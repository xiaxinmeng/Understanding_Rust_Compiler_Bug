{"sha": "089d12274633f9446335b3a181357cbc0b71b96e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDg5ZDEyMjc0NjMzZjk0NDYzMzViM2ExODEzNTdjYmMwYjcxYjk2ZQ==", "commit": {"author": {"name": "Ilya Enkovich", "email": "ilya.enkovich@intel.com", "date": "2013-11-29T12:12:39Z"}, "committer": {"name": "Kirill Yukhin", "email": "kyukhin@gcc.gnu.org", "date": "2013-11-29T12:12:39Z"}, "message": "revert: cgraph.h (varpool_node): Add need_bounds_init field.\n\n\tReverted:\n\t2013-11-20  Ilya Enkovich  <ilya.enkovich@intel.com>\n\t* cgraph.h (varpool_node): Add need_bounds_init field.\n\t* lto-cgraph.c (lto_output_varpool_node): Output\n\tneed_bounds_init value.\n\t(input_varpool_node): Read need_bounds_init value.\n\t* varpool.c (dump_varpool_node): Dump need_bounds_init field.\n\n\tReverted:\n\t2013-11-20  Ilya Enkovich  <ilya.enkovich@intel.com>\n\t* dbxout.c (dbxout_type): Ignore POINTER_BOUNDS_TYPE.\n\t* dwarf2out.c (gen_subprogram_die): Ignore bound args.\n\t(gen_type_die_with_usage): Skip pointer bounds.\n\t(dwarf2out_global_decl): Likewise.\n\n\tReverted:\n\t2013-11-18  Ilya Enkovich  <ilya.enkovich@intel.com>\n\t* builtin-types.def (BT_FN_PTR_CONST_PTR_VAR): New.\n\t* chkp-builtins.def (BUILT_IN_CHKP_BIND_BOUNDS): New.\n\t* cfgexpand.c (expand_call_stmt): Expand BUILT_IN_CHKP_BIND_BOUNDS.\n\t* gimple.c (gimple_call_get_nobnd_arg_index): Remove.\n\t* gimple.h (gf_mask): Add GF_CALL_WITH_BOUNDS.\n\t(gimple_call_with_bounds_p): New.\n\t(gimple_call_set_with_bounds): New.\n\t(gimple_call_num_nobnd_args): Remove.\n\t(gimple_call_nobnd_arg): Remove.\n\t* tree.h (CALL_WITH_BOUNDS_P): New.\n\t* rtl.h (CALL_EXPR_WITH_BOUNDS_P): New.\n\n\tReverted:\n\t2013-11-08  Ilya Enkovich  <ilya.enkovich@intel.com>\n\t* common.opt (fcheck-pointer-bounds): Move to ...\n\t* c-family/c.opt: ... here.\n\t* langhooks-def.h (LANG_HOOKS_CHKP_SUPPORTED): Remove.\n\t(LANG_HOOKS_INITIALIZER): Remove LANG_HOOKS_CHKP_SUPPORTED.\n\t* langhooks.h (lang_hooks): Remove chkp_supported field.\n\t* toplev.c (process_options): Remove chkp_supported check.\n\n\tReverted:\n\t2013-10-30  Ilya Enkovich  <ilya.enkovich@intel.com>\n\t* tree-core.h (tree_index): Add TI_POINTER_BOUNDS_TYPE.\n\t* tree.h (POINTER_BOUNDS_P): New.\n\t(BOUNDED_TYPE_P): New.\n\t(BOUNDED_P): New.\n\t(pointer_bounds_type_node): New.\n\t* tree.c (build_common_tree_nodes): Initialize\n\tpointer_bounds_type_node.\n\t* gimple.h (gimple_call_get_nobnd_arg_index): New.\n\t(gimple_call_num_nobnd_args): New.\n\t(gimple_call_nobnd_arg): New.\n\t(gimple_return_retbnd): New.\n\t(gimple_return_set_retbnd): New\n\t* gimple.c (gimple_build_return): Increase number of ops\n\tfor return statement.\n\t(gimple_call_get_nobnd_arg_index): New.\n\t* gimple-pretty-print.c (dump_gimple_return): Print second op.\n\n\tReverted:\n\t2013-10-30  Ilya Enkovich  <ilya.enkovich@intel.com>\n\t* ipa.c (cgraph_build_static_cdtor_1): Support contructors\n\twith \"chkp ctor\" and \"bnd_legacy\" attributes.\n\t* gimplify.c (gimplify_init_constructor): Avoid infinite\n\tloop during gimplification of bounds initializer.\n\n\tReverted:\n\t2013-10-30  Ilya Enkovich  <ilya.enkovich@intel.com>\n\t* c-family/c-common.c (handle_bnd_variable_size_attribute): New.\n\t(handle_bnd_legacy): New.\n\t(c_common_attribute_table): Add bnd_variable_size and bnd_legacy.\n\t* doc/extend.texi: Document bnd_variable_size and bnd_legacy\n\tattributes.\n\n\tReverted:\n\t2013-10-29  Ilya Enkovich  <ilya.enkovich@intel.com>\n\t* builtin-types.def (BT_FN_VOID_CONST_PTR): New.\n\t(BT_FN_PTR_CONST_PTR): New.\n\t(BT_FN_CONST_PTR_CONST_PTR): New.\n\t(BT_FN_PTR_CONST_PTR_SIZE): New.\n\t(BT_FN_PTR_CONST_PTR_CONST_PTR): New.\n\t(BT_FN_VOID_PTRPTR_CONST_PTR): New.\n\t(BT_FN_VOID_CONST_PTR_SIZE): New.\n\t(BT_FN_PTR_CONST_PTR_CONST_PTR_SIZE): New.\n\t* chkp-builtins.def: New.\n\t* builtins.def: include chkp-builtins.def.\n\t(DEF_CHKP_BUILTIN): New.\n\t* builtins.c (expand_builtin): Support BUILT_IN_CHKP_INIT_PTR_BOUNDS,\n\tBUILT_IN_CHKP_NULL_PTR_BOUNDS, BUILT_IN_CHKP_COPY_PTR_BOUNDS,\n\tBUILT_IN_CHKP_CHECK_PTR_LBOUNDS, BUILT_IN_CHKP_CHECK_PTR_UBOUNDS,\n\tBUILT_IN_CHKP_CHECK_PTR_BOUNDS, BUILT_IN_CHKP_SET_PTR_BOUNDS,\n\tBUILT_IN_CHKP_NARROW_PTR_BOUNDS, BUILT_IN_CHKP_STORE_PTR_BOUNDS,\n\tBUILT_IN_CHKP_GET_PTR_LBOUND, BUILT_IN_CHKP_GET_PTR_UBOUND,\n\tBUILT_IN_CHKP_BNDMK, BUILT_IN_CHKP_BNDSTX, BUILT_IN_CHKP_BNDCL,\n\tBUILT_IN_CHKP_BNDCU, BUILT_IN_CHKP_BNDLDX, BUILT_IN_CHKP_BNDRET,\n\tBUILT_IN_CHKP_INTERSECT, BUILT_IN_CHKP_ARG_BND, BUILT_IN_CHKP_NARROW,\n\tBUILT_IN_CHKP_EXTRACT_LOWER, BUILT_IN_CHKP_EXTRACT_UPPER.\n\t* common.opt (fcheck-pointer-bounds): New.\n\t* toplev.c (process_options): Check Pointer Bounds Checker is\n\tsupported.\n\t* doc/extend.texi: Document Pointer Bounds Checker built-in functions.\n\n\tReverted:\n\t2013-10-30  Ilya Enkovich  <ilya.enkovich@intel.com>\n\t* target.def (builtin_chkp_function): New.\n\t(chkp_bound_type): New.\n\t(chkp_bound_mode): New.\n\t(fn_abi_va_list_bounds_size): New.\n\t(load_bounds_for_arg): New.\n\t(store_bounds_for_arg): New.\n\t* targhooks.h (default_load_bounds_for_arg): New.\n\t(default_store_bounds_for_arg): New.\n\t(default_fn_abi_va_list_bounds_size): New.\n\t(default_chkp_bound_type): New.\n\t(default_chkp_bound_mode): New.\n\t(default_builtin_chkp_function): New.\n\t* targhooks.c (default_load_bounds_for_arg): New.\n\t(default_store_bounds_for_arg): New.\n\t(default_fn_abi_va_list_bounds_size): New.\n\t(default_chkp_bound_type): New.\n\t(default_chkp_bound_mode); New.\n\t(default_builtin_chkp_function): New.\n\t* doc/tm.texi.in (TARGET_FN_ABI_VA_LIST_BOUNDS_SIZE): New.\n\t(TARGET_LOAD_BOUNDS_FOR_ARG): New.\n\t(TARGET_STORE_BOUNDS_FOR_ARG): New.\n\t(TARGET_BUILTIN_CHKP_FUNCTION): New.\n\t(TARGET_CHKP_BOUND_TYPE): New.\n\t(TARGET_CHKP_BOUND_MODE): New.\n\t* doc/tm.texi: Regenerated.\n\t* langhooks.h (lang_hooks): Add chkp_supported field.\n\t* langhooks-def.h (LANG_HOOKS_CHKP_SUPPORTED): New.\n\t(LANG_HOOKS_INITIALIZER); Add LANG_HOOKS_CHKP_SUPPORTED.\n\n\tReverted:\n\t2013-10-24  Ilya Enkovich  <ilya.enkovich@intel.com>\n\t* config/i386/constraints.md (B): New.\n\t(Ti): New.\n\t(Tb): New.\n\t* config/i386/i386-c.c (ix86_target_macros_internal): Add __MPX__.\n\t* config/i386/i386-modes.def (BND32): New.\n\t(BND64): New.\n\t* config/i386/i386-protos.h (ix86_bnd_prefixed_insn_p): New.\n\t* config/i386/i386.c (isa_opts): Add mmpx.\n\t(regclass_map): Add bound registers.\n\t(dbx_register_map): Likewise.\n\t(dbx64_register_map): Likewise.\n\t(svr4_dbx_register_map): Likewise.\n\t(PTA_MPX): New.\n\t(ix86_option_override_internal): Support MPX ISA.\n\t(ix86_conditional_register_usage): Support bound registers.\n\t(print_reg): Likewise.\n\t(ix86_code_end): Add MPX bnd prefix.\n\t(output_set_got): Likewise.\n\t(ix86_output_call_insn): Likewise.\n\t(ix86_print_operand): Add '!' (MPX bnd) print prefix support.\n\t(ix86_print_operand_punct_valid_p): Likewise.\n\t(ix86_print_operand_address): Support UNSPEC_BNDMK_ADDR and\n\tUNSPEC_BNDMK_ADDR.\n\t(ix86_class_likely_spilled_p): Add bound regs support.\n\t(ix86_hard_regno_mode_ok): Likewise.\n\t(x86_order_regs_for_local_alloc): Likewise.\n\t(ix86_bnd_prefixed_insn_p): New.\n\t* config/i386/i386.h (FIRST_PSEUDO_REGISTER): Fix to new value.\n\t(FIXED_REGISTERS): Add bound registers.\n\t(CALL_USED_REGISTERS): Likewise.\n\t(REG_ALLOC_ORDER): Likewise.\n\t(HARD_REGNO_NREGS): Likewise.\n\t(TARGET_MPX): New.\n\t(VALID_BND_REG_MODE): New.\n\t(FIRST_BND_REG): New.\n\t(LAST_BND_REG): New.\n\t(reg_class): Add BND_REGS.\n\t(REG_CLASS_NAMES): Likewise.\n\t(REG_CLASS_CONTENTS): Likewise.\n\t(BND_REGNO_P): New.\n\t(ANY_BND_REG_P): New.\n\t(BNDmode): New.\n\t(HI_REGISTER_NAMES): Add bound registers.\n\t* config/i386/i386.md (UNSPEC_BNDMK): New.\n\t(UNSPEC_BNDMK_ADDR): New.\n\t(UNSPEC_BNDSTX): New.\n\t(UNSPEC_BNDLDX): New.\n\t(UNSPEC_BNDLDX_ADDR): New.\n\t(UNSPEC_BNDCL): New.\n\t(UNSPEC_BNDCU): New.\n\t(UNSPEC_BNDCN): New.\n\t(UNSPEC_MPX_FENCE): New.\n\t(BND0_REG): New.\n\t(BND1_REG): New.\n\t(type): Add mpxmov, mpxmk, mpxchk, mpxld, mpxst.\n\t(length_immediate): Likewise.\n\t(prefix_0f): Likewise.\n\t(memory): Likewise.\n\t(prefix_rep): Check for bnd prefix.\n\t(length_nobnd): New.\n\t(length): Use length_nobnd if specified.\n\t(BND): New.\n\t(bnd_ptr): New.\n\t(BNDCHECK): New.\n\t(bndcheck): New.\n\t(*jcc_1): Add bnd prefix and rename length attr to length_nobnd.\n\t(*jcc_2): Likewise.\n\t(jump): Likewise.\n\t(simple_return_internal): Likewise.\n\t(simple_return_pop_internal): Likewise.\n\t(*indirect_jump): Add MPX bnd prefix.\n\t(*tablejump_1): Likewise.\n\t(simple_return_internal_long): Likewise.\n\t(simple_return_indirect_internal): Likewise.\n\t(<mode>_mk): New.\n\t(*<mode>_mk): New.\n\t(mov<mode>): New.\n\t(*mov<mode>_internal_mpx): New.\n\t(<mode>_<bndcheck>): New.\n\t(*<mode>_<bndcheck>): New.\n\t(<mode>_ldx): New.\n\t(*<mode>_ldx): New.\n\t(<mode>_stx): New.\n\t(*<mode>_stx): New.\n\t* config/i386/predicates.md (lea_address_operand): Rename to...\n\t(address_no_seg_operand): ... this.\n\t(address_mpx_no_base_operand): New.\n\t(address_mpx_no_index_operand): New.\n\t(bnd_mem_operator): New.\n\t* config/i386/i386.opt (mmpx): New.\n\t* doc/invoke.texi: Add documentation for the flags -mmpx, -mno-mpx.\n\t* doc/rtl.texi Add documentation for BND32mode and BND64mode.\n\n\tReverted:\n\t2013-10-24  Ilya Enkovich  <ilya.enkovich@intel.com>\n\t* mode-classes.def (MODE_POINTER_BOUNDS): New.\n\t* tree.def (POINTER_BOUNDS_TYPE): New.\n\t* genmodes.c (complete_mode): Support MODE_POINTER_BOUNDS.\n\t(POINTER_BOUNDS_MODE): New.\n\t(make_pointer_bounds_mode): New.\n\t* machmode.h (POINTER_BOUNDS_MODE_P): New.\n\t* stor-layout.c (int_mode_for_mode): Support MODE_POINTER_BOUNDS.\n\t(layout_type): Support POINTER_BOUNDS_TYPE.\n\t* tree-pretty-print.c (dump_generic_node): Support POINTER_BOUNDS_TYPE.\n\t* tree.c (build_int_cst_wide): Support POINTER_BOUNDS_TYPE.\n\t(type_contains_placeholder_1): Likewise.\n\t* tree.h (POINTER_BOUNDS_TYPE_P): New.\n\t* varasm.c (output_constant): Support POINTER_BOUNDS_TYPE.\n\t* doc/rtl.texi (MODE_POINTER_BOUNDS): New.\n\nFrom-SVN: r205522", "tree": {"sha": "a9419c14461cb91513d4f9dac632dbff36693565", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9419c14461cb91513d4f9dac632dbff36693565"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/089d12274633f9446335b3a181357cbc0b71b96e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/089d12274633f9446335b3a181357cbc0b71b96e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/089d12274633f9446335b3a181357cbc0b71b96e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/089d12274633f9446335b3a181357cbc0b71b96e/comments", "author": {"login": "ienkovich", "id": 18308708, "node_id": "MDQ6VXNlcjE4MzA4NzA4", "avatar_url": "https://avatars.githubusercontent.com/u/18308708?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ienkovich", "html_url": "https://github.com/ienkovich", "followers_url": "https://api.github.com/users/ienkovich/followers", "following_url": "https://api.github.com/users/ienkovich/following{/other_user}", "gists_url": "https://api.github.com/users/ienkovich/gists{/gist_id}", "starred_url": "https://api.github.com/users/ienkovich/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ienkovich/subscriptions", "organizations_url": "https://api.github.com/users/ienkovich/orgs", "repos_url": "https://api.github.com/users/ienkovich/repos", "events_url": "https://api.github.com/users/ienkovich/events{/privacy}", "received_events_url": "https://api.github.com/users/ienkovich/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b8815bd32f6029b77dc97143edc6d39aa5e014df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8815bd32f6029b77dc97143edc6d39aa5e014df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8815bd32f6029b77dc97143edc6d39aa5e014df"}], "stats": {"total": 1672, "additions": 338, "deletions": 1334}, "files": [{"sha": "b40ff365aea6feff402cc1acf53fd07fff55262c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 245, "deletions": 0, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -1,3 +1,248 @@\n+2013-11-29  Ilya Enkovich  <ilya.enkovich@intel.com>\n+\n+\tReverted:\n+\t2013-11-20  Ilya Enkovich  <ilya.enkovich@intel.com>\n+\t* cgraph.h (varpool_node): Add need_bounds_init field.\n+\t* lto-cgraph.c (lto_output_varpool_node): Output\n+\tneed_bounds_init value.\n+\t(input_varpool_node): Read need_bounds_init value.\n+\t* varpool.c (dump_varpool_node): Dump need_bounds_init field.\n+\n+\tReverted:\n+\t2013-11-20  Ilya Enkovich  <ilya.enkovich@intel.com>\n+\t* dbxout.c (dbxout_type): Ignore POINTER_BOUNDS_TYPE.\n+\t* dwarf2out.c (gen_subprogram_die): Ignore bound args.\n+\t(gen_type_die_with_usage): Skip pointer bounds.\n+\t(dwarf2out_global_decl): Likewise.\n+\n+\tReverted:\n+\t2013-11-18  Ilya Enkovich  <ilya.enkovich@intel.com>\n+\t* builtin-types.def (BT_FN_PTR_CONST_PTR_VAR): New.\n+\t* chkp-builtins.def (BUILT_IN_CHKP_BIND_BOUNDS): New.\n+\t* cfgexpand.c (expand_call_stmt): Expand BUILT_IN_CHKP_BIND_BOUNDS.\n+\t* gimple.c (gimple_call_get_nobnd_arg_index): Remove.\n+\t* gimple.h (gf_mask): Add GF_CALL_WITH_BOUNDS.\n+\t(gimple_call_with_bounds_p): New.\n+\t(gimple_call_set_with_bounds): New.\n+\t(gimple_call_num_nobnd_args): Remove.\n+\t(gimple_call_nobnd_arg): Remove.\n+\t* tree.h (CALL_WITH_BOUNDS_P): New.\n+\t* rtl.h (CALL_EXPR_WITH_BOUNDS_P): New.\n+\n+\tReverted:\n+\t2013-11-08  Ilya Enkovich  <ilya.enkovich@intel.com>\n+\t* common.opt (fcheck-pointer-bounds): Move to ...\n+\t* c-family/c.opt: ... here.\n+\t* langhooks-def.h (LANG_HOOKS_CHKP_SUPPORTED): Remove.\n+\t(LANG_HOOKS_INITIALIZER): Remove LANG_HOOKS_CHKP_SUPPORTED.\n+\t* langhooks.h (lang_hooks): Remove chkp_supported field.\n+\t* toplev.c (process_options): Remove chkp_supported check.\n+\n+\tReverted:\n+\t2013-10-30  Ilya Enkovich  <ilya.enkovich@intel.com>\n+\t* tree-core.h (tree_index): Add TI_POINTER_BOUNDS_TYPE.\n+\t* tree.h (POINTER_BOUNDS_P): New.\n+\t(BOUNDED_TYPE_P): New.\n+\t(BOUNDED_P): New.\n+\t(pointer_bounds_type_node): New.\n+\t* tree.c (build_common_tree_nodes): Initialize\n+\tpointer_bounds_type_node.\n+\t* gimple.h (gimple_call_get_nobnd_arg_index): New.\n+\t(gimple_call_num_nobnd_args): New.\n+\t(gimple_call_nobnd_arg): New.\n+\t(gimple_return_retbnd): New.\n+\t(gimple_return_set_retbnd): New\n+\t* gimple.c (gimple_build_return): Increase number of ops\n+\tfor return statement.\n+\t(gimple_call_get_nobnd_arg_index): New.\n+\t* gimple-pretty-print.c (dump_gimple_return): Print second op.\n+\n+\tReverted:\n+\t2013-10-30  Ilya Enkovich  <ilya.enkovich@intel.com>\n+\t* ipa.c (cgraph_build_static_cdtor_1): Support contructors\n+\twith \"chkp ctor\" and \"bnd_legacy\" attributes.\n+\t* gimplify.c (gimplify_init_constructor): Avoid infinite\n+\tloop during gimplification of bounds initializer.\n+\n+\tReverted:\n+\t2013-10-30  Ilya Enkovich  <ilya.enkovich@intel.com>\n+\t* c-family/c-common.c (handle_bnd_variable_size_attribute): New.\n+\t(handle_bnd_legacy): New.\n+\t(c_common_attribute_table): Add bnd_variable_size and bnd_legacy.\n+\t* doc/extend.texi: Document bnd_variable_size and bnd_legacy\n+\tattributes.\n+\n+\tReverted:\n+\t2013-10-29  Ilya Enkovich  <ilya.enkovich@intel.com>\n+\t* builtin-types.def (BT_FN_VOID_CONST_PTR): New.\n+\t(BT_FN_PTR_CONST_PTR): New.\n+\t(BT_FN_CONST_PTR_CONST_PTR): New.\n+\t(BT_FN_PTR_CONST_PTR_SIZE): New.\n+\t(BT_FN_PTR_CONST_PTR_CONST_PTR): New.\n+\t(BT_FN_VOID_PTRPTR_CONST_PTR): New.\n+\t(BT_FN_VOID_CONST_PTR_SIZE): New.\n+\t(BT_FN_PTR_CONST_PTR_CONST_PTR_SIZE): New.\n+\t* chkp-builtins.def: New.\n+\t* builtins.def: include chkp-builtins.def.\n+\t(DEF_CHKP_BUILTIN): New.\n+\t* builtins.c (expand_builtin): Support BUILT_IN_CHKP_INIT_PTR_BOUNDS,\n+\tBUILT_IN_CHKP_NULL_PTR_BOUNDS, BUILT_IN_CHKP_COPY_PTR_BOUNDS,\n+\tBUILT_IN_CHKP_CHECK_PTR_LBOUNDS, BUILT_IN_CHKP_CHECK_PTR_UBOUNDS,\n+\tBUILT_IN_CHKP_CHECK_PTR_BOUNDS, BUILT_IN_CHKP_SET_PTR_BOUNDS,\n+\tBUILT_IN_CHKP_NARROW_PTR_BOUNDS, BUILT_IN_CHKP_STORE_PTR_BOUNDS,\n+\tBUILT_IN_CHKP_GET_PTR_LBOUND, BUILT_IN_CHKP_GET_PTR_UBOUND,\n+\tBUILT_IN_CHKP_BNDMK, BUILT_IN_CHKP_BNDSTX, BUILT_IN_CHKP_BNDCL,\n+\tBUILT_IN_CHKP_BNDCU, BUILT_IN_CHKP_BNDLDX, BUILT_IN_CHKP_BNDRET,\n+\tBUILT_IN_CHKP_INTERSECT, BUILT_IN_CHKP_ARG_BND, BUILT_IN_CHKP_NARROW,\n+\tBUILT_IN_CHKP_EXTRACT_LOWER, BUILT_IN_CHKP_EXTRACT_UPPER.\n+\t* common.opt (fcheck-pointer-bounds): New.\n+\t* toplev.c (process_options): Check Pointer Bounds Checker is\n+\tsupported.\n+\t* doc/extend.texi: Document Pointer Bounds Checker built-in functions.\n+\n+\tReverted:\n+\t2013-10-30  Ilya Enkovich  <ilya.enkovich@intel.com>\n+\t* target.def (builtin_chkp_function): New.\n+\t(chkp_bound_type): New.\n+\t(chkp_bound_mode): New.\n+\t(fn_abi_va_list_bounds_size): New.\n+\t(load_bounds_for_arg): New.\n+\t(store_bounds_for_arg): New.\n+\t* targhooks.h (default_load_bounds_for_arg): New.\n+\t(default_store_bounds_for_arg): New.\n+\t(default_fn_abi_va_list_bounds_size): New.\n+\t(default_chkp_bound_type): New.\n+\t(default_chkp_bound_mode): New.\n+\t(default_builtin_chkp_function): New.\n+\t* targhooks.c (default_load_bounds_for_arg): New.\n+\t(default_store_bounds_for_arg): New.\n+\t(default_fn_abi_va_list_bounds_size): New.\n+\t(default_chkp_bound_type): New.\n+\t(default_chkp_bound_mode); New.\n+\t(default_builtin_chkp_function): New.\n+\t* doc/tm.texi.in (TARGET_FN_ABI_VA_LIST_BOUNDS_SIZE): New.\n+\t(TARGET_LOAD_BOUNDS_FOR_ARG): New.\n+\t(TARGET_STORE_BOUNDS_FOR_ARG): New.\n+\t(TARGET_BUILTIN_CHKP_FUNCTION): New.\n+\t(TARGET_CHKP_BOUND_TYPE): New.\n+\t(TARGET_CHKP_BOUND_MODE): New.\n+\t* doc/tm.texi: Regenerated.\n+\t* langhooks.h (lang_hooks): Add chkp_supported field.\n+\t* langhooks-def.h (LANG_HOOKS_CHKP_SUPPORTED): New.\n+\t(LANG_HOOKS_INITIALIZER); Add LANG_HOOKS_CHKP_SUPPORTED.\n+\n+\tReverted:\n+\t2013-10-24  Ilya Enkovich  <ilya.enkovich@intel.com>\n+\t* config/i386/constraints.md (B): New.\n+\t(Ti): New.\n+\t(Tb): New.\n+\t* config/i386/i386-c.c (ix86_target_macros_internal): Add __MPX__.\n+\t* config/i386/i386-modes.def (BND32): New.\n+\t(BND64): New.\n+\t* config/i386/i386-protos.h (ix86_bnd_prefixed_insn_p): New.\n+\t* config/i386/i386.c (isa_opts): Add mmpx.\n+\t(regclass_map): Add bound registers.\n+\t(dbx_register_map): Likewise.\n+\t(dbx64_register_map): Likewise.\n+\t(svr4_dbx_register_map): Likewise.\n+\t(PTA_MPX): New.\n+\t(ix86_option_override_internal): Support MPX ISA.\n+\t(ix86_conditional_register_usage): Support bound registers.\n+\t(print_reg): Likewise.\n+\t(ix86_code_end): Add MPX bnd prefix.\n+\t(output_set_got): Likewise.\n+\t(ix86_output_call_insn): Likewise.\n+\t(ix86_print_operand): Add '!' (MPX bnd) print prefix support.\n+\t(ix86_print_operand_punct_valid_p): Likewise.\n+\t(ix86_print_operand_address): Support UNSPEC_BNDMK_ADDR and\n+\tUNSPEC_BNDMK_ADDR.\n+\t(ix86_class_likely_spilled_p): Add bound regs support.\n+\t(ix86_hard_regno_mode_ok): Likewise.\n+\t(x86_order_regs_for_local_alloc): Likewise.\n+\t(ix86_bnd_prefixed_insn_p): New.\n+\t* config/i386/i386.h (FIRST_PSEUDO_REGISTER): Fix to new value.\n+\t(FIXED_REGISTERS): Add bound registers.\n+\t(CALL_USED_REGISTERS): Likewise.\n+\t(REG_ALLOC_ORDER): Likewise.\n+\t(HARD_REGNO_NREGS): Likewise.\n+\t(TARGET_MPX): New.\n+\t(VALID_BND_REG_MODE): New.\n+\t(FIRST_BND_REG): New.\n+\t(LAST_BND_REG): New.\n+\t(reg_class): Add BND_REGS.\n+\t(REG_CLASS_NAMES): Likewise.\n+\t(REG_CLASS_CONTENTS): Likewise.\n+\t(BND_REGNO_P): New.\n+\t(ANY_BND_REG_P): New.\n+\t(BNDmode): New.\n+\t(HI_REGISTER_NAMES): Add bound registers.\n+\t* config/i386/i386.md (UNSPEC_BNDMK): New.\n+\t(UNSPEC_BNDMK_ADDR): New.\n+\t(UNSPEC_BNDSTX): New.\n+\t(UNSPEC_BNDLDX): New.\n+\t(UNSPEC_BNDLDX_ADDR): New.\n+\t(UNSPEC_BNDCL): New.\n+\t(UNSPEC_BNDCU): New.\n+\t(UNSPEC_BNDCN): New.\n+\t(UNSPEC_MPX_FENCE): New.\n+\t(BND0_REG): New.\n+\t(BND1_REG): New.\n+\t(type): Add mpxmov, mpxmk, mpxchk, mpxld, mpxst.\n+\t(length_immediate): Likewise.\n+\t(prefix_0f): Likewise.\n+\t(memory): Likewise.\n+\t(prefix_rep): Check for bnd prefix.\n+\t(length_nobnd): New.\n+\t(length): Use length_nobnd if specified.\n+\t(BND): New.\n+\t(bnd_ptr): New.\n+\t(BNDCHECK): New.\n+\t(bndcheck): New.\n+\t(*jcc_1): Add bnd prefix and rename length attr to length_nobnd.\n+\t(*jcc_2): Likewise.\n+\t(jump): Likewise.\n+\t(simple_return_internal): Likewise.\n+\t(simple_return_pop_internal): Likewise.\n+\t(*indirect_jump): Add MPX bnd prefix.\n+\t(*tablejump_1): Likewise.\n+\t(simple_return_internal_long): Likewise.\n+\t(simple_return_indirect_internal): Likewise.\n+\t(<mode>_mk): New.\n+\t(*<mode>_mk): New.\n+\t(mov<mode>): New.\n+\t(*mov<mode>_internal_mpx): New.\n+\t(<mode>_<bndcheck>): New.\n+\t(*<mode>_<bndcheck>): New.\n+\t(<mode>_ldx): New.\n+\t(*<mode>_ldx): New.\n+\t(<mode>_stx): New.\n+\t(*<mode>_stx): New.\n+\t* config/i386/predicates.md (lea_address_operand): Rename to...\n+\t(address_no_seg_operand): ... this.\n+\t(address_mpx_no_base_operand): New.\n+\t(address_mpx_no_index_operand): New.\n+\t(bnd_mem_operator): New.\n+\t* config/i386/i386.opt (mmpx): New.\n+\t* doc/invoke.texi: Add documentation for the flags -mmpx, -mno-mpx.\n+\t* doc/rtl.texi Add documentation for BND32mode and BND64mode.\n+\n+\tReverted:\n+\t2013-10-24  Ilya Enkovich  <ilya.enkovich@intel.com>\n+\t* mode-classes.def (MODE_POINTER_BOUNDS): New.\n+\t* tree.def (POINTER_BOUNDS_TYPE): New.\n+\t* genmodes.c (complete_mode): Support MODE_POINTER_BOUNDS.\n+\t(POINTER_BOUNDS_MODE): New.\n+\t(make_pointer_bounds_mode): New.\n+\t* machmode.h (POINTER_BOUNDS_MODE_P): New.\n+\t* stor-layout.c (int_mode_for_mode): Support MODE_POINTER_BOUNDS.\n+\t(layout_type): Support POINTER_BOUNDS_TYPE.\n+\t* tree-pretty-print.c (dump_generic_node): Support POINTER_BOUNDS_TYPE.\n+\t* tree.c (build_int_cst_wide): Support POINTER_BOUNDS_TYPE.\n+\t(type_contains_placeholder_1): Likewise.\n+\t* tree.h (POINTER_BOUNDS_TYPE_P): New.\n+\t* varasm.c (output_constant): Support POINTER_BOUNDS_TYPE.\n+\t* doc/rtl.texi (MODE_POINTER_BOUNDS): New.\n+\n 2013-11-29  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/59338"}, {"sha": "e1054088ceec3b5e9ae126922b4400be499295e0", "filename": "gcc/builtin-types.def", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fbuiltin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fbuiltin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-types.def?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -234,8 +234,6 @@ DEF_FUNCTION_TYPE_1 (BT_FN_UINT16_UINT16, BT_UINT16, BT_UINT16)\n DEF_FUNCTION_TYPE_1 (BT_FN_UINT32_UINT32, BT_UINT32, BT_UINT32)\n DEF_FUNCTION_TYPE_1 (BT_FN_UINT64_UINT64, BT_UINT64, BT_UINT64)\n DEF_FUNCTION_TYPE_1 (BT_FN_BOOL_INT, BT_BOOL, BT_INT)\n-DEF_FUNCTION_TYPE_1 (BT_FN_PTR_CONST_PTR, BT_PTR, BT_CONST_PTR)\n-DEF_FUNCTION_TYPE_1 (BT_FN_CONST_PTR_CONST_PTR, BT_CONST_PTR, BT_CONST_PTR)\n \n DEF_POINTER_TYPE (BT_PTR_FN_VOID_PTR, BT_FN_VOID_PTR)\n \n@@ -349,10 +347,6 @@ DEF_FUNCTION_TYPE_2 (BT_FN_BOOL_SIZE_CONST_VPTR, BT_BOOL, BT_SIZE,\n \t\t     BT_CONST_VOLATILE_PTR)\n DEF_FUNCTION_TYPE_2 (BT_FN_BOOL_INT_BOOL, BT_BOOL, BT_INT, BT_BOOL)\n DEF_FUNCTION_TYPE_2 (BT_FN_VOID_UINT_UINT, BT_VOID, BT_UINT, BT_UINT)\n-DEF_FUNCTION_TYPE_2 (BT_FN_PTR_CONST_PTR_SIZE, BT_PTR, BT_CONST_PTR, BT_SIZE)\n-DEF_FUNCTION_TYPE_2 (BT_FN_PTR_CONST_PTR_CONST_PTR, BT_PTR, BT_CONST_PTR, BT_CONST_PTR)\n-DEF_FUNCTION_TYPE_2 (BT_FN_VOID_PTRPTR_CONST_PTR, BT_VOID, BT_PTR_PTR, BT_CONST_PTR)\n-DEF_FUNCTION_TYPE_2 (BT_FN_VOID_CONST_PTR_SIZE, BT_VOID, BT_CONST_PTR, BT_SIZE)\n \n DEF_POINTER_TYPE (BT_PTR_FN_VOID_PTR_PTR, BT_FN_VOID_PTR_PTR)\n \n@@ -435,7 +429,6 @@ DEF_FUNCTION_TYPE_3 (BT_FN_VOID_VPTR_I2_INT, BT_VOID, BT_VOLATILE_PTR, BT_I2, BT\n DEF_FUNCTION_TYPE_3 (BT_FN_VOID_VPTR_I4_INT, BT_VOID, BT_VOLATILE_PTR, BT_I4, BT_INT)\n DEF_FUNCTION_TYPE_3 (BT_FN_VOID_VPTR_I8_INT, BT_VOID, BT_VOLATILE_PTR, BT_I8, BT_INT)\n DEF_FUNCTION_TYPE_3 (BT_FN_VOID_VPTR_I16_INT, BT_VOID, BT_VOLATILE_PTR, BT_I16, BT_INT)\n-DEF_FUNCTION_TYPE_3 (BT_FN_PTR_CONST_PTR_CONST_PTR_SIZE, BT_PTR, BT_CONST_PTR, BT_CONST_PTR, BT_SIZE)\n \n DEF_FUNCTION_TYPE_4 (BT_FN_SIZE_CONST_PTR_SIZE_SIZE_FILEPTR,\n \t\t     BT_SIZE, BT_CONST_PTR, BT_SIZE, BT_SIZE, BT_FILEPTR)\n@@ -542,8 +535,6 @@ DEF_FUNCTION_TYPE_VAR_1 (BT_FN_INT_CONST_STRING_VAR,\n \t\t\t BT_INT, BT_CONST_STRING)\n DEF_FUNCTION_TYPE_VAR_1 (BT_FN_UINT32_UINT32_VAR,\n \t\t\t BT_UINT32, BT_UINT32)\n-DEF_FUNCTION_TYPE_VAR_1 (BT_FN_PTR_CONST_PTR_VAR,\n-\t\t\t BT_PTR, BT_CONST_PTR)\n \n DEF_FUNCTION_TYPE_VAR_2 (BT_FN_INT_FILEPTR_CONST_STRING_VAR,\n \t\t\t BT_INT, BT_FILEPTR, BT_CONST_STRING)"}, {"sha": "4f1c8180a5b05d3dec92ac97f7211112c82a8e3b", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 57, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -5787,18 +5787,7 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n       && fcode != BUILT_IN_EXECVE\n       && fcode != BUILT_IN_ALLOCA\n       && fcode != BUILT_IN_ALLOCA_WITH_ALIGN\n-      && fcode != BUILT_IN_FREE\n-      && fcode != BUILT_IN_CHKP_SET_PTR_BOUNDS\n-      && fcode != BUILT_IN_CHKP_INIT_PTR_BOUNDS\n-      && fcode != BUILT_IN_CHKP_NULL_PTR_BOUNDS\n-      && fcode != BUILT_IN_CHKP_COPY_PTR_BOUNDS\n-      && fcode != BUILT_IN_CHKP_NARROW_PTR_BOUNDS\n-      && fcode != BUILT_IN_CHKP_STORE_PTR_BOUNDS\n-      && fcode != BUILT_IN_CHKP_CHECK_PTR_LBOUNDS\n-      && fcode != BUILT_IN_CHKP_CHECK_PTR_UBOUNDS\n-      && fcode != BUILT_IN_CHKP_CHECK_PTR_BOUNDS\n-      && fcode != BUILT_IN_CHKP_GET_PTR_LBOUND\n-      && fcode != BUILT_IN_CHKP_GET_PTR_UBOUND)\n+      && fcode != BUILT_IN_FREE)\n     return expand_call (exp, target, ignore);\n \n   /* The built-in function expanders test for target == const0_rtx\n@@ -6850,51 +6839,6 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n       expand_builtin_cilk_pop_frame (exp);\n       return const0_rtx;\n \n-    case BUILT_IN_CHKP_INIT_PTR_BOUNDS:\n-    case BUILT_IN_CHKP_NULL_PTR_BOUNDS:\n-    case BUILT_IN_CHKP_COPY_PTR_BOUNDS:\n-      return expand_normal (CALL_EXPR_ARG (exp, 0));\n-\n-    case BUILT_IN_CHKP_CHECK_PTR_LBOUNDS:\n-    case BUILT_IN_CHKP_CHECK_PTR_UBOUNDS:\n-    case BUILT_IN_CHKP_CHECK_PTR_BOUNDS:\n-    case BUILT_IN_CHKP_SET_PTR_BOUNDS:\n-    case BUILT_IN_CHKP_NARROW_PTR_BOUNDS:\n-    case BUILT_IN_CHKP_STORE_PTR_BOUNDS:\n-    case BUILT_IN_CHKP_GET_PTR_LBOUND:\n-    case BUILT_IN_CHKP_GET_PTR_UBOUND:\n-      /* We allow user CHKP builtins if Pointer Bounds\n-\t Checker is off.  */\n-      if (!flag_check_pointer_bounds)\n-\t{\n-\t  if (fcode == BUILT_IN_CHKP_SET_PTR_BOUNDS\n-\t      || fcode == BUILT_IN_CHKP_NARROW_PTR_BOUNDS)\n-\t    return expand_normal (CALL_EXPR_ARG (exp, 0));\n-\t  else if (fcode == BUILT_IN_CHKP_GET_PTR_LBOUND)\n-\t    return expand_normal (size_zero_node);\n-\t  else if (fcode == BUILT_IN_CHKP_GET_PTR_UBOUND)\n-\t    return expand_normal (size_int (-1));\n-\t  else\n-\t    return const0_rtx;\n-\t}\n-      /* FALLTHROUGH */\n-\n-    case BUILT_IN_CHKP_BNDMK:\n-    case BUILT_IN_CHKP_BNDSTX:\n-    case BUILT_IN_CHKP_BNDCL:\n-    case BUILT_IN_CHKP_BNDCU:\n-    case BUILT_IN_CHKP_BNDLDX:\n-    case BUILT_IN_CHKP_BNDRET:\n-    case BUILT_IN_CHKP_INTERSECT:\n-    case BUILT_IN_CHKP_ARG_BND:\n-    case BUILT_IN_CHKP_NARROW:\n-    case BUILT_IN_CHKP_EXTRACT_LOWER:\n-    case BUILT_IN_CHKP_EXTRACT_UPPER:\n-      /* Software implementation of pointers checker is NYI.\n-\t Target support is required.  */\n-      error (\"Your target platform does not support -fcheck-pointers\");\n-      break;\n-\n     default:\t/* just do library call, if unknown builtin */\n       break;\n     }"}, {"sha": "3e3deaa57809e9b32dddaf004ec36fa01ba1a61a", "filename": "gcc/builtins.def", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -176,12 +176,6 @@ along with GCC; see the file COPYING3.  If not see\n   DEF_BUILTIN (ENUM, NAME, BUILT_IN_NORMAL, BT_FN_INT_VAR, BT_LAST, \\\n   \t       false, false, false, ATTRS, false, flag_enable_cilkplus) \n \n-/* Builtin used by the implementation of Pointer Bounds Checker.  */\n-#undef DEF_CHKP_BUILTIN\n-#define DEF_CHKP_BUILTIN(ENUM, NAME, TYPE, ATTRS) \\\n-  DEF_BUILTIN (ENUM, \"__builtin_\" NAME, BUILT_IN_NORMAL, TYPE, TYPE,    \\\n-\t       true, true, false, ATTRS, true, true)\n-\n /* Define an attribute list for math functions that are normally\n    \"impure\" because some of them may write into global memory for\n    `errno'.  If !flag_errno_math they are instead \"const\".  */\n@@ -876,6 +870,3 @@ DEF_GCC_BUILTIN (BUILT_IN_LINE, \"LINE\", BT_FN_INT, ATTR_NOTHROW_LEAF_LIST)\n \n /* Cilk Plus builtins.  */\n #include \"cilkplus.def\"\n-\n-/* Pointer Bounds Checker builtins.  */\n-#include \"chkp-builtins.def\""}, {"sha": "e652802fde180f64b9529611bdadc3341937c9a0", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -382,8 +382,6 @@ static tree handle_omp_declare_simd_attribute (tree *, tree, tree, int,\n \t\t\t\t\t       bool *);\n static tree handle_omp_declare_target_attribute (tree *, tree, tree, int,\n \t\t\t\t\t\t bool *);\n-static tree handle_bnd_variable_size_attribute (tree *, tree, tree, int, bool *);\n-static tree handle_bnd_legacy (tree *, tree, tree, int, bool *);\n \n static void check_function_nonnull (tree, int, tree *);\n static void check_nonnull_arg (void *, tree, unsigned HOST_WIDE_INT);\n@@ -771,10 +769,6 @@ const struct attribute_spec c_common_attribute_table[] =\n \t\t\t      handle_omp_declare_simd_attribute, false },\n   { \"omp declare target\",     0, 0, true, false, false,\n \t\t\t      handle_omp_declare_target_attribute, false },\n-  { \"bnd_variable_size\",      0, 0, true,  false, false,\n-\t\t\t      handle_bnd_variable_size_attribute, false },\n-  { \"bnd_legacy\",             0, 0, true, false, false,\n-\t\t\t      handle_bnd_legacy, false },\n   { NULL,                     0, 0, false, false, false, NULL, false }\n };\n \n@@ -8049,38 +8043,6 @@ handle_fnspec_attribute (tree *node ATTRIBUTE_UNUSED, tree ARG_UNUSED (name),\n   return NULL_TREE;\n }\n \n-/* Handle a \"bnd_variable_size\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_bnd_variable_size_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n-\t\t\t\t    int ARG_UNUSED (flags), bool *no_add_attrs)\n-{\n-  if (TREE_CODE (*node) != FIELD_DECL)\n-    {\n-      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n-      *no_add_attrs = true;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"bnd_legacy\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_bnd_legacy (tree *node, tree name, tree ARG_UNUSED (args),\n-\t\t   int ARG_UNUSED (flags), bool *no_add_attrs)\n-{\n-  if (TREE_CODE (*node) != FUNCTION_DECL)\n-    {\n-      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n-      *no_add_attrs = true;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n /* Handle a \"warn_unused\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n "}, {"sha": "bfca1e0e6f612edffb9abd09a74e9b7035a2781d", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -862,11 +862,6 @@ fcanonical-system-headers\n C ObjC C++ ObjC++\n Where shorter, use canonicalized paths to systems headers.\n \n-fcheck-pointer-bounds\n-C ObjC C++ ObjC++ LTO Report Var(flag_check_pointer_bounds)\n-Add Pointer Bounds Checker instrumentation.  fchkp-* flags are used to\n-control instrumentation.\n-\n fcilkplus\n C ObjC C++ ObjC++ LTO Report Var(flag_enable_cilkplus) Init(0)\n Enable Cilk Plus"}, {"sha": "853ace2c2a172cb6ac8edd8b1642a06fde969160", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -2186,21 +2186,11 @@ expand_call_stmt (gimple stmt)\n       return;\n     }\n \n-  decl = gimple_call_fndecl (stmt);\n-  builtin_p = decl && DECL_BUILT_IN (decl);\n-\n-  /* Bind bounds call is expanded as assignment.  */\n-  if (builtin_p\n-      && DECL_BUILT_IN_CLASS (decl) == BUILT_IN_NORMAL\n-      && DECL_FUNCTION_CODE (decl) == BUILT_IN_CHKP_BIND_BOUNDS)\n-    {\n-      expand_assignment (gimple_call_lhs (stmt),\n-\t\t\t gimple_call_arg (stmt, 0), false);\n-      return;\n-    }\n-\n   exp = build_vl_exp (CALL_EXPR, gimple_call_num_args (stmt) + 3);\n+\n   CALL_EXPR_FN (exp) = gimple_call_fn (stmt);\n+  decl = gimple_call_fndecl (stmt);\n+  builtin_p = decl && DECL_BUILT_IN (decl);\n \n   /* If this is not a builtin function, the function type through which the\n      call is made may be different from the type of the function.  */"}, {"sha": "0d8166a961f4bbebf4e5a8f4d6cbdba683b44768", "filename": "gcc/cgraph.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -628,10 +628,6 @@ class GTY((tag (\"SYMTAB_VARIABLE\"))) varpool_node : public symtab_node {\n   /* Set when variable is scheduled to be assembled.  */\n   unsigned output : 1;\n \n-  /* Set when variable has statically initialized pointer\n-     or is a static bounds variable and needs initalization.  */\n-  unsigned need_bounds_init : 1;\n-\n   /* Set if the variable is dynamically initialized, except for\n      function local statics.   */\n   unsigned dynamically_initialized : 1;"}, {"sha": "b920950d603935a013f0fb5c024a21299689dc31", "filename": "gcc/chkp-builtins.def", "status": "removed", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8815bd32f6029b77dc97143edc6d39aa5e014df/gcc%2Fchkp-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8815bd32f6029b77dc97143edc6d39aa5e014df/gcc%2Fchkp-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fchkp-builtins.def?ref=b8815bd32f6029b77dc97143edc6d39aa5e014df", "patch": "@@ -1,76 +0,0 @@\n-/* This file contains the definitions and documentation for the\n-   builtins used in the GNU compiler.\n-   Copyright (C) 2013 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-/* Before including this file, you should define macros:\n-\n-      DEF_BUILTIN_STUB(ENUM, NAME)\n-      DEF_CHKP_BUILTIN(ENUM, NAME, TYPE, ATTRS)\n-\n-   See builtins.def for details.  */\n-\n-/* Following builtins are used by compiler for Pointer Bounds Checker\n-   instrumentation.  Currently these generic builtins are not\n-   implemented and target has to provide his own version.  See\n-   builtin_chkp_function target hook documentation for more details.  */\n-DEF_BUILTIN_STUB (BUILT_IN_CHKP_BNDMK, \"__chkp_bndmk\")\n-DEF_BUILTIN_STUB (BUILT_IN_CHKP_BNDSTX, \"__chkp_bndstx\")\n-DEF_BUILTIN_STUB (BUILT_IN_CHKP_BNDCL, \"__chkp_bndcl\")\n-DEF_BUILTIN_STUB (BUILT_IN_CHKP_BNDCU, \"__chkp_bndcu\")\n-DEF_BUILTIN_STUB (BUILT_IN_CHKP_BNDLDX, \"__chkp_bndldx\")\n-DEF_BUILTIN_STUB (BUILT_IN_CHKP_BNDRET, \"__chkp_bndret\")\n-DEF_BUILTIN_STUB (BUILT_IN_CHKP_INTERSECT, \"__chkp_intersect\")\n-DEF_BUILTIN_STUB (BUILT_IN_CHKP_ARG_BND, \"__chkp_arg_bnd\")\n-DEF_BUILTIN_STUB (BUILT_IN_CHKP_SIZEOF, \"__chkp_sizeof\")\n-DEF_BUILTIN_STUB (BUILT_IN_CHKP_EXTRACT_LOWER, \"__chkp_extract_lower\")\n-DEF_BUILTIN_STUB (BUILT_IN_CHKP_EXTRACT_UPPER, \"__chkp_extract_upper\")\n-DEF_BUILTIN_STUB (BUILT_IN_CHKP_NARROW, \"__chkp_narrow\")\n-\n-/* Builtins to bind bounds to call arguments.  */\n-DEF_CHKP_BUILTIN (BUILT_IN_CHKP_BIND_BOUNDS, \"__chkp_bind_bounds\", BT_FN_PTR_CONST_PTR_VAR, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-/* Pointer Bounds Checker builtins for users.  Only\n-   BUILT_IN_CHKP_SET_PTR_BOUNDS may be redefined\n-   by target.  Other builtins calls are expanded\n-   in the Pointer Bounds Checker pass.  */\n-DEF_CHKP_BUILTIN (BUILT_IN_CHKP_SET_PTR_BOUNDS, \"__bnd_set_ptr_bounds\", BT_FN_PTR_CONST_PTR_SIZE, ATTR_CONST_NOTHROW_LEAF_LIST)\n-DEF_CHKP_BUILTIN (BUILT_IN_CHKP_INIT_PTR_BOUNDS, \"__bnd_init_ptr_bounds\", BT_FN_PTR_CONST_PTR, ATTR_CONST_NOTHROW_LEAF_LIST)\n-DEF_CHKP_BUILTIN (BUILT_IN_CHKP_NULL_PTR_BOUNDS, \"__bnd_null_ptr_bounds\", BT_FN_PTR_CONST_PTR, ATTR_CONST_NOTHROW_LEAF_LIST)\n-DEF_CHKP_BUILTIN (BUILT_IN_CHKP_COPY_PTR_BOUNDS, \"__bnd_copy_ptr_bounds\", BT_FN_PTR_CONST_PTR_CONST_PTR, ATTR_CONST_NOTHROW_LEAF_LIST)\n-DEF_CHKP_BUILTIN (BUILT_IN_CHKP_NARROW_PTR_BOUNDS, \"__bnd_narrow_ptr_bounds\", BT_FN_PTR_CONST_PTR_CONST_PTR_SIZE, ATTR_CONST_NOTHROW_LEAF_LIST)\n-DEF_CHKP_BUILTIN (BUILT_IN_CHKP_STORE_PTR_BOUNDS, \"__bnd_store_ptr_bounds\", BT_FN_VOID_PTRPTR_CONST_PTR, ATTR_NOTHROW_LEAF_LIST)\n-DEF_CHKP_BUILTIN (BUILT_IN_CHKP_CHECK_PTR_LBOUNDS, \"__bnd_chk_ptr_lbounds\", BT_FN_VOID_CONST_PTR, ATTR_NOTHROW_LEAF_LIST)\n-DEF_CHKP_BUILTIN (BUILT_IN_CHKP_CHECK_PTR_UBOUNDS, \"__bnd_chk_ptr_ubounds\", BT_FN_VOID_CONST_PTR, ATTR_NOTHROW_LEAF_LIST)\n-DEF_CHKP_BUILTIN (BUILT_IN_CHKP_CHECK_PTR_BOUNDS, \"__bnd_chk_ptr_bounds\", BT_FN_VOID_CONST_PTR_SIZE, ATTR_NOTHROW_LEAF_LIST)\n-DEF_CHKP_BUILTIN (BUILT_IN_CHKP_GET_PTR_LBOUND, \"__bnd_get_ptr_lbound\", BT_FN_CONST_PTR_CONST_PTR, ATTR_CONST_NOTHROW_LEAF_LIST)\n-DEF_CHKP_BUILTIN (BUILT_IN_CHKP_GET_PTR_UBOUND, \"__bnd_get_ptr_ubound\", BT_FN_CONST_PTR_CONST_PTR, ATTR_CONST_NOTHROW_LEAF_LIST)\n-\n-/* Pointer Bounds Checker specific versions of string functions.  */\n-DEF_CHKP_BUILTIN (BUILT_IN_CHKP_MEMCPY_NOBND, \"chkp_memcpy_nobnd\", BT_FN_PTR_PTR_CONST_PTR_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)\n-DEF_CHKP_BUILTIN (BUILT_IN_CHKP_MEMCPY_NOCHK, \"chkp_memcpy_nochk\", BT_FN_PTR_PTR_CONST_PTR_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)\n-DEF_CHKP_BUILTIN (BUILT_IN_CHKP_MEMCPY_NOBND_NOCHK, \"chkp_memcpy_nobnd_nochk\", BT_FN_PTR_PTR_CONST_PTR_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)\n-DEF_CHKP_BUILTIN (BUILT_IN_CHKP_MEMMOVE_NOBND, \"chkp_memmove_nobnd\", BT_FN_PTR_PTR_CONST_PTR_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)\n-DEF_CHKP_BUILTIN (BUILT_IN_CHKP_MEMMOVE_NOCHK, \"chkp_memmove_nochk\", BT_FN_PTR_PTR_CONST_PTR_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)\n-DEF_CHKP_BUILTIN (BUILT_IN_CHKP_MEMMOVE_NOBND_NOCHK, \"chkp_memmove_nobnd_nochk\", BT_FN_PTR_PTR_CONST_PTR_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)\n-DEF_CHKP_BUILTIN (BUILT_IN_CHKP_MEMPCPY_NOBND, \"chkp_mempcpy_nobnd\", BT_FN_PTR_PTR_CONST_PTR_SIZE, ATTR_NOTHROW_NONNULL_LEAF)\n-DEF_CHKP_BUILTIN (BUILT_IN_CHKP_MEMPCPY_NOCHK, \"chkp_mempcpy_nochk\", BT_FN_PTR_PTR_CONST_PTR_SIZE, ATTR_NOTHROW_NONNULL_LEAF)\n-DEF_CHKP_BUILTIN (BUILT_IN_CHKP_MEMPCPY_NOBND_NOCHK, \"chkp_mempcpy_nobnd_nochk\", BT_FN_PTR_PTR_CONST_PTR_SIZE, ATTR_NOTHROW_NONNULL_LEAF)\n-DEF_CHKP_BUILTIN (BUILT_IN_CHKP_MEMSET_NOBND, \"chkp_memset_nobnd\", BT_FN_PTR_PTR_INT_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)\n-DEF_CHKP_BUILTIN (BUILT_IN_CHKP_MEMSET_NOCHK, \"chkp_memset_nochk\", BT_FN_PTR_PTR_INT_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)\n-DEF_CHKP_BUILTIN (BUILT_IN_CHKP_MEMSET_NOBND_NOCHK, \"chkp_memset_nobnd_nochk\", BT_FN_PTR_PTR_INT_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)"}, {"sha": "0bc53aabcb4b2fe13898b24a1472254f75b6c7f4", "filename": "gcc/config/i386/constraints.md", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fconfig%2Fi386%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fconfig%2Fi386%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fconstraints.md?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -18,7 +18,7 @@\n ;; <http://www.gnu.org/licenses/>.\n \n ;;; Unused letters:\n-;;;           H\n+;;;     B     H\n ;;;           h j\n \n ;; Integer register constraints.\n@@ -91,9 +91,6 @@\n (define_register_constraint \"x\" \"TARGET_SSE ? SSE_REGS : NO_REGS\"\n  \"Any SSE register.\")\n \n-(define_register_constraint \"B\" \"TARGET_MPX ? BND_REGS : NO_REGS\"\n- \"@internal Any bound register.\")\n-\n ;; We use the Y prefix to denote any number of conditional register sets:\n ;;  z\tFirst SSE register.\n ;;  i\tSSE2 inter-unit moves to SSE register enabled\n@@ -239,8 +236,6 @@\n ;; T prefix is used for different address constraints\n ;;   v - VSIB address\n ;;   s - address with no segment register\n-;;   i - address with no index and no rip\n-;;   b - address with no base and no rip\n \n (define_address_constraint \"Tv\"\n   \"VSIB address operand\"\n@@ -249,11 +244,3 @@\n (define_address_constraint \"Ts\"\n   \"Address operand without segment register\"\n   (match_operand 0 \"address_no_seg_operand\"))\n-\n-(define_address_constraint \"Ti\"\n-  \"MPX address operand without index\"\n-  (match_operand 0 \"address_mpx_no_index_operand\"))\n-\n-(define_address_constraint \"Tb\"\n-  \"MPX address operand without base\"\n-  (match_operand 0 \"address_mpx_no_base_operand\"))"}, {"sha": "ff1a17a9d112c491b18413161f4f3b465a18715a", "filename": "gcc/config/i386/i386-c.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fconfig%2Fi386%2Fi386-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fconfig%2Fi386%2Fi386-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-c.c?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -372,8 +372,6 @@ ix86_target_macros_internal (HOST_WIDE_INT isa_flag,\n     def_or_undef (parse_in, \"__SSE_MATH__\");\n   if ((fpmath & FPMATH_SSE) && (isa_flag & OPTION_MASK_ISA_SSE2))\n     def_or_undef (parse_in, \"__SSE2_MATH__\");\n-  if (isa_flag & OPTION_MASK_ISA_MPX)\n-    def_or_undef (parse_in, \"__MPX__\");\n }\n \n \f"}, {"sha": "e0b8fc826abce73d87a4bcb8845357e7a7d2bf4e", "filename": "gcc/config/i386/i386-modes.def", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fconfig%2Fi386%2Fi386-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fconfig%2Fi386%2Fi386-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-modes.def?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -87,9 +87,6 @@ VECTOR_MODE (INT, DI, 1);     /*                   V1DI */\n VECTOR_MODE (INT, SI, 1);     /*                   V1SI */\n VECTOR_MODE (INT, QI, 2);     /*                   V2QI */\n \n-POINTER_BOUNDS_MODE (BND32, 8);\n-POINTER_BOUNDS_MODE (BND64, 16);\n-\n INT_MODE (OI, 32);\n INT_MODE (XI, 64);\n "}, {"sha": "73feef25144c2a4801dbd0515632b01ae5136f4f", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -243,8 +243,6 @@ extern void ix86_expand_sse2_mulv4si3 (rtx, rtx, rtx);\n extern void ix86_expand_sse2_mulvxdi3 (rtx, rtx, rtx);\n extern void ix86_expand_sse2_abs (rtx, rtx);\n \n-extern bool ix86_bnd_prefixed_insn_p (rtx);\n-\n /* In i386-c.c  */\n extern void ix86_target_macros (void);\n extern void ix86_register_pragmas (void);"}, {"sha": "b11363be2df1d164fa8bf492840bed6fafc81ebc", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 9, "deletions": 65, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -2047,8 +2047,6 @@ enum reg_class const regclass_map[FIRST_PSEUDO_REGISTER] =\n   /* Mask registers.  */\n   MASK_REGS, MASK_EVEX_REGS, MASK_EVEX_REGS, MASK_EVEX_REGS,\n   MASK_EVEX_REGS, MASK_EVEX_REGS, MASK_EVEX_REGS, MASK_EVEX_REGS,\n-  /* MPX bound registers */\n-  BND_REGS, BND_REGS, BND_REGS, BND_REGS,\n };\n \n /* The \"default\" register map used in 32bit mode.  */\n@@ -2065,7 +2063,6 @@ int const dbx_register_map[FIRST_PSEUDO_REGISTER] =\n   -1, -1, -1, -1, -1, -1, -1, -1,       /* AVX-512 registers 16-23*/\n   -1, -1, -1, -1, -1, -1, -1, -1,       /* AVX-512 registers 24-31*/\n   93, 94, 95, 96, 97, 98, 99, 100,      /* Mask registers */\n-  101, 102, 103, 104,\t\t\t/* bound registers */\n };\n \n /* The \"default\" register map used in 64bit mode.  */\n@@ -2082,7 +2079,6 @@ int const dbx64_register_map[FIRST_PSEUDO_REGISTER] =\n   67, 68, 69, 70, 71, 72, 73, 74,       /* AVX-512 registers 16-23 */\n   75, 76, 77, 78, 79, 80, 81, 82,       /* AVX-512 registers 24-31 */\n   118, 119, 120, 121, 122, 123, 124, 125, /* Mask registers */\n-  126, 127, 128, 129,\t\t\t/* bound registers */\n };\n \n /* Define the register numbers to be used in Dwarf debugging information.\n@@ -2151,7 +2147,6 @@ int const svr4_dbx_register_map[FIRST_PSEUDO_REGISTER] =\n   -1, -1, -1, -1, -1, -1, -1, -1,       /* AVX-512 registers 16-23*/\n   -1, -1, -1, -1, -1, -1, -1, -1,       /* AVX-512 registers 24-31*/\n   93, 94, 95, 96, 97, 98, 99, 100,      /* Mask registers */\n-  -1, -1, -1, -1,                       /* bound registers */\n };\n \n /* Define parameter passing and return registers.  */\n@@ -2583,7 +2578,6 @@ ix86_target_string (HOST_WIDE_INT isa, int flags, const char *arch,\n     { \"-mrtm\",\t\tOPTION_MASK_ISA_RTM },\n     { \"-mxsave\",\tOPTION_MASK_ISA_XSAVE },\n     { \"-mxsaveopt\",\tOPTION_MASK_ISA_XSAVEOPT },\n-    { \"-mmpx\",          OPTION_MASK_ISA_MPX },\n   };\n \n   /* Flag options.  */\n@@ -3078,7 +3072,6 @@ ix86_option_override_internal (bool main_args_p,\n #define PTA_AVX512ER\t\t(HOST_WIDE_INT_1 << 41)\n #define PTA_AVX512PF\t\t(HOST_WIDE_INT_1 << 42)\n #define PTA_AVX512CD\t\t(HOST_WIDE_INT_1 << 43)\n-#define PTA_MPX\t\t\t(HOST_WIDE_INT_1 << 44)\n \n /* if this reaches 64, need to widen struct pta flags below */\n \n@@ -4271,11 +4264,6 @@ ix86_conditional_register_usage (void)\n       for (i = FIRST_MASK_REG; i <= LAST_MASK_REG; i++)\n \tfixed_regs[i] = call_used_regs[i] = 1, reg_names[i] = \"\";\n     }\n-\n-  /* If MPX is disabled, squash the registers.  */\n-  if (! TARGET_MPX)\n-    for (i = FIRST_BND_REG; i <= LAST_BND_REG; i++)\n-      fixed_regs[i] = call_used_regs[i] = 1, reg_names[i] = \"\";\n }\n \n \f\n@@ -8998,7 +8986,7 @@ ix86_code_end (void)\n       xops[0] = gen_rtx_REG (Pmode, regno);\n       xops[1] = gen_rtx_MEM (Pmode, stack_pointer_rtx);\n       output_asm_insn (\"mov%z0\\t{%1, %0|%0, %1}\", xops);\n-      output_asm_insn (\"%!ret\", NULL);\n+      fputs (\"\\tret\\n\", asm_out_file);\n       final_end_function ();\n       init_insn_lengths ();\n       free_after_compilation (cfun);\n@@ -9056,7 +9044,7 @@ output_set_got (rtx dest, rtx label)\n \n       xops[2] = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (name));\n       xops[2] = gen_rtx_MEM (QImode, xops[2]);\n-      output_asm_insn (\"%!call\\t%X2\", xops);\n+      output_asm_insn (\"call\\t%X2\", xops);\n \n #if TARGET_MACHO\n       /* Output the Mach-O \"canonical\" pic base label name (\"Lxx$pb\") here.\n@@ -14424,7 +14412,7 @@ print_reg (rtx x, int code, FILE *file)\n     case 8:\n     case 4:\n     case 12:\n-      if (! ANY_FP_REG_P (x) &&  ! ANY_BND_REG_P (x))\n+      if (! ANY_FP_REG_P (x))\n \tputc (code == 8 && TARGET_64BIT ? 'r' : 'e', file);\n       /* FALLTHRU */\n     case 16:\n@@ -14547,7 +14535,6 @@ get_some_local_dynamic_name (void)\n    ~ -- print \"i\" if TARGET_AVX2, \"f\" otherwise.\n    @ -- print a segment register of thread base pointer load\n    ^ -- print addr32 prefix if TARGET_64BIT and Pmode != word_mode\n-   ! -- print MPX prefix for jxx/call/ret instructions if required.\n  */\n \n void\n@@ -15047,11 +15034,6 @@ ix86_print_operand (FILE *file, rtx x, int code)\n \t    fputs (\"addr32 \", file);\n \t  return;\n \n-\tcase '!':\n-\t  if (ix86_bnd_prefixed_insn_p (NULL_RTX))\n-\t    fputs (\"bnd \", file);\n-\t  return;\n-\n \tdefault:\n \t    output_operand_lossage (\"invalid operand code '%c'\", code);\n \t}\n@@ -15194,7 +15176,7 @@ static bool\n ix86_print_operand_punct_valid_p (unsigned char code)\n {\n   return (code == '@' || code == '*' || code == '+' || code == '&'\n-\t  || code == ';' || code == '~' || code == '^' || code == '!');\n+\t  || code == ';' || code == '~' || code == '^');\n }\n \f\n /* Print a memory operand whose address is ADDR.  */\n@@ -15224,25 +15206,6 @@ ix86_print_operand_address (FILE *file, rtx addr)\n       ok = ix86_decompose_address (XVECEXP (addr, 0, 0), &parts);\n       code = 'q';\n     }\n-  else if (GET_CODE (addr) == UNSPEC && XINT (addr, 1) == UNSPEC_BNDMK_ADDR)\n-    {\n-      ok = ix86_decompose_address (XVECEXP (addr, 0, 1), &parts);\n-      gcc_assert (parts.base == NULL_RTX || parts.index == NULL_RTX);\n-      if (parts.base != NULL_RTX)\n-\t{\n-\t  parts.index = parts.base;\n-\t  parts.scale = 1;\n-\t}\n-      parts.base = XVECEXP (addr, 0, 0);\n-      addr = XVECEXP (addr, 0, 0);\n-    }\n-  else if (GET_CODE (addr) == UNSPEC && XINT (addr, 1) == UNSPEC_BNDLDX_ADDR)\n-    {\n-      ok = ix86_decompose_address (XVECEXP (addr, 0, 0), &parts);\n-      gcc_assert (parts.index == NULL_RTX);\n-      parts.index = XVECEXP (addr, 0, 1);\n-      addr = XVECEXP (addr, 0, 0);\n-    }\n   else\n     ok = ix86_decompose_address (addr, &parts);\n \n@@ -24551,13 +24514,13 @@ ix86_output_call_insn (rtx insn, rtx call_op)\n   if (SIBLING_CALL_P (insn))\n     {\n       if (direct_p)\n-\txasm = \"%!jmp\\t%P0\";\n+\txasm = \"jmp\\t%P0\";\n       /* SEH epilogue detection requires the indirect branch case\n \t to include REX.W.  */\n       else if (TARGET_SEH)\n-\txasm = \"%!rex.W jmp %A0\";\n+\txasm = \"rex.W jmp %A0\";\n       else\n-\txasm = \"%!jmp\\t%A0\";\n+\txasm = \"jmp\\t%A0\";\n \n       output_asm_insn (xasm, &call_op);\n       return \"\";\n@@ -24594,9 +24557,9 @@ ix86_output_call_insn (rtx insn, rtx call_op)\n     }\n \n   if (direct_p)\n-    xasm = \"%!call\\t%P0\";\n+    xasm = \"call\\t%P0\";\n   else\n-    xasm = \"%!call\\t%A0\";\n+    xasm = \"call\\t%A0\";\n \n   output_asm_insn (xasm, &call_op);\n \n@@ -34762,7 +34725,6 @@ ix86_class_likely_spilled_p (reg_class_t rclass)\n       case SSE_FIRST_REG:\n       case FP_TOP_REG:\n       case FP_SECOND_REG:\n-      case BND_REGS:\n \treturn true;\n \n       default:\n@@ -35111,8 +35073,6 @@ ix86_hard_regno_mode_ok (int regno, enum machine_mode mode)\n     return VALID_FP_MODE_P (mode);\n   if (MASK_REGNO_P (regno))\n     return VALID_MASK_REG_MODE (mode);\n-  if (BND_REGNO_P (regno))\n-    return VALID_BND_REG_MODE (mode);\n   if (SSE_REGNO_P (regno))\n     {\n       /* We implement the move patterns for all vector modes into and\n@@ -35926,10 +35886,6 @@ x86_order_regs_for_local_alloc (void)\n    for (i = FIRST_MASK_REG; i <= LAST_MASK_REG; i++)\n      reg_alloc_order [pos++] = i;\n \n-   /* MPX bound registers.  */\n-   for (i = FIRST_BND_REG; i <= LAST_BND_REG; i++)\n-     reg_alloc_order [pos++] = i;\n-\n    /* x87 registers.  */\n    if (TARGET_SSE_MATH)\n      for (i = FIRST_STACK_REG; i <= LAST_STACK_REG; i++)\n@@ -42428,18 +42384,6 @@ ix86_expand_sse2_mulvxdi3 (rtx op0, rtx op1, rtx op2)\n \t\t       gen_rtx_MULT (mode, op1, op2));\n }\n \n-/* Return 1 if control tansfer instruction INSN\n-   should be encoded with bnd prefix.\n-   If insn is NULL then return 1 when control\n-   transfer instructions should be prefixed with\n-   bnd by default for current function.  */\n-\n-bool\n-ix86_bnd_prefixed_insn_p (rtx insn ATTRIBUTE_UNUSED)\n-{\n-  return false;\n-}\n-\n /* Calculate integer abs() using only SSE2 instructions.  */\n \n void"}, {"sha": "113c75e0813d4fe9d6301b101526b8a52cda41c8", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 36, "deletions": 60, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -128,8 +128,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define TARGET_XSAVE_P(x)\tTARGET_ISA_XSAVE_P(x)\n #define TARGET_XSAVEOPT\tTARGET_ISA_XSAVEOPT\n #define TARGET_XSAVEOPT_P(x)\tTARGET_ISA_XSAVEOPT_P(x)\n-#define TARGET_MPX\tTARGET_ISA_MPX\n-#define TARGET_MPX_P(x)\tTARGET_ISA_MPX_P(x)\n \n #define TARGET_LP64\tTARGET_ABI_64\n #define TARGET_LP64_P(x)\tTARGET_ABI_64_P(x)\n@@ -960,7 +958,7 @@ enum target_cpu_default\n    eliminated during reloading in favor of either the stack or frame\n    pointer.  */\n \n-#define FIRST_PSEUDO_REGISTER 81\n+#define FIRST_PSEUDO_REGISTER 77\n \n /* Number of hardware registers that go into the DWARF-2 unwind info.\n    If not defined, equals FIRST_PSEUDO_REGISTER.  */\n@@ -992,9 +990,7 @@ enum target_cpu_default\n /*xmm24,xmm25,xmm26,xmm27,xmm28,xmm29,xmm30,xmm31*/\t\t\\\n      0,   0,    0,    0,    0,    0,    0,    0,\t\t\\\n /*  k0,  k1, k2, k3, k4, k5, k6, k7*/\t\t\t\t\\\n-     0,  0,   0,  0,  0,  0,  0,  0,\t\t\t\t\\\n-/*   b0, b1, b2, b3*/\t\t\t\t\t\t\\\n-     0,  0,  0,  0 }\n+     0,  0,   0,  0,  0,  0,  0,  0 }\n \n /* 1 for registers not available across function calls.\n    These must include the FIXED_REGISTERS and also any\n@@ -1028,9 +1024,7 @@ enum target_cpu_default\n /*xmm24,xmm25,xmm26,xmm27,xmm28,xmm29,xmm30,xmm31*/\t\t\\\n      6,    6,     6,    6,    6,    6,    6,    6,\t\t\\\n  /* k0,  k1,  k2,  k3,  k4,  k5,  k6,  k7*/\t\t\t\\\n-     1,   1,   1,   1,   1,   1,   1,   1,\t\t\t\\\n-/*   b0, b1, b2, b3*/\t\t\t\t\t\t\\\n-     1,  1,  1,  1 }\n+     1,   1,   1,   1,   1,   1,   1,   1 }\n \n /* Order in which to allocate registers.  Each register must be\n    listed once, even those in FIXED_REGISTERS.  List frame pointer\n@@ -1046,8 +1040,7 @@ enum target_cpu_default\n    18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,\t\\\n    33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,  \\\n    48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,\t\\\n-   63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77,  \\\n-   78, 79, 80 }\n+   63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76 }\n \n /* ADJUST_REG_ALLOC_ORDER is a macro which permits reg_alloc_order\n    to be rearranged based on a particular function.  When using sse math,\n@@ -1069,7 +1062,6 @@ enum target_cpu_default\n \n #define HARD_REGNO_NREGS(REGNO, MODE)\t\t\t\t\t\\\n   (STACK_REGNO_P (REGNO) || SSE_REGNO_P (REGNO) || MMX_REGNO_P (REGNO)\t\\\n-   || BND_REGNO_P (REGNO)\t\t\t\t\t\t\\\n    ? (COMPLEX_MODE_P (MODE) ? 2 : 1)\t\t\t\t\t\\\n    : ((MODE) == XFmode\t\t\t\t\t\t\t\\\n       ? (TARGET_64BIT ? 2 : 3)\t\t\t\t\t\t\\\n@@ -1119,9 +1111,6 @@ enum target_cpu_default\n    || (MODE) == V2SImode || (MODE) == SImode\t\t\t\t\\\n    || (MODE) == V4HImode || (MODE) == V8QImode)\n \n-#define VALID_BND_REG_MODE(MODE) \\\n-  (TARGET_64BIT ? (MODE) == BND64mode : (MODE) == BND32mode)\n-\n #define VALID_DFP_MODE_P(MODE) \\\n   ((MODE) == SDmode || (MODE) == DDmode || (MODE) == TDmode)\n \n@@ -1228,9 +1217,6 @@ enum target_cpu_default\n #define FIRST_MASK_REG  (LAST_EXT_REX_SSE_REG + 1) /*69*/\n #define LAST_MASK_REG   (FIRST_MASK_REG + 7) /*76*/\n \n-#define FIRST_BND_REG  (LAST_MASK_REG + 1) /*77*/\n-#define LAST_BND_REG   (FIRST_BND_REG + 3) /*80*/\n-\n /* Override this in other tm.h files to cope with various OS lossage\n    requiring a frame pointer.  */\n #ifndef SUBTARGET_FRAME_POINTER_REQUIRED\n@@ -1311,7 +1297,6 @@ enum reg_class\n   SSE_FIRST_REG,\n   SSE_REGS,\n   EVEX_SSE_REGS,\n-  BND_REGS,\n   ALL_SSE_REGS,\n   MMX_REGS,\n   FP_TOP_SSE_REGS,\n@@ -1369,7 +1354,6 @@ enum reg_class\n    \"SSE_FIRST_REG\",\t\t\t\\\n    \"SSE_REGS\",\t\t\t\t\\\n    \"EVEX_SSE_REGS\",\t\t\t\\\n-   \"BND_REGS\",\t\t\t\t\\\n    \"ALL_SSE_REGS\",\t\t\t\\\n    \"MMX_REGS\",\t\t\t\t\\\n    \"FP_TOP_SSE_REGS\",\t\t\t\\\n@@ -1389,38 +1373,37 @@ enum reg_class\n    TARGET_CONDITIONAL_REGISTER_USAGE.  */\n \n #define REG_CLASS_CONTENTS                                              \\\n-{     { 0x00,       0x0,    0x0 },                                       \\\n-      { 0x01,       0x0,    0x0 },       /* AREG */                      \\\n-      { 0x02,       0x0,    0x0 },       /* DREG */                      \\\n-      { 0x04,       0x0,    0x0 },       /* CREG */                      \\\n-      { 0x08,       0x0,    0x0 },       /* BREG */                      \\\n-      { 0x10,       0x0,    0x0 },       /* SIREG */                     \\\n-      { 0x20,       0x0,    0x0 },       /* DIREG */                     \\\n-      { 0x03,       0x0,    0x0 },       /* AD_REGS */                   \\\n-      { 0x0f,       0x0,    0x0 },       /* Q_REGS */                    \\\n-  { 0x1100f0,    0x1fe0,    0x0 },       /* NON_Q_REGS */                \\\n-      { 0x7f,    0x1fe0,    0x0 },       /* INDEX_REGS */                \\\n-  { 0x1100ff,       0x0,    0x0 },       /* LEGACY_REGS */               \\\n-      { 0x07,       0x0,    0x0 },       /* CLOBBERED_REGS */            \\\n-  { 0x1100ff,    0x1fe0,    0x0 },       /* GENERAL_REGS */              \\\n-     { 0x100,       0x0,    0x0 },       /* FP_TOP_REG */                \\\n-    { 0x0200,       0x0,    0x0 },       /* FP_SECOND_REG */             \\\n-    { 0xff00,       0x0,    0x0 },       /* FLOAT_REGS */                \\\n-  { 0x200000,       0x0,    0x0 },       /* SSE_FIRST_REG */             \\\n-{ 0x1fe00000,  0x1fe000,    0x0 },       /* SSE_REGS */                  \\\n-       { 0x0,0xffe00000,   0x1f },       /* EVEX_SSE_REGS */             \\\n-       { 0x0,       0x0,0x1e000 },       /* BND_REGS */\t\t\t \\\n-{ 0x1fe00000,0xffffe000,   0x1f },       /* ALL_SSE_REGS */              \\\n-{ 0xe0000000,      0x1f,    0x0 },       /* MMX_REGS */                  \\\n-{ 0x1fe00100,0xffffe000,   0x1f },       /* FP_TOP_SSE_REG */            \\\n-{ 0x1fe00200,0xffffe000,   0x1f },       /* FP_SECOND_SSE_REG */         \\\n-{ 0x1fe0ff00,0xffffe000,   0x1f },       /* FLOAT_SSE_REGS */            \\\n-{   0x11ffff,    0x1fe0,    0x0 },       /* FLOAT_INT_REGS */            \\\n-{ 0x1ff100ff,0xffffffe0,   0x1f },       /* INT_SSE_REGS */              \\\n-{ 0x1ff1ffff,0xffffffe0,   0x1f },       /* FLOAT_INT_SSE_REGS */        \\\n-       { 0x0,       0x0, 0x1fc0 },       /* MASK_EVEX_REGS */           \\\n-       { 0x0,       0x0, 0x1fe0 },       /* MASK_REGS */                 \\\n-{ 0xffffffff,0xffffffff, 0x1fff }                                        \\\n+{     { 0x00,       0x0,   0x0 },                                       \\\n+      { 0x01,       0x0,   0x0 },       /* AREG */                      \\\n+      { 0x02,       0x0,   0x0 },       /* DREG */                      \\\n+      { 0x04,       0x0,   0x0 },       /* CREG */                      \\\n+      { 0x08,       0x0,   0x0 },       /* BREG */                      \\\n+      { 0x10,       0x0,   0x0 },       /* SIREG */                     \\\n+      { 0x20,       0x0,   0x0 },       /* DIREG */                     \\\n+      { 0x03,       0x0,   0x0 },       /* AD_REGS */                   \\\n+      { 0x0f,       0x0,   0x0 },       /* Q_REGS */                    \\\n+  { 0x1100f0,    0x1fe0,   0x0 },       /* NON_Q_REGS */                \\\n+      { 0x7f,    0x1fe0,   0x0 },       /* INDEX_REGS */                \\\n+  { 0x1100ff,       0x0,   0x0 },       /* LEGACY_REGS */               \\\n+      { 0x07,       0x0,   0x0 },       /* CLOBBERED_REGS */            \\\n+  { 0x1100ff,    0x1fe0,   0x0 },       /* GENERAL_REGS */              \\\n+     { 0x100,       0x0,   0x0 },       /* FP_TOP_REG */                \\\n+    { 0x0200,       0x0,   0x0 },       /* FP_SECOND_REG */             \\\n+    { 0xff00,       0x0,   0x0 },       /* FLOAT_REGS */                \\\n+  { 0x200000,       0x0,   0x0 },       /* SSE_FIRST_REG */             \\\n+{ 0x1fe00000,  0x1fe000,   0x0 },       /* SSE_REGS */                  \\\n+       { 0x0,0xffe00000,  0x1f },       /* EVEX_SSE_REGS */             \\\n+{ 0x1fe00000,0xffffe000,  0x1f },       /* ALL_SSE_REGS */              \\\n+{ 0xe0000000,      0x1f,   0x0 },       /* MMX_REGS */                  \\\n+{ 0x1fe00100,0xffffe000,  0x1f },       /* FP_TOP_SSE_REG */            \\\n+{ 0x1fe00200,0xffffe000,  0x1f },       /* FP_SECOND_SSE_REG */         \\\n+{ 0x1fe0ff00,0xffffe000,  0x1f },       /* FLOAT_SSE_REGS */            \\\n+{   0x11ffff,    0x1fe0,   0x0 },       /* FLOAT_INT_REGS */            \\\n+{ 0x1ff100ff,0xffffffe0,  0x1f },       /* INT_SSE_REGS */              \\\n+{ 0x1ff1ffff,0xffffffe0,  0x1f },       /* FLOAT_INT_SSE_REGS */        \\\n+       { 0x0,       0x0,0x1fc0 },       /* MASK_EVEX_REGS */           \\\n+       { 0x0,       0x0,0x1fe0 },       /* MASK_REGS */                 \\\n+{ 0xffffffff,0xffffffff,0x1fff }                                        \\\n }\n \n /* The same information, inverted:\n@@ -1496,9 +1479,6 @@ enum reg_class\n #define CC_REG_P(X) (REG_P (X) && CC_REGNO_P (REGNO (X)))\n #define CC_REGNO_P(X) ((X) == FLAGS_REG || (X) == FPSR_REG)\n \n-#define BND_REGNO_P(N) IN_RANGE ((N), FIRST_BND_REG, LAST_BND_REG)\n-#define ANY_BND_REG_P(X) (REG_P (X) && BND_REGNO_P (REGNO (X)))\n-\n /* The class value for index registers, and the one for base regs.  */\n \n #define INDEX_REG_CLASS INDEX_REGS\n@@ -1943,9 +1923,6 @@ do {\t\t\t\t\t\t\t\\\n    between pointers and any other objects of this machine mode.  */\n #define Pmode (ix86_pmode == PMODE_DI ? DImode : SImode)\n \n-/* Specify the machine mode that bounds have.  */\n-#define BNDmode (ix86_pmode == PMODE_DI ? BND64mode : BND32mode)\n-\n /* A C expression whose value is zero if pointers that need to be extended\n    from being `POINTER_SIZE' bits wide to `Pmode' are sign-extended and\n    greater then zero if they are zero-extended and less then zero if the\n@@ -2056,8 +2033,7 @@ do {\t\t\t\t\t\t\t\\\n  \"xmm20\", \"xmm21\", \"xmm22\", \"xmm23\",\t\t\t\t\t\\\n  \"xmm24\", \"xmm25\", \"xmm26\", \"xmm27\",\t\t\t\t\t\\\n  \"xmm28\", \"xmm29\", \"xmm30\", \"xmm31\",\t\t\t\t\t\\\n- \"k0\", \"k1\", \"k2\", \"k3\", \"k4\", \"k5\", \"k6\", \"k7\",\t\t\t\\\n- \"bnd0\", \"bnd1\", \"bnd2\", \"bnd3\" }\n+ \"k0\", \"k1\", \"k2\", \"k3\", \"k4\", \"k5\", \"k6\", \"k7\" }\n \n #define REGISTER_NAMES HI_REGISTER_NAMES\n "}, {"sha": "6976124d4a89ef77bb7b7f158be43b17f9ebbbe2", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 20, "deletions": 195, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -63,7 +63,6 @@\n ;; ~ -- print \"i\" if TARGET_AVX2, \"f\" otherwise.\n ;; @ -- print a segment register of thread base pointer load\n ;; ^ -- print addr32 prefix if TARGET_64BIT and Pmode != word_mode\n-;; ! -- print MPX prefix for jxx/call/ret instructions if required.\n \n (define_c_enum \"unspec\" [\n   ;; Relocation specifiers\n@@ -179,16 +178,6 @@\n   ;; For BMI2 support\n   UNSPEC_PDEP\n   UNSPEC_PEXT\n-\n-  UNSPEC_BNDMK\n-  UNSPEC_BNDMK_ADDR\n-  UNSPEC_BNDSTX\n-  UNSPEC_BNDLDX\n-  UNSPEC_BNDLDX_ADDR\n-  UNSPEC_BNDCL\n-  UNSPEC_BNDCU\n-  UNSPEC_BNDCN\n-  UNSPEC_MPX_FENCE\n ])\n \n (define_c_enum \"unspecv\" [\n@@ -353,8 +342,6 @@\n    (MASK5_REG\t\t\t74)\n    (MASK6_REG\t\t\t75)\n    (MASK7_REG\t\t\t76)\n-   (BND0_REG\t\t\t77)\n-   (BND1_REG\t\t\t78)\n   ])\n \n ;; Insns whose names begin with \"x86_\" are emitted by gen_FOO calls\n@@ -389,8 +376,7 @@\n    ssecvt,ssecvt1,sseicvt,sseins,\n    sseshuf,sseshuf1,ssemuladd,sse4arg,\n    lwp,mskmov,msklog,\n-   mmx,mmxmov,mmxadd,mmxmul,mmxcmp,mmxcvt,mmxshft,\n-   mpxmov,mpxmk,mpxchk,mpxld,mpxst\"\n+   mmx,mmxmov,mmxadd,mmxmul,mmxcmp,mmxcvt,mmxshft\"\n   (const_string \"other\"))\n \n ;; Main data type used by the insn\n@@ -419,8 +405,7 @@\n ;; The (bounding maximum) length of an instruction immediate.\n (define_attr \"length_immediate\" \"\"\n   (cond [(eq_attr \"type\" \"incdec,setcc,icmov,str,lea,other,multi,idiv,leave,\n-\t\t\t  bitmanip,imulx,msklog,mskmov,mpxmk,mpxmov,mpxchk,\n-\t\t\t  mpxld,mpxst\")\n+\t\t\t  bitmanip,imulx,msklog,mskmov\")\n \t   (const_int 0)\n \t (eq_attr \"unit\" \"i387,sse,mmx\")\n \t   (const_int 0)\n@@ -475,17 +460,13 @@\n \t   (const_int 0)\n \t (and (eq_attr \"unit\" \"sse\") (eq_attr \"mode\" \"SF,DF\"))\n \t   (const_int 1)\n-\t (and (eq_attr \"type\" \"ibr,call,callv\")\n-\t      (match_test \"ix86_bnd_prefixed_insn_p (insn)\"))\n-\t   (const_int 1)\n \t]\n \t(const_int 0)))\n \n ;; Set when 0f opcode prefix is used.\n (define_attr \"prefix_0f\" \"\"\n   (if_then_else\n-    (ior (eq_attr \"type\" \"imovx,setcc,icmov,bitmanip,msklog,mskmov,\n-\t\t\t  mpxmk,mpxmov,mpxchk,mpxld,mpxst\")\n+    (ior (eq_attr \"type\" \"imovx,setcc,icmov,bitmanip,msklog,mskmov\")\n \t (eq_attr \"unit\" \"sse,mmx\"))\n     (const_int 1)\n     (const_int 0)))\n@@ -588,19 +569,12 @@\n \t ]\n \t (const_int 1)))\n \n-;; When this attribute is set, calculate total insn length from\n-;; length_nobnd attribute, prefixed with eventual bnd prefix byte\n-(define_attr \"length_nobnd\" \"\" (const_int 0))\n-\n ;; The (bounding maximum) length of an instruction in bytes.\n ;; ??? fistp and frndint are in fact fldcw/{fistp,frndint}/fldcw sequences.\n ;; Later we may want to split them and compute proper length as for\n ;; other insns.\n (define_attr \"length\" \"\"\n-  (cond [(eq_attr \"length_nobnd\" \"!0\")\n-\t   (plus (symbol_ref (\"ix86_bnd_prefixed_insn_p (insn)\"))\n-\t\t (attr \"length_nobnd\"))\n-\t (eq_attr \"type\" \"other,multi,fistp,frndint\")\n+  (cond [(eq_attr \"type\" \"other,multi,fistp,frndint\")\n \t   (const_int 16)\n \t (eq_attr \"type\" \"fcmp\")\n \t   (const_int 4)\n@@ -641,16 +615,12 @@\n (define_attr \"memory\" \"none,load,store,both,unknown\"\n   (cond [(eq_attr \"type\" \"other,multi,str,lwp\")\n \t   (const_string \"unknown\")\n-\t (eq_attr \"type\" \"lea,fcmov,fpspc,mpxmk,mpxchk\")\n+\t (eq_attr \"type\" \"lea,fcmov,fpspc\")\n \t   (const_string \"none\")\n \t (eq_attr \"type\" \"fistp,leave\")\n \t   (const_string \"both\")\n \t (eq_attr \"type\" \"frndint\")\n \t   (const_string \"load\")\n-\t (eq_attr \"type\" \"mpxld\")\n-\t   (const_string \"load\")\n-\t (eq_attr \"type\" \"mpxst\")\n-\t   (const_string \"store\")\n \t (eq_attr \"type\" \"push\")\n \t   (if_then_else (match_operand 1 \"memory_operand\")\n \t     (const_string \"both\")\n@@ -696,7 +666,7 @@\n \t\t   fmov,fcmp,fsgn,\n \t\t   sse,ssemov,ssecmp,ssecomi,ssecvt,ssecvt1,sseicvt,\n \t\t   sselog1,sseshuf1,sseadd1,sseiadd1,sseishft1,\n-\t\t   mmx,mmxmov,mmxcmp,mmxcvt,mskmov,msklog,mpxmov\")\n+\t\t   mmx,mmxmov,mmxcmp,mmxcvt,mskmov,msklog\")\n \t      (match_operand 2 \"memory_operand\"))\n \t   (const_string \"load\")\n \t (and (eq_attr \"type\" \"icmov,ssemuladd,sse4arg\")\n@@ -935,21 +905,6 @@\n (define_mode_iterator DWIH [(SI \"!TARGET_64BIT\")\n \t\t\t    (DI \"TARGET_64BIT\")])\n \n-;; Bound modes.\n-(define_mode_iterator BND [(BND32 \"!TARGET_LP64\")\n-\t\t\t   (BND64 \"TARGET_LP64\")])\n-\n-;; Pointer mode corresponding to bound mode.\n-(define_mode_attr bnd_ptr [(BND32 \"SI\") (BND64 \"DI\")])\n-\n-;; MPX check types\n-(define_int_iterator BNDCHECK [UNSPEC_BNDCL UNSPEC_BNDCU UNSPEC_BNDCN])\n-\n-;; Check name\n-(define_int_attr bndcheck [(UNSPEC_BNDCL \"cl\")\n-\t\t\t   (UNSPEC_BNDCU \"cu\")\n-\t\t\t   (UNSPEC_BNDCN \"cn\")])\n-\n ;; Instruction suffix for integer modes.\n (define_mode_attr imodesuffix [(QI \"b\") (HI \"w\") (SI \"l\") (DI \"q\")])\n \n@@ -10799,10 +10754,10 @@\n \t\t      (label_ref (match_operand 0))\n \t\t      (pc)))]\n   \"\"\n-  \"%!%+j%C1\\t%l0\"\n+  \"%+j%C1\\t%l0\"\n   [(set_attr \"type\" \"ibr\")\n    (set_attr \"modrm\" \"0\")\n-   (set (attr \"length_nobnd\")\n+   (set (attr \"length\")\n \t   (if_then_else (and (ge (minus (match_dup 0) (pc))\n \t\t\t\t  (const_int -126))\n \t\t\t      (lt (minus (match_dup 0) (pc))\n@@ -10817,10 +10772,10 @@\n \t\t      (pc)\n \t\t      (label_ref (match_operand 0))))]\n   \"\"\n-  \"%!%+j%c1\\t%l0\"\n+  \"%+j%c1\\t%l0\"\n   [(set_attr \"type\" \"ibr\")\n    (set_attr \"modrm\" \"0\")\n-   (set (attr \"length_nobnd\")\n+   (set (attr \"length\")\n \t   (if_then_else (and (ge (minus (match_dup 0) (pc))\n \t\t\t\t  (const_int -126))\n \t\t\t      (lt (minus (match_dup 0) (pc))\n@@ -11283,9 +11238,9 @@\n   [(set (pc)\n \t(label_ref (match_operand 0)))]\n   \"\"\n-  \"%!jmp\\t%l0\"\n+  \"jmp\\t%l0\"\n   [(set_attr \"type\" \"ibr\")\n-   (set (attr \"length_nobnd\")\n+   (set (attr \"length\")\n \t   (if_then_else (and (ge (minus (match_dup 0) (pc))\n \t\t\t\t  (const_int -126))\n \t\t\t      (lt (minus (match_dup 0) (pc))\n@@ -11305,7 +11260,7 @@\n (define_insn \"*indirect_jump\"\n   [(set (pc) (match_operand:W 0 \"indirect_branch_operand\" \"rw\"))]\n   \"\"\n-  \"%!jmp\\t%A0\"\n+  \"jmp\\t%A0\"\n   [(set_attr \"type\" \"ibr\")\n    (set_attr \"length_immediate\" \"0\")])\n \n@@ -11354,7 +11309,7 @@\n   [(set (pc) (match_operand:W 0 \"indirect_branch_operand\" \"rw\"))\n    (use (label_ref (match_operand 1)))]\n   \"\"\n-  \"%!jmp\\t%A0\"\n+  \"jmp\\t%A0\"\n   [(set_attr \"type\" \"ibr\")\n    (set_attr \"length_immediate\" \"0\")])\n \f\n@@ -11741,8 +11696,8 @@\n (define_insn \"simple_return_internal\"\n   [(simple_return)]\n   \"reload_completed\"\n-  \"%!ret\"\n-  [(set_attr \"length_nobnd\" \"1\")\n+  \"ret\"\n+  [(set_attr \"length\" \"1\")\n    (set_attr \"atom_unit\" \"jeu\")\n    (set_attr \"length_immediate\" \"0\")\n    (set_attr \"modrm\" \"0\")])\n@@ -11754,12 +11709,7 @@\n   [(simple_return)\n    (unspec [(const_int 0)] UNSPEC_REP)]\n   \"reload_completed\"\n-{\n-  if (ix86_bnd_prefixed_insn_p (insn))\n-    return \"%!ret\";\n-\n-  return \"rep%; ret\";\n-}\n+  \"rep%; ret\"\n   [(set_attr \"length\" \"2\")\n    (set_attr \"atom_unit\" \"jeu\")\n    (set_attr \"length_immediate\" \"0\")\n@@ -11770,8 +11720,8 @@\n   [(simple_return)\n    (use (match_operand:SI 0 \"const_int_operand\"))]\n   \"reload_completed\"\n-  \"%!ret\\t%0\"\n-  [(set_attr \"length_nobnd\" \"3\")\n+  \"ret\\t%0\"\n+  [(set_attr \"length\" \"3\")\n    (set_attr \"atom_unit\" \"jeu\")\n    (set_attr \"length_immediate\" \"2\")\n    (set_attr \"modrm\" \"0\")])\n@@ -11780,7 +11730,7 @@\n   [(simple_return)\n    (use (match_operand:SI 0 \"register_operand\" \"r\"))]\n   \"reload_completed\"\n-  \"%!jmp\\t%A0\"\n+  \"jmp\\t%A0\"\n   [(set_attr \"type\" \"ibr\")\n    (set_attr \"length_immediate\" \"0\")])\n \n@@ -18333,131 +18283,6 @@\n   [(set_attr \"type\" \"other\")\n    (set_attr \"length\" \"3\")])\n \n-;; MPX instructions\n-\n-(define_expand \"<mode>_mk\"\n-  [(set (match_operand:BND 0 \"register_operand\")\n-    (unspec:BND\n-      [(mem:<bnd_ptr>\n-       (match_par_dup 3\n-        [(match_operand:<bnd_ptr> 1 \"register_operand\")\n-\t (match_operand:<bnd_ptr> 2 \"address_mpx_no_base_operand\")]))]\n-      UNSPEC_BNDMK))]\n-  \"TARGET_MPX\"\n-{\n-  operands[3] = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, operands[1],\n-\t\t\t\t\t\t  operands[2]),\n-                                UNSPEC_BNDMK_ADDR);\n-})\n-\n-(define_insn \"*<mode>_mk\"\n-  [(set (match_operand:BND 0 \"register_operand\" \"=B\")\n-    (unspec:BND\n-      [(match_operator:<bnd_ptr> 3 \"bnd_mem_operator\"\n-        [(unspec:<bnd_ptr>\n-\t   [(match_operand:<bnd_ptr> 1 \"register_operand\" \"r\")\n-            (match_operand:<bnd_ptr> 2 \"address_mpx_no_base_operand\" \"Tb\")]\n-\t   UNSPEC_BNDMK_ADDR)])]\n-      UNSPEC_BNDMK))]\n-  \"TARGET_MPX\"\n-  \"bndmk\\t{%3, %0|%0, %3}\"\n-  [(set_attr \"type\" \"mpxmk\")])\n-\n-(define_expand \"mov<mode>\"\n-  [(set (match_operand:BND 0 \"general_operand\")\n-        (match_operand:BND 1 \"general_operand\"))]\n-  \"TARGET_MPX\"\n-{\n-  ix86_expand_move (<MODE>mode, operands);DONE;\n-})\n-\n-(define_insn \"*mov<mode>_internal_mpx\"\n-  [(set (match_operand:BND 0 \"nonimmediate_operand\" \"=B,m\")\n-        (match_operand:BND 1 \"general_operand\" \"Bm,B\"))]\n-  \"TARGET_MPX\"\n-  \"bndmov\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"mpxmov\")])\n-\n-(define_expand \"<mode>_<bndcheck>\"\n-  [(parallel [(unspec [(match_operand:BND 0 \"register_operand\")\n-                       (match_operand:<bnd_ptr> 1 \"address_no_seg_operand\")] BNDCHECK)\n-              (set (match_dup 2)\n-                   (unspec:BLK [(match_dup 2)] UNSPEC_MPX_FENCE))])]\n-  \"TARGET_MPX\"\n-{\n-  operands[2] = gen_rtx_MEM (BLKmode, operands[1]);\n-  MEM_VOLATILE_P (operands[2]) = 1;\n-})\n-\n-(define_insn \"*<mode>_<bndcheck>\"\n-  [(parallel [(unspec [(match_operand:BND 0 \"register_operand\" \"B\")\n-                       (match_operand:<bnd_ptr> 1 \"address_no_seg_operand\" \"Ts\")] BNDCHECK)\n-              (set (match_operand:BLK 2 \"bnd_mem_operator\")\n-                   (unspec:BLK [(match_dup 2)] UNSPEC_MPX_FENCE))])]\n-  \"TARGET_MPX\"\n-  \"bnd<bndcheck>\\t{%a1, %0|%0, %a1}\"\n-  [(set_attr \"type\" \"mpxchk\")])\n-\n-(define_expand \"<mode>_ldx\"\n-  [(parallel [(set:BND (match_operand:BND 0 \"register_operand\")\n-                       (unspec:BND\n-\t\t         [(mem:<bnd_ptr>\n-\t\t\t   (match_par_dup 3\n-\t\t\t     [(match_operand:<bnd_ptr> 1 \"address_mpx_no_index_operand\")\n-\t                      (match_operand:<bnd_ptr> 2 \"register_operand\")]))]\n-\t\t\t UNSPEC_BNDLDX))\n-              (use (mem:BLK (match_dup 1)))])]\n-  \"TARGET_MPX\"\n-{\n-  operands[3] = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, operands[1],\n-                                                  operands[2]),\n-\t\t\t\tUNSPEC_BNDLDX_ADDR);\n-})\n-\n-(define_insn \"*<mode>_ldx\"\n-  [(parallel [(set:BND (match_operand:BND 0 \"register_operand\" \"=B\")\n-                       (unspec:BND\n-\t\t         [(match_operator:<bnd_ptr> 3 \"bnd_mem_operator\"\n-\t\t\t   [(unspec:<bnd_ptr>\n-\t\t\t     [(match_operand:<bnd_ptr> 1 \"address_mpx_no_index_operand\" \"Ti\")\n-\t                      (match_operand:<bnd_ptr> 2 \"register_operand\" \"l\")]\n-\t\t\t    UNSPEC_BNDLDX_ADDR)])]\n-\t\t\t UNSPEC_BNDLDX))\n-              (use (mem:BLK (match_dup 1)))])]\n-  \"TARGET_MPX\"\n-  \"bndldx\\t{%3, %0|%0, %3}\"\n-  [(set_attr \"type\" \"mpxld\")])\n-\n-(define_expand \"<mode>_stx\"\n-  [(parallel [(unspec [(mem:<bnd_ptr>\n-\t\t\t (match_par_dup 3\n-\t\t\t   [(match_operand:<bnd_ptr> 0 \"address_mpx_no_index_operand\")\n-\t                    (match_operand:<bnd_ptr> 1 \"register_operand\")]))\n-\t               (match_operand:BND 2 \"register_operand\")] UNSPEC_BNDSTX)\n-              (set (match_dup 4)\n-                   (unspec:BLK [(match_dup 4)] UNSPEC_MPX_FENCE))])]\n-  \"TARGET_MPX\"\n-{\n-  operands[3] = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, operands[0],\n-                                                  operands[1]),\n-\t\t\t\tUNSPEC_BNDLDX_ADDR);\n-  operands[4] = gen_rtx_MEM (BLKmode, operands[0]);\n-  MEM_VOLATILE_P (operands[4]) = 1;\n-})\n-\n-(define_insn \"*<mode>_stx\"\n-  [(parallel [(unspec [(match_operator:<bnd_ptr> 3 \"bnd_mem_operator\"\n-\t\t\t [(unspec:<bnd_ptr>\n-\t\t\t  [(match_operand:<bnd_ptr> 0 \"address_mpx_no_index_operand\" \"Ti\")\n-\t                   (match_operand:<bnd_ptr> 1 \"register_operand\" \"l\")]\n-\t\t\t UNSPEC_BNDLDX_ADDR)])\n-\t               (match_operand:BND 2 \"register_operand\" \"B\")] UNSPEC_BNDSTX)\n-              (set (match_operand:BLK 4 \"bnd_mem_operator\")\n-                   (unspec:BLK [(match_dup 4)] UNSPEC_MPX_FENCE))])]\n-  \"TARGET_MPX\"\n-  \"bndstx\\t{%2, %3|%3, %2}\"\n-  [(set_attr \"type\" \"mpxst\")])\n-\n (include \"mmx.md\")\n (include \"sse.md\")\n (include \"sync.md\")"}, {"sha": "5b3219aaf224f84734df3a255a0115346b1dc14a", "filename": "gcc/config/i386/i386.opt", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fconfig%2Fi386%2Fi386.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fconfig%2Fi386%2Fi386.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.opt?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -669,10 +669,6 @@ mrtm\n Target Report Mask(ISA_RTM) Var(ix86_isa_flags) Save\n Support RTM built-in functions and code generation\n \n-mmpx\n-Target Report Mask(ISA_MPX) Var(ix86_isa_flags) Save\n-Support MPX code generation\n-\n mstack-protector-guard=\n Target RejectNegative Joined Enum(stack_protector_guard) Var(ix86_stack_protector_guard) Init(SSP_TLS)\n Use given stack-protector guard"}, {"sha": "b86201924c3f7054b74b48ae884a4098972caa7c", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -982,74 +982,9 @@\n   return true;\n })\n \n-;; Return true if op is valid MPX address operand without base\n-(define_predicate \"address_mpx_no_base_operand\"\n-  (match_operand 0 \"address_operand\")\n-{\n-  struct ix86_address parts;\n-  int ok;\n-\n-  ok = ix86_decompose_address (op, &parts);\n-  gcc_assert (ok);\n-\n-  if (parts.index && parts.base)\n-    return false;\n-\n-  if (parts.seg != SEG_DEFAULT)\n-    return false;\n-\n-  /* Do not support (%rip).  */\n-  if (parts.disp && flag_pic && TARGET_64BIT\n-      && SYMBOLIC_CONST (parts.disp))\n-    {\n-      if (GET_CODE (parts.disp) != CONST\n-\t  || GET_CODE (XEXP (parts.disp, 0)) != PLUS\n-\t  || GET_CODE (XEXP (XEXP (parts.disp, 0), 0)) != UNSPEC\n-\t  || !CONST_INT_P (XEXP (XEXP (parts.disp, 0), 1))\n-\t  || (XINT (XEXP (XEXP (parts.disp, 0), 0), 1) != UNSPEC_DTPOFF\n-\t      && XINT (XEXP (XEXP (parts.disp, 0), 0), 1) != UNSPEC_NTPOFF))\n-\treturn false;\n-    }\n-\n-  return true;\n-})\n-\n-;; Return true if op is valid MPX address operand without index\n-(define_predicate \"address_mpx_no_index_operand\"\n-  (match_operand 0 \"address_operand\")\n-{\n-  struct ix86_address parts;\n-  int ok;\n-\n-  ok = ix86_decompose_address (op, &parts);\n-  gcc_assert (ok);\n-\n-  if (parts.index)\n-    return false;\n-\n-  if (parts.seg != SEG_DEFAULT)\n-    return false;\n-\n-  /* Do not support (%rip).  */\n-  if (parts.disp && flag_pic && TARGET_64BIT\n-      && SYMBOLIC_CONST (parts.disp)\n-      && (GET_CODE (parts.disp) != CONST\n-\t  || GET_CODE (XEXP (parts.disp, 0)) != PLUS\n-\t  || GET_CODE (XEXP (XEXP (parts.disp, 0), 0)) != UNSPEC\n-\t  || !CONST_INT_P (XEXP (XEXP (parts.disp, 0), 1))\n-\t  || (XINT (XEXP (XEXP (parts.disp, 0), 0), 1) != UNSPEC_DTPOFF\n-\t      && XINT (XEXP (XEXP (parts.disp, 0), 0), 1) != UNSPEC_NTPOFF)))\n-    return false;\n-\n-  return true;\n-})\n-\n (define_predicate \"vsib_mem_operator\"\n   (match_code \"mem\"))\n \n-(define_predicate \"bnd_mem_operator\"\n-  (match_code \"mem\"))\n-\n ;; Return true if the rtx is known to be at least 32 bits aligned.\n (define_predicate \"aligned_operand\"\n   (match_operand 0 \"general_operand\")"}, {"sha": "ad1533e601d88aef6dad3380ff672f01661e54ce", "filename": "gcc/dbxout.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -2367,10 +2367,6 @@ dbxout_type (tree type, int full)\n       dbxout_type (TREE_TYPE (type), 0);\n       break;\n \n-    case POINTER_BOUNDS_TYPE:\n-      /* No debug info for pointer bounds type supported yet.  */\n-      break;\n-\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "da2c63ef00bf6b3805b865997d5991a70e8a088a", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 6, "deletions": 212, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -82,7 +82,6 @@ extensions, accepted by GCC in C90 mode and in C++.\n * x86 specific memory model extensions for transactional memory:: x86 memory models.\n * Object Size Checking:: Built-in functions for limited buffer overflow\n                         checking.\n-* Pointer Bounds Checker builtins:: Built-in functions for Pointer Bounds Checker.\n * Cilk Plus Builtins::  Built-in functions for the Cilk Plus language extension.\n * Other Builtins::      Other built-in functions.\n * Target Builtins::     Built-in functions specific to particular targets.\n@@ -2167,7 +2166,7 @@ attributes are currently defined for functions on all targets:\n @code{returns_nonnull}, @code{gnu_inline},\n @code{externally_visible}, @code{hot}, @code{cold}, @code{artificial},\n @code{no_sanitize_address}, @code{no_address_safety_analysis},\n-@code{no_sanitize_undefined}, @code{bnd_legacy},\n+@code{no_sanitize_undefined},\n @code{error} and @code{warning}.\n Several other attributes are defined for functions on particular\n target systems.  Other attributes, including @code{section} are\n@@ -3611,12 +3610,6 @@ The @code{no_sanitize_undefined} attribute on functions is used\n to inform the compiler that it should not check for undefined behavior\n in the function when compiling with the @option{-fsanitize=undefined} option.\n \n-@item bnd_legacy\n-@cindex @code{bnd_legacy} function attribute\n-The @code{bnd_legacy} attribute on functions is used to inform\n-compiler that function should not be instrumented when compiled\n-with @option{-fcheck-pointers} option.\n-\n @item regparm (@var{number})\n @cindex @code{regparm} attribute\n @cindex functions that are passed arguments in registers on the 386\n@@ -5410,12 +5403,12 @@ placed in either the @code{.bss_below100} section or the\n The keyword @code{__attribute__} allows you to specify special\n attributes of @code{struct} and @code{union} types when you define\n such types.  This keyword is followed by an attribute specification\n-inside double parentheses.  Eight attributes are currently defined for\n+inside double parentheses.  Seven attributes are currently defined for\n types: @code{aligned}, @code{packed}, @code{transparent_union},\n-@code{unused}, @code{deprecated}, @code{visibility}, @code{may_alias}\n-and @code{bnd_variable_size}.  Other attributes are defined for\n-functions (@pxref{Function Attributes}) and for variables\n-(@pxref{Variable Attributes}).\n+@code{unused}, @code{deprecated}, @code{visibility}, and\n+@code{may_alias}.  Other attributes are defined for functions\n+(@pxref{Function Attributes}) and for variables (@pxref{Variable\n+Attributes}).\n \n You may also specify any one of these attributes with @samp{__}\n preceding and following its keyword.  This allows you to use these\n@@ -5707,35 +5700,6 @@ and caught in another, the class must have default visibility.\n Otherwise the two shared objects are unable to use the same\n typeinfo node and exception handling will break.\n \n-@item bnd_variable_size\n-When applied to a structure field, this attribute tells Pointer\n-Bounds Checker that the size of this field should not be computed\n-using static type information.  It may be used to mark variable\n-sized static array fields placed at the end of a structure.\n-\n-@smallexample\n-struct S\n-@{\n-  int size;\n-  char data[1];\n-@}\n-S *p = (S *)malloc (sizeof(S) + 100);\n-p->data[10] = 0; //Bounds violation\n-@end smallexample\n-\n-By using an attribute for a field we may avoid bound violation\n-we most probably do not want to see:\n-\n-@smallexample\n-struct S\n-@{\n-  int size;\n-  char data[1] __attribute__((bnd_variable_size));\n-@}\n-S *p = (S *)malloc (sizeof(S) + 100);\n-p->data[10] = 0; //OK\n-@end smallexample\n-\n @end table\n \n To specify multiple attributes, separate them by commas within the\n@@ -7871,176 +7835,6 @@ format string @var{fmt}.  If the compiler is able to optimize them to\n @code{fputc} etc.@: functions, it does, otherwise the checking function\n is called and the @var{flag} argument passed to it.\n \n-@node Pointer Bounds Checker builtins\n-@section Pointer Bounds Checker Built-in Functions\n-@findex __builtin___bnd_set_ptr_bounds\n-@findex __builtin___bnd_narrow_ptr_bounds\n-@findex __builtin___bnd_copy_ptr_bounds\n-@findex __builtin___bnd_init_ptr_bounds\n-@findex __builtin___bnd_null_ptr_bounds\n-@findex __builtin___bnd_store_ptr_bounds\n-@findex __builtin___bnd_chk_ptr_lbounds\n-@findex __builtin___bnd_chk_ptr_ubounds\n-@findex __builtin___bnd_chk_ptr_bounds\n-@findex __builtin___bnd_get_ptr_lbound\n-@findex __builtin___bnd_get_ptr_ubound\n-\n-GCC provides a set of built-in functions to control Pointer Bounds Checker\n-instrumentation.  Note that all Pointer Bounds Checker builtins are allowed\n-to use even if you compile with Pointer Bounds Checker off.  But functions\n-behavior may differ in such case.\n-\n-@deftypefn {Built-in Function} void * __builtin___bnd_set_ptr_bounds (const void * @var{q}, size_t @var{size})\n-\n-This built-in function returns a new pointer with the value of @var{q}, and\n-associate it with the bounds [@var{q}, @var{q}+@var{size}-1].  With Pointer\n-Bounds Checker off built-in function just returns the first argument.\n-\n-@smallexample\n-extern void *__wrap_malloc (size_t n)\n-@{\n-  void *p = (void *)__real_malloc (n);\n-  if (!p) return __builtin___bnd_null_ptr_bounds (p);\n-  return __builtin___bnd_set_ptr_bounds (p, n);\n-@}\n-@end smallexample\n-\n-@end deftypefn\n-\n-@deftypefn {Built-in Function} void * __builtin___bnd_narrow_ptr_bounds (const void * @var{p}, const void * @var{q}, size_t  @var{size})\n-\n-This built-in function returns a new pointer with the value of @var{p}\n-and associate it with the narrowed bounds formed by the intersection\n-of bounds associated with @var{q} and the [@var{p}, @var{p} + @var{size} - 1].\n-With Pointer Bounds Checker off built-in function just returns the first\n-argument.\n-\n-@smallexample\n-void init_objects (object *objs, size_t size)\n-@{\n-  size_t i;\n-  /* Initialize objects one-by-one passing pointers with bounds of an object,\n-     not the full array of objects.  */\n-  for (i = 0; i < size; i++)\n-    init_object (__builtin___bnd_narrow_ptr_bounds (objs + i, objs, sizeof(object)));\n-@}\n-@end smallexample\n-\n-@end deftypefn\n-\n-@deftypefn {Built-in Function} void * __builtin___bnd_copy_ptr_bounds (const void * @var{q}, const void * @var{r})\n-\n-This built-in function returns a new pointer with the value of @var{q},\n-and associate it with the bounds already associated with pointer @var{r}.\n-With Pointer Bounds Checker off built-in function just returns the first\n-argument.\n-\n-@smallexample\n-/* Here is a way to get pointer to object's field but\n-   still with the full object's bounds.  */\n-int *field_ptr = __builtin___bnd_copy_ptr_bounds (&objptr->int_filed, objptr);\n-@end smallexample\n-\n-@end deftypefn\n-\n-@deftypefn {Built-in Function} void * __builtin___bnd_init_ptr_bounds (const void * @var{q})\n-\n-This built-in function returns a new pointer with the value of @var{q}, and\n-associate it with INIT (allowing full memory access) bounds. With Pointer\n-Bounds Checker off built-in function just returns the first argument.\n-\n-@end deftypefn\n-\n-@deftypefn {Built-in Function} void * __builtin___bnd_null_ptr_bounds (const void * @var{q})\n-\n-This built-in function returns a new pointer with the value of @var{q}, and\n-associate it with NULL (allowing no memory access) bounds. With Pointer\n-Bounds Checker off built-in function just returns the first argument.\n-\n-@end deftypefn\n-\n-@deftypefn {Built-in Function} void __builtin___bnd_store_ptr_bounds (const void ** @var{ptr_addr}, const void * @var{ptr_val})\n-\n-This built-in function stores the bounds associated with pointer @var{ptr_val}\n-and location @var{ptr_addr} into Bounds Table.  This can be useful to propagate\n-bounds from legacy code without touching the associated pointer's memory when\n-pointers were copied as integers.  With Pointer Bounds Checker off built-in\n-function call is ignored.\n-\n-@end deftypefn\n-\n-@deftypefn {Built-in Function} void __builtin___bnd_chk_ptr_lbounds (const void * @var{q})\n-\n-This built-in function checks if the pointer @var{q} is within the lower\n-bound of its associated bounds.  With Pointer Bounds Checker off built-in\n-function call is ignored.\n-\n-@smallexample\n-extern void *__wrap_memset (void *dst, int c, size_t len)\n-@{\n-  if (len > 0)\n-    @{\n-      __builtin___bnd_chk_ptr_lbounds (dst);\n-      __builtin___bnd_chk_ptr_ubounds ((char *)dst + len - 1);\n-      __real_memset (dst, c, len);\n-    @}\n-  return dst;\n-@}\n-@end smallexample\n-\n-@end deftypefn\n-\n-@deftypefn {Built-in Function} void __builtin___bnd_chk_ptr_ubounds (const void * @var{q})\n-\n-This built-in function checks if the pointer @var{q} is within the upper\n-bound of its associated bounds.  With Pointer Bounds Checker off built-in\n-function call is ignored.\n-\n-@end deftypefn\n-\n-@deftypefn {Built-in Function} void __builtin___bnd_chk_ptr_bounds (const void * @var{q}, size_t @var{size})\n-\n-This built-in function checks if [@var{q}, @var{q} + @var{size} - 1] is within\n-the lower and upper bounds associated with @var{q}.  With Pointer Bounds Checker\n-off built-in function call is ignored.\n-\n-@smallexample\n-extern void *__wrap_memcpy (void *dst, const void *src, size_t n)\n-@{\n-  if (n > 0)\n-    @{\n-      __bnd_chk_ptr_bounds (dst, n);\n-      __bnd_chk_ptr_bounds (src, n);\n-      __real_memcpy (dst, src, n);\n-    @}\n-  return dst;\n-@}\n-@end smallexample\n-\n-@end deftypefn\n-\n-@deftypefn {Built-in Function} const void * __builtin___bnd_get_ptr_lbound (const void * @var{q})\n-\n-This built-in function returns the lower bound (which is a pointer) associated\n-with the pointer @var{q}.  This is at least useful for debugging using printf.\n-With Pointer Bounds Checker off built-in function returns 0.\n-\n-@smallexample\n-void *lb = __builtin___bnd_get_ptr_lbound (q);\n-void *ub = __builtin___bnd_get_ptr_ubound (q);\n-printf (\"q = %p  lb(q) = %p  ub(q) = %p\", q, lb, ub);\n-@end smallexample\n-\n-@end deftypefn\n-\n-@deftypefn {Built-in Function} const void * __builtin___bnd_get_ptr_ubound (const void * @var{q})\n-\n-This built-in function returns the upper bound (which is a pointer) associated\n-with the pointer @var{q}.  With Pointer Bounds Checker off built-in function\n-returns -1.\n-\n-@end deftypefn\n-\n @node Cilk Plus Builtins\n @section Cilk Plus C/C++ language extension Built-in Functions.\n "}, {"sha": "54aa8b347f9294343a7e59cb8e1e488f99192133", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -669,7 +669,7 @@ Objective-C and Objective-C++ Dialects}.\n -mavx2 -mavx512f -mavx512pf -mavx512er -mavx512cd @gol\n -maes -mpclmul -mfsgsbase -mrdrnd -mf16c -mfma @gol\n -msse4a -m3dnow -mpopcnt -mabm -mbmi -mtbm -mfma4 -mxop -mlzcnt @gol\n--mbmi2 -mfxsr -mxsave -mxsaveopt -mrtm -mlwp -mmpx -mthreads @gol\n+-mbmi2 -mfxsr -mxsave -mxsaveopt -mrtm -mlwp -mthreads @gol\n -mno-align-stringops  -minline-all-stringops @gol\n -minline-stringops-dynamically -mstringop-strategy=@var{alg} @gol\n -mmemcpy-strategy=@var{strategy} -mmemset-strategy=@var{strategy}\n@@ -15090,8 +15090,6 @@ preferred alignment to @option{-mpreferred-stack-boundary=2}.\n @itemx -mrtm\n @itemx -mtbm\n @itemx -mno-tbm\n-@itemx -mmpx\n-@itemx -mno-mpx\n @opindex mmmx\n @opindex mno-mmx\n @opindex msse\n@@ -15101,7 +15099,7 @@ preferred alignment to @option{-mpreferred-stack-boundary=2}.\n These switches enable or disable the use of instructions in the MMX, SSE,\n SSE2, SSE3, SSSE3, SSE4.1, AVX, AVX2, AVX512F, AVX512PF, AVX512ER, AVX512CD,\n AES, PCLMUL, FSGSBASE, RDRND, F16C, FMA, SSE4A, FMA4, XOP, LWP, ABM, BMI, BMI2,\n-FXSR, XSAVE, XSAVEOPT, LZCNT, RTM, MPX or 3DNow!@:\n+FXSR, XSAVE, XSAVEOPT, LZCNT, RTM or 3DNow!@:\n extended instruction sets.\n These extensions are also available as built-in functions: see\n @ref{X86 Built-in Functions}, for details of the functions enabled and"}, {"sha": "84c0444ad9c44f49ca00557e0352152fb7272ded", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -1295,12 +1295,6 @@ These modes stand for a complex number represented as a pair of integer\n values.  The integer values are in @code{QImode}, @code{HImode},\n @code{SImode}, @code{DImode}, @code{TImode}, and @code{OImode},\n respectively.\n-\n-@findex BND32mode\n-@findex BND64mode\n-@item BND32mode BND64mode\n-These modes stand for bounds for pointer of 32 and 64 bit size respectively.\n-Mode size is double pointer mode size.\n @end table\n \n The machine description defines @code{Pmode} as a C macro which expands\n@@ -1388,12 +1382,6 @@ any @code{CC_MODE} modes listed in the @file{@var{machine}-modes.def}.\n @xref{Jump Patterns},\n also see @ref{Condition Code}.\n \n-@findex MODE_POINTER_BOUNDS\n-@item MODE_POINTER_BOUNDS\n-Pointer bounds modes.  Used to represent values of pointer bounds type.\n-Operations in these modes may be executed as NOPs depending on hardware\n-features and environment setup.\n-\n @findex MODE_RANDOM\n @item MODE_RANDOM\n This is a catchall mode class for modes which don't fit into the above"}, {"sha": "2fd5466a1646e277a6173fe1746f84ac8bf81d6f", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 0, "deletions": 117, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -4338,13 +4338,6 @@ This hook returns the va_list type of the calling convention specified by\n The default version of this hook returns @code{va_list_type_node}.\n @end deftypefn\n \n-@deftypefn {Target Hook} tree TARGET_FN_ABI_VA_LIST_BOUNDS_SIZE (tree @var{fndecl})\n-This hook returns size for @code{va_list} object in function specified\n-by @var{fndecl}.  This hook is used by Pointer Bounds Checker to build bounds\n-for @code{va_list} object.  Return @code{integer_zero_node} if no bounds\n-should be used (e.g. @code{va_list} is a scalar pointer to the stack).\n-@end deftypefn\n-\n @deftypefn {Target Hook} tree TARGET_CANONICAL_VA_LIST_TYPE (tree @var{type})\n This hook returns the va_list type of the calling convention specified by the\n type of @var{type}. If @var{type} is not a valid va_list type, it returns\n@@ -5162,26 +5155,6 @@ defined, then define this hook to return @code{true} if\n Otherwise, you should not define this hook.\n @end deftypefn\n \n-@deftypefn {Target Hook} rtx TARGET_LOAD_BOUNDS_FOR_ARG (rtx @var{slot}, rtx @var{arg}, rtx @var{slot_no})\n-This hook is used by expand pass to emit insn to load bounds of\n-@var{arg} passed in @var{slot}.  Expand pass uses this hook in case\n-bounds of @var{arg} are not passed in register.  If @var{slot} is a\n-memory, then bounds are loaded as for regular pointer loaded from\n-memory.  If @var{slot} is not a memory then @var{slot_no} is an integer\n-constant holding number of the target dependent special slot which\n-should be used to obtain bounds.  Hook returns RTX holding loaded bounds.\n-@end deftypefn\n-\n-@deftypefn {Target Hook} void TARGET_STORE_BOUNDS_FOR_ARG (rtx @var{arg}, rtx @var{slot}, rtx @var{bounds}, rtx @var{slot_no})\n-This hook is used by expand pass to emit insns to store @var{bounds} of\n-@var{arg} passed in @var{slot}.  Expand pass uses this hook in case\n-@var{bounds} of @var{arg} are not passed in register.  If @var{slot} is a\n-memory, then @var{bounds} are stored as for regular pointer stored in\n-memory.  If @var{slot} is not a memory then @var{slot_no} is an integer\n-constant holding number of the target dependent special slot which\n-should be used to store @var{bounds}.\n-@end deftypefn\n-\n @node Trampolines\n @section Trampolines for Nested Functions\n @cindex trampolines for nested functions\n@@ -10977,96 +10950,6 @@ ignored.  This function should return the result of the call to the\n built-in function.\n @end deftypefn\n \n-@deftypefn {Target Hook} tree TARGET_BUILTIN_CHKP_FUNCTION (unsigned @var{fcode})\n-This hook allows target to redefine built-in functions used by\n-Pointer Bounds Checker for code instrumentation.  Hook should return\n-fndecl of function implementing generic builtin whose code is\n-passed in @var{fcode}.  Currently following built-in functions are\n-obtained using this hook:\n-@deftypefn {Built-in Function} bnd __chkp_bndmk (const void *@var{lb}, size_t @var{size})\n-Function code - BUILT_IN_CHKP_BNDMK.  This built-in function is used\n-by Pointer Bounds Checker to create bound values.  @var{lb} holds low\n-bound of the resulting bounds.  @var{size} holds size of created bounds.\n-@end deftypefn\n-\n-@deftypefn {Built-in Function} void __chkp_bndstx (const void **@var{loc}, const void *@var{ptr}, bnd @var{b})\n-Function code - @code{BUILT_IN_CHKP_BNDSTX}.  This built-in function is used\n-by Pointer Bounds Checker to store bounds @var{b} for pointer @var{ptr}\n-stored by address @var{loc}.\n-@end deftypefn\n-\n-@deftypefn {Built-in Function} bnd __chkp_bndldx (const void **@var{loc}, const void *@var{ptr})\n-Function code - @code{BUILT_IN_CHKP_BNDLDX}.  This built-in function is used\n-by Pointer Bounds Checker to get bounds of pointer @var{ptr} loaded by\n-address @var{loc}.\n-@end deftypefn\n-\n-@deftypefn {Built-in Function} void __chkp_bndcl (bnd @var{b}, const void *@var{ptr})\n-Function code - @code{BUILT_IN_CHKP_BNDCL}.  This built-in function is used\n-by Pointer Bounds Checker to perform check for pointer @var{ptr} against\n-lower bound of bounds @var{b}.\n-@end deftypefn\n-\n-@deftypefn {Built-in Function} void __chkp_bndcu (bnd @var{b}, const void *@var{ptr})\n-Function code - @code{BUILT_IN_CHKP_BNDCU}.  This built-in function is used\n-by Pointer Bounds Checker to perform check for pointer @var{ptr} against\n-upper bound of bounds @var{b}.\n-@end deftypefn\n-\n-@deftypefn {Built-in Function} bnd __chkp_bndret (void *@var{ptr})\n-Function code - @code{BUILT_IN_CHKP_BNDRET}.  This built-in function is used\n-by Pointer Bounds Checker to obtain bounds returned by call statement.\n-@var{ptr} passed to buil-in is @code{SSA_NAME} returned by call.\n-@end deftypefn\n-\n-@deftypefn {Built-in Function} bnd __chkp_arg_bnd (void *@var{arg})\n-Function code - @code{BUILT_IN_CHKP_ARG_BND}.   This built-in function is\n-used by Pointer Bounds Checker to obtain bounds passed for input argument.\n-@var{arg} is default @code{SSA_NAME} of the @code{PARM_DECL} whose\n-bounds we want to obtain.\n-@end deftypefn\n-\n-@deftypefn {Built-in Function} bnd __chkp_intersect (bnd @var{b1}, bnd @var{b2})\n-Function code - @code{BUILT_IN_CHKP_INTERSECT}.  This built-in function\n-returns intersection of bounds @var{b1} and @var{b2}.\n-@end deftypefn\n-\n-@deftypefn {Built-in Function} bnd __chkp_narrow (const void *@var{ptr}, bnd @var{b}, size_t @var{s})\n-Function code - @code{BUILT_IN_CHKP_NARROW}.  This built-in function\n-returns intersection of bounds @var{b} and\n-[@var{ptr}, @var{ptr} + @var{s} - @code{1}].\n-@end deftypefn\n-\n-@deftypefn {Built-in Function} void *__chkp_set_bounds (const void *@var{ptr}, size_t @var{s})\n-Function code - @code{BUILT_IN_CHKP_SET_PTR_BOUNDS}.  This built-in function\n-returns @var{ptr} with bounds [@var{ptr}, @var{ptr} + @var{s} - @code{1}].\n-@end deftypefn\n-\n-@deftypefn {Built-in Function} size_t __chkp_sizeof (const void *@var{ptr})\n-Function code - @code{BUILT_IN_CHKP_SIZEOF}.  This built-in function\n-returns size of object referenced by @var{ptr}. @var{ptr} is always\n-@code{ADDR_EXPR} of @code{VAR_DECL}.  This built-in is used by\n-Pointer Boudns Checker when bounds of object cannot be computed statically\n-(e.g. object has incomplete type).\n-@end deftypefn\n-\n-@deftypefn {Built-in Function} const void *__chkp_extract_lower (bnd @var{b})\n-Function code - @code{BUILT_IN_CHKP_EXTRACT_LOWER}.  This built-in function\n-returns lower bound of bounds @var{b}.\n-@end deftypefn\n-\n-@deftypefn {Built-in Function} const void *__chkp_extract_upper (bnd @var{b})\n-Function code - @code{BUILT_IN_CHKP_EXTRACT_UPPER}.  This built-in function\n-returns upper bound of bounds @var{b}.\n-@end deftypefn\n-@end deftypefn\n-@deftypefn {Target Hook} tree TARGET_CHKP_BOUND_TYPE (void)\n-Return type to be used for bounds\n-@end deftypefn\n-@deftypefn {Target Hook} {enum machine_mode} TARGET_CHKP_BOUND_MODE (void)\n-Return mode to be used for bounds.\n-@end deftypefn\n-\n @deftypefn {Target Hook} tree TARGET_RESOLVE_OVERLOADED_BUILTIN (unsigned int @var{loc}, tree @var{fndecl}, void *@var{arglist})\n Select a replacement for a machine specific built-in function that\n was set up by @samp{TARGET_INIT_BUILTINS}.  This is done"}, {"sha": "7e459ebd087d37dc0e46eb328058e37d6b160627", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -3696,8 +3696,6 @@ stack.\n \n @hook TARGET_FN_ABI_VA_LIST\n \n-@hook TARGET_FN_ABI_VA_LIST_BOUNDS_SIZE\n-\n @hook TARGET_CANONICAL_VA_LIST_TYPE\n \n @hook TARGET_GIMPLIFY_VA_ARG_EXPR\n@@ -4068,10 +4066,6 @@ These machine description macros help implement varargs:\n \n @hook TARGET_PRETEND_OUTGOING_VARARGS_NAMED\n \n-@hook TARGET_LOAD_BOUNDS_FOR_ARG\n-\n-@hook TARGET_STORE_BOUNDS_FOR_ARG\n-\n @node Trampolines\n @section Trampolines for Nested Functions\n @cindex trampolines for nested functions\n@@ -8210,10 +8204,6 @@ to by @var{ce_info}.\n \n @hook TARGET_EXPAND_BUILTIN\n \n-@hook TARGET_BUILTIN_CHKP_FUNCTION\n-@hook TARGET_CHKP_BOUND_TYPE\n-@hook TARGET_CHKP_BOUND_MODE\n-\n @hook TARGET_RESOLVE_OVERLOADED_BUILTIN\n \n @hook TARGET_FOLD_BUILTIN"}, {"sha": "14d1bf77f227e8d5f82509b02ff4a8c57c632180", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -18289,7 +18289,7 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t    gen_formal_parameter_pack_die (generic_decl_parm,\n \t\t\t\t\t   parm, subr_die,\n \t\t\t\t\t   &parm);\n-\t  else if (parm && !POINTER_BOUNDS_P (parm))\n+\t  else if (parm)\n \t    {\n \t      dw_die_ref parm_die = gen_decl_die (parm, NULL, subr_die);\n \n@@ -18301,8 +18301,6 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \n \t      parm = DECL_CHAIN (parm);\n \t    }\n-\t  else if (parm)\n-\t    parm = DECL_CHAIN (parm);\n \n \t  if (generic_decl_parm)\n \t    generic_decl_parm = DECL_CHAIN (generic_decl_parm);\n@@ -19800,7 +19798,6 @@ gen_type_die_with_usage (tree type, dw_die_ref context_die,\n     case FIXED_POINT_TYPE:\n     case COMPLEX_TYPE:\n     case BOOLEAN_TYPE:\n-    case POINTER_BOUNDS_TYPE:\n       /* No DIEs needed for fundamental types.  */\n       break;\n \n@@ -20451,8 +20448,7 @@ dwarf2out_global_decl (tree decl)\n      declarations, file-scope (extern) function declarations (which\n      had no corresponding body) and file-scope tagged type declarations\n      and definitions which have not yet been forced out.  */\n-  if ((TREE_CODE (decl) != FUNCTION_DECL || !DECL_INITIAL (decl))\n-      && !POINTER_BOUNDS_P (decl))\n+  if (TREE_CODE (decl) != FUNCTION_DECL || !DECL_INITIAL (decl))\n     dwarf2out_decl (decl);\n }\n "}, {"sha": "3c1ce0e9301a87fe1f8653f0f99ed5149d1845c3", "filename": "gcc/genmodes.c", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fgenmodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fgenmodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmodes.c?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -333,7 +333,6 @@ complete_mode (struct mode_data *m)\n       break;\n \n     case MODE_INT:\n-    case MODE_POINTER_BOUNDS:\n     case MODE_FLOAT:\n     case MODE_DECIMAL_FLOAT:\n     case MODE_FRACT:\n@@ -535,19 +534,6 @@ make_special_mode (enum mode_class cl, const char *name,\n   new_mode (cl, name, file, line);\n }\n \n-#define POINTER_BOUNDS_MODE(N, Y) \\\n-  make_pointer_bounds_mode (#N, Y, __FILE__, __LINE__)\n-\n-static void ATTRIBUTE_UNUSED\n-make_pointer_bounds_mode (const char *name,\n-\t\t\t  unsigned int bytesize,\n-\t\t\t  const char *file, unsigned int line)\n-{\n-  struct mode_data *m = new_mode (MODE_POINTER_BOUNDS, name, file, line);\n-  m->bytesize = bytesize;\n-}\n-\n-\n #define INT_MODE(N, Y) FRACTIONAL_INT_MODE (N, -1U, Y)\n #define FRACTIONAL_INT_MODE(N, B, Y) \\\n   make_int_mode (#N, B, Y, __FILE__, __LINE__)"}, {"sha": "2917bee9614d12650d7020de0371efaccf8a7f34", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -547,12 +547,11 @@ dump_gimple_assign (pretty_printer *buffer, gimple gs, int spc, int flags)\n static void\n dump_gimple_return (pretty_printer *buffer, gimple gs, int spc, int flags)\n {\n-  tree t, t2;\n+  tree t;\n \n   t = gimple_return_retval (gs);\n-  t2 = gimple_return_retbnd (gs);\n   if (flags & TDF_RAW)\n-    dump_gimple_fmt (buffer, spc, flags, \"%G <%T %T>\", gs, t, t2);\n+    dump_gimple_fmt (buffer, spc, flags, \"%G <%T>\", gs, t);\n   else\n     {\n       pp_string (buffer, \"return\");\n@@ -561,11 +560,6 @@ dump_gimple_return (pretty_printer *buffer, gimple gs, int spc, int flags)\n \t  pp_space (buffer);\n \t  dump_generic_node (buffer, t, spc, flags, false);\n \t}\n-      if (t2)\n-\t{\n-\t  pp_string (buffer, \", \");\n-\t  dump_generic_node (buffer, t2, spc, flags, false);\n-\t}\n       pp_semicolon (buffer);\n     }\n }"}, {"sha": "7bc87bc34ee8442e5b1bfb321c8bc8d04621ac2e", "filename": "gcc/gimple.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -180,7 +180,7 @@ gimple_build_with_ops_stat (enum gimple_code code, unsigned subcode,\n gimple\n gimple_build_return (tree retval)\n {\n-  gimple s = gimple_build_with_ops (GIMPLE_RETURN, ERROR_MARK, 2);\n+  gimple s = gimple_build_with_ops (GIMPLE_RETURN, ERROR_MARK, 1);\n   if (retval)\n     gimple_return_set_retval (s, retval);\n   return s;"}, {"sha": "a97a5e8b2d4301a17f0ebe85fd1c5e6a201d8195", "filename": "gcc/gimple.h", "status": "modified", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -90,7 +90,6 @@ enum gf_mask {\n     GF_CALL_NOTHROW\t\t= 1 << 4,\n     GF_CALL_ALLOCA_FOR_VAR\t= 1 << 5,\n     GF_CALL_INTERNAL\t\t= 1 << 6,\n-    GF_CALL_WITH_BOUNDS \t= 1 << 7,\n     GF_OMP_PARALLEL_COMBINED\t= 1 << 0,\n     GF_OMP_FOR_KIND_MASK\t= 3 << 0,\n     GF_OMP_FOR_KIND_FOR\t\t= 0 << 0,\n@@ -2435,31 +2434,6 @@ gimple_call_internal_p (const_gimple gs)\n }\n \n \n-/* Return true if call GS is marked as instrumented by\n-   Pointer Bounds Checker.  */\n-\n-static inline bool\n-gimple_call_with_bounds_p (const_gimple gs)\n-{\n-  GIMPLE_CHECK (gs, GIMPLE_CALL);\n-  return (gs->subcode & GF_CALL_WITH_BOUNDS) != 0;\n-}\n-\n-\n-/* If INSTRUMENTED_P is true, marm statement GS as instrumented by\n-   Pointer Bounds Checker.  */\n-\n-static inline void\n-gimple_call_set_with_bounds (gimple gs, bool with_bounds)\n-{\n-  GIMPLE_CHECK (gs, GIMPLE_CALL);\n-  if (with_bounds)\n-    gs->subcode |= GF_CALL_WITH_BOUNDS;\n-  else\n-    gs->subcode &= ~GF_CALL_WITH_BOUNDS;\n-}\n-\n-\n /* Return the target of internal call GS.  */\n \n static inline enum internal_fn\n@@ -5539,26 +5513,6 @@ gimple_return_set_retval (gimple gs, tree retval)\n }\n \n \n-/* Return the return bounds for GIMPLE_RETURN GS.  */\n-\n-static inline tree\n-gimple_return_retbnd (const_gimple gs)\n-{\n-  GIMPLE_CHECK (gs, GIMPLE_RETURN);\n-  return gimple_op (gs, 1);\n-}\n-\n-\n-/* Set RETVAL to be the return bounds for GIMPLE_RETURN GS.  */\n-\n-static inline void\n-gimple_return_set_retbnd (gimple gs, tree retval)\n-{\n-  GIMPLE_CHECK (gs, GIMPLE_RETURN);\n-  gimple_set_op (gs, 1, retval);\n-}\n-\n-\n /* Returns true when the gimple statement STMT is any of the OpenMP types.  */\n \n #define CASE_GIMPLE_OMP\t\t\t\t\\"}, {"sha": "7b9dd5abeebc202c3e46fbe4880dadeecfbede76", "filename": "gcc/gimplify.c", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -3774,19 +3774,10 @@ gimplify_init_constructor (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t   individual element initialization.  Also don't do this for small\n \t   all-zero initializers (which aren't big enough to merit\n \t   clearing), and don't try to make bitwise copies of\n-\t   TREE_ADDRESSABLE types.\n-\n-\t   We cannot apply such transformation when compiling chkp static\n-\t   initializer because creation of initializer image in the memory\n-\t   will require static initialization of bounds for it.  It should\n-\t   result in another gimplification of similar initializer and we\n-\t   may fall into infinite loop.  */\n+\t   TREE_ADDRESSABLE types.  */\n \tif (valid_const_initializer\n \t    && !(cleared || num_nonzero_elements == 0)\n-\t    && !TREE_ADDRESSABLE (type)\n-\t    && (!current_function_decl\n-\t\t|| !lookup_attribute (\"chkp ctor\",\n-\t\t\t\t      DECL_ATTRIBUTES (current_function_decl))))\n+\t    && !TREE_ADDRESSABLE (type))\n \t  {\n \t    HOST_WIDE_INT size = int_size_in_bytes (type);\n \t    unsigned int align;"}, {"sha": "520a5bbdaec932811905d623946e854be5883f91", "filename": "gcc/ipa.c", "status": "modified", "additions": 6, "deletions": 24, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -1275,11 +1275,9 @@ make_pass_ipa_whole_program_visibility (gcc::context *ctxt)\n }\n \n /* Generate and emit a static constructor or destructor.  WHICH must\n-   be one of 'I' (for a constructor), 'D' (for a destructor), 'P'\n-   (for chp static vars constructor) or 'B' (for chkp static bounds\n-   constructor).  BODY is a STATEMENT_LIST containing GENERIC\n-   statements.  PRIORITY is the initialization priority for this\n-   constructor or destructor.\n+   be one of 'I' (for a constructor) or 'D' (for a destructor).  BODY\n+   is a STATEMENT_LIST containing GENERIC statements.  PRIORITY is the\n+   initialization priority for this constructor or destructor. \n \n    FINAL specify whether the externally visible name for collect2 should\n    be produced. */\n@@ -1338,20 +1336,6 @@ cgraph_build_static_cdtor_1 (char which, tree body, int priority, bool final)\n       DECL_STATIC_CONSTRUCTOR (decl) = 1;\n       decl_init_priority_insert (decl, priority);\n       break;\n-    case 'P':\n-      DECL_STATIC_CONSTRUCTOR (decl) = 1;\n-      DECL_ATTRIBUTES (decl) = tree_cons (get_identifier (\"chkp ctor\"),\n-\t\t\t\t\t  NULL,\n-\t\t\t\t\t  NULL_TREE);\n-      decl_init_priority_insert (decl, priority);\n-      break;\n-    case 'B':\n-      DECL_STATIC_CONSTRUCTOR (decl) = 1;\n-      DECL_ATTRIBUTES (decl) = tree_cons (get_identifier (\"bnd_legacy\"),\n-\t\t\t\t\t  NULL,\n-\t\t\t\t\t  NULL_TREE);\n-      decl_init_priority_insert (decl, priority);\n-      break;\n     case 'D':\n       DECL_STATIC_DESTRUCTOR (decl) = 1;\n       decl_fini_priority_insert (decl, priority);\n@@ -1369,11 +1353,9 @@ cgraph_build_static_cdtor_1 (char which, tree body, int priority, bool final)\n }\n \n /* Generate and emit a static constructor or destructor.  WHICH must\n-   be one of 'I' (for a constructor), 'D' (for a destructor), 'P'\n-   (for chkp static vars constructor) or 'B' (for chkp static bounds\n-   constructor).  BODY is a STATEMENT_LIST containing GENERIC\n-   statements.  PRIORITY is the initialization priority for this\n-   constructor or destructor.  */\n+   be one of 'I' (for a constructor) or 'D' (for a destructor).  BODY\n+   is a STATEMENT_LIST containing GENERIC statements.  PRIORITY is the\n+   initialization priority for this constructor or destructor.  */\n \n void\n cgraph_build_static_cdtor (char which, tree body, int priority)"}, {"sha": "6f2773c70ba3d8909d51094f432328d70acaaae4", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -581,7 +581,6 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, struct varpool_node\n \t\t     && boundary_p && !DECL_EXTERNAL (node->decl), 1);\n \t  /* in_other_partition.  */\n     }\n-  bp_pack_value (&bp, node->need_bounds_init, 1);\n   streamer_write_bitpack (&bp);\n   if (node->same_comdat_group && !boundary_p)\n     {\n@@ -1152,7 +1151,6 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n   node->analyzed = bp_unpack_value (&bp, 1);\n   node->used_from_other_partition = bp_unpack_value (&bp, 1);\n   node->in_other_partition = bp_unpack_value (&bp, 1);\n-  node->need_bounds_init = bp_unpack_value (&bp, 1);\n   if (node->in_other_partition)\n     {\n       DECL_EXTERNAL (node->decl) = 1;"}, {"sha": "da0923a81a20fb72cb171eb0f2bcb8178b79ce2e", "filename": "gcc/machmode.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -174,9 +174,6 @@ extern const unsigned char mode_class[NUM_MACHINE_MODES];\n    || CLASS == MODE_ACCUM                      \\\n    || CLASS == MODE_UACCUM)\n \n-#define POINTER_BOUNDS_MODE_P(MODE)      \\\n-  (GET_MODE_CLASS (MODE) == MODE_POINTER_BOUNDS)\n-\n /* Get the size in bytes and bits of an object of mode MODE.  */\n \n extern CONST_MODE_SIZE unsigned char mode_size[NUM_MACHINE_MODES];"}, {"sha": "7207ef7712b00939eb053eb74104d91115d5b09f", "filename": "gcc/mode-classes.def", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fmode-classes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fmode-classes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmode-classes.def?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -22,7 +22,6 @@ along with GCC; see the file COPYING3.  If not see\n   DEF_MODE_CLASS (MODE_CC),\t\t/* condition code in a register */ \\\n   DEF_MODE_CLASS (MODE_INT),\t\t/* integer */\t\t\t   \\\n   DEF_MODE_CLASS (MODE_PARTIAL_INT),\t/* integer with padding bits */    \\\n-  DEF_MODE_CLASS (MODE_POINTER_BOUNDS), /* bounds */                       \\\n   DEF_MODE_CLASS (MODE_FRACT),\t\t/* signed fractional number */\t   \\\n   DEF_MODE_CLASS (MODE_UFRACT),\t\t/* unsigned fractional number */   \\\n   DEF_MODE_CLASS (MODE_ACCUM),\t\t/* signed accumulator */\t   \\"}, {"sha": "247a0d0670183a3a7d57f9968fc78b7e0f4a1bc3", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -266,8 +266,7 @@ struct GTY((chain_next (\"RTX_NEXT (&%h)\"),\n      In a CODE_LABEL, part of the two-bit alternate entry field.\n      1 in a CONCAT is VAL_EXPR_IS_COPIED in var-tracking.c.\n      1 in a VALUE is SP_BASED_VALUE_P in cselib.c.\n-     1 in a SUBREG generated by LRA for reload insns.\n-     1 in a CALL for calls instrumented by Pointer Bounds Checker.  */\n+     1 in a SUBREG generated by LRA for reload insns.  */\n   unsigned int jump : 1;\n   /* In a CODE_LABEL, part of the two-bit alternate entry field.\n      1 in a MEM if it cannot trap.\n@@ -1421,10 +1420,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define LRA_SUBREG_P(RTX)\t\\\n   (RTL_FLAG_CHECK1 (\"LRA_SUBREG_P\", (RTX), SUBREG)->jump)\n \n-/* True if call is instrumented by Pointer Bounds Checker.  */\n-#define CALL_EXPR_WITH_BOUNDS_P(RTX) \\\n-  (RTL_FLAG_CHECK1 (\"CALL_EXPR_WITH_BOUNDS_P\", (RTX), CALL)->jump)\n-\n /* Access various components of an ASM_OPERANDS rtx.  */\n \n #define ASM_OPERANDS_TEMPLATE(RTX) XCSTR (RTX, 0, ASM_OPERANDS)"}, {"sha": "9325525dd9fd86c368c6184db8eaf7d2d341a0ed", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -386,7 +386,6 @@ int_mode_for_mode (enum machine_mode mode)\n     case MODE_VECTOR_ACCUM:\n     case MODE_VECTOR_UFRACT:\n     case MODE_VECTOR_UACCUM:\n-    case MODE_POINTER_BOUNDS:\n       mode = mode_for_size (GET_MODE_BITSIZE (mode), MODE_INT, 0);\n       break;\n \n@@ -2125,14 +2124,6 @@ layout_type (tree type)\n       SET_TYPE_MODE (type, VOIDmode);\n       break;\n \n-    case POINTER_BOUNDS_TYPE:\n-      SET_TYPE_MODE (type,\n-                     mode_for_size (TYPE_PRECISION (type),\n-\t\t\t\t    MODE_POINTER_BOUNDS, 0));\n-      TYPE_SIZE (type) = bitsize_int (GET_MODE_BITSIZE (TYPE_MODE (type)));\n-      TYPE_SIZE_UNIT (type) = size_int (GET_MODE_SIZE (TYPE_MODE (type)));\n-      break;\n-\n     case OFFSET_TYPE:\n       TYPE_SIZE (type) = bitsize_int (POINTER_SIZE);\n       TYPE_SIZE_UNIT (type) = size_int (POINTER_SIZE / BITS_PER_UNIT);"}, {"sha": "524a299d4bc1f07abcbcd092cf38b0bc32710137", "filename": "gcc/target.def", "status": "modified", "additions": 0, "deletions": 131, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -2078,104 +2078,6 @@ built-in function.\",\n  (tree exp, rtx target, rtx subtarget, enum machine_mode mode, int ignore),\n  default_expand_builtin)\n \n-DEFHOOK\n-(builtin_chkp_function,\n- \"This hook allows target to redefine built-in functions used by\\n\\\n-Pointer Bounds Checker for code instrumentation.  Hook should return\\n\\\n-fndecl of function implementing generic builtin whose code is\\n\\\n-passed in @var{fcode}.  Currently following built-in functions are\\n\\\n-obtained using this hook:\\n\\\n-@deftypefn {Built-in Function} bnd __chkp_bndmk (const void *@var{lb}, size_t @var{size})\\n\\\n-Function code - BUILT_IN_CHKP_BNDMK.  This built-in function is used\\n\\\n-by Pointer Bounds Checker to create bound values.  @var{lb} holds low\\n\\\n-bound of the resulting bounds.  @var{size} holds size of created bounds.\\n\\\n-@end deftypefn\\n\\\n-\\n\\\n-@deftypefn {Built-in Function} void __chkp_bndstx (const void **@var{loc}, const void *@var{ptr}, bnd @var{b})\\n\\\n-Function code - @code{BUILT_IN_CHKP_BNDSTX}.  This built-in function is used\\n\\\n-by Pointer Bounds Checker to store bounds @var{b} for pointer @var{ptr}\\n\\\n-stored by address @var{loc}.\\n\\\n-@end deftypefn\\n\\\n-\\n\\\n-@deftypefn {Built-in Function} bnd __chkp_bndldx (const void **@var{loc}, const void *@var{ptr})\\n\\\n-Function code - @code{BUILT_IN_CHKP_BNDLDX}.  This built-in function is used\\n\\\n-by Pointer Bounds Checker to get bounds of pointer @var{ptr} loaded by\\n\\\n-address @var{loc}.\\n\\\n-@end deftypefn\\n\\\n-\\n\\\n-@deftypefn {Built-in Function} void __chkp_bndcl (bnd @var{b}, const void *@var{ptr})\\n\\\n-Function code - @code{BUILT_IN_CHKP_BNDCL}.  This built-in function is used\\n\\\n-by Pointer Bounds Checker to perform check for pointer @var{ptr} against\\n\\\n-lower bound of bounds @var{b}.\\n\\\n-@end deftypefn\\n\\\n-\\n\\\n-@deftypefn {Built-in Function} void __chkp_bndcu (bnd @var{b}, const void *@var{ptr})\\n\\\n-Function code - @code{BUILT_IN_CHKP_BNDCU}.  This built-in function is used\\n\\\n-by Pointer Bounds Checker to perform check for pointer @var{ptr} against\\n\\\n-upper bound of bounds @var{b}.\\n\\\n-@end deftypefn\\n\\\n-\\n\\\n-@deftypefn {Built-in Function} bnd __chkp_bndret (void *@var{ptr})\\n\\\n-Function code - @code{BUILT_IN_CHKP_BNDRET}.  This built-in function is used\\n\\\n-by Pointer Bounds Checker to obtain bounds returned by call statement.\\n\\\n-@var{ptr} passed to buil-in is @code{SSA_NAME} returned by call.\\n\\\n-@end deftypefn\\n\\\n-\\n\\\n-@deftypefn {Built-in Function} bnd __chkp_arg_bnd (void *@var{arg})\\n\\\n-Function code - @code{BUILT_IN_CHKP_ARG_BND}.   This built-in function is\\n\\\n-used by Pointer Bounds Checker to obtain bounds passed for input argument.\\n\\\n-@var{arg} is default @code{SSA_NAME} of the @code{PARM_DECL} whose\\n\\\n-bounds we want to obtain.\\n\\\n-@end deftypefn\\n\\\n-\\n\\\n-@deftypefn {Built-in Function} bnd __chkp_intersect (bnd @var{b1}, bnd @var{b2})\\n\\\n-Function code - @code{BUILT_IN_CHKP_INTERSECT}.  This built-in function\\n\\\n-returns intersection of bounds @var{b1} and @var{b2}.\\n\\\n-@end deftypefn\\n\\\n-\\n\\\n-@deftypefn {Built-in Function} bnd __chkp_narrow (const void *@var{ptr}, bnd @var{b}, size_t @var{s})\\n\\\n-Function code - @code{BUILT_IN_CHKP_NARROW}.  This built-in function\\n\\\n-returns intersection of bounds @var{b} and\\n\\\n-[@var{ptr}, @var{ptr} + @var{s} - @code{1}].\\n\\\n-@end deftypefn\\n\\\n-\\n\\\n-@deftypefn {Built-in Function} void *__chkp_set_bounds (const void *@var{ptr}, size_t @var{s})\\n\\\n-Function code - @code{BUILT_IN_CHKP_SET_PTR_BOUNDS}.  This built-in function\\n\\\n-returns @var{ptr} with bounds [@var{ptr}, @var{ptr} + @var{s} - @code{1}].\\n\\\n-@end deftypefn\\n\\\n-\\n\\\n-@deftypefn {Built-in Function} size_t __chkp_sizeof (const void *@var{ptr})\\n\\\n-Function code - @code{BUILT_IN_CHKP_SIZEOF}.  This built-in function\\n\\\n-returns size of object referenced by @var{ptr}. @var{ptr} is always\\n\\\n-@code{ADDR_EXPR} of @code{VAR_DECL}.  This built-in is used by\\n\\\n-Pointer Boudns Checker when bounds of object cannot be computed statically\\n\\\n-(e.g. object has incomplete type).\\n\\\n-@end deftypefn\\n\\\n-\\n\\\n-@deftypefn {Built-in Function} const void *__chkp_extract_lower (bnd @var{b})\\n\\\n-Function code - @code{BUILT_IN_CHKP_EXTRACT_LOWER}.  This built-in function\\n\\\n-returns lower bound of bounds @var{b}.\\n\\\n-@end deftypefn\\n\\\n-\\n\\\n-@deftypefn {Built-in Function} const void *__chkp_extract_upper (bnd @var{b})\\n\\\n-Function code - @code{BUILT_IN_CHKP_EXTRACT_UPPER}.  This built-in function\\n\\\n-returns upper bound of bounds @var{b}.\\n\\\n-@end deftypefn\",\n- tree, (unsigned fcode),\n- default_builtin_chkp_function)\n-\n-DEFHOOK\n-(chkp_bound_type,\n- \"Return type to be used for bounds\",\n- tree, (void),\n- default_chkp_bound_type)\n-\n-DEFHOOK\n-(chkp_bound_mode,\n- \"Return mode to be used for bounds.\",\n- enum machine_mode, (void),\n- default_chkp_bound_mode)\n-\n /* Select a replacement for a target-specific builtin.  This is done\n    *before* regular type checking, and so allows the target to\n    implement a crude form of function overloading.  The result is a\n@@ -3426,15 +3328,6 @@ The default version of this hook returns @code{va_list_type_node}.\",\n  tree, (tree fndecl),\n  std_fn_abi_va_list)\n \n-DEFHOOK\n-(fn_abi_va_list_bounds_size,\n- \"This hook returns size for @code{va_list} object in function specified\\n\\\n-by @var{fndecl}.  This hook is used by Pointer Bounds Checker to build bounds\\n\\\n-for @code{va_list} object.  Return @code{integer_zero_node} if no bounds\\n\\\n-should be used (e.g. @code{va_list} is a scalar pointer to the stack).\",\n- tree, (tree fndecl),\n- default_fn_abi_va_list_bounds_size)\n-\n /* Get the __builtin_va_list type dependent on input type.  */\n DEFHOOK\n (canonical_va_list_type,\n@@ -3882,30 +3775,6 @@ not generate any instructions in this case.\",\n \tint *pretend_args_size, int second_time),\n  default_setup_incoming_varargs)\n \n-DEFHOOK\n-(load_bounds_for_arg,\n- \"This hook is used by expand pass to emit insn to load bounds of\\n\\\n-@var{arg} passed in @var{slot}.  Expand pass uses this hook in case\\n\\\n-bounds of @var{arg} are not passed in register.  If @var{slot} is a\\n\\\n-memory, then bounds are loaded as for regular pointer loaded from\\n\\\n-memory.  If @var{slot} is not a memory then @var{slot_no} is an integer\\n\\\n-constant holding number of the target dependent special slot which\\n\\\n-should be used to obtain bounds.  Hook returns RTX holding loaded bounds.\",\n- rtx, (rtx slot, rtx arg, rtx slot_no),\n- default_load_bounds_for_arg)\n-\n-DEFHOOK\n-(store_bounds_for_arg,\n- \"This hook is used by expand pass to emit insns to store @var{bounds} of\\n\\\n-@var{arg} passed in @var{slot}.  Expand pass uses this hook in case\\n\\\n-@var{bounds} of @var{arg} are not passed in register.  If @var{slot} is a\\n\\\n-memory, then @var{bounds} are stored as for regular pointer stored in\\n\\\n-memory.  If @var{slot} is not a memory then @var{slot_no} is an integer\\n\\\n-constant holding number of the target dependent special slot which\\n\\\n-should be used to store @var{bounds}.\",\n- void, (rtx arg, rtx slot, rtx bounds, rtx slot_no),\n- default_store_bounds_for_arg)\n-\n DEFHOOK\n (strict_argument_naming,\n  \"Define this hook to return @code{true} if the location where a function\\n\\"}, {"sha": "c6a19a94c10912ecf646336e432a9897194d1ef0", "filename": "gcc/targhooks.c", "status": "modified", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -1571,28 +1571,6 @@ default_member_type_forces_blk (const_tree, enum machine_mode)\n {\n   return false;\n }\n-rtx\n-default_load_bounds_for_arg (rtx addr ATTRIBUTE_UNUSED,\n-\t\t\t     rtx ptr ATTRIBUTE_UNUSED,\n-\t\t\t     rtx bnd ATTRIBUTE_UNUSED)\n-{\n-  gcc_unreachable ();\n-}\n-\n-void\n-default_store_bounds_for_arg (rtx val ATTRIBUTE_UNUSED,\n-\t\t\t      rtx addr ATTRIBUTE_UNUSED,\n-\t\t\t      rtx bounds ATTRIBUTE_UNUSED,\n-\t\t\t      rtx to ATTRIBUTE_UNUSED)\n-{\n-  gcc_unreachable ();\n-}\n-\n-tree\n-default_fn_abi_va_list_bounds_size (tree fndecl ATTRIBUTE_UNUSED)\n-{\n-  return integer_zero_node;\n-}\n \n /* Default version of canonicalize_comparison.  */\n \n@@ -1718,27 +1696,6 @@ std_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n   return build_va_arg_indirect_ref (addr);\n }\n \n-tree\n-default_chkp_bound_type (void)\n-{\n-  tree res = make_node (POINTER_BOUNDS_TYPE);\n-  TYPE_PRECISION (res) = TYPE_PRECISION (size_type_node) * 2;\n-  layout_type (res);\n-  return res;\n-}\n-\n-enum machine_mode\n-default_chkp_bound_mode (void)\n-{\n-  return VOIDmode;\n-}\n-\n-tree\n-default_builtin_chkp_function (unsigned int fcode ATTRIBUTE_UNUSED)\n-{\n-  return NULL_TREE;\n-}\n-\n /* An implementation of TARGET_CAN_USE_DOLOOP_P for targets that do\n    not support nested low-overhead loops.  */\n "}, {"sha": "c24db1689a2e7def23cd56c3f921db0c1755626a", "filename": "gcc/targhooks.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -206,12 +206,5 @@ extern bool default_member_type_forces_blk (const_tree, enum machine_mode);\n extern void default_atomic_assign_expand_fenv (tree *, tree *, tree *);\n extern tree build_va_arg_indirect_ref (tree);\n extern tree std_gimplify_va_arg_expr (tree, tree, gimple_seq *, gimple_seq *);\n-\n-extern rtx default_load_bounds_for_arg (rtx, rtx, rtx);\n-extern void default_store_bounds_for_arg (rtx, rtx, rtx, rtx);\n-extern tree default_fn_abi_va_list_bounds_size (tree);\n-extern tree default_chkp_bound_type (void);\n-extern enum machine_mode default_chkp_bound_mode (void);\n-extern tree default_builtin_chkp_function (unsigned int);\n extern bool can_use_doloop_if_innermost (double_int, double_int,\n \t\t\t\t\t unsigned int, bool);"}, {"sha": "91a08ae1d7cc3c9a5964174202efb6c9b29d8deb", "filename": "gcc/toplev.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -1284,12 +1284,6 @@ process_options (void)\n \t   \"and -ftree-loop-linear)\");\n #endif\n \n-  if (flag_check_pointer_bounds)\n-    {\n-      if (targetm.chkp_bound_mode () == VOIDmode)\n-\terror (\"-fcheck-pointers is not supported for this target\");\n-    }\n-\n   /* One region RA really helps to decrease the code size.  */\n   if (flag_ira_region == IRA_REGION_AUTODETECT)\n     flag_ira_region"}, {"sha": "81ecc23267f8ffff3d1b7acca797eb216e9deb7e", "filename": "gcc/tree-core.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -457,8 +457,6 @@ enum tree_index {\n   TI_FILEPTR_TYPE,\n   TI_POINTER_SIZED_TYPE,\n \n-  TI_POINTER_BOUNDS_TYPE,\n-\n   TI_DFLOAT32_TYPE,\n   TI_DFLOAT64_TYPE,\n   TI_DFLOAT128_TYPE,"}, {"sha": "69275d0113e6e7c28f55eba6ba7591c56eb26e23", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -869,7 +869,6 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       break;\n \n     case VOID_TYPE:\n-    case POINTER_BOUNDS_TYPE:\n     case INTEGER_TYPE:\n     case REAL_TYPE:\n     case FIXED_POINT_TYPE:"}, {"sha": "0967b432964e31e680fea9f455d594a6b22269be", "filename": "gcc/tree.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -1156,8 +1156,7 @@ build_int_cst_wide (tree type, unsigned HOST_WIDE_INT low, HOST_WIDE_INT hi)\n \n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n-    case POINTER_BOUNDS_TYPE:\n-      /* Cache NULL pointer and zero bounds.  */\n+      /* Cache NULL pointer.  */\n       if (!hi && !low)\n \t{\n \t  limit = 1;\n@@ -3286,7 +3285,6 @@ type_contains_placeholder_1 (const_tree type)\n   switch (TREE_CODE (type))\n     {\n     case VOID_TYPE:\n-    case POINTER_BOUNDS_TYPE:\n     case COMPLEX_TYPE:\n     case ENUMERAL_TYPE:\n     case BOOLEAN_TYPE:\n@@ -9692,8 +9690,6 @@ build_common_tree_nodes (bool signed_char, bool short_double)\n   void_type_node = make_node (VOID_TYPE);\n   layout_type (void_type_node);\n \n-  pointer_bounds_type_node = targetm.chkp_bound_type ();\n-\n   /* We are not going to have real types in C with less than byte alignment,\n      so we might as well not have any types that claim to have it.  */\n   TYPE_ALIGN (void_type_node) = BITS_PER_UNIT;"}, {"sha": "1a05193efc71998a9cb00150de0e6a7e67b0b388", "filename": "gcc/tree.def", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -232,11 +232,6 @@ DEFTREECODE (QUAL_UNION_TYPE, \"qual_union_type\", tcc_type, 0)\n /* The void type in C */\n DEFTREECODE (VOID_TYPE, \"void_type\", tcc_type, 0)\n \n-/* Type to hold bounds for a pointer.\n-   Has TYPE_PRECISION component to specify number of bits used\n-   by this type.  */\n-DEFTREECODE (POINTER_BOUNDS_TYPE, \"pointer_bounds_type\", tcc_type, 0)\n-\n /* Type of functions.  Special fields:\n    TREE_TYPE\t\t    type of value returned.\n    TYPE_ARG_TYPES      list of types of arguments expected."}, {"sha": "1a420027b8fa98a7fe1bfd73e3cb444778696aab", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -548,21 +548,6 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n /* Nonzero if this type is a complete type.  */\n #define COMPLETE_TYPE_P(NODE) (TYPE_SIZE (NODE) != NULL_TREE)\n \n-/* Nonzero if this type is a pointer bounds type.  */\n-#define POINTER_BOUNDS_TYPE_P(NODE) \\\n-  (TREE_CODE (NODE) == POINTER_BOUNDS_TYPE)\n-\n-/* Nonzero if this node has a pointer bounds type.  */\n-#define POINTER_BOUNDS_P(NODE) \\\n-  (POINTER_BOUNDS_TYPE_P (TREE_TYPE (NODE)))\n-\n-/* Nonzero if this type supposes bounds existence.  */\n-#define BOUNDED_TYPE_P(type) (POINTER_TYPE_P (type))\n-\n-/* Nonzero for objects with bounded type.  */\n-#define BOUNDED_P(node) \\\n-  BOUNDED_TYPE_P (TREE_TYPE (node))\n-\n /* Nonzero if this type is the (possibly qualified) void type.  */\n #define VOID_TYPE_P(NODE) (TREE_CODE (NODE) == VOID_TYPE)\n \n@@ -836,9 +821,6 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n #define CALL_ALLOCA_FOR_VAR_P(NODE) \\\n   (CALL_EXPR_CHECK (NODE)->base.protected_flag)\n \n-/* In a CALL_EXPR, means call was instrumented by Pointer Bounds Checker.  */\n-#define CALL_WITH_BOUNDS_P(NODE) (CALL_EXPR_CHECK (NODE)->base.deprecated_flag)\n-\n /* In a type, nonzero means that all objects of the type are guaranteed by the\n    language or front-end to be properly aligned, so we can indicate that a MEM\n    of this type is aligned at least to the alignment of the type, even if it\n@@ -3245,8 +3227,6 @@ tree_operand_check_code (const_tree __t, enum tree_code __code, int __i,\n #define complex_double_type_node\tglobal_trees[TI_COMPLEX_DOUBLE_TYPE]\n #define complex_long_double_type_node\tglobal_trees[TI_COMPLEX_LONG_DOUBLE_TYPE]\n \n-#define pointer_bounds_type_node        global_trees[TI_POINTER_BOUNDS_TYPE]\n-\n #define void_type_node\t\t\tglobal_trees[TI_VOID_TYPE]\n /* The C type `void *'.  */\n #define ptr_type_node\t\t\tglobal_trees[TI_PTR_TYPE]"}, {"sha": "1440f335c953d40eca8f1bb9821cff804bf69d04", "filename": "gcc/varasm.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -4688,7 +4688,6 @@ output_constant (tree exp, unsigned HOST_WIDE_INT size, unsigned int align)\n     case REFERENCE_TYPE:\n     case OFFSET_TYPE:\n     case FIXED_POINT_TYPE:\n-    case POINTER_BOUNDS_TYPE:\n     case NULLPTR_TYPE:\n       if (! assemble_integer (expand_expr (exp, NULL_RTX, VOIDmode,\n \t\t\t\t\t   EXPAND_INITIALIZER),"}, {"sha": "1e469b3a253e4fc2f3b36eaa79fe66ed7bb94a3d", "filename": "gcc/varpool.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d12274633f9446335b3a181357cbc0b71b96e/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=089d12274633f9446335b3a181357cbc0b71b96e", "patch": "@@ -204,8 +204,6 @@ dump_varpool_node (FILE *f, struct varpool_node *node)\n     fprintf (f, \" initialized\");\n   if (node->output)\n     fprintf (f, \" output\");\n-  if (node->need_bounds_init)\n-    fprintf (f, \" need-bounds-init\");\n   if (TREE_READONLY (node->decl))\n     fprintf (f, \" read-only\");\n   if (ctor_for_folding (node->decl) != error_mark_node)"}]}