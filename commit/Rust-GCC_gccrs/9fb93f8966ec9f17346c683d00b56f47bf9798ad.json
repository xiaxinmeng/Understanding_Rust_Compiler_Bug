{"sha": "9fb93f8966ec9f17346c683d00b56f47bf9798ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWZiOTNmODk2NmVjOWYxNzM0NmM2ODNkMDBiNTZmNDdiZjk3OThhZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-06-29T17:27:23Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-06-29T17:27:23Z"}, "message": "i386.c (ix86_expand_int_vcond): Remove unsignedp argument.\n\n        * config/i386/i386.c (ix86_expand_int_vcond): Remove unsignedp\n        argument.  Simplify canonicalization of condition.  Use unsigned\n        saturating subtraction for QI and HImode unsigned compares.  Use\n        bit arithmetic tricks for SImode unsigned compares.\n        * config/i386/i386-protos.h (ix86_expand_int_vcond): Update decl.\n        * config/i386/sse.md (SSEMODE14): New.\n        (umaxv8hi3): Use us_minus+plus to avoid vcond.\n        (umaxv4si3): New.\n        (smax<SSEMODE14>3): Rename from smaxv16qi3 and macroize.\n        (smin<SSEMODE14>3): Similarly with sminv16qi3.\n        (umin<SSEMODE24>3): Similarly with uminv8hi3.\n\n        * lib/target-supports.exp (check_effective_target_vect_no_max):\n        Remove i386 and x86_64.\n\nFrom-SVN: r101429", "tree": {"sha": "5d2dfa3860bda0dd44b181d005bd603aada4f4fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d2dfa3860bda0dd44b181d005bd603aada4f4fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9fb93f8966ec9f17346c683d00b56f47bf9798ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fb93f8966ec9f17346c683d00b56f47bf9798ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fb93f8966ec9f17346c683d00b56f47bf9798ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fb93f8966ec9f17346c683d00b56f47bf9798ad/comments", "author": null, "committer": null, "parents": [{"sha": "88be5d434d395513b453e304408b653800ce1ddf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88be5d434d395513b453e304408b653800ce1ddf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88be5d434d395513b453e304408b653800ce1ddf"}], "stats": {"total": 285, "additions": 158, "deletions": 127}, "files": [{"sha": "c13d7f8d77a8b36b4cfb4aa8980396f8b33b0ca3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb93f8966ec9f17346c683d00b56f47bf9798ad/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb93f8966ec9f17346c683d00b56f47bf9798ad/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9fb93f8966ec9f17346c683d00b56f47bf9798ad", "patch": "@@ -1,3 +1,17 @@\n+2005-06-29  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/i386/i386.c (ix86_expand_int_vcond): Remove unsignedp\n+\targument.  Simplify canonicalization of condition.  Use unsigned\n+\tsaturating subtraction for QI and HImode unsigned compares.  Use\n+\tbit arithmetic tricks for SImode unsigned compares.\n+\t* config/i386/i386-protos.h (ix86_expand_int_vcond): Update decl.\n+\t* config/i386/sse.md (SSEMODE14): New.\n+\t(umaxv8hi3): Use us_minus+plus to avoid vcond.\n+\t(umaxv4si3): New.\n+\t(smax<SSEMODE14>3): Rename from smaxv16qi3 and macroize.\n+\t(smin<SSEMODE14>3): Similarly with sminv16qi3.\n+\t(umin<SSEMODE24>3): Similarly with uminv8hi3.\n+\n 2005-06-29  Ian Lance Taylor  <ian@airs.com>\n \n \t* dwarf2out.c (expand_builtin_init_dwarf_reg_sizes): Change"}, {"sha": "15c52b090c20f42dfa125114c913c76ae5589da4", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb93f8966ec9f17346c683d00b56f47bf9798ad/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb93f8966ec9f17346c683d00b56f47bf9798ad/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=9fb93f8966ec9f17346c683d00b56f47bf9798ad", "patch": "@@ -149,7 +149,7 @@ extern int ix86_expand_setcc (enum rtx_code, rtx);\n extern int ix86_expand_int_movcc (rtx[]);\n extern int ix86_expand_fp_movcc (rtx[]);\n extern bool ix86_expand_fp_vcond (rtx[]);\n-extern bool ix86_expand_int_vcond (rtx[], bool);\n+extern bool ix86_expand_int_vcond (rtx[]);\n extern int ix86_expand_int_addcc (rtx[]);\n extern void ix86_expand_call (rtx, rtx, rtx, rtx, rtx, int);\n extern void x86_initialize_trampoline (rtx, rtx, rtx);"}, {"sha": "77437046621782883302d5fcced47686d0dbd005", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 75, "deletions": 67, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb93f8966ec9f17346c683d00b56f47bf9798ad/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb93f8966ec9f17346c683d00b56f47bf9798ad/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=9fb93f8966ec9f17346c683d00b56f47bf9798ad", "patch": "@@ -10501,94 +10501,102 @@ ix86_expand_fp_vcond (rtx operands[])\n /* Expand a signed integral vector conditional move.  */\n \n bool\n-ix86_expand_int_vcond (rtx operands[], bool unsignedp)\n+ix86_expand_int_vcond (rtx operands[])\n {\n   enum machine_mode mode = GET_MODE (operands[0]);\n   enum rtx_code code = GET_CODE (operands[3]);\n-  rtx cmp, x;\n+  bool negate = false;\n+  rtx x, cop0, cop1;\n \n-  if (unsignedp)\n-    code = signed_condition (code);\n-  if (code == NE || code == LE || code == GE)\n+  cop0 = operands[4];\n+  cop1 = operands[5];\n+\n+  /* Canonicalize the comparison to EQ, GT, GTU.  */\n+  switch (code)\n     {\n-      /* Inverse of a supported code.  */\n-      x = operands[1];\n-      operands[1] = operands[2];\n-      operands[2] = x;\n+    case EQ:\n+    case GT:\n+    case GTU:\n+      break;\n+\n+    case NE:\n+    case LE:\n+    case LEU:\n       code = reverse_condition (code);\n-    }\n-  if (code == LT)\n-    {\n-      /* Swap of a supported code.  */\n-      x = operands[4];\n-      operands[4] = operands[5];\n-      operands[5] = x;\n+      negate = true;\n+      break;\n+\n+    case GE:\n+    case GEU:\n+      code = reverse_condition (code);\n+      negate = true;\n+      /* FALLTHRU */\n+\n+    case LT:\n+    case LTU:\n       code = swap_condition (code);\n-    }\n-  gcc_assert (code == EQ || code == GT);\n+      x = cop0, cop0 = cop1, cop1 = x;\n+      break;\n \n-  /* Unlike floating-point, we can rely on the optimizers to have already\n-     converted to MIN/MAX expressions, so we don't have to handle that.  */\n+    default:\n+      gcc_unreachable ();\n+    }\n \n-  /* Unsigned GT is not directly supported.  We can zero-extend QI and\n-     HImode elements to the next wider element size, use a signed compare,\n-     then repack.  For three extra instructions, this is definitely a win.  */\n-  if (code == GT && unsignedp)\n+  /* Unsigned parallel compare is not supported by the hardware.  Play some\n+     tricks to turn this into a signed comparison against 0.  */\n+  if (code == GTU)\n     {\n-      rtx o0l, o0h, o1l, o1h, cl, ch, zero;\n-      enum machine_mode wider;\n-      rtx (*unpackl) (rtx, rtx, rtx);\n-      rtx (*unpackh) (rtx, rtx, rtx);\n-      rtx (*pack) (rtx, rtx, rtx);\n-\n       switch (mode)\n \t{\n-\tcase V16QImode:\n-\t  wider = V8HImode;\n-\t  unpackl = gen_sse2_punpcklbw;\n-\t  unpackh = gen_sse2_punpckhbw;\n-\t  pack = gen_sse2_packsswb;\n+\tcase V4SImode:\n+\t  {\n+\t    rtx t1, t2, mask;\n+\n+\t    /* Perform a parallel modulo subtraction.  */\n+\t    t1 = gen_reg_rtx (mode);\n+\t    emit_insn (gen_subv4si3 (t1, cop0, cop1));\n+\n+\t    /* Extract the original sign bit of op0.  */\n+\t    mask = GEN_INT (-0x80000000);\n+\t    mask = gen_rtx_CONST_VECTOR (mode,\n+\t\t\tgen_rtvec (4, mask, mask, mask, mask));\n+\t    mask = force_reg (mode, mask);\n+\t    t2 = gen_reg_rtx (mode);\n+\t    emit_insn (gen_andv4si3 (t2, cop0, mask));\n+\n+\t    /* XOR it back into the result of the subtraction.  This results\n+\t       in the sign bit set iff we saw unsigned underflow.  */\n+\t    x = gen_reg_rtx (mode);\n+\t    emit_insn (gen_xorv4si3 (x, t1, t2));\n+\n+\t    code = GT;\n+\t  }\n \t  break;\n+\n+\tcase V16QImode:\n \tcase V8HImode:\n-\t  wider = V4SImode;\n-\t  unpackl = gen_sse2_punpcklwd;\n-\t  unpackh = gen_sse2_punpckhwd;\n-\t  pack = gen_sse2_packssdw;\n+\t  /* Perform a parallel unsigned saturating subtraction.  */\n+\t  x = gen_reg_rtx (mode);\n+\t  emit_insn (gen_rtx_SET (VOIDmode, x,\n+\t\t\t\t  gen_rtx_US_MINUS (mode, cop0, cop1)));\n+\n+\t  code = EQ;\n+\t  negate = !negate;\n \t  break;\n+\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n \n-      operands[4] = force_reg (mode, operands[4]);\n-      operands[5] = force_reg (mode, operands[5]);\n-\n-      o0l = gen_reg_rtx (wider);\n-      o0h = gen_reg_rtx (wider);\n-      o1l = gen_reg_rtx (wider);\n-      o1h = gen_reg_rtx (wider);\n-      cl = gen_reg_rtx (wider);\n-      ch = gen_reg_rtx (wider);\n-      cmp = gen_reg_rtx (mode);\n-      zero = force_reg (mode, CONST0_RTX (mode));\n-\n-      emit_insn (unpackl (gen_lowpart (mode, o0l), operands[4], zero));\n-      emit_insn (unpackh (gen_lowpart (mode, o0h), operands[4], zero));\n-      emit_insn (unpackl (gen_lowpart (mode, o1l), operands[5], zero));\n-      emit_insn (unpackh (gen_lowpart (mode, o1h), operands[5], zero));\n-\n-      x = gen_rtx_GT (wider, o0l, o1l);\n-      emit_insn (gen_rtx_SET (VOIDmode, cl, x));\n-\n-      x = gen_rtx_GT (wider, o0h, o1h);\n-      emit_insn (gen_rtx_SET (VOIDmode, ch, x));\n-\n-      emit_insn (pack (cmp, cl, ch));\n+      cop0 = x;\n+      cop1 = CONST0_RTX (mode);\n     }\n-  else\n-    cmp = ix86_expand_sse_cmp (operands[0], code, operands[4], operands[5],\n-\t\t\t       operands[1], operands[2]);\n \n-  ix86_expand_sse_movcc (operands[0], cmp, operands[1], operands[2]);\n+  x = ix86_expand_sse_cmp (operands[0], code, cop0, cop1,\n+\t\t\t   operands[1+negate], operands[2-negate]);\n+\n+  ix86_expand_sse_movcc (operands[0], x, operands[1+negate],\n+\t\t\t operands[2-negate]);\n   return true;\n }\n "}, {"sha": "bb9f98e9eba937d9552f94cd780b34a14fd78095", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 62, "deletions": 56, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb93f8966ec9f17346c683d00b56f47bf9798ad/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb93f8966ec9f17346c683d00b56f47bf9798ad/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=9fb93f8966ec9f17346c683d00b56f47bf9798ad", "patch": "@@ -30,6 +30,7 @@\n ;; Mix-n-match\n (define_mode_macro SSEMODE12 [V16QI V8HI])\n (define_mode_macro SSEMODE24 [V8HI V4SI])\n+(define_mode_macro SSEMODE14 [V16QI V4SI])\n (define_mode_macro SSEMODE124 [V16QI V8HI V4SI])\n (define_mode_macro SSEMODE248 [V8HI V4SI V2DI])\n \n@@ -2741,26 +2742,6 @@\n   operands[1] = gen_lowpart (TImode, operands[1]);\n })\n \n-(define_expand \"smaxv16qi3\"\n-  [(set (match_operand:V16QI 0 \"register_operand\" \"\")\n-\t(smax:V16QI (match_operand:V16QI 1 \"register_operand\" \"\")\n-\t\t    (match_operand:V16QI 2 \"register_operand\" \"\")))]\n-  \"TARGET_SSE2\"\n-{\n-  rtx xops[6];\n-  bool ok;\n-\n-  xops[0] = operands[0];\n-  xops[1] = operands[1];\n-  xops[2] = operands[2];\n-  xops[3] = gen_rtx_GT (VOIDmode, operands[1], operands[2]);\n-  xops[4] = operands[1];\n-  xops[5] = operands[2];\n-  ok = ix86_expand_int_vcond (xops, false);\n-  gcc_assert (ok);\n-  DONE;\n-})\n-\n (define_expand \"umaxv16qi3\"\n   [(set (match_operand:V16QI 0 \"register_operand\" \"\")\n \t(umax:V16QI (match_operand:V16QI 1 \"nonimmediate_operand\" \"\")\n@@ -2794,33 +2775,42 @@\n    (set_attr \"mode\" \"TI\")])\n \n (define_expand \"umaxv8hi3\"\n-  [(set (match_operand:V8HI 0 \"register_operand\" \"\")\n-\t(umax:V8HI (match_operand:V8HI 1 \"register_operand\" \"\")\n-\t\t   (match_operand:V8HI 2 \"register_operand\" \"\")))]\n+  [(set (match_operand:V8HI 0 \"register_operand\" \"=x\")\n+\t(us_minus:V8HI (match_operand:V8HI 1 \"register_operand\" \"0\")\n+\t\t       (match_operand:V8HI 2 \"nonimmediate_operand\" \"xm\")))\n+   (set (match_dup 3)\n+\t(plus:V8HI (match_dup 0) (match_dup 2)))]\n   \"TARGET_SSE2\"\n {\n-  rtx xops[6], t1, t2;\n-  bool ok;\n+  operands[3] = operands[0];\n+  if (rtx_equal_p (operands[0], operands[2]))\n+    operands[0] = gen_reg_rtx (V8HImode);\n+})\n \n-  t1 = gen_reg_rtx (V8HImode);\n-  emit_insn (gen_sse2_ussubv8hi3 (t1, operands[2], operands[1]));\n-  t2 = force_reg (V8HImode, CONST0_RTX (V8HImode));\n+(define_expand \"smax<mode>3\"\n+  [(set (match_operand:SSEMODE14 0 \"register_operand\" \"\")\n+\t(smax:SSEMODE14 (match_operand:SSEMODE14 1 \"register_operand\" \"\")\n+\t\t\t(match_operand:SSEMODE14 2 \"register_operand\" \"\")))]\n+  \"TARGET_SSE2\"\n+{\n+  rtx xops[6];\n+  bool ok;\n \n   xops[0] = operands[0];\n   xops[1] = operands[1];\n   xops[2] = operands[2];\n-  xops[3] = gen_rtx_EQ (VOIDmode, t1, t2);\n-  xops[4] = t1;\n-  xops[5] = t2;\n-  ok = ix86_expand_int_vcond (xops, false);\n+  xops[3] = gen_rtx_GT (VOIDmode, operands[1], operands[2]);\n+  xops[4] = operands[1];\n+  xops[5] = operands[2];\n+  ok = ix86_expand_int_vcond (xops);\n   gcc_assert (ok);\n   DONE;\n })\n \n-(define_expand \"sminv16qi3\"\n-  [(set (match_operand:V16QI 0 \"register_operand\" \"\")\n-\t(smin:V16QI (match_operand:V16QI 1 \"register_operand\" \"\")\n-\t\t    (match_operand:V16QI 2 \"register_operand\" \"\")))]\n+(define_expand \"umaxv4si3\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"\")\n+\t(umax:V4SI (match_operand:V4SI 1 \"register_operand\" \"\")\n+\t\t   (match_operand:V4SI 2 \"register_operand\" \"\")))]\n   \"TARGET_SSE2\"\n {\n   rtx xops[6];\n@@ -2829,10 +2819,10 @@\n   xops[0] = operands[0];\n   xops[1] = operands[1];\n   xops[2] = operands[2];\n-  xops[3] = gen_rtx_GT (VOIDmode, operands[1], operands[2]);\n-  xops[4] = operands[2];\n-  xops[5] = operands[1];\n-  ok = ix86_expand_int_vcond (xops, false);\n+  xops[3] = gen_rtx_GTU (VOIDmode, operands[1], operands[2]);\n+  xops[4] = operands[1];\n+  xops[5] = operands[2];\n+  ok = ix86_expand_int_vcond (xops);\n   gcc_assert (ok);\n   DONE;\n })\n@@ -2869,26 +2859,42 @@\n   [(set_attr \"type\" \"sseiadd\")\n    (set_attr \"mode\" \"TI\")])\n \n-(define_expand \"uminv8hi3\"\n-  [(set (match_operand:V8HI 0 \"register_operand\" \"\")\n-\t(umin:V8HI (match_operand:V8HI 1 \"register_operand\" \"\")\n-\t\t   (match_operand:V8HI 2 \"register_operand\" \"\")))]\n+(define_expand \"smin<mode>3\"\n+  [(set (match_operand:SSEMODE14 0 \"register_operand\" \"\")\n+\t(smin:SSEMODE14 (match_operand:SSEMODE14 1 \"register_operand\" \"\")\n+\t\t\t(match_operand:SSEMODE14 2 \"register_operand\" \"\")))]\n   \"TARGET_SSE2\"\n {\n-  rtx xops[6], t1, t2;\n+  rtx xops[6];\n   bool ok;\n \n-  t1 = gen_reg_rtx (V8HImode);\n-  emit_insn (gen_sse2_ussubv8hi3 (t1, operands[1], operands[2]));\n-  t2 = force_reg (V8HImode, CONST0_RTX (V8HImode));\n+  xops[0] = operands[0];\n+  xops[1] = operands[2];\n+  xops[2] = operands[1];\n+  xops[3] = gen_rtx_GT (VOIDmode, operands[1], operands[2]);\n+  xops[4] = operands[1];\n+  xops[5] = operands[2];\n+  ok = ix86_expand_int_vcond (xops);\n+  gcc_assert (ok);\n+  DONE;\n+})\n+\n+(define_expand \"umin<mode>3\"\n+  [(set (match_operand:SSEMODE24 0 \"register_operand\" \"\")\n+\t(umin:SSEMODE24 (match_operand:SSEMODE24 1 \"register_operand\" \"\")\n+\t\t\t(match_operand:SSEMODE24 2 \"register_operand\" \"\")))]\n+  \"TARGET_SSE2\"\n+{\n+  rtx xops[6];\n+  bool ok;\n \n   xops[0] = operands[0];\n-  xops[1] = operands[1];\n-  xops[2] = operands[2];\n-  xops[3] = gen_rtx_EQ (VOIDmode, t1, t2);\n-  xops[4] = t1;\n-  xops[5] = t2;\n-  ok = ix86_expand_int_vcond (xops, false);\n+  xops[1] = operands[2];\n+  xops[2] = operands[1];\n+  xops[3] = gen_rtx_GTU (VOIDmode, operands[1], operands[2]);\n+  xops[4] = operands[1];\n+  xops[5] = operands[2];\n+  ok = ix86_expand_int_vcond (xops);\n   gcc_assert (ok);\n   DONE;\n })\n@@ -2929,7 +2935,7 @@\n           (match_operand:SSEMODE124 2 \"general_operand\" \"\")))]\n   \"TARGET_SSE2\"\n {\n-  if (ix86_expand_int_vcond (operands, false))\n+  if (ix86_expand_int_vcond (operands))\n     DONE;\n   else\n     FAIL;\n@@ -2945,7 +2951,7 @@\n           (match_operand:SSEMODE12 2 \"general_operand\" \"\")))]\n   \"TARGET_SSE2\"\n {\n-  if (ix86_expand_int_vcond (operands, true))\n+  if (ix86_expand_int_vcond (operands))\n     DONE;\n   else\n     FAIL;"}, {"sha": "10b2817eeb770df9c8efc12288dc3152ed49848e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb93f8966ec9f17346c683d00b56f47bf9798ad/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb93f8966ec9f17346c683d00b56f47bf9798ad/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9fb93f8966ec9f17346c683d00b56f47bf9798ad", "patch": "@@ -1,3 +1,8 @@\n+2005-05-29  Richard Henderson  <rth@redhat.com>\n+\n+\t* lib/target-supports.exp (check_effective_target_vect_no_max): \n+\tRemove i386 and x86_64.\n+\n 2005-06-29  Steve Ellcey  <sje@cup.hp.com>\n \n \tPR testsuite/21969"}, {"sha": "d00850ad3f031eb19e1add922161f29241cd083f", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb93f8966ec9f17346c683d00b56f47bf9798ad/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb93f8966ec9f17346c683d00b56f47bf9798ad/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=9fb93f8966ec9f17346c683d00b56f47bf9798ad", "patch": "@@ -973,9 +973,7 @@ proc check_effective_target_vect_no_max { } {\n \tverbose \"check_effective_target_vect_no_max: using cached result\" 2\n     } else {\n \tset et_vect_no_max_saved 0\n-\tif { [istarget i?86-*-*]\n-\t     || [istarget x86_64-*-*]\n-\t     || [istarget sparc*-*-*]\n+\tif { [istarget sparc*-*-*]\n \t     || [istarget alpha*-*-*] } {\n \t    set et_vect_no_max_saved 1\n \t}"}]}