{"sha": "10c8507372f3e1c09df0bfe6449c126dee5075de", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBjODUwNzM3MmYzZTFjMDlkZjBiZmU2NDQ5YzEyNmRlZTUwNzVkZQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-08-07T22:17:35Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-08-08T00:22:33Z"}, "message": "libgo: update to Go1.15rc2 release\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/247517", "tree": {"sha": "27c7db25f91db33c83f56cc75621e61fbf21d921", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/27c7db25f91db33c83f56cc75621e61fbf21d921"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10c8507372f3e1c09df0bfe6449c126dee5075de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10c8507372f3e1c09df0bfe6449c126dee5075de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10c8507372f3e1c09df0bfe6449c126dee5075de", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10c8507372f3e1c09df0bfe6449c126dee5075de/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a72e938d710fa4b6c8eb89c4daab68e320fa97df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a72e938d710fa4b6c8eb89c4daab68e320fa97df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a72e938d710fa4b6c8eb89c4daab68e320fa97df"}], "stats": {"total": 533, "additions": 336, "deletions": 197}, "files": [{"sha": "b6089f3f01d2b692ec0cd3c243b113fe0ca77add", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c8507372f3e1c09df0bfe6449c126dee5075de/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c8507372f3e1c09df0bfe6449c126dee5075de/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=10c8507372f3e1c09df0bfe6449c126dee5075de", "patch": "@@ -1,4 +1,4 @@\n-f45afedf90ac9af8f03d7d4515e952cbd724953a\n+307665073fce992ea8112f74b91954e770afcc70\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "a84f1e38f9d4adf5acc4dbdeeacc50426c444cd9", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=10c8507372f3e1c09df0bfe6449c126dee5075de", "patch": "@@ -1,4 +1,4 @@\n-3e8f6b0791a670e52d25d76813d669daa68acfb4\n+c4f8cb43caf0bcd0c730d7d04a3fce129393cecc\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "2d962d8cd2716330bf58d3a04b64481dfd9d28f1", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=10c8507372f3e1c09df0bfe6449c126dee5075de", "patch": "@@ -1 +1 @@\n-go1.15rc1\n+go1.15rc2"}, {"sha": "1d23fc1d255a2222473701482f97539953ffd091", "filename": "libgo/go/cmd/cgo/out.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go?ref=10c8507372f3e1c09df0bfe6449c126dee5075de", "patch": "@@ -128,7 +128,9 @@ func (p *Package) writeDefs() {\n \t\t// Moreover, empty file name makes compile emit no source debug info at all.\n \t\tvar buf bytes.Buffer\n \t\tnoSourceConf.Fprint(&buf, fset, def.Go)\n-\t\tif bytes.HasPrefix(buf.Bytes(), []byte(\"_Ctype_\")) {\n+\t\tif bytes.HasPrefix(buf.Bytes(), []byte(\"_Ctype_\")) ||\n+\t\t\tstrings.HasPrefix(name, \"_Ctype_enum_\") ||\n+\t\t\tstrings.HasPrefix(name, \"_Ctype_union_\") {\n \t\t\t// This typedef is of the form `typedef a b` and should be an alias.\n \t\t\tfmt.Fprintf(fgo2, \"= \")\n \t\t}"}, {"sha": "28220ce6107f8bdf3764ab03b913b8b632367d45", "filename": "libgo/go/cmd/go/internal/load/pkg.go", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go?ref=10c8507372f3e1c09df0bfe6449c126dee5075de", "patch": "@@ -239,11 +239,25 @@ func (p *Package) setLoadPackageDataError(err error, path string, stk *ImportSta\n \t\terr = &NoGoError{Package: p}\n \t}\n \n+\t// Take only the first error from a scanner.ErrorList. PackageError only\n+\t// has room for one position, so we report the first error with a position\n+\t// instead of all of the errors without a position.\n+\tvar pos string\n+\tvar isScanErr bool\n+\tif scanErr, ok := err.(scanner.ErrorList); ok && len(scanErr) > 0 {\n+\t\tisScanErr = true // For stack push/pop below.\n+\n+\t\tscanPos := scanErr[0].Pos\n+\t\tscanPos.Filename = base.ShortPath(scanPos.Filename)\n+\t\tpos = scanPos.String()\n+\t\terr = errors.New(scanErr[0].Msg)\n+\t}\n+\n \t// Report the error on the importing package if the problem is with the import declaration\n \t// for example, if the package doesn't exist or if the import path is malformed.\n \t// On the other hand, don't include a position if the problem is with the imported package,\n \t// for example there are no Go files (NoGoError), or there's a problem in the imported\n-\t// package's source files themselves.\n+\t// package's source files themselves (scanner errors).\n \t//\n \t// TODO(matloob): Perhaps make each of those the errors in the first group\n \t// (including modload.ImportMissingError, and the corresponding\n@@ -254,22 +268,11 @@ func (p *Package) setLoadPackageDataError(err error, path string, stk *ImportSta\n \t// to make it easier to check for them? That would save us from having to\n \t// move the modload errors into this package to avoid a package import cycle,\n \t// and from having to export an error type for the errors produced in build.\n-\tif !isMatchErr && nogoErr != nil {\n+\tif !isMatchErr && (nogoErr != nil || isScanErr) {\n \t\tstk.Push(path)\n \t\tdefer stk.Pop()\n \t}\n \n-\t// Take only the first error from a scanner.ErrorList. PackageError only\n-\t// has room for one position, so we report the first error with a position\n-\t// instead of all of the errors without a position.\n-\tvar pos string\n-\tif scanErr, ok := err.(scanner.ErrorList); ok && len(scanErr) > 0 {\n-\t\tscanPos := scanErr[0].Pos\n-\t\tscanPos.Filename = base.ShortPath(scanPos.Filename)\n-\t\tpos = scanPos.String()\n-\t\terr = errors.New(scanErr[0].Msg)\n-\t}\n-\n \tp.Error = &PackageError{\n \t\tImportStack: stk.Copy(),\n \t\tPos:         pos,"}, {"sha": "6f59bb5cffbe9d2632cb96549cfe7903789a10fb", "filename": "libgo/go/crypto/ed25519/ed25519.go", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2Fgo%2Fcrypto%2Fed25519%2Fed25519.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2Fgo%2Fcrypto%2Fed25519%2Fed25519.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fed25519%2Fed25519.go?ref=10c8507372f3e1c09df0bfe6449c126dee5075de", "patch": "@@ -154,7 +154,7 @@ func Sign(privateKey PrivateKey, message []byte) []byte {\n \treturn signature\n }\n \n-func signGeneric(signature, privateKey, message []byte) {\n+func sign(signature, privateKey, message []byte) {\n \tif l := len(privateKey); l != PrivateKeySize {\n \t\tpanic(\"ed25519: bad private key length: \" + strconv.Itoa(l))\n \t}\n@@ -201,10 +201,6 @@ func signGeneric(signature, privateKey, message []byte) {\n // Verify reports whether sig is a valid signature of message by publicKey. It\n // will panic if len(publicKey) is not PublicKeySize.\n func Verify(publicKey PublicKey, message, sig []byte) bool {\n-\treturn verify(publicKey, message, sig)\n-}\n-\n-func verifyGeneric(publicKey PublicKey, message, sig []byte) bool {\n \tif l := len(publicKey); l != PublicKeySize {\n \t\tpanic(\"ed25519: bad public key length: \" + strconv.Itoa(l))\n \t}"}, {"sha": "4425bb2766d1d339267a2e95add6d7ae973b63ca", "filename": "libgo/go/crypto/ed25519/ed25519_noasm.go", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a72e938d710fa4b6c8eb89c4daab68e320fa97df/libgo%2Fgo%2Fcrypto%2Fed25519%2Fed25519_noasm.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a72e938d710fa4b6c8eb89c4daab68e320fa97df/libgo%2Fgo%2Fcrypto%2Fed25519%2Fed25519_noasm.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fed25519%2Fed25519_noasm.go?ref=a72e938d710fa4b6c8eb89c4daab68e320fa97df", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2020 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// -build !s390x\n-\n-package ed25519\n-\n-func sign(signature, privateKey, message []byte) {\n-\tsignGeneric(signature, privateKey, message)\n-}\n-\n-func verify(publicKey PublicKey, message, sig []byte) bool {\n-\treturn verifyGeneric(publicKey, message, sig)\n-}"}, {"sha": "d7e5243884eca175de03b92b9783defe19cd66e0", "filename": "libgo/go/crypto/ed25519/ed25519_s390x.go", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a72e938d710fa4b6c8eb89c4daab68e320fa97df/libgo%2Fgo%2Fcrypto%2Fed25519%2Fed25519_s390x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a72e938d710fa4b6c8eb89c4daab68e320fa97df/libgo%2Fgo%2Fcrypto%2Fed25519%2Fed25519_s390x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fed25519%2Fed25519_s390x.go?ref=a72e938d710fa4b6c8eb89c4daab68e320fa97df", "patch": "@@ -1,53 +0,0 @@\n-// Copyright 2020 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build ignore_for_gccgo\n-\n-package ed25519\n-\n-import (\n-\t\"internal/cpu\"\n-\t\"strconv\"\n-)\n-\n-//go:noescape\n-func kdsaSign(message, signature, privateKey []byte) bool\n-\n-//go:noescape\n-func kdsaVerify(message, signature, publicKey []byte) bool\n-\n-// sign does a check to see if hardware has Edwards Curve instruction available.\n-// If it does, use the hardware implementation. Otherwise, use the generic version.\n-func sign(signature, privateKey, message []byte) {\n-\tif cpu.S390X.HasEDDSA {\n-\t\tif l := len(privateKey); l != PrivateKeySize {\n-\t\t\tpanic(\"ed25519: bad private key length: \" + strconv.Itoa(l))\n-\t\t}\n-\n-\t\tret := kdsaSign(message, signature, privateKey[:32])\n-\t\tif !ret {\n-\t\t\tpanic(\"ed25519: kdsa sign has a failure\")\n-\t\t}\n-\t\treturn\n-\t}\n-\tsignGeneric(signature, privateKey, message)\n-}\n-\n-// verify does a check to see if hardware has Edwards Curve instruction available.\n-// If it does, use the hardware implementation for eddsa verfication. Otherwise, the generic\n-// version is used\n-func verify(publicKey PublicKey, message, sig []byte) bool {\n-\tif cpu.S390X.HasEDDSA {\n-\t\tif l := len(publicKey); l != PublicKeySize {\n-\t\t\tpanic(\"ed25519: bad public key length: \" + strconv.Itoa(l))\n-\t\t}\n-\n-\t\tif len(sig) != SignatureSize || sig[63]&224 != 0 {\n-\t\t\treturn false\n-\t\t}\n-\n-\t\treturn kdsaVerify(message, sig, publicKey)\n-\t}\n-\treturn verifyGeneric(publicKey, message, sig)\n-}"}, {"sha": "adb09e409a502c58a4f7910c4308a18708e5f9cc", "filename": "libgo/go/crypto/ed25519/ed25519_test.go", "status": "modified", "additions": 7, "deletions": 37, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2Fgo%2Fcrypto%2Fed25519%2Fed25519_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2Fgo%2Fcrypto%2Fed25519%2Fed25519_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fed25519%2Fed25519_test.go?ref=10c8507372f3e1c09df0bfe6449c126dee5075de", "patch": "@@ -26,14 +26,6 @@ func (zeroReader) Read(buf []byte) (int, error) {\n \treturn len(buf), nil\n }\n \n-// signGenericWrapper is identical to Sign except that it unconditionally calls signGeneric directly\n-// rather than going through the sign function that might call assembly code.\n-func signGenericWrapper(privateKey PrivateKey, msg []byte) []byte {\n-\tsig := make([]byte, SignatureSize)\n-\tsignGeneric(sig, privateKey, msg)\n-\treturn sig\n-}\n-\n func TestUnmarshalMarshal(t *testing.T) {\n \tpub, _, _ := GenerateKey(rand.Reader)\n \n@@ -53,33 +45,22 @@ func TestUnmarshalMarshal(t *testing.T) {\n }\n \n func TestSignVerify(t *testing.T) {\n-\tt.Run(\"Generic\", func(t *testing.T) { testSignVerify(t, signGenericWrapper, verifyGeneric) })\n-\tt.Run(\"Native\", func(t *testing.T) { testSignVerify(t, Sign, Verify) })\n-}\n-\n-func testSignVerify(t *testing.T, signImpl func(privateKey PrivateKey, message []byte) []byte,\n-\tverifyImpl func(publicKey PublicKey, message, sig []byte) bool) {\n \tvar zero zeroReader\n \tpublic, private, _ := GenerateKey(zero)\n \n \tmessage := []byte(\"test message\")\n-\tsig := signImpl(private, message)\n-\tif !verifyImpl(public, message, sig) {\n+\tsig := Sign(private, message)\n+\tif !Verify(public, message, sig) {\n \t\tt.Errorf(\"valid signature rejected\")\n \t}\n \n \twrongMessage := []byte(\"wrong message\")\n-\tif verifyImpl(public, wrongMessage, sig) {\n+\tif Verify(public, wrongMessage, sig) {\n \t\tt.Errorf(\"signature of different message accepted\")\n \t}\n }\n \n func TestCryptoSigner(t *testing.T) {\n-\tt.Run(\"Generic\", func(t *testing.T) { testCryptoSigner(t, verifyGeneric) })\n-\tt.Run(\"Native\", func(t *testing.T) { testCryptoSigner(t, Verify) })\n-}\n-\n-func testCryptoSigner(t *testing.T, verifyImpl func(publicKey PublicKey, message, sig []byte) bool) {\n \tvar zero zeroReader\n \tpublic, private, _ := GenerateKey(zero)\n \n@@ -102,7 +83,7 @@ func testCryptoSigner(t *testing.T, verifyImpl func(publicKey PublicKey, message\n \t\tt.Fatalf(\"error from Sign(): %s\", err)\n \t}\n \n-\tif !verifyImpl(public, message, signature) {\n+\tif !Verify(public, message, signature) {\n \t\tt.Errorf(\"Verify failed on signature from Sign()\")\n \t}\n }\n@@ -130,12 +111,6 @@ func TestEqual(t *testing.T) {\n }\n \n func TestGolden(t *testing.T) {\n-\tt.Run(\"Generic\", func(t *testing.T) { testGolden(t, signGenericWrapper, verifyGeneric) })\n-\tt.Run(\"Native\", func(t *testing.T) { testGolden(t, Sign, Verify) })\n-}\n-\n-func testGolden(t *testing.T, signImpl func(privateKey PrivateKey, message []byte) []byte,\n-\tverifyImpl func(publicKey PublicKey, message, sig []byte) bool) {\n \t// sign.input.gz is a selection of test cases from\n \t// https://ed25519.cr.yp.to/python/sign.input\n \ttestDataZ, err := os.Open(\"testdata/sign.input.gz\")\n@@ -177,12 +152,12 @@ func testGolden(t *testing.T, signImpl func(privateKey PrivateKey, message []byt\n \t\tcopy(priv[:], privBytes)\n \t\tcopy(priv[32:], pubKey)\n \n-\t\tsig2 := signImpl(priv[:], msg)\n+\t\tsig2 := Sign(priv[:], msg)\n \t\tif !bytes.Equal(sig, sig2[:]) {\n \t\t\tt.Errorf(\"different signature result on line %d: %x vs %x\", lineNo, sig, sig2)\n \t\t}\n \n-\t\tif !verifyImpl(pubKey, msg, sig2) {\n+\t\tif !Verify(pubKey, msg, sig2) {\n \t\t\tt.Errorf(\"signature failed to verify on line %d\", lineNo)\n \t\t}\n \n@@ -206,11 +181,6 @@ func testGolden(t *testing.T, signImpl func(privateKey PrivateKey, message []byt\n }\n \n func TestMalleability(t *testing.T) {\n-\tt.Run(\"Generic\", func(t *testing.T) { testMalleability(t, verifyGeneric) })\n-\tt.Run(\"Native\", func(t *testing.T) { testMalleability(t, Verify) })\n-}\n-\n-func testMalleability(t *testing.T, verifyImpl func(publicKey PublicKey, message, sig []byte) bool) {\n \t// https://tools.ietf.org/html/rfc8032#section-5.1.7 adds an additional test\n \t// that s be in [0, order). This prevents someone from adding a multiple of\n \t// order to s and obtaining a second valid signature for the same message.\n@@ -229,7 +199,7 @@ func testMalleability(t *testing.T, verifyImpl func(publicKey PublicKey, message\n \t\t0xb1, 0x08, 0xc3, 0xbd, 0xae, 0x36, 0x9e, 0xf5, 0x49, 0xfa,\n \t}\n \n-\tif verifyImpl(publicKey, msg, sig) {\n+\tif Verify(publicKey, msg, sig) {\n \t\tt.Fatal(\"non-canonical signature accepted\")\n \t}\n }"}, {"sha": "38af61075c860ef6b97b883bc6be2508a1c914f1", "filename": "libgo/go/encoding/binary/varint.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint.go?ref=10c8507372f3e1c09df0bfe6449c126dee5075de", "patch": "@@ -106,20 +106,21 @@ var overflow = errors.New(\"binary: varint overflows a 64-bit integer\")\n func ReadUvarint(r io.ByteReader) (uint64, error) {\n \tvar x uint64\n \tvar s uint\n-\tfor i := 0; ; i++ {\n+\tfor i := 0; i < MaxVarintLen64; i++ {\n \t\tb, err := r.ReadByte()\n \t\tif err != nil {\n \t\t\treturn x, err\n \t\t}\n \t\tif b < 0x80 {\n-\t\t\tif i > 9 || i == 9 && b > 1 {\n+\t\t\tif i == 9 && b > 1 {\n \t\t\t\treturn x, overflow\n \t\t\t}\n \t\t\treturn x | uint64(b)<<s, nil\n \t\t}\n \t\tx |= uint64(b&0x7f) << s\n \t\ts += 7\n \t}\n+\treturn x, overflow\n }\n \n // ReadVarint reads an encoded signed integer from r and returns it as an int64."}, {"sha": "6ef4c9950525a45c56eb7a11c5bb2ca443693b09", "filename": "libgo/go/encoding/binary/varint_test.go", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint_test.go?ref=10c8507372f3e1c09df0bfe6449c126dee5075de", "patch": "@@ -121,21 +121,27 @@ func TestBufferTooSmall(t *testing.T) {\n \t}\n }\n \n-func testOverflow(t *testing.T, buf []byte, n0 int, err0 error) {\n+func testOverflow(t *testing.T, buf []byte, x0 uint64, n0 int, err0 error) {\n \tx, n := Uvarint(buf)\n \tif x != 0 || n != n0 {\n \t\tt.Errorf(\"Uvarint(%v): got x = %d, n = %d; want 0, %d\", buf, x, n, n0)\n \t}\n \n-\tx, err := ReadUvarint(bytes.NewReader(buf))\n-\tif x != 0 || err != err0 {\n-\t\tt.Errorf(\"ReadUvarint(%v): got x = %d, err = %s; want 0, %s\", buf, x, err, err0)\n+\tr := bytes.NewReader(buf)\n+\tlen := r.Len()\n+\tx, err := ReadUvarint(r)\n+\tif x != x0 || err != err0 {\n+\t\tt.Errorf(\"ReadUvarint(%v): got x = %d, err = %s; want %d, %s\", buf, x, err, x0, err0)\n+\t}\n+\tif read := len - r.Len(); read > MaxVarintLen64 {\n+\t\tt.Errorf(\"ReadUvarint(%v): read more than MaxVarintLen64 bytes, got %d\", buf, read)\n \t}\n }\n \n func TestOverflow(t *testing.T) {\n-\ttestOverflow(t, []byte{0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x2}, -10, overflow)\n-\ttestOverflow(t, []byte{0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x1, 0, 0}, -13, overflow)\n+\ttestOverflow(t, []byte{0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x2}, 0, -10, overflow)\n+\ttestOverflow(t, []byte{0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x1, 0, 0}, 0, -13, overflow)\n+\ttestOverflow(t, []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, 1<<64-1, 0, overflow) // 11 bytes, should overflow\n }\n \n func TestNonCanonicalZero(t *testing.T) {"}, {"sha": "d37b52b13d06006619d341692680bf13cc1a4d52", "filename": "libgo/go/net/http/transport.go", "status": "modified", "additions": 42, "deletions": 31, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go?ref=10c8507372f3e1c09df0bfe6449c126dee5075de", "patch": "@@ -100,7 +100,7 @@ type Transport struct {\n \tidleLRU      connLRU\n \n \treqMu       sync.Mutex\n-\treqCanceler map[*Request]func(error)\n+\treqCanceler map[cancelKey]func(error)\n \n \taltMu    sync.Mutex   // guards changing altProto only\n \taltProto atomic.Value // of nil or map[string]RoundTripper, key is URI scheme\n@@ -273,6 +273,13 @@ type Transport struct {\n \tForceAttemptHTTP2 bool\n }\n \n+// A cancelKey is the key of the reqCanceler map.\n+// We wrap the *Request in this type since we want to use the original request,\n+// not any transient one created by roundTrip.\n+type cancelKey struct {\n+\treq *Request\n+}\n+\n func (t *Transport) writeBufferSize() int {\n \tif t.WriteBufferSize > 0 {\n \t\treturn t.WriteBufferSize\n@@ -433,9 +440,10 @@ func ProxyURL(fixedURL *url.URL) func(*Request) (*url.URL, error) {\n // optional extra headers to write and stores any error to return\n // from roundTrip.\n type transportRequest struct {\n-\t*Request                        // original request, not to be mutated\n-\textra    Header                 // extra headers to write, or nil\n-\ttrace    *httptrace.ClientTrace // optional\n+\t*Request                         // original request, not to be mutated\n+\textra     Header                 // extra headers to write, or nil\n+\ttrace     *httptrace.ClientTrace // optional\n+\tcancelKey cancelKey\n \n \tmu  sync.Mutex // guards err\n \terr error      // first setError value for mapRoundTripError to consider\n@@ -512,6 +520,7 @@ func (t *Transport) roundTrip(req *Request) (*Response, error) {\n \t}\n \n \torigReq := req\n+\tcancelKey := cancelKey{origReq}\n \treq = setupRewindBody(req)\n \n \tif altRT := t.alternateRoundTripper(req); altRT != nil {\n@@ -546,7 +555,7 @@ func (t *Transport) roundTrip(req *Request) (*Response, error) {\n \t\t}\n \n \t\t// treq gets modified by roundTrip, so we need to recreate for each retry.\n-\t\ttreq := &transportRequest{Request: req, trace: trace}\n+\t\ttreq := &transportRequest{Request: req, trace: trace, cancelKey: cancelKey}\n \t\tcm, err := t.connectMethodForRequest(treq)\n \t\tif err != nil {\n \t\t\treq.closeBody()\n@@ -559,15 +568,15 @@ func (t *Transport) roundTrip(req *Request) (*Response, error) {\n \t\t// to send it requests.\n \t\tpconn, err := t.getConn(treq, cm)\n \t\tif err != nil {\n-\t\t\tt.setReqCanceler(req, nil)\n+\t\t\tt.setReqCanceler(cancelKey, nil)\n \t\t\treq.closeBody()\n \t\t\treturn nil, err\n \t\t}\n \n \t\tvar resp *Response\n \t\tif pconn.alt != nil {\n \t\t\t// HTTP/2 path.\n-\t\t\tt.setReqCanceler(req, nil) // not cancelable with CancelRequest\n+\t\t\tt.setReqCanceler(cancelKey, nil) // not cancelable with CancelRequest\n \t\t\tresp, err = pconn.alt.RoundTrip(req)\n \t\t} else {\n \t\t\tresp, err = pconn.roundTrip(treq)\n@@ -753,14 +762,14 @@ func (t *Transport) CloseIdleConnections() {\n // cancelable context instead. CancelRequest cannot cancel HTTP/2\n // requests.\n func (t *Transport) CancelRequest(req *Request) {\n-\tt.cancelRequest(req, errRequestCanceled)\n+\tt.cancelRequest(cancelKey{req}, errRequestCanceled)\n }\n \n // Cancel an in-flight request, recording the error value.\n-func (t *Transport) cancelRequest(req *Request, err error) {\n+func (t *Transport) cancelRequest(key cancelKey, err error) {\n \tt.reqMu.Lock()\n-\tcancel := t.reqCanceler[req]\n-\tdelete(t.reqCanceler, req)\n+\tcancel := t.reqCanceler[key]\n+\tdelete(t.reqCanceler, key)\n \tt.reqMu.Unlock()\n \tif cancel != nil {\n \t\tcancel(err)\n@@ -1093,34 +1102,34 @@ func (t *Transport) removeIdleConnLocked(pconn *persistConn) bool {\n \treturn removed\n }\n \n-func (t *Transport) setReqCanceler(r *Request, fn func(error)) {\n+func (t *Transport) setReqCanceler(key cancelKey, fn func(error)) {\n \tt.reqMu.Lock()\n \tdefer t.reqMu.Unlock()\n \tif t.reqCanceler == nil {\n-\t\tt.reqCanceler = make(map[*Request]func(error))\n+\t\tt.reqCanceler = make(map[cancelKey]func(error))\n \t}\n \tif fn != nil {\n-\t\tt.reqCanceler[r] = fn\n+\t\tt.reqCanceler[key] = fn\n \t} else {\n-\t\tdelete(t.reqCanceler, r)\n+\t\tdelete(t.reqCanceler, key)\n \t}\n }\n \n // replaceReqCanceler replaces an existing cancel function. If there is no cancel function\n // for the request, we don't set the function and return false.\n // Since CancelRequest will clear the canceler, we can use the return value to detect if\n // the request was canceled since the last setReqCancel call.\n-func (t *Transport) replaceReqCanceler(r *Request, fn func(error)) bool {\n+func (t *Transport) replaceReqCanceler(key cancelKey, fn func(error)) bool {\n \tt.reqMu.Lock()\n \tdefer t.reqMu.Unlock()\n-\t_, ok := t.reqCanceler[r]\n+\t_, ok := t.reqCanceler[key]\n \tif !ok {\n \t\treturn false\n \t}\n \tif fn != nil {\n-\t\tt.reqCanceler[r] = fn\n+\t\tt.reqCanceler[key] = fn\n \t} else {\n-\t\tdelete(t.reqCanceler, r)\n+\t\tdelete(t.reqCanceler, key)\n \t}\n \treturn true\n }\n@@ -1324,12 +1333,12 @@ func (t *Transport) getConn(treq *transportRequest, cm connectMethod) (pc *persi\n \t\t// set request canceler to some non-nil function so we\n \t\t// can detect whether it was cleared between now and when\n \t\t// we enter roundTrip\n-\t\tt.setReqCanceler(req, func(error) {})\n+\t\tt.setReqCanceler(treq.cancelKey, func(error) {})\n \t\treturn pc, nil\n \t}\n \n \tcancelc := make(chan error, 1)\n-\tt.setReqCanceler(req, func(err error) { cancelc <- err })\n+\tt.setReqCanceler(treq.cancelKey, func(err error) { cancelc <- err })\n \n \t// Queue for permission to dial.\n \tt.queueForDial(w)\n@@ -2078,7 +2087,7 @@ func (pc *persistConn) readLoop() {\n \t\t}\n \n \t\tif !hasBody || bodyWritable {\n-\t\t\tpc.t.setReqCanceler(rc.req, nil)\n+\t\t\tpc.t.setReqCanceler(rc.cancelKey, nil)\n \n \t\t\t// Put the idle conn back into the pool before we send the response\n \t\t\t// so if they process it quickly and make another request, they'll\n@@ -2151,7 +2160,7 @@ func (pc *persistConn) readLoop() {\n \t\t// reading the response body. (or for cancellation or death)\n \t\tselect {\n \t\tcase bodyEOF := <-waitForBodyRead:\n-\t\t\tpc.t.setReqCanceler(rc.req, nil) // before pc might return to idle pool\n+\t\t\tpc.t.setReqCanceler(rc.cancelKey, nil) // before pc might return to idle pool\n \t\t\talive = alive &&\n \t\t\t\tbodyEOF &&\n \t\t\t\t!pc.sawEOF &&\n@@ -2165,7 +2174,7 @@ func (pc *persistConn) readLoop() {\n \t\t\tpc.t.CancelRequest(rc.req)\n \t\tcase <-rc.req.Context().Done():\n \t\t\talive = false\n-\t\t\tpc.t.cancelRequest(rc.req, rc.req.Context().Err())\n+\t\t\tpc.t.cancelRequest(rc.cancelKey, rc.req.Context().Err())\n \t\tcase <-pc.closech:\n \t\t\talive = false\n \t\t}\n@@ -2408,9 +2417,10 @@ type responseAndError struct {\n }\n \n type requestAndChan struct {\n-\t_   incomparable\n-\treq *Request\n-\tch  chan responseAndError // unbuffered; always send in select on callerGone\n+\t_         incomparable\n+\treq       *Request\n+\tcancelKey cancelKey\n+\tch        chan responseAndError // unbuffered; always send in select on callerGone\n \n \t// whether the Transport (as opposed to the user client code)\n \t// added the Accept-Encoding gzip header. If the Transport\n@@ -2472,7 +2482,7 @@ var (\n \n func (pc *persistConn) roundTrip(req *transportRequest) (resp *Response, err error) {\n \ttestHookEnterRoundTrip()\n-\tif !pc.t.replaceReqCanceler(req.Request, pc.cancelRequest) {\n+\tif !pc.t.replaceReqCanceler(req.cancelKey, pc.cancelRequest) {\n \t\tpc.t.putOrCloseIdleConn(pc)\n \t\treturn nil, errRequestCanceled\n \t}\n@@ -2524,7 +2534,7 @@ func (pc *persistConn) roundTrip(req *transportRequest) (resp *Response, err err\n \n \tdefer func() {\n \t\tif err != nil {\n-\t\t\tpc.t.setReqCanceler(req.Request, nil)\n+\t\t\tpc.t.setReqCanceler(req.cancelKey, nil)\n \t\t}\n \t}()\n \n@@ -2540,6 +2550,7 @@ func (pc *persistConn) roundTrip(req *transportRequest) (resp *Response, err err\n \tresc := make(chan responseAndError)\n \tpc.reqch <- requestAndChan{\n \t\treq:        req.Request,\n+\t\tcancelKey:  req.cancelKey,\n \t\tch:         resc,\n \t\taddedGzip:  requestedGzip,\n \t\tcontinueCh: continueCh,\n@@ -2591,10 +2602,10 @@ func (pc *persistConn) roundTrip(req *transportRequest) (resp *Response, err err\n \t\t\t}\n \t\t\treturn re.res, nil\n \t\tcase <-cancelChan:\n-\t\t\tpc.t.CancelRequest(req.Request)\n+\t\t\tpc.t.cancelRequest(req.cancelKey, errRequestCanceled)\n \t\t\tcancelChan = nil\n \t\tcase <-ctxDoneChan:\n-\t\t\tpc.t.cancelRequest(req.Request, req.Context().Err())\n+\t\t\tpc.t.cancelRequest(req.cancelKey, req.Context().Err())\n \t\t\tcancelChan = nil\n \t\t\tctxDoneChan = nil\n \t\t}"}, {"sha": "5c5ae3f6b22ebbec3771d521b5e136969d610adb", "filename": "libgo/go/net/http/transport_test.go", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go?ref=10c8507372f3e1c09df0bfe6449c126dee5075de", "patch": "@@ -2368,6 +2368,50 @@ func TestTransportCancelRequest(t *testing.T) {\n \t}\n }\n \n+func testTransportCancelRequestInDo(t *testing.T, body io.Reader) {\n+\tsetParallel(t)\n+\tdefer afterTest(t)\n+\tif testing.Short() {\n+\t\tt.Skip(\"skipping test in -short mode\")\n+\t}\n+\tunblockc := make(chan bool)\n+\tts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n+\t\t<-unblockc\n+\t}))\n+\tdefer ts.Close()\n+\tdefer close(unblockc)\n+\n+\tc := ts.Client()\n+\ttr := c.Transport.(*Transport)\n+\n+\tdonec := make(chan bool)\n+\treq, _ := NewRequest(\"GET\", ts.URL, body)\n+\tgo func() {\n+\t\tdefer close(donec)\n+\t\tc.Do(req)\n+\t}()\n+\tstart := time.Now()\n+\ttimeout := 10 * time.Second\n+\tfor time.Since(start) < timeout {\n+\t\ttime.Sleep(100 * time.Millisecond)\n+\t\ttr.CancelRequest(req)\n+\t\tselect {\n+\t\tcase <-donec:\n+\t\t\treturn\n+\t\tdefault:\n+\t\t}\n+\t}\n+\tt.Errorf(\"Do of canceled request has not returned after %v\", timeout)\n+}\n+\n+func TestTransportCancelRequestInDo(t *testing.T) {\n+\ttestTransportCancelRequestInDo(t, nil)\n+}\n+\n+func TestTransportCancelRequestWithBodyInDo(t *testing.T) {\n+\ttestTransportCancelRequestInDo(t, bytes.NewBuffer([]byte{0}))\n+}\n+\n func TestTransportCancelRequestInDial(t *testing.T) {\n \tdefer afterTest(t)\n \tif testing.Short() {"}, {"sha": "425ca8dd93f680ac7fc9c9b57c64d06fc0a7cd93", "filename": "libgo/go/runtime/lockrank_off.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2Fgo%2Fruntime%2Flockrank_off.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2Fgo%2Fruntime%2Flockrank_off.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Flockrank_off.go?ref=10c8507372f3e1c09df0bfe6449c126dee5075de", "patch": "@@ -1,3 +1,7 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n // +build !goexperiment.staticlockranking\n \n package runtime"}, {"sha": "fbc5ff58b72e6709ad67385ffc0ecdfab114ea20", "filename": "libgo/go/runtime/lockrank_on.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2Fgo%2Fruntime%2Flockrank_on.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2Fgo%2Fruntime%2Flockrank_on.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Flockrank_on.go?ref=10c8507372f3e1c09df0bfe6449c126dee5075de", "patch": "@@ -1,3 +1,7 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n // +build goexperiment.staticlockranking\n \n package runtime"}, {"sha": "8b3c62c375e76f2efbd1f08a566af86b86954eaf", "filename": "libgo/go/runtime/mpagealloc.go", "status": "modified", "additions": 32, "deletions": 11, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2Fgo%2Fruntime%2Fmpagealloc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2Fgo%2Fruntime%2Fmpagealloc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmpagealloc.go?ref=10c8507372f3e1c09df0bfe6449c126dee5075de", "patch": "@@ -233,16 +233,12 @@ type pageAlloc struct {\n \n \t// The address to start an allocation search with. It must never\n \t// point to any memory that is not contained in inUse, i.e.\n-\t// inUse.contains(searchAddr) must always be true.\n+\t// inUse.contains(searchAddr.addr()) must always be true. The one\n+\t// exception to this rule is that it may take on the value of\n+\t// maxOffAddr to indicate that the heap is exhausted.\n \t//\n-\t// When added with arenaBaseOffset, we guarantee that\n-\t// all valid heap addresses (when also added with\n-\t// arenaBaseOffset) below this value are allocated and\n-\t// not worth searching.\n-\t//\n-\t// Note that adding in arenaBaseOffset transforms addresses\n-\t// to a new address space with a linear view of the full address\n-\t// space on architectures with segmented address spaces.\n+\t// We guarantee that all valid heap addresses below this value\n+\t// are allocated and not worth searching.\n \tsearchAddr offAddr\n \n \t// start and end represent the chunk indices\n@@ -518,6 +514,30 @@ func (s *pageAlloc) allocRange(base, npages uintptr) uintptr {\n \treturn uintptr(scav) * pageSize\n }\n \n+// findMappedAddr returns the smallest mapped offAddr that is\n+// >= addr. That is, if addr refers to mapped memory, then it is\n+// returned. If addr is higher than any mapped region, then\n+// it returns maxOffAddr.\n+//\n+// s.mheapLock must be held.\n+func (s *pageAlloc) findMappedAddr(addr offAddr) offAddr {\n+\t// If we're not in a test, validate first by checking mheap_.arenas.\n+\t// This is a fast path which is only safe to use outside of testing.\n+\tai := arenaIndex(addr.addr())\n+\tif s.test || mheap_.arenas[ai.l1()] == nil || mheap_.arenas[ai.l1()][ai.l2()] == nil {\n+\t\tvAddr, ok := s.inUse.findAddrGreaterEqual(addr.addr())\n+\t\tif ok {\n+\t\t\treturn offAddr{vAddr}\n+\t\t} else {\n+\t\t\t// The candidate search address is greater than any\n+\t\t\t// known address, which means we definitely have no\n+\t\t\t// free memory left.\n+\t\t\treturn maxOffAddr\n+\t\t}\n+\t}\n+\treturn addr\n+}\n+\n // find searches for the first (address-ordered) contiguous free region of\n // npages in size and returns a base address for that region.\n //\n@@ -526,6 +546,7 @@ func (s *pageAlloc) allocRange(base, npages uintptr) uintptr {\n //\n // find also computes and returns a candidate s.searchAddr, which may or\n // may not prune more of the address space than s.searchAddr already does.\n+// This candidate is always a valid s.searchAddr.\n //\n // find represents the slow path and the full radix tree search.\n //\n@@ -695,7 +716,7 @@ nextLevel:\n \t\t\t// We found a sufficiently large run of free pages straddling\n \t\t\t// some boundary, so compute the address and return it.\n \t\t\taddr := levelIndexToOffAddr(l, i).add(uintptr(base) * pageSize).addr()\n-\t\t\treturn addr, firstFree.base\n+\t\t\treturn addr, s.findMappedAddr(firstFree.base)\n \t\t}\n \t\tif l == 0 {\n \t\t\t// We're at level zero, so that means we've exhausted our search.\n@@ -741,7 +762,7 @@ nextLevel:\n \t// found an even narrower free window.\n \tsearchAddr := chunkBase(ci) + uintptr(searchIdx)*pageSize\n \tfoundFree(offAddr{searchAddr}, chunkBase(ci+1)-searchAddr)\n-\treturn addr, firstFree.base\n+\treturn addr, s.findMappedAddr(firstFree.base)\n }\n \n // alloc allocates npages worth of memory from the page heap, returning the base"}, {"sha": "65ba71d459ce60248979508b19b8b3dc79e25bab", "filename": "libgo/go/runtime/mpagealloc_test.go", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2Fgo%2Fruntime%2Fmpagealloc_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2Fgo%2Fruntime%2Fmpagealloc_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmpagealloc_test.go?ref=10c8507372f3e1c09df0bfe6449c126dee5075de", "patch": "@@ -612,6 +612,63 @@ func TestPageAllocAlloc(t *testing.T) {\n \t\t\t\tbaseChunkIdx + chunkIdxBigJump:     {{0, PallocChunkPages}},\n \t\t\t},\n \t\t}\n+\n+\t\t// Test to check for issue #40191. Essentially, the candidate searchAddr\n+\t\t// discovered by find may not point to mapped memory, so we need to handle\n+\t\t// that explicitly.\n+\t\t//\n+\t\t// chunkIdxSmallOffset is an offset intended to be used within chunkIdxBigJump.\n+\t\t// It is far enough within chunkIdxBigJump that the summaries at the beginning\n+\t\t// of an address range the size of chunkIdxBigJump will not be mapped in.\n+\t\tconst chunkIdxSmallOffset = 0x503\n+\t\ttests[\"DiscontiguousBadSearchAddr\"] = test{\n+\t\t\tbefore: map[ChunkIdx][]BitRange{\n+\t\t\t\t// The mechanism for the bug involves three chunks, A, B, and C, which are\n+\t\t\t\t// far apart in the address space. In particular, B is chunkIdxBigJump +\n+\t\t\t\t// chunkIdxSmalloffset chunks away from B, and C is 2*chunkIdxBigJump chunks\n+\t\t\t\t// away from A. A has 1 page free, B has several (NOT at the end of B), and\n+\t\t\t\t// C is totally free.\n+\t\t\t\t// Note that B's free memory must not be at the end of B because the fast\n+\t\t\t\t// path in the page allocator will check if the searchAddr even gives us\n+\t\t\t\t// enough space to place the allocation in a chunk before accessing the\n+\t\t\t\t// summary.\n+\t\t\t\tBaseChunkIdx + chunkIdxBigJump*0: {{0, PallocChunkPages - 1}},\n+\t\t\t\tBaseChunkIdx + chunkIdxBigJump*1 + chunkIdxSmallOffset: {\n+\t\t\t\t\t{0, PallocChunkPages - 10},\n+\t\t\t\t\t{PallocChunkPages - 1, 1},\n+\t\t\t\t},\n+\t\t\t\tBaseChunkIdx + chunkIdxBigJump*2: {},\n+\t\t\t},\n+\t\t\tscav: map[ChunkIdx][]BitRange{\n+\t\t\t\tBaseChunkIdx + chunkIdxBigJump*0:                       {},\n+\t\t\t\tBaseChunkIdx + chunkIdxBigJump*1 + chunkIdxSmallOffset: {},\n+\t\t\t\tBaseChunkIdx + chunkIdxBigJump*2:                       {},\n+\t\t\t},\n+\t\t\thits: []hit{\n+\t\t\t\t// We first allocate into A to set the page allocator's searchAddr to the\n+\t\t\t\t// end of that chunk. That is the only purpose A serves.\n+\t\t\t\t{1, PageBase(BaseChunkIdx, PallocChunkPages-1), 0},\n+\t\t\t\t// Then, we make a big allocation that doesn't fit into B, and so must be\n+\t\t\t\t// fulfilled by C.\n+\t\t\t\t//\n+\t\t\t\t// On the way to fulfilling the allocation into C, we estimate searchAddr\n+\t\t\t\t// using the summary structure, but that will give us a searchAddr of\n+\t\t\t\t// B's base address minus chunkIdxSmallOffset chunks. These chunks will\n+\t\t\t\t// not be mapped.\n+\t\t\t\t{100, PageBase(baseChunkIdx+chunkIdxBigJump*2, 0), 0},\n+\t\t\t\t// Now we try to make a smaller allocation that can be fulfilled by B.\n+\t\t\t\t// In an older implementation of the page allocator, this will segfault,\n+\t\t\t\t// because this last allocation will first try to access the summary\n+\t\t\t\t// for B's base address minus chunkIdxSmallOffset chunks in the fast path,\n+\t\t\t\t// and this will not be mapped.\n+\t\t\t\t{9, PageBase(baseChunkIdx+chunkIdxBigJump*1+chunkIdxSmallOffset, PallocChunkPages-10), 0},\n+\t\t\t},\n+\t\t\tafter: map[ChunkIdx][]BitRange{\n+\t\t\t\tBaseChunkIdx + chunkIdxBigJump*0:                       {{0, PallocChunkPages}},\n+\t\t\t\tBaseChunkIdx + chunkIdxBigJump*1 + chunkIdxSmallOffset: {{0, PallocChunkPages}},\n+\t\t\t\tBaseChunkIdx + chunkIdxBigJump*2:                       {{0, 100}},\n+\t\t\t},\n+\t\t}\n \t}\n \tfor name, v := range tests {\n \t\tv := v"}, {"sha": "2c0eb2c2ddf5e4c68cd3bca5598e780e2493e54d", "filename": "libgo/go/runtime/mranges.go", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2Fgo%2Fruntime%2Fmranges.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2Fgo%2Fruntime%2Fmranges.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmranges.go?ref=10c8507372f3e1c09df0bfe6449c126dee5075de", "patch": "@@ -188,6 +188,25 @@ func (a *addrRanges) findSucc(addr uintptr) int {\n \treturn len(a.ranges)\n }\n \n+// findAddrGreaterEqual returns the smallest address represented by a\n+// that is >= addr. Thus, if the address is represented by a,\n+// then it returns addr. The second return value indicates whether\n+// such an address exists for addr in a. That is, if addr is larger than\n+// any address known to a, the second return value will be false.\n+func (a *addrRanges) findAddrGreaterEqual(addr uintptr) (uintptr, bool) {\n+\ti := a.findSucc(addr)\n+\tif i == 0 {\n+\t\treturn a.ranges[0].base.addr(), true\n+\t}\n+\tif a.ranges[i-1].contains(addr) {\n+\t\treturn addr, true\n+\t}\n+\tif i < len(a.ranges) {\n+\t\treturn a.ranges[i].base.addr(), true\n+\t}\n+\treturn 0, false\n+}\n+\n // contains returns true if a covers the address addr.\n func (a *addrRanges) contains(addr uintptr) bool {\n \ti := a.findSucc(addr)"}, {"sha": "84070e42cfa5a3ae08cf1e2caeff4fb19b6f1321", "filename": "libgo/go/runtime/proc.go", "status": "modified", "additions": 52, "deletions": 17, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2Fgo%2Fruntime%2Fproc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2Fgo%2Fruntime%2Fproc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fproc.go?ref=10c8507372f3e1c09df0bfe6449c126dee5075de", "patch": "@@ -176,7 +176,7 @@ func main(unsafe.Pointer) {\n \n \tif GOARCH != \"wasm\" { // no threads on wasm yet, so no sysmon\n \t\tsystemstack(func() {\n-\t\t\tnewm(sysmon, nil)\n+\t\t\tnewm(sysmon, nil, -1)\n \t\t})\n \t}\n \n@@ -567,7 +567,7 @@ func schedinit() {\n \n \tmallocinit()\n \tfastrandinit() // must run before mcommoninit\n-\tmcommoninit(_g_.m)\n+\tmcommoninit(_g_.m, -1)\n \tcpuinit() // must run before alginit\n \talginit() // maps must not be used before this call\n \n@@ -633,7 +633,22 @@ func checkmcount() {\n \t}\n }\n \n-func mcommoninit(mp *m) {\n+// mReserveID returns the next ID to use for a new m. This new m is immediately\n+// considered 'running' by checkdead.\n+//\n+// sched.lock must be held.\n+func mReserveID() int64 {\n+\tif sched.mnext+1 < sched.mnext {\n+\t\tthrow(\"runtime: thread ID overflow\")\n+\t}\n+\tid := sched.mnext\n+\tsched.mnext++\n+\tcheckmcount()\n+\treturn id\n+}\n+\n+// Pre-allocated ID may be passed as 'id', or omitted by passing -1.\n+func mcommoninit(mp *m, id int64) {\n \t_g_ := getg()\n \n \t// g0 stack won't make sense for user (and is not necessary unwindable).\n@@ -642,12 +657,12 @@ func mcommoninit(mp *m) {\n \t}\n \n \tlock(&sched.lock)\n-\tif sched.mnext+1 < sched.mnext {\n-\t\tthrow(\"runtime: thread ID overflow\")\n+\n+\tif id >= 0 {\n+\t\tmp.id = id\n+\t} else {\n+\t\tmp.id = mReserveID()\n \t}\n-\tmp.id = sched.mnext\n-\tsched.mnext++\n-\tcheckmcount()\n \n \tmp.fastrand[0] = uint32(int64Hash(uint64(mp.id), fastrandseed))\n \tmp.fastrand[1] = uint32(int64Hash(uint64(cputicks()), ^fastrandseed))\n@@ -1052,7 +1067,7 @@ func startTheWorldWithSema(emitTraceEvent bool) int64 {\n \t\t\tnotewakeup(&mp.park)\n \t\t} else {\n \t\t\t// Start M to run P.  Do not start another M below.\n-\t\t\tnewm(nil, p)\n+\t\t\tnewm(nil, p, -1)\n \t\t}\n \t}\n \n@@ -1379,12 +1394,13 @@ func runSafePointFn() {\n // Allocate a new m unassociated with any thread.\n // Can use p for allocation context if needed.\n // fn is recorded as the new m's m.mstartfn.\n+// id is optional pre-allocated m ID. Omit by passing -1.\n //\n // This function is allowed to have write barriers even if the caller\n // isn't because it borrows _p_.\n //\n //go:yeswritebarrierrec\n-func allocm(_p_ *p, fn func(), allocatestack bool) (mp *m, g0Stack unsafe.Pointer, g0StackSize uintptr) {\n+func allocm(_p_ *p, fn func(), id int64, allocatestack bool) (mp *m, g0Stack unsafe.Pointer, g0StackSize uintptr) {\n \t_g_ := getg()\n \tacquirem() // disable GC because it can be called from sysmon\n \tif _g_.m.p == 0 {\n@@ -1413,7 +1429,7 @@ func allocm(_p_ *p, fn func(), allocatestack bool) (mp *m, g0Stack unsafe.Pointe\n \n \tmp = new(m)\n \tmp.mstartfn = fn\n-\tmcommoninit(mp)\n+\tmcommoninit(mp, id)\n \n \tmp.g0 = malg(allocatestack, false, &g0Stack, &g0StackSize)\n \tmp.g0.m = mp\n@@ -1540,7 +1556,7 @@ func oneNewExtraM() {\n \t// The sched.pc will never be returned to, but setting it to\n \t// goexit makes clear to the traceback routines where\n \t// the goroutine stack ends.\n-\tmp, g0SP, g0SPSize := allocm(nil, nil, true)\n+\tmp, g0SP, g0SPSize := allocm(nil, nil, -1, true)\n \tgp := malg(true, false, nil, nil)\n \t// malg returns status as _Gidle. Change to _Gdead before\n \t// adding to allg where GC can see it. We use _Gdead to hide\n@@ -1715,9 +1731,11 @@ var newmHandoff struct {\n // Create a new m. It will start off with a call to fn, or else the scheduler.\n // fn needs to be static and not a heap allocated closure.\n // May run with m.p==nil, so write barriers are not allowed.\n+//\n+// id is optional pre-allocated m ID. Omit by passing -1.\n //go:nowritebarrierrec\n-func newm(fn func(), _p_ *p) {\n-\tmp, _, _ := allocm(_p_, fn, false)\n+func newm(fn func(), _p_ *p, id int64) {\n+\tmp, _, _ := allocm(_p_, fn, id, false)\n \tmp.nextp.set(_p_)\n \tmp.sigmask = initSigmask\n \tif gp := getg(); gp != nil && gp.m != nil && (gp.m.lockedExt != 0 || gp.m.incgo) && GOOS != \"plan9\" {\n@@ -1770,7 +1788,7 @@ func startTemplateThread() {\n \t\treleasem(mp)\n \t\treturn\n \t}\n-\tnewm(templateThread, nil)\n+\tnewm(templateThread, nil, -1)\n \treleasem(mp)\n }\n \n@@ -1865,16 +1883,31 @@ func startm(_p_ *p, spinning bool) {\n \t\t}\n \t}\n \tmp := mget()\n-\tunlock(&sched.lock)\n \tif mp == nil {\n+\t\t// No M is available, we must drop sched.lock and call newm.\n+\t\t// However, we already own a P to assign to the M.\n+\t\t//\n+\t\t// Once sched.lock is released, another G (e.g., in a syscall),\n+\t\t// could find no idle P while checkdead finds a runnable G but\n+\t\t// no running M's because this new M hasn't started yet, thus\n+\t\t// throwing in an apparent deadlock.\n+\t\t//\n+\t\t// Avoid this situation by pre-allocating the ID for the new M,\n+\t\t// thus marking it as 'running' before we drop sched.lock. This\n+\t\t// new M will eventually run the scheduler to execute any\n+\t\t// queued G's.\n+\t\tid := mReserveID()\n+\t\tunlock(&sched.lock)\n+\n \t\tvar fn func()\n \t\tif spinning {\n \t\t\t// The caller incremented nmspinning, so set m.spinning in the new M.\n \t\t\tfn = mspinning\n \t\t}\n-\t\tnewm(fn, _p_)\n+\t\tnewm(fn, _p_, id)\n \t\treturn\n \t}\n+\tunlock(&sched.lock)\n \tif mp.spinning {\n \t\tthrow(\"startm: m is spinning\")\n \t}\n@@ -4897,7 +4930,9 @@ func runqputbatch(pp *p, q *gQueue, qsize int) {\n \n \tatomic.StoreRel(&pp.runqtail, t)\n \tif !q.empty() {\n+\t\tlock(&sched.lock)\n \t\tglobrunqputbatch(q, int32(qsize))\n+\t\tunlock(&sched.lock)\n \t}\n }\n "}, {"sha": "f10c4e8e0ef3e7e9ee4aefa27825f6a0b7e47296", "filename": "libgo/go/sync/runtime2.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2Fgo%2Fsync%2Fruntime2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2Fgo%2Fsync%2Fruntime2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fruntime2.go?ref=10c8507372f3e1c09df0bfe6449c126dee5075de", "patch": "@@ -1,3 +1,7 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n // +build !goexperiment.staticlockranking\n \n package sync"}, {"sha": "aaa1c276261e29a7e34cc014467301cc9d2d226a", "filename": "libgo/go/sync/runtime2_lockrank.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2Fgo%2Fsync%2Fruntime2_lockrank.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2Fgo%2Fsync%2Fruntime2_lockrank.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fruntime2_lockrank.go?ref=10c8507372f3e1c09df0bfe6449c126dee5075de", "patch": "@@ -1,3 +1,7 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n // +build goexperiment.staticlockranking\n \n package sync"}, {"sha": "dee77f747c01effb3ae27bfdb1876d056ebfee27", "filename": "libgo/go/testing/testing.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2Fgo%2Ftesting%2Ftesting.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2Fgo%2Ftesting%2Ftesting.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Ftesting.go?ref=10c8507372f3e1c09df0bfe6449c126dee5075de", "patch": "@@ -3,7 +3,7 @@\n // license that can be found in the LICENSE file.\n \n // Package testing provides support for automated testing of Go packages.\n-// It is intended to be used in concert with the ``go test'' command, which automates\n+// It is intended to be used in concert with the \"go test\" command, which automates\n // execution of any function of the form\n //     func TestXxx(*testing.T)\n // where Xxx does not start with a lowercase letter. The function name\n@@ -14,8 +14,8 @@\n // To write a new test suite, create a file whose name ends _test.go that\n // contains the TestXxx functions as described here. Put the file in the same\n // package as the one being tested. The file will be excluded from regular\n-// package builds but will be included when the ``go test'' command is run.\n-// For more detail, run ``go help test'' and ``go help testflag''.\n+// package builds but will be included when the \"go test\" command is run.\n+// For more detail, run \"go help test\" and \"go help testflag\".\n //\n // A simple test function looks like this:\n //"}, {"sha": "35bc3a1447592f5d8b999b7ab95ee3afaaad1ef4", "filename": "libgo/misc/cgo/test/test.go", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2Fmisc%2Fcgo%2Ftest%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2Fmisc%2Fcgo%2Ftest%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Ftest.go?ref=10c8507372f3e1c09df0bfe6449c126dee5075de", "patch": "@@ -901,6 +901,12 @@ typedef struct S32579 { unsigned char data[1]; } S32579;\n // issue 38649\n // Test that #define'd type aliases work.\n #define netbsd_gid unsigned int\n+\n+// issue 40494\n+// Inconsistent handling of tagged enum and union types.\n+enum Enum40494 { X_40494 };\n+union Union40494 { int x; };\n+void issue40494(enum Enum40494 e, union Union40494* up) {}\n */\n import \"C\"\n \n@@ -2204,3 +2210,10 @@ var issue38649 C.netbsd_gid = 42\n // issue 39877\n \n var issue39877 *C.void = nil\n+\n+// issue 40494\n+// No runtime test; just make sure it compiles.\n+\n+func Issue40494() {\n+\tC.issue40494(C.enum_Enum40494(C.X_40494), (*C.union_Union40494)(nil))\n+}"}, {"sha": "5e0893784b69d74cca9350719c313748121c2230", "filename": "libgo/misc/cgo/testshared/shared_test.go", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fshared_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c8507372f3e1c09df0bfe6449c126dee5075de/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fshared_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fshared_test.go?ref=10c8507372f3e1c09df0bfe6449c126dee5075de", "patch": "@@ -462,6 +462,7 @@ func TestTrivialExecutable(t *testing.T) {\n \trun(t, \"trivial executable\", \"../../bin/trivial\")\n \tAssertIsLinkedTo(t, \"../../bin/trivial\", soname)\n \tAssertHasRPath(t, \"../../bin/trivial\", gorootInstallDir)\n+\tcheckSize(t, \"../../bin/trivial\", 100000) // it is 19K on linux/amd64, 100K should be enough\n }\n \n // Build a trivial program in PIE mode that links against the shared runtime and check it runs.\n@@ -470,6 +471,18 @@ func TestTrivialExecutablePIE(t *testing.T) {\n \trun(t, \"trivial executable\", \"./trivial.pie\")\n \tAssertIsLinkedTo(t, \"./trivial.pie\", soname)\n \tAssertHasRPath(t, \"./trivial.pie\", gorootInstallDir)\n+\tcheckSize(t, \"./trivial.pie\", 100000) // it is 19K on linux/amd64, 100K should be enough\n+}\n+\n+// Check that the file size does not exceed a limit.\n+func checkSize(t *testing.T, f string, limit int64) {\n+\tfi, err := os.Stat(f)\n+\tif err != nil {\n+\t\tt.Fatalf(\"stat failed: %v\", err)\n+\t}\n+\tif sz := fi.Size(); sz > limit {\n+\t\tt.Errorf(\"file too large: got %d, want <= %d\", sz, limit)\n+\t}\n }\n \n // Build a division test program and check it runs."}]}