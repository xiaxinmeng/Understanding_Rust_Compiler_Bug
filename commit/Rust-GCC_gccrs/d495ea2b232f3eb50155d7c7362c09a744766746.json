{"sha": "d495ea2b232f3eb50155d7c7362c09a744766746", "node_id": "C_kwDOANBUbNoAKGQ0OTVlYTJiMjMyZjNlYjUwMTU1ZDdjNzM2MmMwOWE3NDQ3NjY3NDY", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2023-03-25T00:52:34Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2023-03-25T00:52:34Z"}, "message": "diagnostics: ensure that .sarif files are UTF-8 encoded [PR109098]\n\nPR analyzer/109098 notes that the SARIF spec mandates that .sarif\nfiles are UTF-8 encoded, but -fdiagnostics-format=sarif-file naively\nassumes that the source files are UTF-8 encoded when quoting source\nartefacts in the .sarif output, which can lead to us writing out\n.sarif files with non-UTF-8 bytes in them (which break my reporting\nscripts).\n\nThe root cause is that sarif_builder::maybe_make_artifact_content_object\nwas using maybe_read_file to load the file content as bytes, and\nassuming they were UTF-8 encoded.\n\nThis patch reworks both overloads of this function (one used for the\nwhole file, the other for snippets of quoted lines) so that they go\nthrough input.cc's file cache, which attempts to decode the input files\naccording to the input charset, and then encode as UTF-8.  They also\ncheck that the result actually is UTF-8, for cases where the input\ncharset is missing, or incorrectly specified, and omit the quoted\nsource for such awkward cases.\n\nDoing so fixes all of the cases I've encountered.\n\nThe patch adds a new:\n  { dg-final { verify-sarif-file } }\ndirective to all SARIF test cases in the test suite, which verifies\nthat the output is UTF-8 encoded, and is valid JSON.  In particular\nit verifies that when we complain about encoding problems, the .sarif\nreport we emit is itself correctly encoded.\n\ngcc/ChangeLog:\n\tPR analyzer/109098\n\t* diagnostic-format-sarif.cc (read_until_eof): Delete.\n\t(maybe_read_file): Delete.\n\t(sarif_builder::maybe_make_artifact_content_object): Use\n\tget_source_file_content rather than maybe_read_file.\n\tReject it if it's not valid UTF-8.\n\t* input.cc (file_cache_slot::get_full_file_content): New.\n\t(get_source_file_content): New.\n\t(selftest::check_cpp_valid_utf8_p): New.\n\t(selftest::test_cpp_valid_utf8_p): New.\n\t(selftest::input_cc_tests): Call selftest::test_cpp_valid_utf8_p.\n\t* input.h (get_source_file_content): New prototype.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/109098\n\t* c-c++-common/diagnostic-format-sarif-file-1.c: Add\n\tverify-sarif-file directive.\n\t* c-c++-common/diagnostic-format-sarif-file-2.c: Likewise.\n\t* c-c++-common/diagnostic-format-sarif-file-3.c: Likewise.\n\t* c-c++-common/diagnostic-format-sarif-file-4.c: Likewise.\n\t* c-c++-common/diagnostic-format-sarif-file-Wbidi-chars.c: New\n\ttest case, adapted from Wbidi-chars-1.c.\n\t* c-c++-common/diagnostic-format-sarif-file-bad-utf8-pr109098-1.c:\n\tNew test case.\n\t* c-c++-common/diagnostic-format-sarif-file-bad-utf8-pr109098-2.c:\n\tNew test case.\n\t* c-c++-common/diagnostic-format-sarif-file-bad-utf8-pr109098-3.c:\n\tNew test case, adapted from cpp/Winvalid-utf8-1.c.\n\t* c-c++-common/diagnostic-format-sarif-file-valid-CP850.c: New\n\ttest case, adapted from gcc.dg/diagnostic-input-charset-1.c.\n\t* gcc.dg/plugin/crash-test-ice-sarif.c: Add verify-sarif-file\n\tdirective.\n\t* gcc.dg/plugin/crash-test-write-though-null-sarif.c: Likewise.\n\t* gcc.dg/plugin/diagnostic-test-paths-5.c: Likewise.\n\t* lib/scansarif.exp (verify-sarif-file): New procedure.\n\t* lib/verify-sarif-file.py: New support script.\n\nlibcpp/ChangeLog:\n\tPR analyzer/109098\n\t* charset.cc (cpp_valid_utf8_p): New function.\n\t* include/cpplib.h (cpp_valid_utf8_p): New prototype.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "0216e5a6060e9e3762d6951bc47524cea7e9c7f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0216e5a6060e9e3762d6951bc47524cea7e9c7f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d495ea2b232f3eb50155d7c7362c09a744766746", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d495ea2b232f3eb50155d7c7362c09a744766746", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d495ea2b232f3eb50155d7c7362c09a744766746", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d495ea2b232f3eb50155d7c7362c09a744766746/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "13ec81eb4c3b484ad636000fa8f6d925e15fb983", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13ec81eb4c3b484ad636000fa8f6d925e15fb983", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13ec81eb4c3b484ad636000fa8f6d925e15fb983"}], "stats": {"total": 462, "additions": 401, "deletions": 61}, "files": [{"sha": "fd29ac2ca3b4ad9e6f3438ac5c9a8ec189a31c47", "filename": "gcc/diagnostic-format-sarif.cc", "status": "modified", "additions": 17, "deletions": 61, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d495ea2b232f3eb50155d7c7362c09a744766746/gcc%2Fdiagnostic-format-sarif.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d495ea2b232f3eb50155d7c7362c09a744766746/gcc%2Fdiagnostic-format-sarif.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-format-sarif.cc?ref=d495ea2b232f3eb50155d7c7362c09a744766746", "patch": "@@ -1390,76 +1390,25 @@ sarif_builder::make_artifact_object (const char *filename)\n   return artifact_obj;\n }\n \n-/* Read all data from F_IN until EOF.\n-   Return a NULL-terminated buffer containing the data, which must be\n-   freed by the caller.\n-   Return NULL on errors.  */\n-\n-static char *\n-read_until_eof (FILE *f_in)\n-{\n-  /* Read content, allocating a buffer for it.  */\n-  char *result = NULL;\n-  size_t total_sz = 0;\n-  size_t alloc_sz = 0;\n-  char buf[4096];\n-  size_t iter_sz_in;\n-\n-  while ( (iter_sz_in = fread (buf, 1, sizeof (buf), f_in)) )\n-    {\n-      gcc_assert (alloc_sz >= total_sz);\n-      size_t old_total_sz = total_sz;\n-      total_sz += iter_sz_in;\n-      /* Allow 1 extra byte for 0-termination.  */\n-      if (alloc_sz < (total_sz + 1))\n-\t{\n-\t  size_t new_alloc_sz = alloc_sz ? alloc_sz * 2: total_sz + 1;\n-\t  result = (char *)xrealloc (result, new_alloc_sz);\n-\t  alloc_sz = new_alloc_sz;\n-\t}\n-      memcpy (result + old_total_sz, buf, iter_sz_in);\n-    }\n-\n-  if (!feof (f_in))\n-    return NULL;\n-\n-  /* 0-terminate the buffer.  */\n-  gcc_assert (total_sz < alloc_sz);\n-  result[total_sz] = '\\0';\n-\n-  return result;\n-}\n-\n-/* Read all data from FILENAME until EOF.\n-   Return a NULL-terminated buffer containing the data, which must be\n-   freed by the caller.\n-   Return NULL on errors.  */\n-\n-static char *\n-maybe_read_file (const char *filename)\n-{\n-  FILE *f_in = fopen (filename, \"r\");\n-  if (!f_in)\n-    return NULL;\n-  char *result = read_until_eof (f_in);\n-  fclose (f_in);\n-  return result;\n-}\n-\n /* Make an artifactContent object (SARIF v2.1.0 section 3.3) for the\n    full contents of FILENAME.  */\n \n json::object *\n sarif_builder::maybe_make_artifact_content_object (const char *filename) const\n {\n-  char *text_utf8 = maybe_read_file (filename);\n-  if (!text_utf8)\n+  /* Let input.cc handle any charset conversion.  */\n+  char_span utf8_content = get_source_file_content (filename);\n+  if (!utf8_content)\n     return NULL;\n \n-  json::object *artifact_content_obj = new json::object ();\n-  artifact_content_obj->set (\"text\", new json::string (text_utf8));\n-  free (text_utf8);\n+  /* Don't add it if it's not valid UTF-8.  */\n+  if (!cpp_valid_utf8_p(utf8_content.get_buffer (), utf8_content.length ()))\n+    return NULL;\n \n+  json::object *artifact_content_obj = new json::object ();\n+  artifact_content_obj->set (\"text\",\n+\t\t\t     new json::string (utf8_content.get_buffer (),\n+\t\t\t\t\t       utf8_content.length ()));\n   return artifact_content_obj;\n }\n \n@@ -1501,6 +1450,13 @@ sarif_builder::maybe_make_artifact_content_object (const char *filename,\n   if (!text_utf8)\n     return NULL;\n \n+  /* Don't add it if it's not valid UTF-8.  */\n+  if (!cpp_valid_utf8_p(text_utf8, strlen(text_utf8)))\n+    {\n+      free (text_utf8);\n+      return NULL;\n+    }\n+\n   json::object *artifact_content_obj = new json::object ();\n   artifact_content_obj->set (\"text\", new json::string (text_utf8));\n   free (text_utf8);"}, {"sha": "eaf301ec7c15075d53f801e85180a91bcacc05d2", "filename": "gcc/input.cc", "status": "modified", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d495ea2b232f3eb50155d7c7362c09a744766746/gcc%2Finput.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d495ea2b232f3eb50155d7c7362c09a744766746/gcc%2Finput.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.cc?ref=d495ea2b232f3eb50155d7c7362c09a744766746", "patch": "@@ -67,6 +67,7 @@ class file_cache_slot\n   {\n     return m_missing_trailing_newline;\n   }\n+  char_span get_full_file_content ();\n \n   void inc_use_count () { m_use_count++; }\n \n@@ -459,6 +460,20 @@ file_cache::add_file (const char *file_path)\n   return r;\n }\n \n+/* Get a borrowed char_span to the full content of this file\n+   as decoded according to the input charset, encoded as UTF-8.  */\n+\n+char_span\n+file_cache_slot::get_full_file_content ()\n+{\n+  char *line;\n+  ssize_t line_len;\n+  while (get_next_line (&line, &line_len))\n+    {\n+    }\n+  return char_span (m_data, m_nb_read);\n+}\n+\n /* Populate this slot for use on FILE_PATH and FP, dropping any\n    existing cached content within it.  */\n \n@@ -1047,6 +1062,18 @@ get_source_text_between (location_t start, location_t end)\n   return xstrdup (buf);\n }\n \n+/* Get a borrowed char_span to the full content of FILE_PATH\n+   as decoded according to the input charset, encoded as UTF-8.  */\n+\n+char_span\n+get_source_file_content (const char *file_path)\n+{\n+  diagnostic_file_cache_init ();\n+\n+  file_cache_slot *c = global_dc->m_file_cache->lookup_or_add_file (file_path);\n+  return c->get_full_file_content ();\n+}\n+\n /* Determine if FILE_PATH missing a trailing newline on its final line.\n    Only valid to call once all of the file has been loaded, by\n    requesting a line number beyond the end of the file.  */\n@@ -4045,7 +4072,104 @@ void test_cpp_utf8 ()\n \t  ASSERT_EQ (byte_col2, byte_col);\n       }\n   }\n+}\n+\n+static bool\n+check_cpp_valid_utf8_p (const char *str)\n+{\n+  return cpp_valid_utf8_p (str, strlen (str));\n+}\n+\n+/* Check that cpp_valid_utf8_p works as expected.  */\n+\n+static void\n+test_cpp_valid_utf8_p ()\n+{\n+  ASSERT_TRUE (check_cpp_valid_utf8_p (\"hello world\"));\n+\n+  /* 2-byte char (pi).  */\n+  ASSERT_TRUE (check_cpp_valid_utf8_p(\"\\xcf\\x80\"));\n+\n+  /* 3-byte chars (the Japanese word \"mojibake\").  */\n+  ASSERT_TRUE (check_cpp_valid_utf8_p\n+\t       (\n+\t\t/* U+6587 CJK UNIFIED IDEOGRAPH-6587\n+\t\t   UTF-8: 0xE6 0x96 0x87\n+\t\t   C octal escaped UTF-8: \\346\\226\\207.  */\n+\t\t\"\\346\\226\\207\"\n+\t\t/* U+5B57 CJK UNIFIED IDEOGRAPH-5B57\n+\t\t   UTF-8: 0xE5 0xAD 0x97\n+\t\t   C octal escaped UTF-8: \\345\\255\\227.  */\n+\t\t\"\\345\\255\\227\"\n+\t\t/* U+5316 CJK UNIFIED IDEOGRAPH-5316\n+\t\t   UTF-8: 0xE5 0x8C 0x96\n+\t\t   C octal escaped UTF-8: \\345\\214\\226.  */\n+\t\t\"\\345\\214\\226\"\n+\t\t/* U+3051 HIRAGANA LETTER KE\n+\t\t   UTF-8: 0xE3 0x81 0x91\n+\t\t   C octal escaped UTF-8: \\343\\201\\221.  */\n+\t\t\"\\343\\201\\221\"));\n+\n+  /* 4-byte char: an emoji.  */\n+  ASSERT_TRUE (check_cpp_valid_utf8_p (\"\\xf0\\x9f\\x98\\x82\"));\n+\n+  /* Control codes, including the NUL byte.  */\n+  ASSERT_TRUE (cpp_valid_utf8_p (\"\\r\\n\\v\\0\\1\", 5));\n+\n+  ASSERT_FALSE (check_cpp_valid_utf8_p (\"\\xf0!\\x9f!\\x98!\\x82!\"));\n+\n+  /* Unexpected continuation bytes.  */\n+  for (unsigned char continuation_byte = 0x80;\n+       continuation_byte <= 0xbf;\n+       continuation_byte++)\n+    ASSERT_FALSE (cpp_valid_utf8_p ((const char *)&continuation_byte, 1));\n+\n+  /* \"Lonely start characters\" for 2-byte sequences.  */\n+  {\n+    unsigned char buf[2];\n+    buf[1] = ' ';\n+    for (buf[0] = 0xc0;\n+\t buf[0] <= 0xdf;\n+\t buf[0]++)\n+      ASSERT_FALSE (cpp_valid_utf8_p ((const char *)buf, 2));\n+  }\n+\n+  /* \"Lonely start characters\" for 3-byte sequences.  */\n+  {\n+    unsigned char buf[2];\n+    buf[1] = ' ';\n+    for (buf[0] = 0xe0;\n+\t buf[0] <= 0xef;\n+\t buf[0]++)\n+      ASSERT_FALSE (cpp_valid_utf8_p ((const char *)buf, 2));\n+  }\n+\n+  /* \"Lonely start characters\" for 4-byte sequences.  */\n+  {\n+    unsigned char buf[2];\n+    buf[1] = ' ';\n+    for (buf[0] = 0xf0;\n+\t buf[0] <= 0xf4;\n+\t buf[0]++)\n+      ASSERT_FALSE (cpp_valid_utf8_p ((const char *)buf, 2));\n+  }\n+\n+  /* Invalid start characters (formerly valid for 5-byte and 6-byte\n+     sequences).  */\n+  {\n+    unsigned char buf[2];\n+    buf[1] = ' ';\n+    for (buf[0] = 0xf5;\n+\t buf[0] <= 0xfd;\n+\t buf[0]++)\n+      ASSERT_FALSE (cpp_valid_utf8_p ((const char *)buf, 2));\n+  }\n \n+  /* Impossible bytes.  */\n+  ASSERT_FALSE (check_cpp_valid_utf8_p (\"\\xc0\"));\n+  ASSERT_FALSE (check_cpp_valid_utf8_p (\"\\xc1\"));\n+  ASSERT_FALSE (check_cpp_valid_utf8_p (\"\\xfe\"));\n+  ASSERT_FALSE (check_cpp_valid_utf8_p (\"\\xff\"));\n }\n \n /* Run all of the selftests within this file.  */\n@@ -4091,6 +4215,7 @@ input_cc_tests ()\n   test_line_offset_overflow ();\n \n   test_cpp_utf8 ();\n+  test_cpp_valid_utf8_p ();\n }\n \n } // namespace selftest"}, {"sha": "d1087b7a9e8bf24e2bcb9b926b5c2d260b28e01a", "filename": "gcc/input.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d495ea2b232f3eb50155d7c7362c09a744766746/gcc%2Finput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d495ea2b232f3eb50155d7c7362c09a744766746/gcc%2Finput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.h?ref=d495ea2b232f3eb50155d7c7362c09a744766746", "patch": "@@ -115,6 +115,7 @@ class char_span\n \n extern char_span location_get_source_line (const char *file_path, int line);\n extern char *get_source_text_between (location_t, location_t);\n+extern char_span get_source_file_content (const char *file_path);\n \n extern bool location_missing_trailing_newline (const char *file_path);\n "}, {"sha": "f0dcaa705ca6c44b5177dabc40a9790ea18629a3", "filename": "gcc/testsuite/c-c++-common/diagnostic-format-sarif-file-1.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d495ea2b232f3eb50155d7c7362c09a744766746/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d495ea2b232f3eb50155d7c7362c09a744766746/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-1.c?ref=d495ea2b232f3eb50155d7c7362c09a744766746", "patch": "@@ -4,6 +4,7 @@\n #warning message\n \n /* Verify that some JSON was written to a file with the expected name.  */\n+/* { dg-final { verify-sarif-file } } */\n \n /* We expect various properties.\n    The indentation here reflects the expected hierarchy, though these tests"}, {"sha": "02ee33f5265293a3563e4c66e389e719dc976f5e", "filename": "gcc/testsuite/c-c++-common/diagnostic-format-sarif-file-2.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d495ea2b232f3eb50155d7c7362c09a744766746/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d495ea2b232f3eb50155d7c7362c09a744766746/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-2.c?ref=d495ea2b232f3eb50155d7c7362c09a744766746", "patch": "@@ -10,6 +10,8 @@ int test (void)\n }\n \n /* \n+   { dg-final { verify-sarif-file } }\n+\n        { dg-final { scan-sarif-file \"\\\"level\\\": \\\"warning\\\"\" } }\n        { dg-final { scan-sarif-file \"\\\"ruleId\\\": \\\"-Wmisleading-indentation\\\"\" } }\n          { dg-final { scan-sarif-file \"\\\"text\\\": \\\"  if \" } }"}, {"sha": "80954711db286b1108f44457c714e79f30f057ee", "filename": "gcc/testsuite/c-c++-common/diagnostic-format-sarif-file-3.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d495ea2b232f3eb50155d7c7362c09a744766746/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d495ea2b232f3eb50155d7c7362c09a744766746/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-3.c?ref=d495ea2b232f3eb50155d7c7362c09a744766746", "patch": "@@ -10,6 +10,8 @@ int test (struct s *ptr)\n }\n \n /* \n+   { dg-final { verify-sarif-file } }\n+\n        { dg-final { scan-sarif-file \"\\\"level\\\": \\\"error\\\"\" } }\n \n        We expect a logical location for the error (within fn \"test\"):"}, {"sha": "bd13da714250e1fd49637d1585b21dfd672430fe", "filename": "gcc/testsuite/c-c++-common/diagnostic-format-sarif-file-4.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d495ea2b232f3eb50155d7c7362c09a744766746/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d495ea2b232f3eb50155d7c7362c09a744766746/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-4.c?ref=d495ea2b232f3eb50155d7c7362c09a744766746", "patch": "@@ -8,6 +8,8 @@ int test (void)\n }\n \n /* \n+   { dg-final { verify-sarif-file } }\n+\n        { dg-final { scan-sarif-file \"\\\"level\\\": \\\"error\\\"\" } }\n \n        We expect the region expressed in display columns:"}, {"sha": "283df75670d027b43bbf2cff8a9f49ce90c9196f", "filename": "gcc/testsuite/c-c++-common/diagnostic-format-sarif-file-Wbidi-chars.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d495ea2b232f3eb50155d7c7362c09a744766746/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-Wbidi-chars.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d495ea2b232f3eb50155d7c7362c09a744766746/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-Wbidi-chars.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-Wbidi-chars.c?ref=d495ea2b232f3eb50155d7c7362c09a744766746", "patch": "@@ -0,0 +1,23 @@\n+/* Adapted from Wbidi-chars-1.c */\n+\n+/* PR preprocessor/103026 */\n+/* { dg-do compile } */\n+/* { dg-options \"-fdiagnostics-format=sarif-file\" } */\n+\n+int main() {\n+    int isAdmin = 0;\n+    /*\u202e } \u2066if (isAdmin)\u2069 \u2066 begin admins only */\n+        __builtin_printf(\"You are an admin.\\n\");\n+    /* end admins only \u202e { \u2066*/\n+    return 0;\n+}\n+\n+/* Verify that we generate a valid UTF-8 .sarif file.\n+\n+     { dg-final { verify-sarif-file } }\n+\n+   Verify that we captured the expected warnings.\n+\n+     { dg-final { scan-sarif-file {\"text\": \"unpaired UTF-8 bidirectional control characters detected\"} } }\n+     { dg-final { scan-sarif-file {\"text\": \"unpaired UTF-8 bidirectional control characters detected\"} } }\n+*/"}, {"sha": "47f89232b1176d4d585e49e7872a9a37a5d7a485", "filename": "gcc/testsuite/c-c++-common/diagnostic-format-sarif-file-bad-utf8-pr109098-1.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d495ea2b232f3eb50155d7c7362c09a744766746/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-bad-utf8-pr109098-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d495ea2b232f3eb50155d7c7362c09a744766746/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-bad-utf8-pr109098-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-bad-utf8-pr109098-1.c?ref=d495ea2b232f3eb50155d7c7362c09a744766746", "patch": "@@ -0,0 +1,23 @@\n+/* Try to process this explicitly as UTF-8.\n+\n+   { dg-do preprocess }\n+   { dg-options \"-finput-charset=UTF-8 -Winvalid-utf8 -fdiagnostics-format=sarif-file\" } */\n+\n+/* This comment intentionally contains non-UTF-8 bytes:\n+ *   \ufffd\ufffd<unknown>\ufffd\ufffd may be used uninitialized\n+ */\n+\n+/* \n+   { dg-final { verify-sarif-file } }\n+\n+   Verify that we captured the expected warnings.\n+\n+     { dg-final { scan-sarif-file \"\\\"results\\\": \\\\\\[\" } }\n+       { dg-final { scan-sarif-file \"\\\"level\\\": \\\"warning\\\"\" } }\n+       { dg-final { scan-sarif-file \"\\\"ruleId\\\": \\\"-Winvalid-utf8\\\"\" } }\n+       { dg-final { scan-sarif-file \"\\\"message\\\": \" } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <80>\"} } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <98>\"} } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <80>\"} } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <99>\"} } }\n+*/"}, {"sha": "8395f1d86100f4b5e4ef7416b0108ce05730504d", "filename": "gcc/testsuite/c-c++-common/diagnostic-format-sarif-file-bad-utf8-pr109098-2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d495ea2b232f3eb50155d7c7362c09a744766746/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-bad-utf8-pr109098-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d495ea2b232f3eb50155d7c7362c09a744766746/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-bad-utf8-pr109098-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-bad-utf8-pr109098-2.c?ref=d495ea2b232f3eb50155d7c7362c09a744766746", "patch": "@@ -0,0 +1,16 @@\n+/* Try to process this explicitly as UTF-8.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-finput-charset=utf-8 -fdiagnostics-format=sarif-file\" } */\n+/* { dg-excess-errors \"The error is sent to the SARIF file, rather than stderr\" } */\n+\n+const char *section = \"\ufffd\"\n+\n+/* The above in quotes is byte 0xFE which is not valid in UTF-8.\n+   Verify that we can generate a valid UTF-8 .sarif file complaining\n+   about the missing semicolon above.  */\n+\n+/* { dg-final { verify-sarif-file } }\n+\n+     { dg-final { scan-sarif-file {\"text\": \"expected ',' or ';' at end of input\"} } }\n+*/"}, {"sha": "ead03a52fd6d7e390d716e4408f3d52c2e7215c6", "filename": "gcc/testsuite/c-c++-common/diagnostic-format-sarif-file-bad-utf8-pr109098-3.c", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d495ea2b232f3eb50155d7c7362c09a744766746/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-bad-utf8-pr109098-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d495ea2b232f3eb50155d7c7362c09a744766746/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-bad-utf8-pr109098-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-bad-utf8-pr109098-3.c?ref=d495ea2b232f3eb50155d7c7362c09a744766746", "patch": "@@ -0,0 +1,95 @@\n+/* Adapted from cpp/Winvalid-utf8-1.c\n+\n+   P2295R6 - Support for UTF-8 as a portable source file encoding\n+   This test intentionally contains various byte sequences which are not valid UTF-8\n+   { dg-do preprocess }\n+   { dg-options \"-finput-charset=UTF-8 -Winvalid-utf8 -fdiagnostics-format=sarif-file\" } */\n+\n+// a\u0080\u07ff\u0800\ud7ff\ue000\ud800\udc00\udbff\udfffa\n+// a\ufffda\n+// a\ufffda\n+// a\ufffda\n+// a\ufffda\n+// a\ufffda\n+// a\ufffda\n+// a\ufffda\n+// a\ufffda\n+// a\ufffda\n+// a\ufffda\n+// a\ufffda\n+// a\ufffda\n+// a\ufffda\n+// a\ufffda\n+// a\ufffda\n+// a\ufffda\n+// a\ufffd\n+/* a\u0080\u07ff\u0800\ud7ff\ue000\ud800\udc00\udbff\udfffa */\n+/* a\ufffda */\n+/* a\ufffda */\n+/* a\ufffda */\n+/* a\ufffda */\n+/* a\ufffda */\n+/* a\ufffda */\n+/* a\ufffda */\n+/* a\ufffda */\n+/* a\ufffda */\n+/* a\ufffda */\n+/* a\ufffda */\n+/* a\ufffda */\n+/* a\ufffda */\n+/* a\ufffda */\n+/* a\ufffda */\n+/* a\ufffda */\n+/* a\ufffda */\n+\n+\n+\n+/* Verify that we generate a valid UTF-8 .sarif file.\n+\n+     { dg-final { verify-sarif-file } }\n+\n+   Verify that we captured the expected warnings.\n+\n+     { dg-final { scan-sarif-file \"\\\"results\\\": \\\\\\[\" } }\n+       { dg-final { scan-sarif-file \"\\\"level\\\": \\\"warning\\\"\" } }\n+       { dg-final { scan-sarif-file \"\\\"ruleId\\\": \\\"-Winvalid-utf8\\\"\" } }\n+       { dg-final { scan-sarif-file \"\\\"message\\\": \" } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <80>\"} } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <bf>\"} } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <c0>\"} } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <c1>\"} } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <f5>\"} } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <ff>\"} } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <c2>\"} } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <e0>\"} } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <e0><80><bf>\"} } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <e0><9f><80>\"} } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <e0><bf>\"} } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <ec><80>\"} } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <ed><a0><80>\"} } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <f0><80><80><80>\"} } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <f0><8f><bf><bf>\"} } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <f4><90><80><80>\"} } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <fd><bf><bf><bf>\"} } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <bf>\"} } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <bf>\"} } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <80>\"} } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <bf>\"} } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <c0>\"} } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <c1>\"} } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <f5>\"} } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <ff>\"} } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <c2>\"} } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <e0>\"} } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <e0><80><bf>\"} } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <e0><9f><80>\"} } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <e0><bf>\"} } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <ec><80>\"} } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <ed><a0><80>\"} } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <f0><80><80><80>\"} } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <f0><8f><bf><bf>\"} } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <f4><90><80><80>\"} } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <fd><bf><bf><bf>\"} } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <bf>\"} } }\n+         { dg-final { scan-sarif-file {\"text\": \"invalid UTF-8 character <bf>\"} } }\n+*/"}, {"sha": "a189274692e319f7d6d7b5361f879a91721abfb0", "filename": "gcc/testsuite/c-c++-common/diagnostic-format-sarif-file-valid-CP850.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d495ea2b232f3eb50155d7c7362c09a744766746/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-valid-CP850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d495ea2b232f3eb50155d7c7362c09a744766746/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-valid-CP850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-valid-CP850.c?ref=d495ea2b232f3eb50155d7c7362c09a744766746", "patch": "@@ -0,0 +1,22 @@\n+/* Adapted from gcc.dg/diagnostic-input-charset-1.c  */\n+/* { dg-do compile } */\n+/* { dg-require-iconv \"CP850\" } */\n+/* { dg-options \"-finput-charset=CP850 -fdiagnostics-format=sarif-file\" } */\n+/* { dg-excess-errors \"The error is sent to the SARIF file, rather than stderr\" } */\n+\n+/* Test that diagnostics are converted to UTF-8; this file is encoded in\n+   CP850.\n+\n+   The non-ASCII byte here is 0xf5, which when decoded as CP850\n+   is U+00A7 SECTION SIGN  */\n+const char *section = \"\ufffd\"\n+\n+/* \n+   { dg-final { verify-sarif-file } }\n+\n+   Verify that we captured the expected warning, and converted the snippet to\n+   UTF-8 on output.\n+\n+   { dg-final { scan-sarif-file {\"text\": \"expected ',' or ';' at end of input\"} } }\n+   { dg-final { scan-sarif-file {\"text\": \"const char .section = \\\\\"\\u00a7\\\\\"} } }\n+*/"}, {"sha": "3b773a9a84c857e35f34300bd7c17abd3cd1b126", "filename": "gcc/testsuite/gcc.dg/plugin/crash-test-ice-sarif.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d495ea2b232f3eb50155d7c7362c09a744766746/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fcrash-test-ice-sarif.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d495ea2b232f3eb50155d7c7362c09a744766746/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fcrash-test-ice-sarif.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fcrash-test-ice-sarif.c?ref=d495ea2b232f3eb50155d7c7362c09a744766746", "patch": "@@ -10,6 +10,7 @@ void test_inject_ice (void)\n }\n \n /* Verify that some JSON was written to a file with the expected name.  */\n+/* { dg-final { verify-sarif-file } } */\n \n /* We expect various properties.\n    The indentation here reflects the expected hierarchy, though these tests"}, {"sha": "57caa20155fa4730dac72a299b13e0f77b8350e9", "filename": "gcc/testsuite/gcc.dg/plugin/crash-test-write-though-null-sarif.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d495ea2b232f3eb50155d7c7362c09a744766746/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fcrash-test-write-though-null-sarif.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d495ea2b232f3eb50155d7c7362c09a744766746/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fcrash-test-write-though-null-sarif.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fcrash-test-write-though-null-sarif.c?ref=d495ea2b232f3eb50155d7c7362c09a744766746", "patch": "@@ -10,6 +10,7 @@ void test_inject_write_through_null (void)\n }\n \n /* Verify that some JSON was written to a file with the expected name.  */\n+/* { dg-final { verify-sarif-file } } */\n \n /* We expect various properties.\n    The indentation here reflects the expected hierarchy, though these tests"}, {"sha": "27851d1b9f78c64aea3e3e1d828d44a01244b046", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic-test-paths-5.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d495ea2b232f3eb50155d7c7362c09a744766746/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-paths-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d495ea2b232f3eb50155d7c7362c09a744766746/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-paths-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-paths-5.c?ref=d495ea2b232f3eb50155d7c7362c09a744766746", "patch": "@@ -34,6 +34,8 @@ make_a_list_of_random_ints_badly(PyObject *self,\n }\n \n /* \n+   { dg-final { verify-sarif-file } }\n+\n    { dg-final { scan-sarif-file \"\\\"tool\\\": \" } }\n \n      We expect info about the plugin:"}, {"sha": "83e76c31de7df0bb711c88f62f03ac16869b3a43", "filename": "gcc/testsuite/lib/scansarif.exp", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d495ea2b232f3eb50155d7c7362c09a744766746/gcc%2Ftestsuite%2Flib%2Fscansarif.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d495ea2b232f3eb50155d7c7362c09a744766746/gcc%2Ftestsuite%2Flib%2Fscansarif.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fscansarif.exp?ref=d495ea2b232f3eb50155d7c7362c09a744766746", "patch": "@@ -51,3 +51,32 @@ proc scan-sarif-file-not { args } {\n \n     dg-scan \"scan-sarif-file-not\" 0 $testcase $output_file $args\n }\n+\n+# Perform validity checks on the .sarif file produced by the compiler.\n+#\n+# Assuming python3 is available, use verify-sarif-file.py to check\n+# that the .sarif file is UTF-8 encoded and is parseable as JSON.\n+\n+proc verify-sarif-file { args } {\n+    global srcdir subdir\n+\n+    set testcase [testname-for-summary]\n+    set filename [lindex $testcase 0]\n+    set output_file \"[file tail $filename].sarif\"\n+\n+    if { ![check_effective_target_recent_python3] } {\n+\tunsupported \"$testcase verify-sarif-file: python3 is missing\"\n+\treturn\n+    }\n+\n+    # Verify that the file is correctly encoded and is parseable as JSON.\n+    set script_name $srcdir/lib/verify-sarif-file.py\n+    set what \"$testcase (test .sarif output for UTF-8-encoded parseable JSON)\"\n+    if [catch {exec python3 $script_name $output_file} res ] {\n+\tverbose \"verify-sarif-file: res: $res\" 2\n+\tfail \"$what\"\n+\treturn\n+    } else {\n+\tpass \"$what\"\n+    }\n+}"}, {"sha": "f1833f3016e85430cb0cc3eb058c848c006b2a19", "filename": "gcc/testsuite/lib/verify-sarif-file.py", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d495ea2b232f3eb50155d7c7362c09a744766746/gcc%2Ftestsuite%2Flib%2Fverify-sarif-file.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d495ea2b232f3eb50155d7c7362c09a744766746/gcc%2Ftestsuite%2Flib%2Fverify-sarif-file.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fverify-sarif-file.py?ref=d495ea2b232f3eb50155d7c7362c09a744766746", "patch": "@@ -0,0 +1,11 @@\n+# Verify that ARGV[1] is UTF-8 encoded and parseable as JSON\n+# For use by the verify-sarif-file directive\n+\n+import json\n+import sys\n+\n+sys.tracebacklimit = 0\n+\n+fname = sys.argv[1]\n+with open(fname, encoding=\"utf-8\") as f:\n+    json.load(f)"}, {"sha": "d7f323b2cd526f3a42b5007f2037432ebadef585", "filename": "libcpp/charset.cc", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d495ea2b232f3eb50155d7c7362c09a744766746/libcpp%2Fcharset.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d495ea2b232f3eb50155d7c7362c09a744766746/libcpp%2Fcharset.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fcharset.cc?ref=d495ea2b232f3eb50155d7c7362c09a744766746", "patch": "@@ -1864,6 +1864,33 @@ _cpp_valid_utf8 (cpp_reader *pfile,\n   return true;\n }\n \n+/* Return true iff BUFFER of size NUM_BYTES is validly-encoded UTF-8.  */\n+\n+extern bool\n+cpp_valid_utf8_p (const char *buffer, size_t num_bytes)\n+{\n+  const uchar *iter = (const uchar *)buffer;\n+  size_t bytesleft = num_bytes;\n+  while (bytesleft > 0)\n+    {\n+      /* one_utf8_to_cppchar implements 5-byte and 6 byte sequences as per\n+\t RFC 2279, but this has been superceded by RFC 3629, which\n+\t restricts UTF-8 to 1-byte through 4-byte sequences, and\n+\t states \"the octet values C0, C1, F5 to FF never appear\".\n+\n+\t Reject such values.  */\n+      if (*iter >= 0xf4)\n+\treturn false;\n+\n+      cppchar_t cp;\n+      int err = one_utf8_to_cppchar (&iter, &bytesleft, &cp);\n+      if (err)\n+\treturn false;\n+    }\n+  /* No problems encountered.  */\n+  return true;\n+}\n+\n /* Subroutine of convert_hex and convert_oct.  N is the representation\n    in the execution character set of a numeric escape; write it into the\n    string buffer TBUF and update the end-of-string pointer therein.  WIDE"}, {"sha": "a6f0abd894c2af9fa3bfb4e3f6cfec70dad652b0", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d495ea2b232f3eb50155d7c7362c09a744766746/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d495ea2b232f3eb50155d7c7362c09a744766746/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=d495ea2b232f3eb50155d7c7362c09a744766746", "patch": "@@ -1600,5 +1600,6 @@ int cpp_wcwidth (cppchar_t c);\n \n bool cpp_input_conversion_is_trivial (const char *input_charset);\n int cpp_check_utf8_bom (const char *data, size_t data_length);\n+bool cpp_valid_utf8_p (const char *data, size_t num_bytes);\n \n #endif /* ! LIBCPP_CPPLIB_H */"}]}