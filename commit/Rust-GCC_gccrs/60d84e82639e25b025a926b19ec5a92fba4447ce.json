{"sha": "60d84e82639e25b025a926b19ec5a92fba4447ce", "node_id": "C_kwDOANBUbNoAKDYwZDg0ZTgyNjM5ZTI1YjAyNWE5MjZiMTllYzVhOTJmYmE0NDQ3Y2U", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2022-08-10T19:00:49Z"}, "committer": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2022-08-25T21:54:13Z"}, "message": "c: Implement C23 nullptr (N3042)\n\nThis patch implements the C23 nullptr literal:\n<https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3042.htm> (with\nwording fixes from N3047), which is intended to replace the problematic\ndefinition of NULL which might be either of integer type or void*.\n\nSince C++ has had nullptr for over a decade now, it was relatively easy\nto just move the built-in node definitions from the C++ FE to the C/C++\ncommon code.  Also, our DWARF emitter already handles NULLPTR_TYPE by\nemitting DW_TAG_unspecified_type.  However, I had to handle a lot of\ncontexts such as ?:, comparison, conversion, etc.\n\nThere are some minor differences, e.g. in C you can do\n\n  bool b = nullptr;\n\nbut in C++ you have to use direct-initialization:\n\n  bool b{nullptr};\n\nAnd I think that\n\n  nullptr_t n = 0;\n\nis only valid in C++.\n\nOf course, C doesn't have to handle mangling, RTTI, substitution,\noverloading, ...\n\nThis patch also defines nullptr_t in <stddef.h>.  However, it does not\ndefine __STDC_VERSION_STDDEF_H__ yet, because we don't know yet what value\nit should be defined to.\n\ngcc/c-family/ChangeLog:\n\n\t* c-common.cc (c_common_reswords): Enable nullptr in C2X.\n\t(c_common_nodes_and_builtins): Create the built-in node for nullptr.\n\t* c-common.h (enum c_tree_index): Add CTI_NULLPTR, CTI_NULLPTR_TYPE.\n\t(struct c_common_resword): Resize the disable member.\n\t(D_C2X): Add.\n\t(nullptr_node): Define.\n\t(nullptr_type_node): Define.\n\t(NULLPTR_TYPE_P): Define.\n\t* c-pretty-print.cc (c_pretty_printer::simple_type_specifier): Handle\n\tNULLPTR_TYPE.\n\t(c_pretty_printer::direct_abstract_declarator): Likewise.\n\t(c_pretty_printer::constant): Likewise.\n\ngcc/c/ChangeLog:\n\n\t* c-convert.cc (c_convert) <case POINTER_TYPE>: Handle NULLPTR_TYPE.\n\tGive a better diagnostic when converting to nullptr_t.\n\t* c-decl.cc (c_init_decl_processing): Perform C-specific nullptr\n\tinitialization.\n\t* c-parser.cc (c_parse_init): Maybe OR D_C2X into mask.\n\t(c_parser_postfix_expression): Handle RID_NULLPTR.\n\t* c-typeck.cc (null_pointer_constant_p): Return true when expr is\n\tnullptr_node.\n\t(build_unary_op) <case TRUTH_NOT_EXPR>: Handle NULLPTR_TYPE.\n\t(build_conditional_expr): Handle the case when the second/third operand\n\tis NULLPTR_TYPE and third/second operand is POINTER_TYPE.\n\t(convert_for_assignment): Handle converting an expression of type\n\tnullptr_t to pointer/bool.\n\t(build_binary_op) <case TRUTH_XOR_EXPR>: Handle NULLPTR_TYPE.\n\t<case EQ_EXPR>: Handle comparing operands of type nullptr_t.\n\ngcc/cp/ChangeLog:\n\n\t* cp-tree.h (enum cp_tree_index): Remove CTI_NULLPTR, CTI_NULLPTR_TYPE.\n\tMove it to c_tree_index.\n\t(nullptr_node): No longer define here.\n\t(nullptr_type_node): Likewise.\n\t(NULLPTR_TYPE_P): Likewise.\n\t* decl.cc (cxx_init_decl_processing): Only keep C++-specific nullptr\n\tinitialization; move the shared code to c_common_nodes_and_builtins.\n\ngcc/ChangeLog:\n\n\t* ginclude/stddef.h: Define nullptr_t.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/c11-nullptr-1.c: New test.\n\t* gcc.dg/c17-nullptr-1.c: New test.\n\t* gcc.dg/c17-nullptr-2.c: New test.\n\t* gcc.dg/c2x-nullptr-1.c: New test.\n\t* gcc.dg/c2x-nullptr-2.c: New test.\n\t* gcc.dg/c2x-nullptr-3.c: New test.\n\t* gcc.dg/c2x-nullptr-4.c: New test.\n\t* gcc.dg/c2x-nullptr-5.c: New test.", "tree": {"sha": "7bbbeeb4ff4c16132b02c74f95a936d80cd09779", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7bbbeeb4ff4c16132b02c74f95a936d80cd09779"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/60d84e82639e25b025a926b19ec5a92fba4447ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60d84e82639e25b025a926b19ec5a92fba4447ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60d84e82639e25b025a926b19ec5a92fba4447ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60d84e82639e25b025a926b19ec5a92fba4447ce/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14cfa01755a66afbae2539f8b5796c960ddcecc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14cfa01755a66afbae2539f8b5796c960ddcecc6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14cfa01755a66afbae2539f8b5796c960ddcecc6"}], "stats": {"total": 628, "additions": 586, "deletions": 42}, "files": [{"sha": "82ebe7c45024b2dd4ee31327dca4f31f6072f1c8", "filename": "gcc/c-family/c-common.cc", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60d84e82639e25b025a926b19ec5a92fba4447ce/gcc%2Fc-family%2Fc-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60d84e82639e25b025a926b19ec5a92fba4447ce/gcc%2Fc-family%2Fc-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.cc?ref=60d84e82639e25b025a926b19ec5a92fba4447ce", "patch": "@@ -324,8 +324,10 @@ static bool nonnull_check_p (tree, unsigned HOST_WIDE_INT);\n    if they match the mask.\n \n    Masks for languages:\n-   C --std=c89: D_C99 | D_CXXONLY | D_OBJC | D_CXX_OBJC\n-   C --std=c99: D_CXXONLY | D_OBJC\n+   C --std=c89: D_C99 | D_C2X | D_CXXONLY | D_OBJC | D_CXX_OBJC\n+   C --std=c99: D_C2X | D_CXXONLY | D_OBJC\n+   C --std=c17: D_C2X | D_CXXONLY | D_OBJC\n+   C --std=c2x: D_CXXONLY | D_OBJC\n    ObjC is like C except that D_OBJC and D_CXX_OBJC are not set\n    C++ --std=c++98: D_CONLY | D_CXX11 | D_CXX20 | D_OBJC\n    C++ --std=c++11: D_CONLY | D_CXX20 | D_OBJC\n@@ -500,7 +502,7 @@ const struct c_common_resword c_common_reswords[] =\n   { \"namespace\",\tRID_NAMESPACE,\tD_CXXONLY | D_CXXWARN },\n   { \"new\",\t\tRID_NEW,\tD_CXXONLY | D_CXXWARN },\n   { \"noexcept\",\t\tRID_NOEXCEPT,\tD_CXXONLY | D_CXX11 | D_CXXWARN },\n-  { \"nullptr\",\t\tRID_NULLPTR,\tD_CXXONLY | D_CXX11 | D_CXXWARN },\n+  { \"nullptr\",\t\tRID_NULLPTR,\tD_C2X | D_CXX11 | D_CXXWARN },\n   { \"operator\",\t\tRID_OPERATOR,\tD_CXXONLY | D_CXXWARN },\n   { \"private\",\t\tRID_PRIVATE,\tD_CXX_OBJC | D_CXXWARN },\n   { \"protected\",\tRID_PROTECTED,\tD_CXX_OBJC | D_CXXWARN },\n@@ -4723,6 +4725,18 @@ c_common_nodes_and_builtins (void)\n   null_node = make_int_cst (1, 1);\n   TREE_TYPE (null_node) = c_common_type_for_size (POINTER_SIZE, 0);\n \n+  /* Create the built-in nullptr node.  This part of its initialization is\n+     common to C and C++.  The front ends can further adjust its definition\n+     in {c,cxx}_init_decl_processing.  In particular, we aren't setting the\n+     alignment here for C++ backward ABI bug compatibility.  */\n+  nullptr_type_node = make_node (NULLPTR_TYPE);\n+  TYPE_SIZE (nullptr_type_node) = bitsize_int (GET_MODE_BITSIZE (ptr_mode));\n+  TYPE_SIZE_UNIT (nullptr_type_node) = size_int (GET_MODE_SIZE (ptr_mode));\n+  TYPE_UNSIGNED (nullptr_type_node) = 1;\n+  TYPE_PRECISION (nullptr_type_node) = GET_MODE_BITSIZE (ptr_mode);\n+  SET_TYPE_MODE (nullptr_type_node, ptr_mode);\n+  nullptr_node = build_int_cst (nullptr_type_node, 0);\n+\n   /* Since builtin_types isn't gc'ed, don't export these nodes.  */\n   memset (builtin_types, 0, sizeof (builtin_types));\n }"}, {"sha": "e7b0fd1309d337868fffa1bd51d833870aa42cb6", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60d84e82639e25b025a926b19ec5a92fba4447ce/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60d84e82639e25b025a926b19ec5a92fba4447ce/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=60d84e82639e25b025a926b19ec5a92fba4447ce", "patch": "@@ -375,6 +375,8 @@ enum c_tree_index\n     CTI_DEFAULT_FUNCTION_TYPE,\n \n     CTI_NULL,\n+    CTI_NULLPTR,\n+    CTI_NULLPTR_TYPE,\n \n     /* These are not types, but we have to look them up all the time.  */\n     CTI_FUNCTION_NAME_DECL,\n@@ -409,7 +411,7 @@ struct c_common_resword\n {\n   const char *const word;\n   ENUM_BITFIELD(rid) const rid : 16;\n-  const unsigned int disable   : 16;\n+  const unsigned int disable   : 32;\n };\n \n /* Mode used to build pointers (VOIDmode means ptr_mode).  */\n@@ -447,19 +449,20 @@ extern machine_mode c_default_pointer_mode;\n #define D_CONLY\t\t0x0001\t/* C only (not in C++).  */\n #define D_CXXONLY\t0x0002\t/* C++ only (not in C).  */\n #define D_C99\t\t0x0004\t/* In C, C99 only.  */\n-#define D_CXX11         0x0008\t/* In C++, C++11 only.  */\n-#define D_EXT\t\t0x0010\t/* GCC extension.  */\n-#define D_EXT89\t\t0x0020\t/* GCC extension incorporated in C99.  */\n-#define D_ASM\t\t0x0040\t/* Disabled by -fno-asm.  */\n-#define D_OBJC\t\t0x0080\t/* In Objective C and neither C nor C++.  */\n-#define D_CXX_OBJC\t0x0100\t/* In Objective C, and C++, but not C.  */\n-#define D_CXXWARN\t0x0200\t/* In C warn with -Wcxx-compat.  */\n-#define D_CXX_CONCEPTS  0x0400\t/* In C++, only with concepts.  */\n-#define D_TRANSMEM\t0X0800\t/* C++ transactional memory TS.  */\n-#define D_CXX_CHAR8_T\t0X1000\t/* In C++, only with -fchar8_t.  */\n-#define D_CXX20\t\t0x2000  /* In C++, C++20 only.  */\n-#define D_CXX_COROUTINES 0x4000  /* In C++, only with coroutines.  */\n-#define D_CXX_MODULES\t0x8000  /* In C++, only with modules.  */\n+#define D_C2X\t\t0x0008\t/* In C, C2X only.  */\n+#define D_CXX11         0x0010\t/* In C++, C++11 only.  */\n+#define D_EXT\t\t0x0020\t/* GCC extension.  */\n+#define D_EXT89\t\t0x0040\t/* GCC extension incorporated in C99.  */\n+#define D_ASM\t\t0x0080\t/* Disabled by -fno-asm.  */\n+#define D_OBJC\t\t0x0100\t/* In Objective C and neither C nor C++.  */\n+#define D_CXX_OBJC\t0x0200\t/* In Objective C, and C++, but not C.  */\n+#define D_CXXWARN\t0x0400\t/* In C warn with -Wcxx-compat.  */\n+#define D_CXX_CONCEPTS  0x0800\t/* In C++, only with concepts.  */\n+#define D_TRANSMEM\t0x1000\t/* C++ transactional memory TS.  */\n+#define D_CXX_CHAR8_T\t0x2000\t/* In C++, only with -fchar8_t.  */\n+#define D_CXX20\t\t0x4000  /* In C++, C++20 only.  */\n+#define D_CXX_COROUTINES 0x8000  /* In C++, only with coroutines.  */\n+#define D_CXX_MODULES\t0x10000  /* In C++, only with modules.  */\n \n #define D_CXX_CONCEPTS_FLAGS D_CXXONLY | D_CXX_CONCEPTS\n #define D_CXX_CHAR8_T_FLAGS D_CXXONLY | D_CXX_CHAR8_T\n@@ -534,6 +537,9 @@ extern const unsigned int num_c_common_reswords;\n \n /* The node for C++ `__null'.  */\n #define null_node                       c_global_trees[CTI_NULL]\n+/* The nodes for `nullptr'.  */\n+#define nullptr_node                    c_global_trees[CTI_NULLPTR]\n+#define nullptr_type_node               c_global_trees[CTI_NULLPTR_TYPE]\n \n extern GTY(()) tree c_global_trees[CTI_MAX];\n \n@@ -1009,6 +1015,9 @@ extern void c_parse_final_cleanups (void);\n #define DECL_UNNAMED_BIT_FIELD(NODE) \\\n   (DECL_C_BIT_FIELD (NODE) && !DECL_NAME (NODE))\n \n+/* True iff TYPE is cv decltype(nullptr).  */\n+#define NULLPTR_TYPE_P(TYPE) (TREE_CODE (TYPE) == NULLPTR_TYPE)\n+\n extern tree do_case (location_t, tree, tree);\n extern tree build_stmt (location_t, enum tree_code, ...);\n extern tree build_real_imag_expr (location_t, enum tree_code, tree);"}, {"sha": "efa1768f4d6255719183c4cf028ea4d6d12fda3f", "filename": "gcc/c-family/c-pretty-print.cc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60d84e82639e25b025a926b19ec5a92fba4447ce/gcc%2Fc-family%2Fc-pretty-print.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60d84e82639e25b025a926b19ec5a92fba4447ce/gcc%2Fc-family%2Fc-pretty-print.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pretty-print.cc?ref=60d84e82639e25b025a926b19ec5a92fba4447ce", "patch": "@@ -321,6 +321,7 @@ pp_c_pointer (c_pretty_printer *pp, tree t)\n       _Bool                          -- C99\n       _Complex                       -- C99\n       _Imaginary                     -- C99\n+      nullptr_t                      -- C23\n       struct-or-union-specifier\n       enum-specifier\n       typedef-name.\n@@ -424,6 +425,9 @@ c_pretty_printer::simple_type_specifier (tree t)\n       else\n \ttranslate_string (\"<anonymous>\");\n       break;\n+    case NULLPTR_TYPE:\n+      pp_c_ws_string (this, \"nullptr_t\");\n+      break;\n \n     default:\n       pp_unsupported_tree (this, t);\n@@ -678,6 +682,7 @@ c_pretty_printer::direct_abstract_declarator (tree t)\n     case COMPLEX_TYPE:\n     case TYPE_DECL:\n     case ERROR_MARK:\n+    case NULLPTR_TYPE:\n       break;\n \n     default:\n@@ -1219,6 +1224,8 @@ c_pretty_printer::constant (tree e)\n \t  pp_c_character_constant (this, e);\n \telse if (TREE_CODE (type) == ENUMERAL_TYPE)\n \t  pp_c_enumeration_constant (this, e);\n+\telse if (NULLPTR_TYPE_P (type))\n+\t  pp_string (this, \"nullptr\");\n \telse\n \t  pp_c_integer_constant (this, e);\n       }"}, {"sha": "6e7491339d427d72fb8eb3630894dd041d4fbcef", "filename": "gcc/c/c-convert.cc", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60d84e82639e25b025a926b19ec5a92fba4447ce/gcc%2Fc%2Fc-convert.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60d84e82639e25b025a926b19ec5a92fba4447ce/gcc%2Fc%2Fc-convert.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-convert.cc?ref=60d84e82639e25b025a926b19ec5a92fba4447ce", "patch": "@@ -133,6 +133,20 @@ c_convert (tree type, tree expr, bool init_const)\n \t(loc, type, c_objc_common_truthvalue_conversion (input_location, expr));\n \n     case POINTER_TYPE:\n+      /* The type nullptr_t may be converted to a pointer type.  The result is\n+\t a null pointer value.  */\n+      if (NULLPTR_TYPE_P (TREE_TYPE (e)))\n+\t{\n+\t  /* To make sure that (void *)nullptr is not a null pointer constant,\n+\t     build_c_cast will create an additional NOP_EXPR around the result\n+\t     of this conversion.  */\n+\t  if (TREE_SIDE_EFFECTS (e))\n+\t    ret = build2 (COMPOUND_EXPR, type, e, build_int_cst (type, 0));\n+\t  else\n+\t    ret = build_int_cst (type, 0);\n+\t  goto maybe_fold;\n+\t}\n+      gcc_fallthrough ();\n     case REFERENCE_TYPE:\n       ret = convert_to_pointer (type, e);\n       goto maybe_fold;\n@@ -180,7 +194,16 @@ c_convert (tree type, tree expr, bool init_const)\n       return ret;\n     }\n \n-  error (\"conversion to non-scalar type requested\");\n+  /* If we are converting to nullptr_t, don't say \"non-scalar type\" because\n+     the nullptr_t type is a scalar type.  Only nullptr_t shall be converted\n+     to nullptr_t.  */\n+  if (code == NULLPTR_TYPE)\n+    {\n+      error (\"conversion from %qT to %qT\", TREE_TYPE (e), type);\n+      inform (input_location, \"only %qT can be converted to %qT\", type, type);\n+    }\n+  else\n+    error (\"conversion to non-scalar type requested\");\n   return error_mark_node;\n }\n "}, {"sha": "804314dd0f22ddaf79ccdf6b6cbec03910030774", "filename": "gcc/c/c-decl.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60d84e82639e25b025a926b19ec5a92fba4447ce/gcc%2Fc%2Fc-decl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60d84e82639e25b025a926b19ec5a92fba4447ce/gcc%2Fc%2Fc-decl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.cc?ref=60d84e82639e25b025a926b19ec5a92fba4447ce", "patch": "@@ -4531,6 +4531,12 @@ c_init_decl_processing (void)\n   pushdecl (build_decl (UNKNOWN_LOCATION, TYPE_DECL, get_identifier (\"_Bool\"),\n \t\t\tboolean_type_node));\n \n+  /* C-specific nullptr initialization.  */\n+  record_builtin_type (RID_MAX, \"nullptr_t\", nullptr_type_node);\n+  /* The size and alignment of nullptr_t is the same as for a pointer to\n+     character type.  */\n+  SET_TYPE_ALIGN (nullptr_type_node, GET_MODE_ALIGNMENT (ptr_mode));\n+\n   input_location = save_loc;\n \n   make_fname_decl = c_make_fname_decl;"}, {"sha": "0fe2ff55040d08275a651f15860689b93f2cac87", "filename": "gcc/c/c-parser.cc", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60d84e82639e25b025a926b19ec5a92fba4447ce/gcc%2Fc%2Fc-parser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60d84e82639e25b025a926b19ec5a92fba4447ce/gcc%2Fc%2Fc-parser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.cc?ref=60d84e82639e25b025a926b19ec5a92fba4447ce", "patch": "@@ -119,6 +119,8 @@ c_parse_init (void)\n   mask |= D_CXXONLY;\n   if (!flag_isoc99)\n     mask |= D_C99;\n+  if (!flag_isoc2x)\n+    mask |= D_C2X;\n   if (flag_no_asm)\n     {\n       mask |= D_ASM | D_EXT;\n@@ -10253,6 +10255,14 @@ c_parser_postfix_expression (c_parser *parser)\n \t\t\t \"%<depend%> clause\");\n \t  expr.set_error ();\n \t  break;\n+\t/* C23 'nullptr' literal.  */\n+\tcase RID_NULLPTR:\n+\t  c_parser_consume_token (parser);\n+\t  expr.value = nullptr_node;\n+\t  set_c_expr_source_range (&expr, tok_range);\n+\t  pedwarn_c11 (loc, OPT_Wpedantic,\n+\t\t       \"ISO C does not support %qs before C2X\", \"nullptr\");\n+\t  break;\n \tdefault:\n \t  c_parser_error (parser, \"expected expression\");\n \t  expr.set_error ();"}, {"sha": "f3d83d175e23756402a798d01564c886183ad710", "filename": "gcc/c/c-typeck.cc", "status": "modified", "additions": 48, "deletions": 9, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60d84e82639e25b025a926b19ec5a92fba4447ce/gcc%2Fc%2Fc-typeck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60d84e82639e25b025a926b19ec5a92fba4447ce/gcc%2Fc%2Fc-typeck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.cc?ref=60d84e82639e25b025a926b19ec5a92fba4447ce", "patch": "@@ -133,6 +133,13 @@ null_pointer_constant_p (const_tree expr)\n   /* This should really operate on c_expr structures, but they aren't\n      yet available everywhere required.  */\n   tree type = TREE_TYPE (expr);\n+\n+  /* An integer constant expression with the value 0, such an expression\n+     cast to type void*, or the predefined constant nullptr, are a null\n+     pointer constant.  */\n+  if (expr == nullptr_node)\n+    return true;\n+\n   return (TREE_CODE (expr) == INTEGER_CST\n \t  && !TREE_OVERFLOW (expr)\n \t  && integer_zerop (expr)\n@@ -4575,7 +4582,7 @@ build_unary_op (location_t location, enum tree_code code, tree xarg,\n     case TRUTH_NOT_EXPR:\n       if (typecode != INTEGER_TYPE && typecode != FIXED_POINT_TYPE\n \t  && typecode != REAL_TYPE && typecode != POINTER_TYPE\n-\t  && typecode != COMPLEX_TYPE)\n+\t  && typecode != COMPLEX_TYPE && typecode != NULLPTR_TYPE)\n \t{\n \t  error_at (location,\n \t\t    \"wrong type argument to unary exclamation mark\");\n@@ -5515,6 +5522,13 @@ build_conditional_expr (location_t colon_loc, tree ifexp, bool ifexp_bcp,\n \t}\n       result_type = type2;\n     }\n+  /* 6.5.15: \"if one is a null pointer constant (other than a pointer) or has\n+     type nullptr_t and the other is a pointer, the result type is the pointer\n+     type.\"  */\n+  else if (code1 == NULLPTR_TYPE && code2 == POINTER_TYPE)\n+    result_type = type2;\n+  else if (code1 == POINTER_TYPE && code2 == NULLPTR_TYPE)\n+    result_type = type1;\n \n   if (!result_type)\n     {\n@@ -7613,12 +7627,13 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n \terror_at (location, msg);\n       return error_mark_node;\n     }\n-  else if (codel == POINTER_TYPE && coder == INTEGER_TYPE)\n+  else if (codel == POINTER_TYPE\n+\t   && (coder == INTEGER_TYPE || coder == NULLPTR_TYPE))\n     {\n-      /* An explicit constant 0 can convert to a pointer,\n-\t or one that results from arithmetic, even including\n-\t a cast to integer type.  */\n-      if (!null_pointer_constant)\n+      /* An explicit constant 0 or type nullptr_t can convert to a pointer,\n+\t or one that results from arithmetic, even including a cast to\n+\t integer type.  */\n+      if (!null_pointer_constant && coder != NULLPTR_TYPE)\n \tswitch (errtype)\n \t  {\n \t  case ic_argpass:\n@@ -7691,7 +7706,10 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n \n       return convert (type, rhs);\n     }\n-  else if (codel == BOOLEAN_TYPE && coder == POINTER_TYPE)\n+  else if (codel == BOOLEAN_TYPE\n+\t   /* The type nullptr_t may be converted to bool.  The\n+\t      result is false.  */\n+\t   && (coder == POINTER_TYPE || coder == NULLPTR_TYPE))\n     {\n       tree ret;\n       bool save = in_late_binary_op;\n@@ -12112,10 +12130,10 @@ build_binary_op (location_t location, enum tree_code code,\n     case TRUTH_XOR_EXPR:\n       if ((code0 == INTEGER_TYPE || code0 == POINTER_TYPE\n \t   || code0 == REAL_TYPE || code0 == COMPLEX_TYPE\n-\t   || code0 == FIXED_POINT_TYPE)\n+\t   || code0 == FIXED_POINT_TYPE || code0 == NULLPTR_TYPE)\n \t  && (code1 == INTEGER_TYPE || code1 == POINTER_TYPE\n \t      || code1 == REAL_TYPE || code1 == COMPLEX_TYPE\n-\t      || code1 == FIXED_POINT_TYPE))\n+\t      || code1 == FIXED_POINT_TYPE || code1 ==  NULLPTR_TYPE))\n \t{\n \t  /* Result of these operations is always an int,\n \t     but that does not mean the operands should be\n@@ -12423,6 +12441,27 @@ build_binary_op (location_t location, enum tree_code code,\n \t  result_type = type1;\n \t  pedwarn (location, 0, \"comparison between pointer and integer\");\n \t}\n+      /* 6.5.9: One of the following shall hold:\n+\t -- both operands have type nullptr_t;  */\n+      else if (code0 == NULLPTR_TYPE && code1 == NULLPTR_TYPE)\n+\t{\n+\t  result_type = nullptr_type_node;\n+\t  /* No need to convert the operands to result_type later.  */\n+\t  converted = 1;\n+\t}\n+    /* -- one operand has type nullptr_t and the other is a null pointer\n+       constant.  We will have to convert the former to the type of the\n+       latter, because during gimplification we can't have mismatching\n+       comparison operand type.  We convert from nullptr_t to the other\n+       type, since only nullptr_t can be converted to nullptr_t.  Also,\n+       even a constant 0 is a null pointer constant, so we may have to\n+       create a pointer type from its type.  */\n+      else if (code0 == NULLPTR_TYPE && null_pointer_constant_p (orig_op1))\n+\tresult_type = (INTEGRAL_TYPE_P (type1)\n+\t\t       ? build_pointer_type (type1) : type1);\n+      else if (code1 == NULLPTR_TYPE && null_pointer_constant_p (orig_op0))\n+\tresult_type = (INTEGRAL_TYPE_P (type0)\n+\t\t       ? build_pointer_type (type0) : type0);\n       if ((TREE_CODE (TREE_TYPE (orig_op0)) == BOOLEAN_TYPE\n \t   || truth_value_p (TREE_CODE (orig_op0)))\n \t  ^ (TREE_CODE (TREE_TYPE (orig_op1)) == BOOLEAN_TYPE"}, {"sha": "c897da204fe3db7ca1374c2a3eb1424e5e23ff48", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60d84e82639e25b025a926b19ec5a92fba4447ce/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60d84e82639e25b025a926b19ec5a92fba4447ce/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=60d84e82639e25b025a926b19ec5a92fba4447ce", "patch": "@@ -187,9 +187,6 @@ enum cp_tree_index\n     CPTI_NOEXCEPT_FALSE_SPEC,\n     CPTI_NOEXCEPT_DEFERRED_SPEC,\n \n-    CPTI_NULLPTR,\n-    CPTI_NULLPTR_TYPE,\n-\n     CPTI_ANY_TARG,\n \n     CPTI_MODULE_HWM,\n@@ -254,8 +251,6 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n #define conv_op_marker\t\t\tcp_global_trees[CPTI_CONV_OP_MARKER]\n #define abort_fndecl\t\t\tcp_global_trees[CPTI_ABORT_FNDECL]\n #define current_aggr\t\t\tcp_global_trees[CPTI_AGGR_TAG]\n-#define nullptr_node\t\t\tcp_global_trees[CPTI_NULLPTR]\n-#define nullptr_type_node\t\tcp_global_trees[CPTI_NULLPTR_TYPE]\n /* std::align_val_t */\n #define align_type_node\t\t\tcp_global_trees[CPTI_ALIGN_TYPE]\n \n@@ -4405,9 +4400,6 @@ get_vec_init_expr (tree t)\n    || TREE_CODE (TYPE) == REAL_TYPE \\\n    || TREE_CODE (TYPE) == COMPLEX_TYPE)\n \n-/* True iff TYPE is cv decltype(nullptr).  */\n-#define NULLPTR_TYPE_P(TYPE) (TREE_CODE (TYPE) == NULLPTR_TYPE)\n-\n /* [basic.types]\n \n    Arithmetic types, enumeration types, pointer types,"}, {"sha": "d46a347a6c7476d00f29d79190d7f0c3762b27d1", "filename": "gcc/cp/decl.cc", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60d84e82639e25b025a926b19ec5a92fba4447ce/gcc%2Fcp%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60d84e82639e25b025a926b19ec5a92fba4447ce/gcc%2Fcp%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.cc?ref=60d84e82639e25b025a926b19ec5a92fba4447ce", "patch": "@@ -4793,16 +4793,10 @@ cxx_init_decl_processing (void)\n \t  }\n       }\n \n-    nullptr_type_node = make_node (NULLPTR_TYPE);\n-    TYPE_SIZE (nullptr_type_node) = bitsize_int (GET_MODE_BITSIZE (ptr_mode));\n-    TYPE_SIZE_UNIT (nullptr_type_node) = size_int (GET_MODE_SIZE (ptr_mode));\n-    TYPE_UNSIGNED (nullptr_type_node) = 1;\n-    TYPE_PRECISION (nullptr_type_node) = GET_MODE_BITSIZE (ptr_mode);\n+    /* C++-specific nullptr initialization.  */\n     if (abi_version_at_least (9))\n       SET_TYPE_ALIGN (nullptr_type_node, GET_MODE_ALIGNMENT (ptr_mode));\n-    SET_TYPE_MODE (nullptr_type_node, ptr_mode);\n     record_builtin_type (RID_MAX, \"decltype(nullptr)\", nullptr_type_node);\n-    nullptr_node = build_int_cst (nullptr_type_node, 0);\n   }\n \n   if (! supports_one_only ())"}, {"sha": "315ff7866941c77e2b6d073b634c6ec2d794840f", "filename": "gcc/ginclude/stddef.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60d84e82639e25b025a926b19ec5a92fba4447ce/gcc%2Fginclude%2Fstddef.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60d84e82639e25b025a926b19ec5a92fba4447ce/gcc%2Fginclude%2Fstddef.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fstddef.h?ref=60d84e82639e25b025a926b19ec5a92fba4447ce", "patch": "@@ -443,6 +443,14 @@ typedef struct {\n #endif\n #endif /* C++11.  */\n \n+#if (defined (__STDC_VERSION__) && __STDC_VERSION__ > 201710L)\n+#ifndef _GCC_NULLPTR_T\n+#define _GCC_NULLPTR_T\n+  typedef __typeof__(nullptr) nullptr_t;\n+/* ??? This doesn't define __STDC_VERSION_STDDEF_H__ yet.  */\n+#endif\n+#endif /* C23.  */\n+\n #endif /* _STDDEF_H was defined this time */\n \n #endif /* !_STDDEF_H && !_STDDEF_H_ && !_ANSI_STDDEF_H && !__STDDEF_H__"}, {"sha": "c4faedc2c9180686724c1411ef54dfedd5ef6541", "filename": "gcc/testsuite/gcc.dg/c11-nullptr-1.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60d84e82639e25b025a926b19ec5a92fba4447ce/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-nullptr-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60d84e82639e25b025a926b19ec5a92fba4447ce/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-nullptr-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-nullptr-1.c?ref=60d84e82639e25b025a926b19ec5a92fba4447ce", "patch": "@@ -0,0 +1,10 @@\n+/* Test that in pre-C23 modes, nullptr is a normal identifier,\n+   not a keyword.  */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+int nullptr;\n+\n+void\n+f (int nullptr)\n+{\n+}"}, {"sha": "92e43b9df236fc0dc2839a5afe2bc01ea224e0b2", "filename": "gcc/testsuite/gcc.dg/c17-nullptr-1.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60d84e82639e25b025a926b19ec5a92fba4447ce/gcc%2Ftestsuite%2Fgcc.dg%2Fc17-nullptr-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60d84e82639e25b025a926b19ec5a92fba4447ce/gcc%2Ftestsuite%2Fgcc.dg%2Fc17-nullptr-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc17-nullptr-1.c?ref=60d84e82639e25b025a926b19ec5a92fba4447ce", "patch": "@@ -0,0 +1,10 @@\n+/* Test that in pre-C23 modes, nullptr is a normal identifier,\n+   not a keyword.  */\n+/* { dg-options \"-std=c17 -pedantic-errors\" } */\n+\n+int nullptr;\n+\n+void\n+f (int nullptr)\n+{\n+}"}, {"sha": "a6ad7703eebc7cf776502bf8b6bfcae0fb862148", "filename": "gcc/testsuite/gcc.dg/c17-nullptr-2.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60d84e82639e25b025a926b19ec5a92fba4447ce/gcc%2Ftestsuite%2Fgcc.dg%2Fc17-nullptr-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60d84e82639e25b025a926b19ec5a92fba4447ce/gcc%2Ftestsuite%2Fgcc.dg%2Fc17-nullptr-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc17-nullptr-2.c?ref=60d84e82639e25b025a926b19ec5a92fba4447ce", "patch": "@@ -0,0 +1,10 @@\n+/* Test that we don't predefine `nullptr' pre-C2X.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c17 -pedantic-errors\" } */\n+\n+int *\n+fn (int *p)\n+{\n+  p = nullptr; /* { dg-error \"'nullptr' undeclared\" } */\n+  return p;\n+}"}, {"sha": "9501b514f1c89ac31ef317a2d646f6780f51ccb9", "filename": "gcc/testsuite/gcc.dg/c2x-nullptr-1.c", "status": "added", "additions": 298, "deletions": 0, "changes": 298, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60d84e82639e25b025a926b19ec5a92fba4447ce/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-nullptr-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60d84e82639e25b025a926b19ec5a92fba4447ce/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-nullptr-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-nullptr-1.c?ref=60d84e82639e25b025a926b19ec5a92fba4447ce", "patch": "@@ -0,0 +1,298 @@\n+/* Test valid usage of C23 nullptr.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c2x -pedantic-errors -Wall -Wextra -Wno-unused-variable\" } */\n+\n+#include <stdarg.h>\n+\n+typedef __typeof__(nullptr) nullptr_t;\n+\n+void f1 (nullptr_t) { }\n+void f2 (int *) { }\n+void f3 (_Bool) { }\n+nullptr_t cmp (void) { return nullptr; }\n+\n+/* The type nullptr_t shall not be converted to any type other than void, bool or\n+   a pointer type.  No type other than nullptr_t shall be converted to nullptr_t.  */\n+void\n+test1 (void)\n+{\n+  const nullptr_t nptr = nullptr;\n+  static nullptr_t static_nptr;\n+  int *p1 = nullptr;\n+  void *p2 = nullptr;\n+  float *p3 = nullptr;\n+  void (*p4)(int) = nullptr;\n+  int (*p5)[10] = nullptr;\n+  int *p6 = nptr;\n+  void *p7 = nptr;\n+  float *p8 = nptr;\n+  void (*p9)(int) = nptr;\n+  int (*p10)[10] = nptr;\n+  int *p11 = (int *) nullptr;\n+  int *p12 = (int *) nptr;\n+  int *p13 = (nullptr);\n+  int *p14 = _Generic(0, int : nullptr);\n+  if (nullptr || p1 || p2 || p3 || p4 || p5 || p6 || p7 || p8 || p9 || p10\n+      || p11 || p12 || p13 || p14)\n+    __builtin_abort ();\n+\n+  _Bool b1 = nullptr;\n+  _Bool b2 = (_Bool) nullptr;\n+  _Bool b3 = nptr;\n+  _Bool b4 = (_Bool) nptr;\n+  _Bool b5 = _Generic(0, int : nullptr);\n+  if (b1 || b2 || b3 || b4 || b5 || (_Bool) nullptr || (_Bool) nptr)\n+   __builtin_abort ();\n+\n+  __auto_type a1 = nullptr;\n+  __auto_type a2 = nptr;\n+\n+  /* We can convert nullptr_t to nullptr_t.  */\n+  __typeof__(nullptr) x = nullptr;\n+  f1 (x);\n+  f1 (nullptr);\n+  f1 (_Generic(0, int : nullptr));\n+  f2 (x);\n+  f2 (nullptr);\n+  f3 (nullptr);\n+\n+  const nullptr_t np1 = nullptr;\n+  const nullptr_t np2 = np1;\n+  (void) nullptr;\n+  (void) np1;\n+  (void) np2;\n+  (void) cmp ();\n+  (void)(nullptr_t) nullptr;\n+}\n+\n+/* Test valid comparison.  */\n+void\n+test2 (int *p)\n+{\n+  /* If both operands have type nullptr_t or one operand has type nullptr_t\n+     and the other is a null pointer constant, they compare equal.  */\n+  const nullptr_t nptr = nullptr;\n+  int r = 0;\n+\n+  /* Both operands have type nullptr_t.  */\n+  r |= nullptr != nullptr;\n+  r |= cmp () != nullptr;\n+  r |= nullptr != cmp ();\n+  r |= !(nullptr == nullptr);\n+  r |= !(cmp () == nullptr);\n+  r |= !(nullptr == cmp ());\n+  r |= nptr != nptr;\n+  r |= cmp () != nptr;\n+  r |= nptr != cmp ();\n+  r |= !(nptr == nptr);\n+  r |= !(cmp () == nptr);\n+  r |= !(nptr == cmp ());\n+\n+ /* One operand has type nullptr_t and the other is a null pointer constant.  */\n+  r |= nullptr != (void *) 0;\n+  r |= _Generic(0, int : nullptr) != (void *) 0;\n+  r |= (nullptr) != (void *) 0;\n+  r |= !(nullptr == (void *) 0);\n+  r |= (void *) 0 != nullptr;\n+  r |= (void *) 0 != (nullptr);\n+  r |= !((void *) 0 == nullptr);\n+  r |= nullptr != 0;\n+  r |= _Generic(0, int : nullptr) != 0;\n+  r |= (nullptr) != 0;\n+  r |= 0 != nullptr;\n+  r |= 0 != (nullptr);\n+  r |= !(nullptr == 0);\n+  r |= !(0 == nullptr);\n+  r |= nullptr != 0u;\n+  r |= 0u != nullptr;\n+  r |= !(nullptr == 0u);\n+  r |= !(0u == nullptr);\n+  r |= nptr != (void *) 0;\n+  r |= !(nptr == (void *) 0);\n+  r |= (void *) 0 != nptr;\n+  r |= !((void *) 0 == nptr);\n+  r |= nptr != 0;\n+  r |= 0 != nptr;\n+  r |= !(nptr == 0);\n+  r |= !(0 == nptr);\n+  r |= nptr != 0u;\n+  r |= 0u != nptr;\n+  r |= !(nptr == 0u);\n+  r |= !(0u == nptr);\n+  r |= nptr != _Generic(0, int : nullptr);\n+  r |= _Generic(0, int : nullptr) != nptr;\n+  if (r)\n+    __builtin_abort ();\n+\n+  /* One operand is a pointer and the other is a null pointer constant.  */\n+  (void) (p == nullptr);\n+  (void) (p != nullptr);\n+  (void) (nullptr == p);\n+  (void) (nullptr != p);\n+  (void) (p == (nullptr));\n+  (void) (p != (nullptr));\n+  (void) ((nullptr) == p);\n+  (void) ((nullptr) != p);\n+  (void) ((void *)nullptr == nullptr);\n+  (void) ((void *)nullptr != nullptr);\n+  (void) (nullptr == (void *)nullptr);\n+  (void) (nullptr != (void *)nullptr);\n+  (void) (p == _Generic(0, int : nullptr));\n+  (void) (p != _Generic(0, int : nullptr));\n+  (void) (_Generic(0, int : nullptr) == p);\n+  (void) (_Generic(0, int : nullptr) != p);\n+}\n+\n+/* Test ?:.  */\n+void\n+test3 (int *p, _Bool b)\n+{\n+  int x = nullptr ? 1 : 2;\n+  (void) x;\n+  const nullptr_t nptr = nullptr;\n+  /* One of the following shall hold for the second and third operands:\n+     -- both operands have nullptr_t type.  */\n+  __auto_type r1 = b ? nullptr : nullptr;\n+  __auto_type r2 = b ? nptr : nptr;\n+  /* -- one operand is a pointer and the other is a null pointer constant\n+     or has type nullptr_t;  */\n+  __auto_type r3 = b ? p : nullptr;\n+  __auto_type r4 = b ? nullptr : p;\n+  __auto_type r5 = b ? nptr : p;\n+  __auto_type r6 = b ? p : nptr;\n+  __auto_type r7 = b ? 0 : p;\n+  __auto_type r8 = b ? p : 0;\n+  __auto_type r9 = b ? p : cmp ();\n+  __auto_type r10 = b ?  cmp () : p;\n+  __auto_type r11 = b ? p : _Generic(0, int : nullptr);\n+  __auto_type r12 = b ? _Generic(0, int : nullptr) : p;\n+}\n+\n+void test_arg1 (const nullptr_t, _Atomic nullptr_t, volatile nullptr_t) { }\n+void test_arg2 (_Atomic int *, const int *, volatile int *) { }\n+void test_arg3 (_Atomic _Bool, const _Bool, volatile _Bool) { }\n+nullptr_t retn (void) { return nullptr; }\n+_Atomic int *ai (void) { return nullptr; }\n+const int *ci (void) { return nullptr; }\n+volatile int *vi (void) { return nullptr; }\n+_Bool retb (void) { return nullptr; }\n+\n+/* Simple assignment.  */\n+void\n+test4 (void)\n+{\n+  /* -- the left operand has an atomic, qualified, or unqualified version of\n+     the nullptr_t type and the type of the right is nullptr_t;  */\n+  nullptr_t n1;\n+  const nullptr_t n2 = nullptr;\n+  _Atomic nullptr_t n3 = nullptr;\n+  volatile nullptr_t n4 = nullptr;\n+  _Atomic volatile nullptr_t n5 = nullptr;\n+  n1 = nullptr;\n+  n3 = nullptr;\n+  n4 = nullptr;\n+  n5 = nullptr;\n+  n5 = _Generic(0, int : nullptr);\n+  /* -- the left operand is an atomic, qualified, or unqualified pointer,\n+     and the type of the right is nullptr_t;  */\n+  int *p1 = cmp ();\n+  _Atomic int *p2 = cmp ();\n+  const int *volatile p3 = cmp ();\n+  const int *const *const p4 = cmp ();\n+  double (*const p5)(void) = n1;\n+  p2 = _Generic(0, int : nullptr);\n+  p3 = nullptr;\n+  /* -- the left operand is an atomic, qualified, or unqualified bool, and\n+     the type of the right is nullptr_t;  */\n+  _Bool b1;\n+  b1 = cmp ();\n+  const _Bool b2 = nullptr;\n+  _Atomic _Bool b3;\n+  b3 = n1;\n+  (void) b1;\n+  (void) b3;\n+  (void) n3;\n+  (void) n4;\n+  (void) n5;\n+  (void) p2;\n+  (void) p3;\n+\n+  test_arg1 (nullptr, nullptr, nullptr);\n+  test_arg2 (nullptr, nullptr, nullptr);\n+  test_arg3 (nullptr, nullptr, nullptr);\n+}\n+\n+/* var_arg etc.  */\n+static void\n+test5 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  if (va_arg (ap, void *))\n+    __builtin_abort ();\n+}\n+\n+/* Operand of alignas, sizeof or typeof operators.  */\n+void\n+test6 (void)\n+{\n+  _Static_assert (sizeof (nullptr) == sizeof (void *), \"sizeof (nullptr)\");\n+  _Static_assert (sizeof (nullptr_t) == sizeof (void *), \"sizeof (nullptr_t)\");\n+  _Static_assert (sizeof (nullptr) == sizeof (char *), \"sizeof (nullptr)\");\n+  _Static_assert (sizeof (nullptr_t) == sizeof (char *), \"sizeof (nullptr_t)\");\n+  _Static_assert (_Alignof (nullptr_t) == _Alignof (char *), \"_Alignof (nullptr_t)\");\n+  __typeof__(nullptr) t = nullptr;\n+  f1 (t);\n+  _Alignas (nullptr_t) char i1 = 'q';\n+\n+  _Static_assert (_Generic (nullptr, nullptr_t: 1, default: 0) == 1, \"_Generic\");\n+  _Static_assert (_Generic (t, nullptr_t: 1, default: 0) == 1, \"_Generic\");\n+  _Static_assert (_Generic (cmp (), nullptr_t: 1, default: 0) == 1, \"_Generic\");\n+  _Static_assert (_Generic (0, nullptr_t: 1, int: 2, default: 0) == 2, \"_Generic\");\n+  _Static_assert (_Generic ((void *)0, nullptr_t: 1, void *: 2, default: 0) == 2, \"_Generic\");\n+  _Static_assert (_Generic (nullptr, nullptr_t: 1, void *: 2, default: 0) == 1, \"_Generic\");\n+}\n+\n+/* Play with !, ||, &&. */\n+void\n+test7 (void)\n+{\n+  if (nullptr)\n+    __builtin_abort ();\n+  if (1 && nullptr)\n+    __builtin_abort ();\n+  if (0 || nullptr)\n+    __builtin_abort ();\n+  if (nullptr && 1)\n+    __builtin_abort ();\n+  if (nullptr || 0)\n+    __builtin_abort ();\n+  if (!nullptr)\n+    {\n+    }\n+  else\n+    __builtin_abort ();\n+  while (nullptr)\n+    __builtin_abort ();\n+  int i = 0;\n+  do\n+    ++i;\n+  while (nullptr);\n+  if (i != 1)\n+    __builtin_abort ();\n+  for (;nullptr;)\n+    __builtin_abort ();\n+}\n+\n+int\n+main (void)\n+{\n+  int i = 42;\n+  test1 ();\n+  test2 (&i);\n+  test3 (&i, 0);\n+  test4 ();\n+  test5 (42, nullptr);\n+  test6 ();\n+  test7 ();\n+}"}, {"sha": "b61056573621aa8b751b0d7c2534118655cbae9c", "filename": "gcc/testsuite/gcc.dg/c2x-nullptr-2.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60d84e82639e25b025a926b19ec5a92fba4447ce/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-nullptr-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60d84e82639e25b025a926b19ec5a92fba4447ce/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-nullptr-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-nullptr-2.c?ref=60d84e82639e25b025a926b19ec5a92fba4447ce", "patch": "@@ -0,0 +1,9 @@\n+/* Test nullptr_t from <stddef.h>.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x -pedantic-errors\" } */\n+\n+#include <stddef.h>\n+\n+void f(nullptr_t);\n+_Static_assert (sizeof (nullptr_t) == sizeof (char *), \"sizeof (nullptr_t)\");\n+_Static_assert (_Alignof (nullptr_t) == _Alignof (char *), \"_Alignof (nullptr_t)\");"}, {"sha": "34e3e03ba9d5dbe1f573597fe93786c24589ec5c", "filename": "gcc/testsuite/gcc.dg/c2x-nullptr-3.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60d84e82639e25b025a926b19ec5a92fba4447ce/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-nullptr-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60d84e82639e25b025a926b19ec5a92fba4447ce/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-nullptr-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-nullptr-3.c?ref=60d84e82639e25b025a926b19ec5a92fba4447ce", "patch": "@@ -0,0 +1,80 @@\n+/* Test wrong usage of C23 nullptr.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x -pedantic-errors -Wall -Wextra -Wno-unused-variable\" } */\n+\n+typedef __typeof__(nullptr) nullptr_t;\n+\n+void g (nullptr_t); /* { dg-message \"expected .nullptr_t. but argument is of type .int.\" } */\n+nullptr_t cmp (void);\n+\n+void\n+test1 (int *p)\n+{\n+  (void) (p > nullptr); /* { dg-error \"ordered comparison\" } */\n+  (void) (p >= nullptr); /* { dg-error \"ordered comparison\" } */\n+  (void) (p < nullptr); /* { dg-error \"ordered comparison\" } */\n+  (void) (p <= nullptr); /* { dg-error \"ordered comparison\" } */\n+  (void) (nullptr == 1); /* { dg-error \"invalid operands\" } */\n+  (void) (1 == nullptr); /* { dg-error \"invalid operands\" } */\n+  (void) (nullptr != 1); /* { dg-error \"invalid operands\" } */\n+  (void) (1 != nullptr); /* { dg-error \"invalid operands\" } */\n+  (void) (1 > nullptr); /* { dg-error \"invalid operands\" } */\n+\n+  /* \"(nullptr_t)nullptr\" has type nullptr_t but isn't an NPC.  */\n+  (void) ((nullptr_t)nullptr == p); /* { dg-error \"invalid operands\" } */\n+  (void) ((nullptr_t)nullptr != p); /* { dg-error \"invalid operands\" } */\n+  (void) (p == (nullptr_t)nullptr); /* { dg-error \"invalid operands\" } */\n+  (void) (p != (nullptr_t)nullptr); /* { dg-error \"invalid operands\" } */\n+  (void) (cmp () == p); /* { dg-error \"invalid operands\" } */\n+  (void) (cmp () != p); /* { dg-error \"invalid operands\" } */\n+  (void) (p == cmp ()); /* { dg-error \"invalid operands\" } */\n+  (void) (p != cmp ()); /* { dg-error \"invalid operands\" } */\n+  /* \"(void *)nullptr\" is not an NPC, either.  */\n+  (void) ((void *)nullptr == cmp ()); /* { dg-error \"invalid operands\" } */\n+  (void) ((void *)nullptr != cmp ()); /* { dg-error \"invalid operands\" } */\n+  (void) (cmp () == (void *)nullptr); /* { dg-error \"invalid operands\" } */\n+  (void) (cmp () != (void *)nullptr); /* { dg-error \"invalid operands\" } */\n+}\n+\n+void\n+test2 (void)\n+{\n+  const nullptr_t nptr = nullptr;\n+  int p = nullptr; /* { dg-error \"incompatible types\" } */\n+  float d = nullptr; /* { dg-error \"incompatible types\" } */\n+  char arr[10] = { nullptr }; /* { dg-error \"incompatible types\" } */\n+\n+  /* No type other than nullptr_t shall be converted to nullptr_t.  */\n+  const nullptr_t n = 0; /* { dg-error \"invalid initializer\" } */\n+  +(nullptr_t) 0; /* { dg-error \"conversion from .int. to .nullptr_t.\" } */\n+\n+  g (0); /* { dg-error \"incompatible type\" } */\n+\n+  int i = 42 + nullptr; /* { dg-error \"invalid operands\" } */\n+\n+  /* The assignment of an object of type nullptr_t with a value of another\n+     type, even if the value is a null pointer constant, is a constraint\n+     violation.  */\n+  nullptr_t m;\n+  m = 0; /* { dg-error \"incompatible types\" } */\n+  (void) m;\n+  nullptr_t o = 0; /* { dg-error \"invalid initializer\" } */\n+\n+  switch (nullptr); /* { dg-error \"switch quantity not an integer\" } */\n+}\n+\n+/* If a second or third operand of type nullptr_t is used that is not a null\n+   pointer constant and the other operand is not a pointer or does not have\n+   itself nullptr_t, a constraint is violated even if that other operand is\n+   a null pointer constant such as 0.  */\n+void\n+test3 (_Bool b, int i)\n+{\n+  const nullptr_t nptr = nullptr;\n+  __auto_type a1 = b ? nptr : i; /* { dg-error \"type mismatch\" } */\n+  __auto_type a2 = b ? i : nptr; /* { dg-error \"type mismatch\" } */\n+  __auto_type a3 = b ? nptr : 0; /* { dg-error \"type mismatch\" } */\n+  __auto_type a4 = b ? 0 : nptr; /* { dg-error \"type mismatch\" } */\n+  __auto_type a5 = b ? 0 : nullptr; /* { dg-error \"type mismatch\" } */\n+  __auto_type a6 = b ? nullptr : 0; /* { dg-error \"type mismatch\" } */\n+}"}, {"sha": "7479ab4ea1ddc929fd1f680bf2749082273d552d", "filename": "gcc/testsuite/gcc.dg/c2x-nullptr-4.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60d84e82639e25b025a926b19ec5a92fba4447ce/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-nullptr-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60d84e82639e25b025a926b19ec5a92fba4447ce/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-nullptr-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-nullptr-4.c?ref=60d84e82639e25b025a926b19ec5a92fba4447ce", "patch": "@@ -0,0 +1,11 @@\n+/* Test that -Wc11-c2x-compat issues a warning (not a pedwarn) about\n+   `nullptr' in C2X.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x -pedantic-errors -Wc11-c2x-compat\" } */\n+\n+int *\n+fn (int *p)\n+{\n+  p = nullptr; /* { dg-warning \"ISO C does not support .nullptr. before C2X\" } */\n+  return p;\n+}"}, {"sha": "27803f7d03fc06b17432c7537a44711a08c53a3a", "filename": "gcc/testsuite/gcc.dg/c2x-nullptr-5.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60d84e82639e25b025a926b19ec5a92fba4447ce/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-nullptr-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60d84e82639e25b025a926b19ec5a92fba4447ce/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-nullptr-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-nullptr-5.c?ref=60d84e82639e25b025a926b19ec5a92fba4447ce", "patch": "@@ -0,0 +1,14 @@\n+/* Test that we don't lose side-effects when converting from nullptr_t.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c2x -pedantic-errors\" } */\n+\n+int i;\n+nullptr_t fn () { ++i; return nullptr; }\n+\n+int\n+main ()\n+{\n+  int *p = fn ();\n+  if (i != 1)\n+    __builtin_abort ();\n+}"}]}