{"sha": "6050d55ca84fe96018e99afa5e1403341c538f3f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjA1MGQ1NWNhODRmZTk2MDE4ZTk5YWZhNWUxNDAzMzQxYzUzOGYzZg==", "commit": {"author": {"name": "Thomas Preud'homme", "email": "thomas.preudhomme@arm.com", "date": "2017-09-28T16:13:01Z"}, "committer": {"name": "Thomas Preud'homme", "email": "thopre01@gcc.gnu.org", "date": "2017-09-28T16:13:01Z"}, "message": "[ARM] Remove ARMv8-M code for D17-D31\n\nFunction cmse_nonsecure_entry_clear_before_return has code to deal with\nhigh VFP register (D16-D31) while ARMv8-M Baseline and Mainline both do\nnot support more than 16 double VFP registers (D0-D15). This makes this\nsecurity-sensitive code harder to read for not much benefit since\nlibcall for cmse_nonsecure_call functions do not deal with those high\nVFP registers anyway.\n\nThis commit gets rid of this code for simplicity and fixes 2 issues in\nthe same function:\n\n- stop the first loop when reaching maxregno to avoid dealing with VFP\n  registers if targetting Thumb-1 or using -mfloat-abi=soft\n- include maxregno in that loop\n\n2017-09-28  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n\n    gcc/\n    * config/arm/arm.c (arm_option_override): Forbid ARMv8-M Security\n    Extensions with more than 16 double VFP registers.\n    (cmse_nonsecure_entry_clear_before_return): Remove second entry of\n    to_clear_mask and all code related to it.  Replace the remaining\n    entry by a sbitmap and adapt code accordingly.\n\nFrom-SVN: r253256", "tree": {"sha": "10f466de1de6f32fabf5185df6f377c391baa9ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10f466de1de6f32fabf5185df6f377c391baa9ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6050d55ca84fe96018e99afa5e1403341c538f3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6050d55ca84fe96018e99afa5e1403341c538f3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6050d55ca84fe96018e99afa5e1403341c538f3f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6050d55ca84fe96018e99afa5e1403341c538f3f/comments", "author": {"login": "RoboTux", "id": 272327, "node_id": "MDQ6VXNlcjI3MjMyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/272327?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RoboTux", "html_url": "https://github.com/RoboTux", "followers_url": "https://api.github.com/users/RoboTux/followers", "following_url": "https://api.github.com/users/RoboTux/following{/other_user}", "gists_url": "https://api.github.com/users/RoboTux/gists{/gist_id}", "starred_url": "https://api.github.com/users/RoboTux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RoboTux/subscriptions", "organizations_url": "https://api.github.com/users/RoboTux/orgs", "repos_url": "https://api.github.com/users/RoboTux/repos", "events_url": "https://api.github.com/users/RoboTux/events{/privacy}", "received_events_url": "https://api.github.com/users/RoboTux/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5a47aa2c8c36571a51552e46f3d971c107d5bf88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a47aa2c8c36571a51552e46f3d971c107d5bf88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a47aa2c8c36571a51552e46f3d971c107d5bf88"}], "stats": {"total": 72, "additions": 48, "deletions": 24}, "files": [{"sha": "a6c8b93c43915d95e7daa6e20b1cc0f5a40e8ca2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6050d55ca84fe96018e99afa5e1403341c538f3f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6050d55ca84fe96018e99afa5e1403341c538f3f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6050d55ca84fe96018e99afa5e1403341c538f3f", "patch": "@@ -1,3 +1,11 @@\n+2017-09-28  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n+\n+\t* config/arm/arm.c (arm_option_override): Forbid ARMv8-M Security\n+\tExtensions with more than 16 double VFP registers.\n+\t(cmse_nonsecure_entry_clear_before_return): Remove second entry of\n+\tto_clear_mask and all code related to it.  Replace the remaining\n+\tentry by a sbitmap and adapt code accordingly.\n+\n 2017-09-28  Henry Linjam\u00e4ki  <henry.linjamaki@parmance.com>\n \n \t* brig-builtins.def: Change pure attributes to const."}, {"sha": "4cddf3b02e5e731507c2d326b80747524fd505bf", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 40, "deletions": 24, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6050d55ca84fe96018e99afa5e1403341c538f3f/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6050d55ca84fe96018e99afa5e1403341c538f3f/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=6050d55ca84fe96018e99afa5e1403341c538f3f", "patch": "@@ -3669,6 +3669,11 @@ arm_option_override (void)\n   if (use_cmse && !arm_arch_cmse)\n     error (\"target CPU does not support ARMv8-M Security Extensions\");\n \n+  /* We don't clear D16-D31 VFP registers for cmse_nonsecure_call functions\n+     and ARMv8-M Baseline and Mainline do not allow such configuration.  */\n+  if (use_cmse && LAST_VFP_REGNUM > LAST_LO_VFP_REGNUM)\n+    error (\"ARMv8-M Security Extensions incompatible with selected FPU\");\n+\n   /* Disable scheduling fusion by default if it's not armv7 processor\n      or doesn't prefer ldrd/strd.  */\n   if (flag_schedule_fusion == 2\n@@ -25075,42 +25080,37 @@ thumb1_expand_prologue (void)\n void\n cmse_nonsecure_entry_clear_before_return (void)\n {\n-  uint64_t to_clear_mask[2];\n+  int regno, maxregno = TARGET_HARD_FLOAT ? LAST_VFP_REGNUM : IP_REGNUM;\n   uint32_t padding_bits_to_clear = 0;\n   uint32_t * padding_bits_to_clear_ptr = &padding_bits_to_clear;\n-  int regno, maxregno = IP_REGNUM;\n+  auto_sbitmap to_clear_bitmap (maxregno + 1);\n   tree result_type;\n   rtx result_rtl;\n \n-  to_clear_mask[0] = (1ULL << (NUM_ARG_REGS)) - 1;\n-  to_clear_mask[0] |= (1ULL << IP_REGNUM);\n+  bitmap_clear (to_clear_bitmap);\n+  bitmap_set_range (to_clear_bitmap, R0_REGNUM, NUM_ARG_REGS);\n+  bitmap_set_bit (to_clear_bitmap, IP_REGNUM);\n \n   /* If we are not dealing with -mfloat-abi=soft we will need to clear VFP\n-     registers.  We also check that TARGET_HARD_FLOAT and !TARGET_THUMB1 hold\n-     to make sure the instructions used to clear them are present.  */\n-  if (TARGET_HARD_FLOAT && !TARGET_THUMB1)\n+     registers.  */\n+  if (TARGET_HARD_FLOAT)\n     {\n-      uint64_t float_mask = (1ULL << (D7_VFP_REGNUM + 1)) - 1;\n-      maxregno = LAST_VFP_REGNUM;\n+      int float_bits = D7_VFP_REGNUM - FIRST_VFP_REGNUM + 1;\n \n-      float_mask &= ~((1ULL << FIRST_VFP_REGNUM) - 1);\n-      to_clear_mask[0] |= float_mask;\n-\n-      float_mask = (1ULL << (maxregno - 63)) - 1;\n-      to_clear_mask[1] = float_mask;\n+      bitmap_set_range (to_clear_bitmap, FIRST_VFP_REGNUM, float_bits);\n \n       /* Make sure we don't clear the two scratch registers used to clear the\n \t relevant FPSCR bits in output_return_instruction.  */\n       emit_use (gen_rtx_REG (SImode, IP_REGNUM));\n-      to_clear_mask[0] &= ~(1ULL << IP_REGNUM);\n+      bitmap_clear_bit (to_clear_bitmap, IP_REGNUM);\n       emit_use (gen_rtx_REG (SImode, 4));\n-      to_clear_mask[0] &= ~(1ULL << 4);\n+      bitmap_clear_bit (to_clear_bitmap, 4);\n     }\n \n   /* If the user has defined registers to be caller saved, these are no longer\n      restored by the function before returning and must thus be cleared for\n      security purposes.  */\n-  for (regno = NUM_ARG_REGS; regno < LAST_VFP_REGNUM; regno++)\n+  for (regno = NUM_ARG_REGS; regno <= maxregno; regno++)\n     {\n       /* We do not touch registers that can be used to pass arguments as per\n \t the AAPCS, since these should never be made callee-saved by user\n@@ -25120,29 +25120,45 @@ cmse_nonsecure_entry_clear_before_return (void)\n       if (IN_RANGE (regno, IP_REGNUM, PC_REGNUM))\n \tcontinue;\n       if (call_used_regs[regno])\n-\tto_clear_mask[regno / 64] |= (1ULL << (regno % 64));\n+\tbitmap_set_bit (to_clear_bitmap, regno);\n     }\n \n   /* Make sure we do not clear the registers used to return the result in.  */\n   result_type = TREE_TYPE (DECL_RESULT (current_function_decl));\n   if (!VOID_TYPE_P (result_type))\n     {\n+      uint64_t to_clear_return_mask;\n       result_rtl = arm_function_value (result_type, current_function_decl, 0);\n \n       /* No need to check that we return in registers, because we don't\n \t support returning on stack yet.  */\n-      to_clear_mask[0]\n-\t&= ~compute_not_to_clear_mask (result_type, result_rtl, 0,\n-\t\t\t\t       padding_bits_to_clear_ptr);\n+      gcc_assert (REG_P (result_rtl));\n+      to_clear_return_mask\n+\t= compute_not_to_clear_mask (result_type, result_rtl, 0,\n+\t\t\t\t     padding_bits_to_clear_ptr);\n+      if (to_clear_return_mask)\n+\t{\n+\t  gcc_assert ((unsigned) maxregno < sizeof (long long) * __CHAR_BIT__);\n+\t  for (regno = R0_REGNUM; regno <= maxregno; regno++)\n+\t    {\n+\t      if (to_clear_return_mask & (1ULL << regno))\n+\t\tbitmap_clear_bit (to_clear_bitmap, regno);\n+\t    }\n+\t}\n     }\n \n   if (padding_bits_to_clear != 0)\n     {\n       rtx reg_rtx;\n+      auto_sbitmap to_clear_arg_regs_bitmap (R0_REGNUM + NUM_ARG_REGS);\n+\n       /* Padding bits to clear is not 0 so we know we are dealing with\n \t returning a composite type, which only uses r0.  Let's make sure that\n \t r1-r3 is cleared too, we will use r1 as a scratch register.  */\n-      gcc_assert ((to_clear_mask[0] & 0xe) == 0xe);\n+      bitmap_clear (to_clear_arg_regs_bitmap);\n+      bitmap_set_range (to_clear_arg_regs_bitmap, R0_REGNUM + 1,\n+\t\t\tNUM_ARG_REGS - 1);\n+      gcc_assert (bitmap_subset_p (to_clear_arg_regs_bitmap, to_clear_bitmap));\n \n       reg_rtx = gen_rtx_REG (SImode, R1_REGNUM);\n \n@@ -25164,7 +25180,7 @@ cmse_nonsecure_entry_clear_before_return (void)\n \n   for (regno = R0_REGNUM; regno <= maxregno; regno++)\n     {\n-      if (!(to_clear_mask[regno / 64] & (1ULL << (regno % 64))))\n+      if (!bitmap_bit_p (to_clear_bitmap, regno))\n \tcontinue;\n \n       if (IS_VFP_REGNUM (regno))\n@@ -25173,7 +25189,7 @@ cmse_nonsecure_entry_clear_before_return (void)\n \t     be cleared, use vmov.  */\n \t  if (TARGET_VFP_DOUBLE\n \t      && VFP_REGNO_OK_FOR_DOUBLE (regno)\n-\t      && to_clear_mask[regno / 64] & (1ULL << ((regno % 64) + 1)))\n+\t      && bitmap_bit_p (to_clear_bitmap, regno + 1))\n \t    {\n \t      emit_move_insn (gen_rtx_REG (DFmode, regno),\n \t\t\t      CONST1_RTX (DFmode));"}]}