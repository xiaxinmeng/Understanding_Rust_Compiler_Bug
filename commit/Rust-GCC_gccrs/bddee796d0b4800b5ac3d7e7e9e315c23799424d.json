{"sha": "bddee796d0b4800b5ac3d7e7e9e315c23799424d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmRkZWU3OTZkMGI0ODAwYjVhYzNkN2U3ZTllMzE1YzIzNzk5NDI0ZA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2019-03-08T02:54:41Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2019-03-08T02:54:41Z"}, "message": "PR c++/88123 - lambda and using-directive.\n\nFor named function calls in a template, the result of unqualified lookup is\nsafed in CALL_EXPR_FN.  But for operator expressions, no unqualified lookup\nis performed until we know whether the operands have class type.  So when we\nsee in a lambda a use of an operator that might be overloaded, we need to do\nthat lookup then and save it away somewhere.  One possibility would be in\nthe expression, but we can't really add extra conditional operands to\nstandard tree codes.  I mostly implemented another approach using a new\nWITH_LOOKUP_EXPR code, but teaching everywhere how to handle a new tree code\nis always complicated.  Then it occurred to me that we could associate the\nlookups with the function, which is both simpler and smaller.  So this patch\nstores any operator bindings needed by a lambda function in an internal\nattribute on the lambda call operator.\n\n\t* name-lookup.c (op_unqualified_lookup)\n\t(maybe_save_operator_binding, discard_operator_bindings)\n\t(push_operator_bindings): New.\n\t* typeck.c (build_x_binary_op, build_x_unary_op): Call\n\tmaybe_save_operator_binding.\n\t* decl.c (start_preparsed_function): Call push_operator_bindings.\n\t* tree.c (cp_free_lang_data): Call discard_operator_bindings.\n\nFrom-SVN: r269477", "tree": {"sha": "0c9cd89344be1024c157c899c00e236942538921", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c9cd89344be1024c157c899c00e236942538921"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bddee796d0b4800b5ac3d7e7e9e315c23799424d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bddee796d0b4800b5ac3d7e7e9e315c23799424d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bddee796d0b4800b5ac3d7e7e9e315c23799424d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bddee796d0b4800b5ac3d7e7e9e315c23799424d/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1ce59b6cad83d5ca6f1efee83f910d8b677a976a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ce59b6cad83d5ca6f1efee83f910d8b677a976a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ce59b6cad83d5ca6f1efee83f910d8b677a976a"}], "stats": {"total": 156, "additions": 154, "deletions": 2}, "files": [{"sha": "ae5735d30d2f7f036ada1be968fea3da0c4b7835", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bddee796d0b4800b5ac3d7e7e9e315c23799424d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bddee796d0b4800b5ac3d7e7e9e315c23799424d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=bddee796d0b4800b5ac3d7e7e9e315c23799424d", "patch": "@@ -1,5 +1,14 @@\n 2019-03-07  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/88123 - lambda and using-directive.\n+\t* name-lookup.c (op_unqualified_lookup)\n+\t(maybe_save_operator_binding, discard_operator_bindings)\n+\t(push_operator_bindings): New.\n+\t* typeck.c (build_x_binary_op, build_x_unary_op): Call\n+\tmaybe_save_operator_binding.\n+\t* decl.c (start_preparsed_function): Call push_operator_bindings.\n+\t* tree.c (cp_free_lang_data): Call discard_operator_bindings.\n+\n \tPR c++/88820 - ICE with CTAD and member template used in DMI.\n \t* pt.c (do_class_deduction): Handle parm used as its own arg.\n "}, {"sha": "0187db5ff1c1d4b170f9b3dd584debf404dd9f29", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bddee796d0b4800b5ac3d7e7e9e315c23799424d/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bddee796d0b4800b5ac3d7e7e9e315c23799424d/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=bddee796d0b4800b5ac3d7e7e9e315c23799424d", "patch": "@@ -15553,6 +15553,8 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n \n   store_parm_decls (current_function_parms);\n \n+  push_operator_bindings ();\n+\n   if (!processing_template_decl\n       && (flag_lifetime_dse > 1)\n       && DECL_CONSTRUCTOR_P (decl1)"}, {"sha": "2ba888fd1c2e47fba79b700a55b698cc275697a5", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bddee796d0b4800b5ac3d7e7e9e315c23799424d/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bddee796d0b4800b5ac3d7e7e9e315c23799424d/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=bddee796d0b4800b5ac3d7e7e9e315c23799424d", "patch": "@@ -7556,4 +7556,103 @@ cp_emit_debug_info_for_using (tree t, tree context)\n     }\n }\n \n+/* Return the result of unqualified lookup for the overloaded operator\n+   designated by CODE, if we are in a template and the binding we find is\n+   not.  */\n+\n+static tree\n+op_unqualified_lookup (tree fnname)\n+{\n+  if (cxx_binding *binding = IDENTIFIER_BINDING (fnname))\n+    {\n+      cp_binding_level *l = binding->scope;\n+      while (l && !l->this_entity)\n+\tl = l->level_chain;\n+      if (l && uses_template_parms (l->this_entity))\n+\t/* Don't preserve decls from an uninstantiated template,\n+\t   wait until that template is instantiated.  */\n+\treturn NULL_TREE;\n+    }\n+  tree fns = lookup_name (fnname);\n+  if (fns && fns == get_global_binding (fnname))\n+    /* The instantiation can find these.  */\n+    return NULL_TREE;\n+  return fns;\n+}\n+\n+/* E is an expression representing an operation with dependent type, so we\n+   don't know yet whether it will use the built-in meaning of the operator or a\n+   function.  Remember declarations of that operator in scope.  */\n+\n+const char *const op_bind_attrname = \"operator bindings\";\n+\n+void\n+maybe_save_operator_binding (tree e)\n+{\n+  /* This is only useful in a generic lambda.  */\n+  if (!processing_template_decl)\n+    return;\n+  tree cfn = current_function_decl;\n+  if (!cfn)\n+    return;\n+\n+  /* Let's only do this for generic lambdas for now, we could do it for all\n+     function templates if we wanted to.  */\n+  if (!current_lambda_expr())\n+    return;\n+\n+  tree fnname = ovl_op_identifier (false, TREE_CODE (e));\n+  if (!fnname)\n+    return;\n+\n+  tree attributes = DECL_ATTRIBUTES (cfn);\n+  tree attr = lookup_attribute (op_bind_attrname, attributes);\n+  tree bindings = NULL_TREE;\n+  tree fns = NULL_TREE;\n+  if (attr)\n+    {\n+      bindings = TREE_VALUE (attr);\n+      if (tree elt = purpose_member (fnname, bindings))\n+\tfns = TREE_VALUE (elt);\n+    }\n+\n+  if (!fns && (fns = op_unqualified_lookup (fnname)))\n+    {\n+      bindings = tree_cons (fnname, fns, bindings);\n+      if (attr)\n+\tTREE_VALUE (attr) = bindings;\n+      else\n+\tDECL_ATTRIBUTES (cfn)\n+\t  = tree_cons (get_identifier (op_bind_attrname),\n+\t\t       bindings,\n+\t\t       attributes);\n+    }\n+}\n+\n+/* Called from cp_free_lang_data so we don't put this into LTO.  */\n+\n+void\n+discard_operator_bindings (tree decl)\n+{\n+  DECL_ATTRIBUTES (decl) = remove_attribute (op_bind_attrname,\n+\t\t\t\t\t     DECL_ATTRIBUTES (decl));\n+}\n+\n+/* Subroutine of start_preparsed_function: push the bindings we saved away in\n+   maybe_save_op_lookup into the function parameter binding level.  */\n+\n+void\n+push_operator_bindings ()\n+{\n+  tree decl1 = current_function_decl;\n+  if (tree attr = lookup_attribute (op_bind_attrname,\n+\t\t\t\t    DECL_ATTRIBUTES (decl1)))\n+    for (tree binds = TREE_VALUE (attr); binds; binds = TREE_CHAIN (binds))\n+      {\n+\ttree name = TREE_PURPOSE (binds);\n+\ttree val = TREE_VALUE (binds);\n+\tpush_local_binding (name, val, /*using*/true);\n+      }\n+}\n+\n #include \"gt-cp-name-lookup.h\""}, {"sha": "a47486d1b8a9c209c73166773147c3408f936b9e", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bddee796d0b4800b5ac3d7e7e9e315c23799424d/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bddee796d0b4800b5ac3d7e7e9e315c23799424d/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=bddee796d0b4800b5ac3d7e7e9e315c23799424d", "patch": "@@ -330,5 +330,8 @@ extern void push_nested_namespace (tree);\n extern void pop_nested_namespace (tree);\n extern void push_to_top_level (void);\n extern void pop_from_top_level (void);\n+extern void maybe_save_operator_binding (tree);\n+extern void push_operator_bindings (void);\n+extern void discard_operator_bindings (tree);\n \n #endif /* GCC_CP_NAME_LOOKUP_H */"}, {"sha": "eca6b523c5f32aa660c2016aca909a374530886f", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bddee796d0b4800b5ac3d7e7e9e315c23799424d/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bddee796d0b4800b5ac3d7e7e9e315c23799424d/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=bddee796d0b4800b5ac3d7e7e9e315c23799424d", "patch": "@@ -5398,6 +5398,8 @@ cp_free_lang_data (tree t)\n       DECL_EXTERNAL (t) = 1;\n       TREE_STATIC (t) = 0;\n     }\n+  if (TREE_CODE (t) == FUNCTION_DECL)\n+    discard_operator_bindings (t);\n   if (TREE_CODE (t) == NAMESPACE_DECL)\n     /* We do not need the leftover chaining of namespaces from the\n        binding level.  */"}, {"sha": "8d9224b668e2ad74949d08ab7fcf29dd31dca7fd", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bddee796d0b4800b5ac3d7e7e9e315c23799424d/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bddee796d0b4800b5ac3d7e7e9e315c23799424d/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=bddee796d0b4800b5ac3d7e7e9e315c23799424d", "patch": "@@ -4141,7 +4141,11 @@ build_x_binary_op (const op_location_t &loc, enum tree_code code, tree arg1,\n     {\n       if (type_dependent_expression_p (arg1)\n \t  || type_dependent_expression_p (arg2))\n-\treturn build_min_nt_loc (loc, code, arg1, arg2);\n+\t{\n+\t  expr = build_min_nt_loc (loc, code, arg1, arg2);\n+\t  maybe_save_operator_binding (expr);\n+\t  return expr;\n+\t}\n       arg1 = build_non_dependent_expr (arg1);\n       arg2 = build_non_dependent_expr (arg2);\n     }\n@@ -5725,7 +5729,11 @@ build_x_unary_op (location_t loc, enum tree_code code, cp_expr xarg,\n   if (processing_template_decl)\n     {\n       if (type_dependent_expression_p (xarg))\n-\treturn build_min_nt_loc (loc, code, xarg.get_value (), NULL_TREE);\n+\t{\n+\t  tree e = build_min_nt_loc (loc, code, xarg.get_value (), NULL_TREE);\n+\t  maybe_save_operator_binding (e);\n+\t  return e;\n+\t}\n \n       xarg = build_non_dependent_expr (xarg);\n     }"}, {"sha": "2912a754a8119967344a2c1f49608b2bfbfc5703", "filename": "gcc/testsuite/g++.dg/cpp1y/lambda-generic-using1.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bddee796d0b4800b5ac3d7e7e9e315c23799424d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-generic-using1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bddee796d0b4800b5ac3d7e7e9e315c23799424d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-generic-using1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-generic-using1.C?ref=bddee796d0b4800b5ac3d7e7e9e315c23799424d", "patch": "@@ -0,0 +1,29 @@\n+// PR c++/88123\n+// { dg-do compile { target c++14 } }\n+\n+struct bar {};\n+struct baz {};\n+struct baq {};\n+\n+namespace foo\n+{\n+  void operator+(bar);\n+} // namespace foo\n+\n+namespace foo2\n+{\n+  void operator-(baz);\n+}  \n+\n+auto fn() {\n+  using foo::operator+;\n+  using namespace foo2;\n+  extern void operator!(baq);\n+  return [](auto x, auto y, auto z) { +x; -y; !z; };\n+}\n+\n+int main()\n+{\n+  auto l = fn();\n+  l(bar(),baz(),baq());\n+}"}]}