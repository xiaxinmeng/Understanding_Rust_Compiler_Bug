{"sha": "0bfc3f69702dc3162629a236fa21987bebf6524a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGJmYzNmNjk3MDJkYzMxNjI2MjlhMjM2ZmEyMTk4N2JlYmY2NTI0YQ==", "commit": {"author": {"name": "Adrian Straetling", "email": "straetling@de.ibm.com", "date": "2005-04-04T16:25:05Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2005-04-04T16:25:05Z"}, "message": "s390-protos.h: (s390_comparison...\n\n2005-04-04  Adrian Strae\ufffdtling  <straetling@de.ibm.com>\n\n\t* config/s390/s390-protos.h: (s390_comparison,\n\ts390_alc_comparison, s390_slb_comparison, const0_operand,\n\tconsttable_operand, larl_operand, s_operand,\n\tshift_count_operand, bras_sym_operand, load_multiple_operation,\n\tstore_multiple_operation, s390_plus_operand): Remove prototypes.\n\t(s390_legitimate_address_without_index_p): New prototype.\n\t* config/s390/s390.c: (SYMBOL_FLAG_ALIGN1, DISP_IN_RANGE): Move\n\tto s390.h.\n\t(s390_comparison, s390_alc_comparison, s390_slb_comparison,\n\tconst0_operand, consttable_operand, larl_operand, s_operand,\n\tshift_count_operand, bras_sym_operand, load_multiple_operation,\n\tstore_multiple_operation, s390_plus_operand): Move to\n\tpredicates.md.\n\t(check_mode): Remove.\n\t(s390_branch_condition_mask): Remove 'static'. Move prototype to\n\ts390-protos.h.\n\t(s390_legitimate_address_without_index_p): New.\n\t* config/s390/s390.h (PREDICATE_CODES): Remove.\n\t* config/s390/s390.md: Include predicates.md.\n\t* config/s390/predicates.md: New.\n\nFrom-SVN: r97554", "tree": {"sha": "c567b05d0418a1b19ea35e3f8c7e67c652e4e2ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c567b05d0418a1b19ea35e3f8c7e67c652e4e2ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0bfc3f69702dc3162629a236fa21987bebf6524a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bfc3f69702dc3162629a236fa21987bebf6524a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bfc3f69702dc3162629a236fa21987bebf6524a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bfc3f69702dc3162629a236fa21987bebf6524a/comments", "author": null, "committer": null, "parents": [{"sha": "df04438806922874ac6372c4f3e990a9fc7dfd90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df04438806922874ac6372c4f3e990a9fc7dfd90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df04438806922874ac6372c4f3e990a9fc7dfd90"}], "stats": {"total": 922, "additions": 437, "deletions": 485}, "files": [{"sha": "40926b4480cf38899ff0d004113792914117cf59", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bfc3f69702dc3162629a236fa21987bebf6524a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bfc3f69702dc3162629a236fa21987bebf6524a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0bfc3f69702dc3162629a236fa21987bebf6524a", "patch": "@@ -1,3 +1,26 @@\n+2005-04-04  Adrian Strae\ufffdtling  <straetling@de.ibm.com>\n+\n+\t* config/s390/s390-protos.h: (s390_comparison,\n+\ts390_alc_comparison, s390_slb_comparison, const0_operand,\n+\tconsttable_operand, larl_operand, s_operand,\n+\tshift_count_operand, bras_sym_operand, load_multiple_operation,\n+\tstore_multiple_operation, s390_plus_operand): Remove prototypes.\n+\t(s390_legitimate_address_without_index_p): New prototype.\n+\t* config/s390/s390.c: (SYMBOL_FLAG_ALIGN1, DISP_IN_RANGE): Move\n+\tto s390.h.\n+\t(s390_comparison, s390_alc_comparison, s390_slb_comparison,\n+\tconst0_operand, consttable_operand, larl_operand, s_operand,\n+\tshift_count_operand, bras_sym_operand, load_multiple_operation,\n+\tstore_multiple_operation, s390_plus_operand): Move to\n+\tpredicates.md.\n+\t(check_mode): Remove.\n+\t(s390_branch_condition_mask): Remove 'static'. Move prototype to\n+\ts390-protos.h.\n+\t(s390_legitimate_address_without_index_p): New.\n+\t* config/s390/s390.h (PREDICATE_CODES): Remove.\n+\t* config/s390/s390.md: Include predicates.md.\n+\t* config/s390/predicates.md: New.\n+\n 2005-04-04  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \tPR target/20446"}, {"sha": "9af62a886b9a39f2b7c8abceb531d3cf51fcea2c", "filename": "gcc/config/s390/predicates.md", "status": "added", "additions": 386, "deletions": 0, "changes": 386, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bfc3f69702dc3162629a236fa21987bebf6524a/gcc%2Fconfig%2Fs390%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bfc3f69702dc3162629a236fa21987bebf6524a/gcc%2Fconfig%2Fs390%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fpredicates.md?ref=0bfc3f69702dc3162629a236fa21987bebf6524a", "patch": "@@ -0,0 +1,386 @@\n+;; Predicate definitions for S/390 and zSeries.\n+;; Copyright (C) 2005 Free Software Foundation, Inc.\n+;; Contributed by Hartmut Penner (hpenner@de.ibm.com) and\n+;;                Ulrich Weigand (uweigand@de.ibm.com).\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+;; OP is the current operation.\n+;; MODE is the current operation mode.\n+\n+;; operands --------------------------------------------------------------\n+\n+;; Return true if OP a (const_int 0) operand.\n+\n+(define_predicate \"const0_operand\"\n+  (and (match_code \"const_int, const_double\")\n+       (match_test \"op == CONST0_RTX (mode)\")))\n+\n+;; Return true if OP is constant.\n+\n+(define_special_predicate \"consttable_operand\"\n+  (and (match_code \"symbol_ref, label_ref, const, const_int, const_double\")\n+       (match_test \"CONSTANT_P (op)\")))\n+\n+;; Return true if OP is a valid S-type operand.\n+\n+(define_predicate \"s_operand\"\n+  (and (match_code \"subreg, mem\")\n+       (match_operand 0 \"general_operand\"))\n+{\n+  /* Just like memory_operand, allow (subreg (mem ...))\n+     after reload.  */\n+  if (reload_completed\n+      && GET_CODE (op) == SUBREG\n+      && GET_CODE (SUBREG_REG (op)) == MEM)\n+    op = SUBREG_REG (op);\n+\n+  if (GET_CODE (op) != MEM)\n+    return false;\n+  if (!s390_legitimate_address_without_index_p (op))\n+    return false;\n+\n+  return true;\n+})\n+\n+;; Return true if OP is a valid operand for the BRAS instruction.\n+;; Allow SYMBOL_REFs and @PLT stubs.\n+\n+(define_special_predicate \"bras_sym_operand\"\n+  (ior (match_code \"symbol_ref\")\n+       (and (match_code \"const\")\n+\t    (and (match_test \"GET_CODE (XEXP (op, 0)) == UNSPEC\")\n+\t\t (match_test \"XINT (XEXP (op, 0), 1) == UNSPEC_PLT\")))))\n+\n+;; Return true if OP is a PLUS that is not a legitimate\n+;; operand for the LA instruction.\n+\n+(define_predicate \"s390_plus_operand\"\n+  (and (match_code \"plus\")\n+       (and (match_test \"mode == Pmode\")\n+\t    (match_test \"!legitimate_la_operand_p (op)\"))))\n+\n+;; Return true if OP is a valid shift count operand.\n+\n+(define_predicate \"shift_count_operand\"\n+  (match_code \"reg, subreg, plus, const_int\")\n+{\n+  HOST_WIDE_INT offset = 0;\n+\n+  /* We can have an integer constant, an address register,\n+     or a sum of the two.  Note that reload already checks\n+     that any register present is an address register, so\n+     we just check for any register here.  */\n+  if (GET_CODE (op) == CONST_INT)\n+    {\n+      offset = INTVAL (op);\n+      op = NULL_RTX;\n+    }\n+  if (op && GET_CODE (op) == PLUS && GET_CODE (XEXP (op, 1)) == CONST_INT)\n+    {\n+      offset = INTVAL (XEXP (op, 1));\n+      op = XEXP (op, 0);\n+    }\n+  while (op && GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+  if (op && GET_CODE (op) != REG)\n+    return false;\n+\n+  /* Unfortunately we have to reject constants that are invalid\n+     for an address, or else reload will get confused.  */\n+  if (!DISP_IN_RANGE (offset))\n+    return false;\n+\n+  return true;\n+})\n+\n+;;  Return true if OP a valid operand for the LARL instruction.\n+\n+(define_predicate \"larl_operand\"\n+  (match_code \"label_ref, symbol_ref, const, const_int, const_double\")\n+{\n+  /* Allow labels and local symbols.  */\n+  if (GET_CODE (op) == LABEL_REF)\n+    return true;\n+  if (GET_CODE (op) == SYMBOL_REF)\n+    return ((SYMBOL_REF_FLAGS (op) & SYMBOL_FLAG_ALIGN1) == 0\n+\t    && SYMBOL_REF_TLS_MODEL (op) == 0\n+\t    && (!flag_pic || SYMBOL_REF_LOCAL_P (op)));\n+\n+  /* Everything else must have a CONST, so strip it.  */\n+  if (GET_CODE (op) != CONST)\n+    return false;\n+  op = XEXP (op, 0);\n+\n+  /* Allow adding *even* in-range constants.  */\n+  if (GET_CODE (op) == PLUS)\n+    {\n+      if (GET_CODE (XEXP (op, 1)) != CONST_INT\n+          || (INTVAL (XEXP (op, 1)) & 1) != 0)\n+        return false;\n+      if (INTVAL (XEXP (op, 1)) >= (HOST_WIDE_INT)1 << 32\n+\t  || INTVAL (XEXP (op, 1)) < -((HOST_WIDE_INT)1 << 32))\n+        return false;\n+      op = XEXP (op, 0);\n+    }\n+\n+  /* Labels and local symbols allowed here as well.  */\n+  if (GET_CODE (op) == LABEL_REF)\n+    return true;\n+  if (GET_CODE (op) == SYMBOL_REF)\n+    return ((SYMBOL_REF_FLAGS (op) & SYMBOL_FLAG_ALIGN1) == 0\n+\t    && SYMBOL_REF_TLS_MODEL (op) == 0\n+\t    && (!flag_pic || SYMBOL_REF_LOCAL_P (op)));\n+\n+  /* Now we must have a @GOTENT offset or @PLT stub\n+     or an @INDNTPOFF TLS offset.  */\n+  if (GET_CODE (op) == UNSPEC\n+      && XINT (op, 1) == UNSPEC_GOTENT)\n+    return true;\n+  if (GET_CODE (op) == UNSPEC\n+      && XINT (op, 1) == UNSPEC_PLT)\n+    return true;\n+  if (GET_CODE (op) == UNSPEC\n+      && XINT (op, 1) == UNSPEC_INDNTPOFF)\n+    return true;\n+\n+  return false;\n+})\n+\n+;; operators --------------------------------------------------------------\n+\n+;; Return nonzero if OP is a valid comparison operator\n+;; for a branch condition.\n+\n+(define_predicate \"s390_comparison\"\n+  (match_code \"eq, ne, lt, gt, le, ge, ltu, gtu, leu, geu,\n+\t       uneq, unlt, ungt, unle, unge, ltgt,\n+\t       unordered, ordered\")\n+{\n+  if (GET_CODE (XEXP (op, 0)) != REG\n+      || REGNO (XEXP (op, 0)) != CC_REGNUM\n+      || XEXP (op, 1) != const0_rtx)\n+    return false;\n+\n+  return (s390_branch_condition_mask (op) >= 0);\n+})\n+\n+;; Return nonzero if OP is a valid comparison operator\n+;; for an ALC condition.\n+\n+(define_predicate \"s390_alc_comparison\"\n+  (match_code \"zero_extend, sign_extend, ltu, gtu, leu, geu\")\n+{\n+  while (GET_CODE (op) == ZERO_EXTEND || GET_CODE (op) == SIGN_EXTEND)\n+    op = XEXP (op, 0);\n+\n+  if (!COMPARISON_P (op))\n+    return false;\n+\n+  if (GET_CODE (XEXP (op, 0)) != REG\n+      || REGNO (XEXP (op, 0)) != CC_REGNUM\n+      || XEXP (op, 1) != const0_rtx)\n+    return false;\n+\n+  switch (GET_MODE (XEXP (op, 0)))\n+    {\n+    case CCL1mode:\n+      return GET_CODE (op) == LTU;\n+\n+    case CCL2mode:\n+      return GET_CODE (op) == LEU;\n+\n+    case CCL3mode:\n+      return GET_CODE (op) == GEU;\n+\n+    case CCUmode:\n+      return GET_CODE (op) == GTU;\n+\n+    case CCURmode:\n+      return GET_CODE (op) == LTU;\n+\n+    case CCSmode:\n+      return GET_CODE (op) == UNGT;\n+\n+    case CCSRmode:\n+      return GET_CODE (op) == UNLT;\n+\n+    default:\n+      return false;\n+    }\n+})\n+\n+;; Return nonzero if OP is a valid comparison operator\n+;; for an SLB condition.\n+\n+(define_predicate \"s390_slb_comparison\"\n+  (match_code \"zero_extend, sign_extend, ltu, gtu, leu, geu\")\n+{\n+  while (GET_CODE (op) == ZERO_EXTEND || GET_CODE (op) == SIGN_EXTEND)\n+    op = XEXP (op, 0);\n+\n+  if (!COMPARISON_P (op))\n+    return false;\n+\n+  if (GET_CODE (XEXP (op, 0)) != REG\n+      || REGNO (XEXP (op, 0)) != CC_REGNUM\n+      || XEXP (op, 1) != const0_rtx)\n+    return false;\n+\n+  switch (GET_MODE (XEXP (op, 0)))\n+    {\n+    case CCL1mode:\n+      return GET_CODE (op) == GEU;\n+\n+    case CCL2mode:\n+      return GET_CODE (op) == GTU;\n+\n+    case CCL3mode:\n+      return GET_CODE (op) == LTU;\n+\n+    case CCUmode:\n+      return GET_CODE (op) == LEU;\n+\n+    case CCURmode:\n+      return GET_CODE (op) == GEU;\n+\n+    case CCSmode:\n+      return GET_CODE (op) == LE;\n+\n+    case CCSRmode:\n+      return GET_CODE (op) == GE;\n+\n+    default:\n+      return false;\n+    }\n+})\n+\n+;; Return true if OP is a load multiple operation.  It is known to be a\n+;; PARALLEL and the first section will be tested.\n+\n+(define_special_predicate \"load_multiple_operation\"\n+  (match_code \"parallel\")\n+{\n+  enum machine_mode elt_mode;\n+  int count = XVECLEN (op, 0);\n+  unsigned int dest_regno;\n+  rtx src_addr;\n+  int i, off;\n+\n+  /* Perform a quick check so we don't blow up below.  */\n+  if (count <= 1\n+      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n+      || GET_CODE (SET_DEST (XVECEXP (op, 0, 0))) != REG\n+      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != MEM)\n+    return false;\n+\n+  dest_regno = REGNO (SET_DEST (XVECEXP (op, 0, 0)));\n+  src_addr = XEXP (SET_SRC (XVECEXP (op, 0, 0)), 0);\n+  elt_mode = GET_MODE (SET_DEST (XVECEXP (op, 0, 0)));\n+\n+  /* Check, is base, or base + displacement.  */\n+\n+  if (GET_CODE (src_addr) == REG)\n+    off = 0;\n+  else if (GET_CODE (src_addr) == PLUS\n+\t   && GET_CODE (XEXP (src_addr, 0)) == REG\n+\t   && GET_CODE (XEXP (src_addr, 1)) == CONST_INT)\n+    {\n+      off = INTVAL (XEXP (src_addr, 1));\n+      src_addr = XEXP (src_addr, 0);\n+    }\n+  else\n+    return false;\n+\n+  for (i = 1; i < count; i++)\n+    {\n+      rtx elt = XVECEXP (op, 0, i);\n+\n+      if (GET_CODE (elt) != SET\n+\t  || GET_CODE (SET_DEST (elt)) != REG\n+\t  || GET_MODE (SET_DEST (elt)) != elt_mode\n+\t  || REGNO (SET_DEST (elt)) != dest_regno + i\n+\t  || GET_CODE (SET_SRC (elt)) != MEM\n+\t  || GET_MODE (SET_SRC (elt)) != elt_mode\n+\t  || GET_CODE (XEXP (SET_SRC (elt), 0)) != PLUS\n+\t  || ! rtx_equal_p (XEXP (XEXP (SET_SRC (elt), 0), 0), src_addr)\n+\t  || GET_CODE (XEXP (XEXP (SET_SRC (elt), 0), 1)) != CONST_INT\n+\t  || INTVAL (XEXP (XEXP (SET_SRC (elt), 0), 1))\n+\t     != off + i * GET_MODE_SIZE (elt_mode))\n+\treturn false;\n+    }\n+\n+  return true;\n+})\n+\n+;; Return true if OP is a store multiple operation.  It is known to be a\n+;; PARALLEL and the first section will be tested.\n+\n+(define_special_predicate \"store_multiple_operation\"\n+  (match_code \"parallel\")\n+{\n+  enum machine_mode elt_mode;\n+  int count = XVECLEN (op, 0);\n+  unsigned int src_regno;\n+  rtx dest_addr;\n+  int i, off;\n+\n+  /* Perform a quick check so we don't blow up below.  */\n+  if (count <= 1\n+      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n+      || GET_CODE (SET_DEST (XVECEXP (op, 0, 0))) != MEM\n+      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != REG)\n+    return false;\n+\n+  src_regno = REGNO (SET_SRC (XVECEXP (op, 0, 0)));\n+  dest_addr = XEXP (SET_DEST (XVECEXP (op, 0, 0)), 0);\n+  elt_mode = GET_MODE (SET_SRC (XVECEXP (op, 0, 0)));\n+\n+  /* Check, is base, or base + displacement.  */\n+\n+  if (GET_CODE (dest_addr) == REG)\n+    off = 0;\n+  else if (GET_CODE (dest_addr) == PLUS\n+\t   && GET_CODE (XEXP (dest_addr, 0)) == REG\n+\t   && GET_CODE (XEXP (dest_addr, 1)) == CONST_INT)\n+    {\n+      off = INTVAL (XEXP (dest_addr, 1));\n+      dest_addr = XEXP (dest_addr, 0);\n+    }\n+  else\n+    return false;\n+\n+  for (i = 1; i < count; i++)\n+    {\n+      rtx elt = XVECEXP (op, 0, i);\n+\n+      if (GET_CODE (elt) != SET\n+\t  || GET_CODE (SET_SRC (elt)) != REG\n+\t  || GET_MODE (SET_SRC (elt)) != elt_mode\n+\t  || REGNO (SET_SRC (elt)) != src_regno + i\n+\t  || GET_CODE (SET_DEST (elt)) != MEM\n+\t  || GET_MODE (SET_DEST (elt)) != elt_mode\n+\t  || GET_CODE (XEXP (SET_DEST (elt), 0)) != PLUS\n+\t  || ! rtx_equal_p (XEXP (XEXP (SET_DEST (elt), 0), 0), dest_addr)\n+\t  || GET_CODE (XEXP (XEXP (SET_DEST (elt), 0), 1)) != CONST_INT\n+\t  || INTVAL (XEXP (XEXP (SET_DEST (elt), 0), 1))\n+\t     != off + i * GET_MODE_SIZE (elt_mode))\n+\treturn false;\n+    }\n+  return true;\n+})"}, {"sha": "e8f94efe3e3edd0c6547184437dd78abc6eddf4a", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bfc3f69702dc3162629a236fa21987bebf6524a/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bfc3f69702dc3162629a236fa21987bebf6524a/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=0bfc3f69702dc3162629a236fa21987bebf6524a", "patch": "@@ -33,14 +33,6 @@ extern void s390_conditional_register_usage (void);\n #ifdef RTX_CODE\n extern int s390_extra_constraint_str (rtx, int, const char *);\n extern int s390_const_ok_for_constraint_p (HOST_WIDE_INT, int, const char *);\n-extern int const0_operand (rtx, enum machine_mode);\n-extern int consttable_operand (rtx, enum machine_mode);\n-extern int larl_operand (rtx, enum machine_mode);\n-extern int s_operand (rtx, enum machine_mode);\n-extern int shift_count_operand (rtx, enum machine_mode);\n-extern int bras_sym_operand (rtx, enum machine_mode);\n-extern int load_multiple_operation (rtx, enum machine_mode);\n-extern int store_multiple_operation (rtx, enum machine_mode);\n extern int s390_single_part (rtx, enum machine_mode, enum machine_mode, int);\n extern unsigned HOST_WIDE_INT s390_extract_part (rtx, enum machine_mode, int);\n extern bool s390_split_ok_p (rtx, rtx, enum machine_mode, int);\n@@ -51,9 +43,6 @@ extern int s390_match_ccmode (rtx, enum machine_mode);\n extern enum machine_mode s390_tm_ccmode (rtx, rtx, int);\n extern enum machine_mode s390_select_ccmode (enum rtx_code, rtx, rtx);\n extern void s390_canonicalize_comparison (enum rtx_code *, rtx *, rtx *);\n-extern int s390_comparison (rtx op, enum machine_mode mode);\n-extern int s390_alc_comparison (rtx op, enum machine_mode mode);\n-extern int s390_slb_comparison (rtx op, enum machine_mode mode);\n extern rtx s390_emit_compare (enum rtx_code, rtx, rtx);\n extern void s390_emit_jump (rtx, rtx);\n extern int symbolic_reference_mentioned_p (rtx);\n@@ -74,7 +63,6 @@ extern enum reg_class s390_secondary_input_reload_class (enum reg_class,\n extern enum reg_class s390_secondary_output_reload_class (enum reg_class,\n \t\t\t\t\t\t\t  enum machine_mode,\n \t\t\t\t\t\t\t  rtx);\n-extern int s390_plus_operand (rtx, enum machine_mode);\n extern void s390_expand_plus_operand (rtx, rtx, rtx);\n extern void emit_symbolic_move (rtx *);\n extern void s390_load_address (rtx, rtx);\n@@ -103,6 +91,8 @@ extern void s390_output_dwarf_dtprel (FILE*, int, rtx);\n extern int s390_agen_dep_p (rtx, rtx);\n extern rtx s390_load_got (void);\n extern void s390_emit_tpf_eh_return (rtx);\n+extern bool s390_legitimate_address_without_index_p (rtx);\n+extern int s390_branch_condition_mask (rtx);\n \n #endif /* RTX_CODE */\n "}, {"sha": "8bbe3f59ebc2f421af7fe43288890fdbe5005adb", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 15, "deletions": 453, "changes": 468, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bfc3f69702dc3162629a236fa21987bebf6524a/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bfc3f69702dc3162629a236fa21987bebf6524a/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=0bfc3f69702dc3162629a236fa21987bebf6524a", "patch": "@@ -52,9 +52,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"optabs.h\"\n #include \"tree-gimple.h\"\n \n-/* Machine-specific symbol_ref flags.  */\n-#define SYMBOL_FLAG_ALIGN1\t(SYMBOL_FLAG_MACH_DEP << 0)\n-\n \n static bool s390_assemble_integer (rtx, unsigned int, int);\n static void s390_encode_section_info (tree, rtx, int);\n@@ -380,9 +377,7 @@ struct machine_function GTY(())\n   (1 << (BITNUM))))\n \n static int s390_match_ccmode_set (rtx, enum machine_mode);\n-static int s390_branch_condition_mask (rtx);\n static const char *s390_branch_condition_mnemonic (rtx, int);\n-static int check_mode (rtx, enum machine_mode *);\n static int s390_short_displacement (rtx);\n static int s390_decompose_address (rtx, struct s390_address *);\n static rtx get_thread_pointer (void);\n@@ -413,10 +408,20 @@ static int s390_function_arg_size (enum machine_mode, tree);\n static bool s390_function_arg_float (enum machine_mode, tree);\n static struct machine_function * s390_init_machine_status (void);\n \n-/* Check whether integer displacement is in range.  */\n-#define DISP_IN_RANGE(d) \\\n-  (TARGET_LONG_DISPLACEMENT? ((d) >= -524288 && (d) <= 524287) \\\n-                           : ((d) >= 0 && (d) <= 4095))\n+/* Return true if CODE is a valid address without index.  */\n+\n+bool\n+s390_legitimate_address_without_index_p (rtx op)\n+{\n+  struct s390_address addr;\n+\n+  if (!s390_decompose_address (XEXP (op, 0), &addr))\n+    return false;\n+  if (addr.indx)\n+    return false;\n+\n+  return true;\n+}\n \n /* Return true if SET either doesn't set the CC register, or else\n    the source and destination have matching CC modes and that\n@@ -791,126 +796,10 @@ s390_emit_jump (rtx target, rtx cond)\n   emit_jump_insn (insn);\n }\n \n-/* Return nonzero if OP is a valid comparison operator\n-   for a branch condition in mode MODE.  */\n-\n-int\n-s390_comparison (rtx op, enum machine_mode mode)\n-{\n-  if (mode != VOIDmode && mode != GET_MODE (op))\n-    return 0;\n-\n-  if (!COMPARISON_P (op))\n-    return 0;\n-\n-  if (GET_CODE (XEXP (op, 0)) != REG\n-      || REGNO (XEXP (op, 0)) != CC_REGNUM\n-      || XEXP (op, 1) != const0_rtx)\n-    return 0;\n-\n-  return s390_branch_condition_mask (op) >= 0;\n-}\n-\n-/* Return nonzero if OP is a valid comparison operator\n-   for an ALC condition in mode MODE.  */\n-\n-int\n-s390_alc_comparison (rtx op, enum machine_mode mode)\n-{\n-  if (mode != VOIDmode && mode != GET_MODE (op))\n-    return 0;\n-\n-  while (GET_CODE (op) == ZERO_EXTEND || GET_CODE (op) == SIGN_EXTEND)\n-    op = XEXP (op, 0);\n-\n-  if (!COMPARISON_P (op))\n-    return 0;\n-\n-  if (GET_CODE (XEXP (op, 0)) != REG\n-      || REGNO (XEXP (op, 0)) != CC_REGNUM\n-      || XEXP (op, 1) != const0_rtx)\n-    return 0;\n-\n-  switch (GET_MODE (XEXP (op, 0)))\n-    {\n-    case CCL1mode:\n-      return GET_CODE (op) == LTU;\n-\n-    case CCL2mode:\n-      return GET_CODE (op) == LEU;\n-\n-    case CCL3mode:\n-      return GET_CODE (op) == GEU;\n-\n-    case CCUmode:\n-      return GET_CODE (op) == GTU;\n-\n-    case CCURmode:\n-      return GET_CODE (op) == LTU;\n-\n-    case CCSmode:\n-      return GET_CODE (op) == UNGT;\n-\n-    case CCSRmode:\n-      return GET_CODE (op) == UNLT;\n-\n-    default:\n-      return 0;\n-    }\n-}\n-\n-/* Return nonzero if OP is a valid comparison operator\n-   for an SLB condition in mode MODE.  */\n-\n-int\n-s390_slb_comparison (rtx op, enum machine_mode mode)\n-{\n-  if (mode != VOIDmode && mode != GET_MODE (op))\n-    return 0;\n-\n-  while (GET_CODE (op) == ZERO_EXTEND || GET_CODE (op) == SIGN_EXTEND)\n-    op = XEXP (op, 0);\n-\n-  if (!COMPARISON_P (op))\n-    return 0;\n-\n-  if (GET_CODE (XEXP (op, 0)) != REG\n-      || REGNO (XEXP (op, 0)) != CC_REGNUM\n-      || XEXP (op, 1) != const0_rtx)\n-    return 0;\n-\n-  switch (GET_MODE (XEXP (op, 0)))\n-    {\n-    case CCL1mode:\n-      return GET_CODE (op) == GEU;\n-\n-    case CCL2mode:\n-      return GET_CODE (op) == GTU;\n-\n-    case CCL3mode:\n-      return GET_CODE (op) == LTU;\n-\n-    case CCUmode:\n-      return GET_CODE (op) == LEU;\n-\n-    case CCURmode:\n-      return GET_CODE (op) == GEU;\n-\n-    case CCSmode:\n-      return GET_CODE (op) == LE;\n-\n-    case CCSRmode:\n-      return GET_CODE (op) == GE;\n-\n-    default:\n-      return 0;\n-    }\n-}\n-\n /* Return branch condition mask to implement a branch\n    specified by CODE.  Return -1 for invalid comparisons.  */\n \n-static int\n+int\n s390_branch_condition_mask (rtx code)\n {\n   const int CC0 = 1 << 3;\n@@ -1508,172 +1397,6 @@ s390_safe_attr_type (rtx insn)\n     return TYPE_NONE;\n }\n \n-/* Return true if OP a (const_int 0) operand.\n-   OP is the current operation.\n-   MODE is the current operation mode.  */\n-\n-int\n-const0_operand (register rtx op, enum machine_mode mode)\n-{\n-  return op == CONST0_RTX (mode);\n-}\n-\n-/* Return true if OP is constant.\n-   OP is the current operation.\n-   MODE is the current operation mode.  */\n-\n-int\n-consttable_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return CONSTANT_P (op);\n-}\n-\n-/* Return true if the mode of operand OP matches MODE.\n-   If MODE is set to VOIDmode, set it to the mode of OP.  */\n-\n-static int\n-check_mode (register rtx op, enum machine_mode *mode)\n-{\n-  if (*mode == VOIDmode)\n-      *mode = GET_MODE (op);\n-  else\n-  {\n-    if (GET_MODE (op) != VOIDmode && GET_MODE (op) != *mode)\n-       return 0;\n-  }\n-  return 1;\n-}\n-\n-/* Return true if OP a valid operand for the LARL instruction.\n-   OP is the current operation.\n-   MODE is the current operation mode.  */\n-\n-int\n-larl_operand (register rtx op, enum machine_mode mode)\n-{\n-  if (! check_mode (op, &mode))\n-    return 0;\n-\n-  /* Allow labels and local symbols.  */\n-  if (GET_CODE (op) == LABEL_REF)\n-    return 1;\n-  if (GET_CODE (op) == SYMBOL_REF)\n-    return ((SYMBOL_REF_FLAGS (op) & SYMBOL_FLAG_ALIGN1) == 0\n-\t    && SYMBOL_REF_TLS_MODEL (op) == 0\n-\t    && (!flag_pic || SYMBOL_REF_LOCAL_P (op)));\n-\n-  /* Everything else must have a CONST, so strip it.  */\n-  if (GET_CODE (op) != CONST)\n-    return 0;\n-  op = XEXP (op, 0);\n-\n-  /* Allow adding *even* in-range constants.  */\n-  if (GET_CODE (op) == PLUS)\n-    {\n-      if (GET_CODE (XEXP (op, 1)) != CONST_INT\n-          || (INTVAL (XEXP (op, 1)) & 1) != 0)\n-        return 0;\n-#if HOST_BITS_PER_WIDE_INT > 32\n-      if (INTVAL (XEXP (op, 1)) >= (HOST_WIDE_INT)1 << 32\n-\t  || INTVAL (XEXP (op, 1)) < -((HOST_WIDE_INT)1 << 32))\n-        return 0;\n-#endif\n-      op = XEXP (op, 0);\n-    }\n-\n-  /* Labels and local symbols allowed here as well.  */\n-  if (GET_CODE (op) == LABEL_REF)\n-    return 1;\n-  if (GET_CODE (op) == SYMBOL_REF)\n-    return ((SYMBOL_REF_FLAGS (op) & SYMBOL_FLAG_ALIGN1) == 0\n-\t    && SYMBOL_REF_TLS_MODEL (op) == 0\n-\t    && (!flag_pic || SYMBOL_REF_LOCAL_P (op)));\n-\n-  /* Now we must have a @GOTENT offset or @PLT stub\n-     or an @INDNTPOFF TLS offset.  */\n-  if (GET_CODE (op) == UNSPEC\n-      && XINT (op, 1) == UNSPEC_GOTENT)\n-    return 1;\n-  if (GET_CODE (op) == UNSPEC\n-      && XINT (op, 1) == UNSPEC_PLT)\n-    return 1;\n-  if (GET_CODE (op) == UNSPEC\n-      && XINT (op, 1) == UNSPEC_INDNTPOFF)\n-    return 1;\n-\n-  return 0;\n-}\n-\n-/* Return true if OP is a valid S-type operand.\n-   OP is the current operation.\n-   MODE is the current operation mode.  */\n-\n-int\n-s_operand (rtx op, enum machine_mode mode)\n-{\n-  struct s390_address addr;\n-\n-  /* Call general_operand first, so that we don't have to\n-     check for many special cases.  */\n-  if (!general_operand (op, mode))\n-    return 0;\n-\n-  /* Just like memory_operand, allow (subreg (mem ...))\n-     after reload.  */\n-  if (reload_completed\n-      && GET_CODE (op) == SUBREG\n-      && GET_CODE (SUBREG_REG (op)) == MEM)\n-    op = SUBREG_REG (op);\n-\n-  if (GET_CODE (op) != MEM)\n-    return 0;\n-  if (!s390_decompose_address (XEXP (op, 0), &addr))\n-    return 0;\n-  if (addr.indx)\n-    return 0;\n-\n-  return 1;\n-}\n-\n-/* Return true if OP a valid shift count operand.\n-   OP is the current operation.\n-   MODE is the current operation mode.  */\n-\n-int\n-shift_count_operand (rtx op, enum machine_mode mode)\n-{\n-  HOST_WIDE_INT offset = 0;\n-\n-  if (! check_mode (op, &mode))\n-    return 0;\n-\n-  /* We can have an integer constant, an address register,\n-     or a sum of the two.  Note that reload already checks\n-     that any register present is an address register, so\n-     we just check for any register here.  */\n-  if (GET_CODE (op) == CONST_INT)\n-    {\n-      offset = INTVAL (op);\n-      op = NULL_RTX;\n-    }\n-  if (op && GET_CODE (op) == PLUS && GET_CODE (XEXP (op, 1)) == CONST_INT)\n-    {\n-      offset = INTVAL (XEXP (op, 1));\n-      op = XEXP (op, 0);\n-    }\n-  while (op && GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-  if (op && GET_CODE (op) != REG)\n-    return 0;\n-\n-  /* Unfortunately we have to reject constants that are invalid\n-     for an address, or else reload will get confused.  */\n-  if (!DISP_IN_RANGE (offset))\n-    return 0;\n-\n-  return 1;\n-}\n-\n /* Return true if DISP is a valid short displacement.  */\n \n static int\n@@ -2112,27 +1835,6 @@ s390_address_cost (rtx addr)\n   return ad.indx? COSTS_N_INSNS (1) + 1 : COSTS_N_INSNS (1);\n }\n \n-/* Return true if OP is a valid operand for the BRAS instruction.\n-   OP is the current operation.\n-   MODE is the current operation mode.  */\n-\n-int\n-bras_sym_operand (register rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  register enum rtx_code code = GET_CODE (op);\n-\n-  /* Allow SYMBOL_REFs.  */\n-  if (code == SYMBOL_REF)\n-    return 1;\n-\n-  /* Allow @PLT stubs.  */\n-  if (code == CONST\n-      && GET_CODE (XEXP (op, 0)) == UNSPEC\n-      && XINT (XEXP (op, 0), 1) == UNSPEC_PLT)\n-    return 1;\n-  return 0;\n-}\n-\n /* If OP is a SYMBOL_REF of a thread-local symbol, return its TLS mode,\n    otherwise return 0.  */\n \n@@ -2144,126 +1846,6 @@ tls_symbolic_operand (register rtx op)\n   return SYMBOL_REF_TLS_MODEL (op);\n }\n \f\n-/* Return true if OP is a load multiple operation.  It is known to be a\n-   PARALLEL and the first section will be tested.\n-   OP is the current operation.\n-   MODE is the current operation mode.  */\n-\n-int\n-load_multiple_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  enum machine_mode elt_mode;\n-  int count = XVECLEN (op, 0);\n-  unsigned int dest_regno;\n-  rtx src_addr;\n-  int i, off;\n-\n-\n-  /* Perform a quick check so we don't blow up below.  */\n-  if (count <= 1\n-      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n-      || GET_CODE (SET_DEST (XVECEXP (op, 0, 0))) != REG\n-      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != MEM)\n-    return 0;\n-\n-  dest_regno = REGNO (SET_DEST (XVECEXP (op, 0, 0)));\n-  src_addr = XEXP (SET_SRC (XVECEXP (op, 0, 0)), 0);\n-  elt_mode = GET_MODE (SET_DEST (XVECEXP (op, 0, 0)));\n-\n-  /* Check, is base, or base + displacement.  */\n-\n-  if (GET_CODE (src_addr) == REG)\n-    off = 0;\n-  else if (GET_CODE (src_addr) == PLUS\n-\t   && GET_CODE (XEXP (src_addr, 0)) == REG\n-\t   && GET_CODE (XEXP (src_addr, 1)) == CONST_INT)\n-    {\n-      off = INTVAL (XEXP (src_addr, 1));\n-      src_addr = XEXP (src_addr, 0);\n-    }\n-  else\n-    return 0;\n-\n-  for (i = 1; i < count; i++)\n-    {\n-      rtx elt = XVECEXP (op, 0, i);\n-\n-      if (GET_CODE (elt) != SET\n-\t  || GET_CODE (SET_DEST (elt)) != REG\n-\t  || GET_MODE (SET_DEST (elt)) != elt_mode\n-\t  || REGNO (SET_DEST (elt)) != dest_regno + i\n-\t  || GET_CODE (SET_SRC (elt)) != MEM\n-\t  || GET_MODE (SET_SRC (elt)) != elt_mode\n-\t  || GET_CODE (XEXP (SET_SRC (elt), 0)) != PLUS\n-\t  || ! rtx_equal_p (XEXP (XEXP (SET_SRC (elt), 0), 0), src_addr)\n-\t  || GET_CODE (XEXP (XEXP (SET_SRC (elt), 0), 1)) != CONST_INT\n-\t  || INTVAL (XEXP (XEXP (SET_SRC (elt), 0), 1))\n-\t     != off + i * GET_MODE_SIZE (elt_mode))\n-\treturn 0;\n-    }\n-\n-  return 1;\n-}\n-\n-/* Return true if OP is a store multiple operation.  It is known to be a\n-   PARALLEL and the first section will be tested.\n-   OP is the current operation.\n-   MODE is the current operation mode.  */\n-\n-int\n-store_multiple_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  enum machine_mode elt_mode;\n-  int count = XVECLEN (op, 0);\n-  unsigned int src_regno;\n-  rtx dest_addr;\n-  int i, off;\n-\n-  /* Perform a quick check so we don't blow up below.  */\n-  if (count <= 1\n-      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n-      || GET_CODE (SET_DEST (XVECEXP (op, 0, 0))) != MEM\n-      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != REG)\n-    return 0;\n-\n-  src_regno = REGNO (SET_SRC (XVECEXP (op, 0, 0)));\n-  dest_addr = XEXP (SET_DEST (XVECEXP (op, 0, 0)), 0);\n-  elt_mode = GET_MODE (SET_SRC (XVECEXP (op, 0, 0)));\n-\n-  /* Check, is base, or base + displacement.  */\n-\n-  if (GET_CODE (dest_addr) == REG)\n-    off = 0;\n-  else if (GET_CODE (dest_addr) == PLUS\n-\t   && GET_CODE (XEXP (dest_addr, 0)) == REG\n-\t   && GET_CODE (XEXP (dest_addr, 1)) == CONST_INT)\n-    {\n-      off = INTVAL (XEXP (dest_addr, 1));\n-      dest_addr = XEXP (dest_addr, 0);\n-    }\n-  else\n-    return 0;\n-\n-  for (i = 1; i < count; i++)\n-    {\n-      rtx elt = XVECEXP (op, 0, i);\n-\n-      if (GET_CODE (elt) != SET\n-\t  || GET_CODE (SET_SRC (elt)) != REG\n-\t  || GET_MODE (SET_SRC (elt)) != elt_mode\n-\t  || REGNO (SET_SRC (elt)) != src_regno + i\n-\t  || GET_CODE (SET_DEST (elt)) != MEM\n-\t  || GET_MODE (SET_DEST (elt)) != elt_mode\n-\t  || GET_CODE (XEXP (SET_DEST (elt), 0)) != PLUS\n-\t  || ! rtx_equal_p (XEXP (XEXP (SET_DEST (elt), 0), 0), dest_addr)\n-\t  || GET_CODE (XEXP (XEXP (SET_DEST (elt), 0), 1)) != CONST_INT\n-\t  || INTVAL (XEXP (XEXP (SET_DEST (elt), 0), 1))\n-\t     != off + i * GET_MODE_SIZE (elt_mode))\n-\treturn 0;\n-    }\n-  return 1;\n-}\n-\n /* Split DImode access register reference REG (on 64-bit) into its constituent\n    low and high parts, and store them into LO and HI.  Note that gen_lowpart/\n    gen_highpart cannot be used as they assume all registers are word-sized,\n@@ -2570,26 +2152,6 @@ s390_secondary_output_reload_class (enum reg_class class,\n   return NO_REGS;\n }\n \n-/* Return true if OP is a PLUS that is not a legitimate\n-   operand for the LA instruction.\n-   OP is the current operation.\n-   MODE is the current operation mode.  */\n-\n-int\n-s390_plus_operand (register rtx op, enum machine_mode mode)\n-{\n-  if (!check_mode (op, &mode) || mode != Pmode)\n-    return FALSE;\n-\n-  if (GET_CODE (op) != PLUS)\n-    return FALSE;\n-\n-  if (legitimate_la_operand_p (op))\n-    return FALSE;\n-\n-  return TRUE;\n-}\n-\n /* Generate code to load SRC, which is PLUS that is not a\n    legitimate operand for the LA instruction, into TARGET.\n    SCRATCH may be used as scratch register.  */"}, {"sha": "af09184ce634c22167ee6a772f1939aebb8a7d84", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bfc3f69702dc3162629a236fa21987bebf6524a/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bfc3f69702dc3162629a236fa21987bebf6524a/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=0bfc3f69702dc3162629a236fa21987bebf6524a", "patch": "@@ -1043,26 +1043,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n /* Miscellaneous parameters.  */\n \n-/* Define the codes that are matched by predicates in aux-output.c.  */\n-#define PREDICATE_CODES\t\t\t\t\t\t\t\\\n-  {\"s_operand\",       { SUBREG, MEM }},\t\t\t\t\t\\\n-  {\"shift_count_operand\", { REG, SUBREG, PLUS, CONST_INT }},\t\t\\\n-  {\"bras_sym_operand\",{ SYMBOL_REF, CONST }},\t\t\t\t\\\n-  {\"larl_operand\",    { SYMBOL_REF, CONST, CONST_INT, CONST_DOUBLE }},\t\\\n-  {\"load_multiple_operation\", {PARALLEL}},\t\t\t        \\\n-  {\"store_multiple_operation\", {PARALLEL}},\t\t\t        \\\n-  {\"const0_operand\",  { CONST_INT, CONST_DOUBLE }},\t\t\t\\\n-  {\"consttable_operand\", { SYMBOL_REF, LABEL_REF, CONST, \t\t\\\n-\t\t\t   CONST_INT, CONST_DOUBLE }},\t\t\t\\\n-  {\"s390_plus_operand\", { PLUS }},\t\t\t\t\t\\\n-  {\"s390_comparison\",     { EQ, NE, LT, GT, LE, GE, LTU, GTU, LEU, GEU,\t\\\n-\t\t\t    UNEQ, UNLT, UNGT, UNLE, UNGE, LTGT,\t\t\\\n-\t\t\t    UNORDERED, ORDERED }},\t\t\t\\\n-  {\"s390_alc_comparison\", { ZERO_EXTEND, SIGN_EXTEND, \t\t\t\\\n-\t\t\t    LTU, GTU, LEU, GEU }},\t\t\t\\\n-  {\"s390_slb_comparison\", { ZERO_EXTEND, SIGN_EXTEND,\t\t\t\\\n-\t\t\t    LTU, GTU, LEU, GEU }},\n-\n /* Specify the machine mode that this machine uses for the index in the\n    tablejump instruction.  */\n #define CASE_VECTOR_MODE (TARGET_64BIT ? DImode : SImode)\n@@ -1083,4 +1063,12 @@ do {\t\t\t\t\t\t\t\t\t\\\n    indexing purposes) so give the MEM rtx a byte's mode.  */\n #define FUNCTION_MODE QImode\n \n+/* Machine-specific symbol_ref flags.  */\n+#define SYMBOL_FLAG_ALIGN1\t(SYMBOL_FLAG_MACH_DEP << 0)\n+\n+/* Check whether integer displacement is in range.  */\n+#define DISP_IN_RANGE(d) \\\n+  (TARGET_LONG_DISPLACEMENT? ((d) >= -524288 && (d) <= 524287) \\\n+                           : ((d) >= 0 && (d) <= 4095))\n+\n #endif"}, {"sha": "022d7791bba6d8f0bfbcc994139ba1ff8cfb0957", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bfc3f69702dc3162629a236fa21987bebf6524a/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bfc3f69702dc3162629a236fa21987bebf6524a/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=0bfc3f69702dc3162629a236fa21987bebf6524a", "patch": "@@ -229,6 +229,9 @@\n ;; Pipeline description for z990. \n (include \"2084.md\")\n \n+;; Predicates\n+(include \"predicates.md\")\n+\n ;;\n ;;- Compare instructions.\n ;;"}]}