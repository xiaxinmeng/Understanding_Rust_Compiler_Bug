{"sha": "36c735526202039b0dbc128cbf47fde38d39e21f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzZjNzM1NTI2MjAyMDM5YjBkYmMxMjhjYmY0N2ZkZTM4ZDM5ZTIxZg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-17T10:14:36Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-17T10:14:36Z"}, "message": "[multiple changes]\n\n2009-04-17  Thomas Quinot  <quinot@adacore.com>\n\n\t* sinfo.ads, exp_aggr.adb, exp_aggr.ads: Minor reformatting\n\n\t* exp_ch7.adb: Minor reformatting\n\n2009-04-17  Bob Duff  <duff@adacore.com>\n\n\t* exp_ch4.adb (Expand_Allocator_Expression): In an initialized\n\tallocator, check that the expression of the qualified expression obeys\n\tthe constraints of the subtype of the qualified expression.\n\n2009-04-17  Thomas Quinot  <quinot@adacore.com>\n\n\t* sprint.adb (Write_Itype): Add handling of enumeration subtypes.\n\nFrom-SVN: r146239", "tree": {"sha": "57c5b615c263c73c74f43f4d191d8cdf32df81d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57c5b615c263c73c74f43f4d191d8cdf32df81d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/36c735526202039b0dbc128cbf47fde38d39e21f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36c735526202039b0dbc128cbf47fde38d39e21f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36c735526202039b0dbc128cbf47fde38d39e21f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36c735526202039b0dbc128cbf47fde38d39e21f/comments", "author": null, "committer": null, "parents": [{"sha": "cac5a8014c2418c21917fef679a4243d97fce6b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cac5a8014c2418c21917fef679a4243d97fce6b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cac5a8014c2418c21917fef679a4243d97fce6b7"}], "stats": {"total": 120, "additions": 63, "deletions": 57}, "files": [{"sha": "6d0d2a6ba73f57370ac51f1838e1a8e2a447ce57", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36c735526202039b0dbc128cbf47fde38d39e21f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36c735526202039b0dbc128cbf47fde38d39e21f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=36c735526202039b0dbc128cbf47fde38d39e21f", "patch": "@@ -1,3 +1,19 @@\n+2009-04-17  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sinfo.ads, exp_aggr.adb, exp_aggr.ads: Minor reformatting\n+\n+\t* exp_ch7.adb: Minor reformatting\n+\n+2009-04-17  Bob Duff  <duff@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_Allocator_Expression): In an initialized\n+\tallocator, check that the expression of the qualified expression obeys\n+\tthe constraints of the subtype of the qualified expression.\n+\n+2009-04-17  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sprint.adb (Write_Itype): Add handling of enumeration subtypes.\n+\n 2009-04-17  Ed Schonberg  <schonberg@adacore.com>\n \n \t* exp_ch4.adb (Expand_Allocator_Expression): Apply constraint check to"}, {"sha": "22e44f4b74eb82b8b2e9a53e5df59a27b18ad4c9", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36c735526202039b0dbc128cbf47fde38d39e21f/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36c735526202039b0dbc128cbf47fde38d39e21f/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=36c735526202039b0dbc128cbf47fde38d39e21f", "patch": "@@ -3506,10 +3506,10 @@ package body Exp_Aggr is\n                  Is_Controlled (Typ) or else Has_Controlled_Component (Typ));\n       end if;\n \n-      --  If the aggregate is non-limited, create a temporary. If it is\n-      --  limited and the context is an assignment, this is a subaggregate\n-      --  for an enclosing aggregate being expanded. It must be built in place,\n-      --  so use the target of the current assignment.\n+      --  If the aggregate is non-limited, create a temporary. If it is limited\n+      --  and the context is an assignment, this is a subaggregate for an\n+      --  enclosing aggregate being expanded. It must be built in place, so use\n+      --  the target of the current assignment.\n \n       if Is_Limited_Type (Typ)\n         and then Nkind (Parent (N)) = N_Assignment_Statement\n@@ -4947,8 +4947,8 @@ package body Exp_Aggr is\n \n       --  STEP 3\n \n-      --  Delay expansion for nested aggregates it will be taken care of\n-      --  when the parent aggregate is expanded\n+      --  Delay expansion for nested aggregates: it will be taken care of\n+      --  when the parent aggregate is expanded.\n \n       Parent_Node := Parent (N);\n       Parent_Kind := Nkind (Parent_Node);\n@@ -4979,7 +4979,7 @@ package body Exp_Aggr is\n \n       --  STEP 4\n \n-      --  Look if in place aggregate expansion is possible\n+      --  Look if in place aggregate expansion is possible.\n \n       --  For object declarations we build the aggregate in place, unless\n       --  the array is bit-packed or the component is controlled.\n@@ -5018,8 +5018,8 @@ package body Exp_Aggr is\n               and then In_Place_Assign_OK);\n       end if;\n \n-      --  If  this is an array of tasks, it will be expanded into build-in-\n-      --  -place assignments. Build an activation chain for the tasks now\n+      --  If this is an array of tasks, it will be expanded into build-in-place\n+      --  assignments. Build an activation chain for the tasks now.\n \n       if Has_Task (Etype (N)) then\n          Build_Activation_Chain_Entity (N);\n@@ -5114,8 +5114,8 @@ package body Exp_Aggr is\n          Set_No_Initialization (Tmp_Decl, True);\n \n          --  If we are within a loop, the temporary will be pushed on the\n-         --  stack at each iteration. If the aggregate is the expression for\n-         --  an allocator, it will be immediately copied to the heap and can\n+         --  stack at each iteration. If the aggregate is the expression for an\n+         --  allocator, it will be immediately copied to the heap and can\n          --  be reclaimed at once. We create a transient scope around the\n          --  aggregate for this purpose.\n \n@@ -5128,9 +5128,9 @@ package body Exp_Aggr is\n          Insert_Action (N, Tmp_Decl);\n       end if;\n \n-      --  Construct and insert the aggregate code. We can safely suppress\n-      --  index checks because this code is guaranteed not to raise CE\n-      --  on index checks. However we should *not* suppress all checks.\n+      --  Construct and insert the aggregate code. We can safely suppress index\n+      --  checks because this code is guaranteed not to raise CE on index\n+      --  checks. However we should *not* suppress all checks.\n \n       declare\n          Target : Node_Id;"}, {"sha": "5d14f1d5fe150719c73c0091db880ec2f2e798a1", "filename": "gcc/ada/exp_aggr.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36c735526202039b0dbc128cbf47fde38d39e21f/gcc%2Fada%2Fexp_aggr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36c735526202039b0dbc128cbf47fde38d39e21f/gcc%2Fada%2Fexp_aggr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.ads?ref=36c735526202039b0dbc128cbf47fde38d39e21f", "patch": "@@ -34,9 +34,9 @@ package Exp_Aggr is\n    --  Returns True if N is an aggregate of some kind whose Expansion_Delayed\n    --  flag is set (see sinfo for meaning of flag).\n \n-   procedure Convert_Aggr_In_Object_Decl  (N : Node_Id);\n-   --  N is a N_Object_Declaration with an expression which must be\n-   --  an N_Aggregate or N_Extension_Aggregate with Expansion_Delayed\n+   procedure Convert_Aggr_In_Object_Decl (N : Node_Id);\n+   --  N is a N_Object_Declaration with an expression which must be an\n+   --  N_Aggregate or N_Extension_Aggregate with Expansion_Delayed.\n    --  This procedure performs in-place aggregate assignment.\n \n    procedure Convert_Aggr_In_Allocator"}, {"sha": "ef4dbc5198959eb97d4e4d2b7317fefae91f7312", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36c735526202039b0dbc128cbf47fde38d39e21f/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36c735526202039b0dbc128cbf47fde38d39e21f/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=36c735526202039b0dbc128cbf47fde38d39e21f", "patch": "@@ -977,15 +977,14 @@ package body Exp_Ch4 is\n             Rewrite (Exp, New_Copy (Expression (Exp)));\n          end if;\n       else\n-         --  First check against the type of the qualified expression\n-         --\n-         --  NOTE: The commented call should be correct, but for some reason\n-         --  causes the compiler to bomb (sigsegv) on ACVC test c34007g, so for\n-         --  now we just perform the old (incorrect) test against the\n-         --  designated subtype with no sliding in the else part of the if\n-         --  statement below. ???\n-         --\n-         --  Apply_Constraint_Check (Exp, T, No_Sliding => True);\n+         --  If we have:\n+         --    type A is access T1;\n+         --    X : A := new T2'(...);\n+         --  T1 and T2 can be different subtypes, and we might need to check\n+         --  both constraints. First check against the type of the qualified\n+         --  expression.\n+\n+         Apply_Constraint_Check (Exp, T, No_Sliding => True);\n \n          --  A check is also needed in cases where the designated subtype is\n          --  constrained and differs from the subtype given in the qualified\n@@ -997,14 +996,6 @@ package body Exp_Ch4 is\n          then\n             Apply_Constraint_Check\n               (Exp, DesigT, No_Sliding => False);\n-\n-         --  The nonsliding check should really be performed (unconditionally)\n-         --  against the subtype of the qualified expression, but that causes a\n-         --  problem with c34007g (see above), so for now we retain this.\n-\n-         else\n-            Apply_Constraint_Check\n-              (Exp, DesigT, No_Sliding => True);\n          end if;\n \n          --  For an access to unconstrained packed array, GIGI needs to see an"}, {"sha": "dc606480453bd1d4fe8e3b8e04268eab497c30bf", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36c735526202039b0dbc128cbf47fde38d39e21f/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36c735526202039b0dbc128cbf47fde38d39e21f/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=36c735526202039b0dbc128cbf47fde38d39e21f", "patch": "@@ -87,11 +87,11 @@ package body Exp_Ch7 is\n    --      (See Wrap_Transient_Expression for details)\n \n    --   3. In a expression of an object_declaration. No wrapping is possible\n-   --      here, so the finalization actions, if any are done right after the\n+   --      here, so the finalization actions, if any, are done right after the\n    --      declaration and the secondary stack deallocation is done in the\n    --      proper enclosing scope (see Wrap_Transient_Declaration for details)\n \n-   --  Note about functions returning tagged types: It has been decided to\n+   --  Note about functions returning tagged types: it has been decided to\n    --  always allocate their result in the secondary stack, even though is not\n    --  absolutely mandatory when the tagged type is constrained because the\n    --  caller knows the size of the returned object and thus could allocate the\n@@ -124,10 +124,9 @@ package body Exp_Ch7 is\n    --------------------------------------------------\n \n    function Find_Node_To_Be_Wrapped (N : Node_Id) return Node_Id;\n-   --  N is a node which may generate a transient scope. Loop over the\n-   --  parent pointers of N until it find the appropriate node to\n-   --  wrap. It it returns Empty, it means that no transient scope is\n-   --  needed in this context.\n+   --  N is a node which may generate a transient scope. Loop over the parent\n+   --  pointers of N until it find the appropriate node to wrap. If it returns\n+   --  Empty, it means that no transient scope is needed in this context.\n \n    function Make_Clean\n      (N                          : Node_Id;\n@@ -158,14 +157,14 @@ package body Exp_Ch7 is\n \n    procedure Insert_Actions_In_Scope_Around (N : Node_Id);\n    --  Insert the before-actions kept in the scope stack before N, and the\n-   --  after after-actions, after N which must be a member of a list.\n+   --  after-actions after N, which must be a member of a list.\n \n    function Make_Transient_Block\n      (Loc    : Source_Ptr;\n       Action : Node_Id) return Node_Id;\n-   --  Create a transient block whose name is Scope, which is also a\n-   --  controlled block if Flist is not empty and whose only code is\n-   --  Action (either a single statement or single declaration).\n+   --  Create a transient block whose name is Scope, which is also a controlled\n+   --  block if Flist is not empty and whose only code is Action (either a\n+   --  single statement or single declaration).\n \n    type Final_Primitives is (Initialize_Case, Adjust_Case, Finalize_Case);\n    --  This enumeration type is defined in order to ease sharing code for\n@@ -193,26 +192,24 @@ package body Exp_Ch7 is\n      (Prim  : Final_Primitives;\n       Typ   : Entity_Id;\n       Stmts : List_Id) return Node_Id;\n-   --  This function generates the tree for Deep_Initialize, Deep_Adjust\n-   --  or Deep_Finalize procedures according to the first parameter,\n-   --  these procedures operate on the type Typ. The Stmts parameter\n-   --  gives the body of the procedure.\n+   --  This function generates the tree for Deep_Initialize, Deep_Adjust or\n+   --  Deep_Finalize procedures according to the first parameter, these\n+   --  procedures operate on the type Typ. The Stmts parameter gives the body\n+   --  of the procedure.\n \n    function Make_Deep_Array_Body\n      (Prim : Final_Primitives;\n       Typ  : Entity_Id) return List_Id;\n    --  This function generates the list of statements for implementing\n-   --  Deep_Initialize, Deep_Adjust or Deep_Finalize procedures\n-   --  according to the first parameter, these procedures operate on the\n-   --  array type Typ.\n+   --  Deep_Initialize, Deep_Adjust or Deep_Finalize procedures according to\n+   --  the first parameter, these procedures operate on the array type Typ.\n \n    function Make_Deep_Record_Body\n      (Prim : Final_Primitives;\n       Typ  : Entity_Id) return List_Id;\n    --  This function generates the list of statements for implementing\n-   --  Deep_Initialize, Deep_Adjust or Deep_Finalize procedures\n-   --  according to the first parameter, these procedures operate on the\n-   --  record type Typ.\n+   --  Deep_Initialize, Deep_Adjust or Deep_Finalize procedures according to\n+   --  the first parameter, these procedures operate on the record type Typ.\n \n    procedure Check_Visibly_Controlled\n      (Prim : Final_Primitives;"}, {"sha": "b87c917c44d5569927ef80bb2a58de58798b7c6a", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36c735526202039b0dbc128cbf47fde38d39e21f/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36c735526202039b0dbc128cbf47fde38d39e21f/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=36c735526202039b0dbc128cbf47fde38d39e21f", "patch": "@@ -976,7 +976,7 @@ package Sinfo is\n \n    --  Expansion_Delayed (Flag11-Sem)\n    --    Set on aggregates and extension aggregates that need a top-down rather\n-   --    than bottom up expansion. Typically aggregate expansion happens bottom\n+   --    than bottom-up expansion. Typically aggregate expansion happens bottom\n    --    up. For nested aggregates the expansion is delayed until the enclosing\n    --    aggregate itself is expanded, e.g. in the context of a declaration. To\n    --    delay it we set this flag. This is done to avoid creating a temporary"}, {"sha": "35ecce93fc9031475d398c931c1bc624343fac1a", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36c735526202039b0dbc128cbf47fde38d39e21f/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36c735526202039b0dbc128cbf47fde38d39e21f/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=36c735526202039b0dbc128cbf47fde38d39e21f", "patch": "@@ -3768,11 +3768,13 @@ package body Sprint is\n \n                      Write_Char (')');\n \n-                  --  Signed integer types, and modular integer subtypes\n+                  --  Signed integer types, and modular integer subtypes,\n+                  --  and also enumeration subtypes.\n \n                   when E_Signed_Integer_Type     |\n                        E_Signed_Integer_Subtype  |\n-                       E_Modular_Integer_Subtype =>\n+                       E_Modular_Integer_Subtype |\n+                       E_Enumeration_Subtype     =>\n \n                      Write_Header (Ekind (Typ) = E_Signed_Integer_Type);\n "}]}