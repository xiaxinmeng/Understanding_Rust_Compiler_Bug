{"sha": "cfb14840b842698f12ad82ab42ed4b8445af8992", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ZiMTQ4NDBiODQyNjk4ZjEyYWQ4MmFiNDJlZDRiODQ0NWFmODk5Mg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2018-01-17T23:42:36Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2018-01-17T23:42:36Z"}, "message": "re PR c++/83824 (ICE on invalid C++ code with alignas: in chainon, at tree.c:3037)\n\n\tPR c++/83824\n\t* parser.c (attr_chainon): New function.\n\t(cp_parser_label_for_labeled_statement, cp_parser_decl_specifier_seq,\n\tcp_parser_namespace_definition, cp_parser_init_declarator,\n\tcp_parser_type_specifier_seq, cp_parser_parameter_declaration,\n\tcp_parser_gnu_attributes_opt): Use it.\n\t(cp_parser_member_declaration, cp_parser_objc_class_ivars,\n\tcp_parser_objc_struct_declaration): Likewise.  Don't reset\n\tprefix_attributes if attributes is error_mark_node.\n\n\t* g++.dg/cpp0x/pr83824.C: New test.\n\nFrom-SVN: r256823", "tree": {"sha": "c2feaf80b936a5497948de764c734bf6578d3319", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c2feaf80b936a5497948de764c734bf6578d3319"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cfb14840b842698f12ad82ab42ed4b8445af8992", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfb14840b842698f12ad82ab42ed4b8445af8992", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfb14840b842698f12ad82ab42ed4b8445af8992", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfb14840b842698f12ad82ab42ed4b8445af8992/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a3b11faf7e1920d972eb98b86dc826b107f979a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3b11faf7e1920d972eb98b86dc826b107f979a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3b11faf7e1920d972eb98b86dc826b107f979a0"}], "stats": {"total": 109, "additions": 77, "deletions": 32}, "files": [{"sha": "998e0b9925eb4efb197b6dba4a24b81df713a0bf", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfb14840b842698f12ad82ab42ed4b8445af8992/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfb14840b842698f12ad82ab42ed4b8445af8992/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cfb14840b842698f12ad82ab42ed4b8445af8992", "patch": "@@ -1,3 +1,15 @@\n+2018-01-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/83824\n+\t* parser.c (attr_chainon): New function.\n+\t(cp_parser_label_for_labeled_statement, cp_parser_decl_specifier_seq,\n+\tcp_parser_namespace_definition, cp_parser_init_declarator,\n+\tcp_parser_type_specifier_seq, cp_parser_parameter_declaration,\n+\tcp_parser_gnu_attributes_opt): Use it.\n+\t(cp_parser_member_declaration, cp_parser_objc_class_ivars,\n+\tcp_parser_objc_struct_declaration): Likewise.  Don't reset\n+\tprefix_attributes if attributes is error_mark_node.\n+\n 2018-01-17  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/78344"}, {"sha": "222db0cad3fa33e75764675e908be43be9d2f841", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 51, "deletions": 32, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfb14840b842698f12ad82ab42ed4b8445af8992/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfb14840b842698f12ad82ab42ed4b8445af8992/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=cfb14840b842698f12ad82ab42ed4b8445af8992", "patch": "@@ -10908,6 +10908,18 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n \t\t\"attributes at the beginning of statement are ignored\");\n }\n \n+/* Append ATTR to attribute list ATTRS.  */\n+\n+static tree\n+attr_chainon (tree attrs, tree attr)\n+{\n+  if (attrs == error_mark_node)\n+    return error_mark_node;\n+  if (attr == error_mark_node)\n+    return error_mark_node;\n+  return chainon (attrs, attr);\n+}\n+\n /* Parse the label for a labeled-statement, i.e.\n \n    identifier :\n@@ -11027,7 +11039,7 @@ cp_parser_label_for_labeled_statement (cp_parser* parser, tree attributes)\n       else if (!cp_parser_parse_definitely (parser))\n \t;\n       else\n-\tattributes = chainon (attributes, attrs);\n+\tattributes = attr_chainon (attributes, attrs);\n     }\n \n   if (attributes != NULL_TREE)\n@@ -13394,18 +13406,16 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n \t\t  else\n \t\t    {\n \t\t      decl_specs->std_attributes\n-\t\t\t= chainon (decl_specs->std_attributes,\n-\t\t\t\t   attrs);\n+\t\t\t= attr_chainon (decl_specs->std_attributes, attrs);\n \t\t      if (decl_specs->locations[ds_std_attribute] == 0)\n \t\t\tdecl_specs->locations[ds_std_attribute] = token->location;\n \t\t    }\n \t\t  continue;\n \t\t}\n \t    }\n \n-\t    decl_specs->attributes\n-\t      = chainon (decl_specs->attributes,\n-\t\t\t attrs);\n+\t  decl_specs->attributes\n+\t    = attr_chainon (decl_specs->attributes, attrs);\n \t  if (decl_specs->locations[ds_attribute] == 0)\n \t    decl_specs->locations[ds_attribute] = token->location;\n \t  continue;\n@@ -18471,7 +18481,7 @@ cp_parser_namespace_definition (cp_parser* parser)\n \t  identifier = cp_parser_identifier (parser);\n \n \t  /* Parse any attributes specified after the identifier.  */\n-\t  attribs = chainon (attribs, cp_parser_attributes_opt (parser));\n+\t  attribs = attr_chainon (attribs, cp_parser_attributes_opt (parser));\n \t}\n \n       if (cp_lexer_next_token_is_not (parser->lexer, CPP_SCOPE))\n@@ -19633,7 +19643,7 @@ cp_parser_init_declarator (cp_parser* parser,\n       decl = grokfield (declarator, decl_specifiers,\n \t\t\tinitializer, !is_non_constant_init,\n \t\t\t/*asmspec=*/NULL_TREE,\n-\t\t\tchainon (attributes, prefix_attributes));\n+\t\t\tattr_chainon (attributes, prefix_attributes));\n       if (decl && TREE_CODE (decl) == FUNCTION_DECL)\n \tcp_parser_save_default_args (parser, decl);\n       cp_finalize_omp_declare_simd (parser, decl);\n@@ -21007,9 +21017,9 @@ cp_parser_type_specifier_seq (cp_parser* parser,\n       /* Check for attributes first.  */\n       if (cp_next_tokens_can_be_attribute_p (parser))\n \t{\n-\t  type_specifier_seq->attributes =\n-\t    chainon (type_specifier_seq->attributes,\n-\t\t     cp_parser_attributes_opt (parser));\n+\t  type_specifier_seq->attributes\n+\t    = attr_chainon (type_specifier_seq->attributes,\n+\t\t\t    cp_parser_attributes_opt (parser));\n \t  continue;\n \t}\n \n@@ -21491,8 +21501,8 @@ cp_parser_parameter_declaration (cp_parser *parser,\n       parser->default_arg_ok_p = saved_default_arg_ok_p;\n       /* After the declarator, allow more attributes.  */\n       decl_specifiers.attributes\n-\t= chainon (decl_specifiers.attributes,\n-\t\t   cp_parser_attributes_opt (parser));\n+\t= attr_chainon (decl_specifiers.attributes,\n+\t\t\tcp_parser_attributes_opt (parser));\n \n       /* If the declarator is a template parameter pack, remember that and\n \t clear the flag in the declarator itself so we don't get errors\n@@ -23653,13 +23663,13 @@ cp_parser_member_declaration (cp_parser* parser)\n \t\t  late_attributes = cp_parser_attributes_opt (parser);\n \t\t}\n \n-\t      attributes = chainon (attributes, late_attributes);\n+\t      attributes = attr_chainon (attributes, late_attributes);\n \n \t      /* Remember which attributes are prefix attributes and\n \t\t which are not.  */\n \t      first_attribute = attributes;\n \t      /* Combine the attributes.  */\n-\t      attributes = chainon (prefix_attributes, attributes);\n+\t      attributes = attr_chainon (prefix_attributes, attributes);\n \n \t      /* Create the bitfield declaration.  */\n \t      decl = grokbitfield (identifier\n@@ -23715,7 +23725,7 @@ cp_parser_member_declaration (cp_parser* parser)\n \t\t which are not.  */\n \t      first_attribute = attributes;\n \t      /* Combine the attributes.  */\n-\t      attributes = chainon (prefix_attributes, attributes);\n+\t      attributes = attr_chainon (prefix_attributes, attributes);\n \n \t      /* If it's an `=', then we have a constant-initializer or a\n \t\t pure-specifier.  It is not correct to parse the\n@@ -23837,10 +23847,13 @@ cp_parser_member_declaration (cp_parser* parser)\n \t  cp_finalize_oacc_routine (parser, decl, false);\n \n \t  /* Reset PREFIX_ATTRIBUTES.  */\n-\t  while (attributes && TREE_CHAIN (attributes) != first_attribute)\n-\t    attributes = TREE_CHAIN (attributes);\n-\t  if (attributes)\n-\t    TREE_CHAIN (attributes) = NULL_TREE;\n+\t  if (attributes != error_mark_node)\n+\t    {\n+\t      while (attributes && TREE_CHAIN (attributes) != first_attribute)\n+\t\tattributes = TREE_CHAIN (attributes);\n+\t      if (attributes)\n+\t\tTREE_CHAIN (attributes) = NULL_TREE;\n+\t    }\n \n \t  /* If there is any qualification still in effect, clear it\n \t     now; we will be starting fresh with the next declarator.  */\n@@ -24909,7 +24922,7 @@ cp_parser_gnu_attributes_opt (cp_parser* parser)\n \tcp_parser_skip_to_end_of_statement (parser);\n \n       /* Add these new attributes to the list.  */\n-      attributes = chainon (attributes, attribute_list);\n+      attributes = attr_chainon (attributes, attribute_list);\n     }\n \n   return attributes;\n@@ -30114,7 +30127,7 @@ cp_parser_objc_class_ivars (cp_parser* parser)\n \t     which are not.  */\n \t  first_attribute = attributes;\n \t  /* Combine the attributes.  */\n-\t  attributes = chainon (prefix_attributes, attributes);\n+\t  attributes = attr_chainon (prefix_attributes, attributes);\n \n \t  if (width)\n \t    /* Create the bitfield declaration.  */\n@@ -30130,10 +30143,13 @@ cp_parser_objc_class_ivars (cp_parser* parser)\n \t    objc_add_instance_variable (decl);\n \n \t  /* Reset PREFIX_ATTRIBUTES.  */\n-\t  while (attributes && TREE_CHAIN (attributes) != first_attribute)\n-\t    attributes = TREE_CHAIN (attributes);\n-\t  if (attributes)\n-\t    TREE_CHAIN (attributes) = NULL_TREE;\n+\t  if (attributes != error_mark_node)\n+\t    {\n+\t      while (attributes && TREE_CHAIN (attributes) != first_attribute)\n+\t\tattributes = TREE_CHAIN (attributes);\n+\t      if (attributes)\n+\t\tTREE_CHAIN (attributes) = NULL_TREE;\n+\t    }\n \n \t  token = cp_lexer_peek_token (parser->lexer);\n \n@@ -30666,8 +30682,8 @@ cp_parser_objc_struct_declaration (cp_parser *parser)\n \t which are not.  */\n       first_attribute = attributes;\n       /* Combine the attributes.  */\n-      attributes = chainon (prefix_attributes, attributes);\n-      \n+      attributes = attr_chainon (prefix_attributes, attributes);\n+\n       decl = grokfield (declarator, &declspecs,\n \t\t\tNULL_TREE, /*init_const_expr_p=*/false,\n \t\t\tNULL_TREE, attributes);\n@@ -30676,10 +30692,13 @@ cp_parser_objc_struct_declaration (cp_parser *parser)\n \treturn error_mark_node;\n       \n       /* Reset PREFIX_ATTRIBUTES.  */\n-      while (attributes && TREE_CHAIN (attributes) != first_attribute)\n-\tattributes = TREE_CHAIN (attributes);\n-      if (attributes)\n-\tTREE_CHAIN (attributes) = NULL_TREE;\n+      if (attributes != error_mark_node)\n+\t{\n+\t  while (attributes && TREE_CHAIN (attributes) != first_attribute)\n+\t    attributes = TREE_CHAIN (attributes);\n+\t  if (attributes)\n+\t    TREE_CHAIN (attributes) = NULL_TREE;\n+\t}\n \n       DECL_CHAIN (decl) = decls;\n       decls = decl;"}, {"sha": "c4a4e3e4d7e486a789faf5d02e9e5858bd9839d2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfb14840b842698f12ad82ab42ed4b8445af8992/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfb14840b842698f12ad82ab42ed4b8445af8992/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cfb14840b842698f12ad82ab42ed4b8445af8992", "patch": "@@ -1,3 +1,8 @@\n+2018-01-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/83824\n+\t* g++.dg/cpp0x/pr83824.C: New test.\n+\n 2018-01-17  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \t* gcc.target/powerpc/gnuattr1.c: New test to make sure we set the"}, {"sha": "9474e1ebb25d8428c08684699d661a7f62210fff", "filename": "gcc/testsuite/g++.dg/cpp0x/pr83824.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfb14840b842698f12ad82ab42ed4b8445af8992/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr83824.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfb14840b842698f12ad82ab42ed4b8445af8992/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr83824.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr83824.C?ref=cfb14840b842698f12ad82ab42ed4b8445af8992", "patch": "@@ -0,0 +1,9 @@\n+// PR c++/83824\n+// { dg-do compile { target c++11 } }\n+\n+void\n+foo ()\n+{\n+  if (alignas(1 alignas(1)))\t// { dg-error \"expected\" }\n+    ;\n+}"}]}