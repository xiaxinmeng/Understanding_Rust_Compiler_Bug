{"sha": "6cf9eb278e26ca95ddb3e7c45a75902eb548b288", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNmOWViMjc4ZTI2Y2E5NWRkYjNlN2M0NWE3NTkwMmViNTQ4YjI4OA==", "commit": {"author": {"name": "Kirill Yukhin", "email": "kirill.yukhin@intel.com", "date": "2011-08-09T11:45:53Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2011-08-09T11:45:53Z"}, "message": "i386.c: Remove traling spaces.\n\n       * config/i386/i386.c: Remove traling spaces.\n       * config/i386/sse.md: Likewise.\n       (*fma_fmadd_<mode>): Update.\n       (*fma_fmsub_<mode>): Likewise.\n       (*fma_fnmadd_<mode>): Likewise.\n       (*fma_fnmsub_<mode>): Likewise.\n\nFrom-SVN: r177588", "tree": {"sha": "a74aeee4beac42fdebcf574e8866f1b25f894028", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a74aeee4beac42fdebcf574e8866f1b25f894028"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6cf9eb278e26ca95ddb3e7c45a75902eb548b288", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cf9eb278e26ca95ddb3e7c45a75902eb548b288", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cf9eb278e26ca95ddb3e7c45a75902eb548b288", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cf9eb278e26ca95ddb3e7c45a75902eb548b288/comments", "author": null, "committer": null, "parents": [{"sha": "d6257cf07853cb98228528980822cd68e4b6b022", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6257cf07853cb98228528980822cd68e4b6b022", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6257cf07853cb98228528980822cd68e4b6b022"}], "stats": {"total": 75, "additions": 42, "deletions": 33}, "files": [{"sha": "b9285afd319d41649fdd78c1d145d925d1a06145", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf9eb278e26ca95ddb3e7c45a75902eb548b288/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf9eb278e26ca95ddb3e7c45a75902eb548b288/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6cf9eb278e26ca95ddb3e7c45a75902eb548b288", "patch": "@@ -1,3 +1,12 @@\n+2011-08-09  Kirill Yukhin  <kirill.yukhin@intel.com>\n+\n+       * config/i386/i386.c: Remove traling spaces.\n+       * config/i386/sse.md: Likewise.\n+       (*fma_fmadd_<mode>): Update.\n+       (*fma_fmsub_<mode>): Likewise.\n+       (*fma_fnmadd_<mode>): Likewise.\n+       (*fma_fnmsub_<mode>): Likewise.\n+\n 2011-08-09  Nick Clifton  <nickc@redhat.com>\n \n \t* config/rx/rx.md: Disable extender peepholes at -O3."}, {"sha": "c9781e147a52d79ad748d9dc88956be69c6c2822", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf9eb278e26ca95ddb3e7c45a75902eb548b288/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf9eb278e26ca95ddb3e7c45a75902eb548b288/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=6cf9eb278e26ca95ddb3e7c45a75902eb548b288", "patch": "@@ -120,7 +120,7 @@ check_avx256_stores (rtx dest, const_rtx set, void *data)\n /* Helper function for move_or_delete_vzeroupper_1.  Look for vzeroupper\n    in basic block BB.  Delete it if upper 128bit AVX registers are\n    unused.  If it isn't deleted, move it to just before a jump insn.\n-   \n+\n    STATE is state of the upper 128bits of AVX registers at entry.  */\n \n static void\n@@ -2168,7 +2168,7 @@ static unsigned int initial_ix86_tune_features[X86_TUNE_LAST] = {\n \n   /* X86_TUNE_AVX128_OPTIMAL: Enable 128-bit AVX instruction generation for\n      the auto-vectorizer.  */\n-  m_BDVER \n+  m_BDVER\n };\n \n /* Feature tests against the various architecture variations.  */\n@@ -3786,7 +3786,7 @@ ix86_option_override_internal (bool main_args_p)\n \t    target_flags |= MASK_PREFER_AVX128;\n \t}\n     }\n-  else \n+  else\n     {\n       /* Disable vzeroupper pass if TARGET_AVX is disabled.  */\n       target_flags &= ~MASK_VZEROUPPER;\n@@ -4707,8 +4707,8 @@ ix86_function_ok_for_sibcall (tree decl, tree exp)\n      optimize any indirect call, or a direct call to a global function,\n      as the PLT requires %ebx be live. (Darwin does not have a PLT.)  */\n   if (!TARGET_MACHO\n-      && !TARGET_64BIT \n-      && flag_pic \n+      && !TARGET_64BIT\n+      && flag_pic\n       && (!decl || !targetm.binds_local_p (decl)))\n     return false;\n \n@@ -7514,7 +7514,7 @@ setup_incoming_varargs_ms_64 (CUMULATIVE_ARGS *cum)\n      before.  */\n   ix86_varargs_gpr_size = 0;\n   ix86_varargs_fpr_size = 0;\n-  \n+\n   for (i = cum->regno; i < X86_64_MS_REGPARM_MAX; i++)\n     {\n       rtx reg, mem;\n@@ -8896,7 +8896,7 @@ choose_baseaddr_len (unsigned int regno, HOST_WIDE_INT offset)\n \n   return len;\n }\n-  \n+\n /* Return an RTX that points to CFA_OFFSET within the stack frame.\n    The valid base registers are taken from CFUN->MACHINE->FS.  */\n \n@@ -10361,7 +10361,7 @@ ix86_emit_restore_regs_using_mov (HOST_WIDE_INT cfa_offset,\n       {\n \trtx reg = gen_rtx_REG (Pmode, regno);\n \trtx insn, mem;\n-\t\n+\n \tmem = choose_baseaddr (cfa_offset);\n \tmem = gen_frame_mem (Pmode, mem);\n \tinsn = emit_move_insn (reg, mem);\n@@ -10709,7 +10709,7 @@ ix86_expand_epilogue (int style)\n   if (TARGET_VZEROUPPER\n       && !TREE_THIS_VOLATILE (cfun->decl)\n       && !cfun->machine->caller_return_avx256_p)\n-    emit_insn (gen_avx_vzeroupper (GEN_INT (call_no_avx256))); \n+    emit_insn (gen_avx_vzeroupper (GEN_INT (call_no_avx256)));\n \n   if (crtl->args.pops_args && crtl->args.size)\n     {\n@@ -11151,7 +11151,7 @@ ix86_decompose_address (rtx addr, struct ix86_address *out)\n       && GET_MODE (addr) == DImode\n       && GET_MODE (XEXP (addr, 0)) == SImode)\n     addr = XEXP (addr, 0);\n- \n+\n   if (REG_P (addr))\n     base = addr;\n   else if (GET_CODE (addr) == SUBREG)\n@@ -15084,7 +15084,7 @@ ix86_expand_move (enum machine_mode mode, rtx operands[])\n \t}\n     }\n \n-  if ((flag_pic || MACHOPIC_INDIRECT) \n+  if ((flag_pic || MACHOPIC_INDIRECT)\n       && symbolic_operand (op1, mode))\n     {\n       if (TARGET_MACHO && !TARGET_64BIT)\n@@ -15912,7 +15912,7 @@ ix86_split_idivmod (enum machine_mode mode, rtx operands[],\n     insn = emit_move_insn (operands[1], tmp1);\n   else\n     {\n-      /* Need a new scratch register since the old one has result \n+      /* Need a new scratch register since the old one has result\n \t of 8bit divide.  */\n       scratch = gen_reg_rtx (mode);\n       emit_move_insn (scratch, tmp1);\n@@ -22961,7 +22961,7 @@ ix86_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n \t    case AX_REG:\n \t      opcode = 0xb8; break;\n \t    case CX_REG:\n-\t      opcode = 0xb9; break;\t\n+\t      opcode = 0xb9; break;\n \t    default:\n \t      gcc_unreachable ();\n \t    }\n@@ -28291,7 +28291,7 @@ ix86_secondary_reload (bool in_p, rtx x, reg_class_t rclass,\n \n   /* This condition handles corner case where an expression involving\n      pointers gets vectorized.  We're trying to use the address of a\n-     stack slot as a vector initializer.  \n+     stack slot as a vector initializer.\n \n      (set (reg:V2DI 74 [ vect_cst_.2 ])\n           (vec_duplicate:V2DI (reg/f:DI 20 frame)))\n@@ -30008,7 +30008,7 @@ ix86_pad_returns (void)\n /* Count the minimum number of instructions in BB.  Return 4 if the\n    number of instructions >= 4.  */\n \n-static int \n+static int\n ix86_count_insn_bb (basic_block bb)\n {\n   rtx insn;\n@@ -30037,10 +30037,10 @@ ix86_count_insn_bb (basic_block bb)\n }\n \n \n-/* Count the minimum number of instructions in code path in BB.  \n+/* Count the minimum number of instructions in code path in BB.\n    Return 4 if the number of instructions >= 4.  */\n \n-static int \n+static int\n ix86_count_insn (basic_block bb)\n {\n   edge e;\n@@ -34950,7 +34950,7 @@ ix86_autovectorize_vector_sizes (void)\n #undef TARGET_PRINT_OPERAND_PUNCT_VALID_P\n #define TARGET_PRINT_OPERAND_PUNCT_VALID_P ix86_print_operand_punct_valid_p\n #undef TARGET_ASM_OUTPUT_ADDR_CONST_EXTRA\n-#define TARGET_ASM_OUTPUT_ADDR_CONST_EXTRA i386_asm_output_addr_const_extra \n+#define TARGET_ASM_OUTPUT_ADDR_CONST_EXTRA i386_asm_output_addr_const_extra\n \n #undef TARGET_SCHED_INIT_GLOBAL\n #define TARGET_SCHED_INIT_GLOBAL ix86_sched_init_global"}, {"sha": "e9f6c3da8fbbe9c6af5a539103527ccfd8c57092", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf9eb278e26ca95ddb3e7c45a75902eb548b288/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf9eb278e26ca95ddb3e7c45a75902eb548b288/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=6cf9eb278e26ca95ddb3e7c45a75902eb548b288", "patch": "@@ -119,7 +119,7 @@\n    (V16QI \"\") (V8HI \"\") (V4SI \"\") (V2DI \"\")\n    (V8SF \"256\") (V4DF \"256\")\n    (V4SF \"\") (V2DF \"\")])\n- \n+\n ;; SSE instruction mode\n (define_mode_attr sseinsnmode\n   [(V32QI \"OI\") (V16HI \"OI\") (V8SI \"OI\") (V4DI \"OI\")\n@@ -1717,7 +1717,7 @@\n   \"TARGET_FMA\"\n   \"@\n    vfmadd132<ssemodesuffix>\\t{%2, %3, %0|%0, %3, %2}\n-   vfmadd312<ssemodesuffix>\\t{%3, %2, %0|%0, %2, %3}\n+   vfmadd213<ssemodesuffix>\\t{%3, %2, %0|%0, %2, %3}\n    vfmadd231<ssemodesuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n   [(set_attr \"type\" \"ssemuladd\")\n    (set_attr \"mode\" \"<MODE>\")])\n@@ -1732,7 +1732,7 @@\n   \"TARGET_FMA\"\n   \"@\n    vfmsub132<ssemodesuffix>\\t{%2, %3, %0|%0, %3, %2}\n-   vfmsub312<ssemodesuffix>\\t{%3, %2, %0|%0, %2, %3}\n+   vfmsub213<ssemodesuffix>\\t{%3, %2, %0|%0, %2, %3}\n    vfmsub231<ssemodesuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n   [(set_attr \"type\" \"ssemuladd\")\n    (set_attr \"mode\" \"<MODE>\")])\n@@ -1747,7 +1747,7 @@\n   \"TARGET_FMA\"\n   \"@\n    vfnmadd132<ssemodesuffix>\\t{%2, %3, %0|%0, %3, %2}\n-   vfnmadd312<ssemodesuffix>\\t{%3, %2, %0|%0, %2, %3}\n+   vfnmadd213<ssemodesuffix>\\t{%3, %2, %0|%0, %2, %3}\n    vfnmadd231<ssemodesuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n   [(set_attr \"type\" \"ssemuladd\")\n    (set_attr \"mode\" \"<MODE>\")])\n@@ -1763,7 +1763,7 @@\n   \"TARGET_FMA\"\n   \"@\n    vfnmsub132<ssemodesuffix>\\t{%2, %3, %0|%0, %3, %2}\n-   vfnmsub312<ssemodesuffix>\\t{%3, %2, %0|%0, %2, %3}\n+   vfnmsub231<ssemodesuffix>\\t{%3, %2, %0|%0, %2, %3}\n    vfnmsub231<ssemodesuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n   [(set_attr \"type\" \"ssemuladd\")\n    (set_attr \"mode\" \"<MODE>\")])\n@@ -2646,7 +2646,7 @@\n \t\t\t   ix86_build_const_vector (V2DFmode, 1, x));\n \n   operands[5] = gen_reg_rtx (V4SImode);\n- \n+\n   for (i = 6; i < 9; i++)\n     operands[i] = gen_reg_rtx (V2DFmode);\n })\n@@ -2771,7 +2771,7 @@\n   \"TARGET_SSE\"\n {\n   rtx dst = ix86_fixup_binary_operands (UNKNOWN, V4SFmode, operands);\n-  \n+\n   emit_insn (gen_sse_movhlps (dst, operands[1], operands[2]));\n \n   /* Fix up the destination if needed.  */\n@@ -2816,7 +2816,7 @@\n   \"TARGET_SSE\"\n {\n   rtx dst = ix86_fixup_binary_operands (UNKNOWN, V4SFmode, operands);\n-  \n+\n   emit_insn (gen_sse_movlhps (dst, operands[1], operands[2]));\n \n   /* Fix up the destination if needed.  */\n@@ -3182,7 +3182,7 @@\n   \"TARGET_SSE\"\n {\n   rtx dst = ix86_fixup_binary_operands (UNKNOWN, V4SFmode, operands);\n-  \n+\n   emit_insn (gen_sse_loadhps (dst, operands[1], operands[2]));\n \n   /* Fix up the destination if needed.  */\n@@ -3235,7 +3235,7 @@\n   \"TARGET_SSE\"\n {\n   rtx dst = ix86_fixup_binary_operands (UNKNOWN, V4SFmode, operands);\n-  \n+\n   emit_insn (gen_sse_loadlps (dst, operands[1], operands[2]));\n \n   /* Fix up the destination if needed.  */\n@@ -4034,7 +4034,7 @@\n   [(V16QI \"TARGET_SSE2\")\n    (V8HI \"TARGET_SSE2\")\n    (V4SI \"TARGET_SSE2\")\n-   (V2DI \"TARGET_SSE2\") \n+   (V2DI \"TARGET_SSE2\")\n    (V8SF \"TARGET_AVX\") V4SF\n    (V4DF \"TARGET_AVX\") (V2DF \"TARGET_SSE2\")])\n \n@@ -4236,7 +4236,7 @@\n   \"TARGET_SSE2\"\n {\n   rtx dst = ix86_fixup_binary_operands (UNKNOWN, V2DFmode, operands);\n-  \n+\n   emit_insn (gen_sse2_loadhpd (dst, operands[1], operands[2]));\n \n   /* Fix up the destination if needed.  */\n@@ -4292,7 +4292,7 @@\n   \"TARGET_SSE2\"\n {\n   rtx dst = ix86_fixup_binary_operands (UNKNOWN, V2DFmode, operands);\n-  \n+\n   emit_insn (gen_sse2_loadlpd (dst, operands[1], operands[2]));\n \n   /* Fix up the destination if needed.  */\n@@ -7260,7 +7260,7 @@\n   \"@\n    phsubd\\t{%2, %0|%0, %2}\n    vphsubd\\t{%2, %1, %0|%0, %1, %2}\"\n-  \n+\n   [(set_attr \"isa\" \"noavx,avx\")\n    (set_attr \"type\" \"sseiadd\")\n    (set_attr \"atom_unit\" \"complex\")\n@@ -10250,7 +10250,7 @@\n   rtx op1 = operands[1];\n   if (REG_P (op0))\n     op0 = gen_rtx_REG (<ssehalfvecmode>mode, REGNO (op0));\n-  else \n+  else\n     op1 = gen_rtx_REG (<MODE>mode, REGNO (op1));\n   emit_move_insn (op0, op1);\n   DONE;"}]}