{"sha": "089e62f33c328afea756ec4b92f5823584b08a3a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDg5ZTYyZjMzYzMyOGFmZWE3NTZlYzRiOTJmNTgyMzU4NGIwOGEzYQ==", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-07-14T20:48:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-07-14T20:48:41Z"}, "message": "Merge #566\n\n566: Further error checking for trait impl blocks r=philberty a=philberty\n\nThis PR introduces enhanced type checking for trait constants\r\nand associated types. It also brings in the check to ensure all\r\nmandatory trait items are implemented. Note optional trait items\r\ncannot be referenced or used yet and will be done in a separate PR.\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "7dae8f29c3df18aa714c1e8ad931198634d93b81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7dae8f29c3df18aa714c1e8ad931198634d93b81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/089e62f33c328afea756ec4b92f5823584b08a3a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg702pCRBK7hj4Ov3rIwAAjFgIABljm0QXiz70PUEMHjd05JuX\nFlfLWcFoxw3QTEZT5c8u05yI2dRC4tR4HTkbStbYDmjbcxIUbUYbV48eDcm0ljvY\nrQ/C2H/2c0Cd6eblTM7UMwz7mZ2q4+yeWXnC0uy3TvQx0EZqY2lmch5HwBXHuiYD\nudyzd6pLcekYuc6AqA9mluKqC++c/W/wIONI2oQK96Rd+vcxQpRxpk1Pe7VzO97t\nkuQUusKQ9KD88b8wnhL/fSbfJHni7YGqNbgzhYi2sMn6gCm/zZKZyDWtQ/a7iWEF\n/3/agf0S2D5cP25SR/VUTa4pAskPjmSpt3D2TPTy3z1BRzdszyKTAKuvy9EpYoU=\n=qwxt\n-----END PGP SIGNATURE-----\n", "payload": "tree 7dae8f29c3df18aa714c1e8ad931198634d93b81\nparent 51f66ab1368fcd69ea1289bafae8f5eadda932dd\nparent 05b5eec7ab095d2d80a4fb8262c8985ad03550b6\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1626295721 +0000\ncommitter GitHub <noreply@github.com> 1626295721 +0000\n\nMerge #566\n\n566: Further error checking for trait impl blocks r=philberty a=philberty\n\nThis PR introduces enhanced type checking for trait constants\r\nand associated types. It also brings in the check to ensure all\r\nmandatory trait items are implemented. Note optional trait items\r\ncannot be referenced or used yet and will be done in a separate PR.\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/089e62f33c328afea756ec4b92f5823584b08a3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/089e62f33c328afea756ec4b92f5823584b08a3a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/089e62f33c328afea756ec4b92f5823584b08a3a/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51f66ab1368fcd69ea1289bafae8f5eadda932dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51f66ab1368fcd69ea1289bafae8f5eadda932dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51f66ab1368fcd69ea1289bafae8f5eadda932dd"}, {"sha": "05b5eec7ab095d2d80a4fb8262c8985ad03550b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05b5eec7ab095d2d80a4fb8262c8985ad03550b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05b5eec7ab095d2d80a4fb8262c8985ad03550b6"}], "stats": {"total": 580, "additions": 402, "deletions": 178}, "files": [{"sha": "30cab0ed90049b02c7473f69f559f20e120fecb5", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089e62f33c328afea756ec4b92f5823584b08a3a/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089e62f33c328afea756ec4b92f5823584b08a3a/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=089e62f33c328afea756ec4b92f5823584b08a3a", "patch": "@@ -3265,10 +3265,12 @@ class TraitItemConst : public TraitItem\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n \n+  bool has_expr () const { return expr != nullptr; }\n+\n   // TODO: is this better? Or is a \"vis_block\" better?\n   std::unique_ptr<Expr> &get_expr ()\n   {\n-    rust_assert (expr != nullptr);\n+    rust_assert (has_expr ());\n     return expr;\n   }\n "}, {"sha": "0714f5d57063aa2d482ca1be33a2c451513ec3d2", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089e62f33c328afea756ec4b92f5823584b08a3a/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089e62f33c328afea756ec4b92f5823584b08a3a/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=089e62f33c328afea756ec4b92f5823584b08a3a", "patch": "@@ -168,7 +168,9 @@ class ResolveTraitItems : public ResolverBase\n   void visit (AST::TraitItemConst &constant) override\n   {\n     ResolveType::go (constant.get_type ().get (), constant.get_node_id ());\n-    ResolveExpr::go (constant.get_expr ().get (), constant.get_node_id ());\n+\n+    if (constant.has_expr ())\n+      ResolveExpr::go (constant.get_expr ().get (), constant.get_node_id ());\n \n     // the mutability checker needs to verify for immutable decls the number\n     // of assignments are <1. This marks an implicit assignment"}, {"sha": "35c0fefd849a5a951dccef736fa45829250f4f76", "filename": "gcc/rust/typecheck/rust-hir-trait-ref.h", "status": "modified", "additions": 73, "deletions": 17, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089e62f33c328afea756ec4b92f5823584b08a3a/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089e62f33c328afea756ec4b92f5823584b08a3a/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h?ref=089e62f33c328afea756ec4b92f5823584b08a3a", "patch": "@@ -27,6 +27,7 @@ namespace Resolver {\n \n // Data Objects for the associated trait items in a structure we can work with\n // https://doc.rust-lang.org/edition-guide/rust-2018/trait-system/associated-constants.html\n+class TypeCheckContext;\n class TraitItemReference\n {\n public:\n@@ -39,26 +40,25 @@ class TraitItemReference\n   };\n \n   TraitItemReference (std::string identifier, bool optional, TraitItemType type,\n-\t\t      const HIR::TraitItem *hir_trait_item, TyTy::BaseType *ty,\n-\t\t      Location locus)\n-    : identifier (identifier), optional_flag (optional), type (type),\n-      hir_trait_item (hir_trait_item), ty (ty), locus (locus)\n-  {}\n+\t\t      HIR::TraitItem *hir_trait_item, TyTy::BaseType *self,\n+\t\t      std::vector<TyTy::SubstitutionParamMapping> substitutions,\n+\t\t      Location locus);\n \n-  TraitItemReference (TraitItemReference const &other)\n-    : identifier (other.identifier), optional_flag (other.optional_flag),\n-      type (other.type), hir_trait_item (other.hir_trait_item), ty (other.ty),\n-      locus (other.locus)\n-  {}\n+  TraitItemReference (TraitItemReference const &other);\n \n   TraitItemReference &operator= (TraitItemReference const &other)\n   {\n     identifier = other.identifier;\n     optional_flag = other.optional_flag;\n     type = other.type;\n     hir_trait_item = other.hir_trait_item;\n-    ty = other.ty;\n+    self = other.self;\n     locus = other.locus;\n+    context = other.context;\n+\n+    inherited_substitutions.reserve (other.inherited_substitutions.size ());\n+    for (size_t i = 0; i < other.inherited_substitutions.size (); i++)\n+      inherited_substitutions.push_back (other.inherited_substitutions.at (i));\n \n     return *this;\n   }\n@@ -68,7 +68,8 @@ class TraitItemReference\n \n   static TraitItemReference error ()\n   {\n-    return TraitItemReference (\"\", false, ERROR, nullptr, nullptr, Location ());\n+    return TraitItemReference (\"\", false, ERROR, nullptr, nullptr, {},\n+\t\t\t       Location ());\n   }\n \n   static TraitItemReference &error_node ()\n@@ -82,7 +83,7 @@ class TraitItemReference\n   std::string as_string () const\n   {\n     return \"(\" + trait_item_type_as_string (type) + \" \" + identifier + \" \"\n-\t   + ty->as_string () + \")\";\n+\t   + \")\";\n   }\n \n   static std::string trait_item_type_as_string (TraitItemType ty)\n@@ -109,17 +110,65 @@ class TraitItemReference\n \n   const HIR::TraitItem *get_hir_trait_item () const { return hir_trait_item; }\n \n-  TyTy::BaseType *get_tyty () const { return ty; }\n-\n   Location get_locus () const { return locus; }\n \n+  const Analysis::NodeMapping &get_mappings () const\n+  {\n+    return hir_trait_item->get_mappings ();\n+  }\n+\n+  TyTy::BaseType *get_tyty () const\n+  {\n+    rust_assert (hir_trait_item != nullptr);\n+\n+    switch (type)\n+      {\n+      case CONST:\n+\treturn get_type_from_constant (\n+\t  static_cast</*const*/ HIR::TraitItemConst &> (*hir_trait_item));\n+\tbreak;\n+\n+      case TYPE:\n+\treturn get_type_from_typealias (\n+\t  static_cast</*const*/ HIR::TraitItemType &> (*hir_trait_item));\n+\n+      case FN:\n+\treturn get_type_from_fn (\n+\t  static_cast</*const*/ HIR::TraitItemFunc &> (*hir_trait_item));\n+\tbreak;\n+\n+      default:\n+\treturn get_error ();\n+      }\n+\n+    gcc_unreachable ();\n+    return get_error ();\n+  }\n+\n private:\n+  TyTy::ErrorType *get_error () const\n+  {\n+    return new TyTy::ErrorType (get_mappings ().get_hirid ());\n+  }\n+\n+  TyTy::BaseType *get_type_from_typealias (/*const*/\n+\t\t\t\t\t   HIR::TraitItemType &type) const;\n+\n+  TyTy::BaseType *\n+  get_type_from_constant (/*const*/ HIR::TraitItemConst &constant) const;\n+\n+  TyTy::BaseType *get_type_from_fn (/*const*/ HIR::TraitItemFunc &fn) const;\n+\n   std::string identifier;\n   bool optional_flag;\n   TraitItemType type;\n-  const HIR::TraitItem *hir_trait_item;\n-  TyTy::BaseType *ty;\n+  HIR::TraitItem *hir_trait_item;\n+  std::vector<TyTy::SubstitutionParamMapping> inherited_substitutions;\n   Location locus;\n+\n+  TyTy::BaseType\n+    *self; // this is the implict Self TypeParam required for methods\n+  Resolver::TypeCheckContext *context;\n };\n \n class TraitReference\n@@ -187,6 +236,13 @@ class TraitReference\n     return TraitItemReference::error_node ();\n   }\n \n+  size_t size () const { return item_refs.size (); }\n+\n+  const std::vector<TraitItemReference> &get_trait_items () const\n+  {\n+    return item_refs;\n+  }\n+\n private:\n   const HIR::Trait *hir_trait_ref;\n   std::vector<TraitItemReference> item_refs;"}, {"sha": "3de68c8e685edaefb4c7049e541aad330ee0225d", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.h", "status": "modified", "additions": 3, "deletions": 100, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089e62f33c328afea756ec4b92f5823584b08a3a/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089e62f33c328afea756ec4b92f5823584b08a3a/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h?ref=089e62f33c328afea756ec4b92f5823584b08a3a", "patch": "@@ -55,128 +55,31 @@ class ResolveTraitItemToRef : public TypeCheckBase\n \n     resolved = TraitItemReference (identifier, is_optional,\n \t\t\t\t   TraitItemReference::TraitItemType::TYPE,\n-\t\t\t\t   &type, ty, locus);\n+\t\t\t\t   &type, self, substitutions, locus);\n   }\n \n   void visit (HIR::TraitItemConst &cst) override\n   {\n-    // attempt to lookup the type of the trait item function\n-    TyTy::BaseType *ty = nullptr;\n-    if (!context->lookup_type (cst.get_mappings ().get_hirid (), &ty))\n-      {\n-\tauto resolved = TypeCheckType::Resolve (cst.get_type ().get ());\n-\tif (resolved->get_kind () == TyTy::TypeKind::ERROR)\n-\t  {\n-\t    rust_error_at (cst.get_locus (),\n-\t\t\t   \"failed to resolve trait constant type\");\n-\t    return;\n-\t  }\n-      }\n-\n     // create trait-item-ref\n     Location locus = cst.get_locus ();\n     bool is_optional = cst.has_expr ();\n     std::string identifier = cst.get_name ();\n \n     resolved = TraitItemReference (identifier, is_optional,\n \t\t\t\t   TraitItemReference::TraitItemType::CONST,\n-\t\t\t\t   &cst, ty, locus);\n+\t\t\t\t   &cst, self, substitutions, locus);\n   }\n \n   void visit (HIR::TraitItemFunc &fn) override\n   {\n-    // FIXME this is duplicated in a few places and could be refactored\n-\n-    // attempt to lookup the type of the trait item function\n-    TyTy::BaseType *ty = nullptr;\n-    if (!context->lookup_type (fn.get_mappings ().get_hirid (), &ty))\n-      {\n-\tHIR::TraitFunctionDecl &function = fn.get_decl ();\n-\tif (function.has_generics ())\n-\t  {\n-\t    for (auto &generic_param : function.get_generic_params ())\n-\t      {\n-\t\tswitch (generic_param.get ()->get_kind ())\n-\t\t  {\n-\t\t  case HIR::GenericParam::GenericKind::LIFETIME:\n-\t\t    // Skipping Lifetime completely until better handling.\n-\t\t    break;\n-\n-\t\t    case HIR::GenericParam::GenericKind::TYPE: {\n-\t\t      auto param_type = TypeResolveGenericParam::Resolve (\n-\t\t\tgeneric_param.get ());\n-\t\t      context->insert_type (generic_param->get_mappings (),\n-\t\t\t\t\t    param_type);\n-\n-\t\t      substitutions.push_back (TyTy::SubstitutionParamMapping (\n-\t\t\tstatic_cast<HIR::TypeParam &> (*generic_param),\n-\t\t\tparam_type));\n-\t\t    }\n-\t\t    break;\n-\t\t  }\n-\t      }\n-\t  }\n-\n-\tTyTy::BaseType *ret_type = nullptr;\n-\tif (!function.has_return_type ())\n-\t  ret_type = new TyTy::TupleType (fn.get_mappings ().get_hirid ());\n-\telse\n-\t  {\n-\t    auto resolved\n-\t      = TypeCheckType::Resolve (function.get_return_type ().get ());\n-\t    if (resolved->get_kind () == TyTy::TypeKind::ERROR)\n-\t      {\n-\t\trust_error_at (fn.get_locus (),\n-\t\t\t       \"failed to resolve return type\");\n-\t\treturn;\n-\t      }\n-\n-\t    ret_type = resolved->clone ();\n-\t    ret_type->set_ref (\n-\t      function.get_return_type ()->get_mappings ().get_hirid ());\n-\t  }\n-\n-\tstd::vector<std::pair<HIR::Pattern *, TyTy::BaseType *> > params;\n-\tif (function.is_method ())\n-\t  {\n-\t    // add the synthetic self param at the front, this is a placeholder\n-\t    // for compilation to know parameter names. The types are ignored\n-\t    // but we reuse the HIR identifier pattern which requires it\n-\t    HIR::SelfParam &self_param = function.get_self ();\n-\t    HIR::IdentifierPattern *self_pattern = new HIR::IdentifierPattern (\n-\t      \"self\", self_param.get_locus (), self_param.is_ref (),\n-\t      self_param.is_mut (), std::unique_ptr<HIR::Pattern> (nullptr));\n-\t    context->insert_type (self_param.get_mappings (), self->clone ());\n-\t    params.push_back (\n-\t      std::pair<HIR::Pattern *, TyTy::BaseType *> (self_pattern,\n-\t\t\t\t\t\t\t   self->clone ()));\n-\t  }\n-\n-\tfor (auto &param : function.get_function_params ())\n-\t  {\n-\t    // get the name as well required for later on\n-\t    auto param_tyty = TypeCheckType::Resolve (param.get_type ());\n-\t    params.push_back (std::pair<HIR::Pattern *, TyTy::BaseType *> (\n-\t      param.get_param_name (), param_tyty));\n-\n-\t    context->insert_type (param.get_mappings (), param_tyty);\n-\t  }\n-\n-\tty = new TyTy::FnType (fn.get_mappings ().get_hirid (),\n-\t\t\t       function.get_function_name (),\n-\t\t\t       function.is_method (), std::move (params),\n-\t\t\t       ret_type, std::move (substitutions));\n-\tcontext->insert_type (fn.get_mappings (), ty);\n-      }\n-\n     // create trait-item-ref\n     Location locus = fn.get_locus ();\n     bool is_optional = fn.has_block_defined ();\n     std::string identifier = fn.get_decl ().get_function_name ();\n \n     resolved = TraitItemReference (identifier, is_optional,\n \t\t\t\t   TraitItemReference::TraitItemType::FN, &fn,\n-\t\t\t\t   ty, locus);\n+\t\t\t\t   self, substitutions, locus);\n   }\n \n private:"}, {"sha": "d6c3aed386e0698c876c3bee6108c6083519a0a1", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 46, "deletions": 56, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089e62f33c328afea756ec4b92f5823584b08a3a/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089e62f33c328afea756ec4b92f5823584b08a3a/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=089e62f33c328afea756ec4b92f5823584b08a3a", "patch": "@@ -214,116 +214,109 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n \n   void visit (HIR::ConstantItem &constant) override\n   {\n-    TypeCheckImplItem::visit (constant);\n-\n-    // we get the error checking from the base method here\n-    TyTy::BaseType *lookup;\n-    if (!context->lookup_type (constant.get_mappings ().get_hirid (), &lookup))\n-      return;\n-\n-    const TraitItemReference &trait_item_ref\n-      = trait_reference.lookup_trait_item (\n-\tconstant.get_identifier (), TraitItemReference::TraitItemType::CONST);\n+    resolved_trait_item = trait_reference.lookup_trait_item (\n+      constant.get_identifier (), TraitItemReference::TraitItemType::CONST);\n \n     // unknown trait item\n-    if (trait_item_ref.is_error ())\n+    if (resolved_trait_item.is_error ())\n       {\n \tRichLocation r (constant.get_locus ());\n \tr.add_range (trait_reference.get_locus ());\n \trust_error_at (r, \"constant %<%s%> is not a member of trait %<%s%>\",\n \t\t       constant.get_identifier ().c_str (),\n \t\t       trait_reference.get_name ().c_str ());\n-\treturn;\n       }\n \n+    // normal resolution of the item\n+    TypeCheckImplItem::visit (constant);\n+    TyTy::BaseType *lookup;\n+    if (!context->lookup_type (constant.get_mappings ().get_hirid (), &lookup))\n+      return;\n+    if (resolved_trait_item.is_error ())\n+      return;\n+\n     // check the types are compatible\n-    if (!trait_item_ref.get_tyty ()->can_eq (lookup, true))\n+    if (!resolved_trait_item.get_tyty ()->can_eq (lookup, true))\n       {\n \tRichLocation r (constant.get_locus ());\n-\tr.add_range (trait_item_ref.get_locus ());\n+\tr.add_range (resolved_trait_item.get_locus ());\n \n \trust_error_at (\n \t  r, \"constant %<%s%> has an incompatible type for trait %<%s%>\",\n \t  constant.get_identifier ().c_str (),\n \t  trait_reference.get_name ().c_str ());\n-\treturn;\n       }\n-\n-    resolved_trait_item = trait_item_ref;\n   }\n \n   void visit (HIR::TypeAlias &type) override\n   {\n-    TypeCheckImplItem::visit (type);\n-\n-    // we get the error checking from the base method here\n-    TyTy::BaseType *lookup;\n-    if (!context->lookup_type (type.get_mappings ().get_hirid (), &lookup))\n-      return;\n-\n-    const TraitItemReference &trait_item_ref\n-      = trait_reference.lookup_trait_item (\n-\ttype.get_new_type_name (), TraitItemReference::TraitItemType::TYPE);\n+    resolved_trait_item = trait_reference.lookup_trait_item (\n+      type.get_new_type_name (), TraitItemReference::TraitItemType::TYPE);\n \n     // unknown trait item\n-    if (trait_item_ref.is_error ())\n+    if (resolved_trait_item.is_error ())\n       {\n \tRichLocation r (type.get_locus ());\n \tr.add_range (trait_reference.get_locus ());\n \trust_error_at (r, \"type alias %<%s%> is not a member of trait %<%s%>\",\n \t\t       type.get_new_type_name ().c_str (),\n \t\t       trait_reference.get_name ().c_str ());\n-\treturn;\n       }\n \n+    // normal resolution of the item\n+    TypeCheckImplItem::visit (type);\n+    TyTy::BaseType *lookup;\n+    if (!context->lookup_type (type.get_mappings ().get_hirid (), &lookup))\n+      return;\n+    if (resolved_trait_item.is_error ())\n+      return;\n+\n     // check the types are compatible\n-    if (!trait_item_ref.get_tyty ()->can_eq (lookup, true))\n+    if (!resolved_trait_item.get_tyty ()->can_eq (lookup, true))\n       {\n \tRichLocation r (type.get_locus ());\n-\tr.add_range (trait_item_ref.get_locus ());\n+\tr.add_range (resolved_trait_item.get_locus ());\n \n \trust_error_at (\n \t  r, \"type alias %<%s%> has an incompatible type for trait %<%s%>\",\n \t  type.get_new_type_name ().c_str (),\n \t  trait_reference.get_name ().c_str ());\n-\treturn;\n       }\n \n-    resolved_trait_item = trait_item_ref;\n+    context->insert_type (resolved_trait_item.get_mappings (),\n+\t\t\t  lookup->clone ());\n   }\n \n   void visit (HIR::Function &function) override\n   {\n-    TypeCheckImplItem::visit (function);\n-\n-    // we get the error checking from the base method here\n-    TyTy::BaseType *lookup;\n-    if (!context->lookup_type (function.get_mappings ().get_hirid (), &lookup))\n-      return;\n-\n-    if (lookup->get_kind () != TyTy::TypeKind::FNDEF)\n-      return;\n-\n-    TyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup);\n-    const TraitItemReference &trait_item_ref\n-      = trait_reference.lookup_trait_item (\n-\tfntype->get_identifier (), TraitItemReference::TraitItemType::FN);\n+    resolved_trait_item = trait_reference.lookup_trait_item (\n+      function.get_function_name (), TraitItemReference::TraitItemType::FN);\n \n     // unknown trait item\n-    if (trait_item_ref.is_error ())\n+    if (resolved_trait_item.is_error ())\n       {\n \tRichLocation r (function.get_locus ());\n \tr.add_range (trait_reference.get_locus ());\n \trust_error_at (r, \"method %<%s%> is not a member of trait %<%s%>\",\n-\t\t       fntype->get_identifier ().c_str (),\n+\t\t       function.get_function_name ().c_str (),\n \t\t       trait_reference.get_name ().c_str ());\n-\treturn;\n       }\n \n-    rust_assert (trait_item_ref.get_tyty ()->get_kind ()\n+    // we get the error checking from the base method here\n+    TypeCheckImplItem::visit (function);\n+    TyTy::BaseType *lookup;\n+    if (!context->lookup_type (function.get_mappings ().get_hirid (), &lookup))\n+      return;\n+    if (resolved_trait_item.is_error ())\n+      return;\n+\n+    rust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n+    rust_assert (resolved_trait_item.get_tyty ()->get_kind ()\n \t\t == TyTy::TypeKind::FNDEF);\n+\n+    TyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup);\n     TyTy::FnType *trait_item_fntype\n-      = static_cast<TyTy::FnType *> (trait_item_ref.get_tyty ());\n+      = static_cast<TyTy::FnType *> (resolved_trait_item.get_tyty ());\n \n     // sets substitute self into the trait_item_ref->tyty\n     TyTy::SubstitutionParamMapping *self_mapping = nullptr;\n@@ -350,16 +343,13 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n     if (!trait_item_fntype->can_eq (fntype, true))\n       {\n \tRichLocation r (function.get_locus ());\n-\tr.add_range (trait_item_ref.get_locus ());\n+\tr.add_range (resolved_trait_item.get_locus ());\n \n \trust_error_at (\n \t  r, \"method %<%s%> has an incompatible type for trait %<%s%>\",\n \t  fntype->get_identifier ().c_str (),\n \t  trait_reference.get_name ().c_str ());\n-\treturn;\n       }\n-\n-    resolved_trait_item = trait_item_ref;\n   }\n \n private:"}, {"sha": "f1ae82dde7cf12895859f33a7b1896f3011a341b", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.h", "status": "modified", "additions": 55, "deletions": 3, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089e62f33c328afea756ec4b92f5823584b08a3a/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089e62f33c328afea756ec4b92f5823584b08a3a/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h?ref=089e62f33c328afea756ec4b92f5823584b08a3a", "patch": "@@ -60,13 +60,65 @@ class TypeCheckItem : public TypeCheckBase\n \treturn;\n       }\n \n+    bool is_trait_impl_block = !trait_reference.is_error ();\n+\n+    std::vector<std::reference_wrapper<const TraitItemReference>>\n+      trait_item_refs;\n     for (auto &impl_item : impl_block.get_impl_items ())\n       {\n-\tif (trait_reference.is_error ())\n+\tif (!is_trait_impl_block)\n \t  TypeCheckImplItem::Resolve (impl_item.get (), self);\n \telse\n-\t  TypeCheckImplItemWithTrait::Resolve (impl_item.get (), self,\n-\t\t\t\t\t       trait_reference);\n+\t  {\n+\t    auto &trait_item_ref\n+\t      = TypeCheckImplItemWithTrait::Resolve (impl_item.get (), self,\n+\t\t\t\t\t\t     trait_reference);\n+\t    trait_item_refs.push_back (trait_item_ref);\n+\t  }\n+      }\n+\n+    bool impl_block_missing_trait_items\n+      = is_trait_impl_block\n+\t&& trait_reference.size () != trait_item_refs.size ();\n+    if (impl_block_missing_trait_items)\n+      {\n+\t// filter the missing impl_items\n+\tstd::vector<std::reference_wrapper<const TraitItemReference>>\n+\t  missing_trait_items;\n+\tfor (auto &trait_item_ref : trait_reference.get_trait_items ())\n+\t  {\n+\t    bool found = false;\n+\t    for (const TraitItemReference &implemented_trait_item :\n+\t\t trait_item_refs)\n+\t      {\n+\t\tstd::string trait_item_name = trait_item_ref.get_identifier ();\n+\t\tstd::string impl_item_name\n+\t\t  = implemented_trait_item.get_identifier ();\n+\t\tfound = trait_item_name.compare (impl_item_name) == 0;\n+\t\tif (found)\n+\t\t  break;\n+\t      }\n+\n+\t    bool is_required_trait_item = !trait_item_ref.is_optional ();\n+\t    if (!found && is_required_trait_item)\n+\t      missing_trait_items.push_back (trait_item_ref);\n+\t  }\n+\n+\tstd::string missing_items_buf;\n+\tRichLocation r (impl_block.get_locus ());\n+\tfor (size_t i = 0; i < missing_trait_items.size (); i++)\n+\t  {\n+\t    bool has_more = (i + 1) < missing_trait_items.size ();\n+\t    const TraitItemReference &missing_trait_item\n+\t      = missing_trait_items.at (i);\n+\t    missing_items_buf\n+\t      += missing_trait_item.get_identifier () + (has_more ? \", \" : \"\");\n+\t    r.add_range (missing_trait_item.get_locus ());\n+\t  }\n+\n+\trust_error_at (r, \"missing %s in implementation of trait %<%s%>\",\n+\t\t       missing_items_buf.c_str (),\n+\t\t       trait_reference.get_name ().c_str ());\n       }\n   }\n "}, {"sha": "acfc02210c338e26f46549ef5a979002c7ca88c2", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089e62f33c328afea756ec4b92f5823584b08a3a/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089e62f33c328afea756ec4b92f5823584b08a3a/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=089e62f33c328afea756ec4b92f5823584b08a3a", "patch": "@@ -375,5 +375,132 @@ TypeCheckType::visit (HIR::ArrayType &type)\n \t\t\t\t    TyTy::TyVar (base->get_ref ()));\n }\n \n+// rust-hir-trait-ref.h\n+\n+TraitItemReference::TraitItemReference (\n+  std::string identifier, bool optional, TraitItemType type,\n+  HIR::TraitItem *hir_trait_item, TyTy::BaseType *self,\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions, Location locus)\n+  : identifier (identifier), optional_flag (optional), type (type),\n+    hir_trait_item (hir_trait_item), inherited_substitutions (substitutions),\n+    locus (locus), self (self), context (TypeCheckContext::get ())\n+{}\n+\n+TraitItemReference::TraitItemReference (TraitItemReference const &other)\n+  : identifier (other.identifier), optional_flag (other.optional_flag),\n+    type (other.type), hir_trait_item (other.hir_trait_item),\n+    locus (other.locus), self (other.self), context (TypeCheckContext::get ())\n+{\n+  inherited_substitutions.reserve (other.inherited_substitutions.size ());\n+  for (size_t i = 0; i < other.inherited_substitutions.size (); i++)\n+    inherited_substitutions.push_back (other.inherited_substitutions.at (i));\n+}\n+\n+TyTy::BaseType *\n+TraitItemReference::get_type_from_typealias (/*const*/\n+\t\t\t\t\t     HIR::TraitItemType &type) const\n+{\n+  TyTy::TyVar var (get_mappings ().get_hirid ());\n+  return var.get_tyty ();\n+}\n+\n+TyTy::BaseType *\n+TraitItemReference::get_type_from_constant (\n+  /*const*/ HIR::TraitItemConst &constant) const\n+{\n+  TyTy::BaseType *type = TypeCheckType::Resolve (constant.get_type ().get ());\n+  if (constant.has_expr ())\n+    {\n+      TyTy::BaseType *expr\n+\t= TypeCheckExpr::Resolve (constant.get_expr ().get (), false);\n+\n+      return type->unify (expr);\n+    }\n+  return type;\n+}\n+\n+TyTy::BaseType *\n+TraitItemReference::get_type_from_fn (/*const*/ HIR::TraitItemFunc &fn) const\n+{\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions\n+    = inherited_substitutions;\n+\n+  HIR::TraitFunctionDecl &function = fn.get_decl ();\n+  if (function.has_generics ())\n+    {\n+      for (auto &generic_param : function.get_generic_params ())\n+\t{\n+\t  switch (generic_param.get ()->get_kind ())\n+\t    {\n+\t    case HIR::GenericParam::GenericKind::LIFETIME:\n+\t      // Skipping Lifetime completely until better handling.\n+\t      break;\n+\n+\t      case HIR::GenericParam::GenericKind::TYPE: {\n+\t\tauto param_type\n+\t\t  = TypeResolveGenericParam::Resolve (generic_param.get ());\n+\t\tcontext->insert_type (generic_param->get_mappings (),\n+\t\t\t\t      param_type);\n+\n+\t\tsubstitutions.push_back (TyTy::SubstitutionParamMapping (\n+\t\t  static_cast<HIR::TypeParam &> (*generic_param), param_type));\n+\t      }\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  TyTy::BaseType *ret_type = nullptr;\n+  if (!function.has_return_type ())\n+    ret_type = new TyTy::TupleType (fn.get_mappings ().get_hirid ());\n+  else\n+    {\n+      auto resolved\n+\t= TypeCheckType::Resolve (function.get_return_type ().get ());\n+      if (resolved->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (fn.get_locus (), \"failed to resolve return type\");\n+\t  return get_error ();\n+\t}\n+\n+      ret_type = resolved->clone ();\n+      ret_type->set_ref (\n+\tfunction.get_return_type ()->get_mappings ().get_hirid ());\n+    }\n+\n+  std::vector<std::pair<HIR::Pattern *, TyTy::BaseType *> > params;\n+  if (function.is_method ())\n+    {\n+      // add the synthetic self param at the front, this is a placeholder\n+      // for compilation to know parameter names. The types are ignored\n+      // but we reuse the HIR identifier pattern which requires it\n+      HIR::SelfParam &self_param = function.get_self ();\n+      HIR::IdentifierPattern *self_pattern\n+\t= new HIR::IdentifierPattern (\"self\", self_param.get_locus (),\n+\t\t\t\t      self_param.is_ref (),\n+\t\t\t\t      self_param.is_mut (),\n+\t\t\t\t      std::unique_ptr<HIR::Pattern> (nullptr));\n+      context->insert_type (self_param.get_mappings (), self->clone ());\n+      params.push_back (\n+\tstd::pair<HIR::Pattern *, TyTy::BaseType *> (self_pattern,\n+\t\t\t\t\t\t     self->clone ()));\n+    }\n+\n+  for (auto &param : function.get_function_params ())\n+    {\n+      // get the name as well required for later on\n+      auto param_tyty = TypeCheckType::Resolve (param.get_type ());\n+      params.push_back (\n+\tstd::pair<HIR::Pattern *, TyTy::BaseType *> (param.get_param_name (),\n+\t\t\t\t\t\t     param_tyty));\n+\n+      context->insert_type (param.get_mappings (), param_tyty);\n+    }\n+\n+  return new TyTy::FnType (fn.get_mappings ().get_hirid (),\n+\t\t\t   function.get_function_name (), function.is_method (),\n+\t\t\t   std::move (params), ret_type, substitutions);\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "5aae2e3a9c56f09ab60b33cab968b49ba173f347", "filename": "gcc/testsuite/rust/compile/torture/traits6.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089e62f33c328afea756ec4b92f5823584b08a3a/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits6.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089e62f33c328afea756ec4b92f5823584b08a3a/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits6.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits6.rs?ref=089e62f33c328afea756ec4b92f5823584b08a3a", "patch": "@@ -0,0 +1,23 @@\n+trait Foo {\n+    type A;\n+    // { dg-warning \"unused name .Foo::A.\" \"\" { target *-*-* } .-1 }\n+\n+    fn baz(a: Self::A) -> Self::A;\n+    // { dg-warning \"unused name .a.\" \"\" { target *-*-* } .-1 }\n+    // { dg-warning \"unused name .Foo::baz.\" \"\" { target *-*-* } .-2 }\n+}\n+\n+struct Bar<T>(T);\n+\n+impl<T> Foo for Bar<T> {\n+    type A = T;\n+\n+    fn baz(a: Self::A) -> T {\n+        a\n+    }\n+}\n+\n+fn main() {\n+    let a;\n+    a = Bar::<i32>::baz(123);\n+}"}, {"sha": "a6fe5a34b6f5ffa4259a46b5ba6f35ae2e9ce056", "filename": "gcc/testsuite/rust/compile/torture/traits7.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089e62f33c328afea756ec4b92f5823584b08a3a/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits7.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089e62f33c328afea756ec4b92f5823584b08a3a/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits7.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits7.rs?ref=089e62f33c328afea756ec4b92f5823584b08a3a", "patch": "@@ -0,0 +1,22 @@\n+trait Foo {\n+    const A: i32;\n+    // { dg-warning \"unused name .Foo::A.\" \"\" { target *-*-* } .-1 }\n+\n+    fn test(self);\n+    // { dg-warning \"unused name .self.\" \"\" { target *-*-* } .-1 }\n+    // { dg-warning \"unused name .Foo::test.\" \"\" { target *-*-* } .-2 }\n+}\n+\n+struct Bar;\n+impl Foo for Bar {\n+    const A: i32 = 123;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+\n+    fn test(self) {}\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+}\n+\n+fn main() {\n+    let a = Bar;\n+    a.test();\n+}"}, {"sha": "c971a11bf8821a8d18bd1886ca0f2d92309aa13d", "filename": "gcc/testsuite/rust/compile/traits3.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089e62f33c328afea756ec4b92f5823584b08a3a/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089e62f33c328afea756ec4b92f5823584b08a3a/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits3.rs?ref=089e62f33c328afea756ec4b92f5823584b08a3a", "patch": "@@ -0,0 +1,22 @@\n+trait Foo {\n+    type A;\n+\n+    fn baz(a: Self::A) -> Self::A;\n+}\n+\n+struct Bar<T>(T);\n+\n+impl<T> Foo for Bar<T> {\n+    type A = i32;\n+\n+    fn baz(a: f32) -> f32 {\n+        // { dg-error \"expected .i32. got .f32.\" \"\" { target *-*-* } .-1 }\n+        // { dg-error \"method .baz. has an incompatible type for trait .Foo.\" \"\" { target *-*-* } .-2 }\n+        a\n+    }\n+}\n+\n+fn main() {\n+    let a;\n+    a = Bar::<i32>::baz(123f32);\n+}"}, {"sha": "486301d61369820d1ee7872e26d80439632383ad", "filename": "gcc/testsuite/rust/compile/traits4.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089e62f33c328afea756ec4b92f5823584b08a3a/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits4.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089e62f33c328afea756ec4b92f5823584b08a3a/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits4.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits4.rs?ref=089e62f33c328afea756ec4b92f5823584b08a3a", "patch": "@@ -0,0 +1,16 @@\n+trait Foo {\n+    const A: i32;\n+\n+    fn test(self);\n+}\n+\n+struct Bar;\n+impl Foo for Bar {\n+    // { dg-error \"missing A in implementation of trait .Foo.\" \"\" { target *-*-* } .-1 }\n+    fn test(self) {}\n+}\n+\n+fn main() {\n+    let a = Bar;\n+    a.test();\n+}"}, {"sha": "8b2fb9bc10d4da1b864b689b776fa603105886ef", "filename": "gcc/testsuite/rust/compile/traits5.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089e62f33c328afea756ec4b92f5823584b08a3a/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits5.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089e62f33c328afea756ec4b92f5823584b08a3a/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits5.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits5.rs?ref=089e62f33c328afea756ec4b92f5823584b08a3a", "patch": "@@ -0,0 +1,9 @@\n+trait Foo {\n+    const A: i32;\n+\n+    fn test(self);\n+}\n+\n+struct Bar;\n+impl Foo for Bar {}\n+// { dg-error \"missing A, test in implementation of trait .Foo.\" \"\" { target *-*-* } .-1 }"}]}