{"sha": "b2ca46dfad0bfd7246383eeda6446ea98c4d9817", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjJjYTQ2ZGZhZDBiZmQ3MjQ2MzgzZWVkYTY0NDZlYTk4YzRkOTgxNw==", "commit": {"author": {"name": "Evandro Menezes", "email": "e.menezes@samsung.com", "date": "2015-12-07T19:30:01Z"}, "committer": {"name": "Evandro Menezes", "email": "evandro@gcc.gnu.org", "date": "2015-12-07T19:30:01Z"}, "message": "Add scheduling model for Exynos M1\n\ngcc/\n\t* config/aarch64/aarch64-cores.def: Use the Exynos M1 sched model.\n\t* config/aarch64/aarch64.md: Include \"exynos-m1.md\".\n\t* config/arm/arm.md: Likewise.\n\t* config/arm/exynos-m1.md: New file.\n\nFrom-SVN: r231378", "tree": {"sha": "c5dc6a5acd3be153866de991d8eddcd898c846df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c5dc6a5acd3be153866de991d8eddcd898c846df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b2ca46dfad0bfd7246383eeda6446ea98c4d9817", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2ca46dfad0bfd7246383eeda6446ea98c4d9817", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2ca46dfad0bfd7246383eeda6446ea98c4d9817", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2ca46dfad0bfd7246383eeda6446ea98c4d9817/comments", "author": null, "committer": null, "parents": [{"sha": "2efd77e92ded2bc3540c60f8ffa856fa04582e2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2efd77e92ded2bc3540c60f8ffa856fa04582e2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2efd77e92ded2bc3540c60f8ffa856fa04582e2b"}], "stats": {"total": 960, "additions": 958, "deletions": 2}, "files": [{"sha": "8741e03e458daaf27438d96ea9ccf8918eb555a1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2ca46dfad0bfd7246383eeda6446ea98c4d9817/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2ca46dfad0bfd7246383eeda6446ea98c4d9817/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b2ca46dfad0bfd7246383eeda6446ea98c4d9817", "patch": "@@ -1,3 +1,10 @@\n+2015-12-07  Evandro Menezes  <e.menezes@samsung.com>\n+\n+\t* config/aarch64/aarch64-cores.def: Use the Exynos M1 sched model.\n+\t* config/aarch64/aarch64.md: Include \"exynos-m1.md\".\n+\t* config/arm/arm.md: Likewise.\n+\t* config/arm/exynos-m1.md: New file.\n+\n 2015-12-07  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* fold-const.c (operand_equal_p): Drp flag_strict_aliasing check."}, {"sha": "e4b2e20d95a06fcfe1f3336d420583339b7e2813", "filename": "gcc/config/aarch64/aarch64-cores.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2ca46dfad0bfd7246383eeda6446ea98c4d9817/gcc%2Fconfig%2Faarch64%2Faarch64-cores.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2ca46dfad0bfd7246383eeda6446ea98c4d9817/gcc%2Fconfig%2Faarch64%2Faarch64-cores.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-cores.def?ref=b2ca46dfad0bfd7246383eeda6446ea98c4d9817", "patch": "@@ -44,7 +44,7 @@ AARCH64_CORE(\"cortex-a35\",  cortexa35, cortexa53, 8A,  AARCH64_FL_FOR_ARCH8 | AA\n AARCH64_CORE(\"cortex-a53\",  cortexa53, cortexa53, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa53, \"0x41\", \"0xd03\")\n AARCH64_CORE(\"cortex-a57\",  cortexa57, cortexa57, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa57, \"0x41\", \"0xd07\")\n AARCH64_CORE(\"cortex-a72\",  cortexa72, cortexa57, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa72, \"0x41\", \"0xd08\")\n-AARCH64_CORE(\"exynos-m1\",   exynosm1,  cortexa57, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC | AARCH64_FL_CRYPTO, exynosm1,  \"0x53\", \"0x001\")\n+AARCH64_CORE(\"exynos-m1\",   exynosm1,  exynosm1,  8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC | AARCH64_FL_CRYPTO, exynosm1,  \"0x53\", \"0x001\")\n AARCH64_CORE(\"qdf24xx\",     qdf24xx,   cortexa57, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC | AARCH64_FL_CRYPTO, cortexa57, \"0x51\", \"0x800\")\n AARCH64_CORE(\"thunderx\",    thunderx,  thunderx,  8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC | AARCH64_FL_CRYPTO, thunderx,  \"0x43\", \"0x0a1\")\n AARCH64_CORE(\"xgene1\",      xgene1,    xgene1,    8A,  AARCH64_FL_FOR_ARCH8, xgene1, \"0x50\", \"0x000\")"}, {"sha": "d9fe1ae4593c4a174632d59080b9b6be366d81d9", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2ca46dfad0bfd7246383eeda6446ea98c4d9817/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2ca46dfad0bfd7246383eeda6446ea98c4d9817/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=b2ca46dfad0bfd7246383eeda6446ea98c4d9817", "patch": "@@ -211,6 +211,7 @@\n ;; Scheduling\n (include \"../arm/cortex-a53.md\")\n (include \"../arm/cortex-a57.md\")\n+(include \"../arm/exynos-m1.md\")\n (include \"thunderx.md\")\n (include \"../arm/xgene1.md\")\n "}, {"sha": "a91873c8948ba66699e8ca7cce0289134730782d", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2ca46dfad0bfd7246383eeda6446ea98c4d9817/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2ca46dfad0bfd7246383eeda6446ea98c4d9817/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=b2ca46dfad0bfd7246383eeda6446ea98c4d9817", "patch": "@@ -380,7 +380,7 @@\n                                 arm1136jfs,cortexa5,cortexa7,cortexa8,\\\n                                 cortexa9,cortexa12,cortexa15,cortexa17,\\\n                                 cortexa53,cortexa57,cortexm4,cortexm7,\\\n-\t\t\t\tmarvell_pj4,xgene1\")\n+\t\t\t\texynosm1,marvell_pj4,xgene1\")\n \t       (eq_attr \"tune_cortexr4\" \"yes\"))\n           (const_string \"no\")\n           (const_string \"yes\"))))\n@@ -419,6 +419,7 @@\n (include \"cortex-m7.md\")\n (include \"cortex-m4.md\")\n (include \"cortex-m4-fpu.md\")\n+(include \"exynos-m1.md\")\n (include \"vfp11.md\")\n (include \"marvell-pj4.md\")\n (include \"xgene1.md\")"}, {"sha": "fd73353188ba4665f125150fdd063e48d40d5e75", "filename": "gcc/config/arm/exynos-m1.md", "status": "added", "additions": 947, "deletions": 0, "changes": 947, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2ca46dfad0bfd7246383eeda6446ea98c4d9817/gcc%2Fconfig%2Farm%2Fexynos-m1.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2ca46dfad0bfd7246383eeda6446ea98c4d9817/gcc%2Fconfig%2Farm%2Fexynos-m1.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fexynos-m1.md?ref=b2ca46dfad0bfd7246383eeda6446ea98c4d9817", "patch": "@@ -0,0 +1,947 @@\n+;; Samsung Exynos M1 pipeline description\n+;; Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but\n+;; WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+;; General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+(define_attr \"exynos_m1_neon_type\"\n+  \"neon_arith_simple, neon_arith_basic, neon_arith_complex,\n+   neon_multiply, neon_mla, neon_mla_q, neon_mla_long, neon_sat_mla_long,\n+   neon_shift_acc, neon_shift_imm_basic, neon_shift_imm_complex,\n+   neon_shift_reg_basic, neon_shift_reg_basic_q,\n+   neon_shift_reg_complex, neon_shift_reg_complex_q,\n+   neon_fp_unary, neon_fp_add, neon_fp_abd, neon_fp_compare,\n+   neon_fp_reduc_minmax, neon_fp_reduc_add, neon_fp_round, neon_fp_cvt,\n+   neon_fp_minmax, neon_fp_mul, neon_fp_mul_q, neon_fp_mla, neon_fp_mla_q,\n+   neon_fp_estimate, neon_fp_estimatex, neon_fp_step,\n+   neon_bitops, neon_bitops_q, neon_bitins,\n+   neon_to_gp, neon_from_gp, neon_move, neon_tbl,\n+   neon_load1_1, neon_load1_2, neon_load1_3, neon_load1_4,\n+   neon_load1_one, neon_load1_all,\n+   neon_load2_2, neon_load2_one, neon_load2_all,\n+   neon_load3_3, neon_load3_one, neon_load3_all,\n+   neon_load4_4, neon_load4_one, neon_load4_all,\n+   neon_store,\n+   neon_store1_1, neon_store1_2, neon_store1_3, neon_store1_4, neon_store1_one,\n+   neon_store2_2, neon_store2_one,\n+   neon_store3_3, neon_store3_one,\n+   neon_store4_4, neon_store4_one,\n+   unknown\"\n+  (cond [\n+\t  (eq_attr \"type\" \"neon_abd, neon_abd_q, neon_abd_long,\\\n+\t\t\t   neon_abs, neon_abs_q,\\\n+\t\t\t   neon_minmax, neon_minmax_q\")\n+\t    (const_string \"neon_arith_simple\")\n+\n+\t  (eq_attr \"type\" \"neon_add, neon_add_q, neon_add_long,\\\n+\t\t\t   neon_neg, neon_neg_q,\\\n+\t\t\t   neon_sub, neon_sub_q, neon_sub_long, neon_sub_widen,\\\n+\t\t\t   neon_logic, neon_logic_q, neon_tst, neon_tst_q,\\\n+\t\t\t   neon_compare_zero, neon_compare_zero_q\")\n+\t    (const_string \"neon_arith_basic\")\n+\n+\t  (eq_attr \"type\" \"neon_add_widen, neon_arith_acc, neon_arith_acc_q,\\\n+\t\t\t   neon_reduc_add, neon_reduc_add_q,\\\n+\t\t\t   neon_reduc_add_acc, neon_reduc_add_acc_q,\\\n+\t\t\t   neon_reduc_add_long, neon_add_halve_narrow_q,\\\n+\t\t\t   neon_add_halve, neon_add_halve_q,\\\n+\t\t\t   neon_sub_halve, neon_sub_halve_q, neon_qabs,\\\n+\t\t\t   neon_qabs_q, neon_qadd, neon_qadd_q, neon_qneg,\\\n+\t\t\t   neon_qneg_q, neon_qsub, neon_qsub_q,\\\n+\t\t\t   neon_sub_halve_narrow_q,\\\n+\t\t\t   neon_compare, neon_compare_q,\\\n+\t\t\t   neon_reduc_minmax, neon_reduc_minmax_q\")\n+\t    (const_string \"neon_arith_complex\")\n+\n+\t  (eq_attr \"type\" \"neon_mul_b, neon_mul_b_q, neon_mul_h, neon_mul_h_q,\\\n+\t\t\t   neon_mul_s, neon_mul_s_q,\\\n+\t\t\t   neon_mul_h_scalar, neon_mul_h_scalar_q,\\\n+\t\t\t   neon_mul_s_scalar, neon_mul_s_scalar_q,\\\n+\t\t\t   neon_mul_h_scalar_long, neon_mul_s_scalar_long,\\\n+\t\t\t   neon_sat_mul_b, neon_sat_mul_b_q,\\\n+\t\t\t   neon_sat_mul_h, neon_sat_mul_h_q,\\\n+\t\t\t   neon_sat_mul_s, neon_sat_mul_s_q,\\\n+\t\t\t   neon_sat_mul_h_scalar, neon_sat_mul_h_scalar_q,\\\n+\t\t\t   neon_sat_mul_s_scalar, neon_sat_mul_s_scalar_q,\\\n+\t\t\t   neon_sat_mul_b_long, neon_sat_mul_h_long,\\\n+\t\t\t   neon_sat_mul_s_long, neon_sat_mul_h_scalar_long,\\\n+\t\t\t   neon_sat_mul_s_scalar_long\")\n+\t    (const_string \"neon_multiply\")\n+\n+\t  (eq_attr \"type\" \"neon_mla_b, neon_mla_h, neon_mla_s,\\\n+\t\t\t   neon_mla_h_scalar, neon_mla_s_scalar,\\\n+\t\t\t   neon_mla_b_long, neon_mla_h_long,\\\n+\t\t\t   neon_mla_s_long,\\\n+\t\t\t   neon_mla_h_scalar_long, neon_mla_s_scalar_long,\\\n+\t\t\t   neon_mla_b_q, neon_mla_h_q, neon_mla_s_q,\\\n+\t\t\t   neon_mla_h_scalar_q, neon_mla_s_scalar_q\")\n+\t    (const_string \"neon_mla\")\n+\n+\t  (eq_attr \"type\" \"neon_sat_mla_b_long, neon_sat_mla_h_long,\\\n+\t\t\t   neon_sat_mla_s_long, neon_sat_mla_h_scalar_long,\\\n+\t\t\t   neon_sat_mla_s_scalar_long\")\n+\t    (const_string \"neon_sat_mla_long\")\n+\n+\t  (eq_attr \"type\" \"neon_shift_acc, neon_shift_acc_q\")\n+\t    (const_string \"neon_shift_acc\")\n+\n+\t  (eq_attr \"type\" \"neon_shift_imm, neon_shift_imm_q,\\\n+\t\t\t   neon_shift_imm_narrow_q, neon_shift_imm_long\")\n+\t    (const_string \"neon_shift_imm_basic\")\n+\n+\t  (eq_attr \"type\" \"neon_sat_shift_imm, neon_sat_shift_imm_q,\\\n+\t\t\t   neon_sat_shift_imm_narrow_q\")\n+\t    (const_string \"neon_shift_imm_complex\")\n+\n+\t  (eq_attr \"type\" \"neon_shift_reg, neon_shift_reg_q\")\n+\t    (const_string \"neon_shift_reg_basic\")\n+\n+\t  (eq_attr \"type\" \"neon_sat_shift_reg, neon_sat_shift_reg_q\")\n+\t    (const_string \"neon_shift_reg_complex\")\n+\n+\t  (eq_attr \"type\" \"neon_fp_neg_s, neon_fp_neg_s_q,\\\n+\t\t\t   neon_fp_abs_s, neon_fp_abs_s_q,\\\n+\t\t\t   neon_fp_neg_d, neon_fp_neg_d_q,\\\n+\t\t\t   neon_fp_abs_d, neon_fp_abs_d_q\")\n+\t    (const_string \"neon_fp_unary\")\n+\n+\t  (eq_attr \"type\" \"neon_fp_addsub_s, neon_fp_addsub_s_q,\\\n+\t\t\t   neon_fp_addsub_d, neon_fp_addsub_d_q\")\n+\t    (const_string \"neon_fp_add\")\n+\n+\t  (eq_attr \"type\" \"neon_fp_abd_s, neon_fp_abd_s_q,\\\n+\t\t\t   neon_fp_abd_d, neon_fp_abd_d_q\")\n+\t    (const_string \"neon_fp_abd\")\n+\n+\t  (eq_attr \"type\" \"neon_fp_compare_s, neon_fp_compare_s_q,\\\n+\t\t\t   neon_fp_compare_d, neon_fp_compare_d_q,\\\n+\t\t\t   neon_fp_minmax_s, neon_fp_minmax_s_q,\\\n+\t\t\t   neon_fp_minmax_d, neon_fp_minmax_d_q\")\n+\t    (const_string \"neon_fp_compare\")\n+\n+\t  (eq_attr \"type\" \"neon_fp_reduc_minmax_s, neon_fp_reduc_minmax_s_q,\\\n+\t\t\t   neon_fp_reduc_minmax_d, neon_fp_reduc_minmax_d_q\")\n+\t    (const_string \"neon_fp_reduc_minmax\")\n+\n+\t  (eq_attr \"type\" \"neon_fp_reduc_add_s, neon_fp_reduc_add_s_q,\\\n+\t\t\t   neon_fp_reduc_add_d, neon_fp_reduc_add_d_q\")\n+\t    (const_string \"neon_fp_reduc_add\")\n+\n+\t  (eq_attr \"type\" \"neon_fp_round_s, neon_fp_round_s_q,\\\n+\t\t\t   neon_fp_round_d, neon_fp_round_d_q\")\n+\t    (const_string \"neon_fp_round\")\n+\n+\t  (eq_attr \"type\" \"neon_fp_cvt_narrow_s_q, neon_fp_cvt_widen_h,\n+\t\t\t   neon_fp_to_int_s, neon_fp_to_int_s_q,\\\n+\t\t\t   neon_fp_to_int_d_q, neon_fp_to_int_d,\\\n+\t\t\t   neon_int_to_fp_s, neon_int_to_fp_s_q,\\\n+\t\t\t   neon_int_to_fp_d, neon_int_to_fp_d_q\")\n+\t    (const_string \"neon_fp_cvt\")\n+\n+\t  (eq_attr \"type\" \"neon_fp_mul_s, neon_fp_mul_s_q,\\\n+\t\t\t   neon_fp_mul_s_scalar, neon_fp_mul_s_scalar_q,\\\n+\t\t\t   neon_fp_mul_d, neon_fp_mul_d_q,\\\n+\t\t\t   neon_fp_mul_d_scalar_q\")\n+\t    (const_string \"neon_fp_mul\")\n+\n+\t  (eq_attr \"type\" \"neon_fp_mla_s, neon_fp_mla_s_q,\\\n+\t\t\t   neon_fp_mla_s_scalar,neon_fp_mla_s_scalar_q,\\\n+\t\t\t   neon_fp_mla_d, neon_fp_mla_d_q,\\\n+\t\t\t   neon_fp_mla_d_scalar_q\")\n+\t    (const_string \"neon_fp_mla\")\n+\n+\t  (eq_attr \"type\" \"neon_fp_recpe_s, neon_fp_recpe_s_q,\\\n+\t\t\t   neon_fp_rsqrte_s, neon_fp_rsqrte_s_q,\\\n+\t\t\t   neon_fp_recpe_d, neon_fp_recpe_d_q,\\\n+\t\t\t   neon_fp_rsqrte_d, neon_fp_rsqrte_d_q\")\n+\t    (const_string \"neon_fp_estimate\")\n+\n+\t  (eq_attr \"type\" \"neon_fp_recpx_s, neon_fp_recpx_s_q,\\\n+\t\t\t   neon_fp_recpx_d, neon_fp_recpx_d_q\")\n+\t    (const_string \"neon_fp_estimatex\")\n+\n+\t  (eq_attr \"type\" \"neon_fp_recps_s, neon_fp_recps_s_q,\\\n+\t\t\t   neon_fp_rsqrts_s, neon_fp_rsqrts_s_q,\\\n+\t\t\t   neon_fp_recps_d, neon_fp_recps_d_q,\\\n+\t\t\t   neon_fp_rsqrts_d, neon_fp_rsqrts_d_q\")\n+\t    (const_string \"neon_fp_step\")\n+\n+\t  (eq_attr \"type\" \"neon_rbit, neon_rbit_q,\\\n+\t\t\t   neon_cls, neon_cls_q, neon_cnt, neon_cnt_q,\\\n+\t\t\t   neon_dup, neon_dup_q,\\\n+\t\t\t   neon_rev, neon_rev_q,\\\n+\t\t\t   neon_move, neon_move_q,\n+\t\t\t   neon_ext, neon_permute, neon_zip\")\n+\t    (const_string \"neon_bitops\")\n+\n+\t  (eq_attr \"type\" \"neon_ext_q, neon_permute_q, neon_zip_q\")\n+\t    (const_string \"neon_bitops_q\")\n+\n+\t  (eq_attr \"type\" \"neon_bsl, neon_bsl_q\")\n+\t    (const_string \"neon_bitins\")\n+\n+\t  (eq_attr \"type\" \"neon_tbl1, neon_tbl2, neon_tbl3, neon_tbl4\")\n+\t    (const_string \"neon_tbl\")\n+\n+\t  (eq_attr \"type\" \"neon_from_gp, neon_from_gp_q, f_mcr, f_mcrr\")\n+\t    (const_string \"neon_from_gp\")\n+\n+\t  (eq_attr \"type\" \"neon_to_gp, neon_to_gp_q, f_mrc, f_mrrc\")\n+\t    (const_string \"neon_to_gp\")\n+\n+\t  (eq_attr \"type\" \"neon_load1_1reg, neon_load1_1reg_q\")\n+\t    (const_string \"neon_load1_1\")\n+\n+\t  (eq_attr \"type\" \"neon_load1_2reg, neon_load1_2reg_q\")\n+\t    (const_string \"neon_load1_2\")\n+\n+\t  (eq_attr \"type\" \"neon_load1_3reg, neon_load1_3reg_q\")\n+\t    (const_string \"neon_load1_3\")\n+\n+\t  (eq_attr \"type\" \"neon_load1_4reg, neon_load1_4reg_q\")\n+\t    (const_string \"neon_load1_4\")\n+\n+\t  (eq_attr \"type\" \"neon_load1_one_lane, neon_load1_one_lane_q\")\n+\t    (const_string \"neon_load1_one\")\n+\n+\t  (eq_attr \"type\" \"neon_load1_all_lanes, neon_load1_all_lanes_q\")\n+\t    (const_string \"neon_load1_all\")\n+\n+\t  (eq_attr \"type\" \"neon_load2_2reg, neon_load2_2reg_q,\\\n+\t\t\t   neon_load2_4reg, neon_load2_4reg_q\")\n+\t    (const_string \"neon_load2_2\")\n+\n+\t  (eq_attr \"type\" \"neon_load2_one_lane, neon_load2_one_lane_q\")\n+\t    (const_string \"neon_load2_one\")\n+\n+\t  (eq_attr \"type\" \"neon_load2_all_lanes, neon_load2_all_lanes_q\")\n+\t    (const_string \"neon_load2_all\")\n+\n+\t  (eq_attr \"type\" \"neon_load3_3reg, neon_load3_3reg_q\")\n+\t    (const_string \"neon_load3_3\")\n+\n+\t  (eq_attr \"type\" \"neon_load3_one_lane, neon_load3_one_lane_q\")\n+\t    (const_string \"neon_load3_one\")\n+\n+\t  (eq_attr \"type\" \"neon_load3_all_lanes, neon_load3_all_lanes_q\")\n+\t    (const_string \"neon_load3_all\")\n+\n+\t  (eq_attr \"type\" \"neon_load4_4reg, neon_load4_4reg_q\")\n+\t    (const_string \"neon_load4_4\")\n+\n+\t  (eq_attr \"type\" \"neon_load4_one_lane, neon_load4_one_lane_q\")\n+\t    (const_string \"neon_load4_one\")\n+\n+\t  (eq_attr \"type\" \"neon_load4_all_lanes, neon_load4_all_lanes_q\")\n+\t    (const_string \"neon_load4_all\")\n+\n+\t  (eq_attr \"type\" \"f_stores, f_stored,\\\n+\t\t\t   neon_stp, neon_stp_q\")\n+\t    (const_string \"neon_store\")\n+\n+\t  (eq_attr \"type\" \"neon_store1_1reg, neon_store1_1reg_q\")\n+\t    (const_string \"neon_store1_1\")\n+\n+\t  (eq_attr \"type\" \"neon_store1_2reg, neon_store1_2reg_q\")\n+\t    (const_string \"neon_store1_2\")\n+\n+\t  (eq_attr \"type\" \"neon_store1_3reg, neon_store1_3reg_q\")\n+\t    (const_string \"neon_store1_3\")\n+\n+\t  (eq_attr \"type\" \"neon_store1_4reg, neon_store1_4reg_q\")\n+\t    (const_string \"neon_store1_4\")\n+\n+\t  (eq_attr \"type\" \"neon_store1_one_lane, neon_store1_one_lane_q\")\n+\t    (const_string \"neon_store1_one\")\n+\n+\t  (eq_attr \"type\" \"neon_store2_2reg, neon_store2_2reg_q,\\\n+\t\t\t   neon_store2_4reg, neon_store2_4reg_q\")\n+\t    (const_string \"neon_store2_2\")\n+\n+\t  (eq_attr \"type\" \"neon_store2_one_lane, neon_store2_one_lane_q\")\n+\t    (const_string \"neon_store2_one\")\n+\n+\t  (eq_attr \"type\" \"neon_store3_3reg, neon_store3_3reg_q\")\n+\t    (const_string \"neon_store3_3\")\n+\n+\t  (eq_attr \"type\" \"neon_store3_one_lane, neon_store3_one_lane_q\")\n+\t    (const_string \"neon_store3_one\")\n+\n+\t  (eq_attr \"type\" \"neon_store4_4reg, neon_store4_4reg_q\")\n+\t    (const_string \"neon_store4_4\")\n+\n+\t  (eq_attr \"type\" \"neon_store4_one_lane, neon_store4_one_lane_q\")\n+\t    (const_string \"neon_store4_one\")]\n+\n+\t  (const_string \"unknown\")))\n+\n+;; The Exynos M1 core is modeled as a triple issue pipeline that has\n+;; the following functional units.\n+\n+(define_automaton \"exynos_m1_gp\")\n+(define_automaton \"exynos_m1_ls\")\n+(define_automaton \"exynos_m1_fp\")\n+\n+;; 1.  Two pipelines for simple integer operations: A, B\n+;; 2.  One pipeline for simple or complex integer operations: C\n+\n+(define_cpu_unit \"em1_xa, em1_xb, em1_xc\" \"exynos_m1_gp\")\n+\n+(define_reservation \"em1_alu\" \"(em1_xa | em1_xb | em1_xc)\")\n+(define_reservation \"em1_c\" \"em1_xc\")\n+\n+;; 3.  Two asymmetric pipelines for Neon and FP operations: F0, F1\n+\n+(define_cpu_unit \"em1_f0, em1_f1\" \"exynos_m1_fp\")\n+\n+(define_reservation \"em1_fmac\" \"em1_f0\")\n+(define_reservation \"em1_fcvt\" \"em1_f0\")\n+(define_reservation \"em1_nalu\" \"(em1_f0 | em1_f1)\")\n+(define_reservation \"em1_nalu0\" \"em1_f0\")\n+(define_reservation \"em1_nalu1\" \"em1_f1\")\n+(define_reservation \"em1_nmisc\" \"em1_f0\")\n+(define_reservation \"em1_ncrypt\" \"em1_f0\")\n+(define_reservation \"em1_fadd\" \"em1_f1\")\n+(define_reservation \"em1_fvar\" \"em1_f1\")\n+(define_reservation \"em1_fst\" \"em1_f1\")\n+\n+;; 4.  One pipeline for branch operations: BX\n+\n+(define_cpu_unit \"em1_bx\" \"exynos_m1_gp\")\n+\n+(define_reservation \"em1_br\" \"em1_bx\")\n+\n+;; 5.  One AGU for loads: L\n+;;     One AGU for stores and one pipeline for stores: S, SD\n+\n+(define_cpu_unit \"em1_lx\" \"exynos_m1_ls\")\n+(define_cpu_unit \"em1_sx, em1_sd\" \"exynos_m1_ls\")\n+\n+(define_reservation \"em1_ld\" \"em1_lx\")\n+(define_reservation \"em1_st\" \"(em1_sx + em1_sd)\")\n+\n+;; Common occurrences\n+(define_reservation \"em1_sfst\" \"(em1_fst + em1_st)\")\n+(define_reservation \"em1_lfst\" \"(em1_fst + em1_ld)\")\n+\n+;; Branches\n+;;\n+;; No latency as there is no result\n+;; TODO: Unconditional branches use no units;\n+;; conditional branches add the BX unit;\n+;; indirect branches add the C unit.\n+(define_insn_reservation \"exynos_m1_branch\" 0\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"type\" \"branch\"))\n+  \"em1_br\")\n+\n+(define_insn_reservation \"exynos_m1_call\" 1\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"type\" \"call\"))\n+  \"em1_alu\")\n+\n+;; Basic ALU\n+;;\n+;; Simple ALU without shift, non-predicated\n+(define_insn_reservation \"exynos_m1_alu\" 1\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (and (not (eq_attr \"predicated\" \"yes\"))\n+\t    (eq_attr \"type\" \"alu_imm, alus_imm, logic_imm, logics_imm,\\\n+\t\t\t     alu_sreg, alus_sreg, logic_reg, logics_reg,\\\n+\t\t\t     adc_imm, adcs_imm, adc_reg, adcs_reg,\\\n+\t\t\t     adr, bfm, clz, rbit, rev, csel, alu_dsp_reg,\\\n+\t\t\t     shift_imm, shift_reg, rotate_imm, extend,\\\n+\t\t\t     mov_imm, mov_reg,\\\n+\t\t\t     mvn_imm, mvn_reg,\\\n+\t\t\t     mrs, multiple\")))\n+  \"em1_alu\")\n+\n+;; Simple ALU without shift, predicated\n+(define_insn_reservation \"exynos_m1_alu_p\" 1\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (and (eq_attr \"predicated\" \"yes\")\n+\t    (eq_attr \"type\" \"alu_imm, alus_imm, logic_imm, logics_imm,\\\n+\t\t\t     alu_sreg, alus_sreg, logic_reg, logics_reg,\\\n+\t\t\t     adc_imm, adcs_imm, adc_reg, adcs_reg,\\\n+\t\t\t     adr, bfm, clz, rbit, rev, alu_dsp_reg,\\\n+\t\t\t     shift_imm, shift_reg, rotate_imm, extend,\\\n+\t\t\t     mov_imm, mov_reg,\\\n+\t\t\t     mvn_imm, mvn_reg,\\\n+\t\t\t     mrs, multiple\")))\n+  \"em1_c\")\n+\n+;; ALU ops with immediate shift\n+;; TODO: if the shift value is between 0 and 3, the latency is just 1 cycle;\n+;;       otherwise it takes 2 cycles and the unit is blocked;\n+;;       for now, assume the latter's latency and the former's units.\n+(define_insn_reservation \"exynos_m1_alu_shift\" 2\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"type\" \"alu_ext, alus_ext,\\\n+\t\t\talu_shift_imm, alus_shift_imm,\\\n+\t\t\tlogic_shift_imm, logics_shift_imm,\\\n+\t\t\tmov_shift, mvn_shift\"))\n+  \"(em1_alu)\")\n+\n+;; ALU ops with register controlled shift, non-predicated\n+(define_insn_reservation \"exynos_m1_alu_shift_reg\" 2\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (and (not (eq_attr \"predicated\" \"yes\"))\n+\t    (eq_attr \"type\" \"alu_shift_reg, alus_shift_reg,\\\n+\t\t\t     logic_shift_reg, logics_shift_reg,\\\n+\t\t\t     mov_shift_reg, mvn_shift_reg\")))\n+   \"(em1_alu * 2)\")\n+\n+;; ALU ops with register controlled shift, predicated\n+(define_insn_reservation \"exynos_m1_alu_shift_reg_p\" 2\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (and (eq_attr \"predicated\" \"yes\")\n+\t    (eq_attr \"type\" \"alu_shift_reg, alus_shift_reg,\\\n+\t\t\t     logic_shift_reg, logics_shift_reg,\\\n+\t\t\t     mov_shift_reg, mvn_shift_reg\")))\n+  \"(em1_alu, em1_c)\")\n+\n+;; Integer multiply\n+(define_insn_reservation \"exynos_m1_mla\" 3\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"mul32\" \"yes\"))\n+  \"em1_c\")\n+\n+(define_insn_reservation \"exynos_m1_mlal\" 4\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"mul64\" \"yes\"))\n+  \"em1_alu, em1_c\")\n+\n+;; Integer divide\n+;; TODO: assume the median latency; blocks other divisions\n+(define_insn_reservation \"exynos_m1_div\" 13\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"type\" \"udiv, sdiv\"))\n+  \"em1_c\")\n+\n+;; Load-store execution Unit\n+;;\n+;; Loads of up to 2 words.\n+(define_insn_reservation \"exynos_m1_load\" 4\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"type\" \"load_byte, load1, load2\"))\n+  \"em1_ld\")\n+\n+;; Loads of 3 or 4 words.\n+(define_insn_reservation \"exynos_m1_loadm\" 6\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"type\" \"load3, load4\"))\n+  \"(em1_ld * 3)\")\n+\n+;; Stores of up to 2 words.\n+(define_insn_reservation \"exynos_m1_store\" 1\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"type\" \"store1, store2\"))\n+  \"em1_st\")\n+\n+;; Stores of 3 or 4 words.\n+(define_insn_reservation \"exynos_m1_storem\" 3\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"type\" \"store3, store4\"))\n+  \"(em1_st * 3)\")\n+\n+;; Advanced SIMD Unit\n+;;\n+;; Integer Arithmetic Instructions.\n+\n+(define_insn_reservation  \"exynos_m1_arith_simple\" 1\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_arith_simple\"))\n+  \"em1_nmisc\")\n+\n+(define_insn_reservation  \"exynos_m1_neon_arith_basic\" 2\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_arith_basic\"))\n+  \"em1_nalu\")\n+\n+(define_insn_reservation  \"exynos_m1_neon_arith_complex\" 3\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_arith_complex\"))\n+  \"em1_nmisc\")\n+\n+;; Integer Multiply Instructions.\n+\n+(define_insn_reservation \"exynos_m1_neon_multiply\" 4\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\"\n+\t\t\"neon_multiply, neon_mla, neon_sat_mla_long\"))\n+  \"em1_nmisc\")\n+\n+;; Integer Shift Instructions.\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_shift_acc\" 4\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_shift_acc\"))\n+  \"em1_nalu1\")\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_shift_basic\" 2\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\"\n+\t\t\"neon_shift_imm_basic, neon_shift_reg_basic\"))\n+  \"em1_nalu\")\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_shift_complex\" 4\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\"\n+\t\t\"neon_shift_imm_complex, neon_shift_reg_complex\"))\n+  \"em1_nalu1\")\n+\n+;; Floating Point Instructions.\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_fp_unary\" 2\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_fp_unary\"))\n+  \"em1_nalu\")\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_fp_add\" 4\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_fp_add\"))\n+  \"em1_fadd\")\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_fp_abd\" 3\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_fp_abd\"))\n+  \"em1_nmisc\")\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_fp_compare\" 1\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_fp_compare\"))\n+  \"em1_nmisc\")\n+\n+;; TODO: the latency and throughput of reduce insns actually varies between\n+;; 3-5 and 1/4-1, but picked the median values.\n+(define_insn_reservation\n+  \"exynos_m1_neon_fp_reduc\" 5\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_fp_reduc_minmax\"))\n+  \"(em1_nmisc * 4)\")\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_fp_reduc_add\" 10\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_fp_reduc_add\"))\n+  \"((em1_nalu * 2), em1_fadd)\")\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_fp_round\" 4\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_fp_round\"))\n+  \"em1_fcvt\")\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_fp_cvt\" 4\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_fp_cvt\"))\n+  \"em1_fcvt\")\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_fp_mul\" 5\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_fp_mul\"))\n+  \"em1_fmac\")\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_fp_mla\" 6\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_fp_mla\"))\n+  \"em1_fmac\")\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_fp_estimate\" 5\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_fp_estimate\"))\n+  \"em1_fcvt\")\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_fp_estimatex\" 1\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_fp_estimatex\"))\n+  \"em1_nmisc\")\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_fp_step\" 6\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_fp_step\"))\n+  \"em1_fmac\")\n+\n+;; Miscellaneous Instructions.\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_bitops\" 2\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_bitops\"))\n+  \"em1_nalu\")\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_bitops_q\" 3\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_bitops_q\"))\n+  \"(em1_nalu, em1_nalu)\")\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_bitins\" 2\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_bitins\"))\n+  \"em1_nalu1\")\n+\n+;; TODO: it is more complicated than this.\n+(define_insn_reservation\n+  \"exynos_m1_neon_tbl\" 2\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_tbl\"))\n+  \"em1_nalu1\")\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_from_gp\" 4\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_from_gp\"))\n+  \"em1_st\")\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_to_gp\" 9\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_to_gp\"))\n+  \"em1_lfst\")\n+\n+;; Load Instructions.\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_load\" 5\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"type\" \"f_loads, f_loadd, neon_ldp\"))\n+  \"em1_ld\")\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_load_q\" 6\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"type\" \"neon_ldp_q\"))\n+  \"(em1_ld, em1_ld)\")\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_load1_1\" 6\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_load1_1, neon_load1_all\"))\n+  \"em1_ld\")\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_load1_2\" 6\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_load1_2\"))\n+  \"(em1_ld * 2)\")\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_load1_3\" 7\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_load1_3\"))\n+  \"(em1_ld * 3)\")\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_load1_4\" 8\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_load1_4\"))\n+  \"(em1_ld * 4)\")\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_load1_one\" 7\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_load1_one\"))\n+  \"((em1_ld * 2), em1_nalu)\")\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_load2_2\" 10\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_load2_2\"))\n+  \"(em1_ld * 5)\")\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_load2_one\" 7\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_load2_one\"))\n+  \"((em1_ld * 2), (em1_nalu * 2))\")\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_load2_all\" 6\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_load2_all\"))\n+  \"(em1_ld * 2)\")\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_load3_3\" 12\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_load3_3\"))\n+  \"(em1_ld * 6)\")\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_load3_one\" 9\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_load3_one\"))\n+  \"((em1_ld * 4), (em1_nalu * 3))\")\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_load3_all\" 7\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_load3_all\"))\n+  \"(em1_ld * 3)\")\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_load4_4\" 14\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_load4_4\"))\n+  \"(em1_ld * 7)\")\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_load4_one\" 9\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_load4_one\"))\n+  \"((em1_ld * 4), (em1_nalu * 4))\")\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_load4_all\" 8\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_load4_all\"))\n+  \"(em1_ld * 4)\")\n+\n+;; Store Instructions.\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_store\" 1\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_store\"))\n+  \"(em1_fst, em1_st)\")\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_store1_1\" 1\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_store1_1\"))\n+  \"em1_sfst\")\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_store1_2\" 2\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_store1_2\"))\n+  \"(em1_sfst * 2)\")\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_store1_3\" 3\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_store1_3\"))\n+  \"(em1_sfst * 3)\")\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_store1_4\" 4\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_store1_4\"))\n+  \"(em1_sfst * 4)\")\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_store1_one\" 7\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_store1_one\"))\n+  \"(em1_fst, em1_st)\")\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_store2\" 7\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_store2_2, neon_store2_one\"))\n+  \"em1_sfst, em1_fst\")\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_store3\" 16\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_store3_3, neon_store3_one\"))\n+  \"((em1_sfst * 3), (em1_fst * 2), em1_nalu)\")\n+\n+(define_insn_reservation\n+  \"exynos_m1_neon_store4\" 17\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"exynos_m1_neon_type\" \"neon_store4_4, neon_store4_one\"))\n+  \"((em1_sfst * 4), (em1_fst * 2), em1_nalu)\")\n+\n+;; Floating-Point Operations.\n+\n+(define_insn_reservation \"exynos_m1_fp_const\" 2\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"type\" \"fconsts, fconstd\"))\n+  \"em1_nalu\")\n+\n+(define_insn_reservation \"exynos_m1_fp_add\" 4\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"type\" \"fadds, faddd\"))\n+  \"em1_fadd\")\n+\n+(define_insn_reservation \"exynos_m1_fp_mul\" 5\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"type\" \"fmuls, fmuld\"))\n+  \"em1_fmac\")\n+\n+(define_insn_reservation \"exynos_m1_fp_mac\" 6\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"type\" \"fmacs, ffmas, fmacd, ffmad\"))\n+  \"em1_fmac\")\n+\n+(define_insn_reservation \"exynos_m1_fp_cvt\" 4\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"type\" \"f_cvt, f_rints, f_rintd\"))\n+  \"em1_fcvt\")\n+\n+(define_insn_reservation \"exynos_m1_fp_cvt_i\" 13\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"type\" \"f_cvtf2i\"))\n+  \"(em1_fcvt, em1_lfst)\")\n+\n+(define_insn_reservation \"exynos_m1_i_cvt_fp\" 9\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"type\" \"f_cvti2f\"))\n+  \"(em1_st, em1_fcvt)\")\n+\n+(define_insn_reservation \"exynos_m1_fp_cmp\" 4\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"type\" \"fcmps, fcmpd\"))\n+  \"em1_nmisc\")\n+\n+(define_insn_reservation \"exynos_m1_fp_sel\" 4\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"type\" \"fcsel\"))\n+  \"(em1_st + em1_nalu0)\")\n+\n+(define_insn_reservation \"exynos_m1_fp_arith\" 2\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"type\" \"ffariths, ffarithd\"))\n+  \"em1_nalu\")\n+\n+(define_insn_reservation \"exynos_m1_fp_cpy\" 2\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"type\" \"fmov\"))\n+  \"em1_nalu\")\n+\n+(define_insn_reservation \"exynos_m1_fp_divs\" 15\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"type\" \"fdivs, neon_fp_div_s, neon_fp_div_s_q,\\\n+\t\t\tfsqrts, neon_fp_sqrt_s, neon_fp_sqrt_s_q\"))\n+  \"(em1_fvar * 9)\")\n+\n+(define_insn_reservation \"exynos_m1_fp_divd\" 22\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"type\" \"fdivd, neon_fp_div_d, neon_fp_div_d_q,\\\n+\t\t\tfsqrtd, neon_fp_sqrt_d, neon_fp_sqrt_d_q\"))\n+  \"(em1_fvar * 9)\")\n+\n+(define_insn_reservation \"exynos_m1_fp_minmax\" 2\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"type\" \"f_minmaxs, f_minmaxd\"))\n+  \"(em1_nmisc * 2)\")\n+\n+;; Crypto Operations.\n+\n+(define_insn_reservation \"exynos_m1_crypto_simple\" 2\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"type\" \"crypto_aese, crypto_aesmc,\\\n+\t\t\tcrypto_sha1_xor, crypto_sha1_fast, crypto_sha256_fast\"))\n+  \"em1_ncrypt\")\n+\n+(define_insn_reservation \"exynos_m1_crypto_complex\" 6\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"type\" \"crypto_sha1_slow, crypto_sha256_slow\"))\n+  \"em1_ncrypt\")\n+\n+(define_insn_reservation \"exynos_m1_crypto_poly\" 2\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"type\" \"neon_mul_b_long, neon_mul_h_long, neon_mul_s_long\"))\n+  \"em1_ncrypt\")\n+\n+(define_insn_reservation \"exynos_m1_crypto_polyl\" 4\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"type\" \"neon_mul_d_long\"))\n+  \"em1_ncrypt\")\n+\n+(define_insn_reservation \"exynos_m1_crc\" 2\n+  (and (eq_attr \"tune\" \"exynosm1\")\n+       (eq_attr \"type\" \"crc\"))\n+  \"em1_c\")\n+\n+;; Simple execution unit bypasses\n+\n+;; Pre-decrement and post-increment addressing modes update the register quickly.\n+;; TODO: figure out how to tell the addressing mode register from the loaded one.\n+(define_bypass 1 \"exynos_m1_store*\" \"exynos_m1_store*\")\n+\n+;; MLAs can feed other MLAs quickly.\n+(define_bypass 1 \"exynos_m1_mla*\" \"exynos_m1_mla*\")\n+\n+;; Insns in FMAC or FADD can feed other such insns quickly.\n+(define_bypass 4 \"exynos_m1_fp_mul\"\n+\t\t \"exynos_m1_fp_add, exynos_m1_fp_mul, exynos_m1_fp_mac\")\n+(define_bypass 5 \"exynos_m1_fp_mac\"\n+\t\t \"exynos_m1_fp_add, exynos_m1_fp_mul, exynos_m1_fp_mac\")\n+(define_bypass 4 \"exynos_m1_neon_fp_mul\"\n+\t\t \"exynos_m1_neon_fp_add, exynos_m1_neon_fp_mul,\\\n+\t\t  exynos_m1_neon_fp_mla, exynos_m1_neon_fp_step\")\n+(define_bypass 5 \"exynos_m1_neon_fp_mla, exynos_m1_neon_fp_step\"\n+\t\t \"exynos_m1_neon_fp_add, exynos_m1_neon_fp_mul,\\\n+\t\t  exynos_m1_neon_fp_mla, exynos_m1_neon_fp_step\")\n+\n+(define_bypass 3 \"exynos_m1_fp_add\"\n+\t\t \"exynos_m1_fp_add, exynos_m1_fp_mul, exynos_m1_fp_mac\")\n+(define_bypass 3 \"exynos_m1_neon_fp_add\"\n+\t\t \"exynos_m1_neon_fp_add, exynos_m1_neon_fp_mul,\\\n+\t\t  exynos_m1_neon_fp_mla, exynos_m1_neon_fp_step\")\n+\n+;; Insns in NALU can feed other such insns quickly.\n+(define_bypass 1 \"exynos_m1_fp_const, exynos_m1_fp_arith, exynos_m1_fp_cpy\"\n+\t\t \"exynos_m1_fp_const, exynos_m1_fp_arith, exynos_m1_fp_cpy,\\\n+\t\t  exynos_m1_fp_sel\")\n+(define_bypass 3 \"exynos_m1_fp_sel\"\n+\t\t \"exynos_m1_fp_const, exynos_m1_fp_arith, exynos_m1_fp_cpy,\\\n+\t\t  exynos_m1_fp_sel\")\n+(define_bypass 1 \"exynos_m1_neon_arith_basic, exynos_m1_neon_shift_basic,\\\n+\t\t  exynos_m1_neon_bitops, exynos_m1_neon_bitins,\\\n+\t\t  exynos_m1_neon_tbl\"\n+\t\t \"exynos_m1_neon_arith_basic, exynos_m1_neon_shift_basic,\\\n+\t\t  exynos_m1_neon_shift_acc, exynos_m1_neon_shift_complex,\\\n+\t\t  exynos_m1_neon_bitops*, exynos_m1_neon_bitins,\\\n+\t\t  exynos_m1_neon_tbl\")\n+(define_bypass 3 \"exynos_m1_neon_shift_acc, exynos_m1_neon_shift_complex\"\n+\t\t \"exynos_m1_neon_arith_basic, exynos_m1_neon_shift_basic,\\\n+\t\t  exynos_m1_neon_shift_acc, exynos_m1_neon_shift_complex,\\\n+\t\t  exynos_m1_neon_bitops*, exynos_m1_neon_bitins,\\\n+\t\t  exynos_m1_neon_tbl\")\n+(define_bypass 1 \"exynos_m1_neon_fp_unary\" \"exynos_m1_neon_fp_unary\")\n+\n+;; Insns in NCRYPT can feed other such insns quickly.\n+(define_bypass 1 \"exynos_m1_crypto_simple, exynos_m1_crypto_poly\"\n+\t\t \"exynos_m1_crypto_simple, exynos_m1_crypto_complex,\\\n+\t\t  exynos_m1_crypto_poly*\")\n+(define_bypass 3 \"exynos_m1_crypto_polyl\"\n+\t\t \"exynos_m1_crypto_simple, exynos_m1_crypto_complex,\\\n+\t\t  exynos_m1_crypto_poly*\")\n+(define_bypass 5 \"exynos_m1_crypto_complex\"\n+\t\t \"exynos_m1_crypto_simple, exynos_m1_crypto_complex,\\\n+\t\t  exynos_m1_crypto_poly*\")\n+\n+;; Predicted branches take no time, but mispredicted ones take forever anyway.\n+(define_bypass 1 \"exynos_m1_*\"\n+\t\t \"exynos_m1_call, exynos_m1_branch\")"}]}