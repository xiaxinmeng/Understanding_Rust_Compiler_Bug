{"sha": "4dfa034295629327f8b823cb1c6dfa1585ac86ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGRmYTAzNDI5NTYyOTMyN2Y4YjgyM2NiMWM2ZGZhMTU4NWFjODZlZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-07-02T01:15:43Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-07-02T01:15:43Z"}, "message": "tree.def (RTL_EXPR): Remove.\n\n        * tree.def (RTL_EXPR): Remove.\n        * c-typeck.c (lvalue_p): Don't handle it.\n        * expr.c (safe_from_p): Likewise.\n        (expand_expr_real_1): Likewise.\n        * fold-const.c (non_lvalue, operand_equal_p, fold): Likewise.\n        (fold_checksum_tree, tree_expr_nonnegative_p): Likewise.\n        * gengtype.c (adjust_field_tree_exp): Likewise.\n        * stmt.c (warn_if_unused_value): Likewise.\n        * tree-gimple.c (recalculate_side_effects): Likewise.\n        * tree-pretty-print.c (dump_generic_node): Likewise.\n        * tree.c (make_node_stat, first_rtl_op, unsave_expr_1): Likewise.\n        (unsafe_for_reeval, stabilize_reference, build1_stat): Likewise.\n        * tree.h (RTL_EXPR_SEQUENCE, RTL_EXPR_RTL, RTL_EXPR_ALT_RTL): Remove.\n\n        * stmt.c (struct stmt_status): Remove x_last_expr_type,\n        x_last_expr_value, x_last_expr_alt_rtl, x_expr_stmts_for_value.\n        (last_expr_type, last_expr_value, last_expr_alt_rtl): Remove.\n        (expand_expr_stmt): Merge with expand_expr_stmt_value.  Remove\n        all the bits that tracked last_expr.\n        (expand_end_bindings): Don't track last_expr.\n        (expand_start_stmt_expr, expand_end_stmt_expr): Remove.\n        (clear_last_expr): Remove.\n        (expand_asm): Don't call it.\n        (expand_asm_operands, expand_end_cond): Likewise.\n        (expand_naked_return, expand_null_return_1): Likewise.\n        * c-typeck.c (c_begin_compound_stmt): Likewise.\n        * cfgexpand.c (expand_block): Use expand_expr_stmt.\n        * expr.c (expand_expr_real_1): Likewise.\n        * tree.h: Update prototypes.\n\n        * function.h (struct sequence_stack): Remove sequence_rtl_expr.\n        (struct emit_status): Remove sequence_rtl_expr.\n        (struct function): Remove x_rtl_expr_chain.\n        (seq_rtl_expr, rtl_expr_chain): Remove.\n        * function.c (struct temp_slot): Remove rtl_expr.\n        (assign_stack_temp_for_type): Don't set it.\n        (free_temp_slots, pop_temp_slots): Don't check it.\n        (free_after_compilation): Don't clear x_rtl_expr_chain.\n        (fixup_var_refs): Don't search it.\n        (preserve_rtl_expr_result, free_temps_for_rtl_expr): Remove.\n        * emit-rtl.c (start_sequence): Don't use sequence_rtl_expr\n        or seq_rtl_expr.\n        (push_topmost_sequence): Likewise.\n        (end_sequence, init_emit): Likewise.\n        (start_sequence_for_rtl_expr): Remove.\n        * expmed.c (make_tree): Build a VAR_DECL instead of an RTL_EXPR.\n        * rtl.h (preserve_rtl_expr_result): Remove.\n\nada/\n        * trans.c (gnat_stabilize_reference): Don't handle RTL_EXPR.\n        * utils.c (max_size): Likewise.\n\ncp/\n        * class.c (fixed_type_or_null): Don't handle RTL_EXPR.\n        * method.c (synthesize_method): Don't clear_last_expr.\n        * name-lookup.c (maybe_push_cleanup_level): Likewise.\n\nFrom-SVN: r84009", "tree": {"sha": "d7b1ab265a5bd2738e55776227182ff82a96a751", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7b1ab265a5bd2738e55776227182ff82a96a751"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4dfa034295629327f8b823cb1c6dfa1585ac86ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dfa034295629327f8b823cb1c6dfa1585ac86ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4dfa034295629327f8b823cb1c6dfa1585ac86ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dfa034295629327f8b823cb1c6dfa1585ac86ee/comments", "author": null, "committer": null, "parents": [{"sha": "f6fe65dc61754f3dc25a8757a1955b61e6374f51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6fe65dc61754f3dc25a8757a1955b61e6374f51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6fe65dc61754f3dc25a8757a1955b61e6374f51"}], "stats": {"total": 565, "additions": 107, "deletions": 458}, "files": [{"sha": "bee41d45458f92584f89d71e80d1ccdccefe4897", "filename": "gcc/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4dfa034295629327f8b823cb1c6dfa1585ac86ee", "patch": "@@ -1,3 +1,53 @@\n+2004-07-01  Richard Henderson  <rth@redhat.com>\n+\n+\t* tree.def (RTL_EXPR): Remove.\n+\t* c-typeck.c (lvalue_p): Don't handle it.\n+\t* expr.c (safe_from_p): Likewise.\n+\t(expand_expr_real_1): Likewise.\n+\t* fold-const.c (non_lvalue, operand_equal_p, fold): Likewise.\t\n+\t(fold_checksum_tree, tree_expr_nonnegative_p): Likewise.\n+\t* gengtype.c (adjust_field_tree_exp): Likewise.\n+\t* stmt.c (warn_if_unused_value): Likewise.\n+\t* tree-gimple.c (recalculate_side_effects): Likewise.\n+\t* tree-pretty-print.c (dump_generic_node): Likewise.\n+\t* tree.c (make_node_stat, first_rtl_op, unsave_expr_1): Likewise.\n+\t(unsafe_for_reeval, stabilize_reference, build1_stat): Likewise.\n+\t* tree.h (RTL_EXPR_SEQUENCE, RTL_EXPR_RTL, RTL_EXPR_ALT_RTL): Remove.\n+\n+\t* stmt.c (struct stmt_status): Remove x_last_expr_type,\n+\tx_last_expr_value, x_last_expr_alt_rtl, x_expr_stmts_for_value.\n+\t(last_expr_type, last_expr_value, last_expr_alt_rtl): Remove.\n+\t(expand_expr_stmt): Merge with expand_expr_stmt_value.  Remove\n+\tall the bits that tracked last_expr.\n+\t(expand_end_bindings): Don't track last_expr.\n+\t(expand_start_stmt_expr, expand_end_stmt_expr): Remove.\n+\t(clear_last_expr): Remove.\n+\t(expand_asm): Don't call it.\n+\t(expand_asm_operands, expand_end_cond): Likewise.\n+\t(expand_naked_return, expand_null_return_1): Likewise.\n+\t* c-typeck.c (c_begin_compound_stmt): Likewise.\n+\t* cfgexpand.c (expand_block): Use expand_expr_stmt.\n+\t* expr.c (expand_expr_real_1): Likewise.\n+\t* tree.h: Update prototypes.\n+\n+\t* function.h (struct sequence_stack): Remove sequence_rtl_expr.\n+\t(struct emit_status): Remove sequence_rtl_expr.\n+\t(struct function): Remove x_rtl_expr_chain.\n+\t(seq_rtl_expr, rtl_expr_chain): Remove.\n+\t* function.c (struct temp_slot): Remove rtl_expr.\n+\t(assign_stack_temp_for_type): Don't set it.\n+\t(free_temp_slots, pop_temp_slots): Don't check it.\n+\t(free_after_compilation): Don't clear x_rtl_expr_chain.\n+\t(fixup_var_refs): Don't search it.\n+\t(preserve_rtl_expr_result, free_temps_for_rtl_expr): Remove.\n+\t* emit-rtl.c (start_sequence): Don't use sequence_rtl_expr\n+\tor seq_rtl_expr.\n+\t(push_topmost_sequence): Likewise.\n+\t(end_sequence, init_emit): Likewise.\n+\t(start_sequence_for_rtl_expr): Remove.\n+\t* expmed.c (make_tree): Build a VAR_DECL instead of an RTL_EXPR.\n+\t* rtl.h (preserve_rtl_expr_result): Remove.\n+\n 2004-07-02  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* ifcvt.c, modulo-sched.c, tree-alias-common.c, tree-sra.c,"}, {"sha": "a398e01b1403e836b1cda3e4bfe92fd438063f58", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=4dfa034295629327f8b823cb1c6dfa1585ac86ee", "patch": "@@ -1,3 +1,8 @@\n+2004-07-01  Richard Henderson  <rth@redhat.com>\n+\n+\t* trans.c (gnat_stabilize_reference): Don't handle RTL_EXPR.\n+\t* utils.c (max_size): Likewise.\n+\n 2004-06-28  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* decl.c: Remove calls to add_decl_expr, pushdecl, rest_of_compilation,"}, {"sha": "6135dafc02d6bb9abcdea96c96d6eb618d017b8d", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=4dfa034295629327f8b823cb1c6dfa1585ac86ee", "patch": "@@ -5501,12 +5501,6 @@ gnat_stabilize_reference (tree ref, int force)\n \t\t\t\t\t\tforce));\n       break;\n \n-    case RTL_EXPR:\n-      result = build1 (INDIRECT_REF, type,\n-\t\t       save_expr (build1 (ADDR_EXPR,\n-\t\t\t\t\t  build_reference_type (type), ref)));\n-      break;\n-\n       /* If arg isn't a kind of lvalue we recognize, make no change.\n \t Caller should recognize the error for an invalid lvalue.  */\n     default:"}, {"sha": "772fdd4e8788e66867d0ee56fcc9821349eb8d4c", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=4dfa034295629327f8b823cb1c6dfa1585ac86ee", "patch": "@@ -2025,9 +2025,7 @@ max_size (tree exp, int max_p)\n \t\t\t\t      code == NEGATE_EXPR ? ! max_p : max_p)));\n \n \tcase 2:\n-\t  if (code == RTL_EXPR)\n-\t    gigi_abort (407);\n-\t  else if (code == COMPOUND_EXPR)\n+\t  if (code == COMPOUND_EXPR)\n \t    return max_size (TREE_OPERAND (exp, 1), max_p);\n \n \t  {"}, {"sha": "57a718f4dbf87eb01caa28ae2609c1d0400d03f4", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=4dfa034295629327f8b823cb1c6dfa1585ac86ee", "patch": "@@ -2610,7 +2610,6 @@ lvalue_p (tree ref)\n \t      && TREE_CODE (TREE_TYPE (ref)) != METHOD_TYPE);\n \n     case BIND_EXPR:\n-    case RTL_EXPR:\n       return TREE_CODE (TREE_TYPE (ref)) == ARRAY_TYPE;\n \n     default:\n@@ -6809,10 +6808,7 @@ c_begin_compound_stmt (bool do_scope)\n {\n   tree stmt = push_stmt_list ();\n   if (do_scope)\n-    {\n-      push_scope ();\n-      clear_last_expr ();\n-    }\n+    push_scope ();\n   return stmt;\n }\n "}, {"sha": "b331e3de6c4b8aa223fd50ca83a7c14a8cb8f24c", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=4dfa034295629327f8b823cb1c6dfa1585ac86ee", "patch": "@@ -59,7 +59,7 @@ expand_block (basic_block bb, FILE * dump_file)\n     {\n       last = get_last_insn ();\n \n-      expand_expr_stmt_value (stmt, 0, 0);\n+      expand_expr_stmt (stmt);\n \n       /* Java emits line number notes in the top of labels. \n          ??? Make this go away once line number notes are obsoleted.  */\n@@ -179,7 +179,7 @@ expand_block (basic_block bb, FILE * dump_file)\n \tcase CALL_EXPR:\n \tcase MODIFY_EXPR:\n \tcase RETURN_EXPR:\n-          expand_expr_stmt_value (stmt, 0, 0);\n+          expand_expr_stmt (stmt);\n \t  for (last = NEXT_INSN (last); last; last = NEXT_INSN (last))\n \t    {\n \t      if (GET_CODE (last) == CALL_INSN && SIBLING_CALL_P (last))\n@@ -242,7 +242,7 @@ expand_block (basic_block bb, FILE * dump_file)\n \t  break;\n \n \tdefault:\n-          expand_expr_stmt_value (stmt, 0, 0);\n+          expand_expr_stmt (stmt);\n \t  break;\n \t}\n     }"}, {"sha": "7ebda95670ed593ea8a3be71f339483476fc64bc", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4dfa034295629327f8b823cb1c6dfa1585ac86ee", "patch": "@@ -1,3 +1,9 @@\n+2004-07-01  Richard Henderson  <rth@redhat.com>\n+\n+\t* class.c (fixed_type_or_null): Don't handle RTL_EXPR.\n+\t* method.c (synthesize_method): Don't clear_last_expr.\n+\t* name-lookup.c (maybe_push_cleanup_level): Likewise.\n+\n 2004-07-01  Nick Clifton  <nickc@redhat.com>\n \n \t* decl2.c (import_export_class): Invoke the"}, {"sha": "fdf15e153322766b13164dee1205cb0488dd14e3", "filename": "gcc/cp/class.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=4dfa034295629327f8b823cb1c6dfa1585ac86ee", "patch": "@@ -5309,9 +5309,6 @@ fixed_type_or_null (tree instance, int* nonnull, int* cdtorp)\n \t}\n       return fixed_type_or_null (TREE_OPERAND (instance, 0), nonnull, cdtorp);\n \n-    case RTL_EXPR:\n-      return NULL_TREE;\n-\n     case PLUS_EXPR:\n     case MINUS_EXPR:\n       if (TREE_CODE (TREE_OPERAND (instance, 0)) == ADDR_EXPR)"}, {"sha": "8745dcec78afec05a6f2aefc04a5561d638ed0a3", "filename": "gcc/cp/method.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=4dfa034295629327f8b823cb1c6dfa1585ac86ee", "patch": "@@ -740,7 +740,6 @@ synthesize_method (tree fndecl)\n \n   interface_unknown = 1;\n   start_preparsed_function (fndecl, NULL_TREE, SF_DEFAULT | SF_PRE_PARSED);\n-  clear_last_expr ();\n   stmt = begin_function_body ();\n \n   if (DECL_OVERLOADED_OPERATOR_P (fndecl) == NOP_EXPR)"}, {"sha": "e449631fdec2eff2b6583e05e30815bc26516cac", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=4dfa034295629327f8b823cb1c6dfa1585ac86ee", "patch": "@@ -1440,7 +1440,6 @@ maybe_push_cleanup_level (tree type)\n     {\n       begin_scope (sk_cleanup, NULL);\n       current_binding_level->statement_list = push_stmt_list ();\n-      clear_last_expr ();\n     }\n }\n "}, {"sha": "53edf2c25d8a818b3d71083b43f4282ae12179d0", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 6, "deletions": 24, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=4dfa034295629327f8b823cb1c6dfa1585ac86ee", "patch": "@@ -4822,13 +4822,12 @@ emit (rtx x)\n /* Space for free sequence stack entries.  */\n static GTY ((deletable)) struct sequence_stack *free_sequence_stack;\n \n-/* Begin emitting insns to a sequence which can be packaged in an\n-   RTL_EXPR.  If this sequence will contain something that might cause\n-   the compiler to pop arguments to function calls (because those\n-   pops have previously been deferred; see INHIBIT_DEFER_POP for more\n-   details), use do_pending_stack_adjust before calling this function.\n-   That will ensure that the deferred pops are not accidentally\n-   emitted in the middle of this sequence.  */\n+/* Begin emitting insns to a sequence.  If this sequence will contain\n+   something that might cause the compiler to pop arguments to function\n+   calls (because those pops have previously been deferred; see\n+   INHIBIT_DEFER_POP for more details), use do_pending_stack_adjust\n+   before calling this function.  That will ensure that the deferred\n+   pops are not accidentally emitted in the middle of this sequence.  */\n \n void\n start_sequence (void)\n@@ -4846,26 +4845,13 @@ start_sequence (void)\n   tem->next = seq_stack;\n   tem->first = first_insn;\n   tem->last = last_insn;\n-  tem->sequence_rtl_expr = seq_rtl_expr;\n \n   seq_stack = tem;\n \n   first_insn = 0;\n   last_insn = 0;\n }\n \n-/* Similarly, but indicate that this sequence will be placed in T, an\n-   RTL_EXPR.  See the documentation for start_sequence for more\n-   information about how to use this function.  */\n-\n-void\n-start_sequence_for_rtl_expr (tree t)\n-{\n-  start_sequence ();\n-\n-  seq_rtl_expr = t;\n-}\n-\n /* Set up the insn chain starting with FIRST as the current sequence,\n    saving the previously current one.  See the documentation for\n    start_sequence for more information about how to use this function.  */\n@@ -4911,7 +4897,6 @@ push_topmost_sequence (void)\n \n   first_insn = top->first;\n   last_insn = top->last;\n-  seq_rtl_expr = top->sequence_rtl_expr;\n }\n \n /* After emitting to the outer-level insn chain, update the outer-level\n@@ -4927,7 +4912,6 @@ pop_topmost_sequence (void)\n \n   top->first = first_insn;\n   top->last = last_insn;\n-  /* ??? Why don't we save seq_rtl_expr here?  */\n \n   end_sequence ();\n }\n@@ -4952,7 +4936,6 @@ end_sequence (void)\n \n   first_insn = tem->first;\n   last_insn = tem->last;\n-  seq_rtl_expr = tem->sequence_rtl_expr;\n   seq_stack = tem->next;\n \n   memset (tem, 0, sizeof (*tem));\n@@ -5168,7 +5151,6 @@ init_emit (void)\n   f->emit = ggc_alloc (sizeof (struct emit_status));\n   first_insn = NULL;\n   last_insn = NULL;\n-  seq_rtl_expr = NULL;\n   cur_insn_uid = 1;\n   reg_rtx_no = LAST_VIRTUAL_REGISTER + 1;\n   last_location = UNKNOWN_LOCATION;"}, {"sha": "1dbad8679eb47d173618d68486dcae1d3e0e34e6", "filename": "gcc/expmed.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=4dfa034295629327f8b823cb1c6dfa1585ac86ee", "patch": "@@ -4314,7 +4314,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n }\n \f\n /* Return a tree node with data type TYPE, describing the value of X.\n-   Usually this is an RTL_EXPR, if there is no obvious better choice.\n+   Usually this is an VAR_DECL, if there is no obvious better choice.\n    X may be an expression, however we only support those expressions\n    generated by loop.c.  */\n \n@@ -4424,19 +4424,16 @@ make_tree (tree type, rtx x)\n \t\t\t\t\t  GET_CODE (x) == ZERO_EXTEND);\n       return fold (convert (type, make_tree (t, XEXP (x, 0))));\n \n-   default:\n-      t = make_node (RTL_EXPR);\n-      TREE_TYPE (t) = type;\n+    default:\n+      t = build_decl (VAR_DECL, NULL_TREE, type);\n \n       /* If TYPE is a POINTER_TYPE, X might be Pmode with TYPE_MODE being\n \t ptr_mode.  So convert.  */\n       if (POINTER_TYPE_P (type))\n \tx = convert_memory_address (TYPE_MODE (type), x);\n \n-      RTL_EXPR_RTL (t) = x;\n-      /* There are no insns to be output\n-\t when this rtl_expr is used.  */\n-      RTL_EXPR_SEQUENCE (t) = 0;\n+      SET_DECL_RTL (t, x);\n+\n       return t;\n     }\n }"}, {"sha": "df354228fec24993153c190c6979bd5ac14386a4", "filename": "gcc/expr.c", "status": "modified", "additions": 12, "deletions": 62, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=4dfa034295629327f8b823cb1c6dfa1585ac86ee", "patch": "@@ -1533,9 +1533,7 @@ emit_block_move_via_libcall (rtx dst, rtx src, rtx size)\n      could get the wrong value for an argument.\n \n      To avoid this problem we go ahead and emit code to copy the addresses of\n-     DST and SRC and SIZE into new pseudos.  We can then place those new\n-     pseudos into an RTL_EXPR and use them later, even after a call to\n-     emit_queue.\n+     DST and SRC and SIZE into new pseudos.\n \n      Note this is not strictly needed for library calls since they do not call\n      emit_queue before loading their arguments.  However, we may need to have\n@@ -2665,9 +2663,7 @@ clear_storage_via_libcall (rtx object, rtx size)\n      not careful we could get the wrong value for an argument.\n \n      To avoid this problem we go ahead and emit code to copy OBJECT\n-     and SIZE into new pseudos.  We can then place those new pseudos\n-     into an RTL_EXPR and use them later, even after a call to\n-     emit_queue.\n+     and SIZE into new pseudos.\n \n      Note this is not strictly needed for library calls since they\n      do not call emit_queue before loading their arguments.  However,\n@@ -6138,16 +6134,6 @@ safe_from_p (rtx x, tree exp, int top_p)\n \t    return 0;\n \t  break;\n \n-\tcase RTL_EXPR:\n-\t  /* If a sequence exists, we would have to scan every instruction\n-\t     in the sequence to see if it was safe.  This is probably not\n-\t     worthwhile.  */\n-\t  if (RTL_EXPR_SEQUENCE (exp))\n-\t    return 0;\n-\n-\t  exp_rtl = RTL_EXPR_RTL (exp);\n-\t  break;\n-\n \tcase WITH_CLEANUP_EXPR:\n \t  exp_rtl = WITH_CLEANUP_EXPR_RTL (exp);\n \t  break;\n@@ -6962,7 +6948,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n     case LABELED_BLOCK_EXPR:\n       if (LABELED_BLOCK_BODY (exp))\n-\texpand_expr_stmt_value (LABELED_BLOCK_BODY (exp), 0, 1);\n+\texpand_expr_stmt (LABELED_BLOCK_BODY (exp));\n       /* Should perhaps use expand_label, but this is simpler and safer.  */\n       do_pending_stack_adjust ();\n       emit_label (label_rtx (LABELED_BLOCK_LABEL (exp)));\n@@ -6979,32 +6965,10 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \ttree block = BIND_EXPR_BLOCK (exp);\n \tint mark_ends;\n \n-\tif (TREE_CODE (BIND_EXPR_BODY (exp)) != RTL_EXPR)\n-\t  {\n-\t    /* If we're in functions-as-trees mode, this BIND_EXPR represents\n-\t       the block, so we need to emit NOTE_INSN_BLOCK_* notes.  */\n-\t    mark_ends = (block != NULL_TREE);\n-\t    expand_start_bindings_and_block (mark_ends ? 0 : 2, block);\n-\t  }\n-\telse\n-\t  {\n-\t    /* If we're not in functions-as-trees mode, we've already emitted\n-\t       those notes into our RTL_EXPR, so we just want to splice our BLOCK\n-\t       into the enclosing one.  */\n-\t    mark_ends = 0;\n-\n-\t    /* Need to open a binding contour here because\n-\t       if there are any cleanups they must be contained here.  */\n-\t    expand_start_bindings_and_block (2, NULL_TREE);\n-\n-\t    /* Mark the corresponding BLOCK for output in its proper place.  */\n-\t    if (block)\n-\t      {\n-\t\tif (TREE_USED (block))\n-\t\t  abort ();\n-\t\tlang_hooks.decls.insert_block (block);\n-\t      }\n-\t  }\n+\t/* If we're in functions-as-trees mode, this BIND_EXPR represents\n+\t   the block, so we need to emit NOTE_INSN_BLOCK_* notes.  */\n+\tmark_ends = (block != NULL_TREE);\n+\texpand_start_bindings_and_block (mark_ends ? 0 : 2, block);\n \n \t/* If VARS have not yet been expanded, expand them now.  */\n \texpand_vars (BIND_EXPR_VARS (exp));\n@@ -7021,20 +6985,6 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \treturn temp;\n       }\n \n-    case RTL_EXPR:\n-      if (RTL_EXPR_SEQUENCE (exp))\n-\t{\n-\t  if (RTL_EXPR_SEQUENCE (exp) == const0_rtx)\n-\t    abort ();\n-\t  emit_insn (RTL_EXPR_SEQUENCE (exp));\n-\t  RTL_EXPR_SEQUENCE (exp) = const0_rtx;\n-\t}\n-      preserve_rtl_expr_result (RTL_EXPR_RTL (exp));\n-      free_temps_for_rtl_expr (exp);\n-      if (alt_rtl)\n-\t*alt_rtl = RTL_EXPR_ALT_RTL (exp);\n-      return RTL_EXPR_RTL (exp);\n-\n     case CONSTRUCTOR:\n       /* If we don't need the result, just ensure we evaluate any\n \t subexpressions.  */\n@@ -7913,7 +7863,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n                    && (GET_MODE_CLASS (mode) == MODE_INT)\n                    ? addv_optab : add_optab;\n \n-      /* If we are adding a constant, an RTL_EXPR that is sp, fp, or ap, and\n+      /* If we are adding a constant, a VAR_DECL that is sp, fp, or ap, and\n \t something else, make sure we add the register to the constant and\n \t then to the other thing.  This case can occur during strength\n \t reduction and doing it this way will produce better code if the\n@@ -7926,10 +7876,10 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n       if (TREE_CODE (TREE_OPERAND (exp, 0)) == PLUS_EXPR\n \t  && TREE_CODE (TREE_OPERAND (TREE_OPERAND (exp, 0), 1)) == INTEGER_CST\n-\t  && TREE_CODE (TREE_OPERAND (exp, 1)) == RTL_EXPR\n-\t  && (RTL_EXPR_RTL (TREE_OPERAND (exp, 1)) == frame_pointer_rtx\n-\t      || RTL_EXPR_RTL (TREE_OPERAND (exp, 1)) == stack_pointer_rtx\n-\t      || RTL_EXPR_RTL (TREE_OPERAND (exp, 1)) == arg_pointer_rtx))\n+\t  && TREE_CODE (TREE_OPERAND (exp, 1)) == VAR_DECL\n+\t  && (DECL_RTL (TREE_OPERAND (exp, 1)) == frame_pointer_rtx\n+\t      || DECL_RTL (TREE_OPERAND (exp, 1)) == stack_pointer_rtx\n+\t      || DECL_RTL (TREE_OPERAND (exp, 1)) == arg_pointer_rtx))\n \t{\n \t  tree t = TREE_OPERAND (exp, 1);\n "}, {"sha": "f8408c4d693d7b7ea79fa63b7aa3719d79f21b3c", "filename": "gcc/fold-const.c", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=4dfa034295629327f8b823cb1c6dfa1585ac86ee", "patch": "@@ -2041,7 +2041,6 @@ non_lvalue (tree x)\n   case BIND_EXPR:\n   case MIN_EXPR:\n   case MAX_EXPR:\n-  case RTL_EXPR:\n     break;\n \n   default:\n@@ -2530,9 +2529,6 @@ operand_equal_p (tree arg0, tree arg1, unsigned int flags)\n \t\t     && operand_equal_p (TREE_OPERAND (arg0, 1),\n \t\t\t\t\t TREE_OPERAND (arg1, 0), flags));\n \n-\tcase RTL_EXPR:\n-\t  return rtx_equal_p (RTL_EXPR_RTL (arg0), RTL_EXPR_RTL (arg1));\n-\n \tcase CALL_EXPR:\n \t  /* If the CALL_EXPRs call different functions, then they\n \t     clearly can not be equal.  */\n@@ -5975,9 +5971,8 @@ fold (tree expr)\n      if all operands are constant.  */\n   int wins = 1;\n \n-  /* Don't try to process an RTL_EXPR since its operands aren't trees.\n-     Likewise for a SAVE_EXPR that's already been evaluated.  */\n-  if (code == RTL_EXPR || (code == SAVE_EXPR && SAVE_EXPR_RTL (t) != 0))\n+  /* Don't try to process an SAVE_EXPR that's already been evaluated.  */\n+  if (code == SAVE_EXPR && SAVE_EXPR_RTL (t) != 0)\n     return t;\n \n   /* Return right away if a constant.  */\n@@ -9058,7 +9053,6 @@ fold_checksum_tree (tree expr, struct md5_ctx *ctx, htab_t ht)\n \t{\n \tcase SAVE_EXPR: len = 2; break;\n \tcase GOTO_SUBROUTINE_EXPR: len = 0; break;\n-\tcase RTL_EXPR: len = 0; break;\n \tcase WITH_CLEANUP_EXPR: len = 2; break;\n \tdefault: break;\n \t}\n@@ -9376,8 +9370,6 @@ tree_expr_nonnegative_p (tree t)\n       return tree_expr_nonnegative_p (TREE_OPERAND (t, 0));\n     case FLOAT_EXPR:\n       return tree_expr_nonnegative_p (TREE_OPERAND (t, 0));\n-    case RTL_EXPR:\n-      return rtl_expr_nonnegative_p (RTL_EXPR_RTL (t));\n \n     case TARGET_EXPR:\n       {"}, {"sha": "1d17c4fa591e3a9825653977bf79ef48feec237b", "filename": "gcc/function.c", "status": "modified", "additions": 4, "deletions": 84, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=4dfa034295629327f8b823cb1c6dfa1585ac86ee", "patch": "@@ -186,8 +186,6 @@ struct temp_slot GTY(())\n      It can be reused if objects of the type of the new slot will always\n      conflict with objects of the type of the old slot.  */\n   tree type;\n-  /* The value of `sequence_rtl_expr' when this temporary is allocated.  */\n-  tree rtl_expr;\n   /* Nonzero if this temporary is currently in use.  */\n   char in_use;\n   /* Nonzero if this temporary has its address taken.  */\n@@ -440,7 +438,6 @@ free_after_compilation (struct function *f)\n   f->x_naked_return_label = NULL;\n   f->x_save_expr_regs = NULL;\n   f->x_stack_slot_list = NULL;\n-  f->x_rtl_expr_chain = NULL;\n   f->x_tail_recursion_reentry = NULL;\n   f->x_arg_pointer_save_area = NULL;\n   f->x_parm_birth_insn = NULL;\n@@ -768,7 +765,6 @@ assign_stack_temp_for_type (enum machine_mode mode, HOST_WIDE_INT size, int keep\n \t\t\t\t\t\t    rounded_size));\n \t      p->align = best_p->align;\n \t      p->address = 0;\n-\t      p->rtl_expr = 0;\n \t      p->type = best_p->type;\n \t      insert_slot_to_list (p, &avail_temp_slots);\n \n@@ -834,7 +830,6 @@ assign_stack_temp_for_type (enum machine_mode mode, HOST_WIDE_INT size, int keep\n   p = selected;\n   p->in_use = 1;\n   p->addr_taken = 0;\n-  p->rtl_expr = seq_rtl_expr;\n   p->type = type;\n \n   if (keep == 2)\n@@ -1230,39 +1225,8 @@ preserve_temp_slots (rtx x)\n     }\n }\n \n-/* X is the result of an RTL_EXPR.  If it is a temporary slot associated\n-   with that RTL_EXPR, promote it into a temporary slot at the present\n-   level so it will not be freed when we free slots made in the\n-   RTL_EXPR.  */\n-\n-void\n-preserve_rtl_expr_result (rtx x)\n-{\n-  struct temp_slot *p;\n-\n-  /* If X is not in memory or is at a constant address, it cannot be in\n-     a temporary slot.  */\n-  if (x == 0 || !MEM_P (x) || CONSTANT_P (XEXP (x, 0)))\n-    return;\n-\n-  /* If we can find a match, move it to our level unless it is already at\n-     an upper level.  */\n-  p = find_temp_slot_from_address (XEXP (x, 0));\n-  if (p != 0)\n-    {\n-      move_slot_to_level (p, MIN (p->level, temp_slot_level));\n-      p->rtl_expr = 0;\n-    }\n-\n-  return;\n-}\n-\n-/* Free all temporaries used so far.  This is normally called at the end\n-   of generating code for a statement.  Don't free any temporaries\n-   currently in use for an RTL_EXPR that hasn't yet been emitted.\n-   We could eventually do better than this since it can be reused while\n-   generating the same RTL_EXPR, but this is complex and probably not\n-   worthwhile.  */\n+/* Free all temporaries used so far.  This is normally called at the\n+   end of generating code for a statement.  */\n \n void\n free_temp_slots (void)\n@@ -1273,40 +1237,13 @@ free_temp_slots (void)\n     {\n       next = p->next;\n \n-      if (!p->keep && p->rtl_expr == 0)\n+      if (!p->keep)\n \tmake_slot_available (p);\n     }\n \n   combine_temp_slots ();\n }\n \n-/* Free all temporary slots used in T, an RTL_EXPR node.  */\n-\n-void\n-free_temps_for_rtl_expr (tree t)\n-{\n-  struct temp_slot *p, *next;\n-\n-  for (p = *temp_slots_at_level (temp_slot_level); p; p = next)\n-    {\n-      next = p->next;\n-\n-      if (p->rtl_expr == t)\n-\t{\n-\t  /* If this slot is below the current TEMP_SLOT_LEVEL, then it\n-\t     needs to be preserved.  This can happen if a temporary in\n-\t     the RTL_EXPR was addressed; preserve_temp_slots will move\n-\t     the temporary into a higher level.  */\n-\t  if (temp_slot_level <= p->level)\n-\t    make_slot_available (p);\n-\t  else\n-\t    p->rtl_expr = NULL_TREE;\n-\t}\n-    }\n-\n-  combine_temp_slots ();\n-}\n-\n /* Push deeper into the nesting level for stack temporaries.  */\n \n void\n@@ -1326,9 +1263,7 @@ pop_temp_slots (void)\n   for (p = *temp_slots_at_level (temp_slot_level); p; p = next)\n     {\n       next = p->next;\n-\n-      if (p->rtl_expr == 0)\n-\tmake_slot_available (p);\n+      make_slot_available (p);\n     }\n \n   combine_temp_slots ();\n@@ -1587,10 +1522,8 @@ static void\n fixup_var_refs (rtx var, enum machine_mode promoted_mode, int unsignedp,\n \t\trtx may_share, htab_t ht)\n {\n-  tree pending;\n   rtx first_insn = get_insns ();\n   struct sequence_stack *stack = seq_stack;\n-  tree rtl_exps = rtl_expr_chain;\n   int save_volatile_ok = volatile_ok;\n \n   /* If there's a hash table, it must record all uses of VAR.  */\n@@ -1621,19 +1554,6 @@ fixup_var_refs (rtx var, enum machine_mode promoted_mode, int unsignedp,\n       end_sequence ();\n     }\n \n-  /* Scan all waiting RTL_EXPRs too.  */\n-  for (pending = rtl_exps; pending; pending = TREE_CHAIN (pending))\n-    {\n-      rtx seq = RTL_EXPR_SEQUENCE (TREE_VALUE (pending));\n-      if (seq != const0_rtx && seq != 0)\n-\t{\n-\t  push_to_sequence (seq);\n-\t  fixup_var_refs_insns (seq, var, promoted_mode, unsignedp, 0,\n-\t\t\t\tmay_share);\n-\t  end_sequence ();\n-\t}\n-    }\n-\n   volatile_ok = save_volatile_ok;\n }\n \f"}, {"sha": "7043d0bff3f22cf09ca15b9f9c612349a078f45b", "filename": "gcc/function.h", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=4dfa034295629327f8b823cb1c6dfa1585ac86ee", "patch": "@@ -40,7 +40,6 @@ struct sequence_stack GTY(())\n   /* First and last insns in the chain of the saved sequence.  */\n   rtx first;\n   rtx last;\n-  tree sequence_rtl_expr;\n   struct sequence_stack *next;\n };\n \n@@ -66,16 +65,11 @@ struct emit_status GTY(())\n   /* The ends of the doubly-linked chain of rtl for the current function.\n      Both are reset to null at the start of rtl generation for the function.\n \n-     start_sequence saves both of these on `sequence_stack' along with\n-     `sequence_rtl_expr' and then starts a new, nested sequence of insns.  */\n+     start_sequence saves both of these on `sequence_stack' and then starts\n+     a new, nested sequence of insns.  */\n   rtx x_first_insn;\n   rtx x_last_insn;\n \n-  /* RTL_EXPR within which the current sequence will be placed.  Use to\n-     prevent reuse of any temporaries within the sequence until after the\n-     RTL_EXPR is emitted.  */\n-  tree sequence_rtl_expr;\n-\n   /* Stack of pending (incomplete) sequences saved by `start_sequence'.\n      Each element describes one pending sequence.\n      The main insn-chain is saved in the last element of the chain,\n@@ -112,7 +106,6 @@ struct emit_status GTY(())\n \n /* For backward compatibility... eventually these should all go away.  */\n #define reg_rtx_no (cfun->emit->x_reg_rtx_no)\n-#define seq_rtl_expr (cfun->emit->sequence_rtl_expr)\n #define regno_reg_rtx (cfun->emit->x_regno_reg_rtx)\n #define seq_stack (cfun->emit->sequence_stack)\n \n@@ -258,9 +251,6 @@ struct function GTY(())\n      Made for the sake of unshare_all_rtl.  */\n   rtx x_stack_slot_list;\n \n-  /* Chain of all RTL_EXPRs that have insns in them.  */\n-  tree x_rtl_expr_chain;\n-\n   /* Place after which to insert the tail_recursion_label if we need one.  */\n   rtx x_tail_recursion_reentry;\n \n@@ -522,7 +512,6 @@ extern int trampolines_created;\n #define frame_offset (cfun->x_frame_offset)\n #define tail_recursion_reentry (cfun->x_tail_recursion_reentry)\n #define arg_pointer_save_area (cfun->x_arg_pointer_save_area)\n-#define rtl_expr_chain (cfun->x_rtl_expr_chain)\n #define used_temp_slots (cfun->x_used_temp_slots)\n #define avail_temp_slots (cfun->x_avail_temp_slots)\n #define temp_slot_level (cfun->x_temp_slot_level)"}, {"sha": "99b79901a5fb842c887bdceb660bcfab86b6af09", "filename": "gcc/gengtype.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=4dfa034295629327f8b823cb1c6dfa1585ac86ee", "patch": "@@ -652,7 +652,6 @@ adjust_field_tree_exp (type_p t, options_p opt ATTRIBUTE_UNUSED)\n   } data[] = {\n     { \"SAVE_EXPR\", 2, 1 },\n     { \"GOTO_SUBROUTINE_EXPR\", 0, 2 },\n-    { \"RTL_EXPR\", 0, 2 },\n     { \"WITH_CLEANUP_EXPR\", 2, 1 },\n   };\n "}, {"sha": "8e673049e60fa0665101a5b0658aef8dae789d65", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=4dfa034295629327f8b823cb1c6dfa1585ac86ee", "patch": "@@ -2278,7 +2278,6 @@ extern void reposition_prologue_and_epilogue_notes (rtx);\n extern void thread_prologue_and_epilogue_insns (rtx);\n extern int prologue_epilogue_contains (rtx);\n extern int sibcall_epilogue_contains (rtx);\n-extern void preserve_rtl_expr_result (rtx);\n extern void mark_temp_addr_taken (rtx);\n extern void update_temp_slot_address (rtx, rtx);\n extern void purge_addressof (rtx);"}, {"sha": "543c92a09dc84adae0d8d7f8edc45f664c292bc9", "filename": "gcc/stmt.c", "status": "modified", "additions": 3, "deletions": 175, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=4dfa034295629327f8b823cb1c6dfa1585ac86ee", "patch": "@@ -335,16 +335,6 @@ struct stmt_status GTY(())\n   /* Number of binding contours started so far in this function.  */\n   int x_block_start_count;\n \n-  /* Each time we expand an expression-statement,\n-     record the expr's type and its RTL value here.  */\n-  tree x_last_expr_type;\n-  rtx x_last_expr_value;\n-  rtx x_last_expr_alt_rtl;\n-\n-  /* Nonzero if within a ({...}) grouping, in which case we must\n-     always compute a value for each expr-stmt in case it is the last one.  */\n-  int x_expr_stmts_for_value;\n-\n   /* Location of last line-number note, whether we actually\n      emitted it or not.  */\n   location_t x_emit_locus;\n@@ -359,10 +349,6 @@ struct stmt_status GTY(())\n #define nesting_stack (cfun->stmt->x_nesting_stack)\n #define nesting_depth (cfun->stmt->x_nesting_depth)\n #define current_block_start_count (cfun->stmt->x_block_start_count)\n-#define last_expr_type (cfun->stmt->x_last_expr_type)\n-#define last_expr_value (cfun->stmt->x_last_expr_value)\n-#define last_expr_alt_rtl (cfun->stmt->x_last_expr_alt_rtl)\n-#define expr_stmts_for_value (cfun->stmt->x_expr_stmts_for_value)\n #define emit_locus (cfun->stmt->x_emit_locus)\n #define goto_fixup_chain (cfun->stmt->x_goto_fixup_chain)\n \n@@ -976,8 +962,6 @@ expand_asm (tree string, int vol)\n   MEM_VOLATILE_P (body) = vol;\n \n   emit_insn (body);\n-\n-  clear_last_expr ();\n }\n \n /* Parse the output constraint pointed to by *CONSTRAINT_P.  It is the\n@@ -1414,8 +1398,6 @@ expand_asm_operands (tree string, tree outputs, tree inputs,\n \t}\n     }\n \n-  clear_last_expr ();\n-\n   /* First pass over inputs and outputs checks validity and sets\n      mark_addressable if needed.  */\n \n@@ -2054,56 +2036,15 @@ resolve_operand_name_1 (char *p, tree outputs, tree inputs)\n   return p;\n }\n \f\n-/* Generate RTL to evaluate the expression EXP\n-   and remember it in case this is the VALUE in a ({... VALUE; }) constr.\n-   Provided just for backward-compatibility.  expand_expr_stmt_value()\n-   should be used for new code.  */\n+/* Generate RTL to evaluate the expression EXP.  */\n \n void\n expand_expr_stmt (tree exp)\n-{\n-  expand_expr_stmt_value (exp, -1, 1);\n-}\n-\n-/* Generate RTL to evaluate the expression EXP.  WANT_VALUE tells\n-   whether to (1) save the value of the expression, (0) discard it or\n-   (-1) use expr_stmts_for_value to tell.  The use of -1 is\n-   deprecated, and retained only for backward compatibility.  */\n-\n-void\n-expand_expr_stmt_value (tree exp, int want_value, int maybe_last)\n {\n   rtx value;\n   tree type;\n-  rtx alt_rtl = NULL;\n-\n-  if (want_value == -1)\n-    want_value = expr_stmts_for_value != 0;\n-\n-  /* If -Wextra, warn about statements with no side effects,\n-     except for an explicit cast to void (e.g. for assert()), and\n-     except for last statement in ({...}) where they may be useful.  */\n-  if (! want_value\n-      && (expr_stmts_for_value == 0 || ! maybe_last)\n-      && exp != error_mark_node\n-      && warn_unused_value)\n-    {\n-      if (TREE_SIDE_EFFECTS (exp))\n-\twarn_if_unused_value (exp, emit_locus);\n-      else if (!VOID_TYPE_P (TREE_TYPE (exp)) && !TREE_NO_WARNING (exp))\n-\twarning (\"%Hstatement with no effect\", &emit_locus);\n-    }\n-\n-  /* If EXP is of function type and we are expanding statements for\n-     value, convert it to pointer-to-function.  */\n-  if (want_value && TREE_CODE (TREE_TYPE (exp)) == FUNCTION_TYPE)\n-    exp = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (exp)), exp);\n \n-  /* The call to `expand_expr' could cause last_expr_type and\n-     last_expr_value to get reset.  Therefore, we set last_expr_value\n-     and last_expr_type *after* calling expand_expr.  */\n-  value = expand_expr_real (exp, want_value ? NULL_RTX : const0_rtx,\n-\t\t\t    VOIDmode, 0, &alt_rtl);\n+  value = expand_expr (exp, const0_rtx, VOIDmode, 0);\n   type = TREE_TYPE (exp);\n \n   /* If all we do is reference a volatile value in memory,\n@@ -2127,22 +2068,9 @@ expand_expr_stmt_value (tree exp, int want_value, int maybe_last)\n \t}\n     }\n \n-  /* If this expression is part of a ({...}) and is in memory, we may have\n-     to preserve temporaries.  */\n-  preserve_temp_slots (value);\n-\n-  /* Free any temporaries used to evaluate this expression.  Any temporary\n-     used as a result of this expression will already have been preserved\n-     above.  */\n+  /* Free any temporaries used to evaluate this expression.  */\n   free_temp_slots ();\n \n-  if (want_value)\n-    {\n-      last_expr_value = value;\n-      last_expr_alt_rtl = alt_rtl;\n-      last_expr_type = type;\n-    }\n-\n   emit_queue ();\n }\n \n@@ -2176,7 +2104,6 @@ warn_if_unused_value (tree exp, location_t locus)\n     case INIT_EXPR:\n     case TARGET_EXPR:\n     case CALL_EXPR:\n-    case RTL_EXPR:\n     case TRY_CATCH_EXPR:\n     case WITH_CLEANUP_EXPR:\n     case EXIT_EXPR:\n@@ -2263,90 +2190,6 @@ warn_if_unused_value (tree exp, location_t locus)\n       return 1;\n     }\n }\n-\n-/* Clear out the memory of the last expression evaluated.  */\n-\n-void\n-clear_last_expr (void)\n-{\n-  last_expr_type = NULL_TREE;\n-  last_expr_value = NULL_RTX;\n-  last_expr_alt_rtl = NULL_RTX;\n-}\n-\n-/* Begin a statement-expression, i.e., a series of statements which\n-   may return a value.  Return the RTL_EXPR for this statement expr.\n-   The caller must save that value and pass it to\n-   expand_end_stmt_expr.  If HAS_SCOPE is nonzero, temporaries created\n-   in the statement-expression are deallocated at the end of the\n-   expression.  */\n-\n-tree\n-expand_start_stmt_expr (int has_scope)\n-{\n-  tree t;\n-\n-  /* Make the RTL_EXPR node temporary, not momentary,\n-     so that rtl_expr_chain doesn't become garbage.  */\n-  t = make_node (RTL_EXPR);\n-  do_pending_stack_adjust ();\n-  if (has_scope)\n-    start_sequence_for_rtl_expr (t);\n-  else\n-    start_sequence ();\n-  NO_DEFER_POP;\n-  expr_stmts_for_value++;\n-  return t;\n-}\n-\n-/* Restore the previous state at the end of a statement that returns a value.\n-   Returns a tree node representing the statement's value and the\n-   insns to compute the value.\n-\n-   The nodes of that expression have been freed by now, so we cannot use them.\n-   But we don't want to do that anyway; the expression has already been\n-   evaluated and now we just want to use the value.  So generate a RTL_EXPR\n-   with the proper type and RTL value.\n-\n-   If the last substatement was not an expression,\n-   return something with type `void'.  */\n-\n-tree\n-expand_end_stmt_expr (tree t)\n-{\n-  OK_DEFER_POP;\n-\n-  if (! last_expr_value || ! last_expr_type)\n-    {\n-      last_expr_value = const0_rtx;\n-      last_expr_alt_rtl = NULL_RTX;\n-      last_expr_type = void_type_node;\n-    }\n-  else if (!REG_P (last_expr_value) && ! CONSTANT_P (last_expr_value))\n-    /* Remove any possible QUEUED.  */\n-    last_expr_value = protect_from_queue (last_expr_value, 0);\n-\n-  emit_queue ();\n-\n-  TREE_TYPE (t) = last_expr_type;\n-  RTL_EXPR_RTL (t) = last_expr_value;\n-  RTL_EXPR_ALT_RTL (t) = last_expr_alt_rtl;\n-  RTL_EXPR_SEQUENCE (t) = get_insns ();\n-\n-  rtl_expr_chain = tree_cons (NULL_TREE, t, rtl_expr_chain);\n-\n-  end_sequence ();\n-\n-  /* Don't consider deleting this expr or containing exprs at tree level.  */\n-  TREE_SIDE_EFFECTS (t) = 1;\n-  /* Propagate volatility of the actual RTL expr.  */\n-  TREE_THIS_VOLATILE (t) = volatile_refs_p (last_expr_value);\n-\n-  clear_last_expr ();\n-  expr_stmts_for_value--;\n-\n-  return t;\n-}\n \f\n /* Generate RTL for the start of an if-then.  COND is the expression\n    whose truth should be tested.\n@@ -2430,7 +2273,6 @@ expand_end_cond (void)\n     emit_label (thiscond->data.cond.endif_label);\n \n   POPSTACK (cond_stack);\n-  clear_last_expr ();\n }\n \f\n /* Return nonzero if we should preserve sub-expressions as separate\n@@ -2481,7 +2323,6 @@ expand_naked_return (void)\n \n   clear_pending_stack_adjust ();\n   do_pending_stack_adjust ();\n-  clear_last_expr ();\n \n   if (end_label == 0)\n     end_label = naked_return_label = gen_label_rtx ();\n@@ -2604,7 +2445,6 @@ expand_null_return_1 (rtx last_insn)\n \n   clear_pending_stack_adjust ();\n   do_pending_stack_adjust ();\n-  clear_last_expr ();\n \n   if (end_label == 0)\n      end_label = return_label = gen_label_rtx ();\n@@ -3112,13 +2952,6 @@ expand_end_bindings (tree vars, int mark_ends ATTRIBUTE_UNUSED,\n       int reachable;\n       rtx insn;\n \n-      /* Don't let cleanups affect ({...}) constructs.  */\n-      int old_expr_stmts_for_value = expr_stmts_for_value;\n-      rtx old_last_expr_value = last_expr_value;\n-      rtx old_last_expr_alt_rtl = last_expr_alt_rtl;\n-      tree old_last_expr_type = last_expr_type;\n-      expr_stmts_for_value = 0;\n-\n       /* Only clean up here if this point can actually be reached.  */\n       insn = get_last_insn ();\n       if (GET_CODE (insn) == NOTE)\n@@ -3130,11 +2963,6 @@ expand_end_bindings (tree vars, int mark_ends ATTRIBUTE_UNUSED,\n       if (reachable)\n \tdo_pending_stack_adjust ();\n \n-      expr_stmts_for_value = old_expr_stmts_for_value;\n-      last_expr_value = old_last_expr_value;\n-      last_expr_alt_rtl = old_last_expr_alt_rtl;\n-      last_expr_type = old_last_expr_type;\n-\n       /* Restore the stack level.  */\n \n       if (reachable && thisblock->data.block.stack_level != 0)"}, {"sha": "97a34a1182ae59a0d05f8eccb2cb8a7ab38f1d07", "filename": "gcc/tree-gimple.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Ftree-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Ftree-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.c?ref=4dfa034295629327f8b823cb1c6dfa1585ac86ee", "patch": "@@ -495,7 +495,6 @@ recalculate_side_effects (tree t)\n \tcase INIT_EXPR:\n \tcase MODIFY_EXPR:\n \tcase VA_ARG_EXPR:\n-\tcase RTL_EXPR:\n \tcase PREDECREMENT_EXPR:\n \tcase PREINCREMENT_EXPR:\n \tcase POSTDECREMENT_EXPR:"}, {"sha": "a3649ddd2a0831b3d2b5821e14b204aa960989a8", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=4dfa034295629327f8b823cb1c6dfa1585ac86ee", "patch": "@@ -1109,10 +1109,6 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       pp_character (buffer, '>');\n       break;\n \n-    case RTL_EXPR:\n-      NIY;\n-      break;\n-\n     case ENTRY_VALUE_EXPR:\n       NIY;\n       break;"}, {"sha": "38e94ef70aff166a196cc584b9aa226a5c3b59aa", "filename": "gcc/tree.c", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=4dfa034295629327f8b823cb1c6dfa1585ac86ee", "patch": "@@ -334,7 +334,6 @@ make_node_stat (enum tree_code code MEM_STAT_DECL)\n \tcase INIT_EXPR:\n \tcase MODIFY_EXPR:\n \tcase VA_ARG_EXPR:\n-\tcase RTL_EXPR:\n \tcase PREDECREMENT_EXPR:\n \tcase PREINCREMENT_EXPR:\n \tcase POSTDECREMENT_EXPR:\n@@ -1455,7 +1454,6 @@ first_rtl_op (enum tree_code code)\n     case SAVE_EXPR:\n       return 2;\n     case GOTO_SUBROUTINE_EXPR:\n-    case RTL_EXPR:\n       return 0;\n     case WITH_CLEANUP_EXPR:\n       return 2;\n@@ -1530,12 +1528,6 @@ unsave_expr_1 (tree expr)\n       TREE_OPERAND (expr, 3) = NULL_TREE;\n       break;\n \n-    case RTL_EXPR:\n-      /* I don't yet know how to emit a sequence multiple times.  */\n-      if (RTL_EXPR_SEQUENCE (expr) != 0)\n-\tabort ();\n-      break;\n-\n     default:\n       break;\n     }\n@@ -1552,10 +1544,7 @@ unsave_expr_1 (tree expr)\n    SAVE_EXPRs basically *only* appear replicated in an expression tree,\n    occasionally across the whole of a function.  It is therefore only\n    safe to unsave a SAVE_EXPR if you know that all occurrences appear\n-   below the UNSAVE_EXPR.\n-\n-   RTL_EXPRs consume their rtl during evaluation.  It is therefore\n-   never possible to unsave them.  */\n+   below the UNSAVE_EXPR.  */\n \n int\n unsafe_for_reeval (tree expr)\n@@ -1575,7 +1564,6 @@ unsafe_for_reeval (tree expr)\n   switch (code)\n     {\n     case SAVE_EXPR:\n-    case RTL_EXPR:\n       return 2;\n \n       /* A label can only be emitted once.  */\n@@ -2194,13 +2182,6 @@ stabilize_reference (tree ref)\n \t volatiles.  */\n       return stabilize_reference_1 (ref);\n \n-    case RTL_EXPR:\n-      result = build1 (INDIRECT_REF, TREE_TYPE (ref),\n-\t\t       save_expr (build1 (ADDR_EXPR,\n-\t\t\t\t\t  build_pointer_type (TREE_TYPE (ref)),\n-\t\t\t\t\t  ref)));\n-      break;\n-\n       /* If arg isn't a kind of lvalue we recognize, make no change.\n \t Caller should recognize the error for an invalid lvalue.  */\n     default:\n@@ -2459,7 +2440,6 @@ build1_stat (enum tree_code code, tree type, tree node MEM_STAT_DECL)\n     case INIT_EXPR:\n     case MODIFY_EXPR:\n     case VA_ARG_EXPR:\n-    case RTL_EXPR:\n     case PREDECREMENT_EXPR:\n     case PREINCREMENT_EXPR:\n     case POSTDECREMENT_EXPR:"}, {"sha": "bf80871793a718cfb73908bd9feac0e6a688743a", "filename": "gcc/tree.def", "status": "modified", "additions": 6, "deletions": 22, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=4dfa034295629327f8b823cb1c6dfa1585ac86ee", "patch": "@@ -499,9 +499,7 @@ DEFTREECODE (CALL_EXPR, \"call_expr\", 'e', 3)\n /* Specify a value to compute along with its corresponding cleanup.\n    Operand 0 argument is an expression whose value needs a cleanup.\n    Operand 1 is the cleanup expression for the object.\n-   Operand 2 is an RTL_EXPR which will eventually represent that value.\n-     The RTL_EXPR is used in this expression, which is how the expression\n-     manages to act on the proper value.\n+   Operand 2 is unused.\n    The cleanup is executed by the first enclosing CLEANUP_POINT_EXPR, if\n    it exists, otherwise it is the responsibility of the caller to manually\n    call expand_start_target_temps/expand_end_target_temps, as needed.\n@@ -731,27 +729,13 @@ DEFTREECODE (VIEW_CONVERT_EXPR, \"view_convert_expr\", '1', 1)\n DEFTREECODE (SAVE_EXPR, \"save_expr\", 'e', 3)\n \n /* For a UNSAVE_EXPR, operand 0 is the value to unsave.  By unsave, we\n-   mean that all _EXPRs such as TARGET_EXPRs, SAVE_EXPRs,\n-   CALL_EXPRs and RTL_EXPRs, that are protected\n-   from being evaluated more than once should be reset so that a new\n-   expand_expr call of this expr will cause those to be re-evaluated.\n-   This is useful when we want to reuse a tree in different places,\n-   but where we must re-expand.  */\n+   mean that all _EXPRs such as TARGET_EXPRs, SAVE_EXPRs, CALL_EXPRs,\n+   that are protected from being evaluated more than once should be\n+   reset so that a new expand_expr call of this expr will cause those\n+   to be re-evaluated.  This is useful when we want to reuse a tree in\n+   different places, but where we must re-expand.  */\n DEFTREECODE (UNSAVE_EXPR, \"unsave_expr\", 'e', 1)\n \n-/* Represents something whose RTL has already been expanded as a\n-   sequence which should be emitted when this expression is expanded.\n-   The first operand is the RTL to emit.  It is the first of a chain\n-   of insns.  The second is the RTL expression for the result.  The\n-   third operand is the \"alternate RTL expression\" for the result, if\n-   any; if the second argument is the DECL_RTL for a VAR_DECL, but\n-   with an invalid memory address replaced by a valid one, then the\n-   third operand will be the original DECL_RTL.  Any temporaries\n-   created during the building of the RTL_EXPR can be reused once the\n-   RTL_EXPR has been expanded, with the exception of the\n-   RTL_EXPR_RTL.  */\n-DEFTREECODE (RTL_EXPR, \"rtl_expr\", 'e', 3)\n-\n /* & in C.  Value is the address at which the operand's value resides.\n    Operand may have any mode.  Result mode is Pmode.  */\n DEFTREECODE (ADDR_EXPR, \"addr_expr\", 'e', 1)"}, {"sha": "b91ac6c19d05723007f482d18a37889610551b9c", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dfa034295629327f8b823cb1c6dfa1585ac86ee/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=4dfa034295629327f8b823cb1c6dfa1585ac86ee", "patch": "@@ -1043,11 +1043,6 @@ struct tree_vec GTY(())\n    recalculated.)  */\n #define SAVE_EXPR_PERSISTENT_P(NODE) TREE_ASM_WRITTEN (SAVE_EXPR_CHECK (NODE))\n \n-/* In a RTL_EXPR node.  */\n-#define RTL_EXPR_SEQUENCE(NODE) TREE_RTL_OPERAND_CHECK (NODE, RTL_EXPR, 0)\n-#define RTL_EXPR_RTL(NODE) TREE_RTL_OPERAND_CHECK (NODE, RTL_EXPR, 1)\n-#define RTL_EXPR_ALT_RTL(NODE) TREE_RTL_OPERAND_CHECK (NODE, RTL_EXPR, 2)\n-\n /* In a WITH_CLEANUP_EXPR node.  */\n #define WITH_CLEANUP_EXPR_RTL(NODE) \\\n   TREE_RTL_OPERAND_CHECK (NODE, WITH_CLEANUP_EXPR, 2)\n@@ -3337,13 +3332,10 @@ extern bool commutative_tree_code (enum tree_code);\n /* In stmt.c */\n \n extern void expand_fixups (rtx);\n-extern tree expand_start_stmt_expr (int);\n-extern tree expand_end_stmt_expr (tree);\n extern void expand_expr_stmt (tree);\n extern void expand_expr_stmt_value (tree, int, int);\n extern int warn_if_unused_value (tree, location_t);\n extern void expand_decl_init (tree);\n-extern void clear_last_expr (void);\n extern void expand_label (tree);\n extern void expand_goto (tree);\n extern void expand_asm (tree, int);\n@@ -3514,7 +3506,6 @@ extern void push_temp_slots (void);\n extern void preserve_temp_slots (rtx);\n extern void preserve_rtl_expr_temps (tree);\n extern int aggregate_value_p (tree, tree);\n-extern void free_temps_for_rtl_expr (tree);\n extern void push_function_context (void);\n extern void pop_function_context (void);\n extern void push_function_context_to (tree);\n@@ -3541,7 +3532,6 @@ extern rtx expand_builtin_return_addr (enum built_in_function, int, rtx);\n extern void check_max_integer_computation_mode (tree);\n \n /* In emit-rtl.c */\n-extern void start_sequence_for_rtl_expr (tree);\n extern rtx emit_line_note (location_t);\n \n /* In calls.c */"}]}