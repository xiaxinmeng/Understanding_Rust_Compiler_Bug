{"sha": "faff4ab8c58604e4d521dabf3ae33a4ab0481d7e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmFmZjRhYjhjNTg2MDRlNGQ1MjFkYWJmM2FlMzNhNGFiMDQ4MWQ3ZQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@cygnus.com", "date": "1998-10-29T19:06:48Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1998-10-29T19:06:48Z"}, "message": "Fix sched REG_DEAD note handling bug found by post-reload-flow pass.\n\n\t* sched.c (update_flow_info): Add code to ! found_orig_dest case to\n\thandle deleted no-op moves of hard registers.\n\t* haifa-sched.c (update_flow_info): Likewise.\n\nFrom-SVN: r23431", "tree": {"sha": "3c29708e3ea9d938be6b03a4cef25d59127fa5d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c29708e3ea9d938be6b03a4cef25d59127fa5d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/faff4ab8c58604e4d521dabf3ae33a4ab0481d7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/faff4ab8c58604e4d521dabf3ae33a4ab0481d7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/faff4ab8c58604e4d521dabf3ae33a4ab0481d7e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/faff4ab8c58604e4d521dabf3ae33a4ab0481d7e/comments", "author": null, "committer": null, "parents": [{"sha": "839366ddec3534593850e1660ead262a8a260158", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/839366ddec3534593850e1660ead262a8a260158", "html_url": "https://github.com/Rust-GCC/gccrs/commit/839366ddec3534593850e1660ead262a8a260158"}], "stats": {"total": 54, "additions": 50, "deletions": 4}, "files": [{"sha": "22c38bc8c115adc0278e0d9ff861890cecc26957", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faff4ab8c58604e4d521dabf3ae33a4ab0481d7e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faff4ab8c58604e4d521dabf3ae33a4ab0481d7e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=faff4ab8c58604e4d521dabf3ae33a4ab0481d7e", "patch": "@@ -1,3 +1,9 @@\n+Thu Oct 29 19:05:17 1998  Jim Wilson  <wilson@cygnus.com>\n+\n+\t* sched.c (update_flow_info): Add code to ! found_orig_dest case to\n+\thandle deleted no-op moves of hard registers.\n+\t* haifa-sched.c (update_flow_info): Likewise.\n+\n Thu Oct 29 18:07:47 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* mips.md (reload_{in,out}{si,di}): Emit a USE of HILO at the end"}, {"sha": "ea043907262356bbdd3643d90fa777585698ff08", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faff4ab8c58604e4d521dabf3ae33a4ab0481d7e/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faff4ab8c58604e4d521dabf3ae33a4ab0481d7e/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=faff4ab8c58604e4d521dabf3ae33a4ab0481d7e", "patch": "@@ -8340,8 +8340,28 @@ update_flow_info (notes, first, last, orig_insn)\n \t}\n       else if (!found_orig_dest)\n \t{\n-\t  /* This should never happen.  */\n-\t  abort ();\n+\t  int i, regno;\n+\n+\t  /* Should never reach here for a pseudo reg.  */\n+\t  if (REGNO (orig_dest) >= FIRST_PSEUDO_REGISTER)\n+\t    abort ();\n+\n+\t  /* This can happen for a hard register, if the splitter\n+\t     does not bother to emit instructions which would be no-ops.\n+\t     We try to verify that this is the case by checking to see if\n+\t     the original instruction uses all of the registers that it\n+\t     set.  This case is OK, because deleting a no-op can not affect\n+\t     REG_DEAD notes on other insns.  If this is not the case, then\n+\t     abort.  */\n+\t  \n+\t  regno = REGNO (orig_dest);\n+\t  for (i = HARD_REGNO_NREGS (regno, GET_MODE (orig_dest)) - 1;\n+\t       i >= 0; i--)\n+\t    if (! refers_to_regno_p (regno + i, regno + i + 1, orig_insn,\n+\t\t\t\t     NULL_PTR))\n+\t      break;\n+\t  if (i >= 0)\n+\t    abort ();\n \t}\n     }\n "}, {"sha": "e27f70e28eaa36ea11944e770e81da969dffe303", "filename": "gcc/sched.c", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faff4ab8c58604e4d521dabf3ae33a4ab0481d7e/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faff4ab8c58604e4d521dabf3ae33a4ab0481d7e/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=faff4ab8c58604e4d521dabf3ae33a4ab0481d7e", "patch": "@@ -4174,8 +4174,28 @@ update_flow_info (notes, first, last, orig_insn)\n \t}\n       else if (! found_orig_dest)\n \t{\n-\t  /* This should never happen.  */\n-\t  abort ();\n+\t  int i, regno;\n+\n+\t  /* Should never reach here for a pseudo reg.  */\n+\t  if (REGNO (orig_dest) >= FIRST_PSEUDO_REGISTER)\n+\t    abort ();\n+\n+\t  /* This can happen for a hard register, if the splitter\n+\t     does not bother to emit instructions which would be no-ops.\n+\t     We try to verify that this is the case by checking to see if\n+\t     the original instruction uses all of the registers that it\n+\t     set.  This case is OK, because deleting a no-op can not affect\n+\t     REG_DEAD notes on other insns.  If this is not the case, then\n+\t     abort.  */\n+\t  \n+\t  regno = REGNO (orig_dest);\n+\t  for (i = HARD_REGNO_NREGS (regno, GET_MODE (orig_dest)) - 1;\n+\t       i >= 0; i--)\n+\t    if (! refers_to_regno_p (regno + i, regno + i + 1, orig_insn,\n+\t\t\t\t     NULL_PTR))\n+\t      break;\n+\t  if (i >= 0)\n+\t    abort ();\n \t}\n     }\n "}]}