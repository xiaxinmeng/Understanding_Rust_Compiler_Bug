{"sha": "75bafecbd14e68a0f94b3bbc9e414b214c2e7805", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzViYWZlY2JkMTRlNjhhMGY5NGIzYmJjOWU0MTRiMjE0YzJlNzgwNQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-10-26T12:47:14Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-10-26T12:47:14Z"}, "message": "[C++ PATCH] Kill IDENTIFIER_LABEL_VALUE\n\nhttps://gcc.gnu.org/ml/gcc-patches/2017-10/msg01935.html\n\t* decl.c (sort_labels): Restore function.\n\t(pop_labels): Sort labels\n\t(identify_goto): Add translation markup.\n\nFrom-SVN: r254104", "tree": {"sha": "2253d716932a8ce2c8fb32a6c00524b2a39a5e99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2253d716932a8ce2c8fb32a6c00524b2a39a5e99"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75bafecbd14e68a0f94b3bbc9e414b214c2e7805", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75bafecbd14e68a0f94b3bbc9e414b214c2e7805", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75bafecbd14e68a0f94b3bbc9e414b214c2e7805", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75bafecbd14e68a0f94b3bbc9e414b214c2e7805/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8c2e5ecf991b9427afab0679b26a7a99dae2e078", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c2e5ecf991b9427afab0679b26a7a99dae2e078", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c2e5ecf991b9427afab0679b26a7a99dae2e078"}], "stats": {"total": 59, "additions": 43, "deletions": 16}, "files": [{"sha": "29139c54fd0e8b5a3d7e6a8d394dd72861f9154c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75bafecbd14e68a0f94b3bbc9e414b214c2e7805/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75bafecbd14e68a0f94b3bbc9e414b214c2e7805/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=75bafecbd14e68a0f94b3bbc9e414b214c2e7805", "patch": "@@ -1,3 +1,9 @@\n+2017-10-26  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* decl.c (sort_labels): Restore function.\n+\t(pop_labels): Sort labels\n+\t(identify_goto): Add translation markup.\n+\n 2017-10-25  Nathan Sidwell  <nathan@acm.org>\n \n \tKill IDENTIFIER_LABEL_VALUE."}, {"sha": "519aa06a0f908d11693022e3e7538936166382fc", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 37, "deletions": 16, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75bafecbd14e68a0f94b3bbc9e414b214c2e7805/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75bafecbd14e68a0f94b3bbc9e414b214c2e7805/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=75bafecbd14e68a0f94b3bbc9e414b214c2e7805", "patch": "@@ -372,6 +372,18 @@ check_label_used (tree label)\n     }\n }\n \n+/* Helper function to sort named label entries in a vector by DECL_UID.  */\n+\n+static int\n+sort_labels (const void *a, const void *b)\n+{\n+  tree label1 = *(tree const *) a;\n+  tree label2 = *(tree const *) b;\n+\n+  /* DECL_UIDs can never be equal.  */\n+  return DECL_UID (label1) > DECL_UID (label2) ? -1 : +1;\n+}\n+\n /* At the end of a function, all labels declared within the function\n    go out of scope.  BLOCK is the top-level block for the\n    function.  */\n@@ -382,6 +394,12 @@ pop_labels (tree block)\n   if (!named_labels)\n     return;\n \n+  /* We need to add the labels to the block chain, so debug\n+     information is emitted.  But, we want the order to be stable so\n+     need to sort them first.  Otherwise the debug output could be\n+     randomly ordered.  I guess it's mostly stable, unless the hash\n+     table implementation changes.  */\n+  auto_vec<tree, 32> labels (named_labels->elements ());\n   hash_table<named_label_hash>::iterator end (named_labels->end ());\n   for (hash_table<named_label_hash>::iterator iter\n \t (named_labels->begin ()); iter != end; ++iter)\n@@ -390,18 +408,21 @@ pop_labels (tree block)\n \n       gcc_checking_assert (!ent->outer);\n       if (ent->label_decl)\n-\t{\n-\t  check_label_used (ent->label_decl);\n-\n-\t  /* Put the labels into the \"variables\" of the top-level block,\n-\t     so debugger can see them.  */\n-\t  DECL_CHAIN (ent->label_decl) = BLOCK_VARS (block);\n-\t  BLOCK_VARS (block) = ent->label_decl;\n-\t}\n+\tlabels.quick_push (ent->label_decl);\n       ggc_free (ent);\n     }\n-\n   named_labels = NULL;\n+  labels.qsort (sort_labels);\n+\n+  while (labels.length ())\n+    {\n+      tree label = labels.pop ();\n+\n+      DECL_CHAIN (label) = BLOCK_VARS (block);\n+      BLOCK_VARS (block) = label;\n+\n+      check_label_used (label);\n+    }\n }\n \n /* At the end of a block with local labels, restore the outer definition.  */\n@@ -3066,8 +3087,8 @@ identify_goto (tree decl, location_t loc, const location_t *locus,\n {\n   bool complained\n     = emit_diagnostic (diag_kind, loc, 0,\n-\t\t       decl ? \"jump to label %qD\" : \"jump to case label\",\n-\t\t       decl);\n+\t\t       decl ? N_(\"jump to label %qD\")\n+\t\t       : N_(\"jump to case label\"), decl);\n   if (complained && locus)\n     inform (*locus, \"  from here\");\n   return complained;\n@@ -3136,32 +3157,32 @@ check_previous_goto_1 (tree decl, cp_binding_level* level, tree names,\n \t{\n \tcase sk_try:\n \t  if (!saw_eh)\n-\t    inf = \"enters try block\";\n+\t    inf = N_(\"enters try block\");\n \t  saw_eh = true;\n \t  break;\n \n \tcase sk_catch:\n \t  if (!saw_eh)\n-\t    inf = \"enters catch block\";\n+\t    inf = N_(\"enters catch block\");\n \t  saw_eh = true;\n \t  break;\n \n \tcase sk_omp:\n \t  if (!saw_omp)\n-\t    inf = \"enters OpenMP structured block\";\n+\t    inf = N_(\"enters OpenMP structured block\");\n \t  saw_omp = true;\n \t  break;\n \n \tcase sk_transaction:\n \t  if (!saw_tm)\n-\t    inf = \"enters synchronized or atomic statement\";\n+\t    inf = N_(\"enters synchronized or atomic statement\");\n \t  saw_tm = true;\n \t  break;\n \n \tcase sk_block:\n \t  if (!saw_cxif && level_for_constexpr_if (b->level_chain))\n \t    {\n-\t      inf = \"enters constexpr if statement\";\n+\t      inf = N_(\"enters constexpr if statement\");\n \t      loc = EXPR_LOCATION (b->level_chain->this_entity);\n \t      saw_cxif = true;\n \t    }"}]}