{"sha": "5a63e06940f9d67dd50445c5cdaaf48e4250bdaa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWE2M2UwNjk0MGY5ZDY3ZGQ1MDQ0NWM1Y2RhYWY0OGU0MjUwYmRhYQ==", "commit": {"author": {"name": "Janis Johnson", "email": "janis187@us.ibm.com", "date": "2002-05-07T00:18:48Z"}, "committer": {"name": "Janis Johnson", "email": "janis@gcc.gnu.org", "date": "2002-05-07T00:18:48Z"}, "message": "rtl.h (struct rtx_def): Update comments.\n\n\t* rtl.h (struct rtx_def): Update comments.\n\t(RTL_FLAG_CHECK[12345678]): New.  (rtl_check_failed_flag): Declare.\n\t(RTL_FLAG): New.  (CLEAR_RTX_FLAGS): New.  (flag access macros): Use\n\tRTL_FLAG_CHECK macros with list of expected RTL codes.\n\t* rtl.c (copy_rtx, shallow_copy_rtx): Use RTX_FLAG macro.\n\t(rtl_check_failed_flag): New.\n\t* reload1.c (reload): Use REG macro before changing rtx to MEM.\n\t(reload_cse_noop_set_p): Check rtx code before using access macro.\n\t* config/ia64/ia64.c (process_for_unwind_directive): Check rtx code\n\tbefore using access macro.\n\nFrom-SVN: r53245", "tree": {"sha": "6a6fcad1a0a0bc7ab5bf7d4105bb09ccee379fcb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a6fcad1a0a0bc7ab5bf7d4105bb09ccee379fcb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a63e06940f9d67dd50445c5cdaaf48e4250bdaa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a63e06940f9d67dd50445c5cdaaf48e4250bdaa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a63e06940f9d67dd50445c5cdaaf48e4250bdaa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a63e06940f9d67dd50445c5cdaaf48e4250bdaa/comments", "author": null, "committer": null, "parents": [{"sha": "4afe395245206ed4085058134148ff2bd0aab1f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4afe395245206ed4085058134148ff2bd0aab1f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4afe395245206ed4085058134148ff2bd0aab1f6"}], "stats": {"total": 282, "additions": 211, "deletions": 71}, "files": [{"sha": "5eee1e5ada7ee7a8a4f3ae141c465d2cc279fcd6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a63e06940f9d67dd50445c5cdaaf48e4250bdaa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a63e06940f9d67dd50445c5cdaaf48e4250bdaa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5a63e06940f9d67dd50445c5cdaaf48e4250bdaa", "patch": "@@ -1,3 +1,16 @@\n+2002-05-06  Janis Johnson  <janis187@us.ibm.com>\n+\n+\t* rtl.h (struct rtx_def): Update comments.\n+\t(RTL_FLAG_CHECK[12345678]): New.  (rtl_check_failed_flag): Declare.\n+\t(RTL_FLAG): New.  (CLEAR_RTX_FLAGS): New.  (flag access macros): Use\n+\tRTL_FLAG_CHECK macros with list of expected RTL codes.\n+\t* rtl.c (copy_rtx, shallow_copy_rtx): Use RTX_FLAG macro.\n+\t(rtl_check_failed_flag): New.\n+\t* reload1.c (reload): Use REG macro before changing rtx to MEM.\n+\t(reload_cse_noop_set_p): Check rtx code before using access macro.\n+\t* config/ia64/ia64.c (process_for_unwind_directive): Check rtx code\n+\tbefore using access macro.\n+\n 2002-05-06  Janis Johnson  <janis187@us.ibm.com>\n \n \t* doc/rtl.texi (Flags): Update to reflect current usage."}, {"sha": "24b839b44edafdcbaad551a92e0e77d69d4e777c", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a63e06940f9d67dd50445c5cdaaf48e4250bdaa/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a63e06940f9d67dd50445c5cdaaf48e4250bdaa/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=5a63e06940f9d67dd50445c5cdaaf48e4250bdaa", "patch": "@@ -7225,7 +7225,7 @@ process_for_unwind_directive (asm_out_file, insn)\n \t    }\n \t}\n \n-      if (! RTX_FRAME_RELATED_P (insn))\n+      if (GET_CODE (insn) == NOTE || ! RTX_FRAME_RELATED_P (insn))\n \treturn;\n \n       pat = find_reg_note (insn, REG_FRAME_RELATED_EXPR, NULL_RTX);"}, {"sha": "3974e99f0b330b090ca8c4cf12f5a602cc7fc2d9", "filename": "gcc/reload1.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a63e06940f9d67dd50445c5cdaaf48e4250bdaa/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a63e06940f9d67dd50445c5cdaaf48e4250bdaa/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=5a63e06940f9d67dd50445c5cdaaf48e4250bdaa", "patch": "@@ -1160,9 +1160,9 @@ reload (first, global)\n \t    {\n \t      rtx reg = regno_reg_rtx[i];\n \n+\t      REG_USERVAR_P (reg) = 0;\n \t      PUT_CODE (reg, MEM);\n \t      XEXP (reg, 0) = addr;\n-\t      REG_USERVAR_P (reg) = 0;\n \t      if (reg_equiv_memory_loc[i])\n \t\tMEM_COPY_ATTRIBUTES (reg, reg_equiv_memory_loc[i]);\n \t      else\n@@ -8079,7 +8079,8 @@ reload_cse_simplify (insn)\n       if (!count && reload_cse_noop_set_p (body))\n \t{\n \t  rtx value = SET_DEST (body);\n-\t  if (! REG_FUNCTION_VALUE_P (SET_DEST (body)))\n+\t  if (GET_CODE (body) == REG\n+\t      && ! REG_FUNCTION_VALUE_P (SET_DEST (body)))\n \t    value = 0;\n \t  reload_cse_delete_noop_set (insn, value);\n \t  return;"}, {"sha": "ad0bc53694d1c7baac12b8c3e6dc4dec983336e2", "filename": "gcc/rtl.c", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a63e06940f9d67dd50445c5cdaaf48e4250bdaa/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a63e06940f9d67dd50445c5cdaaf48e4250bdaa/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=5a63e06940f9d67dd50445c5cdaaf48e4250bdaa", "patch": "@@ -331,13 +331,13 @@ copy_rtx (orig)\n \n   /* We do not copy the USED flag, which is used as a mark bit during\n      walks over the RTL.  */\n-  copy->used = 0;\n+  RTX_FLAG (copy, used) = 0;\n \n   /* We do not copy FRAME_RELATED for INSNs.  */\n   if (GET_RTX_CLASS (code) == 'i')\n-    copy->frame_related = 0;\n-  copy->jump = orig->jump;\n-  copy->call = orig->call;\n+    RTX_FLAG (copy, frame_related) = 0;\n+  RTX_FLAG (copy, jump) = RTX_FLAG (orig, jump);\n+  RTX_FLAG (copy, call) = RTX_FLAG (orig, call);\n \n   format_ptr = GET_RTX_FORMAT (GET_CODE (copy));\n \n@@ -390,11 +390,11 @@ shallow_copy_rtx (orig)\n   rtx copy = rtx_alloc (code);\n \n   PUT_MODE (copy, GET_MODE (orig));\n-  copy->in_struct = orig->in_struct;\n-  copy->volatil = orig->volatil;\n-  copy->unchanging = orig->unchanging;\n-  copy->integrated = orig->integrated;\n-  copy->frame_related = orig->frame_related;\n+  RTX_FLAG (copy, in_struct) = RTX_FLAG (orig, in_struct);\n+  RTX_FLAG (copy, volatil) = RTX_FLAG (orig, volatil);\n+  RTX_FLAG (copy, unchanging) = RTX_FLAG (orig, unchanging);\n+  RTX_FLAG (copy, integrated) = RTX_FLAG (orig, integrated);\n+  RTX_FLAG (copy, frame_related) = RTX_FLAG (orig, frame_related);\n \n   for (i = 0; i < GET_RTX_LENGTH (code); i++)\n     copy->fld[i] = orig->fld[i];\n@@ -637,3 +637,17 @@ rtvec_check_failed_bounds (r, n, file, line, func)\n      n, GET_NUM_ELEM (r) - 1, func, trim_filename (file), line);\n }\n #endif /* ENABLE_RTL_CHECKING */\n+\n+#if defined ENABLE_RTL_FLAG_CHECKING\n+void\n+rtl_check_failed_flag (r, file, line, func)\n+    rtx r;\n+    const char *file;\n+    int line;\n+    const char *func;\n+{\n+  internal_error\n+    (\"RTL flag check: access macro used with unexpected rtx code `%s' in %s, at %s:%d\",\n+     GET_RTX_NAME (GET_CODE (r)), func, trim_filename (file), line);\n+}\n+#endif /* ENABLE_RTL_FLAG_CHECKING */"}, {"sha": "3a20343a78677c79aaae99e2b0451eeb406167b4", "filename": "gcc/rtl.h", "status": "modified", "additions": 171, "deletions": 59, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a63e06940f9d67dd50445c5cdaaf48e4250bdaa/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a63e06940f9d67dd50445c5cdaaf48e4250bdaa/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=5a63e06940f9d67dd50445c5cdaaf48e4250bdaa", "patch": "@@ -127,31 +127,30 @@ struct rtx_def\n   /* The kind of value the expression has.  */\n   ENUM_BITFIELD(machine_mode) mode : 8;\n \n-  /* 1 in an INSN if it can alter flow of control\n-     within this function.\n-     MEM_KEEP_ALIAS_SET_P in a MEM.\n-     SET_IS_RETURN_P in a SET.  */\n+  /* 1 in a MEM if we should keep the alias set for this mem unchanged\n+     when we access a component.\n+     1 in a CALL_INSN if it is a sibling call.\n+     1 in a SET that is for a return.  */\n   unsigned int jump : 1;\n-  /* 1 in an INSN if it can call another function.  */\n+  /* This flag is currently unused.  */\n   unsigned int call : 1;\n-  /* 1 in a REG if value of this expression will never change during\n-     the current function, even though it is not manifestly constant.\n-     1 in a MEM if contents of memory are constant.  This does not\n-     necessarily mean that the value of this expression is constant.\n-     1 in a SUBREG if it is from a promoted variable that is unsigned.\n+  /* 1 in a REG, MEM, or CONCAT if the value is set at most once, anywhere.\n+     1 in a SUBREG if it references an unsigned object whose mode has been\n+     from a promoted to a wider mode.\n      1 in a SYMBOL_REF if it addresses something in the per-function\n      constants pool.\n-     1 in a CALL_INSN if it is a const call.\n-     1 in a JUMP_INSN if it is a branch that should be annulled.  Valid from\n-     reorg until end of compilation; cleared before used.  */\n+     1 in a CALL_INSN, NOTE, or EXPR_LIST for a const or pure call.\n+     1 in an INSN in the delay slot of a branch insn if an annulling branch\n+     should be used.  */\n   unsigned int unchanging : 1;\n-  /* 1 in a MEM expression if contents of memory are volatile.\n-     1 in an INSN, CALL_INSN, JUMP_INSN, CODE_LABEL or BARRIER\n-     if it is deleted.\n-     1 in a REG expression if corresponds to a variable declared by the user.\n+  /* 1 in a MEM or ASM_OPERANDS expression if the memory reference is volatile.\n+     1 in an INSN, CALL_INSN, JUMP_INSN, CODE_LABEL, BARRIER, or NOTE\n+     if it has been deleted.\n+     1 in a REG expression if corresponds to a variable declared by the user,\n      0 for an internally generated temporary.\n-     In a SYMBOL_REF, this flag is used for machine-specific purposes.\n-     In a LABEL_REF or in a REG_LABEL note, this is LABEL_REF_NONLOCAL_P.  */\n+     1 in a SUBREG with a negative value.\n+     1 in a LABEL_REF or in a REG_LABEL note for a non-local label.\n+     In a SYMBOL_REF, this flag is used for machine-specific purposes.  */\n   unsigned int volatil : 1;\n   /* 1 in a MEM referring to a field of an aggregate.\n      0 if the MEM was a variable or the result of a * operator in C;\n@@ -163,23 +162,25 @@ struct rtx_def\n      and must not be deleted even if its count is zero.\n      1 in a LABEL_REF if this is a reference to a label outside the\n      current loop.\n-     1 in an INSN, JUMP_INSN, or CALL_INSN if this insn must be scheduled\n-     together with the preceding insn.  Valid only within sched.\n+     1 in an INSN, JUMP_INSN, CALL_INSN, CODE_LABEL, BARRIER, or NOTE if\n+     this insn must be scheduled together with the preceding insn.  Valid\n+     only within sched.\n      1 in an INSN, JUMP_INSN, or CALL_INSN if insn is in a delay slot and\n      from the target of a branch.  Valid from reorg until end of compilation;\n      cleared before used.\n-     1 in an INSN if this insn is dead code.  Valid only during\n+     1 in an INSN in a delay slot that is the target of a branch, during reorg.\n+     1 in an INSN or related rtx if this insn is dead code.  Valid only during\n      dead-code elimination phase; cleared before use.  */\n   unsigned int in_struct : 1;\n-  /* 1 if this rtx is used.  This is used for copying shared structure.\n-     See `unshare_all_rtl'.\n+  /* At the end of RTL generation, 1 if this rtx is used.  This is used for\n+     copying shared structure.  See `unshare_all_rtl'.\n      In a REG, this is not needed for that purpose, and used instead\n      in `leaf_renumber_regs_insn'.\n-     In a SYMBOL_REF, means that emit_library_call\n+     1 in a SYMBOL_REF, means that emit_library_call\n      has used it as the function.  */\n   unsigned int used : 1;\n   /* Nonzero if this rtx came from procedure integration.\n-     In a REG, nonzero means this reg refers to the return value\n+     1 in a REG means this reg refers to the return value\n      of the current function.\n      1 in a SYMBOL_REF if the symbol is weak.  */\n   unsigned integrated : 1;\n@@ -209,11 +210,6 @@ struct rtx_def\n #define GET_MODE(RTX)\t    ((enum machine_mode) (RTX)->mode)\n #define PUT_MODE(RTX, MODE) ((RTX)->mode = (ENUM_BITFIELD(machine_mode)) (MODE))\n \n-#define RTX_FLAG(RTX,FLAG) ((RTX)->FLAG)\n-#define RTX_INTEGRATED_P(RTX) ((RTX)->integrated)\n-#define RTX_UNCHANGING_P(RTX) ((RTX)->unchanging)\n-#define RTX_FRAME_RELATED_P(RTX) ((RTX)->frame_related)\n-\n /* RTL vector.  These appear inside RTX's when there is a need\n    for a variable number of things.  The principle use is inside\n    PARALLEL expressions.  */\n@@ -336,6 +332,102 @@ extern void rtvec_check_failed_bounds PARAMS ((rtvec, int,\n \n #endif\n \n+/* General accessor macros for accessing the flags of an rtx.  */\n+\n+/* Access an individual rtx flag, with no checking of any kind.  */\n+#define RTX_FLAG(RTX, FLAG)\t((RTX)->FLAG)\n+\n+#if defined ENABLE_RTL_FLAG_CHECKING\n+#define RTL_FLAG_CHECK1(RTX, C1) __extension__\t\t\t\\\n+({ rtx const _rtx = (RTX);\t\t\t\t\t\t\\\n+   if (GET_CODE(_rtx) != C1)\t\t\t\t\t\t\\\n+     rtl_check_failed_flag  (_rtx, __FILE__, __LINE__, __FUNCTION__);\t\\\n+   _rtx; })\n+\n+#define RTL_FLAG_CHECK2(RTX, C1, C2) __extension__\t\t\\\n+({ rtx const _rtx = (RTX);\t\t\t\t\t\t\\\n+   if (GET_CODE(_rtx) != C1 && GET_CODE(_rtx) != C2)\t\t\t\\\n+     rtl_check_failed_flag  (_rtx, __FILE__, __LINE__, __FUNCTION__);\t\\\n+   _rtx; })\n+\n+#define RTL_FLAG_CHECK3(RTX, C1, C2, C3) __extension__\t\t\\\n+({ rtx const _rtx = (RTX);\t\t\t\t\t\t\\\n+   if (GET_CODE(_rtx) != C1 && GET_CODE(_rtx) != C2 \t\t\t\\\n+       && GET_CODE(_rtx) != C3)\t\t\t\t\t\t\\\n+     rtl_check_failed_flag  (_rtx, __FILE__, __LINE__, __FUNCTION__);\t\\\n+   _rtx; })\n+\n+#define RTL_FLAG_CHECK4(RTX, C1, C2, C3, C4) __extension__\t\\\n+({ rtx const _rtx = (RTX);\t\t\t\t\t\t\\\n+   if (GET_CODE(_rtx) != C1 && GET_CODE(_rtx) != C2\t \t\t\\\n+       && GET_CODE(_rtx) != C3 && GET_CODE(_rtx) != C4)\t\t\t\\\n+     rtl_check_failed_flag  (_rtx, __FILE__, __LINE__, __FUNCTION__);\t\\\n+   _rtx; })\n+\n+#define RTL_FLAG_CHECK5(RTX, C1, C2, C3, C4, C5) __extension__\t\\\n+({ rtx const _rtx = (RTX);\t\t\t\t\t\t\\\n+   if (GET_CODE(_rtx) != C1 && GET_CODE(_rtx) != C2\t \t\t\\\n+       && GET_CODE(_rtx) != C3 && GET_CODE(_rtx) != C4\t\t\t\\\n+       && GET_CODE(_rtx) != C5)\t\t\t\t\t\t\\\n+     rtl_check_failed_flag  (_rtx, __FILE__, __LINE__, __FUNCTION__);\t\\\n+   _rtx; })\n+\n+#define RTL_FLAG_CHECK6(RTX, C1, C2, C3, C4, C5, C6) __extension__\t\\\n+({ rtx const _rtx = (RTX);\t\t\t\t\t\t\\\n+   if (GET_CODE(_rtx) != C1 && GET_CODE(_rtx) != C2\t \t\t\\\n+       && GET_CODE(_rtx) != C3 && GET_CODE(_rtx) != C4\t\t\t\\\n+       && GET_CODE(_rtx) != C5 && GET_CODE(_rtx) != C6)\t\t\t\\\n+     rtl_check_failed_flag  (_rtx, __FILE__, __LINE__, __FUNCTION__);\t\\\n+   _rtx; })\n+\n+#define RTL_FLAG_CHECK7(RTX, C1, C2, C3, C4, C5, C6, C7) __extension__\t\\\n+({ rtx const _rtx = (RTX);\t\t\t\t\t\t\\\n+   if (GET_CODE(_rtx) != C1 && GET_CODE(_rtx) != C2\t \t\t\\\n+       && GET_CODE(_rtx) != C3 && GET_CODE(_rtx) != C4\t\t\t\\\n+       && GET_CODE(_rtx) != C5 && GET_CODE(_rtx) != C6\t\t\t\\\n+       && GET_CODE(_rtx) != C7)\t\t\t\t\t\t\\\n+     rtl_check_failed_flag  (_rtx, __FILE__, __LINE__, __FUNCTION__);\t\\\n+   _rtx; })\n+\n+#define RTL_FLAG_CHECK8(RTX, C1, C2, C3, C4, C5, C6, C7, C8) __extension__ \\\n+({ rtx const _rtx = (RTX);\t\t\t\t\t\t\\\n+   if (GET_CODE(_rtx) != C1 && GET_CODE(_rtx) != C2\t \t\t\\\n+       && GET_CODE(_rtx) != C3 && GET_CODE(_rtx) != C4\t\t\t\\\n+       && GET_CODE(_rtx) != C5 && GET_CODE(_rtx) != C6\t\t\t\\\n+       && GET_CODE(_rtx) != C7 && GET_CODE(_rtx) != C8)\t\t\t\\\n+     rtl_check_failed_flag  (_rtx, __FILE__, __LINE__, __FUNCTION__);\t\\\n+   _rtx; })\n+\n+extern void rtl_check_failed_flag PARAMS ((rtx, const char *, int,\n+      \t\t\t\t\t const char *))\n+    ATTRIBUTE_NORETURN\n+    ;\n+\n+#else\t/* not ENABLE_RTL_FLAG_CHECKING */\n+\n+#define RTL_FLAG_CHECK1(RTX, C1)\t\t\t(RTX)\n+#define RTL_FLAG_CHECK2(RTX, C1, C2)\t\t\t(RTX)\n+#define RTL_FLAG_CHECK3(RTX, C1, C2, C3)\t\t(RTX)\n+#define RTL_FLAG_CHECK4(RTX, C1, C2, C3, C4)\t\t(RTX)\n+#define RTL_FLAG_CHECK5(RTX, C1, C2, C3, C4, C5)  \t(RTX)\n+#define RTL_FLAG_CHECK6(RTX, C1, C2, C3, C4, C5, C6)\t(RTX)\n+#define RTL_FLAG_CHECK7(RTX, C1, C2, C3, C4, C5, C6, C7) (RTX)\n+#define RTL_FLAG_CHECK8(RTX, C1, C2, C3, C4, C5, C6, C7, C8) (RTX)\n+#endif\n+\n+#define CLEAR_RTX_FLAGS(RTX)\t\\\n+do {\t\t\t\t\\\n+  rtx const _rtx = (RTX);\t\\\n+  _rtx->call = 0;\t\t\\\n+  _rtx->frame_related = 0;\t\\\n+  _rtx->in_struct = 0;\t\t\\\n+  _rtx->integrated = 0;\t\t\\\n+  _rtx->jump = 0;\t\t\\\n+  _rtx->unchanging = 0;\t\t\\\n+  _rtx->used = 0;\t\t\\\n+  _rtx->volatil = 0;\t\t\\\n+} while (0)\n+\n #define XWINT(RTX, N)\t(RTL_CHECK1 (RTX, N, 'w').rtwint)\n #define XINT(RTX, N)\t(RTL_CHECK2 (RTX, N, 'i', 'n').rtint)\n #define XSTR(RTX, N)\t(RTL_CHECK2 (RTX, N, 's', 'S').rtstr)\n@@ -412,27 +504,39 @@ extern void rtvec_check_failed_bounds PARAMS ((rtvec, int,\n    They are always in the same basic block as this insn.  */\n #define LOG_LINKS(INSN)\tXEXP(INSN, 5)\n \n+#define RTX_INTEGRATED_P(RTX)\t\\\n+  (RTL_FLAG_CHECK8((RTX), INSN, CALL_INSN, JUMP_INSN, INSN_LIST,\t\\\n+\t\t   BARRIER, CODE_LABEL, CONST, NOTE)->integrated)\n+#define RTX_UNCHANGING_P(RTX)\t\t\\\n+  (RTL_FLAG_CHECK3((RTX), REG, MEM, CONCAT)->unchanging)\n+#define RTX_FRAME_RELATED_P(RTX)\t\\\n+  (RTL_FLAG_CHECK5((RTX), INSN, CALL_INSN, JUMP_INSN, BARRIER,\t\\\n+\t\t   SET)->frame_related)\n+\n /* 1 if insn has been deleted.  */\n-#define INSN_DELETED_P(INSN) ((INSN)->volatil)\n+#define INSN_DELETED_P(RTX)\t\\\n+  (RTL_FLAG_CHECK6((RTX), INSN, CALL_INSN, JUMP_INSN, CODE_LABEL,\t\\\n+\t\t   BARRIER, NOTE)->volatil)\n \n /* 1 if insn is a call to a const or pure function.  */\n-#define CONST_OR_PURE_CALL_P(INSN) ((INSN)->unchanging)\n+#define CONST_OR_PURE_CALL_P(RTX)\t\\\n+  (RTL_FLAG_CHECK3((RTX), CALL_INSN, NOTE, EXPR_LIST)->unchanging)\n \n /* 1 if insn (assumed to be a CALL_INSN) is a sibling call.  */\n-#define SIBLING_CALL_P(INSN) ((INSN)->jump)\n+#define SIBLING_CALL_P(INSN) (RTL_FLAG_CHECK1((INSN), CALL_INSN)->jump)\n \n-/* 1 if insn is a branch that should not unconditionally execute its\n-   delay slots, i.e., it is an annulled branch.  */\n-#define INSN_ANNULLED_BRANCH_P(INSN) ((INSN)->unchanging)\n+/* 1 in an INSN in the delay slot of a branch insn if an annulling branch\n+   should be used.  */\n+#define INSN_ANNULLED_BRANCH_P(RTX) (RTL_FLAG_CHECK1((RTX), INSN)->unchanging)\n \n /* 1 if insn is a dead code.  Valid only for dead-code elimination phase.  */\n-#define INSN_DEAD_CODE_P(INSN) ((INSN)->in_struct)\n+#define INSN_DEAD_CODE_P(RTX) (RTL_FLAG_CHECK1((RTX), INSN)->in_struct)\n \n /* 1 if insn is in a delay slot and is from the target of the branch.  If\n    the branch insn has INSN_ANNULLED_BRANCH_P set, this insn should only be\n    executed if the branch is taken.  For annulled branches with this bit\n    clear, the insn should be executed only if the branch is not taken.  */\n-#define INSN_FROM_TARGET_P(INSN) ((INSN)->in_struct)\n+#define INSN_FROM_TARGET_P(RTX) (RTL_FLAG_CHECK1((RTX), INSN)->in_struct)\n \n #define ADDR_DIFF_VEC_FLAGS(RTX) X0ADVFLAGS(RTX, 4)\n \n@@ -792,13 +896,13 @@ extern const char * const note_insn_name[NOTE_INSN_MAX - NOTE_INSN_BIAS];\n /* For a REG rtx, REG_FUNCTION_VALUE_P is nonzero if the reg\n    is the current function's return value.  */\n \n-#define REG_FUNCTION_VALUE_P(RTX) ((RTX)->integrated)\n+#define REG_FUNCTION_VALUE_P(RTX) (RTL_FLAG_CHECK1((RTX), REG)->integrated)\n \n /* 1 in a REG rtx if it corresponds to a variable declared by the user.  */\n-#define REG_USERVAR_P(RTX) ((RTX)->volatil)\n+#define REG_USERVAR_P(RTX) (RTL_FLAG_CHECK1((RTX), REG)->volatil)\n \n /* 1 in a REG rtx if the register is a pointer.  */\n-#define REG_POINTER(RTX) ((RTX)->frame_related)\n+#define REG_POINTER(RTX) (RTL_FLAG_CHECK1((RTX), REG)->frame_related)\n \n /* 1 if the given register REG corresponds to a hard register.  */\n #define HARD_REGISTER_P(REG) (HARD_REGISTER_NUM_P (REGNO (REG)))\n@@ -851,17 +955,19 @@ extern unsigned int subreg_regno \tPARAMS ((rtx));\n    When used as a LHS, is means that this extension must be done\n    when assigning to SUBREG_REG.  */\n \n-#define SUBREG_PROMOTED_VAR_P(RTX) ((RTX)->in_struct)\n+#define SUBREG_PROMOTED_VAR_P(RTX) (RTL_FLAG_CHECK1((RTX), SUBREG)->in_struct)\n #define SUBREG_PROMOTED_UNSIGNED_SET(RTX, VAL)\t\\\n do {\t\t\t\t\t\t\\\n+  RTL_FLAG_CHECK1((RTX), SUBREG);\t\t\\\n   if ((VAL) < 0)\t\t\t\t\\\n     (RTX)->volatil = 1;\t\t\t\t\\\n   else {\t\t\t\t\t\\\n     (RTX)->volatil = 0;\t\t\t\t\\\n     (RTX)->unchanging = (VAL);\t\t\t\\\n   }\t\t\t\t\t\t\\\n } while (0)\n-#define SUBREG_PROMOTED_UNSIGNED_P(RTX) ((RTX)->volatil ? -1 : (RTX)->unchanging)\n+#define SUBREG_PROMOTED_UNSIGNED_P(RTX)\t\\\n+  ((RTL_FLAG_CHECK1((RTX), SUBREG)->volatil) ? -1 : (RTX)->unchanging)\n \n /* Access various components of an ASM_OPERANDS rtx.  */\n \n@@ -884,20 +990,20 @@ do {\t\t\t\t\t\t\\\n /* For a MEM RTX, 1 if we should keep the alias set for this mem\n    unchanged when we access a component.  Set to 1, or example, when we\n    are already in a non-addressable component of an aggregate.  */\n-#define MEM_KEEP_ALIAS_SET_P(RTX) ((RTX)->jump)\n+#define MEM_KEEP_ALIAS_SET_P(RTX) (RTL_FLAG_CHECK1((RTX), MEM)->jump)\n \n /* For a MEM rtx, 1 if it's a volatile reference.\n    Also in an ASM_OPERANDS rtx.  */\n-#define MEM_VOLATILE_P(RTX) ((RTX)->volatil)\n+#define MEM_VOLATILE_P(RTX) (RTL_FLAG_CHECK2((RTX), MEM, ASM_OPERANDS)->volatil)\n \n /* For a MEM rtx, 1 if it refers to an aggregate, either to the\n    aggregate itself of to a field of the aggregate.  If zero, RTX may\n    or may not be such a reference.  */\n-#define MEM_IN_STRUCT_P(RTX) ((RTX)->in_struct)\n+#define MEM_IN_STRUCT_P(RTX) (RTL_FLAG_CHECK1((RTX), MEM)->in_struct)\n \n /* For a MEM rtx, 1 if it refers to a scalar.  If zero, RTX may or may\n    not refer to a scalar.  */\n-#define MEM_SCALAR_P(RTX) ((RTX)->frame_related)\n+#define MEM_SCALAR_P(RTX) (RTL_FLAG_CHECK1((RTX), MEM)->frame_related)\n \n /* If VAL is non-zero, set MEM_IN_STRUCT_P and clear MEM_SCALAR_P in\n    RTX.  Otherwise, vice versa.  Use this macro only when you are\n@@ -965,27 +1071,31 @@ do {\t\t\t\t\t\t\\\n \n /* For a LABEL_REF, 1 means that this reference is to a label outside the\n    loop containing the reference.  */\n-#define LABEL_OUTSIDE_LOOP_P(RTX) ((RTX)->in_struct)\n+#define LABEL_OUTSIDE_LOOP_P(RTX) (RTL_FLAG_CHECK1((RTX), LABEL_REF)->in_struct)\n \n /* For a LABEL_REF, 1 means it is for a nonlocal label.  */\n /* Likewise in an EXPR_LIST for a REG_LABEL note.  */\n-#define LABEL_REF_NONLOCAL_P(RTX) ((RTX)->volatil)\n+#define LABEL_REF_NONLOCAL_P(RTX)\t\\\n+  (RTL_FLAG_CHECK2((RTX), LABEL_REF, REG_LABEL)->volatil)\n \n /* For a CODE_LABEL, 1 means always consider this label to be needed.  */\n-#define LABEL_PRESERVE_P(RTX) ((RTX)->in_struct)\n+#define LABEL_PRESERVE_P(RTX) \\\n+  (RTL_FLAG_CHECK2((RTX), CODE_LABEL, NOTE)->in_struct)\n \n /* For a REG, 1 means the register is used only in an exit test of a loop.  */\n-#define REG_LOOP_TEST_P(RTX) ((RTX)->in_struct)\n+#define REG_LOOP_TEST_P(RTX) (RTL_FLAG_CHECK1((RTX), REG)->in_struct)\n \n /* During sched, for an insn, 1 means that the insn must be scheduled together\n    with the preceding insn.  */\n-#define SCHED_GROUP_P(INSN) ((INSN)->in_struct)\n+#define SCHED_GROUP_P(RTX)\t\\\n+  (RTL_FLAG_CHECK6((RTX), INSN, JUMP_INSN, CALL_INSN, CODE_LABEL, \\\n+\t\t          BARRIER, NOTE)->in_struct)\n \n /* For a SET rtx, SET_DEST is the place that is set\n    and SET_SRC is the value it is set to.  */\n #define SET_DEST(RTX) XC2EXP(RTX, 0, SET, CLOBBER)\n #define SET_SRC(RTX) XCEXP(RTX, 1, SET)\n-#define SET_IS_RETURN_P(RTX) ((RTX)->jump)\n+#define SET_IS_RETURN_P(RTX) (RTL_FLAG_CHECK1((RTX), SET)->jump)\n \n /* For a TRAP_IF rtx, TRAP_CONDITION is an expression.  */\n #define TRAP_CONDITION(RTX) XCEXP (RTX, 0, TRAP_IF)\n@@ -998,19 +1108,21 @@ do {\t\t\t\t\t\t\\\n #define COND_EXEC_CODE(RTX) XCEXP (RTX, 1, COND_EXEC)\n \n /* 1 in a SYMBOL_REF if it addresses this function's constants pool.  */\n-#define CONSTANT_POOL_ADDRESS_P(RTX) ((RTX)->unchanging)\n+#define CONSTANT_POOL_ADDRESS_P(RTX)\t\\\n+  (RTL_FLAG_CHECK1((RTX), SYMBOL_REF)->unchanging)\n \n /* 1 in a SYMBOL_REF if it addresses this function's string constant pool.  */\n-#define STRING_POOL_ADDRESS_P(RTX) ((RTX)->frame_related)\n+#define STRING_POOL_ADDRESS_P(RTX)\t\\\n+  (RTL_FLAG_CHECK1((RTX), SYMBOL_REF)->frame_related)\n \n /* Flag in a SYMBOL_REF for machine-specific purposes.  */\n-#define SYMBOL_REF_FLAG(RTX) ((RTX)->volatil)\n+#define SYMBOL_REF_FLAG(RTX) (RTL_FLAG_CHECK1((RTX), SYMBOL_REF)->volatil)\n \n /* 1 means a SYMBOL_REF has been the library function in emit_library_call.  */\n-#define SYMBOL_REF_USED(RTX) ((RTX)->used)\n+#define SYMBOL_REF_USED(RTX) (RTL_FLAG_CHECK1((RTX), SYMBOL_REF)->used)\n \n /* 1 means a SYMBOL_REF is weak.  */\n-#define SYMBOL_REF_WEAK(RTX) ((RTX)->integrated)\n+#define SYMBOL_REF_WEAK(RTX) (RTL_FLAG_CHECK1((RTX), SYMBOL_REF)->integrated)\n \n /* Define a macro to look for REG_INC notes,\n    but save time on machines where they never exist.  */"}]}