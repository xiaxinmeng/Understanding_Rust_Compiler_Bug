{"sha": "0bf60f68ed9db2e4b373b28c125aeda339f6cd59", "node_id": "C_kwDOANBUbNoAKDBiZjYwZjY4ZWQ5ZGIyZTRiMzczYjI4YzEyNWFlZGEzMzlmNmNkNTk", "commit": {"author": {"name": "Max Filippov", "email": "jcmvbkbc@gmail.com", "date": "2022-07-14T09:39:59Z"}, "committer": {"name": "Max Filippov", "email": "jcmvbkbc@gmail.com", "date": "2022-09-22T10:53:43Z"}, "message": "xtensa: gcc: implement MI thunk generation for call0 ABI\n\ngcc/\n\t* config/xtensa/xtensa.cc (xtensa_can_output_mi_thunk)\n\t(xtensa_output_mi_thunk): New functions.\n\t(TARGET_ASM_CAN_OUTPUT_MI_THUNK)\n\t(TARGET_ASM_OUTPUT_MI_THUNK): New macro definitions.\n\t(xtensa_prepare_expand_call): Use fixed register a8 as temporary\n\twhen called with reload_completed set to 1.", "tree": {"sha": "fea5b1cadfdd4d3ebda6b23fa9cd5810e265a584", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fea5b1cadfdd4d3ebda6b23fa9cd5810e265a584"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0bf60f68ed9db2e4b373b28c125aeda339f6cd59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bf60f68ed9db2e4b373b28c125aeda339f6cd59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bf60f68ed9db2e4b373b28c125aeda339f6cd59", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bf60f68ed9db2e4b373b28c125aeda339f6cd59/comments", "author": {"login": "jcmvbkbc", "id": 166731, "node_id": "MDQ6VXNlcjE2NjczMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/166731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jcmvbkbc", "html_url": "https://github.com/jcmvbkbc", "followers_url": "https://api.github.com/users/jcmvbkbc/followers", "following_url": "https://api.github.com/users/jcmvbkbc/following{/other_user}", "gists_url": "https://api.github.com/users/jcmvbkbc/gists{/gist_id}", "starred_url": "https://api.github.com/users/jcmvbkbc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jcmvbkbc/subscriptions", "organizations_url": "https://api.github.com/users/jcmvbkbc/orgs", "repos_url": "https://api.github.com/users/jcmvbkbc/repos", "events_url": "https://api.github.com/users/jcmvbkbc/events{/privacy}", "received_events_url": "https://api.github.com/users/jcmvbkbc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jcmvbkbc", "id": 166731, "node_id": "MDQ6VXNlcjE2NjczMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/166731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jcmvbkbc", "html_url": "https://github.com/jcmvbkbc", "followers_url": "https://api.github.com/users/jcmvbkbc/followers", "following_url": "https://api.github.com/users/jcmvbkbc/following{/other_user}", "gists_url": "https://api.github.com/users/jcmvbkbc/gists{/gist_id}", "starred_url": "https://api.github.com/users/jcmvbkbc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jcmvbkbc/subscriptions", "organizations_url": "https://api.github.com/users/jcmvbkbc/orgs", "repos_url": "https://api.github.com/users/jcmvbkbc/repos", "events_url": "https://api.github.com/users/jcmvbkbc/events{/privacy}", "received_events_url": "https://api.github.com/users/jcmvbkbc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4bdf739f835520ccbc433dc9eac461895741f317", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bdf739f835520ccbc433dc9eac461895741f317", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bdf739f835520ccbc433dc9eac461895741f317"}], "stats": {"total": 116, "additions": 115, "deletions": 1}, "files": [{"sha": "e5abd356a745340e7460afa75e6a69f8f6fa51b1", "filename": "gcc/config/xtensa/xtensa.cc", "status": "modified", "additions": 115, "deletions": 1, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bf60f68ed9db2e4b373b28c125aeda339f6cd59/gcc%2Fconfig%2Fxtensa%2Fxtensa.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bf60f68ed9db2e4b373b28c125aeda339f6cd59/gcc%2Fconfig%2Fxtensa%2Fxtensa.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.cc?ref=0bf60f68ed9db2e4b373b28c125aeda339f6cd59", "patch": "@@ -191,6 +191,15 @@ static bool xtensa_can_eliminate (const int from ATTRIBUTE_UNUSED,\n static HOST_WIDE_INT xtensa_starting_frame_offset (void);\n static unsigned HOST_WIDE_INT xtensa_asan_shadow_offset (void);\n static bool xtensa_function_ok_for_sibcall (tree, tree);\n+static bool xtensa_can_output_mi_thunk (const_tree thunk_fndecl ATTRIBUTE_UNUSED,\n+\t\t\t\t\tHOST_WIDE_INT delta ATTRIBUTE_UNUSED,\n+\t\t\t\t\tHOST_WIDE_INT vcall_offset ATTRIBUTE_UNUSED,\n+\t\t\t\t\tconst_tree function ATTRIBUTE_UNUSED);\n+static void xtensa_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n+\t\t\t\t    HOST_WIDE_INT delta,\n+\t\t\t\t    HOST_WIDE_INT vcall_offset,\n+\t\t\t\t    tree function);\n+\n static rtx xtensa_delegitimize_address (rtx);\n \n \f\n@@ -351,6 +360,12 @@ static rtx xtensa_delegitimize_address (rtx);\n #undef TARGET_FUNCTION_OK_FOR_SIBCALL\n #define TARGET_FUNCTION_OK_FOR_SIBCALL xtensa_function_ok_for_sibcall\n \n+#undef TARGET_ASM_CAN_OUTPUT_MI_THUNK\n+#define TARGET_ASM_CAN_OUTPUT_MI_THUNK xtensa_can_output_mi_thunk\n+\n+#undef TARGET_ASM_OUTPUT_MI_THUNK\n+#define TARGET_ASM_OUTPUT_MI_THUNK xtensa_output_mi_thunk\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n \f\n@@ -2173,7 +2188,16 @@ xtensa_prepare_expand_call (int callop, rtx *operands)\n     addr = gen_sym_PLT (addr);\n \n   if (!call_insn_operand (addr, VOIDmode))\n-    XEXP (operands[callop], 0) = copy_to_mode_reg (Pmode, addr);\n+    {\n+      /* This may be called while generating MI thunk when we pretend\n+\t that reload is over.  Use a8 as a temporary register in that case.  */\n+      rtx reg = can_create_pseudo_p ()\n+\t? copy_to_mode_reg (Pmode, addr)\n+\t: copy_to_suggested_reg (addr,\n+\t\t\t\t gen_rtx_REG (Pmode, A8_REG),\n+\t\t\t\t Pmode);\n+      XEXP (operands[callop], 0) = reg;\n+    }\n }\n \n \n@@ -4983,6 +5007,96 @@ xtensa_function_ok_for_sibcall (tree decl ATTRIBUTE_UNUSED, tree exp ATTRIBUTE_U\n   return true;\n }\n \n+static bool\n+xtensa_can_output_mi_thunk (const_tree thunk_fndecl ATTRIBUTE_UNUSED,\n+\t\t\t    HOST_WIDE_INT delta ATTRIBUTE_UNUSED,\n+\t\t\t    HOST_WIDE_INT vcall_offset ATTRIBUTE_UNUSED,\n+\t\t\t    const_tree function ATTRIBUTE_UNUSED)\n+{\n+  if (TARGET_WINDOWED_ABI)\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Output code to add DELTA to the first argument, and then jump\n+   to FUNCTION.  Used for C++ multiple inheritance.  */\n+static void\n+xtensa_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n+\t\t\tHOST_WIDE_INT delta,\n+\t\t\tHOST_WIDE_INT vcall_offset,\n+\t\t\ttree function)\n+{\n+  rtx this_rtx;\n+  rtx funexp;\n+  rtx_insn *insn;\n+  int this_reg_no;\n+  rtx temp0 = gen_rtx_REG (Pmode, A9_REG);\n+  const char *fnname = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (thunk));\n+\n+  reload_completed = 1;\n+\n+  if (aggregate_value_p (TREE_TYPE (TREE_TYPE (function)), function))\n+    this_reg_no = 3;\n+  else\n+    this_reg_no = 2;\n+\n+  this_rtx = gen_rtx_REG (Pmode, A0_REG + this_reg_no);\n+\n+  if (delta)\n+    {\n+      if (xtensa_simm8 (delta))\n+\temit_insn (gen_addsi3 (this_rtx, this_rtx, GEN_INT (delta)));\n+      else\n+\t{\n+\t  emit_move_insn (temp0, GEN_INT (delta));\n+\t  emit_insn (gen_addsi3 (this_rtx, this_rtx, temp0));\n+\t}\n+    }\n+\n+  if (vcall_offset)\n+    {\n+      rtx temp1 = gen_rtx_REG (Pmode, A0_REG + 10);\n+      rtx addr = temp1;\n+\n+      emit_move_insn (temp0, gen_rtx_MEM (Pmode, this_rtx));\n+      if (xtensa_uimm8x4 (vcall_offset))\n+\taddr = plus_constant (Pmode, temp0, vcall_offset);\n+      else if (xtensa_simm8 (vcall_offset))\n+\temit_insn (gen_addsi3 (temp1, temp0, GEN_INT (vcall_offset)));\n+      else\n+\t{\n+\t  emit_move_insn (temp1, GEN_INT (vcall_offset));\n+\t  emit_insn (gen_addsi3 (temp1, temp0, temp1));\n+\t}\n+      emit_move_insn (temp1, gen_rtx_MEM (Pmode, addr));\n+      emit_insn (gen_add2_insn (this_rtx, temp1));\n+    }\n+\n+  /* Generate a tail call to the target function.  */\n+  if (!TREE_USED (function))\n+    {\n+      assemble_external (function);\n+      TREE_USED (function) = 1;\n+    }\n+\n+  funexp = XEXP (DECL_RTL (function), 0);\n+  funexp = gen_rtx_MEM (FUNCTION_MODE, funexp);\n+  insn = emit_call_insn (gen_sibcall (funexp, const0_rtx));\n+  SIBLING_CALL_P (insn) = 1;\n+\n+  insn = get_insns ();\n+  shorten_branches (insn);\n+  assemble_start_function (thunk, fnname);\n+  final_start_function (insn, file, 1);\n+  final (insn, file, 1);\n+  final_end_function ();\n+  assemble_end_function (thunk, fnname);\n+\n+  /* Stop pretending to be a post-reload pass.  */\n+  reload_completed = 0;\n+}\n+\n static rtx\n xtensa_delegitimize_address (rtx op)\n {"}]}