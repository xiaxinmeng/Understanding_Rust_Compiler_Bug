{"sha": "b1092901380ec5872a5122837ea72da9d2f6169b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjEwOTI5MDEzODBlYzU4NzJhNTEyMjgzN2VhNzJkYTlkMmY2MTY5Yg==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-07-03T05:34:40Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-07-03T05:34:40Z"}, "message": "pa.c (ireg_or_int5_operand): New function.\n\n        * pa.c (ireg_or_int5_operand): New function.\n        (output_parallel_movb, output_parallel_addb): Likewise.\n        (combinable_copy, combinable_add, following_call): Likewise.\n        (pa_adjust_insn_length): Handle parallel unconditional branches.\n        (output_movb): Handle case were destination is %sar.\n        * pa.h: Declare new functions.\n        * pa.md (parallel_branch): New \"type\" attribute.\n        (delay slot descriptions): Don't allow \"parallel_branches\" in\n        delay slots.  Fill \"parallel_branches\" like \"branch\" insns.\n        (movb patterns): Handle %sar as destination register.\n\nFrom-SVN: r12382", "tree": {"sha": "bc3d0f8594974822b41adcd7a9aa7b0297ae8a46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc3d0f8594974822b41adcd7a9aa7b0297ae8a46"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1092901380ec5872a5122837ea72da9d2f6169b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1092901380ec5872a5122837ea72da9d2f6169b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1092901380ec5872a5122837ea72da9d2f6169b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1092901380ec5872a5122837ea72da9d2f6169b/comments", "author": null, "committer": null, "parents": [{"sha": "5718612fc1929a7d9a3ec02c34eb6999c3d5b738", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5718612fc1929a7d9a3ec02c34eb6999c3d5b738", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5718612fc1929a7d9a3ec02c34eb6999c3d5b738"}], "stats": {"total": 233, "additions": 200, "deletions": 33}, "files": [{"sha": "76a1b9784129eb9d303a651fc2f02d87e10c2520", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 181, "deletions": 4, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1092901380ec5872a5122837ea72da9d2f6169b/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1092901380ec5872a5122837ea72da9d2f6169b/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=b1092901380ec5872a5122837ea72da9d2f6169b", "patch": "@@ -382,6 +382,19 @@ arith_double_operand (op, mode)\n \t\t  == ((CONST_DOUBLE_LOW (op) & 0x1000) == 0))));\n }\n \n+/* Return truth value of whether OP is a integer which fits the\n+   range constraining immediate operands in three-address insns, or\n+   is an integer register.  */\n+\n+int\n+ireg_or_int5_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return ((GET_CODE (op) == CONST_INT && INT_5_BITS (op))\n+\t  || (GET_CODE (op) == REG && REGNO (op) > 0 && REGNO (op) < 32));\n+}\n+\n /* Return truth value of whether OP is a integer which fits the\n    range constraining immediate operands in three-address insns.  */\n \n@@ -3058,6 +3071,10 @@ pa_adjust_insn_length (insn, length)\n \t  && length == 4\n \t  && ! forward_branch_p (insn))\n \treturn 4;\n+      else if (GET_CODE (pat) == PARALLEL\n+\t       && get_attr_type (insn) == TYPE_PARALLEL_BRANCH\n+\t       && length == 4)\n+\treturn 4;\n       /* Adjust dbra insn with short backwards conditional branch with\n \t unfilled delay slot -- only for case where counter is in a\n \t general register register. */\n@@ -3071,8 +3088,7 @@ pa_adjust_insn_length (insn, length)\n       else\n \treturn 0;\n     }\n-  else\n-    return 0;\n+  return 0;\n }\n \n /* Print operand X (an rtx) in assembler syntax to file FILE.\n@@ -4364,8 +4380,10 @@ output_movb (operands, insn, which_alternative, reverse_comparison)\n \t  output_asm_insn (\"stw %1,-16(0,%%r30)\",operands);\n \t  return \"fldws -16(0,%%r30),%0\";\n \t}\n-      else\n+      else if (which_alternative == 2)\n \treturn \"stw %1,%0\";\n+      else\n+\treturn \"mtsar %r1\";\n     }\n \n   /* Support the second variant.  */\n@@ -4432,7 +4450,7 @@ output_movb (operands, insn, which_alternative, reverse_comparison)\n \treturn \"comclr,%B2 0,%1,0\\n\\tbl %3,0\\n\\tfldws -16(0,%%r30),%0\";\n     }\n   /* Deal with gross reload from memory case.  */\n-  else\n+  else if (which_alternative == 2)\n     {\n       /* Reload loop counter from memory, the store back to memory\n \t happens in the branch's delay slot.   */\n@@ -4441,6 +4459,14 @@ output_movb (operands, insn, which_alternative, reverse_comparison)\n       else\n \treturn \"comclr,%B2 0,%1,0\\n\\tbl %3,0\\n\\tstw %1,%0\";\n     }\n+  /* Handle SAR as a destination.  */\n+  else\n+    {\n+      if (get_attr_length (insn) == 8)\n+\treturn \"comb,%S2 0,%1,%3\\n\\tmtsar %r1\";\n+      else\n+\treturn \"comclr,%B2 0,%1,0\\n\\tbl %3,0\\n\\tmtsar %r1\";\n+    }\n }\n \n \n@@ -5088,6 +5114,157 @@ jump_in_call_delay (insn)\n     return 0;\n }\n \n+/* Output an unconditional move and branch insn.  */\n+\n+char *\n+output_parallel_movb (operands, length)\n+     rtx *operands;\n+     int length;\n+{\n+  /* These are the cases in which we win.  */\n+  if (length == 4)\n+    return \"mov%I1b,tr %1,%0,%2\";\n+\n+  /* None of these cases wins, but they don't lose either.  */\n+  if (dbr_sequence_length () == 0)\n+    {\n+      /* Nothing in the delay slot, fake it by putting the combined\n+\t insn (the copy or add) in the delay slot of a bl.  */\n+      if (GET_CODE (operands[1]) == CONST_INT)\n+\treturn \"bl %2,0\\n\\tldi %1,%0\";\n+      else\n+\treturn \"bl %2,0\\n\\tcopy %1,%0\";\n+    }\n+  else\n+    {\n+      /* Something in the delay slot, but we've got a long branch.  */\n+      if (GET_CODE (operands[1]) == CONST_INT)\n+\treturn \"ldi %1,%0\\n\\tbl %2,0\";\n+      else\n+\treturn \"copy %1,%0\\n\\tbl %2,0\";\n+    }\n+}\n+\n+/* Output an unconditional add and branch insn.  */\n+\n+char *\n+output_parallel_addb (operands, length)\n+     rtx *operands;\n+     int length;\n+{\n+  /* To make life easy we want operand0 to be the shared input/output\n+     operand and operand1 to be the readonly operand.  */\n+  if (operands[0] == operands[1])\n+    operands[1] = operands[2];\n+\n+  /* These are the cases in which we win.  */\n+  if (length == 4)\n+    return \"add%I1b,tr %1,%0,%3\";\n+\n+  /* None of these cases win, but they don't lose either.  */\n+  if (dbr_sequence_length () == 0)\n+    {\n+      /* Nothing in the delay slot, fake it by putting the combined\n+\t insn (the copy or add) in the delay slot of a bl.  */\n+      return \"bl %3,0\\n\\tadd%I1 %1,%0,%0\";\n+    }\n+  else\n+    {\n+      /* Something in the delay slot, but we've got a long branch.  */\n+      return \"add%I1 %1,%0,%0\\n\\tbl %3,0\";\n+    }\n+}\n+\n+/* Return nonzero if INSN represents an integer add which might be\n+   combinable with an unconditional branch.  */ \n+\n+combinable_add (insn)\n+     rtx insn;\n+{\n+  rtx src, dest, prev, pattern = PATTERN (insn);\n+\n+  /* Must be a (set (reg) (plus (reg) (reg/5_bit_int)))  */\n+  if (GET_CODE (pattern) != SET\n+      || GET_CODE (SET_SRC (pattern)) != PLUS\n+      || GET_CODE (SET_DEST (pattern)) != REG)\n+    return 0;\n+\n+  src = SET_SRC (pattern);\n+  dest = SET_DEST (pattern);\n+\n+  /* Must be an integer add.  */\n+  if (GET_MODE (src) != SImode\n+      || GET_MODE (dest) != SImode)\n+    return 0;\n+\n+  /* Each operand must be an integer register and/or 5 bit immediate.  */\n+  if (!ireg_or_int5_operand (dest, VOIDmode)\n+       || !ireg_or_int5_operand (XEXP (src, 0), VOIDmode)\n+       || !ireg_or_int5_operand (XEXP (src, 1), VOIDmode))\n+    return 0;\n+\n+  /* The destination must also be one of the sources.  */\n+  return (dest == XEXP (src, 0) || dest == XEXP (src, 1));\n+}\n+\n+/* Return nonzero if INSN represents an integer load/copy which might be\n+   combinable with an unconditional branch.  */ \n+\n+combinable_copy (insn)\n+     rtx insn;\n+{\n+  rtx src, dest, pattern = PATTERN (insn);\n+  enum machine_mode mode;\n+\n+  /* Must be a (set (reg) (reg/5_bit_int)).  */\n+  if (GET_CODE (pattern) != SET)\n+    return 0;\n+\n+  src = SET_SRC (pattern);\n+  dest = SET_DEST (pattern);\n+\n+  /* Must be a mode that corresponds to a single integer register.  */\n+  mode = GET_MODE (dest);\n+  if (mode != SImode\n+      && mode != SFmode\n+      && mode != HImode\n+      && mode != QImode)\n+    return 0;\n+\n+  /* Each operand must be a register or 5 bit integer.  */\n+  if (!ireg_or_int5_operand (dest, VOIDmode)\n+      || !ireg_or_int5_operand (src, VOIDmode))\n+    return 0;\n+\n+  return 1;\n+}\n+\n+/* Return nonzero if INSN (a jump insn) immediately follows a call.  This\n+   is used to discourage creating parallel movb/addb insns since a jump\n+   which immediately follows a call can execute in the delay slot of the\n+   call.  */\n+   \n+following_call (insn)\n+     rtx insn;\n+{\n+  /* Find the previous real insn, skipping NOTEs.  */\n+  insn = PREV_INSN (insn);\n+  while (insn && GET_CODE (insn) == NOTE)\n+    insn = PREV_INSN (insn);\n+\n+  /* Check for CALL_INSNs and millicode calls.  */\n+  if (insn\n+      && (GET_CODE (insn) == CALL_INSN\n+\t  || (GET_CODE (insn) == INSN\n+\t      && GET_CODE (PATTERN (insn)) != SEQUENCE\n+\t      && GET_CODE (PATTERN (insn)) != USE\n+\t      && GET_CODE (PATTERN (insn)) != CLOBBER\n+\t      && get_attr_type (insn) == TYPE_MILLI)))\n+    return 1;\n+\n+  return 0;\n+}\n+\n \n /* We use this hook to perform a PA specific optimization which is difficult\n    to do in earlier passes."}, {"sha": "a6e9f869d04f839c2386c4b0690aff9fca7f78fb", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1092901380ec5872a5122837ea72da9d2f6169b/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1092901380ec5872a5122837ea72da9d2f6169b/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=b1092901380ec5872a5122837ea72da9d2f6169b", "patch": "@@ -2280,6 +2280,8 @@ extern char *output_bb ();\n extern char *output_bvb ();\n extern char *output_dbra ();\n extern char *output_movb ();\n+extern char *output_parallel_movb ();\n+extern char *output_parallel_addb ();\n extern char *output_return ();\n extern char *output_call ();\n extern char *output_millicode_call ();"}, {"sha": "6c10b2474642087ed4e90789dde14930ba44c497", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 17, "deletions": 29, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1092901380ec5872a5122837ea72da9d2f6169b/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1092901380ec5872a5122837ea72da9d2f6169b/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=b1092901380ec5872a5122837ea72da9d2f6169b", "patch": "@@ -31,7 +31,7 @@\n ;; type \"binary\" insns have two input operands (1,2) and one output (0)\n \n (define_attr \"type\"\n-  \"move,unary,binary,shift,nullshift,compare,load,store,uncond_branch,branch,cbranch,fbranch,call,dyncall,fpload,fpstore,fpalu,fpcc,fpmulsgl,fpmuldbl,fpdivsgl,fpdivdbl,fpsqrtsgl,fpsqrtdbl,multi,milli\"\n+  \"move,unary,binary,shift,nullshift,compare,load,store,uncond_branch,branch,cbranch,fbranch,call,dyncall,fpload,fpstore,fpalu,fpcc,fpmulsgl,fpmuldbl,fpdivsgl,fpdivdbl,fpsqrtsgl,fpsqrtdbl,multi,milli,parallel_branch\"\n   (const_string \"binary\"))\n \n ;; Processor type (for scheduling, not code generation) -- this attribute\n@@ -69,23 +69,23 @@\n \n ;; For conditional branches.\n (define_attr \"in_branch_delay\" \"false,true\"\n-  (if_then_else (and (eq_attr \"type\" \"!uncond_branch,branch,cbranch,fbranch,call,dyncall,multi,milli\")\n+  (if_then_else (and (eq_attr \"type\" \"!uncond_branch,branch,cbranch,fbranch,call,dyncall,multi,milli,parallel_branch\")\n \t\t     (eq_attr \"length\" \"4\"))\n \t\t(const_string \"true\")\n \t\t(const_string \"false\")))\n \n ;; Disallow instructions which use the FPU since they will tie up the FPU\n ;; even if the instruction is nullified.\n (define_attr \"in_nullified_branch_delay\" \"false,true\"\n-  (if_then_else (and (eq_attr \"type\" \"!uncond_branch,branch,cbranch,fbranch,call,dyncall,multi,milli,fpcc,fpalu,fpmulsgl,fpmuldbl,fpdivsgl,fpdivdbl,fpsqrtsgl,fpsqrtdbl\")\n+  (if_then_else (and (eq_attr \"type\" \"!uncond_branch,branch,cbranch,fbranch,call,dyncall,multi,milli,fpcc,fpalu,fpmulsgl,fpmuldbl,fpdivsgl,fpdivdbl,fpsqrtsgl,fpsqrtdbl,parallel_branch\")\n \t\t     (eq_attr \"length\" \"4\"))\n \t\t(const_string \"true\")\n \t\t(const_string \"false\")))\n \n ;; For calls and millicode calls.  Allow unconditional branches in the\n ;; delay slot.\n (define_attr \"in_call_delay\" \"false,true\"\n-  (cond [(and (eq_attr \"type\" \"!uncond_branch,branch,cbranch,fbranch,call,dyncall,multi,milli\")\n+  (cond [(and (eq_attr \"type\" \"!uncond_branch,branch,cbranch,fbranch,call,dyncall,multi,milli,parallel_branch\")\n \t      (eq_attr \"length\" \"4\"))\n \t   (const_string \"true\")\n \t (eq_attr \"type\" \"uncond_branch\")\n@@ -96,19 +96,19 @@\n \t(const_string \"false\")))\n \n \n-;; Unconditional branch and call delay slot description.\n-(define_delay (eq_attr \"type\" \"uncond_branch,branch,call\")\n+;; Call delay slot description.\n+(define_delay (eq_attr \"type\" \"uncond_branch,call\")\n   [(eq_attr \"in_call_delay\" \"true\") (nil) (nil)])\n \n ;; millicode call delay slot description.  Note it disallows delay slot\n-;; when TARGET_PORTABLE_RUNTIME.\n+;; when TARGET_PORTABLE_RUNTIME is true.\n (define_delay (eq_attr \"type\" \"milli\")\n   [(and (eq_attr \"in_call_delay\" \"true\")\n \t(eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0)))\n    (nil) (nil)])\n \n-;; Unconditional branch, return and other similar instructions.\n-(define_delay (eq_attr \"type\" \"uncond_branch,branch\")\n+;; Return and other similar instructions.\n+(define_delay (eq_attr \"type\" \"branch,parallel_branch\")\n   [(eq_attr \"in_branch_delay\" \"true\") (nil) (nil)])\n \n ;; Floating point conditional branch delay slot description and\n@@ -4878,15 +4878,15 @@\n   [(set (pc)\n \t(if_then_else\n \t  (match_operator 2 \"movb_comparison_operator\"\n-\t   [(match_operand:SI 1 \"register_operand\" \"r,r,r\") (const_int 0)])\n+\t   [(match_operand:SI 1 \"register_operand\" \"r,r,r,r\") (const_int 0)])\n \t  (label_ref (match_operand 3 \"\" \"\"))\n \t  (pc)))\n-   (set (match_operand:SI 0 \"register_operand\" \"=!r,!*f,!*m\")\n+   (set (match_operand:SI 0 \"register_operand\" \"=!r,!*f,!*m,!*q\")\n \t(match_dup 1))]\n   \"\"\n \"* return output_movb (operands, insn, which_alternative, 0); \"\n ;; Do not expect to understand this the first time through.\n-[(set_attr \"type\" \"cbranch,multi,multi\")\n+[(set_attr \"type\" \"cbranch,multi,multi,multi\")\n  (set (attr \"length\")\n       (if_then_else (eq_attr \"alternative\" \"0\")\n ;; Loop counter in register case\n@@ -4911,7 +4911,7 @@\n \t\t  (const_int 8184))\n \t      (const_int 12)\n \t      (const_int 16)))\n-;; Loop counter in memory case.\n+;; Loop counter in memory or sar case.\n ;; Extra goo to deal with additional reload insns.\n \t(if_then_else\n \t  (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n@@ -4924,15 +4924,15 @@\n   [(set (pc)\n \t(if_then_else\n \t  (match_operator 2 \"movb_comparison_operator\"\n-\t   [(match_operand:SI 1 \"register_operand\" \"r,r,r\") (const_int 0)])\n+\t   [(match_operand:SI 1 \"register_operand\" \"r,r,r,r\") (const_int 0)])\n \t  (pc)\n \t  (label_ref (match_operand 3 \"\" \"\"))))\n-   (set (match_operand:SI 0 \"register_operand\" \"=!r,!*f,!*m\")\n+   (set (match_operand:SI 0 \"register_operand\" \"=!r,!*f,!*m,!*q\")\n \t(match_dup 1))]\n   \"\"\n \"* return output_movb (operands, insn, which_alternative, 1); \"\n ;; Do not expect to understand this the first time through.\n-[(set_attr \"type\" \"cbranch,multi,multi\")\n+[(set_attr \"type\" \"cbranch,multi,multi,multi\")\n  (set (attr \"length\")\n       (if_then_else (eq_attr \"alternative\" \"0\")\n ;; Loop counter in register case\n@@ -4957,7 +4957,7 @@\n \t\t  (const_int 8184))\n \t      (const_int 12)\n \t      (const_int 16)))\n-;; Loop counter in memory case.\n+;; Loop counter in memory or SAR case.\n ;; Extra goo to deal with additional reload insns.\n \t(if_then_else\n \t  (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n@@ -5262,18 +5262,6 @@\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"8\")])\n \n-\n-;; XXX FIXME.  The function pointer comparison code is only at the FSF\n-;; for documentation and merging purposes, it is _NOT_ actually used.\n-;;\n-;; I've been trying to get Kenner to deal with the machine independent\n-;; problems for many months, and for whatever reason nothing ever seems\n-;; to happen.\n-;;\n-;; If you want function pointer comparisons to work, first scream at\n-;; Kenner to deal with the MI problems, then email me for a hack that\n-;; will get the job done (law@cygnus.com).\n-\n ;; Given a function pointer, canonicalize it so it can be \n ;; reliably compared to another function pointer.  */\n (define_expand \"canonicalize_funcptr_for_compare\""}]}