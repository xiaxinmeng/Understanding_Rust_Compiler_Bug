{"sha": "16707e90f935452e4ce65e04e0a2047b6b083eb3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTY3MDdlOTBmOTM1NDUyZTRjZTY1ZTA0ZTBhMjA0N2I2YjA4M2ViMw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-11T08:05:43Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-11T08:05:43Z"}, "message": "New files, to ease sync between AdaCore and FSF.\n\nFrom-SVN: r251958", "tree": {"sha": "73c16be4b56b2b6732dce4e6b933b55576cbf5b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73c16be4b56b2b6732dce4e6b933b55576cbf5b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16707e90f935452e4ce65e04e0a2047b6b083eb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16707e90f935452e4ce65e04e0a2047b6b083eb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16707e90f935452e4ce65e04e0a2047b6b083eb3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16707e90f935452e4ce65e04e0a2047b6b083eb3/comments", "author": null, "committer": null, "parents": [{"sha": "b123dccb013fa6a79a621b9895349a3e1290aabd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b123dccb013fa6a79a621b9895349a3e1290aabd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b123dccb013fa6a79a621b9895349a3e1290aabd"}], "stats": {"total": 1383, "additions": 1383, "deletions": 0}, "files": [{"sha": "813a0966802332e29bb2c7699c27396e3d11a7d4", "filename": "gcc/ada/libgnarl/a-intnam-lynxos.ads", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16707e90f935452e4ce65e04e0a2047b6b083eb3/gcc%2Fada%2Flibgnarl%2Fa-intnam-lynxos.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16707e90f935452e4ce65e04e0a2047b6b083eb3/gcc%2Fada%2Flibgnarl%2Fa-intnam-lynxos.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fa-intnam-lynxos.ads?ref=16707e90f935452e4ce65e04e0a2047b6b083eb3", "patch": "@@ -0,0 +1,166 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n+--                                                                          --\n+--                   A D A . I N T E R R U P T S . N A M E S                --\n+--                                                                          --\n+--                                  S p e c                                 --\n+--                                                                          --\n+--          Copyright (C) 1991-2017, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a LynxOS version of this package\n+\n+--  The following signals are reserved by the run time:\n+\n+--  SIGFPE, SIGILL, SIGSEGV, SIGBUS, SIGTRAP, SIGABRT, SIGINT,\n+--  SIGWAITING, SIGLWP, SIGTTIN, SIGTTOU, SIGTSTP, SIGPROF, SIGSTOP, SIGKILL\n+\n+--  The pragma Unreserve_All_Interrupts affects the following signal(s):\n+\n+--  SIGINT: made available for Ada handler\n+\n+with System.OS_Interface;\n+\n+package Ada.Interrupts.Names is\n+\n+   --  All identifiers in this unit are implementation defined\n+\n+   pragma Implementation_Defined;\n+\n+   --  Beware that the mapping of names to signals may be many-to-one. There\n+   --  may be aliases.\n+\n+   SIGHUP : constant Interrupt_ID :=\n+     System.OS_Interface.SIGHUP;      --  hangup\n+\n+   SIGINT : constant Interrupt_ID :=\n+     System.OS_Interface.SIGINT;      --  interrupt (rubout)\n+\n+   SIGQUIT : constant Interrupt_ID :=\n+     System.OS_Interface.SIGQUIT;     --  quit (ASCD FS)\n+\n+   SIGILL : constant Interrupt_ID :=\n+     System.OS_Interface.SIGILL;      --  illegal instruction (not reset)\n+\n+   SIGTRAP : constant Interrupt_ID :=\n+     System.OS_Interface.SIGTRAP;     --  trace trap (not reset)\n+\n+   SIGBRK : constant Interrupt_ID :=\n+     System.OS_Interface.SIGBRK;      --  break\n+\n+   SIGIOT : constant Interrupt_ID :=\n+     System.OS_Interface.SIGIOT;      --  IOT instruction\n+\n+   SIGABRT : constant Interrupt_ID := --  used by abort,\n+     System.OS_Interface.SIGABRT;     --  replace SIGIOT in the  future\n+\n+   SIGCORE : constant Interrupt_ID :=\n+     System.OS_Interface.SIGCORE;     --  kill with core dump\n+\n+   SIGEMT : constant Interrupt_ID :=\n+     System.OS_Interface.SIGEMT;      --  EMT instruction\n+\n+   SIGFPE : constant Interrupt_ID :=\n+     System.OS_Interface.SIGFPE;      --  floating point exception\n+\n+   SIGKILL : constant Interrupt_ID :=\n+     System.OS_Interface.SIGKILL;     --  kill (cannot be caught or ignored)\n+\n+   SIGBUS : constant Interrupt_ID :=\n+     System.OS_Interface.SIGBUS;      --  bus error\n+\n+   SIGSEGV : constant Interrupt_ID :=\n+     System.OS_Interface.SIGSEGV;     --  segmentation violation\n+\n+   SIGSYS : constant Interrupt_ID :=\n+     System.OS_Interface.SIGSYS;      --  bad argument to system call\n+\n+   SIGPIPE : constant Interrupt_ID := --  write on a pipe with\n+     System.OS_Interface.SIGPIPE;     --  no one to read it\n+\n+   SIGALRM : constant Interrupt_ID :=\n+     System.OS_Interface.SIGALRM;     --  alarm clock\n+\n+   SIGTERM : constant Interrupt_ID :=\n+     System.OS_Interface.SIGTERM;     --  software termination signal from kill\n+\n+   SIGURG : constant Interrupt_ID :=\n+     System.OS_Interface.SIGURG;      --  urgent condition on IO channel\n+\n+   SIGSTOP : constant Interrupt_ID :=\n+     System.OS_Interface.SIGSTOP;     --  stop (cannot be caught or ignored)\n+\n+   SIGTSTP : constant Interrupt_ID :=\n+     System.OS_Interface.SIGTSTP;     --  user stop requested from tty\n+\n+   SIGCONT : constant Interrupt_ID :=\n+     System.OS_Interface.SIGCONT;     --  stopped process has been continued\n+\n+   SIGCLD : constant Interrupt_ID :=\n+     System.OS_Interface.SIGCLD;      --  child status change\n+\n+   SIGCHLD : constant Interrupt_ID :=\n+     System.OS_Interface.SIGCHLD;     --  4.3BSD's/POSIX name for SIGCLD\n+\n+   SIGTTIN : constant Interrupt_ID :=\n+     System.OS_Interface.SIGTTIN;     --  background tty read attempted\n+\n+   SIGTTOU : constant Interrupt_ID :=\n+     System.OS_Interface.SIGTTOU;     --  background tty write attempted\n+\n+   SIGPOLL : constant Interrupt_ID :=\n+     System.OS_Interface.SIGPOLL;     --  pollable event occurred\n+\n+   SIGIO : constant Interrupt_ID :=   --  input/output possible,\n+     System.OS_Interface.SIGIO;       --  SIGPOLL alias (Solaris)\n+\n+   SIGXCPU : constant Interrupt_ID :=\n+     System.OS_Interface.SIGXCPU;     --  CPU time limit exceeded\n+\n+   SIGXFSZ : constant Interrupt_ID :=\n+     System.OS_Interface.SIGXFSZ;     --  filesize limit exceeded\n+\n+   SIGVTALRM : constant Interrupt_ID :=\n+     System.OS_Interface.SIGVTALRM;   --  virtual timer expired\n+\n+   SIGPROF : constant Interrupt_ID :=\n+     System.OS_Interface.SIGPROF;     --  profiling timer expired\n+\n+   SIGWINCH : constant Interrupt_ID :=\n+     System.OS_Interface.SIGWINCH;    --  window size change\n+\n+   SIGLOST : constant Interrupt_ID :=\n+     System.OS_Interface.SIGLOST;     --  SUN 4.1 compatibility\n+\n+   SIGUSR1 : constant Interrupt_ID :=\n+     System.OS_Interface.SIGUSR1;     --  user defined signal 1\n+\n+   SIGUSR2 : constant Interrupt_ID :=\n+     System.OS_Interface.SIGUSR2;     --  user defined signal 2\n+\n+   SIGPRIO : constant Interrupt_ID :=\n+     System.OS_Interface.SIGPRIO;\n+   --  sent to a process with its priority\n+   --  or group is changed\n+end Ada.Interrupts.Names;"}, {"sha": "9048e49c59b48dde849b555a181616c4e85d7492", "filename": "gcc/ada/libgnarl/s-intman-lynxos.adb", "status": "added", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16707e90f935452e4ce65e04e0a2047b6b083eb3/gcc%2Fada%2Flibgnarl%2Fs-intman-lynxos.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16707e90f935452e4ce65e04e0a2047b6b083eb3/gcc%2Fada%2Flibgnarl%2Fs-intman-lynxos.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-intman-lynxos.adb?ref=16707e90f935452e4ce65e04e0a2047b6b083eb3", "patch": "@@ -0,0 +1,292 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n+--                                                                          --\n+--           S Y S T E M . I N T E R R U P T _ M A N A G E M E N T          --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the LynxOS version of this package\n+\n+--  Make a careful study of all signals available under the OS, to see which\n+--  need to be reserved, kept always unmasked, or kept always unmasked. Be on\n+--  the lookout for special signals that may be used by the thread library.\n+\n+--  Since this is a multi target file, the signal <-> exception mapping\n+--  is simple minded. If you need a more precise and target specific\n+--  signal handling, create a new s-intman.adb that will fit your needs.\n+\n+--  This file assumes that:\n+\n+--    SIGFPE, SIGILL, SIGSEGV and SIGBUS exist. They are mapped as follows:\n+--      SIGPFE  => Constraint_Error\n+--      SIGILL  => Program_Error\n+--      SIGSEGV => Storage_Error\n+--      SIGBUS  => Storage_Error\n+\n+--    SIGINT exists and will be kept unmasked unless the pragma\n+--     Unreserve_All_Interrupts is specified anywhere in the application.\n+\n+--    System.OS_Interface contains the following:\n+--      SIGADAABORT: the signal that will be used to abort tasks.\n+--      Unmasked: the OS specific set of signals that should be unmasked in\n+--                all the threads. SIGADAABORT is unmasked by\n+--                default\n+--      Reserved: the OS specific set of signals that are reserved.\n+\n+with System.Task_Primitives;\n+\n+package body System.Interrupt_Management is\n+\n+   use Interfaces.C;\n+   use System.OS_Interface;\n+\n+   type Interrupt_List is array (Interrupt_ID range <>) of Interrupt_ID;\n+   Exception_Interrupts : constant Interrupt_List :=\n+     (SIGFPE, SIGILL, SIGSEGV, SIGBUS);\n+\n+   Unreserve_All_Interrupts : Interfaces.C.int;\n+   pragma Import\n+     (C, Unreserve_All_Interrupts, \"__gl_unreserve_all_interrupts\");\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function State (Int : Interrupt_ID) return Character;\n+   pragma Import (C, State, \"__gnat_get_interrupt_state\");\n+   --  Get interrupt state. Defined in init.c The input argument is the\n+   --  interrupt number, and the result is one of the following:\n+\n+   User    : constant Character := 'u';\n+   Runtime : constant Character := 'r';\n+   Default : constant Character := 's';\n+   --    'n'   this interrupt not set by any Interrupt_State pragma\n+   --    'u'   Interrupt_State pragma set state to User\n+   --    'r'   Interrupt_State pragma set state to Runtime\n+   --    's'   Interrupt_State pragma set state to System (use \"default\"\n+   --           system handler)\n+\n+   procedure Notify_Exception\n+     (signo    : Signal;\n+      siginfo  : System.Address;\n+      ucontext : System.Address);\n+   --  This function identifies the Ada exception to be raised using the\n+   --  information when the system received a synchronous signal. Since this\n+   --  function is machine and OS dependent, different code has to be provided\n+   --  for different target.\n+\n+   ----------------------\n+   -- Notify_Exception --\n+   ----------------------\n+\n+   Signal_Mask : aliased sigset_t;\n+   --  The set of signals handled by Notify_Exception\n+\n+   procedure Notify_Exception\n+     (signo    : Signal;\n+      siginfo  : System.Address;\n+      ucontext : System.Address)\n+   is\n+      pragma Unreferenced (siginfo);\n+\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      --  With the __builtin_longjmp, the signal mask is not restored, so we\n+      --  need to restore it explicitly.\n+\n+      Result := pthread_sigmask (SIG_UNBLOCK, Signal_Mask'Access, null);\n+      pragma Assert (Result = 0);\n+\n+      --  Perform the necessary context adjustments prior to a raise\n+      --  from a signal handler.\n+\n+      Adjust_Context_For_Raise (signo, ucontext);\n+\n+      --  Check that treatment of exception propagation here is consistent with\n+      --  treatment of the abort signal in System.Task_Primitives.Operations.\n+\n+      case signo is\n+         when SIGFPE  => raise Constraint_Error;\n+         when SIGILL  => raise Program_Error;\n+         when SIGSEGV => raise Storage_Error;\n+         when SIGBUS  => raise Storage_Error;\n+         when others  => null;\n+      end case;\n+   end Notify_Exception;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   Initialized : Boolean := False;\n+\n+   procedure Initialize is\n+      act     : aliased struct_sigaction;\n+      old_act : aliased struct_sigaction;\n+      Result  : System.OS_Interface.int;\n+\n+      Use_Alternate_Stack : constant Boolean :=\n+                              System.Task_Primitives.Alternate_Stack_Size /= 0;\n+      --  Whether to use an alternate signal stack for stack overflows\n+\n+   begin\n+      if Initialized then\n+         return;\n+      end if;\n+\n+      Initialized := True;\n+\n+      --  Need to call pthread_init very early because it is doing signal\n+      --  initializations.\n+\n+      pthread_init;\n+\n+      Abort_Task_Interrupt := SIGADAABORT;\n+\n+      act.sa_handler := Notify_Exception'Address;\n+\n+      --  Setting SA_SIGINFO asks the kernel to pass more than just the signal\n+      --  number argument to the handler when it is called. The set of extra\n+      --  parameters includes a pointer to the interrupted context, which the\n+      --  ZCX propagation scheme needs.\n+\n+      --  Most man pages for sigaction mention that sa_sigaction should be set\n+      --  instead of sa_handler when SA_SIGINFO is on.  In practice, the two\n+      --  fields are actually union'ed and located at the same offset.\n+\n+      --  On some targets, we set sa_flags to SA_NODEFER so that during the\n+      --  handler execution we do not change the Signal_Mask to be masked for\n+      --  the Signal.\n+\n+      --  This is a temporary fix to the problem that the Signal_Mask is not\n+      --  restored after the exception (longjmp) from the handler. The right\n+      --  fix should be made in sigsetjmp so that we save the Signal_Set and\n+      --  restore it after a longjmp.\n+\n+      --  Since SA_NODEFER is obsolete, instead we reset explicitly the mask\n+      --  in the exception handler.\n+\n+      Result := sigemptyset (Signal_Mask'Access);\n+      pragma Assert (Result = 0);\n+\n+      --  Add signals that map to Ada exceptions to the mask\n+\n+      for J in Exception_Interrupts'Range loop\n+         if State (Exception_Interrupts (J)) /= Default then\n+            Result :=\n+            sigaddset (Signal_Mask'Access, Signal (Exception_Interrupts (J)));\n+            pragma Assert (Result = 0);\n+         end if;\n+      end loop;\n+\n+      act.sa_mask := Signal_Mask;\n+\n+      pragma Assert (Keep_Unmasked = (Interrupt_ID'Range => False));\n+      pragma Assert (Reserve = (Interrupt_ID'Range => False));\n+\n+      --  Process state of exception signals\n+\n+      for J in Exception_Interrupts'Range loop\n+         if State (Exception_Interrupts (J)) /= User then\n+            Keep_Unmasked (Exception_Interrupts (J)) := True;\n+            Reserve (Exception_Interrupts (J)) := True;\n+\n+            if State (Exception_Interrupts (J)) /= Default then\n+               --  This file is identical to s-intman-posix.adb, except that we\n+               --  don't set the SA_SIGINFO flag in act.sa_flags, because\n+               --  LynxOS does not support that. If SA_SIGINFO is set, then\n+               --  sigaction fails, returning -1.\n+               act.sa_flags := 0;\n+\n+               if Use_Alternate_Stack\n+                 and then Exception_Interrupts (J) = SIGSEGV\n+               then\n+                  act.sa_flags := act.sa_flags + SA_ONSTACK;\n+               end if;\n+\n+               Result :=\n+                 sigaction\n+                   (Signal (Exception_Interrupts (J)), act'Unchecked_Access,\n+                    old_act'Unchecked_Access);\n+               pragma Assert (Result = 0);\n+            end if;\n+         end if;\n+      end loop;\n+\n+      if State (Abort_Task_Interrupt) /= User then\n+         Keep_Unmasked (Abort_Task_Interrupt) := True;\n+         Reserve (Abort_Task_Interrupt) := True;\n+      end if;\n+\n+      --  Set SIGINT to unmasked state as long as it is not in \"User\" state.\n+      --  Check for Unreserve_All_Interrupts last.\n+\n+      if State (SIGINT) /= User then\n+         Keep_Unmasked (SIGINT) := True;\n+         Reserve (SIGINT) := True;\n+      end if;\n+\n+      --  Check all signals for state that requires keeping them unmasked and\n+      --  reserved.\n+\n+      for J in Interrupt_ID'Range loop\n+         if State (J) = Default or else State (J) = Runtime then\n+            Keep_Unmasked (J) := True;\n+            Reserve (J) := True;\n+         end if;\n+      end loop;\n+\n+      --  Add the set of signals that must always be unmasked for this target\n+\n+      for J in Unmasked'Range loop\n+         Keep_Unmasked (Interrupt_ID (Unmasked (J))) := True;\n+         Reserve (Interrupt_ID (Unmasked (J))) := True;\n+      end loop;\n+\n+      --  Add target-specific reserved signals\n+\n+      for J in Reserved'Range loop\n+         Reserve (Interrupt_ID (Reserved (J))) := True;\n+      end loop;\n+\n+      --  Process pragma Unreserve_All_Interrupts. This overrides any settings\n+      --  due to pragma Interrupt_State:\n+\n+      if Unreserve_All_Interrupts /= 0 then\n+         Keep_Unmasked (SIGINT) := False;\n+         Reserve (SIGINT) := False;\n+      end if;\n+\n+      --  We do not really have Signal 0. We just use this value to identify\n+      --  non-existent signals (see s-intnam.ads). Therefore, Signal should not\n+      --  be used in all signal related operations hence mark it as reserved.\n+\n+      Reserve (0) := True;\n+   end Initialize;\n+\n+end System.Interrupt_Management;"}, {"sha": "50e93538af08495411cab2d452bd052772b618c2", "filename": "gcc/ada/libgnarl/s-osinte-lynxos178.adb", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16707e90f935452e4ce65e04e0a2047b6b083eb3/gcc%2Fada%2Flibgnarl%2Fs-osinte-lynxos178.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16707e90f935452e4ce65e04e0a2047b6b083eb3/gcc%2Fada%2Flibgnarl%2Fs-osinte-lynxos178.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-osinte-lynxos178.adb?ref=16707e90f935452e4ce65e04e0a2047b6b083eb3", "patch": "@@ -0,0 +1,180 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n+--                                                                          --\n+--                   S Y S T E M . O S _ I N T E R F A C E                  --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--                     Copyright (C) 2001-2017, AdaCore                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Version of System.OS_Interface for LynxOS-178 (POSIX Threads)\n+\n+pragma Polling (Off);\n+--  Turn off polling, we do not want ATC polling to take place during tasking\n+--  operations. It may cause infinite loops and other problems.\n+\n+package body System.OS_Interface is\n+\n+   use Interfaces.C;\n+\n+   ------------------\n+   --  Current_CPU --\n+   ------------------\n+\n+   function Current_CPU return Multiprocessors.CPU is\n+   begin\n+      --  No multiprocessor support, always return the first CPU Id\n+\n+      return Multiprocessors.CPU'First;\n+   end Current_CPU;\n+\n+   --------------------\n+   --  Get_Affinity  --\n+   --------------------\n+\n+   function Get_Affinity (Id : Thread_Id) return Multiprocessors.CPU_Range is\n+      pragma Unreferenced (Id);\n+\n+   begin\n+      --  No multiprocessor support, always return Not_A_Specific_CPU\n+\n+      return Multiprocessors.Not_A_Specific_CPU;\n+   end Get_Affinity;\n+\n+   ---------------\n+   --  Get_CPU  --\n+   ---------------\n+\n+   function Get_CPU  (Id : Thread_Id) return Multiprocessors.CPU is\n+      pragma Unreferenced (Id);\n+\n+   begin\n+      --  No multiprocessor support, always return the first CPU Id\n+\n+      return Multiprocessors.CPU'First;\n+   end Get_CPU;\n+\n+   -------------------\n+   -- Get_Page_Size --\n+   -------------------\n+\n+   SC_PAGESIZE : constant := 17;\n+   --  C macro to get pagesize value from sysconf\n+\n+   function sysconf (name : int) return long;\n+   pragma Import (C, sysconf, \"sysconf\");\n+\n+   function Get_Page_Size return int is\n+   begin\n+      return int (sysconf (SC_PAGESIZE));\n+   end Get_Page_Size;\n+\n+   -----------------\n+   -- To_Duration --\n+   -----------------\n+\n+   function To_Duration (TS : timespec) return Duration is\n+   begin\n+      return Duration (TS.tv_sec) + Duration (TS.tv_nsec) / 10#1#E9;\n+   end To_Duration;\n+\n+   ------------------------\n+   -- To_Target_Priority --\n+   ------------------------\n+\n+   function To_Target_Priority\n+     (Prio : System.Any_Priority) return Interfaces.C.int\n+   is\n+   begin\n+      return Interfaces.C.int (Prio);\n+   end To_Target_Priority;\n+\n+   -----------------\n+   -- To_Timespec --\n+   -----------------\n+\n+   function To_Timespec (D : Duration) return timespec is\n+      S : time_t;\n+      F : Duration;\n+\n+   begin\n+      S := time_t (Long_Long_Integer (D));\n+      F := D - Duration (S);\n+\n+      --  If F is negative due to a round-up, adjust for positive F value\n+\n+      if F < 0.0 then\n+         S := S - 1;\n+         F := F + 1.0;\n+      end if;\n+\n+      return timespec'(tv_sec => S,\n+                       tv_nsec => long (Long_Long_Integer (F * 10#1#E9)));\n+   end To_Timespec;\n+\n+   -------------\n+   -- sigwait --\n+   -------------\n+\n+   function sigwait\n+     (set :  access sigset_t;\n+      sig :  access Signal)\n+      return int\n+   is\n+      function sigwaitinfo\n+        (set   : access sigset_t;\n+         info  : System.Address) return Signal;\n+      pragma Import (C, sigwaitinfo, \"sigwaitinfo\");\n+\n+   begin\n+      sig.all := sigwaitinfo (set, Null_Address);\n+\n+      if sig.all = -1 then\n+         return errno;\n+      end if;\n+\n+      return 0;\n+   end sigwait;\n+\n+   --------------------\n+   -- Get_Stack_Base --\n+   --------------------\n+\n+   function Get_Stack_Base (thread : pthread_t) return Address is\n+      pragma Warnings (Off, thread);\n+   begin\n+      return Null_Address;\n+   end Get_Stack_Base;\n+\n+   ------------------\n+   -- pthread_init --\n+   ------------------\n+\n+   procedure pthread_init is\n+   begin\n+      null;\n+   end pthread_init;\n+\n+end System.OS_Interface;"}, {"sha": "5eda0721c4e79ed97d3d5107349d4174369dc4ca", "filename": "gcc/ada/libgnarl/s-osinte-lynxos178e.ads", "status": "added", "additions": 627, "deletions": 0, "changes": 627, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16707e90f935452e4ce65e04e0a2047b6b083eb3/gcc%2Fada%2Flibgnarl%2Fs-osinte-lynxos178e.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16707e90f935452e4ce65e04e0a2047b6b083eb3/gcc%2Fada%2Flibgnarl%2Fs-osinte-lynxos178e.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-osinte-lynxos178e.ads?ref=16707e90f935452e4ce65e04e0a2047b6b083eb3", "patch": "@@ -0,0 +1,627 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n+--                                                                          --\n+--                   S Y S T E M . O S _ I N T E R F A C E                  --\n+--                                                                          --\n+--                                  S p e c                                 --\n+--                                                                          --\n+--             Copyright (C) 1991-1994, Florida State University            --\n+--          Copyright (C) 1995-2017, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a LynxOS-178 Elf (POSIX-8 Threads) version of this package\n+\n+--  This package encapsulates all direct interfaces to OS services that are\n+--  needed by the tasking run-time (libgnarl).\n+\n+--  PLEASE DO NOT add any with-clauses to this package or remove the pragma\n+--  Preelaborate. This package is designed to be a bottom-level (leaf) package.\n+\n+with Ada.Unchecked_Conversion;\n+\n+with Interfaces.C;\n+\n+with System.Multiprocessors;\n+\n+package System.OS_Interface is\n+   pragma Preelaborate;\n+\n+   pragma Linker_Options (\"-mthreads\");\n+   --  Selects the POSIX 1.c runtime, rather than the non-threading runtime or\n+   --  the deprecated legacy threads library.\n+\n+   subtype int            is Interfaces.C.int;\n+   subtype short          is Interfaces.C.short;\n+   subtype long           is Interfaces.C.long;\n+   subtype unsigned       is Interfaces.C.unsigned;\n+   subtype unsigned_short is Interfaces.C.unsigned_short;\n+   subtype unsigned_long  is Interfaces.C.unsigned_long;\n+   subtype unsigned_char  is Interfaces.C.unsigned_char;\n+   subtype plain_char     is Interfaces.C.plain_char;\n+   subtype size_t         is Interfaces.C.size_t;\n+   subtype int64          is Interfaces.Integer_64;\n+\n+   -----------\n+   -- Errno --\n+   -----------\n+\n+   function errno return int;\n+   pragma Import (C, errno, \"__get_errno\");\n+\n+   EAGAIN    : constant := 11;\n+   EINTR     : constant := 4;\n+   EINVAL    : constant := 22;\n+   ENOMEM    : constant := 12;\n+   ETIMEDOUT : constant := 60;\n+   --  Error codes\n+\n+   -------------\n+   -- Signals --\n+   -------------\n+\n+   Max_Interrupt : constant := 63;\n+   --  Max_Interrupt is the number of OS signals, as defined in:\n+   --\n+   --   /usr/include/sys/signal.h\n+   --\n+   --  The lowest numbered signal is 1, but 0 is a valid argument to some\n+   --  library functions, e.g. kill(2). However, 0 is not just another signal:\n+   --  For instance 'I in Signal' and similar should be used with caution.\n+\n+   type Signal is new int range 0 .. Max_Interrupt;\n+   for  Signal'Size use int'Size;\n+\n+   SIGHUP        : constant := 1;  --  hangup\n+   SIGINT        : constant := 2;  --  interrupt (rubout)\n+   SIGQUIT       : constant := 3;  --  quit (ASCD FS)\n+   SIGILL        : constant := 4;  --  illegal instruction (not reset)\n+   SIGTRAP       : constant := 5;  --  trace trap (not reset)\n+   SIGBRK        : constant := 6;  --  break\n+   SIGIOT        : constant := 6;  --  IOT instruction\n+   SIGABRT       : constant := 6;  --  used by abort, replace SIGIOT in future\n+   SIGCORE       : constant := 7;  --  kill with core dump\n+   SIGEMT        : constant := 7;  --  EMT instruction\n+   SIGFPE        : constant := 8;  --  floating point exception\n+   SIGKILL       : constant := 9;  --  kill (cannot be caught or ignored)\n+   SIGBUS        : constant := 10; --  bus error\n+   SIGSEGV       : constant := 11; --  segmentation violation\n+   SIGSYS        : constant := 12; --  bad argument to system call\n+   SIGPIPE       : constant := 13; --  write on a pipe with no one to read it\n+   SIGALRM       : constant := 14; --  alarm clock\n+   SIGTERM       : constant := 15; --  software termination signal from kill\n+   SIGURG        : constant := 16; --  urgent condition on IO channel\n+   SIGSTOP       : constant := 17; --  stop (cannot be caught or ignored)\n+   SIGTSTP       : constant := 18; --  user stop requested from tty\n+   SIGCONT       : constant := 19; --  stopped process has been continued\n+   SIGCLD        : constant := 20; --  alias for SIGCHLD\n+   SIGCHLD       : constant := 20; --  child status change\n+   SIGTTIN       : constant := 21; --  background tty read attempted\n+   SIGTTOU       : constant := 22; --  background tty write attempted\n+   SIGIO         : constant := 23; --  I/O possible (Solaris SIGPOLL alias)\n+   SIGPOLL       : constant := 23; --  pollable event occurred\n+   SIGTHREADKILL : constant := 24; --  Reserved by LynxOS runtime\n+   SIGXCPU       : constant := 24; --  CPU time limit exceeded\n+   SIGXFSZ       : constant := 25; --  filesize limit exceeded\n+   SIGVTALRM     : constant := 26; --  virtual timer expired\n+   SIGPROF       : constant := 27; --  profiling timer expired\n+   SIGWINCH      : constant := 28; --  window size change\n+   SIGLOST       : constant := 29; --  SUN 4.1 compatibility\n+   SIGUSR1       : constant := 30; --  user defined signal 1\n+   SIGUSR2       : constant := 31; --  user defined signal 2\n+\n+   SIGPRIO       : constant := 32;\n+   --  Sent to a process with its priority or group is changed\n+\n+   SIGADAABORT : constant := SIGABRT;\n+   --  Change this if you want to use another signal for task abort. SIGTERM\n+   --  might be a good one.\n+\n+   type Signal_Set is array (Natural range <>) of Signal;\n+\n+   Unmasked    : constant Signal_Set :=\n+     (SIGTRAP, SIGTTIN, SIGTTOU, SIGTSTP, SIGPROF, SIGTHREADKILL);\n+   Reserved    : constant Signal_Set := (SIGABRT, SIGKILL, SIGSTOP, SIGPRIO);\n+\n+   type sigset_t is private;\n+\n+   function sigaddset (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigaddset, \"sigaddset\");\n+\n+   function sigdelset (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigdelset, \"sigdelset\");\n+\n+   function sigfillset (set : access sigset_t) return int;\n+   pragma Import (C, sigfillset, \"sigfillset\");\n+\n+   function sigismember (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigismember, \"sigismember\");\n+\n+   function sigemptyset (set : access sigset_t) return int;\n+   pragma Import (C, sigemptyset, \"sigemptyset\");\n+\n+   type struct_sigaction is record\n+      sa_handler   : System.Address;\n+      sa_mask      : sigset_t;\n+      sa_flags     : int;\n+   end record;\n+   pragma Convention (C, struct_sigaction);\n+   type struct_sigaction_ptr is access all struct_sigaction;\n+\n+   SA_SIGINFO : constant := 16#80#;\n+\n+   SA_ONSTACK : constant := 16#00#;\n+   --  SA_ONSTACK is not defined on LynxOS, but it is referred to in the POSIX\n+   --  implementation of System.Interrupt_Management. Therefore we define a\n+   --  dummy value of zero here so that setting this flag is a nop.\n+\n+   SIG_BLOCK   : constant := 0;\n+   SIG_UNBLOCK : constant := 1;\n+   SIG_SETMASK : constant := 2;\n+\n+   SIG_DFL : constant := 0;\n+   SIG_IGN : constant := 1;\n+\n+   function sigaction\n+     (sig  : Signal;\n+      act  : struct_sigaction_ptr;\n+      oact : struct_sigaction_ptr) return int;\n+   pragma Import (C, sigaction, \"sigaction\");\n+\n+   ----------\n+   -- Time --\n+   ----------\n+\n+   Time_Slice_Supported : constant Boolean := True;\n+   --  Indicates whether time slicing is supported\n+\n+   type timespec is private;\n+\n+   type clockid_t is new int;\n+\n+   function clock_gettime\n+     (clock_id : clockid_t;\n+      tp       : access timespec) return int;\n+   pragma Import (C, clock_gettime, \"clock_gettime\");\n+\n+   function clock_getres\n+     (clock_id : clockid_t;\n+      res      : access timespec) return int;\n+   pragma Import (C, clock_getres, \"clock_getres\");\n+\n+   function To_Duration (TS : timespec) return Duration;\n+   pragma Inline (To_Duration);\n+\n+   function To_Timespec (D : Duration) return timespec;\n+   pragma Inline (To_Timespec);\n+\n+   type struct_timezone is record\n+      tz_minuteswest : int;\n+      tz_dsttime     : int;\n+   end record;\n+   pragma Convention (C, struct_timezone);\n+   type struct_timezone_ptr is access all struct_timezone;\n+\n+   type struct_timeval is private;\n+\n+   -------------------------\n+   -- Priority Scheduling --\n+   -------------------------\n+\n+   SCHED_RR    : constant := 16#100_000#;\n+   SCHED_FIFO  : constant := 16#200_000#;\n+   SCHED_OTHER : constant := 16#400_000#;\n+\n+   function To_Target_Priority\n+     (Prio : System.Any_Priority) return Interfaces.C.int;\n+   --  Maps System.Any_Priority to a POSIX priority\n+\n+   -------------\n+   -- Process --\n+   -------------\n+\n+   type pid_t is private;\n+\n+   function kill (pid : pid_t; sig : Signal) return int;\n+   pragma Import (C, kill, \"kill\");\n+\n+   function getpid return pid_t;\n+   pragma Import (C, getpid, \"getpid\");\n+\n+   ---------\n+   -- LWP --\n+   ---------\n+\n+   type pthread_t is private;\n+\n+   function lwp_self return pthread_t;\n+   pragma Import (C, lwp_self, \"pthread_self\");\n+\n+   -------------\n+   -- Threads --\n+   -------------\n+\n+   type Thread_Body is access\n+     function (arg : System.Address) return System.Address;\n+   pragma Convention (C, Thread_Body);\n+\n+   function Thread_Body_Access is new\n+     Ada.Unchecked_Conversion (System.Address, Thread_Body);\n+\n+   subtype Thread_Id        is pthread_t;\n+\n+   type pthread_mutex_t     is limited private;\n+   type pthread_cond_t      is limited private;\n+   type pthread_attr_t      is limited private;\n+   type pthread_mutexattr_t is limited private;\n+   type pthread_condattr_t  is limited private;\n+   type pthread_key_t       is private;\n+\n+   PTHREAD_CREATE_DETACHED : constant := 1;\n+   PTHREAD_CREATE_JOINABLE : constant := 0;\n+\n+   PTHREAD_SCOPE_PROCESS : constant := 0; --  not supported by LynxOS178\n+   PTHREAD_SCOPE_SYSTEM  : constant := 1;\n+\n+   --  Read/Write lock not supported on LynxOS. To add support both types\n+   --  pthread_rwlock_t and pthread_rwlockattr_t must properly be defined\n+   --  with the associated routines pthread_rwlock_[init/destroy] and\n+   --  pthread_rwlock_[rdlock/wrlock/unlock].\n+\n+   subtype pthread_rwlock_t     is pthread_mutex_t;\n+   subtype pthread_rwlockattr_t is pthread_mutexattr_t;\n+\n+   -----------\n+   -- Stack --\n+   -----------\n+\n+   type stack_t is record\n+      ss_sp    : System.Address;\n+      ss_flags : int;\n+      ss_size  : size_t;\n+   end record;\n+   pragma Convention (C, stack_t);\n+\n+   function sigaltstack\n+     (ss  : not null access stack_t;\n+      oss : access stack_t) return int;\n+   pragma Import (C, sigaltstack, \"sigaltstack\");\n+   --  Neither stack_t nor sigaltstack are available on LynxOS-178\n+\n+   Alternate_Stack : aliased System.Address;\n+   --  This is a dummy definition, never used (Alternate_Stack_Size is 0)\n+\n+   Alternate_Stack_Size : constant := 0;\n+   --  No alternate signal stack is used on this platform\n+\n+   Stack_Base_Available : constant Boolean := False;\n+   --  Indicates whether the stack base is available on this target\n+\n+   function Get_Stack_Base (thread : pthread_t) return Address;\n+   pragma Inline (Get_Stack_Base);\n+   --  Returns the stack base of the specified thread. Only call this function\n+   --  when Stack_Base_Available is True.\n+\n+   function Get_Page_Size return int;\n+   --  Returns the size of a page in bytes\n+\n+   PROT_NONE  : constant := 1;\n+   PROT_READ  : constant := 2;\n+   PROT_WRITE : constant := 4;\n+   PROT_EXEC  : constant := 8;\n+   PROT_ALL   : constant := PROT_READ + PROT_WRITE + PROT_EXEC;\n+\n+   PROT_ON    : constant := PROT_READ;\n+   PROT_OFF   : constant := PROT_ALL;\n+\n+   function mprotect (addr : Address; len : size_t; prot : int) return int;\n+   pragma Import (C, mprotect);\n+\n+   ---------------------------------------\n+   -- Nonstandard Thread Initialization --\n+   ---------------------------------------\n+\n+   procedure pthread_init;\n+   --  This is a dummy procedure to share some GNULLI files\n+\n+   -------------------------\n+   -- POSIX.1c  Section 3 --\n+   -------------------------\n+   function sigwait\n+     (set : access sigset_t;\n+      sig : access Signal) return int;\n+   pragma Inline (sigwait);\n+   --  LynxOS has non standard sigwait\n+\n+   function pthread_kill\n+     (thread : pthread_t;\n+      sig    : Signal) return int;\n+   pragma Import (C, pthread_kill, \"pthread_kill\");\n+\n+   function pthread_sigmask\n+     (how  : int;\n+      set  : access sigset_t;\n+      oset : access sigset_t) return int;\n+   pragma Import (C, pthread_sigmask, \"pthread_sigmask\");\n+\n+   ----------------------------\n+   --  POSIX.1c  Section 11  --\n+   ----------------------------\n+\n+   function pthread_mutexattr_init\n+     (attr : access pthread_mutexattr_t) return int;\n+   pragma Import (C, pthread_mutexattr_init, \"pthread_mutexattr_init\");\n+\n+   function pthread_mutexattr_destroy\n+     (attr : access pthread_mutexattr_t) return int;\n+   pragma Import (C, pthread_mutexattr_destroy, \"pthread_mutexattr_destroy\");\n+\n+   function pthread_mutex_init\n+     (mutex : access pthread_mutex_t;\n+      attr  : access pthread_mutexattr_t) return int;\n+   pragma Import (C, pthread_mutex_init, \"pthread_mutex_init\");\n+\n+   function pthread_mutex_destroy (mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_mutex_destroy, \"pthread_mutex_destroy\");\n+\n+   function pthread_mutex_lock (mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_mutex_lock, \"pthread_mutex_lock\");\n+\n+   function pthread_mutex_unlock (mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_mutex_unlock, \"pthread_mutex_unlock\");\n+\n+   function pthread_condattr_init\n+     (attr : access pthread_condattr_t) return int;\n+   pragma Import (C, pthread_condattr_init, \"pthread_condattr_init\");\n+\n+   function pthread_condattr_destroy\n+     (attr : access pthread_condattr_t) return int;\n+   pragma Import (C, pthread_condattr_destroy, \"pthread_condattr_destroy\");\n+\n+   function pthread_cond_init\n+     (cond : access pthread_cond_t;\n+      attr : access pthread_condattr_t) return int;\n+   pragma Import (C, pthread_cond_init, \"pthread_cond_init\");\n+\n+   function pthread_cond_destroy (cond : access pthread_cond_t) return int;\n+   pragma Import (C, pthread_cond_destroy, \"pthread_cond_destroy\");\n+\n+   function pthread_cond_signal (cond : access pthread_cond_t) return int;\n+   pragma Import (C, pthread_cond_signal, \"pthread_cond_signal\");\n+\n+   function pthread_cond_wait\n+     (cond  : access pthread_cond_t;\n+      mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_cond_wait, \"pthread_cond_wait\");\n+\n+   function pthread_cond_timedwait\n+     (cond    : access pthread_cond_t;\n+      mutex   : access pthread_mutex_t;\n+      abstime : access timespec) return int;\n+   pragma Import (C, pthread_cond_timedwait, \"pthread_cond_timedwait\");\n+\n+   Relative_Timed_Wait : constant Boolean := False;\n+   --  pthread_cond_timedwait requires an absolute delay time\n+\n+   --------------------------\n+   -- POSIX.1c  Section 13 --\n+   --------------------------\n+\n+   PTHREAD_PRIO_NONE    : constant := 0;\n+   PTHREAD_PRIO_INHERIT : constant := 1;\n+   PTHREAD_PRIO_PROTECT : constant := 2;\n+\n+   function pthread_mutexattr_setprotocol\n+     (attr     : access pthread_mutexattr_t;\n+      protocol : int) return int;\n+   pragma Import (C, pthread_mutexattr_setprotocol);\n+\n+   function pthread_mutexattr_setprioceiling\n+     (attr        : access pthread_mutexattr_t;\n+      prioceiling : int) return int;\n+   pragma Import (C, pthread_mutexattr_setprioceiling);\n+\n+   type struct_sched_param is record\n+      sched_priority        : int;\n+   end record;\n+   pragma Convention (C, struct_sched_param);\n+\n+   function pthread_setschedparam\n+     (thread : pthread_t;\n+      policy : int;\n+      param  : access struct_sched_param) return int;\n+   pragma Import (C, pthread_setschedparam, \"pthread_setschedparam\");\n+\n+   function pthread_attr_setscope\n+     (attr            : access pthread_attr_t;\n+      contentionscope : int) return int is (0);\n+   --  pthread_attr_setscope is not implemented in production mode\n+\n+   function pthread_attr_setinheritsched\n+     (attr         : access pthread_attr_t;\n+      inheritsched : int) return int;\n+   pragma Import (C, pthread_attr_setinheritsched);\n+\n+   function pthread_attr_setschedpolicy\n+     (attr   : access pthread_attr_t;\n+      policy : int) return int;\n+   pragma Import (C, pthread_attr_setschedpolicy);\n+\n+   function sched_yield return int;\n+   pragma Import (C, sched_yield, \"sched_yield\");\n+\n+   --------------------------\n+   -- P1003.1c  Section 16 --\n+   --------------------------\n+\n+   function pthread_attr_init (attributes : access pthread_attr_t) return int;\n+   pragma Import (C, pthread_attr_init, \"pthread_attr_init\");\n+\n+   function pthread_attr_destroy\n+     (attributes : access pthread_attr_t) return int;\n+   pragma Import (C, pthread_attr_destroy, \"pthread_attr_destroy\");\n+\n+   function pthread_attr_setdetachstate\n+     (attr        : access pthread_attr_t;\n+      detachstate : int) return int;\n+   pragma Import (C, pthread_attr_setdetachstate);\n+\n+   function pthread_attr_setstacksize\n+     (attr      : access pthread_attr_t;\n+      stacksize : size_t) return int;\n+   pragma Import (C, pthread_attr_setstacksize);\n+\n+   function pthread_create\n+     (thread        : access pthread_t;\n+      attributes    : access pthread_attr_t;\n+      start_routine : Thread_Body;\n+      arg           : System.Address) return int;\n+   pragma Import (C, pthread_create, \"pthread_create\");\n+\n+   procedure pthread_exit (status : System.Address);\n+   pragma Import (C, pthread_exit, \"pthread_exit\");\n+\n+   function pthread_self return pthread_t;\n+   pragma Import (C, pthread_self, \"pthread_self\");\n+\n+   --------------------------\n+   -- POSIX.1c  Section 17 --\n+   --------------------------\n+\n+   function pthread_setspecific\n+     (key   : pthread_key_t;\n+      value : System.Address) return int;\n+   pragma Import (C, pthread_setspecific, \"pthread_setspecific\");\n+\n+   function pthread_getspecific\n+     (key    : pthread_key_t) return System.Address;\n+   pragma Import (C, pthread_getspecific, \"pthread_getspecific\");\n+\n+   type destructor_pointer is access procedure (arg : System.Address);\n+   pragma Convention (C, destructor_pointer);\n+\n+   function pthread_key_create\n+     (key        : access pthread_key_t;\n+      destructor : destructor_pointer\n+     ) return int;\n+   pragma Import (C, pthread_key_create, \"pthread_key_create\");\n+\n+   ---------------------\n+   -- Multiprocessors --\n+   ---------------------\n+\n+   function Current_CPU return Multiprocessors.CPU;\n+   --  Return the id of the current CPU\n+\n+   function Get_Affinity (Id : Thread_Id) return Multiprocessors.CPU_Range;\n+   --  Return CPU affinity of the given thread (maybe Not_A_Specific_CPU)\n+\n+   function Get_CPU (Id : Thread_Id) return Multiprocessors.CPU;\n+   --  Return the CPU in charge of the given thread (always a valid CPU)\n+\n+private\n+\n+   type sigset_t is array (1 .. 2) of long;\n+   pragma Convention (C, sigset_t);\n+\n+   type pid_t is new long;\n+\n+   type time_t is new int64;\n+\n+   type suseconds_t is new int;\n+\n+   type timespec is record\n+      tv_sec  : time_t;\n+      tv_nsec : long;\n+   end record;\n+   pragma Convention (C, timespec);\n+\n+   type struct_timeval is record\n+      tv_sec  : time_t;\n+      tv_usec : suseconds_t;\n+   end record;\n+   pragma Convention (C, struct_timeval);\n+\n+   type st_attr is record\n+      stksize      : int;\n+      prio         : int;\n+      inheritsched : int;\n+      state        : int;\n+      sched        : int;\n+      detachstate  : int;\n+      guardsize    : int;\n+   end record;\n+   pragma Convention (C, st_attr);\n+   subtype st_attr_t is st_attr;\n+\n+   type pthread_attr_t is record\n+      pthread_attr_magic : unsigned;\n+      st                 : st_attr_t;\n+      pthread_attr_scope : int;\n+   end record;\n+   pragma Convention (C, pthread_attr_t);\n+\n+   type pthread_condattr_t is record\n+      cv_magic   : unsigned;\n+      cv_pshared : unsigned;\n+   end record;\n+   pragma Convention (C, pthread_condattr_t);\n+\n+   type pthread_mutexattr_t is record\n+      m_flags   : unsigned;\n+      m_prio_c  : int;\n+      m_pshared : int;\n+   end record;\n+   pragma Convention (C, pthread_mutexattr_t);\n+\n+   type tid_t is new short;\n+   type pthread_t is new tid_t;\n+\n+   type block_obj_t is record\n+      b_head : int;\n+   end record;\n+   pragma Convention (C, block_obj_t);\n+\n+   type pthread_mutex_t is record\n+      m_flags      : unsigned;\n+      m_owner      : tid_t;\n+      m_wait       : block_obj_t;\n+      m_prio_c     : int;\n+      m_oldprio    : int;\n+      m_count      : int;\n+      m_referenced : int;\n+   end record;\n+   pragma Convention (C, pthread_mutex_t);\n+   type pthread_mutex_t_ptr is access all pthread_mutex_t;\n+\n+   type pthread_cond_t is record\n+      cv_magic   : unsigned;\n+      cv_wait    : block_obj_t;\n+      cv_mutex   : pthread_mutex_t_ptr;\n+      cv_refcnt  : int;\n+   end record;\n+   pragma Convention (C, pthread_cond_t);\n+\n+   type pthread_key_t is new int;\n+\n+end System.OS_Interface;"}, {"sha": "298c0699fc5c52693106637404942ddbd638b1d1", "filename": "gcc/ada/libgnarl/s-taspri-lynxos.ads", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16707e90f935452e4ce65e04e0a2047b6b083eb3/gcc%2Fada%2Flibgnarl%2Fs-taspri-lynxos.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16707e90f935452e4ce65e04e0a2047b6b083eb3/gcc%2Fada%2Flibgnarl%2Fs-taspri-lynxos.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-taspri-lynxos.ads?ref=16707e90f935452e4ce65e04e0a2047b6b083eb3", "patch": "@@ -0,0 +1,118 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n+--                                                                          --\n+--               S Y S T E M . T A S K _ P R I M I T I V E S                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 1991-2017, Florida State University             --\n+--                     Copyright (C) 1995-2017, AdaCore                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is LynxOS Family version of this package.\n+\n+pragma Polling (Off);\n+--  Turn off polling, we do not want ATC polling to take place during tasking\n+--  operations. It causes infinite loops and other problems.\n+\n+with System.OS_Interface;\n+\n+package System.Task_Primitives is\n+   pragma Preelaborate;\n+\n+   type Lock is limited private;\n+   --  Should be used for implementation of protected objects\n+\n+   type RTS_Lock is limited private;\n+   --  Should be used inside the runtime system. The difference between Lock\n+   --  and the RTS_Lock is that the latter serves only as a semaphore so that\n+   --  we do not check for ceiling violations.\n+\n+   type Suspension_Object is limited private;\n+   --  Should be used for the implementation of Ada.Synchronous_Task_Control\n+\n+   type Task_Body_Access is access procedure;\n+   --  Pointer to the task body's entry point (or possibly a wrapper declared\n+   --  local to the GNARL).\n+\n+   type Private_Data is limited private;\n+   --  Any information that the GNULLI needs maintained on a per-task basis.\n+   --  A component of this type is guaranteed to be included in the\n+   --  Ada_Task_Control_Block.\n+\n+   subtype Task_Address is System.Address;\n+   Task_Address_Size : constant := Standard'Address_Size;\n+   --  Type used for task addresses and its size\n+\n+   Alternate_Stack_Size : constant := System.OS_Interface.Alternate_Stack_Size;\n+   --  Import value from System.OS_Interface\n+\n+private\n+\n+   type Lock is record\n+      RW : aliased System.OS_Interface.pthread_rwlock_t;\n+      WO : aliased System.OS_Interface.pthread_mutex_t;\n+   end record;\n+\n+   type RTS_Lock is new System.OS_Interface.pthread_mutex_t;\n+\n+   type Suspension_Object is record\n+      State : Boolean;\n+      pragma Atomic (State);\n+      --  Boolean that indicates whether the object is open. This field is\n+      --  marked Atomic to ensure that we can read its value without locking\n+      --  the access to the Suspension_Object.\n+\n+      Waiting : Boolean;\n+      --  Flag showing if there is a task already suspended on this object\n+\n+      L : aliased System.OS_Interface.pthread_mutex_t;\n+      --  Protection for ensuring mutual exclusion on the Suspension_Object\n+\n+      CV : aliased System.OS_Interface.pthread_cond_t;\n+      --  Condition variable used to queue threads until condition is signaled\n+   end record;\n+\n+   type Private_Data is limited record\n+      Thread : aliased System.OS_Interface.pthread_t;\n+      pragma Atomic (Thread);\n+      --  Thread field may be updated by two different threads of control.\n+      --  (See, Enter_Task and Create_Task in s-taprop.adb). They put the same\n+      --  value (thr_self value). We do not want to use lock on those\n+      --  operations and the only thing we have to make sure is that they are\n+      --  updated in atomic fashion.\n+\n+      LWP : aliased System.OS_Interface.pthread_t;\n+      --  The purpose of this field is to provide a better tasking support on\n+      --  gdb. The order of the two first fields (Thread and LWP) is important.\n+      --  On targets where lwp is not relevant, this is equivalent to Thread.\n+\n+      CV : aliased System.OS_Interface.pthread_cond_t;\n+      --  Should be commented ??? (in all versions of taspri)\n+\n+      L : aliased RTS_Lock;\n+      --  Protection for all components is lock L\n+   end record;\n+\n+end System.Task_Primitives;"}]}