{"sha": "852dd866e2faba95cb407c98d31a48b6aae66677", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODUyZGQ4NjZlMmZhYmE5NWNiNDA3Yzk4ZDMxYTQ4YjZhYWU2NjY3Nw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-04-28T07:43:02Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-04-28T07:46:22Z"}, "message": "Fix loss of optimization of array iteration due to inlining\n\nThis helps loop-invariant motion to hoist complicated offset computations.\n\ngcc/ada/\n\t* gcc-interface/trans.c (language_function): Add comment.\n\t(loop_info_d): Add fndecl and invariants fields.\n\t(find_loop_for): Test fndecl instead of the context of var.\n\t(find_loop): New function.\n\t(Regular_Loop_to_gnu): Fold back into...\n\t(Loop_Statement_to_gnu): ...this.  Emit invariants on entry, if any.\n\t(gnat_to_gnu) <N_Selected_Component>: Record nonconstant invariant\n\toffset computations in loops when optimization is enabled.\n\t* gcc-interface/utils2.c (gnat_invariant_expr): Handle BIT_AND_EXPR.\ngcc/testsuite/\n\t* gnat.dg/opt93.ads, gnat.dg/opt93.adb: New test.", "tree": {"sha": "5fdf04f62c9004fc0406ef82636e0f496ff35fab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5fdf04f62c9004fc0406ef82636e0f496ff35fab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/852dd866e2faba95cb407c98d31a48b6aae66677", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/852dd866e2faba95cb407c98d31a48b6aae66677", "html_url": "https://github.com/Rust-GCC/gccrs/commit/852dd866e2faba95cb407c98d31a48b6aae66677", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/852dd866e2faba95cb407c98d31a48b6aae66677/comments", "author": null, "committer": null, "parents": [{"sha": "d91e7eab3a2c3957c2220ad71e62d9fc78cccb9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d91e7eab3a2c3957c2220ad71e62d9fc78cccb9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d91e7eab3a2c3957c2220ad71e62d9fc78cccb9b"}], "stats": {"total": 179, "additions": 121, "deletions": 58}, "files": [{"sha": "4e533cef2af9e46f51fa7105dc7419f3b0ee6fbe", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 76, "deletions": 58, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852dd866e2faba95cb407c98d31a48b6aae66677/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852dd866e2faba95cb407c98d31a48b6aae66677/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=852dd866e2faba95cb407c98d31a48b6aae66677", "patch": "@@ -112,7 +112,7 @@ struct GTY (()) parm_attr_d {\n \n typedef struct parm_attr_d *parm_attr;\n \n-\n+/* Structure used to record information for a function.  */\n struct GTY(()) language_function {\n   vec<parm_attr, va_gc> *parm_attr_cache;\n   bitmap named_ret_val;\n@@ -194,9 +194,9 @@ struct GTY(()) range_check_info_d {\n \n typedef struct range_check_info_d *range_check_info;\n \n-\n /* Structure used to record information for a loop.  */\n struct GTY(()) loop_info_d {\n+  tree fndecl;\n   tree stmt;\n   tree loop_var;\n   tree low_bound;\n@@ -205,11 +205,11 @@ struct GTY(()) loop_info_d {\n   tree omp_construct_clauses;\n   enum tree_code omp_code;\n   vec<range_check_info, va_gc> *checks;\n+  vec<tree, va_gc> *invariants;\n };\n \n typedef struct loop_info_d *loop_info;\n \n-\n /* Stack of loop_info structures associated with LOOP_STMT nodes.  */\n static GTY(()) vec<loop_info, va_gc> *gnu_loop_stack;\n \n@@ -2768,13 +2768,27 @@ find_loop_for (tree expr, tree *disp, bool *neg_p)\n   if (TREE_CODE (var) != VAR_DECL)\n     return NULL;\n \n-  if (decl_function_context (var) != current_function_decl)\n-    return NULL;\n+  gcc_checking_assert (vec_safe_length (gnu_loop_stack) > 0);\n+\n+  FOR_EACH_VEC_ELT_REVERSE (*gnu_loop_stack, i, iter)\n+    if (iter->loop_var == var && iter->fndecl == current_function_decl)\n+      break;\n+\n+  return iter;\n+}\n \n-  gcc_assert (vec_safe_length (gnu_loop_stack) > 0);\n+/* Return the innermost enclosing loop in the current function.  */\n+\n+static struct loop_info_d *\n+find_loop (void)\n+{\n+  struct loop_info_d *iter = NULL;\n+  unsigned int i;\n+\n+  gcc_checking_assert (vec_safe_length (gnu_loop_stack) > 0);\n \n   FOR_EACH_VEC_ELT_REVERSE (*gnu_loop_stack, i, iter)\n-    if (var == iter->loop_var)\n+    if (iter->fndecl == current_function_decl)\n       break;\n \n   return iter;\n@@ -2924,26 +2938,30 @@ independent_iterations_p (tree stmt_list)\n   return true;\n }\n \n-/* Helper for Loop_Statement_to_gnu, to translate the body of a loop not\n-   subject to any sort of parallelization directive or restriction, designated\n-   by GNAT_NODE.\n-\n-   We expect the top of gnu_loop_stack to hold a pointer to the loop info\n-   setup for the translation, which holds a pointer to the initial gnu loop\n-   stmt node.  We return the new gnu loop statement to use.\n-\n-   We might also set *GNU_COND_EXPR_P to request a variant of the translation\n-   scheme in Loop_Statement_to_gnu.  */\n+/* Subroutine of gnat_to_gnu to translate gnat_node, an N_Loop_Statement,\n+   to a GCC tree, which is returned.  */\n \n static tree\n-Regular_Loop_to_gnu (Node_Id gnat_node, tree *gnu_cond_expr_p)\n+Loop_Statement_to_gnu (Node_Id gnat_node)\n {\n   const Node_Id gnat_iter_scheme = Iteration_Scheme (gnat_node);\n-  struct loop_info_d *const gnu_loop_info = gnu_loop_stack->last ();\n-  tree gnu_loop_stmt = gnu_loop_info->stmt;\n-  tree gnu_loop_label = LOOP_STMT_LABEL (gnu_loop_stmt);\n-  tree gnu_cond_expr = *gnu_cond_expr_p;\n-  tree gnu_low = NULL_TREE, gnu_high = NULL_TREE;\n+  struct loop_info_d *gnu_loop_info = ggc_cleared_alloc<loop_info_d> ();\n+  tree gnu_loop_stmt = build4 (LOOP_STMT, void_type_node, NULL_TREE,\n+\t\t\t       NULL_TREE, NULL_TREE, NULL_TREE);\n+  tree gnu_loop_label = create_artificial_label (input_location);\n+  tree gnu_cond_expr = NULL_TREE, gnu_low = NULL_TREE, gnu_high = NULL_TREE;\n+  tree gnu_result;\n+\n+  /* Push the loop_info structure associated with the LOOP_STMT.  */\n+  gnu_loop_info->fndecl = current_function_decl;\n+  gnu_loop_info->stmt = gnu_loop_stmt;\n+  vec_safe_push (gnu_loop_stack, gnu_loop_info);\n+\n+  /* Set location information for statement and end label.  */\n+  set_expr_location_from_node (gnu_loop_stmt, gnat_node);\n+  Sloc_to_locus (Sloc (End_Label (gnat_node)),\n+\t\t &DECL_SOURCE_LOCATION (gnu_loop_label));\n+  LOOP_STMT_LABEL (gnu_loop_stmt) = gnu_loop_label;\n \n   /* Set the condition under which the loop must keep going.  If we have an\n      explicit condition, use it to set the location information throughout\n@@ -3277,7 +3295,16 @@ Regular_Loop_to_gnu (Node_Id gnat_node, tree *gnu_cond_expr_p)\n \t\t}\n \t}\n \n-      /* Second, if loop vectorization is enabled and the iterations of the\n+      /* Second, if we have recorded invariants to be hoisted, emit them.  */\n+      if (vec_safe_length (gnu_loop_info->invariants) > 0)\n+\t{\n+\t  tree *iter;\n+\t  unsigned int i;\n+\t  FOR_EACH_VEC_ELT (*gnu_loop_info->invariants, i, iter)\n+\t    add_stmt_with_node_force (*iter, gnat_node);\n+\t}\n+\n+      /* Third, if loop vectorization is enabled and the iterations of the\n \t loop can easily be proved as independent, mark the loop.  */\n       if (optimize >= 3\n \t  && independent_iterations_p (LOOP_STMT_BODY (gnu_loop_stmt)))\n@@ -3288,40 +3315,6 @@ Regular_Loop_to_gnu (Node_Id gnat_node, tree *gnu_cond_expr_p)\n       gnu_loop_stmt = end_stmt_group ();\n     }\n \n-  *gnu_cond_expr_p = gnu_cond_expr;\n-\n-  return gnu_loop_stmt;\n-}\n-\n-/* Subroutine of gnat_to_gnu to translate gnat_node, an N_Loop_Statement,\n-   to a GCC tree, which is returned.  */\n-\n-static tree\n-Loop_Statement_to_gnu (Node_Id gnat_node)\n-{\n-  struct loop_info_d *gnu_loop_info = ggc_cleared_alloc<loop_info_d> ();\n-\n-  tree gnu_loop_stmt = build4 (LOOP_STMT, void_type_node, NULL_TREE,\n-\t\t\t       NULL_TREE, NULL_TREE, NULL_TREE);\n-  tree gnu_cond_expr = NULL_TREE;\n-  tree gnu_loop_label = create_artificial_label (input_location);\n-  tree gnu_result;\n-\n-  /* Push the loop_info structure associated with the LOOP_STMT.  */\n-  vec_safe_push (gnu_loop_stack, gnu_loop_info);\n-\n-  /* Set location information for statement and end label.  */\n-  set_expr_location_from_node (gnu_loop_stmt, gnat_node);\n-  Sloc_to_locus (Sloc (End_Label (gnat_node)),\n-\t\t &DECL_SOURCE_LOCATION (gnu_loop_label));\n-  LOOP_STMT_LABEL (gnu_loop_stmt) = gnu_loop_label;\n-\n-  /* Save the statement for later reuse.  */\n-  gnu_loop_info->stmt = gnu_loop_stmt;\n-\n-  /* Perform the core loop body translation.  */\n-  gnu_loop_stmt = Regular_Loop_to_gnu (gnat_node, &gnu_cond_expr);\n-\n   /* If we have an outer COND_EXPR, that's our result and this loop is its\n      \"true\" statement.  Otherwise, the result is the LOOP_STMT.  */\n   if (gnu_cond_expr)\n@@ -6731,13 +6724,38 @@ gnat_to_gnu (Node_Id gnat_node)\n \telse\n \t  {\n \t    tree gnu_field = gnat_to_gnu_field_decl (gnat_field);\n+\t    tree gnu_offset;\n+\t    struct loop_info_d *loop;\n \n \t    gnu_result\n \t      = build_component_ref (gnu_prefix, gnu_field,\n \t\t\t\t     (Nkind (Parent (gnat_node))\n \t\t\t\t      == N_Attribute_Reference)\n \t\t\t\t     && lvalue_required_for_attribute_p\n \t\t\t\t\t(Parent (gnat_node)));\n+\n+\t    /* If optimization is enabled and we are inside a loop, we try to\n+\t       hoist nonconstant but invariant offset computations outside of\n+\t       the loop, since they very likely contain loads that could turn\n+\t       out to be hard to move if they end up in active EH regions.  */\n+\t    if (optimize\n+\t\t&& inside_loop_p ()\n+\t\t&& TREE_CODE (gnu_result) == COMPONENT_REF\n+\t\t&& (gnu_offset = component_ref_field_offset (gnu_result))\n+\t\t&& !TREE_CONSTANT (gnu_offset)\n+\t\t&& (gnu_offset = gnat_invariant_expr (gnu_offset))\n+\t\t&& (loop = find_loop ()))\n+\t      {\n+\t\ttree invariant\n+\t\t  = build1 (SAVE_EXPR, TREE_TYPE (gnu_offset), gnu_offset);\n+\t\tvec_safe_push (loop->invariants, invariant);\n+\t\ttree field = TREE_OPERAND (gnu_result, 1);\n+\t\ttree factor\n+\t\t  = size_int (DECL_OFFSET_ALIGN (field) / BITS_PER_UNIT);\n+\t\t/* Divide the offset by its alignment.  */\n+\t\tTREE_OPERAND (gnu_result, 2)\n+\t\t  = size_binop (EXACT_DIV_EXPR, invariant, factor);\n+\t      }\n \t  }\n \n \tgnu_result_type = get_unpadded_type (Etype (gnat_node));"}, {"sha": "83cc794a7753b1055d22df5b28aa527efb2f8bff", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852dd866e2faba95cb407c98d31a48b6aae66677/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852dd866e2faba95cb407c98d31a48b6aae66677/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=852dd866e2faba95cb407c98d31a48b6aae66677", "patch": "@@ -2946,6 +2946,17 @@ gnat_invariant_expr (tree expr)\n   if (TREE_CONSTANT (expr))\n     return fold_convert (type, expr);\n \n+  /* Deal with aligning patterns.  */\n+  if (TREE_CODE (expr) == BIT_AND_EXPR\n+      && TREE_CONSTANT (TREE_OPERAND (expr, 1)))\n+    {\n+      tree op0 = gnat_invariant_expr (TREE_OPERAND (expr, 0));\n+      if (op0)\n+\treturn fold_build2 (BIT_AND_EXPR, type, op0, TREE_OPERAND (expr, 1));\n+      else\n+\treturn NULL_TREE;\n+    }\n+\n   /* Deal with addition or subtraction of constants.  */\n   if (is_simple_additive_expression (expr, &add, &cst, &minus_p))\n     {"}, {"sha": "5c82ad2e94214432ca88e9c7b2e22891db1fa2f7", "filename": "gcc/testsuite/gnat.dg/opt93.adb", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852dd866e2faba95cb407c98d31a48b6aae66677/gcc%2Ftestsuite%2Fgnat.dg%2Fopt93.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852dd866e2faba95cb407c98d31a48b6aae66677/gcc%2Ftestsuite%2Fgnat.dg%2Fopt93.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt93.adb?ref=852dd866e2faba95cb407c98d31a48b6aae66677", "patch": "@@ -0,0 +1,20 @@\n+-- { dg-do compile }\n+-- { dg-options \"-O2 -fdump-tree-optimized\" }\n+\n+package body Opt93 is\n+\n+  function Worker (Obj : T) return Boolean is\n+  begin\n+    return (for some J in 1 .. Obj.D2 => Obj.A (J) = 0);\n+  end;\n+\n+  function Contains_Zero (Obj : T) return Boolean is\n+  begin\n+    return Worker (Obj);\n+  exception\n+    when Others => raise Program_Error;\n+  end;\n+\n+end Opt93;\n+\n+-- { dg-final { scan-tree-dump \"ivtmp.\\[0-9_]+ = ivtmp.\\[0-9_]+ \\\\+ 2\" \"optimized\" } }"}, {"sha": "61bc2364464b56d774083bd9f3ade26c91801493", "filename": "gcc/testsuite/gnat.dg/opt93.ads", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852dd866e2faba95cb407c98d31a48b6aae66677/gcc%2Ftestsuite%2Fgnat.dg%2Fopt93.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852dd866e2faba95cb407c98d31a48b6aae66677/gcc%2Ftestsuite%2Fgnat.dg%2Fopt93.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt93.ads?ref=852dd866e2faba95cb407c98d31a48b6aae66677", "patch": "@@ -0,0 +1,14 @@\n+package Opt93 is\n+\n+  type Arr is array (Natural range <>) of Short_Integer;\n+\n+  type Rec (D1, D2 : Natural) is record\n+    S : String (1 .. D1);\n+    A : Arr (1 .. D2);\n+  end record;\n+\n+  type T is access Rec;\n+\n+  function Contains_Zero (Obj : T) return Boolean;\n+\n+end Opt93;"}]}