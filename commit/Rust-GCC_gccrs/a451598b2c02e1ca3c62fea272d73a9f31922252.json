{"sha": "a451598b2c02e1ca3c62fea272d73a9f31922252", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQ1MTU5OGIyYzAyZTFjYTNjNjJmZWEyNzJkNzNhOWYzMTkyMjI1Mg==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2021-05-13T10:42:58Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2021-05-13T10:44:45Z"}, "message": "arm: correctly handle inequality comparisons against max constants [PR100563]\n\nNormally we expect the gimple optimizers to fold away comparisons that\nare always true, but at some lower optimization levels this is not\nalways the case, so the back-end has to be able to generate correct\ncode in these cases.\n\nIn this example, we have a comparison of the form\n\n  (unsigned long long) op <= ~0ULL\n\nwhich, of course is always true.\n\nNormally, in the arm back-end we handle these expansions where the\nimmediate cannot be handled directly by adding 1 to the constant and\nthen adjusting the comparison operator:\n\n  (unsigned long long) op < CONST + 1\n\nbut we cannot do that when the constant is already the largest value.\n\nFortunately, we observe that the comparisons we need to handle this\nway are either always true or always false, so instead of forming a\ncomparison against the maximum value, we can replace it with a\ncomparison against the minimum value (which just happens to also be a\nconstant we can handle.  So\n\n  op1 <= ~0ULL -> op1 >= 0U\n  op1 > ~0ULL -> op1 < 0U\n\n  op1 <= LONG_LONG_INT_MAX -> op1 >= (-LONG_LONG_INT_MAX - 1)\n  op1 > LONG_LONG_INT_MAX -> op1 < (-LONG_LONG_INT_MAX - 1)\n\ngcc:\n\tPR target/100563\n\t* config/arm/arm.c (arm_canonicalize_comparison): Correctly\n\tcanonicalize DImode inequality comparisons against the\n\tmaximum integral value.\n\ngcc/testsuite:\n\t* gcc.dg/pr100563.c: New test.", "tree": {"sha": "b63c39fbeeb19ad8816211179bfb777643c7ce4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b63c39fbeeb19ad8816211179bfb777643c7ce4e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a451598b2c02e1ca3c62fea272d73a9f31922252", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a451598b2c02e1ca3c62fea272d73a9f31922252", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a451598b2c02e1ca3c62fea272d73a9f31922252", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a451598b2c02e1ca3c62fea272d73a9f31922252/comments", "author": null, "committer": null, "parents": [{"sha": "829c4bea06600ea4201462f91ce6d76ca21fdb35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/829c4bea06600ea4201462f91ce6d76ca21fdb35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/829c4bea06600ea4201462f91ce6d76ca21fdb35"}], "stats": {"total": 38, "additions": 34, "deletions": 4}, "files": [{"sha": "d0c0c50be9757e36429a519bac4a9ae9e2a870e9", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a451598b2c02e1ca3c62fea272d73a9f31922252/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a451598b2c02e1ca3c62fea272d73a9f31922252/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=a451598b2c02e1ca3c62fea272d73a9f31922252", "patch": "@@ -5563,9 +5563,20 @@ arm_canonicalize_comparison (int *code, rtx *op0, rtx *op1,\n \t\t\treturn;\n \t\t      *op1 = GEN_INT (i + 1);\n \t\t      *code = *code == GT ? GE : LT;\n-\t\t      return;\n \t\t    }\n-\t\t  break;\n+\t\t  else\n+\t\t    {\n+\t\t      /* GT maxval is always false, LE maxval is always true.\n+\t\t\t We can't fold that away here as we must make a\n+\t\t\t comparison, but we can fold them to comparisons\n+\t\t\t with the same result that can be handled:\n+\t\t\t   op0 GT maxval -> op0 LT minval\n+\t\t\t   op0 LE maxval -> op0 GE minval\n+\t\t\t where minval = (-maxval - 1).  */\n+\t\t      *op1 = GEN_INT (-maxval - 1);\n+\t\t      *code = *code == GT ? LT : GE;\n+\t\t    }\n+\t\t  return;\n \n \t\tcase GTU:\n \t\tcase LEU:\n@@ -5578,9 +5589,19 @@ arm_canonicalize_comparison (int *code, rtx *op0, rtx *op1,\n \t\t\treturn;\n \t\t      *op1 = GEN_INT (i + 1);\n \t\t      *code = *code == GTU ? GEU : LTU;\n-\t\t      return;\n \t\t    }\n-\t\t  break;\n+\t\t  else\n+\t\t    {\n+\t\t      /* GTU ~0 is always false, LEU ~0 is always true.\n+\t\t\t We can't fold that away here as we must make a\n+\t\t\t comparison, but we can fold them to comparisons\n+\t\t\t with the same result that can be handled:\n+\t\t\t   op0 GTU ~0 -> op0 LTU 0\n+\t\t\t   op0 LEU ~0 -> op0 GEU 0.  */\n+\t\t      *op1 = const0_rtx;\n+\t\t      *code = *code == GTU ? LTU : GEU;\n+\t\t    }\n+\t\t  return;\n \n \t\tdefault:\n \t\t  gcc_unreachable ();"}, {"sha": "812eb9e6ae2a5a7a0c852f5df3395796a1b518c0", "filename": "gcc/testsuite/gcc.dg/pr100563.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a451598b2c02e1ca3c62fea272d73a9f31922252/gcc%2Ftestsuite%2Fgcc.dg%2Fpr100563.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a451598b2c02e1ca3c62fea272d73a9f31922252/gcc%2Ftestsuite%2Fgcc.dg%2Fpr100563.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr100563.c?ref=a451598b2c02e1ca3c62fea272d73a9f31922252", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Og\" } */\n+unsigned long long e(void);\n+void f(int);\n+void a() {\n+  short b = -1, c = (int)&b;\n+  unsigned long long d = e();\n+  f(b >= d);\n+}"}]}