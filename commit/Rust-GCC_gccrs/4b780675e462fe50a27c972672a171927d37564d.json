{"sha": "4b780675e462fe50a27c972672a171927d37564d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGI3ODA2NzVlNDYyZmU1MGEyN2M5NzI2NzJhMTcxOTI3ZDM3NTY0ZA==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2003-08-10T18:17:06Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2003-08-10T18:17:06Z"}, "message": "pretty-print.c (pp_base_indent): Rename from pp_indent.\n\n\t* pretty-print.c (pp_base_indent): Rename from pp_indent.\n\t* c-pretty-print.h (pp_c_pretty_print_flag)s: New datatype.\n\t(struct c_pretty_print_info): Add more fields.\n\t(pp_c_left_paren): Move to c-pretty-print.c.\n\t(pp_c_right_paren): Likewise.\n\t(pp_c_left_brace): Likewise.\n\t(pp_c_right_brace): Likewise.\n\t(pp_c_left_bracket): Likewise.\n\t(pp_c_right_bracket): Likewise.\n\t(pp_c_declarator): Declare.\n\t(pp_c_direct_declarator): Likewise.\n\t(pp_c_specifier_qualifier_list): Likewise.\n\t(pp_c_type_id): Likewise.\n\t* c-pretty-print.c (pp_c_cv_qualifier): Change prootype. Rework..\n\t(pp_c_type_qualifier_list): New.\n\t(pp_c_pointer): Likewise.\n\t(pp_c_parameter_type_list): Likewise.\n\t(pp_c_function_definition): Likewise.\n\t(pp_c_id_expression): Likewise.\n\t(pp_c_simple_type_specifier): Tidy.\n\t(pp_c_unary_expression): Likewise.\n\t(pp_c_expression): Likewise.\n\t(pp_c_pretty_printer_init): Likewise.\n\t(pp_c_specifier_qualifier_list): Rework..\n\t(pp_c_abstract_declarator): Likewise.\n\t(pp_c_postfix_expression): Likewise.\n\t(pp_c_primary_expression): Likewise.\n\t(pp_c_cast_expression): Likewise.\n\t(pp_c_direct_abstract_declarator): Likewise.\n\t(pp_c_storage_class_specifier): Likewise.\n\t(pp_c_function_specifier): Likewise.\n\t(pp_c_declaration_specifiers): Likewise.\n\t(pp_c_direct_declarator): Likewise.\n\t(pp_c_declarator): Likewise.\n\t(pp_c_declaration): Likewise.\n\t(pp_c_statement): Likewise.\n\t(pp_c_integer_constant): Rename from pp_c_integer_literal.\n\t(pp_c_character_constant): Rename from pp_c_character_literal.\n\t(pp_c_bool_constant): Rename from pp_c_bool_literal.\n\t(pp_c_enumeration_constant): Rename from pp_c_enumerator.\n\t(pp_c_floating_constant): Rename from pp_c_real_literal.\n\t(pp_c_constant): Rename from pp_c_literal.\n\t* c-lang.c: Include diagnostic.h and c-pretty-print.h\n\t(LANG_HOOKS_INITIALIZE_DIAGNOSTITCS): Define.\n\t(c_initialize_diagnostics): New.\n\t* Makefile.in (c-lang.o): Update dependency.\n\ncp/\n\n\t* error.c (dump_expr): Tidy.\n\t* cxx-pretty-print.c (pp_cxx_nonconsecutive_character): New.\n\t(pp_cxx_begin_template_argument_list): Likewise.\n\t(pp_cxx_end_template_argument_list): Likewise.\n\t(is_destructor_name): Likewise.\n\t(pp_cxx_unqualified_id): Likewise.\n\t(pp_cxx_qualified_id): Likewise.\n\t(pp_cxx_id_expression): Likewise.\n\t(pp_cxx_new_expression): Likewise.\n\t(pp_cxx_delete_expression): Likewise.\n\t(pp_cxx_pm_expression): Likewise.\n\t(pp_cxx_type_specifier): Rework.\n\t(pp_cxx_type_id): Likewise.\n\t(pp_cxx_primary_expression): Likewise.\n\t(pp_cxx_postfix_expression): Likewise.\n\t(pp_cxx_unary_expression): Likewise.\n\t(pp_cxx_multiplicative_expression): Likewise.\n\t(pp_cxx_conditional_expression): Likewise.\n\t(pp_cxx_assignment_expression): Likewise.\n\t(pp_cxx_pretty_printer_init): Tidy.\n\nFrom-SVN: r70299", "tree": {"sha": "6b4733cd709d9969e774e038f5d1924ffe164466", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b4733cd709d9969e774e038f5d1924ffe164466"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b780675e462fe50a27c972672a171927d37564d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b780675e462fe50a27c972672a171927d37564d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b780675e462fe50a27c972672a171927d37564d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b780675e462fe50a27c972672a171927d37564d/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bae39a73bedabd843cbd6adfe195fa2327ca89ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bae39a73bedabd843cbd6adfe195fa2327ca89ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bae39a73bedabd843cbd6adfe195fa2327ca89ea"}], "stats": {"total": 1764, "additions": 1432, "deletions": 332}, "files": [{"sha": "407250f70fdc2e7309bc93d5f70705ad23a207e4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b780675e462fe50a27c972672a171927d37564d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b780675e462fe50a27c972672a171927d37564d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4b780675e462fe50a27c972672a171927d37564d", "patch": "@@ -1,3 +1,52 @@\n+2003-08-10  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\t* pretty-print.c (pp_base_indent): Rename from pp_indent.\n+\t* c-pretty-print.h (pp_c_pretty_print_flag)s: New datatype.\n+\t(struct c_pretty_print_info): Add more fields.\n+\t(pp_c_left_paren): Move to c-pretty-print.c.\n+\t(pp_c_right_paren): Likewise.\n+\t(pp_c_left_brace): Likewise.\n+\t(pp_c_right_brace): Likewise.\n+\t(pp_c_left_bracket): Likewise.\n+\t(pp_c_right_bracket): Likewise.\n+\t(pp_c_declarator): Declare.\n+\t(pp_c_direct_declarator): Likewise.\n+\t(pp_c_specifier_qualifier_list): Likewise.\n+\t(pp_c_type_id): Likewise.\n+\t* c-pretty-print.c (pp_c_cv_qualifier): Change prootype. Rework..\n+\t(pp_c_type_qualifier_list): New.\n+\t(pp_c_pointer): Likewise.\n+\t(pp_c_parameter_type_list): Likewise.\n+\t(pp_c_function_definition): Likewise.\n+\t(pp_c_id_expression): Likewise.\n+\t(pp_c_simple_type_specifier): Tidy.\n+\t(pp_c_unary_expression): Likewise.\n+\t(pp_c_expression): Likewise.\n+\t(pp_c_pretty_printer_init): Likewise.\n+\t(pp_c_specifier_qualifier_list): Rework..\n+\t(pp_c_abstract_declarator): Likewise.\n+\t(pp_c_postfix_expression): Likewise.\n+\t(pp_c_primary_expression): Likewise.\n+\t(pp_c_cast_expression): Likewise.\n+\t(pp_c_direct_abstract_declarator): Likewise.\n+\t(pp_c_storage_class_specifier): Likewise.\n+\t(pp_c_function_specifier): Likewise.\n+\t(pp_c_declaration_specifiers): Likewise.\n+\t(pp_c_direct_declarator): Likewise.\n+\t(pp_c_declarator): Likewise.\n+\t(pp_c_declaration): Likewise.\n+\t(pp_c_statement): Likewise.\n+\t(pp_c_integer_constant): Rename from pp_c_integer_literal.\n+\t(pp_c_character_constant): Rename from pp_c_character_literal.\n+\t(pp_c_bool_constant): Rename from pp_c_bool_literal.\n+\t(pp_c_enumeration_constant): Rename from pp_c_enumerator.\n+\t(pp_c_floating_constant): Rename from pp_c_real_literal.\n+\t(pp_c_constant): Rename from pp_c_literal.\n+\t* c-lang.c: Include diagnostic.h and c-pretty-print.h\n+\t(LANG_HOOKS_INITIALIZE_DIAGNOSTITCS): Define.\n+\t(c_initialize_diagnostics): New.\n+\t* Makefile.in (c-lang.o): Update dependency.\n+\n 2003-08-10  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* c-typeck.c (digest_init): Add conversion for VECTOR_TYPEs."}, {"sha": "753e42bf2de36d00a5929b242676b0995dba557e", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b780675e462fe50a27c972672a171927d37564d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b780675e462fe50a27c972672a171927d37564d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=4b780675e462fe50a27c972672a171927d37564d", "patch": "@@ -1280,7 +1280,8 @@ c-decl.o : c-decl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n     $(LANGHOOKS_DEF_H)\n c-typeck.o : c-typeck.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(C_TREE_H) \\\n     $(TARGET_H) flags.h intl.h output.h $(EXPR_H) $(RTL_H) toplev.h $(TM_P_H)\n-c-lang.o : c-lang.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(C_TREE_H) \\\n+c-lang.o : c-lang.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n+    $(C_TREE_H) $(C_PRETTY_PRINT_H) $(DIAGNOSTIC_H) \\\n     $(GGC_H) langhooks.h $(LANGHOOKS_DEF_H) $(C_COMMON_H) gtype-c.h\n c-lex.o : c-lex.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n     $(RTL_H) debug.h $(C_TREE_H) $(C_COMMON_H) real.h c-incpath.h cppdefault.h \\"}, {"sha": "6504501559ffa429c30b30e1abe755089c3a3930", "filename": "gcc/c-lang.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b780675e462fe50a27c972672a171927d37564d/gcc%2Fc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b780675e462fe50a27c972672a171927d37564d/gcc%2Fc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lang.c?ref=4b780675e462fe50a27c972672a171927d37564d", "patch": "@@ -30,6 +30,10 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"ggc.h\"\n #include \"langhooks.h\"\n #include \"langhooks-def.h\"\n+#include \"diagnostic.h\"\n+#include \"c-pretty-print.h\"\n+\n+static void c_initialize_diagnostics (diagnostic_context *);\n \n enum c_language_kind c_language = clk_c;\n \n@@ -43,6 +47,8 @@ enum c_language_kind c_language = clk_c;\n #define LANG_HOOKS_FINISH c_common_finish\n #undef LANG_HOOKS_INIT_OPTIONS\n #define LANG_HOOKS_INIT_OPTIONS c_common_init_options\n+#undef LANG_HOOKS_INITIALIZE_DIAGNOSTITCS\n+#define LANG_HOOKS_INITIALIZE_DIAGNOSTITCS c_initialize_diagnostics\n #undef LANG_HOOKS_HANDLE_OPTION\n #define LANG_HOOKS_HANDLE_OPTION c_common_handle_option\n #undef LANG_HOOKS_MISSING_ARGUMENT\n@@ -218,4 +224,18 @@ finish_file (void)\n   c_objc_common_finish_file ();\n }\n \n+static void\n+c_initialize_diagnostics (diagnostic_context *context)\n+{\n+  pretty_printer *base = context->printer;\n+  c_pretty_printer pp = xmalloc (sizeof *pp);\n+  memcpy (pp_base (pp), base, sizeof (pretty_printer));\n+  pp_c_pretty_printer_init (pp);\n+  context->printer = (pretty_printer *) pp;\n+\n+  /* It is safe to free this object because it was previously malloc()'d.  */\n+  free (base);\n+}\n+\n+\n #include \"gtype-c.h\""}, {"sha": "ee4d2a419e769a5cea91f53f89f82f0d6dc61e3c", "filename": "gcc/c-pretty-print.c", "status": "modified", "additions": 707, "deletions": 204, "changes": 911, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b780675e462fe50a27c972672a171927d37564d/gcc%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b780675e462fe50a27c972672a171927d37564d/gcc%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.c?ref=4b780675e462fe50a27c972672a171927d37564d", "patch": "@@ -34,18 +34,85 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    much easier o add extensions and nifty pretty-printing effects that\n    takes expresssion or declaration contexts into account.  */\n \n+\n+#define pp_c_whitespace(PP)           \\\n+   do {                               \\\n+     pp_space (PP);                   \\\n+     pp_base (PP)->padding = pp_none; \\\n+   } while (0)\n+#define pp_c_maybe_whitespace(PP)            \\\n+   do {                                      \\\n+     if (pp_base (PP)->padding == pp_before) \\\n+       pp_c_whitespace (PP);                 \\\n+   } while (0)\n+\n+#define pp_c_left_paren(PP)           \\\n+  do {                                \\\n+    pp_left_paren (PP);               \\\n+    pp_base (PP)->padding = pp_none;  \\\n+  } while (0)\n+\n+#define pp_c_right_paren(PP)          \\\n+  do {                                \\\n+    pp_right_paren (PP);              \\\n+    pp_base (PP)->padding = pp_none;  \\\n+  } while (0)\n+\n+#define pp_c_left_brace(PP)           \\\n+  do {                                \\\n+    pp_left_brace (PP);               \\\n+    pp_base (PP)->padding = pp_none;  \\\n+  } while (0)\n+\n+#define pp_c_right_brace(PP)          \\\n+  do {                                \\\n+    pp_right_brace (PP);              \\\n+    pp_base (PP)->padding = pp_none;  \\\n+  } while (0)\n+\n+#define pp_c_left_bracket(PP)         \\\n+  do {                                \\\n+    pp_left_bracket (PP);             \\\n+    pp_base (PP)->padding = pp_none;  \\\n+  } while (0)\n+\n+#define pp_c_right_bracket(PP)        \\\n+  do {                                \\\n+    pp_right_bracket (PP);            \\\n+    pp_base (PP)->padding = pp_none;  \\\n+  } while (0)\n+\n+#define pp_c_arrow(PP)                \\\n+  do {                                \\\n+    pp_arrow (PP);                    \\\n+    pp_base (PP)->padding = pp_none;  \\\n+  } while (0)\n+\n+#define pp_c_star(PP)                 \\\n+  do {                                \\\n+    pp_star (PP);                     \\\n+    pp_base (PP)->padding = pp_none;  \\\n+  } while (0)\n+\n+#define pp_c_dot(PP)                  \\\n+  do {                                \\\n+    pp_dot (PP);                      \\\n+    pp_base (PP)->padding = pp_none;  \\\n+  } while (0)\n+\n+#define pp_c_semicolon(PP)            \\\n+  do {                                \\\n+    pp_semicolon (PP);                \\\n+    pp_base (PP)->padding = pp_none;  \\\n+  } while (0)\n+\n /* literal  */\n static void pp_c_char (c_pretty_printer, int);\n-static void pp_c_character_literal (c_pretty_printer, tree);\n-static void pp_c_bool_literal (c_pretty_printer, tree);\n-static bool pp_c_enumerator (c_pretty_printer, tree);\n-\n static void pp_c_primary_expression (c_pretty_printer, tree);\n \n /* postfix-expression  */\n static void pp_c_initializer_list (c_pretty_printer, tree);\n \n-static void pp_c_unary_expression (c_pretty_printer, tree);\n static void pp_c_multiplicative_expression (c_pretty_printer, tree);\n static void pp_c_additive_expression (c_pretty_printer, tree);\n static void pp_c_shift_expression (c_pretty_printer, tree);\n@@ -60,36 +127,71 @@ static void pp_c_assignment_expression (c_pretty_printer, tree);\n \n /* declarations.  */\n static void pp_c_declaration_specifiers (c_pretty_printer, tree);\n+static void pp_c_direct_abstract_declarator (c_pretty_printer, tree);\n static void pp_c_init_declarator (c_pretty_printer, tree);\n-static void pp_c_declarator (c_pretty_printer, tree);\n-static void pp_c_direct_declarator (c_pretty_printer, tree);\n-static void pp_c_abstract_declarator (c_pretty_printer, tree);\n-static void pp_c_specifier_qualifier_list (c_pretty_printer, tree);\n static void pp_c_simple_type_specifier (c_pretty_printer, tree);\n static void pp_c_parameter_declaration (c_pretty_printer, tree);\n-static void pp_c_type_id (c_pretty_printer, tree);\n static void pp_c_storage_class_specifier (c_pretty_printer, tree);\n static void pp_c_function_specifier (c_pretty_printer, tree);\n \n \n \f\n /* Declarations.  */\n \n-/* Print out CV-qualifiers.  Take care of possible extensions.\n-     cv-qualifier:\n-        const\n-        volatile\n-        restrict\n-        __restrict__   */\n+static void\n+pp_c_cv_qualifier (c_pretty_printer pp, const char *cv)\n+{\n+  const char *p = pp_last_position_in_text (pp);\n+  if (p != NULL && *p == '*')\n+    pp_c_whitespace (pp);\n+  pp_c_identifier (pp, cv);\n+}\n+\n+/* C++ cv-qualifiers are called type-qualifiers in C.  Print out the\n+   cv-qualifiers of T.  If T is a declaration then it is the cv-qualifier\n+   of its type.  Take care of possible extensions.\n+   cv-qualifier:\n+       const\n+       volatile\n+       restrict\n+       __restrict__   */\n void\n-pp_c_cv_qualifier (c_pretty_printer ppi, int cv)\n+pp_c_type_qualifier_list (c_pretty_printer pp, tree t)\n {\n-  if (cv & TYPE_QUAL_CONST)\n-    pp_c_identifier (ppi, \"const\");\n-  if (cv & TYPE_QUAL_VOLATILE)\n-    pp_c_identifier (ppi, \"volatile\");\n-  if (cv & TYPE_QUAL_RESTRICT)\n-    pp_c_identifier (ppi, flag_isoc99 ? \"restrict\" : \"__restrict__\");\n+   int qualifiers;\n+   \n+  if (!TYPE_P (t))\n+    t = TREE_TYPE (t);\n+\n+  qualifiers = TYPE_QUALS (t);\n+  if (qualifiers & TYPE_QUAL_CONST)\n+    pp_c_cv_qualifier (pp, \"const\");\n+  if (qualifiers & TYPE_QUAL_VOLATILE)\n+    pp_c_cv_qualifier (pp, \"volatile\");\n+  if (qualifiers & TYPE_QUAL_RESTRICT)\n+    pp_c_cv_qualifier (pp, flag_isoc99 ? \"restrict\" : \"__restrict__\");\n+}\n+\n+/* pointer:\n+      * type-qualifier-list(opt)\n+      * type-qualifier-list(opt) pointer  */\n+static void\n+pp_c_pointer (c_pretty_printer pp, tree t)\n+{\n+  if (!TYPE_P (t) && TREE_CODE (t) != TYPE_DECL)\n+    t = TREE_TYPE (t);\n+  switch (TREE_CODE (t))\n+    {\n+    case POINTER_TYPE:\n+      if (TREE_CODE (TREE_TYPE (t)) == POINTER_TYPE)\n+        pp_c_pointer (pp, TREE_TYPE (t));\n+      pp_c_star (pp);\n+      pp_c_type_qualifier_list (pp, t);\n+      break;\n+\n+    default:\n+      pp_unsupported_tree (pp, t);\n+    }\n }\n \n /*\n@@ -115,7 +217,12 @@ pp_c_cv_qualifier (c_pretty_printer ppi, int cv)\n static void\n pp_c_simple_type_specifier (c_pretty_printer ppi, tree t)\n {\n-  const enum tree_code code = TREE_CODE (t);\n+  enum tree_code code;\n+\n+  if (DECL_P (t) && TREE_CODE (t) != TYPE_DECL)\n+    t = TREE_TYPE (t);\n+\n+  code = TREE_CODE (t);\n   switch (code)\n     {\n     case ERROR_MARK:\n@@ -137,7 +244,7 @@ pp_c_simple_type_specifier (c_pretty_printer ppi, tree t)\n     case CHAR_TYPE:\n     case INTEGER_TYPE:\n     case REAL_TYPE:\n-      pp_c_tree_identifier (ppi, DECL_NAME (t));\n+      pp_c_simple_type_specifier (ppi, TYPE_NAME (t));\n       break;\n \n     case COMPLEX_TYPE:\n@@ -151,7 +258,7 @@ pp_c_simple_type_specifier (c_pretty_printer ppi, tree t)\n \n     case TYPE_DECL:\n       if (DECL_NAME (t))\n-\tpp_c_tree_identifier (ppi, DECL_NAME (t));\n+\tpp_id_expression (ppi, t);\n       else\n \tpp_c_identifier (ppi, \"<typedef-error>\");\n       break;\n@@ -169,47 +276,196 @@ pp_c_simple_type_specifier (c_pretty_printer ppi, tree t)\n \tpp_c_identifier (ppi, \"<tag-error>\");\n \n       if (TYPE_NAME (t))\n-\tpp_c_tree_identifier (ppi, TYPE_NAME (t));\n+\tpp_id_expression (ppi, TYPE_NAME (t));\n       else\n \tpp_c_identifier (ppi, \"<anonymous>\");\n       break;\n \n+    case POINTER_TYPE:\n+    case ARRAY_TYPE:\n+    case FUNCTION_TYPE:\n+      pp_c_simple_type_specifier (ppi, TREE_TYPE (t));\n+      break;\n+\n     default:\n       pp_unsupported_tree (ppi, t);\n+      break;\n     }\n }\n \n /* specifier-qualifier-list:\n       type-specifier specifier-qualifier-list-opt\n-      cv-qualifier specifier-qualifier-list-opt  */\n-static inline void\n-pp_c_specifier_qualifier_list (c_pretty_printer ppi, tree t)\n+      cv-qualifier specifier-qualifier-list-opt\n+\n+\n+  Implementation note:  Because of the non-linearities in array or\n+  function declarations, this routinie prints not just the\n+  specifier-qualifier-list of such entities or types of such entities,\n+  but also the 'pointer' production part of their declarators.  The\n+  remaining part is done by pp_declarator or pp_c_abstract_declarator.  */\n+void\n+pp_c_specifier_qualifier_list (c_pretty_printer pp, tree t)\n {\n-  pp_c_simple_type_specifier (ppi, TYPE_MAIN_VARIANT (TREE_TYPE (t)));\n-  pp_c_cv_qualifier (ppi, TYPE_QUALS (t));\n+  if (TREE_CODE (t) != POINTER_TYPE)\n+    pp_c_type_qualifier_list (pp, t);\n+  switch (TREE_CODE (t))\n+    {\n+    case POINTER_TYPE:\n+      {\n+        /* Get the types-specifier of this type.  */\n+        tree pointee = TREE_TYPE (t);\n+        while (TREE_CODE (pointee) == POINTER_TYPE)\n+          pointee = TREE_TYPE (pointee);\n+        pp_c_specifier_qualifier_list (pp, pointee);\n+        if (TREE_CODE (pointee) == ARRAY_TYPE\n+            || TREE_CODE (pointee) == FUNCTION_TYPE)\n+          {\n+            pp_c_whitespace (pp);\n+            pp_c_left_paren (pp);\n+          }\n+        pp_c_pointer (pp, t);\n+        if (TREE_CODE (pointee) != FUNCTION_TYPE\n+            && TREE_CODE (pointee) != ARRAY_TYPE)\n+          pp_c_whitespace (pp);\n+      }\n+      break;\n+\n+    case FUNCTION_TYPE:\n+    case ARRAY_TYPE:\n+      pp_c_specifier_qualifier_list (pp, TREE_TYPE (t));\n+      break;\n+\n+    case VECTOR_TYPE:\n+    case COMPLEX_TYPE:\n+      pp_c_specifier_qualifier_list (pp, TREE_TYPE (t));\n+      pp_space (pp);\n+      pp_c_simple_type_specifier (pp, t);\n+      break;\n+\n+    default:\n+      pp_c_simple_type_specifier (pp, t);\n+      break;\n+    }\n }\n \n+/* parameter-type-list:\n+      parameter-list\n+      parameter-list , ...\n+\n+   parameter-list:\n+      parameter-declaration\n+      parameter-list , parameter-declaration\n+\n+   parameter-declaration:\n+      declaration-specifiers declarator\n+      declaration-specifiers abstract-declarator(opt)   */\n static void\n-pp_c_abstract_declarator (c_pretty_printer ppi, tree t)\n+pp_c_parameter_type_list (c_pretty_printer pp, tree t)\n {\n-  pp_unsupported_tree (ppi, t);\n+  pp_c_left_paren (pp);\n+  if (t == void_list_node)\n+    pp_c_identifier (pp, \"void\");\n+  else\n+    {\n+      bool first = true;\n+      bool want_parm_decl = t && DECL_P (t);\n+      for ( ; t != NULL && t != void_list_node; t = TREE_CHAIN (t))\n+        {\n+          if (!first)\n+            pp_separate_with (pp, ',');\n+          first = false;\n+          pp_declaration_specifiers (pp, want_parm_decl ? t : TREE_VALUE (t));\n+          if (want_parm_decl)\n+            pp_declarator (pp, t);\n+          else\n+            pp_abstract_declarator (pp, TREE_VALUE (t));\n+        }\n+    }\n+  pp_c_right_paren (pp);\n }\n \n-\n+/* abstract-declarator:\n+      pointer\n+      pointer(opt) direct-abstract-declarator  */\n static inline void\n+pp_c_abstract_declarator (c_pretty_printer pp, tree t)\n+{\n+  if (TREE_CODE (t) == POINTER_TYPE)\n+    {\n+      if (TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE\n+          || TREE_CODE (TREE_TYPE (t)) == FUNCTION_TYPE)\n+        pp_c_right_paren (pp);\n+      t = TREE_TYPE (t);\n+    }\n+\n+  pp_c_direct_abstract_declarator (pp, t);\n+}\n+\n+/* direct-abstract-declarator:\n+      ( abstract-declarator )\n+      direct-abstract-declarator(opt) [ assignment-expression(opt) ]\n+      direct-abstract-declarator(opt) [ * ]\n+      direct-abstract-declarator(opt) ( parameter-type-list(opt) )  */\n+static void\n+pp_c_direct_abstract_declarator (c_pretty_printer pp, tree t)\n+{\n+  switch (TREE_CODE (t))\n+    {\n+    case POINTER_TYPE:\n+      pp_c_abstract_declarator (pp, t);\n+      break;\n+      \n+    case FUNCTION_TYPE:\n+      pp_c_parameter_type_list (pp, TYPE_ARG_TYPES (t));\n+      pp_c_direct_abstract_declarator (pp, TREE_TYPE (t));\n+      break;\n+\n+    case ARRAY_TYPE:\n+      pp_c_left_bracket (pp);\n+      if (TYPE_DOMAIN (t))\n+        pp_c_expression (pp, TYPE_MAX_VALUE (TYPE_DOMAIN (t)));\n+      pp_c_right_bracket (pp);\n+      pp_c_direct_abstract_declarator (pp, TREE_TYPE (t));\n+      break;\n+\n+    case IDENTIFIER_NODE:\n+    case VOID_TYPE:\n+    case BOOLEAN_TYPE:\n+    case INTEGER_TYPE:\n+    case REAL_TYPE:\n+    case ENUMERAL_TYPE:\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+    case VECTOR_TYPE:\n+    case COMPLEX_TYPE:\n+    case TYPE_DECL:\n+      break;\n+      \n+    default:\n+      pp_unsupported_tree (pp, t);\n+      break;\n+    }\n+}\n+\n+void\n pp_c_type_id (c_pretty_printer ppi, tree t)\n {\n   pp_c_specifier_qualifier_list (ppi, t);\n-  pp_c_abstract_declarator (ppi, t);\n+  pp_abstract_declarator (ppi, t);\n }\n \n static inline void\n pp_c_storage_class_specifier (c_pretty_printer pp, tree t)\n {\n   if (TREE_CODE (t) == TYPE_DECL)\n     pp_c_identifier (pp, \"typedef\");\n-  else if (DECL_REGISTER (t))\n-    pp_c_identifier (pp, \"register\");\n+  else if (DECL_P (t))\n+    {\n+      if (DECL_REGISTER (t))\n+        pp_c_identifier (pp, \"register\");\n+      else if (TREE_STATIC (t) && TREE_CODE (t) == VAR_DECL)\n+        pp_c_identifier (pp, \"static\");\n+    }\n }\n \n static inline void\n@@ -219,27 +475,108 @@ pp_c_function_specifier (c_pretty_printer pp, tree t)\n     pp_c_identifier (pp, \"inline\");\n }\n \n+/* declaration-specifiers:\n+      storage-class-specifier declaration-specifiers(opt)\n+      type-specifier declaration-specifiers(opt)\n+      type-qualifier declaration-specifiers(opt)\n+      function-specifier declaration-specifiers(opt)  */\n static inline void\n pp_c_declaration_specifiers (c_pretty_printer pp, tree t)\n {\n-  pp_c_storage_class_specifier (pp, t);\n-  pp_c_function_specifier (pp, t);\n-  pp_type_specifier (pp, TYPE_MAIN_VARIANT (TREE_TYPE (t)));\n-  pp_c_cv_qualifier (pp, TYPE_QUALS (TREE_TYPE (t)));\n+  pp_storage_class_specifier (pp, t);\n+  pp_function_specifier (pp, t);\n+  pp_c_specifier_qualifier_list (pp, DECL_P (t) ?  TREE_TYPE (t) : t);\n }\n \n-static inline void\n+/* direct-declarator\n+      identifier\n+      ( declarator )\n+      direct-declarator [ type-qualifier-list(opt) assignment-expression(opt) ]\n+      direct-declarator [ static type-qualifier-list(opt) assignment-expression(opt)]\n+      direct-declarator [ type-qualifier-list static assignment-exression ]\n+      direct-declarator [ type-qualifier-list * ]\n+      direct-declaratpr ( parameter-type-list )\n+      direct-declarator ( identifier-list(opt) )  */\n+void\n pp_c_direct_declarator (c_pretty_printer pp, tree t)\n {\n-  pp_unsupported_tree (pp, t);\n+  switch (TREE_CODE (t))\n+    {\n+    case VAR_DECL:\n+    case PARM_DECL:\n+    case TYPE_DECL:\n+    case FIELD_DECL:\n+    case LABEL_DECL:\n+      pp_c_tree_identifier (pp, DECL_NAME (t));\n+    case ARRAY_TYPE:\n+    case POINTER_TYPE:\n+      pp_abstract_declarator (pp, TREE_TYPE (t));\n+      break;\n+\n+    case FUNCTION_TYPE:\n+      pp_c_parameter_type_list (pp, TYPE_ARG_TYPES (t));\n+      pp_c_abstract_declarator (pp, TREE_TYPE (t));\n+      break;\n+\n+    case FUNCTION_DECL:\n+      pp_c_tree_identifier (pp, DECL_NAME (t));\n+      if (pp_c_base (pp)->flags & pp_c_flag_abstract)\n+        pp_c_abstract_declarator (pp, TREE_TYPE (t));\n+      else\n+        {\n+          pp_c_parameter_type_list (pp, DECL_ARGUMENTS (t));\n+          pp_c_abstract_declarator (pp, TREE_TYPE (TREE_TYPE (t)));\n+        }\n+      break;\n+\n+    case INTEGER_TYPE:\n+    case REAL_TYPE:\n+    case ENUMERAL_TYPE:\n+    case UNION_TYPE:\n+    case RECORD_TYPE:\n+      break;\n+\n+    default:\n+      pp_unsupported_tree (pp, t);\n+      break;\n+    }\n }\n \n-static inline void\n+\n+/* declarator:\n+      pointer(opt)  direct-declarator   */\n+void\n pp_c_declarator (c_pretty_printer pp, tree t)\n {\n-  pp_unsupported_tree (pp, t);\n+  switch (TREE_CODE (t))\n+    {\n+    case INTEGER_TYPE:\n+    case REAL_TYPE:\n+    case ENUMERAL_TYPE:\n+    case UNION_TYPE:\n+    case RECORD_TYPE:\n+      break;\n+\n+    case VAR_DECL:\n+    case PARM_DECL:\n+    case FIELD_DECL:\n+    case ARRAY_TYPE:\n+    case FUNCTION_TYPE:\n+    case FUNCTION_DECL:\n+    case TYPE_DECL:\n+      pp_direct_declarator (pp, t);\n+    break;\n+\n+    \n+    default:\n+      pp_unsupported_tree (pp, t);\n+      break;\n+    }\n }\n \n+/* init-declarator:\n+      declarator:\n+      declarator = initializer   */\n static inline void\n pp_c_init_declarator (c_pretty_printer pp, tree t)\n {\n@@ -253,6 +590,9 @@ pp_c_init_declarator (c_pretty_printer pp, tree t)\n     }\n }\n \n+/* declaration:\n+      declaration-specifiers init-declarator-list(opt) ;  */\n+\n void\n pp_c_declaration (c_pretty_printer pp, tree t)\n {\n@@ -293,6 +633,19 @@ pp_c_attributes (c_pretty_printer pp, tree attributes)\n   pp_c_right_paren (pp);\n }\n \n+/* function-definition:\n+      declaration-specifiers declarator compound-statement  */\n+void\n+pp_c_function_definition (c_pretty_printer pp, tree t)\n+{\n+  pp_declaration_specifiers (pp, t);\n+  pp_declarator (pp, t);\n+  pp_needs_newline (pp) = true;\n+  pp_statement (pp, DECL_SAVED_TREE (t));\n+  pp_newline (pp);\n+  pp_flush (pp);\n+}\n+\n \f\n /* Expressions.  */\n \n@@ -354,52 +707,77 @@ pp_c_string_literal (c_pretty_printer ppi, tree s)\n   pp_doublequote (ppi);\n }\n \n+static void\n+pp_c_integer_constant (c_pretty_printer pp, tree i)\n+{\n+  if (host_integerp (i, 0))\n+    pp_wide_integer (pp, TREE_INT_CST_LOW (i));\n+  else\n+    {\n+      if (tree_int_cst_sgn (i) < 0)\n+        {\n+          pp_c_char (pp, '-');\n+          i = build_int_2 (-TREE_INT_CST_LOW (i),\n+                           ~TREE_INT_CST_HIGH (i) + !TREE_INT_CST_LOW (i));\n+        }\n+      sprintf (pp_buffer (pp)->digit_buffer,\n+               HOST_WIDE_INT_PRINT_DOUBLE_HEX,\n+               TREE_INT_CST_HIGH (i), TREE_INT_CST_LOW (i));\n+      pp_string (pp, pp_buffer (pp)->digit_buffer);\n+    }\n+}\n+\n /* Print out a CHARACTER literal.  */\n static inline void\n-pp_c_character_literal (c_pretty_printer ppi, tree c)\n+pp_c_character_constant (c_pretty_printer pp, tree c)\n {\n   tree type = TREE_TYPE (c);\n-  pp_quote (ppi);\n+  if (type == wchar_type_node)\n+    pp_character (pp, 'L'); \n+  pp_quote (pp);\n   if (host_integerp (c, TREE_UNSIGNED (type)))\n-    pp_c_char (ppi, tree_low_cst (c, TREE_UNSIGNED (type)));\n+    pp_c_char (pp, tree_low_cst (c, TREE_UNSIGNED (type)));\n   else\n-    pp_scalar (ppi, \"\\\\x%x\", (unsigned) TREE_INT_CST_LOW (c));\n-  pp_quote (ppi);\n+    pp_scalar (pp, \"\\\\x%x\", (unsigned) TREE_INT_CST_LOW (c));\n+  pp_quote (pp);\n }\n \n /* Print out a BOOLEAN literal.  */\n-void\n-pp_c_bool_literal (c_pretty_printer ppi, tree b)\n+static void\n+pp_c_bool_constant (c_pretty_printer pp, tree b)\n {\n-  if (b == boolean_false_node || integer_zerop (b))\n+  if (b == boolean_false_node)\n     {\n       if (c_dialect_cxx ())\n-\tpp_c_identifier (ppi, \"false\");\n+\tpp_c_identifier (pp, \"false\");\n       else if (flag_isoc99)\n-\tpp_c_identifier (ppi, \"_False\");\n+\tpp_c_identifier (pp, \"_False\");\n       else\n-\tpp_unsupported_tree (ppi, b);\n+\tpp_unsupported_tree (pp, b);\n     }\n   else if (b == boolean_true_node)\n     {\n       if (c_dialect_cxx ())\n-\tpp_c_identifier (ppi, \"true\");\n+\tpp_c_identifier (pp, \"true\");\n       else if (flag_isoc99)\n-\tpp_c_identifier (ppi, \"_True\");\n+\tpp_c_identifier (pp, \"_True\");\n       else\n-\tpp_unsupported_tree (ppi, b);\n+\tpp_unsupported_tree (pp, b);\n     }\n+  else if (TREE_CODE (b) == INTEGER_CST)\n+    pp_c_integer_constant (pp, b);\n   else\n-    pp_unsupported_tree (ppi, b);\n+    pp_unsupported_tree (pp, b);\n }\n \n /* Attempt to print out an ENUMERATOR.  Return true on success.  Else return\n    false; that means the value was obtained by a cast, in which case\n    print out the type-id part of the cast-expression -- the casted value\n    is then printed by pp_c_integer_literal.  */\n static bool\n-pp_c_enumerator (c_pretty_printer ppi, tree e)\n+pp_c_enumeration_constant (c_pretty_printer ppi, tree e)\n {\n+  bool value_is_named = true;\n   tree type = TREE_TYPE (e);\n   tree value;\n \n@@ -410,86 +788,81 @@ pp_c_enumerator (c_pretty_printer ppi, tree e)\n     ;\n \n   if (value != NULL_TREE)\n-    pp_c_tree_identifier (ppi, TREE_PURPOSE (value));\n+    pp_id_expression (ppi, TREE_PURPOSE (value));\n   else\n     {\n       /* Value must have been cast.  */\n       pp_c_left_paren (ppi);\n       pp_type_id (ppi, type);\n       pp_c_right_paren (ppi);\n-      return false;\n+      value_is_named = false;\n     }\n \n-  return true;\n-}\n-\n-/* Print out an INTEGER constant value.  */\n-void\n-pp_c_integer_literal (c_pretty_printer ppi, tree i)\n-{\n-  tree type = TREE_TYPE (i);\n-\n-  if (type == boolean_type_node)\n-    pp_c_bool_literal (ppi, i);\n-  else if (type == char_type_node)\n-    pp_c_character_literal (ppi, i);\n-  else if (TREE_CODE (type) == ENUMERAL_TYPE\n-\t   && pp_c_enumerator (ppi, i))\n-    ;\n-  else\n-    {\n-      if (host_integerp (i, 0))\n-\tpp_wide_integer (ppi, TREE_INT_CST_LOW (i));\n-      else\n-\t{\n-\t  if (tree_int_cst_sgn (i) < 0)\n-\t    {\n-\t      pp_c_char (ppi, '-');\n-\t      i = build_int_2 (-TREE_INT_CST_LOW (i),\n-\t\t\t       ~TREE_INT_CST_HIGH (i) + !TREE_INT_CST_LOW (i));\n-\t      sprintf (pp_buffer (ppi)->digit_buffer,\n-\t\t       HOST_WIDE_INT_PRINT_DOUBLE_HEX,\n-\t\t       TREE_INT_CST_HIGH (i), TREE_INT_CST_LOW (i));\n-\t      pp_string (ppi, pp_buffer (ppi)->digit_buffer);\n-\t    }\n-\t}\n-    }\n+  return value_is_named;\n }\n \n /* Print out a REAL value.  */\n-void\n-pp_c_real_literal (c_pretty_printer ppi, tree r)\n+static inline void\n+pp_c_floating_constant (c_pretty_printer pp, tree r)\n {\n-  real_to_decimal (pp_buffer (ppi)->digit_buffer, &TREE_REAL_CST (r),\n-\t\t   sizeof (pp_buffer (ppi)->digit_buffer), 0, 1);\n-  pp_string (ppi, pp_buffer(ppi)->digit_buffer);\n+  real_to_decimal (pp_buffer (pp)->digit_buffer, &TREE_REAL_CST (r),\n+\t\t   sizeof (pp_buffer (pp)->digit_buffer), 0, 1);\n+  pp_string (pp, pp_buffer(pp)->digit_buffer);\n }\n \n-\n+/* constant:\n+      integer-constant\n+      floating-constant\n+      enumeration-constant\n+      chatracter-constant   */\n void\n-pp_c_literal (c_pretty_printer ppi, tree e)\n+pp_c_constant (c_pretty_printer pp, tree e)\n {\n   switch (TREE_CODE (e))\n     {\n     case INTEGER_CST:\n-      pp_c_integer_literal (ppi, e);\n+      {\n+        tree type = TREE_TYPE (e);\n+        if (type == boolean_type_node)\n+          pp_c_bool_constant (pp, e);\n+        else if (type == char_type_node)\n+          pp_c_character_constant (pp, e);\n+        else if (TREE_CODE (type) == ENUMERAL_TYPE\n+                 && pp_c_enumeration_constant (pp, e))\n+          ; \n+        else \n+          pp_c_integer_constant (pp, e);\n+      }\n       break;\n \n     case REAL_CST:\n-      pp_c_real_literal (ppi, e);\n+      pp_c_floating_constant (pp, e);\n       break;\n \n     case STRING_CST:\n-      pp_c_string_literal (ppi, e);\n+      pp_c_string_literal (pp, e);\n       break;\n \n     default:\n-      pp_unsupported_tree (ppi, e);\n+      pp_unsupported_tree (pp, e);\n       break;\n     }\n }\n \n-/* Pretty-print a C primary-expression.  */\n+void\n+pp_c_identifier (c_pretty_printer pp, const char *id)\n+{\n+  pp_c_maybe_whitespace (pp);            \n+  pp_identifier (pp, id);  \n+  pp_base (pp)->padding = pp_before;\n+}\n+\n+/* Pretty-print a C primary-expression.\n+   primary-expression:\n+      identifier\n+      constant\n+      string-literal\n+      ( expression )   */\n static void\n pp_c_primary_expression (c_pretty_printer ppi, tree e)\n {\n@@ -518,15 +891,15 @@ pp_c_primary_expression (c_pretty_printer ppi, tree e)\n     case INTEGER_CST:\n     case REAL_CST:\n     case STRING_CST:\n-      pp_c_literal (ppi, e);\n+      pp_c_constant (ppi, e);\n       break;\n \n     case TARGET_EXPR:\n       pp_c_left_paren (ppi);\n       pp_c_identifier (ppi, \"__builtin_memcpy\");\n       pp_c_left_paren (ppi);\n       pp_ampersand (ppi);\n-      pp_c_primary_expression (ppi, TREE_OPERAND (e, 0));\n+      pp_primary_expression (ppi, TREE_OPERAND (e, 0));\n       pp_separate_with (ppi, ',');\n       pp_ampersand (ppi);\n       pp_initializer (ppi, TREE_OPERAND (e, 1));\n@@ -544,15 +917,20 @@ pp_c_primary_expression (c_pretty_printer ppi, tree e)\n       break;\n \n     default:\n-      /*  Make sure this call won't cause any infinite loop.  */\n+      /* FIXME:  Make sure we won't get into an infinie loop.  */\n       pp_c_left_paren (ppi);\n       pp_c_expression (ppi, e);\n       pp_c_right_paren (ppi);\n       break;\n     }\n }\n \n-/* Print out a C initializer -- also support C compound-literals.  */\n+/* Print out a C initializer -- also support C compound-literals.\n+   initializer:\n+      assignment-expression:\n+      { initializer-list }\n+      { initializer-list , }   */\n+\n void\n pp_c_initializer (c_pretty_printer ppi, tree e)\n {\n@@ -561,9 +939,9 @@ pp_c_initializer (c_pretty_printer ppi, tree e)\n       enum tree_code code = TREE_CODE (TREE_TYPE (e));\n       if (code == RECORD_TYPE || code == UNION_TYPE || code == ARRAY_TYPE)\n \t{\n-\t  pp_left_brace (ppi);\n+\t  pp_c_left_brace (ppi);\n \t  pp_c_initializer_list (ppi, e);\n-\t  pp_right_brace (ppi);\n+\t  pp_c_right_brace (ppi);\n \t}\n       else\n \tpp_unsupported_tree (ppi, TREE_OPERAND (e, 1));\n@@ -572,6 +950,20 @@ pp_c_initializer (c_pretty_printer ppi, tree e)\n     pp_assignment_expression (ppi, e);\n }\n \n+/* initializer-list:\n+      designation(opt) initializer\n+      initializer-list , designation(opt) initializer\n+\n+   designation:\n+      designator-list =\n+\n+   designator-list:\n+      designator\n+      designator-list designator\n+\n+   designator:\n+      [ constant-expression ]\n+      identifier   */\n static void\n pp_c_initializer_list (c_pretty_printer ppi, tree e)\n {\n@@ -580,19 +972,19 @@ pp_c_initializer_list (c_pretty_printer ppi, tree e)\n \n   if (code == RECORD_TYPE || code == UNION_TYPE || code == ARRAY_TYPE)\n     {\n-      tree init = TREE_OPERAND (e, 1);\n+      tree init = TREE_OPERAND (e, 0);\n       for (; init != NULL_TREE; init = TREE_CHAIN (init))\n \t{\n \t  if (code == RECORD_TYPE || code == UNION_TYPE)\n \t    {\n-\t      pp_dot (ppi);\n+\t      pp_c_dot (ppi);\n \t      pp_c_primary_expression (ppi, TREE_PURPOSE (init));\n \t    }\n \t  else\n \t    {\n \t      pp_c_left_bracket (ppi);\n \t      if (TREE_PURPOSE (init))\n-\t\tpp_c_literal (ppi, TREE_PURPOSE (init));\n+\t\tpp_c_constant (ppi, TREE_PURPOSE (init));\n \t      pp_c_right_bracket (ppi);\n \t    }\n \t  pp_c_whitespace (ppi);\n@@ -607,6 +999,44 @@ pp_c_initializer_list (c_pretty_printer ppi, tree e)\n     pp_unsupported_tree (ppi, type);\n }\n \n+/*  This is a convenient function, used to bridge gap between C and C++\n+    grammars.\n+\n+    id-expression:\n+       identifier  */\n+void\n+pp_c_id_expression (c_pretty_printer pp, tree t)\n+{\n+  switch (TREE_CODE (t))\n+    {\n+    case VAR_DECL:\n+    case PARM_DECL:\n+    case CONST_DECL:\n+    case TYPE_DECL:\n+    case FUNCTION_DECL:\n+    case FIELD_DECL:\n+    case LABEL_DECL:\n+      t = DECL_NAME (t);\n+    case IDENTIFIER_NODE:\n+      pp_c_tree_identifier (pp, t);\n+      break;\n+\n+    default:\n+      pp_unsupported_tree (pp, t);\n+      break;\n+    }\n+}\n+\n+/* postfix-expression:\n+      primary-expression\n+      postfix-expression [ expression ]\n+      postfix-expression ( argument-expression-list(opt) )\n+      postfix-expression . identifier\n+      postfix-expression -> identifier\n+      postfix-expression ++\n+      postfix-expression --\n+      ( type-name ) { initializer-list }\n+      ( type-name ) { initializer-list , }  */\n void\n pp_c_postfix_expression (c_pretty_printer ppi, tree e)\n {\n@@ -621,7 +1051,7 @@ pp_c_postfix_expression (c_pretty_printer ppi, tree e)\n \n     case ARROW_EXPR:\n       pp_postfix_expression (ppi, TREE_OPERAND (e, 0));\n-      pp_arrow (ppi);\n+      pp_c_arrow (ppi);\n       break;\n \n     case ARRAY_REF:\n@@ -653,12 +1083,12 @@ pp_c_postfix_expression (c_pretty_printer ppi, tree e)\n \tif (TREE_CODE (object) == INDIRECT_REF)\n \t  {\n \t    pp_postfix_expression (ppi, TREE_OPERAND (object, 0));\n-\t    pp_arrow (ppi);\n+\t    pp_c_arrow (ppi);\n \t  }\n \telse\n \t  {\n \t    pp_postfix_expression (ppi, object);\n-\t    pp_dot (ppi);\n+\t    pp_c_dot (ppi);\n \t  }\n \tpp_c_expression (ppi, TREE_OPERAND (e, 1));\n       }\n@@ -670,7 +1100,7 @@ pp_c_postfix_expression (c_pretty_printer ppi, tree e)\n       pp_c_left_paren (ppi);\n       pp_type_id (ppi, TREE_TYPE (e));\n       pp_c_right_paren (ppi);\n-      pp_left_brace (ppi);\n+      pp_c_left_brace (ppi);\n \n       if (code == COMPLEX_CST)\n \t{\n@@ -687,7 +1117,7 @@ pp_c_postfix_expression (c_pretty_printer ppi, tree e)\n \t  pp_c_expression (ppi, TREE_OPERAND (e, 1));\n \t}\n \n-      pp_right_brace (ppi);\n+      pp_c_right_brace (ppi);\n       break;\n \n     case COMPOUND_LITERAL_EXPR:\n@@ -706,6 +1136,14 @@ pp_c_postfix_expression (c_pretty_printer ppi, tree e)\n       pp_c_right_paren (ppi);\n       break;\n \n+    case ADDR_EXPR:\n+      if (TREE_CODE (TREE_OPERAND (e, 0)) == FUNCTION_DECL)\n+        {\n+          pp_c_id_expression (ppi, TREE_OPERAND (e, 0));\n+          break;\n+        }\n+      /* else fall through.   */\n+\n     default:\n       pp_primary_expression (ppi, e);\n       break;\n@@ -741,7 +1179,7 @@ pp_c_expression_list (c_pretty_printer ppi, tree e)\n       __alignof__ ( type-id )\n       __real__ unary-expression\n       __imag__ unary-expression  */\n-static void\n+void\n pp_c_unary_expression (c_pretty_printer ppi, tree e)\n {\n   enum tree_code code = TREE_CODE (e);\n@@ -759,10 +1197,11 @@ pp_c_unary_expression (c_pretty_printer ppi, tree e)\n     case BIT_NOT_EXPR:\n     case TRUTH_NOT_EXPR:\n     case CONJ_EXPR:\n-      if (code == ADDR_EXPR)\n+      /* String literal are used by address.  */\n+      if (code == ADDR_EXPR && TREE_CODE (TREE_OPERAND (e, 0)) != STRING_CST)\n \tpp_ampersand (ppi);\n       else if (code == INDIRECT_REF)\n-\tpp_star (ppi);\n+\tpp_c_star (ppi);\n       else if (code == NEGATE_EXPR)\n \tpp_minus (ppi);\n       else if (code == BIT_NOT_EXPR || code == CONJ_EXPR)\n@@ -783,7 +1222,7 @@ pp_c_unary_expression (c_pretty_printer ppi, tree e)\n \t  pp_c_right_paren (ppi);\n \t}\n       else\n-\tpp_c_unary_expression (ppi, TREE_OPERAND (e, 0));\n+\tpp_unary_expression (ppi, TREE_OPERAND (e, 0));\n       break;\n \n     case REALPART_EXPR:\n@@ -802,15 +1241,20 @@ pp_c_unary_expression (c_pretty_printer ppi, tree e)\n void\n pp_c_cast_expression (c_pretty_printer ppi, tree e)\n {\n-  if (TREE_CODE (e) == CONVERT_EXPR || TREE_CODE (e) == FLOAT_EXPR)\n+  switch (TREE_CODE (e))\n     {\n+    case FLOAT_EXPR:\n+    case FIX_TRUNC_EXPR:\n+    case CONVERT_EXPR:\n       pp_c_left_paren (ppi);\n       pp_type_id (ppi, TREE_TYPE (e));\n       pp_c_right_paren (ppi);\n       pp_c_cast_expression (ppi, TREE_OPERAND (e, 0));\n+      break;\n+\n+    default:\n+      pp_unary_expression (ppi, e);\n     }\n-  else\n-    pp_unary_expression (ppi, e);\n }\n \n static void\n@@ -822,10 +1266,10 @@ pp_c_multiplicative_expression (c_pretty_printer ppi, tree e)\n     case MULT_EXPR:\n     case TRUNC_DIV_EXPR:\n     case TRUNC_MOD_EXPR:\n-      pp_c_multiplicative_expression (ppi, TREE_OPERAND (e, 0));\n+      pp_multiplicative_expression (ppi, TREE_OPERAND (e, 0));\n       pp_c_whitespace (ppi);\n       if (code == MULT_EXPR)\n-\tpp_star (ppi);\n+\tpp_c_star (ppi);\n       else if (code == TRUNC_DIV_EXPR)\n \tpp_slash (ppi);\n       else\n@@ -855,7 +1299,7 @@ pp_c_additive_expression (c_pretty_printer ppi, tree e)\n       else\n \tpp_minus (ppi);\n       pp_c_whitespace (ppi);\n-      pp_multiplicative_expression (ppi, TREE_OPERAND (e, 1));\n+      pp_multiplicative_expression (ppi, TREE_OPERAND (e, 1)); \n       break;\n \n     default:\n@@ -923,7 +1367,7 @@ pp_c_equality_expression (c_pretty_printer ppi, tree e)\n     case EQ_EXPR:\n     case NE_EXPR:\n       pp_c_equality_expression (ppi, TREE_OPERAND (e, 0));\n-      pp_c_maybe_whitespace (ppi);\n+      pp_c_whitespace (ppi);\n       pp_identifier (ppi, code == EQ_EXPR ? \"==\" : \"!=\");\n       pp_c_whitespace (ppi);\n       pp_c_relational_expression (ppi, TREE_OPERAND (e, 1));\n@@ -941,7 +1385,7 @@ pp_c_and_expression (c_pretty_printer ppi, tree e)\n   if (TREE_CODE (e) == BIT_AND_EXPR)\n     {\n       pp_c_and_expression (ppi, TREE_OPERAND (e, 0));\n-      pp_c_maybe_whitespace (ppi);\n+      pp_c_whitespace (ppi);\n       pp_ampersand (ppi);\n       pp_c_whitespace (ppi);\n       pp_c_equality_expression (ppi, TREE_OPERAND (e, 1));\n@@ -971,7 +1415,7 @@ pp_c_inclusive_or_expression (c_pretty_printer ppi, tree e)\n   if (TREE_CODE (e) == BIT_IOR_EXPR)\n     {\n       pp_c_exclusive_or_expression (ppi, TREE_OPERAND (e, 0));\n-      pp_c_maybe_whitespace (ppi);\n+      pp_c_whitespace (ppi);\n       pp_bar (ppi);\n       pp_c_whitespace (ppi);\n       pp_c_exclusive_or_expression (ppi, TREE_OPERAND (e, 1));\n@@ -986,7 +1430,7 @@ pp_c_logical_and_expression (c_pretty_printer ppi, tree e)\n   if (TREE_CODE (e) == TRUTH_ANDIF_EXPR)\n     {\n       pp_c_logical_and_expression (ppi, TREE_OPERAND (e, 0));\n-      pp_c_maybe_whitespace (ppi);\n+      pp_c_whitespace (ppi);\n       pp_identifier (ppi, \"&&\");\n       pp_c_whitespace (ppi);\n       pp_c_inclusive_or_expression (ppi, TREE_OPERAND (e, 1));\n@@ -1001,7 +1445,7 @@ pp_c_logical_or_expression (c_pretty_printer ppi, tree e)\n   if (TREE_CODE (e) == TRUTH_ORIF_EXPR)\n     {\n       pp_c_logical_or_expression (ppi, TREE_OPERAND (e, 0));\n-      pp_c_maybe_whitespace (ppi);\n+      pp_c_whitespace (ppi);\n       pp_identifier (ppi, \"||\");\n       pp_c_whitespace (ppi);\n       pp_c_logical_and_expression (ppi, TREE_OPERAND (e, 1));\n@@ -1016,7 +1460,7 @@ pp_c_conditional_expression (c_pretty_printer ppi, tree e)\n   if (TREE_CODE (e) == COND_EXPR)\n     {\n       pp_c_logical_or_expression (ppi, TREE_OPERAND (e, 0));\n-      pp_c_maybe_whitespace (ppi);\n+      pp_c_whitespace (ppi);\n       pp_question (ppi);\n       pp_c_whitespace (ppi);\n       pp_c_expression (ppi, TREE_OPERAND (e, 1));\n@@ -1053,11 +1497,11 @@ pp_c_expression (c_pretty_printer ppi, tree e)\n   switch (TREE_CODE (e))\n     {\n     case INTEGER_CST:\n-      pp_c_integer_literal (ppi, e);\n+      pp_c_integer_constant (ppi, e);\n       break;\n \n     case REAL_CST:\n-      pp_c_real_literal (ppi, e);\n+      pp_c_floating_constant (ppi, e);\n       break;\n \n     case STRING_CST:\n@@ -1074,7 +1518,7 @@ pp_c_expression (c_pretty_printer ppi, tree e)\n     case ERROR_MARK:\n     case TARGET_EXPR:\n     case STMT_EXPR:\n-      pp_c_primary_expression (ppi, e);\n+      pp_primary_expression (ppi, e);\n       break;\n \n     case POSTINCREMENT_EXPR:\n@@ -1091,7 +1535,7 @@ pp_c_expression (c_pretty_printer ppi, tree e)\n     case COMPOUND_LITERAL_EXPR:\n     case COMPLEX_EXPR:\n     case VA_ARG_EXPR:\n-      pp_c_postfix_expression (ppi, e);\n+      pp_postfix_expression (ppi, e);\n       break;\n \n     case CONJ_EXPR:\n@@ -1109,15 +1553,16 @@ pp_c_expression (c_pretty_printer ppi, tree e)\n       pp_c_unary_expression (ppi, e);\n       break;\n \n-    case CONVERT_EXPR:\n     case FLOAT_EXPR:\n+    case FIX_TRUNC_EXPR:\n+    case CONVERT_EXPR:\n       pp_c_cast_expression (ppi, e);\n       break;\n \n     case MULT_EXPR:\n     case TRUNC_MOD_EXPR:\n     case TRUNC_DIV_EXPR:\n-      pp_c_multiplicative_expression (ppi, e);\n+      pp_multiplicative_expression (ppi, e);\n       break;\n \n     case LSHIFT_EXPR:\n@@ -1152,17 +1597,23 @@ pp_c_expression (c_pretty_printer ppi, tree e)\n       pp_c_logical_or_expression (ppi, e);\n       break;\n \n+    case EQ_EXPR:\n+    case NE_EXPR:\n+      pp_c_equality_expression (ppi, e);\n+      break;\n+      \n     case COND_EXPR:\n-      pp_c_conditional_expression (ppi, e);\n+      pp_conditional_expression (ppi, e);\n       break;\n \n-    case MODIFY_EXPR:\n-    case INIT_EXPR:\n-      pp_c_assignment_expression (ppi, e);\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+      pp_c_additive_expression (ppi, e);\n       break;\n \n-    case NOP_EXPR:\n-      pp_c_expression (ppi, TREE_OPERAND (e, 0));\n+    case MODIFY_EXPR:\n+    case INIT_EXPR:\n+      pp_assignment_expression (ppi, e);\n       break;\n \n     case COMPOUND_EXPR:\n@@ -1173,27 +1624,42 @@ pp_c_expression (c_pretty_printer ppi, tree e)\n       pp_c_right_paren (ppi);\n       break;\n \n-\n+    case NOP_EXPR:\n+    case NON_LVALUE_EXPR:\n+    case SAVE_EXPR:\n+    case UNSAVE_EXPR:\n+      pp_c_expression (ppi, TREE_OPERAND (e, 0));\n+      break;\n+      \n     default:\n       pp_unsupported_tree (ppi, e);\n       break;\n     }\n }\n \n+\n \f\n /* Statements.  */\n void\n pp_c_statement (c_pretty_printer ppi, tree stmt)\n {\n-  const enum tree_code code = TREE_CODE (stmt);\n+  enum tree_code code;\n+\n+  if (stmt == NULL)\n+    return;\n+  \n+  code = TREE_CODE (stmt);\n   switch (code)\n     {\n     case LABEL_STMT:\n     case CASE_LABEL:\n-      pp_newline (ppi);\n+      if (pp_needs_newline (ppi))\n+        pp_newline_and_indent (ppi, -3);\n+      else\n+        pp_indentation (ppi) -= 3;\n       if (code == LABEL_STMT)\n \tpp_tree_identifier (ppi, DECL_NAME (LABEL_STMT_LABEL (stmt)));\n-      else if (code == LABEL_STMT)\n+      else if (code == CASE_LABEL)\n \t{\n \t  if (CASE_LOW (stmt) == NULL_TREE)\n \t    pp_identifier (ppi, \"default\");\n@@ -1210,35 +1676,45 @@ pp_c_statement (c_pretty_printer ppi, tree stmt)\n \t    }\n \t}\n       pp_colon (ppi);\n-      pp_newline_and_indent (ppi, 3);\n+      pp_indentation (ppi) += 3;\n+      pp_needs_newline (ppi) = true;\n       break;\n \n     case COMPOUND_STMT:\n-      pp_left_brace (ppi);\n+      if (pp_needs_newline (ppi))\n+        pp_newline_and_indent (ppi, 0);\n+      pp_c_left_brace (ppi);\n       pp_newline_and_indent (ppi, 3);\n       for (stmt = COMPOUND_BODY (stmt); stmt; stmt = TREE_CHAIN (stmt))\n \tpp_c_statement (ppi, stmt);\n       pp_newline_and_indent (ppi, -3);\n-      pp_right_brace (ppi);\n-      pp_newline (ppi);\n+      pp_c_right_brace (ppi);\n+      pp_needs_newline (ppi) = true;\n       break;\n \n     case EXPR_STMT:\n     case CLEANUP_STMT:\n-      pp_newline (ppi);\n-      pp_c_expression (ppi, code == EXPR_STMT\n-\t\t       ? EXPR_STMT_EXPR (stmt)\n-\t\t       : CLEANUP_EXPR (stmt));\n-      pp_semicolon (ppi);\n-      pp_newline (ppi);\n+      if (pp_needs_newline (ppi))\n+        pp_newline_and_indent (ppi, 0);\n+      {\n+        tree e = code == EXPR_STMT\n+          ? EXPR_STMT_EXPR (stmt)\n+          : CLEANUP_EXPR (stmt);\n+        if (e)\n+          pp_c_expression (ppi, e);\n+      }\n+      pp_c_semicolon (ppi);\n+      pp_needs_newline (ppi) = true;\n       break;\n \n     case IF_STMT:\n+      if (pp_needs_newline (ppi))\n+        pp_newline_and_indent (ppi, 0);\n       pp_c_identifier (ppi, \"if\");\n-      pp_space (ppi);\n+      pp_c_whitespace (ppi);\n       pp_c_left_paren (ppi);\n       pp_c_expression (ppi, IF_COND (stmt));\n-      pp_right_paren (ppi);\n+      pp_c_right_paren (ppi);\n       pp_newline_and_indent (ppi, 3);\n       pp_statement (ppi, THEN_CLAUSE (stmt));\n       pp_newline_and_indent (ppi, -3);\n@@ -1257,29 +1733,36 @@ pp_c_statement (c_pretty_printer ppi, tree stmt)\n       break;\n \n     case SWITCH_STMT:\n-      pp_newline (ppi);\n+      if (pp_needs_newline (ppi))\n+        pp_newline_and_indent (ppi, 0);\n       pp_c_identifier (ppi, \"switch\");\n       pp_space (ppi);\n       pp_c_left_paren (ppi);\n       pp_c_expression (ppi, SWITCH_COND (stmt));\n-      pp_right_paren (ppi);\n-      pp_newline_and_indent (ppi, 3);\n+      pp_c_right_paren (ppi);\n+      pp_indentation (ppi) += 3;\n+      pp_needs_newline (ppi) = true;\n       pp_statement (ppi, SWITCH_BODY (stmt));\n       pp_newline_and_indent (ppi, -3);\n       break;\n \n     case WHILE_STMT:\n+      if (pp_needs_newline (ppi))\n+        pp_newline_and_indent (ppi, 0);\n       pp_c_identifier (ppi, \"while\");\n       pp_space (ppi);\n       pp_c_left_paren (ppi);\n       pp_c_expression (ppi, WHILE_COND (stmt));\n-      pp_right_paren (ppi);\n+      pp_c_right_paren (ppi);\n       pp_newline_and_indent (ppi, 3);\n       pp_statement (ppi, WHILE_BODY (stmt));\n-      pp_newline_and_indent (ppi, -3);\n+      pp_indentation (ppi) -= 3;\n+      pp_needs_newline (ppi) = true;\n       break;\n \n     case DO_STMT:\n+      if (pp_needs_newline (ppi))\n+        pp_newline_and_indent (ppi, 0);\n       pp_c_identifier (ppi, \"do\");\n       pp_newline_and_indent (ppi, 3);\n       pp_statement (ppi, DO_BODY (stmt));\n@@ -1289,34 +1772,43 @@ pp_c_statement (c_pretty_printer ppi, tree stmt)\n       pp_c_left_paren (ppi);\n       pp_c_expression (ppi, DO_COND (stmt));\n       pp_c_right_paren (ppi);\n-      pp_semicolon (ppi);\n-      pp_newline (ppi);\n+      pp_c_semicolon (ppi);\n+      pp_needs_newline (ppi) = true;\n       break;\n \n     case FOR_STMT:\n+      if (pp_needs_newline (ppi))\n+        pp_newline_and_indent (ppi, 0);\n       pp_c_identifier (ppi, \"for\");\n       pp_space (ppi);\n       pp_c_left_paren (ppi);\n-      pp_statement (ppi, FOR_INIT_STMT (stmt));\n+      if (FOR_INIT_STMT (stmt))\n+        pp_statement (ppi, FOR_INIT_STMT (stmt));\n+      else\n+        pp_c_semicolon (ppi);\n+      pp_needs_newline (ppi) = false;\n       pp_c_whitespace (ppi);\n       if (FOR_COND (stmt))\n \tpp_c_expression (ppi, FOR_COND (stmt));\n-      pp_semicolon (ppi);\n+      pp_c_semicolon (ppi);\n+      pp_needs_newline (ppi) = false;\n       pp_c_whitespace (ppi);\n       if (FOR_EXPR (stmt))\n \tpp_c_expression (ppi, FOR_EXPR (stmt));\n-      pp_right_paren (ppi);\n+      pp_c_right_paren (ppi);\n       pp_newline_and_indent (ppi, 3);\n       pp_statement (ppi, FOR_BODY (stmt));\n-      pp_newline_and_indent (ppi, -3);\n+      pp_indentation (ppi) -= 3;\n+      pp_needs_newline (ppi) = true;\n       break;\n \n     case BREAK_STMT:\n     case CONTINUE_STMT:\n-      pp_newline (ppi);\n+      if (pp_needs_newline (ppi))\n+        pp_newline_and_indent (ppi, 0);\n       pp_identifier (ppi, code == BREAK_STMT ? \"break\" : \"continue\");\n-      pp_semicolon (ppi);\n-      pp_newline (ppi);\n+      pp_c_semicolon (ppi);\n+      pp_needs_newline (ppi) = true;\n       break;\n \n     case RETURN_STMT:\n@@ -1325,36 +1817,43 @@ pp_c_statement (c_pretty_printer ppi, tree stmt)\n \ttree e = code == RETURN_STMT\n \t  ? RETURN_STMT_EXPR (stmt)\n \t  : GOTO_DESTINATION (stmt);\n-\n-\tpp_newline (ppi);\n+        if (pp_needs_newline (ppi))\n+          pp_newline_and_indent (ppi, 0);\n \tpp_c_identifier (ppi, code == RETURN_STMT ? \"return\" : \"goto\");\n \tif (e)\n \t  pp_c_expression (ppi, e);\n-\tpp_semicolon (ppi);\n-\tpp_newline (ppi);\n+\tpp_c_semicolon (ppi);\n+\tpp_needs_newline (ppi) = true;\n       }\n       break;\n \n     case SCOPE_STMT:\n       if (!SCOPE_NULLIFIED_P (stmt) && SCOPE_NO_CLEANUPS_P (stmt))\n-\t{\n-\t  if (SCOPE_BEGIN_P (stmt))\n-\t    {\n-\t      pp_left_brace (ppi);\n-\t      pp_newline_and_indent (ppi, 3);\n-\t    }\n-\t  else if (SCOPE_END_P (stmt))\n-\t    {\n-\t      pp_right_brace (ppi);\n-\t      pp_newline_and_indent (ppi, -3);\n-\t    }\n-\t}\n+        {\n+          int i = 0;\n+          if (pp_needs_newline (ppi))\n+            pp_newline_and_indent (ppi, 0);\n+          if (SCOPE_BEGIN_P (stmt))\n+            {\n+              pp_left_brace (ppi);\n+              i = 3;\n+            }\n+          else if (SCOPE_END_P (stmt))\n+            {\n+              pp_right_brace (ppi);\n+              i = -3;\n+            }\n+          pp_indentation (ppi) += i;\n+          pp_needs_newline (ppi) = true;\n+        }\n       break;\n \n     case DECL_STMT:\n+      if (pp_needs_newline (ppi))\n+        pp_newline_and_indent (ppi, 0);\n       pp_declaration (ppi, DECL_STMT_DECL (stmt));\n-      pp_semicolon (ppi);\n-      pp_newline (ppi);\n+      pp_c_semicolon (ppi);\n+      pp_needs_newline (ppi) = true;\n       break;\n \n     case ASM_STMT:\n@@ -1383,7 +1882,7 @@ pp_c_statement (c_pretty_printer ppi, tree stmt)\n \t    if (ASM_CLOBBERS (stmt))\n \t      pp_c_expression (ppi, ASM_CLOBBERS (stmt));\n \t  }\n-\tpp_right_paren (ppi);\n+\tpp_c_right_paren (ppi);\n \tpp_newline (ppi);\n       }\n       break;\n@@ -1394,8 +1893,8 @@ pp_c_statement (c_pretty_printer ppi, tree stmt)\n       pp_equal (ppi);\n       pp_c_whitespace (ppi);\n       pp_c_identifier (ppi, FILE_STMT_FILENAME (stmt));\n-      pp_semicolon (ppi);\n-      pp_newline (ppi);\n+      pp_c_semicolon (ppi);\n+      pp_needs_newline (ppi) = true;\n       break;\n \n     default:\n@@ -1413,14 +1912,18 @@ pp_c_pretty_printer_init (c_pretty_printer pp)\n \n   pp->declaration               = pp_c_declaration;\n   pp->declaration_specifiers    = pp_c_declaration_specifiers;\n-  pp->type_specifier            = pp_c_simple_type_specifier;\n   pp->declarator                = pp_c_declarator;\n   pp->direct_declarator         = pp_c_direct_declarator;\n+  pp->type_specifier            = pp_c_simple_type_specifier;\n+  pp->abstract_declarator       = pp_c_abstract_declarator;\n   pp->parameter_declaration     = pp_c_parameter_declaration;\n   pp->type_id                   = pp_c_type_id;\n+  pp->function_specifier        = pp_c_function_specifier;\n+  pp->storage_class_specifier   = pp_c_storage_class_specifier;\n \n   pp->statement                 = pp_c_statement;\n \n+  pp->id_expression             = pp_c_id_expression;\n   pp->primary_expression        = pp_c_primary_expression;\n   pp->postfix_expression        = pp_c_postfix_expression;\n   pp->unary_expression          = pp_c_unary_expression;"}, {"sha": "8052662c764593a7fab5a539e6902d3865d275f0", "filename": "gcc/c-pretty-print.h", "status": "modified", "additions": 47, "deletions": 56, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b780675e462fe50a27c972672a171927d37564d/gcc%2Fc-pretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b780675e462fe50a27c972672a171927d37564d/gcc%2Fc-pretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.h?ref=4b780675e462fe50a27c972672a171927d37564d", "patch": "@@ -27,6 +27,13 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"pretty-print.h\"\n \n \n+typedef enum\n+  {\n+     pp_c_flag_abstract = 1 << 1,\n+     pp_c_flag_last_bit = 2    \n+  } pp_c_pretty_print_flags;\n+\n+\n /* The data type used to bundle information necessary for pretty-printing\n    a C or C++ entity.  */\n typedef struct c_pretty_print_info *c_pretty_printer;\n@@ -41,18 +48,24 @@ struct c_pretty_print_info\n      Not used yet.  */\n   int *offset_list;\n \n+  pp_flags flags;\n+   \n   /* These must be overridden by each of the C and C++ front-end to\n      reflect their understanding of syntactic productions when they differ.  */\n   c_pretty_print_fn declaration;\n   c_pretty_print_fn declaration_specifiers;\n-  c_pretty_print_fn type_specifier;\n   c_pretty_print_fn declarator;\n+  c_pretty_print_fn abstract_declarator;\n+  c_pretty_print_fn type_specifier;\n   c_pretty_print_fn direct_declarator;\n   c_pretty_print_fn parameter_declaration;\n   c_pretty_print_fn type_id;\n+  c_pretty_print_fn function_specifier;\n+  c_pretty_print_fn storage_class_specifier;\n \n   c_pretty_print_fn statement;\n \n+  c_pretty_print_fn id_expression;\n   c_pretty_print_fn primary_expression;\n   c_pretty_print_fn postfix_expression;\n   c_pretty_print_fn unary_expression;\n@@ -65,78 +78,50 @@ struct c_pretty_print_info\n #undef pp_base\n #define pp_base(PP)  (&pp_c_base (PP)->base)\n \n-#define pp_c_left_paren(PPI)                       \\\n-   do {                                            \\\n-     pp_left_paren (PPI);                          \\\n-     pp_c_base (PPI)->base.padding = pp_none;      \\\n-   } while (0)\n-#define pp_c_right_paren(PPI)                      \\\n-   do {                                            \\\n-     pp_right_paren (PPI);                         \\\n-     pp_c_base (PPI)->base.padding = pp_none;      \\\n-   } while (0)\n-#define pp_c_left_bracket(PPI)                     \\\n-   do {                                            \\\n-     pp_left_bracket (PPI);                        \\\n-     pp_c_base (PPI)->base.padding = pp_none;      \\\n-   } while (0)\n-#define pp_c_right_bracket(PPI)                    \\\n-   do {                                            \\\n-     pp_right_bracket (PPI);                       \\\n-     pp_c_base (PPI)->base.padding = pp_none;      \\\n-   } while (0)\n-#define pp_c_whitespace(PPI)                       \\\n-   do {                                            \\\n-     pp_space (PPI);                               \\\n-     pp_c_base (PPI)->base.padding = pp_none;      \\\n-   } while (0)\n-#define pp_c_maybe_whitespace(PPI)                 \\\n-   do {                                            \\\n-     if (pp_c_base (PPI)->base.padding != pp_none) \\\n-       pp_c_whitespace (PPI);                      \\\n-   } while (0)\n-#define pp_c_identifier(PPI, ID)                   \\\n-   do {                                            \\\n-     pp_c_maybe_whitespace (PPI);                  \\\n-     pp_identifier (PPI, ID);                      \\\n-     pp_c_base (PPI)->base.padding = pp_before;    \\\n-   } while (0)\n      \n #define pp_c_tree_identifier(PPI, ID)              \\\n    pp_c_identifier (PPI, IDENTIFIER_POINTER (ID))\n \n #define pp_declaration(PPI, T)                    \\\n-   (*pp_c_base (PPI)->declaration) (pp_c_base (PPI), T)\n+   pp_c_base (PPI)->declaration (pp_c_base (PPI), T)\n #define pp_declaration_specifiers(PPI, D)         \\\n-   (*pp_c_base (PPI)->declaration_specifiers) (pp_c_base (PPI), D)\n+   pp_c_base (PPI)->declaration_specifiers (pp_c_base (PPI), D)\n+#define pp_abstract_declarator(PP, D)             \\\n+   pp_c_base (PP)->abstract_declarator (pp_c_base (PP), D)\n #define pp_type_specifier(PPI, D)                 \\\n-   (*pp_c_base (PPI)->type_specifier) (pp_c_base (PPI), D)\n+   pp_c_base (PPI)->type_specifier (pp_c_base (PPI), D)\n #define pp_declarator(PPI, D)                     \\\n-   (*pp_c_base (PPI)->declarator) (pp_c_base (PPI), D)\n+   pp_c_base (PPI)->declarator (pp_c_base (PPI), D)\n #define pp_direct_declarator(PPI, D)              \\\n-   (*pp_c_base (PPI)->direct_declarator) (pp_c_base (PPI), D)\n+   pp_c_base (PPI)->direct_declarator (pp_c_base (PPI), D)\n #define pp_parameter_declaration(PPI, T)          \\\n-  (*pp_c_base (PPI)->parameter_declaration) (pp_c_base (PPI), T)\n+  pp_c_base (PPI)->parameter_declaration (pp_c_base (PPI), T)\n #define pp_type_id(PPI, D)                        \\\n-  (*pp_c_base (PPI)->type_id) (pp_c_base (PPI), D)\n+  pp_c_base (PPI)->type_id (pp_c_base (PPI), D)\n+#define pp_function_specifier(PP, D)              \\\n+  pp_c_base (PP)->function_specifier (pp_c_base (PP), D)\n+#define pp_storage_class_specifier(PP, D)         \\\n+  pp_c_base (PP)->storage_class_specifier (pp_c_base (PP), D);\n \n #define pp_statement(PPI, S)                      \\\n-  (*pp_c_base (PPI)->statement) (pp_c_base (PPI), S)\n+  pp_c_base (PPI)->statement (pp_c_base (PPI), S)\n \n+#define pp_id_expression(PP, E)  \\\n+  pp_c_base (PP)->id_expression (pp_c_base (PP), E)\n #define pp_primary_expression(PPI, E)             \\\n-  (*pp_c_base (PPI)->primary_expression) (pp_c_base (PPI), E)\n+  pp_c_base (PPI)->primary_expression (pp_c_base (PPI), E)\n #define pp_postfix_expression(PPI, E)             \\\n-  (*pp_c_base (PPI)->postfix_expression) (pp_c_base (PPI), E)\n+  pp_c_base (PPI)->postfix_expression (pp_c_base (PPI), E)\n #define pp_unary_expression(PPI, E)               \\\n-  (*pp_c_base (PPI)->unary_expression) (pp_c_base (PPI), E)\n+  pp_c_base (PPI)->unary_expression (pp_c_base (PPI), E)\n #define pp_initializer(PPI, E)                    \\\n-  (*pp_c_base (PPI)->initializer) (pp_c_base (PPI), E)\n+  pp_c_base (PPI)->initializer (pp_c_base (PPI), E)\n #define pp_multiplicative_expression(PPI, E)      \\\n-   (*pp_c_base (PPI)->multiplicative_expression) (pp_c_base (PPI), E)\n+  pp_c_base (PPI)->multiplicative_expression (pp_c_base (PPI), E)\n #define pp_conditional_expression(PPI, E)         \\\n-   (*pp_c_base (PPI)->conditional_expression) (pp_c_base (PPI), E)\n+  pp_c_base (PPI)->conditional_expression (pp_c_base (PPI), E)\n #define pp_assignment_expression(PPI, E)          \\\n-   (*pp_c_base (PPI)->assignment_expression) (pp_c_base (PPI), E)\n+   pp_c_base (PPI)->assignment_expression (pp_c_base (PPI), E)\n \n \n /* Returns the c_pretty_printer base object of PRETTY-PRINTER.  This\n@@ -146,22 +131,28 @@ struct c_pretty_print_info\n extern void pp_c_pretty_printer_init (c_pretty_printer);\n \n /* Declarations.  */\n+void pp_c_function_definition (c_pretty_printer, tree);\n void pp_c_attributes (c_pretty_printer, tree);\n-void pp_c_cv_qualifier (c_pretty_printer, int);\n+void pp_c_type_qualifier_list (c_pretty_printer, tree);\n void pp_c_parameter_declaration_clause (c_pretty_printer, tree);\n void pp_c_declaration (c_pretty_printer, tree);\n+void pp_c_declarator (c_pretty_printer, tree);\n+void pp_c_direct_declarator (c_pretty_printer, tree);\n+void pp_c_specifier_qualifier_list (c_pretty_printer, tree);\n+void pp_c_type_id (c_pretty_printer, tree);\n /* Statements.  */\n void pp_c_statement (c_pretty_printer, tree);\n /* Expressions.  */\n void pp_c_expression (c_pretty_printer, tree);\n void pp_c_logical_or_expression (c_pretty_printer, tree);\n void pp_c_expression_list (c_pretty_printer, tree);\n+void pp_c_unary_expression (c_pretty_printer, tree);\n void pp_c_cast_expression (c_pretty_printer, tree);\n void pp_c_postfix_expression (c_pretty_printer, tree);\n void pp_c_initializer (c_pretty_printer, tree);\n-void pp_c_literal (c_pretty_printer, tree);\n+void pp_c_constant (c_pretty_printer, tree);\n+void pp_c_id_expression (c_pretty_printer, tree);\n+void pp_c_identifier (c_pretty_printer, const char *);\n void pp_c_string_literal (c_pretty_printer, tree);\n-void pp_c_real_literal (c_pretty_printer, tree);\n-void pp_c_integer_literal (c_pretty_printer, tree);\n \n #endif /* GCC_C_PRETTY_PRINTER */"}, {"sha": "fde090e1bb72effd4afc4157f5c913711c6e07fa", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b780675e462fe50a27c972672a171927d37564d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b780675e462fe50a27c972672a171927d37564d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4b780675e462fe50a27c972672a171927d37564d", "patch": "@@ -1,3 +1,26 @@\n+2003-08-10  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\t* error.c (dump_expr): Tidy.\n+\t* cxx-pretty-print.c (pp_cxx_nonconsecutive_character): New.\n+\t(pp_cxx_begin_template_argument_list): Likewise.\n+\t(pp_cxx_end_template_argument_list): Likewise.\n+\t(is_destructor_name): Likewise.\n+\t(pp_cxx_unqualified_id): Likewise.\n+\t(pp_cxx_qualified_id): Likewise.\n+\t(pp_cxx_id_expression): Likewise.\n+\t(pp_cxx_new_expression): Likewise.\n+\t(pp_cxx_delete_expression): Likewise.\n+\t(pp_cxx_pm_expression): Likewise.\n+\t(pp_cxx_type_specifier): Rework.\n+\t(pp_cxx_type_id): Likewise.\n+\t(pp_cxx_primary_expression): Likewise.\n+\t(pp_cxx_postfix_expression): Likewise.\n+\t(pp_cxx_unary_expression): Likewise.\n+\t(pp_cxx_multiplicative_expression): Likewise.\n+\t(pp_cxx_conditional_expression): Likewise.\n+\t(pp_cxx_assignment_expression): Likewise.\n+\t(pp_cxx_pretty_printer_init): Tidy.\n+\n 2003-08-10  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* cp-tree.h (TMPL_ARGS_HAVE_MULTIPLE_LEVELS): non-NULL"}, {"sha": "83e438120123deb970a21dc970432d5eed5fecb1", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 557, "deletions": 19, "changes": 576, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b780675e462fe50a27c972672a171927d37564d/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b780675e462fe50a27c972672a171927d37564d/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=4b780675e462fe50a27c972672a171927d37564d", "patch": "@@ -26,7 +26,28 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"real.h\"\n #include \"cxx-pretty-print.h\"\n #include \"cp-tree.h\"\n+\n+static void pp_cxx_unqualified_id (cxx_pretty_printer *, tree);\n+static void pp_cxx_qualified_id (cxx_pretty_printer *, tree);\n+static void pp_cxx_assignment_expression (cxx_pretty_printer *, tree);\n+static void pp_cxx_template_argument_list (cxx_pretty_printer *, tree);\n \f\n+\n+static inline void\n+pp_cxx_nonconsecutive_character (cxx_pretty_printer *pp, int c)\n+{\n+  const char *p = pp_last_position_in_text (pp);\n+\n+  if (p != NULL && *p == c)\n+    pp_space (pp);\n+  pp_character (pp, c);\n+}\n+\n+#define pp_cxx_begin_template_argument_list(PP) \\\n+  pp_cxx_nonconsecutive_character (PP, '<')\n+#define pp_cxx_end_template_argument_list(PP) \\\n+  pp_cxx_nonconsecutive_character (PP, '>')\n+\n /* Declarations.  */\n \n void\n@@ -40,23 +61,55 @@ pp_cxx_declaration_specifiers (cxx_pretty_printer *pp, tree t)\n {\n   pp_unsupported_tree (pp, t);\n }\n+/* type-specifier:\n+      simple-type-specifier\n+      class-specifier\n+      enum-specifier\n+      elaborated-type-specifier\n+      cv-qualifer   */\n \n static void\n pp_cxx_type_specifier (cxx_pretty_printer *pp, tree t)\n {\n-  pp_unsupported_tree (pp, t);\n+  pp_c_type_qualifier_list (pp_c_base (pp), t);\n+\n+  switch (TREE_CODE (t))\n+    {\n+    case TEMPLATE_DECL:\n+    case TYPE_DECL:\n+      if (pp->enclosing_scope != DECL_CONTEXT (t))\n+        pp_cxx_qualified_id (pp, t);\n+      else\n+        pp_cxx_unqualified_id (pp, t);\n+      break;\n+\n+    case TYPEOF_TYPE:\n+      pp_c_identifier (pp_c_base (pp), \"__typeof__\");\n+      pp_left_paren (pp);\n+      pp_c_expression (pp_c_base (pp), TYPE_FIELDS (t));\n+      pp_right_paren (pp);\n+      break;\n+\n+    default:\n+      pp_c_specifier_qualifier_list (pp_c_base (pp), t);\n+    }\n }\n \n static void\n pp_cxx_declarator (cxx_pretty_printer *pp, tree t)\n {\n-  pp_unsupported_tree (pp, t);\n+  switch (TREE_CODE (t))\n+    {\n+    default:\n+      pp_c_declarator (pp_c_base (pp), t);\n+      break;\n+    }\n }\n \n static void\n pp_cxx_direct_declarator (cxx_pretty_printer *pp, tree t)\n {\n-  pp_unsupported_tree (pp, t);\n+  pp_c_direct_declarator (pp_c_base (pp), t);\n }\n \n static void\n@@ -65,12 +118,78 @@ pp_cxx_parameter_declaration (cxx_pretty_printer *pp, tree t)\n   pp_unsupported_tree (pp, t);\n }\n \n+\n+\n+/* type-id:\n+     type-specifier-seq abstract-declarator(opt) */\n static void\n pp_cxx_type_id (cxx_pretty_printer *pp, tree t)\n+{\n+  pp_flags saved_flags = pp_c_base (pp)->flags;\n+  pp_c_base (pp)->flags |= pp_c_flag_abstract;\n+\n+  switch (TREE_CODE (t))\n+    {\n+    case TYPE_DECL:\n+    case UNION_TYPE:\n+    case RECORD_TYPE:\n+    case ENUMERAL_TYPE:\n+    case TYPENAME_TYPE:\n+    case BOUND_TEMPLATE_TEMPLATE_PARM:\n+    case UNBOUND_CLASS_TEMPLATE:\n+    case TEMPLATE_TEMPLATE_PARM:\n+    case TEMPLATE_TYPE_PARM:\n+    case TEMPLATE_PARM_INDEX:\n+    case TEMPLATE_DECL:\n+    case TYPEOF_TYPE:\n+    case TEMPLATE_ID_EXPR:\n+      /* FIXME: Should be pp_cxx_type_specifier_seq.  */\n+      pp_cxx_type_specifier (pp, t);\n+      pp_cxx_declarator (pp, t);\n+      break;\n+\n+    default:\n+      pp_c_type_id (pp_c_base (pp), t);\n+      break;\n+    }\n+\n+  pp_c_base (pp)->flags = saved_flags;\n+}\n+\n+static void\n+pp_cxx_initializer (cxx_pretty_printer *pp, tree t)\n {\n   pp_unsupported_tree (pp, t);\n }\n \n+/* template-argument-list:\n+      template-argument\n+      template-argument-list, template-argument\n+\n+   template-argument:\n+      assignment-expression\n+      type-id\n+      template-name   */\n+static void\n+pp_cxx_template_argument_list (cxx_pretty_printer *pp, tree t)\n+{\n+  int i;\n+  if (t == NULL)\n+    return;\n+  for (i = 0; i < TREE_VEC_LENGTH (t); ++i)\n+    {\n+      tree arg = TREE_VEC_ELT (t, i);\n+      if (i != 0)\n+        pp_separate_with (pp, ',');\n+      if (TYPE_P (arg) || (TREE_CODE (arg) == TEMPLATE_DECL\n+                           && TYPE_P (DECL_TEMPLATE_RESULT (arg))))\n+        pp_cxx_type_id (pp, arg);\n+      else\n+        pp_c_expression (pp_c_base (pp), arg);\n+    }\n+}\n+\n+\n /* Statements.  */\n \n void\n@@ -81,52 +200,470 @@ pp_cxx_statement (cxx_pretty_printer *pp, tree t)\n \n /* Expressions. */\n \n+static inline bool\n+is_destructor_name (tree name)\n+{\n+  return name == complete_dtor_identifier\n+    || name == base_dtor_identifier\n+    || name == deleting_dtor_identifier;\n+}\n+\n+/* unqualified-id:\n+     identifier\n+     operator-function-id\n+     conversion-function-id\n+     ~ class-name\n+     template-id  */\n+static void\n+pp_cxx_unqualified_id (cxx_pretty_printer *pp, tree t)\n+{\n+  enum tree_code code = TREE_CODE (t);\n+  switch (code)\n+    {\n+    case VAR_DECL:\n+    case PARM_DECL:\n+    case CONST_DECL:\n+    case TYPE_DECL:\n+    case FUNCTION_DECL:\n+    case NAMESPACE_DECL:\n+    case FIELD_DECL:\n+    case LABEL_DECL:\n+    case USING_DECL:\n+      t = DECL_NAME (t);\n+      \n+    case IDENTIFIER_NODE:\n+      if (IDENTIFIER_TYPENAME_P (t))\n+        {\n+          pp_c_identifier (pp_c_base (pp), \"operator\");\n+          /* FIXME: should be pp_cxx_type_specifier_seq */\n+          pp_cxx_type_specifier (pp, TREE_TYPE (t));\n+          /* FIXME:  should be pp_cxx_conversion_declarator. */\n+          pp_cxx_type_id (pp, TREE_TYPE (t));\n+        }\n+      else if (IDENTIFIER_OPNAME_P (t))\n+        {\n+          const char *name = operator_name_info[TREE_CODE (t)].name;\n+          pp_c_identifier (pp_c_base (pp), \"operator\");\n+          if (ISALPHA (name[0]))\n+            pp_space (pp);\n+          pp_base (pp)->padding = pp_none;\n+          pp_c_identifier (pp_c_base (pp), name);\n+        }\n+      else\n+        {\n+          if (is_destructor_name (t))\n+            {\n+              pp_complement (pp);\n+              t = constructor_name (TREE_TYPE (t));\n+            }\n+          pp_c_tree_identifier (pp_c_base (pp), t);\n+        }\n+      break;\n+\n+    case TEMPLATE_ID_EXPR:\n+      pp_cxx_unqualified_id (pp, TREE_OPERAND (t, 0));\n+      pp_less (pp);\n+      pp_cxx_template_argument_list (pp, TREE_OPERAND (t, 1));\n+      pp_greater (pp);\n+      break;\n+\n+    default:\n+      pp_unsupported_tree (pp, t);\n+    }\n+}\n+\n+/* qualified-id:\n+      nested-name-specifier template(opt) unqualified-id  */\n+static void\n+pp_cxx_qualified_id (cxx_pretty_printer *pp, tree t)\n+{\n+  switch (TREE_CODE (t))\n+    {\n+    case PTRMEM_CST:\n+      pp_cxx_qualified_id (pp, PTRMEM_CST_CLASS (t));\n+      pp_colon_colon (pp);\n+      pp_cxx_unqualified_id (pp, PTRMEM_CST_MEMBER (t));\n+      break;\n+\n+    case OFFSET_REF:\n+    case SCOPE_REF:\n+      pp_cxx_qualified_id (pp, TREE_OPERAND (t, 0));\n+      pp_colon_colon (pp);\n+      pp_cxx_unqualified_id (pp, TREE_OPERAND (t, 1));\n+      break;\n+\n+    default:\n+      {\n+        tree scope = DECL_CONTEXT (t);\n+        if (scope == pp->enclosing_scope)\n+          pp_cxx_unqualified_id (pp, t);\n+        else\n+          {\n+            pp_cxx_qualified_id (pp, scope);\n+            pp_colon_colon (pp);\n+            if (TYPE_P (scope) && dependent_type_p (scope)\n+                && TREE_CODE (t) == TEMPLATE_DECL)\n+              pp_c_identifier (pp_c_base (pp), \"template\");\n+            pp_cxx_unqualified_id (pp, t);\n+          }\n+      }\n+      break;\n+    }\n+}\n+\n+/* id-expression:\n+      unaqualified-id\n+      qualified-id   */\n+static inline void\n+pp_cxx_id_expression (cxx_pretty_printer *pp, tree t)\n+{\n+  if (pp_c_base (pp)->flags\n+      & (pp_cxx_flag_qualified_id | pp_cxx_flag_global_scope))\n+    pp_cxx_qualified_id (pp, t);\n+  else\n+    pp_cxx_unqualified_id (pp, t);\n+}\n+\n+/* primary-expression:\n+     literal\n+     this\n+     :: identifier\n+     :: operator-function-id\n+     :: qualifier-id\n+     ( expression )\n+     id-expression   */\n static void\n pp_cxx_primary_expression (cxx_pretty_printer *pp, tree t)\n {\n-  pp_unsupported_tree (pp, t);\n+  switch (TREE_CODE (t))\n+    {\n+    case STRING_CST:\n+    case INTEGER_CST:\n+    case REAL_CST:\n+      pp_c_constant (pp_c_base (pp), t);\n+      break;\n+\n+    default:\n+      if (pp_c_base (pp)->flags & pp_cxx_flag_qualified_id)\n+        pp_cxx_qualified_id (pp, t);\n+      else\n+        {\n+          if (pp_c_base (pp)->flags & pp_cxx_flag_global_scope)\n+            pp_colon_colon (pp);\n+          pp_cxx_unqualified_id (pp, t);\n+        }\n+      break;\n+    }\n }\n \n+/* postfix-expression:\n+     primary-expression\n+     postfix-expression [ expression ]\n+     postfix-expression ( expression-list(opt) )\n+     simple-type-specifier ( expression-list(opt) )\n+     typename ::(opt) nested-name-specifier identifier ( expression-list(opt) )\n+     typename ::(opt) nested-name-specifier template(opt)\n+                                       template-id ( expression-list(opt) )\n+     postfix-expression . template(opt) ::(opt) id-expression\n+     postfix-expression -> template(opt) ::(opt) id-expression\n+     postfix-expression . pseudo-destructor-name\n+     postfix-expression -> pseudo-destructor-name\n+     postfix-expression ++\n+     postfix-expression --\n+     dynamic_cast < type-id > ( expression )\n+     static_cast < type-id > ( expression )\n+     reinterpret_cast < type-id > ( expression )\n+     const_cast < type-id > ( expression )\n+     typeid ( expression )\n+     typeif ( type-id )  */\n+\n static void\n pp_cxx_postfix_expression (cxx_pretty_printer *pp, tree t)\n {\n-  pp_unsupported_tree (pp, t);\n+  enum tree_code code = TREE_CODE (t);\n+  \n+  switch (code)\n+    {\n+    case DYNAMIC_CAST_EXPR:\n+    case STATIC_CAST_EXPR:\n+    case REINTERPRET_CAST_EXPR:\n+    case CONST_CAST_EXPR:\n+      if (code == DYNAMIC_CAST_EXPR)\n+        pp_identifier (pp, \"dynamic_cast\");\n+      else if (code == STATIC_CAST_EXPR)\n+        pp_identifier (pp, \"static_cast\");\n+      else if (code == REINTERPRET_CAST_EXPR)\n+        pp_identifier (pp, \"reinterpret_cast\");\n+      else\n+        pp_identifier (pp, \"const_cast\");\n+      pp_cxx_begin_template_argument_list (pp);\n+      pp_cxx_type_id (pp, TREE_TYPE (t));\n+      pp_cxx_end_template_argument_list (pp);\n+      pp_left_paren (pp);\n+      pp_c_expression (pp_c_base (pp), TREE_OPERAND (t, 0));\n+      pp_right_paren (pp);\n+      break;\n+\n+    case EMPTY_CLASS_EXPR:\n+      pp_cxx_type_id (pp, TREE_TYPE (t));\n+      pp_left_paren (pp);\n+      pp_right_paren (pp);\n+      break;\n+\n+    case TYPEID_EXPR:\n+      t = TREE_OPERAND (t, 0);\n+      pp_c_identifier (pp_c_base (pp), \"typeid\");\n+      pp_left_paren (pp);\n+      if (TYPE_P (t))\n+        pp_cxx_type_id (pp, t);\n+      else\n+        pp_c_expression (pp_c_base (pp), t);\n+      pp_right_paren (pp);\n+      break;\n+\n+    case PSEUDO_DTOR_EXPR:\n+      pp_cxx_postfix_expression (pp, TREE_OPERAND (t, 0));\n+      pp_dot (pp);\n+      pp_cxx_qualified_id (pp, TREE_OPERAND (t, 1));\n+      pp_colon_colon (pp);\n+      pp_complement (pp);\n+      pp_cxx_unqualified_id (pp, TREE_OPERAND (t, 2));\n+      break;\n+\n+    default:\n+      pp_c_postfix_expression (pp_c_base (pp), t);\n+      break;\n+    }\n }\n \n+/* new-expression:\n+      ::(opt) new new-placement(opt) new-type-id new-initializer(opt)\n+      ::(opt) new new-placement(opt) ( type-id ) new-initializer(opt)\n+\n+   new-placement:\n+      ( expression-list )\n+\n+   new-type-id:\n+      type-specifier-seq new-declarator(opt)\n+\n+   new-declarator:\n+      ptr-operator new-declarator(opt)\n+      direct-new-declarator\n+\n+   direct-new-declarator\n+      [ expression ]\n+      direct-new-declarator [ constant-expression ]\n+\n+   new-initializer:\n+      ( expression-list(opt) )  */\n static void\n-pp_cxx_unary_expression (cxx_pretty_printer *pp, tree t)\n+pp_cxx_new_expression (cxx_pretty_printer *pp, tree t)\n {\n-  pp_unsupported_tree (pp, t);\n+  enum tree_code code = TREE_CODE (t);\n+  switch (code)\n+    {\n+    case NEW_EXPR:\n+    case VEC_NEW_EXPR:\n+      if (NEW_EXPR_USE_GLOBAL (t))\n+        pp_colon_colon (pp);\n+      pp_c_identifier (pp_c_base (pp), \"new\");\n+      if (TREE_OPERAND (t, 0))\n+        {\n+          pp_left_paren (pp);\n+          pp_c_expression_list (pp_c_base (pp), TREE_OPERAND (t, 0));\n+          pp_right_paren (pp);\n+          pp_space (pp);\n+        }\n+      /* FIXME: array-types are built with one more element.  */\n+      pp_cxx_type_id (pp, TREE_OPERAND (t, 1));\n+      if (TREE_OPERAND (t, 2))\n+        {\n+          pp_left_paren (pp);\n+          t = TREE_OPERAND (t, 2);\n+          if (TREE_CODE (t) == TREE_LIST)\n+            pp_c_expression_list (pp_c_base (pp), t);\n+          else if (t == void_zero_node)\n+            ;                   /* OK, empty initializer list.  */\n+          else\n+            pp_c_expression (pp_c_base (pp), t);\n+          pp_right_paren (pp);\n+        }\n+      break;\n+\n+    default:\n+      pp_unsupported_tree (pp, t);\n+    }\n }\n \n+/* delete-expression:\n+      ::(opt) delete cast-expression\n+      ::(opt) delete [ ] cast-expression   */\n static void\n-pp_cxx_initializer (cxx_pretty_printer *pp, tree t)\n+pp_cxx_delete_expression (cxx_pretty_printer *pp, tree t)\n {\n-  pp_unsupported_tree (pp, t);\n+  enum tree_code code = TREE_CODE (t);\n+  switch (code)\n+    {\n+    case DELETE_EXPR:\n+    case VEC_DELETE_EXPR:\n+      if (DELETE_EXPR_USE_GLOBAL (t))\n+        pp_colon_colon (pp);\n+      pp_c_identifier (pp_c_base (pp), \"delete\");\n+      if (code == VEC_DELETE_EXPR)\n+        {\n+          pp_left_bracket (pp);\n+          pp_right_bracket (pp);\n+        }\n+      pp_c_cast_expression (pp_c_base (pp), TREE_OPERAND (t, 0));\n+      break;      \n+      \n+    default:\n+      pp_unsupported_tree (pp, t);\n+    }\n }\n \n+/* unary-expression:\n+      postfix-expression\n+      ++ cast-expression\n+      -- cast-expression\n+      unary-operator cast-expression\n+      sizeof unary-expression\n+      sizeof ( type-id )\n+      new-expression\n+      delete-expression\n+\n+   unary-operator: one of\n+      *   &   +   -  !\n+\n+   GNU extensions:\n+      __alignof__ unary-expression\n+      __alignof__ ( type-id )  */\n static void\n-pp_cxx_multiplicatice_expression (cxx_pretty_printer *pp, tree t)\n+pp_cxx_unary_expression (cxx_pretty_printer *pp, tree t)\n {\n-  pp_unsupported_tree (pp, t);\n+  enum tree_code code = TREE_CODE (t);\n+  switch (code)\n+    {\n+    case NEW_EXPR:\n+    case VEC_NEW_EXPR:\n+      pp_cxx_new_expression (pp, t);\n+      break;\n+\n+    case DELETE_EXPR:\n+    case VEC_DELETE_EXPR:\n+      pp_cxx_delete_expression (pp, t);\n+      break;\n+      \n+    default:\n+      pp_c_unary_expression (pp_c_base (pp), t);\n+      break;\n+    }\n }\n \n+/* pm-expression:\n+      cast-expression\n+      pm-expression .* cast-expression\n+      pm-expression ->* cast-expression  */\n static void\n-pp_cxx_conditional_expression (cxx_pretty_printer *pp, tree t)\n+pp_cxx_pm_expression (cxx_pretty_printer *pp, tree t)\n {\n-  pp_unsupported_tree (pp, t);\n+  switch (TREE_CODE (t))\n+    {\n+      /* Handle unfortunate OFFESET_REF overloading here.  */\n+    case OFFSET_REF:\n+      if (TYPE_P (TREE_OPERAND (t, 0)))\n+        {\n+          pp_cxx_qualified_id (pp, t);\n+          break;\n+        }\n+      /* else fall through */\n+    case MEMBER_REF:\n+    case DOTSTAR_EXPR:\n+      pp_cxx_pm_expression (pp, TREE_OPERAND (t, 0));\n+      pp_dot (pp);\n+      pp_star(pp);\n+      pp_c_cast_expression (pp_c_base (pp), TREE_OPERAND (t, 1));\n+      break;\n+\n+\n+    default:\n+      pp_c_cast_expression (pp_c_base (pp), t);\n+      break;\n+    }\n }\n \n+/* multiplicative-expression:\n+      pm-expression\n+      multiplicative-expression * pm-expression\n+      multiplicative-expression / pm-expression\n+      multiplicative-expression % pm-expression  */\n static void\n-pp_cxx_assignment_expression (cxx_pretty_printer *pp, tree t)\n+pp_cxx_multiplicative_expression (cxx_pretty_printer *pp, tree e)\n {\n-  pp_unsupported_tree (pp, t);\n+  enum tree_code code = TREE_CODE (e);\n+  switch (code)\n+    {\n+    case MULT_EXPR:\n+    case TRUNC_DIV_EXPR:\n+    case TRUNC_MOD_EXPR:\n+      pp_cxx_multiplicative_expression (pp, TREE_OPERAND (e, 0));\n+      pp_space (pp);\n+      if (code == MULT_EXPR)\n+\tpp_star (pp);\n+      else if (code == TRUNC_DIV_EXPR)\n+\tpp_slash (pp);\n+      else\n+\tpp_modulo (pp);\n+      pp_space (pp);\n+      pp_cxx_pm_expression (pp, TREE_OPERAND (e, 1));\n+      break;\n+\n+    default:\n+      pp_cxx_pm_expression (pp, e);\n+      break;\n+    }\n }\n \n-void\n-pp_cxx_expression (cxx_pretty_printer *pp, tree t)\n+\n+/* conditional-expression:\n+      logical-or-expression\n+      logical-or-expression ?  expression  : assignment-expression  */\n+static void\n+pp_cxx_conditional_expression (cxx_pretty_printer *pp, tree e)\n {\n-  pp_unsupported_tree (pp, t);\n+  if (TREE_CODE (e) == COND_EXPR)\n+    {\n+      pp_c_logical_or_expression (pp_c_base (pp), TREE_OPERAND (e, 0));\n+      pp_space (pp);\n+      pp_question (pp);\n+      pp_space (pp);\n+      pp_c_expression (pp_c_base (pp), TREE_OPERAND (e, 1));\n+      pp_space (pp);\n+      pp_cxx_assignment_expression (pp, TREE_OPERAND (e, 2));\n+    }\n+  else\n+    pp_c_logical_or_expression (pp_c_base (pp), e);\n+}\n+\n+/* assignment-expression:\n+      conditional-expression\n+      logical-or-expression assignment-operator assignment-expression\n+\n+   assignment-expression: one of\n+      =    *=    /=    %=    +=    -=    >>=    <<=    &=    ^=    |=  */\n+static void\n+pp_cxx_assignment_expression (cxx_pretty_printer *pp, tree e)\n+{\n+  if (TREE_CODE (e) == MODIFY_EXPR)\n+    {\n+      pp_c_logical_or_expression (pp_c_base (pp), TREE_OPERAND (e, 0));\n+      pp_space (pp);\n+      pp_equal (pp);\n+      pp_space (pp);\n+      pp_cxx_assignment_expression (pp, TREE_OPERAND (e, 1));\n+    }\n+  else\n+    pp_cxx_conditional_expression (pp, e);\n }\n \n \n@@ -146,11 +683,12 @@ pp_cxx_pretty_printer_init (cxx_pretty_printer *pp)\n   pp->c_base.parameter_declaration = (pp_fun) pp_cxx_parameter_declaration;\n   pp->c_base.type_id = (pp_fun) pp_cxx_type_id;\n   pp->c_base.statement = (pp_fun) pp_cxx_statement;\n+  pp->c_base.id_expression = (pp_fun) pp_cxx_id_expression;\n   pp->c_base.primary_expression = (pp_fun) pp_cxx_primary_expression;\n   pp->c_base.postfix_expression = (pp_fun) pp_cxx_postfix_expression;\n   pp->c_base.unary_expression = (pp_fun) pp_cxx_unary_expression;\n   pp->c_base.initializer = (pp_fun) pp_cxx_initializer;\n-  pp->c_base.multiplicative_expression = (pp_fun) pp_cxx_multiplicatice_expression;\n+  pp->c_base.multiplicative_expression = (pp_fun) pp_cxx_multiplicative_expression;\n   pp->c_base.conditional_expression = (pp_fun) pp_cxx_conditional_expression;\n   pp->c_base.assignment_expression = (pp_fun) pp_cxx_assignment_expression;\n   pp->enclosing_scope = NULL;"}, {"sha": "514f2534b40a782c1e80c5ba96849607d475986c", "filename": "gcc/cp/cxx-pretty-print.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b780675e462fe50a27c972672a171927d37564d/gcc%2Fcp%2Fcxx-pretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b780675e462fe50a27c972672a171927d37564d/gcc%2Fcp%2Fcxx-pretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.h?ref=4b780675e462fe50a27c972672a171927d37564d", "patch": "@@ -27,6 +27,14 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #undef pp_c_base\n #define pp_c_base(PP) (&(PP)->c_base)\n \n+typedef enum\n+{\n+  /* Ask for an qualified-id.  */\n+  pp_cxx_flag_qualified_id = 1 << pp_c_flag_last_bit,\n+  pp_cxx_flag_global_scope = 1 << (pp_c_flag_last_bit + 1)\n+  \n+} cxx_pretty_printer_flags;\n+\n typedef struct\n {\n   struct c_pretty_print_info c_base;\n@@ -38,7 +46,6 @@ void pp_cxx_pretty_printer_init (cxx_pretty_printer *);\n \n void pp_cxx_declaration (cxx_pretty_printer *, tree);\n void pp_cxx_statement (cxx_pretty_printer *, tree);\n-void pp_cxx_expression (cxx_pretty_printer *, tree);\n \n \n #endif /* GCC_CXX_PRETTY_PRINT_H */"}, {"sha": "380a5263a0b4747bfa405545127f0b4b1c743b6e", "filename": "gcc/cp/error.c", "status": "modified", "additions": 2, "deletions": 35, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b780675e462fe50a27c972672a171927d37564d/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b780675e462fe50a27c972672a171927d37564d/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=4b780675e462fe50a27c972672a171927d37564d", "patch": "@@ -1331,38 +1331,9 @@ dump_expr (tree t, int flags)\n       break;\n \n     case INTEGER_CST:\n-      {\n-\ttree type = TREE_TYPE (t);\n-\tmy_friendly_assert (type != 0, 81);\n-\n-\t/* If it's an enum, output its tag, rather than its value.  */\n-\tif (TREE_CODE (type) == ENUMERAL_TYPE)\n-\t  {\n-\t    tree values = TYPE_VALUES (type);\n-\n-\t    for (; values;\n-\t         values = TREE_CHAIN (values))\n-\t      if (tree_int_cst_equal (TREE_VALUE (values), t))\n-\t        break;\n-\n-\t    if (values)\n-\t      pp_tree_identifier (cxx_pp, TREE_PURPOSE (values));\n-\t    else\n-\t      {\n-                /* Value must have been cast.  */\n-                pp_left_paren (cxx_pp);\n-                dump_type (type, flags);\n-                pp_right_paren (cxx_pp);\n-                pp_c_integer_literal (pp_c_base (cxx_pp), t);\n-\t      }\n-\t  }\n-        else\n-          pp_c_integer_literal (pp_c_base (cxx_pp), t);\n-      }\n-      break;\n-\n+    case STRING_CST:\n     case REAL_CST:\n-      pp_c_real_literal (pp_c_base (cxx_pp), t);\n+       pp_c_constant (pp_c_base (cxx_pp), t);\n       break;\n \n     case PTRMEM_CST:\n@@ -1372,10 +1343,6 @@ dump_expr (tree t, int flags)\n       pp_tree_identifier (cxx_pp, DECL_NAME (PTRMEM_CST_MEMBER (t)));\n       break;\n \n-    case STRING_CST:\n-      pp_c_string_literal (pp_c_base (cxx_pp), t);\n-      break;\n-\n     case COMPOUND_EXPR:\n       pp_left_paren (cxx_pp);\n       dump_expr (TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);"}, {"sha": "d865107d81fa364d94b1a7cbfb07264b20c79f3d", "filename": "gcc/pretty-print.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b780675e462fe50a27c972672a171927d37564d/gcc%2Fpretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b780675e462fe50a27c972672a171927d37564d/gcc%2Fpretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpretty-print.c?ref=4b780675e462fe50a27c972672a171927d37564d", "patch": "@@ -90,19 +90,6 @@ pp_clear_state (pretty_printer *pp)\n   pp_indentation (pp) = 0;\n }\n \n-/* Insert enough spaces into the output area of PRETTY-PRINTER to bring\n-   the column position to the current indentation level, assuming that a\n-   newline has just been written to the buffer.  */\n-static void\n-pp_indent (pretty_printer *pp)\n-{\n-  int n = pp_indentation (pp);\n-  int i;\n-\n-  for (i = 0; i < n; ++i)\n-    pp_space (pp);\n-}\n-\n /* Flush the formatted text of PRETTY-PRINTER onto the attached stream.  */\n static inline void\n pp_write_text_to_stream (pretty_printer *pp)\n@@ -164,6 +151,19 @@ pp_append_r (pretty_printer *pp, const char *start, int length)\n   pp->buffer->line_length += length;\n }\n \n+/* Insert enough spaces into the output area of PRETTY-PRINTER to bring\n+   the column position to the current indentation level, assuming that a\n+   newline has just been written to the buffer.  */\n+void\n+pp_base_indent (pretty_printer *pp)\n+{\n+  int n = pp_indentation (pp);\n+  int i;\n+\n+  for (i = 0; i < n; ++i)\n+    pp_space (pp);\n+}\n+\n /* Format a message pointed to by TEXT.  The following format specifiers are\n    recognized as being client independent:\n    %d, %i: (signed) integer in base ten.\n@@ -399,7 +399,7 @@ pp_base_emit_prefix (pretty_printer *pp)\n \tcase DIAGNOSTICS_SHOW_PREFIX_ONCE:\n \t  if (pp->emitted_prefix)\n \t    {\n-\t      pp_indent (pp);\n+\t      pp_base_indent (pp);\n \t      break;\n \t    }\n \t  pp_indentation (pp) += 3;"}, {"sha": "0fd00b33a276d21407b62dd4d2d5b4b628104e65", "filename": "gcc/pretty-print.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b780675e462fe50a27c972672a171927d37564d/gcc%2Fpretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b780675e462fe50a27c972672a171927d37564d/gcc%2Fpretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpretty-print.h?ref=4b780675e462fe50a27c972672a171927d37564d", "patch": "@@ -108,8 +108,6 @@ struct pretty_print_info\n \n   /* The prefix for each new line.  */\n   const char *prefix;\n-\n-  pp_flags flags;\n   \n   /* Where to put whitespace around the entity being formatted.  */\n   pp_padding padding;\n@@ -202,6 +200,8 @@ struct pretty_print_info\n   do {                               \\\n     pp_indentation (PP) += N;        \\\n     pp_newline (PP);                 \\\n+    pp_base_indent (pp_base (PP));   \\\n+    pp_needs_newline (PP) = false;   \\\n   } while (0)\n #define pp_separate_with(PP, C)     \\\n    do {                             \\\n@@ -251,6 +251,7 @@ extern void pp_base_flush (pretty_printer *);\n extern void pp_base_format_text (pretty_printer *, text_info *);\n extern void pp_base_format_verbatim (pretty_printer *, text_info *);\n \n+extern void pp_base_indent (pretty_printer *);\n extern void pp_base_newline (pretty_printer *);\n extern void pp_base_character (pretty_printer *, int);\n extern void pp_base_string (pretty_printer *, const char *);"}]}