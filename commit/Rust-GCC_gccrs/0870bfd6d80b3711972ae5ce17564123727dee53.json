{"sha": "0870bfd6d80b3711972ae5ce17564123727dee53", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDg3MGJmZDZkODBiMzcxMTk3MmFlNWNlMTc1NjQxMjM3MjdkZWU1Mw==", "commit": {"author": {"name": "Alex Samuel", "email": "samuel@codesourcery.com", "date": "2000-10-22T23:59:25Z"}, "committer": {"name": "Alex Samuel", "email": "samuel@gcc.gnu.org", "date": "2000-10-22T23:59:25Z"}, "message": "cp-demangle.c (string_list_def): Add caret_position and comments.\n\n\t* cp-demangle.c (string_list_def): Add caret_position and comments.\n\t(result_caret_pos): New macro.\n\t(result_append_string): Rename to...\n\t(result_add_string): ... this, and insert at caret position.\n\tRename throughout.\n\t(result_append): Rename to...\n\t(result_add): ... this, and insert at caret position.  Rename\n\tthroughout.\n\t(result_append_char): Rename to...\n\t(result_add_char): ... this, and insert at caret position.  Rename\n\tthroughout.\n\t(result_append_space): Remove.\n\t(string_list_new): Initialize caret position.\n\t(result_add_separated_char): Use caret position.\n\t(result_get_caret): New funtion.\n\t(result_set_caret): Likewise.\n\t(result_shift_caret): Likewise.\n\t(result_previous_char_is_space): Likewise.\n\t(substitution_start): Use caret position.\n\t(substitution_add): Likewise.\n\t(demangling_new): Initialize caret position.\n\t(demangle_encoding): Use caret position.\n\t(demanglin_nested_name): Put CV qualifiers after name.\n\t(demangle_type_ptr): Use switch statement.  Handle pointers to\n\tarrays.  Don't use result_append_space.  Use caret position.\n\t(demangle_type): Emit CV qualifiers after underlying type.  Adjust\n\tcall to demangle_array_type.\n\t(demangle_array_type): Add parameter to handle pointers to arrays.\n\nFrom-SVN: r37011", "tree": {"sha": "d62b44d61ba1e292051d51395edbcf4b37a1527e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d62b44d61ba1e292051d51395edbcf4b37a1527e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0870bfd6d80b3711972ae5ce17564123727dee53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0870bfd6d80b3711972ae5ce17564123727dee53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0870bfd6d80b3711972ae5ce17564123727dee53", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0870bfd6d80b3711972ae5ce17564123727dee53/comments", "author": null, "committer": null, "parents": [{"sha": "ae4bd6227a20806b4c7cd116126177101f85d145", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae4bd6227a20806b4c7cd116126177101f85d145", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae4bd6227a20806b4c7cd116126177101f85d145"}], "stats": {"total": 477, "additions": 304, "deletions": 173}, "files": [{"sha": "4317a13bc7206cd0fb18f6412f879401574a2797", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0870bfd6d80b3711972ae5ce17564123727dee53/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0870bfd6d80b3711972ae5ce17564123727dee53/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=0870bfd6d80b3711972ae5ce17564123727dee53", "patch": "@@ -1,3 +1,34 @@\n+2000-10-20  Alex Samuel  <samuel@codesourcery.com>\n+\n+\t* cp-demangle.c (string_list_def): Add caret_position and comments.\n+\t(result_caret_pos): New macro.\n+\t(result_append_string): Rename to...\n+\t(result_add_string): ... this, and insert at caret position.\n+\tRename throughout. \n+\t(result_append): Rename to...\n+\t(result_add): ... this, and insert at caret position.  Rename\n+\tthroughout. \n+\t(result_append_char): Rename to...\n+\t(result_add_char): ... this, and insert at caret position.  Rename\n+\tthroughout. \n+\t(result_append_space): Remove.\n+\t(string_list_new): Initialize caret position.\n+\t(result_add_separated_char): Use caret position.\n+\t(result_get_caret): New funtion.\n+\t(result_set_caret): Likewise.\n+\t(result_shift_caret): Likewise.\n+\t(result_previous_char_is_space): Likewise.\n+\t(substitution_start): Use caret position.\n+\t(substitution_add): Likewise.\n+\t(demangling_new): Initialize caret position.\n+\t(demangle_encoding): Use caret position.\n+\t(demanglin_nested_name): Put CV qualifiers after name. \n+\t(demangle_type_ptr): Use switch statement.  Handle pointers to\n+\tarrays.  Don't use result_append_space.  Use caret position.\n+\t(demangle_type): Emit CV qualifiers after underlying type.  Adjust\n+\tcall to demangle_array_type. \n+\t(demangle_array_type): Add parameter to handle pointers to arrays. \n+\t\n 2000-10-01  Mark Mitchell  <mark@codesourcery.com>\n \n \t* splay-tree.c (splay_tree_insert): Fix formatting."}, {"sha": "a5e5ded10e0fabfaaf84098931e6b4ab935a002c", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 273, "deletions": 173, "changes": 446, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0870bfd6d80b3711972ae5ce17564123727dee53/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0870bfd6d80b3711972ae5ce17564123727dee53/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=0870bfd6d80b3711972ae5ce17564123727dee53", "patch": "@@ -79,13 +79,22 @@ static int flag_verbose;\n    specification -- don't demangle special g++ manglings.  */\n static int flag_strict;\n \n-/* String_list_t is an extended form of dyn_string_t which provides a link\n-   field.  A string_list_t may safely be cast to and used as a\n-   dyn_string_t.  */\n+/* String_list_t is an extended form of dyn_string_t which provides a\n+   link field and a caret position for additions to the string.  A\n+   string_list_t may safely be cast to and used as a dyn_string_t.  */\n \n struct string_list_def\n {\n+  /* The dyn_string; must be first.  */\n   struct dyn_string string;\n+\n+  /* The position at which additional text is added to this string\n+     (using the result_add* macros).  This value is an offset from the\n+     end of the string, not the beginning (and should be\n+     non-positive).  */\n+  int caret_position;\n+\n+  /* The next string in the list.  */\n   struct string_list_def *next;\n };\n \n@@ -272,19 +281,28 @@ static void demangling_delete\n /* Returns the string containing the current demangled result.  */\n #define result_string(DM)       (&(DM)->result->string)\n \n-/* Appends a dyn_string_t to the demangled result.  */\n-#define result_append_string(DM, STRING)                                \\\n-  (dyn_string_append (&(DM)->result->string, (STRING))                  \\\n+/* Returns the position at which new text is inserted into the\n+   demangled result.  */\n+#define result_caret_pos(DM)                                            \\\n+  (result_length (DM) +                                                 \\\n+   ((string_list_t) result_string (DM))->caret_position)\n+\n+/* Adds a dyn_string_t to the demangled result.  */\n+#define result_add_string(DM, STRING)                                   \\\n+  (dyn_string_insert (&(DM)->result->string,                            \\\n+\t\t      result_caret_pos (DM), (STRING))                  \\\n    ? STATUS_OK : STATUS_ALLOCATION_FAILED)\n \n-/* Appends NUL-terminated string CSTR to the demangled result.  */\n-#define result_append(DM, CSTR)                                         \\\n-  (dyn_string_append_cstr (&(DM)->result->string, (CSTR))               \\\n+/* Adds NUL-terminated string CSTR to the demangled result.    */\n+#define result_add(DM, CSTR)                                            \\\n+  (dyn_string_insert_cstr (&(DM)->result->string,                       \\\n+\t\t\t   result_caret_pos (DM), (CSTR))               \\\n    ? STATUS_OK : STATUS_ALLOCATION_FAILED)\n \n-/* Appends character CHAR to the demangled result.  */\n-#define result_append_char(DM, CHAR)                                    \\\n-  (dyn_string_append_char (&(DM)->result->string, (CHAR))               \\\n+/* Adds character CHAR to the demangled result.  */\n+#define result_add_char(DM, CHAR)                                       \\\n+  (dyn_string_insert_char (&(DM)->result->string,                       \\\n+\t\t\t   result_caret_pos (DM), (CHAR))               \\\n    ? STATUS_OK : STATUS_ALLOCATION_FAILED)\n \n /* Inserts a dyn_string_t to the demangled result at position POS.  */\n@@ -307,12 +325,6 @@ static void demangling_delete\n #define result_length(DM)                                               \\\n   dyn_string_length (&(DM)->result->string)\n \n-/* Appends a space to the demangled result if the last character is\n-   not a space.  */\n-#define result_append_space(DM)                                         \\\n-  (dyn_string_append_space (&(DM)->result->string)                      \\\n-   ? STATUS_OK : STATUS_ALLOCATION_FAILED)\n-\n /* Appends a (less-than, greater-than) character to the result in DM\n    to (open, close) a template argument or parameter list.  Appends a\n    space first if necessary to prevent spurious elision of angle\n@@ -380,6 +392,7 @@ string_list_new (length)\n      int length;\n {\n   string_list_t s = (string_list_t) malloc (sizeof (struct string_list_def));\n+  s->caret_position = 0;\n   if (s == NULL)\n     return NULL;\n   if (!dyn_string_init ((dyn_string_t) s, length))\n@@ -409,20 +422,15 @@ result_add_separated_char (dm, character)\n      demangling_t dm;\n      int character;\n {\n-  dyn_string_t s = &dm->result->string;\n+  char *result = dyn_string_buf (result_string (dm));\n+  int caret_pos = result_caret_pos (dm);\n \n-  /* Add a space if the last character is already a closing angle\n-     bracket, so that a nested template arg list doesn't look like\n-     it's closed with a right-shift operator.  */\n-  if (dyn_string_last_char (s) == character)\n-    {\n-      if (!dyn_string_append_char (s, ' '))\n-\treturn STATUS_ALLOCATION_FAILED;\n-    }\n-\n-  /* Add closing angle brackets.  */\n-  if (!dyn_string_append_char (s, character))\n-    return STATUS_ALLOCATION_FAILED;\n+  /* Add a space if the last character is already the character we\n+     want to add.  */\n+  if (caret_pos > 0 && result[caret_pos - 1] == character)\n+    RETURN_IF_ERROR (result_add_char (dm, ' '));\n+  /* Add the character.  */\n+  RETURN_IF_ERROR (result_add_char (dm, character));\n \n   return STATUS_OK;\n }\n@@ -460,6 +468,51 @@ result_pop (dm)\n   return top;\n }\n \n+/* Returns the current value of the caret for the result string.  The\n+   value is an offet from the end of the result string.  */\n+\n+static int\n+result_get_caret (dm)\n+     demangling_t dm;\n+{\n+  return ((string_list_t) result_string (dm))->caret_position;\n+}\n+\n+/* Sets the value of the caret for the result string, counted as an\n+   offet from the end of the result string.  */\n+\n+static void\n+result_set_caret (dm, position)\n+     demangling_t dm;\n+     int position;\n+{\n+  ((string_list_t) result_string (dm))->caret_position = position;\n+}\n+\n+/* Shifts the position of the next addition to the result by\n+   POSITION_OFFSET.  A negative value shifts the caret to the left.  */\n+\n+static void\n+result_shift_caret (dm, position_offset)\n+     demangling_t dm;\n+     int position_offset;\n+{\n+  ((string_list_t) result_string (dm))->caret_position += position_offset;\n+}\n+\n+/* Returns non-zero if the character that comes right before the place\n+   where text will be added to the result is a space.  In this case,\n+   the caller should supress adding another space.  */\n+\n+static int\n+result_previous_char_is_space (dm)\n+     demangling_t dm;\n+{\n+  char *result = dyn_string_buf (result_string (dm));\n+  int pos = result_caret_pos (dm);\n+  return pos > 0 && result[pos - 1] == ' ';\n+}\n+\n /* Returns the start position of a fragment of the demangled result\n    that will be a substitution candidate.  Should be called at the\n    start of productions that can add substitutions.  */\n@@ -468,7 +521,7 @@ static int\n substitution_start (dm)\n      demangling_t dm;\n {\n-  return result_length (dm);\n+  return result_caret_pos (dm);\n }\n \n /* Adds the suffix of the current demangled result of DM starting at\n@@ -491,7 +544,7 @@ substitution_add (dm, start_position, template_p)\n   /* Extract the substring of the current demangling result that\n      represents the subsitution candidate.  */\n   if (!dyn_string_substring (substitution, \n-\t\t\t     result, start_position, result_length (dm)))\n+\t\t\t     result, start_position, result_caret_pos (dm)))\n     {\n       dyn_string_delete (substitution);\n       return STATUS_ALLOCATION_FAILED;\n@@ -843,7 +896,7 @@ static status_t demangle_bare_function_type\n static status_t demangle_class_enum_type\n   PARAMS ((demangling_t, int *));\n static status_t demangle_array_type\n-  PARAMS ((demangling_t));\n+  PARAMS ((demangling_t, int *));\n static status_t demangle_template_param\n   PARAMS ((demangling_t));\n static status_t demangle_template_args\n@@ -933,7 +986,7 @@ demangle_encoding (dm)\n   \n   /* Remember where the name starts.  If it turns out to be a template\n      function, we'll have to insert the return type here.  */\n-  start_position = result_length (dm);\n+  start_position = result_caret_pos (dm);\n \n   if (peek == 'G' || peek == 'T')\n     RETURN_IF_ERROR (demangle_special_name (dm));\n@@ -943,7 +996,7 @@ demangle_encoding (dm)\n       RETURN_IF_ERROR (demangle_name (dm, &encode_return_type));\n \n       /* If there's anything left, the name was a function name, with\n-\t maybe its return type, and its parameters types, following.  */\n+\t maybe its return type, and its parameter types, following.  */\n       if (!end_of_name_p (dm) \n \t  && peek_char (dm) != 'E')\n \t{\n@@ -1017,7 +1070,7 @@ demangle_name (dm, encode_return_type)\n \t{\n \t  (void) next_char (dm);\n \t  (void) next_char (dm);\n-\t  RETURN_IF_ERROR (result_append (dm, \"std::\"));\n+\t  RETURN_IF_ERROR (result_add (dm, \"std::\"));\n \t  RETURN_IF_ERROR \n \t    (demangle_unqualified_name (dm, &suppress_return_type));\n \t  is_std_substitution = 1;\n@@ -1082,20 +1135,30 @@ demangle_nested_name (dm, encode_return_type)\n   peek = peek_char (dm);\n   if (peek == 'r' || peek == 'V' || peek == 'K')\n     {\n+      dyn_string_t cv_qualifiers;\n       status_t status;\n \n-      /* Snarf up and emit CV qualifiers.  */\n-      dyn_string_t cv_qualifiers = dyn_string_new (24);\n+      /* Snarf up CV qualifiers.  */\n+      cv_qualifiers = dyn_string_new (24);\n       if (cv_qualifiers == NULL)\n \treturn STATUS_ALLOCATION_FAILED;\n-\n       demangle_CV_qualifiers (dm, cv_qualifiers);\n-      status = result_append_string (dm, cv_qualifiers);\n+\n+      /* Emit them, preceded by a space.  */\n+      status = result_add_char (dm, ' ');\n+      if (STATUS_NO_ERROR (status)) \n+\tstatus = result_add_string (dm, cv_qualifiers);\n+      /* The CV qualifiers that occur in a <nested-name> will be\n+\t qualifiers for member functions.  These are placed at the end\n+\t of the function.  Therefore, shift the caret to the left by\n+\t the length of the qualifiers, so other text is inserted\n+\t before them and they stay at the end.  */\n+      result_shift_caret (dm, -dyn_string_length (cv_qualifiers) - 1);\n+      /* Clean up.  */\n       dyn_string_delete (cv_qualifiers);\n       RETURN_IF_ERROR (status);\n-      RETURN_IF_ERROR (result_append_space (dm));\n     }\n-  \n+\n   RETURN_IF_ERROR (demangle_prefix (dm, encode_return_type));\n   /* No need to demangle the final <unqualified-name>; demangle_prefix\n      will handle it.  */\n@@ -1159,7 +1222,7 @@ demangle_prefix (dm, encode_return_type)\n \t{\n \t  /* We have another level of scope qualification.  */\n \t  if (nested)\n-\t    RETURN_IF_ERROR (result_append (dm, \"::\"));\n+\t    RETURN_IF_ERROR (result_add (dm, \"::\"));\n \t  else\n \t    nested = 1;\n \n@@ -1275,7 +1338,7 @@ demangle_source_name (dm)\n \t\t\t\t\tdm->last_source_name));\n \n   /* Emit it.  */\n-  RETURN_IF_ERROR (result_append_string (dm, dm->last_source_name));\n+  RETURN_IF_ERROR (result_add_string (dm, dm->last_source_name));\n \n   return STATUS_OK;\n }\n@@ -1547,7 +1610,7 @@ demangle_operator_name (dm, short_name, num_args)\n   /* Is this a vendor-extended operator?  */\n   if (c0 == 'v' && IS_DIGIT (c1))\n     {\n-      RETURN_IF_ERROR (result_append (dm, \"operator \"));\n+      RETURN_IF_ERROR (result_add (dm, \"operator \"));\n       RETURN_IF_ERROR (demangle_source_name (dm));\n       *num_args = 0;\n       return STATUS_OK;\n@@ -1556,7 +1619,7 @@ demangle_operator_name (dm, short_name, num_args)\n   /* Is this a conversion operator?  */\n   if (c0 == 'c' && c1 == 'v')\n     {\n-      RETURN_IF_ERROR (result_append (dm, \"operator \"));\n+      RETURN_IF_ERROR (result_add (dm, \"operator \"));\n       /* Demangle the converted-to type.  */\n       RETURN_IF_ERROR (demangle_type (dm));\n       *num_args = 0;\n@@ -1574,8 +1637,8 @@ demangle_operator_name (dm, short_name, num_args)\n \t/* Found it.  */\n \t{\n \t  if (!short_name)\n-\t    RETURN_IF_ERROR (result_append (dm, \"operator\"));\n-\t  RETURN_IF_ERROR (result_append (dm, p->name));\n+\t    RETURN_IF_ERROR (result_add (dm, \"operator\"));\n+\t  RETURN_IF_ERROR (result_add (dm, p->name));\n \t  *num_args = p->num_args;\n \n \t  return STATUS_OK;\n@@ -1615,11 +1678,11 @@ demangle_nv_offset (dm)\n   /* Don't display the offset unless in verbose mode.  */\n   if (flag_verbose)\n     {\n-      status = result_append (dm, \" [nv:\");\n+      status = result_add (dm, \" [nv:\");\n       if (STATUS_NO_ERROR (status))\n-\tstatus = result_append_string (dm, number);\n+\tstatus = result_add_string (dm, number);\n       if (STATUS_NO_ERROR (status))\n-\tstatus = result_append_char (dm, ']');\n+\tstatus = result_add_char (dm, ']');\n     }\n \n   /* Clean up.  */\n@@ -1651,11 +1714,11 @@ demangle_v_offset (dm)\n   /* Don't display the offset unless in verbose mode.  */\n   if (flag_verbose)\n     {\n-      status = result_append (dm, \" [v:\");\n+      status = result_add (dm, \" [v:\");\n       if (STATUS_NO_ERROR (status))\n-\tstatus = result_append_string (dm, number);\n+\tstatus = result_add_string (dm, number);\n       if (STATUS_NO_ERROR (status))\n-\tresult_append_char (dm, ',');\n+\tresult_add_char (dm, ',');\n     }\n   dyn_string_delete (number);\n   RETURN_IF_ERROR (status);\n@@ -1672,9 +1735,9 @@ demangle_v_offset (dm)\n   /* Don't display the vcall offset unless in verbose mode.  */\n   if (flag_verbose)\n     {\n-      status = result_append_string (dm, number);\n+      status = result_add_string (dm, number);\n       if (STATUS_NO_ERROR (status))\n-\tstatus = result_append_char (dm, ']');\n+\tstatus = result_add_char (dm, ']');\n     }\n   dyn_string_delete (number);\n   RETURN_IF_ERROR (status);\n@@ -1763,7 +1826,7 @@ demangle_special_name (dm)\n       /* A guard variable name.  Consume the G.  */\n       advance_char (dm);\n       RETURN_IF_ERROR (demangle_char (dm, 'V'));\n-      RETURN_IF_ERROR (result_append (dm, \"guard variable for \"));\n+      RETURN_IF_ERROR (result_add (dm, \"guard variable for \"));\n       RETURN_IF_ERROR (demangle_name (dm, &unused));\n     }\n   else if (peek == 'T')\n@@ -1778,77 +1841,77 @@ demangle_special_name (dm)\n \tcase 'V':\n \t  /* Virtual table.  */\n \t  advance_char (dm);\n-\t  RETURN_IF_ERROR (result_append (dm, \"vtable for \"));\n+\t  RETURN_IF_ERROR (result_add (dm, \"vtable for \"));\n \t  RETURN_IF_ERROR (demangle_type (dm));\n \t  break;\n \n \tcase 'T':\n \t  /* VTT structure.  */\n \t  advance_char (dm);\n-\t  RETURN_IF_ERROR (result_append (dm, \"VTT for \"));\n+\t  RETURN_IF_ERROR (result_add (dm, \"VTT for \"));\n \t  RETURN_IF_ERROR (demangle_type (dm));\n \t  break;\n \n \tcase 'I':\n \t  /* Typeinfo structure.  */\n \t  advance_char (dm);\n-\t  RETURN_IF_ERROR (result_append (dm, \"typeinfo for \"));\n+\t  RETURN_IF_ERROR (result_add (dm, \"typeinfo for \"));\n \t  RETURN_IF_ERROR (demangle_type (dm));\n \t  break;\n \n \tcase 'F':\n \t  /* Typeinfo function.  Used only in old ABI with new mangling.  */\n \t  advance_char (dm);\n-\t  RETURN_IF_ERROR (result_append (dm, \"typeinfo fn for \"));\n+\t  RETURN_IF_ERROR (result_add (dm, \"typeinfo fn for \"));\n \t  RETURN_IF_ERROR (demangle_type (dm));\n \t  break;\n \n \tcase 'S':\n \t  /* Character string containing type name, used in typeinfo. */\n \t  advance_char (dm);\n-\t  RETURN_IF_ERROR (result_append (dm, \"typeinfo name for \"));\n+\t  RETURN_IF_ERROR (result_add (dm, \"typeinfo name for \"));\n \t  RETURN_IF_ERROR (demangle_type (dm));\n \t  break;\n \n \tcase 'J':\n \t  /* The java Class variable corresponding to a C++ class.  */\n \t  advance_char (dm);\n-\t  RETURN_IF_ERROR (result_append (dm, \"java Class for \"));\n+\t  RETURN_IF_ERROR (result_add (dm, \"java Class for \"));\n \t  RETURN_IF_ERROR (demangle_type (dm));\n \t  break;\n \n \tcase 'h':\n \t  /* Non-virtual thunk.  */\n \t  advance_char (dm);\n-\t  RETURN_IF_ERROR (result_append (dm, \"non-virtual thunk\"));\n+\t  RETURN_IF_ERROR (result_add (dm, \"non-virtual thunk\"));\n \t  RETURN_IF_ERROR (demangle_nv_offset (dm));\n \t  /* Demangle the separator.  */\n \t  RETURN_IF_ERROR (demangle_char (dm, '_'));\n \t  /* Demangle and emit the target name and function type.  */\n-\t  RETURN_IF_ERROR (result_append (dm, \" to \"));\n+\t  RETURN_IF_ERROR (result_add (dm, \" to \"));\n \t  RETURN_IF_ERROR (demangle_encoding (dm));\n \t  break;\n \n \tcase 'v':\n \t  /* Virtual thunk.  */\n \t  advance_char (dm);\n-\t  RETURN_IF_ERROR (result_append (dm, \"virtual thunk\"));\n+\t  RETURN_IF_ERROR (result_add (dm, \"virtual thunk\"));\n \t  RETURN_IF_ERROR (demangle_v_offset (dm));\n \t  /* Demangle the separator.  */\n \t  RETURN_IF_ERROR (demangle_char (dm, '_'));\n \t  /* Demangle and emit the target function.  */\n-\t  RETURN_IF_ERROR (result_append (dm, \" to \"));\n+\t  RETURN_IF_ERROR (result_add (dm, \" to \"));\n \t  RETURN_IF_ERROR (demangle_encoding (dm));\n \t  break;\n \n \tcase 'c':\n \t  /* Covariant return thunk.  */\n \t  advance_char (dm);\n-\t  RETURN_IF_ERROR (result_append (dm, \"covariant return thunk\"));\n+\t  RETURN_IF_ERROR (result_add (dm, \"covariant return thunk\"));\n \t  RETURN_IF_ERROR (demangle_call_offset (dm));\n \t  RETURN_IF_ERROR (demangle_call_offset (dm));\n \t  /* Demangle and emit the target function.  */\n-\t  RETURN_IF_ERROR (result_append (dm, \" to \"));\n+\t  RETURN_IF_ERROR (result_add (dm, \" to \"));\n \t  RETURN_IF_ERROR (demangle_encoding (dm));\n \t  break;\n \n@@ -1859,7 +1922,7 @@ demangle_special_name (dm)\n \t      dyn_string_t derived_type;\n \n \t      advance_char (dm);\n-\t      RETURN_IF_ERROR (result_append (dm, \"construction vtable for \"));\n+\t      RETURN_IF_ERROR (result_add (dm, \"construction vtable for \"));\n \n \t      /* Demangle the derived type off to the side.  */\n \t      RETURN_IF_ERROR (result_push (dm));\n@@ -1883,17 +1946,17 @@ demangle_special_name (dm)\n \n \t      /* Emit the derived type.  */\n \t      if (STATUS_NO_ERROR (status))\n-\t\tstatus = result_append (dm, \"-in-\");\n+\t\tstatus = result_add (dm, \"-in-\");\n \t      if (STATUS_NO_ERROR (status))\n-\t\tstatus = result_append_string (dm, derived_type);\n+\t\tstatus = result_add_string (dm, derived_type);\n \t      dyn_string_delete (derived_type);\n \n \t      /* Don't display the offset unless in verbose mode.  */\n \t      if (flag_verbose)\n \t\t{\n-\t\t  status = result_append_char (dm, ' ');\n+\t\t  status = result_add_char (dm, ' ');\n \t\t  if (STATUS_NO_ERROR (status))\n-\t\t    result_append_string (dm, number);\n+\t\t    result_add_string (dm, number);\n \t\t}\n \t      dyn_string_delete (number);\n \t      RETURN_IF_ERROR (status);\n@@ -1949,14 +2012,14 @@ demangle_ctor_dtor_name (dm)\n       advance_char (dm);\n       if (peek_char (dm) < '1' || peek_char (dm) > '3')\n \treturn \"Unrecognized constructor.\";\n-      RETURN_IF_ERROR (result_append_string (dm, dm->last_source_name));\n+      RETURN_IF_ERROR (result_add_string (dm, dm->last_source_name));\n       /* Print the flavor of the constructor if in verbose mode.  */\n       flavor = next_char (dm) - '1';\n       if (flag_verbose)\n \t{\n-\t  RETURN_IF_ERROR (result_append (dm, \"[\"));\n-\t  RETURN_IF_ERROR (result_append (dm, ctor_flavors[flavor]));\n-\t  RETURN_IF_ERROR (result_append_char (dm, ']'));\n+\t  RETURN_IF_ERROR (result_add (dm, \"[\"));\n+\t  RETURN_IF_ERROR (result_add (dm, ctor_flavors[flavor]));\n+\t  RETURN_IF_ERROR (result_add_char (dm, ']'));\n \t}\n     }\n   else if (peek == 'D')\n@@ -1965,15 +2028,15 @@ demangle_ctor_dtor_name (dm)\n       advance_char (dm);\n       if (peek_char (dm) < '0' || peek_char (dm) > '2')\n \treturn \"Unrecognized destructor.\";\n-      RETURN_IF_ERROR (result_append_char (dm, '~'));\n-      RETURN_IF_ERROR (result_append_string (dm, dm->last_source_name));\n+      RETURN_IF_ERROR (result_add_char (dm, '~'));\n+      RETURN_IF_ERROR (result_add_string (dm, dm->last_source_name));\n       /* Print the flavor of the destructor if in verbose mode.  */\n       flavor = next_char (dm) - '0';\n       if (flag_verbose)\n \t{\n-\t  RETURN_IF_ERROR (result_append (dm, \" [\"));\n-\t  RETURN_IF_ERROR (result_append (dm, dtor_flavors[flavor]));\n-\t  RETURN_IF_ERROR (result_append_char (dm, ']'));\n+\t  RETURN_IF_ERROR (result_add (dm, \" [\"));\n+\t  RETURN_IF_ERROR (result_add (dm, dtor_flavors[flavor]));\n+\t  RETURN_IF_ERROR (result_add_char (dm, ']'));\n \t}\n     }\n   else\n@@ -2014,17 +2077,16 @@ demangle_type_ptr (dm, insert_pos, substitution_start)\n      int *insert_pos;\n      int substitution_start;\n {\n-  char next;\n   status_t status;\n   int is_substitution_candidate = 1;\n \n   DEMANGLE_TRACE (\"type*\", dm);\n \n   /* Scan forward, collecting pointers and references into symbols,\n      until we hit something else.  Then emit the type.  */\n-  next = peek_char (dm);\n-  if (next == 'P')\n+  switch (peek_char (dm))\n     {\n+    case 'P':\n       /* A pointer.  Snarf the `P'.  */\n       advance_char (dm);\n       /* Demangle the underlying type.  */\n@@ -2036,9 +2098,9 @@ demangle_type_ptr (dm, insert_pos, substitution_start)\n       /* The next (outermost) pointer or reference character should go\n \t after this one.  */\n       ++(*insert_pos);\n-    }\n-  else if (next == 'R')\n-    {\n+      break;\n+\n+    case 'R':\n       /* A reference.  Snarf the `R'.  */\n       advance_char (dm);\n       /* Demangle the underlying type.  */\n@@ -2050,8 +2112,9 @@ demangle_type_ptr (dm, insert_pos, substitution_start)\n       /* The next (outermost) pointer or reference character should go\n \t after this one.  */\n       ++(*insert_pos);\n-    }\n-  else if (next == 'M')\n+      break;\n+\n+    case 'M':\n     {\n       /* A pointer-to-member.  */\n       dyn_string_t class_type;\n@@ -2071,17 +2134,24 @@ demangle_type_ptr (dm, insert_pos, substitution_start)\n \t   and set *insert_pos to the spot between the first\n \t   parentheses.  */\n \tstatus = demangle_type_ptr (dm, insert_pos, substitution_start);\n+      else if (peek_char (dm) == 'A')\n+\t/* A pointer-to-member array variable.  We want output that\n+\t   looks like `int (Klass::*) [10]'.  Demangle the array type\n+\t   as `int () [10]', and set *insert_pos to the spot between\n+\t   the parentheses.  */\n+\tstatus = demangle_array_type (dm, insert_pos);\n       else\n         {\n \t  /* A pointer-to-member variable.  Demangle the type of the\n              pointed-to member.  */\n \t  status = demangle_type (dm);\n \t  /* Make it pretty.  */\n-\t  if (STATUS_NO_ERROR (status))\n-\t    status = result_append_space (dm);\n+\t  if (STATUS_NO_ERROR (status)\n+\t      && !result_previous_char_is_space (dm))\n+\t    status = result_add_char (dm, ' ');\n \t  /* The pointer-to-member notation (e.g. `C::*') follows the\n              member's type.  */\n-\t  *insert_pos = result_length (dm);\n+\t  *insert_pos = result_caret_pos (dm);\n \t}\n \n       /* Build the pointer-to-member notation.  */\n@@ -2100,15 +2170,16 @@ demangle_type_ptr (dm, insert_pos, substitution_start)\n \n       RETURN_IF_ERROR (status);\n     }\n-  else if (next == 'F')\n-    {\n+    break;\n+\n+    case 'F':\n       /* Ooh, tricky, a pointer-to-function.  When we demangle the\n \t function type, the return type should go at the very\n \t beginning.  */\n-      *insert_pos = result_length (dm);\n+      *insert_pos = result_caret_pos (dm);\n       /* The parentheses indicate this is a function pointer or\n \t reference type.  */\n-      RETURN_IF_ERROR (result_append (dm, \"()\"));\n+      RETURN_IF_ERROR (result_add (dm, \"()\"));\n       /* Now demangle the function type.  The return type will be\n \t inserted before the `()', and the argument list will go after\n \t it.  */\n@@ -2120,20 +2191,27 @@ demangle_type_ptr (dm, insert_pos, substitution_start)\n \t type.  Move it one character over so it points inside the\n \t `()'.  */\n       ++(*insert_pos);\n-    }\n-  else\n-    {\n+      break;\n+\n+    case 'A':\n+      /* An array pointer or reference.  demangle_array_type will figure\n+\t out where the asterisks and ampersands go.  */\n+      RETURN_IF_ERROR (demangle_array_type (dm, insert_pos));\n+      break;\n+\n+    default:\n       /* No more pointer or reference tokens; this is therefore a\n \t pointer to data.  Finish up by demangling the underlying\n \t type.  */\n       RETURN_IF_ERROR (demangle_type (dm));\n       /* The pointer or reference characters follow the underlying\n \t type, as in `int*&'.  */\n-      *insert_pos = result_length (dm);\n+      *insert_pos = result_caret_pos (dm);\n       /* Because of the production <type> ::= <substitution>,\n \t demangle_type will already have added the underlying type as\n \t a substitution candidate.  Don't do it again.  */\n       is_substitution_candidate = 0;\n+      break;\n     }\n   \n   if (is_substitution_candidate)\n@@ -2201,42 +2279,38 @@ demangle_type (dm)\n \t{\n \t  status_t status;\n \t  dyn_string_t cv_qualifiers = dyn_string_new (24);\n+\t  int old_caret_position = result_get_caret (dm);\n \n \t  if (cv_qualifiers == NULL)\n \t    return STATUS_ALLOCATION_FAILED;\n \n+\t  /* Decode all adjacent CV qualifiers.  */\n \t  demangle_CV_qualifiers (dm, cv_qualifiers);\n-\n-\t  /* If the qualifiers apply to a pointer or reference, they\n-\t     need to come after the whole qualified type.  */\n-\t  if (peek_char (dm) == 'P' || peek_char (dm) == 'R')\n-\t    {\n-\t      status = demangle_type (dm);\n-\t      if (STATUS_NO_ERROR (status))\n-\t\tstatus = result_append_space (dm);\n-\t      if (STATUS_NO_ERROR (status))\n-\t\tstatus = result_append_string (dm, cv_qualifiers);\n-\t    }\n-\t  /* Otherwise, the qualifiers come first.  */\n-\t  else\n-\t    {\n-\t      status = result_append_string (dm, cv_qualifiers);\n-\t      if (STATUS_NO_ERROR (status))\n-\t\tstatus = result_append_space (dm);\n-\t      if (STATUS_NO_ERROR (status))\n-\t\tstatus = demangle_type (dm);\n-\t    }\n-\n+\t  /* Emit them, and shift the caret left so that the\n+\t     underlying type will be emitted before the qualifiers.  */\n+\t  status = result_add_string (dm, cv_qualifiers);\n+\t  result_shift_caret (dm, -dyn_string_length (cv_qualifiers));\n+\t  /* Clean up.  */\n \t  dyn_string_delete (cv_qualifiers);\n \t  RETURN_IF_ERROR (status);\n+\t  /* Also prepend a blank, if needed.  */\n+\t  RETURN_IF_ERROR (result_add_char (dm, ' '));\n+\t  result_shift_caret (dm, -1);\n+\n+\t  /* Demangle the underlying type.  It will be emitted before\n+\t     the CV qualifiers, since we moved the caret.  */\n+\t  RETURN_IF_ERROR (demangle_type (dm));\n+\n+\t  /* Put the caret back where it was previously.  */\n+\t  result_set_caret (dm, old_caret_position);\n \t}\n \tbreak;\n \n       case 'F':\n \treturn \"Non-pointer or -reference function type.\";\n \n       case 'A':\n-\tRETURN_IF_ERROR (demangle_array_type (dm));\n+\tRETURN_IF_ERROR (demangle_array_type (dm, NULL));\n \tbreak;\n \n       case 'T':\n@@ -2325,14 +2399,14 @@ demangle_type (dm)\n \n       case 'C':\n \t/* A C99 complex type.  */\n-\tRETURN_IF_ERROR (result_append (dm, \"complex \"));\n+\tRETURN_IF_ERROR (result_add (dm, \"complex \"));\n \tadvance_char (dm);\n \tRETURN_IF_ERROR (demangle_type (dm));\n \tbreak;\n \n       case 'G':\n \t/* A C99 imaginary type.  */\n-\tRETURN_IF_ERROR (result_append (dm, \"imaginary \"));\n+\tRETURN_IF_ERROR (result_add (dm, \"imaginary \"));\n \tadvance_char (dm);\n \tRETURN_IF_ERROR (demangle_type (dm));\n \tbreak;\n@@ -2341,7 +2415,7 @@ demangle_type (dm)\n \t/* Vendor-extended type qualifier.  */\n \tadvance_char (dm);\n \tRETURN_IF_ERROR (demangle_source_name (dm));\n-\tRETURN_IF_ERROR (result_append_char (dm, ' '));\n+\tRETURN_IF_ERROR (result_add_char (dm, ' '));\n \tRETURN_IF_ERROR (demangle_type (dm));\n \tbreak;\n \n@@ -2441,7 +2515,7 @@ demangle_builtin_type (dm)\n       if (type_name == NULL)\n \treturn \"Unrecognized <builtin-type> code.\";\n \n-      RETURN_IF_ERROR (result_append (dm, type_name));\n+      RETURN_IF_ERROR (result_add (dm, type_name));\n       advance_char (dm);\n       return STATUS_OK;\n     }\n@@ -2512,7 +2586,7 @@ demangle_function_type (dm, function_name_pos)\n     {\n       /* Indicate this function has C linkage if in verbose mode.  */\n       if (flag_verbose)\n-\tRETURN_IF_ERROR (result_append (dm, \" [extern \\\"C\\\"] \"));\n+\tRETURN_IF_ERROR (result_add (dm, \" [extern \\\"C\\\"] \"));\n       advance_char (dm);\n     }\n   RETURN_IF_ERROR (demangle_bare_function_type (dm, function_name_pos));\n@@ -2539,7 +2613,7 @@ demangle_bare_function_type (dm, return_type_pos)\n \n   DEMANGLE_TRACE (\"bare-function-type\", dm);\n \n-  RETURN_IF_ERROR (result_append_char (dm, '('));\n+  RETURN_IF_ERROR (result_add_char (dm, '('));\n   while (!end_of_name_p (dm) && peek_char (dm) != 'E')\n     {\n       if (sequence == -1)\n@@ -2581,15 +2655,15 @@ demangle_bare_function_type (dm, return_type_pos)\n \t    {\n \t      /* Separate parameter types by commas.  */\n \t      if (sequence > 0)\n-\t\tRETURN_IF_ERROR (result_append (dm, \", \"));\n+\t\tRETURN_IF_ERROR (result_add (dm, \", \"));\n \t      /* Demangle the type.  */\n \t      RETURN_IF_ERROR (demangle_type (dm));\n \t    }\n \t}\n \n       ++sequence;\n     }\n-  RETURN_IF_ERROR (result_append_char (dm, ')'));\n+  RETURN_IF_ERROR (result_add_char (dm, ')'));\n \n   /* We should have demangled at least one parameter type (which would\n      be void, for a function that takes no parameters), plus the\n@@ -2620,17 +2694,32 @@ demangle_class_enum_type (dm, encode_return_type)\n \n /* Demangles and emits an <array-type>.  \n \n+   If PTR_INSERT_POS is not NULL, the array type is formatted as a\n+   pointer or reference to an array, except that asterisk and\n+   ampersand punctuation is omitted (since it's not know at this\n+   point).  *PTR_INSERT_POS is set to the position in the demangled\n+   name at which this punctuation should be inserted.  For example,\n+   `A10_i' is demangled to `int () [10]' and *PTR_INSERT_POS points\n+   between the parentheses.\n+\n+   If PTR_INSERT_POS is NULL, the array type is assumed not to be\n+   pointer- or reference-qualified.  Then, for example, `A10_i' is\n+   demangled simply as `int[10]'.  \n+\n     <array-type> ::= A [<dimension number>] _ <element type>  \n                  ::= A <dimension expression> _ <element type>  */\n \n static status_t\n-demangle_array_type (dm)\n+demangle_array_type (dm, ptr_insert_pos)\n      demangling_t dm;\n+     int *ptr_insert_pos;\n {\n   status_t status = STATUS_OK;\n   dyn_string_t array_size = NULL;\n   char peek;\n \n+  DEMANGLE_TRACE (\"array-type\", dm);\n+\n   RETURN_IF_ERROR (demangle_char (dm, 'A'));\n \n   /* Demangle the array size into array_size.  */\n@@ -2664,13 +2753,24 @@ demangle_array_type (dm)\n   if (STATUS_NO_ERROR (status))\n     status = demangle_type (dm);\n \n+  if (ptr_insert_pos != NULL)\n+    {\n+      /* This array is actually part of an pointer- or\n+\t reference-to-array type.  Format appropriately, except we\n+\t don't know which and how much punctuation to use.  */\n+      if (STATUS_NO_ERROR (status))\n+\tstatus = result_add (dm, \" () \");\n+      /* Let the caller know where to insert the punctuation.  */\n+      *ptr_insert_pos = result_caret_pos (dm) - 2;\n+    }\n+\n   /* Emit the array dimension syntax.  */\n   if (STATUS_NO_ERROR (status))\n-    status = result_append_char (dm, '[');\n+    status = result_add_char (dm, '[');\n   if (STATUS_NO_ERROR (status) && array_size != NULL)\n-    status = result_append_string (dm, array_size);\n+    status = result_add_string (dm, array_size);\n   if (STATUS_NO_ERROR (status))\n-    status = result_append_char (dm, ']');\n+    status = result_add_char (dm, ']');\n   if (array_size != NULL)\n     dyn_string_delete (array_size);\n   \n@@ -2714,7 +2814,7 @@ demangle_template_param (dm)\n     /* parm_number exceeded the number of arguments in the current\n        template argument list.  */\n     return \"Template parameter number out of bounds.\";\n-  RETURN_IF_ERROR (result_append_string (dm, (dyn_string_t) arg));\n+  RETURN_IF_ERROR (result_add_string (dm, (dyn_string_t) arg));\n \n   return STATUS_OK;\n }\n@@ -2752,15 +2852,15 @@ demangle_template_args (dm)\n       if (first)\n \tfirst = 0;\n       else\n-\tRETURN_IF_ERROR (result_append (dm, \", \"));\n+\tRETURN_IF_ERROR (result_add (dm, \", \"));\n \n       /* Capture the template arg.  */\n       RETURN_IF_ERROR (result_push (dm));\n       RETURN_IF_ERROR (demangle_template_arg (dm));\n       arg = result_pop (dm);\n \n       /* Emit it in the demangled name.  */\n-      RETURN_IF_ERROR (result_append_string (dm, (dyn_string_t) arg));\n+      RETURN_IF_ERROR (result_add_string (dm, (dyn_string_t) arg));\n \n       /* Save it for use in expanding <template-param>s.  */\n       template_arg_list_add_arg (arg_list, arg);\n@@ -2836,9 +2936,9 @@ demangle_literal (dm)\n \t     corresponding to false or true, respectively.  */\n \t  value = peek_char (dm);\n \t  if (value == '0')\n-\t    RETURN_IF_ERROR (result_append (dm, \"false\"));\n+\t    RETURN_IF_ERROR (result_add (dm, \"false\"));\n \t  else if (value == '1')\n-\t    RETURN_IF_ERROR (result_append (dm, \"true\"));\n+\t    RETURN_IF_ERROR (result_add (dm, \"true\"));\n \t  else\n \t    return \"Unrecognized bool constant.\";\n \t  /* Consume the 0 or 1.  */\n@@ -2856,10 +2956,10 @@ demangle_literal (dm)\n \t  value_string = dyn_string_new (0);\n \t  status = demangle_number_literally (dm, value_string, 10, 1);\n \t  if (STATUS_NO_ERROR (status))\n-\t    status = result_append_string (dm, value_string);\n+\t    status = result_add_string (dm, value_string);\n \t  /* For long integers, append an l.  */\n \t  if (code == 'l' && STATUS_NO_ERROR (status))\n-\t    status = result_append_char (dm, code);\n+\t    status = result_add_char (dm, code);\n \t  dyn_string_delete (value_string);\n \n \t  RETURN_IF_ERROR (status);\n@@ -2869,17 +2969,17 @@ demangle_literal (dm)\n \t literal's type explicitly using cast syntax.  */\n     }\n \n-  RETURN_IF_ERROR (result_append_char (dm, '('));\n+  RETURN_IF_ERROR (result_add_char (dm, '('));\n   RETURN_IF_ERROR (demangle_type (dm));\n-  RETURN_IF_ERROR (result_append_char (dm, ')'));\n+  RETURN_IF_ERROR (result_add_char (dm, ')'));\n \n   value_string = dyn_string_new (0);\n   if (value_string == NULL)\n     return STATUS_ALLOCATION_FAILED;\n \n   status = demangle_number_literally (dm, value_string, 10, 1);\n   if (STATUS_NO_ERROR (status))\n-    status = result_append_string (dm, value_string);\n+    status = result_add_string (dm, value_string);\n   dyn_string_delete (value_string);\n   RETURN_IF_ERROR (status);\n \n@@ -2967,30 +3067,30 @@ demangle_expression (dm)\n       /* If it's binary, do an operand first.  */\n       if (num_args > 1)\n \t{\n-\t  status = result_append_char (dm, '(');\n+\t  status = result_add_char (dm, '(');\n \t  if (STATUS_NO_ERROR (status))\n \t    status = demangle_expression (dm);\n \t  if (STATUS_NO_ERROR (status))\n-\t    status = result_append_char (dm, ')');\n+\t    status = result_add_char (dm, ')');\n \t}\n \n       /* Emit the operator.  */  \n       if (STATUS_NO_ERROR (status))\n-\tstatus = result_append_string (dm, operator_name);\n+\tstatus = result_add_string (dm, operator_name);\n       dyn_string_delete (operator_name);\n       RETURN_IF_ERROR (status);\n       \n       /* Emit its second (if binary) or only (if unary) operand.  */\n-      RETURN_IF_ERROR (result_append_char (dm, '('));\n+      RETURN_IF_ERROR (result_add_char (dm, '('));\n       RETURN_IF_ERROR (demangle_expression (dm));\n-      RETURN_IF_ERROR (result_append_char (dm, ')'));\n+      RETURN_IF_ERROR (result_add_char (dm, ')'));\n \n       /* The ternary operator takes a third operand.  */\n       if (num_args == 3)\n \t{\n-\t  RETURN_IF_ERROR (result_append (dm, \":(\"));\n+\t  RETURN_IF_ERROR (result_add (dm, \":(\"));\n \t  RETURN_IF_ERROR (demangle_expression (dm));\n-\t  RETURN_IF_ERROR (result_append_char (dm, ')'));\n+\t  RETURN_IF_ERROR (result_add_char (dm, ')'));\n \t}\n     }\n \n@@ -3009,7 +3109,7 @@ demangle_scope_expression (dm)\n   RETURN_IF_ERROR (demangle_char (dm, 's'));\n   RETURN_IF_ERROR (demangle_char (dm, 'r'));\n   RETURN_IF_ERROR (demangle_type (dm));\n-  RETURN_IF_ERROR (result_append (dm, \"::\"));\n+  RETURN_IF_ERROR (result_add (dm, \"::\"));\n   RETURN_IF_ERROR (demangle_encoding (dm));\n   return STATUS_OK;\n }\n@@ -3100,30 +3200,30 @@ demangle_substitution (dm, template_p)\n       switch (peek)\n \t{\n \tcase 't':\n-\t  RETURN_IF_ERROR (result_append (dm, \"std\"));\n+\t  RETURN_IF_ERROR (result_add (dm, \"std\"));\n \t  break;\n \n \tcase 'a':\n-\t  RETURN_IF_ERROR (result_append (dm, \"std::allocator\"));\n+\t  RETURN_IF_ERROR (result_add (dm, \"std::allocator\"));\n \t  new_last_source_name = \"allocator\";\n \t  *template_p = 1;\n \t  break;\n \n \tcase 'b':\n-\t  RETURN_IF_ERROR (result_append (dm, \"std::basic_string\"));\n+\t  RETURN_IF_ERROR (result_add (dm, \"std::basic_string\"));\n \t  new_last_source_name = \"basic_string\";\n \t  *template_p = 1;\n \t  break;\n \t  \n \tcase 's':\n \t  if (!flag_verbose)\n \t    {\n-\t      RETURN_IF_ERROR (result_append (dm, \"std::string\"));\n+\t      RETURN_IF_ERROR (result_add (dm, \"std::string\"));\n \t      new_last_source_name = \"string\";\n \t    }\n \t  else\n \t    {\n-\t      RETURN_IF_ERROR (result_append (dm, \"std::basic_string<char, std::char_traits<char>, std::allocator<char> >\"));\n+\t      RETURN_IF_ERROR (result_add (dm, \"std::basic_string<char, std::char_traits<char>, std::allocator<char> >\"));\n \t      new_last_source_name = \"basic_string\";\n \t    }\n \t  *template_p = 0;\n@@ -3132,12 +3232,12 @@ demangle_substitution (dm, template_p)\n \tcase 'i':\n \t  if (!flag_verbose)\n \t    {\n-\t      RETURN_IF_ERROR (result_append (dm, \"std::istream\"));\n+\t      RETURN_IF_ERROR (result_add (dm, \"std::istream\"));\n \t      new_last_source_name = \"istream\";\n \t    }\n \t  else\n \t    {\n-\t      RETURN_IF_ERROR (result_append (dm, \"std::basic_istream<char, std::char_traints<char> >\"));\n+\t      RETURN_IF_ERROR (result_add (dm, \"std::basic_istream<char, std::char_traints<char> >\"));\n \t      new_last_source_name = \"basic_istream\";\n \t    }\n \t  *template_p = 0;\n@@ -3146,12 +3246,12 @@ demangle_substitution (dm, template_p)\n \tcase 'o':\n \t  if (!flag_verbose)\n \t    {\n-\t      RETURN_IF_ERROR (result_append (dm, \"std::ostream\"));\n+\t      RETURN_IF_ERROR (result_add (dm, \"std::ostream\"));\n \t      new_last_source_name = \"ostream\";\n \t    }\n \t  else\n \t    {\n-\t      RETURN_IF_ERROR (result_append (dm, \"std::basic_ostream<char, std::char_traits<char> >\"));\n+\t      RETURN_IF_ERROR (result_add (dm, \"std::basic_ostream<char, std::char_traits<char> >\"));\n \t      new_last_source_name = \"basic_ostream\";\n \t    }\n \t  *template_p = 0;\n@@ -3160,12 +3260,12 @@ demangle_substitution (dm, template_p)\n \tcase 'd':\n \t  if (!flag_verbose) \n \t    {\n-\t      RETURN_IF_ERROR (result_append (dm, \"std::iostream\"));\n+\t      RETURN_IF_ERROR (result_add (dm, \"std::iostream\"));\n \t      new_last_source_name = \"iostream\";\n \t    }\n \t  else\n \t    {\n-\t      RETURN_IF_ERROR (result_append (dm, \"std::basic_iostream<char, std::char_traits<char> >\"));\n+\t      RETURN_IF_ERROR (result_add (dm, \"std::basic_iostream<char, std::char_traits<char> >\"));\n \t      new_last_source_name = \"basic_iostream\";\n \t    }\n \t  *template_p = 0;\n@@ -3196,7 +3296,7 @@ demangle_substitution (dm, template_p)\n     return \"Substitution number out of range.\";\n \n   /* Emit the substitution text.  */\n-  RETURN_IF_ERROR (result_append_string (dm, text));\n+  RETURN_IF_ERROR (result_add_string (dm, text));\n \n   RETURN_IF_ERROR (demangle_char (dm, '_'));\n   return STATUS_OK;\n@@ -3216,12 +3316,12 @@ demangle_local_name (dm)\n   RETURN_IF_ERROR (demangle_char (dm, 'Z'));\n   RETURN_IF_ERROR (demangle_encoding (dm));\n   RETURN_IF_ERROR (demangle_char (dm, 'E'));\n-  RETURN_IF_ERROR (result_append (dm, \"::\"));\n+  RETURN_IF_ERROR (result_add (dm, \"::\"));\n \n   if (peek_char (dm) == 's')\n     {\n       /* Local character string literal.  */\n-      RETURN_IF_ERROR (result_append (dm, \"string literal\"));\n+      RETURN_IF_ERROR (result_add (dm, \"string literal\"));\n       /* Consume the s.  */\n       advance_char (dm);\n       RETURN_IF_ERROR (demangle_discriminator (dm, 0));\n@@ -3258,7 +3358,7 @@ demangle_discriminator (dm, suppress_first)\n       /* Consume the underscore.  */\n       advance_char (dm);\n       if (flag_verbose)\n-\tRETURN_IF_ERROR (result_append (dm, \" [#\"));\n+\tRETURN_IF_ERROR (result_add (dm, \" [#\"));\n       /* Check if there's a number following the underscore.  */\n       if (IS_DIGIT ((unsigned char) peek_char (dm)))\n \t{\n@@ -3276,15 +3376,15 @@ demangle_discriminator (dm, suppress_first)\n \t{\n \t  if (flag_verbose)\n \t    /* A missing digit correspond to one.  */\n-\t    RETURN_IF_ERROR (result_append_char (dm, '1'));\n+\t    RETURN_IF_ERROR (result_add_char (dm, '1'));\n \t}\n       if (flag_verbose)\n-\tRETURN_IF_ERROR (result_append_char (dm, ']'));\n+\tRETURN_IF_ERROR (result_add_char (dm, ']'));\n     }\n   else if (!suppress_first)\n     {\n       if (flag_verbose)\n-\tRETURN_IF_ERROR (result_append (dm, \" [#0]\"));\n+\tRETURN_IF_ERROR (result_add (dm, \" [#0]\"));\n     }\n \n   return STATUS_OK;"}]}