{"sha": "8bfd0a46ea397185b00fe00bb40ae03c18838398", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGJmZDBhNDZlYTM5NzE4NWIwMGZlMDBiYjQwYWUwM2MxODgzODM5OA==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2004-09-01T22:17:00Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2004-09-01T22:17:00Z"}, "message": "re PR libstdc++/16614 (Excessive resource usage in __mt_alloc)\n\n\n2004-09-01  Benjamin Kosnik  <bkoz@redhat.com>\n\n\tPR libstdc++/16614\n\t* include/ext/mt_allocator.h (__mt_base): Not type dependent,\n\tsplit into..\n\t(__pool): New, specialize.\n\t(__common_pool): New, static bits here.\n\t(__per_type_pool): New, and here.\n\t(__mt_alloc_base): New.\n\t(__mt_alloc): Add template parameter, inherit from it.\n\t* src/allocator.cc: Split this...\n\t* src/allocator-inst.cc: And this...\n\t* src/pool_allocator.cc: ...into this.\n\t* src/mt_allocator.cc: ... and this. Add definitions for\n\t__mt_base.\n\t* src/Makefile.am (sources): Split allocator.cc to\n\tpool_allocator.cc and mt_allocator.cc.\n\t* src/Makefile.in: Regenerate.\n\t* config/linker-map.gnu: Add symbols.\n\t* docs/html/ext/mt_allocator.html: Document new design.\n\t* testsuite/ext/mt_allocator/tune-1.cc: New.\n\t* testsuite/ext/mt_allocator/tune-2.cc: New.\n\t* testsuite/ext/mt_allocator/tune-3.cc: New.\n\t* testsuite/ext/mt_allocator/tune-4.cc: New.\n\n\t* testsuite/testsuite_allocator.h (__gnu_test::check_new): New.\n\t* testsuite/ext/allocators.cc: Use check_new, split into...\n\t* testsuite/ext/mt_allocator/check_new.cc: this.\n\t* testsuite/ext/pool_allocator/check_new.cc: this.\n\t* testsuite/ext/malloc_allocator/check_new.cc: this.\n\t* testsuite/ext/debug_allocator/check_new.cc: this.\n\t* testsuite/ext/mt_allocator/instantiate.cc: this.\n\t* testsuite/ext/pool_allocator/instantiate.cc: this.\n\t* testsuite/ext/malloc_allocator/instantiate.cc: this.\n\t* testsuite/ext/debug_allocator/instantiate.cc: this.\n\nFrom-SVN: r86936", "tree": {"sha": "011bcfe52cc2afab1d0b8cb19946c66ceddd599d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/011bcfe52cc2afab1d0b8cb19946c66ceddd599d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8bfd0a46ea397185b00fe00bb40ae03c18838398", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bfd0a46ea397185b00fe00bb40ae03c18838398", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8bfd0a46ea397185b00fe00bb40ae03c18838398", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bfd0a46ea397185b00fe00bb40ae03c18838398/comments", "author": null, "committer": null, "parents": [{"sha": "0705d60230a25db8478d23bbd037351bf78309dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0705d60230a25db8478d23bbd037351bf78309dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0705d60230a25db8478d23bbd037351bf78309dc"}], "stats": {"total": 2624, "additions": 1901, "deletions": 723}, "files": [{"sha": "a230dc9c3c4ac79f4124c663b2dc3517fd198238", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=8bfd0a46ea397185b00fe00bb40ae03c18838398", "patch": "@@ -1,3 +1,39 @@\n+2004-09-01  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\tPR libstdc++/16614\n+\t* include/ext/mt_allocator.h (__mt_base): Not type dependent,\n+\tsplit into..\n+\t(__pool): New, specialize.\n+\t(__common_pool): New, static bits here.\n+\t(__per_type_pool): New, and here.\n+\t(__mt_alloc_base): New.\n+\t(__mt_alloc): Add template parameter, inherit from it.\n+\t* src/allocator.cc: Split this...\n+\t* src/allocator-inst.cc: And this...\n+\t* src/pool_allocator.cc: ...into this.\n+\t* src/mt_allocator.cc: ... and this. Add definitions for\n+\t__mt_base.\n+\t* src/Makefile.am (sources): Split allocator.cc to\n+\tpool_allocator.cc and mt_allocator.cc.\n+\t* src/Makefile.in: Regenerate.\n+\t* config/linker-map.gnu: Add symbols.\n+\t* docs/html/ext/mt_allocator.html: Document new design.\n+\t* testsuite/ext/mt_allocator/tune-1.cc: New.\n+\t* testsuite/ext/mt_allocator/tune-2.cc: New.\n+\t* testsuite/ext/mt_allocator/tune-3.cc: New.\n+\t* testsuite/ext/mt_allocator/tune-4.cc: New.\t\n+\n+\t* testsuite/testsuite_allocator.h (__gnu_test::check_new): New.\n+\t* testsuite/ext/allocators.cc: Use check_new, split into...\n+\t* testsuite/ext/mt_allocator/check_new.cc: this.\n+\t* testsuite/ext/pool_allocator/check_new.cc: this.\n+\t* testsuite/ext/malloc_allocator/check_new.cc: this.\t\n+\t* testsuite/ext/debug_allocator/check_new.cc: this.\t\n+\t* testsuite/ext/mt_allocator/instantiate.cc: this.\n+\t* testsuite/ext/pool_allocator/instantiate.cc: this.\n+\t* testsuite/ext/malloc_allocator/instantiate.cc: this.\t\n+\t* testsuite/ext/debug_allocator/instantiate.cc: this.\n+\t\n 2004-08-30  Phil Edwards  <phil@codesourcery.com>\n \n \t* docs/html/install.html:  Update locales list (from Paolo)."}, {"sha": "efb1afb7ba049278c811a9c21a4690fe4ce3e280", "filename": "libstdc++-v3/config/linker-map.gnu", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu?ref=8bfd0a46ea397185b00fe00bb40ae03c18838398", "patch": "@@ -255,10 +255,20 @@ GLIBCXX_3.4.2 {\n \n     _ZN9__gnu_cxx18stdio_sync_filebufI[cw]St11char_traitsI[cw]EE4fileEv;\n \n+    # pool_alloc\n     _ZN9__gnu_cxx17__pool_alloc_base9_M_refillE[jm];\n     _ZN9__gnu_cxx17__pool_alloc_base16_M_get_free_listE[jm];\n     _ZN9__gnu_cxx17__pool_alloc_base12_M_get_mutexEv;\n \n+    # mt_alloc\n+    _ZN9__gnu_cxx6__poolILb0EE13_M_initializeEv;\n+    _ZN9__gnu_cxx6__poolILb1EE13_M_initializeEPFvPvE;\n+    _ZN9__gnu_cxx6__poolILb1EE21_M_destroy_thread_keyEPv;\n+    _ZN9__gnu_cxx6__poolILb1EE16_M_get_thread_idEv;\n+    _ZN9__gnu_cxx6__poolILb[01]EE17_M_reserve_memoryE[jm][jm];\n+    _ZN9__gnu_cxx6__poolILb[01]EE17_M_reclaim_memoryEPc[jm];\n+    _ZN9__gnu_cxx20__common_pool_policyILb[01]EE11_S_get_poolEv;\n+\n } GLIBCXX_3.4.1;\n \n # Symbols in the support library (libsupc++) have their own tag."}, {"sha": "9ddd5a052de9dbc3bc9af7565a2b5988b5f45838", "filename": "libstdc++-v3/docs/html/ext/mt_allocator.html", "status": "modified", "additions": 71, "deletions": 13, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Fmt_allocator.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Fmt_allocator.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Fmt_allocator.html?ref=8bfd0a46ea397185b00fe00bb40ae03c18838398", "patch": "@@ -42,23 +42,80 @@ <h3 class=\"left\">\n applications [hereinafter referred to as an MT application]. Over time\n the allocator has evolved and been improved in many ways, one of the\n being that it now also does a good job in single threaded applications\n-[hereinafter referred to as a ST application].  (Note: In this\n+[hereinafter referred to as a ST application]. (Note: In this\n document, when referring to single threaded applications this also\n includes applications that are compiled with gcc without thread\n-support enabled. This is accomplished using ifdef's on __GTHREADS)\n+support enabled. This is accomplished using ifdef's on\n+__GTHREADS). This allocator is tunable, very flexible, and capable of\n+high-performance.\n </p>\n \n <p>\n The aim of this document is to describe - from a application point of\n view - the \"inner workings\" of the allocator.\n </p>\n \n+<h3 class=\"left\">\n+  <a name=\"design\">Design Overview</a>\n+</h3>\n+\n+<p> There are three general components to the allocator: a datum\n+describing the characteristics of the memory pool, a policy class\n+containing this pool that links instantiation types to common or\n+individual pools, and a class inheriting from the policy class that is\n+the actual allocator.\n+</p>\n+\n+<p>The datum describing pools characteristics is \n+<pre>\n+  template&lt;bool _Thread&gt;\n+    class __pool\n+</pre>\n+This class is parametrized on thread support, and is explicitly\n+specialized for both multiple threads (with <code>bool==true</code>)\n+and single threads (via <code>bool==false</code>.)\n+</p>\n+\n+<p> There are two distinct policy classes, each of which can be used\n+with either type of underlying pool datum.\n+</p>\n+\n+<pre>\n+  template&lt;bool _Thread&gt;\n+    struct __common_pool_policy\n+\n+  template&lt;typename _Tp, bool _Thread&gt;\n+    struct __per_type_pool_policy\n+</pre>\n+\n+<p> The first policy, <code>__common_pool_policy</code>, implements a\n+common pool. This means that allocators that are instantiated with\n+different types, say <code>char</code> and <code>long</code> will both\n+use the same pool. This is the default policy.\n+</p>\n+\n+<p> The second policy, <code>__per_type_pool_policy</code>, implements\n+a separate pool for each instantiating type. Thus, <code>char</code>\n+and <code>long</code> will use separate pools. This allows per-type\n+tuning, for instance.\n+</p>\n+\n+<p> Putting this all together, the actual allocator class is\n+<pre>\n+  template&lt;typename _Tp, typename _Poolp = __default_policy&gt;\n+    class __mt_alloc : public __mt_alloc_base&lt;_Tp&gt;,  _Poolp\n+</pre>\n+This class has the interface required for standard library allocator\n+classes, namely member functions <code>allocate</code> and\n+<code>deallocate</code>, plus others.\n+</p>\n+\n <h3 class=\"left\">\n   <a name=\"init\">Tunable parameters</a>\n </h3>\n \n-<p>Certain allocation parameters can be modified on a per-type\n-basis. There exists a nested <pre>struct _Tune</pre> that contains all\n+<p>Certain allocation parameters can be modified, or tuned. There\n+exists a nested <pre>struct __pool_base::_Tune</pre> that contains all\n these parameters, which include settings for\n </p>\n    <ul>\n@@ -87,16 +144,16 @@ <h3 class=\"left\">\n {\n   typedef pod value_type;\n   typedef __gnu_cxx::__mt_alloc&lt;value_type&gt; allocator_type;\n-  typedef allocator_type::_Tune tune_type;\n+  typedef __gnu_cxx::__pool_base::_Tune tune_type;\n \n   tune_type t_default;\n   tune_type t_opt(16, 5120, 32, 5120, 20, 10, false);\n   tune_type t_single(16, 5120, 32, 5120, 1, 10, false);\n \n   tune_type t;\n-  t = allocator_type::_S_get_options();  \n-  allocator_type::_S_set_options(t_opt);\n-  t = allocator_type::_S_get_options();  \n+  t = allocator_type::_M_get_options();  \n+  allocator_type::_M_set_options(t_opt);\n+  t = allocator_type::_M_get_options();  \n \n   allocator_type a;\n   allocator_type::pointer p1 = a.allocate(128);\n@@ -119,14 +176,15 @@ <h3 class=\"left\">\n </p>\n \n <p>\n-The very first allocate() call will always call the _S_init() function. \n-In order to make sure that this function is called exactly once we make use\n-of a __gthread_once (with _S_once_mt and _S_init as arguments) call in MT \n-applications and check a static bool (_S_initialized) in ST applications.\n+The very first allocate() call will always call the\n+_S_initialize_once() function.  In order to make sure that this\n+function is called exactly once we make use of a __gthread_once call\n+in MT applications and check a static bool (_S_init) in ST\n+applications.\n </p>\n \n <p>\n-The _S_init() function:\n+The _S_initialize() function:\n - If the GLIBCXX_FORCE_NEW environment variable is set, it sets the bool\n   _S_force_new to true and then returns. This will cause subsequent calls to\n   allocate() to return memory directly from a new() call, and deallocate will"}, {"sha": "58ac9e014db189056d39e2eab0045b98185adadc", "filename": "libstdc++-v3/include/ext/mt_allocator.h", "status": "modified", "additions": 543, "deletions": 580, "changes": 1123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h?ref=8bfd0a46ea397185b00fe00bb40ae03c18838398", "patch": "@@ -53,159 +53,127 @@ namespace __gnu_cxx\n    *  Further details:\n    *  http://gcc.gnu.org/onlinedocs/libstdc++/ext/mt_allocator.html\n    */\n-  template<typename _Tp>\n-    class __mt_alloc\n+  typedef void (*__destroy_handler)(void*);\n+  typedef void (*__create_handler)(void);\n+\n+  class __pool_base\n+  {\n+  public:\n+    // Variables used to configure the behavior of the allocator,\n+    // assigned and explained in detail below.\n+    struct _Tune\n     {\n-    public:\n-      typedef size_t                    size_type;\n-      typedef ptrdiff_t                 difference_type;\n-      typedef _Tp*                      pointer;\n-      typedef const _Tp*                const_pointer;\n-      typedef _Tp&                      reference;\n-      typedef const _Tp&                const_reference;\n-      typedef _Tp                       value_type;\n-\n-      template<typename _Tp1>\n-        struct rebind\n-        { typedef __mt_alloc<_Tp1> other; };\n-\n-      __mt_alloc() throw() \n-      {\n-\t// XXX\n-      }\n-\n-      __mt_alloc(const __mt_alloc&) throw() \n-      {\n-\t// XXX\n-      }\n-\n-      template<typename _Tp1>\n-        __mt_alloc(const __mt_alloc<_Tp1>& obj) throw()  \n-        {\n-\t  // XXX\n-\t}\n-\n-      ~__mt_alloc() throw() { }\n-\n-      pointer\n-      address(reference __x) const\n-      { return &__x; }\n-\n-      const_pointer\n-      address(const_reference __x) const\n-      { return &__x; }\n-\n-      size_type\n-      max_size() const throw() \n-      { return size_t(-1) / sizeof(_Tp); }\n-\n-      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-      // 402. wrong new expression in [some_] allocator::construct\n-      void \n-      construct(pointer __p, const _Tp& __val) \n-      { ::new(__p) _Tp(__val); }\n-\n-      void \n-      destroy(pointer __p) { __p->~_Tp(); }\n-\n-      pointer\n-      allocate(size_type __n, const void* = 0);\n+      // Alignment needed.\n+      // NB: In any case must be >= sizeof(_Block_record), that\n+      // is 4 on 32 bit machines and 8 on 64 bit machines.\n+      size_t  _M_align;\n+      \n+      // Allocation requests (after round-up to power of 2) below\n+      // this value will be handled by the allocator. A raw new/\n+      // call will be used for requests larger than this value.\n+      size_t\t_M_max_bytes; \n+      \n+      // Size in bytes of the smallest bin.\n+      // NB: Must be a power of 2 and >= _M_align.\n+      size_t  _M_min_bin;\n+      \n+      // In order to avoid fragmenting and minimize the number of\n+      // new() calls we always request new memory using this\n+      // value. Based on previous discussions on the libstdc++\n+      // mailing list we have choosen the value below.\n+      // See http://gcc.gnu.org/ml/libstdc++/2001-07/msg00077.html\n+      size_t \t_M_chunk_size;\n+      \n+      // The maximum number of supported threads. For\n+      // single-threaded operation, use one. Maximum values will\n+      // vary depending on details of the underlying system. (For\n+      // instance, Linux 2.4.18 reports 4070 in\n+      // /proc/sys/kernel/threads-max, while Linux 2.6.6 reports\n+      // 65534)\n+      size_t \t_M_max_threads;\n+      \n+      // Each time a deallocation occurs in a threaded application\n+      // we make sure that there are no more than\n+      // _M_freelist_headroom % of used memory on the freelist. If\n+      // the number of additional records is more than\n+      // _M_freelist_headroom % of the freelist, we move these\n+      // records back to the global pool.\n+      size_t \t_M_freelist_headroom;\n+      \n+      // Set to true forces all allocations to use new().\n+      bool \t_M_force_new; \n+      \n+      explicit\n+      _Tune()\n+      : _M_align(8), _M_max_bytes(128), _M_min_bin(8),\n+      _M_chunk_size(4096 - 4 * sizeof(void*)), \n+      _M_max_threads(4096), _M_freelist_headroom(10), \n+      _M_force_new(getenv(\"GLIBCXX_FORCE_NEW\") ? true : false)\n+      { }\n+\n+      explicit\n+      _Tune(size_t __align, size_t __maxb, size_t __minbin, size_t __chunk, \n+\t    size_t __maxthreads, size_t __headroom, bool __force) \n+      : _M_align(__align), _M_max_bytes(__maxb), _M_min_bin(__minbin),\n+      _M_chunk_size(__chunk), _M_max_threads(__maxthreads),\n+      _M_freelist_headroom(__headroom), _M_force_new(__force)\n+      { }\n+    };\n+    \n+    const _Tune&\n+    _M_get_options() const\n+    { return _M_options; }\n \n-      void\n-      deallocate(pointer __p, size_type __n);\n+    void\n+    _M_set_options(_Tune __t)\n+    { \n+      if (!_M_init)\n+\t_M_options = __t;\n+    }\n \n-      // Variables used to configure the behavior of the allocator,\n-      // assigned and explained in detail below.\n-      struct _Tune\n-      {\n-\t// Alignment needed.\n-\t// NB: In any case must be >= sizeof(_Block_record), that\n-\t// is 4 on 32 bit machines and 8 on 64 bit machines.\n-\tsize_t  _M_align;\n-\n-\t// Allocation requests (after round-up to power of 2) below\n-\t// this value will be handled by the allocator. A raw new/\n-\t// call will be used for requests larger than this value.\n-\tsize_t\t_M_max_bytes; \n-\n-\t// Size in bytes of the smallest bin.\n-\t// NB: Must be a power of 2 and >= _M_align.\n-\tsize_t  _M_min_bin;\n-\n-\t// In order to avoid fragmenting and minimize the number of\n-\t// new() calls we always request new memory using this\n-\t// value. Based on previous discussions on the libstdc++\n-\t// mailing list we have choosen the value below.\n-\t// See http://gcc.gnu.org/ml/libstdc++/2001-07/msg00077.html\n-\tsize_t \t_M_chunk_size;\n-\n-\t// The maximum number of supported threads. For\n-\t// single-threaded operation, use one. Maximum values will\n-\t// vary depending on details of the underlying system. (For\n-\t// instance, Linux 2.4.18 reports 4070 in\n-\t// /proc/sys/kernel/threads-max, while Linux 2.6.6 reports\n-\t// 65534)\n-\tsize_t \t_M_max_threads;\n-\n-\t// Each time a deallocation occurs in a threaded application\n-\t// we make sure that there are no more than\n-\t// _M_freelist_headroom % of used memory on the freelist. If\n-\t// the number of additional records is more than\n-\t// _M_freelist_headroom % of the freelist, we move these\n-\t// records back to the global pool.\n-\tsize_t \t_M_freelist_headroom;\n-\n-\t// Set to true forces all allocations to use new().\n-\tbool \t_M_force_new; \n-     \n-\texplicit\n-\t_Tune()\n-\t: _M_align(8), _M_max_bytes(128), _M_min_bin(8),\n-\t  _M_chunk_size(4096 - 4 * sizeof(void*)), \n-\t  _M_max_threads(4096), _M_freelist_headroom(10), \n-\t  _M_force_new(getenv(\"GLIBCXX_FORCE_NEW\") ? true : false)\n-\t{ }\n-\n-\texplicit\n-\t_Tune(size_t __align, size_t __maxb, size_t __minbin,\n-\t      size_t __chunk, size_t __maxthreads, size_t __headroom,\n-\t      bool __force) \n-\t: _M_align(__align), _M_max_bytes(__maxb), _M_min_bin(__minbin),\n-\t  _M_chunk_size(__chunk), _M_max_threads(__maxthreads),\n-\t  _M_freelist_headroom(__headroom), _M_force_new(__force)\n-\t{ }\n-      };\n+    bool\n+    _M_check_threshold(size_t __bytes)\n+    { return __bytes > _M_options._M_max_bytes || _M_options._M_force_new; }\n \n-      static const _Tune\n-      _S_get_options()\n-      { return _S_options; }\n+    size_t\n+    _M_get_binmap(size_t __bytes)\n+    { return _M_binmap[__bytes]; }\n+\n+    explicit __pool_base() \n+    : _M_init(false), _M_options(_Tune()), _M_binmap(NULL) { }\n+\n+  protected:\n+    // We need to create the initial lists and set up some variables\n+    // before we can answer to the first request for memory.\n+    bool \t\t\t_M_init;\n+    \n+    // Configuration options.\n+    _Tune \t       \t\t_M_options;\n+    \n+    // Using short int as type for the binmap implies we are never\n+    // caching blocks larger than 65535 with this allocator.\n+    typedef unsigned short int  _Binmap_type;\n+    _Binmap_type* \t\t_M_binmap;\n+  };\n+\n+  // Data describing the underlying memory pool, parameterized on\n+  // threading support.\n+  template<bool _Thread>\n+    class __pool;\n+\n+  template<>\n+    class __pool<true>;\n+\n+  template<>\n+    class __pool<false>;\n \n-      static void\n-      _S_set_options(_Tune __t)\n-      { \n-\tif (!_S_init)\n-\t  _S_options = __t;\n-      }\n \n-    private:\n-      // We need to create the initial lists and set up some variables\n-      // before we can answer to the first request for memory.\n #ifdef __GTHREADS\n-      static __gthread_once_t \t\t_S_once;\n-#endif\n-      static bool \t\t\t_S_init;\n-\n-      static void\n-      _S_initialize();\n-\n-      // Configuration options.\n-      static _Tune \t       \t\t_S_options;\n-\n-      // Using short int as type for the binmap implies we are never\n-      // caching blocks larger than 65535 with this allocator\n-      typedef unsigned short int        _Binmap_type;\n-      static _Binmap_type* \t\t_S_binmap;\n-\n+  // Specialization for thread enabled, via gthreads.h.\n+  template<>\n+    class __pool<true> : public __pool_base\n+    {\n+    public:\n       // Each requesting thread is assigned an id ranging from 1 to\n       // _S_max_threads. Thread id 0 is used as a global memory pool.\n       // In order to get constant performance on the thread assignment\n@@ -215,508 +183,503 @@ namespace __gnu_cxx\n       // __gthread_key we specify a destructor. When this destructor\n       // (i.e. the thread dies) is called, we return the thread id to\n       // the front of this list.\n-#ifdef __GTHREADS\n       struct _Thread_record\n       {\n-        // Points to next free thread id record. NULL if last record in list.\n-        _Thread_record* volatile        _M_next;\n-\n+\t// Points to next free thread id record. NULL if last record in list.\n+\t_Thread_record* volatile        _M_next;\n+\t\n \t// Thread id ranging from 1 to _S_max_threads.\n-        size_t                          _M_id;\n+\tsize_t                          _M_id;\n       };\n-\n-      static _Thread_record* volatile \t_S_thread_freelist_first;\n-      static __gthread_mutex_t \t\t_S_thread_freelist_mutex;\n-      static __gthread_key_t \t\t_S_thread_key;\n-\n-      static void \n-      _S_destroy_thread_key(void* __freelist_pos);\n-#endif\n-\n-      static size_t \n-      _S_get_thread_id();\n-\n+      \n       union _Block_record\n       {\n \t// Points to the block_record of the next free block.\n-        _Block_record* volatile         _M_next;\n-\n-#ifdef __GTHREADS\n+\t_Block_record* volatile         _M_next;\n+\t\n \t// The thread id of the thread which has requested this block.\n-        size_t                          _M_thread_id;\n-#endif\n+\tsize_t                          _M_thread_id;\n       };\n-\n+      \n       struct _Bin_record\n       {\n \t// An \"array\" of pointers to the first free block for each\n \t// thread id. Memory to this \"array\" is allocated in _S_initialize()\n \t// for _S_max_threads + global pool 0.\n-        _Block_record** volatile        _M_first;\n-\n-#ifdef __GTHREADS\n+\t_Block_record** volatile        _M_first;\n+\t\n \t// An \"array\" of counters used to keep track of the amount of\n \t// blocks that are on the freelist/used for each thread id.\n \t// Memory to these \"arrays\" is allocated in _S_initialize() for\n \t// _S_max_threads + global pool 0.\n-        size_t* volatile                _M_free;\n-        size_t* volatile                _M_used;\n-\n+\tsize_t* volatile                _M_free;\n+\tsize_t* volatile                _M_used;\n+\t\n \t// Each bin has its own mutex which is used to ensure data\n \t// integrity while changing \"ownership\" on a block.  The mutex\n \t// is initialized in _S_initialize().\n-        __gthread_mutex_t*              _M_mutex;\n+\t__gthread_mutex_t*              _M_mutex;\n+      };\n+      \n+      void\n+      _M_initialize(__destroy_handler __d);\n+\n+      void\n+      _M_initialize_once(__create_handler __c)\n+      {\n+\t// Although the test in __gthread_once() would suffice, we\n+\t// wrap test of the once condition in our own unlocked\n+\t// check. This saves one function call to pthread_once()\n+\t// (which itself only tests for the once value unlocked anyway\n+\t// and immediately returns if set)\n+\tif (__builtin_expect(_M_init == false, false))\n+\t  {\n+\t    if (__gthread_active_p())\n+\t      __gthread_once(&_M_once, __c);\n+\t    if (!_M_init)\n+\t      __c();\n+\t  }\n+      }\n+\n+      char* \n+      _M_reserve_memory(size_t __bytes, const size_t __thread_id);\n+    \n+      void\n+      _M_reclaim_memory(char* __p, size_t __bytes);\n+    \n+      const _Bin_record&\n+      _M_get_bin(size_t __which)\n+      { return _M_bin[__which]; }\n+      \n+      void\n+      _M_adjust_freelist(const _Bin_record& __bin, _Block_record* __block, \n+\t\t\t size_t __thread_id)\n+      {\n+\tif (__gthread_active_p())\n+\t  {\n+\t    __block->_M_thread_id = __thread_id;\n+\t    --__bin._M_free[__thread_id];\n+\t    ++__bin._M_used[__thread_id];\n+\t  }\n+      }\n+\n+      void \n+      _M_destroy_thread_key(void* __freelist_pos);\n+\n+      size_t \n+      _M_get_thread_id();\n+\n+      explicit __pool() \n+      : _M_bin(NULL), _M_bin_size(1), _M_thread_freelist(NULL) \n+      {\n+\t// On some platforms, __gthread_once_t is an aggregate.\n+\t__gthread_once_t __tmp = __GTHREAD_ONCE_INIT;\n+\t_M_once = __tmp;\n+      }\n+\n+    private:\n+      // An \"array\" of bin_records each of which represents a specific\n+      // power of 2 size. Memory to this \"array\" is allocated in\n+      // _M_initialize().\n+      _Bin_record* volatile\t_M_bin;\n+\n+      // Actual value calculated in _M_initialize().\n+      size_t \t       \t     \t_M_bin_size;\n+\n+      __gthread_once_t \t\t_M_once;\n+      \n+      _Thread_record* \t\t_M_thread_freelist;\n+    };\n #endif\n+\n+  // Specialization for single thread.\n+  template<>\n+    class __pool<false> : public __pool_base\n+    {\n+    public:\n+      union _Block_record\n+      {\n+\t// Points to the block_record of the next free block.\n+\t_Block_record* volatile         _M_next;\n+      };\n+      \n+      struct _Bin_record\n+      {\n+\t// An \"array\" of pointers to the first free block for each\n+\t// thread id. Memory to this \"array\" is allocated in _S_initialize()\n+\t// for _S_max_threads + global pool 0.\n+\t_Block_record** volatile        _M_first;\n       };\n+      \n+      void\n+      _M_initialize_once()\n+      {\n+\tif (__builtin_expect(_M_init == false, false))\n+\t  _M_initialize();\n+      }\n \n+      char* \n+      _M_reserve_memory(size_t __bytes, const size_t __thread_id);\n+    \n+      void\n+      _M_reclaim_memory(char* __p, size_t __bytes);\n+    \n+      size_t \n+      _M_get_thread_id() { return 0; }\n+      \n+      const _Bin_record&\n+      _M_get_bin(size_t __which)\n+      { return _M_bin[__which]; }\n+      \n+      void\n+      _M_adjust_freelist(const _Bin_record&, _Block_record*, size_t)\n+      { }\n+\n+      explicit __pool() \n+      : _M_bin(NULL), _M_bin_size(1) { }\n+      \n+    private:\n       // An \"array\" of bin_records each of which represents a specific\n       // power of 2 size. Memory to this \"array\" is allocated in\n-      // _S_initialize().\n-      static _Bin_record* volatile     \t_S_bin;\n+      // _M_initialize().\n+      _Bin_record* volatile\t_M_bin;\n+      \n+      // Actual value calculated in _M_initialize().\n+      size_t \t       \t     \t_M_bin_size;     \n+\n+      void\n+      _M_initialize();\n+  };\n+\n+\n+  template<bool _Thread>\n+    struct __common_pool_policy \n+    {\n+      template<typename _Tp1, bool _Thread1 = _Thread>\n+        struct _M_rebind;\n+\n+      template<typename _Tp1>\n+        struct _M_rebind<_Tp1, true>\n+        { typedef __common_pool_policy<true> other; };\n+\n+      template<typename _Tp1>\n+        struct _M_rebind<_Tp1, false>\n+        { typedef __common_pool_policy<false> other; };\n \n-      // Actual value calculated in _S_initialize().\n-      static size_t \t       \t     \t_S_bin_size; \n+      typedef __pool<_Thread> __pool_type;\n+      static __pool_type\t_S_data;\n+\n+      static __pool_type&\n+      _S_get_pool();\n+\n+      static void\n+      _S_initialize_once() \n+      { \n+\tstatic bool __init;\n+\tif (__builtin_expect(__init == false, false))\n+\t  {\n+\t    _S_get_pool()._M_initialize_once(); \n+\t    __init = true;\n+\t  }\n+      }\n     };\n \n+  template<>\n+    struct __common_pool_policy<true>;\n+\n+#ifdef __GTHREADS\n+  template<>\n+    struct __common_pool_policy<true>\n+    {\n+      template<typename _Tp1, bool _Thread1 = true>\n+        struct _M_rebind;\n+\n+      template<typename _Tp1>\n+        struct _M_rebind<_Tp1, true>\n+        { typedef __common_pool_policy<true> other; };\n+\n+      template<typename _Tp1>\n+        struct _M_rebind<_Tp1, false>\n+        { typedef __common_pool_policy<false> other; };\n+\n+      typedef __pool<true> __pool_type;\n+      static __pool_type\t_S_data;\n+\n+      static __pool_type&\n+      _S_get_pool();\n+\n+      static void\n+      _S_destroy_thread_key(void* __freelist_pos)\n+      { _S_get_pool()._M_destroy_thread_key(__freelist_pos); }\n+      \n+      static void\n+      _S_initialize() \n+      { _S_get_pool()._M_initialize(_S_destroy_thread_key); }\n+\n+      static void\n+      _S_initialize_once() \n+      { \n+\tstatic bool __init;\n+\tif (__builtin_expect(__init == false, false))\n+\t  {\n+\t    _S_get_pool()._M_initialize_once(_S_initialize); \n+\t    __init = true;\n+\t  }\n+      }\n+   };\n+#endif\n+\n+  template<typename _Tp, bool _Thread>\n+    struct __per_type_pool_policy\n+    {\n+      template<typename _Tp1, bool _Thread1 = _Thread>\n+        struct _M_rebind;\n+\n+      template<typename _Tp1>\n+        struct _M_rebind<_Tp1, false>\n+        { typedef __per_type_pool_policy<_Tp1, false> other; };\n+\n+      template<typename _Tp1>\n+        struct _M_rebind<_Tp1, true>\n+        { typedef __per_type_pool_policy<_Tp1, true> other; };\n+\n+      typedef __pool<_Thread> __pool_type;\n+      static __pool_type\t_S_data;\n+\n+      static __pool_type&\n+      _S_get_pool( ) { return _S_data; }\n+\n+      static void\n+      _S_initialize_once() \n+      { \n+\tstatic bool __init;\n+\tif (__builtin_expect(__init == false, false))\n+\t  {\n+\t    _S_get_pool()._M_initialize_once(); \n+\t    __init = true;\n+\t  }\n+      }\n+    };\n+\n+  template<typename _Tp, bool _Thread>\n+    __pool<_Thread>\n+    __per_type_pool_policy<_Tp, _Thread>::_S_data;\n+\n   template<typename _Tp>\n-    typename __mt_alloc<_Tp>::pointer\n-    __mt_alloc<_Tp>::\n-    allocate(size_type __n, const void*)\n+    struct __per_type_pool_policy<_Tp, true>;\n+\n+#ifdef __GTHREADS\n+  template<typename _Tp>\n+    struct __per_type_pool_policy<_Tp, true>\n     {\n-      // Although the test in __gthread_once() would suffice, we wrap\n-      // test of the once condition in our own unlocked check. This\n-      // saves one function call to pthread_once() (which itself only\n-      // tests for the once value unlocked anyway and immediately\n-      // returns if set)\n-      if (!_S_init)\n-\t{\n+      template<typename _Tp1, bool _Thread1 = true>\n+        struct _M_rebind;\n+\n+      template<typename _Tp1>\n+        struct _M_rebind<_Tp1, false>\n+        { typedef __per_type_pool_policy<_Tp1, false> other; };\n+\n+      template<typename _Tp1>\n+        struct _M_rebind<_Tp1, true>\n+        { typedef __per_type_pool_policy<_Tp1, true> other; };\n+\n+      typedef __pool<true> __pool_type;\n+      static __pool_type\t_S_data;\n+\n+      static __pool_type&\n+      _S_get_pool( ) { return _S_data; }\n+\n+      static void\n+      _S_destroy_thread_key(void* __freelist_pos)\n+      { _S_get_pool()._M_destroy_thread_key(__freelist_pos); }\n+      \n+      static void\n+      _S_initialize() \n+      { _S_get_pool()._M_initialize(_S_destroy_thread_key); }\n+\n+      static void\n+      _S_initialize_once() \n+      { \n+\tstatic bool __init;\n+\tif (__builtin_expect(__init == false, false))\n+\t  {\n+\t    _S_get_pool()._M_initialize_once(_S_initialize); \n+\t    __init = true;\n+\t  }\n+      }\n+    };\n+\n+  template<typename _Tp>\n+    __pool<true>\n+    __per_type_pool_policy<_Tp, true>::_S_data;\n+#endif\n+\n #ifdef __GTHREADS\n-\t  if (__gthread_active_p())\n-\t    __gthread_once(&_S_once, _S_initialize);\n+  typedef __common_pool_policy<true> __default_policy;\n+#else\n+  typedef __common_pool_policy<false> __default_policy;\n #endif\n-\t  if (!_S_init)\n-\t    _S_initialize();\n+\n+  template<typename _Tp>\n+    class __mt_alloc_base \n+    {\n+    public:\n+      typedef size_t                    size_type;\n+      typedef ptrdiff_t                 difference_type;\n+      typedef _Tp*                      pointer;\n+      typedef const _Tp*                const_pointer;\n+      typedef _Tp&                      reference;\n+      typedef const _Tp&                const_reference;\n+      typedef _Tp                       value_type;\n+\n+      pointer\n+      address(reference __x) const\n+      { return &__x; }\n+\n+      const_pointer\n+      address(const_reference __x) const\n+      { return &__x; }\n+\n+      size_type\n+      max_size() const throw() \n+      { return size_t(-1) / sizeof(_Tp); }\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 402. wrong new expression in [some_] allocator::construct\n+      void \n+      construct(pointer __p, const _Tp& __val) \n+      { ::new(__p) _Tp(__val); }\n+\n+      void \n+      destroy(pointer __p) { __p->~_Tp(); }\n+    };\n+\n+  template<typename _Tp, typename _Poolp = __default_policy>\n+    class __mt_alloc : public __mt_alloc_base<_Tp>,  _Poolp\n+    {\n+    public:\n+      typedef size_t                    size_type;\n+      typedef ptrdiff_t                 difference_type;\n+      typedef _Tp*                      pointer;\n+      typedef const _Tp*                const_pointer;\n+      typedef _Tp&                      reference;\n+      typedef const _Tp&                const_reference;\n+      typedef _Tp                       value_type;\n+      typedef _Poolp                  \t__policy_type;\n+      typedef typename _Poolp::__pool_type       __pool_type;\n+\n+      template<typename _Tp1, typename _Poolp1 = _Poolp>\n+        struct rebind\n+        { \n+\t  typedef typename _Poolp1::template _M_rebind<_Tp1>::other pol_type;\n+\t  typedef __mt_alloc<_Tp1, pol_type> other;\n+\t};\n+\n+      __mt_alloc() throw() \n+      {\n+\t// XXX\n+      }\n+\n+      __mt_alloc(const __mt_alloc&) throw() \n+      {\n+\t// XXX\n+      }\n+\n+      template<typename _Tp1, typename _Poolp1>\n+        __mt_alloc(const __mt_alloc<_Tp1, _Poolp1>& obj) throw()  \n+        {\n+\t  // XXX\n \t}\n+\n+      ~__mt_alloc() throw() { }\n+\n+      pointer\n+      allocate(size_type __n, const void* = 0);\n+\n+      void\n+      deallocate(pointer __p, size_type __n);\n+\n+      const __pool_base::_Tune\n+      _M_get_options()\n+      { \n+\t// Return a copy, not a reference, for external consumption.\n+\treturn __pool_base::_Tune(this->_S_get_pool()._M_get_options()); \n+      }\n       \n+      void\n+      _M_set_options(__pool_base::_Tune __t)\n+      { this->_S_get_pool()._M_set_options(__t); }\n+    };\n+\n+  template<typename _Tp, typename _Poolp>\n+    typename __mt_alloc<_Tp, _Poolp>::pointer\n+    __mt_alloc<_Tp, _Poolp>::\n+    allocate(size_type __n, const void*)\n+    {\n+      this->_S_initialize_once();\n+\n       // Requests larger than _M_max_bytes are handled by new/delete\n       // directly.\n+      __pool_type& __pl = this->_S_get_pool();\n       const size_t __bytes = __n * sizeof(_Tp);\n-      if (__bytes > _S_options._M_max_bytes || _S_options._M_force_new)\n+      if (__pl._M_check_threshold(__bytes))\n \t{\n \t  void* __ret = ::operator new(__bytes);\n \t  return static_cast<_Tp*>(__ret);\n \t}\n \n       // Round up to power of 2 and figure out which bin to use.\n-      const size_t __which = _S_binmap[__bytes];      \n-      const size_t __thread_id = _S_get_thread_id();\n+      const size_t __which = __pl._M_get_binmap(__bytes);\n+      const size_t __thread_id = __pl._M_get_thread_id();\n       \n       // Find out if we have blocks on our freelist.  If so, go ahead\n       // and use them directly without having to lock anything.\n-      const _Bin_record& __bin = _S_bin[__which];\n-      _Block_record* __block = NULL;\n-      if (__bin._M_first[__thread_id] == NULL)\n+      char* __c;\n+      typedef typename __pool_type::_Bin_record _Bin_record;\n+      const _Bin_record& __bin = __pl._M_get_bin(__which);\n+      if (__bin._M_first[__thread_id])\n \t{\n-\t  // NB: For alignment reasons, we can't use the first _M_align\n-\t  // bytes, even when sizeof(_Block_record) < _M_align.\n-\t  const size_t __bin_size = ((_S_options._M_min_bin << __which)\n-\t\t\t\t     + _S_options._M_align);\n-\t  size_t __block_count = _S_options._M_chunk_size / __bin_size;\t  \n-\n-\t  // Are we using threads?\n-\t  // - Yes, check if there are free blocks on the global\n-\t  //   list. If so, grab up to __block_count blocks in one\n-\t  //   lock and change ownership. If the global list is \n-\t  //   empty, we allocate a new chunk and add those blocks \n-\t  //   directly to our own freelist (with us as owner).\n-\t  // - No, all operations are made directly to global pool 0\n-\t  //   no need to lock or change ownership but check for free\n-\t  //   blocks on global list (and if not add new ones) and\n-\t  //   get the first one.\n-#ifdef __GTHREADS\n-\t  if (__gthread_active_p())\n-\t    {\n-\t      __gthread_mutex_lock(__bin._M_mutex);\n-\t      if (__bin._M_first[0] == NULL)\n-\t\t{\n-\t\t  // No need to hold the lock when we are adding a\n-\t\t  // whole chunk to our own list.\n-\t\t  __gthread_mutex_unlock(__bin._M_mutex);\n-\t\t  \n-\t\t  void* __v = ::operator new(_S_options._M_chunk_size);\n-\t\t  __bin._M_first[__thread_id] = static_cast<_Block_record*>(__v);\n-\t\t  __bin._M_free[__thread_id] = __block_count;\n-\n-\t\t  --__block_count;\n-\t\t  __block = __bin._M_first[__thread_id];\n-\t\t  while (__block_count-- > 0)\n-\t\t    {\n-\t\t      char* __c = reinterpret_cast<char*>(__block) + __bin_size;\n-\t\t      __block->_M_next = reinterpret_cast<_Block_record*>(__c);\n-\t\t      __block = __block->_M_next;\n-\t\t    }\n-\t\t  __block->_M_next = NULL;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  // Is the number of required blocks greater than or\n-\t\t  // equal to the number that can be provided by the\n-\t\t  // global free list?\n-\t\t  __bin._M_first[__thread_id] = __bin._M_first[0];\n-\t\t  if (__block_count >= __bin._M_free[0])\n-\t\t    {\n-\t\t      __bin._M_free[__thread_id] = __bin._M_free[0];\n-\t\t      __bin._M_free[0] = 0;\n-\t\t      __bin._M_first[0] = NULL;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      __bin._M_free[__thread_id] = __block_count;\n-\t\t      __bin._M_free[0] -= __block_count;\n-\t\t      --__block_count;\n-\t\t      __block = __bin._M_first[0];\n-\t\t      while (__block_count-- > 0)\n-\t\t\t__block = __block->_M_next;\n-\t\t      __bin._M_first[0] = __block->_M_next;\n-\t\t      __block->_M_next = NULL;\n-\t\t    }\n-\t\t  __gthread_mutex_unlock(__bin._M_mutex);\n-\t\t}\n-\t    }\n-\t  else\n-#endif\n-\t    {\n-\t      void* __v = ::operator new(_S_options._M_chunk_size);\n-\t      __bin._M_first[0] = static_cast<_Block_record*>(__v);\n-\t      \n-\t      --__block_count;\n-\t      __block = __bin._M_first[0];\n-\t      while (__block_count-- > 0)\n-\t\t{\n-\t\t  char* __c = reinterpret_cast<char*>(__block) + __bin_size;\n-\t\t  __block->_M_next = reinterpret_cast<_Block_record*>(__c);\n-\t\t  __block = __block->_M_next;\n-\t\t}\n-\t      __block->_M_next = NULL;\n-\t    }\n+\t  // Already reserved.\n+\t  typedef typename __pool_type::_Block_record _Block_record;\n+\t  _Block_record* __block = __bin._M_first[__thread_id];\n+\t  __bin._M_first[__thread_id] = __bin._M_first[__thread_id]->_M_next;\n+\t  \n+\t  __pl._M_adjust_freelist(__bin, __block, __thread_id);\n+\t  const __pool_base::_Tune& __options = __pl._M_get_options();\n+\t  __c = reinterpret_cast<char*>(__block) + __options._M_align;\n \t}\n-\n-      __block = __bin._M_first[__thread_id];\n-      __bin._M_first[__thread_id] = __bin._M_first[__thread_id]->_M_next;\n-#ifdef __GTHREADS\n-      if (__gthread_active_p())\n+      else\n \t{\n-\t  __block->_M_thread_id = __thread_id;\n-\t  --__bin._M_free[__thread_id];\n-\t  ++__bin._M_used[__thread_id];\n+\t  // Null, reserve.\n+\t  __c = __pl._M_reserve_memory(__bytes, __thread_id);\n \t}\n-#endif\n-\n-      char* __c = reinterpret_cast<char*>(__block) + _S_options._M_align;\n       return static_cast<_Tp*>(static_cast<void*>(__c));\n     }\n   \n-  template<typename _Tp>\n+  template<typename _Tp, typename _Poolp>\n     void\n-    __mt_alloc<_Tp>::\n+    __mt_alloc<_Tp, _Poolp>::\n     deallocate(pointer __p, size_type __n)\n     {\n       // Requests larger than _M_max_bytes are handled by operators\n       // new/delete directly.\n+      __pool_type& __pl = this->_S_get_pool();\n       const size_t __bytes = __n * sizeof(_Tp);\n-      if (__bytes > _S_options._M_max_bytes || _S_options._M_force_new)\n-\t{\n-\t  ::operator delete(__p);\n-\t  return;\n-\t}\n-      \n-      // Round up to power of 2 and figure out which bin to use.\n-      const size_t __which = _S_binmap[__bytes];\n-      const _Bin_record& __bin = _S_bin[__which];\n-\n-      char* __c = reinterpret_cast<char*>(__p) - _S_options._M_align;\n-      _Block_record* __block = reinterpret_cast<_Block_record*>(__c);\n-      \n-#ifdef __GTHREADS\n-      if (__gthread_active_p())\n-\t{\n-\t  // Calculate the number of records to remove from our freelist:\n-\t  // in order to avoid too much contention we wait until the\n-\t  // number of records is \"high enough\".\n-\t  const size_t __thread_id = _S_get_thread_id();\n-\n-\t  long __remove = ((__bin._M_free[__thread_id]\n-\t\t\t    * _S_options._M_freelist_headroom)\n-\t\t\t   - __bin._M_used[__thread_id]);\n-\t  if (__remove > static_cast<long>(100 * (_S_bin_size - __which)\n-\t\t\t\t\t   * _S_options._M_freelist_headroom)\n-\t      && __remove > static_cast<long>(__bin._M_free[__thread_id]))\n-\t    {\n-\t      _Block_record* __tmp = __bin._M_first[__thread_id];\n-\t      _Block_record* __first = __tmp;\n-\t      __remove /= _S_options._M_freelist_headroom;\n-\t      const long __removed = __remove;\n-\t      --__remove;\n-\t      while (__remove-- > 0)\n-\t\t__tmp = __tmp->_M_next;\n-\t      __bin._M_first[__thread_id] = __tmp->_M_next;\n-\t      __bin._M_free[__thread_id] -= __removed;\n-\n-\t      __gthread_mutex_lock(__bin._M_mutex);\n-\t      __tmp->_M_next = __bin._M_first[0];\n-\t      __bin._M_first[0] = __first;\n-\t      __bin._M_free[0] += __removed;\n-\t      __gthread_mutex_unlock(__bin._M_mutex);\n-\t    }\n-\t  \n-\t  // Return this block to our list and update counters and\n-\t  // owner id as needed.\n-\t  --__bin._M_used[__block->_M_thread_id];\n-\n-\t  __block->_M_next = __bin._M_first[__thread_id];\n-\t  __bin._M_first[__thread_id] = __block;\n-\t  \n-\t  ++__bin._M_free[__thread_id];\n-\t}\n+      if (__pl._M_check_threshold(__bytes))\n+\t::operator delete(__p);\n       else\n-#endif\n-\t{\n-\t  // Single threaded application - return to global pool.\n-\t  __block->_M_next = __bin._M_first[0];\n-\t  __bin._M_first[0] = __block;\n-\t}\n+\t__pl._M_reclaim_memory(reinterpret_cast<char*>(__p), __bytes);\n     }\n   \n-  template<typename _Tp>\n-    void\n-    __mt_alloc<_Tp>::\n-    _S_initialize()\n-    {\n-      // This method is called on the first allocation (when _S_init is still\n-      // false) to create the bins.\n-      \n-      // Ensure that the static initialization of _S_options has\n-      // happened.  This depends on (a) _M_align == 0 being an invalid\n-      // value that is only present at startup, and (b) the real\n-      // static initialization that happens later not actually\n-      // changing anything.\n-      if (_S_options._M_align == 0) \n-        new (&_S_options) _Tune;\n-  \n-      // _M_force_new must not change after the first allocate(),\n-      // which in turn calls this method, so if it's false, it's false\n-      // forever and we don't need to return here ever again.\n-      if (_S_options._M_force_new) \n-\t{\n-\t  _S_init = true;\n-\t  return;\n-\t}\n-\n-      // Calculate the number of bins required based on _M_max_bytes.\n-      // _S_bin_size is statically-initialized to one.\n-      size_t __bin_size = _S_options._M_min_bin;\n-      while (_S_options._M_max_bytes > __bin_size)\n-\t{\n-\t  __bin_size <<= 1;\n-\t  ++_S_bin_size;\n-\t}\n-\n-      // Setup the bin map for quick lookup of the relevant bin.\n-      const size_t __j = (_S_options._M_max_bytes + 1) * sizeof(_Binmap_type);\n-      _S_binmap = static_cast<_Binmap_type*>(::operator new(__j));\n-\n-      _Binmap_type* __bp = _S_binmap;\n-      _Binmap_type __bin_max = _S_options._M_min_bin;\n-      _Binmap_type __bint = 0;\n-      for (_Binmap_type __ct = 0; __ct <= _S_options._M_max_bytes; ++__ct)\n-        {\n-          if (__ct > __bin_max)\n-            {\n-              __bin_max <<= 1;\n-              ++__bint;\n-            }\n-          *__bp++ = __bint;\n-        }\n-\n-      // Initialize _S_bin and its members.\n-      void* __v = ::operator new(sizeof(_Bin_record) * _S_bin_size);\n-      _S_bin = static_cast<_Bin_record*>(__v);\n-\n-      // If __gthread_active_p() create and initialize the list of\n-      // free thread ids. Single threaded applications use thread id 0\n-      // directly and have no need for this.\n-#ifdef __GTHREADS\n-      if (__gthread_active_p())\n-        {\n-\t  const size_t __k = sizeof(_Thread_record) * _S_options._M_max_threads;\n-\t  __v = ::operator new(__k);\n-          _S_thread_freelist_first = static_cast<_Thread_record*>(__v);\n-\n-\t  // NOTE! The first assignable thread id is 1 since the\n-\t  // global pool uses id 0\n-          size_t __i;\n-          for (__i = 1; __i < _S_options._M_max_threads; ++__i)\n-            {\n-\t      _Thread_record& __tr = _S_thread_freelist_first[__i - 1];\n-              __tr._M_next = &_S_thread_freelist_first[__i];\n-              __tr._M_id = __i;\n-            }\n-\n-          // Set last record.\n-          _S_thread_freelist_first[__i - 1]._M_next = NULL;\n-          _S_thread_freelist_first[__i - 1]._M_id = __i;\n-\n-\t  // Make sure this is initialized.\n-#ifndef __GTHREAD_MUTEX_INIT\n-\t  __GTHREAD_MUTEX_INIT_FUNCTION(&_S_thread_freelist_mutex);\n-#endif\n-          // Initialize per thread key to hold pointer to\n-          // _S_thread_freelist.\n-          __gthread_key_create(&_S_thread_key, _S_destroy_thread_key);\n-\n-\t  const size_t __max_threads = _S_options._M_max_threads + 1;\n-\t  for (size_t __n = 0; __n < _S_bin_size; ++__n)\n-\t    {\n-\t      _Bin_record& __bin = _S_bin[__n];\n-\t      __v = ::operator new(sizeof(_Block_record*) * __max_threads);\n-\t      __bin._M_first = static_cast<_Block_record**>(__v);\n-\n-\t      __v = ::operator new(sizeof(size_t) * __max_threads);\n-              __bin._M_free = static_cast<size_t*>(__v);\n-\n-\t      __v = ::operator new(sizeof(size_t) * __max_threads);\n-              __bin._M_used = static_cast<size_t*>(__v);\n-\n-\t      __v = ::operator new(sizeof(__gthread_mutex_t));\n-              __bin._M_mutex = static_cast<__gthread_mutex_t*>(__v);\n-\n-#ifdef __GTHREAD_MUTEX_INIT\n-              {\n-                // Do not copy a POSIX/gthr mutex once in use.\n-                __gthread_mutex_t __tmp = __GTHREAD_MUTEX_INIT;\n-                *__bin._M_mutex = __tmp;\n-              }\n-#else\n-              { __GTHREAD_MUTEX_INIT_FUNCTION(__bin._M_mutex); }\n-#endif\n-\n-\t      for (size_t __threadn = 0; __threadn < __max_threads;\n-\t\t   ++__threadn)\n-\t\t{\n-\t\t  __bin._M_first[__threadn] = NULL;\n-\t\t  __bin._M_free[__threadn] = 0;\n-\t\t  __bin._M_used[__threadn] = 0;\n-\t\t}\n-\t    }\n-\t}\n-      else\n-#endif\t\n-\tfor (size_t __n = 0; __n < _S_bin_size; ++__n)\n-\t  {\n-\t    _Bin_record& __bin = _S_bin[__n];\n-\t    __v = ::operator new(sizeof(_Block_record*));\n-\t    __bin._M_first = static_cast<_Block_record**>(__v);\n-\t    __bin._M_first[0] = NULL;\n-\t  }\n-\n-      _S_init = true;\n-    }\n-\n-  template<typename _Tp>\n-    size_t\n-    __mt_alloc<_Tp>::\n-    _S_get_thread_id()\n-    {\n-#ifdef __GTHREADS\n-      // If we have thread support and it's active we check the thread\n-      // key value and return its id or if it's not set we take the\n-      // first record from _S_thread_freelist and sets the key and\n-      // returns it's id.\n-      if (__gthread_active_p())\n-        {\n-          _Thread_record* __freelist_pos =\n-\t    static_cast<_Thread_record*>(__gthread_getspecific(_S_thread_key)); \n-\t  if (__freelist_pos == NULL)\n-            {\n-\t      // Since _S_options._M_max_threads must be larger than\n-\t      // the theoretical max number of threads of the OS the\n-\t      // list can never be empty.\n-              __gthread_mutex_lock(&_S_thread_freelist_mutex);\n-              __freelist_pos = _S_thread_freelist_first;\n-              _S_thread_freelist_first = _S_thread_freelist_first->_M_next;\n-              __gthread_mutex_unlock(&_S_thread_freelist_mutex);\n-\n-              __gthread_setspecific(_S_thread_key, \n-\t\t\t\t    static_cast<void*>(__freelist_pos));\n-            }\n-          return __freelist_pos->_M_id;\n-        }\n-#endif\n-      // Otherwise (no thread support or inactive) all requests are\n-      // served from the global pool 0.\n-      return 0;\n-    }\n-\n-#ifdef __GTHREADS\n-  template<typename _Tp>\n-    void\n-    __mt_alloc<_Tp>::\n-    _S_destroy_thread_key(void* __freelist_pos)\n-    {\n-      // Return this thread id record to front of thread_freelist.\n-      __gthread_mutex_lock(&_S_thread_freelist_mutex);\n-      _Thread_record* __tr = static_cast<_Thread_record*>(__freelist_pos);\n-      __tr->_M_next = _S_thread_freelist_first;\n-      _S_thread_freelist_first = __tr;\n-      __gthread_mutex_unlock(&_S_thread_freelist_mutex);\n-    }\n-#endif\n-\n-  template<typename _Tp>\n+  template<typename _Tp, typename _Poolp>\n     inline bool\n-    operator==(const __mt_alloc<_Tp>&, const __mt_alloc<_Tp>&)\n+    operator==(const __mt_alloc<_Tp, _Poolp>&, const __mt_alloc<_Tp, _Poolp>&)\n     { return true; }\n   \n-  template<typename _Tp>\n+  template<typename _Tp, typename _Poolp>\n     inline bool\n-    operator!=(const __mt_alloc<_Tp>&, const __mt_alloc<_Tp>&)\n+    operator!=(const __mt_alloc<_Tp, _Poolp>&, const __mt_alloc<_Tp, _Poolp>&)\n     { return false; }\n-\n-  template<typename _Tp> \n-    bool __mt_alloc<_Tp>::_S_init = false;\n-\n-  template<typename _Tp> \n-    typename __mt_alloc<_Tp>::_Tune __mt_alloc<_Tp>::_S_options;\n-\n-  template<typename _Tp> \n-    typename __mt_alloc<_Tp>::_Binmap_type* __mt_alloc<_Tp>::_S_binmap;\n-\n-  template<typename _Tp> \n-    typename __mt_alloc<_Tp>::_Bin_record* volatile __mt_alloc<_Tp>::_S_bin;\n-\n-  template<typename _Tp> \n-    size_t __mt_alloc<_Tp>::_S_bin_size = 1;\n-\n-  // Actual initialization in _S_initialize().\n-#ifdef __GTHREADS\n-  template<typename _Tp> \n-    __gthread_once_t __mt_alloc<_Tp>::_S_once = __GTHREAD_ONCE_INIT;\n-\n-  template<typename _Tp> \n-    typename __mt_alloc<_Tp>::_Thread_record*\n-    volatile __mt_alloc<_Tp>::_S_thread_freelist_first = NULL;\n-\n-  template<typename _Tp> \n-    __gthread_key_t __mt_alloc<_Tp>::_S_thread_key;\n-\n-  template<typename _Tp> \n-    __gthread_mutex_t\n-#ifdef __GTHREAD_MUTEX_INIT\n-    __mt_alloc<_Tp>::_S_thread_freelist_mutex = __GTHREAD_MUTEX_INIT;\n-#else\n-    __mt_alloc<_Tp>::_S_thread_freelist_mutex;\n-#endif\n-#endif\n } // namespace __gnu_cxx\n \n #endif"}, {"sha": "fb393f2a95714285e91b393851994be283cd773c", "filename": "libstdc++-v3/src/Makefile.am", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am?ref=8bfd0a46ea397185b00fe00bb40ae03c18838398", "patch": "@@ -96,7 +96,8 @@ basic_file.cc: ${glibcxx_srcdir}/$(BASIC_FILE_CC)\n \n # Sources present in the src directory.\n sources = \\\n-\tallocator.cc \\\n+\tpool_allocator.cc \\\n+\tmt_allocator.cc \\\n \tcodecvt.cc \\\n \tcomplex_io.cc \\\n \tctype.cc \\"}, {"sha": "91644529c25162b8ee3d8dae21d05dbdb8e4c44a", "filename": "libstdc++-v3/src/Makefile.in", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in?ref=8bfd0a46ea397185b00fe00bb40ae03c18838398", "patch": "@@ -64,14 +64,15 @@ am__objects_1 = atomicity.lo codecvt_members.lo collate_members.lo \\\n \tctype_members.lo messages_members.lo monetary_members.lo \\\n \tnumeric_members.lo time_members.lo\n am__objects_2 = basic_file.lo c++locale.lo\n-am__objects_3 = allocator.lo codecvt.lo complex_io.lo ctype.lo \\\n-\tdebug.lo debug_list.lo functexcept.lo globals_locale.lo \\\n-\tglobals_io.lo ios.lo ios_failure.lo ios_init.lo ios_locale.lo \\\n-\tlimits.lo list.lo locale.lo locale_init.lo locale_facets.lo \\\n-\tlocalename.lo stdexcept.lo strstream.lo tree.lo \\\n-\tallocator-inst.lo concept-inst.lo fstream-inst.lo ext-inst.lo \\\n-\tio-inst.lo istream-inst.lo locale-inst.lo locale-misc-inst.lo \\\n-\tmisc-inst.lo ostream-inst.lo sstream-inst.lo streambuf-inst.lo \\\n+am__objects_3 = pool_allocator.lo mt_allocator.lo codecvt.lo \\\n+\tcomplex_io.lo ctype.lo debug.lo debug_list.lo functexcept.lo \\\n+\tglobals_locale.lo globals_io.lo ios.lo ios_failure.lo \\\n+\tios_init.lo ios_locale.lo limits.lo list.lo locale.lo \\\n+\tlocale_init.lo locale_facets.lo localename.lo stdexcept.lo \\\n+\tstrstream.lo tree.lo allocator-inst.lo concept-inst.lo \\\n+\tfstream-inst.lo ext-inst.lo io-inst.lo istream-inst.lo \\\n+\tlocale-inst.lo locale-misc-inst.lo misc-inst.lo \\\n+\tostream-inst.lo sstream-inst.lo streambuf-inst.lo \\\n \tstring-inst.lo valarray-inst.lo wlocale-inst.lo \\\n \twstring-inst.lo $(am__objects_1) $(am__objects_2)\n am_libstdc___la_OBJECTS = $(am__objects_3)\n@@ -303,7 +304,8 @@ host_sources_extra = \\\n \n # Sources present in the src directory.\n sources = \\\n-\tallocator.cc \\\n+\tpool_allocator.cc \\\n+\tmt_allocator.cc \\\n \tcodecvt.cc \\\n \tcomplex_io.cc \\\n \tctype.cc \\"}, {"sha": "d25f488e4ca33ca1bff2a47429b92faa4aa10273", "filename": "libstdc++-v3/src/allocator-inst.cc", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Fsrc%2Fallocator-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Fsrc%2Fallocator-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fallocator-inst.cc?ref=8bfd0a46ea397185b00fe00bb40ae03c18838398", "patch": "@@ -32,20 +32,9 @@\n //\n \n #include <memory>\n-#include <ext/mt_allocator.h>\n-#include <ext/pool_allocator.h>\n \n namespace std\n {\n   template class allocator<char>;\n   template class allocator<wchar_t>;\n } // namespace std\n-\n-namespace __gnu_cxx\n-{\n-  template class __mt_alloc<char>;\n-  template class __mt_alloc<wchar_t>;\n-\n-  template class __pool_alloc<char>;\n-  template class __pool_alloc<wchar_t>;\n-} // namespace __gnu_cxx"}, {"sha": "ab3778c37f6dfd129f3729f4b7bcc051e4a39a08", "filename": "libstdc++-v3/src/mt_allocator.cc", "status": "added", "additions": 509, "deletions": 0, "changes": 509, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Fsrc%2Fmt_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Fsrc%2Fmt_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fmt_allocator.cc?ref=8bfd0a46ea397185b00fe00bb40ae03c18838398", "patch": "@@ -0,0 +1,509 @@\n+// Allocator details.\n+\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Librarbooly.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882:\n+//\n+\n+#include <bits/c++config.h>\n+#include <ext/mt_allocator.h>\n+#include <bits/concurrence.h>\n+\n+namespace __gnu_internal\n+{\n+  __glibcxx_mutex_define_initialized(freelist_mutex);\n+\n+#ifdef __GTHREADS\n+  __gthread_key_t freelist_key;\n+#endif\n+}\n+\n+namespace __gnu_cxx\n+{\n+#ifdef __GTHREADS\n+  void\n+  __pool<true>::_M_reclaim_memory(char* __p, size_t __bytes)\n+  {\n+    // Round up to power of 2 and figure out which bin to use.\n+    const size_t __which = _M_binmap[__bytes];\n+    const _Bin_record& __bin = _M_bin[__which];\n+    const _Tune& __options = _M_get_options();\n+    \n+    char* __c = __p - __options._M_align;\n+    _Block_record* __block = reinterpret_cast<_Block_record*>(__c);\n+    \n+    if (__gthread_active_p())\n+      {\n+\t// Calculate the number of records to remove from our freelist:\n+\t// in order to avoid too much contention we wait until the\n+\t// number of records is \"high enough\".\n+\tconst size_t __thread_id = _M_get_thread_id();\n+\t\n+\tlong __remove = ((__bin._M_free[__thread_id] \n+\t\t\t  * __options._M_freelist_headroom)\n+\t\t\t - __bin._M_used[__thread_id]);\n+\tif (__remove > static_cast<long>(100 * (_M_bin_size - __which)\n+\t\t\t\t\t * __options._M_freelist_headroom)\n+\t    && __remove > static_cast<long>(__bin._M_free[__thread_id]))\n+\t  {\n+\t    _Block_record* __tmp = __bin._M_first[__thread_id];\n+\t    _Block_record* __first = __tmp;\n+\t    __remove /= __options._M_freelist_headroom;\n+\t    const long __removed = __remove;\n+\t    --__remove;\n+\t    while (__remove-- > 0)\n+\t      __tmp = __tmp->_M_next;\n+\t    __bin._M_first[__thread_id] = __tmp->_M_next;\n+\t    __bin._M_free[__thread_id] -= __removed;\n+\t    \n+\t    __gthread_mutex_lock(__bin._M_mutex);\n+\t    __tmp->_M_next = __bin._M_first[0];\n+\t    __bin._M_first[0] = __first;\n+\t    __bin._M_free[0] += __removed;\n+\t    __gthread_mutex_unlock(__bin._M_mutex);\n+\t  }\n+\t\n+\t// Return this block to our list and update counters and\n+\t// owner id as needed.\n+\t--__bin._M_used[__block->_M_thread_id];\n+\t\n+\t__block->_M_next = __bin._M_first[__thread_id];\n+\t__bin._M_first[__thread_id] = __block;\n+\t\n+\t++__bin._M_free[__thread_id];\n+      }\n+    else\n+      {\n+\t// Not using threads, so single threaded application - return\n+\t// to global pool.\n+\t__block->_M_next = __bin._M_first[0];\n+\t__bin._M_first[0] = __block;\n+      }\n+  }\n+#endif\n+\n+  void\n+  __pool<false>::_M_reclaim_memory(char* __p, size_t __bytes)\n+  {\n+    // Round up to power of 2 and figure out which bin to use.\n+    const size_t __which = _M_binmap[__bytes];\n+    const _Bin_record& __bin = _M_bin[__which];\n+    const _Tune& __options = _M_get_options();\n+      \n+    char* __c = __p - __options._M_align;\n+    _Block_record* __block = reinterpret_cast<_Block_record*>(__c);\n+      \n+    // Single threaded application - return to global pool.\n+    __block->_M_next = __bin._M_first[0];\n+    __bin._M_first[0] = __block;\n+  }\n+\n+#ifdef __GTHREADS\n+  char* \n+  __pool<true>::_M_reserve_memory(size_t __bytes, const size_t __thread_id)\n+  {\n+    // Round up to power of 2 and figure out which bin to use.\n+    const size_t __which = _M_binmap[__bytes];\n+      \n+    // If here, there are no blocks on our freelist.\n+    const _Tune& __options = _M_get_options();\n+    _Block_record* __block = NULL;\n+    const _Bin_record& __bin = _M_bin[__which];\n+\n+    // NB: For alignment reasons, we can't use the first _M_align\n+    // bytes, even when sizeof(_Block_record) < _M_align.\n+    const size_t __bin_size = ((__options._M_min_bin << __which)\n+\t\t\t       + __options._M_align);\n+    size_t __block_count = __options._M_chunk_size / __bin_size;\t  \n+    \n+    // Are we using threads?\n+    // - Yes, check if there are free blocks on the global\n+    //   list. If so, grab up to __block_count blocks in one\n+    //   lock and change ownership. If the global list is \n+    //   empty, we allocate a new chunk and add those blocks \n+    //   directly to our own freelist (with us as owner).\n+    // - No, all operations are made directly to global pool 0\n+    //   no need to lock or change ownership but check for free\n+    //   blocks on global list (and if not add new ones) and\n+    //   get the first one.\n+    if (__gthread_active_p())\n+      {\n+\t__gthread_mutex_lock(__bin._M_mutex);\n+\tif (__bin._M_first[0] == NULL)\n+\t  {\n+\t    // No need to hold the lock when we are adding a\n+\t    // whole chunk to our own list.\n+\t    __gthread_mutex_unlock(__bin._M_mutex);\n+\t    \n+\t    void* __v = ::operator new(__options._M_chunk_size);\n+\t    __bin._M_first[__thread_id] = static_cast<_Block_record*>(__v);\n+\t    __bin._M_free[__thread_id] = __block_count;\n+\t    \n+\t    --__block_count;\n+\t    __block = __bin._M_first[__thread_id];\n+\t    while (__block_count-- > 0)\n+\t      {\n+\t\tchar* __c = reinterpret_cast<char*>(__block) + __bin_size;\n+\t\t__block->_M_next = reinterpret_cast<_Block_record*>(__c);\n+\t\t__block = __block->_M_next;\n+\t      }\n+\t    __block->_M_next = NULL;\n+\t  }\n+\telse\n+\t  {\n+\t    // Is the number of required blocks greater than or\n+\t    // equal to the number that can be provided by the\n+\t    // global free list?\n+\t    __bin._M_first[__thread_id] = __bin._M_first[0];\n+\t    if (__block_count >= __bin._M_free[0])\n+\t      {\n+\t\t__bin._M_free[__thread_id] = __bin._M_free[0];\n+\t\t__bin._M_free[0] = 0;\n+\t\t__bin._M_first[0] = NULL;\n+\t      }\n+\t    else\n+\t      {\n+\t\t__bin._M_free[__thread_id] = __block_count;\n+\t\t__bin._M_free[0] -= __block_count;\n+\t\t--__block_count;\n+\t\t__block = __bin._M_first[0];\n+\t\twhile (__block_count-- > 0)\n+\t\t  __block = __block->_M_next;\n+\t\t__bin._M_first[0] = __block->_M_next;\n+\t\t__block->_M_next = NULL;\n+\t      }\n+\t    __gthread_mutex_unlock(__bin._M_mutex);\n+\t  }\n+      }\n+    else\n+      {\n+\tvoid* __v = ::operator new(__options._M_chunk_size);\n+\t__bin._M_first[0] = static_cast<_Block_record*>(__v);\n+\t\n+\t--__block_count;\n+\t__block = __bin._M_first[0];\n+\twhile (__block_count-- > 0)\n+\t  {\n+\t    char* __c = reinterpret_cast<char*>(__block) + __bin_size;\n+\t    __block->_M_next = reinterpret_cast<_Block_record*>(__c);\n+\t    __block = __block->_M_next;\n+\t  }\n+\t__block->_M_next = NULL;\n+      }\n+      \n+    __block = __bin._M_first[__thread_id];\n+    __bin._M_first[__thread_id] = __bin._M_first[__thread_id]->_M_next;\n+\n+    if (__gthread_active_p())\n+      {\n+\t__block->_M_thread_id = __thread_id;\n+\t--__bin._M_free[__thread_id];\n+\t++__bin._M_used[__thread_id];\n+      }\n+    return reinterpret_cast<char*>(__block) + __options._M_align;\n+  }\n+#endif\n+\n+  char* \n+  __pool<false>::_M_reserve_memory(size_t __bytes, const size_t __thread_id)\n+  {\n+    // Round up to power of 2 and figure out which bin to use.\n+    const size_t __which = _M_binmap[__bytes];\n+      \n+    // If here, there are no blocks on our freelist.\n+    const _Tune& __options = _M_get_options();\n+    _Block_record* __block = NULL;\n+    const _Bin_record& __bin = _M_bin[__which];\n+    \n+    // NB: For alignment reasons, we can't use the first _M_align\n+    // bytes, even when sizeof(_Block_record) < _M_align.\n+    const size_t __bin_size = ((__options._M_min_bin << __which) \n+\t\t\t       + __options._M_align);\n+    size_t __block_count = __options._M_chunk_size / __bin_size;\t  \n+\t  \n+    // Not using threads.\n+    void* __v = ::operator new(__options._M_chunk_size);\n+    __bin._M_first[0] = static_cast<_Block_record*>(__v);\n+    \n+    --__block_count;\n+    __block = __bin._M_first[0];\n+    while (__block_count-- > 0)\n+      {\n+\tchar* __c = reinterpret_cast<char*>(__block) + __bin_size;\n+\t__block->_M_next = reinterpret_cast<_Block_record*>(__c);\n+\t__block = __block->_M_next;\n+      }\n+    __block->_M_next = NULL;\n+      \n+    __block = __bin._M_first[__thread_id];\n+    __bin._M_first[__thread_id] = __bin._M_first[__thread_id]->_M_next;\n+    return reinterpret_cast<char*>(__block) + __options._M_align;\n+  }\n+\n+#ifdef __GTHREADS\n+ void\n+  __pool<true>::_M_initialize(__destroy_handler __d)\n+  {\n+    // This method is called on the first allocation (when _M_init\n+    // is still false) to create the bins.\n+    \n+    // _M_force_new must not change after the first allocate(),\n+    // which in turn calls this method, so if it's false, it's false\n+    // forever and we don't need to return here ever again.\n+    if (_M_options._M_force_new) \n+      {\n+\t_M_init = true;\n+\treturn;\n+      }\n+      \n+    // Calculate the number of bins required based on _M_max_bytes.\n+    // _M_bin_size is statically-initialized to one.\n+    size_t __bin_size = _M_options._M_min_bin;\n+    while (_M_options._M_max_bytes > __bin_size)\n+      {\n+\t__bin_size <<= 1;\n+\t++_M_bin_size;\n+      }\n+      \n+    // Setup the bin map for quick lookup of the relevant bin.\n+    const size_t __j = (_M_options._M_max_bytes + 1) * sizeof(_Binmap_type);\n+    _M_binmap = static_cast<_Binmap_type*>(::operator new(__j));\n+      \n+    _Binmap_type* __bp = _M_binmap;\n+    _Binmap_type __bin_max = _M_options._M_min_bin;\n+    _Binmap_type __bint = 0;\n+    for (_Binmap_type __ct = 0; __ct <= _M_options._M_max_bytes; ++__ct)\n+      {\n+\tif (__ct > __bin_max)\n+\t  {\n+\t    __bin_max <<= 1;\n+\t    ++__bint;\n+\t  }\n+\t*__bp++ = __bint;\n+      }\n+      \n+    // Initialize _M_bin and its members.\n+    void* __v = ::operator new(sizeof(_Bin_record) * _M_bin_size);\n+    _M_bin = static_cast<_Bin_record*>(__v);\n+      \n+    // If __gthread_active_p() create and initialize the list of\n+    // free thread ids. Single threaded applications use thread id 0\n+    // directly and have no need for this.\n+    if (__gthread_active_p())\n+      {\n+\tconst size_t __k = sizeof(_Thread_record) * _M_options._M_max_threads;\n+\t__v = ::operator new(__k);\n+\t_M_thread_freelist = static_cast<_Thread_record*>(__v);\n+\t  \n+\t// NOTE! The first assignable thread id is 1 since the\n+\t// global pool uses id 0\n+\tsize_t __i;\n+\tfor (__i = 1; __i < _M_options._M_max_threads; ++__i)\n+\t  {\n+\t    _Thread_record& __tr = _M_thread_freelist[__i - 1];\n+\t    __tr._M_next = &_M_thread_freelist[__i];\n+\t    __tr._M_id = __i;\n+\t  }\n+\t  \n+\t// Set last record.\n+\t_M_thread_freelist[__i - 1]._M_next = NULL;\n+\t_M_thread_freelist[__i - 1]._M_id = __i;\n+\t  \n+\t// Initialize per thread key to hold pointer to\n+\t// _M_thread_freelist.\n+\t__gthread_key_create(&__gnu_internal::freelist_key, __d);\n+\t  \n+\tconst size_t __max_threads = _M_options._M_max_threads + 1;\n+\tfor (size_t __n = 0; __n < _M_bin_size; ++__n)\n+\t  {\n+\t    _Bin_record& __bin = _M_bin[__n];\n+\t    __v = ::operator new(sizeof(_Block_record*) * __max_threads);\n+\t    __bin._M_first = static_cast<_Block_record**>(__v);\n+\t      \n+\t    __v = ::operator new(sizeof(size_t) * __max_threads);\n+\t    __bin._M_free = static_cast<size_t*>(__v);\n+\t      \n+\t    __v = ::operator new(sizeof(size_t) * __max_threads);\n+\t    __bin._M_used = static_cast<size_t*>(__v);\n+\t      \n+\t    __v = ::operator new(sizeof(__gthread_mutex_t));\n+\t    __bin._M_mutex = static_cast<__gthread_mutex_t*>(__v);\n+\t      \n+#ifdef __GTHREAD_MUTEX_INIT\n+\t    {\n+\t      // Do not copy a POSIX/gthr mutex once in use.\n+\t      __gthread_mutex_t __tmp = __GTHREAD_MUTEX_INIT;\n+\t      *__bin._M_mutex = __tmp;\n+\t    }\n+#else\n+\t    { __GTHREAD_MUTEX_INIT_FUNCTION(__bin._M_mutex); }\n+#endif\n+\t      \n+\t    for (size_t __threadn = 0; __threadn < __max_threads;\n+\t\t ++__threadn)\n+\t      {\n+\t\t__bin._M_first[__threadn] = NULL;\n+\t\t__bin._M_free[__threadn] = 0;\n+\t\t__bin._M_used[__threadn] = 0;\n+\t      }\n+\t  }\n+      }\n+    else\n+      for (size_t __n = 0; __n < _M_bin_size; ++__n)\n+\t{\n+\t  _Bin_record& __bin = _M_bin[__n];\n+\t  __v = ::operator new(sizeof(_Block_record*));\n+\t  __bin._M_first = static_cast<_Block_record**>(__v);\n+\t  __bin._M_first[0] = NULL;\n+\t}\n+    _M_init = true;\n+  }\n+#endif\n+\n+  void\n+  __pool<false>::_M_initialize()\n+  {\n+    // This method is called on the first allocation (when _M_init\n+    // is still false) to create the bins.\n+    \n+    // _M_force_new must not change after the first allocate(),\n+    // which in turn calls this method, so if it's false, it's false\n+    // forever and we don't need to return here ever again.\n+    if (_M_options._M_force_new) \n+      {\n+\t_M_init = true;\n+\treturn;\n+      }\n+      \n+    // Calculate the number of bins required based on _M_max_bytes.\n+    // _M_bin_size is statically-initialized to one.\n+    size_t __bin_size = _M_options._M_min_bin;\n+    while (_M_options._M_max_bytes > __bin_size)\n+      {\n+\t__bin_size <<= 1;\n+\t++_M_bin_size;\n+      }\n+      \n+    // Setup the bin map for quick lookup of the relevant bin.\n+    const size_t __j = (_M_options._M_max_bytes + 1) * sizeof(_Binmap_type);\n+    _M_binmap = static_cast<_Binmap_type*>(::operator new(__j));\n+      \n+    _Binmap_type* __bp = _M_binmap;\n+    _Binmap_type __bin_max = _M_options._M_min_bin;\n+    _Binmap_type __bint = 0;\n+    for (_Binmap_type __ct = 0; __ct <= _M_options._M_max_bytes; ++__ct)\n+      {\n+\tif (__ct > __bin_max)\n+\t  {\n+\t    __bin_max <<= 1;\n+\t    ++__bint;\n+\t  }\n+\t*__bp++ = __bint;\n+      }\n+      \n+    // Initialize _M_bin and its members.\n+    void* __v = ::operator new(sizeof(_Bin_record) * _M_bin_size);\n+    _M_bin = static_cast<_Bin_record*>(__v);\n+      \n+    for (size_t __n = 0; __n < _M_bin_size; ++__n)\n+      {\n+\t_Bin_record& __bin = _M_bin[__n];\n+\t__v = ::operator new(sizeof(_Block_record*));\n+\t__bin._M_first = static_cast<_Block_record**>(__v);\n+\t__bin._M_first[0] = NULL;\n+      }\n+    _M_init = true;\n+  }\n+  \n+#ifdef __GTHREADS\n+  size_t\n+  __pool<true>::_M_get_thread_id()\n+  {\n+    // If we have thread support and it's active we check the thread\n+    // key value and return its id or if it's not set we take the\n+    // first record from _M_thread_freelist and sets the key and\n+    // returns it's id.\n+    if (__gthread_active_p())\n+      {\n+\tvoid* v = __gthread_getspecific(__gnu_internal::freelist_key);\n+\t_Thread_record* __freelist_pos = static_cast<_Thread_record*>(v); \n+\tif (__freelist_pos == NULL)\n+\t  {\n+\t    // Since _M_options._M_max_threads must be larger than\n+\t    // the theoretical max number of threads of the OS the\n+\t    // list can never be empty.\n+\t    {\n+\t      __gnu_cxx::lock sentry(__gnu_internal::freelist_mutex);\n+\t      __freelist_pos = _M_thread_freelist;\n+\t      _M_thread_freelist = _M_thread_freelist->_M_next;\n+\t    }\n+\t      \n+\t    __gthread_setspecific(__gnu_internal::freelist_key, \n+\t\t\t\t  static_cast<void*>(__freelist_pos));\n+\t  }\n+\treturn __freelist_pos->_M_id;\n+      }\n+\n+    // Otherwise (no thread support or inactive) all requests are\n+    // served from the global pool 0.\n+    return 0;\n+  }\n+\n+  void\n+  __pool<true>::_M_destroy_thread_key(void* __freelist_pos)\n+  {\n+    // Return this thread id record to front of thread_freelist.\n+    __gnu_cxx::lock sentry(__gnu_internal::freelist_mutex);\n+    _Thread_record* __tr = static_cast<_Thread_record*>(__freelist_pos);\n+    __tr->_M_next = _M_thread_freelist; \n+    _M_thread_freelist = __tr;\n+  }\n+#endif\n+\n+  // Definitions for non-exported bits of __common_pool.\n+#ifdef __GTHREADS\n+  __pool<true>\n+  __common_pool_policy<true>::_S_data = __pool<true>();\n+\n+  __pool<true>&\n+  __common_pool_policy<true>::_S_get_pool() { return _S_data; }\n+#endif\n+\n+  template<>\n+    __pool<false>\n+    __common_pool_policy<false>::_S_data = __pool<false>();\n+\n+  template<>\n+    __pool<false>&\n+    __common_pool_policy<false>::_S_get_pool() { return _S_data; }\n+\n+  // Instantiations.\n+  template class __mt_alloc<char>;\n+  template class __mt_alloc<wchar_t>;\n+} // namespace __gnu_cxx"}, {"sha": "8c7fc29058b52a4fcb3fa690245c81756b42fe71", "filename": "libstdc++-v3/src/pool_allocator.cc", "status": "renamed", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Fsrc%2Fpool_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Fsrc%2Fpool_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fpool_allocator.cc?ref=8bfd0a46ea397185b00fe00bb40ae03c18838398", "patch": "@@ -32,8 +32,7 @@\n //\n \n #include <bits/c++config.h>\n-#include <memory>\n-#include <ext/mt_allocator.h>\n+#include <cstdlib>\n #include <ext/pool_allocator.h>\n \n namespace __gnu_internal\n@@ -166,4 +165,8 @@ namespace __gnu_cxx\n   char* __pool_alloc_base::_S_end_free = 0;\n   \n   size_t __pool_alloc_base::_S_heap_size = 0;\n+\n+  // Instantiations.\n+  template class __pool_alloc<char>;\n+  template class __pool_alloc<wchar_t>;\n } // namespace __gnu_cxx", "previous_filename": "libstdc++-v3/src/allocator.cc"}, {"sha": "7e4e9f98aa4cdfab7cb3691d5dab82a136f7837e", "filename": "libstdc++-v3/testsuite/ext/allocators.cc", "status": "removed", "additions": 0, "deletions": 105, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0705d60230a25db8478d23bbd037351bf78309dc/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fallocators.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0705d60230a25db8478d23bbd037351bf78309dc/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fallocators.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fallocators.cc?ref=0705d60230a25db8478d23bbd037351bf78309dc", "patch": "@@ -1,105 +0,0 @@\n-// 2001-11-25  Phil Edwards  <pme@gcc.gnu.org>\n-//\n-// Copyright (C) 2001, 2003 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-//\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-//\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n-// USA.\n-\n-// 20.4.1.1 allocator members\n-\n-#include <cstdlib>\n-#include <memory>\n-//#include <ext/pool_allocator.h>\n-#include <ext/debug_allocator.h>\n-#include <ext/malloc_allocator.h>\n-#include <testsuite_hooks.h>\n-\n-using __gnu_cxx::malloc_allocator;\n-using __gnu_cxx::debug_allocator;\n-\n-\n-template class malloc_allocator<int>;\n-template class debug_allocator<malloc_allocator<int> >;\n-\n-#if 0\n-using __gnu_cxx::__pool_alloc;\n-template class __pool_alloc<true, 3>;\n-template class __pool_alloc<false, 3>;\n-#endif\n-\n-bool         new_called;\n-bool         delete_called;\n-std::size_t  requested;\n-\n-void* \n-operator new(std::size_t n) throw(std::bad_alloc)\n-{\n-  new_called = true;\n-  requested = n;\n-  return std::malloc(n);\n-}\n-\n-void\n-operator delete(void *v) throw()\n-{\n-  delete_called = true;\n-  return std::free(v);\n-}\n-\n-template<typename Alloc, bool uses_global_new_and_delete>\n-void check_allocator()\n-{\n-  bool test __attribute__((unused)) = true;\n-  new_called = false;\n-  delete_called = false;\n-  requested = 0;\n-\n-  Alloc  a;\n-  typename Alloc::pointer p = a.allocate(10);\n-  if (uses_global_new_and_delete)  \n-    VERIFY( requested >= (10 * 15 * sizeof(long)) );\n-\n-  VERIFY( new_called == uses_global_new_and_delete );\n-  a.deallocate(p, 10);\n-  VERIFY( delete_called == uses_global_new_and_delete );\n-}\n-\n-// These just help tracking down error messages.\n-void test01() \n-{ check_allocator<malloc_allocator<int>, false>(); }\n-\n-void test02() \n-{ check_allocator<debug_allocator<malloc_allocator<int> >, false>(); }\n-\n-#if 0\n-void test03() \n-{ check_allocator<__pool_alloc<true, 3>, true>(); }\n-\n-void test04() \n-{ check_allocator<__pool_alloc<false, 3>, true>(); }\n-#endif\n-\n-int main()\n-{\n-  test01();\n-  test02();\n-#if 0\n-  test03();\n-  test04();\n-#endif\n-  return 0;\n-}\n-"}, {"sha": "04358f2d4a0f3cd239134a7095bd45617e4ca600", "filename": "libstdc++-v3/testsuite/ext/debug_allocator/check_new.cc", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fdebug_allocator%2Fcheck_new.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fdebug_allocator%2Fcheck_new.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fdebug_allocator%2Fcheck_new.cc?ref=8bfd0a46ea397185b00fe00bb40ae03c18838398", "patch": "@@ -0,0 +1,56 @@\n+// 2001-11-25  Phil Edwards  <pme@gcc.gnu.org>\n+//\n+// Copyright (C) 2001, 2003, 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 20.4.1.1 allocator members\n+\n+#include <cstdlib>\n+#include <ext/debug_allocator.h>\n+#include <ext/malloc_allocator.h>\n+#include <testsuite_allocator.h>\n+\n+using __gnu_cxx::malloc_allocator;\n+using __gnu_cxx::debug_allocator;\n+\n+void* \n+operator new(std::size_t n) throw(std::bad_alloc)\n+{\n+  new_called = true;\n+  requested = n;\n+  return std::malloc(n);\n+}\n+\n+void\n+operator delete(void *v) throw()\n+{\n+  delete_called = true;\n+  return std::free(v);\n+}\n+\n+bool test02() \n+{ \n+  typedef debug_allocator<malloc_allocator<unsigned int> > allocator_type;\n+  return (__gnu_test::check_new<allocator_type, false>() == false); \n+}\n+\n+int main()\n+{\n+  return test02();\n+}\n+"}, {"sha": "1e7b9f869482acca7e912c1dbe7d57f6a8028b3e", "filename": "libstdc++-v3/testsuite/ext/debug_allocator/instantiate.cc", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fdebug_allocator%2Finstantiate.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fdebug_allocator%2Finstantiate.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fdebug_allocator%2Finstantiate.cc?ref=8bfd0a46ea397185b00fe00bb40ae03c18838398", "patch": "@@ -0,0 +1,29 @@\n+// { dg-do compile }\n+\n+// 2001-11-25  Phil Edwards  <pme@gcc.gnu.org>\n+//\n+// Copyright (C) 2001, 2003, 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 20.4.1.1 allocator members\n+\n+#include <cstdlib>\n+#include <ext/debug_allocator.h>\n+#include <ext/malloc_allocator.h>\n+\n+template class __gnu_cxx::debug_allocator<__gnu_cxx::malloc_allocator<int> >;"}, {"sha": "544839aaad7fc445e9d7d028a35fe61c9b7e91ec", "filename": "libstdc++-v3/testsuite/ext/malloc_allocator/check_new.cc", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmalloc_allocator%2Fcheck_new.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmalloc_allocator%2Fcheck_new.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmalloc_allocator%2Fcheck_new.cc?ref=8bfd0a46ea397185b00fe00bb40ae03c18838398", "patch": "@@ -0,0 +1,55 @@\n+// 2001-11-25  Phil Edwards  <pme@gcc.gnu.org>\n+//\n+// Copyright (C) 2001, 2003, 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 20.4.1.1 allocator members\n+\n+#include <cstdlib>\n+#include <ext/malloc_allocator.h>\n+#include <testsuite_allocator.h>\n+\n+using __gnu_cxx::malloc_allocator;\n+\n+void* \n+operator new(std::size_t n) throw(std::bad_alloc)\n+{\n+  new_called = true;\n+  requested = n;\n+  return std::malloc(n);\n+}\n+\n+void\n+operator delete(void *v) throw()\n+{\n+  delete_called = true;\n+  return std::free(v);\n+}\n+\n+// These just help tracking down error messages.\n+bool test01() \n+{ \n+  typedef malloc_allocator<unsigned int> allocator_type;\n+  return (__gnu_test::check_new<allocator_type, false>() == false); \n+}\n+\n+int main()\n+{\n+  return test01();\n+}\n+"}, {"sha": "1b0a385c1639f948fb3b74edc3229324193c7ccb", "filename": "libstdc++-v3/testsuite/ext/malloc_allocator/instantiate.cc", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmalloc_allocator%2Finstantiate.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmalloc_allocator%2Finstantiate.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmalloc_allocator%2Finstantiate.cc?ref=8bfd0a46ea397185b00fe00bb40ae03c18838398", "patch": "@@ -0,0 +1,28 @@\n+// { dg-do compile }\n+\n+// 2001-11-25  Phil Edwards  <pme@gcc.gnu.org>\n+//\n+// Copyright (C) 2001, 2003, 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 20.4.1.1 allocator members\n+\n+#include <cstdlib>\n+#include <ext/malloc_allocator.h>\n+\n+template class __gnu_cxx::malloc_allocator<int>;"}, {"sha": "9e08821460234e17dca576ffda1bf773992d9aeb", "filename": "libstdc++-v3/testsuite/ext/mt_allocator/check_new.cc", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Fcheck_new.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Fcheck_new.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Fcheck_new.cc?ref=8bfd0a46ea397185b00fe00bb40ae03c18838398", "patch": "@@ -0,0 +1,54 @@\n+// 2001-11-25  Phil Edwards  <pme@gcc.gnu.org>\n+//\n+// Copyright (C) 2001, 2003, 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 20.4.1.1 allocator members\n+\n+#include <cstdlib>\n+#include <ext/mt_allocator.h>\n+#include <testsuite_allocator.h>\n+\n+using __gnu_cxx::__mt_alloc;\n+\n+void* \n+operator new(std::size_t n) throw(std::bad_alloc)\n+{\n+  new_called = true;\n+  requested = n;\n+  return std::malloc(n);\n+}\n+\n+void\n+operator delete(void *v) throw()\n+{\n+  delete_called = true;\n+  return std::free(v);\n+}\n+\n+bool test03() \n+{ \n+  typedef __mt_alloc<unsigned int> allocator_type;\n+  return (__gnu_test::check_new<allocator_type, true>() == true); \n+}\n+\n+int main()\n+{\n+  return test03();\n+}\n+"}, {"sha": "8e16b92df39e93df5e5c1be6d44aa5d38bf1592e", "filename": "libstdc++-v3/testsuite/ext/mt_allocator/instantiate.cc", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Finstantiate.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Finstantiate.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Finstantiate.cc?ref=8bfd0a46ea397185b00fe00bb40ae03c18838398", "patch": "@@ -0,0 +1,28 @@\n+// { dg-do compile }\n+\n+// 2001-11-25  Phil Edwards  <pme@gcc.gnu.org>\n+//\n+// Copyright (C) 2001, 2003, 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 20.4.1.1 allocator members\n+\n+#include <cstdlib>\n+#include <ext/mt_allocator.h>\n+\n+template class __gnu_cxx::__mt_alloc<int>;"}, {"sha": "d5769fce026af8c3a8127f23eb0f33aa6510045f", "filename": "libstdc++-v3/testsuite/ext/mt_allocator/tune-1.cc", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Ftune-1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Ftune-1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Ftune-1.cc?ref=8bfd0a46ea397185b00fe00bb40ae03c18838398", "patch": "@@ -0,0 +1,69 @@\n+// 2004-08-25 Benjamin Kosnik <bkoz@redhat.com>\n+//\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+#include <cassert>\n+#include <memory>\n+#include <ext/mt_allocator.h>\n+\n+struct pod\n+{\n+  int i;\n+};\n+\n+// Tune characteristics. \n+// __common_pool_policy\n+void test01()\n+{\n+  typedef pod value_type;\n+#ifdef __GTHREADS\n+  typedef __gnu_cxx::__common_pool_policy<true> policy_type;\n+#else\n+  typedef __gnu_cxx::__common_pool_policy<false> policy_type;\n+#endif\n+  typedef __gnu_cxx::__mt_alloc<value_type, policy_type> allocator_type;\n+  typedef __gnu_cxx::__pool_base::_Tune tune_type;\n+\n+  tune_type t_default;\n+  tune_type t_opt(16, 5120, 32, 5120, 20, 10, false);\n+  tune_type t_single(16, 5120, 32, 5120, 1, 10, false);\n+\n+  allocator_type a;\n+  tune_type t1 = a._M_get_options();  \n+  assert(t1._M_align == t_default._M_align);\n+  a._M_set_options(t_opt);\n+  tune_type t2 = a._M_get_options();  \n+  assert(t1._M_align != t2._M_align);\n+\n+  allocator_type::pointer p1 = a.allocate(128);\n+  allocator_type::pointer p2 = a.allocate(5128);\n+  a._M_set_options(t_single);\n+  t1 = a._M_get_options();  \n+  assert(t1._M_max_threads != t_single._M_max_threads);\n+  assert(t1._M_max_threads == t_opt._M_max_threads);\n+\n+  a.deallocate(p1, 128);\n+  a.deallocate(p2, 5128);\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "728606942055e078774d1fa0e2ea2355abfbad77", "filename": "libstdc++-v3/testsuite/ext/mt_allocator/tune-2.cc", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Ftune-2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Ftune-2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Ftune-2.cc?ref=8bfd0a46ea397185b00fe00bb40ae03c18838398", "patch": "@@ -0,0 +1,71 @@\n+// 2004-08-25 Benjamin Kosnik <bkoz@redhat.com>\n+//\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+#include <cassert>\n+#include <memory>\n+#include <ext/mt_allocator.h>\n+\n+struct pod\n+{\n+  int i;\n+};\n+\n+// Tune characteristics. \n+// __per_type_pool_policy\n+void test02()\n+{\n+  typedef pod value_type;\n+#ifdef __GTHREADS\n+  typedef __gnu_cxx::__per_type_pool_policy<value_type, true> policy_type;\n+#else\n+  typedef __gnu_cxx::__per_type_pool_policy<value_type, false> policy_type;\n+#endif\n+  typedef __gnu_cxx::__mt_alloc<value_type, policy_type> allocator_type;\n+  typedef __gnu_cxx::__pool_base::_Tune tune_type;\n+\n+  tune_type t_default;\n+  tune_type t_opt(16, 5120, 32, 5120, 20, 10, false);\n+  tune_type t_single(16, 5120, 32, 5120, 1, 10, false);\n+\n+  allocator_type a;\n+  tune_type t1 = a._M_get_options();  \n+  assert(t1._M_align == t_default._M_align);\n+  a._M_set_options(t_opt);\n+  tune_type t2 = a._M_get_options();  \n+  assert(t1._M_align != t2._M_align);\n+\n+  allocator_type::pointer p1 = a.allocate(128);\n+  allocator_type::pointer p2 = a.allocate(5128);\n+  a._M_set_options(t_single);\n+  t1 = a._M_get_options();  \n+  assert(t1._M_max_threads != t_single._M_max_threads);\n+  assert(t1._M_max_threads == t_opt._M_max_threads);\n+\n+  a.deallocate(p1, 128);\n+  a.deallocate(p2, 5128);\n+}\n+\n+\n+int main()\n+{\n+  test02();\n+\n+  return 0;\n+}"}, {"sha": "aeb732f115638ec262f66aa2cb5526a36102e973", "filename": "libstdc++-v3/testsuite/ext/mt_allocator/tune-3.cc", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Ftune-3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Ftune-3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Ftune-3.cc?ref=8bfd0a46ea397185b00fe00bb40ae03c18838398", "patch": "@@ -0,0 +1,100 @@\n+// 2004-08-25 Benjamin Kosnik <bkoz@redhat.com>\n+//\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+#include <cassert>\n+#include <memory>\n+#include <ext/mt_allocator.h>\n+\n+struct pod\n+{\n+  int i;\n+};\n+\n+// Tune characteristics, two of same type\n+template<typename _Tp>\n+struct test_policy\n+{ static bool per_type() { return true; } };\n+\n+template<bool _Thread>\n+struct test_policy<__gnu_cxx::__common_pool_policy<_Thread> >\n+{ \n+  typedef __gnu_cxx::__common_pool_policy<_Thread> pool_type;\n+  static bool per_type() { return false; } \n+};\n+\n+// Tune characteristics, two of different types\n+template<typename _Tp, typename _Cp>\n+void test03()\n+{\n+  typedef __gnu_cxx::__pool_base::_Tune tune_type;\n+  typedef _Tp value_type;\n+  typedef _Cp policy_type;\n+  typedef __gnu_cxx::__mt_alloc<value_type, policy_type> allocator_type;\n+\n+  tune_type t_default;\n+  tune_type t_opt(16, 5120, 32, 5120, 20, 10, false);\n+  tune_type t_single(16, 5120, 32, 5120, 1, 10, false);\n+\n+  // First instances assured.\n+  allocator_type a;\n+  tune_type t1 = a._M_get_options();\n+  tune_type t2;\n+  if (test_policy<policy_type>::per_type())\n+    {\n+      assert(t1._M_align == t_default._M_align);\n+      a._M_set_options(t_opt);\n+      t2 = a._M_get_options();  \n+      assert(t1._M_align != t2._M_align);\n+    }\n+  else\n+    t2 = t1;\n+\n+\n+  // Lock tune settings.\n+  typename allocator_type::pointer p1 = a.allocate(128);\n+\n+  allocator_type a2;\n+  tune_type t3 = a2._M_get_options();  \n+  tune_type t4;\n+  assert(t3._M_max_threads == t2._M_max_threads);\n+\n+  typename allocator_type::pointer p2 = a2.allocate(5128);\n+\n+  a2._M_set_options(t_single);\n+  t4 = a2._M_get_options();  \n+  assert(t4._M_max_threads != t_single._M_max_threads);\n+  assert(t4._M_max_threads == t3._M_max_threads);\n+\n+  a.deallocate(p1, 128);\n+  a2.deallocate(p2, 5128);\n+}\n+\n+int main()\n+{\n+#ifdef __GTHREADS\n+  test03<int, __gnu_cxx::__per_type_pool_policy<int, true> >();\n+  test03<int, __gnu_cxx::__common_pool_policy<true> >();\n+#endif\n+\n+  test03<int, __gnu_cxx::__common_pool_policy<false> >();\n+  test03<int, __gnu_cxx::__per_type_pool_policy<int, false> >();\n+\n+  return 0;\n+}"}, {"sha": "b85de24e561271743ada20cec9a3836d9d66146e", "filename": "libstdc++-v3/testsuite/ext/mt_allocator/tune-4.cc", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Ftune-4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Ftune-4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fmt_allocator%2Ftune-4.cc?ref=8bfd0a46ea397185b00fe00bb40ae03c18838398", "patch": "@@ -0,0 +1,118 @@\n+// 2004-08-25 Benjamin Kosnik <bkoz@redhat.com>\n+//\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+#include <cassert>\n+#include <memory>\n+#include <ext/mt_allocator.h>\n+\n+struct pod\n+{\n+  int i;\n+};\n+\n+// Tune characteristics, two of same type\n+template<typename _Tp>\n+struct test_policy\n+{ static bool per_type() { return true; } };\n+\n+template<bool _Thread>\n+struct test_policy<__gnu_cxx::__common_pool_policy<_Thread> >\n+{ \n+  typedef __gnu_cxx::__common_pool_policy<_Thread> pool_type;\n+  static bool per_type() { return false; } \n+};\n+\n+struct pod2\n+{\n+  int i;\n+  int j;\n+};\n+\n+// Tune characteristics, two of different instantiations\n+template<typename _Tp, typename _Cp>\n+void test04()\n+{\n+  typedef __gnu_cxx::__pool_base::_Tune tune_type;\n+  typedef _Tp value_type;\n+  typedef _Cp policy_type;\n+\n+  typedef __gnu_cxx::__mt_alloc<value_type, policy_type> allocator_type;\n+  tune_type t_default;\n+  tune_type t_opt(16, 5120, 32, 5120, 20, 10, false);\n+  tune_type t_single(16, 5120, 32, 5120, 1, 10, false);\n+\n+  allocator_type a;\n+  tune_type t1 = a._M_get_options();\n+  tune_type t2;\n+  if (test_policy<policy_type>::per_type())\n+    {\n+      assert(t1._M_align == t_default._M_align);\n+      a._M_set_options(t_opt);\n+      t2 = a._M_get_options();  \n+      assert(t1._M_align != t2._M_align);\n+    }\n+  else\n+    t2 = t1;\n+\n+  // Lock tune settings.\n+  typename allocator_type::pointer p1 = a.allocate(128);\n+\n+  // First instance of local type assured.\n+  typedef pod2 value2_type;\n+  typedef typename allocator_type::template rebind<value2_type>::other rebind_type;\n+\n+  rebind_type a2;\n+  tune_type t3 = a2._M_get_options();  \n+  tune_type t4;\n+\n+  // Both policy_type and rebind_type::policy_type have same characteristics.\n+  if (test_policy<policy_type>::per_type())\n+    {\n+      assert(t3._M_align == t_default._M_align);\n+      a2._M_set_options(t_opt);\n+      t4 = a2._M_get_options();  \n+      assert(t3._M_align != t4._M_align);\n+      t3 = t4;\n+    }\n+  else\n+    assert(t3._M_max_threads == t2._M_max_threads);\n+\n+  typename rebind_type::pointer p2 = a2.allocate(5128);\n+\n+  a2._M_set_options(t_single);\n+  t4 = a2._M_get_options();  \n+  assert(t4._M_max_threads != t_single._M_max_threads);\n+  assert(t4._M_max_threads == t3._M_max_threads);\n+\n+  a.deallocate(p1, 128);\n+  a2.deallocate(p2, 5128);\n+}\n+\n+int main()\n+{\n+#ifdef __GTHREADS\n+  test04<float, __gnu_cxx::__common_pool_policy<true> >();\n+  test04<double, __gnu_cxx::__per_type_pool_policy<double, true> >();\n+#endif\n+  test04<float, __gnu_cxx::__common_pool_policy<false> >();\n+  test04<double, __gnu_cxx::__per_type_pool_policy<double, false> >();\n+\n+  return 0;\n+}"}, {"sha": "ba6c75118ee14e342f7f704f883d17ebf0d6540f", "filename": "libstdc++-v3/testsuite/ext/pool_allocator/check_new.cc", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fpool_allocator%2Fcheck_new.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fpool_allocator%2Fcheck_new.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fpool_allocator%2Fcheck_new.cc?ref=8bfd0a46ea397185b00fe00bb40ae03c18838398", "patch": "@@ -0,0 +1,54 @@\n+// 2001-11-25  Phil Edwards  <pme@gcc.gnu.org>\n+//\n+// Copyright (C) 2001, 2003, 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 20.4.1.1 allocator members\n+\n+#include <cstdlib>\n+#include <ext/pool_allocator.h>\n+#include <testsuite_allocator.h>\n+\n+using __gnu_cxx::__pool_alloc;\n+\n+void* \n+operator new(std::size_t n) throw(std::bad_alloc)\n+{\n+  new_called = true;\n+  requested = n;\n+  return std::malloc(n);\n+}\n+\n+void\n+operator delete(void *v) throw()\n+{\n+  delete_called = true;\n+  return std::free(v);\n+}\n+\n+bool test03() \n+{ \n+  typedef __pool_alloc<unsigned int> allocator_type;\n+  return (__gnu_test::check_new<allocator_type, true>() == true); \n+}\n+\n+int main()\n+{\n+  return test03();\n+}\n+"}, {"sha": "42db97b5d0ed7aad32263115c8506ca078da9189", "filename": "libstdc++-v3/testsuite/ext/pool_allocator/instantiate.cc", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fpool_allocator%2Finstantiate.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fpool_allocator%2Finstantiate.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fpool_allocator%2Finstantiate.cc?ref=8bfd0a46ea397185b00fe00bb40ae03c18838398", "patch": "@@ -0,0 +1,28 @@\n+// { dg-do compile }\n+\n+// 2001-11-25  Phil Edwards  <pme@gcc.gnu.org>\n+//\n+// Copyright (C) 2001, 2003, 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 20.4.1.1 allocator members\n+\n+#include <cstdlib>\n+#include <ext/pool_allocator.h>\n+\n+template class __gnu_cxx::__pool_alloc<int>;"}, {"sha": "7d373aa08f9760b532d019006da0815f7191f2c1", "filename": "libstdc++-v3/testsuite/testsuite_allocator.h", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bfd0a46ea397185b00fe00bb40ae03c18838398/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_allocator.h?ref=8bfd0a46ea397185b00fe00bb40ae03c18838398", "patch": "@@ -38,6 +38,13 @@\n #include <cstddef>\n #include <limits>\n \n+namespace \n+{\n+  bool         new_called = false;\n+  bool         delete_called = false;\n+  std::size_t  requested = 0;\n+};\n+\n namespace __gnu_test\n {\n   class allocation_tracker\n@@ -170,9 +177,24 @@ namespace __gnu_test\n     operator!=(const tracker_alloc<T1>&, const tracker_alloc<T2>&) throw()\n     { return false; }\n \n-   bool\n-   check_construct_destroy(const char* tag, int expected_c, int expected_d);\n+  bool\n+  check_construct_destroy(const char* tag, int expected_c, int expected_d);\n \n+  template<typename Alloc, bool uses_global_new_and_delete>\n+  bool check_new()\n+  {\n+    bool test __attribute__((unused)) = true;\n+    Alloc  a;\n+    typename Alloc::pointer p = a.allocate(10);\n+    if (uses_global_new_and_delete)  \n+      test &= ( requested >= (10 * 15 * sizeof(long)) );\n+\n+    test &= ( new_called == uses_global_new_and_delete );\n+    a.deallocate(p, 10);\n+    test &= ( delete_called == uses_global_new_and_delete );\n+  \n+    return test;\n+  }\n }; // namespace __gnu_test\n \n #endif // _GLIBCXX_TESTSUITE_ALLOCATOR_H"}]}