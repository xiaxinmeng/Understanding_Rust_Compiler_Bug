{"sha": "a51a546c1704cd572c35c11e539568c04d99e7d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTUxYTU0NmMxNzA0Y2Q1NzJjMzVjMTFlNTM5NTY4YzA0ZDk5ZTdkMQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-02-27T16:38:00Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-02-28T12:58:28Z"}, "message": "libstdc++: Fix FS-dependent filesystem tests\n\nThese tests were failing on XFS because it doesn't support setting file\ntimestamps past 2038, so the expected overflow when reading back a huge\ntimestamp into a file_time_type didn't happen.\n\nAdditionally, the std::filesystem::file_time_type::clock has an\nepoch that is out of range of 32-bit time_t so testing times around that\nepoch may also fail.\n\nThis fixes the tests to give up gracefully if the filesystem doesn't\nsupport times that can't be represented in 32-bit time_t.\n\n\t* testsuite/27_io/filesystem/operations/last_write_time.cc: Fixes for\n\tfilesystems that silently truncate timestamps.\n\t* testsuite/experimental/filesystem/operations/last_write_time.cc:\n\tLikewise.", "tree": {"sha": "1ebf8ff9f963c803e435c0b6edeee4f51150906f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ebf8ff9f963c803e435c0b6edeee4f51150906f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a51a546c1704cd572c35c11e539568c04d99e7d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a51a546c1704cd572c35c11e539568c04d99e7d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a51a546c1704cd572c35c11e539568c04d99e7d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a51a546c1704cd572c35c11e539568c04d99e7d1/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86e2dc22c91a722d2624c0010d81f1ce4b911bbd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86e2dc22c91a722d2624c0010d81f1ce4b911bbd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86e2dc22c91a722d2624c0010d81f1ce4b911bbd"}], "stats": {"total": 140, "additions": 104, "deletions": 36}, "files": [{"sha": "9fe2fd2caa8261c0baa8f87b3c4c56274f076115", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51a546c1704cd572c35c11e539568c04d99e7d1/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51a546c1704cd572c35c11e539568c04d99e7d1/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=a51a546c1704cd572c35c11e539568c04d99e7d1", "patch": "@@ -1,5 +1,10 @@\n 2020-02-28  Jonathan Wakely  <jwakely@redhat.com>\n \n+\t* testsuite/27_io/filesystem/operations/last_write_time.cc: Fixes for\n+\tfilesystems that silently truncate timestamps.\n+\t* testsuite/experimental/filesystem/operations/last_write_time.cc:\n+\tLikewise.\n+\n \t* testsuite/21_strings/basic_string/cons/char/1.cc: Disable\n \t-Wstringop-overflow warnings.\n "}, {"sha": "2bba02f6899df0ea75f690da3eec3033d1b9f836", "filename": "libstdc++-v3/testsuite/27_io/filesystem/operations/last_write_time.cc", "status": "modified", "additions": 58, "deletions": 19, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51a546c1704cd572c35c11e539568c04d99e7d1/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Flast_write_time.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51a546c1704cd572c35c11e539568c04d99e7d1/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Flast_write_time.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Flast_write_time.cc?ref=a51a546c1704cd572c35c11e539568c04d99e7d1", "patch": "@@ -32,9 +32,12 @@\n #if _GLIBCXX_HAVE_UTIME_H\n # include <utime.h>\n #endif\n+#include <stdio.h>\n \n using time_type = std::filesystem::file_time_type;\n \n+namespace chrono = std::chrono;\n+\n void\n test01()\n {\n@@ -67,10 +70,15 @@ test01()\n \n   auto end_of_time = time_type::duration::max();\n   auto last_second\n-    = std::chrono::duration_cast<std::chrono::seconds>(end_of_time).count();\n+    = chrono::duration_cast<chrono::seconds>(end_of_time).count();\n   if (last_second > std::numeric_limits<std::time_t>::max())\n-    return; // can't test overflow\n+  {\n+    puts(\"Range of time_t is smaller than range of chrono::file_clock, \"\n+\t \"can't test for overflow on this target.\");\n+    return;\n+  }\n \n+  // Set mtime to a date past the maximum possible file_time_type:\n #if _GLIBCXX_USE_UTIMENSAT\n   struct ::timespec ts[2];\n   ts[0].tv_sec = 0;\n@@ -84,25 +92,34 @@ test01()\n   times.actime = std::numeric_limits<std::time_t>::max() - 1;\n   VERIFY( !::utime(p.string().c_str(), &times) );\n #else\n+  puts(\"No utimensat or utime, giving up.\");\n   return;\n #endif\n \n+  // Try to read back the impossibly-large mtime:\n   mtime = last_write_time(p, ec);\n-  VERIFY( ec );\n-  VERIFY( ec == std::make_error_code(std::errc::value_too_large) );\n-  VERIFY( mtime == time_type::min() );\n+  // Some filesystems (e.g. XFS) silently truncate distant times to\n+  // the time_t epochalypse, Jan 19 2038, so we won't get an error when\n+  // reading it back:\n+  if (ec)\n+  {\n+    VERIFY( ec == std::make_error_code(std::errc::value_too_large) );\n+    VERIFY( mtime == time_type::min() );\n+  }\n+  else\n+    puts(\"No overflow error, filesystem may not support 64-bit time_t.\");\n \n #if __cpp_exceptions\n-  caught = false;\n+  // Once more, with exceptions:\n   try {\n-    mtime = last_write_time(p);\n-  } catch (std::system_error const& e) {\n-    caught = true;\n-    ec = e.code();\n+    auto mtime2 = last_write_time(p);\n+    // If it didn't throw, expect to have read back the same value:\n+    VERIFY( mtime2 == mtime );\n+  } catch (std::filesystem::filesystem_error const& e) {\n+    // If it did throw, expect the error_code to be the same:\n+    VERIFY( e.code() == ec );\n+    VERIFY( e.path1() == p );\n   }\n-  VERIFY( caught );\n-  VERIFY( ec );\n-  VERIFY( ec == std::make_error_code(std::errc::value_too_large) );\n #endif\n }\n \n@@ -111,7 +128,7 @@ bool approx_equal(time_type file_time, time_type expected)\n   auto delta = expected - file_time;\n   if (delta < delta.zero())\n     delta = -delta;\n-  return delta < std::chrono::seconds(1);\n+  return delta < chrono::seconds(1);\n }\n \n void\n@@ -124,20 +141,20 @@ test02()\n   std::error_code ec;\n   time_type time;\n \n-  time = last_write_time(f.path);\n   ec = bad_ec;\n+  time = last_write_time(f.path);\n   last_write_time(f.path, time, ec);\n   VERIFY( !ec );\n   VERIFY( approx_equal(last_write_time(f.path), time) );\n \n   ec = bad_ec;\n-  time -= std::chrono::milliseconds(1000 * 60 * 10 + 15);\n+  time -= chrono::milliseconds(1000 * 60 * 10 + 15);\n   last_write_time(f.path, time, ec);\n   VERIFY( !ec );\n   VERIFY( approx_equal(last_write_time(f.path), time) );\n \n   ec = bad_ec;\n-  time += std::chrono::milliseconds(1000 * 60 * 20 + 15);\n+  time += chrono::milliseconds(1000 * 60 * 20 + 15);\n   last_write_time(f.path, time, ec);\n   VERIFY( !ec );\n   VERIFY( approx_equal(last_write_time(f.path), time) );\n@@ -146,6 +163,28 @@ test02()\n       < std::numeric_limits<std::int64_t>::max())\n     return; // file clock's epoch is out of range for 32-bit time_t\n \n+  using sys_time_32b\n+    = chrono::time_point<chrono::system_clock, chrono::duration<std::int32_t>>;\n+  auto duration_until_2038 = sys_time_32b::max() - sys_time_32b::clock::now();\n+  auto file_time_2038 = time_type::clock::now() + duration_until_2038;\n+\n+  ec = bad_ec;\n+  time = file_time_2038 - chrono::seconds(1);\n+  // Assume all filesystems can store times that fit in 32-bit time_t\n+  // (i.e. up to Jan 19 2038)\n+  last_write_time(f.path, time, ec);\n+  VERIFY( !ec );\n+  VERIFY( approx_equal(last_write_time(f.path), time) );\n+\n+  // Check whether the filesystem supports times larger than 32-bit time_t:\n+  time += chrono::seconds(60);\n+  last_write_time(f.path, time, ec);\n+  if (ec || !approx_equal(last_write_time(f.path), time))\n+  {\n+    puts(\"Filesystem seems to truncate times past Jan 19 2038, giving up.\");\n+    return; // Tests below will fail on this filesystem\n+  }\n+\n   ec = bad_ec;\n   // The file clock's epoch:\n   time = time_type();\n@@ -155,14 +194,14 @@ test02()\n \n   ec = bad_ec;\n   // A time after the epoch\n-  time += std::chrono::milliseconds(1000 * 60 * 10 + 15);\n+  time += chrono::milliseconds(1000 * 60 * 10 + 15);\n   last_write_time(f.path, time, ec);\n   VERIFY( !ec );\n   VERIFY( approx_equal(last_write_time(f.path), time) );\n \n   ec = bad_ec;\n   // A time before than the epoch\n-  time -= std::chrono::milliseconds(1000 * 60 * 20 + 15);\n+  time -= chrono::milliseconds(1000 * 60 * 20 + 15);\n   last_write_time(f.path, time, ec);\n   VERIFY( !ec );\n   VERIFY( approx_equal(last_write_time(f.path), time) );"}, {"sha": "13313a9a6404bf75bfc0c459b853e0848fe8214a", "filename": "libstdc++-v3/testsuite/experimental/filesystem/operations/last_write_time.cc", "status": "modified", "additions": 41, "deletions": 17, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51a546c1704cd572c35c11e539568c04d99e7d1/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Foperations%2Flast_write_time.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51a546c1704cd572c35c11e539568c04d99e7d1/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Foperations%2Flast_write_time.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Foperations%2Flast_write_time.cc?ref=a51a546c1704cd572c35c11e539568c04d99e7d1", "patch": "@@ -22,6 +22,7 @@\n // 15.25 Permissions [fs.op.last_write_time]\n \n #include <experimental/filesystem>\n+#include <limits>\n #include <testsuite_fs.h>\n #include <testsuite_hooks.h>\n \n@@ -31,9 +32,12 @@\n #if _GLIBCXX_HAVE_UTIME_H\n # include <utime.h>\n #endif\n+#include <stdio.h>\n \n using time_type = std::experimental::filesystem::file_time_type;\n \n+namespace chrono = std::chrono;\n+\n void\n test01()\n {\n@@ -66,10 +70,15 @@ test01()\n \n   auto end_of_time = time_type::duration::max();\n   auto last_second\n-    = std::chrono::duration_cast<std::chrono::seconds>(end_of_time).count();\n+    = chrono::duration_cast<chrono::seconds>(end_of_time).count();\n   if (last_second > std::numeric_limits<std::time_t>::max())\n-    return; // can't test overflow\n+  {\n+    puts(\"Range of time_t is smaller than range of chrono::file_clock, \"\n+\t \"can't test for overflow on this target.\");\n+    return;\n+  }\n \n+  // Set mtime to a date past the maximum possible file_time_type:\n #if _GLIBCXX_USE_UTIMENSAT\n   struct ::timespec ts[2];\n   ts[0].tv_sec = 0;\n@@ -83,25 +92,34 @@ test01()\n   times.actime = std::numeric_limits<std::time_t>::max() - 1;\n   VERIFY( !::utime(p.string().c_str(), &times) );\n #else\n+  puts(\"No utimensat or utime, giving up.\");\n   return;\n #endif\n \n+  // Try to read back the impossibly-large mtime:\n   mtime = last_write_time(p, ec);\n-  VERIFY( ec );\n-  VERIFY( ec == std::make_error_code(std::errc::value_too_large) );\n-  VERIFY( mtime == time_type::min() );\n+  // Some filesystems (e.g. XFS) silently truncate distant times to\n+  // the time_t epochalypse, Jan 19 2038, so we won't get an error when\n+  // reading it back:\n+  if (ec)\n+  {\n+    VERIFY( ec == std::make_error_code(std::errc::value_too_large) );\n+    VERIFY( mtime == time_type::min() );\n+  }\n+  else\n+    puts(\"No overflow error, filesystem may not support 64-bit time_t.\");\n \n #if __cpp_exceptions\n-  caught = false;\n+  // Once more, with exceptions:\n   try {\n-    mtime = last_write_time(p);\n-  } catch (std::system_error const& e) {\n-    caught = true;\n-    ec = e.code();\n+    auto mtime2 = last_write_time(p);\n+    // If it didn't throw, expect to have read back the same value:\n+    VERIFY( mtime2 == mtime );\n+  } catch (std::experimental::filesystem::filesystem_error const& e) {\n+    // If it did throw, expect the error_code to be the same:\n+    VERIFY( e.code() == ec );\n+    VERIFY( e.path1() == p );\n   }\n-  VERIFY( caught );\n-  VERIFY( ec );\n-  VERIFY( ec == std::make_error_code(std::errc::value_too_large) );\n #endif\n }\n \n@@ -110,39 +128,45 @@ bool approx_equal(time_type file_time, time_type expected)\n   auto delta = expected - file_time;\n   if (delta < delta.zero())\n     delta = -delta;\n-  return delta < std::chrono::seconds(1);\n+  return delta < chrono::seconds(1);\n }\n \n void\n test02()\n {\n   // write times\n \n+  const std::error_code bad_ec = make_error_code(std::errc::invalid_argument);\n   __gnu_test::scoped_file f;\n   std::error_code ec;\n   time_type time;\n \n+  ec = bad_ec;\n   time = last_write_time(f.path);\n   last_write_time(f.path, time, ec);\n   VERIFY( !ec );\n   VERIFY( approx_equal(last_write_time(f.path), time) );\n \n-  time -= std::chrono::milliseconds(1000 * 60 * 10 + 15);\n+  ec = bad_ec;\n+  time -= chrono::milliseconds(1000 * 60 * 10 + 15);\n   last_write_time(f.path, time, ec);\n   VERIFY( !ec );\n   VERIFY( approx_equal(last_write_time(f.path), time) );\n \n-  time += std::chrono::milliseconds(1000 * 60 * 20 + 15);\n+  ec = bad_ec;\n+  time += chrono::milliseconds(1000 * 60 * 20 + 15);\n   last_write_time(f.path, time, ec);\n   VERIFY( !ec );\n   VERIFY( approx_equal(last_write_time(f.path), time) );\n \n+  ec = bad_ec;\n   time = time_type();\n   last_write_time(f.path, time, ec);\n   VERIFY( !ec );\n   VERIFY( approx_equal(last_write_time(f.path), time) );\n \n-  time -= std::chrono::milliseconds(1000 * 60 * 10 + 15);\n+  ec = bad_ec;\n+  time -= chrono::milliseconds(1000 * 60 * 10 + 15);\n   last_write_time(f.path, time, ec);\n   VERIFY( !ec );\n   VERIFY( approx_equal(last_write_time(f.path), time) );"}]}