{"sha": "a6fa947e8261399636817b840fd0fc7c202742e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZmYTk0N2U4MjYxMzk5NjM2ODE3Yjg0MGZkMGZjN2MyMDI3NDJlNg==", "commit": {"author": {"name": "David Wohlferd", "email": "dw@LimeGreenSocks.com", "date": "2015-11-06T22:52:35Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2015-11-06T22:52:35Z"}, "message": "inline asm and multi-alternative constraints\n\n\t* doc/md.texi (multi-alternative constraints): Don't document\n\talternatives inherently tied to reload for the user documentation.\n\nFrom-SVN: r229897", "tree": {"sha": "3e2ce86540d25e95fa7dd360ca2d8040358029fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e2ce86540d25e95fa7dd360ca2d8040358029fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6fa947e8261399636817b840fd0fc7c202742e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6fa947e8261399636817b840fd0fc7c202742e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6fa947e8261399636817b840fd0fc7c202742e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6fa947e8261399636817b840fd0fc7c202742e6/comments", "author": null, "committer": null, "parents": [{"sha": "84d289d4b799707af519962a7d2670c71176d7a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84d289d4b799707af519962a7d2670c71176d7a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84d289d4b799707af519962a7d2670c71176d7a1"}], "stats": {"total": 25, "additions": 22, "deletions": 3}, "files": [{"sha": "e2f588bf6664fa912d4e745aa63802d777a00dd9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6fa947e8261399636817b840fd0fc7c202742e6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6fa947e8261399636817b840fd0fc7c202742e6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a6fa947e8261399636817b840fd0fc7c202742e6", "patch": "@@ -1,3 +1,8 @@\n+2015-11-06  David Wohlferd  <dw@LimeGreenSocks.com>\n+\n+\t* doc/md.texi (multi-alternative constraints): Don't document\n+\talternatives inherently tied to reload for the user documentation.\n+\n 2015-11-06  Michael Collison  <michael.collison@linaro.org\n \t    Ramana Radhakrishnan  <ramana.radhakrishnan@linaro.org>\n "}, {"sha": "ee629e2338127de0b683bd89c884644156b8d90c", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6fa947e8261399636817b840fd0fc7c202742e6/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6fa947e8261399636817b840fd0fc7c202742e6/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=a6fa947e8261399636817b840fd0fc7c202742e6", "patch": "@@ -1465,6 +1465,8 @@ can be described by a series of letters for each operand.  The overall\n constraint for an operand is made from the letters for this operand\n from the first alternative, a comma, the letters for this operand from\n the second alternative, a comma, and so on until the last alternative.\n+All operands for a single instruction must have the same number of \n+alternatives.\n @ifset INTERNALS\n Here is how it is done for fullword logical-or on the 68000:\n \n@@ -1482,9 +1484,7 @@ operand 1 (meaning it must match operand 0), and @samp{dKs} for operand\n @samp{0} for operand 1, and @samp{dmKs} for operand 2.  The @samp{=} and\n @samp{%} in the constraints apply to all the alternatives; their\n meaning is explained in the next section (@pxref{Class Preferences}).\n-@end ifset\n \n-@c FIXME Is this ? and ! stuff of use in asm()?  If not, hide unless INTERNAL\n If all the operands fit any one alternative, the instruction is valid.\n Otherwise, for each alternative, the compiler counts how many instructions\n must be added to copy the operands so that that alternative applies.\n@@ -1521,14 +1521,28 @@ This constraint is analogous to @samp{!} but it disparages severely\n the alternative only if the operand with the @samp{$} needs a reload.\n @end table\n \n-@ifset INTERNALS\n When an insn pattern has multiple alternatives in its constraints, often\n the appearance of the assembler code is determined mostly by which\n alternative was matched.  When this is so, the C code for writing the\n assembler code can use the variable @code{which_alternative}, which is\n the ordinal number of the alternative that was actually satisfied (0 for\n the first, 1 for the second alternative, etc.).  @xref{Output Statement}.\n @end ifset\n+@ifclear INTERNALS\n+\n+So the first alternative for the 68000's logical-or could be written as \n+@code{\"+m\" (output) : \"ir\" (input)}.  The second could be @code{\"+r\" \n+(output): \"irm\" (input)}.  However, the fact that two memory locations \n+cannot be used in a single instruction prevents simply using @code{\"+rm\" \n+(output) : \"irm\" (input)}.  Using multi-alternatives, this might be \n+written as @code{\"+m,r\" (output) : \"ir,irm\" (input)}.  This describes\n+all the available alternatives to the compiler, allowing it to choose \n+the most efficient one for the current conditions.\n+\n+There is no way within the template to determine which alternative was \n+chosen.  However you may be able to wrap your @code{asm} statements with \n+builtins such as @code{__builtin_constant_p} to achieve the desired results.\n+@end ifclear\n \n @ifset INTERNALS\n @node Class Preferences"}]}