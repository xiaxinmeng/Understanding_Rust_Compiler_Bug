{"sha": "fecfbfa4a290992437a99977381e29815ed9199d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmVjZmJmYTRhMjkwOTkyNDM3YTk5OTc3MzgxZTI5ODE1ZWQ5MTk5ZA==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2016-07-19T16:40:55Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2016-07-19T16:40:55Z"}, "message": "builtins.c: Use HOST_WIDE_INT_1 instead of (HOST_WIDE_INT) 1...\n\n\t* builtins.c: Use HOST_WIDE_INT_1 instead of (HOST_WIDE_INT) 1,\n\tHOST_WIDE_INT_1U instead of (unsigned HOST_WIDE_INT) 1,\n\tHOST_WIDE_INT_M1 instead of (HOST_WIDE_INT) -1 and\n\tHOST_WIDE_INT_M1U instead of (unsigned HOST_WIDE_INT) -1.\n\t* combine.c: Ditto.\n\t* cse.c: Ditto.\n\t* dojump.c: Ditto.\n\t* double-int.c: Ditto.\n\t* dse.c: Ditto.\n\t* dwarf2out.c: Ditto.\n\t* expmed.c: Ditto.\n\t* expr.c: Ditto.\n\t* fold-const.c: Ditto.\n\t* function.c: Ditto.\n\t* fwprop.c: Ditto.\n\t* genmodes.c: Ditto.\n\t* hwint.c: Ditto.\n\t* hwint.h: Ditto.\n\t* ifcvt.c: Ditto.\n\t* loop-doloop.c: Ditto.\n\t* loop-invariant.c: Ditto.\n\t* loop-iv.c: Ditto.\n\t* match.pd: Ditto.\n\t* optabs.c: Ditto.\n\t* real.c: Ditto.\n\t* reload.c: Ditto.\n\t* rtlanal.c: Ditto.\n\t* simplify-rtx.c: Ditto.\n\t* stor-layout.c: Ditto.\n\t* toplev.c: Ditto.\n\t* tree-ssa-loop-ivopts.c: Ditto.\n\t* tree-vect-generic.c: Ditto.\n\t* tree-vect-patterns.c: Ditto.\n\t* tree.c: Ditto.\n\t* tree.h: Ditto.\n\t* ubsan.c: Ditto.\n\t* varasm.c: Ditto.\n\t* wide-int-print.cc: Ditto.\n\t* wide-int.cc: Ditto.\n\t* wide-int.h: Ditto.\n\nFrom-SVN: r238481", "tree": {"sha": "d187dacf2ba515208c78754cda80de5b3a012926", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d187dacf2ba515208c78754cda80de5b3a012926"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fecfbfa4a290992437a99977381e29815ed9199d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fecfbfa4a290992437a99977381e29815ed9199d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fecfbfa4a290992437a99977381e29815ed9199d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fecfbfa4a290992437a99977381e29815ed9199d/comments", "author": null, "committer": null, "parents": [{"sha": "5989388cdfa7b757a9aab117f4dcabea147050a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5989388cdfa7b757a9aab117f4dcabea147050a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5989388cdfa7b757a9aab117f4dcabea147050a8"}], "stats": {"total": 411, "additions": 228, "deletions": 183}, "files": [{"sha": "66657798607a3288809d1683b9a4111e33a8d9be", "filename": "gcc/ChangeLog", "status": "modified", "additions": 50, "deletions": 5, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fecfbfa4a290992437a99977381e29815ed9199d", "patch": "@@ -1,13 +1,56 @@\n+2016-07-19  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* builtins.c: Use HOST_WIDE_INT_1 instead of (HOST_WIDE_INT) 1,\n+\tHOST_WIDE_INT_1U instead of (unsigned HOST_WIDE_INT) 1,\n+\tHOST_WIDE_INT_M1 instead of (HOST_WIDE_INT) -1 and\n+\tHOST_WIDE_INT_M1U instead of (unsigned HOST_WIDE_INT) -1.\n+\t* combine.c: Ditto.\n+\t* cse.c: Ditto.\n+\t* dojump.c: Ditto.\n+\t* double-int.c: Ditto.\n+\t* dse.c: Ditto.\n+\t* dwarf2out.c: Ditto.\n+\t* expmed.c: Ditto.\n+\t* expr.c: Ditto.\n+\t* fold-const.c: Ditto.\n+\t* function.c: Ditto.\n+\t* fwprop.c: Ditto.\n+\t* genmodes.c: Ditto.\n+\t* hwint.c: Ditto.\n+\t* hwint.h: Ditto.\n+\t* ifcvt.c: Ditto.\n+\t* loop-doloop.c: Ditto.\n+\t* loop-invariant.c: Ditto.\n+\t* loop-iv.c: Ditto.\n+\t* match.pd: Ditto.\n+\t* optabs.c: Ditto.\n+\t* real.c: Ditto.\n+\t* reload.c: Ditto.\n+\t* rtlanal.c: Ditto.\n+\t* simplify-rtx.c: Ditto.\n+\t* stor-layout.c: Ditto.\n+\t* toplev.c: Ditto.\n+\t* tree-ssa-loop-ivopts.c: Ditto.\n+\t* tree-vect-generic.c: Ditto.\n+\t* tree-vect-patterns.c: Ditto.\n+\t* tree.c: Ditto.\n+\t* tree.h: Ditto.\n+\t* ubsan.c: Ditto.\n+\t* varasm.c: Ditto.\n+\t* wide-int-print.cc: Ditto.\n+\t* wide-int.cc: Ditto.\n+\t* wide-int.h: Ditto.\n+\n 2016-07-19  David Malcolm  <dmalcolm@redhat.com>\n \n \t* selftest.c (selftest::assert_streq): Handle NULL values of\n \tval_actual and val_expected.\n \n 2016-07-19  Martin Jambor  <mjambor@suse.cz>\n \n-        PR fortran/71688\n-        * trans-decl.c (gfc_generate_function_code): Use cgraph_get_create_node\n-        rather than cgraph_create_node to get a call graph node.\n+\tPR fortran/71688\n+\t* trans-decl.c (gfc_generate_function_code): Use cgraph_get_create_node\n+\trather than cgraph_create_node to get a call graph node.\n \n 2016-07-19  Richard Biener  <rguenther@suse.de>\n \n@@ -367,15 +410,17 @@\n \n 2016-07-12  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n \n-\t* cfgexpand.c (expand_used_vars): Make the type of a local variable auto_vec.\n+\t* cfgexpand.c (expand_used_vars): Make the type of a local\n+\tvariable auto_vec.\n \t* genmatch.c (lower_for): Likewise.\n \t* haifa-sched.c (haifa_sched_init): Likewise.\n \t(add_to_speculative_block): Likewise.\n \t(create_check_block_twin): Likewise.\n \t* predict.c (handle_missing_profiles): Likewise.\n \t* tree-data-ref.c (loop_nest_has_data_refs): Likewise.\n \t* tree-diagnostic.c (maybe_unwind_expanded_macro_loc): Likewise.\n-\t* tree-ssa-loop-niter.c (discover_iteration_bound_by_body_walk): Likewise.\n+\t* tree-ssa-loop-niter.c (discover_iteration_bound_by_body_walk):\n+\tLikewise.\n \t(maybe_lower_iteration_bound): Likewise.\n \t* tree-ssa-sccvn.c (DFS): Likewise.\n \t* tree-stdarg.c (reachable_at_most_once): Likewise."}, {"sha": "03a0dc84d5389a0092d4136dae507a20419f7c21", "filename": "gcc/builtins.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=fecfbfa4a290992437a99977381e29815ed9199d", "patch": "@@ -668,11 +668,11 @@ target_char_cast (tree cst, char *p)\n   val = TREE_INT_CST_LOW (cst);\n \n   if (CHAR_TYPE_SIZE < HOST_BITS_PER_WIDE_INT)\n-    val &= (((unsigned HOST_WIDE_INT) 1) << CHAR_TYPE_SIZE) - 1;\n+    val &= (HOST_WIDE_INT_1U << CHAR_TYPE_SIZE) - 1;\n \n   hostval = val;\n   if (HOST_BITS_PER_CHAR < HOST_BITS_PER_WIDE_INT)\n-    hostval &= (((unsigned HOST_WIDE_INT) 1) << HOST_BITS_PER_CHAR) - 1;\n+    hostval &= (HOST_WIDE_INT_1U << HOST_BITS_PER_CHAR) - 1;\n \n   if (val != hostval)\n     return 1;"}, {"sha": "1e5ee8e9514c9d0139eb5c4d0a67c022c9855dcf", "filename": "gcc/combine.c", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=fecfbfa4a290992437a99977381e29815ed9199d", "patch": "@@ -4882,7 +4882,7 @@ find_split_point (rtx *loc, rtx_insn *insn, bool set_src)\n \t  rtx dest = XEXP (SET_DEST (x), 0);\n \t  machine_mode mode = GET_MODE (dest);\n \t  unsigned HOST_WIDE_INT mask\n-\t    = ((unsigned HOST_WIDE_INT) 1 << len) - 1;\n+\t    = (HOST_WIDE_INT_1U << len) - 1;\n \t  rtx or_mask;\n \n \t  if (BITS_BIG_ENDIAN)\n@@ -5016,7 +5016,7 @@ find_split_point (rtx *loc, rtx_insn *insn, bool set_src)\n \t  if (unsignedp && len <= 8)\n \t    {\n \t      unsigned HOST_WIDE_INT mask\n-\t\t= ((unsigned HOST_WIDE_INT) 1 << len) - 1;\n+\t\t= (HOST_WIDE_INT_1U << len) - 1;\n \t      SUBST (SET_SRC (x),\n \t\t     gen_rtx_AND (mode,\n \t\t\t\t  gen_rtx_LSHIFTRT\n@@ -5852,7 +5852,7 @@ combine_simplify_rtx (rtx x, machine_mode op0_mode, int in_dest,\n \t  && ((GET_CODE (XEXP (XEXP (x, 0), 0)) == AND\n \t       && CONST_INT_P (XEXP (XEXP (XEXP (x, 0), 0), 1))\n \t       && (UINTVAL (XEXP (XEXP (XEXP (x, 0), 0), 1))\n-\t\t   == ((unsigned HOST_WIDE_INT) 1 << (i + 1)) - 1))\n+\t\t   == (HOST_WIDE_INT_1U << (i + 1)) - 1))\n \t      || (GET_CODE (XEXP (XEXP (x, 0), 0)) == ZERO_EXTEND\n \t\t  && (GET_MODE_PRECISION (GET_MODE (XEXP (XEXP (XEXP (x, 0), 0), 0)))\n \t\t      == (unsigned int) i + 1))))\n@@ -6168,7 +6168,7 @@ combine_simplify_rtx (rtx x, machine_mode op0_mode, int in_dest,\n       else if (SHIFT_COUNT_TRUNCATED && !REG_P (XEXP (x, 1)))\n \tSUBST (XEXP (x, 1),\n \t       force_to_mode (XEXP (x, 1), GET_MODE (XEXP (x, 1)),\n-\t\t\t      ((unsigned HOST_WIDE_INT) 1\n+\t\t\t      (HOST_WIDE_INT_1U\n \t\t\t       << exact_log2 (GET_MODE_BITSIZE (GET_MODE (x))))\n \t\t\t      - 1,\n \t\t\t      0));\n@@ -7134,7 +7134,7 @@ expand_compound_operation (rtx x)\n \t\t\t\t  simplify_shift_const (NULL_RTX, LSHIFTRT,\n \t\t\t\t\t\t\tGET_MODE (x),\n \t\t\t\t\t\t\tXEXP (x, 0), pos),\n-\t\t\t\t  ((unsigned HOST_WIDE_INT) 1 << len) - 1);\n+\t\t\t\t  (HOST_WIDE_INT_1U << len) - 1);\n   else\n     /* Any other cases we can't handle.  */\n     return x;\n@@ -7261,7 +7261,7 @@ expand_field_assignment (const_rtx x)\n       /* Now compute the equivalent expression.  Make a copy of INNER\n \t for the SET_DEST in case it is a MEM into which we will substitute;\n \t we don't want shared RTL in that case.  */\n-      mask = gen_int_mode (((unsigned HOST_WIDE_INT) 1 << len) - 1,\n+      mask = gen_int_mode ((HOST_WIDE_INT_1U << len) - 1,\n \t\t\t   compute_mode);\n       cleared = simplify_gen_binary (AND, compute_mode,\n \t\t\t\t     simplify_gen_unary (NOT, compute_mode,\n@@ -7447,7 +7447,7 @@ make_extraction (machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n \tnew_rtx = force_to_mode (inner, tmode,\n \t\t\t     len >= HOST_BITS_PER_WIDE_INT\n \t\t\t     ? ~(unsigned HOST_WIDE_INT) 0\n-\t\t\t     : ((unsigned HOST_WIDE_INT) 1 << len) - 1,\n+\t\t\t     : (HOST_WIDE_INT_1U << len) - 1,\n \t\t\t     0);\n \n       /* If this extraction is going into the destination of a SET,\n@@ -7636,7 +7636,7 @@ make_extraction (machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n \t\t\t     pos_rtx\n \t\t\t     || len + orig_pos >= HOST_BITS_PER_WIDE_INT\n \t\t\t     ? ~(unsigned HOST_WIDE_INT) 0\n-\t\t\t     : ((((unsigned HOST_WIDE_INT) 1 << len) - 1)\n+\t\t\t     : (((HOST_WIDE_INT_1U << len) - 1)\n \t\t\t\t<< orig_pos),\n \t\t\t     0);\n     }\n@@ -7724,7 +7724,7 @@ extract_left_shift (rtx x, int count)\n \t make a new operation.  */\n       if (CONST_INT_P (XEXP (x, 1))\n \t  && (UINTVAL (XEXP (x, 1))\n-\t      & ((((unsigned HOST_WIDE_INT) 1 << count)) - 1)) == 0\n+\t      & (((HOST_WIDE_INT_1U << count)) - 1)) == 0\n \t  && (tem = extract_left_shift (XEXP (x, 0), count)) != 0)\n \t{\n \t  HOST_WIDE_INT val = INTVAL (XEXP (x, 1)) >> count;\n@@ -7793,7 +7793,7 @@ make_compound_operation (rtx x, enum rtx_code in_code)\n \t  && SCALAR_INT_MODE_P (mode))\n \t{\n \t  HOST_WIDE_INT count = INTVAL (XEXP (x, 1));\n-\t  HOST_WIDE_INT multval = (HOST_WIDE_INT) 1 << count;\n+\t  HOST_WIDE_INT multval = HOST_WIDE_INT_1 << count;\n \n \t  new_rtx = make_compound_operation (XEXP (x, 0), next_code);\n \t  if (GET_CODE (new_rtx) == NEG)\n@@ -8389,10 +8389,10 @@ force_to_mode (rtx x, machine_mode mode, unsigned HOST_WIDE_INT mask,\n   /* When we have an arithmetic operation, or a shift whose count we\n      do not know, we need to assume that all bits up to the highest-order\n      bit in MASK will be needed.  This is how we form such a mask.  */\n-  if (mask & ((unsigned HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT - 1)))\n+  if (mask & (HOST_WIDE_INT_1U << (HOST_BITS_PER_WIDE_INT - 1)))\n     fuller_mask = ~(unsigned HOST_WIDE_INT) 0;\n   else\n-    fuller_mask = (((unsigned HOST_WIDE_INT) 1 << (floor_log2 (mask) + 1))\n+    fuller_mask = ((HOST_WIDE_INT_1U << (floor_log2 (mask) + 1))\n \t\t   - 1);\n \n   /* Determine what bits of X are guaranteed to be (non)zero.  */\n@@ -9497,7 +9497,7 @@ make_field_assignment (rtx x)\n   src = force_to_mode (src, mode,\n \t\t       GET_MODE_PRECISION (mode) >= HOST_BITS_PER_WIDE_INT\n \t\t       ? ~(unsigned HOST_WIDE_INT) 0\n-\t\t       : ((unsigned HOST_WIDE_INT) 1 << len) - 1,\n+\t\t       : (HOST_WIDE_INT_1U << len) - 1,\n \t\t       0);\n \n   /* If SRC is masked by an AND that does not make a difference in\n@@ -9508,7 +9508,7 @@ make_field_assignment (rtx x)\n       && GET_CODE (src) == AND\n       && CONST_INT_P (XEXP (src, 1))\n       && UINTVAL (XEXP (src, 1))\n-\t == ((unsigned HOST_WIDE_INT) 1 << INTVAL (XEXP (assign, 1))) - 1)\n+\t == (HOST_WIDE_INT_1U << INTVAL (XEXP (assign, 1))) - 1)\n     src = XEXP (src, 0);\n \n   return gen_rtx_SET (assign, src);\n@@ -10433,7 +10433,7 @@ simplify_shift_const_1 (enum rtx_code code, machine_mode result_mode,\n \t\t  /* C3 has the low-order C1 bits zero.  */\n \n \t\t  mask = GET_MODE_MASK (mode)\n-\t\t\t & ~(((unsigned HOST_WIDE_INT) 1 << first_count) - 1);\n+\t\t\t & ~((HOST_WIDE_INT_1U << first_count) - 1);\n \n \t\t  varop = simplify_and_const_int (NULL_RTX, result_mode,\n \t\t\t\t\t\t  XEXP (varop, 0), mask);\n@@ -11377,7 +11377,7 @@ simplify_compare_const (enum rtx_code code, machine_mode mode,\n       else if (const_op == 0\n \t       && mode_width - 1 < HOST_BITS_PER_WIDE_INT\n \t       && (nonzero_bits (op0, mode)\n-\t\t   & ((unsigned HOST_WIDE_INT) 1 << (mode_width - 1)))\n+\t\t   & (HOST_WIDE_INT_1U << (mode_width - 1)))\n \t       == 0)\n \tcode = EQ;\n       break;\n@@ -11406,7 +11406,7 @@ simplify_compare_const (enum rtx_code code, machine_mode mode,\n       else if (const_op == 0\n \t       && mode_width - 1 < HOST_BITS_PER_WIDE_INT\n \t       && (nonzero_bits (op0, mode)\n-\t\t   & ((unsigned HOST_WIDE_INT) 1 << (mode_width - 1)))\n+\t\t   & (HOST_WIDE_INT_1U << (mode_width - 1)))\n \t       == 0)\n \tcode = NE;\n       break;\n@@ -11422,7 +11422,7 @@ simplify_compare_const (enum rtx_code code, machine_mode mode,\n       /* (unsigned) < 0x80000000 is equivalent to >= 0.  */\n       else if (mode_width - 1 < HOST_BITS_PER_WIDE_INT\n \t       && (unsigned HOST_WIDE_INT) const_op\n-\t       == (unsigned HOST_WIDE_INT) 1 << (mode_width - 1))\n+\t       == HOST_WIDE_INT_1U << (mode_width - 1))\n \t{\n \t  const_op = 0;\n \t  code = GE;\n@@ -11438,7 +11438,7 @@ simplify_compare_const (enum rtx_code code, machine_mode mode,\n       /* (unsigned) <= 0x7fffffff is equivalent to >= 0.  */\n       else if (mode_width - 1 < HOST_BITS_PER_WIDE_INT\n \t       && (unsigned HOST_WIDE_INT) const_op\n-\t       == ((unsigned HOST_WIDE_INT) 1 << (mode_width - 1)) - 1)\n+\t       == (HOST_WIDE_INT_1U << (mode_width - 1)) - 1)\n \t{\n \t  const_op = 0;\n \t  code = GE;\n@@ -11457,7 +11457,7 @@ simplify_compare_const (enum rtx_code code, machine_mode mode,\n       /* (unsigned) >= 0x80000000 is equivalent to < 0.  */\n       else if (mode_width - 1 < HOST_BITS_PER_WIDE_INT\n \t       && (unsigned HOST_WIDE_INT) const_op\n-\t       == (unsigned HOST_WIDE_INT) 1 << (mode_width - 1))\n+\t       == HOST_WIDE_INT_1U << (mode_width - 1))\n \t{\n \t  const_op = 0;\n \t  code = LT;\n@@ -11473,7 +11473,7 @@ simplify_compare_const (enum rtx_code code, machine_mode mode,\n       /* (unsigned) > 0x7fffffff is equivalent to < 0.  */\n       else if (mode_width - 1 < HOST_BITS_PER_WIDE_INT\n \t       && (unsigned HOST_WIDE_INT) const_op\n-\t       == ((unsigned HOST_WIDE_INT) 1 << (mode_width - 1)) - 1)\n+\t       == (HOST_WIDE_INT_1U << (mode_width - 1)) - 1)\n \t{\n \t  const_op = 0;\n \t  code = LT;\n@@ -11691,7 +11691,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t MODE, say that we will only be needing the sign bit of OP0.  */\n       if (sign_bit_comparison_p && HWI_COMPUTABLE_MODE_P (mode))\n \top0 = force_to_mode (op0, mode,\n-\t\t\t     (unsigned HOST_WIDE_INT) 1\n+\t\t\t     HOST_WIDE_INT_1U\n \t\t\t     << (GET_MODE_PRECISION (mode) - 1),\n \t\t\t     0);\n \n@@ -11778,7 +11778,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t      && (GET_CODE (XEXP (op0, 0)) == ABS\n \t\t  || (mode_width <= HOST_BITS_PER_WIDE_INT\n \t\t      && (nonzero_bits (XEXP (op0, 0), mode)\n-\t\t\t  & ((unsigned HOST_WIDE_INT) 1 << (mode_width - 1)))\n+\t\t\t  & (HOST_WIDE_INT_1U << (mode_width - 1)))\n \t\t\t == 0)))\n \t    {\n \t      op0 = XEXP (op0, 0);\n@@ -11816,7 +11816,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t      && mode_width <= HOST_BITS_PER_WIDE_INT)\n \t    {\n \t      op0 = simplify_and_const_int (NULL_RTX, mode, XEXP (op0, 0),\n-\t\t\t\t\t    ((unsigned HOST_WIDE_INT) 1\n+\t\t\t\t\t    (HOST_WIDE_INT_1U\n \t\t\t\t\t     << (mode_width - 1\n \t\t\t\t\t\t - INTVAL (XEXP (op0, 1)))));\n \t      code = (code == LT ? NE : EQ);\n@@ -11888,7 +11888,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \n \t      if ((c1 > 0\n \t\t   && (unsigned HOST_WIDE_INT) c1\n-\t\t       < (unsigned HOST_WIDE_INT) 1 << (mode_width - 1)\n+\t\t       < HOST_WIDE_INT_1U << (mode_width - 1)\n \t\t   && (equality_comparison_p || unsigned_comparison_p)\n \t\t   /* (A - C1) zero-extends if it is positive and sign-extends\n \t\t      if it is negative, C2 both zero- and sign-extends.  */\n@@ -11902,7 +11902,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t\t\t\t\t     - mode_width)\n \t\t\t   && const_op < 0)))\n \t\t  || ((unsigned HOST_WIDE_INT) c1\n-\t\t       < (unsigned HOST_WIDE_INT) 1 << (mode_width - 2)\n+\t\t       < HOST_WIDE_INT_1U << (mode_width - 2)\n \t\t      /* (A - C1) always sign-extends, like C2.  */\n \t\t      && num_sign_bit_copies (a, inner_mode)\n \t\t\t > (unsigned int) (GET_MODE_PRECISION (inner_mode)\n@@ -12111,7 +12111,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t      && CONST_INT_P (XEXP (op0, 1))\n \t      && mode_width <= HOST_BITS_PER_WIDE_INT\n \t      && ((INTVAL (XEXP (op0, 1)) & GET_MODE_MASK (mode))\n-\t\t  == (unsigned HOST_WIDE_INT) 1 << (mode_width - 1)))\n+\t\t  == HOST_WIDE_INT_1U << (mode_width - 1)))\n \t    {\n \t      op0 = XEXP (op0, 0);\n \t      code = (code == EQ ? GE : LT);\n@@ -12214,7 +12214,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t\t      && CONST_INT_P (shift_count)\n \t\t      && HWI_COMPUTABLE_MODE_P (mode)\n \t\t      && (UINTVAL (XEXP (shift_op, 1))\n-\t\t\t  == (unsigned HOST_WIDE_INT) 1\n+\t\t\t  == HOST_WIDE_INT_1U\n \t\t\t       << INTVAL (shift_count))))\n \t\t{\n \t\t  op0\n@@ -12237,7 +12237,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t      && ((INTVAL (XEXP (op0, 1)) + ! equality_comparison_p)\n \t\t  < HOST_BITS_PER_WIDE_INT)\n \t      && (((unsigned HOST_WIDE_INT) const_op\n-\t\t   & (((unsigned HOST_WIDE_INT) 1 << INTVAL (XEXP (op0, 1)))\n+\t\t   & ((HOST_WIDE_INT_1U << INTVAL (XEXP (op0, 1)))\n \t\t      - 1)) == 0)\n \t      && mode_width <= HOST_BITS_PER_WIDE_INT\n \t      && (nonzero_bits (XEXP (op0, 0), mode)\n@@ -12260,7 +12260,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t      && mode_width <= HOST_BITS_PER_WIDE_INT)\n \t    {\n \t      op0 = simplify_and_const_int (NULL_RTX, mode, XEXP (op0, 0),\n-\t\t\t\t\t    ((unsigned HOST_WIDE_INT) 1\n+\t\t\t\t\t    (HOST_WIDE_INT_1U\n \t\t\t\t\t     << (mode_width - 1\n \t\t\t\t\t\t - INTVAL (XEXP (op0, 1)))));\n \t      code = (code == LT ? NE : EQ);\n@@ -12355,7 +12355,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t    {\n \t      unsigned HOST_WIDE_INT low_bits\n \t\t= (nonzero_bits (XEXP (op0, 0), mode)\n-\t\t   & (((unsigned HOST_WIDE_INT) 1\n+\t\t   & ((HOST_WIDE_INT_1U\n \t\t       << INTVAL (XEXP (op0, 1))) - 1));\n \t      if (low_bits == 0 || !equality_comparison_p)\n \t\t{\n@@ -12369,7 +12369,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t\t      && (code == GT || code == GTU\n \t\t\t  || code == LE || code == LEU))\n \t\t    const_op\n-\t\t      |= (((HOST_WIDE_INT) 1 << INTVAL (XEXP (op0, 1))) - 1);\n+\t\t      |= ((HOST_WIDE_INT_1 << INTVAL (XEXP (op0, 1))) - 1);\n \t\t  op1 = GEN_INT (const_op);\n \t\t  op0 = XEXP (op0, 0);\n \t\t  continue;\n@@ -12475,7 +12475,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t      && HWI_COMPUTABLE_MODE_P (mode))\n \t    {\n \t      unsigned HOST_WIDE_INT sign\n-\t\t= (unsigned HOST_WIDE_INT) 1 << (GET_MODE_BITSIZE (mode) - 1);\n+\t\t= HOST_WIDE_INT_1U << (GET_MODE_BITSIZE (mode) - 1);\n \t      op0 = simplify_gen_binary (AND, tmode,\n \t\t\t\t\t gen_lowpart (tmode, op0),\n \t\t\t\t\t gen_int_mode (sign, tmode));"}, {"sha": "6a5ccb5f309d5c62f384ef3a5f48727c8b441af5", "filename": "gcc/cse.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=fecfbfa4a290992437a99977381e29815ed9199d", "patch": "@@ -3558,7 +3558,7 @@ fold_rtx (rtx x, rtx_insn *insn)\n \t\t instead we test for the problematic value in a more direct\n \t\t manner and hope the Sun compilers get it correct.  */\n \t      && INTVAL (const_arg1) !=\n-\t        ((HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT - 1))\n+\t        (HOST_WIDE_INT_1 << (HOST_BITS_PER_WIDE_INT - 1))\n \t      && REG_P (folded_arg1))\n \t    {\n \t      rtx new_const = GEN_INT (-INTVAL (const_arg1));\n@@ -4567,7 +4567,7 @@ cse_insn (rtx_insn *insn)\n \t  if (INTVAL (width) == HOST_BITS_PER_WIDE_INT)\n \t    mask = ~(HOST_WIDE_INT) 0;\n \t  else\n-\t    mask = ((HOST_WIDE_INT) 1 << INTVAL (width)) - 1;\n+\t    mask = (HOST_WIDE_INT_1 << INTVAL (width)) - 1;\n \t  val = (val >> shift) & mask;\n \t  src_eqv = GEN_INT (val);\n \t}\n@@ -4665,7 +4665,7 @@ cse_insn (rtx_insn *insn)\n \t      && INTVAL (width) < HOST_BITS_PER_WIDE_INT\n \t      && (INTVAL (src) & ((HOST_WIDE_INT) (-1) << INTVAL (width))))\n \t    src_folded\n-\t      = GEN_INT (INTVAL (src) & (((HOST_WIDE_INT) 1\n+\t      = GEN_INT (INTVAL (src) & ((HOST_WIDE_INT_1\n \t\t\t\t\t  << INTVAL (width)) - 1));\n \t}\n #endif\n@@ -5235,7 +5235,7 @@ cse_insn (rtx_insn *insn)\n \t\t  if (INTVAL (width) == HOST_BITS_PER_WIDE_INT)\n \t\t    mask = ~(HOST_WIDE_INT) 0;\n \t\t  else\n-\t\t    mask = ((HOST_WIDE_INT) 1 << INTVAL (width)) - 1;\n+\t\t    mask = (HOST_WIDE_INT_1 << INTVAL (width)) - 1;\n \t\t  val &= ~(mask << shift);\n \t\t  val |= (INTVAL (trial) & mask) << shift;\n \t\t  val = trunc_int_for_mode (val, GET_MODE (dest_reg));"}, {"sha": "58f1e03e41b376c6ec70f3a768cfde53cb86e026", "filename": "gcc/dojump.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=fecfbfa4a290992437a99977381e29815ed9199d", "patch": "@@ -575,7 +575,7 @@ do_jump (tree exp, rtx_code_label *if_false_label,\n \t\t\t\t\t  TREE_INT_CST_LOW (shift)))\n \t\t{\n \t\t  unsigned HOST_WIDE_INT mask\n-\t\t    = (unsigned HOST_WIDE_INT) 1 << TREE_INT_CST_LOW (shift);\n+\t\t    = HOST_WIDE_INT_1U << TREE_INT_CST_LOW (shift);\n \t\t  do_jump (build2 (BIT_AND_EXPR, argtype, arg,\n \t\t\t\t   build_int_cstu (argtype, mask)),\n \t\t\t   clr_label, set_label, setclr_prob);"}, {"sha": "8a273907a6fd2538282df1c2b3427ac38608c17e", "filename": "gcc/double-int.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fdouble-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fdouble-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.c?ref=fecfbfa4a290992437a99977381e29815ed9199d", "patch": "@@ -65,10 +65,10 @@ static int div_and_round_double (unsigned, int, unsigned HOST_WIDE_INT,\n    number.  The value of the word is LOWPART + HIGHPART * BASE.  */\n \n #define LOWPART(x) \\\n-  ((x) & (((unsigned HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2)) - 1))\n+  ((x) & ((HOST_WIDE_INT_1U << (HOST_BITS_PER_WIDE_INT / 2)) - 1))\n #define HIGHPART(x) \\\n   ((unsigned HOST_WIDE_INT) (x) >> HOST_BITS_PER_WIDE_INT / 2)\n-#define BASE ((unsigned HOST_WIDE_INT) 1 << HOST_BITS_PER_WIDE_INT / 2)\n+#define BASE (HOST_WIDE_INT_1U << HOST_BITS_PER_WIDE_INT / 2)\n \n /* Unpack a two-word integer into 4 words.\n    LOW and HI are the integer, as two `HOST_WIDE_INT' pieces.\n@@ -546,7 +546,7 @@ div_and_round_double (unsigned code, int uns,\n       if (quo_neg && (*lrem != 0 || *hrem != 0))   /* ratio < 0 && rem != 0 */\n \t{\n \t  /* quo = quo - 1;  */\n-\t  add_double (*lquo, *hquo, (HOST_WIDE_INT) -1, (HOST_WIDE_INT)  -1,\n+\t  add_double (*lquo, *hquo, HOST_WIDE_INT_M1, HOST_WIDE_INT_M1,\n \t\t      lquo, hquo);\n \t}\n       else\n@@ -557,7 +557,7 @@ div_and_round_double (unsigned code, int uns,\n     case CEIL_MOD_EXPR:\t\t/* round toward positive infinity */\n       if (!quo_neg && (*lrem != 0 || *hrem != 0))  /* ratio > 0 && rem != 0 */\n \t{\n-\t  add_double (*lquo, *hquo, (HOST_WIDE_INT) 1, (HOST_WIDE_INT) 0,\n+\t  add_double (*lquo, *hquo, HOST_WIDE_INT_1, (HOST_WIDE_INT) 0,\n \t\t      lquo, hquo);\n \t}\n       else\n@@ -590,10 +590,10 @@ div_and_round_double (unsigned code, int uns,\n \t    if (quo_neg)\n \t      /* quo = quo - 1;  */\n \t      add_double (*lquo, *hquo,\n-\t\t\t  (HOST_WIDE_INT) -1, (HOST_WIDE_INT) -1, lquo, hquo);\n+\t\t\t  HOST_WIDE_INT_M1, HOST_WIDE_INT_M1, lquo, hquo);\n \t    else\n \t      /* quo = quo + 1; */\n-\t      add_double (*lquo, *hquo, (HOST_WIDE_INT) 1, (HOST_WIDE_INT) 0,\n+\t      add_double (*lquo, *hquo, HOST_WIDE_INT_1, (HOST_WIDE_INT) 0,\n \t\t\t  lquo, hquo);\n \t  }\n \telse\n@@ -1058,9 +1058,9 @@ double_int::set_bit (unsigned bitpos) const\n {\n   double_int a = *this;\n   if (bitpos < HOST_BITS_PER_WIDE_INT)\n-    a.low |= (unsigned HOST_WIDE_INT) 1 << bitpos;\n+    a.low |= HOST_WIDE_INT_1U << bitpos;\n   else\n-    a.high |= (HOST_WIDE_INT) 1 <<  (bitpos - HOST_BITS_PER_WIDE_INT);\n+    a.high |= HOST_WIDE_INT_1 <<  (bitpos - HOST_BITS_PER_WIDE_INT);\n  \n   return a;\n }"}, {"sha": "b300fb77c1fa8a0c50d7850b21963c092b876644", "filename": "gcc/dse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=fecfbfa4a290992437a99977381e29815ed9199d", "patch": "@@ -1201,7 +1201,7 @@ set_position_unneeded (store_info *s_info, int pos)\n     }\n   else\n     s_info->positions_needed.small_bitmask\n-      &= ~(((unsigned HOST_WIDE_INT) 1) << pos);\n+      &= ~(HOST_WIDE_INT_1U << pos);\n }\n \n /* Mark the whole store S_INFO as unneeded.  */\n@@ -1744,7 +1744,7 @@ get_stored_val (store_info *store_info, machine_mode read_mode,\n \t{\n \t  unsigned HOST_WIDE_INT c\n \t    = INTVAL (store_info->rhs)\n-\t      & (((HOST_WIDE_INT) 1 << BITS_PER_UNIT) - 1);\n+\t      & ((HOST_WIDE_INT_1 << BITS_PER_UNIT) - 1);\n \t  int shift = BITS_PER_UNIT;\n \t  while (shift < HOST_BITS_PER_WIDE_INT)\n \t    {"}, {"sha": "9da2b3bf4d40d778f0e490c0d3f1c60645c1d6de", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=fecfbfa4a290992437a99977381e29815ed9199d", "patch": "@@ -12976,7 +12976,7 @@ clz_loc_descriptor (rtx rtl, machine_mode mode,\n   if (GET_CODE (rtl) != CLZ)\n     msb = const1_rtx;\n   else if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n-    msb = GEN_INT ((unsigned HOST_WIDE_INT) 1\n+    msb = GEN_INT (HOST_WIDE_INT_1U\n \t\t   << (GET_MODE_BITSIZE (mode) - 1));\n   else\n     msb = immed_wide_int_const"}, {"sha": "0b0abbcf2837eca640d51373a633f67472254a43", "filename": "gcc/expmed.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=fecfbfa4a290992437a99977381e29815ed9199d", "patch": "@@ -85,7 +85,7 @@ mask_rtx (machine_mode mode, int bitpos, int bitsize, bool complement)\n \n /* Test whether a value is zero of a power of two.  */\n #define EXACT_POWER_OF_2_OR_ZERO_P(x) \\\n-  (((x) & ((x) - (unsigned HOST_WIDE_INT) 1)) == 0)\n+  (((x) & ((x) - HOST_WIDE_INT_1U)) == 0)\n \n struct init_expmed_rtl\n {\n@@ -235,7 +235,7 @@ init_expmed (void)\n   memset (&all, 0, sizeof all);\n   for (m = 1; m < MAX_BITS_PER_WORD; m++)\n     {\n-      all.pow2[m] = GEN_INT ((HOST_WIDE_INT) 1 << m);\n+      all.pow2[m] = GEN_INT (HOST_WIDE_INT_1 << m);\n       all.cint[m] = GEN_INT (m);\n     }\n \n@@ -1197,14 +1197,14 @@ store_fixed_bit_field_1 (rtx op0, unsigned HOST_WIDE_INT bitsize,\n       unsigned HOST_WIDE_INT v = UINTVAL (value);\n \n       if (bitsize < HOST_BITS_PER_WIDE_INT)\n-\tv &= ((unsigned HOST_WIDE_INT) 1 << bitsize) - 1;\n+\tv &= (HOST_WIDE_INT_1U << bitsize) - 1;\n \n       if (v == 0)\n \tall_zero = 1;\n       else if ((bitsize < HOST_BITS_PER_WIDE_INT\n-\t\t&& v == ((unsigned HOST_WIDE_INT) 1 << bitsize) - 1)\n+\t\t&& v == (HOST_WIDE_INT_1U << bitsize) - 1)\n \t       || (bitsize == HOST_BITS_PER_WIDE_INT\n-\t\t   && v == (unsigned HOST_WIDE_INT) -1))\n+\t\t   && v == HOST_WIDE_INT_M1U))\n \tall_one = 1;\n \n       value = lshift_value (mode, v, bitnum);\n@@ -1349,7 +1349,7 @@ store_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \t  if (CONST_INT_P (value))\n \t    part = GEN_INT (((unsigned HOST_WIDE_INT) (INTVAL (value))\n \t\t\t     >> (bitsize - bitsdone - thissize))\n-\t\t\t    & (((HOST_WIDE_INT) 1 << thissize) - 1));\n+\t\t\t    & ((HOST_WIDE_INT_1 << thissize) - 1));\n           /* Likewise, but the source is little-endian.  */\n           else if (reverse)\n \t    part = extract_fixed_bit_field (word_mode, value, thissize,\n@@ -1372,7 +1372,7 @@ store_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \t  if (CONST_INT_P (value))\n \t    part = GEN_INT (((unsigned HOST_WIDE_INT) (INTVAL (value))\n \t\t\t     >> bitsdone)\n-\t\t\t    & (((HOST_WIDE_INT) 1 << thissize) - 1));\n+\t\t\t    & ((HOST_WIDE_INT_1 << thissize) - 1));\n \t  /* Likewise, but the source is big-endian.  */\n           else if (reverse)\n \t    part = extract_fixed_bit_field (word_mode, value, thissize,\n@@ -2805,7 +2805,7 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n     {\n       unsigned HOST_WIDE_INT d;\n \n-      d = ((unsigned HOST_WIDE_INT) 1 << m) + 1;\n+      d = (HOST_WIDE_INT_1U << m) + 1;\n       if (t % d == 0 && t > d && m < maxm\n \t  && (!cache_hit || cache_alg == alg_add_factor))\n \t{\n@@ -2835,7 +2835,7 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n \t  break;\n \t}\n \n-      d = ((unsigned HOST_WIDE_INT) 1 << m) - 1;\n+      d = (HOST_WIDE_INT_1U << m) - 1;\n       if (t % d == 0 && t > d && m < maxm\n \t  && (!cache_hit || cache_alg == alg_sub_factor))\n \t{\n@@ -3104,14 +3104,14 @@ expand_mult_const (machine_mode mode, rtx op0, HOST_WIDE_INT val,\n \t  tem = expand_shift (LSHIFT_EXPR, mode, op0, log, NULL_RTX, 0);\n \t  accum = force_operand (gen_rtx_PLUS (mode, accum, tem),\n \t\t\t\t add_target ? add_target : accum_target);\n-\t  val_so_far += (HOST_WIDE_INT) 1 << log;\n+\t  val_so_far += HOST_WIDE_INT_1 << log;\n \t  break;\n \n \tcase alg_sub_t_m2:\n \t  tem = expand_shift (LSHIFT_EXPR, mode, op0, log, NULL_RTX, 0);\n \t  accum = force_operand (gen_rtx_MINUS (mode, accum, tem),\n \t\t\t\t add_target ? add_target : accum_target);\n-\t  val_so_far -= (HOST_WIDE_INT) 1 << log;\n+\t  val_so_far -= HOST_WIDE_INT_1 << log;\n \t  break;\n \n \tcase alg_add_t2_m:\n@@ -3485,7 +3485,7 @@ choose_multiplier (unsigned HOST_WIDE_INT d, int n, int precision,\n   *lgup_ptr = lgup;\n   if (n < HOST_BITS_PER_WIDE_INT)\n     {\n-      unsigned HOST_WIDE_INT mask = ((unsigned HOST_WIDE_INT) 1 << n) - 1;\n+      unsigned HOST_WIDE_INT mask = (HOST_WIDE_INT_1U << n) - 1;\n       *multiplier_ptr = mhigh.to_uhwi () & mask;\n       return mhigh.to_uhwi () >= mask;\n     }\n@@ -3514,7 +3514,7 @@ invert_mod2n (unsigned HOST_WIDE_INT x, int n)\n \n   mask = (n == HOST_BITS_PER_WIDE_INT\n \t  ? ~(unsigned HOST_WIDE_INT) 0\n-\t  : ((unsigned HOST_WIDE_INT) 1 << n) - 1);\n+\t  : (HOST_WIDE_INT_1U << n) - 1);\n \n   while (nbit < n)\n     {\n@@ -3776,7 +3776,7 @@ expand_smod_pow2 (machine_mode mode, rtx op0, HOST_WIDE_INT d)\n \t\t\t\t      mode, 0, -1);\n       if (signmask)\n \t{\n-\t  HOST_WIDE_INT masklow = ((HOST_WIDE_INT) 1 << logd) - 1;\n+\t  HOST_WIDE_INT masklow = (HOST_WIDE_INT_1 << logd) - 1;\n \t  signmask = force_reg (mode, signmask);\n \t  shift = GEN_INT (GET_MODE_BITSIZE (mode) - logd);\n \n@@ -4180,7 +4180,7 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t\t    if (rem_flag)\n \t\t      {\n \t\t\tunsigned HOST_WIDE_INT mask\n-\t\t\t  = ((unsigned HOST_WIDE_INT) 1 << pre_shift) - 1;\n+\t\t\t  = (HOST_WIDE_INT_1U << pre_shift) - 1;\n \t\t\tremainder\n \t\t\t  = expand_binop (compute_mode, and_optab, op0,\n \t\t\t\t\t  gen_int_mode (mask, compute_mode),\n@@ -4194,7 +4194,7 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t\t  }\n \t\telse if (size <= HOST_BITS_PER_WIDE_INT)\n \t\t  {\n-\t\t    if (d >= ((unsigned HOST_WIDE_INT) 1 << (size - 1)))\n+\t\t    if (d >= (HOST_WIDE_INT_1U << (size - 1)))\n \t\t      {\n \t\t\t/* Most significant bit of divisor is set; emit an scc\n \t\t\t   insn.  */\n@@ -4315,7 +4315,7 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t\t  quotient = expand_unop (compute_mode, neg_optab, op0,\n \t\t\t\t\t  tquotient, 0);\n \t\telse if (HOST_BITS_PER_WIDE_INT >= size\n-\t\t\t && abs_d == (unsigned HOST_WIDE_INT) 1 << (size - 1))\n+\t\t\t && abs_d == HOST_WIDE_INT_1U << (size - 1))\n \t\t  {\n \t\t    /* This case is not handled correctly below.  */\n \t\t    quotient = emit_store_flag (tquotient, EQ, op0, op1,\n@@ -4365,7 +4365,7 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t\t      {\n \t\t\tinsn = get_last_insn ();\n \t\t\tif (insn != last\n-\t\t\t    && abs_d < ((unsigned HOST_WIDE_INT) 1\n+\t\t\t    && abs_d < (HOST_WIDE_INT_1U\n \t\t\t\t\t<< (HOST_BITS_PER_WIDE_INT - 1)))\n \t\t\t  set_dst_reg_note (insn, REG_EQUAL,\n \t\t\t\t\t    gen_rtx_DIV (compute_mode, op0,\n@@ -4382,7 +4382,7 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t\t  {\n \t\t    choose_multiplier (abs_d, size, size - 1,\n \t\t\t\t       &ml, &post_shift, &lgup);\n-\t\t    if (ml < (unsigned HOST_WIDE_INT) 1 << (size - 1))\n+\t\t    if (ml < HOST_WIDE_INT_1U << (size - 1))\n \t\t      {\n \t\t\trtx t1, t2, t3;\n \n@@ -4488,7 +4488,7 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t\t    if (rem_flag)\n \t\t      {\n \t\t\tunsigned HOST_WIDE_INT mask\n-\t\t\t  = ((unsigned HOST_WIDE_INT) 1 << pre_shift) - 1;\n+\t\t\t  = (HOST_WIDE_INT_1U << pre_shift) - 1;\n \t\t\tremainder = expand_binop\n \t\t\t  (compute_mode, and_optab, op0,\n \t\t\t   gen_int_mode (mask, compute_mode),"}, {"sha": "1cb233caf797cc3b5d03415477d83ca5c50dbf1d", "filename": "gcc/expr.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=fecfbfa4a290992437a99977381e29815ed9199d", "patch": "@@ -4764,7 +4764,7 @@ optimize_bitfield_assignment_op (unsigned HOST_WIDE_INT bitsize,\n       binop = code == BIT_IOR_EXPR ? ior_optab : xor_optab;\n       if (bitpos + bitsize != str_bitsize)\n \t{\n-\t  rtx mask = gen_int_mode (((unsigned HOST_WIDE_INT) 1 << bitsize) - 1,\n+\t  rtx mask = gen_int_mode ((HOST_WIDE_INT_1U << bitsize) - 1,\n \t\t\t\t   str_mode);\n \t  value = expand_and (str_mode, value, mask, NULL_RTX);\n \t}\n@@ -7586,7 +7586,7 @@ highest_pow2_factor (const_tree exp)\n   int trailing_zeros = tree_ctz (exp);\n   if (trailing_zeros >= HOST_BITS_PER_WIDE_INT)\n     return BIGGEST_ALIGNMENT;\n-  ret = (unsigned HOST_WIDE_INT) 1 << trailing_zeros;\n+  ret = HOST_WIDE_INT_1U << trailing_zeros;\n   if (ret > BIGGEST_ALIGNMENT)\n     return BIGGEST_ALIGNMENT;\n   return ret;\n@@ -10324,7 +10324,7 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \n \t\t    if (TYPE_UNSIGNED (TREE_TYPE (field)))\n \t\t      {\n-\t\t\top1 = gen_int_mode (((HOST_WIDE_INT) 1 << bitsize) - 1,\n+\t\t\top1 = gen_int_mode ((HOST_WIDE_INT_1 << bitsize) - 1,\n \t\t\t\t\t    imode);\n \t\t\top0 = expand_and (imode, op0, op1, target);\n \t\t      }"}, {"sha": "c5d9a79ed28c8d346645eb2f4ca5d482a7f7e1d7", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=fecfbfa4a290992437a99977381e29815ed9199d", "patch": "@@ -2058,7 +2058,7 @@ fold_convert_const_fixed_from_int (tree type, const_tree arg1)\n \n   di.low = TREE_INT_CST_ELT (arg1, 0);\n   if (TREE_INT_CST_NUNITS (arg1) == 1)\n-    di.high = (HOST_WIDE_INT) di.low < 0 ? (HOST_WIDE_INT) -1 : 0;\n+    di.high = (HOST_WIDE_INT) di.low < 0 ? HOST_WIDE_INT_M1 : 0;\n   else\n     di.high = TREE_INT_CST_ELT (arg1, 1);\n "}, {"sha": "269ed8d45436e63ca5d1ba6ee76af29a72f93694", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=fecfbfa4a290992437a99977381e29815ed9199d", "patch": "@@ -233,7 +233,7 @@ frame_offset_overflow (HOST_WIDE_INT offset, tree func)\n {\n   unsigned HOST_WIDE_INT size = FRAME_GROWS_DOWNWARD ? -offset : offset;\n \n-  if (size > ((unsigned HOST_WIDE_INT) 1 << (GET_MODE_BITSIZE (Pmode) - 1))\n+  if (size > (HOST_WIDE_INT_1U << (GET_MODE_BITSIZE (Pmode) - 1))\n \t       /* Leave room for the fixed part of the frame.  */\n \t       - 64 * UNITS_PER_WORD)\n     {"}, {"sha": "30d5739f0e3815c9d03c76a67a55b5d716c97ed8", "filename": "gcc/fwprop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=fecfbfa4a290992437a99977381e29815ed9199d", "patch": "@@ -354,7 +354,7 @@ canonicalize_address (rtx x)\n \t  {\n \t    HOST_WIDE_INT shift = INTVAL (XEXP (x, 1));\n \t    PUT_CODE (x, MULT);\n-\t    XEXP (x, 1) = gen_int_mode ((HOST_WIDE_INT) 1 << shift,\n+\t    XEXP (x, 1) = gen_int_mode (HOST_WIDE_INT_1 << shift,\n \t\t\t\t\tGET_MODE (x));\n \t  }\n "}, {"sha": "59faae98244bd8bd527dce5a68caec2d086f9081", "filename": "gcc/genmodes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fgenmodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fgenmodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmodes.c?ref=fecfbfa4a290992437a99977381e29815ed9199d", "patch": "@@ -1410,7 +1410,7 @@ emit_mode_mask (void)\n #define MODE_MASK(m)                          \\\\\\n\\\n   ((m) >= HOST_BITS_PER_WIDE_INT)             \\\\\\n\\\n    ? ~(unsigned HOST_WIDE_INT) 0              \\\\\\n\\\n-   : ((unsigned HOST_WIDE_INT) 1 << (m)) - 1\\n\");\n+   : (HOST_WIDE_INT_1U << (m)) - 1\\n\");\n \n   for_all_modes (c, m)\n     if (m->precision != (unsigned int)-1)"}, {"sha": "b936c52e5c1ef958740005663824315da750a264", "filename": "gcc/hwint.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fhwint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fhwint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhwint.c?ref=fecfbfa4a290992437a99977381e29815ed9199d", "patch": "@@ -41,20 +41,20 @@ floor_log2 (unsigned HOST_WIDE_INT x)\n     return -1;\n \n   if (HOST_BITS_PER_WIDE_INT > 64)\n-    if (x >= (unsigned HOST_WIDE_INT) 1 << (t + 64))\n+    if (x >= HOST_WIDE_INT_1U << (t + 64))\n       t += 64;\n   if (HOST_BITS_PER_WIDE_INT > 32)\n-    if (x >= ((unsigned HOST_WIDE_INT) 1) << (t + 32))\n+    if (x >= HOST_WIDE_INT_1U << (t + 32))\n       t += 32;\n-  if (x >= ((unsigned HOST_WIDE_INT) 1) << (t + 16))\n+  if (x >= HOST_WIDE_INT_1U << (t + 16))\n     t += 16;\n-  if (x >= ((unsigned HOST_WIDE_INT) 1) << (t + 8))\n+  if (x >= HOST_WIDE_INT_1U << (t + 8))\n     t += 8;\n-  if (x >= ((unsigned HOST_WIDE_INT) 1) << (t + 4))\n+  if (x >= HOST_WIDE_INT_1U << (t + 4))\n     t += 4;\n-  if (x >= ((unsigned HOST_WIDE_INT) 1) << (t + 2))\n+  if (x >= HOST_WIDE_INT_1U << (t + 2))\n     t += 2;\n-  if (x >= ((unsigned HOST_WIDE_INT) 1) << (t + 1))\n+  if (x >= HOST_WIDE_INT_1U << (t + 1))\n     t += 1;\n \n   return t;"}, {"sha": "c816ed40f7b1097723787089c70134e81fbe860a", "filename": "gcc/hwint.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fhwint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fhwint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhwint.h?ref=fecfbfa4a290992437a99977381e29815ed9199d", "patch": "@@ -226,7 +226,7 @@ exact_log2 (unsigned HOST_WIDE_INT x)\n #endif /* GCC_VERSION >= 3004 */\n \n #define HOST_WIDE_INT_MIN (HOST_WIDE_INT) \\\n-  ((unsigned HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT - 1))\n+  (HOST_WIDE_INT_1U << (HOST_BITS_PER_WIDE_INT - 1))\n #define HOST_WIDE_INT_MAX (~(HOST_WIDE_INT_MIN))\n \n extern HOST_WIDE_INT abs_hwi (HOST_WIDE_INT);\n@@ -276,7 +276,7 @@ zext_hwi (unsigned HOST_WIDE_INT src, unsigned int prec)\n   else\n     {\n       gcc_checking_assert (prec < HOST_BITS_PER_WIDE_INT);\n-      return src & (((unsigned HOST_WIDE_INT) 1 << prec) - 1);\n+      return src & ((HOST_WIDE_INT_1U << prec) - 1);\n     }\n }\n "}, {"sha": "a92ab6dd1058634523dfb7e5f3bae2d573b03729", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=fecfbfa4a290992437a99977381e29815ed9199d", "patch": "@@ -2890,7 +2890,7 @@ noce_try_bitop (struct noce_if_info *if_info)\n       if (! rtx_equal_p (x, XEXP (a, 0))\n           || !CONST_INT_P (XEXP (a, 1))\n \t  || (INTVAL (XEXP (a, 1)) & GET_MODE_MASK (mode))\n-\t     != (unsigned HOST_WIDE_INT) 1 << bitnum)\n+\t     != HOST_WIDE_INT_1U << bitnum)\n         return FALSE;\n \n       /* if ((x & C) == 0) x |= C; is transformed to x |= C.   */\n@@ -2900,13 +2900,13 @@ noce_try_bitop (struct noce_if_info *if_info)\n       else if (code == NE)\n \t{\n \t  /* if ((x & C) == 0) x ^= C; is transformed to x |= C.   */\n-\t  result = gen_int_mode ((HOST_WIDE_INT) 1 << bitnum, mode);\n+\t  result = gen_int_mode (HOST_WIDE_INT_1 << bitnum, mode);\n \t  result = simplify_gen_binary (IOR, mode, x, result);\n \t}\n       else\n \t{\n \t  /* if ((x & C) != 0) x ^= C; is transformed to x &= ~C.  */\n-\t  result = gen_int_mode (~((HOST_WIDE_INT) 1 << bitnum), mode);\n+\t  result = gen_int_mode (~(HOST_WIDE_INT_1 << bitnum), mode);\n \t  result = simplify_gen_binary (AND, mode, x, result);\n \t}\n     }\n@@ -2916,7 +2916,7 @@ noce_try_bitop (struct noce_if_info *if_info)\n       if (! rtx_equal_p (x, XEXP (a, 0))\n \t  || !CONST_INT_P (XEXP (a, 1))\n \t  || (INTVAL (XEXP (a, 1)) & GET_MODE_MASK (mode))\n-\t     != (~((HOST_WIDE_INT) 1 << bitnum) & GET_MODE_MASK (mode)))\n+\t     != (~(HOST_WIDE_INT_1 << bitnum) & GET_MODE_MASK (mode)))\n         return FALSE;\n \n       /* if ((x & C) == 0) x &= ~C; is transformed to nothing.  */"}, {"sha": "c31151630ec96a28217ee59919098b1ef84f9b51", "filename": "gcc/loop-doloop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Floop-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Floop-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-doloop.c?ref=fecfbfa4a290992437a99977381e29815ed9199d", "patch": "@@ -688,7 +688,7 @@ doloop_optimize (struct loop *loop)\n \n   word_mode_size = GET_MODE_PRECISION (word_mode);\n   word_mode_max\n-\t  = ((unsigned HOST_WIDE_INT) 1 << (word_mode_size - 1) << 1) - 1;\n+\t  = (HOST_WIDE_INT_1U << (word_mode_size - 1) << 1) - 1;\n   if (! doloop_seq\n       && mode != word_mode\n       /* Before trying mode different from the one in that # of iterations is"}, {"sha": "d550a841d0695b9b55344e1655f6f9f3f79f1976", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=fecfbfa4a290992437a99977381e29815ed9199d", "patch": "@@ -777,7 +777,7 @@ canonicalize_address_mult (rtx x)\n \t{\n \t  HOST_WIDE_INT shift = INTVAL (XEXP (sub, 1));\n \t  PUT_CODE (sub, MULT);\n-\t  XEXP (sub, 1) = gen_int_mode ((HOST_WIDE_INT) 1 << shift,\n+\t  XEXP (sub, 1) = gen_int_mode (HOST_WIDE_INT_1 << shift,\n \t\t\t\t\tGET_MODE (sub));\n \t  iter.skip_subrtxes ();\n \t}"}, {"sha": "68cfd0ef9c8ddea4a3b59044bc038f763df9a99d", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=fecfbfa4a290992437a99977381e29815ed9199d", "patch": "@@ -1613,7 +1613,7 @@ implies_p (rtx a, rtx b)\n \t  && CONST_INT_P (XEXP (opb0, 1))\n \t  /* Avoid overflows.  */\n \t  && ((unsigned HOST_WIDE_INT) INTVAL (XEXP (opb0, 1))\n-\t      != ((unsigned HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT - 1)))\n+\t      != (HOST_WIDE_INT_1U << (HOST_BITS_PER_WIDE_INT - 1)))\n \t  && rtx_equal_p (XEXP (opb0, 0), op0))\n \treturn INTVAL (op1) == -INTVAL (XEXP (opb0, 1));\n       if (GET_CODE (b) == GEU\n@@ -1622,7 +1622,7 @@ implies_p (rtx a, rtx b)\n \t  && CONST_INT_P (XEXP (opb0, 1))\n \t  /* Avoid overflows.  */\n \t  && ((unsigned HOST_WIDE_INT) INTVAL (XEXP (opb0, 1))\n-\t      != ((unsigned HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT - 1)))\n+\t      != (HOST_WIDE_INT_1U << (HOST_BITS_PER_WIDE_INT - 1)))\n \t  && rtx_equal_p (XEXP (opb0, 0), op0))\n \treturn INTVAL (op1) == -INTVAL (XEXP (opb0, 1));\n     }"}, {"sha": "836f7d8f704bce683dfd5e026fbf9a47fddfc7be", "filename": "gcc/match.pd", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=fecfbfa4a290992437a99977381e29815ed9199d", "patch": "@@ -1461,7 +1461,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n        unsigned int prec;\n \n        if (shift == LSHIFT_EXPR)\n-\t zerobits = ((((unsigned HOST_WIDE_INT) 1) << shiftc) - 1);\n+\t zerobits = ((HOST_WIDE_INT_1U << shiftc) - 1);\n        else if (shift == RSHIFT_EXPR\n \t\t&& (TYPE_PRECISION (shift_type)\n \t\t    == GET_MODE_PRECISION (TYPE_MODE (shift_type))))\n@@ -1518,7 +1518,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n \t      mode's mask.  */\n \t   for (prec = BITS_PER_UNIT;\n \t        prec < HOST_BITS_PER_WIDE_INT; prec <<= 1)\n-\t     if (newmask == (((unsigned HOST_WIDE_INT) 1) << prec) - 1)\n+\t     if (newmask == (HOST_WIDE_INT_1U << prec) - 1)\n \t       break;\n \t }\n \t (if (prec < HOST_BITS_PER_WIDE_INT"}, {"sha": "51e10e217698ed9519b220b9db6af909c3061256", "filename": "gcc/optabs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=fecfbfa4a290992437a99977381e29815ed9199d", "patch": "@@ -4903,7 +4903,7 @@ expand_fix (rtx to, rtx from, int unsignedp)\n \t  expand_fix (to, target, 0);\n \t  target = expand_binop (GET_MODE (to), xor_optab, to,\n \t\t\t\t gen_int_mode\n-\t\t\t\t ((HOST_WIDE_INT) 1 << (bitsize - 1),\n+\t\t\t\t (HOST_WIDE_INT_1 << (bitsize - 1),\n \t\t\t\t  GET_MODE (to)),\n \t\t\t\t to, 1, OPTAB_LIB_WIDEN);\n "}, {"sha": "b009ed607edcd3984d134b69b6a633bd63f48c55", "filename": "gcc/real.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=fecfbfa4a290992437a99977381e29815ed9199d", "patch": "@@ -1395,7 +1395,7 @@ real_to_integer (const REAL_VALUE_TYPE *r)\n     case rvc_inf:\n     case rvc_nan:\n     overflow:\n-      i = (unsigned HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT - 1);\n+      i = HOST_WIDE_INT_1U << (HOST_BITS_PER_WIDE_INT - 1);\n       if (!r->sign)\n \ti--;\n       return i;\n@@ -4903,7 +4903,7 @@ real_powi (REAL_VALUE_TYPE *r, format_helper fmt,\n     neg = false;\n \n   t = *x;\n-  bit = (unsigned HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT - 1);\n+  bit = HOST_WIDE_INT_1U << (HOST_BITS_PER_WIDE_INT - 1);\n   for (i = 0; i < HOST_BITS_PER_WIDE_INT; i++)\n     {\n       if (init)"}, {"sha": "1945133baf67396a6c20545fcc1c3172a88f0589", "filename": "gcc/reload.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=fecfbfa4a290992437a99977381e29815ed9199d", "patch": "@@ -6750,7 +6750,7 @@ find_equiv_reg (rtx goal, rtx_insn *insn, enum reg_class rclass, int other,\n       if (NONJUMP_INSN_P (p)\n \t  /* If we don't want spill regs ...  */\n \t  && (! (reload_reg_p != 0\n-\t\t && reload_reg_p != (short *) (HOST_WIDE_INT) 1)\n+\t\t && reload_reg_p != (short *) HOST_WIDE_INT_1)\n \t      /* ... then ignore insns introduced by reload; they aren't\n \t\t useful and can cause results in reload_as_needed to be\n \t\t different from what they were when calculating the need for\n@@ -6883,7 +6883,7 @@ find_equiv_reg (rtx goal, rtx_insn *insn, enum reg_class rclass, int other,\n      (Now that insns introduced by reload are ignored above,\n      this case shouldn't happen, but I'm not positive.)  */\n \n-  if (reload_reg_p != 0 && reload_reg_p != (short *) (HOST_WIDE_INT) 1)\n+  if (reload_reg_p != 0 && reload_reg_p != (short *) HOST_WIDE_INT_1)\n     {\n       int i;\n       for (i = 0; i < valuenregs; ++i)"}, {"sha": "94453295063494c535f0047341b98855e5bd4053", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=fecfbfa4a290992437a99977381e29815ed9199d", "patch": "@@ -4381,7 +4381,7 @@ nonzero_bits1 (const_rtx x, machine_mode mode, const_rtx known_x,\n       /* If X is negative in MODE, sign-extend the value.  */\n       if (SHORT_IMMEDIATES_SIGN_EXTEND && INTVAL (x) > 0\n \t  && mode_width < BITS_PER_WORD\n-\t  && (UINTVAL (x) & ((unsigned HOST_WIDE_INT) 1 << (mode_width - 1)))\n+\t  && (UINTVAL (x) & (HOST_WIDE_INT_1U << (mode_width - 1)))\n \t     != 0)\n \treturn UINTVAL (x) | (HOST_WIDE_INT_M1U << mode_width);\n \n@@ -4513,9 +4513,9 @@ nonzero_bits1 (const_rtx x, machine_mode mode, const_rtx known_x,\n \tint low0 = floor_log2 (nz0 & -nz0);\n \tint low1 = floor_log2 (nz1 & -nz1);\n \tunsigned HOST_WIDE_INT op0_maybe_minusp\n-\t  = nz0 & ((unsigned HOST_WIDE_INT) 1 << sign_index);\n+\t  = nz0 & (HOST_WIDE_INT_1U << sign_index);\n \tunsigned HOST_WIDE_INT op1_maybe_minusp\n-\t  = nz1 & ((unsigned HOST_WIDE_INT) 1 << sign_index);\n+\t  = nz1 & (HOST_WIDE_INT_1U << sign_index);\n \tunsigned int result_width = mode_width;\n \tint result_low = 0;\n \n@@ -4561,17 +4561,17 @@ nonzero_bits1 (const_rtx x, machine_mode mode, const_rtx known_x,\n \t  }\n \n \tif (result_width < mode_width)\n-\t  nonzero &= ((unsigned HOST_WIDE_INT) 1 << result_width) - 1;\n+\t  nonzero &= (HOST_WIDE_INT_1U << result_width) - 1;\n \n \tif (result_low > 0)\n-\t  nonzero &= ~(((unsigned HOST_WIDE_INT) 1 << result_low) - 1);\n+\t  nonzero &= ~((HOST_WIDE_INT_1U << result_low) - 1);\n       }\n       break;\n \n     case ZERO_EXTRACT:\n       if (CONST_INT_P (XEXP (x, 1))\n \t  && INTVAL (XEXP (x, 1)) < HOST_BITS_PER_WIDE_INT)\n-\tnonzero &= ((unsigned HOST_WIDE_INT) 1 << INTVAL (XEXP (x, 1))) - 1;\n+\tnonzero &= (HOST_WIDE_INT_1U << INTVAL (XEXP (x, 1))) - 1;\n       break;\n \n     case SUBREG:\n@@ -4652,8 +4652,8 @@ nonzero_bits1 (const_rtx x, machine_mode mode, const_rtx known_x,\n \t      /* If the sign bit may have been nonzero before the shift, we\n \t\t need to mark all the places it could have been copied to\n \t\t by the shift as possibly nonzero.  */\n-\t      if (inner & ((unsigned HOST_WIDE_INT) 1 << (width - 1 - count)))\n-\t\tinner |= (((unsigned HOST_WIDE_INT) 1 << count) - 1)\n+\t      if (inner & (HOST_WIDE_INT_1U << (width - 1 - count)))\n+\t\tinner |= ((HOST_WIDE_INT_1U << count) - 1)\n \t\t\t   << (width - count);\n \t    }\n \t  else if (code == ASHIFT)\n@@ -4677,7 +4677,7 @@ nonzero_bits1 (const_rtx x, machine_mode mode, const_rtx known_x,\n \t that value, plus the number of bits in the mode minus one.  */\n       if (CLZ_DEFINED_VALUE_AT_ZERO (mode, nonzero))\n \tnonzero\n-\t  |= ((unsigned HOST_WIDE_INT) 1 << (floor_log2 (mode_width))) - 1;\n+\t  |= (HOST_WIDE_INT_1U << (floor_log2 (mode_width))) - 1;\n       else\n \tnonzero = -1;\n       break;\n@@ -4687,14 +4687,14 @@ nonzero_bits1 (const_rtx x, machine_mode mode, const_rtx known_x,\n \t that value, plus the number of bits in the mode minus one.  */\n       if (CTZ_DEFINED_VALUE_AT_ZERO (mode, nonzero))\n \tnonzero\n-\t  |= ((unsigned HOST_WIDE_INT) 1 << (floor_log2 (mode_width))) - 1;\n+\t  |= (HOST_WIDE_INT_1U << (floor_log2 (mode_width))) - 1;\n       else\n \tnonzero = -1;\n       break;\n \n     case CLRSB:\n       /* This is at most the number of bits in the mode minus 1.  */\n-      nonzero = ((unsigned HOST_WIDE_INT) 1 << (floor_log2 (mode_width))) - 1;\n+      nonzero = (HOST_WIDE_INT_1U << (floor_log2 (mode_width))) - 1;\n       break;\n \n     case PARITY:\n@@ -4908,7 +4908,7 @@ num_sign_bit_copies1 (const_rtx x, machine_mode mode, const_rtx known_x,\n \t Then see how many zero bits we have.  */\n       nonzero = UINTVAL (x) & GET_MODE_MASK (mode);\n       if (bitwidth <= HOST_BITS_PER_WIDE_INT\n-\t  && (nonzero & ((unsigned HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0)\n+\t  && (nonzero & (HOST_WIDE_INT_1U << (bitwidth - 1))) != 0)\n \tnonzero = (~nonzero) & GET_MODE_MASK (mode);\n \n       return (nonzero == 0 ? bitwidth : bitwidth - floor_log2 (nonzero) - 1);\n@@ -5008,7 +5008,7 @@ num_sign_bit_copies1 (const_rtx x, machine_mode mode, const_rtx known_x,\n \treturn bitwidth;\n \n       if (num0 > 1\n-\t  && (((unsigned HOST_WIDE_INT) 1 << (bitwidth - 1)) & nonzero))\n+\t  && ((HOST_WIDE_INT_1U << (bitwidth - 1)) & nonzero))\n \tnum0--;\n \n       return num0;\n@@ -5030,7 +5030,7 @@ num_sign_bit_copies1 (const_rtx x, machine_mode mode, const_rtx known_x,\n \t  && bitwidth <= HOST_BITS_PER_WIDE_INT\n \t  && CONST_INT_P (XEXP (x, 1))\n \t  && (UINTVAL (XEXP (x, 1))\n-\t      & ((unsigned HOST_WIDE_INT) 1 << (bitwidth - 1))) == 0)\n+\t      & (HOST_WIDE_INT_1U << (bitwidth - 1))) == 0)\n \treturn num1;\n \n       /* Similarly for IOR when setting high-order bits.  */\n@@ -5039,7 +5039,7 @@ num_sign_bit_copies1 (const_rtx x, machine_mode mode, const_rtx known_x,\n \t  && bitwidth <= HOST_BITS_PER_WIDE_INT\n \t  && CONST_INT_P (XEXP (x, 1))\n \t  && (UINTVAL (XEXP (x, 1))\n-\t      & ((unsigned HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0)\n+\t      & (HOST_WIDE_INT_1U << (bitwidth - 1))) != 0)\n \treturn num1;\n \n       return MIN (num0, num1);\n@@ -5054,7 +5054,7 @@ num_sign_bit_copies1 (const_rtx x, machine_mode mode, const_rtx known_x,\n \t  && bitwidth <= HOST_BITS_PER_WIDE_INT)\n \t{\n \t  nonzero = nonzero_bits (XEXP (x, 0), mode);\n-\t  if ((((unsigned HOST_WIDE_INT) 1 << (bitwidth - 1)) & nonzero) == 0)\n+\t  if (((HOST_WIDE_INT_1U << (bitwidth - 1)) & nonzero) == 0)\n \t    return (nonzero == 1 || nonzero == 0 ? bitwidth\n \t\t    : bitwidth - floor_log2 (nonzero) - 1);\n \t}\n@@ -5082,9 +5082,9 @@ num_sign_bit_copies1 (const_rtx x, machine_mode mode, const_rtx known_x,\n       if (result > 0\n \t  && (bitwidth > HOST_BITS_PER_WIDE_INT\n \t      || (((nonzero_bits (XEXP (x, 0), mode)\n-\t\t    & ((unsigned HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0)\n+\t\t    & (HOST_WIDE_INT_1U << (bitwidth - 1))) != 0)\n \t\t  && ((nonzero_bits (XEXP (x, 1), mode)\n-\t\t       & ((unsigned HOST_WIDE_INT) 1 << (bitwidth - 1)))\n+\t\t       & (HOST_WIDE_INT_1U << (bitwidth - 1)))\n \t\t      != 0))))\n \tresult--;\n \n@@ -5097,7 +5097,7 @@ num_sign_bit_copies1 (const_rtx x, machine_mode mode, const_rtx known_x,\n       if (bitwidth > HOST_BITS_PER_WIDE_INT)\n \treturn 1;\n       else if ((nonzero_bits (XEXP (x, 0), mode)\n-\t\t& ((unsigned HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0)\n+\t\t& (HOST_WIDE_INT_1U << (bitwidth - 1))) != 0)\n \treturn 1;\n       else\n \treturn cached_num_sign_bit_copies (XEXP (x, 0), mode,\n@@ -5110,7 +5110,7 @@ num_sign_bit_copies1 (const_rtx x, machine_mode mode, const_rtx known_x,\n       if (bitwidth > HOST_BITS_PER_WIDE_INT)\n \treturn 1;\n       else if ((nonzero_bits (XEXP (x, 1), mode)\n-\t\t& ((unsigned HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0)\n+\t\t& (HOST_WIDE_INT_1U << (bitwidth - 1))) != 0)\n \treturn 1;\n       else\n \treturn cached_num_sign_bit_copies (XEXP (x, 1), mode,\n@@ -5125,7 +5125,7 @@ num_sign_bit_copies1 (const_rtx x, machine_mode mode, const_rtx known_x,\n       if (result > 1\n \t  && (bitwidth > HOST_BITS_PER_WIDE_INT\n \t      || (nonzero_bits (XEXP (x, 1), mode)\n-\t\t  & ((unsigned HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0))\n+\t\t  & (HOST_WIDE_INT_1U << (bitwidth - 1))) != 0))\n \tresult--;\n \n       return result;\n@@ -5136,7 +5136,7 @@ num_sign_bit_copies1 (const_rtx x, machine_mode mode, const_rtx known_x,\n       if (result > 1\n \t  && (bitwidth > HOST_BITS_PER_WIDE_INT\n \t      || (nonzero_bits (XEXP (x, 1), mode)\n-\t\t  & ((unsigned HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0))\n+\t\t  & (HOST_WIDE_INT_1U << (bitwidth - 1))) != 0))\n \tresult--;\n \n       return result;\n@@ -5180,7 +5180,7 @@ num_sign_bit_copies1 (const_rtx x, machine_mode mode, const_rtx known_x,\n \t Then see how many zero bits we have.  */\n       nonzero = STORE_FLAG_VALUE;\n       if (bitwidth <= HOST_BITS_PER_WIDE_INT\n-\t  && (nonzero & ((unsigned HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0)\n+\t  && (nonzero & (HOST_WIDE_INT_1U << (bitwidth - 1))) != 0)\n \tnonzero = (~nonzero) & GET_MODE_MASK (mode);\n \n       return (nonzero == 0 ? bitwidth : bitwidth - floor_log2 (nonzero) - 1);\n@@ -5199,7 +5199,7 @@ num_sign_bit_copies1 (const_rtx x, machine_mode mode, const_rtx known_x,\n     return 1;\n \n   nonzero = nonzero_bits (x, mode);\n-  return nonzero & ((unsigned HOST_WIDE_INT) 1 << (bitwidth - 1))\n+  return nonzero & (HOST_WIDE_INT_1U << (bitwidth - 1))\n \t ? 1 : bitwidth - floor_log2 (nonzero) - 1;\n }\n \n@@ -5511,7 +5511,7 @@ canonicalize_condition (rtx_insn *insn, rtx cond, int reverse,\n \t   BITS_PER_WORD to HOST_BITS_PER_WIDE_INT */\n \tcase GE:\n \t  if ((const_val & max_val)\n-\t      != ((unsigned HOST_WIDE_INT) 1\n+\t      != (HOST_WIDE_INT_1U\n \t\t  << (GET_MODE_PRECISION (GET_MODE (op0)) - 1)))\n \t    code = GT, op1 = gen_int_mode (const_val - 1, GET_MODE (op0));\n \t  break;\n@@ -6290,7 +6290,7 @@ get_index_scale (const struct address_info *info)\n   if (GET_CODE (index) == ASHIFT\n       && CONST_INT_P (XEXP (index, 1))\n       && info->index_term == &XEXP (index, 0))\n-    return (HOST_WIDE_INT) 1 << INTVAL (XEXP (index, 1));\n+    return HOST_WIDE_INT_1 << INTVAL (XEXP (index, 1));\n \n   if (info->index == info->index_term)\n     return 1;"}, {"sha": "4354b5bcd333f8e652cdf1a516582acfcb085de6", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=fecfbfa4a290992437a99977381e29815ed9199d", "patch": "@@ -40,7 +40,7 @@ along with GCC; see the file COPYING3.  If not see\n    occasionally need to sign extend from low to high as if low were a\n    signed wide int.  */\n #define HWI_SIGN_EXTEND(low) \\\n- ((((HOST_WIDE_INT) low) < 0) ? ((HOST_WIDE_INT) -1) : ((HOST_WIDE_INT) 0))\n+ ((((HOST_WIDE_INT) low) < 0) ? HOST_WIDE_INT_M1 : ((HOST_WIDE_INT) 0))\n \n static rtx neg_const_int (machine_mode, const_rtx);\n static bool plus_minus_operand_p (const_rtx);\n@@ -111,8 +111,8 @@ mode_signbit_p (machine_mode mode, const_rtx x)\n     return false;\n \n   if (width < HOST_BITS_PER_WIDE_INT)\n-    val &= ((unsigned HOST_WIDE_INT) 1 << width) - 1;\n-  return val == ((unsigned HOST_WIDE_INT) 1 << (width - 1));\n+    val &= (HOST_WIDE_INT_1U << width) - 1;\n+  return val == (HOST_WIDE_INT_1U << (width - 1));\n }\n \n /* Test whether VAL is equal to the most significant bit of mode MODE\n@@ -132,7 +132,7 @@ val_signbit_p (machine_mode mode, unsigned HOST_WIDE_INT val)\n     return false;\n \n   val &= GET_MODE_MASK (mode);\n-  return val == ((unsigned HOST_WIDE_INT) 1 << (width - 1));\n+  return val == (HOST_WIDE_INT_1U << (width - 1));\n }\n \n /* Test whether the most significant bit of mode MODE is set in VAL.\n@@ -149,7 +149,7 @@ val_signbit_known_set_p (machine_mode mode, unsigned HOST_WIDE_INT val)\n   if (width == 0 || width > HOST_BITS_PER_WIDE_INT)\n     return false;\n \n-  val &= (unsigned HOST_WIDE_INT) 1 << (width - 1);\n+  val &= HOST_WIDE_INT_1U << (width - 1);\n   return val != 0;\n }\n \n@@ -167,7 +167,7 @@ val_signbit_known_clear_p (machine_mode mode, unsigned HOST_WIDE_INT val)\n   if (width == 0 || width > HOST_BITS_PER_WIDE_INT)\n     return false;\n \n-  val &= (unsigned HOST_WIDE_INT) 1 << (width - 1);\n+  val &= HOST_WIDE_INT_1U << (width - 1);\n   return val == 0;\n }\n \f\n@@ -5188,7 +5188,7 @@ simplify_const_relational_operation (enum rtx_code code,\n \t      int sign_bitnum = GET_MODE_PRECISION (mode) - 1;\n \t      int has_sign = (HOST_BITS_PER_WIDE_INT >= sign_bitnum\n \t\t\t      && (UINTVAL (inner_const)\n-\t\t\t\t  & ((unsigned HOST_WIDE_INT) 1\n+\t\t\t\t  & (HOST_WIDE_INT_1U\n \t\t\t\t     << sign_bitnum)));\n \n \t      switch (code)\n@@ -5376,12 +5376,12 @@ simplify_ternary_operation (enum rtx_code code, machine_mode mode,\n \t  if (HOST_BITS_PER_WIDE_INT != op1val)\n \t    {\n \t      /* First zero-extend.  */\n-\t      val &= ((unsigned HOST_WIDE_INT) 1 << op1val) - 1;\n+\t      val &= (HOST_WIDE_INT_1U << op1val) - 1;\n \t      /* If desired, propagate sign bit.  */\n \t      if (code == SIGN_EXTRACT\n-\t\t  && (val & ((unsigned HOST_WIDE_INT) 1 << (op1val - 1)))\n+\t\t  && (val & (HOST_WIDE_INT_1U << (op1val - 1)))\n \t\t     != 0)\n-\t\tval |= ~ (((unsigned HOST_WIDE_INT) 1 << op1val) - 1);\n+\t\tval |= ~ ((HOST_WIDE_INT_1U << op1val) - 1);\n \t    }\n \n \t  return gen_int_mode (val, mode);\n@@ -5518,7 +5518,7 @@ simplify_ternary_operation (enum rtx_code code, machine_mode mode,\n \t  if (n_elts == HOST_BITS_PER_WIDE_INT)\n \t    mask = -1;\n \t  else\n-\t    mask = ((unsigned HOST_WIDE_INT) 1 << n_elts) - 1;\n+\t    mask = (HOST_WIDE_INT_1U << n_elts) - 1;\n \n \t  if (!(sel & mask) && !side_effects_p (op0))\n \t    return op1;\n@@ -5534,7 +5534,7 @@ simplify_ternary_operation (enum rtx_code code, machine_mode mode,\n \t      unsigned int i;\n \n \t      for (i = 0; i < n_elts; i++)\n-\t\tRTVEC_ELT (v, i) = ((sel & ((unsigned HOST_WIDE_INT) 1 << i))\n+\t\tRTVEC_ELT (v, i) = ((sel & (HOST_WIDE_INT_1U << i))\n \t\t\t\t    ? CONST_VECTOR_ELT (trueop0, i)\n \t\t\t\t    : CONST_VECTOR_ELT (trueop1, i));\n \t      return gen_rtx_CONST_VECTOR (mode, v);"}, {"sha": "4ada959a45a3f93917fe186cf4d7647854f76171", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=fecfbfa4a290992437a99977381e29815ed9199d", "patch": "@@ -2899,13 +2899,13 @@ get_mode_bounds (machine_mode mode, int sign,\n     }\n   else if (sign)\n     {\n-      min_val = -((unsigned HOST_WIDE_INT) 1 << (size - 1));\n-      max_val = ((unsigned HOST_WIDE_INT) 1 << (size - 1)) - 1;\n+      min_val = -(HOST_WIDE_INT_1U << (size - 1));\n+      max_val = (HOST_WIDE_INT_1U << (size - 1)) - 1;\n     }\n   else\n     {\n       min_val = 0;\n-      max_val = ((unsigned HOST_WIDE_INT) 1 << (size - 1) << 1) - 1;\n+      max_val = (HOST_WIDE_INT_1U << (size - 1) << 1) - 1;\n     }\n \n   *mmin = gen_int_mode (min_val, target_mode);"}, {"sha": "b0bb3ecd309bfa076817d7305197d4dd1cf88630", "filename": "gcc/toplev.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=fecfbfa4a290992437a99977381e29815ed9199d", "patch": "@@ -561,14 +561,14 @@ compile_file (void)\n #if defined ASM_OUTPUT_ALIGNED_DECL_COMMON\n       ASM_OUTPUT_ALIGNED_DECL_COMMON (asm_out_file, NULL_TREE,\n \t\t\t\t      \"__gnu_lto_v1\",\n-\t\t\t\t      (unsigned HOST_WIDE_INT) 1, 8);\n+\t\t\t\t      HOST_WIDE_INT_1U, 8);\n #elif defined ASM_OUTPUT_ALIGNED_COMMON\n       ASM_OUTPUT_ALIGNED_COMMON (asm_out_file, \"__gnu_lto_v1\",\n-\t\t\t\t (unsigned HOST_WIDE_INT) 1, 8);\n+\t\t\t\t HOST_WIDE_INT_1U, 8);\n #else\n       ASM_OUTPUT_COMMON (asm_out_file, \"__gnu_lto_v1\",\n-\t\t\t (unsigned HOST_WIDE_INT) 1,\n-\t\t\t (unsigned HOST_WIDE_INT) 1);\n+\t\t\t HOST_WIDE_INT_1U,\n+\t\t\t HOST_WIDE_INT_1U);\n #endif\n     }\n \n@@ -578,14 +578,14 @@ compile_file (void)\n     {\n #if defined ASM_OUTPUT_ALIGNED_DECL_COMMON\n       ASM_OUTPUT_ALIGNED_DECL_COMMON (asm_out_file, NULL_TREE, \"__gnu_lto_slim\",\n-\t\t\t\t      (unsigned HOST_WIDE_INT) 1, 8);\n+\t\t\t\t      HOST_WIDE_INT_1U, 8);\n #elif defined ASM_OUTPUT_ALIGNED_COMMON\n       ASM_OUTPUT_ALIGNED_COMMON (asm_out_file, \"__gnu_lto_slim\",\n-\t\t\t\t (unsigned HOST_WIDE_INT) 1, 8);\n+\t\t\t\t HOST_WIDE_INT_1U, 8);\n #else\n       ASM_OUTPUT_COMMON (asm_out_file, \"__gnu_lto_slim\",\n-\t\t\t (unsigned HOST_WIDE_INT) 1,\n-\t\t\t (unsigned HOST_WIDE_INT) 1);\n+\t\t\t HOST_WIDE_INT_1U,\n+\t\t\t HOST_WIDE_INT_1U);\n #endif\n     }\n "}, {"sha": "ed6bac990f412cfda66d7bbd065e46813a66decc", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=fecfbfa4a290992437a99977381e29815ed9199d", "patch": "@@ -2488,14 +2488,14 @@ compute_max_addr_offset (struct iv_use *use)\n \n   for (i = width; i > 0; i--)\n     {\n-      off = ((unsigned HOST_WIDE_INT) 1 << i) - 1;\n+      off = (HOST_WIDE_INT_1U << i) - 1;\n       XEXP (addr, 1) = gen_int_mode (off, addr_mode);\n       if (memory_address_addr_space_p (mem_mode, addr, as))\n \tbreak;\n \n       /* For some strict-alignment targets, the offset must be naturally\n \t aligned.  Try an aligned offset if mem_mode is not QImode.  */\n-      off = ((unsigned HOST_WIDE_INT) 1 << i);\n+      off = (HOST_WIDE_INT_1U << i);\n       if (off > GET_MODE_SIZE (mem_mode) && mem_mode != QImode)\n \t{\n \t  off -= GET_MODE_SIZE (mem_mode);\n@@ -4002,7 +4002,7 @@ get_address_cost (bool symbol_present, bool var_present,\n \n       for (i = width; i >= 0; i--)\n \t{\n-\t  off = -((unsigned HOST_WIDE_INT) 1 << i);\n+\t  off = -(HOST_WIDE_INT_1U << i);\n \t  XEXP (addr, 1) = gen_int_mode (off, address_mode);\n \t  if (memory_address_addr_space_p (mem_mode, addr, as))\n \t    break;\n@@ -4011,14 +4011,14 @@ get_address_cost (bool symbol_present, bool var_present,\n \n       for (i = width; i >= 0; i--)\n \t{\n-\t  off = ((unsigned HOST_WIDE_INT) 1 << i) - 1;\n+\t  off = (HOST_WIDE_INT_1U << i) - 1;\n \t  XEXP (addr, 1) = gen_int_mode (off, address_mode);\n \t  if (memory_address_addr_space_p (mem_mode, addr, as))\n \t    break;\n \t  /* For some strict-alignment targets, the offset must be naturally\n \t     aligned.  Try an aligned offset if mem_mode is not QImode.  */\n \t  off = mem_mode != QImode\n-\t\t? ((unsigned HOST_WIDE_INT) 1 << i)\n+\t\t? (HOST_WIDE_INT_1U << i)\n \t\t    - GET_MODE_SIZE (mem_mode)\n \t\t: 0;\n \t  if (off > 0)"}, {"sha": "5c4798ac2bff90500baedb0e057c0b6b6cc47e12", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=fecfbfa4a290992437a99977381e29815ed9199d", "patch": "@@ -474,7 +474,7 @@ expand_vector_divmod (gimple_stmt_iterator *gsi, tree type, tree op0,\n \t  unsigned HOST_WIDE_INT mh;\n \t  unsigned HOST_WIDE_INT d = TREE_INT_CST_LOW (cst) & mask;\n \n-\t  if (d >= ((unsigned HOST_WIDE_INT) 1 << (prec - 1)))\n+\t  if (d >= (HOST_WIDE_INT_1U << (prec - 1)))\n \t    /* FIXME: Can transform this into op0 >= op1 ? 1 : 0.  */\n \t    return NULL_TREE;\n \n@@ -558,7 +558,7 @@ expand_vector_divmod (gimple_stmt_iterator *gsi, tree type, tree op0,\n \t  /* n rem d = n rem -d */\n \t  if (code == TRUNC_MOD_EXPR && d < 0)\n \t    d = abs_d;\n-\t  else if (abs_d == (unsigned HOST_WIDE_INT) 1 << (prec - 1))\n+\t  else if (abs_d == HOST_WIDE_INT_1U << (prec - 1))\n \t    {\n \t      /* This case is not handled correctly below.  */\n \t      mode = -2;\n@@ -572,7 +572,7 @@ expand_vector_divmod (gimple_stmt_iterator *gsi, tree type, tree op0,\n \n \t  choose_multiplier (abs_d, prec, prec - 1, &ml,\n \t\t\t     &post_shift, &dummy_int);\n-\t  if (ml >= (unsigned HOST_WIDE_INT) 1 << (prec - 1))\n+\t  if (ml >= HOST_WIDE_INT_1U << (prec - 1))\n \t    {\n \t      this_mode = 4 + (d < 0);\n \t      ml |= (~(unsigned HOST_WIDE_INT) 0) << (prec - 1);\n@@ -640,7 +640,7 @@ expand_vector_divmod (gimple_stmt_iterator *gsi, tree type, tree op0,\n \t      cond = build2 (LT_EXPR, mask_type, op0, zero);\n \t      for (i = 0; i < nunits; i++)\n \t\tvec[i] = build_int_cst (TREE_TYPE (type),\n-\t\t\t\t\t((unsigned HOST_WIDE_INT) 1\n+\t\t\t\t\t(HOST_WIDE_INT_1U\n \t\t\t\t\t << shifts[i]) - 1);\n \t      cst = build_vector (type, vec);\n \t      addend = make_ssa_name (type);\n@@ -678,7 +678,7 @@ expand_vector_divmod (gimple_stmt_iterator *gsi, tree type, tree op0,\n \t  tree mask;\n \t  for (i = 0; i < nunits; i++)\n \t    vec[i] = build_int_cst (TREE_TYPE (type),\n-\t\t\t\t    ((unsigned HOST_WIDE_INT) 1\n+\t\t\t\t    (HOST_WIDE_INT_1U\n \t\t\t\t     << shifts[i]) - 1);\n \t  mask = build_vector (type, vec);\n \t  op = optab_for_tree_code (BIT_AND_EXPR, type, optab_default);"}, {"sha": "d78f92d2efbdef0db0d4f3fc57f02670a6c44c0d", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=fecfbfa4a290992437a99977381e29815ed9199d", "patch": "@@ -2724,7 +2724,7 @@ vect_recog_divmod_pattern (vec<gimple *> *stmts,\n \t\t\t\t  & GET_MODE_MASK (TYPE_MODE (itype)));\n       tree t1, t2, t3, t4;\n \n-      if (d >= ((unsigned HOST_WIDE_INT) 1 << (prec - 1)))\n+      if (d >= (HOST_WIDE_INT_1U << (prec - 1)))\n \t/* FIXME: Can transform this into oprnd0 >= oprnd1 ? 1 : 0.  */\n \treturn NULL;\n \n@@ -2853,12 +2853,12 @@ vect_recog_divmod_pattern (vec<gimple *> *stmts,\n \t  oprnd1 = build_int_cst (itype, abs_d);\n \t}\n       else if (HOST_BITS_PER_WIDE_INT >= prec\n-\t       && abs_d == (unsigned HOST_WIDE_INT) 1 << (prec - 1))\n+\t       && abs_d == HOST_WIDE_INT_1U << (prec - 1))\n \t/* This case is not handled correctly below.  */\n \treturn NULL;\n \n       choose_multiplier (abs_d, prec, prec - 1, &ml, &post_shift, &dummy_int);\n-      if (ml >= (unsigned HOST_WIDE_INT) 1 << (prec - 1))\n+      if (ml >= HOST_WIDE_INT_1U << (prec - 1))\n \t{\n \t  add = true;\n \t  ml |= (~(unsigned HOST_WIDE_INT) 0) << (prec - 1);"}, {"sha": "c08ac25b31edf5385dc1d3fa878e0ff6943c4c4d", "filename": "gcc/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=fecfbfa4a290992437a99977381e29815ed9199d", "patch": "@@ -1422,7 +1422,7 @@ wide_int_to_tree (tree type, const wide_int_ref &pcst)\n     {\n       if (pcst.elt (l - 1) == 0)\n \tgcc_checking_assert (pcst.elt (l - 2) < 0);\n-      if (pcst.elt (l - 1) == (HOST_WIDE_INT) -1)\n+      if (pcst.elt (l - 1) == HOST_WIDE_INT_M1)\n \tgcc_checking_assert (pcst.elt (l - 2) >= 0);\n     }\n "}, {"sha": "e2ffabfe173dfeadf197428630d0fa543ccac28f", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=fecfbfa4a290992437a99977381e29815ed9199d", "patch": "@@ -1965,7 +1965,7 @@ extern machine_mode element_mode (const_tree t);\n \n /* For a VECTOR_TYPE, this is the number of sub-parts of the vector.  */\n #define TYPE_VECTOR_SUBPARTS(VECTOR_TYPE) \\\n-  (((unsigned HOST_WIDE_INT) 1) \\\n+  (HOST_WIDE_INT_1U \\\n    << VECTOR_TYPE_CHECK (VECTOR_TYPE)->type_common.precision)\n \n /* Set precision to n when we have 2^n sub-parts of the vector.  */"}, {"sha": "8ee57d5f1e129c99050b07197780d45a14e044af", "filename": "gcc/ubsan.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.c?ref=fecfbfa4a290992437a99977381e29815ed9199d", "patch": "@@ -1827,7 +1827,7 @@ instrument_object_size (gimple_stmt_iterator *gsi, bool is_lhs)\n     base_addr = build1 (ADDR_EXPR,\n \t\t\tbuild_pointer_type (TREE_TYPE (base)), base);\n   unsigned HOST_WIDE_INT size = compute_builtin_object_size (base_addr, 0);\n-  if (size != (unsigned HOST_WIDE_INT) -1)\n+  if (size != HOST_WIDE_INT_M1U)\n     sizet = build_int_cst (sizetype, size);\n   else if (optimize)\n     {"}, {"sha": "4ef6115455ce991a1137ba8867f7a997c83075a3", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=fecfbfa4a290992437a99977381e29815ed9199d", "patch": "@@ -7497,7 +7497,7 @@ elf_record_gcc_switches (print_switch_type type, const char * name)\n     {\n     case SWITCH_TYPE_PASSED:\n       ASM_OUTPUT_ASCII (asm_out_file, name, strlen (name));\n-      ASM_OUTPUT_SKIP (asm_out_file, (unsigned HOST_WIDE_INT) 1);\n+      ASM_OUTPUT_SKIP (asm_out_file, HOST_WIDE_INT_1U);\n       break;\n \n     case SWITCH_TYPE_DESCRIPTIVE:"}, {"sha": "70f2fb48def04c88b9c4c86c9235a01b049301d6", "filename": "gcc/wide-int-print.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fwide-int-print.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fwide-int-print.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fwide-int-print.cc?ref=fecfbfa4a290992437a99977381e29815ed9199d", "patch": "@@ -120,7 +120,7 @@ print_hex (const wide_int_ref &wi, char *buf)\n \t     we do not print a '-' with hex.  */\n \t  buf += sprintf (buf, \"0x\");\n \t  for (j = BLOCKS_NEEDED (wi.get_precision ()); j > i; j--)\n-\t    buf += sprintf (buf, HOST_WIDE_INT_PRINT_PADDED_HEX, (HOST_WIDE_INT) -1);\n+\t    buf += sprintf (buf, HOST_WIDE_INT_PRINT_PADDED_HEX, HOST_WIDE_INT_M1);\n \n \t}\n       else"}, {"sha": "1a209bb9b852f977c52954f611d3c07e13437f0e", "filename": "gcc/wide-int.cc", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fwide-int.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fwide-int.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fwide-int.cc?ref=fecfbfa4a290992437a99977381e29815ed9199d", "patch": "@@ -60,7 +60,7 @@ static const HOST_WIDE_INT zeros[WIDE_INT_MAX_ELTS] = {};\n \n /* Quantities to deal with values that hold half of a wide int.  Used\n    in multiply and divide.  */\n-#define HALF_INT_MASK (((HOST_WIDE_INT) 1 << HOST_BITS_PER_HALF_WIDE_INT) - 1)\n+#define HALF_INT_MASK ((HOST_WIDE_INT_1 << HOST_BITS_PER_HALF_WIDE_INT) - 1)\n \n #define BLOCK_OF(TARGET) ((TARGET) / HOST_BITS_PER_WIDE_INT)\n #define BLOCKS_NEEDED(PREC) \\\n@@ -73,7 +73,7 @@ static const HOST_WIDE_INT zeros[WIDE_INT_MAX_ELTS] = {};\n static unsigned HOST_WIDE_INT\n safe_uhwi (const HOST_WIDE_INT *val, unsigned int len, unsigned int i)\n {\n-  return i < len ? val[i] : val[len - 1] < 0 ? (HOST_WIDE_INT) -1 : 0;\n+  return i < len ? val[i] : val[len - 1] < 0 ? HOST_WIDE_INT_M1 : 0;\n }\n \n /* Convert the integer in VAL to canonical form, returning its new length.\n@@ -698,7 +698,7 @@ wi::set_bit_large (HOST_WIDE_INT *val, const HOST_WIDE_INT *xval,\n       unsigned int len = block + 1;\n       for (unsigned int i = 0; i < len; i++)\n \tval[i] = safe_uhwi (xval, xlen, i);\n-      val[block] |= (unsigned HOST_WIDE_INT) 1 << subbit;\n+      val[block] |= HOST_WIDE_INT_1U << subbit;\n \n       /* If the bit we just set is at the msb of the block, make sure\n \t that any higher bits are zeros.  */\n@@ -710,7 +710,7 @@ wi::set_bit_large (HOST_WIDE_INT *val, const HOST_WIDE_INT *xval,\n     {\n       for (unsigned int i = 0; i < xlen; i++)\n \tval[i] = xval[i];\n-      val[block] |= (unsigned HOST_WIDE_INT) 1 << subbit;\n+      val[block] |= HOST_WIDE_INT_1U << subbit;\n       return canonize (val, xlen, precision);\n     }\n }\n@@ -779,7 +779,7 @@ wi::mask (HOST_WIDE_INT *val, unsigned int width, bool negate,\n   unsigned int shift = width & (HOST_BITS_PER_WIDE_INT - 1);\n   if (shift != 0)\n     {\n-      HOST_WIDE_INT last = ((unsigned HOST_WIDE_INT) 1 << shift) - 1;\n+      HOST_WIDE_INT last = (HOST_WIDE_INT_1U << shift) - 1;\n       val[i++] = negate ? ~last : last;\n     }\n   else\n@@ -812,12 +812,12 @@ wi::shifted_mask (HOST_WIDE_INT *val, unsigned int start, unsigned int width,\n   unsigned int shift = start & (HOST_BITS_PER_WIDE_INT - 1);\n   if (shift)\n     {\n-      HOST_WIDE_INT block = ((unsigned HOST_WIDE_INT) 1 << shift) - 1;\n+      HOST_WIDE_INT block = (HOST_WIDE_INT_1U << shift) - 1;\n       shift += width;\n       if (shift < HOST_BITS_PER_WIDE_INT)\n \t{\n \t  /* case 000111000 */\n-\t  block = ((unsigned HOST_WIDE_INT) 1 << shift) - block - 1;\n+\t  block = (HOST_WIDE_INT_1U << shift) - block - 1;\n \t  val[i++] = negate ? ~block : block;\n \t  return i;\n \t}\n@@ -834,7 +834,7 @@ wi::shifted_mask (HOST_WIDE_INT *val, unsigned int start, unsigned int width,\n   if (shift != 0)\n     {\n       /* 000011111 */\n-      HOST_WIDE_INT block = ((unsigned HOST_WIDE_INT) 1 << shift) - 1;\n+      HOST_WIDE_INT block = (HOST_WIDE_INT_1U << shift) - 1;\n       val[i++] = negate ? ~block : block;\n     }\n   else if (end < prec)"}, {"sha": "f172faecf871d5d3364c4d4e993acce9240f98a4", "filename": "gcc/wide-int.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fwide-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fecfbfa4a290992437a99977381e29815ed9199d/gcc%2Fwide-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fwide-int.h?ref=fecfbfa4a290992437a99977381e29815ed9199d", "patch": "@@ -2116,7 +2116,7 @@ wi::set_bit (const T &x, unsigned int bit)\n   WIDE_INT_REF_FOR (T) xi (x, precision);\n   if (precision <= HOST_BITS_PER_WIDE_INT)\n     {\n-      val[0] = xi.ulow () | ((unsigned HOST_WIDE_INT) 1 << bit);\n+      val[0] = xi.ulow () | (HOST_WIDE_INT_1U << bit);\n       result.set_len (1);\n     }\n   else"}]}