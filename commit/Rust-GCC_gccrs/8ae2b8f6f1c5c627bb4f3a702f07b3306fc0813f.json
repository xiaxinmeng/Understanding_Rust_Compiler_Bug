{"sha": "8ae2b8f6f1c5c627bb4f3a702f07b3306fc0813f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGFlMmI4ZjZmMWM1YzYyN2JiNGYzYTcwMmYwN2IzMzA2ZmMwODEzZg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-10-20T20:06:59Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-10-20T20:06:59Z"}, "message": "(merge_equiv_classes, cse_insn): Call rehash_using_reg after insert_regs.\n\n(merge_equiv_classes, cse_insn): Call rehash_using_reg\nafter insert_regs.\n(canon_hash): Don't use qty_const to compute hash code for a\nregister.\n\nFrom-SVN: r8319", "tree": {"sha": "90a0a5ad2f1d32790c5a3f74e0f5ea2eab3915ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/90a0a5ad2f1d32790c5a3f74e0f5ea2eab3915ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ae2b8f6f1c5c627bb4f3a702f07b3306fc0813f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ae2b8f6f1c5c627bb4f3a702f07b3306fc0813f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ae2b8f6f1c5c627bb4f3a702f07b3306fc0813f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ae2b8f6f1c5c627bb4f3a702f07b3306fc0813f/comments", "author": null, "committer": null, "parents": [{"sha": "e5852cffc21b02142c084c451360688bf3bbb019", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5852cffc21b02142c084c451360688bf3bbb019", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5852cffc21b02142c084c451360688bf3bbb019"}], "stats": {"total": 40, "additions": 22, "deletions": 18}, "files": [{"sha": "d030c1d8ff159ac6c2c3b31b45adca2be2f4f963", "filename": "gcc/cse.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ae2b8f6f1c5c627bb4f3a702f07b3306fc0813f/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ae2b8f6f1c5c627bb4f3a702f07b3306fc0813f/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=8ae2b8f6f1c5c627bb4f3a702f07b3306fc0813f", "patch": "@@ -1466,7 +1466,10 @@ merge_equiv_classes (class1, class2)\n \t  remove_from_table (elt, hash);\n \n \t  if (insert_regs (exp, class1, 0))\n-\t    hash = HASH (exp, mode);\n+\t    {\n+\t      rehash_using_reg (exp);\n+\t      hash = HASH (exp, mode);\n+\t    }\n \t  new = insert (exp, class1, hash, mode);\n \t  new->in_memory = hash_arg_in_memory;\n \t  new->in_struct = hash_arg_in_struct;\n@@ -1955,17 +1958,6 @@ canon_hash (x, mode)\n       if (fmt[i] == 'e')\n \t{\n \t  rtx tem = XEXP (x, i);\n-\t  rtx tem1;\n-\n-\t  /* If the operand is a REG that is equivalent to a constant, hash\n-\t     as if we were hashing the constant, since we will be comparing\n-\t     that way.  */\n-\t  if (tem != 0 && GET_CODE (tem) == REG\n-\t      && REGNO_QTY_VALID_P (REGNO (tem))\n-\t      && qty_mode[reg_qty[REGNO (tem)]] == GET_MODE (tem)\n-\t      && (tem1 = qty_const[reg_qty[REGNO (tem)]]) != 0\n-\t      && CONSTANT_P (tem1))\n-\t    tem = tem1;\n \n \t  /* If we are about to do the last recursive call\n \t     needed at this level, change it into iteration.\n@@ -7030,7 +7022,10 @@ cse_insn (insn, in_libcall_block)\n \t  classp = 0;\n \t}\n       if (insert_regs (src_eqv, classp, 0))\n-\tsrc_eqv_hash = HASH (src_eqv, eqvmode);\n+\t{\n+\t  rehash_using_reg (src_eqv);\n+\t  src_eqv_hash = HASH (src_eqv, eqvmode);\n+\t}\n       elt = insert (src_eqv, classp, src_eqv_hash, eqvmode);\n       elt->in_memory = src_eqv_in_memory;\n       elt->in_struct = src_eqv_in_struct;\n@@ -7077,7 +7072,10 @@ cse_insn (insn, in_libcall_block)\n \t\t   any of the src_elt's, because they would have failed to\n \t\t   match if not still valid.  */\n \t\tif (insert_regs (src, classp, 0))\n-\t\t  sets[i].src_hash = HASH (src, mode);\n+\t\t  {\n+\t\t    rehash_using_reg (src);\n+\t\t    sets[i].src_hash = HASH (src, mode);\n+\t\t  }\n \t\telt = insert (src, classp, sets[i].src_hash, mode);\n \t\telt->in_memory = sets[i].src_in_memory;\n \t\telt->in_struct = sets[i].src_in_struct;\n@@ -7202,9 +7200,12 @@ cse_insn (insn, in_libcall_block)\n \tif (GET_CODE (dest) == REG || GET_CODE (dest) == SUBREG)\n \t  /* Registers must also be inserted into chains for quantities.  */\n \t  if (insert_regs (dest, sets[i].src_elt, 1))\n-\t    /* If `insert_regs' changes something, the hash code must be\n-\t       recalculated.  */\n-\t    sets[i].dest_hash = HASH (dest, GET_MODE (dest));\n+\t    {\n+\t      /* If `insert_regs' changes something, the hash code must be\n+\t\t recalculated.  */\n+\t      rehash_using_reg (dest);\n+\t      sets[i].dest_hash = HASH (dest, GET_MODE (dest));\n+\t    }\n \n \telt = insert (dest, sets[i].src_elt,\n \t\t      sets[i].dest_hash, GET_MODE (dest));\n@@ -7268,7 +7269,10 @@ cse_insn (insn, in_libcall_block)\n \t\tif (src_elt == 0)\n \t\t  {\n \t\t    if (insert_regs (new_src, classp, 0))\n-\t\t      src_hash = HASH (new_src, new_mode);\n+\t\t      {\n+\t\t\trehash_using_reg (new_src);\n+\t\t\tsrc_hash = HASH (new_src, new_mode);\n+\t\t      }\n \t\t    src_elt = insert (new_src, classp, src_hash, new_mode);\n \t\t    src_elt->in_memory = elt->in_memory;\n \t\t    src_elt->in_struct = elt->in_struct;"}]}