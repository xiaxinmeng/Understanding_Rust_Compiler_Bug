{"sha": "0470fad0d6c2b993e6f9906dc2d17303944dcc14", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQ3MGZhZDBkNmMyYjk5M2U2Zjk5MDZkYzJkMTczMDM5NDRkY2MxNA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2016-10-11T10:33:36Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2016-10-11T10:33:36Z"}, "message": "Simplify std::rethrow_if_nested definition\n\n\t* doc/xml/manual/intro.xml: Document LWG 2484 status.\n\t* libsupc++/nested_exception.h (_Throw_with_nested_impl)\n\t(_Throw_with_nested_helper): Remove.\n\t(__throw_with_nested_impl): New overloaded functions to implement\n\tthrow_with_nested logic.\n\t(throw_with_nested): Call __throw_with_nested_impl.\n\t(_Rethrow_if_nested_impl): Remove\n\t(__rethrow_if_nested_impl): New overloaded functions to implement\n\trethrow_if_nested logic.\n\t(rethrow_if_nested): Call __rethrow_if_nested_impl.\n\t* testsuite/18_support/nested_exception/rethrow_if_nested.cc: Test\n\tproblem cases from LWG 2484.\n\nFrom-SVN: r240983", "tree": {"sha": "f4a14a82455e28eafab455288f29438bc8312154", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f4a14a82455e28eafab455288f29438bc8312154"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0470fad0d6c2b993e6f9906dc2d17303944dcc14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0470fad0d6c2b993e6f9906dc2d17303944dcc14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0470fad0d6c2b993e6f9906dc2d17303944dcc14", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0470fad0d6c2b993e6f9906dc2d17303944dcc14/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf1de1ac983d607f5097ed1a6b004e50eabb3dde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf1de1ac983d607f5097ed1a6b004e50eabb3dde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf1de1ac983d607f5097ed1a6b004e50eabb3dde"}], "stats": {"total": 128, "additions": 79, "deletions": 49}, "files": [{"sha": "eb68cbf53206394f391d5d8b371216368ad87302", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0470fad0d6c2b993e6f9906dc2d17303944dcc14/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0470fad0d6c2b993e6f9906dc2d17303944dcc14/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=0470fad0d6c2b993e6f9906dc2d17303944dcc14", "patch": "@@ -1,5 +1,18 @@\n 2016-10-11  Jonathan Wakely  <jwakely@redhat.com>\n \n+\t* doc/xml/manual/intro.xml: Document LWG 2484 status.\n+\t* libsupc++/nested_exception.h (_Throw_with_nested_impl)\n+\t(_Throw_with_nested_helper): Remove.\n+\t(__throw_with_nested_impl): New overloaded functions to implement\n+\tthrow_with_nested logic.\n+\t(throw_with_nested): Call __throw_with_nested_impl.\n+\t(_Rethrow_if_nested_impl): Remove\n+\t(__rethrow_if_nested_impl): New overloaded functions to implement\n+\trethrow_if_nested logic.\n+\t(rethrow_if_nested): Call __rethrow_if_nested_impl.\n+\t* testsuite/18_support/nested_exception/rethrow_if_nested.cc: Test\n+\tproblem cases from LWG 2484.\n+\n \t* python/libstdcxx/v6/printers.py (build_libstdcxx_dictionary):\n \tRegister printer for std::__cxx11::list.\n \t* python/libstdcxx/v6/xmethods.py (ListMethodsMatcher.match): Match"}, {"sha": "22b792ad1180e6bab143d116499f5de83d3eb330", "filename": "libstdc++-v3/doc/xml/manual/intro.xml", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0470fad0d6c2b993e6f9906dc2d17303944dcc14/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fintro.xml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0470fad0d6c2b993e6f9906dc2d17303944dcc14/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fintro.xml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fintro.xml?ref=0470fad0d6c2b993e6f9906dc2d17303944dcc14", "patch": "@@ -1078,6 +1078,14 @@ requirements of the license of GCC.\n     <listitem><para>Divide by the object type.\n     </para></listitem></varlistentry>\n \n+    <varlistentry><term><link xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"../ext/lwg-defects.html#2484\">2484</link>:\n+       <emphasis><code>rethrow_if_nested()</code>  is doubly unimplementable\n+       </emphasis>\n+    </term>\n+    <listitem><para>Avoid using <code>dynamic_cast</code> when it would be\n+    ill-formed.\n+    </para></listitem></varlistentry>\n+\n     <varlistentry><term><link xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"../ext/lwg-defects.html#2583\">2583</link>:\n        <emphasis>There is no way to supply an allocator for <code> basic_string(str, pos)</code>\n        </emphasis>"}, {"sha": "0c00d7487acee760b4e0009b9cb2041f60230b3a", "filename": "libstdc++-v3/libsupc++/nested_exception.h", "status": "modified", "additions": 39, "deletions": 49, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0470fad0d6c2b993e6f9906dc2d17303944dcc14/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnested_exception.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0470fad0d6c2b993e6f9906dc2d17303944dcc14/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnested_exception.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnested_exception.h?ref=0470fad0d6c2b993e6f9906dc2d17303944dcc14", "patch": "@@ -92,41 +92,21 @@ namespace std\n       { }\n     };\n \n-  template<typename _Tp,\n-\t   bool __with_nested = !__is_base_of(nested_exception, _Tp)>\n-    struct _Throw_with_nested_impl\n-    {\n-      template<typename _Up>\n-\tstatic void _S_throw(_Up&& __t)\n-\t{ throw _Nested_exception<_Tp>{static_cast<_Up&&>(__t)}; }\n-    };\n-\n+  // [except.nested]/8\n+  // Throw an exception of unspecified type that is publicly derived from\n+  // both remove_reference_t<_Tp> and nested_exception.\n   template<typename _Tp>\n-    struct _Throw_with_nested_impl<_Tp, false>\n+    inline void\n+    __throw_with_nested_impl(_Tp&& __t, true_type)\n     {\n-      template<typename _Up>\n-\tstatic void _S_throw(_Up&& __t)\n-\t{ throw static_cast<_Up&&>(__t); }\n-    };\n-\n-  template<typename _Tp, bool = __is_class(_Tp) && !__is_final(_Tp)>\n-    struct _Throw_with_nested_helper : _Throw_with_nested_impl<_Tp>\n-    { };\n-\n-  template<typename _Tp>\n-    struct _Throw_with_nested_helper<_Tp, false>\n-    : _Throw_with_nested_impl<_Tp, false>\n-    { };\n-\n-  template<typename _Tp>\n-    struct _Throw_with_nested_helper<_Tp&, false>\n-    : _Throw_with_nested_helper<_Tp>\n-    { };\n+      using _Up = typename remove_reference<_Tp>::type;\n+      throw _Nested_exception<_Up>{std::forward<_Tp>(__t)};\n+    }\n \n   template<typename _Tp>\n-    struct _Throw_with_nested_helper<_Tp&&, false>\n-    : _Throw_with_nested_helper<_Tp>\n-    { };\n+    inline void\n+    __throw_with_nested_impl(_Tp&& __t, false_type)\n+    { throw std::forward<_Tp>(__t); }\n \n   /// If @p __t is derived from nested_exception, throws @p __t.\n   /// Else, throws an implementation-defined object derived from both.\n@@ -135,33 +115,43 @@ namespace std\n     inline void\n     throw_with_nested(_Tp&& __t)\n     {\n-      _Throw_with_nested_helper<_Tp>::_S_throw(static_cast<_Tp&&>(__t));\n+      using _Up = typename remove_reference<_Tp>::type;\n+      using _CopyConstructible\n+\t= __and_<is_copy_constructible<_Up>, is_move_constructible<_Up>>;\n+      static_assert(_CopyConstructible::value,\n+\t  \"throw_with_nested argument must be CopyConstructible\");\n+      using __nest = __and_<is_class<_Up>, __bool_constant<!__is_final(_Up)>,\n+\t\t\t    __not_<is_base_of<nested_exception, _Up>>>;\n+      return std::__throw_with_nested_impl(std::forward<_Tp>(__t), __nest{});\n     }\n \n-  template<typename _Tp, bool = __is_polymorphic(_Tp)>\n-    struct _Rethrow_if_nested_impl\n-    {\n-      static void _S_rethrow(const _Tp& __t)\n-      {\n-\tif (auto __tp =\n-            dynamic_cast<const nested_exception*>(std::__addressof(__t)))\n-\t  __tp->rethrow_nested();\n-      }\n-    };\n-\n+  // Determine if dynamic_cast<const nested_exception&> would be well-formed.\n   template<typename _Tp>\n-    struct _Rethrow_if_nested_impl<_Tp, false>\n+    using __rethrow_if_nested_cond = typename enable_if<\n+      __and_<is_polymorphic<_Tp>,\n+\t     __or_<__not_<is_base_of<nested_exception, _Tp>>,\n+\t\t   is_convertible<_Tp*, nested_exception*>>>::value\n+    >::type;\n+\n+  // Attempt dynamic_cast to nested_exception and call rethrow_nested().\n+  template<typename _Ex>\n+    inline __rethrow_if_nested_cond<_Ex>\n+    __rethrow_if_nested_impl(const _Ex* __ptr)\n     {\n-      static void _S_rethrow(const _Tp&) { }\n-    };\n+      if (auto __ne_ptr = dynamic_cast<const nested_exception*>(__ptr))\n+\t__ne_ptr->rethrow_nested();\n+    }\n+\n+  // Otherwise, no effects.\n+  inline void\n+  __rethrow_if_nested_impl(const void*)\n+  { }\n \n   /// If @p __ex is derived from nested_exception, @p __ex.rethrow_nested().\n   template<typename _Ex>\n     inline void\n     rethrow_if_nested(const _Ex& __ex)\n-    {\n-      _Rethrow_if_nested_impl<_Ex>::_S_rethrow(__ex);\n-    }\n+    { std::__rethrow_if_nested_impl(std::__addressof(__ex)); }\n \n   // @} group exceptions\n } // namespace std"}, {"sha": "7751213300907d8c13d091f062714c34737b33e0", "filename": "libstdc++-v3/testsuite/18_support/nested_exception/rethrow_if_nested.cc", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0470fad0d6c2b993e6f9906dc2d17303944dcc14/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fnested_exception%2Frethrow_if_nested.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0470fad0d6c2b993e6f9906dc2d17303944dcc14/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fnested_exception%2Frethrow_if_nested.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fnested_exception%2Frethrow_if_nested.cc?ref=0470fad0d6c2b993e6f9906dc2d17303944dcc14", "patch": "@@ -101,11 +101,30 @@ void test03()\n   VERIFY( test );\n }\n \n+void\n+test04()\n+{\n+  // LWG 2484 requires that these cases are well-formed, but don't rethrow.\n+\n+  std::rethrow_if_nested(1);\n+\n+  struct S { } nonpolymorphic;\n+  std::rethrow_if_nested(nonpolymorphic);\n+\n+  struct derived3 : derived, derived2 { };\n+  derived3 ambiguous_base;\n+  std::rethrow_if_nested(ambiguous_base);\n+\n+  struct derived4 : private std::nested_exception { };\n+  derived4 private_base;\n+  std::rethrow_if_nested(private_base);\n+}\n \n int main()\n {\n   test01();\n   test02();\n   test03();\n+  test04();\n   return 0;\n }"}]}