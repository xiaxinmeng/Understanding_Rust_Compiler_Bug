{"sha": "e49aacaf3083a99dc266209ed91183e91b11ffad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQ5YWFjYWYzMDgzYTk5ZGMyNjYyMDllZDkxMTgzZTkxYjExZmZhZA==", "commit": {"author": {"name": "Chris Manghane", "email": "cmang@google.com", "date": "2016-04-29T17:33:01Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-04-29T17:33:01Z"}, "message": "escape: Remove previously existing analysis.\n\n    \n\t* Make-lang.in (GO_OBJS): Remove go/dataflow.o, go/escape.o.\n\n    Reviewed-on: https://go-review.googlesource.com/18261\n\nFrom-SVN: r235649", "tree": {"sha": "da4b8e32107b5037bb3284c81851b0c28762cf9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da4b8e32107b5037bb3284c81851b0c28762cf9d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e49aacaf3083a99dc266209ed91183e91b11ffad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e49aacaf3083a99dc266209ed91183e91b11ffad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e49aacaf3083a99dc266209ed91183e91b11ffad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e49aacaf3083a99dc266209ed91183e91b11ffad/comments", "author": null, "committer": null, "parents": [{"sha": "52d11a4bbf22f3312a559e63c819c2714c633694", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52d11a4bbf22f3312a559e63c819c2714c633694", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52d11a4bbf22f3312a559e63c819c2714c633694"}], "stats": {"total": 2753, "additions": 11, "deletions": 2742}, "files": [{"sha": "c179e79e28178dacf3893f2a69362c6175c47930", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e49aacaf3083a99dc266209ed91183e91b11ffad/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e49aacaf3083a99dc266209ed91183e91b11ffad/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=e49aacaf3083a99dc266209ed91183e91b11ffad", "patch": "@@ -1,3 +1,7 @@\n+2016-04-29  Chris Manghane  <cmang@google.com>\n+\n+\t* Make-lang.in (GO_OBJS): Remove go/dataflow.o, go/escape.o.\n+\n 2016-04-18  Michael Matz  <matz@suse.de>\n \n \t* go-gcc.cc (Gcc_backend::implicit_variable): Use SET_DECL_ALIGN."}, {"sha": "df27e21782876e079b97134c7d7ccf0ae91680ac", "filename": "gcc/go/Make-lang.in", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e49aacaf3083a99dc266209ed91183e91b11ffad/gcc%2Fgo%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e49aacaf3083a99dc266209ed91183e91b11ffad/gcc%2Fgo%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FMake-lang.in?ref=e49aacaf3083a99dc266209ed91183e91b11ffad", "patch": "@@ -50,8 +50,6 @@ go-warn = $(STRICT_WARN)\n \n GO_OBJS = \\\n \tgo/ast-dump.o \\\n-\tgo/dataflow.o \\\n-\tgo/escape.o \\\n \tgo/export.o \\\n \tgo/expressions.o \\\n \tgo/go-backend.o \\"}, {"sha": "1874a2ea3bed35c308c078e7f0f2c1da3c32d9aa", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e49aacaf3083a99dc266209ed91183e91b11ffad/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e49aacaf3083a99dc266209ed91183e91b11ffad/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=e49aacaf3083a99dc266209ed91183e91b11ffad", "patch": "@@ -1,4 +1,4 @@\n-50b2b468a85045c66d60112dc094c31ec4897123\n+46b108136c0d102f181f0cc7c398e3db8c4d08a3\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "bf1d54ab26126bdb16089c98b11ddd9413bc0199", "filename": "gcc/go/gofrontend/dataflow.cc", "status": "removed", "additions": 0, "deletions": 299, "changes": 299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52d11a4bbf22f3312a559e63c819c2714c633694/gcc%2Fgo%2Fgofrontend%2Fdataflow.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52d11a4bbf22f3312a559e63c819c2714c633694/gcc%2Fgo%2Fgofrontend%2Fdataflow.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fdataflow.cc?ref=52d11a4bbf22f3312a559e63c819c2714c633694", "patch": "@@ -1,299 +0,0 @@\n-// dataflow.cc -- Go frontend dataflow.\n-\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-#include \"go-system.h\"\n-\n-#include \"gogo.h\"\n-#include \"expressions.h\"\n-#include \"statements.h\"\n-#include \"dataflow.h\"\n-\n-// This class is used to traverse the tree to look for uses of\n-// variables.\n-\n-class Dataflow_traverse_expressions : public Traverse\n-{\n- public:\n-  Dataflow_traverse_expressions(Dataflow* dataflow, Statement* statement)\n-    : Traverse(traverse_blocks | traverse_expressions),\n-      dataflow_(dataflow), statement_(statement)\n-  { }\n-\n- protected:\n-  // Only look at top-level expressions: do not descend into blocks.\n-  // They will be examined via Dataflow_traverse_statements.\n-  int\n-  block(Block*)\n-  { return TRAVERSE_SKIP_COMPONENTS; }\n-\n-  int\n-  expression(Expression**);\n-\n- private:\n-  // The dataflow information.\n-  Dataflow* dataflow_;\n-  // The Statement in which we are looking.\n-  Statement* statement_;\n-};\n-\n-// Given an expression, return the Named_object that it refers to, if\n-// it is a local variable.\n-\n-static Named_object*\n-get_var(Expression* expr)\n-{\n-  Var_expression* ve = expr->var_expression();\n-  if (ve == NULL)\n-    return NULL;\n-  Named_object* no = ve->named_object();\n-  go_assert(no->is_variable() || no->is_result_variable());\n-  if (no->is_variable() && no->var_value()->is_global())\n-    return NULL;\n-  return no;\n-}\n-\n-// Look for a reference to a variable in an expression.\n-\n-int\n-Dataflow_traverse_expressions::expression(Expression** expr)\n-{\n-  Named_object* no = get_var(*expr);\n-  if (no != NULL)\n-    this->dataflow_->add_ref(no, this->statement_);\n-  return TRAVERSE_CONTINUE;\n-}\n-\n-// This class is used to handle an assignment statement.\n-\n-class Dataflow_traverse_assignment : public Traverse_assignments\n-{\n- public:\n-  Dataflow_traverse_assignment(Dataflow* dataflow, Statement* statement)\n-    : dataflow_(dataflow), statement_(statement)\n-  { }\n-\n- protected:\n-  void\n-  initialize_variable(Named_object*);\n-\n-  void\n-  assignment(Expression** lhs, Expression** rhs);\n-\n-  void\n-  value(Expression**, bool, bool);\n-\n- private:\n-  // The dataflow information.\n-  Dataflow* dataflow_;\n-  // The Statement in which we are looking.\n-  Statement* statement_;\n-};\n-\n-// Handle a variable initialization.\n-\n-void\n-Dataflow_traverse_assignment::initialize_variable(Named_object* var)\n-{\n-  Expression* init = var->var_value()->init();\n-  this->dataflow_->add_def(var, init, this->statement_, true);\n-  if (init != NULL)\n-    {\n-      Expression* e = init;\n-      this->value(&e, true, true);\n-      go_assert(e == init);\n-    }\n-}\n-\n-// Handle an assignment in a statement.\n-\n-void\n-Dataflow_traverse_assignment::assignment(Expression** plhs, Expression** prhs)\n-{\n-  Named_object* no = get_var(*plhs);\n-  if (no != NULL)\n-    {\n-      Expression* rhs = prhs == NULL ? NULL : *prhs;\n-      this->dataflow_->add_def(no, rhs, this->statement_, false);\n-    }\n-  else\n-    {\n-      // If this is not a variable it may be some computed lvalue, and\n-      // we want to look for references to variables in that lvalue.\n-      this->value(plhs, false, false);\n-    }\n-  if (prhs != NULL)\n-    this->value(prhs, true, false);\n-}\n-\n-// Handle a value in a statement.\n-\n-void\n-Dataflow_traverse_assignment::value(Expression** pexpr, bool, bool)\n-{\n-  Named_object* no = get_var(*pexpr);\n-  if (no != NULL)\n-    this->dataflow_->add_ref(no, this->statement_);\n-  else\n-    {\n-      Dataflow_traverse_expressions dte(this->dataflow_, this->statement_);\n-      Expression::traverse(pexpr, &dte);\n-    }\n-}\n-\n-// This class is used to traverse the tree to look for statements.\n-\n-class Dataflow_traverse_statements : public Traverse\n-{\n- public:\n-  Dataflow_traverse_statements(Dataflow* dataflow)\n-    : Traverse(traverse_statements),\n-      dataflow_(dataflow)\n-  { }\n-\n- protected:\n-  int\n-  statement(Block*, size_t* pindex, Statement*);\n-\n- private:\n-  // The dataflow information.\n-  Dataflow* dataflow_;\n-};\n-\n-// For each Statement, we look for expressions.\n-\n-int\n-Dataflow_traverse_statements::statement(Block* block, size_t* pindex,\n-\t\t\t\t\tStatement *statement)\n-{\n-  Dataflow_traverse_assignment dta(this->dataflow_, statement);\n-\n-  // For thunk statements, make sure to traverse the call expression to\n-  // find any reference to a variable being used as an argument.\n-  if (!statement->traverse_assignments(&dta)\n-      || statement->thunk_statement() != NULL)\n-    {\n-      // Case statements in selects will be lowered into temporaries at this\n-      // point so our dataflow analysis will miss references between a/c and ch\n-      // in case statements of the form a,c := <-ch.  Do a special dataflow\n-      // analysis for select statements here; the analysis for the blocks will\n-      // be handled as usual.\n-      if (statement->select_statement() != NULL)\n-\tstatement->select_statement()->analyze_dataflow(this->dataflow_);\n-\n-      Dataflow_traverse_expressions dte(this->dataflow_, statement);\n-      statement->traverse(block, pindex, &dte);\n-    }\n-  return TRAVERSE_CONTINUE;\n-}\n-\n-// Compare variables.\n-\n-bool\n-Dataflow::Compare_vars::operator()(const Named_object* no1,\n-\t\t\t\t   const Named_object* no2) const\n-{\n-  if (no1->name() < no2->name())\n-    return true;\n-  if (no1->name() > no2->name())\n-    return false;\n-\n-  // We can have two different variables with the same name.\n-  Location loc1 = no1->location();\n-  Location loc2 = no2->location();\n-  if (loc1 < loc2)\n-    return false;\n-  if (loc1 > loc2)\n-    return true;\n-  if (Linemap::is_predeclared_location(loc1))\n-    return false;\n-\n-  if (no1 == no2\n-      || (no1->is_result_variable()\n-\t  && no2->is_result_variable())\n-      || ((no1->is_variable()\n-\t   && no1->var_value()->is_type_switch_var())\n-\t  && (no2->is_variable()\n-\t      && no2->var_value()->is_type_switch_var())))\n-    return false;\n-\n-  // We can't have two variables with the same name in the same\n-  // location unless they are type switch variables which share the same\n-  // fake location.\n-  go_unreachable();\n-}\n-\n-// Class Dataflow.\n-\n-Dataflow::Dataflow()\n-  : defs_(), refs_()\n-{\n-}\n-\n-// Build the dataflow information.\n-\n-void\n-Dataflow::initialize(Gogo* gogo)\n-{\n-  Dataflow_traverse_statements dts(this);\n-  gogo->traverse(&dts);\n-}\n-\n-// Add a definition of a variable.\n-\n-void\n-Dataflow::add_def(Named_object* var, Expression* val, Statement* statement,\n-\t\t  bool is_init)\n-{\n-  Defs* defnull = NULL;\n-  std::pair<Defmap::iterator, bool> ins =\n-    this->defs_.insert(std::make_pair(var, defnull));\n-  if (ins.second)\n-    ins.first->second = new Defs;\n-  Def def;\n-  def.statement = statement;\n-  def.val = val;\n-  def.is_init = is_init;\n-  ins.first->second->push_back(def);\n-}\n-\n-// Add a reference to a variable.\n-\n-void\n-Dataflow::add_ref(Named_object* var, Statement* statement)\n-{\n-  Refs* refnull = NULL;\n-  std::pair<Refmap::iterator, bool> ins =\n-    this->refs_.insert(std::make_pair(var, refnull));\n-  if (ins.second)\n-    ins.first->second = new Refs;\n-  Ref ref;\n-  ref.statement = statement;\n-  ins.first->second->push_back(ref);\n-}\n-\n-// Return the definitions of a variable.\n-\n-const Dataflow::Defs*\n-Dataflow::find_defs(Named_object* var) const\n-{\n-  Defmap::const_iterator p = this->defs_.find(var);\n-  if (p == this->defs_.end())\n-    return NULL;\n-  else\n-    return p->second;\n-}\n-\n-// Return the references of a variable.\n-\n-const Dataflow::Refs*\n-Dataflow::find_refs(Named_object* var) const\n-{\n-  Refmap::const_iterator p = this->refs_.find(var);\n-  if (p == this->refs_.end())\n-    return NULL;\n-  else\n-    return p->second;\n-}"}, {"sha": "a75c8e661f5a19ba772bcca0f05bec688d7e483c", "filename": "gcc/go/gofrontend/dataflow.h", "status": "removed", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52d11a4bbf22f3312a559e63c819c2714c633694/gcc%2Fgo%2Fgofrontend%2Fdataflow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52d11a4bbf22f3312a559e63c819c2714c633694/gcc%2Fgo%2Fgofrontend%2Fdataflow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fdataflow.h?ref=52d11a4bbf22f3312a559e63c819c2714c633694", "patch": "@@ -1,91 +0,0 @@\n-// dataflow.h -- Go frontend dataflow.    -*- C++ -*-\n-\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-#ifndef GO_DATAFLOW_H\n-#define GO_DATAFLOW_H\n-\n-class Expression;\n-class Named_object;\n-class Statement;\n-\n-// Dataflow information about the Go program.\n-\n-class Dataflow\n-{\n- public:\n-  // A variable definition.\n-  struct Def\n-  {\n-    // The statement where the variable is defined.\n-    Statement* statement;\n-    // The value to which the variable is set.  This may be NULL.\n-    Expression* val;\n-    // Whether this is an initialization of the variable.\n-    bool is_init;\n-  };\n-\n-  // A variable reference.\n-  struct Ref\n-  {\n-    // The statement where the variable is referenced.\n-    Statement* statement;\n-  };\n-\n-  // A list of defs.\n-  typedef std::vector<Def> Defs;\n-\n-  // A list of refs.\n-  typedef std::vector<Ref> Refs;\n-\n-  Dataflow();\n-\n-  // Initialize the dataflow information.\n-  void\n-  initialize(Gogo*);\n-\n-  // Add a definition of a variable.  STATEMENT assigns a value to\n-  // VAR.  VAL is the value if it is known, NULL otherwise.\n-  void\n-  add_def(Named_object* var, Expression* val, Statement* statement,\n-\t  bool is_init);\n-\n-  // Add a reference to a variable.  VAR is the variable, and\n-  // STATEMENT is the statement which refers to it.\n-  void\n-  add_ref(Named_object* var, Statement* statement);\n-\n-  // Return the definitions of VAR--the places where it is set.\n-  const Defs*\n-  find_defs(Named_object* var) const;\n-\n-  // Return the references to VAR--the places where it is used.\n-  const Refs*\n-  find_refs(Named_object* var) const;\n-\n- private:\n-  // Order variables in the map.\n-  struct Compare_vars\n-  {\n-    bool\n-    operator()(const Named_object*, const Named_object*) const;\n-  };\n-\n-  // Map from variables to a list of defs of the variable.  We use a\n-  // map rather than a hash table because the order in which we\n-  // process variables may affect the resulting code.\n-  typedef std::map<Named_object*, Defs*, Compare_vars> Defmap;\n-\n-  // Map from variables to a list of refs to the vairable.\n-  typedef std::map<Named_object*, Refs*, Compare_vars> Refmap;\n-\n-  // Variable defs.\n-  Defmap defs_;\n-  // Variable refs;\n-  Refmap refs_;\n-};\n-\n-\n-#endif // !defined(GO_DATAFLOW_H)"}, {"sha": "3a5738381d4afb9232269b811c8b1098cf9ccc15", "filename": "gcc/go/gofrontend/escape.cc", "status": "removed", "additions": 0, "deletions": 1669, "changes": 1669, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52d11a4bbf22f3312a559e63c819c2714c633694/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52d11a4bbf22f3312a559e63c819c2714c633694/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fescape.cc?ref=52d11a4bbf22f3312a559e63c819c2714c633694", "patch": "@@ -1,1669 +0,0 @@\n-// escape.cc -- Go frontend escape analysis.\n-\n-// Copyright 2015 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-#include \"go-system.h\"\n-\n-#include <fstream>\n-\n-#include \"go-c.h\"\n-#include \"go-dump.h\"\n-#include \"go-optimize.h\"\n-#include \"types.h\"\n-#include \"statements.h\"\n-#include \"expressions.h\"\n-#include \"dataflow.h\"\n-#include \"gogo.h\"\n-#include \"escape.h\"\n-\n-// Class Node.\n-\n-Node::Node(Node_classification classification, Named_object* object)\n-  : classification_(classification), object_(object)\n-{\n-  // Give every node a unique ID for representation purposes.\n-  static int count;\n-  this->id_ = count++;\n-}\n-\n-Node::~Node()\n-{\n-}\n-\n-// Make a call node for FUNCTION.\n-\n-Node*\n-Node::make_call(Named_object* function)\n-{\n-  return new Call_node(function);\n-}\n-\n-// Make a connection node for OBJECT.\n-\n-Node*\n-Node::make_connection(Named_object* object, Escapement_lattice e)\n-{\n-  return new Connection_node(object, e);\n-}\n-\n-// Return this node's label, which will be the name seen in the graphical\n-// representation.\n-\n-const std::string&\n-Node::label()\n-{\n-  if (this->label_.empty())\n-    {\n-      this->label_ = \"[label=\\\"\";\n-      this->label_ += this->object_->name();\n-      this->label_ += \"\\\"]\";\n-    }\n-  return this->label_;\n-}\n-\n-// Class Call_node.\n-\n-Call_node::Call_node(Named_object* function)\n-  : Node(NODE_CALL, function)\n-{ go_assert(function->is_function() || function->is_function_declaration()); }\n-\n-const std::string&\n-Call_node::name()\n-{\n-  if (this->get_name().empty())\n-    {\n-      char buf[30];\n-      snprintf(buf, sizeof buf, \"CallNode%d\", this->id());\n-      this->set_name(std::string(buf));\n-    }\n-  return this->get_name();\n-}\n-\n-// Class Connection_node.\n-\n-const std::string&\n-Connection_node::name()\n-{\n-  if (this->get_name().empty())\n-    {\n-      char buf[30];\n-      snprintf(buf, sizeof buf, \"ConnectionNode%d\", this->id());\n-      this->set_name(std::string(buf));\n-    }\n-  return this->get_name();\n-}\n-\n-const std::string&\n-Connection_node::label()\n-{\n-  if (this->get_label().empty())\n-    {\n-      std::string label = \"[label=\\\"\";\n-      label += this->object()->name();\n-      label += \"\\\",color=\";\n-      switch (this->escape_state_)\n-      {\n-      case ESCAPE_GLOBAL:\n-\tlabel += \"red\";\n-\tbreak;\n-      case ESCAPE_ARG:\n-\tlabel += \"blue\";\n-\tbreak;\n-      case ESCAPE_NONE:\n-\tlabel += \"black\";\n-\tbreak;\n-      }\n-      label += \"]\";\n-      this->set_label(label);\n-    }\n-  return this->get_label();\n-}\n-\n-// Dump a connection node and its edges to a dump file.\n-\n-void\n-Connection_node::dump_connection(Connection_dump_context* cdc)\n-{\n-  cdc->write_string(this->name() + this->label());\n-  cdc->write_c_string(\"\\n\");\n-\n-  for (std::set<Node*>::const_iterator p = this->edges().begin();\n-       p != this->edges().end();\n-       ++p)\n-    {\n-      cdc->write_string(this->name());\n-      cdc->write_c_string(\"->\");\n-\n-      if ((*p)->object()->is_function())\n-\t{\n-\t  char buf[100];\n-\t  snprintf(buf, sizeof buf, \"dummy%d[lhead=cluster%d]\",\n-\t\t   (*p)->id(), (*p)->id());\n-\t  cdc->write_c_string(buf);\n-\t}\n-      else\n-\tcdc->write_string((*p)->name());\n-      cdc->write_c_string(\"\\n\");\n-    }\n-}\n-\n-// The -fgo-dump-calls flag to activate call graph dumps in GraphViz DOT format.\n-\n-Go_dump call_graph_dump_flag(\"calls\");\n-\n-// Class Call_dump_context.\n-\n-Call_dump_context::Call_dump_context(std::ostream* out)\n-  : ostream_(out), gogo_(NULL)\n-{ }\n-\n-// Dump files will be named %basename%.calls.dot\n-\n-const char* kCallDumpFileExtension = \".calls.dot\";\n-\n-// Dump the call graph in DOT format.\n-\n-void\n-Call_dump_context::dump(Gogo* gogo, const char* basename)\n-{\n-  std::ofstream* out = new std::ofstream();\n-  std::string dumpname(basename);\n-  dumpname += kCallDumpFileExtension;\n-  out->open(dumpname.c_str());\n-\n-  if (out->fail())\n-    {\n-      error(\"cannot open %s:%m, -fgo-dump-calls ignored\", dumpname.c_str());\n-      return;\n-    }\n-\n-  this->gogo_ = gogo;\n-  this->ostream_ = out;\n-\n-  this->write_string(\"digraph CallGraph {\\n\");\n-  std::set<Node*> call_graph = gogo->call_graph();\n-\n-  // Generate GraphViz nodes for each node.\n-  for (std::set<Node*>::const_iterator p = call_graph.begin();\n-       p != call_graph.end();\n-       ++p)\n-    {\n-      this->write_string((*p)->name() + (*p)->label());\n-      this->write_c_string(\"\\n\");\n-      \n-      // Generate a graphical representation of the caller-callee relationship.\n-      std::set<Node*> callees = (*p)->edges();\n-      for (std::set<Node*>::const_iterator ce = callees.begin();\n-\t   ce != callees.end();\n-\t   ++ce)\n-\t{\n-\t  this->write_string((*p)->name() + \"->\" + (*ce)->name());\n-\t  this->write_c_string(\"\\n\");\n-\t}\n-    }\n-  this->write_string(\"}\");\n-  out->close();\n-}\n-\n-// Dump the Call Graph of the program to the dump file.\n-\n-void Gogo::dump_call_graph(const char* basename)\n-{\n-  if (::call_graph_dump_flag.is_enabled())\n-    {\n-      Call_dump_context cdc;\n-      cdc.dump(this, basename);\n-    }\n-}\n-\n-// Implementation of String_dump interface.\n-\n-void\n-Call_dump_context::write_c_string(const char* s)\n-{\n-  this->ostream() << s;\n-}\n-\n-void\n-Call_dump_context::write_string(const std::string& s)\n-{\n-  this->ostream() << s;\n-}\n-\n-// The -fgo-dump-conns flag to activate connection graph dumps in\n-// GraphViz DOT format.\n-\n-Go_dump connection_graph_dump_flag(\"conns\");\n-\n-// Class Connection_dump_context.\n-\n-Connection_dump_context::Connection_dump_context(std::ostream* out)\n-  : ostream_(out), gogo_(NULL)\n-{ }\n-\n-// Dump files will be named %basename%.conns.dot\n-\n-const char* kConnectionDumpFileExtension = \".conns.dot\";\n-\n-// Dump the connection graph in DOT format.\n-\n-void\n-Connection_dump_context::dump(Gogo* gogo, const char* basename)\n-{\n-  std::ofstream* out = new std::ofstream();\n-  std::string dumpname(basename);\n-  dumpname += kConnectionDumpFileExtension;\n-  out->open(dumpname.c_str());\n-\n-  if (out->fail())\n-    {\n-      error(\"cannot open %s:%m, -fgo-dump-conns ignored\", dumpname.c_str());\n-      return;\n-    }\n-\n-  this->gogo_ = gogo;\n-  this->ostream_ = out;\n-\n-  this->write_string(\"digraph ConnectionGraph {\\n\");\n-  this->write_string(\"compound=true\\n\");\n-\n-  // Dump global objects.\n-  std::set<Node*> globals = this->gogo_->global_connections();\n-  this->write_c_string(\"subgraph globals{\\n\");\n-  this->write_c_string(\"label=\\\"NonLocalGraph\\\"\\n\");\n-  this->write_c_string(\"color=red\\n\");\n-  for (std::set<Node*>::const_iterator p1 = globals.begin();\n-       p1 != globals.end();\n-       ++p1)\n-    (*p1)->connection_node()->dump_connection(this);\n-  this->write_c_string(\"}\\n\");\n-\n-  std::set<Node*> roots = this->gogo_->connection_roots();\n-  for (std::set<Node*>::const_reverse_iterator p1 = roots.rbegin();\n-       p1 != roots.rend();\n-       ++p1)\n-    {\n-      std::set<Node*> objects = (*p1)->connection_node()->objects();\n-\n-      char buf[150];\n-      snprintf(buf, sizeof buf, \"subgraph cluster%d\", (*p1)->id());\n-      this->write_c_string(buf);\n-      this->write_string(\"{\\n\");\n-      snprintf(buf, sizeof buf, \"dummy%d[shape=point,style=invis]\\n\",\n-\t       (*p1)->id());\n-      this->write_c_string(buf);\n-      this->write_string(\"label = \\\"\" + (*p1)->object()->name() + \"\\\"\\n\");\n-\n-      for (std::set<Node*>::const_iterator p2 = objects.begin();\n-\t   p2 != objects.end();\n-\t   ++p2)\n-\t(*p2)->connection_node()->dump_connection(this);\n-\n-      this->write_string(\"}\\n\");\n-    }\n-  this->write_string(\"}\");\n-  out->close();\n-}\n-\n-void\n-Gogo::dump_connection_graphs(const char* basename)\n-{\n-  if (::connection_graph_dump_flag.is_enabled())\n-    {\n-      Connection_dump_context cdc;\n-      cdc.dump(this, basename);\n-    }\n-}\n-\n-// Implementation of String_dump interface.\n-\n-void\n-Connection_dump_context::write_c_string(const char* s)\n-{\n-  this->ostream() << s;\n-}\n-\n-void\n-Connection_dump_context::write_string(const std::string& s)\n-{\n-  this->ostream() << s;\n-}\n-\n-// A traversal class used to build a call graph for this program.\n-\n-class Build_call_graph : public Traverse\n-{\n- public:\n-  Build_call_graph(Gogo* gogo)\n-    : Traverse(traverse_functions\n-\t       | traverse_expressions),\n-      gogo_(gogo), current_function_(NULL)\n-  { }\n-\n-  int\n-  function(Named_object*);\n-\n-  int\n-  expression(Expression**);\n-\n- private:\n-  // The IR.\n-  Gogo* gogo_;\n-  // The current function being traversed, for reference when traversing the\n-  // function body.\n-  Named_object* current_function_;\n-};\n-\n-// Add each function to the call graph and then traverse each function's\n-// body to find callee functions.\n-\n-int\n-Build_call_graph::function(Named_object* fn)\n-{\n-  this->gogo_->add_call_node(fn);\n-  go_assert(this->current_function_ == NULL);\n-  this->current_function_ = fn;\n-  fn->func_value()->traverse(this);\n-  this->current_function_ = NULL;\n-  return TRAVERSE_CONTINUE;\n-}\n-\n-// Find function calls and add them as callees to CURRENT_FUNCTION.\n-\n-int\n-Build_call_graph::expression(Expression** pexpr)\n-{\n-  if (this->current_function_ == NULL)\n-    return TRAVERSE_CONTINUE;\n-\n-  Expression* expr = *pexpr;\n-  Named_object* fn;\n-  if (expr->call_expression() != NULL)\n-    {\n-      Func_expression* func = expr->call_expression()->fn()->func_expression();\n-      if (func == NULL)\n-\t{\n-\t  // This is probably a variable holding a function value or a closure.\n-\t  return TRAVERSE_CONTINUE;\n-\t}\n-      fn = func->named_object();\n-    }\n-  else if (expr->func_expression() != NULL)\n-    fn = expr->func_expression()->named_object();\n-  else\n-    return TRAVERSE_CONTINUE;\n-\n-  Node* caller = this->gogo_->lookup_call_node(this->current_function_);\n-  go_assert(caller != NULL);\n-\n-  // Create the callee here if it hasn't been seen yet.  This could also be a\n-  // function defined in another package.\n-  Node* callee = this->gogo_->add_call_node(fn);\n-  caller->add_edge(callee);\n-  return TRAVERSE_CONTINUE;\n-}\n-\n-// Build the call graph.\n-\n-void\n-Gogo::build_call_graph()\n-{\n-  Build_call_graph build_calls(this);\n-  this->traverse(&build_calls);\n-}\n-\n-// A traversal class used to build a connection graph for each node in the\n-// call graph.\n-\n-class Build_connection_graphs : public Traverse\n-{\n- public:\n-  Build_connection_graphs(Gogo* gogo)\n-    : Traverse(traverse_variables\n-\t       | traverse_statements),\n-      gogo_(gogo), dataflow_(new Dataflow), current_function_(NULL)\n-  {\n-    // Collect dataflow information for this program.\n-    this->dataflow_->initialize(this->gogo_);\n-  }\n-\n-  void\n-  set_current_function(Named_object* function)\n-  { this->current_function_ = function; }\n-\n-  int\n-  variable(Named_object*);\n-\n-  int\n-  statement(Block*, size_t*, Statement*);\n-\n-\n- private:\n-  // Handle a call EXPR referencing OBJECT.\n-  void\n-  handle_call(Named_object* object, Expression* expr);\n-\n-  // Get the initialization values of a composite literal EXPR.\n-  Expression_list*\n-  get_composite_arguments(Expression* expr);\n-\n-  // Handle defining OBJECT as a composite literal EXPR.\n-  void\n-  handle_composite_literal(Named_object* object, Expression* expr);\n-\n-  // Handle analysis of the left and right operands of a binary expression\n-  // with respect to OBJECT.\n-  void\n-  handle_binary(Named_object* object, Expression* expr);\n-\n-  // Resolve the outermost named object of EXPR if there is one.\n-  Named_object*\n-  resolve_var_reference(Expression* expr);\n-\n-  // The IR.\n-  Gogo* gogo_;\n-  // The Dataflow information for this program.\n-  Dataflow* dataflow_;\n-  // The current function whose connection graph is being built.\n-  Named_object* current_function_;\n-};\n-\n-// Given an expression, return the outermost Named_object that it refers to.\n-// This is used to model the simplification between assignments in our analysis.\n-\n-Named_object*\n-Build_connection_graphs::resolve_var_reference(Expression* expr)\n-{\n-  bool done = false;\n-  Expression* orig = expr;\n-  while (!done)\n-    {\n-      // The goal of this loop is to find the variable being referenced, p,\n-      // when the expression is:\n-      switch (expr->classification())\n-      {\n-      case Expression::EXPRESSION_UNARY:\n-\t// &p or *p\n-\texpr = expr->unary_expression()->operand();\n-\tbreak;\n-\n-      case Expression::EXPRESSION_ARRAY_INDEX:\n-\t// p[i][j]\n-\texpr = expr->array_index_expression()->array();\n-\tbreak;\n-\n-      case Expression::EXPRESSION_FIELD_REFERENCE:\n-\t// p.i.j\n-\torig = expr;\n-\texpr = expr->field_reference_expression()->expr();\n-\tbreak;\n-\n-      case Expression::EXPRESSION_RECEIVE:\n-\t// <- p\n-\texpr = expr->receive_expression()->channel();\n-\tbreak;\n-\n-      case Expression::EXPRESSION_BOUND_METHOD:\n-\t// p.c\n-\texpr = expr->bound_method_expression()->first_argument();\n-\tbreak;\n-\n-      case Expression::EXPRESSION_CALL:\n-\t// p.c()\n-\texpr = expr->call_expression()->fn();\n-\tbreak;\n-\n-      case Expression::EXPRESSION_TEMPORARY_REFERENCE:\n-\t// This is used after lowering, so try to retrieve the original\n-\t// expression that might have been lowered into a temporary statement.\n-\texpr = expr->temporary_reference_expression()->statement()->init();\n-\tif (expr == NULL)\n-\t  return NULL;\n-\tbreak;\n-\n-      case Expression::EXPRESSION_SET_AND_USE_TEMPORARY:\n-\texpr = expr->set_and_use_temporary_expression()->expression();\n-\tbreak;\n-\n-      case Expression::EXPRESSION_COMPOUND:\n-\t// p && q\n-\texpr = expr->compound_expression()->init();\n-\tbreak;\n-\n-      case Expression::EXPRESSION_CONDITIONAL:\n-\t// if p {\n-\texpr = expr->conditional_expression()->condition();\n-\tbreak;\n-\n-      case Expression::EXPRESSION_CONVERSION:\n-\t// T(p)\n-\texpr = expr->conversion_expression()->expr();\n-\tbreak;\n-\n-      case Expression::EXPRESSION_TYPE_GUARD:\n-\t// p.(T)\n-\texpr = expr->type_guard_expression()->expr();\n-\tbreak;\n-\n-      case Expression::EXPRESSION_UNSAFE_CONVERSION:\n-\t{\n-\t  Expression* e = expr->unsafe_conversion_expression()->expr();\n-\t  if (e->call_result_expression() != NULL\n-\t      && e->call_result_expression()->index() == 0)\n-\t    {\n-\t      // a, ok := p.(T) gets lowered into a call to one of the interface\n-\t      // to type conversion functions instead of a type guard expression.\n-\t      // We only want to make a connection between a and p, the bool\n-\t      // result should not escape because p escapes.\n-\t      e = e->call_result_expression()->call();\n-\n-\t      Named_object* fn =\n-\t\te->call_expression()->fn()->func_expression()->named_object();\n-\t      std::string fn_name = fn->name();\n-\t      if (fn->package() == NULL\n-\t\t  && fn->is_function_declaration()\n-\t\t  && !fn->func_declaration_value()->asm_name().empty())\n-\t\t{\n-\t\t  if (fn_name == \"ifaceI2E2\"\n-\t\t      || fn_name == \"ifaceI2I2\")\n-\t\t    e = e->call_expression()->args()->at(0);\n-\t\t  else if (fn_name == \"ifaceE2I2\"\n-\t\t\t   || fn_name == \"ifaceI2I2\"\n-\t\t\t   || fn_name == \"ifaceE2T2P\"\n-\t\t\t   || fn_name == \"ifaceI2T2P\"\n-\t\t\t   || fn_name == \"ifaceE2T2\"\n-\t\t\t   || fn_name == \"ifaceI2T2\")\n-\t\t    e = e->call_expression()->args()->at(1);\n-\t\t}\n-\t    }\n-\t  expr = e;\n-\t}\n-\tbreak;\n-\n-      default:\n-\tdone = true;\n-\tbreak;\n-      }\n-    }\n-\n-  Var_expression* ve = expr->var_expression();\n-  if (ve != NULL)\n-    {\n-      Named_object* no = ve->named_object();\n-      go_assert(no->is_variable() || no->is_result_variable());\n-\n-      if (no->is_variable()\n-\t  && no->var_value()->is_closure()\n-\t  && this->current_function_->func_value()->needs_closure())\n-\t{\n-\t  // CURRENT_FUNCTION is a closure and NO is being set to a\n-\t  // variable in the enclosing function.\n-\t  Named_object* closure = this->current_function_;\n-\n-\t  // If NO is a closure variable, the expression is a field\n-\t  // reference to the enclosed variable.\n-\t  Field_reference_expression* fre =\n-\t    orig->deref()->field_reference_expression();\n-\t  if (fre == NULL)\n-\t    return NULL;\n-\n-\t  unsigned int closure_index = fre->field_index();\n-\t  no = closure->func_value()->enclosing_var(closure_index - 1);\n-\t}\n-      return no;\n-    }\n-  return NULL;\n-}\n-\n-// For a call that references OBJECT, associate the OBJECT argument with the\n-// appropriate call parameter.\n-\n-void\n-Build_connection_graphs::handle_call(Named_object* object, Expression* e)\n-{\n-  // Only call expression statements are interesting\n-  // e.g. 'func(var)' for which we can show var does not escape.\n-  Call_expression* ce = e->call_expression();\n-  if (ce == NULL)\n-    return;\n-  else if (ce->args() == NULL)\n-    {\n-      if (ce->fn()->interface_field_reference_expression() != NULL)\n-\t{\n-\t  // This is a call to an interface method with no arguments. OBJECT\n-\t  // must be the receiver and we assume it escapes.\n-\t  Connection_node* rcvr_node =\n-\t    this->gogo_->add_connection_node(object)->connection_node();\n-\t  rcvr_node->set_escape_state(Node::ESCAPE_ARG);\n-\t}\n-      return;\n-    }\n-  \n-  // If the function call that references OBJECT is unknown, we must be\n-  // conservative and assume every argument escapes.  A function call is unknown\n-  // if it is a call to a function stored in a variable or a call to an\n-  // interface method.\n-  if (ce->fn()->func_expression() == NULL)\n-    {\n-      for (Expression_list::const_iterator arg = ce->args()->begin();\n-\t   arg != ce->args()->end();\n-\t   ++arg)\n-\t{\n-\t  Named_object* arg_no = this->resolve_var_reference(*arg);\n-\t  if (arg_no != NULL)\n-\t    {\n-\t      Connection_node* arg_node =\n-\t\tthis->gogo_->add_connection_node(arg_no)->connection_node();\n-\t      arg_node->set_escape_state(Node::ESCAPE_ARG);\n-\t    }\n-\t  else if ((*arg)->call_expression() != NULL)\n-\t    this->handle_call(object, *arg);\n-\t}\n-      return;\n-    }\n-\n-  Named_object* callee = ce->fn()->func_expression()->named_object();\n-  Function_type* fntype;\n-  if (callee->is_function())\n-    fntype = callee->func_value()->type();\n-  else\n-    fntype = callee->func_declaration_value()->type();\n-\n-  Node* callee_node = this->gogo_->lookup_connection_node(callee);\n-  if (callee_node == NULL && callee->is_function())\n-    {\n-      // Might be a nested closure that hasn't been analyzed yet.\n-      Named_object* currfn = this->current_function_;\n-      callee_node = this->gogo_->add_connection_node(callee);\n-      this->current_function_ = callee;\n-      callee->func_value()->traverse(this);\n-      this->current_function_ = currfn;\n-    }\n-\n-  // First find which arguments OBJECT is to CALLEE.  Given a function call,\n-  // OBJECT could be an argument multiple times e.g. CALLEE(OBJECT, OBJECT).\n-  // TODO(cmang): This should be done by the Dataflow analysis so we don't have\n-  // to do it each time we see a function call.  FIXME.\n-  Expression_list* args = ce->args()->copy();\n-  if (fntype->is_varargs()\n-      && args->back()->slice_literal() != NULL)\n-    {\n-      // Is the function is varargs, the last argument is lowered into a slice\n-      // containing all original arguments.  We want to traverse the original\n-      // arguments here.\n-      Slice_construction_expression* sce = args->back()->slice_literal();\n-      for (Expression_list::const_iterator p = sce->vals()->begin();\n-\t   p != sce->vals()->end();\n-\t   ++p)\n-\t{\n-\t  if (*p != NULL)\n-\t    args->push_back(*p);\n-\t}\n-    }\n-\n-  // ARG_POSITION is just a counter used to keep track of the index in the list\n-  // of arguments to this call.  In a method call, the receiver will always be\n-  // the first argument.  When looking at the function type, it will not be the\n-  // first element in the parameter list; instead, the receiver will be\n-  // non-NULL.  For convenience, mark the position of the receiver argument\n-  // as negative.\n-  int arg_position = fntype->is_method() ? -1 : 0;\n-  std::list<int> positions;\n-  for (Expression_list::const_iterator p = args->begin();\n-       p != args->end();\n-       ++p, ++arg_position)\n-    {\n-      Expression* arg = *p;\n-\n-      // An argument might be a chain of method calls, some of which are\n-      // converted from value to pointer types.  Just remove the unary\n-      // conversion if it exists.\n-      if (arg->unary_expression() != NULL)\n-\targ = arg->unary_expression()->operand();\n-\n-      // The reference to OBJECT might be in a nested call argument.\n-      if (arg->call_expression() != NULL)\n-\tthis->handle_call(object, arg);\n-\n-      std::vector<Named_object*> objects;\n-      if (arg->is_composite_literal()\n-\t  || arg->heap_expression() != NULL)\n-\t{\n-\t  // For a call that has a composite literal as an argument, traverse\n-\t  // the initializers of the composite literal for extra objects to\n-\t  // associate with a parameter in this function.\n-\t  Expression_list* comp_args = this->get_composite_arguments(arg);\n-\t  if (comp_args == NULL)\n-\t    continue;\n-\n-\t  for (size_t i = 0; i < comp_args->size(); ++i)\n-\t    {\n-\t      Expression* comp_arg = comp_args->at(i);\n-\t      if (comp_arg == NULL)\n-\t\tcontinue;\n-\t      else if (comp_arg->is_composite_literal()\n-\t\t       || comp_arg->heap_expression() != NULL)\n-\t\t{\n-\t\t  // Of course, there are situations where a composite literal\n-\t\t  // initialization value is also a composite literal.\n-\t\t  Expression_list* nested_args =\n-\t\t    this->get_composite_arguments(comp_arg);\n-\t\t  if (nested_args != NULL)\n-\t\t    comp_args->append(nested_args);\n-\t\t}\n-\n-\t      Named_object* no = this->resolve_var_reference(comp_arg);\n-\t      if (no != NULL)\n-\t\tobjects.push_back(no);\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  Named_object* arg_no = this->resolve_var_reference(arg);\n-\t  if (arg_no != NULL)\n-\t    objects.push_back(arg_no);\n-\t}\n-\n-      // There are no variables to consider for this parameter.\n-      if (objects.empty())\n-\tcontinue;\n-\n-      for (std::vector<Named_object*>::const_iterator p1 = objects.begin();\n-\t   p1 != objects.end();\n-\t   ++p1)\n-\t{\n-\t  // If CALLEE is defined in another package and we have imported escape\n-\t  // information about its parameters, update the escape state of this\n-\t  // argument appropriately. If there is no escape information for this\n-\t  // function, we have to assume all arguments escape.\n-\t  if (callee->package() != NULL\n-\t      || fntype->is_builtin())\n-\t    {\n-\t      Node::Escapement_lattice param_escape = Node::ESCAPE_NONE;\n-\t      if (fntype->has_escape_info())\n-\t\t{\n-\t\t  if (arg_position == -1)\n-\t\t    {\n-\t\t      // Use the escape info from the receiver.\n-\t\t      param_escape = fntype->receiver_escape_state();\n-\t\t    }\n-\t\t  else if (fntype->parameters() != NULL)\n-\t\t    {\n-\t\t      const Node::Escape_states* states =\n-\t\t\tfntype->parameter_escape_states();\n-\n-\t\t      int param_size = fntype->parameters()->size();\n-\t\t      if (arg_position >= param_size)\n-\t\t\t{\n-\t\t\t  go_assert(fntype->is_varargs());\n-\t\t\t  param_escape = states->back();\n-\t\t\t}\n-\t\t      else\n-\t\t\tparam_escape =\n-\t\t\t  fntype->parameter_escape_states()->at(arg_position);\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\tparam_escape = Node::ESCAPE_ARG;\n-\n-\t      Connection_node* arg_node =\n-\t\tthis->gogo_->add_connection_node(*p1)->connection_node();\n-\t      if (arg_node->escape_state() > param_escape)\n-\t\targ_node->set_escape_state(param_escape);\n-\t    }\n-\n-\t  if (*p1 == object)\n-\t    positions.push_back(arg_position);\n-\t}\n-    }\n-\n-  // If OBJECT was not found in CALLEE's arguments, OBJECT is likely a\n-  // subexpression of one of the arguments e.g. CALLEE(a[OBJECT]).  This call\n-  // does not give any useful information about whether OBJECT escapes.\n-  if (positions.empty())\n-    return;\n-\n-  // The idea here is to associate the OBJECT in the caller context with the\n-  // parameter in the callee context.  This also needs to consider varargs.\n-  // This only works with functions with arguments.\n-  if (!callee->is_function())\n-    return;\n-\n-  // Use the bindings in the callee to lookup the associated parameter.\n-  const Bindings* callee_bindings = callee->func_value()->block()->bindings();\n-\n-  // Next find the corresponding named parameters in the function signature.\n-  const Typed_identifier_list* params = fntype->parameters();\n-  for (std::list<int>::const_iterator pos = positions.begin();\n-       params != NULL && pos != positions.end();\n-       ++pos)\n-    {\n-      std::string param_name;\n-      if (*pos >= 0 && params->size() <= static_cast<size_t>(*pos))\n-\t{\n-\t  // There were more arguments than there are parameters. This must be\n-\t  // varargs and the argument corresponds to the last parameter.\n-\t  go_assert(fntype->is_varargs());\n-\t  param_name = params->back().name();\n-\t}\n-      else if (*pos < 0)\n-\t{\n-\t  // We adjust the recorded position of method arguments by one to\n-\t  // account for the receiver, so *pos == -1 implies this is the\n-\t  // receiver and this must be a method call.\n-\t  go_assert(fntype->is_method() && fntype->receiver() != NULL);\n-\t  param_name = fntype->receiver()->name();\n-\t}\n-      else\n-\tparam_name = params->at(*pos).name();\n-\n-      if (Gogo::is_sink_name(param_name) || param_name.empty())\n-\tcontinue;\n-\n-      // Get the object for the associated parameter in this binding.\n-      Named_object* param_no = callee_bindings->lookup_local(param_name);\n-      go_assert(param_no != NULL);\n-\n-      // Add an edge from ARG_NODE in the caller context to the PARAM_NODE in\n-      // the callee context.\n-      if (object->is_variable() && object->var_value()->is_closure())\n-\t{\n-\t  int position = *pos;\n-\t  if (fntype->is_method())\n-\t    ++position;\n-\n-\t  // Calling a function within a closure with a closure argument.\n-\t  // Resolve the real variable using the closure argument.\n-\t  object = this->resolve_var_reference(ce->args()->at(position));\n-\t}\n-\n-      Node* arg_node = this->gogo_->add_connection_node(object);\n-      Node* param_node = this->gogo_->add_connection_node(param_no);\n-      param_node->add_edge(arg_node);\n-    }\n-\n-  // This is a method call with one argument: the receiver.\n-  if (params == NULL)\n-    {\n-      go_assert(positions.size() == 1);\n-      std::string rcvr_name = fntype->receiver()->name();\n-      if (Gogo::is_sink_name(rcvr_name) || rcvr_name.empty())\n-\treturn;\n-\n-      Named_object* rcvr_no = callee_bindings->lookup_local(rcvr_name);\n-      Node* arg_node = this->gogo_->add_connection_node(object);\n-      Node* rcvr_node = this->gogo_->add_connection_node(rcvr_no);\n-      rcvr_node->add_edge(arg_node);\n-    }\n-}\n-\n-// Given a composite literal expression, return the initialization values.\n-// This is used to handle situations where call and composite literal\n-// expressions have nested composite literals as arguments/initializers.\n-\n-Expression_list*\n-Build_connection_graphs::get_composite_arguments(Expression* expr)\n-{\n-  // A heap expression is just any expression that takes the address of a\n-  // composite literal.\n-  if (expr->heap_expression() != NULL)\n-    expr = expr->heap_expression()->expr();\n-\n-  switch (expr->classification())\n-    {\n-    case Expression::EXPRESSION_STRUCT_CONSTRUCTION:\n-      return expr->struct_literal()->vals();\n-\n-    case Expression::EXPRESSION_FIXED_ARRAY_CONSTRUCTION:\n-      return expr->array_literal()->vals();\n-\n-    case Expression::EXPRESSION_SLICE_CONSTRUCTION:\n-      return expr->slice_literal()->vals();\n-\n-    case Expression::EXPRESSION_MAP_CONSTRUCTION:\n-      return expr->map_literal()->vals();\n-\n-    default:\n-      return NULL;\n-    }\n-}\n-\n-// Given an OBJECT defined as a composite literal EXPR, create edges between\n-// OBJECT and all variables referenced in EXPR.\n-\n-void\n-Build_connection_graphs::handle_composite_literal(Named_object* object,\n-\t\t\t\t\t\t  Expression* expr)\n-{\n-  Expression_list* args = this->get_composite_arguments(expr);\n-  if (args == NULL)\n-    return;\n-\n-  std::vector<Named_object*> composite_args;\n-  for (Expression_list::const_iterator p = args->begin();\n-       p != args->end();\n-       ++p)\n-    {\n-      if (*p == NULL)\n-\tcontinue;\n-      else if ((*p)->call_expression() != NULL)\n-\tthis->handle_call(object, *p);\n-      else if ((*p)->func_expression() != NULL)\n-\tcomposite_args.push_back((*p)->func_expression()->named_object());\n-      else if ((*p)->is_composite_literal()\n-\t       || (*p)->heap_expression() != NULL)\n-\tthis->handle_composite_literal(object, *p);\n-\n-      Named_object* no = this->resolve_var_reference(*p);\n-      if (no != NULL)\n-\tcomposite_args.push_back(no);\n-    }\n-\n-  Node* object_node = this->gogo_->add_connection_node(object);\n-  for (std::vector<Named_object*>::const_iterator p = composite_args.begin();\n-       p != composite_args.end();\n-       ++p)\n-    {\n-      Node* arg_node = this->gogo_->add_connection_node(*p);\n-      object_node->add_edge(arg_node);\n-    }\n-}\n-\n-// Given an OBJECT reference in a binary expression E, analyze the left and\n-// right operands for possible edges.\n-\n-void\n-Build_connection_graphs::handle_binary(Named_object* object, Expression* e)\n-{\n-  Binary_expression* be = e->binary_expression();\n-  go_assert(be != NULL);\n-  Expression* left = be->left();\n-  Expression* right = be->right();\n-\n-  if (left->call_result_expression() != NULL)\n-    left = left->call_result_expression()->call();\n-  if (left->call_expression() != NULL)\n-    this->handle_call(object, left);\n-  else if (left->binary_expression() != NULL)\n-    this->handle_binary(object, left);\n-  if (right->call_result_expression() != NULL)\n-    right = right->call_result_expression()->call();\n-  if (right->call_expression() != NULL)\n-    this->handle_call(object, right);\n-  else if (right->binary_expression() != NULL)\n-    this->handle_binary(object, right);\n-}\n-\n-// Create connection nodes for each variable in a called function.\n-\n-int\n-Build_connection_graphs::variable(Named_object* var)\n-{\n-  Node* var_node = this->gogo_->add_connection_node(var);\n-  Node* root = this->gogo_->lookup_connection_node(this->current_function_);\n-  go_assert(root != NULL);\n-\n-  // Add VAR to the set of objects in CURRENT_FUNCTION's connection graph.\n-  root->connection_node()->add_object(var_node);\n-\n-  // A function's results always escape.\n-  if (var->is_result_variable())\n-    var_node->connection_node()->set_escape_state(Node::ESCAPE_ARG);\n-\n-  // Create edges from a variable to its definitions.\n-  const Dataflow::Defs* defs = this->dataflow_->find_defs(var);\n-  if (defs != NULL)\n-    {\n-      for (Dataflow::Defs::const_iterator p = defs->begin();\n-\t   p != defs->end();\n-\t   ++p)\n-\t{\n-\t  Expression* def = p->val;\n-\t  if (def == NULL)\n-\t    continue;\n-\n-\t  if (def->conversion_expression() != NULL)\n-\t    def = def->conversion_expression()->expr();\n-\t  if (def->func_expression() != NULL)\n-\t    {\n-\t      // VAR is being defined as a function object.\n-\t      Named_object* fn = def->func_expression()->named_object();\n-\t      Node* fn_node = this->gogo_->add_connection_node(fn);\n-\t      var_node->add_edge(fn_node);\n-\t    }\n-\t  else if(def->is_composite_literal()\n-\t\t  || def->heap_expression() != NULL)\n-\t    this->handle_composite_literal(var, def);\n-\n-\t  Named_object* ref = this->resolve_var_reference(def);\n-\t  if (ref == NULL)\n-\t    continue;\n-\n-\t  Node* ref_node = this->gogo_->add_connection_node(ref);\n-\t  var_node->add_edge(ref_node);\n-\t}\n-    }\n-\n-  // Create edges from a reference to a variable.\n-  const Dataflow::Refs* refs = this->dataflow_->find_refs(var);\n-  if (refs != NULL)\n-    {\n-      for (Dataflow::Refs::const_iterator p = refs->begin();\n-\t   p != refs->end();\n-\t   ++p)\n-\t{\n-\t  switch (p->statement->classification())\n-\t  {\n-\t  case Statement::STATEMENT_ASSIGNMENT:\n-\t    {\n-\t      Assignment_statement* assn =\n-\t\tp->statement->assignment_statement();\n-\t      Named_object* lhs_no = this->resolve_var_reference(assn->lhs());\n-\t      Named_object* rhs_no = this->resolve_var_reference(assn->rhs());\n-\n-\t      Expression* rhs = assn->rhs();\n-\t      if (rhs->is_composite_literal()\n-\t\t  || rhs->heap_expression() != NULL)\n-\t\tthis->handle_composite_literal(var, rhs);\n-\n-\t      if (rhs->call_result_expression() != NULL)\n-\t\t{\n-\t\t  // V's initialization will be a call result if\n-\t\t  // V, V1 := call(VAR).\n-\t\t  // There are no useful edges to make from V, but we want\n-\t\t  // to make sure we handle the call that references VAR.\n-\t\t  rhs = rhs->call_result_expression()->call();\n-\t\t}\n-\t      if (rhs->call_expression() != NULL)\n-\t\tthis->handle_call(var, rhs);\n-\n-\t      // If there is no standalone variable on the rhs, this could be a\n-\t      // binary expression, which isn't interesting for analysis or a\n-\t      // composite literal or call expression, which we handled above.\n-\t      // If the underlying variable on the rhs isn't VAR then it is\n-\t      // likely an indexing expression where VAR is the index.\n-\t      if(lhs_no == NULL\n-\t\t || rhs_no == NULL\n-\t\t || rhs_no != var)\n-\t\tbreak;\n-\n-\t      Node* def_node = this->gogo_->add_connection_node(lhs_no);\n-\t      def_node->add_edge(var_node);\n-\t    }\n-\t    break;\n-\n-\t  case Statement::STATEMENT_SEND:\n-\t    {\n-\t      Send_statement* send = p->statement->send_statement();\n-\t      Named_object* chan_no = this->resolve_var_reference(send->channel());\n-\t      Named_object* val_no = resolve_var_reference(send->val());\n-\n-\t      if (chan_no == NULL || val_no == NULL)\n-\t\tbreak;\n-\n-\t      Node* chan_node = this->gogo_->add_connection_node(chan_no);\n-\t      Node* val_node = this->gogo_->add_connection_node(val_no);\n-\t      chan_node->add_edge(val_node);\n-\t    }\n-\t    break;\n-\n-\t  case Statement::STATEMENT_EXPRESSION:\n-\t    {\n-\t      Expression* call = p->statement->expression_statement()->expr();\n-\t      if (call->call_result_expression() != NULL)\n-\t\tcall = call->call_result_expression()->call();\n-\t      this->handle_call(var, call);\n-\t    }\n-\t    break;\n-\n-\t  case Statement::STATEMENT_GO:\n-\t  case Statement::STATEMENT_DEFER:\n-\t    // Any variable referenced via a go or defer statement escapes to\n-\t    // a different goroutine.\n-\t    if (var_node->connection_node()->escape_state() > Node::ESCAPE_ARG)\n-\t      var_node->connection_node()->set_escape_state(Node::ESCAPE_ARG);\n-\t    this->handle_call(var, p->statement->thunk_statement()->call());\n-\t    break;\n-\n-\t  case Statement::STATEMENT_IF:\n-\t    {\n-\t      // If this is a reference via an if statement, it is interesting\n-\t      // if there is a function call in the condition.  References in\n-\t      // the then and else blocks would be discovered in an earlier\n-\t      // case.\n-\t      If_statement* if_stmt = p->statement->if_statement();\n-\t      Expression* cond = if_stmt->condition();\n-\t      if (cond->call_expression() != NULL)\n-\t\tthis->handle_call(var, cond);\n-\t      else if (cond->binary_expression() != NULL)\n-\t\tthis->handle_binary(var, cond);\n-\t    }\n-\t    break;\n-\n-\t  case Statement::STATEMENT_VARIABLE_DECLARATION:\n-\t    {\n-\t      // VAR could be referenced as the initialization for another\n-\t      // variable, V e.g. V := call(VAR) or V := &T{field: VAR}.\n-\t      Variable_declaration_statement* decl =\n-\t\tp->statement->variable_declaration_statement();\n-\t      Named_object* decl_no = decl->var();\n-\t      Variable* v = decl_no->var_value();\n-\n-\t      Expression* init = v->init();\n-\t      if (init == NULL)\n-\t\tbreak;\n-\n-\t      if (init->is_composite_literal()\n-\t\t  || init->heap_expression() != NULL)\n-\t\t{\n-\t\t  // Create edges between DECL_NO and each named object in the\n-\t\t  // composite literal.\n-\t\t  this->handle_composite_literal(decl_no, init);\n-\t\t}\n-\n-\t      if (init->call_result_expression() != NULL)\n-\t\tinit = init->call_result_expression()->call();\n-\t      if (init->call_expression() != NULL)\n-\t\tthis->handle_call(var, init);\n-\t      else if (init->binary_expression() != NULL)\n-\t\tthis->handle_binary(var, init);\n-\t    }\n-\t    break;\n-\n-\t  case Statement::STATEMENT_TEMPORARY:\n-\t    {\n-\t      // A call to a function with mutliple results that references VAR\n-\t      // will be lowered into a temporary at this point.  Make sure the\n-\t      // call that references VAR is handled.\n-\t      Expression* init = p->statement->temporary_statement()->init();\n-\t      if (init == NULL)\n-\t\tbreak;\n-\t      else if (init->call_result_expression() != NULL)\n-\t\t{\n-\t\t  Expression* call = init->call_result_expression()->call();\n-\t\t  this->handle_call(var, call);\n-\t\t}\n-\t    }\n-\n-\t  default:\n-\t    break;\n-\t  }\n-\t}\n-    }\n-  return TRAVERSE_CONTINUE;\n-}\n-\n-// Traverse statements to find interesting references that might have not\n-// been recorded in the dataflow analysis.  For example, many statements\n-// in closures are not properly recorded during dataflow analysis.  This should\n-// handle all of the cases handled above in statements that reference a\n-// variable.  FIXME.\n-\n-int\n-Build_connection_graphs::statement(Block*, size_t*, Statement* s)\n-{\n-  switch(s->classification())\n-  {\n-  case Statement::STATEMENT_ASSIGNMENT:\n-    {\n-      Assignment_statement* assn = s->assignment_statement();\n-      Named_object* lhs_no = this->resolve_var_reference(assn->lhs());\n-\n-      if (lhs_no == NULL)\n-\tbreak;\n-\n-      Expression* rhs = assn->rhs();\n-      if (rhs->temporary_reference_expression() != NULL)\n-\trhs = rhs->temporary_reference_expression()->statement()->init();\n-      if (rhs == NULL)\n-\tbreak;\n-\n-      if (rhs->call_result_expression() != NULL)\n-\trhs = rhs->call_result_expression()->call();\n-      if (rhs->call_expression() != NULL)\n-\t{\n-\t  // It's not clear what variables we are trying to find references to\n-\t  // so just use the arguments to this call.\n-\t  Expression_list* args = rhs->call_expression()->args();\n-\t  if (args == NULL)\n-\t    break;\n-\n-\t  for (Expression_list::const_iterator p = args->begin();\n-\t       p != args->end();\n-\t       ++p)\n-\t    {\n-\t      Named_object* no = this->resolve_var_reference(*p);\n-\t      if (no != NULL) {\n-\t\tNode* lhs_node = this->gogo_->add_connection_node(lhs_no);\n-\t\tNode* rhs_node = this->gogo_->add_connection_node(no);\n-\t\tlhs_node->add_edge(rhs_node);\n-\t      }\n-\t    }\n-\n-\t  this->handle_call(lhs_no, rhs);\n-\t}\n-      else if (rhs->func_expression() != NULL)\n-\t{\n-\t  Node* lhs_node = this->gogo_->add_connection_node(lhs_no);\n-\t  Named_object* fn = rhs->func_expression()->named_object();\n-\t  Node* fn_node = this->gogo_->add_connection_node(fn);\n-\t  lhs_node->add_edge(fn_node);\n-\t}\n-      else\n-\t{\n-\t  Named_object* rhs_no = this->resolve_var_reference(rhs);\n-\t  if (rhs_no != NULL)\n-\t    {\n-\t      Node* lhs_node = this->gogo_->add_connection_node(lhs_no);\n-\t      Node* rhs_node = this->gogo_->add_connection_node(rhs_no);\n-\t      lhs_node->add_edge(rhs_node);\n-\t    }\n-\t}\n-    }\n-    break;\n-\n-  case Statement::STATEMENT_SEND:\n-    {\n-      Send_statement* send = s->send_statement();\n-      Named_object* chan_no = this->resolve_var_reference(send->channel());\n-      Named_object* val_no = this->resolve_var_reference(send->val());\n-\n-      if (chan_no == NULL || val_no == NULL)\n-\tbreak;\n-\n-      Node* chan_node = this->gogo_->add_connection_node(chan_no);\n-      Node* val_node = this->gogo_->add_connection_node(val_no);\n-      chan_node->add_edge(val_node);\n-    }\n-    break;\n-\n-  case Statement::STATEMENT_EXPRESSION:\n-    {\n-      Expression* expr = s->expression_statement()->expr();\n-      if (expr->call_result_expression() != NULL)\n-\texpr = expr->call_result_expression()->call();\n-      if (expr->call_expression() != NULL)\n-\t{\n-\t  // It's not clear what variables we are trying to find references to\n-\t  // so just use the arguments to this call.\n-\t  Expression_list* args = expr->call_expression()->args();\n-\t  if (args == NULL)\n-\t    break;\n-\n-\t  for (Expression_list::const_iterator p = args->begin();\n-\t       p != args->end();\n-\t       ++p)\n-\t    {\n-\t      Named_object* no = this->resolve_var_reference(*p);\n-\t      if (no != NULL)\n-\t\tthis->handle_call(no, expr);\n-\t    }\n-\t}\n-    }\n-    break;\n-\n-  case Statement::STATEMENT_GO:\n-  case Statement::STATEMENT_DEFER:\n-    {\n-      // Any variable referenced via a go or defer statement escapes to\n-      // a different goroutine.\n-      Expression* call = s->thunk_statement()->call();\n-      if (call->call_expression() != NULL)\n-\t{\n-\t  // It's not clear what variables we are trying to find references to\n-\t  // so just use the arguments to this call.\n-\t  Expression_list* args = call->call_expression()->args();\n-\t  if (args == NULL)\n-\t    break;\n-\n-\t  for (Expression_list::const_iterator p = args->begin();\n-\t       p != args->end();\n-\t       ++p)\n-\t    {\n-\t      Named_object* no = this->resolve_var_reference(*p);\n-\t      if (no != NULL)\n-\t\tthis->handle_call(no, call);\n-\t    }\n-\t}\n-    }\n-    break;\n-\n-  case Statement::STATEMENT_VARIABLE_DECLARATION:\n-    {\n-      Variable_declaration_statement* decl =\n-\ts->variable_declaration_statement();\n-      Named_object* decl_no = decl->var();\n-      Variable* v = decl_no->var_value();\n-\n-      Expression* init = v->init();\n-      if (init == NULL)\n-\tbreak;\n-\n-      if (init->is_composite_literal()\n-\t  || init->heap_expression() != NULL)\n-\t{\n-\t  // Create edges between DECL_NO and each named object in the\n-\t  // composite literal.\n-\t  this->handle_composite_literal(decl_no, init);\n-\t}\n-\n-      if (init->call_result_expression() != NULL)\n-\tinit = init->call_result_expression()->call();\n-      if (init->call_expression() != NULL)\n-\t{\n-\t  // It's not clear what variables we are trying to find references to\n-\t  // so just use the arguments to this call.\n-\t  Expression_list* args = init->call_expression()->args();\n-\t  if (args == NULL)\n-\t    break;\n-\n-\t  for (Expression_list::const_iterator p = args->begin();\n-\t       p != args->end();\n-\t       ++p)\n-\t    {\n-\t      Named_object* no = this->resolve_var_reference(*p);\n-\t      if (no != NULL)\n-\t\tthis->handle_call(no, init);\n-\t    }\n-\t}\n-    }\n-    break;\n-\n-  default:\n-    break;\n-  }\n-\n-  return TRAVERSE_CONTINUE;\n-}\n-\n-// Build the connection graphs for each function present in the call graph.\n-\n-void\n-Gogo::build_connection_graphs()\n-{\n-  Build_connection_graphs build_conns(this);\n-\n-  for (std::set<Node*>::const_iterator p = this->call_graph_.begin();\n-       p != this->call_graph_.end();\n-       ++p)\n-    {\n-      Named_object* func = (*p)->object();\n-      \n-      go_assert(func->is_function() || func->is_function_declaration());\n-      Function_type* fntype;\n-      if (func->is_function())\n-\tfntype = func->func_value()->type();\n-      else\n-\tfntype = func->func_declaration_value()->type();\n-      if (fntype->is_builtin())\n-\tcontinue;\n-\n-      this->add_connection_node(func);\n-      build_conns.set_current_function(func);\n-      if (func->is_function())\n-\t{\n-\t  // A pointer receiver of a method always escapes from the method.\n-\t  if (fntype->is_method() &&\n-\t      fntype->receiver()->type()->points_to() != NULL)\n-\t    {\n-\t      const Bindings* callee_bindings =\n-\t\tfunc->func_value()->block()->bindings();\n-\t      std::string rcvr_name = fntype->receiver()->name();\n-\t      if (Gogo::is_sink_name(rcvr_name) || rcvr_name.empty())\n-\t\treturn;\n-\n-\t      Named_object* rcvr_no = callee_bindings->lookup_local(rcvr_name);\n-\t      Node* rcvr_node = this->add_connection_node(rcvr_no);\n-\t      rcvr_node->connection_node()->set_escape_state(Node::ESCAPE_ARG);\n-\t    }\n-\t  func->func_value()->traverse(&build_conns);\n-\t}\n-    }\n-}\n-\n-void\n-Gogo::analyze_reachability()\n-{\n-  std::list<Node*> worklist;\n-\n-  // Run reachability analysis on all globally escaping objects.\n-  for (std::set<Node*>::const_iterator p = this->global_connections_.begin();\n-       p != this->global_connections_.end();\n-       ++p)\n-    worklist.push_back(*p);\n-\n-  while (!worklist.empty())\n-    {\n-      Node* m = worklist.front();\n-      worklist.pop_front();\n-\n-      std::set<Node*> reachable = m->edges();\n-      if (m->object()->is_function()\n-\t  && m->object()->func_value()->needs_closure())\n-\t{\n-\t  // If a closure escapes everything it closes over also escapes.\n-\t  Function* closure = m->object()->func_value();\n-\t  for (size_t i = 0; i < closure->closure_field_count(); i++)\n-\t    {\n-\t      Named_object* enclosed = closure->enclosing_var(i);\n-\t      Node* enclosed_node = this->lookup_connection_node(enclosed);\n-\t      go_assert(enclosed_node != NULL);\n-\t      reachable.insert(enclosed_node);\n-\t    }\n-\t}\n-      for (std::set<Node*>::iterator n = reachable.begin();\n-\t   n != reachable.end();\n-\t   ++n)\n-\t{\n-\t  // If an object can be reached from a node with ESCAPE_GLOBAL,\n-\t  // it also must ESCAPE_GLOBAL.\n-\t  if ((*n)->connection_node()->escape_state() != Node::ESCAPE_GLOBAL)\n-\t    {\n-\t      (*n)->connection_node()->set_escape_state(Node::ESCAPE_GLOBAL);\n-\t      worklist.push_back(*n);\n-\t    }\n-\t}\n-    }\n-\n-  // Run reachability analysis on all objects that escape via arguments.\n-  for (Named_escape_nodes::const_iterator p =\n-\t this->named_connection_nodes_.begin();\n-       p != this->named_connection_nodes_.end();\n-       ++p)\n-    {\n-      if (p->second->connection_node()->escape_state() < Node::ESCAPE_NONE)\n-\tworklist.push_back(p->second);\n-    }\n-\n-  while (!worklist.empty())\n-    {\n-      Node* m = worklist.front();\n-      worklist.pop_front();\n-\n-      std::set<Node*> reachable = m->edges();\n-      if (m->object()->is_function()\n-\t  && m->object()->func_value()->needs_closure())\n-\t{\n-\t  // If a closure escapes everything it closes over also escapes.\n-\t  Function* closure = m->object()->func_value();\n-\t  for (size_t i = 0; i < closure->closure_field_count(); i++)\n-\t    {\n-\t      Named_object* enclosed = closure->enclosing_var(i);\n-\t      Node* enclosed_node = this->lookup_connection_node(enclosed);\n-\t      go_assert(enclosed_node != NULL);\n-\t      reachable.insert(enclosed_node);\n-\t    }\n-\t}\n-      for (std::set<Node*>::iterator n = reachable.begin();\n-\t   n != reachable.end();\n-\t   ++n)\n-\t{\n-\t  // If an object can be reached from a node with ESCAPE_ARG,\n-\t  // it is ESCAPE_ARG or ESCAPE_GLOBAL.\n-\t  Node::Escapement_lattice e = m->connection_node()->escape_state();\n-\t  if ((*n)->connection_node()->escape_state() > e)\n-\t    {\n-\t      (*n)->connection_node()->set_escape_state(e);\n-\t      worklist.push_back(*n);\n-\t    }\n-\t}\n-    }  \n-}\n-\n-// Iterate over all functions analyzed in the analysis, recording escape\n-// information for each receiver and parameter.\n-\n-void\n-Gogo::mark_escaping_signatures()\n-{\n-  for (std::set<Node*>::const_iterator p = this->call_graph_.begin();\n-       p != this->call_graph_.end();\n-       ++p)\n-    {\n-      Named_object* fn = (*p)->object();\n-      if (!fn->is_function())\n-\tcontinue;\n-\n-      Function* func = fn->func_value();\n-      Function_type* fntype = func->type();\n-      const Bindings* bindings = func->block()->bindings();\n-\n-      // If this is a method, set the escape state of the receiver.\n-      if (fntype->is_method())\n-\t{\n-\t  std::string rcvr_name = fntype->receiver()->name();\n-\t  if (rcvr_name.empty() || Gogo::is_sink_name(rcvr_name))\n-\t    fntype->set_receiver_escape_state(Node::ESCAPE_NONE);\n-\t  else\n-\t    {\n-\t      Named_object* rcvr_no = bindings->lookup_local(rcvr_name);\n-\t      go_assert(rcvr_no != NULL);\n-\n-\t      Node* rcvr_node = this->lookup_connection_node(rcvr_no);\n-\t      if (rcvr_node != NULL)\n-\t\t{\n-\t\t  Node::Escapement_lattice e =\n-\t\t    rcvr_node->connection_node()->escape_state();\n-\t\t  fntype->set_receiver_escape_state(e);\n-\t\t}\n-\t      else\n-\t\tfntype->set_receiver_escape_state(Node::ESCAPE_NONE);\n-\t    }\n-\t  fntype->set_has_escape_info();\n-\t}\n-\n-      const Typed_identifier_list* params = fntype->parameters();\n-      if (params == NULL)\n-\tcontinue;\n-\n-      fntype->set_has_escape_info();\n-      Node::Escape_states* param_escape_states = new Node::Escape_states;\n-      for (Typed_identifier_list::const_iterator p1 = params->begin();\n-\t   p1 != params->end();\n-\t   ++p1)\n-\t{\n-\t  std::string param_name = p1->name();\n-\t  if (param_name.empty() || Gogo::is_sink_name(param_name))\n-\t    param_escape_states->push_back(Node::ESCAPE_NONE);\n-\t  else\n-\t    {\n-\t      Named_object* param_no = bindings->lookup_local(param_name);\n-\t      go_assert(param_no != NULL);\n-\n-\t      Node* param_node = this->lookup_connection_node(param_no);\n-\t      if (param_node == NULL)\n-\t\t{\n-\t\t  param_escape_states->push_back(Node::ESCAPE_NONE);\n-\t\t  continue;\n-\t\t}\n-\n-\t      Node::Escapement_lattice e =\n-\t\tparam_node->connection_node()->escape_state();\n-\t      param_escape_states->push_back(e);\n-\t    }\n-\t}\n-      go_assert(params->size() == param_escape_states->size());\n-      fntype->set_parameter_escape_states(param_escape_states);\n-    }\n-}\n-\n-class Optimize_allocations : public Traverse\n-{\n- public:\n-  Optimize_allocations(Gogo* gogo)\n-    : Traverse(traverse_variables),\n-      gogo_(gogo)\n-  { }\n-\n-  int\n-  variable(Named_object*);\n-\n- private:\n-  // The IR.\n-  Gogo* gogo_;\n-};\n-\n-// The -fgo-optimize-alloc flag activates this escape analysis.\n-\n-Go_optimize optimize_allocation_flag(\"allocs\");\n-\n-// Propagate escape information for each variable.\n-\n-int\n-Optimize_allocations::variable(Named_object* var)\n-{\n-  Node* var_node = this->gogo_->lookup_connection_node(var);\n-  if (var_node == NULL\n-      || var_node->connection_node()->escape_state() != Node::ESCAPE_NONE)\n-    return TRAVERSE_CONTINUE;\n-\n-  if (var->is_variable())\n-    {\n-      var->var_value()->set_does_not_escape();\n-      if (var->var_value()->init() != NULL\n-\t  && var->var_value()->init()->allocation_expression() != NULL)\n-\t{\n-\t  Allocation_expression* alloc =\n-\t    var->var_value()->init()->allocation_expression();\n-\t  alloc->set_allocate_on_stack();\n-\t}\n-    }\n-\n-  return TRAVERSE_CONTINUE;\n-}\n-\n-// Perform escape analysis on this program and optimize allocations using\n-// the derived information if -fgo-optimize-allocs.\n-\n-void\n-Gogo::optimize_allocations(const char** filenames)\n-{\n-  if (!::optimize_allocation_flag.is_enabled() || saw_errors())\n-    return;\n-\n-  // Build call graph for this program.\n-  this->build_call_graph();\n-\n-  // Dump the call graph for this program if -fgo-dump-calls is enabled.\n-  this->dump_call_graph(filenames[0]);\n-\n-  // Build the connection graphs for this program.\n-  this->build_connection_graphs();\n-\n-  // Dump the connection graphs if -fgo-dump-connections is enabled.\n-  this->dump_connection_graphs(filenames[0]);\n-\n-  // Given the connection graphs for this program, perform a reachability\n-  // analysis to determine what objects escape.\n-  this->analyze_reachability();\n-\n-  // Propagate escape information to variables and variable initializations.\n-  Optimize_allocations optimize_allocs(this);\n-  this->traverse(&optimize_allocs);\n-\n-  // Store escape information for a function's receivers and parameters in the\n-  // function's signature for use when exporting package information.\n-  this->mark_escaping_signatures();\n-}"}, {"sha": "42c79f61fad525def844bb15259d5e17ad7d3518", "filename": "gcc/go/gofrontend/escape.h", "status": "removed", "additions": 0, "deletions": 310, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52d11a4bbf22f3312a559e63c819c2714c633694/gcc%2Fgo%2Fgofrontend%2Fescape.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52d11a4bbf22f3312a559e63c819c2714c633694/gcc%2Fgo%2Fgofrontend%2Fescape.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fescape.h?ref=52d11a4bbf22f3312a559e63c819c2714c633694", "patch": "@@ -1,310 +0,0 @@\n-// escape.h -- Go frontend escape analysis.     -*- C++ -*-\n-\n-// Copyright 2015 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-#ifndef GO_ESCAPE_H\n-#define GO_ESCAPE_H\n-\n-#include \"go-system.h\"\n-#include \"string-dump.h\"\n-\n-class Call_node;\n-class Connection_node;\n-class Connection_dump_context;\n-class Gogo;\n-class Named_object;\n-\n-// A basic escape analysis implementation for the Go frontend based on the\n-// algorithm from \"Escape Analysis for Java\" by Choi et. al in OOPSLA '99.\n-// This is a simplified version of the flow insensitive analysis with the goal\n-// of reducing the overhead cost of garbage collection by allocating objects\n-// on the stack when they do not escape the function they were created in.\n-//\n-// A major simplification is that the analysis only implements what Choi refers\n-// to as \"deferred edges\" which are used to used model assignments that copy\n-// references from one variable to another e.g. a := b.  It is unnecessary to\n-// consider assignments to the fields of an object because, in general, if a\n-// field of an object escapes and must be heap-allocated, there is no way to\n-// heap-allocate that escaping field without heap-allocating the entire object.\n-// That is, for some globally escaping object GVAR, if there is an assignment\n-// of the form GVAR = t.f such that field f of object t escapes, it is likely\n-// that t must be heap-allocated as well.  In the analysis, this assignment\n-// will be simplified to GVAR = t, which is imprecise but has the same effect.\n-\n-// This is a general graph node representing a named object used in a call graph\n-// or connection graph.  In a call graph, each named object is either a Function\n-// or Function_declaration representing a function called during the program\n-// execution (which isn't necessarily every function declared).  In a connection\n-// graph, there is a node for each node in the call graph, which forms the root\n-// of that connection graph.  Each connection graph root contains nodes whose\n-// objects are either variables used in the function defintion or are nested\n-// closures created within the function definition.  The connection graph is\n-// a way of modeling the connectivity between all objects created in a given\n-// function as well as understanding the relationship between input arguments\n-// in the caller and the formal parameters in the callee.\n-\n-class Node\n-{\n- public:\n-  enum Node_classification\n-  {\n-    NODE_CALL,\n-    NODE_CONNECTION\n-  };\n-\n-  virtual ~Node();\n-\n-  // Make a call node for FUNCTION.\n-  static Node*\n-  make_call(Named_object* function);\n-\n-  // Make a connection node for OBJECT.\n-  // Note: values in this enum appear in export data, and therefore MUST NOT\n-  // change.\n-  enum Escapement_lattice\n-  {\n-    // ESCAPE_GLOBAL means that the object escapes all functions globally.\n-    ESCAPE_GLOBAL = 0,\n-    // ESCAPE_ARG with respect to a function means that the object escapes that\n-    // function it is created in via the function's arguments or results.\n-    ESCAPE_ARG = 1,\n-    // ESCAPE_NONE means that the object does not escape the function in which\n-    // it was created.\n-    ESCAPE_NONE = 2\n-  };\n-\n-  // A list of states usually corresponding to a list of function parameters.\n-  typedef std::vector<Escapement_lattice> Escape_states;\n-\n-  static Node*\n-  make_connection(Named_object* object, Escapement_lattice e);\n-\n-  // Return the node classification.\n-  Node_classification\n-  classification() const\n-  { return this->classification_; }\n-\n-  // Return whether this is a call node.\n-  bool\n-  is_call() const\n-  { return this->classification_ == NODE_CALL; }\n-\n-  // Return whether this is a connection node.\n-  bool\n-  is_connection() const\n-  { return this->classification_ == NODE_CONNECTION; }\n-\n-  // If this is a connection node, return the Connection_node.\n-  // Otherwise, return NULL.\n-  Connection_node*\n-  connection_node()\n-  { return this->convert<Connection_node, NODE_CONNECTION>(); }\n-\n-  // Return this node's unique id.\n-  unsigned int\n-  id() const\n-  { return this->id_; }\n-\n-  // Return this node's generated name for GraphViz.\n-  virtual const std::string&\n-  name() = 0;\n-\n-  // Return this node's generated label for GraphViz.\n-  virtual const std::string&\n-  label();\n-\n-  // Return the object this node represents.\n-  Named_object*\n-  object() const\n-  { return this->object_; }\n-\n-  void\n-  add_edge(Node* v)\n-  { this->edges_.insert(v); }\n-\n-  const std::set<Node*>&\n-  edges() const\n-  { return this->edges_; }\n-\n- protected:\n-  Node(Node_classification, Named_object* object);\n-\n-  const std::string&\n-  get_name() const\n-  { return this->name_; }\n-\n-  void\n-  set_name(const std::string& name)\n-  { this->name_ = name; }\n-\n-  const std::string&\n-  get_label() const\n-  { return this->label_; }\n-\n-  void\n-  set_label(const std::string& label)\n-  { this->label_ = label; }\n-\n- private:\n-  template<typename Node_class,\n-\t   Node_classification node_classification>\n-  const Node_class*\n-  convert() const\n-  {\n-    return (this->classification_ == node_classification\n-\t    ? static_cast<const Node_class*>(this)\n-\t    : NULL);\n-  }\n-\n-  template<typename Node_class,\n-\t   Node_classification node_classification>\n-  Node_class*\n-  convert()\n-  {\n-    return (this->classification_ == node_classification\n-\t    ? static_cast<Node_class*>(this)\n-\t    : NULL);\n-  }\n-\n-  // The classification of this node.\n-  Node_classification classification_;\n-  // A unique ID for this node.\n-  unsigned int id_;\n-  // The name for this node e.g. \"Node<ID>\" used as a GraphViz identifier.\n-  std::string name_;\n-  // The label for this node in the GraphViz representation.\n-  std::string label_;\n-  // The object represented by this node.\n-  Named_object* object_;\n-  // A distinct set of nodes that this node has edges to.\n-  std::set<Node*> edges_;\n-};\n-\n-\n-// A node representing a function that might be called during program execution.\n-\n-class Call_node : public Node\n-{\n- public:\n-  Call_node(Named_object* function);\n-\n-  const std::string&\n-  name();\n-};\n-\n-// A node representing an object in the connection graph built for each function\n-// in the call graph.\n-\n-class Connection_node : public Node\n-{\n- public:\n-  Connection_node(Named_object* object, Escapement_lattice e)\n-    : Node(NODE_CONNECTION, object),\n-      escape_state_(e)\n-  { }\n-\n-  // Return this node's generated name for GraphViz.\n-  const std::string&\n-  name();\n-\n-  // Return this node's generated label for GraphViz.\n-  const std::string&\n-  label();\n-\n-  // Return the escape state for this node.\n-  Escapement_lattice\n-  escape_state() const\n-  { return this->escape_state_; }\n-\n-  // Set the escape state for this node.\n-  void\n-  set_escape_state(Escapement_lattice e)\n-  { this->escape_state_ = e; }\n-\n-  // Return the objects inside of this connection graph.\n-  // This is empty for all connection nodes that are not the root of a\n-  // connection graph.  Each node in the call graph is a root of a connection\n-  // graph.\n-  const std::set<Node*>&\n-  objects() const\n-  { return this->objects_; }\n-\n-  void\n-  add_object(Node* object)\n-  { this->objects_.insert(object); }\n-\n-  void\n-  dump_connection(Connection_dump_context*);\n-\n- private:\n-  // The escapement of this node.\n-  Escapement_lattice escape_state_;\n-  // The set of nodes contained within this connection node.  If this node is\n-  // not a root of a connection graph, this will be empty.\n-  std::set<Node*> objects_;\n-};\n-\n-// This class implements fgo-dump-calls. The Call graph dump of a Go program.\n-\n-class Call_dump_context : public String_dump\n-{\n- public:\n-  Call_dump_context(std::ostream* out = NULL);\n-\n-  // Initialize the dump context.\n-  void\n-  dump(Gogo*, const char* basename);\n-\n-  // Get dump output stream.\n-  std::ostream&\n-  ostream()\n-  { return *this->ostream_; }\n-\n-  // Implementation of String_dump interface.\n-  void\n-  write_c_string(const char*);\n-\n-  void\n-  write_string(const std::string&);\n-\n- private:\n-  // Stream on output dump file.\n-  std::ostream* ostream_;\n-\n-  Gogo* gogo_;\n-};\n-\n-// This class implements fgo-dump-conns.  The connection graph dump of\n-// the functions called in a Go program.\n-\n-class Connection_dump_context : public String_dump\n-{\n- public:\n-  Connection_dump_context(std::ostream* out = NULL);\n-\n-  // Initialize the dump context.\n-  void\n-  dump(Gogo*, const char* basename);\n-\n-  // Get dump output stream.\n-  std::ostream&\n-  ostream()\n-  { return *this->ostream_; }\n-\n-  // Implementation of String_dump interface.\n-  void\n-  write_c_string(const char*);\n-\n-  void\n-  write_string(const std::string&);\n-\n- private:\n-  // Stream on output dump file.\n-  std::ostream* ostream_;\n-\n-  Gogo* gogo_;\n-};\n-\n-#endif // !defined(GO_ESCAPE_H)"}, {"sha": "5c0094d8795a210e5d915f1850de25799fa40483", "filename": "gcc/go/gofrontend/export.cc", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e49aacaf3083a99dc266209ed91183e91b11ffad/gcc%2Fgo%2Fgofrontend%2Fexport.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e49aacaf3083a99dc266209ed91183e91b11ffad/gcc%2Fgo%2Fgofrontend%2Fexport.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexport.cc?ref=e49aacaf3083a99dc266209ed91183e91b11ffad", "patch": "@@ -436,17 +436,6 @@ Export::write_type(const Type* type)\n     this->type_refs_[type] = index;\n }\n \n-// Export escape information.\n-\n-void\n-Export::write_escape(const Node::Escapement_lattice& e)\n-{\n-  char buf[30];\n-  snprintf(buf, sizeof buf, \"<escape %d>\", e);\n-  this->write_c_string(buf);\n-  return;\n-}\n-\n // Add the builtin types to the export table.\n \n void"}, {"sha": "0526e9a3f6defe86d4b8060b1f7f8e9374abf176", "filename": "gcc/go/gofrontend/export.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e49aacaf3083a99dc266209ed91183e91b11ffad/gcc%2Fgo%2Fgofrontend%2Fexport.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e49aacaf3083a99dc266209ed91183e91b11ffad/gcc%2Fgo%2Fgofrontend%2Fexport.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexport.h?ref=e49aacaf3083a99dc266209ed91183e91b11ffad", "patch": "@@ -7,7 +7,6 @@\n #ifndef GO_EXPORT_H\n #define GO_EXPORT_H\n \n-#include \"escape.h\"\n #include \"string-dump.h\"\n \n struct sha1_ctx;\n@@ -162,10 +161,6 @@ class Export : public String_dump\n   void\n   write_type(const Type*);\n \n-  // Write out escape information.\n-  void\n-  write_escape(const Node::Escapement_lattice& e);\n-\n  private:\n   Export(const Export&);\n   Export& operator=(const Export&);"}, {"sha": "cd30cca265741638431ec576d5b6753e753d4f10", "filename": "gcc/go/gofrontend/go.cc", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e49aacaf3083a99dc266209ed91183e91b11ffad/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e49aacaf3083a99dc266209ed91183e91b11ffad/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgo.cc?ref=e49aacaf3083a99dc266209ed91183e91b11ffad", "patch": "@@ -110,10 +110,6 @@ go_parse_input_files(const char** filenames, unsigned int filename_count,\n   if (only_check_syntax)\n     return;\n \n-  // Consider escape analysis information when deciding if a variable should\n-  // live on the heap or on the stack.\n-  ::gogo->optimize_allocations(filenames);\n-\n   // Export global identifiers as appropriate.\n   ::gogo->do_exports();\n "}, {"sha": "e373d8b17b7e9cad0cbc72cbf10c724ebcbe158c", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 2, "deletions": 164, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e49aacaf3083a99dc266209ed91183e91b11ffad/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e49aacaf3083a99dc266209ed91183e91b11ffad/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=e49aacaf3083a99dc266209ed91183e91b11ffad", "patch": "@@ -18,7 +18,6 @@\n #include \"runtime.h\"\n #include \"import.h\"\n #include \"export.h\"\n-#include \"escape.h\"\n #include \"backend.h\"\n #include \"gogo.h\"\n \n@@ -156,57 +155,35 @@ Gogo::Gogo(Backend* backend, Linemap* linemap, int, int pointer_size)\n   Function_type* new_type = Type::make_function_type(NULL, NULL, NULL, loc);\n   new_type->set_is_varargs();\n   new_type->set_is_builtin();\n-  Node::Escape_states* new_escapes =\n-    new Node::Escape_states(1, Node::ESCAPE_NONE);\n-  new_type->set_parameter_escape_states(new_escapes);\n-  new_type->set_has_escape_info();\n   this->globals_->add_function_declaration(\"new\", NULL, new_type, loc);\n \n   Function_type* make_type = Type::make_function_type(NULL, NULL, NULL, loc);\n   make_type->set_is_varargs();\n   make_type->set_is_builtin();\n-  Node::Escape_states* make_escapes =\n-    new Node::Escape_states(2, Node::ESCAPE_NONE);\n-  make_type->set_parameter_escape_states(make_escapes);\n-  make_type->set_has_escape_info();\n   this->globals_->add_function_declaration(\"make\", NULL, make_type, loc);\n \n   Typed_identifier_list* len_result = new Typed_identifier_list();\n   len_result->push_back(Typed_identifier(\"\", int_type, loc));\n   Function_type* len_type = Type::make_function_type(NULL, NULL, len_result,\n \t\t\t\t\t\t     loc);\n   len_type->set_is_builtin();\n-  Node::Escape_states* len_escapes =\n-    new Node::Escape_states(1, Node::ESCAPE_NONE);\n-  len_type->set_parameter_escape_states(len_escapes);\n-  len_type->set_has_escape_info();\n   this->globals_->add_function_declaration(\"len\", NULL, len_type, loc);\n \n   Typed_identifier_list* cap_result = new Typed_identifier_list();\n   cap_result->push_back(Typed_identifier(\"\", int_type, loc));\n   Function_type* cap_type = Type::make_function_type(NULL, NULL, len_result,\n \t\t\t\t\t\t     loc);\n   cap_type->set_is_builtin();\n-  Node::Escape_states* cap_escapes =\n-    new Node::Escape_states(1, Node::ESCAPE_NONE);\n-  cap_type->set_parameter_escape_states(cap_escapes);\n-  cap_type->set_has_escape_info();\n   this->globals_->add_function_declaration(\"cap\", NULL, cap_type, loc);\n \n   Function_type* print_type = Type::make_function_type(NULL, NULL, NULL, loc);\n   print_type->set_is_varargs();\n   print_type->set_is_builtin();\n-  Node::Escape_states* print_escapes =\n-    new Node::Escape_states(1, Node::ESCAPE_NONE);\n-  print_type->set_parameter_escape_states(print_escapes);\n-  print_type->set_has_escape_info();\n   this->globals_->add_function_declaration(\"print\", NULL, print_type, loc);\n \n   print_type = Type::make_function_type(NULL, NULL, NULL, loc);\n   print_type->set_is_varargs();\n   print_type->set_is_builtin();\n-  print_type->set_parameter_escape_states(print_escapes);\n-  print_type->set_has_escape_info();\n   this->globals_->add_function_declaration(\"println\", NULL, print_type, loc);\n \n   Type *empty = Type::make_empty_interface_type(loc);\n@@ -215,10 +192,6 @@ Gogo::Gogo(Backend* backend, Linemap* linemap, int, int pointer_size)\n   Function_type *panic_type = Type::make_function_type(NULL, panic_parms,\n \t\t\t\t\t\t       NULL, loc);\n   panic_type->set_is_builtin();\n-  Node::Escape_states* panic_escapes =\n-    new Node::Escape_states(1, Node::ESCAPE_ARG);\n-  panic_type->set_parameter_escape_states(panic_escapes);\n-  panic_type->set_has_escape_info();\n   this->globals_->add_function_declaration(\"panic\", NULL, panic_type, loc);\n \n   Typed_identifier_list* recover_result = new Typed_identifier_list();\n@@ -232,10 +205,6 @@ Gogo::Gogo(Backend* backend, Linemap* linemap, int, int pointer_size)\n   Function_type* close_type = Type::make_function_type(NULL, NULL, NULL, loc);\n   close_type->set_is_varargs();\n   close_type->set_is_builtin();\n-  Node::Escape_states* close_escapes =\n-    new Node::Escape_states(1, Node::ESCAPE_NONE);\n-  close_type->set_parameter_escape_states(close_escapes);\n-  close_type->set_has_escape_info();\n   this->globals_->add_function_declaration(\"close\", NULL, close_type, loc);\n \n   Typed_identifier_list* copy_result = new Typed_identifier_list();\n@@ -244,56 +213,31 @@ Gogo::Gogo(Backend* backend, Linemap* linemap, int, int pointer_size)\n \t\t\t\t\t\t      copy_result, loc);\n   copy_type->set_is_varargs();\n   copy_type->set_is_builtin();\n-  Node::Escape_states* copy_escapes =\n-    new Node::Escape_states(2, Node::ESCAPE_NONE);\n-  copy_type->set_parameter_escape_states(copy_escapes);\n-  copy_type->set_has_escape_info();\n   this->globals_->add_function_declaration(\"copy\", NULL, copy_type, loc);\n \n   Function_type* append_type = Type::make_function_type(NULL, NULL, NULL, loc);\n   append_type->set_is_varargs();\n   append_type->set_is_builtin();\n-  Node::Escape_states* append_escapes = new Node::Escape_states;\n-  append_escapes->push_back(Node::ESCAPE_ARG);\n-  append_escapes->push_back(Node::ESCAPE_NONE);\n-  append_type->set_parameter_escape_states(append_escapes);\n-  append_type->set_has_escape_info();\n   this->globals_->add_function_declaration(\"append\", NULL, append_type, loc);\n \n   Function_type* complex_type = Type::make_function_type(NULL, NULL, NULL, loc);\n   complex_type->set_is_varargs();\n   complex_type->set_is_builtin();\n-  Node::Escape_states* complex_escapes =\n-    new Node::Escape_states(2, Node::ESCAPE_NONE);\n-  complex_type->set_parameter_escape_states(complex_escapes);\n-  complex_type->set_has_escape_info();\n   this->globals_->add_function_declaration(\"complex\", NULL, complex_type, loc);\n \n   Function_type* real_type = Type::make_function_type(NULL, NULL, NULL, loc);\n   real_type->set_is_varargs();\n   real_type->set_is_builtin();\n-  Node::Escape_states* real_escapes =\n-    new Node::Escape_states(1, Node::ESCAPE_NONE);\n-  real_type->set_parameter_escape_states(real_escapes);\n-  real_type->set_has_escape_info();\n   this->globals_->add_function_declaration(\"real\", NULL, real_type, loc);\n \n   Function_type* imag_type = Type::make_function_type(NULL, NULL, NULL, loc);\n   imag_type->set_is_varargs();\n   imag_type->set_is_builtin();\n-  Node::Escape_states* imag_escapes =\n-    new Node::Escape_states(1, Node::ESCAPE_NONE);\n-  imag_type->set_parameter_escape_states(imag_escapes);\n-  imag_type->set_has_escape_info();\n   this->globals_->add_function_declaration(\"imag\", NULL, imag_type, loc);\n \n   Function_type* delete_type = Type::make_function_type(NULL, NULL, NULL, loc);\n   delete_type->set_is_varargs();\n   delete_type->set_is_builtin();\n-  Node::Escape_states* delete_escapes =\n-    new Node::Escape_states(2, Node::ESCAPE_NONE);\n-  delete_type->set_parameter_escape_states(delete_escapes);\n-  delete_type->set_has_escape_info();\n   this->globals_->add_function_declaration(\"delete\", NULL, delete_type, loc);\n }\n \n@@ -1889,74 +1833,6 @@ Gogo::add_label_reference(const std::string& label_name,\n \t\t\t\t   issue_goto_errors);\n }\n \n-// Add a function to the call graph.\n-\n-Node*\n-Gogo::add_call_node(Named_object* function)\n-{\n-  Node* call = this->lookup_call_node(function);\n-  if (call == NULL)\n-    {\n-      call = Node::make_call(function);\n-      this->call_graph_.insert(call);\n-      this->named_call_nodes_[function] = call;\n-    }\n-  return call;\n-}\n-\n-// Find the call node that represents FUNCTION.  Return NULL if it does not\n-// exist.\n-\n-Node*\n-Gogo::lookup_call_node(Named_object* function) const\n-{\n-  Named_escape_nodes::const_iterator p = this->named_call_nodes_.find(function);\n-  if (p == this->named_call_nodes_.end())\n-    return NULL;\n-  return p->second;\n-}\n-\n-// Add a connection node for OBJECT.\n-\n-Node*\n-Gogo::add_connection_node(Named_object* object)\n-{\n-  Node* connection = this->lookup_connection_node(object);\n-  if (connection == NULL)\n-    {\n-      connection = Node::make_connection(object, Node::ESCAPE_NONE);\n-\n-      // Each global variable is a part of the global connection graph.\n-      if (object->is_variable()\n-\t  && object->var_value()->is_global())\n-\t{\n-\t  connection->connection_node()->set_escape_state(Node::ESCAPE_GLOBAL);\n-\t  this->global_connections_.insert(connection);\n-\t}\n-\n-      // Each function declaration or definition is the root of its own\n-      // connection graph.  This means closures will have their own\n-      // connection graph that objects in the enclosing function might\n-      // refer to.\n-      if (object->is_function() || object->is_function_declaration())\n-\tthis->connection_roots_.insert(connection);\n-      this->named_connection_nodes_[object] = connection;\n-    }\n-  return connection;\n-}\n-\n-// Find the connection node for OBJECT.  Return NULL if it does not exist.\n-\n-Node*\n-Gogo::lookup_connection_node(Named_object* object) const\n-{\n-  Named_escape_nodes::const_iterator p =\n-    this->named_connection_nodes_.find(object);\n-  if (p == this->named_connection_nodes_.end())\n-    return NULL;\n-  return p->second;\n-}\n-\n // Return the current binding state.\n \n Bindings_snapshot*\n@@ -4918,13 +4794,6 @@ Function::export_func_with_type(Export* exp, const std::string& name,\n       exp->write_c_string(\"(\");\n       const Typed_identifier* receiver = fntype->receiver();\n       exp->write_name(receiver->name());\n-\n-      if (fntype->has_escape_info())\n-        {\n-          exp->write_c_string(\" \");\n-          exp->write_escape(fntype->receiver_escape_state());\n-        }\n-\n       exp->write_c_string(\" \");\n       exp->write_type(receiver->type());\n       exp->write_c_string(\") \");\n@@ -4948,13 +4817,6 @@ Function::export_func_with_type(Export* exp, const std::string& name,\n \t  else\n \t    exp->write_c_string(\", \");\n \t  exp->write_name(p->name());\n-\n-\t  if (fntype->has_escape_info())\n-\t    {\n-\t      exp->write_c_string(\" \");\n-\t      exp->write_escape(fntype->parameter_escape_states()->at(i));\n-\t    }\n-\n \t  exp->write_c_string(\" \");\n \t  if (!is_varargs || p + 1 != parameters->end())\n \t    exp->write_type(p->type());\n@@ -5002,29 +4864,17 @@ Function::export_func_with_type(Export* exp, const std::string& name,\n void\n Function::import_func(Import* imp, std::string* pname,\n \t\t      Typed_identifier** preceiver,\n-\t\t      Node::Escapement_lattice* rcvr_escape,\n \t\t      Typed_identifier_list** pparameters,\n-\t\t      Node::Escape_states** pparam_escapes,\n \t\t      Typed_identifier_list** presults,\n-\t\t      bool* is_varargs, bool* has_escape_info)\n+\t\t      bool* is_varargs)\n {\n-  *has_escape_info = false;\n-\n   imp->require_c_string(\"func \");\n \n   *preceiver = NULL;\n-  *rcvr_escape = Node::ESCAPE_NONE;\n   if (imp->peek_char() == '(')\n     {\n       imp->require_c_string(\"(\");\n       std::string name = imp->read_name();\n-\n-      if (imp->match_c_string(\" <escape\")){\n-\t*has_escape_info = true;\n-\timp->require_c_string(\" \");\n-\t*rcvr_escape = imp->read_escape_info();\n-      }\n-\n       imp->require_c_string(\" \");\n       Type* rtype = imp->read_type();\n       *preceiver = new Typed_identifier(name, rtype, imp->location());\n@@ -5034,27 +4884,16 @@ Function::import_func(Import* imp, std::string* pname,\n   *pname = imp->read_identifier();\n \n   Typed_identifier_list* parameters;\n-  Node::Escape_states* param_escapes;\n   *is_varargs = false;\n   imp->require_c_string(\" (\");\n   if (imp->peek_char() == ')')\n-    {\n-      parameters = NULL;\n-      param_escapes = NULL;\n-    }\n+    parameters = NULL;\n   else\n     {\n       parameters = new Typed_identifier_list();\n-      param_escapes = new Node::Escape_states();\n       while (true)\n \t{\n \t  std::string name = imp->read_name();\n-\t  if (imp->match_c_string(\" <escape\")){\n-\t    *has_escape_info = true;\n-\t    imp->require_c_string(\" \");\n-\t    param_escapes->push_back(imp->read_escape_info());\n-\t  }\n-\n \t  imp->require_c_string(\" \");\n \n \t  if (imp->match_c_string(\"...\"))\n@@ -5076,7 +4915,6 @@ Function::import_func(Import* imp, std::string* pname,\n     }\n   imp->require_c_string(\")\");\n   *pparameters = parameters;\n-  *pparam_escapes = param_escapes;\n \n   Typed_identifier_list* results;\n   if (imp->peek_char() != ' ')"}, {"sha": "45c385781020527f71558b3cb9f5cc1c0fa3af3f", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 1, "deletions": 74, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e49aacaf3083a99dc266209ed91183e91b11ffad/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e49aacaf3083a99dc266209ed91183e91b11ffad/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=e49aacaf3083a99dc266209ed91183e91b11ffad", "patch": "@@ -7,7 +7,6 @@\n #ifndef GO_GOGO_H\n #define GO_GOGO_H\n \n-#include \"escape.h\"\n #include \"go-linemap.h\"\n \n class Traverse;\n@@ -126,21 +125,6 @@ class Gogo\n   linemap()\n   { return this->linemap_; }\n \n-  // Get the Call Graph.\n-  const std::set<Node*>&\n-  call_graph() const\n-  { return this->call_graph_; }\n-\n-  // Get the roots of each connection graph.\n-  const std::set<Node*>&\n-  connection_roots() const\n-  { return this->connection_roots_; }\n-\n-  // Get the nodes that escape globally.\n-  const std::set<Node*>&\n-  global_connections() const\n-  { return this->global_connections_; }\n-\n   // Get the package name.\n   const std::string&\n   package_name() const;\n@@ -361,22 +345,6 @@ class Gogo\n   add_label_reference(const std::string&, Location,\n \t\t      bool issue_goto_errors);\n \n-  // Add a FUNCTION to the call graph.\n-  Node*\n-  add_call_node(Named_object* function);\n-\n-  // Lookup the call node for FUNCTION.\n-  Node*\n-  lookup_call_node(Named_object* function) const;\n-\n-  // Add a connection node for OBJECT.\n-  Node*\n-  add_connection_node(Named_object* object);\n-\n-  // Lookup the connection node for OBJECT.\n-  Node*\n-  lookup_connection_node(Named_object* object) const;\n-\n   // Return a snapshot of the current binding state.\n   Bindings_snapshot*\n   bindings_snapshot(Location);\n@@ -576,26 +544,6 @@ class Gogo\n   void\n   check_return_statements();\n \n-  // Build call graph.\n-  void\n-  build_call_graph();\n-\n-  // Build connection graphs.\n-  void\n-  build_connection_graphs();\n-\n-  // Analyze reachability in the connection graphs.\n-  void\n-  analyze_reachability();\n-\n-  // Record escape information in function signatures for export data.\n-  void\n-  mark_escaping_signatures();\n-\n-  // Optimize variable allocation.\n-  void\n-  optimize_allocations(const char** filenames);\n-\n   // Do all exports.\n   void\n   do_exports();\n@@ -730,10 +678,6 @@ class Gogo\n   // where they were defined.\n   typedef Unordered_map(std::string, Location) File_block_names;\n \n-  // Type used to map named objects that refer to objects to the\n-  // node that represent them in the escape analysis graphs.\n-  typedef Unordered_map(Named_object*, Node*)  Named_escape_nodes;\n-\n   // Type used to queue writing a type specific function.\n   struct Specific_type_function\n   {\n@@ -766,20 +710,6 @@ class Gogo\n   // The global binding contour.  This includes the builtin functions\n   // and the package we are compiling.\n   Bindings* globals_;\n-  // The call graph for a program execution which represents the functions\n-  // encountered and the caller-callee relationship between the functions.\n-  std::set<Node*> call_graph_;\n-  // The nodes that form the roots of the connection graphs for each called\n-  // function and represent the connectivity relationship between all objects\n-  // in the function.\n-  std::set<Node*> connection_roots_;\n-  // All connection nodes that have an escape state of ESCAPE_GLOBAL are a part\n-  // of a special connection graph of only global variables.\n-  std::set<Node*> global_connections_;\n-  // Mapping from named objects to nodes in the call graph.\n-  Named_escape_nodes named_call_nodes_;\n-  // Mapping from named objects to nodes in a connection graph.\n-  Named_escape_nodes named_connection_nodes_;\n   // The list of names we have seen in the file block.\n   File_block_names file_block_names_;\n   // Mapping from import file names to packages.\n@@ -1215,11 +1145,8 @@ class Function\n   // Import a function.\n   static void\n   import_func(Import*, std::string* pname, Typed_identifier** receiver,\n-\t      Node::Escapement_lattice* rcvr_escape,\n \t      Typed_identifier_list** pparameters,\n-\t      Node::Escape_states** pparam_escapes,\n-\t      Typed_identifier_list** presults, bool* is_varargs,\n-\t      bool* has_escape_info);\n+\t      Typed_identifier_list** presults, bool* is_varargs);\n \n  private:\n   // Type for mapping from label names to Label objects."}, {"sha": "8a6dd78607541251894f6c711716331eaa6b0519", "filename": "gcc/go/gofrontend/import.cc", "status": "modified", "additions": 2, "deletions": 27, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e49aacaf3083a99dc266209ed91183e91b11ffad/gcc%2Fgo%2Fgofrontend%2Fimport.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e49aacaf3083a99dc266209ed91183e91b11ffad/gcc%2Fgo%2Fgofrontend%2Fimport.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fimport.cc?ref=e49aacaf3083a99dc266209ed91183e91b11ffad", "patch": "@@ -502,28 +502,16 @@ Import::import_func(Package* package)\n {\n   std::string name;\n   Typed_identifier* receiver;\n-  Node::Escapement_lattice rcvr_escape;\n   Typed_identifier_list* parameters;\n-  Node::Escape_states* param_escapes;\n   Typed_identifier_list* results;\n   bool is_varargs;\n-  bool has_escape_info;\n-  Function::import_func(this, &name, &receiver, &rcvr_escape, &parameters,\n-\t\t\t&param_escapes, &results, &is_varargs,\n-\t\t\t&has_escape_info);\n+  Function::import_func(this, &name, &receiver,\n+\t\t\t&parameters, &results, &is_varargs);\n   Function_type *fntype = Type::make_function_type(receiver, parameters,\n \t\t\t\t\t\t   results, this->location_);\n   if (is_varargs)\n     fntype->set_is_varargs();\n \n-  if (has_escape_info)\n-    {\n-      if (fntype->is_method())\n-\tfntype->set_receiver_escape_state(rcvr_escape);\n-      fntype->set_parameter_escape_states(param_escapes);\n-      fntype->set_has_escape_info();\n-    }\n-\n   Location loc = this->location_;\n   Named_object* no;\n   if (fntype->is_method())\n@@ -774,19 +762,6 @@ Import::read_type()\n   return type;\n }\n \n-// Read escape info in the import stream.\n-\n-Node::Escapement_lattice\n-Import::read_escape_info()\n-{\n-  Stream* stream = this->stream_;\n-  this->require_c_string(\"<escape \");\n-\n-  int escape_value = stream->get_char() - '0';\n-  this->require_c_string(\">\");\n-  return Node::Escapement_lattice(escape_value);\n-}\n-\n // Register the builtin types.\n \n void"}, {"sha": "2a9ac80e7e227fc74ff7660310bbe885412e0c11", "filename": "gcc/go/gofrontend/import.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e49aacaf3083a99dc266209ed91183e91b11ffad/gcc%2Fgo%2Fgofrontend%2Fimport.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e49aacaf3083a99dc266209ed91183e91b11ffad/gcc%2Fgo%2Fgofrontend%2Fimport.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fimport.h?ref=e49aacaf3083a99dc266209ed91183e91b11ffad", "patch": "@@ -7,7 +7,6 @@\n #ifndef GO_IMPORT_H\n #define GO_IMPORT_H\n \n-#include \"escape.h\"\n #include \"export.h\"\n #include \"go-linemap.h\"\n \n@@ -198,10 +197,6 @@ class Import\n   Type*\n   read_type();\n \n-  // Read escape information.\n-  Node::Escapement_lattice\n-  read_escape_info();\n-\n  private:\n   static Stream*\n   try_package_in_directory(const std::string&, Location);"}, {"sha": "c834444f53a4b6abfcc7d4418d95159e62c9c0d7", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e49aacaf3083a99dc266209ed91183e91b11ffad/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e49aacaf3083a99dc266209ed91183e91b11ffad/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=e49aacaf3083a99dc266209ed91183e91b11ffad", "patch": "@@ -14,7 +14,6 @@\n #include \"backend.h\"\n #include \"statements.h\"\n #include \"ast-dump.h\"\n-#include \"dataflow.h\"\n \n // Class Statement.\n \n@@ -4821,22 +4820,6 @@ Select_clauses::Select_clause::check_types()\n     error_at(this->location(), \"invalid receive on send-only channel\");\n }\n \n-// Analyze the dataflow across each case statement.\n-\n-void\n-Select_clauses::Select_clause::analyze_dataflow(Dataflow* dataflow)\n-{\n-  if (this->is_default_)\n-    return;\n-\n-  // For a CommClause, the dataflow analysis should record a definition of\n-  // VAR and CLOSEDVAR\n-  if (this->var_ != NULL && !this->var_->is_sink())\n-    dataflow->add_def(this->var_, this->channel_, NULL, false);\n-  if (this->closedvar_ != NULL && !this->closedvar_->is_sink())\n-    dataflow->add_def(this->closedvar_, this->channel_, NULL, false);\n-}\n-\n // Whether this clause may fall through to the statement which follows\n // the overall select statement.\n \n@@ -4955,17 +4938,6 @@ Select_clauses::check_types()\n     p->check_types();\n }\n \n-// Analyze the dataflow across each case statement.\n-\n-void\n-Select_clauses::analyze_dataflow(Dataflow* dataflow)\n-{\n-  for (Clauses::iterator p = this->clauses_.begin();\n-       p != this->clauses_.end();\n-       ++p)\n-    p->analyze_dataflow(dataflow);\n-}\n-\n // Return whether these select clauses fall through to the statement\n // following the overall select statement.\n "}, {"sha": "498e0f0adfdd342a7faf9d12e727be306ee26398", "filename": "gcc/go/gofrontend/statements.h", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e49aacaf3083a99dc266209ed91183e91b11ffad/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e49aacaf3083a99dc266209ed91183e91b11ffad/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.h?ref=e49aacaf3083a99dc266209ed91183e91b11ffad", "patch": "@@ -47,7 +47,6 @@ class Bexpression;\n class Bstatement;\n class Bvariable;\n class Ast_dump_context;\n-class Dataflow;\n \n // This class is used to traverse assignments made by a statement\n // which makes assignments.\n@@ -860,10 +859,6 @@ class Select_clauses\n   void\n   check_types();\n \n-  // Analyze the dataflow across each case statement.\n-  void\n-  analyze_dataflow(Dataflow*);\n-\n   // Whether the select clauses may fall through to the statement\n   // which follows the overall select statement.\n   bool\n@@ -920,10 +915,6 @@ class Select_clauses\n     void\n     check_types();\n \n-    // Analyze the dataflow across each case statement.\n-    void\n-    analyze_dataflow(Dataflow*);\n-\n     // Return true if this is the default clause.\n     bool\n     is_default() const\n@@ -1030,10 +1021,6 @@ class Select_statement : public Statement\n   Unnamed_label*\n   break_label();\n \n-  void\n-  analyze_dataflow(Dataflow* dataflow)\n-  { this->clauses_->analyze_dataflow(dataflow); }\n-\n  protected:\n   int\n   do_traverse(Traverse* traverse)"}, {"sha": "bf673e63ca854d006277c0b94a9957d851fa6aea", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 1, "deletions": 39, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e49aacaf3083a99dc266209ed91183e91b11ffad/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e49aacaf3083a99dc266209ed91183e91b11ffad/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=e49aacaf3083a99dc266209ed91183e91b11ffad", "patch": "@@ -8,7 +8,6 @@\n #define GO_TYPES_H\n \n #include \"go-linemap.h\"\n-#include \"escape.h\"\n \n class Gogo;\n class Package;\n@@ -1779,24 +1778,14 @@ class Function_type : public Type\n     : Type(TYPE_FUNCTION),\n       receiver_(receiver), parameters_(parameters), results_(results),\n       location_(location), is_varargs_(false), is_builtin_(false),\n-      has_escape_info_(false), fnbtype_(NULL), parameter_escape_states_(NULL)\n+      fnbtype_(NULL)\n   { }\n \n   // Get the receiver.\n   const Typed_identifier*\n   receiver() const\n   { return this->receiver_; }\n \n-  // Get the escape state of the receiver.\n-  const Node::Escapement_lattice&\n-  receiver_escape_state() const\n-  { return this->receiver_escape_state_; }\n-\n-  // Set the escape state of the receiver.\n-  void\n-  set_receiver_escape_state(const Node::Escapement_lattice& e)\n-  { this->receiver_escape_state_ = e; }\n-\n   // Get the return names and types.\n   const Typed_identifier_list*\n   results() const\n@@ -1807,16 +1796,6 @@ class Function_type : public Type\n   parameters() const\n   { return this->parameters_; }\n \n-  // Get the escape states associated with each parameter.\n-  const Node::Escape_states*\n-  parameter_escape_states() const\n-  { return this->parameter_escape_states_; }\n-\n-  // Set the escape states of the parameters.\n-  void\n-  set_parameter_escape_states(Node::Escape_states* states)\n-  { this->parameter_escape_states_ = states; }\n-\n   // Whether this is a varargs function.\n   bool\n   is_varargs() const\n@@ -1827,11 +1806,6 @@ class Function_type : public Type\n   is_builtin() const\n   { return this->is_builtin_; }\n \n-  // Whether this contains escape information.\n-  bool\n-  has_escape_info() const\n-  { return this->has_escape_info_; }\n-\n   // The location where this type was defined.\n   Location\n   location() const\n@@ -1862,11 +1836,6 @@ class Function_type : public Type\n   set_is_builtin()\n   { this->is_builtin_ = true; }\n \n-  // Record that this has escape information.\n-  void\n-  set_has_escape_info()\n-  { this->has_escape_info_ = true; }\n-\n   // Import a function type.\n   static Function_type*\n   do_import(Import*);\n@@ -1978,16 +1947,9 @@ class Function_type : public Type\n   // Whether this is a special builtin function which can not simply\n   // be called.  This is used for len, cap, etc.\n   bool is_builtin_;\n-  // Whether escape information for the receiver and parameters has been\n-  // recorded.\n-  bool has_escape_info_;\n   // The backend representation of this type for backend function\n   // declarations and definitions.\n   Btype* fnbtype_;\n-  // The escape state of the receiver.\n-  Node::Escapement_lattice receiver_escape_state_;\n-  // The escape states of each parameter.\n-  Node::Escape_states* parameter_escape_states_;\n };\n \n // The type of a function's backend representation."}]}