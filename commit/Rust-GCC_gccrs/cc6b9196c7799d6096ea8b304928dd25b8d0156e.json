{"sha": "cc6b9196c7799d6096ea8b304928dd25b8d0156e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2M2YjkxOTZjNzc5OWQ2MDk2ZWE4YjMwNDkyOGRkMjViOGQwMTU2ZQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2014-11-10T19:52:05Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2014-11-10T19:52:05Z"}, "message": "frv.c (frv_registers_conflict_p_1): Take an rtx rather than an rtx *.\n\ngcc/\n\t* config/frv/frv.c (frv_registers_conflict_p_1): Take an rtx rather\n\tthan an rtx *.  Take the regstate_t directly rather than via a void *.\n\tReturn a bool rather than an int.  Iterate over all subrtxes here.\n\t(frv_registers_conflict_p): Update accordingly.\n\nFrom-SVN: r217310", "tree": {"sha": "e7f1d6f0ea68a7875e1c4c3a0a9269268f60579e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7f1d6f0ea68a7875e1c4c3a0a9269268f60579e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc6b9196c7799d6096ea8b304928dd25b8d0156e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc6b9196c7799d6096ea8b304928dd25b8d0156e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc6b9196c7799d6096ea8b304928dd25b8d0156e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc6b9196c7799d6096ea8b304928dd25b8d0156e/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cc665e5670eee5d0a1170bb93f74e3f58be325cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc665e5670eee5d0a1170bb93f74e3f58be325cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc665e5670eee5d0a1170bb93f74e3f58be325cb"}], "stats": {"total": 88, "additions": 45, "deletions": 43}, "files": [{"sha": "bb2876e96d263752532666bc618b8a1b896f4a07", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc6b9196c7799d6096ea8b304928dd25b8d0156e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc6b9196c7799d6096ea8b304928dd25b8d0156e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cc6b9196c7799d6096ea8b304928dd25b8d0156e", "patch": "@@ -1,3 +1,10 @@\n+2014-11-10  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* config/frv/frv.c (frv_registers_conflict_p_1): Take an rtx rather\n+\tthan an rtx *.  Take the regstate_t directly rather than via a void *.\n+\tReturn a bool rather than an int.  Iterate over all subrtxes here.\n+\t(frv_registers_conflict_p): Update accordingly.\n+\n 2014-11-10  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* config/frv/frv.c: Include rtl-iter.h."}, {"sha": "7b38f779efe7426ee561e939ee6e674a6175d912", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 38, "deletions": 43, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc6b9196c7799d6096ea8b304928dd25b8d0156e/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc6b9196c7799d6096ea8b304928dd25b8d0156e/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=cc6b9196c7799d6096ea8b304928dd25b8d0156e", "patch": "@@ -343,7 +343,6 @@ static unsigned int frv_insn_unit\t\t(rtx_insn *);\n static bool frv_issues_to_branch_unit_p\t\t(rtx_insn *);\n static int frv_cond_flags \t\t\t(rtx);\n static bool frv_regstate_conflict_p \t\t(regstate_t, regstate_t);\n-static int frv_registers_conflict_p_1 \t\t(rtx *, void *);\n static bool frv_registers_conflict_p \t\t(rtx);\n static void frv_registers_update_1 \t\t(rtx, const_rtx, void *);\n static void frv_registers_update \t\t(rtx);\n@@ -7171,53 +7170,49 @@ frv_regstate_conflict_p (regstate_t cond1, regstate_t cond2)\n }\n \n \n-/* A for_each_rtx callback.  Return 1 if *X depends on an instruction in\n-   the current packet.  DATA points to a regstate_t that describes the\n-   condition under which *X might be set or used.  */\n+/* Return true if an instruction with pattern PAT depends on an\n+   instruction in the current packet.  COND describes the condition\n+   under which PAT might be set or used.  */\n \n-static int\n-frv_registers_conflict_p_1 (rtx *x, void *data)\n+static bool\n+frv_registers_conflict_p_1 (rtx pat, regstate_t cond)\n {\n-  unsigned int regno, i;\n-  regstate_t cond;\n-\n-  cond = *(regstate_t *) data;\n-\n-  if (GET_CODE (*x) == REG)\n-    FOR_EACH_REGNO (regno, *x)\n-      if ((frv_packet.regstate[regno] & REGSTATE_MODIFIED) != 0)\n-\tif (frv_regstate_conflict_p (frv_packet.regstate[regno], cond))\n-\t  return 1;\n-\n-  if (GET_CODE (*x) == MEM)\n+  subrtx_var_iterator::array_type array;\n+  FOR_EACH_SUBRTX_VAR (iter, array, pat, NONCONST)\n     {\n-      /* If we ran out of memory slots, assume a conflict.  */\n-      if (frv_packet.num_mems > ARRAY_SIZE (frv_packet.mems))\n-\treturn 1;\n+      rtx x = *iter;\n+      if (GET_CODE (x) == REG)\n+\t{\n+\t  unsigned int regno;\n+\t  FOR_EACH_REGNO (regno, x)\n+\t    if ((frv_packet.regstate[regno] & REGSTATE_MODIFIED) != 0)\n+\t      if (frv_regstate_conflict_p (frv_packet.regstate[regno], cond))\n+\t\treturn true;\n+\t}\n+      else if (GET_CODE (x) == MEM)\n+\t{\n+\t  /* If we ran out of memory slots, assume a conflict.  */\n+\t  if (frv_packet.num_mems > ARRAY_SIZE (frv_packet.mems))\n+\t    return 1;\n \n-      /* Check for output or true dependencies with earlier MEMs.  */\n-      for (i = 0; i < frv_packet.num_mems; i++)\n-\tif (frv_regstate_conflict_p (frv_packet.mems[i].cond, cond))\n-\t  {\n-\t    if (true_dependence (frv_packet.mems[i].mem, VOIDmode, *x))\n-\t      return 1;\n+\t  /* Check for output or true dependencies with earlier MEMs.  */\n+\t  for (unsigned int i = 0; i < frv_packet.num_mems; i++)\n+\t    if (frv_regstate_conflict_p (frv_packet.mems[i].cond, cond))\n+\t      {\n+\t\tif (true_dependence (frv_packet.mems[i].mem, VOIDmode, x))\n+\t\t  return true;\n \n-\t    if (output_dependence (frv_packet.mems[i].mem, *x))\n-\t      return 1;\n-\t  }\n-    }\n+\t\tif (output_dependence (frv_packet.mems[i].mem, x))\n+\t\t  return true;\n+\t      }\n+\t}\n \n-  /* The return values of calls aren't significant: they describe\n-     the effect of the call as a whole, not of the insn itself.  */\n-  if (GET_CODE (*x) == SET && GET_CODE (SET_SRC (*x)) == CALL)\n-    {\n-      if (for_each_rtx (&SET_SRC (*x), frv_registers_conflict_p_1, data))\n-\treturn 1;\n-      return -1;\n+      /* The return values of calls aren't significant: they describe\n+\t the effect of the call as a whole, not of the insn itself.  */\n+      else if (GET_CODE (x) == SET && GET_CODE (SET_SRC (x)) == CALL)\n+\titer.substitute (SET_SRC (x));\n     }\n-\n-  /* Check subexpressions.  */\n-  return 0;\n+  return false;\n }\n \n \n@@ -7232,13 +7227,13 @@ frv_registers_conflict_p (rtx x)\n   flags = 0;\n   if (GET_CODE (x) == COND_EXEC)\n     {\n-      if (for_each_rtx (&XEXP (x, 0), frv_registers_conflict_p_1, &flags))\n+      if (frv_registers_conflict_p_1 (XEXP (x, 0), flags))\n \treturn true;\n \n       flags |= frv_cond_flags (XEXP (x, 0));\n       x = XEXP (x, 1);\n     }\n-  return for_each_rtx (&x, frv_registers_conflict_p_1, &flags);\n+  return frv_registers_conflict_p_1 (x, flags);\n }\n \n "}]}