{"sha": "b6b5cca81b846b91c3a4b35bcedd2294a6ee4dfd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjZiNWNjYTgxYjg0NmI5MWMzYTRiMzViY2VkZDIyOTRhNmVlNGRmZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-10-02T13:05:08Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-10-02T13:05:08Z"}, "message": "[multiple changes]\n\n2012-10-02  Ben Brosgol  <brosgol@adacore.com>\n\n\t* gnat_rm.texi: Minor editing.\n\n2012-10-02  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb (Analyze_Function_Return): Reject a return\n\texpression whose type is a local access to subprogram type.\n\n2012-10-02  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_eval.adb: Minor improvement to Compile_Time_Compare.\n\n2012-10-02  Robert Dewar  <dewar@adacore.com>\n\n\t* checks.adb (Apply_Arithmetic_Overflow_Minimized_Eliminated):\n\tFix base type problem that resulted in improper conversion.\n\t(Minimize_Eliminate_Overflow_Checks): Properly handle top\n\tlevel case to avoid unnecessary conversion to bignum or LLI.\n\t(Minimize_Eliminate_Overflow_Checks): Implement uniform two phase\n\tapproach for arithmetic operators and for if/case expressions.\n\t* checks.ads: Minor comment fix.\n\t* exp_ch4.adb (Minimized_Eliminated_Overflow_Check): New function,\n\timplements a uniform way of treating minimized/eliminated checks in\n\ttwo phases.\n\t(Expand_Compare_Minimize_Eliminate_Overflow): Fix cut and\n\tpaste error resulting in wrong results for less than in some\n\tcases.\t(Expand_Membership_Minimize_Eliminate_Overflow):\n\tFix error caused by incorrect capture of operand types.\n\t(Expand_Membership_Minimize_Eliminate_Overflow): Fix error in\n\thandling of bignum case.\n\t(Expand_N_Case_Expression): Implement\n\tproper two phase handling (Expand_N_If_Expression): Implement\n\tproper two phase handling (Expand_N_Op_Abs): Implement proper\n\ttwo phase handling ditto for all other arithmetic operators\n\t* sem_res.adb (Resolve_If_Expression): Avoid introducing\n\tunneeded conversions.\n\nFrom-SVN: r191980", "tree": {"sha": "77297aeeb5ef4433fd70088533b5e97a0664932a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77297aeeb5ef4433fd70088533b5e97a0664932a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6b5cca81b846b91c3a4b35bcedd2294a6ee4dfd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6b5cca81b846b91c3a4b35bcedd2294a6ee4dfd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6b5cca81b846b91c3a4b35bcedd2294a6ee4dfd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6b5cca81b846b91c3a4b35bcedd2294a6ee4dfd/comments", "author": null, "committer": null, "parents": [{"sha": "6e6636ec8b5044a7ab2b464f6e7d7d71ade42356", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e6636ec8b5044a7ab2b464f6e7d7d71ade42356", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e6636ec8b5044a7ab2b464f6e7d7d71ade42356"}], "stats": {"total": 598, "additions": 466, "deletions": 132}, "files": [{"sha": "fa3673dbd5f0c099fd2a7a570ac9f13ac433fdf1", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6b5cca81b846b91c3a4b35bcedd2294a6ee4dfd/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6b5cca81b846b91c3a4b35bcedd2294a6ee4dfd/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b6b5cca81b846b91c3a4b35bcedd2294a6ee4dfd", "patch": "@@ -1,3 +1,41 @@\n+2012-10-02  Ben Brosgol  <brosgol@adacore.com>\n+\n+\t* gnat_rm.texi: Minor editing.\n+\n+2012-10-02  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb (Analyze_Function_Return): Reject a return\n+\texpression whose type is a local access to subprogram type.\n+\n+2012-10-02  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_eval.adb: Minor improvement to Compile_Time_Compare.\n+\n+2012-10-02  Robert Dewar  <dewar@adacore.com>\n+\n+\t* checks.adb (Apply_Arithmetic_Overflow_Minimized_Eliminated):\n+\tFix base type problem that resulted in improper conversion.\n+\t(Minimize_Eliminate_Overflow_Checks): Properly handle top\n+\tlevel case to avoid unnecessary conversion to bignum or LLI.\n+\t(Minimize_Eliminate_Overflow_Checks): Implement uniform two phase\n+\tapproach for arithmetic operators and for if/case expressions.\n+\t* checks.ads: Minor comment fix.\n+\t* exp_ch4.adb (Minimized_Eliminated_Overflow_Check): New function,\n+\timplements a uniform way of treating minimized/eliminated checks in\n+\ttwo phases.\n+\t(Expand_Compare_Minimize_Eliminate_Overflow): Fix cut and\n+\tpaste error resulting in wrong results for less than in some\n+\tcases.\t(Expand_Membership_Minimize_Eliminate_Overflow):\n+\tFix error caused by incorrect capture of operand types.\n+\t(Expand_Membership_Minimize_Eliminate_Overflow): Fix error in\n+\thandling of bignum case.\n+\t(Expand_N_Case_Expression): Implement\n+\tproper two phase handling (Expand_N_If_Expression): Implement\n+\tproper two phase handling (Expand_N_Op_Abs): Implement proper\n+\ttwo phase handling ditto for all other arithmetic operators\n+\t* sem_res.adb (Resolve_If_Expression): Avoid introducing\n+\tunneeded conversions.\n+\n 2012-10-02  Robert Dewar  <dewar@adacore.com>\n \n \t* s-bignum.adb (Big_Exp): 0**0 should be 1, not 0."}, {"sha": "53be1a674fc1db74ae342d76706219d20b72f5c5", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 166, "deletions": 44, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6b5cca81b846b91c3a4b35bcedd2294a6ee4dfd/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6b5cca81b846b91c3a4b35bcedd2294a6ee4dfd/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=b6b5cca81b846b91c3a4b35bcedd2294a6ee4dfd", "patch": "@@ -854,7 +854,7 @@ package body Checks is\n       if Is_Signed_Integer_Type (Typ)\n         and then Nkind (Parent (N)) = N_Type_Conversion\n       then\n-         declare\n+         Conversion_Optimization : declare\n             Target_Type : constant Entity_Id :=\n               Base_Type (Entity (Subtype_Mark (Parent (N))));\n \n@@ -918,7 +918,7 @@ package body Checks is\n                   end if;\n                end if;\n             end if;\n-         end;\n+         end Conversion_Optimization;\n       end if;\n \n       --  Now see if an overflow check is required\n@@ -1129,9 +1129,11 @@ package body Checks is\n       --  top level, we have the proper type. This \"undoing\" is a point at\n       --  which a final overflow check may be applied.\n \n-      --  If the result type was not fiddled we are all set\n+      --  If the result type was not fiddled we are all set. We go to base\n+      --  types here because things may have been rewritten to generate the\n+      --  base type of the operand types.\n \n-      if Etype (Op) = Result_Type then\n+      if Base_Type (Etype (Op)) = Base_Type (Result_Type) then\n          return;\n \n       --  Bignum case\n@@ -1204,10 +1206,13 @@ package body Checks is\n             Analyze_And_Resolve (Op);\n          end;\n \n-         --  Here we know the result is Long_Long_Integer'Base\n+         --  Here we know the result is Long_Long_Integer'Base, or that it\n+         --  has been rewritten because the parent is a conversion (see\n+         --  Apply_Arithmetic_Overflow_Check.Conversion_Optimization).\n \n       else\n-         pragma Assert (Etype (Op) = LLIB);\n+         pragma Assert\n+           (Etype (Op) = LLIB or else Nkind (Parent (Op)) = N_Type_Conversion);\n \n          --  All we need to do here is to convert the result to the proper\n          --  result type. As explained above for the Bignum case, we can\n@@ -6682,6 +6687,35 @@ package body Checks is\n    -- Minimize_Eliminate_Overflow_Checks --\n    ----------------------------------------\n \n+   --  This is a recursive routine that is called at the top of an expression\n+   --  tree to properly process overflow checking for a whole subtree by making\n+   --  recursive calls to process operands. This processing may involve the use\n+   --  of bignum or long long integer arithmetic, which will change the types\n+   --  of operands and results. That's why we can't do this bottom up (since\n+   --  it would intefere with semantic analysis).\n+\n+   --  What happens is that if Minimized/Eliminated mode is in effect then\n+   --  the operator expansion routines, as well as the expansion routines\n+   --  for if/case expression test the Do_Overflow_Check flag and if it is\n+   --  set they (for the moment) do nothing except call the routine to apply\n+   --  the overflow check (Apply_Arithmetic_Overflow_Check). That routine\n+   --  does nothing for non top-level nodes, so at the point where the call\n+   --  is made for the top level node, the entire expression subtree has not\n+   --  been expanded, or processed for overflow. All that has to happen as a\n+   --  result of the top level call to this routine.\n+\n+   --  As noted above, the overflow processing works by making recursive calls\n+   --  for the operands, and figuring out what to do, based on the processing\n+   --  of these operands (e.g. if a bignum operand appears, the parent op has\n+   --  to be done in bignum mode), and the determined ranges of the operands.\n+\n+   --  After possible rewriting of a constituent subexpression node, a call is\n+   --  made to reanalyze the node after setting Analyzed to False. To avoid a\n+   --  recursive call into the whole overflow apparatus, and important rule for\n+   --  this reanalysis call is that either Do_Overflow_Check must be False, or\n+   --  if it is set, then the overflow checking mode must be temporarily set\n+   --  to Checked/Suppressed. Either step will avoid the unwanted recursion.\n+\n    procedure Minimize_Eliminate_Overflow_Checks\n      (N         : Node_Id;\n       Lo        : out Uint;\n@@ -6743,10 +6777,14 @@ package body Checks is\n \n       function In_Result_Range return Boolean is\n       begin\n-         if Is_Static_Subtype (Etype (N)) then\n+         if Lo = No_Uint or else Hi = No_Uint then\n+            return False;\n+\n+         elsif Is_Static_Subtype (Etype (N)) then\n             return Lo >= Expr_Value (Type_Low_Bound  (Rtyp))\n                      and then\n                    Hi <= Expr_Value (Type_High_Bound (Rtyp));\n+\n          else\n             return Lo >= Expr_Value (Type_Low_Bound  (Base_Type (Rtyp)))\n                      and then\n@@ -6853,10 +6891,13 @@ package body Checks is\n             --  If we have no Long_Long_Integer operands, then we are in result\n             --  range, since it means that none of our operands felt the need\n             --  to worry about overflow (otherwise it would have already been\n-            --  converted to long long integer or bignum).\n+            --  converted to long long integer or bignum). We reanalyze to\n+            --  complete the expansion of the if expression\n \n             elsif not Long_Long_Integer_Operands then\n                Set_Do_Overflow_Check (N, False);\n+               Set_Analyzed (N, False);\n+               Analyze_And_Resolve (N, Suppress => Overflow_Check);\n \n             --  Otherwise convert us to long long integer mode. Note that we\n             --  don't need any further overflow checking at this level.\n@@ -6865,7 +6906,12 @@ package body Checks is\n                Convert_To_And_Rewrite (LLIB, Then_DE);\n                Convert_To_And_Rewrite (LLIB, Else_DE);\n                Set_Etype (N, LLIB);\n+\n+               --  Now reanalyze with overflow checks off\n+\n                Set_Do_Overflow_Check (N, False);\n+               Set_Analyzed (N, False);\n+               Analyze_And_Resolve (N, LLIB, Suppress => Overflow_Check);\n             end if;\n          end;\n \n@@ -6880,10 +6926,7 @@ package body Checks is\n          Hi := No_Uint;\n \n          declare\n-            Alt      : Node_Id;\n-            New_Alts : List_Id;\n-            New_Exp  : Node_Id;\n-            Rtype    : Entity_Id;\n+            Alt : Node_Id;\n \n          begin\n             --  Loop through expressions applying recursive call\n@@ -6915,40 +6958,48 @@ package body Checks is\n             --  we will properly reexpand and get the needed expansion for\n             --  the case expression.\n \n-            if not (Bignum_Operands or else Long_Long_Integer_Operands) then\n+            if not (Bignum_Operands or Long_Long_Integer_Operands) then\n                Set_Do_Overflow_Check (N, False);\n                Set_Analyzed (N, False);\n+               Analyze_And_Resolve (N, Suppress => Overflow_Check);\n \n             --  Otherwise we are going to rebuild the case expression using\n             --  either bignum or long long integer operands throughout.\n \n             else\n-               New_Alts := New_List;\n-               Alt := First (Alternatives (N));\n-               while Present (Alt) loop\n-                  if Bignum_Operands then\n-                     New_Exp := Convert_To_Bignum (Expression (Alt));\n-                     Rtype   := RTE (RE_Bignum);\n-                  else\n-                     New_Exp := Convert_To (LLIB, Expression (Alt));\n-                     Rtype   := LLIB;\n-                  end if;\n+               declare\n+                  Rtype    : Entity_Id;\n+                  New_Alts : List_Id;\n+                  New_Exp  : Node_Id;\n \n-                  Append_To (New_Alts,\n-                    Make_Case_Expression_Alternative (Sloc (Alt),\n-                      Actions          => No_List,\n-                      Discrete_Choices => Discrete_Choices (Alt),\n-                      Expression       => New_Exp));\n+               begin\n+                  New_Alts := New_List;\n+                  Alt := First (Alternatives (N));\n+                  while Present (Alt) loop\n+                     if Bignum_Operands then\n+                        New_Exp := Convert_To_Bignum (Expression (Alt));\n+                        Rtype   := RTE (RE_Bignum);\n+                     else\n+                        New_Exp := Convert_To (LLIB, Expression (Alt));\n+                        Rtype   := LLIB;\n+                     end if;\n \n-                  Next (Alt);\n-               end loop;\n+                     Append_To (New_Alts,\n+                       Make_Case_Expression_Alternative (Sloc (Alt),\n+                         Actions          => No_List,\n+                         Discrete_Choices => Discrete_Choices (Alt),\n+                         Expression       => New_Exp));\n \n-               Rewrite (N,\n-                 Make_Case_Expression (Loc,\n-                   Expression   => Expression (N),\n-                   Alternatives => New_Alts));\n+                     Next (Alt);\n+                  end loop;\n+\n+                  Rewrite (N,\n+                    Make_Case_Expression (Loc,\n+                      Expression   => Expression (N),\n+                      Alternatives => New_Alts));\n \n-               Analyze_And_Resolve (N, Rtype, Suppress => Overflow_Check);\n+                  Analyze_And_Resolve (N, Rtype, Suppress => Overflow_Check);\n+               end;\n             end if;\n          end;\n \n@@ -6967,7 +7018,17 @@ package body Checks is\n            (Left_Opnd (N), Llo, Lhi, Top_Level => False);\n       end if;\n \n-      --  If either operand is a bignum, then result will be a bignum\n+      --  Record if we have Long_Long_Integer operands\n+\n+      Long_Long_Integer_Operands :=\n+        Etype (Right_Opnd (N)) = LLIB\n+          or else (Binary and then Etype (Left_Opnd (N)) = LLIB);\n+\n+      --  If either operand is a bignum, then result will be a bignum and we\n+      --  don't need to do any range analysis. As previously discussed we could\n+      --  do range analysis in such cases, but it could mean working with giant\n+      --  numbers at compile time for very little gain (the number of cases\n+      --  in which we could slip back from bignum mode are small).\n \n       if Rlo = No_Uint or else (Binary and then Llo = No_Uint) then\n          Lo := No_Uint;\n@@ -7321,7 +7382,59 @@ package body Checks is\n          end case;\n       end if;\n \n-      --  Case where we do the operation in Bignum mode. This happens either\n+      --  If we know we are in the result range, and we do not have Bignum\n+      --  operands or Long_Long_Integer operands, we can just renalyze with\n+      --  overflow checks turned off (since we know we cannot have overflow).\n+      --  As always the reanalysis is required to complete expansion of the\n+      --  operator, and we prevent recursion by suppressing the check.\n+\n+      if not (Bignum_Operands or Long_Long_Integer_Operands)\n+        and then In_Result_Range\n+      then\n+         Set_Do_Overflow_Check (N, False);\n+         Set_Analyzed (N, False);\n+         Analyze_And_Resolve (N, Suppress => Overflow_Check);\n+         return;\n+\n+      --  Here we know that we are not in the result range, and in the general\n+      --  we will move into either the Bignum or Long_Long_Integer domain to\n+      --  compute the result. However, there is one exception. If we are at the\n+      --  top level, and we do not have Bignum or Long_Long_Integer operands,\n+      --  we will have to immediately convert the result back to the result\n+      --  type, so there is no point in Bignum/Long_Long_Integer fiddling.\n+\n+      elsif Top_Level\n+        and then not (Bignum_Operands or Long_Long_Integer_Operands)\n+      then\n+         --  Here we will keep the original types, but we do need an overflow\n+         --  check, so we will set Do_Overflow_Check to True (actually it is\n+         --  true already, or how would we have got here?).\n+\n+         pragma Assert (Do_Overflow_Check (N));\n+         Set_Analyzed (N, False);\n+\n+         --  One subtlety. We can't just go ahead and do an analyze operation\n+         --  here because it will cause recursion into the whole minimized/\n+         --  eliminated overflow processing which is not what we want. Here\n+         --  we are at the top level, and we need a check against the result\n+         --  mode (i.e. we want to use Checked mode). So do exactly that!\n+\n+         declare\n+            Svg : constant Overflow_Check_Type :=\n+                    Scope_Suppress.Overflow_Checks_General;\n+            Sva : constant Overflow_Check_Type :=\n+                    Scope_Suppress.Overflow_Checks_Assertions;\n+         begin\n+            Scope_Suppress.Overflow_Checks_General    := Checked;\n+            Scope_Suppress.Overflow_Checks_Assertions := Checked;\n+            Analyze_And_Resolve (N);\n+            Scope_Suppress.Overflow_Checks_General    := Svg;\n+            Scope_Suppress.Overflow_Checks_Assertions := Sva;\n+         end;\n+\n+         return;\n+\n+      --  Cases where we do the operation in Bignum mode. This happens either\n       --  because one of our operands is in Bignum mode already, or because\n       --  the computed bounds are outside the bounds of Long_Long_Integer,\n       --  which in some cases can be indicated by Hi and Lo being No_Uint.\n@@ -7331,10 +7444,10 @@ package body Checks is\n       --  0 .. 1, but the cases are rare and it is not worth the effort.\n       --  Failing to do this switching back is only an efficiency issue.\n \n-      if Lo = No_Uint or else Lo < LLLo or else Hi > LLHi then\n+      elsif Lo = No_Uint or else Lo < LLLo or else Hi > LLHi then\n \n          --  OK, we are definitely outside the range of Long_Long_Integer. The\n-         --  question is whether to move into Bignum mode, or remain the domain\n+         --  question is whether to move to Bignum mode, or stay in the domain\n          --  of Long_Long_Integer, signalling that an overflow check is needed.\n \n          --  Obviously in MINIMIZED mode we stay with LLI, since we are not in\n@@ -7440,12 +7553,21 @@ package body Checks is\n          Set_Do_Overflow_Check (N, False);\n       end if;\n \n-      --  If Result is in range of the result type, and we don't have any\n-      --  Long_Long_Integer operands, then overflow checking is not needed\n-      --  and we have nothing to do (we have already reset Do_Overflow_Check).\n+      --  Here we are not in Bignum territory, but we may have long long\n+      --  integer operands that need special handling. First a special check:\n+      --  If an exponentiation operator exponent is of type Long_Long_Integer,\n+      --  it means we converted it to prevent overflow, but exponentiation\n+      --  requires a Natural right operand, so convert it back to Natural.\n+      --  This conversion may raise an exception which is fine.\n \n-      if In_Result_Range and not Long_Long_Integer_Operands then\n-         return;\n+      if Nkind (N) = N_Op_Expon and then Etype (Right_Opnd (N)) = LLIB then\n+         Convert_To_And_Rewrite (Standard_Natural, Right_Opnd (N));\n+\n+         --  Now Long_Long_Integer_Operands may have to be reset if that was\n+         --  the only long long integer operand, i.e. we now have long long\n+         --  integer operands only if the left operand is long long integer.\n+\n+         Long_Long_Integer_Operands := Etype (Left_Opnd (N)) = LLIB;\n       end if;\n \n       --  Here we will do the operation in Long_Long_Integer. We do this even"}, {"sha": "8efaecef78045e2d9d028d0147793c64735b5ae0", "filename": "gcc/ada/checks.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6b5cca81b846b91c3a4b35bcedd2294a6ee4dfd/gcc%2Fada%2Fchecks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6b5cca81b846b91c3a4b35bcedd2294a6ee4dfd/gcc%2Fada%2Fchecks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.ads?ref=b6b5cca81b846b91c3a4b35bcedd2294a6ee4dfd", "patch": "@@ -142,7 +142,7 @@ package Checks is\n    --  overflow checking for dependent expressions. This routine handles\n    --  front end vs back end overflow checks (in the front end case it expands\n    --  the necessary check). Note that divide is handled separately using\n-   --  Apply_Arithmetic_Divide_Overflow_Check.\n+   --  Apply_Divide_Checks.\n \n    procedure Apply_Constraint_Check\n      (N          : Node_Id;"}, {"sha": "dc5a299b7195037ce75e9af355483961842b5335", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 223, "deletions": 81, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6b5cca81b846b91c3a4b35bcedd2294a6ee4dfd/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6b5cca81b846b91c3a4b35bcedd2294a6ee4dfd/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=b6b5cca81b846b91c3a4b35bcedd2294a6ee4dfd", "patch": "@@ -212,6 +212,21 @@ package body Exp_Ch4 is\n    --  constrained type (the caller has ensured this by using\n    --  Convert_To_Actual_Subtype if necessary).\n \n+   function Minimized_Eliminated_Overflow_Check (N : Node_Id) return Boolean;\n+   --  For signed arithmetic operations with Do_Overflow_Check set when the\n+   --  current overflow mode is MINIMIZED or ELIMINATED, we need to make a\n+   --  call to Apply_Arithmetic_Overflow_Checks as the first thing we do. We\n+   --  then return. We count on the recursive apparatus for overflow checks\n+   --  to call us back with an equivalent operation that does not have the\n+   --  Do_Overflow_Check flag set, and that is when we will proceed with the\n+   --  expansion of the operator (e.g. converting X+0 to X, or X**2 to X*X).\n+   --  We cannot do these optimizations without first making this check, since\n+   --  there may be operands further down the tree that are relying on the\n+   --  recursive calls triggered by the top level nodes to properly process\n+   --  overflow checking and remaining expansion on these nodes. Note that\n+   --  this call back may be skipped if the operation is done in Bignum mode\n+   --  but that's fine, since the Bignum call takes care of everything.\n+\n    procedure Optimize_Length_Comparison (N : Node_Id);\n    --  Given an expression, if it is of the form X'Length op N (or the other\n    --  way round), where N is known at compile time to be 0 or 1, and X is a\n@@ -2383,9 +2398,9 @@ package body Exp_Ch4 is\n \n          when N_Op_Lt =>\n             if Llo >= Rhi then\n-               Set_True;\n-            elsif Lhi < Rlo then\n                Set_False;\n+            elsif Lhi < Rlo then\n+               Set_True;\n             end if;\n \n          when N_Op_Ne =>\n@@ -3721,11 +3736,14 @@ package body Exp_Ch4 is\n       --  Despite the name, this routine applies only to N_In, not to\n       --  N_Not_In. The latter is always rewritten as not (X in Y).\n \n-      Loc   : constant Source_Ptr := Sloc (N);\n-      Lop   : constant Node_Id    := Left_Opnd (N);\n-      Rop   : constant Node_Id    := Right_Opnd (N);\n-      Ltype : constant Entity_Id  := Etype (Lop);\n-      Rtype : constant Entity_Id  := Etype (Rop);\n+      Loc : constant Source_Ptr := Sloc (N);\n+      Lop : constant Node_Id    := Left_Opnd (N);\n+      Rop : constant Node_Id    := Right_Opnd (N);\n+\n+      --  Note: there are many referencs to Etype (Lop) and Etype (Rop). It\n+      --  is thus tempting to capture these values, but due to the rewrites\n+      --  that occur as a result of overflow checking, these values change\n+      --  as we go along, and it is safe just to always use Etype explicitly.\n \n       Restype : constant Entity_Id := Etype (N);\n       --  Save result type\n@@ -3743,35 +3761,40 @@ package body Exp_Ch4 is\n       --  predicate, then we can just replace the right operand with an\n       --  explicit range T'First .. T'Last, and use the explicit range code.\n \n-      if Nkind (Rop) /= N_Range and then No (Predicate_Function (Rtype)) then\n-         Rewrite (Rop,\n-           Make_Range (Loc,\n-             Low_Bound =>\n-               Make_Attribute_Reference (Loc,\n-                 Attribute_Name => Name_First,\n-                 Prefix         => New_Reference_To (Rtype, Loc)),\n-\n-             High_Bound =>\n-               Make_Attribute_Reference (Loc,\n-                 Attribute_Name => Name_Last,\n-                 Prefix         => New_Reference_To (Rtype, Loc))));\n-         Analyze_And_Resolve (Rop, Rtype, Suppress => All_Checks);\n+      if Nkind (Rop) /= N_Range\n+        and then No (Predicate_Function (Etype (Rop)))\n+      then\n+         declare\n+            Rtyp : constant Entity_Id := Etype (Rop);\n+         begin\n+            Rewrite (Rop,\n+              Make_Range (Loc,\n+                Low_Bound =>\n+                  Make_Attribute_Reference (Loc,\n+                    Attribute_Name => Name_First,\n+                    Prefix         => New_Reference_To (Rtyp, Loc)),\n+                High_Bound =>\n+                  Make_Attribute_Reference (Loc,\n+                    Attribute_Name => Name_Last,\n+                    Prefix         => New_Reference_To (Rtyp, Loc))));\n+            Analyze_And_Resolve (Rop, Rtyp, Suppress => All_Checks);\n+         end;\n       end if;\n \n       --  Here for the explicit range case. Note that the bounds of the range\n       --  have not been processed for minimized or eliminated checks.\n \n       if Nkind (Rop) = N_Range then\n          Minimize_Eliminate_Overflow_Checks\n-           (Low_Bound (Rop),  Lo, Hi, Top_Level => False);\n+           (Low_Bound (Rop), Lo, Hi, Top_Level => False);\n          Minimize_Eliminate_Overflow_Checks\n            (High_Bound (Rop), Lo, Hi, Top_Level => False);\n \n          --  We have A in B .. C, treated as  A >= B and then A <= C\n \n          --  Bignum case\n \n-         if Is_RTE (Ltype, RE_Bignum)\n+         if Is_RTE (Etype (Lop), RE_Bignum)\n            or else Is_RTE (Etype (Low_Bound (Rop)), RE_Bignum)\n            or else Is_RTE (Etype (High_Bound (Rop)), RE_Bignum)\n          then\n@@ -3841,9 +3864,9 @@ package body Exp_Ch4 is\n          else\n             --  Case where types are all the same\n \n-            if Ltype = Etype (Low_Bound (Rop))\n+            if Base_Type (Etype (Lop)) = Base_Type (Etype (Low_Bound (Rop)))\n                  and then\n-               Ltype = Etype (High_Bound (Rop))\n+               Base_Type (Etype (Lop)) = Base_Type (Etype (High_Bound (Rop)))\n             then\n                null;\n \n@@ -3862,7 +3885,8 @@ package body Exp_Ch4 is\n             end if;\n \n             --  Now the three operands are of the same signed integer type,\n-            --  so we can use the normal expansion routine for membership.\n+            --  so we can use the normal expansion routine for membership,\n+            --  setting the flag to prevent recursion into this procedure.\n \n             Set_No_Minimize_Eliminate (N);\n             Expand_N_In (N);\n@@ -3873,17 +3897,17 @@ package body Exp_Ch4 is\n       --  the standard N_In circuitry with appropriate types.\n \n       else\n-         pragma Assert (Present (Predicate_Function (Rtype)));\n+         pragma Assert (Present (Predicate_Function (Etype (Rop))));\n \n          --  If types are \"right\", just call Expand_N_In preventing recursion\n \n-         if Base_Type (Ltype) = Base_Type (Rtype) then\n+         if Base_Type (Etype (Lop)) = Base_Type (Etype (Rop)) then\n             Set_No_Minimize_Eliminate (N);\n             Expand_N_In (N);\n \n          --  Bignum case\n \n-         elsif Is_RTE (Ltype, RE_Bignum) then\n+         elsif Is_RTE (Etype (Lop), RE_Bignum) then\n \n             --  For X in T, we want to insert code that looks like\n \n@@ -3911,21 +3935,21 @@ package body Exp_Ch4 is\n             --  A bit gruesome, but here goes.\n \n             declare\n-               Blk    : constant Node_Id   := Make_Bignum_Block (Loc);\n-               Bnn    : constant Entity_Id := Make_Temporary (Loc, 'B', N);\n-               Lnn    : constant Entity_Id := Make_Temporary (Loc, 'L', N);\n-               Nnn    : constant Entity_Id := Make_Temporary (Loc, 'N', N);\n-               Nin    : Node_Id;\n+               Blk : constant Node_Id   := Make_Bignum_Block (Loc);\n+               Bnn : constant Entity_Id := Make_Temporary (Loc, 'B', N);\n+               Lnn : constant Entity_Id := Make_Temporary (Loc, 'L', N);\n+               Nnn : constant Entity_Id := Make_Temporary (Loc, 'N', N);\n+               Nin : Node_Id;\n \n             begin\n                --  The last membership test is marked to prevent recursion\n \n                Nin :=\n                  Make_In (Loc,\n                    Left_Opnd =>\n-                     Convert_To (Base_Type (Rtype),\n+                     Convert_To (Base_Type (Etype (Rop)),\n                        New_Occurrence_Of (Lnn, Loc)),\n-                   Right_Opnd => New_Occurrence_Of (Rtype, Loc));\n+                   Right_Opnd => New_Occurrence_Of (Etype (Rop), Loc));\n                Set_No_Minimize_Eliminate (Nin);\n \n                --  Now decorate the block\n@@ -3985,7 +4009,7 @@ package body Exp_Ch4 is\n                                     New_Occurrence_Of (Lnn, Loc),\n                                   Right_Opnd =>\n                                     New_Occurrence_Of\n-                                      (Base_Type (Rtype), Loc)),\n+                                      (Base_Type (Etype (Rop)), Loc)),\n                               Right_Opnd => Nin))))));\n \n                Insert_Actions (N, New_List (\n@@ -4001,10 +4025,10 @@ package body Exp_Ch4 is\n             end;\n \n          --  Not bignum case, but types don't match (this means we rewrote the\n-         --  left operand to be Long_Long_Integer.\n+         --  left operand to be Long_Long_Integer).\n \n          else\n-            pragma Assert (Base_Type (Ltype) = LLIB);\n+            pragma Assert (Base_Type (Etype (Lop)) = LLIB);\n \n             --  We rewrite the membership test as\n \n@@ -4019,8 +4043,9 @@ package body Exp_Ch4 is\n                Nin :=\n                  Make_In (Loc,\n                    Left_Opnd =>\n-                     Convert_To (Base_Type (Rtype), Duplicate_Subexpr (Lop)),\n-                   Right_Opnd => New_Occurrence_Of (Rtype, Loc));\n+                     Convert_To (Base_Type (Etype (Rop)),\n+                       Duplicate_Subexpr (Lop)),\n+                   Right_Opnd => New_Occurrence_Of (Etype (Rop), Loc));\n                Set_No_Minimize_Eliminate (Nin);\n \n                --  Now do the rewrite\n@@ -4031,7 +4056,7 @@ package body Exp_Ch4 is\n                      Make_In (Loc,\n                        Left_Opnd  => Lop,\n                        Right_Opnd =>\n-                         New_Occurrence_Of (Base_Type (Ltype), Loc)),\n+                         New_Occurrence_Of (Base_Type (Etype (Lop)), Loc)),\n                    Right_Opnd => Nin));\n \n                Analyze_And_Resolve (N, Restype, Suppress => All_Checks);\n@@ -4776,14 +4801,9 @@ package body Exp_Ch4 is\n       Fexp    : Node_Id;\n \n    begin\n-      --  If Do_Overflow_Check is set, it means we are in MINIMIZED/ELIMINATED\n-      --  mode, and all we do is to call Apply_Arithmetic_Overflow_Check to\n-      --  ensure proper overflow handling for the dependent expressions. The\n-      --  checks circuitry will rewrite the case expression in this case with\n-      --  Do_Overflow_Checks off. so that when that rewritten node arrives back\n-      --  here, then we will do the full expansion.\n-\n-      if Do_Overflow_Check (N) then\n+      --  Check for MINIMIZED/ELIMINATED overflow mode\n+\n+      if Minimized_Eliminated_Overflow_Check (N) then\n          Apply_Arithmetic_Overflow_Check (N);\n          return;\n       end if;\n@@ -5170,6 +5190,13 @@ package body Exp_Ch4 is\n       New_N   : Node_Id;\n \n    begin\n+      --  Check for MINIMIZED/ELIMINATED overflow mode\n+\n+      if Minimized_Eliminated_Overflow_Check (N) then\n+         Apply_Arithmetic_Overflow_Check (N);\n+         return;\n+      end if;\n+\n       --  Fold at compile time if condition known. We have already folded\n       --  static if expressions, but it is possible to fold any case in which\n       --  the condition is known at compile time, even though the result is\n@@ -5383,15 +5410,6 @@ package body Exp_Ch4 is\n          --  the same approach as a C conditional expression.\n \n       else\n-         --  If Do_Overflow_Check is set it means we have a signed intger type\n-         --  in MINIMIZED or ELIMINATED mode, so we apply an overflow check to\n-         --  the if expression (to make sure that overflow checking is properly\n-         --  handled for dependent expressions).\n-\n-         if Do_Overflow_Check (N) then\n-            Apply_Arithmetic_Overflow_Check (N);\n-         end if;\n-\n          return;\n       end if;\n \n@@ -5500,18 +5518,35 @@ package body Exp_Ch4 is\n \n       --  Check case of explicit test for an expression in range of its\n       --  subtype. This is suspicious usage and we replace it with a 'Valid\n-      --  test and give a warning. For floating point types however, this is a\n-      --  standard way to check for finite numbers, and using 'Valid would\n-      --  typically be a pessimization. Also skip this test for predicated\n-      --  types, since it is perfectly reasonable to check if a value meets\n-      --  its predicate.\n+      --  test and give a warning for scalar types.\n \n       if Is_Scalar_Type (Ltyp)\n+\n+        --  Only relevant for source comparisons\n+\n+        and then Comes_From_Source (N)\n+\n+        --  In floating-point this is a standard way to check for finite values\n+        --  and using 'Valid would typically be a pessimization.\n+\n         and then not Is_Floating_Point_Type (Ltyp)\n+\n+        --  Don't give the message unless right operand is a type entity and\n+        --  the type of the left operand matches this type. Note that this\n+        --  eliminates the cases where MINIMIZED/ELIMINATED mode overflow\n+        --  checks have changed the type of the left operand.\n+\n         and then Nkind (Rop) in N_Has_Entity\n         and then Ltyp = Entity (Rop)\n-        and then Comes_From_Source (N)\n+\n+        --  Skip in VM mode, where we have no sense of invalid values. The\n+        --  warning still seems relevant, but not important enough to worry.\n+\n         and then VM_Target = No_VM\n+\n+        --  Skip this for predicated types, where such expressions are a\n+        --  reasonable way of testing if something meets the predicate.\n+\n         and then not (Is_Discrete_Type (Ltyp)\n                        and then Present (Predicate_Function (Ltyp)))\n       then\n@@ -5564,15 +5599,30 @@ package body Exp_Ch4 is\n             --  Could use some individual comments for this complex test ???\n \n             if Is_Scalar_Type (Ltyp)\n+\n+              --  And left operand is X'First where X matches left operand\n+              --  type (this eliminates cases of type mismatch, including\n+              --  the cases where ELIMINATED/MINIMIZED mode has changed the\n+              --  type of the left operand.\n+\n               and then Nkind (Lo_Orig) = N_Attribute_Reference\n               and then Attribute_Name (Lo_Orig) = Name_First\n               and then Nkind (Prefix (Lo_Orig)) in N_Has_Entity\n               and then Entity (Prefix (Lo_Orig)) = Ltyp\n+\n+            --  Same tests for right operand\n+\n               and then Nkind (Hi_Orig) = N_Attribute_Reference\n               and then Attribute_Name (Hi_Orig) = Name_Last\n               and then Nkind (Prefix (Hi_Orig)) in N_Has_Entity\n               and then Entity (Prefix (Hi_Orig)) = Ltyp\n+\n+              --  Relevant only for source cases\n+\n               and then Comes_From_Source (N)\n+\n+              --  Omit for VM cases, where we don't have invalid values\n+\n               and then VM_Target = No_VM\n             then\n                Substitute_Valid_Check;\n@@ -6331,6 +6381,13 @@ package body Exp_Ch4 is\n    begin\n       Unary_Op_Validity_Checks (N);\n \n+      --  Check for MINIMIZED/ELIMINATED overflow mode\n+\n+      if Minimized_Eliminated_Overflow_Check (N) then\n+         Apply_Arithmetic_Overflow_Check (N);\n+         return;\n+      end if;\n+\n       --  Deal with software overflow checking\n \n       if not Backend_Overflow_Checks_On_Target\n@@ -6374,6 +6431,13 @@ package body Exp_Ch4 is\n    begin\n       Binary_Op_Validity_Checks (N);\n \n+      --  Check for MINIMIZED/ELIMINATED overflow mode\n+\n+      if Minimized_Eliminated_Overflow_Check (N) then\n+         Apply_Arithmetic_Overflow_Check (N);\n+         return;\n+      end if;\n+\n       --  N + 0 = 0 + N = N for integer types\n \n       if Is_Integer_Type (Typ) then\n@@ -6516,6 +6580,15 @@ package body Exp_Ch4 is\n    begin\n       Binary_Op_Validity_Checks (N);\n \n+      --  Check for MINIMIZED/ELIMINATED overflow mode\n+\n+      if Minimized_Eliminated_Overflow_Check (N) then\n+         Apply_Arithmetic_Overflow_Check (N);\n+         return;\n+      end if;\n+\n+      --  Otherwise proceed with expansion of division\n+\n       if Rknow then\n          Rval := Expr_Value (Ropnd);\n       end if;\n@@ -7284,19 +7357,9 @@ package body Exp_Ch4 is\n          end;\n       end if;\n \n-      --  Normally we complete expansion of exponentiation (e.g. converting\n-      --  to multplications) right here, but there is one exception to this.\n-      --  If we have a signed integer type and the overflow checking mode\n-      --  is MINIMIZED or ELIMINATED and overflow checking is activated, then\n-      --  we don't yet want to expand, since that will intefere with handling\n-      --  of extended precision intermediate value. In this situation we just\n-      --  apply the arithmetic overflow check, and then the overflow check\n-      --  circuit will re-expand the exponentiation node in CHECKED mode.\n+      --  Check for MINIMIZED/ELIMINATED overflow mode\n \n-      if Is_Signed_Integer_Type (Rtyp)\n-        and then Overflow_Check_Mode (Typ) in Minimized_Or_Eliminated\n-        and then Do_Overflow_Check (N)\n-      then\n+      if Minimized_Eliminated_Overflow_Check (N) then\n          Apply_Arithmetic_Overflow_Check (N);\n          return;\n       end if;\n@@ -7792,6 +7855,13 @@ package body Exp_Ch4 is\n    begin\n       Unary_Op_Validity_Checks (N);\n \n+      --  Check for MINIMIZED/ELIMINATED overflow mode\n+\n+      if Minimized_Eliminated_Overflow_Check (N) then\n+         Apply_Arithmetic_Overflow_Check (N);\n+         return;\n+      end if;\n+\n       if not Backend_Overflow_Checks_On_Target\n          and then Is_Signed_Integer_Type (Etype (N))\n          and then Do_Overflow_Check (N)\n@@ -7819,11 +7889,12 @@ package body Exp_Ch4 is\n    procedure Expand_N_Op_Mod (N : Node_Id) is\n       Loc   : constant Source_Ptr := Sloc (N);\n       Typ   : constant Entity_Id  := Etype (N);\n-      Left  : constant Node_Id    := Left_Opnd (N);\n-      Right : constant Node_Id    := Right_Opnd (N);\n       DOC   : constant Boolean    := Do_Overflow_Check (N);\n       DDC   : constant Boolean    := Do_Division_Check (N);\n \n+      Left  : Node_Id;\n+      Right : Node_Id;\n+\n       LLB : Uint;\n       Llo : Uint;\n       Lhi : Uint;\n@@ -7837,10 +7908,29 @@ package body Exp_Ch4 is\n    begin\n       Binary_Op_Validity_Checks (N);\n \n+      --  Check for MINIMIZED/ELIMINATED overflow mode\n+\n+      if Minimized_Eliminated_Overflow_Check (N) then\n+         Apply_Arithmetic_Overflow_Check (N);\n+         return;\n+      end if;\n+\n       if Is_Integer_Type (Etype (N)) then\n          Apply_Divide_Checks (N);\n+\n+         --  All done if we don't have a MOD any more, which can happen as a\n+         --  result of overflow expansion in MINIMIZED or ELIMINATED modes.\n+\n+         if Nkind (N) /= N_Op_Mod then\n+            return;\n+         end if;\n       end if;\n \n+      --  Proceed with expansion of mod operator\n+\n+      Left  := Left_Opnd (N);\n+      Right := Right_Opnd (N);\n+\n       Determine_Range (Right, ROK, Rlo, Rhi, Assume_Valid => True);\n       Determine_Range (Left,  LOK, Llo, Lhi, Assume_Valid => True);\n \n@@ -7960,6 +8050,13 @@ package body Exp_Ch4 is\n    begin\n       Binary_Op_Validity_Checks (N);\n \n+      --  Check for MINIMIZED/ELIMINATED overflow mode\n+\n+      if Minimized_Eliminated_Overflow_Check (N) then\n+         Apply_Arithmetic_Overflow_Check (N);\n+         return;\n+      end if;\n+\n       --  Special optimizations for integer types\n \n       if Is_Integer_Type (Typ) then\n@@ -8482,6 +8579,13 @@ package body Exp_Ch4 is\n    procedure Expand_N_Op_Plus (N : Node_Id) is\n    begin\n       Unary_Op_Validity_Checks (N);\n+\n+      --  Check for MINIMIZED/ELIMINATED overflow mode\n+\n+      if Minimized_Eliminated_Overflow_Check (N) then\n+         Apply_Arithmetic_Overflow_Check (N);\n+         return;\n+      end if;\n    end Expand_N_Op_Plus;\n \n    ---------------------\n@@ -8492,8 +8596,8 @@ package body Exp_Ch4 is\n       Loc : constant Source_Ptr := Sloc (N);\n       Typ : constant Entity_Id  := Etype (N);\n \n-      Left  : constant Node_Id := Left_Opnd (N);\n-      Right : constant Node_Id := Right_Opnd (N);\n+      Left  : Node_Id;\n+      Right : Node_Id;\n \n       Lo : Uint;\n       Hi : Uint;\n@@ -8508,10 +8612,29 @@ package body Exp_Ch4 is\n    begin\n       Binary_Op_Validity_Checks (N);\n \n+      --  Check for MINIMIZED/ELIMINATED overflow mode\n+\n+      if Minimized_Eliminated_Overflow_Check (N) then\n+         Apply_Arithmetic_Overflow_Check (N);\n+         return;\n+      end if;\n+\n       if Is_Integer_Type (Etype (N)) then\n          Apply_Divide_Checks (N);\n+\n+         --  All done if we don't have a REM any more, which can happen as a\n+         --  result of overflow expansion in MINIMIZED or ELIMINATED modes.\n+\n+         if Nkind (N) /= N_Op_Rem then\n+            return;\n+         end if;\n       end if;\n \n+      --  Proceed with expansion of REM\n+\n+      Left  := Left_Opnd (N);\n+      Right := Right_Opnd (N);\n+\n       --  Apply optimization x rem 1 = 0. We don't really need that with gcc,\n       --  but it is useful with other back ends (e.g. AAMP), and is certainly\n       --  harmless.\n@@ -8624,6 +8747,13 @@ package body Exp_Ch4 is\n    begin\n       Binary_Op_Validity_Checks (N);\n \n+      --  Check for MINIMIZED/ELIMINATED overflow mode\n+\n+      if Minimized_Eliminated_Overflow_Check (N) then\n+         Apply_Arithmetic_Overflow_Check (N);\n+         return;\n+      end if;\n+\n       --  N - 0 = N for integer types\n \n       if Is_Integer_Type (Typ)\n@@ -11626,6 +11756,18 @@ package body Exp_Ch4 is\n       return Func_Body;\n    end Make_Boolean_Array_Op;\n \n+   -----------------------------------------\n+   -- Minimized_Eliminated_Overflow_Check --\n+   -----------------------------------------\n+\n+   function Minimized_Eliminated_Overflow_Check (N : Node_Id) return Boolean is\n+   begin\n+      return\n+        Is_Signed_Integer_Type (Etype (N))\n+          and then Do_Overflow_Check (N)\n+          and then Overflow_Check_Mode (Empty) in Minimized_Or_Eliminated;\n+   end Minimized_Eliminated_Overflow_Check;\n+\n    --------------------------------\n    -- Optimize_Length_Comparison --\n    --------------------------------\n@@ -12216,7 +12358,7 @@ package body Exp_Ch4 is\n          end if;\n       end Is_Safe_Operand;\n \n-   --  Start of processing for Is_Safe_In_Place_Array_Op\n+   --  Start of processing for Safe_In_Place_Array_Op\n \n    begin\n       --  Skip this processing if the component size is different from system"}, {"sha": "9e875bc9c52f6b6773ccd68a8165da2eecb21fc2", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6b5cca81b846b91c3a4b35bcedd2294a6ee4dfd/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6b5cca81b846b91c3a4b35bcedd2294a6ee4dfd/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=b6b5cca81b846b91c3a4b35bcedd2294a6ee4dfd", "patch": "@@ -4147,7 +4147,8 @@ MODE ::= SUPPRESSED | CHECKED | MINIMIZED | ELIMINATED\n \n @noindent\n This pragma sets the current overflow mode to the given mode. For details\n-of the meaning of these modes, see section on overflow checking in the\n+of the meaning of these modes, please refer to the\n+``Overflow Check Handling in GNAT'' appendix in the\n @value{EDITION} User's Guide. If only the @code{General} parameter is present,\n the given mode applies to all expressions. If both parameters are present,\n the @code{General} mode applies to expressions outside assertions, and\n@@ -4169,6 +4170,7 @@ The pragma @code{Suppress (Overflow_Check)} sets mode\n    General => Suppressed\n @end smallexample\n \n+@noindent\n suppressing all overflow checking within and outside\n assertions.\n \n@@ -4178,9 +4180,11 @@ The pragam @code{Unsuppress (Overflow_Check)} sets mode\n    General => Checked\n @end smallexample\n \n+@noindent\n which causes overflow checking of all intermediate overflows.\n This applies both inside and outside assertions.\n \n+\n @node Pragma Passive\n @unnumberedsec Pragma Passive\n @findex Passive"}, {"sha": "098f943e32ef481dd86f1b78e6d33e6c31f73d0b", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6b5cca81b846b91c3a4b35bcedd2294a6ee4dfd/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6b5cca81b846b91c3a4b35bcedd2294a6ee4dfd/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=b6b5cca81b846b91c3a4b35bcedd2294a6ee4dfd", "patch": "@@ -869,6 +869,24 @@ package body Sem_Ch6 is\n          then\n             Rewrite (Expr, Convert_To (R_Type, Relocate_Node (Expr)));\n             Analyze_And_Resolve (Expr, R_Type);\n+\n+         --  If this is a local anonymous access to subprogram, the\n+         --  accessibility check can be applied statically. The return is\n+         --  illegal if the access type of the return expression is declared\n+         --  inside of the subprogram (except if it is the subtype indication\n+         --  of an extended return statement).\n+\n+         elsif  Ekind (R_Type) = E_Anonymous_Access_Subprogram_Type then\n+            if not Comes_From_Source (Current_Scope)\n+              or else Ekind (Current_Scope) = E_Return_Statement\n+            then\n+               null;\n+\n+            elsif\n+                Scope_Depth (Scope (Etype (Expr))) >= Scope_Depth (Scope_Id)\n+            then\n+               Error_Msg_N (\"cannot return local access to subprogram\", N);\n+            end if;\n          end if;\n \n          --  If the result type is class-wide, then check that the return"}, {"sha": "116864aa2a93fc96f7abf56dc23f451488686763", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6b5cca81b846b91c3a4b35bcedd2294a6ee4dfd/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6b5cca81b846b91c3a4b35bcedd2294a6ee4dfd/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=b6b5cca81b846b91c3a4b35bcedd2294a6ee4dfd", "patch": "@@ -949,21 +949,31 @@ package body Sem_Eval is\n             LLo, LHi : Uint;\n             RLo, RHi : Uint;\n \n+            Single : Boolean;\n+            --  True if each range is a single point\n+\n          begin\n             Determine_Range (L, LOK, LLo, LHi, Assume_Valid);\n             Determine_Range (R, ROK, RLo, RHi, Assume_Valid);\n \n             if LOK and ROK then\n+               Single := (LLo = LHi) and then (RLo = RHi);\n+\n                if LHi < RLo then\n+                  if Single and Assume_Valid then\n+                     Diff.all := RLo - LLo;\n+                  end if;\n+\n                   return LT;\n \n                elsif RHi < LLo then\n+                  if Single and Assume_Valid then\n+                     Diff.all := LLo - RLo;\n+                  end if;\n+\n                   return GT;\n \n-               elsif LLo = LHi\n-                 and then RLo = RHi\n-                 and then LLo = RLo\n-               then\n+               elsif Single and then LLo = RLo then\n \n                   --  If the range includes a single literal and we can assume\n                   --  validity then the result is known even if an operand is"}, {"sha": "5095088f0bcb9d07bb610a78e592ccfcb8a8c53c", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6b5cca81b846b91c3a4b35bcedd2294a6ee4dfd/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6b5cca81b846b91c3a4b35bcedd2294a6ee4dfd/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=b6b5cca81b846b91c3a4b35bcedd2294a6ee4dfd", "patch": "@@ -7162,7 +7162,7 @@ package body Sem_Res is\n       --  a constraint check.\n \n       if Is_Scalar_Type (Then_Typ)\n-        and then Then_Typ /= Typ\n+        and then Base_Type (Then_Typ) /= Base_Type (Typ)\n       then\n          Rewrite (Then_Expr, Convert_To (Typ, Then_Expr));\n          Analyze_And_Resolve (Then_Expr, Typ);"}]}