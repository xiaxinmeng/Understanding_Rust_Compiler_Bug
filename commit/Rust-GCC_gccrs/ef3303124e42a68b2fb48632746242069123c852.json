{"sha": "ef3303124e42a68b2fb48632746242069123c852", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWYzMzAzMTI0ZTQyYTY4YjJmYjQ4NjMyNzQ2MjQyMDY5MTIzYzg1Mg==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2005-07-05T16:20:53Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2005-07-05T16:20:53Z"}, "message": "Makefile.in: Adjust dependencies.\n\n2005-07-05  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* Makefile.in: Adjust dependencies.\n\t* tree-pass.h: Add new passes and passes formerly in tree-optimize.c.\n\t* basic-block.h (duplicate_computed_gotos): Remove, it is now static.\n\t* alias.c (rest_of_handle_cfg, pass_cfg): New.\n\t* bb-reorder.c (duplicate_computed_gotos): Make it static.\n\t* cfgexpand.c (tree_expand_cfg): Add code formerly at the beginning of\n\trest_of_compilation.\n\n\t* bb-reorder.c (gate_duplicate_computed_gotos,\n\tpass_duplicate_computed_gotos, gate_handle_reorder_blocks,\n\trest_of_handle_reorder_blocks, pass_reorder_blocks,\n\tgate_handle_partition_blocks, rest_of_handle_partition_blocks,\n\tpass_partition_blocks): New.\n\t* bt-load.c (gate_handle_branch_target_load_optimize,\n\trest_of_handle_branch_target_load_optimize,\n\tpass_branch_target_load_optimize): New.\n\t* cfgcleanup.c (rest_of_handle_jump, pass_jump, rest_of_handle_jump2,\n\tpass_jump2): New.\n\t* cfglayout.c (pass_insn_locators_initialize): New.\n\t* cfgrtl.c (pass_free_cfg): New.\n\t* combine.c (gate_handle_combine, rest_of_handle_combine,\n\tpass_combine): New.\n\t* cse.c (gate_handle_cse, rest_of_handle_cse, pass_cse,\n\tgate_handle_cse2, rest_of_handle_cse2, pass_cse2): New.\n\t* emit-rtl.c (pass_unshare_all_rtl, pass_remove_unnecessary_notes): New.\n\t* except.c (pass_set_nothrow_function_flags,\n\tpass_convert_to_eh_region_ranges, gate_handle_eh, rest_of_handle_eh,\n\tpass_rtl_eh): New.\n\t* final.c (pass_compute_alignments, rest_of_handle_final, pass_final,\n\trest_of_handle_shorten_branches, pass_shorten_branches,\n\trest_of_clean_state, pass_clean_state): New.\n\t* flow.c (pass_recompute_reg_usage, gate_remove_death_notes,\n\trest_of_handle_remove_death_notes, pass_remove_death_notes,\n\trest_of_handle_life, pass_life, rest_of_handle_flow2,\n\tpass_flow2): New.\n\t* function.c (pass_instantiate_virtual_regs, pass_init_function,\n\trest_of_handle_check_leaf_regs, pass_leaf_regs): New.\n\t* gcse.c (gate_handle_jump_bypass, rest_of_handle_jump_bypass,\n\tpass_jump_bypass, gate_handle_gcse, rest_of_handle_gcse,\n\tpass_gcse): New.\n\t* global.c (rest_of_handle_global_alloc, pass_global_alloc): New.\n\t* ifcvt.c (gate_handle_if_conversion, rest_of_handle_if_conversion,\n\tpass_rtl_ifcvt, gate_handle_if_after_combine,\n\trest_of_handle_if_after_combine, pass_if_after_combine,\n\tgate_handle_if_after_reload, rest_of_handle_if_after_reload,\n\tpass_if_after_reload): New.\n\t* integrate.c (pass_initial_value_sets): New.\n\t* jump.c (pass_cleanup_barriers, purge_line_number_notes,\n\tpass_purge_lineno_notes): New.\n\t* mode-switching.c (rest_of_handle_mode_switching,\n\tpass_mode_switching): New.\n\t* local-alloc.c (rest_of_handle_local_alloc, pass_local_alloc): New.\n\t* loop-init.c (gate_handle_loop2, rest_of_handle_loop2,\n\tpass_loop2): New.\n\t* loop.c (gate_handle_loop_optimize, rest_of_handle_loop_optimize,\n\tpass_loop_optimize): New.\n\t* modulo-sched.c (gate_handle_sms, rest_of_handle_sms,\n\tpass_sms): New.\n\t* postreload-gcse.c (gate_handle_gcse2, rest_of_handle_gcse2,\n\tpass_gcse2): New.\n\t* postreload.c (gate_handle_postreload, rest_of_handle_postreload,\n\tpass_postreload_cse): New.\n\t* profile.c (gate_handle_profiling, pass_profiling,\n\trest_of_handle_branch_prob, pass_branch_prob): New.\n\t* recog.c (pass pass_split_for_shorten_branches, gate_do_final_split,\n\tpass_split_before_regstack, gate_handle_split_before_regstack,\n\tgate_handle_peephole2, rest_of_handle_peephole2, pass_peephole2,\n\trest_of_handle_split_all_insns, pass_split_all_insns): New.\n\t* reg-stack.c (gate_handle_stack_regs, rest_of_handle_stack_regs,\n\tpass_stack_regs): New.\n\t* regmove.c (gate_handle_regmove, rest_of_handle_regmove, pass_regmove,\n\tgate_handle_stack_adjustments, rest_of_handle_stack_adjustments,\n\tpass_stack_adjustments): New.\n\t* regrename.c (gate_handle_regrename, rest_of_handle_regrename,\n\tpass_regrename): New.\n\t* reorg.c (gate_handle_delay_slots, rest_of_handle_delay_slots,\n\tpass_delay_slots, gate_handle_machine_reorg,\n\trest_of_handle_machine_reorg, pass_machine_reorg): New.\n\t* rtl.h (extern void purge_line_number_notes): New.\n\t* sched-rgn.c (gate_handle_sched, rest_of_handle_sched,\n\tgate_handle_sched2, rest_of_handle_sched2, pass_sched,\n\tpass_sched2): New.\n\t* tracer.c (gate_handle_tracer, rest_of_handle_tracer,\n\tpass_tracer): New.\n\t* value-prof.c (gate_handle_value_profile_transformations,\n\trest_of_handle_value_profile_transformations,\n\tpass_value_profile_transformations): New.\n\t* var-tracking.c (gate_handle_var_tracking,\n\tpass_variable_tracking): New.\n\t* web.c (gate_handle_web, rest_of_handle_web, pass_web): New.\n\n\t* passes.c (open_dump_file, close_dump_file, rest_of_handle_final,\n\trest_of_handle_delay_slots, rest_of_handle_stack_regs,\n\trest_of_handle_variable_tracking, rest_of_handle_machine_reorg,\n\trest_of_handle_old_regalloc, rest_of_handle_regrename,\n\trest_of_handle_reorder_blocks, rest_of_handle_partition_blocks,\n\trest_of_handle_sms, rest_of_handle_sched, rest_of_handle_sched2,\n\trest_of_handle_gcse2, rest_of_handle_regmove,\n\trest_of_handle_tracer, rest_of_handle_if_conversion,\n\trest_of_handle_if_after_combine, rest_of_handle_if_after_reload,\n\trest_of_handle_web, rest_of_handle_branch_prob,\n\trest_of_handle_value_profile_transformations, rest_of_handle_cfg,\n\trest_of_handle_jump_bypass, rest_of_handle_combine,\n\trest_of_handle_life, rest_of_handle_cse, rest_of_handle_cse2,\n\trest_of_handle_gcse, rest_of_handle_loop_optimize,\n\trest_of_handle_loop2, rest_of_handle_branch_target_load_optimize,\n\trest_of_handle_mode_switching, rest_of_handle_jump,\n\trest_of_handle_eh, rest_of_handle_stack_adjustments,\n\trest_of_handle_flow2, rest_of_handle_jump2,\n\trest_of_handle_peephole2, rest_of_handle_postreload,\n\trest_of_handle_shorten_branches, rest_of_clean_state,\n\trest_of_compilation): Remove.\n\n\t* cgraphunit.c (ipa_passes): Moved from tree-optimize.c.\n\t* passes.c (dump_flags, in_gimple_form, all_passes,\n\tall_ipa_passes, all_lowering_passes, register_one_dump_file,\n\tregister_dump_files, next_pass_1, last_verified, execute_todo,\n\texecute_one_pass, execute_pass_list, execute_ipa_pass_list): Moved\n\tfrom tree-optimize.c.\n\t(init_optimization_passes): Moved from tree-optimize.c,\n\tadding the RTL optimizations.\n\t* tree-dump.h (dump_info_p, dump_flag): Moved from tree.h.\n\t* tree-optimize.c (dump_flags, in_gimple_form, all_passes,\n\tall_ipa_passes, all_lowering_passes, register_one_dump_file,\n\tregister_dump_files, next_pass_1, last_verified, execute_todo,\n\texecute_one_pass, execute_pass_list, execute_ipa_pass_list,\n\tinit_tree_optimization_passes, ipa_passes): Delete.\n\t* tree-pass.h (enum tree_dump_index): Moved from tree.h, removing\n\tthe RTL dumps.\n\t(TDF_*, get_dump_file_name, dump_enabled_p, dump_initialized_p,\n\tdump_begin, dump_end, dump_node, dump_switch_p, dump_flag_name): Moved\n\tfrom tree.h.\n\t(ipa_passes): Remove.\n\t(all_passes, all_ipa_passes, all_lowering_passes): Now extern.\n\t* tree.h (enum tree_dump_index, TDF_*, get_dump_file_name,\n\tdump_enabled_p, dump_initialized_p, dump_begin, dump_end, dump_node,\n\tdump_switch_p, dump_flag_name): Moved to tree-pass.h.\n\t(dump_info_p, dump_flag): Moved to tree-dump.h.\n\n\t* Makefile.in: Adjust dependencies for tree-pretty-print.c,\n\tcgraph.c, opts.c.\n\t* passes.c (finish_optimization_passes): Use dump_begin\n\tand dump_end, TDI_end.\n\t(gate_rest_of_compilation): New.\n\t(pass_rest_of_compilation): Use it.\n\t(gate_postreload, pass_postreload): New.\n\t* toplev.c (general_init): Rename init_tree_optimization_passes.\n\t* toplev.h (init_tree_optimization_passes): Rename to\n\tinit_optimizations_passes.\n\t* tree-dump.c (dump_flag): Make static.\n\t(dump_files): Remove RTL dumps.\n\t* tree-optimize.c (pass_all_optimizations, pass_early_local_passes,\n\tpass_cleanup_cfg, pass_free_cfg_annotations,\n\tpass_cleanup_cfg_post_optimizing, pass_free_datastructures,\n\tpass_init_datastructures, pass_fixup_cfg): Make non-static.\n\t* tree-pretty-print.c: Include tree-pass.h.\n\t* cgraph.c: Include tree-dump.h.\n\ncp:\n2005-07-05  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* Makefile.in (class.o, decl2.o): Adjust dependencies.\n\t* class.c: Include tree-dump.h.\n\t* decl2.c: Include tree-dump.h.\n\njava:\n2005-07-05  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* Makefile.in (parse.o): Adjust dependencies.\n\t* parse.y: Include tree-dump.h.\n\nFrom-SVN: r101627", "tree": {"sha": "d89a5fdebc6c5d682db6ca72c2bac0046b3ef373", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d89a5fdebc6c5d682db6ca72c2bac0046b3ef373"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef3303124e42a68b2fb48632746242069123c852", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef3303124e42a68b2fb48632746242069123c852", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef3303124e42a68b2fb48632746242069123c852", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef3303124e42a68b2fb48632746242069123c852/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "47bcb538b497203e13bcf965302e5af682f2bf12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47bcb538b497203e13bcf965302e5af682f2bf12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47bcb538b497203e13bcf965302e5af682f2bf12"}], "stats": {"total": 5631, "additions": 3410, "deletions": 2221}, "files": [{"sha": "d680ff852b48b215fcf6ec557a0c70b3d5580c4b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -1,3 +1,163 @@\n+2005-07-05  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* Makefile.in: Adjust dependencies.\n+\t* tree-pass.h: Add new passes and passes formerly in tree-optimize.c.\n+\t* basic-block.h (duplicate_computed_gotos): Remove, it is now static.\n+\t* alias.c (rest_of_handle_cfg, pass_cfg): New.\n+\t* bb-reorder.c (duplicate_computed_gotos): Make it static.\n+\t* cfgexpand.c (tree_expand_cfg): Add code formerly at the beginning of\n+\trest_of_compilation.\n+\n+\t* bb-reorder.c (gate_duplicate_computed_gotos,\n+\tpass_duplicate_computed_gotos, gate_handle_reorder_blocks,\n+\trest_of_handle_reorder_blocks, pass_reorder_blocks,\n+\tgate_handle_partition_blocks, rest_of_handle_partition_blocks,\n+\tpass_partition_blocks): New.\n+\t* bt-load.c (gate_handle_branch_target_load_optimize,\n+\trest_of_handle_branch_target_load_optimize,\n+\tpass_branch_target_load_optimize): New.\n+\t* cfgcleanup.c (rest_of_handle_jump, pass_jump, rest_of_handle_jump2,\n+\tpass_jump2): New.\n+\t* cfglayout.c (pass_insn_locators_initialize): New.\n+\t* cfgrtl.c (pass_free_cfg): New.\n+\t* combine.c (gate_handle_combine, rest_of_handle_combine,\n+\tpass_combine): New.\n+\t* cse.c (gate_handle_cse, rest_of_handle_cse, pass_cse,\n+\tgate_handle_cse2, rest_of_handle_cse2, pass_cse2): New.\n+\t* emit-rtl.c (pass_unshare_all_rtl, pass_remove_unnecessary_notes): New.\n+\t* except.c (pass_set_nothrow_function_flags,\n+\tpass_convert_to_eh_region_ranges, gate_handle_eh, rest_of_handle_eh,\n+\tpass_rtl_eh): New.\n+\t* final.c (pass_compute_alignments, rest_of_handle_final, pass_final,\n+\trest_of_handle_shorten_branches, pass_shorten_branches,\n+\trest_of_clean_state, pass_clean_state): New.\n+\t* flow.c (pass_recompute_reg_usage, gate_remove_death_notes,\n+\trest_of_handle_remove_death_notes, pass_remove_death_notes,\n+\trest_of_handle_life, pass_life, rest_of_handle_flow2,\n+\tpass_flow2): New.\n+\t* function.c (pass_instantiate_virtual_regs, pass_init_function,\n+\trest_of_handle_check_leaf_regs, pass_leaf_regs): New.\n+\t* gcse.c (gate_handle_jump_bypass, rest_of_handle_jump_bypass,\n+\tpass_jump_bypass, gate_handle_gcse, rest_of_handle_gcse,\n+\tpass_gcse): New.\n+\t* global.c (rest_of_handle_global_alloc, pass_global_alloc): New.\n+\t* ifcvt.c (gate_handle_if_conversion, rest_of_handle_if_conversion,\n+\tpass_rtl_ifcvt, gate_handle_if_after_combine,\n+\trest_of_handle_if_after_combine, pass_if_after_combine,\n+\tgate_handle_if_after_reload, rest_of_handle_if_after_reload,\n+\tpass_if_after_reload): New.\n+\t* integrate.c (pass_initial_value_sets): New.\n+\t* jump.c (pass_cleanup_barriers, purge_line_number_notes,\n+\tpass_purge_lineno_notes): New.\n+\t* mode-switching.c (rest_of_handle_mode_switching,\n+\tpass_mode_switching): New.\n+\t* local-alloc.c (rest_of_handle_local_alloc, pass_local_alloc): New.\n+\t* loop-init.c (gate_handle_loop2, rest_of_handle_loop2,\n+\tpass_loop2): New.\n+\t* loop.c (gate_handle_loop_optimize, rest_of_handle_loop_optimize,\n+\tpass_loop_optimize): New.\n+\t* modulo-sched.c (gate_handle_sms, rest_of_handle_sms,\n+\tpass_sms): New.\n+\t* postreload-gcse.c (gate_handle_gcse2, rest_of_handle_gcse2,\n+\tpass_gcse2): New.\n+\t* postreload.c (gate_handle_postreload, rest_of_handle_postreload,\n+\tpass_postreload_cse): New.\n+\t* profile.c (gate_handle_profiling, pass_profiling,\n+\trest_of_handle_branch_prob, pass_branch_prob): New.\n+\t* recog.c (pass pass_split_for_shorten_branches, gate_do_final_split, \n+\tpass_split_before_regstack, gate_handle_split_before_regstack,\n+\tgate_handle_peephole2, rest_of_handle_peephole2, pass_peephole2,\n+\trest_of_handle_split_all_insns, pass_split_all_insns): New.\n+\t* reg-stack.c (gate_handle_stack_regs, rest_of_handle_stack_regs,\n+\tpass_stack_regs): New.\n+\t* regmove.c (gate_handle_regmove, rest_of_handle_regmove, pass_regmove,\n+\tgate_handle_stack_adjustments, rest_of_handle_stack_adjustments,\n+\tpass_stack_adjustments): New.\n+\t* regrename.c (gate_handle_regrename, rest_of_handle_regrename,\n+\tpass_regrename): New.\n+\t* reorg.c (gate_handle_delay_slots, rest_of_handle_delay_slots,\n+\tpass_delay_slots, gate_handle_machine_reorg,\n+\trest_of_handle_machine_reorg, pass_machine_reorg): New.\n+\t* rtl.h (extern void purge_line_number_notes): New.\n+\t* sched-rgn.c (gate_handle_sched, rest_of_handle_sched,\n+\tgate_handle_sched2, rest_of_handle_sched2, pass_sched,\n+\tpass_sched2): New.\n+\t* tracer.c (gate_handle_tracer, rest_of_handle_tracer,\n+\tpass_tracer): New.\n+\t* value-prof.c (gate_handle_value_profile_transformations,\n+\trest_of_handle_value_profile_transformations,\n+\tpass_value_profile_transformations): New.\n+\t* var-tracking.c (gate_handle_var_tracking,\n+\tpass_variable_tracking): New.\n+\t* web.c (gate_handle_web, rest_of_handle_web, pass_web): New.\n+\n+\t* passes.c (open_dump_file, close_dump_file, rest_of_handle_final,\n+\trest_of_handle_delay_slots, rest_of_handle_stack_regs,\n+\trest_of_handle_variable_tracking, rest_of_handle_machine_reorg,\n+\trest_of_handle_old_regalloc, rest_of_handle_regrename,\n+\trest_of_handle_reorder_blocks, rest_of_handle_partition_blocks,\n+\trest_of_handle_sms, rest_of_handle_sched, rest_of_handle_sched2,\n+\trest_of_handle_gcse2, rest_of_handle_regmove,\n+\trest_of_handle_tracer, rest_of_handle_if_conversion,\n+\trest_of_handle_if_after_combine, rest_of_handle_if_after_reload,\n+\trest_of_handle_web, rest_of_handle_branch_prob,\n+\trest_of_handle_value_profile_transformations, rest_of_handle_cfg,\n+\trest_of_handle_jump_bypass, rest_of_handle_combine,\n+\trest_of_handle_life, rest_of_handle_cse, rest_of_handle_cse2,\n+\trest_of_handle_gcse, rest_of_handle_loop_optimize,\n+\trest_of_handle_loop2, rest_of_handle_branch_target_load_optimize,\n+\trest_of_handle_mode_switching, rest_of_handle_jump,\n+\trest_of_handle_eh, rest_of_handle_stack_adjustments,\n+\trest_of_handle_flow2, rest_of_handle_jump2,\n+\trest_of_handle_peephole2, rest_of_handle_postreload,\n+\trest_of_handle_shorten_branches, rest_of_clean_state,\n+\trest_of_compilation): Remove.\n+\n+\t* cgraphunit.c (ipa_passes): Moved from tree-optimize.c.\n+\t* passes.c (dump_flags, in_gimple_form, all_passes,\n+\tall_ipa_passes, all_lowering_passes, register_one_dump_file,\n+\tregister_dump_files, next_pass_1, last_verified, execute_todo,\n+\texecute_one_pass, execute_pass_list, execute_ipa_pass_list): Moved\n+\tfrom tree-optimize.c.\n+\t(init_optimization_passes): Moved from tree-optimize.c,\n+\tadding the RTL optimizations.\n+\t* tree-dump.h (dump_info_p, dump_flag): Moved from tree.h.\n+\t* tree-optimize.c (dump_flags, in_gimple_form, all_passes,\n+\tall_ipa_passes, all_lowering_passes, register_one_dump_file,\n+\tregister_dump_files, next_pass_1, last_verified, execute_todo,\n+\texecute_one_pass, execute_pass_list, execute_ipa_pass_list,\n+\tinit_tree_optimization_passes, ipa_passes): Delete.\n+\t* tree-pass.h (enum tree_dump_index): Moved from tree.h, removing\n+\tthe RTL dumps.\n+\t(TDF_*, get_dump_file_name, dump_enabled_p, dump_initialized_p,\n+\tdump_begin, dump_end, dump_node, dump_switch_p, dump_flag_name): Moved\n+\tfrom tree.h.\n+\t(ipa_passes): Remove.\n+\t(all_passes, all_ipa_passes, all_lowering_passes): Now extern.\n+\t* tree.h (enum tree_dump_index, TDF_*, get_dump_file_name,\n+\tdump_enabled_p, dump_initialized_p, dump_begin, dump_end, dump_node,\n+\tdump_switch_p, dump_flag_name): Moved to tree-pass.h.\n+\t(dump_info_p, dump_flag): Moved to tree-dump.h.\n+\t\n+\t* Makefile.in: Adjust dependencies for tree-pretty-print.c,\n+\tcgraph.c, opts.c.\n+\t* passes.c (finish_optimization_passes): Use dump_begin\n+\tand dump_end, TDI_end.\n+\t(gate_rest_of_compilation): New.\n+\t(pass_rest_of_compilation): Use it.\n+\t(gate_postreload, pass_postreload): New.\n+\t* toplev.c (general_init): Rename init_tree_optimization_passes.\n+\t* toplev.h (init_tree_optimization_passes): Rename to\n+\tinit_optimizations_passes.\n+\t* tree-dump.c (dump_flag): Make static.\n+\t(dump_files): Remove RTL dumps.\n+\t* tree-optimize.c (pass_all_optimizations, pass_early_local_passes,\n+\tpass_cleanup_cfg, pass_free_cfg_annotations,\n+\tpass_cleanup_cfg_post_optimizing, pass_free_datastructures,\n+\tpass_init_datastructures, pass_fixup_cfg): Make non-static.\n+\t* tree-pretty-print.c: Include tree-pass.h.\n+\t* cgraph.c: Include tree-dump.h.\n+\t\n 2005-07-04  Daniel Berlin  <dberlin@dberlin.org>\n \n \t* tree-ssa-structalias.c (get_constraint_exp_from_ssa_var):"}, {"sha": "0d08b792d0ed5639c20e5f9b26de93108274c8ac", "filename": "gcc/Makefile.in", "status": "modified", "additions": 56, "deletions": 45, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -1966,7 +1966,7 @@ tree-nomudflap.o : $(CONFIG_H) $(SYSTEM_H) $(TREE_H) tree-inline.h \\\n    $(GGC_H) gt-tree-mudflap.h tree-pass.h toplev.h\n tree-pretty-print.o : tree-pretty-print.c $(CONFIG_H) $(SYSTEM_H) \\\n    $(TREE_H) $(DIAGNOSTIC_H) real.h $(HASHTAB_H) $(TREE_FLOW_H) \\\n-   $(TM_H) coretypes.h tree-iterator.h tree-chrec.h langhooks.h\n+   $(TM_H) coretypes.h tree-iterator.h tree-chrec.h langhooks.h tree-pass.h\n fold-const.o : fold-const.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(FLAGS_H) real.h toplev.h $(HASHTAB_H) $(EXPR_H) $(RTL_H) \\\n    $(GGC_H) $(TM_P_H) langhooks.h $(MD5_H)\n@@ -1976,7 +1976,7 @@ diagnostic.o : diagnostic.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n opts.o : opts.c opts.h options.h toplev.h $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TREE_H) $(TM_H) langhooks.h $(GGC_H) $(RTL_H) \\\n    output.h $(DIAGNOSTIC_H) $(TM_P_H) $(INSN_ATTR_H) intl.h $(TARGET_H) \\\n-   $(FLAGS_H) $(PARAMS_H)\n+   $(FLAGS_H) $(PARAMS_H) tree-pass.h\n targhooks.o : targhooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TREE_H) \\\n    $(EXPR_H) $(TM_H) $(RTL_H) $(TM_P_H) function.h output.h toplev.h \\\n    $(MACHMODE_H) $(TARGET_DEF_H) $(TARGET_H) $(GGC_H) gt-targhooks.h\n@@ -2002,7 +2002,7 @@ passes.o : passes.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(PARAMS_H) $(TM_P_H) reload.h dwarf2asm.h $(TARGET_H) \\\n    langhooks.h insn-flags.h $(CFGLAYOUT_H) real.h $(CFGLOOP_H) \\\n    hosthooks.h $(CGRAPH_H) $(COVERAGE_H) tree-pass.h $(TREE_DUMP_H) \\\n-   $(GGC_H) $(INTEGRATE_H) $(CPPLIB_H) opts.h\n+   $(GGC_H) $(INTEGRATE_H) $(CPPLIB_H) opts.h tree-flow.h tree-inline.h\n \n main.o : main.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) toplev.h\n \n@@ -2032,7 +2032,8 @@ function.o : function.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(CFGLAYOUT_H) $(TREE_GIMPLE_H) $(FLAGS_H) function.h $(EXPR_H) \\\n    $(OPTABS_H) libfuncs.h $(REGS_H) hard-reg-set.h insn-config.h $(RECOG_H) \\\n    output.h toplev.h except.h $(HASHTAB_H) $(GGC_H) $(TM_P_H) langhooks.h \\\n-   gt-function.h $(TARGET_H) $(BASIC_BLOCK_H) $(INTEGRATE_H) $(PREDICT_H)\n+   gt-function.h $(TARGET_H) $(BASIC_BLOCK_H) $(INTEGRATE_H) $(PREDICT_H) \\\n+   tree-pass.h\n stmt.o : stmt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(FLAGS_H) function.h insn-config.h hard-reg-set.h $(EXPR_H) \\\n    libfuncs.h except.h $(RECOG_H) toplev.h output.h $(GGC_H) $(TM_P_H) \\\n@@ -2043,7 +2044,7 @@ except.o : except.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    langhooks.h insn-config.h hard-reg-set.h $(BASIC_BLOCK_H) output.h \\\n    dwarf2asm.h dwarf2out.h toplev.h $(HASHTAB_H) intl.h $(GGC_H) \\\n    gt-except.h $(CGRAPH_H) $(INTEGRATE_H) $(DIAGNOSTIC_H) dwarf2.h \\\n-   $(TARGET_H) $(TM_P_H)\n+   $(TARGET_H) $(TM_P_H) tree-pass.h timevar.h\n expr.o : expr.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(FLAGS_H) function.h $(REGS_H) $(EXPR_H) $(OPTABS_H) \\\n    libfuncs.h $(INSN_ATTR_H) insn-config.h $(RECOG_H) output.h \\\n@@ -2100,16 +2101,17 @@ xcoffout.o : xcoffout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n emit-rtl.o : emit-rtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(FLAGS_H) function.h $(REGS_H) insn-config.h $(RECOG_H) real.h \\\n    $(GGC_H) $(EXPR_H) hard-reg-set.h bitmap.h toplev.h $(BASIC_BLOCK_H) \\\n-   $(HASHTAB_H) $(TM_P_H) debug.h langhooks.h gt-emit-rtl.h\n+   $(HASHTAB_H) $(TM_P_H) debug.h langhooks.h tree-pass.h gt-emit-rtl.h\n real.o : real.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    toplev.h $(TM_P_H) real.h\n integrate.o : integrate.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(TREE_H) $(FLAGS_H) debug.h $(INTEGRATE_H) insn-config.h \\\n    $(EXPR_H) real.h $(REGS_H) intl.h function.h output.h $(RECOG_H) \\\n    except.h toplev.h $(PARAMS_H) $(TM_P_H) $(TARGET_H) langhooks.h \\\n-   gt-integrate.h $(GGC_H)\n+   gt-integrate.h $(GGC_H) tree-pass.h\n jump.o : jump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(FLAGS_H) \\\n-   hard-reg-set.h $(REGS_H) insn-config.h $(RECOG_H) $(EXPR_H) real.h except.h function.h \\\n+   hard-reg-set.h $(REGS_H) insn-config.h $(RECOG_H) $(EXPR_H) real.h except.h \\\n+   function.h tree-pass.h \\\n    toplev.h $(INSN_ATTR_H) $(TM_P_H) reload.h $(PREDICT_H) $(TIMEVAR_H) \\\n    $(DIAGNOSTIC_H)\n \n@@ -2120,7 +2122,7 @@ simplify-rtx.o : simplify-rtx.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n cgraph.o : cgraph.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    langhooks.h toplev.h $(FLAGS_H) $(GGC_H) $(TARGET_H) $(CGRAPH_H) \\\n    gt-cgraph.h output.h intl.h $(BASIC_BLOCK_H) debug.h $(HASHTAB_H) \\\n-   tree-inline.h $(VARRAY_H)\n+   tree-inline.h $(VARRAY_H) tree-dump.h\n cgraphunit.o : cgraphunit.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) langhooks.h tree-inline.h toplev.h $(FLAGS_H) $(GGC_H) \\\n    $(TARGET_H) $(CGRAPH_H) intl.h pointer-set.h function.h $(TREE_GIMPLE_H) \\\n@@ -2142,24 +2144,25 @@ cselib.o : cselib.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n cse.o : cse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \\\n    hard-reg-set.h $(FLAGS_H) real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h \\\n    output.h function.h $(BASIC_BLOCK_H) $(GGC_H) $(TM_P_H) $(TIMEVAR_H) \\\n-   except.h $(TARGET_H) $(PARAMS_H) rtlhooks-def.h\n+   except.h $(TARGET_H) $(PARAMS_H) rtlhooks-def.h tree-pass.h\n web.o : web.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    hard-reg-set.h $(FLAGS_H) $(BASIC_BLOCK_H) function.h output.h toplev.h \\\n-   $(DF_H) $(OBSTACK_H)\n+   $(DF_H) $(OBSTACK_H) timevar.h tree-pass.h\n gcse.o : gcse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(REGS_H) hard-reg-set.h $(FLAGS_H) real.h insn-config.h $(GGC_H) \\\n    $(RECOG_H) $(EXPR_H) $(BASIC_BLOCK_H) function.h output.h toplev.h \\\n    $(TM_P_H) $(PARAMS_H) except.h gt-gcse.h $(TREE_H) cselib.h $(TIMEVAR_H) \\\n-   intl.h $(OBSTACK_H)\n+   intl.h $(OBSTACK_H) tree-pass.h\n resource.o : resource.c $(CONFIG_H) $(RTL_H) hard-reg-set.h $(SYSTEM_H) \\\n    coretypes.h $(TM_H) $(REGS_H) $(FLAGS_H) output.h $(RESOURCE_H) \\\n    function.h toplev.h $(INSN_ATTR_H) except.h $(PARAMS_H) $(TM_P_H)\n lcm.o : lcm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \\\n    hard-reg-set.h $(FLAGS_H) real.h insn-config.h $(INSN_ATTR_H) $(RECOG_H) \\\n    $(BASIC_BLOCK_H) $(TM_P_H) function.h output.h\n-mode-switching.o : mode-switching.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n-   $(RTL_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) real.h insn-config.h \\\n-   $(INSN_ATTR_H) $(RECOG_H) $(BASIC_BLOCK_H) $(TM_P_H) function.h output.h\n+mode-switching.o : mode-switching.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+   $(TM_H) $(RTL_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) real.h insn-config.h \\\n+   $(INSN_ATTR_H) $(RECOG_H) $(BASIC_BLOCK_H) $(TM_P_H) function.h output.h \\\n+   tree-pass.h timevar.h\n tree-ssa-dce.o : tree-ssa-dce.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \\\n     $(RTL_H) $(TM_P_H) $(TREE_FLOW_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) \\\n     coretypes.h $(TREE_DUMP_H) tree-pass.h $(FLAGS_H) $(BASIC_BLOCK_H) \\\n@@ -2190,12 +2193,13 @@ df.o : df.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n var-tracking.o : var-tracking.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(TREE_H) hard-reg-set.h insn-config.h reload.h $(FLAGS_H) \\\n    $(BASIC_BLOCK_H) output.h sbitmap.h alloc-pool.h $(FIBHEAP_H) $(HASHTAB_H) \\\n-   $(REGS_H) $(EXPR_H)\n+   $(REGS_H) $(EXPR_H) timevar.h tree-pass.h\n conflict.o : conflict.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(OBSTACK_H) \\\n    $(HASHTAB_H) $(RTL_H) hard-reg-set.h $(BASIC_BLOCK_H)\n profile.o : profile.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(FLAGS_H) output.h $(REGS_H) $(EXPR_H) function.h \\\n-   toplev.h $(COVERAGE_H) $(TREE_FLOW_H) value-prof.h cfghooks.h\n+   toplev.h $(COVERAGE_H) $(TREE_FLOW_H) value-prof.h cfghooks.h \\\n+   cfgloop.h timevar.h tree-pass.h\n tree-profile.o : tree-profile.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(RTL_H) $(TREE_H) $(FLAGS_H) output.h $(REGS_H) $(EXPR_H) \\\n    function.h toplev.h $(COVERAGE_H) $(TREE_H) value-prof.h $(TREE_DUMP_H) \\\n@@ -2207,19 +2211,20 @@ value-prof.o : value-prof.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h value-prof.h $(EXPR_H) output.h $(FLAGS_H) \\\n    $(RECOG_H) insn-config.h $(OPTABS_H) $(REGS_H) $(GGC_H) $(DIAGNOSTIC_H) \\\n    $(TREE_H) $(COVERAGE_H) $(RTL_H) $(GCOV_IO_H) $(TREE_FLOW_H) \\\n-   tree-flow-inline.h\n+   tree-flow-inline.h timevar.h tree-pass.h\n loop.o : loop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(FLAGS_H) insn-config.h $(REGS_H) hard-reg-set.h $(RECOG_H) $(EXPR_H) \\\n    real.h $(PREDICT_H) $(BASIC_BLOCK_H) function.h $(CFGLOOP_H) \\\n-   toplev.h except.h cselib.h $(OPTABS_H) $(TM_P_H) $(GGC_H) insn-flags.h\n+   toplev.h except.h cselib.h $(OPTABS_H) $(TM_P_H) $(GGC_H) insn-flags.h \\\n+   timevar.h tree-pass.h\n loop-doloop.o : loop-doloop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(FLAGS_H) $(EXPR_H) hard-reg-set.h $(BASIC_BLOCK_H) $(TM_P_H) \\\n    toplev.h $(CFGLOOP_H) output.h $(PARAMS_H)\n alloc-pool.o : alloc-pool.c $(CONFIG_H) $(SYSTEM_H) alloc-pool.h $(HASHTAB_H)\n flow.o : flow.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(FLAGS_H) insn-config.h $(BASIC_BLOCK_H) $(REGS_H) \\\n    hard-reg-set.h output.h toplev.h $(RECOG_H) function.h except.h \\\n-   $(EXPR_H) $(TM_P_H) $(OBSTACK_H) $(SPLAY_TREE_H) $(TIMEVAR_H)\n+   $(EXPR_H) $(TM_P_H) $(OBSTACK_H) $(SPLAY_TREE_H) $(TIMEVAR_H) tree-pass.h\n cfg.o : cfg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(FLAGS_H) \\\n    $(REGS_H) hard-reg-set.h output.h toplev.h function.h except.h $(GGC_H) \\\n    $(TM_P_H) $(TIMEVAR_H) $(OBSTACK_H) $(TREE_H) alloc-pool.h $(HASHTAB_H)\n@@ -2228,11 +2233,12 @@ cfghooks.o: cfghooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n cfgexpand.o : cfgexpand.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) function.h $(TIMEVAR_H) $(TM_H) \\\n    coretypes.h $(TREE_DUMP_H) except.h langhooks.h tree-pass.h $(RTL_H) \\\n-   $(DIAGNOSTIC_H) toplev.h $(BASIC_BLOCK_H) $(FLAGS_H) $(PARAMS_H)\n+   $(DIAGNOSTIC_H) toplev.h $(BASIC_BLOCK_H) $(FLAGS_H) debug.h $(PARAMS_H)\n cfgrtl.o : cfgrtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(FLAGS_H) insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h \\\n    output.h toplev.h function.h except.h $(TM_P_H) insn-config.h $(EXPR_H) \\\n-   $(CFGLAYOUT_H) $(CFGLOOP_H) $(OBSTACK_H) $(TARGET_H) $(TREE_H)\n+   $(CFGLAYOUT_H) $(CFGLOOP_H) $(OBSTACK_H) $(TARGET_H) $(TREE_H) \\\n+   tree-pass.h\n cfganal.o : cfganal.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h insn-config.h $(RECOG_H) $(TM_P_H) \\\n    $(TIMEVAR_H) $(OBSTACK_H) toplev.h\n@@ -2242,7 +2248,7 @@ cfgbuild.o : cfgbuild.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n cfgcleanup.o : cfgcleanup.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(TIMEVAR_H) hard-reg-set.h output.h $(FLAGS_H) $(RECOG_H) \\\n    toplev.h insn-config.h cselib.h $(TARGET_H) $(TM_P_H) $(PARAMS_H) \\\n-   $(REGS_H) $(EMIT_RTL_H) $(CFGLAYOUT_H)\n+   $(REGS_H) $(EMIT_RTL_H) $(CFGLAYOUT_H) tree-pass.h cfgloop.h expr.h\n cfgloop.o : cfgloop.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) coretypes.h $(TM_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(FLAGS_H) function.h \\\n    $(OBSTACK_H) toplev.h $(TREE_FLOW_H) $(TREE_H)\n@@ -2260,7 +2266,7 @@ cfgloopmanip.o : cfgloopmanip.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n    coretypes.h $(TM_H) cfghooks.h $(OBSTACK_H)\n loop-init.o : loop-init.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(CFGLAYOUT_H) \\\n-   coretypes.h $(TM_H) $(OBSTACK_H)\n+   coretypes.h $(TM_H) $(OBSTACK_H) tree-pass.h timevar.h $(FLAGS_H)\n loop-unswitch.o : loop-unswitch.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TM_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(CFGLAYOUT_H) $(PARAMS_H) \\\n    output.h $(EXPR_H) coretypes.h $(TM_H) $(OBSTACK_H)\n@@ -2276,20 +2282,21 @@ combine.o : combine.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(FLAGS_H) function.h insn-config.h $(INSN_ATTR_H) $(REGS_H) $(EXPR_H) \\\n    rtlhooks-def.h $(BASIC_BLOCK_H) $(RECOG_H) real.h hard-reg-set.h \\\n    toplev.h $(TM_P_H) $(TREE_H) $(TARGET_H) output.h $(PARAMS_H) $(OPTABS_H) \\\n-   insn-codes.h\n+   insn-codes.h timevar.h tree-pass.h\n regclass.o : regclass.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    hard-reg-set.h $(FLAGS_H) $(BASIC_BLOCK_H) $(REGS_H) insn-config.h \\\n    $(RECOG_H) reload.h real.h toplev.h function.h output.h $(GGC_H) \\\n    $(TM_P_H) $(EXPR_H) $(TIMEVAR_H) gt-regclass.h $(HASHTAB_H)\n local-alloc.o : local-alloc.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(FLAGS_H) $(REGS_H) hard-reg-set.h insn-config.h $(RECOG_H) \\\n    output.h function.h $(INSN_ATTR_H) toplev.h  except.h reload.h $(TM_P_H) \\\n-   $(GGC_H) $(INTEGRATE_H)\n+   $(GGC_H) $(INTEGRATE_H) timevar.h tree-pass.h\n bitmap.o : bitmap.c $(CONFIG_H) $(SYSTEM_H)  coretypes.h $(TM_H) $(RTL_H) \\\n    $(FLAGS_H) $(GGC_H) gt-bitmap.h bitmap.h $(OBSTACK_H)\n global.o : global.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(FLAGS_H) reload.h function.h $(RECOG_H) $(REGS_H) hard-reg-set.h \\\n-   insn-config.h output.h toplev.h $(TM_P_H) $(MACHMODE_H)\n+   insn-config.h output.h toplev.h $(TM_P_H) $(MACHMODE_H) tree-pass.h \\\n+   timevar.h\n varray.o : varray.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(GGC_H) \\\n    $(HASHTAB_H) $(BCONFIG_H) $(VARRAY_H) toplev.h\n vec.o : vec.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) coretypes.h vec.h $(GGC_H) \\\n@@ -2308,28 +2315,30 @@ postreload.o : postreload.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) real.h $(FLAGS_H) $(EXPR_H) $(OPTABS_H) reload.h $(REGS_H) \\\n    hard-reg-set.h insn-config.h $(BASIC_BLOCK_H) $(RECOG_H) output.h \\\n    function.h toplev.h cselib.h $(TM_P_H) except.h $(TREE_H) $(MACHMODE_H) \\\n-   $(OBSTACK_H)\n+   $(OBSTACK_H) timevar.h tree-pass.h\n postreload-gcse.o : postreload-gcse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(RTL_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) real.h insn-config.h \\\n    $(RECOG_H) $(EXPR_H) $(BASIC_BLOCK_H) function.h output.h toplev.h \\\n    $(TM_P_H) except.h $(TREE_H) $(TARGET_H) $(HASHTAB_H) intl.h $(OBSTACK_H) \\\n-   $(PARAMS_H)\n+   $(PARAMS_H) timevar.h tree-pass.h\n caller-save.o : caller-save.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(FLAGS_H) $(REGS_H) hard-reg-set.h insn-config.h $(BASIC_BLOCK_H) function.h \\\n    $(RECOG_H) reload.h $(EXPR_H) toplev.h $(TM_P_H)\n bt-load.o : bt-load.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) except.h \\\n-   $(RTL_H) hard-reg-set.h $(REGS_H) $(TM_P_H) $(FIBHEAP_H) output.h \\\n-   $(TARGET_H) $(EXPR_H) $(FLAGS_H) $(INSN_ATTR_H) function.h\n+   $(RTL_H) hard-reg-set.h $(REGS_H) $(TM_P_H) $(FIBHEAP_H) output.h $(EXPR_H) \\\n+   $(TARGET_H) $(FLAGS_H) $(INSN_ATTR_H) function.h tree-pass.h toplev.h\n reorg.o : reorg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    conditions.h hard-reg-set.h $(BASIC_BLOCK_H) $(REGS_H) insn-config.h \\\n    $(INSN_ATTR_H) except.h $(RECOG_H) function.h $(FLAGS_H) output.h \\\n-   $(EXPR_H) toplev.h $(PARAMS_H) $(TM_P_H) $(OBSTACK_H) $(RESOURCE_H)\n+   $(EXPR_H) toplev.h $(PARAMS_H) $(TM_P_H) $(OBSTACK_H) $(RESOURCE_H) \\\n+   timevar.h target.h tree-pass.h\n alias.o : alias.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(FLAGS_H) hard-reg-set.h $(BASIC_BLOCK_H) $(REGS_H) toplev.h output.h \\\n    $(ALIAS_H) $(EMIT_RTL_H) $(GGC_H) function.h cselib.h $(TREE_H) $(TM_P_H) \\\n    langhooks.h $(TARGET_H) gt-alias.h $(TIMEVAR_H) $(CGRAPH_H) \\\n-   $(SPLAY_TREE_H) $(VARRAY_H)\n-regmove.o : regmove.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) insn-config.h \\\n+   $(SPLAY_TREE_H) $(VARRAY_H) tree-pass.h\n+regmove.o : regmove.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n+   insn-config.h timevar.h tree-pass.h \\\n    $(RECOG_H) output.h $(REGS_H) hard-reg-set.h $(FLAGS_H) function.h \\\n    $(EXPR_H) $(BASIC_BLOCK_H) toplev.h $(TM_P_H) except.h reload.h\n ddg.o : ddg.c $(DDG_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TARGET_H) \\\n@@ -2341,7 +2350,7 @@ modulo-sched.o : modulo-sched.c $(DDG_H) $(CONFIG_H) $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TARGET_H) toplev.h $(RTL_H) $(TM_P_H) $(REGS_H) function.h \\\n    $(FLAGS_H) insn-config.h $(INSN_ATTR_H) except.h $(RECOG_H) \\\n    $(SCHED_INT_H) $(CFGLAYOUT_H) $(CFGLOOP_H) $(EXPR_H) $(PARAMS_H) \\\n-   cfghooks.h $(DF_H) $(GCOV_IO_H) hard-reg-set.h $(TM_H)\n+   cfghooks.h $(DF_H) $(GCOV_IO_H) hard-reg-set.h $(TM_H) timevar.h tree-pass.h\n haifa-sched.o : haifa-sched.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(SCHED_INT_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h function.h \\\n    $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h $(TM_P_H) $(TARGET_H)\n@@ -2352,7 +2361,7 @@ sched-deps.o : sched-deps.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n sched-rgn.o : sched-rgn.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(SCHED_INT_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \\\n    function.h $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h $(PARAMS_H) \\\n-   $(TM_P_H) $(TARGET_H) $(CFGLAYOUT_H)\n+   $(TM_P_H) $(TARGET_H) $(CFGLAYOUT_H) timevar.h tree-pass.h\n sched-ebb.o : sched-ebb.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(SCHED_INT_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \\\n    function.h $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h $(TM_P_H) \\\n@@ -2363,16 +2372,17 @@ sched-vis.o : sched-vis.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n final.o : final.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(FLAGS_H) intl.h $(REGS_H) $(RECOG_H) conditions.h \\\n    insn-config.h $(INSN_ATTR_H) function.h real.h output.h hard-reg-set.h \\\n-   except.h debug.h xcoffout.h toplev.h reload.h dwarf2out.h \\\n-   $(BASIC_BLOCK_H) $(TM_P_H) $(TARGET_H) $(EXPR_H) $(CFGLAYOUT_H) dbxout.h\n+   except.h debug.h xcoffout.h toplev.h reload.h dwarf2out.h tree-pass.h \\\n+   $(BASIC_BLOCK_H) $(TM_P_H) $(TARGET_H) $(EXPR_H) $(CFGLAYOUT_H) dbxout.h \\\n+   timevar.h cgraph.h coverage.h\n recog.o : recog.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    function.h $(BASIC_BLOCK_H) $(REGS_H) $(RECOG_H) $(EXPR_H) hard-reg-set.h \\\n    $(FLAGS_H) insn-config.h $(INSN_ATTR_H) real.h toplev.h output.h reload.h \\\n-   $(TM_P_H)\n+   $(TM_P_H) timevar.h tree-pass.h\n reg-stack.o : reg-stack.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(TREE_H) $(RECOG_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) \\\n    insn-config.h toplev.h reload.h function.h $(TM_P_H) $(GGC_H) \\\n-   gt-reg-stack.h $(BASIC_BLOCK_H) output.h $(VARRAY_H)\n+   gt-reg-stack.h $(BASIC_BLOCK_H) output.h $(VARRAY_H) timevar.h tree-pass.h\n sreal.o: sreal.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) sreal.h\n predict.o: predict.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(FLAGS_H) insn-config.h $(BASIC_BLOCK_H) $(REGS_H) \\\n@@ -2385,24 +2395,25 @@ lists.o: lists.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) toplev.h \\\n bb-reorder.o : bb-reorder.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(FLAGS_H) $(TIMEVAR_H) output.h $(CFGLAYOUT_H) $(FIBHEAP_H) \\\n    $(TARGET_H) function.h $(TM_P_H) $(OBSTACK_H) $(EXPR_H) $(REGS_H) \\\n-   $(PARAMS_H) toplev.h\n+   $(PARAMS_H) toplev.h tree-pass.h\n tracer.o : tracer.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(BASIC_BLOCK_H) hard-reg-set.h output.h $(CFGLAYOUT_H) \\\n-   $(FLAGS_H) $(TIMEVAR_H) $(PARAMS_H) $(COVERAGE_H) $(FIBHEAP_H)\n+   $(FLAGS_H) $(TIMEVAR_H) $(PARAMS_H) $(COVERAGE_H) $(FIBHEAP_H) \\\n+   tree-pass.h\n cfglayout.o : cfglayout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(TREE_H) insn-config.h $(BASIC_BLOCK_H) hard-reg-set.h output.h \\\n    function.h $(CFGLAYOUT_H) $(CFGLOOP_H) $(TARGET_H) gt-cfglayout.h \\\n-   $(GGC_H) alloc-pool.h $(FLAGS_H) $(OBSTACK_H)\n+   $(GGC_H) alloc-pool.h $(FLAGS_H) $(OBSTACK_H) tree-pass.h\n timevar.o : timevar.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TIMEVAR_H) $(FLAGS_H) intl.h toplev.h $(RTL_H) timevar.def\n regrename.o : regrename.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h \\\n    output.h $(RECOG_H) function.h $(OBSTACK_H) $(FLAGS_H) $(TM_P_H) \\\n-   reload.h toplev.h\n+   reload.h toplev.h timevar.h tree-pass.h\n ifcvt.o : ifcvt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(REGS_H) toplev.h $(FLAGS_H) insn-config.h function.h $(RECOG_H) \\\n    $(TARGET_H) $(BASIC_BLOCK_H) $(EXPR_H) output.h except.h $(TM_P_H) \\\n-   real.h $(OPTABS_H) $(CFGLOOP_H) hard-reg-set.h\n+   real.h $(OPTABS_H) $(CFGLOOP_H) hard-reg-set.h timevar.h tree-pass.h\n lambda-mat.o : lambda-mat.c $(LAMBDA_H) $(GGC_H) $(SYSTEM_H) $(CONFIG_H) \\\n    $(TM_H) coretypes.h $(TREE_H) $(VARRAY_H)\n lambda-trans.o: lambda-trans.c $(LAMBDA_H) $(GGC_H) $(SYSTEM_H) $(CONFIG_H) \\"}, {"sha": "9bc11d72049343d8d1b47f1a54bbe0559c8d48dc", "filename": "gcc/alias.c", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -44,6 +44,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"target.h\"\n #include \"cgraph.h\"\n #include \"varray.h\"\n+#include \"tree-pass.h\"\n \n /* The alias sets assigned to MEMs assist the back-end in determining\n    which MEMs can alias which other MEMs.  In general, two MEMs in\n@@ -2967,5 +2968,57 @@ end_alias_analysis (void)\n       alias_invariant_size = 0;\n     }\n }\n+\f\n+/* Do control and data flow analysis; write some of the results to the\n+   dump file.  */\n+static void\n+rest_of_handle_cfg (void)\n+{\n+  if (dump_file)\n+    dump_flow_info (dump_file);\n+  if (optimize)\n+    cleanup_cfg (CLEANUP_EXPENSIVE\n+                 | (flag_thread_jumps ? CLEANUP_THREADING : 0));\n+\n+  /* It may make more sense to mark constant functions after dead code is\n+     eliminated by life_analysis, but we need to do it early, as -fprofile-arcs\n+     may insert code making function non-constant, but we still must consider\n+     it as constant, otherwise -fbranch-probabilities will not read data back.\n+\n+     life_analysis rarely eliminates modification of external memory.\n+\n+     FIXME: now with tree based profiling we are in the trap described above\n+     again.  It seems to be easiest to disable the optimization for time\n+     being before the problem is either solved by moving the transformation\n+     to the IPA level (we need the CFG for this) or the very early optimization\n+     passes are made to ignore the const/pure flags so code does not change.  */\n+  if (optimize\n+      && (!flag_tree_based_profiling\n+          || (!profile_arc_flag && !flag_branch_probabilities)))\n+    {\n+      /* Alias analysis depends on this information and mark_constant_function\n+       depends on alias analysis.  */\n+      reg_scan (get_insns (), max_reg_num ());\n+      mark_constant_function ();\n+    }\n+}\n+\n+struct tree_opt_pass pass_cfg =\n+{\n+  \"cfg\",                                /* name */\n+  NULL,\t\t\t\t\t/* gate */   \n+  rest_of_handle_cfg,                   /* execute */       \n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_FLOW,                              /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func,                       /* todo_flags_finish */\n+  'f'                                   /* letter */\n+};\n+\n \n #include \"gt-alias.h\""}, {"sha": "267b02da3b89c2980f1aef8a881b223b238db68e", "filename": "gcc/basic-block.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -926,7 +926,6 @@ extern bool control_flow_insn_p (rtx);\n \n /* In bb-reorder.c */\n extern void reorder_basic_blocks (unsigned int);\n-extern void duplicate_computed_gotos (void);\n extern void partition_hot_cold_basic_blocks (void);\n \n /* In dominance.c */"}, {"sha": "76faedaaee31a3fc4b2553181876b2b53e192be7", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 132, "deletions": 9, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -83,6 +83,11 @@\n #include \"expr.h\"\n #include \"params.h\"\n #include \"toplev.h\"\n+#include \"tree-pass.h\"\n+\n+#ifndef HAVE_conditional_execution\n+#define HAVE_conditional_execution 0\n+#endif\n \n /* The number of rounds.  In most cases there will only be 4 rounds, but\n    when partitioning hot and cold basic blocks into separate sections of\n@@ -1894,8 +1899,6 @@ reorder_basic_blocks (unsigned int flags)\n   if (targetm.cannot_modify_jumps_p ())\n     return;\n \n-  timevar_push (TV_REORDER_BLOCKS);\n-\n   cfg_layout_initialize (flags);\n \n   set_edge_can_fallthru_flag ();\n@@ -1931,8 +1934,6 @@ reorder_basic_blocks (unsigned int flags)\n   cfg_layout_finalize ();\n   if (flag_reorder_blocks_and_partition)\n     verify_hot_cold_block_grouping ();\n-\n-  timevar_pop (TV_REORDER_BLOCKS);\n }\n \n /* Determine which partition the first basic block in the function\n@@ -1970,7 +1971,14 @@ insert_section_boundary_note (void)\n    which can seriously pessimize code with many computed jumps in the source\n    code, such as interpreters.  See e.g. PR15242.  */\n \n-void\n+static bool\n+gate_duplicate_computed_gotos (void)\n+{\n+  return (optimize > 0 && flag_expensive_optimizations && !optimize_size);\n+}\n+\n+\n+static void\n duplicate_computed_gotos (void)\n {\n   basic_block bb, new_bb;\n@@ -1983,8 +1991,6 @@ duplicate_computed_gotos (void)\n   if (targetm.cannot_modify_jumps_p ())\n     return;\n \n-  timevar_push (TV_REORDER_BLOCKS);\n-\n   cfg_layout_initialize (0);\n \n   /* We are estimating the length of uncond jump insn only once\n@@ -2076,10 +2082,26 @@ duplicate_computed_gotos (void)\n   cfg_layout_finalize ();\n \n   BITMAP_FREE (candidates);\n-\n-  timevar_pop (TV_REORDER_BLOCKS);\n }\n \n+struct tree_opt_pass pass_duplicate_computed_gotos =\n+{\n+  NULL,                                 /* name */\n+  gate_duplicate_computed_gotos,        /* gate */\n+  duplicate_computed_gotos,             /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_REORDER_BLOCKS,                    /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  0,                                    /* todo_flags_finish */\n+  0                                     /* letter */\n+};\n+\n+\n /* This function is the main 'entrance' for the optimization that\n    partitions hot and cold basic blocks into separate sections of the\n    .o file (to improve performance and cache locality).  Ideally it\n@@ -2169,3 +2191,104 @@ partition_hot_cold_basic_blocks (void)\n \n   cfg_layout_finalize();\n }\n+\f\n+static bool\n+gate_handle_reorder_blocks (void)\n+{\n+  return (optimize > 0);\n+}\n+\n+\n+/* Reorder basic blocks.  */\n+static void\n+rest_of_handle_reorder_blocks (void)\n+{\n+  bool changed;\n+  unsigned int liveness_flags;\n+\n+  /* Last attempt to optimize CFG, as scheduling, peepholing and insn\n+     splitting possibly introduced more crossjumping opportunities.  */\n+  liveness_flags = (!HAVE_conditional_execution ? CLEANUP_UPDATE_LIFE : 0);\n+  changed = cleanup_cfg (CLEANUP_EXPENSIVE | liveness_flags);\n+\n+  if (flag_sched2_use_traces && flag_schedule_insns_after_reload)\n+    {\n+      timevar_push (TV_TRACER);\n+      tracer (liveness_flags);\n+      timevar_pop (TV_TRACER);\n+    }\n+\n+  if (flag_reorder_blocks || flag_reorder_blocks_and_partition)\n+    reorder_basic_blocks (liveness_flags);\n+  if (flag_reorder_blocks || flag_reorder_blocks_and_partition\n+      || (flag_sched2_use_traces && flag_schedule_insns_after_reload))\n+    changed |= cleanup_cfg (CLEANUP_EXPENSIVE | liveness_flags);\n+\n+  /* On conditional execution targets we can not update the life cheaply, so\n+     we deffer the updating to after both cleanups.  This may lose some cases\n+     but should not be terribly bad.  */\n+  if (changed && HAVE_conditional_execution)\n+    update_life_info (NULL, UPDATE_LIFE_GLOBAL_RM_NOTES,\n+                      PROP_DEATH_NOTES);\n+}\n+\n+struct tree_opt_pass pass_reorder_blocks =\n+{\n+  \"bbro\",                               /* name */\n+  gate_handle_reorder_blocks,           /* gate */\n+  rest_of_handle_reorder_blocks,        /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_REORDER_BLOCKS,                    /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func,                       /* todo_flags_finish */\n+  'B'                                   /* letter */\n+};\n+\n+static bool\n+gate_handle_partition_blocks (void)\n+{\n+  /* The optimization to partition hot/cold basic blocks into separate\n+     sections of the .o file does not work well with linkonce or with\n+     user defined section attributes.  Don't call it if either case\n+     arises.  */\n+\n+  return (flag_reorder_blocks_and_partition\n+          && !DECL_ONE_ONLY (current_function_decl)\n+          && !user_defined_section_attribute);\n+}\n+\n+/* Partition hot and cold basic blocks.  */\n+static void\n+rest_of_handle_partition_blocks (void)\n+{\n+  no_new_pseudos = 0;\n+  partition_hot_cold_basic_blocks ();\n+  allocate_reg_life_data ();\n+  update_life_info (NULL, UPDATE_LIFE_GLOBAL_RM_NOTES,\n+                    PROP_LOG_LINKS | PROP_REG_INFO | PROP_DEATH_NOTES);\n+  no_new_pseudos = 1;\n+}\n+\n+struct tree_opt_pass pass_partition_blocks =\n+{\n+  NULL,                                 /* name */\n+  gate_handle_partition_blocks,         /* gate */\n+  rest_of_handle_partition_blocks,      /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_REORDER_BLOCKS,                    /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  0,\t\t                        /* todo_flags_finish */\n+  0                                     /* letter */\n+};\n+\n+"}, {"sha": "e8b02256915a29727fdf2bc76b63217a5c53d1e0", "filename": "gcc/bt-load.c", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -34,6 +34,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"function.h\"\n #include \"except.h\"\n #include \"tm_p.h\"\n+#include \"toplev.h\"\n+#include \"tree-pass.h\"\n \n /* Target register optimizations - these are performed after reload.  */\n \n@@ -1479,3 +1481,50 @@ branch_target_load_optimize (bool after_prologue_epilogue_gen)\n \t\t\tPROP_DEATH_NOTES | PROP_REG_INFO);\n     }\n }\n+\f\n+static bool\n+gate_handle_branch_target_load_optimize (void)\n+{\n+  return (optimize > 0 && flag_branch_target_load_optimize2);\n+}\n+\n+\n+static void\n+rest_of_handle_branch_target_load_optimize (void)\n+{\n+  static int warned = 0;\n+\n+  /* Leave this a warning for now so that it is possible to experiment\n+     with running this pass twice.  In 3.6, we should either make this\n+     an error, or use separate dump files.  */\n+  if (flag_branch_target_load_optimize\n+      && flag_branch_target_load_optimize2\n+      && !warned)\n+    {\n+      warning (0, \"branch target register load optimization is not intended \"\n+                  \"to be run twice\");\n+\n+      warned = 1;\n+    }\n+\n+  branch_target_load_optimize (epilogue_completed);\n+}\n+\n+struct tree_opt_pass pass_branch_target_load_optimize =\n+{\n+  \"btl\",                               /* name */\n+  gate_handle_branch_target_load_optimize,      /* gate */\n+  rest_of_handle_branch_target_load_optimize,   /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  0,\t\t                        /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func |\n+  TODO_ggc_collect,                     /* todo_flags_finish */\n+  'd'                                   /* letter */\n+};\n+"}, {"sha": "a5a5d0730428e469f29874698f8914a262f648be", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -50,6 +50,9 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"target.h\"\n #include \"cfglayout.h\"\n #include \"emit-rtl.h\"\n+#include \"tree-pass.h\"\n+#include \"cfgloop.h\"\n+#include \"expr.h\"\n \n /* cleanup_cfg maintains following flags for each basic block.  */\n \n@@ -2136,3 +2139,81 @@ cleanup_cfg (int mode)\n \n   return changed;\n }\n+\f\n+static void\n+rest_of_handle_jump (void)\n+{\n+  delete_unreachable_blocks ();\n+\n+  if (cfun->tail_call_emit)\n+    fixup_tail_calls ();\n+}\n+\n+struct tree_opt_pass pass_jump =\n+{\n+  \"sibling\",                            /* name */\n+  NULL,                                 /* gate */   \n+  rest_of_handle_jump,\t\t\t/* execute */       \n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_JUMP,                              /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  TODO_ggc_collect,                     /* todo_flags_start */\n+  TODO_dump_func |\n+  TODO_verify_flow,                     /* todo_flags_finish */\n+  'i'                                   /* letter */\n+};\n+\n+\n+static void\n+rest_of_handle_jump2 (void)\n+{\n+  /* Turn NOTE_INSN_EXPECTED_VALUE into REG_BR_PROB.  Do this\n+     before jump optimization switches branch directions.  */\n+  if (flag_guess_branch_prob)\n+    expected_value_to_br_prob ();\n+\n+  delete_trivially_dead_insns (get_insns (), max_reg_num ());\n+  reg_scan (get_insns (), max_reg_num ());\n+  if (dump_file)\n+    dump_flow_info (dump_file);\n+  cleanup_cfg ((optimize ? CLEANUP_EXPENSIVE : 0) | CLEANUP_PRE_LOOP\n+               | (flag_thread_jumps ? CLEANUP_THREADING : 0));\n+\n+  create_loop_notes ();\n+\n+  purge_line_number_notes ();\n+\n+  if (optimize)\n+    cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n+\n+  /* Jump optimization, and the removal of NULL pointer checks, may\n+     have reduced the number of instructions substantially.  CSE, and\n+     future passes, allocate arrays whose dimensions involve the\n+     maximum instruction UID, so if we can reduce the maximum UID\n+     we'll save big on memory.  */\n+  renumber_insns (dump_file);\n+}\n+\n+\n+struct tree_opt_pass pass_jump2 =\n+{\n+  \"jump\",                               /* name */\n+  NULL,                                 /* gate */   \n+  rest_of_handle_jump2,\t\t\t/* execute */       \n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_JUMP,                              /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  TODO_ggc_collect,                     /* todo_flags_start */\n+  TODO_dump_func,                       /* todo_flags_finish */\n+  'j'                                   /* letter */\n+};\n+\n+"}, {"sha": "a3bd41c4797a8c9486c6df593879a5648a3e7657", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -37,9 +37,9 @@ Boston, MA 02110-1301, USA.  */\n #include \"flags.h\"\n #include \"diagnostic.h\"\n #include \"toplev.h\"\n+#include \"debug.h\"\n #include \"params.h\"\n \n-\n /* Verify that there is exactly single jump instruction since last and attach\n    REG_BR_PROB note specifying probability.\n    ??? We really ought to pass the probability down to RTL expanders and let it\n@@ -1556,6 +1556,30 @@ tree_expand_cfg (void)\n \t       \"\\n\\n;;\\n;; Full RTL generated for this function:\\n;;\\n\");\n       /* And the pass manager will dump RTL for us.  */\n     }\n+\n+  /* If we're emitting a nested function, make sure its parent gets\n+     emitted as well.  Doing otherwise confuses debug info.  */\n+  {   \n+    tree parent;\n+    for (parent = DECL_CONTEXT (current_function_decl);\n+         parent != NULL_TREE;\n+         parent = get_containing_scope (parent))\n+      if (TREE_CODE (parent) == FUNCTION_DECL)\n+        TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (parent)) = 1;\n+  }\n+    \n+  /* We are now committed to emitting code for this function.  Do any\n+     preparation, such as emitting abstract debug info for the inline\n+     before it gets mangled by optimization.  */\n+  if (cgraph_function_possibly_inlined_p (current_function_decl))\n+    (*debug_hooks->outlining_inline_function) (current_function_decl);\n+\n+  TREE_ASM_WRITTEN (current_function_decl) = 1;\n+\n+#ifdef FINALIZE_PIC\n+  if (flag_pic)\n+    FINALIZE_PIC;\n+#endif\n }\n \n struct tree_opt_pass pass_expand =\n@@ -1572,6 +1596,6 @@ struct tree_opt_pass pass_expand =\n   PROP_rtl,                             /* properties_provided */\n   PROP_gimple_leh,\t\t\t/* properties_destroyed */\n   0,                                    /* todo_flags_start */\n-  0,\t\t\t\t\t/* todo_flags_finish */\n+  TODO_dump_func,                       /* todo_flags_finish */\n   'r'\t\t\t\t\t/* letter */\n };"}, {"sha": "2a8a1221ac9ace5cadeafad9bc8ddb7e837f9b28", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -36,6 +36,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"ggc.h\"\n #include \"alloc-pool.h\"\n #include \"flags.h\"\n+#include \"tree-pass.h\"\n \n /* Holds the interesting trailing notes for the function.  */\n rtx cfg_layout_function_footer, cfg_layout_function_header;\n@@ -330,6 +331,24 @@ insn_locators_initialize (void)\n   free_block_changes ();\n }\n \n+struct tree_opt_pass pass_insn_locators_initialize =\n+{\n+  NULL,                                 /* name */\n+  NULL,                                 /* gate */   \n+  insn_locators_initialize,             /* execute */       \n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  0,                                    /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  0,                                    /* todo_flags_finish */\n+  0                                     /* letter */\n+};\n+\n+\n /* For each lexical block, set BLOCK_NUMBER to the depth at which it is\n    found in the block tree.  */\n "}, {"sha": "30290d4902ca8a56b05666e9b75d96eba82d2ea4", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -59,6 +59,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"target.h\"\n #include \"cfgloop.h\"\n #include \"ggc.h\"\n+#include \"tree-pass.h\"\n \n static int can_delete_note_p (rtx);\n static int can_delete_label_p (rtx);\n@@ -418,6 +419,23 @@ free_bb_for_insn (void)\n       BLOCK_FOR_INSN (insn) = NULL;\n }\n \n+struct tree_opt_pass pass_free_cfg =\n+{\n+  NULL,                                 /* name */\n+  NULL,                                 /* gate */\n+  free_bb_for_insn,                     /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  0,                                    /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  PROP_cfg,                             /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  0,                                    /* todo_flags_finish */\n+  0                                     /* letter */\n+};\n+\n /* Return RTX to emit after when we want to emit code on the entry of function.  */\n rtx\n entry_of_function (void)"}, {"sha": "2538442fd0d8296bb4cbabad24f4cb96b86dc435", "filename": "gcc/cgraph.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -98,6 +98,7 @@ The varpool data structure:\n #include \"output.h\"\n #include \"intl.h\"\n #include \"tree-gimple.h\"\n+#include \"tree-dump.h\"\n \n static void cgraph_node_remove_callers (struct cgraph_node *node);\n static inline void cgraph_edge_remove_caller (struct cgraph_edge *e);"}, {"sha": "6ab04d4d850b78c3e79d780259384b095c12b716", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -1190,6 +1190,16 @@ cgraph_preserve_function_body_p (tree decl)\n   return false;\n }\n \n+static void\n+ipa_passes (void)\n+{\n+  cfun = NULL;\n+  tree_register_cfg_hooks ();\n+  bitmap_obstack_initialize (NULL);\n+  execute_ipa_pass_list (all_ipa_passes);\n+  bitmap_obstack_release (NULL);\n+}\n+\n /* Perform simple optimizations based on callgraph.  */\n \n void"}, {"sha": "9d2b28b9af8443cb92ca13cc0ab48f3027dd2681", "filename": "gcc/combine.c", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -96,6 +96,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n /* Include output.h for dump_file.  */\n #include \"output.h\"\n #include \"params.h\"\n+#include \"timevar.h\"\n+#include \"tree-pass.h\"\n \n /* Number of attempts to combine instructions in this function.  */\n \n@@ -12514,3 +12516,50 @@ dump_combine_total_stats (FILE *file)\n      \"\\n;; Combiner totals: %d attempts, %d substitutions (%d requiring new space),\\n;; %d successes.\\n\",\n      total_attempts, total_merges, total_extras, total_successes);\n }\n+\f\n+\n+static bool\n+gate_handle_combine (void)\n+{\n+  return (optimize > 0);\n+}\n+\n+/* Try combining insns through substitution.  */\n+static void\n+rest_of_handle_combine (void)\n+{\n+  int rebuild_jump_labels_after_combine\n+    = combine_instructions (get_insns (), max_reg_num ());\n+\n+  /* Combining insns may have turned an indirect jump into a\n+     direct jump.  Rebuild the JUMP_LABEL fields of jumping\n+     instructions.  */\n+  if (rebuild_jump_labels_after_combine)\n+    {\n+      timevar_push (TV_JUMP);\n+      rebuild_jump_labels (get_insns ());\n+      timevar_pop (TV_JUMP);\n+\n+      delete_dead_jumptables ();\n+      cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE);\n+    }\n+}\n+\n+struct tree_opt_pass pass_combine =\n+{\n+  \"combine\",                            /* name */\n+  gate_handle_combine,                  /* gate */\n+  rest_of_handle_combine,               /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_COMBINE,                           /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func |\n+  TODO_ggc_collect,                     /* todo_flags_finish */\n+  'c'                                   /* letter */\n+};\n+"}, {"sha": "0140cde4328a65c12272102ec262affd9dc64030", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -1,3 +1,9 @@\n+2005-07-05  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* Makefile.in (class.o, decl2.o): Adjust dependencies.\n+\t* class.c: Include tree-dump.h.\n+\t* decl2.c: Include tree-dump.h.\n+\t\n 2005-07-02  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \t* dump.c: Use dump_string_field."}, {"sha": "c3649e1ccc36866eb638989f413dee828f394513", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -244,7 +244,7 @@ cp/decl.o: cp/decl.c $(CXX_TREE_H) $(TM_H) flags.h cp/decl.h \\\n   debug.h gt-cp-decl.h timevar.h $(TREE_FLOW_H)\n cp/decl2.o: cp/decl2.c $(CXX_TREE_H) $(TM_H) flags.h cp/decl.h $(EXPR_H) \\\n   output.h except.h toplev.h $(RTL_H) c-common.h gt-cp-decl2.h cgraph.h \\\n-  c-pragma.h\n+  c-pragma.h $(TREE_DUMP_H) intl.h\n cp/cp-objcp-common.o : cp/cp-objcp-common.c $(CONFIG_H) $(SYSTEM_H) \\\n   coretypes.h $(TM_H) $(TREE_H) $(CXX_TREE_H) c-common.h toplev.h langhooks.h \\\n   $(LANGHOOKS_DEF_H) $(DIAGNOSTIC_H) debug.h $(CXX_PRETTY_PRINT_H) \\\n@@ -254,7 +254,7 @@ cp/typeck2.o: cp/typeck2.c $(CXX_TREE_H) $(TM_H) flags.h toplev.h output.h \\\n cp/typeck.o: cp/typeck.c $(CXX_TREE_H) $(TM_H) flags.h $(RTL_H) $(EXPR_H) \\\n   toplev.h diagnostic.h convert.h c-common.h\n cp/class.o: cp/class.c $(CXX_TREE_H) $(TM_H) flags.h toplev.h $(RTL_H) \\\n-  $(TARGET_H) convert.h $(CGRAPH_H)\n+  $(TARGET_H) convert.h $(CGRAPH_H) $(TREE_DUMP_H)\n cp/call.o: cp/call.c $(CXX_TREE_H) $(TM_H) flags.h toplev.h $(RTL_H) \\\n   $(EXPR_H) diagnostic.h intl.h gt-cp-call.h convert.h target.h\n cp/friend.o: cp/friend.c $(CXX_TREE_H) $(TM_H) flags.h $(RTL_H) toplev.h \\"}, {"sha": "a226d28f88547c3a0a4b7a46b4efba8d7c4841d4", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -36,6 +36,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"target.h\"\n #include \"convert.h\"\n #include \"cgraph.h\"\n+#include \"tree-dump.h\"\n \n /* The number of nested classes being processed.  If we are not in the\n    scope of any class, this is zero.  */"}, {"sha": "cb08ee51eeb39bd625a0ac77362c7dc63ae82d23", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -49,6 +49,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"cgraph.h\"\n #include \"tree-inline.h\"\n #include \"c-pragma.h\"\n+#include \"tree-dump.h\"\n #include \"intl.h\"\n \n extern cpp_reader *parse_in;"}, {"sha": "c7f9000b2edf41b97322121e87d736253ec8ca2a", "filename": "gcc/cse.c", "status": "modified", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -43,6 +43,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"target.h\"\n #include \"params.h\"\n #include \"rtlhooks-def.h\"\n+#include \"tree-pass.h\"\n \n /* The basic idea of common subexpression elimination is to go\n    through the code, keeping a record of expressions that would\n@@ -7741,3 +7742,119 @@ cse_condition_code_reg (void)\n \t}\n     }\n }\n+\f\n+\n+/* Perform common subexpression elimination.  Nonzero value from\n+   `cse_main' means that jumps were simplified and some code may now\n+   be unreachable, so do jump optimization again.  */\n+static bool\n+gate_handle_cse (void)\n+{\n+  return optimize > 0;\n+}\n+\n+static void\n+rest_of_handle_cse (void)\n+{\n+  int tem;\n+\n+  if (dump_file)\n+    dump_flow_info (dump_file);\n+\n+  reg_scan (get_insns (), max_reg_num ());\n+\n+  tem = cse_main (get_insns (), max_reg_num (), dump_file);\n+  if (tem)\n+    rebuild_jump_labels (get_insns ());\n+  if (purge_all_dead_edges ())\n+    delete_unreachable_blocks ();\n+\n+  delete_trivially_dead_insns (get_insns (), max_reg_num ());\n+\n+  /* If we are not running more CSE passes, then we are no longer\n+     expecting CSE to be run.  But always rerun it in a cheap mode.  */\n+  cse_not_expected = !flag_rerun_cse_after_loop && !flag_gcse;\n+\n+  if (tem)\n+    delete_dead_jumptables ();\n+\n+  if (tem || optimize > 1)\n+    cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n+}\n+\n+struct tree_opt_pass pass_cse =\n+{\n+  \"cse1\",                               /* name */\n+  gate_handle_cse,                      /* gate */   \n+  rest_of_handle_cse,\t\t\t/* execute */       \n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_CSE,                               /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func |\n+  TODO_ggc_collect,                     /* todo_flags_finish */\n+  's'                                   /* letter */\n+};\n+\n+\n+static bool\n+gate_handle_cse2 (void)\n+{\n+  return optimize > 0 && flag_rerun_cse_after_loop;\n+}\n+\n+/* Run second CSE pass after loop optimizations.  */\n+static void\n+rest_of_handle_cse2 (void)\n+{\n+  int tem;\n+\n+  if (dump_file)\n+    dump_flow_info (dump_file);\n+\n+  tem = cse_main (get_insns (), max_reg_num (), dump_file);\n+\n+  /* Run a pass to eliminate duplicated assignments to condition code\n+     registers.  We have to run this after bypass_jumps, because it\n+     makes it harder for that pass to determine whether a jump can be\n+     bypassed safely.  */\n+  cse_condition_code_reg ();\n+\n+  purge_all_dead_edges ();\n+  delete_trivially_dead_insns (get_insns (), max_reg_num ());\n+\n+  if (tem)\n+    {\n+      timevar_push (TV_JUMP);\n+      rebuild_jump_labels (get_insns ());\n+      delete_dead_jumptables ();\n+      cleanup_cfg (CLEANUP_EXPENSIVE);\n+      timevar_pop (TV_JUMP);\n+    }\n+  reg_scan (get_insns (), max_reg_num ());\n+  cse_not_expected = 1;\n+}\n+\n+\n+struct tree_opt_pass pass_cse2 =\n+{\n+  \"cse2\",                               /* name */\n+  gate_handle_cse2,                     /* gate */   \n+  rest_of_handle_cse2,\t\t\t/* execute */       \n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_CSE2,                              /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func |\n+  TODO_ggc_collect,                     /* todo_flags_finish */\n+  't'                                   /* letter */\n+};\n+"}, {"sha": "351c70ba7f942a69b908bd6af0281e450f91c428", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -55,6 +55,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"ggc.h\"\n #include \"debug.h\"\n #include \"langhooks.h\"\n+#include \"tree-pass.h\"\n \n /* Commonly used modes.  */\n \n@@ -2135,6 +2136,24 @@ unshare_all_rtl (void)\n   unshare_all_rtl_1 (current_function_decl, get_insns ());\n }\n \n+struct tree_opt_pass pass_unshare_all_rtl =\n+{\n+  NULL,                                 /* name */\n+  NULL,                                 /* gate */\n+  unshare_all_rtl,                      /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  0,                                    /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  0,                                    /* todo_flags_finish */\n+  0                                     /* letter */\n+};\n+\n+\n /* Check that ORIG is not marked when it should not be and mark ORIG as in use,\n    Recursively does the same for subexpressions.  */\n \n@@ -3705,6 +3724,23 @@ remove_unnecessary_notes (void)\n   gcc_assert (!eh_stack);\n }\n \n+struct tree_opt_pass pass_remove_unnecessary_notes =\n+{\n+  NULL,                                 /* name */ \n+  NULL,\t\t\t\t\t/* gate */\n+  remove_unnecessary_notes,             /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  0,\t\t\t\t\t/* tv_id */ \n+  0,\t\t\t\t\t/* properties_required */\n+  0,                                    /* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  0,\t\t\t\t\t/* todo_flags_finish */\n+  0                                     /* letter */ \n+};\n+\n \f\n /* Emit insn(s) of given code and pattern\n    at a specified place within the doubly-linked list."}, {"sha": "4578ae903d8fffaa28e08755302eb567354f16fd", "filename": "gcc/except.c", "status": "modified", "additions": 69, "deletions": 1, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -75,6 +75,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"langhooks.h\"\n #include \"cgraph.h\"\n #include \"diagnostic.h\"\n+#include \"tree-pass.h\"\n+#include \"timevar.h\"\n \n /* Provide defaults for stuff that may not be defined when using\n    sjlj exceptions.  */\n@@ -2711,6 +2713,23 @@ set_nothrow_function_flags (void)\n       }\n }\n \n+struct tree_opt_pass pass_set_nothrow_function_flags =\n+{\n+  NULL,                                 /* name */\n+  NULL,                                 /* gate */\n+  set_nothrow_function_flags,           /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  0,                                    /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  0,                                    /* todo_flags_finish */\n+  0                                     /* letter */\n+};\n+\n \f\n /* Various hooks for unwind library.  */\n \n@@ -3220,6 +3239,23 @@ convert_to_eh_region_ranges (void)\n   htab_delete (ar_hash);\n }\n \n+struct tree_opt_pass pass_convert_to_eh_region_ranges =\n+{\n+  NULL,                                 /* name */\n+  NULL,                                 /* gate */\n+  convert_to_eh_region_ranges,          /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  0,                                    /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  0,                                    /* todo_flags_finish */\n+  0                                     /* letter */\n+};\n+\n \f\n static void\n push_uleb128 (varray_type *data_area, unsigned int value)\n@@ -3768,7 +3804,6 @@ verify_eh_tree (struct function *fun)\n     }\n }\n \n-\n /* Initialize unwind_resume_libfunc.  */\n \n void\n@@ -3780,4 +3815,37 @@ default_init_unwind_resume_libfunc (void)\n \t\t\t\t\t     : \"_Unwind_Resume\");\n }\n \n+\f\n+static bool\n+gate_handle_eh (void)\n+{\n+  return doing_eh (0);\n+}\n+\n+/* Complete generation of exception handling code.  */\n+static void\n+rest_of_handle_eh (void)\n+{\n+  cleanup_cfg (CLEANUP_PRE_LOOP | CLEANUP_NO_INSN_DEL);\n+  finish_eh_generation ();\n+  cleanup_cfg (CLEANUP_PRE_LOOP | CLEANUP_NO_INSN_DEL);\n+}\n+\n+struct tree_opt_pass pass_rtl_eh =\n+{\n+  \"eh\",                                 /* name */\n+  gate_handle_eh,                       /* gate */   \n+  rest_of_handle_eh,\t\t\t/* execute */       \n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_JUMP,                              /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func,                       /* todo_flags_finish */\n+  'h'                                   /* letter */\n+};\n+\n #include \"gt-except.h\""}, {"sha": "18c53b76aad0478ad995eb0e99d4aedb202eb0bc", "filename": "gcc/final.c", "status": "modified", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -72,6 +72,10 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"debug.h\"\n #include \"expr.h\"\n #include \"cfglayout.h\"\n+#include \"tree-pass.h\"\n+#include \"timevar.h\"\n+#include \"cgraph.h\"\n+#include \"coverage.h\"\n \n #ifdef XCOFF_DEBUGGING_INFO\n #include \"xcoffout.h\"\t\t/* Needed for external data\n@@ -735,6 +739,24 @@ compute_alignments (void)\n       LABEL_TO_MAX_SKIP (label) = max_skip;\n     }\n }\n+\n+struct tree_opt_pass pass_compute_alignments =\n+{\n+  NULL,                                 /* name */\n+  NULL,                                 /* gate */\n+  compute_alignments,                   /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  0,                                    /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  0,                                    /* todo_flags_finish */\n+  0                                     /* letter */\n+};\n+\n \f\n /* Make a pass over all insns and compute their actual lengths by shortening\n    any branches of variable length if possible.  */\n@@ -3862,3 +3884,186 @@ debug_free_queue (void)\n       symbol_queue_size = 0;\n     }\n }\n+\f\n+/* Turn the RTL into assembly.  */\n+static void\n+rest_of_handle_final (void)\n+{\n+  rtx x;\n+  const char *fnname;\n+\n+  /* Get the function's name, as described by its RTL.  This may be\n+     different from the DECL_NAME name used in the source file.  */\n+\n+  x = DECL_RTL (current_function_decl);\n+  gcc_assert (MEM_P (x));\n+  x = XEXP (x, 0);\n+  gcc_assert (GET_CODE (x) == SYMBOL_REF);\n+  fnname = XSTR (x, 0);\n+\n+  assemble_start_function (current_function_decl, fnname);\n+  final_start_function (get_insns (), asm_out_file, optimize);\n+  final (get_insns (), asm_out_file, optimize);\n+  final_end_function ();\n+\n+#ifdef TARGET_UNWIND_INFO\n+  /* ??? The IA-64 \".handlerdata\" directive must be issued before\n+     the \".endp\" directive that closes the procedure descriptor.  */\n+  output_function_exception_table ();\n+#endif\n+\n+  assemble_end_function (current_function_decl, fnname);\n+\n+#ifndef TARGET_UNWIND_INFO\n+  /* Otherwise, it feels unclean to switch sections in the middle.  */\n+  output_function_exception_table ();\n+#endif\n+\n+  user_defined_section_attribute = false;\n+\n+  if (! quiet_flag)\n+    fflush (asm_out_file);\n+\n+  /* Release all memory allocated by flow.  */\n+  free_basic_block_vars ();\n+\n+  /* Write DBX symbols if requested.  */\n+\n+  /* Note that for those inline functions where we don't initially\n+     know for certain that we will be generating an out-of-line copy,\n+     the first invocation of this routine (rest_of_compilation) will\n+     skip over this code by doing a `goto exit_rest_of_compilation;'.\n+     Later on, wrapup_global_declarations will (indirectly) call\n+     rest_of_compilation again for those inline functions that need\n+     to have out-of-line copies generated.  During that call, we\n+     *will* be routed past here.  */\n+\n+  timevar_push (TV_SYMOUT);\n+  (*debug_hooks->function_decl) (current_function_decl);\n+  timevar_pop (TV_SYMOUT);\n+}\n+\n+struct tree_opt_pass pass_final =\n+{\n+  NULL,                                 /* name */\n+  NULL,                                 /* gate */\n+  rest_of_handle_final,                 /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_FINAL,                             /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_ggc_collect,                     /* todo_flags_finish */\n+  0                                     /* letter */\n+};\n+\n+\n+static void\n+rest_of_handle_shorten_branches (void)\n+{\n+  /* Shorten branches.  */\n+  shorten_branches (get_insns ());\n+}\n+ \n+struct tree_opt_pass pass_shorten_branches =\n+{\n+  NULL,                                 /* name */\n+  NULL,                                 /* gate */\n+  rest_of_handle_shorten_branches,      /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_FINAL,                             /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  0,                                    /* todo_flags_finish */\n+  0                                     /* letter */\n+};\n+\n+\n+static void\n+rest_of_clean_state (void)\n+{\n+  rtx insn, next;\n+\n+  /* It is very important to decompose the RTL instruction chain here:\n+     debug information keeps pointing into CODE_LABEL insns inside the function\n+     body.  If these remain pointing to the other insns, we end up preserving\n+     whole RTL chain and attached detailed debug info in memory.  */\n+  for (insn = get_insns (); insn; insn = next)\n+    {\n+      next = NEXT_INSN (insn);\n+      NEXT_INSN (insn) = NULL;\n+      PREV_INSN (insn) = NULL;\n+    }\n+\n+  /* In case the function was not output,\n+     don't leave any temporary anonymous types\n+     queued up for sdb output.  */\n+#ifdef SDB_DEBUGGING_INFO\n+  if (write_symbols == SDB_DEBUG)\n+    sdbout_types (NULL_TREE);\n+#endif\n+\n+  reload_completed = 0;\n+  epilogue_completed = 0;\n+  flow2_completed = 0;\n+  no_new_pseudos = 0;\n+\n+  /* Clear out the insn_length contents now that they are no\n+     longer valid.  */\n+  init_insn_lengths ();\n+\n+  /* Show no temporary slots allocated.  */\n+  init_temp_slots ();\n+\n+  free_basic_block_vars ();\n+  free_bb_for_insn ();\n+\n+\n+  if (targetm.binds_local_p (current_function_decl))\n+    {\n+      int pref = cfun->preferred_stack_boundary;\n+      if (cfun->stack_alignment_needed > cfun->preferred_stack_boundary)\n+        pref = cfun->stack_alignment_needed;\n+      cgraph_rtl_info (current_function_decl)->preferred_incoming_stack_boundary\n+        = pref;\n+    }\n+\n+  /* Make sure volatile mem refs aren't considered valid operands for\n+     arithmetic insns.  We must call this here if this is a nested inline\n+     function, since the above code leaves us in the init_recog state,\n+     and the function context push/pop code does not save/restore volatile_ok.\n+\n+     ??? Maybe it isn't necessary for expand_start_function to call this\n+     anymore if we do it here?  */\n+\n+  init_recog_no_volatile ();\n+\n+  /* We're done with this function.  Free up memory if we can.  */\n+  free_after_parsing (cfun);\n+  free_after_compilation (cfun);\n+}\n+\n+struct tree_opt_pass pass_clean_state =\n+{\n+  NULL,                                 /* name */\n+  NULL,                                 /* gate */\n+  rest_of_clean_state,                  /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_FINAL,                             /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  PROP_rtl,                             /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  0,                                    /* todo_flags_finish */\n+  0                                     /* letter */\n+};\n+"}, {"sha": "6a0022d77e59686d3a5df4f96941a03cdfa40a7e", "filename": "gcc/flow.c", "status": "modified", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -140,6 +140,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"obstack.h\"\n #include \"splay-tree.h\"\n+#include \"tree-pass.h\"\n \n #ifndef HAVE_epilogue\n #define HAVE_epilogue 0\n@@ -4357,6 +4358,23 @@ recompute_reg_usage (void)\n   update_life_info (NULL, UPDATE_LIFE_LOCAL, PROP_REG_INFO | PROP_DEATH_NOTES);\n }\n \n+struct tree_opt_pass pass_recompute_reg_usage =\n+{\n+  NULL,                                 /* name */\n+  NULL,                                 /* gate */\n+  recompute_reg_usage,                  /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  0,                                    /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  0,                                    /* todo_flags_finish */\n+  0                                     /* letter */\n+};\n+\n /* Optionally removes all the REG_DEAD and REG_UNUSED notes from a set of\n    blocks.  If BLOCKS is NULL, assume the universal set.  Returns a count\n    of the number of registers that died.  */\n@@ -4504,3 +4522,131 @@ reg_set_to_hard_reg_set (HARD_REG_SET *to, bitmap from)\n       SET_HARD_REG_BIT (*to, i);\n     }\n }\n+\f\n+\n+static bool\n+gate_remove_death_notes (void)\n+{\n+  return flag_profile_values;\n+}\n+\n+static void\n+rest_of_handle_remove_death_notes (void)\n+{\n+  count_or_remove_death_notes (NULL, 1);\n+}\n+\n+struct tree_opt_pass pass_remove_death_notes =\n+{\n+  NULL,                                 /* name */\n+  gate_remove_death_notes,              /* gate */\n+  rest_of_handle_remove_death_notes,    /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  0,                                    /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  0,                                    /* todo_flags_finish */\n+  0                                     /* letter */\n+};\n+\n+/* Perform life analysis.  */\n+static void\n+rest_of_handle_life (void)\n+{\n+  regclass_init ();\n+\n+  life_analysis (dump_file, PROP_FINAL);\n+  if (optimize)\n+    cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE | CLEANUP_LOG_LINKS\n+                 | (flag_thread_jumps ? CLEANUP_THREADING : 0));\n+\n+  if (extra_warnings)\n+    {\n+      setjmp_vars_warning (DECL_INITIAL (current_function_decl));\n+      setjmp_args_warning ();\n+    }\n+\n+  if (optimize)\n+    {\n+      if (initialize_uninitialized_subregs ())\n+        {\n+          /* Insns were inserted, and possibly pseudos created, so\n+             things might look a bit different.  */\n+          allocate_reg_life_data ();\n+          update_life_info (NULL, UPDATE_LIFE_GLOBAL_RM_NOTES,\n+                            PROP_LOG_LINKS | PROP_REG_INFO | PROP_DEATH_NOTES);\n+        }\n+    }\n+\n+  no_new_pseudos = 1;\n+}\n+\n+struct tree_opt_pass pass_life =\n+{\n+  \"life\",                               /* name */\n+  NULL,                                 /* gate */\n+  rest_of_handle_life,                  /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_FLOW,                              /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  TODO_verify_flow,                     /* todo_flags_start */\n+  TODO_dump_func |\n+  TODO_ggc_collect,                     /* todo_flags_finish */\n+  'f'                                   /* letter */\n+};\n+\n+static void\n+rest_of_handle_flow2 (void)\n+{\n+  /* Re-create the death notes which were deleted during reload.  */\n+#ifdef ENABLE_CHECKING\n+  verify_flow_info ();\n+#endif\n+\n+  /* If optimizing, then go ahead and split insns now.  */\n+#ifndef STACK_REGS\n+  if (optimize > 0)\n+#endif\n+    split_all_insns (0);\n+\n+  if (flag_branch_target_load_optimize)\n+    branch_target_load_optimize (epilogue_completed);\n+\n+  if (optimize)\n+    cleanup_cfg (CLEANUP_EXPENSIVE);\n+\n+  /* On some machines, the prologue and epilogue code, or parts thereof,\n+     can be represented as RTL.  Doing so lets us schedule insns between\n+     it and the rest of the code and also allows delayed branch\n+     scheduling to operate in the epilogue.  */\n+  thread_prologue_and_epilogue_insns (get_insns ());\n+  epilogue_completed = 1;\n+  flow2_completed = 1;\n+}\n+\n+struct tree_opt_pass pass_flow2 =\n+{\n+  \"flow2\",                              /* name */\n+  NULL,                                 /* gate */\n+  rest_of_handle_flow2,                 /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_FLOW2,                             /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  TODO_verify_flow,                     /* todo_flags_start */\n+  TODO_dump_func |\n+  TODO_ggc_collect,                     /* todo_flags_finish */\n+  'w'                                   /* letter */\n+};\n+"}, {"sha": "ae8f7fd978b5b24a52e6819ec1f0dc38e5a59cbd", "filename": "gcc/function.c", "status": "modified", "additions": 65, "deletions": 1, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -61,9 +61,9 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"target.h\"\n #include \"cfglayout.h\"\n #include \"tree-gimple.h\"\n+#include \"tree-pass.h\"\n #include \"predict.h\"\n \n-\n #ifndef LOCAL_ALIGNMENT\n #define LOCAL_ALIGNMENT(TYPE, ALIGNMENT) ALIGNMENT\n #endif\n@@ -1662,6 +1662,24 @@ instantiate_virtual_regs (void)\n      frame_pointer_rtx.  */\n   virtuals_instantiated = 1;\n }\n+\n+struct tree_opt_pass pass_instantiate_virtual_regs =\n+{\n+  NULL,                                 /* name */\n+  NULL,                                 /* gate */\n+  instantiate_virtual_regs,             /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  0,                                    /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  0,                                    /* todo_flags_finish */\n+  0                                     /* letter */\n+};\n+\n \f\n /* Return 1 if EXP is an aggregate type (or a value with aggregate type).\n    This means a type for which function calls must pass an address to the\n@@ -3884,6 +3902,24 @@ init_function_for_compilation (void)\n   gcc_assert (VEC_length (int, sibcall_epilogue) == 0);\n }\n \n+struct tree_opt_pass pass_init_function =\n+{\n+  NULL,                                 /* name */\n+  NULL,                                 /* gate */   \n+  init_function_for_compilation,        /* execute */       \n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  0,                                    /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  0,                                    /* todo_flags_finish */\n+  0                                     /* letter */\n+};\n+\n+\n void\n expand_main_function (void)\n {\n@@ -5499,5 +5535,33 @@ current_function_name (void)\n {\n   return lang_hooks.decl_printable_name (cfun->decl, 2);\n }\n+\f\n+\n+static void\n+rest_of_handle_check_leaf_regs (void)\n+{\n+#ifdef LEAF_REGISTERS\n+  current_function_uses_only_leaf_regs\n+    = optimize > 0 && only_leaf_regs_used () && leaf_function_p ();\n+#endif\n+}\n+\n+struct tree_opt_pass pass_leaf_regs =\n+{\n+  NULL,                                 /* name */\n+  NULL,                                 /* gate */\n+  rest_of_handle_check_leaf_regs,       /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  0,                                    /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  0,                                    /* todo_flags_finish */\n+  0                                     /* letter */\n+};\n+\n \n #include \"gt-function.h\""}, {"sha": "5099a08d7ba312cff81dc88a012c6c0e040d7dc8", "filename": "gcc/gcse.c", "status": "modified", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -169,6 +169,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"intl.h\"\n #include \"obstack.h\"\n #include \"timevar.h\"\n+#include \"tree-pass.h\"\n \n /* Propagate flow information through back edges and thus enable PRE's\n    moving loop invariant calculations out of loops.\n@@ -6558,5 +6559,113 @@ is_too_expensive (const char *pass)\n \n   return false;\n }\n+\f\n+static bool\n+gate_handle_jump_bypass (void)\n+{\n+  return optimize > 0 && flag_gcse;\n+}\n+\n+/* Perform jump bypassing and control flow optimizations.  */\n+static void\n+rest_of_handle_jump_bypass (void)\n+{\n+  cleanup_cfg (CLEANUP_EXPENSIVE);\n+  reg_scan (get_insns (), max_reg_num ());\n+\n+  if (bypass_jumps (dump_file))\n+    {\n+      rebuild_jump_labels (get_insns ());\n+      cleanup_cfg (CLEANUP_EXPENSIVE);\n+      delete_trivially_dead_insns (get_insns (), max_reg_num ());\n+    }\n+}\n+\n+struct tree_opt_pass pass_jump_bypass =\n+{\n+  \"bypass\",                             /* name */\n+  gate_handle_jump_bypass,              /* gate */   \n+  rest_of_handle_jump_bypass,           /* execute */       \n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_BYPASS,                            /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func |\n+  TODO_ggc_collect | TODO_verify_flow,  /* todo_flags_finish */\n+  'G'                                   /* letter */\n+};\n+\n+\n+static bool\n+gate_handle_gcse (void)\n+{\n+  return optimize > 0 && flag_gcse;\n+}\n+\n+\n+static void\n+rest_of_handle_gcse (void)\n+{\n+  int save_csb, save_cfj;\n+  int tem2 = 0, tem;\n+\n+  tem = gcse_main (get_insns (), dump_file);\n+  rebuild_jump_labels (get_insns ());\n+  delete_trivially_dead_insns (get_insns (), max_reg_num ());\n+\n+  save_csb = flag_cse_skip_blocks;\n+  save_cfj = flag_cse_follow_jumps;\n+  flag_cse_skip_blocks = flag_cse_follow_jumps = 0;\n+\n+  /* If -fexpensive-optimizations, re-run CSE to clean up things done\n+     by gcse.  */\n+  if (flag_expensive_optimizations)\n+    {\n+      timevar_push (TV_CSE);\n+      reg_scan (get_insns (), max_reg_num ());\n+      tem2 = cse_main (get_insns (), max_reg_num (), dump_file);\n+      purge_all_dead_edges ();\n+      delete_trivially_dead_insns (get_insns (), max_reg_num ());\n+      timevar_pop (TV_CSE);\n+      cse_not_expected = !flag_rerun_cse_after_loop;\n+    }\n+\n+  /* If gcse or cse altered any jumps, rerun jump optimizations to clean\n+     things up.  */\n+  if (tem || tem2)\n+    {\n+      timevar_push (TV_JUMP);\n+      rebuild_jump_labels (get_insns ());\n+      delete_dead_jumptables ();\n+      cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n+      timevar_pop (TV_JUMP);\n+    }\n+\n+  flag_cse_skip_blocks = save_csb;\n+  flag_cse_follow_jumps = save_cfj;\n+}\n+\n+struct tree_opt_pass pass_gcse =\n+{\n+  \"gcse1\",                              /* name */\n+  gate_handle_gcse,                     /* gate */   \n+  rest_of_handle_gcse,\t\t\t/* execute */       \n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_GCSE,                              /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func |\n+  TODO_verify_flow | TODO_ggc_collect,  /* todo_flags_finish */\n+  'G'                                   /* letter */\n+};\n+\n \n #include \"gt-gcse.h\""}, {"sha": "13b81736859a137ecc17b193a370199e6e0fdd0c", "filename": "gcc/global.c", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -36,6 +36,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"reload.h\"\n #include \"output.h\"\n #include \"toplev.h\"\n+#include \"tree-pass.h\"\n+#include \"timevar.h\"\n \n /* This pass of the compiler performs global register allocation.\n    It assigns hard register numbers to all the pseudo registers\n@@ -2474,3 +2476,50 @@ make_accurate_live_analysis (void)\n     }\n   free_bb_info ();\n }\n+/* Run old register allocator.  Return TRUE if we must exit\n+   rest_of_compilation upon return.  */\n+static void\n+rest_of_handle_global_alloc (void)\n+{\n+  bool failure;\n+\n+  /* If optimizing, allocate remaining pseudo-regs.  Do the reload\n+     pass fixing up any insns that are invalid.  */\n+\n+  if (optimize)\n+    failure = global_alloc (dump_file);\n+  else\n+    {\n+      build_insn_chain (get_insns ());\n+      failure = reload (get_insns (), 0);\n+    }\n+\n+  if (dump_enabled_p (pass_global_alloc.static_pass_number))\n+    {\n+      timevar_push (TV_DUMP);\n+      dump_global_regs (dump_file);\n+      timevar_pop (TV_DUMP);\n+    }\n+\n+  gcc_assert (reload_completed || failure);\n+  reload_completed = !failure;\n+}\n+\n+struct tree_opt_pass pass_global_alloc =\n+{\n+  \"greg\",                               /* name */\n+  NULL,                                 /* gate */\n+  rest_of_handle_global_alloc,          /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_GLOBAL_ALLOC,                      /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func |\n+  TODO_ggc_collect,                     /* todo_flags_finish */\n+  'g'                                   /* letter */\n+};\n+"}, {"sha": "d9f18bca6118f6765850ede5d502e3e3096a657d", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -41,6 +41,8 @@\n #include \"tm_p.h\"\n #include \"cfgloop.h\"\n #include \"target.h\"\n+#include \"timevar.h\"\n+#include \"tree-pass.h\"\n \n \n #ifndef HAVE_conditional_execution\n@@ -3579,3 +3581,120 @@ if_convert (int x_life_data_ok)\n   verify_flow_info ();\n #endif\n }\n+\f\n+static bool\n+gate_handle_if_conversion (void)\n+{\n+  return (optimize > 0);\n+}\n+\n+/* If-conversion and CFG cleanup.  */\n+static void\n+rest_of_handle_if_conversion (void)\n+{\n+  if (flag_if_conversion)\n+    {\n+      if (dump_file)\n+        dump_flow_info (dump_file);\n+      cleanup_cfg (CLEANUP_EXPENSIVE);\n+      reg_scan (get_insns (), max_reg_num ());\n+      if_convert (0);\n+    }\n+\n+  timevar_push (TV_JUMP);\n+  cleanup_cfg (CLEANUP_EXPENSIVE);\n+  reg_scan (get_insns (), max_reg_num ());\n+  timevar_pop (TV_JUMP);\n+}\n+\n+struct tree_opt_pass pass_rtl_ifcvt =\n+{\n+  \"ce1\",                                /* name */\n+  gate_handle_if_conversion,            /* gate */\n+  rest_of_handle_if_conversion,         /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_IFCVT,                             /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func,                       /* todo_flags_finish */\n+  'C'                                   /* letter */\n+};\n+\n+static bool\n+gate_handle_if_after_combine (void)\n+{\n+  return (optimize > 0 && flag_if_conversion);\n+}\n+\n+\n+/* Rerun if-conversion, as combine may have simplified things enough\n+   to now meet sequence length restrictions.  */\n+static void\n+rest_of_handle_if_after_combine (void)\n+{\n+  no_new_pseudos = 0;\n+  if_convert (1);\n+  no_new_pseudos = 1;\n+}\n+\n+struct tree_opt_pass pass_if_after_combine =\n+{\n+  \"ce2\",                                /* name */\n+  gate_handle_if_after_combine,         /* gate */\n+  rest_of_handle_if_after_combine,      /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_IFCVT,                             /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func |\n+  TODO_ggc_collect,                     /* todo_flags_finish */\n+  'C'                                   /* letter */\n+};\n+\n+\n+static bool\n+gate_handle_if_after_reload (void)\n+{\n+  return (optimize > 0);\n+}\n+\n+static void\n+rest_of_handle_if_after_reload (void)\n+{\n+  /* Last attempt to optimize CFG, as scheduling, peepholing and insn\n+     splitting possibly introduced more crossjumping opportunities.  */\n+  cleanup_cfg (CLEANUP_EXPENSIVE\n+               | CLEANUP_UPDATE_LIFE\n+               | (flag_crossjumping ? CLEANUP_CROSSJUMP : 0));\n+  if (flag_if_conversion2)\n+    if_convert (1);\n+}\n+\n+\n+struct tree_opt_pass pass_if_after_reload =\n+{\n+  \"ce3\",                                /* name */\n+  gate_handle_if_after_reload,          /* gate */\n+  rest_of_handle_if_after_reload,       /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_IFCVT2,                            /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func |\n+  TODO_ggc_collect,                     /* todo_flags_finish */\n+  'E'                                   /* letter */\n+};\n+\n+"}, {"sha": "31ff9c76e08c1705e4c3e9b96d246714b6d2eed6", "filename": "gcc/integrate.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -45,6 +45,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"ggc.h\"\n #include \"target.h\"\n #include \"langhooks.h\"\n+#include \"tree-pass.h\"\n \n /* Round to the next highest integer that meets the alignment.  */\n #define CEIL_ROUND(VALUE,ALIGN)\t(((VALUE) + (ALIGN) - 1) & ~((ALIGN)- 1))\n@@ -371,6 +372,23 @@ emit_initial_value_sets (void)\n   emit_insn_after (seq, entry_of_function ());\n }\n \n+struct tree_opt_pass pass_initial_value_sets =\n+{\n+  NULL,                                 /* name */\n+  NULL,                                 /* gate */\n+  emit_initial_value_sets,              /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  0,                                    /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  0,                                    /* todo_flags_finish */\n+  0                                     /* letter */\n+};\n+\n /* If the backend knows where to allocate pseudos for hard\n    register initial values, register these allocations now.  */\n void"}, {"sha": "83861f1d71ce5058be63f87e7331b2f8c572141a", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -1,3 +1,8 @@\n+2005-07-05  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* Makefile.in (parse.o): Adjust dependencies.\n+\t* parse.y: Include tree-dump.h.\n+\n 2005-07-02  Joseph S. Myers  <joseph@codesourcery.com>\n \n \t* class.c, decl.c, expr.c: Use '+' flag instead of %J.  Use 'q'"}, {"sha": "ddeb12d8e3c93ea423f166ec357e89165992eddf", "filename": "gcc/java/Make-lang.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fjava%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fjava%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FMake-lang.in?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -365,7 +365,8 @@ java/parse-scan.o: java/parse-scan.c $(CONFIG_H) $(SYSTEM_H) \\\n   coretypes.h $(TM_H) toplev.h $(JAVA_LEX_C) java/parse.h java/lex.h input.h\n java/parse.o: java/parse.c java/jcf-reader.c $(CONFIG_H) $(SYSTEM_H) \\\n   coretypes.h $(TM_H) function.h $(JAVA_TREE_H) $(JAVA_LEX_C) java/parse.h \\\n-  java/lex.h input.h $(GGC_H) debug.h gt-java-parse.h gtype-java.h target.h\n+  java/lex.h input.h $(GGC_H) debug.h gt-java-parse.h gtype-java.h target.h \\\n+  $(TREE_DUMP_H)\n \n # jcf-io.o needs $(ZLIBINC) added to cflags.\n java/jcf-io.o: java/jcf-io.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\"}, {"sha": "cda54c1d1a9ba3fc2cb818cc8c857fecc7e9a611", "filename": "gcc/java/parse.y", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -72,6 +72,7 @@ definitions and other extensions.  */\n #include \"ggc.h\"\n #include \"debug.h\"\n #include \"tree-inline.h\"\n+#include \"tree-dump.h\"\n #include \"cgraph.h\"\n #include \"target.h\"\n "}, {"sha": "de5686d8fd5c4643ebe9f3a9b823b5abc7915ef8", "filename": "gcc/jump.c", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -56,6 +56,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"reload.h\"\n #include \"predict.h\"\n #include \"timevar.h\"\n+#include \"tree-pass.h\"\n \n /* Optimize jump y; x: ... y: jumpif... x?\n    Don't know if it is worth bothering with.  */\n@@ -120,8 +121,25 @@ cleanup_barriers (void)\n     }\n }\n \n+struct tree_opt_pass pass_cleanup_barriers =\n+{\n+  NULL,                                 /* name */\n+  NULL,                                 /* gate */\n+  cleanup_barriers,                     /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  0,                                    /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  0,                                    /* todo_flags_finish */\n+  0                                     /* letter */\n+};\n+\n void\n-purge_line_number_notes (rtx f)\n+purge_line_number_notes (void)\n {\n   rtx last_note = 0;\n   rtx insn;\n@@ -130,7 +148,7 @@ purge_line_number_notes (rtx f)\n      extraneous.  There should be some indication where that line belonged,\n      even if it became empty.  */\n \n-  for (insn = f; insn; insn = NEXT_INSN (insn))\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     if (NOTE_P (insn))\n       {\n \tif (NOTE_LINE_NUMBER (insn) == NOTE_INSN_FUNCTION_BEG)\n@@ -157,6 +175,24 @@ purge_line_number_notes (rtx f)\n \t  }\n       }\n }\n+\n+struct tree_opt_pass pass_purge_lineno_notes =\n+{\n+  NULL,                                 /* name */\n+  NULL,                                 /* gate */\n+  purge_line_number_notes,              /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  0,                                    /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  0,                                    /* todo_flags_finish */\n+  0                                     /* letter */\n+};\n+\n \f\n /* Initialize LABEL_NUSES and JUMP_LABEL fields.  Delete any REG_LABEL\n    notes whose labels don't occur in the insn any more.  Returns the"}, {"sha": "cd26174fa6a7a4ca77ee9d4492a785adaa381a87", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -78,6 +78,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"integrate.h\"\n #include \"reload.h\"\n #include \"ggc.h\"\n+#include \"timevar.h\"\n+#include \"tree-pass.h\"\n \f\n /* Next quantity number available for allocation.  */\n \n@@ -2496,3 +2498,69 @@ dump_local_alloc (FILE *file)\n     if (reg_renumber[i] != -1)\n       fprintf (file, \";; Register %d in %d.\\n\", i, reg_renumber[i]);\n }\n+\n+/* Run old register allocator.  Return TRUE if we must exit\n+   rest_of_compilation upon return.  */\n+static void\n+rest_of_handle_local_alloc (void)\n+{\n+  int rebuild_notes;\n+\n+  /* Determine if the current function is a leaf before running reload\n+     since this can impact optimizations done by the prologue and\n+     epilogue thus changing register elimination offsets.  */\n+  current_function_is_leaf = leaf_function_p ();\n+\n+  /* Allocate the reg_renumber array.  */\n+  allocate_reg_info (max_regno, FALSE, TRUE);\n+\n+  /* And the reg_equiv_memory_loc array.  */\n+  VARRAY_GROW (reg_equiv_memory_loc_varray, max_regno);\n+  reg_equiv_memory_loc = &VARRAY_RTX (reg_equiv_memory_loc_varray, 0);\n+\n+  allocate_initial_values (reg_equiv_memory_loc);\n+\n+  regclass (get_insns (), max_reg_num (), dump_file);\n+  rebuild_notes = local_alloc ();\n+\n+  /* Local allocation may have turned an indirect jump into a direct\n+     jump.  If so, we must rebuild the JUMP_LABEL fields of jumping\n+     instructions.  */\n+  if (rebuild_notes)\n+    {\n+      timevar_push (TV_JUMP);\n+\n+      rebuild_jump_labels (get_insns ());\n+      purge_all_dead_edges ();\n+      delete_unreachable_blocks ();\n+\n+      timevar_pop (TV_JUMP);\n+    }\n+\n+  if (dump_enabled_p (pass_local_alloc.static_pass_number))\n+    {\n+      timevar_push (TV_DUMP);\n+      dump_flow_info (dump_file);\n+      dump_local_alloc (dump_file);\n+      timevar_pop (TV_DUMP);\n+    }\n+}\n+\n+struct tree_opt_pass pass_local_alloc =\n+{\n+  \"lreg\",                               /* name */\n+  NULL,                                 /* gate */\n+  rest_of_handle_local_alloc,           /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_LOCAL_ALLOC,                       /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func |\n+  TODO_ggc_collect,                     /* todo_flags_finish */\n+  'l'                                   /* letter */\n+};\n+"}, {"sha": "375b2bf23a5e310b13a31a400e5a0e8455909e18", "filename": "gcc/loop-init.c", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Floop-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Floop-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-init.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -28,6 +28,9 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"basic-block.h\"\n #include \"cfgloop.h\"\n #include \"cfglayout.h\"\n+#include \"tree-pass.h\"\n+#include \"timevar.h\"\n+#include \"flags.h\"\n \n /* Initialize loop optimizer.  */\n \n@@ -116,3 +119,88 @@ loop_optimizer_finalize (struct loops *loops, FILE *dumpfile)\n   verify_flow_info ();\n #endif\n }\n+\f\n+static bool\n+gate_handle_loop2 (void)\n+{\n+  return (optimize > 0 && flag_loop_optimize2\n+  \t  && (flag_move_loop_invariants\n+              || flag_unswitch_loops\n+              || flag_peel_loops\n+              || flag_unroll_loops\n+              || flag_branch_on_count_reg));\n+}\n+\n+/* Perform loop optimizations.  It might be better to do them a bit\n+   sooner, but we want the profile feedback to work more\n+   efficiently.  */\n+static void\n+rest_of_handle_loop2 (void)\n+{\n+  struct loops *loops;\n+  basic_block bb;\n+\n+  if (dump_file)\n+    dump_flow_info (dump_file);\n+\n+  /* Initialize structures for layout changes.  */\n+  cfg_layout_initialize (0);\n+\n+  loops = loop_optimizer_init (dump_file);\n+\n+  if (loops)\n+    {\n+      /* The optimizations:  */\n+      if (flag_move_loop_invariants)\n+        move_loop_invariants (loops);\n+\n+      if (flag_unswitch_loops)\n+        unswitch_loops (loops);\n+\n+      if (flag_peel_loops || flag_unroll_loops)\n+        unroll_and_peel_loops (loops,\n+                               (flag_peel_loops ? UAP_PEEL : 0) |\n+                               (flag_unroll_loops ? UAP_UNROLL : 0) |\n+                               (flag_unroll_all_loops ? UAP_UNROLL_ALL : 0));\n+\n+#ifdef HAVE_doloop_end\n+      if (flag_branch_on_count_reg && HAVE_doloop_end)\n+        doloop_optimize_loops (loops);\n+#endif /* HAVE_doloop_end */\n+\n+      loop_optimizer_finalize (loops, dump_file);\n+    }\n+\n+  free_dominance_info (CDI_DOMINATORS);\n+\n+  /* Finalize layout changes.  */\n+  FOR_EACH_BB (bb)\n+    if (bb->next_bb != EXIT_BLOCK_PTR)\n+      bb->aux = bb->next_bb;\n+  cfg_layout_finalize ();\n+\n+  cleanup_cfg (CLEANUP_EXPENSIVE);\n+  delete_trivially_dead_insns (get_insns (), max_reg_num ());\n+  reg_scan (get_insns (), max_reg_num ());\n+  if (dump_file)\n+    dump_flow_info (dump_file);\n+}\n+\n+struct tree_opt_pass pass_loop2 =\n+{\n+  \"loop2\",                              /* name */\n+  gate_handle_loop2, \t\t        /* gate */\n+  rest_of_handle_loop2,      \t\t/* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_LOOP,                              /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func |\n+  TODO_ggc_collect,                     /* todo_flags_finish */\n+  'L'                                   /* letter */\n+};\n+"}, {"sha": "b9b285648bc3ebc6b160c635383505301a55e53a", "filename": "gcc/loop.c", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -66,6 +66,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"optabs.h\"\n #include \"cfgloop.h\"\n #include \"ggc.h\"\n+#include \"timevar.h\"\n+#include \"tree-pass.h\"\n \n /* Get the loop info pointer of a loop.  */\n #define LOOP_INFO(LOOP) ((struct loop_info *) (LOOP)->aux)\n@@ -11807,3 +11809,66 @@ debug_loops (const struct loops *loops)\n {\n   flow_loops_dump (loops, stderr, loop_dump_aux, 1);\n }\n+\f\n+static bool\n+gate_handle_loop_optimize (void)\n+{\n+  return (optimize > 0 && flag_loop_optimize);\n+}\n+\n+/* Move constant computations out of loops.  */\n+static void\n+rest_of_handle_loop_optimize (void)\n+{\n+  int do_prefetch;\n+\n+  /* CFG is no longer maintained up-to-date.  */\n+  free_bb_for_insn ();\n+  profile_status = PROFILE_ABSENT;\n+  \n+  do_prefetch = flag_prefetch_loop_arrays ? LOOP_PREFETCH : 0;\n+  \n+  if (flag_rerun_loop_opt)\n+    {\n+      cleanup_barriers ();\n+      \n+      /* We only want to perform unrolling once.  */\n+      loop_optimize (get_insns (), dump_file, 0);\n+      \n+      /* The first call to loop_optimize makes some instructions\n+         trivially dead.  We delete those instructions now in the\n+         hope that doing so will make the heuristics in loop work\n+         better and possibly speed up compilation.  */\n+      delete_trivially_dead_insns (get_insns (), max_reg_num ());\n+  \n+      /* The regscan pass is currently necessary as the alias\n+         analysis code depends on this information.  */\n+      reg_scan (get_insns (), max_reg_num ());\n+    } \n+  cleanup_barriers ();\n+  loop_optimize (get_insns (), dump_file, do_prefetch);\n+      \n+  /* Loop can create trivially dead instructions.  */\n+  delete_trivially_dead_insns (get_insns (), max_reg_num ());\n+  find_basic_blocks (get_insns ());\n+}\n+\n+struct tree_opt_pass pass_loop_optimize =\n+{\n+  \"old-loop\",                           /* name */\n+  gate_handle_loop_optimize,            /* gate */   \n+  rest_of_handle_loop_optimize,         /* execute */       \n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_LOOP,                              /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func |\n+  TODO_ggc_collect,                     /* todo_flags_finish */\n+  'L'                                   /* letter */\n+};\n+\n+"}, {"sha": "9e8ad62fbe7a54c45636d8c3ddd439740ab84ead", "filename": "gcc/mode-switching.c", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fmode-switching.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fmode-switching.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmode-switching.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -34,6 +34,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"output.h\"\n #include \"tm_p.h\"\n #include \"function.h\"\n+#include \"tree-pass.h\"\n+#include \"timevar.h\"\n \n /* We want target macros for the mode switching code to be able to refer\n    to instruction attribute values.  */\n@@ -708,4 +710,43 @@ optimize_mode_switching (FILE *file)\n \n   return 1;\n }\n+\n #endif /* OPTIMIZE_MODE_SWITCHING */\n+\f\n+static bool\n+gate_mode_switching (void)\n+{\n+#ifdef OPTIMIZE_MODE_SWITCHING\n+  return true;\n+#else\n+  return false;\n+#endif\n+}\n+\n+static void\n+rest_of_handle_mode_switching (void)\n+{\n+#ifdef OPTIMIZE_MODE_SWITCHING\n+  no_new_pseudos = 0;\n+  optimize_mode_switching (NULL);\n+  no_new_pseudos = 1;\n+#endif /* OPTIMIZE_MODE_SWITCHING */\n+}\n+\n+\n+struct tree_opt_pass pass_mode_switching =\n+{\n+  NULL,                                 /* name */\n+  gate_mode_switching,                  /* gate */\n+  rest_of_handle_mode_switching,        /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_MODE_SWITCH,                       /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  0,                                    /* todo_flags_finish */\n+  0                                     /* letter */\n+};"}, {"sha": "4b3b90091cb1d97380cf3d43f0f1de0d4ef4732d", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 65, "deletions": 1, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -47,6 +47,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"gcov-io.h\"\n #include \"df.h\"\n #include \"ddg.h\"\n+#include \"timevar.h\"\n+#include \"tree-pass.h\"\n \n #ifdef INSN_SCHEDULING\n \n@@ -2517,5 +2519,67 @@ ps_unschedule_node (partial_schedule_ptr ps, ddg_node_ptr n)\n \n   return remove_node_from_ps (ps, ps_i);\n }\n-#endif /* INSN_SCHEDULING*/\n+#endif /* INSN_SCHEDULING */\n+\f\n+static bool\n+gate_handle_sms (void)\n+{\n+  return (optimize > 0 && flag_modulo_sched);\n+}\n+\n+\n+/* Run instruction scheduler.  */\n+/* Perform SMS module scheduling.  */\n+static void\n+rest_of_handle_sms (void)\n+{\n+#ifdef INSN_SCHEDULING\n+  basic_block bb;\n+  sbitmap blocks;\n+\n+  /* We want to be able to create new pseudos.  */\n+  no_new_pseudos = 0;\n+  /* Collect loop information to be used in SMS.  */\n+  cfg_layout_initialize (CLEANUP_UPDATE_LIFE);\n+  sms_schedule (dump_file);\n+\n+  /* Update the life information, because we add pseudos.  */\n+  max_regno = max_reg_num ();\n+  allocate_reg_info (max_regno, FALSE, FALSE);\n+  blocks = sbitmap_alloc (last_basic_block);\n+  sbitmap_ones (blocks);\n+  update_life_info (blocks, UPDATE_LIFE_GLOBAL_RM_NOTES,\n+                    (PROP_DEATH_NOTES\n+                     | PROP_REG_INFO\n+                     | PROP_KILL_DEAD_CODE\n+                     | PROP_SCAN_DEAD_CODE));\n+\n+  no_new_pseudos = 1;\n+\n+  /* Finalize layout changes.  */\n+  FOR_EACH_BB (bb)\n+    if (bb->next_bb != EXIT_BLOCK_PTR)\n+      bb->aux = bb->next_bb;\n+  cfg_layout_finalize ();\n+  free_dominance_info (CDI_DOMINATORS);\n+#endif /* INSN_SCHEDULING */\n+}\n+\n+struct tree_opt_pass pass_sms =\n+{\n+  \"sms\",                                /* name */\n+  gate_handle_sms,                      /* gate */\n+  rest_of_handle_sms,                   /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_SMS,                               /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func |\n+  TODO_ggc_collect,                     /* todo_flags_finish */\n+  'm'                                   /* letter */\n+};\n "}, {"sha": "195626fa264ad7c6f95c8ecf513aa948f3fd84df", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -38,6 +38,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"tm_p.h\"\t\t/* For OPTIMIZATION_OPTIONS.  */\n #include \"insn-attr.h\"\t\t/* For INSN_SCHEDULING.  */\n #include \"target.h\"\n+#include \"tree-pass.h\"\n \n /* Value of the -G xx switch, and whether it was passed or not.  */\n unsigned HOST_WIDE_INT g_switch_value;"}, {"sha": "67ffffb350deb9e06db3e57da7e2290e4ca5a1fc", "filename": "gcc/passes.c", "status": "modified", "additions": 547, "deletions": 1514, "changes": 2061, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -78,6 +78,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"opts.h\"\n #include \"coverage.h\"\n #include \"value-prof.h\"\n+#include \"tree-inline.h\"\n+#include \"tree-flow.h\"\n #include \"tree-pass.h\"\n #include \"tree-dump.h\"\n \n@@ -98,80 +100,10 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \t\t\t\t   declarations for e.g. AIX 4.x.  */\n #endif\n \n-#ifndef HAVE_conditional_execution\n-#define HAVE_conditional_execution 0\n-#endif\n-\n-/* Format to use to print dumpfile index value */\n-#ifndef DUMPFILE_FORMAT\n-#define DUMPFILE_FORMAT \".%02d.\"\n-#endif\n-\n-static int initializing_dump = 0;\n-\n-/* Routine to open a dump file.  Return true if the dump file is enabled.  */\n-\n-static int\n-open_dump_file (enum tree_dump_index index, tree decl)\n-{\n-  if (! dump_enabled_p (index))\n-    return 0;\n-\n-  timevar_push (TV_DUMP);\n-\n-  gcc_assert (!dump_file && !dump_file_name);\n-\n-  dump_file_name = get_dump_file_name (index);\n-  initializing_dump = !dump_initialized_p (index);\n-  dump_file = dump_begin (index, NULL);\n-\n-  if (dump_file == NULL)\n-    fatal_error (\"can't open %s: %m\", dump_file_name);\n-\n-  if (decl)\n-    fprintf (dump_file, \"\\n;; Function %s%s\\n\\n\",\n-\t     lang_hooks.decl_printable_name (decl, 2),\n-\t     cfun->function_frequency == FUNCTION_FREQUENCY_HOT\n-\t     ? \" (hot)\"\n-\t     : cfun->function_frequency == FUNCTION_FREQUENCY_UNLIKELY_EXECUTED\n-\t     ? \" (unlikely executed)\"\n-\t     : \"\");\n-\n-  timevar_pop (TV_DUMP);\n-  return 1;\n-}\n-\n-/* Routine to close a dump file.  */\n-\n-static void\n-close_dump_file (enum tree_dump_index index,\n-\t\t void (*func) (FILE *, rtx),\n-\t\t rtx insns)\n-{\n-  if (! dump_file)\n-    return;\n-\n-  timevar_push (TV_DUMP);\n-  if (insns\n-      && graph_dump_format != no_graph)\n-    {\n-      /* If we've not initialized the files, do so now.  */\n-      if (initializing_dump)\n-\tclean_graph_dump_file (dump_file_name);\n-\n-      print_rtl_graph_with_bb (dump_file_name, insns);\n-    }\n-\n-  if (func && insns)\n-    func (dump_file, insns);\n+/* Global variables used to communicate with passes.  */\n+int dump_flags;\n+bool in_gimple_form;\n \n-  dump_end (index, dump_file);\n-  free ((char *) dump_file_name);\n-\n-  dump_file = NULL;\n-  dump_file_name = NULL;\n-  timevar_pop (TV_DUMP);\n-}\n \n /* This is called from various places for FUNCTION_DECL, VAR_DECL,\n    and TYPE_DECL nodes.\n@@ -270,1539 +202,640 @@ rest_of_type_compilation (tree type, int toplev)\n   timevar_pop (TV_SYMOUT);\n }\n \n-/* Turn the RTL into assembly.  */\n-static void\n-rest_of_handle_final (void)\n-{\n-  timevar_push (TV_FINAL);\n-  {\n-    rtx x;\n-    const char *fnname;\n-\n-    /* Get the function's name, as described by its RTL.  This may be\n-       different from the DECL_NAME name used in the source file.  */\n-\n-    x = DECL_RTL (current_function_decl);\n-    gcc_assert (MEM_P (x));\n-    x = XEXP (x, 0);\n-    gcc_assert (GET_CODE (x) == SYMBOL_REF);\n-    fnname = XSTR (x, 0);\n-\n-    assemble_start_function (current_function_decl, fnname);\n-    final_start_function (get_insns (), asm_out_file, optimize);\n-    final (get_insns (), asm_out_file, optimize);\n-    final_end_function ();\n-\n-#ifdef TARGET_UNWIND_INFO\n-    /* ??? The IA-64 \".handlerdata\" directive must be issued before\n-       the \".endp\" directive that closes the procedure descriptor.  */\n-    output_function_exception_table ();\n-#endif\n-\n-    assemble_end_function (current_function_decl, fnname);\n-\n-#ifndef TARGET_UNWIND_INFO\n-    /* Otherwise, it feels unclean to switch sections in the middle.  */\n-    output_function_exception_table ();\n-#endif\n-\n-    user_defined_section_attribute = false;\n-\n-    if (! quiet_flag)\n-      fflush (asm_out_file);\n-\n-    /* Release all memory allocated by flow.  */\n-    free_basic_block_vars ();\n-  }\n-\n-  /* Write DBX symbols if requested.  */\n-\n-  /* Note that for those inline functions where we don't initially\n-     know for certain that we will be generating an out-of-line copy,\n-     the first invocation of this routine (rest_of_compilation) will\n-     skip over this code by doing a `goto exit_rest_of_compilation;'.\n-     Later on, wrapup_global_declarations will (indirectly) call\n-     rest_of_compilation again for those inline functions that need\n-     to have out-of-line copies generated.  During that call, we\n-     *will* be routed past here.  */\n-\n-  timevar_push (TV_SYMOUT);\n-  (*debug_hooks->function_decl) (current_function_decl);\n-  timevar_pop (TV_SYMOUT);\n-\n-  ggc_collect ();\n-  timevar_pop (TV_FINAL);\n-}\n+\f\n \n-#ifdef DELAY_SLOTS\n-/* Run delay slot optimization.  */\n-static void\n-rest_of_handle_delay_slots (void)\n+void\n+finish_optimization_passes (void)\n {\n-  timevar_push (TV_DBR_SCHED);\n-  open_dump_file (DFI_dbr, current_function_decl);\n-\n-  dbr_schedule (get_insns (), dump_file);\n-\n-  close_dump_file (DFI_dbr, print_rtl, get_insns ());\n-\n-  ggc_collect ();\n-\n-  timevar_pop (TV_DBR_SCHED);\n-}\n-#endif\n+  enum tree_dump_index i;\n+  struct dump_file_info *dfi;\n+  char *name;\n \n-#ifdef STACK_REGS\n-/* Convert register usage from flat register file usage to a stack\n-   register file.  */\n-static void\n-rest_of_handle_stack_regs (void)\n-{\n-#if defined (HAVE_ATTR_length)\n-  /* If flow2 creates new instructions which need splitting\n-     and scheduling after reload is not done, they might not be\n-     split until final which doesn't allow splitting\n-     if HAVE_ATTR_length.  */\n-#ifdef INSN_SCHEDULING\n-  if (optimize && !flag_schedule_insns_after_reload)\n-#else\n-  if (optimize)\n-#endif\n+  timevar_push (TV_DUMP);\n+  if (profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n     {\n-      timevar_push (TV_SHORTEN_BRANCH);\n-      split_all_insns (1);\n-      timevar_pop (TV_SHORTEN_BRANCH);\n+      dump_file = dump_begin (pass_branch_prob.static_pass_number, NULL);\n+      end_branch_prob ();\n+      if (dump_file)\n+\tdump_end (pass_branch_prob.static_pass_number, dump_file);\n     }\n-#endif\n \n-  timevar_push (TV_REG_STACK);\n-  open_dump_file (DFI_stack, current_function_decl);\n-\n-  if (reg_to_stack (dump_file) && optimize)\n+  if (optimize > 0)\n     {\n-      if (cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_POST_REGSTACK\n-\t\t       | (flag_crossjumping ? CLEANUP_CROSSJUMP : 0))\n-\t  && (flag_reorder_blocks || flag_reorder_blocks_and_partition))\n+      dump_file = dump_begin (pass_combine.static_pass_number, NULL);\n+      if (dump_file)\n \t{\n-\t  reorder_basic_blocks (0);\n-\t  cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_POST_REGSTACK);\n+\t  dump_combine_total_stats (dump_file);\n+          dump_end (pass_combine.static_pass_number, dump_file);\n \t}\n     }\n \n-  close_dump_file (DFI_stack, print_rtl_with_bb, get_insns ());\n+  /* Do whatever is necessary to finish printing the graphs.  */\n+  if (graph_dump_format != no_graph)\n+    for (i = TDI_end; (dfi = get_dump_file_info (i)) != NULL; ++i)\n+      if (dump_initialized_p (i)\n+\t  && (dfi->flags & TDF_RTL) != 0\n+\t  && (name = get_dump_file_name (i)) != NULL)\n+        {\n+          finish_graph_dump_file (name);\n+          free (name);\n+        }\n \n-  ggc_collect ();\n-  timevar_pop (TV_REG_STACK);\n+  timevar_pop (TV_DUMP);\n }\n-#endif\n \n-/* Track the variables, i.e. compute where the variable is stored at each position in function.  */\n-static void\n-rest_of_handle_variable_tracking (void)\n+static bool\n+gate_rest_of_compilation (void)\n {\n-  timevar_push (TV_VAR_TRACKING);\n-  open_dump_file (DFI_vartrack, current_function_decl);\n-\n-  variable_tracking_main ();\n-\n-  close_dump_file (DFI_vartrack, print_rtl_with_bb, get_insns ());\n-  timevar_pop (TV_VAR_TRACKING);\n+  /* Early return if there were errors.  We can run afoul of our\n+     consistency checks, and there's not really much point in fixing them.  */\n+  return !(rtl_dump_and_exit || flag_syntax_only || errorcount || sorrycount);\n }\n \n-/* Machine dependent reorg pass.  */\n-static void\n-rest_of_handle_machine_reorg (void)\n+struct tree_opt_pass pass_rest_of_compilation =\n {\n-  timevar_push (TV_MACH_DEP);\n-  open_dump_file (DFI_mach, current_function_decl);\n-\n-  targetm.machine_dependent_reorg ();\n-\n-  close_dump_file (DFI_mach, print_rtl, get_insns ());\n+  NULL,                                 /* name */\n+  gate_rest_of_compilation,             /* gate */\n+  NULL,                                 /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_REST_OF_COMPILATION,               /* tv_id */\n+  PROP_rtl,                             /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_ggc_collect,                     /* todo_flags_finish */\n+  0                                     /* letter */\n+};\n \n-  ggc_collect ();\n-  timevar_pop (TV_MACH_DEP);\n+static bool\n+gate_postreload (void)\n+{\n+  return reload_completed;\n }\n \n-\n-/* Run old register allocator.  Return TRUE if we must exit\n-   rest_of_compilation upon return.  */\n-static bool\n-rest_of_handle_old_regalloc (void)\n+struct tree_opt_pass pass_postreload =\n {\n-  int failure;\n-  int rebuild_notes;\n+  NULL,                                 /* name */\n+  gate_postreload,                      /* gate */\n+  NULL,                                 /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  0,                                    /* tv_id */\n+  PROP_rtl,                             /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_ggc_collect,                     /* todo_flags_finish */\n+  0\t\t\t\t\t/* letter */\n+};\n \n-  timevar_push (TV_LOCAL_ALLOC);\n-  open_dump_file (DFI_lreg, current_function_decl);\n \n-  /* Allocate the reg_renumber array.  */\n-  allocate_reg_info (max_regno, FALSE, TRUE);\n \n-  /* And the reg_equiv_memory_loc array.  */\n-  VARRAY_GROW (reg_equiv_memory_loc_varray, max_regno);\n-  reg_equiv_memory_loc = &VARRAY_RTX (reg_equiv_memory_loc_varray, 0);\n+/* The root of the compilation pass tree, once constructed.  */\n+struct tree_opt_pass *all_passes, *all_ipa_passes, *all_lowering_passes;\n \n-  allocate_initial_values (reg_equiv_memory_loc);\n+/* Iterate over the pass tree allocating dump file numbers.  We want\n+   to do this depth first, and independent of whether the pass is\n+   enabled or not.  */\n \n-  regclass (get_insns (), max_reg_num (), dump_file);\n-  rebuild_notes = local_alloc ();\n+static void\n+register_one_dump_file (struct tree_opt_pass *pass, bool ipa, int n)\n+{\n+  char *dot_name, *flag_name, *glob_name;\n+  char num[10];\n \n-  timevar_pop (TV_LOCAL_ALLOC);\n+  /* See below in next_pass_1.  */\n+  num[0] = '\\0';\n+  if (pass->static_pass_number != -1)\n+    sprintf (num, \"%d\", ((int) pass->static_pass_number < 0\n+\t\t\t ? 1 : pass->static_pass_number));\n \n-  /* Local allocation may have turned an indirect jump into a direct\n-     jump.  If so, we must rebuild the JUMP_LABEL fields of jumping\n-     instructions.  */\n-  if (rebuild_notes)\n+  dot_name = concat (\".\", pass->name, num, NULL);\n+  if (ipa)\n     {\n-      timevar_push (TV_JUMP);\n-\n-      rebuild_jump_labels (get_insns ());\n-      purge_all_dead_edges ();\n-      delete_unreachable_blocks ();\n-\n-      timevar_pop (TV_JUMP);\n+      flag_name = concat (\"ipa-\", pass->name, num, NULL);\n+      glob_name = concat (\"ipa-\", pass->name, NULL);\n+      /* First IPA dump is cgraph that is dumped via separate channels.  */\n+      pass->static_pass_number = dump_register (dot_name, flag_name, glob_name,\n+                                                TDF_IPA, n + 1, 0);\n     }\n-\n-  if (dump_enabled_p (DFI_lreg))\n+  else if (pass->properties_provided & PROP_trees)\n     {\n-      timevar_push (TV_DUMP);\n-      dump_flow_info (dump_file);\n-      dump_local_alloc (dump_file);\n-      timevar_pop (TV_DUMP);\n+      flag_name = concat (\"tree-\", pass->name, num, NULL);\n+      glob_name = concat (\"tree-\", pass->name, NULL);\n+      pass->static_pass_number = dump_register (dot_name, flag_name, glob_name,\n+                                                TDF_TREE, n + TDI_tree_all, 0);\n     }\n-\n-  close_dump_file (DFI_lreg, print_rtl_with_bb, get_insns ());\n-\n-  ggc_collect ();\n-\n-  timevar_push (TV_GLOBAL_ALLOC);\n-  open_dump_file (DFI_greg, current_function_decl);\n-\n-  /* If optimizing, allocate remaining pseudo-regs.  Do the reload\n-     pass fixing up any insns that are invalid.  */\n-\n-  if (optimize)\n-    failure = global_alloc (dump_file);\n   else\n     {\n-      build_insn_chain (get_insns ());\n-      failure = reload (get_insns (), 0);\n-    }\n-\n-  if (dump_enabled_p (DFI_greg))\n-    {\n-      timevar_push (TV_DUMP);\n-      dump_global_regs (dump_file);\n-      timevar_pop (TV_DUMP);\n-\n-      close_dump_file (DFI_greg, print_rtl_with_bb, get_insns ());\n+      flag_name = concat (\"rtl-\", pass->name, num, NULL);\n+      glob_name = concat (\"rtl-\", pass->name, NULL);\n+      pass->static_pass_number = dump_register (dot_name, flag_name, glob_name,\n+                                                TDF_RTL, n, pass->letter);\n     }\n-\n-  ggc_collect ();\n-\n-  timevar_pop (TV_GLOBAL_ALLOC);\n-\n-  return failure;\n-}\n-\n-/* Run the regrename and cprop passes.  */\n-static void\n-rest_of_handle_regrename (void)\n-{\n-  timevar_push (TV_RENAME_REGISTERS);\n-  open_dump_file (DFI_rnreg, current_function_decl);\n-\n-  if (flag_rename_registers)\n-    regrename_optimize ();\n-  if (flag_cprop_registers)\n-    copyprop_hardreg_forward ();\n-\n-  close_dump_file (DFI_rnreg, print_rtl_with_bb, get_insns ());\n-  timevar_pop (TV_RENAME_REGISTERS);\n-}\n-\n-/* Reorder basic blocks.  */\n-static void\n-rest_of_handle_reorder_blocks (void)\n-{\n-  bool changed;\n-  unsigned int liveness_flags;\n-\n-  open_dump_file (DFI_bbro, current_function_decl);\n-\n-  /* Last attempt to optimize CFG, as scheduling, peepholing and insn\n-     splitting possibly introduced more crossjumping opportunities.  */\n-  liveness_flags = (!HAVE_conditional_execution ? CLEANUP_UPDATE_LIFE : 0);\n-  changed = cleanup_cfg (CLEANUP_EXPENSIVE | liveness_flags);\n-\n-  if (flag_sched2_use_traces && flag_schedule_insns_after_reload)\n-    tracer (liveness_flags);\n-  if (flag_reorder_blocks || flag_reorder_blocks_and_partition)\n-    reorder_basic_blocks (liveness_flags);\n-  if (flag_reorder_blocks || flag_reorder_blocks_and_partition\n-      || (flag_sched2_use_traces && flag_schedule_insns_after_reload))\n-    changed |= cleanup_cfg (CLEANUP_EXPENSIVE | liveness_flags);\n-\n-  /* On conditional execution targets we can not update the life cheaply, so\n-     we deffer the updating to after both cleanups.  This may lose some cases\n-     but should not be terribly bad.  */\n-  if (changed && HAVE_conditional_execution)\n-    update_life_info (NULL, UPDATE_LIFE_GLOBAL_RM_NOTES,\n-\t\t      PROP_DEATH_NOTES);\n-  close_dump_file (DFI_bbro, print_rtl_with_bb, get_insns ());\n-}\n-\n-/* Partition hot and cold basic blocks.  */\n-static void\n-rest_of_handle_partition_blocks (void)\n-{\n-  no_new_pseudos = 0;\n-  partition_hot_cold_basic_blocks ();\n-  allocate_reg_life_data ();\n-  update_life_info (NULL, UPDATE_LIFE_GLOBAL_RM_NOTES, \n-\t\t    PROP_LOG_LINKS | PROP_REG_INFO | PROP_DEATH_NOTES);\n-  no_new_pseudos = 1;\n-}\n-\n-#ifdef INSN_SCHEDULING\n-/* Run instruction scheduler.  */\n-/* Perform SMS module scheduling.  */\n-static void\n-rest_of_handle_sms (void)\n-{\n-  basic_block bb;\n-  sbitmap blocks;\n-\n-  timevar_push (TV_SMS);\n-  open_dump_file (DFI_sms, current_function_decl);\n-\n-  /* We want to be able to create new pseudos.  */\n-  no_new_pseudos = 0;\n-  /* Collect loop information to be used in SMS.  */\n-  cfg_layout_initialize (CLEANUP_UPDATE_LIFE);\n-  sms_schedule (dump_file);\n-  close_dump_file (DFI_sms, print_rtl, get_insns ());\n-\n-  /* Update the life information, because we add pseudos.  */\n-  max_regno = max_reg_num ();\n-  allocate_reg_info (max_regno, FALSE, FALSE);\n-  blocks = sbitmap_alloc (last_basic_block);\n-  sbitmap_ones (blocks);\n-  update_life_info (blocks, UPDATE_LIFE_GLOBAL_RM_NOTES,\n-\t\t    (PROP_DEATH_NOTES\n-\t\t     | PROP_REG_INFO\n-\t\t     | PROP_KILL_DEAD_CODE\n-\t\t     | PROP_SCAN_DEAD_CODE));\n-\n-  no_new_pseudos = 1;\n-\n-  /* Finalize layout changes.  */\n-  FOR_EACH_BB (bb)\n-    if (bb->next_bb != EXIT_BLOCK_PTR)\n-      bb->aux = bb->next_bb;\n-  cfg_layout_finalize ();\n-  free_dominance_info (CDI_DOMINATORS);\n-  ggc_collect ();\n-  timevar_pop (TV_SMS);\n }\n \n-/* Run instruction scheduler.  */\n-static void\n-rest_of_handle_sched (void)\n+static int \n+register_dump_files (struct tree_opt_pass *pass, bool ipa, int properties)\n {\n-  timevar_push (TV_SCHED);\n-\n-  /* Print function header into sched dump now\n-     because doing the sched analysis makes some of the dump.  */\n-  open_dump_file (DFI_sched, current_function_decl);\n-\n-  /* Do control and data sched analysis,\n-     and write some of the results to dump file.  */\n+  static int n = 0;\n+  do\n+    {\n+      int new_properties;\n+      int pass_number;\n \n-  schedule_insns (dump_file);\n+      pass->properties_required = properties;\n+      new_properties =\n+        (properties | pass->properties_provided) & ~pass->properties_destroyed;\n \n-  close_dump_file (DFI_sched, print_rtl_with_bb, get_insns ());\n+      /* Reset the counter when we reach RTL-based passes.  */\n+      if ((new_properties ^ pass->properties_required) & PROP_rtl)\n+        n = 0;\n \n-  ggc_collect ();\n-  timevar_pop (TV_SCHED);\n-}\n+      pass_number = n;\n+      if (pass->name)\n+        n++;\n \n-/* Run second scheduling pass after reload.  */\n-static void\n-rest_of_handle_sched2 (void)\n-{\n-  timevar_push (TV_SCHED2);\n-  open_dump_file (DFI_sched2, current_function_decl);\n+      if (pass->sub)\n+        new_properties = register_dump_files (pass->sub, false, new_properties);\n \n-  /* Do control and data sched analysis again,\n-     and write some more of the results to dump file.  */\n+      /* If we have a gate, combine the properties that we could have with\n+         and without the pass being examined.  */\n+      if (pass->gate)\n+        properties &= new_properties;\n+      else\n+        properties = new_properties;\n \n-  split_all_insns (1);\n+      pass->properties_provided = properties;\n+      if (pass->name)\n+        register_one_dump_file (pass, ipa, pass_number);\n \n-  if (flag_sched2_use_superblocks || flag_sched2_use_traces)\n-    {\n-      schedule_ebbs (dump_file);\n-      /* No liveness updating code yet, but it should be easy to do.\n-\t reg-stack recomputes the liveness when needed for now.  */\n-      count_or_remove_death_notes (NULL, 1);\n-      cleanup_cfg (CLEANUP_EXPENSIVE);\n+      pass = pass->next;\n     }\n-  else\n-    schedule_insns (dump_file);\n+  while (pass);\n \n-  close_dump_file (DFI_sched2, print_rtl_with_bb, get_insns ());\n-\n-  ggc_collect ();\n-\n-  timevar_pop (TV_SCHED2);\n+  return properties;\n }\n-#endif\n-\n-static void\n-rest_of_handle_gcse2 (void)\n-{\n-  timevar_push (TV_GCSE_AFTER_RELOAD);\n-  open_dump_file (DFI_gcse2, current_function_decl);\n-\n-  gcse_after_reload_main (get_insns ());\n-  rebuild_jump_labels (get_insns ());\n-  delete_trivially_dead_insns (get_insns (), max_reg_num ());\n-  close_dump_file (DFI_gcse2, print_rtl_with_bb, get_insns ());\n-\n-  ggc_collect ();\n \n-#ifdef ENABLE_CHECKING\n-  verify_flow_info ();\n-#endif\n-\n-  timevar_pop (TV_GCSE_AFTER_RELOAD);\n-}\n+/* Add a pass to the pass list. Duplicate the pass if it's already\n+   in the list.  */\n \n-/* Register allocation pre-pass, to reduce number of moves necessary\n-   for two-address machines.  */\n-static void\n-rest_of_handle_regmove (void)\n+static struct tree_opt_pass **\n+next_pass_1 (struct tree_opt_pass **list, struct tree_opt_pass *pass)\n {\n-  timevar_push (TV_REGMOVE);\n-  open_dump_file (DFI_regmove, current_function_decl);\n \n-  regmove_optimize (get_insns (), max_reg_num (), dump_file);\n-\n-  cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE);\n-  close_dump_file (DFI_regmove, print_rtl_with_bb, get_insns ());\n+  /* A nonzero static_pass_number indicates that the\n+     pass is already in the list.  */\n+  if (pass->static_pass_number)\n+    {\n+      struct tree_opt_pass *new;\n \n-  ggc_collect ();\n-  timevar_pop (TV_REGMOVE);\n-}\n+      new = xmalloc (sizeof (*new));\n+      memcpy (new, pass, sizeof (*new));\n \n-/* Run tracer.  */\n-static void\n-rest_of_handle_tracer (void)\n-{\n-  open_dump_file (DFI_tracer, current_function_decl);\n-  if (dump_file)\n-    dump_flow_info (dump_file);\n-  tracer (0);\n-  cleanup_cfg (CLEANUP_EXPENSIVE);\n-  reg_scan (get_insns (), max_reg_num ());\n-  close_dump_file (DFI_tracer, print_rtl_with_bb, get_insns ());\n+      /* Indicate to register_dump_files that this pass has duplicates,\n+         and so it should rename the dump file.  The first instance will\n+         be -1, and be number of duplicates = -static_pass_number - 1.\n+         Subsequent instances will be > 0 and just the duplicate number.  */\n+      if (pass->name)\n+        {\n+          pass->static_pass_number -= 1;\n+          new->static_pass_number = -pass->static_pass_number;\n+\t}\n+      \n+      *list = new;\n+    }\n+  else\n+    {\n+      pass->static_pass_number = -1;\n+      *list = pass;\n+    }  \n+  \n+  return &(*list)->next;\n+          \n }\n \n-/* If-conversion and CFG cleanup.  */\n-static void\n-rest_of_handle_if_conversion (void)\n-{\n-  timevar_push (TV_IFCVT);\n-  open_dump_file (DFI_ce1, current_function_decl);\n+/* Construct the pass tree.  */\n \n-  if (flag_if_conversion)\n+void\n+init_optimization_passes (void)\n+{\n+  struct tree_opt_pass **p;\n+\n+#define NEXT_PASS(PASS)  (p = next_pass_1 (p, &PASS))\n+  /* Interprocedural optimization passes.  */\n+  p = &all_ipa_passes;\n+  NEXT_PASS (pass_early_ipa_inline);\n+  NEXT_PASS (pass_early_local_passes);\n+  NEXT_PASS (pass_ipa_inline);\n+  *p = NULL;\n+\n+  /* All passes needed to lower the function into shape optimizers can operate\n+     on.  These passes are performed before interprocedural passes, unlike rest\n+     of local passes (all_passes).  */\n+  p = &all_lowering_passes;\n+  NEXT_PASS (pass_remove_useless_stmts);\n+  NEXT_PASS (pass_mudflap_1);\n+  NEXT_PASS (pass_lower_cf);\n+  NEXT_PASS (pass_lower_eh);\n+  NEXT_PASS (pass_build_cfg);\n+  NEXT_PASS (pass_lower_complex_O0);\n+  NEXT_PASS (pass_lower_vector);\n+  NEXT_PASS (pass_warn_function_return);\n+  NEXT_PASS (pass_early_tree_profile);\n+  *p = NULL;\n+\n+  p = &pass_early_local_passes.sub;\n+  NEXT_PASS (pass_tree_profile);\n+  NEXT_PASS (pass_cleanup_cfg);\n+  NEXT_PASS (pass_rebuild_cgraph_edges);\n+  *p = NULL;\n+\n+  p = &all_passes;\n+  NEXT_PASS (pass_fixup_cfg);\n+  NEXT_PASS (pass_init_datastructures);\n+  NEXT_PASS (pass_all_optimizations);\n+  NEXT_PASS (pass_warn_function_noreturn);\n+  NEXT_PASS (pass_mudflap_2);\n+  NEXT_PASS (pass_free_datastructures);\n+  NEXT_PASS (pass_free_cfg_annotations);\n+  NEXT_PASS (pass_expand);\n+  NEXT_PASS (pass_rest_of_compilation);\n+  NEXT_PASS (pass_clean_state);\n+  *p = NULL;\n+\n+  p = &pass_all_optimizations.sub;\n+  NEXT_PASS (pass_referenced_vars);\n+  NEXT_PASS (pass_create_structure_vars);\n+  NEXT_PASS (pass_build_ssa);\n+  NEXT_PASS (pass_build_pta);\n+  NEXT_PASS (pass_may_alias);\n+  NEXT_PASS (pass_return_slot);\n+  NEXT_PASS (pass_del_pta);\n+  NEXT_PASS (pass_rename_ssa_copies);\n+  NEXT_PASS (pass_early_warn_uninitialized);\n+\n+  /* Initial scalar cleanups.  */\n+  NEXT_PASS (pass_ccp);\n+  NEXT_PASS (pass_fre);\n+  NEXT_PASS (pass_dce);\n+  NEXT_PASS (pass_forwprop);\n+  NEXT_PASS (pass_copy_prop);\n+  NEXT_PASS (pass_vrp);\n+  NEXT_PASS (pass_dce);\n+  NEXT_PASS (pass_merge_phi);\n+  NEXT_PASS (pass_dominator);\n+\n+  NEXT_PASS (pass_phiopt);\n+  NEXT_PASS (pass_build_pta);\n+  NEXT_PASS (pass_may_alias);\n+  NEXT_PASS (pass_del_pta);\n+  NEXT_PASS (pass_tail_recursion);\n+  NEXT_PASS (pass_profile);\n+  NEXT_PASS (pass_ch);\n+  NEXT_PASS (pass_stdarg);\n+  NEXT_PASS (pass_lower_complex);\n+  NEXT_PASS (pass_sra);\n+  /* FIXME: SRA may generate arbitrary gimple code, exposing new\n+     aliased and call-clobbered variables.  As mentioned below,\n+     pass_may_alias should be a TODO item.  */\n+  NEXT_PASS (pass_may_alias);\n+  NEXT_PASS (pass_rename_ssa_copies);\n+  NEXT_PASS (pass_dominator);\n+  NEXT_PASS (pass_copy_prop);\n+  NEXT_PASS (pass_dce);\n+  NEXT_PASS (pass_dse);\n+  NEXT_PASS (pass_may_alias);\n+  NEXT_PASS (pass_forwprop);\n+  NEXT_PASS (pass_phiopt);\n+  NEXT_PASS (pass_object_sizes);\n+  NEXT_PASS (pass_store_ccp);\n+  NEXT_PASS (pass_store_copy_prop);\n+  NEXT_PASS (pass_fold_builtins);\n+  /* FIXME: May alias should a TODO but for 4.0.0,\n+     we add may_alias right after fold builtins\n+     which can create arbitrary GIMPLE.  */\n+  NEXT_PASS (pass_may_alias);\n+  NEXT_PASS (pass_cse_reciprocals);\n+  NEXT_PASS (pass_split_crit_edges);\n+  NEXT_PASS (pass_reassoc);\n+  NEXT_PASS (pass_pre);\n+  NEXT_PASS (pass_sink_code);\n+  NEXT_PASS (pass_loop);\n+  NEXT_PASS (pass_dominator);\n+  NEXT_PASS (pass_copy_prop);\n+  NEXT_PASS (pass_cd_dce);\n+\n+  /* FIXME: If DCE is not run before checking for uninitialized uses,\n+     we may get false warnings (e.g., testsuite/gcc.dg/uninit-5.c).\n+     However, this also causes us to misdiagnose cases that should be\n+     real warnings (e.g., testsuite/gcc.dg/pr18501.c).\n+     \n+     To fix the false positives in uninit-5.c, we would have to\n+     account for the predicates protecting the set and the use of each\n+     variable.  Using a representation like Gated Single Assignment\n+     may help.  */\n+  NEXT_PASS (pass_late_warn_uninitialized);\n+  NEXT_PASS (pass_dse);\n+  NEXT_PASS (pass_forwprop);\n+  NEXT_PASS (pass_phiopt);\n+  NEXT_PASS (pass_tail_calls);\n+  NEXT_PASS (pass_rename_ssa_copies);\n+  NEXT_PASS (pass_uncprop);\n+  NEXT_PASS (pass_del_ssa);\n+  NEXT_PASS (pass_nrv);\n+  NEXT_PASS (pass_remove_useless_vars);\n+  NEXT_PASS (pass_mark_used_blocks);\n+  NEXT_PASS (pass_cleanup_cfg_post_optimizing);\n+  *p = NULL;\n+\n+  p = &pass_loop.sub;\n+  NEXT_PASS (pass_loop_init);\n+  NEXT_PASS (pass_copy_prop);\n+  NEXT_PASS (pass_lim);\n+  NEXT_PASS (pass_unswitch);\n+  NEXT_PASS (pass_scev_cprop);\n+  NEXT_PASS (pass_record_bounds);\n+  NEXT_PASS (pass_linear_transform);\n+  NEXT_PASS (pass_iv_canon);\n+  NEXT_PASS (pass_if_conversion);\n+  NEXT_PASS (pass_vectorize);\n+  /* NEXT_PASS (pass_may_alias) cannot be done again because the\n+     vectorizer creates alias relations that are not supported by\n+     pass_may_alias.  */\n+  NEXT_PASS (pass_lower_vector_ssa);\n+  NEXT_PASS (pass_complete_unroll);\n+  NEXT_PASS (pass_iv_optimize);\n+  NEXT_PASS (pass_loop_done);\n+  *p = NULL;\n+\n+  p = &pass_rest_of_compilation.sub;\n+  NEXT_PASS (pass_remove_unnecessary_notes);\n+  NEXT_PASS (pass_init_function);\n+  NEXT_PASS (pass_jump);\n+  NEXT_PASS (pass_insn_locators_initialize);\n+  NEXT_PASS (pass_rtl_eh);\n+  NEXT_PASS (pass_initial_value_sets);\n+  NEXT_PASS (pass_unshare_all_rtl);\n+  NEXT_PASS (pass_instantiate_virtual_regs);\n+  NEXT_PASS (pass_jump2);\n+  NEXT_PASS (pass_cse);\n+  NEXT_PASS (pass_gcse);\n+  NEXT_PASS (pass_loop_optimize);\n+  NEXT_PASS (pass_jump_bypass);\n+  NEXT_PASS (pass_cfg);\n+  NEXT_PASS (pass_profiling);\n+  NEXT_PASS (pass_rtl_ifcvt);\n+  NEXT_PASS (pass_tracer);\n+  NEXT_PASS (pass_loop2);\n+  NEXT_PASS (pass_web);\n+  NEXT_PASS (pass_cse2);\n+  NEXT_PASS (pass_life);\n+  NEXT_PASS (pass_combine);\n+  NEXT_PASS (pass_if_after_combine);\n+  NEXT_PASS (pass_partition_blocks);\n+  NEXT_PASS (pass_regmove);\n+  NEXT_PASS (pass_split_all_insns);\n+  NEXT_PASS (pass_mode_switching);\n+  NEXT_PASS (pass_recompute_reg_usage);\n+  NEXT_PASS (pass_sms);\n+  NEXT_PASS (pass_sched);\n+  NEXT_PASS (pass_local_alloc);\n+  NEXT_PASS (pass_global_alloc);\n+  NEXT_PASS (pass_postreload);\n+  *p = NULL;\n+\n+  p = &pass_profiling.sub;\n+  NEXT_PASS (pass_branch_prob);\n+  NEXT_PASS (pass_value_profile_transformations);\n+  NEXT_PASS (pass_remove_death_notes);\n+  *p = NULL;\n+\n+  p = &pass_postreload.sub;\n+  NEXT_PASS (pass_postreload_cse);\n+  NEXT_PASS (pass_gcse2);\n+  NEXT_PASS (pass_flow2);\n+  NEXT_PASS (pass_stack_adjustments);\n+  NEXT_PASS (pass_peephole2);\n+  NEXT_PASS (pass_if_after_reload);\n+  NEXT_PASS (pass_regrename);\n+  NEXT_PASS (pass_reorder_blocks);\n+  NEXT_PASS (pass_branch_target_load_optimize);\n+  NEXT_PASS (pass_leaf_regs);\n+  NEXT_PASS (pass_sched2);\n+  NEXT_PASS (pass_split_before_regstack);\n+  NEXT_PASS (pass_stack_regs);\n+  NEXT_PASS (pass_compute_alignments);\n+  NEXT_PASS (pass_duplicate_computed_gotos);\n+  NEXT_PASS (pass_variable_tracking);\n+  NEXT_PASS (pass_free_cfg);\n+  NEXT_PASS (pass_machine_reorg);\n+  NEXT_PASS (pass_purge_lineno_notes);\n+  NEXT_PASS (pass_cleanup_barriers);\n+  NEXT_PASS (pass_delay_slots);\n+  NEXT_PASS (pass_split_for_shorten_branches);\n+  NEXT_PASS (pass_convert_to_eh_region_ranges);\n+  NEXT_PASS (pass_shorten_branches);\n+  NEXT_PASS (pass_set_nothrow_function_flags);\n+  NEXT_PASS (pass_final);\n+  *p = NULL;\n+\n+#undef NEXT_PASS\n+\n+  /* Register the passes with the tree dump code.  */\n+  register_dump_files (all_lowering_passes, false, PROP_gimple_any);\n+  register_dump_files (all_passes, false, PROP_gimple_leh\n+\t\t\t\t\t  | PROP_cfg);\n+  register_dump_files (all_ipa_passes, true, PROP_gimple_leh\n+\t\t\t\t\t     | PROP_cfg);\n+}\n+\n+static unsigned int last_verified;\n+\n+static void\n+execute_todo (struct tree_opt_pass *pass, unsigned int flags, bool use_required)\n+{\n+  int properties \n+    = use_required ? pass->properties_required : pass->properties_provided;\n+\n+#if defined ENABLE_CHECKING\n+  if (need_ssa_update_p ())\n+    gcc_assert (flags & TODO_update_ssa_any);\n+#endif\n+\n+  if (flags & TODO_update_ssa_any)\n     {\n-      if (dump_file)\n-\tdump_flow_info (dump_file);\n-      cleanup_cfg (CLEANUP_EXPENSIVE);\n-      reg_scan (get_insns (), max_reg_num ());\n-      if_convert (0);\n+      unsigned update_flags = flags & TODO_update_ssa_any;\n+      update_ssa (update_flags);\n     }\n \n-  timevar_push (TV_JUMP);\n-  cleanup_cfg (CLEANUP_EXPENSIVE);\n-  reg_scan (get_insns (), max_reg_num ());\n-  timevar_pop (TV_JUMP);\n-\n-  close_dump_file (DFI_ce1, print_rtl_with_bb, get_insns ());\n-  timevar_pop (TV_IFCVT);\n-}\n-\n-/* Rerun if-conversion, as combine may have simplified things enough\n-   to now meet sequence length restrictions.  */\n-static void\n-rest_of_handle_if_after_combine (void)\n-{\n-  timevar_push (TV_IFCVT);\n-  open_dump_file (DFI_ce2, current_function_decl);\n-\n-  no_new_pseudos = 0;\n-  if_convert (1);\n-  no_new_pseudos = 1;\n+  if (flags & TODO_cleanup_cfg)\n+    {\n+      if (current_loops)\n+\tcleanup_tree_cfg_loop ();\n+      else\n+\tcleanup_tree_cfg ();\n+    }\n \n-  close_dump_file (DFI_ce2, print_rtl_with_bb, get_insns ());\n-  timevar_pop (TV_IFCVT);\n-}\n+  if ((flags & TODO_dump_func)\n+      && dump_file && current_function_decl)\n+    {\n+      if (properties & PROP_trees)\n+        dump_function_to_file (current_function_decl,\n+                               dump_file, dump_flags);\n+      else if (properties & PROP_cfg)\n+        print_rtl_with_bb (dump_file, get_insns ());\n+      else\n+        print_rtl (dump_file, get_insns ());\n+\n+      /* Flush the file.  If verification fails, we won't be able to\n+\t close the file before aborting.  */\n+      fflush (dump_file);\n+    }\n+  if ((flags & TODO_dump_cgraph)\n+      && dump_file && !current_function_decl)\n+    {\n+      dump_cgraph (dump_file);\n+      /* Flush the file.  If verification fails, we won't be able to\n+\t close the file before aborting.  */\n+      fflush (dump_file);\n+    }\n \n-static void\n-rest_of_handle_if_after_reload (void)\n-{\n-  timevar_push (TV_IFCVT2);\n-  open_dump_file (DFI_ce3, current_function_decl);\n-\n-  /* Last attempt to optimize CFG, as scheduling, peepholing and insn\n-     splitting possibly introduced more crossjumping opportunities.  */\n-  cleanup_cfg (CLEANUP_EXPENSIVE\n-\t       | CLEANUP_UPDATE_LIFE \n-\t       | (flag_crossjumping ? CLEANUP_CROSSJUMP : 0));\n-  if (flag_if_conversion2)\n-    if_convert (1);\n-  close_dump_file (DFI_ce3, print_rtl_with_bb, get_insns ());\n-  timevar_pop (TV_IFCVT2);\n-}\n+  if (flags & TODO_ggc_collect)\n+    {\n+      ggc_collect ();\n+    }\n \n-static void\n-rest_of_handle_web (void)\n-{\n-  open_dump_file (DFI_web, current_function_decl);\n-  timevar_push (TV_WEB);\n-  web_main ();\n-  delete_trivially_dead_insns (get_insns (), max_reg_num ());\n-  cleanup_cfg (CLEANUP_EXPENSIVE);\n-\n-  timevar_pop (TV_WEB);\n-  close_dump_file (DFI_web, print_rtl_with_bb, get_insns ());\n-  reg_scan (get_insns (), max_reg_num ());\n+#if defined ENABLE_CHECKING\n+  if ((pass->properties_required & PROP_ssa)\n+      && !(pass->properties_destroyed & PROP_ssa))\n+    verify_ssa (true);\n+  if (flags & TODO_verify_flow)\n+    verify_flow_info ();\n+  if (flags & TODO_verify_stmts)\n+    verify_stmts ();\n+  if (flags & TODO_verify_loops)\n+    verify_loop_closed_ssa ();\n+#endif\n }\n \n-/* Do branch profiling and static profile estimation passes.  */\n-static void\n-rest_of_handle_branch_prob (void)\n+static bool\n+execute_one_pass (struct tree_opt_pass *pass)\n {\n-  struct loops loops;\n+  unsigned int todo; \n \n-  timevar_push (TV_BRANCH_PROB);\n-  open_dump_file (DFI_bp, current_function_decl);\n+  /* See if we're supposed to run this pass.  */\n+  if (pass->gate && !pass->gate ())\n+    return false;\n \n-  if ((profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n-      && !flag_tree_based_profiling)\n-    branch_prob ();\n+  /* Note that the folders should only create gimple expressions.\n+     This is a hack until the new folder is ready.  */\n+  in_gimple_form = (pass->properties_provided & PROP_trees) != 0;\n \n-  /* Discover and record the loop depth at the head of each basic\n-     block.  The loop infrastructure does the real job for us.  */\n-  flow_loops_find (&loops);\n+  /* Run pre-pass verification.  */\n+  todo = pass->todo_flags_start & ~last_verified;\n+  if (todo)\n+    execute_todo (pass, todo, true);\n \n-  if (dump_file)\n-    flow_loops_dump (&loops, dump_file, NULL, 0);\n+  /* If a dump file name is present, open it if enabled.  */\n+  if (pass->static_pass_number != -1)\n+    {\n+      bool initializing_dump = !dump_initialized_p (pass->static_pass_number);\n+      dump_file_name = get_dump_file_name (pass->static_pass_number);\n+      dump_file = dump_begin (pass->static_pass_number, &dump_flags);\n+      if (dump_file && current_function_decl)\n+\t{\n+\t  const char *dname, *aname;\n+\t  dname = lang_hooks.decl_printable_name (current_function_decl, 2);\n+\t  aname = (IDENTIFIER_POINTER\n+\t\t   (DECL_ASSEMBLER_NAME (current_function_decl)));\n+\t  fprintf (dump_file, \"\\n;; Function %s (%s)%s\\n\\n\", dname, aname,\n+\t     cfun->function_frequency == FUNCTION_FREQUENCY_HOT\n+\t     ? \" (hot)\"\n+\t     : cfun->function_frequency == FUNCTION_FREQUENCY_UNLIKELY_EXECUTED\n+\t     ? \" (unlikely executed)\"\n+\t     : \"\");\n+\t}\n \n-  /* Estimate using heuristics if no profiling info is available.  */\n-  if (flag_guess_branch_prob && profile_status == PROFILE_ABSENT)\n-    estimate_probability (&loops);\n+      if (initializing_dump\n+          && graph_dump_format != no_graph\n+\t  && (pass->properties_provided & (PROP_cfg | PROP_rtl))\n+\t      == (PROP_cfg | PROP_rtl))\n+        clean_graph_dump_file (dump_file_name);\n+    }\n \n-  flow_loops_free (&loops);\n-  free_dominance_info (CDI_DOMINATORS);\n-  close_dump_file (DFI_bp, print_rtl_with_bb, get_insns ());\n-  timevar_pop (TV_BRANCH_PROB);\n-}\n+  /* If a timevar is present, start it.  */\n+  if (pass->tv_id)\n+    timevar_push (pass->tv_id);\n \n-/* Do optimizations based on expression value profiles.  */\n-static void\n-rest_of_handle_value_profile_transformations (void)\n-{\n-  open_dump_file (DFI_vpt, current_function_decl);\n-  timevar_push (TV_VPT);\n+  /* Do it!  */\n+  if (pass->execute)\n+    pass->execute ();\n \n-  if (value_profile_transformations ())\n-    cleanup_cfg (CLEANUP_EXPENSIVE);\n+  /* Stop timevar.  */\n+  if (pass->tv_id)\n+    timevar_pop (pass->tv_id);\n \n-  timevar_pop (TV_VPT);\n-  close_dump_file (DFI_vpt, print_rtl_with_bb, get_insns ());\n-}\n+  /* Run post-pass cleanup and verification.  */\n+  todo = pass->todo_flags_finish;\n+  last_verified = todo & TODO_verify_all;\n+  if (todo)\n+    execute_todo (pass, todo, false);\n \n-/* Do control and data flow analysis; write some of the results to the\n-   dump file.  */\n-static void\n-rest_of_handle_cfg (void)\n-{\n-  open_dump_file (DFI_cfg, current_function_decl);\n-  if (dump_file)\n-    dump_flow_info (dump_file);\n-  if (optimize)\n-    cleanup_cfg (CLEANUP_EXPENSIVE\n-\t\t | (flag_thread_jumps ? CLEANUP_THREADING : 0));\n-\n-  /* It may make more sense to mark constant functions after dead code is\n-     eliminated by life_analysis, but we need to do it early, as -fprofile-arcs\n-     may insert code making function non-constant, but we still must consider\n-     it as constant, otherwise -fbranch-probabilities will not read data back.\n-\n-     life_analysis rarely eliminates modification of external memory.\n-\n-     FIXME: now with tree based profiling we are in the trap described above\n-     again.  It seems to be easiest to disable the optimization for time\n-     being before the problem is either solved by moving the transformation\n-     to the IPA level (we need the CFG for this) or the very early optimization\n-     passes are made to ignore the const/pure flags so code does not change.  */\n-  if (optimize\n-      && (!flag_tree_based_profiling\n-\t  || (!profile_arc_flag && !flag_branch_probabilities)))\n+  /* Flush and close dump file.  */\n+  if (dump_file_name)\n     {\n-      /* Alias analysis depends on this information and mark_constant_function\n-       depends on alias analysis.  */\n-      reg_scan (get_insns (), max_reg_num ());\n-      mark_constant_function ();\n+      free ((char *) dump_file_name);\n+      dump_file_name = NULL;\n     }\n-\n-  close_dump_file (DFI_cfg, print_rtl_with_bb, get_insns ());\n-}\n-\n-/* Perform jump bypassing and control flow optimizations.  */\n-static void\n-rest_of_handle_jump_bypass (void)\n-{\n-  timevar_push (TV_BYPASS);\n-  open_dump_file (DFI_bypass, current_function_decl);\n-\n-  cleanup_cfg (CLEANUP_EXPENSIVE);\n-  reg_scan (get_insns (), max_reg_num ());\n-\n-  if (bypass_jumps (dump_file))\n+  if (dump_file)\n     {\n-      rebuild_jump_labels (get_insns ());\n-      cleanup_cfg (CLEANUP_EXPENSIVE);\n-      delete_trivially_dead_insns (get_insns (), max_reg_num ());\n+      dump_end (pass->static_pass_number, dump_file);\n+      dump_file = NULL;\n     }\n \n-  close_dump_file (DFI_bypass, print_rtl_with_bb, get_insns ());\n-  timevar_pop (TV_BYPASS);\n-\n-  ggc_collect ();\n-\n-#ifdef ENABLE_CHECKING\n-  verify_flow_info ();\n-#endif\n+  return true;\n }\n \n-/* Try combining insns through substitution.  */\n-static void\n-rest_of_handle_combine (void)\n+void\n+execute_pass_list (struct tree_opt_pass *pass)\n {\n-  int rebuild_jump_labels_after_combine = 0;\n-\n-  timevar_push (TV_COMBINE);\n-  open_dump_file (DFI_combine, current_function_decl);\n-\n-  rebuild_jump_labels_after_combine\n-    = combine_instructions (get_insns (), max_reg_num ());\n-\n-  /* Combining insns may have turned an indirect jump into a\n-     direct jump.  Rebuild the JUMP_LABEL fields of jumping\n-     instructions.  */\n-  if (rebuild_jump_labels_after_combine)\n+  do\n     {\n-      timevar_push (TV_JUMP);\n-      rebuild_jump_labels (get_insns ());\n-      timevar_pop (TV_JUMP);\n-\n-      delete_dead_jumptables ();\n-      cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE);\n+      if (execute_one_pass (pass) && pass->sub)\n+        execute_pass_list (pass->sub);\n+      pass = pass->next;\n     }\n-\n-  close_dump_file (DFI_combine, print_rtl_with_bb, get_insns ());\n-  timevar_pop (TV_COMBINE);\n-\n-  ggc_collect ();\n+  while (pass);\n }\n \n-/* Perform life analysis.  */\n-static void\n-rest_of_handle_life (void)\n+/* Same as execute_pass_list but assume that subpasses of IPA passes\n+   are local passes.  */\n+void\n+execute_ipa_pass_list (struct tree_opt_pass *pass)\n {\n-  open_dump_file (DFI_life, current_function_decl);\n-  regclass_init ();\n-\n-#ifdef ENABLE_CHECKING\n-  verify_flow_info ();\n-#endif\n-  life_analysis (dump_file, PROP_FINAL);\n-  if (optimize)\n-    cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE | CLEANUP_LOG_LINKS\n-\t\t | (flag_thread_jumps ? CLEANUP_THREADING : 0));\n-\n-  if (extra_warnings)\n-    {\n-      setjmp_vars_warning (DECL_INITIAL (current_function_decl));\n-      setjmp_args_warning ();\n-    }\n-\n-  if (optimize)\n+  do\n     {\n-      if (initialize_uninitialized_subregs ())\n+      if (execute_one_pass (pass) && pass->sub)\n \t{\n-\t  /* Insns were inserted, and possibly pseudos created, so\n-\t     things might look a bit different.  */\n-\t  allocate_reg_life_data ();\n-\t  update_life_info (NULL, UPDATE_LIFE_GLOBAL_RM_NOTES,\n-\t\t\t    PROP_LOG_LINKS | PROP_REG_INFO | PROP_DEATH_NOTES);\n+\t  struct cgraph_node *node;\n+\t  for (node = cgraph_nodes; node; node = node->next)\n+\t    if (node->analyzed)\n+\t      {\n+\t\tpush_cfun (DECL_STRUCT_FUNCTION (node->decl));\n+\t\tcurrent_function_decl = node->decl;\n+\t\texecute_pass_list (pass->sub);\n+\t\tfree_dominance_info (CDI_DOMINATORS);\n+\t\tfree_dominance_info (CDI_POST_DOMINATORS);\n+\t\tcurrent_function_decl = NULL;\n+\t\tpop_cfun ();\n+\t\tggc_collect ();\n+\t      }\n \t}\n+      pass = pass->next;\n     }\n-\n-  no_new_pseudos = 1;\n-\n-  close_dump_file (DFI_life, print_rtl_with_bb, get_insns ());\n-\n-  ggc_collect ();\n-}\n-\n-/* Perform common subexpression elimination.  Nonzero value from\n-   `cse_main' means that jumps were simplified and some code may now\n-   be unreachable, so do jump optimization again.  */\n-static void\n-rest_of_handle_cse (void)\n-{\n-  int tem;\n-\n-  open_dump_file (DFI_cse, current_function_decl);\n-  if (dump_file)\n-    dump_flow_info (dump_file);\n-  timevar_push (TV_CSE);\n-\n-  reg_scan (get_insns (), max_reg_num ());\n-\n-  tem = cse_main (get_insns (), max_reg_num (), dump_file);\n-  if (tem)\n-    rebuild_jump_labels (get_insns ());\n-  if (purge_all_dead_edges ())\n-    delete_unreachable_blocks ();\n-\n-  delete_trivially_dead_insns (get_insns (), max_reg_num ());\n-\n-  /* If we are not running more CSE passes, then we are no longer\n-     expecting CSE to be run.  But always rerun it in a cheap mode.  */\n-  cse_not_expected = !flag_rerun_cse_after_loop && !flag_gcse;\n-\n-  if (tem)\n-    delete_dead_jumptables ();\n-\n-  if (tem || optimize > 1)\n-    cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n-\n-  timevar_pop (TV_CSE);\n-  close_dump_file (DFI_cse, print_rtl_with_bb, get_insns ());\n-\n-  ggc_collect ();\n-}\n-\n-/* Run second CSE pass after loop optimizations.  */\n-static void\n-rest_of_handle_cse2 (void)\n-{\n-  int tem;\n-\n-  timevar_push (TV_CSE2);\n-  open_dump_file (DFI_cse2, current_function_decl);\n-  if (dump_file)\n-    dump_flow_info (dump_file);\n-\n-  tem = cse_main (get_insns (), max_reg_num (), dump_file);\n-\n-  /* Run a pass to eliminate duplicated assignments to condition code\n-     registers.  We have to run this after bypass_jumps, because it\n-     makes it harder for that pass to determine whether a jump can be\n-     bypassed safely.  */\n-  cse_condition_code_reg ();\n-\n-  purge_all_dead_edges ();\n-  delete_trivially_dead_insns (get_insns (), max_reg_num ());\n-\n-  if (tem)\n-    {\n-      timevar_push (TV_JUMP);\n-      rebuild_jump_labels (get_insns ());\n-      delete_dead_jumptables ();\n-      cleanup_cfg (CLEANUP_EXPENSIVE);\n-      timevar_pop (TV_JUMP);\n-    }\n-  reg_scan (get_insns (), max_reg_num ());\n-  close_dump_file (DFI_cse2, print_rtl_with_bb, get_insns ());\n-  timevar_pop (TV_CSE2);\n-\n-  ggc_collect ();\n-}\n-\n-/* Perform global cse.  */\n-static void\n-rest_of_handle_gcse (void)\n-{\n-  int save_csb, save_cfj;\n-  int tem2 = 0, tem;\n-\n-  timevar_push (TV_GCSE);\n-  open_dump_file (DFI_gcse, current_function_decl);\n-\n-  tem = gcse_main (get_insns (), dump_file);\n-  rebuild_jump_labels (get_insns ());\n-  delete_trivially_dead_insns (get_insns (), max_reg_num ());\n-\n-  save_csb = flag_cse_skip_blocks;\n-  save_cfj = flag_cse_follow_jumps;\n-  flag_cse_skip_blocks = flag_cse_follow_jumps = 0;\n-\n-  /* If -fexpensive-optimizations, re-run CSE to clean up things done\n-     by gcse.  */\n-  if (flag_expensive_optimizations)\n-    {\n-      timevar_push (TV_CSE);\n-      reg_scan (get_insns (), max_reg_num ());\n-      tem2 = cse_main (get_insns (), max_reg_num (), dump_file);\n-      purge_all_dead_edges ();\n-      delete_trivially_dead_insns (get_insns (), max_reg_num ());\n-      timevar_pop (TV_CSE);\n-      cse_not_expected = !flag_rerun_cse_after_loop;\n-    }\n-\n-  /* If gcse or cse altered any jumps, rerun jump optimizations to clean\n-     things up.  */\n-  if (tem || tem2)\n-    {\n-      timevar_push (TV_JUMP);\n-      rebuild_jump_labels (get_insns ());\n-      delete_dead_jumptables ();\n-      cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n-      timevar_pop (TV_JUMP);\n-    }\n-\n-  close_dump_file (DFI_gcse, print_rtl_with_bb, get_insns ());\n-  timevar_pop (TV_GCSE);\n-\n-  ggc_collect ();\n-  flag_cse_skip_blocks = save_csb;\n-  flag_cse_follow_jumps = save_cfj;\n-#ifdef ENABLE_CHECKING\n-  verify_flow_info ();\n-#endif\n-}\n-\n-/* Move constant computations out of loops.  */\n-static void\n-rest_of_handle_loop_optimize (void)\n-{\n-  int do_prefetch;\n-\n-  timevar_push (TV_LOOP);\n-  open_dump_file (DFI_loop, current_function_decl);\n-\n-  /* CFG is no longer maintained up-to-date.  */\n-  free_bb_for_insn ();\n-  profile_status = PROFILE_ABSENT;\n-\n-  do_prefetch = flag_prefetch_loop_arrays ? LOOP_PREFETCH : 0;\n-\n-  if (flag_rerun_loop_opt)\n-    {\n-      cleanup_barriers ();\n-\n-      /* We only want to perform unrolling once.  */\n-      loop_optimize (get_insns (), dump_file, 0);\n-\n-      /* The first call to loop_optimize makes some instructions\n-\t trivially dead.  We delete those instructions now in the\n-\t hope that doing so will make the heuristics in loop work\n-\t better and possibly speed up compilation.  */\n-      delete_trivially_dead_insns (get_insns (), max_reg_num ());\n-\n-      /* The regscan pass is currently necessary as the alias\n-\t analysis code depends on this information.  */\n-      reg_scan (get_insns (), max_reg_num ());\n-    }\n-  cleanup_barriers ();\n-  loop_optimize (get_insns (), dump_file, do_prefetch);\n-\n-  /* Loop can create trivially dead instructions.  */\n-  delete_trivially_dead_insns (get_insns (), max_reg_num ());\n-  find_basic_blocks (get_insns ());\n-  close_dump_file (DFI_loop, print_rtl, get_insns ());\n-  timevar_pop (TV_LOOP);\n-\n-  ggc_collect ();\n-}\n-\n-/* Perform loop optimizations.  It might be better to do them a bit\n-   sooner, but we want the profile feedback to work more\n-   efficiently.  */\n-static void\n-rest_of_handle_loop2 (void)\n-{\n-  struct loops *loops;\n-  basic_block bb;\n-\n-  if (!flag_move_loop_invariants\n-      && !flag_unswitch_loops\n-      && !flag_peel_loops\n-      && !flag_unroll_loops\n-      && !flag_branch_on_count_reg)\n-    return;\n-\n-  timevar_push (TV_LOOP);\n-  open_dump_file (DFI_loop2, current_function_decl);\n-  if (dump_file)\n-    dump_flow_info (dump_file);\n-\n-  /* Initialize structures for layout changes.  */\n-  cfg_layout_initialize (0);\n-\n-  loops = loop_optimizer_init (dump_file);\n-\n-  if (loops)\n-    {\n-      /* The optimizations:  */\n-      if (flag_move_loop_invariants)\n-\tmove_loop_invariants (loops);\n-\n-      if (flag_unswitch_loops)\n-\tunswitch_loops (loops);\n-\n-      if (flag_peel_loops || flag_unroll_loops)\n-\tunroll_and_peel_loops (loops,\n-\t\t\t       (flag_peel_loops ? UAP_PEEL : 0) |\n-\t\t\t       (flag_unroll_loops ? UAP_UNROLL : 0) |\n-\t\t\t       (flag_unroll_all_loops ? UAP_UNROLL_ALL : 0));\n-\n-#ifdef HAVE_doloop_end\n-      if (flag_branch_on_count_reg && HAVE_doloop_end)\n-\tdoloop_optimize_loops (loops);\n-#endif /* HAVE_doloop_end */\n-\n-      loop_optimizer_finalize (loops, dump_file);\n-    }\n-\n-  free_dominance_info (CDI_DOMINATORS);\n-\n-  /* Finalize layout changes.  */\n-  FOR_EACH_BB (bb)\n-    if (bb->next_bb != EXIT_BLOCK_PTR)\n-      bb->aux = bb->next_bb;\n-  cfg_layout_finalize ();\n-\n-  cleanup_cfg (CLEANUP_EXPENSIVE);\n-  delete_trivially_dead_insns (get_insns (), max_reg_num ());\n-  reg_scan (get_insns (), max_reg_num ());\n-  if (dump_file)\n-    dump_flow_info (dump_file);\n-  close_dump_file (DFI_loop2, print_rtl_with_bb, get_insns ());\n-  timevar_pop (TV_LOOP);\n-  ggc_collect ();\n-}\n-\n-static void\n-rest_of_handle_branch_target_load_optimize (void)\n-{\n-  static int warned = 0;\n-\n-  /* Leave this a warning for now so that it is possible to experiment\n-     with running this pass twice.  In 3.6, we should either make this\n-     an error, or use separate dump files.  */\n-  if (flag_branch_target_load_optimize\n-      && flag_branch_target_load_optimize2\n-      && !warned)\n-    {\n-      warning (0, \"branch target register load optimization is not intended \"\n-\t       \"to be run twice\");\n-\n-      warned = 1;\n-    }\n-\n-  open_dump_file (DFI_branch_target_load, current_function_decl);\n-  branch_target_load_optimize (epilogue_completed);\n-  close_dump_file (DFI_branch_target_load, print_rtl_with_bb, get_insns ());\n-  ggc_collect ();\n-}\n-\n-#ifdef OPTIMIZE_MODE_SWITCHING\n-static void\n-rest_of_handle_mode_switching (void)\n-{\n-  timevar_push (TV_MODE_SWITCH);\n-\n-  no_new_pseudos = 0;\n-  optimize_mode_switching (NULL);\n-  no_new_pseudos = 1;\n-\n-  timevar_pop (TV_MODE_SWITCH);\n-}\n-#endif\n-\n-static void\n-rest_of_handle_jump (void)\n-{\n-  ggc_collect ();\n-\n-  timevar_push (TV_JUMP);\n-  open_dump_file (DFI_sibling, current_function_decl);\n-\n-  delete_unreachable_blocks ();\n-#ifdef ENABLE_CHECKING\n-  verify_flow_info ();\n-#endif\n-\n-  if (cfun->tail_call_emit)\n-    fixup_tail_calls ();\n-\n-  close_dump_file (DFI_sibling, print_rtl, get_insns ());\n-  timevar_pop (TV_JUMP);\n-}\n-\n-static void\n-rest_of_handle_eh (void)\n-{\n-  insn_locators_initialize ();\n-  /* Complete generation of exception handling code.  */\n-  if (doing_eh (0))\n-    {\n-      timevar_push (TV_JUMP);\n-      open_dump_file (DFI_eh, current_function_decl);\n-\n-      cleanup_cfg (CLEANUP_PRE_LOOP | CLEANUP_NO_INSN_DEL);\n-\n-      finish_eh_generation ();\n-\n-      cleanup_cfg (CLEANUP_PRE_LOOP | CLEANUP_NO_INSN_DEL);\n-\n-      close_dump_file (DFI_eh, print_rtl, get_insns ());\n-      timevar_pop (TV_JUMP);\n-    }\n-}\n-\n-static void\n-rest_of_handle_stack_adjustments (void)\n-{\n-  life_analysis (dump_file, PROP_POSTRELOAD);\n-  cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE\n-\t       | (flag_crossjumping ? CLEANUP_CROSSJUMP : 0));\n-    \n-  /* This is kind of a heuristic.  We need to run combine_stack_adjustments\n-     even for machines with possibly nonzero RETURN_POPS_ARGS\n-     and ACCUMULATE_OUTGOING_ARGS.  We expect that only ports having\n-     push instructions will have popping returns.  */\n-#ifndef PUSH_ROUNDING\n-  if (!ACCUMULATE_OUTGOING_ARGS)\n-#endif\n-    combine_stack_adjustments ();\n-}\n-\n-static void\n-rest_of_handle_flow2 (void)\n-{\n-  timevar_push (TV_FLOW2);\n-  open_dump_file (DFI_flow2, current_function_decl);\n-\n-  /* Re-create the death notes which were deleted during reload.  */\n-#ifdef ENABLE_CHECKING\n-  verify_flow_info ();\n-#endif\n-\n-  /* If optimizing, then go ahead and split insns now.  */\n-#ifndef STACK_REGS\n-  if (optimize > 0)\n-#endif\n-    split_all_insns (0);\n-\n-  if (flag_branch_target_load_optimize)\n-    {\n-      close_dump_file (DFI_flow2, print_rtl_with_bb, get_insns ());\n-      rest_of_handle_branch_target_load_optimize ();\n-      open_dump_file (DFI_flow2, current_function_decl);\n-    }\n-\n-  if (optimize)\n-    cleanup_cfg (CLEANUP_EXPENSIVE);\n-\n-  /* On some machines, the prologue and epilogue code, or parts thereof,\n-     can be represented as RTL.  Doing so lets us schedule insns between\n-     it and the rest of the code and also allows delayed branch\n-     scheduling to operate in the epilogue.  */\n-  thread_prologue_and_epilogue_insns (get_insns ());\n-  epilogue_completed = 1;\n-\n-  if (optimize)\n-    rest_of_handle_stack_adjustments ();\n-\n-  flow2_completed = 1;\n-\n-  close_dump_file (DFI_flow2, print_rtl_with_bb, get_insns ());\n-  timevar_pop (TV_FLOW2);\n-\n-  ggc_collect ();\n-}\n-\n-\n-static void\n-rest_of_handle_jump2 (void)\n-{\n-  open_dump_file (DFI_jump, current_function_decl);\n-\n-  /* Always do one jump optimization pass to ensure that JUMP_LABEL fields\n-     are initialized and to compute whether control can drop off the end\n-     of the function.  */\n-\n-  timevar_push (TV_JUMP);\n-  /* Turn NOTE_INSN_EXPECTED_VALUE into REG_BR_PROB.  Do this\n-     before jump optimization switches branch directions.  */\n-  if (flag_guess_branch_prob)\n-    expected_value_to_br_prob ();\n-\n-  delete_trivially_dead_insns (get_insns (), max_reg_num ());\n-  reg_scan (get_insns (), max_reg_num ());\n-  if (dump_file)\n-    dump_flow_info (dump_file);\n-  cleanup_cfg ((optimize ? CLEANUP_EXPENSIVE : 0) | CLEANUP_PRE_LOOP\n-\t       | (flag_thread_jumps ? CLEANUP_THREADING : 0));\n-\n-  create_loop_notes ();\n-\n-  purge_line_number_notes (get_insns ());\n-\n-  if (optimize)\n-    cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n-\n-  /* Jump optimization, and the removal of NULL pointer checks, may\n-     have reduced the number of instructions substantially.  CSE, and\n-     future passes, allocate arrays whose dimensions involve the\n-     maximum instruction UID, so if we can reduce the maximum UID\n-     we'll save big on memory.  */\n-  renumber_insns (dump_file);\n-\n-  close_dump_file (DFI_jump, print_rtl_with_bb, get_insns ());\n-  timevar_pop (TV_JUMP);\n-\n-  ggc_collect ();\n-}\n-\n-#ifdef HAVE_peephole2\n-static void\n-rest_of_handle_peephole2 (void)\n-{\n-  timevar_push (TV_PEEPHOLE2);\n-  open_dump_file (DFI_peephole2, current_function_decl);\n-\n-  peephole2_optimize (dump_file);\n-\n-  close_dump_file (DFI_peephole2, print_rtl_with_bb, get_insns ());\n-  timevar_pop (TV_PEEPHOLE2);\n-}\n-#endif\n-\n-static void\n-rest_of_handle_postreload (void)\n-{\n-  timevar_push (TV_RELOAD_CSE_REGS);\n-  open_dump_file (DFI_postreload, current_function_decl);\n-\n-  /* Do a very simple CSE pass over just the hard registers.  */\n-  reload_cse_regs (get_insns ());\n-  /* reload_cse_regs can eliminate potentially-trapping MEMs.\n-     Remove any EH edges associated with them.  */\n-  if (flag_non_call_exceptions)\n-    purge_all_dead_edges ();\n-\n-  close_dump_file (DFI_postreload, print_rtl_with_bb, get_insns ());\n-  timevar_pop (TV_RELOAD_CSE_REGS);\n-}\n-\n-static void\n-rest_of_handle_shorten_branches (void)\n-{\n-  /* Shorten branches.  */\n-  timevar_push (TV_SHORTEN_BRANCH);\n-  shorten_branches (get_insns ());\n-  timevar_pop (TV_SHORTEN_BRANCH);\n+  while (pass);\n }\n-\n-static void\n-rest_of_clean_state (void)\n-{\n-  rtx insn, next;\n-\n-  /* It is very important to decompose the RTL instruction chain here:\n-     debug information keeps pointing into CODE_LABEL insns inside the function\n-     body.  If these remain pointing to the other insns, we end up preserving\n-     whole RTL chain and attached detailed debug info in memory.  */\n-  for (insn = get_insns (); insn; insn = next)\n-    {\n-      next = NEXT_INSN (insn);\n-      NEXT_INSN (insn) = NULL;\n-      PREV_INSN (insn) = NULL;\n-    }\n-\n-  /* In case the function was not output,\n-     don't leave any temporary anonymous types\n-     queued up for sdb output.  */\n-#ifdef SDB_DEBUGGING_INFO\n-  if (write_symbols == SDB_DEBUG)\n-    sdbout_types (NULL_TREE);\n-#endif\n-\n-  reload_completed = 0;\n-  epilogue_completed = 0;\n-  flow2_completed = 0;\n-  no_new_pseudos = 0;\n-\n-  timevar_push (TV_FINAL);\n-\n-  /* Clear out the insn_length contents now that they are no\n-     longer valid.  */\n-  init_insn_lengths ();\n-\n-  /* Show no temporary slots allocated.  */\n-  init_temp_slots ();\n-\n-  free_basic_block_vars ();\n-  free_bb_for_insn ();\n-\n-  timevar_pop (TV_FINAL);\n-\n-  if (targetm.binds_local_p (current_function_decl))\n-    {\n-      int pref = cfun->preferred_stack_boundary;\n-      if (cfun->stack_alignment_needed > cfun->preferred_stack_boundary)\n-\tpref = cfun->stack_alignment_needed;\n-      cgraph_rtl_info (current_function_decl)->preferred_incoming_stack_boundary\n-        = pref;\n-    }\n-\n-  /* Make sure volatile mem refs aren't considered valid operands for\n-     arithmetic insns.  We must call this here if this is a nested inline\n-     function, since the above code leaves us in the init_recog state\n-     (from final.c), and the function context push/pop code does not\n-     save/restore volatile_ok.\n-\n-     ??? Maybe it isn't necessary for expand_start_function to call this\n-     anymore if we do it here?  */\n-\n-  init_recog_no_volatile ();\n-\n-  /* We're done with this function.  Free up memory if we can.  */\n-  free_after_parsing (cfun);\n-  free_after_compilation (cfun);\n-}\n-\f\n-\n-/* This function is called from the pass manager in tree-optimize.c\n-   after all tree passes have finished for a single function, and we\n-   have expanded the function body from trees to RTL.\n-   Once we are here, we have decided that we're supposed to output\n-   that function, i.e. that we should write assembler code for it.\n-\n-   We run a series of low-level passes here on the function's RTL\n-   representation.  Each pass is called via a rest_of_* function.  */\n-\n-static void\n-rest_of_compilation (void)\n-{\n-  /* If we're emitting a nested function, make sure its parent gets\n-     emitted as well.  Doing otherwise confuses debug info.  */\n-  {\n-    tree parent;\n-    for (parent = DECL_CONTEXT (current_function_decl);\n-\t parent != NULL_TREE;\n-\t parent = get_containing_scope (parent))\n-      if (TREE_CODE (parent) == FUNCTION_DECL)\n-\tTREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (parent)) = 1;\n-  }\n-\n-  /* We are now committed to emitting code for this function.  Do any\n-     preparation, such as emitting abstract debug info for the inline\n-     before it gets mangled by optimization.  */\n-  if (cgraph_function_possibly_inlined_p (current_function_decl))\n-    (*debug_hooks->outlining_inline_function) (current_function_decl);\n-\n-  /* Remove any notes we don't need.  That will make iterating\n-     over the instruction sequence faster, and allow the garbage\n-     collector to reclaim the memory used by the notes.  */\n-  remove_unnecessary_notes ();\n-\n-  /* Initialize some variables used by the optimizers.  */\n-  init_function_for_compilation ();\n-\n-  TREE_ASM_WRITTEN (current_function_decl) = 1;\n-\n-  /* Early return if there were errors.  We can run afoul of our\n-     consistency checks, and there's not really much point in fixing them.  */\n-  if (rtl_dump_and_exit || flag_syntax_only || errorcount || sorrycount)\n-    goto exit_rest_of_compilation;\n-\n-  rest_of_handle_jump ();\n-\n-  rest_of_handle_eh ();\n-\n-  /* Delay emitting hard_reg_initial_value sets until after EH landing pad\n-     generation, which might create new sets.  */\n-  emit_initial_value_sets ();\n-\n-#ifdef FINALIZE_PIC\n-  /* If we are doing position-independent code generation, now\n-     is the time to output special prologues and epilogues.\n-     We do not want to do this earlier, because it just clutters\n-     up inline functions with meaningless insns.  */\n-  if (flag_pic)\n-    FINALIZE_PIC;\n-#endif\n-\n-  /* Copy any shared structure that should not be shared.  */\n-  unshare_all_rtl ();\n-\n-  /* Instantiate all virtual registers.  */\n-  instantiate_virtual_regs ();\n-\n-  rest_of_handle_jump2 ();\n-\n-  if (optimize > 0)\n-    rest_of_handle_cse ();\n-\n-  if (optimize > 0)\n-    {\n-      if (flag_gcse)\n-\trest_of_handle_gcse ();\n-\n-      if (flag_loop_optimize)\n-\trest_of_handle_loop_optimize ();\n-\n-      if (flag_gcse)\n-\trest_of_handle_jump_bypass ();\n-    }\n-\n-  timevar_push (TV_FLOW);\n-  rest_of_handle_cfg ();\n-\n-  if (optimize > 0\n-      || ((profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n-\t  && !flag_tree_based_profiling))\n-    {\n-      rtl_register_profile_hooks ();\n-      rtl_register_value_prof_hooks ();\n-      rest_of_handle_branch_prob ();\n-\n-      if (flag_branch_probabilities\n-\t  && flag_profile_values\n-          && !flag_tree_based_profiling\n-\t  && (flag_value_profile_transformations\n-\t      || flag_speculative_prefetching))\n-\trest_of_handle_value_profile_transformations ();\n-\n-      /* Remove the death notes created for vpt.  */\n-      if (flag_profile_values)\n-\tcount_or_remove_death_notes (NULL, 1);\n-    }\n-\n-  if (optimize > 0)\n-    rest_of_handle_if_conversion ();\n-\n-  if (optimize > 0 && flag_tracer)\n-    rest_of_handle_tracer ();\n-\n-  if (optimize > 0\n-      && flag_loop_optimize2)\n-    rest_of_handle_loop2 ();\n-\n-  if (optimize > 0 && flag_web)\n-    rest_of_handle_web ();\n-\n-  if (optimize > 0 && flag_rerun_cse_after_loop)\n-    rest_of_handle_cse2 ();\n-\n-  cse_not_expected = 1;\n-\n-  rest_of_handle_life ();\n-  timevar_pop (TV_FLOW);\n-\n-  if (optimize > 0)\n-    rest_of_handle_combine ();\n-\n-  if (optimize > 0 && flag_if_conversion)\n-    rest_of_handle_if_after_combine ();\n-\n-  /* The optimization to partition hot/cold basic blocks into separate\n-     sections of the .o file does not work well with linkonce or with\n-     user defined section attributes.  Don't call it if either case\n-     arises.  */\n-\n-  if (flag_reorder_blocks_and_partition \n-      && !DECL_ONE_ONLY (current_function_decl)\n-      && !user_defined_section_attribute)\n-    rest_of_handle_partition_blocks ();\n-\n-  if (optimize > 0 && flag_regmove)\n-    rest_of_handle_regmove ();\n-\n-  /* Do unconditional splitting before register allocation to allow machine\n-     description to add extra information not needed previously.  */\n-  split_all_insns (1);\n-\n-#ifdef OPTIMIZE_MODE_SWITCHING\n-  rest_of_handle_mode_switching ();\n-#endif\n-\n-  /* Any of the several passes since flow1 will have munged register\n-     lifetime data a bit.  We need it to be up to date for scheduling\n-     (see handling of reg_known_equiv in init_alias_analysis).  */\n-  recompute_reg_usage ();\n-\n-#ifdef INSN_SCHEDULING\n-  if (optimize > 0 && flag_modulo_sched)\n-    rest_of_handle_sms ();\n-\n-  if (flag_schedule_insns)\n-    rest_of_handle_sched ();\n-#endif\n-\n-  /* Determine if the current function is a leaf before running reload\n-     since this can impact optimizations done by the prologue and\n-     epilogue thus changing register elimination offsets.  */\n-  current_function_is_leaf = leaf_function_p ();\n-\n-  if (rest_of_handle_old_regalloc ())\n-    goto exit_rest_of_compilation;\n-\n-  if (optimize > 0)\n-    rest_of_handle_postreload ();\n-\n-  if (optimize > 0 && flag_gcse_after_reload)\n-    rest_of_handle_gcse2 ();\n-\n-  rest_of_handle_flow2 ();\n-\n-#ifdef HAVE_peephole2\n-  if (optimize > 0 && flag_peephole2)\n-    rest_of_handle_peephole2 ();\n-#endif\n-\n-  if (optimize > 0)\n-    rest_of_handle_if_after_reload ();\n-\n-  if (optimize > 0)\n-    {\n-      if (flag_rename_registers || flag_cprop_registers)\n-\trest_of_handle_regrename ();\n-\n-      rest_of_handle_reorder_blocks ();\n-    }\n-\n-  if (flag_branch_target_load_optimize2)\n-    rest_of_handle_branch_target_load_optimize ();\n-\n-#ifdef LEAF_REGISTERS\n-  current_function_uses_only_leaf_regs\n-    = optimize > 0 && only_leaf_regs_used () && leaf_function_p ();\n-#endif\n-\n-#ifdef INSN_SCHEDULING\n-  if (optimize > 0 && flag_schedule_insns_after_reload)\n-    rest_of_handle_sched2 ();\n-#endif\n-\n-#ifdef STACK_REGS\n-  rest_of_handle_stack_regs ();\n-#endif\n-\n-  compute_alignments ();\n-\n-  /* Aggressively duplicate basic blocks ending in computed gotos to the\n-     tails of their predecessors, unless we are optimizing for size.  */\n-  if (flag_expensive_optimizations && !optimize_size)\n-    duplicate_computed_gotos ();\n-\n-  if (flag_var_tracking)\n-    rest_of_handle_variable_tracking ();\n-\n-  /* CFG is no longer maintained up-to-date.  */\n-  free_bb_for_insn ();\n-\n-  if (targetm.machine_dependent_reorg != 0)\n-    rest_of_handle_machine_reorg ();\n-\n-  purge_line_number_notes (get_insns ());\n-  cleanup_barriers ();\n-\n-#ifdef DELAY_SLOTS\n-  if (flag_delayed_branch)\n-    rest_of_handle_delay_slots ();\n-#endif\n-\n-#if defined (HAVE_ATTR_length) && !defined (STACK_REGS)\n-  timevar_push (TV_SHORTEN_BRANCH);\n-  split_all_insns_noflow ();\n-  timevar_pop (TV_SHORTEN_BRANCH);\n-#endif\n-\n-  convert_to_eh_region_ranges ();\n-\n-  rest_of_handle_shorten_branches ();\n-\n-  set_nothrow_function_flags ();\n-\n-  rest_of_handle_final ();\n-\n- exit_rest_of_compilation:\n-\n-  rest_of_clean_state ();\n-}\n-\n-void\n-finish_optimization_passes (void)\n-{\n-  enum tree_dump_index i;\n-  struct dump_file_info *dfi;\n-  char *name;\n-\n-  timevar_push (TV_DUMP);\n-  if (profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n-    {\n-      open_dump_file (DFI_bp, NULL);\n-      end_branch_prob ();\n-      close_dump_file (DFI_bp, NULL, NULL_RTX);\n-    }\n-\n-  if (optimize > 0 && open_dump_file (DFI_combine, NULL))\n-    {\n-      dump_combine_total_stats (dump_file);\n-      close_dump_file (DFI_combine, NULL, NULL_RTX);\n-    }\n-\n-  /* Do whatever is necessary to finish printing the graphs.  */\n-  if (graph_dump_format != no_graph)\n-    for (i = DFI_MIN; (dfi = get_dump_file_info (i)) != NULL; ++i)\n-      if (dump_initialized_p (i)\n-\t  && (dfi->flags & TDF_RTL) != 0\n-\t  && (name = get_dump_file_name (i)) != NULL)\n-        {\n-          finish_graph_dump_file (name);\n-          free (name);\n-        }\n-\n-  timevar_pop (TV_DUMP);\n-}\n-\n-struct tree_opt_pass pass_rest_of_compilation =\n-{\n-  NULL,\t\t\t                /* name */\n-  NULL,\t\t                        /* gate */\n-  rest_of_compilation,                  /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_REST_OF_COMPILATION,               /* tv_id */\n-  PROP_rtl,\t\t                /* properties_required */\n-  0,                                    /* properties_provided */\n-  PROP_rtl,                             /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_ggc_collect,\t\t\t/* todo_flags_finish */\n-  0\t\t\t\t\t/* letter */\n-};\n-\n-"}, {"sha": "cf08c09aba7374a4f74de6acc6a52ee15bd04913", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -44,6 +44,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"hashtab.h\"\n #include \"params.h\"\n #include \"target.h\"\n+#include \"timevar.h\"\n+#include \"tree-pass.h\"\n \n /* The following code implements gcse after reload, the purpose of this\n    pass is to cleanup redundant loads generated by reload and other\n@@ -1337,3 +1339,37 @@ gcse_after_reload_main (rtx f ATTRIBUTE_UNUSED)\n   free_mem ();\n }\n \n+\f\n+static bool\n+gate_handle_gcse2 (void)\n+{\n+  return (optimize > 0 && flag_gcse_after_reload);\n+}\n+\n+\n+static void\n+rest_of_handle_gcse2 (void)\n+{\n+  gcse_after_reload_main (get_insns ());\n+  rebuild_jump_labels (get_insns ());\n+  delete_trivially_dead_insns (get_insns (), max_reg_num ());\n+}\n+\n+struct tree_opt_pass pass_gcse2 =\n+{\n+  \"gcse2\",                              /* name */\n+  gate_handle_gcse2,                    /* gate */\n+  rest_of_handle_gcse2,                 /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_GCSE_AFTER_RELOAD,                 /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func |\n+  TODO_verify_flow | TODO_ggc_collect,  /* todo_flags_finish */\n+  'J'                                   /* letter */\n+};\n+"}, {"sha": "d164ae17f108c87aeea7843572fd53413ee7b671", "filename": "gcc/postreload.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -44,6 +44,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"toplev.h\"\n #include \"except.h\"\n #include \"tree.h\"\n+#include \"timevar.h\"\n+#include \"tree-pass.h\"\n \n static int reload_cse_noop_set_p (rtx);\n static void reload_cse_simplify (rtx, rtx);\n@@ -1561,3 +1563,39 @@ move2add_note_store (rtx dst, rtx set, void *data ATTRIBUTE_UNUSED)\n \treg_set_luid[i] = 0;\n     }\n }\n+\f\n+static bool\n+gate_handle_postreload (void)\n+{\n+  return (optimize > 0);\n+}\n+\n+\n+static void\n+rest_of_handle_postreload (void)\n+{\n+  /* Do a very simple CSE pass over just the hard registers.  */\n+  reload_cse_regs (get_insns ());\n+  /* reload_cse_regs can eliminate potentially-trapping MEMs.\n+     Remove any EH edges associated with them.  */\n+  if (flag_non_call_exceptions)\n+    purge_all_dead_edges ();\n+}\n+\n+struct tree_opt_pass pass_postreload_cse =\n+{\n+  \"postreload\",                         /* name */\n+  gate_handle_postreload,               /* gate */\n+  rest_of_handle_postreload,            /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_RELOAD_CSE_REGS,                   /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func,                       /* todo_flags_finish */\n+  'o'                                   /* letter */\n+};\n+"}, {"sha": "054f0771f47e0442c89aac4f754e4bad39163fa1", "filename": "gcc/profile.c", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -65,6 +65,9 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"tree.h\"\n #include \"cfghooks.h\"\n #include \"tree-flow.h\"\n+#include \"timevar.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-pass.h\"\n \n /* Hooks for profiling.  */\n static struct profile_hooks* profile_hooks;\n@@ -1329,3 +1332,78 @@ rtl_register_profile_hooks (void)\n   gcc_assert (!ir_type ());\n   profile_hooks = &rtl_profile_hooks;\n }\n+\f\n+static bool\n+gate_handle_profiling (void)\n+{\n+  return optimize > 0\n+         || (!flag_tree_based_profiling\n+\t     && (profile_arc_flag || flag_test_coverage\n+\t\t || flag_branch_probabilities));\n+}\n+\n+struct tree_opt_pass pass_profiling =\n+{\n+  NULL,                                 /* name */\n+  gate_handle_profiling,                /* gate */   \n+  NULL,\t\t\t\t        /* execute */       \n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  0,                                    /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  0,                                    /* todo_flags_finish */\n+  0                                     /* letter */\n+};\n+\n+\n+/* Do branch profiling and static profile estimation passes.  */\n+static void\n+rest_of_handle_branch_prob (void)\n+{\n+  struct loops loops;\n+\n+  rtl_register_profile_hooks ();\n+  rtl_register_value_prof_hooks ();\n+\n+  if ((profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n+      && !flag_tree_based_profiling)\n+    branch_prob ();\n+\n+  /* Discover and record the loop depth at the head of each basic\n+     block.  The loop infrastructure does the real job for us.  */\n+  flow_loops_find (&loops);\n+\n+  if (dump_file)\n+    flow_loops_dump (&loops, dump_file, NULL, 0);\n+\n+  /* Estimate using heuristics if no profiling info is available.  */\n+  if (flag_guess_branch_prob && profile_status == PROFILE_ABSENT)\n+    estimate_probability (&loops);\n+\n+  flow_loops_free (&loops);\n+  free_dominance_info (CDI_DOMINATORS);\n+}\n+\n+struct tree_opt_pass pass_branch_prob =\n+{\n+  \"bp\",                                 /* name */\n+  NULL,                                 /* gate */   \n+  rest_of_handle_branch_prob,           /* execute */       \n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_BRANCH_PROB,                       /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func,                       /* todo_flags_finish */\n+  'b'                                   /* letter */\n+};\n+\n+\n+"}, {"sha": "8e6a62b6dd0aac827074b9659611cea042558a05", "filename": "gcc/recog.c", "status": "modified", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -39,6 +39,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"basic-block.h\"\n #include \"output.h\"\n #include \"reload.h\"\n+#include \"timevar.h\"\n+#include \"tree-pass.h\"\n \n #ifndef STACK_PUSH_CODE\n #ifdef STACK_GROWS_DOWNWARD\n@@ -3418,3 +3420,122 @@ if_test_bypass_p (rtx out_insn, rtx in_insn)\n \n   return true;\n }\n+\f\n+static bool\n+gate_handle_peephole2 (void)\n+{\n+  return (optimize > 0 && flag_peephole2);\n+}\n+\n+static void\n+rest_of_handle_peephole2 (void)\n+{\n+#ifdef HAVE_peephole2\n+  peephole2_optimize (dump_file);\n+#endif\n+}\n+\n+struct tree_opt_pass pass_peephole2 =\n+{\n+  \"peephole2\",                          /* name */\n+  gate_handle_peephole2,                /* gate */\n+  rest_of_handle_peephole2,             /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_PEEPHOLE2,                         /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func,                       /* todo_flags_finish */\n+  'z'                                   /* letter */\n+};\n+\n+static void\n+rest_of_handle_split_all_insns (void)\n+{\n+  split_all_insns (1);\n+}\n+\n+struct tree_opt_pass pass_split_all_insns =\n+{\n+  NULL,                                 /* name */\n+  NULL,                                 /* gate */\n+  rest_of_handle_split_all_insns,       /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  0,                                    /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  0,                                    /* todo_flags_finish */\n+  0                                     /* letter */\n+};\n+\n+/* The placement of the splitting that we do for shorten_branches\n+   depends on whether regstack is used by the target or not.  */\n+static bool\n+gate_do_final_split (void)\n+{\n+#if defined (HAVE_ATTR_length) && !defined (STACK_REGS)\n+  return 1;\n+#else\n+  return 0;\n+#endif \n+}\n+\n+struct tree_opt_pass pass_split_for_shorten_branches =\n+{\n+  NULL,                                 /* name */\n+  gate_do_final_split,                  /* gate */\n+  split_all_insns_noflow,               /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_SHORTEN_BRANCH,                    /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  0,                                    /* todo_flags_finish */\n+  0                                     /* letter */\n+};\n+\n+\n+static bool\n+gate_handle_split_before_regstack (void)\n+{\n+#if defined (HAVE_ATTR_length) && defined (STACK_REGS)\n+  /* If flow2 creates new instructions which need splitting\n+     and scheduling after reload is not done, they might not be\n+     split until final which doesn't allow splitting\n+     if HAVE_ATTR_length.  */\n+# ifdef INSN_SCHEDULING\n+  return (optimize && !flag_schedule_insns_after_reload);\n+# else\n+  return (optimize);\n+# endif\n+#else\n+  return 0;\n+#endif\n+}\n+\n+struct tree_opt_pass pass_split_before_regstack =\n+{\n+  NULL,                                 /* name */\n+  gate_handle_split_before_regstack,    /* gate */\n+  rest_of_handle_split_all_insns,       /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_SHORTEN_BRANCH,                    /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  0,                                    /* todo_flags_finish */\n+  0                                     /* letter */\n+};"}, {"sha": "d1d8b9894bde2308378153e42940d1d393b53e45", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -170,6 +170,8 @@\n #include \"varray.h\"\n #include \"reload.h\"\n #include \"ggc.h\"\n+#include \"timevar.h\"\n+#include \"tree-pass.h\"\n \n /* We use this array to cache info about insns, because otherwise we\n    spend too much time in stack_regs_mentioned_p.\n@@ -3126,5 +3128,52 @@ reg_to_stack (FILE *file)\n   return true;\n }\n #endif /* STACK_REGS */\n+\f\n+static bool\n+gate_handle_stack_regs (void)\n+{\n+#ifdef STACK_REGS\n+  return 1;\n+#else\n+  return 0;\n+#endif\n+}\n+\n+/* Convert register usage from flat register file usage to a stack\n+   register file.  */\n+static void\n+rest_of_handle_stack_regs (void)\n+{\n+#ifdef STACK_REGS\n+  if (reg_to_stack (dump_file) && optimize)\n+    {\n+      if (cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_POST_REGSTACK\n+                       | (flag_crossjumping ? CLEANUP_CROSSJUMP : 0))\n+          && (flag_reorder_blocks || flag_reorder_blocks_and_partition))\n+        {\n+          reorder_basic_blocks (0);\n+          cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_POST_REGSTACK);\n+        }\n+    }\n+#endif\n+}\n+\n+struct tree_opt_pass pass_stack_regs =\n+{\n+  \"stack\",                              /* name */\n+  gate_handle_stack_regs,               /* gate */\n+  rest_of_handle_stack_regs,            /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_REG_STACK,                         /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func |\n+  TODO_ggc_collect,                     /* todo_flags_finish */\n+  'k'                                   /* letter */\n+};\n \n #include \"gt-reg-stack.h\""}, {"sha": "08cacf42bd188f34e03616637530d453e965f249", "filename": "gcc/regmove.c", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -43,6 +43,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"except.h\"\n #include \"toplev.h\"\n #include \"reload.h\"\n+#include \"timevar.h\"\n+#include \"tree-pass.h\"\n \n \n /* Turn STACK_GROWS_DOWNWARD into a boolean.  */\n@@ -2461,3 +2463,80 @@ combine_stack_adjustments_for_block (basic_block bb)\n   if (memlist)\n     free_csa_memlist (memlist);\n }\n+\f\n+static bool\n+gate_handle_regmove (void)\n+{\n+  return (optimize > 0 && flag_regmove);\n+}\n+\n+\n+/* Register allocation pre-pass, to reduce number of moves necessary\n+   for two-address machines.  */\n+static void\n+rest_of_handle_regmove (void)\n+{\n+  regmove_optimize (get_insns (), max_reg_num (), dump_file);\n+  cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE);\n+}\n+\n+struct tree_opt_pass pass_regmove =\n+{\n+  \"regmove\",                            /* name */\n+  gate_handle_regmove,                  /* gate */\n+  rest_of_handle_regmove,               /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_REGMOVE,                           /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func |\n+  TODO_ggc_collect,                     /* todo_flags_finish */\n+  'N'                                   /* letter */\n+};\n+\n+\n+static bool\n+gate_handle_stack_adjustments (void)\n+{\n+  return (optimize > 0);\n+}\n+\n+static void\n+rest_of_handle_stack_adjustments (void)\n+{\n+  life_analysis (dump_file, PROP_POSTRELOAD);\n+  cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE\n+               | (flag_crossjumping ? CLEANUP_CROSSJUMP : 0));\n+\n+  /* This is kind of a heuristic.  We need to run combine_stack_adjustments\n+     even for machines with possibly nonzero RETURN_POPS_ARGS\n+     and ACCUMULATE_OUTGOING_ARGS.  We expect that only ports having\n+     push instructions will have popping returns.  */\n+#ifndef PUSH_ROUNDING\n+  if (!ACCUMULATE_OUTGOING_ARGS)\n+#endif\n+    combine_stack_adjustments ();\n+}\n+\n+struct tree_opt_pass pass_stack_adjustments =\n+{\n+  NULL,                                 /* name */\n+  gate_handle_stack_adjustments,        /* gate */\n+  rest_of_handle_stack_adjustments,     /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  0,                                    /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func |\n+  TODO_ggc_collect,                     /* todo_flags_finish */\n+  0                                     /* letter */\n+};\n+"}, {"sha": "cd448c4465429dc57c73d925bae261a882915bf5", "filename": "gcc/regrename.c", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -36,6 +36,8 @@\n #include \"flags.h\"\n #include \"toplev.h\"\n #include \"obstack.h\"\n+#include \"timevar.h\"\n+#include \"tree-pass.h\"\n \n struct du_chain\n {\n@@ -1907,3 +1909,38 @@ validate_value_data (struct value_data *vd)\n \t\t      vd->e[i].next_regno);\n }\n #endif\n+\f\n+static bool\n+gate_handle_regrename (void)\n+{\n+  return (optimize > 0 && (flag_rename_registers || flag_cprop_registers));\n+}\n+\n+\n+/* Run the regrename and cprop passes.  */\n+static void\n+rest_of_handle_regrename (void)\n+{\n+  if (flag_rename_registers)\n+    regrename_optimize ();\n+  if (flag_cprop_registers)\n+    copyprop_hardreg_forward ();\n+}\n+\n+struct tree_opt_pass pass_regrename =\n+{\n+  \"rnreg\",                              /* name */\n+  gate_handle_regrename,                /* gate */\n+  rest_of_handle_regrename,             /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_RENAME_REGISTERS,                  /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func,                       /* todo_flags_finish */\n+  'n'                                   /* letter */\n+};\n+"}, {"sha": "c32d9bc0f939d12fa40af95d54a8b3ded3d79685", "filename": "gcc/reorg.c", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -133,6 +133,9 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"resource.h\"\n #include \"except.h\"\n #include \"params.h\"\n+#include \"timevar.h\"\n+#include \"target.h\"\n+#include \"tree-pass.h\"\n \n #ifdef DELAY_SLOTS\n \n@@ -3809,3 +3812,73 @@ dbr_schedule (rtx first, FILE *file)\n #endif\n }\n #endif /* DELAY_SLOTS */\n+\f\n+static bool\n+gate_handle_delay_slots (void)\n+{\n+#ifdef DELAY_SLOTS\n+  return flag_delayed_branch;\n+#else \n+  return 0;\n+#endif\n+}\n+\n+/* Run delay slot optimization.  */\n+static void\n+rest_of_handle_delay_slots (void)\n+{\n+#ifdef DELAY_SLOTS\n+  dbr_schedule (get_insns (), dump_file);\n+#endif\n+}   \n+\n+struct tree_opt_pass pass_delay_slots =\n+{\n+  \"dbr\",                                /* name */\n+  gate_handle_delay_slots,              /* gate */\n+  rest_of_handle_delay_slots,           /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_DBR_SCHED,                         /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func |\n+  TODO_ggc_collect,                     /* todo_flags_finish */\n+  'd'                                   /* letter */\n+};\n+\n+/* Machine dependent reorg pass.  */\n+static bool\n+gate_handle_machine_reorg (void)\n+{\n+  return targetm.machine_dependent_reorg != 0;\n+}\n+\n+\n+static void\n+rest_of_handle_machine_reorg (void)\n+{\n+  targetm.machine_dependent_reorg ();\n+}\n+\n+struct tree_opt_pass pass_machine_reorg =\n+{\n+  \"mach\",                               /* name */\n+  gate_handle_machine_reorg,            /* gate */\n+  rest_of_handle_machine_reorg,         /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_MACH_DEP,                          /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func |\n+  TODO_ggc_collect,                     /* todo_flags_finish */\n+  'M'                                   /* letter */\n+};\n+"}, {"sha": "da43bf8ca84b572ccd91fc2bdd122773e9d34c95", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -1896,7 +1896,7 @@ extern enum rtx_code reversed_comparison_code_parts (enum rtx_code,\n \t\t\t\t\t\t     rtx, rtx, rtx);\n extern void delete_for_peephole (rtx, rtx);\n extern int condjump_in_parallel_p (rtx);\n-extern void purge_line_number_notes (rtx);\n+extern void purge_line_number_notes (void);\n \n /* In emit-rtl.c.  */\n extern int max_reg_num (void);"}, {"sha": "3be01cce24a772e4f26aa6fa817ead13f574047e", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -65,6 +65,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"params.h\"\n #include \"sched-int.h\"\n #include \"target.h\"\n+#include \"timevar.h\"\n+#include \"tree-pass.h\"\n \n /* Define when we want to do count REG_DEAD notes before and after scheduling\n    for sanity checking.  We can't do that when conditional execution is used,\n@@ -2588,3 +2590,95 @@ schedule_insns (FILE *dump_file)\n   sbitmap_free (large_region_blocks);\n }\n #endif\n+\f\n+static bool\n+gate_handle_sched (void)\n+{\n+#ifdef INSN_SCHEDULING\n+  return flag_schedule_insns;\n+#else\n+  return 0;\n+#endif\n+}\n+\n+/* Run instruction scheduler.  */\n+static void\n+rest_of_handle_sched (void)\n+{\n+#ifdef INSN_SCHEDULING\n+  /* Do control and data sched analysis,\n+     and write some of the results to dump file.  */\n+\n+  schedule_insns (dump_file);\n+#endif\n+}\n+\n+static bool\n+gate_handle_sched2 (void)\n+{\n+#ifdef INSN_SCHEDULING\n+  return optimize > 0 && flag_schedule_insns_after_reload;\n+#else\n+  return 0;\n+#endif\n+}\n+\n+/* Run second scheduling pass after reload.  */\n+static void\n+rest_of_handle_sched2 (void)\n+{\n+#ifdef INSN_SCHEDULING\n+  /* Do control and data sched analysis again,\n+     and write some more of the results to dump file.  */\n+\n+  split_all_insns (1);\n+\n+  if (flag_sched2_use_superblocks || flag_sched2_use_traces)\n+    {\n+      schedule_ebbs (dump_file);\n+      /* No liveness updating code yet, but it should be easy to do.\n+         reg-stack recomputes the liveness when needed for now.  */\n+      count_or_remove_death_notes (NULL, 1);\n+      cleanup_cfg (CLEANUP_EXPENSIVE);\n+    }\n+  else\n+    schedule_insns (dump_file);\n+#endif\n+}\n+\n+struct tree_opt_pass pass_sched =\n+{\n+  \"sched1\",                             /* name */\n+  gate_handle_sched,                    /* gate */\n+  rest_of_handle_sched,                 /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_SCHED,                             /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func |\n+  TODO_ggc_collect,                     /* todo_flags_finish */\n+  'S'                                   /* letter */\n+};\n+\n+struct tree_opt_pass pass_sched2 =\n+{\n+  \"sched2\",                             /* name */\n+  gate_handle_sched2,                   /* gate */\n+  rest_of_handle_sched2,                /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_SCHED2,                            /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func |\n+  TODO_ggc_collect,                     /* todo_flags_finish */\n+  'R'                                   /* letter */\n+};\n+"}, {"sha": "294e5b7af65bd8ba35ba76db46225f6f98955d87", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -1470,7 +1470,7 @@ general_init (const char *argv0)\n \n   /* This must be done after add_params but before argument processing.  */\n   init_ggc_heuristics();\n-  init_tree_optimization_passes ();\n+  init_optimization_passes ();\n }\n \n /* Process the options that have been parsed.  */"}, {"sha": "48339dbd86ba074cc425a4c2066bb2063be0c19b", "filename": "gcc/toplev.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -69,7 +69,7 @@ extern void verbatim (const char *, ...) ATTRIBUTE_GCC_DIAG(1,2);\n extern void rest_of_decl_compilation (tree, int, int);\n extern void rest_of_type_compilation (tree, int);\n extern void tree_rest_of_compilation (tree);\n-extern void init_tree_optimization_passes (void);\n+extern void init_optimization_passes (void);\n extern void finish_optimization_passes (void);\n extern bool enable_rtl_dump_file (int);\n "}, {"sha": "a92dcbc35ddaa259fadd37b4dfe529f9518c470e", "filename": "gcc/tracer.c", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -48,6 +48,7 @@\n #include \"timevar.h\"\n #include \"params.h\"\n #include \"coverage.h\"\n+#include \"tree-pass.h\"\n \n static int count_insns (basic_block);\n static bool ignore_bb_p (basic_block);\n@@ -365,8 +366,6 @@ tracer (unsigned int flags)\n   if (n_basic_blocks <= 1)\n     return;\n \n-  timevar_push (TV_TRACER);\n-\n   cfg_layout_initialize (flags);\n   mark_dfs_back_edges ();\n   if (dump_file)\n@@ -379,6 +378,39 @@ tracer (unsigned int flags)\n \n   /* Merge basic blocks in duplicated traces.  */\n   cleanup_cfg (CLEANUP_EXPENSIVE);\n+}\n+\f\n+static bool\n+gate_handle_tracer (void)\n+{\n+  return (optimize > 0 && flag_tracer);\n+}\n \n-  timevar_pop (TV_TRACER);\n+/* Run tracer.  */\n+static void\n+rest_of_handle_tracer (void)\n+{\n+  if (dump_file)\n+    dump_flow_info (dump_file);\n+  tracer (0);\n+  cleanup_cfg (CLEANUP_EXPENSIVE);\n+  reg_scan (get_insns (), max_reg_num ());\n }\n+\n+struct tree_opt_pass pass_tracer =\n+{\n+  \"tracer\",                             /* name */\n+  gate_handle_tracer,                   /* gate */\n+  rest_of_handle_tracer,                /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_TRACER,                            /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func,                       /* todo_flags_finish */\n+  'T'                                   /* letter */\n+};\n+"}, {"sha": "3f6592bd30644188bf6c5b5e0a804e732a045c03", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -713,43 +713,6 @@ static struct dump_file_info dump_files[TDI_end] =\n   {NULL, \"ipa-all\", NULL, TDF_IPA, 0, 0, 0},\n \n   { \".cgraph\", \"ipa-cgraph\", NULL,\tTDF_IPA, 0,  0, 0},\n-\n-  { \".sibling\", \"rtl-sibling\", NULL,\tTDF_RTL, 0,  1, 'i'},\n-  { \".eh\", \"rtl-eh\", NULL,\t\tTDF_RTL, 0,  2, 'h'},\n-  { \".jump\", \"rtl-jump\", NULL,\t\tTDF_RTL, 0,  3, 'j'},\n-  { \".cse\", \"rtl-cse\", NULL,    \t TDF_RTL, 0,  4, 's'},\n-  { \".gcse\", \"rtl-gcse\", NULL,\t\tTDF_RTL, 0,  5, 'G'},\n-  { \".loop\", \"rtl-loop\", NULL,\t\tTDF_RTL, 0,  6, 'L'},\n-  { \".bypass\", \"rtl-bypass\", NULL,\t\tTDF_RTL, 0,  7, 'G'},\n-  { \".cfg\", \"rtl-cfg\", NULL,\t\t\tTDF_RTL, 0,  8, 'f'},\n-  { \".bp\", \"rtl-bp\", NULL,\t\t\tTDF_RTL, 0,  9, 'b'},\n-  { \".vpt\", \"rtl-vpt\", NULL,\t\t\tTDF_RTL, 0, 10, 'V'},\n-  { \".ce1\", \"rtl-ce1\", NULL,\t\t\tTDF_RTL, 0, 11, 'C'},\n-  { \".tracer\", \"rtl-tracer\", NULL,\t\tTDF_RTL, 0, 12, 'T'},\n-  { \".loop2\", \"rtl-loop2\", NULL,\t\tTDF_RTL, 0, 13, 'L'},\n-  { \".web\", \"rtl-web\", NULL,\t\t\tTDF_RTL, 0, 14, 'Z'},\n-  { \".cse2\", \"rtl-cse2\", NULL,\t\tTDF_RTL, 0, 15, 't'},\n-  { \".life\", \"rtl-life\", NULL,\t\tTDF_RTL, 0, 16, 'f'},\n-  { \".combine\", \"rtl-combine\", NULL,\t\tTDF_RTL, 0, 17, 'c'},\n-  { \".ce2\", \"rtl-ce2\", NULL,\t\t\tTDF_RTL, 0, 18, 'C'},\n-  { \".regmove\", \"rtl-regmove\", NULL,\t\tTDF_RTL, 0, 19, 'N'},\n-  { \".sms\", \"rtl-sms\", NULL,\t\t\tTDF_RTL, 0, 20, 'm'},\n-  { \".sched\", \"rtl-sched\", NULL,\t\tTDF_RTL, 0, 21, 'S'},\n-  { \".lreg\", \"rtl-lreg\", NULL,\t\tTDF_RTL, 0, 22, 'l'},\n-  { \".greg\", \"rtl-greg\", NULL,\t\tTDF_RTL, 0, 23, 'g'},\n-  { \".postreload\", \"rtl-postreload\", NULL,\tTDF_RTL, 0, 24, 'o'},\n-  { \".gcse2\", \"rtl-gcse2\", NULL,\t\tTDF_RTL, 0, 25, 'J'},\n-  { \".flow2\", \"rtl-flow2\", NULL,\t\tTDF_RTL, 0, 26, 'w'},\n-  { \".peephole2\", \"rtl-peephole2\", NULL,\tTDF_RTL, 0, 27, 'z'},\n-  { \".ce3\", \"rtl-ce3\", NULL,\t\t\tTDF_RTL, 0, 28, 'E'},\n-  { \".rnreg\", \"rtl-rnreg\", NULL,\t\tTDF_RTL, 0, 29, 'n'},\n-  { \".bbro\", \"rtl-bbro\", NULL,\t\tTDF_RTL, 0, 30, 'B'},\n-  { \".btl\", \"rtl-btl\", NULL,\t\t\tTDF_RTL, 0, 31, 'd'},\n-  { \".sched2\", \"rtl-sched2\", NULL,\t\tTDF_RTL, 0, 32, 'R'},\n-  { \".stack\", \"rtl-stack\", NULL,\t\tTDF_RTL, 0, 33, 'k'},\n-  { \".vartrack\", \"rtl-vartrack\", NULL,\tTDF_RTL, 0, 34, 'V'},\n-  { \".mach\", \"rtl-mach\", NULL,\t\tTDF_RTL, 0, 35, 'M'},\n-  { \".dbr\", \"rtl-dbr\", NULL,\t\t\tTDF_RTL, 0, 36, 'd'}\n };\n \n /* Dynamically registered tree dump files and switches.  */"}, {"sha": "bc226937b30f3b66df3c7028a443514239519ee1", "filename": "gcc/tree-dump.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Ftree-dump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Ftree-dump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.h?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -23,6 +23,9 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #define GCC_TREE_DUMP_H\n \n #include \"splay-tree.h\"\n+#include \"tree-pass.h\"\n+\n+typedef struct dump_info *dump_info_p;\n \n /* Flags used with queue functions.  */\n #define DUMP_NONE     0\n@@ -88,6 +91,7 @@ extern void queue_and_dump_index (dump_info_p, const char *, tree, int);\n extern void queue_and_dump_type (dump_info_p, tree);\n extern void dump_function (enum tree_dump_index, tree);\n extern void dump_function_to_file (tree, FILE *, int);\n+extern int dump_flag (dump_info_p, int, tree);\n \n extern unsigned int dump_register (const char *, const char *, const char *, \n \t\t\t\t   int, unsigned int, int);"}, {"sha": "4b23a82fbf01da50f551d60eb1b1abec9f6d446f", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 9, "deletions": 504, "changes": 513, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -50,12 +50,6 @@ Boston, MA 02110-1301, USA.  */\n #include \"cfgloop.h\"\n #include \"except.h\"\n \n-/* Global variables used to communicate with passes.  */\n-int dump_flags;\n-bool in_gimple_form;\n-\n-/* The root of the compilation pass tree, once constructed.  */\n-static struct tree_opt_pass *all_passes, *all_ipa_passes, *all_lowering_passes;\n \n /* Gate: execute, or not, all of the non-trivial optimizations.  */\n \n@@ -67,7 +61,7 @@ gate_all_optimizations (void)\n \t  && !(errorcount || sorrycount));\n }\n \n-static struct tree_opt_pass pass_all_optimizations =\n+struct tree_opt_pass pass_all_optimizations =\n {\n   NULL,\t\t\t\t\t/* name */\n   gate_all_optimizations,\t\t/* gate */\n@@ -84,7 +78,7 @@ static struct tree_opt_pass pass_all_optimizations =\n   0\t\t\t\t\t/* letter */\n };\n \n-static struct tree_opt_pass pass_early_local_passes =\n+struct tree_opt_pass pass_early_local_passes =\n {\n   NULL,\t\t\t\t\t/* name */\n   gate_all_optimizations,\t\t/* gate */\n@@ -112,7 +106,7 @@ execute_cleanup_cfg_pre_ipa (void)\n   cleanup_tree_cfg ();\n }\n \n-static struct tree_opt_pass pass_cleanup_cfg =\n+struct tree_opt_pass pass_cleanup_cfg =\n {\n   \"cleanup_cfg\",\t\t\t/* name */\n   NULL,\t\t\t\t\t/* gate */\n@@ -143,7 +137,7 @@ execute_cleanup_cfg_post_optimizing (void)\n   group_case_labels ();\n }\n \n-static struct tree_opt_pass pass_cleanup_cfg_post_optimizing =\n+struct tree_opt_pass pass_cleanup_cfg_post_optimizing =\n {\n   \"final_cleanup\",\t\t\t/* name */\n   NULL,\t\t\t\t\t/* gate */\n@@ -176,7 +170,7 @@ execute_free_datastructures (void)\n   delete_tree_ssa ();\n }\n \n-static struct tree_opt_pass pass_free_datastructures =\n+struct tree_opt_pass pass_free_datastructures =\n {\n   NULL,\t\t\t\t\t/* name */\n   NULL,\t\t\t\t\t/* gate */\n@@ -216,7 +210,7 @@ execute_free_cfg_annotations (void)\n   delete_tree_cfg_annotations ();\n }\n \n-static struct tree_opt_pass pass_free_cfg_annotations =\n+struct tree_opt_pass pass_free_cfg_annotations =\n {\n   NULL,\t\t\t\t\t/* name */\n   NULL,\t\t\t\t\t/* gate */\n@@ -261,7 +255,7 @@ execute_fixup_cfg (void)\n   cleanup_tree_cfg ();\n }\n \n-static struct tree_opt_pass pass_fixup_cfg =\n+struct tree_opt_pass pass_fixup_cfg =\n {\n   NULL,\t\t\t\t\t/* name */\n   NULL,\t\t\t\t\t/* gate */\n@@ -288,7 +282,7 @@ execute_init_datastructures (void)\n   init_tree_ssa ();\n }\n \n-static struct tree_opt_pass pass_init_datastructures =\n+struct tree_opt_pass pass_init_datastructures =\n {\n   NULL,\t\t\t\t\t/* name */\n   NULL,\t\t\t\t\t/* gate */\n@@ -305,484 +299,7 @@ static struct tree_opt_pass pass_init_datastructures =\n   0\t\t\t\t\t/* letter */\n };\n \n-/* Iterate over the pass tree allocating dump file numbers.  We want\n-   to do this depth first, and independent of whether the pass is\n-   enabled or not.  */\n-\n-static void\n-register_one_dump_file (struct tree_opt_pass *pass, bool ipa, int n)\n-{\n-  char *dot_name, *flag_name, *glob_name;\n-  char num[10];\n-\n-  /* See below in next_pass_1.  */\n-  num[0] = '\\0';\n-  if (pass->static_pass_number != -1)\n-    sprintf (num, \"%d\", ((int) pass->static_pass_number < 0\n-\t\t\t ? 1 : pass->static_pass_number));\n-\n-  dot_name = concat (\".\", pass->name, num, NULL);\n-  if (ipa)\n-    {\n-      flag_name = concat (\"ipa-\", pass->name, num, NULL);\n-      glob_name = concat (\"ipa-\", pass->name, NULL);\n-      /* First IPA dump is cgraph that is dumped via separate channels.  */\n-      pass->static_pass_number = dump_register (dot_name, flag_name, glob_name,\n-                                                TDF_IPA, n + 1, 0);\n-    }\n-  else if (pass->properties_provided & PROP_trees)\n-    {\n-      flag_name = concat (\"tree-\", pass->name, num, NULL);\n-      glob_name = concat (\"tree-\", pass->name, NULL);\n-      pass->static_pass_number = dump_register (dot_name, flag_name, glob_name,\n-                                                TDF_TREE, n + TDI_tree_all, 0);\n-    }\n-  else\n-    {\n-      flag_name = concat (\"rtl-\", pass->name, num, NULL);\n-      glob_name = concat (\"rtl-\", pass->name, NULL);\n-      pass->static_pass_number = dump_register (dot_name, flag_name, glob_name,\n-                                                TDF_RTL, n, pass->letter);\n-    }\n-}\n-\n-static int \n-register_dump_files (struct tree_opt_pass *pass, bool ipa, int properties)\n-{\n-  static int n = 0;\n-  do\n-    {\n-      int new_properties;\n-      int pass_number;\n-\n-      pass->properties_required = properties;\n-      new_properties =\n-        (properties | pass->properties_provided) & ~pass->properties_destroyed;\n-\n-      /* Reset the counter when we reach RTL-based passes.  */\n-      if ((pass->properties_provided ^ pass->properties_required) & PROP_rtl)\n-        n = 0;\n-\n-      pass_number = n;\n-      if (pass->name)\n-        n++;\n-\n-      if (pass->sub)\n-        new_properties = register_dump_files (pass->sub, false, new_properties);\n-\n-      /* If we have a gate, combine the properties that we could have with\n-         and without the pass being examined.  */\n-      if (pass->gate)\n-        properties &= new_properties;\n-      else\n-        properties = new_properties;\n-\n-      pass->properties_provided = properties;\n-      if (pass->name)\n-        register_one_dump_file (pass, ipa, pass_number);\n-\n-      pass = pass->next;\n-    }\n-  while (pass);\n-\n-  return properties;\n-}\n-\n-/* Add a pass to the pass list. Duplicate the pass if it's already\n-   in the list.  */\n-\n-static struct tree_opt_pass **\n-next_pass_1 (struct tree_opt_pass **list, struct tree_opt_pass *pass)\n-{\n-\n-  /* A nonzero static_pass_number indicates that the\n-     pass is already in the list.  */\n-  if (pass->static_pass_number)\n-    {\n-      struct tree_opt_pass *new;\n-\n-      new = xmalloc (sizeof (*new));\n-      memcpy (new, pass, sizeof (*new));\n-\n-      /* Indicate to register_dump_files that this pass has duplicates,\n-         and so it should rename the dump file.  The first instance will\n-         be -1, and be number of duplicates = -static_pass_number - 1.\n-         Subsequent instances will be > 0 and just the duplicate number.  */\n-      if (pass->name)\n-        {\n-          pass->static_pass_number -= 1;\n-          new->static_pass_number = -pass->static_pass_number;\n-\t}\n-      \n-      *list = new;\n-    }\n-  else\n-    {\n-      pass->static_pass_number = -1;\n-      *list = pass;\n-    }  \n-  \n-  return &(*list)->next;\n-          \n-}\n-\n-/* Construct the pass tree.  */\n-\n-void\n-init_tree_optimization_passes (void)\n-{\n-  struct tree_opt_pass **p;\n-\n-#define NEXT_PASS(PASS)  (p = next_pass_1 (p, &PASS))\n-  /* Interprocedural optimization passes.  */\n-  p = &all_ipa_passes;\n-  NEXT_PASS (pass_early_ipa_inline);\n-  NEXT_PASS (pass_early_local_passes);\n-  NEXT_PASS (pass_ipa_inline);\n-  *p = NULL;\n-\n-  /* All passes needed to lower the function into shape optimizers can operate\n-     on.  These passes are performed before interprocedural passes, unlike rest\n-     of local passes (all_passes).  */\n-  p = &all_lowering_passes;\n-  NEXT_PASS (pass_remove_useless_stmts);\n-  NEXT_PASS (pass_mudflap_1);\n-  NEXT_PASS (pass_lower_cf); \n-  NEXT_PASS (pass_lower_eh); \n-  NEXT_PASS (pass_build_cfg); \n-  NEXT_PASS (pass_lower_complex_O0);\n-  NEXT_PASS (pass_lower_vector);\n-  NEXT_PASS (pass_warn_function_return);\n-  NEXT_PASS (pass_early_tree_profile);\n-  *p = NULL;\n-\n-  p = &pass_early_local_passes.sub;\n-  NEXT_PASS (pass_tree_profile);\n-  NEXT_PASS (pass_cleanup_cfg);\n-  NEXT_PASS (pass_rebuild_cgraph_edges);\n-  *p = NULL;\n-\n-  p = &all_passes;\n-  NEXT_PASS (pass_fixup_cfg);\n-  NEXT_PASS (pass_init_datastructures);\n-  NEXT_PASS (pass_all_optimizations);\n-  NEXT_PASS (pass_warn_function_noreturn);\n-  NEXT_PASS (pass_mudflap_2);\n-  NEXT_PASS (pass_free_datastructures);\n-  NEXT_PASS (pass_free_cfg_annotations);\n-  NEXT_PASS (pass_expand);\n-  NEXT_PASS (pass_rest_of_compilation);\n-  *p = NULL;\n-\n-  p = &pass_all_optimizations.sub;\n-  NEXT_PASS (pass_referenced_vars);\n-  NEXT_PASS (pass_create_structure_vars);\n-  NEXT_PASS (pass_build_ssa);\n-  NEXT_PASS (pass_build_pta);  \n-  NEXT_PASS (pass_may_alias);\n-  NEXT_PASS (pass_return_slot);\n-  NEXT_PASS (pass_del_pta);  \n-  NEXT_PASS (pass_rename_ssa_copies);\n-  NEXT_PASS (pass_early_warn_uninitialized);\n-\n-  /* Initial scalar cleanups.  */\n-  NEXT_PASS (pass_ccp);\n-  NEXT_PASS (pass_fre);\n-  NEXT_PASS (pass_dce);\n-  NEXT_PASS (pass_forwprop);\n-  NEXT_PASS (pass_copy_prop);\n-  NEXT_PASS (pass_vrp);\n-  NEXT_PASS (pass_dce);\n-  NEXT_PASS (pass_merge_phi);\n-  NEXT_PASS (pass_dominator);\n-\n-  NEXT_PASS (pass_phiopt);\n-  NEXT_PASS (pass_build_pta);  \n-  NEXT_PASS (pass_may_alias);\n-  NEXT_PASS (pass_del_pta);  \n-  NEXT_PASS (pass_tail_recursion);\n-  NEXT_PASS (pass_profile);\n-  NEXT_PASS (pass_ch);\n-  NEXT_PASS (pass_stdarg);\n-  NEXT_PASS (pass_lower_complex);\n-  NEXT_PASS (pass_sra);\n-  /* FIXME: SRA may generate arbitrary gimple code, exposing new\n-     aliased and call-clobbered variables.  As mentioned below,\n-     pass_may_alias should be a TODO item.  */\n-  NEXT_PASS (pass_may_alias);\n-  NEXT_PASS (pass_rename_ssa_copies);\n-  NEXT_PASS (pass_dominator);\n-  NEXT_PASS (pass_copy_prop);\n-  NEXT_PASS (pass_dce);\n-  NEXT_PASS (pass_dse);\n-  NEXT_PASS (pass_may_alias);\n-  NEXT_PASS (pass_forwprop);\n-  NEXT_PASS (pass_phiopt);\n-  NEXT_PASS (pass_object_sizes);\n-  NEXT_PASS (pass_store_ccp);\n-  NEXT_PASS (pass_store_copy_prop);\n-  NEXT_PASS (pass_fold_builtins);\n-  /* FIXME: May alias should a TODO but for 4.0.0,\n-     we add may_alias right after fold builtins\n-     which can create arbitrary GIMPLE.  */\n-  NEXT_PASS (pass_may_alias);\n-  NEXT_PASS (pass_cse_reciprocals);\n-  NEXT_PASS (pass_split_crit_edges);\n-  NEXT_PASS (pass_reassoc);\n-  NEXT_PASS (pass_pre);\n-  NEXT_PASS (pass_sink_code);\n-  NEXT_PASS (pass_loop);\n-  NEXT_PASS (pass_dominator);\n-  NEXT_PASS (pass_copy_prop);\n-  NEXT_PASS (pass_cd_dce);\n-  /* FIXME: If DCE is not run before checking for uninitialized uses,\n-     we may get false warnings (e.g., testsuite/gcc.dg/uninit-5.c).\n-     However, this also causes us to misdiagnose cases that should be\n-     real warnings (e.g., testsuite/gcc.dg/pr18501.c).\n-     \n-     To fix the false positives in uninit-5.c, we would have to\n-     account for the predicates protecting the set and the use of each\n-     variable.  Using a representation like Gated Single Assignment\n-     may help.  */\n-  NEXT_PASS (pass_late_warn_uninitialized);\n-  NEXT_PASS (pass_dse);\n-  NEXT_PASS (pass_forwprop);\n-  NEXT_PASS (pass_phiopt);\n-  NEXT_PASS (pass_tail_calls);\n-  NEXT_PASS (pass_rename_ssa_copies);\n-  NEXT_PASS (pass_uncprop);\n-  NEXT_PASS (pass_del_ssa);\n-  NEXT_PASS (pass_nrv);\n-  NEXT_PASS (pass_remove_useless_vars);\n-  NEXT_PASS (pass_mark_used_blocks);\n-  NEXT_PASS (pass_cleanup_cfg_post_optimizing);\n-  *p = NULL;\n-\n-  p = &pass_loop.sub;\n-  NEXT_PASS (pass_loop_init);\n-  NEXT_PASS (pass_copy_prop);\n-  NEXT_PASS (pass_lim);\n-  NEXT_PASS (pass_unswitch);\n-  NEXT_PASS (pass_scev_cprop);\n-  NEXT_PASS (pass_record_bounds);\n-  NEXT_PASS (pass_linear_transform);\n-  NEXT_PASS (pass_iv_canon);\n-  NEXT_PASS (pass_if_conversion);\n-  NEXT_PASS (pass_vectorize);\n-  /* NEXT_PASS (pass_may_alias) cannot be done again because the\n-     vectorizer creates alias relations that are not supported by\n-     pass_may_alias.  */\n-  NEXT_PASS (pass_lower_vector_ssa);\n-  NEXT_PASS (pass_complete_unroll);\n-  NEXT_PASS (pass_iv_optimize);\n-  NEXT_PASS (pass_loop_done);\n-  *p = NULL;\n-\n-#undef NEXT_PASS\n-\n-  register_dump_files (all_lowering_passes, false, PROP_gimple_any);\n-  register_dump_files (all_passes, false, PROP_gimple_any\n-\t\t\t\t\t  | PROP_gimple_lcf\n-\t\t\t\t\t  | PROP_gimple_leh\n-\t\t\t\t\t  | PROP_cfg);\n-  register_dump_files (all_ipa_passes, true, PROP_gimple_any\n-\t\t\t\t\t     | PROP_gimple_lcf\n-\t\t\t\t\t     | PROP_gimple_leh\n-\t\t\t\t\t     | PROP_cfg);\n-}\n-\n-static unsigned int last_verified;\n-\n-static void\n-execute_todo (struct tree_opt_pass *pass, unsigned int flags, bool use_required)\n-{\n-  int properties \n-    = use_required ? pass->properties_required : pass->properties_provided;\n-\n-#if defined ENABLE_CHECKING\n-  if (need_ssa_update_p ())\n-    gcc_assert (flags & TODO_update_ssa_any);\n-#endif\n-\n-  if (flags & TODO_update_ssa_any)\n-    {\n-      unsigned update_flags = flags & TODO_update_ssa_any;\n-      update_ssa (update_flags);\n-    }\n-\n-  if (flags & TODO_cleanup_cfg)\n-    {\n-      if (current_loops)\n-\tcleanup_tree_cfg_loop ();\n-      else\n-\tcleanup_tree_cfg ();\n-    }\n-\n-  if ((flags & TODO_dump_func)\n-      && dump_file && current_function_decl)\n-    {\n-      if (properties & PROP_trees)\n-        dump_function_to_file (current_function_decl,\n-                               dump_file, dump_flags);\n-      else if (properties & PROP_cfg)\n-        print_rtl_with_bb (dump_file, get_insns ());\n-      else\n-        print_rtl (dump_file, get_insns ());\n-\n-      /* Flush the file.  If verification fails, we won't be able to\n-\t close the file before dieing.  */\n-      fflush (dump_file);\n-    }\n-  if ((flags & TODO_dump_cgraph)\n-      && dump_file && !current_function_decl)\n-    {\n-      dump_cgraph (dump_file);\n-      /* Flush the file.  If verification fails, we won't be able to\n-\t close the file before aborting.  */\n-      fflush (dump_file);\n-    }\n-\n-  if (flags & TODO_ggc_collect)\n-    {\n-      ggc_collect ();\n-    }\n-\n-#if defined ENABLE_CHECKING\n-  if ((pass->properties_required & PROP_ssa)\n-      && !(pass->properties_destroyed & PROP_ssa))\n-    verify_ssa (true);\n-  if (flags & TODO_verify_flow)\n-    verify_flow_info ();\n-  if (flags & TODO_verify_stmts)\n-    verify_stmts ();\n-  if (flags & TODO_verify_loops)\n-    verify_loop_closed_ssa ();\n-#endif\n-}\n-\n-static bool\n-execute_one_pass (struct tree_opt_pass *pass)\n-{\n-  unsigned int todo; \n-\n-  /* See if we're supposed to run this pass.  */\n-  if (pass->gate && !pass->gate ())\n-    return false;\n-\n-  /* Note that the folders should only create gimple expressions.\n-     This is a hack until the new folder is ready.  */\n-  in_gimple_form = (pass->properties_provided & PROP_trees) != 0;\n-\n-  /* Run pre-pass verification.  */\n-  todo = pass->todo_flags_start & ~last_verified;\n-  if (todo)\n-    execute_todo (pass, todo, true);\n-\n-  /* If a dump file name is present, open it if enabled.  */\n-  if (pass->static_pass_number != -1)\n-    {\n-      bool initializing_dump = !dump_initialized_p (pass->static_pass_number);\n-      dump_file_name = get_dump_file_name (pass->static_pass_number);\n-      dump_file = dump_begin (pass->static_pass_number, &dump_flags);\n-      if (dump_file && current_function_decl)\n-\t{\n-\t  const char *dname, *aname;\n-\t  dname = lang_hooks.decl_printable_name (current_function_decl, 2);\n-\t  aname = (IDENTIFIER_POINTER\n-\t\t   (DECL_ASSEMBLER_NAME (current_function_decl)));\n-\t  fprintf (dump_file, \"\\n;; Function %s (%s)%s\\n\\n\", dname, aname,\n-\t     cfun->function_frequency == FUNCTION_FREQUENCY_HOT\n-\t     ? \" (hot)\"\n-\t     : cfun->function_frequency == FUNCTION_FREQUENCY_UNLIKELY_EXECUTED\n-\t     ? \" (unlikely executed)\"\n-\t     : \"\");\n-\t}\n-\n-      if (initializing_dump\n-          && graph_dump_format != no_graph\n-\t  && (pass->properties_provided & (PROP_cfg | PROP_rtl))\n-\t      == (PROP_cfg | PROP_rtl))\n-        clean_graph_dump_file (dump_file_name);\n-    }\n-\n-  /* If a timevar is present, start it.  */\n-  if (pass->tv_id)\n-    timevar_push (pass->tv_id);\n-\n-  /* Do it!  */\n-  if (pass->execute)\n-    pass->execute ();\n-\n-  /* Stop timevar.  */\n-  if (pass->tv_id)\n-    timevar_pop (pass->tv_id);\n-\n-  if (dump_file\n-      && (pass->properties_provided & (PROP_cfg | PROP_rtl))\n-\t  == (PROP_cfg | PROP_rtl))\n-    print_rtl_with_bb (dump_file, get_insns ());\n-\n-  /* Run post-pass cleanup and verification.  */\n-  todo = pass->todo_flags_finish;\n-  last_verified = todo & TODO_verify_all;\n-  if (todo)\n-    execute_todo (pass, todo, false);\n-\n-  /* Flush and close dump file.  */\n-  if (dump_file_name)\n-    {\n-      free ((char *) dump_file_name);\n-      dump_file_name = NULL;\n-    }\n-  if (dump_file)\n-    {\n-      dump_end (pass->static_pass_number, dump_file);\n-      dump_file = NULL;\n-    }\n-\n-  return true;\n-}\n-\n-static void\n-execute_pass_list (struct tree_opt_pass *pass)\n-{\n-  do\n-    {\n-      if (execute_one_pass (pass) && pass->sub)\n-        execute_pass_list (pass->sub);\n-      pass = pass->next;\n-    }\n-  while (pass);\n-}\n-\n-/* Same as execute_pass_list but assume that subpasses of IPA passes\n-   are local passes.  */\n-static void\n-execute_ipa_pass_list (struct tree_opt_pass *pass)\n-{\n-  do\n-    {\n-      if (execute_one_pass (pass) && pass->sub)\n-\t{\n-\t  struct cgraph_node *node;\n-\t  for (node = cgraph_nodes; node; node = node->next)\n-\t    if (node->analyzed)\n-\t      {\n-\t\tpush_cfun (DECL_STRUCT_FUNCTION (node->decl));\n-\t\tcurrent_function_decl = node->decl;\n-\t\texecute_pass_list (pass->sub);\n-\t\tfree_dominance_info (CDI_DOMINATORS);\n-\t\tfree_dominance_info (CDI_POST_DOMINATORS);\n-\t\tcurrent_function_decl = NULL;\n-\t\tpop_cfun ();\n-\t\tggc_collect ();\n-\t      }\n-\t}\n-      pass = pass->next;\n-    }\n-  while (pass);\n-}\n-\n+\f\n void\n tree_lowering_passes (tree fn)\n {\n@@ -800,18 +317,6 @@ tree_lowering_passes (tree fn)\n   pop_cfun ();\n }\n \n-/* Execute all IPA passes.  */\n-void\n-ipa_passes (void)\n-{\n-  cfun = NULL;\n-  tree_register_cfg_hooks ();\n-  bitmap_obstack_initialize (NULL);\n-  execute_ipa_pass_list (all_ipa_passes);\n-  bitmap_obstack_release (NULL);\n-}\n-\f\n-\n /* Update recursively all inlined_to pointers of functions\n    inlined into NODE to INLINED_TO.  */\n static void"}, {"sha": "80f4a05abcc849134b8b3c73e01451c41ae52710", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 133, "deletions": 1, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -23,6 +23,59 @@ Boston, MA 02110-1301, USA.  */\n #ifndef GCC_TREE_PASS_H\n #define GCC_TREE_PASS_H 1\n \n+/* In tree-dump.c */\n+\n+/* Different tree dump places.  When you add new tree dump places,\n+   extend the DUMP_FILES array in tree-dump.c.  */\n+enum tree_dump_index\n+{\n+  TDI_none,\t\t\t/* No dump */\n+  TDI_tu,\t\t\t/* dump the whole translation unit.  */\n+  TDI_class,\t\t\t/* dump class hierarchy.  */\n+  TDI_original,\t\t\t/* dump each function before optimizing it */\n+  TDI_generic,\t\t\t/* dump each function after genericizing it */\n+  TDI_nested,\t\t\t/* dump each function after unnesting it */\n+  TDI_inlined,\t\t\t/* dump each function after inlining\n+\t\t\t\t   within it.  */\n+  TDI_vcg,\t\t\t/* create a VCG graph file for each\n+\t\t\t\t   function's flowgraph.  */\n+  TDI_tree_all,                 /* enable all the GENERIC/GIMPLE dumps.  */\n+  TDI_rtl_all,                  /* enable all the RTL dumps.  */\n+  TDI_ipa_all,                  /* enable all the IPA dumps.  */\n+\n+  TDI_cgraph,                   /* dump function call graph.  */\n+  TDI_end\n+};\n+\n+/* Bit masks to control dumping. Not all values are applicable to\n+   all dumps. Add new ones at the end. When you define new\n+   values, extend the DUMP_OPTIONS array in tree-dump.c */\n+#define TDF_ADDRESS\t(1 << 0)\t/* dump node addresses */\n+#define TDF_SLIM\t(1 << 1)\t/* don't go wild following links */\n+#define TDF_RAW  \t(1 << 2)\t/* don't unparse the function */\n+#define TDF_DETAILS\t(1 << 3)\t/* show more detailed info about\n+\t\t\t\t\t   each pass */\n+#define TDF_STATS\t(1 << 4)\t/* dump various statistics about\n+\t\t\t\t\t   each pass */\n+#define TDF_BLOCKS\t(1 << 5)\t/* display basic block boundaries */\n+#define TDF_VOPS\t(1 << 6)\t/* display virtual operands */\n+#define TDF_LINENO\t(1 << 7)\t/* display statement line numbers */\n+#define TDF_UID\t\t(1 << 8)\t/* display decl UIDs */\n+\n+#define TDF_TREE\t(1 << 9)\t/* is a tree dump */\n+#define TDF_RTL\t\t(1 << 10)\t/* is a RTL dump */\n+#define TDF_IPA\t\t(1 << 11)\t/* is an IPA dump */\n+#define TDF_STMTADDR\t(1 << 12)\t/* Address of stmt.  */\n+\n+extern char *get_dump_file_name (enum tree_dump_index);\n+extern int dump_enabled_p (enum tree_dump_index);\n+extern int dump_initialized_p (enum tree_dump_index);\n+extern FILE *dump_begin (enum tree_dump_index, int *);\n+extern void dump_end (enum tree_dump_index, FILE *);\n+extern void dump_node (tree, int, FILE *);\n+extern int dump_switch_p (const char *);\n+extern const char *dump_flag_name (enum tree_dump_index);\n+\n /* Global variables used to communicate with passes.  */\n extern FILE *dump_file;\n extern int dump_flags;\n@@ -154,7 +207,6 @@ struct dump_file_info\n #define TODO_verify_all \\\n   (TODO_verify_ssa | TODO_verify_flow | TODO_verify_stmts)\n \n-extern void ipa_passes (void);\n extern void tree_lowering_passes (tree decl);\n \n extern struct tree_opt_pass pass_mudflap_1;\n@@ -165,6 +217,7 @@ extern struct tree_opt_pass pass_lower_eh;\n extern struct tree_opt_pass pass_build_cfg;\n extern struct tree_opt_pass pass_tree_profile;\n extern struct tree_opt_pass pass_early_tree_profile;\n+extern struct tree_opt_pass pass_cleanup_cfg;\n extern struct tree_opt_pass pass_referenced_vars;\n extern struct tree_opt_pass pass_sra;\n extern struct tree_opt_pass pass_tail_recursion;\n@@ -233,5 +286,84 @@ extern struct tree_opt_pass pass_rebuild_cgraph_edges;\n /* IPA Passes */\n extern struct tree_opt_pass pass_ipa_inline;\n extern struct tree_opt_pass pass_early_ipa_inline;\n+extern struct tree_opt_pass pass_early_local_passes;\n+\n+extern struct tree_opt_pass pass_all_optimizations;\n+extern struct tree_opt_pass pass_cleanup_cfg_post_optimizing;\n+extern struct tree_opt_pass pass_free_cfg_annotations;\n+extern struct tree_opt_pass pass_free_datastructures;\n+extern struct tree_opt_pass pass_init_datastructures;\n+extern struct tree_opt_pass pass_fixup_cfg;\n+\n+extern struct tree_opt_pass pass_remove_unnecessary_notes;\n+extern struct tree_opt_pass pass_init_function;\n+extern struct tree_opt_pass pass_jump;\n+extern struct tree_opt_pass pass_insn_locators_initialize;\n+extern struct tree_opt_pass pass_rtl_eh;\n+extern struct tree_opt_pass pass_initial_value_sets;\n+extern struct tree_opt_pass pass_unshare_all_rtl;\n+extern struct tree_opt_pass pass_instantiate_virtual_regs;\n+extern struct tree_opt_pass pass_jump2;\n+extern struct tree_opt_pass pass_cse;\n+extern struct tree_opt_pass pass_gcse;\n+extern struct tree_opt_pass pass_loop_optimize;\n+extern struct tree_opt_pass pass_jump_bypass;\n+extern struct tree_opt_pass pass_cfg;\n+extern struct tree_opt_pass pass_profiling;\n+extern struct tree_opt_pass pass_rtl_ifcvt;\n+extern struct tree_opt_pass pass_tracer;\n+extern struct tree_opt_pass pass_loop2;\n+extern struct tree_opt_pass pass_web;\n+extern struct tree_opt_pass pass_cse2;\n+extern struct tree_opt_pass pass_life;\n+extern struct tree_opt_pass pass_combine;\n+extern struct tree_opt_pass pass_if_after_combine;\n+extern struct tree_opt_pass pass_partition_blocks;\n+extern struct tree_opt_pass pass_partition_blocks;\n+extern struct tree_opt_pass pass_regmove;\n+extern struct tree_opt_pass pass_split_all_insns;\n+extern struct tree_opt_pass pass_mode_switching;\n+extern struct tree_opt_pass pass_recompute_reg_usage;\n+extern struct tree_opt_pass pass_sms;\n+extern struct tree_opt_pass pass_sched;\n+extern struct tree_opt_pass pass_local_alloc;\n+extern struct tree_opt_pass pass_global_alloc;\n+extern struct tree_opt_pass pass_postreload;\n+extern struct tree_opt_pass pass_clean_state;\n+extern struct tree_opt_pass pass_branch_prob;\n+extern struct tree_opt_pass pass_value_profile_transformations;\n+extern struct tree_opt_pass pass_remove_death_notes;\n+extern struct tree_opt_pass pass_postreload_cse;\n+extern struct tree_opt_pass pass_gcse2;\n+extern struct tree_opt_pass pass_flow2;\n+extern struct tree_opt_pass pass_stack_adjustments;\n+extern struct tree_opt_pass pass_peephole2;\n+extern struct tree_opt_pass pass_if_after_reload;\n+extern struct tree_opt_pass pass_regrename;\n+extern struct tree_opt_pass pass_reorder_blocks;\n+extern struct tree_opt_pass pass_branch_target_load_optimize;\n+extern struct tree_opt_pass pass_leaf_regs;\n+extern struct tree_opt_pass pass_sched2;\n+extern struct tree_opt_pass pass_stack_regs;\n+extern struct tree_opt_pass pass_compute_alignments;\n+extern struct tree_opt_pass pass_duplicate_computed_gotos;\n+extern struct tree_opt_pass pass_variable_tracking;\n+extern struct tree_opt_pass pass_free_cfg;\n+extern struct tree_opt_pass pass_machine_reorg;\n+extern struct tree_opt_pass pass_purge_lineno_notes;\n+extern struct tree_opt_pass pass_cleanup_barriers;\n+extern struct tree_opt_pass pass_delay_slots;\n+extern struct tree_opt_pass pass_split_for_shorten_branches;\n+extern struct tree_opt_pass pass_split_before_regstack;\n+extern struct tree_opt_pass pass_convert_to_eh_region_ranges;\n+extern struct tree_opt_pass pass_shorten_branches;\n+extern struct tree_opt_pass pass_set_nothrow_function_flags;\n+extern struct tree_opt_pass pass_final;\n+\n+/* The root of the compilation pass tree, once constructed.  */\n+extern struct tree_opt_pass *all_passes, *all_ipa_passes, *all_lowering_passes;\n+\n+extern void execute_pass_list (struct tree_opt_pass *);\n+extern void execute_ipa_pass_list (struct tree_opt_pass *);\n \n #endif /* GCC_TREE_PASS_H */"}, {"sha": "17de6f361fcb10024997f021bd995db5119f3cdf", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -31,6 +31,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"langhooks.h\"\n #include \"tree-iterator.h\"\n #include \"tree-chrec.h\"\n+#include \"tree-pass.h\"\n \n /* Local functions, macros and variables.  */\n static int op_prio (tree);"}, {"sha": "1d5567cfc79ad28570449ff282f34a81a934fbab", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 94, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -3890,100 +3890,6 @@ typedef tree (*walk_tree_fn) (tree *, int *, void *);\n extern tree walk_tree (tree*, walk_tree_fn, void*, struct pointer_set_t*);\n extern tree walk_tree_without_duplicates (tree*, walk_tree_fn, void*);\n \n-/* In tree-dump.c */\n-\n-/* Different tree dump places.  When you add new tree dump places,\n-   extend the DUMP_FILES array in tree-dump.c.  */\n-enum tree_dump_index\n-{\n-  TDI_none,\t\t\t/* No dump */\n-  TDI_tu,\t\t\t/* dump the whole translation unit.  */\n-  TDI_class,\t\t\t/* dump class hierarchy.  */\n-  TDI_original,\t\t\t/* dump each function before optimizing it */\n-  TDI_generic,\t\t\t/* dump each function after genericizing it */\n-  TDI_nested,\t\t\t/* dump each function after unnesting it */\n-  TDI_inlined,\t\t\t/* dump each function after inlining\n-\t\t\t\t   within it.  */\n-  TDI_vcg,\t\t\t/* create a VCG graph file for each\n-\t\t\t\t   function's flowgraph.  */\n-  TDI_tree_all,                 /* enable all the GENERIC/GIMPLE dumps.  */\n-  TDI_rtl_all,                  /* enable all the RTL dumps.  */\n-  TDI_ipa_all,                  /* enable all the IPA dumps.  */\n-\n-  TDI_cgraph,                   /* dump function call graph.  */\n-\n-  DFI_MIN,                      /* For now, RTL dumps are placed here.  */\n-  DFI_sibling = DFI_MIN,\n-  DFI_eh,\n-  DFI_jump,\n-  DFI_cse,\n-  DFI_gcse,\n-  DFI_loop,\n-  DFI_bypass,\n-  DFI_cfg,\n-  DFI_bp,\n-  DFI_vpt,\n-  DFI_ce1,\n-  DFI_tracer,\n-  DFI_loop2,\n-  DFI_web,\n-  DFI_cse2,\n-  DFI_life,\n-  DFI_combine,\n-  DFI_ce2,\n-  DFI_regmove,\n-  DFI_sms,\n-  DFI_sched,\n-  DFI_lreg,\n-  DFI_greg,\n-  DFI_postreload,\n-  DFI_gcse2,\n-  DFI_flow2,\n-  DFI_peephole2,\n-  DFI_ce3,\n-  DFI_rnreg,\n-  DFI_bbro,\n-  DFI_branch_target_load,\n-  DFI_sched2,\n-  DFI_stack,\n-  DFI_vartrack,\n-  DFI_mach,\n-  DFI_dbr,\n-\n-  TDI_end\n-};\n-\n-/* Bit masks to control dumping. Not all values are applicable to\n-   all dumps. Add new ones at the end. When you define new\n-   values, extend the DUMP_OPTIONS array in tree-dump.c */\n-#define TDF_ADDRESS\t(1 << 0)\t/* dump node addresses */\n-#define TDF_SLIM\t(1 << 1)\t/* don't go wild following links */\n-#define TDF_RAW  \t(1 << 2)\t/* don't unparse the function */\n-#define TDF_DETAILS\t(1 << 3)\t/* show more detailed info about\n-\t\t\t\t\t   each pass */\n-#define TDF_STATS\t(1 << 4)\t/* dump various statistics about\n-\t\t\t\t\t   each pass */\n-#define TDF_BLOCKS\t(1 << 5)\t/* display basic block boundaries */\n-#define TDF_VOPS\t(1 << 6)\t/* display virtual operands */\n-#define TDF_LINENO\t(1 << 7)\t/* display statement line numbers */\n-#define TDF_UID\t\t(1 << 8)\t/* display decl UIDs */\n-\n-#define TDF_TREE\t(1 << 9)\t/* is a tree dump */\n-#define TDF_RTL\t\t(1 << 10)\t/* is a RTL dump */\n-#define TDF_IPA\t\t(1 << 11)\t/* is an IPA dump */\n-#define TDF_STMTADDR\t(1 << 12)\t/* Address of stmt.  */\n-\n-typedef struct dump_info *dump_info_p;\n-\n-extern char *get_dump_file_name (enum tree_dump_index);\n-extern int dump_flag (dump_info_p, int, tree);\n-extern int dump_enabled_p (enum tree_dump_index);\n-extern int dump_initialized_p (enum tree_dump_index);\n-extern FILE *dump_begin (enum tree_dump_index, int *);\n-extern void dump_end (enum tree_dump_index, FILE *);\n-extern void dump_node (tree, int, FILE *);\n-extern int dump_switch_p (const char *);\n-extern const char *dump_flag_name (enum tree_dump_index);\n /* Assign the RTX to declaration.  */\n \n extern void set_decl_rtl (tree, rtx);"}, {"sha": "f436b4a3efd63ce80f61a4b889771681b4affb4b", "filename": "gcc/value-prof.c", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -40,6 +40,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"coverage.h\"\n #include \"tree.h\"\n #include \"gcov-io.h\"\n+#include \"timevar.h\"\n+#include \"tree-pass.h\"\n \n static struct value_prof_hooks *value_prof_hooks;\n \n@@ -1798,3 +1800,40 @@ value_profile_transformations (void)\n   VEC_free (histogram_value, heap, static_values);\n   return retval;\n }\n+\f\n+static bool \n+gate_handle_value_profile_transformations (void)\n+{\n+  return flag_branch_probabilities\n+         && flag_profile_values\n+         && !flag_tree_based_profiling\n+         && (flag_value_profile_transformations\n+             || flag_speculative_prefetching);\n+}\n+\n+\n+/* Do optimizations based on expression value profiles.  */\n+static void\n+rest_of_handle_value_profile_transformations (void)\n+{\n+  if (value_profile_transformations ())\n+    cleanup_cfg (CLEANUP_EXPENSIVE);\n+}\n+\n+struct tree_opt_pass pass_value_profile_transformations =\n+{\n+  \"vpt\",                               /* name */\n+  gate_handle_value_profile_transformations,           /* gate */\n+  rest_of_handle_value_profile_transformations,        /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_VPT,                               /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func,                       /* todo_flags_finish */\n+  'V'                                   /* letter */\n+};\n+"}, {"sha": "92976dc3a814b680c727df27de48dc2b9213d350", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -104,6 +104,8 @@\n #include \"hashtab.h\"\n #include \"regs.h\"\n #include \"expr.h\"\n+#include \"timevar.h\"\n+#include \"tree-pass.h\"\n \n /* Type of micro operation.  */\n enum micro_operation_type\n@@ -2809,3 +2811,29 @@ variable_tracking_main (void)\n \n   vt_finalize ();\n }\n+\f\n+static bool\n+gate_handle_var_tracking (void)\n+{\n+  return (flag_var_tracking);\n+}\n+\n+\n+\n+struct tree_opt_pass pass_variable_tracking =\n+{\n+  \"vartrack\",                           /* name */\n+  gate_handle_var_tracking,             /* gate */\n+  variable_tracking_main,               /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_VAR_TRACKING,                      /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func,                       /* todo_flags_finish */\n+  'V'                                   /* letter */\n+};\n+"}, {"sha": "74ad0f3e82ccbbe87c6db831d0d02b332b8b87f5", "filename": "gcc/web.c", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fweb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3303124e42a68b2fb48632746242069123c852/gcc%2Fweb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fweb.c?ref=ef3303124e42a68b2fb48632746242069123c852", "patch": "@@ -56,6 +56,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"output.h\"\n #include \"df.h\"\n #include \"function.h\"\n+#include \"timevar.h\"\n+#include \"tree-pass.h\"\n \n \n /* This entry is allocated for each reference in the insn stream.  */\n@@ -271,3 +273,36 @@ web_main (void)\n   free (used);\n   df_finish (df);\n }\n+\f\n+static bool\n+gate_handle_web (void)\n+{\n+  return (optimize > 0 && flag_web);\n+}\n+\n+static void\n+rest_of_handle_web (void)\n+{\n+  web_main ();\n+  delete_trivially_dead_insns (get_insns (), max_reg_num ());\n+  cleanup_cfg (CLEANUP_EXPENSIVE);\n+  reg_scan (get_insns (), max_reg_num ());\n+}\n+\n+struct tree_opt_pass pass_web =\n+{\n+  \"web\",                                /* name */\n+  gate_handle_web,                      /* gate */\n+  rest_of_handle_web,                   /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_WEB,                               /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func,                       /* todo_flags_finish */\n+  'Z'                                   /* letter */\n+};\n+"}]}