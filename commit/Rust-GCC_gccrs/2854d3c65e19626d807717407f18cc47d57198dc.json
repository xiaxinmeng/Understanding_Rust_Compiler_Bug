{"sha": "2854d3c65e19626d807717407f18cc47d57198dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjg1NGQzYzY1ZTE5NjI2ZDgwNzcxNzQwN2YxOGNjNDdkNTcxOThkYw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2000-03-21T16:12:25Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2000-03-21T16:12:25Z"}, "message": "cxxabi.h: New header file.\n\n\t* inc/cxxabi.h: New header file. Define new-abi entry points.\n\t(__pointer_type_info::target): Rename member to ...\n\t(__pointer_type_info::type): ... here.\n\t(__base_class_info::type): Rename member to ...\n\t(__base_class_info::base): ... here.\n\t* Make-lang.in (CXX_EXTRA_HEADERS): Add cxxabi.h\n\t* cp-tree.h (CPTI_ABI): New global tree enumeration.\n\t(abi_node): New global tree node.\n\t* decl.c (abi_node): Document.\n\t(init_decl_processing): Initialize abi_node.\n\t* rtti.c (build_dynamic_cast_1): Use abi_node for new-abi.\n\t(get_vmi_pseudo_type_info): Likewise.\n\t(create_tinfo_types): Likewise.\n\t(emit_support_tinfos): Likewise.\n\t* tinfo.h (cxxabi.h): Include for new-abi.\n\tMove rtti class definitions to new header file.\n\t* tinfo.cc (abi): Use the namespace.\n\t(std): Move new abi rtti classes from here ...\n\t(__cxxabiv1): ... to here.\n\t* tinfo2.cc (cxxabi.h): Include for new-abi.\n\tMove rtti class definitions to new header file.\n\t(std): Move new abi rtti classes from here ...\n\t(__cxxabiv1): ... to here.\n\t* inc/typeinfo (__class_type_info): Move into __cxxabiv1\n\tnamespace.\n\nFrom-SVN: r32669", "tree": {"sha": "592a5d0cb1f16a27d6eb7a0d3aacb77ba5f98f68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/592a5d0cb1f16a27d6eb7a0d3aacb77ba5f98f68"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2854d3c65e19626d807717407f18cc47d57198dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2854d3c65e19626d807717407f18cc47d57198dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2854d3c65e19626d807717407f18cc47d57198dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2854d3c65e19626d807717407f18cc47d57198dc/comments", "author": null, "committer": null, "parents": [{"sha": "b8731430ae0a7458d0e7aefdee2240305facf1b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8731430ae0a7458d0e7aefdee2240305facf1b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8731430ae0a7458d0e7aefdee2240305facf1b6"}], "stats": {"total": 827, "additions": 470, "deletions": 357}, "files": [{"sha": "64a2b8a561678254c7377b6a932ebfcfa613a02e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2854d3c65e19626d807717407f18cc47d57198dc/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2854d3c65e19626d807717407f18cc47d57198dc/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2854d3c65e19626d807717407f18cc47d57198dc", "patch": "@@ -1,3 +1,31 @@\n+2000-03-21  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* inc/cxxabi.h: New header file. Define new-abi entry points.\n+\t(__pointer_type_info::target): Rename member to ...\n+\t(__pointer_type_info::type): ... here.\n+\t(__base_class_info::type): Rename member to ...\n+\t(__base_class_info::base): ... here.\n+\t* Make-lang.in (CXX_EXTRA_HEADERS): Add cxxabi.h\n+\t* cp-tree.h (CPTI_ABI): New global tree enumeration.\n+\t(abi_node): New global tree node.\n+\t* decl.c (abi_node): Document.\n+\t(init_decl_processing): Initialize abi_node.\n+\t* rtti.c (build_dynamic_cast_1): Use abi_node for new-abi.\n+\t(get_vmi_pseudo_type_info): Likewise.\n+\t(create_tinfo_types): Likewise.\n+\t(emit_support_tinfos): Likewise.\n+\t* tinfo.h (cxxabi.h): Include for new-abi.\n+\tMove rtti class definitions to new header file.\n+\t* tinfo.cc (abi): Use the namespace.\n+\t(std): Move new abi rtti classes from here ...\n+\t(__cxxabiv1): ... to here.\n+\t* tinfo2.cc (cxxabi.h): Include for new-abi.\n+\tMove rtti class definitions to new header file.\n+\t(std): Move new abi rtti classes from here ...\n+\t(__cxxabiv1): ... to here.\n+\t* inc/typeinfo (__class_type_info): Move into __cxxabiv1\n+\tnamespace.\n+\n 2000-03-20  Jed Wing <jedwin@zloty.ugcs.caltech.edu>\n \t    Jason Merrill  <jason@casey.cygnus.com>\n "}, {"sha": "fb8ce9f8b84d2f6153db9f53ffe7a85e2b175db8", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2854d3c65e19626d807717407f18cc47d57198dc/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2854d3c65e19626d807717407f18cc47d57198dc/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=2854d3c65e19626d807717407f18cc47d57198dc", "patch": "@@ -58,7 +58,7 @@ DEMANGLER_PROG = c++filt$(exeext)\n \n # Extra headers to install.\n CXX_EXTRA_HEADERS = $(srcdir)/cp/inc/typeinfo $(srcdir)/cp/inc/exception \\\n-\t$(srcdir)/cp/inc/new $(srcdir)/cp/inc/new.h\n+\t$(srcdir)/cp/inc/new $(srcdir)/cp/inc/new.h $(srcdir)/cp/inc/cxxabi.h\n \n # Extra code to include in libgcc2.\n CXX_LIB2FUNCS = tinfo.o tinfo2.o new.o opnew.o opnewnt.o opvnew.o opvnewnt.o \\"}, {"sha": "abf072ceadd2e7db60084ad5581f679f6489b6eb", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2854d3c65e19626d807717407f18cc47d57198dc/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2854d3c65e19626d807717407f18cc47d57198dc/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=2854d3c65e19626d807717407f18cc47d57198dc", "patch": "@@ -537,6 +537,7 @@ enum cp_tree_index\n     CPTI_VTBL_TYPE,\n     CPTI_VTBL_PTR_TYPE,\n     CPTI_STD,\n+    CPTI_ABI,\n     CPTI_TYPE_INFO_TYPE,\n     CPTI_TINFO_DECL_ID,\n     CPTI_TINFO_DECL_TYPE,\n@@ -622,6 +623,7 @@ extern tree cp_global_trees[CPTI_MAX];\n #define vtbl_type_node\t\t\tcp_global_trees[CPTI_VTBL_TYPE]\n #define vtbl_ptr_type_node\t\tcp_global_trees[CPTI_VTBL_PTR_TYPE]\n #define std_node\t\t\tcp_global_trees[CPTI_STD]\n+#define abi_node                        cp_global_trees[CPTI_ABI]\n #define type_info_type_node\t\tcp_global_trees[CPTI_TYPE_INFO_TYPE]\n #define tinfo_decl_id\t\t\tcp_global_trees[CPTI_TINFO_DECL_ID]\n #define tinfo_decl_type\t\t\tcp_global_trees[CPTI_TINFO_DECL_TYPE]"}, {"sha": "e1d317830d731682df09060f755b4eae60f88c9a", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2854d3c65e19626d807717407f18cc47d57198dc/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2854d3c65e19626d807717407f18cc47d57198dc/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=2854d3c65e19626d807717407f18cc47d57198dc", "patch": "@@ -231,9 +231,10 @@ tree error_mark_list;\n \ttree vtbl_type_node;\n \ttree vtbl_ptr_type_node;\n \n-   Nnamespace std\n+   Namespaces,\n \n \ttree std_node;\n+\ttree abi_node;\n \n    A FUNCTION_DECL which can call `abort'.  Not necessarily the\n    one that the user will declare, but sufficient to be called\n@@ -6385,6 +6386,13 @@ init_decl_processing ()\n \t\t\t get_identifier (flag_honor_std ? \"fake std\":\"std\"),\n \t\t\t void_type_node);\n   pushdecl (std_node);\n+  \n+  if (flag_new_abi)\n+    {\n+      push_namespace (get_identifier (\"__cxxabiv1\"));\n+      abi_node = current_namespace;\n+      pop_namespace ();\n+    }\n \n   global_type_node = make_node (LANG_TYPE);\n   record_unknown_type (global_type_node, \"global type\");"}, {"sha": "b140a15f648b1f0974f5909fb4f7bf0bcce081b8", "filename": "gcc/cp/inc/cxxabi.h", "status": "added", "additions": 399, "deletions": 0, "changes": 399, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2854d3c65e19626d807717407f18cc47d57198dc/gcc%2Fcp%2Finc%2Fcxxabi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2854d3c65e19626d807717407f18cc47d57198dc/gcc%2Fcp%2Finc%2Fcxxabi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finc%2Fcxxabi.h?ref=2854d3c65e19626d807717407f18cc47d57198dc", "patch": "@@ -0,0 +1,399 @@\n+/* new abi support -*- C++ -*-\n+   Copyright (C) 2000\n+   Free Software Foundation, Inc.\n+   Written by Nathan Sidwell, Codesourcery LLC, <nathan@codesourcery.com>\n+\n+   This file declares the new abi entry points into the runtime. It is not\n+   normally necessary for user programs to include this header, or use the\n+   entry points directly. However, this header is available should that be\n+   needed.\n+   \n+   Some of the entry points are intended for both C and C++, thus this header\n+   is includable from both C and C++. Though the C++ specific parts are not\n+   available in C, naturally enough.  */\n+\n+#ifndef __CXXABI_H\n+#define __CXXABI_H 1\n+\n+#if defined(__cplusplus) && (!defined(__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100)\n+/* These structures only make sense when targeting the new abi, catch a\n+   bonehead error early rather than let the user get very confused.  */\n+#error \"Not targetting the new abi, supply -fnew-abi\"\n+#endif\n+\n+#ifdef __cplusplus\n+\n+#include <typeinfo>\n+#include <stddef.h>\n+\n+namespace __cxxabiv1\n+{\n+\n+/* type information for int, float etc */\n+class __fundamental_type_info\n+  : public std::type_info\n+{\n+public:\n+  virtual ~__fundamental_type_info ();\n+public:\n+  explicit __fundamental_type_info (const char *n_)\n+    : std::type_info (n_)\n+    { }\n+};\n+\n+/* type information for pointer to data or function, but not pointer to member */\n+class __pointer_type_info\n+  : public std::type_info\n+{\n+/* abi defined member variables */\n+public:\n+  int quals;                    /* qualification of the target object */\n+  const std::type_info *type;   /* type of pointed to object */\n+\n+/* abi defined member functions */\n+public:\n+  virtual ~__pointer_type_info ();\n+public:\n+  explicit __pointer_type_info (const char *n_,\n+                                int quals_,\n+                                const std::type_info *type_)\n+    : std::type_info (n_), quals (quals_), type (type_)\n+    { }\n+\n+/* implementation defined types */\n+public:\n+  enum quals_masks {\n+    const_mask = 0x1,\n+    volatile_mask = 0x2\n+  };\n+\n+/* implementation defined member functions */\n+protected:\n+  virtual bool is_pointer_p () const;\n+protected:\n+  virtual bool do_catch (const std::type_info *thr_type, void **thr_obj,\n+                         unsigned outer) const;\n+};\n+\n+/* type information for array objects */\n+class __array_type_info\n+  : public std::type_info\n+{\n+/* abi defined member functions */\n+protected:\n+  virtual ~__array_type_info ();\n+public:\n+  explicit __array_type_info (const char *n_)\n+    : std::type_info (n_)\n+    { }\n+};\n+\n+/* type information for functions (both member and non-member) */\n+class __function_type_info\n+  : public std::type_info\n+{\n+/* abi defined member functions */\n+public:\n+  virtual ~__function_type_info ();\n+public:\n+  explicit __function_type_info (const char *n_)\n+    : std::type_info (n_)\n+    { }\n+  \n+/* implementation defined member functions */\n+protected:\n+  virtual bool is_function_p () const;\n+};\n+\n+/* type information for enumerations */\n+class __enum_type_info\n+  : public std::type_info\n+{\n+/* abi defined member functions */\n+public:\n+  virtual ~__enum_type_info ();\n+public:\n+  explicit __enum_type_info (const char *n_)\n+    : std::type_info (n_)\n+    { }\n+};\n+\n+/* type information for a pointer to member variable (not function) */\n+class __pointer_to_member_type_info\n+  : public std::type_info\n+{\n+/* abi defined member variables */\n+public:\n+  const __class_type_info *klass;   /* class of the member */\n+  const std::type_info *type;       /* type of the pointed to member */\n+  int quals;                        /* qualifications of the pointed to type */\n+\n+/* abi defined member functions */\n+public:\n+  virtual ~__pointer_to_member_type_info ();\n+public:\n+  explicit __pointer_to_member_type_info (const char *n_,\n+                                          const __class_type_info *klass_,\n+                                          const std::type_info *type_,\n+                                          int quals_)\n+    : std::type_info (n_), klass (klass_), type (type_), quals (quals_)\n+    { }\n+\n+/* implementation defined types */\n+public:\n+  enum quals_masks {\n+    const_mask = 0x1,\n+    volatile_mask = 0x2\n+  };\n+\n+/* implementation defined member functions */\n+protected:\n+  virtual bool do_catch (const std::type_info *thr_type, void **thr_obj,\n+                         unsigned outer) const;\n+};\n+\n+class __class_type_info;\n+\n+/* helper class for __vmi_class_type */\n+class __base_class_info\n+{\n+/* abi defined member variables */\n+public:\n+  const __class_type_info *base;    /* base class type */\n+  std::ptrdiff_t offset;            /* offset to the sub object */\n+  int vmi_flags;                    /* about the base */\n+\n+/* implementation defined types */\n+public:\n+  enum vmi_masks {\n+    virtual_mask = 0x1,\n+    public_mask = 0x2,\n+    hwm_bit = 2\n+  };\n+  \n+/* implementation defined member functions */\n+public:\n+  bool is_virtual_p () const\n+    { return vmi_flags & virtual_mask; }\n+  bool is_public_p () const\n+    { return vmi_flags & public_mask; }\n+};\n+\n+/* type information for a class */\n+class __class_type_info\n+  : public std::type_info\n+{\n+/* abi defined member variables */\n+public:\n+  int details;      /* details about the class heirarchy */\n+\n+/* abi defined member functions */\n+public:\n+  virtual ~__class_type_info ();\n+public:\n+  explicit __class_type_info (const char *n_,\n+                              int details_)\n+    : type_info (n_), details (details_)\n+    { }\n+\n+/* implementation defined types */\n+public:\n+  enum detail_masks {\n+    multiple_base_mask = 0x1,   /* multiple inheritance of the same base type */\n+    polymorphic_mask = 0x2,     /* is a polymorphic type */\n+    virtual_base_mask = 0x4,    /* has virtual bases (direct or indirect) */\n+    private_base_mask = 0x8     /* has private bases (direct or indirect) */\n+  };\n+\n+public:\n+  /* sub_kind tells us about how a base object is contained within a derived\n+     object. We often do this lazily, hence the UNKNOWN value. At other times\n+     we may use NOT_CONTAINED to mean not publicly contained. */\n+  enum sub_kind\n+  {\n+    unknown = 0,              /* we have no idea */\n+    not_contained,            /* not contained within us (in some */\n+                              /* circumstances this might mean not contained */\n+                              /* publicly) */\n+    contained_ambig,          /* contained ambiguously */\n+    \n+    contained_virtual_mask = __base_class_info::virtual_mask, /* via a virtual path */\n+    contained_public_mask = __base_class_info::public_mask,   /* via a public path */\n+    contained_mask = 1 << __base_class_info::hwm_bit,         /* contained within us */\n+    \n+    contained_private = contained_mask,\n+    contained_public = contained_mask | contained_public_mask\n+  };\n+\n+public:  \n+  struct upcast_result\n+  {\n+    const void *dst_ptr;        /* pointer to caught object */\n+    sub_kind whole2dst;         /* path from most derived object to target */\n+    int src_details;            /* hints about the source type */\n+    const __class_type_info *base_type; /* where we found the target, */\n+                                /* if in vbase the __class_type_info of vbase */\n+                                /* if a non-virtual base then 1 */\n+                                /* else NULL */\n+    public:\n+    upcast_result (int d)\n+      :dst_ptr (NULL), whole2dst (unknown), src_details (d), base_type (NULL)\n+      {}\n+  };\n+\n+public:\n+  /* dyncast_result is used to hold information during traversal of a class\n+     heirarchy when dynamic casting. */\n+  struct dyncast_result\n+  {\n+    const void *dst_ptr;        /* pointer to target object or NULL */\n+    sub_kind whole2dst;         /* path from most derived object to target */\n+    sub_kind whole2src;         /* path from most derived object to sub object */\n+    sub_kind dst2src;           /* path from target to sub object */\n+    \n+    public:\n+    dyncast_result ()\n+      :dst_ptr (NULL), whole2dst (unknown),\n+       whole2src (unknown), dst2src (unknown)\n+      {}\n+  };\n+\n+/* implementation defined member functions */\n+protected:\n+  virtual bool do_upcast (const __class_type_info *dst_type, void **obj_ptr) const;\n+\n+protected:\n+  virtual bool do_catch (const type_info *thr_type, void **thr_obj,\n+                         unsigned outer) const;\n+\n+\n+public:\n+  /* Helper for upcast. See if DST is us, or one of our bases. ACCESS_PATH */\n+  /* gives the access from the start object. Return TRUE if we know the upcast */\n+  /* fails. */\n+  virtual bool do_upcast (sub_kind access_path,\n+                          const __class_type_info *dst, const void *obj,\n+                          upcast_result &__restrict result) const;\n+\n+public:\n+  /* Indicate whether SRC_PTR of type SRC_TYPE is contained publicly within\n+     OBJ_PTR. OBJ_PTR points to a base object of our type, which is the\n+     destination type. SRC2DST indicates how SRC objects might be contained\n+     within this type.  If SRC_PTR is one of our SRC_TYPE bases, indicate the\n+     virtuality. Returns not_contained for non containment or private\n+     containment. */\n+  inline sub_kind find_public_src (std::ptrdiff_t src2dst, const void *obj_ptr,\n+                                   const __class_type_info *src_type,\n+                                   const void *src_ptr) const;\n+\n+public:\n+  /* dynamic cast helper. ACCESS_PATH gives the access from the most derived\n+     object to this base. DST_TYPE indicates the desired type we want. OBJ_PTR\n+     points to a base of our type within the complete object. SRC_TYPE\n+     indicates the static type started from and SRC_PTR points to that base\n+     within the most derived object. Fill in RESULT with what we find. Return\n+     true if we have located an ambiguous match. */\n+  virtual bool do_dyncast (std::ptrdiff_t src2dst, sub_kind access_path,\n+                           const __class_type_info *dst_type, const void *obj_ptr,\n+                           const __class_type_info *src_type, const void *src_ptr,\n+                           dyncast_result &result) const;\n+public:\n+  /* Helper for find_public_subobj. SRC2DST indicates how SRC_TYPE bases are\n+     inherited by the type started from -- which is not necessarily the\n+     current type. The current type will be a base of the destination type.\n+     OBJ_PTR points to the current base. */\n+  virtual sub_kind do_find_public_src (std::ptrdiff_t src2dst, const void *obj_ptr,\n+                                       const __class_type_info *src_type,\n+                                       const void *src_ptr) const;\n+};\n+\n+/* type information for a class with a single non-virtual base */\n+class __si_class_type_info\n+  : public __class_type_info\n+{\n+/* abi defined member variables */\n+protected:\n+  const __class_type_info *base;    /* base type */\n+\n+/* abi defined member functions */\n+public:\n+  virtual ~__si_class_type_info ();\n+public:\n+  explicit __si_class_type_info (const char *n_,\n+                                 int details_,\n+                                 const __class_type_info *base_)\n+    : __class_type_info (n_, details_), base (base_)\n+    { }\n+\n+/* implementation defined member functions */\n+protected:\n+  virtual bool do_dyncast (std::ptrdiff_t src2dst, sub_kind access_path,\n+                           const __class_type_info *dst_type, const void *obj_ptr,\n+                           const __class_type_info *src_type, const void *src_ptr,\n+                           dyncast_result &result) const;\n+  virtual sub_kind do_find_public_src (std::ptrdiff_t src2dst, const void *obj_ptr,\n+                                       const __class_type_info *src_type,\n+                                       const void *sub_ptr) const;\n+  virtual bool do_upcast (sub_kind access_path,\n+                          const __class_type_info *dst, const void *obj,\n+                          upcast_result &__restrict result) const;\n+};\n+\n+/* type information for a class with multiple and/or virtual bases */\n+class __vmi_class_type_info : public __class_type_info {\n+/* abi defined member variables */\n+protected:\n+  int n_bases;      /* number of direct bases */\n+  __base_class_info base_list[1]; /* array of bases */\n+  /* The array of bases uses the trailing array struct hack\n+     so this class is not constructable with a normal constructor. It is\n+     internally generated by the compiler. */\n+\n+/* abi defined member functions */\n+public:\n+  virtual ~__vmi_class_type_info ();\n+public:\n+  explicit __vmi_class_type_info (const char *n_,\n+                                  int details_)\n+    : __class_type_info (n_, details_), n_bases (0)\n+    { }\n+\n+/* implementation defined member functions */\n+protected:\n+  virtual bool do_dyncast (std::ptrdiff_t src2dst, sub_kind access_path,\n+                           const __class_type_info *dst_type, const void *obj_ptr,\n+                           const __class_type_info *src_type, const void *src_ptr,\n+                           dyncast_result &result) const;\n+  virtual sub_kind do_find_public_src (std::ptrdiff_t src2dst, const void *obj_ptr,\n+                                       const __class_type_info *src_type,\n+                                       const void *src_ptr) const;\n+  virtual bool do_upcast (sub_kind access_path,\n+                          const __class_type_info *dst, const void *obj,\n+                          upcast_result &__restrict result) const;\n+};\n+\n+/* dynamic cast runtime */\n+void *__dynamic_cast (const void *src_ptr,    /* object started from */\n+                      const __class_type_info *src_type, /* static type of object */\n+                      const __class_type_info *dst_type, /* desired target type */\n+                      std::ptrdiff_t src2dst); /* how src and dst are related */\n+\n+    /* src2dst has the following possible values\n+       >= 0: src_type is a unique public non-virtual base of dst_type\n+             dst_ptr + src2dst == src_ptr\n+       -1: unspecified relationship\n+       -2: src_type is not a public base of dst_type\n+       -3: src_type is a multiple public non-virtual base of dst_type */\n+\n+\n+\n+} /* namespace __cxxabiv1 */\n+\n+/* User programs should use the alias `abi'. */\n+namespace abi = __cxxabiv1;\n+\n+#else\n+#endif /* __cplusplus */\n+\n+\n+#endif /* __CXXABI_H */"}, {"sha": "02fa73d334fa529728d60ed26246120718baa98b", "filename": "gcc/cp/inc/typeinfo", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2854d3c65e19626d807717407f18cc47d57198dc/gcc%2Fcp%2Finc%2Ftypeinfo", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2854d3c65e19626d807717407f18cc47d57198dc/gcc%2Fcp%2Finc%2Ftypeinfo", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finc%2Ftypeinfo?ref=2854d3c65e19626d807717407f18cc47d57198dc", "patch": "@@ -15,12 +15,15 @@\n \n extern \"C++\" {\n \n-namespace std {\n-\n #if defined(__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100\n-class __class_type_info;\n+namespace __cxxabiv1\n+{\n+  class __class_type_info;\n+} // namespace __cxxabiv1\n #endif\n \n+namespace std {\n+\n class type_info {\n public:\n   // Destructor. Being the first non-inline virtual function, this controls in\n@@ -82,7 +85,7 @@ public:\n                          unsigned outer) const;\n \n   // internally used during catch matching\n-  virtual bool do_upcast (const __class_type_info *target, void **obj_ptr) const;\n+  virtual bool do_upcast (const __cxxabiv1::__class_type_info *target, void **obj_ptr) const;\n #endif\n };\n "}, {"sha": "bc9746c975287413104dbf8c209126114e6727fa", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2854d3c65e19626d807717407f18cc47d57198dc/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2854d3c65e19626d807717407f18cc47d57198dc/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=2854d3c65e19626d807717407f18cc47d57198dc", "patch": "@@ -769,10 +769,10 @@ build_dynamic_cast_1 (type, expr)\n \t    {\n \t      tree tmp;\n \t      tree tinfo_ptr;\n-\t      tree ns = global_namespace;\n+\t      tree ns = new_abi_rtti_p () ? abi_node : global_namespace;\n \t      const char *name;\n \t      \n-              push_nested_namespace (ns);\n+\t      push_nested_namespace (ns);\n \t      if (!new_abi_rtti_p ())\n \t        {\n     \t          tinfo_ptr = build_pointer_type (tinfo_decl_type);\n@@ -787,11 +787,6 @@ build_dynamic_cast_1 (type, expr)\n \t        }\n \t      else\n \t        {\n-\t          if (flag_honor_std)\n-\t            {\n-                      push_namespace (get_identifier (\"std\"));\n-                      ns = current_namespace;\n-\t            }\n                   tinfo_ptr = xref_tag (class_type_node,\n                                         get_identifier (\"__class_type_info\"),\n                                         1);\n@@ -1675,8 +1670,7 @@ get_vmi_pseudo_type_info (num_bases)\n   array_domain = build_index_type (build_int_2 (num_bases, 0));\n   base_array = build_array_type (base_desc_type_node, array_domain);\n \n-  if (flag_honor_std)\n-    push_namespace (get_identifier (\"std\"));\n+  push_nested_namespace (abi_node);\n \n   desc = create_pseudo_type_info\n             (\"__vmi_class_type_info\", num_bases,\n@@ -1685,8 +1679,7 @@ get_vmi_pseudo_type_info (num_bases)\n              build_lang_decl (FIELD_DECL, NULL_TREE, base_array),\n              NULL);\n \n-  if (flag_honor_std)\n-    pop_namespace ();\n+  pop_nested_namespace (abi_node);\n \n   TREE_VEC_ELT (vmi_class_desc_type_node, num_bases) = desc;\n   return desc;\n@@ -1702,8 +1695,7 @@ create_tinfo_types ()\n   \n   if (bltn_desc_type_node)\n     return;\n-  if (flag_honor_std)\n-    push_namespace (get_identifier (\"std\"));\n+  push_nested_namespace (abi_node);\n \n   ptr_type_info = build_pointer_type\n                     (build_qualified_type\n@@ -1785,8 +1777,7 @@ create_tinfo_types ()\n         build_lang_decl (FIELD_DECL, NULL_TREE, integer_type_node),\n         NULL);\n \n-  if (flag_honor_std)\n-    pop_namespace ();\n+  pop_nested_namespace (abi_node);\n }\n \n /* Emit the type_info descriptors which are guaranteed to be in the runtime\n@@ -1825,12 +1816,10 @@ emit_support_tinfos ()\n   int ix;\n   tree bltn_type, dtor;\n   \n-  if (flag_honor_std)\n-    push_namespace (get_identifier (\"std\"));\n+  push_nested_namespace (abi_node);\n   bltn_type = xref_tag (class_type_node,\n                         get_identifier (\"__fundamental_type_info\"), 1);\n-  if (flag_honor_std)\n-    pop_namespace ();\n+  pop_nested_namespace (abi_node);\n   if (!TYPE_SIZE (bltn_type))\n     return;\n   dtor = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (bltn_type), 1);"}, {"sha": "90c3058abaa8c4c348c0ad391761a8e442533626", "filename": "gcc/cp/tinfo.cc", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2854d3c65e19626d807717407f18cc47d57198dc/gcc%2Fcp%2Ftinfo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2854d3c65e19626d807717407f18cc47d57198dc/gcc%2Fcp%2Ftinfo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftinfo.cc?ref=2854d3c65e19626d807717407f18cc47d57198dc", "patch": "@@ -562,7 +562,7 @@ do_catch (const type_info *thr_type, void **, unsigned) const\n \n // upcast from this type to the target. __class_type_info will override\n bool type_info::\n-do_upcast (const __class_type_info *, void **) const\n+do_upcast (const abi::__class_type_info *, void **) const\n {\n   return false;\n }\n@@ -572,6 +572,7 @@ do_upcast (const __class_type_info *, void **) const\n namespace {\n \n using namespace std;\n+using namespace abi;\n \n // initial part of a vtable, this structure is used with offsetof, so we don't\n // have to keep alignments consistent manually.\n@@ -621,7 +622,8 @@ static const __class_type_info *const nonvirtual_base_type =\n \n }; // namespace\n \n-namespace std {\n+namespace __cxxabiv1\n+{\n \n __class_type_info::\n ~__class_type_info ()\n@@ -722,7 +724,7 @@ do_find_public_src (ptrdiff_t src2dst,\n         }\n       base = adjust_pointer <void> (base, offset);\n       \n-      sub_kind base_kind = base_list[i].type->do_find_public_src\n+      sub_kind base_kind = base_list[i].base->do_find_public_src\n                               (src2dst, base, src_type, src_ptr);\n       if (contained_p (base_kind))\n         {\n@@ -849,7 +851,7 @@ do_dyncast (ptrdiff_t src2dst,\n         base_access = sub_kind (base_access & ~contained_public_mask);\n       \n       bool result2_ambig\n-          = base_list[i].type->do_dyncast (src2dst, base_access,\n+          = base_list[i].base->do_dyncast (src2dst, base_access,\n                                            dst_type, base,\n                                            src_type, src_ptr, result2);\n       result.whole2src = sub_kind (result.whole2src | result2.whole2src);\n@@ -1043,13 +1045,13 @@ do_upcast (sub_kind access_path,\n       if (base)\n         base = adjust_pointer <void> (base, offset);\n       \n-      if (base_list[i].type->do_upcast (sub_access, dst, base, result2))\n+      if (base_list[i].base->do_upcast (sub_access, dst, base, result2))\n         return true; // must fail\n       if (result2.base_type)\n         {\n           if (result2.base_type == nonvirtual_base_type\n               && base_list[i].is_virtual_p ())\n-            result2.base_type = base_list[i].type;\n+            result2.base_type = base_list[i].base;\n           if (!result.base_type)\n             {\n               result = result2;\n@@ -1131,5 +1133,5 @@ __dynamic_cast (const void *src_ptr,    // object started from\n   return NULL;\n }\n \n-}; // namespace std\n+}; // namespace __cxxabiv1\n #endif"}, {"sha": "4173ca6eec0e60cd10a2241fc0090174d95081e4", "filename": "gcc/cp/tinfo.h", "status": "modified", "additions": 1, "deletions": 221, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2854d3c65e19626d807717407f18cc47d57198dc/gcc%2Fcp%2Ftinfo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2854d3c65e19626d807717407f18cc47d57198dc/gcc%2Fcp%2Ftinfo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftinfo.h?ref=2854d3c65e19626d807717407f18cc47d57198dc", "patch": "@@ -210,226 +210,6 @@ struct __class_type_info : public __user_type_info {\n };\n #else\n // new abi\n-#include \"stddef.h\"\n-\n-namespace std {\n-\n-class __class_type_info;\n-\n-// helper class for __vmi_class_type\n-struct __base_class_info {\n-  const __class_type_info *type;  // base class type\n-  ptrdiff_t offset;               // offset to the sub object\n-  int vmi_flags;                  // about the base\n-\n-// implementation specific parts\n-  enum vmi_masks {\n-    virtual_mask = 0x1,\n-    public_mask = 0x2,\n-    hwm_bit = 2\n-  };\n-  \n-public:\n-  bool is_virtual_p () const\n-    { return vmi_flags & virtual_mask; }\n-  bool is_public_p () const\n-    { return vmi_flags & public_mask; }\n-};\n-\n-// type information for a class\n-class __class_type_info : public type_info {\n-protected:\n-  virtual ~__class_type_info ();\n-public:\n-  int details;      // details about the class heirarchy\n-\n-// implementation specific parts\n-  enum detail_masks {\n-    multiple_base_mask = 0x1,   // multiple inheritance of the same base type\n-    polymorphic_mask = 0x2,     // is a polymorphic type\n-    virtual_base_mask = 0x4,    // has virtual bases (direct or indirect)\n-    private_base_mask = 0x8     // has private bases (direct or indirect)\n-  };\n-\n-public:\n-  // sub_kind tells us about how a base object is contained within a derived\n-  // object. We often do this lazily, hence the UNKNOWN value. At other times\n-  // we may use NOT_CONTAINED to mean not publicly contained.\n-  enum sub_kind\n-  {\n-    unknown = 0,              // we have no idea\n-    not_contained,            // not contained within us (in some\n-                              // circumstances this might mean not contained\n-                              // publicly)\n-    contained_ambig,          // contained ambiguously\n-    \n-    contained_virtual_mask = __base_class_info::virtual_mask, // via a virtual path\n-    contained_public_mask = __base_class_info::public_mask,   // via a public path\n-    contained_mask = 1 << __base_class_info::hwm_bit,         // contained within us\n-    \n-    contained_private = contained_mask,\n-    contained_public = contained_mask | contained_public_mask\n-  };\n-\n-public:  \n-  struct upcast_result\n-  {\n-    const void *dst_ptr;        // pointer to caught object\n-    sub_kind whole2dst;         // path from most derived object to target\n-    int src_details;            // hints about the source type\n-    const __class_type_info *base_type; // where we found the target,\n-                                // if in vbase the __class_type_info of vbase\n-                                // if a non-virtual base then 1\n-                                // else NULL\n-    public:\n-    upcast_result (int d)\n-      :dst_ptr (NULL), whole2dst (unknown), src_details (d), base_type (NULL)\n-      {}\n-  };\n-\n-public:\n-  // dyncast_result is used to hold information during traversal of a class\n-  // heirarchy when dynamic casting.\n-  struct dyncast_result\n-  {\n-    const void *dst_ptr;        // pointer to target object or NULL\n-    sub_kind whole2dst;         // path from most derived object to target\n-    sub_kind whole2src;         // path from most derived object to sub object\n-    sub_kind dst2src;           // path from target to sub object\n-    \n-    public:\n-    dyncast_result ()\n-      :dst_ptr (NULL), whole2dst (unknown),\n-       whole2src (unknown), dst2src (unknown)\n-      {}\n-  };\n-\n-public:\n-  explicit __class_type_info (const char *n,\n-                              int details_)\n-    : type_info (n), details (details_)\n-    { }\n-\n-protected:\n-  virtual bool do_upcast (const __class_type_info *dst_type, void **obj_ptr) const;\n-\n-protected:\n-  virtual bool do_catch (const type_info *thr_type, void **thr_obj,\n-                         unsigned outer) const;\n-\n-\n-public:\n-  // Helper for upcast. See if DST is us, or one of our bases. ACCESS_PATH\n-  // gives the access from the start object. Return TRUE if we know the upcast\n-  // fails.\n-  virtual bool do_upcast (sub_kind access_path,\n-                          const __class_type_info *dst, const void *obj,\n-                          upcast_result &__restrict result) const;\n-\n-public:\n-  // Indicate whether SRC_PTR of type SRC_TYPE is contained publicly within\n-  // OBJ_PTR. OBJ_PTR points to a base object of our type, which is the\n-  // destination type. SRC2DST indicates how SRC objects might be contained\n-  // within this type.  If SRC_PTR is one of our SRC_TYPE bases, indicate the\n-  // virtuality. Returns not_contained for non containment or private\n-  // containment.\n-  inline sub_kind find_public_src (ptrdiff_t src2dst, const void *obj_ptr,\n-                                   const __class_type_info *src_type,\n-                                   const void *src_ptr) const;\n-\n-public:\n-  // dynamic cast helper. ACCESS_PATH gives the access from the most derived\n-  // object to this base. DST_TYPE indicates the desired type we want. OBJ_PTR\n-  // points to a base of our type within the complete object. SRC_TYPE\n-  // indicates the static type started from and SRC_PTR points to that base\n-  // within the most derived object. Fill in RESULT with what we find. Return\n-  // true if we have located an ambiguous match.\n-  virtual bool do_dyncast (ptrdiff_t src2dst, sub_kind access_path,\n-                           const __class_type_info *dst_type, const void *obj_ptr,\n-                           const __class_type_info *src_type, const void *src_ptr,\n-                           dyncast_result &result) const;\n-public:\n-  // Helper for find_public_subobj. SRC2DST indicates how SRC_TYPE bases are\n-  // inherited by the type started from -- which is not necessarily the\n-  // current type. The current type will be a base of the destination type.\n-  // OBJ_PTR points to the current base.\n-  virtual sub_kind do_find_public_src (ptrdiff_t src2dst, const void *obj_ptr,\n-                                       const __class_type_info *src_type,\n-                                       const void *src_ptr) const;\n-};\n-\n-// type information for a class with a single non-virtual base\n-class __si_class_type_info : public __class_type_info {\n-protected:\n-  virtual ~__si_class_type_info ();\n-protected:\n-  const __class_type_info *base;    // base type\n-\n-public:\n-  explicit __si_class_type_info (const char *n,\n-                                 int details_,\n-                                 const __class_type_info *base_)\n-    : __class_type_info (n, details_), base (base_)\n-    { }\n-\n-// implementation specific parts\n-protected:\n-  virtual bool do_dyncast (ptrdiff_t src2dst, sub_kind access_path,\n-                           const __class_type_info *dst_type, const void *obj_ptr,\n-                           const __class_type_info *src_type, const void *src_ptr,\n-                           dyncast_result &result) const;\n-  virtual sub_kind do_find_public_src (ptrdiff_t src2dst, const void *obj_ptr,\n-                                       const __class_type_info *src_type,\n-                                       const void *sub_ptr) const;\n-  virtual bool do_upcast (sub_kind access_path,\n-                          const __class_type_info *dst, const void *obj,\n-                          upcast_result &__restrict result) const;\n-};\n-\n-// type information for a class with multiple and/or virtual bases\n-class __vmi_class_type_info : public __class_type_info {\n-protected:\n-  virtual ~__vmi_class_type_info ();\n-protected:\n-  int n_bases;      // number of direct bases\n-  __base_class_info base_list[1]; // array of bases\n-  // The array of bases uses the trailing array struct hack\n-  // so this class is not constructable with a normal constructor. It is\n-  // internally generated by the compiler.\n-\n-public:\n-  explicit __vmi_class_type_info (const char *n,\n-                                  int details_)\n-    : __class_type_info (n, details_), n_bases (0)\n-    { }\n-\n-// implementation specific parts\n-protected:\n-  virtual bool do_dyncast (ptrdiff_t src2dst, sub_kind access_path,\n-                           const __class_type_info *dst_type, const void *obj_ptr,\n-                           const __class_type_info *src_type, const void *src_ptr,\n-                           dyncast_result &result) const;\n-  virtual sub_kind do_find_public_src (ptrdiff_t src2dst, const void *obj_ptr,\n-                                       const __class_type_info *src_type,\n-                                       const void *src_ptr) const;\n-  virtual bool do_upcast (sub_kind access_path,\n-                          const __class_type_info *dst, const void *obj,\n-                          upcast_result &__restrict result) const;\n-};\n-\n-// dynamic cast runtime\n-void *__dynamic_cast (const void *src_ptr,    // object started from\n-                      const __class_type_info *src_type, // static type of object\n-                      const __class_type_info *dst_type, // desired target type\n-                      ptrdiff_t src2dst); // how src and dst are related\n-\n-    // src2dst has the following possible values\n-    // >= 0: src_type is a unique public non-virtual base of dst_type\n-    //       dst_ptr + src2dst == src_ptr\n-    // -1: unspecified relationship\n-    // -2: src_type is not a public base of dst_type\n-    // -3: src_type is a multiple public non-virtual base of dst_type\n-\n-} // namespace std\n+#include <cxxabi.h>\n \n #endif"}, {"sha": "1eb3502880e05ee4a26b3868f7155d105ae5be3e", "filename": "gcc/cp/tinfo2.cc", "status": "modified", "additions": 6, "deletions": 104, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2854d3c65e19626d807717407f18cc47d57198dc/gcc%2Fcp%2Ftinfo2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2854d3c65e19626d807717407f18cc47d57198dc/gcc%2Fcp%2Ftinfo2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftinfo2.cc?ref=2854d3c65e19626d807717407f18cc47d57198dc", "patch": "@@ -91,111 +91,13 @@ struct __array_type_info : public type_info {\n \n #else\n \n-namespace std {\n-  \n-// type information for int, float etc\n-class __fundamental_type_info : public type_info {\n-public:\n-  virtual ~__fundamental_type_info ();\n-public:\n-  explicit __fundamental_type_info (const char *n)\n-    : type_info (n)\n-    { }\n-};\n-\n-// type information for pointer to data or function, but not pointer to member\n-class __pointer_type_info : public type_info {\n-public:\n-  virtual ~__pointer_type_info ();\n-// external parts\n-  int quals;                // qualification of the target object\n-  const type_info *target;  // type of object being pointed to\n-\n-// internal parts\n-  enum quals_masks {\n-    const_mask = 0x1,\n-    volatile_mask = 0x2\n-  };\n-  \n-public:\n-  explicit __pointer_type_info (const char *n,\n-                                int quals_,\n-                                const type_info *target_)\n-    : type_info (n), quals (quals_), target (target_)\n-    { }\n-\n-protected:\n-  virtual bool is_pointer_p () const;\n-  virtual bool do_catch (const type_info *thr_type, void **thr_obj,\n-                         unsigned outer) const;\n-};\n-\n-// type information for array objects\n-class __array_type_info : public type_info {\n-public:\n-  virtual ~__array_type_info ();\n-public:\n-  explicit __array_type_info (const char *n)\n-    : type_info (n)\n-    { }\n-};\n-\n-// type information for functions (both member and non-member)\n-class __function_type_info : public type_info {\n-public:\n-  virtual ~__function_type_info ();\n-public:\n-  explicit __function_type_info (const char *n)\n-    : type_info (n)\n-    { }\n-protected:\n-  virtual bool is_function_p () const;\n-};\n-\n-// type information for enumerations\n-class __enum_type_info : public type_info {\n-public:\n-  virtual ~__enum_type_info ();\n-public:\n-  explicit __enum_type_info (const char *n)\n-    : type_info (n)\n-    { }\n-};\n-\n-// type information for a pointer to member variable (not function)\n-class __pointer_to_member_type_info : public type_info {\n-public:\n-  virtual ~__pointer_to_member_type_info ();\n-// external parts\n-  const __class_type_info *klass;   // class of the member\n-  const type_info *type;            // type of the member\n-  int quals;                        // qualifications of the pointed to type\n-\n-// internal parts\n-  enum quals_masks {\n-    const_mask = 0x1,\n-    volatile_mask = 0x2\n-  };\n-\n-public:\n-  explicit __pointer_to_member_type_info (const char *n,\n-                                          const __class_type_info *klass_,\n-                                          const type_info *type_,\n-                                          int quals_)\n-    : type_info (n), klass (klass_), type (type_), quals (quals_)\n-    { }\n-\n-protected:\n-  virtual bool do_catch (const type_info *thr_type, void **thr_obj,\n-                         unsigned outer) const;\n-};\n-\n-}; // namespace std\n-\n+#include <cxxabi.h>\n #endif\n \n #if defined(__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100\n-namespace std {\n+namespace __cxxabiv1 {\n+\n+using namespace std;\n \n // This has special meaning to the compiler, and will cause it\n // to emit the type_info structures for the fundamental types which are\n@@ -262,13 +164,13 @@ do_catch (const type_info *thr_type,\n   if (!(quals & const_mask))\n     outer &= ~1;\n   \n-  if (outer < 2 && *target == typeid (void))\n+  if (outer < 2 && *type == typeid (void))\n     {\n       // conversion to void\n       return !thrown_type->is_function_p ();\n     }\n   \n-  return target->do_catch (thrown_type->target, thr_obj, outer + 2);\n+  return type->do_catch (thrown_type->type, thr_obj, outer + 2);\n }\n \n bool __pointer_to_member_type_info::"}]}