{"sha": "5c475ba98b74a9831f6c05fb39c816d406d7daad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWM0NzViYTk4Yjc0YTk4MzFmNmMwNWZiMzljODE2ZDQwNmQ3ZGFhZA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2013-10-19T11:11:03Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2013-10-19T11:11:03Z"}, "message": "utils.c (scale_by_factor_of): New function.\n\n\t* gcc-interface/utils.c (scale_by_factor_of): New function.\n\t(rest_of_record_type_compilation): Use scale_by_factor_of in order to\n\tscale the original offset for both rounding cases; in the second case,\n\ttake into accout the addend to compute the alignment.  Tidy up.\n\nFrom-SVN: r203852", "tree": {"sha": "62c84e425fd23259af0ec500f46a2b68e6c50a3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62c84e425fd23259af0ec500f46a2b68e6c50a3c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c475ba98b74a9831f6c05fb39c816d406d7daad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c475ba98b74a9831f6c05fb39c816d406d7daad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c475ba98b74a9831f6c05fb39c816d406d7daad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c475ba98b74a9831f6c05fb39c816d406d7daad/comments", "author": null, "committer": null, "parents": [{"sha": "457f72ac38955335c4b3f20e353bc9891681d805", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/457f72ac38955335c4b3f20e353bc9891681d805", "html_url": "https://github.com/Rust-GCC/gccrs/commit/457f72ac38955335c4b3f20e353bc9891681d805"}], "stats": {"total": 127, "additions": 71, "deletions": 56}, "files": [{"sha": "77cd3b9d360c7c6175faa20566df7e84684ad80d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c475ba98b74a9831f6c05fb39c816d406d7daad/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c475ba98b74a9831f6c05fb39c816d406d7daad/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5c475ba98b74a9831f6c05fb39c816d406d7daad", "patch": "@@ -1,3 +1,10 @@\n+2013-10-19  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/utils.c (scale_by_factor_of): New function.\n+\t(rest_of_record_type_compilation): Use scale_by_factor_of in order to\n+\tscale the original offset for both rounding cases; in the second case,\n+\ttake into accout the addend to compute the alignment.  Tidy up.\n+\n 2013-10-19  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/cuintp.c: Remove useless include directives."}, {"sha": "24123907d3069ffbf89cde37fec02cb193a51d22", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 64, "deletions": 56, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c475ba98b74a9831f6c05fb39c816d406d7daad/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c475ba98b74a9831f6c05fb39c816d406d7daad/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=5c475ba98b74a9831f6c05fb39c816d406d7daad", "patch": "@@ -232,6 +232,7 @@ static tree compute_related_constant (tree, tree);\n static tree split_plus (tree, tree *);\n static tree float_type_for_precision (int, enum machine_mode);\n static tree convert_to_fat_pointer (tree, tree);\n+static unsigned int scale_by_factor_of (tree, unsigned int);\n static bool potential_alignment_gap (tree, tree, tree);\n \f\n /* Initialize data structures of the utils.c module.  */\n@@ -1708,93 +1709,74 @@ rest_of_record_type_compilation (tree record_type)\n       TYPE_SIZE_UNIT (new_record_type)\n \t= size_int (TYPE_ALIGN (record_type) / BITS_PER_UNIT);\n \n-      /* Now scan all the fields, replacing each field with a new\n-\t field corresponding to the new encoding.  */\n+      /* Now scan all the fields, replacing each field with a new field\n+\t corresponding to the new encoding.  */\n       for (old_field = TYPE_FIELDS (record_type); old_field;\n \t   old_field = DECL_CHAIN (old_field))\n \t{\n \t  tree field_type = TREE_TYPE (old_field);\n \t  tree field_name = DECL_NAME (old_field);\n-\t  tree new_field;\n \t  tree curpos = bit_position (old_field);\n+\t  tree pos, new_field;\n \t  bool var = false;\n \t  unsigned int align = 0;\n-\t  tree pos;\n \n-\t  /* See how the position was modified from the last position.\n-\n-\t  There are two basic cases we support: a value was added\n-\t  to the last position or the last position was rounded to\n-\t  a boundary and they something was added.  Check for the\n-\t  first case first.  If not, see if there is any evidence\n-\t  of rounding.  If so, round the last position and try\n-\t  again.\n+\t  /* We're going to do some pattern matching below so remove as many\n+\t     conversions as possible.  */\n+\t  curpos = remove_conversions (curpos, true);\n \n-\t  If this is a union, the position can be taken as zero. */\n+\t  /* See how the position was modified from the last position.\n \n-\t  /* Some computations depend on the shape of the position expression,\n-\t     so strip conversions to make sure it's exposed.  */\n-\t  curpos = remove_conversions (curpos, true);\n+\t     There are two basic cases we support: a value was added\n+\t     to the last position or the last position was rounded to\n+\t     a boundary and they something was added.  Check for the\n+\t     first case first.  If not, see if there is any evidence\n+\t     of rounding.  If so, round the last position and retry.\n \n+\t     If this is a union, the position can be taken as zero.  */\n \t  if (TREE_CODE (new_record_type) == UNION_TYPE)\n-\t    pos = bitsize_zero_node, align = 0;\n+\t    pos = bitsize_zero_node;\n \t  else\n \t    pos = compute_related_constant (curpos, last_pos);\n \n-\t  if (!pos && TREE_CODE (curpos) == MULT_EXPR\n+\t  if (!pos\n+\t      && TREE_CODE (curpos) == MULT_EXPR\n \t      && host_integerp (TREE_OPERAND (curpos, 1), 1))\n \t    {\n \t      tree offset = TREE_OPERAND (curpos, 0);\n \t      align = tree_low_cst (TREE_OPERAND (curpos, 1), 1);\n-\n-\t      /* An offset which is a bitwise AND with a mask increases the\n-\t\t alignment according to the number of trailing zeros.  */\n-\t      offset = remove_conversions (offset, true);\n-\t      if (TREE_CODE (offset) == BIT_AND_EXPR\n-\t\t  && TREE_CODE (TREE_OPERAND (offset, 1)) == INTEGER_CST)\n-\t\t{\n-\t\t  unsigned HOST_WIDE_INT mask\n-\t\t    = TREE_INT_CST_LOW (TREE_OPERAND (offset, 1));\n-\t\t  unsigned int i;\n-\n-\t\t  for (i = 0; i < HOST_BITS_PER_WIDE_INT; i++)\n-\t\t    {\n-\t\t      if (mask & 1)\n-\t\t\tbreak;\n-\t\t      mask >>= 1;\n-\t\t      align *= 2;\n-\t\t    }\n-\t\t}\n-\n-\t      pos = compute_related_constant (curpos,\n-\t\t\t\t\t      round_up (last_pos, align));\n+\t      align = scale_by_factor_of (offset, align);\n+\t      last_pos = round_up (last_pos, align);\n+\t      pos = compute_related_constant (curpos, last_pos);\n \t    }\n-\t  else if (!pos && TREE_CODE (curpos) == PLUS_EXPR\n-\t\t   && TREE_CODE (TREE_OPERAND (curpos, 1)) == INTEGER_CST\n+\t  else if (!pos\n+\t\t   && TREE_CODE (curpos) == PLUS_EXPR\n+\t\t   && host_integerp (TREE_OPERAND (curpos, 1), 1)\n \t\t   && TREE_CODE (TREE_OPERAND (curpos, 0)) == MULT_EXPR\n-\t\t   && host_integerp (TREE_OPERAND\n-\t\t\t\t     (TREE_OPERAND (curpos, 0), 1),\n-\t\t\t\t     1))\n+\t\t   && host_integerp\n+\t\t      (TREE_OPERAND (TREE_OPERAND (curpos, 0), 1), 1))\n \t    {\n+\t      tree offset = TREE_OPERAND (TREE_OPERAND (curpos, 0), 0);\n+\t      unsigned HOST_WIDE_INT addend\n+\t        = tree_low_cst (TREE_OPERAND (curpos, 1), 1);\n \t      align\n-\t\t= tree_low_cst\n-\t\t(TREE_OPERAND (TREE_OPERAND (curpos, 0), 1), 1);\n-\t      pos = compute_related_constant (curpos,\n-\t\t\t\t\t      round_up (last_pos, align));\n+\t\t= tree_low_cst (TREE_OPERAND (TREE_OPERAND (curpos, 0), 1), 1);\n+\t      align = scale_by_factor_of (offset, align);\n+\t      align = MIN (align, addend & -addend);\n+\t      last_pos = round_up (last_pos, align);\n+\t      pos = compute_related_constant (curpos, last_pos);\n \t    }\n-\t  else if (potential_alignment_gap (prev_old_field, old_field,\n-\t\t\t\t\t    pos))\n+\t  else if (potential_alignment_gap (prev_old_field, old_field, pos))\n \t    {\n \t      align = TYPE_ALIGN (field_type);\n-\t      pos = compute_related_constant (curpos,\n-\t\t\t\t\t      round_up (last_pos, align));\n+\t      last_pos = round_up (last_pos, align);\n+\t      pos = compute_related_constant (curpos, last_pos);\n \t    }\n \n \t  /* If we can't compute a position, set it to zero.\n \n-\t  ??? We really should abort here, but it's too much work\n-\t  to get this correct for all cases.  */\n-\n+\t     ??? We really should abort here, but it's too much work\n+\t     to get this correct for all cases.  */\n \t  if (!pos)\n \t    pos = bitsize_zero_node;\n \n@@ -2576,6 +2558,32 @@ value_factor_p (tree value, HOST_WIDE_INT factor)\n   return false;\n }\n \n+/* Return VALUE scaled by the biggest power-of-2 factor of EXPR.  */\n+\n+static unsigned int\n+scale_by_factor_of (tree expr, unsigned int value)\n+{\n+  expr = remove_conversions (expr, true);\n+\n+  /* An expression which is a bitwise AND with a mask has a power-of-2 factor\n+     corresponding to the number of trailing zeros of the mask.  */\n+  if (TREE_CODE (expr) == BIT_AND_EXPR\n+      && TREE_CODE (TREE_OPERAND (expr, 1)) == INTEGER_CST)\n+    {\n+      unsigned HOST_WIDE_INT mask = TREE_INT_CST_LOW (TREE_OPERAND (expr, 1));\n+      unsigned int i = 0;\n+\n+      while ((mask & 1) == 0 && i < HOST_BITS_PER_WIDE_INT)\n+\t{\n+\t  mask >>= 1;\n+\t  value *= 2;\n+\t  i++;\n+\t}\n+    }\n+\n+  return value;\n+}\n+\n /* Given two consecutive field decls PREV_FIELD and CURR_FIELD, return true\n    unless we can prove these 2 fields are laid out in such a way that no gap\n    exist between the end of PREV_FIELD and the beginning of CURR_FIELD.  OFFSET"}]}