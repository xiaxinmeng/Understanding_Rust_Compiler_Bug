{"sha": "f781186f2734abc323873821e3a62c74c07f0d08", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjc4MTE4NmYyNzM0YWJjMzIzODczODIxZTNhNjJjNzRjMDdmMGQwOA==", "commit": {"author": {"name": "Craig Burley", "email": "burley@gnu.org", "date": "1998-07-01T11:00:52Z"}, "committer": {"name": "Dave Love", "email": "fx@gcc.gnu.org", "date": "1998-07-01T11:00:52Z"}, "message": "Fix 980701-1.f (which was producing \"unaligned trap\" on an Alpha running GNU/Linux, as predicted):\n\nWed Jul  1 11:19:13 1998  Craig Burley  <burley@gnu.org>\n\tFix 980701-1.f (which was producing \"unaligned trap\"\n\ton an Alpha running GNU/Linux, as predicted):\n\t* equiv.c (ffeequiv_layout_local_): Don't bother\n\tcoping with pre-padding of entire area while building\n\tit; do that instead after the building is done, and\n\tdo it by modifying only the modulo field.  This covers\n\tthe case of alignment stringency being increased without\n\tlowering the starting offset, unlike the previous changes,\n\tand even more elegantly than those.\n\t* target.c (ffetarget_align): Make sure alignments\n\tare non-zero, just in case.\n\nFrom-SVN: r20875", "tree": {"sha": "ef8e5413369c6e17e1bb4c707f7a94a9e2686269", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef8e5413369c6e17e1bb4c707f7a94a9e2686269"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f781186f2734abc323873821e3a62c74c07f0d08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f781186f2734abc323873821e3a62c74c07f0d08", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f781186f2734abc323873821e3a62c74c07f0d08", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f781186f2734abc323873821e3a62c74c07f0d08/comments", "author": null, "committer": null, "parents": [{"sha": "b22773b1756908d40a5a1965483b4df8cf31412d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b22773b1756908d40a5a1965483b4df8cf31412d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b22773b1756908d40a5a1965483b4df8cf31412d"}], "stats": {"total": 79, "additions": 62, "deletions": 17}, "files": [{"sha": "9f8068f47021bf59f69a97496a89d3fb33342a2e", "filename": "gcc/f/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f781186f2734abc323873821e3a62c74c07f0d08/gcc%2Ff%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f781186f2734abc323873821e3a62c74c07f0d08/gcc%2Ff%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog?ref=f781186f2734abc323873821e3a62c74c07f0d08", "patch": "@@ -1,3 +1,18 @@\n+Wed Jul  1 11:19:13 1998  Craig Burley  <burley@gnu.org>\n+\n+\tFix 980701-1.f (which was producing \"unaligned trap\"\n+\ton an Alpha running GNU/Linux, as predicted):\n+\t* equiv.c (ffeequiv_layout_local_): Don't bother\n+\tcoping with pre-padding of entire area while building\n+\tit; do that instead after the building is done, and\n+\tdo it by modifying only the modulo field.  This covers\n+\tthe case of alignment stringency being increased without\n+\tlowering the starting offset, unlike the previous changes,\n+\tand even more elegantly than those.\n+\n+\t* target.c (ffetarget_align): Make sure alignments\n+\tare non-zero, just in case.\n+\n Mon Jun 29 09:47:33 1998  Craig Burley  <burley@gnu.org>\n \n \tFix 980628-*.f:"}, {"sha": "8c0975128c19488e57afa2e9777a5e3a135c18ff", "filename": "gcc/f/equiv.c", "status": "modified", "additions": 43, "deletions": 16, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f781186f2734abc323873821e3a62c74c07f0d08/gcc%2Ff%2Fequiv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f781186f2734abc323873821e3a62c74c07f0d08/gcc%2Ff%2Fequiv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fequiv.c?ref=f781186f2734abc323873821e3a62c74c07f0d08", "patch": "@@ -368,6 +368,7 @@ ffeequiv_layout_local_ (ffeequiv eq)\n \t      ffestorag item_st;\t\t/* Storage for var. */\n \t      ffesymbol item_sym;\t\t/* Var itself. */\n \t      ffetargetOffset item_offset;\t/* Offset for var from root. */\n+\t      ffetargetOffset new_size;\n \n \t      item_exp = ffebld_head (item);\n \t      item_sym = ffeequiv_symbol (item_exp);\n@@ -433,28 +434,18 @@ ffeequiv_layout_local_ (ffeequiv eq)\n \t\t}\n \t      else if (item_offset < ffestorag_offset (st))\n \t\t{\n-\t\t  ffetargetOffset new_size;\n-\n-\t\t  /* First, calculate the initial padding necessary\n-\t\t     to preserve the current alignment/modulo requirements\n-\t\t     for the storage area.  */\n-\t\t  pad = (-item_offset) % ffestorag_alignment (st);\n-\t\t  if (pad != 0)\n-\t\t    pad = ffestorag_alignment (st) - pad;\n-\n-\t\t  /* Increase size of equiv area to start for lower offset relative\n-\t\t     to root symbol.  */\n+\t\t  /* Increase size of equiv area to start for lower offset\n+\t\t     relative to root symbol.  */\n \t\t  if (! ffetarget_offset_add (&new_size,\n-\t\t\t\t\t     (ffestorag_offset (st)\n-\t\t\t\t\t      - item_offset)\n-\t\t\t\t\t     + pad,\n-\t\t\t\t\t     ffestorag_size (st)))\n+\t\t\t\t\t      ffestorag_offset (st)\n+\t\t\t\t\t      - item_offset,\n+\t\t\t\t\t      ffestorag_size (st)))\n \t\t    ffetarget_offset_overflow (ffesymbol_text (s));\n \t\t  else\n \t\t    ffestorag_set_size (st, new_size);\n \n \t\t  ffestorag_set_symbol (st, item_sym);\n-\t\t  ffestorag_set_offset (st, item_offset - pad);\n+\t\t  ffestorag_set_offset (st, item_offset);\n \n #if FFEEQUIV_DEBUG\n \t\t  fprintf (stderr, \" [eq offset=%\" ffetargetOffset_f\n@@ -538,6 +529,42 @@ ffeequiv_layout_local_ (ffeequiv eq)\n \n   ffeequiv_kill (eq);\t\t/* Fully processed, no longer needed. */\n \n+  /* If the offset for this storage area is zero (it cannot be positive),\n+     that means the alignment/modulo info is already correct.  Otherwise,\n+     the alignment info is correct, but the modulo info reflects a\n+     zero offset, so fix it.  */\n+\n+  if (ffestorag_offset (st) < 0)\n+    {\n+      /* Calculate the initial padding necessary to preserve\n+\t the alignment/modulo requirements for the storage area.\n+\t These requirements are themselves kept track of in the\n+\t record for the storage area as a whole, but really pertain\n+\t to offset 0 of that area, which is where the root symbol\n+\t was originally placed.\n+\n+\t The goal here is to have the offset and size for the area\n+\t faithfully reflect the area itself, not extra requirements\n+\t like alignment.  So to meet the alignment requirements,\n+\t the modulo for the area should be set as if the area had an\n+\t alignment requirement of alignment/0 and was aligned/padded\n+\t downward to meet the alignment requirements of the area at\n+\t offset zero, the amount of padding needed being the desired\n+\t value for the modulo of the area.  */\n+\n+      alignment = ffestorag_alignment (st);\n+      modulo = ffestorag_modulo (st);\n+\n+      /* Since we want to move the whole area *down* (lower memory\n+\t addresses) as required by the alignment/modulo paid, negate\n+\t the offset to ffetarget_align, which assumes aligning *up*\n+\t is desired.  */\n+      pad = ffetarget_align (&alignment, &modulo,\n+\t\t\t     - ffestorag_offset (st),\n+\t\t\t     alignment, 0);\n+      ffestorag_set_modulo (st, pad);\n+    }\n+\n   if (init)\n     ffedata_gather (st);\t/* Gather subordinate inits into one init. */\n }"}, {"sha": "5de05ff07caac26ea53e7cd18b17c23042017cc2", "filename": "gcc/f/target.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f781186f2734abc323873821e3a62c74c07f0d08/gcc%2Ff%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f781186f2734abc323873821e3a62c74c07f0d08/gcc%2Ff%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Ftarget.c?ref=f781186f2734abc323873821e3a62c74c07f0d08", "patch": "@@ -214,6 +214,9 @@ ffetarget_align (ffetargetAlign *updated_alignment,\n   ffetargetAlign i;\n   ffetargetAlign j;\n \n+  assert (alignment > 0);\n+  assert (*updated_alignment > 0);\n+  \n   assert (*updated_modulo < *updated_alignment);\n   assert (modulo < alignment);\n "}, {"sha": "98e877b79c7ff227093b0231426c77f87847ce25", "filename": "gcc/f/version.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f781186f2734abc323873821e3a62c74c07f0d08/gcc%2Ff%2Fversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f781186f2734abc323873821e3a62c74c07f0d08/gcc%2Ff%2Fversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fversion.c?ref=f781186f2734abc323873821e3a62c74c07f0d08", "patch": "@@ -1 +1 @@\n-char *ffe_version_string = \"0.5.24-19980629\";\n+char *ffe_version_string = \"0.5.24-19980701\";"}]}