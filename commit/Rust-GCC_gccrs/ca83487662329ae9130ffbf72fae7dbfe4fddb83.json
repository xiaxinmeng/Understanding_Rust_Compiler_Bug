{"sha": "ca83487662329ae9130ffbf72fae7dbfe4fddb83", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2E4MzQ4NzY2MjMyOWFlOTEzMGZmYmY3MmZhZTdkYmZlNGZkZGI4Mw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-12-13T02:12:15Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-12-13T02:12:15Z"}, "message": "cgraph.c (cgraph_node::get_untransformed_body): Pass compressed flag to lto_get_section_data.\n\n\n\t* cgraph.c (cgraph_node::get_untransformed_body): Pass compressed\n\tflag to lto_get_section_data.\n\t* varpool.c (varpool_node::get_constructor): Likewise.\n\t* lto-section-in.c (lto_get_section_data): Add new flag decompress.\n\t(lto_free_section_data): Likewise.\n\t(lto_get_raw_section_data): New function.\n\t(lto_free_raw_section_data): New function.\n\t(copy_function_or_variable): Copy sections w/o decompressing.\n\t(lto_output_decl_state_refs): Picke compressed bit.\n\t* lto-streamer.h (lto_in_decl_state): New flag compressed.\n\t(lto_out_decl_state): Likewise.\n\t(lto_get_section_data, lto_free_section_data): Update prototypes\n\t(lto_get_raw_section_data, lto_free_raw_section_data): Declare.\n\t(lto_write_raw_data): Declare.\n\t(lto_begin_section): Remove FIXME.\n\t(lto_write_raw_data): New function.\n\t(lto_write_stream): Remove FIXME.\n\t(lto_new_out_decl_state): Set compressed flag.\n\n\t* lto.c (lto_read_in_decl_state): Unpickle compressed bit.\n\nFrom-SVN: r231593", "tree": {"sha": "d18c6e4f8e505e7d6ec7206494843089e5e6d216", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d18c6e4f8e505e7d6ec7206494843089e5e6d216"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca83487662329ae9130ffbf72fae7dbfe4fddb83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca83487662329ae9130ffbf72fae7dbfe4fddb83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca83487662329ae9130ffbf72fae7dbfe4fddb83", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca83487662329ae9130ffbf72fae7dbfe4fddb83/comments", "author": null, "committer": null, "parents": [{"sha": "b44c0c0c7fd037165e5c8ddd20d5f2986e29d309", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b44c0c0c7fd037165e5c8ddd20d5f2986e29d309", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b44c0c0c7fd037165e5c8ddd20d5f2986e29d309"}], "stats": {"total": 96, "additions": 81, "deletions": 15}, "files": [{"sha": "1e68758cdac098c2bd149f650ff2fa92a37c7de6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca83487662329ae9130ffbf72fae7dbfe4fddb83/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca83487662329ae9130ffbf72fae7dbfe4fddb83/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ca83487662329ae9130ffbf72fae7dbfe4fddb83", "patch": "@@ -1,3 +1,24 @@\n+2015-12-10  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* cgraph.c (cgraph_node::get_untransformed_body): Pass compressed\n+\tflag to lto_get_section_data.\n+\t* varpool.c (varpool_node::get_constructor): Likewise.\n+\t* lto-section-in.c (lto_get_section_data): Add new flag decompress.\n+\t(lto_free_section_data): Likewise.\n+\t(lto_get_raw_section_data): New function.\n+\t(lto_free_raw_section_data): New function.\n+\t(copy_function_or_variable): Copy sections w/o decompressing.\n+\t(lto_output_decl_state_refs): Picke compressed bit.\n+\t* lto-streamer.h (lto_in_decl_state): New flag compressed.\n+\t(lto_out_decl_state): Likewise.\n+\t(lto_get_section_data, lto_free_section_data): Update prototypes\n+\t(lto_get_raw_section_data, lto_free_raw_section_data): Declare.\n+\t(lto_write_raw_data): Declare.\n+\t(lto_begin_section): Remove FIXME.\n+\t(lto_write_raw_data): New function.\n+\t(lto_write_stream): Remove FIXME.\n+\t(lto_new_out_decl_state): Set compressed flag.\n+\n 2015-12-10  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* tree.c (free_lang_data_in_type, find_decls_types_r): Also free"}, {"sha": "c8c337026128c29c4ed49541ab02f38336e453c2", "filename": "gcc/cgraph.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca83487662329ae9130ffbf72fae7dbfe4fddb83/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca83487662329ae9130ffbf72fae7dbfe4fddb83/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=ca83487662329ae9130ffbf72fae7dbfe4fddb83", "patch": "@@ -3251,9 +3251,11 @@ cgraph_node::get_untransformed_body (void)\n \n   /* We may have renamed the declaration, e.g., a static function.  */\n   name = lto_get_decl_name_mapping (file_data, name);\n+  struct lto_in_decl_state *decl_state\n+\t = lto_get_function_in_decl_state (file_data, decl);\n \n   data = lto_get_section_data (file_data, LTO_section_function_body,\n-\t\t\t       name, &len);\n+\t\t\t       name, &len, decl_state->compressed);\n   if (!data)\n     fatal_error (input_location, \"%s: section %s is missing\",\n \t\t file_data->file_name,\n@@ -3264,7 +3266,7 @@ cgraph_node::get_untransformed_body (void)\n   lto_input_function_body (file_data, this, data);\n   lto_stats.num_function_bodies++;\n   lto_free_section_data (file_data, LTO_section_function_body, name,\n-\t\t\t data, len);\n+\t\t\t data, len, decl_state->compressed);\n   lto_free_function_in_decl_state_for_node (this);\n   /* Keep lto file data so ipa-inline-analysis knows about cross module\n      inlining.  */"}, {"sha": "1529fdd3bb15a0b4dd84134a0e56e27667cbbcce", "filename": "gcc/lto-section-in.c", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca83487662329ae9130ffbf72fae7dbfe4fddb83/gcc%2Flto-section-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca83487662329ae9130ffbf72fae7dbfe4fddb83/gcc%2Flto-section-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-in.c?ref=ca83487662329ae9130ffbf72fae7dbfe4fddb83", "patch": "@@ -130,7 +130,7 @@ const char *\n lto_get_section_data (struct lto_file_decl_data *file_data,\n \t\t      enum lto_section_type section_type,\n \t\t      const char *name,\n-\t\t      size_t *len)\n+\t\t      size_t *len, bool decompress)\n {\n   const char *data = (get_section_f) (file_data, section_type, name, len);\n   const size_t header_length = sizeof (struct lto_data_header);\n@@ -142,9 +142,10 @@ lto_get_section_data (struct lto_file_decl_data *file_data,\n   if (data == NULL)\n     return NULL;\n \n-  /* FIXME lto: WPA mode does not write compressed sections, so for now\n-     suppress uncompression if flag_ltrans.  */\n-  if (!flag_ltrans)\n+  /* WPA->ltrans streams are not compressed with exception of function bodies\n+     and variable initializers that has been verbatim copied from earlier\n+     compilations.  */\n+  if (!flag_ltrans || decompress)\n     {\n       /* Create a mapping header containing the underlying data and length,\n \t and prepend this to the uncompression buffer.  The uncompressed data\n@@ -170,6 +171,16 @@ lto_get_section_data (struct lto_file_decl_data *file_data,\n   return data;\n }\n \n+/* Get the section data without any header parsing or uncompression.  */\n+\n+const char *\n+lto_get_raw_section_data (struct lto_file_decl_data *file_data,\n+\t\t\t  enum lto_section_type section_type,\n+\t\t\t  const char *name,\n+\t\t\t  size_t *len)\n+{\n+  return (get_section_f) (file_data, section_type, name, len);\n+}\n \n /* Free the data found from the above call.  The first three\n    parameters are the same as above.  DATA is the data to be freed and\n@@ -180,7 +191,7 @@ lto_free_section_data (struct lto_file_decl_data *file_data,\n \t\t       enum lto_section_type section_type,\n \t\t       const char *name,\n \t\t       const char *data,\n-\t\t       size_t len)\n+\t\t       size_t len, bool decompress)\n {\n   const size_t header_length = sizeof (struct lto_data_header);\n   const char *real_data = data - header_length;\n@@ -189,9 +200,7 @@ lto_free_section_data (struct lto_file_decl_data *file_data,\n \n   gcc_assert (free_section_f);\n \n-  /* FIXME lto: WPA mode does not write compressed sections, so for now\n-     suppress uncompression mapping if flag_ltrans.  */\n-  if (flag_ltrans)\n+  if (flag_ltrans && !decompress)\n     {\n       (free_section_f) (file_data, section_type, name, data, len);\n       return;\n@@ -203,6 +212,17 @@ lto_free_section_data (struct lto_file_decl_data *file_data,\n   free (CONST_CAST (char *, real_data));\n }\n \n+/* Free data allocated by lto_get_raw_section_data.  */\n+\n+void\n+lto_free_raw_section_data (struct lto_file_decl_data *file_data,\n+\t\t           enum lto_section_type section_type,\n+\t\t           const char *name,\n+\t\t           const char *data,\n+\t\t           size_t len)\n+{\n+  (free_section_f) (file_data, section_type, name, data, len);\n+}\n \n /* Load a section of type SECTION_TYPE from FILE_DATA, parse the\n    header and then return an input block pointing to the section.  The"}, {"sha": "06c8d7a04e95704955aee05672613b4082cf6fa2", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca83487662329ae9130ffbf72fae7dbfe4fddb83/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca83487662329ae9130ffbf72fae7dbfe4fddb83/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=ca83487662329ae9130ffbf72fae7dbfe4fddb83", "patch": "@@ -501,6 +501,9 @@ struct GTY((for_user)) lto_in_decl_state\n   /* If this in-decl state is associated with a function. FN_DECL\n      point to the FUNCTION_DECL. */\n   tree fn_decl;\n+\n+  /* True if decl state is compressed.  */\n+  bool compressed;\n };\n \n typedef struct lto_in_decl_state *lto_in_decl_state_ptr;\n@@ -534,6 +537,9 @@ struct lto_out_decl_state\n   /* If this out-decl state belongs to a function, fn_decl points to that\n      function.  Otherwise, it is NULL. */\n   tree fn_decl;\n+\n+  /* True if decl state is compressed.  */\n+  bool compressed;\n };\n \n typedef struct lto_out_decl_state *lto_out_decl_state_ptr;\n@@ -758,10 +764,18 @@ extern void lto_set_in_hooks (struct lto_file_decl_data **,\n extern struct lto_file_decl_data **lto_get_file_decl_data (void);\n extern const char *lto_get_section_data (struct lto_file_decl_data *,\n \t\t\t\t\t enum lto_section_type,\n-\t\t\t\t\t const char *, size_t *);\n+\t\t\t\t\t const char *, size_t *,\n+\t\t\t\t\t bool decompress = false);\n+extern const char *lto_get_raw_section_data (struct lto_file_decl_data *,\n+\t\t\t\t\t     enum lto_section_type,\n+\t\t\t\t\t     const char *, size_t *);\n extern void lto_free_section_data (struct lto_file_decl_data *,\n-\t\t\t\t   enum lto_section_type,\n-\t\t\t\t   const char *, const char *, size_t);\n+\t\t\t           enum lto_section_type,\n+\t\t\t\t   const char *, const char *, size_t,\n+\t\t\t\t   bool decompress = false);\n+extern void lto_free_raw_section_data (struct lto_file_decl_data *,\n+\t\t\t\t       enum lto_section_type,\n+\t\t\t\t       const char *, const char *, size_t);\n extern htab_t lto_create_renaming_table (void);\n extern void lto_record_renamed_decl (struct lto_file_decl_data *,\n \t\t\t\t     const char *, const char *);\n@@ -782,6 +796,7 @@ extern void lto_value_range_error (const char *,\n extern void lto_begin_section (const char *, bool);\n extern void lto_end_section (void);\n extern void lto_write_data (const void *, unsigned int);\n+extern void lto_write_raw_data (const void *, unsigned int);\n extern void lto_write_stream (struct lto_output_stream *);\n extern bool lto_output_decl_index (struct lto_output_stream *,\n \t\t\t    struct lto_tree_ref_encoder *,"}, {"sha": "6e905276d3165e2b020a0147ebee66b119a2bb28", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca83487662329ae9130ffbf72fae7dbfe4fddb83/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca83487662329ae9130ffbf72fae7dbfe4fddb83/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=ca83487662329ae9130ffbf72fae7dbfe4fddb83", "patch": "@@ -1,3 +1,7 @@\n+2015-12-10  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* lto.c (lto_read_in_decl_state): Unpickle compressed bit.\n+\n 2015-12-11  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR ipa/61886"}, {"sha": "fcf7caf460ab3a99620602d7608e27be6e6d4880", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca83487662329ae9130ffbf72fae7dbfe4fddb83/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca83487662329ae9130ffbf72fae7dbfe4fddb83/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=ca83487662329ae9130ffbf72fae7dbfe4fddb83", "patch": "@@ -234,6 +234,8 @@ lto_read_in_decl_state (struct data_in *data_in, const uint32_t *data,\n   uint32_t i, j;\n \n   ix = *data++;\n+  state->compressed = ix & 1;\n+  ix /= 2;\n   decl = streamer_tree_cache_get_tree (data_in->reader_cache, ix);\n   if (!VAR_OR_FUNCTION_DECL_P (decl))\n     {"}, {"sha": "5e4fcbf2a4a3a7f087c38fa8eb54e7b9b7ea2125", "filename": "gcc/varpool.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca83487662329ae9130ffbf72fae7dbfe4fddb83/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca83487662329ae9130ffbf72fae7dbfe4fddb83/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=ca83487662329ae9130ffbf72fae7dbfe4fddb83", "patch": "@@ -296,9 +296,11 @@ varpool_node::get_constructor (void)\n \n   /* We may have renamed the declaration, e.g., a static function.  */\n   name = lto_get_decl_name_mapping (file_data, name);\n+  struct lto_in_decl_state *decl_state\n+\t = lto_get_function_in_decl_state (file_data, decl);\n \n   data = lto_get_section_data (file_data, LTO_section_function_body,\n-\t\t\t       name, &len);\n+\t\t\t       name, &len, decl_state->compressed);\n   if (!data)\n     fatal_error (input_location, \"%s: section %s is missing\",\n \t\t file_data->file_name,\n@@ -308,7 +310,7 @@ varpool_node::get_constructor (void)\n   gcc_assert (DECL_INITIAL (decl) != error_mark_node);\n   lto_stats.num_function_bodies++;\n   lto_free_section_data (file_data, LTO_section_function_body, name,\n-\t\t\t data, len);\n+\t\t\t data, len, decl_state->compressed);\n   lto_free_function_in_decl_state_for_node (this);\n   timevar_pop (TV_IPA_LTO_CTORS_IN);\n   return DECL_INITIAL (decl);"}]}