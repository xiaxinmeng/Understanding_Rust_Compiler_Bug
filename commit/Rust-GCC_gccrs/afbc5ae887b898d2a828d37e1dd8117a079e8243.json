{"sha": "afbc5ae887b898d2a828d37e1dd8117a079e8243", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWZiYzVhZTg4N2I4OThkMmE4MjhkMzdlMWRkODExN2EwNzllODI0Mw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2016-01-15T20:33:58Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2016-01-15T20:33:58Z"}, "message": "re PR fortran/64324 (Deferred character specific functions not permitted in generic operator interface)\n\n2016-01-15  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/64324\n\t* resolve.c (check_uop_procedure): Prevent deferred length\n\tcharacters from being trapped by assumed length error.\n\n\tPR fortran/49630\n\tPR fortran/54070\n\tPR fortran/60593\n\tPR fortran/60795\n\tPR fortran/61147\n\tPR fortran/64324\n\t* trans-array.c (gfc_conv_scalarized_array_ref): Pass decl for\n\tfunction as well as variable expressions.\n\t(gfc_array_init_size): Add 'expr' as an argument. Use this to\n\tcorrectly set the descriptor dtype for deferred characters.\n\t(gfc_array_allocate): Add 'expr' to the call to\n\t'gfc_array_init_size'.\n\t* trans.c (gfc_build_array_ref): Expand logic for setting span\n\tto include indirect references to character lengths.\n\t* trans-decl.c (gfc_get_symbol_decl): Ensure that deferred\n\tresult char lengths that are PARM_DECLs are indirectly\n\treferenced both for directly passed and by reference.\n\t(create_function_arglist): If the length type is a pointer type\n\tthen store the length as the 'passed_length' and make the char\n\tlength an indirect reference to it.\n\t(gfc_trans_deferred_vars): If a character length has escaped\n\tbeing set as an indirect reference, return it via the 'passed\n\tlength'.\n\t* trans-expr.c (gfc_conv_procedure_call): The length of\n\tdeferred character length results is set TREE_STATIC and set to\n\tzero.\n\t(gfc_trans_assignment_1): Do not fix the rse string_length if\n\tit is a variable, a parameter or an indirect reference. Add the\n\tcode to trap assignment of scalars to unallocated arrays.\n\t* trans-stmt.c (gfc_trans_allocate): Remove 'def_str_len' and\n\tall references to it. Instead, replicate the code to obtain a\n\texplicitly defined string length and provide a value before\n\tarray allocation so that the dtype is correctly set.\n\ttrans-types.c (gfc_get_character_type): If the character length\n\tis a pointer, use the indirect reference.\n\n2016-01-15  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/49630\n\t* gfortran.dg/deferred_character_13.f90: New test for the fix\n\tof comment 3 of the PR.\n\n\tPR fortran/54070\n\t* gfortran.dg/deferred_character_8.f90: New test\n\t* gfortran.dg/allocate_error_5.f90: New test\n\n\tPR fortran/60593\n\t* gfortran.dg/deferred_character_10.f90: New test\n\n\tPR fortran/60795\n\t* gfortran.dg/deferred_character_14.f90: New test\n\n\tPR fortran/61147\n\t* gfortran.dg/deferred_character_11.f90: New test\n\n\tPR fortran/64324\n\t* gfortran.dg/deferred_character_9.f90: New test\n\nFrom-SVN: r232450", "tree": {"sha": "415abc4f91d8bf24a1d9431d1b2927b149a88784", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/415abc4f91d8bf24a1d9431d1b2927b149a88784"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/afbc5ae887b898d2a828d37e1dd8117a079e8243", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afbc5ae887b898d2a828d37e1dd8117a079e8243", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afbc5ae887b898d2a828d37e1dd8117a079e8243", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afbc5ae887b898d2a828d37e1dd8117a079e8243/comments", "author": null, "committer": null, "parents": [{"sha": "f47429917545ac2811630ff8648f05aa01aa3edf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f47429917545ac2811630ff8648f05aa01aa3edf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f47429917545ac2811630ff8648f05aa01aa3edf"}], "stats": {"total": 524, "additions": 495, "deletions": 29}, "files": [{"sha": "5ad05ce6e7fa4657f9947a682a889a1df95b45e9", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afbc5ae887b898d2a828d37e1dd8117a079e8243/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afbc5ae887b898d2a828d37e1dd8117a079e8243/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=afbc5ae887b898d2a828d37e1dd8117a079e8243", "patch": "@@ -1,3 +1,45 @@\n+2016-01-15  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/64324\n+\t* resolve.c (check_uop_procedure): Prevent deferred length\n+\tcharacters from being trapped by assumed length error.\n+\n+\tPR fortran/49630\n+\tPR fortran/54070\n+\tPR fortran/60593\n+\tPR fortran/60795\n+\tPR fortran/61147\n+\tPR fortran/64324\n+\t* trans-array.c (gfc_conv_scalarized_array_ref): Pass decl for\n+\tfunction as well as variable expressions.\n+\t(gfc_array_init_size): Add 'expr' as an argument. Use this to\n+\tcorrectly set the descriptor dtype for deferred characters.\n+\t(gfc_array_allocate): Add 'expr' to the call to\n+\t'gfc_array_init_size'.\n+\t* trans.c (gfc_build_array_ref): Expand logic for setting span\n+\tto include indirect references to character lengths.\n+\t* trans-decl.c (gfc_get_symbol_decl): Ensure that deferred\n+\tresult char lengths that are PARM_DECLs are indirectly\n+\treferenced both for directly passed and by reference.\n+\t(create_function_arglist): If the length type is a pointer type\n+\tthen store the length as the 'passed_length' and make the char\n+\tlength an indirect reference to it.\n+\t(gfc_trans_deferred_vars): If a character length has escaped\n+\tbeing set as an indirect reference, return it via the 'passed\n+\tlength'.\n+\t* trans-expr.c (gfc_conv_procedure_call): The length of\n+\tdeferred character length results is set TREE_STATIC and set to\n+\tzero.\n+\t(gfc_trans_assignment_1): Do not fix the rse string_length if\n+\tit is a variable, a parameter or an indirect reference. Add the\n+\tcode to trap assignment of scalars to unallocated arrays.\n+\t* trans-stmt.c (gfc_trans_allocate): Remove 'def_str_len' and\n+\tall references to it. Instead, replicate the code to obtain a\n+\texplicitly defined string length and provide a value before\n+\tarray allocation so that the dtype is correctly set.\n+\ttrans-types.c (gfc_get_character_type): If the character length\n+\tis a pointer, use the indirect reference.\n+\n 2016-01-10  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/69154"}, {"sha": "64d59ceef17cd46d471a73eca5fda926d9fd1b28", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afbc5ae887b898d2a828d37e1dd8117a079e8243/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afbc5ae887b898d2a828d37e1dd8117a079e8243/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=afbc5ae887b898d2a828d37e1dd8117a079e8243", "patch": "@@ -15320,9 +15320,9 @@ check_uop_procedure (gfc_symbol *sym, locus where)\n     }\n \n   if (sym->ts.type == BT_CHARACTER\n-      && !(sym->ts.u.cl && sym->ts.u.cl->length)\n-      && !(sym->result && sym->result->ts.u.cl\n-\t   && sym->result->ts.u.cl->length))\n+      && !((sym->ts.u.cl && sym->ts.u.cl->length) || sym->ts.deferred)\n+      && !(sym->result && ((sym->result->ts.u.cl\n+\t   && sym->result->ts.u.cl->length) || sym->result->ts.deferred)))\n     {\n       gfc_error (\"User operator procedure %qs at %L cannot be assumed \"\n \t\t \"character length\", sym->name, &where);"}, {"sha": "eeb688c9b9114959ffdb37e523931e1886d680f9", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afbc5ae887b898d2a828d37e1dd8117a079e8243/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afbc5ae887b898d2a828d37e1dd8117a079e8243/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=afbc5ae887b898d2a828d37e1dd8117a079e8243", "patch": "@@ -3165,7 +3165,8 @@ gfc_conv_scalarized_array_ref (gfc_se * se, gfc_array_ref * ar)\n \t\t\t     index, info->offset);\n \n   if (expr && (is_subref_array (expr)\n-\t       || (expr->ts.deferred && expr->expr_type == EXPR_VARIABLE)))\n+\t       || (expr->ts.deferred && (expr->expr_type == EXPR_VARIABLE\n+\t\t\t\t\t || expr->expr_type == EXPR_FUNCTION))))\n     decl = expr->symtree->n.sym->backend_decl;\n \n   tmp = build_fold_indirect_ref_loc (input_location, info->data);\n@@ -5038,7 +5039,7 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n \t\t     gfc_expr ** lower, gfc_expr ** upper, stmtblock_t * pblock,\n \t\t     stmtblock_t * descriptor_block, tree * overflow,\n \t\t     tree expr3_elem_size, tree *nelems, gfc_expr *expr3,\n-\t\t     tree expr3_desc, bool e3_is_array_constr)\n+\t\t     tree expr3_desc, bool e3_is_array_constr, gfc_expr *expr)\n {\n   tree type;\n   tree tmp;\n@@ -5063,8 +5064,19 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n   offset = gfc_index_zero_node;\n \n   /* Set the dtype.  */\n-  tmp = gfc_conv_descriptor_dtype (descriptor);\n-  gfc_add_modify (descriptor_block, tmp, gfc_get_dtype (type));\n+  if (expr->ts.type == BT_CHARACTER && expr->ts.deferred\n+      && TREE_CODE (expr->ts.u.cl->backend_decl) == VAR_DECL)\n+    {\n+      type = gfc_typenode_for_spec (&expr->ts);\n+      tmp = gfc_conv_descriptor_dtype (descriptor);\n+      gfc_add_modify (descriptor_block, tmp,\n+\t\t      gfc_get_dtype_rank_type (rank, type));\n+    }\n+  else\n+    {\n+      tmp = gfc_conv_descriptor_dtype (descriptor);\n+      gfc_add_modify (descriptor_block, tmp, gfc_get_dtype (type));\n+    }\n \n   or_expr = boolean_false_node;\n \n@@ -5446,7 +5458,7 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n \t\t\t      ref->u.ar.as->corank, &offset, lower, upper,\n \t\t\t      &se->pre, &set_descriptor_block, &overflow,\n \t\t\t      expr3_elem_size, nelems, expr3, e3_arr_desc,\n-\t\t\t      e3_is_array_constr);\n+\t\t\t      e3_is_array_constr, expr);\n \n   if (dimension)\n     {"}, {"sha": "a0305a6970685fe33ca5b3e85d06212101b039d2", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afbc5ae887b898d2a828d37e1dd8117a079e8243/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afbc5ae887b898d2a828d37e1dd8117a079e8243/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=afbc5ae887b898d2a828d37e1dd8117a079e8243", "patch": "@@ -1377,8 +1377,8 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n \t&& TREE_CODE (sym->ts.u.cl->backend_decl) == PARM_DECL)\n     {\n       sym->ts.u.cl->passed_length = sym->ts.u.cl->backend_decl;\n-      sym->ts.u.cl->backend_decl = NULL_TREE;\n-      length = gfc_create_string_length (sym);\n+      gcc_assert (POINTER_TYPE_P (TREE_TYPE (sym->ts.u.cl->passed_length)));\n+      sym->ts.u.cl->backend_decl = build_fold_indirect_ref (sym->ts.u.cl->backend_decl);\n     }\n \n   fun_or_res = byref && (sym->attr.result\n@@ -1420,9 +1420,12 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n \t\t  /* We need to insert a indirect ref for param decls.  */\n \t\t  if (sym->ts.u.cl->backend_decl\n \t\t      && TREE_CODE (sym->ts.u.cl->backend_decl) == PARM_DECL)\n+\t\t    {\n+\t\t      sym->ts.u.cl->passed_length = sym->ts.u.cl->backend_decl;\n \t\t    sym->ts.u.cl->backend_decl =\n \t\t\tbuild_fold_indirect_ref (sym->ts.u.cl->backend_decl);\n \t\t}\n+\t\t}\n \t      /* For all other parameters make sure, that they are copied so\n \t\t that the value and any modifications are local to the routine\n \t\t by generating a temporary variable.  */\n@@ -1431,6 +1434,10 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n \t\t       && sym->ts.u.cl->backend_decl)\n \t\t{\n \t\t  sym->ts.u.cl->passed_length = sym->ts.u.cl->backend_decl;\n+\t\t  if (POINTER_TYPE_P (TREE_TYPE (sym->ts.u.cl->passed_length)))\n+\t\t    sym->ts.u.cl->backend_decl\n+\t\t\t= build_fold_indirect_ref (sym->ts.u.cl->backend_decl);\n+\t\t  else\n \t\t  sym->ts.u.cl->backend_decl = NULL_TREE;\n \t\t}\n \t    }\n@@ -2264,6 +2271,13 @@ create_function_arglist (gfc_symbol * sym)\n \t      type = gfc_sym_type (arg);\n \t      arg->backend_decl = backend_decl;\n \t      type = build_reference_type (type);\n+\n+\t      if (POINTER_TYPE_P (len_type))\n+\t\t{\n+\t\t  sym->ts.u.cl->passed_length = length;\n+\t\t  sym->ts.u.cl->backend_decl =\n+\t\t    build_fold_indirect_ref_loc (input_location, length);\n+\t\t}\n \t    }\n \t}\n \n@@ -2347,7 +2361,10 @@ create_function_arglist (gfc_symbol * sym)\n \t  if (f->sym->ts.u.cl->backend_decl == NULL\n \t      || f->sym->ts.u.cl->backend_decl == length)\n \t    {\n-\t      if (f->sym->ts.u.cl->backend_decl == NULL)\n+\t      if (POINTER_TYPE_P (len_type))\n+\t\tf->sym->ts.u.cl->backend_decl =\n+\t\t\tbuild_fold_indirect_ref_loc (input_location, length);\n+\t      else if (f->sym->ts.u.cl->backend_decl == NULL)\n \t\tgfc_create_string_length (f->sym);\n \n \t      /* Make sure PARM_DECL type doesn't point to incomplete type.  */\n@@ -3975,12 +3992,19 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \t      gfc_restore_backend_locus (&loc);\n \n \t      /* Pass back the string length on exit.  */\n+\t      tmp = proc_sym->ts.u.cl->backend_decl;\n+\t      if (TREE_CODE (tmp) != INDIRECT_REF)\n+\t\t{\n \t      tmp = proc_sym->ts.u.cl->passed_length;\n \t      tmp = build_fold_indirect_ref_loc (input_location, tmp);\n \t      tmp = fold_convert (gfc_charlen_type_node, tmp);\n \t      tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n \t\t\t\t     gfc_charlen_type_node, tmp,\n \t\t\t\t     proc_sym->ts.u.cl->backend_decl);\n+\t\t}\n+\t      else\n+\t\ttmp = NULL_TREE;\n+\n \t      gfc_add_init_cleanup (block, gfc_finish_block (&init), tmp);\n \t    }\n \t  else if (TREE_CODE (proc_sym->ts.u.cl->backend_decl) == VAR_DECL)"}, {"sha": "863e2aab8786027d0349bf50f53e0fc0642bc3fb", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afbc5ae887b898d2a828d37e1dd8117a079e8243/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afbc5ae887b898d2a828d37e1dd8117a079e8243/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=afbc5ae887b898d2a828d37e1dd8117a079e8243", "patch": "@@ -5942,6 +5942,9 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  tmp = len;\n \t  if (TREE_CODE (tmp) != VAR_DECL)\n \t    tmp = gfc_evaluate_now (len, &se->pre);\n+\t  TREE_STATIC (tmp) = 1;\n+\t  gfc_add_modify (&se->pre, tmp,\n+\t\t\t  build_int_cst (TREE_TYPE (tmp), 0));\n \t  tmp = gfc_build_addr_expr (NULL_TREE, tmp);\n \t  vec_safe_push (retargs, tmp);\n \t}\n@@ -9263,7 +9266,10 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n     }\n \n   /* Stabilize a string length for temporaries.  */\n-  if (expr2->ts.type == BT_CHARACTER && !expr2->ts.deferred)\n+  if (expr2->ts.type == BT_CHARACTER && !expr1->ts.deferred\n+      && !(TREE_CODE (rse.string_length) == VAR_DECL\n+\t   || TREE_CODE (rse.string_length) == PARM_DECL\n+\t   || TREE_CODE (rse.string_length) == INDIRECT_REF))\n     string_length = gfc_evaluate_now (rse.string_length, &rse.pre);\n   else if (expr2->ts.type == BT_CHARACTER)\n     string_length = rse.string_length;\n@@ -9277,7 +9283,32 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n \tlse.string_length = string_length;\n     }\n   else\n+    {\n     gfc_conv_expr (&lse, expr1);\n+      if (gfc_option.rtcheck & GFC_RTCHECK_MEM\n+\t  && gfc_expr_attr (expr1).allocatable\n+\t  && expr1->rank\n+\t  && !expr2->rank)\n+\t{\n+\t  tree cond;\n+\t  const char* msg;\n+\n+\t  tmp = expr1->symtree->n.sym->backend_decl;\n+\t  if (POINTER_TYPE_P (TREE_TYPE (tmp)))\n+\t    tmp = build_fold_indirect_ref_loc (input_location, tmp);\n+\n+\t  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (tmp)))\n+\t    tmp = gfc_conv_descriptor_data_get (tmp);\n+\t  else\n+\t    tmp = TREE_OPERAND (lse.expr, 0);\n+\n+\t  cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t\t\t\t  tmp, build_int_cst (TREE_TYPE (tmp), 0));\n+\t  msg = _(\"Assignment of scalar to unallocated array\");\n+\t  gfc_trans_runtime_check (true, false, cond, &loop.pre,\n+\t\t\t\t   &expr1->where, msg);\n+\t}\n+    }\n \n   /* Assignments of scalar derived types with allocatable components\n      to arrays must be done with a deep copy and the rhs temporary"}, {"sha": "310d2cdb9178b2b5133e931ddacbe9638b839baa", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afbc5ae887b898d2a828d37e1dd8117a079e8243/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afbc5ae887b898d2a828d37e1dd8117a079e8243/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=afbc5ae887b898d2a828d37e1dd8117a079e8243", "patch": "@@ -1437,7 +1437,7 @@ gfc_trans_critical (gfc_code *code)\n \t\t\t  tree_cons (NULL_TREE, tmp, NULL_TREE),\n \t\t\t  NULL_TREE);\n       ASM_VOLATILE_P (tmp) = 1;\n-  \n+\n       gfc_add_expr_to_block (&block, tmp);\n     }\n \n@@ -5298,7 +5298,6 @@ gfc_trans_allocate (gfc_code * code)\n   tree label_finish;\n   tree memsz;\n   tree al_vptr, al_len;\n-  tree def_str_len = NULL_TREE;\n   /* If an expr3 is present, then store the tree for accessing its\n      _vptr, and _len components in the variables, respectively.  The\n      element size, i.e. _vptr%size, is stored in expr3_esize.  Any of\n@@ -5688,7 +5687,6 @@ gfc_trans_allocate (gfc_code * code)\n \t  expr3_esize = fold_build2_loc (input_location, MULT_EXPR,\n \t\t\t\t\t TREE_TYPE (se_sz.expr),\n \t\t\t\t\t tmp, se_sz.expr);\n-\t  def_str_len = gfc_evaluate_now (se_sz.expr, &block);\n \t}\n     }\n \n@@ -5741,16 +5739,6 @@ gfc_trans_allocate (gfc_code * code)\n       se.want_pointer = 1;\n       se.descriptor_only = 1;\n \n-      if (expr->ts.type == BT_CHARACTER\n-\t  && expr->ts.deferred\n-\t  && TREE_CODE (expr->ts.u.cl->backend_decl) == VAR_DECL\n-\t  && def_str_len != NULL_TREE)\n-\t{\n-\t  tmp = expr->ts.u.cl->backend_decl;\n-\t  gfc_add_modify (&block, tmp,\n-\t\t\t  fold_convert (TREE_TYPE (tmp), def_str_len));\n-\t}\n-\n       gfc_conv_expr (&se, expr);\n       if (expr->ts.type == BT_CHARACTER && expr->ts.deferred)\n \t/* se.string_length now stores the .string_length variable of expr\n@@ -5888,6 +5876,20 @@ gfc_trans_allocate (gfc_code * code)\n \t      /* Prevent setting the length twice.  */\n \t      al_len_needs_set = false;\n \t    }\n+\t  else if (expr->ts.type == BT_CHARACTER && al_len != NULL_TREE\n+\t\t   && code->ext.alloc.ts.u.cl->length)\n+\t    {\n+\t      /* Cover the cases where a string length is explicitly\n+\t\t specified by a type spec for deferred length character\n+\t\t arrays or unlimited polymorphic objects without a\n+\t\t source= or mold= expression.  */\n+\t      gfc_init_se (&se_sz, NULL);\n+\t      gfc_conv_expr (&se_sz, code->ext.alloc.ts.u.cl->length);\n+\t      gfc_add_modify (&block, al_len,\n+\t\t\t      fold_convert (TREE_TYPE (al_len),\n+\t\t\t\t\t    se_sz.expr));\n+\t      al_len_needs_set = false;\n+\t    }\n \t}\n \n       gfc_add_block_to_block (&block, &se.pre);"}, {"sha": "f3d084194de1f037f838a1a08c20a211e48133d2", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afbc5ae887b898d2a828d37e1dd8117a079e8243/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afbc5ae887b898d2a828d37e1dd8117a079e8243/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=afbc5ae887b898d2a828d37e1dd8117a079e8243", "patch": "@@ -1045,6 +1045,8 @@ gfc_get_character_type (int kind, gfc_charlen * cl)\n   tree len;\n \n   len = (cl == NULL) ? NULL_TREE : cl->backend_decl;\n+  if (len && POINTER_TYPE_P (TREE_TYPE (len)))\n+    len = build_fold_indirect_ref (len);\n \n   return gfc_get_character_type_len (kind, len);\n }"}, {"sha": "e71430baeb88c93f3915255607a03ef7d3fda1cf", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afbc5ae887b898d2a828d37e1dd8117a079e8243/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afbc5ae887b898d2a828d37e1dd8117a079e8243/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=afbc5ae887b898d2a828d37e1dd8117a079e8243", "patch": "@@ -335,10 +335,13 @@ gfc_build_array_ref (tree base, tree offset, tree decl, tree vptr)\n      references.  */\n   if (type && TREE_CODE (type) == ARRAY_TYPE\n       && TYPE_MAXVAL (TYPE_DOMAIN (type)) != NULL_TREE\n-      && TREE_CODE (TYPE_MAXVAL (TYPE_DOMAIN (type))) == VAR_DECL\n+      && (TREE_CODE (TYPE_MAXVAL (TYPE_DOMAIN (type))) == VAR_DECL\n+\t  || TREE_CODE (TYPE_MAXVAL (TYPE_DOMAIN (type))) == INDIRECT_REF)\n       && decl\n-      && DECL_CONTEXT (TYPE_MAXVAL (TYPE_DOMAIN (type)))\n-\t\t\t\t\t== DECL_CONTEXT (decl))\n+      && (TREE_CODE (TYPE_MAXVAL (TYPE_DOMAIN (type))) == INDIRECT_REF\n+\t  || TREE_CODE (decl) == FUNCTION_DECL\n+\t  || DECL_CONTEXT (TYPE_MAXVAL (TYPE_DOMAIN (type)))\n+\t\t\t\t\t== DECL_CONTEXT (decl)))\n     span = TYPE_MAXVAL (TYPE_DOMAIN (type));\n   else\n     span = NULL_TREE;\n@@ -354,7 +357,8 @@ gfc_build_array_ref (tree base, tree offset, tree decl, tree vptr)\n      and reference the element with pointer arithmetic.  */\n   if ((decl && (TREE_CODE (decl) == FIELD_DECL\n \t\t|| TREE_CODE (decl) == VAR_DECL\n-\t\t|| TREE_CODE (decl) == PARM_DECL)\n+\t\t|| TREE_CODE (decl) == PARM_DECL\n+\t\t|| TREE_CODE (decl) == FUNCTION_DECL)\n        && ((GFC_DECL_SUBREF_ARRAY_P (decl)\n \t    && !integer_zerop (GFC_DECL_SPAN (decl)))\n \t   || GFC_DECL_CLASS (decl)"}, {"sha": "29291a2012baf6bec987a3c90c4118b701746dfe", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afbc5ae887b898d2a828d37e1dd8117a079e8243/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afbc5ae887b898d2a828d37e1dd8117a079e8243/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=afbc5ae887b898d2a828d37e1dd8117a079e8243", "patch": "@@ -1,3 +1,25 @@\n+2016-01-15  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/49630\n+\t* gfortran.dg/deferred_character_13.f90: New test for the fix\n+\tof comment 3 of the PR.\n+\n+\tPR fortran/54070\n+\t* gfortran.dg/deferred_character_8.f90: New test\n+\t* gfortran.dg/allocate_error_5.f90: New test\n+\n+\tPR fortran/60593\n+\t* gfortran.dg/deferred_character_10.f90: New test\n+\n+\tPR fortran/60795\n+\t* gfortran.dg/deferred_character_14.f90: New test\n+\n+\tPR fortran/61147\n+\t* gfortran.dg/deferred_character_11.f90: New test\n+\n+\tPR fortran/64324\n+\t* gfortran.dg/deferred_character_9.f90: New test\n+\n 2016-01-15  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR rtl-optimization/69030"}, {"sha": "4e5f4bd3b30124b64ffd3ff8d2a372c618901d06", "filename": "gcc/testsuite/gfortran.dg/allocate_error_5.f90", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afbc5ae887b898d2a828d37e1dd8117a079e8243/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_error_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afbc5ae887b898d2a828d37e1dd8117a079e8243/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_error_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_error_5.f90?ref=afbc5ae887b898d2a828d37e1dd8117a079e8243", "patch": "@@ -0,0 +1,23 @@\n+! { dg-do run }\n+! { dg-additional-options \"-fcheck=mem\" }\n+! { dg-shouldfail \"Fortran runtime error: Assignment of scalar to unallocated array\" }\n+!\n+! This omission was encountered in the course of fixing PR54070. Whilst this is a\n+! very specific case, others such as allocatable components have been tested.\n+!\n+! Contributed by Tobias Burnus  <burnus@gcc.gnu.org>\n+!\n+function g(a) result (res)\n+  character(len=*) :: a\n+  character(len=:),allocatable :: res(:)\n+  res = a  ! Since 'res' is not allocated, a runtime error should occur.\n+end function\n+\n+  interface\n+    function g(a) result(res)\n+      character(len=*) :: a\n+      character(len=:),allocatable :: res(:)\n+    end function\n+  end interface\n+  print *, g(\"ABC\")\n+end"}, {"sha": "6a3674150a177ac9de736e9bea01a2b922f2facc", "filename": "gcc/testsuite/gfortran.dg/deferred_character_10.f90", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afbc5ae887b898d2a828d37e1dd8117a079e8243/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_10.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afbc5ae887b898d2a828d37e1dd8117a079e8243/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_10.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_10.f90?ref=afbc5ae887b898d2a828d37e1dd8117a079e8243", "patch": "@@ -0,0 +1,52 @@\n+! { dg-do run }\n+!\n+! Checks that PR60593 is fixed (Revision: 214757)\n+!\n+! Contributed by Steve Kargl  <kargl@gcc.gnu.org>\n+!\n+! Main program added for this test.\n+!\n+module stringhelper_m\n+\n+  implicit none\n+\n+  type :: string_t\n+     character(:), allocatable :: string\n+  end type\n+\n+  interface len\n+     function strlen(s) bind(c,name='strlen')\n+       use iso_c_binding\n+       implicit none\n+       type(c_ptr), intent(in), value :: s\n+       integer(c_size_t) :: strlen\n+     end function\n+  end interface\n+\n+  contains\n+\n+    function C2FChar(c_charptr) result(res)\n+      use iso_c_binding\n+      type(c_ptr), intent(in) :: c_charptr\n+      character(:), allocatable :: res\n+      character(kind=c_char,len=1), pointer :: string_p(:)\n+      integer i, c_str_len\n+      c_str_len = int(len(c_charptr))\n+      call c_f_pointer(c_charptr, string_p, [c_str_len])\n+      allocate(character(c_str_len) :: res)\n+      forall (i = 1:c_str_len) res(i:i) = string_p(i)\n+    end function\n+\n+end module\n+\n+  use stringhelper_m\n+  use iso_c_binding\n+  implicit none\n+  type(c_ptr) :: cptr\n+  character(20), target :: str\n+\n+  str = \"abcdefghij\"//char(0)\n+  cptr = c_loc (str)\n+  if (len (C2FChar (cptr)) .ne. 10) call abort\n+  if (C2FChar (cptr) .ne. \"abcdefghij\") call abort\n+end"}, {"sha": "454cf47e1b138b64584629eacd6c4398d168beb7", "filename": "gcc/testsuite/gfortran.dg/deferred_character_11.f90", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afbc5ae887b898d2a828d37e1dd8117a079e8243/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_11.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afbc5ae887b898d2a828d37e1dd8117a079e8243/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_11.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_11.f90?ref=afbc5ae887b898d2a828d37e1dd8117a079e8243", "patch": "@@ -0,0 +1,39 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR61147.\n+!\n+! Contributed by Thomas Clune  <Thomas.L.Clune@nasa.gov>\n+!\n+module B_mod\n+\n+   type :: B\n+      character(:), allocatable :: string\n+   end type B\n+\n+contains\n+\n+   function toPointer(this) result(ptr)\n+      character(:), pointer :: ptr\n+      class (B), intent(in), target :: this\n+\n+         ptr => this%string\n+\n+   end function toPointer\n+\n+end module B_mod\n+\n+program main\n+   use B_mod\n+\n+   type (B) :: obj\n+   character(:), pointer :: p\n+\n+   obj%string = 'foo'\n+   p => toPointer(obj)\n+\n+   If (len (p) .ne. 3) call abort\n+   If (p .ne. \"foo\") call abort\n+\n+end program main\n+\n+"}, {"sha": "cdb6c89375684e4a3474c4bf425042ef15144167", "filename": "gcc/testsuite/gfortran.dg/deferred_character_12.f90", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afbc5ae887b898d2a828d37e1dd8117a079e8243/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_12.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afbc5ae887b898d2a828d37e1dd8117a079e8243/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_12.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_12.f90?ref=afbc5ae887b898d2a828d37e1dd8117a079e8243", "patch": "@@ -0,0 +1,37 @@\n+! { dg-do run }\n+!\n+! Tests the fix for PR63232\n+!\n+! Contributed by Balint Aradi  <baradi09@gmail.com>\n+!\n+module mymod\n+  implicit none\n+\n+  type :: wrapper\n+    character(:), allocatable :: string\n+  end type wrapper\n+\n+contains\n+\n+\n+  subroutine sub2(mystring)\n+    character(:), allocatable, intent(out) :: mystring\n+\n+    mystring = \"test\"\n+\n+  end subroutine sub2\n+\n+end module mymod\n+\n+\n+program test\n+  use mymod\n+  implicit none\n+\n+  type(wrapper) :: mywrapper\n+\n+  call sub2(mywrapper%string)\n+  if (.not. allocated(mywrapper%string)) call abort\n+  if (trim(mywrapper%string) .ne. \"test\") call abort\n+\n+end program test"}, {"sha": "822cc5de3a841bab30ec19ae7486494ea94da225", "filename": "gcc/testsuite/gfortran.dg/deferred_character_13.f90", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afbc5ae887b898d2a828d37e1dd8117a079e8243/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_13.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afbc5ae887b898d2a828d37e1dd8117a079e8243/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_13.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_13.f90?ref=afbc5ae887b898d2a828d37e1dd8117a079e8243", "patch": "@@ -0,0 +1,34 @@\n+! { dg-do run }\n+!\n+! Tests the fix for PR49630 comment #3.\n+!\n+! Contributed by Janus Weil  <janus@gcc.gnu.org>\n+!\n+module abc\n+  implicit none\n+\n+  type::abc_type\n+   contains\n+     procedure::abc_function\n+  end type abc_type\n+\n+contains\n+\n+  function abc_function(this)\n+    class(abc_type),intent(in)::this\n+    character(:),allocatable::abc_function\n+    allocate(abc_function,source=\"hello\")\n+  end function abc_function\n+\n+  subroutine do_something(this)\n+    class(abc_type),intent(in)::this\n+    if (this%abc_function() .ne. \"hello\") call abort\n+  end subroutine do_something\n+\n+end module abc\n+\n+\n+  use abc\n+  type(abc_type) :: a\n+  call do_something(a)\n+end"}, {"sha": "3c4163ee7ac4d3a05a8f8906785c63ded6a9216b", "filename": "gcc/testsuite/gfortran.dg/deferred_character_14.f90", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afbc5ae887b898d2a828d37e1dd8117a079e8243/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_14.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afbc5ae887b898d2a828d37e1dd8117a079e8243/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_14.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_14.f90?ref=afbc5ae887b898d2a828d37e1dd8117a079e8243", "patch": "@@ -0,0 +1,30 @@\n+! { dg-do run }\n+!\n+! Test fix for PR60795 comments #1 and  #4\n+!\n+! Contributed by Kergonath  <kergonath@me.com>\n+!\n+module m\n+contains\n+    subroutine allocate_array(s_array)\n+        character(:), dimension(:), allocatable, intent(out) :: s_array\n+\n+        allocate(character(2) :: s_array(2))\n+        s_array = [\"ab\",\"cd\"]\n+    end subroutine\n+end module\n+\n+program stringtest\n+    use m\n+    character(:), dimension(:), allocatable :: s4\n+    character(:), dimension(:), allocatable :: s\n+! Comment #1\n+    allocate(character(1) :: s(10))\n+    if (size (s) .ne. 10) call abort\n+    if (len (s) .ne. 1) call abort\n+! Comment #4\n+    call allocate_array(s4)\n+    if (size (s4) .ne. 2) call abort\n+    if (len (s4) .ne. 2) call abort\n+    if (any (s4 .ne. [\"ab\", \"cd\"])) call abort\n+ end program"}, {"sha": "009acc1d29066dbcc1cf70ab5503f739be5e6a22", "filename": "gcc/testsuite/gfortran.dg/deferred_character_8.f90", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afbc5ae887b898d2a828d37e1dd8117a079e8243/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afbc5ae887b898d2a828d37e1dd8117a079e8243/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_8.f90?ref=afbc5ae887b898d2a828d37e1dd8117a079e8243", "patch": "@@ -0,0 +1,84 @@\n+! { dg-do run }\n+!\n+! Test the fix for all the remaining issues in PR54070. These were all\n+! concerned with deferred length characters being returned as function results,\n+! except for comment #23 where the descriptor dtype was not correctly set and\n+! array IO failed in consequence.\n+!\n+! Contributed by Tobias Burnus  <burnus@gcc.gnu.org>\n+!\n+! The original comment #1 with an allocate statement.\n+! Allocatable, deferred length scalar resul.\n+function f()\n+  character(len=:),allocatable :: f\n+  allocate (f, source = \"abc\")\n+  f =\"ABC\"\n+end function\n+!\n+! Allocatable, deferred length, explicit, array result\n+function g(a) result (res)\n+  character(len=*) :: a(:)\n+  character(len (a)) :: b(size (a))\n+  character(len=:),allocatable :: res(:)\n+  integer :: i\n+  allocate (character(len(a)) :: res(2*size(a)))\n+  do i = 1, len (a)\n+    b(:)(i:i) = char (ichar (a(:)(i:i)) + 4)\n+  end do\n+  res = [a, b]\n+end function\n+!\n+! Allocatable, deferred length, array result\n+function h(a)\n+  character(len=*) :: a(:)\n+  character(len(a)) :: b (size(a))\n+  character(len=:),allocatable :: h(:)\n+  integer :: i\n+  allocate (character(len(a)) :: h(size(a)))\n+  do i = 1, len (a)\n+    b(:)(i:i) = char (ichar (a(:)(i:i)) + 32)\n+  end do\n+  h = b\n+end function\n+\n+module deferred_length_char_array\n+contains\n+  function return_string(argument)\n+    character(*) :: argument\n+    character(:), dimension(:), allocatable :: return_string\n+    allocate (character (len(argument)) :: return_string(2))\n+    return_string = argument\n+  end function\n+end module\n+\n+  use deferred_length_char_array\n+  character(len=3) :: chr(3)\n+  character(:), pointer :: s(:)\n+  character(6) :: buffer\n+  interface\n+    function f()\n+      character(len=:),allocatable :: f\n+    end function\n+    function g(a) result(res)\n+      character(len=*) :: a(:)\n+      character(len=:),allocatable :: res(:)\n+    end function\n+    function h(a)\n+      character(len=*) :: a(:)\n+      character(len=:),allocatable :: h(:)\n+    end function\n+  end interface\n+\n+  if (f () .ne. \"ABC\") call abort\n+  if (any (g ([\"ab\",\"cd\"]) .ne. [\"ab\",\"cd\",\"ef\",\"gh\"])) call abort\n+  chr = h ([\"ABC\",\"DEF\",\"GHI\"])\n+  if (any (chr .ne. [\"abc\",\"def\",\"ghi\"])) call abort\n+  if (any (return_string (\"abcdefg\") .ne. [\"abcdefg\",\"abcdefg\"])) call abort\n+\n+! Comment #23\n+  allocate(character(3)::s(2))\n+  s(1) = 'foo'\n+  s(2) = 'bar'\n+  write (buffer, '(2A3)') s\n+  if (buffer .ne. 'foobar') call abort\n+end"}, {"sha": "f88de7a4ad5397a1332e1f2f6fe16fe552320a88", "filename": "gcc/testsuite/gfortran.dg/deferred_character_9.f90", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afbc5ae887b898d2a828d37e1dd8117a079e8243/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afbc5ae887b898d2a828d37e1dd8117a079e8243/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_9.f90?ref=afbc5ae887b898d2a828d37e1dd8117a079e8243", "patch": "@@ -0,0 +1,28 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR64324 in which deferred length user ops\n+! were being mistaken as assumed length and so rejected.\n+!\n+! Contributed by Ian Harvey  <ian_harvey@bigpond.com>\n+!\n+MODULE m\n+  IMPLICIT NONE\n+  INTERFACE OPERATOR(.ToString.)\n+    MODULE PROCEDURE tostring\n+  END INTERFACE OPERATOR(.ToString.)\n+CONTAINS\n+  FUNCTION tostring(arg)\n+    INTEGER, INTENT(IN) :: arg\n+    CHARACTER(:), ALLOCATABLE :: tostring\n+    allocate (character(5) :: tostring)\n+    write (tostring, \"(I5)\") arg\n+  END FUNCTION tostring\n+END MODULE m\n+\n+  use m\n+  character(:), allocatable :: str\n+  integer :: i = 999\n+  str = .ToString. i\n+  if (str .ne. \"  999\") call abort\n+end\n+"}]}