{"sha": "b7f6588dd26feb66e936f4a3817d28c8ea929fae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjdmNjU4OGRkMjZmZWI2NmU5MzZmNGEzODE3ZDI4YzhlYTkyOWZhZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-02-16T04:52:31Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-02-16T04:52:31Z"}, "message": "tree.c (first_rtl_op): New fn.\n\n\t* tree.c (first_rtl_op): New fn.\n\t(unsave_expr_now): Use it.\n\t* print-tree.c (print_node): Likewise.\n\t* tree.c (has_cleanups): New fn.\n\t* fold-const.c (fold, case CLEANUP_POINT_EXPR): Use it.  Be more\n\tconservative about pushing the cleanup point down.\n\t* tree.h: Declare them.\n\nFrom-SVN: r18023", "tree": {"sha": "a79a0fce1411246619cb9375b2e5e885167e3226", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a79a0fce1411246619cb9375b2e5e885167e3226"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7f6588dd26feb66e936f4a3817d28c8ea929fae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7f6588dd26feb66e936f4a3817d28c8ea929fae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7f6588dd26feb66e936f4a3817d28c8ea929fae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7f6588dd26feb66e936f4a3817d28c8ea929fae/comments", "author": null, "committer": null, "parents": [{"sha": "f75778a8d6315df5f100475fa2cd1bb0423d8019", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f75778a8d6315df5f100475fa2cd1bb0423d8019", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f75778a8d6315df5f100475fa2cd1bb0423d8019"}], "stats": {"total": 150, "additions": 112, "deletions": 38}, "files": [{"sha": "ce452cb14a921b27b13bc74ff1abaf059b36a031", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7f6588dd26feb66e936f4a3817d28c8ea929fae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7f6588dd26feb66e936f4a3817d28c8ea929fae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b7f6588dd26feb66e936f4a3817d28c8ea929fae", "patch": "@@ -1,3 +1,13 @@\n+1998-02-16  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* tree.c (first_rtl_op): New fn.\n+\t(unsave_expr_now): Use it.\n+\t* print-tree.c (print_node): Likewise.\n+\t* tree.c (has_cleanups): New fn.\n+\t* fold-const.c (fold, case CLEANUP_POINT_EXPR): Use it.  Be more\n+\tconservative about pushing the cleanup point down.\n+\t* tree.h: Declare them.\n+\n Sun Feb 15 23:28:44 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* toplev.c (flag_schedule_reverse_before_reload): Delete variable."}, {"sha": "35d8bebe9164a991cccc5be58e7c8601d1de9398", "filename": "gcc/fold-const.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7f6588dd26feb66e936f4a3817d28c8ea929fae/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7f6588dd26feb66e936f4a3817d28c8ea929fae/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=b7f6588dd26feb66e936f4a3817d28c8ea929fae", "patch": "@@ -5920,7 +5920,7 @@ fold (expr)\n       /* Pull arithmetic ops out of the CLEANUP_POINT_EXPR where\n          appropriate.  */\n     case CLEANUP_POINT_EXPR:\n-      if (! TREE_SIDE_EFFECTS (arg0))\n+      if (! has_cleanups (arg0))\n \treturn TREE_OPERAND (t, 0);\n \n       {\n@@ -5941,12 +5941,14 @@ fold (expr)\n \t  {\n \t    arg01 = TREE_OPERAND (arg0, 1);\n \n-\t    if (! TREE_SIDE_EFFECTS (arg00))\n+\t    if (TREE_CONSTANT (arg00)\n+\t\t|| ((code0 == TRUTH_ANDIF_EXPR || code0 == TRUTH_ORIF_EXPR)\n+\t\t    && ! has_cleanups (arg00)))\n \t      return fold (build (code0, type, arg00,\n \t\t\t\t  fold (build1 (CLEANUP_POINT_EXPR,\n \t\t\t\t\t\tTREE_TYPE (arg01), arg01))));\n \n-\t    if (! TREE_SIDE_EFFECTS (arg01))\n+\t    if (TREE_CONSTANT (arg01))\n \t      return fold (build (code0, type,\n \t\t\t\t  fold (build1 (CLEANUP_POINT_EXPR,\n \t\t\t\t\t\tTREE_TYPE (arg00), arg00)),"}, {"sha": "5b81bc5dd9f83511781b4dbe0e7425c61728e8d6", "filename": "gcc/print-tree.c", "status": "modified", "additions": 3, "deletions": 22, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7f6588dd26feb66e936f4a3817d28c8ea929fae/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7f6588dd26feb66e936f4a3817d28c8ea929fae/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=b7f6588dd26feb66e936f4a3817d28c8ea929fae", "patch": "@@ -547,29 +547,10 @@ print_node (file, prefix, node, indent)\n \t  return;\n \t}\n \n-      first_rtl = len = tree_code_length[(int) TREE_CODE (node)];\n-      /* These kinds of nodes contain rtx's, not trees,\n+      len = tree_code_length[(int) TREE_CODE (node)];\n+      /* Some nodes contain rtx's, not trees,\n \t after a certain point.  Print the rtx's as rtx's.  */\n-      switch (TREE_CODE (node))\n-\t{\n-\tcase SAVE_EXPR:\n-\t  first_rtl = 2;\n-\t  break;\n-\tcase CALL_EXPR:\n-\t  first_rtl = 2;\n-\t  break;\n-\tcase METHOD_CALL_EXPR:\n-\t  first_rtl = 3;\n-\t  break;\n-\tcase WITH_CLEANUP_EXPR:\n-\t  /* Should be defined to be 2.  */\n-\t  first_rtl = 1;\n-\t  break;\n-\tcase RTL_EXPR:\n-\t  first_rtl = 0;\n-\tdefault:\n-\t  break;\n-\t}\n+      first_rtl = first_rtl_op (TREE_CODE (node));\n       for (i = 0; i < len; i++)\n \t{\n \t  if (i >= first_rtl)"}, {"sha": "1f135328717e33d579fdc90548df859a9d76335b", "filename": "gcc/tree.c", "status": "modified", "additions": 84, "deletions": 13, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7f6588dd26feb66e936f4a3817d28c8ea929fae/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7f6588dd26feb66e936f4a3817d28c8ea929fae/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=b7f6588dd26feb66e936f4a3817d28c8ea929fae", "patch": "@@ -2387,6 +2387,31 @@ unsave_expr (expr)\n   return t;\n }\n \n+/* Returns the index of the first non-tree operand for CODE, or the number\n+   of operands if all are trees.  */\n+\n+int\n+first_rtl_op (code)\n+     enum tree_code code;\n+{\n+  switch (code)\n+    {\n+    case SAVE_EXPR:\n+      return 2;\n+    case RTL_EXPR:\n+      return 0;\n+    case CALL_EXPR:\n+      return 2;\n+    case WITH_CLEANUP_EXPR:\n+      /* Should be defined to be 2.  */\n+      return 1;\n+    case METHOD_CALL_EXPR:\n+      return 3;\n+    default:\n+      return tree_code_length [(int) code];\n+    }\n+}\n+\n /* Modify a tree in place so that all the evaluate only once things\n    are cleared out.  Return the EXPR given.  */\n \n@@ -2402,12 +2427,11 @@ unsave_expr_now (expr)\n     return expr;\n \n   code = TREE_CODE (expr);\n-  first_rtl = tree_code_length [(int) code];\n+  first_rtl = first_rtl_op (code);\n   switch (code)\n     {\n     case SAVE_EXPR:\n       SAVE_EXPR_RTL (expr) = 0;\n-      first_rtl = 2;\n       break;\n \n     case TARGET_EXPR:\n@@ -2419,7 +2443,6 @@ unsave_expr_now (expr)\n       /* I don't yet know how to emit a sequence multiple times.  */\n       if (RTL_EXPR_SEQUENCE (expr) != 0)\n \tabort ();\n-      first_rtl = 0;\n       break;\n \n     case CALL_EXPR:\n@@ -2434,16 +2457,6 @@ unsave_expr_now (expr)\n \t      exp = TREE_CHAIN (exp);\n \t    }\n \t}\n-      first_rtl = 2;\n-      break;\n-\n-    case WITH_CLEANUP_EXPR:\n-      /* Should be defined to be 2.  */\n-      first_rtl = 1;\n-      break;\n-\n-    case METHOD_CALL_EXPR:\n-      first_rtl = 3;\n       break;\n \n     default:\n@@ -2561,6 +2574,64 @@ contains_placeholder_p (exp)\n       return 0;\n     }\n }\n+\n+/* Return 1 if EXP contains any expressions that produce cleanups for an\n+   outer scope to deal with.  Used by fold.  */\n+\n+int\n+has_cleanups (exp)\n+     tree exp;\n+{\n+  int i, nops, cmp;\n+\n+  if (! TREE_SIDE_EFFECTS (exp))\n+    return 0;\n+\n+  switch (TREE_CODE (exp))\n+    {\n+    case TARGET_EXPR:\n+    case WITH_CLEANUP_EXPR:\n+      return 1;\n+\n+    case CLEANUP_POINT_EXPR:\n+      return 0;\n+\n+    case CALL_EXPR:\n+      for (exp = TREE_OPERAND (exp, 1); exp; exp = TREE_CHAIN (exp))\n+\t{\n+\t  cmp = has_cleanups (TREE_VALUE (exp));\n+\t  if (cmp)\n+\t    return cmp;\n+\t}\n+      return 0;\n+\n+    default:\n+      break;\n+    }\n+\n+  /* This general rule works for most tree codes.  All exceptions should be\n+     handled above.  If this is a language-specific tree code, we can't\n+     trust what might be in the operand, so say we don't know\n+     the situation.  */\n+  if ((int) TREE_CODE (exp) >= (int) LAST_AND_UNUSED_TREE_CODE)\n+    return -1;\n+\n+  nops = first_rtl_op (TREE_CODE (exp));\n+  for (i = 0; i < nops; i++)\n+    if (TREE_OPERAND (exp, i) != 0)\n+      {\n+\tint type = TREE_CODE_CLASS (TREE_CODE (TREE_OPERAND (exp, i)));\n+\tif (type == 'e' || type == '<' || type == '1' || type == '2'\n+\t    || type == 'r' || type == 's')\n+\t  {\n+\t    cmp = has_cleanups (TREE_OPERAND (exp, i));\n+\t    if (cmp)\n+\t      return cmp;\n+\t  }\n+      }\n+\n+  return 0;\n+}\n \f\n /* Given a tree EXP, a FIELD_DECL F, and a replacement value R,\n    return a tree with all occurrences of references to F in a"}, {"sha": "39ec3033055679ce03cc7cca23fe345d92978779", "filename": "gcc/tree.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7f6588dd26feb66e936f4a3817d28c8ea929fae/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7f6588dd26feb66e936f4a3817d28c8ea929fae/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=b7f6588dd26feb66e936f4a3817d28c8ea929fae", "patch": "@@ -1490,6 +1490,11 @@ extern int lvalue_or_else\t\tPROTO((tree, char *));\n \n extern tree save_expr\t\t\tPROTO((tree));\n \n+/* Returns the index of the first non-tree operand for CODE, or the number\n+   of operands if all are trees.  */\n+\n+extern int first_rtl_op\t\t\tPROTO((enum tree_code));\n+\n /* unsave_expr (EXP) returns an expression equivalent to EXP but it\n    can be used multiple times and will evaluate EXP, in it's entirety\n    each time.  */\n@@ -1509,6 +1514,11 @@ extern tree unsave_expr_now\t\tPROTO((tree));\n \n extern int contains_placeholder_p\tPROTO((tree));\n \n+/* Return 1 if EXP contains any expressions that produce cleanups for an\n+   outer scope to deal with.  Used by fold.  */\n+\n+extern int has_cleanups\t\t\tPROTO((tree));\n+\n /* Given a tree EXP, a FIELD_DECL F, and a replacement value R,\n    return a tree with all occurrences of references to F in a\n    PLACEHOLDER_EXPR replaced by R.   Note that we assume here that EXP"}]}