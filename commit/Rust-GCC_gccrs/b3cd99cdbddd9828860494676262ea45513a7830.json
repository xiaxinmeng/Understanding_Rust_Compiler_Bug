{"sha": "b3cd99cdbddd9828860494676262ea45513a7830", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjNjZDk5Y2RiZGRkOTgyODg2MDQ5NDY3NjI2MmVhNDU1MTNhNzgzMA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@libertysurf.fr", "date": "2003-10-25T12:55:18Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2003-10-25T12:55:18Z"}, "message": "re PR target/12712 (ICE on short legit C++ code fragment with gcc 3.3.2)\n\n\tPR target/12712\n\t* reg-stack.c (convert_regs_1): Create an arbitrary input stack\n\tif the block has no predecessors.\n\t(convert_regs_2): Document the problem with successors whose\n\tonly predecessor is the block to be processed.\n\t(convert_regs): Don't create the arbitrary input stack here.\n\nFrom-SVN: r72923", "tree": {"sha": "9c312b258a5817d52418700fabb9eb90a166cc5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c312b258a5817d52418700fabb9eb90a166cc5e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3cd99cdbddd9828860494676262ea45513a7830", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3cd99cdbddd9828860494676262ea45513a7830", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3cd99cdbddd9828860494676262ea45513a7830", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3cd99cdbddd9828860494676262ea45513a7830/comments", "author": {"login": "ebotcazou", "id": 48091907, "node_id": "MDQ6VXNlcjQ4MDkxOTA3", "avatar_url": "https://avatars.githubusercontent.com/u/48091907?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebotcazou", "html_url": "https://github.com/ebotcazou", "followers_url": "https://api.github.com/users/ebotcazou/followers", "following_url": "https://api.github.com/users/ebotcazou/following{/other_user}", "gists_url": "https://api.github.com/users/ebotcazou/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebotcazou/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebotcazou/subscriptions", "organizations_url": "https://api.github.com/users/ebotcazou/orgs", "repos_url": "https://api.github.com/users/ebotcazou/repos", "events_url": "https://api.github.com/users/ebotcazou/events{/privacy}", "received_events_url": "https://api.github.com/users/ebotcazou/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "999bf60f6a7358d43fd2b53532d4df3772cde468", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/999bf60f6a7358d43fd2b53532d4df3772cde468", "html_url": "https://github.com/Rust-GCC/gccrs/commit/999bf60f6a7358d43fd2b53532d4df3772cde468"}], "stats": {"total": 83, "additions": 64, "deletions": 19}, "files": [{"sha": "e4dd113d815cca5e25ebe83572107dfaa07ef481", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3cd99cdbddd9828860494676262ea45513a7830/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3cd99cdbddd9828860494676262ea45513a7830/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b3cd99cdbddd9828860494676262ea45513a7830", "patch": "@@ -1,3 +1,12 @@\n+2003-10-25  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\tPR target/12712\n+\t* reg-stack.c (convert_regs_1): Create an arbitrary input stack\n+\tif the block has no predecessors.\n+\t(convert_regs_2): Document the problem with successors whose\n+\tonly predecessor is the block to be processed.\n+\t(convert_regs): Don't create the arbitrary input stack here.\n+\n 2003-10-24  Zack Weinberg  <zack@codesourcery.com>\n \n \t* genmodes.c (struct mode_data): Add contained and next_cont"}, {"sha": "50bc63fcb0c6c90873b98e9872f7058564630d25", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 30, "deletions": 19, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3cd99cdbddd9828860494676262ea45513a7830/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3cd99cdbddd9828860494676262ea45513a7830/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=b3cd99cdbddd9828860494676262ea45513a7830", "patch": "@@ -2675,10 +2675,24 @@ convert_regs_1 (FILE *file, basic_block block)\n \tbeste = e;\n     }\n \n-  /* Entry block does have stack already initialized.  */\n+  /* Initialize stack at block entry.  */\n   if (bi->stack_in.top == -2)\n-    inserted |= compensate_edge (beste, file);\n+    {\n+      if (beste)\n+\tinserted |= compensate_edge (beste, file);\n+      else\n+\t{\n+\t  /* No predecessors.  Create an arbitrary input stack.  */\n+\t  int reg;\n+\n+\t  bi->stack_in.top = -1;\n+\t  for (reg = LAST_STACK_REG; reg >= FIRST_STACK_REG; --reg)\n+\t    if (TEST_HARD_REG_BIT (bi->stack_in.reg_set, reg))\n+\t      bi->stack_in.reg[++bi->stack_in.top] = reg;\n+\t}\n+    }\n   else\n+    /* Entry blocks do have stack already initialized.  */\n     beste = NULL;\n \n   current_block = block;\n@@ -2833,12 +2847,19 @@ convert_regs_2 (FILE *file, basic_block block)\n \n       block = *--sp;\n \n-      /* Processing \"block\" is achieved by convert_regs_1, which may purge\n-\t some dead EH outgoing edge after the possible deletion of the\n-\t trapping insn inside the block.  Since the number of predecessors of\n-\t \"block\"'s successors has been computed based on the initial edge set,\n-\t we check for the possibility to process some of these successors\n-\t before such an edge deletion may happen.  */\n+      /* Processing BLOCK is achieved by convert_regs_1, which may purge\n+\t some dead EH outgoing edge after the deletion of the trapping\n+\t insn inside the block.  Since the number of predecessors of\n+\t BLOCK's successors was computed based on the initial edge set,\n+\t we check the necessity to process some of these successors\n+\t before such an edge deletion may happen.  However, there is\n+\t a pitfall: if BLOCK is the only predecessor of a successor and\n+\t the edge between them happens to be deleted, the successor\n+\t becomes unreachable and should not be processed.  The problem\n+\t is that there is no way to preventively detect this case so we\n+\t stack the successor in all cases and hand over the task of\n+\t fixing up the discrepancy to convert_regs_1.  */\n+\n       for (e = block->succ; e ; e = e->succ_next)\n \tif (! (e->flags & EDGE_DFS_BACK))\n \t  {\n@@ -2888,17 +2909,7 @@ convert_regs (FILE *file)\n       block_info bi = BLOCK_INFO (b);\n \n       if (! bi->done)\n-\t{\n-\t  int reg;\n-\n-\t  /* Create an arbitrary input stack.  */\n-\t  bi->stack_in.top = -1;\n-\t  for (reg = LAST_STACK_REG; reg >= FIRST_STACK_REG; --reg)\n-\t    if (TEST_HARD_REG_BIT (bi->stack_in.reg_set, reg))\n-\t      bi->stack_in.reg[++bi->stack_in.top] = reg;\n-\n-\t  inserted |= convert_regs_2 (file, b);\n-\t}\n+\tinserted |= convert_regs_2 (file, b);\n     }\n   clear_aux_for_blocks ();\n "}, {"sha": "28a067b1a6d5f9a0e5c5997dbb9e3ac3ecf73fd2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3cd99cdbddd9828860494676262ea45513a7830/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3cd99cdbddd9828860494676262ea45513a7830/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b3cd99cdbddd9828860494676262ea45513a7830", "patch": "@@ -1,3 +1,7 @@\n+2003-10-25  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\t* g++.dg/opt/reg-stack3.C: New test.\n+\n 2003-10-24  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \t* gcc.dg/c99-arraydecl-2.c: New test.  PR c/11943."}, {"sha": "48dcb335b21e9a7b1701c8384b656b45a0c75e5a", "filename": "gcc/testsuite/g++.dg/opt/reg-stack3.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3cd99cdbddd9828860494676262ea45513a7830/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Freg-stack3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3cd99cdbddd9828860494676262ea45513a7830/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Freg-stack3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Freg-stack3.C?ref=b3cd99cdbddd9828860494676262ea45513a7830", "patch": "@@ -0,0 +1,21 @@\n+// PR target/12712\n+// Origin: Markus Schoder <gccbug@gammarayburst.de>\n+\n+// This used to segfault on x86 because the reg-stack pass\n+// created an unreachable basic block by purging an outgoing\n+// edge, and was not prepared to handle it.\n+\n+// { dg-do compile }\n+\n+struct A\n+{\n+  ~A();\n+  float f(float x);\n+  float g() const {return 0;}\n+};\n+\n+void h()\n+{\n+  A a, b;\n+  a.f(b.g() + 1);\n+}"}]}