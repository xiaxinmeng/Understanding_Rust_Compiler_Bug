{"sha": "adb1c4d1e0511ae9dbfa4da277e18e9394f792d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWRiMWM0ZDFlMDUxMWFlOWRiZmE0ZGEyNzdlMThlOTM5NGY3OTJkNQ==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2013-02-11T00:19:41Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2013-02-11T00:19:41Z"}, "message": "containers.xml: Add section on unordered containers.\n\n2013-02-10  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\t    Jonathan Wakely  <jwakely.gcc@gmail.com>\n\n\t* doc/xml/manual/containers.xml: Add section on unordered containers.\n\t* doc/xml/manual/using.xml: Fix incomplete sentence.\n\nCo-Authored-By: Jonathan Wakely <jwakely.gcc@gmail.com>\n\nFrom-SVN: r195937", "tree": {"sha": "bed9dcada7a77987ad57060d14d02d442aa2a70b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bed9dcada7a77987ad57060d14d02d442aa2a70b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/adb1c4d1e0511ae9dbfa4da277e18e9394f792d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adb1c4d1e0511ae9dbfa4da277e18e9394f792d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/adb1c4d1e0511ae9dbfa4da277e18e9394f792d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adb1c4d1e0511ae9dbfa4da277e18e9394f792d5/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfed5434f3946d39cef0d6965891a927f8b388d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfed5434f3946d39cef0d6965891a927f8b388d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfed5434f3946d39cef0d6965891a927f8b388d2"}], "stats": {"total": 90, "additions": 88, "deletions": 2}, "files": [{"sha": "32b391ee475e539bf8aac2377f6a0e7d39bcfc4b", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb1c4d1e0511ae9dbfa4da277e18e9394f792d5/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb1c4d1e0511ae9dbfa4da277e18e9394f792d5/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=adb1c4d1e0511ae9dbfa4da277e18e9394f792d5", "patch": "@@ -1,3 +1,9 @@\n+2013-02-10  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\t    Jonathan Wakely  <jwakely.gcc@gmail.com>\n+\n+\t* doc/xml/manual/containers.xml: Add section on unordered containers.\n+\t* doc/xml/manual/using.xml: Fix incomplete sentence.\n+\n 2013-02-10  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \n \tPR libstdc++/56267"}, {"sha": "920b491db3658b3a24226df59c591e805f7f9722", "filename": "libstdc++-v3/doc/xml/manual/containers.xml", "status": "modified", "additions": 81, "deletions": 1, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb1c4d1e0511ae9dbfa4da277e18e9394f792d5/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fcontainers.xml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb1c4d1e0511ae9dbfa4da277e18e9394f792d5/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fcontainers.xml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fcontainers.xml?ref=adb1c4d1e0511ae9dbfa4da277e18e9394f792d5", "patch": "@@ -349,7 +349,87 @@\n \n </section>\n \n-<!-- Sect1 03 : Interacting with C -->\n+<!-- Sect1 03 : Unordered Associative -->\n+<section xml:id=\"std.containers.unordered\" xreflabel=\"Unordered\">\n+  <info><title>Unordered Associative</title></info>\n+  <?dbhtml filename=\"unordered_associative.html\"?>\n+\n+  <section xml:id=\"containers.unordered.hash\" xreflabel=\"Hash\">\n+    <info><title>Hash Code</title></info>\n+\n+  <section xml:id=\"containers.unordered.cache\" xreflabel=\"Cache\">\n+    <info><title>Hash Code Caching Policy</title></info>\n+\n+    <para>\n+      The unordered containers in libstdc++ may cache the hash code for each\n+      element alongside the element itself. In some cases not recalculating\n+      the hash code every time it's needed can improve performance, but the\n+      additional memory overhead can also reduce performance, so whether an\n+      unordered associative container caches the hash code or not depends on\n+      a number of factors. The caching policy for GCC 4.8 is described below.\n+    </para>\n+    <para>\n+      The C++ standard requires that <code>erase</code> and <code>swap</code>\n+      operations must not throw exceptions. Those operations might need an\n+      element's hash code, but cannot use the hash function if it could\n+      throw.\n+      This means the hash codes will be cached unless the hash function\n+      has a non-throwing exception specification such as <code>noexcept</code>\n+      or <code>throw()</code>.\n+    </para>\n+    <para>\n+      Secondly, libstdc++ also needs the hash code in the implementation of\n+      <code>local_iterator</code> and <code>const_local_iterator</code> in\n+      order to know when the iterator has reached the end of the bucket.\n+      This means that the local iterator types will embed a copy of the hash\n+      function when possible.\n+      Because the local iterator types must be DefaultConstructible and\n+      CopyAssignable, if the hash function type does not model those concepts\n+      then it cannot be embedded and so the hash code must be cached.\n+      Note that a hash function might not be safe to use when\n+      default-constructed (e.g if it a function pointer) so a hash\n+      function that is contained in a local iterator won't be used until\n+      the iterator is valid, so the hash function has been copied from a\n+      correctly-initialized object.\n+    </para>\n+    <para>\n+      If the hash function is non-throwing, DefaultConstructible and\n+      CopyAssignable then libstdc++ doesn't need to cache the hash code for\n+      correctness, but might still do so for performance if computing a\n+      hash code is an expensive operation, as it may be for arbitrarily\n+      long strings.\n+      As an extension libstdc++ provides a trait type to describe whether\n+      a hash function is fast. By default hash functions are assumed to be\n+      fast unless the trait is specialized for the hash function and the\n+      trait's value is false, in which case the hash code will always be\n+      cached.\n+      The trait can be specialized for user-defined hash functions like so:\n+    </para>\n+    <programlisting>\n+      #include &lt;unordered_set&gt;\n+\n+      struct hasher\n+      {\n+        std::size_t operator()(int val) const noexcept\n+        {\n+          // Some very slow computation of a hash code from an int !\n+          ...\n+        }\n+      }\n+\n+      namespace std\n+      {\n+        template&lt;&gt;\n+          struct __is_fast_hash&lt;hasher&gt; : std::false_type\n+          { };\n+      }\n+    </programlisting>\n+  </section>\n+</section>\n+\n+</section>\n+\n+<!-- Sect1 04 : Interacting with C -->\n <section xml:id=\"std.containers.c\" xreflabel=\"Interacting with C\"><info><title>Interacting with C</title></info>\n <?dbhtml filename=\"containers_and_c.html\"?>\n   "}, {"sha": "dfc5cef2408f9d69fd092972c7022db2149761cf", "filename": "libstdc++-v3/doc/xml/manual/using.xml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb1c4d1e0511ae9dbfa4da277e18e9394f792d5/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fusing.xml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb1c4d1e0511ae9dbfa4da277e18e9394f792d5/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fusing.xml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fusing.xml?ref=adb1c4d1e0511ae9dbfa4da277e18e9394f792d5", "patch": "@@ -755,7 +755,7 @@ g++ -Winvalid-pch -I. -include stdc++.h -H -g -O2 hello.cc -o test.exe\n . /mnt/share/bld/H-x86-gcc.20071201include/c++/4.3.0/string\n </programlisting>\n \n-<para>The exclamation point to the left of the <code>stdc++.h.gch</code> listing means that the generated PCH file was used, and thus the </para>\n+<para>The exclamation point to the left of the <code>stdc++.h.gch</code> listing means that the generated PCH file was used.</para>\n <para/>\n \n <para> Detailed information about creating precompiled header files can be found in the GCC <link xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"http://gcc.gnu.org/onlinedocs/gcc/Precompiled-Headers.html\">documentation</link>."}]}