{"sha": "96adcacb9fbc80b23bb48060baed22498027e533", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTZhZGNhY2I5ZmJjODBiMjNiYjQ4MDYwYmFlZDIyNDk4MDI3ZTUzMw==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@redhat.com", "date": "2002-03-28T04:04:20Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2002-03-28T04:04:20Z"}, "message": "hex.c: Add documentation.\n\n* hex.c: Add documentation.\n(_hex_value): Provide non-ASCII empty table.\n(hex_init): Initialize the non-ASCII table.\n* functions.texi: Regenerate.\n\nFrom-SVN: r51496", "tree": {"sha": "4c1c90c4e896cf2aa5fbbc2c4272b75986e5b34c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c1c90c4e896cf2aa5fbbc2c4272b75986e5b34c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/96adcacb9fbc80b23bb48060baed22498027e533", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96adcacb9fbc80b23bb48060baed22498027e533", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96adcacb9fbc80b23bb48060baed22498027e533", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96adcacb9fbc80b23bb48060baed22498027e533/comments", "author": null, "committer": null, "parents": [{"sha": "a3ebd14d24d97379462543660912c2536c2aafc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3ebd14d24d97379462543660912c2536c2aafc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3ebd14d24d97379462543660912c2536c2aafc2"}], "stats": {"total": 116, "additions": 110, "deletions": 6}, "files": [{"sha": "50a323f1bef779f2717b11a673c56c05b334e340", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96adcacb9fbc80b23bb48060baed22498027e533/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96adcacb9fbc80b23bb48060baed22498027e533/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=96adcacb9fbc80b23bb48060baed22498027e533", "patch": "@@ -1,3 +1,10 @@\n+2002-03-27  DJ Delorie  <dj@redhat.com>\n+\n+\t* hex.c: Add documentation.\n+\t(_hex_value): Provide non-ASCII empty table.\n+\t(hex_init): Initialize the non-ASCII table.\n+\t* functions.texi: Regenerate.\n+\n 2002-03-27  Mark Mitchell  <mark@codesourcery.com>\n \n \t* dyn-string.c: Add libgcc exception to copyright notice."}, {"sha": "b518243d95a6729c7603b29a749cf933ad4c37bb", "filename": "libiberty/functions.texi", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96adcacb9fbc80b23bb48060baed22498027e533/libiberty%2Ffunctions.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96adcacb9fbc80b23bb48060baed22498027e533/libiberty%2Ffunctions.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ffunctions.texi?ref=96adcacb9fbc80b23bb48060baed22498027e533", "patch": "@@ -317,6 +317,34 @@ between calls to @code{getpwd}.\n \n @end deftypefn\n \n+@c hex.c:25\n+@deftypefn Extension void hex_init (void)\n+\n+Initializes the array mapping the current character set to\n+corresponding hex values.  This function must be called before any\n+call to @code{hex_p} or @code{hex_value}.\n+\n+@end deftypefn\n+\n+@c hex.c:33\n+@deftypefn Extension int hex_p (int @var{c})\n+\n+Evaluates to non-zero if the given character is a valid hex character,\n+or zero if it is not.  Note that the value you pass will be cast to\n+@code{unsigned char} within the macro.\n+\n+@end deftypefn\n+\n+@c hex.c:41\n+@deftypefn Extension int hex_value (int @var{c})\n+\n+Returns the numeric equivalent of the given character when interpreted\n+as a hexidecimal digit.  The result is undefined if you pass an\n+invalid hex digit.  Note that the value you pass will be cast to\n+@code{unsigned char} within the macro.\n+\n+@end deftypefn\n+\n @c index.c:5\n @deftypefn Supplemental char* index (char *@var{s}, int @var{c})\n "}, {"sha": "5f8229253494de21455e83b86766ca9e5002de11", "filename": "libiberty/hex.c", "status": "modified", "additions": 75, "deletions": 6, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96adcacb9fbc80b23bb48060baed22498027e533/libiberty%2Fhex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96adcacb9fbc80b23bb48060baed22498027e533/libiberty%2Fhex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fhex.c?ref=96adcacb9fbc80b23bb48060baed22498027e533", "patch": "@@ -20,11 +20,40 @@ Boston, MA 02111-1307, USA.  */\n #include <stdio.h>  /* for EOF */\n #include \"libiberty.h\"\n \n-/* Provided for ABI compatibility.  */\n-void\n-hex_init ()\n-{\n-}\n+/*\n+\n+@deftypefn Extension void hex_init (void)\n+\n+Initializes the array mapping the current character set to\n+corresponding hex values.  This function must be called before any\n+call to @code{hex_p} or @code{hex_value}.  If you fail to call it, a\n+default ASCII-based table will normally be used on ASCII systems.\n+\n+@end deftypefn\n+\n+@deftypefn Extension int hex_p (int @var{c})\n+\n+Evaluates to non-zero if the given character is a valid hex character,\n+or zero if it is not.  Note that the value you pass will be cast to\n+@code{unsigned char} within the macro.\n+\n+@end deftypefn\n+\n+@deftypefn Extension int hex_value (int @var{c})\n+\n+Returns the numeric equivalent of the given character when interpreted\n+as a hexidecimal digit.  The result is undefined if you pass an\n+invalid hex digit.  Note that the value you pass will be cast to\n+@code{unsigned char} within the macro.\n+\n+@end deftypefn\n+\n+@undocumented _hex_array_size\n+@undocumented _hex_bad\n+@undocumented _hex_value\n+\n+*/\n+\n \n /* Are we ASCII? */\n #if '\\n' == 0x0A && ' ' == 0x20 && '0' == 0x30 \\\n@@ -106,6 +135,46 @@ const char _hex_value[_hex_array_size] =\n   _hex_bad, _hex_bad, _hex_bad, _hex_bad,\n   _hex_bad, _hex_bad, _hex_bad, _hex_bad,\n };\n+#define HEX_TABLE_INITIALIZED\n+\n #else\n- #error \"Unsupported host character set\"\n+\n+char _hex_value[_hex_array_size];\n+\n #endif /* not ASCII */\n+\n+void\n+hex_init ()\n+{\n+#ifndef HEX_TABLE_INITIALIZED\n+  int i;\n+\n+  for (i=0; i<_hex_array_size; i++)\n+    {\n+      switch (i)\n+\t{\n+\tcase '0': _hex_value[i] = 0; break;\n+\tcase '1': _hex_value[i] = 1; break;\n+\tcase '2': _hex_value[i] = 2; break;\n+\tcase '3': _hex_value[i] = 3; break;\n+\tcase '4': _hex_value[i] = 4; break;\n+\tcase '5': _hex_value[i] = 5; break;\n+\tcase '6': _hex_value[i] = 6; break;\n+\tcase '7': _hex_value[i] = 7; break;\n+\tcase '8': _hex_value[i] = 8; break;\n+\tcase '9': _hex_value[i] = 9; break;\n+\n+\tcase 'a': case 'A': _hex_value[i] = 10; break;\n+\tcase 'b': case 'B': _hex_value[i] = 11; break;\n+\tcase 'c': case 'C': _hex_value[i] = 12; break;\n+\tcase 'd': case 'D': _hex_value[i] = 13; break;\n+\tcase 'e': case 'E': _hex_value[i] = 14; break;\n+\tcase 'f': case 'F': _hex_value[i] = 15; break;\n+\n+\tdefault:\n+\t  _hex_value[i] = _hex_bad;\n+\t  break;\n+\t}\n+    }\n+#endif\n+}"}]}