{"sha": "e7c33f54117ee31b73113df6f978260a924b5f5b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTdjMzNmNTQxMTdlZTMxYjczMTEzZGY2Zjk3ODI2MGE5MjRiNWY1Yg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-03-31T23:13:36Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-03-31T23:13:36Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r652", "tree": {"sha": "f9fc69502108c29a14a4e31a297831643a0c6835", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9fc69502108c29a14a4e31a297831643a0c6835"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7c33f54117ee31b73113df6f978260a924b5f5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7c33f54117ee31b73113df6f978260a924b5f5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7c33f54117ee31b73113df6f978260a924b5f5b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7c33f54117ee31b73113df6f978260a924b5f5b/comments", "author": null, "committer": null, "parents": [{"sha": "b18135da4e035ff2e10348590781d8bd37d18964", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b18135da4e035ff2e10348590781d8bd37d18964", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b18135da4e035ff2e10348590781d8bd37d18964"}], "stats": {"total": 220, "additions": 185, "deletions": 35}, "files": [{"sha": "a03cff0e9125b3750e01bc850ec3068307d68c26", "filename": "gcc/expr.c", "status": "modified", "additions": 181, "deletions": 32, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7c33f54117ee31b73113df6f978260a924b5f5b/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7c33f54117ee31b73113df6f978260a924b5f5b/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=e7c33f54117ee31b73113df6f978260a924b5f5b", "patch": "@@ -841,10 +841,9 @@ move_by_pieces (to, from, len, align)\n       enum machine_mode mode = VOIDmode, tmode;\n       enum insn_code icode;\n \n-      for (tmode = VOIDmode; (int) tmode < (int) MAX_MACHINE_MODE;\n-\t   tmode = (enum machine_mode) ((int) tmode + 1))\n-\tif (GET_MODE_CLASS (tmode) == MODE_INT\n-\t    && GET_MODE_SIZE (tmode) < max_size)\n+      for (tmode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n+\t   tmode != VOIDmode; tmode = GET_MODE_WIDER_MODE (tmode))\n+\tif (GET_MODE_SIZE (tmode) < max_size)\n \t  mode = tmode;\n \n       if (mode == VOIDmode)\n@@ -884,10 +883,9 @@ move_by_pieces_ninsns (l, align)\n       enum machine_mode mode = VOIDmode, tmode;\n       enum insn_code icode;\n \n-      for (tmode = VOIDmode; (int) tmode < (int) MAX_MACHINE_MODE;\n-\t   tmode = (enum machine_mode) ((int) tmode + 1))\n-\tif (GET_MODE_CLASS (tmode) == MODE_INT\n-\t    && GET_MODE_SIZE (tmode) < max_size)\n+      for (tmode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n+\t   tmode != VOIDmode; tmode = GET_MODE_WIDER_MODE (tmode))\n+\tif (GET_MODE_SIZE (tmode) < max_size)\n \t  mode = tmode;\n \n       if (mode == VOIDmode)\n@@ -2443,7 +2441,11 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode,\n \n    If the field is a bit-field, *PMODE is set to VOIDmode.  Otherwise, it\n    is a mode that can be used to access the field.  In that case, *PBITSIZE\n-   is redundant.  */\n+   is redundant.\n+\n+   If the field describes a variable-sized object, *PMODE is set to\n+   VOIDmode and *PBITSIZE is set to -1.  An access cannot be made in\n+   this case, but the address of the object can be found.  */\n \n tree\n get_inner_reference (exp, pbitsize, pbitpos, pmode, punsignedp, pvolatilep)\n@@ -2479,9 +2481,9 @@ get_inner_reference (exp, pbitsize, pbitpos, pmode, punsignedp, pvolatilep)\n   if (size_tree)\n     {\n       if (TREE_CODE (size_tree) != INTEGER_CST)\n-\tabort ();\n-\n-      *pbitsize = TREE_INT_CST_LOW (size_tree);\n+\tmode = BLKmode, *pbitsize = -1;\n+      else\n+\t*pbitsize = TREE_INT_CST_LOW (size_tree);\n     }\n \n   /* Compute cumulative bit-offset for nested component-refs and array-refs,\n@@ -4395,6 +4397,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t\t\t      ? integer_one_node\n \t\t\t\t\t      : integer_zero_node)),\n \t\t\t       0, 0);\n+\t    do_pending_stack_adjust ();\n \t    emit_label (label);\n \t    return const0_rtx;\n \t  }\n@@ -4527,7 +4530,9 @@ get_pointer_alignment (exp, max_align)\n \tcase ADDR_EXPR:\n \t  /* See what we are pointing at and look at its alignment.  */\n \t  exp = TREE_OPERAND (exp, 0);\n-\t  if (TREE_CODE_CLASS (TREE_CODE (exp)) == 'd')\n+\t  if (TREE_CODE (exp) == FUNCTION_DECL)\n+\t    align = MAX (align, FUNCTION_BOUNDARY);\n+\t  else if (TREE_CODE_CLASS (TREE_CODE (exp)) == 'd')\n \t    align = MAX (align, DECL_ALIGN (exp));\n #ifdef CONSTANT_ALIGNMENT\n \t  else if (TREE_CODE_CLASS (TREE_CODE (exp)) == 'c')\n@@ -4665,6 +4670,7 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n   tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n   tree arglist = TREE_OPERAND (exp, 1);\n   rtx op0;\n+  rtx lab1, lab2, insns;\n   enum machine_mode value_mode = TYPE_MODE (TREE_TYPE (exp));\n \n   switch (DECL_FUNCTION_CODE (fndecl))\n@@ -4687,15 +4693,58 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \n       /* Compute the argument.  */\n       op0 = expand_expr (TREE_VALUE (arglist), subtarget, VOIDmode, 0);\n-      /* Compute sqrt, into TARGET if possible.\n+\n+      /* Make a suitable register to place result in.  */\n+      target = gen_reg_rtx (TYPE_MODE (TREE_TYPE (exp)));\n+\n+      /* Test the argument to make sure it is in the proper domain for\n+\t the sqrt function.  If it is not in the domain, branch to a \n+\t library call.  */\n+      start_sequence();\n+      lab1 = gen_label_rtx();\n+      lab2 = gen_label_rtx();\n+\n+      /* By default check the arguments.  If flag_fast_math is turned on,\n+\t then assume sqrt will always be called with valid arguments.  */\n+      if (! flag_fast_math) \n+\t{\n+\n+\t  /* By checking op >= 1 we are able to catch all of the\n+             IEEE special cases with a single if conditional.  */\n+          emit_cmp_insn (op0, CONST0_RTX (op0->mode), GT, 0, op0->mode, 0, 0);\n+          emit_jump_insn (gen_bgt (lab1));\n+\n+          /* The arguemnt was not in the domain; do this via library call.  */\n+          expand_call (exp, target, 0, 0);\n+\n+          /* Branch around open coded version */\n+          emit_jump_insn (gen_jump (lab2));\n+\t}\n+\n+      emit_label (lab1);\n+      /* Arg is in the domain, compute sqrt, into TARGET. \n \t Set TARGET to wherever the result comes back.  */\n       target = expand_unop (TYPE_MODE (TREE_TYPE (TREE_VALUE (arglist))),\n \t\t\t    sqrt_optab, op0, target, 1);\n+\n+      /* If we were unable to expand via the builtin, stop the\n+\t sequence (without outputting the insns) and break, causing\n+\t a call the the library function.  */\n       if (target == 0)\n-\tbreak;\n-      return target;\n+\t{\n+\t  end_sequence();\n+\t  break;\n+        }\n+      emit_label (lab2);\n \n \n+      /* Output the entire sequence. */\n+      insns = get_insns();\n+      end_sequence();\n+      emit_insns();\n+ \n+      return target;\n+\n     case BUILT_IN_SAVEREGS:\n       /* Don't do __builtin_saveregs more than once in a function.\n \t Save the result of the first call and reuse it.  */\n@@ -4975,11 +5024,76 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \treturn const0_rtx;\n       else\n \t{\n-\t  tree len = c_strlen (TREE_VALUE (arglist));\n+\t  tree src = TREE_VALUE (arglist);\n+\t  tree len = c_strlen (src);\n \n-\t  if (len == 0)\n+\t  int align\n+\t    = get_pointer_alignment (src, BIGGEST_ALIGNMENT) / BITS_PER_UNIT;\n+\n+\t  rtx result, src_rtx, char_rtx;\n+\t  enum machine_mode insn_mode = value_mode, char_mode;\n+\t  enum insn_code icode;\n+\n+\t  /* If the length is known, just return it. */\n+\t  if (len != 0)\n+\t    return expand_expr (len, target, mode, 0);\n+\n+\t  /* If SRC is not a pointer type, don't do this operation inline. */\n+\t  if (align == 0)\n+\t    break;\n+\n+\t  /* Call a function if we can't compute strlen in the right mode. */\n+\n+\t  while (insn_mode != VOIDmode)\n+\t    {\n+\t      icode = strlen_optab->handlers[(int) insn_mode].insn_code;\n+\t      if (icode != CODE_FOR_nothing)\n+\t\tbreak;\n+\n+\t      insn_mode = GET_MODE_WIDER_MODE (insn_mode);\n+\t    }\n+\t  if (insn_mode == VOIDmode)\n \t    break;\n-\t  return expand_expr (len, target, mode, 0);\n+\n+\t  /* Make a place to write the result of the instruction.  */\n+\t  result = target;\n+\t  if (! (result != 0\n+\t\t && GET_CODE (result) == REG\n+\t\t && GET_MODE (result) == insn_mode\n+\t\t && REGNO (result) >= FIRST_PSEUDO_REGISTER))\n+\t    result = gen_reg_rtx (insn_mode);\n+\n+\t  /* Make the operands are acceptable to the predicates.  */\n+\n+\t  if (! (*insn_operand_predicate[icode][0]) (result, insn_mode))\n+\t    result = gen_reg_rtx (insn_mode);\n+\n+\t  src_rtx = memory_address (BLKmode,\n+\t\t\t\t    expand_expr (src, 0, Pmode,\n+\t\t\t\t\t\t EXPAND_NORMAL));\n+\t  if (! (*insn_operand_predicate[icode][1]) (src_rtx, Pmode))\n+\t    src_rtx = copy_to_mode_reg (Pmode, src_rtx);\n+\n+\t  char_rtx = const0_rtx;\n+\t  char_mode = insn_operand_mode[icode][2];\n+\t  if (! (*insn_operand_predicate[icode][2]) (char_rtx, char_mode))\n+\t    char_rtx = copy_to_mode_reg (char_mode, char_rtx);\n+\n+\t  emit_insn (GEN_FCN (icode) (result,\n+\t\t\t\t      gen_rtx (MEM, BLKmode, src_rtx),\n+\t\t\t\t      char_rtx,\n+\t\t\t\t      gen_rtx (CONST_INT, VOIDmode, align)));\n+\n+\t  /* Return the value in the proper mode for this function.  */\n+\t  if (GET_MODE (result) == value_mode)\n+\t    return result;\n+\t  else if (target != 0)\n+\t    {\n+\t      convert_move (target, result, 0);\n+\t      return target;\n+\t    }\n+\t  else\n+\t    return convert_to_mode (value_mode, result, 0);\n \t}\n \n     case BUILT_IN_STRCPY:\n@@ -5452,6 +5566,10 @@ jumpif (exp, label)\n    Either of IF_FALSE_LABEL and IF_TRUE_LABEL may be zero,\n    meaning fall through in that case.\n \n+   do_jump always does any pending stack adjust except when it does not\n+   actually perform a jump.  An example where there is no jump\n+   is when EXP is `(foo (), 0)' and IF_FALSE_LABEL is null.\n+\n    This function is responsible for optimizing cases such as\n    &&, || and comparison operators in EXP.  */\n \n@@ -5574,6 +5692,7 @@ do_jump (exp, if_false_label, if_true_label)\n       expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode, 0);\n       free_temp_slots ();\n       emit_queue ();\n+      do_pending_stack_adjust ();\n       do_jump (TREE_OPERAND (exp, 1), if_false_label, if_true_label);\n       break;\n \n@@ -5592,7 +5711,7 @@ do_jump (exp, if_false_label, if_true_label)\n \t\t\t     &volatilep);\n \n \ttype = type_for_size (bitsize, unsignedp);\n-\tif (type != 0\n+\tif (type != 0 && bitsize >= 0\n \t    && TYPE_PRECISION (type) < TYPE_PRECISION (TREE_TYPE (exp)))\n \t  {\n \t    do_jump (convert (type, exp), if_false_label, if_true_label);\n@@ -5620,6 +5739,8 @@ do_jump (exp, if_false_label, if_true_label)\n \t  do_jump (TREE_OPERAND (exp, 1),\n \t\t   if_false_label ? if_false_label : drop_through_label,\n \t\t   if_true_label ? if_true_label : drop_through_label);\n+\t  /* In case the do_jump just above never jumps.  */\n+\t  do_pending_stack_adjust ();\n \t  emit_label (label1);\n \t  /* Now the ELSE-expression.  */\n \t  do_jump (TREE_OPERAND (exp, 2),\n@@ -5739,7 +5860,13 @@ do_jump (exp, if_false_label, if_true_label)\n   free_temp_slots ();\n \n   if (drop_through_label)\n-    emit_label (drop_through_label);\n+    {\n+      /* If do_jump produces code that might be jumped around,\n+\t do any stack adjusts from that code, before the place\n+\t where control merges in.  */\n+      do_pending_stack_adjust ();\n+      emit_label (drop_through_label);\n+    }\n }\n \f\n /* Given a comparison expression EXP for values too wide to be compared\n@@ -6028,7 +6155,9 @@ compare_from_rtx (op0, op1, code, unsignedp, mode, size, align)\n }\n \f\n /* Generate code to calculate EXP using a store-flag instruction\n-   and return an rtx for the result.\n+   and return an rtx for the result.  EXP is either a comparison\n+   or a TRUTH_NOT_EXPR whose operand is a comparison.\n+\n    If TARGET is nonzero, store the result there if convenient.\n \n    If ONLY_CHEAP is non-zero, only do this if it is likely to be very\n@@ -6053,17 +6182,30 @@ do_store_flag (exp, target, mode, only_cheap)\n      int only_cheap;\n {\n   enum rtx_code code;\n-  tree arg0 = TREE_OPERAND (exp, 0);\n-  tree arg1 = TREE_OPERAND (exp, 1);\n+  tree arg0, arg1, type;\n   tree tem;\n-  tree type = TREE_TYPE (arg0);\n-  enum machine_mode operand_mode = TYPE_MODE (type);\n-  int unsignedp = TREE_UNSIGNED (type);\n+  enum machine_mode operand_mode;\n+  int invert = 0;\n+  int unsignedp;\n   rtx op0, op1;\n   enum insn_code icode;\n   rtx subtarget = target;\n   rtx result, label, pattern, jump_pat;\n \n+  /* If this is a TRUTH_NOT_EXPR, set a flag indicating we must invert the\n+     result at the end.  We can't simply invert the test since it would\n+     have already been inverted if it were valid.  This case occurs for\n+     some floating-point comparisons.  */\n+\n+  if (TREE_CODE (exp) == TRUTH_NOT_EXPR)\n+    invert = 1, exp = TREE_OPERAND (exp, 0);\n+\n+  arg0 = TREE_OPERAND (exp, 0);\n+  arg1 = TREE_OPERAND (exp, 1);\n+  type = TREE_TYPE (arg0);\n+  operand_mode = TYPE_MODE (type);\n+  unsignedp = TREE_UNSIGNED (type);\n+\n   /* We won't bother with BLKmode store-flag operations because it would mean\n      passing a lot of information to emit_store_flag.  */\n   if (operand_mode == BLKmode)\n@@ -6156,7 +6298,7 @@ do_store_flag (exp, target, mode, only_cheap)\n       if (bitnum != TYPE_PRECISION (type) - 1)\n \top0 = expand_and (op0, const1_rtx, target);\n \n-      if (code == EQ)\n+      if ((code == EQ && ! invert) || (code == NE && invert))\n \top0 = expand_binop (mode, xor_optab, op0, const1_rtx, target, 0,\n \t\t\t    OPTAB_LIB_WIDEN);\n \n@@ -6203,24 +6345,31 @@ do_store_flag (exp, target, mode, only_cheap)\n \t\t\t    unsignedp, 1);\n \n   if (result)\n-    return result;\n+    {\n+      if (invert)\n+\tresult = expand_binop (mode, xor_optab, result, const1_rtx,\n+\t\t\t       result, 0, OPTAB_LIB_WIDEN);\n+      return result;\n+    }\n \n   /* If this failed, we have to do this with set/compare/jump/set code.  */\n   if (target == 0 || GET_CODE (target) != REG\n       || reg_mentioned_p (target, op0) || reg_mentioned_p (target, op1))\n     target = gen_reg_rtx (GET_MODE (target));\n \n-  emit_move_insn (target, const1_rtx);\n+  emit_move_insn (target, invert ? const0_rtx : const1_rtx);\n   result = compare_from_rtx (op0, op1, code, unsignedp, operand_mode, 0, 0);\n   if (GET_CODE (result) == CONST_INT)\n-    return result == const0_rtx ? const0_rtx : const1_rtx;\n+    return (((result == const0_rtx && ! invert)\n+\t     || (result != const0_rtx && invert))\n+\t    ? const0_rtx : const1_rtx);\n \n   label = gen_label_rtx ();\n   if (bcc_gen_fctn[(int) code] == 0)\n     abort ();\n \n   emit_jump_insn ((*bcc_gen_fctn[(int) code]) (label));\n-  emit_move_insn (target, const0_rtx);\n+  emit_move_insn (target, invert ? const1_rtx : const0_rtx);\n   emit_label (label);\n \n   return target;"}, {"sha": "469c31dd866ef4e11719614e9caf3751d9c9d4fc", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7c33f54117ee31b73113df6f978260a924b5f5b/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7c33f54117ee31b73113df6f978260a924b5f5b/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=e7c33f54117ee31b73113df6f978260a924b5f5b", "patch": "@@ -769,7 +769,7 @@ check_attr_value (exp, attr)\n \t  for (p = XSTR (exp, 0); *p; p++)\n \t    if (*p > '9' || *p < '0')\n \t      fatal (\"Non-numeric value for numeric `%s' attribute\",\n-\t\t     attr ? \"internal\" : attr->name);\n+\t\t     attr ? attr->name : \"internal\");\n \t  break;\n \t}\n \n@@ -780,7 +780,7 @@ check_attr_value (exp, attr)\n \n       if (av == NULL)\n \tfatal (\"Unknown value `%s' for `%s' attribute\",\n-\t       XSTR (exp, 0), attr ? \"internal\" : attr->name);\n+\t       XSTR (exp, 0), attr ? attr->name : \"internal\");\n \n       return;\n "}, {"sha": "35051be5ff0f9fbc81acd2a1776671446f836f62", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7c33f54117ee31b73113df6f978260a924b5f5b/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7c33f54117ee31b73113df6f978260a924b5f5b/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=e7c33f54117ee31b73113df6f978260a924b5f5b", "patch": "@@ -342,7 +342,8 @@ layout_record (rec)\n \t  else\n \t    {\n \t      if (const_size > 0)\n-\t\tvar_size = size_binop (PLUS_EXPR, var_size, const_size);\n+\t\tvar_size = size_binop (PLUS_EXPR, var_size,\n+\t\t\t\t       size_int (const_size));\n \t      const_size = 0;\n \t      var_size = round_up (var_size, desired_align);\n \t      var_align = MIN (var_align, desired_align);"}]}