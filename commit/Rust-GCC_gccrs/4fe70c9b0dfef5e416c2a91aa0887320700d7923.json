{"sha": "4fe70c9b0dfef5e416c2a91aa0887320700d7923", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGZlNzBjOWIwZGZlZjVlNDE2YzJhOTFhYTA4ODczMjA3MDBkNzkyMw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2005-12-24T12:05:36Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2005-12-24T12:05:36Z"}, "message": "re PR fortran/25029 (Assumed size array can be associated with array pointer without upper bound of last dimension)\n\n2005-12-24  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/25029\n\tPR fortran/21256\n\t* resolve.c (check_assumed_size_reference, resolve_assumed_size_actual):\n\tRemove because of regressions caused by patch.\n\t(resolve_function, resolve_call, resolve_variable): Remove assumed size\n\tchecks because of regressionscaused by patch.\n\n\tPR fortran/25029\n\tPR fortran/21256\n\t* gfortran.dg/initialization_1.f90: Remove tests of intrinsic functions\n\twith incorrect assumed size references.\n\nFrom-SVN: r109039", "tree": {"sha": "ab6f1981e18d133966ac00e865959bb1fdbac142", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab6f1981e18d133966ac00e865959bb1fdbac142"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4fe70c9b0dfef5e416c2a91aa0887320700d7923", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fe70c9b0dfef5e416c2a91aa0887320700d7923", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fe70c9b0dfef5e416c2a91aa0887320700d7923", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fe70c9b0dfef5e416c2a91aa0887320700d7923/comments", "author": null, "committer": null, "parents": [{"sha": "5f5c25d99db0cfb53d9686fbca496f255907b791", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f5c25d99db0cfb53d9686fbca496f255907b791", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f5c25d99db0cfb53d9686fbca496f255907b791"}], "stats": {"total": 142, "additions": 16, "deletions": 126}, "files": [{"sha": "d3dafba1b25edd548a1570a6891ae509798efb50", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fe70c9b0dfef5e416c2a91aa0887320700d7923/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fe70c9b0dfef5e416c2a91aa0887320700d7923/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=4fe70c9b0dfef5e416c2a91aa0887320700d7923", "patch": "@@ -1,3 +1,12 @@\n+2005-12-24  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/25029\n+\tPR fortran/21256\n+\t* resolve.c (check_assumed_size_reference, resolve_assumed_size_actual):\n+\tRemove because of regressions caused by patch.\n+\t(resolve_function, resolve_call, resolve_variable): Remove assumed size\n+\tchecks because of regressionscaused by patch.\n+\n 2005-12-23  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/25029"}, {"sha": "63c9abde22c8956fa81f3b96b4be6e83f528a59f", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 0, "deletions": 122, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fe70c9b0dfef5e416c2a91aa0887320700d7923/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fe70c9b0dfef5e416c2a91aa0887320700d7923/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=4fe70c9b0dfef5e416c2a91aa0887320700d7923", "patch": "@@ -695,68 +695,6 @@ procedure_kind (gfc_symbol * sym)\n   return PTYPE_UNKNOWN;\n }\n \n-/* Check references to assumed size arrays.  The flag need_full_assumed_size\n-   is zero when matching actual arguments.  */\n-\n-static int need_full_assumed_size = 1;\n-\n-static int\n-check_assumed_size_reference (gfc_symbol * sym, gfc_expr * e)\n-{\n-  gfc_ref * ref;\n-  int dim;\n-  int last = 1;\n-\n-  if (!need_full_assumed_size\n-\t|| !(sym->as && sym->as->type == AS_ASSUMED_SIZE))\n-      return 0;\n-\n-  for (ref = e->ref; ref; ref = ref->next)\n-    if (ref->type == REF_ARRAY)\n-      for (dim = 0; dim < ref->u.ar.as->rank; dim++)\n-\tlast = (ref->u.ar.end[dim] == NULL) && (ref->u.ar.type == DIMEN_ELEMENT);\n-\n-  if (last)\n-    {\n-      gfc_error (\"The upper bound in the last dimension must \"\n-\t\t \"appear in the reference to the assumed size \"\n-\t\t \"array '%s' at %L.\", sym->name, &e->where);\n-      return 1;\n-    }\n-  return 0;\n-}\n-\n-\n-/* Look for bad assumed size array references in argument expressions\n-  of elemental and array valued intrinsic procedures.  Since this is\n-  called from procedure resolution functions, it only recurses at\n-  operators.  */\n-static bool\n-resolve_assumed_size_actual (gfc_expr *e)\n-{\n-  if (e == NULL)\n-   return false;\n-\n-  switch (e->expr_type)\n-    {\n-    case EXPR_VARIABLE:\n-      if (e->symtree\n-\t    && check_assumed_size_reference (e->symtree->n.sym, e))\n-\treturn true;\n-      break;\n-\n-    case EXPR_OP:\n-      if (resolve_assumed_size_actual (e->value.op.op1)\n-\t    || resolve_assumed_size_actual (e->value.op.op2))\n-\treturn true;\n-      break;\n-\n-    default:\n-      break;\n-    }\n-  return false;\n-}\n-\n \n /* Resolve an actual argument list.  Most of the time, this is just\n    resolving the expressions in the list.\n@@ -1154,16 +1092,9 @@ resolve_function (gfc_expr * expr)\n   const char *name;\n   try t;\n \n-  /* Switch off assumed size checking and do this again for certain kinds\n-     of procedure, once the procedure itself is resolved.  */\n-  need_full_assumed_size = 0;\n-\n   if (resolve_actual_arglist (expr->value.function.actual) == FAILURE)\n     return FAILURE;\n \n-  /* Resume assumed_size checking. */\n-  need_full_assumed_size = 1;\n-\n /* See if function is already resolved.  */\n \n   if (expr->value.function.name != NULL)\n@@ -1217,33 +1148,6 @@ resolve_function (gfc_expr * expr)\n \t      break;\n \t    }\n \t}\n-\n-      /* Being elemental, the last upper bound of an assumed size array\n-\t argument must be present.  */\n-      for (arg = expr->value.function.actual; arg; arg = arg->next)\n-\t{\n-\t  if (arg->expr != NULL\n-\t\t&& arg->expr->rank > 0\n-\t\t&& resolve_assumed_size_actual (arg->expr))\n-\t    return FAILURE;\n-\t}\n-    }\n-\n-  else if (expr->value.function.actual != NULL\n-      && expr->value.function.isym != NULL\n-      && strcmp (expr->value.function.isym->name, \"lbound\")\n-      && strcmp (expr->value.function.isym->name, \"ubound\")\n-      && strcmp (expr->value.function.isym->name, \"size\"))\n-    {\n-      /* Array instrinsics must also have the last upper bound of an\n-\t asumed size array argument.  */\n-      for (arg = expr->value.function.actual; arg; arg = arg->next)\n-\t{\n-\t  if (arg->expr != NULL\n-\t\t&& arg->expr->rank > 0\n-\t\t&& resolve_assumed_size_actual (arg->expr))\n-\t    return FAILURE;\n-\t}\n     }\n \n   if (!pure_function (expr, &name))\n@@ -1485,17 +1389,9 @@ resolve_call (gfc_code * c)\n {\n   try t;\n \n-  /* Switch off assumed size checking and do this again for certain kinds\n-     of procedure, once the procedure itself is resolved.  */\n-  need_full_assumed_size = 0;\n-\n   if (resolve_actual_arglist (c->ext.actual) == FAILURE)\n     return FAILURE;\n \n-  /* Resume assumed_size checking. */\n-  need_full_assumed_size = 1;\n-\n-\n   t = SUCCESS;\n   if (c->resolved_sym == NULL)\n     switch (procedure_kind (c->symtree->n.sym))\n@@ -1516,21 +1412,6 @@ resolve_call (gfc_code * c)\n \tgfc_internal_error (\"resolve_subroutine(): bad function type\");\n       }\n \n-  if (c->ext.actual != NULL\n-      && c->symtree->n.sym->attr.elemental)\n-    {\n-      gfc_actual_arglist * a;\n-      /* Being elemental, the last upper bound of an assumed size array\n-\t argument must be present.  */\n-      for (a = c->ext.actual; a; a = a->next)\n-\t{\n-\t  if (a->expr != NULL\n-\t\t&& a->expr->rank > 0\n-\t\t&& resolve_assumed_size_actual (a->expr))\n-\t    return FAILURE;\n-\t}\n-    }\n-\n   if (t == SUCCESS)\n     find_noncopying_intrinsics (c->resolved_sym, c->ext.actual);\n   return t;\n@@ -2457,9 +2338,6 @@ resolve_variable (gfc_expr * e)\n       e->ts = sym->ts;\n     }\n \n-  if (check_assumed_size_reference (sym, e))\n-    return FAILURE;\n-\n   return SUCCESS;\n }\n "}, {"sha": "2d786b50020fac78158bd267da265c0f68fcb0a2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fe70c9b0dfef5e416c2a91aa0887320700d7923/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fe70c9b0dfef5e416c2a91aa0887320700d7923/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4fe70c9b0dfef5e416c2a91aa0887320700d7923", "patch": "@@ -1,3 +1,10 @@\n+2005-12-24  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/25029\n+\tPR fortran/21256\n+\t* gfortran.dg/initialization_1.f90: Remove tests of intrinsic functions\n+\twith incorrect assumed size references.\n+\n 2005-12-24  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/23171"}, {"sha": "479348e7e9c4d14d71f88369c17e5738227bcbd4", "filename": "gcc/testsuite/gfortran.dg/initialization_1.f90", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fe70c9b0dfef5e416c2a91aa0887320700d7923/gcc%2Ftestsuite%2Fgfortran.dg%2Finitialization_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fe70c9b0dfef5e416c2a91aa0887320700d7923/gcc%2Ftestsuite%2Fgfortran.dg%2Finitialization_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finitialization_1.f90?ref=4fe70c9b0dfef5e416c2a91aa0887320700d7923", "patch": "@@ -25,10 +25,6 @@ subroutine foo(ch1, x, y)\n ! However, this gives a warning because it is an initialization expression.\n     integer :: l1 = len (ch1)     ! { dg-warning \"assumed character length variable\" }\n \n-! Dependence on upper bound of final dimension of assumed size array knocks these out.\n-    integer :: m1 = size (x, 2)   ! { dg-error \"not a valid dimension index\" }\n-    integer :: m2(2) = shape (x)  ! { dg-error \"assumed size array\" }\n-\n ! These are warnings because they are gfortran extensions.\n     integer :: m3 = size (x, 1)   ! { dg-warning \"Evaluation of nonstandard initialization\" }\n     integer :: m4(2) = shape (z)  ! { dg-warning \"Evaluation of nonstandard initialization\" }"}]}