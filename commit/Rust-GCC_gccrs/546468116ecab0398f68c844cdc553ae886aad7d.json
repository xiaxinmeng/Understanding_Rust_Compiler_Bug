{"sha": "546468116ecab0398f68c844cdc553ae886aad7d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQ2NDY4MTE2ZWNhYjAzOThmNjhjODQ0Y2RjNTUzYWU4ODZhYWQ3ZA==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "2001-03-19T21:57:37Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "2001-03-19T21:57:37Z"}, "message": "Fixes to process to command-line .class files in two passes.  See ChangeLog.\n\nFrom-SVN: r40637", "tree": {"sha": "43b6051fb4c61f97cc997150ff09dfbcd993c639", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43b6051fb4c61f97cc997150ff09dfbcd993c639"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/546468116ecab0398f68c844cdc553ae886aad7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/546468116ecab0398f68c844cdc553ae886aad7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/546468116ecab0398f68c844cdc553ae886aad7d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/546468116ecab0398f68c844cdc553ae886aad7d/comments", "author": null, "committer": null, "parents": [{"sha": "e7ce60a8607279aa6312b7852c3477033596d0c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7ce60a8607279aa6312b7852c3477033596d0c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7ce60a8607279aa6312b7852c3477033596d0c4"}], "stats": {"total": 193, "additions": 122, "deletions": 71}, "files": [{"sha": "77f98ca210d6f9f52d7c2f26e59daf6d91a30651", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/546468116ecab0398f68c844cdc553ae886aad7d/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/546468116ecab0398f68c844cdc553ae886aad7d/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=546468116ecab0398f68c844cdc553ae886aad7d", "patch": "@@ -1,9 +1,38 @@\n+2001-03-19  Per Bothner  <per@bothner.com>\n+\n+\tFixes to process to command-line .class files in two passes.\n+\t* java-tree.h (JAVA_FILE_P, CLASS_FILE_P, ZIP_FILE_P):  New flags.\n+\t(CLASS_FROM_CURRENTLY_COMPILED_SOURCE_P):  Rename to ..\n+\t(CLASS_FROM_CURRENTLY_COMPILED_P):  ... because it is more general now.\n+\t* class.c (is_compiled_class):  Fix for renamed flag.\n+\t* parse.y (maybe_create_class_interface_decl):  Likewise.\n+\t* jcf-parse.c (yyparse):  Also set if compiling .class files.\n+\t* jcf-parse.c (read_class);  Read current_class.\n+\t(jcf_parse):  Make static.\n+\t(load_inner_classes):  New function, with code moved from jcf_parse,\n+\tbecause we need to inner classes after the command-line files are read.\n+\t(yyparse):  Set finput to NULL when it doesn't need to be closed.\n+\tReduce use of main_jcf (basically only for archive) and\n+\tuse finput instead of main_jcf->read_state.\n+\tInline jcf_figure_file_type into yyparse.\n+\tSet JAVA_FILE_P, CLASS_FILE_P, or ZIP_FILE_P on filename list name.\n+\tDefer load_inner_classes and parse_class_file to a second pass,\n+\tafter we've correctly mapped command-line .clas fiels to classes.\n+\t(jcf_figure_file_type):  Removed.\n+\t* jcf.h (JCF_ZIP, JCF_CLASS, JCF_SOURCE):  Removed flags.\n+\t(JCF_ZERO):  Also clear zipd field.\n+\t* zipfile.h:  Conditionalize on JCF_H insread of JCF_ZIP.\n+\n+2001-03-18  Matt Kraai  <kraai@alumni.carnegiemellon.edu>\n+\n+\t* jcf-parse.c (yyparse): Change ch from char * to char.\n+\n 2001-03-19  Per Bothner  <per@bothner.com>\n \n \t* jvspec.c (lang_specific_driver):  Check for .zip and .jar files.\n \tAdd constructed filelist-file at end, following -xjava.  Thus any .o\n \tand library files are not affected by the -xjava.  Also wrap\n-\texplicut @FILE with -xjava and -xnone.\n+\texplicit @FILE with -xjava and -xnone.\n \n 2001-03-19  Andrew Haley  <aph@cambridge.redhat.com>\n "}, {"sha": "4114271e07da97f9e502446127bf6232017a673c", "filename": "gcc/java/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/546468116ecab0398f68c844cdc553ae886aad7d/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/546468116ecab0398f68c844cdc553ae886aad7d/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=546468116ecab0398f68c844cdc553ae886aad7d", "patch": "@@ -1527,7 +1527,7 @@ is_compiled_class (class)\n     return 2;\n \n   seen_in_zip = (TYPE_JCF (class) && JCF_SEEN_IN_ZIP (TYPE_JCF (class)));\n-  if (CLASS_FROM_CURRENTLY_COMPILED_SOURCE_P (class) || seen_in_zip)\n+  if (CLASS_FROM_CURRENTLY_COMPILED_P (class) || seen_in_zip)\n     {\n       /* The class was seen in the current ZIP file and will be\n \t available as a compiled class in the future but may not have"}, {"sha": "8dd98ba487f62aa6dda6a77df6f4d9bb328d6fc0", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/546468116ecab0398f68c844cdc553ae886aad7d/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/546468116ecab0398f68c844cdc553ae886aad7d/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=546468116ecab0398f68c844cdc553ae886aad7d", "patch": "@@ -49,14 +49,17 @@ struct JCF;\n       COMPOUND_ASSIGN_P (in EXPR (binop_*))\n       LOCAL_CLASS_P (in RECORD_TYPE)\n       BLOCK_IS_IMPLICIT (in BLOCK)\n+      JAVA_FILE_P (in TREE_LIST in current_file_list)\n    2: RETURN_MAP_ADJUSTED (in TREE_VEC).\n       QUALIFIED_P (in IDENTIFIER_NODE)\n       PRIMARY_P (in EXPR_WITH_FILE_LOCATION)\n       MODIFY_EXPR_FROM_INITIALIZATION_P (in MODIFY_EXPR)\n       CLASS_METHOD_CHECKED_P (in RECORD_TYPE) \n+      CLASS_FILE_P (in TREE_LIST in current_file_list)\n    3: IS_AN_IMPORT_ON_DEMAND_P (in IDENTIFIER_NODE)\n       RESOLVE_PACKAGE_NAME_P (in EXPR_WITH_FILE_LOCATION)\n       SWITCH_HAS_DEFAULT (in SWITCH_EXPR)\n+      ZIP_FILE_P (in TREE_LIST in current_file_list)\n    4: IS_A_COMMAND_LINE_FILENAME_P (in IDENTIFIER_NODE)\n       RESOLVE_TYPE_NAME_P (in EXPR_WITH_FILE_LOCATION)\n       CALL_USING_SUPER (in CALL_EXPR)\n@@ -947,7 +950,6 @@ extern tree get_constant PARAMS ((struct JCF*, int));\n extern tree get_name_constant PARAMS ((struct JCF*, int));\n extern tree get_class_constant PARAMS ((struct JCF*, int));\n extern tree parse_signature PARAMS ((struct JCF *jcf, int sig_index));\n-extern void jcf_parse PARAMS ((struct JCF*));\n extern tree add_field PARAMS ((tree, tree, tree, int));\n extern tree add_method PARAMS ((tree, int, tree, tree));\n extern tree add_method_1 PARAMS ((tree, int, tree, tree));\n@@ -1138,6 +1140,10 @@ struct rtx_def * java_lang_expand_expr PARAMS ((tree, rtx, enum machine_mode,\n #define METHOD_ABSTRACT(DECL) DECL_LANG_FLAG_5 (DECL)\n #define METHOD_TRANSIENT(DECL) DECL_LANG_FLAG_6 (DECL)\n \n+#define JAVA_FILE_P(NODE) TREE_LANG_FLAG_2 (NODE)\n+#define CLASS_FILE_P(NODE) TREE_LANG_FLAG_3 (NODE)\n+#define ZIP_FILE_P(NODE) TREE_LANG_FLAG_4 (NODE)\n+\n /* Other predicates on method decls  */\n \n #define DECL_CONSTRUCTOR_P(DECL) DECL_LANG_FLAG_7(DECL)\n@@ -1291,8 +1297,8 @@ extern tree *type_map;\n /* True of a RECORD_TYPE of a class/interface type (not array type) */\n #define CLASS_P(TYPE) TYPE_LANG_FLAG_4 (TYPE)\n \n-/* True if class TYPE was defined in a Java source file compiled. */\n-#define CLASS_FROM_CURRENTLY_COMPILED_SOURCE_P(TYPE) \\\n+/* True if class TYPE was requested (on command line) to be compiled.*/\n+#define CLASS_FROM_CURRENTLY_COMPILED_P(TYPE) \\\n   TYPE_LANG_FLAG_5 (TYPE)\n \n /* True if class TYPE is currently being laid out. Helps in detection"}, {"sha": "84f268878cbd273a48007690bd61aeaf70dd3513", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 73, "deletions": 58, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/546468116ecab0398f68c844cdc553ae886aad7d/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/546468116ecab0398f68c844cdc553ae886aad7d/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=546468116ecab0398f68c844cdc553ae886aad7d", "patch": "@@ -81,9 +81,11 @@ static tree parse_roots[3] = { NULL_TREE, NULL_TREE, NULL_TREE };\n /* A list of file names.  */\n #define current_file_list parse_roots[2]\n \n-/* The Java .class file that provides main_class;  the main input file. */\n+/* The Java archive that provides main_class;  the main input file. */\n static struct JCF main_jcf[1];\n \n+static struct ZipFile *localToFile;\n+\n /* Declarations of some functions used here.  */\n static void handle_innerclass_attribute PARAMS ((int count, JCF *));\n static tree give_name_to_class PARAMS ((JCF *jcf, int index));\n@@ -92,11 +94,12 @@ static void process_zip_dir PARAMS ((FILE *));\n static void parse_source_file_1 PARAMS ((tree, FILE *));\n static void parse_source_file_2 PARAMS ((void));\n static void jcf_parse_source PARAMS ((void));\n-static int jcf_figure_file_type PARAMS ((JCF *));\n static void parse_class_file PARAMS ((void));\n static void set_source_filename PARAMS ((JCF *, int));\n static int predefined_filename_p PARAMS ((tree));\n static void ggc_mark_jcf PARAMS ((void**));\n+static void jcf_parse PARAMS ((struct JCF*));\n+static void load_inner_classes PARAMS ((tree));\n \n /* Mark (for garbage collection) all the tree nodes that are\n    referenced from JCF's constant pool table. */\n@@ -576,9 +579,11 @@ read_class (name)\n     java_parser_context_save_global ();\n     java_push_parser_context ();\n     input_filename = current_jcf->filename;\n+    current_class = class;\n     if (JCF_SEEN_IN_ZIP (current_jcf))\n       read_zip_member(current_jcf, current_jcf->zipd, current_jcf->zipd->zipf);\n     jcf_parse (current_jcf);\n+    load_inner_classes (current_class);\n     java_pop_parser_context (0);\n     java_parser_context_restore_global ();\n   }\n@@ -708,11 +713,17 @@ jcf_parse (jcf)\n   if (current_class == object_type_node)\n     layout_class_methods (object_type_node);\n   else\n-    all_class_list = tree_cons (NULL_TREE, \n+    all_class_list = tree_cons (NULL_TREE,\n \t\t\t\tTYPE_NAME (current_class), all_class_list );\n+}\n \n-  /* And if we came across inner classes, load them now. */\n-  for (current = DECL_INNER_CLASS_LIST (TYPE_NAME (current_class)); current;\n+/* If we came across inner classes, load them now. */\n+static void\n+load_inner_classes (cur_class)\n+     tree cur_class;\n+{\n+  tree current;\n+  for (current = DECL_INNER_CLASS_LIST (TYPE_NAME (cur_class)); current;\n        current = TREE_CHAIN (current))\n     {\n       tree name = DECL_NAME (TREE_PURPOSE (current));\n@@ -889,7 +900,7 @@ yyparse ()\n   int filename_count = 0;\n   char *list, *next;\n   tree node;\n-  FILE *finput;\n+  FILE *finput = NULL;\n \n   if (flag_filelist_file)\n     {\n@@ -923,6 +934,7 @@ yyparse ()\n \t  next += count;\n \t}\n       fclose (finput);\n+      finput = NULL;\n     }\n   else\n     list = xstrdup (input_filename);\n@@ -931,7 +943,7 @@ yyparse ()\n     {\n       for (next = list; ; )\n \t{\n-\t  char *ch = *next;\n+\t  char ch = *next;\n \t  if (ch == '\\n' || ch == '\\r' || ch == '\\t' || ch == ' '\n \t      || ch == '&' /* FIXME */)\n \t    {\n@@ -1017,48 +1029,71 @@ yyparse ()\n   current_file_list = nreverse (current_file_list);\n   for (node = current_file_list; node; node = TREE_CHAIN (node))\n     {\n+      unsigned char magic_string[4];\n+      uint32 magic;\n       tree name = TREE_VALUE (node);\n \n       /* Skip already parsed files */\n       if (HAS_BEEN_ALREADY_PARSED_P (name))\n \tcontinue;\n       \n       /* Close previous descriptor, if any */\n-      if (main_jcf->read_state && fclose (main_jcf->read_state))\n-\tfatal_io_error (\"can't close %s\",\n-\t\t\tmain_jcf->filename ? main_jcf->filename : \"<unknown>\");\n+      if (finput && fclose (finput))\n+\tfatal_io_error (\"can't close input file %s\", main_input_filename);\n       \n-      /* Set jcf up and open a new file */\n-      JCF_ZERO (main_jcf);\n-      main_jcf->read_state = fopen (IDENTIFIER_POINTER (name), \"rb\");\n-      if (main_jcf->read_state == NULL)\n+      finput = fopen (IDENTIFIER_POINTER (name), \"rb\");\n+      if (finput == NULL)\n \tfatal_io_error (\"can't open %s\", IDENTIFIER_POINTER (name));\n       \n-      /* Set new input_filename and finput */\n-      finput = main_jcf->read_state;\n #ifdef IO_BUFFER_SIZE\n       setvbuf (finput, (char *) xmalloc (IO_BUFFER_SIZE),\n \t       _IOFBF, IO_BUFFER_SIZE);\n #endif\n       input_filename = IDENTIFIER_POINTER (name);\n-      main_jcf->filbuf = jcf_filbuf_from_stdio;\n \n-      switch (jcf_figure_file_type (current_jcf))\n+      /* Figure what kind of file we're dealing with */\n+      if (fread (magic_string, 1, 4, finput) != 4)\n+\tfatal_io_error (\"Premature end of input file %s\", \n+\t\t\tIDENTIFIER_POINTER (name));\n+      fseek (finput, 0L, SEEK_SET);\n+      magic = GET_u4 (magic_string);\n+      if (magic == 0xcafebabe)\n \t{\n-\tcase JCF_ZIP:\n-\t  parse_zip_file_entries ();\n-\t  break;\n-\tcase JCF_CLASS:\n+\t  CLASS_FILE_P (node) = 1;\n+\t  current_jcf = ALLOC (sizeof (JCF));\n+\t  JCF_ZERO (current_jcf);\n+\t  current_jcf->read_state = finput;\n+\t  current_jcf->filbuf = jcf_filbuf_from_stdio;\n \t  jcf_parse (current_jcf);\n-\t  parse_class_file ();\n-\t  break;\n-\tcase JCF_SOURCE:\n+\t  TYPE_JCF (current_class) = current_jcf;\n+\t  CLASS_FROM_CURRENTLY_COMPILED_P (current_class) = 1;\n+\t  TREE_PURPOSE (node) = current_class;\n+\t}\n+      else if (magic == (JCF_u4)ZIPMAGIC)\n+\t{\n+\t  ZIP_FILE_P (node) = 1;\n+\t  JCF_ZERO (main_jcf);\n+\t  main_jcf->read_state = finput;\n+\t  main_jcf->filbuf = jcf_filbuf_from_stdio;\n+\t  if (open_in_zip (main_jcf, input_filename, NULL, 0) <  0)\n+\t    fatal_error (\"bad zip/jar file %s\", IDENTIFIER_POINTER (name));\n+\t  localToFile = SeenZipFiles;\n+\t  /* Register all the class defined there.  */\n+\t  process_zip_dir (main_jcf->read_state);\n+\t  parse_zip_file_entries ();\n+\t  /*\n+\t  for (each entry)\n+\t    CLASS_FROM_CURRENTLY_COMPILED_P (current_class) = 1;\n+\t  */\n+\t}\n+      else\n+\t{\n+\t  JAVA_FILE_P (node) = 1;\n \t  java_push_parser_context ();\n \t  java_parser_context_save_global ();\n \t  parse_source_file_1 (name, finput);\n \t  java_parser_context_restore_global ();\n \t  java_pop_parser_context (1);\n-\t  break;\n \t}\n     }\n \n@@ -1067,6 +1102,17 @@ yyparse ()\n       input_filename = ctxp->filename;\n       parse_source_file_2 ();\n     }\n+  for (node = current_file_list; node; node = TREE_CHAIN (node))\n+    {\n+      input_filename = IDENTIFIER_POINTER (TREE_VALUE (node));\n+      if (CLASS_FILE_P (node))\n+\t{\n+\t  current_class = TREE_PURPOSE (node);\n+\t  current_jcf = TYPE_JCF (current_class);\n+\t  load_inner_classes (current_class);\n+\t  parse_class_file ();\n+\t}\n+    }\n   input_filename = main_input_filename;\n \n   java_expand_classes ();\n@@ -1075,8 +1121,6 @@ yyparse ()\n   return 0;\n }\n \n-static struct ZipFile *localToFile;\n-\n /* Process all class entries found in the zip file.  */\n static void\n parse_zip_file_entries (void)\n@@ -1101,6 +1145,7 @@ parse_zip_file_entries (void)\n \t{\n \t  read_zip_member(current_jcf, zdir, localToFile);\n \t  jcf_parse (current_jcf);\n+\t  load_inner_classes (current_class);\n \t}\n \n       if (TYPE_SIZE (current_class) != error_mark_node)\n@@ -1175,36 +1220,6 @@ process_zip_dir (FILE *finput)\n     }\n }\n \n-/* Figure what kind of file we're dealing with */\n-static int\n-DEFUN(jcf_figure_file_type, (jcf),\n-      JCF *jcf)\n-{\n-  unsigned char magic_string[4];\n-  uint32 magic;\n-\n-  if (fread (magic_string, 1, 4, jcf->read_state) != 4)\n-    jcf_unexpected_eof (jcf, 4);\n-\n-  fseek (jcf->read_state, 0L, SEEK_SET);\n-  magic = GET_u4 (magic_string);\n-\n-  if (magic == 0xcafebabe)\n-    return JCF_CLASS;\n-\n-  /* FIXME: is it a system file?  */\n-  if (magic ==  (JCF_u4)ZIPMAGIC\n-      && !open_in_zip (jcf, input_filename, NULL, 0))\n-    {\n-      localToFile = SeenZipFiles;\n-      /* Register all the class defined there.  */\n-      process_zip_dir (jcf->read_state);\n-      return JCF_ZIP;\n-    }\n-\n-  return JCF_SOURCE;\n-}\n-\n /* Initialization.  */\n \n void"}, {"sha": "6fb6c254dde9e7e0d8b58adb1fbe18f80181c8cc", "filename": "gcc/java/jcf.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/546468116ecab0398f68c844cdc553ae886aad7d/gcc%2Fjava%2Fjcf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/546468116ecab0398f68c844cdc553ae886aad7d/gcc%2Fjava%2Fjcf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf.h?ref=546468116ecab0398f68c844cdc553ae886aad7d", "patch": "@@ -63,10 +63,6 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #define JCF_word JCF_u4\n #endif\n \n-#define JCF_ZIP    1\n-#define JCF_CLASS  2\n-#define JCF_SOURCE 3\n-\n struct JCF;\n typedef int (*jcf_filbuf_t) PARAMS ((struct JCF*, int needed));\n \n@@ -157,7 +153,7 @@ typedef struct JCF {\n #define JCF_ZERO(JCF)  \\\n   ((JCF)->buffer = (JCF)->buffer_end = (JCF)->read_ptr = (JCF)->read_end = 0,\\\n    (JCF)->read_state = 0, (JCF)->filename = (JCF)->classname = 0, \\\n-   CPOOL_INIT(&(JCF)->cpool), (JCF)->java_source = 0)\n+   CPOOL_INIT(&(JCF)->cpool), (JCF)->java_source = 0, (JCF)->zipd = 0)\n \n /* Given that PTR points to a 2-byte unsigned integer in network\n    (big-endian) byte-order, return that integer. */"}, {"sha": "8d588f0f10a0d38dd67a5ea1eb32a11923afe128", "filename": "gcc/java/parse.y", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/546468116ecab0398f68c844cdc553ae886aad7d/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/546468116ecab0398f68c844cdc553ae886aad7d/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=546468116ecab0398f68c844cdc553ae886aad7d", "patch": "@@ -3635,7 +3635,7 @@ maybe_create_class_interface_decl (decl, raw_name, qualified_name, cl)\n   else\n     DECL_SOURCE_LINE (decl) = EXPR_WFL_LINENO (cl);\n   CLASS_FROM_SOURCE_P (TREE_TYPE (decl)) = 1;\n-  CLASS_FROM_CURRENTLY_COMPILED_SOURCE_P (TREE_TYPE (decl)) =\n+  CLASS_FROM_CURRENTLY_COMPILED_P (TREE_TYPE (decl)) =\n     IS_A_COMMAND_LINE_FILENAME_P (EXPR_WFL_FILENAME_NODE (cl));\n \n   PUSH_CPC (decl, raw_name);\n@@ -5274,7 +5274,12 @@ jdep_resolve_class (dep)\n   if (!decl)\n     complete_class_report_errors (dep);\n   else if (PURE_INNER_CLASS_DECL_P (decl))\n-    check_inner_class_access (decl, JDEP_ENCLOSING (dep), JDEP_WFL (dep));\n+    {\n+      tree inner = TREE_TYPE (decl);\n+      if (! CLASS_LOADED_P (inner))\n+\tsafe_layout_class (inner);\n+      check_inner_class_access (decl, JDEP_ENCLOSING (dep), JDEP_WFL (dep));\n+    }\n   return decl;\n }\n "}, {"sha": "e30fdda3832f486cd776fdf38a4bccb7d2d16b45", "filename": "gcc/java/zipfile.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/546468116ecab0398f68c844cdc553ae886aad7d/gcc%2Fjava%2Fzipfile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/546468116ecab0398f68c844cdc553ae886aad7d/gcc%2Fjava%2Fzipfile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fzipfile.h?ref=546468116ecab0398f68c844cdc553ae886aad7d", "patch": "@@ -60,7 +60,7 @@ extern struct ZipFile *SeenZipFiles;\n \n extern ZipFile * opendir_in_zip PARAMS ((const char *, int));\n extern int read_zip_archive PARAMS ((ZipFile *));\n-#ifdef JCF_ZIP\n+#ifdef JCF_H\n extern int read_zip_member PARAMS ((JCF*, ZipDirectory*, ZipFile *));\n extern int open_in_zip PARAMS ((struct JCF *, const char *,\n \t\t\t       const char *, int));"}]}