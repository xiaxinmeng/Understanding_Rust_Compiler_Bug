{"sha": "df023e0f3e7228cc38677384dc7149368449066c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGYwMjNlMGYzZTcyMjhjYzM4Njc3Mzg0ZGM3MTQ5MzY4NDQ5MDY2Yw==", "commit": {"author": {"name": "James Greenhalgh", "email": "james.greenhalgh@arm.com", "date": "2013-11-08T15:09:50Z"}, "committer": {"name": "James Greenhalgh", "email": "jgreenhalgh@gcc.gnu.org", "date": "2013-11-08T15:09:50Z"}, "message": "[ARM, AArch64] Make aarch-common.c files more robust.\n\ngcc/\n\t* config/arm/aarch-common.c\n\t(search_term): New typedef.\n\t(shift_rtx_costs): New array.\n\t(arm_rtx_shift_left_p): New.\n\t(arm_find_sub_rtx_with_search_term): Likewise.\n\t(arm_find_sub_rtx_with_code): Likewise.\n\t(arm_early_load_addr_dep): Add sanity checking.\n\t(arm_no_early_alu_shift_dep): Likewise.\n\t(arm_no_early_alu_shift_value_dep): Likewise.\n\t(arm_no_early_mul_dep): Likewise.\n\t(arm_no_early_store_addr_dep): Likewise.\n\nFrom-SVN: r204575", "tree": {"sha": "c03514520f518989192968adacadf80fd0f89bbb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c03514520f518989192968adacadf80fd0f89bbb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df023e0f3e7228cc38677384dc7149368449066c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df023e0f3e7228cc38677384dc7149368449066c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df023e0f3e7228cc38677384dc7149368449066c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df023e0f3e7228cc38677384dc7149368449066c/comments", "author": {"login": "jgreenhalgh-arm", "id": 6104025, "node_id": "MDQ6VXNlcjYxMDQwMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6104025?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jgreenhalgh-arm", "html_url": "https://github.com/jgreenhalgh-arm", "followers_url": "https://api.github.com/users/jgreenhalgh-arm/followers", "following_url": "https://api.github.com/users/jgreenhalgh-arm/following{/other_user}", "gists_url": "https://api.github.com/users/jgreenhalgh-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jgreenhalgh-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jgreenhalgh-arm/subscriptions", "organizations_url": "https://api.github.com/users/jgreenhalgh-arm/orgs", "repos_url": "https://api.github.com/users/jgreenhalgh-arm/repos", "events_url": "https://api.github.com/users/jgreenhalgh-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/jgreenhalgh-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "34d1ff06bf3d8df09bbb2c0caf7d4c6bc0de5d2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34d1ff06bf3d8df09bbb2c0caf7d4c6bc0de5d2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34d1ff06bf3d8df09bbb2c0caf7d4c6bc0de5d2a"}], "stats": {"total": 271, "additions": 180, "deletions": 91}, "files": [{"sha": "5a854b0165c70984add6396eca20302142f83665", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df023e0f3e7228cc38677384dc7149368449066c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df023e0f3e7228cc38677384dc7149368449066c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=df023e0f3e7228cc38677384dc7149368449066c", "patch": "@@ -1,3 +1,17 @@\n+2013-11-08  James Greenhalgh  <james.greenhalgh@arm.com>\n+\n+\t* config/arm/aarch-common.c\n+\t(search_term): New typedef.\n+\t(shift_rtx_costs): New array.\n+\t(arm_rtx_shift_left_p): New.\n+\t(arm_find_sub_rtx_with_search_term): Likewise.\n+\t(arm_find_sub_rtx_with_code): Likewise.\n+\t(arm_early_load_addr_dep): Add sanity checking.\n+\t(arm_no_early_alu_shift_dep): Likewise.\n+\t(arm_no_early_alu_shift_value_dep): Likewise.\n+\t(arm_no_early_mul_dep): Likewise.\n+\t(arm_no_early_store_addr_dep): Likewise.\n+\n 2013-11-08  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/59047"}, {"sha": "201e581a4a67fed34330aba8503bae19fcb406df", "filename": "gcc/config/arm/aarch-common.c", "status": "modified", "additions": 166, "deletions": 91, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df023e0f3e7228cc38677384dc7149368449066c/gcc%2Fconfig%2Farm%2Faarch-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df023e0f3e7228cc38677384dc7149368449066c/gcc%2Fconfig%2Farm%2Faarch-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faarch-common.c?ref=df023e0f3e7228cc38677384dc7149368449066c", "patch": "@@ -31,119 +31,196 @@\n #include \"c-family/c-common.h\"\n #include \"rtl.h\"\n \n-/* Return nonzero if the CONSUMER instruction (a load) does need\n-   PRODUCER's value to calculate the address.  */\n+typedef struct\n+{\n+  rtx_code search_code;\n+  rtx search_result;\n+  bool find_any_shift;\n+} search_term;\n+\n+/* Return TRUE if X is either an arithmetic shift left, or\n+   is a multiplication by a power of two.  */\n+static bool\n+arm_rtx_shift_left_p (rtx x)\n+{\n+  enum rtx_code code = GET_CODE (x);\n \n-int\n-arm_early_load_addr_dep (rtx producer, rtx consumer)\n+  if (code == MULT && CONST_INT_P (XEXP (x, 1))\n+      && exact_log2 (INTVAL (XEXP (x, 1))) > 0)\n+    return true;\n+\n+  if (code == ASHIFT)\n+    return true;\n+\n+  return false;\n+}\n+\n+static rtx_code shift_rtx_codes[] =\n+  { ASHIFT, ROTATE, ASHIFTRT, LSHIFTRT,\n+    ROTATERT, ZERO_EXTEND, SIGN_EXTEND };\n+\n+/* Callback function for arm_find_sub_rtx_with_code.\n+   DATA is safe to treat as a SEARCH_TERM, ST.  This will\n+   hold a SEARCH_CODE.  PATTERN is checked to see if it is an\n+   RTX with that code.  If it is, write SEARCH_RESULT in ST\n+   and return 1.  Otherwise, or if we have been passed a NULL_RTX\n+   return 0.  If ST.FIND_ANY_SHIFT then we are interested in\n+   anything which can reasonably be described as a SHIFT RTX.  */\n+static int\n+arm_find_sub_rtx_with_search_term (rtx *pattern, void *data)\n {\n-  rtx value = PATTERN (producer);\n-  rtx addr = PATTERN (consumer);\n-\n-  if (GET_CODE (value) == COND_EXEC)\n-    value = COND_EXEC_CODE (value);\n-  if (GET_CODE (value) == PARALLEL)\n-    value = XVECEXP (value, 0, 0);\n-  value = XEXP (value, 0);\n-  if (GET_CODE (addr) == COND_EXEC)\n-    addr = COND_EXEC_CODE (addr);\n-  if (GET_CODE (addr) == PARALLEL)\n+  search_term *st = (search_term *) data;\n+  rtx_code pattern_code;\n+  int found = 0;\n+\n+  gcc_assert (pattern);\n+  gcc_assert (st);\n+\n+  /* Poorly formed patterns can really ruin our day.  */\n+  if (*pattern == NULL_RTX)\n+    return 0;\n+\n+  pattern_code = GET_CODE (*pattern);\n+\n+  if (st->find_any_shift)\n     {\n-      if (GET_CODE (XVECEXP (addr, 0, 0)) == RETURN)\n-        addr = XVECEXP (addr, 0, 1);\n+      unsigned i = 0;\n+\n+      /* Left shifts might have been canonicalized to a MULT of some\n+\t power of two.  Make sure we catch them.  */\n+      if (arm_rtx_shift_left_p (*pattern))\n+\tfound = 1;\n       else\n-        addr = XVECEXP (addr, 0, 0);\n+\tfor (i = 0; i < ARRAY_SIZE (shift_rtx_codes); i++)\n+\t  if (pattern_code == shift_rtx_codes[i])\n+\t    found = 1;\n+    }\n+\n+  if (pattern_code == st->search_code)\n+    found = 1;\n+\n+  if (found)\n+    st->search_result = *pattern;\n+\n+  return found;\n+}\n+\n+/* Traverse PATTERN looking for a sub-rtx with RTX_CODE CODE.  */\n+static rtx\n+arm_find_sub_rtx_with_code (rtx pattern, rtx_code code, bool find_any_shift)\n+{\n+  search_term st;\n+  int result = 0;\n+\n+  gcc_assert (pattern != NULL_RTX);\n+  st.search_code = code;\n+  st.search_result = NULL_RTX;\n+  st.find_any_shift = find_any_shift;\n+  result = for_each_rtx (&pattern, arm_find_sub_rtx_with_search_term, &st);\n+  if (result)\n+    return st.search_result;\n+  else\n+    return NULL_RTX;\n+}\n+\n+/* Traverse PATTERN looking for any sub-rtx which looks like a shift.  */\n+static rtx\n+arm_find_shift_sub_rtx (rtx pattern)\n+{\n+  return arm_find_sub_rtx_with_code (pattern, ASHIFT, true);\n+}\n+\n+/* PRODUCER and CONSUMER are two potentially dependant RTX.  PRODUCER\n+   (possibly) contains a SET which will provide a result we can access\n+   using the SET_DEST macro.  We will place the RTX which would be\n+   written by PRODUCER in SET_SOURCE.\n+   Similarly, CONSUMER (possibly) contains a SET which has an operand\n+   we can access using SET_SRC.  We place this operand in\n+   SET_DESTINATION.\n+\n+   Return nonzero if we found the SET RTX we expected.  */\n+static int\n+arm_get_set_operands (rtx producer, rtx consumer,\n+\t\t      rtx *set_source, rtx *set_destination)\n+{\n+  rtx set_producer = arm_find_sub_rtx_with_code (producer, SET, false);\n+  rtx set_consumer = arm_find_sub_rtx_with_code (consumer, SET, false);\n+\n+  if (set_producer && set_consumer)\n+    {\n+      *set_source = SET_DEST (set_producer);\n+      *set_destination = SET_SRC (set_consumer);\n+      return 1;\n     }\n-  addr = XEXP (addr, 1);\n+  return 0;\n+}\n+\n+/* Return nonzero if the CONSUMER instruction (a load) does need\n+   PRODUCER's value to calculate the address.  */\n+int\n+arm_early_load_addr_dep (rtx producer, rtx consumer)\n+{\n+  rtx value, addr;\n+\n+  if (!arm_get_set_operands (producer, consumer, &value, &addr))\n+    return 0;\n \n   return reg_overlap_mentioned_p (value, addr);\n }\n \n /* Return nonzero if the CONSUMER instruction (an ALU op) does not\n    have an early register shift value or amount dependency on the\n    result of PRODUCER.  */\n-\n int\n arm_no_early_alu_shift_dep (rtx producer, rtx consumer)\n {\n-  rtx value = PATTERN (producer);\n-  rtx op = PATTERN (consumer);\n+  rtx value, op;\n   rtx early_op;\n \n-  if (GET_CODE (value) == COND_EXEC)\n-    value = COND_EXEC_CODE (value);\n-  if (GET_CODE (value) == PARALLEL)\n-    value = XVECEXP (value, 0, 0);\n-  value = XEXP (value, 0);\n-  if (GET_CODE (op) == COND_EXEC)\n-    op = COND_EXEC_CODE (op);\n-  if (GET_CODE (op) == PARALLEL)\n-    op = XVECEXP (op, 0, 0);\n-  op = XEXP (op, 1);\n-\n-  early_op = XEXP (op, 0);\n-  /* This is either an actual independent shift, or a shift applied to\n-     the first operand of another operation.  We want the whole shift\n-     operation.  */\n-  if (REG_P (early_op))\n-    early_op = op;\n-\n-  return !reg_overlap_mentioned_p (value, early_op);\n+  if (!arm_get_set_operands (producer, consumer, &value, &op))\n+    return 0;\n+\n+  if ((early_op = arm_find_shift_sub_rtx (op)))\n+    {\n+      if (REG_P (early_op))\n+\tearly_op = op;\n+\n+      return !reg_overlap_mentioned_p (value, early_op);\n+    }\n+\n+  return 0;\n }\n \n /* Return nonzero if the CONSUMER instruction (an ALU op) does not\n    have an early register shift value dependency on the result of\n    PRODUCER.  */\n-\n int\n arm_no_early_alu_shift_value_dep (rtx producer, rtx consumer)\n {\n-  rtx value = PATTERN (producer);\n-  rtx op = PATTERN (consumer);\n+  rtx value, op;\n   rtx early_op;\n \n-  if (GET_CODE (value) == COND_EXEC)\n-    value = COND_EXEC_CODE (value);\n-  if (GET_CODE (value) == PARALLEL)\n-    value = XVECEXP (value, 0, 0);\n-  value = XEXP (value, 0);\n-  if (GET_CODE (op) == COND_EXEC)\n-    op = COND_EXEC_CODE (op);\n-  if (GET_CODE (op) == PARALLEL)\n-    op = XVECEXP (op, 0, 0);\n-  op = XEXP (op, 1);\n-\n-  early_op = XEXP (op, 0);\n-\n-  /* This is either an actual independent shift, or a shift applied to\n-     the first operand of another operation.  We want the value being\n-     shifted, in either case.  */\n-  if (!REG_P (early_op))\n-    early_op = XEXP (early_op, 0);\n-\n-  return !reg_overlap_mentioned_p (value, early_op);\n+  if (!arm_get_set_operands (producer, consumer, &value, &op))\n+    return 0;\n+\n+  if ((early_op = arm_find_shift_sub_rtx (op)))\n+    /* We want to check the value being shifted.  */\n+    if (!reg_overlap_mentioned_p (value, XEXP (early_op, 0)))\n+      return 1;\n+\n+  return 0;\n }\n \n /* Return nonzero if the CONSUMER (a mul or mac op) does not\n    have an early register mult dependency on the result of\n    PRODUCER.  */\n-\n int\n arm_no_early_mul_dep (rtx producer, rtx consumer)\n {\n-  rtx value = PATTERN (producer);\n-  rtx op = PATTERN (consumer);\n-\n-  if (GET_CODE (value) == COND_EXEC)\n-    value = COND_EXEC_CODE (value);\n-  if (GET_CODE (value) == PARALLEL)\n-    value = XVECEXP (value, 0, 0);\n-  value = XEXP (value, 0);\n-  if (GET_CODE (op) == COND_EXEC)\n-    op = COND_EXEC_CODE (op);\n-  if (GET_CODE (op) == PARALLEL)\n-    op = XVECEXP (op, 0, 0);\n-  op = XEXP (op, 1);\n+  rtx value, op;\n+\n+  if (!arm_get_set_operands (producer, consumer, &value, &op))\n+    return 0;\n \n   if (GET_CODE (op) == PLUS || GET_CODE (op) == MINUS)\n     {\n@@ -162,19 +239,17 @@ arm_no_early_mul_dep (rtx producer, rtx consumer)\n int\n arm_no_early_store_addr_dep (rtx producer, rtx consumer)\n {\n-  rtx value = PATTERN (producer);\n-  rtx addr = PATTERN (consumer);\n-\n-  if (GET_CODE (value) == COND_EXEC)\n-    value = COND_EXEC_CODE (value);\n-  if (GET_CODE (value) == PARALLEL)\n-    value = XVECEXP (value, 0, 0);\n-  value = XEXP (value, 0);\n-  if (GET_CODE (addr) == COND_EXEC)\n-    addr = COND_EXEC_CODE (addr);\n-  if (GET_CODE (addr) == PARALLEL)\n-    addr = XVECEXP (addr, 0, 0);\n-  addr = XEXP (addr, 0);\n+  rtx value = arm_find_sub_rtx_with_code (producer, SET, false);\n+  rtx addr = arm_find_sub_rtx_with_code (consumer, SET, false);\n+\n+  if (value)\n+    value = SET_DEST (value);\n+\n+  if (addr)\n+    addr = SET_DEST (addr);\n+\n+  if (!value || !addr)\n+    return 0;\n \n   return !reg_overlap_mentioned_p (value, addr);\n }"}]}