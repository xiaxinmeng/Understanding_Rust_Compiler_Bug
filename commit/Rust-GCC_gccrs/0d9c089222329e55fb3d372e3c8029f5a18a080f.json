{"sha": "0d9c089222329e55fb3d372e3c8029f5a18a080f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQ5YzA4OTIyMjMyOWU1NWZiM2QzNzJlM2M4MDI5ZjVhMThhMDgwZg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2009-03-31T18:31:17Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2009-03-31T18:31:17Z"}, "message": "re PR c++/37806 (CV-qualifiers on function typedef's are inconsistently accepted depending on typedef scope)\n\n        PR c++/37806\n        * typeck.c (cp_apply_type_quals_to_decl): Don't apply any quals\n        to a typedef.\n        * tree.c (cp_build_qualified_type_real): Don't apply restrict to a\n        function type.\n        * decl.h (enum decl_context): Add TEMPLATE_TYPE_ARG.\n        * decl.c (groktypename): Add is_template_arg parameter.\n        (grokdeclarator): Allow function cv-quals on a template type arg.\n        * parser.c (cp_parser_new_type_id, cp_parser_type_id): Add\n        is_template_arg argument in calls to groktypename.\n        * cp-tree.h: Adjust prototype.\n        * error.c (dump_type_prefix, dump_type_suffix): Fix plain\n        FUNCTION_TYPE printing.\n\n        PR libstdc++/39310\n        * include/tr1_impl/type_traits (is_function): Add partial\n        specializations with function cv-quals.\n        (__is_function_helper): Remove.\n        (is_member_pointer): Don't define in terms of is_member_*_pointer.\n\nFrom-SVN: r145365", "tree": {"sha": "155b10aa3c254e87c8ef3b1be4137739cf355dfb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/155b10aa3c254e87c8ef3b1be4137739cf355dfb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d9c089222329e55fb3d372e3c8029f5a18a080f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d9c089222329e55fb3d372e3c8029f5a18a080f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d9c089222329e55fb3d372e3c8029f5a18a080f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d9c089222329e55fb3d372e3c8029f5a18a080f/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a3c497526740202a565d78c77d29f2b93c92f1ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3c497526740202a565d78c77d29f2b93c92f1ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3c497526740202a565d78c77d29f2b93c92f1ee"}], "stats": {"total": 155, "additions": 112, "deletions": 43}, "files": [{"sha": "95079f15c31fb75291a10f7b1fd01b25bfff427d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d9c089222329e55fb3d372e3c8029f5a18a080f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d9c089222329e55fb3d372e3c8029f5a18a080f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0d9c089222329e55fb3d372e3c8029f5a18a080f", "patch": "@@ -1,5 +1,19 @@\n 2009-03-31  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/37806\n+\t* typeck.c (cp_apply_type_quals_to_decl): Don't apply any quals\n+\tto a typedef.\n+\t* tree.c (cp_build_qualified_type_real): Don't apply restrict to a \n+\tfunction type.\n+\t* decl.h (enum decl_context): Add TEMPLATE_TYPE_ARG.\n+\t* decl.c (groktypename): Add is_template_arg parameter.\n+\t(grokdeclarator): Allow function cv-quals on a template type arg.\n+\t* parser.c (cp_parser_new_type_id, cp_parser_type_id): Add\n+\tis_template_arg argument in calls to groktypename.\n+\t* cp-tree.h: Adjust prototype.\n+\t* error.c (dump_type_prefix, dump_type_suffix): Fix plain \n+\tFUNCTION_TYPE printing.\n+\t\n \t* mangle.c (write_expression): Mangle dependent name as\n \tsource-name.\n "}, {"sha": "9878d9d29a027c2c7ae9d224b25caeddd07021fa", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d9c089222329e55fb3d372e3c8029f5a18a080f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d9c089222329e55fb3d372e3c8029f5a18a080f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=0d9c089222329e55fb3d372e3c8029f5a18a080f", "patch": "@@ -4328,7 +4328,7 @@ extern tree push_void_library_fn\t\t(tree, tree);\n extern tree push_throw_library_fn\t\t(tree, tree);\n extern tree check_tag_decl\t\t\t(cp_decl_specifier_seq *);\n extern tree shadow_tag\t\t\t\t(cp_decl_specifier_seq *);\n-extern tree groktypename\t\t\t(cp_decl_specifier_seq *, const cp_declarator *);\n+extern tree groktypename\t\t\t(cp_decl_specifier_seq *, const cp_declarator *, bool);\n extern tree start_decl\t\t\t\t(const cp_declarator *, cp_decl_specifier_seq *, int, tree, tree, tree *);\n extern void start_decl_1\t\t\t(tree, bool);\n extern bool check_array_initializer\t\t(tree, tree, tree);"}, {"sha": "6537c50409fc3ce32ec3bc2987fd5b37488924ce", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d9c089222329e55fb3d372e3c8029f5a18a080f/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d9c089222329e55fb3d372e3c8029f5a18a080f/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=0d9c089222329e55fb3d372e3c8029f5a18a080f", "patch": "@@ -3967,13 +3967,16 @@ shadow_tag (cp_decl_specifier_seq *declspecs)\n \n tree\n groktypename (cp_decl_specifier_seq *type_specifiers,\n-\t      const cp_declarator *declarator)\n+\t      const cp_declarator *declarator,\n+\t      bool is_template_arg)\n {\n   tree attrs;\n   tree type;\n+  enum decl_context context\n+    = is_template_arg ? TEMPLATE_TYPE_ARG : TYPENAME;\n   attrs = type_specifiers->attributes;\n   type_specifiers->attributes = NULL_TREE;\n-  type = grokdeclarator (declarator, type_specifiers, TYPENAME, 0, &attrs);\n+  type = grokdeclarator (declarator, type_specifiers, context, 0, &attrs);\n   if (attrs && type != error_mark_node)\n     {\n       if (CLASS_TYPE_P (type))\n@@ -7603,6 +7606,7 @@ grokdeclarator (const cp_declarator *declarator,\n   bool type_was_error_mark_node = false;\n   bool parameter_pack_p = declarator? declarator->parameter_pack_p : false;\n   bool set_no_warning = false;\n+  bool template_type_arg = false;\n \n   signed_p = declspecs->specs[(int)ds_signed];\n   unsigned_p = declspecs->specs[(int)ds_unsigned];\n@@ -7617,6 +7621,8 @@ grokdeclarator (const cp_declarator *declarator,\n     funcdef_flag = true, decl_context = FIELD;\n   else if (decl_context == BITFIELD)\n     bitfield = 1, decl_context = FIELD;\n+  else if (decl_context == TEMPLATE_TYPE_ARG)\n+    template_type_arg = true, decl_context = TYPENAME;\n \n   if (initialized > 1)\n     funcdef_flag = true;\n@@ -8476,6 +8482,12 @@ grokdeclarator (const cp_declarator *declarator,\n \t      memfn_quals = TYPE_UNQUALIFIED;\n \t    }\n \n+\t  if (TREE_CODE (type) == FUNCTION_TYPE\n+\t      && cp_type_quals (type) != TYPE_UNQUALIFIED)\n+\t    error (\"cannot declare %s to qualified function type %qT\",\n+\t\t   declarator->kind == cdk_reference ? \"reference\" : \"pointer\",\n+\t\t   type);\n+\n \t  if (declarator->kind == cdk_reference)\n \t    {\n \t      /* In C++0x, the type we are creating a reference to might be\n@@ -8948,15 +8960,17 @@ grokdeclarator (const cp_declarator *declarator,\n \t}\n       else if (memfn_quals)\n \t{\n-\t  if (ctype == NULL_TREE)\n-\t    {\n-\t      if (TREE_CODE (type) != METHOD_TYPE)\n-\t\terror (\"invalid qualifiers on non-member function type\");\n-\t      else\n-\t\tctype = TYPE_METHOD_BASETYPE (type);\n-\t    }\n+\t  if (ctype == NULL_TREE\n+\t      && TREE_CODE (type) == METHOD_TYPE)\n+\t    ctype = TYPE_METHOD_BASETYPE (type);\n+\n \t  if (ctype)\n \t    type = build_memfn_type (type, ctype, memfn_quals);\n+\t  /* Core issue #547: need to allow this in template type args.  */\n+\t  else if (template_type_arg && TREE_CODE (type) == FUNCTION_TYPE)\n+\t    type = cp_build_qualified_type (type, memfn_quals);\n+\t  else\n+\t    error (\"invalid qualifiers on non-member function type\");\n \t}\n \n       return type;"}, {"sha": "d6e3c83bcbfecebff0055c69d5eda4327477cdaf", "filename": "gcc/cp/decl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d9c089222329e55fb3d372e3c8029f5a18a080f/gcc%2Fcp%2Fdecl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d9c089222329e55fb3d372e3c8029f5a18a080f/gcc%2Fcp%2Fdecl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.h?ref=0d9c089222329e55fb3d372e3c8029f5a18a080f", "patch": "@@ -27,6 +27,7 @@ enum decl_context\n   FIELD,\t\t\t/* Declaration inside struct or union */\n   BITFIELD,\t\t\t/* Likewise but with specified width */\n   TYPENAME,\t\t\t/* Typename (inside cast or sizeof)  */\n+  TEMPLATE_TYPE_ARG,\t\t/* Almost the same as TYPENAME  */\n   MEMFUNCDEF\t\t\t/* Member function definition */\n };\n "}, {"sha": "7d3756e33402e31eda2ad7ca1a99d4d7f3231e84", "filename": "gcc/cp/error.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d9c089222329e55fb3d372e3c8029f5a18a080f/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d9c089222329e55fb3d372e3c8029f5a18a080f/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=0d9c089222329e55fb3d372e3c8029f5a18a080f", "patch": "@@ -550,7 +550,8 @@ dump_type_prefix (tree t, int flags)\n \ttree sub = TREE_TYPE (t);\n \n \tdump_type_prefix (sub, flags);\n-\tif (TREE_CODE (sub) == ARRAY_TYPE)\n+\tif (TREE_CODE (sub) == ARRAY_TYPE\n+\t    || TREE_CODE (sub) == FUNCTION_TYPE)\n \t  {\n \t    pp_cxx_whitespace (cxx_pp);\n \t    pp_cxx_left_paren (cxx_pp);\n@@ -585,12 +586,10 @@ dump_type_prefix (tree t, int flags)\n       pp_base (cxx_pp)->padding = pp_before;\n       break;\n \n-      /* Can only be reached through function pointer -- this would not be\n-\t correct if FUNCTION_DECLs used it.  */\n+      /* This can be reached without a pointer when dealing with\n+\t templates, e.g. std::is_function.  */\n     case FUNCTION_TYPE:\n       dump_type_prefix (TREE_TYPE (t), flags);\n-      pp_maybe_space (cxx_pp);\n-      pp_cxx_left_paren (cxx_pp);\n       break;\n \n     case METHOD_TYPE:\n@@ -654,17 +653,19 @@ dump_type_suffix (tree t, int flags)\n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n     case OFFSET_TYPE:\n-      if (TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE)\n+      if (TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE\n+\t  || TREE_CODE (TREE_TYPE (t)) == FUNCTION_TYPE)\n \tpp_cxx_right_paren (cxx_pp);\n       dump_type_suffix (TREE_TYPE (t), flags);\n       break;\n \n-      /* Can only be reached through function pointer.  */\n     case FUNCTION_TYPE:\n     case METHOD_TYPE:\n       {\n \ttree arg;\n-\tpp_cxx_right_paren (cxx_pp);\n+\tif (TREE_CODE (t) == METHOD_TYPE)\n+\t  /* Can only be reached through a pointer.  */\n+\t  pp_cxx_right_paren (cxx_pp);\n \targ = TYPE_ARG_TYPES (t);\n \tif (TREE_CODE (t) == METHOD_TYPE)\n \t  arg = TREE_CHAIN (arg);\n@@ -677,7 +678,7 @@ dump_type_suffix (tree t, int flags)\n \t  pp_cxx_cv_qualifier_seq\n \t    (cxx_pp, TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (t))));\n \telse\n-\t  pp_cxx_cv_qualifier_seq(cxx_pp, t);\n+\t  pp_cxx_cv_qualifier_seq (cxx_pp, t);\n \tdump_exception_spec (TYPE_RAISES_EXCEPTIONS (t), flags);\n \tdump_type_suffix (TREE_TYPE (t), flags);\n \tbreak;"}, {"sha": "28f47c8f402282f86c54a5726c52f9cfd2235319", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d9c089222329e55fb3d372e3c8029f5a18a080f/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d9c089222329e55fb3d372e3c8029f5a18a080f/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=0d9c089222329e55fb3d372e3c8029f5a18a080f", "patch": "@@ -1732,6 +1732,10 @@ static tree cp_parser_declarator_id\n   (cp_parser *, bool);\n static tree cp_parser_type_id\n   (cp_parser *);\n+static tree cp_parser_template_type_arg\n+  (cp_parser *);\n+static tree cp_parser_type_id_1\n+  (cp_parser *, bool);\n static void cp_parser_type_specifier_seq\n   (cp_parser *, bool, cp_decl_specifier_seq *);\n static tree cp_parser_parameter_declaration_clause\n@@ -5772,7 +5776,7 @@ cp_parser_new_type_id (cp_parser* parser, tree *nelts)\n \tnew_declarator = NULL;\n     }\n \n-  type = groktypename (&type_specifier_seq, new_declarator);\n+  type = groktypename (&type_specifier_seq, new_declarator, false);\n   return type;\n }\n \n@@ -10544,7 +10548,7 @@ cp_parser_template_argument (cp_parser* parser)\n \n      Therefore, we try a type-id first.  */\n   cp_parser_parse_tentatively (parser);\n-  argument = cp_parser_type_id (parser);\n+  argument = cp_parser_template_type_arg (parser);\n   /* If there was no error parsing the type-id but the next token is a\n      '>>', our behavior depends on which dialect of C++ we're\n      parsing. In C++98, we probably found a typo for '> >'. But there\n@@ -10732,7 +10736,7 @@ cp_parser_template_argument (cp_parser* parser)\n      was the only alternative that matched (albeit with a '>' after\n      it). We can assume it's just a typo from the user, and a\n      diagnostic will then be issued.  */\n-  return cp_parser_type_id (parser);\n+  return cp_parser_template_type_arg (parser);\n }\n \n /* Parse an explicit-instantiation.\n@@ -13766,7 +13770,7 @@ cp_parser_declarator_id (cp_parser* parser, bool optional_p)\n    Returns the TYPE specified.  */\n \n static tree\n-cp_parser_type_id (cp_parser* parser)\n+cp_parser_type_id_1 (cp_parser* parser, bool is_template_arg)\n {\n   cp_decl_specifier_seq type_specifier_seq;\n   cp_declarator *abstract_declarator;\n@@ -13795,7 +13799,18 @@ cp_parser_type_id (cp_parser* parser)\n       return error_mark_node;\n     }\n   \n-  return groktypename (&type_specifier_seq, abstract_declarator);\n+  return groktypename (&type_specifier_seq, abstract_declarator,\n+\t\t       is_template_arg);\n+}\n+\n+static tree cp_parser_type_id (cp_parser *parser)\n+{\n+  return cp_parser_type_id_1 (parser, false);\n+}\n+\n+static tree cp_parser_template_type_arg (cp_parser *parser)\n+{\n+  return cp_parser_type_id_1 (parser, true);\n }\n \n /* Parse a type-specifier-seq."}, {"sha": "b4b977ef1a990187cc469031f0e3eede597eb37a", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d9c089222329e55fb3d372e3c8029f5a18a080f/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d9c089222329e55fb3d372e3c8029f5a18a080f/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=0d9c089222329e55fb3d372e3c8029f5a18a080f", "patch": "@@ -852,11 +852,10 @@ cp_build_qualified_type_real (tree type,\n     }\n \n   /* A restrict-qualified type must be a pointer (or reference)\n-     to object or incomplete type, or a function type. */\n+     to object or incomplete type. */\n   if ((type_quals & TYPE_QUAL_RESTRICT)\n       && TREE_CODE (type) != TEMPLATE_TYPE_PARM\n       && TREE_CODE (type) != TYPENAME_TYPE\n-      && TREE_CODE (type) != FUNCTION_TYPE\n       && !POINTER_TYPE_P (type))\n     {\n       bad_quals |= TYPE_QUAL_RESTRICT;"}, {"sha": "fe791f3d707f920648c85ede79db562b4ad23180", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d9c089222329e55fb3d372e3c8029f5a18a080f/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d9c089222329e55fb3d372e3c8029f5a18a080f/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=0d9c089222329e55fb3d372e3c8029f5a18a080f", "patch": "@@ -7239,6 +7239,9 @@ cp_apply_type_quals_to_decl (int type_quals, tree decl)\n   if (type == error_mark_node)\n     return;\n \n+  if (TREE_CODE (decl) == TYPE_DECL)\n+    return;\n+\n   if (TREE_CODE (type) == FUNCTION_TYPE\n       && type_quals != TYPE_UNQUALIFIED)\n     {"}, {"sha": "f42981b52b7a5fa3704138b3dde45a857858547f", "filename": "gcc/testsuite/g++.dg/template/qualttp20.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d9c089222329e55fb3d372e3c8029f5a18a080f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fqualttp20.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d9c089222329e55fb3d372e3c8029f5a18a080f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fqualttp20.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fqualttp20.C?ref=0d9c089222329e55fb3d372e3c8029f5a18a080f", "patch": "@@ -17,7 +17,7 @@ struct AS\n template <typename T> struct B1 : T\n {\n   typedef typename T::L __restrict__ r;// { dg-error \"'__restrict__' qualifiers cannot\" \"\" }\n-  typedef typename T::myT __restrict__ p;// { dg-error \"ignoring '__restrict__'\" }\n+  typedef typename T::myT __restrict__ p;\n \n   // The following are DR 295 dependent\n   typedef typename T::myT volatile *myvolatile;"}, {"sha": "1bcfc0b8045147d3ffa68759aaacd0808d1a2bf9", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d9c089222329e55fb3d372e3c8029f5a18a080f/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d9c089222329e55fb3d372e3c8029f5a18a080f/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=0d9c089222329e55fb3d372e3c8029f5a18a080f", "patch": "@@ -1,3 +1,11 @@\n+2009-03-31  Jason Merrill  <jason@redhat.com>\n+\n+\tPR libstdc++/39310\n+\t* include/tr1_impl/type_traits (is_function): Add partial\n+\tspecializations with function cv-quals.\n+\t(__is_function_helper): Remove.\n+\t(is_member_pointer): Don't define in terms of is_member_*_pointer.\n+\n 2009-03-30  Ian Lance Taylor  <iant@google.com>\n \n \t* include/backward/hashtable.h (clear): Return quickly if the"}, {"sha": "0672c398693cdbca8041c7357098baaf5a0cf269", "filename": "libstdc++-v3/include/tr1_impl/type_traits", "status": "modified", "additions": 30, "deletions": 16, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d9c089222329e55fb3d372e3c8029f5a18a080f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d9c089222329e55fb3d372e3c8029f5a18a080f/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Ftype_traits?ref=0d9c089222329e55fb3d372e3c8029f5a18a080f", "patch": "@@ -224,24 +224,34 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n     : public integral_constant<bool, __is_class(_Tp)>\n     { };\n \n+  /// is_function\n   template<typename>\n-    struct __is_function_helper\n+    struct is_function\n     : public false_type { };\n-\n   template<typename _Res, typename... _ArgTypes>\n-    struct __is_function_helper<_Res(_ArgTypes...)>\n+    struct is_function<_Res(_ArgTypes...)>\n     : public true_type { };\n-\n   template<typename _Res, typename... _ArgTypes>\n-    struct __is_function_helper<_Res(_ArgTypes......)>\n+    struct is_function<_Res(_ArgTypes......)>\n+    : public true_type { };\n+  template<typename _Res, typename... _ArgTypes>\n+    struct is_function<_Res(_ArgTypes...) const>\n+    : public true_type { };\n+  template<typename _Res, typename... _ArgTypes>\n+    struct is_function<_Res(_ArgTypes......) const>\n+    : public true_type { };\n+  template<typename _Res, typename... _ArgTypes>\n+    struct is_function<_Res(_ArgTypes...) volatile>\n+    : public true_type { };\n+  template<typename _Res, typename... _ArgTypes>\n+    struct is_function<_Res(_ArgTypes......) volatile>\n+    : public true_type { };\n+  template<typename _Res, typename... _ArgTypes>\n+    struct is_function<_Res(_ArgTypes...) const volatile>\n+    : public true_type { };\n+  template<typename _Res, typename... _ArgTypes>\n+    struct is_function<_Res(_ArgTypes......) const volatile>\n     : public true_type { };\n-\n-  /// is_function\n-  template<typename _Tp>\n-    struct is_function\n-    : public integral_constant<bool, (__is_function_helper<typename\n-\t\t\t\t      remove_cv<_Tp>::type>::value)>\n-    { };\n \n   // composite type traits [4.5.2].\n   \n@@ -287,10 +297,14 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n \n   /// is_member_pointer\n   template<typename _Tp>\n-    struct is_member_pointer\n-    : public integral_constant<bool,\n-\t\t\t       (is_member_object_pointer<_Tp>::value\n-\t\t\t\t|| is_member_function_pointer<_Tp>::value)>\n+    struct __is_member_pointer_helper\n+    : public false_type { };\n+  _DEFINE_SPEC(2, __is_member_pointer_helper, _Tp _Cp::*, true)\n+\n+  template<typename _Tp>\n+  struct is_member_pointer\n+    : public integral_constant<bool, (__is_member_pointer_helper<\n+\t\t\t\t      typename remove_cv<_Tp>::type>::value)>\n     { };\n \n   // type properties [4.5.3]."}]}