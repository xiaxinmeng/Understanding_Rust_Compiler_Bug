{"sha": "fa49fd0f8a6fdcfd29976f51104c1bd59da0ea22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmE0OWZkMGY4YTZmZGNmZDI5OTc2ZjUxMTA0YzFiZDU5ZGEwZWEyMg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-02-12T23:15:38Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-02-12T23:15:38Z"}, "message": "cselib.c: New file, from simplify-rtx.c.\n\n\t* cselib.c: New file, from simplify-rtx.c.\n\t* simplify-rtx.c: Remove cselib parts.\n\t* Makefile.in: Add cselib.o.\n\nFrom-SVN: r39611", "tree": {"sha": "18ef115a7eb1ad2e9329c859cee11475d9cfddf0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18ef115a7eb1ad2e9329c859cee11475d9cfddf0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa49fd0f8a6fdcfd29976f51104c1bd59da0ea22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa49fd0f8a6fdcfd29976f51104c1bd59da0ea22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa49fd0f8a6fdcfd29976f51104c1bd59da0ea22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa49fd0f8a6fdcfd29976f51104c1bd59da0ea22/comments", "author": null, "committer": null, "parents": [{"sha": "ca5adc63bdd7dc70640d757fedf72d09ba405c5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca5adc63bdd7dc70640d757fedf72d09ba405c5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca5adc63bdd7dc70640d757fedf72d09ba405c5d"}], "stats": {"total": 2742, "additions": 1395, "deletions": 1347}, "files": [{"sha": "026d93e8908f12eb13c25a672c5454779fbc59c5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa49fd0f8a6fdcfd29976f51104c1bd59da0ea22/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa49fd0f8a6fdcfd29976f51104c1bd59da0ea22/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fa49fd0f8a6fdcfd29976f51104c1bd59da0ea22", "patch": "@@ -1,3 +1,9 @@\n+Mon Feb 12 18:13:26 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* cselib.c: New file, from simplify-rtx.c.\n+\t* simplify-rtx.c: Remove cselib parts.\n+\t* Makefile.in: Add cselib.o.\n+\n 2001-02-12  Geoffrey Keating  <geoffk@redhat.com>\n \n \t* config/rs6000/rs6000.c (rs6000_float_const): Remove warning."}, {"sha": "4194ac8a36ca4dfc0b1558f7e8b305c795be1f69", "filename": "gcc/Makefile.in", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa49fd0f8a6fdcfd29976f51104c1bd59da0ea22/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa49fd0f8a6fdcfd29976f51104c1bd59da0ea22/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=fa49fd0f8a6fdcfd29976f51104c1bd59da0ea22", "patch": "@@ -733,19 +733,19 @@ C_OBJS = c-parse.o c-lang.o $(C_AND_OBJC_OBJS)\n \n # Language-independent object files.\n \n-OBJS = diagnostic.o version.o tree.o print-tree.o stor-layout.o fold-const.o  \\\n- function.o stmt.o except.o expr.o calls.o expmed.o explow.o optabs.o real.o  \\\n- builtins.o intl.o varasm.o rtl.o print-rtl.o rtlanal.o emit-rtl.o genrtl.o   \\\n- dbxout.o sdbout.o dwarfout.o dwarf2out.o xcoffout.o bitmap.o alias.o gcse.o  \\\n- integrate.o jump.o cse.o loop.o doloop.o unroll.o flow.o combine.o varray.o  \\\n- regclass.o regmove.o local-alloc.o global.o reload.o reload1.o caller-save.o \\\n- insn-peep.o reorg.o haifa-sched.o final.o recog.o reg-stack.o regrename.o    \\\n- insn-opinit.o insn-recog.o insn-extract.o insn-output.o insn-emit.o lcm.o    \\\n- profile.o insn-attrtab.o $(out_object_file) $(EXTRA_OBJS) convert.o\t      \\\n- mbchar.o splay-tree.o graph.o sbitmap.o resource.o hash.o predict.o\t      \\\n- lists.o ggc-common.o $(GGC) stringpool.o simplify-rtx.o ssa.o bb-reorder.o   \\\n+OBJS = diagnostic.o version.o tree.o print-tree.o stor-layout.o fold-const.o \\\n+ function.o stmt.o except.o expr.o calls.o expmed.o explow.o optabs.o real.o \\\n+ builtins.o intl.o varasm.o rtl.o print-rtl.o rtlanal.o emit-rtl.o genrtl.o  \\\n+ dbxout.o sdbout.o dwarfout.o dwarf2out.o xcoffout.o bitmap.o alias.o gcse.o \\\n+ integrate.o jump.o cse.o loop.o doloop.o unroll.o flow.o combine.o varray.o \\\n+ regclass.o regmove.o local-alloc.o global.o reload.o reload1.o caller-save.o\\\n+ insn-peep.o reorg.o haifa-sched.o final.o recog.o reg-stack.o regrename.o   \\\n+ insn-opinit.o insn-recog.o insn-extract.o insn-output.o insn-emit.o lcm.o   \\\n+ profile.o insn-attrtab.o $(out_object_file) $(EXTRA_OBJS) convert.o\t     \\\n+ mbchar.o splay-tree.o graph.o sbitmap.o resource.o hash.o predict.o\t     \\\n+ lists.o ggc-common.o $(GGC) stringpool.o simplify-rtx.o ssa.o bb-reorder.o  \\\n  sibcall.o conflict.o timevar.o ifcvt.o dominance.o dependence.o dce.o \\\n- sched-vis.o sched-deps.o sched-rgn.o sched-ebb.o hashtab.o\n+ sched-vis.o sched-deps.o sched-rgn.o sched-ebb.o hashtab.o cselib.o\n \n BACKEND = toplev.o libbackend.a\n \n@@ -1412,6 +1412,9 @@ jump.o : jump.c $(CONFIG_H) system.h $(RTL_H) flags.h hard-reg-set.h $(REGS_H) \\\n    toplev.h $(INSN_ATTR_H)\n \n simplify-rtx.o : simplify-rtx.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) \\\n+   hard-reg-set.h flags.h real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h \\\n+   output.h function.h $(GGC_H) $(OBSTACK_H)\n+cselib.o : cselib.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) \\\n    hard-reg-set.h flags.h real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h \\\n    output.h function.h cselib.h $(GGC_H) $(OBSTACK_H)\n cse.o : cse.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) hard-reg-set.h flags.h \\"}, {"sha": "606eb972a5709299f093fd06112dbcdbf6bcd8f7", "filename": "gcc/cselib.c", "status": "added", "additions": 1373, "deletions": 0, "changes": 1373, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa49fd0f8a6fdcfd29976f51104c1bd59da0ea22/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa49fd0f8a6fdcfd29976f51104c1bd59da0ea22/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=fa49fd0f8a6fdcfd29976f51104c1bd59da0ea22", "patch": "@@ -0,0 +1,1373 @@\n+/* Common subexpression elimination library for GNU compiler.\n+   Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n+   1999, 2000, 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include <setjmp.h>\n+\n+#include \"rtl.h\"\n+#include \"tm_p.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"flags.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"recog.h\"\n+#include \"function.h\"\n+#include \"expr.h\"\n+#include \"toplev.h\"\n+#include \"output.h\"\n+#include \"ggc.h\"\n+#include \"obstack.h\"\n+#include \"hashtab.h\"\n+#include \"cselib.h\"\n+\n+static int entry_and_rtx_equal_p\tPARAMS ((const void *, const void *));\n+static unsigned int get_value_hash\tPARAMS ((const void *));\n+static struct elt_list *new_elt_list\tPARAMS ((struct elt_list *,\n+\t\t\t\t\t\t cselib_val *));\n+static struct elt_loc_list *new_elt_loc_list PARAMS ((struct elt_loc_list *,\n+\t\t\t\t\t\t      rtx));\n+static void unchain_one_value\t\tPARAMS ((cselib_val *));\n+static void unchain_one_elt_list\tPARAMS ((struct elt_list **));\n+static void unchain_one_elt_loc_list\tPARAMS ((struct elt_loc_list **));\n+static void clear_table\t\t\tPARAMS ((int));\n+static int discard_useless_locs\t\tPARAMS ((void **, void *));\n+static int discard_useless_values\tPARAMS ((void **, void *));\n+static void remove_useless_values\tPARAMS ((void));\n+static rtx wrap_constant\t\tPARAMS ((enum machine_mode, rtx));\n+static unsigned int hash_rtx\t\tPARAMS ((rtx, enum machine_mode, int));\n+static cselib_val *new_cselib_val\tPARAMS ((unsigned int,\n+\t\t\t\t\t\t enum machine_mode));\n+static void add_mem_for_addr\t\tPARAMS ((cselib_val *, cselib_val *,\n+\t\t\t\t\t\t rtx));\n+static cselib_val *cselib_lookup_mem\tPARAMS ((rtx, int));\n+static rtx cselib_subst_to_values\tPARAMS ((rtx));\n+static void cselib_invalidate_regno\tPARAMS ((unsigned int,\n+\t\t\t\t\t\t enum machine_mode));\n+static int cselib_mem_conflict_p\tPARAMS ((rtx, rtx));\n+static int cselib_invalidate_mem_1\tPARAMS ((void **, void *));\n+static void cselib_invalidate_mem\tPARAMS ((rtx));\n+static void cselib_invalidate_rtx\tPARAMS ((rtx, rtx, void *));\n+static void cselib_record_set\t\tPARAMS ((rtx, cselib_val *,\n+\t\t\t\t\t\t cselib_val *));\n+static void cselib_record_sets\t\tPARAMS ((rtx));\n+\n+/* There are three ways in which cselib can look up an rtx:\n+   - for a REG, the reg_values table (which is indexed by regno) is used\n+   - for a MEM, we recursively look up its address and then follow the\n+     addr_list of that value\n+   - for everything else, we compute a hash value and go through the hash\n+     table.  Since different rtx's can still have the same hash value,\n+     this involves walking the table entries for a given value and comparing\n+     the locations of the entries with the rtx we are looking up.  */\n+\n+/* A table that enables us to look up elts by their value.  */\n+static htab_t hash_table;\n+\n+/* This is a global so we don't have to pass this through every function.\n+   It is used in new_elt_loc_list to set SETTING_INSN.  */\n+static rtx cselib_current_insn;\n+\n+/* Every new unknown value gets a unique number.  */\n+static unsigned int next_unknown_value;\n+\n+/* The number of registers we had when the varrays were last resized.  */\n+static unsigned int cselib_nregs;\n+\n+/* Count values without known locations.  Whenever this grows too big, we\n+   remove these useless values from the table.  */\n+static int n_useless_values;\n+\n+/* Number of useless values before we remove them from the hash table.  */\n+#define MAX_USELESS_VALUES 32\n+\n+/* This table maps from register number to values.  It does not contain\n+   pointers to cselib_val structures, but rather elt_lists.  The purpose is\n+   to be able to refer to the same register in different modes.  */\n+static varray_type reg_values;\n+#define REG_VALUES(I) VARRAY_ELT_LIST (reg_values, (I))\n+\n+/* Here the set of indices I with REG_VALUES(I) != 0 is saved.  This is used\n+   in clear_table() for fast emptying.  */\n+static varray_type used_regs;\n+\n+/* We pass this to cselib_invalidate_mem to invalidate all of\n+   memory for a non-const call instruction.  */\n+static rtx callmem;\n+\n+/* Memory for our structures is allocated from this obstack.  */\n+static struct obstack cselib_obstack;\n+\n+/* Used to quickly free all memory.  */\n+static char *cselib_startobj;\n+\n+/* Caches for unused structures.  */\n+static cselib_val *empty_vals;\n+static struct elt_list *empty_elt_lists;\n+static struct elt_loc_list *empty_elt_loc_lists;\n+\n+/* Set by discard_useless_locs if it deleted the last location of any\n+   value.  */\n+static int values_became_useless;\n+\f\n+\n+/* Allocate a struct elt_list and fill in its two elements with the\n+   arguments.  */\n+\n+static struct elt_list *\n+new_elt_list (next, elt)\n+     struct elt_list *next;\n+     cselib_val *elt;\n+{\n+  struct elt_list *el = empty_elt_lists;\n+\n+  if (el)\n+    empty_elt_lists = el->next;\n+  else\n+    el = (struct elt_list *) obstack_alloc (&cselib_obstack,\n+\t\t\t\t\t    sizeof (struct elt_list));\n+  el->next = next;\n+  el->elt = elt;\n+  return el;\n+}\n+\n+/* Allocate a struct elt_loc_list and fill in its two elements with the\n+   arguments.  */\n+\n+static struct elt_loc_list *\n+new_elt_loc_list (next, loc)\n+     struct elt_loc_list *next;\n+     rtx loc;\n+{\n+  struct elt_loc_list *el = empty_elt_loc_lists;\n+\n+  if (el)\n+    empty_elt_loc_lists = el->next;\n+  else\n+    el = (struct elt_loc_list *) obstack_alloc (&cselib_obstack,\n+\t\t\t\t\t\tsizeof (struct elt_loc_list));\n+  el->next = next;\n+  el->loc = loc;\n+  el->setting_insn = cselib_current_insn;\n+  return el;\n+}\n+\n+/* The elt_list at *PL is no longer needed.  Unchain it and free its\n+   storage.  */\n+\n+static void\n+unchain_one_elt_list (pl)\n+     struct elt_list **pl;\n+{\n+  struct elt_list *l = *pl;\n+\n+  *pl = l->next;\n+  l->next = empty_elt_lists;\n+  empty_elt_lists = l;\n+}\n+\n+/* Likewise for elt_loc_lists.  */\n+\n+static void\n+unchain_one_elt_loc_list (pl)\n+     struct elt_loc_list **pl;\n+{\n+  struct elt_loc_list *l = *pl;\n+\n+  *pl = l->next;\n+  l->next = empty_elt_loc_lists;\n+  empty_elt_loc_lists = l;\n+}\n+\n+/* Likewise for cselib_vals.  This also frees the addr_list associated with\n+   V.  */\n+\n+static void\n+unchain_one_value (v)\n+     cselib_val *v;\n+{\n+  while (v->addr_list)\n+    unchain_one_elt_list (&v->addr_list);\n+\n+  v->u.next_free = empty_vals;\n+  empty_vals = v;\n+}\n+\n+/* Remove all entries from the hash table.  Also used during\n+   initialization.  If CLEAR_ALL isn't set, then only clear the entries\n+   which are known to have been used.  */\n+\n+static void\n+clear_table (clear_all)\n+     int clear_all;\n+{\n+  unsigned int i;\n+\n+  if (clear_all)\n+    for (i = 0; i < cselib_nregs; i++)\n+      REG_VALUES (i) = 0;\n+  else\n+    for (i = 0; i < VARRAY_ACTIVE_SIZE (used_regs); i++)\n+      REG_VALUES (VARRAY_UINT (used_regs, i)) = 0;\n+\n+  VARRAY_POP_ALL (used_regs);\n+\n+  htab_empty (hash_table);\n+  obstack_free (&cselib_obstack, cselib_startobj);\n+\n+  empty_vals = 0;\n+  empty_elt_lists = 0;\n+  empty_elt_loc_lists = 0;\n+  n_useless_values = 0;\n+\n+  next_unknown_value = 0;\n+}\n+\n+/* The equality test for our hash table.  The first argument ENTRY is a table\n+   element (i.e. a cselib_val), while the second arg X is an rtx.  We know\n+   that all callers of htab_find_slot_with_hash will wrap CONST_INTs into a\n+   CONST of an appropriate mode.  */\n+\n+static int\n+entry_and_rtx_equal_p (entry, x_arg)\n+     const void *entry, *x_arg;\n+{\n+  struct elt_loc_list *l;\n+  const cselib_val *v = (const cselib_val *) entry;\n+  rtx x = (rtx) x_arg;\n+  enum machine_mode mode = GET_MODE (x);\n+\n+  if (GET_CODE (x) == CONST_INT\n+      || (mode == VOIDmode && GET_CODE (x) == CONST_DOUBLE))\n+    abort ();\n+  if (mode != GET_MODE (v->u.val_rtx))\n+    return 0;\n+\n+  /* Unwrap X if necessary.  */\n+  if (GET_CODE (x) == CONST\n+      && (GET_CODE (XEXP (x, 0)) == CONST_INT\n+\t  || GET_CODE (XEXP (x, 0)) == CONST_DOUBLE))\n+    x = XEXP (x, 0);\n+  \n+  /* We don't guarantee that distinct rtx's have different hash values,\n+     so we need to do a comparison.  */\n+  for (l = v->locs; l; l = l->next)\n+    if (rtx_equal_for_cselib_p (l->loc, x))\n+      return 1;\n+\n+  return 0;\n+}\n+\n+/* The hash function for our hash table.  The value is always computed with\n+   hash_rtx when adding an element; this function just extracts the hash\n+   value from a cselib_val structure.  */\n+\n+static unsigned int\n+get_value_hash (entry)\n+     const void *entry;\n+{\n+  const cselib_val *v = (const cselib_val *) entry;\n+  return v->value;\n+}\n+\n+/* Return true if X contains a VALUE rtx.  If ONLY_USELESS is set, we\n+   only return true for values which point to a cselib_val whose value\n+   element has been set to zero, which implies the cselib_val will be\n+   removed.  */\n+\n+int\n+references_value_p (x, only_useless)\n+     rtx x;\n+     int only_useless;\n+{\n+  enum rtx_code code = GET_CODE (x);\n+  const char *fmt = GET_RTX_FORMAT (code);\n+  int i, j;\n+\n+  if (GET_CODE (x) == VALUE\n+      && (! only_useless || CSELIB_VAL_PTR (x)->locs == 0))\n+    return 1;\n+\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e' && references_value_p (XEXP (x, i), only_useless))\n+\treturn 1;\n+      else if (fmt[i] == 'E')\n+\tfor (j = 0; j < XVECLEN (x, i); j++)\n+\t  if (references_value_p (XVECEXP (x, i, j), only_useless))\n+\t    return 1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* For all locations found in X, delete locations that reference useless\n+   values (i.e. values without any location).  Called through\n+   htab_traverse.  */\n+\n+static int\n+discard_useless_locs (x, info)\n+     void **x;\n+     void *info ATTRIBUTE_UNUSED;\n+{\n+  cselib_val *v = (cselib_val *)*x;\n+  struct elt_loc_list **p = &v->locs;\n+  int had_locs = v->locs != 0;\n+\n+  while (*p)\n+    {\n+      if (references_value_p ((*p)->loc, 1))\n+\tunchain_one_elt_loc_list (p);\n+      else\n+\tp = &(*p)->next;\n+    }\n+\n+  if (had_locs && v->locs == 0)\n+    {\n+      n_useless_values++;\n+      values_became_useless = 1;\n+    }\n+  return 1;\n+}\n+\n+/* If X is a value with no locations, remove it from the hashtable.  */\n+\n+static int\n+discard_useless_values (x, info)\n+     void **x;\n+     void *info ATTRIBUTE_UNUSED;\n+{\n+  cselib_val *v = (cselib_val *)*x;\n+\n+  if (v->locs == 0)\n+    {\n+      htab_clear_slot (hash_table, x);\n+      unchain_one_value (v);\n+      n_useless_values--;\n+    }\n+\n+  return 1;\n+}\n+\n+/* Clean out useless values (i.e. those which no longer have locations\n+   associated with them) from the hash table.  */\n+\n+static void\n+remove_useless_values ()\n+{\n+  /* First pass: eliminate locations that reference the value.  That in\n+     turn can make more values useless.  */\n+  do\n+    {\n+      values_became_useless = 0;\n+      htab_traverse (hash_table, discard_useless_locs, 0);\n+    }\n+  while (values_became_useless);\n+\n+  /* Second pass: actually remove the values.  */\n+  htab_traverse (hash_table, discard_useless_values, 0);\n+\n+  if (n_useless_values != 0)\n+    abort ();\n+}\n+\n+/* Return nonzero if we can prove that X and Y contain the same value, taking\n+   our gathered information into account.  */\n+\n+int\n+rtx_equal_for_cselib_p (x, y)\n+     rtx x, y;\n+{\n+  enum rtx_code code;\n+  const char *fmt;\n+  int i;\n+  \n+  if (GET_CODE (x) == REG || GET_CODE (x) == MEM)\n+    {\n+      cselib_val *e = cselib_lookup (x, GET_MODE (x), 0);\n+\n+      if (e)\n+\tx = e->u.val_rtx;\n+    }\n+\n+  if (GET_CODE (y) == REG || GET_CODE (y) == MEM)\n+    {\n+      cselib_val *e = cselib_lookup (y, GET_MODE (y), 0);\n+\n+      if (e)\n+\ty = e->u.val_rtx;\n+    }\n+\n+  if (x == y)\n+    return 1;\n+\n+  if (GET_CODE (x) == VALUE && GET_CODE (y) == VALUE)\n+    return CSELIB_VAL_PTR (x) == CSELIB_VAL_PTR (y);\n+\n+  if (GET_CODE (x) == VALUE)\n+    {\n+      cselib_val *e = CSELIB_VAL_PTR (x);\n+      struct elt_loc_list *l;\n+\n+      for (l = e->locs; l; l = l->next)\n+\t{\n+\t  rtx t = l->loc;\n+\n+\t  /* Avoid infinite recursion.  */\n+\t  if (GET_CODE (t) == REG || GET_CODE (t) == MEM)\n+\t    continue;\n+\t  else if (rtx_equal_for_cselib_p (t, y))\n+\t    return 1;\n+\t}\n+      \n+      return 0;\n+    }\n+\n+  if (GET_CODE (y) == VALUE)\n+    {\n+      cselib_val *e = CSELIB_VAL_PTR (y);\n+      struct elt_loc_list *l;\n+\n+      for (l = e->locs; l; l = l->next)\n+\t{\n+\t  rtx t = l->loc;\n+\n+\t  if (GET_CODE (t) == REG || GET_CODE (t) == MEM)\n+\t    continue;\n+\t  else if (rtx_equal_for_cselib_p (x, t))\n+\t    return 1;\n+\t}\n+      \n+      return 0;\n+    }\n+\n+  if (GET_CODE (x) != GET_CODE (y) || GET_MODE (x) != GET_MODE (y))\n+    return 0;\n+\n+  /* This won't be handled correctly by the code below.  */\n+  if (GET_CODE (x) == LABEL_REF)\n+    return XEXP (x, 0) == XEXP (y, 0);\n+  \n+  code = GET_CODE (x);\n+  fmt = GET_RTX_FORMAT (code);\n+\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      int j;\n+\n+      switch (fmt[i])\n+\t{\n+\tcase 'w':\n+\t  if (XWINT (x, i) != XWINT (y, i))\n+\t    return 0;\n+\t  break;\n+\n+\tcase 'n':\n+\tcase 'i':\n+\t  if (XINT (x, i) != XINT (y, i))\n+\t    return 0;\n+\t  break;\n+\n+\tcase 'V':\n+\tcase 'E':\n+\t  /* Two vectors must have the same length.  */\n+\t  if (XVECLEN (x, i) != XVECLEN (y, i))\n+\t    return 0;\n+\n+\t  /* And the corresponding elements must match.  */\n+\t  for (j = 0; j < XVECLEN (x, i); j++)\n+\t    if (! rtx_equal_for_cselib_p (XVECEXP (x, i, j),\n+\t\t\t\t\t  XVECEXP (y, i, j)))\n+\t      return 0;\n+\t  break;\n+\n+\tcase 'e':\n+\t  if (! rtx_equal_for_cselib_p (XEXP (x, i), XEXP (y, i)))\n+\t    return 0;\n+\t  break;\n+\n+\tcase 'S':\n+\tcase 's':\n+\t  if (strcmp (XSTR (x, i), XSTR (y, i)))\n+\t    return 0;\n+\t  break;\n+\n+\tcase 'u':\n+\t  /* These are just backpointers, so they don't matter.  */\n+\t  break;\n+\n+\tcase '0':\n+\tcase 't':\n+\t  break;\n+\n+\t  /* It is believed that rtx's at this level will never\n+\t     contain anything but integers and other rtx's,\n+\t     except for within LABEL_REFs and SYMBOL_REFs.  */\n+\tdefault:\n+\t  abort ();\n+\t}\n+    }\n+  return 1;\n+}\n+\n+/* We need to pass down the mode of constants through the hash table\n+   functions.  For that purpose, wrap them in a CONST of the appropriate\n+   mode.  */\n+static rtx\n+wrap_constant (mode, x)\n+     enum machine_mode mode;\n+     rtx x;\n+{\n+  if (GET_CODE (x) != CONST_INT\n+      && (GET_CODE (x) != CONST_DOUBLE || GET_MODE (x) != VOIDmode))\n+    return x;\n+  if (mode == VOIDmode)\n+    abort ();\n+  return gen_rtx_CONST (mode, x);\n+}\n+\n+/* Hash an rtx.  Return 0 if we couldn't hash the rtx.\n+   For registers and memory locations, we look up their cselib_val structure\n+   and return its VALUE element.\n+   Possible reasons for return 0 are: the object is volatile, or we couldn't\n+   find a register or memory location in the table and CREATE is zero.  If\n+   CREATE is nonzero, table elts are created for regs and mem.\n+   MODE is used in hashing for CONST_INTs only;\n+   otherwise the mode of X is used.  */\n+\n+static unsigned int\n+hash_rtx (x, mode, create)\n+     rtx x;\n+     enum machine_mode mode;\n+     int create;\n+{\n+  cselib_val *e;\n+  int i, j;\n+  enum rtx_code code;\n+  const char *fmt;\n+  unsigned int hash = 0;\n+\n+  /* repeat is used to turn tail-recursion into iteration.  */\n+ repeat:\n+  code = GET_CODE (x);\n+  hash += (unsigned) code + (unsigned) GET_MODE (x);\n+\n+  switch (code)\n+    {\n+    case MEM:\n+    case REG:\n+      e = cselib_lookup (x, GET_MODE (x), create);\n+      if (! e)\n+\treturn 0;\n+\n+      hash += e->value;\n+      return hash;\n+\n+    case CONST_INT:\n+      hash += ((unsigned) CONST_INT << 7) + (unsigned) mode + INTVAL (x);\n+      return hash ? hash : CONST_INT;\n+\n+    case CONST_DOUBLE:\n+      /* This is like the general case, except that it only counts\n+\t the integers representing the constant.  */\n+      hash += (unsigned) code + (unsigned) GET_MODE (x);\n+      if (GET_MODE (x) != VOIDmode)\n+\tfor (i = 2; i < GET_RTX_LENGTH (CONST_DOUBLE); i++)\n+\t  hash += XWINT (x, i);\n+      else\n+\thash += ((unsigned) CONST_DOUBLE_LOW (x)\n+\t\t + (unsigned) CONST_DOUBLE_HIGH (x));\n+      return hash ? hash : CONST_DOUBLE;\n+\n+      /* Assume there is only one rtx object for any given label.  */\n+    case LABEL_REF:\n+      hash\n+\t+= ((unsigned) LABEL_REF << 7) + (unsigned long) XEXP (x, 0);\n+      return hash ? hash : LABEL_REF;\n+\n+    case SYMBOL_REF:\n+      hash\n+\t+= ((unsigned) SYMBOL_REF << 7) + (unsigned long) XSTR (x, 0);\n+      return hash ? hash : SYMBOL_REF;\n+\n+    case PRE_DEC:\n+    case PRE_INC:\n+    case POST_DEC:\n+    case POST_INC:\n+    case POST_MODIFY:\n+    case PRE_MODIFY:\n+    case PC:\n+    case CC0:\n+    case CALL:\n+    case UNSPEC_VOLATILE:\n+      return 0;\n+\n+    case ASM_OPERANDS:\n+      if (MEM_VOLATILE_P (x))\n+\treturn 0;\n+\n+      break;\n+      \n+    default:\n+      break;\n+    }\n+\n+  i = GET_RTX_LENGTH (code) - 1;\n+  fmt = GET_RTX_FORMAT (code);\n+  for (; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\t{\n+\t  rtx tem = XEXP (x, i);\n+\t  unsigned int tem_hash;\n+\n+\t  /* If we are about to do the last recursive call\n+\t     needed at this level, change it into iteration.\n+\t     This function  is called enough to be worth it.  */\n+\t  if (i == 0)\n+\t    {\n+\t      x = tem;\n+\t      goto repeat;\n+\t    }\n+\n+\t  tem_hash = hash_rtx (tem, 0, create);\n+\t  if (tem_hash == 0)\n+\t    return 0;\n+\n+\t  hash += tem_hash;\n+\t}\n+      else if (fmt[i] == 'E')\n+\tfor (j = 0; j < XVECLEN (x, i); j++)\n+\t  {\n+\t    unsigned int tem_hash = hash_rtx (XVECEXP (x, i, j), 0, create);\n+\n+\t    if (tem_hash == 0)\n+\t      return 0;\n+\n+\t    hash += tem_hash;\n+\t  }\n+      else if (fmt[i] == 's')\n+\t{\n+\t  const unsigned char *p = (const unsigned char *) XSTR (x, i);\n+\n+\t  if (p)\n+\t    while (*p)\n+\t      hash += *p++;\n+\t}\n+      else if (fmt[i] == 'i')\n+\thash += XINT (x, i);\n+      else if (fmt[i] == '0' || fmt[i] == 't')\n+\t/* unused */;\n+      else\n+\tabort ();\n+    }\n+\n+  return hash ? hash : 1 + GET_CODE (x);\n+}\n+\n+/* Create a new value structure for VALUE and initialize it.  The mode of the\n+   value is MODE.  */\n+\n+static cselib_val *\n+new_cselib_val (value, mode)\n+     unsigned int value;\n+     enum machine_mode mode;\n+{\n+  cselib_val *e = empty_vals;\n+\n+  if (e)\n+    empty_vals = e->u.next_free;\n+  else\n+    e = (cselib_val *) obstack_alloc (&cselib_obstack, sizeof (cselib_val));\n+\n+  if (value == 0)\n+    abort ();\n+\n+  e->value = value;\n+  e->u.val_rtx = gen_rtx_VALUE (mode);\n+  CSELIB_VAL_PTR (e->u.val_rtx) = e;\n+  e->addr_list = 0;\n+  e->locs = 0;\n+  return e;\n+}\n+\n+/* ADDR_ELT is a value that is used as address.  MEM_ELT is the value that\n+   contains the data at this address.  X is a MEM that represents the\n+   value.  Update the two value structures to represent this situation.  */\n+\n+static void\n+add_mem_for_addr (addr_elt, mem_elt, x)\n+     cselib_val *addr_elt, *mem_elt;\n+     rtx x;\n+{\n+  rtx new;\n+  struct elt_loc_list *l;\n+\n+  /* Avoid duplicates.  */\n+  for (l = mem_elt->locs; l; l = l->next)\n+    if (GET_CODE (l->loc) == MEM\n+\t&& CSELIB_VAL_PTR (XEXP (l->loc, 0)) == addr_elt)\n+      return;\n+\n+  new = gen_rtx_MEM (GET_MODE (x), addr_elt->u.val_rtx);\n+  MEM_COPY_ATTRIBUTES (new, x);\n+\n+  addr_elt->addr_list = new_elt_list (addr_elt->addr_list, mem_elt);\n+  mem_elt->locs = new_elt_loc_list (mem_elt->locs, new);\n+}\n+\n+/* Subroutine of cselib_lookup.  Return a value for X, which is a MEM rtx.\n+   If CREATE, make a new one if we haven't seen it before.  */\n+\n+static cselib_val *\n+cselib_lookup_mem (x, create)\n+     rtx x;\n+     int create;\n+{\n+  enum machine_mode mode = GET_MODE (x);\n+  void **slot;\n+  cselib_val *addr;\n+  cselib_val *mem_elt;\n+  struct elt_list *l;\n+\n+  if (MEM_VOLATILE_P (x) || mode == BLKmode\n+      || (FLOAT_MODE_P (mode) && flag_float_store))\n+    return 0;\n+\n+  /* Look up the value for the address.  */\n+  addr = cselib_lookup (XEXP (x, 0), mode, create);\n+  if (! addr)\n+    return 0;\n+\n+  /* Find a value that describes a value of our mode at that address.  */\n+  for (l = addr->addr_list; l; l = l->next)\n+    if (GET_MODE (l->elt->u.val_rtx) == mode)\n+      return l->elt;\n+\n+  if (! create)\n+    return 0;\n+\n+  mem_elt = new_cselib_val (++next_unknown_value, mode);\n+  add_mem_for_addr (addr, mem_elt, x);\n+  slot = htab_find_slot_with_hash (hash_table, wrap_constant (mode, x),\n+\t\t\t\t   mem_elt->value, INSERT);\n+  *slot = mem_elt;\n+  return mem_elt;\n+}\n+\n+/* Walk rtx X and replace all occurrences of REG and MEM subexpressions\n+   with VALUE expressions.  This way, it becomes independent of changes\n+   to registers and memory.\n+   X isn't actually modified; if modifications are needed, new rtl is\n+   allocated.  However, the return value can share rtl with X.  */\n+\n+static rtx\n+cselib_subst_to_values (x)\n+     rtx x;\n+{\n+  enum rtx_code code = GET_CODE (x);\n+  const char *fmt = GET_RTX_FORMAT (code);\n+  cselib_val *e;\n+  struct elt_list *l;\n+  rtx copy = x;\n+  int i;\n+\n+  switch (code)\n+    {\n+    case REG:\n+      for (l = REG_VALUES (REGNO (x)); l; l = l->next)\n+\tif (GET_MODE (l->elt->u.val_rtx) == GET_MODE (x))\n+\t  return l->elt->u.val_rtx;\n+\n+      abort ();\n+\n+    case MEM:\n+      e = cselib_lookup_mem (x, 0);\n+      if (! e)\n+\tabort ();\n+      return e->u.val_rtx;\n+\n+      /* CONST_DOUBLEs must be special-cased here so that we won't try to\n+\t look up the CONST_DOUBLE_MEM inside.  */\n+    case CONST_DOUBLE:\n+    case CONST_INT:\n+      return x;\n+\n+    default:\n+      break;\n+    }\n+\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\t{\n+\t  rtx t = cselib_subst_to_values (XEXP (x, i));\n+\n+\t  if (t != XEXP (x, i) && x == copy)\n+\t    copy = shallow_copy_rtx (x);\n+\n+\t  XEXP (copy, i) = t;\n+\t}\n+      else if (fmt[i] == 'E')\n+\t{\n+\t  int j, k;\n+\n+\t  for (j = 0; j < XVECLEN (x, i); j++)\n+\t    {\n+\t      rtx t = cselib_subst_to_values (XVECEXP (x, i, j));\n+\n+\t      if (t != XVECEXP (x, i, j) && XVEC (x, i) == XVEC (copy, i))\n+\t\t{\n+\t\t  if (x == copy)\n+\t\t    copy = shallow_copy_rtx (x);\n+\n+\t\t  XVEC (copy, i) = rtvec_alloc (XVECLEN (x, i));\n+\t\t  for (k = 0; k < j; k++)\n+\t\t    XVECEXP (copy, i, k) = XVECEXP (x, i, k);\n+\t\t}\n+\n+\t      XVECEXP (copy, i, j) = t;\n+\t    }\n+\t}\n+    }\n+\n+  return copy;\n+}\n+\n+/* Look up the rtl expression X in our tables and return the value it has.\n+   If CREATE is zero, we return NULL if we don't know the value.  Otherwise,\n+   we create a new one if possible, using mode MODE if X doesn't have a mode\n+   (i.e. because it's a constant).  */\n+\n+cselib_val *\n+cselib_lookup (x, mode, create)\n+     rtx x;\n+     enum machine_mode mode;\n+     int create;\n+{\n+  void **slot;\n+  cselib_val *e;\n+  unsigned int hashval;\n+\n+  if (GET_MODE (x) != VOIDmode)\n+    mode = GET_MODE (x);\n+\n+  if (GET_CODE (x) == VALUE)\n+    return CSELIB_VAL_PTR (x);\n+\n+  if (GET_CODE (x) == REG)\n+    {\n+      struct elt_list *l;\n+      unsigned int i = REGNO (x);\n+\n+      for (l = REG_VALUES (i); l; l = l->next)\n+\tif (mode == GET_MODE (l->elt->u.val_rtx))\n+\t  return l->elt;\n+\n+      if (! create)\n+\treturn 0;\n+\n+      e = new_cselib_val (++next_unknown_value, GET_MODE (x));\n+      e->locs = new_elt_loc_list (e->locs, x);\n+      if (REG_VALUES (i) == 0)\n+        VARRAY_PUSH_UINT (used_regs, i);\n+      REG_VALUES (i) = new_elt_list (REG_VALUES (i), e);\n+      slot = htab_find_slot_with_hash (hash_table, x, e->value, INSERT);\n+      *slot = e;\n+      return e;\n+    }\n+\n+  if (GET_CODE (x) == MEM)\n+    return cselib_lookup_mem (x, create);\n+\n+  hashval = hash_rtx (x, mode, create);\n+  /* Can't even create if hashing is not possible.  */\n+  if (! hashval)\n+    return 0;\n+\n+  slot = htab_find_slot_with_hash (hash_table, wrap_constant (mode, x),\n+\t\t\t\t   hashval, create ? INSERT : NO_INSERT);\n+  if (slot == 0)\n+    return 0;\n+\n+  e = (cselib_val *) *slot;\n+  if (e)\n+    return e;\n+\n+  e = new_cselib_val (hashval, mode);\n+\n+  /* We have to fill the slot before calling cselib_subst_to_values:\n+     the hash table is inconsistent until we do so, and\n+     cselib_subst_to_values will need to do lookups.  */\n+  *slot = (void *) e;\n+  e->locs = new_elt_loc_list (e->locs, cselib_subst_to_values (x));\n+  return e;\n+}\n+\n+/* Invalidate any entries in reg_values that overlap REGNO.  This is called\n+   if REGNO is changing.  MODE is the mode of the assignment to REGNO, which\n+   is used to determine how many hard registers are being changed.  If MODE\n+   is VOIDmode, then only REGNO is being changed; this is used when\n+   invalidating call clobbered registers across a call.  */\n+\n+static void\n+cselib_invalidate_regno (regno, mode)\n+     unsigned int regno;\n+     enum machine_mode mode;\n+{\n+  unsigned int endregno;\n+  unsigned int i;\n+\n+  /* If we see pseudos after reload, something is _wrong_.  */\n+  if (reload_completed && regno >= FIRST_PSEUDO_REGISTER\n+      && reg_renumber[regno] >= 0)\n+    abort ();\n+\n+  /* Determine the range of registers that must be invalidated.  For\n+     pseudos, only REGNO is affected.  For hard regs, we must take MODE\n+     into account, and we must also invalidate lower register numbers\n+     if they contain values that overlap REGNO.  */\n+  endregno = regno + 1;\n+  if (regno < FIRST_PSEUDO_REGISTER && mode != VOIDmode) \n+    endregno = regno + HARD_REGNO_NREGS (regno, mode);\n+\n+  for (i = 0; i < endregno; i++)\n+    {\n+      struct elt_list **l = &REG_VALUES (i);\n+\n+      /* Go through all known values for this reg; if it overlaps the range\n+\t we're invalidating, remove the value.  */\n+      while (*l)\n+\t{\n+\t  cselib_val *v = (*l)->elt;\n+\t  struct elt_loc_list **p;\n+\t  unsigned int this_last = i;\n+\n+\t  if (i < FIRST_PSEUDO_REGISTER)\n+\t    this_last += HARD_REGNO_NREGS (i, GET_MODE (v->u.val_rtx)) - 1;\n+\n+\t  if (this_last < regno)\n+\t    {\n+\t      l = &(*l)->next;\n+\t      continue;\n+\t    }\n+\n+\t  /* We have an overlap.  */\n+\t  unchain_one_elt_list (l);\n+\n+\t  /* Now, we clear the mapping from value to reg.  It must exist, so\n+\t     this code will crash intentionally if it doesn't.  */\n+\t  for (p = &v->locs; ; p = &(*p)->next)\n+\t    {\n+\t      rtx x = (*p)->loc;\n+\n+\t      if (GET_CODE (x) == REG && REGNO (x) == i)\n+\t\t{\n+\t\t  unchain_one_elt_loc_list (p);\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  if (v->locs == 0)\n+\t    n_useless_values++;\n+\t}\n+    }\n+}\n+\n+/* The memory at address MEM_BASE is being changed.\n+   Return whether this change will invalidate VAL.  */\n+\n+static int\n+cselib_mem_conflict_p (mem_base, val)\n+     rtx mem_base;\n+     rtx val;\n+{\n+  enum rtx_code code;\n+  const char *fmt;\n+  int i, j;\n+\n+  code = GET_CODE (val);\n+  switch (code)\n+    {\n+      /* Get rid of a few simple cases quickly. */\n+    case REG:\n+    case PC:\n+    case CC0:\n+    case SCRATCH:\n+    case CONST:\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      return 0;\n+\n+    case MEM:\n+      if (GET_MODE (mem_base) == BLKmode\n+\t  || GET_MODE (val) == BLKmode\n+\t  || anti_dependence (val, mem_base))\n+\treturn 1;\n+\n+      /* The address may contain nested MEMs.  */\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\t{\n+\t  if (cselib_mem_conflict_p (mem_base, XEXP (val, i)))\n+\t    return 1;\n+\t}\n+      else if (fmt[i] == 'E')\n+\tfor (j = 0; j < XVECLEN (val, i); j++)\n+\t  if (cselib_mem_conflict_p (mem_base, XVECEXP (val, i, j)))\n+\t    return 1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* For the value found in SLOT, walk its locations to determine if any overlap\n+   INFO (which is a MEM rtx).  */\n+\n+static int\n+cselib_invalidate_mem_1 (slot, info)\n+     void **slot;\n+     void *info;\n+{\n+  cselib_val *v = (cselib_val *) *slot;\n+  rtx mem_rtx = (rtx) info;\n+  struct elt_loc_list **p = &v->locs;\n+  int had_locs = v->locs != 0;\n+\n+  while (*p)\n+    {\n+      rtx x = (*p)->loc;\n+      cselib_val *addr;\n+      struct elt_list **mem_chain;\n+\n+      /* MEMs may occur in locations only at the top level; below\n+\t that every MEM or REG is substituted by its VALUE.  */\n+      if (GET_CODE (x) != MEM\n+\t  || ! cselib_mem_conflict_p (mem_rtx, x))\n+\t{\n+\t  p = &(*p)->next;\n+\t  continue;\n+\t}\n+\n+      /* This one overlaps.  */\n+      /* We must have a mapping from this MEM's address to the\n+\t value (E).  Remove that, too.  */\n+      addr = cselib_lookup (XEXP (x, 0), VOIDmode, 0);\n+      mem_chain = &addr->addr_list;\n+      for (;;)\n+\t{\n+\t  if ((*mem_chain)->elt == v)\n+\t    {\n+\t      unchain_one_elt_list (mem_chain);\n+\t      break;\n+\t    }\n+\n+\t  mem_chain = &(*mem_chain)->next;\n+\t}\n+\n+      unchain_one_elt_loc_list (p);\n+    }\n+\n+  if (had_locs && v->locs == 0)\n+    n_useless_values++;\n+\n+  return 1;\n+}\n+\n+/* Invalidate any locations in the table which are changed because of a\n+   store to MEM_RTX.  If this is called because of a non-const call\n+   instruction, MEM_RTX is (mem:BLK const0_rtx).  */\n+\n+static void\n+cselib_invalidate_mem (mem_rtx)\n+     rtx mem_rtx;\n+{\n+  htab_traverse (hash_table, cselib_invalidate_mem_1, mem_rtx);\n+}\n+\n+/* Invalidate DEST, which is being assigned to or clobbered.  The second and\n+   the third parameter exist so that this function can be passed to\n+   note_stores; they are ignored.  */\n+\n+static void\n+cselib_invalidate_rtx (dest, ignore, data)\n+     rtx dest;\n+     rtx ignore ATTRIBUTE_UNUSED;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  while (GET_CODE (dest) == STRICT_LOW_PART || GET_CODE (dest) == SIGN_EXTRACT\n+\t || GET_CODE (dest) == ZERO_EXTRACT || GET_CODE (dest) == SUBREG)\n+    dest = XEXP (dest, 0);\n+\n+  if (GET_CODE (dest) == REG)\n+    cselib_invalidate_regno (REGNO (dest), GET_MODE (dest));\n+  else if (GET_CODE (dest) == MEM)\n+    cselib_invalidate_mem (dest);\n+\n+  /* Some machines don't define AUTO_INC_DEC, but they still use push\n+     instructions.  We need to catch that case here in order to\n+     invalidate the stack pointer correctly.  Note that invalidating\n+     the stack pointer is different from invalidating DEST.  */\n+  if (push_operand (dest, GET_MODE (dest)))\n+    cselib_invalidate_rtx (stack_pointer_rtx, NULL_RTX, NULL);\n+}\n+\n+/* Record the result of a SET instruction.  DEST is being set; the source\n+   contains the value described by SRC_ELT.  If DEST is a MEM, DEST_ADDR_ELT\n+   describes its address.  */\n+\n+static void\n+cselib_record_set (dest, src_elt, dest_addr_elt)\n+     rtx dest;\n+     cselib_val *src_elt, *dest_addr_elt;\n+{\n+  int dreg = GET_CODE (dest) == REG ? (int) REGNO (dest) : -1;\n+\n+  if (src_elt == 0 || side_effects_p (dest))\n+    return;\n+\n+  if (dreg >= 0)\n+    {\n+      if (REG_VALUES (dreg) == 0)\n+        VARRAY_PUSH_UINT (used_regs, dreg);\n+\n+      REG_VALUES (dreg) = new_elt_list (REG_VALUES (dreg), src_elt);\n+      if (src_elt->locs == 0)\n+\tn_useless_values--;\n+      src_elt->locs = new_elt_loc_list (src_elt->locs, dest);\n+    }\n+  else if (GET_CODE (dest) == MEM && dest_addr_elt != 0)\n+    {\n+      if (src_elt->locs == 0)\n+\tn_useless_values--;\n+      add_mem_for_addr (dest_addr_elt, src_elt, dest);\n+    }\n+}\n+\n+/* Describe a single set that is part of an insn.  */\n+struct set\n+{\n+  rtx src;\n+  rtx dest;\n+  cselib_val *src_elt;\n+  cselib_val *dest_addr_elt;\n+};\n+\n+/* There is no good way to determine how many elements there can be\n+   in a PARALLEL.  Since it's fairly cheap, use a really large number.  */\n+#define MAX_SETS (FIRST_PSEUDO_REGISTER * 2)\n+\n+/* Record the effects of any sets in INSN.  */\n+static void\n+cselib_record_sets (insn)\n+     rtx insn;\n+{\n+  int n_sets = 0;\n+  int i;\n+  struct set sets[MAX_SETS];\n+  rtx body = PATTERN (insn);\n+\n+  body = PATTERN (insn);\n+  /* Find all sets.  */\n+  if (GET_CODE (body) == SET)\n+    {\n+      sets[0].src = SET_SRC (body);\n+      sets[0].dest = SET_DEST (body);\n+      n_sets = 1;\n+    }\n+  else if (GET_CODE (body) == PARALLEL)\n+    {\n+      /* Look through the PARALLEL and record the values being\n+\t set, if possible.  Also handle any CLOBBERs.  */\n+      for (i = XVECLEN (body, 0) - 1; i >= 0; --i)\n+\t{\n+\t  rtx x = XVECEXP (body, 0, i);\n+\n+\t  if (GET_CODE (x) == SET)\n+\t    {\n+\t      sets[n_sets].src = SET_SRC (x);\n+\t      sets[n_sets].dest = SET_DEST (x);\n+\t      n_sets++;\n+\t    }\n+\t}\n+    }\n+\n+  /* Look up the values that are read.  Do this before invalidating the\n+     locations that are written.  */\n+  for (i = 0; i < n_sets; i++)\n+    {\n+      rtx dest = sets[i].dest;\n+\n+      /* A STRICT_LOW_PART can be ignored; we'll record the equivalence for\n+         the low part after invalidating any knowledge about larger modes.  */\n+      if (GET_CODE (sets[i].dest) == STRICT_LOW_PART)\n+\tsets[i].dest = dest = XEXP (dest, 0);\n+\n+      /* We don't know how to record anything but REG or MEM.  */\n+      if (GET_CODE (dest) == REG || GET_CODE (dest) == MEM)\n+        {\n+\t  sets[i].src_elt = cselib_lookup (sets[i].src, GET_MODE (dest), 1);\n+\t  if (GET_CODE (dest) == MEM)\n+\t    sets[i].dest_addr_elt = cselib_lookup (XEXP (dest, 0), Pmode, 1);\n+\t  else\n+\t    sets[i].dest_addr_elt = 0;\n+\t}\n+    }\n+\n+  /* Invalidate all locations written by this insn.  Note that the elts we\n+     looked up in the previous loop aren't affected, just some of their\n+     locations may go away.  */\n+  note_stores (body, cselib_invalidate_rtx, NULL);\n+\n+  /* Now enter the equivalences in our tables.  */\n+  for (i = 0; i < n_sets; i++)\n+    {\n+      rtx dest = sets[i].dest;\n+      if (GET_CODE (dest) == REG || GET_CODE (dest) == MEM)\n+\tcselib_record_set (dest, sets[i].src_elt, sets[i].dest_addr_elt);\n+    }\n+}\n+\n+/* Record the effects of INSN.  */\n+\n+void\n+cselib_process_insn (insn)\n+     rtx insn;\n+{\n+  int i;\n+  rtx x;\n+\n+  cselib_current_insn = insn;\n+\n+  /* Forget everything at a CODE_LABEL, a volatile asm, or a setjmp.  */\n+  if (GET_CODE (insn) == CODE_LABEL\n+      || (GET_CODE (insn) == NOTE\n+\t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_SETJMP)\n+      || (GET_CODE (insn) == INSN\n+\t  && GET_CODE (PATTERN (insn)) == ASM_OPERANDS\n+\t  && MEM_VOLATILE_P (PATTERN (insn))))\n+    {\n+      clear_table (0);\n+      return;\n+    }\n+\n+  if (! INSN_P (insn))\n+    {\n+      cselib_current_insn = 0;\n+      return;\n+    }\n+\n+  /* If this is a call instruction, forget anything stored in a\n+     call clobbered register, or, if this is not a const call, in\n+     memory.  */\n+  if (GET_CODE (insn) == CALL_INSN)\n+    {\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\tif (call_used_regs[i])\n+\t  cselib_invalidate_regno (i, VOIDmode);\n+\n+      if (! CONST_CALL_P (insn))\n+\tcselib_invalidate_mem (callmem);\n+    }\n+\n+  cselib_record_sets (insn);\n+\n+#ifdef AUTO_INC_DEC\n+  /* Clobber any registers which appear in REG_INC notes.  We\n+     could keep track of the changes to their values, but it is\n+     unlikely to help.  */\n+  for (x = REG_NOTES (insn); x; x = XEXP (x, 1))\n+    if (REG_NOTE_KIND (x) == REG_INC)\n+      cselib_invalidate_rtx (XEXP (x, 0), NULL_RTX, NULL);\n+#endif\n+\n+  /* Look for any CLOBBERs in CALL_INSN_FUNCTION_USAGE, but only\n+     after we have processed the insn.  */\n+  if (GET_CODE (insn) == CALL_INSN)\n+    for (x = CALL_INSN_FUNCTION_USAGE (insn); x; x = XEXP (x, 1))\n+      if (GET_CODE (XEXP (x, 0)) == CLOBBER)\n+\tcselib_invalidate_rtx (XEXP (XEXP (x, 0), 0), NULL_RTX, NULL);\n+\n+  cselib_current_insn = 0;\n+\n+  if (n_useless_values > MAX_USELESS_VALUES)\n+    remove_useless_values ();\n+}\n+\n+/* Make sure our varrays are big enough.  Not called from any cselib routines;\n+   it must be called by the user if it allocated new registers.  */\n+\n+void\n+cselib_update_varray_sizes ()\n+{\n+  unsigned int nregs = max_reg_num ();\n+\n+  if (nregs == cselib_nregs)\n+    return;\n+\n+  cselib_nregs = nregs;\n+  VARRAY_GROW (reg_values, nregs);\n+  VARRAY_GROW (used_regs, nregs);\n+}\n+\n+/* Initialize cselib for one pass.  The caller must also call\n+   init_alias_analysis.  */\n+\n+void\n+cselib_init ()\n+{\n+  /* These are only created once.  */\n+  if (! callmem)\n+    {\n+      gcc_obstack_init (&cselib_obstack);\n+      cselib_startobj = obstack_alloc (&cselib_obstack, 0);\n+\n+      callmem = gen_rtx_MEM (BLKmode, const0_rtx);\n+      ggc_add_rtx_root (&callmem, 1);\n+    }\n+\n+  cselib_nregs = max_reg_num ();\n+  VARRAY_ELT_LIST_INIT (reg_values, cselib_nregs, \"reg_values\");\n+  VARRAY_UINT_INIT (used_regs, cselib_nregs, \"used_regs\");\n+  hash_table = htab_create (31, get_value_hash, entry_and_rtx_equal_p, NULL);\n+  clear_table (1);\n+}\n+\n+/* Called when the current user is done with cselib.  */\n+\n+void\n+cselib_finish ()\n+{\n+  clear_table (0);\n+  VARRAY_FREE (reg_values);\n+  VARRAY_FREE (used_regs);\n+  htab_delete (hash_table);\n+}"}, {"sha": "fa3dfe17f0f4e1cfd0f0936cbbef7219d110340a", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 1, "deletions": 1335, "changes": 1336, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa49fd0f8a6fdcfd29976f51104c1bd59da0ea22/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa49fd0f8a6fdcfd29976f51104c1bd59da0ea22/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=fa49fd0f8a6fdcfd29976f51104c1bd59da0ea22", "patch": "@@ -37,9 +37,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"output.h\"\n #include \"ggc.h\"\n-#include \"obstack.h\"\n-#include \"hashtab.h\"\n-#include \"cselib.h\"\n \n /* Simplification and canonicalization of RTL.  */\n \n@@ -102,94 +99,6 @@ Boston, MA 02111-1307, USA.  */\n static rtx simplify_plus_minus\t\tPARAMS ((enum rtx_code,\n \t\t\t\t\t\t enum machine_mode, rtx, rtx));\n static void check_fold_consts\t\tPARAMS ((PTR));\n-static int entry_and_rtx_equal_p\tPARAMS ((const void *, const void *));\n-static unsigned int get_value_hash\tPARAMS ((const void *));\n-static struct elt_list *new_elt_list\tPARAMS ((struct elt_list *,\n-\t\t\t\t\t\t cselib_val *));\n-static struct elt_loc_list *new_elt_loc_list PARAMS ((struct elt_loc_list *,\n-\t\t\t\t\t\t      rtx));\n-static void unchain_one_value\t\tPARAMS ((cselib_val *));\n-static void unchain_one_elt_list\tPARAMS ((struct elt_list **));\n-static void unchain_one_elt_loc_list\tPARAMS ((struct elt_loc_list **));\n-static void clear_table\t\t\tPARAMS ((int));\n-static int discard_useless_locs\t\tPARAMS ((void **, void *));\n-static int discard_useless_values\tPARAMS ((void **, void *));\n-static void remove_useless_values\tPARAMS ((void));\n-static rtx wrap_constant\t\tPARAMS ((enum machine_mode, rtx));\n-static unsigned int hash_rtx\t\tPARAMS ((rtx, enum machine_mode, int));\n-static cselib_val *new_cselib_val\tPARAMS ((unsigned int,\n-\t\t\t\t\t\t enum machine_mode));\n-static void add_mem_for_addr\t\tPARAMS ((cselib_val *, cselib_val *,\n-\t\t\t\t\t\t rtx));\n-static cselib_val *cselib_lookup_mem\tPARAMS ((rtx, int));\n-static rtx cselib_subst_to_values\tPARAMS ((rtx));\n-static void cselib_invalidate_regno\tPARAMS ((unsigned int,\n-\t\t\t\t\t\t enum machine_mode));\n-static int cselib_mem_conflict_p\tPARAMS ((rtx, rtx));\n-static int cselib_invalidate_mem_1\tPARAMS ((void **, void *));\n-static void cselib_invalidate_mem\tPARAMS ((rtx));\n-static void cselib_invalidate_rtx\tPARAMS ((rtx, rtx, void *));\n-static void cselib_record_set\t\tPARAMS ((rtx, cselib_val *,\n-\t\t\t\t\t\t cselib_val *));\n-static void cselib_record_sets\t\tPARAMS ((rtx));\n-\n-/* There are three ways in which cselib can look up an rtx:\n-   - for a REG, the reg_values table (which is indexed by regno) is used\n-   - for a MEM, we recursively look up its address and then follow the\n-     addr_list of that value\n-   - for everything else, we compute a hash value and go through the hash\n-     table.  Since different rtx's can still have the same hash value,\n-     this involves walking the table entries for a given value and comparing\n-     the locations of the entries with the rtx we are looking up.  */\n-\n-/* A table that enables us to look up elts by their value.  */\n-static htab_t hash_table;\n-\n-/* This is a global so we don't have to pass this through every function.\n-   It is used in new_elt_loc_list to set SETTING_INSN.  */\n-static rtx cselib_current_insn;\n-\n-/* Every new unknown value gets a unique number.  */\n-static unsigned int next_unknown_value;\n-\n-/* The number of registers we had when the varrays were last resized.  */\n-static unsigned int cselib_nregs;\n-\n-/* Count values without known locations.  Whenever this grows too big, we\n-   remove these useless values from the table.  */\n-static int n_useless_values;\n-\n-/* Number of useless values before we remove them from the hash table.  */\n-#define MAX_USELESS_VALUES 32\n-\n-/* This table maps from register number to values.  It does not contain\n-   pointers to cselib_val structures, but rather elt_lists.  The purpose is\n-   to be able to refer to the same register in different modes.  */\n-static varray_type reg_values;\n-#define REG_VALUES(I) VARRAY_ELT_LIST (reg_values, (I))\n-\n-/* Here the set of indices I with REG_VALUES(I) != 0 is saved.  This is used\n-   in clear_table() for fast emptying.  */\n-static varray_type used_regs;\n-\n-/* We pass this to cselib_invalidate_mem to invalidate all of\n-   memory for a non-const call instruction.  */\n-static rtx callmem;\n-\n-/* Memory for our structures is allocated from this obstack.  */\n-static struct obstack cselib_obstack;\n-\n-/* Used to quickly free all memory.  */\n-static char *cselib_startobj;\n-\n-/* Caches for unused structures.  */\n-static cselib_val *empty_vals;\n-static struct elt_list *empty_elt_lists;\n-static struct elt_loc_list *empty_elt_loc_lists;\n-\n-/* Set by discard_useless_locs if it deleted the last location of any\n-   value.  */\n-static int values_became_useless;\n \f\n /* Make a binary operation by properly ordering the operands and \n    seeing if the expression folds.  */\n@@ -1798,7 +1707,7 @@ simplify_relational_operation (code, mode, op0, op1)\n       args.op1 = op1;\n       \n       \n-      if (!do_float_handler(check_fold_consts, (PTR) &args))\n+      if (!do_float_handler (check_fold_consts, (PTR) &args))\n \targs.unordered = 1;\n \n       if (args.unordered)\n@@ -2184,1246 +2093,3 @@ simplify_rtx (x)\n       return NULL;\n     }\n }\n-\f\n-\n-/* Allocate a struct elt_list and fill in its two elements with the\n-   arguments.  */\n-\n-static struct elt_list *\n-new_elt_list (next, elt)\n-     struct elt_list *next;\n-     cselib_val *elt;\n-{\n-  struct elt_list *el = empty_elt_lists;\n-\n-  if (el)\n-    empty_elt_lists = el->next;\n-  else\n-    el = (struct elt_list *) obstack_alloc (&cselib_obstack,\n-\t\t\t\t\t    sizeof (struct elt_list));\n-  el->next = next;\n-  el->elt = elt;\n-  return el;\n-}\n-\n-/* Allocate a struct elt_loc_list and fill in its two elements with the\n-   arguments.  */\n-\n-static struct elt_loc_list *\n-new_elt_loc_list (next, loc)\n-     struct elt_loc_list *next;\n-     rtx loc;\n-{\n-  struct elt_loc_list *el = empty_elt_loc_lists;\n-\n-  if (el)\n-    empty_elt_loc_lists = el->next;\n-  else\n-    el = (struct elt_loc_list *) obstack_alloc (&cselib_obstack,\n-\t\t\t\t\t\tsizeof (struct elt_loc_list));\n-  el->next = next;\n-  el->loc = loc;\n-  el->setting_insn = cselib_current_insn;\n-  return el;\n-}\n-\n-/* The elt_list at *PL is no longer needed.  Unchain it and free its\n-   storage.  */\n-\n-static void\n-unchain_one_elt_list (pl)\n-     struct elt_list **pl;\n-{\n-  struct elt_list *l = *pl;\n-\n-  *pl = l->next;\n-  l->next = empty_elt_lists;\n-  empty_elt_lists = l;\n-}\n-\n-/* Likewise for elt_loc_lists.  */\n-\n-static void\n-unchain_one_elt_loc_list (pl)\n-     struct elt_loc_list **pl;\n-{\n-  struct elt_loc_list *l = *pl;\n-\n-  *pl = l->next;\n-  l->next = empty_elt_loc_lists;\n-  empty_elt_loc_lists = l;\n-}\n-\n-/* Likewise for cselib_vals.  This also frees the addr_list associated with\n-   V.  */\n-\n-static void\n-unchain_one_value (v)\n-     cselib_val *v;\n-{\n-  while (v->addr_list)\n-    unchain_one_elt_list (&v->addr_list);\n-\n-  v->u.next_free = empty_vals;\n-  empty_vals = v;\n-}\n-\n-/* Remove all entries from the hash table.  Also used during\n-   initialization.  If CLEAR_ALL isn't set, then only clear the entries\n-   which are known to have been used.  */\n-\n-static void\n-clear_table (clear_all)\n-     int clear_all;\n-{\n-  unsigned int i;\n-\n-  if (clear_all)\n-    for (i = 0; i < cselib_nregs; i++)\n-      REG_VALUES (i) = 0;\n-  else\n-    for (i = 0; i < VARRAY_ACTIVE_SIZE (used_regs); i++)\n-      REG_VALUES (VARRAY_UINT (used_regs, i)) = 0;\n-\n-  VARRAY_POP_ALL (used_regs);\n-\n-  htab_empty (hash_table);\n-  obstack_free (&cselib_obstack, cselib_startobj);\n-\n-  empty_vals = 0;\n-  empty_elt_lists = 0;\n-  empty_elt_loc_lists = 0;\n-  n_useless_values = 0;\n-\n-  next_unknown_value = 0;\n-}\n-\n-/* The equality test for our hash table.  The first argument ENTRY is a table\n-   element (i.e. a cselib_val), while the second arg X is an rtx.  We know\n-   that all callers of htab_find_slot_with_hash will wrap CONST_INTs into a\n-   CONST of an appropriate mode.  */\n-\n-static int\n-entry_and_rtx_equal_p (entry, x_arg)\n-     const void *entry, *x_arg;\n-{\n-  struct elt_loc_list *l;\n-  const cselib_val *v = (const cselib_val *) entry;\n-  rtx x = (rtx) x_arg;\n-  enum machine_mode mode = GET_MODE (x);\n-\n-  if (GET_CODE (x) == CONST_INT\n-      || (mode == VOIDmode && GET_CODE (x) == CONST_DOUBLE))\n-    abort ();\n-  if (mode != GET_MODE (v->u.val_rtx))\n-    return 0;\n-\n-  /* Unwrap X if necessary.  */\n-  if (GET_CODE (x) == CONST\n-      && (GET_CODE (XEXP (x, 0)) == CONST_INT\n-\t  || GET_CODE (XEXP (x, 0)) == CONST_DOUBLE))\n-    x = XEXP (x, 0);\n-  \n-  /* We don't guarantee that distinct rtx's have different hash values,\n-     so we need to do a comparison.  */\n-  for (l = v->locs; l; l = l->next)\n-    if (rtx_equal_for_cselib_p (l->loc, x))\n-      return 1;\n-\n-  return 0;\n-}\n-\n-/* The hash function for our hash table.  The value is always computed with\n-   hash_rtx when adding an element; this function just extracts the hash\n-   value from a cselib_val structure.  */\n-\n-static unsigned int\n-get_value_hash (entry)\n-     const void *entry;\n-{\n-  const cselib_val *v = (const cselib_val *) entry;\n-  return v->value;\n-}\n-\n-/* Return true if X contains a VALUE rtx.  If ONLY_USELESS is set, we\n-   only return true for values which point to a cselib_val whose value\n-   element has been set to zero, which implies the cselib_val will be\n-   removed.  */\n-\n-int\n-references_value_p (x, only_useless)\n-     rtx x;\n-     int only_useless;\n-{\n-  enum rtx_code code = GET_CODE (x);\n-  const char *fmt = GET_RTX_FORMAT (code);\n-  int i, j;\n-\n-  if (GET_CODE (x) == VALUE\n-      && (! only_useless || CSELIB_VAL_PTR (x)->locs == 0))\n-    return 1;\n-\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    {\n-      if (fmt[i] == 'e' && references_value_p (XEXP (x, i), only_useless))\n-\treturn 1;\n-      else if (fmt[i] == 'E')\n-\tfor (j = 0; j < XVECLEN (x, i); j++)\n-\t  if (references_value_p (XVECEXP (x, i, j), only_useless))\n-\t    return 1;\n-    }\n-\n-  return 0;\n-}\n-\n-/* For all locations found in X, delete locations that reference useless\n-   values (i.e. values without any location).  Called through\n-   htab_traverse.  */\n-\n-static int\n-discard_useless_locs (x, info)\n-     void **x;\n-     void *info ATTRIBUTE_UNUSED;\n-{\n-  cselib_val *v = (cselib_val *)*x;\n-  struct elt_loc_list **p = &v->locs;\n-  int had_locs = v->locs != 0;\n-\n-  while (*p)\n-    {\n-      if (references_value_p ((*p)->loc, 1))\n-\tunchain_one_elt_loc_list (p);\n-      else\n-\tp = &(*p)->next;\n-    }\n-\n-  if (had_locs && v->locs == 0)\n-    {\n-      n_useless_values++;\n-      values_became_useless = 1;\n-    }\n-  return 1;\n-}\n-\n-/* If X is a value with no locations, remove it from the hashtable.  */\n-\n-static int\n-discard_useless_values (x, info)\n-     void **x;\n-     void *info ATTRIBUTE_UNUSED;\n-{\n-  cselib_val *v = (cselib_val *)*x;\n-\n-  if (v->locs == 0)\n-    {\n-      htab_clear_slot (hash_table, x);\n-      unchain_one_value (v);\n-      n_useless_values--;\n-    }\n-\n-  return 1;\n-}\n-\n-/* Clean out useless values (i.e. those which no longer have locations\n-   associated with them) from the hash table.  */\n-\n-static void\n-remove_useless_values ()\n-{\n-  /* First pass: eliminate locations that reference the value.  That in\n-     turn can make more values useless.  */\n-  do\n-    {\n-      values_became_useless = 0;\n-      htab_traverse (hash_table, discard_useless_locs, 0);\n-    }\n-  while (values_became_useless);\n-\n-  /* Second pass: actually remove the values.  */\n-  htab_traverse (hash_table, discard_useless_values, 0);\n-\n-  if (n_useless_values != 0)\n-    abort ();\n-}\n-\n-/* Return nonzero if we can prove that X and Y contain the same value, taking\n-   our gathered information into account.  */\n-\n-int\n-rtx_equal_for_cselib_p (x, y)\n-     rtx x, y;\n-{\n-  enum rtx_code code;\n-  const char *fmt;\n-  int i;\n-  \n-  if (GET_CODE (x) == REG || GET_CODE (x) == MEM)\n-    {\n-      cselib_val *e = cselib_lookup (x, GET_MODE (x), 0);\n-\n-      if (e)\n-\tx = e->u.val_rtx;\n-    }\n-\n-  if (GET_CODE (y) == REG || GET_CODE (y) == MEM)\n-    {\n-      cselib_val *e = cselib_lookup (y, GET_MODE (y), 0);\n-\n-      if (e)\n-\ty = e->u.val_rtx;\n-    }\n-\n-  if (x == y)\n-    return 1;\n-\n-  if (GET_CODE (x) == VALUE && GET_CODE (y) == VALUE)\n-    return CSELIB_VAL_PTR (x) == CSELIB_VAL_PTR (y);\n-\n-  if (GET_CODE (x) == VALUE)\n-    {\n-      cselib_val *e = CSELIB_VAL_PTR (x);\n-      struct elt_loc_list *l;\n-\n-      for (l = e->locs; l; l = l->next)\n-\t{\n-\t  rtx t = l->loc;\n-\n-\t  /* Avoid infinite recursion.  */\n-\t  if (GET_CODE (t) == REG || GET_CODE (t) == MEM)\n-\t    continue;\n-\t  else if (rtx_equal_for_cselib_p (t, y))\n-\t    return 1;\n-\t}\n-      \n-      return 0;\n-    }\n-\n-  if (GET_CODE (y) == VALUE)\n-    {\n-      cselib_val *e = CSELIB_VAL_PTR (y);\n-      struct elt_loc_list *l;\n-\n-      for (l = e->locs; l; l = l->next)\n-\t{\n-\t  rtx t = l->loc;\n-\n-\t  if (GET_CODE (t) == REG || GET_CODE (t) == MEM)\n-\t    continue;\n-\t  else if (rtx_equal_for_cselib_p (x, t))\n-\t    return 1;\n-\t}\n-      \n-      return 0;\n-    }\n-\n-  if (GET_CODE (x) != GET_CODE (y) || GET_MODE (x) != GET_MODE (y))\n-    return 0;\n-\n-  /* This won't be handled correctly by the code below.  */\n-  if (GET_CODE (x) == LABEL_REF)\n-    return XEXP (x, 0) == XEXP (y, 0);\n-  \n-  code = GET_CODE (x);\n-  fmt = GET_RTX_FORMAT (code);\n-\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    {\n-      int j;\n-\n-      switch (fmt[i])\n-\t{\n-\tcase 'w':\n-\t  if (XWINT (x, i) != XWINT (y, i))\n-\t    return 0;\n-\t  break;\n-\n-\tcase 'n':\n-\tcase 'i':\n-\t  if (XINT (x, i) != XINT (y, i))\n-\t    return 0;\n-\t  break;\n-\n-\tcase 'V':\n-\tcase 'E':\n-\t  /* Two vectors must have the same length.  */\n-\t  if (XVECLEN (x, i) != XVECLEN (y, i))\n-\t    return 0;\n-\n-\t  /* And the corresponding elements must match.  */\n-\t  for (j = 0; j < XVECLEN (x, i); j++)\n-\t    if (! rtx_equal_for_cselib_p (XVECEXP (x, i, j),\n-\t\t\t\t\t  XVECEXP (y, i, j)))\n-\t      return 0;\n-\t  break;\n-\n-\tcase 'e':\n-\t  if (! rtx_equal_for_cselib_p (XEXP (x, i), XEXP (y, i)))\n-\t    return 0;\n-\t  break;\n-\n-\tcase 'S':\n-\tcase 's':\n-\t  if (strcmp (XSTR (x, i), XSTR (y, i)))\n-\t    return 0;\n-\t  break;\n-\n-\tcase 'u':\n-\t  /* These are just backpointers, so they don't matter.  */\n-\t  break;\n-\n-\tcase '0':\n-\tcase 't':\n-\t  break;\n-\n-\t  /* It is believed that rtx's at this level will never\n-\t     contain anything but integers and other rtx's,\n-\t     except for within LABEL_REFs and SYMBOL_REFs.  */\n-\tdefault:\n-\t  abort ();\n-\t}\n-    }\n-  return 1;\n-}\n-\n-/* We need to pass down the mode of constants through the hash table\n-   functions.  For that purpose, wrap them in a CONST of the appropriate\n-   mode.  */\n-static rtx\n-wrap_constant (mode, x)\n-     enum machine_mode mode;\n-     rtx x;\n-{\n-  if (GET_CODE (x) != CONST_INT\n-      && (GET_CODE (x) != CONST_DOUBLE || GET_MODE (x) != VOIDmode))\n-    return x;\n-  if (mode == VOIDmode)\n-    abort ();\n-  return gen_rtx_CONST (mode, x);\n-}\n-\n-/* Hash an rtx.  Return 0 if we couldn't hash the rtx.\n-   For registers and memory locations, we look up their cselib_val structure\n-   and return its VALUE element.\n-   Possible reasons for return 0 are: the object is volatile, or we couldn't\n-   find a register or memory location in the table and CREATE is zero.  If\n-   CREATE is nonzero, table elts are created for regs and mem.\n-   MODE is used in hashing for CONST_INTs only;\n-   otherwise the mode of X is used.  */\n-\n-static unsigned int\n-hash_rtx (x, mode, create)\n-     rtx x;\n-     enum machine_mode mode;\n-     int create;\n-{\n-  cselib_val *e;\n-  int i, j;\n-  enum rtx_code code;\n-  const char *fmt;\n-  unsigned int hash = 0;\n-\n-  /* repeat is used to turn tail-recursion into iteration.  */\n- repeat:\n-  code = GET_CODE (x);\n-  hash += (unsigned) code + (unsigned) GET_MODE (x);\n-\n-  switch (code)\n-    {\n-    case MEM:\n-    case REG:\n-      e = cselib_lookup (x, GET_MODE (x), create);\n-      if (! e)\n-\treturn 0;\n-\n-      hash += e->value;\n-      return hash;\n-\n-    case CONST_INT:\n-      hash += ((unsigned) CONST_INT << 7) + (unsigned) mode + INTVAL (x);\n-      return hash ? hash : CONST_INT;\n-\n-    case CONST_DOUBLE:\n-      /* This is like the general case, except that it only counts\n-\t the integers representing the constant.  */\n-      hash += (unsigned) code + (unsigned) GET_MODE (x);\n-      if (GET_MODE (x) != VOIDmode)\n-\tfor (i = 2; i < GET_RTX_LENGTH (CONST_DOUBLE); i++)\n-\t  hash += XWINT (x, i);\n-      else\n-\thash += ((unsigned) CONST_DOUBLE_LOW (x)\n-\t\t + (unsigned) CONST_DOUBLE_HIGH (x));\n-      return hash ? hash : CONST_DOUBLE;\n-\n-      /* Assume there is only one rtx object for any given label.  */\n-    case LABEL_REF:\n-      hash\n-\t+= ((unsigned) LABEL_REF << 7) + (unsigned long) XEXP (x, 0);\n-      return hash ? hash : LABEL_REF;\n-\n-    case SYMBOL_REF:\n-      hash\n-\t+= ((unsigned) SYMBOL_REF << 7) + (unsigned long) XSTR (x, 0);\n-      return hash ? hash : SYMBOL_REF;\n-\n-    case PRE_DEC:\n-    case PRE_INC:\n-    case POST_DEC:\n-    case POST_INC:\n-    case POST_MODIFY:\n-    case PRE_MODIFY:\n-    case PC:\n-    case CC0:\n-    case CALL:\n-    case UNSPEC_VOLATILE:\n-      return 0;\n-\n-    case ASM_OPERANDS:\n-      if (MEM_VOLATILE_P (x))\n-\treturn 0;\n-\n-      break;\n-      \n-    default:\n-      break;\n-    }\n-\n-  i = GET_RTX_LENGTH (code) - 1;\n-  fmt = GET_RTX_FORMAT (code);\n-  for (; i >= 0; i--)\n-    {\n-      if (fmt[i] == 'e')\n-\t{\n-\t  rtx tem = XEXP (x, i);\n-\t  unsigned int tem_hash;\n-\n-\t  /* If we are about to do the last recursive call\n-\t     needed at this level, change it into iteration.\n-\t     This function  is called enough to be worth it.  */\n-\t  if (i == 0)\n-\t    {\n-\t      x = tem;\n-\t      goto repeat;\n-\t    }\n-\n-\t  tem_hash = hash_rtx (tem, 0, create);\n-\t  if (tem_hash == 0)\n-\t    return 0;\n-\n-\t  hash += tem_hash;\n-\t}\n-      else if (fmt[i] == 'E')\n-\tfor (j = 0; j < XVECLEN (x, i); j++)\n-\t  {\n-\t    unsigned int tem_hash = hash_rtx (XVECEXP (x, i, j), 0, create);\n-\n-\t    if (tem_hash == 0)\n-\t      return 0;\n-\n-\t    hash += tem_hash;\n-\t  }\n-      else if (fmt[i] == 's')\n-\t{\n-\t  const unsigned char *p = (const unsigned char *) XSTR (x, i);\n-\n-\t  if (p)\n-\t    while (*p)\n-\t      hash += *p++;\n-\t}\n-      else if (fmt[i] == 'i')\n-\thash += XINT (x, i);\n-      else if (fmt[i] == '0' || fmt[i] == 't')\n-\t/* unused */;\n-      else\n-\tabort ();\n-    }\n-\n-  return hash ? hash : 1 + GET_CODE (x);\n-}\n-\n-/* Create a new value structure for VALUE and initialize it.  The mode of the\n-   value is MODE.  */\n-\n-static cselib_val *\n-new_cselib_val (value, mode)\n-     unsigned int value;\n-     enum machine_mode mode;\n-{\n-  cselib_val *e = empty_vals;\n-\n-  if (e)\n-    empty_vals = e->u.next_free;\n-  else\n-    e = (cselib_val *) obstack_alloc (&cselib_obstack, sizeof (cselib_val));\n-\n-  if (value == 0)\n-    abort ();\n-\n-  e->value = value;\n-  e->u.val_rtx = gen_rtx_VALUE (mode);\n-  CSELIB_VAL_PTR (e->u.val_rtx) = e;\n-  e->addr_list = 0;\n-  e->locs = 0;\n-  return e;\n-}\n-\n-/* ADDR_ELT is a value that is used as address.  MEM_ELT is the value that\n-   contains the data at this address.  X is a MEM that represents the\n-   value.  Update the two value structures to represent this situation.  */\n-\n-static void\n-add_mem_for_addr (addr_elt, mem_elt, x)\n-     cselib_val *addr_elt, *mem_elt;\n-     rtx x;\n-{\n-  rtx new;\n-  struct elt_loc_list *l;\n-\n-  /* Avoid duplicates.  */\n-  for (l = mem_elt->locs; l; l = l->next)\n-    if (GET_CODE (l->loc) == MEM\n-\t&& CSELIB_VAL_PTR (XEXP (l->loc, 0)) == addr_elt)\n-      return;\n-\n-  new = gen_rtx_MEM (GET_MODE (x), addr_elt->u.val_rtx);\n-  MEM_COPY_ATTRIBUTES (new, x);\n-\n-  addr_elt->addr_list = new_elt_list (addr_elt->addr_list, mem_elt);\n-  mem_elt->locs = new_elt_loc_list (mem_elt->locs, new);\n-}\n-\n-/* Subroutine of cselib_lookup.  Return a value for X, which is a MEM rtx.\n-   If CREATE, make a new one if we haven't seen it before.  */\n-\n-static cselib_val *\n-cselib_lookup_mem (x, create)\n-     rtx x;\n-     int create;\n-{\n-  enum machine_mode mode = GET_MODE (x);\n-  void **slot;\n-  cselib_val *addr;\n-  cselib_val *mem_elt;\n-  struct elt_list *l;\n-\n-  if (MEM_VOLATILE_P (x) || mode == BLKmode\n-      || (FLOAT_MODE_P (mode) && flag_float_store))\n-    return 0;\n-\n-  /* Look up the value for the address.  */\n-  addr = cselib_lookup (XEXP (x, 0), mode, create);\n-  if (! addr)\n-    return 0;\n-\n-  /* Find a value that describes a value of our mode at that address.  */\n-  for (l = addr->addr_list; l; l = l->next)\n-    if (GET_MODE (l->elt->u.val_rtx) == mode)\n-      return l->elt;\n-\n-  if (! create)\n-    return 0;\n-\n-  mem_elt = new_cselib_val (++next_unknown_value, mode);\n-  add_mem_for_addr (addr, mem_elt, x);\n-  slot = htab_find_slot_with_hash (hash_table, wrap_constant (mode, x),\n-\t\t\t\t   mem_elt->value, INSERT);\n-  *slot = mem_elt;\n-  return mem_elt;\n-}\n-\n-/* Walk rtx X and replace all occurrences of REG and MEM subexpressions\n-   with VALUE expressions.  This way, it becomes independent of changes\n-   to registers and memory.\n-   X isn't actually modified; if modifications are needed, new rtl is\n-   allocated.  However, the return value can share rtl with X.  */\n-\n-static rtx\n-cselib_subst_to_values (x)\n-     rtx x;\n-{\n-  enum rtx_code code = GET_CODE (x);\n-  const char *fmt = GET_RTX_FORMAT (code);\n-  cselib_val *e;\n-  struct elt_list *l;\n-  rtx copy = x;\n-  int i;\n-\n-  switch (code)\n-    {\n-    case REG:\n-      for (l = REG_VALUES (REGNO (x)); l; l = l->next)\n-\tif (GET_MODE (l->elt->u.val_rtx) == GET_MODE (x))\n-\t  return l->elt->u.val_rtx;\n-\n-      abort ();\n-\n-    case MEM:\n-      e = cselib_lookup_mem (x, 0);\n-      if (! e)\n-\tabort ();\n-      return e->u.val_rtx;\n-\n-      /* CONST_DOUBLEs must be special-cased here so that we won't try to\n-\t look up the CONST_DOUBLE_MEM inside.  */\n-    case CONST_DOUBLE:\n-    case CONST_INT:\n-      return x;\n-\n-    default:\n-      break;\n-    }\n-\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    {\n-      if (fmt[i] == 'e')\n-\t{\n-\t  rtx t = cselib_subst_to_values (XEXP (x, i));\n-\n-\t  if (t != XEXP (x, i) && x == copy)\n-\t    copy = shallow_copy_rtx (x);\n-\n-\t  XEXP (copy, i) = t;\n-\t}\n-      else if (fmt[i] == 'E')\n-\t{\n-\t  int j, k;\n-\n-\t  for (j = 0; j < XVECLEN (x, i); j++)\n-\t    {\n-\t      rtx t = cselib_subst_to_values (XVECEXP (x, i, j));\n-\n-\t      if (t != XVECEXP (x, i, j) && XVEC (x, i) == XVEC (copy, i))\n-\t\t{\n-\t\t  if (x == copy)\n-\t\t    copy = shallow_copy_rtx (x);\n-\n-\t\t  XVEC (copy, i) = rtvec_alloc (XVECLEN (x, i));\n-\t\t  for (k = 0; k < j; k++)\n-\t\t    XVECEXP (copy, i, k) = XVECEXP (x, i, k);\n-\t\t}\n-\n-\t      XVECEXP (copy, i, j) = t;\n-\t    }\n-\t}\n-    }\n-\n-  return copy;\n-}\n-\n-/* Look up the rtl expression X in our tables and return the value it has.\n-   If CREATE is zero, we return NULL if we don't know the value.  Otherwise,\n-   we create a new one if possible, using mode MODE if X doesn't have a mode\n-   (i.e. because it's a constant).  */\n-\n-cselib_val *\n-cselib_lookup (x, mode, create)\n-     rtx x;\n-     enum machine_mode mode;\n-     int create;\n-{\n-  void **slot;\n-  cselib_val *e;\n-  unsigned int hashval;\n-\n-  if (GET_MODE (x) != VOIDmode)\n-    mode = GET_MODE (x);\n-\n-  if (GET_CODE (x) == VALUE)\n-    return CSELIB_VAL_PTR (x);\n-\n-  if (GET_CODE (x) == REG)\n-    {\n-      struct elt_list *l;\n-      unsigned int i = REGNO (x);\n-\n-      for (l = REG_VALUES (i); l; l = l->next)\n-\tif (mode == GET_MODE (l->elt->u.val_rtx))\n-\t  return l->elt;\n-\n-      if (! create)\n-\treturn 0;\n-\n-      e = new_cselib_val (++next_unknown_value, GET_MODE (x));\n-      e->locs = new_elt_loc_list (e->locs, x);\n-      if (REG_VALUES (i) == 0)\n-        VARRAY_PUSH_UINT (used_regs, i);\n-      REG_VALUES (i) = new_elt_list (REG_VALUES (i), e);\n-      slot = htab_find_slot_with_hash (hash_table, x, e->value, INSERT);\n-      *slot = e;\n-      return e;\n-    }\n-\n-  if (GET_CODE (x) == MEM)\n-    return cselib_lookup_mem (x, create);\n-\n-  hashval = hash_rtx (x, mode, create);\n-  /* Can't even create if hashing is not possible.  */\n-  if (! hashval)\n-    return 0;\n-\n-  slot = htab_find_slot_with_hash (hash_table, wrap_constant (mode, x),\n-\t\t\t\t   hashval, create ? INSERT : NO_INSERT);\n-  if (slot == 0)\n-    return 0;\n-\n-  e = (cselib_val *) *slot;\n-  if (e)\n-    return e;\n-\n-  e = new_cselib_val (hashval, mode);\n-\n-  /* We have to fill the slot before calling cselib_subst_to_values:\n-     the hash table is inconsistent until we do so, and\n-     cselib_subst_to_values will need to do lookups.  */\n-  *slot = (void *) e;\n-  e->locs = new_elt_loc_list (e->locs, cselib_subst_to_values (x));\n-  return e;\n-}\n-\n-/* Invalidate any entries in reg_values that overlap REGNO.  This is called\n-   if REGNO is changing.  MODE is the mode of the assignment to REGNO, which\n-   is used to determine how many hard registers are being changed.  If MODE\n-   is VOIDmode, then only REGNO is being changed; this is used when\n-   invalidating call clobbered registers across a call.  */\n-\n-static void\n-cselib_invalidate_regno (regno, mode)\n-     unsigned int regno;\n-     enum machine_mode mode;\n-{\n-  unsigned int endregno;\n-  unsigned int i;\n-\n-  /* If we see pseudos after reload, something is _wrong_.  */\n-  if (reload_completed && regno >= FIRST_PSEUDO_REGISTER\n-      && reg_renumber[regno] >= 0)\n-    abort ();\n-\n-  /* Determine the range of registers that must be invalidated.  For\n-     pseudos, only REGNO is affected.  For hard regs, we must take MODE\n-     into account, and we must also invalidate lower register numbers\n-     if they contain values that overlap REGNO.  */\n-  endregno = regno + 1;\n-  if (regno < FIRST_PSEUDO_REGISTER && mode != VOIDmode) \n-    endregno = regno + HARD_REGNO_NREGS (regno, mode);\n-\n-  for (i = 0; i < endregno; i++)\n-    {\n-      struct elt_list **l = &REG_VALUES (i);\n-\n-      /* Go through all known values for this reg; if it overlaps the range\n-\t we're invalidating, remove the value.  */\n-      while (*l)\n-\t{\n-\t  cselib_val *v = (*l)->elt;\n-\t  struct elt_loc_list **p;\n-\t  unsigned int this_last = i;\n-\n-\t  if (i < FIRST_PSEUDO_REGISTER)\n-\t    this_last += HARD_REGNO_NREGS (i, GET_MODE (v->u.val_rtx)) - 1;\n-\n-\t  if (this_last < regno)\n-\t    {\n-\t      l = &(*l)->next;\n-\t      continue;\n-\t    }\n-\n-\t  /* We have an overlap.  */\n-\t  unchain_one_elt_list (l);\n-\n-\t  /* Now, we clear the mapping from value to reg.  It must exist, so\n-\t     this code will crash intentionally if it doesn't.  */\n-\t  for (p = &v->locs; ; p = &(*p)->next)\n-\t    {\n-\t      rtx x = (*p)->loc;\n-\n-\t      if (GET_CODE (x) == REG && REGNO (x) == i)\n-\t\t{\n-\t\t  unchain_one_elt_loc_list (p);\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t  if (v->locs == 0)\n-\t    n_useless_values++;\n-\t}\n-    }\n-}\n-\n-/* The memory at address MEM_BASE is being changed.\n-   Return whether this change will invalidate VAL.  */\n-\n-static int\n-cselib_mem_conflict_p (mem_base, val)\n-     rtx mem_base;\n-     rtx val;\n-{\n-  enum rtx_code code;\n-  const char *fmt;\n-  int i, j;\n-\n-  code = GET_CODE (val);\n-  switch (code)\n-    {\n-      /* Get rid of a few simple cases quickly. */\n-    case REG:\n-    case PC:\n-    case CC0:\n-    case SCRATCH:\n-    case CONST:\n-    case CONST_INT:\n-    case CONST_DOUBLE:\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-      return 0;\n-\n-    case MEM:\n-      if (GET_MODE (mem_base) == BLKmode\n-\t  || GET_MODE (val) == BLKmode\n-\t  || anti_dependence (val, mem_base))\n-\treturn 1;\n-\n-      /* The address may contain nested MEMs.  */\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    {\n-      if (fmt[i] == 'e')\n-\t{\n-\t  if (cselib_mem_conflict_p (mem_base, XEXP (val, i)))\n-\t    return 1;\n-\t}\n-      else if (fmt[i] == 'E')\n-\tfor (j = 0; j < XVECLEN (val, i); j++)\n-\t  if (cselib_mem_conflict_p (mem_base, XVECEXP (val, i, j)))\n-\t    return 1;\n-    }\n-\n-  return 0;\n-}\n-\n-/* For the value found in SLOT, walk its locations to determine if any overlap\n-   INFO (which is a MEM rtx).  */\n-\n-static int\n-cselib_invalidate_mem_1 (slot, info)\n-     void **slot;\n-     void *info;\n-{\n-  cselib_val *v = (cselib_val *) *slot;\n-  rtx mem_rtx = (rtx) info;\n-  struct elt_loc_list **p = &v->locs;\n-  int had_locs = v->locs != 0;\n-\n-  while (*p)\n-    {\n-      rtx x = (*p)->loc;\n-      cselib_val *addr;\n-      struct elt_list **mem_chain;\n-\n-      /* MEMs may occur in locations only at the top level; below\n-\t that every MEM or REG is substituted by its VALUE.  */\n-      if (GET_CODE (x) != MEM\n-\t  || ! cselib_mem_conflict_p (mem_rtx, x))\n-\t{\n-\t  p = &(*p)->next;\n-\t  continue;\n-\t}\n-\n-      /* This one overlaps.  */\n-      /* We must have a mapping from this MEM's address to the\n-\t value (E).  Remove that, too.  */\n-      addr = cselib_lookup (XEXP (x, 0), VOIDmode, 0);\n-      mem_chain = &addr->addr_list;\n-      for (;;)\n-\t{\n-\t  if ((*mem_chain)->elt == v)\n-\t    {\n-\t      unchain_one_elt_list (mem_chain);\n-\t      break;\n-\t    }\n-\n-\t  mem_chain = &(*mem_chain)->next;\n-\t}\n-\n-      unchain_one_elt_loc_list (p);\n-    }\n-\n-  if (had_locs && v->locs == 0)\n-    n_useless_values++;\n-\n-  return 1;\n-}\n-\n-/* Invalidate any locations in the table which are changed because of a\n-   store to MEM_RTX.  If this is called because of a non-const call\n-   instruction, MEM_RTX is (mem:BLK const0_rtx).  */\n-\n-static void\n-cselib_invalidate_mem (mem_rtx)\n-     rtx mem_rtx;\n-{\n-  htab_traverse (hash_table, cselib_invalidate_mem_1, mem_rtx);\n-}\n-\n-/* Invalidate DEST, which is being assigned to or clobbered.  The second and\n-   the third parameter exist so that this function can be passed to\n-   note_stores; they are ignored.  */\n-\n-static void\n-cselib_invalidate_rtx (dest, ignore, data)\n-     rtx dest;\n-     rtx ignore ATTRIBUTE_UNUSED;\n-     void *data ATTRIBUTE_UNUSED;\n-{\n-  while (GET_CODE (dest) == STRICT_LOW_PART || GET_CODE (dest) == SIGN_EXTRACT\n-\t || GET_CODE (dest) == ZERO_EXTRACT || GET_CODE (dest) == SUBREG)\n-    dest = XEXP (dest, 0);\n-\n-  if (GET_CODE (dest) == REG)\n-    cselib_invalidate_regno (REGNO (dest), GET_MODE (dest));\n-  else if (GET_CODE (dest) == MEM)\n-    cselib_invalidate_mem (dest);\n-\n-  /* Some machines don't define AUTO_INC_DEC, but they still use push\n-     instructions.  We need to catch that case here in order to\n-     invalidate the stack pointer correctly.  Note that invalidating\n-     the stack pointer is different from invalidating DEST.  */\n-  if (push_operand (dest, GET_MODE (dest)))\n-    cselib_invalidate_rtx (stack_pointer_rtx, NULL_RTX, NULL);\n-}\n-\n-/* Record the result of a SET instruction.  DEST is being set; the source\n-   contains the value described by SRC_ELT.  If DEST is a MEM, DEST_ADDR_ELT\n-   describes its address.  */\n-\n-static void\n-cselib_record_set (dest, src_elt, dest_addr_elt)\n-     rtx dest;\n-     cselib_val *src_elt, *dest_addr_elt;\n-{\n-  int dreg = GET_CODE (dest) == REG ? (int) REGNO (dest) : -1;\n-\n-  if (src_elt == 0 || side_effects_p (dest))\n-    return;\n-\n-  if (dreg >= 0)\n-    {\n-      if (REG_VALUES (dreg) == 0)\n-        VARRAY_PUSH_UINT (used_regs, dreg);\n-\n-      REG_VALUES (dreg) = new_elt_list (REG_VALUES (dreg), src_elt);\n-      if (src_elt->locs == 0)\n-\tn_useless_values--;\n-      src_elt->locs = new_elt_loc_list (src_elt->locs, dest);\n-    }\n-  else if (GET_CODE (dest) == MEM && dest_addr_elt != 0)\n-    {\n-      if (src_elt->locs == 0)\n-\tn_useless_values--;\n-      add_mem_for_addr (dest_addr_elt, src_elt, dest);\n-    }\n-}\n-\n-/* Describe a single set that is part of an insn.  */\n-struct set\n-{\n-  rtx src;\n-  rtx dest;\n-  cselib_val *src_elt;\n-  cselib_val *dest_addr_elt;\n-};\n-\n-/* There is no good way to determine how many elements there can be\n-   in a PARALLEL.  Since it's fairly cheap, use a really large number.  */\n-#define MAX_SETS (FIRST_PSEUDO_REGISTER * 2)\n-\n-/* Record the effects of any sets in INSN.  */\n-static void\n-cselib_record_sets (insn)\n-     rtx insn;\n-{\n-  int n_sets = 0;\n-  int i;\n-  struct set sets[MAX_SETS];\n-  rtx body = PATTERN (insn);\n-\n-  body = PATTERN (insn);\n-  /* Find all sets.  */\n-  if (GET_CODE (body) == SET)\n-    {\n-      sets[0].src = SET_SRC (body);\n-      sets[0].dest = SET_DEST (body);\n-      n_sets = 1;\n-    }\n-  else if (GET_CODE (body) == PARALLEL)\n-    {\n-      /* Look through the PARALLEL and record the values being\n-\t set, if possible.  Also handle any CLOBBERs.  */\n-      for (i = XVECLEN (body, 0) - 1; i >= 0; --i)\n-\t{\n-\t  rtx x = XVECEXP (body, 0, i);\n-\n-\t  if (GET_CODE (x) == SET)\n-\t    {\n-\t      sets[n_sets].src = SET_SRC (x);\n-\t      sets[n_sets].dest = SET_DEST (x);\n-\t      n_sets++;\n-\t    }\n-\t}\n-    }\n-\n-  /* Look up the values that are read.  Do this before invalidating the\n-     locations that are written.  */\n-  for (i = 0; i < n_sets; i++)\n-    {\n-      rtx dest = sets[i].dest;\n-\n-      /* A STRICT_LOW_PART can be ignored; we'll record the equivalence for\n-         the low part after invalidating any knowledge about larger modes.  */\n-      if (GET_CODE (sets[i].dest) == STRICT_LOW_PART)\n-\tsets[i].dest = dest = XEXP (dest, 0);\n-\n-      /* We don't know how to record anything but REG or MEM.  */\n-      if (GET_CODE (dest) == REG || GET_CODE (dest) == MEM)\n-        {\n-\t  sets[i].src_elt = cselib_lookup (sets[i].src, GET_MODE (dest), 1);\n-\t  if (GET_CODE (dest) == MEM)\n-\t    sets[i].dest_addr_elt = cselib_lookup (XEXP (dest, 0), Pmode, 1);\n-\t  else\n-\t    sets[i].dest_addr_elt = 0;\n-\t}\n-    }\n-\n-  /* Invalidate all locations written by this insn.  Note that the elts we\n-     looked up in the previous loop aren't affected, just some of their\n-     locations may go away.  */\n-  note_stores (body, cselib_invalidate_rtx, NULL);\n-\n-  /* Now enter the equivalences in our tables.  */\n-  for (i = 0; i < n_sets; i++)\n-    {\n-      rtx dest = sets[i].dest;\n-      if (GET_CODE (dest) == REG || GET_CODE (dest) == MEM)\n-\tcselib_record_set (dest, sets[i].src_elt, sets[i].dest_addr_elt);\n-    }\n-}\n-\n-/* Record the effects of INSN.  */\n-\n-void\n-cselib_process_insn (insn)\n-     rtx insn;\n-{\n-  int i;\n-  rtx x;\n-\n-  cselib_current_insn = insn;\n-\n-  /* Forget everything at a CODE_LABEL, a volatile asm, or a setjmp.  */\n-  if (GET_CODE (insn) == CODE_LABEL\n-      || (GET_CODE (insn) == NOTE\n-\t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_SETJMP)\n-      || (GET_CODE (insn) == INSN\n-\t  && GET_CODE (PATTERN (insn)) == ASM_OPERANDS\n-\t  && MEM_VOLATILE_P (PATTERN (insn))))\n-    {\n-      clear_table (0);\n-      return;\n-    }\n-\n-  if (! INSN_P (insn))\n-    {\n-      cselib_current_insn = 0;\n-      return;\n-    }\n-\n-  /* If this is a call instruction, forget anything stored in a\n-     call clobbered register, or, if this is not a const call, in\n-     memory.  */\n-  if (GET_CODE (insn) == CALL_INSN)\n-    {\n-      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\tif (call_used_regs[i])\n-\t  cselib_invalidate_regno (i, VOIDmode);\n-\n-      if (! CONST_CALL_P (insn))\n-\tcselib_invalidate_mem (callmem);\n-    }\n-\n-  cselib_record_sets (insn);\n-\n-#ifdef AUTO_INC_DEC\n-  /* Clobber any registers which appear in REG_INC notes.  We\n-     could keep track of the changes to their values, but it is\n-     unlikely to help.  */\n-  for (x = REG_NOTES (insn); x; x = XEXP (x, 1))\n-    if (REG_NOTE_KIND (x) == REG_INC)\n-      cselib_invalidate_rtx (XEXP (x, 0), NULL_RTX, NULL);\n-#endif\n-\n-  /* Look for any CLOBBERs in CALL_INSN_FUNCTION_USAGE, but only\n-     after we have processed the insn.  */\n-  if (GET_CODE (insn) == CALL_INSN)\n-    for (x = CALL_INSN_FUNCTION_USAGE (insn); x; x = XEXP (x, 1))\n-      if (GET_CODE (XEXP (x, 0)) == CLOBBER)\n-\tcselib_invalidate_rtx (XEXP (XEXP (x, 0), 0), NULL_RTX, NULL);\n-\n-  cselib_current_insn = 0;\n-\n-  if (n_useless_values > MAX_USELESS_VALUES)\n-    remove_useless_values ();\n-}\n-\n-/* Make sure our varrays are big enough.  Not called from any cselib routines;\n-   it must be called by the user if it allocated new registers.  */\n-\n-void\n-cselib_update_varray_sizes ()\n-{\n-  unsigned int nregs = max_reg_num ();\n-\n-  if (nregs == cselib_nregs)\n-    return;\n-\n-  cselib_nregs = nregs;\n-  VARRAY_GROW (reg_values, nregs);\n-  VARRAY_GROW (used_regs, nregs);\n-}\n-\n-/* Initialize cselib for one pass.  The caller must also call\n-   init_alias_analysis.  */\n-\n-void\n-cselib_init ()\n-{\n-  /* These are only created once.  */\n-  if (! callmem)\n-    {\n-      gcc_obstack_init (&cselib_obstack);\n-      cselib_startobj = obstack_alloc (&cselib_obstack, 0);\n-\n-      callmem = gen_rtx_MEM (BLKmode, const0_rtx);\n-      ggc_add_rtx_root (&callmem, 1);\n-    }\n-\n-  cselib_nregs = max_reg_num ();\n-  VARRAY_ELT_LIST_INIT (reg_values, cselib_nregs, \"reg_values\");\n-  VARRAY_UINT_INIT (used_regs, cselib_nregs, \"used_regs\");\n-  hash_table = htab_create (31, get_value_hash, entry_and_rtx_equal_p, NULL);\n-  clear_table (1);\n-}\n-\n-/* Called when the current user is done with cselib.  */\n-\n-void\n-cselib_finish ()\n-{\n-  clear_table (0);\n-  VARRAY_FREE (reg_values);\n-  VARRAY_FREE (used_regs);\n-  htab_delete (hash_table);\n-}"}]}