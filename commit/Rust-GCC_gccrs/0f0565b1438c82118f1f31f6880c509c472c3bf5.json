{"sha": "0f0565b1438c82118f1f31f6880c509c472c3bf5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGYwNTY1YjE0MzhjODIxMThmMWYzMWY2ODgwYzUwOWM0NzJjM2JmNQ==", "commit": {"author": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2016-10-01T14:00:57Z"}, "committer": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2016-10-01T14:00:57Z"}, "message": "re PR libfortran/77663 (libgfortran/caf/single.c: three minor problems and a lost token)\n\ngcc/testsuite/ChangeLog:\n\n2016-10-01  Andre Vehreschild  <vehre@gcc.gnu.org>\n\n\tPR fortran/77663\n\t* gfortran.dg/coarray_send_by_ref_1.f08: New test.\n\nlibgfortran/ChangeLog:\n\n2016-10-01  Andre Vehreschild  <vehre@gcc.gnu.org>\n\n\tPR fortran/77663\n\t* caf/single.c (caf_internal_error): Fix not terminating va-list.\n\t(_gfortran_caf_register): Free memory also when other allocs failed.\n\t(_gfortran_caf_get_by_ref): Fixed style.\n\t(send_by_ref): Token is now stored at the correct position preventing\n\tinaccessible tokens, memory loss and possibly crashes.\n\nFrom-SVN: r240695", "tree": {"sha": "eff176f1e251fa98b5827cd362cc3acbcca23c7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eff176f1e251fa98b5827cd362cc3acbcca23c7a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f0565b1438c82118f1f31f6880c509c472c3bf5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f0565b1438c82118f1f31f6880c509c472c3bf5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f0565b1438c82118f1f31f6880c509c472c3bf5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f0565b1438c82118f1f31f6880c509c472c3bf5/comments", "author": null, "committer": null, "parents": [{"sha": "eb647b80ba1a0ab2d9b879cbfdd08cd6805e75c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb647b80ba1a0ab2d9b879cbfdd08cd6805e75c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb647b80ba1a0ab2d9b879cbfdd08cd6805e75c3"}], "stats": {"total": 66, "additions": 57, "deletions": 9}, "files": [{"sha": "feb787754c7cb29b288edc2ea963c15b5cba2f51", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f0565b1438c82118f1f31f6880c509c472c3bf5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f0565b1438c82118f1f31f6880c509c472c3bf5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0f0565b1438c82118f1f31f6880c509c472c3bf5", "patch": "@@ -1,3 +1,8 @@\n+2016-10-01  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\tPR fortran/77663\n+\t* gfortran.dg/coarray_send_by_ref_1.f08: New test.\n+\n 2016-10-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c/77490"}, {"sha": "73f91e03993e3c59cc5255ccf3df66dd3e888b32", "filename": "gcc/testsuite/gfortran.dg/coarray_send_by_ref_1.f08", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f0565b1438c82118f1f31f6880c509c472c3bf5/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_send_by_ref_1.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f0565b1438c82118f1f31f6880c509c472c3bf5/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_send_by_ref_1.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_send_by_ref_1.f08?ref=0f0565b1438c82118f1f31f6880c509c472c3bf5", "patch": "@@ -0,0 +1,29 @@\n+! { dg-do run }\n+! { dg-options \"-fcoarray=lib -lcaf_single\" }\n+\n+program check_caf_send_by_ref\n+\n+  implicit none\n+\n+  type T\n+    integer, allocatable :: scal\n+    integer, allocatable :: array(:)\n+  end type T\n+\n+  type(T), save :: obj[*]\n+  integer :: me, np, i\n+\n+  me = this_image()\n+  np = num_images()\n+\n+  obj[np]%scal = 42\n+\n+  ! Check the token for the scalar is set.\n+  if (obj[np]%scal /= 42) call abort()\n+\n+  ! Now the same for arrays.\n+  obj[np]%array = [(i * np + me, i = 1, 15)]\n+  if (any(obj[np]%array /= [(i * np + me, i = 1, 15)])) call abort()\n+\n+end program check_caf_send_by_ref\n+"}, {"sha": "5430ed188509ffc2ed5574f78f475b53d13fd20b", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f0565b1438c82118f1f31f6880c509c472c3bf5/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f0565b1438c82118f1f31f6880c509c472c3bf5/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=0f0565b1438c82118f1f31f6880c509c472c3bf5", "patch": "@@ -1,3 +1,12 @@\n+2016-10-01  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\tPR fortran/77663\n+\t* caf/single.c (caf_internal_error): Fix not terminating va-list.\n+\t(_gfortran_caf_register): Free memory also when other allocs failed.\n+\t(_gfortran_caf_get_by_ref): Fixed style.\n+\t(send_by_ref): Token is now stored at the correct position preventing\n+\tinaccessible tokens, memory loss and possibly crashes.\n+\n 2016-09-28  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/77707"}, {"sha": "00b71208473819b4567639eddfa7cb55d372e942", "filename": "libgfortran/caf/single.c", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f0565b1438c82118f1f31f6880c509c472c3bf5/libgfortran%2Fcaf%2Fsingle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f0565b1438c82118f1f31f6880c509c472c3bf5/libgfortran%2Fcaf%2Fsingle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fcaf%2Fsingle.c?ref=0f0565b1438c82118f1f31f6880c509c472c3bf5", "patch": "@@ -87,6 +87,7 @@ caf_internal_error (const char *msg, int *stat, char *errmsg,\n \t  if ((size_t)errmsg_len > len)\n \t    memset (&errmsg[len], ' ', errmsg_len - len);\n \t}\n+      va_end (args);\n       return;\n     }\n   else\n@@ -149,6 +150,13 @@ _gfortran_caf_register (size_t size, caf_register_t type, caf_token_t *token,\n \n   if (unlikely (local == NULL || *token == NULL))\n     {\n+      /* Freeing the memory conditionally seems pointless, but\n+\t caf_internal_error () may return, when a stat is given and then the\n+\t memory may be lost.  */\n+      if (local)\n+\tfree (local);\n+      if (*token)\n+\tfree (*token);\n       caf_internal_error (alloc_fail_msg, stat, errmsg, errmsg_len);\n       return;\n     }\n@@ -1465,7 +1473,7 @@ _gfortran_caf_get_by_ref (caf_token_t token,\n   bool array_extent_fixed = false;\n   realloc_needed = realloc_required = GFC_DESCRIPTOR_DATA (dst) == NULL;\n \n-  assert (!realloc_needed || (realloc_needed && dst_reallocatable));\n+  assert (!realloc_needed || dst_reallocatable);\n \n   if (stat)\n     *stat = 0;\n@@ -1909,14 +1917,14 @@ send_by_ref (caf_reference_t *ref, size_t *i, size_t *src_index,\n \t\t  GFC_DESCRIPTOR_DATA (&static_dst) = NULL;\n \t\t  GFC_DESCRIPTOR_DTYPE (&static_dst)\n \t\t      = GFC_DESCRIPTOR_DTYPE (src);\n-\t\t  /* The component may be allocated now, because it is a\n+\t\t  /* The component can be allocated now, because it is a\n \t\t     scalar.  */\n-\t\t  single_token = *(caf_single_token_t*)\n-\t\t\t\t\t       (ds + ref->u.c.caf_token_offset);\n \t\t  _gfortran_caf_register (ref->item_size,\n \t\t\t\t\t  CAF_REGTYPE_COARRAY_ALLOC,\n-\t\t\t\t\t  (caf_token_t *)&single_token,\n+\t\t\t\t\t  ds + ref->u.c.caf_token_offset,\n \t\t\t\t\t  &static_dst, stat, NULL, 0);\n+\t\t  single_token = *(caf_single_token_t *)\n+\t\t\t\t\t       (ds + ref->u.c.caf_token_offset);\n \t\t  /* In case of an error in allocation return.  When stat is\n \t\t     NULL, then register_component() terminates on error.  */\n \t\t  if (stat != NULL && *stat)\n@@ -2005,15 +2013,12 @@ send_by_ref (caf_reference_t *ref, size_t *i, size_t *src_index,\n \t      /* The size of the array is given by size.  */\n \t      _gfortran_caf_register (size * ref->item_size,\n \t\t\t\t      CAF_REGTYPE_COARRAY_ALLOC,\n-\t\t\t\t      (void **)&single_token,\n+\t\t\t\t      ds + ref->u.c.caf_token_offset,\n \t\t\t\t      dst, stat, NULL, 0);\n \t      /* In case of an error in allocation return.  When stat is\n \t\t NULL, then register_component() terminates on error.  */\n \t      if (stat != NULL && *stat)\n \t\treturn;\n-\t      /* The memptr, descriptor and the token are set below.  */\n-\t      *(caf_single_token_t *)(ds + ref->u.c.caf_token_offset)\n-\t\t  = single_token;\n \t    }\n \t  single_token = *(caf_single_token_t*)(ds + ref->u.c.caf_token_offset);\n \t  send_by_ref (ref->next, i, src_index, single_token,"}]}