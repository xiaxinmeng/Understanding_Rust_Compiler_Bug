{"sha": "95539f21f508d6d928d9888be2a5984a684a3288", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTU1MzlmMjFmNTA4ZDZkOTI4ZDk4ODhiZTJhNTk4NGE2ODRhMzI4OA==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2014-05-21T19:51:05Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2014-05-21T19:51:05Z"}, "message": "re PR libstdc++/61143 (Arithmetic exception on emplacing into unordered_map moved out)\n\n2014-05-21  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\n\tPR libstdc++/61143\n\t* include/bits/hashtable.h: Fix move semantic to leave hashtable in a\n\tusable state.\n\t* testsuite/23_containers/unordered_set/61143.cc: New.\n\t* testsuite/23_containers/unordered_set/modifiers/swap.cc: New.\n\nFrom-SVN: r210726", "tree": {"sha": "da97a8e92cd69f84cf796558e5813462fef6f6fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da97a8e92cd69f84cf796558e5813462fef6f6fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95539f21f508d6d928d9888be2a5984a684a3288", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95539f21f508d6d928d9888be2a5984a684a3288", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95539f21f508d6d928d9888be2a5984a684a3288", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95539f21f508d6d928d9888be2a5984a684a3288/comments", "author": null, "committer": null, "parents": [{"sha": "9652331a6ba454d402b1df6317d65ab56c1dff5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9652331a6ba454d402b1df6317d65ab56c1dff5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9652331a6ba454d402b1df6317d65ab56c1dff5d"}], "stats": {"total": 257, "additions": 210, "deletions": 47}, "files": [{"sha": "b53dfb457a8b684c67b41428d008f9832e942bdc", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95539f21f508d6d928d9888be2a5984a684a3288/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95539f21f508d6d928d9888be2a5984a684a3288/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=95539f21f508d6d928d9888be2a5984a684a3288", "patch": "@@ -1,3 +1,11 @@\n+2014-05-21  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\n+\tPR libstdc++/61143\n+\t* include/bits/hashtable.h: Fix move semantic to leave hashtable in a\n+\tusable state.\n+\t* testsuite/23_containers/unordered_set/61143.cc: New.\n+\t* testsuite/23_containers/unordered_set/modifiers/swap.cc: New.\n+\n 2014-05-21  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/61269"}, {"sha": "9b6394c4e49965f22a317fd565f584742ff8eb97", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 99, "deletions": 47, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95539f21f508d6d928d9888be2a5984a684a3288/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95539f21f508d6d928d9888be2a5984a684a3288/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=95539f21f508d6d928d9888be2a5984a684a3288", "patch": "@@ -316,14 +316,49 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       size_type\t\t\t_M_element_count;\n       _RehashPolicy\t\t_M_rehash_policy;\n \n+      // A single bucket used when only need for 1 bucket. Especially\n+      // interesting in move semantic to leave hashtable with only 1 buckets\n+      // which is not allocated so that we can have those operations noexcept\n+      // qualified.\n+      // Note that we can't leave hashtable with 0 bucket without adding\n+      // numerous checks in the code to avoid 0 modulus.\n+      __bucket_type\t\t_M_single_bucket;\n+\n+      bool\n+      _M_uses_single_bucket(__bucket_type* __bkts) const\n+      { return __builtin_expect(_M_buckets == &_M_single_bucket, false); }\n+\n+      bool\n+      _M_uses_single_bucket() const\n+      { return _M_uses_single_bucket(_M_buckets); }\n+\n       __hashtable_alloc&\n       _M_base_alloc() { return *this; }\n \n-      using __hashtable_alloc::_M_deallocate_buckets;\n+      __bucket_type*\n+      _M_allocate_buckets(size_type __n)\n+      {\n+\tif (__builtin_expect(__n == 1, false))\n+\t  {\n+\t    _M_single_bucket = nullptr;\n+\t    return &_M_single_bucket;\n+\t  }\n+\n+\treturn __hashtable_alloc::_M_allocate_buckets(__n);\n+      }\n+\n+      void\n+      _M_deallocate_buckets(__bucket_type* __bkts, size_type __n)\n+      {\n+\tif (_M_uses_single_bucket(__bkts))\n+\t  return;\n+\n+\t__hashtable_alloc::_M_deallocate_buckets(__bkts, __n);\n+      }\n \n       void\n       _M_deallocate_buckets()\n-      { this->_M_deallocate_buckets(_M_buckets, _M_bucket_count); }\n+      { _M_deallocate_buckets(_M_buckets, _M_bucket_count); }\n \n       // Gets bucket begin, deals with the fact that non-empty buckets contain\n       // their before begin node.\n@@ -703,11 +738,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       size_type\n       erase(const key_type& __k)\n-      {\n-\tif (__builtin_expect(_M_bucket_count == 0, false))\n-\t  return 0;\n-\treturn _M_erase(__unique_keys(), __k);\n-      }\n+      { return _M_erase(__unique_keys(), __k); }\n \n       iterator\n       erase(const_iterator, const_iterator);\n@@ -768,7 +799,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_rehash_policy()\n     {\n       _M_bucket_count = _M_rehash_policy._M_next_bkt(__bucket_hint);\n-      _M_buckets = this->_M_allocate_buckets(_M_bucket_count);\n+      _M_buckets = _M_allocate_buckets(_M_bucket_count);\n     }\n \n   template<typename _Key, typename _Value,\n@@ -796,7 +827,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    std::max(_M_rehash_policy._M_bkt_for_elements(__nb_elems),\n \t\t     __bucket_hint));\n \n-\t_M_buckets = this->_M_allocate_buckets(_M_bucket_count);\n+\t_M_buckets = _M_allocate_buckets(_M_bucket_count);\n \t__try\n \t  {\n \t    for (; __f != __l; ++__f)\n@@ -833,9 +864,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t      {\n \t\t// Replacement allocator cannot free existing storage.\n \t\tthis->_M_deallocate_nodes(_M_begin());\n-\t\tif (__builtin_expect(_M_bucket_count != 0, true))\n-\t\t  _M_deallocate_buckets();\n-\t\t_M_reset();\n+\t\t_M_before_begin._M_nxt = nullptr;\n+\t\t_M_deallocate_buckets();\n+\t\t_M_buckets = nullptr;\n \t\tstd::__alloc_on_copy(__this_alloc, __that_alloc);\n \t\t__hashtable_base::operator=(__ht);\n \t\t_M_bucket_count = __ht._M_bucket_count;\n@@ -867,7 +898,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tif (_M_bucket_count != __ht._M_bucket_count)\n \t  {\n \t    __former_buckets = _M_buckets;\n-\t    _M_buckets = this->_M_allocate_buckets(__ht._M_bucket_count);\n+\t    _M_buckets = _M_allocate_buckets(__ht._M_bucket_count);\n \t    _M_bucket_count = __ht._M_bucket_count;\n \t  }\n \telse\n@@ -885,8 +916,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t      [&__roan](const __node_type* __n)\n \t\t      { return __roan(__n->_M_v()); });\n \t    if (__former_buckets)\n-\t      this->_M_deallocate_buckets(__former_buckets,\n-\t\t\t\t\t  __former_bucket_count);\n+\t      _M_deallocate_buckets(__former_buckets, __former_bucket_count);\n \t  }\n \t__catch(...)\n \t  {\n@@ -917,7 +947,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       {\n \t__bucket_type* __buckets = nullptr;\n \tif (!_M_buckets)\n-\t  _M_buckets = __buckets = this->_M_allocate_buckets(_M_bucket_count);\n+\t  _M_buckets = __buckets = _M_allocate_buckets(_M_bucket_count);\n \n \t__try\n \t  {\n@@ -964,8 +994,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _M_reset() noexcept\n     {\n       _M_rehash_policy._M_reset();\n-      _M_bucket_count = 0;\n-      _M_buckets = nullptr;\n+      _M_bucket_count = 1;\n+      _M_single_bucket = nullptr;\n+      _M_buckets = &_M_single_bucket;\n       _M_before_begin._M_nxt = nullptr;\n       _M_element_count = 0;\n     }\n@@ -980,12 +1011,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _M_move_assign(_Hashtable&& __ht, std::true_type)\n     {\n       this->_M_deallocate_nodes(_M_begin());\n-      if (__builtin_expect(_M_bucket_count != 0, true))\n-\t_M_deallocate_buckets();\n-\n+      _M_deallocate_buckets();\n       __hashtable_base::operator=(std::move(__ht));\n       _M_rehash_policy = __ht._M_rehash_policy;\n-      _M_buckets = __ht._M_buckets;\n+      if (!__ht._M_uses_single_bucket())\n+\t_M_buckets = __ht._M_buckets;\n+      else\n+\t{\n+\t  _M_buckets = &_M_single_bucket;\n+\t  _M_single_bucket = __ht._M_single_bucket;\n+\t}\n       _M_bucket_count = __ht._M_bucket_count;\n       _M_before_begin._M_nxt = __ht._M_before_begin._M_nxt;\n       _M_element_count = __ht._M_element_count;\n@@ -1019,7 +1054,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  if (_M_bucket_count != __ht._M_bucket_count)\n \t    {\n \t      __former_buckets = _M_buckets;\n-\t      _M_buckets = this->_M_allocate_buckets(__ht._M_bucket_count);\n+\t      _M_buckets = _M_allocate_buckets(__ht._M_bucket_count);\n \t      _M_bucket_count = __ht._M_bucket_count;\n \t    }\n \t  else\n@@ -1093,10 +1128,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_element_count(__ht._M_element_count),\n       _M_rehash_policy(__ht._M_rehash_policy)\n     {\n+      // Update, if necessary, buckets if __ht is using its single bucket.\n+      if (__ht._M_uses_single_bucket())\n+\t{\n+\t  _M_buckets = &_M_single_bucket;\n+\t  _M_single_bucket = __ht._M_single_bucket;\n+\t}\n+\n       // Update, if necessary, bucket pointing to before begin that hasn't\n       // moved.\n       if (_M_begin())\n \t_M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;\n+\n       __ht._M_reset();\n     }\n \n@@ -1139,7 +1182,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       if (__ht._M_node_allocator() == this->_M_node_allocator())\n \t{\n-\t  _M_buckets = __ht._M_buckets;\n+\t  if (__ht._M_uses_single_bucket())\n+\t    {\n+\t      _M_buckets = &_M_single_bucket;\n+\t      _M_single_bucket = __ht._M_single_bucket;\n+\t    }\n+\t  else\n+\t    _M_buckets = __ht._M_buckets;\n+\n \t  _M_before_begin._M_nxt = __ht._M_before_begin._M_nxt;\n \t  // Update, if necessary, bucket pointing to before begin that hasn't\n \t  // moved.\n@@ -1189,15 +1239,34 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       std::__alloc_on_swap(this->_M_node_allocator(), __x._M_node_allocator());\n       std::swap(_M_rehash_policy, __x._M_rehash_policy);\n-      std::swap(_M_buckets, __x._M_buckets);\n+\n+      // Deal properly with potentially moved instances.\n+      if (this->_M_uses_single_bucket())\n+\t{\n+\t  if (!__x._M_uses_single_bucket())\n+\t    {\n+\t      _M_buckets = __x._M_buckets;\n+\t      __x._M_buckets = &__x._M_single_bucket;\n+\t    }\n+\t}\n+      else if (__x._M_uses_single_bucket())\n+\t{\n+\t  __x._M_buckets = _M_buckets;\n+\t  _M_buckets = &_M_single_bucket;\n+\t}\t\n+      else\n+\tstd::swap(_M_buckets, __x._M_buckets);\n+\n       std::swap(_M_bucket_count, __x._M_bucket_count);\n       std::swap(_M_before_begin._M_nxt, __x._M_before_begin._M_nxt);\n       std::swap(_M_element_count, __x._M_element_count);\n+      std::swap(_M_single_bucket, __x._M_single_bucket);\n \n       // Fix buckets containing the _M_before_begin pointers that can't be\n       // swapped.\n       if (_M_begin())\n \t_M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;\n+\n       if (__x._M_begin())\n \t__x._M_buckets[__x._M_bucket_index(__x._M_begin())]\n \t  = &__x._M_before_begin;\n@@ -1230,9 +1299,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     find(const key_type& __k)\n     {\n-      if (__builtin_expect(_M_bucket_count == 0, false))\n-\treturn end();\n-\n       __hash_code __code = this->_M_hash_code(__k);\n       std::size_t __n = _M_bucket_index(__k, __code);\n       __node_type* __p = _M_find_node(__n, __k, __code);\n@@ -1250,9 +1316,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     find(const key_type& __k) const\n     {\n-      if (__builtin_expect(_M_bucket_count == 0, false))\n-\treturn end();\n-      \n       __hash_code __code = this->_M_hash_code(__k);\n       std::size_t __n = _M_bucket_index(__k, __code);\n       __node_type* __p = _M_find_node(__n, __k, __code);\n@@ -1270,9 +1333,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     count(const key_type& __k) const\n     {\n-      if (__builtin_expect(_M_bucket_count == 0, false))\n-\treturn 0;\n-\n       __hash_code __code = this->_M_hash_code(__k);\n       std::size_t __n = _M_bucket_index(__k, __code);\n       __node_type* __p = _M_bucket_begin(__n);\n@@ -1287,7 +1347,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  else if (__result)\n \t    // All equivalent values are next to each other, if we\n \t    // found a non-equivalent value after an equivalent one it\n-\t    // means that we won't find any more equivalent values.\n+\t    // means that we won't find any new equivalent value.\n \t    break;\n \t  if (!__p->_M_nxt || _M_bucket_index(__p->_M_next()) != __n)\n \t    break;\n@@ -1311,9 +1371,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     equal_range(const key_type& __k)\n     {\n-      if (__builtin_expect(_M_bucket_count == 0, false))\n-\treturn std::make_pair(end(), end());\n-\n       __hash_code __code = this->_M_hash_code(__k);\n       std::size_t __n = _M_bucket_index(__k, __code);\n       __node_type* __p = _M_find_node(__n, __k, __code);\n@@ -1347,9 +1404,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     equal_range(const key_type& __k) const\n     {\n-      if (__builtin_expect(_M_bucket_count == 0, false))\n-\treturn std::make_pair(end(), end());\n-\t\n       __hash_code __code = this->_M_hash_code(__k);\n       std::size_t __n = _M_bucket_index(__k, __code);\n       __node_type* __p = _M_find_node(__n, __k, __code);\n@@ -1944,7 +1998,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     _M_rehash_aux(size_type __n, std::true_type)\n     {\n-      __bucket_type* __new_buckets = this->_M_allocate_buckets(__n);\n+      __bucket_type* __new_buckets = _M_allocate_buckets(__n);\n       __node_type* __p = _M_begin();\n       _M_before_begin._M_nxt = nullptr;\n       std::size_t __bbegin_bkt = 0;\n@@ -1969,8 +2023,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  __p = __next;\n \t}\n \n-      if (__builtin_expect(_M_bucket_count != 0, true))\n-\t_M_deallocate_buckets();\n+      _M_deallocate_buckets();\n       _M_bucket_count = __n;\n       _M_buckets = __new_buckets;\n     }\n@@ -1986,7 +2039,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     _M_rehash_aux(size_type __n, std::false_type)\n     {\n-      __bucket_type* __new_buckets = this->_M_allocate_buckets(__n);\n+      __bucket_type* __new_buckets = _M_allocate_buckets(__n);\n \n       __node_type* __p = _M_begin();\n       _M_before_begin._M_nxt = nullptr;\n@@ -2060,8 +2113,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    __new_buckets[__next_bkt] = __prev_p;\n \t}\n \n-      if (__builtin_expect(_M_bucket_count != 0, true))\n-\t_M_deallocate_buckets();\n+      _M_deallocate_buckets();\n       _M_bucket_count = __n;\n       _M_buckets = __new_buckets;\n     }"}, {"sha": "b9464254f12e224f70faac7d97e92ba14fffe9d2", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/61143.cc", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95539f21f508d6d928d9888be2a5984a684a3288/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2F61143.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95539f21f508d6d928d9888be2a5984a684a3288/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2F61143.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2F61143.cc?ref=95539f21f508d6d928d9888be2a5984a684a3288", "patch": "@@ -0,0 +1,38 @@\n+// { dg-options \"-std=gnu++11\" }\n+\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// libstdc++/61143\n+\n+#include <unordered_set>\n+\n+void test01()\n+{\n+  std::unordered_set<int> us1, us2;\n+  us1.insert(1);\n+\n+  us2 = std::move(us1);\n+\n+  us1.insert(1);\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "d03fd1dc3b16326d0d13707a9551aaa364b05a82", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/modifiers/swap.cc", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95539f21f508d6d928d9888be2a5984a684a3288/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fmodifiers%2Fswap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95539f21f508d6d928d9888be2a5984a684a3288/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fmodifiers%2Fswap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fmodifiers%2Fswap.cc?ref=95539f21f508d6d928d9888be2a5984a684a3288", "patch": "@@ -0,0 +1,65 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <unordered_set>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  std::unordered_set<int> us1 { 0, 1 };\n+  {\n+    std::unordered_set<int> us2(std::move(us1));\n+\n+    us1.swap(us2);\n+\n+    VERIFY( us1.find(0) != us1.end() );\n+\n+    us1.insert(2);\n+\n+    VERIFY( us1.size() == 3 );\n+\n+    us2.swap(us1);\n+\n+    VERIFY( us2.size() == 3 );\n+    VERIFY( us2.find(2) != us2.end() );\n+\n+    us1 = { 3, 4, 5 };\n+\n+    VERIFY( us1.size() == 3 );\n+    VERIFY( us1.bucket_count() >= 3 );\n+\n+    std::unordered_set<int> us3(std::move(us1));\n+    us3 = std::move(us2);\n+\n+    us1.swap(us2);\n+\n+    VERIFY( us1.empty() );\n+    VERIFY( us2.empty() );\n+  }\n+\n+  us1 = { 0, 1 };\n+  VERIFY( us1.size() == 2 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}]}