{"sha": "ff485e71cf8f300fc80c6e8c9ca0b0fd0c3590ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmY0ODVlNzFjZjhmMzAwZmM4MGM2ZThjOWNhMGIwZmQwYzM1OTBjYQ==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2006-06-26T21:10:22Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2006-06-26T21:10:22Z"}, "message": "[multiple changes]\n\n2006-06-26  DJ Delorie  <dj@redhat.com>\n\n\t* config/m32c/m32c.c (m32c_print_operand): Fix sign-merging logic.\n\n2006-06-26  Naveen H.S  <naveenh@kpitcummins.com>\n\t    Jayant Sonar  <jayants@kpitcummins.com>\n\t    Jaydeep Vipradas  <jaydeepv@kpitcummins.com>\n\n\t* config/m32c/addsub.md (addsi3, addsi3_1, addsi3_2): New.\n\t(subsi3, subsi3_1, subsi3_2): New.\n\t* config/m32c/bitops.md (andsi3, iorsi3, xorsi3): New.\n\t* config/m32c/mov.md (SI mov peephole): New.\n\t* config/m32c/m32.c (m32c_immd_dbl_mov): New.\n\t* config/m32c/m32c-protos.h (m32c_immd_dbl_mov): New.\n\nFrom-SVN: r115023", "tree": {"sha": "b6ce301684ee79ed60fcdfb68b5e1526c7ecba3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6ce301684ee79ed60fcdfb68b5e1526c7ecba3f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff485e71cf8f300fc80c6e8c9ca0b0fd0c3590ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff485e71cf8f300fc80c6e8c9ca0b0fd0c3590ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff485e71cf8f300fc80c6e8c9ca0b0fd0c3590ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff485e71cf8f300fc80c6e8c9ca0b0fd0c3590ca/comments", "author": null, "committer": null, "parents": [{"sha": "500c353d7290b4a91a66fd5cd009048b6b387984", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/500c353d7290b4a91a66fd5cd009048b6b387984", "html_url": "https://github.com/Rust-GCC/gccrs/commit/500c353d7290b4a91a66fd5cd009048b6b387984"}], "stats": {"total": 318, "additions": 312, "deletions": 6}, "files": [{"sha": "6066846ef8f290f0aa277c96f2823d08c5cc659d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff485e71cf8f300fc80c6e8c9ca0b0fd0c3590ca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff485e71cf8f300fc80c6e8c9ca0b0fd0c3590ca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ff485e71cf8f300fc80c6e8c9ca0b0fd0c3590ca", "patch": "@@ -1,3 +1,18 @@\n+2006-06-26  DJ Delorie  <dj@redhat.com>\n+\n+\t* config/m32c/m32c.c (m32c_print_operand): Fix sign-merging logic.\n+\n+2006-06-26  Naveen H.S  <naveenh@kpitcummins.com>\n+\t    Jayant Sonar  <jayants@kpitcummins.com>\n+\t    Jaydeep Vipradas  <jaydeepv@kpitcummins.com>\n+\n+\t* config/m32c/addsub.md (addsi3, addsi3_1, addsi3_2): New.\n+\t(subsi3, subsi3_1, subsi3_2): New.\n+\t* config/m32c/bitops.md (andsi3, iorsi3, xorsi3): New.\n+\t* config/m32c/mov.md (SI mov peephole): New.\n+\t* config/m32c/m32.c (m32c_immd_dbl_mov): New.\n+\t* config/m32c/m32c-protos.h (m32c_immd_dbl_mov): New.\n+\t\n 2006-06-26  Olivier Hainque  <hainque@adacore.com>\n \n \t* function.c (aggregate_value_p): Honor DECL_BY_REFERENCE on"}, {"sha": "45bd3cd366436fb1e2b51a8aa3576be3bce9600b", "filename": "gcc/config/m32c/addsub.md", "status": "modified", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff485e71cf8f300fc80c6e8c9ca0b0fd0c3590ca/gcc%2Fconfig%2Fm32c%2Faddsub.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff485e71cf8f300fc80c6e8c9ca0b0fd0c3590ca/gcc%2Fconfig%2Fm32c%2Faddsub.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Faddsub.md?ref=ff485e71cf8f300fc80c6e8c9ca0b0fd0c3590ca", "patch": "@@ -72,6 +72,56 @@\n   [(set_attr \"flags\" \"oszc,oszc,oszc,oszc,oszc,n,n\")]\n   )\n \n+(define_expand \"addsi3\"\n+  [(set (match_operand:SI 0 \"mra_operand\" \"=RsiSd,RsiSd,??Rmm,??Rmm\")\n+        (plus:SI (match_operand:SI 1 \"mra_operand\" \"%0,0,0,0\")\n+                 (match_operand:SI 2 \"mrai_operand\" \"iRsiSd,?Rmm,iRsiSd,?Rmm\")))]\n+  \"TARGET_A24 ||TARGET_A16\"\n+  \"\"\n+  )\n+\n+(define_insn \"addsi3_1\"\n+  [(set (match_operand:SI 0 \"mra_operand\" \"=RsiSd,??Rmm,RsiSd,RsiSd,??Rmm,??Rmm,??Rmm,RsiSd\")\n+        (plus:SI (match_operand:SI 1 \"mra_operand\" \"%0,0,0,0,0,0,0,0\")\n+                 (match_operand 2 \"mrai_operand\" \"IU2,IU2,i,?Rmm,i,RsiSd,?Rmm,RsiSd\")))]\n+  \"TARGET_A16\"\n+  \"*\n+  \n+  switch (which_alternative)\n+    { \n+    case 0:\n+      return \\\"add.w %X2,%h0\\;adcf.w %H0\\\";\n+    case 1:\n+      return \\\"add.w %X2,%h0\\;adcf.w %H0\\\";\n+    case 2:\n+      output_asm_insn (\\\"add.w %X2,%h0\\\",operands);\n+      operands[2]= GEN_INT (INTVAL (operands[2]) >> 16);\n+      return \\\"adc.w %X2,%H0\\\";\n+    case 3:\n+      return \\\"add.w %h2,%h0\\;adc.w %H2,%H0\\\";\n+    case 4:\n+      output_asm_insn (\\\"add.w %X2,%h0\\\",operands);\n+      operands[2]= GEN_INT (INTVAL (operands[2]) >> 16);\n+      return \\\"adc.w %X2,%H0\\\";\n+    case 5:\n+      return \\\"add.w %h2,%h0\\;adc.w %H2,%H0\\\";\n+    case 6:\n+      return \\\"add.w %h2,%h0\\;adc.w %H2,%H0\\\";\n+    case 7:\n+      return \\\"add.w %h2,%h0\\;adc.w %H2,%H0\\\";\n+    }\"\n+  [(set_attr \"flags\" \"x,x,x,x,x,x,x,x\")]\n+)\n+\n+(define_insn \"addsi3_2\"\n+  [(set (match_operand:SI 0 \"mra_operand\" \"=RsiSd,RsiSd,??Rmm,??Rmm\")\n+        (plus:SI (match_operand:SI 1 \"mra_operand\" \"%0,0,0,0\")\n+                 (match_operand:SI 2 \"mrai_operand\" \"iRsiSd,?Rmm,iRsiSd,?Rmm\")))]\n+  \"TARGET_A24\"\n+  \"add.l\\t%2,%0\"\n+  [(set_attr \"flags\" \"oszc\")]\n+)\n+\n (define_insn \"subqi3\"\n   [(set (match_operand:QI 0 \"mra_or_sp_operand\"\n \t\t   \"=SdRhl,SdRhl,??Rmm,??Rmm, Raa,Raa,SdRhl,??Rmm, *Rsp\")\n@@ -111,6 +161,51 @@\n   [(set_attr \"flags\" \"oszc\")]\n   )\n \n+(define_expand \"subsi3\"\n+  [(set (match_operand:SI 0 \"mra_operand\" \"=RsiSd,RsiSd,??Rmm,??Rmm\")\n+        (minus:SI (match_operand:SI 1 \"mra_operand\" \"0,0,0,0\")\n+                  (match_operand:SI 2 \"mrai_operand\" \"iRsiSd,?Rmm,iRsiSd,?Rmm\")))]\n+  \"TARGET_A24 ||TARGET_A16\"\n+  \"\"\n+)\n+\n+(define_insn \"subsi3_1\"\n+  [(set (match_operand:SI 0 \"mra_operand\" \"=RsiSd,RsiSd,??Rmm,??Rmm,??Rmm,RsiSd\")\n+        (minus:SI (match_operand:SI 1 \"mra_operand\" \"0,0,0,0,0,0\")\n+                  (match_operand:SI 2 \"mrai_operand\" \"i,?Rmm,i,RsiSd,?Rmm,RsiSd\")))]\n+  \"TARGET_A16\"\n+  \"*\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      output_asm_insn (\\\"sub.w %X2,%h0\\\",operands);\n+      operands[2]= GEN_INT (INTVAL (operands[2]) >> 16);\n+      return \\\"sbb.w %X2,%H0\\\";\n+    case 1:\n+      return \\\"sub.w %h2,%h0\\;sbb.w %H2,%H0\\\";\n+    case 2:\n+      output_asm_insn (\\\"sub.w %X2,%h0\\\",operands);\n+      operands[2]= GEN_INT (INTVAL (operands[2]) >> 16);\n+      return \\\"sbb.w %X2,%H0\\\";\n+    case 3:\n+      return \\\"sub.w %h2,%h0\\;sbb.w %H2,%H0\\\";\n+    case 4:\n+      return \\\"sub.w %h2,%h0\\;sbb.w %H2,%H0\\\";\n+    case 5:\n+      return \\\"sub.w %h2,%h0\\;sbb.w %H2,%H0\\\";\n+    }\"\n+  [(set_attr \"flags\" \"x,x,x,x,x,x\")]\n+)\n+\n+(define_insn \"subsi3_2\"\n+  [(set (match_operand:SI 0 \"mra_operand\" \"=RsiSd,RsiSd,??Rmm,??Rmm\")\n+        (minus:SI (match_operand:SI 1 \"mra_operand\" \"0,0,0,0\")\n+                  (match_operand:SI 2 \"mrai_operand\" \"iRsiSd,?Rmm,iRsiSd,?Rmm\")))]\n+  \"TARGET_A24\"\n+  \"sub.l\\t%2,%0\"\n+  [(set_attr \"flags\" \"oszc,oszc,oszc,oszc\")]\n+)\n+\n (define_insn \"negqi2\"\n   [(set (match_operand:QI 0 \"mra_operand\" \"=SdRhl,??Rmm\")\n \t(neg:QI (match_operand:QI 1 \"mra_operand\" \"0,0\")))]"}, {"sha": "87322d386292a6f24e83b0da26b30029031d0356", "filename": "gcc/config/m32c/bitops.md", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff485e71cf8f300fc80c6e8c9ca0b0fd0c3590ca/gcc%2Fconfig%2Fm32c%2Fbitops.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff485e71cf8f300fc80c6e8c9ca0b0fd0c3590ca/gcc%2Fconfig%2Fm32c%2Fbitops.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fbitops.md?ref=ff485e71cf8f300fc80c6e8c9ca0b0fd0c3590ca", "patch": "@@ -113,6 +113,33 @@\n   [(set_attr \"flags\" \"n,n,n,sz,sz,sz,sz\")]\n   )\n \n+(define_insn \"andsi3\"\n+  [(set (match_operand:SI 0 \"mra_operand\" \"=RsiSd,RsiSd,??Rmm,??Rmm,??Rmm,RsiSd\")\n+        (and:SI (match_operand:SI 1 \"mra_operand\" \"%0,0,0,0,0,0\")\n+                (match_operand:SI 2 \"mrai_operand\" \"i,?Rmm,i,RsiSd,?Rmm,RsiSd\")))]\n+  \"\"\n+  \"*\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      output_asm_insn (\\\"and.w %X2,%h0\\\",operands);\n+      operands[2]= GEN_INT (INTVAL (operands[2]) >> 16);\n+      return \\\"and.w %X2,%H0\\\";\n+    case 1:\n+      return \\\"and.w %h2,%h0\\;and.w %H2,%H0\\\";\n+    case 2:\n+      output_asm_insn (\\\"and.w %X2,%h0\\\",operands);\n+      operands[2]= GEN_INT (INTVAL (operands[2]) >> 16);\n+      return \\\"and.w %X2,%H0\\\";\n+    case 3:\n+      return \\\"and.w %h2,%h0\\;and.w %H2,%H0\\\";\n+    case 4:\n+      return \\\"and.w %h2,%h0\\;and.w %H2,%H0\\\";\n+    case 5:\n+      return \\\"and.w %h2,%h0\\;and.w %H2,%H0\\\";\n+    }\"\n+  [(set_attr \"flags\" \"x,x,x,x,x,x\")]\n+)\n \n \n (define_insn \"iorqi3_16\"\n@@ -264,6 +291,34 @@\n    DONE;\"\n   )\n \n+(define_insn \"iorsi3\"\n+  [(set (match_operand:SI 0 \"mra_operand\" \"=RsiSd,RsiSd,??Rmm,??Rmm,??Rmm,RsiSd\")\n+        (ior:SI (match_operand:SI 1 \"mra_operand\" \"%0,0,0,0,0,0\")\n+                (match_operand:SI 2 \"mrai_operand\" \"i,?Rmm,i,RsiSd,?Rmm,RsiSd\")))]\n+  \"\"\n+  \"*\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      output_asm_insn (\\\"or.w %X2,%h0\\\",operands);\n+      operands[2]= GEN_INT (INTVAL (operands[2]) >> 16);\n+      return \\\"or.w %X2,%H0\\\";\n+    case 1:\n+      return \\\"or.w %h2,%h0\\;or.w %H2,%H0\\\";\n+    case 2:\n+      output_asm_insn (\\\"or.w %X2,%h0\\\",operands);\n+      operands[2]= GEN_INT (INTVAL (operands[2]) >> 16);\n+      return \\\"or.w %X2,%H0\\\";\n+    case 3:\n+      return \\\"or.w %h2,%h0\\;or.w %H2,%H0\\\";\n+    case 4:\n+      return \\\"or.w %h2,%h0\\;or.w %H2,%H0\\\";\n+    case 5:\n+      return \\\"or.w %h2,%h0\\;or.w %H2,%H0\\\";\n+    }\"\n+  [(set_attr \"flags\" \"x,x,x,x,x,x\")]\n+)\n+\n (define_insn \"xorqi3\"\n   [(set (match_operand:QI 0 \"mra_operand\" \"=RhlSd,RhlSd,??Rmm,??Rmm\")\n \t(xor:QI (match_operand:QI 1 \"mra_operand\" \"%0,0,0,0\")\n@@ -282,6 +337,34 @@\n   [(set_attr \"flags\" \"sz,sz,sz,sz\")]\n   )\n \n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI 0 \"mra_operand\" \"=RsiSd,RsiSd,??Rmm,??Rmm,??Rmm,RsiSd\")\n+        (xor:SI (match_operand:SI 1 \"mra_operand\" \"%0,0,0,0,0,0\")\n+                (match_operand:SI 2 \"mrai_operand\" \"i,?Rmm,i,RsiSd,?Rmm,RsiSd\")))]\n+  \"\"\n+  \"*\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      output_asm_insn (\\\"xor.w %X2,%h0\\\",operands);\n+      operands[2]= GEN_INT (INTVAL (operands[2]) >> 16);\n+      return \\\"xor.w %X2,%H0\\\";\n+    case 1:\n+      return \\\"xor.w %h2,%h0\\;xor.w %H2,%H0\\\";\n+    case 2:\n+      output_asm_insn (\\\"xor.w %X2,%h0\\\",operands);\n+      operands[2]= GEN_INT (INTVAL (operands[2]) >> 16);\n+      return \\\"xor.w %X2,%H0\\\";\n+    case 3:\n+      return \\\"xor.w %h2,%h0\\;xor.w %H2,%H0\\\";\n+    case 4:\n+      return \\\"xor.w %h2,%h0\\;xor.w %H2,%H0\\\";\n+    case 5:\n+      return \\\"xor.w %h2,%h0\\;xor.w %H2,%H0\\\";\n+    }\"\n+  [(set_attr \"flags\" \"x,x,x,x,x,x\")]\n+)\n+\n (define_insn \"one_cmplqi2\"\n   [(set (match_operand:QI 0 \"mra_operand\" \"=RhlSd,??Rmm\")\n \t(not:QI (match_operand:QI 1 \"mra_operand\" \"0,0\")))]"}, {"sha": "6979da278a24e480b3bdd62d3e17090144c1028b", "filename": "gcc/config/m32c/m32c-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff485e71cf8f300fc80c6e8c9ca0b0fd0c3590ca/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff485e71cf8f300fc80c6e8c9ca0b0fd0c3590ca/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h?ref=ff485e71cf8f300fc80c6e8c9ca0b0fd0c3590ca", "patch": "@@ -72,6 +72,7 @@ int  m32c_extra_constraint_p (rtx, char, const char *);\n int  m32c_extra_constraint_p2 (rtx, char, const char *);\n int  m32c_hard_regno_nregs (int, MM);\n int  m32c_hard_regno_ok (int, MM);\n+bool m32c_immd_dbl_mov (rtx *, MM);\n rtx  m32c_incoming_return_addr_rtx (void);\n void m32c_initialize_trampoline (rtx, rtx, rtx);\n int  m32c_legitimate_address_p (MM, rtx, int);"}, {"sha": "4c2219e23d803d2ebaf8c91ea39ff1a5a7181665", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 107, "deletions": 6, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff485e71cf8f300fc80c6e8c9ca0b0fd0c3590ca/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff485e71cf8f300fc80c6e8c9ca0b0fd0c3590ca/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=ff485e71cf8f300fc80c6e8c9ca0b0fd0c3590ca", "patch": "@@ -2301,6 +2301,7 @@ m32c_print_operand (FILE * file, rtx x, int code)\n   const char *comma;\n   HOST_WIDE_INT ival;\n   int unsigned_const = 0;\n+  int force_sign;\n \n   /* Multiplies; constants are converted to sign-extended format but\n    we need unsigned, so 'u' and 'U' tell us what size unsigned we\n@@ -2463,6 +2464,7 @@ m32c_print_operand (FILE * file, rtx x, int code)\n     code = 0;\n \n   encode_pattern (x);\n+  force_sign = 0;\n   for (i = 0; conversions[i].pattern; i++)\n     if (conversions[i].code == code\n \t&& streq (conversions[i].pattern, pattern))\n@@ -2576,6 +2578,8 @@ m32c_print_operand (FILE * file, rtx x, int code)\n \t\t\t  /* Integers used as addresses are unsigned.  */\n \t\t\t  ival &= (TARGET_A24 ? 0xffffff : 0xffff);\n \t\t\t}\n+\t\t      if (force_sign && ival >= 0)\n+\t\t\tfputc ('+', file);\n \t\t      fprintf (file, HOST_WIDE_INT_PRINT_DEC, ival);\n \t\t      break;\n \t\t    }\n@@ -2620,13 +2624,14 @@ m32c_print_operand (FILE * file, rtx x, int code)\n \t      /* Signed displacements off symbols need to have signs\n \t\t blended cleanly.  */\n \t      if (conversions[i].format[j] == '+'\n-\t\t  && (!code || code == 'I')\n+\t\t  && (!code || code == 'D' || code == 'd')\n \t\t  && ISDIGIT (conversions[i].format[j + 1])\n-\t\t  && GET_CODE (patternr[conversions[i].format[j + 1] - '0'])\n-\t\t  == CONST_INT\n-\t\t  && INTVAL (patternr[conversions[i].format[j + 1] - '0']) <\n-\t\t  0)\n-\t\tcontinue;\n+\t\t  && (GET_CODE (patternr[conversions[i].format[j + 1] - '0'])\n+\t\t      == CONST_INT))\n+\t\t{\n+\t\t  force_sign = 1;\n+\t\t  continue;\n+\t\t}\n \t      fputc (conversions[i].format[j], file);\n \t    }\n \tbreak;\n@@ -2787,6 +2792,102 @@ m32c_mov_ok (rtx * operands, enum machine_mode mode ATTRIBUTE_UNUSED)\n   return true;\n }\n \n+/* Returns TRUE if two consecutive HImode mov instructions, generated\n+   for moving an immediate double data to a double data type variable\n+   location, can be combined into single SImode mov instruction.  */\n+bool\n+m32c_immd_dbl_mov (rtx * operands, \n+\t\t   enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  int flag = 0, okflag = 0, offset1 = 0, offset2 = 0, offsetsign = 0;\n+  const char *str1;\n+  const char *str2;\n+\n+  if (GET_CODE (XEXP (operands[0], 0)) == SYMBOL_REF\n+      && MEM_SCALAR_P (operands[0])\n+      && !MEM_IN_STRUCT_P (operands[0])\n+      && GET_CODE (XEXP (operands[2], 0)) == CONST\n+      && GET_CODE (XEXP (XEXP (operands[2], 0), 0)) == PLUS\n+      && GET_CODE (XEXP (XEXP (XEXP (operands[2], 0), 0), 0)) == SYMBOL_REF\n+      && GET_CODE (XEXP (XEXP (XEXP (operands[2], 0), 0), 1)) == CONST_INT\n+      && MEM_SCALAR_P (operands[2])\n+      && !MEM_IN_STRUCT_P (operands[2]))\n+    flag = 1; \n+\n+  else if (GET_CODE (XEXP (operands[0], 0)) == CONST\n+           && GET_CODE (XEXP (XEXP (operands[0], 0), 0)) == PLUS\n+           && GET_CODE (XEXP (XEXP (XEXP (operands[0], 0), 0), 0)) == SYMBOL_REF\n+           && MEM_SCALAR_P (operands[0])\n+           && !MEM_IN_STRUCT_P (operands[0])\n+           && !(XINT (XEXP (XEXP (XEXP (operands[0], 0), 0), 1), 0) %4)\n+           && GET_CODE (XEXP (operands[2], 0)) == CONST\n+           && GET_CODE (XEXP (XEXP (operands[2], 0), 0)) == PLUS\n+           && GET_CODE (XEXP (XEXP (XEXP (operands[2], 0), 0), 0)) == SYMBOL_REF\n+           && MEM_SCALAR_P (operands[2])\n+           && !MEM_IN_STRUCT_P (operands[2]))\n+    flag = 2; \n+\n+  else if (GET_CODE (XEXP (operands[0], 0)) == PLUS\n+           &&  GET_CODE (XEXP (XEXP (operands[0], 0), 0)) == REG\n+           &&  REGNO (XEXP (XEXP (operands[0], 0), 0)) == FB_REGNO \n+           &&  GET_CODE (XEXP (XEXP (operands[0], 0), 1)) == CONST_INT\n+           &&  MEM_SCALAR_P (operands[0])\n+           &&  !MEM_IN_STRUCT_P (operands[0])\n+           &&  !(XINT (XEXP (XEXP (operands[0], 0), 1), 0) %4)\n+           &&  REGNO (XEXP (XEXP (operands[2], 0), 0)) == FB_REGNO \n+           &&  GET_CODE (XEXP (XEXP (operands[2], 0), 1)) == CONST_INT\n+           &&  MEM_SCALAR_P (operands[2])\n+           &&  !MEM_IN_STRUCT_P (operands[2]))\n+    flag = 3; \n+\n+  else\n+    return false;\n+\n+  switch (flag)\n+    {\n+    case 1:\n+      str1 = XSTR (XEXP (operands[0], 0), 0);\n+      str2 = XSTR (XEXP (XEXP (XEXP (operands[2], 0), 0), 0), 0);\n+      if (strcmp (str1, str2) == 0)\n+\tokflag = 1; \n+      else\n+\tokflag = 0; \n+      break;\n+    case 2:\n+      str1 = XSTR (XEXP (XEXP (XEXP (operands[0], 0), 0), 0), 0);\n+      str2 = XSTR (XEXP (XEXP (XEXP (operands[2], 0), 0), 0), 0);\n+      if (strcmp(str1,str2) == 0)\n+\tokflag = 1; \n+      else\n+\tokflag = 0; \n+      break; \n+    case 3:\n+      offset1 = XINT (XEXP (XEXP (operands[0], 0), 1), 0);\n+      offset2 = XINT (XEXP (XEXP (operands[2], 0), 1), 0);\n+      offsetsign = offset1 >> ((sizeof (offset1) * 8) -1);\n+      if (((offset2-offset1) == 2) && offsetsign != 0)\n+\tokflag = 1;\n+      else \n+\tokflag = 0; \n+      break; \n+    default:\n+      okflag = 0; \n+    } \n+      \n+  if (okflag == 1)\n+    {\n+      HOST_WIDE_INT val;\n+      operands[4] = gen_rtx_MEM (SImode, XEXP (operands[0], 0));\n+\n+      val = (XINT (operands[3], 0) << 16) + (XINT (operands[1], 0) & 0xFFFF);\n+      operands[5] = gen_rtx_CONST_INT (VOIDmode, val);\n+     \n+      return true;\n+    }\n+\n+  return false;\n+}  \n+\n /* Expanders */\n \n /* Subregs are non-orthogonal for us, because our registers are all"}, {"sha": "fde98d3723c625f09996e13acc985da25e20b906", "filename": "gcc/config/m32c/mov.md", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff485e71cf8f300fc80c6e8c9ca0b0fd0c3590ca/gcc%2Fconfig%2Fm32c%2Fmov.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff485e71cf8f300fc80c6e8c9ca0b0fd0c3590ca/gcc%2Fconfig%2Fm32c%2Fmov.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fmov.md?ref=ff485e71cf8f300fc80c6e8c9ca0b0fd0c3590ca", "patch": "@@ -135,6 +135,17 @@\n \t(match_dup 3))]\n   \"\")\n \n+; Peephole to generate SImode mov instructions for storing an\n+; immediate double data to a memory location.\n+(define_peephole2\n+  [(set (match_operand:HI 0 \"memory_operand\" \"\")\n+        (match_operand 1 \"const_int_operand\" \"\"))\n+   (set (match_operand:HI 2 \"memory_operand\" \"\")\n+        (match_operand 3 \"const_int_operand\" \"\"))]\n+   \"TARGET_A24 && m32c_immd_dbl_mov (operands, HImode)\"\n+   [(set (match_dup 4) (match_dup 5))]\n+   \"\"\n+)\n \n ; Some PSI moves must be split.\n (define_split"}]}