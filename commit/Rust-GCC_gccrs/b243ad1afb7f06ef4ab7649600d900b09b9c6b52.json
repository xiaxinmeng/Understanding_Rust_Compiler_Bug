{"sha": "b243ad1afb7f06ef4ab7649600d900b09b9c6b52", "node_id": "C_kwDOANBUbNoAKGIyNDNhZDFhZmI3ZjA2ZWY0YWI3NjQ5NjAwZDkwMGIwOWI5YzZiNTI", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2022-03-29T15:07:09Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2022-03-29T16:38:31Z"}, "message": "aarch64: correctly handle zero-sized bit-fields in AAPCS64 [PR102024]\n\nOn aarch64 the AAPCS64 states that an HFA is determined by the 'shape' of\nthe object after layout has been completed, so anything that adds no\nmembers and does not cause the layout to be modified should be ignored\nfor the purposes of determining which registers are used for parameter\npassing.\n\nA zero-sized bit-field falls into this category.  This was not handled\ncorrectly for C structs and in G++-11 only handled correctly because\nsuch fields were eliminated early by the front end.\n\ngcc/ChangeLog:\n\n\tPR target/102024\n\t* config/aarch64/aarch64.cc (aapcs_vfp_sub_candidate): Handle\n\tzero-sized bit-fields.  Detect cases where a warning may be needed.\n\t(aarch64_vfp_is_call_or_return_candidate): Emit a note if a\n\tzero-sized bit-field has caused parameter passing to change.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/aarch64/aapcs64/test_28.c: New test.", "tree": {"sha": "70d566a410efb5f74d8f8d83f68f0b2361d08415", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70d566a410efb5f74d8f8d83f68f0b2361d08415"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b243ad1afb7f06ef4ab7649600d900b09b9c6b52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b243ad1afb7f06ef4ab7649600d900b09b9c6b52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b243ad1afb7f06ef4ab7649600d900b09b9c6b52", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b243ad1afb7f06ef4ab7649600d900b09b9c6b52/comments", "author": null, "committer": null, "parents": [{"sha": "3032df28f2a1cc6514571558b76d9b80373b19c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3032df28f2a1cc6514571558b76d9b80373b19c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3032df28f2a1cc6514571558b76d9b80373b19c6"}], "stats": {"total": 63, "additions": 60, "deletions": 3}, "files": [{"sha": "ab78b11b1585ebdf429bf68a1d1c1f9328ac71e5", "filename": "gcc/config/aarch64/aarch64.cc", "status": "modified", "additions": 32, "deletions": 3, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b243ad1afb7f06ef4ab7649600d900b09b9c6b52/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b243ad1afb7f06ef4ab7649600d900b09b9c6b52/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.cc?ref=b243ad1afb7f06ef4ab7649600d900b09b9c6b52", "patch": "@@ -19917,6 +19917,7 @@ aarch64_member_type_forces_blk (const_tree field_or_array, machine_mode mode)\n       a HFA or HVA.  */\n const unsigned int WARN_PSABI_EMPTY_CXX17_BASE = 1U << 0;\n const unsigned int WARN_PSABI_NO_UNIQUE_ADDRESS = 1U << 1;\n+const unsigned int WARN_PSABI_ZERO_WIDTH_BITFIELD = 1U << 2;\n \n /* Walk down the type tree of TYPE counting consecutive base elements.\n    If *MODEP is VOIDmode, then set it to the first valid floating point\n@@ -20073,6 +20074,28 @@ aapcs_vfp_sub_candidate (const_tree type, machine_mode *modep,\n \t\t    continue;\n \t\t  }\n \t      }\n+\t    /* A zero-width bitfield may affect layout in some\n+\t       circumstances, but adds no members.  The determination\n+\t       of whether or not a type is an HFA is performed after\n+\t       layout is complete, so if the type still looks like an\n+\t       HFA afterwards, it is still classed as one.  This is\n+\t       potentially an ABI break for the hard-float ABI.  */\n+\t    else if (DECL_BIT_FIELD (field)\n+\t\t     && integer_zerop (DECL_SIZE (field)))\n+\t      {\n+\t\t/* Prior to GCC-12 these fields were striped early,\n+\t\t   hiding them from the back-end entirely and\n+\t\t   resulting in the correct behaviour for argument\n+\t\t   passing.  Simulate that old behaviour without\n+\t\t   generating a warning.  */\n+\t\tif (DECL_FIELD_CXX_ZERO_WIDTH_BIT_FIELD (field))\n+\t\t  continue;\n+\t\tif (warn_psabi_flags)\n+\t\t  {\n+\t\t    *warn_psabi_flags |= WARN_PSABI_ZERO_WIDTH_BITFIELD;\n+\t\t    continue;\n+\t\t  }\n+\t      }\n \n \t    sub_count = aapcs_vfp_sub_candidate (TREE_TYPE (field), modep,\n \t\t\t\t\t\t warn_psabi_flags);\n@@ -20273,8 +20296,10 @@ aarch64_vfp_is_call_or_return_candidate (machine_mode mode,\n \t      && ((alt = aapcs_vfp_sub_candidate (type, &new_mode, NULL))\n \t\t  != ag_count))\n \t    {\n-\t      const char *url\n+\t      const char *url10\n \t\t= CHANGES_ROOT_URL \"gcc-10/changes.html#empty_base\";\n+\t      const char *url12\n+\t\t= CHANGES_ROOT_URL \"gcc-12/changes.html#zero_width_bitfields\";\n \t      gcc_assert (alt == -1);\n \t      last_reported_type_uid = uid;\n \t      /* Use TYPE_MAIN_VARIANT to strip any redundant const\n@@ -20283,12 +20308,16 @@ aarch64_vfp_is_call_or_return_candidate (machine_mode mode,\n \t\tinform (input_location, \"parameter passing for argument of \"\n \t\t\t\"type %qT with %<[[no_unique_address]]%> members \"\n \t\t\t\"changed %{in GCC 10.1%}\",\n-\t\t\tTYPE_MAIN_VARIANT (type), url);\n+\t\t\tTYPE_MAIN_VARIANT (type), url10);\n \t      else if (warn_psabi_flags & WARN_PSABI_EMPTY_CXX17_BASE)\n \t\tinform (input_location, \"parameter passing for argument of \"\n \t\t\t\"type %qT when C++17 is enabled changed to match \"\n \t\t\t\"C++14 %{in GCC 10.1%}\",\n-\t\t\tTYPE_MAIN_VARIANT (type), url);\n+\t\t\tTYPE_MAIN_VARIANT (type), url10);\n+\t      else if (warn_psabi_flags & WARN_PSABI_ZERO_WIDTH_BITFIELD)\n+\t\tinform (input_location, \"parameter passing for argument of \"\n+\t\t\t\"type %qT changed %{in GCC 12.1%}\",\n+\t\t\tTYPE_MAIN_VARIANT (type), url12);\n \t    }\n \n \t  if (is_ha != NULL) *is_ha = true;"}, {"sha": "951057b35098a4c291c9939bacacfa7566e374c8", "filename": "gcc/testsuite/gcc.target/aarch64/aapcs64/test_28.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b243ad1afb7f06ef4ab7649600d900b09b9c6b52/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Faapcs64%2Ftest_28.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b243ad1afb7f06ef4ab7649600d900b09b9c6b52/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Faapcs64%2Ftest_28.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Faapcs64%2Ftest_28.c?ref=b243ad1afb7f06ef4ab7649600d900b09b9c6b52", "patch": "@@ -0,0 +1,28 @@\n+/* Test AAPCS64 layout for HFA with zero-sized bit-field.  */\n+\n+/* { dg-do run { target aarch64*-*-* } } */\n+\n+#ifndef IN_FRAMEWORK\n+#define VFP\n+#define TESTFILE \"test_28.c\"\n+\n+/* Anonymous bitfields do not add members; if they do not change the layout\n+   then the end result may still be an HFA.  */\n+struct z\n+{\n+  float a;\n+  int :0;\n+  float b;\n+};\n+\n+struct z a = { 5.0f, 6.0f };\n+struct z b = { 9.0f, 10.0f };\n+\n+#define MYFUNCTYPE struct z\n+\n+#include \"abitest.h\"\n+#else\n+  ARG(int, 7, W0)\n+  ARG(struct z, a, S0)\n+  LAST_ARG(struct z, b, S2)\n+#endif"}]}