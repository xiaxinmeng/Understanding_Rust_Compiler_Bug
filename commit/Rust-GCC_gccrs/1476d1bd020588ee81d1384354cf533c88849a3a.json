{"sha": "1476d1bd020588ee81d1384354cf533c88849a3a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQ3NmQxYmQwMjA1ODhlZTgxZDEzODQzNTRjZjUzM2M4ODg0OWEzYQ==", "commit": {"author": {"name": "Mikhail Maltsev", "email": "maltsevm@gmail.com", "date": "2015-05-20T19:39:42Z"}, "committer": {"name": "Mikhail Maltsev", "email": "miyuki@gcc.gnu.org", "date": "2015-05-20T19:39:42Z"}, "message": "Promote types of RTL expressions to more derived ones.\n\n\t* bb-reorder.c (set_edge_can_fallthru_flag): Use rtx_jump_insn where\n\tfeasible.\n\t(fix_up_fall_thru_edges): Likewise.\n\t(fix_crossing_conditional_branches): Likewise. Promote jump targets\n\tfrom to rtx_insn to rtx_code_label where feasible.\n\t* bt-load.c (move_btr_def): Remove as-a cast of the value returned by\n\tgen_move_insn (returned type changed to rtx_insn).\n\t* builtins.c (expand_errno_check): Fix arguments of\n\tdo_compare_rtx_and_jump (now expects rtx_code_label).\n\t(expand_builtin_acc_on_device): Likewise.\n\t* cfgcleanup.c (try_simplify_condjump): Add cast when calling\n\tinvert_jump (now exprects rtx_jump_insn).\n\t* cfgexpand.c (label_rtx_for_bb): Promote return type to rtx_code_label.\n\t(construct_init_block): Use rtx_code_label.\n\t* cfgrtl.c (block_label): Promote return type to rtx_code_label.\n\t(try_redirect_by_replacing_jump): Use cast to rtx_jump_insn when\n\tcalling redirect_jump.\n\t(patch_jump_insn): Likewise.\n\t(redirect_branch_edge): Likewise.\n\t(force_nonfallthru_and_redirect): Likewise.\n\t(fixup_reorder_chain): Explicitly use rtx_jump_insn instead of rtx_insn\n\twhen suitable.\n\t(rtl_lv_add_condition_to_bb): Update call of do_compare_rtx_and_jump.\n\t* cfgrtl.h: Promote return type of block_label to rtx_code_label.\n\t* config/bfin/bfin.c (hwloop_optimize): Fix call of emit_label_before.\n\t* config/i386/i386.c (ix86_emit_cmove): Explicitly use rtx_code_label\n\tto store the value retured by gen_label_rtx.\n\t* config/mips/mips.c (mips16_split_long_branches): Promote rtx_insn to\n\trtx_jump_insn.\n\t* config/sh/sh.c (gen_far_branch): Likewise. Fix call of invert_jump.\n\t(split_branches): Fix calls of redirect_jump.\n\t* dojump.c (jumpifnot): Promote argument type from rtx to rtx_code_label.\n\t(jumpifnot_1): Likewise.\n\t(jumpif): Likewise.\n\t(jumpif_1): Likewise.\n\t(do_jump_1): Likewise.\n\t(do_jump): Likewise. Use rtx_code_label when feasible.\n\t(do_jump_by_parts_greater_rtx): Likewise.\n\t(do_jump_by_parts_zero_rtx): Likewise.\n\t(do_jump_by_parts_equality_rtx): Likewise.\n\t(do_compare_rtx_and_jump): Likewise.\n\t* dojump.h: Update function prototypes.\n\t* dse.c (emit_inc_dec_insn_before): Remove case (gen_move_insn now\n\treturns rtx_insn).\n\t* emit-rtl.c (emit_jump_insn_before_noloc): Promote return type to\n\trtx_jump_insn.\n\t(emit_label_before): Likewise.\n\t(emit_jump_insn_after_noloc): Likewise.\n\t(emit_jump_insn_after_setloc): Likewise.\n\t(emit_jump_insn_after): Likewise\n\t(emit_jump_insn_before_setloc): Likewise.\n\t(emit_jump_insn_before): Likewise.\n\t(emit_label_before): Promote return type to rtx_code_label.\n\t(emit_label): Likewise.\n\t* except.c (sjlj_emit_dispatch_table): Use jump_target_rtx.\n\t* explow.c (emit_stack_save): Use gen_move_insn_uncast instead of\n\tgen_move_insn.\n\t(emit_stack_restore): Likewise.\n\t* expmed.c (emit_store_flag_force): Fix calls of do_compare_rtx_and_jump.\n\t(do_cmp_and_jump): Likewise.\n\t* expr.c (expand_expr_real_2): Likewise. Promote some local variables\n\tfrom rtx to rtx_code_label.\n\t(gen_move_insn_uncast): New function.\n\t* expr.h: Update return type of gen_move_insn (promote to rtx_insn).\n\t* function.c (convert_jumps_to_returns): Fix call of redirect_jump.\n\t* gcse.c (pre_insert_copy_insn): Use rtx_insn instead of rtx.\n\t* ifcvt.c (dead_or_predicable): Use rtx_jump_insn when calling\n\tinvert_jump_1 and redirect_jump_1.\n\t* internal-fn.c (expand_arith_overflow_result_store): Fix call of\n\tdo_compare_rtx_and_jump.\n\t(expand_addsub_overflow): Likewise.\n\t(expand_neg_overflow): Likewise.\n\t(expand_mul_overflow): Likewise.\n\t* ira.c (split_live_ranges_for_shrink_wrap): Use rtx_insn for\n\treturn value of gen_move_insn.\n\t* jump.c (redirect_jump): Promote argument from rtx to rtx_jump_insn.\n\t* loop-doloop.c (add_test): Use rtx_code_label.\n\t(doloop_modify): Likewise.\n\t(doloop_optimize): Likewise.\n\t* loop-unroll.c (compare_and_jump_seq): Promote rtx to rtx_code_label.\n\t* lra-constraints.c (emit_spill_move): Remove cast of value returned\n\tby gen_move_insn.\n\t(inherit_reload_reg): Add cast when calling dump_insn_slim.\n\t(split_reg): Likewise.\n\t* modulo-sched.c (schedule_reg_moves): Remove cast of value returned by\n\tgen_move_insn.\n\t* optabs.c (expand_binop_directly): Remove casts of values returned by\n\tmaybe_gen_insn.\n\t(expand_unop_direct): Likewise.\n\t(expand_abs): Likewise.\n\t(maybe_emit_unop_insn): Likewise.\n\t(maybe_gen_insn): Promote return type to rtx_insn.\n\t* optabs.h: Update prototype of maybe_gen_insn.\n\t* postreload-gcse.c (eliminate_partially_redundant_load): Remove\n\tredundant cast.\n\t* recog.c (struct peep2_insn_data): Promote type of insn field to\n\trtx_insn.\n\t(peep2_reinit_state): Use NULL instead of NULL_RTX.\n\t(peep2_attempt): Remove casts of insn in peep2_insn_data.\n\t(peep2_fill_buffer): Promote argument from rtx to rtx_insn\n\t* recog.h (struct insn_gen_fn): Promote return types of function\n\tpointers and operator ().from rtx to rtx_insn.\n\t* reorg.c (fill_simple_delay_slots): Promote rtx_insn to rtx_jump_insn.\n\t(fill_eager_delay_slots): Likewise.\n\t(relax_delay_slots): Likewise.\n\t(make_return_insns): Likewise.\n\t(dbr_schedule): Likewise.\n\t(optimize_skips): Likewise.\n\t(reorg_redirect_jump): Likewise.\n\t(fill_slots_from_thread): Likewise.\n\t* reorg.h: Update prototypes.\n\t* resource.c (find_dead_or_set_registers): Use dyn_cast to\n\trtx_jump_insn instead of check.  Use it's jump_target method.\n\t* rtl.h (rtx_jump_insn::jump_label): Define new method.\n\t(rtx_jump_insn::jump_target): Define new method.\n\t(rtx_jump_insn::set_jump_target): Define new method.\n\t* rtlanal.c (tablejump_p): Promote type of one local variable.\n\t* sched-deps.c (sched_analyze_2): Promote rtx to rtx_insn_list.\n\t(sched_analyze_insn): Likewise.\n\t* sched-vis.c (print_insn_with_notes): Promote rtx to rtx_insn.\n\t(print_insn): Likewise.\n\t* stmt.c (label_rtx): Promote return type to rtx_insn.\n\t(force_label_rtx): Likewise.\n\t(jump_target_rtx): Define new function.\n\t(expand_label): Use it, get rid of one cast.\n\t(expand_naked_return): Promote rtx to rtx_code_label.\n\t(do_jump_if_equal): Fix do_compare_rtx_and_jump call.\n\t(expand_case): Use rtx_code_label instread of rtx where feasible.\n\t(expand_sjlj_dispatch_table): Likewise.\n\t(emit_case_nodes): Likewise.\n\t* stmt.h: Declare jump_target_rtx.  Update prototypes.  Fix comments.\n\t* store-motion.c (insert_store): Make use of new return type of\n\tgen_move_insn and remove a cast.\n\t(replace_store_insn): Likewise.\n\nFrom-SVN: r223454", "tree": {"sha": "710f2e790c32c989e13feab254c623d98b5f103d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/710f2e790c32c989e13feab254c623d98b5f103d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1476d1bd020588ee81d1384354cf533c88849a3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1476d1bd020588ee81d1384354cf533c88849a3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1476d1bd020588ee81d1384354cf533c88849a3a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1476d1bd020588ee81d1384354cf533c88849a3a/comments", "author": {"login": "miyuki", "id": 4668268, "node_id": "MDQ6VXNlcjQ2NjgyNjg=", "avatar_url": "https://avatars.githubusercontent.com/u/4668268?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miyuki", "html_url": "https://github.com/miyuki", "followers_url": "https://api.github.com/users/miyuki/followers", "following_url": "https://api.github.com/users/miyuki/following{/other_user}", "gists_url": "https://api.github.com/users/miyuki/gists{/gist_id}", "starred_url": "https://api.github.com/users/miyuki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miyuki/subscriptions", "organizations_url": "https://api.github.com/users/miyuki/orgs", "repos_url": "https://api.github.com/users/miyuki/repos", "events_url": "https://api.github.com/users/miyuki/events{/privacy}", "received_events_url": "https://api.github.com/users/miyuki/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fd2ef1171407340dbb09935ab535debf40f56376", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd2ef1171407340dbb09935ab535debf40f56376", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd2ef1171407340dbb09935ab535debf40f56376"}], "stats": {"total": 1325, "additions": 795, "deletions": 530}, "files": [{"sha": "5bcbcb49d418cf92584a618d908f763ee06463cb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -1,3 +1,140 @@\n+2015-05-20  Mikhail Maltsev  <maltsevm@gmail.com>\n+\n+\t* bb-reorder.c (set_edge_can_fallthru_flag): Use rtx_jump_insn where\n+\tfeasible.\n+\t(fix_up_fall_thru_edges): Likewise.\n+\t(fix_crossing_conditional_branches): Likewise. Promote jump targets\n+\tfrom to rtx_insn to rtx_code_label where feasible.\n+\t* bt-load.c (move_btr_def): Remove as-a cast of the value returned by\n+\tgen_move_insn (returned type changed to rtx_insn).\n+\t* builtins.c (expand_errno_check): Fix arguments of\n+\tdo_compare_rtx_and_jump (now expects rtx_code_label).\n+\t(expand_builtin_acc_on_device): Likewise.\n+\t* cfgcleanup.c (try_simplify_condjump): Add cast when calling\n+\tinvert_jump (now exprects rtx_jump_insn).\n+\t* cfgexpand.c (label_rtx_for_bb): Promote return type to rtx_code_label.\n+\t(construct_init_block): Use rtx_code_label.\n+\t* cfgrtl.c (block_label): Promote return type to rtx_code_label.\n+\t(try_redirect_by_replacing_jump): Use cast to rtx_jump_insn when\n+\tcalling redirect_jump.\n+\t(patch_jump_insn): Likewise.\n+\t(redirect_branch_edge): Likewise.\n+\t(force_nonfallthru_and_redirect): Likewise.\n+\t(fixup_reorder_chain): Explicitly use rtx_jump_insn instead of rtx_insn\n+\twhen suitable.\n+\t(rtl_lv_add_condition_to_bb): Update call of do_compare_rtx_and_jump.\n+\t* cfgrtl.h: Promote return type of block_label to rtx_code_label.\n+\t* config/bfin/bfin.c (hwloop_optimize): Fix call of emit_label_before.\n+\t* config/i386/i386.c (ix86_emit_cmove): Explicitly use rtx_code_label\n+\tto store the value retured by gen_label_rtx.\n+\t* config/mips/mips.c (mips16_split_long_branches): Promote rtx_insn to\n+\trtx_jump_insn.\n+\t* config/sh/sh.c (gen_far_branch): Likewise. Fix call of invert_jump.\n+\t(split_branches): Fix calls of redirect_jump.\n+\t* dojump.c (jumpifnot): Promote argument type from rtx to rtx_code_label.\n+\t(jumpifnot_1): Likewise.\n+\t(jumpif): Likewise.\n+\t(jumpif_1): Likewise.\n+\t(do_jump_1): Likewise.\n+\t(do_jump): Likewise. Use rtx_code_label when feasible.\n+\t(do_jump_by_parts_greater_rtx): Likewise.\n+\t(do_jump_by_parts_zero_rtx): Likewise.\n+\t(do_jump_by_parts_equality_rtx): Likewise.\n+\t(do_compare_rtx_and_jump): Likewise.\n+\t* dojump.h: Update function prototypes.\n+\t* dse.c (emit_inc_dec_insn_before): Remove case (gen_move_insn now\n+\treturns rtx_insn).\n+\t* emit-rtl.c (emit_jump_insn_before_noloc): Promote return type to\n+\trtx_jump_insn.\n+\t(emit_label_before): Likewise.\n+\t(emit_jump_insn_after_noloc): Likewise.\n+\t(emit_jump_insn_after_setloc): Likewise.\n+\t(emit_jump_insn_after): Likewise\n+\t(emit_jump_insn_before_setloc): Likewise.\n+\t(emit_jump_insn_before): Likewise.\n+\t(emit_label_before): Promote return type to rtx_code_label.\n+\t(emit_label): Likewise.\n+\t* except.c (sjlj_emit_dispatch_table): Use jump_target_rtx.\n+\t* explow.c (emit_stack_save): Use gen_move_insn_uncast instead of\n+\tgen_move_insn.\n+\t(emit_stack_restore): Likewise.\n+\t* expmed.c (emit_store_flag_force): Fix calls of do_compare_rtx_and_jump.\n+\t(do_cmp_and_jump): Likewise.\n+\t* expr.c (expand_expr_real_2): Likewise. Promote some local variables\n+\tfrom rtx to rtx_code_label.\n+\t(gen_move_insn_uncast): New function.\n+\t* expr.h: Update return type of gen_move_insn (promote to rtx_insn).\n+\t* function.c (convert_jumps_to_returns): Fix call of redirect_jump.\n+\t* gcse.c (pre_insert_copy_insn): Use rtx_insn instead of rtx.\n+\t* ifcvt.c (dead_or_predicable): Use rtx_jump_insn when calling\n+\tinvert_jump_1 and redirect_jump_1.\n+\t* internal-fn.c (expand_arith_overflow_result_store): Fix call of\n+\tdo_compare_rtx_and_jump.\n+\t(expand_addsub_overflow): Likewise.\n+\t(expand_neg_overflow): Likewise.\n+\t(expand_mul_overflow): Likewise.\n+\t* ira.c (split_live_ranges_for_shrink_wrap): Use rtx_insn for\n+\treturn value of gen_move_insn.\n+\t* jump.c (redirect_jump): Promote argument from rtx to rtx_jump_insn.\n+\t* loop-doloop.c (add_test): Use rtx_code_label.\n+\t(doloop_modify): Likewise.\n+\t(doloop_optimize): Likewise.\n+\t* loop-unroll.c (compare_and_jump_seq): Promote rtx to rtx_code_label.\n+\t* lra-constraints.c (emit_spill_move): Remove cast of value returned\n+\tby gen_move_insn.\n+\t(inherit_reload_reg): Add cast when calling dump_insn_slim.\n+\t(split_reg): Likewise.\n+\t* modulo-sched.c (schedule_reg_moves): Remove cast of value returned by\n+\tgen_move_insn.\n+\t* optabs.c (expand_binop_directly): Remove casts of values returned by\n+\tmaybe_gen_insn.\n+\t(expand_unop_direct): Likewise.\n+\t(expand_abs): Likewise.\n+\t(maybe_emit_unop_insn): Likewise.\n+\t(maybe_gen_insn): Promote return type to rtx_insn.\n+\t* optabs.h: Update prototype of maybe_gen_insn.\n+\t* postreload-gcse.c (eliminate_partially_redundant_load): Remove\n+\tredundant cast.\n+\t* recog.c (struct peep2_insn_data): Promote type of insn field to\n+\trtx_insn.\n+\t(peep2_reinit_state): Use NULL instead of NULL_RTX.\n+\t(peep2_attempt): Remove casts of insn in peep2_insn_data.\n+\t(peep2_fill_buffer): Promote argument from rtx to rtx_insn\n+\t* recog.h (struct insn_gen_fn): Promote return types of function\n+\tpointers and operator ().from rtx to rtx_insn.\n+\t* reorg.c (fill_simple_delay_slots): Promote rtx_insn to rtx_jump_insn.\n+\t(fill_eager_delay_slots): Likewise.\n+\t(relax_delay_slots): Likewise.\n+\t(make_return_insns): Likewise.\n+\t(dbr_schedule): Likewise.\n+\t(optimize_skips): Likewise.\n+\t(reorg_redirect_jump): Likewise.\n+\t(fill_slots_from_thread): Likewise.\n+\t* reorg.h: Update prototypes.\n+\t* resource.c (find_dead_or_set_registers): Use dyn_cast to\n+\trtx_jump_insn instead of check.  Use it's jump_target method.\n+\t* rtl.h (rtx_jump_insn::jump_label): Define new method.\n+\t(rtx_jump_insn::jump_target): Define new method.\n+\t(rtx_jump_insn::set_jump_target): Define new method.\n+\t* rtlanal.c (tablejump_p): Promote type of one local variable.\n+\t* sched-deps.c (sched_analyze_2): Promote rtx to rtx_insn_list.\n+\t(sched_analyze_insn): Likewise.\n+\t* sched-vis.c (print_insn_with_notes): Promote rtx to rtx_insn.\n+\t(print_insn): Likewise.\n+\t* stmt.c (label_rtx): Promote return type to rtx_insn.\n+\t(force_label_rtx): Likewise.\n+\t(jump_target_rtx): Define new function.\n+\t(expand_label): Use it, get rid of one cast.\n+\t(expand_naked_return): Promote rtx to rtx_code_label.\n+\t(do_jump_if_equal): Fix do_compare_rtx_and_jump call.\n+\t(expand_case): Use rtx_code_label instread of rtx where feasible.\n+\t(expand_sjlj_dispatch_table): Likewise.\n+\t(emit_case_nodes): Likewise.\n+\t* stmt.h: Declare jump_target_rtx.  Update prototypes.  Fix comments.\n+\t* store-motion.c (insert_store): Make use of new return type of\n+\tgen_move_insn and remove a cast.\n+\t(replace_store_insn): Likewise.\n+\n 2015-05-20  Max Filippov  <jcmvbkbc@gmail.com>\n \n \t* config/xtensa/xtensa.c (init_alignment_context): Replace MULT"}, {"sha": "20e15fc9fdc2db4b2850468579ae800bc0339f35", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -1736,9 +1736,11 @@ set_edge_can_fallthru_flag (void)\n \tcontinue;\n       if (!any_condjump_p (BB_END (bb)))\n \tcontinue;\n-      if (!invert_jump (BB_END (bb), JUMP_LABEL (BB_END (bb)), 0))\n+\n+      rtx_jump_insn *bb_end_jump = as_a <rtx_jump_insn *> (BB_END (bb));\n+      if (!invert_jump (bb_end_jump, JUMP_LABEL (bb_end_jump), 0))\n \tcontinue;\n-      invert_jump (BB_END (bb), JUMP_LABEL (BB_END (bb)), 0);\n+      invert_jump (bb_end_jump, JUMP_LABEL (bb_end_jump), 0);\n       EDGE_SUCC (bb, 0)->flags |= EDGE_CAN_FALLTHRU;\n       EDGE_SUCC (bb, 1)->flags |= EDGE_CAN_FALLTHRU;\n     }\n@@ -1892,9 +1894,15 @@ fix_up_fall_thru_edges (void)\n \n \t\t      fall_thru_label = block_label (fall_thru->dest);\n \n-\t\t      if (old_jump && JUMP_P (old_jump) && fall_thru_label)\n-\t\t\tinvert_worked = invert_jump (old_jump,\n-\t\t\t\t\t\t     fall_thru_label,0);\n+\t\t      if (old_jump && fall_thru_label)\n+\t\t\t{\n+\t\t\t  rtx_jump_insn *old_jump_insn =\n+\t\t\t\tdyn_cast <rtx_jump_insn *> (old_jump);\n+\t\t\t  if (old_jump_insn)\n+\t\t\t    invert_worked = invert_jump (old_jump_insn,\n+\t\t\t\t\t\t\t fall_thru_label, 0);\n+\t\t\t}\n+\n \t\t      if (invert_worked)\n \t\t\t{\n \t\t\t  fall_thru->flags &= ~EDGE_FALLTHRU;\n@@ -2009,10 +2017,9 @@ fix_crossing_conditional_branches (void)\n   edge succ2;\n   edge crossing_edge;\n   edge new_edge;\n-  rtx_insn *old_jump;\n   rtx set_src;\n   rtx old_label = NULL_RTX;\n-  rtx new_label;\n+  rtx_code_label *new_label;\n \n   FOR_EACH_BB_FN (cur_bb, cfun)\n     {\n@@ -2037,7 +2044,7 @@ fix_crossing_conditional_branches (void)\n \n       if (crossing_edge)\n \t{\n-\t  old_jump = BB_END (cur_bb);\n+\t  rtx_jump_insn *old_jump = as_a <rtx_jump_insn *> (BB_END (cur_bb));\n \n \t  /* Check to make sure the jump instruction is a\n \t     conditional jump.  */\n@@ -2076,7 +2083,8 @@ fix_crossing_conditional_branches (void)\n \t      else\n \t\t{\n \t\t  basic_block last_bb;\n-\t\t  rtx_insn *new_jump;\n+\t\t  rtx_code_label *old_jump_target;\n+\t\t  rtx_jump_insn *new_jump;\n \n \t\t  /* Create new basic block to be dest for\n \t\t     conditional jump.  */\n@@ -2087,9 +2095,10 @@ fix_crossing_conditional_branches (void)\n \t\t  emit_label (new_label);\n \n \t\t  gcc_assert (GET_CODE (old_label) == LABEL_REF);\n-\t\t  old_label = JUMP_LABEL (old_jump);\n-\t\t  new_jump = emit_jump_insn (gen_jump (old_label));\n-\t\t  JUMP_LABEL (new_jump) = old_label;\n+\t\t  old_jump_target = old_jump->jump_target ();\n+\t\t  new_jump = as_a <rtx_jump_insn *>\n+\t\t\t\t(emit_jump_insn (gen_jump (old_jump_target)));\n+\t\t  new_jump->set_jump_target (old_jump_target);\n \n \t\t  last_bb = EXIT_BLOCK_PTR_FOR_FN (cfun)->prev_bb;\n \t\t  new_bb = create_basic_block (new_label, new_jump, last_bb);"}, {"sha": "ae0db9d778a38a9542a8b8bd7ad1cf04e7baaa2a", "filename": "gcc/bt-load.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -1212,7 +1212,7 @@ move_btr_def (basic_block new_def_bb, int btr, btr_def def, bitmap live_range,\n   btr_mode = GET_MODE (SET_DEST (set));\n   btr_rtx = gen_rtx_REG (btr_mode, btr);\n \n-  new_insn = as_a <rtx_insn *> (gen_move_insn (btr_rtx, src));\n+  new_insn = gen_move_insn (btr_rtx, src);\n \n   /* Insert target register initialization at head of basic block.  */\n   def->insn = emit_insn_after (new_insn, insp);"}, {"sha": "f6012afedaf219d429812eba0fda1d6a4fd369e4", "filename": "gcc/builtins.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -2000,7 +2000,7 @@ expand_errno_check (tree exp, rtx target)\n   /* Test the result; if it is NaN, set errno=EDOM because\n      the argument was not in the domain.  */\n   do_compare_rtx_and_jump (target, target, EQ, 0, GET_MODE (target),\n-\t\t\t   NULL_RTX, NULL_RTX, lab,\n+\t\t\t   NULL_RTX, NULL, lab,\n \t\t\t   /* The jump is very likely.  */\n \t\t\t   REG_BR_PROB_BASE - (REG_BR_PROB_BASE / 2000 - 1));\n \n@@ -5934,9 +5934,9 @@ expand_builtin_acc_on_device (tree exp, rtx target)\n   emit_move_insn (target, const1_rtx);\n   rtx_code_label *done_label = gen_label_rtx ();\n   do_compare_rtx_and_jump (v, v1, EQ, false, v_mode, NULL_RTX,\n-\t\t\t   NULL_RTX, done_label, PROB_EVEN);\n+\t\t\t   NULL, done_label, PROB_EVEN);\n   do_compare_rtx_and_jump (v, v2, EQ, false, v_mode, NULL_RTX,\n-\t\t\t   NULL_RTX, done_label, PROB_EVEN);\n+\t\t\t   NULL, done_label, PROB_EVEN);\n   emit_move_insn (target, const0_rtx);\n   emit_label (done_label);\n "}, {"sha": "aff64efcca9967665873635035259acb9ef5621a", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -190,7 +190,8 @@ try_simplify_condjump (basic_block cbranch_block)\n     return false;\n \n   /* Invert the conditional branch.  */\n-  if (!invert_jump (cbranch_insn, block_label (jump_dest_block), 0))\n+  if (!invert_jump (as_a <rtx_jump_insn *> (cbranch_insn),\n+\t\t    block_label (jump_dest_block), 0))\n     return false;\n \n   if (dump_file)"}, {"sha": "b190f913fd706025624b8aa7561cda249c0b3f6c", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -2051,7 +2051,7 @@ static hash_map<basic_block, rtx_code_label *> *lab_rtx_for_bb;\n \n /* Returns the label_rtx expression for a label starting basic block BB.  */\n \n-static rtx\n+static rtx_code_label *\n label_rtx_for_bb (basic_block bb ATTRIBUTE_UNUSED)\n {\n   gimple_stmt_iterator gsi;\n@@ -2078,7 +2078,7 @@ label_rtx_for_bb (basic_block bb ATTRIBUTE_UNUSED)\n       if (DECL_NONLOCAL (lab))\n \tbreak;\n \n-      return label_rtx (lab);\n+      return jump_target_rtx (lab);\n     }\n \n   rtx_code_label *l = gen_label_rtx ();\n@@ -3048,7 +3048,7 @@ expand_goto (tree label)\n   gcc_assert (!context || context == current_function_decl);\n #endif\n \n-  emit_jump (label_rtx (label));\n+  emit_jump (jump_target_rtx (label));\n }\n \n /* Output a return with no value.  */\n@@ -5507,7 +5507,7 @@ construct_init_block (void)\n     {\n       tree label = gimple_block_label (e->dest);\n \n-      emit_jump (label_rtx (label));\n+      emit_jump (jump_target_rtx (label));\n       flags = 0;\n     }\n   else"}, {"sha": "11ba5c025536b19e3590e80c2155d0dbe4d969cb", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -999,18 +999,18 @@ rtl_can_merge_blocks (basic_block a, basic_block b)\n /* Return the label in the head of basic block BLOCK.  Create one if it doesn't\n    exist.  */\n \n-rtx\n+rtx_code_label *\n block_label (basic_block block)\n {\n   if (block == EXIT_BLOCK_PTR_FOR_FN (cfun))\n-    return NULL_RTX;\n+    return NULL;\n \n   if (!LABEL_P (BB_HEAD (block)))\n     {\n       BB_HEAD (block) = emit_label_before (gen_label_rtx (), BB_HEAD (block));\n     }\n \n-  return BB_HEAD (block);\n+  return as_a <rtx_code_label *> (BB_HEAD (block));\n }\n \n /* Attempt to perform edge redirection by replacing possibly complex jump\n@@ -1110,7 +1110,8 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n       if (dump_file)\n \tfprintf (dump_file, \"Redirecting jump %i from %i to %i.\\n\",\n \t\t INSN_UID (insn), e->dest->index, target->index);\n-      if (!redirect_jump (insn, block_label (target), 0))\n+      if (!redirect_jump (as_a <rtx_jump_insn *> (insn),\n+\t\t\t  block_label (target), 0))\n \t{\n \t  gcc_assert (target == EXIT_BLOCK_PTR_FOR_FN (cfun));\n \t  return NULL;\n@@ -1294,7 +1295,8 @@ patch_jump_insn (rtx_insn *insn, rtx_insn *old_label, basic_block new_bb)\n \t  /* If the substitution doesn't succeed, die.  This can happen\n \t     if the back end emitted unrecognizable instructions or if\n \t     target is exit block on some arches.  */\n-\t  if (!redirect_jump (insn, block_label (new_bb), 0))\n+\t  if (!redirect_jump (as_a <rtx_jump_insn *> (insn),\n+\t\t\t      block_label (new_bb), 0))\n \t    {\n \t      gcc_assert (new_bb == EXIT_BLOCK_PTR_FOR_FN (cfun));\n \t      return false;\n@@ -1322,15 +1324,16 @@ redirect_branch_edge (edge e, basic_block target)\n \n   if (!currently_expanding_to_rtl)\n     {\n-      if (!patch_jump_insn (insn, old_label, target))\n+      if (!patch_jump_insn (as_a <rtx_jump_insn *> (insn), old_label, target))\n \treturn NULL;\n     }\n   else\n     /* When expanding this BB might actually contain multiple\n        jumps (i.e. not yet split by find_many_sub_basic_blocks).\n        Redirect all of those that match our label.  */\n     FOR_BB_INSNS (src, insn)\n-      if (JUMP_P (insn) && !patch_jump_insn (insn, old_label, target))\n+      if (JUMP_P (insn) && !patch_jump_insn (as_a <rtx_jump_insn *> (insn),\n+\t\t\t\t\t     old_label, target))\n \treturn NULL;\n \n   if (dump_file)\n@@ -1521,7 +1524,8 @@ force_nonfallthru_and_redirect (edge e, basic_block target, rtx jump_label)\n       edge b = unchecked_make_edge (e->src, target, 0);\n       bool redirected;\n \n-      redirected = redirect_jump (BB_END (e->src), block_label (target), 0);\n+      redirected = redirect_jump (as_a <rtx_jump_insn *> (BB_END (e->src)),\n+\t\t\t\t  block_label (target), 0);\n       gcc_assert (redirected);\n \n       note = find_reg_note (BB_END (e->src), REG_BR_PROB, NULL_RTX);\n@@ -3775,21 +3779,21 @@ fixup_reorder_chain (void)\n \t  e_taken = e;\n \n       bb_end_insn = BB_END (bb);\n-      if (JUMP_P (bb_end_insn))\n+      if (rtx_jump_insn *bb_end_jump = dyn_cast <rtx_jump_insn *> (bb_end_insn))\n \t{\n-\t  ret_label = JUMP_LABEL (bb_end_insn);\n-\t  if (any_condjump_p (bb_end_insn))\n+\t  ret_label = JUMP_LABEL (bb_end_jump);\n+\t  if (any_condjump_p (bb_end_jump))\n \t    {\n \t      /* This might happen if the conditional jump has side\n \t\t effects and could therefore not be optimized away.\n \t\t Make the basic block to end with a barrier in order\n \t\t to prevent rtl_verify_flow_info from complaining.  */\n \t      if (!e_fall)\n \t\t{\n-\t\t  gcc_assert (!onlyjump_p (bb_end_insn)\n-\t\t\t      || returnjump_p (bb_end_insn)\n+\t\t  gcc_assert (!onlyjump_p (bb_end_jump)\n+\t\t\t      || returnjump_p (bb_end_jump)\n                               || (e_taken->flags & EDGE_CROSSING));\n-\t\t  emit_barrier_after (bb_end_insn);\n+\t\t  emit_barrier_after (bb_end_jump);\n \t\t  continue;\n \t\t}\n \n@@ -3811,11 +3815,11 @@ fixup_reorder_chain (void)\n \t\t edge based on known or assumed probability.  */\n \t      else if (bb->aux != e_taken->dest)\n \t\t{\n-\t\t  rtx note = find_reg_note (bb_end_insn, REG_BR_PROB, 0);\n+\t\t  rtx note = find_reg_note (bb_end_jump, REG_BR_PROB, 0);\n \n \t\t  if (note\n \t\t      && XINT (note, 0) < REG_BR_PROB_BASE / 2\n-\t\t      && invert_jump (bb_end_insn,\n+\t\t      && invert_jump (bb_end_jump,\n \t\t\t\t      (e_fall->dest\n \t\t\t\t       == EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t\t\t\t       ? NULL_RTX\n@@ -3838,7 +3842,7 @@ fixup_reorder_chain (void)\n \n \t      /* Otherwise we can try to invert the jump.  This will\n \t\t basically never fail, however, keep up the pretense.  */\n-\t      else if (invert_jump (bb_end_insn,\n+\t      else if (invert_jump (bb_end_jump,\n \t\t\t\t    (e_fall->dest\n \t\t\t\t     == EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t\t\t\t     ? NULL_RTX\n@@ -4956,7 +4960,7 @@ rtl_lv_add_condition_to_bb (basic_block first_head ,\n \t\t\t    basic_block second_head ATTRIBUTE_UNUSED,\n \t\t\t    basic_block cond_bb, void *comp_rtx)\n {\n-  rtx label;\n+  rtx_code_label *label;\n   rtx_insn *seq, *jump;\n   rtx op0 = XEXP ((rtx)comp_rtx, 0);\n   rtx op1 = XEXP ((rtx)comp_rtx, 1);\n@@ -4972,8 +4976,7 @@ rtl_lv_add_condition_to_bb (basic_block first_head ,\n   start_sequence ();\n   op0 = force_operand (op0, NULL_RTX);\n   op1 = force_operand (op1, NULL_RTX);\n-  do_compare_rtx_and_jump (op0, op1, comp, 0,\n-\t\t\t   mode, NULL_RTX, NULL_RTX, label, -1);\n+  do_compare_rtx_and_jump (op0, op1, comp, 0, mode, NULL_RTX, NULL, label, -1);\n   jump = get_last_insn ();\n   JUMP_LABEL (jump) = label;\n   LABEL_NUSES (label)++;"}, {"sha": "cdf147775f1ca2d95fa6e71327f30bd036bd96f7", "filename": "gcc/cfgrtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fcfgrtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fcfgrtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.h?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -33,7 +33,7 @@ extern bool contains_no_active_insn_p (const_basic_block);\n extern bool forwarder_block_p (const_basic_block);\n extern bool can_fallthru (basic_block, basic_block);\n extern rtx_note *bb_note (basic_block);\n-extern rtx block_label (basic_block);\n+extern rtx_code_label *block_label (basic_block);\n extern edge try_redirect_by_replacing_jump (edge, basic_block, bool);\n extern void emit_barrier_after_bb (basic_block bb);\n extern basic_block force_nonfallthru_and_redirect (edge, basic_block, rtx);"}, {"sha": "37f4ded79474e6f6a4653bb175b3f6dcf959b96c", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -3844,7 +3844,8 @@ hwloop_optimize (hwloop_info loop)\n \n   delete_insn (loop->loop_end);\n   /* Insert the loop end label before the last instruction of the loop.  */\n-  emit_label_before (loop->end_label, loop->last_insn);\n+  emit_label_before (as_a <rtx_code_label *> (loop->end_label),\n+\t\t     loop->last_insn);\n \n   return true;\n }"}, {"sha": "af219fdb3c7961a04e055b9a2d33380555e2d7a9", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -38399,7 +38399,7 @@ ix86_emit_cmove (rtx dst, rtx src, enum rtx_code code, rtx op1, rtx op2)\n     }\n   else\n     {\n-      rtx nomove = gen_label_rtx ();\n+      rtx_code_label *nomove = gen_label_rtx ();\n       emit_cmp_and_jump_insns (op1, op2, reverse_condition (code),\n \t\t\t       const0_rtx, GET_MODE (op1), 1, nomove);\n       emit_move_insn (dst, src);"}, {"sha": "c3755f57adfb2ffef194ab8c2d6d4c4f0a35751d", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -16788,13 +16788,14 @@ mips16_split_long_branches (void)\n   do\n     {\n       rtx_insn *insn;\n+      rtx_jump_insn *jump_insn;\n \n       shorten_branches (get_insns ());\n       something_changed = false;\n       for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-\tif (JUMP_P (insn)\n-\t    && get_attr_length (insn) > 4\n-\t    && (any_condjump_p (insn) || any_uncondjump_p (insn)))\n+\tif ((jump_insn = dyn_cast <rtx_jump_insn *> (insn))\n+\t    && get_attr_length (jump_insn) > 4\n+\t    && (any_condjump_p (jump_insn) || any_uncondjump_p (jump_insn)))\n \t  {\n \t    rtx old_label, temp, saved_temp;\n \t    rtx_code_label *new_label;\n@@ -16809,7 +16810,7 @@ mips16_split_long_branches (void)\n \t    emit_move_insn (saved_temp, temp);\n \n \t    /* Load the branch target into TEMP.  */\n-\t    old_label = JUMP_LABEL (insn);\n+\t    old_label = JUMP_LABEL (jump_insn);\n \t    target = gen_rtx_LABEL_REF (Pmode, old_label);\n \t    mips16_load_branch_target (temp, target);\n \n@@ -16824,7 +16825,7 @@ mips16_split_long_branches (void)\n \t       a PC-relative constant pool.  */\n \t    mips16_lay_out_constants (false);\n \n-\t    if (simplejump_p (insn))\n+\t    if (simplejump_p (jump_insn))\n \t      /* We're going to replace INSN with a longer form.  */\n \t      new_label = NULL;\n \t    else\n@@ -16838,11 +16839,11 @@ mips16_split_long_branches (void)\n \t    jump_sequence = get_insns ();\n \t    end_sequence ();\n \n-\t    emit_insn_after (jump_sequence, insn);\n+\t    emit_insn_after (jump_sequence, jump_insn);\n \t    if (new_label)\n-\t      invert_jump (insn, new_label, false);\n+\t      invert_jump (jump_insn, new_label, false);\n \t    else\n-\t      delete_insn (insn);\n+\t      delete_insn (jump_insn);\n \t    something_changed = true;\n \t  }\n     }"}, {"sha": "bc1ce24a9cc911b3c9b9f37ab3ca25b39d8313e8", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -5876,7 +5876,7 @@ static void\n gen_far_branch (struct far_branch *bp)\n {\n   rtx_insn *insn = bp->insert_place;\n-  rtx_insn *jump;\n+  rtx_jump_insn *jump;\n   rtx_code_label *label = gen_label_rtx ();\n   int ok;\n \n@@ -5907,7 +5907,7 @@ gen_far_branch (struct far_branch *bp)\n       JUMP_LABEL (jump) = pat;\n     }\n \n-  ok = invert_jump (insn, label, 1);\n+  ok = invert_jump (as_a <rtx_jump_insn *> (insn), label, 1);\n   gcc_assert (ok);\n \n   /* If we are branching around a jump (rather than a return), prevent\n@@ -6700,7 +6700,7 @@ split_branches (rtx_insn *first)\n \t\t    bp->insert_place = insn;\n \t\t    bp->address = addr;\n \t\t  }\n-\t\tok = redirect_jump (insn, label, 0);\n+\t\tok = redirect_jump (as_a <rtx_jump_insn *> (insn), label, 0);\n \t\tgcc_assert (ok);\n \t      }\n \t    else\n@@ -6775,7 +6775,7 @@ split_branches (rtx_insn *first)\n \t\t\tJUMP_LABEL (insn) = far_label;\n \t\t\tLABEL_NUSES (far_label)++;\n \t\t      }\n-\t\t    redirect_jump (insn, ret_rtx, 1);\n+\t\t    redirect_jump (as_a <rtx_jump_insn *> (insn), ret_rtx, 1);\n \t\t    far_label = 0;\n \t\t  }\n \t      }"}, {"sha": "e5ea58957601e50025fbba1229717ba290bfdf3e", "filename": "gcc/dojump.c", "status": "modified", "additions": 80, "deletions": 67, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -61,10 +61,12 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm_p.h\"\n \n static bool prefer_and_bit_test (machine_mode, int);\n-static void do_jump_by_parts_greater (tree, tree, int, rtx, rtx, int);\n-static void do_jump_by_parts_equality (tree, tree, rtx, rtx, int);\n-static void do_compare_and_jump\t(tree, tree, enum rtx_code, enum rtx_code, rtx,\n-\t\t\t\t rtx, int);\n+static void do_jump_by_parts_greater (tree, tree, int,\n+\t\t\t\t      rtx_code_label *, rtx_code_label *, int);\n+static void do_jump_by_parts_equality (tree, tree, rtx_code_label *,\n+\t\t\t\t       rtx_code_label *, int);\n+static void do_compare_and_jump\t(tree, tree, enum rtx_code, enum rtx_code,\n+\t\t\t\t rtx_code_label *, rtx_code_label *, int);\n \n /* Invert probability if there is any.  -1 stands for unknown.  */\n \n@@ -146,34 +148,34 @@ restore_pending_stack_adjust (saved_pending_stack_adjust *save)\n \f\n /* Expand conditional expressions.  */\n \n-/* Generate code to evaluate EXP and jump to LABEL if the value is zero.\n-   LABEL is an rtx of code CODE_LABEL, in this function and all the\n-   functions here.  */\n+/* Generate code to evaluate EXP and jump to LABEL if the value is zero.  */\n \n void\n-jumpifnot (tree exp, rtx label, int prob)\n+jumpifnot (tree exp, rtx_code_label *label, int prob)\n {\n-  do_jump (exp, label, NULL_RTX, inv (prob));\n+  do_jump (exp, label, NULL, inv (prob));\n }\n \n void\n-jumpifnot_1 (enum tree_code code, tree op0, tree op1, rtx label, int prob)\n+jumpifnot_1 (enum tree_code code, tree op0, tree op1, rtx_code_label *label,\n+\t     int prob)\n {\n-  do_jump_1 (code, op0, op1, label, NULL_RTX, inv (prob));\n+  do_jump_1 (code, op0, op1, label, NULL, inv (prob));\n }\n \n /* Generate code to evaluate EXP and jump to LABEL if the value is nonzero.  */\n \n void\n-jumpif (tree exp, rtx label, int prob)\n+jumpif (tree exp, rtx_code_label *label, int prob)\n {\n-  do_jump (exp, NULL_RTX, label, prob);\n+  do_jump (exp, NULL, label, prob);\n }\n \n void\n-jumpif_1 (enum tree_code code, tree op0, tree op1, rtx label, int prob)\n+jumpif_1 (enum tree_code code, tree op0, tree op1,\n+\t  rtx_code_label *label, int prob)\n {\n-  do_jump_1 (code, op0, op1, NULL_RTX, label, prob);\n+  do_jump_1 (code, op0, op1, NULL, label, prob);\n }\n \n /* Used internally by prefer_and_bit_test.  */\n@@ -225,7 +227,8 @@ prefer_and_bit_test (machine_mode mode, int bitnum)\n \n void\n do_jump_1 (enum tree_code code, tree op0, tree op1,\n-\t   rtx if_false_label, rtx if_true_label, int prob)\n+\t   rtx_code_label *if_false_label, rtx_code_label *if_true_label,\n+\t   int prob)\n {\n   machine_mode mode;\n   rtx_code_label *drop_through_label = 0;\n@@ -378,15 +381,15 @@ do_jump_1 (enum tree_code code, tree op0, tree op1,\n             op0_prob = inv (op0_false_prob);\n             op1_prob = inv (op1_false_prob);\n           }\n-        if (if_false_label == NULL_RTX)\n+\tif (if_false_label == NULL)\n           {\n             drop_through_label = gen_label_rtx ();\n-            do_jump (op0, drop_through_label, NULL_RTX, op0_prob);\n-            do_jump (op1, NULL_RTX, if_true_label, op1_prob);\n+\t    do_jump (op0, drop_through_label, NULL, op0_prob);\n+\t    do_jump (op1, NULL, if_true_label, op1_prob);\n           }\n         else\n           {\n-            do_jump (op0, if_false_label, NULL_RTX, op0_prob);\n+\t    do_jump (op0, if_false_label, NULL, op0_prob);\n             do_jump (op1, if_false_label, if_true_label, op1_prob);\n           }\n         break;\n@@ -405,18 +408,18 @@ do_jump_1 (enum tree_code code, tree op0, tree op1,\n           {\n             op0_prob = prob / 2;\n             op1_prob = GCOV_COMPUTE_SCALE ((prob / 2), inv (op0_prob));\n-          }\n-        if (if_true_label == NULL_RTX)\n-          {\n-            drop_through_label = gen_label_rtx ();\n-            do_jump (op0, NULL_RTX, drop_through_label, op0_prob);\n-            do_jump (op1, if_false_label, NULL_RTX, op1_prob);\n-          }\n-        else\n-          {\n-            do_jump (op0, NULL_RTX, if_true_label, op0_prob);\n-            do_jump (op1, if_false_label, if_true_label, op1_prob);\n-          }\n+\t  }\n+\tif (if_true_label == NULL)\n+\t  {\n+\t    drop_through_label = gen_label_rtx ();\n+\t    do_jump (op0, NULL, drop_through_label, op0_prob);\n+\t    do_jump (op1, if_false_label, NULL, op1_prob);\n+\t  }\n+\telse\n+\t  {\n+\t    do_jump (op0, NULL, if_true_label, op0_prob);\n+\t    do_jump (op1, if_false_label, if_true_label, op1_prob);\n+\t  }\n         break;\n       }\n \n@@ -443,25 +446,29 @@ do_jump_1 (enum tree_code code, tree op0, tree op1,\n    PROB is probability of jump to if_true_label, or -1 if unknown.  */\n \n void\n-do_jump (tree exp, rtx if_false_label, rtx if_true_label, int prob)\n+do_jump (tree exp, rtx_code_label *if_false_label,\n+\t rtx_code_label *if_true_label, int prob)\n {\n   enum tree_code code = TREE_CODE (exp);\n   rtx temp;\n   int i;\n   tree type;\n   machine_mode mode;\n-  rtx_code_label *drop_through_label = 0;\n+  rtx_code_label *drop_through_label = NULL;\n \n   switch (code)\n     {\n     case ERROR_MARK:\n       break;\n \n     case INTEGER_CST:\n-      temp = integer_zerop (exp) ? if_false_label : if_true_label;\n-      if (temp)\n-        emit_jump (temp);\n-      break;\n+      {\n+\trtx_code_label *lab = integer_zerop (exp) ? if_false_label\n+\t\t\t\t\t\t  : if_true_label;\n+\tif (lab)\n+\t  emit_jump (lab);\n+\tbreak;\n+      }\n \n #if 0\n       /* This is not true with #pragma weak  */\n@@ -511,7 +518,7 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label, int prob)\n \t  }\n \n         do_pending_stack_adjust ();\n-\tdo_jump (TREE_OPERAND (exp, 0), label1, NULL_RTX, -1);\n+\tdo_jump (TREE_OPERAND (exp, 0), label1, NULL, -1);\n \tdo_jump (TREE_OPERAND (exp, 1), if_false_label, if_true_label, prob);\n         emit_label (label1);\n \tdo_jump (TREE_OPERAND (exp, 2), if_false_label, if_true_label, prob);\n@@ -555,7 +562,7 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label, int prob)\n       if (integer_onep (TREE_OPERAND (exp, 1)))\n \t{\n \t  tree exp0 = TREE_OPERAND (exp, 0);\n-\t  rtx set_label, clr_label;\n+\t  rtx_code_label *set_label, *clr_label;\n \t  int setclr_prob = prob;\n \n \t  /* Strip narrowing integral type conversions.  */\n@@ -684,11 +691,12 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label, int prob)\n \n static void\n do_jump_by_parts_greater_rtx (machine_mode mode, int unsignedp, rtx op0,\n-\t\t\t      rtx op1, rtx if_false_label, rtx if_true_label,\n+\t\t\t      rtx op1, rtx_code_label *if_false_label,\n+\t\t\t      rtx_code_label *if_true_label,\n \t\t\t      int prob)\n {\n   int nwords = (GET_MODE_SIZE (mode) / UNITS_PER_WORD);\n-  rtx drop_through_label = 0;\n+  rtx_code_label *drop_through_label = 0;\n   bool drop_through_if_true = false, drop_through_if_false = false;\n   enum rtx_code code = GT;\n   int i;\n@@ -735,7 +743,7 @@ do_jump_by_parts_greater_rtx (machine_mode mode, int unsignedp, rtx op0,\n \n       /* All but high-order word must be compared as unsigned.  */\n       do_compare_rtx_and_jump (op0_word, op1_word, code, (unsignedp || i > 0),\n-\t\t\t       word_mode, NULL_RTX, NULL_RTX, if_true_label,\n+\t\t\t       word_mode, NULL_RTX, NULL, if_true_label,\n \t\t\t       prob);\n \n       /* Emit only one comparison for 0.  Do not emit the last cond jump.  */\n@@ -744,7 +752,7 @@ do_jump_by_parts_greater_rtx (machine_mode mode, int unsignedp, rtx op0,\n \n       /* Consider lower words only if these are equal.  */\n       do_compare_rtx_and_jump (op0_word, op1_word, NE, unsignedp, word_mode,\n-\t\t\t       NULL_RTX, NULL_RTX, if_false_label, inv (prob));\n+\t\t\t       NULL_RTX, NULL, if_false_label, inv (prob));\n     }\n \n   if (!drop_through_if_false)\n@@ -760,7 +768,8 @@ do_jump_by_parts_greater_rtx (machine_mode mode, int unsignedp, rtx op0,\n \n static void\n do_jump_by_parts_greater (tree treeop0, tree treeop1, int swap,\n-\t\t\t  rtx if_false_label, rtx if_true_label, int prob)\n+\t\t\t  rtx_code_label *if_false_label,\n+\t\t\t  rtx_code_label *if_true_label, int prob)\n {\n   rtx op0 = expand_normal (swap ? treeop1 : treeop0);\n   rtx op1 = expand_normal (swap ? treeop0 : treeop1);\n@@ -773,17 +782,18 @@ do_jump_by_parts_greater (tree treeop0, tree treeop1, int swap,\n \f\n /* Jump according to whether OP0 is 0.  We assume that OP0 has an integer\n    mode, MODE, that is too wide for the available compare insns.  Either\n-   Either (but not both) of IF_TRUE_LABEL and IF_FALSE_LABEL may be NULL_RTX\n+   Either (but not both) of IF_TRUE_LABEL and IF_FALSE_LABEL may be NULL\n    to indicate drop through.  */\n \n static void\n do_jump_by_parts_zero_rtx (machine_mode mode, rtx op0,\n-\t\t\t   rtx if_false_label, rtx if_true_label, int prob)\n+\t\t\t   rtx_code_label *if_false_label,\n+\t\t\t   rtx_code_label *if_true_label, int prob)\n {\n   int nwords = GET_MODE_SIZE (mode) / UNITS_PER_WORD;\n   rtx part;\n   int i;\n-  rtx drop_through_label = 0;\n+  rtx_code_label *drop_through_label = NULL;\n \n   /* The fastest way of doing this comparison on almost any machine is to\n      \"or\" all the words and compare the result.  If all have to be loaded\n@@ -806,12 +816,12 @@ do_jump_by_parts_zero_rtx (machine_mode mode, rtx op0,\n \n   /* If we couldn't do the \"or\" simply, do this with a series of compares.  */\n   if (! if_false_label)\n-    drop_through_label = if_false_label = gen_label_rtx ();\n+    if_false_label = drop_through_label = gen_label_rtx ();\n \n   for (i = 0; i < nwords; i++)\n     do_compare_rtx_and_jump (operand_subword_force (op0, i, mode),\n                              const0_rtx, EQ, 1, word_mode, NULL_RTX,\n-\t\t\t     if_false_label, NULL_RTX, prob);\n+\t\t\t     if_false_label, NULL, prob);\n \n   if (if_true_label)\n     emit_jump (if_true_label);\n@@ -827,10 +837,11 @@ do_jump_by_parts_zero_rtx (machine_mode mode, rtx op0,\n \n static void\n do_jump_by_parts_equality_rtx (machine_mode mode, rtx op0, rtx op1,\n-\t\t\t       rtx if_false_label, rtx if_true_label, int prob)\n+\t\t\t       rtx_code_label *if_false_label,\n+\t\t\t       rtx_code_label *if_true_label, int prob)\n {\n   int nwords = (GET_MODE_SIZE (mode) / UNITS_PER_WORD);\n-  rtx drop_through_label = 0;\n+  rtx_code_label *drop_through_label = NULL;\n   int i;\n \n   if (op1 == const0_rtx)\n@@ -853,7 +864,7 @@ do_jump_by_parts_equality_rtx (machine_mode mode, rtx op0, rtx op1,\n     do_compare_rtx_and_jump (operand_subword_force (op0, i, mode),\n                              operand_subword_force (op1, i, mode),\n                              EQ, 0, word_mode, NULL_RTX,\n-\t\t\t     if_false_label, NULL_RTX, prob);\n+\t\t\t     if_false_label, NULL, prob);\n \n   if (if_true_label)\n     emit_jump (if_true_label);\n@@ -865,8 +876,9 @@ do_jump_by_parts_equality_rtx (machine_mode mode, rtx op0, rtx op1,\n    with one insn, test the comparison and jump to the appropriate label.  */\n \n static void\n-do_jump_by_parts_equality (tree treeop0, tree treeop1, rtx if_false_label,\n-\t\t\t   rtx if_true_label, int prob)\n+do_jump_by_parts_equality (tree treeop0, tree treeop1,\n+\t\t\t   rtx_code_label *if_false_label,\n+\t\t\t   rtx_code_label *if_true_label, int prob)\n {\n   rtx op0 = expand_normal (treeop0);\n   rtx op1 = expand_normal (treeop1);\n@@ -961,11 +973,12 @@ split_comparison (enum rtx_code code, machine_mode mode,\n \n void\n do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n-\t\t\t machine_mode mode, rtx size, rtx if_false_label,\n-\t\t\t rtx if_true_label, int prob)\n+\t\t\t machine_mode mode, rtx size,\n+\t\t\t rtx_code_label *if_false_label,\n+\t\t\t rtx_code_label *if_true_label, int prob)\n {\n   rtx tem;\n-  rtx dummy_label = NULL;\n+  rtx_code_label *dummy_label = NULL;\n \n   /* Reverse the comparison if that is safe and we want to jump if it is\n      false.  Also convert to the reverse comparison if the target can\n@@ -1010,8 +1023,9 @@ do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n     {\n       if (CONSTANT_P (tem))\n \t{\n-\t  rtx label = (tem == const0_rtx || tem == CONST0_RTX (mode))\n-\t\t      ? if_false_label : if_true_label;\n+\t  rtx_code_label *label = (tem == const0_rtx\n+\t\t\t\t   || tem == CONST0_RTX (mode))\n+\t\t\t\t\t? if_false_label : if_true_label;\n \t  if (label)\n \t    emit_jump (label);\n \t  return;\n@@ -1127,7 +1141,7 @@ do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n \t\tfirst_prob = REG_BR_PROB_BASE - REG_BR_PROB_BASE / 100;\n \t      if (and_them)\n \t\t{\n-\t\t  rtx dest_label;\n+\t\t  rtx_code_label *dest_label;\n \t\t  /* If we only jump if true, just bypass the second jump.  */\n \t\t  if (! if_false_label)\n \t\t    {\n@@ -1138,13 +1152,11 @@ do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n \t\t  else\n \t\t    dest_label = if_false_label;\n                   do_compare_rtx_and_jump (op0, op1, first_code, unsignedp, mode,\n-\t\t\t\t\t   size, dest_label, NULL_RTX,\n-\t\t\t\t\t   first_prob);\n+\t\t\t\t\t   size, dest_label, NULL, first_prob);\n \t\t}\n               else\n                 do_compare_rtx_and_jump (op0, op1, first_code, unsignedp, mode,\n-\t\t\t\t\t size, NULL_RTX, if_true_label,\n-\t\t\t\t\t first_prob);\n+\t\t\t\t\t size, NULL, if_true_label, first_prob);\n \t    }\n \t}\n \n@@ -1170,8 +1182,9 @@ do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n \n static void\n do_compare_and_jump (tree treeop0, tree treeop1, enum rtx_code signed_code,\n-\t\t     enum rtx_code unsigned_code, rtx if_false_label,\n-\t\t     rtx if_true_label, int prob)\n+\t\t     enum rtx_code unsigned_code,\n+\t\t     rtx_code_label *if_false_label,\n+\t\t     rtx_code_label *if_true_label, int prob)\n {\n   rtx op0, op1;\n   tree type;"}, {"sha": "1b64ea7fdb7aaed7d198cfc5b9c29c64883af33c", "filename": "gcc/dojump.h", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fdojump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fdojump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.h?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -57,20 +57,23 @@ extern void save_pending_stack_adjust (saved_pending_stack_adjust *);\n extern void restore_pending_stack_adjust (saved_pending_stack_adjust *);\n \n /* Generate code to evaluate EXP and jump to LABEL if the value is zero.  */\n-extern void jumpifnot (tree, rtx, int);\n-extern void jumpifnot_1 (enum tree_code, tree, tree, rtx, int);\n+extern void jumpifnot (tree exp, rtx_code_label *label, int prob);\n+extern void jumpifnot_1 (enum tree_code, tree, tree, rtx_code_label *, int);\n \n /* Generate code to evaluate EXP and jump to LABEL if the value is nonzero.  */\n-extern void jumpif (tree, rtx, int);\n-extern void jumpif_1 (enum tree_code, tree, tree, rtx, int);\n+extern void jumpif (tree exp, rtx_code_label *label, int prob);\n+extern void jumpif_1 (enum tree_code, tree, tree, rtx_code_label *, int);\n \n /* Generate code to evaluate EXP and jump to IF_FALSE_LABEL if\n    the result is zero, or IF_TRUE_LABEL if the result is one.  */\n-extern void do_jump (tree, rtx, rtx, int);\n-extern void do_jump_1 (enum tree_code, tree, tree, rtx, rtx, int);\n+extern void do_jump (tree exp, rtx_code_label *if_false_label,\n+\t\t     rtx_code_label *if_true_label, int prob);\n+extern void do_jump_1 (enum tree_code, tree, tree, rtx_code_label *,\n+\t\t       rtx_code_label *, int);\n \n extern void do_compare_rtx_and_jump (rtx, rtx, enum rtx_code, int,\n-\t\t\t\t     machine_mode, rtx, rtx, rtx, int);\n+\t\t\t\t     machine_mode, rtx, rtx_code_label *,\n+\t\t\t\t     rtx_code_label *, int);\n \n extern bool split_comparison (enum rtx_code, machine_mode,\n \t\t\t      enum rtx_code *, enum rtx_code *);"}, {"sha": "b3b38d51d3dd48a6a2c5def88c01f683f0527453", "filename": "gcc/dse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -905,7 +905,7 @@ emit_inc_dec_insn_before (rtx mem ATTRIBUTE_UNUSED,\n       end_sequence ();\n     }\n   else\n-    new_insn = as_a <rtx_insn *> (gen_move_insn (dest, src));\n+    new_insn = gen_move_insn (dest, src);\n   info.first = new_insn;\n   info.fixed_regs_live = insn_info->fixed_regs_live;\n   info.failure = false;"}, {"sha": "8270ce9878dd5c8fdf8cf3de4b5dbceed75cce2c", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 42, "deletions": 21, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -143,6 +143,11 @@ rtx ret_rtx;\n rtx simple_return_rtx;\n rtx cc0_rtx;\n \n+/* Marker used for denoting an INSN, which should never be accessed (i.e.,\n+   this pointer should normally never be dereferenced), but is required to be\n+   distinct from NULL_RTX.  Currently used by peephole2 pass.  */\n+rtx_insn *invalid_insn_rtx;\n+\n /* A hash table storing CONST_INTs whose absolute value is greater\n    than MAX_SAVED_CONST_INT.  */\n \n@@ -4410,11 +4415,12 @@ emit_insn_before_noloc (rtx x, rtx_insn *before, basic_block bb)\n /* Make an instruction with body X and code JUMP_INSN\n    and output it before the instruction BEFORE.  */\n \n-rtx_insn *\n+rtx_jump_insn *\n emit_jump_insn_before_noloc (rtx x, rtx_insn *before)\n {\n-  return emit_pattern_before_noloc (x, before, NULL_RTX, NULL,\n-\t\t\t\t    make_jump_insn_raw);\n+  return as_a <rtx_jump_insn *> (\n+\t\temit_pattern_before_noloc (x, before, NULL_RTX, NULL,\n+\t\t\t\t\t   make_jump_insn_raw));\n }\n \n /* Make an instruction with body X and code CALL_INSN\n@@ -4453,13 +4459,13 @@ emit_barrier_before (rtx before)\n \n /* Emit the label LABEL before the insn BEFORE.  */\n \n-rtx_insn *\n+rtx_code_label *\n emit_label_before (rtx label, rtx_insn *before)\n {\n   gcc_checking_assert (INSN_UID (label) == 0);\n   INSN_UID (label) = cur_insn_uid++;\n   add_insn_before (label, before, NULL);\n-  return as_a <rtx_insn *> (label);\n+  return as_a <rtx_code_label *> (label);\n }\n \f\n /* Helper for emit_insn_after, handles lists of instructions\n@@ -4561,10 +4567,11 @@ emit_insn_after_noloc (rtx x, rtx after, basic_block bb)\n /* Make an insn of code JUMP_INSN with body X\n    and output it after the insn AFTER.  */\n \n-rtx_insn *\n+rtx_jump_insn *\n emit_jump_insn_after_noloc (rtx x, rtx after)\n {\n-  return emit_pattern_after_noloc (x, after, NULL, make_jump_insn_raw);\n+  return as_a <rtx_jump_insn *> (\n+\t\temit_pattern_after_noloc (x, after, NULL, make_jump_insn_raw));\n }\n \n /* Make an instruction with body X and code CALL_INSN\n@@ -4738,17 +4745,19 @@ emit_insn_after (rtx pattern, rtx after)\n }\n \n /* Like emit_jump_insn_after_noloc, but set INSN_LOCATION according to LOC.  */\n-rtx_insn *\n+rtx_jump_insn *\n emit_jump_insn_after_setloc (rtx pattern, rtx after, int loc)\n {\n-  return emit_pattern_after_setloc (pattern, after, loc, make_jump_insn_raw);\n+  return as_a <rtx_jump_insn *> (\n+\temit_pattern_after_setloc (pattern, after, loc, make_jump_insn_raw));\n }\n \n /* Like emit_jump_insn_after_noloc, but set INSN_LOCATION according to AFTER.  */\n-rtx_insn *\n+rtx_jump_insn *\n emit_jump_insn_after (rtx pattern, rtx after)\n {\n-  return emit_pattern_after (pattern, after, true, make_jump_insn_raw);\n+  return as_a <rtx_jump_insn *> (\n+\temit_pattern_after (pattern, after, true, make_jump_insn_raw));\n }\n \n /* Like emit_call_insn_after_noloc, but set INSN_LOCATION according to LOC.  */\n@@ -4855,19 +4864,21 @@ emit_insn_before (rtx pattern, rtx before)\n }\n \n /* like emit_insn_before_noloc, but set INSN_LOCATION according to LOC.  */\n-rtx_insn *\n+rtx_jump_insn *\n emit_jump_insn_before_setloc (rtx pattern, rtx_insn *before, int loc)\n {\n-  return emit_pattern_before_setloc (pattern, before, loc, false,\n-\t\t\t\t     make_jump_insn_raw);\n+  return as_a <rtx_jump_insn *> (\n+\temit_pattern_before_setloc (pattern, before, loc, false,\n+\t\t\t\t    make_jump_insn_raw));\n }\n \n /* Like emit_jump_insn_before_noloc, but set INSN_LOCATION according to BEFORE.  */\n-rtx_insn *\n+rtx_jump_insn *\n emit_jump_insn_before (rtx pattern, rtx before)\n {\n-  return emit_pattern_before (pattern, before, true, false,\n-\t\t\t      make_jump_insn_raw);\n+  return as_a <rtx_jump_insn *> (\n+\temit_pattern_before (pattern, before, true, false,\n+\t\t\t     make_jump_insn_raw));\n }\n \n /* Like emit_insn_before_noloc, but set INSN_LOCATION according to LOC.  */\n@@ -5082,13 +5093,15 @@ emit_call_insn (rtx x)\n \n /* Add the label LABEL to the end of the doubly-linked list.  */\n \n-rtx_insn *\n-emit_label (rtx label)\n+rtx_code_label *\n+emit_label (rtx uncast_label)\n {\n+  rtx_code_label *label = as_a <rtx_code_label *> (uncast_label);\n+\n   gcc_checking_assert (INSN_UID (label) == 0);\n   INSN_UID (label) = cur_insn_uid++;\n-  add_insn (as_a <rtx_insn *> (label));\n-  return as_a <rtx_insn *> (label);\n+  add_insn (label);\n+  return label;\n }\n \n /* Make an insn of code JUMP_TABLE_DATA\n@@ -6151,6 +6164,14 @@ init_emit_once (void)\n   ret_rtx = gen_rtx_fmt_ (RETURN, VOIDmode);\n   simple_return_rtx = gen_rtx_fmt_ (SIMPLE_RETURN, VOIDmode);\n   cc0_rtx = gen_rtx_fmt_ (CC0, VOIDmode);\n+  invalid_insn_rtx = gen_rtx_INSN (VOIDmode,\n+\t\t\t\t   /*prev_insn=*/NULL,\n+\t\t\t\t   /*next_insn=*/NULL,\n+\t\t\t\t   /*bb=*/NULL,\n+\t\t\t\t   /*pattern=*/NULL_RTX,\n+\t\t\t\t   /*location=*/-1,\n+\t\t\t\t   CODE_FOR_nothing,\n+\t\t\t\t   /*reg_notes=*/NULL_RTX);\n }\n \f\n /* Produce exact duplicate of insn INSN after AFTER."}, {"sha": "074f36107eb22254b4a449b27fb62432d3d8e7aa", "filename": "gcc/except.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -1364,7 +1364,7 @@ sjlj_emit_dispatch_table (rtx_code_label *dispatch_label, int num_dispatch)\n     if (lp && lp->post_landing_pad)\n       {\n \trtx_insn *seq2;\n-\trtx label;\n+\trtx_code_label *label;\n \n \tstart_sequence ();\n \n@@ -1378,7 +1378,7 @@ sjlj_emit_dispatch_table (rtx_code_label *dispatch_label, int num_dispatch)\n \t    t = build_int_cst (integer_type_node, disp_index);\n \t    case_elt = build_case_label (t, NULL, t_label);\n \t    dispatch_labels.quick_push (case_elt);\n-\t    label = label_rtx (t_label);\n+\t    label = jump_target_rtx (t_label);\n \t  }\n \telse\n \t  label = gen_label_rtx ();"}, {"sha": "b41feb682666ab86b65ebbc2c0ab92e594ad67f8", "filename": "gcc/explow.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -984,7 +984,7 @@ emit_stack_save (enum save_level save_level, rtx *psave)\n {\n   rtx sa = *psave;\n   /* The default is that we use a move insn and save in a Pmode object.  */\n-  rtx (*fcn) (rtx, rtx) = gen_move_insn;\n+  rtx (*fcn) (rtx, rtx) = gen_move_insn_uncast;\n   machine_mode mode = STACK_SAVEAREA_MODE (save_level);\n \n   /* See if this machine has anything special to do for this kind of save.  */\n@@ -1039,7 +1039,7 @@ void\n emit_stack_restore (enum save_level save_level, rtx sa)\n {\n   /* The default is that we use a move insn.  */\n-  rtx (*fcn) (rtx, rtx) = gen_move_insn;\n+  rtx (*fcn) (rtx, rtx) = gen_move_insn_uncast;\n \n   /* If stack_realign_drap, the x86 backend emits a prologue that aligns both\n      STACK_POINTER and HARD_FRAME_POINTER."}, {"sha": "c95299cdf970ee69efd01e62785e83ea0e05d5c9", "filename": "gcc/expmed.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -5805,8 +5805,8 @@ emit_store_flag_force (rtx target, enum rtx_code code, rtx op0, rtx op1,\n       && op1 == const0_rtx)\n     {\n       label = gen_label_rtx ();\n-      do_compare_rtx_and_jump (target, const0_rtx, EQ, unsignedp,\n-\t\t\t       mode, NULL_RTX, NULL_RTX, label, -1);\n+      do_compare_rtx_and_jump (target, const0_rtx, EQ, unsignedp, mode,\n+\t\t\t       NULL_RTX, NULL, label, -1);\n       emit_move_insn (target, trueval);\n       emit_label (label);\n       return target;\n@@ -5843,8 +5843,8 @@ emit_store_flag_force (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \n   emit_move_insn (target, trueval);\n   label = gen_label_rtx ();\n-  do_compare_rtx_and_jump (op0, op1, code, unsignedp, mode, NULL_RTX,\n-\t\t\t   NULL_RTX, label, -1);\n+  do_compare_rtx_and_jump (op0, op1, code, unsignedp, mode, NULL_RTX, NULL,\n+\t\t\t   label, -1);\n \n   emit_move_insn (target, falseval);\n   emit_label (label);\n@@ -5861,6 +5861,6 @@ do_cmp_and_jump (rtx arg1, rtx arg2, enum rtx_code op, machine_mode mode,\n \t\t rtx_code_label *label)\n {\n   int unsignedp = (op == LTU || op == LEU || op == GTU || op == GEU);\n-  do_compare_rtx_and_jump (arg1, arg2, op, unsignedp, mode,\n-\t\t\t   NULL_RTX, NULL_RTX, label, -1);\n+  do_compare_rtx_and_jump (arg1, arg2, op, unsignedp, mode, NULL_RTX,\n+\t\t\t   NULL, label, -1);\n }"}, {"sha": "8d75ef55f23e6e379172f5cb72f8ceacad6e4aac", "filename": "gcc/expr.c", "status": "modified", "additions": 95, "deletions": 82, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -3651,7 +3651,7 @@ emit_move_insn (rtx x, rtx y)\n /* Generate the body of an instruction to copy Y into X.\n    It may be a list of insns, if one insn isn't enough.  */\n \n-rtx\n+rtx_insn *\n gen_move_insn (rtx x, rtx y)\n {\n   rtx_insn *seq;\n@@ -3663,6 +3663,15 @@ gen_move_insn (rtx x, rtx y)\n   return seq;\n }\n \n+/* Same as above, but return rtx (used as a callback, which must have\n+   prototype compatible with other functions returning rtx).  */\n+\n+rtx\n+gen_move_insn_uncast (rtx x, rtx y)\n+{\n+  return gen_move_insn (x, y);\n+}\n+\n /* If Y is representable exactly in a narrower mode, and the target can\n    perform the extension directly from constant or memory, then emit the\n    move as an extension.  */\n@@ -8127,6 +8136,7 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \t\t    enum expand_modifier modifier)\n {\n   rtx op0, op1, op2, temp;\n+  rtx_code_label *lab;\n   tree type;\n   int unsignedp;\n   machine_mode mode;\n@@ -8936,13 +8946,13 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \tif (target != op0)\n \t  emit_move_insn (target, op0);\n \n-\ttemp = gen_label_rtx ();\n+\tlab = gen_label_rtx ();\n \tdo_compare_rtx_and_jump (target, cmpop1, comparison_code,\n-\t\t\t\t unsignedp, mode, NULL_RTX, NULL_RTX, temp,\n+\t\t\t\t unsignedp, mode, NULL_RTX, NULL, lab,\n \t\t\t\t -1);\n       }\n       emit_move_insn (target, op1);\n-      emit_label (temp);\n+      emit_label (lab);\n       return target;\n \n     case BIT_NOT_EXPR:\n@@ -9020,38 +9030,39 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n     case UNGE_EXPR:\n     case UNEQ_EXPR:\n     case LTGT_EXPR:\n-      temp = do_store_flag (ops,\n-\t\t\t    modifier != EXPAND_STACK_PARM ? target : NULL_RTX,\n-\t\t\t    tmode != VOIDmode ? tmode : mode);\n-      if (temp)\n-\treturn temp;\n-\n-      /* Use a compare and a jump for BLKmode comparisons, or for function\n-\t type comparisons is HAVE_canonicalize_funcptr_for_compare.  */\n-\n-      if ((target == 0\n-\t   || modifier == EXPAND_STACK_PARM\n-\t   || ! safe_from_p (target, treeop0, 1)\n-\t   || ! safe_from_p (target, treeop1, 1)\n-\t   /* Make sure we don't have a hard reg (such as function's return\n-\t      value) live across basic blocks, if not optimizing.  */\n-\t   || (!optimize && REG_P (target)\n-\t       && REGNO (target) < FIRST_PSEUDO_REGISTER)))\n-\ttarget = gen_reg_rtx (tmode != VOIDmode ? tmode : mode);\n+      {\n+\ttemp = do_store_flag (ops,\n+\t\t\t      modifier != EXPAND_STACK_PARM ? target : NULL_RTX,\n+\t\t\t      tmode != VOIDmode ? tmode : mode);\n+\tif (temp)\n+\t  return temp;\n \n-      emit_move_insn (target, const0_rtx);\n+\t/* Use a compare and a jump for BLKmode comparisons, or for function\n+\t   type comparisons is HAVE_canonicalize_funcptr_for_compare.  */\n+\n+\tif ((target == 0\n+\t     || modifier == EXPAND_STACK_PARM\n+\t     || ! safe_from_p (target, treeop0, 1)\n+\t     || ! safe_from_p (target, treeop1, 1)\n+\t     /* Make sure we don't have a hard reg (such as function's return\n+\t\tvalue) live across basic blocks, if not optimizing.  */\n+\t     || (!optimize && REG_P (target)\n+\t\t && REGNO (target) < FIRST_PSEUDO_REGISTER)))\n+\t  target = gen_reg_rtx (tmode != VOIDmode ? tmode : mode);\n \n-      op1 = gen_label_rtx ();\n-      jumpifnot_1 (code, treeop0, treeop1, op1, -1);\n+\temit_move_insn (target, const0_rtx);\n \n-      if (TYPE_PRECISION (type) == 1 && !TYPE_UNSIGNED (type))\n-\temit_move_insn (target, constm1_rtx);\n-      else\n-\temit_move_insn (target, const1_rtx);\n+\trtx_code_label *lab1 = gen_label_rtx ();\n+\tjumpifnot_1 (code, treeop0, treeop1, lab1, -1);\n \n-      emit_label (op1);\n-      return target;\n+\tif (TYPE_PRECISION (type) == 1 && !TYPE_UNSIGNED (type))\n+\t  emit_move_insn (target, constm1_rtx);\n+\telse\n+\t  emit_move_insn (target, const1_rtx);\n \n+\temit_label (lab1);\n+\treturn target;\n+      }\n     case COMPLEX_EXPR:\n       /* Get the rtx code of the operands.  */\n       op0 = expand_normal (treeop0);\n@@ -9274,58 +9285,60 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n       }\n \n     case COND_EXPR:\n-      /* A COND_EXPR with its type being VOID_TYPE represents a\n-\t conditional jump and is handled in\n-\t expand_gimple_cond_expr.  */\n-      gcc_assert (!VOID_TYPE_P (type));\n-\n-      /* Note that COND_EXPRs whose type is a structure or union\n-\t are required to be constructed to contain assignments of\n-\t a temporary variable, so that we can evaluate them here\n-\t for side effect only.  If type is void, we must do likewise.  */\n-\n-      gcc_assert (!TREE_ADDRESSABLE (type)\n-\t\t  && !ignore\n-\t\t  && TREE_TYPE (treeop1) != void_type_node\n-\t\t  && TREE_TYPE (treeop2) != void_type_node);\n-\n-      temp = expand_cond_expr_using_cmove (treeop0, treeop1, treeop2);\n-      if (temp)\n-\treturn temp;\n-\n-      /* If we are not to produce a result, we have no target.  Otherwise,\n-\t if a target was specified use it; it will not be used as an\n-\t intermediate target unless it is safe.  If no target, use a\n-\t temporary.  */\n-\n-      if (modifier != EXPAND_STACK_PARM\n-\t  && original_target\n-\t  && safe_from_p (original_target, treeop0, 1)\n-\t  && GET_MODE (original_target) == mode\n-\t  && !MEM_P (original_target))\n-\ttemp = original_target;\n-      else\n-\ttemp = assign_temp (type, 0, 1);\n-\n-      do_pending_stack_adjust ();\n-      NO_DEFER_POP;\n-      op0 = gen_label_rtx ();\n-      op1 = gen_label_rtx ();\n-      jumpifnot (treeop0, op0, -1);\n-      store_expr (treeop1, temp,\n-\t\t  modifier == EXPAND_STACK_PARM,\n-\t\t  false);\n-\n-      emit_jump_insn (gen_jump (op1));\n-      emit_barrier ();\n-      emit_label (op0);\n-      store_expr (treeop2, temp,\n-\t\t  modifier == EXPAND_STACK_PARM,\n-\t\t  false);\n+      {\n+\t/* A COND_EXPR with its type being VOID_TYPE represents a\n+\t   conditional jump and is handled in\n+\t   expand_gimple_cond_expr.  */\n+\tgcc_assert (!VOID_TYPE_P (type));\n+\n+\t/* Note that COND_EXPRs whose type is a structure or union\n+\t   are required to be constructed to contain assignments of\n+\t   a temporary variable, so that we can evaluate them here\n+\t   for side effect only.  If type is void, we must do likewise.  */\n+\n+\tgcc_assert (!TREE_ADDRESSABLE (type)\n+\t\t    && !ignore\n+\t\t    && TREE_TYPE (treeop1) != void_type_node\n+\t\t    && TREE_TYPE (treeop2) != void_type_node);\n+\n+\ttemp = expand_cond_expr_using_cmove (treeop0, treeop1, treeop2);\n+\tif (temp)\n+\t  return temp;\n \n-      emit_label (op1);\n-      OK_DEFER_POP;\n-      return temp;\n+\t/* If we are not to produce a result, we have no target.  Otherwise,\n+\t   if a target was specified use it; it will not be used as an\n+\t   intermediate target unless it is safe.  If no target, use a\n+\t   temporary.  */\n+\n+\tif (modifier != EXPAND_STACK_PARM\n+\t    && original_target\n+\t    && safe_from_p (original_target, treeop0, 1)\n+\t    && GET_MODE (original_target) == mode\n+\t    && !MEM_P (original_target))\n+\t  temp = original_target;\n+\telse\n+\t  temp = assign_temp (type, 0, 1);\n+\n+\tdo_pending_stack_adjust ();\n+\tNO_DEFER_POP;\n+\trtx_code_label *lab0 = gen_label_rtx ();\n+\trtx_code_label *lab1 = gen_label_rtx ();\n+\tjumpifnot (treeop0, lab0, -1);\n+\tstore_expr (treeop1, temp,\n+\t\t    modifier == EXPAND_STACK_PARM,\n+\t\t    false);\n+\n+\temit_jump_insn (gen_jump (lab1));\n+\temit_barrier ();\n+\temit_label (lab0);\n+\tstore_expr (treeop2, temp,\n+\t\t    modifier == EXPAND_STACK_PARM,\n+\t\t    false);\n+\n+\temit_label (lab1);\n+\tOK_DEFER_POP;\n+\treturn temp;\n+      }\n \n     case VEC_COND_EXPR:\n       target = expand_vec_cond_expr (type, treeop0, treeop1, treeop2, target);"}, {"sha": "e3afa8db1f6a2735f6860266f7fb62f352efaa0d", "filename": "gcc/expr.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -203,7 +203,8 @@ extern rtx store_by_pieces (rtx, unsigned HOST_WIDE_INT,\n \n /* Emit insns to set X from Y.  */\n extern rtx_insn *emit_move_insn (rtx, rtx);\n-extern rtx gen_move_insn (rtx, rtx);\n+extern rtx_insn *gen_move_insn (rtx, rtx);\n+extern rtx gen_move_insn_uncast (rtx, rtx);\n \n /* Emit insns to set X from Y, with no frills.  */\n extern rtx_insn *emit_move_insn_1 (rtx, rtx);"}, {"sha": "7d2d7e4abcaa4ee11222783391bfb6e0c554e7cd", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -5786,7 +5786,7 @@ convert_jumps_to_returns (basic_block last_bb, bool simple_p,\n \t    dest = simple_return_rtx;\n \t  else\n \t    dest = ret_rtx;\n-\t  if (!redirect_jump (jump, dest, 0))\n+\t  if (!redirect_jump (as_a <rtx_jump_insn *> (jump), dest, 0))\n \t    {\n \t      if (HAVE_simple_return && simple_p)\n \t\t{"}, {"sha": "efbe4f4cbb9b5a32704c2d489f6a366f4a5bd056", "filename": "gcc/gcse.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -2229,7 +2229,8 @@ pre_insert_copy_insn (struct gcse_expr *expr, rtx_insn *insn)\n   int regno = REGNO (reg);\n   int indx = expr->bitmap_index;\n   rtx pat = PATTERN (insn);\n-  rtx set, first_set, new_insn;\n+  rtx set, first_set;\n+  rtx_insn *new_insn;\n   rtx old_reg;\n   int i;\n "}, {"sha": "b00aaa4afb9a8f9ee0218e474e351fb522c1f5b1", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -4444,9 +4444,10 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n       else\n \tnew_dest_label = block_label (new_dest);\n \n+      rtx_jump_insn *jump_insn = as_a <rtx_jump_insn *> (jump);\n       if (reversep\n-\t  ? ! invert_jump_1 (jump, new_dest_label)\n-\t  : ! redirect_jump_1 (jump, new_dest_label))\n+\t  ? ! invert_jump_1 (jump_insn, new_dest_label)\n+\t  : ! redirect_jump_1 (jump_insn, new_dest_label))\n \tgoto cancel;\n     }\n \n@@ -4457,7 +4458,8 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n \n   if (other_bb != new_dest)\n     {\n-      redirect_jump_2 (jump, old_dest, new_dest_label, 0, reversep);\n+      redirect_jump_2 (as_a <rtx_jump_insn *> (jump), old_dest, new_dest_label,\n+\t\t       0, reversep);\n \n       redirect_edge_succ (BRANCH_EDGE (test_bb), new_dest);\n       if (reversep)"}, {"sha": "2a64d9a5afff6752e4ada30e2ce3933de27047b6", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 48, "deletions": 49, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -422,7 +422,7 @@ expand_arith_overflow_result_store (tree lhs, rtx target,\n       lres = convert_modes (tgtmode, mode, res, uns);\n       gcc_assert (GET_MODE_PRECISION (tgtmode) < GET_MODE_PRECISION (mode));\n       do_compare_rtx_and_jump (res, convert_modes (mode, tgtmode, lres, uns),\n-\t\t\t       EQ, true, mode, NULL_RTX, NULL_RTX, done_label,\n+\t\t\t       EQ, true, mode, NULL_RTX, NULL, done_label,\n \t\t\t       PROB_VERY_LIKELY);\n       write_complex_part (target, const1_rtx, true);\n       emit_label (done_label);\n@@ -569,7 +569,7 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n \t      : CONST_SCALAR_INT_P (op1)))\n \ttem = op1;\n       do_compare_rtx_and_jump (res, tem, code == PLUS_EXPR ? GEU : LEU,\n-\t\t\t       true, mode, NULL_RTX, NULL_RTX, done_label,\n+\t\t\t       true, mode, NULL_RTX, NULL, done_label,\n \t\t\t       PROB_VERY_LIKELY);\n       goto do_error_label;\n     }\n@@ -584,7 +584,7 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n       rtx tem = expand_binop (mode, add_optab,\n \t\t\t      code == PLUS_EXPR ? res : op0, sgn,\n \t\t\t      NULL_RTX, false, OPTAB_LIB_WIDEN);\n-      do_compare_rtx_and_jump (tem, op1, GEU, true, mode, NULL_RTX, NULL_RTX,\n+      do_compare_rtx_and_jump (tem, op1, GEU, true, mode, NULL_RTX, NULL,\n \t\t\t       done_label, PROB_VERY_LIKELY);\n       goto do_error_label;\n     }\n@@ -627,8 +627,8 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n       else if (pos_neg == 3)\n \t/* If ARG0 is not known to be always positive, check at runtime.  */\n \tdo_compare_rtx_and_jump (op0, const0_rtx, LT, false, mode, NULL_RTX,\n-\t\t\t\t NULL_RTX, do_error, PROB_VERY_UNLIKELY);\n-      do_compare_rtx_and_jump (op1, op0, LEU, true, mode, NULL_RTX, NULL_RTX,\n+\t\t\t\t NULL, do_error, PROB_VERY_UNLIKELY);\n+      do_compare_rtx_and_jump (op1, op0, LEU, true, mode, NULL_RTX, NULL,\n \t\t\t       done_label, PROB_VERY_LIKELY);\n       goto do_error_label;\n     }\n@@ -642,7 +642,7 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n \t\t\t  OPTAB_LIB_WIDEN);\n       rtx tem = expand_binop (mode, add_optab, op1, sgn, NULL_RTX, false,\n \t\t\t      OPTAB_LIB_WIDEN);\n-      do_compare_rtx_and_jump (op0, tem, LTU, true, mode, NULL_RTX, NULL_RTX,\n+      do_compare_rtx_and_jump (op0, tem, LTU, true, mode, NULL_RTX, NULL,\n \t\t\t       done_label, PROB_VERY_LIKELY);\n       goto do_error_label;\n     }\n@@ -655,7 +655,7 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n       res = expand_binop (mode, add_optab, op0, op1, NULL_RTX, false,\n \t\t\t  OPTAB_LIB_WIDEN);\n       do_compare_rtx_and_jump (res, const0_rtx, LT, false, mode, NULL_RTX,\n-\t\t\t       NULL_RTX, do_error, PROB_VERY_UNLIKELY);\n+\t\t\t       NULL, do_error, PROB_VERY_UNLIKELY);\n       rtx tem = op1;\n       /* The operation is commutative, so we can pick operand to compare\n \t against.  For prec <= BITS_PER_WORD, I think preferring REG operand\n@@ -668,7 +668,7 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n \t  ? (CONST_SCALAR_INT_P (op1) && REG_P (op0))\n \t  : CONST_SCALAR_INT_P (op0))\n \ttem = op0;\n-      do_compare_rtx_and_jump (res, tem, GEU, true, mode, NULL_RTX, NULL_RTX,\n+      do_compare_rtx_and_jump (res, tem, GEU, true, mode, NULL_RTX, NULL,\n \t\t\t       done_label, PROB_VERY_LIKELY);\n       goto do_error_label;\n     }\n@@ -698,26 +698,26 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n \t  tem = expand_binop (mode, ((pos_neg == 1) ^ (code == MINUS_EXPR))\n \t\t\t\t    ? and_optab : ior_optab,\n \t\t\t      op0, res, NULL_RTX, false, OPTAB_LIB_WIDEN);\n-\t  do_compare_rtx_and_jump (tem, const0_rtx, GE, false, mode, NULL_RTX,\n-\t\t\t\t   NULL_RTX, done_label, PROB_VERY_LIKELY);\n+\t  do_compare_rtx_and_jump (tem, const0_rtx, GE, false, mode, NULL,\n+\t\t\t\t   NULL, done_label, PROB_VERY_LIKELY);\n \t}\n       else\n \t{\n \t  rtx_code_label *do_ior_label = gen_label_rtx ();\n \t  do_compare_rtx_and_jump (op1, const0_rtx,\n \t\t\t\t   code == MINUS_EXPR ? GE : LT, false, mode,\n-\t\t\t\t   NULL_RTX, NULL_RTX, do_ior_label,\n+\t\t\t\t   NULL_RTX, NULL, do_ior_label,\n \t\t\t\t   PROB_EVEN);\n \t  tem = expand_binop (mode, and_optab, op0, res, NULL_RTX, false,\n \t\t\t      OPTAB_LIB_WIDEN);\n \t  do_compare_rtx_and_jump (tem, const0_rtx, GE, false, mode, NULL_RTX,\n-\t\t\t\t   NULL_RTX, done_label, PROB_VERY_LIKELY);\n+\t\t\t\t   NULL, done_label, PROB_VERY_LIKELY);\n \t  emit_jump (do_error);\n \t  emit_label (do_ior_label);\n \t  tem = expand_binop (mode, ior_optab, op0, res, NULL_RTX, false,\n \t\t\t      OPTAB_LIB_WIDEN);\n \t  do_compare_rtx_and_jump (tem, const0_rtx, GE, false, mode, NULL_RTX,\n-\t\t\t\t   NULL_RTX, done_label, PROB_VERY_LIKELY);\n+\t\t\t\t   NULL, done_label, PROB_VERY_LIKELY);\n \t}\n       goto do_error_label;\n     }\n@@ -730,14 +730,14 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n       res = expand_binop (mode, sub_optab, op0, op1, NULL_RTX, false,\n \t\t\t  OPTAB_LIB_WIDEN);\n       rtx_code_label *op0_geu_op1 = gen_label_rtx ();\n-      do_compare_rtx_and_jump (op0, op1, GEU, true, mode, NULL_RTX, NULL_RTX,\n+      do_compare_rtx_and_jump (op0, op1, GEU, true, mode, NULL_RTX, NULL,\n \t\t\t       op0_geu_op1, PROB_EVEN);\n       do_compare_rtx_and_jump (res, const0_rtx, LT, false, mode, NULL_RTX,\n-\t\t\t       NULL_RTX, done_label, PROB_VERY_LIKELY);\n+\t\t\t       NULL, done_label, PROB_VERY_LIKELY);\n       emit_jump (do_error);\n       emit_label (op0_geu_op1);\n       do_compare_rtx_and_jump (res, const0_rtx, GE, false, mode, NULL_RTX,\n-\t\t\t       NULL_RTX, done_label, PROB_VERY_LIKELY);\n+\t\t\t       NULL, done_label, PROB_VERY_LIKELY);\n       goto do_error_label;\n     }\n \n@@ -816,12 +816,12 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n       /* If the op1 is negative, we have to use a different check.  */\n       if (pos_neg == 3)\n \tdo_compare_rtx_and_jump (op1, const0_rtx, LT, false, mode, NULL_RTX,\n-\t\t\t\t NULL_RTX, sub_check, PROB_EVEN);\n+\t\t\t\t NULL, sub_check, PROB_EVEN);\n \n       /* Compare the result of the operation with one of the operands.  */\n       if (pos_neg & 1)\n \tdo_compare_rtx_and_jump (res, op0, code == PLUS_EXPR ? GE : LE,\n-\t\t\t\t false, mode, NULL_RTX, NULL_RTX, done_label,\n+\t\t\t\t false, mode, NULL_RTX, NULL, done_label,\n \t\t\t\t PROB_VERY_LIKELY);\n \n       /* If we get here, we have to print the error.  */\n@@ -835,7 +835,7 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n       /* We have k = a + b for b < 0 here.  k <= a must hold.  */\n       if (pos_neg & 2)\n \tdo_compare_rtx_and_jump (res, op0, code == PLUS_EXPR ? LE : GE,\n-\t\t\t\t false, mode, NULL_RTX, NULL_RTX, done_label,\n+\t\t\t\t false, mode, NULL_RTX, NULL, done_label,\n \t\t\t\t PROB_VERY_LIKELY);\n     }\n \n@@ -931,7 +931,7 @@ expand_neg_overflow (location_t loc, tree lhs, tree arg1, bool is_ubsan)\n \n       /* Compare the operand with the most negative value.  */\n       rtx minv = expand_normal (TYPE_MIN_VALUE (TREE_TYPE (arg1)));\n-      do_compare_rtx_and_jump (op1, minv, NE, true, mode, NULL_RTX, NULL_RTX,\n+      do_compare_rtx_and_jump (op1, minv, NE, true, mode, NULL_RTX, NULL,\n \t\t\t       done_label, PROB_VERY_LIKELY);\n     }\n \n@@ -1068,15 +1068,15 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t  ops.location = loc;\n \t  res = expand_expr_real_2 (&ops, NULL_RTX, mode, EXPAND_NORMAL);\n \t  do_compare_rtx_and_jump (op1, const0_rtx, EQ, true, mode, NULL_RTX,\n-\t\t\t\t   NULL_RTX, done_label, PROB_VERY_LIKELY);\n+\t\t\t\t   NULL, done_label, PROB_VERY_LIKELY);\n \t  goto do_error_label;\n \tcase 3:\n \t  rtx_code_label *do_main_label;\n \t  do_main_label = gen_label_rtx ();\n \t  do_compare_rtx_and_jump (op0, const0_rtx, GE, false, mode, NULL_RTX,\n-\t\t\t\t   NULL_RTX, do_main_label, PROB_VERY_LIKELY);\n+\t\t\t\t   NULL, do_main_label, PROB_VERY_LIKELY);\n \t  do_compare_rtx_and_jump (op1, const0_rtx, EQ, true, mode, NULL_RTX,\n-\t\t\t\t   NULL_RTX, do_main_label, PROB_VERY_LIKELY);\n+\t\t\t\t   NULL, do_main_label, PROB_VERY_LIKELY);\n \t  write_complex_part (target, const1_rtx, true);\n \t  emit_label (do_main_label);\n \t  goto do_main;\n@@ -1113,15 +1113,15 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t  ops.location = loc;\n \t  res = expand_expr_real_2 (&ops, NULL_RTX, mode, EXPAND_NORMAL);\n \t  do_compare_rtx_and_jump (op0, const0_rtx, EQ, true, mode, NULL_RTX,\n-\t\t\t\t   NULL_RTX, done_label, PROB_VERY_LIKELY);\n+\t\t\t\t   NULL, done_label, PROB_VERY_LIKELY);\n \t  do_compare_rtx_and_jump (op0, constm1_rtx, NE, true, mode, NULL_RTX,\n-\t\t\t\t   NULL_RTX, do_error, PROB_VERY_UNLIKELY);\n+\t\t\t\t   NULL, do_error, PROB_VERY_UNLIKELY);\n \t  int prec;\n \t  prec = GET_MODE_PRECISION (mode);\n \t  rtx sgn;\n \t  sgn = immed_wide_int_const (wi::min_value (prec, SIGNED), mode);\n \t  do_compare_rtx_and_jump (op1, sgn, EQ, true, mode, NULL_RTX,\n-\t\t\t\t   NULL_RTX, done_label, PROB_VERY_LIKELY);\n+\t\t\t\t   NULL, done_label, PROB_VERY_LIKELY);\n \t  goto do_error_label;\n \tcase 3:\n \t  /* Rest of handling of this case after res is computed.  */\n@@ -1167,7 +1167,7 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t      tem = expand_binop (mode, and_optab, op0, op1, NULL_RTX, false,\n \t\t\t\t  OPTAB_LIB_WIDEN);\n \t      do_compare_rtx_and_jump (tem, const0_rtx, EQ, true, mode,\n-\t\t\t\t       NULL_RTX, NULL_RTX, done_label,\n+\t\t\t\t       NULL_RTX, NULL, done_label,\n \t\t\t\t       PROB_VERY_LIKELY);\n \t      goto do_error_label;\n \t    }\n@@ -1185,8 +1185,7 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t  tem = expand_binop (mode, and_optab, op0, op1, NULL_RTX, false,\n \t\t\t      OPTAB_LIB_WIDEN);\n \t  do_compare_rtx_and_jump (tem, const0_rtx, GE, false, mode, NULL_RTX,\n-\t\t\t\t   NULL_RTX, after_negate_label,\n-\t\t\t\t   PROB_VERY_LIKELY);\n+\t\t\t\t   NULL, after_negate_label, PROB_VERY_LIKELY);\n \t  /* Both arguments negative here, negate them and continue with\n \t     normal unsigned overflow checking multiplication.  */\n \t  emit_move_insn (op0, expand_unop (mode, neg_optab, op0,\n@@ -1202,13 +1201,13 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t  tem2 = expand_binop (mode, xor_optab, op0, op1, NULL_RTX, false,\n \t\t\t       OPTAB_LIB_WIDEN);\n \t  do_compare_rtx_and_jump (tem2, const0_rtx, GE, false, mode, NULL_RTX,\n-\t\t\t\t   NULL_RTX, do_main_label, PROB_VERY_LIKELY);\n+\t\t\t\t   NULL, do_main_label, PROB_VERY_LIKELY);\n \t  /* One argument is negative here, the other positive.  This\n \t     overflows always, unless one of the arguments is 0.  But\n \t     if e.g. s2 is 0, (U) s1 * 0 doesn't overflow, whatever s1\n \t     is, thus we can keep do_main code oring in overflow as is.  */\n \t  do_compare_rtx_and_jump (tem, const0_rtx, EQ, true, mode, NULL_RTX,\n-\t\t\t\t   NULL_RTX, do_main_label, PROB_VERY_LIKELY);\n+\t\t\t\t   NULL, do_main_label, PROB_VERY_LIKELY);\n \t  write_complex_part (target, const1_rtx, true);\n \t  emit_label (do_main_label);\n \t  goto do_main;\n@@ -1274,7 +1273,7 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t    /* For the unsigned multiplication, there was overflow if\n \t       HIPART is non-zero.  */\n \t    do_compare_rtx_and_jump (hipart, const0_rtx, EQ, true, mode,\n-\t\t\t\t     NULL_RTX, NULL_RTX, done_label,\n+\t\t\t\t     NULL_RTX, NULL, done_label,\n \t\t\t\t     PROB_VERY_LIKELY);\n \t  else\n \t    {\n@@ -1284,7 +1283,7 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t\t the high half.  There was overflow if\n \t\t HIPART is different from RES < 0 ? -1 : 0.  */\n \t      do_compare_rtx_and_jump (signbit, hipart, EQ, true, mode,\n-\t\t\t\t       NULL_RTX, NULL_RTX, done_label,\n+\t\t\t\t       NULL_RTX, NULL, done_label,\n \t\t\t\t       PROB_VERY_LIKELY);\n \t    }\n \t}\n@@ -1377,12 +1376,12 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \n \t  if (!op0_small_p)\n \t    do_compare_rtx_and_jump (signbit0, hipart0, NE, true, hmode,\n-\t\t\t\t     NULL_RTX, NULL_RTX, large_op0,\n+\t\t\t\t     NULL_RTX, NULL, large_op0,\n \t\t\t\t     PROB_UNLIKELY);\n \n \t  if (!op1_small_p)\n \t    do_compare_rtx_and_jump (signbit1, hipart1, NE, true, hmode,\n-\t\t\t\t     NULL_RTX, NULL_RTX, small_op0_large_op1,\n+\t\t\t\t     NULL_RTX, NULL, small_op0_large_op1,\n \t\t\t\t     PROB_UNLIKELY);\n \n \t  /* If both op0 and op1 are sign (!uns) or zero (uns) extended from\n@@ -1428,7 +1427,7 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \n \t  if (!op1_small_p)\n \t    do_compare_rtx_and_jump (signbit1, hipart1, NE, true, hmode,\n-\t\t\t\t     NULL_RTX, NULL_RTX, both_ops_large,\n+\t\t\t\t     NULL_RTX, NULL, both_ops_large,\n \t\t\t\t     PROB_UNLIKELY);\n \n \t  /* If op1 is sign (!uns) or zero (uns) extended from hmode to mode,\n@@ -1465,7 +1464,7 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t\temit_jump (after_hipart_neg);\n \t      else if (larger_sign != -1)\n \t\tdo_compare_rtx_and_jump (hipart, const0_rtx, GE, false, hmode,\n-\t\t\t\t\t NULL_RTX, NULL_RTX, after_hipart_neg,\n+\t\t\t\t\t NULL_RTX, NULL, after_hipart_neg,\n \t\t\t\t\t PROB_EVEN);\n \n \t      tem = convert_modes (mode, hmode, lopart, 1);\n@@ -1481,7 +1480,7 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t\temit_jump (after_lopart_neg);\n \t      else if (smaller_sign != -1)\n \t\tdo_compare_rtx_and_jump (lopart, const0_rtx, GE, false, hmode,\n-\t\t\t\t\t NULL_RTX, NULL_RTX, after_lopart_neg,\n+\t\t\t\t\t NULL_RTX, NULL, after_lopart_neg,\n \t\t\t\t\t PROB_EVEN);\n \n \t      tem = expand_simple_binop (mode, MINUS, loxhi, larger, NULL_RTX,\n@@ -1510,7 +1509,7 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t\t\t\t\t hprec - 1, NULL_RTX, 0);\n \n \t  do_compare_rtx_and_jump (signbitloxhi, hipartloxhi, NE, true, hmode,\n-\t\t\t\t   NULL_RTX, NULL_RTX, do_overflow,\n+\t\t\t\t   NULL_RTX, NULL, do_overflow,\n \t\t\t\t   PROB_VERY_UNLIKELY);\n \n \t  /* res = (loxhi << (bitsize / 2)) | (hmode) lo0xlo1;  */\n@@ -1546,7 +1545,7 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t\t  tem = expand_simple_binop (hmode, PLUS, hipart0, const1_rtx,\n \t\t\t\t\t     NULL_RTX, 1, OPTAB_DIRECT);\n \t\t  do_compare_rtx_and_jump (tem, const1_rtx, GTU, true, hmode,\n-\t\t\t\t\t   NULL_RTX, NULL_RTX, do_error,\n+\t\t\t\t\t   NULL_RTX, NULL, do_error,\n \t\t\t\t\t   PROB_VERY_UNLIKELY);\n \t\t}\n \n@@ -1555,7 +1554,7 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t\t  tem = expand_simple_binop (hmode, PLUS, hipart1, const1_rtx,\n \t\t\t\t\t     NULL_RTX, 1, OPTAB_DIRECT);\n \t\t  do_compare_rtx_and_jump (tem, const1_rtx, GTU, true, hmode,\n-\t\t\t\t\t   NULL_RTX, NULL_RTX, do_error,\n+\t\t\t\t\t   NULL_RTX, NULL, do_error,\n \t\t\t\t\t   PROB_VERY_UNLIKELY);\n \t\t}\n \n@@ -1566,18 +1565,18 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t\temit_jump (hipart_different);\n \t      else if (op0_sign == 1 || op1_sign == 1)\n \t\tdo_compare_rtx_and_jump (hipart0, hipart1, NE, true, hmode,\n-\t\t\t\t\t NULL_RTX, NULL_RTX, hipart_different,\n+\t\t\t\t\t NULL_RTX, NULL, hipart_different,\n \t\t\t\t\t PROB_EVEN);\n \n \t      do_compare_rtx_and_jump (res, const0_rtx, LT, false, mode,\n-\t\t\t\t       NULL_RTX, NULL_RTX, do_error,\n+\t\t\t\t       NULL_RTX, NULL, do_error,\n \t\t\t\t       PROB_VERY_UNLIKELY);\n \t      emit_jump (done_label);\n \n \t      emit_label (hipart_different);\n \n \t      do_compare_rtx_and_jump (res, const0_rtx, GE, false, mode,\n-\t\t\t\t       NULL_RTX, NULL_RTX, do_error,\n+\t\t\t\t       NULL_RTX, NULL, do_error,\n \t\t\t\t       PROB_VERY_UNLIKELY);\n \t      emit_jump (done_label);\n \t    }\n@@ -1623,7 +1622,7 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n     {\n       rtx_code_label *all_done_label = gen_label_rtx ();\n       do_compare_rtx_and_jump (res, const0_rtx, GE, false, mode, NULL_RTX,\n-\t\t\t       NULL_RTX, all_done_label, PROB_VERY_LIKELY);\n+\t\t\t       NULL, all_done_label, PROB_VERY_LIKELY);\n       write_complex_part (target, const1_rtx, true);\n       emit_label (all_done_label);\n     }\n@@ -1634,13 +1633,13 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n       rtx_code_label *all_done_label = gen_label_rtx ();\n       rtx_code_label *set_noovf = gen_label_rtx ();\n       do_compare_rtx_and_jump (op1, const0_rtx, GE, false, mode, NULL_RTX,\n-\t\t\t       NULL_RTX, all_done_label, PROB_VERY_LIKELY);\n+\t\t\t       NULL, all_done_label, PROB_VERY_LIKELY);\n       write_complex_part (target, const1_rtx, true);\n       do_compare_rtx_and_jump (op0, const0_rtx, EQ, true, mode, NULL_RTX,\n-\t\t\t       NULL_RTX, set_noovf, PROB_VERY_LIKELY);\n+\t\t\t       NULL, set_noovf, PROB_VERY_LIKELY);\n       do_compare_rtx_and_jump (op0, constm1_rtx, NE, true, mode, NULL_RTX,\n-\t\t\t       NULL_RTX, all_done_label, PROB_VERY_UNLIKELY);\n-      do_compare_rtx_and_jump (op1, res, NE, true, mode, NULL_RTX, NULL_RTX,\n+\t\t\t       NULL, all_done_label, PROB_VERY_UNLIKELY);\n+      do_compare_rtx_and_jump (op1, res, NE, true, mode, NULL_RTX, NULL,\n \t\t\t       all_done_label, PROB_VERY_UNLIKELY);\n       emit_label (set_noovf);\n       write_complex_part (target, const0_rtx, true);"}, {"sha": "47b57252bb6a73cc722b2423fa5cdffd7b9cbcd7", "filename": "gcc/ira.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -4988,7 +4988,7 @@ split_live_ranges_for_shrink_wrap (void)\n \n       if (newreg)\n \t{\n-\t  rtx new_move = gen_move_insn (newreg, dest);\n+\t  rtx_insn *new_move = gen_move_insn (newreg, dest);\n \t  emit_insn_after (new_move, bb_note (call_dom));\n \t  if (dump_file)\n \t    {"}, {"sha": "66eb1d99a11d786697d7c2a22a4d25a6ab4156ce", "filename": "gcc/jump.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -1580,9 +1580,9 @@ redirect_jump_1 (rtx_insn *jump, rtx nlabel)\n    (this can only occur when trying to produce return insns).  */\n \n int\n-redirect_jump (rtx_insn *jump, rtx nlabel, int delete_unused)\n+redirect_jump (rtx_jump_insn *jump, rtx nlabel, int delete_unused)\n {\n-  rtx olabel = JUMP_LABEL (jump);\n+  rtx olabel = jump->jump_label ();\n \n   if (!nlabel)\n     {\n@@ -1612,7 +1612,7 @@ redirect_jump (rtx_insn *jump, rtx nlabel, int delete_unused)\n    If DELETE_UNUSED is positive, delete related insn to OLABEL if its ref\n    count has dropped to zero.  */\n void\n-redirect_jump_2 (rtx_insn *jump, rtx olabel, rtx nlabel, int delete_unused,\n+redirect_jump_2 (rtx_jump_insn *jump, rtx olabel, rtx nlabel, int delete_unused,\n \t\t int invert)\n {\n   rtx note;\n@@ -1700,7 +1700,7 @@ invert_exp_1 (rtx x, rtx insn)\n    inversion and redirection.  */\n \n int\n-invert_jump_1 (rtx_insn *jump, rtx nlabel)\n+invert_jump_1 (rtx_jump_insn *jump, rtx nlabel)\n {\n   rtx x = pc_set (jump);\n   int ochanges;\n@@ -1724,7 +1724,7 @@ invert_jump_1 (rtx_insn *jump, rtx nlabel)\n    NLABEL instead of where it jumps now.  Return true if successful.  */\n \n int\n-invert_jump (rtx_insn *jump, rtx nlabel, int delete_unused)\n+invert_jump (rtx_jump_insn *jump, rtx nlabel, int delete_unused)\n {\n   rtx olabel = JUMP_LABEL (jump);\n "}, {"sha": "afd1da093369eaa236fc0bb6f083edfa503dd117", "filename": "gcc/loop-doloop.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Floop-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Floop-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-doloop.c?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -365,7 +365,7 @@ static bool\n add_test (rtx cond, edge *e, basic_block dest)\n {\n   rtx_insn *seq, *jump;\n-  rtx label;\n+  rtx_code_label *label;\n   machine_mode mode;\n   rtx op0 = XEXP (cond, 0), op1 = XEXP (cond, 1);\n   enum rtx_code code = GET_CODE (cond);\n@@ -379,8 +379,7 @@ add_test (rtx cond, edge *e, basic_block dest)\n   op0 = force_operand (op0, NULL_RTX);\n   op1 = force_operand (op1, NULL_RTX);\n   label = block_label (dest);\n-  do_compare_rtx_and_jump (op0, op1, code, 0, mode, NULL_RTX,\n-\t\t\t   NULL_RTX, label, -1);\n+  do_compare_rtx_and_jump (op0, op1, code, 0, mode, NULL_RTX, NULL, label, -1);\n \n   jump = get_last_insn ();\n   if (!jump || !JUMP_P (jump))\n@@ -432,7 +431,7 @@ doloop_modify (struct loop *loop, struct niter_desc *desc,\n   rtx tmp, noloop = NULL_RTX;\n   rtx_insn *sequence;\n   rtx_insn *jump_insn;\n-  rtx jump_label;\n+  rtx_code_label *jump_label;\n   int nonneg = 0;\n   bool increment_count;\n   basic_block loop_end = desc->out_edge->src;\n@@ -627,7 +626,7 @@ doloop_optimize (struct loop *loop)\n   rtx doloop_seq, doloop_pat, doloop_reg;\n   rtx count;\n   widest_int iterations, iterations_max;\n-  rtx start_label;\n+  rtx_code_label *start_label;\n   rtx condition;\n   unsigned level, est_niter;\n   int max_cost;"}, {"sha": "f1d2ea5c7b4c5054984c07940ff4c0c79686cfb0", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -794,10 +794,11 @@ split_edge_and_insert (edge e, rtx_insn *insns)\n    in order to create a jump.  */\n \n static rtx_insn *\n-compare_and_jump_seq (rtx op0, rtx op1, enum rtx_code comp, rtx label, int prob,\n-\t\t      rtx_insn *cinsn)\n+compare_and_jump_seq (rtx op0, rtx op1, enum rtx_code comp,\n+\t\t      rtx_code_label *label, int prob, rtx_insn *cinsn)\n {\n-  rtx_insn *seq, *jump;\n+  rtx_insn *seq;\n+  rtx_jump_insn *jump;\n   rtx cond;\n   machine_mode mode;\n \n@@ -816,8 +817,7 @@ compare_and_jump_seq (rtx op0, rtx op1, enum rtx_code comp, rtx label, int prob,\n       gcc_assert (rtx_equal_p (op0, XEXP (cond, 0)));\n       gcc_assert (rtx_equal_p (op1, XEXP (cond, 1)));\n       emit_jump_insn (copy_insn (PATTERN (cinsn)));\n-      jump = get_last_insn ();\n-      gcc_assert (JUMP_P (jump));\n+      jump = as_a <rtx_jump_insn *> (get_last_insn ());\n       JUMP_LABEL (jump) = JUMP_LABEL (cinsn);\n       LABEL_NUSES (JUMP_LABEL (jump))++;\n       redirect_jump (jump, label, 0);\n@@ -829,10 +829,9 @@ compare_and_jump_seq (rtx op0, rtx op1, enum rtx_code comp, rtx label, int prob,\n       op0 = force_operand (op0, NULL_RTX);\n       op1 = force_operand (op1, NULL_RTX);\n       do_compare_rtx_and_jump (op0, op1, comp, 0,\n-\t\t\t       mode, NULL_RTX, NULL_RTX, label, -1);\n-      jump = get_last_insn ();\n-      gcc_assert (JUMP_P (jump));\n-      JUMP_LABEL (jump) = label;\n+\t\t\t       mode, NULL_RTX, NULL, label, -1);\n+      jump = as_a <rtx_jump_insn *> (get_last_insn ());\n+      jump->set_jump_target (label);\n       LABEL_NUSES (label)++;\n     }\n   add_int_reg_note (jump, REG_BR_PROB, prob);"}, {"sha": "c0f29956edddc8b3f0b3fe6ac4b9f89c4db9d117", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -1063,9 +1063,8 @@ emit_spill_move (bool to_p, rtx mem_pseudo, rtx val)\n \t  LRA_SUBREG_P (mem_pseudo) = 1;\n \t}\n     }\n-  return as_a <rtx_insn *> (to_p\n-\t\t\t    ? gen_move_insn (mem_pseudo, val)\n-\t\t\t    : gen_move_insn (val, mem_pseudo));\n+  return to_p ? gen_move_insn (mem_pseudo, val)\n+\t      : gen_move_insn (val, mem_pseudo);\n }\n \n /* Process a special case insn (register move), return true if we\n@@ -4528,7 +4527,7 @@ struct usage_insns\n static struct usage_insns *usage_insns;\n \n static void\n-setup_next_usage_insn (int regno, rtx_insn *insn, int reloads_num, bool after_p)\n+setup_next_usage_insn (int regno, rtx insn, int reloads_num, bool after_p)\n {\n   usage_insns[regno].check = curr_usage_insns_check;\n   usage_insns[regno].insns = insn;\n@@ -4541,7 +4540,7 @@ setup_next_usage_insn (int regno, rtx_insn *insn, int reloads_num, bool after_p)\n    optional debug insns finished by a non-debug insn using REGNO.\n    RELOADS_NUM is current number of reload insns processed so far.  */\n static void\n-add_next_usage_insn (int regno, rtx_insn *insn, int reloads_num)\n+add_next_usage_insn (int regno, rtx insn, int reloads_num)\n {\n   rtx next_usage_insns;\n \n@@ -4763,7 +4762,7 @@ inherit_reload_reg (bool def_p, int original_regno,\n \t\t   \"    Inheritance reuse change %d->%d (bb%d):\\n\",\n \t\t   original_regno, REGNO (new_reg),\n \t\t   BLOCK_FOR_INSN (usage_insn)->index);\n-\t  dump_insn_slim (lra_dump_file, usage_insn);\n+\t  dump_insn_slim (lra_dump_file, as_a <rtx_insn *> (usage_insn));\n \t}\n     }\n   if (lra_dump_file != NULL)\n@@ -5023,7 +5022,7 @@ split_reg (bool before_p, int original_regno, rtx_insn *insn,\n \t{\n \t  fprintf (lra_dump_file, \"    Split reuse change %d->%d:\\n\",\n \t\t   original_regno, REGNO (new_reg));\n-\t  dump_insn_slim (lra_dump_file, usage_insn);\n+\t  dump_insn_slim (lra_dump_file, as_a <rtx_insn *> (usage_insn));\n \t}\n     }\n   lra_assert (NOTE_P (usage_insn) || NONDEBUG_INSN_P (usage_insn));\n@@ -5564,7 +5563,7 @@ inherit_in_ebb (rtx_insn *head, rtx_insn *tail)\n \t\t\t   || reg_renumber[src_regno] >= 0)\n \t\t    {\n \t\t      bool before_p;\n-\t\t      rtx_insn *use_insn = curr_insn;\n+\t\t      rtx use_insn = curr_insn;\n \n \t\t      before_p = (JUMP_P (curr_insn)\n \t\t\t\t  || (CALL_P (curr_insn) && reg->type == OP_IN));"}, {"sha": "a6167c735f7f49b0ec680292dc6e028d84743859", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -790,8 +790,7 @@ schedule_reg_moves (partial_schedule_ptr ps)\n \t  move->old_reg = old_reg;\n \t  move->new_reg = gen_reg_rtx (GET_MODE (prev_reg));\n \t  move->num_consecutive_stages = distances[0] && distances[1] ? 2 : 1;\n-\t  move->insn = as_a <rtx_insn *> (gen_move_insn (move->new_reg,\n-\t\t\t\t\t\t\t copy_rtx (prev_reg)));\n+\t  move->insn = gen_move_insn (move->new_reg, copy_rtx (prev_reg));\n \t  bitmap_clear (move->uses);\n \n \t  prev_reg = move->new_reg;"}, {"sha": "26dbe8764f2772134acf08aee5b485880e95e989", "filename": "gcc/optabs.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -1416,7 +1416,7 @@ expand_binop_directly (machine_mode mode, optab binoptab,\n   machine_mode mode0, mode1, tmp_mode;\n   struct expand_operand ops[3];\n   bool commutative_p;\n-  rtx pat;\n+  rtx_insn *pat;\n   rtx xop0 = op0, xop1 = op1;\n \n   /* If it is a commutative operator and the modes would match\n@@ -1490,8 +1490,8 @@ expand_binop_directly (machine_mode mode, optab binoptab,\n       /* If PAT is composed of more than one insn, try to add an appropriate\n \t REG_EQUAL note to it.  If we can't because TEMP conflicts with an\n \t operand, call expand_binop again, this time without a target.  */\n-      if (INSN_P (pat) && NEXT_INSN (as_a <rtx_insn *> (pat)) != NULL_RTX\n-\t  && ! add_equal_note (as_a <rtx_insn *> (pat), ops[0].value,\n+      if (INSN_P (pat) && NEXT_INSN (pat) != NULL_RTX\n+\t  && ! add_equal_note (pat, ops[0].value,\n \t\t\t       optab_to_code (binoptab),\n \t\t\t       ops[1].value, ops[2].value))\n \t{\n@@ -3003,15 +3003,15 @@ expand_unop_direct (machine_mode mode, optab unoptab, rtx op0, rtx target,\n       struct expand_operand ops[2];\n       enum insn_code icode = optab_handler (unoptab, mode);\n       rtx_insn *last = get_last_insn ();\n-      rtx pat;\n+      rtx_insn *pat;\n \n       create_output_operand (&ops[0], target, mode);\n       create_convert_operand_from (&ops[1], op0, mode, unsignedp);\n       pat = maybe_gen_insn (icode, 2, ops);\n       if (pat)\n \t{\n-\t  if (INSN_P (pat) && NEXT_INSN (as_a <rtx_insn *> (pat)) != NULL_RTX\n-\t      && ! add_equal_note (as_a <rtx_insn *> (pat), ops[0].value,\n+\t  if (INSN_P (pat) && NEXT_INSN (pat) != NULL_RTX\n+\t      && ! add_equal_note (pat, ops[0].value,\n \t\t\t\t   optab_to_code (unoptab),\n \t\t\t\t   ops[1].value, NULL_RTX))\n \t    {\n@@ -3495,7 +3495,7 @@ expand_abs (machine_mode mode, rtx op0, rtx target,\n   NO_DEFER_POP;\n \n   do_compare_rtx_and_jump (target, CONST0_RTX (mode), GE, 0, mode,\n-\t\t\t   NULL_RTX, NULL_RTX, op1, -1);\n+\t\t\t   NULL_RTX, NULL, op1, -1);\n \n   op0 = expand_unop (mode, result_unsignedp ? neg_optab : negv_optab,\n                      target, target, 0);\n@@ -3804,18 +3804,17 @@ maybe_emit_unop_insn (enum insn_code icode, rtx target, rtx op0,\n \t\t      enum rtx_code code)\n {\n   struct expand_operand ops[2];\n-  rtx pat;\n+  rtx_insn *pat;\n \n   create_output_operand (&ops[0], target, GET_MODE (target));\n   create_input_operand (&ops[1], op0, GET_MODE (op0));\n   pat = maybe_gen_insn (icode, 2, ops);\n   if (!pat)\n     return false;\n \n-  if (INSN_P (pat) && NEXT_INSN (as_a <rtx_insn *> (pat)) != NULL_RTX\n+  if (INSN_P (pat) && NEXT_INSN (pat) != NULL_RTX\n       && code != UNKNOWN)\n-    add_equal_note (as_a <rtx_insn *> (pat), ops[0].value, code, ops[1].value,\n-\t\t    NULL_RTX);\n+    add_equal_note (pat, ops[0].value, code, ops[1].value, NULL_RTX);\n \n   emit_insn (pat);\n \n@@ -8360,13 +8359,13 @@ maybe_legitimize_operands (enum insn_code icode, unsigned int opno,\n    and emit any necessary set-up code.  Return null and emit no\n    code on failure.  */\n \n-rtx\n+rtx_insn *\n maybe_gen_insn (enum insn_code icode, unsigned int nops,\n \t\tstruct expand_operand *ops)\n {\n   gcc_assert (nops == (unsigned int) insn_data[(int) icode].n_generator_args);\n   if (!maybe_legitimize_operands (icode, 0, nops, ops))\n-    return NULL_RTX;\n+    return NULL;\n \n   switch (nops)\n     {"}, {"sha": "5c30ce5767a2cc3c400f7cc3c9f0a867d93fd4ab", "filename": "gcc/optabs.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -541,8 +541,8 @@ extern void create_convert_operand_from_type (struct expand_operand *op,\n extern bool maybe_legitimize_operands (enum insn_code icode,\n \t\t\t\t       unsigned int opno, unsigned int nops,\n \t\t\t\t       struct expand_operand *ops);\n-extern rtx maybe_gen_insn (enum insn_code icode, unsigned int nops,\n-\t\t\t   struct expand_operand *ops);\n+extern rtx_insn *maybe_gen_insn (enum insn_code icode, unsigned int nops,\n+\t\t\t\t struct expand_operand *ops);\n extern bool maybe_expand_insn (enum insn_code icode, unsigned int nops,\n \t\t\t       struct expand_operand *ops);\n extern bool maybe_expand_jump_insn (enum insn_code icode, unsigned int nops,"}, {"sha": "21ac6cd35f9d494e497525474ace61fce038ed57", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -1115,8 +1115,8 @@ eliminate_partially_redundant_load (basic_block bb, rtx_insn *insn,\n \n \t  /* Make sure we can generate a move from register avail_reg to\n \t     dest.  */\n-\t  rtx_insn *move = as_a <rtx_insn *>\n-\t    (gen_move_insn (copy_rtx (dest), copy_rtx (avail_reg)));\n+\t  rtx_insn *move = gen_move_insn (copy_rtx (dest),\n+\t\t\t\t\t  copy_rtx (avail_reg));\n \t  extract_insn (move);\n \t  if (! constrain_operands (1, get_preferred_alternatives (insn,\n \t\t\t\t\t\t\t\t   pred_bb))"}, {"sha": "b251299ac17fcf4fdf6775a5e3a38cba1eaf99c6", "filename": "gcc/recog.c", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -3066,7 +3066,7 @@ split_all_insns_noflow (void)\n #ifdef HAVE_peephole2\n struct peep2_insn_data\n {\n-  rtx insn;\n+  rtx_insn *insn;\n   regset live_before;\n };\n \n@@ -3079,10 +3079,9 @@ static bool peep2_do_cleanup_cfg;\n /* The number of instructions available to match a peep2.  */\n int peep2_current_count;\n \n-/* A non-insn marker indicating the last insn of the block.\n-   The live_before regset for this element is correct, indicating\n-   DF_LIVE_OUT for the block.  */\n-#define PEEP2_EOB\tpc_rtx\n+/* A marker indicating the last insn of the block.  The live_before regset\n+   for this element is correct, indicating DF_LIVE_OUT for the block.  */\n+#define PEEP2_EOB invalid_insn_rtx\n \n /* Wrap N to fit into the peep2_insn_data buffer.  */\n \n@@ -3282,7 +3281,7 @@ peep2_reinit_state (regset live)\n \n   /* Indicate that all slots except the last holds invalid data.  */\n   for (i = 0; i < MAX_INSNS_PER_PEEP2; ++i)\n-    peep2_insn_data[i].insn = NULL_RTX;\n+    peep2_insn_data[i].insn = NULL;\n   peep2_current_count = 0;\n \n   /* Indicate that the last slot contains live_after data.  */\n@@ -3298,9 +3297,8 @@ peep2_reinit_state (regset live)\n    if the replacement is rejected.  */\n \n static rtx_insn *\n-peep2_attempt (basic_block bb, rtx uncast_insn, int match_len, rtx_insn *attempt)\n+peep2_attempt (basic_block bb, rtx_insn *insn, int match_len, rtx_insn *attempt)\n {\n-  rtx_insn *insn = safe_as_a <rtx_insn *> (uncast_insn);\n   int i;\n   rtx_insn *last, *before_try, *x;\n   rtx eh_note, as_note;\n@@ -3310,7 +3308,7 @@ peep2_attempt (basic_block bb, rtx uncast_insn, int match_len, rtx_insn *attempt\n \n   /* If we are splitting an RTX_FRAME_RELATED_P insn, do not allow it to\n      match more than one insn, or to be split into more than one insn.  */\n-  old_insn = as_a <rtx_insn *> (peep2_insn_data[peep2_current].insn);\n+  old_insn = peep2_insn_data[peep2_current].insn;\n   if (RTX_FRAME_RELATED_P (old_insn))\n     {\n       bool any_note = false;\n@@ -3398,7 +3396,7 @@ peep2_attempt (basic_block bb, rtx uncast_insn, int match_len, rtx_insn *attempt\n       rtx note;\n \n       j = peep2_buf_position (peep2_current + i);\n-      old_insn = as_a <rtx_insn *> (peep2_insn_data[j].insn);\n+      old_insn = peep2_insn_data[j].insn;\n       if (!CALL_P (old_insn))\n \tcontinue;\n       was_call = true;\n@@ -3437,7 +3435,7 @@ peep2_attempt (basic_block bb, rtx uncast_insn, int match_len, rtx_insn *attempt\n       while (++i <= match_len)\n \t{\n \t  j = peep2_buf_position (peep2_current + i);\n-\t  old_insn = as_a <rtx_insn *> (peep2_insn_data[j].insn);\n+\t  old_insn = peep2_insn_data[j].insn;\n \t  gcc_assert (!CALL_P (old_insn));\n \t}\n       break;\n@@ -3449,7 +3447,7 @@ peep2_attempt (basic_block bb, rtx uncast_insn, int match_len, rtx_insn *attempt\n   for (i = match_len; i >= 0; --i)\n     {\n       int j = peep2_buf_position (peep2_current + i);\n-      old_insn = as_a <rtx_insn *> (peep2_insn_data[j].insn);\n+      old_insn = peep2_insn_data[j].insn;\n \n       as_note = find_reg_note (old_insn, REG_ARGS_SIZE, NULL);\n       if (as_note)\n@@ -3460,7 +3458,7 @@ peep2_attempt (basic_block bb, rtx uncast_insn, int match_len, rtx_insn *attempt\n   eh_note = find_reg_note (peep2_insn_data[i].insn, REG_EH_REGION, NULL_RTX);\n \n   /* Replace the old sequence with the new.  */\n-  rtx_insn *peepinsn = as_a <rtx_insn *> (peep2_insn_data[i].insn);\n+  rtx_insn *peepinsn = peep2_insn_data[i].insn;\n   last = emit_insn_after_setloc (attempt,\n \t\t\t\t peep2_insn_data[i].insn,\n \t\t\t\t INSN_LOCATION (peepinsn));\n@@ -3577,7 +3575,7 @@ peep2_update_life (basic_block bb, int match_len, rtx_insn *last,\n    add more instructions to the buffer.  */\n \n static bool\n-peep2_fill_buffer (basic_block bb, rtx insn, regset live)\n+peep2_fill_buffer (basic_block bb, rtx_insn *insn, regset live)\n {\n   int pos;\n \n@@ -3603,7 +3601,7 @@ peep2_fill_buffer (basic_block bb, rtx insn, regset live)\n   COPY_REG_SET (peep2_insn_data[pos].live_before, live);\n   peep2_current_count++;\n \n-  df_simulate_one_insn_forwards (bb, as_a <rtx_insn *> (insn), live);\n+  df_simulate_one_insn_forwards (bb, insn, live);\n   return true;\n }\n \n@@ -3645,8 +3643,7 @@ peephole2_optimize (void)\n       insn = BB_HEAD (bb);\n       for (;;)\n \t{\n-\t  rtx_insn *attempt;\n-\t  rtx head;\n+\t  rtx_insn *attempt, *head;\n \t  int match_len;\n \n \t  if (!past_end && !NONDEBUG_INSN_P (insn))"}, {"sha": "d97f4df3dbea16abaec391aeb29e100f11d6b8d4", "filename": "gcc/recog.h", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -276,43 +276,43 @@ typedef const char * (*insn_output_fn) (rtx *, rtx_insn *);\n \n struct insn_gen_fn\n {\n-  typedef rtx (*f0) (void);\n-  typedef rtx (*f1) (rtx);\n-  typedef rtx (*f2) (rtx, rtx);\n-  typedef rtx (*f3) (rtx, rtx, rtx);\n-  typedef rtx (*f4) (rtx, rtx, rtx, rtx);\n-  typedef rtx (*f5) (rtx, rtx, rtx, rtx, rtx);\n-  typedef rtx (*f6) (rtx, rtx, rtx, rtx, rtx, rtx);\n-  typedef rtx (*f7) (rtx, rtx, rtx, rtx, rtx, rtx, rtx);\n-  typedef rtx (*f8) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx);\n-  typedef rtx (*f9) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx);\n-  typedef rtx (*f10) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx);\n-  typedef rtx (*f11) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx);\n-  typedef rtx (*f12) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx);\n-  typedef rtx (*f13) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx);\n-  typedef rtx (*f14) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx);\n-  typedef rtx (*f15) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx);\n-  typedef rtx (*f16) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx);\n+  typedef rtx_insn * (*f0) (void);\n+  typedef rtx_insn * (*f1) (rtx);\n+  typedef rtx_insn * (*f2) (rtx, rtx);\n+  typedef rtx_insn * (*f3) (rtx, rtx, rtx);\n+  typedef rtx_insn * (*f4) (rtx, rtx, rtx, rtx);\n+  typedef rtx_insn * (*f5) (rtx, rtx, rtx, rtx, rtx);\n+  typedef rtx_insn * (*f6) (rtx, rtx, rtx, rtx, rtx, rtx);\n+  typedef rtx_insn * (*f7) (rtx, rtx, rtx, rtx, rtx, rtx, rtx);\n+  typedef rtx_insn * (*f8) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx);\n+  typedef rtx_insn * (*f9) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx);\n+  typedef rtx_insn * (*f10) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx);\n+  typedef rtx_insn * (*f11) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx);\n+  typedef rtx_insn * (*f12) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx);\n+  typedef rtx_insn * (*f13) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx);\n+  typedef rtx_insn * (*f14) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx);\n+  typedef rtx_insn * (*f15) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx);\n+  typedef rtx_insn * (*f16) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx);\n \n   typedef f0 stored_funcptr;\n \n-  rtx operator () (void) const { return ((f0)func) (); }\n-  rtx operator () (rtx a0) const { return ((f1)func) (a0); }\n-  rtx operator () (rtx a0, rtx a1) const { return ((f2)func) (a0, a1); }\n-  rtx operator () (rtx a0, rtx a1, rtx a2) const { return ((f3)func) (a0, a1, a2); }\n-  rtx operator () (rtx a0, rtx a1, rtx a2, rtx a3) const { return ((f4)func) (a0, a1, a2, a3); }\n-  rtx operator () (rtx a0, rtx a1, rtx a2, rtx a3, rtx a4) const { return ((f5)func) (a0, a1, a2, a3, a4); }\n-  rtx operator () (rtx a0, rtx a1, rtx a2, rtx a3, rtx a4, rtx a5) const { return ((f6)func) (a0, a1, a2, a3, a4, a5); }\n-  rtx operator () (rtx a0, rtx a1, rtx a2, rtx a3, rtx a4, rtx a5, rtx a6) const { return ((f7)func) (a0, a1, a2, a3, a4, a5, a6); }\n-  rtx operator () (rtx a0, rtx a1, rtx a2, rtx a3, rtx a4, rtx a5, rtx a6, rtx a7) const { return ((f8)func) (a0, a1, a2, a3, a4, a5, a6, a7); }\n-  rtx operator () (rtx a0, rtx a1, rtx a2, rtx a3, rtx a4, rtx a5, rtx a6, rtx a7, rtx a8) const { return ((f9)func) (a0, a1, a2, a3, a4, a5, a6, a7, a8); }\n-  rtx operator () (rtx a0, rtx a1, rtx a2, rtx a3, rtx a4, rtx a5, rtx a6, rtx a7, rtx a8, rtx a9) const { return ((f10)func) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9); }\n-  rtx operator () (rtx a0, rtx a1, rtx a2, rtx a3, rtx a4, rtx a5, rtx a6, rtx a7, rtx a8, rtx a9, rtx a10) const { return ((f11)func) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10); }\n-  rtx operator () (rtx a0, rtx a1, rtx a2, rtx a3, rtx a4, rtx a5, rtx a6, rtx a7, rtx a8, rtx a9, rtx a10, rtx a11) const { return ((f12)func) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11); }\n-  rtx operator () (rtx a0, rtx a1, rtx a2, rtx a3, rtx a4, rtx a5, rtx a6, rtx a7, rtx a8, rtx a9, rtx a10, rtx a11, rtx a12) const { return ((f13)func) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12); }\n-  rtx operator () (rtx a0, rtx a1, rtx a2, rtx a3, rtx a4, rtx a5, rtx a6, rtx a7, rtx a8, rtx a9, rtx a10, rtx a11, rtx a12, rtx a13) const { return ((f14)func) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13); }\n-  rtx operator () (rtx a0, rtx a1, rtx a2, rtx a3, rtx a4, rtx a5, rtx a6, rtx a7, rtx a8, rtx a9, rtx a10, rtx a11, rtx a12, rtx a13, rtx a14) const { return ((f15)func) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14); }\n-  rtx operator () (rtx a0, rtx a1, rtx a2, rtx a3, rtx a4, rtx a5, rtx a6, rtx a7, rtx a8, rtx a9, rtx a10, rtx a11, rtx a12, rtx a13, rtx a14, rtx a15) const { return ((f16)func) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15); }\n+  rtx_insn * operator () (void) const { return ((f0)func) (); }\n+  rtx_insn * operator () (rtx a0) const { return ((f1)func) (a0); }\n+  rtx_insn * operator () (rtx a0, rtx a1) const { return ((f2)func) (a0, a1); }\n+  rtx_insn * operator () (rtx a0, rtx a1, rtx a2) const { return ((f3)func) (a0, a1, a2); }\n+  rtx_insn * operator () (rtx a0, rtx a1, rtx a2, rtx a3) const { return ((f4)func) (a0, a1, a2, a3); }\n+  rtx_insn * operator () (rtx a0, rtx a1, rtx a2, rtx a3, rtx a4) const { return ((f5)func) (a0, a1, a2, a3, a4); }\n+  rtx_insn * operator () (rtx a0, rtx a1, rtx a2, rtx a3, rtx a4, rtx a5) const { return ((f6)func) (a0, a1, a2, a3, a4, a5); }\n+  rtx_insn * operator () (rtx a0, rtx a1, rtx a2, rtx a3, rtx a4, rtx a5, rtx a6) const { return ((f7)func) (a0, a1, a2, a3, a4, a5, a6); }\n+  rtx_insn * operator () (rtx a0, rtx a1, rtx a2, rtx a3, rtx a4, rtx a5, rtx a6, rtx a7) const { return ((f8)func) (a0, a1, a2, a3, a4, a5, a6, a7); }\n+  rtx_insn * operator () (rtx a0, rtx a1, rtx a2, rtx a3, rtx a4, rtx a5, rtx a6, rtx a7, rtx a8) const { return ((f9)func) (a0, a1, a2, a3, a4, a5, a6, a7, a8); }\n+  rtx_insn * operator () (rtx a0, rtx a1, rtx a2, rtx a3, rtx a4, rtx a5, rtx a6, rtx a7, rtx a8, rtx a9) const { return ((f10)func) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9); }\n+  rtx_insn * operator () (rtx a0, rtx a1, rtx a2, rtx a3, rtx a4, rtx a5, rtx a6, rtx a7, rtx a8, rtx a9, rtx a10) const { return ((f11)func) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10); }\n+  rtx_insn * operator () (rtx a0, rtx a1, rtx a2, rtx a3, rtx a4, rtx a5, rtx a6, rtx a7, rtx a8, rtx a9, rtx a10, rtx a11) const { return ((f12)func) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11); }\n+  rtx_insn * operator () (rtx a0, rtx a1, rtx a2, rtx a3, rtx a4, rtx a5, rtx a6, rtx a7, rtx a8, rtx a9, rtx a10, rtx a11, rtx a12) const { return ((f13)func) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12); }\n+  rtx_insn * operator () (rtx a0, rtx a1, rtx a2, rtx a3, rtx a4, rtx a5, rtx a6, rtx a7, rtx a8, rtx a9, rtx a10, rtx a11, rtx a12, rtx a13) const { return ((f14)func) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13); }\n+  rtx_insn * operator () (rtx a0, rtx a1, rtx a2, rtx a3, rtx a4, rtx a5, rtx a6, rtx a7, rtx a8, rtx a9, rtx a10, rtx a11, rtx a12, rtx a13, rtx a14) const { return ((f15)func) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14); }\n+  rtx_insn * operator () (rtx a0, rtx a1, rtx a2, rtx a3, rtx a4, rtx a5, rtx a6, rtx a7, rtx a8, rtx a9, rtx a10, rtx a11, rtx a12, rtx a13, rtx a14, rtx a15) const { return ((f16)func) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15); }\n \n   // This is for compatibility of code that invokes functions like\n   //   (*funcptr) (arg)"}, {"sha": "e0852907f3bf490b28df86df10e01573a34b7b89", "filename": "gcc/reorg.c", "status": "modified", "additions": 74, "deletions": 66, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -236,7 +236,7 @@ static rtx_insn *delete_from_delay_slot (rtx_insn *);\n static void delete_scheduled_jump (rtx_insn *);\n static void note_delay_statistics (int, int);\n #if defined(ANNUL_IFFALSE_SLOTS) || defined(ANNUL_IFTRUE_SLOTS)\n-static rtx_insn_list *optimize_skip (rtx_insn *);\n+static rtx_insn_list *optimize_skip (rtx_jump_insn *);\n #endif\n static int get_jump_flags (const rtx_insn *, rtx);\n static int mostly_true_jump (rtx);\n@@ -264,12 +264,12 @@ static void try_merge_delay_insns (rtx_insn *, rtx_insn *);\n static rtx redundant_insn (rtx, rtx_insn *, rtx);\n static int own_thread_p (rtx, rtx, int);\n static void update_block (rtx_insn *, rtx);\n-static int reorg_redirect_jump (rtx_insn *, rtx);\n+static int reorg_redirect_jump (rtx_jump_insn *, rtx);\n static void update_reg_dead_notes (rtx_insn *, rtx_insn *);\n static void fix_reg_dead_note (rtx, rtx);\n static void update_reg_unused_notes (rtx, rtx);\n static void fill_simple_delay_slots (int);\n-static rtx_insn_list *fill_slots_from_thread (rtx_insn *, rtx, rtx, rtx,\n+static rtx_insn_list *fill_slots_from_thread (rtx_jump_insn *, rtx, rtx, rtx,\n \t\t\t\t\t      int, int, int, int,\n \t\t\t\t\t      int *, rtx_insn_list *);\n static void fill_eager_delay_slots (void);\n@@ -779,7 +779,7 @@ note_delay_statistics (int slots_filled, int index)\n    of delay slots required.  */\n \n static rtx_insn_list *\n-optimize_skip (rtx_insn *insn)\n+optimize_skip (rtx_jump_insn *insn)\n {\n   rtx_insn *trial = next_nonnote_insn (insn);\n   rtx_insn *next_trial = next_active_insn (trial);\n@@ -1789,7 +1789,7 @@ update_block (rtx_insn *insn, rtx where)\n    the basic block containing the jump.  */\n \n static int\n-reorg_redirect_jump (rtx_insn *jump, rtx nlabel)\n+reorg_redirect_jump (rtx_jump_insn *jump, rtx nlabel)\n {\n   incr_ticks_for_insn (jump);\n   return redirect_jump (jump, nlabel, 1);\n@@ -2147,7 +2147,7 @@ fill_simple_delay_slots (int non_jumps_p)\n \t  && (condjump_p (insn) || condjump_in_parallel_p (insn))\n \t  && !ANY_RETURN_P (JUMP_LABEL (insn)))\n \t{\n-\t  delay_list = optimize_skip (insn);\n+\t  delay_list = optimize_skip (as_a <rtx_jump_insn *> (insn));\n \t  if (delay_list)\n \t    slots_filled += 1;\n \t}\n@@ -2296,18 +2296,20 @@ fill_simple_delay_slots (int non_jumps_p)\n \t\t    = add_to_delay_list (copy_delay_slot_insn (next_trial),\n \t\t\t\t\t delay_list);\n \t\t  slots_filled++;\n-\t\t  reorg_redirect_jump (trial, new_label);\n+\t\t  reorg_redirect_jump (as_a <rtx_jump_insn *> (trial),\n+\t\t\t\t       new_label);\n \t\t}\n \t    }\n \t}\n \n       /* If this is an unconditional jump, then try to get insns from the\n \t target of the jump.  */\n-      if (JUMP_P (insn)\n-\t  && simplejump_p (insn)\n+      rtx_jump_insn *jump_insn;\n+      if ((jump_insn = dyn_cast <rtx_jump_insn *> (insn))\n+\t  && simplejump_p (jump_insn)\n \t  && slots_filled != slots_to_fill)\n \tdelay_list\n-\t  = fill_slots_from_thread (insn, const_true_rtx,\n+\t  = fill_slots_from_thread (jump_insn, const_true_rtx,\n \t\t\t\t    next_active_insn (JUMP_LABEL (insn)),\n \t\t\t\t    NULL, 1, 1,\n \t\t\t\t    own_thread_p (JUMP_LABEL (insn),\n@@ -2411,10 +2413,9 @@ follow_jumps (rtx label, rtx_insn *jump, bool *crossing)\n    slot.  We then adjust the jump to point after the insns we have taken.  */\n \n static rtx_insn_list *\n-fill_slots_from_thread (rtx_insn *insn, rtx condition, rtx thread_or_return,\n-\t\t\trtx opposite_thread, int likely,\n-\t\t\tint thread_if_true,\n-\t\t\tint own_thread, int slots_to_fill,\n+fill_slots_from_thread (rtx_jump_insn *insn, rtx condition,\n+\t\t\trtx thread_or_return, rtx opposite_thread, int likely,\n+\t\t\tint thread_if_true, int own_thread, int slots_to_fill,\n \t\t\tint *pslots_filled, rtx_insn_list *delay_list)\n {\n   rtx new_thread;\n@@ -2883,18 +2884,19 @@ fill_eager_delay_slots (void)\n       rtx target_label, insn_at_target;\n       rtx_insn *fallthrough_insn;\n       rtx_insn_list *delay_list = 0;\n+      rtx_jump_insn *jump_insn;\n       int own_target;\n       int own_fallthrough;\n       int prediction, slots_to_fill, slots_filled;\n \n       insn = unfilled_slots_base[i];\n       if (insn == 0\n \t  || insn->deleted ()\n-\t  || !JUMP_P (insn)\n-\t  || ! (condjump_p (insn) || condjump_in_parallel_p (insn)))\n+\t  || ! (jump_insn = dyn_cast <rtx_jump_insn *> (insn))\n+\t  || ! (condjump_p (jump_insn) || condjump_in_parallel_p (jump_insn)))\n \tcontinue;\n \n-      slots_to_fill = num_delay_slots (insn);\n+      slots_to_fill = num_delay_slots (jump_insn);\n       /* Some machine description have defined instructions to have\n \t delay slots only in certain circumstances which may depend on\n \t nearby insns (which change due to reorg's actions).\n@@ -2910,8 +2912,8 @@ fill_eager_delay_slots (void)\n \tcontinue;\n \n       slots_filled = 0;\n-      target_label = JUMP_LABEL (insn);\n-      condition = get_branch_condition (insn, target_label);\n+      target_label = JUMP_LABEL (jump_insn);\n+      condition = get_branch_condition (jump_insn, target_label);\n \n       if (condition == 0)\n \tcontinue;\n@@ -2931,9 +2933,9 @@ fill_eager_delay_slots (void)\n \t}\n       else\n \t{\n-\t  fallthrough_insn = next_active_insn (insn);\n-\t  own_fallthrough = own_thread_p (NEXT_INSN (insn), NULL_RTX, 1);\n-\t  prediction = mostly_true_jump (insn);\n+\t  fallthrough_insn = next_active_insn (jump_insn);\n+\t  own_fallthrough = own_thread_p (NEXT_INSN (jump_insn), NULL_RTX, 1);\n+\t  prediction = mostly_true_jump (jump_insn);\n \t}\n \n       /* If this insn is expected to branch, first try to get insns from our\n@@ -2943,7 +2945,7 @@ fill_eager_delay_slots (void)\n       if (prediction > 0)\n \t{\n \t  delay_list\n-\t    = fill_slots_from_thread (insn, condition, insn_at_target,\n+\t    = fill_slots_from_thread (jump_insn, condition, insn_at_target,\n \t\t\t\t      fallthrough_insn, prediction == 2, 1,\n \t\t\t\t      own_target,\n \t\t\t\t      slots_to_fill, &slots_filled, delay_list);\n@@ -2954,11 +2956,12 @@ fill_eager_delay_slots (void)\n \t\t we might have found a redundant insn which we deleted\n \t\t from the thread that was filled.  So we have to recompute\n \t\t the next insn at the target.  */\n-\t      target_label = JUMP_LABEL (insn);\n+\t      target_label = JUMP_LABEL (jump_insn);\n \t      insn_at_target = first_active_target_insn (target_label);\n \n \t      delay_list\n-\t\t= fill_slots_from_thread (insn, condition, fallthrough_insn,\n+\t\t= fill_slots_from_thread (jump_insn, condition,\n+\t\t\t\t\t  fallthrough_insn,\n \t\t\t\t\t  insn_at_target, 0, 0,\n \t\t\t\t\t  own_fallthrough,\n \t\t\t\t\t  slots_to_fill, &slots_filled,\n@@ -2969,15 +2972,15 @@ fill_eager_delay_slots (void)\n \t{\n \t  if (own_fallthrough)\n \t    delay_list\n-\t      = fill_slots_from_thread (insn, condition, fallthrough_insn,\n+\t      = fill_slots_from_thread (jump_insn, condition, fallthrough_insn,\n \t\t\t\t\tinsn_at_target, 0, 0,\n \t\t\t\t\town_fallthrough,\n \t\t\t\t\tslots_to_fill, &slots_filled,\n \t\t\t\t\tdelay_list);\n \n \t  if (delay_list == 0)\n \t    delay_list\n-\t      = fill_slots_from_thread (insn, condition, insn_at_target,\n+\t      = fill_slots_from_thread (jump_insn, condition, insn_at_target,\n \t\t\t\t\tnext_active_insn (insn), 0, 1,\n \t\t\t\t\town_target,\n \t\t\t\t\tslots_to_fill, &slots_filled,\n@@ -2986,7 +2989,7 @@ fill_eager_delay_slots (void)\n \n       if (delay_list)\n \tunfilled_slots_base[i]\n-\t  = emit_delay_sequence (insn, delay_list, slots_filled);\n+\t  = emit_delay_sequence (jump_insn, delay_list, slots_filled);\n \n       if (slots_to_fill == slots_filled)\n \tunfilled_slots_base[i] = 0;\n@@ -3222,40 +3225,41 @@ relax_delay_slots (rtx_insn *first)\n       /* If this is a jump insn, see if it now jumps to a jump, jumps to\n \t the next insn, or jumps to a label that is not the last of a\n \t group of consecutive labels.  */\n-      if (JUMP_P (insn)\n+      if (is_a <rtx_jump_insn *> (insn)\n \t  && (condjump_p (insn) || condjump_in_parallel_p (insn))\n \t  && !ANY_RETURN_P (target_label = JUMP_LABEL (insn)))\n \t{\n+\t  rtx_jump_insn *jump_insn = as_a <rtx_jump_insn *> (insn);\n \t  target_label\n-\t    = skip_consecutive_labels (follow_jumps (target_label, insn,\n+\t    = skip_consecutive_labels (follow_jumps (target_label, jump_insn,\n \t\t\t\t\t\t     &crossing));\n \t  if (ANY_RETURN_P (target_label))\n \t    target_label = find_end_label (target_label);\n \n \t  if (target_label && next_active_insn (target_label) == next\n-\t      && ! condjump_in_parallel_p (insn)\n-\t      && ! (next && switch_text_sections_between_p (insn, next)))\n+\t      && ! condjump_in_parallel_p (jump_insn)\n+\t      && ! (next && switch_text_sections_between_p (jump_insn, next)))\n \t    {\n-\t      delete_jump (insn);\n+\t      delete_jump (jump_insn);\n \t      continue;\n \t    }\n \n-\t  if (target_label && target_label != JUMP_LABEL (insn))\n+\t  if (target_label && target_label != JUMP_LABEL (jump_insn))\n \t    {\n-\t      reorg_redirect_jump (insn, target_label);\n+\t      reorg_redirect_jump (jump_insn, target_label);\n \t      if (crossing)\n-\t\tCROSSING_JUMP_P (insn) = 1;\n+\t\tCROSSING_JUMP_P (jump_insn) = 1;\n \t    }\n \n \t  /* See if this jump conditionally branches around an unconditional\n \t     jump.  If so, invert this jump and point it to the target of the\n \t     second jump.  Check if it's possible on the target.  */\n \t  if (next && simplejump_or_return_p (next)\n-\t      && any_condjump_p (insn)\n+\t      && any_condjump_p (jump_insn)\n \t      && target_label\n \t      && next_active_insn (target_label) == next_active_insn (next)\n-\t      && no_labels_between_p (insn, next)\n-\t      && targetm.can_follow_jump (insn, next))\n+\t      && no_labels_between_p (jump_insn, next)\n+\t      && targetm.can_follow_jump (jump_insn, next))\n \t    {\n \t      rtx label = JUMP_LABEL (next);\n \n@@ -3270,10 +3274,10 @@ relax_delay_slots (rtx_insn *first)\n \t      if (!ANY_RETURN_P (label))\n \t\t++LABEL_NUSES (label);\n \n-\t      if (invert_jump (insn, label, 1))\n+\t      if (invert_jump (jump_insn, label, 1))\n \t\t{\n \t\t  delete_related_insns (next);\n-\t\t  next = insn;\n+\t\t  next = jump_insn;\n \t\t}\n \n \t      if (!ANY_RETURN_P (label))\n@@ -3303,8 +3307,8 @@ relax_delay_slots (rtx_insn *first)\n \t  rtx other_target = JUMP_LABEL (other);\n \t  target_label = JUMP_LABEL (insn);\n \n-\t  if (invert_jump (other, target_label, 0))\n-\t    reorg_redirect_jump (insn, other_target);\n+\t  if (invert_jump (as_a <rtx_jump_insn *> (other), target_label, 0))\n+\t    reorg_redirect_jump (as_a <rtx_jump_insn *> (insn), other_target);\n \t}\n \n       /* Now look only at cases where we have a filled delay slot.  */\n@@ -3369,25 +3373,28 @@ relax_delay_slots (rtx_insn *first)\n \t}\n \n       /* Now look only at the cases where we have a filled JUMP_INSN.  */\n-      if (!JUMP_P (delay_insn)\n-\t  || !(condjump_p (delay_insn) || condjump_in_parallel_p (delay_insn)))\n+      rtx_jump_insn *delay_jump_insn =\n+\t\tdyn_cast <rtx_jump_insn *> (delay_insn);\n+      if (! delay_jump_insn || !(condjump_p (delay_jump_insn)\n+\t  || condjump_in_parallel_p (delay_jump_insn)))\n \tcontinue;\n \n-      target_label = JUMP_LABEL (delay_insn);\n+      target_label = JUMP_LABEL (delay_jump_insn);\n       if (target_label && ANY_RETURN_P (target_label))\n \tcontinue;\n \n       /* If this jump goes to another unconditional jump, thread it, but\n \t don't convert a jump into a RETURN here.  */\n-      trial = skip_consecutive_labels (follow_jumps (target_label, delay_insn,\n+      trial = skip_consecutive_labels (follow_jumps (target_label,\n+\t\t\t\t\t\t     delay_jump_insn,\n \t\t\t\t\t\t     &crossing));\n       if (ANY_RETURN_P (trial))\n \ttrial = find_end_label (trial);\n \n       if (trial && trial != target_label\n-\t  && redirect_with_delay_slots_safe_p (delay_insn, trial, insn))\n+\t  && redirect_with_delay_slots_safe_p (delay_jump_insn, trial, insn))\n \t{\n-\t  reorg_redirect_jump (delay_insn, trial);\n+\t  reorg_redirect_jump (delay_jump_insn, trial);\n \t  target_label = trial;\n \t  if (crossing)\n \t    CROSSING_JUMP_P (insn) = 1;\n@@ -3419,7 +3426,7 @@ relax_delay_slots (rtx_insn *first)\n \t      /* Now emit a label before the special USE insn, and\n \t\t redirect our jump to the new label.  */\n \t      target_label = get_label_before (PREV_INSN (tmp), target_label);\n-\t      reorg_redirect_jump (delay_insn, target_label);\n+\t      reorg_redirect_jump (delay_jump_insn, target_label);\n \t      next = insn;\n \t      continue;\n \t    }\n@@ -3440,19 +3447,19 @@ relax_delay_slots (rtx_insn *first)\n \t    target_label = find_end_label (target_label);\n \t  \n \t  if (target_label\n-\t      && redirect_with_delay_slots_safe_p (delay_insn, target_label,\n-\t\t\t\t\t\t   insn))\n+\t      && redirect_with_delay_slots_safe_p (delay_jump_insn,\n+\t\t\t\t\t\t   target_label, insn))\n \t    {\n \t      update_block (trial_seq->insn (1), insn);\n-\t      reorg_redirect_jump (delay_insn, target_label);\n+\t      reorg_redirect_jump (delay_jump_insn, target_label);\n \t      next = insn;\n \t      continue;\n \t    }\n \t}\n \n       /* See if we have a simple (conditional) jump that is useless.  */\n-      if (! INSN_ANNULLED_BRANCH_P (delay_insn)\n-\t  && ! condjump_in_parallel_p (delay_insn)\n+      if (! INSN_ANNULLED_BRANCH_P (delay_jump_insn)\n+\t  && ! condjump_in_parallel_p (delay_jump_insn)\n \t  && prev_active_insn (target_label) == insn\n \t  && ! BARRIER_P (prev_nonnote_insn (target_label))\n #if HAVE_cc0\n@@ -3489,11 +3496,11 @@ relax_delay_slots (rtx_insn *first)\n \t  trial = PREV_INSN (insn);\n \t  delete_related_insns (insn);\n \t  gcc_assert (GET_CODE (pat) == SEQUENCE);\n-\t  add_insn_after (delay_insn, trial, NULL);\n-\t  after = delay_insn;\n+\t  add_insn_after (delay_jump_insn, trial, NULL);\n+\t  after = delay_jump_insn;\n \t  for (i = 1; i < pat->len (); i++)\n \t    after = emit_copy_of_insn_after (pat->insn (i), after);\n-\t  delete_scheduled_jump (delay_insn);\n+\t  delete_scheduled_jump (delay_jump_insn);\n \t  continue;\n \t}\n \n@@ -3515,30 +3522,31 @@ relax_delay_slots (rtx_insn *first)\n \t this jump and point it to the target of the second jump.  We cannot\n \t do this for annulled jumps, though.  Again, don't convert a jump to\n \t a RETURN here.  */\n-      if (! INSN_ANNULLED_BRANCH_P (delay_insn)\n-\t  && any_condjump_p (delay_insn)\n+      if (! INSN_ANNULLED_BRANCH_P (delay_jump_insn)\n+\t  && any_condjump_p (delay_jump_insn)\n \t  && next && simplejump_or_return_p (next)\n \t  && next_active_insn (target_label) == next_active_insn (next)\n \t  && no_labels_between_p (insn, next))\n \t{\n \t  rtx label = JUMP_LABEL (next);\n-\t  rtx old_label = JUMP_LABEL (delay_insn);\n+\t  rtx old_label = JUMP_LABEL (delay_jump_insn);\n \n \t  if (ANY_RETURN_P (label))\n \t    label = find_end_label (label);\n \n \t  /* find_end_label can generate a new label. Check this first.  */\n \t  if (label\n \t      && no_labels_between_p (insn, next)\n-\t      && redirect_with_delay_slots_safe_p (delay_insn, label, insn))\n+\t      && redirect_with_delay_slots_safe_p (delay_jump_insn,\n+\t\t\t\t\t\t   label, insn))\n \t    {\n \t      /* Be careful how we do this to avoid deleting code or labels\n \t\t that are momentarily dead.  See similar optimization in\n \t\t jump.c  */\n \t      if (old_label)\n \t\t++LABEL_NUSES (old_label);\n \n-\t      if (invert_jump (delay_insn, label, 1))\n+\t      if (invert_jump (delay_jump_insn, label, 1))\n \t\t{\n \t\t  int i;\n \n@@ -3585,7 +3593,7 @@ static void\n make_return_insns (rtx_insn *first)\n {\n   rtx_insn *insn;\n-  rtx_insn *jump_insn;\n+  rtx_jump_insn *jump_insn;\n   rtx real_return_label = function_return_label;\n   rtx real_simple_return_label = function_simple_return_label;\n   int slots, i;\n@@ -3645,7 +3653,7 @@ make_return_insns (rtx_insn *first)\n       else\n \tcontinue;\n \n-      jump_insn = pat->insn (0);\n+      jump_insn = as_a <rtx_jump_insn *> (pat->insn (0));\n \n       /* If we can't make the jump into a RETURN, try to redirect it to the best\n \t RETURN and go on to the next insn.  */\n@@ -3783,7 +3791,7 @@ dbr_schedule (rtx_insn *first)\n \t  && !ANY_RETURN_P (JUMP_LABEL (insn))\n \t  && ((target = skip_consecutive_labels (JUMP_LABEL (insn)))\n \t      != JUMP_LABEL (insn)))\n-\tredirect_jump (insn, target, 1);\n+\tredirect_jump (as_a <rtx_jump_insn *> (insn), target, 1);\n     }\n \n   init_resource_info (epilogue_insn);"}, {"sha": "ad644af9db71d55d0acc1af2e95f9f4c9d2d7234", "filename": "gcc/resource.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -439,7 +439,7 @@ find_dead_or_set_registers (rtx_insn *target, struct resources *res,\n \n   for (insn = target; insn; insn = next_insn)\n     {\n-      rtx_insn *this_jump_insn = insn;\n+      rtx_insn *this_insn = insn;\n \n       next_insn = NEXT_INSN (insn);\n \n@@ -487,8 +487,8 @@ find_dead_or_set_registers (rtx_insn *target, struct resources *res,\n \t\t of a call, so search for a JUMP_INSN in any position.  */\n \t      for (i = 0; i < seq->len (); i++)\n \t\t{\n-\t\t  this_jump_insn = seq->insn (i);\n-\t\t  if (JUMP_P (this_jump_insn))\n+\t\t  this_insn = seq->insn (i);\n+\t\t  if (JUMP_P (this_insn))\n \t\t    break;\n \t\t}\n \t    }\n@@ -497,14 +497,15 @@ find_dead_or_set_registers (rtx_insn *target, struct resources *res,\n \t  break;\n \t}\n \n-      if (JUMP_P (this_jump_insn))\n+      if (rtx_jump_insn *this_jump_insn =\n+\t    dyn_cast <rtx_jump_insn *> (this_insn))\n \t{\n \t  if (jump_count++ < 10)\n \t    {\n \t      if (any_uncondjump_p (this_jump_insn)\n \t\t  || ANY_RETURN_P (PATTERN (this_jump_insn)))\n \t\t{\n-\t\t  rtx lab_or_return = JUMP_LABEL (this_jump_insn);\n+\t\t  rtx lab_or_return = this_jump_insn->jump_label ();\n \t\t  if (ANY_RETURN_P (lab_or_return))\n \t\t    next_insn = NULL;\n \t\t  else\n@@ -577,10 +578,10 @@ find_dead_or_set_registers (rtx_insn *target, struct resources *res,\n \t\t  AND_COMPL_HARD_REG_SET (scratch, needed.regs);\n \t\t  AND_COMPL_HARD_REG_SET (fallthrough_res.regs, scratch);\n \n-\t\t  if (!ANY_RETURN_P (JUMP_LABEL (this_jump_insn)))\n-\t\t    find_dead_or_set_registers (JUMP_LABEL_AS_INSN (this_jump_insn),\n-\t\t\t\t\t\t&target_res, 0, jump_count,\n-\t\t\t\t\t\ttarget_set, needed);\n+\t\t  if (!ANY_RETURN_P (this_jump_insn->jump_label ()))\n+\t\t    find_dead_or_set_registers\n+\t\t\t  (this_jump_insn->jump_target (),\n+\t\t\t   &target_res, 0, jump_count, target_set, needed);\n \t\t  find_dead_or_set_registers (next_insn,\n \t\t\t\t\t      &fallthrough_res, 0, jump_count,\n \t\t\t\t\t      set, needed);"}, {"sha": "f9e1b27e4ceff7837156094031b933de0ac1c2ab", "filename": "gcc/rtl.h", "status": "modified", "additions": 55, "deletions": 13, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -559,13 +559,29 @@ class GTY(()) rtx_nonjump_insn : public rtx_insn\n \n class GTY(()) rtx_jump_insn : public rtx_insn\n {\n+public:\n   /* No extra fields, but adds the invariant:\n        JUMP_P (X) aka (GET_CODE (X) == JUMP_INSN)\n      i.e. an instruction that can possibly jump.\n \n      This is an instance of:\n        DEF_RTL_EXPR(JUMP_INSN, \"jump_insn\", \"uuBeiie0\", RTX_INSN)\n      from rtl.def.  */\n+\n+  /* Returns jump target of this instruction.  The returned value is not\n+     necessarily a code label: it may also be a RETURN or SIMPLE_RETURN\n+     expression.  Also, when the code label is marked \"deleted\", it is\n+     replaced by a NOTE.  In some cases the value is NULL_RTX.  */\n+\n+  inline rtx jump_label () const;\n+\n+  /* Returns jump target cast to rtx_code_label *.  */\n+\n+  inline rtx_code_label *jump_target () const;\n+\n+  /* Set jump target.  */\n+\n+  inline void set_jump_target (rtx_code_label *);\n };\n \n class GTY(()) rtx_call_insn : public rtx_insn\n@@ -853,6 +869,14 @@ is_a_helper <rtx_jump_insn *>::test (rtx rt)\n   return JUMP_P (rt);\n }\n \n+template <>\n+template <>\n+inline bool\n+is_a_helper <rtx_jump_insn *>::test (rtx_insn *insn)\n+{\n+  return JUMP_P (insn);\n+}\n+\n template <>\n template <>\n inline bool\n@@ -1701,6 +1725,23 @@ inline rtx_insn *JUMP_LABEL_AS_INSN (const rtx_insn *insn)\n   return safe_as_a <rtx_insn *> (JUMP_LABEL (insn));\n }\n \n+/* Methods of rtx_jump_insn.  */\n+\n+inline rtx rtx_jump_insn::jump_label () const\n+{\n+  return JUMP_LABEL (this);\n+}\n+\n+inline rtx_code_label *rtx_jump_insn::jump_target () const\n+{\n+  return safe_as_a <rtx_code_label *> (JUMP_LABEL (this));\n+}\n+\n+inline void rtx_jump_insn::set_jump_target (rtx_code_label *target)\n+{\n+  JUMP_LABEL (this) = target;\n+}\n+\n /* Once basic blocks are found, each CODE_LABEL starts a chain that\n    goes through all the LABEL_REFs that jump to that label.  The chain\n    eventually winds up at the CODE_LABEL: it is circular.  */\n@@ -2699,24 +2740,24 @@ extern void decide_function_section (tree);\n extern rtx_insn *emit_insn_before (rtx, rtx);\n extern rtx_insn *emit_insn_before_noloc (rtx, rtx_insn *, basic_block);\n extern rtx_insn *emit_insn_before_setloc (rtx, rtx_insn *, int);\n-extern rtx_insn *emit_jump_insn_before (rtx, rtx);\n-extern rtx_insn *emit_jump_insn_before_noloc (rtx, rtx_insn *);\n-extern rtx_insn *emit_jump_insn_before_setloc (rtx, rtx_insn *, int);\n+extern rtx_jump_insn *emit_jump_insn_before (rtx, rtx);\n+extern rtx_jump_insn *emit_jump_insn_before_noloc (rtx, rtx_insn *);\n+extern rtx_jump_insn *emit_jump_insn_before_setloc (rtx, rtx_insn *, int);\n extern rtx_insn *emit_call_insn_before (rtx, rtx_insn *);\n extern rtx_insn *emit_call_insn_before_noloc (rtx, rtx_insn *);\n extern rtx_insn *emit_call_insn_before_setloc (rtx, rtx_insn *, int);\n extern rtx_insn *emit_debug_insn_before (rtx, rtx_insn *);\n extern rtx_insn *emit_debug_insn_before_noloc (rtx, rtx);\n extern rtx_insn *emit_debug_insn_before_setloc (rtx, rtx, int);\n extern rtx_barrier *emit_barrier_before (rtx);\n-extern rtx_insn *emit_label_before (rtx, rtx_insn *);\n+extern rtx_code_label *emit_label_before (rtx, rtx_insn *);\n extern rtx_note *emit_note_before (enum insn_note, rtx_insn *);\n extern rtx_insn *emit_insn_after (rtx, rtx);\n extern rtx_insn *emit_insn_after_noloc (rtx, rtx, basic_block);\n extern rtx_insn *emit_insn_after_setloc (rtx, rtx, int);\n-extern rtx_insn *emit_jump_insn_after (rtx, rtx);\n-extern rtx_insn *emit_jump_insn_after_noloc (rtx, rtx);\n-extern rtx_insn *emit_jump_insn_after_setloc (rtx, rtx, int);\n+extern rtx_jump_insn *emit_jump_insn_after (rtx, rtx);\n+extern rtx_jump_insn *emit_jump_insn_after_noloc (rtx, rtx);\n+extern rtx_jump_insn *emit_jump_insn_after_setloc (rtx, rtx, int);\n extern rtx_insn *emit_call_insn_after (rtx, rtx);\n extern rtx_insn *emit_call_insn_after_noloc (rtx, rtx);\n extern rtx_insn *emit_call_insn_after_setloc (rtx, rtx, int);\n@@ -2730,7 +2771,7 @@ extern rtx_insn *emit_insn (rtx);\n extern rtx_insn *emit_debug_insn (rtx);\n extern rtx_insn *emit_jump_insn (rtx);\n extern rtx_insn *emit_call_insn (rtx);\n-extern rtx_insn *emit_label (rtx);\n+extern rtx_code_label *emit_label (rtx);\n extern rtx_jump_table_data *emit_jump_table_data (rtx);\n extern rtx_barrier *emit_barrier (void);\n extern rtx_note *emit_note (enum insn_note);\n@@ -3066,6 +3107,7 @@ extern GTY(()) rtx pc_rtx;\n extern GTY(()) rtx cc0_rtx;\n extern GTY(()) rtx ret_rtx;\n extern GTY(()) rtx simple_return_rtx;\n+extern GTY(()) rtx_insn *invalid_insn_rtx;\n \n /* If HARD_FRAME_POINTER_REGNUM is defined, then a special dummy reg\n    is used to represent the frame pointer.  This is because the\n@@ -3397,14 +3439,14 @@ extern int eh_returnjump_p (rtx_insn *);\n extern int onlyjump_p (const rtx_insn *);\n extern int only_sets_cc0_p (const_rtx);\n extern int sets_cc0_p (const_rtx);\n-extern int invert_jump_1 (rtx_insn *, rtx);\n-extern int invert_jump (rtx_insn *, rtx, int);\n+extern int invert_jump_1 (rtx_jump_insn *, rtx);\n+extern int invert_jump (rtx_jump_insn *, rtx, int);\n extern int rtx_renumbered_equal_p (const_rtx, const_rtx);\n extern int true_regnum (const_rtx);\n extern unsigned int reg_or_subregno (const_rtx);\n extern int redirect_jump_1 (rtx_insn *, rtx);\n-extern void redirect_jump_2 (rtx_insn *, rtx, rtx, int, int);\n-extern int redirect_jump (rtx_insn *, rtx, int);\n+extern void redirect_jump_2 (rtx_jump_insn *, rtx, rtx, int, int);\n+extern int redirect_jump (rtx_jump_insn *, rtx, int);\n extern void rebuild_jump_labels (rtx_insn *);\n extern void rebuild_jump_labels_chain (rtx_insn *);\n extern rtx reversed_comparison (const_rtx, machine_mode);\n@@ -3487,7 +3529,7 @@ extern void print_inline_rtx (FILE *, const_rtx, int);\n    not be in sched-vis.c but in rtl.c, because they are not only used\n    by the scheduler anymore but for all \"slim\" RTL dumping.  */\n extern void dump_value_slim (FILE *, const_rtx, int);\n-extern void dump_insn_slim (FILE *, const_rtx);\n+extern void dump_insn_slim (FILE *, const rtx_insn *);\n extern void dump_rtl_slim (FILE *, const rtx_insn *, const rtx_insn *,\n \t\t\t   int, int);\n extern void print_value (pretty_printer *, const_rtx, int);"}, {"sha": "377b31f5dd96d5eee60236c8098056ded79323b2", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -2917,7 +2917,8 @@ rtx_referenced_p (const_rtx x, const_rtx body)\n bool\n tablejump_p (const rtx_insn *insn, rtx *labelp, rtx_jump_table_data **tablep)\n {\n-  rtx label, table;\n+  rtx label;\n+  rtx_insn *table;\n \n   if (!JUMP_P (insn))\n     return false;"}, {"sha": "3a10d26311e4bca81d9797e8bc779700881878a7", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -2649,7 +2649,7 @@ sched_analyze_2 (struct deps_desc *deps, rtx x, rtx_insn *insn)\n     case MEM:\n       {\n \t/* Reading memory.  */\n-\trtx u;\n+\trtx_insn_list *u;\n \trtx_insn_list *pending;\n \trtx_expr_list *pending_mem;\n \trtx t = x;\n@@ -2700,11 +2700,10 @@ sched_analyze_2 (struct deps_desc *deps, rtx x, rtx_insn *insn)\n \t\tpending_mem = pending_mem->next ();\n \t      }\n \n-\t    for (u = deps->last_pending_memory_flush; u; u = XEXP (u, 1))\n-\t      add_dependence (insn, as_a <rtx_insn *> (XEXP (u, 0)),\n-\t\t\t      REG_DEP_ANTI);\n+\t    for (u = deps->last_pending_memory_flush; u; u = u->next ())\n+\t      add_dependence (insn, u->insn (), REG_DEP_ANTI);\n \n-\t    for (u = deps->pending_jump_insns; u; u = XEXP (u, 1))\n+\t    for (u = deps->pending_jump_insns; u; u = u->next ())\n \t      if (deps_may_trap_p (x))\n \t\t{\n \t\t  if ((sched_deps_info->generate_spec_deps)\n@@ -2713,11 +2712,10 @@ sched_analyze_2 (struct deps_desc *deps, rtx x, rtx_insn *insn)\n \t\t      ds_t ds = set_dep_weak (DEP_ANTI, BEGIN_CONTROL,\n \t\t\t\t\t      MAX_DEP_WEAK);\n \t\t      \n-\t\t      note_dep (as_a <rtx_insn *> (XEXP (u, 0)), ds);\n+\t\t      note_dep (u->insn (), ds);\n \t\t    }\n \t\t  else\n-\t\t    add_dependence (insn, as_a <rtx_insn *> (XEXP (u, 0)),\n-\t\t\t\t    REG_DEP_CONTROL);\n+\t\t    add_dependence (insn, u->insn (), REG_DEP_CONTROL);\n \t\t}\n \t  }\n \n@@ -3088,7 +3086,7 @@ sched_analyze_insn (struct deps_desc *deps, rtx x, rtx_insn *insn)\n   if (DEBUG_INSN_P (insn))\n     {\n       rtx_insn *prev = deps->last_debug_insn;\n-      rtx u;\n+      rtx_insn_list *u;\n \n       if (!deps->readonly)\n \tdeps->last_debug_insn = insn;\n@@ -3100,8 +3098,8 @@ sched_analyze_insn (struct deps_desc *deps, rtx x, rtx_insn *insn)\n \t\t\t   REG_DEP_ANTI, false);\n \n       if (!sel_sched_p ())\n-\tfor (u = deps->last_pending_memory_flush; u; u = XEXP (u, 1))\n-\t  add_dependence (insn, as_a <rtx_insn *> (XEXP (u, 0)), REG_DEP_ANTI);\n+\tfor (u = deps->last_pending_memory_flush; u; u = u->next ())\n+\t  add_dependence (insn, u->insn (), REG_DEP_ANTI);\n \n       EXECUTE_IF_SET_IN_REG_SET (reg_pending_uses, 0, i, rsi)\n \t{"}, {"sha": "31794e66f4cfeb10977306d42689a55cea79f651", "filename": "gcc/sched-vis.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fsched-vis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fsched-vis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-vis.c?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -67,7 +67,7 @@ along with GCC; see the file COPYING3.  If not see\n    pointer, via str_pattern_slim, but this usage is discouraged.  */\n \n /* For insns we print patterns, and for some patterns we print insns...  */\n-static void print_insn_with_notes (pretty_printer *, const_rtx);\n+static void print_insn_with_notes (pretty_printer *, const rtx_insn *);\n \n /* This recognizes rtx'en classified as expressions.  These are always\n    represent some action on values or results of other expression, that\n@@ -669,7 +669,7 @@ print_pattern (pretty_printer *pp, const_rtx x, int verbose)\n    with their INSN_UIDs.  */\n \n void\n-print_insn (pretty_printer *pp, const_rtx x, int verbose)\n+print_insn (pretty_printer *pp, const rtx_insn *x, int verbose)\n {\n   if (verbose)\n     {\n@@ -787,7 +787,7 @@ print_insn (pretty_printer *pp, const_rtx x, int verbose)\n    note attached to the instruction.  */\n \n static void\n-print_insn_with_notes (pretty_printer *pp, const_rtx x)\n+print_insn_with_notes (pretty_printer *pp, const rtx_insn *x)\n {\n   pp_string (pp, print_rtx_head);\n   print_insn (pp, x, 1);\n@@ -823,7 +823,7 @@ dump_value_slim (FILE *f, const_rtx x, int verbose)\n /* Emit a slim dump of X (an insn) to the file F, including any register\n    note attached to the instruction.  */\n void\n-dump_insn_slim (FILE *f, const_rtx x)\n+dump_insn_slim (FILE *f, const rtx_insn *x)\n {\n   pretty_printer rtl_slim_pp;\n   rtl_slim_pp.buffer->stream = f;\n@@ -893,9 +893,9 @@ str_pattern_slim (const_rtx x)\n }\n \n /* Emit a slim dump of X (an insn) to stderr.  */\n-extern void debug_insn_slim (const_rtx);\n+extern void debug_insn_slim (const rtx_insn *);\n DEBUG_FUNCTION void\n-debug_insn_slim (const_rtx x)\n+debug_insn_slim (const rtx_insn *x)\n {\n   dump_insn_slim (stderr, x);\n }"}, {"sha": "16a080a623aa8eba891689f779dd69fc1133a860", "filename": "gcc/stmt.c", "status": "modified", "additions": 35, "deletions": 22, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -135,12 +135,12 @@ static void balance_case_nodes (case_node_ptr *, case_node_ptr);\n static int node_has_low_bound (case_node_ptr, tree);\n static int node_has_high_bound (case_node_ptr, tree);\n static int node_is_bounded (case_node_ptr, tree);\n-static void emit_case_nodes (rtx, case_node_ptr, rtx, int, tree);\n+static void emit_case_nodes (rtx, case_node_ptr, rtx_code_label *, int, tree);\n \f\n /* Return the rtx-label that corresponds to a LABEL_DECL,\n    creating it if necessary.  */\n \n-rtx\n+rtx_insn *\n label_rtx (tree label)\n {\n   gcc_assert (TREE_CODE (label) == LABEL_DECL);\n@@ -153,15 +153,15 @@ label_rtx (tree label)\n \tLABEL_PRESERVE_P (r) = 1;\n     }\n \n-  return DECL_RTL (label);\n+  return as_a <rtx_insn *> (DECL_RTL (label));\n }\n \n /* As above, but also put it on the forced-reference list of the\n    function that contains it.  */\n-rtx\n+rtx_insn *\n force_label_rtx (tree label)\n {\n-  rtx_insn *ref = as_a <rtx_insn *> (label_rtx (label));\n+  rtx_insn *ref = label_rtx (label);\n   tree function = decl_function_context (label);\n \n   gcc_assert (function);\n@@ -170,6 +170,14 @@ force_label_rtx (tree label)\n   return ref;\n }\n \n+/* As label_rtx, but ensures (in check build), that returned value is\n+   an existing label (i.e. rtx with code CODE_LABEL).  */\n+rtx_code_label *\n+jump_target_rtx (tree label)\n+{\n+  return as_a <rtx_code_label *> (label_rtx (label));\n+}\n+\n /* Add an unconditional jump to LABEL as the next sequential instruction.  */\n \n void\n@@ -196,7 +204,7 @@ emit_jump (rtx label)\n void\n expand_label (tree label)\n {\n-  rtx_insn *label_r = as_a <rtx_insn *> (label_rtx (label));\n+  rtx_code_label *label_r = jump_target_rtx (label);\n \n   do_pending_stack_adjust ();\n   emit_label (label_r);\n@@ -706,7 +714,7 @@ resolve_operand_name_1 (char *p, tree outputs, tree inputs, tree labels)\n void\n expand_naked_return (void)\n {\n-  rtx end_label;\n+  rtx_code_label *end_label;\n \n   clear_pending_stack_adjust ();\n   do_pending_stack_adjust ();\n@@ -721,12 +729,12 @@ expand_naked_return (void)\n /* Generate code to jump to LABEL if OP0 and OP1 are equal in mode MODE. PROB\n    is the probability of jumping to LABEL.  */\n static void\n-do_jump_if_equal (machine_mode mode, rtx op0, rtx op1, rtx label,\n+do_jump_if_equal (machine_mode mode, rtx op0, rtx op1, rtx_code_label *label,\n \t\t  int unsignedp, int prob)\n {\n   gcc_assert (prob <= REG_BR_PROB_BASE);\n   do_compare_rtx_and_jump (op0, op1, EQ, unsignedp, mode,\n-\t\t\t   NULL_RTX, NULL_RTX, label, prob);\n+\t\t\t   NULL_RTX, NULL, label, prob);\n }\n \f\n /* Do the insertion of a case label into case_list.  The labels are\n@@ -883,8 +891,8 @@ expand_switch_as_decision_tree_p (tree range,\n \n static void\n emit_case_decision_tree (tree index_expr, tree index_type,\n-\t\t\t struct case_node *case_list, rtx default_label,\n-                         int default_prob)\n+\t\t\t case_node_ptr case_list, rtx_code_label *default_label,\n+\t\t\t int default_prob)\n {\n   rtx index = expand_normal (index_expr);\n \n@@ -1142,7 +1150,7 @@ void\n expand_case (gswitch *stmt)\n {\n   tree minval = NULL_TREE, maxval = NULL_TREE, range = NULL_TREE;\n-  rtx default_label = NULL_RTX;\n+  rtx_code_label *default_label = NULL;\n   unsigned int count, uniq;\n   int i;\n   int ncases = gimple_switch_num_labels (stmt);\n@@ -1174,7 +1182,8 @@ expand_case (gswitch *stmt)\n   do_pending_stack_adjust ();\n \n   /* Find the default case target label.  */\n-  default_label = label_rtx (CASE_LABEL (gimple_switch_default_label (stmt)));\n+  default_label = jump_target_rtx\n+      (CASE_LABEL (gimple_switch_default_label (stmt)));\n   edge default_edge = EDGE_SUCC (bb, 0);\n   int default_prob = default_edge->probability;\n \n@@ -1324,7 +1333,7 @@ expand_sjlj_dispatch_table (rtx dispatch_index,\n       for (int i = 0; i < ncases; i++)\n         {\n \t  tree elt = dispatch_table[i];\n-\t  rtx lab = label_rtx (CASE_LABEL (elt));\n+\t  rtx_code_label *lab = jump_target_rtx (CASE_LABEL (elt));\n \t  do_jump_if_equal (index_mode, index, zero, lab, 0, -1);\n \t  force_expand_binop (index_mode, sub_optab,\n \t\t\t      index, CONST1_RTX (index_mode),\n@@ -1593,7 +1602,7 @@ node_is_bounded (case_node_ptr node, tree index_type)\n    tests for the value 50, then this node need not test anything.  */\n \n static void\n-emit_case_nodes (rtx index, case_node_ptr node, rtx default_label,\n+emit_case_nodes (rtx index, case_node_ptr node, rtx_code_label *default_label,\n \t\t int default_prob, tree index_type)\n {\n   /* If INDEX has an unsigned type, we must make unsigned branches.  */\n@@ -1621,7 +1630,8 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx default_label,\n \t\t\tconvert_modes (mode, imode,\n \t\t\t\t       expand_normal (node->low),\n \t\t\t\t       unsignedp),\n-\t\t\tlabel_rtx (node->code_label), unsignedp, probability);\n+\t\t\tjump_target_rtx (node->code_label),\n+\t\t\tunsignedp, probability);\n       /* Since this case is taken at this point, reduce its weight from\n          subtree_weight.  */\n       subtree_prob -= prob;\n@@ -1663,7 +1673,8 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx default_label,\n \t\t\t\t       LT, NULL_RTX, mode, unsignedp,\n \t\t\t\t       label_rtx (node->left->code_label),\n                                        probability);\n-\t      emit_case_nodes (index, node->right, default_label, default_prob, index_type);\n+\t      emit_case_nodes (index, node->right, default_label, default_prob,\n+\t\t\t       index_type);\n \t    }\n \n \t  /* If both children are single-valued cases with no\n@@ -1688,7 +1699,7 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx default_label,\n \t\t\t\tconvert_modes (mode, imode,\n \t\t\t\t\t       expand_normal (node->right->low),\n \t\t\t\t\t       unsignedp),\n-\t\t\t\tlabel_rtx (node->right->code_label),\n+\t\t\t\tjump_target_rtx (node->right->code_label),\n \t\t\t\tunsignedp, probability);\n \n \t      /* See if the value matches what the left hand side\n@@ -1700,7 +1711,7 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx default_label,\n \t\t\t\tconvert_modes (mode, imode,\n \t\t\t\t\t       expand_normal (node->left->low),\n \t\t\t\t\t       unsignedp),\n-\t\t\t\tlabel_rtx (node->left->code_label),\n+\t\t\t\tjump_target_rtx (node->left->code_label),\n \t\t\t\tunsignedp, probability);\n \t    }\n \n@@ -1787,7 +1798,8 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx default_label,\n \t\t\t        (mode, imode,\n \t\t\t         expand_normal (node->right->low),\n \t\t\t         unsignedp),\n-\t\t\t        label_rtx (node->right->code_label), unsignedp, probability);\n+\t\t\t\tjump_target_rtx (node->right->code_label),\n+\t\t\t\tunsignedp, probability);\n             }\n \t  }\n \n@@ -1829,7 +1841,8 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx default_label,\n \t\t\t        (mode, imode,\n \t\t\t         expand_normal (node->left->low),\n \t\t\t         unsignedp),\n-\t\t\t        label_rtx (node->left->code_label), unsignedp, probability);\n+\t\t\t\tjump_target_rtx (node->left->code_label),\n+\t\t\t\tunsignedp, probability);\n             }\n \t}\n     }\n@@ -2052,7 +2065,7 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx default_label,\n \t\t\t\t       mode, 1, default_label, probability);\n \t    }\n \n-\t  emit_jump (label_rtx (node->code_label));\n+\t  emit_jump (jump_target_rtx (node->code_label));\n \t}\n     }\n }"}, {"sha": "721c7ea5a04bd4bdc66f625d47be8712c2041136", "filename": "gcc/stmt.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fstmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fstmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.h?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -31,13 +31,18 @@ extern tree resolve_asm_operand_names (tree, tree, tree, tree);\n extern tree tree_overlaps_hard_reg_set (tree, HARD_REG_SET *);\n #endif\n \n-/* Return the CODE_LABEL rtx for a LABEL_DECL, creating it if necessary.  */\n-extern rtx label_rtx (tree);\n+/* Return the CODE_LABEL rtx for a LABEL_DECL, creating it if necessary.\n+   If label was deleted, the corresponding note\n+   (NOTE_INSN_DELETED{_DEBUG,}_LABEL) insn will be returned.  */\n+extern rtx_insn *label_rtx (tree);\n \n /* As label_rtx, but additionally the label is placed on the forced label\n    list of its containing function (i.e. it is treated as reachable even\n    if how is not obvious).  */\n-extern rtx force_label_rtx (tree);\n+extern rtx_insn *force_label_rtx (tree);\n+\n+/* As label_rtx, but checks that label was not deleted.  */\n+extern rtx_code_label *jump_target_rtx (tree);\n \n /* Expand a GIMPLE_SWITCH statement.  */\n extern void expand_case (gswitch *);"}, {"sha": "fdd2f4739083d96cd893e9387f00d2b2e743f731", "filename": "gcc/store-motion.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fstore-motion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1476d1bd020588ee81d1384354cf533c88849a3a/gcc%2Fstore-motion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstore-motion.c?ref=1476d1bd020588ee81d1384354cf533c88849a3a", "patch": "@@ -813,7 +813,7 @@ insert_store (struct st_expr * expr, edge e)\n     return 0;\n \n   reg = expr->reaching_reg;\n-  insn = as_a <rtx_insn *> (gen_move_insn (copy_rtx (expr->pattern), reg));\n+  insn = gen_move_insn (copy_rtx (expr->pattern), reg);\n \n   /* If we are inserting this expression on ALL predecessor edges of a BB,\n      insert it at the start of the BB, and reset the insert bits on the other\n@@ -954,7 +954,7 @@ replace_store_insn (rtx reg, rtx_insn *del, basic_block bb,\n   rtx mem, note, set, ptr;\n \n   mem = smexpr->pattern;\n-  insn = as_a <rtx_insn *> (gen_move_insn (reg, SET_SRC (single_set (del))));\n+  insn = gen_move_insn (reg, SET_SRC (single_set (del)));\n \n   for (ptr = smexpr->antic_stores; ptr; ptr = XEXP (ptr, 1))\n     if (XEXP (ptr, 0) == del)"}]}