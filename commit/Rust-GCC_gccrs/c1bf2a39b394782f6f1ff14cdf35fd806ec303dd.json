{"sha": "c1bf2a39b394782f6f1ff14cdf35fd806ec303dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzFiZjJhMzliMzk0NzgyZjZmMWZmMTRjZGYzNWZkODA2ZWMzMDNkZA==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2013-10-09T14:11:30Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2013-10-09T14:11:30Z"}, "message": "tree-flow.h: Remove all remaining prototypes...\n\n\n\n\t* tree-flow.h: Remove all remaining prototypes, enums and structs that\n\tare not related to tree-cfg.c.\n\t* tree-ssa-address.h: New file.  Relocate prototypes.\n\t* tree-ssa-address.c: (struct mem_address): Relocate from tree-flow.h.\n\t(addr_for_mem_ref): New.  Combine call to get_address_description and\n\treturn addr_for_mem_ref.\n\t* expr.c (expand_expr_real_1): Use new addr_for_mem_ref routine.\n\t* tree-ssa-live.h: Adjust prototypes.\n\t* passes.c: Include tree-ssa-live.h.\n\t* gimple-pretty-print.h (gimple_dump_bb): Add prototype.\n\t* graphite.c (graphite_transform_loops): Make static.\n\t(graphite_transforms, gate_graphite_transforms, pass_data_graphite,\n\tmake_pass_graphite, pass_data_graphite_transforms, \n\tmake_pass_graphite_transforms): Relocate here from tree-ssa-loop.c.\n\t* ipa-pure-const.c (warn_function_noreturn): Make static.\n\t(execute_warn_function_noreturn, gate_warn_function_noreturn,\n\tclass pass_warn_function_noreturn, make_pass_warn_function_noreturn):\n\tRelocate from tree-cfg.c\n\t* tree-cfg.c (tree_node_can_be_shared, gimple_empty_block_p): Make\n\tstatic.\n\t(execute_warn_function_noreturn, gate_warn_function_noreturn,\n\tclass pass_warn_function_noreturn, make_pass_warn_function_noreturn):\n\tMove to ipa-pure-const.c.\n\t(execute_fixup_cfg, class pass_fixup_cfg, make_pass_fixup_cfg): Relocate\n\tfrom tree-optimize.c.\n\t* tree-optimize.c (execute_fixup_cfg, class pass_fixup_cfg,\n\tmake_pass_fixup_cfg): Move to tree-cfg.c.\n\t* tree-chrec.h: (enum ev_direction): Relocate here from tree-flow.h.\n\tRelocate some prototypes.\n\t* tree-data-ref.h (tree_check_data_deps) Add prototype.\n\t* tree-dump.c (dump_function_to_file): Remove prototype.\n\tAdd tree-flow.h to the include file.\n\t* tree-dump.h: Remove prototype.\n\t* tree-parloops.h: New File.  Add prototypes.\n\t* tree-parloops.c (gate_tree_parallelize_loops, tree_parallelize_loops,\n\tpass_data_parallelize_loops,  make_pass_parallelize_loops): Relocate\n\tfrom tree-ssa-loop.c.\n\t* tree-predcom.c (run_tree_predictive_commoning,\n\tgate_tree_predictive_commoning, pass_data_predcom, make_pass_predcom):\n\tRelocate here from tree-ssa-loop.c.\n\t* tree-ssa-dom.c (tree_ssa_dominator_optimize) Don't call \n\tssa_name_values.release ().\n\t* tree-ssa-threadedge.h: New File.  Relocate prototypes here.\n\t(ssa_name_values): Relocate from tree-flow.h.\n\t* tree-ssa.h: Include tree-ssa-threadedge.h and tree-ssa-address.h.\n\t* tree-ssa-loop.c (run_tree_predictive_commoning,\n\tgate_tree_predictive_commoning, pass_data_predcom, make_pass_predcom,\n\tgraphite_transforms, gate_graphite_transforms, pass_data_graphite,\n\tmake_pass_graphite, pass_data_graphite_transforms,\n\tmake_pass_graphite_transforms, gate_tree_parallelize_loops,\n\ttree_parallelize_loops, pass_data_parallelize_loops,\n\tmake_pass_parallelize_loops): Move to other files.\n\t* tree-vectorizer.h (lpeel_tree_duplicate_loop_to_edge_cfg): Prototype\n\tmoved here.\n\t* tree.h: Remove prototypes from tree-address.c.\n\nFrom-SVN: r203320", "tree": {"sha": "5f0d797d661ee8ba11c4c05d7c09c7138fad2499", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f0d797d661ee8ba11c4c05d7c09c7138fad2499"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/comments", "author": null, "committer": null, "parents": [{"sha": "428e041efefedff5d94d49e62482861ef215620d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/428e041efefedff5d94d49e62482861ef215620d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/428e041efefedff5d94d49e62482861ef215620d"}], "stats": {"total": 1213, "additions": 663, "deletions": 550}, "files": [{"sha": "f86660ddb25d1894f7be5efa0df399e53e353103", "filename": "gcc/ChangeLog", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c1bf2a39b394782f6f1ff14cdf35fd806ec303dd", "patch": "@@ -1,3 +1,61 @@\n+2013-10-09  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\t* tree-flow.h: Remove all remaining prototypes, enums and structs that\n+\tare not related to tree-cfg.c.\n+\t* tree-ssa-address.h: New file.  Relocate prototypes.\n+\t* tree-ssa-address.c: (struct mem_address): Relocate from tree-flow.h.\n+\t(addr_for_mem_ref): New.  Combine call to get_address_description and\n+\treturn addr_for_mem_ref.\n+\t* expr.c (expand_expr_real_1): Use new addr_for_mem_ref routine.\n+\t* tree-ssa-live.h: Adjust prototypes.\n+\t* passes.c: Include tree-ssa-live.h.\n+\t* gimple-pretty-print.h (gimple_dump_bb): Add prototype.\n+\t* graphite.c (graphite_transform_loops): Make static.\n+\t(graphite_transforms, gate_graphite_transforms, pass_data_graphite,\n+\tmake_pass_graphite, pass_data_graphite_transforms, \n+\tmake_pass_graphite_transforms): Relocate here from tree-ssa-loop.c.\n+\t* ipa-pure-const.c (warn_function_noreturn): Make static.\n+\t(execute_warn_function_noreturn, gate_warn_function_noreturn,\n+\tclass pass_warn_function_noreturn, make_pass_warn_function_noreturn):\n+\tRelocate from tree-cfg.c\n+\t* tree-cfg.c (tree_node_can_be_shared, gimple_empty_block_p): Make\n+\tstatic.\n+\t(execute_warn_function_noreturn, gate_warn_function_noreturn,\n+\tclass pass_warn_function_noreturn, make_pass_warn_function_noreturn):\n+\tMove to ipa-pure-const.c.\n+\t(execute_fixup_cfg, class pass_fixup_cfg, make_pass_fixup_cfg): Relocate\n+\tfrom tree-optimize.c.\n+\t* tree-optimize.c (execute_fixup_cfg, class pass_fixup_cfg,\n+\tmake_pass_fixup_cfg): Move to tree-cfg.c.\n+\t* tree-chrec.h: (enum ev_direction): Relocate here from tree-flow.h.\n+\tRelocate some prototypes.\n+\t* tree-data-ref.h (tree_check_data_deps) Add prototype.\n+\t* tree-dump.c (dump_function_to_file): Remove prototype.\n+\tAdd tree-flow.h to the include file.\n+\t* tree-dump.h: Remove prototype.\n+\t* tree-parloops.h: New File.  Add prototypes.\n+\t* tree-parloops.c (gate_tree_parallelize_loops, tree_parallelize_loops,\n+\tpass_data_parallelize_loops,  make_pass_parallelize_loops): Relocate\n+\tfrom tree-ssa-loop.c.\n+\t* tree-predcom.c (run_tree_predictive_commoning,\n+\tgate_tree_predictive_commoning, pass_data_predcom, make_pass_predcom):\n+\tRelocate here from tree-ssa-loop.c.\n+\t* tree-ssa-dom.c (tree_ssa_dominator_optimize) Don't call \n+\tssa_name_values.release ().\n+\t* tree-ssa-threadedge.h: New File.  Relocate prototypes here.\n+\t(ssa_name_values): Relocate from tree-flow.h.\n+\t* tree-ssa.h: Include tree-ssa-threadedge.h and tree-ssa-address.h.\n+\t* tree-ssa-loop.c (run_tree_predictive_commoning,\n+\tgate_tree_predictive_commoning, pass_data_predcom, make_pass_predcom,\n+\tgraphite_transforms, gate_graphite_transforms, pass_data_graphite,\n+\tmake_pass_graphite, pass_data_graphite_transforms,\n+\tmake_pass_graphite_transforms, gate_tree_parallelize_loops,\n+\ttree_parallelize_loops, pass_data_parallelize_loops,\n+\tmake_pass_parallelize_loops): Move to other files.\n+\t* tree-vectorizer.h (lpeel_tree_duplicate_loop_to_edge_cfg): Prototype\n+\tmoved here.\n+\t* tree.h: Remove prototypes from tree-address.c.\n+\n 2013-10-09  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* tree-flow.h (tm_restart_node, gimple_df): Move to gimple-ssa.h."}, {"sha": "4975a64e1d869ffb2ed3fed21045811fe9b080e9", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=c1bf2a39b394782f6f1ff14cdf35fd806ec303dd", "patch": "@@ -9560,12 +9560,10 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       {\n \taddr_space_t as\n \t  = TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (TREE_OPERAND (exp, 0))));\n-\tstruct mem_address addr;\n \tenum insn_code icode;\n \tunsigned int align;\n \n-\tget_address_description (exp, &addr);\n-\top0 = addr_for_mem_ref (&addr, as, true);\n+\top0 = addr_for_mem_ref (exp, as, true);\n \top0 = memory_address_addr_space (mode, op0, as);\n \ttemp = gen_rtx_MEM (mode, op0);\n \tset_mem_attributes (temp, exp, 0);"}, {"sha": "5227eb8d584e2801afd410b3a38a4176f7bb2449", "filename": "gcc/gimple-pretty-print.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Fgimple-pretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Fgimple-pretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.h?ref=c1bf2a39b394782f6f1ff14cdf35fd806ec303dd", "patch": "@@ -33,6 +33,7 @@ extern void debug (gimple_statement_d &ref);\n extern void debug (gimple_statement_d *ptr);\n extern void print_gimple_expr (FILE *, gimple, int, int);\n extern void pp_gimple_stmt_1 (pretty_printer *, gimple, int, int);\n+extern void gimple_dump_bb (FILE *, basic_block, int, int);\n extern void gimple_dump_bb_for_graph (pretty_printer *, basic_block);\n \n #endif /* ! GCC_GIMPLE_PRETTY_PRINT_H */"}, {"sha": "7273c1120844d3cdb628db1030a65ea787f68422", "filename": "gcc/graphite.c", "status": "modified", "additions": 108, "deletions": 1, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=c1bf2a39b394782f6f1ff14cdf35fd806ec303dd", "patch": "@@ -55,6 +55,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-scalar-evolution.h\"\n #include \"sese.h\"\n #include \"dbgcnt.h\"\n+#include \"tree-parloops.h\"\n+#include \"tree-pass.h\"\n \n #ifdef HAVE_cloog\n \n@@ -301,10 +303,115 @@ graphite_transform_loops (void)\n \n #else /* If Cloog is not available: #ifndef HAVE_cloog.  */\n \n-void\n+static void\n graphite_transform_loops (void)\n {\n   sorry (\"Graphite loop optimizations cannot be used\");\n }\n \n #endif\n+\n+\n+static unsigned int\n+graphite_transforms (void)\n+{\n+  if (!current_loops)\n+    return 0;\n+\n+  graphite_transform_loops ();\n+\n+  return 0;\n+}\n+\n+static bool\n+gate_graphite_transforms (void)\n+{\n+  /* Enable -fgraphite pass if any one of the graphite optimization flags\n+     is turned on.  */\n+  if (flag_loop_block\n+      || flag_loop_interchange\n+      || flag_loop_strip_mine\n+      || flag_graphite_identity\n+      || flag_loop_parallelize_all\n+      || flag_loop_optimize_isl)\n+    flag_graphite = 1;\n+\n+  return flag_graphite != 0;\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_graphite =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"graphite0\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  true, /* has_gate */\n+  false, /* has_execute */\n+  TV_GRAPHITE, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_graphite : public gimple_opt_pass\n+{\n+public:\n+  pass_graphite (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_graphite, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_graphite_transforms (); }\n+\n+}; // class pass_graphite\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_graphite (gcc::context *ctxt)\n+{\n+  return new pass_graphite (ctxt);\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_graphite_transforms =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"graphite\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_GRAPHITE_TRANSFORMS, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_graphite_transforms : public gimple_opt_pass\n+{\n+public:\n+  pass_graphite_transforms (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_graphite_transforms, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_graphite_transforms (); }\n+  unsigned int execute () { return graphite_transforms (); }\n+\n+}; // class pass_graphite_transforms\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_graphite_transforms (gcc::context *ctxt)\n+{\n+  return new pass_graphite_transforms (ctxt);\n+}\n+\n+"}, {"sha": "85e5736d770efa82649d00823ba84319a9b523b5", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 58, "deletions": 1, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=c1bf2a39b394782f6f1ff14cdf35fd806ec303dd", "patch": "@@ -179,7 +179,7 @@ warn_function_const (tree decl, bool known_finite)\n \t\t\t known_finite, warned_about, \"const\");\n }\n \n-void\n+static void\n warn_function_noreturn (tree decl)\n {\n   static struct pointer_set_t *warned_about;\n@@ -1722,3 +1722,60 @@ make_pass_local_pure_const (gcc::context *ctxt)\n {\n   return new pass_local_pure_const (ctxt);\n }\n+\n+/* Emit noreturn warnings.  */\n+\n+static unsigned int\n+execute_warn_function_noreturn (void)\n+{\n+  if (!TREE_THIS_VOLATILE (current_function_decl)\n+      && EDGE_COUNT (EXIT_BLOCK_PTR->preds) == 0)\n+    warn_function_noreturn (current_function_decl);\n+  return 0;\n+}\n+\n+static bool\n+gate_warn_function_noreturn (void)\n+{\n+  return warn_suggest_attribute_noreturn;\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_warn_function_noreturn =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"*warn_function_noreturn\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  PROP_cfg, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_warn_function_noreturn : public gimple_opt_pass\n+{\n+public:\n+  pass_warn_function_noreturn (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_warn_function_noreturn, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_warn_function_noreturn (); }\n+  unsigned int execute () { return execute_warn_function_noreturn (); }\n+\n+}; // class pass_warn_function_noreturn\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_warn_function_noreturn (gcc::context *ctxt)\n+{\n+  return new pass_warn_function_noreturn (ctxt);\n+}\n+\n+"}, {"sha": "1b2202e8b82244fba1cfc8535138ecff38918f3e", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=c1bf2a39b394782f6f1ff14cdf35fd806ec303dd", "patch": "@@ -72,6 +72,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pretty-print.h\" /* for dump_function_header */\n #include \"context.h\"\n #include \"pass_manager.h\"\n+#include \"tree-ssa-live.h\"  /* For remove_unused_locals.  */\n \n using namespace gcc;\n "}, {"sha": "de66d07d8a236cfbbe69f77a84095c352a620131", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 143, "deletions": 58, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=c1bf2a39b394782f6f1ff14cdf35fd806ec303dd", "patch": "@@ -41,6 +41,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"pointer-set.h\"\n #include \"tree-inline.h\"\n #include \"target.h\"\n+#include \"tree-ssa-live.h\"\n \n /* This file contains functions for building the Control Flow Graph (CFG)\n    for a function tree.  */\n@@ -4449,7 +4450,7 @@ verify_gimple_in_seq (gimple_seq stmts)\n \n /* Return true when the T can be shared.  */\n \n-bool\n+static bool\n tree_node_can_be_shared (tree t)\n {\n   if (IS_TYPE_OR_DECL_P (t)\n@@ -5459,7 +5460,7 @@ gimple_move_block_after (basic_block bb, basic_block after)\n /* Return TRUE if block BB has no executable statements, otherwise return\n    FALSE.  */\n \n-bool\n+static bool\n gimple_empty_block_p (basic_block bb)\n {\n   /* BB must have no executable statements.  */\n@@ -8106,62 +8107,6 @@ make_pass_warn_function_return (gcc::context *ctxt)\n   return new pass_warn_function_return (ctxt);\n }\n \n-/* Emit noreturn warnings.  */\n-\n-static unsigned int\n-execute_warn_function_noreturn (void)\n-{\n-  if (!TREE_THIS_VOLATILE (current_function_decl)\n-      && EDGE_COUNT (EXIT_BLOCK_PTR->preds) == 0)\n-    warn_function_noreturn (current_function_decl);\n-  return 0;\n-}\n-\n-static bool\n-gate_warn_function_noreturn (void)\n-{\n-  return warn_suggest_attribute_noreturn;\n-}\n-\n-namespace {\n-\n-const pass_data pass_data_warn_function_noreturn =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"*warn_function_noreturn\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_gate */\n-  true, /* has_execute */\n-  TV_NONE, /* tv_id */\n-  PROP_cfg, /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  0, /* todo_flags_finish */\n-};\n-\n-class pass_warn_function_noreturn : public gimple_opt_pass\n-{\n-public:\n-  pass_warn_function_noreturn (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_warn_function_noreturn, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  bool gate () { return gate_warn_function_noreturn (); }\n-  unsigned int execute () { return execute_warn_function_noreturn (); }\n-\n-}; // class pass_warn_function_noreturn\n-\n-} // anon namespace\n-\n-gimple_opt_pass *\n-make_pass_warn_function_noreturn (gcc::context *ctxt)\n-{\n-  return new pass_warn_function_noreturn (ctxt);\n-}\n-\n-\n /* Walk a gimplified function and warn for functions whose return value is\n    ignored and attribute((warn_unused_result)) is set.  This is done before\n    inlining, so we don't have to worry about that.  */\n@@ -8278,6 +8223,146 @@ make_pass_warn_unused_result (gcc::context *ctxt)\n   return new pass_warn_unused_result (ctxt);\n }\n \n+/* IPA passes, compilation of earlier functions or inlining\n+   might have changed some properties, such as marked functions nothrow,\n+   pure, const or noreturn.\n+   Remove redundant edges and basic blocks, and create new ones if necessary.\n+\n+   This pass can't be executed as stand alone pass from pass manager, because\n+   in between inlining and this fixup the verify_flow_info would fail.  */\n+\n+unsigned int\n+execute_fixup_cfg (void)\n+{\n+  basic_block bb;\n+  gimple_stmt_iterator gsi;\n+  int todo = gimple_in_ssa_p (cfun) ? TODO_verify_ssa : 0;\n+  gcov_type count_scale;\n+  edge e;\n+  edge_iterator ei;\n+\n+  count_scale\n+      = GCOV_COMPUTE_SCALE (cgraph_get_node (current_function_decl)->count,\n+                            ENTRY_BLOCK_PTR->count);\n+\n+  ENTRY_BLOCK_PTR->count = cgraph_get_node (current_function_decl)->count;\n+  EXIT_BLOCK_PTR->count = apply_scale (EXIT_BLOCK_PTR->count,\n+                                       count_scale);\n+\n+  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n+    e->count = apply_scale (e->count, count_scale);\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      bb->count = apply_scale (bb->count, count_scale);\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  gimple stmt = gsi_stmt (gsi);\n+\t  tree decl = is_gimple_call (stmt)\n+\t\t      ? gimple_call_fndecl (stmt)\n+\t\t      : NULL;\n+\t  if (decl)\n+\t    {\n+\t      int flags = gimple_call_flags (stmt);\n+\t      if (flags & (ECF_CONST | ECF_PURE | ECF_LOOPING_CONST_OR_PURE))\n+\t\t{\n+\t\t  if (gimple_purge_dead_abnormal_call_edges (bb))\n+\t\t    todo |= TODO_cleanup_cfg;\n+\n+\t\t  if (gimple_in_ssa_p (cfun))\n+\t\t    {\n+\t\t      todo |= TODO_update_ssa | TODO_cleanup_cfg;\n+\t\t      update_stmt (stmt);\n+\t\t    }\n+\t\t}\n+\n+\t      if (flags & ECF_NORETURN\n+\t\t  && fixup_noreturn_call (stmt))\n+\t\ttodo |= TODO_cleanup_cfg;\n+\t     }\n+\n+\t  if (maybe_clean_eh_stmt (stmt)\n+\t      && gimple_purge_dead_eh_edges (bb))\n+\t    todo |= TODO_cleanup_cfg;\n+\t}\n+\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+        e->count = apply_scale (e->count, count_scale);\n+\n+      /* If we have a basic block with no successors that does not\n+\t end with a control statement or a noreturn call end it with\n+\t a call to __builtin_unreachable.  This situation can occur\n+\t when inlining a noreturn call that does in fact return.  */\n+      if (EDGE_COUNT (bb->succs) == 0)\n+\t{\n+\t  gimple stmt = last_stmt (bb);\n+\t  if (!stmt\n+\t      || (!is_ctrl_stmt (stmt)\n+\t\t  && (!is_gimple_call (stmt)\n+\t\t      || (gimple_call_flags (stmt) & ECF_NORETURN) == 0)))\n+\t    {\n+\t      stmt = gimple_build_call\n+\t\t  (builtin_decl_implicit (BUILT_IN_UNREACHABLE), 0);\n+\t      gimple_stmt_iterator gsi = gsi_last_bb (bb);\n+\t      gsi_insert_after (&gsi, stmt, GSI_NEW_STMT);\n+\t    }\n+\t}\n+    }\n+  if (count_scale != REG_BR_PROB_BASE)\n+    compute_function_frequency ();\n+\n+  /* We just processed all calls.  */\n+  if (cfun->gimple_df)\n+    vec_free (MODIFIED_NORETURN_CALLS (cfun));\n+\n+  /* Dump a textual representation of the flowgraph.  */\n+  if (dump_file)\n+    gimple_dump_cfg (dump_file, dump_flags);\n+\n+  if (current_loops\n+      && (todo & TODO_cleanup_cfg))\n+    loops_state_set (LOOPS_NEED_FIXUP);\n+\n+  return todo;\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_fixup_cfg =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"*free_cfg_annotations\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  false, /* has_gate */\n+  true, /* has_execute */\n+  TV_NONE, /* tv_id */\n+  PROP_cfg, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_fixup_cfg : public gimple_opt_pass\n+{\n+public:\n+  pass_fixup_cfg (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_fixup_cfg, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_fixup_cfg (m_ctxt); }\n+  unsigned int execute () { return execute_fixup_cfg (); }\n+\n+}; // class pass_fixup_cfg\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_fixup_cfg (gcc::context *ctxt)\n+{\n+  return new pass_fixup_cfg (ctxt);\n+}\n \n /* Garbage collection support for edge_def.  */\n "}, {"sha": "2c689d8839cfce35862aa43a154f5f9a63e1e66b", "filename": "gcc/tree-chrec.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Ftree-chrec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Ftree-chrec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.h?ref=c1bf2a39b394782f6f1ff14cdf35fd806ec303dd", "patch": "@@ -52,6 +52,8 @@ tree_is_chrec (const_tree expr)\n }\n \n \f\n+enum ev_direction {EV_DIR_GROWS, EV_DIR_DECREASES, EV_DIR_UNKNOWN};\n+enum ev_direction scev_direction (const_tree);\n \n /* Chrec folding functions.  */\n extern tree chrec_fold_plus (tree, tree, tree);\n@@ -72,6 +74,8 @@ extern tree hide_evolution_in_other_loops_than_loop (tree, unsigned);\n extern tree reset_evolution_in_loop (unsigned, tree, tree);\n extern tree chrec_merge (tree, tree);\n extern void for_each_scev_op (tree *, bool (*) (tree *, void *), void *);\n+extern bool convert_affine_scev (struct loop *, tree, tree *, tree *, gimple,\n+\t\t\t\t bool);\n \n /* Observers.  */\n extern bool eq_evolutions_p (const_tree, const_tree);"}, {"sha": "8cd7ef801da8c4f646260bbb5bdacaa181815cf5", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=c1bf2a39b394782f6f1ff14cdf35fd806ec303dd", "patch": "@@ -406,6 +406,7 @@ extern bool dr_may_alias_p (const struct data_reference *,\n \t\t\t    const struct data_reference *, bool);\n extern bool dr_equal_offsets_p (struct data_reference *,\n                                 struct data_reference *);\n+extern void tree_check_data_deps (void);\n \n \n /* Return true when the base objects of data references A and B are"}, {"sha": "0dd97291dea6e0636a3641ed9f71216817c59543", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=c1bf2a39b394782f6f1ff14cdf35fd806ec303dd", "patch": "@@ -29,6 +29,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"langhooks.h\"\n #include \"tree-iterator.h\"\n #include \"tree-pretty-print.h\"\n+#include \"tree-flow.h\"\n \n static unsigned int queue (dump_info_p, const_tree, int);\n static void dump_index (dump_info_p, unsigned int);"}, {"sha": "edd32e7160112a2eebb24788615176810064a3c9", "filename": "gcc/tree-dump.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Ftree-dump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Ftree-dump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.h?ref=c1bf2a39b394782f6f1ff14cdf35fd806ec303dd", "patch": "@@ -90,7 +90,4 @@ extern void queue_and_dump_type (dump_info_p, const_tree);\n extern void dump_function (int, tree);\n extern int dump_flag (dump_info_p, int, const_tree);\n \n-/* In tree-cfg.c  */\n-extern void dump_function_to_file (tree, FILE *, int);\n-\n #endif /* ! GCC_TREE_DUMP_H */"}, {"sha": "c4678d9fcf4ba57c3bb25da917f0033ff9f1f7fc", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 44, "deletions": 116, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=c1bf2a39b394782f6f1ff14cdf35fd806ec303dd", "patch": "@@ -87,120 +87,77 @@ extern void free_omp_regions (void);\n void omp_expand_local (basic_block);\n tree copy_var_decl (tree, tree, tree);\n \n-/*---------------------------------------------------------------------------\n-\t\t\t      Function prototypes\n----------------------------------------------------------------------------*/\n-/* In tree-cfg.c  */\n-\n /* Location to track pending stmt for edge insertion.  */\n #define PENDING_STMT(e)\t((e)->insns.g)\n \n-extern void delete_tree_cfg_annotations (void);\n-extern bool stmt_ends_bb_p (gimple);\n-extern bool is_ctrl_stmt (gimple);\n-extern bool is_ctrl_altering_stmt (gimple);\n-extern bool simple_goto_p (gimple);\n-extern bool stmt_can_make_abnormal_goto (gimple);\n+extern void init_empty_tree_cfg_for_function (struct function *);\n+extern void init_empty_tree_cfg (void);\n+extern void fold_cond_expr_cond (void);\n+extern void start_recording_case_labels (void);\n+extern void end_recording_case_labels (void);\n+extern basic_block label_to_block_fn (struct function *, tree);\n+#define label_to_block(t) (label_to_block_fn (cfun, t))\n+extern void make_abnormal_goto_edges (basic_block, bool);\n+extern void cleanup_dead_labels (void);\n+extern void group_case_labels_stmt (gimple);\n+extern void group_case_labels (void);\n+extern void replace_uses_by (tree, tree);\n extern basic_block single_noncomplex_succ (basic_block bb);\n-extern void gimple_dump_bb (FILE *, basic_block, int, int);\n+extern void notice_special_calls (gimple);\n+extern void clear_special_calls (void);\n+extern edge find_taken_edge (basic_block, tree);\n extern void gimple_debug_bb (basic_block);\n extern basic_block gimple_debug_bb_n (int);\n-extern void gimple_dump_cfg (FILE *, int);\n extern void gimple_debug_cfg (int);\n+extern void gimple_dump_cfg (FILE *, int);\n extern void dump_cfg_stats (FILE *);\n-extern void dot_cfg (void);\n extern void debug_cfg_stats (void);\n-extern void debug_loops (int);\n-extern void debug_loop (struct loop *, int);\n-extern void debug (struct loop &ref);\n-extern void debug (struct loop *ptr);\n-extern void debug_verbose (struct loop &ref);\n-extern void debug_verbose (struct loop *ptr);\n-extern void debug_loop_num (unsigned, int);\n-extern void print_loops (FILE *, int);\n-extern void print_loops_bb (FILE *, basic_block, int, int);\n-extern void cleanup_dead_labels (void);\n-extern void group_case_labels_stmt (gimple);\n-extern void group_case_labels (void);\n+extern bool stmt_can_make_abnormal_goto (gimple);\n+extern bool is_ctrl_stmt (gimple);\n+extern bool is_ctrl_altering_stmt (gimple);\n+extern bool simple_goto_p (gimple);\n+extern bool stmt_ends_bb_p (gimple);\n+extern void delete_tree_cfg_annotations (void);\n extern gimple first_stmt (basic_block);\n extern gimple last_stmt (basic_block);\n extern gimple last_and_only_stmt (basic_block);\n-extern edge find_taken_edge (basic_block, tree);\n-extern basic_block label_to_block_fn (struct function *, tree);\n-#define label_to_block(t) (label_to_block_fn (cfun, t))\n-extern void notice_special_calls (gimple);\n-extern void clear_special_calls (void);\n extern void verify_gimple_in_seq (gimple_seq);\n extern void verify_gimple_in_cfg (struct function *);\n extern tree gimple_block_label (basic_block);\n-extern void extract_true_false_edges_from_block (basic_block, edge *, edge *);\n+extern void add_phi_args_after_copy_bb (basic_block);\n+extern void add_phi_args_after_copy (basic_block *, unsigned, edge);\n extern bool gimple_duplicate_sese_region (edge, edge, basic_block *, unsigned,\n \t\t\t\t\tbasic_block *, bool);\n extern bool gimple_duplicate_sese_tail (edge, edge, basic_block *, unsigned,\n \t\t\t\t      basic_block *);\n extern void gather_blocks_in_sese_region (basic_block entry, basic_block exit,\n \t\t\t\t\t  vec<basic_block> *bbs_p);\n-extern void add_phi_args_after_copy_bb (basic_block);\n-extern void add_phi_args_after_copy (basic_block *, unsigned, edge);\n+extern basic_block move_sese_region_to_fn (struct function *, basic_block,\n+\t\t\t\t           basic_block, tree);\n+extern void dump_function_to_file (tree, FILE *, int);\n+extern void debug_function (tree, int) ;\n+extern void print_loops_bb (FILE *, basic_block, int, int);\n+extern void print_loops (FILE *, int);\n+extern void debug (struct loop &ref);\n+extern void debug (struct loop *ptr);\n+extern void debug_verbose (struct loop &ref);\n+extern void debug_verbose (struct loop *ptr);\n+extern void debug_loops (int);\n+extern void debug_loop (struct loop *, int);\n+extern void debug_loop_num (unsigned, int);\n+void remove_edge_and_dominated_blocks (edge);\n extern bool gimple_purge_dead_eh_edges (basic_block);\n extern bool gimple_purge_all_dead_eh_edges (const_bitmap);\n extern bool gimple_purge_dead_abnormal_call_edges (basic_block);\n extern bool gimple_purge_all_dead_abnormal_call_edges (const_bitmap);\n-extern tree gimplify_build1 (gimple_stmt_iterator *, enum tree_code,\n-\t\t\t     tree, tree);\n-extern tree gimplify_build2 (gimple_stmt_iterator *, enum tree_code,\n-\t\t\t     tree, tree, tree);\n extern tree gimplify_build3 (gimple_stmt_iterator *, enum tree_code,\n \t\t\t     tree, tree, tree, tree);\n-extern void init_empty_tree_cfg (void);\n-extern void init_empty_tree_cfg_for_function (struct function *);\n-extern void fold_cond_expr_cond (void);\n-extern void make_abnormal_goto_edges (basic_block, bool);\n-extern void replace_uses_by (tree, tree);\n-extern void start_recording_case_labels (void);\n-extern void end_recording_case_labels (void);\n-extern basic_block move_sese_region_to_fn (struct function *, basic_block,\n-\t\t\t\t           basic_block, tree);\n-void remove_edge_and_dominated_blocks (edge);\n-bool tree_node_can_be_shared (tree);\n-\n-\n-\n-/* In tree-ssa-loop*.c  */\n-\n-unsigned tree_predictive_commoning (void);\n-bool parallelize_loops (void);\n-\n-bool convert_affine_scev (struct loop *, tree, tree *, tree *, gimple, bool);\n-\n-enum ev_direction {EV_DIR_GROWS, EV_DIR_DECREASES, EV_DIR_UNKNOWN};\n-enum ev_direction scev_direction (const_tree);\n-\n-struct loop *slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *, edge);\n-\n-/* In tree-ssa-threadedge.c */\n-extern void threadedge_initialize_values (void);\n-extern void threadedge_finalize_values (void);\n-extern vec<tree> ssa_name_values;\n-#define SSA_NAME_VALUE(x) \\\n-    (SSA_NAME_VERSION (x) < ssa_name_values.length () \\\n-     ? ssa_name_values[SSA_NAME_VERSION (x)] \\\n-     : NULL_TREE)\n-extern void set_ssa_name_value (tree, tree);\n-extern bool potentially_threadable_block (basic_block);\n-extern void thread_across_edge (gimple, edge, bool,\n-\t\t\t\tvec<tree> *, tree (*) (gimple, gimple));\n-extern void propagate_threaded_block_debug_into (basic_block, basic_block);\n-\n-/* In tree-loop-linear.c  */\n-extern void linear_transform_loops (void);\n-extern unsigned perfect_loop_nest_depth (struct loop *);\n-\n-/* In graphite.c  */\n-extern void graphite_transform_loops (void);\n-\n-/* In tree-data-ref.c  */\n-extern void tree_check_data_deps (void);\n+extern tree gimplify_build2 (gimple_stmt_iterator *, enum tree_code,\n+\t\t\t     tree, tree, tree);\n+extern tree gimplify_build1 (gimple_stmt_iterator *, enum tree_code,\n+\t\t\t     tree, tree);\n+extern void extract_true_false_edges_from_block (basic_block, edge *, edge *);\n+extern unsigned int execute_fixup_cfg (void);\n \n /* In gimplify.c  */\n tree force_gimple_operand_1 (tree, gimple_seq *, gimple_predicate, tree);\n@@ -212,34 +169,5 @@ tree force_gimple_operand_gsi (gimple_stmt_iterator *, tree, bool, tree,\n \t\t\t       bool, enum gsi_iterator_update);\n tree gimple_fold_indirect_ref (tree);\n \n-/* In tree-ssa-live.c */\n-extern void remove_unused_locals (void);\n-extern void dump_scope_blocks (FILE *, int);\n-extern void debug_scope_blocks (int);\n-extern void debug_scope_block (tree, int);\n-\n-/* In tree-ssa-address.c  */\n-\n-/* Description of a memory address.  */\n-\n-struct mem_address\n-{\n-  tree symbol, base, index, step, offset;\n-};\n-\n-struct affine_tree_combination;\n-tree create_mem_ref (gimple_stmt_iterator *, tree,\n-\t\t     struct affine_tree_combination *, tree, tree, tree, bool);\n-rtx addr_for_mem_ref (struct mem_address *, addr_space_t, bool);\n-void get_address_description (tree, struct mem_address *);\n-tree maybe_fold_tmr (tree);\n-\n-unsigned int execute_fixup_cfg (void);\n-\n-/* In ipa-pure-const.c  */\n-void warn_function_noreturn (tree);\n-\n-/* In tree-parloops.c  */\n-bool parallelized_function_p (tree);\n \n #endif /* _TREE_FLOW_H  */"}, {"sha": "d823dbed412d98188321cd1ffb8327b5da71c2f0", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 0, "deletions": 139, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=c1bf2a39b394782f6f1ff14cdf35fd806ec303dd", "patch": "@@ -127,143 +127,4 @@ make_pass_cleanup_cfg_post_optimizing (gcc::context *ctxt)\n   return new pass_cleanup_cfg_post_optimizing (ctxt);\n }\n \n-/* IPA passes, compilation of earlier functions or inlining\n-   might have changed some properties, such as marked functions nothrow,\n-   pure, const or noreturn.\n-   Remove redundant edges and basic blocks, and create new ones if necessary.\n \n-   This pass can't be executed as stand alone pass from pass manager, because\n-   in between inlining and this fixup the verify_flow_info would fail.  */\n-\n-unsigned int\n-execute_fixup_cfg (void)\n-{\n-  basic_block bb;\n-  gimple_stmt_iterator gsi;\n-  int todo = gimple_in_ssa_p (cfun) ? TODO_verify_ssa : 0;\n-  gcov_type count_scale;\n-  edge e;\n-  edge_iterator ei;\n-\n-  count_scale\n-      = GCOV_COMPUTE_SCALE (cgraph_get_node (current_function_decl)->count,\n-                            ENTRY_BLOCK_PTR->count);\n-\n-  ENTRY_BLOCK_PTR->count = cgraph_get_node (current_function_decl)->count;\n-  EXIT_BLOCK_PTR->count = apply_scale (EXIT_BLOCK_PTR->count,\n-                                       count_scale);\n-\n-  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n-    e->count = apply_scale (e->count, count_scale);\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      bb->count = apply_scale (bb->count, count_scale);\n-      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-\t{\n-\t  gimple stmt = gsi_stmt (gsi);\n-\t  tree decl = is_gimple_call (stmt)\n-\t\t      ? gimple_call_fndecl (stmt)\n-\t\t      : NULL;\n-\t  if (decl)\n-\t    {\n-\t      int flags = gimple_call_flags (stmt);\n-\t      if (flags & (ECF_CONST | ECF_PURE | ECF_LOOPING_CONST_OR_PURE))\n-\t\t{\n-\t\t  if (gimple_purge_dead_abnormal_call_edges (bb))\n-\t\t    todo |= TODO_cleanup_cfg;\n-\n-\t\t  if (gimple_in_ssa_p (cfun))\n-\t\t    {\n-\t\t      todo |= TODO_update_ssa | TODO_cleanup_cfg;\n-\t\t      update_stmt (stmt);\n-\t\t    }\n-\t\t}\n-\n-\t      if (flags & ECF_NORETURN\n-\t\t  && fixup_noreturn_call (stmt))\n-\t\ttodo |= TODO_cleanup_cfg;\n-\t     }\n-\n-\t  if (maybe_clean_eh_stmt (stmt)\n-\t      && gimple_purge_dead_eh_edges (bb))\n-\t    todo |= TODO_cleanup_cfg;\n-\t}\n-\n-      FOR_EACH_EDGE (e, ei, bb->succs)\n-        e->count = apply_scale (e->count, count_scale);\n-\n-      /* If we have a basic block with no successors that does not\n-\t end with a control statement or a noreturn call end it with\n-\t a call to __builtin_unreachable.  This situation can occur\n-\t when inlining a noreturn call that does in fact return.  */\n-      if (EDGE_COUNT (bb->succs) == 0)\n-\t{\n-\t  gimple stmt = last_stmt (bb);\n-\t  if (!stmt\n-\t      || (!is_ctrl_stmt (stmt)\n-\t\t  && (!is_gimple_call (stmt)\n-\t\t      || (gimple_call_flags (stmt) & ECF_NORETURN) == 0)))\n-\t    {\n-\t      stmt = gimple_build_call\n-\t\t  (builtin_decl_implicit (BUILT_IN_UNREACHABLE), 0);\n-\t      gimple_stmt_iterator gsi = gsi_last_bb (bb);\n-\t      gsi_insert_after (&gsi, stmt, GSI_NEW_STMT);\n-\t    }\n-\t}\n-    }\n-  if (count_scale != REG_BR_PROB_BASE)\n-    compute_function_frequency ();\n-\n-  /* We just processed all calls.  */\n-  if (cfun->gimple_df)\n-    vec_free (MODIFIED_NORETURN_CALLS (cfun));\n-\n-  /* Dump a textual representation of the flowgraph.  */\n-  if (dump_file)\n-    gimple_dump_cfg (dump_file, dump_flags);\n-\n-  if (current_loops\n-      && (todo & TODO_cleanup_cfg))\n-    loops_state_set (LOOPS_NEED_FIXUP);\n-\n-  return todo;\n-}\n-\n-namespace {\n-\n-const pass_data pass_data_fixup_cfg =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"*free_cfg_annotations\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  false, /* has_gate */\n-  true, /* has_execute */\n-  TV_NONE, /* tv_id */\n-  PROP_cfg, /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  0, /* todo_flags_finish */\n-};\n-\n-class pass_fixup_cfg : public gimple_opt_pass\n-{\n-public:\n-  pass_fixup_cfg (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_fixup_cfg, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  opt_pass * clone () { return new pass_fixup_cfg (m_ctxt); }\n-  unsigned int execute () { return execute_fixup_cfg (); }\n-\n-}; // class pass_fixup_cfg\n-\n-} // anon namespace\n-\n-gimple_opt_pass *\n-make_pass_fixup_cfg (gcc::context *ctxt)\n-{\n-  return new pass_fixup_cfg (ctxt);\n-}"}, {"sha": "056950dd066b185eca15b4237a151ac1a8065945", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=c1bf2a39b394782f6f1ff14cdf35fd806ec303dd", "patch": "@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"langhooks.h\"\n #include \"tree-vectorizer.h\"\n #include \"tree-hasher.h\"\n+#include \"tree-parloops.h\"\n \n /* This pass tries to distribute iterations of loops into several threads.\n    The implementation is straightforward -- for each loop we test whether its\n@@ -2240,4 +2241,62 @@ parallelize_loops (void)\n   return changed;\n }\n \n+/* Parallelization.  */\n+\n+static bool\n+gate_tree_parallelize_loops (void)\n+{\n+  return flag_tree_parallelize_loops > 1;\n+}\n+\n+static unsigned\n+tree_parallelize_loops (void)\n+{\n+  if (number_of_loops (cfun) <= 1)\n+    return 0;\n+\n+  if (parallelize_loops ())\n+    return TODO_cleanup_cfg | TODO_rebuild_alias;\n+  return 0;\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_parallelize_loops =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"parloops\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_PARALLELIZE_LOOPS, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_flow, /* todo_flags_finish */\n+};\n+\n+class pass_parallelize_loops : public gimple_opt_pass\n+{\n+public:\n+  pass_parallelize_loops (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_parallelize_loops, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_tree_parallelize_loops (); }\n+  unsigned int execute () { return tree_parallelize_loops (); }\n+\n+}; // class pass_parallelize_loops\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_parallelize_loops (gcc::context *ctxt)\n+{\n+  return new pass_parallelize_loops (ctxt);\n+}\n+\n+\n #include \"gt-tree-parloops.h\""}, {"sha": "35926b64a637a03f62318c1b05e58c2c6f6033cb", "filename": "gcc/tree-parloops.h", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Ftree-parloops.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Ftree-parloops.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.h?ref=c1bf2a39b394782f6f1ff14cdf35fd806ec303dd", "patch": "@@ -0,0 +1,26 @@\n+/* Header file for loop autoparallelization.\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_TREE_PARLOOPS_H\n+#define GCC_TREE_PARLOOPS_H\n+\n+extern bool parallelized_function_p (tree);\n+extern bool parallelize_loops (void);\n+\n+#endif /* GCC_TREE_PARLOOPS_H */"}, {"sha": "ba3e1318e7b703264d1db7bdbefa64edcc5fe16c", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=c1bf2a39b394782f6f1ff14cdf35fd806ec303dd", "patch": "@@ -2563,3 +2563,60 @@ tree_predictive_commoning (void)\n \n   return ret;\n }\n+\n+/* Predictive commoning Pass.  */\n+\n+static unsigned\n+run_tree_predictive_commoning (void)\n+{\n+  if (!current_loops)\n+    return 0;\n+\n+  return tree_predictive_commoning ();\n+}\n+\n+static bool\n+gate_tree_predictive_commoning (void)\n+{\n+  return flag_predictive_commoning != 0;\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_predcom =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"pcom\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_PREDCOM, /* tv_id */\n+  PROP_cfg, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_update_ssa_only_virtuals, /* todo_flags_finish */\n+};\n+\n+class pass_predcom : public gimple_opt_pass\n+{\n+public:\n+  pass_predcom (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_predcom, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_tree_predictive_commoning (); }\n+  unsigned int execute () { return run_tree_predictive_commoning (); }\n+\n+}; // class pass_predcom\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_predcom (gcc::context *ctxt)\n+{\n+  return new pass_predcom (ctxt);\n+}\n+\n+"}, {"sha": "49b69b82da3b9ffa0df02cc1bc66df31499efbf8", "filename": "gcc/tree-ssa-address.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Ftree-ssa-address.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Ftree-ssa-address.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-address.c?ref=c1bf2a39b394782f6f1ff14cdf35fd806ec303dd", "patch": "@@ -42,6 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ggc.h\"\n #include \"target.h\"\n #include \"expmed.h\"\n+#include \"tree-ssa-address.h\"\n \n /* TODO -- handling of symbols (according to Richard Hendersons\n    comments, http://gcc.gnu.org/ml/gcc-patches/2005-04/msg00949.html):\n@@ -173,6 +174,13 @@ gen_addr_rtx (enum machine_mode address_mode,\n     *addr = const0_rtx;\n }\n \n+/* Description of a memory address.  */\n+\n+struct mem_address\n+{\n+  tree symbol, base, index, step, offset;\n+};\n+\n /* Returns address for TARGET_MEM_REF with parameters given by ADDR\n    in address space AS.\n    If REALLY_EXPAND is false, just make fake registers instead\n@@ -256,6 +264,17 @@ addr_for_mem_ref (struct mem_address *addr, addr_space_t as,\n   return address;\n }\n \n+/* implement addr_for_mem_ref() directly from a tree, which avoids exporting\n+   the mem_address structure.  */\n+\n+rtx\n+addr_for_mem_ref (tree exp, addr_space_t as, bool really_expand)\n+{\n+  struct mem_address addr;\n+  get_address_description (exp, &addr);\n+  return addr_for_mem_ref (&addr, as, really_expand);\n+}\n+\n /* Returns address of MEM_REF in TYPE.  */\n \n tree"}, {"sha": "803f9c82fb1ba34e69362cfdd335589bb67c371b", "filename": "gcc/tree-ssa-address.h", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Ftree-ssa-address.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Ftree-ssa-address.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-address.h?ref=c1bf2a39b394782f6f1ff14cdf35fd806ec303dd", "patch": "@@ -0,0 +1,32 @@\n+/* Header file for memory address lowering and mode selection.\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_TREE_SSA_ADDRESS_H\n+#define GCC_TREE_SSA_ADDRESS_H\n+\n+extern rtx addr_for_mem_ref (struct mem_address *, addr_space_t, bool);\n+extern rtx addr_for_mem_ref (tree exp, addr_space_t as, bool really_expand);\n+extern void get_address_description (tree, struct mem_address *);\n+extern tree tree_mem_ref_addr (tree, tree);\n+tree create_mem_ref (gimple_stmt_iterator *, tree,\n+\t\t     struct affine_tree_combination *, tree, tree, tree, bool);\n+extern void copy_ref_info (tree, tree);\n+tree maybe_fold_tmr (tree);\n+\n+#endif /* GCC_TREE_SSA_ADDRESS_H */"}, {"sha": "6292bb0bd56c6599cfad1d3fd75e0916b6014b20", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=c1bf2a39b394782f6f1ff14cdf35fd806ec303dd", "patch": "@@ -902,7 +902,6 @@ tree_ssa_dominator_optimize (void)\n \n   /* Free the value-handle array.  */\n   threadedge_finalize_values ();\n-  ssa_name_values.release ();\n \n   return 0;\n }"}, {"sha": "0aa9f0c43318d9ffd97ef970adacaa862ab2829c", "filename": "gcc/tree-ssa-live.h", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Ftree-ssa-live.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Ftree-ssa-live.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.h?ref=c1bf2a39b394782f6f1ff14cdf35fd806ec303dd", "patch": "@@ -70,12 +70,16 @@ typedef struct _var_map\n \n extern var_map init_var_map (int);\n extern void delete_var_map (var_map);\n-extern void dump_var_map (FILE *, var_map);\n-extern void debug (_var_map &ref);\n-extern void debug (_var_map *ptr);\n extern int var_union (var_map, tree, tree);\n extern void partition_view_normal (var_map, bool);\n extern void partition_view_bitmap (var_map, bitmap, bool);\n+extern void dump_scope_blocks (FILE *, int);\n+extern void debug_scope_block (tree, int);\n+extern void debug_scope_blocks (int);\n+extern void remove_unused_locals (void);\n+extern void dump_var_map (FILE *, var_map);\n+extern void debug (_var_map &ref);\n+extern void debug (_var_map *ptr);\n #ifdef ENABLE_CHECKING\n extern void register_ssa_partition_check (tree ssa_var);\n #endif\n@@ -241,16 +245,15 @@ typedef struct tree_live_info_d\n } *tree_live_info_p;\n \n \n-extern tree_live_info_p calculate_live_ranges (var_map);\n-extern void calculate_live_on_exit (tree_live_info_p);\n-extern void delete_tree_live_info (tree_live_info_p);\n-\n #define LIVEDUMP_ENTRY\t0x01\n #define LIVEDUMP_EXIT\t0x02\n #define LIVEDUMP_ALL\t(LIVEDUMP_ENTRY | LIVEDUMP_EXIT)\n-extern void dump_live_info (FILE *, tree_live_info_p, int);\n+extern void delete_tree_live_info (tree_live_info_p);\n+extern void calculate_live_on_exit (tree_live_info_p);\n+extern tree_live_info_p calculate_live_ranges (var_map);\n extern void debug (tree_live_info_d &ref);\n extern void debug (tree_live_info_d *ptr);\n+extern void dump_live_info (FILE *, tree_live_info_p, int);\n \n \n /*  Return TRUE if P is marked as a global in LIVE.  */"}, {"sha": "cbb14e6066d669cbe8ac055150075fe13d0cf42e", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 0, "deletions": 216, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=c1bf2a39b394782f6f1ff14cdf35fd806ec303dd", "patch": "@@ -134,61 +134,6 @@ make_pass_tree_loop_init (gcc::context *ctxt)\n   return new pass_tree_loop_init (ctxt);\n }\n \n-/* Predictive commoning.  */\n-\n-static unsigned\n-run_tree_predictive_commoning (void)\n-{\n-  if (!current_loops)\n-    return 0;\n-\n-  return tree_predictive_commoning ();\n-}\n-\n-static bool\n-gate_tree_predictive_commoning (void)\n-{\n-  return flag_predictive_commoning != 0;\n-}\n-\n-namespace {\n-\n-const pass_data pass_data_predcom =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"pcom\", /* name */\n-  OPTGROUP_LOOP, /* optinfo_flags */\n-  true, /* has_gate */\n-  true, /* has_execute */\n-  TV_PREDCOM, /* tv_id */\n-  PROP_cfg, /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  TODO_update_ssa_only_virtuals, /* todo_flags_finish */\n-};\n-\n-class pass_predcom : public gimple_opt_pass\n-{\n-public:\n-  pass_predcom (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_predcom, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  bool gate () { return gate_tree_predictive_commoning (); }\n-  unsigned int execute () { return run_tree_predictive_commoning (); }\n-\n-}; // class pass_predcom\n-\n-} // anon namespace\n-\n-gimple_opt_pass *\n-make_pass_predcom (gcc::context *ctxt)\n-{\n-  return new pass_predcom (ctxt);\n-}\n-\n /* Loop autovectorization.  */\n \n static unsigned int\n@@ -244,110 +189,6 @@ make_pass_vectorize (gcc::context *ctxt)\n   return new pass_vectorize (ctxt);\n }\n \n-/* GRAPHITE optimizations.  */\n-\n-static unsigned int\n-graphite_transforms (void)\n-{\n-  if (!current_loops)\n-    return 0;\n-\n-  graphite_transform_loops ();\n-\n-  return 0;\n-}\n-\n-static bool\n-gate_graphite_transforms (void)\n-{\n-  /* Enable -fgraphite pass if any one of the graphite optimization flags\n-     is turned on.  */\n-  if (flag_loop_block\n-      || flag_loop_interchange\n-      || flag_loop_strip_mine\n-      || flag_graphite_identity\n-      || flag_loop_parallelize_all\n-      || flag_loop_optimize_isl)\n-    flag_graphite = 1;\n-\n-  return flag_graphite != 0;\n-}\n-\n-namespace {\n-\n-const pass_data pass_data_graphite =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"graphite0\", /* name */\n-  OPTGROUP_LOOP, /* optinfo_flags */\n-  true, /* has_gate */\n-  false, /* has_execute */\n-  TV_GRAPHITE, /* tv_id */\n-  ( PROP_cfg | PROP_ssa ), /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  0, /* todo_flags_finish */\n-};\n-\n-class pass_graphite : public gimple_opt_pass\n-{\n-public:\n-  pass_graphite (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_graphite, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  bool gate () { return gate_graphite_transforms (); }\n-\n-}; // class pass_graphite\n-\n-} // anon namespace\n-\n-gimple_opt_pass *\n-make_pass_graphite (gcc::context *ctxt)\n-{\n-  return new pass_graphite (ctxt);\n-}\n-\n-namespace {\n-\n-const pass_data pass_data_graphite_transforms =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"graphite\", /* name */\n-  OPTGROUP_LOOP, /* optinfo_flags */\n-  true, /* has_gate */\n-  true, /* has_execute */\n-  TV_GRAPHITE_TRANSFORMS, /* tv_id */\n-  ( PROP_cfg | PROP_ssa ), /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  0, /* todo_flags_finish */\n-};\n-\n-class pass_graphite_transforms : public gimple_opt_pass\n-{\n-public:\n-  pass_graphite_transforms (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_graphite_transforms, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  bool gate () { return gate_graphite_transforms (); }\n-  unsigned int execute () { return graphite_transforms (); }\n-\n-}; // class pass_graphite_transforms\n-\n-} // anon namespace\n-\n-gimple_opt_pass *\n-make_pass_graphite_transforms (gcc::context *ctxt)\n-{\n-  return new pass_graphite_transforms (ctxt);\n-}\n-\n /* Check the correctness of the data dependence analyzers.  */\n \n static unsigned int\n@@ -501,63 +342,6 @@ make_pass_record_bounds (gcc::context *ctxt)\n   return new pass_record_bounds (ctxt);\n }\n \n-/* Parallelization.  */\n-\n-static bool\n-gate_tree_parallelize_loops (void)\n-{\n-  return flag_tree_parallelize_loops > 1;\n-}\n-\n-static unsigned\n-tree_parallelize_loops (void)\n-{\n-  if (number_of_loops (cfun) <= 1)\n-    return 0;\n-\n-  if (parallelize_loops ())\n-    return TODO_cleanup_cfg | TODO_rebuild_alias;\n-  return 0;\n-}\n-\n-namespace {\n-\n-const pass_data pass_data_parallelize_loops =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"parloops\", /* name */\n-  OPTGROUP_LOOP, /* optinfo_flags */\n-  true, /* has_gate */\n-  true, /* has_execute */\n-  TV_TREE_PARALLELIZE_LOOPS, /* tv_id */\n-  ( PROP_cfg | PROP_ssa ), /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  TODO_verify_flow, /* todo_flags_finish */\n-};\n-\n-class pass_parallelize_loops : public gimple_opt_pass\n-{\n-public:\n-  pass_parallelize_loops (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_parallelize_loops, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  bool gate () { return gate_tree_parallelize_loops (); }\n-  unsigned int execute () { return tree_parallelize_loops (); }\n-\n-}; // class pass_parallelize_loops\n-\n-} // anon namespace\n-\n-gimple_opt_pass *\n-make_pass_parallelize_loops (gcc::context *ctxt)\n-{\n-  return new pass_parallelize_loops (ctxt);\n-}\n-\n /* Induction variable optimizations.  */\n \n static unsigned int"}, {"sha": "5cdae0e6847d8f61ef777e71b8a072bf3b2ababb", "filename": "gcc/tree-ssa-threadedge.h", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Ftree-ssa-threadedge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Ftree-ssa-threadedge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.h?ref=c1bf2a39b394782f6f1ff14cdf35fd806ec303dd", "patch": "@@ -0,0 +1,36 @@\n+/* Header file for SSA jump threading.\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_TREE_SSA_THREADEDGE_H\n+#define GCC_TREE_SSA_THREADEDGE_H\n+\n+extern vec<tree> ssa_name_values;\n+#define SSA_NAME_VALUE(x) \\\n+    (SSA_NAME_VERSION (x) < ssa_name_values.length () \\\n+     ? ssa_name_values[SSA_NAME_VERSION (x)] \\\n+     : NULL_TREE)\n+extern void set_ssa_name_value (tree, tree);\n+extern void threadedge_initialize_values (void);\n+extern void threadedge_finalize_values (void);\n+extern bool potentially_threadable_block (basic_block);\n+extern void propagate_threaded_block_debug_into (basic_block, basic_block);\n+extern void thread_across_edge (gimple, edge, bool,\n+\t\t\t\tvec<tree> *, tree (*) (gimple, gimple));\n+\n+#endif /* GCC_TREE_SSA_THREADEDGE_H */"}, {"sha": "7371ceb26789dbc64c7fd031469e96bf6b4033e4", "filename": "gcc/tree-ssa.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Ftree-ssa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Ftree-ssa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.h?ref=c1bf2a39b394782f6f1ff14cdf35fd806ec303dd", "patch": "@@ -28,6 +28,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssanames.h\"\n #include \"tree-ssa-dom.h\"\n #include \"tree-flow.h\"\n+#include \"tree-ssa-threadedge.h\"\n+#include \"tree-ssa-address.h\"\n \n /* Mapping for redirected edges.  */\n struct _edge_var_map {"}, {"sha": "8b7b345150993da5d79ed125883af7ea732f16dc", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=c1bf2a39b394782f6f1ff14cdf35fd806ec303dd", "patch": "@@ -899,6 +899,7 @@ extern LOC vect_location;\n    in tree-vect-loop-manip.c.  */\n extern void slpeel_make_loop_iterate_ntimes (struct loop *, tree);\n extern bool slpeel_can_duplicate_loop_p (const struct loop *, const_edge);\n+struct loop *slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *, edge);\n extern void vect_loop_versioning (loop_vec_info, unsigned int, bool);\n extern void vect_do_peeling_for_loop_bound (loop_vec_info, tree *,\n \t\t\t\t\t    unsigned int, bool);"}, {"sha": "0fdebfbf0098a5903825fe97fac8d72ec70bad5d", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bf2a39b394782f6f1ff14cdf35fd806ec303dd/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=c1bf2a39b394782f6f1ff14cdf35fd806ec303dd", "patch": "@@ -4737,10 +4737,6 @@ extern unsigned int tree_decl_map_hash (const void *);\n #define tree_vec_map_hash tree_decl_map_hash\n #define tree_vec_map_marked_p tree_map_base_marked_p\n \n-/* In tree-ssa-address.c.  */\n-extern tree tree_mem_ref_addr (tree, tree);\n-extern void copy_ref_info (tree, tree);\n-\n /* In tree-vrp.c */\n extern bool ssa_name_nonnegative_p (const_tree);\n "}]}