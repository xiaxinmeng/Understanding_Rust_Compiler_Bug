{"sha": "ebde8a27549bdf9cba2b29f8549c65c3b14d3980", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWJkZThhMjc1NDliZGY5Y2JhMmIyOWY4NTQ5YzY1YzNiMTRkMzk4MA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-10-09T09:48:36Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-10-09T09:48:36Z"}, "message": "(range_test): Function deleted.\n\n(range_binop, make_range, build_range_check): New functions.\n(merge_ranges, fold_range_test): Likewise.\n(fold_truthop): No longer call range_test.\n(fold, case TRUTH_{AND,OR}{,IF}_EXPR): Call fold_range_test.\n\nFrom-SVN: r12921", "tree": {"sha": "8eea54d0ae8c27ff52587ee36f2f82c4fbe67fe6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8eea54d0ae8c27ff52587ee36f2f82c4fbe67fe6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ebde8a27549bdf9cba2b29f8549c65c3b14d3980", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebde8a27549bdf9cba2b29f8549c65c3b14d3980", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebde8a27549bdf9cba2b29f8549c65c3b14d3980", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebde8a27549bdf9cba2b29f8549c65c3b14d3980/comments", "author": null, "committer": null, "parents": [{"sha": "d291dd49eebd5d36a0f52e37de12e24ea6c0f093", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d291dd49eebd5d36a0f52e37de12e24ea6c0f093", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d291dd49eebd5d36a0f52e37de12e24ea6c0f093"}], "stats": {"total": 617, "additions": 461, "deletions": 156}, "files": [{"sha": "28f645673f052e7504ec9d55f1ff82e85c378166", "filename": "gcc/fold-const.c", "status": "modified", "additions": 461, "deletions": 156, "changes": 617, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebde8a27549bdf9cba2b29f8549c65c3b14d3980/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebde8a27549bdf9cba2b29f8549c65c3b14d3980/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=ebde8a27549bdf9cba2b29f8549c65c3b14d3980", "patch": "@@ -47,37 +47,45 @@ Boston, MA 02111-1307, USA.  */\n /* Handle floating overflow for `const_binop'.  */\n static jmp_buf float_error;\n \n-static void encode\tPROTO((HOST_WIDE_INT *, HOST_WIDE_INT, HOST_WIDE_INT));\n-static void decode\tPROTO((HOST_WIDE_INT *, HOST_WIDE_INT *, HOST_WIDE_INT *));\n-int div_and_round_double PROTO((enum tree_code, int, HOST_WIDE_INT,\n+static void encode\t\tPROTO((HOST_WIDE_INT *,\n+\t\t\t\t       HOST_WIDE_INT, HOST_WIDE_INT));\n+static void decode\t\tPROTO((HOST_WIDE_INT *,\n+\t\t\t\t       HOST_WIDE_INT *, HOST_WIDE_INT *));\n+int div_and_round_double\tPROTO((enum tree_code, int, HOST_WIDE_INT,\n \t\t\t\t       HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t       HOST_WIDE_INT, HOST_WIDE_INT *,\n \t\t\t\t       HOST_WIDE_INT *, HOST_WIDE_INT *,\n \t\t\t\t       HOST_WIDE_INT *));\n-static int split_tree\tPROTO((tree, enum tree_code, tree *, tree *, int *));\n-static tree const_binop PROTO((enum tree_code, tree, tree, int));\n-static tree fold_convert PROTO((tree, tree));\n+static int split_tree\t\tPROTO((tree, enum tree_code, tree *,\n+\t\t\t\t       tree *, int *));\n+static tree const_binop\t\tPROTO((enum tree_code, tree, tree, int));\n+static tree fold_convert\tPROTO((tree, tree));\n static enum tree_code invert_tree_comparison PROTO((enum tree_code));\n static enum tree_code swap_tree_comparison PROTO((enum tree_code));\n-static int truth_value_p PROTO((enum tree_code));\n+static int truth_value_p\tPROTO((enum tree_code));\n static int operand_equal_for_comparison_p PROTO((tree, tree, tree));\n-static int twoval_comparison_p PROTO((tree, tree *, tree *, int *));\n-static tree eval_subst\tPROTO((tree, tree, tree, tree, tree));\n-static tree omit_one_operand PROTO((tree, tree, tree));\n+static int twoval_comparison_p\tPROTO((tree, tree *, tree *, int *));\n+static tree eval_subst\t\tPROTO((tree, tree, tree, tree, tree));\n+static tree omit_one_operand\tPROTO((tree, tree, tree));\n static tree pedantic_omit_one_operand PROTO((tree, tree, tree));\n static tree distribute_bit_expr PROTO((enum tree_code, tree, tree, tree));\n-static tree make_bit_field_ref PROTO((tree, tree, int, int, int));\n+static tree make_bit_field_ref\tPROTO((tree, tree, int, int, int));\n static tree optimize_bit_field_compare PROTO((enum tree_code, tree,\n \t\t\t\t\t      tree, tree));\n static tree decode_field_reference PROTO((tree, int *, int *,\n \t\t\t\t\t  enum machine_mode *, int *,\n \t\t\t\t\t  int *, tree *, tree *));\n-static int all_ones_mask_p PROTO((tree, int));\n-static int simple_operand_p PROTO((tree));\n-static tree range_test\tPROTO((enum tree_code, tree, enum tree_code,\n-\t\t\t       enum tree_code, tree, tree, tree));\n-static tree unextend\tPROTO((tree, int, int, tree));\n-static tree fold_truthop PROTO((enum tree_code, tree, tree, tree));\n+static int all_ones_mask_p\tPROTO((tree, int));\n+static int simple_operand_p\tPROTO((tree));\n+static tree range_binop\t\tPROTO((enum tree_code, tree, tree, int,\n+\t\t\t\t       tree, int));\n+static tree make_range\t\tPROTO((tree, int *, tree *, tree *));\n+static tree build_range_check\tPROTO((tree, tree, int, tree, tree));\n+static int merge_ranges\t\tPROTO((int *, tree *, tree *, int, tree, tree,\n+\t\t\t\t       int, tree, tree));\n+static tree fold_range_test\tPROTO((tree));\n+static tree unextend\t\tPROTO((tree, int, int, tree));\n+static tree fold_truthop\tPROTO((enum tree_code, tree, tree, tree));\n static tree strip_compound_expr PROTO((tree, tree));\n \n #ifndef BRANCH_COST\n@@ -2509,134 +2517,460 @@ simple_operand_p (exp)\n \t      && (! TREE_STATIC (exp) || DECL_REGISTER (exp))));\n }\n \f\n-/* Subroutine for fold_truthop: try to optimize a range test.\n+/* The following functions are subroutines to fold_range_test and allow it to\n+   try to change a logical combination of comparisons into a range test.\n+\n+   For example, both\n+   \tX == 2 && X == 3 && X == 4 && X == 5\n+   and\n+   \tX >= 2 && X <= 5\n+   are converted to\n+\t(unsigned) (X - 2) <= 3\n+\n+   We decribe each set of comparisons as being either inside or outside\n+   a range, using a variable named like IN_P, and then describe the\n+   range with a lower and upper bound.  If one of the bounds is omitted,\n+   it represents either the highest or lowest value of the type.\n+\n+   In the comments below, we represent a range by two numbers in brackets\n+   preceeded by a \"+\" to designate being inside that range, or a \"-\" to\n+   designate being outside that range, so the condition can be inverted by\n+   flipping the prefix.  An omitted bound is represented by a \"-\".  For\n+   example, \"- [-, 10]\" means being outside the range starting at the lowest\n+   possible value and ending at 10, in other words, being greater than 10.\n+   The range \"+ [-, -]\" is always true and hence the range \"- [-, -]\" is\n+   always false.\n+\n+   We set up things so that the missing bounds are handled in a consistent\n+   manner so neither a missing bound nor \"true\" and \"false\" need to be\n+   handled using a special case.  */\n+\n+/* Return the result of applying CODE to ARG0 and ARG1, but handle the case\n+   of ARG0 and/or ARG1 being omitted, meaning an unlimited range. UPPER0_P\n+   and UPPER1_P are nonzero if the respective argument is an upper bound\n+   and zero for a lower.  TYPE, if nonzero, is the type of the result; it\n+   must be specified for a comparison.  ARG1 will be converted to ARG0's\n+   type if both are specified.  */\n \n-   For example, \"i >= 2 && i =< 9\" can be done as \"(unsigned) (i - 2) <= 7\".\n+static tree\n+range_binop (code, type, arg0, upper0_p, arg1, upper1_p)\n+     enum tree_code code;\n+     tree type;\n+     tree arg0, arg1;\n+     int upper0_p, upper1_p;\n+{\n+  int result;\n+  int sgn0, sgn1;\n \n-   JCODE is the logical combination of the two terms.  It is TRUTH_AND_EXPR\n-   (representing TRUTH_ANDIF_EXPR and TRUTH_AND_EXPR) or TRUTH_OR_EXPR\n-   (representing TRUTH_ORIF_EXPR and TRUTH_OR_EXPR).  TYPE is the type of\n-   the result.\n+  /* If neither arg represents infinity, do the normal operation.\n+     Else, if not a comparison, return infinity.  Else handle the special\n+     comparison rules. Note that most of the cases below won't occur, but\n+     are handled for consistency.  */\n \n-   VAR is the value being tested.  LO_CODE and HI_CODE are the comparison\n-   operators comparing VAR to LO_CST and HI_CST.  LO_CST is known to be no\n-   larger than HI_CST (they may be equal).\n+  if (arg0 != 0 && arg1 != 0)\n+    return fold (build (code, type != 0 ? type : TREE_TYPE (arg0),\n+\t\t\targ0, convert (TREE_TYPE (arg0), arg1)));\n \n-   We return the simplified tree or 0 if no optimization is possible.  */\n+  if (TREE_CODE_CLASS (code) != '<')\n+    return 0;\n+\n+  /* Set SGN[01] to -1 if ARG[01] is a lower bound, 1 for upper, and 0\n+     for neither.  Then compute our result treating them as never equal\n+     and comparing bounds to non-bounds as above.  */\n+  sgn0 = arg0 != 0 ? 0 : (upper0_p ? 1 : -1);\n+  sgn1 = arg1 != 0 ? 1 : (upper1_p ? 1 : -1);\n+  switch (code)\n+    {\n+    case EQ_EXPR:  case NE_EXPR:\n+      result = (code == NE_EXPR);\n+      break;\n+    case LT_EXPR:  case LE_EXPR:\n+      result = sgn0 < sgn1;\n+      break;\n+    case GT_EXPR:  case GE_EXPR:\n+      result = sgn0 > sgn1;\n+      break;\n+    }\n+\n+  return convert (type, result ? integer_one_node : integer_zero_node);\n+}\n+\f      \n+/* Given EXP, a logical expression, set the range it is testing into\n+   variables denoted by PIN_P, PLOW, and PHIGH.  Return the expression\n+   actually being tested.  *PLOW and *PHIGH will have be made the same type\n+   as the returned expression.  If EXP is not a comparison, we will most\n+   likely not be returning a useful value and range.  */\n \n static tree\n-range_test (jcode, type, lo_code, hi_code, var, lo_cst, hi_cst)\n-     enum tree_code jcode, lo_code, hi_code;\n-     tree type, var, lo_cst, hi_cst;\n+make_range (exp, pin_p, plow, phigh)\n+     tree exp;\n+     int *pin_p;\n+     tree *plow, *phigh;\n {\n-  tree utype;\n-  enum tree_code rcode;\n+  enum tree_code code;\n+  tree arg0, arg1, type;\n+  int in_p, n_in_p;\n+  tree low, high, n_low, n_high;\n \n-  /* See if this is a range test and normalize the constant terms.  */\n+  /* Start with simply saying \"EXP != 0\" and then look at the code of EXP\n+     and see if we can refine the range.  Some of the cases below may not\n+     happen, but it doesn't seem worth worrying about this.  We \"continue\"\n+     the outer loop when we've changed something; otherwise we \"break\"\n+     the switch, which will \"break\" the while.  */\n \n-  if (jcode == TRUTH_AND_EXPR)\n+  in_p = 0, low = high = convert (TREE_TYPE (exp), integer_zero_node);\n+\n+  while (1)\n     {\n-      switch (lo_code)\n-\t{\n-\tcase NE_EXPR:\n-\t  /* See if we have VAR != CST && VAR != CST+1.  */\n-\t  if (! (hi_code == NE_EXPR\n-\t\t && TREE_INT_CST_LOW (hi_cst) - TREE_INT_CST_LOW (lo_cst) == 1\n-\t\t && tree_int_cst_equal (integer_one_node,\n-\t\t\t\t\tconst_binop (MINUS_EXPR,\n-\t\t\t\t\t\t     hi_cst, lo_cst, 0))))\n-\t    return 0;\n+      code = TREE_CODE (exp);\n+      arg0 = TREE_OPERAND (exp, 0), arg1 = TREE_OPERAND (exp, 1);\n+      if (tree_code_length[(int) code] > 0)\n+\ttype = TREE_TYPE (arg0);\n \n-\t  rcode = GT_EXPR;\n-\t  break;\n+      switch (code)\n+\t{\n+\tcase TRUTH_NOT_EXPR:\n+\t  in_p = ! in_p, exp = arg0;\n+\t  continue;\n+\n+\tcase EQ_EXPR: case NE_EXPR:\n+\tcase LT_EXPR: case LE_EXPR: case GE_EXPR: case GT_EXPR:\n+\t  /* We can only do something if the range is testing for zero\n+\t     and if the second operand is an integer constant.  Note that\n+\t     saying something is \"in\" the range we make is done by\n+\t     complementing IN_P since it will set in the initial case of\n+\t     being not equal to zero; \"out\" is leaving it alone.  */\n+\t  if (low == 0 || high == 0\n+\t      || ! integer_zerop (low) || ! integer_zerop (high)\n+\t      || TREE_CODE (arg1) != INTEGER_CST)\n+\t    break;\n \n-\tcase GT_EXPR:\n-\tcase GE_EXPR:\n-\t  if (hi_code == LT_EXPR)\n-\t    hi_cst = const_binop (MINUS_EXPR, hi_cst, integer_one_node, 0);\n-\t  else if (hi_code != LE_EXPR)\n-\t    return 0;\n+\t  switch (code)\n+\t    {\n+\t    case NE_EXPR:  /* - [c, c]  */\n+\t      low = high = arg1;\n+\t      break;\n+\t    case EQ_EXPR:  /* + [c, c]  */\n+\t      in_p = ! in_p, low = high = arg1;\n+\t      break;\n+\t    case GT_EXPR:  /* - [-, c] */\n+\t      low = 0, high = arg1;\n+\t      break;\n+\t    case GE_EXPR:  /* + [c, -] */\n+\t      in_p = ! in_p, low = arg1, high = 0;\n+\t      break;\n+\t    case LT_EXPR:  /* - [c, -] */\n+\t      low = arg1, high = 0;\n+\t      break;\n+\t    case LE_EXPR:  /* + [-, c] */\n+\t      in_p = ! in_p, low = 0, high = arg1;\n+\t      break;\n+\t    }\n \n-\t  if (lo_code == GT_EXPR)\n-\t    lo_cst = const_binop (PLUS_EXPR, lo_cst, integer_one_node, 0);\n+\t  exp = arg0;\n \n-\t  /* We now have VAR >= LO_CST && VAR <= HI_CST.  */\n-\t  rcode = LE_EXPR;\n-\t  break;\n+\t  /* If this is an unsigned comparison, we also know that EXP\n+\t     is greater than or equal to zero.  We base the range tests\n+\t     we make on that fact, so we record it here so we can parse\n+\t     existing range tests.  */\n+\t  if (TREE_UNSIGNED (type))\n+\t    {\n+\t      if (! merge_ranges (&n_in_p, &n_low, &n_high, in_p, low, high,\n+\t\t\t\t  1, convert (type, integer_zero_node),\n+\t\t\t\t  NULL_TREE))\n+\t\tbreak;\n \n-\tdefault:\n-\t  return 0;\n+\t      in_p = n_in_p, low = n_low, high = n_high;\n+\t    }\n+\t  continue;\n+\n+\tcase NEGATE_EXPR:\n+\t  /* (-x) IN [a,b] -> x in [-b, -a]  */\n+\t  n_low = range_binop (MINUS_EXPR, type,\n+\t\t\t       convert (type, integer_zero_node), 0, high, 1);\n+\t  n_high = range_binop (MINUS_EXPR, type,\n+\t\t\t\tconvert (type, integer_zero_node), 0, low, 0);\n+\t  low = n_low, high = n_high;\n+\t  exp = arg0;\n+\t  continue;\n+\n+\tcase BIT_NOT_EXPR:\n+\t  /* ~ X -> -X - 1  */\n+\t  exp = build (MINUS_EXPR, type, build1 (NEGATE_EXPR, type, arg0),\n+\t\t       convert (type, integer_zero_node));\n+\t  continue;\n+\n+\tcase PLUS_EXPR:  case MINUS_EXPR:\n+\t  if (TREE_CODE (arg1) != INTEGER_CST)\n+\t    break;\n+\n+\t  /* If EXP is signed, any overflow in the computation is undefined,\n+\t     so we don't worry about it so long as our computations on\n+\t     the bounds don't overflow.  For unsigned, overflow is defined\n+\t     and this is exactly the right thing.  */\n+\t  n_low = range_binop (code == MINUS_EXPR ? PLUS_EXPR : MINUS_EXPR,\n+\t\t\t       type, low, 0, arg1, 0);\n+\t  n_high = range_binop (code == MINUS_EXPR ? PLUS_EXPR : MINUS_EXPR,\n+\t\t\t\ttype, high, 1, arg1, 0);\n+\t  if ((n_low != 0 && TREE_OVERFLOW (n_low))\n+\t      || (n_high != 0 && TREE_OVERFLOW (n_high)))\n+\t    break;\n+\n+\t  low = n_low, high = n_high;\n+\t  exp = arg0;\n+\t  continue;\n+\n+\tcase NOP_EXPR:  case NON_LVALUE_EXPR:  case CONVERT_EXPR:\n+\t  if (! INTEGRAL_TYPE_P (type)\n+\t      || (low != 0 && ! int_fits_type_p (low, type))\n+\t      || (high != 0 && ! int_fits_type_p (high, type)))\n+\t    break;\n+\n+\t  if (low != 0)\n+\t    low = convert (type, low);\n+\n+\t  if (high != 0)\n+\t    high = convert (type, high);\n+\n+\t  exp = arg0;\n+\t  continue;\n \t}\n+\n+      break;\n     }\n-  else\n+\n+  *pin_p = in_p, *plow = low, *phigh = high;\n+  return exp;\n+}\n+\f\n+/* Given a range, LOW, HIGH, and IN_P, an expression, EXP, and a result\n+   type, TYPE, return an expression to test if EXP is in (or out of, depending\n+   on IN_P) the range.  */\n+\n+static tree\n+build_range_check (type, exp, in_p, low, high)\n+     tree type;\n+     tree exp;\n+     int in_p;\n+     tree low, high;\n+{\n+  tree etype = TREE_TYPE (exp);\n+  tree utype, value;\n+\n+  if (! in_p\n+      && (0 != (value = build_range_check (type, exp, 1, low, high))))\n+    return invert_truthvalue (value);\n+\n+  else if (low == 0 && high == 0)\n+    return convert (type, integer_one_node);\n+\n+  else if (low == 0)\n+    return fold (build (LE_EXPR, type, exp, high));\n+\n+  else if (high == 0)\n+    return fold (build (GE_EXPR, type, exp, low));\n+\n+  else if (operand_equal_p (low, high, 0))\n+    return fold (build (EQ_EXPR, type, exp, low));\n+\n+  else if (TREE_UNSIGNED (etype) && integer_zerop (low))\n+    return build_range_check (type, exp, 1, 0, high);\n+\n+  else if (integer_zerop (low))\n     {\n-      switch (lo_code)\n-\t{\n-\tcase EQ_EXPR:\n-\t  /* See if we have VAR == CST || VAR == CST+1.  */\n-\t  if (! (hi_code == EQ_EXPR\n-\t\t && TREE_INT_CST_LOW (hi_cst) - TREE_INT_CST_LOW (lo_cst) == 1\n-\t\t && tree_int_cst_equal (integer_one_node,\n-\t\t\t\t\tconst_binop (MINUS_EXPR,\n-\t\t\t\t\t\t     hi_cst, lo_cst, 0))))\n-\t    return 0;\n+      utype = unsigned_type (etype);\n+      return build_range_check (type, convert (utype, exp), 1, 0,\n+\t\t\t\tconvert (utype, high));\n+    }\n \n-\t  rcode = LE_EXPR;\n-\t  break;\n+  else if (0 != (value = const_binop (MINUS_EXPR, high, low, 0))\n+\t   && ! TREE_OVERFLOW (value))\n+    return build_range_check (type,\n+\t\t\t      fold (build (MINUS_EXPR, etype, exp, low)),\n+\t\t\t      1, convert (etype, integer_zero_node), value);\n+  else\n+    return 0;\n+}\n+\f\n+/* Given two ranges, see if we can merge them into one.  Return 1 if we \n+   can, 0 if we can't.  Set the output range into the specified parameters.  */\n \n-\tcase LE_EXPR:\n-\tcase LT_EXPR:\n-\t  if (hi_code == GE_EXPR)\n-\t    hi_cst = const_binop (MINUS_EXPR, hi_cst, integer_one_node, 0);\n-\t  else if (hi_code != GT_EXPR)\n-\t    return 0;\n+static int\n+merge_ranges (pin_p, plow, phigh, in0_p, low0, high0, in1_p, low1, high1)\n+     int *pin_p;\n+     tree *plow, *phigh;\n+     int in0_p, in1_p;\n+     tree low0, high0, low1, high1;\n+{\n+  int no_overlap;\n+  int subset;\n+  int temp;\n+  tree tem;\n+  int in_p;\n+  tree low, high;\n+\n+  /* Make range 0 be the range that starts first.  Swap them if it isn't.  */\n+  if (integer_onep (range_binop (GT_EXPR, integer_type_node, \n+\t\t\t\t low0, 0, low1, 0))\n+      || (((low0 == 0 && low1 == 0)\n+\t   || integer_onep (range_binop (EQ_EXPR, integer_type_node,\n+\t\t\t\t\t low0, 0, low1, 0)))\n+\t  && integer_onep (range_binop (GT_EXPR, integer_type_node,\n+\t\t\t\t\thigh0, 1, high1, 1))))\n+    {\n+      temp = in0_p, in0_p = in1_p, in1_p = temp;\n+      tem = low0, low0 = low1, low1 = tem;\n+      tem = high0, high0 = high1, high1 = tem;\n+    }\n \n-\t  if (lo_code == LE_EXPR)\n-\t    lo_cst = const_binop (PLUS_EXPR, lo_cst, integer_one_node, 0);\n+  /* Now flag two cases, whether the ranges are disjoint or whether the\n+     second range is totally subsumed in the first.  Note that the tests\n+     below are simplified by the ones above.  */\n+  no_overlap = integer_onep (range_binop (LT_EXPR, integer_type_node,\n+\t\t\t\t\t  high0, 1, low1, 0));\n+  subset = integer_onep (range_binop (LT_EXPR, integer_type_node,\n+\t\t\t\t      high1, 1, high0, 1));\n+\n+  /* We now have four cases, depending on whether we are including or\n+     excluding the two ranges.  */\n+  if (in0_p && in1_p)\n+    {\n+      /* If they don't overlap, the result is false.  If the second range\n+\t is a subset it is the result.  Otherwise, the range is from the start\n+\t of the second to the end of the first.  */\n+      if (no_overlap)\n+\tin_p = 0, low = high = 0;\n+      else if (subset)\n+\tin_p = 1, low = low1, high = high1;\n+      else\n+\tin_p = 1, low = low1, high = high0;\n+    }\n \n-\t  /* We now have VAR < LO_CST || VAR > HI_CST.  */\n-\t  rcode = GT_EXPR;\n-\t  break;\n+  else if (in0_p && ! in1_p)\n+    {\n+      /* If they don't overlap, the result is the first range.  If the\n+\t second range is a subset of the first, we can't describe this as\n+\t a single range.  Otherwise, we go from the start of the first\n+\t range to just before the start of the second.  */\n+      if (no_overlap)\n+\tin_p = 1, low = low0, high = high0;\n+      else if (subset)\n+\treturn 0;\n+      else\n+\t{\n+\t  in_p = 1, low = low0;\n+\t  high = range_binop (MINUS_EXPR, NULL_TREE, low1, 0,\n+\t\t\t      integer_zero_node, 0);\n+\t}\n+    }\n \n-\tdefault:\n-\t  return 0;\n+  else if (! in0_p && in1_p)\n+    {\n+      /* If they don't overlap, the result is the second range.  If the second\n+\t is a subset of the first, the result is false.  Otherwise,\n+\t the range starts just after the first range and ends at the\n+\t end of the second.  */\n+      if (no_overlap)\n+\tin_p = 1, low = low1, high = high1;\n+      else if (subset)\n+\tin_p = 0, low = high = 0;\n+      else\n+\t{\n+\t  in_p = 1, high = high1;\n+\t  low = range_binop (PLUS_EXPR, NULL_TREE, high0, 1,\n+\t\t\t     integer_one_node, 0);\n \t}\n     }\n \n-  /* When normalizing, it is possible to both increment the smaller constant\n-     and decrement the larger constant.  See if they are still ordered.  */\n-  if (tree_int_cst_lt (hi_cst, lo_cst))\n-    return 0;\n+  else\n+    {\n+      /* The case where we are excluding both ranges.  Here the complex case\n+\t is if they don't overlap.  In that case, the only time we have a\n+\t range is if they are adjacent.  If the second is a subset of the\n+\t first, the result is the first.  Otherwise, the range to exclude\n+\t starts at the beginning of the first range and ends at the end of the\n+\t second.  */\n+      if (no_overlap)\n+\t{\n+\t  if (integer_onep (range_binop (EQ_EXPR, integer_type_node,\n+\t\t\t\t\t range_binop (PLUS_EXPR, NULL_TREE,\n+\t\t\t\t\t\t      high0, 1,\n+\t\t\t\t\t\t      integer_one_node, 1),\n+\t\t\t\t\t 1, low1, 0)))\n+\t    in_p = 0, low = low0, high = high1;\n+\t  else\n+\t    return 0;\n+\t}\n+      else if (subset)\n+\tin_p = 0, low = low0, high = high0;\n+      else\n+\tin_p = 0, low = low0, high = high1;\n+    }\n \n-  /* Fail if VAR isn't an integer.  */\n-  utype = TREE_TYPE (var);\n-  if (! INTEGRAL_TYPE_P (utype))\n-    return 0;\n+  *pin_p = in_p, *plow = low, *phigh = high;\n+  return 1;\n+}\n+\f\n+/* EXP is some logical combination of boolean tests.  See if we can\n+   merge it into some range test.  Return the new tree if so.  */\n \n-  /* The range test is invalid if subtracting the two constants results\n-     in overflow.  This can happen in traditional mode.  */\n-  if (! int_fits_type_p (hi_cst, TREE_TYPE (var))\n-      || ! int_fits_type_p (lo_cst, TREE_TYPE (var)))\n-    return 0;\n+static tree\n+fold_range_test (exp)\n+     tree exp;\n+{\n+  int or_op = (TREE_CODE (exp) == TRUTH_ORIF_EXPR\n+\t       || TREE_CODE (exp) == TRUTH_OR_EXPR);\n+  int in0_p, in1_p, in_p;\n+  tree low0, low1, low, high0, high1, high;\n+  tree lhs = make_range (TREE_OPERAND (exp, 0), &in0_p, &low0, &high0);\n+  tree rhs = make_range (TREE_OPERAND (exp, 1), &in1_p, &low1, &high1);\n+  tree tem;\n \n-  if (! TREE_UNSIGNED (utype))\n+  /* If this is an OR operation, invert both sides; we will invert\n+     again at the end.  */\n+  if (or_op)\n+    in0_p = ! in0_p, in1_p = ! in1_p;\n+\n+  /* If both expressions are the same, if we can merge the ranges, and we\n+     can build the range test, return it or it inverted.  */\n+  if (operand_equal_p (lhs, rhs, 0)\n+      && merge_ranges (&in_p, &low, &high, in0_p, low0, high0,\n+\t\t       in1_p, low1, high1)\n+      && 0 != (tem = (build_range_check (TREE_TYPE (exp), lhs,\n+\t\t\t\t\t in_p, low, high))))\n+    return or_op ? invert_truthvalue (tem) : tem;\n+\n+  /* On machines where the branch cost is expensive, if this is a\n+     short-circuited branch and the underlying object on both sides\n+     is the same, make a non-short-circuit operation.  */\n+  else if (BRANCH_COST >= 2\n+\t   && (TREE_CODE (exp) == TRUTH_ANDIF_EXPR\n+\t       || TREE_CODE (exp) == TRUTH_ORIF_EXPR)\n+\t   && operand_equal_p (lhs, rhs, 0))\n     {\n-      utype = unsigned_type (utype);\n-      return fold (convert (type,\n-\t\t\t    build (rcode, utype,\n-\t\t\t\t   convert (utype,\n-\t\t\t\t\t    build (MINUS_EXPR, TREE_TYPE (var),\n-\t\t\t\t\t\t   var, lo_cst)),\n-\t\t\t\t   convert (utype,\n-\t\t\t\t\t    const_binop (MINUS_EXPR, hi_cst,\n-\t\t\t\t\t\t\t lo_cst, 0)))));\n+      /* If simple enough, just rewrite.  Otherwise, make a SAVE_EXPR.  */\n+      if (simple_operand_p (lhs))\n+\treturn build (TREE_CODE (exp) == TRUTH_ANDIF_EXPR\n+\t\t      ? TRUTH_AND_EXPR : TRUTH_OR_EXPR,\n+\t\t      TREE_TYPE (exp), TREE_OPERAND (exp, 0),\n+\t\t      TREE_OPERAND (exp, 1));\n+      else\n+\t{\n+\t  tree common = save_expr (lhs);\n+\n+\t  if (0 != (lhs = build_range_check (TREE_TYPE (exp), common,\n+\t\t\t\t\t     or_op ? ! in0_p : in0_p,\n+\t\t\t\t\t     low0, high0))\n+\t      && (0 != (rhs = build_range_check (TREE_TYPE (exp), common,\n+\t\t\t\t\t\t or_op ? ! in1_p : in1_p,\n+\t\t\t\t\t\t low1, high1))))\n+\t    return build (TREE_CODE (exp) == TRUTH_ANDIF_EXPR\n+\t\t\t  ? TRUTH_AND_EXPR : TRUTH_OR_EXPR,\n+\t\t\t  TREE_TYPE (exp), lhs, rhs);\n+\t}\n     }\n   else\n-      return fold (convert (type,\n-\t\t\t    build (rcode, utype,\n-\t\t\t\t   build (MINUS_EXPR, utype, var, lo_cst),\n-\t\t\t\t   const_binop (MINUS_EXPR, hi_cst,\n-\t\t\t\t\t\tlo_cst, 0))));\n+    return 0;\n }\n \f\n /* Subroutine for fold_truthop: C is an INTEGER_CST interpreted as a P\n@@ -2730,13 +3064,11 @@ fold_truthop (code, truth_type, lhs, rhs)\n   int first_bit, end_bit;\n   int volatilep;\n \n-  /* Start by getting the comparison codes and seeing if this looks like\n-     a range test.  Fail if anything is volatile.  If one operand is a\n-     BIT_AND_EXPR with the constant one, treat it as if it were surrounded\n-     with a NE_EXPR.  */\n+  /* Start by getting the comparison codes.  Fail if anything is volatile.\n+     If one operand is a BIT_AND_EXPR with the constant one, treat it as if\n+     it were surrounded with a NE_EXPR.  */\n \n-  if (TREE_SIDE_EFFECTS (lhs)\n-      || TREE_SIDE_EFFECTS (rhs))\n+  if (TREE_SIDE_EFFECTS (lhs) || TREE_SIDE_EFFECTS (rhs))\n     return 0;\n \n   lcode = TREE_CODE (lhs);\n@@ -2748,8 +3080,7 @@ fold_truthop (code, truth_type, lhs, rhs)\n   if (rcode == BIT_AND_EXPR && integer_onep (TREE_OPERAND (rhs, 1)))\n     rcode = NE_EXPR, rhs = build (NE_EXPR, truth_type, rhs, integer_zero_node);\n \n-  if (TREE_CODE_CLASS (lcode) != '<'\n-      || TREE_CODE_CLASS (rcode) != '<')\n+  if (TREE_CODE_CLASS (lcode) != '<' || TREE_CODE_CLASS (rcode) != '<')\n     return 0;\n \n   code = ((code == TRUTH_AND_EXPR || code == TRUTH_ANDIF_EXPR)\n@@ -2760,36 +3091,6 @@ fold_truthop (code, truth_type, lhs, rhs)\n   rl_arg = TREE_OPERAND (rhs, 0);\n   rr_arg = TREE_OPERAND (rhs, 1);\n   \n-  if (TREE_CODE (lr_arg) == INTEGER_CST\n-      && TREE_CODE (rr_arg) == INTEGER_CST\n-      && operand_equal_p (ll_arg, rl_arg, 0))\n-    {\n-      if (tree_int_cst_lt (lr_arg, rr_arg))\n-\tresult = range_test (code, truth_type, lcode, rcode,\n-\t\t\t     ll_arg, lr_arg, rr_arg);\n-      else\n-\tresult = range_test (code, truth_type, rcode, lcode,\n-\t\t\t     ll_arg, rr_arg, lr_arg);\n-\n-      /* If this isn't a range test, it also isn't a comparison that\n-\t can be merged.  However, it wins to evaluate the RHS unconditionally\n-\t on machines with expensive branches.   */\n-\n-      if (result == 0 && BRANCH_COST >= 2)\n-\t{\n-\t  if (TREE_CODE (ll_arg) != VAR_DECL\n-\t      && TREE_CODE (ll_arg) != PARM_DECL)\n-\t    {\n-\t      /* Avoid evaluating the variable part twice.  */\n-\t      ll_arg = save_expr (ll_arg);\n-\t      lhs = build (lcode, TREE_TYPE (lhs), ll_arg, lr_arg);\n-\t      rhs = build (rcode, TREE_TYPE (rhs), ll_arg, rr_arg);\n-\t    }\n-\t  return build (code, truth_type, lhs, rhs);\n-\t}\n-      return result;\n-    }\n-\n   /* If the RHS can be evaluated unconditionally and its operands are\n      simple, it wins to evaluate the RHS unconditionally on machines\n      with expensive branches.  In this case, this isn't a comparison\n@@ -4344,6 +4645,10 @@ fold (expr)\n \t\t\t\ta01));\n \t}\n \n+      /* See if we can build a range comparison.  */\n+      if (0 != (tem = fold_range_test (t)))\n+\treturn tem;\n+\n       /* Check for the possibility of merging component references.  If our\n \t lhs is another similar operation, try to merge its rhs with our\n \t rhs.  Then try to merge our lhs and rhs.  */\n@@ -4768,11 +5073,11 @@ fold (expr)\n \n       /* If this is a comparison of a field, we may be able to simplify it.  */\n       if ((TREE_CODE (arg0) == COMPONENT_REF\n-\t\t|| TREE_CODE (arg0) == BIT_FIELD_REF)\n-\t       && (code == EQ_EXPR || code == NE_EXPR)\n-\t       /* Handle the constant case even without -O\n-\t\t  to make sure the warnings are given.  */\n-\t       && (optimize || TREE_CODE (arg1) == INTEGER_CST))\n+\t   || TREE_CODE (arg0) == BIT_FIELD_REF)\n+\t  && (code == EQ_EXPR || code == NE_EXPR)\n+\t  /* Handle the constant case even without -O\n+\t     to make sure the warnings are given.  */\n+\t  && (optimize || TREE_CODE (arg1) == INTEGER_CST))\n \t{\n \t  t1 = optimize_bit_field_compare (code, type, arg0, arg1);\n \t  return t1 ? t1 : t;"}]}