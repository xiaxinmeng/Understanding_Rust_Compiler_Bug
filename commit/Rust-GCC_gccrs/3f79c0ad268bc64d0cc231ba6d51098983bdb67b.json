{"sha": "3f79c0ad268bc64d0cc231ba6d51098983bdb67b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Y3OWMwYWQyNjhiYzY0ZDBjYzIzMWJhNmQ1MTA5ODk4M2JkYjY3Yg==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2018-11-29T04:53:49Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2018-11-29T04:53:49Z"}, "message": "[RS6000] inline plt call sequences\n\nFinally, the point of the previous patches in this series, support for\ninline PLT calls, keyed off -fno-plt.  This emits code using new\nrelocations that tie all insns in the sequence together, so that the\nlinker can edit the sequence back to a direct call should the call\ntarget turn out to be local.  An example of ELFv2 code to call puts is\nas follows:\n\n     .reloc .,R_PPC64_PLTSEQ,puts\n        std 2,24(1)\n     .reloc .,R_PPC64_PLT16_HA,puts\n        addis 12,2,0\n     .reloc .,R_PPC64_PLT16_LO_DS,puts\n        ld 12,0(12)\n     .reloc .,R_PPC64_PLTSEQ,puts\n        mtctr 12\n     .reloc .,R_PPC64_PLTCALL,puts\n        bctrl\n        ld 2,24(1)\n\n\"addis 12,2,puts@plt@ha\" and \"ld 12,puts@plt@l(12)\" are also supported\nby the assembler.  gcc instead uses the explicit R_PPC64_PLT16_HA and\nR_PPC64_PLT16_LO_DS relocs because when the call is to __tls_get_addr\nan extra reloc is emitted at every place where one is shown above, to\nspecify the __tls_get_addr arg.  The linker expects the extra reloc to\ncome first.  .reloc enforces that ordering.\n\nThe patch also changes code emitted for longcalls if the assembler\nsupports the new marker relocs, so that these too can be edited.  One\nside effect of longcalls using PLT16 relocs is that they can now be\nresolved lazily by ld.so.\n\nI don't support lazy inline PLT calls for ELFv1, because ELFv1 would\nneed barriers to reliably load both the function address and toc\npointer from the PLT.  ELFv1 -fno-plt uses the longcall sequence\ninstead, which isn't edited by GNU ld.\n\n\t* config.in (HAVE_AS_PLTSEQ): Add.\n\t* config/rs6000/predicates.md (indirect_call_operand): New.\n\t* config/rs6000/rs6000-protos.h (rs6000_pltseq_template),\n\t(rs6000_sibcall_sysv): Declare.\n\t* config/rs6000/rs6000.c (init_cumulative_args): Set cookie\n\tCALL_LONG for -fno-plt.\n\t(print_operand <T, z, 0>): Handle UNSPEC_PLTSEQ.\n\t(rs6000_indirect_call_template_1): Emit .reloc directives for\n\tUNSPEC_PLTSEQ calls.\n\t(rs6000_pltseq_template): New function.\n\t(rs6000_longcall_ref): Add arg parameter.  Use PLT16 insns if\n\trelocs supported by assembler.  Move SYMBOL_REF test to callers.\n\t(rs6000_call_aix): Adjust rs6000_longcall_ref call.  Package\n\tinsns in UNSPEC_PLTSEQ, preserving original func_desc.\n\t(rs6000_call_sysv): Likewise.\n\t(rs6000_sibcall_sysv): New function.\n\t* config/rs6000/rs6000.h (HAVE_AS_PLTSEQ): Provide default.\n\t* config/rs6000/rs6000.md (UNSPEC_PLTSEQ, UNSPEC_PLT16_HA,\n\tUNSPEC_PLT16_LO): New.\n\t(pltseq_tocsave, pltseq_plt16_ha, pltseq_plt16_lo, pltseq_mtctr): New.\n\t(call_indirect_nonlocal_sysv): Don't differentiate zero from non-zero\n\tcookie in constraints.  Test explicitly for flags in length attr.\n\tHandle unspec operand 1.\n\t(call_value_indirect_nonlocal_sysv): Likewise.\n\t(call_indirect_aix, call_value_indirect_aix): Handle unspec operand 1.\n\t(call_indirect_elfv2, call_value_indirect_elfv2): Likewise.\n\t(sibcall, sibcall_value): Use rs6000_sibcall_sysv.\n\t(sibcall_indirect_nonlocal_sysv): New pattern.\n\t(sibcall_value_indirect_nonlocal_sysv): Likewise.\n\t(sibcall_nonlocal_sysv, sibcall_value_nonlocal_sysv): Remove indirect\n\tcall alternatives.\n\t* configure.ac: Check for gas plt sequence marker support.\n\t* configure: Regenerate.\n\nFrom-SVN: r266605", "tree": {"sha": "668438f0c9105e410904a6b0788446c72d448890", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/668438f0c9105e410904a6b0788446c72d448890"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f79c0ad268bc64d0cc231ba6d51098983bdb67b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f79c0ad268bc64d0cc231ba6d51098983bdb67b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f79c0ad268bc64d0cc231ba6d51098983bdb67b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f79c0ad268bc64d0cc231ba6d51098983bdb67b/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ece3bca2bd08bd02028f9ac6b0a2b6b8fa111305", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ece3bca2bd08bd02028f9ac6b0a2b6b8fa111305", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ece3bca2bd08bd02028f9ac6b0a2b6b8fa111305"}], "stats": {"total": 726, "additions": 602, "deletions": 124}, "files": [{"sha": "56dd30f9b3eb61eb658e7653e8799c4951f65977", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f79c0ad268bc64d0cc231ba6d51098983bdb67b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f79c0ad268bc64d0cc231ba6d51098983bdb67b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3f79c0ad268bc64d0cc231ba6d51098983bdb67b", "patch": "@@ -1,3 +1,39 @@\n+2018-11-29  Alan Modra  <amodra@gmail.com>\n+\n+\t* config.in (HAVE_AS_PLTSEQ): Add.\n+\t* config/rs6000/predicates.md (indirect_call_operand): New.\n+\t* config/rs6000/rs6000-protos.h (rs6000_pltseq_template),\n+\t(rs6000_sibcall_sysv): Declare.\n+\t* config/rs6000/rs6000.c (init_cumulative_args): Set cookie\n+\tCALL_LONG for -fno-plt.\n+\t(print_operand <T, z, 0>): Handle UNSPEC_PLTSEQ.\n+\t(rs6000_indirect_call_template_1): Emit .reloc directives for\n+\tUNSPEC_PLTSEQ calls.\n+\t(rs6000_pltseq_template): New function.\n+\t(rs6000_longcall_ref): Add arg parameter.  Use PLT16 insns if\n+\trelocs supported by assembler.  Move SYMBOL_REF test to callers.\n+\t(rs6000_call_aix): Adjust rs6000_longcall_ref call.  Package\n+\tinsns in UNSPEC_PLTSEQ, preserving original func_desc.\n+\t(rs6000_call_sysv): Likewise.\n+\t(rs6000_sibcall_sysv): New function.\n+\t* config/rs6000/rs6000.h (HAVE_AS_PLTSEQ): Provide default.\n+\t* config/rs6000/rs6000.md (UNSPEC_PLTSEQ, UNSPEC_PLT16_HA,\n+\tUNSPEC_PLT16_LO): New.\n+\t(pltseq_tocsave, pltseq_plt16_ha, pltseq_plt16_lo, pltseq_mtctr): New.\n+\t(call_indirect_nonlocal_sysv): Don't differentiate zero from non-zero\n+\tcookie in constraints.  Test explicitly for flags in length attr.\n+\tHandle unspec operand 1.\n+\t(call_value_indirect_nonlocal_sysv): Likewise.\n+\t(call_indirect_aix, call_value_indirect_aix): Handle unspec operand 1.\n+\t(call_indirect_elfv2, call_value_indirect_elfv2): Likewise.\n+\t(sibcall, sibcall_value): Use rs6000_sibcall_sysv.\n+\t(sibcall_indirect_nonlocal_sysv): New pattern.\n+\t(sibcall_value_indirect_nonlocal_sysv): Likewise.\n+\t(sibcall_nonlocal_sysv, sibcall_value_nonlocal_sysv): Remove indirect\n+\tcall alternatives.\n+\t* configure.ac: Check for gas plt sequence marker support.\n+\t* configure: Regenerate.\n+\n 2018-11-29  Alan Modra  <amodra@gmail.com>\n \n \t* config/rs6000/predicates.md (unspec_tls): New."}, {"sha": "48a533bf20869aba50592d3f35aacceb559ea41f", "filename": "gcc/config.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f79c0ad268bc64d0cc231ba6d51098983bdb67b/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f79c0ad268bc64d0cc231ba6d51098983bdb67b/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=3f79c0ad268bc64d0cc231ba6d51098983bdb67b", "patch": "@@ -577,6 +577,12 @@\n #endif\n \n \n+/* Define if your assembler supports R_PPC*_PLTSEQ relocations. */\n+#ifndef USED_FOR_TARGET\n+#undef HAVE_AS_PLTSEQ\n+#endif\n+\n+\n /* Define if your assembler supports .ref */\n #ifndef USED_FOR_TARGET\n #undef HAVE_AS_REF"}, {"sha": "e98b00dec5db8f6e9119b15d769d2a9d65437b7e", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f79c0ad268bc64d0cc231ba6d51098983bdb67b/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f79c0ad268bc64d0cc231ba6d51098983bdb67b/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=3f79c0ad268bc64d0cc231ba6d51098983bdb67b", "patch": "@@ -1013,6 +1013,24 @@\n \t\t  || REGNO (op) >= FIRST_PSEUDO_REGISTER\")\n      (match_code \"symbol_ref\")))\n \n+;; Return 1 if the operand, used inside a MEM, is a valid first argument\n+;; to an indirect CALL.  This is LR, CTR, or a PLTSEQ unspec using CTR.\n+(define_predicate \"indirect_call_operand\"\n+  (match_code \"reg,unspec\")\n+{\n+  if (REG_P (op))\n+    return (REGNO (op) == LR_REGNO\n+\t    || REGNO (op) == CTR_REGNO);\n+  if (GET_CODE (op) == UNSPEC)\n+    {\n+      if (XINT (op, 1) != UNSPEC_PLTSEQ)\n+\treturn false;\n+      op = XVECEXP (op, 0, 0);\n+      return REG_P (op) && REGNO (op) == CTR_REGNO;\n+    }\n+  return false;\n+})\n+\n ;; Return 1 if the operand is a SYMBOL_REF for a function known to be in\n ;; this file.\n (define_predicate \"current_file_function_operand\""}, {"sha": "1dfe7995ff15eeb023a991b47fb203d0af2739f4", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f79c0ad268bc64d0cc231ba6d51098983bdb67b/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f79c0ad268bc64d0cc231ba6d51098983bdb67b/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=3f79c0ad268bc64d0cc231ba6d51098983bdb67b", "patch": "@@ -109,6 +109,7 @@ extern const char *rs6000_call_template (rtx *, unsigned int);\n extern const char *rs6000_sibcall_template (rtx *, unsigned int);\n extern const char *rs6000_indirect_call_template (rtx *, unsigned int);\n extern const char *rs6000_indirect_sibcall_template (rtx *, unsigned int);\n+extern const char *rs6000_pltseq_template (rtx *, int);\n extern enum rtx_code rs6000_reverse_condition (machine_mode,\n \t\t\t\t\t       enum rtx_code);\n extern rtx rs6000_emit_eqne (machine_mode, rtx, rtx, rtx);\n@@ -198,6 +199,7 @@ extern void rs6000_emit_eh_reg_restore (rtx, rtx);\n extern void rs6000_call_aix (rtx, rtx, rtx, rtx);\n extern void rs6000_sibcall_aix (rtx, rtx, rtx, rtx);\n extern void rs6000_call_sysv (rtx, rtx, rtx, rtx);\n+extern void rs6000_sibcall_sysv (rtx, rtx, rtx, rtx);\n extern void rs6000_aix_asm_output_dwarf_table_ref (char *);\n extern void get_ppc476_thunk_name (char name[32]);\n extern bool rs6000_overloaded_builtin_p (enum rs6000_builtins);"}, {"sha": "1c4bdb0cfd677d6c79259dc9fe3d5787730a9adf", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 321, "deletions": 38, "changes": 359, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f79c0ad268bc64d0cc231ba6d51098983bdb67b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f79c0ad268bc64d0cc231ba6d51098983bdb67b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=3f79c0ad268bc64d0cc231ba6d51098983bdb67b", "patch": "@@ -10689,7 +10689,7 @@ void\n init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype,\n \t\t      rtx libname ATTRIBUTE_UNUSED, int incoming,\n \t\t      int libcall, int n_named_args,\n-\t\t      tree fndecl ATTRIBUTE_UNUSED,\n+\t\t      tree fndecl,\n \t\t      machine_mode return_mode ATTRIBUTE_UNUSED)\n {\n   static CUMULATIVE_ARGS zero_cumulative;\n@@ -10715,6 +10715,27 @@ init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype,\n \t  && lookup_attribute (\"longcall\", TYPE_ATTRIBUTES (fntype))\n \t  && !lookup_attribute (\"shortcall\", TYPE_ATTRIBUTES (fntype))))\n     cum->call_cookie |= CALL_LONG;\n+  else if (DEFAULT_ABI != ABI_DARWIN)\n+    {\n+      bool is_local = (fndecl\n+\t\t       && !DECL_EXTERNAL (fndecl)\n+\t\t       && !DECL_WEAK (fndecl)\n+\t\t       && (*targetm.binds_local_p) (fndecl));\n+      if (is_local)\n+\t;\n+      else if (flag_plt)\n+\t{\n+\t  if (fntype\n+\t      && lookup_attribute (\"noplt\", TYPE_ATTRIBUTES (fntype)))\n+\t    cum->call_cookie |= CALL_LONG;\n+\t}\n+      else\n+\t{\n+\t  if (!(fntype\n+\t\t&& lookup_attribute (\"plt\", TYPE_ATTRIBUTES (fntype))))\n+\t    cum->call_cookie |= CALL_LONG;\n+\t}\n+    }\n \n   if (TARGET_DEBUG_ARG)\n     {\n@@ -20946,6 +20967,8 @@ print_operand (FILE *file, rtx x, int code)\n \n     case 'T':\n       /* Print the symbolic name of a branch target register.  */\n+      if (GET_CODE (x) == UNSPEC && XINT (x, 1) == UNSPEC_PLTSEQ)\n+\tx = XVECEXP (x, 0, 0);\n       if (GET_CODE (x) != REG || (REGNO (x) != LR_REGNO\n \t\t\t\t  && REGNO (x) != CTR_REGNO))\n \toutput_operand_lossage (\"invalid %%T value\");\n@@ -21089,6 +21112,8 @@ print_operand (FILE *file, rtx x, int code)\n       return;\n \n     case 'z':\n+      if (GET_CODE (x) == UNSPEC && XINT (x, 1) == UNSPEC_PLTSEQ)\n+\tx = XVECEXP (x, 0, 1);\n       /* X is a SYMBOL_REF.  Write out the name preceded by a\n \t period and without any trailing data in brackets.  Used for function\n \t names.  If we are configured for System V (or the embedded ABI) on\n@@ -21208,6 +21233,8 @@ print_operand (FILE *file, rtx x, int code)\n \toutput_addr_const (file, CONST_CAST_RTX (tocrel_base_oac));\n       else if (GET_CODE (x) == UNSPEC && XINT (x, 1) == UNSPEC_TLSGD)\n \toutput_addr_const (file, XVECEXP (x, 0, 0));\n+      else if (GET_CODE (x) == UNSPEC && XINT (x, 1) == UNSPEC_PLTSEQ)\n+\toutput_addr_const (file, XVECEXP (x, 0, 1));\n       else\n \toutput_addr_const (file, x);\n       return;\n@@ -21457,55 +21484,89 @@ rs6000_indirect_call_template_1 (rtx *operands, unsigned int funop,\n       might produce 10 digits.  */\n   gcc_assert (funop <= MAX_RECOG_OPERANDS);\n \n-  static char str[144];\n+  static char str[144];  /* 1 spare */\n+  char *s = str;\n   const char *ptrload = TARGET_64BIT ? \"d\" : \"wz\";\n \n+  if (DEFAULT_ABI == ABI_AIX)\n+    s += sprintf (s,\n+\t\t  \"l%s 2,%%%u\\n\\t\",\n+\t\t  ptrload, funop + 2);\n+\n   /* We don't need the extra code to stop indirect call speculation if\n      calling via LR.  */\n   bool speculate = (TARGET_MACHO\n \t\t    || rs6000_speculate_indirect_jumps\n \t\t    || (REG_P (operands[funop])\n \t\t\t&& REGNO (operands[funop]) == LR_REGNO));\n \n+  if (!TARGET_MACHO && HAVE_AS_PLTSEQ && GET_CODE (operands[funop]) == UNSPEC)\n+    {\n+      const char *rel64 = TARGET_64BIT ? \"64\" : \"\";\n+      char tls[29];\n+      tls[0] = 0;\n+      if (GET_CODE (operands[funop + 1]) == UNSPEC)\n+\t{\n+\t  if (XINT (operands[funop + 1], 1) == UNSPEC_TLSGD)\n+\t    sprintf (tls, \".reloc .,R_PPC%s_TLSGD,%%%u\\n\\t\",\n+\t\t     rel64, funop + 1);\n+\t  else if (XINT (operands[funop + 1], 1) == UNSPEC_TLSLD)\n+\t    sprintf (tls, \".reloc .,R_PPC%s_TLSLD,%%&\\n\\t\",\n+\t\t     rel64);\n+\t  else\n+\t    gcc_unreachable ();\n+\t}\n+\n+      const char *addend = (DEFAULT_ABI == ABI_V4 && TARGET_SECURE_PLT\n+\t\t\t    && flag_pic == 2 ? \"+32768\" : \"\");\n+      if (!speculate)\n+\t{\n+\t  s += sprintf (s,\n+\t\t\t\"%s.reloc .,R_PPC%s_PLTSEQ,%%z%u%s\\n\\t\",\n+\t\t\ttls, rel64, funop, addend);\n+\t  s += sprintf (s, \"crset 2\\n\\t\");\n+\t}\n+      s += sprintf (s,\n+\t\t    \"%s.reloc .,R_PPC%s_PLTCALL,%%z%u%s\\n\\t\",\n+\t\t    tls, rel64, funop, addend);\n+    }\n+  else if (!speculate)\n+    s += sprintf (s, \"crset 2\\n\\t\");\n+\n   if (DEFAULT_ABI == ABI_AIX)\n     {\n       if (speculate)\n-\tsprintf (str,\n-\t\t \"l%s 2,%%%u\\n\\t\"\n+\tsprintf (s,\n \t\t \"b%%T%ul\\n\\t\"\n \t\t \"l%s 2,%%%u(1)\",\n-\t\t ptrload, funop + 2, funop, ptrload, funop + 3);\n+\t\t funop, ptrload, funop + 3);\n       else\n-\tsprintf (str,\n-\t\t \"crset 2\\n\\t\"\n-\t\t \"l%s 2,%%%u\\n\\t\"\n+\tsprintf (s,\n \t\t \"beq%%T%ul-\\n\\t\"\n \t\t \"l%s 2,%%%u(1)\",\n-\t\t ptrload, funop + 2, funop, ptrload, funop + 3);\n+\t\t funop, ptrload, funop + 3);\n     }\n   else if (DEFAULT_ABI == ABI_ELFv2)\n     {\n       if (speculate)\n-\tsprintf (str,\n+\tsprintf (s,\n \t\t \"b%%T%ul\\n\\t\"\n \t\t \"l%s 2,%%%u(1)\",\n \t\t funop, ptrload, funop + 2);\n       else\n-\tsprintf (str,\n-\t\t \"crset 2\\n\\t\"\n+\tsprintf (s,\n \t\t \"beq%%T%ul-\\n\\t\"\n \t\t \"l%s 2,%%%u(1)\",\n \t\t funop, ptrload, funop + 2);\n     }\n   else\n     {\n       if (speculate)\n-\tsprintf (str,\n+\tsprintf (s,\n \t\t \"b%%T%u%s\",\n \t\t funop, sibcall ? \"\" : \"l\");\n       else\n-\tsprintf (str,\n-\t\t \"crset 2\\n\\t\"\n+\tsprintf (s,\n \t\t \"beq%%T%u%s-%s\",\n \t\t funop, sibcall ? \"\" : \"l\", sibcall ? \"\\n\\tb $\" : \"\");\n     }\n@@ -21524,6 +21585,72 @@ rs6000_indirect_sibcall_template (rtx *operands, unsigned int funop)\n   return rs6000_indirect_call_template_1 (operands, funop, true);\n }\n \n+#if HAVE_AS_PLTSEQ\n+/* Output indirect call insns.\n+   WHICH is 0 for tocsave, 1 for plt16_ha, 2 for plt16_lo, 3 for mtctr.  */\n+const char *\n+rs6000_pltseq_template (rtx *operands, int which)\n+{\n+  const char *rel64 = TARGET_64BIT ? \"64\" : \"\";\n+  char tls[28];\n+  tls[0] = 0;\n+  if (GET_CODE (operands[3]) == UNSPEC)\n+    {\n+      if (XINT (operands[3], 1) == UNSPEC_TLSGD)\n+\tsprintf (tls, \".reloc .,R_PPC%s_TLSGD,%%3\\n\\t\",\n+\t\t rel64);\n+      else if (XINT (operands[3], 1) == UNSPEC_TLSLD)\n+\tsprintf (tls, \".reloc .,R_PPC%s_TLSLD,%%&\\n\\t\",\n+\t\t rel64);\n+      else\n+\tgcc_unreachable ();\n+    }\n+\n+  gcc_assert (DEFAULT_ABI == ABI_ELFv2 || DEFAULT_ABI == ABI_V4);\n+  static char str[96];  /* 15 spare */\n+  const char *off = WORDS_BIG_ENDIAN ? \"+2\" : \"\";\n+  const char *addend = (DEFAULT_ABI == ABI_V4 && TARGET_SECURE_PLT\n+\t\t\t&& flag_pic == 2 ? \"+32768\" : \"\");\n+  switch (which)\n+    {\n+    case 0:\n+      sprintf (str,\n+\t       \"%s.reloc .,R_PPC%s_PLTSEQ,%%z2\\n\\t\"\n+\t       \"st%s\",\n+\t       tls, rel64, TARGET_64BIT ? \"d 2,24(1)\" : \"w 2,12(1)\");\n+      break;\n+    case 1:\n+      if (DEFAULT_ABI == ABI_V4 && !flag_pic)\n+\tsprintf (str,\n+\t\t \"%s.reloc .%s,R_PPC%s_PLT16_HA,%%z2\\n\\t\"\n+\t\t \"lis %%0,0\",\n+\t\t tls, off, rel64);\n+      else\n+\tsprintf (str,\n+\t\t \"%s.reloc .%s,R_PPC%s_PLT16_HA,%%z2%s\\n\\t\"\n+\t\t \"addis %%0,%%1,0\",\n+\t\t tls, off, rel64, addend);\n+      break;\n+    case 2:\n+      sprintf (str,\n+\t       \"%s.reloc .%s,R_PPC%s_PLT16_LO%s,%%z2%s\\n\\t\"\n+\t       \"l%s %%0,0(%%1)\",\n+\t       tls, off, rel64, TARGET_64BIT ? \"_DS\" : \"\", addend,\n+\t       TARGET_64BIT ? \"d\" : \"wz\");\n+      break;\n+    case 3:\n+      sprintf (str,\n+\t       \"%s.reloc .,R_PPC%s_PLTSEQ,%%z2%s\\n\\t\"\n+\t       \"mtctr %%1\",\n+\t       tls, rel64, addend);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  return str;\n+}\n+#endif\n+\n #if defined (HAVE_GAS_HIDDEN) && !TARGET_MACHO\n /* Emit an assembler directive to set symbol visibility for DECL to\n    VISIBILITY_TYPE.  */\n@@ -32535,11 +32662,8 @@ rs6000_set_default_type_attributes (tree type)\n    longcall attribute.  */\n \n static rtx\n-rs6000_longcall_ref (rtx call_ref)\n+rs6000_longcall_ref (rtx call_ref, rtx arg)\n {\n-  if (GET_CODE (call_ref) != SYMBOL_REF)\n-    return call_ref;\n-\n   /* System V adds '.' to the internal name, so skip them.  */\n   const char *call_name = XSTR (call_ref, 0);\n   if (*call_name == '.')\n@@ -32551,6 +32675,36 @@ rs6000_longcall_ref (rtx call_ref)\n       call_ref = gen_rtx_SYMBOL_REF (VOIDmode, IDENTIFIER_POINTER (node));\n     }\n \n+  if (HAVE_AS_PLTSEQ\n+      && TARGET_TLS_MARKERS\n+      && (DEFAULT_ABI == ABI_ELFv2 || DEFAULT_ABI == ABI_V4))\n+    {\n+      rtx base = const0_rtx;\n+      int regno;\n+      if (DEFAULT_ABI == ABI_ELFv2)\n+\t{\n+\t  base = gen_rtx_REG (Pmode, TOC_REGISTER);\n+\t  regno = 12;\n+\t}\n+      else\n+\t{\n+\t  if (flag_pic)\n+\t    base = gen_rtx_REG (Pmode, RS6000_PIC_OFFSET_TABLE_REGNUM);\n+\t  regno = 11;\n+\t}\n+      /* Reg must match that used by linker PLT stubs.  For ELFv2, r12\n+\t may be used by a function global entry point.  For SysV4, r11\n+\t is used by __glink_PLTresolve lazy resolver entry.  */\n+      rtx reg = gen_rtx_REG (Pmode, regno);\n+      rtx hi = gen_rtx_UNSPEC (Pmode, gen_rtvec (3, base, call_ref, arg),\n+\t\t\t       UNSPEC_PLT16_HA);\n+      rtx lo = gen_rtx_UNSPEC (Pmode, gen_rtvec (3, reg, call_ref, arg),\n+\t\t\t       UNSPEC_PLT16_LO);\n+      emit_insn (gen_rtx_SET (reg, hi));\n+      emit_insn (gen_rtx_SET (reg, lo));\n+      return reg;\n+    }\n+\n   return force_reg (Pmode, call_ref);\n }\n \f\n@@ -37520,8 +37674,7 @@ chain_already_loaded (rtx_insn *last)\n void\n rs6000_call_aix (rtx value, rtx func_desc, rtx tlsarg, rtx cookie)\n {\n-  const bool direct_call_p\n-    = GET_CODE (func_desc) == SYMBOL_REF && SYMBOL_REF_FUNCTION_P (func_desc);\n+  rtx func = func_desc;\n   rtx toc_reg = gen_rtx_REG (Pmode, TOC_REGNUM);\n   rtx toc_load = NULL_RTX;\n   rtx toc_restore = NULL_RTX;\n@@ -37535,12 +37688,13 @@ rs6000_call_aix (rtx value, rtx func_desc, rtx tlsarg, rtx cookie)\n     tlsarg = global_tlsarg;\n \n   /* Handle longcall attributes.  */\n-  if (INTVAL (cookie) & CALL_LONG)\n-    func_desc = rs6000_longcall_ref (func_desc);\n+  if ((INTVAL (cookie) & CALL_LONG) != 0\n+      && GET_CODE (func_desc) == SYMBOL_REF)\n+    func = rs6000_longcall_ref (func_desc, tlsarg);\n \n   /* Handle indirect calls.  */\n-  if (GET_CODE (func_desc) != SYMBOL_REF\n-      || (DEFAULT_ABI == ABI_AIX && !SYMBOL_REF_FUNCTION_P (func_desc)))\n+  if (GET_CODE (func) != SYMBOL_REF\n+      || (DEFAULT_ABI == ABI_AIX && !SYMBOL_REF_FUNCTION_P (func)))\n     {\n       /* Save the TOC into its reserved slot before the call,\n \t and prepare to restore it after the call.  */\n@@ -37561,17 +37715,43 @@ rs6000_call_aix (rtx value, rtx func_desc, rtx tlsarg, rtx cookie)\n \t\t\t\t\t     gen_rtx_PLUS (Pmode, stack_ptr,\n \t\t\t\t\t\t\t   stack_toc_offset));\n \t  MEM_VOLATILE_P (stack_toc_mem) = 1;\n-\t  emit_move_insn (stack_toc_mem, toc_reg);\n+\t  if (HAVE_AS_PLTSEQ\n+\t      && TARGET_TLS_MARKERS\n+\t      && DEFAULT_ABI == ABI_ELFv2\n+\t      && GET_CODE (func_desc) == SYMBOL_REF)\n+\t    {\n+\t      rtvec v = gen_rtvec (3, toc_reg, func_desc, tlsarg);\n+\t      rtx mark_toc_reg = gen_rtx_UNSPEC (Pmode, v, UNSPEC_PLTSEQ);\n+\t      emit_insn (gen_rtx_SET (stack_toc_mem, mark_toc_reg));\n+\t    }\n+\t  else\n+\t    emit_move_insn (stack_toc_mem, toc_reg);\n \t}\n \n       if (DEFAULT_ABI == ABI_ELFv2)\n \t{\n \t  /* A function pointer in the ELFv2 ABI is just a plain address, but\n \t     the ABI requires it to be loaded into r12 before the call.  */\n \t  func_addr = gen_rtx_REG (Pmode, 12);\n-\t  if (!rtx_equal_p (func_addr, func_desc))\n-\t    emit_move_insn (func_addr, func_desc);\n+\t  if (!rtx_equal_p (func_addr, func))\n+\t    emit_move_insn (func_addr, func);\n \t  abi_reg = func_addr;\n+\t  /* Indirect calls via CTR are strongly preferred over indirect\n+\t     calls via LR, so move the address there.  Needed to mark\n+\t     this insn for linker plt sequence editing too.  */\n+\t  func_addr = gen_rtx_REG (Pmode, CTR_REGNO);\n+\t  if (HAVE_AS_PLTSEQ\n+\t      && TARGET_TLS_MARKERS\n+\t      && GET_CODE (func_desc) == SYMBOL_REF)\n+\t    {\n+\t      rtvec v = gen_rtvec (3, abi_reg, func_desc, tlsarg);\n+\t      rtx mark_func = gen_rtx_UNSPEC (Pmode, v, UNSPEC_PLTSEQ);\n+\t      emit_insn (gen_rtx_SET (func_addr, mark_func));\n+\t      v = gen_rtvec (2, func_addr, func_desc);\n+\t      func_addr = gen_rtx_UNSPEC (Pmode, v, UNSPEC_PLTSEQ);\n+\t    }\n+\t  else\n+\t    emit_move_insn (func_addr, abi_reg);\n \t}\n       else\n \t{\n@@ -37583,32 +37763,39 @@ rs6000_call_aix (rtx value, rtx func_desc, rtx tlsarg, rtx cookie)\n \t     not have any executable code.  */\n \n \t  /* Load up address of the actual function.  */\n-\t  func_desc = force_reg (Pmode, func_desc);\n+\t  func = force_reg (Pmode, func);\n \t  func_addr = gen_reg_rtx (Pmode);\n-\t  emit_move_insn (func_addr, gen_rtx_MEM (Pmode, func_desc));\n+\t  emit_move_insn (func_addr, gen_rtx_MEM (Pmode, func));\n+\n+\t  /* Indirect calls via CTR are strongly preferred over indirect\n+\t     calls via LR, so move the address there.  */\n+\t  rtx ctr_reg = gen_rtx_REG (Pmode, CTR_REGNO);\n+\t  emit_move_insn (ctr_reg, func_addr);\n+\t  func_addr = ctr_reg;\n \n \t  /* Prepare to load the TOC of the called function.  Note that the\n \t     TOC load must happen immediately before the actual call so\n \t     that unwinding the TOC registers works correctly.  See the\n \t     comment in frob_update_context.  */\n \t  rtx func_toc_offset = GEN_INT (GET_MODE_SIZE (Pmode));\n \t  rtx func_toc_mem = gen_rtx_MEM (Pmode,\n-\t\t\t\t\t  gen_rtx_PLUS (Pmode, func_desc,\n+\t\t\t\t\t  gen_rtx_PLUS (Pmode, func,\n \t\t\t\t\t\t\tfunc_toc_offset));\n \t  toc_load = gen_rtx_USE (VOIDmode, func_toc_mem);\n \n \t  /* If we have a static chain, load it up.  But, if the call was\n \t     originally direct, the 3rd word has not been written since no\n \t     trampoline has been built, so we ought not to load it, lest we\n \t     override a static chain value.  */\n-\t  if (!direct_call_p\n+\t  if (!(GET_CODE (func_desc) == SYMBOL_REF\n+\t\t&& SYMBOL_REF_FUNCTION_P (func_desc))\n \t      && TARGET_POINTERS_TO_NESTED_FUNCTIONS\n \t      && !chain_already_loaded (get_current_sequence ()->next->last))\n \t    {\n \t      rtx sc_reg = gen_rtx_REG (Pmode, STATIC_CHAIN_REGNUM);\n \t      rtx func_sc_offset = GEN_INT (2 * GET_MODE_SIZE (Pmode));\n \t      rtx func_sc_mem = gen_rtx_MEM (Pmode,\n-\t\t\t\t\t     gen_rtx_PLUS (Pmode, func_desc,\n+\t\t\t\t\t     gen_rtx_PLUS (Pmode, func,\n \t\t\t\t\t\t\t   func_sc_offset));\n \t      emit_move_insn (sc_reg, func_sc_mem);\n \t      abi_reg = sc_reg;\n@@ -37621,7 +37808,7 @@ rs6000_call_aix (rtx value, rtx func_desc, rtx tlsarg, rtx cookie)\n \t assume the TOC register is set; for non-local calls, the\n \t PLT stub needs the TOC register.  */\n       abi_reg = toc_reg;\n-      func_addr = func_desc;\n+      func_addr = func;\n     }\n \n   /* Create the call.  */\n@@ -37676,22 +37863,51 @@ rs6000_sibcall_aix (rtx value, rtx func_desc, rtx tlsarg, rtx cookie)\n /* Expand code to perform a call under the SYSV4 ABI.  */\n \n void\n-rs6000_call_sysv (rtx value, rtx func, rtx tlsarg, rtx cookie)\n+rs6000_call_sysv (rtx value, rtx func_desc, rtx tlsarg, rtx cookie)\n {\n+  rtx func = func_desc;\n   rtx func_addr;\n   rtx call[3];\n   rtx insn;\n+  rtx abi_reg = NULL_RTX;\n \n   if (global_tlsarg)\n     tlsarg = global_tlsarg;\n \n   /* Handle longcall attributes.  */\n-  if (INTVAL (cookie) & CALL_LONG)\n-    func = rs6000_longcall_ref (func);\n+  if ((INTVAL (cookie) & CALL_LONG) != 0\n+      && GET_CODE (func_desc) == SYMBOL_REF)\n+    {\n+      func = rs6000_longcall_ref (func_desc, tlsarg);\n+      /* If the longcall was implemented using PLT16 relocs, then r11\n+\t needs to be valid at the call for lazy linking.  */\n+      if (HAVE_AS_PLTSEQ\n+\t  && TARGET_TLS_MARKERS)\n+\tabi_reg = func;\n+    }\n \n   /* Handle indirect calls.  */\n   if (GET_CODE (func) != SYMBOL_REF)\n-    func_addr = force_reg (Pmode, func);\n+    {\n+      func = force_reg (Pmode, func);\n+\n+      /* Indirect calls via CTR are strongly preferred over indirect\n+\t calls via LR, so move the address there.  Needed to mark\n+\t this insn for linker plt sequence editing too.  */\n+      func_addr = gen_rtx_REG (Pmode, CTR_REGNO);\n+      if (HAVE_AS_PLTSEQ\n+\t  && TARGET_TLS_MARKERS\n+\t  && GET_CODE (func_desc) == SYMBOL_REF)\n+\t{\n+\t  rtvec v = gen_rtvec (3, func, func_desc, tlsarg);\n+\t  rtx mark_func = gen_rtx_UNSPEC (Pmode, v, UNSPEC_PLTSEQ);\n+\t  emit_insn (gen_rtx_SET (func_addr, mark_func));\n+\t  v = gen_rtvec (2, func_addr, func_desc);\n+\t  func_addr = gen_rtx_UNSPEC (Pmode, v, UNSPEC_PLTSEQ);\n+\t}\n+      else\n+\temit_move_insn (func_addr, func);\n+    }\n   else\n     func_addr = func;\n \n@@ -37707,6 +37923,73 @@ rs6000_call_sysv (rtx value, rtx func, rtx tlsarg, rtx cookie)\n \n   insn = gen_rtx_PARALLEL (VOIDmode, gen_rtvec_v (3, call));\n   insn = emit_call_insn (insn);\n+  if (abi_reg)\n+    use_reg (&CALL_INSN_FUNCTION_USAGE (insn), abi_reg);\n+}\n+\n+/* Expand code to perform a sibling call under the SysV4 ABI.  */\n+\n+void\n+rs6000_sibcall_sysv (rtx value, rtx func_desc, rtx tlsarg, rtx cookie)\n+{\n+  rtx func = func_desc;\n+  rtx func_addr;\n+  rtx call[3];\n+  rtx insn;\n+  rtx abi_reg = NULL_RTX;\n+\n+  if (global_tlsarg)\n+    tlsarg = global_tlsarg;\n+\n+  /* Handle longcall attributes.  */\n+  if ((INTVAL (cookie) & CALL_LONG) != 0\n+      && GET_CODE (func_desc) == SYMBOL_REF)\n+    {\n+      func = rs6000_longcall_ref (func_desc, tlsarg);\n+      /* If the longcall was implemented using PLT16 relocs, then r11\n+\t needs to be valid at the call for lazy linking.  */\n+      if (HAVE_AS_PLTSEQ\n+\t  && TARGET_TLS_MARKERS)\n+\tabi_reg = func;\n+    }\n+\n+  /* Handle indirect calls.  */\n+  if (GET_CODE (func) != SYMBOL_REF)\n+    {\n+      func = force_reg (Pmode, func);\n+\n+      /* Indirect sibcalls must go via CTR.  Needed to mark\n+\t this insn for linker plt sequence editing too.  */\n+      func_addr = gen_rtx_REG (Pmode, CTR_REGNO);\n+      if (HAVE_AS_PLTSEQ\n+\t  && TARGET_TLS_MARKERS\n+\t  && GET_CODE (func_desc) == SYMBOL_REF)\n+\t{\n+\t  rtvec v = gen_rtvec (3, func, func_desc, tlsarg);\n+\t  rtx mark_func = gen_rtx_UNSPEC (Pmode, v, UNSPEC_PLTSEQ);\n+\t  emit_insn (gen_rtx_SET (func_addr, mark_func));\n+\t  v = gen_rtvec (2, func_addr, func_desc);\n+\t  func_addr = gen_rtx_UNSPEC (Pmode, v, UNSPEC_PLTSEQ);\n+\t}\n+      else\n+\temit_move_insn (func_addr, func);\n+    }\n+  else\n+    func_addr = func;\n+\n+  /* Create the call.  */\n+  call[0] = gen_rtx_CALL (VOIDmode, gen_rtx_MEM (SImode, func_addr), tlsarg);\n+  if (value != NULL_RTX)\n+    call[0] = gen_rtx_SET (value, call[0]);\n+\n+  unsigned int mask = CALL_V4_SET_FP_ARGS | CALL_V4_CLEAR_FP_ARGS;\n+  call[1] = gen_rtx_USE (VOIDmode, GEN_INT (INTVAL (cookie) & mask));\n+  call[2] = simple_return_rtx;\n+\n+  insn = gen_rtx_PARALLEL (VOIDmode, gen_rtvec_v (3, call));\n+  insn = emit_call_insn (insn);\n+  if (abi_reg)\n+    use_reg (&CALL_INSN_FUNCTION_USAGE (insn), abi_reg);\n }\n \n /* Return whether we need to always update the saved TOC pointer when we update"}, {"sha": "2a62679bdb8459df5e1b4ea9d69bfc352019dc8c", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f79c0ad268bc64d0cc231ba6d51098983bdb67b/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f79c0ad268bc64d0cc231ba6d51098983bdb67b/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=3f79c0ad268bc64d0cc231ba6d51098983bdb67b", "patch": "@@ -220,6 +220,10 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n #define HAVE_AS_TLS 0\n #endif\n \n+#ifndef HAVE_AS_PLTSEQ\n+#define HAVE_AS_PLTSEQ 0\n+#endif\n+\n #ifndef TARGET_LINK_STACK\n #define TARGET_LINK_STACK 0\n #endif"}, {"sha": "8427a5e55bb752dc9dca28433ed218a7054bcab6", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 167, "deletions": 80, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f79c0ad268bc64d0cc231ba6d51098983bdb67b/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f79c0ad268bc64d0cc231ba6d51098983bdb67b/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=3f79c0ad268bc64d0cc231ba6d51098983bdb67b", "patch": "@@ -146,6 +146,9 @@\n    UNSPEC_SIGNBIT\n    UNSPEC_SF_FROM_SI\n    UNSPEC_SI_FROM_SF\n+   UNSPEC_PLTSEQ\n+   UNSPEC_PLT16_HA\n+   UNSPEC_PLT16_LO\n   ])\n \n ;;\n@@ -10195,6 +10198,55 @@\n \t\t   (match_operand 2 \"\" \"\")))]\n    \"TARGET_ELF && !TARGET_64BIT && !flag_pic\"\n    \"la %0,%2@l(%1)\")\n+\n+(define_insn \"*pltseq_tocsave_<mode>\"\n+  [(set (match_operand:P 0 \"memory_operand\" \"=m\")\n+\t(unspec:P [(match_operand:P 1 \"gpc_reg_operand\" \"b\")\n+\t\t   (match_operand:P 2 \"symbol_ref_operand\" \"s\")\n+\t\t   (match_operand:P 3 \"\" \"\")]\n+\t\t  UNSPEC_PLTSEQ))]\n+  \"HAVE_AS_PLTSEQ && TARGET_TLS_MARKERS\n+   && DEFAULT_ABI == ABI_ELFv2\"\n+{\n+  return rs6000_pltseq_template (operands, 0);\n+})\n+\n+(define_insn \"*pltseq_plt16_ha_<mode>\"\n+  [(set (match_operand:P 0 \"gpc_reg_operand\" \"=r\")\n+\t(unspec:P [(match_operand:P 1 \"\" \"\")\n+\t\t   (match_operand:P 2 \"symbol_ref_operand\" \"s\")\n+\t\t   (match_operand:P 3 \"\" \"\")]\n+\t\t  UNSPEC_PLT16_HA))]\n+  \"HAVE_AS_PLTSEQ && TARGET_TLS_MARKERS\n+   && (DEFAULT_ABI == ABI_ELFv2 || DEFAULT_ABI == ABI_V4)\"\n+{\n+  return rs6000_pltseq_template (operands, 1);\n+})\n+\n+(define_insn \"*pltseq_plt16_lo_<mode>\"\n+  [(set (match_operand:P 0 \"gpc_reg_operand\" \"=r\")\n+\t(unspec:P [(match_operand:P 1 \"gpc_reg_operand\" \"b\")\n+\t\t   (match_operand:P 2 \"symbol_ref_operand\" \"s\")\n+\t\t   (match_operand:P 3 \"\" \"\")]\n+\t\t  UNSPEC_PLT16_LO))]\n+  \"HAVE_AS_PLTSEQ && TARGET_TLS_MARKERS\n+   && (DEFAULT_ABI == ABI_ELFv2 || DEFAULT_ABI == ABI_V4)\"\n+{\n+  return rs6000_pltseq_template (operands, 2);\n+}\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_insn \"*pltseq_mtctr_<mode>\"\n+  [(set (match_operand:P 0 \"register_operand\" \"=c\")\n+\t(unspec:P [(match_operand:P 1 \"gpc_reg_operand\" \"r\")\n+\t\t   (match_operand:P 2 \"symbol_ref_operand\" \"s\")\n+\t\t   (match_operand:P 3 \"\" \"\")]\n+\t\t  UNSPEC_PLTSEQ))]\n+  \"HAVE_AS_PLTSEQ && TARGET_TLS_MARKERS\n+   && (DEFAULT_ABI == ABI_ELFv2 || DEFAULT_ABI == ABI_V4)\"\n+{\n+  return rs6000_pltseq_template (operands, 3);\n+})\n \f\n ;; Call and call_value insns\n (define_expand \"call\"\n@@ -10351,9 +10403,9 @@\n ;; which indicates how to set cr1\n \n (define_insn \"*call_indirect_nonlocal_sysv<mode>\"\n-  [(call (mem:SI (match_operand:P 0 \"register_operand\" \"c,*l,c,*l\"))\n+  [(call (mem:SI (match_operand:P 0 \"indirect_call_operand\" \"c,*l,X\"))\n \t (match_operand 1))\n-   (use (match_operand:SI 2 \"immediate_operand\" \"O,O,n,n\"))\n+   (use (match_operand:SI 2 \"immediate_operand\" \"n,n,n\"))\n    (clobber (reg:SI LR_REGNO))]\n   \"DEFAULT_ABI == ABI_V4\n    || DEFAULT_ABI == ABI_DARWIN\"\n@@ -10366,18 +10418,17 @@\n \n   return rs6000_indirect_call_template (operands, 0);\n }\n-  [(set_attr \"type\" \"jmpreg,jmpreg,jmpreg,jmpreg\")\n-   (set_attr_alternative \"length\"\n-     [(if_then_else (eq (symbol_ref \"rs6000_speculate_indirect_jumps\")\n-\t\t\t(const_int 0))\n-\t\t    (const_string \"8\")\n-\t\t    (const_string \"4\"))\n-      (const_string \"4\")\n-      (if_then_else (eq (symbol_ref \"rs6000_speculate_indirect_jumps\")\n-\t\t\t(const_int 0))\n-\t\t    (const_string \"12\")\n-\t\t    (const_string \"8\"))\n-      (const_string \"8\")])])\n+  [(set_attr \"type\" \"jmpreg\")\n+   (set (attr \"length\")\n+\t(cond [(and (and (match_test \"!rs6000_speculate_indirect_jumps\")\n+\t\t\t (match_test \"which_alternative != 1\"))\n+\t\t    (match_test \"(INTVAL (operands[2]) & (CALL_V4_SET_FP_ARGS | CALL_V4_CLEAR_FP_ARGS))\"))\n+\t\t  (const_string \"12\")\n+\t       (ior (and (match_test \"!rs6000_speculate_indirect_jumps\")\n+\t\t\t (match_test \"which_alternative != 1\"))\n+\t\t    (match_test \"(INTVAL (operands[2]) & (CALL_V4_SET_FP_ARGS | CALL_V4_CLEAR_FP_ARGS))\"))\n+\t\t  (const_string \"8\")]\n+\t      (const_string \"4\")))])\n \n (define_insn_and_split \"*call_nonlocal_sysv<mode>\"\n   [(call (mem:SI (match_operand:P 0 \"symbol_ref_operand\" \"s,s\"))\n@@ -10437,9 +10488,9 @@\n \n (define_insn \"*call_value_indirect_nonlocal_sysv<mode>\"\n   [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:SI (match_operand:P 1 \"register_operand\" \"c,*l,c,*l\"))\n+\t(call (mem:SI (match_operand:P 1 \"indirect_call_operand\" \"c,*l,X\"))\n \t      (match_operand 2)))\n-   (use (match_operand:SI 3 \"immediate_operand\" \"O,O,n,n\"))\n+   (use (match_operand:SI 3 \"immediate_operand\" \"n,n,n\"))\n    (clobber (reg:SI LR_REGNO))]\n   \"DEFAULT_ABI == ABI_V4\n    || DEFAULT_ABI == ABI_DARWIN\"\n@@ -10452,18 +10503,17 @@\n \n   return rs6000_indirect_call_template (operands, 1);\n }\n-  [(set_attr \"type\" \"jmpreg,jmpreg,jmpreg,jmpreg\")\n-   (set_attr_alternative \"length\"\n-     [(if_then_else (eq (symbol_ref \"rs6000_speculate_indirect_jumps\")\n-\t\t\t(const_int 0))\n-\t\t    (const_string \"8\")\n-\t\t    (const_string \"4\"))\n-      (const_string \"4\")\n-      (if_then_else (eq (symbol_ref \"rs6000_speculate_indirect_jumps\")\n-\t\t\t(const_int 0))\n-\t\t    (const_string \"12\")\n-\t\t    (const_string \"8\"))\n-      (const_string \"8\")])])\n+  [(set_attr \"type\" \"jmpreg\")\n+   (set (attr \"length\")\n+\t(cond [(and (and (match_test \"!rs6000_speculate_indirect_jumps\")\n+\t\t\t (match_test \"which_alternative != 1\"))\n+\t\t    (match_test \"(INTVAL (operands[3]) & (CALL_V4_SET_FP_ARGS | CALL_V4_CLEAR_FP_ARGS))\"))\n+\t\t  (const_string \"12\")\n+\t       (ior (and (match_test \"!rs6000_speculate_indirect_jumps\")\n+\t\t\t (match_test \"which_alternative != 1\"))\n+\t\t   (match_test \"(INTVAL (operands[3]) & (CALL_V4_SET_FP_ARGS | CALL_V4_CLEAR_FP_ARGS))\"))\n+\t\t  (const_string \"8\")]\n+\t      (const_string \"4\")))])\n \n (define_insn_and_split \"*call_value_nonlocal_sysv<mode>\"\n   [(set (match_operand 0 \"\" \"\")\n@@ -10576,10 +10626,10 @@\n ;; Operand3 is the offset of the stack location holding the current TOC pointer\n \n (define_insn \"*call_indirect_aix<mode>\"\n-  [(call (mem:SI (match_operand:P 0 \"register_operand\" \"c,*l\"))\n+  [(call (mem:SI (match_operand:P 0 \"indirect_call_operand\" \"c,*l,X\"))\n \t (match_operand 1))\n-   (use (match_operand:P 2 \"memory_operand\" \"<ptrm>,<ptrm>\"))\n-   (set (reg:P TOC_REGNUM) (unspec:P [(match_operand:P 3 \"const_int_operand\" \"n,n\")] UNSPEC_TOCSLOT))\n+   (use (match_operand:P 2 \"memory_operand\" \"<ptrm>,<ptrm>,<ptrm>\"))\n+   (set (reg:P TOC_REGNUM) (unspec:P [(match_operand:P 3 \"const_int_operand\" \"n,n,n\")] UNSPEC_TOCSLOT))\n    (clobber (reg:P LR_REGNO))]\n   \"DEFAULT_ABI == ABI_AIX\"\n {\n@@ -10594,10 +10644,10 @@\n \n (define_insn \"*call_value_indirect_aix<mode>\"\n   [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:SI (match_operand:P 1 \"register_operand\" \"c,*l\"))\n+\t(call (mem:SI (match_operand:P 1 \"indirect_call_operand\" \"c,*l,X\"))\n \t      (match_operand 2)))\n-   (use (match_operand:P 3 \"memory_operand\" \"<ptrm>,<ptrm>\"))\n-   (set (reg:P TOC_REGNUM) (unspec:P [(match_operand:P 4 \"const_int_operand\" \"n,n\")] UNSPEC_TOCSLOT))\n+   (use (match_operand:P 3 \"memory_operand\" \"<ptrm>,<ptrm>,<ptrm>\"))\n+   (set (reg:P TOC_REGNUM) (unspec:P [(match_operand:P 4 \"const_int_operand\" \"n,n,n\")] UNSPEC_TOCSLOT))\n    (clobber (reg:P LR_REGNO))]\n   \"DEFAULT_ABI == ABI_AIX\"\n {\n@@ -10615,9 +10665,9 @@\n ;; Operand2 is the offset of the stack location holding the current TOC pointer\n \n (define_insn \"*call_indirect_elfv2<mode>\"\n-  [(call (mem:SI (match_operand:P 0 \"register_operand\" \"c,*l\"))\n+  [(call (mem:SI (match_operand:P 0 \"indirect_call_operand\" \"c,*l,X\"))\n \t (match_operand 1))\n-   (set (reg:P TOC_REGNUM) (unspec:P [(match_operand:P 2 \"const_int_operand\" \"n,n\")] UNSPEC_TOCSLOT))\n+   (set (reg:P TOC_REGNUM) (unspec:P [(match_operand:P 2 \"const_int_operand\" \"n,n,n\")] UNSPEC_TOCSLOT))\n    (clobber (reg:P LR_REGNO))]\n   \"DEFAULT_ABI == ABI_ELFv2\"\n {\n@@ -10632,9 +10682,9 @@\n \n (define_insn \"*call_value_indirect_elfv2<mode>\"\n   [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:SI (match_operand:P 1 \"register_operand\" \"c,*l\"))\n+\t(call (mem:SI (match_operand:P 1 \"indirect_call_operand\" \"c,*l,X\"))\n \t      (match_operand 2)))\n-   (set (reg:P TOC_REGNUM) (unspec:P [(match_operand:P 3 \"const_int_operand\" \"n,n\")] UNSPEC_TOCSLOT))\n+   (set (reg:P TOC_REGNUM) (unspec:P [(match_operand:P 3 \"const_int_operand\" \"n,n,n\")] UNSPEC_TOCSLOT))\n    (clobber (reg:P LR_REGNO))]\n   \"DEFAULT_ABI == ABI_ELFv2\"\n {\n@@ -10697,6 +10747,12 @@\n       rs6000_sibcall_aix (NULL_RTX, operands[0], operands[1], operands[2]);\n       DONE;\n     }\n+\n+  if (DEFAULT_ABI == ABI_V4)\n+    {\n+      rs6000_sibcall_sysv (NULL_RTX, operands[0], operands[1], operands[2]);\n+      DONE;\n+    }\n })\n \n (define_expand \"sibcall_value\"\n@@ -10722,6 +10778,12 @@\n       rs6000_sibcall_aix (operands[0], operands[1], operands[2], operands[3]);\n       DONE;\n     }\n+\n+  if (DEFAULT_ABI == ABI_V4)\n+    {\n+      rs6000_sibcall_sysv (operands[0], operands[1], operands[2], operands[3]);\n+      DONE;\n+    }\n })\n \n (define_insn \"*sibcall_local32\"\n@@ -10798,10 +10860,38 @@\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"4,8\")])\n \n+(define_insn \"*sibcall_indirect_nonlocal_sysv<mode>\"\n+  [(call (mem:SI (match_operand:P 0 \"indirect_call_operand\" \"c,*l,X\"))\n+\t (match_operand 1))\n+   (use (match_operand:SI 2 \"immediate_operand\" \"n,n,n\"))\n+   (simple_return)]\n+  \"DEFAULT_ABI == ABI_V4\n+   || DEFAULT_ABI == ABI_DARWIN\"\n+{\n+  if (INTVAL (operands[2]) & CALL_V4_SET_FP_ARGS)\n+    output_asm_insn (\"crxor 6,6,6\", operands);\n+\n+  else if (INTVAL (operands[2]) & CALL_V4_CLEAR_FP_ARGS)\n+    output_asm_insn (\"creqv 6,6,6\", operands);\n+\n+  return rs6000_indirect_sibcall_template (operands, 0);\n+}\n+  [(set_attr \"type\" \"jmpreg\")\n+   (set (attr \"length\")\n+\t(cond [(and (and (match_test \"!rs6000_speculate_indirect_jumps\")\n+\t\t\t (match_test \"which_alternative != 1\"))\n+\t\t    (match_test \"(INTVAL (operands[2]) & (CALL_V4_SET_FP_ARGS | CALL_V4_CLEAR_FP_ARGS))\"))\n+\t\t  (const_string \"12\")\n+\t       (ior (and (match_test \"!rs6000_speculate_indirect_jumps\")\n+\t\t\t (match_test \"which_alternative != 1\"))\n+\t\t   (match_test \"(INTVAL (operands[2]) & (CALL_V4_SET_FP_ARGS | CALL_V4_CLEAR_FP_ARGS))\"))\n+\t\t  (const_string \"8\")]\n+\t      (const_string \"4\")))])\n+\n (define_insn \"*sibcall_nonlocal_sysv<mode>\"\n-  [(call (mem:SI (match_operand:P 0 \"call_operand\" \"s,s,c,c\"))\n-\t (match_operand 1 \"\" \"\"))\n-   (use (match_operand 2 \"immediate_operand\" \"O,n,O,n\"))\n+  [(call (mem:SI (match_operand:P 0 \"symbol_ref_operand\" \"s,s\"))\n+\t (match_operand 1))\n+   (use (match_operand 2 \"immediate_operand\" \"O,n\"))\n    (simple_return)]\n   \"(DEFAULT_ABI == ABI_DARWIN\n     || DEFAULT_ABI == ABI_V4)\n@@ -10813,29 +10903,45 @@\n   else if (INTVAL (operands[2]) & CALL_V4_CLEAR_FP_ARGS)\n     output_asm_insn (\"creqv 6,6,6\", operands);\n \n-  if (which_alternative >= 2)\n-    return rs6000_indirect_sibcall_template (operands, 0);\n-  else\n-    return rs6000_sibcall_template (operands, 0);\n+  return rs6000_sibcall_template (operands, 0);\n }\n   [(set_attr \"type\" \"branch\")\n-   (set_attr_alternative \"length\"\n-     [(const_string \"4\")\n-      (const_string \"8\")\n-      (if_then_else (eq (symbol_ref \"rs6000_speculate_indirect_jumps\")\n-\t\t\t(const_int 0))\n-\t\t    (const_string \"12\")\n-\t\t    (const_string \"4\"))\n-      (if_then_else (eq (symbol_ref \"rs6000_speculate_indirect_jumps\")\n-\t\t\t(const_int 0))\n-\t\t    (const_string \"16\")\n-\t\t    (const_string \"8\"))])])\n+   (set_attr \"length\" \"4,8\")])\n+\n+(define_insn \"*sibcall_value_indirect_nonlocal_sysv<mode>\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:SI (match_operand:P 1 \"indirect_call_operand\" \"c,*l,X\"))\n+\t      (match_operand 2)))\n+   (use (match_operand:SI 3 \"immediate_operand\" \"n,n,n\"))\n+   (simple_return)]\n+  \"DEFAULT_ABI == ABI_V4\n+   || DEFAULT_ABI == ABI_DARWIN\"\n+{\n+  if (INTVAL (operands[3]) & CALL_V4_SET_FP_ARGS)\n+    output_asm_insn (\"crxor 6,6,6\", operands);\n+\n+  else if (INTVAL (operands[3]) & CALL_V4_CLEAR_FP_ARGS)\n+    output_asm_insn (\"creqv 6,6,6\", operands);\n+\n+  return rs6000_indirect_sibcall_template (operands, 1);\n+}\n+  [(set_attr \"type\" \"jmpreg\")\n+   (set (attr \"length\")\n+\t(cond [(and (and (match_test \"!rs6000_speculate_indirect_jumps\")\n+\t\t\t (match_test \"which_alternative != 1\"))\n+\t\t    (match_test \"(INTVAL (operands[3]) & (CALL_V4_SET_FP_ARGS | CALL_V4_CLEAR_FP_ARGS))\"))\n+\t\t  (const_string \"12\")\n+\t       (ior (and (match_test \"!rs6000_speculate_indirect_jumps\")\n+\t\t\t (match_test \"which_alternative != 1\"))\n+\t\t   (match_test \"(INTVAL (operands[3]) & (CALL_V4_SET_FP_ARGS | CALL_V4_CLEAR_FP_ARGS))\"))\n+\t\t  (const_string \"8\")]\n+\t      (const_string \"4\")))])\n \n (define_insn \"*sibcall_value_nonlocal_sysv<mode>\"\n   [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:SI (match_operand:P 1 \"call_operand\" \"s,s,c,c\"))\n-\t      (match_operand 2 \"\" \"\")))\n-   (use (match_operand:SI 3 \"immediate_operand\" \"O,n,O,n\"))\n+\t(call (mem:SI (match_operand:P 1 \"symbol_ref_operand\" \"s,s\"))\n+\t      (match_operand 2)))\n+   (use (match_operand:SI 3 \"immediate_operand\" \"O,n\"))\n    (simple_return)]\n   \"(DEFAULT_ABI == ABI_DARWIN\n     || DEFAULT_ABI == ABI_V4)\n@@ -10847,29 +10953,10 @@\n   else if (INTVAL (operands[3]) & CALL_V4_CLEAR_FP_ARGS)\n     output_asm_insn (\"creqv 6,6,6\", operands);\n \n-  if (which_alternative >= 2)\n-    {\n-      if (rs6000_speculate_indirect_jumps)\n-\treturn \"b%T1\";\n-      else\n-\t/* Can use CR0 since it is volatile across sibcalls.  */\n-\treturn \"crset 2\\;beq%T1-\\;b $\";\n-    }\n-  else\n-    return rs6000_sibcall_template (operands, 1);\n+  return rs6000_sibcall_template (operands, 1);\n }\n   [(set_attr \"type\" \"branch\")\n-   (set_attr_alternative \"length\"\n-     [(const_string \"4\")\n-      (const_string \"8\")\n-      (if_then_else (eq (symbol_ref \"rs6000_speculate_indirect_jumps\")\n-\t\t\t(const_int 0))\n-\t\t    (const_string \"12\")\n-\t\t    (const_string \"4\"))\n-      (if_then_else (eq (symbol_ref \"rs6000_speculate_indirect_jumps\")\n-\t\t\t(const_int 0))\n-\t\t    (const_string \"16\")\n-\t\t    (const_string \"8\"))])])\n+   (set_attr \"length\" \"4,8\")])\n \n ;; AIX ABI sibling call patterns.\n "}, {"sha": "bdaa6fa0c3e2c409312a3038deb33548fa1274de", "filename": "gcc/configure", "status": "modified", "additions": 42, "deletions": 6, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f79c0ad268bc64d0cc231ba6d51098983bdb67b/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f79c0ad268bc64d0cc231ba6d51098983bdb67b/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=3f79c0ad268bc64d0cc231ba6d51098983bdb67b", "patch": "@@ -24393,12 +24393,12 @@ foo:\t.long\t25\n \t;;\n   or1k*-*-*)\n     conftest_s='\n-        .section \".tdata\",\"awT\",@progbits\n-foo:    .long   25\n-        .text\n-        l.movhi r3, tpoffha(foo)\n-        l.add   r3, r3, r10\n-        l.lwz   r4, tpofflo(foo)(r3)'\n+\t.section \".tdata\",\"awT\",@progbits\n+foo:\t.long\t25\n+\t.text\n+\tl.movhi\tr3, tpoffha(foo)\n+\tl.add\tr3, r3, r10\n+\tl.lwz\tr4, tpofflo(foo)(r3)'\n     tls_first_major=2\n     tls_first_minor=30\n     tls_as_opt=--fatal-warnings\n@@ -26939,6 +26939,42 @@ if test $gcc_cv_as_powerpc_entry_markers = yes; then\n \n $as_echo \"#define HAVE_AS_ENTRY_MARKERS 1\" >>confdefs.h\n \n+fi\n+\n+\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking assembler for plt sequence marker support\" >&5\n+$as_echo_n \"checking assembler for plt sequence marker support... \" >&6; }\n+if ${gcc_cv_as_powerpc_pltseq_markers+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  gcc_cv_as_powerpc_pltseq_markers=no\n+    if test $in_tree_gas = yes; then\n+    if test $gcc_cv_gas_vers -ge `expr \\( \\( 2 \\* 1000 \\) + 31 \\) \\* 1000 + 0`\n+  then gcc_cv_as_powerpc_pltseq_markers=yes\n+fi\n+  elif test x$gcc_cv_as != x; then\n+    $as_echo ' .reloc .,R_PPC_PLTSEQ; nop' > conftest.s\n+    if { ac_try='$gcc_cv_as $gcc_cv_as_flags -a32 --fatal-warnings -o conftest.o conftest.s >&5'\n+  { { eval echo \"\\\"\\$as_me\\\":${as_lineno-$LINENO}: \\\"$ac_try\\\"\"; } >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  $as_echo \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n+  test $ac_status = 0; }; }\n+    then\n+\tgcc_cv_as_powerpc_pltseq_markers=yes\n+    else\n+      echo \"configure: failed program was\" >&5\n+      cat conftest.s >&5\n+    fi\n+    rm -f conftest.o conftest.s\n+  fi\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $gcc_cv_as_powerpc_pltseq_markers\" >&5\n+$as_echo \"$gcc_cv_as_powerpc_pltseq_markers\" >&6; }\n+if test $gcc_cv_as_powerpc_pltseq_markers = yes; then\n+\n+$as_echo \"#define HAVE_AS_PLTSEQ 1\" >>confdefs.h\n+\n fi\n \n "}, {"sha": "2673f80af96bdab7513f8faf1e7d7e014c404ff3", "filename": "gcc/configure.ac", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f79c0ad268bc64d0cc231ba6d51098983bdb67b/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f79c0ad268bc64d0cc231ba6d51098983bdb67b/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=3f79c0ad268bc64d0cc231ba6d51098983bdb67b", "patch": "@@ -4648,6 +4648,12 @@ LCF0:\n       [AC_DEFINE(HAVE_AS_ENTRY_MARKERS, 1,\n \t  [Define if your assembler supports the R_PPC64_ENTRY relocation.])])\n \n+    gcc_GAS_CHECK_FEATURE([plt sequence marker support],\n+      gcc_cv_as_powerpc_pltseq_markers, [2,31,0],-a32 --fatal-warnings,\n+      [ .reloc .,R_PPC_PLTSEQ; nop],,\n+      [AC_DEFINE(HAVE_AS_PLTSEQ, 1,\n+\t  [Define if your assembler supports R_PPC*_PLTSEQ relocations.])])\n+\n     case $target in\n       *-*-aix*)\n \tgcc_GAS_CHECK_FEATURE([AIX .ref support],"}]}