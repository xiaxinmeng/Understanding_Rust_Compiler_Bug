{"sha": "55310dadb016d935b602a60d0467d96e960c7b03", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTUzMTBkYWRiMDE2ZDkzNWI2MDJhNjBkMDQ2N2Q5NmU5NjBjN2IwMw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-04-09T01:44:57Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-04-09T01:44:57Z"}, "message": "Include hard-reg-set.h.\n\n(reg_nonzero_bits): Should be unsigned.\n(reg_last_set_{mode,nonzero_bits,sign_bit_copies}): New variables.\n(combine_instructions): Allocate and initialized them.\n(nonzero_bits, num_sign_bit_copies, case REG): Use new variables to get\ninformation on regs we've seen before.\n(record_value_for_reg): Set new variables for register being modified.\n(record_dead_and_set_regs): Invalidate regs clobbered by CALL_INSN.\n\nFrom-SVN: r4051", "tree": {"sha": "ba60657bad0b0e40330291c171cb450323055fa6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba60657bad0b0e40330291c171cb450323055fa6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/55310dadb016d935b602a60d0467d96e960c7b03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55310dadb016d935b602a60d0467d96e960c7b03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55310dadb016d935b602a60d0467d96e960c7b03", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55310dadb016d935b602a60d0467d96e960c7b03/comments", "author": null, "committer": null, "parents": [{"sha": "f67850266f1c06c34c97b42d011a47a0920d5e3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f67850266f1c06c34c97b42d011a47a0920d5e3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f67850266f1c06c34c97b42d011a47a0920d5e3c"}], "stats": {"total": 78, "additions": 67, "deletions": 11}, "files": [{"sha": "9a55261ee9d705621ddae5b52a2b4cf1291e0282", "filename": "gcc/combine.c", "status": "modified", "additions": 67, "deletions": 11, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55310dadb016d935b602a60d0467d96e960c7b03/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55310dadb016d935b602a60d0467d96e960c7b03/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=55310dadb016d935b602a60d0467d96e960c7b03", "patch": "@@ -78,6 +78,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"rtl.h\"\n #include \"flags.h\"\n #include \"regs.h\"\n+#include \"hard-reg-set.h\"\n #include \"expr.h\"\n #include \"basic-block.h\"\n #include \"insn-config.h\"\n@@ -262,7 +263,7 @@ static short label_tick;\n \n    If an entry is zero, it means that we don't know anything special.  */\n \n-static HOST_WIDE_INT *reg_nonzero_bits;\n+static unsigned HOST_WIDE_INT *reg_nonzero_bits;\n \n /* Mode used to compute significance in reg_nonzero_bits.  It is the largest\n    integer mode that can fit in HOST_BITS_PER_WIDE_INT.  */\n@@ -280,6 +281,15 @@ static char *reg_sign_bit_copies;\n    which can be incorrect if a variable is modified in a loop.  */\n \n static int nonzero_sign_valid;\n+\n+/* These arrays are maintained in parallel with reg_last_set_value\n+   and are used to store the mode in which the register was last set,\n+   the bits that were known to be zero when it was last set, and the\n+   number of sign bits copies it was known to have when it was last set.  */\n+\n+static enum machine_mode *reg_last_set_mode;\n+static unsigned HOST_WIDE_INT *reg_last_set_nonzero_bits;\n+static char *reg_last_set_sign_bit_copies;\n \f\n /* Record one modification to rtl structure\n    to be undone by storing old_contents into *where.\n@@ -417,7 +427,15 @@ combine_instructions (f, nregs)\n   reg_last_set_table_tick = (short *) alloca (nregs * sizeof (short));\n   reg_last_set_label = (short *) alloca (nregs * sizeof (short));\n   reg_last_set_invalid = (char *) alloca (nregs * sizeof (char));\n-  reg_nonzero_bits = (HOST_WIDE_INT *) alloca (nregs * sizeof (HOST_WIDE_INT));\n+  reg_last_set_mode\n+    = (enum machine_mode *) alloca (nregs * sizeof (enum machine_mode));\n+  reg_last_set_nonzero_bits\n+    = (unsigned HOST_WIDE_INT *) alloca (nregs * sizeof (HOST_WIDE_INT));\n+  reg_last_set_sign_bit_copies\n+    = (char *) alloca (nregs * sizeof (char));\n+\n+  reg_nonzero_bits\n+    = (unsigned HOST_WIDE_INT *) alloca (nregs * sizeof (HOST_WIDE_INT));\n   reg_sign_bit_copies = (char *) alloca (nregs * sizeof (char));\n \n   bzero (reg_last_death, nregs * sizeof (rtx));\n@@ -426,6 +444,9 @@ combine_instructions (f, nregs)\n   bzero (reg_last_set_table_tick, nregs * sizeof (short));\n   bzero (reg_last_set_label, nregs * sizeof (short));\n   bzero (reg_last_set_invalid, nregs * sizeof (char));\n+  bzero (reg_last_set_mode, nregs * sizeof (enum machine_mode));\n+  bzero (reg_last_set_nonzero_bits, nregs * sizeof (HOST_WIDE_INT));\n+  bzero (reg_last_set_sign_bit_copies, nregs * sizeof (char));\n   bzero (reg_nonzero_bits, nregs * sizeof (HOST_WIDE_INT));\n   bzero (reg_sign_bit_copies, nregs * sizeof (char));\n \n@@ -6144,9 +6165,17 @@ nonzero_bits (x, mode)\n \t}\n #endif\n \n-      /* If X is a register whose value we can find, use that value.  \n-\t Otherwise, use the previously-computed nonzero bits for this\n-\t register.  */\n+      /* If X is a register whose nonzero bits value is current, use it.\n+\t Otherwise, if X is a register whose value we can find, use that\n+\t value.  Otherwise, use the previously-computed global nonzero bits\n+\t for this register.  */\n+\n+      if (reg_last_set_value[REGNO (x)] != 0\n+\t  && reg_last_set_mode[REGNO (x)] == mode\n+\t  && (reg_n_sets[REGNO (x)] == 1\n+\t      || reg_last_set_label[REGNO (x)] == label_tick)\n+\t  && INSN_CUID (reg_last_set[REGNO (x)]) < subst_low_cuid)\n+\treturn reg_last_set_nonzero_bits[REGNO (x)];\n \n       tem = get_last_value (x);\n       if (tem)\n@@ -6425,12 +6454,20 @@ num_sign_bit_copies (x, mode)\n   switch (code)\n     {\n     case REG:\n-      if (nonzero_sign_valid && reg_sign_bit_copies[REGNO (x)] != 0)\n-\treturn reg_sign_bit_copies[REGNO (x)];\n+\n+      if (reg_last_set_value[REGNO (x)] != 0\n+\t  && reg_last_set_mode[REGNO (x)] == mode\n+\t  && (reg_n_sets[REGNO (x)] == 1\n+\t      || reg_last_set_label[REGNO (x)] == label_tick)\n+\t  && INSN_CUID (reg_last_set[REGNO (x)]) < subst_low_cuid)\n+\treturn reg_last_set_sign_bit_copies[REGNO (x)];\n \n       tem =  get_last_value (x);\n       if (tem != 0)\n \treturn num_sign_bit_copies (tem, mode);\n+\n+      if (nonzero_sign_valid && reg_sign_bit_copies[REGNO (x)] != 0)\n+\treturn reg_sign_bit_copies[REGNO (x)];\n       break;\n \n #ifdef BYTE_LOADS_SIGN_EXTEND\n@@ -8856,9 +8893,18 @@ record_value_for_reg (reg, insn, value)\n \tvalue = 0;\n     }\n \n-  /* For the main register being modified, update the value.  */\n+  /* For the main register being modified, update the value, the mode, the\n+     nonzero bits, and the number of sign bit copies.  */\n+\n   reg_last_set_value[regno] = value;\n \n+  if (value)\n+    {\n+      reg_last_set_mode[regno] = GET_MODE (reg);\n+      reg_last_set_nonzero_bits[regno] = nonzero_bits (value, GET_MODE (reg));\n+      reg_last_set_sign_bit_copies[regno]\n+\t= num_sign_bit_copies (value, GET_MODE (reg));\n+    }\n }\n \n /* Used for communication between the following two routines.  */\n@@ -8907,6 +8953,8 @@ record_dead_and_set_regs (insn)\n      rtx insn;\n {\n   register rtx link;\n+  int i;\n+\n   for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n     {\n       if (REG_NOTE_KIND (link) == REG_DEAD\n@@ -8917,7 +8965,6 @@ record_dead_and_set_regs (insn)\n \t    = regno + (regno < FIRST_PSEUDO_REGISTER\n \t\t       ? HARD_REGNO_NREGS (regno, GET_MODE (XEXP (link, 0)))\n \t\t       : 1);\n-\t  int i;\n \n \t  for (i = regno; i < endregno; i++)\n \t    reg_last_death[i] = insn;\n@@ -8927,7 +8974,16 @@ record_dead_and_set_regs (insn)\n     }\n \n   if (GET_CODE (insn) == CALL_INSN)\n-    last_call_cuid = mem_last_set = INSN_CUID (insn);\n+    {\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\tif (call_used_regs[i])\n+\t  {\n+\t    reg_last_set_value[i] = 0;\n+\t    reg_last_death[i] = 0;\n+\t  }\n+\n+      last_call_cuid = mem_last_set = INSN_CUID (insn);\n+    }\n \n   record_dead_insn = insn;\n   note_stores (PATTERN (insn), record_dead_and_set_regs_1);\n@@ -9018,7 +9074,7 @@ get_last_value (x)\n \n   if (value == 0\n       || (reg_n_sets[regno] != 1\n-\t  && (reg_last_set_label[regno] != label_tick)))\n+\t  && reg_last_set_label[regno] != label_tick))\n     return 0;\n \n   /* If the value was set in a later insn that the ones we are processing,"}]}