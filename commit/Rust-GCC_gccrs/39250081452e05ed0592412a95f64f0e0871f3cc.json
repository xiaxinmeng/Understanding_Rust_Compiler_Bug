{"sha": "39250081452e05ed0592412a95f64f0e0871f3cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzkyNTAwODE0NTJlMDVlZDA1OTI0MTJhOTVmNjRmMGUwODcxZjNjYw==", "commit": {"author": {"name": "Roman Zippel", "email": "zippel@linux-m68k.org", "date": "2007-09-24T21:02:40Z"}, "committer": {"name": "Roman Zippel", "email": "zippel@gcc.gnu.org", "date": "2007-09-24T21:02:40Z"}, "message": "m68k.c (strict_low_part_peephole_ok): Don't leave the basic block.\n\n\t* config/m68k/m68k.c (strict_low_part_peephole_ok): Don't leave\n\tthe basic block.\n\t* config/m68k/m68k.md (movsi_m68k): Allow certain constant when\n\treload is completed.\n\t(peephole pattern): Convert most of them to RTL peephole pattern.\n\nFrom-SVN: r128728", "tree": {"sha": "bb0715021a467ec3691e4534d9d196e652e89fd5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb0715021a467ec3691e4534d9d196e652e89fd5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39250081452e05ed0592412a95f64f0e0871f3cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39250081452e05ed0592412a95f64f0e0871f3cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39250081452e05ed0592412a95f64f0e0871f3cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39250081452e05ed0592412a95f64f0e0871f3cc/comments", "author": null, "committer": null, "parents": [{"sha": "67595cbb21ce2cd419dcc390e811e4cdb2ef25af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67595cbb21ce2cd419dcc390e811e4cdb2ef25af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67595cbb21ce2cd419dcc390e811e4cdb2ef25af"}], "stats": {"total": 315, "additions": 172, "deletions": 143}, "files": [{"sha": "100a62cbdb2f891c53cdc3a9cc0c57ae94473b63", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39250081452e05ed0592412a95f64f0e0871f3cc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39250081452e05ed0592412a95f64f0e0871f3cc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=39250081452e05ed0592412a95f64f0e0871f3cc", "patch": "@@ -1,3 +1,11 @@\n+2007-09-24  Roman Zippel <zippel@linux-m68k.org> \n+ \n+\t* config/m68k/m68k.c (strict_low_part_peephole_ok): Don't leave\n+\tthe basic block.\n+\t* config/m68k/m68k.md (movsi_m68k): Allow certain constant when\n+\treload is completed.\n+\t(peephole pattern): Convert most of them to RTL peephole pattern.\n+\n 2007-09-24  Roman Zippel <zippel@linux-m68k.org> \n \n \t* config/m68k/m68k.c (notice_update_cc): Recognize fp compare"}, {"sha": "1df869fdf40eda13c6defd70e27b055607ea203f", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39250081452e05ed0592412a95f64f0e0871f3cc/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39250081452e05ed0592412a95f64f0e0871f3cc/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=39250081452e05ed0592412a95f64f0e0871f3cc", "patch": "@@ -3963,14 +3963,18 @@ bool\n strict_low_part_peephole_ok (enum machine_mode mode, rtx first_insn,\n                              rtx target)\n {\n-  rtx p;\n+  rtx p = first_insn;\n \n-  p = prev_nonnote_insn (first_insn);\n-\n-  while (p)\n+  while ((p = PREV_INSN (p)))\n     {\n+      if (NOTE_INSN_BASIC_BLOCK_P (p))\n+\treturn false;\n+\n+      if (NOTE_P (p))\n+\tcontinue;\n+\n       /* If it isn't an insn, then give up.  */\n-      if (GET_CODE (p) != INSN)\n+      if (!INSN_P (p))\n \treturn false;\n \n       if (reg_set_p (target, p))\n@@ -4000,8 +4004,6 @@ strict_low_part_peephole_ok (enum machine_mode mode, rtx first_insn,\n \t  else\n \t    return false;\n \t}\n-\n-      p = prev_nonnote_insn (p);\n     }\n \n   return false;"}, {"sha": "68053b33b707c3ac266ea06f282fe9a978ccba60", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 155, "deletions": 136, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39250081452e05ed0592412a95f64f0e0871f3cc/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39250081452e05ed0592412a95f64f0e0871f3cc/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=39250081452e05ed0592412a95f64f0e0871f3cc", "patch": "@@ -900,12 +900,21 @@\n     }\n })\n \n-;; General case of fullword move.  The register constraints\n-;; force integer constants in range for a moveq to be reloaded\n-;; if they are headed for memory.\n-(define_insn \"\"\n+;; General case of fullword move.\n+(define_insn \"*movsi_m68k\"\n   ;; Notes: make sure no alternative allows g vs g.\n   ;; We don't allow f-regs since fixed point cannot go in them.\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g,d,a<\")\n+        (match_operand:SI 1 \"general_src_operand\" \"damSnT,n,i\"))]\n+  \"!TARGET_COLDFIRE && reload_completed\"\n+{\n+  return output_move_simode (operands);\n+})\n+\n+;; Before reload is completed the register constraints\n+;; force integer constants in range for a moveq to be reloaded\n+;; if they are headed for memory.\n+(define_insn \"*movsi_m68k2\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g,d,a<\")\n         (match_operand:SI 1 \"general_src_operand\" \"damSKT,n,i\"))]\n \n@@ -7292,153 +7301,163 @@\n ;; and then is moved into an FP register.\n ;; But it is mainly intended to test the support for these optimizations.\n \n-(define_peephole\n+(define_peephole2\n   [(set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (const_int 4)))\n-   (set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(match_operand:DF 1 \"register_operand\" \"ad\"))]\n-  \"FP_REG_P (operands[0]) && ! FP_REG_P (operands[1])\"\n-{\n-  rtx xoperands[2];\n-  xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n-  output_asm_insn (\"move%.l %1,%@\", xoperands);\n-  output_asm_insn (\"move%.l %1,%-\", operands);\n-  return \"fmove%.d %+,%0\";\n-})\n+   (set (match_operand:DF 0 \"register_operand\" \"\")\n+\t(match_operand:DF 1 \"register_operand\" \"\"))]\n+  \"FP_REG_P (operands[0]) && !FP_REG_P (operands[1])\"\n+  [(set (mem:SI (reg:SI SP_REG)) (match_dup 1))\n+   (set (mem:SI (pre_dec:SI (reg:SI SP_REG))) (match_dup 2))\n+   (set (match_dup 0) (mem:DF (post_inc:SI (reg:SI SP_REG))))]\n+  \"split_di(operands + 1, 1, operands + 1, operands + 2);\")\n \n ;; Optimize a stack-adjust followed by a push of an argument.\n ;; This is said to happen frequently with -msoft-float\n ;; when there are consecutive library calls.\n \n-(define_peephole\n+(define_peephole2\n+  [(set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (const_int 4)))\n+   (set (match_operand:SF 0 \"push_operand\" \"\")\n+\t(match_operand:SF 1 \"general_operand\" \"\"))]\n+  \"!reg_mentioned_p (stack_pointer_rtx, operands[0])\"\n+  [(set (match_dup 0) (match_dup 1))]\n+  \"operands[0] = replace_equiv_address (operands[0], stack_pointer_rtx);\")\n+\n+(define_peephole2\n   [(set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG)\n-\t\t\t\t (match_operand:SI 0 \"const_int_operand\" \"n\")))\n-   (set (match_operand:SF 1 \"push_operand\" \"=m\")\n-\t(match_operand:SF 2 \"general_operand\" \"rmfF\"))]\n-  \"INTVAL (operands[0]) >= 4\n-   && ! reg_mentioned_p (stack_pointer_rtx, operands[2])\"\n+\t\t\t\t (match_operand:SI 0 \"const_int_operand\" \"\")))\n+   (set (match_operand:SF 1 \"push_operand\" \"\")\n+\t(match_operand:SF 2 \"general_operand\" \"\"))]\n+  \"INTVAL (operands[0]) > 4\n+   && !reg_mentioned_p (stack_pointer_rtx, operands[2])\"\n+  [(set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (match_dup 0)))\n+   (set (match_dup 1) (match_dup 2))]\n {\n-  if (INTVAL (operands[0]) > 4)\n-    {\n-      rtx xoperands[2];\n-      xoperands[0] = stack_pointer_rtx;\n-      xoperands[1] = GEN_INT (INTVAL (operands[0]) - 4);\n-      if (INTVAL (xoperands[1]) <= 8)\n-\t{\n-\t  if (!TARGET_COLDFIRE)\n-\t    output_asm_insn (\"addq%.w %1,%0\", xoperands);\n-\t  else\n-\t    output_asm_insn (\"addq%.l %1,%0\", xoperands);\n-\t}\n-      else if (TUNE_CPU32 && INTVAL (xoperands[1]) <= 16)\n-\t{\n-\t  xoperands[1] = GEN_INT (INTVAL (xoperands[1]) - 8);\n-\t  output_asm_insn (\"addq%.w #8,%0\\;addq%.w %1,%0\", xoperands);\n-\t}\n-      else if (INTVAL (xoperands[1]) <= 0x7FFF)\n-        {\n-\t  if (TUNE_68040)\n-\t    output_asm_insn (\"add%.w %1,%0\", xoperands);\n-\t  else if (MOTOROLA)\n-\t    output_asm_insn (\"lea (%c1,%0),%0\", xoperands);\n-\t  else\n-\t    output_asm_insn (\"lea %0@(%c1),%0\", xoperands);\n-        }\n-      else\n-        output_asm_insn (\"add%.l %1,%0\", xoperands);\n-    }\n-  if (FP_REG_P (operands[2]))\n-    return \"fmove%.s %2,%@\";\n-  return \"move%.l %2,%@\";\n+  operands[0] = GEN_INT (INTVAL (operands[0]) - 4);\n+  operands[1] = replace_equiv_address (operands[1], stack_pointer_rtx);\n })\n \n ;; Speed up stack adjust followed by a fullword fixedpoint push.\n+;; Constant operands need special care, as replacing a \"pea X.w\" with\n+;; \"move.l #X,(%sp)\" is often not a win.\n \n-(define_peephole\n+;; Already done by the previous csa pass, left as reference.\n+(define_peephole2\n+  [(set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (const_int 4)))\n+   (set (match_operand:SI 0 \"push_operand\" \"\")\n+\t(match_operand:SI 1 \"general_operand\" \"\"))]\n+  \"!reg_mentioned_p (stack_pointer_rtx, operands[1])\"\n+  [(set (match_dup 0) (match_dup 1))]\n+  \"operands[0] = replace_equiv_address (operands[0], stack_pointer_rtx);\")\n+\n+;; Try to use moveq, after stack push has been changed into a simple move.\n+(define_peephole2\n+  [(match_scratch:SI 2 \"d\")\n+   (set (match_operand:SI 0 \"memory_operand\" \"\")\n+\t(match_operand:SI 1 \"const_int_operand\" \"\"))]\n+  \"GET_CODE (XEXP (operands[0], 0)) != PRE_DEC\n+   && INTVAL (operands[1]) != 0\n+   && IN_RANGE (INTVAL (operands[1]), -0x80, 0x7f)\n+   && !valid_mov3q_const (INTVAL (operands[1]))\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (set (match_dup 0) (match_dup 2))])\n+\n+;; This sequence adds an instruction, but is two bytes shorter.\n+(define_peephole2\n+  [(match_scratch:SI 2 \"d\")\n+   (set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (const_int 12)))\n+   (set (match_operand:SI 0 \"push_operand\" \"\")\n+\t(match_operand:SI 1 \"const_int_operand\" \"\"))]\n+  \"INTVAL (operands[1]) != 0\n+   && IN_RANGE (INTVAL (operands[1]), -0x80, 0x7f)\n+   && !valid_mov3q_const (INTVAL (operands[1]))\"\n+  [(set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (const_int 8)))\n+   (set (match_dup 2) (match_dup 1))\n+   (set (match_dup 0) (match_dup 2))]\n+  \"operands[0] = replace_equiv_address (operands[0], stack_pointer_rtx);\")\n+\n+;; Changing pea X.w into a move.l is no real win here.\n+(define_peephole2\n   [(set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG)\n-\t\t\t\t (match_operand:SI 0 \"const_int_operand\" \"n\")))\n-   (set (match_operand:SI 1 \"push_operand\" \"=m\")\n-\t(match_operand:SI 2 \"general_operand\" \"g\"))]\n-  \"INTVAL (operands[0]) >= 4\n-   && ! reg_mentioned_p (stack_pointer_rtx, operands[2])\"\n-{\n-  if (INTVAL (operands[0]) > 4)\n-    {\n-      rtx xoperands[2];\n-      xoperands[0] = stack_pointer_rtx;\n-      xoperands[1] = GEN_INT (INTVAL (operands[0]) - 4);\n-      if (INTVAL (xoperands[1]) <= 8)\n-\t{\n-\t  if (!TARGET_COLDFIRE)\n-\t    output_asm_insn (\"addq%.w %1,%0\", xoperands);\n-\t  else\n-\t    output_asm_insn (\"addq%.l %1,%0\", xoperands);\n-\t}\n-      else if (TUNE_CPU32 && INTVAL (xoperands[1]) <= 16)\n-\t{\n-\t  xoperands[1] = GEN_INT (INTVAL (xoperands[1]) - 8);\n-\t  output_asm_insn (\"addq%.w #8,%0\\;addq%.w %1,%0\", xoperands);\n-\t}\n-      else if (INTVAL (xoperands[1]) <= 0x7FFF)\n-        {\n-\t  if (TUNE_68040)\n-\t    output_asm_insn (\"add%.w %1,%0\", xoperands);\n-\t  else if (MOTOROLA)\n-\t    output_asm_insn (\"lea (%c1,%0),%0\", xoperands);\n-\t  else\n-\t    output_asm_insn (\"lea %0@(%c1),%0\", xoperands);\n-        }\n-      else\n-        output_asm_insn (\"add%.l %1,%0\", xoperands);\n-    }\n-  if (operands[2] == const0_rtx)\n-    return \"clr%.l %@\";\n-  return \"move%.l %2,%@\";\n-})\n-\n-;; Speed up pushing a single byte but leaving four bytes of space.\n-\n-(define_peephole\n-  [(set (mem:QI (pre_dec:SI (reg:SI SP_REG)))\n-\t(match_operand:QI 1 \"general_operand\" \"dami\"))\n-   (set (reg:SI SP_REG) (minus:SI (reg:SI SP_REG) (const_int 2)))]\n-  \"! reg_mentioned_p (stack_pointer_rtx, operands[1])\"\n-{\n-  rtx xoperands[4];\n-\n-  if (GET_CODE (operands[1]) == REG)\n-    return \"move%.l %1,%-\";\n-\n-  xoperands[1] = operands[1];\n-  xoperands[2]\n-    = gen_rtx_MEM (QImode, plus_constant (stack_pointer_rtx, 3));\n-  xoperands[3] = stack_pointer_rtx;\n-  if (!TARGET_COLDFIRE)\n-    output_asm_insn (\"subq%.w #4,%3\\;move%.b %1,%2\", xoperands);\n-  else\n-    output_asm_insn (\"subq%.l #4,%3\\;move%.b %1,%2\", xoperands);\n-  return \"\";\n-})\n+\t\t\t\t (match_operand:SI 0 \"const_int_operand\" \"\")))\n+   (set (match_operand:SI 1 \"push_operand\" \"\")\n+\t(match_operand:SI 2 \"general_operand\" \"\"))]\n+  \"INTVAL (operands[0]) > 4\n+   && !reg_mentioned_p (stack_pointer_rtx, operands[2])\n+   && !(CONST_INT_P (operands[2]) && INTVAL (operands[2]) != 0\n+\t&& IN_RANGE (INTVAL (operands[2]), -0x8000, 0x7fff)\n+\t&& !valid_mov3q_const (INTVAL (operands[2])))\"\n+  [(set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (match_dup 0)))\n+   (set (match_dup 1) (match_dup 2))]\n+{\n+  operands[0] = GEN_INT (INTVAL (operands[0]) - 4);\n+  operands[1] = replace_equiv_address (operands[1], stack_pointer_rtx);\n+})\n+\n+;; Speed up pushing a single byte/two bytes but leaving four bytes of space\n+;; (which differs slightly between m680x0 and ColdFire).\n+\n+(define_peephole2\n+  [(set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (const_int -4)))\n+   (set (match_operand:QI 0 \"memory_operand\" \"\")\n+\t(match_operand:QI 1 \"register_operand\" \"\"))]\n+  \"!reg_mentioned_p (stack_pointer_rtx, operands[1])\n+   && GET_CODE (XEXP (operands[0], 0)) == PLUS\n+   && rtx_equal_p (XEXP (XEXP (operands[0], 0), 0), stack_pointer_rtx)\n+   && CONST_INT_P (XEXP (XEXP (operands[0], 0), 1))\n+   && INTVAL (XEXP (XEXP (operands[0], 0), 1)) == 3\"\n+  [(set (match_dup 0) (match_dup 1))]\n+{\n+  rtx addr = gen_rtx_PRE_DEC (Pmode, stack_pointer_rtx);\n+  operands[0] = adjust_automodify_address (operands[0], SImode, addr, -3);\n+  operands[1] = simplify_gen_subreg (SImode, operands[1], QImode, 0);\n+})\n+\n+(define_peephole2\n+  [(set (match_operand:QI 0 \"push_operand\" \"\")\n+\t(match_operand:QI 1 \"register_operand\" \"\"))\n+   (set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (const_int -3)))]\n+  \"!reg_mentioned_p (stack_pointer_rtx, operands[1])\"\n+  [(set (match_dup 0) (match_dup 1))]\n+{\n+  operands[0] = adjust_automodify_address (operands[0], SImode,\n+\t\t\t\t\t   XEXP (operands[0], 0), -3);\n+  operands[1] = simplify_gen_subreg (SImode, operands[1], QImode, 0);\n+})\n+\n+(define_peephole2\n+  [(set (match_operand:HI 0 \"push_operand\" \"\")\n+\t(match_operand:HI 1 \"register_operand\" \"\"))\n+   (set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (const_int -2)))]\n+  \"!reg_mentioned_p (stack_pointer_rtx, operands[1])\"\n+  [(set (match_dup 0) (match_dup 1))]\n+{\n+  operands[0] = adjust_automodify_address (operands[0], SImode,\n+\t\t\t\t\t   XEXP (operands[0], 0), -2);\n+  operands[1] = simplify_gen_subreg (SImode, operands[1], HImode, 0);\n+})\n+\n+;; Optimize a series of strict_low_part assignments\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(const_int 0))\n+   (set (strict_low_part (match_operand:HI 1 \"register_operand\" \"\"))\n+\t(match_operand:HI 2 \"general_operand\" \"\"))]\n+  \"REGNO (operands[0]) == REGNO (operands[1])\n+   && strict_low_part_peephole_ok (HImode, insn, operands[0])\"\n+  [(set (strict_low_part (match_dup 1)) (match_dup 2))]\n+  \"\")\n \n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(const_int 0))\n-   (set (strict_low_part (subreg:HI (match_dup 0) 2))\n-\t(match_operand:HI 1 \"general_operand\" \"rmn\"))]\n-  \"strict_low_part_peephole_ok (HImode, prev_nonnote_insn (insn), operands[0])\"\n-{\n-  if (GET_CODE (operands[1]) == CONST_INT)\n-    {\n-      if (operands[1] == const0_rtx\n-\t  && (DATA_REG_P (operands[0])\n-\t      || GET_CODE (operands[0]) == MEM)\n-\t  /* clr insns on 68000 read before writing.  */\n-\t  && ((TARGET_68010 || TARGET_COLDFIRE)\n-\t      || !(GET_CODE (operands[0]) == MEM\n-\t\t   && MEM_VOLATILE_P (operands[0]))))\n-\treturn \"clr%.w %0\";\n-    }\n-  return \"move%.w %1,%0\";\n-})\n+   (set (strict_low_part (match_operand:QI 1 \"register_operand\" \"\"))\n+\t(match_operand:QI 2 \"general_operand\" \"\"))]\n+  \"REGNO (operands[0]) == REGNO (operands[1])\n+   && strict_low_part_peephole_ok (QImode, insn, operands[0])\"\n+  [(set (strict_low_part (match_dup 1)) (match_dup 2))]\n+  \"\")\n \n ;; dbCC peepholes\n ;;"}]}