{"sha": "67102517d54bdc14ea9075e9b75326ae41851f78", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjcxMDI1MTdkNTRiZGMxNGVhOTA3NWU5Yjc1MzI2YWU0MTg1MWY3OA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-03-25T00:34:56Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-03-25T00:34:56Z"}, "message": "alpha: Unify SF, DF, QI, HI, SI mode moves with enabled attribute.\n\nFor floating-point, this involves in addition conditionalizing the\ndefinition of the \"f\" register constraint.\n\nFrom-SVN: r171436", "tree": {"sha": "1cf532701f4bac7f6f8ed8468b34958f03337c36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1cf532701f4bac7f6f8ed8468b34958f03337c36"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67102517d54bdc14ea9075e9b75326ae41851f78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67102517d54bdc14ea9075e9b75326ae41851f78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67102517d54bdc14ea9075e9b75326ae41851f78", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67102517d54bdc14ea9075e9b75326ae41851f78/comments", "author": null, "committer": null, "parents": [{"sha": "6aba5cb489502ed9a7a73684c67d979819cedd78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6aba5cb489502ed9a7a73684c67d979819cedd78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6aba5cb489502ed9a7a73684c67d979819cedd78"}], "stats": {"total": 302, "additions": 106, "deletions": 196}, "files": [{"sha": "eaed8bf135a16d490a08460c52945b52d6001b32", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67102517d54bdc14ea9075e9b75326ae41851f78/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67102517d54bdc14ea9075e9b75326ae41851f78/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=67102517d54bdc14ea9075e9b75326ae41851f78", "patch": "@@ -1,3 +1,16 @@\n+2011-02-24  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/alpha/alpha.md (attribute isa): Add vms.\n+\t(attribute enabled): Handle it.\n+\t(*movsf): Merge *movsf_{nofix,fix,nofp}.\n+\t(*movdf): Merge *movdf_{nofix,fix,nofp}.\n+\t(*movtf): Rename from *movtf_internal for consistency.\n+\t(*movsi): Merge with *movsi_nt_vms.\n+\t(*movhi): Merge *movhi_nobwx, *movhi_bwx.\n+\t(*movqi): Merge *movqi_nobwx, *movqi_bwx.\n+\t(*mov<VEC>): Merge *mov<VEC>_fix, *mov<VEC>_nofix.\n+\t* config/alpha/constraint.md (\"f\"): Use NO_REGS when fpu is disabled.\n+\n 2011-02-24  Richard Henderson  <rth@redhat.com>\n \n \t* config/alpha/alpha.md (extendqihi2): Implement for BWX only."}, {"sha": "0f712922f59b0997fbec9d0a2ca2901a6c178c0a", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 92, "deletions": 195, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67102517d54bdc14ea9075e9b75326ae41851f78/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67102517d54bdc14ea9075e9b75326ae41851f78/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=67102517d54bdc14ea9075e9b75326ae41851f78", "patch": "@@ -179,14 +179,17 @@\n   (const_string \"false\"))\n \n ;; Used to control the \"enabled\" attribute on a per-instruction basis.\n-(define_attr \"isa\" \"base,bwx,max,fix,cix\"\n+;; For convenience, conflate ABI issues re loading of addresses with\n+;; an \"isa\".\n+(define_attr \"isa\" \"base,bwx,max,fix,cix,vms\"\n   (const_string \"base\"))\n \n (define_attr \"enabled\" \"\"\n   (cond [(eq_attr \"isa\" \"bwx\")\t(symbol_ref \"TARGET_BWX\")\n \t (eq_attr \"isa\" \"max\")\t(symbol_ref \"TARGET_MAX\")\n \t (eq_attr \"isa\" \"fix\")\t(symbol_ref \"TARGET_FIX\")\n \t (eq_attr \"isa\" \"cix\")\t(symbol_ref \"TARGET_CIX\")\n+         (eq_attr \"isa\" \"vms\")  (symbol_ref \"TARGET_ABI_OPEN_VMS\")\n \t]\n \t(const_int 1)))\n \f\n@@ -4607,27 +4610,21 @@\n ;; are done via define_expand.  Start with the floating-point insns, since\n ;; they are simpler.\n \n-(define_insn \"*movsf_nofix\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f,f,*r,*r,m,m\")\n-\t(match_operand:SF 1 \"input_operand\" \"fG,m,*rG,m,fG,*r\"))]\n-  \"TARGET_FPREGS && ! TARGET_FIX\n-   && (register_operand (operands[0], SFmode)\n-       || reg_or_0_operand (operands[1], SFmode))\"\n-  \"@\n-   cpys %R1,%R1,%0\n-   ld%, %0,%1\n-   bis $31,%r1,%0\n-   ldl %0,%1\n-   st%, %R1,%0\n-   stl %r1,%0\"\n-  [(set_attr \"type\" \"fcpys,fld,ilog,ild,fst,ist\")])\n+(define_expand \"movsf\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:SF 1 \"general_operand\" \"\"))]\n+  \"\"\n+{\n+  if (MEM_P (operands[0])\n+      && ! reg_or_0_operand (operands[1], SFmode))\n+    operands[1] = force_reg (SFmode, operands[1]);\n+})\n \n-(define_insn \"*movsf_fix\"\n+(define_insn \"*movsf\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f,f,*r,*r,m,m,f,*r\")\n \t(match_operand:SF 1 \"input_operand\" \"fG,m,*rG,m,fG,*r,*r,f\"))]\n-  \"TARGET_FPREGS && TARGET_FIX\n-   && (register_operand (operands[0], SFmode)\n-       || reg_or_0_operand (operands[1], SFmode))\"\n+  \"register_operand (operands[0], SFmode)\n+   || reg_or_0_operand (operands[1], SFmode)\"\n   \"@\n    cpys %R1,%R1,%0\n    ld%, %0,%1\n@@ -4637,41 +4634,24 @@\n    stl %r1,%0\n    itofs %1,%0\n    ftois %1,%0\"\n-  [(set_attr \"type\" \"fcpys,fld,ilog,ild,fst,ist,itof,ftoi\")])\n-\n-(define_insn \"*movsf_nofp\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r,r,m\")\n-\t(match_operand:SF 1 \"input_operand\" \"rG,m,r\"))]\n-  \"! TARGET_FPREGS\n-   && (register_operand (operands[0], SFmode)\n-       || reg_or_0_operand (operands[1], SFmode))\"\n-  \"@\n-   bis $31,%r1,%0\n-   ldl %0,%1\n-   stl %r1,%0\"\n-  [(set_attr \"type\" \"ilog,ild,ist\")])\n-\n-(define_insn \"*movdf_nofix\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,f,*r,*r,m,m\")\n-\t(match_operand:DF 1 \"input_operand\" \"fG,m,*rG,m,fG,*r\"))]\n-  \"TARGET_FPREGS && ! TARGET_FIX\n-   && (register_operand (operands[0], DFmode)\n-       || reg_or_0_operand (operands[1], DFmode))\"\n-  \"@\n-   cpys %R1,%R1,%0\n-   ld%- %0,%1\n-   bis $31,%r1,%0\n-   ldq %0,%1\n-   st%- %R1,%0\n-   stq %r1,%0\"\n-  [(set_attr \"type\" \"fcpys,fld,ilog,ild,fst,ist\")])\n+  [(set_attr \"type\" \"fcpys,fld,ilog,ild,fst,ist,itof,ftoi\")\n+   (set_attr \"isa\" \"*,*,*,*,*,*,fix,fix\")])\n \n-(define_insn \"*movdf_fix\"\n+(define_expand \"movdf\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:DF 1 \"general_operand\" \"\"))]\n+  \"\"\n+{\n+  if (MEM_P (operands[0])\n+      && ! reg_or_0_operand (operands[1], DFmode))\n+    operands[1] = force_reg (DFmode, operands[1]);\n+})\n+\n+(define_insn \"*movdf\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,f,*r,*r,m,m,f,*r\")\n \t(match_operand:DF 1 \"input_operand\" \"fG,m,*rG,m,fG,*r,*r,f\"))]\n-  \"TARGET_FPREGS && TARGET_FIX\n-   && (register_operand (operands[0], DFmode)\n-       || reg_or_0_operand (operands[1], DFmode))\"\n+  \"register_operand (operands[0], DFmode)\n+   || reg_or_0_operand (operands[1], DFmode)\"\n   \"@\n    cpys %R1,%R1,%0\n    ld%- %0,%1\n@@ -4681,24 +4661,24 @@\n    stq %r1,%0\n    itoft %1,%0\n    ftoit %1,%0\"\n-  [(set_attr \"type\" \"fcpys,fld,ilog,ild,fst,ist,itof,ftoi\")])\n-\n-(define_insn \"*movdf_nofp\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=r,r,m\")\n-\t(match_operand:DF 1 \"input_operand\" \"rG,m,r\"))]\n-  \"! TARGET_FPREGS\n-   && (register_operand (operands[0], DFmode)\n-       || reg_or_0_operand (operands[1], DFmode))\"\n-  \"@\n-   bis $31,%r1,%0\n-   ldq %0,%1\n-   stq %r1,%0\"\n-  [(set_attr \"type\" \"ilog,ild,ist\")])\n+  [(set_attr \"type\" \"fcpys,fld,ilog,ild,fst,ist,itof,ftoi\")\n+   (set_attr \"isa\" \"*,*,*,*,*,*,fix,fix\")])\n \n ;; Subregs suck for register allocation.  Pretend we can move TFmode\n ;; data between general registers until after reload.\n+;; ??? Is this still true now that we have the lower-subreg pass?\n \n-(define_insn_and_split \"*movtf_internal\"\n+(define_expand \"movtf\"\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:TF 1 \"general_operand\" \"\"))]\n+  \"\"\n+{\n+  if (MEM_P (operands[0])\n+      && ! reg_or_0_operand (operands[1], TFmode))\n+    operands[1] = force_reg (TFmode, operands[1]);\n+})\n+\n+(define_insn_and_split \"*movtf\"\n   [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=r,o\")\n \t(match_operand:TF 1 \"input_operand\" \"roG,rG\"))]\n   \"register_operand (operands[0], TFmode)\n@@ -4711,126 +4691,33 @@\n   alpha_split_tmode_pair (operands, TFmode, true); \n })\n \n-(define_expand \"movsf\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n-\t(match_operand:SF 1 \"general_operand\" \"\"))]\n-  \"\"\n-{\n-  if (MEM_P (operands[0])\n-      && ! reg_or_0_operand (operands[1], SFmode))\n-    operands[1] = force_reg (SFmode, operands[1]);\n-})\n-\n-(define_expand \"movdf\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n-\t(match_operand:DF 1 \"general_operand\" \"\"))]\n-  \"\"\n-{\n-  if (MEM_P (operands[0])\n-      && ! reg_or_0_operand (operands[1], DFmode))\n-    operands[1] = force_reg (DFmode, operands[1]);\n-})\n+;; We do two major things here: handle mem->mem and construct long\n+;; constants.\n \n-(define_expand \"movtf\"\n-  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n-\t(match_operand:TF 1 \"general_operand\" \"\"))]\n+(define_expand \"movsi\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:SI 1 \"general_operand\" \"\"))]\n   \"\"\n {\n-  if (MEM_P (operands[0])\n-      && ! reg_or_0_operand (operands[1], TFmode))\n-    operands[1] = force_reg (TFmode, operands[1]);\n+  if (alpha_expand_mov (SImode, operands))\n+    DONE;\n })\n \n (define_insn \"*movsi\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,m\")\n-\t(match_operand:SI 1 \"input_operand\" \"rJ,K,L,n,m,rJ\"))]\n-  \"TARGET_ABI_OSF\n-   && (register_operand (operands[0], SImode)\n-       || reg_or_0_operand (operands[1], SImode))\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,m,r\")\n+\t(match_operand:SI 1 \"input_operand\" \"rJ,K,L,n,m,rJ,s\"))]\n+  \"register_operand (operands[0], SImode)\n+   || reg_or_0_operand (operands[1], SImode)\"\n   \"@\n    bis $31,%r1,%0\n    lda %0,%1($31)\n    ldah %0,%h1($31)\n    #\n    ldl %0,%1\n-   stl %r1,%0\"\n-  [(set_attr \"type\" \"ilog,iadd,iadd,multi,ild,ist\")])\n-\n-(define_insn \"*movsi_nt_vms\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,r,m\")\n-\t(match_operand:SI 1 \"input_operand\" \"rJ,K,L,s,n,m,rJ\"))]\n-  \"TARGET_ABI_OPEN_VMS\n-    && (register_operand (operands[0], SImode)\n-        || reg_or_0_operand (operands[1], SImode))\"\n-  \"@\n-   bis $31,%1,%0\n-   lda %0,%1\n-   ldah %0,%h1\n-   lda %0,%1\n-   #\n-   ldl %0,%1\n-   stl %r1,%0\"\n-  [(set_attr \"type\" \"ilog,iadd,iadd,ldsym,multi,ild,ist\")])\n-\n-(define_insn \"*movhi_nobwx\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n-\t(match_operand:HI 1 \"input_operand\" \"rJ,n\"))]\n-  \"! TARGET_BWX\n-   && (register_operand (operands[0], HImode)\n-       || register_operand (operands[1], HImode))\"\n-  \"@\n-   bis $31,%r1,%0\n-   lda %0,%L1($31)\"\n-  [(set_attr \"type\" \"ilog,iadd\")])\n-\n-(define_insn \"*movhi_bwx\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r,r,m\")\n-\t(match_operand:HI 1 \"input_operand\" \"rJ,n,m,rJ\"))]\n-  \"TARGET_BWX\n-   && (register_operand (operands[0], HImode)\n-       || reg_or_0_operand (operands[1], HImode))\"\n-  \"@\n-   bis $31,%r1,%0\n-   lda %0,%L1($31)\n-   ldwu %0,%1\n-   stw %r1,%0\"\n-  [(set_attr \"type\" \"ilog,iadd,ild,ist\")])\n-\n-(define_insn \"*movqi_nobwx\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r,r\")\n-\t(match_operand:QI 1 \"input_operand\" \"rJ,n\"))]\n-  \"! TARGET_BWX\n-   && (register_operand (operands[0], QImode)\n-       || register_operand (operands[1], QImode))\"\n-  \"@\n-   bis $31,%r1,%0\n-   lda %0,%L1($31)\"\n-  [(set_attr \"type\" \"ilog,iadd\")])\n-\n-(define_insn \"*movqi_bwx\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r,r,r,m\")\n-\t(match_operand:QI 1 \"input_operand\" \"rJ,n,m,rJ\"))]\n-  \"TARGET_BWX\n-   && (register_operand (operands[0], QImode)\n-       || reg_or_0_operand (operands[1], QImode))\"\n-  \"@\n-   bis $31,%r1,%0\n-   lda %0,%L1($31)\n-   ldbu %0,%1\n-   stb %r1,%0\"\n-  [(set_attr \"type\" \"ilog,iadd,ild,ist\")])\n-\n-;; We do two major things here: handle mem->mem and construct long\n-;; constants.\n-\n-(define_expand \"movsi\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n-\t(match_operand:SI 1 \"general_operand\" \"\"))]\n-  \"\"\n-{\n-  if (alpha_expand_mov (SImode, operands))\n-    DONE;\n-})\n+   stl %r1,%0\n+   lda %0,%1\"\n+  [(set_attr \"type\" \"ilog,iadd,iadd,multi,ild,ist,ldsym\")\n+   (set_attr \"isa\" \"*,*,*,*,*,*,vms\")])\n \n ;; Split a load of a large constant into the appropriate two-insn\n ;; sequence.\n@@ -5454,7 +5341,7 @@\n \t(match_dup 4))]\n   \"WORDS_BIG_ENDIAN\"\n   \"operands[5] = force_reg (DImode, operands[0]);\")\n-\f\n+\n ;; Here are the define_expand's for QI and HI moves that use the above\n ;; patterns.  We have the normal sets, plus the ones that need scratch\n ;; registers for reload.\n@@ -5470,6 +5357,19 @@\n     DONE;\n })\n \n+(define_insn \"*movqi\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r,r,r,m\")\n+\t(match_operand:QI 1 \"input_operand\" \"rJ,n,m,rJ\"))]\n+  \"register_operand (operands[0], QImode)\n+   || reg_or_0_operand (operands[1], QImode)\"\n+  \"@\n+   bis $31,%r1,%0\n+   lda %0,%L1($31)\n+   ldbu %0,%1\n+   stb %r1,%0\"\n+  [(set_attr \"type\" \"ilog,iadd,ild,ist\")\n+   (set_attr \"isa\" \"*,*,bwx,bwx\")])\n+\n (define_expand \"movhi\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n \t(match_operand:HI 1 \"general_operand\" \"\"))]\n@@ -5481,6 +5381,19 @@\n     DONE;\n })\n \n+(define_insn \"*movhi\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r,r,m\")\n+\t(match_operand:HI 1 \"input_operand\" \"rJ,n,m,rJ\"))]\n+  \"register_operand (operands[0], HImode)\n+   || reg_or_0_operand (operands[1], HImode)\"\n+  \"@\n+   bis $31,%r1,%0\n+   lda %0,%L1($31)\n+   ldwu %0,%1\n+   stw %r1,%0\"\n+  [(set_attr \"type\" \"ilog,iadd,ild,ist\")\n+   (set_attr \"isa\" \"*,*,bwx,bwx\")])\n+\n ;; We need to hook into the extra support that we have for HImode \n ;; reloads when BWX insns are not available.\n (define_expand \"movcqi\"\n@@ -5565,7 +5478,7 @@\n   [(parallel [(match_operand:RELOAD12 0 \"any_memory_operand\" \"=m\")\n \t      (match_operand:RELOAD12 1 \"register_operand\" \"r\")\n \t      (match_operand:TI 2 \"register_operand\" \"=&r\")])]\n-  \"! TARGET_BWX\"\n+  \"!TARGET_BWX\"\n {\n   unsigned regno = REGNO (operands[2]);\n \n@@ -5676,9 +5589,8 @@\n (define_insn \"*mov<mode>_fix\"\n   [(set (match_operand:VEC 0 \"nonimmediate_operand\" \"=r,r,r,m,*f,*f,m,r,*f\")\n \t(match_operand:VEC 1 \"input_operand\" \"rW,i,m,rW,*fW,m,*f,*f,r\"))]\n-  \"TARGET_FIX\n-   && (register_operand (operands[0], <MODE>mode)\n-       || reg_or_0_operand (operands[1], <MODE>mode))\"\n+  \"register_operand (operands[0], <MODE>mode)\n+   || reg_or_0_operand (operands[1], <MODE>mode)\"\n   \"@\n    bis $31,%r1,%0\n    #\n@@ -5689,23 +5601,8 @@\n    stt %R1,%0\n    ftoit %1,%0\n    itoft %1,%0\"\n-  [(set_attr \"type\" \"ilog,multi,ild,ist,fcpys,fld,fst,ftoi,itof\")])\n-\n-(define_insn \"*mov<mode>_nofix\"\n-  [(set (match_operand:VEC 0 \"nonimmediate_operand\" \"=r,r,r,m,*f,*f,m\")\n-\t(match_operand:VEC 1 \"input_operand\" \"rW,i,m,rW,*fW,m,*f\"))]\n-  \"! TARGET_FIX\n-   && (register_operand (operands[0], <MODE>mode)\n-       || reg_or_0_operand (operands[1], <MODE>mode))\"\n-  \"@\n-   bis $31,%r1,%0\n-   #\n-   ldq %0,%1\n-   stq %r1,%0\n-   cpys %R1,%R1,%0\n-   ldt %0,%1\n-   stt %R1,%0\"\n-  [(set_attr \"type\" \"ilog,multi,ild,ist,fcpys,fld,fst\")])\n+  [(set_attr \"type\" \"ilog,multi,ild,ist,fcpys,fld,fst,ftoi,itof\")\n+   (set_attr \"isa\" \"*,*,*,*,*,*,*,fix,fix\")])\n \n (define_insn \"uminv8qi3\"\n   [(set (match_operand:V8QI 0 \"register_operand\" \"=r\")"}, {"sha": "35514502c2089caccab88a037b297cd76c0172d6", "filename": "gcc/config/alpha/constraints.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67102517d54bdc14ea9075e9b75326ae41851f78/gcc%2Fconfig%2Falpha%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67102517d54bdc14ea9075e9b75326ae41851f78/gcc%2Fconfig%2Falpha%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fconstraints.md?ref=67102517d54bdc14ea9075e9b75326ae41851f78", "patch": "@@ -32,7 +32,7 @@\n (define_register_constraint \"c\" \"R27_REG\"\n  \"General register 27, function call address\")\n \n-(define_register_constraint \"f\" \"FLOAT_REGS\"\n+(define_register_constraint \"f\" \"TARGET_FPREGS ? FLOAT_REGS : NO_REGS\"\n  \"Any floating-point register\")\n \n (define_register_constraint \"v\" \"R0_REG\""}]}