{"sha": "4b6bf620d4dcf42826d633fb3e39fae040135498", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGI2YmY2MjBkNGRjZjQyODI2ZDYzM2ZiM2UzOWZhZTA0MDEzNTQ5OA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2000-04-21T19:19:24Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2000-04-21T19:19:24Z"}, "message": "stor-layout.c (layout_decl): Only set DECL_MODE if not already set.\n\n\t* stor-layout.c (layout_decl): Only set DECL_MODE if not already set.\n\t(place_field): Properly compute know and actual alignment.\n\nFrom-SVN: r33312", "tree": {"sha": "668fe6d38708e7e4d15304d12a2df640c8c0a166", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/668fe6d38708e7e4d15304d12a2df640c8c0a166"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b6bf620d4dcf42826d633fb3e39fae040135498", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b6bf620d4dcf42826d633fb3e39fae040135498", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b6bf620d4dcf42826d633fb3e39fae040135498", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b6bf620d4dcf42826d633fb3e39fae040135498/comments", "author": null, "committer": null, "parents": [{"sha": "cdd83c31375b8aedcfedadf0d26069a4bc66f0fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdd83c31375b8aedcfedadf0d26069a4bc66f0fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdd83c31375b8aedcfedadf0d26069a4bc66f0fa"}], "stats": {"total": 18, "additions": 13, "deletions": 5}, "files": [{"sha": "ce2ea3a6e00db1c7f27c26489b79860285b1d682", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b6bf620d4dcf42826d633fb3e39fae040135498/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b6bf620d4dcf42826d633fb3e39fae040135498/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4b6bf620d4dcf42826d633fb3e39fae040135498", "patch": "@@ -1,5 +1,8 @@\n Fri Apr 21 13:30:26 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* stor-layout.c (layout_decl): Only set DECL_MODE if not already set.\n+\t(place_field): Properly compute know and actual alignment.\n+\n \t* gengenrtl.c (gencode): Write obstack_alloc_rtx function start\n \tin proper format.\n "}, {"sha": "cce030bd41293c4c151101877997ad0ecb056623", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b6bf620d4dcf42826d633fb3e39fae040135498/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b6bf620d4dcf42826d633fb3e39fae040135498/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=4b6bf620d4dcf42826d633fb3e39fae040135498", "patch": "@@ -306,10 +306,12 @@ layout_decl (decl, known_align)\n      also happens with other fields.  For example, the C++ front-end creates\n      zero-sized fields corresponding to empty base classes, and depends on\n      layout_type setting DECL_FIELD_BITPOS correctly for the field.  Set the\n-     size in bytes from the size in bits.  */\n+     size in bytes from the size in bits.  If we have already set the mode,\n+     don't set it again since we can be called twice for FIELD_DECLs.  */\n \n-  DECL_MODE (decl) = TYPE_MODE (type);\n   TREE_UNSIGNED (decl) = TREE_UNSIGNED (type);\n+  if (DECL_MODE (decl) == VOIDmode)\n+    DECL_MODE (decl) = TYPE_MODE (type);\n \n   if (DECL_SIZE (decl) == 0)\n     {\n@@ -642,9 +644,11 @@ place_field (rli, field)\n \n   /* Work out the known alignment so far.  Note that A & (-A) is the\n      value of the least-significant bit in A that is one.  */\n-  if (! integer_zerop (rli->bitpos) && TREE_CONSTANT (rli->offset))\n+  if (! integer_zerop (rli->bitpos))\n     known_align = (tree_low_cst (rli->bitpos, 1)\n \t\t   & - tree_low_cst (rli->bitpos, 1));\n+  else if (integer_zerop (rli->offset))\n+    known_align = BIGGEST_ALIGNMENT;\n   else if (host_integerp (rli->offset, 1))\n     known_align = (BITS_PER_UNIT\n \t\t   * (tree_low_cst (rli->offset, 1)\n@@ -833,10 +837,11 @@ place_field (rli, field)\n   /* If this field ended up more aligned than we thought it would be (we\n      approximate this by seeing if its position changed), lay out the field\n      again; perhaps we can use an integral mode for it now.  */\n-  if (! integer_zerop (DECL_FIELD_BIT_OFFSET (field))\n-      && TREE_CONSTANT (DECL_FIELD_OFFSET (field)))\n+  if (! integer_zerop (DECL_FIELD_BIT_OFFSET (field)))\n     actual_align = (tree_low_cst (DECL_FIELD_BIT_OFFSET (field), 1)\n \t\t    & - tree_low_cst (DECL_FIELD_BIT_OFFSET (field), 1));\n+  else if (integer_zerop (DECL_FIELD_OFFSET (field)))\n+    actual_align = BIGGEST_ALIGNMENT;\n   else if (host_integerp (DECL_FIELD_OFFSET (field), 1))\n     actual_align = (BITS_PER_UNIT\n \t\t   * (tree_low_cst (DECL_FIELD_OFFSET (field), 1)"}]}