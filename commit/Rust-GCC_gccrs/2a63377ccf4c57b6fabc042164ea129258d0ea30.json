{"sha": "2a63377ccf4c57b6fabc042164ea129258d0ea30", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmE2MzM3N2NjZjRjNTdiNmZhYmMwNDIxNjRlYTEyOTI1OGQwZWEzMA==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1998-09-05T02:24:45Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-09-05T02:24:45Z"}, "message": "Makefile.in (pexecute.o): Use pexecute.c from libiberty.\n\n        * Makefile.in (pexecute.o): Use pexecute.c from libiberty.  Provide\n        explicit rules for building.\n        * pexecute.c: Delete.\n\nFrom-SVN: r22242", "tree": {"sha": "86b608a1fc39cdfe34551c5bd16c6fa739d1ce34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86b608a1fc39cdfe34551c5bd16c6fa739d1ce34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a63377ccf4c57b6fabc042164ea129258d0ea30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a63377ccf4c57b6fabc042164ea129258d0ea30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a63377ccf4c57b6fabc042164ea129258d0ea30", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a63377ccf4c57b6fabc042164ea129258d0ea30/comments", "author": null, "committer": null, "parents": [{"sha": "d4751916e806a1e20a51f3d03b64b05443b57918", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4751916e806a1e20a51f3d03b64b05443b57918", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4751916e806a1e20a51f3d03b64b05443b57918"}], "stats": {"total": 791, "additions": 13, "deletions": 778}, "files": [{"sha": "047523304da70381d27b556901d456b5683ec79a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a63377ccf4c57b6fabc042164ea129258d0ea30/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a63377ccf4c57b6fabc042164ea129258d0ea30/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2a63377ccf4c57b6fabc042164ea129258d0ea30", "patch": "@@ -1,3 +1,9 @@\n+Sat Sep  5 03:23:05 1998  Jeffrey A Law  (law@cygnus.com)\n+\n+        * Makefile.in (pexecute.o): Use pexecute.c from libiberty.  Provide\n+\texplicit rules for building.\n+        * pexecute.c: Delete.\n+\n Fri Sep  4 11:57:50 1998  Tom Tromey  <tromey@cygnus.com>\n \n \t* gcc.c (do_spec_1): [case 'o'] Account for"}, {"sha": "0369aff409853a204b157cf209645f8a7a7561de", "filename": "gcc/Makefile.in", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a63377ccf4c57b6fabc042164ea129258d0ea30/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a63377ccf4c57b6fabc042164ea129258d0ea30/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=2a63377ccf4c57b6fabc042164ea129258d0ea30", "patch": "@@ -1309,6 +1309,11 @@ cplus-dem.o: $(srcdir)/../libiberty/cplus-dem.c $(DEMANGLE_H)\n \t$(LN_S) $(srcdir)/../libiberty/cplus-dem.c cplus-dem.c\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) cplus-dem.c\n \n+pexecute.o: $(srcdir)/../libiberty/pexecute.c $(CONFIG_H) system.h gansidecl.h\n+\trm -f pexecute.c\n+\t$(LN_S) $(srcdir)/../libiberty/pexecute.c pexecute.c\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) pexecute.c\n+\n underscore.c: s-under ; @true\n \n s-under: $(GCC_PASSES)\n@@ -1362,7 +1367,6 @@ version.o: version.c\n obstack.o: obstack.c $(CONFIG_H)\n choose-temp.o: choose-temp.c $(CONFIG_H) gansidecl.h system.h\n mkstemp.o: mkstemp.c $(CONFIG_H) gansidecl.h system.h\n-pexecute.o: pexecute.c $(CONFIG_H) system.h gansidecl.h\n prefix.o: prefix.c $(CONFIG_H) system.h gansidecl.h Makefile\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n \t-DPREFIX=\\\"$(prefix)\\\" \\\n@@ -1800,9 +1804,9 @@ $(HOST_PREFIX_1)obstack.o: obstack.c\n \tsed -e 's/config[.]h/hconfig.h/' $(srcdir)/obstack.c > $(HOST_PREFIX)obstack.c\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(HOST_PREFIX)obstack.c\n \n-$(HOST_PREFIX_1)vfprintf.o: vfprintf.c\n+$(HOST_PREFIX_1)vfprintf.o: $(srcdir)/../libiberty/vfprintf.c\n \trm -f $(HOST_PREFIX)vfprintf.c\n-\tsed -e 's/config[.]h/hconfig.h/' $(srcdir)/vfprintf.c > $(HOST_PREFIX)vfprintf.c\n+\tsed -e 's/config[.]h/hconfig.h/' $(srcdir)../libiberty/vfprintf.c > $(HOST_PREFIX)vfprintf.c\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(HOST_PREFIX)vfprintf.c\n \n $(HOST_PREFIX_1)doprint.o: doprint.c"}, {"sha": "804f3147f7d8bb6b07988b12dad4f1de7f9bf026", "filename": "gcc/pexecute.c", "status": "removed", "additions": 0, "deletions": 775, "changes": 775, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4751916e806a1e20a51f3d03b64b05443b57918/gcc%2Fpexecute.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4751916e806a1e20a51f3d03b64b05443b57918/gcc%2Fpexecute.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpexecute.c?ref=d4751916e806a1e20a51f3d03b64b05443b57918", "patch": "@@ -1,775 +0,0 @@\n-/* Utilities to execute a program in a subprocess (possibly linked by pipes\n-   with other subprocesses), and wait for it.\n-   Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.\n-\n-This file is part of the libiberty library.\n-Libiberty is free software; you can redistribute it and/or\n-modify it under the terms of the GNU Library General Public\n-License as published by the Free Software Foundation; either\n-version 2 of the License, or (at your option) any later version.\n-\n-Libiberty is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-Library General Public License for more details.\n-\n-You should have received a copy of the GNU Library General Public\n-License along with libiberty; see the file COPYING.LIB.  If not,\n-write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* This file exports two functions: pexecute and pwait.  */\n-\n-/* This file lives in at least two places: libiberty and gcc.\n-   Don't change one without the other.  */\n-\n-#ifdef IN_GCC\n-#include \"config.h\"\n-#endif\n-\n-#include \"system.h\"\n-\n-#ifdef IN_GCC\n-#include \"gansidecl.h\"\n-/* ??? Need to find a suitable header file.  */\n-#define PEXECUTE_FIRST   1\n-#define PEXECUTE_LAST    2\n-#define PEXECUTE_ONE     (PEXECUTE_FIRST + PEXECUTE_LAST)\n-#define PEXECUTE_SEARCH  4\n-#define PEXECUTE_VERBOSE 8\n-#else\n-#include \"libiberty.h\"\n-#endif\n-\n-/* stdin file number.  */\n-#define STDIN_FILE_NO 0\n-\n-/* stdout file number.  */\n-#define STDOUT_FILE_NO 1\n-\n-/* value of `pipe': port index for reading.  */\n-#define READ_PORT 0\n-\n-/* value of `pipe': port index for writing.  */\n-#define WRITE_PORT 1\n-\n-static char *install_error_msg = \"installation problem, cannot exec `%s'\";\n-\n-/* pexecute: execute a program.\n-\n-   PROGRAM and ARGV are the arguments to execv/execvp.\n-\n-   THIS_PNAME is name of the calling program (i.e. argv[0]).\n-\n-   TEMP_BASE is the path name, sans suffix, of a temporary file to use\n-   if needed.  This is currently only needed for MSDOS ports that don't use\n-   GO32 (do any still exist?).  Ports that don't need it can pass NULL.\n-\n-   (FLAGS & PEXECUTE_SEARCH) is non-zero if $PATH should be searched\n-   (??? It's not clear that GCC passes this flag correctly).\n-   (FLAGS & PEXECUTE_FIRST) is nonzero for the first process in chain.\n-   (FLAGS & PEXECUTE_FIRST) is nonzero for the last process in chain.\n-   FIRST_LAST could be simplified to only mark the last of a chain of processes\n-   but that requires the caller to always mark the last one (and not give up\n-   early if some error occurs).  It's more robust to require the caller to\n-   mark both ends of the chain.\n-\n-   The result is the pid on systems like Unix where we fork/exec and on systems\n-   like WIN32 and OS2 where we use spawn.  It is up to the caller to wait for\n-   the child.\n-\n-   The result is the WEXITSTATUS on systems like MSDOS where we spawn and wait\n-   for the child here.\n-\n-   Upon failure, ERRMSG_FMT and ERRMSG_ARG are set to the text of the error\n-   message with an optional argument (if not needed, ERRMSG_ARG is set to\n-   NULL), and -1 is returned.  `errno' is available to the caller to use.\n-\n-   pwait: cover function for wait.\n-\n-   PID is the process id of the task to wait for.\n-   STATUS is the `status' argument to wait.\n-   FLAGS is currently unused (allows future enhancement without breaking\n-   upward compatibility).  Pass 0 for now.\n-\n-   The result is the pid of the child reaped,\n-   or -1 for failure (errno says why).\n-\n-   On systems that don't support waiting for a particular child, PID is\n-   ignored.  On systems like MSDOS that don't really multitask pwait\n-   is just a mechanism to provide a consistent interface for the caller.\n-\n-   pfinish: finish generation of script\n-\n-   pfinish is necessary for systems like MPW where a script is generated that\n-   runs the requested programs.\n-*/\n-\n-#ifdef __MSDOS__\n-\n-/* MSDOS doesn't multitask, but for the sake of a consistent interface\n-   the code behaves like it does.  pexecute runs the program, tucks the\n-   exit code away, and returns a \"pid\".  pwait must be called to fetch the\n-   exit code.  */\n-\n-#include <process.h>\n-\n-/* For communicating information from pexecute to pwait.  */\n-static int last_pid = 0;\n-static int last_status = 0;\n-static int last_reaped = 0;\n-\n-int\n-pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)\n-     const char *program;\n-     char * const *argv;\n-     const char *this_pname;\n-     const char *temp_base;\n-     char **errmsg_fmt, **errmsg_arg;\n-     int flags;\n-{\n-  int rc;\n-\n-  last_pid++;\n-  if (last_pid < 0)\n-    last_pid = 1;\n-\n-  if ((flags & PEXECUTE_ONE) != PEXECUTE_ONE)\n-    abort ();\n-\n-#ifdef __GO32__\n-  /* ??? What are the possible return values from spawnv?  */\n-  rc = (flags & PEXECUTE_SEARCH ? spawnvp : spawnv) (1, program, argv);\n-#else\n-  char *scmd, *rf;\n-  FILE *argfile;\n-  int i, el = flags & PEXECUTE_SEARCH ? 4 : 0;\n-\n-  scmd = (char *) xmalloc (strlen (program) + strlen (temp_base) + 6 + el);\n-  rf = scmd + strlen(program) + 2 + el;\n-  sprintf (scmd, \"%s%s @%s.gp\", program,\n-\t   (flags & PEXECUTE_SEARCH ? \".exe\" : \"\"), temp_base);\n-  argfile = fopen (rf, \"w\");\n-  if (argfile == 0)\n-    {\n-      int errno_save = errno;\n-      free (scmd);\n-      errno = errno_save;\n-      *errmsg_fmt = \"cannot open `%s.gp'\";\n-      *errmsg_arg = temp_base;\n-      return -1;\n-    }\n-\n-  for (i=1; argv[i]; i++)\n-    {\n-      char *cp;\n-      for (cp = argv[i]; *cp; cp++)\n-\t{\n-\t  if (*cp == '\"' || *cp == '\\'' || *cp == '\\\\' || ISSPACE (*cp))\n-\t    fputc ('\\\\', argfile);\n-\t  fputc (*cp, argfile);\n-\t}\n-      fputc ('\\n', argfile);\n-    }\n-  fclose (argfile);\n-\n-  rc = system (scmd);\n-\n-  {\n-    int errno_save = errno;\n-    remove (rf);\n-    free (scmd);\n-    errno = errno_save;\n-  }\n-#endif\n-\n-  if (rc == -1)\n-    {\n-      *errmsg_fmt = install_error_msg;\n-      *errmsg_arg = program;\n-      return -1;\n-    }\n-\n-  /* Tuck the status away for pwait, and return a \"pid\".  */\n-  last_status = rc << 8;\n-  return last_pid;\n-}\n-\n-int\n-pwait (pid, status, flags)\n-     int pid;\n-     int *status;\n-     int flags;\n-{\n-  /* On MSDOS each pexecute must be followed by it's associated pwait.  */\n-  if (pid != last_pid\n-      /* Called twice for the same child?  */\n-      || pid == last_reaped)\n-    {\n-      /* ??? ECHILD would be a better choice.  Can we use it here?  */\n-      errno = EINVAL;\n-      return -1;\n-    }\n-  /* ??? Here's an opportunity to canonicalize the values in STATUS.\n-     Needed?  */\n-  *status = last_status;\n-  last_reaped = last_pid;\n-  return last_pid;\n-}\n-\n-#endif /* MSDOS */\n-\n-#if defined (_WIN32)\n-\n-#include <process.h>\n-\n-#ifdef __CYGWIN32__\n-\n-#define fix_argv(argvec) (argvec)\n-\n-extern int _spawnv ();\n-extern int _spawnvp ();\n-\n-int\n-pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)\n-     const char *program;\n-     char * const *argv;\n-     const char *this_pname;\n-     const char *temp_base;\n-     char **errmsg_fmt, **errmsg_arg;\n-     int flags;\n-{\n-  int pid;\n-\n-  if ((flags & PEXECUTE_ONE) != PEXECUTE_ONE)\n-    abort ();\n-  pid = (flags & PEXECUTE_SEARCH ? _spawnvp : _spawnv)\n-    (_P_NOWAIT, program, fix_argv(argv));\n-  if (pid == -1)\n-    {\n-      *errmsg_fmt = install_error_msg;\n-      *errmsg_arg = program;\n-      return -1;\n-    }\n-  return pid;\n-}\n-\n-int\n-pwait (pid, status, flags)\n-     int pid;\n-     int *status;\n-     int flags;\n-{\n-  /* ??? Here's an opportunity to canonicalize the values in STATUS.\n-     Needed?  */\n-  return cwait (status, pid, WAIT_CHILD);\n-}\n-\n-#else /* ! __CYGWIN32__ */\n-\n-/* This is a kludge to get around the Microsoft C spawn functions' propensity\n-   to remove the outermost set of double quotes from all arguments.  */\n-\n-const char * const *\n-fix_argv (argvec)\n-     char **argvec;\n-{\n-  int i;\n-\n-  for (i = 1; argvec[i] != 0; i++)\n-    {\n-      int len, j;\n-      char *temp, *newtemp;\n-\n-      temp = argvec[i];\n-      len = strlen (temp);\n-      for (j = 0; j < len; j++)\n-        {\n-          if (temp[j] == '\"')\n-            {\n-              newtemp = xmalloc (len + 2);\n-              strncpy (newtemp, temp, j);\n-              newtemp [j] = '\\\\';\n-              strncpy (&newtemp [j+1], &temp [j], len-j);\n-              newtemp [len+1] = 0;\n-              temp = newtemp;\n-              len++;\n-              j++;\n-            }\n-        }\n-\n-        argvec[i] = temp;\n-      }\n-\n-  return (const char * const *) argvec;\n-}\n-\n-#include <io.h>\n-#include <fcntl.h>\n-#include <signal.h>\n-\n-/* mingw32 headers may not define the following.  */\n-\n-#ifndef _P_WAIT\n-#  define _P_WAIT\t0\n-#  define _P_NOWAIT\t1\n-#  define _P_OVERLAY\t2\n-#  define _P_NOWAITO\t3\n-#  define _P_DETACH\t4\n-\n-#  define WAIT_CHILD\t0\n-#  define WAIT_GRANDCHILD\t1\n-#endif\n-\n-/* Win32 supports pipes */\n-int\n-pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)\n-     const char *program;\n-     char * const *argv;\n-     const char *this_pname;\n-     const char *temp_base;\n-     char **errmsg_fmt, **errmsg_arg;\n-     int flags;\n-{\n-  int pid;\n-  int pdes[2], org_stdin, org_stdout;\n-  int input_desc, output_desc;\n-  int retries, sleep_interval;\n-\n-  /* Pipe waiting from last process, to be used as input for the next one.\n-     Value is STDIN_FILE_NO if no pipe is waiting\n-     (i.e. the next command is the first of a group).  */\n-  static int last_pipe_input;\n-\n-  /* If this is the first process, initialize.  */\n-  if (flags & PEXECUTE_FIRST)\n-    last_pipe_input = STDIN_FILE_NO;\n-\n-  input_desc = last_pipe_input;\n-\n-  /* If this isn't the last process, make a pipe for its output,\n-     and record it as waiting to be the input to the next process.  */\n-  if (! (flags & PEXECUTE_LAST))\n-    {\n-      if (_pipe (pdes, 256, O_BINARY) < 0)\n-\t{\n-\t  *errmsg_fmt = \"pipe\";\n-\t  *errmsg_arg = NULL;\n-\t  return -1;\n-\t}\n-      output_desc = pdes[WRITE_PORT];\n-      last_pipe_input = pdes[READ_PORT];\n-    }\n-  else\n-    {\n-      /* Last process.  */\n-      output_desc = STDOUT_FILE_NO;\n-      last_pipe_input = STDIN_FILE_NO;\n-    }\n-\n-  if (input_desc != STDIN_FILE_NO)\n-    {\n-      org_stdin = dup (STDIN_FILE_NO);\n-      dup2 (input_desc, STDIN_FILE_NO);\n-      close (input_desc); \n-    }\n-\n-  if (output_desc != STDOUT_FILE_NO)\n-    {\n-      org_stdout = dup (STDOUT_FILE_NO);\n-      dup2 (output_desc, STDOUT_FILE_NO);\n-      close (output_desc);\n-    }\n-\n-  pid = (flags & PEXECUTE_SEARCH ? _spawnvp : _spawnv)\n-    (_P_NOWAIT, program, fix_argv(argv));\n-\n-  if (input_desc != STDIN_FILE_NO)\n-    {\n-      dup2 (org_stdin, STDIN_FILE_NO);\n-      close (org_stdin);\n-    }\n-\n-  if (output_desc != STDOUT_FILE_NO)\n-    {\n-      dup2 (org_stdout, STDOUT_FILE_NO);\n-      close (org_stdout);\n-    }\n-\n-  if (pid == -1)\n-    {\n-      *errmsg_fmt = install_error_msg;\n-      *errmsg_arg = program;\n-      return -1;\n-    }\n-\n-  return pid;\n-}\n-\n-/* MS CRTDLL doesn't return enough information in status to decide if the\n-   child exited due to a signal or not, rather it simply returns an\n-   integer with the exit code of the child; eg., if the child exited with \n-   an abort() call and didn't have a handler for SIGABRT, it simply returns\n-   with status = 3. We fix the status code to conform to the usual WIF*\n-   macros. Note that WIFSIGNALED will never be true under CRTDLL. */\n-\n-int\n-pwait (pid, status, flags)\n-     int pid;\n-     int *status;\n-     int flags;\n-{\n-  int termstat;\n-\n-  pid = _cwait (&termstat, pid, WAIT_CHILD);\n-\n-  /* ??? Here's an opportunity to canonicalize the values in STATUS.\n-     Needed?  */\n-\n-  /* cwait returns the child process exit code in termstat.\n-     A value of 3 indicates that the child caught a signal, but not\n-     which one.  Since only SIGABRT, SIGFPE and SIGINT do anything, we\n-     report SIGABRT.  */\n-  if (termstat == 3)\n-    *status = SIGABRT;\n-  else\n-    *status = (((termstat) & 0xff) << 8);\n-\n-  return pid;\n-}\n-\n-#endif /* ! defined (__CYGWIN32__) */\n-\n-#endif /* _WIN32 */\n-\n-#ifdef OS2\n-\n-/* ??? Does OS2 have process.h?  */\n-extern int spawnv ();\n-extern int spawnvp ();\n-\n-int\n-pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)\n-     const char *program;\n-     char * const *argv;\n-     const char *this_pname;\n-     const char *temp_base;\n-     char **errmsg_fmt, **errmsg_arg;\n-     int flags;\n-{\n-  int pid;\n-\n-  if ((flags & PEXECUTE_ONE) != PEXECUTE_ONE)\n-    abort ();\n-  /* ??? Presumably 1 == _P_NOWAIT.  */\n-  pid = (flags & PEXECUTE_SEARCH ? spawnvp : spawnv) (1, program, argv);\n-  if (pid == -1)\n-    {\n-      *errmsg_fmt = install_error_msg;\n-      *errmsg_arg = program;\n-      return -1;\n-    }\n-  return pid;\n-}\n-\n-int\n-pwait (pid, status, flags)\n-     int pid;\n-     int *status;\n-     int flags;\n-{\n-  /* ??? Here's an opportunity to canonicalize the values in STATUS.\n-     Needed?  */\n-  int pid = wait (status);\n-  return pid;\n-}\n-\n-#endif /* OS2 */\n-\n-#ifdef MPW\n-\n-/* MPW pexecute doesn't actually run anything; instead, it writes out\n-   script commands that, when run, will do the actual executing.\n-\n-   For example, in GCC's case, GCC will write out several script commands:\n-\n-   cpp ...\n-   cc1 ...\n-   as ...\n-   ld ...\n-\n-   and then exit.  None of the above programs will have run yet.  The task\n-   that called GCC will then execute the script and cause cpp,etc. to run.\n-   The caller must invoke pfinish before calling exit.  This adds\n-   the finishing touches to the generated script.  */\n-\n-static int first_time = 1;\n-\n-int\n-pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)\n-     const char *program;\n-     char * const *argv;\n-     const char *this_pname;\n-     const char *temp_base;\n-     char **errmsg_fmt, **errmsg_arg;\n-     int flags;\n-{\n-  char tmpprogram[255];\n-  char *cp, *tmpname;\n-  int i;\n-\n-  mpwify_filename (program, tmpprogram);\n-  if (first_time)\n-    {\n-      printf (\"Set Failed 0\\n\");\n-      first_time = 0;\n-    }\n-\n-  fputs (\"If {Failed} == 0\\n\", stdout);\n-  /* If being verbose, output a copy of the command.  It should be\n-     accurate enough and escaped enough to be \"clickable\".  */\n-  if (flags & PEXECUTE_VERBOSE)\n-    {\n-      fputs (\"\\tEcho \", stdout);\n-      fputc ('\\'', stdout);\n-      fputs (tmpprogram, stdout);\n-      fputc ('\\'', stdout);\n-      fputc (' ', stdout);\n-      for (i=1; argv[i]; i++)\n-\t{\n-\t  fputc ('\\'', stdout);\n-\t  /* See if we have an argument that needs fixing.  */\n-\t  if (strchr(argv[i], '/'))\n-\t    {\n-\t      tmpname = (char *) xmalloc (256);\n-\t      mpwify_filename (argv[i], tmpname);\n-\t      argv[i] = tmpname;\n-\t    }\n-\t  for (cp = argv[i]; *cp; cp++)\n-\t    {\n-\t      /* Write an Option-d escape char in front of special chars.  */\n-\t      if (strchr(\"'+\", *cp))\n-\t\tfputc ('\\266', stdout);\n-\t      fputc (*cp, stdout);\n-\t    }\n-\t  fputc ('\\'', stdout);\n-\t  fputc (' ', stdout);\n-\t}\n-      fputs (\"\\n\", stdout);\n-    }\n-  fputs (\"\\t\", stdout);\n-  fputs (tmpprogram, stdout);\n-  fputc (' ', stdout);\n-\n-  for (i=1; argv[i]; i++)\n-    {\n-      /* See if we have an argument that needs fixing.  */\n-      if (strchr(argv[i], '/'))\n-\t{\n-\t  tmpname = (char *) xmalloc (256);\n-\t  mpwify_filename (argv[i], tmpname);\n-\t  argv[i] = tmpname;\n-\t}\n-      if (strchr (argv[i], ' '))\n-\tfputc ('\\'', stdout);\n-      for (cp = argv[i]; *cp; cp++)\n-\t{\n-\t  /* Write an Option-d escape char in front of special chars.  */\n-\t  if (strchr(\"'+\", *cp))\n-\t    fputc ('\\266', stdout);\n-\t  fputc (*cp, stdout);\n-\t}\n-      if (strchr (argv[i], ' '))\n-\tfputc ('\\'', stdout);\n-      fputc (' ', stdout);\n-    }\n-\n-  fputs (\"\\n\", stdout);\n-\n-  /* Output commands that arrange to clean up and exit if a failure occurs.\n-     We have to be careful to collect the status from the program that was\n-     run, rather than some other script command.  Also, we don't exit\n-     immediately, since necessary cleanups are at the end of the script.  */\n-  fputs (\"\\tSet TmpStatus {Status}\\n\", stdout);\n-  fputs (\"\\tIf {TmpStatus} != 0\\n\", stdout);\n-  fputs (\"\\t\\tSet Failed {TmpStatus}\\n\", stdout);\n-  fputs (\"\\tEnd\\n\", stdout);\n-  fputs (\"End\\n\", stdout);\n-\n-  /* We're just composing a script, can't fail here.  */\n-  return 0;\n-}\n-\n-int\n-pwait (pid, status, flags)\n-     int pid;\n-     int *status;\n-     int flags;\n-{\n-  *status = 0;\n-  return 0;\n-}\n-\n-/* Write out commands that will exit with the correct error code\n-   if something in the script failed.  */\n-\n-void\n-pfinish ()\n-{\n-  printf (\"\\tExit \\\"{Failed}\\\"\\n\");\n-}\n-\n-#endif /* MPW */\n-\n-/* include for Unix-like environments but not for Dos-like environments */\n-#if ! defined (__MSDOS__) && ! defined (OS2) && ! defined (MPW) \\\n-    && ! defined (_WIN32)\n-\n-#ifdef VMS\n-#define vfork() (decc$$alloc_vfork_blocks() >= 0 ? \\\n-               lib$get_current_invo_context(decc$$get_vfork_jmpbuf()) : -1)\n-#else\n-#ifdef USG\n-#define vfork fork\n-#endif\n-#endif\n-\n-extern int execv ();\n-extern int execvp ();\n-#ifdef IN_GCC\n-extern char * my_strerror\t\t\tPROTO ((int));\n-#endif\n-\n-int\n-pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)\n-     const char *program;\n-     char * const *argv;\n-     const char *this_pname;\n-     const char *temp_base;\n-     char **errmsg_fmt, **errmsg_arg;\n-     int flags;\n-{\n-  int (*func)() = (flags & PEXECUTE_SEARCH ? execvp : execv);\n-  int pid;\n-  int pdes[2];\n-  int input_desc, output_desc;\n-  int retries, sleep_interval;\n-  /* Pipe waiting from last process, to be used as input for the next one.\n-     Value is STDIN_FILE_NO if no pipe is waiting\n-     (i.e. the next command is the first of a group).  */\n-  static int last_pipe_input;\n-\n-  /* If this is the first process, initialize.  */\n-  if (flags & PEXECUTE_FIRST)\n-    last_pipe_input = STDIN_FILE_NO;\n-\n-  input_desc = last_pipe_input;\n-\n-  /* If this isn't the last process, make a pipe for its output,\n-     and record it as waiting to be the input to the next process.  */\n-  if (! (flags & PEXECUTE_LAST))\n-    {\n-      if (pipe (pdes) < 0)\n-\t{\n-\t  *errmsg_fmt = \"pipe\";\n-\t  *errmsg_arg = NULL;\n-\t  return -1;\n-\t}\n-      output_desc = pdes[WRITE_PORT];\n-      last_pipe_input = pdes[READ_PORT];\n-    }\n-  else\n-    {\n-      /* Last process.  */\n-      output_desc = STDOUT_FILE_NO;\n-      last_pipe_input = STDIN_FILE_NO;\n-    }\n-\n-  /* Fork a subprocess; wait and retry if it fails.  */\n-  sleep_interval = 1;\n-  for (retries = 0; retries < 4; retries++)\n-    {\n-      pid = vfork ();\n-      if (pid >= 0)\n-\tbreak;\n-      sleep (sleep_interval);\n-      sleep_interval *= 2;\n-    }\n-\n-  switch (pid)\n-    {\n-    case -1:\n-      {\n-#ifdef vfork\n-\t*errmsg_fmt = \"fork\";\n-#else\n-\t*errmsg_fmt = \"vfork\";\n-#endif\n-\t*errmsg_arg = NULL;\n-\treturn -1;\n-      }\n-\n-    case 0: /* child */\n-      /* Move the input and output pipes into place, if necessary.  */\n-      if (input_desc != STDIN_FILE_NO)\n-\t{\n-\t  close (STDIN_FILE_NO);\n-\t  dup (input_desc);\n-\t  close (input_desc);\n-\t}\n-      if (output_desc != STDOUT_FILE_NO)\n-\t{\n-\t  close (STDOUT_FILE_NO);\n-\t  dup (output_desc);\n-\t  close (output_desc);\n-\t}\n-\n-      /* Close the parent's descs that aren't wanted here.  */\n-      if (last_pipe_input != STDIN_FILE_NO)\n-\tclose (last_pipe_input);\n-\n-      /* Exec the program.  */\n-      (*func) (program, argv);\n-\n-      /* Note: Calling fprintf and exit here doesn't seem right for vfork.  */\n-      fprintf (stderr, \"%s: \", this_pname);\n-      fprintf (stderr, install_error_msg, program);\n-#ifdef IN_GCC\n-      fprintf (stderr, \": %s\\n\", my_strerror (errno));\n-#else\n-      fprintf (stderr, \": %s\\n\", xstrerror (errno));\n-#endif\n-      exit (-1);\n-      /* NOTREACHED */\n-      return 0;\n-\n-    default:\n-      /* In the parent, after forking.\n-\t Close the descriptors that we made for this child.  */\n-      if (input_desc != STDIN_FILE_NO)\n-\tclose (input_desc);\n-      if (output_desc != STDOUT_FILE_NO)\n-\tclose (output_desc);\n-\n-      /* Return child's process number.  */\n-      return pid;\n-    }\n-}\n-\n-int\n-pwait (pid, status, flags)\n-     int pid;\n-     int *status;\n-     int flags;\n-{\n-  /* ??? Here's an opportunity to canonicalize the values in STATUS.\n-     Needed?  */\n-#ifdef VMS\n-  pid = waitpid (-1, status, 0);\n-#else\n-  pid = wait (status);\n-#endif\n-  return pid;\n-}\n-\n-#endif /* ! __MSDOS__ && ! OS2 && ! MPW && ! _WIN32 */"}]}