{"sha": "a5b1779f81ebfa6d13f0e5116234c8282d71c46d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTViMTc3OWY4MWViZmE2ZDEzZjBlNTExNjIzNGM4MjgyZDcxYzQ2ZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2011-06-10T11:43:01Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-06-10T11:43:01Z"}, "message": "ipa-inline-transform.c (can_remove_node_now_p): Move out of...\n\n\t* ipa-inline-transform.c (can_remove_node_now_p): Move out of...\n\t(clone_inlined_nodes): ... here.\n\t(inline_call): Use cgraph_function_or_thunk_node; redirect edge\n\tto real destination prior inlining.\n\t* ipa-inline.c (caller_growth_limits, can_inline_edge_p,\n\tcan_early_inline_edge_p, want_early_inline_function_p,\n\twant_early_inline_function_p, want_inline_small_function_p,\n\twant_inline_self_recursive_call_p, want_inline_function_called_once_p,\n\tedge_badness, update_all_callee_keys, lookup_recursive_calls,\n\tadd_new_edges_to_heap, inline_small_functions, flatten_function,\n\tinline_always_inline_functions, early_inline_small_functions): Use\n\tcgraph_function_or_thunk_node.\n\t* ipa-inline-analysis.c (evaluate_conditions_for_edge,\n\tdump_inline_edge_summary, estimate_function_body_sizes): Likewise.\n\t(do_estimate_edge_growth_1): Break out from ...\n\t(do_estimate_growth) ... here; walk aliases.\n\t(inline_generate_summary): Skip aliases.\n\nFrom-SVN: r174901", "tree": {"sha": "1d26feeab584ee3df009ef00a986f63acea4c6bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d26feeab584ee3df009ef00a986f63acea4c6bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5b1779f81ebfa6d13f0e5116234c8282d71c46d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5b1779f81ebfa6d13f0e5116234c8282d71c46d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5b1779f81ebfa6d13f0e5116234c8282d71c46d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5b1779f81ebfa6d13f0e5116234c8282d71c46d/comments", "author": null, "committer": null, "parents": [{"sha": "c1ae3ca5d8842831d35b08e6e9ae1f983b39bc6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1ae3ca5d8842831d35b08e6e9ae1f983b39bc6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1ae3ca5d8842831d35b08e6e9ae1f983b39bc6b"}], "stats": {"total": 316, "additions": 201, "deletions": 115}, "files": [{"sha": "74b3e43b05f094cb3c10baabb8e1b8f1b08972a3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5b1779f81ebfa6d13f0e5116234c8282d71c46d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5b1779f81ebfa6d13f0e5116234c8282d71c46d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a5b1779f81ebfa6d13f0e5116234c8282d71c46d", "patch": "@@ -1,3 +1,23 @@\n+2011-06-10  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-inline-transform.c (can_remove_node_now_p): Move out of...\n+\t(clone_inlined_nodes): ... here.\n+\t(inline_call): Use cgraph_function_or_thunk_node; redirect edge\n+\tto real destination prior inlining.\n+\t* ipa-inline.c (caller_growth_limits, can_inline_edge_p,\n+\tcan_early_inline_edge_p, want_early_inline_function_p,\n+\twant_early_inline_function_p, want_inline_small_function_p,\n+\twant_inline_self_recursive_call_p, want_inline_function_called_once_p,\n+\tedge_badness, update_all_callee_keys, lookup_recursive_calls,\n+\tadd_new_edges_to_heap, inline_small_functions, flatten_function,\n+\tinline_always_inline_functions, early_inline_small_functions): Use\n+\tcgraph_function_or_thunk_node.\n+\t* ipa-inline-analysis.c (evaluate_conditions_for_edge,\n+\tdump_inline_edge_summary, estimate_function_body_sizes): Likewise.\n+\t(do_estimate_edge_growth_1): Break out from ...\n+\t(do_estimate_growth) ... here; walk aliases.\n+\t(inline_generate_summary): Skip aliases.\n+\n 2011-06-10  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-ssa-forwprop.c (ssa_forward_propagate_and_combine):"}, {"sha": "473f554e4ae184c5f305a9b5d5f5deea69cd49ba", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 57, "deletions": 31, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5b1779f81ebfa6d13f0e5116234c8282d71c46d/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5b1779f81ebfa6d13f0e5116234c8282d71c46d/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=a5b1779f81ebfa6d13f0e5116234c8282d71c46d", "patch": "@@ -589,7 +589,8 @@ static clause_t\n evaluate_conditions_for_edge (struct cgraph_edge *e, bool inline_p)\n {\n   clause_t clause = inline_p ? 0 : 1 << predicate_not_inlined_condition;\n-  struct inline_summary *info = inline_summary (e->callee);\n+  struct cgraph_node *callee = cgraph_function_or_thunk_node (e->callee, NULL);\n+  struct inline_summary *info = inline_summary (callee);\n   int i;\n \n   if (ipa_node_params_vector && info->conds\n@@ -615,7 +616,7 @@ evaluate_conditions_for_edge (struct cgraph_edge *e, bool inline_p)\n \t  if (cst)\n \t    VEC_replace (tree, known_vals, i, cst);\n \t}\n-      clause = evaluate_conditions_for_known_args (e->callee,\n+      clause = evaluate_conditions_for_known_args (callee,\n \t\t\t\t\t\t   inline_p, known_vals);\n       VEC_free (tree, heap, known_vals);\n     }\n@@ -919,18 +920,19 @@ dump_inline_edge_summary (FILE * f, int indent, struct cgraph_node *node,\n   for (edge = node->callees; edge; edge = edge->next_callee)\n     {\n       struct inline_edge_summary *es = inline_edge_summary (edge);\n+      struct cgraph_node *callee = cgraph_function_or_thunk_node (edge->callee, NULL);\n       fprintf (f, \"%*s%s/%i %s\\n%*s  loop depth:%2i freq:%4i size:%2i time: %2i callee size:%2i stack:%2i\",\n-\t       indent, \"\", cgraph_node_name (edge->callee),\n-\t       edge->callee->uid, \n+\t       indent, \"\", cgraph_node_name (callee),\n+\t       callee->uid, \n \t       !edge->inline_failed ? \"inlined\"\n \t       : cgraph_inline_failed_string (edge->inline_failed),\n \t       indent, \"\",\n \t       es->loop_depth,\t\n                edge->frequency,\n \t       es->call_stmt_size,\n \t       es->call_stmt_time,\n-\t       (int)inline_summary (edge->callee)->size,\n-\t       (int)inline_summary (edge->callee)->estimated_stack_size);\n+\t       (int)inline_summary (callee)->size,\n+\t       (int)inline_summary (callee)->estimated_stack_size);\n       if (es->predicate)\n \t{\n \t  fprintf (f, \" predicate: \");\n@@ -942,10 +944,10 @@ dump_inline_edge_summary (FILE * f, int indent, struct cgraph_node *node,\n \t{\n           fprintf (f, \"%*sStack frame offset %i, callee self size %i, callee size %i\\n\",\n \t\t   indent+2, \"\",\n-\t\t   (int)inline_summary (edge->callee)->stack_frame_offset,\n-\t\t   (int)inline_summary (edge->callee)->estimated_self_stack_size,\n-\t\t   (int)inline_summary (edge->callee)->estimated_stack_size);\n-\t  dump_inline_edge_summary (f, indent+2, edge->callee, info);\n+\t\t   (int)inline_summary (callee)->stack_frame_offset,\n+\t\t   (int)inline_summary (callee)->estimated_self_stack_size,\n+\t\t   (int)inline_summary (callee)->estimated_stack_size);\n+\t  dump_inline_edge_summary (f, indent+2, callee, info);\n \t}\n     }\n   for (edge = node->indirect_calls; edge; edge = edge->next_callee)\n@@ -1525,7 +1527,10 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t      /* Do not inline calls where we cannot triviall work around\n \t\t mismatches in argument or return types.  */\n \t      if (edge->callee\n-\t\t  && !gimple_check_call_matching_types (stmt, edge->callee->decl))\n+\t\t  && cgraph_function_or_thunk_node (edge->callee, NULL)\n+\t\t  && !gimple_check_call_matching_types (stmt,\n+\t\t\t\t\t\t\tcgraph_function_or_thunk_node (edge->callee,\n+\t\t\t\t\t\t\t\t\t\t       NULL)->decl))\n \t\t{\n \t\t  edge->call_stmt_cannot_inline_p = true;\n \t\t  gimple_call_set_cannot_inline (stmt, true);\n@@ -2110,6 +2115,7 @@ int\n do_estimate_edge_growth (struct cgraph_edge *edge)\n {\n   int size;\n+  struct cgraph_node *callee;\n \n   /* When we do caching, use do_estimate_edge_time to populate the entry.  */\n \n@@ -2122,10 +2128,11 @@ do_estimate_edge_growth (struct cgraph_edge *edge)\n       gcc_checking_assert (size);\n       return size - (size > 0);\n     }\n+  callee = cgraph_function_or_thunk_node (edge->callee, NULL);\n \n   /* Early inliner runs without caching, go ahead and do the dirty work.  */\n   gcc_checking_assert (edge->inline_failed);\n-  estimate_node_size_and_time (edge->callee,\n+  estimate_node_size_and_time (callee,\n \t\t\t       evaluate_conditions_for_edge (edge, true),\n \t\t\t       &size, NULL);\n   gcc_checking_assert (inline_edge_summary (edge)->call_stmt_size);\n@@ -2171,15 +2178,20 @@ estimate_size_after_inlining (struct cgraph_node *node,\n }\n \n \n-/* Estimate the growth caused by inlining NODE into all callees.  */\n+struct growth_data\n+{\n+  bool self_recursive;\n+  int growth;\n+};\n \n-int\n-do_estimate_growth (struct cgraph_node *node)\n+\n+/* Worker for do_estimate_growth.  Collect growth for all callers.  */\n+\n+static bool\n+do_estimate_growth_1 (struct cgraph_node *node, void *data)\n {\n-  int growth = 0;\n   struct cgraph_edge *e;\n-  bool self_recursive = false;\n-  struct inline_summary *info = inline_summary (node);\n+  struct growth_data *d = (struct growth_data *) data;\n \n   for (e = node->callers; e; e = e->next_caller)\n     {\n@@ -2188,37 +2200,50 @@ do_estimate_growth (struct cgraph_node *node)\n       if (e->caller == node\n \t  || (e->caller->global.inlined_to\n \t      && e->caller->global.inlined_to == node))\n-        self_recursive = true;\n-      growth += estimate_edge_growth (e);\n+        d->self_recursive = true;\n+      d->growth += estimate_edge_growth (e);\n     }\n-     \n+  return false;\n+}\n+\n+\n+/* Estimate the growth caused by inlining NODE into all callees.  */\n+\n+int\n+do_estimate_growth (struct cgraph_node *node)\n+{\n+  struct growth_data d = {0, false};\n+  struct inline_summary *info = inline_summary (node);\n+\n+  cgraph_for_node_and_aliases (node, do_estimate_growth_1, &d, true);\n \n   /* For self recursive functions the growth estimation really should be\n      infinity.  We don't want to return very large values because the growth\n      plays various roles in badness computation fractions.  Be sure to not\n      return zero or negative growths. */\n-  if (self_recursive)\n-    growth = growth < info->size ? info->size : growth;\n+  if (d.self_recursive)\n+    d.growth = d.growth < info->size ? info->size : d.growth;\n   else\n     {\n-      if (cgraph_will_be_removed_from_program_if_no_direct_calls (node)\n-\t  && !DECL_EXTERNAL (node->decl))\n-\tgrowth -= info->size;\n+      if (!DECL_EXTERNAL (node->decl)\n+\t  && !cgraph_will_be_removed_from_program_if_no_direct_calls (node))\n+\td.growth -= info->size;\n       /* COMDAT functions are very often not shared across multiple units since they\n-\t come from various template instantiations.  Take this into account.  */\n+\t come from various template instantiations.  Take this into account.\n+         FIXME: allow also COMDATs with COMDAT aliases.  */\n       else  if (DECL_COMDAT (node->decl)\n \t\t&& cgraph_can_remove_if_no_direct_calls_p (node))\n-\tgrowth -= (info->size\n-\t\t   * (100 - PARAM_VALUE (PARAM_COMDAT_SHARING_PROBABILITY)) + 50) / 100;\n+\td.growth -= (info->size\n+\t\t     * (100 - PARAM_VALUE (PARAM_COMDAT_SHARING_PROBABILITY)) + 50) / 100;\n     }\n \n   if (node_growth_cache)\n     {\n       if ((int)VEC_length (int, node_growth_cache) <= node->uid)\n \tVEC_safe_grow_cleared (int, heap, node_growth_cache, cgraph_max_uid);\n-      VEC_replace (int, node_growth_cache, node->uid, growth + (growth >= 0));\n+      VEC_replace (int, node_growth_cache, node->uid, d.growth + (d.growth >= 0));\n     }\n-  return growth;\n+  return d.growth;\n }\n \n \n@@ -2282,6 +2307,7 @@ inline_generate_summary (void)\n     ipa_register_cgraph_hooks ();\n \n   FOR_EACH_DEFINED_FUNCTION (node)\n+    if (!node->alias)\n       inline_analyze_function (node);\n }\n "}, {"sha": "c5f32a34b763d9dc6103c935b88cf9b0bfd69c94", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 38, "deletions": 21, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5b1779f81ebfa6d13f0e5116234c8282d71c46d/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5b1779f81ebfa6d13f0e5116234c8282d71c46d/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=a5b1779f81ebfa6d13f0e5116234c8282d71c46d", "patch": "@@ -76,6 +76,35 @@ update_noncloned_frequencies (struct cgraph_node *node,\n     }\n }\n \n+/* We removed or are going to remove the last call to NODE.\n+   Return true if we can and want proactively remove the NODE now.\n+   This is important to do, since we want inliner to know when offline\n+   copy of function was removed.  */\n+\n+static bool\n+can_remove_node_now_p (struct cgraph_node *node)\n+{\n+  /* FIXME: When address is taken of DECL_EXTERNAL function we still\n+     can remove its offline copy, but we would need to keep unanalyzed node in\n+     the callgraph so references can point to it.  */\n+  return (!node->address_taken\n+\t  && cgraph_can_remove_if_no_direct_calls_p (node)\n+\t  /* Inlining might enable more devirtualizing, so we want to remove\n+\t     those only after all devirtualizable virtual calls are processed.\n+\t     Lacking may edges in callgraph we just preserve them post\n+\t     inlining.  */\n+\t  && (!DECL_VIRTUAL_P (node->decl)\n+\t      || (!DECL_COMDAT (node->decl)\n+\t\t  && !DECL_EXTERNAL (node->decl)))\n+\t  /* Don't reuse if more than one function shares a comdat group.\n+\t     If the other function(s) are needed, we need to emit even\n+\t     this function out of line.  */\n+\t  && !node->same_comdat_group\n+\t  /* During early inlining some unanalyzed cgraph nodes might be in the\n+\t     callgraph and they might reffer the function in question.  */\n+\t  && !cgraph_new_nodes);\n+}\n+\n \n /* E is expected to be an edge being inlined.  Clone destination node of\n    the edge and redirect it to the new clone.\n@@ -97,25 +126,7 @@ clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n \t  /* Recursive inlining never wants the master clone to\n \t     be overwritten.  */\n \t  && update_original\n-\t  /* FIXME: When address is taken of DECL_EXTERNAL function we still\n-\t     can remove its offline copy, but we would need to keep unanalyzed\n-\t     node in the callgraph so references can point to it.  */\n-\t  && !e->callee->address_taken\n-\t  && cgraph_can_remove_if_no_direct_calls_p (e->callee)\n-\t  /* Inlining might enable more devirtualizing, so we want to remove\n-\t     those only after all devirtualizable virtual calls are processed.\n-\t     Lacking may edges in callgraph we just preserve them post\n-\t     inlining.  */\n-\t  && (!DECL_VIRTUAL_P (e->callee->decl)\n-\t      || (!DECL_COMDAT (e->callee->decl)\n-\t\t  && !DECL_EXTERNAL (e->callee->decl)))\n-\t  /* Don't reuse if more than one function shares a comdat group.\n-\t     If the other function(s) are needed, we need to emit even\n-\t     this function out of line.  */\n-\t  && !e->callee->same_comdat_group\n-\t  /* During early inlining some unanalyzed cgraph nodes might be in the\n-\t     callgraph and they might reffer the function in question.  */\n-\t  && !cgraph_new_nodes)\n+\t  && can_remove_node_now_p (e->callee))\n \t{\n \t  gcc_assert (!e->callee->global.inlined_to);\n \t  if (e->callee->analyzed && !DECL_EXTERNAL (e->callee->decl))\n@@ -164,19 +175,25 @@ inline_call (struct cgraph_edge *e, bool update_original,\n   int old_size = 0, new_size = 0;\n   struct cgraph_node *to = NULL;\n   struct cgraph_edge *curr = e;\n+  struct cgraph_node *callee = cgraph_function_or_thunk_node (e->callee, NULL);\n \n   /* Don't inline inlined edges.  */\n   gcc_assert (e->inline_failed);\n   /* Don't even think of inlining inline clone.  */\n-  gcc_assert (!e->callee->global.inlined_to);\n+  gcc_assert (!callee->global.inlined_to);\n \n   e->inline_failed = CIF_OK;\n-  DECL_POSSIBLY_INLINED (e->callee->decl) = true;\n+  DECL_POSSIBLY_INLINED (callee->decl) = true;\n \n   to = e->caller;\n   if (to->global.inlined_to)\n     to = to->global.inlined_to;\n \n+  /* If aliases are involved, redirect edge to the actual destination and\n+     possibly remove the aliases.  */\n+  if (e->callee != callee)\n+    cgraph_redirect_edge_callee (e, callee);\n+\n   clone_inlined_nodes (e, true, update_original, overall_size);\n \n   gcc_assert (curr->callee->global.inlined_to == to);"}, {"sha": "6733e9ae356ed37d0b9f59a0f99df0443e025097", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 86, "deletions": 63, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5b1779f81ebfa6d13f0e5116234c8282d71c46d/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5b1779f81ebfa6d13f0e5116234c8282d71c46d/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=a5b1779f81ebfa6d13f0e5116234c8282d71c46d", "patch": "@@ -137,7 +137,7 @@ static bool\n caller_growth_limits (struct cgraph_edge *e)\n {\n   struct cgraph_node *to = e->caller;\n-  struct cgraph_node *what = e->callee;\n+  struct cgraph_node *what = cgraph_function_or_thunk_node (e->callee, NULL);\n   int newsize;\n   int limit = 0;\n   HOST_WIDE_INT stack_size_limit = 0, inlined_stack;\n@@ -237,22 +237,24 @@ static bool\n can_inline_edge_p (struct cgraph_edge *e, bool report)\n {\n   bool inlinable = true;\n+  enum availability avail;\n+  struct cgraph_node *callee = cgraph_function_or_thunk_node (e->callee, &avail);\n   tree caller_tree = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (e->caller->decl);\n-  tree callee_tree = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (e->callee->decl);\n+  tree callee_tree = callee ? DECL_FUNCTION_SPECIFIC_OPTIMIZATION (callee->decl) : NULL;\n \n   gcc_assert (e->inline_failed);\n \n-  if (!e->callee->analyzed)\n+  if (!callee || !callee->analyzed)\n     {\n       e->inline_failed = CIF_BODY_NOT_AVAILABLE;\n       inlinable = false;\n     }\n-  else if (!inline_summary (e->callee)->inlinable)\n+  else if (!inline_summary (callee)->inlinable)\n     {\n       e->inline_failed = CIF_FUNCTION_NOT_INLINABLE;\n       inlinable = false;\n     }\n-  else if (cgraph_function_body_availability (e->callee) <= AVAIL_OVERWRITABLE)\n+  else if (avail <= AVAIL_OVERWRITABLE)\n     {\n       e->inline_failed = CIF_OVERWRITABLE;\n       return false;\n@@ -264,9 +266,9 @@ can_inline_edge_p (struct cgraph_edge *e, bool report)\n     }\n   /* Don't inline if the functions have different EH personalities.  */\n   else if (DECL_FUNCTION_PERSONALITY (e->caller->decl)\n-\t   && DECL_FUNCTION_PERSONALITY (e->callee->decl)\n+\t   && DECL_FUNCTION_PERSONALITY (callee->decl)\n \t   && (DECL_FUNCTION_PERSONALITY (e->caller->decl)\n-\t       != DECL_FUNCTION_PERSONALITY (e->callee->decl)))\n+\t       != DECL_FUNCTION_PERSONALITY (callee->decl)))\n     {\n       e->inline_failed = CIF_EH_PERSONALITY;\n       inlinable = false;\n@@ -275,9 +277,9 @@ can_inline_edge_p (struct cgraph_edge *e, bool report)\n      caller cannot.\n      FIXME: this is obviously wrong for LTO where STRUCT_FUNCTION is missing.\n      Move the flag into cgraph node or mirror it in the inline summary.  */\n-  else if (DECL_STRUCT_FUNCTION (e->callee->decl)\n+  else if (DECL_STRUCT_FUNCTION (callee->decl)\n \t   && DECL_STRUCT_FUNCTION\n-\t        (e->callee->decl)->can_throw_non_call_exceptions\n+\t        (callee->decl)->can_throw_non_call_exceptions\n \t   && !(DECL_STRUCT_FUNCTION (e->caller->decl)\n \t        && DECL_STRUCT_FUNCTION\n \t\t     (e->caller->decl)->can_throw_non_call_exceptions))\n@@ -287,13 +289,13 @@ can_inline_edge_p (struct cgraph_edge *e, bool report)\n     }\n   /* Check compatibility of target optimization options.  */\n   else if (!targetm.target_option.can_inline_p (e->caller->decl,\n-\t\t\t\t\t\te->callee->decl))\n+\t\t\t\t\t\tcallee->decl))\n     {\n       e->inline_failed = CIF_TARGET_OPTION_MISMATCH;\n       inlinable = false;\n     }\n   /* Check if caller growth allows the inlining.  */\n-  else if (!DECL_DISREGARD_INLINE_LIMITS (e->callee->decl)\n+  else if (!DECL_DISREGARD_INLINE_LIMITS (callee->decl)\n \t   && !lookup_attribute (\"flatten\",\n \t\t\t\t DECL_ATTRIBUTES\n \t\t\t\t   (e->caller->global.inlined_to\n@@ -343,10 +345,12 @@ can_inline_edge_p (struct cgraph_edge *e, bool report)\n static bool\n can_early_inline_edge_p (struct cgraph_edge *e)\n {\n+  struct cgraph_node *callee = cgraph_function_or_thunk_node (e->callee,\n+\t\t\t\t\t\t\t      NULL);\n   /* Early inliner might get called at WPA stage when IPA pass adds new\n      function.  In this case we can not really do any of early inlining\n      because function bodies are missing.  */\n-  if (!gimple_has_body_p (e->callee->decl))\n+  if (!gimple_has_body_p (callee->decl))\n     {\n       e->inline_failed = CIF_BODY_NOT_AVAILABLE;\n       return false;\n@@ -356,7 +360,7 @@ can_early_inline_edge_p (struct cgraph_edge *e)\n      the callee by early inliner, yet).  We don't have CIF code for this\n      case; later we will re-do the decision in the real inliner.  */\n   if (!gimple_in_ssa_p (DECL_STRUCT_FUNCTION (e->caller->decl))\n-      || !gimple_in_ssa_p (DECL_STRUCT_FUNCTION (e->callee->decl)))\n+      || !gimple_in_ssa_p (DECL_STRUCT_FUNCTION (callee->decl)))\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"  edge not inlinable: not in SSA form\\n\");\n@@ -388,10 +392,11 @@ static bool\n want_early_inline_function_p (struct cgraph_edge *e)\n {\n   bool want_inline = true;\n+  struct cgraph_node *callee = cgraph_function_or_thunk_node (e->callee, NULL);\n \n-  if (DECL_DISREGARD_INLINE_LIMITS (e->callee->decl))\n+  if (DECL_DISREGARD_INLINE_LIMITS (callee->decl))\n     ;\n-  else if (!DECL_DECLARED_INLINE_P (e->callee->decl)\n+  else if (!DECL_DECLARED_INLINE_P (callee->decl)\n \t   && !flag_inline_small_functions)\n     {\n       e->inline_failed = CIF_FUNCTION_NOT_INLINE_CANDIDATE;\n@@ -410,18 +415,18 @@ want_early_inline_function_p (struct cgraph_edge *e)\n \t    fprintf (dump_file, \"  will not early inline: %s/%i->%s/%i, \"\n \t\t     \"call is cold and code would grow by %i\\n\",\n \t\t     cgraph_node_name (e->caller), e->caller->uid,\n-\t\t     cgraph_node_name (e->callee), e->callee->uid,\n+\t\t     cgraph_node_name (callee), callee->uid,\n \t\t     growth);\n \t  want_inline = false;\n \t}\n-      else if (!leaf_node_p (e->callee)\n+      else if (!leaf_node_p (callee)\n \t       && growth > 0)\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \"  will not early inline: %s/%i->%s/%i, \"\n \t\t     \"callee is not leaf and code would grow by %i\\n\",\n \t\t     cgraph_node_name (e->caller), e->caller->uid,\n-\t\t     cgraph_node_name (e->callee), e->callee->uid,\n+\t\t     cgraph_node_name (callee), callee->uid,\n \t\t     growth);\n \t  want_inline = false;\n \t}\n@@ -431,7 +436,7 @@ want_early_inline_function_p (struct cgraph_edge *e)\n \t    fprintf (dump_file, \"  will not early inline: %s/%i->%s/%i, \"\n \t\t     \"growth %i exceeds --param early-inlining-insns\\n\",\n \t\t     cgraph_node_name (e->caller), e->caller->uid,\n-\t\t     cgraph_node_name (e->callee), e->callee->uid,\n+\t\t     cgraph_node_name (callee), callee->uid,\n \t\t     growth);\n \t  want_inline = false;\n \t}\n@@ -446,10 +451,11 @@ static bool\n want_inline_small_function_p (struct cgraph_edge *e, bool report)\n {\n   bool want_inline = true;\n+  struct cgraph_node *callee = cgraph_function_or_thunk_node (e->callee, NULL);\n \n-  if (DECL_DISREGARD_INLINE_LIMITS (e->callee->decl))\n+  if (DECL_DISREGARD_INLINE_LIMITS (callee->decl))\n     ;\n-  else if (!DECL_DECLARED_INLINE_P (e->callee->decl)\n+  else if (!DECL_DECLARED_INLINE_P (callee->decl)\n \t   && !flag_inline_small_functions)\n     {\n       e->inline_failed = CIF_FUNCTION_NOT_INLINE_CANDIDATE;\n@@ -461,19 +467,19 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n \n       if (growth <= 0)\n \t;\n-      else if (DECL_DECLARED_INLINE_P (e->callee->decl)\n+      else if (DECL_DECLARED_INLINE_P (callee->decl)\n \t       && growth >= MAX_INLINE_INSNS_SINGLE)\n \t{\n           e->inline_failed = CIF_MAX_INLINE_INSNS_SINGLE_LIMIT;\n \t  want_inline = false;\n \t}\n-      else if (!DECL_DECLARED_INLINE_P (e->callee->decl)\n+      else if (!DECL_DECLARED_INLINE_P (callee->decl)\n \t       && !flag_inline_functions)\n \t{\n           e->inline_failed = CIF_NOT_DECLARED_INLINED;\n \t  want_inline = false;\n \t}\n-      else if (!DECL_DECLARED_INLINE_P (e->callee->decl)\n+      else if (!DECL_DECLARED_INLINE_P (callee->decl)\n \t       && growth >= MAX_INLINE_INSNS_AUTO)\n \t{\n           e->inline_failed = CIF_MAX_INLINE_INSNS_AUTO_LIMIT;\n@@ -495,7 +501,7 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n \t \"good\" calls, we will realize that keeping the function around is\n \t better.  */\n       else if (!cgraph_maybe_hot_edge_p (e)\n-\t       && (DECL_EXTERNAL (e->callee->decl)\n+\t       && (DECL_EXTERNAL (callee->decl)\n \n \t\t   /* Unlike for functions called once, we play unsafe with\n \t\t      COMDATs.  We can allow that since we know functions\n@@ -510,8 +516,8 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n \t\t      instead of\n \t\t      cgraph_will_be_removed_from_program_if_no_direct_calls  */\n \n-\t\t   || !cgraph_can_remove_if_no_direct_calls_p (e->callee)\n-\t\t   || estimate_growth (e->callee) > 0))\n+\t\t   || !cgraph_can_remove_if_no_direct_calls_p (callee)\n+\t\t   || estimate_growth (callee) > 0))\n \t{\n           e->inline_failed = CIF_UNLIKELY_CALL;\n \t  want_inline = false;\n@@ -544,7 +550,7 @@ want_inline_self_recursive_call_p (struct cgraph_edge *edge,\n   int caller_freq = CGRAPH_FREQ_BASE;\n   int max_depth = PARAM_VALUE (PARAM_MAX_INLINE_RECURSIVE_DEPTH_AUTO);\n \n-  if (DECL_DECLARED_INLINE_P (edge->callee->decl))\n+  if (DECL_DECLARED_INLINE_P (edge->caller->decl))\n     max_depth = PARAM_VALUE (PARAM_MAX_INLINE_RECURSIVE_DEPTH);\n \n   if (!cgraph_maybe_hot_edge_p (edge))\n@@ -644,6 +650,8 @@ want_inline_self_recursive_call_p (struct cgraph_edge *edge,\n static bool\n want_inline_function_called_once_p (struct cgraph_node *node)\n {\n+   if (node->alias)\n+     return false;\n    /* Already inlined?  */\n    if (node->global.inlined_to)\n      return false;\n@@ -708,9 +716,11 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n {\n   gcov_type badness;\n   int growth, time_growth;\n-  struct inline_summary *callee_info = inline_summary (edge->callee);\n+  struct cgraph_node *callee = cgraph_function_or_thunk_node (edge->callee,\n+\t\t\t\t\t\t\t      NULL);\n+  struct inline_summary *callee_info = inline_summary (callee);\n \n-  if (DECL_DISREGARD_INLINE_LIMITS (edge->callee->decl))\n+  if (DECL_DISREGARD_INLINE_LIMITS (callee->decl))\n     return INT_MIN;\n \n   growth = estimate_edge_growth (edge);\n@@ -720,7 +730,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n     {\n       fprintf (dump_file, \"    Badness calculation for %s -> %s\\n\",\n \t       cgraph_node_name (edge->caller),\n-\t       cgraph_node_name (edge->callee));\n+\t       cgraph_node_name (callee));\n       fprintf (dump_file, \"      size growth %i, time growth %i\\n\",\n \t       growth,\n \t       time_growth);\n@@ -808,7 +818,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t We might mix the valud into the fraction by taking into account\n \t relative growth of the unit, but for now just add the number\n \t into resulting fraction.  */\n-      growth_for_all = estimate_growth (edge->callee);\n+      growth_for_all = estimate_growth (callee);\n       badness += growth_for_all;\n       if (badness > INT_MAX - 1)\n \tbadness = INT_MAX - 1;\n@@ -828,7 +838,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n   else\n     {\n       int nest = MIN (inline_edge_summary (edge)->loop_depth, 8);\n-      badness = estimate_growth (edge->callee) * 256;\n+      badness = estimate_growth (callee) * 256;\n \n       /* Decrease badness if call is nested.  */\n       if (badness > 0)\n@@ -1002,13 +1012,16 @@ update_callee_keys (fibheap_t heap, struct cgraph_node *node,\n       e = e->callee->callees;\n     else\n       {\n+\tenum availability avail;\n+\tstruct cgraph_node *callee;\n \t/* We do not reset callee growth cache here.  Since we added a new call,\n \t   growth chould have just increased and consequentely badness metric\n            don't need updating.  */\n \tif (e->inline_failed\n-\t    && inline_summary (e->callee)->inlinable\n-\t    && cgraph_function_body_availability (e->callee) >= AVAIL_AVAILABLE\n-\t    && !bitmap_bit_p (updated_nodes, e->callee->uid))\n+\t    && (callee = cgraph_function_or_thunk_node (e->callee, &avail))\n+\t    && inline_summary (callee)->inlinable\n+\t    && cgraph_function_body_availability (callee) >= AVAIL_AVAILABLE\n+\t    && !bitmap_bit_p (updated_nodes, callee->uid))\n \t  {\n \t    if (can_inline_edge_p (e, false)\n \t\t&& want_inline_small_function_p (e, false))\n@@ -1044,19 +1057,21 @@ update_all_callee_keys (fibheap_t heap, struct cgraph_node *node,\n \t\t\tbitmap updated_nodes)\n {\n   struct cgraph_edge *e = node->callees;\n-\n   if (!e)\n     return;\n   while (true)\n     if (!e->inline_failed && e->callee->callees)\n       e = e->callee->callees;\n     else\n       {\n+\tstruct cgraph_node *callee = cgraph_function_or_thunk_node (e->callee,\n+\t\t\t\t\t\t\t\t    NULL);\n+\n \t/* We inlined and thus callees might have different number of calls.\n \t   Reset their caches  */\n-        reset_node_growth_cache (e->callee);\n+        reset_node_growth_cache (callee);\n \tif (e->inline_failed)\n-\t  update_caller_keys (heap, e->callee, updated_nodes, e);\n+\t  update_caller_keys (heap, callee, updated_nodes, e);\n \tif (e->next_callee)\n \t  e = e->next_callee;\n \telse\n@@ -1081,8 +1096,12 @@ lookup_recursive_calls (struct cgraph_node *node, struct cgraph_node *where,\n \t\t\tfibheap_t heap)\n {\n   struct cgraph_edge *e;\n+  enum availability avail;\n+\n   for (e = where->callees; e; e = e->next_callee)\n-    if (e->callee == node)\n+    if (e->callee == node\n+\t|| (cgraph_function_or_thunk_node (e->callee, &avail) == node\n+\t    && avail > AVAIL_OVERWRITABLE))\n       {\n \t/* When profile feedback is available, prioritize by expected number\n \t   of calls.  */\n@@ -1240,8 +1259,7 @@ add_new_edges_to_heap (fibheap_t heap, VEC (cgraph_edge_p, heap) *new_edges)\n       struct cgraph_edge *edge = VEC_pop (cgraph_edge_p, new_edges);\n \n       gcc_assert (!edge->aux);\n-      if (inline_summary (edge->callee)->inlinable\n-\t  && edge->inline_failed\n+      if (edge->inline_failed\n \t  && can_inline_edge_p (edge, true)\n \t  && want_inline_small_function_p (edge, true))\n         edge->aux = fibheap_insert (heap, edge_badness (edge, false), edge);\n@@ -1283,10 +1301,14 @@ inline_small_functions (void)\n   FOR_EACH_DEFINED_FUNCTION (node)\n     if (!node->global.inlined_to)\n       {\n-\tstruct inline_summary *info = inline_summary (node);\n+\tif (cgraph_function_with_gimple_body_p (node)\n+\t    || node->thunk.thunk_p)\n+\t  {\n+\t    struct inline_summary *info = inline_summary (node);\n \n-\tif (!DECL_EXTERNAL (node->decl))\n-\t  initial_size += info->size;\n+\t    if (!DECL_EXTERNAL (node->decl))\n+\t      initial_size += info->size;\n+\t  }\n \n \tfor (edge = node->callers; edge; edge = edge->next_caller)\n \t  if (max_count < edge->count)\n@@ -1355,14 +1377,14 @@ inline_small_functions (void)\n       if (!can_inline_edge_p (edge, true))\n \tcontinue;\n       \n-      callee = edge->callee;\n+      callee = cgraph_function_or_thunk_node (edge->callee, NULL);\n       growth = estimate_edge_growth (edge);\n       if (dump_file)\n \t{\n \t  fprintf (dump_file,\n \t\t   \"\\nConsidering %s with %i size\\n\",\n-\t\t   cgraph_node_name (edge->callee),\n-\t\t   inline_summary (edge->callee)->size);\n+\t\t   cgraph_node_name (callee),\n+\t\t   inline_summary (callee)->size);\n \t  fprintf (dump_file,\n \t\t   \" to be inlined into %s in %s:%i\\n\"\n \t\t   \" Estimated growth after inlined into all is %+i insns.\\n\"\n@@ -1372,7 +1394,7 @@ inline_small_functions (void)\n \t\t   : gimple_filename ((const_gimple) edge->call_stmt),\n \t\t   flag_wpa ? -1\n \t\t   : gimple_lineno ((const_gimple) edge->call_stmt),\n-\t\t   estimate_growth (edge->callee),\n+\t\t   estimate_growth (callee),\n \t\t   badness,\n \t\t   edge->frequency / (double)CGRAPH_FREQ_BASE);\n \t  if (edge->count)\n@@ -1383,7 +1405,7 @@ inline_small_functions (void)\n \t}\n \n       if (overall_size + growth > max_size\n-\t  && !DECL_DISREGARD_INLINE_LIMITS (edge->callee->decl))\n+\t  && !DECL_DISREGARD_INLINE_LIMITS (callee->decl))\n \t{\n \t  edge->inline_failed = CIF_INLINE_UNIT_GROWTH_LIMIT;\n \t  report_inline_failed_reason (edge);\n@@ -1418,7 +1440,6 @@ inline_small_functions (void)\n \t}\n       else\n \t{\n-\t  struct cgraph_node *callee;\n \t  struct cgraph_node *outer_node = NULL;\n \t  int depth = 0;\n \n@@ -1446,7 +1467,6 @@ inline_small_functions (void)\n \t  else if (depth && dump_file)\n \t    fprintf (dump_file, \" Peeling recursion with depth %i\\n\", depth);\n \n-\t  callee = edge->callee;\n \t  gcc_checking_assert (!callee->global.inlined_to);\n \t  inline_call (edge, true, &new_indirect_edges, &overall_size);\n \t  if (flag_indirect_inlining)\n@@ -1529,14 +1549,15 @@ flatten_function (struct cgraph_node *node, bool early)\n   for (e = node->callees; e; e = e->next_callee)\n     {\n       struct cgraph_node *orig_callee;\n+      struct cgraph_node *callee = cgraph_function_or_thunk_node (e->callee, NULL);\n \n       /* We've hit cycle?  It is time to give up.  */\n-      if (e->callee->aux)\n+      if (callee->aux)\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file,\n \t\t     \"Not inlining %s into %s to avoid cycle.\\n\",\n-\t\t     cgraph_node_name (e->callee),\n+\t\t     cgraph_node_name (callee),\n \t\t     cgraph_node_name (e->caller));\n \t  e->inline_failed = CIF_RECURSIVE_INLINING;\n \t  continue;\n@@ -1546,7 +1567,7 @@ flatten_function (struct cgraph_node *node, bool early)\n \t it in order to fully flatten the leaves.  */\n       if (!e->inline_failed)\n \t{\n-\t  flatten_function (e->callee, early);\n+\t  flatten_function (callee, early);\n \t  continue;\n \t}\n \n@@ -1566,7 +1587,7 @@ flatten_function (struct cgraph_node *node, bool early)\n \t}\n \n       if (gimple_in_ssa_p (DECL_STRUCT_FUNCTION (node->decl))\n-\t  != gimple_in_ssa_p (DECL_STRUCT_FUNCTION (e->callee->decl)))\n+\t  != gimple_in_ssa_p (DECL_STRUCT_FUNCTION (callee->decl)))\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \"Not inlining: SSA form does not match.\\n\");\n@@ -1577,9 +1598,9 @@ flatten_function (struct cgraph_node *node, bool early)\n          recursing through the original node if the node was cloned.  */\n       if (dump_file)\n \tfprintf (dump_file, \" Inlining %s into %s.\\n\",\n-\t\t cgraph_node_name (e->callee),\n+\t\t cgraph_node_name (callee),\n \t\t cgraph_node_name (e->caller));\n-      orig_callee = e->callee;\n+      orig_callee = callee;\n       inline_call (e, true, NULL, NULL);\n       if (e->callee != orig_callee)\n \torig_callee->aux = (void *) node;\n@@ -1727,7 +1748,8 @@ inline_always_inline_functions (struct cgraph_node *node)\n \n   for (e = node->callees; e; e = e->next_callee)\n     {\n-      if (!DECL_DISREGARD_INLINE_LIMITS (e->callee->decl))\n+      struct cgraph_node *callee = cgraph_function_or_thunk_node (e->callee, NULL);\n+      if (!DECL_DISREGARD_INLINE_LIMITS (callee->decl))\n \tcontinue;\n \n       if (cgraph_edge_recursive_p (e))\n@@ -1764,19 +1786,20 @@ early_inline_small_functions (struct cgraph_node *node)\n \n   for (e = node->callees; e; e = e->next_callee)\n     {\n-      if (!inline_summary (e->callee)->inlinable\n+      struct cgraph_node *callee = cgraph_function_or_thunk_node (e->callee, NULL);\n+      if (!inline_summary (callee)->inlinable\n \t  || !e->inline_failed)\n \tcontinue;\n \n       /* Do not consider functions not declared inline.  */\n-      if (!DECL_DECLARED_INLINE_P (e->callee->decl)\n+      if (!DECL_DECLARED_INLINE_P (callee->decl)\n \t  && !flag_inline_small_functions\n \t  && !flag_inline_functions)\n \tcontinue;\n \n       if (dump_file)\n \tfprintf (dump_file, \"Considering inline candidate %s.\\n\",\n-\t\t cgraph_node_name (e->callee));\n+\t\t cgraph_node_name (callee));\n \n       if (!can_early_inline_edge_p (e))\n \tcontinue;\n@@ -1793,7 +1816,7 @@ early_inline_small_functions (struct cgraph_node *node)\n \n       if (dump_file)\n \tfprintf (dump_file, \" Inlining %s into %s.\\n\",\n-\t\t cgraph_node_name (e->callee),\n+\t\t cgraph_node_name (callee),\n \t\t cgraph_node_name (e->caller));\n       inline_call (e, true, NULL, NULL);\n       inlined = true;"}]}