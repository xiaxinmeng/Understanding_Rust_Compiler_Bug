{"sha": "9ff56c9570642711d5b7ab29920ecf5dbff14a27", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWZmNTZjOTU3MDY0MjcxMWQ1YjdhYjI5OTIwZWNmNWRiZmYxNGEyNw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-05-20T00:18:15Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-05-20T00:18:15Z"}, "message": "Update to current version of Go library.\n\nFrom-SVN: r173931", "tree": {"sha": "c891bdec1e6f073f73fedeef23718bc3ac30d499", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c891bdec1e6f073f73fedeef23718bc3ac30d499"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ff56c9570642711d5b7ab29920ecf5dbff14a27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ff56c9570642711d5b7ab29920ecf5dbff14a27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ff56c9570642711d5b7ab29920ecf5dbff14a27", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ff56c9570642711d5b7ab29920ecf5dbff14a27/comments", "author": null, "committer": null, "parents": [{"sha": "37cb25ed7acdb844b218231130e54b8b7a0ff6e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37cb25ed7acdb844b218231130e54b8b7a0ff6e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37cb25ed7acdb844b218231130e54b8b7a0ff6e6"}], "stats": {"total": 23900, "additions": 19008, "deletions": 4892}, "files": [{"sha": "bf1921610c1065371bc395159aeb134ccd24f659", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 45, "deletions": 16, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -1432,7 +1432,7 @@ Type::methods_constructor(Gogo* gogo, Type* methods_type,\n        p != smethods.end();\n        ++p)\n     vals->push_back(this->method_constructor(gogo, method_type, p->first,\n-\t\t\t\t\t     p->second));\n+\t\t\t\t\t     p->second, only_value_methods));\n \n   return Expression::make_slice_composite_literal(methods_type, vals, bloc);\n }\n@@ -1444,7 +1444,8 @@ Type::methods_constructor(Gogo* gogo, Type* methods_type,\n Expression*\n Type::method_constructor(Gogo*, Type* method_type,\n \t\t\t const std::string& method_name,\n-\t\t\t const Method* m) const\n+\t\t\t const Method* m,\n+\t\t\t bool only_value_methods) const\n {\n   source_location bloc = BUILTINS_LOCATION;\n \n@@ -1487,6 +1488,25 @@ Type::method_constructor(Gogo*, Type* method_type,\n \n   ++p;\n   go_assert(p->field_name() == \"typ\");\n+  if (!only_value_methods && m->is_value_method())\n+    {\n+      // This is a value method on a pointer type.  Change the type of\n+      // the method to use a pointer receiver.  The implementation\n+      // always uses a pointer receiver anyhow.\n+      Type* rtype = mtype->receiver()->type();\n+      Type* prtype = Type::make_pointer_type(rtype);\n+      Typed_identifier* receiver =\n+\tnew Typed_identifier(mtype->receiver()->name(), prtype,\n+\t\t\t     mtype->receiver()->location());\n+      mtype = Type::make_function_type(receiver,\n+\t\t\t\t       (mtype->parameters() == NULL\n+\t\t\t\t\t? NULL\n+\t\t\t\t\t: mtype->parameters()->copy()),\n+\t\t\t\t       (mtype->results() == NULL\n+\t\t\t\t\t? NULL\n+\t\t\t\t\t: mtype->results()->copy()),\n+\t\t\t\t       mtype->location());\n+    }\n   vals->push_back(Expression::make_type_descriptor(mtype, bloc));\n \n   ++p;\n@@ -2779,14 +2799,7 @@ Function_type::type_descriptor_params(Type* params_type,\n \t\t+ (receiver != NULL ? 1 : 0));\n \n   if (receiver != NULL)\n-    {\n-      Type* rtype = receiver->type();\n-      // The receiver is always passed as a pointer.  FIXME: Is this\n-      // right?  Should that fact affect the type descriptor?\n-      if (rtype->points_to() == NULL)\n-\trtype = Type::make_pointer_type(rtype);\n-      vals->push_back(Expression::make_type_descriptor(rtype, bloc));\n-    }\n+    vals->push_back(Expression::make_type_descriptor(receiver->type(), bloc));\n \n   if (params != NULL)\n     {\n@@ -4822,9 +4835,10 @@ Array_type::make_array_type_descriptor_type()\n       Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n \n       Struct_type* sf =\n-\tType::make_builtin_struct_type(3,\n+\tType::make_builtin_struct_type(4,\n \t\t\t\t       \"\", tdt,\n \t\t\t\t       \"elem\", ptdt,\n+\t\t\t\t       \"slice\", ptdt,\n \t\t\t\t       \"len\", uintptr_type);\n \n       ret = Type::make_builtin_named_type(\"ArrayType\", sf);\n@@ -4890,6 +4904,11 @@ Array_type::array_type_descriptor(Gogo* gogo, Named_type* name)\n   go_assert(p->field_name() == \"elem\");\n   vals->push_back(Expression::make_type_descriptor(this->element_type_, bloc));\n \n+  ++p;\n+  go_assert(p->field_name() == \"slice\");\n+  Type* slice_type = Type::make_array_type(this->element_type_, NULL);\n+  vals->push_back(Expression::make_type_descriptor(slice_type, bloc));\n+\n   ++p;\n   go_assert(p->field_name() == \"len\");\n   vals->push_back(Expression::make_cast(p->type(), this->length_, bloc));\n@@ -5375,8 +5394,9 @@ Channel_type::do_make_expression_tree(Translate_context* context,\n   Gogo* gogo = context->gogo();\n   tree channel_type = type_to_tree(this->get_backend(gogo));\n \n-  tree element_tree = type_to_tree(this->element_type_->get_backend(gogo));\n-  tree element_size_tree = size_in_bytes(element_tree);\n+  Type* ptdt = Type::make_type_descriptor_ptr_type();\n+  tree element_type_descriptor =\n+    this->element_type_->type_descriptor_pointer(gogo);\n \n   tree bad_index = NULL_TREE;\n \n@@ -5402,8 +5422,8 @@ Channel_type::do_make_expression_tree(Translate_context* context,\n \t\t\t\t\"__go_new_channel\",\n \t\t\t\t2,\n \t\t\t\tchannel_type,\n-\t\t\t\tsizetype,\n-\t\t\t\telement_size_tree,\n+\t\t\t\ttype_to_tree(ptdt->get_backend(gogo)),\n+\t\t\t\telement_type_descriptor,\n \t\t\t\tsizetype,\n \t\t\t\texpr_tree);\n   if (ret == error_mark_node)\n@@ -6242,7 +6262,16 @@ Interface_type::do_reflection(Gogo* gogo, std::string* ret) const\n \t  if (p != this->methods_->begin())\n \t    ret->append(\";\");\n \t  ret->push_back(' ');\n-\t  ret->append(Gogo::unpack_hidden_name(p->name()));\n+\t  if (!Gogo::is_hidden_name(p->name()))\n+\t    ret->append(p->name());\n+\t  else\n+\t    {\n+\t      // This matches what the gc compiler does.\n+\t      std::string prefix = Gogo::hidden_name_prefix(p->name());\n+\t      ret->append(prefix.substr(prefix.find('.') + 1));\n+\t      ret->push_back('.');\n+\t      ret->append(Gogo::unpack_hidden_name(p->name()));\n+\t    }\n \t  std::string sub = p->type()->reflection(gogo);\n \t  go_assert(sub.compare(0, 4, \"func\") == 0);\n \t  sub = sub.substr(4);"}, {"sha": "3ada1b1f0f89f8a9aceca0107b2f71bb43501bc9", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -1044,7 +1044,7 @@ class Type\n   // Build a composite literal for one method.\n   Expression*\n   method_constructor(Gogo*, Type* method_type, const std::string& name,\n-\t\t     const Method*) const;\n+\t\t     const Method*, bool only_value_methods) const;\n \n   static tree\n   build_receive_return_type(tree type);"}, {"sha": "0a75663d0647f58ace06f60a1fc76c252939da4e", "filename": "gcc/testsuite/go.test/test/convert.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fconvert.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fconvert.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fconvert.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -8,7 +8,7 @@ package main\n \n import \"reflect\"\n \n-func typeof(x interface{}) string { return reflect.Typeof(x).String() }\n+func typeof(x interface{}) string { return reflect.TypeOf(x).String() }\n \n func f() int { return 0 }\n "}, {"sha": "a120ad0abf2fd647acb4b5beb8313e75412ecba4", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug177.go", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug177.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug177.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug177.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -5,23 +5,26 @@\n // license that can be found in the LICENSE file.\n \n package main\n+\n import \"reflect\"\n-type S1 struct { i int }\n-type S2 struct { S1 }\n+\n+type S1 struct{ i int }\n+type S2 struct{ S1 }\n+\n func main() {\n-\ttyp := reflect.Typeof(S2{}).(*reflect.StructType);\n-\tf := typ.Field(0);\n+\ttyp := reflect.TypeOf(S2{})\n+\tf := typ.Field(0)\n \tif f.Name != \"S1\" || f.Anonymous != true {\n-\t\tprintln(\"BUG: \", f.Name, f.Anonymous);\n-\t\treturn;\n+\t\tprintln(\"BUG: \", f.Name, f.Anonymous)\n+\t\treturn\n \t}\n-\tf, ok := typ.FieldByName(\"S1\");\n+\tf, ok := typ.FieldByName(\"S1\")\n \tif !ok {\n-\t\tprintln(\"BUG: missing S1\");\n-\t\treturn;\n+\t\tprintln(\"BUG: missing S1\")\n+\t\treturn\n \t}\n \tif !f.Anonymous {\n-\t\tprintln(\"BUG: S1 is not anonymous\");\n-\t\treturn;\n+\t\tprintln(\"BUG: S1 is not anonymous\")\n+\t\treturn\n \t}\n }"}, {"sha": "b6c816a5cef0fe99f6851868f9e99c9618ac0614", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug248.dir/bug2.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug248.dir%2Fbug2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug248.dir%2Fbug2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug248.dir%2Fbug2.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -38,11 +38,11 @@ func main() {\n \t// meaning that reflect data for v0, v1 didn't get confused.\n \n \t// path is full (rooted) path name.  check suffix for gc, prefix for gccgo\n-\tif s := reflect.Typeof(v0).PkgPath(); !strings.HasSuffix(s, \"/bug0\") && !strings.HasPrefix(s, \"bug0\") {\n+\tif s := reflect.TypeOf(v0).PkgPath(); !strings.HasSuffix(s, \"/bug0\") && !strings.HasPrefix(s, \"bug0\") {\n \t\tprintln(\"bad v0 path\", len(s), s)\n \t\tpanic(\"fail\")\n \t}\n-\tif s := reflect.Typeof(v1).PkgPath(); !strings.HasSuffix(s, \"/bug1\") && !strings.HasPrefix(s, \"bug1\") {\n+\tif s := reflect.TypeOf(v1).PkgPath(); !strings.HasSuffix(s, \"/bug1\") && !strings.HasPrefix(s, \"bug1\") {\n \t\tprintln(\"bad v1 path\", s)\n \t\tpanic(\"fail\")\n \t}"}, {"sha": "bdc5b9072c34db948128f9e8ec1c6d7ecf1a07f6", "filename": "gcc/testsuite/go.test/test/interface/fake.go", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Finterface%2Ffake.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Finterface%2Ffake.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Finterface%2Ffake.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -46,34 +46,34 @@ func main() {\n \tx.t = add(\"abc\", \"def\")\n \tx.u = 1\n \tx.v = 2\n-\tx.w = 1<<28\n-\tx.x = 2<<28\n+\tx.w = 1 << 28\n+\tx.x = 2 << 28\n \tx.y = 0x12345678\n \tx.z = x.y\n \n \t// check mem and string\n-\tv := reflect.NewValue(x)\n-\ti := v.(*reflect.StructValue).Field(0)\n-\tj := v.(*reflect.StructValue).Field(1)\n+\tv := reflect.ValueOf(x)\n+\ti := v.Field(0)\n+\tj := v.Field(1)\n \tassert(i.Interface() == j.Interface())\n \n-\ts := v.(*reflect.StructValue).Field(2)\n-\tt := v.(*reflect.StructValue).Field(3)\n+\ts := v.Field(2)\n+\tt := v.Field(3)\n \tassert(s.Interface() == t.Interface())\n \n \t// make sure different values are different.\n \t// make sure whole word is being compared,\n \t// not just a single byte.\n-\ti = v.(*reflect.StructValue).Field(4)\n-\tj = v.(*reflect.StructValue).Field(5)\n+\ti = v.Field(4)\n+\tj = v.Field(5)\n \tassert(i.Interface() != j.Interface())\n \n-\ti = v.(*reflect.StructValue).Field(6)\n-\tj = v.(*reflect.StructValue).Field(7)\n+\ti = v.Field(6)\n+\tj = v.Field(7)\n \tassert(i.Interface() != j.Interface())\n \n-\ti = v.(*reflect.StructValue).Field(8)\n-\tj = v.(*reflect.StructValue).Field(9)\n+\ti = v.Field(8)\n+\tj = v.Field(9)\n \tassert(i.Interface() == j.Interface())\n }\n "}, {"sha": "fa6ff1d52ee6ba625c41991728260d02e369cae6", "filename": "gcc/testsuite/go.test/test/ken/cplx3.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fken%2Fcplx3.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fken%2Fcplx3.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fken%2Fcplx3.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -25,9 +25,9 @@ func main() {\n \tprintln(c)\n \n \tvar a interface{}\n-\tswitch c := reflect.NewValue(a).(type) {\n-\tcase *reflect.ComplexValue:\n-\t\tv := c.Get()\n+\tswitch c := reflect.ValueOf(a); c.Kind() {\n+\tcase reflect.Complex64, reflect.Complex128:\n+\t\tv := c.Complex()\n \t\t_, _ = complex128(v), true\n \t}\n }"}, {"sha": "9cee703c403de505f86c2198b4cd5f26edcbe7cf", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -1,4 +1,4 @@\n-f618e5e0991d\n+aea0ba6e5935\n \n The first line of this file holds the Mercurial revision number of the\n last merge done from the master library sources."}, {"sha": "ae6848f0932038f51221b0c4c1dcdf82711e546b", "filename": "libgo/Makefile.am", "status": "modified", "additions": 179, "deletions": 40, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -248,7 +248,8 @@ toolexeclibgogo_DATA = \\\n \tgo/printer.gox \\\n \tgo/scanner.gox \\\n \tgo/token.gox \\\n-\tgo/typechecker.gox\n+\tgo/typechecker.gox \\\n+\tgo/types.gox\n \n toolexeclibgohashdir = $(toolexeclibgodir)/hash\n \n@@ -262,14 +263,19 @@ toolexeclibgohttpdir = $(toolexeclibgodir)/http\n \n toolexeclibgohttp_DATA = \\\n \thttp/cgi.gox \\\n+\thttp/fcgi.gox \\\n \thttp/httptest.gox \\\n-\thttp/pprof.gox\n+\thttp/pprof.gox \\\n+\thttp/spdy.gox\n \n toolexeclibgoimagedir = $(toolexeclibgodir)/image\n \n toolexeclibgoimage_DATA = \\\n+\timage/gif.gox \\\n \timage/jpeg.gox \\\n-\timage/png.gox\n+\timage/png.gox \\\n+\timage/tiff.gox \\\n+\timage/ycbcr.gox\n \n toolexeclibgoindexdir = $(toolexeclibgodir)/index\n \n@@ -303,6 +309,7 @@ endif\n \n toolexeclibgoos_DATA = \\\n \t$(os_inotify_gox) \\\n+\tos/user.gox \\\n \tos/signal.gox\n \n toolexeclibgopathdir = $(toolexeclibgodir)/path\n@@ -404,6 +411,7 @@ runtime_files = \\\n \truntime/go-send-nb-big.c \\\n \truntime/go-send-nb-small.c \\\n \truntime/go-send-small.c \\\n+\truntime/go-setenv.c \\\n \truntime/go-signal.c \\\n \truntime/go-strcmp.c \\\n \truntime/go-string-to-byte-array.c \\\n@@ -560,6 +568,7 @@ go_http_files = \\\n \tgo/http/persist.go \\\n \tgo/http/request.go \\\n \tgo/http/response.go \\\n+\tgo/http/reverseproxy.go \\\n \tgo/http/server.go \\\n \tgo/http/status.go \\\n \tgo/http/transfer.go \\\n@@ -656,8 +665,17 @@ go_net_newpollserver_file = go/net/newpollserver.go\n endif # !LIBGO_IS_LINUX\n endif # !LIBGO_IS_RTEMS\n \n+if LIBGO_IS_LINUX\n+go_net_cgo_file = go/net/cgo_linux.go\n+go_net_sock_file = go/net/sock_linux.go\n+else\n+go_net_cgo_file = go/net/cgo_bsd.go\n+go_net_sock_file = go/net/sock_bsd.go\n+endif\n+\n go_net_files = \\\n-\tgo/net/cgo_stub.go \\\n+\tgo/net/cgo_unix.go \\\n+\t$(go_net_cgo_file) \\\n \tgo/net/dial.go \\\n \tgo/net/dnsclient.go \\\n \tgo/net/dnsconfig.go \\\n@@ -676,6 +694,7 @@ go_net_files = \\\n \tgo/net/pipe.go \\\n \tgo/net/port.go \\\n \tgo/net/sock.go \\\n+\t$(go_net_sock_file) \\\n \tgo/net/tcpsock.go \\\n \tgo/net/udpsock.go \\\n \tgo/net/unixsock.go\n@@ -1002,7 +1021,6 @@ go_crypto_subtle_files = \\\n \tgo/crypto/subtle/constant_time.go\n go_crypto_tls_files = \\\n \tgo/crypto/tls/alert.go \\\n-\tgo/crypto/tls/ca_set.go \\\n \tgo/crypto/tls/cipher_suites.go \\\n \tgo/crypto/tls/common.go \\\n \tgo/crypto/tls/conn.go \\\n@@ -1015,6 +1033,8 @@ go_crypto_tls_files = \\\n go_crypto_twofish_files = \\\n \tgo/crypto/twofish/twofish.go\n go_crypto_x509_files = \\\n+\tgo/crypto/x509/cert_pool.go \\\n+\tgo/crypto/x509/verify.go \\\n \tgo/crypto/x509/x509.go\n go_crypto_xtea_files = \\\n \tgo/crypto/xtea/block.go \\\n@@ -1130,6 +1150,12 @@ go_go_typechecker_files = \\\n \tgo/go/typechecker/type.go \\\n \tgo/go/typechecker/typechecker.go \\\n \tgo/go/typechecker/universe.go\n+go_go_types_files = \\\n+\tgo/go/types/const.go \\\n+\tgo/go/types/exportdata.go \\\n+\tgo/go/types/gcimporter.go \\\n+\tgo/go/types/types.go \\\n+\tgo/go/types/universe.go\n \n go_hash_adler32_files = \\\n \tgo/hash/adler32/adler32.go\n@@ -1143,21 +1169,39 @@ go_hash_fnv_files = \\\n go_http_cgi_files = \\\n \tgo/http/cgi/child.go \\\n \tgo/http/cgi/host.go\n+go_http_fcgi_files = \\\n+\tgo/http/fcgi/child.go \\\n+\tgo/http/fcgi/fcgi.go\n go_http_httptest_files = \\\n \tgo/http/httptest/recorder.go \\\n \tgo/http/httptest/server.go\n go_http_pprof_files = \\\n \tgo/http/pprof/pprof.go\n+go_http_spdy_files = \\\n+\tgo/http/spdy/protocol.go\n+\n+go_image_gif_files = \\\n+\tgo/image/gif/reader.go\n \n go_image_jpeg_files = \\\n+\tgo/image/jpeg/fdct.go \\\n \tgo/image/jpeg/huffman.go \\\n \tgo/image/jpeg/idct.go \\\n-\tgo/image/jpeg/reader.go\n+\tgo/image/jpeg/reader.go \\\n+\tgo/image/jpeg/writer.go\n \n go_image_png_files = \\\n \tgo/image/png/reader.go \\\n \tgo/image/png/writer.go\n \n+go_image_tiff_files = \\\n+\tgo/image/tiff/buffer.go \\\n+\tgo/image/tiff/consts.go \\\n+\tgo/image/tiff/reader.go\n+\n+go_image_ycbcr_files = \\\n+\tgo/image/ycbcr/ycbcr.go\n+\n go_index_suffixarray_files = \\\n \tgo/index/suffixarray/qsufsort.go \\\n \tgo/index/suffixarray/suffixarray.go\n@@ -1167,6 +1211,7 @@ go_io_ioutil_files = \\\n \tgo/io/ioutil/tempfile.go\n \n go_mime_multipart_files = \\\n+\tgo/mime/multipart/formdata.go \\\n \tgo/mime/multipart/multipart.go\n \n go_net_dict_files = \\\n@@ -1182,6 +1227,10 @@ go_net_textproto_files = \\\n go_os_inotify_files = \\\n \tgo/os/inotify/inotify_linux.go\n \n+go_os_user_files = \\\n+\tgo/os/user/user.go \\\n+\tgo/os/user/lookup_unix.go\n+\n go_os_signal_files = \\\n \tgo/os/signal/signal.go \\\n \tunix.go\n@@ -1485,21 +1534,28 @@ libgo_go_objs = \\\n \tgo/scanner.lo \\\n \tgo/token.lo \\\n \tgo/typechecker.lo \\\n+\tgo/types.lo \\\n \thash/adler32.lo \\\n \thash/crc32.lo \\\n \thash/crc64.lo \\\n \thash/fnv.lo \\\n \thttp/cgi.lo \\\n+\thttp/fcgi.lo \\\n \thttp/httptest.lo \\\n \thttp/pprof.lo \\\n+\thttp/spdy.lo \\\n+\timage/gif.lo \\\n \timage/jpeg.lo \\\n \timage/png.lo \\\n+\timage/tiff.lo \\\n+\timage/ycbcr.lo \\\n \tindex/suffixarray.lo \\\n \tio/ioutil.lo \\\n \tmime/multipart.lo \\\n \tnet/dict.lo \\\n \tnet/textproto.lo \\\n \t$(os_lib_inotify_lo) \\\n+\tos/user.lo \\\n \tos/signal.lo \\\n \tpath/filepath.lo \\\n \trpc/jsonrpc.lo \\\n@@ -1711,11 +1767,12 @@ html/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: html/check\n \n-http/http.lo: $(go_http_files) bufio.gox bytes.gox container/vector.gox \\\n-\t\tcrypto/rand.gox crypto/tls.gox encoding/base64.gox fmt.gox \\\n-\t\tio.gox io/ioutil.gox log.gox mime.gox mime/multipart.gox \\\n-\t\tnet.gox net/textproto.gox os.gox path.gox path/filepath.gox \\\n-\t\tsort.gox strconv.gox strings.gox sync.gox time.gox utf8.gox\n+http/http.lo: $(go_http_files) bufio.gox bytes.gox compress/gzip.gox \\\n+\t\tcontainer/vector.gox crypto/rand.gox crypto/tls.gox \\\n+\t\tencoding/base64.gox fmt.gox io.gox io/ioutil.gox log.gox \\\n+\t\tmime.gox mime/multipart.gox net.gox net/textproto.gox os.gox \\\n+\t\tpath.gox path/filepath.gox sort.gox strconv.gox strings.gox \\\n+\t\tsync.gox time.gox utf8.gox\n \t$(BUILDPACKAGE)\n http/check: $(CHECK_DEPS)\n \t@$(CHECK)\n@@ -1755,16 +1812,16 @@ math/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: math/check\n \n-mime/mime.lo: $(go_mime_files) bufio.gox bytes.gox os.gox strings.gox \\\n+mime/mime.lo: $(go_mime_files) bufio.gox bytes.gox fmt.gox os.gox strings.gox \\\n \t\tsync.gox unicode.gox\n \t$(BUILDPACKAGE)\n mime/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: mime/check\n \n net/net.lo: $(go_net_files) bytes.gox fmt.gox io.gox os.gox rand.gox \\\n-\t\treflect.gox strconv.gox strings.gox sync.gox syscall.gox \\\n-\t\ttime.gox\n+\t\treflect.gox sort.gox strconv.gox strings.gox sync.gox \\\n+\t\tsyscall.gox time.gox\n \t$(BUILDPACKAGE)\n net/check: $(CHECK_DEPS)\n \t@$(CHECK_ON_REQUEST)\n@@ -1945,8 +2002,8 @@ xml/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: xml/check\n \n-archive/tar.lo: $(go_archive_tar_files) bytes.gox io.gox os.gox strconv.gox \\\n-\t\tstrings.gox\n+archive/tar.lo: $(go_archive_tar_files) bytes.gox io.gox io/ioutil.gox os.gox \\\n+\t\tstrconv.gox strings.gox\n \t$(BUILDPACKAGE)\n archive/tar/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) archive/tar\n@@ -2148,8 +2205,7 @@ crypto/ripemd160/check: $(CHECK_DEPS)\n .PHONY: crypto/ripemd160/check\n \n crypto/rsa.lo: $(go_crypto_rsa_files) big.gox crypto.gox crypto/sha1.gox \\\n-\t\tcrypto/subtle.gox encoding/hex.gox hash.gox io.gox os.gox \\\n-\t\tsync.gox\n+\t\tcrypto/subtle.gox encoding/hex.gox hash.gox io.gox os.gox\n \t$(BUILDPACKAGE)\n crypto/rsa/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/rsa\n@@ -2184,13 +2240,13 @@ crypto/subtle/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: crypto/subtle/check\n \n-crypto/tls.lo: $(go_crypto_tls_files) big.gox bufio.gox bytes.gox \\\n-\t\tcontainer/list.gox crypto.gox crypto/aes.gox crypto/cipher.gox \\\n-\t\tcrypto/elliptic.gox crypto/hmac.gox crypto/md5.gox \\\n-\t\tcrypto/rc4.gox crypto/rand.gox crypto/rsa.gox crypto/sha1.gox \\\n-\t\tcrypto/subtle.gox crypto/rsa.gox crypto/sha1.gox \\\n-\t\tcrypto/x509.gox encoding/pem.gox fmt.gox hash.gox io.gox \\\n-\t\tio/ioutil.gox net.gox os.gox strings.gox sync.gox time.gox\n+crypto/tls.lo: $(go_crypto_tls_files) big.gox bytes.gox crypto.gox \\\n+\t\tcrypto/aes.gox crypto/cipher.gox crypto/elliptic.gox \\\n+\t\tcrypto/hmac.gox crypto/md5.gox crypto/rand.gox crypto/rc4.gox \\\n+\t\tcrypto/rsa.gox crypto/sha1.gox crypto/subtle.gox \\\n+\t\tcrypto/x509.gox encoding/pem.gox hash.gox io.gox \\\n+\t\tio/ioutil.gox net.gox os.gox strconv.gox strings.gox sync.gox \\\n+\t\ttime.gox\n \t$(BUILDPACKAGE)\n crypto/tls/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/tls\n@@ -2204,9 +2260,10 @@ crypto/twofish/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: crypto/twofish/check\n \n-crypto/x509.lo: $(go_crypto_x509_files) asn1.gox big.gox container/vector.gox \\\n-\t\tcrypto.gox crypto/rsa.gox crypto/sha1.gox hash.gox os.gox \\\n-\t\tstrings.gox time.gox\n+crypto/x509.lo: $(go_crypto_x509_files) asn1.gox big.gox bytes.gox \\\n+\t\tcontainer/vector.gox crypto.gox crypto/rsa.gox \\\n+\t\tcrypto/sha1.gox encoding/pem.gox hash.gox os.gox strings.gox \\\n+\t\ttime.gox\n \t$(BUILDPACKAGE)\n crypto/x509/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/x509\n@@ -2220,9 +2277,8 @@ crypto/xtea/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: crypto/xtea/check\n \n-crypto/openpgp/armor.lo: $(go_crypto_openpgp_armor_files) bytes.gox \\\n-\t\tcrypto/openpgp/error.gox encoding/base64.gox \\\n-\t\tencoding/line.gox io.gox os.gox\n+crypto/openpgp/armor.lo: $(go_crypto_openpgp_armor_files) bufio.gox bytes.gox \\\n+\t\tcrypto/openpgp/error.gox encoding/base64.gox io.gox os.gox\n \t$(BUILDPACKAGE)\n crypto/openpgp/armor/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/openpgp/armor\n@@ -2374,7 +2430,7 @@ exp/datafmt/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: exp/datafmt/check\n \n-exp/draw.lo: $(go_exp_draw_files) image.gox os.gox\n+exp/draw.lo: $(go_exp_draw_files) image.gox image/ycbcr.gox os.gox\n \t$(BUILDPACKAGE)\n exp/draw/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) exp/draw\n@@ -2448,6 +2504,15 @@ go/typechecker/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: go/typechecker/check\n \n+go/types.lo: $(go_go_types_files) big.gox bufio.gox fmt.gox go/ast.gox \\\n+\t\tgo/token.gox io.gox os.gox path/filepath.gox runtime.gox \\\n+\t\tscanner.gox strconv.gox strings.gox\n+\t$(BUILDPACKAGE)\n+go/types/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) go/types\n+\t@$(CHECK)\n+.PHONY: go/types/check\n+\n hash/adler32.lo: $(go_hash_adler32_files) hash.gox os.gox\n \t$(BUILDPACKAGE)\n hash/adler32/check: $(CHECK_DEPS)\n@@ -2476,15 +2541,25 @@ hash/fnv/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: hash/fnv/check\n \n-http/cgi.lo: $(go_http_cgi_files) bufio.gox bytes.gox encoding/line.gox \\\n-\t\texec.gox fmt.gox http.gox io.gox io/ioutil.gox log.gox \\\n-\t\tos.gox path/filepath.gox regexp.gox strconv.gox strings.gox\n+http/cgi.lo: $(go_http_cgi_files) bufio.gox bytes.gox crypto/tls.gox \\\n+\t\texec.gox fmt.gox http.gox net.gox io.gox io/ioutil.gox \\\n+\t\tlog.gox os.gox path/filepath.gox regexp.gox strconv.gox \\\n+\t\tstrings.gox\n \t$(BUILDPACKAGE)\n http/cgi/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) http/cgi\n \t@$(CHECK)\n .PHONY: http/cgi/check\n \n+http/fcgi.lo: $(go_http_fcgi_files) bufio.gox bytes.gox encoding/binary.gox \\\n+\t\tfmt.gox http.gox http/cgi.gox io.gox net.gox os.gox sync.gox \\\n+\t\ttime.gox\n+\t$(BUILDPACKAGE)\n+http/fcgi/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) http/fcgi\n+\t@$(CHECK)\n+.PHONY: http/fcgi/check\n+\n http/httptest.lo: $(go_http_httptest_files) bytes.gox crypto/rand.gox \\\n \t\tcrypto/tls.gox fmt.gox http.gox net.gox os.gox time.gox\n \t$(BUILDPACKAGE)\n@@ -2493,15 +2568,33 @@ http/httptest/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: http/httptest/check\n \n-http/pprof.lo: $(go_http_pprof_files) bufio.gox fmt.gox http.gox os.gox \\\n-\t\truntime.gox runtime/pprof.gox strconv.gox strings.gox\n+http/pprof.lo: $(go_http_pprof_files) bufio.gox bytes.gox fmt.gox http.gox \\\n+\t\tos.gox runtime.gox runtime/pprof.gox strconv.gox strings.gox\n \t$(BUILDPACKAGE)\n http/pprof/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) http/pprof\n \t@$(CHECK)\n .PHONY: http/pprof/check\n \n-image/jpeg.lo: $(go_image_jpeg_files) bufio.gox image.gox io.gox os.gox\n+http/spdy.lo: $(go_http_spdy_files) bytes.gox compress/zlib.gox \\\n+\t\tencoding/binary.gox http.gox io.gox os.gox strconv.gox \\\n+\t\tstrings.gox sync.gox\n+\t$(BUILDPACKAGE)\n+http/spdy/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) http/spdy\n+\t@$(CHECK)\n+.PHONY: http/spdy/check\n+\n+image/gif.lo: $(go_image_gif_files) bufio.gox compress/lzw.gox fmt.gox \\\n+\t\timage.gox io.gox os.gox\n+\t$(BUILDPACKAGE)\n+image/gif/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) image/gif\n+\t@$(CHECK)\n+.PHONY: image/gif/check\n+\n+image/jpeg.lo: $(go_image_jpeg_files) bufio.gox image.gox image/ycbcr.gox \\\n+\t\tio.gox os.gox\n \t$(BUILDPACKAGE)\n image/jpeg/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) image/jpeg\n@@ -2516,6 +2609,21 @@ image/png/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: image/png/check\n \n+image/tiff.lo: $(go_image_tiff_files) compress/lzw.gox compress/zlib.gox \\\n+\t\tencoding/binary.gox image.gox io.gox io/ioutil.gox os.gox\n+\t$(BUILDPACKAGE)\n+image/tiff/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) image/tiff\n+\t@$(CHECK)\n+.PHONY: image/tiff/check\n+\n+image/ycbcr.lo: $(go_image_ycbcr_files) image.gox\n+\t$(BUILDPACKAGE)\n+image/ycbcr/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) image/ycbcr\n+\t@$(CHECK)\n+.PHONY: image/ycbcr/check\n+\n index/suffixarray.lo: $(go_index_suffixarray_files) bytes.gox regexp.gox \\\n \t\tsort.gox\n \t$(BUILDPACKAGE)\n@@ -2532,8 +2640,9 @@ io/ioutil/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: io/ioutil/check\n \n-mime/multipart.lo: $(go_mime_multipart_files) bufio.gox bytes.gox io.gox \\\n-\t\tmime.gox net/textproto.gox os.gox regexp.gox strings.gox\n+mime/multipart.lo: $(go_mime_multipart_files) bufio.gox bytes.gox fmt.gox \\\n+\t\tio.gox io/ioutil.gox mime.gox net/textproto.gox os.gox \\\n+\t\tregexp.gox\n \t$(BUILDPACKAGE)\n mime/multipart/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) mime/multipart\n@@ -2560,6 +2669,14 @@ os/inotify/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: os/inotify/check\n \n+os/user.lo: $(go_os_user_files) fmt.gox os.gox runtime.gox strconv.gox \\\n+\t\tstrings.gox syscall.gox\n+\t$(BUILDPACKAGE)\n+os/user/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) os/user\n+\t@$(CHECK)\n+.PHONY: os/user/check\n+\n os/signal.lo: $(go_os_signal_files) runtime.gox strconv.gox\n \t$(BUILDPACKAGE)\n os/signal/check: $(CHECK_DEPS)\n@@ -2886,6 +3003,8 @@ go/token.gox: go/token.lo\n \t$(BUILDGOX)\n go/typechecker.gox: go/typechecker.lo\n \t$(BUILDGOX)\n+go/types.gox: go/types.lo\n+\t$(BUILDGOX)\n \n hash/adler32.gox: hash/adler32.lo\n \t$(BUILDGOX)\n@@ -2898,15 +3017,25 @@ hash/fnv.gox: hash/fnv.lo\n \n http/cgi.gox: http/cgi.lo\n \t$(BUILDGOX)\n+http/fcgi.gox: http/fcgi.lo\n+\t$(BUILDGOX)\n http/httptest.gox: http/httptest.lo\n \t$(BUILDGOX)\n http/pprof.gox: http/pprof.lo\n \t$(BUILDGOX)\n+http/spdy.gox: http/spdy.lo\n+\t$(BUILDGOX)\n \n+image/gif.gox: image/gif.lo\n+\t$(BUILDGOX)\n image/jpeg.gox: image/jpeg.lo\n \t$(BUILDGOX)\n image/png.gox: image/png.lo\n \t$(BUILDGOX)\n+image/tiff.gox: image/tiff.lo\n+\t$(BUILDGOX)\n+image/ycbcr.gox: image/ycbcr.lo\n+\t$(BUILDGOX)\n \n index/suffixarray.gox: index/suffixarray.lo\n \t$(BUILDGOX)\n@@ -2924,6 +3053,8 @@ net/textproto.gox: net/textproto.lo\n \n os/inotify.gox: os/inotify.lo\n \t$(BUILDGOX)\n+os/user.gox: os/user.lo\n+\t$(BUILDGOX)\n os/signal.gox: os/signal.lo\n \t$(BUILDGOX)\n \n@@ -3054,22 +3185,30 @@ TEST_PACKAGES = \\\n \texp/datafmt/check \\\n \texp/draw/check \\\n \texp/eval/check \\\n+\tgo/ast/check \\\n \tgo/parser/check \\\n \tgo/printer/check \\\n \tgo/scanner/check \\\n \tgo/token/check \\\n \tgo/typechecker/check \\\n+\t$(go_types_check_omitted_since_it_calls_6g) \\\n \thash/adler32/check \\\n \thash/crc32/check \\\n \thash/crc64/check \\\n \thash/fnv/check \\\n \thttp/cgi/check \\\n+\thttp/fcgi/check \\\n+\thttp/spdy/check \\\n+\timage/jpeg/check \\\n \timage/png/check \\\n+\timage/tiff/check \\\n+\timage/ycbcr/check \\\n \tindex/suffixarray/check \\\n \tio/ioutil/check \\\n \tmime/multipart/check \\\n \tnet/textproto/check \\\n \t$(os_inotify_check) \\\n+\tos/user/check \\\n \tos/signal/check \\\n \tpath/filepath/check \\\n \trpc/jsonrpc/check \\"}, {"sha": "10d0a4e4e2085d8332a955cf69b519e38c99c71b", "filename": "libgo/Makefile.in", "status": "modified", "additions": 199, "deletions": 51, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -155,15 +155,17 @@ am__DEPENDENCIES_2 = asn1/asn1.lo big/big.lo bufio/bufio.lo \\\n \tencoding/binary.lo encoding/git85.lo encoding/hex.lo \\\n \tencoding/line.lo encoding/pem.lo exp/datafmt.lo exp/draw.lo \\\n \texp/eval.lo go/ast.lo go/doc.lo go/parser.lo go/printer.lo \\\n-\tgo/scanner.lo go/token.lo go/typechecker.lo hash/adler32.lo \\\n-\thash/crc32.lo hash/crc64.lo hash/fnv.lo http/cgi.lo \\\n-\thttp/httptest.lo http/pprof.lo image/jpeg.lo image/png.lo \\\n-\tindex/suffixarray.lo io/ioutil.lo mime/multipart.lo \\\n-\tnet/dict.lo net/textproto.lo $(am__DEPENDENCIES_1) \\\n-\tos/signal.lo path/filepath.lo rpc/jsonrpc.lo runtime/debug.lo \\\n-\truntime/pprof.lo sync/atomic.lo sync/atomic_c.lo \\\n-\tsyscalls/syscall.lo syscalls/errno.lo testing/testing.lo \\\n-\ttesting/iotest.lo testing/quick.lo testing/script.lo\n+\tgo/scanner.lo go/token.lo go/typechecker.lo go/types.lo \\\n+\thash/adler32.lo hash/crc32.lo hash/crc64.lo hash/fnv.lo \\\n+\thttp/cgi.lo http/fcgi.lo http/httptest.lo http/pprof.lo \\\n+\thttp/spdy.lo image/gif.lo image/jpeg.lo image/png.lo \\\n+\timage/tiff.lo image/ycbcr.lo index/suffixarray.lo io/ioutil.lo \\\n+\tmime/multipart.lo net/dict.lo net/textproto.lo \\\n+\t$(am__DEPENDENCIES_1) os/user.lo os/signal.lo path/filepath.lo \\\n+\trpc/jsonrpc.lo runtime/debug.lo runtime/pprof.lo \\\n+\tsync/atomic.lo sync/atomic_c.lo syscalls/syscall.lo \\\n+\tsyscalls/errno.lo testing/testing.lo testing/iotest.lo \\\n+\ttesting/quick.lo testing/script.lo\n libgo_la_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1) \\\n \t$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \\\n \t$(am__DEPENDENCIES_1)\n@@ -196,7 +198,7 @@ am__libgo_la_SOURCES_DIST = runtime/go-append.c runtime/go-assert.c \\\n \truntime/go-select.c runtime/go-semacquire.c \\\n \truntime/go-send-big.c runtime/go-send-nb-big.c \\\n \truntime/go-send-nb-small.c runtime/go-send-small.c \\\n-\truntime/go-signal.c runtime/go-strcmp.c \\\n+\truntime/go-setenv.c runtime/go-signal.c runtime/go-strcmp.c \\\n \truntime/go-string-to-byte-array.c \\\n \truntime/go-string-to-int-array.c runtime/go-strplus.c \\\n \truntime/go-strslice.c runtime/go-trampoline.c \\\n@@ -233,7 +235,7 @@ am__objects_3 = go-append.lo go-assert.lo go-assert-interface.lo \\\n \tgo-reflect-chan.lo go-reflect-map.lo go-rune.lo \\\n \tgo-runtime-error.lo go-sched.lo go-select.lo go-semacquire.lo \\\n \tgo-send-big.lo go-send-nb-big.lo go-send-nb-small.lo \\\n-\tgo-send-small.lo go-signal.lo go-strcmp.lo \\\n+\tgo-send-small.lo go-setenv.lo go-signal.lo go-strcmp.lo \\\n \tgo-string-to-byte-array.lo go-string-to-int-array.lo \\\n \tgo-strplus.lo go-strslice.lo go-trampoline.lo go-type-eface.lo \\\n \tgo-type-error.lo go-type-identity.lo go-type-interface.lo \\\n@@ -689,7 +691,8 @@ toolexeclibgogo_DATA = \\\n \tgo/printer.gox \\\n \tgo/scanner.gox \\\n \tgo/token.gox \\\n-\tgo/typechecker.gox\n+\tgo/typechecker.gox \\\n+\tgo/types.gox\n \n toolexeclibgohashdir = $(toolexeclibgodir)/hash\n toolexeclibgohash_DATA = \\\n@@ -701,13 +704,18 @@ toolexeclibgohash_DATA = \\\n toolexeclibgohttpdir = $(toolexeclibgodir)/http\n toolexeclibgohttp_DATA = \\\n \thttp/cgi.gox \\\n+\thttp/fcgi.gox \\\n \thttp/httptest.gox \\\n-\thttp/pprof.gox\n+\thttp/pprof.gox \\\n+\thttp/spdy.gox\n \n toolexeclibgoimagedir = $(toolexeclibgodir)/image\n toolexeclibgoimage_DATA = \\\n+\timage/gif.gox \\\n \timage/jpeg.gox \\\n-\timage/png.gox\n+\timage/png.gox \\\n+\timage/tiff.gox \\\n+\timage/ycbcr.gox\n \n toolexeclibgoindexdir = $(toolexeclibgodir)/index\n toolexeclibgoindex_DATA = \\\n@@ -733,6 +741,7 @@ toolexeclibgoosdir = $(toolexeclibgodir)/os\n @LIBGO_IS_LINUX_TRUE@os_inotify_gox = \n toolexeclibgoos_DATA = \\\n \t$(os_inotify_gox) \\\n+\tos/user.gox \\\n \tos/signal.gox\n \n toolexeclibgopathdir = $(toolexeclibgodir)/path\n@@ -821,6 +830,7 @@ runtime_files = \\\n \truntime/go-send-nb-big.c \\\n \truntime/go-send-nb-small.c \\\n \truntime/go-send-small.c \\\n+\truntime/go-setenv.c \\\n \truntime/go-signal.c \\\n \truntime/go-strcmp.c \\\n \truntime/go-string-to-byte-array.c \\\n@@ -952,6 +962,7 @@ go_http_files = \\\n \tgo/http/persist.go \\\n \tgo/http/request.go \\\n \tgo/http/response.go \\\n+\tgo/http/reverseproxy.go \\\n \tgo/http/server.go \\\n \tgo/http/status.go \\\n \tgo/http/transfer.go \\\n@@ -1041,8 +1052,13 @@ go_mime_files = \\\n @LIBGO_IS_LINUX_FALSE@@LIBGO_IS_RTEMS_FALSE@go_net_newpollserver_file = go/net/newpollserver.go\n @LIBGO_IS_LINUX_TRUE@@LIBGO_IS_RTEMS_FALSE@go_net_newpollserver_file = go/net/newpollserver.go\n @LIBGO_IS_RTEMS_TRUE@go_net_newpollserver_file = go/net/newpollserver_rtems.go\n+@LIBGO_IS_LINUX_FALSE@go_net_cgo_file = go/net/cgo_bsd.go\n+@LIBGO_IS_LINUX_TRUE@go_net_cgo_file = go/net/cgo_linux.go\n+@LIBGO_IS_LINUX_FALSE@go_net_sock_file = go/net/sock_bsd.go\n+@LIBGO_IS_LINUX_TRUE@go_net_sock_file = go/net/sock_linux.go\n go_net_files = \\\n-\tgo/net/cgo_stub.go \\\n+\tgo/net/cgo_unix.go \\\n+\t$(go_net_cgo_file) \\\n \tgo/net/dial.go \\\n \tgo/net/dnsclient.go \\\n \tgo/net/dnsconfig.go \\\n@@ -1061,6 +1077,7 @@ go_net_files = \\\n \tgo/net/pipe.go \\\n \tgo/net/port.go \\\n \tgo/net/sock.go \\\n+\t$(go_net_sock_file) \\\n \tgo/net/tcpsock.go \\\n \tgo/net/udpsock.go \\\n \tgo/net/unixsock.go\n@@ -1365,7 +1382,6 @@ go_crypto_subtle_files = \\\n \n go_crypto_tls_files = \\\n \tgo/crypto/tls/alert.go \\\n-\tgo/crypto/tls/ca_set.go \\\n \tgo/crypto/tls/cipher_suites.go \\\n \tgo/crypto/tls/common.go \\\n \tgo/crypto/tls/conn.go \\\n@@ -1380,6 +1396,8 @@ go_crypto_twofish_files = \\\n \tgo/crypto/twofish/twofish.go\n \n go_crypto_x509_files = \\\n+\tgo/crypto/x509/cert_pool.go \\\n+\tgo/crypto/x509/verify.go \\\n \tgo/crypto/x509/x509.go\n \n go_crypto_xtea_files = \\\n@@ -1519,6 +1537,13 @@ go_go_typechecker_files = \\\n \tgo/go/typechecker/typechecker.go \\\n \tgo/go/typechecker/universe.go\n \n+go_go_types_files = \\\n+\tgo/go/types/const.go \\\n+\tgo/go/types/exportdata.go \\\n+\tgo/go/types/gcimporter.go \\\n+\tgo/go/types/types.go \\\n+\tgo/go/types/universe.go\n+\n go_hash_adler32_files = \\\n \tgo/hash/adler32/adler32.go\n \n@@ -1535,22 +1560,42 @@ go_http_cgi_files = \\\n \tgo/http/cgi/child.go \\\n \tgo/http/cgi/host.go\n \n+go_http_fcgi_files = \\\n+\tgo/http/fcgi/child.go \\\n+\tgo/http/fcgi/fcgi.go\n+\n go_http_httptest_files = \\\n \tgo/http/httptest/recorder.go \\\n \tgo/http/httptest/server.go\n \n go_http_pprof_files = \\\n \tgo/http/pprof/pprof.go\n \n+go_http_spdy_files = \\\n+\tgo/http/spdy/protocol.go\n+\n+go_image_gif_files = \\\n+\tgo/image/gif/reader.go\n+\n go_image_jpeg_files = \\\n+\tgo/image/jpeg/fdct.go \\\n \tgo/image/jpeg/huffman.go \\\n \tgo/image/jpeg/idct.go \\\n-\tgo/image/jpeg/reader.go\n+\tgo/image/jpeg/reader.go \\\n+\tgo/image/jpeg/writer.go\n \n go_image_png_files = \\\n \tgo/image/png/reader.go \\\n \tgo/image/png/writer.go\n \n+go_image_tiff_files = \\\n+\tgo/image/tiff/buffer.go \\\n+\tgo/image/tiff/consts.go \\\n+\tgo/image/tiff/reader.go\n+\n+go_image_ycbcr_files = \\\n+\tgo/image/ycbcr/ycbcr.go\n+\n go_index_suffixarray_files = \\\n \tgo/index/suffixarray/qsufsort.go \\\n \tgo/index/suffixarray/suffixarray.go\n@@ -1560,6 +1605,7 @@ go_io_ioutil_files = \\\n \tgo/io/ioutil/tempfile.go\n \n go_mime_multipart_files = \\\n+\tgo/mime/multipart/formdata.go \\\n \tgo/mime/multipart/multipart.go\n \n go_net_dict_files = \\\n@@ -1575,6 +1621,10 @@ go_net_textproto_files = \\\n go_os_inotify_files = \\\n \tgo/os/inotify/inotify_linux.go\n \n+go_os_user_files = \\\n+\tgo/os/user/user.go \\\n+\tgo/os/user/lookup_unix.go\n+\n go_os_signal_files = \\\n \tgo/os/signal/signal.go \\\n \tunix.go\n@@ -1816,21 +1866,28 @@ libgo_go_objs = \\\n \tgo/scanner.lo \\\n \tgo/token.lo \\\n \tgo/typechecker.lo \\\n+\tgo/types.lo \\\n \thash/adler32.lo \\\n \thash/crc32.lo \\\n \thash/crc64.lo \\\n \thash/fnv.lo \\\n \thttp/cgi.lo \\\n+\thttp/fcgi.lo \\\n \thttp/httptest.lo \\\n \thttp/pprof.lo \\\n+\thttp/spdy.lo \\\n+\timage/gif.lo \\\n \timage/jpeg.lo \\\n \timage/png.lo \\\n+\timage/tiff.lo \\\n+\timage/ycbcr.lo \\\n \tindex/suffixarray.lo \\\n \tio/ioutil.lo \\\n \tmime/multipart.lo \\\n \tnet/dict.lo \\\n \tnet/textproto.lo \\\n \t$(os_lib_inotify_lo) \\\n+\tos/user.lo \\\n \tos/signal.lo \\\n \tpath/filepath.lo \\\n \trpc/jsonrpc.lo \\\n@@ -2052,22 +2109,30 @@ TEST_PACKAGES = \\\n \texp/datafmt/check \\\n \texp/draw/check \\\n \texp/eval/check \\\n+\tgo/ast/check \\\n \tgo/parser/check \\\n \tgo/printer/check \\\n \tgo/scanner/check \\\n \tgo/token/check \\\n \tgo/typechecker/check \\\n+\t$(go_types_check_omitted_since_it_calls_6g) \\\n \thash/adler32/check \\\n \thash/crc32/check \\\n \thash/crc64/check \\\n \thash/fnv/check \\\n \thttp/cgi/check \\\n+\thttp/fcgi/check \\\n+\thttp/spdy/check \\\n+\timage/jpeg/check \\\n \timage/png/check \\\n+\timage/tiff/check \\\n+\timage/ycbcr/check \\\n \tindex/suffixarray/check \\\n \tio/ioutil/check \\\n \tmime/multipart/check \\\n \tnet/textproto/check \\\n \t$(os_inotify_check) \\\n+\tos/user/check \\\n \tos/signal/check \\\n \tpath/filepath/check \\\n \trpc/jsonrpc/check \\\n@@ -2270,6 +2335,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-send-nb-big.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-send-nb-small.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-send-small.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-setenv.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-signal.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-strcmp.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-string-to-byte-array.Plo@am__quote@\n@@ -2750,6 +2816,13 @@ go-send-small.lo: runtime/go-send-small.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-send-small.lo `test -f 'runtime/go-send-small.c' || echo '$(srcdir)/'`runtime/go-send-small.c\n \n+go-setenv.lo: runtime/go-setenv.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-setenv.lo -MD -MP -MF $(DEPDIR)/go-setenv.Tpo -c -o go-setenv.lo `test -f 'runtime/go-setenv.c' || echo '$(srcdir)/'`runtime/go-setenv.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-setenv.Tpo $(DEPDIR)/go-setenv.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-setenv.c' object='go-setenv.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-setenv.lo `test -f 'runtime/go-setenv.c' || echo '$(srcdir)/'`runtime/go-setenv.c\n+\n go-signal.lo: runtime/go-signal.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-signal.lo -MD -MP -MF $(DEPDIR)/go-signal.Tpo -c -o go-signal.lo `test -f 'runtime/go-signal.c' || echo '$(srcdir)/'`runtime/go-signal.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-signal.Tpo $(DEPDIR)/go-signal.Plo\n@@ -4114,11 +4187,12 @@ html/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: html/check\n \n-http/http.lo: $(go_http_files) bufio.gox bytes.gox container/vector.gox \\\n-\t\tcrypto/rand.gox crypto/tls.gox encoding/base64.gox fmt.gox \\\n-\t\tio.gox io/ioutil.gox log.gox mime.gox mime/multipart.gox \\\n-\t\tnet.gox net/textproto.gox os.gox path.gox path/filepath.gox \\\n-\t\tsort.gox strconv.gox strings.gox sync.gox time.gox utf8.gox\n+http/http.lo: $(go_http_files) bufio.gox bytes.gox compress/gzip.gox \\\n+\t\tcontainer/vector.gox crypto/rand.gox crypto/tls.gox \\\n+\t\tencoding/base64.gox fmt.gox io.gox io/ioutil.gox log.gox \\\n+\t\tmime.gox mime/multipart.gox net.gox net/textproto.gox os.gox \\\n+\t\tpath.gox path/filepath.gox sort.gox strconv.gox strings.gox \\\n+\t\tsync.gox time.gox utf8.gox\n \t$(BUILDPACKAGE)\n http/check: $(CHECK_DEPS)\n \t@$(CHECK)\n@@ -4158,16 +4232,16 @@ math/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: math/check\n \n-mime/mime.lo: $(go_mime_files) bufio.gox bytes.gox os.gox strings.gox \\\n+mime/mime.lo: $(go_mime_files) bufio.gox bytes.gox fmt.gox os.gox strings.gox \\\n \t\tsync.gox unicode.gox\n \t$(BUILDPACKAGE)\n mime/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: mime/check\n \n net/net.lo: $(go_net_files) bytes.gox fmt.gox io.gox os.gox rand.gox \\\n-\t\treflect.gox strconv.gox strings.gox sync.gox syscall.gox \\\n-\t\ttime.gox\n+\t\treflect.gox sort.gox strconv.gox strings.gox sync.gox \\\n+\t\tsyscall.gox time.gox\n \t$(BUILDPACKAGE)\n net/check: $(CHECK_DEPS)\n \t@$(CHECK_ON_REQUEST)\n@@ -4348,8 +4422,8 @@ xml/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: xml/check\n \n-archive/tar.lo: $(go_archive_tar_files) bytes.gox io.gox os.gox strconv.gox \\\n-\t\tstrings.gox\n+archive/tar.lo: $(go_archive_tar_files) bytes.gox io.gox io/ioutil.gox os.gox \\\n+\t\tstrconv.gox strings.gox\n \t$(BUILDPACKAGE)\n archive/tar/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) archive/tar\n@@ -4551,8 +4625,7 @@ crypto/ripemd160/check: $(CHECK_DEPS)\n .PHONY: crypto/ripemd160/check\n \n crypto/rsa.lo: $(go_crypto_rsa_files) big.gox crypto.gox crypto/sha1.gox \\\n-\t\tcrypto/subtle.gox encoding/hex.gox hash.gox io.gox os.gox \\\n-\t\tsync.gox\n+\t\tcrypto/subtle.gox encoding/hex.gox hash.gox io.gox os.gox\n \t$(BUILDPACKAGE)\n crypto/rsa/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/rsa\n@@ -4587,13 +4660,13 @@ crypto/subtle/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: crypto/subtle/check\n \n-crypto/tls.lo: $(go_crypto_tls_files) big.gox bufio.gox bytes.gox \\\n-\t\tcontainer/list.gox crypto.gox crypto/aes.gox crypto/cipher.gox \\\n-\t\tcrypto/elliptic.gox crypto/hmac.gox crypto/md5.gox \\\n-\t\tcrypto/rc4.gox crypto/rand.gox crypto/rsa.gox crypto/sha1.gox \\\n-\t\tcrypto/subtle.gox crypto/rsa.gox crypto/sha1.gox \\\n-\t\tcrypto/x509.gox encoding/pem.gox fmt.gox hash.gox io.gox \\\n-\t\tio/ioutil.gox net.gox os.gox strings.gox sync.gox time.gox\n+crypto/tls.lo: $(go_crypto_tls_files) big.gox bytes.gox crypto.gox \\\n+\t\tcrypto/aes.gox crypto/cipher.gox crypto/elliptic.gox \\\n+\t\tcrypto/hmac.gox crypto/md5.gox crypto/rand.gox crypto/rc4.gox \\\n+\t\tcrypto/rsa.gox crypto/sha1.gox crypto/subtle.gox \\\n+\t\tcrypto/x509.gox encoding/pem.gox hash.gox io.gox \\\n+\t\tio/ioutil.gox net.gox os.gox strconv.gox strings.gox sync.gox \\\n+\t\ttime.gox\n \t$(BUILDPACKAGE)\n crypto/tls/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/tls\n@@ -4607,9 +4680,10 @@ crypto/twofish/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: crypto/twofish/check\n \n-crypto/x509.lo: $(go_crypto_x509_files) asn1.gox big.gox container/vector.gox \\\n-\t\tcrypto.gox crypto/rsa.gox crypto/sha1.gox hash.gox os.gox \\\n-\t\tstrings.gox time.gox\n+crypto/x509.lo: $(go_crypto_x509_files) asn1.gox big.gox bytes.gox \\\n+\t\tcontainer/vector.gox crypto.gox crypto/rsa.gox \\\n+\t\tcrypto/sha1.gox encoding/pem.gox hash.gox os.gox strings.gox \\\n+\t\ttime.gox\n \t$(BUILDPACKAGE)\n crypto/x509/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/x509\n@@ -4623,9 +4697,8 @@ crypto/xtea/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: crypto/xtea/check\n \n-crypto/openpgp/armor.lo: $(go_crypto_openpgp_armor_files) bytes.gox \\\n-\t\tcrypto/openpgp/error.gox encoding/base64.gox \\\n-\t\tencoding/line.gox io.gox os.gox\n+crypto/openpgp/armor.lo: $(go_crypto_openpgp_armor_files) bufio.gox bytes.gox \\\n+\t\tcrypto/openpgp/error.gox encoding/base64.gox io.gox os.gox\n \t$(BUILDPACKAGE)\n crypto/openpgp/armor/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/openpgp/armor\n@@ -4777,7 +4850,7 @@ exp/datafmt/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: exp/datafmt/check\n \n-exp/draw.lo: $(go_exp_draw_files) image.gox os.gox\n+exp/draw.lo: $(go_exp_draw_files) image.gox image/ycbcr.gox os.gox\n \t$(BUILDPACKAGE)\n exp/draw/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) exp/draw\n@@ -4851,6 +4924,15 @@ go/typechecker/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: go/typechecker/check\n \n+go/types.lo: $(go_go_types_files) big.gox bufio.gox fmt.gox go/ast.gox \\\n+\t\tgo/token.gox io.gox os.gox path/filepath.gox runtime.gox \\\n+\t\tscanner.gox strconv.gox strings.gox\n+\t$(BUILDPACKAGE)\n+go/types/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) go/types\n+\t@$(CHECK)\n+.PHONY: go/types/check\n+\n hash/adler32.lo: $(go_hash_adler32_files) hash.gox os.gox\n \t$(BUILDPACKAGE)\n hash/adler32/check: $(CHECK_DEPS)\n@@ -4879,15 +4961,25 @@ hash/fnv/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: hash/fnv/check\n \n-http/cgi.lo: $(go_http_cgi_files) bufio.gox bytes.gox encoding/line.gox \\\n-\t\texec.gox fmt.gox http.gox io.gox io/ioutil.gox log.gox \\\n-\t\tos.gox path/filepath.gox regexp.gox strconv.gox strings.gox\n+http/cgi.lo: $(go_http_cgi_files) bufio.gox bytes.gox crypto/tls.gox \\\n+\t\texec.gox fmt.gox http.gox net.gox io.gox io/ioutil.gox \\\n+\t\tlog.gox os.gox path/filepath.gox regexp.gox strconv.gox \\\n+\t\tstrings.gox\n \t$(BUILDPACKAGE)\n http/cgi/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) http/cgi\n \t@$(CHECK)\n .PHONY: http/cgi/check\n \n+http/fcgi.lo: $(go_http_fcgi_files) bufio.gox bytes.gox encoding/binary.gox \\\n+\t\tfmt.gox http.gox http/cgi.gox io.gox net.gox os.gox sync.gox \\\n+\t\ttime.gox\n+\t$(BUILDPACKAGE)\n+http/fcgi/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) http/fcgi\n+\t@$(CHECK)\n+.PHONY: http/fcgi/check\n+\n http/httptest.lo: $(go_http_httptest_files) bytes.gox crypto/rand.gox \\\n \t\tcrypto/tls.gox fmt.gox http.gox net.gox os.gox time.gox\n \t$(BUILDPACKAGE)\n@@ -4896,15 +4988,33 @@ http/httptest/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: http/httptest/check\n \n-http/pprof.lo: $(go_http_pprof_files) bufio.gox fmt.gox http.gox os.gox \\\n-\t\truntime.gox runtime/pprof.gox strconv.gox strings.gox\n+http/pprof.lo: $(go_http_pprof_files) bufio.gox bytes.gox fmt.gox http.gox \\\n+\t\tos.gox runtime.gox runtime/pprof.gox strconv.gox strings.gox\n \t$(BUILDPACKAGE)\n http/pprof/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) http/pprof\n \t@$(CHECK)\n .PHONY: http/pprof/check\n \n-image/jpeg.lo: $(go_image_jpeg_files) bufio.gox image.gox io.gox os.gox\n+http/spdy.lo: $(go_http_spdy_files) bytes.gox compress/zlib.gox \\\n+\t\tencoding/binary.gox http.gox io.gox os.gox strconv.gox \\\n+\t\tstrings.gox sync.gox\n+\t$(BUILDPACKAGE)\n+http/spdy/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) http/spdy\n+\t@$(CHECK)\n+.PHONY: http/spdy/check\n+\n+image/gif.lo: $(go_image_gif_files) bufio.gox compress/lzw.gox fmt.gox \\\n+\t\timage.gox io.gox os.gox\n+\t$(BUILDPACKAGE)\n+image/gif/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) image/gif\n+\t@$(CHECK)\n+.PHONY: image/gif/check\n+\n+image/jpeg.lo: $(go_image_jpeg_files) bufio.gox image.gox image/ycbcr.gox \\\n+\t\tio.gox os.gox\n \t$(BUILDPACKAGE)\n image/jpeg/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) image/jpeg\n@@ -4919,6 +5029,21 @@ image/png/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: image/png/check\n \n+image/tiff.lo: $(go_image_tiff_files) compress/lzw.gox compress/zlib.gox \\\n+\t\tencoding/binary.gox image.gox io.gox io/ioutil.gox os.gox\n+\t$(BUILDPACKAGE)\n+image/tiff/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) image/tiff\n+\t@$(CHECK)\n+.PHONY: image/tiff/check\n+\n+image/ycbcr.lo: $(go_image_ycbcr_files) image.gox\n+\t$(BUILDPACKAGE)\n+image/ycbcr/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) image/ycbcr\n+\t@$(CHECK)\n+.PHONY: image/ycbcr/check\n+\n index/suffixarray.lo: $(go_index_suffixarray_files) bytes.gox regexp.gox \\\n \t\tsort.gox\n \t$(BUILDPACKAGE)\n@@ -4935,8 +5060,9 @@ io/ioutil/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: io/ioutil/check\n \n-mime/multipart.lo: $(go_mime_multipart_files) bufio.gox bytes.gox io.gox \\\n-\t\tmime.gox net/textproto.gox os.gox regexp.gox strings.gox\n+mime/multipart.lo: $(go_mime_multipart_files) bufio.gox bytes.gox fmt.gox \\\n+\t\tio.gox io/ioutil.gox mime.gox net/textproto.gox os.gox \\\n+\t\tregexp.gox\n \t$(BUILDPACKAGE)\n mime/multipart/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) mime/multipart\n@@ -4963,6 +5089,14 @@ os/inotify/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: os/inotify/check\n \n+os/user.lo: $(go_os_user_files) fmt.gox os.gox runtime.gox strconv.gox \\\n+\t\tstrings.gox syscall.gox\n+\t$(BUILDPACKAGE)\n+os/user/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) os/user\n+\t@$(CHECK)\n+.PHONY: os/user/check\n+\n os/signal.lo: $(go_os_signal_files) runtime.gox strconv.gox\n \t$(BUILDPACKAGE)\n os/signal/check: $(CHECK_DEPS)\n@@ -5284,6 +5418,8 @@ go/token.gox: go/token.lo\n \t$(BUILDGOX)\n go/typechecker.gox: go/typechecker.lo\n \t$(BUILDGOX)\n+go/types.gox: go/types.lo\n+\t$(BUILDGOX)\n \n hash/adler32.gox: hash/adler32.lo\n \t$(BUILDGOX)\n@@ -5296,15 +5432,25 @@ hash/fnv.gox: hash/fnv.lo\n \n http/cgi.gox: http/cgi.lo\n \t$(BUILDGOX)\n+http/fcgi.gox: http/fcgi.lo\n+\t$(BUILDGOX)\n http/httptest.gox: http/httptest.lo\n \t$(BUILDGOX)\n http/pprof.gox: http/pprof.lo\n \t$(BUILDGOX)\n+http/spdy.gox: http/spdy.lo\n+\t$(BUILDGOX)\n \n+image/gif.gox: image/gif.lo\n+\t$(BUILDGOX)\n image/jpeg.gox: image/jpeg.lo\n \t$(BUILDGOX)\n image/png.gox: image/png.lo\n \t$(BUILDGOX)\n+image/tiff.gox: image/tiff.lo\n+\t$(BUILDGOX)\n+image/ycbcr.gox: image/ycbcr.lo\n+\t$(BUILDGOX)\n \n index/suffixarray.gox: index/suffixarray.lo\n \t$(BUILDGOX)\n@@ -5322,6 +5468,8 @@ net/textproto.gox: net/textproto.lo\n \n os/inotify.gox: os/inotify.lo\n \t$(BUILDGOX)\n+os/user.gox: os/user.lo\n+\t$(BUILDGOX)\n os/signal.gox: os/signal.lo\n \t$(BUILDGOX)\n "}, {"sha": "52885876589cd0ca6275a8c9c11979046af2d82b", "filename": "libgo/go/archive/tar/common.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Farchive%2Ftar%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Farchive%2Ftar%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fcommon.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// The tar package implements access to tar archives.\n+// Package tar implements access to tar archives.\n // It aims to cover most of the variations, including those produced\n // by GNU and BSD tars.\n //"}, {"sha": "ad06b6dac548bd97928ee597406557c3db178c88", "filename": "libgo/go/archive/tar/reader.go", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Farchive%2Ftar%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Farchive%2Ftar%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Freader.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -10,6 +10,7 @@ package tar\n import (\n \t\"bytes\"\n \t\"io\"\n+\t\"io/ioutil\"\n \t\"os\"\n \t\"strconv\"\n )\n@@ -27,13 +28,13 @@ var (\n //\ttr := tar.NewReader(r)\n //\tfor {\n //\t\thdr, err := tr.Next()\n-//\t\tif err != nil {\n-//\t\t\t// handle error\n-//\t\t}\n-//\t\tif hdr == nil {\n+//\t\tif err == os.EOF {\n //\t\t\t// end of tar archive\n //\t\t\tbreak\n //\t\t}\n+//\t\tif err != nil {\n+//\t\t\t// handle error\n+//\t\t}\n //\t\tio.Copy(data, tr)\n //\t}\n type Reader struct {\n@@ -84,12 +85,6 @@ func (tr *Reader) octal(b []byte) int64 {\n \treturn int64(x)\n }\n \n-type ignoreWriter struct{}\n-\n-func (ignoreWriter) Write(b []byte) (n int, err os.Error) {\n-\treturn len(b), nil\n-}\n-\n // Skip any unread bytes in the existing file entry, as well as any alignment padding.\n func (tr *Reader) skipUnread() {\n \tnr := tr.nb + tr.pad // number of bytes to skip\n@@ -99,7 +94,7 @@ func (tr *Reader) skipUnread() {\n \t\t\treturn\n \t\t}\n \t}\n-\t_, tr.err = io.Copyn(ignoreWriter{}, tr.r, nr)\n+\t_, tr.err = io.Copyn(ioutil.Discard, tr.r, nr)\n }\n \n func (tr *Reader) verifyChecksum(header []byte) bool {"}, {"sha": "17464c5d8e4129d65dc4e7a6ac01d66012d9c49e", "filename": "libgo/go/archive/zip/reader.go", "status": "modified", "additions": 35, "deletions": 13, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -3,7 +3,7 @@\n // license that can be found in the LICENSE file.\n \n /*\n-The zip package provides support for reading ZIP archives.\n+Package zip provides support for reading ZIP archives.\n \n See: http://www.pkware.com/documents/casestudies/APPNOTE.TXT\n \n@@ -35,6 +35,11 @@ type Reader struct {\n \tComment string\n }\n \n+type ReadCloser struct {\n+\tf *os.File\n+\tReader\n+}\n+\n type File struct {\n \tFileHeader\n \tzipr         io.ReaderAt\n@@ -47,43 +52,60 @@ func (f *File) hasDataDescriptor() bool {\n \treturn f.Flags&0x8 != 0\n }\n \n-// OpenReader will open the Zip file specified by name and return a Reader.\n-func OpenReader(name string) (*Reader, os.Error) {\n+// OpenReader will open the Zip file specified by name and return a ReaderCloser.\n+func OpenReader(name string) (*ReadCloser, os.Error) {\n \tf, err := os.Open(name)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \tfi, err := f.Stat()\n \tif err != nil {\n+\t\tf.Close()\n+\t\treturn nil, err\n+\t}\n+\tr := new(ReadCloser)\n+\tif err := r.init(f, fi.Size); err != nil {\n+\t\tf.Close()\n \t\treturn nil, err\n \t}\n-\treturn NewReader(f, fi.Size)\n+\treturn r, nil\n }\n \n // NewReader returns a new Reader reading from r, which is assumed to\n // have the given size in bytes.\n func NewReader(r io.ReaderAt, size int64) (*Reader, os.Error) {\n-\tend, err := readDirectoryEnd(r, size)\n-\tif err != nil {\n+\tzr := new(Reader)\n+\tif err := zr.init(r, size); err != nil {\n \t\treturn nil, err\n \t}\n-\tz := &Reader{\n-\t\tr:       r,\n-\t\tFile:    make([]*File, end.directoryRecords),\n-\t\tComment: end.comment,\n+\treturn zr, nil\n+}\n+\n+func (z *Reader) init(r io.ReaderAt, size int64) os.Error {\n+\tend, err := readDirectoryEnd(r, size)\n+\tif err != nil {\n+\t\treturn err\n \t}\n+\tz.r = r\n+\tz.File = make([]*File, end.directoryRecords)\n+\tz.Comment = end.comment\n \trs := io.NewSectionReader(r, 0, size)\n \tif _, err = rs.Seek(int64(end.directoryOffset), os.SEEK_SET); err != nil {\n-\t\treturn nil, err\n+\t\treturn err\n \t}\n \tbuf := bufio.NewReader(rs)\n \tfor i := range z.File {\n \t\tz.File[i] = &File{zipr: r, zipsize: size}\n \t\tif err := readDirectoryHeader(z.File[i], buf); err != nil {\n-\t\t\treturn nil, err\n+\t\t\treturn err\n \t\t}\n \t}\n-\treturn z, nil\n+\treturn nil\n+}\n+\n+// Close closes the Zip file, rendering it unusable for I/O.\n+func (rc *ReadCloser) Close() os.Error {\n+\treturn rc.f.Close()\n }\n \n // Open returns a ReadCloser that provides access to the File's contents."}, {"sha": "c72cd9a2347b48162795d8535077c27640145cc5", "filename": "libgo/go/archive/zip/reader_test.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -76,6 +76,12 @@ func readTestZip(t *testing.T, zt ZipTest) {\n \t\treturn\n \t}\n \n+\t// bail if file is not zip\n+\tif err == FormatError {\n+\t\treturn\n+\t}\n+\tdefer z.Close()\n+\n \t// bail here if no Files expected to be tested\n \t// (there may actually be files in the zip, but we don't care)\n \tif zt.File == nil {"}, {"sha": "5f470aed7970f3d3edd17c7191c7dc5e1fecb598", "filename": "libgo/go/asn1/asn1.go", "status": "modified", "additions": 38, "deletions": 46, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fasn1%2Fasn1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fasn1%2Fasn1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fasn1%2Fasn1.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// The asn1 package implements parsing of DER-encoded ASN.1 data structures,\n+// Package asn1 implements parsing of DER-encoded ASN.1 data structures,\n // as defined in ITU-T Rec X.690.\n //\n // See also ``A Layman's Guide to a Subset of ASN.1, BER, and DER,''\n@@ -373,7 +373,7 @@ func parseTagAndLength(bytes []byte, initOffset int) (ret tagAndLength, offset i\n // parseSequenceOf is used for SEQUENCE OF and SET OF values. It tries to parse\n // a number of ASN.1 values from the given byte array and returns them as a\n // slice of Go values of the given type.\n-func parseSequenceOf(bytes []byte, sliceType *reflect.SliceType, elemType reflect.Type) (ret *reflect.SliceValue, err os.Error) {\n+func parseSequenceOf(bytes []byte, sliceType reflect.Type, elemType reflect.Type) (ret reflect.Value, err os.Error) {\n \texpectedTag, compoundType, ok := getUniversalType(elemType)\n \tif !ok {\n \t\terr = StructuralError{\"unknown Go type for slice\"}\n@@ -409,7 +409,7 @@ func parseSequenceOf(bytes []byte, sliceType *reflect.SliceType, elemType reflec\n \tparams := fieldParameters{}\n \toffset := 0\n \tfor i := 0; i < numElements; i++ {\n-\t\toffset, err = parseField(ret.Elem(i), bytes, offset, params)\n+\t\toffset, err = parseField(ret.Index(i), bytes, offset, params)\n \t\tif err != nil {\n \t\t\treturn\n \t\t}\n@@ -418,13 +418,13 @@ func parseSequenceOf(bytes []byte, sliceType *reflect.SliceType, elemType reflec\n }\n \n var (\n-\tbitStringType        = reflect.Typeof(BitString{})\n-\tobjectIdentifierType = reflect.Typeof(ObjectIdentifier{})\n-\tenumeratedType       = reflect.Typeof(Enumerated(0))\n-\tflagType             = reflect.Typeof(Flag(false))\n-\ttimeType             = reflect.Typeof(&time.Time{})\n-\trawValueType         = reflect.Typeof(RawValue{})\n-\trawContentsType      = reflect.Typeof(RawContent(nil))\n+\tbitStringType        = reflect.TypeOf(BitString{})\n+\tobjectIdentifierType = reflect.TypeOf(ObjectIdentifier{})\n+\tenumeratedType       = reflect.TypeOf(Enumerated(0))\n+\tflagType             = reflect.TypeOf(Flag(false))\n+\ttimeType             = reflect.TypeOf(&time.Time{})\n+\trawValueType         = reflect.TypeOf(RawValue{})\n+\trawContentsType      = reflect.TypeOf(RawContent(nil))\n )\n \n // invalidLength returns true iff offset + length > sliceLength, or if the\n@@ -461,13 +461,12 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam\n \t\t}\n \t\tresult := RawValue{t.class, t.tag, t.isCompound, bytes[offset : offset+t.length], bytes[initOffset : offset+t.length]}\n \t\toffset += t.length\n-\t\tv.(*reflect.StructValue).Set(reflect.NewValue(result).(*reflect.StructValue))\n+\t\tv.Set(reflect.ValueOf(result))\n \t\treturn\n \t}\n \n \t// Deal with the ANY type.\n-\tif ifaceType, ok := fieldType.(*reflect.InterfaceType); ok && ifaceType.NumMethod() == 0 {\n-\t\tifaceValue := v.(*reflect.InterfaceValue)\n+\tif ifaceType := fieldType; ifaceType.Kind() == reflect.Interface && ifaceType.NumMethod() == 0 {\n \t\tvar t tagAndLength\n \t\tt, offset, err = parseTagAndLength(bytes, offset)\n \t\tif err != nil {\n@@ -506,7 +505,7 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam\n \t\t\treturn\n \t\t}\n \t\tif result != nil {\n-\t\t\tifaceValue.Set(reflect.NewValue(result))\n+\t\t\tv.Set(reflect.ValueOf(result))\n \t\t}\n \t\treturn\n \t}\n@@ -536,9 +535,7 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam\n \t\t\t\t\terr = StructuralError{\"Zero length explicit tag was not an asn1.Flag\"}\n \t\t\t\t\treturn\n \t\t\t\t}\n-\n-\t\t\t\tflagValue := v.(*reflect.BoolValue)\n-\t\t\t\tflagValue.Set(true)\n+\t\t\t\tv.SetBool(true)\n \t\t\t\treturn\n \t\t\t}\n \t\t} else {\n@@ -606,23 +603,20 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam\n \tswitch fieldType {\n \tcase objectIdentifierType:\n \t\tnewSlice, err1 := parseObjectIdentifier(innerBytes)\n-\t\tsliceValue := v.(*reflect.SliceValue)\n-\t\tsliceValue.Set(reflect.MakeSlice(sliceValue.Type().(*reflect.SliceType), len(newSlice), len(newSlice)))\n+\t\tv.Set(reflect.MakeSlice(v.Type(), len(newSlice), len(newSlice)))\n \t\tif err1 == nil {\n-\t\t\treflect.Copy(sliceValue, reflect.NewValue(newSlice).(reflect.ArrayOrSliceValue))\n+\t\t\treflect.Copy(v, reflect.ValueOf(newSlice))\n \t\t}\n \t\terr = err1\n \t\treturn\n \tcase bitStringType:\n-\t\tstructValue := v.(*reflect.StructValue)\n \t\tbs, err1 := parseBitString(innerBytes)\n \t\tif err1 == nil {\n-\t\t\tstructValue.Set(reflect.NewValue(bs).(*reflect.StructValue))\n+\t\t\tv.Set(reflect.ValueOf(bs))\n \t\t}\n \t\terr = err1\n \t\treturn\n \tcase timeType:\n-\t\tptrValue := v.(*reflect.PtrValue)\n \t\tvar time *time.Time\n \t\tvar err1 os.Error\n \t\tif universalTag == tagUTCTime {\n@@ -631,55 +625,53 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam\n \t\t\ttime, err1 = parseGeneralizedTime(innerBytes)\n \t\t}\n \t\tif err1 == nil {\n-\t\t\tptrValue.Set(reflect.NewValue(time).(*reflect.PtrValue))\n+\t\t\tv.Set(reflect.ValueOf(time))\n \t\t}\n \t\terr = err1\n \t\treturn\n \tcase enumeratedType:\n \t\tparsedInt, err1 := parseInt(innerBytes)\n-\t\tenumValue := v.(*reflect.IntValue)\n \t\tif err1 == nil {\n-\t\t\tenumValue.Set(int64(parsedInt))\n+\t\t\tv.SetInt(int64(parsedInt))\n \t\t}\n \t\terr = err1\n \t\treturn\n \tcase flagType:\n-\t\tflagValue := v.(*reflect.BoolValue)\n-\t\tflagValue.Set(true)\n+\t\tv.SetBool(true)\n \t\treturn\n \t}\n-\tswitch val := v.(type) {\n-\tcase *reflect.BoolValue:\n+\tswitch val := v; val.Kind() {\n+\tcase reflect.Bool:\n \t\tparsedBool, err1 := parseBool(innerBytes)\n \t\tif err1 == nil {\n-\t\t\tval.Set(parsedBool)\n+\t\t\tval.SetBool(parsedBool)\n \t\t}\n \t\terr = err1\n \t\treturn\n-\tcase *reflect.IntValue:\n+\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n \t\tswitch val.Type().Kind() {\n \t\tcase reflect.Int:\n \t\t\tparsedInt, err1 := parseInt(innerBytes)\n \t\t\tif err1 == nil {\n-\t\t\t\tval.Set(int64(parsedInt))\n+\t\t\t\tval.SetInt(int64(parsedInt))\n \t\t\t}\n \t\t\terr = err1\n \t\t\treturn\n \t\tcase reflect.Int64:\n \t\t\tparsedInt, err1 := parseInt64(innerBytes)\n \t\t\tif err1 == nil {\n-\t\t\t\tval.Set(parsedInt)\n+\t\t\t\tval.SetInt(parsedInt)\n \t\t\t}\n \t\t\terr = err1\n \t\t\treturn\n \t\t}\n-\tcase *reflect.StructValue:\n-\t\tstructType := fieldType.(*reflect.StructType)\n+\tcase reflect.Struct:\n+\t\tstructType := fieldType\n \n \t\tif structType.NumField() > 0 &&\n \t\t\tstructType.Field(0).Type == rawContentsType {\n \t\t\tbytes := bytes[initOffset:offset]\n-\t\t\tval.Field(0).SetValue(reflect.NewValue(RawContent(bytes)))\n+\t\t\tval.Field(0).Set(reflect.ValueOf(RawContent(bytes)))\n \t\t}\n \n \t\tinnerOffset := 0\n@@ -697,11 +689,11 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam\n \t\t// adding elements to the end has been used in X.509 as the\n \t\t// version numbers have increased.\n \t\treturn\n-\tcase *reflect.SliceValue:\n-\t\tsliceType := fieldType.(*reflect.SliceType)\n+\tcase reflect.Slice:\n+\t\tsliceType := fieldType\n \t\tif sliceType.Elem().Kind() == reflect.Uint8 {\n \t\t\tval.Set(reflect.MakeSlice(sliceType, len(innerBytes), len(innerBytes)))\n-\t\t\treflect.Copy(val, reflect.NewValue(innerBytes).(reflect.ArrayOrSliceValue))\n+\t\t\treflect.Copy(val, reflect.ValueOf(innerBytes))\n \t\t\treturn\n \t\t}\n \t\tnewSlice, err1 := parseSequenceOf(innerBytes, sliceType, sliceType.Elem())\n@@ -710,7 +702,7 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam\n \t\t}\n \t\terr = err1\n \t\treturn\n-\tcase *reflect.StringValue:\n+\tcase reflect.String:\n \t\tvar v string\n \t\tswitch universalTag {\n \t\tcase tagPrintableString:\n@@ -729,7 +721,7 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam\n \t\t\terr = SyntaxError{fmt.Sprintf(\"internal error: unknown string type %d\", universalTag)}\n \t\t}\n \t\tif err == nil {\n-\t\t\tval.Set(v)\n+\t\t\tval.SetString(v)\n \t\t}\n \t\treturn\n \t}\n@@ -748,9 +740,9 @@ func setDefaultValue(v reflect.Value, params fieldParameters) (ok bool) {\n \tif params.defaultValue == nil {\n \t\treturn\n \t}\n-\tswitch val := v.(type) {\n-\tcase *reflect.IntValue:\n-\t\tval.Set(*params.defaultValue)\n+\tswitch val := v; val.Kind() {\n+\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n+\t\tval.SetInt(*params.defaultValue)\n \t}\n \treturn\n }\n@@ -806,7 +798,7 @@ func Unmarshal(b []byte, val interface{}) (rest []byte, err os.Error) {\n // UnmarshalWithParams allows field parameters to be specified for the\n // top-level element. The form of the params is the same as the field tags.\n func UnmarshalWithParams(b []byte, val interface{}, params string) (rest []byte, err os.Error) {\n-\tv := reflect.NewValue(val).(*reflect.PtrValue).Elem()\n+\tv := reflect.ValueOf(val).Elem()\n \toffset, err := parseField(v, b, 0, parseFieldParameters(params))\n \tif err != nil {\n \t\treturn nil, err"}, {"sha": "78f56280524b1e9de43939c04aad679699076075", "filename": "libgo/go/asn1/asn1_test.go", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fasn1%2Fasn1_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fasn1%2Fasn1_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fasn1%2Fasn1_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -267,11 +267,6 @@ func TestParseFieldParameters(t *testing.T) {\n \t}\n }\n \n-type unmarshalTest struct {\n-\tin  []byte\n-\tout interface{}\n-}\n-\n type TestObjectIdentifierStruct struct {\n \tOID ObjectIdentifier\n }\n@@ -290,7 +285,10 @@ type TestElementsAfterString struct {\n \tA, B int\n }\n \n-var unmarshalTestData []unmarshalTest = []unmarshalTest{\n+var unmarshalTestData = []struct {\n+\tin  []byte\n+\tout interface{}\n+}{\n \t{[]byte{0x02, 0x01, 0x42}, newInt(0x42)},\n \t{[]byte{0x30, 0x08, 0x06, 0x06, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d}, &TestObjectIdentifierStruct{[]int{1, 2, 840, 113549}}},\n \t{[]byte{0x03, 0x04, 0x06, 0x6e, 0x5d, 0xc0}, &BitString{[]byte{110, 93, 192}, 18}},\n@@ -309,9 +307,7 @@ var unmarshalTestData []unmarshalTest = []unmarshalTest{\n \n func TestUnmarshal(t *testing.T) {\n \tfor i, test := range unmarshalTestData {\n-\t\tpv := reflect.MakeZero(reflect.NewValue(test.out).Type())\n-\t\tzv := reflect.MakeZero(pv.Type().(*reflect.PtrType).Elem())\n-\t\tpv.(*reflect.PtrValue).PointTo(zv)\n+\t\tpv := reflect.New(reflect.TypeOf(test.out).Elem())\n \t\tval := pv.Interface()\n \t\t_, err := Unmarshal(test.in, val)\n \t\tif err != nil {"}, {"sha": "1589877477cf7ce6413aa47bee4cd211a95b9ad0", "filename": "libgo/go/asn1/common.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fasn1%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fasn1%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fasn1%2Fcommon.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -133,22 +133,22 @@ func getUniversalType(t reflect.Type) (tagNumber int, isCompound, ok bool) {\n \tcase enumeratedType:\n \t\treturn tagEnum, false, true\n \t}\n-\tswitch t := t.(type) {\n-\tcase *reflect.BoolType:\n+\tswitch t.Kind() {\n+\tcase reflect.Bool:\n \t\treturn tagBoolean, false, true\n-\tcase *reflect.IntType:\n+\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n \t\treturn tagInteger, false, true\n-\tcase *reflect.StructType:\n+\tcase reflect.Struct:\n \t\treturn tagSequence, true, true\n-\tcase *reflect.SliceType:\n+\tcase reflect.Slice:\n \t\tif t.Elem().Kind() == reflect.Uint8 {\n \t\t\treturn tagOctetString, false, true\n \t\t}\n \t\tif strings.HasSuffix(t.Name(), \"SET\") {\n \t\t\treturn tagSet, true, true\n \t\t}\n \t\treturn tagSequence, true, true\n-\tcase *reflect.StringType:\n+\tcase reflect.String:\n \t\treturn tagPrintableString, false, true\n \t}\n \treturn 0, false, false"}, {"sha": "a3e1145b8956cc0965d91fe548d4a76adda86139", "filename": "libgo/go/asn1/marshal.go", "status": "modified", "additions": 43, "deletions": 21, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fasn1%2Fmarshal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fasn1%2Fmarshal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fasn1%2Fmarshal.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -125,6 +125,28 @@ func int64Length(i int64) (numBytes int) {\n \treturn\n }\n \n+func marshalLength(out *forkableWriter, i int) (err os.Error) {\n+\tn := lengthLength(i)\n+\n+\tfor ; n > 0; n-- {\n+\t\terr = out.WriteByte(byte(i >> uint((n-1)*8)))\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n+\treturn nil\n+}\n+\n+func lengthLength(i int) (numBytes int) {\n+\tnumBytes = 1\n+\tfor i > 255 {\n+\t\tnumBytes++\n+\t\ti >>= 8\n+\t}\n+\treturn\n+}\n+\n func marshalTagAndLength(out *forkableWriter, t tagAndLength) (err os.Error) {\n \tb := uint8(t.class) << 6\n \tif t.isCompound {\n@@ -149,12 +171,12 @@ func marshalTagAndLength(out *forkableWriter, t tagAndLength) (err os.Error) {\n \t}\n \n \tif t.length >= 128 {\n-\t\tl := int64Length(int64(t.length))\n+\t\tl := lengthLength(t.length)\n \t\terr = out.WriteByte(0x80 | byte(l))\n \t\tif err != nil {\n \t\t\treturn\n \t\t}\n-\t\terr = marshalInt64(out, int64(t.length))\n+\t\terr = marshalLength(out, t.length)\n \t\tif err != nil {\n \t\t\treturn\n \t\t}\n@@ -314,28 +336,28 @@ func marshalBody(out *forkableWriter, value reflect.Value, params fieldParameter\n \t\treturn marshalObjectIdentifier(out, value.Interface().(ObjectIdentifier))\n \t}\n \n-\tswitch v := value.(type) {\n-\tcase *reflect.BoolValue:\n-\t\tif v.Get() {\n+\tswitch v := value; v.Kind() {\n+\tcase reflect.Bool:\n+\t\tif v.Bool() {\n \t\t\treturn out.WriteByte(255)\n \t\t} else {\n \t\t\treturn out.WriteByte(0)\n \t\t}\n-\tcase *reflect.IntValue:\n-\t\treturn marshalInt64(out, int64(v.Get()))\n-\tcase *reflect.StructValue:\n-\t\tt := v.Type().(*reflect.StructType)\n+\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n+\t\treturn marshalInt64(out, int64(v.Int()))\n+\tcase reflect.Struct:\n+\t\tt := v.Type()\n \n \t\tstartingField := 0\n \n \t\t// If the first element of the structure is a non-empty\n \t\t// RawContents, then we don't bother serialising the rest.\n \t\tif t.NumField() > 0 && t.Field(0).Type == rawContentsType {\n-\t\t\ts := v.Field(0).(*reflect.SliceValue)\n+\t\t\ts := v.Field(0)\n \t\t\tif s.Len() > 0 {\n \t\t\t\tbytes := make([]byte, s.Len())\n \t\t\t\tfor i := 0; i < s.Len(); i++ {\n-\t\t\t\t\tbytes[i] = uint8(s.Elem(i).(*reflect.UintValue).Get())\n+\t\t\t\t\tbytes[i] = uint8(s.Index(i).Uint())\n \t\t\t\t}\n \t\t\t\t/* The RawContents will contain the tag and\n \t\t\t\t * length fields but we'll also be writing\n@@ -357,12 +379,12 @@ func marshalBody(out *forkableWriter, value reflect.Value, params fieldParameter\n \t\t\t}\n \t\t}\n \t\treturn\n-\tcase *reflect.SliceValue:\n-\t\tsliceType := v.Type().(*reflect.SliceType)\n+\tcase reflect.Slice:\n+\t\tsliceType := v.Type()\n \t\tif sliceType.Elem().Kind() == reflect.Uint8 {\n \t\t\tbytes := make([]byte, v.Len())\n \t\t\tfor i := 0; i < v.Len(); i++ {\n-\t\t\t\tbytes[i] = uint8(v.Elem(i).(*reflect.UintValue).Get())\n+\t\t\t\tbytes[i] = uint8(v.Index(i).Uint())\n \t\t\t}\n \t\t\t_, err = out.Write(bytes)\n \t\t\treturn\n@@ -372,17 +394,17 @@ func marshalBody(out *forkableWriter, value reflect.Value, params fieldParameter\n \t\tfor i := 0; i < v.Len(); i++ {\n \t\t\tvar pre *forkableWriter\n \t\t\tpre, out = out.fork()\n-\t\t\terr = marshalField(pre, v.Elem(i), params)\n+\t\t\terr = marshalField(pre, v.Index(i), params)\n \t\t\tif err != nil {\n \t\t\t\treturn\n \t\t\t}\n \t\t}\n \t\treturn\n-\tcase *reflect.StringValue:\n+\tcase reflect.String:\n \t\tif params.stringType == tagIA5String {\n-\t\t\treturn marshalIA5String(out, v.Get())\n+\t\t\treturn marshalIA5String(out, v.String())\n \t\t} else {\n-\t\t\treturn marshalPrintableString(out, v.Get())\n+\t\t\treturn marshalPrintableString(out, v.String())\n \t\t}\n \t\treturn\n \t}\n@@ -392,7 +414,7 @@ func marshalBody(out *forkableWriter, value reflect.Value, params fieldParameter\n \n func marshalField(out *forkableWriter, v reflect.Value, params fieldParameters) (err os.Error) {\n \t// If the field is an interface{} then recurse into it.\n-\tif v, ok := v.(*reflect.InterfaceValue); ok && v.Type().(*reflect.InterfaceType).NumMethod() == 0 {\n+\tif v.Kind() == reflect.Interface && v.Type().NumMethod() == 0 {\n \t\treturn marshalField(out, v.Elem(), params)\n \t}\n \n@@ -406,7 +428,7 @@ func marshalField(out *forkableWriter, v reflect.Value, params fieldParameters)\n \t\treturn\n \t}\n \n-\tif params.optional && reflect.DeepEqual(v.Interface(), reflect.MakeZero(v.Type()).Interface()) {\n+\tif params.optional && reflect.DeepEqual(v.Interface(), reflect.Zero(v.Type()).Interface()) {\n \t\treturn\n \t}\n \n@@ -471,7 +493,7 @@ func marshalField(out *forkableWriter, v reflect.Value, params fieldParameters)\n // Marshal returns the ASN.1 encoding of val.\n func Marshal(val interface{}) ([]byte, os.Error) {\n \tvar out bytes.Buffer\n-\tv := reflect.NewValue(val)\n+\tv := reflect.ValueOf(val)\n \tf := newForkableWriter()\n \terr := marshalField(f, v, fieldParameters{})\n \tif err != nil {"}, {"sha": "cd165d203528ec07732e8734dd70cca0133fa1a1", "filename": "libgo/go/asn1/marshal_test.go", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fasn1%2Fmarshal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fasn1%2Fmarshal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fasn1%2Fmarshal_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -77,6 +77,30 @@ var marshalTests = []marshalTest{\n \t{ObjectIdentifier([]int{1, 2, 3, 4}), \"06032a0304\"},\n \t{ObjectIdentifier([]int{1, 2, 840, 133549, 1, 1, 5}), \"06092a864888932d010105\"},\n \t{\"test\", \"130474657374\"},\n+\t{\n+\t\t\"\" +\n+\t\t\t\"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\" +\n+\t\t\t\"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\" +\n+\t\t\t\"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\" +\n+\t\t\t\"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\", // This is 127 times 'x'\n+\t\t\"137f\" +\n+\t\t\t\"7878787878787878787878787878787878787878787878787878787878787878\" +\n+\t\t\t\"7878787878787878787878787878787878787878787878787878787878787878\" +\n+\t\t\t\"7878787878787878787878787878787878787878787878787878787878787878\" +\n+\t\t\t\"78787878787878787878787878787878787878787878787878787878787878\",\n+\t},\n+\t{\n+\t\t\"\" +\n+\t\t\t\"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\" +\n+\t\t\t\"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\" +\n+\t\t\t\"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\" +\n+\t\t\t\"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\", // This is 128 times 'x'\n+\t\t\"138180\" +\n+\t\t\t\"7878787878787878787878787878787878787878787878787878787878787878\" +\n+\t\t\t\"7878787878787878787878787878787878787878787878787878787878787878\" +\n+\t\t\t\"7878787878787878787878787878787878787878787878787878787878787878\" +\n+\t\t\t\"7878787878787878787878787878787878787878787878787878787878787878\",\n+\t},\n \t{ia5StringTest{\"test\"}, \"3006160474657374\"},\n \t{printableStringTest{\"test\"}, \"3006130474657374\"},\n \t{printableStringTest{\"test*\"}, \"30071305746573742a\"},"}, {"sha": "f1ea7b1c2ec2cf8c524dc444f541b4f276928ec7", "filename": "libgo/go/big/int.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fbig%2Fint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fbig%2Fint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbig%2Fint.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -337,6 +337,10 @@ func fmtbase(ch int) int {\n // 'x' (hexadecimal).\n //\n func (x *Int) Format(s fmt.State, ch int) {\n+\tif x == nil {\n+\t\tfmt.Fprint(s, \"<nil>\")\n+\t\treturn\n+\t}\n \tif x.neg {\n \t\tfmt.Fprint(s, \"-\")\n \t}"}, {"sha": "4848d427b39d48d474d3fb1a3f2a320a99d62954", "filename": "libgo/go/big/nat.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fbig%2Fnat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fbig%2Fnat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbig%2Fnat.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,11 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This file contains operations on unsigned multi-precision integers.\n-// These are the building blocks for the operations on signed integers\n-// and rationals.\n-\n-// This package implements multi-precision arithmetic (big numbers).\n+// Package big implements multi-precision arithmetic (big numbers).\n // The following numeric types are supported:\n //\n //\t- Int\tsigned integers\n@@ -18,6 +14,10 @@\n //\n package big\n \n+// This file contains operations on unsigned multi-precision integers.\n+// These are the building blocks for the operations on signed integers\n+// and rationals.\n+\n import \"rand\"\n \n // An unsigned integer x of the form"}, {"sha": "eaae8bb42c35bd8a75e4dd618073b9fa9b91b825", "filename": "libgo/go/bufio/bufio.go", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fbufio%2Fbufio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fbufio%2Fbufio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This package implements buffered I/O.  It wraps an io.Reader or io.Writer\n+// Package bufio implements buffered I/O.  It wraps an io.Reader or io.Writer\n // object, creating another object (Reader or Writer) that also implements\n // the interface but provides buffering and some help for textual I/O.\n package bufio\n@@ -282,6 +282,33 @@ func (b *Reader) ReadSlice(delim byte) (line []byte, err os.Error) {\n \tpanic(\"not reached\")\n }\n \n+// ReadLine tries to return a single line, not including the end-of-line bytes.\n+// If the line was too long for the buffer then isPrefix is set and the\n+// beginning of the line is returned. The rest of the line will be returned\n+// from future calls. isPrefix will be false when returning the last fragment\n+// of the line. The returned buffer is only valid until the next call to\n+// ReadLine. ReadLine either returns a non-nil line or it returns an error,\n+// never both.\n+func (b *Reader) ReadLine() (line []byte, isPrefix bool, err os.Error) {\n+\tline, err = b.ReadSlice('\\n')\n+\tif err == ErrBufferFull {\n+\t\treturn line, true, nil\n+\t}\n+\n+\tif len(line) == 0 {\n+\t\treturn\n+\t}\n+\terr = nil\n+\n+\tif line[len(line)-1] == '\\n' {\n+\t\tline = line[:len(line)-1]\n+\t}\n+\tif len(line) > 0 && line[len(line)-1] == '\\r' {\n+\t\tline = line[:len(line)-1]\n+\t}\n+\treturn\n+}\n+\n // ReadBytes reads until the first occurrence of delim in the input,\n // returning a slice containing the data up to and including the delimiter.\n // If ReadBytes encounters an error before finding a delimiter,"}, {"sha": "123adac29a4996b43f5e850fefe7635c190ae4d1", "filename": "libgo/go/bufio/bufio_test.go", "status": "modified", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -9,6 +9,7 @@ import (\n \t\"bytes\"\n \t\"fmt\"\n \t\"io\"\n+\t\"io/ioutil\"\n \t\"os\"\n \t\"strings\"\n \t\"testing\"\n@@ -570,3 +571,128 @@ func TestPeekThenUnreadRune(t *testing.T) {\n \tr.UnreadRune()\n \tr.ReadRune() // Used to panic here\n }\n+\n+var testOutput = []byte(\"0123456789abcdefghijklmnopqrstuvwxy\")\n+var testInput = []byte(\"012\\n345\\n678\\n9ab\\ncde\\nfgh\\nijk\\nlmn\\nopq\\nrst\\nuvw\\nxy\")\n+var testInputrn = []byte(\"012\\r\\n345\\r\\n678\\r\\n9ab\\r\\ncde\\r\\nfgh\\r\\nijk\\r\\nlmn\\r\\nopq\\r\\nrst\\r\\nuvw\\r\\nxy\\r\\n\\n\\r\\n\")\n+\n+// TestReader wraps a []byte and returns reads of a specific length.\n+type testReader struct {\n+\tdata   []byte\n+\tstride int\n+}\n+\n+func (t *testReader) Read(buf []byte) (n int, err os.Error) {\n+\tn = t.stride\n+\tif n > len(t.data) {\n+\t\tn = len(t.data)\n+\t}\n+\tif n > len(buf) {\n+\t\tn = len(buf)\n+\t}\n+\tcopy(buf, t.data)\n+\tt.data = t.data[n:]\n+\tif len(t.data) == 0 {\n+\t\terr = os.EOF\n+\t}\n+\treturn\n+}\n+\n+func testReadLine(t *testing.T, input []byte) {\n+\t//for stride := 1; stride < len(input); stride++ {\n+\tfor stride := 1; stride < 2; stride++ {\n+\t\tdone := 0\n+\t\treader := testReader{input, stride}\n+\t\tl, _ := NewReaderSize(&reader, len(input)+1)\n+\t\tfor {\n+\t\t\tline, isPrefix, err := l.ReadLine()\n+\t\t\tif len(line) > 0 && err != nil {\n+\t\t\t\tt.Errorf(\"ReadLine returned both data and error: %s\", err)\n+\t\t\t}\n+\t\t\tif isPrefix {\n+\t\t\t\tt.Errorf(\"ReadLine returned prefix\")\n+\t\t\t}\n+\t\t\tif err != nil {\n+\t\t\t\tif err != os.EOF {\n+\t\t\t\t\tt.Fatalf(\"Got unknown error: %s\", err)\n+\t\t\t\t}\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tif want := testOutput[done : done+len(line)]; !bytes.Equal(want, line) {\n+\t\t\t\tt.Errorf(\"Bad line at stride %d: want: %x got: %x\", stride, want, line)\n+\t\t\t}\n+\t\t\tdone += len(line)\n+\t\t}\n+\t\tif done != len(testOutput) {\n+\t\t\tt.Errorf(\"ReadLine didn't return everything: got: %d, want: %d (stride: %d)\", done, len(testOutput), stride)\n+\t\t}\n+\t}\n+}\n+\n+func TestReadLine(t *testing.T) {\n+\ttestReadLine(t, testInput)\n+\ttestReadLine(t, testInputrn)\n+}\n+\n+func TestLineTooLong(t *testing.T) {\n+\tbuf := bytes.NewBuffer([]byte(\"aaabbbcc\\n\"))\n+\tl, _ := NewReaderSize(buf, 3)\n+\tline, isPrefix, err := l.ReadLine()\n+\tif !isPrefix || !bytes.Equal(line, []byte(\"aaa\")) || err != nil {\n+\t\tt.Errorf(\"bad result for first line: %x %s\", line, err)\n+\t}\n+\tline, isPrefix, err = l.ReadLine()\n+\tif !isPrefix || !bytes.Equal(line, []byte(\"bbb\")) || err != nil {\n+\t\tt.Errorf(\"bad result for second line: %x\", line)\n+\t}\n+\tline, isPrefix, err = l.ReadLine()\n+\tif isPrefix || !bytes.Equal(line, []byte(\"cc\")) || err != nil {\n+\t\tt.Errorf(\"bad result for third line: %x\", line)\n+\t}\n+\tline, isPrefix, err = l.ReadLine()\n+\tif isPrefix || err == nil {\n+\t\tt.Errorf(\"expected no more lines: %x %s\", line, err)\n+\t}\n+}\n+\n+func TestReadAfterLines(t *testing.T) {\n+\tline1 := \"line1\"\n+\trestData := \"line2\\nline 3\\n\"\n+\tinbuf := bytes.NewBuffer([]byte(line1 + \"\\n\" + restData))\n+\toutbuf := new(bytes.Buffer)\n+\tmaxLineLength := len(line1) + len(restData)/2\n+\tl, _ := NewReaderSize(inbuf, maxLineLength)\n+\tline, isPrefix, err := l.ReadLine()\n+\tif isPrefix || err != nil || string(line) != line1 {\n+\t\tt.Errorf(\"bad result for first line: isPrefix=%v err=%v line=%q\", isPrefix, err, string(line))\n+\t}\n+\tn, err := io.Copy(outbuf, l)\n+\tif int(n) != len(restData) || err != nil {\n+\t\tt.Errorf(\"bad result for Read: n=%d err=%v\", n, err)\n+\t}\n+\tif outbuf.String() != restData {\n+\t\tt.Errorf(\"bad result for Read: got %q; expected %q\", outbuf.String(), restData)\n+\t}\n+}\n+\n+func TestReadEmptyBuffer(t *testing.T) {\n+\tl, _ := NewReaderSize(bytes.NewBuffer(nil), 10)\n+\tline, isPrefix, err := l.ReadLine()\n+\tif err != os.EOF {\n+\t\tt.Errorf(\"expected EOF from ReadLine, got '%s' %t %s\", line, isPrefix, err)\n+\t}\n+}\n+\n+func TestLinesAfterRead(t *testing.T) {\n+\tl, _ := NewReaderSize(bytes.NewBuffer([]byte(\"foo\")), 10)\n+\t_, err := ioutil.ReadAll(l)\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t\treturn\n+\t}\n+\n+\tline, isPrefix, err := l.ReadLine()\n+\tif err != os.EOF {\n+\t\tt.Errorf(\"expected EOF from ReadLine, got '%s' %t %s\", line, isPrefix, err)\n+\t}\n+}"}, {"sha": "0f9ac98637144427658f07035fb6a32381bdd753", "filename": "libgo/go/bytes/bytes.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fbytes%2Fbytes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fbytes%2Fbytes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,8 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// The bytes package implements functions for the manipulation of byte slices.\n-// Analogous to the facilities of the strings package.\n+// Package bytes implements functions for the manipulation of byte slices.\n+// It is analogous to the facilities of the strings package.\n package bytes\n \n import ("}, {"sha": "f3199cad561e21c08a7c5ad84752f3dbcd66e168", "filename": "libgo/go/cmath/abs.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcmath%2Fabs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcmath%2Fabs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmath%2Fabs.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,8 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// The cmath package provides basic constants\n-// and mathematical functions for complex numbers.\n+// Package cmath provides basic constants and mathematical functions for\n+// complex numbers.\n package cmath\n \n import \"math\""}, {"sha": "a02a5e8d94bcac794234dbf0b18782440284a8c0", "filename": "libgo/go/compress/flate/deflate.go", "status": "modified", "additions": 51, "deletions": 5, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -143,10 +143,18 @@ func (d *compressor) fillWindow(index int) (int, os.Error) {\n \t\t\td.blockStart = math.MaxInt32\n \t\t}\n \t\tfor i, h := range d.hashHead {\n-\t\t\td.hashHead[i] = max(h-wSize, -1)\n+\t\t\tv := h - wSize\n+\t\t\tif v < -1 {\n+\t\t\t\tv = -1\n+\t\t\t}\n+\t\t\td.hashHead[i] = v\n \t\t}\n \t\tfor i, h := range d.hashPrev {\n-\t\t\td.hashPrev[i] = max(h-wSize, -1)\n+\t\t\tv := -h - wSize\n+\t\t\tif v < -1 {\n+\t\t\t\tv = -1\n+\t\t\t}\n+\t\t\td.hashPrev[i] = v\n \t\t}\n \t}\n \tcount, err := d.r.Read(d.window[d.windowEnd:])\n@@ -177,10 +185,18 @@ func (d *compressor) writeBlock(tokens []token, index int, eof bool) os.Error {\n // Try to find a match starting at index whose length is greater than prevSize.\n // We only look at chainCount possibilities before giving up.\n func (d *compressor) findMatch(pos int, prevHead int, prevLength int, lookahead int) (length, offset int, ok bool) {\n-\twin := d.window[0 : pos+min(maxMatchLength, lookahead)]\n+\tminMatchLook := maxMatchLength\n+\tif lookahead < minMatchLook {\n+\t\tminMatchLook = lookahead\n+\t}\n+\n+\twin := d.window[0 : pos+minMatchLook]\n \n \t// We quit when we get a match that's at least nice long\n-\tnice := min(d.niceMatch, len(win)-pos)\n+\tnice := len(win) - pos\n+\tif d.niceMatch < nice {\n+\t\tnice = d.niceMatch\n+\t}\n \n \t// If we've got a match that's good enough, only look in 1/4 the chain.\n \ttries := d.maxChainLength\n@@ -344,9 +360,12 @@ Loop:\n \t\t}\n \t\tprevLength := length\n \t\tprevOffset := offset\n-\t\tminIndex := max(index-maxOffset, 0)\n \t\tlength = minMatchLength - 1\n \t\toffset = 0\n+\t\tminIndex := index - maxOffset\n+\t\tif minIndex < 0 {\n+\t\t\tminIndex = 0\n+\t\t}\n \n \t\tif chainHead >= minIndex &&\n \t\t\t(isFastDeflate && lookahead > minMatchLength-1 ||\n@@ -477,6 +496,33 @@ func NewWriter(w io.Writer, level int) *Writer {\n \treturn &Writer{pw, &d}\n }\n \n+// NewWriterDict is like NewWriter but initializes the new\n+// Writer with a preset dictionary.  The returned Writer behaves\n+// as if the dictionary had been written to it without producing\n+// any compressed output.  The compressed data written to w\n+// can only be decompressed by a Reader initialized with the\n+// same dictionary.\n+func NewWriterDict(w io.Writer, level int, dict []byte) *Writer {\n+\tdw := &dictWriter{w, false}\n+\tzw := NewWriter(dw, level)\n+\tzw.Write(dict)\n+\tzw.Flush()\n+\tdw.enabled = true\n+\treturn zw\n+}\n+\n+type dictWriter struct {\n+\tw       io.Writer\n+\tenabled bool\n+}\n+\n+func (w *dictWriter) Write(b []byte) (n int, err os.Error) {\n+\tif w.enabled {\n+\t\treturn w.w.Write(b)\n+\t}\n+\treturn len(b), nil\n+}\n+\n // A Writer takes data written to it and writes the compressed\n // form of that data to an underlying writer (see NewWriter).\n type Writer struct {"}, {"sha": "650a8059ace91c8e95e6a59e68f4ff1de79fb9d8", "filename": "libgo/go/compress/flate/deflate_test.go", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -275,3 +275,49 @@ func TestDeflateInflateString(t *testing.T) {\n \t}\n \ttestToFromWithLevel(t, 1, gold, \"2.718281828...\")\n }\n+\n+func TestReaderDict(t *testing.T) {\n+\tconst (\n+\t\tdict = \"hello world\"\n+\t\ttext = \"hello again world\"\n+\t)\n+\tvar b bytes.Buffer\n+\tw := NewWriter(&b, 5)\n+\tw.Write([]byte(dict))\n+\tw.Flush()\n+\tb.Reset()\n+\tw.Write([]byte(text))\n+\tw.Close()\n+\n+\tr := NewReaderDict(&b, []byte(dict))\n+\tdata, err := ioutil.ReadAll(r)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif string(data) != \"hello again world\" {\n+\t\tt.Fatalf(\"read returned %q want %q\", string(data), text)\n+\t}\n+}\n+\n+func TestWriterDict(t *testing.T) {\n+\tconst (\n+\t\tdict = \"hello world\"\n+\t\ttext = \"hello again world\"\n+\t)\n+\tvar b bytes.Buffer\n+\tw := NewWriter(&b, 5)\n+\tw.Write([]byte(dict))\n+\tw.Flush()\n+\tb.Reset()\n+\tw.Write([]byte(text))\n+\tw.Close()\n+\n+\tvar b1 bytes.Buffer\n+\tw = NewWriterDict(&b1, 5, []byte(dict))\n+\tw.Write([]byte(text))\n+\tw.Close()\n+\n+\tif !bytes.Equal(b1.Bytes(), b.Bytes()) {\n+\t\tt.Fatalf(\"writer wrote %q want %q\", b1.Bytes(), b.Bytes())\n+\t}\n+}"}, {"sha": "320b80d06994e80e2af5640a471781be7f49be7c", "filename": "libgo/go/compress/flate/inflate.go", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,9 +2,9 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// The flate package implements the DEFLATE compressed data\n-// format, described in RFC 1951.  The gzip and zlib packages\n-// implement access to DEFLATE-based file formats.\n+// Package flate implements the DEFLATE compressed data format, described in\n+// RFC 1951.  The gzip and zlib packages implement access to DEFLATE-based file\n+// formats.\n package flate\n \n import (\n@@ -526,6 +526,20 @@ func (f *decompressor) dataBlock() os.Error {\n \treturn nil\n }\n \n+func (f *decompressor) setDict(dict []byte) {\n+\tif len(dict) > len(f.hist) {\n+\t\t// Will only remember the tail.\n+\t\tdict = dict[len(dict)-len(f.hist):]\n+\t}\n+\n+\tf.hp = copy(f.hist[:], dict)\n+\tif f.hp == len(f.hist) {\n+\t\tf.hp = 0\n+\t\tf.hfull = true\n+\t}\n+\tf.hw = f.hp\n+}\n+\n func (f *decompressor) moreBits() os.Error {\n \tc, err := f.r.ReadByte()\n \tif err != nil {\n@@ -618,3 +632,16 @@ func NewReader(r io.Reader) io.ReadCloser {\n \tgo func() { pw.CloseWithError(f.decompress(r, pw)) }()\n \treturn pr\n }\n+\n+// NewReaderDict is like NewReader but initializes the reader\n+// with a preset dictionary.  The returned Reader behaves as if\n+// the uncompressed data stream started with the given dictionary,\n+// which has already been read.  NewReaderDict is typically used\n+// to read data compressed by NewWriterDict.\n+func NewReaderDict(r io.Reader, dict []byte) io.ReadCloser {\n+\tvar f decompressor\n+\tf.setDict(dict)\n+\tpr, pw := io.Pipe()\n+\tgo func() { pw.CloseWithError(f.decompress(r, pw)) }()\n+\treturn pr\n+}"}, {"sha": "b0ddc81d2529ada6fbdbcdc27954066fc1c576fa", "filename": "libgo/go/compress/gzip/gunzip.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,8 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// The gzip package implements reading and writing of\n-// gzip format compressed files, as specified in RFC 1952.\n+// Package gzip implements reading and writing of gzip format compressed files,\n+// as specified in RFC 1952.\n package gzip\n \n import ("}, {"sha": "a1cd2abc0439e0fea9fb1979eadf73dfc362e54c", "filename": "libgo/go/compress/lzw/reader.go", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcompress%2Flzw%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcompress%2Flzw%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Flzw%2Freader.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// The lzw package implements the Lempel-Ziv-Welch compressed data format,\n+// Package lzw implements the Lempel-Ziv-Welch compressed data format,\n // described in T. A. Welch, ``A Technique for High-Performance Data\n // Compression'', Computer, 17(6) (June 1984), pp 8-19.\n //\n@@ -165,16 +165,19 @@ func decode1(pw *io.PipeWriter, r io.ByteReader, read func(*decoder) (uint16, os\n \t\t\tif _, err := w.Write(buf[i:]); err != nil {\n \t\t\t\treturn err\n \t\t\t}\n-\t\t\t// Save what the hi code expands to.\n-\t\t\tsuffix[hi] = uint8(c)\n-\t\t\tprefix[hi] = last\n+\t\t\tif last != invalidCode {\n+\t\t\t\t// Save what the hi code expands to.\n+\t\t\t\tsuffix[hi] = uint8(c)\n+\t\t\t\tprefix[hi] = last\n+\t\t\t}\n \t\tdefault:\n \t\t\treturn os.NewError(\"lzw: invalid code\")\n \t\t}\n \t\tlast, hi = code, hi+1\n-\t\tif hi == overflow {\n+\t\tif hi >= overflow {\n \t\t\tif d.width == maxWidth {\n-\t\t\t\treturn os.NewError(\"lzw: missing clear code\")\n+\t\t\t\tlast = invalidCode\n+\t\t\t\tcontinue\n \t\t\t}\n \t\t\td.width++\n \t\t\toverflow <<= 1"}, {"sha": "72121a6b5696261fbd988c583fb316f9fb3fcf13", "filename": "libgo/go/compress/lzw/reader_test.go", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcompress%2Flzw%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcompress%2Flzw%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Flzw%2Freader_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -112,12 +112,6 @@ func TestReader(t *testing.T) {\n \t}\n }\n \n-type devNull struct{}\n-\n-func (devNull) Write(p []byte) (int, os.Error) {\n-\treturn len(p), nil\n-}\n-\n func benchmarkDecoder(b *testing.B, n int) {\n \tb.StopTimer()\n \tb.SetBytes(int64(n))\n@@ -134,7 +128,7 @@ func benchmarkDecoder(b *testing.B, n int) {\n \truntime.GC()\n \tb.StartTimer()\n \tfor i := 0; i < b.N; i++ {\n-\t\tio.Copy(devNull{}, NewReader(bytes.NewBuffer(buf1), LSB, 8))\n+\t\tio.Copy(ioutil.Discard, NewReader(bytes.NewBuffer(buf1), LSB, 8))\n \t}\n }\n "}, {"sha": "82464ecd1b0811b23eadc5b00cdeca7c9b07ccdb", "filename": "libgo/go/compress/lzw/writer_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -113,7 +113,7 @@ func benchmarkEncoder(b *testing.B, n int) {\n \truntime.GC()\n \tb.StartTimer()\n \tfor i := 0; i < b.N; i++ {\n-\t\tw := NewWriter(devNull{}, LSB, 8)\n+\t\tw := NewWriter(ioutil.Discard, LSB, 8)\n \t\tw.Write(buf1)\n \t\tw.Close()\n \t}"}, {"sha": "8a3ef1580aaeb74b5afb305bb5e5ef8c21b7358a", "filename": "libgo/go/compress/zlib/reader.go", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcompress%2Fzlib%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcompress%2Fzlib%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fzlib%2Freader.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -3,8 +3,8 @@\n // license that can be found in the LICENSE file.\n \n /*\n-The zlib package implements reading and writing of zlib\n-format compressed data, as specified in RFC 1950.\n+Package zlib implements reading and writing of zlib format compressed data,\n+as specified in RFC 1950.\n \n The implementation provides filters that uncompress during reading\n and compress during writing.  For example, to write compressed data\n@@ -36,7 +36,7 @@ const zlibDeflate = 8\n \n var ChecksumError os.Error = os.ErrorString(\"zlib checksum error\")\n var HeaderError os.Error = os.ErrorString(\"invalid zlib header\")\n-var UnsupportedError os.Error = os.ErrorString(\"unsupported zlib format\")\n+var DictionaryError os.Error = os.ErrorString(\"invalid zlib dictionary\")\n \n type reader struct {\n \tr            flate.Reader\n@@ -50,6 +50,12 @@ type reader struct {\n // The implementation buffers input and may read more data than necessary from r.\n // It is the caller's responsibility to call Close on the ReadCloser when done.\n func NewReader(r io.Reader) (io.ReadCloser, os.Error) {\n+\treturn NewReaderDict(r, nil)\n+}\n+\n+// NewReaderDict is like NewReader but uses a preset dictionary.\n+// NewReaderDict ignores the dictionary if the compressed data does not refer to it.\n+func NewReaderDict(r io.Reader, dict []byte) (io.ReadCloser, os.Error) {\n \tz := new(reader)\n \tif fr, ok := r.(flate.Reader); ok {\n \t\tz.r = fr\n@@ -65,11 +71,19 @@ func NewReader(r io.Reader) (io.ReadCloser, os.Error) {\n \t\treturn nil, HeaderError\n \t}\n \tif z.scratch[1]&0x20 != 0 {\n-\t\t// BUG(nigeltao): The zlib package does not implement the FDICT flag.\n-\t\treturn nil, UnsupportedError\n+\t\t_, err = io.ReadFull(z.r, z.scratch[0:4])\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tchecksum := uint32(z.scratch[0])<<24 | uint32(z.scratch[1])<<16 | uint32(z.scratch[2])<<8 | uint32(z.scratch[3])\n+\t\tif checksum != adler32.Checksum(dict) {\n+\t\t\treturn nil, DictionaryError\n+\t\t}\n+\t\tz.decompressor = flate.NewReaderDict(z.r, dict)\n+\t} else {\n+\t\tz.decompressor = flate.NewReader(z.r)\n \t}\n \tz.digest = adler32.New()\n-\tz.decompressor = flate.NewReader(z.r)\n \treturn z, nil\n }\n "}, {"sha": "195db446c9fff0ae708cc55989ba1136c249eb79", "filename": "libgo/go/compress/zlib/reader_test.go", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcompress%2Fzlib%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcompress%2Fzlib%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fzlib%2Freader_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -15,6 +15,7 @@ type zlibTest struct {\n \tdesc       string\n \traw        string\n \tcompressed []byte\n+\tdict       []byte\n \terr        os.Error\n }\n \n@@ -27,6 +28,7 @@ var zlibTests = []zlibTest{\n \t\t\"\",\n \t\t[]byte{0x78, 0x9c, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01},\n \t\tnil,\n+\t\tnil,\n \t},\n \t{\n \t\t\"goodbye\",\n@@ -37,23 +39,27 @@ var zlibTests = []zlibTest{\n \t\t\t0x01, 0x00, 0x28, 0xa5, 0x05, 0x5e,\n \t\t},\n \t\tnil,\n+\t\tnil,\n \t},\n \t{\n \t\t\"bad header\",\n \t\t\"\",\n \t\t[]byte{0x78, 0x9f, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01},\n+\t\tnil,\n \t\tHeaderError,\n \t},\n \t{\n \t\t\"bad checksum\",\n \t\t\"\",\n \t\t[]byte{0x78, 0x9c, 0x03, 0x00, 0x00, 0x00, 0x00, 0xff},\n+\t\tnil,\n \t\tChecksumError,\n \t},\n \t{\n \t\t\"not enough data\",\n \t\t\"\",\n \t\t[]byte{0x78, 0x9c, 0x03, 0x00, 0x00, 0x00},\n+\t\tnil,\n \t\tio.ErrUnexpectedEOF,\n \t},\n \t{\n@@ -64,14 +70,41 @@ var zlibTests = []zlibTest{\n \t\t\t0x78, 0x9c, 0xff,\n \t\t},\n \t\tnil,\n+\t\tnil,\n+\t},\n+\t{\n+\t\t\"dictionary\",\n+\t\t\"Hello, World!\\n\",\n+\t\t[]byte{\n+\t\t\t0x78, 0xbb, 0x1c, 0x32, 0x04, 0x27, 0xf3, 0x00,\n+\t\t\t0xb1, 0x75, 0x20, 0x1c, 0x45, 0x2e, 0x00, 0x24,\n+\t\t\t0x12, 0x04, 0x74,\n+\t\t},\n+\t\t[]byte{\n+\t\t\t0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x57, 0x6f, 0x72, 0x6c, 0x64, 0x0a,\n+\t\t},\n+\t\tnil,\n+\t},\n+\t{\n+\t\t\"wrong dictionary\",\n+\t\t\"\",\n+\t\t[]byte{\n+\t\t\t0x78, 0xbb, 0x1c, 0x32, 0x04, 0x27, 0xf3, 0x00,\n+\t\t\t0xb1, 0x75, 0x20, 0x1c, 0x45, 0x2e, 0x00, 0x24,\n+\t\t\t0x12, 0x04, 0x74,\n+\t\t},\n+\t\t[]byte{\n+\t\t\t0x48, 0x65, 0x6c, 0x6c,\n+\t\t},\n+\t\tDictionaryError,\n \t},\n }\n \n func TestDecompressor(t *testing.T) {\n \tb := new(bytes.Buffer)\n \tfor _, tt := range zlibTests {\n \t\tin := bytes.NewBuffer(tt.compressed)\n-\t\tzlib, err := NewReader(in)\n+\t\tzlib, err := NewReaderDict(in, tt.dict)\n \t\tif err != nil {\n \t\t\tif err != tt.err {\n \t\t\t\tt.Errorf(\"%s: NewReader: %s\", tt.desc, err)"}, {"sha": "f1f9b285375685bbd01382624ae9571e2ad43d6a", "filename": "libgo/go/compress/zlib/writer.go", "status": "modified", "additions": 46, "deletions": 13, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -21,56 +21,80 @@ const (\n \tDefaultCompression = flate.DefaultCompression\n )\n \n-type writer struct {\n+// A Writer takes data written to it and writes the compressed\n+// form of that data to an underlying writer (see NewWriter).\n+type Writer struct {\n \tw          io.Writer\n-\tcompressor io.WriteCloser\n+\tcompressor *flate.Writer\n \tdigest     hash.Hash32\n \terr        os.Error\n \tscratch    [4]byte\n }\n \n // NewWriter calls NewWriterLevel with the default compression level.\n-func NewWriter(w io.Writer) (io.WriteCloser, os.Error) {\n+func NewWriter(w io.Writer) (*Writer, os.Error) {\n \treturn NewWriterLevel(w, DefaultCompression)\n }\n \n-// NewWriterLevel creates a new io.WriteCloser that satisfies writes by compressing data written to w.\n+// NewWriterLevel calls NewWriterDict with no dictionary.\n+func NewWriterLevel(w io.Writer, level int) (*Writer, os.Error) {\n+\treturn NewWriterDict(w, level, nil)\n+}\n+\n+// NewWriterDict creates a new io.WriteCloser that satisfies writes by compressing data written to w.\n // It is the caller's responsibility to call Close on the WriteCloser when done.\n // level is the compression level, which can be DefaultCompression, NoCompression,\n // or any integer value between BestSpeed and BestCompression (inclusive).\n-func NewWriterLevel(w io.Writer, level int) (io.WriteCloser, os.Error) {\n-\tz := new(writer)\n+// dict is the preset dictionary to compress with, or nil to use no dictionary.\n+func NewWriterDict(w io.Writer, level int, dict []byte) (*Writer, os.Error) {\n+\tz := new(Writer)\n \t// ZLIB has a two-byte header (as documented in RFC 1950).\n \t// The first four bits is the CINFO (compression info), which is 7 for the default deflate window size.\n \t// The next four bits is the CM (compression method), which is 8 for deflate.\n \tz.scratch[0] = 0x78\n \t// The next two bits is the FLEVEL (compression level). The four values are:\n \t// 0=fastest, 1=fast, 2=default, 3=best.\n-\t// The next bit, FDICT, is unused, in this implementation.\n+\t// The next bit, FDICT, is set if a dictionary is given.\n \t// The final five FCHECK bits form a mod-31 checksum.\n \tswitch level {\n \tcase 0, 1:\n-\t\tz.scratch[1] = 0x01\n+\t\tz.scratch[1] = 0 << 6\n \tcase 2, 3, 4, 5:\n-\t\tz.scratch[1] = 0x5e\n+\t\tz.scratch[1] = 1 << 6\n \tcase 6, -1:\n-\t\tz.scratch[1] = 0x9c\n+\t\tz.scratch[1] = 2 << 6\n \tcase 7, 8, 9:\n-\t\tz.scratch[1] = 0xda\n+\t\tz.scratch[1] = 3 << 6\n \tdefault:\n \t\treturn nil, os.NewError(\"level out of range\")\n \t}\n+\tif dict != nil {\n+\t\tz.scratch[1] |= 1 << 5\n+\t}\n+\tz.scratch[1] += uint8(31 - (uint16(z.scratch[0])<<8+uint16(z.scratch[1]))%31)\n \t_, err := w.Write(z.scratch[0:2])\n \tif err != nil {\n \t\treturn nil, err\n \t}\n+\tif dict != nil {\n+\t\t// The next four bytes are the Adler-32 checksum of the dictionary.\n+\t\tchecksum := adler32.Checksum(dict)\n+\t\tz.scratch[0] = uint8(checksum >> 24)\n+\t\tz.scratch[1] = uint8(checksum >> 16)\n+\t\tz.scratch[2] = uint8(checksum >> 8)\n+\t\tz.scratch[3] = uint8(checksum >> 0)\n+\t\t_, err = w.Write(z.scratch[0:4])\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n \tz.w = w\n \tz.compressor = flate.NewWriter(w, level)\n \tz.digest = adler32.New()\n \treturn z, nil\n }\n \n-func (z *writer) Write(p []byte) (n int, err os.Error) {\n+func (z *Writer) Write(p []byte) (n int, err os.Error) {\n \tif z.err != nil {\n \t\treturn 0, z.err\n \t}\n@@ -86,8 +110,17 @@ func (z *writer) Write(p []byte) (n int, err os.Error) {\n \treturn\n }\n \n+// Flush flushes the underlying compressor.\n+func (z *Writer) Flush() os.Error {\n+\tif z.err != nil {\n+\t\treturn z.err\n+\t}\n+\tz.err = z.compressor.Flush()\n+\treturn z.err\n+}\n+\n // Calling Close does not close the wrapped io.Writer originally passed to NewWriter.\n-func (z *writer) Close() os.Error {\n+func (z *Writer) Close() os.Error {\n \tif z.err != nil {\n \t\treturn z.err\n \t}"}, {"sha": "f94f28470065effa9821e66e586f77e0a4736c03", "filename": "libgo/go/compress/zlib/writer_test.go", "status": "modified", "additions": 34, "deletions": 17, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -16,39 +16,45 @@ var filenames = []string{\n \t\"../testdata/pi.txt\",\n }\n \n-// Tests that compressing and then decompressing the given file at the given compression level\n+// Tests that compressing and then decompressing the given file at the given compression level and dictionary\n // yields equivalent bytes to the original file.\n-func testFileLevel(t *testing.T, fn string, level int) {\n+func testFileLevelDict(t *testing.T, fn string, level int, d string) {\n+\t// Read dictionary, if given.\n+\tvar dict []byte\n+\tif d != \"\" {\n+\t\tdict = []byte(d)\n+\t}\n+\n \t// Read the file, as golden output.\n \tgolden, err := os.Open(fn)\n \tif err != nil {\n-\t\tt.Errorf(\"%s (level=%d): %v\", fn, level, err)\n+\t\tt.Errorf(\"%s (level=%d, dict=%q): %v\", fn, level, d, err)\n \t\treturn\n \t}\n \tdefer golden.Close()\n \n \t// Read the file again, and push it through a pipe that compresses at the write end, and decompresses at the read end.\n \traw, err := os.Open(fn)\n \tif err != nil {\n-\t\tt.Errorf(\"%s (level=%d): %v\", fn, level, err)\n+\t\tt.Errorf(\"%s (level=%d, dict=%q): %v\", fn, level, d, err)\n \t\treturn\n \t}\n \tpiper, pipew := io.Pipe()\n \tdefer piper.Close()\n \tgo func() {\n \t\tdefer raw.Close()\n \t\tdefer pipew.Close()\n-\t\tzlibw, err := NewWriterLevel(pipew, level)\n+\t\tzlibw, err := NewWriterDict(pipew, level, dict)\n \t\tif err != nil {\n-\t\t\tt.Errorf(\"%s (level=%d): %v\", fn, level, err)\n+\t\t\tt.Errorf(\"%s (level=%d, dict=%q): %v\", fn, level, d, err)\n \t\t\treturn\n \t\t}\n \t\tdefer zlibw.Close()\n \t\tvar b [1024]byte\n \t\tfor {\n \t\t\tn, err0 := raw.Read(b[0:])\n \t\t\tif err0 != nil && err0 != os.EOF {\n-\t\t\t\tt.Errorf(\"%s (level=%d): %v\", fn, level, err0)\n+\t\t\t\tt.Errorf(\"%s (level=%d, dict=%q): %v\", fn, level, d, err0)\n \t\t\t\treturn\n \t\t\t}\n \t\t\t_, err1 := zlibw.Write(b[0:n])\n@@ -57,17 +63,17 @@ func testFileLevel(t *testing.T, fn string, level int) {\n \t\t\t\treturn\n \t\t\t}\n \t\t\tif err1 != nil {\n-\t\t\t\tt.Errorf(\"%s (level=%d): %v\", fn, level, err1)\n+\t\t\t\tt.Errorf(\"%s (level=%d, dict=%q): %v\", fn, level, d, err1)\n \t\t\t\treturn\n \t\t\t}\n \t\t\tif err0 == os.EOF {\n \t\t\t\tbreak\n \t\t\t}\n \t\t}\n \t}()\n-\tzlibr, err := NewReader(piper)\n+\tzlibr, err := NewReaderDict(piper, dict)\n \tif err != nil {\n-\t\tt.Errorf(\"%s (level=%d): %v\", fn, level, err)\n+\t\tt.Errorf(\"%s (level=%d, dict=%q): %v\", fn, level, d, err)\n \t\treturn\n \t}\n \tdefer zlibr.Close()\n@@ -76,31 +82,42 @@ func testFileLevel(t *testing.T, fn string, level int) {\n \tb0, err0 := ioutil.ReadAll(golden)\n \tb1, err1 := ioutil.ReadAll(zlibr)\n \tif err0 != nil {\n-\t\tt.Errorf(\"%s (level=%d): %v\", fn, level, err0)\n+\t\tt.Errorf(\"%s (level=%d, dict=%q): %v\", fn, level, d, err0)\n \t\treturn\n \t}\n \tif err1 != nil {\n-\t\tt.Errorf(\"%s (level=%d): %v\", fn, level, err1)\n+\t\tt.Errorf(\"%s (level=%d, dict=%q): %v\", fn, level, d, err1)\n \t\treturn\n \t}\n \tif len(b0) != len(b1) {\n-\t\tt.Errorf(\"%s (level=%d): length mismatch %d versus %d\", fn, level, len(b0), len(b1))\n+\t\tt.Errorf(\"%s (level=%d, dict=%q): length mismatch %d versus %d\", fn, level, d, len(b0), len(b1))\n \t\treturn\n \t}\n \tfor i := 0; i < len(b0); i++ {\n \t\tif b0[i] != b1[i] {\n-\t\t\tt.Errorf(\"%s (level=%d): mismatch at %d, 0x%02x versus 0x%02x\\n\", fn, level, i, b0[i], b1[i])\n+\t\t\tt.Errorf(\"%s (level=%d, dict=%q): mismatch at %d, 0x%02x versus 0x%02x\\n\", fn, level, d, i, b0[i], b1[i])\n \t\t\treturn\n \t\t}\n \t}\n }\n \n func TestWriter(t *testing.T) {\n \tfor _, fn := range filenames {\n-\t\ttestFileLevel(t, fn, DefaultCompression)\n-\t\ttestFileLevel(t, fn, NoCompression)\n+\t\ttestFileLevelDict(t, fn, DefaultCompression, \"\")\n+\t\ttestFileLevelDict(t, fn, NoCompression, \"\")\n+\t\tfor level := BestSpeed; level <= BestCompression; level++ {\n+\t\t\ttestFileLevelDict(t, fn, level, \"\")\n+\t\t}\n+\t}\n+}\n+\n+func TestWriterDict(t *testing.T) {\n+\tconst dictionary = \"0123456789.\"\n+\tfor _, fn := range filenames {\n+\t\ttestFileLevelDict(t, fn, DefaultCompression, dictionary)\n+\t\ttestFileLevelDict(t, fn, NoCompression, dictionary)\n \t\tfor level := BestSpeed; level <= BestCompression; level++ {\n-\t\t\ttestFileLevel(t, fn, level)\n+\t\t\ttestFileLevelDict(t, fn, level, dictionary)\n \t\t}\n \t}\n }"}, {"sha": "f2b8a750a45c16ee18b3fed854f7df4ae1623d33", "filename": "libgo/go/container/heap/heap.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This package provides heap operations for any type that implements\n+// Package heap provides heap operations for any type that implements\n // heap.Interface.\n //\n package heap"}, {"sha": "5eb54374ab297d32aa5016f5aa5a73d4bc85bc84", "filename": "libgo/go/container/heap/heap_test.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,11 +2,12 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package heap\n+package heap_test\n \n import (\n \t\"testing\"\n \t\"container/vector\"\n+\t. \"container/heap\"\n )\n \n "}, {"sha": "a3fd4b39f322433fa05fc276309aecf558e18440", "filename": "libgo/go/container/list/list.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcontainer%2Flist%2Flist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcontainer%2Flist%2Flist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Flist%2Flist.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// The list package implements a doubly linked list.\n+// Package list implements a doubly linked list.\n //\n // To iterate over a list (where l is a *List):\n //\tfor e := l.Front(); e != nil; e = e.Next() {"}, {"sha": "cc870ce93649ac1b491b7ba3f2d785b03dc601e1", "filename": "libgo/go/container/ring/ring.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcontainer%2Fring%2Fring.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcontainer%2Fring%2Fring.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fring%2Fring.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// The ring package implements operations on circular lists.\n+// Package ring implements operations on circular lists.\n package ring\n \n // A Ring is an element of a circular list, or ring."}, {"sha": "bfb5481fb8904bdb0c251781ab7bfb520c6f72e2", "filename": "libgo/go/container/vector/defs.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcontainer%2Fvector%2Fdefs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcontainer%2Fvector%2Fdefs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fvector%2Fdefs.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,8 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// The vector package implements containers for managing sequences\n-// of elements. Vectors grow and shrink dynamically as necessary.\n+// Package vector implements containers for managing sequences of elements.\n+// Vectors grow and shrink dynamically as necessary.\n package vector\n \n "}, {"sha": "25acd0d1702f2b2c387f4c61bcc6c42534bff432", "filename": "libgo/go/crypto/aes/const.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Faes%2Fconst.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Faes%2Fconst.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Fconst.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,12 +2,12 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// AES constants - 8720 bytes of initialized data.\n-\n-// This package implements AES encryption (formerly Rijndael),\n-// as defined in U.S. Federal Information Processing Standards Publication 197.\n+// Package aes implements AES encryption (formerly Rijndael), as defined in\n+// U.S. Federal Information Processing Standards Publication 197.\n package aes\n \n+// This file contains AES constants - 8720 bytes of initialized data.\n+\n // http://www.csrc.nist.gov/publications/fips/fips197/fips-197.pdf\n \n // AES is based on the mathematical behavior of binary polynomials"}, {"sha": "f3c5175acfaa358216caa12a572bcbbfb03d0937", "filename": "libgo/go/crypto/blowfish/cipher.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fblowfish%2Fcipher.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fblowfish%2Fcipher.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fblowfish%2Fcipher.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This package implements Bruce Schneier's Blowfish encryption algorithm.\n+// Package blowfish implements Bruce Schneier's Blowfish encryption algorithm.\n package blowfish\n \n // The code is a port of Bruce Schneier's C implementation."}, {"sha": "cb62e3132e8d17886f68ed2b7d6cf17bdd717026", "filename": "libgo/go/crypto/cast5/cast5.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fcast5%2Fcast5.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fcast5%2Fcast5.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcast5%2Fcast5.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This package implements CAST5, as defined in RFC 2144. CAST5 is a common\n+// Package cast5 implements CAST5, as defined in RFC 2144. CAST5 is a common\n // OpenPGP cipher.\n package cast5\n "}, {"sha": "1ffaa8c2c330795e237e7b6172614f8f77c2d3ee", "filename": "libgo/go/crypto/cipher/cipher.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcipher.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcipher.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcipher.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,8 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// The cipher package implements standard block cipher modes\n-// that can be wrapped around low-level block cipher implementations.\n+// Package cipher implements standard block cipher modes that can be wrapped\n+// around low-level block cipher implementations.\n // See http://csrc.nist.gov/groups/ST/toolkit/BCM/current_modes.html\n // and NIST Special Publication 800-38A.\n package cipher"}, {"sha": "53672a4da3c9efc40931c5f721cc000eaa8a7186", "filename": "libgo/go/crypto/crypto.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fcrypto.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fcrypto.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcrypto.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// The crypto package collects common cryptographic constants.\n+// Package crypto collects common cryptographic constants.\n package crypto\n \n import ("}, {"sha": "335c9645dc6ab56c1bb59b46df838191d9d05315", "filename": "libgo/go/crypto/elliptic/elliptic.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,8 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// The elliptic package implements several standard elliptic curves over prime\n-// fields\n+// Package elliptic implements several standard elliptic curves over prime\n+// fields.\n package elliptic\n \n // This package operates, internally, on Jacobian coordinates. For a given"}, {"sha": "04ec86e9ab115787f2b90e4f9c40d1db7a3a34a5", "filename": "libgo/go/crypto/hmac/hmac.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,8 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// The hmac package implements the Keyed-Hash Message Authentication Code (HMAC)\n-// as defined in U.S. Federal Information Processing Standards Publication 198.\n+// Package hmac implements the Keyed-Hash Message Authentication Code (HMAC) as\n+// defined in U.S. Federal Information Processing Standards Publication 198.\n // An HMAC is a cryptographic hash that uses a key to sign a message.\n // The receiver verifies the hash by recomputing it using the same key.\n package hmac"}, {"sha": "848d9552df55a0ed1620f9be978e716ec9263b75", "filename": "libgo/go/crypto/md4/md4.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fmd4%2Fmd4.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fmd4%2Fmd4.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd4%2Fmd4.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This package implements the MD4 hash algorithm as defined in RFC 1320.\n+// Package md4 implements the MD4 hash algorithm as defined in RFC 1320.\n package md4\n \n import ("}, {"sha": "378faa6ec71a247ca53ea0dc0dad478a1449e62e", "filename": "libgo/go/crypto/md5/md5.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This package implements the MD5 hash algorithm as defined in RFC 1321.\n+// Package md5 implements the MD5 hash algorithm as defined in RFC 1321.\n package md5\n \n import ("}, {"sha": "acd75b8b06ef1609fdfab68c02612c5611a83ed2", "filename": "libgo/go/crypto/ocsp/ocsp.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Focsp%2Focsp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Focsp%2Focsp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Focsp%2Focsp.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This package parses OCSP responses as specified in RFC 2560. OCSP responses\n+// Package ocsp parses OCSP responses as specified in RFC 2560. OCSP responses\n // are signed messages attesting to the validity of a certificate for a small\n // period of time. This is used to manage revocation for X.509 certificates.\n package ocsp"}, {"sha": "8da612c500777233d8717ce47afaea45257af492", "filename": "libgo/go/crypto/openpgp/armor/armor.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Farmor.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Farmor.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Farmor.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,15 +2,15 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This package implements OpenPGP ASCII Armor, see RFC 4880. OpenPGP Armor is\n+// Package armor implements OpenPGP ASCII Armor, see RFC 4880. OpenPGP Armor is\n // very similar to PEM except that it has an additional CRC checksum.\n package armor\n \n import (\n+\t\"bufio\"\n \t\"bytes\"\n \t\"crypto/openpgp/error\"\n \t\"encoding/base64\"\n-\t\"encoding/line\"\n \t\"io\"\n \t\"os\"\n )\n@@ -63,7 +63,7 @@ var armorEndOfLine = []byte(\"-----\")\n // lineReader wraps a line based reader. It watches for the end of an armor\n // block and records the expected CRC value.\n type lineReader struct {\n-\tin  *line.Reader\n+\tin  *bufio.Reader\n \tbuf []byte\n \teof bool\n \tcrc uint32\n@@ -156,7 +156,7 @@ func (r *openpgpReader) Read(p []byte) (n int, err os.Error) {\n // given Reader is not usable after calling this function: an arbitary amount\n // of data may have been read past the end of the block.\n func Decode(in io.Reader) (p *Block, err os.Error) {\n-\tr := line.NewReader(in, 100)\n+\tr, _ := bufio.NewReaderSize(in, 100)\n \tvar line []byte\n \tignoreNext := false\n "}, {"sha": "99dee375ef4e1f15bca58aebd162e7a2af354431", "filename": "libgo/go/crypto/openpgp/armor/encode.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Fencode.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -18,9 +18,9 @@ var armorEndOfLineOut = []byte(\"-----\\n\")\n // writeSlices writes its arguments to the given Writer.\n func writeSlices(out io.Writer, slices ...[]byte) (err os.Error) {\n \tfor _, s := range slices {\n-\t\t_, err := out.Write(s)\n+\t\t_, err = out.Write(s)\n \t\tif err != nil {\n-\t\t\treturn\n+\t\t\treturn err\n \t\t}\n \t}\n \treturn"}, {"sha": "3759ce16122672bebe0500b184c62d483e1a0777", "filename": "libgo/go/crypto/openpgp/error/error.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Ferror%2Ferror.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Ferror%2Ferror.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Ferror%2Ferror.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This package contains common error types for the OpenPGP packages.\n+// Package error contains common error types for the OpenPGP packages.\n package error\n \n import ("}, {"sha": "6c03f882831d128ae55db3c860f72eedfd537793", "filename": "libgo/go/crypto/openpgp/keys.go", "status": "modified", "additions": 41, "deletions": 22, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fkeys.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fkeys.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fkeys.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -5,6 +5,7 @@\n package openpgp\n \n import (\n+\t\"crypto/openpgp/armor\"\n \t\"crypto/openpgp/error\"\n \t\"crypto/openpgp/packet\"\n \t\"io\"\n@@ -13,6 +14,8 @@ import (\n \n // PublicKeyType is the armor type for a PGP public key.\n var PublicKeyType = \"PGP PUBLIC KEY BLOCK\"\n+// PrivateKeyType is the armor type for a PGP private key.\n+var PrivateKeyType = \"PGP PRIVATE KEY BLOCK\"\n \n // An Entity represents the components of an OpenPGP key: a primary public key\n // (which must be a signing key), one or more identities claimed by that key,\n@@ -101,37 +104,50 @@ func (el EntityList) DecryptionKeys() (keys []Key) {\n \n // ReadArmoredKeyRing reads one or more public/private keys from an armor keyring file.\n func ReadArmoredKeyRing(r io.Reader) (EntityList, os.Error) {\n-\tbody, err := readArmored(r, PublicKeyType)\n+\tblock, err := armor.Decode(r)\n+\tif err == os.EOF {\n+\t\treturn nil, error.InvalidArgumentError(\"no armored data found\")\n+\t}\n \tif err != nil {\n \t\treturn nil, err\n \t}\n+\tif block.Type != PublicKeyType && block.Type != PrivateKeyType {\n+\t\treturn nil, error.InvalidArgumentError(\"expected public or private key block, got: \" + block.Type)\n+\t}\n \n-\treturn ReadKeyRing(body)\n+\treturn ReadKeyRing(block.Body)\n }\n \n-// ReadKeyRing reads one or more public/private keys, ignoring unsupported keys.\n+// ReadKeyRing reads one or more public/private keys. Unsupported keys are\n+// ignored as long as at least a single valid key is found.\n func ReadKeyRing(r io.Reader) (el EntityList, err os.Error) {\n \tpackets := packet.NewReader(r)\n+\tvar lastUnsupportedError os.Error\n \n \tfor {\n \t\tvar e *Entity\n \t\te, err = readEntity(packets)\n \t\tif err != nil {\n \t\t\tif _, ok := err.(error.UnsupportedError); ok {\n+\t\t\t\tlastUnsupportedError = err\n \t\t\t\terr = readToNextPublicKey(packets)\n \t\t\t}\n \t\t\tif err == os.EOF {\n \t\t\t\terr = nil\n-\t\t\t\treturn\n+\t\t\t\tbreak\n \t\t\t}\n \t\t\tif err != nil {\n \t\t\t\tel = nil\n-\t\t\t\treturn\n+\t\t\t\tbreak\n \t\t\t}\n \t\t} else {\n \t\t\tel = append(el, e)\n \t\t}\n \t}\n+\n+\tif len(el) == 0 && err == nil {\n+\t\terr = lastUnsupportedError\n+\t}\n \treturn\n }\n \n@@ -197,25 +213,28 @@ EachPacket:\n \t\t\tcurrent.Name = pkt.Id\n \t\t\tcurrent.UserId = pkt\n \t\t\te.Identities[pkt.Id] = current\n-\t\t\tp, err = packets.Next()\n-\t\t\tif err == os.EOF {\n-\t\t\t\terr = io.ErrUnexpectedEOF\n-\t\t\t}\n-\t\t\tif err != nil {\n-\t\t\t\tif _, ok := err.(error.UnsupportedError); ok {\n+\n+\t\t\tfor {\n+\t\t\t\tp, err = packets.Next()\n+\t\t\t\tif err == os.EOF {\n+\t\t\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t\t\t} else if err != nil {\n \t\t\t\t\treturn nil, err\n \t\t\t\t}\n-\t\t\t\treturn nil, error.StructuralError(\"identity self-signature invalid: \" + err.String())\n-\t\t\t}\n-\t\t\tcurrent.SelfSignature, ok = p.(*packet.Signature)\n-\t\t\tif !ok {\n-\t\t\t\treturn nil, error.StructuralError(\"user ID packet not followed by self signature\")\n-\t\t\t}\n-\t\t\tif current.SelfSignature.SigType != packet.SigTypePositiveCert {\n-\t\t\t\treturn nil, error.StructuralError(\"user ID self-signature with wrong type\")\n-\t\t\t}\n-\t\t\tif err = e.PrimaryKey.VerifyUserIdSignature(pkt.Id, current.SelfSignature); err != nil {\n-\t\t\t\treturn nil, error.StructuralError(\"user ID self-signature invalid: \" + err.String())\n+\n+\t\t\t\tsig, ok := p.(*packet.Signature)\n+\t\t\t\tif !ok {\n+\t\t\t\t\treturn nil, error.StructuralError(\"user ID packet not followed by self-signature\")\n+\t\t\t\t}\n+\n+\t\t\t\tif sig.SigType == packet.SigTypePositiveCert && sig.IssuerKeyId != nil && *sig.IssuerKeyId == e.PrimaryKey.KeyId {\n+\t\t\t\t\tif err = e.PrimaryKey.VerifyUserIdSignature(pkt.Id, sig); err != nil {\n+\t\t\t\t\t\treturn nil, error.StructuralError(\"user ID self-signature invalid: \" + err.String())\n+\t\t\t\t\t}\n+\t\t\t\t\tcurrent.SelfSignature = sig\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tcurrent.Signatures = append(current.Signatures, sig)\n \t\t\t}\n \t\tcase *packet.Signature:\n \t\t\tif current == nil {"}, {"sha": "c0ec44dd8ec53867128a621240ba8e45465c4d86", "filename": "libgo/go/crypto/openpgp/packet/packet.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpacket.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpacket.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpacket.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This package implements parsing and serialisation of OpenPGP packets, as\n+// Package packet implements parsing and serialisation of OpenPGP packets, as\n // specified in RFC 4880.\n package packet\n "}, {"sha": "fde2a9933d831e02f1e704c56dcde21cd352c067", "filename": "libgo/go/crypto/openpgp/packet/private_key.go", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fprivate_key.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fprivate_key.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fprivate_key.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -164,8 +164,10 @@ func (pk *PrivateKey) parseRSAPrivateKey(data []byte) (err os.Error) {\n \t}\n \n \trsaPriv.D = new(big.Int).SetBytes(d)\n-\trsaPriv.P = new(big.Int).SetBytes(p)\n-\trsaPriv.Q = new(big.Int).SetBytes(q)\n+\trsaPriv.Primes = make([]*big.Int, 2)\n+\trsaPriv.Primes[0] = new(big.Int).SetBytes(p)\n+\trsaPriv.Primes[1] = new(big.Int).SetBytes(q)\n+\trsaPriv.Precompute()\n \tpk.PrivateKey = rsaPriv\n \tpk.Encrypted = false\n \tpk.encryptedData = nil"}, {"sha": "cd4a9aebb6083f40d8410185e97fb52e003ee562", "filename": "libgo/go/crypto/openpgp/packet/public_key.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpublic_key.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpublic_key.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpublic_key.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -15,6 +15,7 @@ import (\n \t\"hash\"\n \t\"io\"\n \t\"os\"\n+\t\"strconv\"\n )\n \n // PublicKey represents an OpenPGP public key. See RFC 4880, section 5.5.2.\n@@ -47,7 +48,7 @@ func (pk *PublicKey) parse(r io.Reader) (err os.Error) {\n \tcase PubKeyAlgoDSA:\n \t\terr = pk.parseDSA(r)\n \tdefault:\n-\t\terr = error.UnsupportedError(\"public key type\")\n+\t\terr = error.UnsupportedError(\"public key type: \" + strconv.Itoa(int(pk.PubKeyAlgo)))\n \t}\n \tif err != nil {\n \t\treturn"}, {"sha": "4f84dff82bb95b7eacbf2f096260521386542d49", "filename": "libgo/go/crypto/openpgp/read.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fread.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fread.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fread.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This openpgp package implements high level operations on OpenPGP messages.\n+// Package openpgp implements high level operations on OpenPGP messages.\n package openpgp\n \n import ("}, {"sha": "423c85b0f27b969e686c5c3d793ef390e73eadab", "filename": "libgo/go/crypto/openpgp/read_test.go", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fread_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fread_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fread_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -230,6 +230,23 @@ func TestDetachedSignatureDSA(t *testing.T) {\n \ttestDetachedSignature(t, kring, readerFromHex(detachedSignatureDSAHex), signedInput, \"binary\", testKey3KeyId)\n }\n \n+func TestReadingArmoredPrivateKey(t *testing.T) {\n+\tel, err := ReadArmoredKeyRing(bytes.NewBufferString(armoredPrivateKeyBlock))\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t}\n+\tif len(el) != 1 {\n+\t\tt.Errorf(\"got %d entities, wanted 1\\n\", len(el))\n+\t}\n+}\n+\n+func TestNoArmoredData(t *testing.T) {\n+\t_, err := ReadArmoredKeyRing(bytes.NewBufferString(\"foo\"))\n+\tif _, ok := err.(error.InvalidArgumentError); !ok {\n+\t\tt.Errorf(\"error was not an InvalidArgumentError: %s\", err)\n+\t}\n+}\n+\n const testKey1KeyId = 0xA34D7E18C20C31BB\n const testKey3KeyId = 0x338934250CCC0360\n \n@@ -259,3 +276,37 @@ const symmetricallyEncryptedCompressedHex = \"8c0d04030302eb4a03808145d0d260c92f7\n const dsaTestKeyHex = \"9901a2044d6c49de110400cb5ce438cf9250907ac2ba5bf6547931270b89f7c4b53d9d09f4d0213a5ef2ec1f26806d3d259960f872a4a102ef1581ea3f6d6882d15134f21ef6a84de933cc34c47cc9106efe3bd84c6aec12e78523661e29bc1a61f0aab17fa58a627fd5fd33f5149153fbe8cd70edf3d963bc287ef875270ff14b5bfdd1bca4483793923b00a0fe46d76cb6e4cbdc568435cd5480af3266d610d303fe33ae8273f30a96d4d34f42fa28ce1112d425b2e3bf7ea553d526e2db6b9255e9dc7419045ce817214d1a0056dbc8d5289956a4b1b69f20f1105124096e6a438f41f2e2495923b0f34b70642607d45559595c7fe94d7fa85fc41bf7d68c1fd509ebeaa5f315f6059a446b9369c277597e4f474a9591535354c7e7f4fd98a08aa60400b130c24ff20bdfbf683313f5daebf1c9b34b3bdadfc77f2ddd72ee1fb17e56c473664bc21d66467655dd74b9005e3a2bacce446f1920cd7017231ae447b67036c9b431b8179deacd5120262d894c26bc015bffe3d827ba7087ad9b700d2ca1f6d16cc1786581e5dd065f293c31209300f9b0afcc3f7c08dd26d0a22d87580b4db41054657374204b65792033202844534129886204131102002205024d6c49de021b03060b090807030206150802090a0b0416020301021e01021780000a0910338934250ccc03607e0400a0bdb9193e8a6b96fc2dfc108ae848914b504481f100a09c4dc148cb693293a67af24dd40d2b13a9e36794\"\n \n const dsaTestKeyPrivateHex = \"9501bb044d6c49de110400cb5ce438cf9250907ac2ba5bf6547931270b89f7c4b53d9d09f4d0213a5ef2ec1f26806d3d259960f872a4a102ef1581ea3f6d6882d15134f21ef6a84de933cc34c47cc9106efe3bd84c6aec12e78523661e29bc1a61f0aab17fa58a627fd5fd33f5149153fbe8cd70edf3d963bc287ef875270ff14b5bfdd1bca4483793923b00a0fe46d76cb6e4cbdc568435cd5480af3266d610d303fe33ae8273f30a96d4d34f42fa28ce1112d425b2e3bf7ea553d526e2db6b9255e9dc7419045ce817214d1a0056dbc8d5289956a4b1b69f20f1105124096e6a438f41f2e2495923b0f34b70642607d45559595c7fe94d7fa85fc41bf7d68c1fd509ebeaa5f315f6059a446b9369c277597e4f474a9591535354c7e7f4fd98a08aa60400b130c24ff20bdfbf683313f5daebf1c9b34b3bdadfc77f2ddd72ee1fb17e56c473664bc21d66467655dd74b9005e3a2bacce446f1920cd7017231ae447b67036c9b431b8179deacd5120262d894c26bc015bffe3d827ba7087ad9b700d2ca1f6d16cc1786581e5dd065f293c31209300f9b0afcc3f7c08dd26d0a22d87580b4d00009f592e0619d823953577d4503061706843317e4fee083db41054657374204b65792033202844534129886204131102002205024d6c49de021b03060b090807030206150802090a0b0416020301021e01021780000a0910338934250ccc03607e0400a0bdb9193e8a6b96fc2dfc108ae848914b504481f100a09c4dc148cb693293a67af24dd40d2b13a9e36794\"\n+\n+const armoredPrivateKeyBlock = `-----BEGIN PGP PRIVATE KEY BLOCK-----\n+Version: GnuPG v1.4.10 (GNU/Linux)\n+\n+lQHYBE2rFNoBBADFwqWQIW/DSqcB4yCQqnAFTJ27qS5AnB46ccAdw3u4Greeu3Bp\n+idpoHdjULy7zSKlwR1EA873dO/k/e11Ml3dlAFUinWeejWaK2ugFP6JjiieSsrKn\n+vWNicdCS4HTWn0X4sjl0ZiAygw6GNhqEQ3cpLeL0g8E9hnYzJKQ0LWJa0QARAQAB\n+AAP/TB81EIo2VYNmTq0pK1ZXwUpxCrvAAIG3hwKjEzHcbQznsjNvPUihZ+NZQ6+X\n+0HCfPAdPkGDCLCb6NavcSW+iNnLTrdDnSI6+3BbIONqWWdRDYJhqZCkqmG6zqSfL\n+IdkJgCw94taUg5BWP/AAeQrhzjChvpMQTVKQL5mnuZbUCeMCAN5qrYMP2S9iKdnk\n+VANIFj7656ARKt/nf4CBzxcpHTyB8+d2CtPDKCmlJP6vL8t58Jmih+kHJMvC0dzn\n+gr5f5+sCAOOe5gt9e0am7AvQWhdbHVfJU0TQJx+m2OiCJAqGTB1nvtBLHdJnfdC9\n+TnXXQ6ZXibqLyBies/xeY2sCKL5qtTMCAKnX9+9d/5yQxRyrQUHt1NYhaXZnJbHx\n+q4ytu0eWz+5i68IYUSK69jJ1NWPM0T6SkqpB3KCAIv68VFm9PxqG1KmhSrQIVGVz\n+dCBLZXmIuAQTAQIAIgUCTasU2gIbAwYLCQgHAwIGFQgCCQoLBBYCAwECHgECF4AA\n+CgkQO9o98PRieSoLhgQAkLEZex02Qt7vGhZzMwuN0R22w3VwyYyjBx+fM3JFETy1\n+ut4xcLJoJfIaF5ZS38UplgakHG0FQ+b49i8dMij0aZmDqGxrew1m4kBfjXw9B/v+\n+eIqpODryb6cOSwyQFH0lQkXC040pjq9YqDsO5w0WYNXYKDnzRV0p4H1pweo2VDid\n+AdgETasU2gEEAN46UPeWRqKHvA99arOxee38fBt2CI08iiWyI8T3J6ivtFGixSqV\n+bRcPxYO/qLpVe5l84Nb3X71GfVXlc9hyv7CD6tcowL59hg1E/DC5ydI8K8iEpUmK\n+/UnHdIY5h8/kqgGxkY/T/hgp5fRQgW1ZoZxLajVlMRZ8W4tFtT0DeA+JABEBAAEA\n+A/0bE1jaaZKj6ndqcw86jd+QtD1SF+Cf21CWRNeLKnUds4FRRvclzTyUMuWPkUeX\n+TaNNsUOFqBsf6QQ2oHUBBK4VCHffHCW4ZEX2cd6umz7mpHW6XzN4DECEzOVksXtc\n+lUC1j4UB91DC/RNQqwX1IV2QLSwssVotPMPqhOi0ZLNY7wIA3n7DWKInxYZZ4K+6\n+rQ+POsz6brEoRHwr8x6XlHenq1Oki855pSa1yXIARoTrSJkBtn5oI+f8AzrnN0BN\n+oyeQAwIA/7E++3HDi5aweWrViiul9cd3rcsS0dEnksPhvS0ozCJiHsq/6GFmy7J8\n+QSHZPteedBnZyNp5jR+H7cIfVN3KgwH/Skq4PsuPhDq5TKK6i8Pc1WW8MA6DXTdU\n+nLkX7RGmMwjC0DBf7KWAlPjFaONAX3a8ndnz//fy1q7u2l9AZwrj1qa1iJ8EGAEC\n+AAkFAk2rFNoCGwwACgkQO9o98PRieSo2/QP/WTzr4ioINVsvN1akKuekmEMI3LAp\n+BfHwatufxxP1U+3Si/6YIk7kuPB9Hs+pRqCXzbvPRrI8NHZBmc8qIGthishdCYad\n+AHcVnXjtxrULkQFGbGvhKURLvS9WnzD/m1K2zzwxzkPTzT9/Yf06O6Mal5AdugPL\n+VrM0m72/jnpKo04=\n+=zNCn\n+-----END PGP PRIVATE KEY BLOCK-----`"}, {"sha": "93b7582fa06a5feb033ee5ca630102c64147ddf3", "filename": "libgo/go/crypto/openpgp/s2k/s2k.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fs2k%2Fs2k.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fs2k%2Fs2k.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fs2k%2Fs2k.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This package implements the various OpenPGP string-to-key transforms as\n+// Package s2k implements the various OpenPGP string-to-key transforms as\n // specified in RFC 4800 section 3.7.1.\n package s2k\n "}, {"sha": "7ee471093b4f485fa6c9bc5dfd58b2eeee4449e6", "filename": "libgo/go/crypto/rc4/rc4.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This package implements RC4 encryption, as defined in Bruce Schneier's\n+// Package rc4 implements RC4 encryption, as defined in Bruce Schneier's\n // Applied Cryptography.\n package rc4\n "}, {"sha": "5aaca59a3cfc10f86ef6de700cd6ed6d12540fc4", "filename": "libgo/go/crypto/ripemd160/ripemd160.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fripemd160%2Fripemd160.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fripemd160%2Fripemd160.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fripemd160%2Fripemd160.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This package implements the RIPEMD-160 hash algorithm.\n+// Package ripemd160 implements the RIPEMD-160 hash algorithm.\n package ripemd160\n \n // RIPEMD-160 is designed by by Hans Dobbertin, Antoon Bosselaers, and Bart"}, {"sha": "3defa62ea6d36263846482808dcb1997b93e049a", "filename": "libgo/go/crypto/rsa/pkcs1v15.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -149,10 +149,10 @@ func nonZeroRandomBytes(s []byte, rand io.Reader) (err os.Error) {\n // precompute a prefix of the digest value that makes a valid ASN1 DER string\n // with the correct contents.\n var hashPrefixes = map[crypto.Hash][]byte{\n-\tcrypto.MD5:       []byte{0x30, 0x20, 0x30, 0x0c, 0x06, 0x08, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x02, 0x05, 0x05, 0x00, 0x04, 0x10},\n-\tcrypto.SHA1:      []byte{0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0e, 0x03, 0x02, 0x1a, 0x05, 0x00, 0x04, 0x14},\n-\tcrypto.SHA256:    []byte{0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20},\n-\tcrypto.SHA384:    []byte{0x30, 0x41, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x02, 0x05, 0x00, 0x04, 0x30},\n+\tcrypto.MD5:       {0x30, 0x20, 0x30, 0x0c, 0x06, 0x08, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x02, 0x05, 0x05, 0x00, 0x04, 0x10},\n+\tcrypto.SHA1:      {0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0e, 0x03, 0x02, 0x1a, 0x05, 0x00, 0x04, 0x14},\n+\tcrypto.SHA256:    {0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20},\n+\tcrypto.SHA384:    {0x30, 0x41, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x02, 0x05, 0x00, 0x04, 0x30},\n \tcrypto.SHA512:    {0x30, 0x51, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03, 0x05, 0x00, 0x04, 0x40},\n \tcrypto.MD5SHA1:   {}, // A special TLS case which doesn't use an ASN1 prefix.\n \tcrypto.RIPEMD160: {0x30, 0x20, 0x30, 0x08, 0x06, 0x06, 0x28, 0xcf, 0x06, 0x03, 0x00, 0x31, 0x04, 0x14},"}, {"sha": "d69bacfd68506933afdc7eb3fa2488891cb849d0", "filename": "libgo/go/crypto/rsa/pkcs1v15_test.go", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -197,12 +197,6 @@ func TestVerifyPKCS1v15(t *testing.T) {\n \t}\n }\n \n-func bigFromString(s string) *big.Int {\n-\tret := new(big.Int)\n-\tret.SetString(s, 10)\n-\treturn ret\n-}\n-\n // In order to generate new test vectors you'll need the PEM form of this key:\n // -----BEGIN RSA PRIVATE KEY-----\n // MIIBOgIBAAJBALKZD0nEffqM1ACuak0bijtqE2QrI/KLADv7l3kK3ppMyCuLKoF0\n@@ -216,10 +210,12 @@ func bigFromString(s string) *big.Int {\n \n var rsaPrivateKey = &PrivateKey{\n \tPublicKey: PublicKey{\n-\t\tN: bigFromString(\"9353930466774385905609975137998169297361893554149986716853295022578535724979677252958524466350471210367835187480748268864277464700638583474144061408845077\"),\n+\t\tN: fromBase10(\"9353930466774385905609975137998169297361893554149986716853295022578535724979677252958524466350471210367835187480748268864277464700638583474144061408845077\"),\n \t\tE: 65537,\n \t},\n-\tD: bigFromString(\"7266398431328116344057699379749222532279343923819063639497049039389899328538543087657733766554155839834519529439851673014800261285757759040931985506583861\"),\n-\tP: bigFromString(\"98920366548084643601728869055592650835572950932266967461790948584315647051443\"),\n-\tQ: bigFromString(\"94560208308847015747498523884063394671606671904944666360068158221458669711639\"),\n+\tD: fromBase10(\"7266398431328116344057699379749222532279343923819063639497049039389899328538543087657733766554155839834519529439851673014800261285757759040931985506583861\"),\n+\tPrimes: []*big.Int{\n+\t\tfromBase10(\"98920366548084643601728869055592650835572950932266967461790948584315647051443\"),\n+\t\tfromBase10(\"94560208308847015747498523884063394671606671904944666360068158221458669711639\"),\n+\t},\n }"}, {"sha": "e1813dbf938f9fb7d26b9467c1f5a6e98bab2b6e", "filename": "libgo/go/crypto/rsa/rsa.go", "status": "modified", "additions": 126, "deletions": 164, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This package implements RSA encryption as specified in PKCS#1.\n+// Package rsa implements RSA encryption as specified in PKCS#1.\n package rsa\n \n // TODO(agl): Add support for PSS padding.\n@@ -13,7 +13,6 @@ import (\n \t\"hash\"\n \t\"io\"\n \t\"os\"\n-\t\"sync\"\n )\n \n var bigZero = big.NewInt(0)\n@@ -90,50 +89,60 @@ type PublicKey struct {\n \n // A PrivateKey represents an RSA key\n type PrivateKey struct {\n-\tPublicKey          // public part.\n-\tD         *big.Int // private exponent\n-\tP, Q, R   *big.Int // prime factors of N (R may be nil)\n-\n-\trwMutex    sync.RWMutex // protects the following\n-\tdP, dQ, dR *big.Int     // D mod (P-1) (or mod Q-1 etc) \n-\tqInv       *big.Int     // q^-1 mod p\n-\tpq         *big.Int     // P*Q\n-\ttr         *big.Int     // pq\u00b7tr \u2261 1 mod r\n+\tPublicKey            // public part.\n+\tD         *big.Int   // private exponent\n+\tPrimes    []*big.Int // prime factors of N, has >= 2 elements.\n+\n+\t// Precomputed contains precomputed values that speed up private\n+\t// operations, if availible.\n+\tPrecomputed PrecomputedValues\n+}\n+\n+type PrecomputedValues struct {\n+\tDp, Dq *big.Int // D mod (P-1) (or mod Q-1) \n+\tQinv   *big.Int // Q^-1 mod Q\n+\n+\t// CRTValues is used for the 3rd and subsequent primes. Due to a\n+\t// historical accident, the CRT for the first two primes is handled\n+\t// differently in PKCS#1 and interoperability is sufficiently\n+\t// important that we mirror this.\n+\tCRTValues []CRTValue\n+}\n+\n+// CRTValue contains the precomputed chinese remainder theorem values.\n+type CRTValue struct {\n+\tExp   *big.Int // D mod (prime-1).\n+\tCoeff *big.Int // R\u00b7Coeff \u2261 1 mod Prime.\n+\tR     *big.Int // product of primes prior to this (inc p and q).\n }\n \n // Validate performs basic sanity checks on the key.\n // It returns nil if the key is valid, or else an os.Error describing a problem.\n \n func (priv *PrivateKey) Validate() os.Error {\n-\t// Check that p, q and, maybe, r are prime. Note that this is just a\n-\t// sanity check. Since the random witnesses chosen by ProbablyPrime are\n-\t// deterministic, given the candidate number, it's easy for an attack\n-\t// to generate composites that pass this test.\n-\tif !big.ProbablyPrime(priv.P, 20) {\n-\t\treturn os.ErrorString(\"P is composite\")\n-\t}\n-\tif !big.ProbablyPrime(priv.Q, 20) {\n-\t\treturn os.ErrorString(\"Q is composite\")\n-\t}\n-\tif priv.R != nil && !big.ProbablyPrime(priv.R, 20) {\n-\t\treturn os.ErrorString(\"R is composite\")\n+\t// Check that the prime factors are actually prime. Note that this is\n+\t// just a sanity check. Since the random witnesses chosen by\n+\t// ProbablyPrime are deterministic, given the candidate number, it's\n+\t// easy for an attack to generate composites that pass this test.\n+\tfor _, prime := range priv.Primes {\n+\t\tif !big.ProbablyPrime(prime, 20) {\n+\t\t\treturn os.ErrorString(\"Prime factor is composite\")\n+\t\t}\n \t}\n \n-\t// Check that p*q*r == n.\n-\tmodulus := new(big.Int).Mul(priv.P, priv.Q)\n-\tif priv.R != nil {\n-\t\tmodulus.Mul(modulus, priv.R)\n+\t// Check that \u03a0primes == n.\n+\tmodulus := new(big.Int).Set(bigOne)\n+\tfor _, prime := range priv.Primes {\n+\t\tmodulus.Mul(modulus, prime)\n \t}\n \tif modulus.Cmp(priv.N) != 0 {\n \t\treturn os.ErrorString(\"invalid modulus\")\n \t}\n-\t// Check that e and totient(p, q, r) are coprime.\n-\tpminus1 := new(big.Int).Sub(priv.P, bigOne)\n-\tqminus1 := new(big.Int).Sub(priv.Q, bigOne)\n-\ttotient := new(big.Int).Mul(pminus1, qminus1)\n-\tif priv.R != nil {\n-\t\trminus1 := new(big.Int).Sub(priv.R, bigOne)\n-\t\ttotient.Mul(totient, rminus1)\n+\t// Check that e and totient(\u03a0primes) are coprime.\n+\ttotient := new(big.Int).Set(bigOne)\n+\tfor _, prime := range priv.Primes {\n+\t\tpminus1 := new(big.Int).Sub(prime, bigOne)\n+\t\ttotient.Mul(totient, pminus1)\n \t}\n \te := big.NewInt(int64(priv.E))\n \tgcd := new(big.Int)\n@@ -143,7 +152,7 @@ func (priv *PrivateKey) Validate() os.Error {\n \tif gcd.Cmp(bigOne) != 0 {\n \t\treturn os.ErrorString(\"invalid public exponent E\")\n \t}\n-\t// Check that de \u2261 1 (mod totient(p, q, r))\n+\t// Check that de \u2261 1 (mod totient(\u03a0primes))\n \tde := new(big.Int).Mul(priv.D, e)\n \tde.Mod(de, totient)\n \tif de.Cmp(bigOne) != 0 {\n@@ -154,6 +163,20 @@ func (priv *PrivateKey) Validate() os.Error {\n \n // GenerateKey generates an RSA keypair of the given bit size.\n func GenerateKey(rand io.Reader, bits int) (priv *PrivateKey, err os.Error) {\n+\treturn GenerateMultiPrimeKey(rand, 2, bits)\n+}\n+\n+// GenerateMultiPrimeKey generates a multi-prime RSA keypair of the given bit\n+// size, as suggested in [1]. Although the public keys are compatible\n+// (actually, indistinguishable) from the 2-prime case, the private keys are\n+// not. Thus it may not be possible to export multi-prime private keys in\n+// certain formats or to subsequently import them into other code.\n+//\n+// Table 1 in [2] suggests maximum numbers of primes for a given size.\n+//\n+// [1] US patent 4405829 (1972, expired)\n+// [2] http://www.cacr.math.uwaterloo.ca/techreports/2006/cacr2006-16.pdf\n+func GenerateMultiPrimeKey(rand io.Reader, nprimes int, bits int) (priv *PrivateKey, err os.Error) {\n \tpriv = new(PrivateKey)\n \t// Smaller public exponents lead to faster public key\n \t// operations. Since the exponent must be coprime to\n@@ -165,100 +188,41 @@ func GenerateKey(rand io.Reader, bits int) (priv *PrivateKey, err os.Error) {\n \t// [1] http://marc.info/?l=cryptography&m=115694833312008&w=2\n \tpriv.E = 3\n \n-\tpminus1 := new(big.Int)\n-\tqminus1 := new(big.Int)\n-\ttotient := new(big.Int)\n-\n-\tfor {\n-\t\tp, err := randomPrime(rand, bits/2)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\n-\t\tq, err := randomPrime(rand, bits/2)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\n-\t\tif p.Cmp(q) == 0 {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tn := new(big.Int).Mul(p, q)\n-\t\tpminus1.Sub(p, bigOne)\n-\t\tqminus1.Sub(q, bigOne)\n-\t\ttotient.Mul(pminus1, qminus1)\n-\n-\t\tg := new(big.Int)\n-\t\tpriv.D = new(big.Int)\n-\t\ty := new(big.Int)\n-\t\te := big.NewInt(int64(priv.E))\n-\t\tbig.GcdInt(g, priv.D, y, e, totient)\n-\n-\t\tif g.Cmp(bigOne) == 0 {\n-\t\t\tpriv.D.Add(priv.D, totient)\n-\t\t\tpriv.P = p\n-\t\t\tpriv.Q = q\n-\t\t\tpriv.N = n\n-\n-\t\t\tbreak\n-\t\t}\n+\tif nprimes < 2 {\n+\t\treturn nil, os.ErrorString(\"rsa.GenerateMultiPrimeKey: nprimes must be >= 2\")\n \t}\n \n-\treturn\n-}\n-\n-// Generate3PrimeKey generates a 3-prime RSA keypair of the given bit size, as\n-// suggested in [1]. Although the public keys are compatible (actually,\n-// indistinguishable) from the 2-prime case, the private keys are not. Thus it\n-// may not be possible to export 3-prime private keys in certain formats or to\n-// subsequently import them into other code.\n-//\n-// Table 1 in [2] suggests that size should be >= 1024 when using 3 primes.\n-//\n-// [1] US patent 4405829 (1972, expired)\n-// [2] http://www.cacr.math.uwaterloo.ca/techreports/2006/cacr2006-16.pdf\n-func Generate3PrimeKey(rand io.Reader, bits int) (priv *PrivateKey, err os.Error) {\n-\tpriv = new(PrivateKey)\n-\tpriv.E = 3\n-\n-\tpminus1 := new(big.Int)\n-\tqminus1 := new(big.Int)\n-\trminus1 := new(big.Int)\n-\ttotient := new(big.Int)\n+\tprimes := make([]*big.Int, nprimes)\n \n+NextSetOfPrimes:\n \tfor {\n-\t\tp, err := randomPrime(rand, bits/3)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\n-\t\ttodo := bits - p.BitLen()\n-\t\tq, err := randomPrime(rand, todo/2)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n+\t\ttodo := bits\n+\t\tfor i := 0; i < nprimes; i++ {\n+\t\t\tprimes[i], err = randomPrime(rand, todo/(nprimes-i))\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\ttodo -= primes[i].BitLen()\n \t\t}\n \n-\t\ttodo -= q.BitLen()\n-\t\tr, err := randomPrime(rand, todo)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n+\t\t// Make sure that primes is pairwise unequal.\n+\t\tfor i, prime := range primes {\n+\t\t\tfor j := 0; j < i; j++ {\n+\t\t\t\tif prime.Cmp(primes[j]) == 0 {\n+\t\t\t\t\tcontinue NextSetOfPrimes\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n \n-\t\tif p.Cmp(q) == 0 ||\n-\t\t\tq.Cmp(r) == 0 ||\n-\t\t\tr.Cmp(p) == 0 {\n-\t\t\tcontinue\n+\t\tn := new(big.Int).Set(bigOne)\n+\t\ttotient := new(big.Int).Set(bigOne)\n+\t\tpminus1 := new(big.Int)\n+\t\tfor _, prime := range primes {\n+\t\t\tn.Mul(n, prime)\n+\t\t\tpminus1.Sub(prime, bigOne)\n+\t\t\ttotient.Mul(totient, pminus1)\n \t\t}\n \n-\t\tn := new(big.Int).Mul(p, q)\n-\t\tn.Mul(n, r)\n-\t\tpminus1.Sub(p, bigOne)\n-\t\tqminus1.Sub(q, bigOne)\n-\t\trminus1.Sub(r, bigOne)\n-\t\ttotient.Mul(pminus1, qminus1)\n-\t\ttotient.Mul(totient, rminus1)\n-\n \t\tg := new(big.Int)\n \t\tpriv.D = new(big.Int)\n \t\ty := new(big.Int)\n@@ -267,15 +231,14 @@ func Generate3PrimeKey(rand io.Reader, bits int) (priv *PrivateKey, err os.Error\n \n \t\tif g.Cmp(bigOne) == 0 {\n \t\t\tpriv.D.Add(priv.D, totient)\n-\t\t\tpriv.P = p\n-\t\t\tpriv.Q = q\n-\t\t\tpriv.R = r\n+\t\t\tpriv.Primes = primes\n \t\t\tpriv.N = n\n \n \t\t\tbreak\n \t\t}\n \t}\n \n+\tpriv.Precompute()\n \treturn\n }\n \n@@ -409,23 +372,34 @@ func modInverse(a, n *big.Int) (ia *big.Int, ok bool) {\n \treturn x, true\n }\n \n-// precompute performs some calculations that speed up private key operations\n+// Precompute performs some calculations that speed up private key operations\n // in the future.\n-func (priv *PrivateKey) precompute() {\n-\tpriv.dP = new(big.Int).Sub(priv.P, bigOne)\n-\tpriv.dP.Mod(priv.D, priv.dP)\n+func (priv *PrivateKey) Precompute() {\n+\tif priv.Precomputed.Dp != nil {\n+\t\treturn\n+\t}\n \n-\tpriv.dQ = new(big.Int).Sub(priv.Q, bigOne)\n-\tpriv.dQ.Mod(priv.D, priv.dQ)\n+\tpriv.Precomputed.Dp = new(big.Int).Sub(priv.Primes[0], bigOne)\n+\tpriv.Precomputed.Dp.Mod(priv.D, priv.Precomputed.Dp)\n \n-\tpriv.qInv = new(big.Int).ModInverse(priv.Q, priv.P)\n+\tpriv.Precomputed.Dq = new(big.Int).Sub(priv.Primes[1], bigOne)\n+\tpriv.Precomputed.Dq.Mod(priv.D, priv.Precomputed.Dq)\n \n-\tif priv.R != nil {\n-\t\tpriv.dR = new(big.Int).Sub(priv.R, bigOne)\n-\t\tpriv.dR.Mod(priv.D, priv.dR)\n+\tpriv.Precomputed.Qinv = new(big.Int).ModInverse(priv.Primes[1], priv.Primes[0])\n \n-\t\tpriv.pq = new(big.Int).Mul(priv.P, priv.Q)\n-\t\tpriv.tr = new(big.Int).ModInverse(priv.pq, priv.R)\n+\tr := new(big.Int).Mul(priv.Primes[0], priv.Primes[1])\n+\tpriv.Precomputed.CRTValues = make([]CRTValue, len(priv.Primes)-2)\n+\tfor i := 2; i < len(priv.Primes); i++ {\n+\t\tprime := priv.Primes[i]\n+\t\tvalues := &priv.Precomputed.CRTValues[i-2]\n+\n+\t\tvalues.Exp = new(big.Int).Sub(prime, bigOne)\n+\t\tvalues.Exp.Mod(priv.D, values.Exp)\n+\n+\t\tvalues.R = new(big.Int).Set(r)\n+\t\tvalues.Coeff = new(big.Int).ModInverse(r, prime)\n+\n+\t\tr.Mul(r, prime)\n \t}\n }\n \n@@ -463,53 +437,41 @@ func decrypt(rand io.Reader, priv *PrivateKey, c *big.Int) (m *big.Int, err os.E\n \t\t}\n \t\tbigE := big.NewInt(int64(priv.E))\n \t\trpowe := new(big.Int).Exp(r, bigE, priv.N)\n-\t\tc.Mul(c, rpowe)\n-\t\tc.Mod(c, priv.N)\n-\t}\n-\n-\tpriv.rwMutex.RLock()\n-\n-\tif priv.dP == nil && priv.P != nil {\n-\t\tpriv.rwMutex.RUnlock()\n-\t\tpriv.rwMutex.Lock()\n-\t\tif priv.dP == nil && priv.P != nil {\n-\t\t\tpriv.precompute()\n-\t\t}\n-\t\tpriv.rwMutex.Unlock()\n-\t\tpriv.rwMutex.RLock()\n+\t\tcCopy := new(big.Int).Set(c)\n+\t\tcCopy.Mul(cCopy, rpowe)\n+\t\tcCopy.Mod(cCopy, priv.N)\n+\t\tc = cCopy\n \t}\n \n-\tif priv.dP == nil {\n+\tif priv.Precomputed.Dp == nil {\n \t\tm = new(big.Int).Exp(c, priv.D, priv.N)\n \t} else {\n \t\t// We have the precalculated values needed for the CRT.\n-\t\tm = new(big.Int).Exp(c, priv.dP, priv.P)\n-\t\tm2 := new(big.Int).Exp(c, priv.dQ, priv.Q)\n+\t\tm = new(big.Int).Exp(c, priv.Precomputed.Dp, priv.Primes[0])\n+\t\tm2 := new(big.Int).Exp(c, priv.Precomputed.Dq, priv.Primes[1])\n \t\tm.Sub(m, m2)\n \t\tif m.Sign() < 0 {\n-\t\t\tm.Add(m, priv.P)\n+\t\t\tm.Add(m, priv.Primes[0])\n \t\t}\n-\t\tm.Mul(m, priv.qInv)\n-\t\tm.Mod(m, priv.P)\n-\t\tm.Mul(m, priv.Q)\n+\t\tm.Mul(m, priv.Precomputed.Qinv)\n+\t\tm.Mod(m, priv.Primes[0])\n+\t\tm.Mul(m, priv.Primes[1])\n \t\tm.Add(m, m2)\n \n-\t\tif priv.dR != nil {\n-\t\t\t// 3-prime CRT.\n-\t\t\tm2.Exp(c, priv.dR, priv.R)\n+\t\tfor i, values := range priv.Precomputed.CRTValues {\n+\t\t\tprime := priv.Primes[2+i]\n+\t\t\tm2.Exp(c, values.Exp, prime)\n \t\t\tm2.Sub(m2, m)\n-\t\t\tm2.Mul(m2, priv.tr)\n-\t\t\tm2.Mod(m2, priv.R)\n+\t\t\tm2.Mul(m2, values.Coeff)\n+\t\t\tm2.Mod(m2, prime)\n \t\t\tif m2.Sign() < 0 {\n-\t\t\t\tm2.Add(m2, priv.R)\n+\t\t\t\tm2.Add(m2, prime)\n \t\t\t}\n-\t\t\tm2.Mul(m2, priv.pq)\n+\t\t\tm2.Mul(m2, values.R)\n \t\t\tm.Add(m, m2)\n \t\t}\n \t}\n \n-\tpriv.rwMutex.RUnlock()\n-\n \tif ir != nil {\n \t\t// Unblind.\n \t\tm.Mul(m, ir)"}, {"sha": "c36bca1cd371d11f0a166bcd97c48bb19c6487a8", "filename": "libgo/go/crypto/rsa/rsa_test.go", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -30,7 +30,20 @@ func Test3PrimeKeyGeneration(t *testing.T) {\n \t}\n \n \tsize := 768\n-\tpriv, err := Generate3PrimeKey(rand.Reader, size)\n+\tpriv, err := GenerateMultiPrimeKey(rand.Reader, 3, size)\n+\tif err != nil {\n+\t\tt.Errorf(\"failed to generate key\")\n+\t}\n+\ttestKeyBasics(t, priv)\n+}\n+\n+func Test4PrimeKeyGeneration(t *testing.T) {\n+\tif testing.Short() {\n+\t\treturn\n+\t}\n+\n+\tsize := 768\n+\tpriv, err := GenerateMultiPrimeKey(rand.Reader, 4, size)\n \tif err != nil {\n \t\tt.Errorf(\"failed to generate key\")\n \t}\n@@ -45,6 +58,7 @@ func testKeyBasics(t *testing.T, priv *PrivateKey) {\n \tpub := &priv.PublicKey\n \tm := big.NewInt(42)\n \tc := encrypt(new(big.Int), pub, m)\n+\n \tm2, err := decrypt(nil, priv, c)\n \tif err != nil {\n \t\tt.Errorf(\"error while decrypting: %s\", err)\n@@ -59,7 +73,7 @@ func testKeyBasics(t *testing.T, priv *PrivateKey) {\n \t\tt.Errorf(\"error while decrypting (blind): %s\", err)\n \t}\n \tif m.Cmp(m3) != 0 {\n-\t\tt.Errorf(\"(blind) got:%v, want:%v\", m3, m)\n+\t\tt.Errorf(\"(blind) got:%v, want:%v (%#v)\", m3, m, priv)\n \t}\n }\n \n@@ -77,10 +91,12 @@ func BenchmarkRSA2048Decrypt(b *testing.B) {\n \t\t\tE: 3,\n \t\t},\n \t\tD: fromBase10(\"9542755287494004433998723259516013739278699355114572217325597900889416163458809501304132487555642811888150937392013824621448709836142886006653296025093941418628992648429798282127303704957273845127141852309016655778568546006839666463451542076964744073572349705538631742281931858219480985907271975884773482372966847639853897890615456605598071088189838676728836833012254065983259638538107719766738032720239892094196108713378822882383694456030043492571063441943847195939549773271694647657549658603365629458610273821292232646334717612674519997533901052790334279661754176490593041941863932308687197618671528035670452762731\"),\n-\t\tP: fromBase10(\"130903255182996722426771613606077755295583329135067340152947172868415809027537376306193179624298874215608270802054347609836776473930072411958753044562214537013874103802006369634761074377213995983876788718033850153719421695468704276694983032644416930879093914927146648402139231293035971427838068945045019075433\"),\n-\t\tQ: fromBase10(\"109348945610485453577574767652527472924289229538286649661240938988020367005475727988253438647560958573506159449538793540472829815903949343191091817779240101054552748665267574271163617694640513549693841337820602726596756351006149518830932261246698766355347898158548465400674856021497190430791824869615170301029\"),\n+\t\tPrimes: []*big.Int{\n+\t\t\tfromBase10(\"130903255182996722426771613606077755295583329135067340152947172868415809027537376306193179624298874215608270802054347609836776473930072411958753044562214537013874103802006369634761074377213995983876788718033850153719421695468704276694983032644416930879093914927146648402139231293035971427838068945045019075433\"),\n+\t\t\tfromBase10(\"109348945610485453577574767652527472924289229538286649661240938988020367005475727988253438647560958573506159449538793540472829815903949343191091817779240101054552748665267574271163617694640513549693841337820602726596756351006149518830932261246698766355347898158548465400674856021497190430791824869615170301029\"),\n+\t\t},\n \t}\n-\tpriv.precompute()\n+\tpriv.Precompute()\n \n \tc := fromBase10(\"1000\")\n \n@@ -99,11 +115,13 @@ func Benchmark3PrimeRSA2048Decrypt(b *testing.B) {\n \t\t\tE: 3,\n \t\t},\n \t\tD: fromBase10(\"10897585948254795600358846499957366070880176878341177571733155050184921896034527397712889205732614568234385175145686545381899460748279607074689061600935843283397424506622998458510302603922766336783617368686090042765718290914099334449154829375179958369993407724946186243249568928237086215759259909861748642124071874879861299389874230489928271621259294894142840428407196932444474088857746123104978617098858619445675532587787023228852383149557470077802718705420275739737958953794088728369933811184572620857678792001136676902250566845618813972833750098806496641114644760255910789397593428910198080271317419213080834885003\"),\n-\t\tP: fromBase10(\"1025363189502892836833747188838978207017355117492483312747347695538428729137306368764177201532277413433182799108299960196606011786562992097313508180436744488171474690412562218914213688661311117337381958560443\"),\n-\t\tQ: fromBase10(\"3467903426626310123395340254094941045497208049900750380025518552334536945536837294961497712862519984786362199788654739924501424784631315081391467293694361474867825728031147665777546570788493758372218019373\"),\n-\t\tR: fromBase10(\"4597024781409332673052708605078359346966325141767460991205742124888960305710298765592730135879076084498363772408626791576005136245060321874472727132746643162385746062759369754202494417496879741537284589047\"),\n+\t\tPrimes: []*big.Int{\n+\t\t\tfromBase10(\"1025363189502892836833747188838978207017355117492483312747347695538428729137306368764177201532277413433182799108299960196606011786562992097313508180436744488171474690412562218914213688661311117337381958560443\"),\n+\t\t\tfromBase10(\"3467903426626310123395340254094941045497208049900750380025518552334536945536837294961497712862519984786362199788654739924501424784631315081391467293694361474867825728031147665777546570788493758372218019373\"),\n+\t\t\tfromBase10(\"4597024781409332673052708605078359346966325141767460991205742124888960305710298765592730135879076084498363772408626791576005136245060321874472727132746643162385746062759369754202494417496879741537284589047\"),\n+\t\t},\n \t}\n-\tpriv.precompute()\n+\tpriv.Precompute()\n \n \tc := fromBase10(\"1000\")\n "}, {"sha": "788d1ff5552d77e003c0d27c52955d23d8c6b5d6", "filename": "libgo/go/crypto/sha1/sha1.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This package implements the SHA1 hash algorithm as defined in RFC 3174.\n+// Package sha1 implements the SHA1 hash algorithm as defined in RFC 3174.\n package sha1\n \n import ("}, {"sha": "a2c058d180e8e665fad431c70e872ad57f8a1083", "filename": "libgo/go/crypto/sha256/sha256.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,7 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This package implements the SHA224 and SHA256 hash algorithms as defined in FIPS 180-2.\n+// Package sha256 implements the SHA224 and SHA256 hash algorithms as defined\n+// in FIPS 180-2.\n package sha256\n \n import ("}, {"sha": "78f5fe26f80762f82877156dc9d5a65dfd5b2ae5", "filename": "libgo/go/crypto/sha512/sha512.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,7 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This package implements the SHA384 and SHA512 hash algorithms as defined in FIPS 180-2.\n+// Package sha512 implements the SHA384 and SHA512 hash algorithms as defined\n+// in FIPS 180-2.\n package sha512\n \n import ("}, {"sha": "57dbe9db555af592883d27e31b5f0bd46c8e7375", "filename": "libgo/go/crypto/subtle/constant_time.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fsubtle%2Fconstant_time.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fsubtle%2Fconstant_time.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsubtle%2Fconstant_time.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This package implements functions that are often useful in cryptographic\n+// Package subtle implements functions that are often useful in cryptographic\n // code but require careful thought to use correctly.\n package subtle\n "}, {"sha": "ae00ac5586831549343fe18bff967a9767a9f7b5", "filename": "libgo/go/crypto/tls/ca_set.go", "status": "removed", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37cb25ed7acdb844b218231130e54b8b7a0ff6e6/libgo%2Fgo%2Fcrypto%2Ftls%2Fca_set.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37cb25ed7acdb844b218231130e54b8b7a0ff6e6/libgo%2Fgo%2Fcrypto%2Ftls%2Fca_set.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fca_set.go?ref=37cb25ed7acdb844b218231130e54b8b7a0ff6e6", "patch": "@@ -1,89 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package tls\n-\n-import (\n-\t\"crypto/x509\"\n-\t\"encoding/pem\"\n-\t\"strings\"\n-)\n-\n-// A CASet is a set of certificates.\n-type CASet struct {\n-\tbySubjectKeyId map[string][]*x509.Certificate\n-\tbyName         map[string][]*x509.Certificate\n-}\n-\n-// NewCASet returns a new, empty CASet.\n-func NewCASet() *CASet {\n-\treturn &CASet{\n-\t\tmake(map[string][]*x509.Certificate),\n-\t\tmake(map[string][]*x509.Certificate),\n-\t}\n-}\n-\n-func nameToKey(name *x509.Name) string {\n-\treturn strings.Join(name.Country, \",\") + \"/\" + strings.Join(name.Organization, \",\") + \"/\" + strings.Join(name.OrganizationalUnit, \",\") + \"/\" + name.CommonName\n-}\n-\n-// FindVerifiedParent attempts to find the certificate in s which has signed\n-// the given certificate. If no such certificate can be found or the signature\n-// doesn't match, it returns nil.\n-func (s *CASet) FindVerifiedParent(cert *x509.Certificate) (parent *x509.Certificate) {\n-\tvar candidates []*x509.Certificate\n-\n-\tif len(cert.AuthorityKeyId) > 0 {\n-\t\tcandidates = s.bySubjectKeyId[string(cert.AuthorityKeyId)]\n-\t}\n-\tif len(candidates) == 0 {\n-\t\tcandidates = s.byName[nameToKey(&cert.Issuer)]\n-\t}\n-\n-\tfor _, c := range candidates {\n-\t\tif cert.CheckSignatureFrom(c) == nil {\n-\t\t\treturn c\n-\t\t}\n-\t}\n-\n-\treturn nil\n-}\n-\n-// AddCert adds a certificate to the set\n-func (s *CASet) AddCert(cert *x509.Certificate) {\n-\tif len(cert.SubjectKeyId) > 0 {\n-\t\tkeyId := string(cert.SubjectKeyId)\n-\t\ts.bySubjectKeyId[keyId] = append(s.bySubjectKeyId[keyId], cert)\n-\t}\n-\tname := nameToKey(&cert.Subject)\n-\ts.byName[name] = append(s.byName[name], cert)\n-}\n-\n-// SetFromPEM attempts to parse a series of PEM encoded root certificates. It\n-// appends any certificates found to s and returns true if any certificates\n-// were successfully parsed. On many Linux systems, /etc/ssl/cert.pem will\n-// contains the system wide set of root CAs in a format suitable for this\n-// function.\n-func (s *CASet) SetFromPEM(pemCerts []byte) (ok bool) {\n-\tfor len(pemCerts) > 0 {\n-\t\tvar block *pem.Block\n-\t\tblock, pemCerts = pem.Decode(pemCerts)\n-\t\tif block == nil {\n-\t\t\tbreak\n-\t\t}\n-\t\tif block.Type != \"CERTIFICATE\" || len(block.Headers) != 0 {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tcert, err := x509.ParseCertificate(block.Bytes)\n-\t\tif err != nil {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\ts.AddCert(cert)\n-\t\tok = true\n-\t}\n-\n-\treturn\n-}"}, {"sha": "0b26aae84d1429da4b7a8670a2bc69e572be053e", "filename": "libgo/go/crypto/tls/common.go", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -100,6 +100,8 @@ type ConnectionState struct {\n \n \t// the certificate chain that was presented by the other side\n \tPeerCertificates []*x509.Certificate\n+\t// the verified certificate chains built from PeerCertificates.\n+\tVerifiedChains [][]*x509.Certificate\n }\n \n // A Config structure is used to configure a TLS client or server. After one\n@@ -122,7 +124,7 @@ type Config struct {\n \t// RootCAs defines the set of root certificate authorities\n \t// that clients use when verifying server certificates.\n \t// If RootCAs is nil, TLS uses the host's root CA set.\n-\tRootCAs *CASet\n+\tRootCAs *x509.CertPool\n \n \t// NextProtos is a list of supported, application level protocols.\n \tNextProtos []string\n@@ -158,7 +160,7 @@ func (c *Config) time() int64 {\n \treturn t()\n }\n \n-func (c *Config) rootCAs() *CASet {\n+func (c *Config) rootCAs() *x509.CertPool {\n \ts := c.RootCAs\n \tif s == nil {\n \t\ts = defaultRoots()\n@@ -178,6 +180,9 @@ func (c *Config) cipherSuites() []uint16 {\n type Certificate struct {\n \tCertificate [][]byte\n \tPrivateKey  *rsa.PrivateKey\n+\t// OCSPStaple contains an optional OCSP response which will be served\n+\t// to clients that request it.\n+\tOCSPStaple []byte\n }\n \n // A TLS record.\n@@ -221,7 +226,7 @@ var certFiles = []string{\n \n var once sync.Once\n \n-func defaultRoots() *CASet {\n+func defaultRoots() *x509.CertPool {\n \tonce.Do(initDefaults)\n \treturn varDefaultRoots\n }\n@@ -236,14 +241,14 @@ func initDefaults() {\n \tinitDefaultCipherSuites()\n }\n \n-var varDefaultRoots *CASet\n+var varDefaultRoots *x509.CertPool\n \n func initDefaultRoots() {\n-\troots := NewCASet()\n+\troots := x509.NewCertPool()\n \tfor _, file := range certFiles {\n \t\tdata, err := ioutil.ReadFile(file)\n \t\tif err == nil {\n-\t\t\troots.SetFromPEM(data)\n+\t\t\troots.AppendCertsFromPEM(data)\n \t\t\tbreak\n \t\t}\n \t}\n@@ -255,7 +260,7 @@ var varDefaultCipherSuites []uint16\n func initDefaultCipherSuites() {\n \tvarDefaultCipherSuites = make([]uint16, len(cipherSuites))\n \ti := 0\n-\tfor id, _ := range cipherSuites {\n+\tfor id := range cipherSuites {\n \t\tvarDefaultCipherSuites[i] = id\n \t\ti++\n \t}"}, {"sha": "48d3f725b49c62179ac42761dc5c13b51259776c", "filename": "libgo/go/crypto/tls/conn.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -34,6 +34,9 @@ type Conn struct {\n \tcipherSuite       uint16\n \tocspResponse      []byte // stapled OCSP response\n \tpeerCertificates  []*x509.Certificate\n+\t// verifedChains contains the certificate chains that we built, as\n+\t// opposed to the ones presented by the server.\n+\tverifiedChains [][]*x509.Certificate\n \n \tclientProtocol         string\n \tclientProtocolFallback bool\n@@ -765,6 +768,7 @@ func (c *Conn) ConnectionState() ConnectionState {\n \t\tstate.NegotiatedProtocolIsMutual = !c.clientProtocolFallback\n \t\tstate.CipherSuite = c.cipherSuite\n \t\tstate.PeerCertificates = c.peerCertificates\n+\t\tstate.VerifiedChains = c.verifiedChains\n \t}\n \n \treturn state"}, {"sha": "c758c96d4ef7a4b8cb05198c985bee2ac1fbb391", "filename": "libgo/go/crypto/tls/handshake_client.go", "status": "modified", "additions": 15, "deletions": 34, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -88,55 +88,36 @@ func (c *Conn) clientHandshake() os.Error {\n \tfinishedHash.Write(certMsg.marshal())\n \n \tcerts := make([]*x509.Certificate, len(certMsg.certificates))\n-\tchain := NewCASet()\n \tfor i, asn1Data := range certMsg.certificates {\n \t\tcert, err := x509.ParseCertificate(asn1Data)\n \t\tif err != nil {\n \t\t\tc.sendAlert(alertBadCertificate)\n \t\t\treturn os.ErrorString(\"failed to parse certificate from server: \" + err.String())\n \t\t}\n \t\tcerts[i] = cert\n-\t\tchain.AddCert(cert)\n \t}\n \n \t// If we don't have a root CA set configured then anything is accepted.\n \t// TODO(rsc): Find certificates for OS X 10.6.\n-\tfor cur := certs[0]; c.config.RootCAs != nil; {\n-\t\tparent := c.config.RootCAs.FindVerifiedParent(cur)\n-\t\tif parent != nil {\n-\t\t\tbreak\n+\tif c.config.RootCAs != nil {\n+\t\topts := x509.VerifyOptions{\n+\t\t\tRoots:         c.config.RootCAs,\n+\t\t\tCurrentTime:   c.config.time(),\n+\t\t\tDNSName:       c.config.ServerName,\n+\t\t\tIntermediates: x509.NewCertPool(),\n \t\t}\n \n-\t\tparent = chain.FindVerifiedParent(cur)\n-\t\tif parent == nil {\n-\t\t\tc.sendAlert(alertBadCertificate)\n-\t\t\treturn os.ErrorString(\"could not find root certificate for chain\")\n+\t\tfor i, cert := range certs {\n+\t\t\tif i == 0 {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\topts.Intermediates.AddCert(cert)\n \t\t}\n-\n-\t\tif !parent.BasicConstraintsValid || !parent.IsCA {\n+\t\tc.verifiedChains, err = certs[0].Verify(opts)\n+\t\tif err != nil {\n \t\t\tc.sendAlert(alertBadCertificate)\n-\t\t\treturn os.ErrorString(\"intermediate certificate does not have CA bit set\")\n+\t\t\treturn err\n \t\t}\n-\t\t// KeyUsage status flags are ignored. From Engineering\n-\t\t// Security, Peter Gutmann: A European government CA marked its\n-\t\t// signing certificates as being valid for encryption only, but\n-\t\t// no-one noticed. Another European CA marked its signature\n-\t\t// keys as not being valid for signatures. A different CA\n-\t\t// marked its own trusted root certificate as being invalid for\n-\t\t// certificate signing.  Another national CA distributed a\n-\t\t// certificate to be used to encrypt data for the country\u2019s tax\n-\t\t// authority that was marked as only being usable for digital\n-\t\t// signatures but not for encryption. Yet another CA reversed\n-\t\t// the order of the bit flags in the keyUsage due to confusion\n-\t\t// over encoding endianness, essentially setting a random\n-\t\t// keyUsage in certificates that it issued. Another CA created\n-\t\t// a self-invalidating certificate by adding a certificate\n-\t\t// policy statement stipulating that the certificate had to be\n-\t\t// used strictly as specified in the keyUsage, and a keyUsage\n-\t\t// containing a flag indicating that the RSA encryption key\n-\t\t// could only be used for Diffie-Hellman key agreement.\n-\n-\t\tcur = parent\n \t}\n \n \tif _, ok := certs[0].PublicKey.(*rsa.PublicKey); !ok {\n@@ -145,7 +126,7 @@ func (c *Conn) clientHandshake() os.Error {\n \n \tc.peerCertificates = certs\n \n-\tif serverHello.certStatus {\n+\tif serverHello.ocspStapling {\n \t\tmsg, err = c.readHandshake()\n \t\tif err != nil {\n \t\t\treturn err"}, {"sha": "6645adce4f21258213952f60db835e2cbb30a1c4", "filename": "libgo/go/crypto/tls/handshake_messages.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -306,7 +306,7 @@ type serverHelloMsg struct {\n \tcompressionMethod uint8\n \tnextProtoNeg      bool\n \tnextProtos        []string\n-\tcertStatus        bool\n+\tocspStapling      bool\n }\n \n func (m *serverHelloMsg) marshal() []byte {\n@@ -327,7 +327,7 @@ func (m *serverHelloMsg) marshal() []byte {\n \t\tnextProtoLen += len(m.nextProtos)\n \t\textensionsLength += nextProtoLen\n \t}\n-\tif m.certStatus {\n+\tif m.ocspStapling {\n \t\tnumExtensions++\n \t}\n \tif numExtensions > 0 {\n@@ -373,7 +373,7 @@ func (m *serverHelloMsg) marshal() []byte {\n \t\t\tz = z[1+l:]\n \t\t}\n \t}\n-\tif m.certStatus {\n+\tif m.ocspStapling {\n \t\tz[0] = byte(extensionStatusRequest >> 8)\n \t\tz[1] = byte(extensionStatusRequest)\n \t\tz = z[4:]\n@@ -406,7 +406,7 @@ func (m *serverHelloMsg) unmarshal(data []byte) bool {\n \n \tm.nextProtoNeg = false\n \tm.nextProtos = nil\n-\tm.certStatus = false\n+\tm.ocspStapling = false\n \n \tif len(data) == 0 {\n \t\t// ServerHello is optionally followed by extension data\n@@ -450,7 +450,7 @@ func (m *serverHelloMsg) unmarshal(data []byte) bool {\n \t\t\tif length > 0 {\n \t\t\t\treturn false\n \t\t\t}\n-\t\t\tm.certStatus = true\n+\t\t\tm.ocspStapling = true\n \t\t}\n \t\tdata = data[length:]\n \t}"}, {"sha": "23f729dd94bdfd866f8689e98caf930e1effe3ed", "filename": "libgo/go/crypto/tls/handshake_messages_test.go", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -32,7 +32,7 @@ type testMessage interface {\n func TestMarshalUnmarshal(t *testing.T) {\n \trand := rand.New(rand.NewSource(0))\n \tfor i, iface := range tests {\n-\t\tty := reflect.NewValue(iface).Type()\n+\t\tty := reflect.ValueOf(iface).Type()\n \n \t\tn := 100\n \t\tif testing.Short() {\n@@ -121,11 +121,11 @@ func (*clientHelloMsg) Generate(rand *rand.Rand, size int) reflect.Value {\n \tm.ocspStapling = rand.Intn(10) > 5\n \tm.supportedPoints = randomBytes(rand.Intn(5)+1, rand)\n \tm.supportedCurves = make([]uint16, rand.Intn(5)+1)\n-\tfor i, _ := range m.supportedCurves {\n+\tfor i := range m.supportedCurves {\n \t\tm.supportedCurves[i] = uint16(rand.Intn(30000))\n \t}\n \n-\treturn reflect.NewValue(m)\n+\treturn reflect.ValueOf(m)\n }\n \n func (*serverHelloMsg) Generate(rand *rand.Rand, size int) reflect.Value {\n@@ -146,7 +146,7 @@ func (*serverHelloMsg) Generate(rand *rand.Rand, size int) reflect.Value {\n \t\t}\n \t}\n \n-\treturn reflect.NewValue(m)\n+\treturn reflect.ValueOf(m)\n }\n \n func (*certificateMsg) Generate(rand *rand.Rand, size int) reflect.Value {\n@@ -156,7 +156,7 @@ func (*certificateMsg) Generate(rand *rand.Rand, size int) reflect.Value {\n \tfor i := 0; i < numCerts; i++ {\n \t\tm.certificates[i] = randomBytes(rand.Intn(10)+1, rand)\n \t}\n-\treturn reflect.NewValue(m)\n+\treturn reflect.ValueOf(m)\n }\n \n func (*certificateRequestMsg) Generate(rand *rand.Rand, size int) reflect.Value {\n@@ -167,13 +167,13 @@ func (*certificateRequestMsg) Generate(rand *rand.Rand, size int) reflect.Value\n \tfor i := 0; i < numCAs; i++ {\n \t\tm.certificateAuthorities[i] = randomBytes(rand.Intn(15)+1, rand)\n \t}\n-\treturn reflect.NewValue(m)\n+\treturn reflect.ValueOf(m)\n }\n \n func (*certificateVerifyMsg) Generate(rand *rand.Rand, size int) reflect.Value {\n \tm := &certificateVerifyMsg{}\n \tm.signature = randomBytes(rand.Intn(15)+1, rand)\n-\treturn reflect.NewValue(m)\n+\treturn reflect.ValueOf(m)\n }\n \n func (*certificateStatusMsg) Generate(rand *rand.Rand, size int) reflect.Value {\n@@ -184,23 +184,23 @@ func (*certificateStatusMsg) Generate(rand *rand.Rand, size int) reflect.Value {\n \t} else {\n \t\tm.statusType = 42\n \t}\n-\treturn reflect.NewValue(m)\n+\treturn reflect.ValueOf(m)\n }\n \n func (*clientKeyExchangeMsg) Generate(rand *rand.Rand, size int) reflect.Value {\n \tm := &clientKeyExchangeMsg{}\n \tm.ciphertext = randomBytes(rand.Intn(1000)+1, rand)\n-\treturn reflect.NewValue(m)\n+\treturn reflect.ValueOf(m)\n }\n \n func (*finishedMsg) Generate(rand *rand.Rand, size int) reflect.Value {\n \tm := &finishedMsg{}\n \tm.verifyData = randomBytes(12, rand)\n-\treturn reflect.NewValue(m)\n+\treturn reflect.ValueOf(m)\n }\n \n func (*nextProtoMsg) Generate(rand *rand.Rand, size int) reflect.Value {\n \tm := &nextProtoMsg{}\n \tm.proto = randomString(rand.Intn(255), rand)\n-\treturn reflect.NewValue(m)\n+\treturn reflect.ValueOf(m)\n }"}, {"sha": "37c8d154ac4dc47955308bf0ad41d91ab2e8b4e2", "filename": "libgo/go/crypto/tls/handshake_server.go", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -103,6 +103,9 @@ FindCipherSuite:\n \t\thello.nextProtoNeg = true\n \t\thello.nextProtos = config.NextProtos\n \t}\n+\tif clientHello.ocspStapling && len(config.Certificates[0].OCSPStaple) > 0 {\n+\t\thello.ocspStapling = true\n+\t}\n \n \tfinishedHash.Write(hello.marshal())\n \tc.writeRecord(recordTypeHandshake, hello.marshal())\n@@ -116,6 +119,14 @@ FindCipherSuite:\n \tfinishedHash.Write(certMsg.marshal())\n \tc.writeRecord(recordTypeHandshake, certMsg.marshal())\n \n+\tif hello.ocspStapling {\n+\t\tcertStatus := new(certificateStatusMsg)\n+\t\tcertStatus.statusType = statusTypeOCSP\n+\t\tcertStatus.response = config.Certificates[0].OCSPStaple\n+\t\tfinishedHash.Write(certStatus.marshal())\n+\t\tc.writeRecord(recordTypeHandshake, certStatus.marshal())\n+\t}\n+\n \tkeyAgreement := suite.ka()\n \n \tskx, err := keyAgreement.generateServerKeyExchange(config, clientHello, hello)"}, {"sha": "5a1e754dcf57df0b819b02fdc7656f28d64d40d3", "filename": "libgo/go/crypto/tls/handshake_server_test.go", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -188,8 +188,10 @@ var testPrivateKey = &rsa.PrivateKey{\n \t\tE: 65537,\n \t},\n \tD: bigFromString(\"29354450337804273969007277378287027274721892607543397931919078829901848876371746653677097639302788129485893852488285045793268732234230875671682624082413996177431586734171663258657462237320300610850244186316880055243099640544518318093544057213190320837094958164973959123058337475052510833916491060913053867729\"),\n-\tP: bigFromString(\"11969277782311800166562047708379380720136961987713178380670422671426759650127150688426177829077494755200794297055316163155755835813760102405344560929062149\"),\n-\tQ: bigFromString(\"10998999429884441391899182616418192492905073053684657075974935218461686523870125521822756579792315215543092255516093840728890783887287417039645833477273829\"),\n+\tPrimes: []*big.Int{\n+\t\tbigFromString(\"11969277782311800166562047708379380720136961987713178380670422671426759650127150688426177829077494755200794297055316163155755835813760102405344560929062149\"),\n+\t\tbigFromString(\"10998999429884441391899182616418192492905073053684657075974935218461686523870125521822756579792315215543092255516093840728890783887287417039645833477273829\"),\n+\t},\n }\n \n // Script of interaction with gnutls implementation."}, {"sha": "7d0bb9f34b86555d2974b0a3ea7a309ba6cc2f45", "filename": "libgo/go/crypto/tls/tls.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,7 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This package partially implements the TLS 1.1 protocol, as specified in RFC 4346.\n+// Package tls partially implements the TLS 1.1 protocol, as specified in RFC\n+// 4346.\n package tls\n \n import ("}, {"sha": "9303f03ffd8bc68b1633bb1e4517c5c09594eac4", "filename": "libgo/go/crypto/twofish/twofish.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Ftwofish%2Ftwofish.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Ftwofish%2Ftwofish.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftwofish%2Ftwofish.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This package implements Bruce Schneier's Twofish encryption algorithm.\n+// Package twofish implements Bruce Schneier's Twofish encryption algorithm.\n package twofish\n \n // Twofish is defined in http://www.schneier.com/paper-twofish-paper.pdf [TWOFISH]"}, {"sha": "c295fd97e8d4311e6f6ee4596e12c52cf55d161e", "filename": "libgo/go/crypto/x509/cert_pool.go", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fx509%2Fcert_pool.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fx509%2Fcert_pool.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fcert_pool.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -0,0 +1,105 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package x509\n+\n+import (\n+\t\"encoding/pem\"\n+\t\"strings\"\n+)\n+\n+// Roots is a set of certificates.\n+type CertPool struct {\n+\tbySubjectKeyId map[string][]int\n+\tbyName         map[string][]int\n+\tcerts          []*Certificate\n+}\n+\n+// NewCertPool returns a new, empty CertPool.\n+func NewCertPool() *CertPool {\n+\treturn &CertPool{\n+\t\tmake(map[string][]int),\n+\t\tmake(map[string][]int),\n+\t\tnil,\n+\t}\n+}\n+\n+func nameToKey(name *Name) string {\n+\treturn strings.Join(name.Country, \",\") + \"/\" + strings.Join(name.Organization, \",\") + \"/\" + strings.Join(name.OrganizationalUnit, \",\") + \"/\" + name.CommonName\n+}\n+\n+// findVerifiedParents attempts to find certificates in s which have signed the\n+// given certificate. If no such certificate can be found or the signature\n+// doesn't match, it returns nil.\n+func (s *CertPool) findVerifiedParents(cert *Certificate) (parents []int) {\n+\tvar candidates []int\n+\n+\tif len(cert.AuthorityKeyId) > 0 {\n+\t\tcandidates = s.bySubjectKeyId[string(cert.AuthorityKeyId)]\n+\t}\n+\tif len(candidates) == 0 {\n+\t\tcandidates = s.byName[nameToKey(&cert.Issuer)]\n+\t}\n+\n+\tfor _, c := range candidates {\n+\t\tif cert.CheckSignatureFrom(s.certs[c]) == nil {\n+\t\t\tparents = append(parents, c)\n+\t\t}\n+\t}\n+\n+\treturn\n+}\n+\n+// AddCert adds a certificate to a pool.\n+func (s *CertPool) AddCert(cert *Certificate) {\n+\tif cert == nil {\n+\t\tpanic(\"adding nil Certificate to CertPool\")\n+\t}\n+\n+\t// Check that the certificate isn't being added twice.\n+\tfor _, c := range s.certs {\n+\t\tif c.Equal(cert) {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n+\tn := len(s.certs)\n+\ts.certs = append(s.certs, cert)\n+\n+\tif len(cert.SubjectKeyId) > 0 {\n+\t\tkeyId := string(cert.SubjectKeyId)\n+\t\ts.bySubjectKeyId[keyId] = append(s.bySubjectKeyId[keyId], n)\n+\t}\n+\tname := nameToKey(&cert.Subject)\n+\ts.byName[name] = append(s.byName[name], n)\n+}\n+\n+// AppendCertsFromPEM attempts to parse a series of PEM encoded root\n+// certificates. It appends any certificates found to s and returns true if any\n+// certificates were successfully parsed.\n+//\n+// On many Linux systems, /etc/ssl/cert.pem will contains the system wide set\n+// of root CAs in a format suitable for this function.\n+func (s *CertPool) AppendCertsFromPEM(pemCerts []byte) (ok bool) {\n+\tfor len(pemCerts) > 0 {\n+\t\tvar block *pem.Block\n+\t\tblock, pemCerts = pem.Decode(pemCerts)\n+\t\tif block == nil {\n+\t\t\tbreak\n+\t\t}\n+\t\tif block.Type != \"CERTIFICATE\" || len(block.Headers) != 0 {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tcert, err := ParseCertificate(block.Bytes)\n+\t\tif err != nil {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\ts.AddCert(cert)\n+\t\tok = true\n+\t}\n+\n+\treturn\n+}"}, {"sha": "9145880a2370f8d3f9f34deed2262c9e39ae9610", "filename": "libgo/go/crypto/x509/verify.go", "status": "added", "additions": 239, "deletions": 0, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -0,0 +1,239 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package x509\n+\n+import (\n+\t\"os\"\n+\t\"strings\"\n+\t\"time\"\n+)\n+\n+type InvalidReason int\n+\n+const (\n+\t// NotAuthorizedToSign results when a certificate is signed by another\n+\t// which isn't marked as a CA certificate.\n+\tNotAuthorizedToSign InvalidReason = iota\n+\t// Expired results when a certificate has expired, based on the time\n+\t// given in the VerifyOptions.\n+\tExpired\n+\t// CANotAuthorizedForThisName results when an intermediate or root\n+\t// certificate has a name constraint which doesn't include the name\n+\t// being checked.\n+\tCANotAuthorizedForThisName\n+)\n+\n+// CertificateInvalidError results when an odd error occurs. Users of this\n+// library probably want to handle all these errors uniformly.\n+type CertificateInvalidError struct {\n+\tCert   *Certificate\n+\tReason InvalidReason\n+}\n+\n+func (e CertificateInvalidError) String() string {\n+\tswitch e.Reason {\n+\tcase NotAuthorizedToSign:\n+\t\treturn \"x509: certificate is not authorized to sign other other certificates\"\n+\tcase Expired:\n+\t\treturn \"x509: certificate has expired or is not yet valid\"\n+\tcase CANotAuthorizedForThisName:\n+\t\treturn \"x509: a root or intermediate certificate is not authorized to sign in this domain\"\n+\t}\n+\treturn \"x509: unknown error\"\n+}\n+\n+// HostnameError results when the set of authorized names doesn't match the\n+// requested name.\n+type HostnameError struct {\n+\tCertificate *Certificate\n+\tHost        string\n+}\n+\n+func (h HostnameError) String() string {\n+\tvar valid string\n+\tc := h.Certificate\n+\tif len(c.DNSNames) > 0 {\n+\t\tvalid = strings.Join(c.DNSNames, \", \")\n+\t} else {\n+\t\tvalid = c.Subject.CommonName\n+\t}\n+\treturn \"certificate is valid for \" + valid + \", not \" + h.Host\n+}\n+\n+\n+// UnknownAuthorityError results when the certificate issuer is unknown\n+type UnknownAuthorityError struct {\n+\tcert *Certificate\n+}\n+\n+func (e UnknownAuthorityError) String() string {\n+\treturn \"x509: certificate signed by unknown authority\"\n+}\n+\n+// VerifyOptions contains parameters for Certificate.Verify. It's a structure\n+// because other PKIX verification APIs have ended up needing many options.\n+type VerifyOptions struct {\n+\tDNSName       string\n+\tIntermediates *CertPool\n+\tRoots         *CertPool\n+\tCurrentTime   int64 // if 0, the current system time is used.\n+}\n+\n+const (\n+\tleafCertificate = iota\n+\tintermediateCertificate\n+\trootCertificate\n+)\n+\n+// isValid performs validity checks on the c.\n+func (c *Certificate) isValid(certType int, opts *VerifyOptions) os.Error {\n+\tif opts.CurrentTime < c.NotBefore.Seconds() ||\n+\t\topts.CurrentTime > c.NotAfter.Seconds() {\n+\t\treturn CertificateInvalidError{c, Expired}\n+\t}\n+\n+\tif len(c.PermittedDNSDomains) > 0 {\n+\t\tfor _, domain := range c.PermittedDNSDomains {\n+\t\t\tif opts.DNSName == domain ||\n+\t\t\t\t(strings.HasSuffix(opts.DNSName, domain) &&\n+\t\t\t\t\tlen(opts.DNSName) >= 1+len(domain) &&\n+\t\t\t\t\topts.DNSName[len(opts.DNSName)-len(domain)-1] == '.') {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\treturn CertificateInvalidError{c, CANotAuthorizedForThisName}\n+\t\t}\n+\t}\n+\n+\t// KeyUsage status flags are ignored. From Engineering Security, Peter\n+\t// Gutmann: A European government CA marked its signing certificates as\n+\t// being valid for encryption only, but no-one noticed. Another\n+\t// European CA marked its signature keys as not being valid for\n+\t// signatures. A different CA marked its own trusted root certificate\n+\t// as being invalid for certificate signing.  Another national CA\n+\t// distributed a certificate to be used to encrypt data for the\n+\t// country\u2019s tax authority that was marked as only being usable for\n+\t// digital signatures but not for encryption. Yet another CA reversed\n+\t// the order of the bit flags in the keyUsage due to confusion over\n+\t// encoding endianness, essentially setting a random keyUsage in\n+\t// certificates that it issued. Another CA created a self-invalidating\n+\t// certificate by adding a certificate policy statement stipulating\n+\t// that the certificate had to be used strictly as specified in the\n+\t// keyUsage, and a keyUsage containing a flag indicating that the RSA\n+\t// encryption key could only be used for Diffie-Hellman key agreement.\n+\n+\tif certType == intermediateCertificate && (!c.BasicConstraintsValid || !c.IsCA) {\n+\t\treturn CertificateInvalidError{c, NotAuthorizedToSign}\n+\t}\n+\n+\treturn nil\n+}\n+\n+// Verify attempts to verify c by building one or more chains from c to a\n+// certificate in opts.roots, using certificates in opts.Intermediates if\n+// needed. If successful, it returns one or chains where the first element of\n+// the chain is c and the last element is from opts.Roots.\n+//\n+// WARNING: this doesn't do any revocation checking.\n+func (c *Certificate) Verify(opts VerifyOptions) (chains [][]*Certificate, err os.Error) {\n+\tif opts.CurrentTime == 0 {\n+\t\topts.CurrentTime = time.Seconds()\n+\t}\n+\terr = c.isValid(leafCertificate, &opts)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tif len(opts.DNSName) > 0 {\n+\t\terr = c.VerifyHostname(opts.DNSName)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\treturn c.buildChains(make(map[int][][]*Certificate), []*Certificate{c}, &opts)\n+}\n+\n+func appendToFreshChain(chain []*Certificate, cert *Certificate) []*Certificate {\n+\tn := make([]*Certificate, len(chain)+1)\n+\tcopy(n, chain)\n+\tn[len(chain)] = cert\n+\treturn n\n+}\n+\n+func (c *Certificate) buildChains(cache map[int][][]*Certificate, currentChain []*Certificate, opts *VerifyOptions) (chains [][]*Certificate, err os.Error) {\n+\tfor _, rootNum := range opts.Roots.findVerifiedParents(c) {\n+\t\troot := opts.Roots.certs[rootNum]\n+\t\terr = root.isValid(rootCertificate, opts)\n+\t\tif err != nil {\n+\t\t\tcontinue\n+\t\t}\n+\t\tchains = append(chains, appendToFreshChain(currentChain, root))\n+\t}\n+\n+\tfor _, intermediateNum := range opts.Intermediates.findVerifiedParents(c) {\n+\t\tintermediate := opts.Intermediates.certs[intermediateNum]\n+\t\terr = intermediate.isValid(intermediateCertificate, opts)\n+\t\tif err != nil {\n+\t\t\tcontinue\n+\t\t}\n+\t\tvar childChains [][]*Certificate\n+\t\tchildChains, ok := cache[intermediateNum]\n+\t\tif !ok {\n+\t\t\tchildChains, err = intermediate.buildChains(cache, appendToFreshChain(currentChain, intermediate), opts)\n+\t\t\tcache[intermediateNum] = childChains\n+\t\t}\n+\t\tchains = append(chains, childChains...)\n+\t}\n+\n+\tif len(chains) > 0 {\n+\t\terr = nil\n+\t}\n+\n+\tif len(chains) == 0 && err == nil {\n+\t\terr = UnknownAuthorityError{c}\n+\t}\n+\n+\treturn\n+}\n+\n+func matchHostnames(pattern, host string) bool {\n+\tif len(pattern) == 0 || len(host) == 0 {\n+\t\treturn false\n+\t}\n+\n+\tpatternParts := strings.Split(pattern, \".\", -1)\n+\thostParts := strings.Split(host, \".\", -1)\n+\n+\tif len(patternParts) != len(hostParts) {\n+\t\treturn false\n+\t}\n+\n+\tfor i, patternPart := range patternParts {\n+\t\tif patternPart == \"*\" {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif patternPart != hostParts[i] {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\n+\treturn true\n+}\n+\n+// VerifyHostname returns nil if c is a valid certificate for the named host.\n+// Otherwise it returns an os.Error describing the mismatch.\n+func (c *Certificate) VerifyHostname(h string) os.Error {\n+\tif len(c.DNSNames) > 0 {\n+\t\tfor _, match := range c.DNSNames {\n+\t\t\tif matchHostnames(match, h) {\n+\t\t\t\treturn nil\n+\t\t\t}\n+\t\t}\n+\t\t// If Subject Alt Name is given, we ignore the common name.\n+\t} else if matchHostnames(c.Subject.CommonName, h) {\n+\t\treturn nil\n+\t}\n+\n+\treturn HostnameError{c, h}\n+}"}, {"sha": "6a103dcfba7da6d60bb47cb7230e0140b6add73e", "filename": "libgo/go/crypto/x509/verify_test.go", "status": "added", "additions": 390, "deletions": 0, "changes": 390, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -0,0 +1,390 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package x509\n+\n+import (\n+\t\"encoding/pem\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"testing\"\n+)\n+\n+type verifyTest struct {\n+\tleaf          string\n+\tintermediates []string\n+\troots         []string\n+\tcurrentTime   int64\n+\tdnsName       string\n+\n+\terrorCallback  func(*testing.T, int, os.Error) bool\n+\texpectedChains [][]string\n+}\n+\n+var verifyTests = []verifyTest{\n+\t{\n+\t\tleaf:          googleLeaf,\n+\t\tintermediates: []string{thawteIntermediate},\n+\t\troots:         []string{verisignRoot},\n+\t\tcurrentTime:   1302726541,\n+\t\tdnsName:       \"www.google.com\",\n+\n+\t\texpectedChains: [][]string{\n+\t\t\t[]string{\"Google\", \"Thawte\", \"VeriSign\"},\n+\t\t},\n+\t},\n+\t{\n+\t\tleaf:          googleLeaf,\n+\t\tintermediates: []string{thawteIntermediate},\n+\t\troots:         []string{verisignRoot},\n+\t\tcurrentTime:   1302726541,\n+\t\tdnsName:       \"www.example.com\",\n+\n+\t\terrorCallback: expectHostnameError,\n+\t},\n+\t{\n+\t\tleaf:          googleLeaf,\n+\t\tintermediates: []string{thawteIntermediate},\n+\t\troots:         []string{verisignRoot},\n+\t\tcurrentTime:   1,\n+\t\tdnsName:       \"www.example.com\",\n+\n+\t\terrorCallback: expectExpired,\n+\t},\n+\t{\n+\t\tleaf:        googleLeaf,\n+\t\troots:       []string{verisignRoot},\n+\t\tcurrentTime: 1302726541,\n+\t\tdnsName:     \"www.google.com\",\n+\n+\t\terrorCallback: expectAuthorityUnknown,\n+\t},\n+\t{\n+\t\tleaf:          googleLeaf,\n+\t\tintermediates: []string{verisignRoot, thawteIntermediate},\n+\t\troots:         []string{verisignRoot},\n+\t\tcurrentTime:   1302726541,\n+\t\tdnsName:       \"www.google.com\",\n+\n+\t\texpectedChains: [][]string{\n+\t\t\t[]string{\"Google\", \"Thawte\", \"VeriSign\"},\n+\t\t},\n+\t},\n+\t{\n+\t\tleaf:          googleLeaf,\n+\t\tintermediates: []string{verisignRoot, thawteIntermediate},\n+\t\troots:         []string{verisignRoot},\n+\t\tcurrentTime:   1302726541,\n+\n+\t\texpectedChains: [][]string{\n+\t\t\t[]string{\"Google\", \"Thawte\", \"VeriSign\"},\n+\t\t},\n+\t},\n+\t{\n+\t\tleaf:          dnssecExpLeaf,\n+\t\tintermediates: []string{startComIntermediate},\n+\t\troots:         []string{startComRoot},\n+\t\tcurrentTime:   1302726541,\n+\n+\t\texpectedChains: [][]string{\n+\t\t\t[]string{\"dnssec-exp\", \"StartCom Class 1\", \"StartCom Certification Authority\"},\n+\t\t},\n+\t},\n+}\n+\n+func expectHostnameError(t *testing.T, i int, err os.Error) (ok bool) {\n+\tif _, ok := err.(HostnameError); !ok {\n+\t\tt.Errorf(\"#%d: error was not a HostnameError: %s\", i, err)\n+\t\treturn false\n+\t}\n+\treturn true\n+}\n+\n+func expectExpired(t *testing.T, i int, err os.Error) (ok bool) {\n+\tif inval, ok := err.(CertificateInvalidError); !ok || inval.Reason != Expired {\n+\t\tt.Errorf(\"#%d: error was not Expired: %s\", i, err)\n+\t\treturn false\n+\t}\n+\treturn true\n+}\n+\n+func expectAuthorityUnknown(t *testing.T, i int, err os.Error) (ok bool) {\n+\tif _, ok := err.(UnknownAuthorityError); !ok {\n+\t\tt.Errorf(\"#%d: error was not UnknownAuthorityError: %s\", i, err)\n+\t\treturn false\n+\t}\n+\treturn true\n+}\n+\n+func certificateFromPEM(pemBytes string) (*Certificate, os.Error) {\n+\tblock, _ := pem.Decode([]byte(pemBytes))\n+\tif block == nil {\n+\t\treturn nil, os.ErrorString(\"failed to decode PEM\")\n+\t}\n+\treturn ParseCertificate(block.Bytes)\n+}\n+\n+func TestVerify(t *testing.T) {\n+\tfor i, test := range verifyTests {\n+\t\topts := VerifyOptions{\n+\t\t\tRoots:         NewCertPool(),\n+\t\t\tIntermediates: NewCertPool(),\n+\t\t\tDNSName:       test.dnsName,\n+\t\t\tCurrentTime:   test.currentTime,\n+\t\t}\n+\n+\t\tfor j, root := range test.roots {\n+\t\t\tok := opts.Roots.AppendCertsFromPEM([]byte(root))\n+\t\t\tif !ok {\n+\t\t\t\tt.Errorf(\"#%d: failed to parse root #%d\", i, j)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\n+\t\tfor j, intermediate := range test.intermediates {\n+\t\t\tok := opts.Intermediates.AppendCertsFromPEM([]byte(intermediate))\n+\t\t\tif !ok {\n+\t\t\t\tt.Errorf(\"#%d: failed to parse intermediate #%d\", i, j)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\n+\t\tleaf, err := certificateFromPEM(test.leaf)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"#%d: failed to parse leaf: %s\", i, err)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tchains, err := leaf.Verify(opts)\n+\n+\t\tif test.errorCallback == nil && err != nil {\n+\t\t\tt.Errorf(\"#%d: unexpected error: %s\", i, err)\n+\t\t}\n+\t\tif test.errorCallback != nil {\n+\t\t\tif !test.errorCallback(t, i, err) {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\n+\t\tif len(chains) != len(test.expectedChains) {\n+\t\t\tt.Errorf(\"#%d: wanted %d chains, got %d\", i, len(test.expectedChains), len(chains))\n+\t\t}\n+\n+\t\t// We check that each returned chain matches a chain from\n+\t\t// expectedChains but an entry in expectedChains can't match\n+\t\t// two chains.\n+\t\tseenChains := make([]bool, len(chains))\n+\tNextOutputChain:\n+\t\tfor _, chain := range chains {\n+\t\tTryNextExpected:\n+\t\t\tfor j, expectedChain := range test.expectedChains {\n+\t\t\t\tif seenChains[j] {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tif len(chain) != len(expectedChain) {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tfor k, cert := range chain {\n+\t\t\t\t\tif strings.Index(nameToKey(&cert.Subject), expectedChain[k]) == -1 {\n+\t\t\t\t\t\tcontinue TryNextExpected\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\t// we matched\n+\t\t\t\tseenChains[j] = true\n+\t\t\t\tcontinue NextOutputChain\n+\t\t\t}\n+\t\t\tt.Errorf(\"#%d: No expected chain matched %s\", i, chainToDebugString(chain))\n+\t\t}\n+\t}\n+}\n+\n+func chainToDebugString(chain []*Certificate) string {\n+\tvar chainStr string\n+\tfor _, cert := range chain {\n+\t\tif len(chainStr) > 0 {\n+\t\t\tchainStr += \" -> \"\n+\t\t}\n+\t\tchainStr += nameToKey(&cert.Subject)\n+\t}\n+\treturn chainStr\n+}\n+\n+const verisignRoot = `-----BEGIN CERTIFICATE-----\n+MIICPDCCAaUCEHC65B0Q2Sk0tjjKewPMur8wDQYJKoZIhvcNAQECBQAwXzELMAkG\n+A1UEBhMCVVMxFzAVBgNVBAoTDlZlcmlTaWduLCBJbmMuMTcwNQYDVQQLEy5DbGFz\n+cyAzIFB1YmxpYyBQcmltYXJ5IENlcnRpZmljYXRpb24gQXV0aG9yaXR5MB4XDTk2\n+MDEyOTAwMDAwMFoXDTI4MDgwMTIzNTk1OVowXzELMAkGA1UEBhMCVVMxFzAVBgNV\n+BAoTDlZlcmlTaWduLCBJbmMuMTcwNQYDVQQLEy5DbGFzcyAzIFB1YmxpYyBQcmlt\n+YXJ5IENlcnRpZmljYXRpb24gQXV0aG9yaXR5MIGfMA0GCSqGSIb3DQEBAQUAA4GN\n+ADCBiQKBgQDJXFme8huKARS0EN8EQNvjV69qRUCPhAwL0TPZ2RHP7gJYHyX3KqhE\n+BarsAx94f56TuZoAqiN91qyFomNFx3InzPRMxnVx0jnvT0Lwdd8KkMaOIG+YD/is\n+I19wKTakyYbnsZogy1Olhec9vn2a/iRFM9x2Fe0PonFkTGUugWhFpwIDAQABMA0G\n+CSqGSIb3DQEBAgUAA4GBALtMEivPLCYATxQT3ab7/AoRhIzzKBxnki98tsX63/Do\n+lbwdj2wsqFHMc9ikwFPwTtYmwHYBV4GSXiHx0bH/59AhWM1pF+NEHJwZRDmJXNyc\n+AA9WjQKZ7aKQRUzkuxCkPfAyAw7xzvjoyVGM5mKf5p/AfbdynMk2OmufTqj/ZA1k\n+-----END CERTIFICATE-----\n+`\n+\n+const thawteIntermediate = `-----BEGIN CERTIFICATE-----\n+MIIDIzCCAoygAwIBAgIEMAAAAjANBgkqhkiG9w0BAQUFADBfMQswCQYDVQQGEwJV\n+UzEXMBUGA1UEChMOVmVyaVNpZ24sIEluYy4xNzA1BgNVBAsTLkNsYXNzIDMgUHVi\n+bGljIFByaW1hcnkgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMDQwNTEzMDAw\n+MDAwWhcNMTQwNTEyMjM1OTU5WjBMMQswCQYDVQQGEwJaQTElMCMGA1UEChMcVGhh\n+d3RlIENvbnN1bHRpbmcgKFB0eSkgTHRkLjEWMBQGA1UEAxMNVGhhd3RlIFNHQyBD\n+QTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA1NNn0I0Vf67NMf59HZGhPwtx\n+PKzMyGT7Y/wySweUvW+Aui/hBJPAM/wJMyPpC3QrccQDxtLN4i/1CWPN/0ilAL/g\n+5/OIty0y3pg25gqtAHvEZEo7hHUD8nCSfQ5i9SGraTaEMXWQ+L/HbIgbBpV8yeWo\n+3nWhLHpo39XKHIdYYBkCAwEAAaOB/jCB+zASBgNVHRMBAf8ECDAGAQH/AgEAMAsG\n+A1UdDwQEAwIBBjARBglghkgBhvhCAQEEBAMCAQYwKAYDVR0RBCEwH6QdMBsxGTAX\n+BgNVBAMTEFByaXZhdGVMYWJlbDMtMTUwMQYDVR0fBCowKDAmoCSgIoYgaHR0cDov\n+L2NybC52ZXJpc2lnbi5jb20vcGNhMy5jcmwwMgYIKwYBBQUHAQEEJjAkMCIGCCsG\n+AQUFBzABhhZodHRwOi8vb2NzcC50aGF3dGUuY29tMDQGA1UdJQQtMCsGCCsGAQUF\n+BwMBBggrBgEFBQcDAgYJYIZIAYb4QgQBBgpghkgBhvhFAQgBMA0GCSqGSIb3DQEB\n+BQUAA4GBAFWsY+reod3SkF+fC852vhNRj5PZBSvIG3dLrWlQoe7e3P3bB+noOZTc\n+q3J5Lwa/q4FwxKjt6lM07e8eU9kGx1Yr0Vz00YqOtCuxN5BICEIlxT6Ky3/rbwTR\n+bcV0oveifHtgPHfNDs5IAn8BL7abN+AqKjbc1YXWrOU/VG+WHgWv\n+-----END CERTIFICATE-----\n+`\n+\n+const googleLeaf = `-----BEGIN CERTIFICATE-----\n+MIIDITCCAoqgAwIBAgIQL9+89q6RUm0PmqPfQDQ+mjANBgkqhkiG9w0BAQUFADBM\n+MQswCQYDVQQGEwJaQTElMCMGA1UEChMcVGhhd3RlIENvbnN1bHRpbmcgKFB0eSkg\n+THRkLjEWMBQGA1UEAxMNVGhhd3RlIFNHQyBDQTAeFw0wOTEyMTgwMDAwMDBaFw0x\n+MTEyMTgyMzU5NTlaMGgxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlh\n+MRYwFAYDVQQHFA1Nb3VudGFpbiBWaWV3MRMwEQYDVQQKFApHb29nbGUgSW5jMRcw\n+FQYDVQQDFA53d3cuZ29vZ2xlLmNvbTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkC\n+gYEA6PmGD5D6htffvXImttdEAoN4c9kCKO+IRTn7EOh8rqk41XXGOOsKFQebg+jN\n+gtXj9xVoRaELGYW84u+E593y17iYwqG7tcFR39SDAqc9BkJb4SLD3muFXxzW2k6L\n+05vuuWciKh0R73mkszeK9P4Y/bz5RiNQl/Os/CRGK1w7t0UCAwEAAaOB5zCB5DAM\n+BgNVHRMBAf8EAjAAMDYGA1UdHwQvMC0wK6ApoCeGJWh0dHA6Ly9jcmwudGhhd3Rl\n+LmNvbS9UaGF3dGVTR0NDQS5jcmwwKAYDVR0lBCEwHwYIKwYBBQUHAwEGCCsGAQUF\n+BwMCBglghkgBhvhCBAEwcgYIKwYBBQUHAQEEZjBkMCIGCCsGAQUFBzABhhZodHRw\n+Oi8vb2NzcC50aGF3dGUuY29tMD4GCCsGAQUFBzAChjJodHRwOi8vd3d3LnRoYXd0\n+ZS5jb20vcmVwb3NpdG9yeS9UaGF3dGVfU0dDX0NBLmNydDANBgkqhkiG9w0BAQUF\n+AAOBgQCfQ89bxFApsb/isJr/aiEdLRLDLE5a+RLizrmCUi3nHX4adpaQedEkUjh5\n+u2ONgJd8IyAPkU0Wueru9G2Jysa9zCRo1kNbzipYvzwY4OA8Ys+WAi0oR1A04Se6\n+z5nRUP8pJcA2NhUzUnC+MY+f6H/nEQyNv4SgQhqAibAxWEEHXw==\n+-----END CERTIFICATE-----`\n+\n+const dnssecExpLeaf = `-----BEGIN CERTIFICATE-----\n+MIIGzTCCBbWgAwIBAgIDAdD6MA0GCSqGSIb3DQEBBQUAMIGMMQswCQYDVQQGEwJJ\n+TDEWMBQGA1UEChMNU3RhcnRDb20gTHRkLjErMCkGA1UECxMiU2VjdXJlIERpZ2l0\n+YWwgQ2VydGlmaWNhdGUgU2lnbmluZzE4MDYGA1UEAxMvU3RhcnRDb20gQ2xhc3Mg\n+MSBQcmltYXJ5IEludGVybWVkaWF0ZSBTZXJ2ZXIgQ0EwHhcNMTAwNzA0MTQ1MjQ1\n+WhcNMTEwNzA1MTA1NzA0WjCBwTEgMB4GA1UEDRMXMjIxMTM3LWxpOWE5dHhJRzZM\n+NnNyVFMxCzAJBgNVBAYTAlVTMR4wHAYDVQQKExVQZXJzb25hIE5vdCBWYWxpZGF0\n+ZWQxKTAnBgNVBAsTIFN0YXJ0Q29tIEZyZWUgQ2VydGlmaWNhdGUgTWVtYmVyMRsw\n+GQYDVQQDExJ3d3cuZG5zc2VjLWV4cC5vcmcxKDAmBgkqhkiG9w0BCQEWGWhvc3Rt\n+YXN0ZXJAZG5zc2VjLWV4cC5vcmcwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEK\n+AoIBAQDEdF/22vaxrPbqpgVYMWi+alfpzBctpbfLBdPGuqOazJdCT0NbWcK8/+B4\n+X6OlSOURNIlwLzhkmwVsWdVv6dVSaN7d4yI/fJkvgfDB9+au+iBJb6Pcz8ULBfe6\n+D8HVvqKdORp6INzHz71z0sghxrQ0EAEkoWAZLh+kcn2ZHdcmZaBNUfjmGbyU6PRt\n+RjdqoP+owIaC1aktBN7zl4uO7cRjlYFdusINrh2kPP02KAx2W84xjxX1uyj6oS6e\n+7eBfvcwe8czW/N1rbE0CoR7h9+HnIrjnVG9RhBiZEiw3mUmF++Up26+4KTdRKbu3\n++BL4yMpfd66z0+zzqu+HkvyLpFn5AgMBAAGjggL/MIIC+zAJBgNVHRMEAjAAMAsG\n+A1UdDwQEAwIDqDATBgNVHSUEDDAKBggrBgEFBQcDATAdBgNVHQ4EFgQUy04I5guM\n+drzfh2JQaXhgV86+4jUwHwYDVR0jBBgwFoAU60I00Jiwq5/0G2sI98xkLu8OLEUw\n+LQYDVR0RBCYwJIISd3d3LmRuc3NlYy1leHAub3Jngg5kbnNzZWMtZXhwLm9yZzCC\n+AUIGA1UdIASCATkwggE1MIIBMQYLKwYBBAGBtTcBAgIwggEgMC4GCCsGAQUFBwIB\n+FiJodHRwOi8vd3d3LnN0YXJ0c3NsLmNvbS9wb2xpY3kucGRmMDQGCCsGAQUFBwIB\n+FihodHRwOi8vd3d3LnN0YXJ0c3NsLmNvbS9pbnRlcm1lZGlhdGUucGRmMIG3Bggr\n+BgEFBQcCAjCBqjAUFg1TdGFydENvbSBMdGQuMAMCAQEagZFMaW1pdGVkIExpYWJp\n+bGl0eSwgc2VlIHNlY3Rpb24gKkxlZ2FsIExpbWl0YXRpb25zKiBvZiB0aGUgU3Rh\n+cnRDb20gQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkgUG9saWN5IGF2YWlsYWJsZSBh\n+dCBodHRwOi8vd3d3LnN0YXJ0c3NsLmNvbS9wb2xpY3kucGRmMGEGA1UdHwRaMFgw\n+KqAooCaGJGh0dHA6Ly93d3cuc3RhcnRzc2wuY29tL2NydDEtY3JsLmNybDAqoCig\n+JoYkaHR0cDovL2NybC5zdGFydHNzbC5jb20vY3J0MS1jcmwuY3JsMIGOBggrBgEF\n+BQcBAQSBgTB/MDkGCCsGAQUFBzABhi1odHRwOi8vb2NzcC5zdGFydHNzbC5jb20v\n+c3ViL2NsYXNzMS9zZXJ2ZXIvY2EwQgYIKwYBBQUHMAKGNmh0dHA6Ly93d3cuc3Rh\n+cnRzc2wuY29tL2NlcnRzL3N1Yi5jbGFzczEuc2VydmVyLmNhLmNydDAjBgNVHRIE\n+HDAahhhodHRwOi8vd3d3LnN0YXJ0c3NsLmNvbS8wDQYJKoZIhvcNAQEFBQADggEB\n+ACXj6SB59KRJPenn6gUdGEqcta97U769SATyiQ87i9er64qLwvIGLMa3o2Rcgl2Y\n+kghUeyLdN/EXyFBYA8L8uvZREPoc7EZukpT/ZDLXy9i2S0jkOxvF2fD/XLbcjGjM\n+iEYG1/6ASw0ri9C0k4oDDoJLCoeH9++yqF7SFCCMcDkJqiAGXNb4euDpa8vCCtEQ\n+CSS+ObZbfkreRt3cNCf5LfCXe9OsTnCfc8Cuq81c0oLaG+SmaLUQNBuToq8e9/Zm\n++b+/a3RVjxmkV5OCcGVBxsXNDn54Q6wsdw0TBMcjwoEndzpLS7yWgFbbkq5ZiGpw\n+Qibb2+CfKuQ+WFV1GkVQmVA=\n+-----END CERTIFICATE-----`\n+\n+const startComIntermediate = `-----BEGIN CERTIFICATE-----\n+MIIGNDCCBBygAwIBAgIBGDANBgkqhkiG9w0BAQUFADB9MQswCQYDVQQGEwJJTDEW\n+MBQGA1UEChMNU3RhcnRDb20gTHRkLjErMCkGA1UECxMiU2VjdXJlIERpZ2l0YWwg\n+Q2VydGlmaWNhdGUgU2lnbmluZzEpMCcGA1UEAxMgU3RhcnRDb20gQ2VydGlmaWNh\n+dGlvbiBBdXRob3JpdHkwHhcNMDcxMDI0MjA1NDE3WhcNMTcxMDI0MjA1NDE3WjCB\n+jDELMAkGA1UEBhMCSUwxFjAUBgNVBAoTDVN0YXJ0Q29tIEx0ZC4xKzApBgNVBAsT\n+IlNlY3VyZSBEaWdpdGFsIENlcnRpZmljYXRlIFNpZ25pbmcxODA2BgNVBAMTL1N0\n+YXJ0Q29tIENsYXNzIDEgUHJpbWFyeSBJbnRlcm1lZGlhdGUgU2VydmVyIENBMIIB\n+IjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtonGrO8JUngHrJJj0PREGBiE\n+gFYfka7hh/oyULTTRwbw5gdfcA4Q9x3AzhA2NIVaD5Ksg8asWFI/ujjo/OenJOJA\n+pgh2wJJuniptTT9uYSAK21ne0n1jsz5G/vohURjXzTCm7QduO3CHtPn66+6CPAVv\n+kvek3AowHpNz/gfK11+AnSJYUq4G2ouHI2mw5CrY6oPSvfNx23BaKA+vWjhwRRI/\n+ME3NO68X5Q/LoKldSKqxYVDLNM08XMML6BDAjJvwAwNi/rJsPnIO7hxDKslIDlc5\n+xDEhyBDBLIf+VJVSH1I8MRKbf+fAoKVZ1eKPPvDVqOHXcDGpxLPPr21TLwb0pwID\n+AQABo4IBrTCCAakwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYD\n+VR0OBBYEFOtCNNCYsKuf9BtrCPfMZC7vDixFMB8GA1UdIwQYMBaAFE4L7xqkQFul\n+F2mHMMo0aEPQQa7yMGYGCCsGAQUFBwEBBFowWDAnBggrBgEFBQcwAYYbaHR0cDov\n+L29jc3Auc3RhcnRzc2wuY29tL2NhMC0GCCsGAQUFBzAChiFodHRwOi8vd3d3LnN0\n+YXJ0c3NsLmNvbS9zZnNjYS5jcnQwWwYDVR0fBFQwUjAnoCWgI4YhaHR0cDovL3d3\n+dy5zdGFydHNzbC5jb20vc2ZzY2EuY3JsMCegJaAjhiFodHRwOi8vY3JsLnN0YXJ0\n+c3NsLmNvbS9zZnNjYS5jcmwwgYAGA1UdIAR5MHcwdQYLKwYBBAGBtTcBAgEwZjAu\n+BggrBgEFBQcCARYiaHR0cDovL3d3dy5zdGFydHNzbC5jb20vcG9saWN5LnBkZjA0\n+BggrBgEFBQcCARYoaHR0cDovL3d3dy5zdGFydHNzbC5jb20vaW50ZXJtZWRpYXRl\n+LnBkZjANBgkqhkiG9w0BAQUFAAOCAgEAIQlJPqWIbuALi0jaMU2P91ZXouHTYlfp\n+tVbzhUV1O+VQHwSL5qBaPucAroXQ+/8gA2TLrQLhxpFy+KNN1t7ozD+hiqLjfDen\n+xk+PNdb01m4Ge90h2c9W/8swIkn+iQTzheWq8ecf6HWQTd35RvdCNPdFWAwRDYSw\n+xtpdPvkBnufh2lWVvnQce/xNFE+sflVHfXv0pQ1JHpXo9xLBzP92piVH0PN1Nb6X\n+t1gW66pceG/sUzCv6gRNzKkC4/C2BBL2MLERPZBOVmTX3DxDX3M570uvh+v2/miI\n+RHLq0gfGabDBoYvvF0nXYbFFSF87ICHpW7LM9NfpMfULFWE7epTj69m8f5SuauNi\n+YpaoZHy4h/OZMn6SolK+u/hlz8nyMPyLwcKmltdfieFcNID1j0cHL7SRv7Gifl9L\n+WtBbnySGBVFaaQNlQ0lxxeBvlDRr9hvYqbBMflPrj0jfyjO1SPo2ShpTpjMM0InN\n+SRXNiTE8kMBy12VLUjWKRhFEuT2OKGWmPnmeXAhEKa2wNREuIU640ucQPl2Eg7PD\n+wuTSxv0JS3QJ3fGz0xk+gA2iCxnwOOfFwq/iI9th4p1cbiCJSS4jarJiwUW0n6+L\n+p/EiO/h94pDQehn7Skzj0n1fSoMD7SfWI55rjbRZotnvbIIp3XUZPD9MEI3vu3Un\n+0q6Dp6jOW6c=\n+-----END CERTIFICATE-----`\n+\n+const startComRoot = `-----BEGIN CERTIFICATE-----\n+MIIHyTCCBbGgAwIBAgIBATANBgkqhkiG9w0BAQUFADB9MQswCQYDVQQGEwJJTDEW\n+MBQGA1UEChMNU3RhcnRDb20gTHRkLjErMCkGA1UECxMiU2VjdXJlIERpZ2l0YWwg\n+Q2VydGlmaWNhdGUgU2lnbmluZzEpMCcGA1UEAxMgU3RhcnRDb20gQ2VydGlmaWNh\n+dGlvbiBBdXRob3JpdHkwHhcNMDYwOTE3MTk0NjM2WhcNMzYwOTE3MTk0NjM2WjB9\n+MQswCQYDVQQGEwJJTDEWMBQGA1UEChMNU3RhcnRDb20gTHRkLjErMCkGA1UECxMi\n+U2VjdXJlIERpZ2l0YWwgQ2VydGlmaWNhdGUgU2lnbmluZzEpMCcGA1UEAxMgU3Rh\n+cnRDb20gQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwggIiMA0GCSqGSIb3DQEBAQUA\n+A4ICDwAwggIKAoICAQDBiNsJvGxGfHiflXu1M5DycmLWwTYgIiRezul38kMKogZk\n+pMyONvg45iPwbm2xPN1yo4UcodM9tDMr0y+v/uqwQVlntsQGfQqedIXWeUyAN3rf\n+OQVSWff0G0ZDpNKFhdLDcfN1YjS6LIp/Ho/u7TTQEceWzVI9ujPW3U3eCztKS5/C\n+Ji/6tRYccjV3yjxd5srhJosaNnZcAdt0FCX+7bWgiA/deMotHweXMAEtcnn6RtYT\n+Kqi5pquDSR3l8u/d5AGOGAqPY1MWhWKpDhk6zLVmpsJrdAfkK+F2PrRt2PZE4XNi\n+HzvEvqBTViVsUQn3qqvKv3b9bZvzndu/PWa8DFaqr5hIlTpL36dYUNk4dalb6kMM\n+Av+Z6+hsTXBbKWWc3apdzK8BMewM69KN6Oqce+Zu9ydmDBpI125C4z/eIT574Q1w\n++2OqqGwaVLRcJXrJosmLFqa7LH4XXgVNWG4SHQHuEhANxjJ/GP/89PrNbpHoNkm+\n+Gkhpi8KWTRoSsmkXwQqQ1vp5Iki/untp+HDH+no32NgN0nZPV/+Qt+OR0t3vwmC3\n+Zzrd/qqc8NSLf3Iizsafl7b4r4qgEKjZ+xjGtrVcUjyJthkqcwEKDwOzEmDyei+B\n+26Nu/yYwl/WL3YlXtq09s68rxbd2AvCl1iuahhQqcvbjM4xdCUsT37uMdBNSSwID\n+AQABo4ICUjCCAk4wDAYDVR0TBAUwAwEB/zALBgNVHQ8EBAMCAa4wHQYDVR0OBBYE\n+FE4L7xqkQFulF2mHMMo0aEPQQa7yMGQGA1UdHwRdMFswLKAqoCiGJmh0dHA6Ly9j\n+ZXJ0LnN0YXJ0Y29tLm9yZy9zZnNjYS1jcmwuY3JsMCugKaAnhiVodHRwOi8vY3Js\n+LnN0YXJ0Y29tLm9yZy9zZnNjYS1jcmwuY3JsMIIBXQYDVR0gBIIBVDCCAVAwggFM\n+BgsrBgEEAYG1NwEBATCCATswLwYIKwYBBQUHAgEWI2h0dHA6Ly9jZXJ0LnN0YXJ0\n+Y29tLm9yZy9wb2xpY3kucGRmMDUGCCsGAQUFBwIBFilodHRwOi8vY2VydC5zdGFy\n+dGNvbS5vcmcvaW50ZXJtZWRpYXRlLnBkZjCB0AYIKwYBBQUHAgIwgcMwJxYgU3Rh\n+cnQgQ29tbWVyY2lhbCAoU3RhcnRDb20pIEx0ZC4wAwIBARqBl0xpbWl0ZWQgTGlh\n+YmlsaXR5LCByZWFkIHRoZSBzZWN0aW9uICpMZWdhbCBMaW1pdGF0aW9ucyogb2Yg\n+dGhlIFN0YXJ0Q29tIENlcnRpZmljYXRpb24gQXV0aG9yaXR5IFBvbGljeSBhdmFp\n+bGFibGUgYXQgaHR0cDovL2NlcnQuc3RhcnRjb20ub3JnL3BvbGljeS5wZGYwEQYJ\n+YIZIAYb4QgEBBAQDAgAHMDgGCWCGSAGG+EIBDQQrFilTdGFydENvbSBGcmVlIFNT\n+TCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTANBgkqhkiG9w0BAQUFAAOCAgEAFmyZ\n+9GYMNPXQhV59CuzaEE44HF7fpiUFS5Eyweg78T3dRAlbB0mKKctmArexmvclmAk8\n+jhvh3TaHK0u7aNM5Zj2gJsfyOZEdUauCe37Vzlrk4gNXcGmXCPleWKYK34wGmkUW\n+FjgKXlf2Ysd6AgXmvB618p70qSmD+LIU424oh0TDkBreOKk8rENNZEXO3SipXPJz\n+ewT4F+irsfMuXGRuczE6Eri8sxHkfY+BUZo7jYn0TZNmezwD7dOaHZrzZVD1oNB1\n+ny+v8OqCQ5j4aZyJecRDjkZy42Q2Eq/3JR44iZB3fsNrarnDy0RLrHiQi+fHLB5L\n+EUTINFInzQpdn4XBidUaePKVEFMy3YCEZnXZtWgo+2EuvoSoOMCZEoalHmdkrQYu\n+L6lwhceWD3yJZfWOQ1QOq92lgDmUYMA0yZZwLKMS9R9Ie70cfmu3nZD0Ijuu+Pwq\n+yvqCUqDvr0tVk+vBtfAii6w0TiYiBKGHLHVKt+V9E9e4DGTANtLJL4YSjCMJwRuC\n+O3NJo2pXh5Tl1njFmUNj403gdy3hZZlyaQQaRwnmDwFWJPsfvw55qVguucQJAX6V\n+um0ABj6y6koQOdjQK/W/7HW/lwLFCRsI3FU34oH7N4RDYiDK51ZLZer+bMEkkySh\n+NOsF/5oirpt9P/FlUQqmMGqz9IgcgA38corog14=\n+-----END CERTIFICATE-----`"}, {"sha": "d0c5a26a9a8fec9b50712a33cf3c610a5104e77d", "filename": "libgo/go/crypto/x509/x509.go", "status": "modified", "additions": 83, "deletions": 70, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,20 +2,20 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This package parses X.509-encoded keys and certificates.\n+// Package x509 parses X.509-encoded keys and certificates.\n package x509\n \n import (\n \t\"asn1\"\n \t\"big\"\n+\t\"bytes\"\n \t\"container/vector\"\n \t\"crypto\"\n \t\"crypto/rsa\"\n \t\"crypto/sha1\"\n \t\"hash\"\n \t\"io\"\n \t\"os\"\n-\t\"strings\"\n \t\"time\"\n )\n \n@@ -27,6 +27,20 @@ type pkcs1PrivateKey struct {\n \tD       asn1.RawValue\n \tP       asn1.RawValue\n \tQ       asn1.RawValue\n+\t// We ignore these values, if present, because rsa will calculate them.\n+\tDp   asn1.RawValue \"optional\"\n+\tDq   asn1.RawValue \"optional\"\n+\tQinv asn1.RawValue \"optional\"\n+\n+\tAdditionalPrimes []pkcs1AddtionalRSAPrime \"optional\"\n+}\n+\n+type pkcs1AddtionalRSAPrime struct {\n+\tPrime asn1.RawValue\n+\n+\t// We ignore these values because rsa will calculate them.\n+\tExp   asn1.RawValue\n+\tCoeff asn1.RawValue\n }\n \n // rawValueIsInteger returns true iff the given ASN.1 RawValue is an INTEGER type.\n@@ -46,6 +60,10 @@ func ParsePKCS1PrivateKey(der []byte) (key *rsa.PrivateKey, err os.Error) {\n \t\treturn\n \t}\n \n+\tif priv.Version > 1 {\n+\t\treturn nil, os.ErrorString(\"x509: unsupported private key version\")\n+\t}\n+\n \tif !rawValueIsInteger(&priv.N) ||\n \t\t!rawValueIsInteger(&priv.D) ||\n \t\t!rawValueIsInteger(&priv.P) ||\n@@ -61,26 +79,66 @@ func ParsePKCS1PrivateKey(der []byte) (key *rsa.PrivateKey, err os.Error) {\n \t}\n \n \tkey.D = new(big.Int).SetBytes(priv.D.Bytes)\n-\tkey.P = new(big.Int).SetBytes(priv.P.Bytes)\n-\tkey.Q = new(big.Int).SetBytes(priv.Q.Bytes)\n+\tkey.Primes = make([]*big.Int, 2+len(priv.AdditionalPrimes))\n+\tkey.Primes[0] = new(big.Int).SetBytes(priv.P.Bytes)\n+\tkey.Primes[1] = new(big.Int).SetBytes(priv.Q.Bytes)\n+\tfor i, a := range priv.AdditionalPrimes {\n+\t\tif !rawValueIsInteger(&a.Prime) {\n+\t\t\treturn nil, asn1.StructuralError{\"tags don't match\"}\n+\t\t}\n+\t\tkey.Primes[i+2] = new(big.Int).SetBytes(a.Prime.Bytes)\n+\t\t// We ignore the other two values because rsa will calculate\n+\t\t// them as needed.\n+\t}\n \n \terr = key.Validate()\n \tif err != nil {\n \t\treturn nil, err\n \t}\n+\tkey.Precompute()\n \n \treturn\n }\n \n+// rawValueForBig returns an asn1.RawValue which represents the given integer.\n+func rawValueForBig(n *big.Int) asn1.RawValue {\n+\tb := n.Bytes()\n+\tif n.Sign() >= 0 && len(b) > 0 && b[0]&0x80 != 0 {\n+\t\t// This positive number would be interpreted as a negative\n+\t\t// number in ASN.1 because the MSB is set.\n+\t\tpadded := make([]byte, len(b)+1)\n+\t\tcopy(padded[1:], b)\n+\t\tb = padded\n+\t}\n+\treturn asn1.RawValue{Tag: 2, Bytes: b}\n+}\n+\n // MarshalPKCS1PrivateKey converts a private key to ASN.1 DER encoded form.\n func MarshalPKCS1PrivateKey(key *rsa.PrivateKey) []byte {\n+\tkey.Precompute()\n+\n+\tversion := 0\n+\tif len(key.Primes) > 2 {\n+\t\tversion = 1\n+\t}\n+\n \tpriv := pkcs1PrivateKey{\n-\t\tVersion: 1,\n-\t\tN:       asn1.RawValue{Tag: 2, Bytes: key.PublicKey.N.Bytes()},\n+\t\tVersion: version,\n+\t\tN:       rawValueForBig(key.N),\n \t\tE:       key.PublicKey.E,\n-\t\tD:       asn1.RawValue{Tag: 2, Bytes: key.D.Bytes()},\n-\t\tP:       asn1.RawValue{Tag: 2, Bytes: key.P.Bytes()},\n-\t\tQ:       asn1.RawValue{Tag: 2, Bytes: key.Q.Bytes()},\n+\t\tD:       rawValueForBig(key.D),\n+\t\tP:       rawValueForBig(key.Primes[0]),\n+\t\tQ:       rawValueForBig(key.Primes[1]),\n+\t\tDp:      rawValueForBig(key.Precomputed.Dp),\n+\t\tDq:      rawValueForBig(key.Precomputed.Dq),\n+\t\tQinv:    rawValueForBig(key.Precomputed.Qinv),\n+\t}\n+\n+\tpriv.AdditionalPrimes = make([]pkcs1AddtionalRSAPrime, len(key.Precomputed.CRTValues))\n+\tfor i, values := range key.Precomputed.CRTValues {\n+\t\tpriv.AdditionalPrimes[i].Prime = rawValueForBig(key.Primes[2+i])\n+\t\tpriv.AdditionalPrimes[i].Exp = rawValueForBig(values.Exp)\n+\t\tpriv.AdditionalPrimes[i].Coeff = rawValueForBig(values.Coeff)\n \t}\n \n \tb, _ := asn1.Marshal(priv)\n@@ -90,6 +148,7 @@ func MarshalPKCS1PrivateKey(key *rsa.PrivateKey) []byte {\n // These structures reflect the ASN.1 structure of X.509 certificates.:\n \n type certificate struct {\n+\tRaw                asn1.RawContent\n \tTBSCertificate     tbsCertificate\n \tSignatureAlgorithm algorithmIdentifier\n \tSignatureValue     asn1.BitString\n@@ -127,6 +186,7 @@ type validity struct {\n }\n \n type publicKeyInfo struct {\n+\tRaw       asn1.RawContent\n \tAlgorithm algorithmIdentifier\n \tPublicKey asn1.BitString\n }\n@@ -343,7 +403,10 @@ const (\n \n // A Certificate represents an X.509 certificate.\n type Certificate struct {\n-\tRaw                []byte // Raw ASN.1 DER contents.\n+\tRaw                     []byte // Complete ASN.1 DER content (certificate, signature algorithm and signature).\n+\tRawTBSCertificate       []byte // Certificate part of raw ASN.1 DER content.\n+\tRawSubjectPublicKeyInfo []byte // DER encoded SubjectPublicKeyInfo.\n+\n \tSignature          []byte\n \tSignatureAlgorithm SignatureAlgorithm\n \n@@ -395,6 +458,10 @@ func (ConstraintViolationError) String() string {\n \treturn \"invalid signature: parent certificate cannot sign this kind of certificate\"\n }\n \n+func (c *Certificate) Equal(other *Certificate) bool {\n+\treturn bytes.Equal(c.Raw, other.Raw)\n+}\n+\n // CheckSignatureFrom verifies that the signature on c is a valid signature\n // from parent.\n func (c *Certificate) CheckSignatureFrom(parent *Certificate) (err os.Error) {\n@@ -434,69 +501,12 @@ func (c *Certificate) CheckSignatureFrom(parent *Certificate) (err os.Error) {\n \t\treturn UnsupportedAlgorithmError{}\n \t}\n \n-\th.Write(c.Raw)\n+\th.Write(c.RawTBSCertificate)\n \tdigest := h.Sum()\n \n \treturn rsa.VerifyPKCS1v15(pub, hashType, digest, c.Signature)\n }\n \n-func matchHostnames(pattern, host string) bool {\n-\tif len(pattern) == 0 || len(host) == 0 {\n-\t\treturn false\n-\t}\n-\n-\tpatternParts := strings.Split(pattern, \".\", -1)\n-\thostParts := strings.Split(host, \".\", -1)\n-\n-\tif len(patternParts) != len(hostParts) {\n-\t\treturn false\n-\t}\n-\n-\tfor i, patternPart := range patternParts {\n-\t\tif patternPart == \"*\" {\n-\t\t\tcontinue\n-\t\t}\n-\t\tif patternPart != hostParts[i] {\n-\t\t\treturn false\n-\t\t}\n-\t}\n-\n-\treturn true\n-}\n-\n-type HostnameError struct {\n-\tCertificate *Certificate\n-\tHost        string\n-}\n-\n-func (h *HostnameError) String() string {\n-\tvar valid string\n-\tc := h.Certificate\n-\tif len(c.DNSNames) > 0 {\n-\t\tvalid = strings.Join(c.DNSNames, \", \")\n-\t} else {\n-\t\tvalid = c.Subject.CommonName\n-\t}\n-\treturn \"certificate is valid for \" + valid + \", not \" + h.Host\n-}\n-\n-// VerifyHostname returns nil if c is a valid certificate for the named host.\n-// Otherwise it returns an os.Error describing the mismatch.\n-func (c *Certificate) VerifyHostname(h string) os.Error {\n-\tif len(c.DNSNames) > 0 {\n-\t\tfor _, match := range c.DNSNames {\n-\t\t\tif matchHostnames(match, h) {\n-\t\t\t\treturn nil\n-\t\t\t}\n-\t\t}\n-\t\t// If Subject Alt Name is given, we ignore the common name.\n-\t} else if matchHostnames(c.Subject.CommonName, h) {\n-\t\treturn nil\n-\t}\n-\n-\treturn &HostnameError{c, h}\n-}\n-\n type UnhandledCriticalExtension struct{}\n \n func (h UnhandledCriticalExtension) String() string {\n@@ -558,7 +568,9 @@ func parsePublicKey(algo PublicKeyAlgorithm, asn1Data []byte) (interface{}, os.E\n \n func parseCertificate(in *certificate) (*Certificate, os.Error) {\n \tout := new(Certificate)\n-\tout.Raw = in.TBSCertificate.Raw\n+\tout.Raw = in.Raw\n+\tout.RawTBSCertificate = in.TBSCertificate.Raw\n+\tout.RawSubjectPublicKeyInfo = in.TBSCertificate.PublicKey.Raw\n \n \tout.Signature = in.SignatureValue.RightAlign()\n \tout.SignatureAlgorithm =\n@@ -975,7 +987,7 @@ func CreateCertificate(rand io.Reader, template, parent *Certificate, pub *rsa.P\n \t\tIssuer:             parent.Subject.toRDNSequence(),\n \t\tValidity:           validity{template.NotBefore, template.NotAfter},\n \t\tSubject:            template.Subject.toRDNSequence(),\n-\t\tPublicKey:          publicKeyInfo{algorithmIdentifier{oidRSA}, encodedPublicKey},\n+\t\tPublicKey:          publicKeyInfo{nil, algorithmIdentifier{oidRSA}, encodedPublicKey},\n \t\tExtensions:         extensions,\n \t}\n \n@@ -996,6 +1008,7 @@ func CreateCertificate(rand io.Reader, template, parent *Certificate, pub *rsa.P\n \t}\n \n \tcert, err = asn1.Marshal(certificate{\n+\t\tnil,\n \t\tc,\n \t\talgorithmIdentifier{oidSHA1WithRSA},\n \t\tasn1.BitString{Bytes: signature, BitLength: len(signature) * 8},"}, {"sha": "a42113addda4fc00835e6bb2d481048ca5ffd346", "filename": "libgo/go/crypto/x509/x509_test.go", "status": "modified", "additions": 45, "deletions": 4, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -20,12 +20,13 @@ func TestParsePKCS1PrivateKey(t *testing.T) {\n \tpriv, err := ParsePKCS1PrivateKey(block.Bytes)\n \tif err != nil {\n \t\tt.Errorf(\"Failed to parse private key: %s\", err)\n+\t\treturn\n \t}\n \tif priv.PublicKey.N.Cmp(rsaPrivateKey.PublicKey.N) != 0 ||\n \t\tpriv.PublicKey.E != rsaPrivateKey.PublicKey.E ||\n \t\tpriv.D.Cmp(rsaPrivateKey.D) != 0 ||\n-\t\tpriv.P.Cmp(rsaPrivateKey.P) != 0 ||\n-\t\tpriv.Q.Cmp(rsaPrivateKey.Q) != 0 {\n+\t\tpriv.Primes[0].Cmp(rsaPrivateKey.Primes[0]) != 0 ||\n+\t\tpriv.Primes[1].Cmp(rsaPrivateKey.Primes[1]) != 0 {\n \t\tt.Errorf(\"got:%+v want:%+v\", priv, rsaPrivateKey)\n \t}\n }\n@@ -47,14 +48,54 @@ func bigFromString(s string) *big.Int {\n \treturn ret\n }\n \n+func fromBase10(base10 string) *big.Int {\n+\ti := new(big.Int)\n+\ti.SetString(base10, 10)\n+\treturn i\n+}\n+\n var rsaPrivateKey = &rsa.PrivateKey{\n \tPublicKey: rsa.PublicKey{\n \t\tN: bigFromString(\"9353930466774385905609975137998169297361893554149986716853295022578535724979677252958524466350471210367835187480748268864277464700638583474144061408845077\"),\n \t\tE: 65537,\n \t},\n \tD: bigFromString(\"7266398431328116344057699379749222532279343923819063639497049039389899328538543087657733766554155839834519529439851673014800261285757759040931985506583861\"),\n-\tP: bigFromString(\"98920366548084643601728869055592650835572950932266967461790948584315647051443\"),\n-\tQ: bigFromString(\"94560208308847015747498523884063394671606671904944666360068158221458669711639\"),\n+\tPrimes: []*big.Int{\n+\t\tbigFromString(\"98920366548084643601728869055592650835572950932266967461790948584315647051443\"),\n+\t\tbigFromString(\"94560208308847015747498523884063394671606671904944666360068158221458669711639\"),\n+\t},\n+}\n+\n+func TestMarshalRSAPrivateKey(t *testing.T) {\n+\tpriv := &rsa.PrivateKey{\n+\t\tPublicKey: rsa.PublicKey{\n+\t\t\tN: fromBase10(\"16346378922382193400538269749936049106320265317511766357599732575277382844051791096569333808598921852351577762718529818072849191122419410612033592401403764925096136759934497687765453905884149505175426053037420486697072448609022753683683718057795566811401938833367954642951433473337066311978821180526439641496973296037000052546108507805269279414789035461158073156772151892452251106173507240488993608650881929629163465099476849643165682709047462010581308719577053905787496296934240246311806555924593059995202856826239801816771116902778517096212527979497399966526283516447337775509777558018145573127308919204297111496233\"),\n+\t\t\tE: 3,\n+\t\t},\n+\t\tD: fromBase10(\"10897585948254795600358846499957366070880176878341177571733155050184921896034527397712889205732614568234385175145686545381899460748279607074689061600935843283397424506622998458510302603922766336783617368686090042765718290914099334449154829375179958369993407724946186243249568928237086215759259909861748642124071874879861299389874230489928271621259294894142840428407196932444474088857746123104978617098858619445675532587787023228852383149557470077802718705420275739737958953794088728369933811184572620857678792001136676902250566845618813972833750098806496641114644760255910789397593428910198080271317419213080834885003\"),\n+\t\tPrimes: []*big.Int{\n+\t\t\tfromBase10(\"1025363189502892836833747188838978207017355117492483312747347695538428729137306368764177201532277413433182799108299960196606011786562992097313508180436744488171474690412562218914213688661311117337381958560443\"),\n+\t\t\tfromBase10(\"3467903426626310123395340254094941045497208049900750380025518552334536945536837294961497712862519984786362199788654739924501424784631315081391467293694361474867825728031147665777546570788493758372218019373\"),\n+\t\t\tfromBase10(\"4597024781409332673052708605078359346966325141767460991205742124888960305710298765592730135879076084498363772408626791576005136245060321874472727132746643162385746062759369754202494417496879741537284589047\"),\n+\t\t},\n+\t}\n+\n+\tderBytes := MarshalPKCS1PrivateKey(priv)\n+\n+\tpriv2, err := ParsePKCS1PrivateKey(derBytes)\n+\tif err != nil {\n+\t\tt.Errorf(\"error parsing serialized key: %s\", err)\n+\t\treturn\n+\t}\n+\tif priv.PublicKey.N.Cmp(priv2.PublicKey.N) != 0 ||\n+\t\tpriv.PublicKey.E != priv2.PublicKey.E ||\n+\t\tpriv.D.Cmp(priv2.D) != 0 ||\n+\t\tlen(priv2.Primes) != 3 ||\n+\t\tpriv.Primes[0].Cmp(priv2.Primes[0]) != 0 ||\n+\t\tpriv.Primes[1].Cmp(priv2.Primes[1]) != 0 ||\n+\t\tpriv.Primes[2].Cmp(priv2.Primes[2]) != 0 {\n+\t\tt.Errorf(\"got:%+v want:%+v\", priv, priv2)\n+\t}\n }\n \n type matchHostnamesTest struct {"}, {"sha": "f2a5da0035c59aa2c0a0517cf6270909f85cc722", "filename": "libgo/go/crypto/xtea/cipher.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fxtea%2Fcipher.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fcrypto%2Fxtea%2Fcipher.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fxtea%2Fcipher.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,8 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This package implements XTEA encryption, as defined in Needham and\n-// Wheeler's 1997 technical report, \"Tea extensions.\"\n+// Package xtea implements XTEA encryption, as defined in Needham and Wheeler's\n+// 1997 technical report, \"Tea extensions.\"\n package xtea\n \n // For details, see http://www.cix.co.uk/~klockstone/xtea.pdf"}, {"sha": "d9525f78835bceef818936e8c10ef30469a1c401", "filename": "libgo/go/debug/dwarf/open.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fdebug%2Fdwarf%2Fopen.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fdebug%2Fdwarf%2Fopen.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Fopen.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,9 +2,9 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This package provides access to DWARF debugging information\n-// loaded from executable files, as defined in the DWARF 2.0 Standard\n-// at http://dwarfstd.org/doc/dwarf-2.0.0.pdf\n+// Package dwarf provides access to DWARF debugging information loaded from\n+// executable files, as defined in the DWARF 2.0 Standard at\n+// http://dwarfstd.org/doc/dwarf-2.0.0.pdf\n package dwarf\n \n import ("}, {"sha": "5d45b24863d47908e4676282c74931a91f9a5cd1", "filename": "libgo/go/debug/elf/elf.go", "status": "modified", "additions": 41, "deletions": 24, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fdebug%2Felf%2Felf.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fdebug%2Felf%2Felf.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Felf.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -330,29 +330,35 @@ func (i SectionIndex) GoString() string { return stringName(uint32(i), shnString\n type SectionType uint32\n \n const (\n-\tSHT_NULL          SectionType = 0          /* inactive */\n-\tSHT_PROGBITS      SectionType = 1          /* program defined information */\n-\tSHT_SYMTAB        SectionType = 2          /* symbol table section */\n-\tSHT_STRTAB        SectionType = 3          /* string table section */\n-\tSHT_RELA          SectionType = 4          /* relocation section with addends */\n-\tSHT_HASH          SectionType = 5          /* symbol hash table section */\n-\tSHT_DYNAMIC       SectionType = 6          /* dynamic section */\n-\tSHT_NOTE          SectionType = 7          /* note section */\n-\tSHT_NOBITS        SectionType = 8          /* no space section */\n-\tSHT_REL           SectionType = 9          /* relocation section - no addends */\n-\tSHT_SHLIB         SectionType = 10         /* reserved - purpose unknown */\n-\tSHT_DYNSYM        SectionType = 11         /* dynamic symbol table section */\n-\tSHT_INIT_ARRAY    SectionType = 14         /* Initialization function pointers. */\n-\tSHT_FINI_ARRAY    SectionType = 15         /* Termination function pointers. */\n-\tSHT_PREINIT_ARRAY SectionType = 16         /* Pre-initialization function ptrs. */\n-\tSHT_GROUP         SectionType = 17         /* Section group. */\n-\tSHT_SYMTAB_SHNDX  SectionType = 18         /* Section indexes (see SHN_XINDEX). */\n-\tSHT_LOOS          SectionType = 0x60000000 /* First of OS specific semantics */\n-\tSHT_HIOS          SectionType = 0x6fffffff /* Last of OS specific semantics */\n-\tSHT_LOPROC        SectionType = 0x70000000 /* reserved range for processor */\n-\tSHT_HIPROC        SectionType = 0x7fffffff /* specific section header types */\n-\tSHT_LOUSER        SectionType = 0x80000000 /* reserved range for application */\n-\tSHT_HIUSER        SectionType = 0xffffffff /* specific indexes */\n+\tSHT_NULL           SectionType = 0          /* inactive */\n+\tSHT_PROGBITS       SectionType = 1          /* program defined information */\n+\tSHT_SYMTAB         SectionType = 2          /* symbol table section */\n+\tSHT_STRTAB         SectionType = 3          /* string table section */\n+\tSHT_RELA           SectionType = 4          /* relocation section with addends */\n+\tSHT_HASH           SectionType = 5          /* symbol hash table section */\n+\tSHT_DYNAMIC        SectionType = 6          /* dynamic section */\n+\tSHT_NOTE           SectionType = 7          /* note section */\n+\tSHT_NOBITS         SectionType = 8          /* no space section */\n+\tSHT_REL            SectionType = 9          /* relocation section - no addends */\n+\tSHT_SHLIB          SectionType = 10         /* reserved - purpose unknown */\n+\tSHT_DYNSYM         SectionType = 11         /* dynamic symbol table section */\n+\tSHT_INIT_ARRAY     SectionType = 14         /* Initialization function pointers. */\n+\tSHT_FINI_ARRAY     SectionType = 15         /* Termination function pointers. */\n+\tSHT_PREINIT_ARRAY  SectionType = 16         /* Pre-initialization function ptrs. */\n+\tSHT_GROUP          SectionType = 17         /* Section group. */\n+\tSHT_SYMTAB_SHNDX   SectionType = 18         /* Section indexes (see SHN_XINDEX). */\n+\tSHT_LOOS           SectionType = 0x60000000 /* First of OS specific semantics */\n+\tSHT_GNU_ATTRIBUTES SectionType = 0x6ffffff5 /* GNU object attributes */\n+\tSHT_GNU_HASH       SectionType = 0x6ffffff6 /* GNU hash table */\n+\tSHT_GNU_LIBLIST    SectionType = 0x6ffffff7 /* GNU prelink library list */\n+\tSHT_GNU_VERDEF     SectionType = 0x6ffffffd /* GNU version definition section */\n+\tSHT_GNU_VERNEED    SectionType = 0x6ffffffe /* GNU version needs section */\n+\tSHT_GNU_VERSYM     SectionType = 0x6fffffff /* GNU version symbol table */\n+\tSHT_HIOS           SectionType = 0x6fffffff /* Last of OS specific semantics */\n+\tSHT_LOPROC         SectionType = 0x70000000 /* reserved range for processor */\n+\tSHT_HIPROC         SectionType = 0x7fffffff /* specific section header types */\n+\tSHT_LOUSER         SectionType = 0x80000000 /* reserved range for application */\n+\tSHT_HIUSER         SectionType = 0xffffffff /* specific indexes */\n )\n \n var shtStrings = []intName{\n@@ -374,7 +380,12 @@ var shtStrings = []intName{\n \t{17, \"SHT_GROUP\"},\n \t{18, \"SHT_SYMTAB_SHNDX\"},\n \t{0x60000000, \"SHT_LOOS\"},\n-\t{0x6fffffff, \"SHT_HIOS\"},\n+\t{0x6ffffff5, \"SHT_GNU_ATTRIBUTES\"},\n+\t{0x6ffffff6, \"SHT_GNU_HASH\"},\n+\t{0x6ffffff7, \"SHT_GNU_LIBLIST\"},\n+\t{0x6ffffffd, \"SHT_GNU_VERDEF\"},\n+\t{0x6ffffffe, \"SHT_GNU_VERNEED\"},\n+\t{0x6fffffff, \"SHT_GNU_VERSYM\"},\n \t{0x70000000, \"SHT_LOPROC\"},\n \t{0x7fffffff, \"SHT_HIPROC\"},\n \t{0x80000000, \"SHT_LOUSER\"},\n@@ -518,6 +529,9 @@ const (\n \tDT_PREINIT_ARRAYSZ DynTag = 33         /* Size in bytes of the array of pre-initialization functions. */\n \tDT_LOOS            DynTag = 0x6000000d /* First OS-specific */\n \tDT_HIOS            DynTag = 0x6ffff000 /* Last OS-specific */\n+\tDT_VERSYM          DynTag = 0x6ffffff0\n+\tDT_VERNEED         DynTag = 0x6ffffffe\n+\tDT_VERNEEDNUM      DynTag = 0x6fffffff\n \tDT_LOPROC          DynTag = 0x70000000 /* First processor-specific type. */\n \tDT_HIPROC          DynTag = 0x7fffffff /* Last processor-specific type. */\n )\n@@ -559,6 +573,9 @@ var dtStrings = []intName{\n \t{33, \"DT_PREINIT_ARRAYSZ\"},\n \t{0x6000000d, \"DT_LOOS\"},\n \t{0x6ffff000, \"DT_HIOS\"},\n+\t{0x6ffffff0, \"DT_VERSYM\"},\n+\t{0x6ffffffe, \"DT_VERNEED\"},\n+\t{0x6fffffff, \"DT_VERNEEDNUM\"},\n \t{0x70000000, \"DT_LOPROC\"},\n \t{0x7fffffff, \"DT_HIPROC\"},\n }"}, {"sha": "9ae8b413d91f61f223032ebae39d474fb86956f3", "filename": "libgo/go/debug/elf/file.go", "status": "modified", "additions": 125, "deletions": 24, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -35,9 +35,11 @@ type FileHeader struct {\n // A File represents an open ELF file.\n type File struct {\n \tFileHeader\n-\tSections []*Section\n-\tProgs    []*Prog\n-\tcloser   io.Closer\n+\tSections  []*Section\n+\tProgs     []*Prog\n+\tcloser    io.Closer\n+\tgnuNeed   []verneed\n+\tgnuVersym []byte\n }\n \n // A SectionHeader represents a single ELF section header.\n@@ -329,8 +331,8 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {\n }\n \n // getSymbols returns a slice of Symbols from parsing the symbol table\n-// with the given type.\n-func (f *File) getSymbols(typ SectionType) ([]Symbol, os.Error) {\n+// with the given type, along with the associated string table.\n+func (f *File) getSymbols(typ SectionType) ([]Symbol, []byte, os.Error) {\n \tswitch f.Class {\n \tcase ELFCLASS64:\n \t\treturn f.getSymbols64(typ)\n@@ -339,27 +341,27 @@ func (f *File) getSymbols(typ SectionType) ([]Symbol, os.Error) {\n \t\treturn f.getSymbols32(typ)\n \t}\n \n-\treturn nil, os.ErrorString(\"not implemented\")\n+\treturn nil, nil, os.ErrorString(\"not implemented\")\n }\n \n-func (f *File) getSymbols32(typ SectionType) ([]Symbol, os.Error) {\n+func (f *File) getSymbols32(typ SectionType) ([]Symbol, []byte, os.Error) {\n \tsymtabSection := f.SectionByType(typ)\n \tif symtabSection == nil {\n-\t\treturn nil, os.ErrorString(\"no symbol section\")\n+\t\treturn nil, nil, os.ErrorString(\"no symbol section\")\n \t}\n \n \tdata, err := symtabSection.Data()\n \tif err != nil {\n-\t\treturn nil, os.ErrorString(\"cannot load symbol section\")\n+\t\treturn nil, nil, os.ErrorString(\"cannot load symbol section\")\n \t}\n \tsymtab := bytes.NewBuffer(data)\n \tif symtab.Len()%Sym32Size != 0 {\n-\t\treturn nil, os.ErrorString(\"length of symbol section is not a multiple of SymSize\")\n+\t\treturn nil, nil, os.ErrorString(\"length of symbol section is not a multiple of SymSize\")\n \t}\n \n \tstrdata, err := f.stringTable(symtabSection.Link)\n \tif err != nil {\n-\t\treturn nil, os.ErrorString(\"cannot load string table section\")\n+\t\treturn nil, nil, os.ErrorString(\"cannot load string table section\")\n \t}\n \n \t// The first entry is all zeros.\n@@ -382,27 +384,27 @@ func (f *File) getSymbols32(typ SectionType) ([]Symbol, os.Error) {\n \t\ti++\n \t}\n \n-\treturn symbols, nil\n+\treturn symbols, strdata, nil\n }\n \n-func (f *File) getSymbols64(typ SectionType) ([]Symbol, os.Error) {\n+func (f *File) getSymbols64(typ SectionType) ([]Symbol, []byte, os.Error) {\n \tsymtabSection := f.SectionByType(typ)\n \tif symtabSection == nil {\n-\t\treturn nil, os.ErrorString(\"no symbol section\")\n+\t\treturn nil, nil, os.ErrorString(\"no symbol section\")\n \t}\n \n \tdata, err := symtabSection.Data()\n \tif err != nil {\n-\t\treturn nil, os.ErrorString(\"cannot load symbol section\")\n+\t\treturn nil, nil, os.ErrorString(\"cannot load symbol section\")\n \t}\n \tsymtab := bytes.NewBuffer(data)\n \tif symtab.Len()%Sym64Size != 0 {\n-\t\treturn nil, os.ErrorString(\"length of symbol section is not a multiple of Sym64Size\")\n+\t\treturn nil, nil, os.ErrorString(\"length of symbol section is not a multiple of Sym64Size\")\n \t}\n \n \tstrdata, err := f.stringTable(symtabSection.Link)\n \tif err != nil {\n-\t\treturn nil, os.ErrorString(\"cannot load string table section\")\n+\t\treturn nil, nil, os.ErrorString(\"cannot load string table section\")\n \t}\n \n \t// The first entry is all zeros.\n@@ -425,7 +427,7 @@ func (f *File) getSymbols64(typ SectionType) ([]Symbol, os.Error) {\n \t\ti++\n \t}\n \n-\treturn symbols, nil\n+\treturn symbols, strdata, nil\n }\n \n // getString extracts a string from an ELF string table.\n@@ -468,7 +470,7 @@ func (f *File) applyRelocationsAMD64(dst []byte, rels []byte) os.Error {\n \t\treturn os.ErrorString(\"length of relocation section is not a multiple of Sym64Size\")\n \t}\n \n-\tsymbols, err := f.getSymbols(SHT_SYMTAB)\n+\tsymbols, _, err := f.getSymbols(SHT_SYMTAB)\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -544,24 +546,123 @@ func (f *File) DWARF() (*dwarf.Data, os.Error) {\n \treturn dwarf.New(abbrev, nil, nil, info, nil, nil, nil, str)\n }\n \n+type ImportedSymbol struct {\n+\tName    string\n+\tVersion string\n+\tLibrary string\n+}\n+\n // ImportedSymbols returns the names of all symbols\n // referred to by the binary f that are expected to be\n // satisfied by other libraries at dynamic load time.\n // It does not return weak symbols.\n-func (f *File) ImportedSymbols() ([]string, os.Error) {\n-\tsym, err := f.getSymbols(SHT_DYNSYM)\n+func (f *File) ImportedSymbols() ([]ImportedSymbol, os.Error) {\n+\tsym, str, err := f.getSymbols(SHT_DYNSYM)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\tvar all []string\n-\tfor _, s := range sym {\n+\tf.gnuVersionInit(str)\n+\tvar all []ImportedSymbol\n+\tfor i, s := range sym {\n \t\tif ST_BIND(s.Info) == STB_GLOBAL && s.Section == SHN_UNDEF {\n-\t\t\tall = append(all, s.Name)\n+\t\t\tall = append(all, ImportedSymbol{Name: s.Name})\n+\t\t\tf.gnuVersion(i, &all[len(all)-1])\n \t\t}\n \t}\n \treturn all, nil\n }\n \n+type verneed struct {\n+\tFile string\n+\tName string\n+}\n+\n+// gnuVersionInit parses the GNU version tables\n+// for use by calls to gnuVersion.\n+func (f *File) gnuVersionInit(str []byte) {\n+\t// Accumulate verneed information.\n+\tvn := f.SectionByType(SHT_GNU_VERNEED)\n+\tif vn == nil {\n+\t\treturn\n+\t}\n+\td, _ := vn.Data()\n+\n+\tvar need []verneed\n+\ti := 0\n+\tfor {\n+\t\tif i+16 > len(d) {\n+\t\t\tbreak\n+\t\t}\n+\t\tvers := f.ByteOrder.Uint16(d[i : i+2])\n+\t\tif vers != 1 {\n+\t\t\tbreak\n+\t\t}\n+\t\tcnt := f.ByteOrder.Uint16(d[i+2 : i+4])\n+\t\tfileoff := f.ByteOrder.Uint32(d[i+4 : i+8])\n+\t\taux := f.ByteOrder.Uint32(d[i+8 : i+12])\n+\t\tnext := f.ByteOrder.Uint32(d[i+12 : i+16])\n+\t\tfile, _ := getString(str, int(fileoff))\n+\n+\t\tvar name string\n+\t\tj := i + int(aux)\n+\t\tfor c := 0; c < int(cnt); c++ {\n+\t\t\tif j+16 > len(d) {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\t// hash := f.ByteOrder.Uint32(d[j:j+4])\n+\t\t\t// flags := f.ByteOrder.Uint16(d[j+4:j+6])\n+\t\t\tother := f.ByteOrder.Uint16(d[j+6 : j+8])\n+\t\t\tnameoff := f.ByteOrder.Uint32(d[j+8 : j+12])\n+\t\t\tnext := f.ByteOrder.Uint32(d[j+12 : j+16])\n+\t\t\tname, _ = getString(str, int(nameoff))\n+\t\t\tndx := int(other)\n+\t\t\tif ndx >= len(need) {\n+\t\t\t\ta := make([]verneed, 2*(ndx+1))\n+\t\t\t\tcopy(a, need)\n+\t\t\t\tneed = a\n+\t\t\t}\n+\n+\t\t\tneed[ndx] = verneed{file, name}\n+\t\t\tif next == 0 {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tj += int(next)\n+\t\t}\n+\n+\t\tif next == 0 {\n+\t\t\tbreak\n+\t\t}\n+\t\ti += int(next)\n+\t}\n+\n+\t// Versym parallels symbol table, indexing into verneed.\n+\tvs := f.SectionByType(SHT_GNU_VERSYM)\n+\tif vs == nil {\n+\t\treturn\n+\t}\n+\td, _ = vs.Data()\n+\n+\tf.gnuNeed = need\n+\tf.gnuVersym = d\n+}\n+\n+// gnuVersion adds Library and Version information to sym,\n+// which came from offset i of the symbol table.\n+func (f *File) gnuVersion(i int, sym *ImportedSymbol) {\n+\t// Each entry is two bytes; skip undef entry at beginning.\n+\ti = (i + 1) * 2\n+\tif i >= len(f.gnuVersym) {\n+\t\treturn\n+\t}\n+\tj := int(f.ByteOrder.Uint16(f.gnuVersym[i:]))\n+\tif j < 2 || j >= len(f.gnuNeed) {\n+\t\treturn\n+\t}\n+\tn := &f.gnuNeed[j]\n+\tsym.Library = n.File\n+\tsym.Version = n.Name\n+}\n+\n // ImportedLibraries returns the names of all libraries\n // referred to by the binary f that are expected to be\n // linked with the binary at dynamic link time."}, {"sha": "7918c4593bbaa1203b3a90086078301f9dbe9962", "filename": "libgo/go/ebnf/ebnf.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Febnf%2Febnf.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Febnf%2Febnf.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Febnf%2Febnf.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,8 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// A library for EBNF grammars. The input is text ([]byte) satisfying\n-// the following grammar (represented itself in EBNF):\n+// Package ebnf is a library for EBNF grammars. The input is text ([]byte)\n+// satisfying the following grammar (represented itself in EBNF):\n //\n //\tProduction  = name \"=\" Expression \".\" .\n //\tExpression  = Alternative { \"|\" Alternative } ."}, {"sha": "a01d0e024642166391964747a8507380e4afba69", "filename": "libgo/go/encoding/binary/binary.go", "status": "modified", "additions": 76, "deletions": 90, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -126,10 +126,10 @@ func (bigEndian) GoString() string { return \"binary.BigEndian\" }\n // and written to successive fields of the data.\n func Read(r io.Reader, order ByteOrder, data interface{}) os.Error {\n \tvar v reflect.Value\n-\tswitch d := reflect.NewValue(data).(type) {\n-\tcase *reflect.PtrValue:\n+\tswitch d := reflect.ValueOf(data); d.Kind() {\n+\tcase reflect.Ptr:\n \t\tv = d.Elem()\n-\tcase *reflect.SliceValue:\n+\tcase reflect.Slice:\n \t\tv = d\n \tdefault:\n \t\treturn os.NewError(\"binary.Read: invalid type \" + d.Type().String())\n@@ -155,7 +155,7 @@ func Read(r io.Reader, order ByteOrder, data interface{}) os.Error {\n // Bytes written to w are encoded using the specified byte order\n // and read from successive fields of the data.\n func Write(w io.Writer, order ByteOrder, data interface{}) os.Error {\n-\tv := reflect.Indirect(reflect.NewValue(data))\n+\tv := reflect.Indirect(reflect.ValueOf(data))\n \tsize := TotalSize(v)\n \tif size < 0 {\n \t\treturn os.NewError(\"binary.Write: invalid type \" + v.Type().String())\n@@ -168,26 +168,26 @@ func Write(w io.Writer, order ByteOrder, data interface{}) os.Error {\n }\n \n func TotalSize(v reflect.Value) int {\n-\tif sv, ok := v.(*reflect.SliceValue); ok {\n-\t\telem := sizeof(v.Type().(*reflect.SliceType).Elem())\n+\tif v.Kind() == reflect.Slice {\n+\t\telem := sizeof(v.Type().Elem())\n \t\tif elem < 0 {\n \t\t\treturn -1\n \t\t}\n-\t\treturn sv.Len() * elem\n+\t\treturn v.Len() * elem\n \t}\n \treturn sizeof(v.Type())\n }\n \n-func sizeof(v reflect.Type) int {\n-\tswitch t := v.(type) {\n-\tcase *reflect.ArrayType:\n+func sizeof(t reflect.Type) int {\n+\tswitch t.Kind() {\n+\tcase reflect.Array:\n \t\tn := sizeof(t.Elem())\n \t\tif n < 0 {\n \t\t\treturn -1\n \t\t}\n \t\treturn t.Len() * n\n \n-\tcase *reflect.StructType:\n+\tcase reflect.Struct:\n \t\tsum := 0\n \t\tfor i, n := 0, t.NumField(); i < n; i++ {\n \t\t\ts := sizeof(t.Field(i).Type)\n@@ -198,12 +198,10 @@ func sizeof(v reflect.Type) int {\n \t\t}\n \t\treturn sum\n \n-\tcase *reflect.UintType, *reflect.IntType, *reflect.FloatType, *reflect.ComplexType:\n-\t\tswitch t := t.Kind(); t {\n-\t\tcase reflect.Int, reflect.Uint, reflect.Uintptr:\n-\t\t\treturn -1\n-\t\t}\n-\t\treturn int(v.Size())\n+\tcase reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,\n+\t\treflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,\n+\t\treflect.Float32, reflect.Float64, reflect.Complex64, reflect.Complex128:\n+\t\treturn int(t.Size())\n \t}\n \treturn -1\n }\n@@ -279,130 +277,118 @@ func (d *decoder) int64() int64 { return int64(d.uint64()) }\n func (e *encoder) int64(x int64) { e.uint64(uint64(x)) }\n \n func (d *decoder) value(v reflect.Value) {\n-\tswitch v := v.(type) {\n-\tcase *reflect.ArrayValue:\n+\tswitch v.Kind() {\n+\tcase reflect.Array:\n \t\tl := v.Len()\n \t\tfor i := 0; i < l; i++ {\n-\t\t\td.value(v.Elem(i))\n+\t\t\td.value(v.Index(i))\n \t\t}\n-\tcase *reflect.StructValue:\n+\tcase reflect.Struct:\n \t\tl := v.NumField()\n \t\tfor i := 0; i < l; i++ {\n \t\t\td.value(v.Field(i))\n \t\t}\n \n-\tcase *reflect.SliceValue:\n+\tcase reflect.Slice:\n \t\tl := v.Len()\n \t\tfor i := 0; i < l; i++ {\n-\t\t\td.value(v.Elem(i))\n+\t\t\td.value(v.Index(i))\n \t\t}\n \n-\tcase *reflect.IntValue:\n-\t\tswitch v.Type().Kind() {\n-\t\tcase reflect.Int8:\n-\t\t\tv.Set(int64(d.int8()))\n-\t\tcase reflect.Int16:\n-\t\t\tv.Set(int64(d.int16()))\n-\t\tcase reflect.Int32:\n-\t\t\tv.Set(int64(d.int32()))\n-\t\tcase reflect.Int64:\n-\t\t\tv.Set(d.int64())\n-\t\t}\n-\n-\tcase *reflect.UintValue:\n-\t\tswitch v.Type().Kind() {\n-\t\tcase reflect.Uint8:\n-\t\t\tv.Set(uint64(d.uint8()))\n-\t\tcase reflect.Uint16:\n-\t\t\tv.Set(uint64(d.uint16()))\n-\t\tcase reflect.Uint32:\n-\t\t\tv.Set(uint64(d.uint32()))\n-\t\tcase reflect.Uint64:\n-\t\t\tv.Set(d.uint64())\n-\t\t}\n-\n-\tcase *reflect.FloatValue:\n-\t\tswitch v.Type().Kind() {\n-\t\tcase reflect.Float32:\n-\t\t\tv.Set(float64(math.Float32frombits(d.uint32())))\n-\t\tcase reflect.Float64:\n-\t\t\tv.Set(math.Float64frombits(d.uint64()))\n-\t\t}\n-\n-\tcase *reflect.ComplexValue:\n-\t\tswitch v.Type().Kind() {\n-\t\tcase reflect.Complex64:\n-\t\t\tv.Set(complex(\n-\t\t\t\tfloat64(math.Float32frombits(d.uint32())),\n-\t\t\t\tfloat64(math.Float32frombits(d.uint32())),\n-\t\t\t))\n-\t\tcase reflect.Complex128:\n-\t\t\tv.Set(complex(\n-\t\t\t\tmath.Float64frombits(d.uint64()),\n-\t\t\t\tmath.Float64frombits(d.uint64()),\n-\t\t\t))\n-\t\t}\n+\tcase reflect.Int8:\n+\t\tv.SetInt(int64(d.int8()))\n+\tcase reflect.Int16:\n+\t\tv.SetInt(int64(d.int16()))\n+\tcase reflect.Int32:\n+\t\tv.SetInt(int64(d.int32()))\n+\tcase reflect.Int64:\n+\t\tv.SetInt(d.int64())\n+\n+\tcase reflect.Uint8:\n+\t\tv.SetUint(uint64(d.uint8()))\n+\tcase reflect.Uint16:\n+\t\tv.SetUint(uint64(d.uint16()))\n+\tcase reflect.Uint32:\n+\t\tv.SetUint(uint64(d.uint32()))\n+\tcase reflect.Uint64:\n+\t\tv.SetUint(d.uint64())\n+\n+\tcase reflect.Float32:\n+\t\tv.SetFloat(float64(math.Float32frombits(d.uint32())))\n+\tcase reflect.Float64:\n+\t\tv.SetFloat(math.Float64frombits(d.uint64()))\n+\n+\tcase reflect.Complex64:\n+\t\tv.SetComplex(complex(\n+\t\t\tfloat64(math.Float32frombits(d.uint32())),\n+\t\t\tfloat64(math.Float32frombits(d.uint32())),\n+\t\t))\n+\tcase reflect.Complex128:\n+\t\tv.SetComplex(complex(\n+\t\t\tmath.Float64frombits(d.uint64()),\n+\t\t\tmath.Float64frombits(d.uint64()),\n+\t\t))\n \t}\n }\n \n func (e *encoder) value(v reflect.Value) {\n-\tswitch v := v.(type) {\n-\tcase *reflect.ArrayValue:\n+\tswitch v.Kind() {\n+\tcase reflect.Array:\n \t\tl := v.Len()\n \t\tfor i := 0; i < l; i++ {\n-\t\t\te.value(v.Elem(i))\n+\t\t\te.value(v.Index(i))\n \t\t}\n-\tcase *reflect.StructValue:\n+\tcase reflect.Struct:\n \t\tl := v.NumField()\n \t\tfor i := 0; i < l; i++ {\n \t\t\te.value(v.Field(i))\n \t\t}\n-\tcase *reflect.SliceValue:\n+\tcase reflect.Slice:\n \t\tl := v.Len()\n \t\tfor i := 0; i < l; i++ {\n-\t\t\te.value(v.Elem(i))\n+\t\t\te.value(v.Index(i))\n \t\t}\n \n-\tcase *reflect.IntValue:\n+\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n \t\tswitch v.Type().Kind() {\n \t\tcase reflect.Int8:\n-\t\t\te.int8(int8(v.Get()))\n+\t\t\te.int8(int8(v.Int()))\n \t\tcase reflect.Int16:\n-\t\t\te.int16(int16(v.Get()))\n+\t\t\te.int16(int16(v.Int()))\n \t\tcase reflect.Int32:\n-\t\t\te.int32(int32(v.Get()))\n+\t\t\te.int32(int32(v.Int()))\n \t\tcase reflect.Int64:\n-\t\t\te.int64(v.Get())\n+\t\t\te.int64(v.Int())\n \t\t}\n \n-\tcase *reflect.UintValue:\n+\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n \t\tswitch v.Type().Kind() {\n \t\tcase reflect.Uint8:\n-\t\t\te.uint8(uint8(v.Get()))\n+\t\t\te.uint8(uint8(v.Uint()))\n \t\tcase reflect.Uint16:\n-\t\t\te.uint16(uint16(v.Get()))\n+\t\t\te.uint16(uint16(v.Uint()))\n \t\tcase reflect.Uint32:\n-\t\t\te.uint32(uint32(v.Get()))\n+\t\t\te.uint32(uint32(v.Uint()))\n \t\tcase reflect.Uint64:\n-\t\t\te.uint64(v.Get())\n+\t\t\te.uint64(v.Uint())\n \t\t}\n \n-\tcase *reflect.FloatValue:\n+\tcase reflect.Float32, reflect.Float64:\n \t\tswitch v.Type().Kind() {\n \t\tcase reflect.Float32:\n-\t\t\te.uint32(math.Float32bits(float32(v.Get())))\n+\t\t\te.uint32(math.Float32bits(float32(v.Float())))\n \t\tcase reflect.Float64:\n-\t\t\te.uint64(math.Float64bits(v.Get()))\n+\t\t\te.uint64(math.Float64bits(v.Float()))\n \t\t}\n \n-\tcase *reflect.ComplexValue:\n+\tcase reflect.Complex64, reflect.Complex128:\n \t\tswitch v.Type().Kind() {\n \t\tcase reflect.Complex64:\n-\t\t\tx := v.Get()\n+\t\t\tx := v.Complex()\n \t\t\te.uint32(math.Float32bits(float32(real(x))))\n \t\t\te.uint32(math.Float32bits(float32(imag(x))))\n \t\tcase reflect.Complex128:\n-\t\t\tx := v.Get()\n+\t\t\tx := v.Complex()\n \t\t\te.uint64(math.Float64bits(real(x)))\n \t\t\te.uint64(math.Float64bits(imag(x)))\n \t\t}"}, {"sha": "7857c68d36e009ec837ba3d22615c7f91f2ce13f", "filename": "libgo/go/encoding/binary/binary_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -152,7 +152,7 @@ func TestWriteT(t *testing.T) {\n \t\tt.Errorf(\"WriteT: have nil, want non-nil\")\n \t}\n \n-\ttv := reflect.Indirect(reflect.NewValue(ts)).(*reflect.StructValue)\n+\ttv := reflect.Indirect(reflect.ValueOf(ts))\n \tfor i, n := 0, tv.NumField(); i < n; i++ {\n \t\terr = Write(buf, BigEndian, tv.Field(i).Interface())\n \t\tif err == nil {"}, {"sha": "891de1861077d17f342568144a320ede00dd3e45", "filename": "libgo/go/encoding/hex/hex.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fencoding%2Fhex%2Fhex.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fencoding%2Fhex%2Fhex.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fhex%2Fhex.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This package implements hexadecimal encoding and decoding.\n+// Package hex implements hexadecimal encoding and decoding.\n package hex\n \n import ("}, {"sha": "123962b1f917998fda722a48ba32a22bb2860b82", "filename": "libgo/go/encoding/line/line.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fencoding%2Fline%2Fline.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fencoding%2Fline%2Fline.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fline%2Fline.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,7 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// The line package implements a Reader that reads lines delimited by '\\n' or ' \\r\\n'.\n+// Package line implements a Reader that reads lines delimited by '\\n' or\n+// ' \\r\\n'.\n package line\n \n import ("}, {"sha": "44e3d0ad0949e9ee98da0216edccad246b6adb88", "filename": "libgo/go/encoding/pem/pem.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fencoding%2Fpem%2Fpem.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fencoding%2Fpem%2Fpem.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fpem%2Fpem.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This package implements the PEM data encoding, which originated in Privacy\n+// Package pem implements the PEM data encoding, which originated in Privacy\n // Enhanced Mail. The most common use of PEM encoding today is in TLS keys and\n // certificates. See RFC 1421.\n package pem"}, {"sha": "043f847283e6d1c57299987c7c3e8584240ff4a5", "filename": "libgo/go/exec/exec.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fexec%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fexec%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexec%2Fexec.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,9 +2,9 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// The exec package runs external commands. It wraps os.StartProcess\n-// to make it easier to remap stdin and stdout, connect I/O with pipes,\n-// and do other adjustments.\n+// Package exec runs external commands. It wraps os.StartProcess to make it\n+// easier to remap stdin and stdout, connect I/O with pipes, and do other\n+// adjustments.\n package exec\n \n // BUG(r): This package should be made even easier to use or merged into os."}, {"sha": "eb8cd5fec9f489ba1723fe1bf9cdf8a7c1ce5474", "filename": "libgo/go/exec/exec_test.go", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fexec%2Fexec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fexec%2Fexec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexec%2Fexec_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -9,19 +9,14 @@ import (\n \t\"io/ioutil\"\n \t\"testing\"\n \t\"os\"\n-\t\"runtime\"\n )\n \n func run(argv []string, stdin, stdout, stderr int) (p *Cmd, err os.Error) {\n-\tif runtime.GOOS == \"windows\" {\n-\t\targv = append([]string{\"cmd\", \"/c\"}, argv...)\n-\t}\n \texe, err := LookPath(argv[0])\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\tp, err = Run(exe, argv, nil, \"\", stdin, stdout, stderr)\n-\treturn p, err\n+\treturn Run(exe, argv, nil, \"\", stdin, stdout, stderr)\n }\n \n func TestRunCat(t *testing.T) {"}, {"sha": "a8efdc58fe9ec1759818334f76624d6d141b51cf", "filename": "libgo/go/exp/datafmt/datafmt.go", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fexp%2Fdatafmt%2Fdatafmt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fexp%2Fdatafmt%2Fdatafmt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fdatafmt%2Fdatafmt.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-/*\tThe datafmt package implements syntax-directed, type-driven formatting\n+/*\tPackage datafmt implements syntax-directed, type-driven formatting\n \tof arbitrary data structures. Formatting a data structure consists of\n \ttwo phases: first, a parser reads a format specification and builds a\n \t\"compiled\" format. Then, the format can be applied repeatedly to\n@@ -408,20 +408,20 @@ func (s *State) error(msg string) {\n //\n \n func typename(typ reflect.Type) string {\n-\tswitch typ.(type) {\n-\tcase *reflect.ArrayType:\n+\tswitch typ.Kind() {\n+\tcase reflect.Array:\n \t\treturn \"array\"\n-\tcase *reflect.SliceType:\n+\tcase reflect.Slice:\n \t\treturn \"array\"\n-\tcase *reflect.ChanType:\n+\tcase reflect.Chan:\n \t\treturn \"chan\"\n-\tcase *reflect.FuncType:\n+\tcase reflect.Func:\n \t\treturn \"func\"\n-\tcase *reflect.InterfaceType:\n+\tcase reflect.Interface:\n \t\treturn \"interface\"\n-\tcase *reflect.MapType:\n+\tcase reflect.Map:\n \t\treturn \"map\"\n-\tcase *reflect.PtrType:\n+\tcase reflect.Ptr:\n \t\treturn \"ptr\"\n \t}\n \treturn typ.String()\n@@ -519,38 +519,38 @@ func (s *State) eval(fexpr expr, value reflect.Value, index int) bool {\n \n \t\tcase \"*\":\n \t\t\t// indirection: operation is type-specific\n-\t\t\tswitch v := value.(type) {\n-\t\t\tcase *reflect.ArrayValue:\n+\t\t\tswitch v := value; v.Kind() {\n+\t\t\tcase reflect.Array:\n \t\t\t\tif v.Len() <= index {\n \t\t\t\t\treturn false\n \t\t\t\t}\n-\t\t\t\tvalue = v.Elem(index)\n+\t\t\t\tvalue = v.Index(index)\n \n-\t\t\tcase *reflect.SliceValue:\n+\t\t\tcase reflect.Slice:\n \t\t\t\tif v.IsNil() || v.Len() <= index {\n \t\t\t\t\treturn false\n \t\t\t\t}\n-\t\t\t\tvalue = v.Elem(index)\n+\t\t\t\tvalue = v.Index(index)\n \n-\t\t\tcase *reflect.MapValue:\n+\t\t\tcase reflect.Map:\n \t\t\t\ts.error(\"reflection support for maps incomplete\")\n \n-\t\t\tcase *reflect.PtrValue:\n+\t\t\tcase reflect.Ptr:\n \t\t\t\tif v.IsNil() {\n \t\t\t\t\treturn false\n \t\t\t\t}\n \t\t\t\tvalue = v.Elem()\n \n-\t\t\tcase *reflect.InterfaceValue:\n+\t\t\tcase reflect.Interface:\n \t\t\t\tif v.IsNil() {\n \t\t\t\t\treturn false\n \t\t\t\t}\n \t\t\t\tvalue = v.Elem()\n \n-\t\t\tcase *reflect.ChanValue:\n+\t\t\tcase reflect.Chan:\n \t\t\t\ts.error(\"reflection support for chans incomplete\")\n \n-\t\t\tcase *reflect.FuncValue:\n+\t\t\tcase reflect.Func:\n \t\t\t\ts.error(\"reflection support for funcs incomplete\")\n \n \t\t\tdefault:\n@@ -560,9 +560,9 @@ func (s *State) eval(fexpr expr, value reflect.Value, index int) bool {\n \t\tdefault:\n \t\t\t// value is value of named field\n \t\t\tvar field reflect.Value\n-\t\t\tif sval, ok := value.(*reflect.StructValue); ok {\n+\t\t\tif sval := value; sval.Kind() == reflect.Struct {\n \t\t\t\tfield = sval.FieldByName(t.fieldName)\n-\t\t\t\tif field == nil {\n+\t\t\t\tif !field.IsValid() {\n \t\t\t\t\t// TODO consider just returning false in this case\n \t\t\t\t\ts.error(fmt.Sprintf(\"error: no field `%s` in `%s`\", t.fieldName, value.Type()))\n \t\t\t\t}\n@@ -671,8 +671,8 @@ func (f Format) Eval(env Environment, args ...interface{}) ([]byte, os.Error) {\n \n \tgo func() {\n \t\tfor _, v := range args {\n-\t\t\tfld := reflect.NewValue(v)\n-\t\t\tif fld == nil {\n+\t\t\tfld := reflect.ValueOf(v)\n+\t\t\tif !fld.IsValid() {\n \t\t\t\terrors <- os.NewError(\"nil argument\")\n \t\t\t\treturn\n \t\t\t}"}, {"sha": "f98e24618946602a325d14d45991c385bac8e718", "filename": "libgo/go/exp/draw/draw.go", "status": "modified", "additions": 121, "deletions": 8, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fexp%2Fdraw%2Fdraw.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fexp%2Fdraw%2Fdraw.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fdraw%2Fdraw.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -8,7 +8,10 @@\n // and the X Render extension.\n package draw\n \n-import \"image\"\n+import (\n+\t\"image\"\n+\t\"image/ycbcr\"\n+)\n \n // m is the maximum color value returned by image.Color.RGBA.\n const m = 1<<16 - 1\n@@ -65,29 +68,42 @@ func DrawMask(dst Image, r image.Rectangle, src image.Image, sp image.Point, mas\n \tif dst0, ok := dst.(*image.RGBA); ok {\n \t\tif op == Over {\n \t\t\tif mask == nil {\n-\t\t\t\tif src0, ok := src.(*image.ColorImage); ok {\n+\t\t\t\tswitch src0 := src.(type) {\n+\t\t\t\tcase *image.ColorImage:\n \t\t\t\t\tdrawFillOver(dst0, r, src0)\n \t\t\t\t\treturn\n-\t\t\t\t}\n-\t\t\t\tif src0, ok := src.(*image.RGBA); ok {\n+\t\t\t\tcase *image.RGBA:\n \t\t\t\t\tdrawCopyOver(dst0, r, src0, sp)\n \t\t\t\t\treturn\n+\t\t\t\tcase *image.NRGBA:\n+\t\t\t\t\tdrawNRGBAOver(dst0, r, src0, sp)\n+\t\t\t\t\treturn\n+\t\t\t\tcase *ycbcr.YCbCr:\n+\t\t\t\t\tdrawYCbCr(dst0, r, src0, sp)\n+\t\t\t\t\treturn\n \t\t\t\t}\n \t\t\t} else if mask0, ok := mask.(*image.Alpha); ok {\n-\t\t\t\tif src0, ok := src.(*image.ColorImage); ok {\n+\t\t\t\tswitch src0 := src.(type) {\n+\t\t\t\tcase *image.ColorImage:\n \t\t\t\t\tdrawGlyphOver(dst0, r, src0, mask0, mp)\n \t\t\t\t\treturn\n \t\t\t\t}\n \t\t\t}\n \t\t} else {\n \t\t\tif mask == nil {\n-\t\t\t\tif src0, ok := src.(*image.ColorImage); ok {\n+\t\t\t\tswitch src0 := src.(type) {\n+\t\t\t\tcase *image.ColorImage:\n \t\t\t\t\tdrawFillSrc(dst0, r, src0)\n \t\t\t\t\treturn\n-\t\t\t\t}\n-\t\t\t\tif src0, ok := src.(*image.RGBA); ok {\n+\t\t\t\tcase *image.RGBA:\n \t\t\t\t\tdrawCopySrc(dst0, r, src0, sp)\n \t\t\t\t\treturn\n+\t\t\t\tcase *image.NRGBA:\n+\t\t\t\t\tdrawNRGBASrc(dst0, r, src0, sp)\n+\t\t\t\t\treturn\n+\t\t\t\tcase *ycbcr.YCbCr:\n+\t\t\t\t\tdrawYCbCr(dst0, r, src0, sp)\n+\t\t\t\t\treturn\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -224,6 +240,36 @@ func drawCopyOver(dst *image.RGBA, r image.Rectangle, src *image.RGBA, sp image.\n \t}\n }\n \n+func drawNRGBAOver(dst *image.RGBA, r image.Rectangle, src *image.NRGBA, sp image.Point) {\n+\tfor y, sy := r.Min.Y, sp.Y; y != r.Max.Y; y, sy = y+1, sy+1 {\n+\t\tdpix := dst.Pix[y*dst.Stride : (y+1)*dst.Stride]\n+\t\tspix := src.Pix[sy*src.Stride : (sy+1)*src.Stride]\n+\t\tfor x, sx := r.Min.X, sp.X; x != r.Max.X; x, sx = x+1, sx+1 {\n+\t\t\t// Convert from non-premultiplied color to pre-multiplied color.\n+\t\t\t// The order of operations here is to match the NRGBAColor.RGBA\n+\t\t\t// method in image/color.go.\n+\t\t\tsnrgba := spix[sx]\n+\t\t\tsa := uint32(snrgba.A)\n+\t\t\tsr := uint32(snrgba.R) * 0x101 * sa / 0xff\n+\t\t\tsg := uint32(snrgba.G) * 0x101 * sa / 0xff\n+\t\t\tsb := uint32(snrgba.B) * 0x101 * sa / 0xff\n+\t\t\tsa *= 0x101\n+\n+\t\t\trgba := dpix[x]\n+\t\t\tdr := uint32(rgba.R)\n+\t\t\tdg := uint32(rgba.G)\n+\t\t\tdb := uint32(rgba.B)\n+\t\t\tda := uint32(rgba.A)\n+\t\t\ta := (m - sa) * 0x101\n+\t\t\tdr = (dr*a + sr*m) / m\n+\t\t\tdg = (dg*a + sg*m) / m\n+\t\t\tdb = (db*a + sb*m) / m\n+\t\t\tda = (da*a + sa*m) / m\n+\t\t\tdpix[x] = image.RGBAColor{uint8(dr >> 8), uint8(dg >> 8), uint8(db >> 8), uint8(da >> 8)}\n+\t\t}\n+\t}\n+}\n+\n func drawGlyphOver(dst *image.RGBA, r image.Rectangle, src *image.ColorImage, mask *image.Alpha, mp image.Point) {\n \tx0, x1 := r.Min.X, r.Max.X\n \ty0, y1 := r.Min.Y, r.Max.Y\n@@ -311,6 +357,73 @@ func drawCopySrc(dst *image.RGBA, r image.Rectangle, src *image.RGBA, sp image.P\n \t}\n }\n \n+func drawNRGBASrc(dst *image.RGBA, r image.Rectangle, src *image.NRGBA, sp image.Point) {\n+\tfor y, sy := r.Min.Y, sp.Y; y != r.Max.Y; y, sy = y+1, sy+1 {\n+\t\tdpix := dst.Pix[y*dst.Stride : (y+1)*dst.Stride]\n+\t\tspix := src.Pix[sy*src.Stride : (sy+1)*src.Stride]\n+\t\tfor x, sx := r.Min.X, sp.X; x != r.Max.X; x, sx = x+1, sx+1 {\n+\t\t\t// Convert from non-premultiplied color to pre-multiplied color.\n+\t\t\t// The order of operations here is to match the NRGBAColor.RGBA\n+\t\t\t// method in image/color.go.\n+\t\t\tsnrgba := spix[sx]\n+\t\t\tsa := uint32(snrgba.A)\n+\t\t\tsr := uint32(snrgba.R) * 0x101 * sa / 0xff\n+\t\t\tsg := uint32(snrgba.G) * 0x101 * sa / 0xff\n+\t\t\tsb := uint32(snrgba.B) * 0x101 * sa / 0xff\n+\t\t\tsa *= 0x101\n+\n+\t\t\tdpix[x] = image.RGBAColor{uint8(sr >> 8), uint8(sg >> 8), uint8(sb >> 8), uint8(sa >> 8)}\n+\t\t}\n+\t}\n+}\n+\n+func drawYCbCr(dst *image.RGBA, r image.Rectangle, src *ycbcr.YCbCr, sp image.Point) {\n+\t// A YCbCr image is always fully opaque, and so if the mask is implicitly nil\n+\t// (i.e. fully opaque) then the op is effectively always Src.\n+\tvar (\n+\t\tyy, cb, cr uint8\n+\t\trr, gg, bb uint8\n+\t)\n+\tswitch src.SubsampleRatio {\n+\tcase ycbcr.SubsampleRatio422:\n+\t\tfor y, sy := r.Min.Y, sp.Y; y != r.Max.Y; y, sy = y+1, sy+1 {\n+\t\t\tdpix := dst.Pix[y*dst.Stride : (y+1)*dst.Stride]\n+\t\t\tfor x, sx := r.Min.X, sp.X; x != r.Max.X; x, sx = x+1, sx+1 {\n+\t\t\t\ti := sx / 2\n+\t\t\t\tyy = src.Y[sy*src.YStride+sx]\n+\t\t\t\tcb = src.Cb[sy*src.CStride+i]\n+\t\t\t\tcr = src.Cr[sy*src.CStride+i]\n+\t\t\t\trr, gg, bb = ycbcr.YCbCrToRGB(yy, cb, cr)\n+\t\t\t\tdpix[x] = image.RGBAColor{rr, gg, bb, 255}\n+\t\t\t}\n+\t\t}\n+\tcase ycbcr.SubsampleRatio420:\n+\t\tfor y, sy := r.Min.Y, sp.Y; y != r.Max.Y; y, sy = y+1, sy+1 {\n+\t\t\tdpix := dst.Pix[y*dst.Stride : (y+1)*dst.Stride]\n+\t\t\tfor x, sx := r.Min.X, sp.X; x != r.Max.X; x, sx = x+1, sx+1 {\n+\t\t\t\ti, j := sx/2, sy/2\n+\t\t\t\tyy = src.Y[sy*src.YStride+sx]\n+\t\t\t\tcb = src.Cb[j*src.CStride+i]\n+\t\t\t\tcr = src.Cr[j*src.CStride+i]\n+\t\t\t\trr, gg, bb = ycbcr.YCbCrToRGB(yy, cb, cr)\n+\t\t\t\tdpix[x] = image.RGBAColor{rr, gg, bb, 255}\n+\t\t\t}\n+\t\t}\n+\tdefault:\n+\t\t// Default to 4:4:4 subsampling.\n+\t\tfor y, sy := r.Min.Y, sp.Y; y != r.Max.Y; y, sy = y+1, sy+1 {\n+\t\t\tdpix := dst.Pix[y*dst.Stride : (y+1)*dst.Stride]\n+\t\t\tfor x, sx := r.Min.X, sp.X; x != r.Max.X; x, sx = x+1, sx+1 {\n+\t\t\t\tyy = src.Y[sy*src.YStride+sx]\n+\t\t\t\tcb = src.Cb[sy*src.CStride+sx]\n+\t\t\t\tcr = src.Cr[sy*src.CStride+sx]\n+\t\t\t\trr, gg, bb = ycbcr.YCbCrToRGB(yy, cb, cr)\n+\t\t\t\tdpix[x] = image.RGBAColor{rr, gg, bb, 255}\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n func drawRGBA(dst *image.RGBA, r image.Rectangle, src image.Image, sp image.Point, mask image.Image, mp image.Point, op Op) {\n \tx0, x1, dx := r.Min.X, r.Max.X, 1\n \ty0, y1, dy := r.Min.Y, r.Max.Y, 1"}, {"sha": "873a2f24a40bedf26c69e2900d4d1fdd53d8b216", "filename": "libgo/go/exp/draw/draw_test.go", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fexp%2Fdraw%2Fdraw_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fexp%2Fdraw%2Fdraw_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fdraw%2Fdraw_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -6,6 +6,7 @@ package draw\n \n import (\n \t\"image\"\n+\t\"image/ycbcr\"\n \t\"testing\"\n )\n \n@@ -43,6 +44,34 @@ func vgradAlpha(alpha int) image.Image {\n \treturn m\n }\n \n+func vgradGreenNRGBA(alpha int) image.Image {\n+\tm := image.NewNRGBA(16, 16)\n+\tfor y := 0; y < 16; y++ {\n+\t\tfor x := 0; x < 16; x++ {\n+\t\t\tm.Set(x, y, image.RGBAColor{0, uint8(y * 0x11), 0, uint8(alpha)})\n+\t\t}\n+\t}\n+\treturn m\n+}\n+\n+func vgradCr() image.Image {\n+\tm := &ycbcr.YCbCr{\n+\t\tY:              make([]byte, 16*16),\n+\t\tCb:             make([]byte, 16*16),\n+\t\tCr:             make([]byte, 16*16),\n+\t\tYStride:        16,\n+\t\tCStride:        16,\n+\t\tSubsampleRatio: ycbcr.SubsampleRatio444,\n+\t\tRect:           image.Rect(0, 0, 16, 16),\n+\t}\n+\tfor y := 0; y < 16; y++ {\n+\t\tfor x := 0; x < 16; x++ {\n+\t\t\tm.Cr[y*m.CStride+x] = uint8(y * 0x11)\n+\t\t}\n+\t}\n+\treturn m\n+}\n+\n func hgradRed(alpha int) Image {\n \tm := image.NewRGBA(16, 16)\n \tfor y := 0; y < 16; y++ {\n@@ -95,6 +124,27 @@ var drawTests = []drawTest{\n \t{\"copyAlphaSrc\", vgradGreen(90), fillAlpha(192), Src, image.RGBAColor{0, 36, 0, 68}},\n \t{\"copyNil\", vgradGreen(90), nil, Over, image.RGBAColor{88, 48, 0, 255}},\n \t{\"copyNilSrc\", vgradGreen(90), nil, Src, image.RGBAColor{0, 48, 0, 90}},\n+\t// Uniform mask (100%, 75%, nil) and variable NRGBA source.\n+\t// At (x, y) == (8, 8):\n+\t// The destination pixel is {136, 0, 0, 255}.\n+\t// The source pixel is {0, 136, 0, 90} in NRGBA-space, which is {0, 48, 0, 90} in RGBA-space.\n+\t// The result pixel is different than in the \"copy*\" test cases because of rounding errors.\n+\t{\"nrgba\", vgradGreenNRGBA(90), fillAlpha(255), Over, image.RGBAColor{88, 46, 0, 255}},\n+\t{\"nrgbaSrc\", vgradGreenNRGBA(90), fillAlpha(255), Src, image.RGBAColor{0, 46, 0, 90}},\n+\t{\"nrgbaAlpha\", vgradGreenNRGBA(90), fillAlpha(192), Over, image.RGBAColor{100, 34, 0, 255}},\n+\t{\"nrgbaAlphaSrc\", vgradGreenNRGBA(90), fillAlpha(192), Src, image.RGBAColor{0, 34, 0, 68}},\n+\t{\"nrgbaNil\", vgradGreenNRGBA(90), nil, Over, image.RGBAColor{88, 46, 0, 255}},\n+\t{\"nrgbaNilSrc\", vgradGreenNRGBA(90), nil, Src, image.RGBAColor{0, 46, 0, 90}},\n+\t// Uniform mask (100%, 75%, nil) and variable YCbCr source.\n+\t// At (x, y) == (8, 8):\n+\t// The destination pixel is {136, 0, 0, 255}.\n+\t// The source pixel is {0, 0, 136} in YCbCr-space, which is {11, 38, 0, 255} in RGB-space.\n+\t{\"ycbcr\", vgradCr(), fillAlpha(255), Over, image.RGBAColor{11, 38, 0, 255}},\n+\t{\"ycbcrSrc\", vgradCr(), fillAlpha(255), Src, image.RGBAColor{11, 38, 0, 255}},\n+\t{\"ycbcrAlpha\", vgradCr(), fillAlpha(192), Over, image.RGBAColor{42, 28, 0, 255}},\n+\t{\"ycbcrAlphaSrc\", vgradCr(), fillAlpha(192), Src, image.RGBAColor{8, 28, 0, 192}},\n+\t{\"ycbcrNil\", vgradCr(), nil, Over, image.RGBAColor{11, 38, 0, 255}},\n+\t{\"ycbcrNilSrc\", vgradCr(), nil, Src, image.RGBAColor{11, 38, 0, 255}},\n \t// Variable mask and variable source.\n \t// At (x, y) == (8, 8):\n \t// The destination pixel is {136, 0, 0, 255}."}, {"sha": "81c67267db64ebc820fed0588b9db603bd5e19f1", "filename": "libgo/go/exp/draw/x11/conn.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fexp%2Fdraw%2Fx11%2Fconn.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fexp%2Fdraw%2Fx11%2Fconn.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fdraw%2Fx11%2Fconn.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This package implements an X11 backend for the exp/draw package.\n+// Package x11 implements an X11 backend for the exp/draw package.\n //\n // The X protocol specification is at ftp://ftp.x.org/pub/X11R7.0/doc/PDF/proto.pdf.\n // A summary of the wire format can be found in XCB's xproto.xml."}, {"sha": "f31d9ab9bd6e0bcf124dda6e6edbd807ec75639f", "filename": "libgo/go/exp/eval/bridge.go", "status": "modified", "additions": 44, "deletions": 49, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fexp%2Feval%2Fbridge.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fexp%2Feval%2Fbridge.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Feval%2Fbridge.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -34,54 +34,49 @@ func TypeFromNative(t reflect.Type) Type {\n \t}\n \n \tvar et Type\n-\tswitch t := t.(type) {\n-\tcase *reflect.BoolType:\n+\tswitch t.Kind() {\n+\tcase reflect.Bool:\n \t\tet = BoolType\n-\tcase *reflect.FloatType:\n-\t\tswitch t.Kind() {\n-\t\tcase reflect.Float32:\n-\t\t\tet = Float32Type\n-\t\tcase reflect.Float64:\n-\t\t\tet = Float64Type\n-\t\t}\n-\tcase *reflect.IntType:\n-\t\tswitch t.Kind() {\n-\t\tcase reflect.Int16:\n-\t\t\tet = Int16Type\n-\t\tcase reflect.Int32:\n-\t\t\tet = Int32Type\n-\t\tcase reflect.Int64:\n-\t\t\tet = Int64Type\n-\t\tcase reflect.Int8:\n-\t\t\tet = Int8Type\n-\t\tcase reflect.Int:\n-\t\t\tet = IntType\n-\t\t}\n-\tcase *reflect.UintType:\n-\t\tswitch t.Kind() {\n-\t\tcase reflect.Uint16:\n-\t\t\tet = Uint16Type\n-\t\tcase reflect.Uint32:\n-\t\t\tet = Uint32Type\n-\t\tcase reflect.Uint64:\n-\t\t\tet = Uint64Type\n-\t\tcase reflect.Uint8:\n-\t\t\tet = Uint8Type\n-\t\tcase reflect.Uint:\n-\t\t\tet = UintType\n-\t\tcase reflect.Uintptr:\n-\t\t\tet = UintptrType\n-\t\t}\n-\tcase *reflect.StringType:\n+\n+\tcase reflect.Float32:\n+\t\tet = Float32Type\n+\tcase reflect.Float64:\n+\t\tet = Float64Type\n+\n+\tcase reflect.Int16:\n+\t\tet = Int16Type\n+\tcase reflect.Int32:\n+\t\tet = Int32Type\n+\tcase reflect.Int64:\n+\t\tet = Int64Type\n+\tcase reflect.Int8:\n+\t\tet = Int8Type\n+\tcase reflect.Int:\n+\t\tet = IntType\n+\n+\tcase reflect.Uint16:\n+\t\tet = Uint16Type\n+\tcase reflect.Uint32:\n+\t\tet = Uint32Type\n+\tcase reflect.Uint64:\n+\t\tet = Uint64Type\n+\tcase reflect.Uint8:\n+\t\tet = Uint8Type\n+\tcase reflect.Uint:\n+\t\tet = UintType\n+\tcase reflect.Uintptr:\n+\t\tet = UintptrType\n+\n+\tcase reflect.String:\n \t\tet = StringType\n-\tcase *reflect.ArrayType:\n+\tcase reflect.Array:\n \t\tet = NewArrayType(int64(t.Len()), TypeFromNative(t.Elem()))\n-\tcase *reflect.ChanType:\n+\tcase reflect.Chan:\n \t\tlog.Panicf(\"%T not implemented\", t)\n-\tcase *reflect.FuncType:\n+\tcase reflect.Func:\n \t\tnin := t.NumIn()\n \t\t// Variadic functions have DotDotDotType at the end\n-\t\tvariadic := t.DotDotDot()\n+\t\tvariadic := t.IsVariadic()\n \t\tif variadic {\n \t\t\tnin--\n \t\t}\n@@ -94,15 +89,15 @@ func TypeFromNative(t reflect.Type) Type {\n \t\t\tout[i] = TypeFromNative(t.Out(i))\n \t\t}\n \t\tet = NewFuncType(in, variadic, out)\n-\tcase *reflect.InterfaceType:\n+\tcase reflect.Interface:\n \t\tlog.Panicf(\"%T not implemented\", t)\n-\tcase *reflect.MapType:\n+\tcase reflect.Map:\n \t\tlog.Panicf(\"%T not implemented\", t)\n-\tcase *reflect.PtrType:\n+\tcase reflect.Ptr:\n \t\tet = NewPtrType(TypeFromNative(t.Elem()))\n-\tcase *reflect.SliceType:\n+\tcase reflect.Slice:\n \t\tet = NewSliceType(TypeFromNative(t.Elem()))\n-\tcase *reflect.StructType:\n+\tcase reflect.Struct:\n \t\tn := t.NumField()\n \t\tfields := make([]StructField, n)\n \t\tfor i := 0; i < n; i++ {\n@@ -113,7 +108,7 @@ func TypeFromNative(t reflect.Type) Type {\n \t\t\tfields[i].Anonymous = sf.Anonymous\n \t\t}\n \t\tet = NewStructType(fields)\n-\tcase *reflect.UnsafePointerType:\n+\tcase reflect.UnsafePointer:\n \t\tlog.Panicf(\"%T not implemented\", t)\n \tdefault:\n \t\tlog.Panicf(\"unexpected reflect.Type: %T\", t)\n@@ -133,7 +128,7 @@ func TypeFromNative(t reflect.Type) Type {\n }\n \n // TypeOfNative returns the interpreter Type of a regular Go value.\n-func TypeOfNative(v interface{}) Type { return TypeFromNative(reflect.Typeof(v)) }\n+func TypeOfNative(v interface{}) Type { return TypeFromNative(reflect.TypeOf(v)) }\n \n /*\n  * Function bridging"}, {"sha": "8a93d8a6c27b3857d7158b9f824abf6086c9a123", "filename": "libgo/go/exp/eval/type.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fexp%2Feval%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fexp%2Feval%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Feval%2Ftype.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -86,7 +86,7 @@ func hashTypeArray(key []Type) uintptr {\n \t\tif t == nil {\n \t\t\tcontinue\n \t\t}\n-\t\taddr := reflect.NewValue(t).(*reflect.PtrValue).Get()\n+\t\taddr := reflect.ValueOf(t).Pointer()\n \t\thash ^= addr\n \t}\n \treturn hash"}, {"sha": "a5f6ac7e5e788aeb0c00180ad3d157593b7429bf", "filename": "libgo/go/exp/eval/world.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fexp%2Feval%2Fworld.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fexp%2Feval%2Fworld.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Feval%2Fworld.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This package is the beginning of an interpreter for Go.\n+// Package eval is the beginning of an interpreter for Go.\n // It can run simple Go programs but does not implement\n // interface values or packages.\n package eval"}, {"sha": "a8db523ea18e9cdb17f5559b19e5f8366511e819", "filename": "libgo/go/exp/ogle/cmd.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fexp%2Fogle%2Fcmd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fexp%2Fogle%2Fcmd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fogle%2Fcmd.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// Ogle is the beginning of a debugger for Go.\n+// Package ogle is the beginning of a debugger for Go.\n package ogle\n \n import ("}, {"sha": "7c803b3a27e990f3282b8cdbb915a604e284f6a8", "filename": "libgo/go/exp/ogle/process.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fexp%2Fogle%2Fprocess.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fexp%2Fogle%2Fprocess.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fogle%2Fprocess.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -226,8 +226,8 @@ func (p *Process) bootstrap() {\n \tp.runtime.G = newManualType(eval.TypeOfNative(rt1G{}), p.Arch)\n \n \t// Get addresses of type.*runtime.XType for discrimination.\n-\trtv := reflect.Indirect(reflect.NewValue(&p.runtime)).(*reflect.StructValue)\n-\trtvt := rtv.Type().(*reflect.StructType)\n+\trtv := reflect.Indirect(reflect.ValueOf(&p.runtime))\n+\trtvt := rtv.Type()\n \tfor i := 0; i < rtv.NumField(); i++ {\n \t\tn := rtvt.Field(i).Name\n \t\tif n[0] != 'P' || n[1] < 'A' || n[1] > 'Z' {\n@@ -237,7 +237,7 @@ func (p *Process) bootstrap() {\n \t\tif sym == nil {\n \t\t\tcontinue\n \t\t}\n-\t\trtv.Field(i).(*reflect.UintValue).Set(sym.Value)\n+\t\trtv.Field(i).SetUint(sym.Value)\n \t}\n \n \t// Get runtime field indexes"}, {"sha": "950418b5388fee785449f8d131b50cf442213d60", "filename": "libgo/go/exp/ogle/rruntime.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fexp%2Fogle%2Frruntime.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fexp%2Fogle%2Frruntime.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fogle%2Frruntime.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -236,9 +236,9 @@ type runtimeValues struct {\n // indexes gathered from the remoteTypes recorded in a runtimeValues\n // structure.\n func fillRuntimeIndexes(runtime *runtimeValues, out *runtimeIndexes) {\n-\toutv := reflect.Indirect(reflect.NewValue(out)).(*reflect.StructValue)\n-\toutt := outv.Type().(*reflect.StructType)\n-\truntimev := reflect.Indirect(reflect.NewValue(runtime)).(*reflect.StructValue)\n+\toutv := reflect.Indirect(reflect.ValueOf(out))\n+\toutt := outv.Type()\n+\truntimev := reflect.Indirect(reflect.ValueOf(runtime))\n \n \t// out contains fields corresponding to each runtime type\n \tfor i := 0; i < outt.NumField(); i++ {\n@@ -260,12 +260,12 @@ func fillRuntimeIndexes(runtime *runtimeValues, out *runtimeIndexes) {\n \t\t}\n \n \t\t// Fill this field of out\n-\t\toutStructv := outv.Field(i).(*reflect.StructValue)\n-\t\toutStructt := outStructv.Type().(*reflect.StructType)\n+\t\toutStructv := outv.Field(i)\n+\t\toutStructt := outStructv.Type()\n \t\tfor j := 0; j < outStructt.NumField(); j++ {\n-\t\t\tf := outStructv.Field(j).(*reflect.IntValue)\n+\t\t\tf := outStructv.Field(j)\n \t\t\tname := outStructt.Field(j).Name\n-\t\t\tf.Set(int64(indexes[name]))\n+\t\t\tf.SetInt(int64(indexes[name]))\n \t\t}\n \t}\n }"}, {"sha": "6ae6330a1fa295202ab52b7f5667821394c21c52", "filename": "libgo/go/exp/wingui/zwinapi.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fexp%2Fwingui%2Fzwinapi.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fexp%2Fwingui%2Fzwinapi.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fwingui%2Fzwinapi.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -1,4 +1,4 @@\n-// mksyscall_windows.sh winapi.go\n+// mksyscall_windows.pl winapi.go\n // MACHINE GENERATED BY THE COMMAND ABOVE; DO NOT EDIT\n \n package main"}, {"sha": "7123d4b0f77c5c4d599f0d787693c295b0797f72", "filename": "libgo/go/expvar/expvar.go", "status": "modified", "additions": 16, "deletions": 27, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fexpvar%2Fexpvar.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fexpvar%2Fexpvar.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexpvar%2Fexpvar.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,9 +2,9 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// The expvar package provides a standardized interface to public variables,\n-// such as operation counters in servers. It exposes these variables via\n-// HTTP at /debug/vars in JSON format.\n+// Package expvar provides a standardized interface to public variables, such\n+// as operation counters in servers. It exposes these variables via HTTP at\n+// /debug/vars in JSON format.\n //\n // Operations to set or modify these public variables are atomic.\n //\n@@ -180,23 +180,14 @@ func (v *String) String() string { return strconv.Quote(v.s) }\n \n func (v *String) Set(value string) { v.s = value }\n \n-// IntFunc wraps a func() int64 to create a value that satisfies the Var interface.\n-// The function will be called each time the Var is evaluated.\n-type IntFunc func() int64\n+// Func implements Var by calling the function\n+// and formatting the returned value using JSON.\n+type Func func() interface{}\n \n-func (v IntFunc) String() string { return strconv.Itoa64(v()) }\n-\n-// FloatFunc wraps a func() float64 to create a value that satisfies the Var interface.\n-// The function will be called each time the Var is evaluated.\n-type FloatFunc func() float64\n-\n-func (v FloatFunc) String() string { return strconv.Ftoa64(v(), 'g', -1) }\n-\n-// StringFunc wraps a func() string to create value that satisfies the Var interface.\n-// The function will be called each time the Var is evaluated.\n-type StringFunc func() string\n-\n-func (f StringFunc) String() string { return strconv.Quote(f()) }\n+func (f Func) String() string {\n+\tv, _ := json.Marshal(f())\n+\treturn string(v)\n+}\n \n \n // All published variables.\n@@ -282,18 +273,16 @@ func expvarHandler(w http.ResponseWriter, r *http.Request) {\n \tfmt.Fprintf(w, \"\\n}\\n\")\n }\n \n-func memstats() string {\n-\tb, _ := json.MarshalIndent(&runtime.MemStats, \"\", \"\\t\")\n-\treturn string(b)\n+func cmdline() interface{} {\n+\treturn os.Args\n }\n \n-func cmdline() string {\n-\tb, _ := json.Marshal(os.Args)\n-\treturn string(b)\n+func memstats() interface{} {\n+\treturn runtime.MemStats\n }\n \n func init() {\n \thttp.Handle(\"/debug/vars\", http.HandlerFunc(expvarHandler))\n-\tPublish(\"cmdline\", StringFunc(cmdline))\n-\tPublish(\"memstats\", StringFunc(memstats))\n+\tPublish(\"cmdline\", Func(cmdline))\n+\tPublish(\"memstats\", Func(memstats))\n }"}, {"sha": "94926d9f8ce045f921c2e62995b2e63d0eab5483", "filename": "libgo/go/expvar/expvar_test.go", "status": "modified", "additions": 8, "deletions": 34, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fexpvar%2Fexpvar_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fexpvar%2Fexpvar_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexpvar%2Fexpvar_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -114,41 +114,15 @@ func TestMapCounter(t *testing.T) {\n \t}\n }\n \n-func TestIntFunc(t *testing.T) {\n-\tx := int64(4)\n-\tix := IntFunc(func() int64 { return x })\n-\tif s := ix.String(); s != \"4\" {\n-\t\tt.Errorf(\"ix.String() = %v, want 4\", s)\n+func TestFunc(t *testing.T) {\n+\tvar x interface{} = []string{\"a\", \"b\"}\n+\tf := Func(func() interface{} { return x })\n+\tif s, exp := f.String(), `[\"a\",\"b\"]`; s != exp {\n+\t\tt.Errorf(`f.String() = %q, want %q`, s, exp)\n \t}\n \n-\tx++\n-\tif s := ix.String(); s != \"5\" {\n-\t\tt.Errorf(\"ix.String() = %v, want 5\", s)\n-\t}\n-}\n-\n-func TestFloatFunc(t *testing.T) {\n-\tx := 8.5\n-\tix := FloatFunc(func() float64 { return x })\n-\tif s := ix.String(); s != \"8.5\" {\n-\t\tt.Errorf(\"ix.String() = %v, want 3.14\", s)\n-\t}\n-\n-\tx -= 1.25\n-\tif s := ix.String(); s != \"7.25\" {\n-\t\tt.Errorf(\"ix.String() = %v, want 4.34\", s)\n-\t}\n-}\n-\n-func TestStringFunc(t *testing.T) {\n-\tx := \"hello\"\n-\tsx := StringFunc(func() string { return x })\n-\tif s, exp := sx.String(), `\"hello\"`; s != exp {\n-\t\tt.Errorf(`sx.String() = %q, want %q`, s, exp)\n-\t}\n-\n-\tx = \"goodbye\"\n-\tif s, exp := sx.String(), `\"goodbye\"`; s != exp {\n-\t\tt.Errorf(`sx.String() = %q, want %q`, s, exp)\n+\tx = 17\n+\tif s, exp := f.String(), `17`; s != exp {\n+\t\tt.Errorf(`f.String() = %q, want %q`, s, exp)\n \t}\n }"}, {"sha": "9ed20e06b5a9df77ac050d79a2f7e0db7f136850", "filename": "libgo/go/flag/flag.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fflag%2Fflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fflag%2Fflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fflag%2Fflag.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -3,7 +3,7 @@\n // license that can be found in the LICENSE file.\n \n /*\n-\tThe flag package implements command-line flag parsing.\n+\tPackage flag implements command-line flag parsing.\n \n \tUsage:\n "}, {"sha": "e4d4f184427fd2ca7c03acf736986508fdb3bdf5", "filename": "libgo/go/fmt/doc.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Ffmt%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Ffmt%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fdoc.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -27,7 +27,7 @@\n \t\t%o\tbase 8\n \t\t%x\tbase 16, with lower-case letters for a-f\n \t\t%X\tbase 16, with upper-case letters for A-F\n-\t\t%U\tUnicode format: U+1234; same as \"U+%x\" with 4 digits default\n+\t\t%U\tUnicode format: U+1234; same as \"U+%0.4X\"\n \tFloating-point and complex constituents:\n \t\t%b\tdecimalless scientific notation with exponent a power\n \t\t\tof two, in the manner of strconv.Ftoa32, e.g. -123456p-78"}, {"sha": "b3c0c5abed4a1324d0624f8c50c5cc836096c992", "filename": "libgo/go/fmt/fmt_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Ffmt_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -170,6 +170,7 @@ var fmttests = []struct {\n \n \t// unicode format\n \t{\"%U\", 0x1, \"U+0001\"},\n+\t{\"%U\", uint(0x1), \"U+0001\"},\n \t{\"%.8U\", 0x2, \"U+00000002\"},\n \t{\"%U\", 0x1234, \"U+1234\"},\n \t{\"%U\", 0x12345, \"U+12345\"},"}, {"sha": "10e0fe7c85bbb92bc8a18855c510f89849f44864", "filename": "libgo/go/fmt/print.go", "status": "modified", "additions": 56, "deletions": 59, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Ffmt%2Fprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Ffmt%2Fprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fprint.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -256,11 +256,11 @@ func Sprintln(a ...interface{}) string {\n // Get the i'th arg of the struct value.\n // If the arg itself is an interface, return a value for\n // the thing inside the interface, not the interface itself.\n-func getField(v *reflect.StructValue, i int) reflect.Value {\n+func getField(v reflect.Value, i int) reflect.Value {\n \tval := v.Field(i)\n-\tif i, ok := val.(*reflect.InterfaceValue); ok {\n+\tif i := val; i.Kind() == reflect.Interface {\n \t\tif inter := i.Interface(); inter != nil {\n-\t\t\treturn reflect.NewValue(inter)\n+\t\t\treturn reflect.ValueOf(inter)\n \t\t}\n \t}\n \treturn val\n@@ -278,18 +278,13 @@ func parsenum(s string, start, end int) (num int, isnum bool, newi int) {\n \treturn\n }\n \n-// Reflection values like reflect.FuncValue implement this method. We use it for %p.\n-type uintptrGetter interface {\n-\tGet() uintptr\n-}\n-\n func (p *pp) unknownType(v interface{}) {\n \tif v == nil {\n \t\tp.buf.Write(nilAngleBytes)\n \t\treturn\n \t}\n \tp.buf.WriteByte('?')\n-\tp.buf.WriteString(reflect.Typeof(v).String())\n+\tp.buf.WriteString(reflect.TypeOf(v).String())\n \tp.buf.WriteByte('?')\n }\n \n@@ -301,7 +296,7 @@ func (p *pp) badVerb(verb int, val interface{}) {\n \tif val == nil {\n \t\tp.buf.Write(nilAngleBytes)\n \t} else {\n-\t\tp.buf.WriteString(reflect.Typeof(val).String())\n+\t\tp.buf.WriteString(reflect.TypeOf(val).String())\n \t\tp.add('=')\n \t\tp.printField(val, 'v', false, false, 0)\n \t}\n@@ -394,6 +389,8 @@ func (p *pp) fmtUint64(v uint64, verb int, goSyntax bool, value interface{}) {\n \t\tp.fmt.integer(int64(v), 16, unsigned, ldigits)\n \tcase 'X':\n \t\tp.fmt.integer(int64(v), 16, unsigned, udigits)\n+\tcase 'U':\n+\t\tp.fmtUnicode(int64(v))\n \tdefault:\n \t\tp.badVerb(verb, value)\n \t}\n@@ -521,16 +518,16 @@ func (p *pp) fmtBytes(v []byte, verb int, goSyntax bool, depth int, value interf\n \n func (p *pp) fmtPointer(field interface{}, value reflect.Value, verb int, goSyntax bool) {\n \tvar u uintptr\n-\tswitch value.(type) {\n-\tcase *reflect.ChanValue, *reflect.FuncValue, *reflect.MapValue, *reflect.PtrValue, *reflect.SliceValue, *reflect.UnsafePointerValue:\n-\t\tu = value.(uintptrGetter).Get()\n+\tswitch value.Kind() {\n+\tcase reflect.Chan, reflect.Func, reflect.Map, reflect.Ptr, reflect.Slice, reflect.UnsafePointer:\n+\t\tu = value.Pointer()\n \tdefault:\n \t\tp.badVerb(verb, field)\n \t\treturn\n \t}\n \tif goSyntax {\n \t\tp.add('(')\n-\t\tp.buf.WriteString(reflect.Typeof(field).String())\n+\t\tp.buf.WriteString(reflect.TypeOf(field).String())\n \t\tp.add(')')\n \t\tp.add('(')\n \t\tif u == 0 {\n@@ -545,10 +542,10 @@ func (p *pp) fmtPointer(field interface{}, value reflect.Value, verb int, goSynt\n }\n \n var (\n-\tintBits     = reflect.Typeof(0).Bits()\n-\tfloatBits   = reflect.Typeof(0.0).Bits()\n-\tcomplexBits = reflect.Typeof(1i).Bits()\n-\tuintptrBits = reflect.Typeof(uintptr(0)).Bits()\n+\tintBits     = reflect.TypeOf(0).Bits()\n+\tfloatBits   = reflect.TypeOf(0.0).Bits()\n+\tcomplexBits = reflect.TypeOf(1i).Bits()\n+\tuintptrBits = reflect.TypeOf(uintptr(0)).Bits()\n )\n \n func (p *pp) printField(field interface{}, verb int, plus, goSyntax bool, depth int) (wasString bool) {\n@@ -565,10 +562,10 @@ func (p *pp) printField(field interface{}, verb int, plus, goSyntax bool, depth\n \t// %T (the value's type) and %p (its address) are special; we always do them first.\n \tswitch verb {\n \tcase 'T':\n-\t\tp.printField(reflect.Typeof(field).String(), 's', false, false, 0)\n+\t\tp.printField(reflect.TypeOf(field).String(), 's', false, false, 0)\n \t\treturn false\n \tcase 'p':\n-\t\tp.fmtPointer(field, reflect.NewValue(field), verb, goSyntax)\n+\t\tp.fmtPointer(field, reflect.ValueOf(field), verb, goSyntax)\n \t\treturn false\n \t}\n \t// Is it a Formatter?\n@@ -656,38 +653,38 @@ func (p *pp) printField(field interface{}, verb int, plus, goSyntax bool, depth\n \t}\n \n \t// Need to use reflection\n-\tvalue := reflect.NewValue(field)\n+\tvalue := reflect.ValueOf(field)\n \n BigSwitch:\n-\tswitch f := value.(type) {\n-\tcase *reflect.BoolValue:\n-\t\tp.fmtBool(f.Get(), verb, field)\n-\tcase *reflect.IntValue:\n-\t\tp.fmtInt64(f.Get(), verb, field)\n-\tcase *reflect.UintValue:\n-\t\tp.fmtUint64(uint64(f.Get()), verb, goSyntax, field)\n-\tcase *reflect.FloatValue:\n+\tswitch f := value; f.Kind() {\n+\tcase reflect.Bool:\n+\t\tp.fmtBool(f.Bool(), verb, field)\n+\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n+\t\tp.fmtInt64(f.Int(), verb, field)\n+\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n+\t\tp.fmtUint64(uint64(f.Uint()), verb, goSyntax, field)\n+\tcase reflect.Float32, reflect.Float64:\n \t\tif f.Type().Size() == 4 {\n-\t\t\tp.fmtFloat32(float32(f.Get()), verb, field)\n+\t\t\tp.fmtFloat32(float32(f.Float()), verb, field)\n \t\t} else {\n-\t\t\tp.fmtFloat64(float64(f.Get()), verb, field)\n+\t\t\tp.fmtFloat64(float64(f.Float()), verb, field)\n \t\t}\n-\tcase *reflect.ComplexValue:\n+\tcase reflect.Complex64, reflect.Complex128:\n \t\tif f.Type().Size() == 8 {\n-\t\t\tp.fmtComplex64(complex64(f.Get()), verb, field)\n+\t\t\tp.fmtComplex64(complex64(f.Complex()), verb, field)\n \t\t} else {\n-\t\t\tp.fmtComplex128(complex128(f.Get()), verb, field)\n+\t\t\tp.fmtComplex128(complex128(f.Complex()), verb, field)\n \t\t}\n-\tcase *reflect.StringValue:\n-\t\tp.fmtString(f.Get(), verb, goSyntax, field)\n-\tcase *reflect.MapValue:\n+\tcase reflect.String:\n+\t\tp.fmtString(f.String(), verb, goSyntax, field)\n+\tcase reflect.Map:\n \t\tif goSyntax {\n \t\t\tp.buf.WriteString(f.Type().String())\n \t\t\tp.buf.WriteByte('{')\n \t\t} else {\n \t\t\tp.buf.Write(mapBytes)\n \t\t}\n-\t\tkeys := f.Keys()\n+\t\tkeys := f.MapKeys()\n \t\tfor i, key := range keys {\n \t\t\tif i > 0 {\n \t\t\t\tif goSyntax {\n@@ -698,20 +695,20 @@ BigSwitch:\n \t\t\t}\n \t\t\tp.printField(key.Interface(), verb, plus, goSyntax, depth+1)\n \t\t\tp.buf.WriteByte(':')\n-\t\t\tp.printField(f.Elem(key).Interface(), verb, plus, goSyntax, depth+1)\n+\t\t\tp.printField(f.MapIndex(key).Interface(), verb, plus, goSyntax, depth+1)\n \t\t}\n \t\tif goSyntax {\n \t\t\tp.buf.WriteByte('}')\n \t\t} else {\n \t\t\tp.buf.WriteByte(']')\n \t\t}\n-\tcase *reflect.StructValue:\n+\tcase reflect.Struct:\n \t\tif goSyntax {\n-\t\t\tp.buf.WriteString(reflect.Typeof(field).String())\n+\t\t\tp.buf.WriteString(reflect.TypeOf(field).String())\n \t\t}\n \t\tp.add('{')\n \t\tv := f\n-\t\tt := v.Type().(*reflect.StructType)\n+\t\tt := v.Type()\n \t\tfor i := 0; i < v.NumField(); i++ {\n \t\t\tif i > 0 {\n \t\t\t\tif goSyntax {\n@@ -729,21 +726,21 @@ BigSwitch:\n \t\t\tp.printField(getField(v, i).Interface(), verb, plus, goSyntax, depth+1)\n \t\t}\n \t\tp.buf.WriteByte('}')\n-\tcase *reflect.InterfaceValue:\n+\tcase reflect.Interface:\n \t\tvalue := f.Elem()\n-\t\tif value == nil {\n+\t\tif !value.IsValid() {\n \t\t\tif goSyntax {\n-\t\t\t\tp.buf.WriteString(reflect.Typeof(field).String())\n+\t\t\t\tp.buf.WriteString(reflect.TypeOf(field).String())\n \t\t\t\tp.buf.Write(nilParenBytes)\n \t\t\t} else {\n \t\t\t\tp.buf.Write(nilAngleBytes)\n \t\t\t}\n \t\t} else {\n \t\t\treturn p.printField(value.Interface(), verb, plus, goSyntax, depth+1)\n \t\t}\n-\tcase reflect.ArrayOrSliceValue:\n+\tcase reflect.Array, reflect.Slice:\n \t\t// Byte slices are special.\n-\t\tif f.Type().(reflect.ArrayOrSliceType).Elem().Kind() == reflect.Uint8 {\n+\t\tif f.Type().Elem().Kind() == reflect.Uint8 {\n \t\t\t// We know it's a slice of bytes, but we also know it does not have static type\n \t\t\t// []byte, or it would have been caught above.  Therefore we cannot convert\n \t\t\t// it directly in the (slightly) obvious way: f.Interface().([]byte); it doesn't have\n@@ -753,13 +750,13 @@ BigSwitch:\n \t\t\t// if reflection could help a little more.\n \t\t\tbytes := make([]byte, f.Len())\n \t\t\tfor i := range bytes {\n-\t\t\t\tbytes[i] = byte(f.Elem(i).(*reflect.UintValue).Get())\n+\t\t\t\tbytes[i] = byte(f.Index(i).Uint())\n \t\t\t}\n \t\t\tp.fmtBytes(bytes, verb, goSyntax, depth, field)\n \t\t\treturn verb == 's'\n \t\t}\n \t\tif goSyntax {\n-\t\t\tp.buf.WriteString(reflect.Typeof(field).String())\n+\t\t\tp.buf.WriteString(reflect.TypeOf(field).String())\n \t\t\tp.buf.WriteByte('{')\n \t\t} else {\n \t\t\tp.buf.WriteByte('[')\n@@ -772,32 +769,32 @@ BigSwitch:\n \t\t\t\t\tp.buf.WriteByte(' ')\n \t\t\t\t}\n \t\t\t}\n-\t\t\tp.printField(f.Elem(i).Interface(), verb, plus, goSyntax, depth+1)\n+\t\t\tp.printField(f.Index(i).Interface(), verb, plus, goSyntax, depth+1)\n \t\t}\n \t\tif goSyntax {\n \t\t\tp.buf.WriteByte('}')\n \t\t} else {\n \t\t\tp.buf.WriteByte(']')\n \t\t}\n-\tcase *reflect.PtrValue:\n-\t\tv := f.Get()\n+\tcase reflect.Ptr:\n+\t\tv := f.Pointer()\n \t\t// pointer to array or slice or struct?  ok at top level\n \t\t// but not embedded (avoid loops)\n \t\tif v != 0 && depth == 0 {\n-\t\t\tswitch a := f.Elem().(type) {\n-\t\t\tcase reflect.ArrayOrSliceValue:\n+\t\t\tswitch a := f.Elem(); a.Kind() {\n+\t\t\tcase reflect.Array, reflect.Slice:\n \t\t\t\tp.buf.WriteByte('&')\n \t\t\t\tp.printField(a.Interface(), verb, plus, goSyntax, depth+1)\n \t\t\t\tbreak BigSwitch\n-\t\t\tcase *reflect.StructValue:\n+\t\t\tcase reflect.Struct:\n \t\t\t\tp.buf.WriteByte('&')\n \t\t\t\tp.printField(a.Interface(), verb, plus, goSyntax, depth+1)\n \t\t\t\tbreak BigSwitch\n \t\t\t}\n \t\t}\n \t\tif goSyntax {\n \t\t\tp.buf.WriteByte('(')\n-\t\t\tp.buf.WriteString(reflect.Typeof(field).String())\n+\t\t\tp.buf.WriteString(reflect.TypeOf(field).String())\n \t\t\tp.buf.WriteByte(')')\n \t\t\tp.buf.WriteByte('(')\n \t\t\tif v == 0 {\n@@ -813,7 +810,7 @@ BigSwitch:\n \t\t\tbreak\n \t\t}\n \t\tp.fmt0x64(uint64(v), true)\n-\tcase *reflect.ChanValue, *reflect.FuncValue, *reflect.UnsafePointerValue:\n+\tcase reflect.Chan, reflect.Func, reflect.UnsafePointer:\n \t\tp.fmtPointer(field, value, verb, goSyntax)\n \tdefault:\n \t\tp.unknownType(f)\n@@ -918,7 +915,7 @@ func (p *pp) doPrintf(format string, a []interface{}) {\n \t\tfor ; fieldnum < len(a); fieldnum++ {\n \t\t\tfield := a[fieldnum]\n \t\t\tif field != nil {\n-\t\t\t\tp.buf.WriteString(reflect.Typeof(field).String())\n+\t\t\t\tp.buf.WriteString(reflect.TypeOf(field).String())\n \t\t\t\tp.buf.WriteByte('=')\n \t\t\t}\n \t\t\tp.printField(field, 'v', false, false, 0)\n@@ -937,7 +934,7 @@ func (p *pp) doPrint(a []interface{}, addspace, addnewline bool) {\n \t\t// always add spaces if we're doing println\n \t\tfield := a[fieldnum]\n \t\tif fieldnum > 0 {\n-\t\t\tisString := field != nil && reflect.Typeof(field).Kind() == reflect.String\n+\t\t\tisString := field != nil && reflect.TypeOf(field).Kind() == reflect.String\n \t\t\tif addspace || !isString && !prevString {\n \t\t\t\tp.buf.WriteByte(' ')\n \t\t\t}"}, {"sha": "42bc52c92bcca480857039c4db146ccf61e1aae5", "filename": "libgo/go/fmt/scan.go", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Ffmt%2Fscan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Ffmt%2Fscan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fscan.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -423,7 +423,7 @@ func (s *ss) token(skipSpace bool, f func(int) bool) []byte {\n \n // typeError indicates that the type of the operand did not match the format\n func (s *ss) typeError(field interface{}, expected string) {\n-\ts.errorString(\"expected field of type pointer to \" + expected + \"; found \" + reflect.Typeof(field).String())\n+\ts.errorString(\"expected field of type pointer to \" + expected + \"; found \" + reflect.TypeOf(field).String())\n }\n \n var complexError = os.ErrorString(\"syntax error scanning complex number\")\n@@ -908,37 +908,37 @@ func (s *ss) scanOne(verb int, field interface{}) {\n \t\t// If we scanned to bytes, the slice would point at the buffer.\n \t\t*v = []byte(s.convertString(verb))\n \tdefault:\n-\t\tval := reflect.NewValue(v)\n-\t\tptr, ok := val.(*reflect.PtrValue)\n-\t\tif !ok {\n+\t\tval := reflect.ValueOf(v)\n+\t\tptr := val\n+\t\tif ptr.Kind() != reflect.Ptr {\n \t\t\ts.errorString(\"Scan: type not a pointer: \" + val.Type().String())\n \t\t\treturn\n \t\t}\n-\t\tswitch v := ptr.Elem().(type) {\n-\t\tcase *reflect.BoolValue:\n-\t\t\tv.Set(s.scanBool(verb))\n-\t\tcase *reflect.IntValue:\n-\t\t\tv.Set(s.scanInt(verb, v.Type().Bits()))\n-\t\tcase *reflect.UintValue:\n-\t\t\tv.Set(s.scanUint(verb, v.Type().Bits()))\n-\t\tcase *reflect.StringValue:\n-\t\t\tv.Set(s.convertString(verb))\n-\t\tcase *reflect.SliceValue:\n+\t\tswitch v := ptr.Elem(); v.Kind() {\n+\t\tcase reflect.Bool:\n+\t\t\tv.SetBool(s.scanBool(verb))\n+\t\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n+\t\t\tv.SetInt(s.scanInt(verb, v.Type().Bits()))\n+\t\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n+\t\t\tv.SetUint(s.scanUint(verb, v.Type().Bits()))\n+\t\tcase reflect.String:\n+\t\t\tv.SetString(s.convertString(verb))\n+\t\tcase reflect.Slice:\n \t\t\t// For now, can only handle (renamed) []byte.\n-\t\t\ttyp := v.Type().(*reflect.SliceType)\n+\t\t\ttyp := v.Type()\n \t\t\tif typ.Elem().Kind() != reflect.Uint8 {\n \t\t\t\tgoto CantHandle\n \t\t\t}\n \t\t\tstr := s.convertString(verb)\n \t\t\tv.Set(reflect.MakeSlice(typ, len(str), len(str)))\n \t\t\tfor i := 0; i < len(str); i++ {\n-\t\t\t\tv.Elem(i).(*reflect.UintValue).Set(uint64(str[i]))\n+\t\t\t\tv.Index(i).SetUint(uint64(str[i]))\n \t\t\t}\n-\t\tcase *reflect.FloatValue:\n+\t\tcase reflect.Float32, reflect.Float64:\n \t\t\ts.skipSpace(false)\n-\t\t\tv.Set(s.convertFloat(s.floatToken(), v.Type().Bits()))\n-\t\tcase *reflect.ComplexValue:\n-\t\t\tv.Set(s.scanComplex(verb, v.Type().Bits()))\n+\t\t\tv.SetFloat(s.convertFloat(s.floatToken(), v.Type().Bits()))\n+\t\tcase reflect.Complex64, reflect.Complex128:\n+\t\t\tv.SetComplex(s.scanComplex(verb, v.Type().Bits()))\n \t\tdefault:\n \t\tCantHandle:\n \t\t\ts.errorString(\"Scan: can't handle type: \" + val.Type().String())"}, {"sha": "da13eb2d112213f766ec109fe60e2c61f62438ca", "filename": "libgo/go/fmt/scan_test.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Ffmt%2Fscan_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Ffmt%2Fscan_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fscan_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -370,8 +370,8 @@ func testScan(name string, t *testing.T, scan func(r io.Reader, a ...interface{}\n \t\t\tcontinue\n \t\t}\n \t\t// The incoming value may be a pointer\n-\t\tv := reflect.NewValue(test.in)\n-\t\tif p, ok := v.(*reflect.PtrValue); ok {\n+\t\tv := reflect.ValueOf(test.in)\n+\t\tif p := v; p.Kind() == reflect.Ptr {\n \t\t\tv = p.Elem()\n \t\t}\n \t\tval := v.Interface()\n@@ -409,8 +409,8 @@ func TestScanf(t *testing.T) {\n \t\t\tcontinue\n \t\t}\n \t\t// The incoming value may be a pointer\n-\t\tv := reflect.NewValue(test.in)\n-\t\tif p, ok := v.(*reflect.PtrValue); ok {\n+\t\tv := reflect.ValueOf(test.in)\n+\t\tif p := v; p.Kind() == reflect.Ptr {\n \t\t\tv = p.Elem()\n \t\t}\n \t\tval := v.Interface()\n@@ -486,7 +486,7 @@ func TestInf(t *testing.T) {\n }\n \n func testScanfMulti(name string, t *testing.T) {\n-\tsliceType := reflect.Typeof(make([]interface{}, 1)).(*reflect.SliceType)\n+\tsliceType := reflect.TypeOf(make([]interface{}, 1))\n \tfor _, test := range multiTests {\n \t\tvar r io.Reader\n \t\tif name == \"StringReader\" {\n@@ -513,8 +513,8 @@ func testScanfMulti(name string, t *testing.T) {\n \t\t// Convert the slice of pointers into a slice of values\n \t\tresultVal := reflect.MakeSlice(sliceType, n, n)\n \t\tfor i := 0; i < n; i++ {\n-\t\t\tv := reflect.NewValue(test.in[i]).(*reflect.PtrValue).Elem()\n-\t\t\tresultVal.Elem(i).(*reflect.InterfaceValue).Set(v)\n+\t\t\tv := reflect.ValueOf(test.in[i]).Elem()\n+\t\t\tresultVal.Index(i).Set(v)\n \t\t}\n \t\tresult := resultVal.Interface()\n \t\tif !reflect.DeepEqual(result, test.out) {"}, {"sha": "2fc1a60323dfdc0b9bb9e8683f63cfff04ad057c", "filename": "libgo/go/go/ast/ast.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Fast%2Fast.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Fast%2Fast.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fast.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,8 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// The AST package declares the types used to represent\n-// syntax trees for Go packages.\n+// Package ast declares the types used to represent syntax trees for Go\n+// packages.\n //\n package ast\n "}, {"sha": "81e1da1d0aa18b51d7f59f81c116f5d90f91678e", "filename": "libgo/go/go/ast/print.go", "status": "modified", "additions": 45, "deletions": 30, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Fast%2Fprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Fast%2Fprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fprint.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -21,11 +21,12 @@ type FieldFilter func(name string, value reflect.Value) bool\n \n // NotNilFilter returns true for field values that are not nil;\n // it returns false otherwise.\n-func NotNilFilter(_ string, value reflect.Value) bool {\n-\tv, ok := value.(interface {\n-\t\tIsNil() bool\n-\t})\n-\treturn !ok || !v.IsNil()\n+func NotNilFilter(_ string, v reflect.Value) bool {\n+\tswitch v.Kind() {\n+\tcase reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Ptr, reflect.Slice:\n+\t\treturn !v.IsNil()\n+\t}\n+\treturn true\n }\n \n \n@@ -61,7 +62,7 @@ func Fprint(w io.Writer, fset *token.FileSet, x interface{}, f FieldFilter) (n i\n \t\tp.printf(\"nil\\n\")\n \t\treturn\n \t}\n-\tp.print(reflect.NewValue(x))\n+\tp.print(reflect.ValueOf(x))\n \tp.printf(\"\\n\")\n \n \treturn\n@@ -79,7 +80,7 @@ type printer struct {\n \toutput  io.Writer\n \tfset    *token.FileSet\n \tfilter  FieldFilter\n-\tptrmap  map[interface{}]int // *reflect.PtrValue -> line number\n+\tptrmap  map[interface{}]int // *T -> line number\n \twritten int                 // number of bytes written to output\n \tindent  int                 // current indentation level\n \tlast    byte                // the last byte processed by Write\n@@ -140,64 +141,69 @@ func (p *printer) printf(format string, args ...interface{}) {\n // Implementation note: Print is written for AST nodes but could be\n // used to print arbitrary data structures; such a version should\n // probably be in a different package.\n+//\n+// Note: This code detects (some) cycles created via pointers but\n+// not cycles that are created via slices or maps containing the\n+// same slice or map. Code for general data structures probably\n+// should catch those as well.\n \n func (p *printer) print(x reflect.Value) {\n \tif !NotNilFilter(\"\", x) {\n \t\tp.printf(\"nil\")\n \t\treturn\n \t}\n \n-\tswitch v := x.(type) {\n-\tcase *reflect.InterfaceValue:\n-\t\tp.print(v.Elem())\n+\tswitch x.Kind() {\n+\tcase reflect.Interface:\n+\t\tp.print(x.Elem())\n \n-\tcase *reflect.MapValue:\n-\t\tp.printf(\"%s (len = %d) {\\n\", x.Type().String(), v.Len())\n+\tcase reflect.Map:\n+\t\tp.printf(\"%s (len = %d) {\\n\", x.Type().String(), x.Len())\n \t\tp.indent++\n-\t\tfor _, key := range v.Keys() {\n+\t\tfor _, key := range x.MapKeys() {\n \t\t\tp.print(key)\n \t\t\tp.printf(\": \")\n-\t\t\tp.print(v.Elem(key))\n+\t\t\tp.print(x.MapIndex(key))\n \t\t\tp.printf(\"\\n\")\n \t\t}\n \t\tp.indent--\n \t\tp.printf(\"}\")\n \n-\tcase *reflect.PtrValue:\n+\tcase reflect.Ptr:\n \t\tp.printf(\"*\")\n \t\t// type-checked ASTs may contain cycles - use ptrmap\n \t\t// to keep track of objects that have been printed\n \t\t// already and print the respective line number instead\n-\t\tptr := v.Interface()\n+\t\tptr := x.Interface()\n \t\tif line, exists := p.ptrmap[ptr]; exists {\n \t\t\tp.printf(\"(obj @ %d)\", line)\n \t\t} else {\n \t\t\tp.ptrmap[ptr] = p.line\n-\t\t\tp.print(v.Elem())\n+\t\t\tp.print(x.Elem())\n \t\t}\n \n-\tcase *reflect.SliceValue:\n-\t\tif s, ok := v.Interface().([]byte); ok {\n+\tcase reflect.Slice:\n+\t\tif s, ok := x.Interface().([]byte); ok {\n \t\t\tp.printf(\"%#q\", s)\n \t\t\treturn\n \t\t}\n-\t\tp.printf(\"%s (len = %d) {\\n\", x.Type().String(), v.Len())\n+\t\tp.printf(\"%s (len = %d) {\\n\", x.Type().String(), x.Len())\n \t\tp.indent++\n-\t\tfor i, n := 0, v.Len(); i < n; i++ {\n+\t\tfor i, n := 0, x.Len(); i < n; i++ {\n \t\t\tp.printf(\"%d: \", i)\n-\t\t\tp.print(v.Elem(i))\n+\t\t\tp.print(x.Index(i))\n \t\t\tp.printf(\"\\n\")\n \t\t}\n \t\tp.indent--\n \t\tp.printf(\"}\")\n \n-\tcase *reflect.StructValue:\n+\tcase reflect.Struct:\n \t\tp.printf(\"%s {\\n\", x.Type().String())\n \t\tp.indent++\n-\t\tt := v.Type().(*reflect.StructType)\n+\t\tt := x.Type()\n \t\tfor i, n := 0, t.NumField(); i < n; i++ {\n \t\t\tname := t.Field(i).Name\n-\t\t\tvalue := v.Field(i)\n+\t\t\tvalue := x.Field(i)\n \t\t\tif p.filter == nil || p.filter(name, value) {\n \t\t\t\tp.printf(\"%s: \", name)\n \t\t\t\tp.print(value)\n@@ -208,11 +214,20 @@ func (p *printer) print(x reflect.Value) {\n \t\tp.printf(\"}\")\n \n \tdefault:\n-\t\tvalue := x.Interface()\n-\t\t// position values can be printed nicely if we have a file set\n-\t\tif pos, ok := value.(token.Pos); ok && p.fset != nil {\n-\t\t\tvalue = p.fset.Position(pos)\n+\t\tv := x.Interface()\n+\t\tswitch v := v.(type) {\n+\t\tcase string:\n+\t\t\t// print strings in quotes\n+\t\t\tp.printf(\"%q\", v)\n+\t\t\treturn\n+\t\tcase token.Pos:\n+\t\t\t// position values can be printed nicely if we have a file set\n+\t\t\tif p.fset != nil {\n+\t\t\t\tp.printf(\"%s\", p.fset.Position(v))\n+\t\t\t\treturn\n+\t\t\t}\n \t\t}\n-\t\tp.printf(\"%v\", value)\n+\t\t// default\n+\t\tp.printf(\"%v\", v)\n \t}\n }"}, {"sha": "0820dcfcef25179ec0a29c9e89a77964d9f927b5", "filename": "libgo/go/go/ast/print_test.go", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Fast%2Fprint_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Fast%2Fprint_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fprint_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -0,0 +1,80 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package ast\n+\n+import (\n+\t\"bytes\"\n+\t\"strings\"\n+\t\"testing\"\n+)\n+\n+\n+var tests = []struct {\n+\tx interface{} // x is printed as s\n+\ts string\n+}{\n+\t// basic types\n+\t{nil, \"0  nil\"},\n+\t{true, \"0  true\"},\n+\t{42, \"0  42\"},\n+\t{3.14, \"0  3.14\"},\n+\t{1 + 2.718i, \"0  (1+2.718i)\"},\n+\t{\"foobar\", \"0  \\\"foobar\\\"\"},\n+\n+\t// maps\n+\t{map[string]int{\"a\": 1, \"b\": 2},\n+\t\t`0  map[string] int (len = 2) {\n+\t\t1  .  \"a\": 1\n+\t\t2  .  \"b\": 2\n+\t\t3  }`},\n+\n+\t// pointers\n+\t{new(int), \"0  *0\"},\n+\n+\t// slices\n+\t{[]int{1, 2, 3},\n+\t\t`0  []int (len = 3) {\n+\t\t1  .  0: 1\n+\t\t2  .  1: 2\n+\t\t3  .  2: 3\n+\t\t4  }`},\n+\n+\t// structs\n+\t{struct{ x, y int }{42, 991},\n+\t\t`0  struct { x int; y int } {\n+\t\t1  .  x: 42\n+\t\t2  .  y: 991\n+\t\t3  }`},\n+}\n+\n+\n+// Split s into lines, trim whitespace from all lines, and return\n+// the concatenated non-empty lines.\n+func trim(s string) string {\n+\tlines := strings.Split(s, \"\\n\", -1)\n+\ti := 0\n+\tfor _, line := range lines {\n+\t\tline = strings.TrimSpace(line)\n+\t\tif line != \"\" {\n+\t\t\tlines[i] = line\n+\t\t\ti++\n+\t\t}\n+\t}\n+\treturn strings.Join(lines[0:i], \"\\n\")\n+}\n+\n+\n+func TestPrint(t *testing.T) {\n+\tvar buf bytes.Buffer\n+\tfor _, test := range tests {\n+\t\tbuf.Reset()\n+\t\tif _, err := Fprint(&buf, nil, test.x, nil); err != nil {\n+\t\t\tt.Errorf(\"Fprint failed: %s\", err)\n+\t\t}\n+\t\tif s, ts := trim(buf.String()), trim(test.s); s != ts {\n+\t\t\tt.Errorf(\"got:\\n%s\\nexpected:\\n%s\\n\", s, ts)\n+\t\t}\n+\t}\n+}"}, {"sha": "29d205d391c82c076f4b45dd82099133b923599e", "filename": "libgo/go/go/doc/doc.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// The doc package extracts source code documentation from a Go AST.\n+// Package doc extracts source code documentation from a Go AST.\n package doc\n \n import ("}, {"sha": "afa9ae517b6f0ce2bf1f51e60a7d6c460227639c", "filename": "libgo/go/go/parser/parser.go", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,10 +2,10 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// A parser for Go source files. Input may be provided in a variety of\n-// forms (see the various Parse* functions); the output is an abstract\n-// syntax tree (AST) representing the Go source. The parser is invoked\n-// through one of the Parse* functions.\n+// Package parser implements a parser for Go source files. Input may be\n+// provided in a variety of forms (see the various Parse* functions); the\n+// output is an abstract syntax tree (AST) representing the Go source. The\n+// parser is invoked through one of the Parse* functions.\n //\n package parser\n \n@@ -1780,10 +1780,6 @@ func (p *parser) parseCommClause() *ast.CommClause {\n \t\t\t\trhs = lhs[0]\n \t\t\t\tlhs = nil // there is no lhs\n \t\t\t}\n-\t\t\tif x, isUnary := rhs.(*ast.UnaryExpr); !isUnary || x.Op != token.ARROW {\n-\t\t\t\tp.errorExpected(rhs.Pos(), \"send or receive operation\")\n-\t\t\t\trhs = &ast.BadExpr{rhs.Pos(), rhs.End()}\n-\t\t\t}\n \t\t\tif lhs != nil {\n \t\t\t\tcomm = &ast.AssignStmt{lhs, pos, tok, []ast.Expr{rhs}}\n \t\t\t} else {"}, {"sha": "5b52f51d4a5776219f93d8e91364614d9df2bf97", "filename": "libgo/go/go/parser/parser_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -51,6 +51,7 @@ var validPrograms = []interface{}{\n \t`package p; type T []int; func f() { for _ = range []int{T{42}[0]} {} };`,\n \t`package p; var a = T{{1, 2}, {3, 4}}`,\n \t`package p; func f() { select { case <- c: case c <- d: case c <- <- d: case <-c <- d: } };`,\n+\t`package p; func f() { select { case x := (<-c): } };`,\n \t`package p; func f() { if ; true {} };`,\n \t`package p; func f() { switch ; {} };`,\n }"}, {"sha": "86c32793062cbbe3313dd70430894a5adbe891a1", "filename": "libgo/go/go/printer/nodes.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -1200,7 +1200,7 @@ func (p *printer) spec(spec ast.Spec, n int, doIndent bool, multiLine *bool) {\n \t\tp.setComment(s.Doc)\n \t\tif s.Name != nil {\n \t\t\tp.expr(s.Name, multiLine)\n-\t\t\tp.print(vtab)\n+\t\t\tp.print(blank)\n \t\t}\n \t\tp.expr(s.Path, multiLine)\n \t\tp.setComment(s.Comment)"}, {"sha": "31de0b7ad40251b00086bace8044bb52b75103f6", "filename": "libgo/go/go/printer/performance_test.go", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Fprinter%2Fperformance_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Fprinter%2Fperformance_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fperformance_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// This file implements a simple printer performance benchmark:\n+// gotest -bench=BenchmarkPrint \n+\n+package printer\n+\n+import (\n+\t\"bytes\"\n+\t\"go/ast\"\n+\t\"go/parser\"\n+\t\"io\"\n+\t\"io/ioutil\"\n+\t\"log\"\n+\t\"testing\"\n+)\n+\n+\n+var testfile *ast.File\n+\n+\n+func testprint(out io.Writer, file *ast.File) {\n+\tif _, err := (&Config{TabIndent | UseSpaces, 8}).Fprint(out, fset, file); err != nil {\n+\t\tlog.Fatalf(\"print error: %s\", err)\n+\t}\n+}\n+\n+\n+// cannot initialize in init because (printer) Fprint launches goroutines.\n+func initialize() {\n+\tconst filename = \"testdata/parser.go\"\n+\n+\tsrc, err := ioutil.ReadFile(filename)\n+\tif err != nil {\n+\t\tlog.Fatalf(\"%s\", err)\n+\t}\n+\n+\tfile, err := parser.ParseFile(fset, filename, src, parser.ParseComments)\n+\tif err != nil {\n+\t\tlog.Fatalf(\"%s\", err)\n+\t}\n+\n+\tvar buf bytes.Buffer\n+\ttestprint(&buf, file)\n+\tif !bytes.Equal(buf.Bytes(), src) {\n+\t\tlog.Fatalf(\"print error: %s not idempotent\", filename)\n+\t}\n+\n+\ttestfile = file\n+}\n+\n+\n+func BenchmarkPrint(b *testing.B) {\n+\tif testfile == nil {\n+\t\tinitialize()\n+\t}\n+\tfor i := 0; i < b.N; i++ {\n+\t\ttestprint(ioutil.Discard, testfile)\n+\t}\n+}"}, {"sha": "01ebf783c416525c5f0a537024669ffabe405a2e", "filename": "libgo/go/go/printer/printer.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// The printer package implements printing of AST nodes.\n+// Package printer implements printing of AST nodes.\n package printer\n \n import ("}, {"sha": "c1b255842c1eda65278862aff49dfbd63bca8e5c", "filename": "libgo/go/go/printer/testdata/declarations.golden", "status": "modified", "additions": 53, "deletions": 24, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.golden?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -7,10 +7,10 @@ package imports\n import \"io\"\n \n import (\n-\t_\t\"io\"\n+\t_ \"io\"\n )\n \n-import _\t\"io\"\n+import _ \"io\"\n \n import (\n \t\"io\"\n@@ -20,40 +20,40 @@ import (\n \n import (\n \t\"io\"\n-\taLongRename\t\"io\"\n+\taLongRename \"io\"\n \n-\tb\t\"io\"\n+\tb \"io\"\n )\n \n import (\n \t\"unrenamed\"\n-\trenamed\t\"renameMe\"\n-\t.\t\"io\"\n-\t_\t\"io\"\n+\trenamed \"renameMe\"\n+\t. \"io\"\n+\t_ \"io\"\n \t\"io\"\n-\t.\t\"os\"\n+\t. \"os\"\n )\n \n // no newlines between consecutive single imports, but\n // respect extra line breaks in the source (at most one empty line)\n-import _\t\"io\"\n-import _\t\"io\"\n-import _\t\"io\"\n+import _ \"io\"\n+import _ \"io\"\n+import _ \"io\"\n \n-import _\t\"os\"\n-import _\t\"os\"\n-import _\t\"os\"\n+import _ \"os\"\n+import _ \"os\"\n+import _ \"os\"\n \n \n-import _\t\"fmt\"\n-import _\t\"fmt\"\n-import _\t\"fmt\"\n+import _ \"fmt\"\n+import _ \"fmt\"\n+import _ \"fmt\"\n \n import \"foo\"\t// a comment\n import \"bar\"\t// a comment\n \n import (\n-\t_\t\"foo\"\n+\t_ \"foo\"\n \t// a comment\n \t\"bar\"\n \t\"foo\"\t// a comment\n@@ -63,27 +63,56 @@ import (\n // comments + renames\n import (\n \t\"unrenamed\"\t// a comment\n-\trenamed\t\t\"renameMe\"\n-\t.\t\t\"io\"\t\t/* a comment */\n-\t_\t\t\"io/ioutil\"\t// a comment\n+\trenamed \"renameMe\"\n+\t. \"io\"\t\t/* a comment */\n+\t_ \"io/ioutil\"\t// a comment\n \t\"io\"\t\t// testing alignment\n-\t.\t\t\"os\"\n+\t. \"os\"\n \t// a comment\n )\n \n // a case that caused problems in the past (comment placement)\n import (\n-\t.\t\"fmt\"\n+\t. \"fmt\"\n \t\"io\"\n \t\"malloc\"\t// for the malloc count test only\n \t\"math\"\n \t\"strings\"\n \t\"testing\"\n )\n \n+// more import examples\n+import (\n+\t\"xxx\"\n+\t\"much longer name\"\t// comment\n+\t\"short name\"\t\t// comment\n+)\n+\n+import (\n+\t_ \"xxx\"\n+\t\"much longer name\"\t// comment\n+)\n+\n+import (\n+\tmymath \"math\"\n+\t\"/foo/bar/long_package_path\"\t// a comment\n+)\n+\n+import (\n+\t\"package_a\"\t// comment\n+\t\"package_b\"\n+\tmy_better_c \"package_c\"\t// comment\n+\t\"package_d\"\t\t// comment\n+\tmy_e \"package_e\"\t// comment\n+\n+\t\"package_a\"\t// comment\n+\t\"package_bb\"\n+\t\"package_ccc\"\t// comment\n+\t\"package_dddd\"\t// comment\n+)\n \n // at least one empty line between declarations of different kind\n-import _\t\"io\"\n+import _ \"io\"\n \n var _ int\n "}, {"sha": "c8b37e12ba49e264fd4a406f7530020f9fe596c6", "filename": "libgo/go/go/printer/testdata/declarations.input", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.input?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -81,6 +81,35 @@ import (\n \t\"testing\"\n )\n \n+// more import examples\n+import (\n+\t\"xxx\"\n+\t\"much longer name\" // comment\n+\t\"short name\" // comment\n+)\n+\n+import (\n+\t_ \"xxx\"\n+\t\"much longer name\" // comment\n+)\n+\n+import (\n+\tmymath \"math\"\n+\t\"/foo/bar/long_package_path\" // a comment\n+)\n+\n+import (\n+\t\"package_a\" // comment\n+\t\"package_b\"\n+\tmy_better_c \"package_c\" // comment\n+\t\"package_d\" // comment\n+\tmy_e \"package_e\" // comment\n+\n+\t\"package_a\"    // comment\n+\t\"package_bb\"\n+\t\"package_ccc\"  // comment\n+\t\"package_dddd\" // comment\n+)\n \n // at least one empty line between declarations of different kind\n import _ \"io\""}, {"sha": "3d0f144e10f31204a7b01a605020b057f25442f7", "filename": "libgo/go/go/printer/testdata/expressions.golden", "status": "modified", "additions": 58, "deletions": 39, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.golden?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -94,30 +94,49 @@ func _() {\n \t_ = under_bar - 1\n \t_ = Open(dpath+\"/file\", O_WRONLY|O_CREAT, 0666)\n \t_ = int(c0&_Mask4)<<18 | int(c1&_Maskx)<<12 | int(c2&_Maskx)<<6 | int(c3&_Maskx)\n-}\n-\n \n-func _() {\n+\t// the parser does not restrict expressions that may appear as statements\n+\ttrue\n+\t42\n+\t\"foo\"\n+\tx\n+\t(x)\n \ta + b\n \ta + b + c\n-\ta + b*c\n \ta + (b * c)\n-\t(a + b) * c\n-\ta + (b * c * d)\n-\ta + (b*c + d)\n+\ta + (b / c)\n+\t1 + a\n+\ta + 1\n+\ts[a]\n+\tx << 1\n+\t(s[0] << 1) & 0xf\n+\t\"foo\" + s\n+\tx == y\n+\tx < y || z > 42\n+}\n+\n+\n+func _() {\n+\t_ = a + b\n+\t_ = a + b + c\n+\t_ = a + b*c\n+\t_ = a + (b * c)\n+\t_ = (a + b) * c\n+\t_ = a + (b * c * d)\n+\t_ = a + (b*c + d)\n \n-\t1 << x\n-\t-1 << x\n-\t1<<x - 1\n-\t-1<<x - 1\n+\t_ = 1 << x\n+\t_ = -1 << x\n+\t_ = 1<<x - 1\n+\t_ = -1<<x - 1\n \n-\tf(a + b)\n-\tf(a + b + c)\n-\tf(a + b*c)\n-\tf(a + (b * c))\n-\tf(1<<x-1, 1<<x-2)\n+\t_ = f(a + b)\n+\t_ = f(a + b + c)\n+\t_ = f(a + b*c)\n+\t_ = f(a + (b * c))\n+\t_ = f(1<<x-1, 1<<x-2)\n \n-\t1<<d.logWindowSize - 1\n+\t_ = 1<<d.logWindowSize - 1\n \n \tbuf = make(x, 2*cap(b.buf)+n)\n \n@@ -131,7 +150,7 @@ func _() {\n \tsigned += ' ' * 8\n \ttw.octal(header[148:155], chksum)\n \n-\tx > 0 && i >= 0\n+\t_ = x > 0 && i >= 0\n \n \tx1, x0 := x>>w2, x&m2\n \tz0 = t1<<w2 + t0\n@@ -141,31 +160,31 @@ func _() {\n \tx1 = (x1 << z) | (x0 >> (uint(w) - z))\n \tx1 = x1<<z | x0>>(uint(w)-z)\n \n-\tbuf[0 : len(buf)+1]\n-\tbuf[0 : n+1]\n+\t_ = buf[0 : len(buf)+1]\n+\t_ = buf[0 : n+1]\n \n \ta, b = b, a\n \ta = b + c\n \ta = b*c + d\n-\ta*b + c\n-\ta - b - c\n-\ta - (b - c)\n-\ta - b*c\n-\ta - (b * c)\n-\ta * b / c\n-\ta / *b\n-\tx[a|^b]\n-\tx[a / *b]\n-\ta & ^b\n-\ta + +b\n-\ta - -b\n-\tx[a*-b]\n-\tx[a + +b]\n-\tx ^ y ^ z\n-\tb[a>>24] ^ b[(a>>16)&0xFF] ^ b[(a>>8)&0xFF] ^ b[a&0xFF]\n-\tlen(longVariableName) * 2\n-\n-\ttoken(matchType + xlength<<lengthShift + xoffset)\n+\t_ = a*b + c\n+\t_ = a - b - c\n+\t_ = a - (b - c)\n+\t_ = a - b*c\n+\t_ = a - (b * c)\n+\t_ = a * b / c\n+\t_ = a / *b\n+\t_ = x[a|^b]\n+\t_ = x[a / *b]\n+\t_ = a & ^b\n+\t_ = a + +b\n+\t_ = a - -b\n+\t_ = x[a*-b]\n+\t_ = x[a + +b]\n+\t_ = x ^ y ^ z\n+\t_ = b[a>>24] ^ b[(a>>16)&0xFF] ^ b[(a>>8)&0xFF] ^ b[a&0xFF]\n+\t_ = len(longVariableName) * 2\n+\n+\t_ = token(matchType + xlength<<lengthShift + xoffset)\n }\n \n "}, {"sha": "d113149835212858ca280826e6acbf6a412e6c71", "filename": "libgo/go/go/printer/testdata/expressions.input", "status": "modified", "additions": 58, "deletions": 39, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.input?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -94,30 +94,49 @@ func _() {\n \t_ = under_bar-1\n \t_ = Open(dpath + \"/file\", O_WRONLY | O_CREAT, 0666)\n \t_ = int(c0&_Mask4)<<18 | int(c1&_Maskx)<<12 | int(c2&_Maskx)<<6 | int(c3&_Maskx)\n-}\n-\n \n-func _() {\n+\t// the parser does not restrict expressions that may appear as statements\n+\ttrue\n+\t42\n+\t\"foo\"\n+\tx\n+\t(x)\n \ta+b\n \ta+b+c\n-\ta+b*c\n \ta+(b*c)\n-\t(a+b)*c\n-\ta+(b*c*d)\n-\ta+(b*c+d)\n+\ta+(b/c)\n+\t1+a\n+\ta+1\n+\ts[a]\n+\tx<<1\n+\t(s[0]<<1)&0xf\n+\t\"foo\"+s\n+\tx == y\n+\tx < y || z > 42\n+}\n \n-\t1<<x\n-\t-1<<x\n-\t1<<x-1\n-\t-1<<x-1\n \n-\tf(a+b)\n-\tf(a+b+c)\n-\tf(a+b*c)\n-\tf(a+(b*c))\n-\tf(1<<x-1, 1<<x-2)\n+func _() {\n+\t_ = a+b\n+\t_ = a+b+c\n+\t_ = a+b*c\n+\t_ = a+(b*c)\n+\t_ = (a+b)*c\n+\t_ = a+(b*c*d)\n+\t_ = a+(b*c+d)\n+\n+\t_ = 1<<x\n+\t_ = -1<<x\n+\t_ = 1<<x-1\n+\t_ = -1<<x-1\n \n-\t1<<d.logWindowSize-1\n+\t_ = f(a+b)\n+\t_ = f(a+b+c)\n+\t_ = f(a+b*c)\n+\t_ = f(a+(b*c))\n+\t_ = f(1<<x-1, 1<<x-2)\n+\n+\t_ = 1<<d.logWindowSize-1\n \n \tbuf = make(x, 2*cap(b.buf) + n)\n \n@@ -131,7 +150,7 @@ func _() {\n \tsigned += ' '*8\n \ttw.octal(header[148:155], chksum)\n \n-\tx > 0 && i >= 0\n+\t_ = x > 0 && i >= 0\n \n \tx1, x0 := x>>w2, x&m2\n \tz0 = t1<<w2+t0\n@@ -141,31 +160,31 @@ func _() {\n \tx1 = (x1<<z)|(x0>>(uint(w)-z))\n \tx1 = x1<<z | x0>>(uint(w)-z)\n \n-\tbuf[0:len(buf)+1]\n-\tbuf[0:n+1]\n+\t_ = buf[0:len(buf)+1]\n+\t_ = buf[0:n+1]\n \n \ta,b = b,a\n \ta = b+c\n \ta = b*c+d\n-\ta*b+c\n-\ta-b-c\n-\ta-(b-c)\n-\ta-b*c\n-\ta-(b*c)\n-\ta*b/c\n-\ta/ *b\n-\tx[a|^b]\n-\tx[a/ *b]\n-\ta& ^b\n-\ta+ +b\n-\ta- -b\n-\tx[a*-b]\n-\tx[a+ +b]\n-\tx^y^z\n-\tb[a>>24] ^ b[(a>>16)&0xFF] ^ b[(a>>8)&0xFF] ^ b[a&0xFF]\n-\tlen(longVariableName)*2\n-\n-\ttoken(matchType + xlength<<lengthShift + xoffset)\n+\t_ = a*b+c\n+\t_ = a-b-c\n+\t_ = a-(b-c)\n+\t_ = a-b*c\n+\t_ = a-(b*c)\n+\t_ = a*b/c\n+\t_ = a/ *b\n+\t_ = x[a|^b]\n+\t_ = x[a/ *b]\n+\t_ = a& ^b\n+\t_ = a+ +b\n+\t_ = a- -b\n+\t_ = x[a*-b]\n+\t_ = x[a+ +b]\n+\t_ = x^y^z\n+\t_ = b[a>>24] ^ b[(a>>16)&0xFF] ^ b[(a>>8)&0xFF] ^ b[a&0xFF]\n+\t_ = len(longVariableName)*2\n+\n+\t_ = token(matchType + xlength<<lengthShift + xoffset)\n }\n \n "}, {"sha": "72ab850fab4698aa913ce34aa190448995ec1f82", "filename": "libgo/go/go/printer/testdata/expressions.raw", "status": "modified", "additions": 58, "deletions": 39, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.raw", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.raw", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.raw?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -94,30 +94,49 @@ func _() {\n \t_ = under_bar - 1\n \t_ = Open(dpath+\"/file\", O_WRONLY|O_CREAT, 0666)\n \t_ = int(c0&_Mask4)<<18 | int(c1&_Maskx)<<12 | int(c2&_Maskx)<<6 | int(c3&_Maskx)\n-}\n-\n \n-func _() {\n+\t// the parser does not restrict expressions that may appear as statements\n+\ttrue\n+\t42\n+\t\"foo\"\n+\tx\n+\t(x)\n \ta + b\n \ta + b + c\n-\ta + b*c\n \ta + (b * c)\n-\t(a + b) * c\n-\ta + (b * c * d)\n-\ta + (b*c + d)\n+\ta + (b / c)\n+\t1 + a\n+\ta + 1\n+\ts[a]\n+\tx << 1\n+\t(s[0] << 1) & 0xf\n+\t\"foo\" + s\n+\tx == y\n+\tx < y || z > 42\n+}\n+\n+\n+func _() {\n+\t_ = a + b\n+\t_ = a + b + c\n+\t_ = a + b*c\n+\t_ = a + (b * c)\n+\t_ = (a + b) * c\n+\t_ = a + (b * c * d)\n+\t_ = a + (b*c + d)\n \n-\t1 << x\n-\t-1 << x\n-\t1<<x - 1\n-\t-1<<x - 1\n+\t_ = 1 << x\n+\t_ = -1 << x\n+\t_ = 1<<x - 1\n+\t_ = -1<<x - 1\n \n-\tf(a + b)\n-\tf(a + b + c)\n-\tf(a + b*c)\n-\tf(a + (b * c))\n-\tf(1<<x-1, 1<<x-2)\n+\t_ = f(a + b)\n+\t_ = f(a + b + c)\n+\t_ = f(a + b*c)\n+\t_ = f(a + (b * c))\n+\t_ = f(1<<x-1, 1<<x-2)\n \n-\t1<<d.logWindowSize - 1\n+\t_ = 1<<d.logWindowSize - 1\n \n \tbuf = make(x, 2*cap(b.buf)+n)\n \n@@ -131,7 +150,7 @@ func _() {\n \tsigned += ' ' * 8\n \ttw.octal(header[148:155], chksum)\n \n-\tx > 0 && i >= 0\n+\t_ = x > 0 && i >= 0\n \n \tx1, x0 := x>>w2, x&m2\n \tz0 = t1<<w2 + t0\n@@ -141,31 +160,31 @@ func _() {\n \tx1 = (x1 << z) | (x0 >> (uint(w) - z))\n \tx1 = x1<<z | x0>>(uint(w)-z)\n \n-\tbuf[0 : len(buf)+1]\n-\tbuf[0 : n+1]\n+\t_ = buf[0 : len(buf)+1]\n+\t_ = buf[0 : n+1]\n \n \ta, b = b, a\n \ta = b + c\n \ta = b*c + d\n-\ta*b + c\n-\ta - b - c\n-\ta - (b - c)\n-\ta - b*c\n-\ta - (b * c)\n-\ta * b / c\n-\ta / *b\n-\tx[a|^b]\n-\tx[a / *b]\n-\ta & ^b\n-\ta + +b\n-\ta - -b\n-\tx[a*-b]\n-\tx[a + +b]\n-\tx ^ y ^ z\n-\tb[a>>24] ^ b[(a>>16)&0xFF] ^ b[(a>>8)&0xFF] ^ b[a&0xFF]\n-\tlen(longVariableName) * 2\n-\n-\ttoken(matchType + xlength<<lengthShift + xoffset)\n+\t_ = a*b + c\n+\t_ = a - b - c\n+\t_ = a - (b - c)\n+\t_ = a - b*c\n+\t_ = a - (b * c)\n+\t_ = a * b / c\n+\t_ = a / *b\n+\t_ = x[a|^b]\n+\t_ = x[a / *b]\n+\t_ = a & ^b\n+\t_ = a + +b\n+\t_ = a - -b\n+\t_ = x[a*-b]\n+\t_ = x[a + +b]\n+\t_ = x ^ y ^ z\n+\t_ = b[a>>24] ^ b[(a>>16)&0xFF] ^ b[(a>>8)&0xFF] ^ b[a&0xFF]\n+\t_ = len(longVariableName) * 2\n+\n+\t_ = token(matchType + xlength<<lengthShift + xoffset)\n }\n \n "}, {"sha": "5c57e41d130fa5fe7f39f5a5e593db23870adea2", "filename": "libgo/go/go/printer/testdata/parser.go", "status": "added", "additions": 2252, "deletions": 0, "changes": 2252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fparser.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -0,0 +1,2252 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package parser implements a parser for Go source files. Input may be\n+// provided in a variety of forms (see the various Parse* functions); the\n+// output is an abstract syntax tree (AST) representing the Go source. The\n+// parser is invoked through one of the Parse* functions.\n+//\n+package parser\n+\n+import (\n+\t\"fmt\"\n+\t\"go/ast\"\n+\t\"go/scanner\"\n+\t\"go/token\"\n+)\n+\n+\n+// The mode parameter to the Parse* functions is a set of flags (or 0).\n+// They control the amount of source code parsed and other optional\n+// parser functionality.\n+//\n+const (\n+\tPackageClauseOnly uint = 1 << iota // parsing stops after package clause\n+\tImportsOnly                        // parsing stops after import declarations\n+\tParseComments                      // parse comments and add them to AST\n+\tTrace                              // print a trace of parsed productions\n+\tDeclarationErrors                  // report declaration errors\n+)\n+\n+\n+// The parser structure holds the parser's internal state.\n+type parser struct {\n+\tfile *token.File\n+\tscanner.ErrorVector\n+\tscanner scanner.Scanner\n+\n+\t// Tracing/debugging\n+\tmode   uint // parsing mode\n+\ttrace  bool // == (mode & Trace != 0)\n+\tindent uint // indentation used for tracing output\n+\n+\t// Comments\n+\tcomments    []*ast.CommentGroup\n+\tleadComment *ast.CommentGroup // last lead comment\n+\tlineComment *ast.CommentGroup // last line comment\n+\n+\t// Next token\n+\tpos token.Pos   // token position\n+\ttok token.Token // one token look-ahead\n+\tlit string      // token literal\n+\n+\t// Non-syntactic parser control\n+\texprLev int // < 0: in control clause, >= 0: in expression\n+\n+\t// Ordinary identifer scopes\n+\tpkgScope   *ast.Scope        // pkgScope.Outer == nil\n+\ttopScope   *ast.Scope        // top-most scope; may be pkgScope\n+\tunresolved []*ast.Ident      // unresolved identifiers\n+\timports    []*ast.ImportSpec // list of imports\n+\n+\t// Label scope\n+\t// (maintained by open/close LabelScope)\n+\tlabelScope  *ast.Scope     // label scope for current function\n+\ttargetStack [][]*ast.Ident // stack of unresolved labels\n+}\n+\n+\n+// scannerMode returns the scanner mode bits given the parser's mode bits.\n+func scannerMode(mode uint) uint {\n+\tvar m uint = scanner.InsertSemis\n+\tif mode&ParseComments != 0 {\n+\t\tm |= scanner.ScanComments\n+\t}\n+\treturn m\n+}\n+\n+\n+func (p *parser) init(fset *token.FileSet, filename string, src []byte, mode uint) {\n+\tp.file = fset.AddFile(filename, fset.Base(), len(src))\n+\tp.scanner.Init(p.file, src, p, scannerMode(mode))\n+\n+\tp.mode = mode\n+\tp.trace = mode&Trace != 0 // for convenience (p.trace is used frequently)\n+\n+\tp.next()\n+\n+\t// set up the pkgScope here (as opposed to in parseFile) because\n+\t// there are other parser entry points (ParseExpr, etc.)\n+\tp.openScope()\n+\tp.pkgScope = p.topScope\n+\n+\t// for the same reason, set up a label scope\n+\tp.openLabelScope()\n+}\n+\n+\n+// ----------------------------------------------------------------------------\n+// Scoping support\n+\n+func (p *parser) openScope() {\n+\tp.topScope = ast.NewScope(p.topScope)\n+}\n+\n+\n+func (p *parser) closeScope() {\n+\tp.topScope = p.topScope.Outer\n+}\n+\n+\n+func (p *parser) openLabelScope() {\n+\tp.labelScope = ast.NewScope(p.labelScope)\n+\tp.targetStack = append(p.targetStack, nil)\n+}\n+\n+\n+func (p *parser) closeLabelScope() {\n+\t// resolve labels\n+\tn := len(p.targetStack) - 1\n+\tscope := p.labelScope\n+\tfor _, ident := range p.targetStack[n] {\n+\t\tident.Obj = scope.Lookup(ident.Name)\n+\t\tif ident.Obj == nil && p.mode&DeclarationErrors != 0 {\n+\t\t\tp.error(ident.Pos(), fmt.Sprintf(\"label %s undefined\", ident.Name))\n+\t\t}\n+\t}\n+\t// pop label scope\n+\tp.targetStack = p.targetStack[0:n]\n+\tp.labelScope = p.labelScope.Outer\n+}\n+\n+\n+func (p *parser) declare(decl interface{}, scope *ast.Scope, kind ast.ObjKind, idents ...*ast.Ident) {\n+\tfor _, ident := range idents {\n+\t\tassert(ident.Obj == nil, \"identifier already declared or resolved\")\n+\t\tif ident.Name != \"_\" {\n+\t\t\tobj := ast.NewObj(kind, ident.Name)\n+\t\t\t// remember the corresponding declaration for redeclaration\n+\t\t\t// errors and global variable resolution/typechecking phase\n+\t\t\tobj.Decl = decl\n+\t\t\tif alt := scope.Insert(obj); alt != nil && p.mode&DeclarationErrors != 0 {\n+\t\t\t\tprevDecl := \"\"\n+\t\t\t\tif pos := alt.Pos(); pos.IsValid() {\n+\t\t\t\t\tprevDecl = fmt.Sprintf(\"\\n\\tprevious declaration at %s\", p.file.Position(pos))\n+\t\t\t\t}\n+\t\t\t\tp.error(ident.Pos(), fmt.Sprintf(\"%s redeclared in this block%s\", ident.Name, prevDecl))\n+\t\t\t}\n+\t\t\tident.Obj = obj\n+\t\t}\n+\t}\n+}\n+\n+\n+func (p *parser) shortVarDecl(idents []*ast.Ident) {\n+\t// Go spec: A short variable declaration may redeclare variables\n+\t// provided they were originally declared in the same block with\n+\t// the same type, and at least one of the non-blank variables is new.\n+\tn := 0 // number of new variables\n+\tfor _, ident := range idents {\n+\t\tassert(ident.Obj == nil, \"identifier already declared or resolved\")\n+\t\tif ident.Name != \"_\" {\n+\t\t\tobj := ast.NewObj(ast.Var, ident.Name)\n+\t\t\t// short var declarations cannot have redeclaration errors\n+\t\t\t// and are not global => no need to remember the respective\n+\t\t\t// declaration\n+\t\t\talt := p.topScope.Insert(obj)\n+\t\t\tif alt == nil {\n+\t\t\t\tn++ // new declaration\n+\t\t\t\talt = obj\n+\t\t\t}\n+\t\t\tident.Obj = alt\n+\t\t}\n+\t}\n+\tif n == 0 && p.mode&DeclarationErrors != 0 {\n+\t\tp.error(idents[0].Pos(), \"no new variables on left side of :=\")\n+\t}\n+}\n+\n+\n+// The unresolved object is a sentinel to mark identifiers that have been added\n+// to the list of unresolved identifiers. The sentinel is only used for verifying\n+// internal consistency.\n+var unresolved = new(ast.Object)\n+\n+\n+func (p *parser) resolve(x ast.Expr) {\n+\t// nothing to do if x is not an identifier or the blank identifier\n+\tident, _ := x.(*ast.Ident)\n+\tif ident == nil {\n+\t\treturn\n+\t}\n+\tassert(ident.Obj == nil, \"identifier already declared or resolved\")\n+\tif ident.Name == \"_\" {\n+\t\treturn\n+\t}\n+\t// try to resolve the identifier\n+\tfor s := p.topScope; s != nil; s = s.Outer {\n+\t\tif obj := s.Lookup(ident.Name); obj != nil {\n+\t\t\tident.Obj = obj\n+\t\t\treturn\n+\t\t}\n+\t}\n+\t// all local scopes are known, so any unresolved identifier\n+\t// must be found either in the file scope, package scope\n+\t// (perhaps in another file), or universe scope --- collect\n+\t// them so that they can be resolved later\n+\tident.Obj = unresolved\n+\tp.unresolved = append(p.unresolved, ident)\n+}\n+\n+\n+// ----------------------------------------------------------------------------\n+// Parsing support\n+\n+func (p *parser) printTrace(a ...interface{}) {\n+\tconst dots = \". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \" +\n+\t\t\". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \"\n+\tconst n = uint(len(dots))\n+\tpos := p.file.Position(p.pos)\n+\tfmt.Printf(\"%5d:%3d: \", pos.Line, pos.Column)\n+\ti := 2 * p.indent\n+\tfor ; i > n; i -= n {\n+\t\tfmt.Print(dots)\n+\t}\n+\tfmt.Print(dots[0:i])\n+\tfmt.Println(a...)\n+}\n+\n+\n+func trace(p *parser, msg string) *parser {\n+\tp.printTrace(msg, \"(\")\n+\tp.indent++\n+\treturn p\n+}\n+\n+\n+// Usage pattern: defer un(trace(p, \"...\"));\n+func un(p *parser) {\n+\tp.indent--\n+\tp.printTrace(\")\")\n+}\n+\n+\n+// Advance to the next token.\n+func (p *parser) next0() {\n+\t// Because of one-token look-ahead, print the previous token\n+\t// when tracing as it provides a more readable output. The\n+\t// very first token (!p.pos.IsValid()) is not initialized\n+\t// (it is token.ILLEGAL), so don't print it .\n+\tif p.trace && p.pos.IsValid() {\n+\t\ts := p.tok.String()\n+\t\tswitch {\n+\t\tcase p.tok.IsLiteral():\n+\t\t\tp.printTrace(s, p.lit)\n+\t\tcase p.tok.IsOperator(), p.tok.IsKeyword():\n+\t\t\tp.printTrace(\"\\\"\" + s + \"\\\"\")\n+\t\tdefault:\n+\t\t\tp.printTrace(s)\n+\t\t}\n+\t}\n+\n+\tp.pos, p.tok, p.lit = p.scanner.Scan()\n+}\n+\n+// Consume a comment and return it and the line on which it ends.\n+func (p *parser) consumeComment() (comment *ast.Comment, endline int) {\n+\t// /*-style comments may end on a different line than where they start.\n+\t// Scan the comment for '\\n' chars and adjust endline accordingly.\n+\tendline = p.file.Line(p.pos)\n+\tif p.lit[1] == '*' {\n+\t\t// don't use range here - no need to decode Unicode code points\n+\t\tfor i := 0; i < len(p.lit); i++ {\n+\t\t\tif p.lit[i] == '\\n' {\n+\t\t\t\tendline++\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tcomment = &ast.Comment{p.pos, p.lit}\n+\tp.next0()\n+\n+\treturn\n+}\n+\n+\n+// Consume a group of adjacent comments, add it to the parser's\n+// comments list, and return it together with the line at which\n+// the last comment in the group ends. An empty line or non-comment\n+// token terminates a comment group.\n+//\n+func (p *parser) consumeCommentGroup() (comments *ast.CommentGroup, endline int) {\n+\tvar list []*ast.Comment\n+\tendline = p.file.Line(p.pos)\n+\tfor p.tok == token.COMMENT && endline+1 >= p.file.Line(p.pos) {\n+\t\tvar comment *ast.Comment\n+\t\tcomment, endline = p.consumeComment()\n+\t\tlist = append(list, comment)\n+\t}\n+\n+\t// add comment group to the comments list\n+\tcomments = &ast.CommentGroup{list}\n+\tp.comments = append(p.comments, comments)\n+\n+\treturn\n+}\n+\n+\n+// Advance to the next non-comment token. In the process, collect\n+// any comment groups encountered, and remember the last lead and\n+// and line comments.\n+//\n+// A lead comment is a comment group that starts and ends in a\n+// line without any other tokens and that is followed by a non-comment\n+// token on the line immediately after the comment group.\n+//\n+// A line comment is a comment group that follows a non-comment\n+// token on the same line, and that has no tokens after it on the line\n+// where it ends.\n+//\n+// Lead and line comments may be considered documentation that is\n+// stored in the AST.\n+//\n+func (p *parser) next() {\n+\tp.leadComment = nil\n+\tp.lineComment = nil\n+\tline := p.file.Line(p.pos) // current line\n+\tp.next0()\n+\n+\tif p.tok == token.COMMENT {\n+\t\tvar comment *ast.CommentGroup\n+\t\tvar endline int\n+\n+\t\tif p.file.Line(p.pos) == line {\n+\t\t\t// The comment is on same line as the previous token; it\n+\t\t\t// cannot be a lead comment but may be a line comment.\n+\t\t\tcomment, endline = p.consumeCommentGroup()\n+\t\t\tif p.file.Line(p.pos) != endline {\n+\t\t\t\t// The next token is on a different line, thus\n+\t\t\t\t// the last comment group is a line comment.\n+\t\t\t\tp.lineComment = comment\n+\t\t\t}\n+\t\t}\n+\n+\t\t// consume successor comments, if any\n+\t\tendline = -1\n+\t\tfor p.tok == token.COMMENT {\n+\t\t\tcomment, endline = p.consumeCommentGroup()\n+\t\t}\n+\n+\t\tif endline+1 == p.file.Line(p.pos) {\n+\t\t\t// The next token is following on the line immediately after the\n+\t\t\t// comment group, thus the last comment group is a lead comment.\n+\t\t\tp.leadComment = comment\n+\t\t}\n+\t}\n+}\n+\n+\n+func (p *parser) error(pos token.Pos, msg string) {\n+\tp.Error(p.file.Position(pos), msg)\n+}\n+\n+\n+func (p *parser) errorExpected(pos token.Pos, msg string) {\n+\tmsg = \"expected \" + msg\n+\tif pos == p.pos {\n+\t\t// the error happened at the current position;\n+\t\t// make the error message more specific\n+\t\tif p.tok == token.SEMICOLON && p.lit[0] == '\\n' {\n+\t\t\tmsg += \", found newline\"\n+\t\t} else {\n+\t\t\tmsg += \", found '\" + p.tok.String() + \"'\"\n+\t\t\tif p.tok.IsLiteral() {\n+\t\t\t\tmsg += \" \" + p.lit\n+\t\t\t}\n+\t\t}\n+\t}\n+\tp.error(pos, msg)\n+}\n+\n+\n+func (p *parser) expect(tok token.Token) token.Pos {\n+\tpos := p.pos\n+\tif p.tok != tok {\n+\t\tp.errorExpected(pos, \"'\"+tok.String()+\"'\")\n+\t}\n+\tp.next() // make progress\n+\treturn pos\n+}\n+\n+\n+func (p *parser) expectSemi() {\n+\tif p.tok != token.RPAREN && p.tok != token.RBRACE {\n+\t\tp.expect(token.SEMICOLON)\n+\t}\n+}\n+\n+\n+func assert(cond bool, msg string) {\n+\tif !cond {\n+\t\tpanic(\"go/parser internal error: \" + msg)\n+\t}\n+}\n+\n+\n+// ----------------------------------------------------------------------------\n+// Identifiers\n+\n+func (p *parser) parseIdent() *ast.Ident {\n+\tpos := p.pos\n+\tname := \"_\"\n+\tif p.tok == token.IDENT {\n+\t\tname = p.lit\n+\t\tp.next()\n+\t} else {\n+\t\tp.expect(token.IDENT) // use expect() error handling\n+\t}\n+\treturn &ast.Ident{pos, name, nil}\n+}\n+\n+\n+func (p *parser) parseIdentList() (list []*ast.Ident) {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"IdentList\"))\n+\t}\n+\n+\tlist = append(list, p.parseIdent())\n+\tfor p.tok == token.COMMA {\n+\t\tp.next()\n+\t\tlist = append(list, p.parseIdent())\n+\t}\n+\n+\treturn\n+}\n+\n+\n+// ----------------------------------------------------------------------------\n+// Common productions\n+\n+// If lhs is set, result list elements which are identifiers are not resolved.\n+func (p *parser) parseExprList(lhs bool) (list []ast.Expr) {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"ExpressionList\"))\n+\t}\n+\n+\tlist = append(list, p.parseExpr(lhs))\n+\tfor p.tok == token.COMMA {\n+\t\tp.next()\n+\t\tlist = append(list, p.parseExpr(lhs))\n+\t}\n+\n+\treturn\n+}\n+\n+\n+func (p *parser) parseLhsList() []ast.Expr {\n+\tlist := p.parseExprList(true)\n+\tswitch p.tok {\n+\tcase token.DEFINE:\n+\t\t// lhs of a short variable declaration\n+\t\tp.shortVarDecl(p.makeIdentList(list))\n+\tcase token.COLON:\n+\t\t// lhs of a label declaration or a communication clause of a select\n+\t\t// statement (parseLhsList is not called when parsing the case clause\n+\t\t// of a switch statement):\n+\t\t// - labels are declared by the caller of parseLhsList\n+\t\t// - for communication clauses, if there is a stand-alone identifier\n+\t\t//   followed by a colon, we have a syntax error; there is no need\n+\t\t//   to resolve the identifier in that case\n+\tdefault:\n+\t\t// identifiers must be declared elsewhere\n+\t\tfor _, x := range list {\n+\t\t\tp.resolve(x)\n+\t\t}\n+\t}\n+\treturn list\n+}\n+\n+\n+func (p *parser) parseRhsList() []ast.Expr {\n+\treturn p.parseExprList(false)\n+}\n+\n+\n+// ----------------------------------------------------------------------------\n+// Types\n+\n+func (p *parser) parseType() ast.Expr {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"Type\"))\n+\t}\n+\n+\ttyp := p.tryType()\n+\n+\tif typ == nil {\n+\t\tpos := p.pos\n+\t\tp.errorExpected(pos, \"type\")\n+\t\tp.next() // make progress\n+\t\treturn &ast.BadExpr{pos, p.pos}\n+\t}\n+\n+\treturn typ\n+}\n+\n+\n+// If the result is an identifier, it is not resolved.\n+func (p *parser) parseTypeName() ast.Expr {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"TypeName\"))\n+\t}\n+\n+\tident := p.parseIdent()\n+\t// don't resolve ident yet - it may be a parameter or field name\n+\n+\tif p.tok == token.PERIOD {\n+\t\t// ident is a package name\n+\t\tp.next()\n+\t\tp.resolve(ident)\n+\t\tsel := p.parseIdent()\n+\t\treturn &ast.SelectorExpr{ident, sel}\n+\t}\n+\n+\treturn ident\n+}\n+\n+\n+func (p *parser) parseArrayType(ellipsisOk bool) ast.Expr {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"ArrayType\"))\n+\t}\n+\n+\tlbrack := p.expect(token.LBRACK)\n+\tvar len ast.Expr\n+\tif ellipsisOk && p.tok == token.ELLIPSIS {\n+\t\tlen = &ast.Ellipsis{p.pos, nil}\n+\t\tp.next()\n+\t} else if p.tok != token.RBRACK {\n+\t\tlen = p.parseRhs()\n+\t}\n+\tp.expect(token.RBRACK)\n+\telt := p.parseType()\n+\n+\treturn &ast.ArrayType{lbrack, len, elt}\n+}\n+\n+\n+func (p *parser) makeIdentList(list []ast.Expr) []*ast.Ident {\n+\tidents := make([]*ast.Ident, len(list))\n+\tfor i, x := range list {\n+\t\tident, isIdent := x.(*ast.Ident)\n+\t\tif !isIdent {\n+\t\t\tpos := x.(ast.Expr).Pos()\n+\t\t\tp.errorExpected(pos, \"identifier\")\n+\t\t\tident = &ast.Ident{pos, \"_\", nil}\n+\t\t}\n+\t\tidents[i] = ident\n+\t}\n+\treturn idents\n+}\n+\n+\n+func (p *parser) parseFieldDecl(scope *ast.Scope) *ast.Field {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"FieldDecl\"))\n+\t}\n+\n+\tdoc := p.leadComment\n+\n+\t// fields\n+\tlist, typ := p.parseVarList(false)\n+\n+\t// optional tag\n+\tvar tag *ast.BasicLit\n+\tif p.tok == token.STRING {\n+\t\ttag = &ast.BasicLit{p.pos, p.tok, p.lit}\n+\t\tp.next()\n+\t}\n+\n+\t// analyze case\n+\tvar idents []*ast.Ident\n+\tif typ != nil {\n+\t\t// IdentifierList Type\n+\t\tidents = p.makeIdentList(list)\n+\t} else {\n+\t\t// [\"*\"] TypeName (AnonymousField)\n+\t\ttyp = list[0] // we always have at least one element\n+\t\tp.resolve(typ)\n+\t\tif n := len(list); n > 1 || !isTypeName(deref(typ)) {\n+\t\t\tpos := typ.Pos()\n+\t\t\tp.errorExpected(pos, \"anonymous field\")\n+\t\t\ttyp = &ast.BadExpr{pos, list[n-1].End()}\n+\t\t}\n+\t}\n+\n+\tp.expectSemi() // call before accessing p.linecomment\n+\n+\tfield := &ast.Field{doc, idents, typ, tag, p.lineComment}\n+\tp.declare(field, scope, ast.Var, idents...)\n+\n+\treturn field\n+}\n+\n+\n+func (p *parser) parseStructType() *ast.StructType {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"StructType\"))\n+\t}\n+\n+\tpos := p.expect(token.STRUCT)\n+\tlbrace := p.expect(token.LBRACE)\n+\tscope := ast.NewScope(nil) // struct scope\n+\tvar list []*ast.Field\n+\tfor p.tok == token.IDENT || p.tok == token.MUL || p.tok == token.LPAREN {\n+\t\t// a field declaration cannot start with a '(' but we accept\n+\t\t// it here for more robust parsing and better error messages\n+\t\t// (parseFieldDecl will check and complain if necessary)\n+\t\tlist = append(list, p.parseFieldDecl(scope))\n+\t}\n+\trbrace := p.expect(token.RBRACE)\n+\n+\t// TODO(gri): store struct scope in AST\n+\treturn &ast.StructType{pos, &ast.FieldList{lbrace, list, rbrace}, false}\n+}\n+\n+\n+func (p *parser) parsePointerType() *ast.StarExpr {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"PointerType\"))\n+\t}\n+\n+\tstar := p.expect(token.MUL)\n+\tbase := p.parseType()\n+\n+\treturn &ast.StarExpr{star, base}\n+}\n+\n+\n+func (p *parser) tryVarType(isParam bool) ast.Expr {\n+\tif isParam && p.tok == token.ELLIPSIS {\n+\t\tpos := p.pos\n+\t\tp.next()\n+\t\ttyp := p.tryIdentOrType(isParam) // don't use parseType so we can provide better error message\n+\t\tif typ == nil {\n+\t\t\tp.error(pos, \"'...' parameter is missing type\")\n+\t\t\ttyp = &ast.BadExpr{pos, p.pos}\n+\t\t}\n+\t\tif p.tok != token.RPAREN {\n+\t\t\tp.error(pos, \"can use '...' with last parameter type only\")\n+\t\t}\n+\t\treturn &ast.Ellipsis{pos, typ}\n+\t}\n+\treturn p.tryIdentOrType(false)\n+}\n+\n+\n+func (p *parser) parseVarType(isParam bool) ast.Expr {\n+\ttyp := p.tryVarType(isParam)\n+\tif typ == nil {\n+\t\tpos := p.pos\n+\t\tp.errorExpected(pos, \"type\")\n+\t\tp.next() // make progress\n+\t\ttyp = &ast.BadExpr{pos, p.pos}\n+\t}\n+\treturn typ\n+}\n+\n+\n+func (p *parser) parseVarList(isParam bool) (list []ast.Expr, typ ast.Expr) {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"VarList\"))\n+\t}\n+\n+\t// a list of identifiers looks like a list of type names\n+\tfor {\n+\t\t// parseVarType accepts any type (including parenthesized ones)\n+\t\t// even though the syntax does not permit them here: we\n+\t\t// accept them all for more robust parsing and complain\n+\t\t// afterwards\n+\t\tlist = append(list, p.parseVarType(isParam))\n+\t\tif p.tok != token.COMMA {\n+\t\t\tbreak\n+\t\t}\n+\t\tp.next()\n+\t}\n+\n+\t// if we had a list of identifiers, it must be followed by a type\n+\ttyp = p.tryVarType(isParam)\n+\tif typ != nil {\n+\t\tp.resolve(typ)\n+\t}\n+\n+\treturn\n+}\n+\n+\n+func (p *parser) parseParameterList(scope *ast.Scope, ellipsisOk bool) (params []*ast.Field) {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"ParameterList\"))\n+\t}\n+\n+\tlist, typ := p.parseVarList(ellipsisOk)\n+\tif typ != nil {\n+\t\t// IdentifierList Type\n+\t\tidents := p.makeIdentList(list)\n+\t\tfield := &ast.Field{nil, idents, typ, nil, nil}\n+\t\tparams = append(params, field)\n+\t\t// Go spec: The scope of an identifier denoting a function\n+\t\t// parameter or result variable is the function body.\n+\t\tp.declare(field, scope, ast.Var, idents...)\n+\t\tif p.tok == token.COMMA {\n+\t\t\tp.next()\n+\t\t}\n+\n+\t\tfor p.tok != token.RPAREN && p.tok != token.EOF {\n+\t\t\tidents := p.parseIdentList()\n+\t\t\ttyp := p.parseVarType(ellipsisOk)\n+\t\t\tfield := &ast.Field{nil, idents, typ, nil, nil}\n+\t\t\tparams = append(params, field)\n+\t\t\t// Go spec: The scope of an identifier denoting a function\n+\t\t\t// parameter or result variable is the function body.\n+\t\t\tp.declare(field, scope, ast.Var, idents...)\n+\t\t\tif p.tok != token.COMMA {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tp.next()\n+\t\t}\n+\n+\t} else {\n+\t\t// Type { \",\" Type } (anonymous parameters)\n+\t\tparams = make([]*ast.Field, len(list))\n+\t\tfor i, x := range list {\n+\t\t\tp.resolve(x)\n+\t\t\tparams[i] = &ast.Field{Type: x}\n+\t\t}\n+\t}\n+\n+\treturn\n+}\n+\n+\n+func (p *parser) parseParameters(scope *ast.Scope, ellipsisOk bool) *ast.FieldList {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"Parameters\"))\n+\t}\n+\n+\tvar params []*ast.Field\n+\tlparen := p.expect(token.LPAREN)\n+\tif p.tok != token.RPAREN {\n+\t\tparams = p.parseParameterList(scope, ellipsisOk)\n+\t}\n+\trparen := p.expect(token.RPAREN)\n+\n+\treturn &ast.FieldList{lparen, params, rparen}\n+}\n+\n+\n+func (p *parser) parseResult(scope *ast.Scope) *ast.FieldList {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"Result\"))\n+\t}\n+\n+\tif p.tok == token.LPAREN {\n+\t\treturn p.parseParameters(scope, false)\n+\t}\n+\n+\ttyp := p.tryType()\n+\tif typ != nil {\n+\t\tlist := make([]*ast.Field, 1)\n+\t\tlist[0] = &ast.Field{Type: typ}\n+\t\treturn &ast.FieldList{List: list}\n+\t}\n+\n+\treturn nil\n+}\n+\n+\n+func (p *parser) parseSignature(scope *ast.Scope) (params, results *ast.FieldList) {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"Signature\"))\n+\t}\n+\n+\tparams = p.parseParameters(scope, true)\n+\tresults = p.parseResult(scope)\n+\n+\treturn\n+}\n+\n+\n+func (p *parser) parseFuncType() (*ast.FuncType, *ast.Scope) {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"FuncType\"))\n+\t}\n+\n+\tpos := p.expect(token.FUNC)\n+\tscope := ast.NewScope(p.topScope) // function scope\n+\tparams, results := p.parseSignature(scope)\n+\n+\treturn &ast.FuncType{pos, params, results}, scope\n+}\n+\n+\n+func (p *parser) parseMethodSpec(scope *ast.Scope) *ast.Field {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"MethodSpec\"))\n+\t}\n+\n+\tdoc := p.leadComment\n+\tvar idents []*ast.Ident\n+\tvar typ ast.Expr\n+\tx := p.parseTypeName()\n+\tif ident, isIdent := x.(*ast.Ident); isIdent && p.tok == token.LPAREN {\n+\t\t// method\n+\t\tidents = []*ast.Ident{ident}\n+\t\tscope := ast.NewScope(nil) // method scope\n+\t\tparams, results := p.parseSignature(scope)\n+\t\ttyp = &ast.FuncType{token.NoPos, params, results}\n+\t} else {\n+\t\t// embedded interface\n+\t\ttyp = x\n+\t}\n+\tp.expectSemi() // call before accessing p.linecomment\n+\n+\tspec := &ast.Field{doc, idents, typ, nil, p.lineComment}\n+\tp.declare(spec, scope, ast.Fun, idents...)\n+\n+\treturn spec\n+}\n+\n+\n+func (p *parser) parseInterfaceType() *ast.InterfaceType {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"InterfaceType\"))\n+\t}\n+\n+\tpos := p.expect(token.INTERFACE)\n+\tlbrace := p.expect(token.LBRACE)\n+\tscope := ast.NewScope(nil) // interface scope\n+\tvar list []*ast.Field\n+\tfor p.tok == token.IDENT {\n+\t\tlist = append(list, p.parseMethodSpec(scope))\n+\t}\n+\trbrace := p.expect(token.RBRACE)\n+\n+\t// TODO(gri): store interface scope in AST\n+\treturn &ast.InterfaceType{pos, &ast.FieldList{lbrace, list, rbrace}, false}\n+}\n+\n+\n+func (p *parser) parseMapType() *ast.MapType {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"MapType\"))\n+\t}\n+\n+\tpos := p.expect(token.MAP)\n+\tp.expect(token.LBRACK)\n+\tkey := p.parseType()\n+\tp.expect(token.RBRACK)\n+\tvalue := p.parseType()\n+\n+\treturn &ast.MapType{pos, key, value}\n+}\n+\n+\n+func (p *parser) parseChanType() *ast.ChanType {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"ChanType\"))\n+\t}\n+\n+\tpos := p.pos\n+\tdir := ast.SEND | ast.RECV\n+\tif p.tok == token.CHAN {\n+\t\tp.next()\n+\t\tif p.tok == token.ARROW {\n+\t\t\tp.next()\n+\t\t\tdir = ast.SEND\n+\t\t}\n+\t} else {\n+\t\tp.expect(token.ARROW)\n+\t\tp.expect(token.CHAN)\n+\t\tdir = ast.RECV\n+\t}\n+\tvalue := p.parseType()\n+\n+\treturn &ast.ChanType{pos, dir, value}\n+}\n+\n+\n+// If the result is an identifier, it is not resolved.\n+func (p *parser) tryIdentOrType(ellipsisOk bool) ast.Expr {\n+\tswitch p.tok {\n+\tcase token.IDENT:\n+\t\treturn p.parseTypeName()\n+\tcase token.LBRACK:\n+\t\treturn p.parseArrayType(ellipsisOk)\n+\tcase token.STRUCT:\n+\t\treturn p.parseStructType()\n+\tcase token.MUL:\n+\t\treturn p.parsePointerType()\n+\tcase token.FUNC:\n+\t\ttyp, _ := p.parseFuncType()\n+\t\treturn typ\n+\tcase token.INTERFACE:\n+\t\treturn p.parseInterfaceType()\n+\tcase token.MAP:\n+\t\treturn p.parseMapType()\n+\tcase token.CHAN, token.ARROW:\n+\t\treturn p.parseChanType()\n+\tcase token.LPAREN:\n+\t\tlparen := p.pos\n+\t\tp.next()\n+\t\ttyp := p.parseType()\n+\t\trparen := p.expect(token.RPAREN)\n+\t\treturn &ast.ParenExpr{lparen, typ, rparen}\n+\t}\n+\n+\t// no type found\n+\treturn nil\n+}\n+\n+\n+func (p *parser) tryType() ast.Expr {\n+\ttyp := p.tryIdentOrType(false)\n+\tif typ != nil {\n+\t\tp.resolve(typ)\n+\t}\n+\treturn typ\n+}\n+\n+\n+// ----------------------------------------------------------------------------\n+// Blocks\n+\n+func (p *parser) parseStmtList() (list []ast.Stmt) {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"StatementList\"))\n+\t}\n+\n+\tfor p.tok != token.CASE && p.tok != token.DEFAULT && p.tok != token.RBRACE && p.tok != token.EOF {\n+\t\tlist = append(list, p.parseStmt())\n+\t}\n+\n+\treturn\n+}\n+\n+\n+func (p *parser) parseBody(scope *ast.Scope) *ast.BlockStmt {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"Body\"))\n+\t}\n+\n+\tlbrace := p.expect(token.LBRACE)\n+\tp.topScope = scope // open function scope\n+\tp.openLabelScope()\n+\tlist := p.parseStmtList()\n+\tp.closeLabelScope()\n+\tp.closeScope()\n+\trbrace := p.expect(token.RBRACE)\n+\n+\treturn &ast.BlockStmt{lbrace, list, rbrace}\n+}\n+\n+\n+func (p *parser) parseBlockStmt() *ast.BlockStmt {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"BlockStmt\"))\n+\t}\n+\n+\tlbrace := p.expect(token.LBRACE)\n+\tp.openScope()\n+\tlist := p.parseStmtList()\n+\tp.closeScope()\n+\trbrace := p.expect(token.RBRACE)\n+\n+\treturn &ast.BlockStmt{lbrace, list, rbrace}\n+}\n+\n+\n+// ----------------------------------------------------------------------------\n+// Expressions\n+\n+func (p *parser) parseFuncTypeOrLit() ast.Expr {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"FuncTypeOrLit\"))\n+\t}\n+\n+\ttyp, scope := p.parseFuncType()\n+\tif p.tok != token.LBRACE {\n+\t\t// function type only\n+\t\treturn typ\n+\t}\n+\n+\tp.exprLev++\n+\tbody := p.parseBody(scope)\n+\tp.exprLev--\n+\n+\treturn &ast.FuncLit{typ, body}\n+}\n+\n+\n+// parseOperand may return an expression or a raw type (incl. array\n+// types of the form [...]T. Callers must verify the result.\n+// If lhs is set and the result is an identifier, it is not resolved.\n+//\n+func (p *parser) parseOperand(lhs bool) ast.Expr {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"Operand\"))\n+\t}\n+\n+\tswitch p.tok {\n+\tcase token.IDENT:\n+\t\tx := p.parseIdent()\n+\t\tif !lhs {\n+\t\t\tp.resolve(x)\n+\t\t}\n+\t\treturn x\n+\n+\tcase token.INT, token.FLOAT, token.IMAG, token.CHAR, token.STRING:\n+\t\tx := &ast.BasicLit{p.pos, p.tok, p.lit}\n+\t\tp.next()\n+\t\treturn x\n+\n+\tcase token.LPAREN:\n+\t\tlparen := p.pos\n+\t\tp.next()\n+\t\tp.exprLev++\n+\t\tx := p.parseRhs()\n+\t\tp.exprLev--\n+\t\trparen := p.expect(token.RPAREN)\n+\t\treturn &ast.ParenExpr{lparen, x, rparen}\n+\n+\tcase token.FUNC:\n+\t\treturn p.parseFuncTypeOrLit()\n+\n+\tdefault:\n+\t\tif typ := p.tryIdentOrType(true); typ != nil {\n+\t\t\t// could be type for composite literal or conversion\n+\t\t\t_, isIdent := typ.(*ast.Ident)\n+\t\t\tassert(!isIdent, \"type cannot be identifier\")\n+\t\t\treturn typ\n+\t\t}\n+\t}\n+\n+\tpos := p.pos\n+\tp.errorExpected(pos, \"operand\")\n+\tp.next() // make progress\n+\treturn &ast.BadExpr{pos, p.pos}\n+}\n+\n+\n+func (p *parser) parseSelector(x ast.Expr) ast.Expr {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"Selector\"))\n+\t}\n+\n+\tsel := p.parseIdent()\n+\n+\treturn &ast.SelectorExpr{x, sel}\n+}\n+\n+\n+func (p *parser) parseTypeAssertion(x ast.Expr) ast.Expr {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"TypeAssertion\"))\n+\t}\n+\n+\tp.expect(token.LPAREN)\n+\tvar typ ast.Expr\n+\tif p.tok == token.TYPE {\n+\t\t// type switch: typ == nil\n+\t\tp.next()\n+\t} else {\n+\t\ttyp = p.parseType()\n+\t}\n+\tp.expect(token.RPAREN)\n+\n+\treturn &ast.TypeAssertExpr{x, typ}\n+}\n+\n+\n+func (p *parser) parseIndexOrSlice(x ast.Expr) ast.Expr {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"IndexOrSlice\"))\n+\t}\n+\n+\tlbrack := p.expect(token.LBRACK)\n+\tp.exprLev++\n+\tvar low, high ast.Expr\n+\tisSlice := false\n+\tif p.tok != token.COLON {\n+\t\tlow = p.parseRhs()\n+\t}\n+\tif p.tok == token.COLON {\n+\t\tisSlice = true\n+\t\tp.next()\n+\t\tif p.tok != token.RBRACK {\n+\t\t\thigh = p.parseRhs()\n+\t\t}\n+\t}\n+\tp.exprLev--\n+\trbrack := p.expect(token.RBRACK)\n+\n+\tif isSlice {\n+\t\treturn &ast.SliceExpr{x, lbrack, low, high, rbrack}\n+\t}\n+\treturn &ast.IndexExpr{x, lbrack, low, rbrack}\n+}\n+\n+\n+func (p *parser) parseCallOrConversion(fun ast.Expr) *ast.CallExpr {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"CallOrConversion\"))\n+\t}\n+\n+\tlparen := p.expect(token.LPAREN)\n+\tp.exprLev++\n+\tvar list []ast.Expr\n+\tvar ellipsis token.Pos\n+\tfor p.tok != token.RPAREN && p.tok != token.EOF && !ellipsis.IsValid() {\n+\t\tlist = append(list, p.parseRhs())\n+\t\tif p.tok == token.ELLIPSIS {\n+\t\t\tellipsis = p.pos\n+\t\t\tp.next()\n+\t\t}\n+\t\tif p.tok != token.COMMA {\n+\t\t\tbreak\n+\t\t}\n+\t\tp.next()\n+\t}\n+\tp.exprLev--\n+\trparen := p.expect(token.RPAREN)\n+\n+\treturn &ast.CallExpr{fun, lparen, list, ellipsis, rparen}\n+}\n+\n+\n+func (p *parser) parseElement(keyOk bool) ast.Expr {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"Element\"))\n+\t}\n+\n+\tif p.tok == token.LBRACE {\n+\t\treturn p.parseLiteralValue(nil)\n+\t}\n+\n+\tx := p.parseExpr(keyOk) // don't resolve if map key\n+\tif keyOk {\n+\t\tif p.tok == token.COLON {\n+\t\t\tcolon := p.pos\n+\t\t\tp.next()\n+\t\t\treturn &ast.KeyValueExpr{x, colon, p.parseElement(false)}\n+\t\t}\n+\t\tp.resolve(x) // not a map key\n+\t}\n+\n+\treturn x\n+}\n+\n+\n+func (p *parser) parseElementList() (list []ast.Expr) {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"ElementList\"))\n+\t}\n+\n+\tfor p.tok != token.RBRACE && p.tok != token.EOF {\n+\t\tlist = append(list, p.parseElement(true))\n+\t\tif p.tok != token.COMMA {\n+\t\t\tbreak\n+\t\t}\n+\t\tp.next()\n+\t}\n+\n+\treturn\n+}\n+\n+\n+func (p *parser) parseLiteralValue(typ ast.Expr) ast.Expr {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"LiteralValue\"))\n+\t}\n+\n+\tlbrace := p.expect(token.LBRACE)\n+\tvar elts []ast.Expr\n+\tp.exprLev++\n+\tif p.tok != token.RBRACE {\n+\t\telts = p.parseElementList()\n+\t}\n+\tp.exprLev--\n+\trbrace := p.expect(token.RBRACE)\n+\treturn &ast.CompositeLit{typ, lbrace, elts, rbrace}\n+}\n+\n+\n+// checkExpr checks that x is an expression (and not a type).\n+func (p *parser) checkExpr(x ast.Expr) ast.Expr {\n+\tswitch t := unparen(x).(type) {\n+\tcase *ast.BadExpr:\n+\tcase *ast.Ident:\n+\tcase *ast.BasicLit:\n+\tcase *ast.FuncLit:\n+\tcase *ast.CompositeLit:\n+\tcase *ast.ParenExpr:\n+\t\tpanic(\"unreachable\")\n+\tcase *ast.SelectorExpr:\n+\tcase *ast.IndexExpr:\n+\tcase *ast.SliceExpr:\n+\tcase *ast.TypeAssertExpr:\n+\t\tif t.Type == nil {\n+\t\t\t// the form X.(type) is only allowed in type switch expressions\n+\t\t\tp.errorExpected(x.Pos(), \"expression\")\n+\t\t\tx = &ast.BadExpr{x.Pos(), x.End()}\n+\t\t}\n+\tcase *ast.CallExpr:\n+\tcase *ast.StarExpr:\n+\tcase *ast.UnaryExpr:\n+\t\tif t.Op == token.RANGE {\n+\t\t\t// the range operator is only allowed at the top of a for statement\n+\t\t\tp.errorExpected(x.Pos(), \"expression\")\n+\t\t\tx = &ast.BadExpr{x.Pos(), x.End()}\n+\t\t}\n+\tcase *ast.BinaryExpr:\n+\tdefault:\n+\t\t// all other nodes are not proper expressions\n+\t\tp.errorExpected(x.Pos(), \"expression\")\n+\t\tx = &ast.BadExpr{x.Pos(), x.End()}\n+\t}\n+\treturn x\n+}\n+\n+\n+// isTypeName returns true iff x is a (qualified) TypeName.\n+func isTypeName(x ast.Expr) bool {\n+\tswitch t := x.(type) {\n+\tcase *ast.BadExpr:\n+\tcase *ast.Ident:\n+\tcase *ast.SelectorExpr:\n+\t\t_, isIdent := t.X.(*ast.Ident)\n+\t\treturn isIdent\n+\tdefault:\n+\t\treturn false // all other nodes are not type names\n+\t}\n+\treturn true\n+}\n+\n+\n+// isLiteralType returns true iff x is a legal composite literal type.\n+func isLiteralType(x ast.Expr) bool {\n+\tswitch t := x.(type) {\n+\tcase *ast.BadExpr:\n+\tcase *ast.Ident:\n+\tcase *ast.SelectorExpr:\n+\t\t_, isIdent := t.X.(*ast.Ident)\n+\t\treturn isIdent\n+\tcase *ast.ArrayType:\n+\tcase *ast.StructType:\n+\tcase *ast.MapType:\n+\tdefault:\n+\t\treturn false // all other nodes are not legal composite literal types\n+\t}\n+\treturn true\n+}\n+\n+\n+// If x is of the form *T, deref returns T, otherwise it returns x.\n+func deref(x ast.Expr) ast.Expr {\n+\tif p, isPtr := x.(*ast.StarExpr); isPtr {\n+\t\tx = p.X\n+\t}\n+\treturn x\n+}\n+\n+\n+// If x is of the form (T), unparen returns unparen(T), otherwise it returns x.\n+func unparen(x ast.Expr) ast.Expr {\n+\tif p, isParen := x.(*ast.ParenExpr); isParen {\n+\t\tx = unparen(p.X)\n+\t}\n+\treturn x\n+}\n+\n+\n+// checkExprOrType checks that x is an expression or a type\n+// (and not a raw type such as [...]T).\n+//\n+func (p *parser) checkExprOrType(x ast.Expr) ast.Expr {\n+\tswitch t := unparen(x).(type) {\n+\tcase *ast.ParenExpr:\n+\t\tpanic(\"unreachable\")\n+\tcase *ast.UnaryExpr:\n+\t\tif t.Op == token.RANGE {\n+\t\t\t// the range operator is only allowed at the top of a for statement\n+\t\t\tp.errorExpected(x.Pos(), \"expression\")\n+\t\t\tx = &ast.BadExpr{x.Pos(), x.End()}\n+\t\t}\n+\tcase *ast.ArrayType:\n+\t\tif len, isEllipsis := t.Len.(*ast.Ellipsis); isEllipsis {\n+\t\t\tp.error(len.Pos(), \"expected array length, found '...'\")\n+\t\t\tx = &ast.BadExpr{x.Pos(), x.End()}\n+\t\t}\n+\t}\n+\n+\t// all other nodes are expressions or types\n+\treturn x\n+}\n+\n+\n+// If lhs is set and the result is an identifier, it is not resolved.\n+func (p *parser) parsePrimaryExpr(lhs bool) ast.Expr {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"PrimaryExpr\"))\n+\t}\n+\n+\tx := p.parseOperand(lhs)\n+L:\n+\tfor {\n+\t\tswitch p.tok {\n+\t\tcase token.PERIOD:\n+\t\t\tp.next()\n+\t\t\tif lhs {\n+\t\t\t\tp.resolve(x)\n+\t\t\t}\n+\t\t\tswitch p.tok {\n+\t\t\tcase token.IDENT:\n+\t\t\t\tx = p.parseSelector(p.checkExpr(x))\n+\t\t\tcase token.LPAREN:\n+\t\t\t\tx = p.parseTypeAssertion(p.checkExpr(x))\n+\t\t\tdefault:\n+\t\t\t\tpos := p.pos\n+\t\t\t\tp.next() // make progress\n+\t\t\t\tp.errorExpected(pos, \"selector or type assertion\")\n+\t\t\t\tx = &ast.BadExpr{pos, p.pos}\n+\t\t\t}\n+\t\tcase token.LBRACK:\n+\t\t\tif lhs {\n+\t\t\t\tp.resolve(x)\n+\t\t\t}\n+\t\t\tx = p.parseIndexOrSlice(p.checkExpr(x))\n+\t\tcase token.LPAREN:\n+\t\t\tif lhs {\n+\t\t\t\tp.resolve(x)\n+\t\t\t}\n+\t\t\tx = p.parseCallOrConversion(p.checkExprOrType(x))\n+\t\tcase token.LBRACE:\n+\t\t\tif isLiteralType(x) && (p.exprLev >= 0 || !isTypeName(x)) {\n+\t\t\t\tif lhs {\n+\t\t\t\t\tp.resolve(x)\n+\t\t\t\t}\n+\t\t\t\tx = p.parseLiteralValue(x)\n+\t\t\t} else {\n+\t\t\t\tbreak L\n+\t\t\t}\n+\t\tdefault:\n+\t\t\tbreak L\n+\t\t}\n+\t\tlhs = false // no need to try to resolve again\n+\t}\n+\n+\treturn x\n+}\n+\n+\n+// If lhs is set and the result is an identifier, it is not resolved.\n+func (p *parser) parseUnaryExpr(lhs bool) ast.Expr {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"UnaryExpr\"))\n+\t}\n+\n+\tswitch p.tok {\n+\tcase token.ADD, token.SUB, token.NOT, token.XOR, token.AND, token.RANGE:\n+\t\tpos, op := p.pos, p.tok\n+\t\tp.next()\n+\t\tx := p.parseUnaryExpr(false)\n+\t\treturn &ast.UnaryExpr{pos, op, p.checkExpr(x)}\n+\n+\tcase token.ARROW:\n+\t\t// channel type or receive expression\n+\t\tpos := p.pos\n+\t\tp.next()\n+\t\tif p.tok == token.CHAN {\n+\t\t\tp.next()\n+\t\t\tvalue := p.parseType()\n+\t\t\treturn &ast.ChanType{pos, ast.RECV, value}\n+\t\t}\n+\n+\t\tx := p.parseUnaryExpr(false)\n+\t\treturn &ast.UnaryExpr{pos, token.ARROW, p.checkExpr(x)}\n+\n+\tcase token.MUL:\n+\t\t// pointer type or unary \"*\" expression\n+\t\tpos := p.pos\n+\t\tp.next()\n+\t\tx := p.parseUnaryExpr(false)\n+\t\treturn &ast.StarExpr{pos, p.checkExprOrType(x)}\n+\t}\n+\n+\treturn p.parsePrimaryExpr(lhs)\n+}\n+\n+\n+// If lhs is set and the result is an identifier, it is not resolved.\n+func (p *parser) parseBinaryExpr(lhs bool, prec1 int) ast.Expr {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"BinaryExpr\"))\n+\t}\n+\n+\tx := p.parseUnaryExpr(lhs)\n+\tfor prec := p.tok.Precedence(); prec >= prec1; prec-- {\n+\t\tfor p.tok.Precedence() == prec {\n+\t\t\tpos, op := p.pos, p.tok\n+\t\t\tp.next()\n+\t\t\tif lhs {\n+\t\t\t\tp.resolve(x)\n+\t\t\t\tlhs = false\n+\t\t\t}\n+\t\t\ty := p.parseBinaryExpr(false, prec+1)\n+\t\t\tx = &ast.BinaryExpr{p.checkExpr(x), pos, op, p.checkExpr(y)}\n+\t\t}\n+\t}\n+\n+\treturn x\n+}\n+\n+\n+// If lhs is set and the result is an identifier, it is not resolved.\n+// TODO(gri): parseExpr may return a type or even a raw type ([..]int) -\n+//            should reject when a type/raw type is obviously not allowed\n+func (p *parser) parseExpr(lhs bool) ast.Expr {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"Expression\"))\n+\t}\n+\n+\treturn p.parseBinaryExpr(lhs, token.LowestPrec+1)\n+}\n+\n+\n+func (p *parser) parseRhs() ast.Expr {\n+\treturn p.parseExpr(false)\n+}\n+\n+\n+// ----------------------------------------------------------------------------\n+// Statements\n+\n+func (p *parser) parseSimpleStmt(labelOk bool) ast.Stmt {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"SimpleStmt\"))\n+\t}\n+\n+\tx := p.parseLhsList()\n+\n+\tswitch p.tok {\n+\tcase\n+\t\ttoken.DEFINE, token.ASSIGN, token.ADD_ASSIGN,\n+\t\ttoken.SUB_ASSIGN, token.MUL_ASSIGN, token.QUO_ASSIGN,\n+\t\ttoken.REM_ASSIGN, token.AND_ASSIGN, token.OR_ASSIGN,\n+\t\ttoken.XOR_ASSIGN, token.SHL_ASSIGN, token.SHR_ASSIGN, token.AND_NOT_ASSIGN:\n+\t\t// assignment statement\n+\t\tpos, tok := p.pos, p.tok\n+\t\tp.next()\n+\t\ty := p.parseRhsList()\n+\t\treturn &ast.AssignStmt{x, pos, tok, y}\n+\t}\n+\n+\tif len(x) > 1 {\n+\t\tp.errorExpected(x[0].Pos(), \"1 expression\")\n+\t\t// continue with first expression\n+\t}\n+\n+\tswitch p.tok {\n+\tcase token.COLON:\n+\t\t// labeled statement\n+\t\tcolon := p.pos\n+\t\tp.next()\n+\t\tif label, isIdent := x[0].(*ast.Ident); labelOk && isIdent {\n+\t\t\t// Go spec: The scope of a label is the body of the function\n+\t\t\t// in which it is declared and excludes the body of any nested\n+\t\t\t// function.\n+\t\t\tstmt := &ast.LabeledStmt{label, colon, p.parseStmt()}\n+\t\t\tp.declare(stmt, p.labelScope, ast.Lbl, label)\n+\t\t\treturn stmt\n+\t\t}\n+\t\tp.error(x[0].Pos(), \"illegal label declaration\")\n+\t\treturn &ast.BadStmt{x[0].Pos(), colon + 1}\n+\n+\tcase token.ARROW:\n+\t\t// send statement\n+\t\tarrow := p.pos\n+\t\tp.next() // consume \"<-\"\n+\t\ty := p.parseRhs()\n+\t\treturn &ast.SendStmt{x[0], arrow, y}\n+\n+\tcase token.INC, token.DEC:\n+\t\t// increment or decrement\n+\t\ts := &ast.IncDecStmt{x[0], p.pos, p.tok}\n+\t\tp.next() // consume \"++\" or \"--\"\n+\t\treturn s\n+\t}\n+\n+\t// expression\n+\treturn &ast.ExprStmt{x[0]}\n+}\n+\n+\n+func (p *parser) parseCallExpr() *ast.CallExpr {\n+\tx := p.parseRhs()\n+\tif call, isCall := x.(*ast.CallExpr); isCall {\n+\t\treturn call\n+\t}\n+\tp.errorExpected(x.Pos(), \"function/method call\")\n+\treturn nil\n+}\n+\n+\n+func (p *parser) parseGoStmt() ast.Stmt {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"GoStmt\"))\n+\t}\n+\n+\tpos := p.expect(token.GO)\n+\tcall := p.parseCallExpr()\n+\tp.expectSemi()\n+\tif call == nil {\n+\t\treturn &ast.BadStmt{pos, pos + 2} // len(\"go\")\n+\t}\n+\n+\treturn &ast.GoStmt{pos, call}\n+}\n+\n+\n+func (p *parser) parseDeferStmt() ast.Stmt {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"DeferStmt\"))\n+\t}\n+\n+\tpos := p.expect(token.DEFER)\n+\tcall := p.parseCallExpr()\n+\tp.expectSemi()\n+\tif call == nil {\n+\t\treturn &ast.BadStmt{pos, pos + 5} // len(\"defer\")\n+\t}\n+\n+\treturn &ast.DeferStmt{pos, call}\n+}\n+\n+\n+func (p *parser) parseReturnStmt() *ast.ReturnStmt {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"ReturnStmt\"))\n+\t}\n+\n+\tpos := p.pos\n+\tp.expect(token.RETURN)\n+\tvar x []ast.Expr\n+\tif p.tok != token.SEMICOLON && p.tok != token.RBRACE {\n+\t\tx = p.parseRhsList()\n+\t}\n+\tp.expectSemi()\n+\n+\treturn &ast.ReturnStmt{pos, x}\n+}\n+\n+\n+func (p *parser) parseBranchStmt(tok token.Token) *ast.BranchStmt {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"BranchStmt\"))\n+\t}\n+\n+\tpos := p.expect(tok)\n+\tvar label *ast.Ident\n+\tif tok != token.FALLTHROUGH && p.tok == token.IDENT {\n+\t\tlabel = p.parseIdent()\n+\t\t// add to list of unresolved targets\n+\t\tn := len(p.targetStack) - 1\n+\t\tp.targetStack[n] = append(p.targetStack[n], label)\n+\t}\n+\tp.expectSemi()\n+\n+\treturn &ast.BranchStmt{pos, tok, label}\n+}\n+\n+\n+func (p *parser) makeExpr(s ast.Stmt) ast.Expr {\n+\tif s == nil {\n+\t\treturn nil\n+\t}\n+\tif es, isExpr := s.(*ast.ExprStmt); isExpr {\n+\t\treturn p.checkExpr(es.X)\n+\t}\n+\tp.error(s.Pos(), \"expected condition, found simple statement\")\n+\treturn &ast.BadExpr{s.Pos(), s.End()}\n+}\n+\n+\n+func (p *parser) parseIfStmt() *ast.IfStmt {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"IfStmt\"))\n+\t}\n+\n+\tpos := p.expect(token.IF)\n+\tp.openScope()\n+\tdefer p.closeScope()\n+\n+\tvar s ast.Stmt\n+\tvar x ast.Expr\n+\t{\n+\t\tprevLev := p.exprLev\n+\t\tp.exprLev = -1\n+\t\tif p.tok == token.SEMICOLON {\n+\t\t\tp.next()\n+\t\t\tx = p.parseRhs()\n+\t\t} else {\n+\t\t\ts = p.parseSimpleStmt(false)\n+\t\t\tif p.tok == token.SEMICOLON {\n+\t\t\t\tp.next()\n+\t\t\t\tx = p.parseRhs()\n+\t\t\t} else {\n+\t\t\t\tx = p.makeExpr(s)\n+\t\t\t\ts = nil\n+\t\t\t}\n+\t\t}\n+\t\tp.exprLev = prevLev\n+\t}\n+\n+\tbody := p.parseBlockStmt()\n+\tvar else_ ast.Stmt\n+\tif p.tok == token.ELSE {\n+\t\tp.next()\n+\t\telse_ = p.parseStmt()\n+\t} else {\n+\t\tp.expectSemi()\n+\t}\n+\n+\treturn &ast.IfStmt{pos, s, x, body, else_}\n+}\n+\n+\n+func (p *parser) parseTypeList() (list []ast.Expr) {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"TypeList\"))\n+\t}\n+\n+\tlist = append(list, p.parseType())\n+\tfor p.tok == token.COMMA {\n+\t\tp.next()\n+\t\tlist = append(list, p.parseType())\n+\t}\n+\n+\treturn\n+}\n+\n+\n+func (p *parser) parseCaseClause(exprSwitch bool) *ast.CaseClause {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"CaseClause\"))\n+\t}\n+\n+\tpos := p.pos\n+\tvar list []ast.Expr\n+\tif p.tok == token.CASE {\n+\t\tp.next()\n+\t\tif exprSwitch {\n+\t\t\tlist = p.parseRhsList()\n+\t\t} else {\n+\t\t\tlist = p.parseTypeList()\n+\t\t}\n+\t} else {\n+\t\tp.expect(token.DEFAULT)\n+\t}\n+\n+\tcolon := p.expect(token.COLON)\n+\tp.openScope()\n+\tbody := p.parseStmtList()\n+\tp.closeScope()\n+\n+\treturn &ast.CaseClause{pos, list, colon, body}\n+}\n+\n+\n+func isExprSwitch(s ast.Stmt) bool {\n+\tif s == nil {\n+\t\treturn true\n+\t}\n+\tif e, ok := s.(*ast.ExprStmt); ok {\n+\t\tif a, ok := e.X.(*ast.TypeAssertExpr); ok {\n+\t\t\treturn a.Type != nil // regular type assertion\n+\t\t}\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+\n+func (p *parser) parseSwitchStmt() ast.Stmt {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"SwitchStmt\"))\n+\t}\n+\n+\tpos := p.expect(token.SWITCH)\n+\tp.openScope()\n+\tdefer p.closeScope()\n+\n+\tvar s1, s2 ast.Stmt\n+\tif p.tok != token.LBRACE {\n+\t\tprevLev := p.exprLev\n+\t\tp.exprLev = -1\n+\t\tif p.tok != token.SEMICOLON {\n+\t\t\ts2 = p.parseSimpleStmt(false)\n+\t\t}\n+\t\tif p.tok == token.SEMICOLON {\n+\t\t\tp.next()\n+\t\t\ts1 = s2\n+\t\t\ts2 = nil\n+\t\t\tif p.tok != token.LBRACE {\n+\t\t\t\ts2 = p.parseSimpleStmt(false)\n+\t\t\t}\n+\t\t}\n+\t\tp.exprLev = prevLev\n+\t}\n+\n+\texprSwitch := isExprSwitch(s2)\n+\tlbrace := p.expect(token.LBRACE)\n+\tvar list []ast.Stmt\n+\tfor p.tok == token.CASE || p.tok == token.DEFAULT {\n+\t\tlist = append(list, p.parseCaseClause(exprSwitch))\n+\t}\n+\trbrace := p.expect(token.RBRACE)\n+\tp.expectSemi()\n+\tbody := &ast.BlockStmt{lbrace, list, rbrace}\n+\n+\tif exprSwitch {\n+\t\treturn &ast.SwitchStmt{pos, s1, p.makeExpr(s2), body}\n+\t}\n+\t// type switch\n+\t// TODO(gri): do all the checks!\n+\treturn &ast.TypeSwitchStmt{pos, s1, s2, body}\n+}\n+\n+\n+func (p *parser) parseCommClause() *ast.CommClause {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"CommClause\"))\n+\t}\n+\n+\tp.openScope()\n+\tpos := p.pos\n+\tvar comm ast.Stmt\n+\tif p.tok == token.CASE {\n+\t\tp.next()\n+\t\tlhs := p.parseLhsList()\n+\t\tif p.tok == token.ARROW {\n+\t\t\t// SendStmt\n+\t\t\tif len(lhs) > 1 {\n+\t\t\t\tp.errorExpected(lhs[0].Pos(), \"1 expression\")\n+\t\t\t\t// continue with first expression\n+\t\t\t}\n+\t\t\tarrow := p.pos\n+\t\t\tp.next()\n+\t\t\trhs := p.parseRhs()\n+\t\t\tcomm = &ast.SendStmt{lhs[0], arrow, rhs}\n+\t\t} else {\n+\t\t\t// RecvStmt\n+\t\t\tpos := p.pos\n+\t\t\ttok := p.tok\n+\t\t\tvar rhs ast.Expr\n+\t\t\tif tok == token.ASSIGN || tok == token.DEFINE {\n+\t\t\t\t// RecvStmt with assignment\n+\t\t\t\tif len(lhs) > 2 {\n+\t\t\t\t\tp.errorExpected(lhs[0].Pos(), \"1 or 2 expressions\")\n+\t\t\t\t\t// continue with first two expressions\n+\t\t\t\t\tlhs = lhs[0:2]\n+\t\t\t\t}\n+\t\t\t\tp.next()\n+\t\t\t\trhs = p.parseRhs()\n+\t\t\t} else {\n+\t\t\t\t// rhs must be single receive operation\n+\t\t\t\tif len(lhs) > 1 {\n+\t\t\t\t\tp.errorExpected(lhs[0].Pos(), \"1 expression\")\n+\t\t\t\t\t// continue with first expression\n+\t\t\t\t}\n+\t\t\t\trhs = lhs[0]\n+\t\t\t\tlhs = nil // there is no lhs\n+\t\t\t}\n+\t\t\tif x, isUnary := rhs.(*ast.UnaryExpr); !isUnary || x.Op != token.ARROW {\n+\t\t\t\tp.errorExpected(rhs.Pos(), \"send or receive operation\")\n+\t\t\t\trhs = &ast.BadExpr{rhs.Pos(), rhs.End()}\n+\t\t\t}\n+\t\t\tif lhs != nil {\n+\t\t\t\tcomm = &ast.AssignStmt{lhs, pos, tok, []ast.Expr{rhs}}\n+\t\t\t} else {\n+\t\t\t\tcomm = &ast.ExprStmt{rhs}\n+\t\t\t}\n+\t\t}\n+\t} else {\n+\t\tp.expect(token.DEFAULT)\n+\t}\n+\n+\tcolon := p.expect(token.COLON)\n+\tbody := p.parseStmtList()\n+\tp.closeScope()\n+\n+\treturn &ast.CommClause{pos, comm, colon, body}\n+}\n+\n+\n+func (p *parser) parseSelectStmt() *ast.SelectStmt {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"SelectStmt\"))\n+\t}\n+\n+\tpos := p.expect(token.SELECT)\n+\tlbrace := p.expect(token.LBRACE)\n+\tvar list []ast.Stmt\n+\tfor p.tok == token.CASE || p.tok == token.DEFAULT {\n+\t\tlist = append(list, p.parseCommClause())\n+\t}\n+\trbrace := p.expect(token.RBRACE)\n+\tp.expectSemi()\n+\tbody := &ast.BlockStmt{lbrace, list, rbrace}\n+\n+\treturn &ast.SelectStmt{pos, body}\n+}\n+\n+\n+func (p *parser) parseForStmt() ast.Stmt {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"ForStmt\"))\n+\t}\n+\n+\tpos := p.expect(token.FOR)\n+\tp.openScope()\n+\tdefer p.closeScope()\n+\n+\tvar s1, s2, s3 ast.Stmt\n+\tif p.tok != token.LBRACE {\n+\t\tprevLev := p.exprLev\n+\t\tp.exprLev = -1\n+\t\tif p.tok != token.SEMICOLON {\n+\t\t\ts2 = p.parseSimpleStmt(false)\n+\t\t}\n+\t\tif p.tok == token.SEMICOLON {\n+\t\t\tp.next()\n+\t\t\ts1 = s2\n+\t\t\ts2 = nil\n+\t\t\tif p.tok != token.SEMICOLON {\n+\t\t\t\ts2 = p.parseSimpleStmt(false)\n+\t\t\t}\n+\t\t\tp.expectSemi()\n+\t\t\tif p.tok != token.LBRACE {\n+\t\t\t\ts3 = p.parseSimpleStmt(false)\n+\t\t\t}\n+\t\t}\n+\t\tp.exprLev = prevLev\n+\t}\n+\n+\tbody := p.parseBlockStmt()\n+\tp.expectSemi()\n+\n+\tif as, isAssign := s2.(*ast.AssignStmt); isAssign {\n+\t\t// possibly a for statement with a range clause; check assignment operator\n+\t\tif as.Tok != token.ASSIGN && as.Tok != token.DEFINE {\n+\t\t\tp.errorExpected(as.TokPos, \"'=' or ':='\")\n+\t\t\treturn &ast.BadStmt{pos, body.End()}\n+\t\t}\n+\t\t// check lhs\n+\t\tvar key, value ast.Expr\n+\t\tswitch len(as.Lhs) {\n+\t\tcase 2:\n+\t\t\tkey, value = as.Lhs[0], as.Lhs[1]\n+\t\tcase 1:\n+\t\t\tkey = as.Lhs[0]\n+\t\tdefault:\n+\t\t\tp.errorExpected(as.Lhs[0].Pos(), \"1 or 2 expressions\")\n+\t\t\treturn &ast.BadStmt{pos, body.End()}\n+\t\t}\n+\t\t// check rhs\n+\t\tif len(as.Rhs) != 1 {\n+\t\t\tp.errorExpected(as.Rhs[0].Pos(), \"1 expression\")\n+\t\t\treturn &ast.BadStmt{pos, body.End()}\n+\t\t}\n+\t\tif rhs, isUnary := as.Rhs[0].(*ast.UnaryExpr); isUnary && rhs.Op == token.RANGE {\n+\t\t\t// rhs is range expression\n+\t\t\t// (any short variable declaration was handled by parseSimpleStat above)\n+\t\t\treturn &ast.RangeStmt{pos, key, value, as.TokPos, as.Tok, rhs.X, body}\n+\t\t}\n+\t\tp.errorExpected(s2.Pos(), \"range clause\")\n+\t\treturn &ast.BadStmt{pos, body.End()}\n+\t}\n+\n+\t// regular for statement\n+\treturn &ast.ForStmt{pos, s1, p.makeExpr(s2), s3, body}\n+}\n+\n+\n+func (p *parser) parseStmt() (s ast.Stmt) {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"Statement\"))\n+\t}\n+\n+\tswitch p.tok {\n+\tcase token.CONST, token.TYPE, token.VAR:\n+\t\ts = &ast.DeclStmt{p.parseDecl()}\n+\tcase\n+\t\t// tokens that may start a top-level expression\n+\t\ttoken.IDENT, token.INT, token.FLOAT, token.CHAR, token.STRING, token.FUNC, token.LPAREN, // operand\n+\t\ttoken.LBRACK, token.STRUCT, // composite type\n+\t\ttoken.MUL, token.AND, token.ARROW, token.ADD, token.SUB, token.XOR: // unary operators\n+\t\ts = p.parseSimpleStmt(true)\n+\t\t// because of the required look-ahead, labeled statements are\n+\t\t// parsed by parseSimpleStmt - don't expect a semicolon after\n+\t\t// them\n+\t\tif _, isLabeledStmt := s.(*ast.LabeledStmt); !isLabeledStmt {\n+\t\t\tp.expectSemi()\n+\t\t}\n+\tcase token.GO:\n+\t\ts = p.parseGoStmt()\n+\tcase token.DEFER:\n+\t\ts = p.parseDeferStmt()\n+\tcase token.RETURN:\n+\t\ts = p.parseReturnStmt()\n+\tcase token.BREAK, token.CONTINUE, token.GOTO, token.FALLTHROUGH:\n+\t\ts = p.parseBranchStmt(p.tok)\n+\tcase token.LBRACE:\n+\t\ts = p.parseBlockStmt()\n+\t\tp.expectSemi()\n+\tcase token.IF:\n+\t\ts = p.parseIfStmt()\n+\tcase token.SWITCH:\n+\t\ts = p.parseSwitchStmt()\n+\tcase token.SELECT:\n+\t\ts = p.parseSelectStmt()\n+\tcase token.FOR:\n+\t\ts = p.parseForStmt()\n+\tcase token.SEMICOLON:\n+\t\ts = &ast.EmptyStmt{p.pos}\n+\t\tp.next()\n+\tcase token.RBRACE:\n+\t\t// a semicolon may be omitted before a closing \"}\"\n+\t\ts = &ast.EmptyStmt{p.pos}\n+\tdefault:\n+\t\t// no statement found\n+\t\tpos := p.pos\n+\t\tp.errorExpected(pos, \"statement\")\n+\t\tp.next() // make progress\n+\t\ts = &ast.BadStmt{pos, p.pos}\n+\t}\n+\n+\treturn\n+}\n+\n+\n+// ----------------------------------------------------------------------------\n+// Declarations\n+\n+type parseSpecFunction func(p *parser, doc *ast.CommentGroup, iota int) ast.Spec\n+\n+\n+func parseImportSpec(p *parser, doc *ast.CommentGroup, _ int) ast.Spec {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"ImportSpec\"))\n+\t}\n+\n+\tvar ident *ast.Ident\n+\tswitch p.tok {\n+\tcase token.PERIOD:\n+\t\tident = &ast.Ident{p.pos, \".\", nil}\n+\t\tp.next()\n+\tcase token.IDENT:\n+\t\tident = p.parseIdent()\n+\t}\n+\n+\tvar path *ast.BasicLit\n+\tif p.tok == token.STRING {\n+\t\tpath = &ast.BasicLit{p.pos, p.tok, p.lit}\n+\t\tp.next()\n+\t} else {\n+\t\tp.expect(token.STRING) // use expect() error handling\n+\t}\n+\tp.expectSemi() // call before accessing p.linecomment\n+\n+\t// collect imports\n+\tspec := &ast.ImportSpec{doc, ident, path, p.lineComment}\n+\tp.imports = append(p.imports, spec)\n+\n+\treturn spec\n+}\n+\n+\n+func parseConstSpec(p *parser, doc *ast.CommentGroup, iota int) ast.Spec {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"ConstSpec\"))\n+\t}\n+\n+\tidents := p.parseIdentList()\n+\ttyp := p.tryType()\n+\tvar values []ast.Expr\n+\tif typ != nil || p.tok == token.ASSIGN || iota == 0 {\n+\t\tp.expect(token.ASSIGN)\n+\t\tvalues = p.parseRhsList()\n+\t}\n+\tp.expectSemi() // call before accessing p.linecomment\n+\n+\t// Go spec: The scope of a constant or variable identifier declared inside\n+\t// a function begins at the end of the ConstSpec or VarSpec and ends at\n+\t// the end of the innermost containing block.\n+\t// (Global identifiers are resolved in a separate phase after parsing.)\n+\tspec := &ast.ValueSpec{doc, idents, typ, values, p.lineComment}\n+\tp.declare(spec, p.topScope, ast.Con, idents...)\n+\n+\treturn spec\n+}\n+\n+\n+func parseTypeSpec(p *parser, doc *ast.CommentGroup, _ int) ast.Spec {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"TypeSpec\"))\n+\t}\n+\n+\tident := p.parseIdent()\n+\n+\t// Go spec: The scope of a type identifier declared inside a function begins\n+\t// at the identifier in the TypeSpec and ends at the end of the innermost\n+\t// containing block.\n+\t// (Global identifiers are resolved in a separate phase after parsing.)\n+\tspec := &ast.TypeSpec{doc, ident, nil, nil}\n+\tp.declare(spec, p.topScope, ast.Typ, ident)\n+\n+\tspec.Type = p.parseType()\n+\tp.expectSemi() // call before accessing p.linecomment\n+\tspec.Comment = p.lineComment\n+\n+\treturn spec\n+}\n+\n+\n+func parseVarSpec(p *parser, doc *ast.CommentGroup, _ int) ast.Spec {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"VarSpec\"))\n+\t}\n+\n+\tidents := p.parseIdentList()\n+\ttyp := p.tryType()\n+\tvar values []ast.Expr\n+\tif typ == nil || p.tok == token.ASSIGN {\n+\t\tp.expect(token.ASSIGN)\n+\t\tvalues = p.parseRhsList()\n+\t}\n+\tp.expectSemi() // call before accessing p.linecomment\n+\n+\t// Go spec: The scope of a constant or variable identifier declared inside\n+\t// a function begins at the end of the ConstSpec or VarSpec and ends at\n+\t// the end of the innermost containing block.\n+\t// (Global identifiers are resolved in a separate phase after parsing.)\n+\tspec := &ast.ValueSpec{doc, idents, typ, values, p.lineComment}\n+\tp.declare(spec, p.topScope, ast.Var, idents...)\n+\n+\treturn spec\n+}\n+\n+\n+func (p *parser) parseGenDecl(keyword token.Token, f parseSpecFunction) *ast.GenDecl {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"GenDecl(\"+keyword.String()+\")\"))\n+\t}\n+\n+\tdoc := p.leadComment\n+\tpos := p.expect(keyword)\n+\tvar lparen, rparen token.Pos\n+\tvar list []ast.Spec\n+\tif p.tok == token.LPAREN {\n+\t\tlparen = p.pos\n+\t\tp.next()\n+\t\tfor iota := 0; p.tok != token.RPAREN && p.tok != token.EOF; iota++ {\n+\t\t\tlist = append(list, f(p, p.leadComment, iota))\n+\t\t}\n+\t\trparen = p.expect(token.RPAREN)\n+\t\tp.expectSemi()\n+\t} else {\n+\t\tlist = append(list, f(p, nil, 0))\n+\t}\n+\n+\treturn &ast.GenDecl{doc, pos, keyword, lparen, list, rparen}\n+}\n+\n+\n+func (p *parser) parseReceiver(scope *ast.Scope) *ast.FieldList {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"Receiver\"))\n+\t}\n+\n+\tpos := p.pos\n+\tpar := p.parseParameters(scope, false)\n+\n+\t// must have exactly one receiver\n+\tif par.NumFields() != 1 {\n+\t\tp.errorExpected(pos, \"exactly one receiver\")\n+\t\t// TODO determine a better range for BadExpr below\n+\t\tpar.List = []*ast.Field{&ast.Field{Type: &ast.BadExpr{pos, pos}}}\n+\t\treturn par\n+\t}\n+\n+\t// recv type must be of the form [\"*\"] identifier\n+\trecv := par.List[0]\n+\tbase := deref(recv.Type)\n+\tif _, isIdent := base.(*ast.Ident); !isIdent {\n+\t\tp.errorExpected(base.Pos(), \"(unqualified) identifier\")\n+\t\tpar.List = []*ast.Field{&ast.Field{Type: &ast.BadExpr{recv.Pos(), recv.End()}}}\n+\t}\n+\n+\treturn par\n+}\n+\n+\n+func (p *parser) parseFuncDecl() *ast.FuncDecl {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"FunctionDecl\"))\n+\t}\n+\n+\tdoc := p.leadComment\n+\tpos := p.expect(token.FUNC)\n+\tscope := ast.NewScope(p.topScope) // function scope\n+\n+\tvar recv *ast.FieldList\n+\tif p.tok == token.LPAREN {\n+\t\trecv = p.parseReceiver(scope)\n+\t}\n+\n+\tident := p.parseIdent()\n+\n+\tparams, results := p.parseSignature(scope)\n+\n+\tvar body *ast.BlockStmt\n+\tif p.tok == token.LBRACE {\n+\t\tbody = p.parseBody(scope)\n+\t}\n+\tp.expectSemi()\n+\n+\tdecl := &ast.FuncDecl{doc, recv, ident, &ast.FuncType{pos, params, results}, body}\n+\tif recv == nil {\n+\t\t// Go spec: The scope of an identifier denoting a constant, type,\n+\t\t// variable, or function (but not method) declared at top level\n+\t\t// (outside any function) is the package block.\n+\t\t//\n+\t\t// init() functions cannot be referred to and there may\n+\t\t// be more than one - don't put them in the pkgScope\n+\t\tif ident.Name != \"init\" {\n+\t\t\tp.declare(decl, p.pkgScope, ast.Fun, ident)\n+\t\t}\n+\t}\n+\n+\treturn decl\n+}\n+\n+\n+func (p *parser) parseDecl() ast.Decl {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"Declaration\"))\n+\t}\n+\n+\tvar f parseSpecFunction\n+\tswitch p.tok {\n+\tcase token.CONST:\n+\t\tf = parseConstSpec\n+\n+\tcase token.TYPE:\n+\t\tf = parseTypeSpec\n+\n+\tcase token.VAR:\n+\t\tf = parseVarSpec\n+\n+\tcase token.FUNC:\n+\t\treturn p.parseFuncDecl()\n+\n+\tdefault:\n+\t\tpos := p.pos\n+\t\tp.errorExpected(pos, \"declaration\")\n+\t\tp.next() // make progress\n+\t\tdecl := &ast.BadDecl{pos, p.pos}\n+\t\treturn decl\n+\t}\n+\n+\treturn p.parseGenDecl(p.tok, f)\n+}\n+\n+\n+func (p *parser) parseDeclList() (list []ast.Decl) {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"DeclList\"))\n+\t}\n+\n+\tfor p.tok != token.EOF {\n+\t\tlist = append(list, p.parseDecl())\n+\t}\n+\n+\treturn\n+}\n+\n+\n+// ----------------------------------------------------------------------------\n+// Source files\n+\n+func (p *parser) parseFile() *ast.File {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"File\"))\n+\t}\n+\n+\t// package clause\n+\tdoc := p.leadComment\n+\tpos := p.expect(token.PACKAGE)\n+\t// Go spec: The package clause is not a declaration;\n+\t// the package name does not appear in any scope.\n+\tident := p.parseIdent()\n+\tif ident.Name == \"_\" {\n+\t\tp.error(p.pos, \"invalid package name _\")\n+\t}\n+\tp.expectSemi()\n+\n+\tvar decls []ast.Decl\n+\n+\t// Don't bother parsing the rest if we had errors already.\n+\t// Likely not a Go source file at all.\n+\n+\tif p.ErrorCount() == 0 && p.mode&PackageClauseOnly == 0 {\n+\t\t// import decls\n+\t\tfor p.tok == token.IMPORT {\n+\t\t\tdecls = append(decls, p.parseGenDecl(token.IMPORT, parseImportSpec))\n+\t\t}\n+\n+\t\tif p.mode&ImportsOnly == 0 {\n+\t\t\t// rest of package body\n+\t\t\tfor p.tok != token.EOF {\n+\t\t\t\tdecls = append(decls, p.parseDecl())\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tassert(p.topScope == p.pkgScope, \"imbalanced scopes\")\n+\n+\t// resolve global identifiers within the same file\n+\ti := 0\n+\tfor _, ident := range p.unresolved {\n+\t\t// i <= index for current ident\n+\t\tassert(ident.Obj == unresolved, \"object already resolved\")\n+\t\tident.Obj = p.pkgScope.Lookup(ident.Name) // also removes unresolved sentinel\n+\t\tif ident.Obj == nil {\n+\t\t\tp.unresolved[i] = ident\n+\t\t\ti++\n+\t\t}\n+\t}\n+\n+\t// TODO(gri): store p.imports in AST\n+\treturn &ast.File{doc, pos, ident, decls, p.pkgScope, p.imports, p.unresolved[0:i], p.comments}\n+}"}, {"sha": "07b7454c87d3450fdfcd2cacbf08d27553a9216b", "filename": "libgo/go/go/scanner/scanner.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,9 +2,9 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// A scanner for Go source text. Takes a []byte as source which can\n-// then be tokenized through repeated calls to the Scan function.\n-// Typical use:\n+// Package scanner implements a scanner for Go source text. Takes a []byte as\n+// source which can then be tokenized through repeated calls to the Scan\n+// function. Typical use:\n //\n //\tvar s Scanner\n //\tfset := token.NewFileSet()  // position information is relative to fset"}, {"sha": "8c35eeb52f77afa63f43c89009f27708962d6cb8", "filename": "libgo/go/go/token/position.go", "status": "modified", "additions": 38, "deletions": 14, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Ftoken%2Fposition.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Ftoken%2Fposition.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftoken%2Fposition.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -94,10 +94,14 @@ func searchFiles(a []*File, x int) int {\n \n \n func (s *FileSet) file(p Pos) *File {\n+\tif f := s.last; f != nil && f.base <= int(p) && int(p) <= f.base+f.size {\n+\t\treturn f\n+\t}\n \tif i := searchFiles(s.files, int(p)); i >= 0 {\n \t\tf := s.files[i]\n \t\t// f.base <= int(p) by definition of searchFiles\n \t\tif int(p) <= f.base+f.size {\n+\t\t\ts.last = f\n \t\t\treturn f\n \t\t}\n \t}\n@@ -316,8 +320,26 @@ func (f *File) Position(p Pos) (pos Position) {\n }\n \n \n-func searchUints(a []int, x int) int {\n-\treturn sort.Search(len(a), func(i int) bool { return a[i] > x }) - 1\n+func searchInts(a []int, x int) int {\n+\t// This function body is a manually inlined version of:\n+\t//\n+\t//   return sort.Search(len(a), func(i int) bool { return a[i] > x }) - 1\n+\t//\n+\t// With better compiler optimizations, this may not be needed in the\n+\t// future, but at the moment this change improves the go/printer\n+\t// benchmark performance by ~30%. This has a direct impact on the\n+\t// speed of gofmt and thus seems worthwhile (2011-04-29).\n+\ti, j := 0, len(a)\n+\tfor i < j {\n+\t\th := i + (j-i)/2 // avoid overflow when computing h\n+\t\t// i \u2264 h < j\n+\t\tif a[h] <= x {\n+\t\t\ti = h + 1\n+\t\t} else {\n+\t\t\tj = h\n+\t\t}\n+\t}\n+\treturn i - 1\n }\n \n \n@@ -329,14 +351,17 @@ func searchLineInfos(a []lineInfo, x int) int {\n // info returns the file name, line, and column number for a file offset.\n func (f *File) info(offset int) (filename string, line, column int) {\n \tfilename = f.name\n-\tif i := searchUints(f.lines, offset); i >= 0 {\n+\tif i := searchInts(f.lines, offset); i >= 0 {\n \t\tline, column = i+1, offset-f.lines[i]+1\n \t}\n-\tif i := searchLineInfos(f.infos, offset); i >= 0 {\n-\t\talt := &f.infos[i]\n-\t\tfilename = alt.filename\n-\t\tif i := searchUints(f.lines, alt.offset); i >= 0 {\n-\t\t\tline += alt.line - i - 1\n+\tif len(f.infos) > 0 {\n+\t\t// almost no files have extra line infos\n+\t\tif i := searchLineInfos(f.infos, offset); i >= 0 {\n+\t\t\talt := &f.infos[i]\n+\t\t\tfilename = alt.filename\n+\t\t\tif i := searchInts(f.lines, alt.offset); i >= 0 {\n+\t\t\t\tline += alt.line - i - 1\n+\t\t\t}\n \t\t}\n \t}\n \treturn\n@@ -348,18 +373,17 @@ func (f *File) info(offset int) (filename string, line, column int) {\n // may invoke them concurrently.\n //\n type FileSet struct {\n-\tmutex sync.RWMutex  // protects the file set\n-\tbase  int           // base offset for the next file\n-\tfiles []*File       // list of files in the order added to the set\n-\tindex map[*File]int // file -> files index for quick lookup\n+\tmutex sync.RWMutex // protects the file set\n+\tbase  int          // base offset for the next file\n+\tfiles []*File      // list of files in the order added to the set\n+\tlast  *File        // cache of last file looked up\n }\n \n \n // NewFileSet creates a new file set.\n func NewFileSet() *FileSet {\n \ts := new(FileSet)\n \ts.base = 1 // 0 == NoPos\n-\ts.index = make(map[*File]int)\n \treturn s\n }\n \n@@ -405,8 +429,8 @@ func (s *FileSet) AddFile(filename string, base, size int) *File {\n \t}\n \t// add the file to the file set\n \ts.base = base\n-\ts.index[f] = len(s.files)\n \ts.files = append(s.files, f)\n+\ts.last = f\n \treturn f\n }\n "}, {"sha": "c2ec80ae14007deece386c6676be347c34d12b98", "filename": "libgo/go/go/token/token.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Ftoken%2Ftoken.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Ftoken%2Ftoken.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftoken%2Ftoken.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,9 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This package defines constants representing the lexical\n-// tokens of the Go programming language and basic operations\n-// on tokens (printing, predicates).\n+// Package token defines constants representing the lexical tokens of the Go\n+// programming language and basic operations on tokens (printing, predicates).\n //\n package token\n "}, {"sha": "b151f5834da1d9e6ce612b56f6df52b2c9da3faf", "filename": "libgo/go/go/typechecker/typechecker.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftypechecker.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftypechecker.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftypechecker.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// INCOMPLETE PACKAGE.\n+// DEPRECATED PACKAGE - SEE go/types INSTEAD.\n // This package implements typechecking of a Go AST.\n // The result of the typecheck is an augmented AST\n // with object and type information for each identifier."}, {"sha": "6fdc22f6b34b004b4b5b4907098488e1f1be9990", "filename": "libgo/go/go/types/const.go", "status": "added", "additions": 347, "deletions": 0, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Ftypes%2Fconst.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Ftypes%2Fconst.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fconst.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -0,0 +1,347 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// This file implements operations on ideal constants.\n+\n+package types\n+\n+import (\n+\t\"big\"\n+\t\"go/token\"\n+\t\"strconv\"\n+)\n+\n+\n+// TODO(gri) Consider changing the API so Const is an interface\n+//           and operations on consts don't have to type switch.\n+\n+// A Const implements an ideal constant Value.\n+// The zero value z for a Const is not a valid constant value.\n+type Const struct {\n+\t// representation of constant values:\n+\t// ideal bool     ->  bool\n+\t// ideal int      ->  *big.Int\n+\t// ideal float    ->  *big.Rat\n+\t// ideal complex  ->  cmplx\n+\t// ideal string   ->  string\n+\tval interface{}\n+}\n+\n+\n+// Representation of complex values.\n+type cmplx struct {\n+\tre, im *big.Rat\n+}\n+\n+\n+func assert(cond bool) {\n+\tif !cond {\n+\t\tpanic(\"go/types internal error: assertion failed\")\n+\t}\n+}\n+\n+\n+// MakeConst makes an ideal constant from a literal\n+// token and the corresponding literal string.\n+func MakeConst(tok token.Token, lit string) Const {\n+\tswitch tok {\n+\tcase token.INT:\n+\t\tvar x big.Int\n+\t\t_, ok := x.SetString(lit, 0)\n+\t\tassert(ok)\n+\t\treturn Const{&x}\n+\tcase token.FLOAT:\n+\t\tvar y big.Rat\n+\t\t_, ok := y.SetString(lit)\n+\t\tassert(ok)\n+\t\treturn Const{&y}\n+\tcase token.IMAG:\n+\t\tassert(lit[len(lit)-1] == 'i')\n+\t\tvar im big.Rat\n+\t\t_, ok := im.SetString(lit[0 : len(lit)-1])\n+\t\tassert(ok)\n+\t\treturn Const{cmplx{big.NewRat(0, 1), &im}}\n+\tcase token.CHAR:\n+\t\tassert(lit[0] == '\\'' && lit[len(lit)-1] == '\\'')\n+\t\tcode, _, _, err := strconv.UnquoteChar(lit[1:len(lit)-1], '\\'')\n+\t\tassert(err == nil)\n+\t\treturn Const{big.NewInt(int64(code))}\n+\tcase token.STRING:\n+\t\ts, err := strconv.Unquote(lit)\n+\t\tassert(err == nil)\n+\t\treturn Const{s}\n+\t}\n+\tpanic(\"unreachable\")\n+}\n+\n+\n+// MakeZero returns the zero constant for the given type.\n+func MakeZero(typ *Type) Const {\n+\t// TODO(gri) fix this\n+\treturn Const{0}\n+}\n+\n+\n+// Match attempts to match the internal constant representations of x and y.\n+// If the attempt is successful, the result is the values of x and y,\n+// if necessary converted to have the same internal representation; otherwise\n+// the results are invalid.\n+func (x Const) Match(y Const) (u, v Const) {\n+\tswitch a := x.val.(type) {\n+\tcase bool:\n+\t\tif _, ok := y.val.(bool); ok {\n+\t\t\tu, v = x, y\n+\t\t}\n+\tcase *big.Int:\n+\t\tswitch y.val.(type) {\n+\t\tcase *big.Int:\n+\t\t\tu, v = x, y\n+\t\tcase *big.Rat:\n+\t\t\tvar z big.Rat\n+\t\t\tz.SetInt(a)\n+\t\t\tu, v = Const{&z}, y\n+\t\tcase cmplx:\n+\t\t\tvar z big.Rat\n+\t\t\tz.SetInt(a)\n+\t\t\tu, v = Const{cmplx{&z, big.NewRat(0, 1)}}, y\n+\t\t}\n+\tcase *big.Rat:\n+\t\tswitch y.val.(type) {\n+\t\tcase *big.Int:\n+\t\t\tv, u = y.Match(x)\n+\t\tcase *big.Rat:\n+\t\t\tu, v = x, y\n+\t\tcase cmplx:\n+\t\t\tu, v = Const{cmplx{a, big.NewRat(0, 0)}}, y\n+\t\t}\n+\tcase cmplx:\n+\t\tswitch y.val.(type) {\n+\t\tcase *big.Int, *big.Rat:\n+\t\t\tv, u = y.Match(x)\n+\t\tcase cmplx:\n+\t\t\tu, v = x, y\n+\t\t}\n+\tcase string:\n+\t\tif _, ok := y.val.(string); ok {\n+\t\t\tu, v = x, y\n+\t\t}\n+\tdefault:\n+\t\tpanic(\"unreachable\")\n+\t}\n+\treturn\n+}\n+\n+\n+// Convert attempts to convert the constant x to a given type.\n+// If the attempt is successful, the result is the new constant;\n+// otherwise the result is invalid.\n+func (x Const) Convert(typ *Type) Const {\n+\t// TODO(gri) implement this\n+\tswitch x := x.val.(type) {\n+\tcase bool:\n+\tcase *big.Int:\n+\tcase *big.Rat:\n+\tcase cmplx:\n+\tcase string:\n+\t}\n+\treturn x\n+}\n+\n+\n+func (x Const) String() string {\n+\tswitch x := x.val.(type) {\n+\tcase bool:\n+\t\tif x {\n+\t\t\treturn \"true\"\n+\t\t}\n+\t\treturn \"false\"\n+\tcase *big.Int:\n+\t\treturn x.String()\n+\tcase *big.Rat:\n+\t\treturn x.FloatString(10) // 10 digits of precision after decimal point seems fine\n+\tcase cmplx:\n+\t\t// TODO(gri) don't print 0 components\n+\t\treturn x.re.FloatString(10) + \" + \" + x.im.FloatString(10) + \"i\"\n+\tcase string:\n+\t\treturn x\n+\t}\n+\tpanic(\"unreachable\")\n+}\n+\n+\n+func (x Const) UnaryOp(op token.Token) Const {\n+\tpanic(\"unimplemented\")\n+}\n+\n+\n+func (x Const) BinaryOp(op token.Token, y Const) Const {\n+\tvar z interface{}\n+\tswitch x := x.val.(type) {\n+\tcase bool:\n+\t\tz = binaryBoolOp(x, op, y.val.(bool))\n+\tcase *big.Int:\n+\t\tz = binaryIntOp(x, op, y.val.(*big.Int))\n+\tcase *big.Rat:\n+\t\tz = binaryFloatOp(x, op, y.val.(*big.Rat))\n+\tcase cmplx:\n+\t\tz = binaryCmplxOp(x, op, y.val.(cmplx))\n+\tcase string:\n+\t\tz = binaryStringOp(x, op, y.val.(string))\n+\tdefault:\n+\t\tpanic(\"unreachable\")\n+\t}\n+\treturn Const{z}\n+}\n+\n+\n+func binaryBoolOp(x bool, op token.Token, y bool) interface{} {\n+\tswitch op {\n+\tcase token.EQL:\n+\t\treturn x == y\n+\tcase token.NEQ:\n+\t\treturn x != y\n+\t}\n+\tpanic(\"unreachable\")\n+}\n+\n+\n+func binaryIntOp(x *big.Int, op token.Token, y *big.Int) interface{} {\n+\tvar z big.Int\n+\tswitch op {\n+\tcase token.ADD:\n+\t\treturn z.Add(x, y)\n+\tcase token.SUB:\n+\t\treturn z.Sub(x, y)\n+\tcase token.MUL:\n+\t\treturn z.Mul(x, y)\n+\tcase token.QUO:\n+\t\treturn z.Quo(x, y)\n+\tcase token.REM:\n+\t\treturn z.Rem(x, y)\n+\tcase token.AND:\n+\t\treturn z.And(x, y)\n+\tcase token.OR:\n+\t\treturn z.Or(x, y)\n+\tcase token.XOR:\n+\t\treturn z.Xor(x, y)\n+\tcase token.AND_NOT:\n+\t\treturn z.AndNot(x, y)\n+\tcase token.SHL:\n+\t\tpanic(\"unimplemented\")\n+\tcase token.SHR:\n+\t\tpanic(\"unimplemented\")\n+\tcase token.EQL:\n+\t\treturn x.Cmp(y) == 0\n+\tcase token.NEQ:\n+\t\treturn x.Cmp(y) != 0\n+\tcase token.LSS:\n+\t\treturn x.Cmp(y) < 0\n+\tcase token.LEQ:\n+\t\treturn x.Cmp(y) <= 0\n+\tcase token.GTR:\n+\t\treturn x.Cmp(y) > 0\n+\tcase token.GEQ:\n+\t\treturn x.Cmp(y) >= 0\n+\t}\n+\tpanic(\"unreachable\")\n+}\n+\n+\n+func binaryFloatOp(x *big.Rat, op token.Token, y *big.Rat) interface{} {\n+\tvar z big.Rat\n+\tswitch op {\n+\tcase token.ADD:\n+\t\treturn z.Add(x, y)\n+\tcase token.SUB:\n+\t\treturn z.Sub(x, y)\n+\tcase token.MUL:\n+\t\treturn z.Mul(x, y)\n+\tcase token.QUO:\n+\t\treturn z.Quo(x, y)\n+\tcase token.EQL:\n+\t\treturn x.Cmp(y) == 0\n+\tcase token.NEQ:\n+\t\treturn x.Cmp(y) != 0\n+\tcase token.LSS:\n+\t\treturn x.Cmp(y) < 0\n+\tcase token.LEQ:\n+\t\treturn x.Cmp(y) <= 0\n+\tcase token.GTR:\n+\t\treturn x.Cmp(y) > 0\n+\tcase token.GEQ:\n+\t\treturn x.Cmp(y) >= 0\n+\t}\n+\tpanic(\"unreachable\")\n+}\n+\n+\n+func binaryCmplxOp(x cmplx, op token.Token, y cmplx) interface{} {\n+\ta, b := x.re, x.im\n+\tc, d := y.re, y.im\n+\tswitch op {\n+\tcase token.ADD:\n+\t\t// (a+c) + i(b+d)\n+\t\tvar re, im big.Rat\n+\t\tre.Add(a, c)\n+\t\tim.Add(b, d)\n+\t\treturn cmplx{&re, &im}\n+\tcase token.SUB:\n+\t\t// (a-c) + i(b-d)\n+\t\tvar re, im big.Rat\n+\t\tre.Sub(a, c)\n+\t\tim.Sub(b, d)\n+\t\treturn cmplx{&re, &im}\n+\tcase token.MUL:\n+\t\t// (ac-bd) + i(bc+ad)\n+\t\tvar ac, bd, bc, ad big.Rat\n+\t\tac.Mul(a, c)\n+\t\tbd.Mul(b, d)\n+\t\tbc.Mul(b, c)\n+\t\tad.Mul(a, d)\n+\t\tvar re, im big.Rat\n+\t\tre.Sub(&ac, &bd)\n+\t\tim.Add(&bc, &ad)\n+\t\treturn cmplx{&re, &im}\n+\tcase token.QUO:\n+\t\t// (ac+bd)/s + i(bc-ad)/s, with s = cc + dd\n+\t\tvar ac, bd, bc, ad, s big.Rat\n+\t\tac.Mul(a, c)\n+\t\tbd.Mul(b, d)\n+\t\tbc.Mul(b, c)\n+\t\tad.Mul(a, d)\n+\t\ts.Add(c.Mul(c, c), d.Mul(d, d))\n+\t\tvar re, im big.Rat\n+\t\tre.Add(&ac, &bd)\n+\t\tre.Quo(&re, &s)\n+\t\tim.Sub(&bc, &ad)\n+\t\tim.Quo(&im, &s)\n+\t\treturn cmplx{&re, &im}\n+\tcase token.EQL:\n+\t\treturn a.Cmp(c) == 0 && b.Cmp(d) == 0\n+\tcase token.NEQ:\n+\t\treturn a.Cmp(c) != 0 || b.Cmp(d) != 0\n+\t}\n+\tpanic(\"unreachable\")\n+}\n+\n+\n+func binaryStringOp(x string, op token.Token, y string) interface{} {\n+\tswitch op {\n+\tcase token.ADD:\n+\t\treturn x + y\n+\tcase token.EQL:\n+\t\treturn x == y\n+\tcase token.NEQ:\n+\t\treturn x != y\n+\tcase token.LSS:\n+\t\treturn x < y\n+\tcase token.LEQ:\n+\t\treturn x <= y\n+\tcase token.GTR:\n+\t\treturn x > y\n+\tcase token.GEQ:\n+\t\treturn x >= y\n+\t}\n+\tpanic(\"unreachable\")\n+}"}, {"sha": "cb08ffe18a2ffd269ef594728e78fe65c63438ef", "filename": "libgo/go/go/types/exportdata.go", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Ftypes%2Fexportdata.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Ftypes%2Fexportdata.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fexportdata.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -0,0 +1,135 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// This file implements ExportData.\n+\n+package types\n+\n+import (\n+\t\"bufio\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"strconv\"\n+\t\"strings\"\n+)\n+\n+\n+func readGopackHeader(buf *bufio.Reader) (name string, size int, err os.Error) {\n+\t// See $GOROOT/include/ar.h.\n+\thdr := make([]byte, 64+12+6+6+8+10+2)\n+\t_, err = io.ReadFull(buf, hdr)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tif trace {\n+\t\tfmt.Printf(\"header: %s\", hdr)\n+\t}\n+\ts := strings.TrimSpace(string(hdr[64+12+6+6+8:][:10]))\n+\tsize, err = strconv.Atoi(s)\n+\tif err != nil || hdr[len(hdr)-2] != '`' || hdr[len(hdr)-1] != '\\n' {\n+\t\terr = os.ErrorString(\"invalid archive header\")\n+\t\treturn\n+\t}\n+\tname = strings.TrimSpace(string(hdr[:64]))\n+\treturn\n+}\n+\n+\n+type dataReader struct {\n+\t*bufio.Reader\n+\tio.Closer\n+}\n+\n+\n+// ExportData returns a readCloser positioned at the beginning of the\n+// export data section of the given object/archive file, or an error.\n+// It is the caller's responsibility to close the readCloser.\n+//\n+func ExportData(filename string) (rc io.ReadCloser, err os.Error) {\n+\tfile, err := os.Open(filename)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\tdefer func() {\n+\t\tif err != nil {\n+\t\t\tfile.Close()\n+\t\t\t// Add file name to error.\n+\t\t\terr = fmt.Errorf(\"reading export data: %s: %v\", filename, err)\n+\t\t}\n+\t}()\n+\n+\tbuf := bufio.NewReader(file)\n+\n+\t// Read first line to make sure this is an object file.\n+\tline, err := buf.ReadSlice('\\n')\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tif string(line) == \"!<arch>\\n\" {\n+\t\t// Archive file.  Scan to __.PKGDEF, which should\n+\t\t// be second archive entry.\n+\t\tvar name string\n+\t\tvar size int\n+\n+\t\t// First entry should be __.SYMDEF.\n+\t\t// Read and discard.\n+\t\tif name, size, err = readGopackHeader(buf); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif name != \"__.SYMDEF\" {\n+\t\t\terr = os.ErrorString(\"go archive does not begin with __.SYMDEF\")\n+\t\t\treturn\n+\t\t}\n+\t\tconst block = 4096\n+\t\ttmp := make([]byte, block)\n+\t\tfor size > 0 {\n+\t\t\tn := size\n+\t\t\tif n > block {\n+\t\t\t\tn = block\n+\t\t\t}\n+\t\t\t_, err = io.ReadFull(buf, tmp[:n])\n+\t\t\tif err != nil {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tsize -= n\n+\t\t}\n+\n+\t\t// Second entry should be __.PKGDEF.\n+\t\tif name, size, err = readGopackHeader(buf); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif name != \"__.PKGDEF\" {\n+\t\t\terr = os.ErrorString(\"go archive is missing __.PKGDEF\")\n+\t\t\treturn\n+\t\t}\n+\n+\t\t// Read first line of __.PKGDEF data, so that line\n+\t\t// is once again the first line of the input.\n+\t\tline, err = buf.ReadSlice('\\n')\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n+\t// Now at __.PKGDEF in archive or still at beginning of file.\n+\t// Either way, line should begin with \"go object \".\n+\tif !strings.HasPrefix(string(line), \"go object \") {\n+\t\terr = os.ErrorString(\"not a go object file\")\n+\t\treturn\n+\t}\n+\n+\t// Skip over object header to export data.\n+\t// Begins after first line with $$.\n+\tfor line[0] != '$' {\n+\t\tline, err = buf.ReadSlice('\\n')\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n+\trc = &dataReader{buf, file}\n+\treturn\n+}"}, {"sha": "30adc04e729efd2e1cd93eff4da0e16813e5e917", "filename": "libgo/go/go/types/gcimporter.go", "status": "added", "additions": 792, "deletions": 0, "changes": 792, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Ftypes%2Fgcimporter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Ftypes%2Fgcimporter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fgcimporter.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -0,0 +1,792 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// This file implements an ast.Importer for gc generated object files.\n+// TODO(gri) Eventually move this into a separate package outside types.\n+\n+package types\n+\n+import (\n+\t\"big\"\n+\t\"fmt\"\n+\t\"go/ast\"\n+\t\"go/token\"\n+\t\"io\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"runtime\"\n+\t\"scanner\"\n+\t\"strconv\"\n+)\n+\n+\n+const trace = false // set to true for debugging\n+\n+var (\n+\tpkgRoot = filepath.Join(runtime.GOROOT(), \"pkg\", runtime.GOOS+\"_\"+runtime.GOARCH)\n+\tpkgExts = [...]string{\".a\", \".5\", \".6\", \".8\"}\n+)\n+\n+\n+// findPkg returns the filename and package id for an import path.\n+// If no file was found, an empty filename is returned.\n+func findPkg(path string) (filename, id string) {\n+\tif len(path) == 0 {\n+\t\treturn\n+\t}\n+\n+\tid = path\n+\tvar noext string\n+\tswitch path[0] {\n+\tdefault:\n+\t\t// \"x\" -> \"$GOROOT/pkg/$GOOS_$GOARCH/x.ext\", \"x\"\n+\t\tnoext = filepath.Join(pkgRoot, path)\n+\n+\tcase '.':\n+\t\t// \"./x\" -> \"/this/directory/x.ext\", \"/this/directory/x\"\n+\t\tcwd, err := os.Getwd()\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tnoext = filepath.Join(cwd, path)\n+\t\tid = noext\n+\n+\tcase '/':\n+\t\t// \"/x\" -> \"/x.ext\", \"/x\"\n+\t\tnoext = path\n+\t}\n+\n+\t// try extensions\n+\tfor _, ext := range pkgExts {\n+\t\tfilename = noext + ext\n+\t\tif f, err := os.Stat(filename); err == nil && f.IsRegular() {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n+\tfilename = \"\" // not found\n+\treturn\n+}\n+\n+\n+// gcParser parses the exports inside a gc compiler-produced\n+// object/archive file and populates its scope with the results.\n+type gcParser struct {\n+\tscanner scanner.Scanner\n+\ttok     int                   // current token\n+\tlit     string                // literal string; only valid for Ident, Int, String tokens\n+\tid      string                // package id of imported package\n+\tscope   *ast.Scope            // scope of imported package; alias for deps[id]\n+\tdeps    map[string]*ast.Scope // package id -> package scope\n+}\n+\n+\n+func (p *gcParser) init(filename, id string, src io.Reader) {\n+\tp.scanner.Init(src)\n+\tp.scanner.Error = func(_ *scanner.Scanner, msg string) { p.error(msg) }\n+\tp.scanner.Mode = scanner.ScanIdents | scanner.ScanInts | scanner.ScanStrings | scanner.ScanComments | scanner.SkipComments\n+\tp.scanner.Whitespace = 1<<'\\t' | 1<<' '\n+\tp.scanner.Filename = filename // for good error messages\n+\tp.next()\n+\tp.id = id\n+\tp.scope = ast.NewScope(nil)\n+\tp.deps = map[string]*ast.Scope{\"unsafe\": Unsafe, id: p.scope}\n+}\n+\n+\n+func (p *gcParser) next() {\n+\tp.tok = p.scanner.Scan()\n+\tswitch p.tok {\n+\tcase scanner.Ident, scanner.Int, scanner.String:\n+\t\tp.lit = p.scanner.TokenText()\n+\tdefault:\n+\t\tp.lit = \"\"\n+\t}\n+\tif trace {\n+\t\tfmt.Printf(\"%s: %q -> %q\\n\", scanner.TokenString(p.tok), p.scanner.TokenText(), p.lit)\n+\t}\n+}\n+\n+\n+// GcImporter implements the ast.Importer signature.\n+func GcImporter(path string) (name string, scope *ast.Scope, err os.Error) {\n+\tif path == \"unsafe\" {\n+\t\treturn path, Unsafe, nil\n+\t}\n+\n+\tdefer func() {\n+\t\tif r := recover(); r != nil {\n+\t\t\terr = r.(importError) // will re-panic if r is not an importError\n+\t\t\tif trace {\n+\t\t\t\tpanic(err) // force a stack trace\n+\t\t\t}\n+\t\t}\n+\t}()\n+\n+\tfilename, id := findPkg(path)\n+\tif filename == \"\" {\n+\t\terr = os.ErrorString(\"can't find import: \" + id)\n+\t\treturn\n+\t}\n+\n+\tbuf, err := ExportData(filename)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tdefer buf.Close()\n+\n+\tif trace {\n+\t\tfmt.Printf(\"importing %s\\n\", filename)\n+\t}\n+\n+\tvar p gcParser\n+\tp.init(filename, id, buf)\n+\tname, scope = p.parseExport()\n+\n+\treturn\n+}\n+\n+\n+// ----------------------------------------------------------------------------\n+// Error handling\n+\n+// Internal errors are boxed as importErrors.\n+type importError struct {\n+\tpos scanner.Position\n+\terr os.Error\n+}\n+\n+\n+func (e importError) String() string {\n+\treturn fmt.Sprintf(\"import error %s (byte offset = %d): %s\", e.pos, e.pos.Offset, e.err)\n+}\n+\n+\n+func (p *gcParser) error(err interface{}) {\n+\tif s, ok := err.(string); ok {\n+\t\terr = os.ErrorString(s)\n+\t}\n+\t// panic with a runtime.Error if err is not an os.Error\n+\tpanic(importError{p.scanner.Pos(), err.(os.Error)})\n+}\n+\n+\n+func (p *gcParser) errorf(format string, args ...interface{}) {\n+\tp.error(fmt.Sprintf(format, args...))\n+}\n+\n+\n+func (p *gcParser) expect(tok int) string {\n+\tlit := p.lit\n+\tif p.tok != tok {\n+\t\tp.errorf(\"expected %q, got %q (%q)\", scanner.TokenString(tok), scanner.TokenString(p.tok), lit)\n+\t}\n+\tp.next()\n+\treturn lit\n+}\n+\n+\n+func (p *gcParser) expectSpecial(tok string) {\n+\tsep := 'x' // not white space\n+\ti := 0\n+\tfor i < len(tok) && p.tok == int(tok[i]) && sep > ' ' {\n+\t\tsep = p.scanner.Peek() // if sep <= ' ', there is white space before the next token\n+\t\tp.next()\n+\t\ti++\n+\t}\n+\tif i < len(tok) {\n+\t\tp.errorf(\"expected %q, got %q\", tok, tok[0:i])\n+\t}\n+}\n+\n+\n+func (p *gcParser) expectKeyword(keyword string) {\n+\tlit := p.expect(scanner.Ident)\n+\tif lit != keyword {\n+\t\tp.errorf(\"expected keyword %s, got %q\", keyword, lit)\n+\t}\n+}\n+\n+\n+// ----------------------------------------------------------------------------\n+// Import declarations\n+\n+// ImportPath = string_lit .\n+//\n+func (p *gcParser) parsePkgId() *ast.Scope {\n+\tid, err := strconv.Unquote(p.expect(scanner.String))\n+\tif err != nil {\n+\t\tp.error(err)\n+\t}\n+\n+\tscope := p.scope // id == \"\" stands for the imported package id\n+\tif id != \"\" {\n+\t\tif scope = p.deps[id]; scope == nil {\n+\t\t\tscope = ast.NewScope(nil)\n+\t\t\tp.deps[id] = scope\n+\t\t}\n+\t}\n+\n+\treturn scope\n+}\n+\n+\n+// dotIdentifier = ( ident | '\u00b7' ) { ident | int | '\u00b7' } .\n+func (p *gcParser) parseDotIdent() string {\n+\tident := \"\"\n+\tif p.tok != scanner.Int {\n+\t\tsep := 'x' // not white space\n+\t\tfor (p.tok == scanner.Ident || p.tok == scanner.Int || p.tok == '\u00b7') && sep > ' ' {\n+\t\t\tident += p.lit\n+\t\t\tsep = p.scanner.Peek() // if sep <= ' ', there is white space before the next token\n+\t\t\tp.next()\n+\t\t}\n+\t}\n+\tif ident == \"\" {\n+\t\tp.expect(scanner.Ident) // use expect() for error handling\n+\t}\n+\treturn ident\n+}\n+\n+\n+// ExportedName = ImportPath \".\" dotIdentifier .\n+//\n+func (p *gcParser) parseExportedName(kind ast.ObjKind) *ast.Object {\n+\tscope := p.parsePkgId()\n+\tp.expect('.')\n+\tname := p.parseDotIdent()\n+\n+\t// a type may have been declared before - if it exists\n+\t// already in the respective package scope, return that\n+\t// type\n+\tif kind == ast.Typ {\n+\t\tif obj := scope.Lookup(name); obj != nil {\n+\t\t\tassert(obj.Kind == ast.Typ)\n+\t\t\treturn obj\n+\t\t}\n+\t}\n+\n+\t// any other object must be a newly declared object -\n+\t// create it and insert it into the package scope\n+\tobj := ast.NewObj(kind, name)\n+\tif scope.Insert(obj) != nil {\n+\t\tp.errorf(\"already declared: %s\", obj.Name)\n+\t}\n+\n+\t// a new type object is a named type and may be referred\n+\t// to before the underlying type is known - set it up\n+\tif kind == ast.Typ {\n+\t\tobj.Type = &Name{Obj: obj}\n+\t}\n+\n+\treturn obj\n+}\n+\n+\n+// ----------------------------------------------------------------------------\n+// Types\n+\n+// BasicType = identifier .\n+//\n+func (p *gcParser) parseBasicType() Type {\n+\tobj := Universe.Lookup(p.expect(scanner.Ident))\n+\tif obj == nil || obj.Kind != ast.Typ {\n+\t\tp.errorf(\"not a basic type: %s\", obj.Name)\n+\t}\n+\treturn obj.Type.(Type)\n+}\n+\n+\n+// ArrayType = \"[\" int_lit \"]\" Type .\n+//\n+func (p *gcParser) parseArrayType() Type {\n+\t// \"[\" already consumed and lookahead known not to be \"]\"\n+\tlit := p.expect(scanner.Int)\n+\tp.expect(']')\n+\telt := p.parseType()\n+\tn, err := strconv.Atoui64(lit)\n+\tif err != nil {\n+\t\tp.error(err)\n+\t}\n+\treturn &Array{Len: n, Elt: elt}\n+}\n+\n+\n+// MapType = \"map\" \"[\" Type \"]\" Type .\n+//\n+func (p *gcParser) parseMapType() Type {\n+\tp.expectKeyword(\"map\")\n+\tp.expect('[')\n+\tkey := p.parseType()\n+\tp.expect(']')\n+\telt := p.parseType()\n+\treturn &Map{Key: key, Elt: elt}\n+}\n+\n+\n+// Name = identifier | \"?\" .\n+//\n+func (p *gcParser) parseName() (name string) {\n+\tswitch p.tok {\n+\tcase scanner.Ident:\n+\t\tname = p.lit\n+\t\tp.next()\n+\tcase '?':\n+\t\t// anonymous\n+\t\tp.next()\n+\tdefault:\n+\t\tp.error(\"name expected\")\n+\t}\n+\treturn\n+}\n+\n+\n+// Field = Name Type [ \":\" string_lit ] .\n+//\n+func (p *gcParser) parseField(scope *ast.Scope) {\n+\t// TODO(gri) The code below is not correct for anonymous fields:\n+\t//           The name is the type name; it should not be empty.\n+\tname := p.parseName()\n+\tftyp := p.parseType()\n+\tif name == \"\" {\n+\t\t// anonymous field - ftyp must be T or *T and T must be a type name\n+\t\tftyp = Deref(ftyp)\n+\t\tif ftyp, ok := ftyp.(*Name); ok {\n+\t\t\tname = ftyp.Obj.Name\n+\t\t} else {\n+\t\t\tp.errorf(\"anonymous field expected\")\n+\t\t}\n+\t}\n+\tif p.tok == ':' {\n+\t\tp.next()\n+\t\ttag := p.expect(scanner.String)\n+\t\t_ = tag // TODO(gri) store tag somewhere\n+\t}\n+\tfld := ast.NewObj(ast.Var, name)\n+\tfld.Type = ftyp\n+\tscope.Insert(fld)\n+}\n+\n+\n+// StructType = \"struct\" \"{\" [ FieldList ] \"}\" .\n+// FieldList  = Field { \";\" Field } .\n+//\n+func (p *gcParser) parseStructType() Type {\n+\tp.expectKeyword(\"struct\")\n+\tp.expect('{')\n+\tscope := ast.NewScope(nil)\n+\tif p.tok != '}' {\n+\t\tp.parseField(scope)\n+\t\tfor p.tok == ';' {\n+\t\t\tp.next()\n+\t\t\tp.parseField(scope)\n+\t\t}\n+\t}\n+\tp.expect('}')\n+\treturn &Struct{}\n+}\n+\n+\n+// Parameter = ( identifier | \"?\" ) [ \"...\" ] Type .\n+//\n+func (p *gcParser) parseParameter(scope *ast.Scope, isVariadic *bool) {\n+\tname := p.parseName()\n+\tif name == \"\" {\n+\t\tname = \"_\" // cannot access unnamed identifiers\n+\t}\n+\tif isVariadic != nil {\n+\t\tif *isVariadic {\n+\t\t\tp.error(\"... not on final argument\")\n+\t\t}\n+\t\tif p.tok == '.' {\n+\t\t\tp.expectSpecial(\"...\")\n+\t\t\t*isVariadic = true\n+\t\t}\n+\t}\n+\tptyp := p.parseType()\n+\tpar := ast.NewObj(ast.Var, name)\n+\tpar.Type = ptyp\n+\tscope.Insert(par)\n+}\n+\n+\n+// Parameters    = \"(\" [ ParameterList ] \")\" .\n+// ParameterList = { Parameter \",\" } Parameter .\n+//\n+func (p *gcParser) parseParameters(scope *ast.Scope, isVariadic *bool) {\n+\tp.expect('(')\n+\tif p.tok != ')' {\n+\t\tp.parseParameter(scope, isVariadic)\n+\t\tfor p.tok == ',' {\n+\t\t\tp.next()\n+\t\t\tp.parseParameter(scope, isVariadic)\n+\t\t}\n+\t}\n+\tp.expect(')')\n+}\n+\n+\n+// Signature = Parameters [ Result ] .\n+// Result    = Type | Parameters .\n+//\n+func (p *gcParser) parseSignature(scope *ast.Scope, isVariadic *bool) {\n+\tp.parseParameters(scope, isVariadic)\n+\n+\t// optional result type\n+\tswitch p.tok {\n+\tcase scanner.Ident, scanner.String, '[', '*', '<':\n+\t\t// single, unnamed result\n+\t\tresult := ast.NewObj(ast.Var, \"_\")\n+\t\tresult.Type = p.parseType()\n+\t\tscope.Insert(result)\n+\tcase '(':\n+\t\t// named or multiple result(s)\n+\t\tp.parseParameters(scope, nil)\n+\t}\n+}\n+\n+\n+// FuncType = \"func\" Signature .\n+//\n+func (p *gcParser) parseFuncType() Type {\n+\t// \"func\" already consumed\n+\tscope := ast.NewScope(nil)\n+\tisVariadic := false\n+\tp.parseSignature(scope, &isVariadic)\n+\treturn &Func{IsVariadic: isVariadic}\n+}\n+\n+\n+// MethodSpec = identifier Signature .\n+//\n+func (p *gcParser) parseMethodSpec(scope *ast.Scope) {\n+\tif p.tok == scanner.Ident {\n+\t\tp.expect(scanner.Ident)\n+\t} else {\n+\t\tp.parsePkgId()\n+\t\tp.expect('.')\n+\t\tp.parseDotIdent()\n+\t}\n+\tisVariadic := false\n+\tp.parseSignature(scope, &isVariadic)\n+}\n+\n+\n+// InterfaceType = \"interface\" \"{\" [ MethodList ] \"}\" .\n+// MethodList    = MethodSpec { \";\" MethodSpec } .\n+//\n+func (p *gcParser) parseInterfaceType() Type {\n+\tp.expectKeyword(\"interface\")\n+\tp.expect('{')\n+\tscope := ast.NewScope(nil)\n+\tif p.tok != '}' {\n+\t\tp.parseMethodSpec(scope)\n+\t\tfor p.tok == ';' {\n+\t\t\tp.next()\n+\t\t\tp.parseMethodSpec(scope)\n+\t\t}\n+\t}\n+\tp.expect('}')\n+\treturn &Interface{}\n+}\n+\n+\n+// ChanType = ( \"chan\" [ \"<-\" ] | \"<-\" \"chan\" ) Type .\n+//\n+func (p *gcParser) parseChanType() Type {\n+\tdir := ast.SEND | ast.RECV\n+\tif p.tok == scanner.Ident {\n+\t\tp.expectKeyword(\"chan\")\n+\t\tif p.tok == '<' {\n+\t\t\tp.expectSpecial(\"<-\")\n+\t\t\tdir = ast.SEND\n+\t\t}\n+\t} else {\n+\t\tp.expectSpecial(\"<-\")\n+\t\tp.expectKeyword(\"chan\")\n+\t\tdir = ast.RECV\n+\t}\n+\telt := p.parseType()\n+\treturn &Chan{Dir: dir, Elt: elt}\n+}\n+\n+\n+// Type =\n+//\tBasicType | TypeName | ArrayType | SliceType | StructType |\n+//      PointerType | FuncType | InterfaceType | MapType | ChanType |\n+//      \"(\" Type \")\" .\n+// BasicType = ident .\n+// TypeName = ExportedName .\n+// SliceType = \"[\" \"]\" Type .\n+// PointerType = \"*\" Type .\n+//\n+func (p *gcParser) parseType() Type {\n+\tswitch p.tok {\n+\tcase scanner.Ident:\n+\t\tswitch p.lit {\n+\t\tdefault:\n+\t\t\treturn p.parseBasicType()\n+\t\tcase \"struct\":\n+\t\t\treturn p.parseStructType()\n+\t\tcase \"func\":\n+\t\t\tp.next() // parseFuncType assumes \"func\" is already consumed\n+\t\t\treturn p.parseFuncType()\n+\t\tcase \"interface\":\n+\t\t\treturn p.parseInterfaceType()\n+\t\tcase \"map\":\n+\t\t\treturn p.parseMapType()\n+\t\tcase \"chan\":\n+\t\t\treturn p.parseChanType()\n+\t\t}\n+\tcase scanner.String:\n+\t\t// TypeName\n+\t\treturn p.parseExportedName(ast.Typ).Type.(Type)\n+\tcase '[':\n+\t\tp.next() // look ahead\n+\t\tif p.tok == ']' {\n+\t\t\t// SliceType\n+\t\t\tp.next()\n+\t\t\treturn &Slice{Elt: p.parseType()}\n+\t\t}\n+\t\treturn p.parseArrayType()\n+\tcase '*':\n+\t\t// PointerType\n+\t\tp.next()\n+\t\treturn &Pointer{Base: p.parseType()}\n+\tcase '<':\n+\t\treturn p.parseChanType()\n+\tcase '(':\n+\t\t// \"(\" Type \")\"\n+\t\tp.next()\n+\t\ttyp := p.parseType()\n+\t\tp.expect(')')\n+\t\treturn typ\n+\t}\n+\tp.errorf(\"expected type, got %s (%q)\", scanner.TokenString(p.tok), p.lit)\n+\treturn nil\n+}\n+\n+\n+// ----------------------------------------------------------------------------\n+// Declarations\n+\n+// ImportDecl = \"import\" identifier string_lit .\n+//\n+func (p *gcParser) parseImportDecl() {\n+\tp.expectKeyword(\"import\")\n+\t// The identifier has no semantic meaning in the import data.\n+\t// It exists so that error messages can print the real package\n+\t// name: binary.ByteOrder instead of \"encoding/binary\".ByteOrder.\n+\t// TODO(gri): Save package id -> package name mapping.\n+\tp.expect(scanner.Ident)\n+\tp.parsePkgId()\n+}\n+\n+\n+// int_lit = [ \"+\" | \"-\" ] { \"0\" ... \"9\" } .\n+//\n+func (p *gcParser) parseInt() (sign, val string) {\n+\tswitch p.tok {\n+\tcase '-':\n+\t\tp.next()\n+\t\tsign = \"-\"\n+\tcase '+':\n+\t\tp.next()\n+\t}\n+\tval = p.expect(scanner.Int)\n+\treturn\n+}\n+\n+\n+// number = int_lit [ \"p\" int_lit ] .\n+//\n+func (p *gcParser) parseNumber() Const {\n+\t// mantissa\n+\tsign, val := p.parseInt()\n+\tmant, ok := new(big.Int).SetString(sign+val, 10)\n+\tassert(ok)\n+\n+\tif p.lit == \"p\" {\n+\t\t// exponent (base 2)\n+\t\tp.next()\n+\t\tsign, val = p.parseInt()\n+\t\texp, err := strconv.Atoui(val)\n+\t\tif err != nil {\n+\t\t\tp.error(err)\n+\t\t}\n+\t\tif sign == \"-\" {\n+\t\t\tdenom := big.NewInt(1)\n+\t\t\tdenom.Lsh(denom, exp)\n+\t\t\treturn Const{new(big.Rat).SetFrac(mant, denom)}\n+\t\t}\n+\t\tif exp > 0 {\n+\t\t\tmant.Lsh(mant, exp)\n+\t\t}\n+\t\treturn Const{new(big.Rat).SetInt(mant)}\n+\t}\n+\n+\treturn Const{mant}\n+}\n+\n+\n+// ConstDecl   = \"const\" ExportedName [ Type ] \"=\" Literal .\n+// Literal     = bool_lit | int_lit | float_lit | complex_lit | string_lit .\n+// bool_lit    = \"true\" | \"false\" .\n+// complex_lit = \"(\" float_lit \"+\" float_lit \")\" .\n+// string_lit  = `\"` { unicode_char } `\"` .\n+//\n+func (p *gcParser) parseConstDecl() {\n+\tp.expectKeyword(\"const\")\n+\tobj := p.parseExportedName(ast.Con)\n+\tvar x Const\n+\tvar typ Type\n+\tif p.tok != '=' {\n+\t\tobj.Type = p.parseType()\n+\t}\n+\tp.expect('=')\n+\tswitch p.tok {\n+\tcase scanner.Ident:\n+\t\t// bool_lit\n+\t\tif p.lit != \"true\" && p.lit != \"false\" {\n+\t\t\tp.error(\"expected true or false\")\n+\t\t}\n+\t\tx = Const{p.lit == \"true\"}\n+\t\ttyp = Bool.Underlying\n+\t\tp.next()\n+\tcase '-', scanner.Int:\n+\t\t// int_lit\n+\t\tx = p.parseNumber()\n+\t\ttyp = Int.Underlying\n+\t\tif _, ok := x.val.(*big.Rat); ok {\n+\t\t\ttyp = Float64.Underlying\n+\t\t}\n+\tcase '(':\n+\t\t// complex_lit\n+\t\tp.next()\n+\t\tre := p.parseNumber()\n+\t\tp.expect('+')\n+\t\tim := p.parseNumber()\n+\t\tp.expect(')')\n+\t\tx = Const{cmplx{re.val.(*big.Rat), im.val.(*big.Rat)}}\n+\t\ttyp = Complex128.Underlying\n+\tcase scanner.String:\n+\t\t// string_lit\n+\t\tx = MakeConst(token.STRING, p.lit)\n+\t\tp.next()\n+\t\ttyp = String.Underlying\n+\tdefault:\n+\t\tp.error(\"expected literal\")\n+\t}\n+\tif obj.Type == nil {\n+\t\tobj.Type = typ\n+\t}\n+\t_ = x // TODO(gri) store x somewhere\n+}\n+\n+\n+// TypeDecl = \"type\" ExportedName Type .\n+//\n+func (p *gcParser) parseTypeDecl() {\n+\tp.expectKeyword(\"type\")\n+\tobj := p.parseExportedName(ast.Typ)\n+\ttyp := p.parseType()\n+\n+\tname := obj.Type.(*Name)\n+\tassert(name.Underlying == nil)\n+\tassert(Underlying(typ) == typ)\n+\tname.Underlying = typ\n+}\n+\n+\n+// VarDecl = \"var\" ExportedName Type .\n+//\n+func (p *gcParser) parseVarDecl() {\n+\tp.expectKeyword(\"var\")\n+\tobj := p.parseExportedName(ast.Var)\n+\tobj.Type = p.parseType()\n+}\n+\n+\n+// FuncDecl = \"func\" ExportedName Signature .\n+//\n+func (p *gcParser) parseFuncDecl() {\n+\t// \"func\" already consumed\n+\tobj := p.parseExportedName(ast.Fun)\n+\tobj.Type = p.parseFuncType()\n+}\n+\n+\n+// MethodDecl = \"func\" Receiver identifier Signature .\n+// Receiver   = \"(\" ( identifier | \"?\" ) [ \"*\" ] ExportedName \")\" .\n+//\n+func (p *gcParser) parseMethodDecl() {\n+\t// \"func\" already consumed\n+\tscope := ast.NewScope(nil) // method scope\n+\tp.expect('(')\n+\tp.parseParameter(scope, nil) // receiver\n+\tp.expect(')')\n+\tp.expect(scanner.Ident)\n+\tisVariadic := false\n+\tp.parseSignature(scope, &isVariadic)\n+\n+}\n+\n+\n+// Decl = [ ImportDecl | ConstDecl | TypeDecl | VarDecl | FuncDecl | MethodDecl ] \"\\n\" .\n+//\n+func (p *gcParser) parseDecl() {\n+\tswitch p.lit {\n+\tcase \"import\":\n+\t\tp.parseImportDecl()\n+\tcase \"const\":\n+\t\tp.parseConstDecl()\n+\tcase \"type\":\n+\t\tp.parseTypeDecl()\n+\tcase \"var\":\n+\t\tp.parseVarDecl()\n+\tcase \"func\":\n+\t\tp.next() // look ahead\n+\t\tif p.tok == '(' {\n+\t\t\tp.parseMethodDecl()\n+\t\t} else {\n+\t\t\tp.parseFuncDecl()\n+\t\t}\n+\t}\n+\tp.expect('\\n')\n+}\n+\n+\n+// ----------------------------------------------------------------------------\n+// Export\n+\n+// Export        = \"PackageClause { Decl } \"$$\" .\n+// PackageClause = \"package\" identifier [ \"safe\" ] \"\\n\" .\n+//\n+func (p *gcParser) parseExport() (string, *ast.Scope) {\n+\tp.expectKeyword(\"package\")\n+\tname := p.expect(scanner.Ident)\n+\tif p.tok != '\\n' {\n+\t\t// A package is safe if it was compiled with the -u flag,\n+\t\t// which disables the unsafe package.\n+\t\t// TODO(gri) remember \"safe\" package\n+\t\tp.expectKeyword(\"safe\")\n+\t}\n+\tp.expect('\\n')\n+\n+\tfor p.tok != '$' && p.tok != scanner.EOF {\n+\t\tp.parseDecl()\n+\t}\n+\n+\tif ch := p.scanner.Peek(); p.tok != '$' || ch != '$' {\n+\t\t// don't call next()/expect() since reading past the\n+\t\t// export data may cause scanner errors (e.g. NUL chars)\n+\t\tp.errorf(\"expected '$$', got %s %c\", scanner.TokenString(p.tok), ch)\n+\t}\n+\n+\tif n := p.scanner.ErrorCount; n != 0 {\n+\t\tp.errorf(\"expected no scanner errors, got %d\", n)\n+\t}\n+\n+\treturn name, p.scope\n+}"}, {"sha": "556e761df2db61112be2a68697415e1b443ee124", "filename": "libgo/go/go/types/gcimporter_test.go", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Ftypes%2Fgcimporter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Ftypes%2Fgcimporter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fgcimporter_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -0,0 +1,111 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package types\n+\n+import (\n+\t\"exec\"\n+\t\"io/ioutil\"\n+\t\"path/filepath\"\n+\t\"runtime\"\n+\t\"strings\"\n+\t\"testing\"\n+\t\"time\"\n+)\n+\n+\n+var gcName, gcPath string // compiler name and path\n+\n+func init() {\n+\t// determine compiler\n+\tswitch runtime.GOARCH {\n+\tcase \"386\":\n+\t\tgcName = \"8g\"\n+\tcase \"amd64\":\n+\t\tgcName = \"6g\"\n+\tcase \"arm\":\n+\t\tgcName = \"5g\"\n+\tdefault:\n+\t\tgcName = \"unknown-GOARCH-compiler\"\n+\t\tgcPath = gcName\n+\t\treturn\n+\t}\n+\tgcPath, _ = exec.LookPath(gcName)\n+}\n+\n+\n+func compile(t *testing.T, dirname, filename string) {\n+\tcmd, err := exec.Run(gcPath, []string{gcPath, filename}, nil, dirname, exec.DevNull, exec.Pipe, exec.MergeWithStdout)\n+\tif err != nil {\n+\t\tt.Errorf(\"%s %s failed: %s\", gcName, filename, err)\n+\t\treturn\n+\t}\n+\tdefer cmd.Close()\n+\n+\tmsg, err := cmd.Wait(0)\n+\tif err != nil {\n+\t\tt.Errorf(\"%s %s failed: %s\", gcName, filename, err)\n+\t\treturn\n+\t}\n+\n+\tif !msg.Exited() || msg.ExitStatus() != 0 {\n+\t\tt.Errorf(\"%s %s failed: exit status = %d\", gcName, filename, msg.ExitStatus())\n+\t\toutput, _ := ioutil.ReadAll(cmd.Stdout)\n+\t\tt.Log(string(output))\n+\t}\n+}\n+\n+\n+func testPath(t *testing.T, path string) bool {\n+\t_, _, err := GcImporter(path)\n+\tif err != nil {\n+\t\tt.Errorf(\"testPath(%s): %s\", path, err)\n+\t\treturn false\n+\t}\n+\treturn true\n+}\n+\n+\n+const maxTime = 3e9 // maximum allotted testing time in ns\n+\n+func testDir(t *testing.T, dir string, endTime int64) (nimports int) {\n+\tdirname := filepath.Join(pkgRoot, dir)\n+\tlist, err := ioutil.ReadDir(dirname)\n+\tif err != nil {\n+\t\tt.Errorf(\"testDir(%s): %s\", dirname, err)\n+\t}\n+\tfor _, f := range list {\n+\t\tif time.Nanoseconds() >= endTime {\n+\t\t\tt.Log(\"testing time used up\")\n+\t\t\treturn\n+\t\t}\n+\t\tswitch {\n+\t\tcase f.IsRegular():\n+\t\t\t// try extensions\n+\t\t\tfor _, ext := range pkgExts {\n+\t\t\t\tif strings.HasSuffix(f.Name, ext) {\n+\t\t\t\t\tname := f.Name[0 : len(f.Name)-len(ext)] // remove extension\n+\t\t\t\t\tif testPath(t, filepath.Join(dir, name)) {\n+\t\t\t\t\t\tnimports++\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\tcase f.IsDirectory():\n+\t\t\tnimports += testDir(t, filepath.Join(dir, f.Name), endTime)\n+\t\t}\n+\t}\n+\treturn\n+}\n+\n+\n+func TestGcImport(t *testing.T) {\n+\tcompile(t, \"testdata\", \"exports.go\")\n+\n+\tnimports := 0\n+\tif testPath(t, \"./testdata/exports\") {\n+\t\tnimports++\n+\t}\n+\tnimports += testDir(t, \"\", time.Nanoseconds()+maxTime) // installed packages\n+\tt.Logf(\"tested %d imports\", nimports)\n+}"}, {"sha": "13efe012a0bb51fb17b38668d296a731fe752e41", "filename": "libgo/go/go/types/testdata/exports.go", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fexports.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fexports.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fexports.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -0,0 +1,89 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// This file is used to generate a .6 object file which\n+// serves as test file for gcimporter_test.go.\n+\n+package exports\n+\n+import (\n+\t\"go/ast\"\n+)\n+\n+\n+const (\n+\tC0 int = 0\n+\tC1 = 3.14159265\n+\tC2 = 2.718281828i\n+\tC3 = -123.456e-789\n+\tC4 = +123.456E+789\n+\tC5 = 1234i\n+\tC6 = \"foo\\n\"\n+\tC7 = `bar\\n`\n+)\n+\n+\n+type (\n+\tT1  int\n+\tT2  [10]int\n+\tT3  []int\n+\tT4  *int\n+\tT5  chan int\n+\tT6a chan<- int\n+\tT6b chan (<-chan int)\n+\tT6c chan<- (chan int)\n+\tT7  <-chan *ast.File\n+\tT8  struct{}\n+\tT9  struct {\n+\t\ta    int\n+\t\tb, c float32\n+\t\td    []string \"tag\"\n+\t}\n+\tT10 struct {\n+\t\tT8\n+\t\tT9\n+\t\t_ *T10\n+\t}\n+\tT11 map[int]string\n+\tT12 interface{}\n+\tT13 interface {\n+\t\tm1()\n+\t\tm2(int) float32\n+\t}\n+\tT14 interface {\n+\t\tT12\n+\t\tT13\n+\t\tm3(x ...struct{}) []T9\n+\t}\n+\tT15 func()\n+\tT16 func(int)\n+\tT17 func(x int)\n+\tT18 func() float32\n+\tT19 func() (x float32)\n+\tT20 func(...interface{})\n+\tT21 struct{ next *T21 }\n+\tT22 struct{ link *T23 }\n+\tT23 struct{ link *T22 }\n+\tT24 *T24\n+\tT25 *T26\n+\tT26 *T27\n+\tT27 *T25\n+\tT28 func(T28) T28\n+)\n+\n+\n+var (\n+\tV0 int\n+\tV1 = -991.0\n+)\n+\n+\n+func F1()         {}\n+func F2(x int)    {}\n+func F3() int     { return 0 }\n+func F4() float32 { return 0 }\n+func F5(a, b, c int, u, v, w struct{ x, y T1 }, more ...interface{}) (p, q, r chan<- T10)\n+\n+\n+func (p *T1) M1()"}, {"sha": "2ee645d989b751ef4131b4608c91a03a01546bf1", "filename": "libgo/go/go/types/types.go", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Ftypes%2Ftypes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Ftypes%2Ftypes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftypes.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -0,0 +1,122 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// PACKAGE UNDER CONSTRUCTION. ANY AND ALL PARTS MAY CHANGE.\n+// Package types declares the types used to represent Go types.\n+//\n+package types\n+\n+import \"go/ast\"\n+\n+\n+// All types implement the Type interface.\n+type Type interface {\n+\tisType()\n+}\n+\n+\n+// All concrete types embed ImplementsType which\n+// ensures that all types implement the Type interface.\n+type ImplementsType struct{}\n+\n+func (t *ImplementsType) isType() {}\n+\n+\n+// A Basic represents a (unnamed) basic type.\n+type Basic struct {\n+\tImplementsType\n+\t// TODO(gri) need a field specifying the exact basic type\n+}\n+\n+\n+// An Array represents an array type [Len]Elt.\n+type Array struct {\n+\tImplementsType\n+\tLen uint64\n+\tElt Type\n+}\n+\n+\n+// A Slice represents a slice type []Elt.\n+type Slice struct {\n+\tImplementsType\n+\tElt Type\n+}\n+\n+\n+// A Struct represents a struct type struct{...}.\n+type Struct struct {\n+\tImplementsType\n+\t// TODO(gri) need to remember fields.\n+}\n+\n+\n+// A Pointer represents a pointer type *Base.\n+type Pointer struct {\n+\tImplementsType\n+\tBase Type\n+}\n+\n+\n+// A Func represents a function type func(...) (...).\n+type Func struct {\n+\tImplementsType\n+\tIsVariadic bool\n+\t// TODO(gri) need to remember parameters.\n+}\n+\n+\n+// An Interface represents an interface type interface{...}.\n+type Interface struct {\n+\tImplementsType\n+\t// TODO(gri) need to remember methods.\n+}\n+\n+\n+// A Map represents a map type map[Key]Elt.\n+type Map struct {\n+\tImplementsType\n+\tKey, Elt Type\n+}\n+\n+\n+// A Chan represents a channel type chan Elt, <-chan Elt, or chan<-Elt.\n+type Chan struct {\n+\tImplementsType\n+\tDir ast.ChanDir\n+\tElt Type\n+}\n+\n+\n+// A Name represents a named type as declared in a type declaration.\n+type Name struct {\n+\tImplementsType\n+\tUnderlying Type        // nil if not fully declared\n+\tObj        *ast.Object // corresponding declared object\n+\t// TODO(gri) need to remember fields and methods.\n+}\n+\n+\n+// If typ is a pointer type, Deref returns the pointer's base type;\n+// otherwise it returns typ.\n+func Deref(typ Type) Type {\n+\tif typ, ok := typ.(*Pointer); ok {\n+\t\treturn typ.Base\n+\t}\n+\treturn typ\n+}\n+\n+\n+// Underlying returns the underlying type of a type.\n+func Underlying(typ Type) Type {\n+\tif typ, ok := typ.(*Name); ok {\n+\t\tutyp := typ.Underlying\n+\t\tif _, ok := utyp.(*Basic); ok {\n+\t\t\treturn typ\n+\t\t}\n+\t\treturn utyp\n+\n+\t}\n+\treturn typ\n+}"}, {"sha": "2a54a8ac12c333acb2490c5bc7a53fee75d4b337", "filename": "libgo/go/go/types/universe.go", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Ftypes%2Funiverse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgo%2Ftypes%2Funiverse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Funiverse.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -0,0 +1,113 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// FILE UNDER CONSTRUCTION. ANY AND ALL PARTS MAY CHANGE.\n+// This file implements the universe and unsafe package scopes.\n+\n+package types\n+\n+import \"go/ast\"\n+\n+\n+var (\n+\tscope, // current scope to use for initialization\n+\tUniverse,\n+\tUnsafe *ast.Scope\n+)\n+\n+\n+func define(kind ast.ObjKind, name string) *ast.Object {\n+\tobj := ast.NewObj(kind, name)\n+\tif scope.Insert(obj) != nil {\n+\t\tpanic(\"types internal error: double declaration\")\n+\t}\n+\treturn obj\n+}\n+\n+\n+func defType(name string) *Name {\n+\tobj := define(ast.Typ, name)\n+\ttyp := &Name{Underlying: &Basic{}, Obj: obj}\n+\tobj.Type = typ\n+\treturn typ\n+}\n+\n+\n+func defConst(name string) {\n+\tobj := define(ast.Con, name)\n+\t_ = obj // TODO(gri) fill in other properties\n+}\n+\n+\n+func defFun(name string) {\n+\tobj := define(ast.Fun, name)\n+\t_ = obj // TODO(gri) fill in other properties\n+}\n+\n+\n+var (\n+\tBool,\n+\tInt,\n+\tFloat64,\n+\tComplex128,\n+\tString *Name\n+)\n+\n+\n+func init() {\n+\tUniverse = ast.NewScope(nil)\n+\tscope = Universe\n+\n+\tBool = defType(\"bool\")\n+\tdefType(\"byte\") // TODO(gri) should be an alias for uint8\n+\tdefType(\"complex64\")\n+\tComplex128 = defType(\"complex128\")\n+\tdefType(\"float32\")\n+\tFloat64 = defType(\"float64\")\n+\tdefType(\"int8\")\n+\tdefType(\"int16\")\n+\tdefType(\"int32\")\n+\tdefType(\"int64\")\n+\tString = defType(\"string\")\n+\tdefType(\"uint8\")\n+\tdefType(\"uint16\")\n+\tdefType(\"uint32\")\n+\tdefType(\"uint64\")\n+\tInt = defType(\"int\")\n+\tdefType(\"uint\")\n+\tdefType(\"uintptr\")\n+\n+\tdefConst(\"true\")\n+\tdefConst(\"false\")\n+\tdefConst(\"iota\")\n+\tdefConst(\"nil\")\n+\n+\tdefFun(\"append\")\n+\tdefFun(\"cap\")\n+\tdefFun(\"close\")\n+\tdefFun(\"complex\")\n+\tdefFun(\"copy\")\n+\tdefFun(\"imag\")\n+\tdefFun(\"len\")\n+\tdefFun(\"make\")\n+\tdefFun(\"new\")\n+\tdefFun(\"panic\")\n+\tdefFun(\"print\")\n+\tdefFun(\"println\")\n+\tdefFun(\"real\")\n+\tdefFun(\"recover\")\n+\n+\tUnsafe = ast.NewScope(nil)\n+\tscope = Unsafe\n+\tdefType(\"Pointer\")\n+\n+\tdefFun(\"Alignof\")\n+\tdefFun(\"New\")\n+\tdefFun(\"NewArray\")\n+\tdefFun(\"Offsetof\")\n+\tdefFun(\"Reflect\")\n+\tdefFun(\"Sizeof\")\n+\tdefFun(\"Typeof\")\n+\tdefFun(\"Unreflect\")\n+}"}, {"sha": "8961336cd342c7ae45dffccfd45dcbd8bdd4e0b2", "filename": "libgo/go/gob/codec_test.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgob%2Fcodec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgob%2Fcodec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fcodec_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -999,13 +999,12 @@ type Bad0 struct {\n \tC  float64\n }\n \n-\n func TestInvalidField(t *testing.T) {\n \tvar bad0 Bad0\n \tbad0.CH = make(chan int)\n \tb := new(bytes.Buffer)\n \tdummyEncoder := new(Encoder) // sufficient for this purpose.\n-\tdummyEncoder.encode(b, reflect.NewValue(&bad0), userType(reflect.Typeof(&bad0)))\n+\tdummyEncoder.encode(b, reflect.ValueOf(&bad0), userType(reflect.TypeOf(&bad0)))\n \tif err := dummyEncoder.err; err == nil {\n \t\tt.Error(\"expected error; got none\")\n \t} else if strings.Index(err.String(), \"type\") < 0 {"}, {"sha": "0e86df6b57a27936f8ffa6e87422759723d8f48e", "filename": "libgo/go/gob/decode.go", "status": "modified", "additions": 103, "deletions": 88, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgob%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgob%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fdecode.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -406,7 +406,7 @@ func decUint8Array(i *decInstr, state *decoderState, p unsafe.Pointer) {\n func decString(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \tif i.indir > 0 {\n \t\tif *(*unsafe.Pointer)(p) == nil {\n-\t\t\t*(*unsafe.Pointer)(p) = unsafe.Pointer(new([]byte))\n+\t\t\t*(*unsafe.Pointer)(p) = unsafe.Pointer(new(string))\n \t\t}\n \t\tp = *(*unsafe.Pointer)(p)\n \t}\n@@ -468,7 +468,7 @@ func (dec *Decoder) decodeSingle(engine *decEngine, ut *userTypeInfo, p uintptr)\n \tbasep := p\n \tdelta := int(state.decodeUint())\n \tif delta != 0 {\n-\t\terrorf(\"gob decode: corrupted data: non-zero delta for singleton\")\n+\t\terrorf(\"decode: corrupted data: non-zero delta for singleton\")\n \t}\n \tinstr := &engine.instr[singletonField]\n \tptr := unsafe.Pointer(basep) // offset will be zero\n@@ -486,14 +486,14 @@ func (dec *Decoder) decodeSingle(engine *decEngine, ut *userTypeInfo, p uintptr)\n // This state cannot arise for decodeSingle, which is called directly\n // from the user's value, not from the innards of an engine.\n func (dec *Decoder) decodeStruct(engine *decEngine, ut *userTypeInfo, p uintptr, indir int) {\n-\tp = allocate(ut.base.(*reflect.StructType), p, indir)\n+\tp = allocate(ut.base, p, indir)\n \tstate := dec.newDecoderState(&dec.buf)\n \tstate.fieldnum = -1\n \tbasep := p\n \tfor state.b.Len() > 0 {\n \t\tdelta := int(state.decodeUint())\n \t\tif delta < 0 {\n-\t\t\terrorf(\"gob decode: corrupted data: negative delta\")\n+\t\t\terrorf(\"decode: corrupted data: negative delta\")\n \t\t}\n \t\tif delta == 0 { // struct terminator is zero delta fieldnum\n \t\t\tbreak\n@@ -521,7 +521,7 @@ func (dec *Decoder) ignoreStruct(engine *decEngine) {\n \tfor state.b.Len() > 0 {\n \t\tdelta := int(state.decodeUint())\n \t\tif delta < 0 {\n-\t\t\terrorf(\"gob ignore decode: corrupted data: negative delta\")\n+\t\t\terrorf(\"ignore decode: corrupted data: negative delta\")\n \t\t}\n \t\tif delta == 0 { // struct terminator is zero delta fieldnum\n \t\t\tbreak\n@@ -544,7 +544,7 @@ func (dec *Decoder) ignoreSingle(engine *decEngine) {\n \tstate.fieldnum = singletonField\n \tdelta := int(state.decodeUint())\n \tif delta != 0 {\n-\t\terrorf(\"gob decode: corrupted data: non-zero delta for singleton\")\n+\t\terrorf(\"decode: corrupted data: non-zero delta for singleton\")\n \t}\n \tinstr := &engine.instr[singletonField]\n \tinstr.op(instr, state, unsafe.Pointer(nil))\n@@ -567,12 +567,12 @@ func (dec *Decoder) decodeArrayHelper(state *decoderState, p uintptr, elemOp dec\n // decodeArray decodes an array and stores it through p, that is, p points to the zeroth element.\n // The length is an unsigned integer preceding the elements.  Even though the length is redundant\n // (it's part of the type), it's a useful check and is included in the encoding.\n-func (dec *Decoder) decodeArray(atyp *reflect.ArrayType, state *decoderState, p uintptr, elemOp decOp, elemWid uintptr, length, indir, elemIndir int, ovfl os.ErrorString) {\n+func (dec *Decoder) decodeArray(atyp reflect.Type, state *decoderState, p uintptr, elemOp decOp, elemWid uintptr, length, indir, elemIndir int, ovfl os.ErrorString) {\n \tif indir > 0 {\n \t\tp = allocate(atyp, p, 1) // All but the last level has been allocated by dec.Indirect\n \t}\n \tif n := state.decodeUint(); n != uint64(length) {\n-\t\terrorf(\"gob: length mismatch in decodeArray\")\n+\t\terrorf(\"length mismatch in decodeArray\")\n \t}\n \tdec.decodeArrayHelper(state, p, elemOp, elemWid, length, elemIndir, ovfl)\n }\n@@ -581,7 +581,7 @@ func (dec *Decoder) decodeArray(atyp *reflect.ArrayType, state *decoderState, p\n // unlike the other items we can't use a pointer directly.\n func decodeIntoValue(state *decoderState, op decOp, indir int, v reflect.Value, ovfl os.ErrorString) reflect.Value {\n \tinstr := &decInstr{op, 0, indir, 0, ovfl}\n-\tup := unsafe.Pointer(v.UnsafeAddr())\n+\tup := unsafe.Pointer(unsafeAddr(v))\n \tif indir > 1 {\n \t\tup = decIndirect(up, indir)\n \t}\n@@ -593,24 +593,24 @@ func decodeIntoValue(state *decoderState, op decOp, indir int, v reflect.Value,\n // Maps are encoded as a length followed by key:value pairs.\n // Because the internals of maps are not visible to us, we must\n // use reflection rather than pointer magic.\n-func (dec *Decoder) decodeMap(mtyp *reflect.MapType, state *decoderState, p uintptr, keyOp, elemOp decOp, indir, keyIndir, elemIndir int, ovfl os.ErrorString) {\n+func (dec *Decoder) decodeMap(mtyp reflect.Type, state *decoderState, p uintptr, keyOp, elemOp decOp, indir, keyIndir, elemIndir int, ovfl os.ErrorString) {\n \tif indir > 0 {\n \t\tp = allocate(mtyp, p, 1) // All but the last level has been allocated by dec.Indirect\n \t}\n \tup := unsafe.Pointer(p)\n \tif *(*unsafe.Pointer)(up) == nil { // maps are represented as a pointer in the runtime\n \t\t// Allocate map.\n-\t\t*(*unsafe.Pointer)(up) = unsafe.Pointer(reflect.MakeMap(mtyp).Get())\n+\t\t*(*unsafe.Pointer)(up) = unsafe.Pointer(reflect.MakeMap(mtyp).Pointer())\n \t}\n \t// Maps cannot be accessed by moving addresses around the way\n \t// that slices etc. can.  We must recover a full reflection value for\n \t// the iteration.\n-\tv := reflect.NewValue(unsafe.Unreflect(mtyp, unsafe.Pointer(p))).(*reflect.MapValue)\n+\tv := reflect.ValueOf(unsafe.Unreflect(mtyp, unsafe.Pointer(p)))\n \tn := int(state.decodeUint())\n \tfor i := 0; i < n; i++ {\n-\t\tkey := decodeIntoValue(state, keyOp, keyIndir, reflect.MakeZero(mtyp.Key()), ovfl)\n-\t\telem := decodeIntoValue(state, elemOp, elemIndir, reflect.MakeZero(mtyp.Elem()), ovfl)\n-\t\tv.SetElem(key, elem)\n+\t\tkey := decodeIntoValue(state, keyOp, keyIndir, allocValue(mtyp.Key()), ovfl)\n+\t\telem := decodeIntoValue(state, elemOp, elemIndir, allocValue(mtyp.Elem()), ovfl)\n+\t\tv.SetMapIndex(key, elem)\n \t}\n }\n \n@@ -625,7 +625,7 @@ func (dec *Decoder) ignoreArrayHelper(state *decoderState, elemOp decOp, length\n // ignoreArray discards the data for an array value with no destination.\n func (dec *Decoder) ignoreArray(state *decoderState, elemOp decOp, length int) {\n \tif n := state.decodeUint(); n != uint64(length) {\n-\t\terrorf(\"gob: length mismatch in ignoreArray\")\n+\t\terrorf(\"length mismatch in ignoreArray\")\n \t}\n \tdec.ignoreArrayHelper(state, elemOp, length)\n }\n@@ -643,7 +643,7 @@ func (dec *Decoder) ignoreMap(state *decoderState, keyOp, elemOp decOp) {\n \n // decodeSlice decodes a slice and stores the slice header through p.\n // Slices are encoded as an unsigned length followed by the elements.\n-func (dec *Decoder) decodeSlice(atyp *reflect.SliceType, state *decoderState, p uintptr, elemOp decOp, elemWid uintptr, indir, elemIndir int, ovfl os.ErrorString) {\n+func (dec *Decoder) decodeSlice(atyp reflect.Type, state *decoderState, p uintptr, elemOp decOp, elemWid uintptr, indir, elemIndir int, ovfl os.ErrorString) {\n \tn := int(uintptr(state.decodeUint()))\n \tif indir > 0 {\n \t\tup := unsafe.Pointer(p)\n@@ -667,41 +667,35 @@ func (dec *Decoder) ignoreSlice(state *decoderState, elemOp decOp) {\n \tdec.ignoreArrayHelper(state, elemOp, int(state.decodeUint()))\n }\n \n-// setInterfaceValue sets an interface value to a concrete value through\n-// reflection.  If the concrete value does not implement the interface, the\n-// setting will panic.  This routine turns the panic into an error return.\n-// This dance avoids manually checking that the value satisfies the\n-// interface.\n-// TODO(rsc): avoid panic+recover after fixing issue 327.\n-func setInterfaceValue(ivalue *reflect.InterfaceValue, value reflect.Value) {\n-\tdefer func() {\n-\t\tif e := recover(); e != nil {\n-\t\t\terror(e.(os.Error))\n-\t\t}\n-\t}()\n+// setInterfaceValue sets an interface value to a concrete value,\n+// but first it checks that the assignment will succeed.\n+func setInterfaceValue(ivalue reflect.Value, value reflect.Value) {\n+\tif !value.Type().AssignableTo(ivalue.Type()) {\n+\t\terrorf(\"cannot assign value of type %s to %s\", value.Type(), ivalue.Type())\n+\t}\n \tivalue.Set(value)\n }\n \n // decodeInterface decodes an interface value and stores it through p.\n // Interfaces are encoded as the name of a concrete type followed by a value.\n // If the name is empty, the value is nil and no value is sent.\n-func (dec *Decoder) decodeInterface(ityp *reflect.InterfaceType, state *decoderState, p uintptr, indir int) {\n-\t// Create an interface reflect.Value.  We need one even for the nil case.\n-\tivalue := reflect.MakeZero(ityp).(*reflect.InterfaceValue)\n+func (dec *Decoder) decodeInterface(ityp reflect.Type, state *decoderState, p uintptr, indir int) {\n+\t// Create a writable interface reflect.Value.  We need one even for the nil case.\n+\tivalue := allocValue(ityp)\n \t// Read the name of the concrete type.\n \tb := make([]byte, state.decodeUint())\n \tstate.b.Read(b)\n \tname := string(b)\n \tif name == \"\" {\n \t\t// Copy the representation of the nil interface value to the target.\n \t\t// This is horribly unsafe and special.\n-\t\t*(*[2]uintptr)(unsafe.Pointer(p)) = ivalue.Get()\n+\t\t*(*[2]uintptr)(unsafe.Pointer(p)) = ivalue.InterfaceData()\n \t\treturn\n \t}\n \t// The concrete type must be registered.\n \ttyp, ok := nameToConcreteType[name]\n \tif !ok {\n-\t\terrorf(\"gob: name not registered for interface: %q\", name)\n+\t\terrorf(\"name not registered for interface: %q\", name)\n \t}\n \t// Read the type id of the concrete value.\n \tconcreteId := dec.decodeTypeSequence(true)\n@@ -712,7 +706,7 @@ func (dec *Decoder) decodeInterface(ityp *reflect.InterfaceType, state *decoderS\n \t// in case we want to ignore the value by skipping it completely).\n \tstate.decodeUint()\n \t// Read the concrete value.\n-\tvalue := reflect.MakeZero(typ)\n+\tvalue := allocValue(typ)\n \tdec.decodeValue(concreteId, value)\n \tif dec.err != nil {\n \t\terror(dec.err)\n@@ -726,7 +720,7 @@ func (dec *Decoder) decodeInterface(ityp *reflect.InterfaceType, state *decoderS\n \tsetInterfaceValue(ivalue, value)\n \t// Copy the representation of the interface value to the target.\n \t// This is horribly unsafe and special.\n-\t*(*[2]uintptr)(unsafe.Pointer(p)) = ivalue.Get()\n+\t*(*[2]uintptr)(unsafe.Pointer(p)) = ivalue.InterfaceData()\n }\n \n // ignoreInterface discards the data for an interface value with no destination.\n@@ -823,8 +817,8 @@ func (dec *Decoder) decOpFor(wireId typeId, rt reflect.Type, name string, inProg\n \tif op == nil {\n \t\tinProgress[rt] = &op\n \t\t// Special cases\n-\t\tswitch t := typ.(type) {\n-\t\tcase *reflect.ArrayType:\n+\t\tswitch t := typ; t.Kind() {\n+\t\tcase reflect.Array:\n \t\t\tname = \"element of \" + name\n \t\t\telemId := dec.wireType[wireId].ArrayT.Elem\n \t\t\telemOp, elemIndir := dec.decOpFor(elemId, t.Elem(), name, inProgress)\n@@ -833,7 +827,7 @@ func (dec *Decoder) decOpFor(wireId typeId, rt reflect.Type, name string, inProg\n \t\t\t\tstate.dec.decodeArray(t, state, uintptr(p), *elemOp, t.Elem().Size(), t.Len(), i.indir, elemIndir, ovfl)\n \t\t\t}\n \n-\t\tcase *reflect.MapType:\n+\t\tcase reflect.Map:\n \t\t\tname = \"element of \" + name\n \t\t\tkeyId := dec.wireType[wireId].MapT.Key\n \t\t\telemId := dec.wireType[wireId].MapT.Elem\n@@ -845,7 +839,7 @@ func (dec *Decoder) decOpFor(wireId typeId, rt reflect.Type, name string, inProg\n \t\t\t\tstate.dec.decodeMap(t, state, uintptr(up), *keyOp, *elemOp, i.indir, keyIndir, elemIndir, ovfl)\n \t\t\t}\n \n-\t\tcase *reflect.SliceType:\n+\t\tcase reflect.Slice:\n \t\t\tname = \"element of \" + name\n \t\t\tif t.Elem().Kind() == reflect.Uint8 {\n \t\t\t\top = decUint8Array\n@@ -863,7 +857,7 @@ func (dec *Decoder) decOpFor(wireId typeId, rt reflect.Type, name string, inProg\n \t\t\t\tstate.dec.decodeSlice(t, state, uintptr(p), *elemOp, t.Elem().Size(), i.indir, elemIndir, ovfl)\n \t\t\t}\n \n-\t\tcase *reflect.StructType:\n+\t\tcase reflect.Struct:\n \t\t\t// Generate a closure that calls out to the engine for the nested type.\n \t\t\tenginePtr, err := dec.getDecEnginePtr(wireId, userType(typ))\n \t\t\tif err != nil {\n@@ -873,14 +867,14 @@ func (dec *Decoder) decOpFor(wireId typeId, rt reflect.Type, name string, inProg\n \t\t\t\t// indirect through enginePtr to delay evaluation for recursive structs.\n \t\t\t\tdec.decodeStruct(*enginePtr, userType(typ), uintptr(p), i.indir)\n \t\t\t}\n-\t\tcase *reflect.InterfaceType:\n+\t\tcase reflect.Interface:\n \t\t\top = func(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \t\t\t\tstate.dec.decodeInterface(t, state, uintptr(p), i.indir)\n \t\t\t}\n \t\t}\n \t}\n \tif op == nil {\n-\t\terrorf(\"gob: decode can't handle type %s\", rt.String())\n+\t\terrorf(\"decode can't handle type %s\", rt.String())\n \t}\n \treturn &op, indir\n }\n@@ -901,7 +895,7 @@ func (dec *Decoder) decIgnoreOpFor(wireId typeId) decOp {\n \t\twire := dec.wireType[wireId]\n \t\tswitch {\n \t\tcase wire == nil:\n-\t\t\terrorf(\"gob: bad data: undefined type %s\", wireId.string())\n+\t\t\terrorf(\"bad data: undefined type %s\", wireId.string())\n \t\tcase wire.ArrayT != nil:\n \t\t\telemId := wire.ArrayT.Elem\n \t\t\telemOp := dec.decIgnoreOpFor(elemId)\n@@ -943,40 +937,41 @@ func (dec *Decoder) decIgnoreOpFor(wireId typeId) decOp {\n \t\t}\n \t}\n \tif op == nil {\n-\t\terrorf(\"gob: bad data: ignore can't handle type %s\", wireId.string())\n+\t\terrorf(\"bad data: ignore can't handle type %s\", wireId.string())\n \t}\n \treturn op\n }\n \n // gobDecodeOpFor returns the op for a type that is known to implement\n // GobDecoder.\n func (dec *Decoder) gobDecodeOpFor(ut *userTypeInfo) (*decOp, int) {\n-\trt := ut.user\n+\trcvrType := ut.user\n \tif ut.decIndir == -1 {\n-\t\trt = reflect.PtrTo(rt)\n+\t\trcvrType = reflect.PtrTo(rcvrType)\n \t} else if ut.decIndir > 0 {\n \t\tfor i := int8(0); i < ut.decIndir; i++ {\n-\t\t\trt = rt.(*reflect.PtrType).Elem()\n+\t\t\trcvrType = rcvrType.Elem()\n \t\t}\n \t}\n \tvar op decOp\n \top = func(i *decInstr, state *decoderState, p unsafe.Pointer) {\n-\t\t// Allocate the underlying data, but hold on to the address we have,\n-\t\t// since we need it to get to the receiver's address.\n-\t\tallocate(ut.base, uintptr(p), ut.indir)\n+\t\t// Caller has gotten us to within one indirection of our value.\n+\t\tif i.indir > 0 {\n+\t\t\tif *(*unsafe.Pointer)(p) == nil {\n+\t\t\t\t*(*unsafe.Pointer)(p) = unsafe.New(ut.base)\n+\t\t\t}\n+\t\t}\n+\t\t// Now p is a pointer to the base type.  Do we need to climb out to\n+\t\t// get to the receiver type?\n \t\tvar v reflect.Value\n \t\tif ut.decIndir == -1 {\n-\t\t\t// Need to climb up one level to turn value into pointer.\n-\t\t\tv = reflect.NewValue(unsafe.Unreflect(rt, unsafe.Pointer(&p)))\n+\t\t\tv = reflect.ValueOf(unsafe.Unreflect(rcvrType, unsafe.Pointer(&p)))\n \t\t} else {\n-\t\t\tif ut.decIndir > 0 {\n-\t\t\t\tp = decIndirect(p, int(ut.decIndir))\n-\t\t\t}\n-\t\t\tv = reflect.NewValue(unsafe.Unreflect(rt, p))\n+\t\t\tv = reflect.ValueOf(unsafe.Unreflect(rcvrType, p))\n \t\t}\n-\t\tstate.dec.decodeGobDecoder(state, v, methodIndex(rt, gobDecodeMethodName))\n+\t\tstate.dec.decodeGobDecoder(state, v, methodIndex(rcvrType, gobDecodeMethodName))\n \t}\n-\treturn &op, int(ut.decIndir)\n+\treturn &op, int(ut.indir)\n \n }\n \n@@ -999,37 +994,37 @@ func (dec *Decoder) compatibleType(fr reflect.Type, fw typeId, inProgress map[re\n \tif ut.isGobDecoder { // This test trumps all others.\n \t\treturn true\n \t}\n-\tswitch t := ut.base.(type) {\n+\tswitch t := ut.base; t.Kind() {\n \tdefault:\n \t\t// chan, etc: cannot handle.\n \t\treturn false\n-\tcase *reflect.BoolType:\n+\tcase reflect.Bool:\n \t\treturn fw == tBool\n-\tcase *reflect.IntType:\n+\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n \t\treturn fw == tInt\n-\tcase *reflect.UintType:\n+\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n \t\treturn fw == tUint\n-\tcase *reflect.FloatType:\n+\tcase reflect.Float32, reflect.Float64:\n \t\treturn fw == tFloat\n-\tcase *reflect.ComplexType:\n+\tcase reflect.Complex64, reflect.Complex128:\n \t\treturn fw == tComplex\n-\tcase *reflect.StringType:\n+\tcase reflect.String:\n \t\treturn fw == tString\n-\tcase *reflect.InterfaceType:\n+\tcase reflect.Interface:\n \t\treturn fw == tInterface\n-\tcase *reflect.ArrayType:\n+\tcase reflect.Array:\n \t\tif !ok || wire.ArrayT == nil {\n \t\t\treturn false\n \t\t}\n \t\tarray := wire.ArrayT\n \t\treturn t.Len() == array.Len && dec.compatibleType(t.Elem(), array.Elem, inProgress)\n-\tcase *reflect.MapType:\n+\tcase reflect.Map:\n \t\tif !ok || wire.MapT == nil {\n \t\t\treturn false\n \t\t}\n \t\tMapType := wire.MapT\n \t\treturn dec.compatibleType(t.Key(), MapType.Key, inProgress) && dec.compatibleType(t.Elem(), MapType.Elem, inProgress)\n-\tcase *reflect.SliceType:\n+\tcase reflect.Slice:\n \t\t// Is it an array of bytes?\n \t\tif t.Elem().Kind() == reflect.Uint8 {\n \t\t\treturn fw == tBytes\n@@ -1043,7 +1038,7 @@ func (dec *Decoder) compatibleType(fr reflect.Type, fw typeId, inProgress map[re\n \t\t}\n \t\telem := userType(t.Elem()).base\n \t\treturn sw != nil && dec.compatibleType(elem, sw.Elem, inProgress)\n-\tcase *reflect.StructType:\n+\tcase reflect.Struct:\n \t\treturn true\n \t}\n \treturn true\n@@ -1093,8 +1088,9 @@ func (dec *Decoder) compileIgnoreSingle(remoteId typeId) (engine *decEngine, err\n // it calls out to compileSingle.\n func (dec *Decoder) compileDec(remoteId typeId, ut *userTypeInfo) (engine *decEngine, err os.Error) {\n \trt := ut.base\n-\tsrt, ok := rt.(*reflect.StructType)\n-\tif !ok || ut.isGobDecoder {\n+\tsrt := rt\n+\tif srt.Kind() != reflect.Struct ||\n+\t\tut.isGobDecoder {\n \t\treturn dec.compileSingle(remoteId, ut)\n \t}\n \tvar wireStruct *structType\n@@ -1110,7 +1106,7 @@ func (dec *Decoder) compileDec(remoteId typeId, ut *userTypeInfo) (engine *decEn\n \t\twireStruct = wire.StructT\n \t}\n \tif wireStruct == nil {\n-\t\terrorf(\"gob: type mismatch in decoder: want struct type %s; got non-struct\", rt.String())\n+\t\terrorf(\"type mismatch in decoder: want struct type %s; got non-struct\", rt.String())\n \t}\n \tengine = new(decEngine)\n \tengine.instr = make([]decInstr, len(wireStruct.Field))\n@@ -1119,7 +1115,7 @@ func (dec *Decoder) compileDec(remoteId typeId, ut *userTypeInfo) (engine *decEn\n \tfor fieldnum := 0; fieldnum < len(wireStruct.Field); fieldnum++ {\n \t\twireField := wireStruct.Field[fieldnum]\n \t\tif wireField.Name == \"\" {\n-\t\t\terrorf(\"gob: empty name for remote field of type %s\", wireStruct.Name)\n+\t\t\terrorf(\"empty name for remote field of type %s\", wireStruct.Name)\n \t\t}\n \t\tovfl := overflow(wireField.Name)\n \t\t// Find the field of the local type with the same name.\n@@ -1131,7 +1127,7 @@ func (dec *Decoder) compileDec(remoteId typeId, ut *userTypeInfo) (engine *decEn\n \t\t\tcontinue\n \t\t}\n \t\tif !dec.compatibleType(localField.Type, wireField.Id, make(map[reflect.Type]typeId)) {\n-\t\t\terrorf(\"gob: wrong type (%s) for received field %s.%s\", localField.Type, wireStruct.Name, wireField.Name)\n+\t\t\terrorf(\"wrong type (%s) for received field %s.%s\", localField.Type, wireStruct.Name, wireField.Name)\n \t\t}\n \t\top, indir := dec.decOpFor(wireField.Id, localField.Type, localField.Name, seen)\n \t\tengine.instr[fieldnum] = decInstr{*op, fieldnum, indir, uintptr(localField.Offset), ovfl}\n@@ -1163,7 +1159,7 @@ func (dec *Decoder) getDecEnginePtr(remoteId typeId, ut *userTypeInfo) (enginePt\n // emptyStruct is the type we compile into when ignoring a struct value.\n type emptyStruct struct{}\n \n-var emptyStructType = reflect.Typeof(emptyStruct{})\n+var emptyStructType = reflect.TypeOf(emptyStruct{})\n \n // getDecEnginePtr returns the engine for the specified type when the value is to be discarded.\n func (dec *Decoder) getIgnoreEnginePtr(wireId typeId) (enginePtr **decEngine, err os.Error) {\n@@ -1189,31 +1185,27 @@ func (dec *Decoder) getIgnoreEnginePtr(wireId typeId) (enginePtr **decEngine, er\n func (dec *Decoder) decodeValue(wireId typeId, val reflect.Value) {\n \tdefer catchError(&dec.err)\n \t// If the value is nil, it means we should just ignore this item.\n-\tif val == nil {\n+\tif !val.IsValid() {\n \t\tdec.decodeIgnoredValue(wireId)\n \t\treturn\n \t}\n \t// Dereference down to the underlying struct type.\n \tut := userType(val.Type())\n \tbase := ut.base\n-\tindir := ut.indir\n-\tif ut.isGobDecoder {\n-\t\tindir = int(ut.decIndir)\n-\t}\n \tvar enginePtr **decEngine\n \tenginePtr, dec.err = dec.getDecEnginePtr(wireId, ut)\n \tif dec.err != nil {\n \t\treturn\n \t}\n \tengine := *enginePtr\n-\tif st, ok := base.(*reflect.StructType); ok && !ut.isGobDecoder {\n+\tif st := base; st.Kind() == reflect.Struct && !ut.isGobDecoder {\n \t\tif engine.numInstr == 0 && st.NumField() > 0 && len(dec.wireType[wireId].StructT.Field) > 0 {\n \t\t\tname := base.Name()\n-\t\t\terrorf(\"gob: type mismatch: no fields matched compiling decoder for %s\", name)\n+\t\t\terrorf(\"type mismatch: no fields matched compiling decoder for %s\", name)\n \t\t}\n-\t\tdec.decodeStruct(engine, ut, uintptr(val.UnsafeAddr()), indir)\n+\t\tdec.decodeStruct(engine, ut, uintptr(unsafeAddr(val)), ut.indir)\n \t} else {\n-\t\tdec.decodeSingle(engine, ut, uintptr(val.UnsafeAddr()))\n+\t\tdec.decodeSingle(engine, ut, uintptr(unsafeAddr(val)))\n \t}\n }\n \n@@ -1234,7 +1226,7 @@ func (dec *Decoder) decodeIgnoredValue(wireId typeId) {\n \n func init() {\n \tvar iop, uop decOp\n-\tswitch reflect.Typeof(int(0)).Bits() {\n+\tswitch reflect.TypeOf(int(0)).Bits() {\n \tcase 32:\n \t\tiop = decInt32\n \t\tuop = decUint32\n@@ -1248,7 +1240,7 @@ func init() {\n \tdecOpTable[reflect.Uint] = uop\n \n \t// Finally uintptr\n-\tswitch reflect.Typeof(uintptr(0)).Bits() {\n+\tswitch reflect.TypeOf(uintptr(0)).Bits() {\n \tcase 32:\n \t\tuop = decUint32\n \tcase 64:\n@@ -1258,3 +1250,26 @@ func init() {\n \t}\n \tdecOpTable[reflect.Uintptr] = uop\n }\n+\n+// Gob assumes it can call UnsafeAddr on any Value\n+// in order to get a pointer it can copy data from.\n+// Values that have just been created and do not point\n+// into existing structs or slices cannot be addressed,\n+// so simulate it by returning a pointer to a copy.\n+// Each call allocates once.\n+func unsafeAddr(v reflect.Value) uintptr {\n+\tif v.CanAddr() {\n+\t\treturn v.UnsafeAddr()\n+\t}\n+\tx := reflect.New(v.Type()).Elem()\n+\tx.Set(v)\n+\treturn x.UnsafeAddr()\n+}\n+\n+// Gob depends on being able to take the address\n+// of zeroed Values it creates, so use this wrapper instead\n+// of the standard reflect.Zero.\n+// Each call allocates once.\n+func allocValue(t reflect.Type) reflect.Value {\n+\treturn reflect.New(t).Elem()\n+}"}, {"sha": "ea2f62ec5034d1176df7e4d3b0eb57355531ff83", "filename": "libgo/go/gob/decoder.go", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgob%2Fdecoder.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgob%2Fdecoder.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fdecoder.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -50,7 +50,7 @@ func (dec *Decoder) recvType(id typeId) {\n \n \t// Type:\n \twire := new(wireType)\n-\tdec.decodeValue(tWireType, reflect.NewValue(wire))\n+\tdec.decodeValue(tWireType, reflect.ValueOf(wire))\n \tif dec.err != nil {\n \t\treturn\n \t}\n@@ -159,9 +159,9 @@ func (dec *Decoder) decodeTypeSequence(isInterface bool) typeId {\n // data item received, and must be a pointer.\n func (dec *Decoder) Decode(e interface{}) os.Error {\n \tif e == nil {\n-\t\treturn dec.DecodeValue(nil)\n+\t\treturn dec.DecodeValue(reflect.Value{})\n \t}\n-\tvalue := reflect.NewValue(e)\n+\tvalue := reflect.ValueOf(e)\n \t// If e represents a value as opposed to a pointer, the answer won't\n \t// get back to the caller.  Make sure it's a pointer.\n \tif value.Type().Kind() != reflect.Ptr {\n@@ -171,12 +171,18 @@ func (dec *Decoder) Decode(e interface{}) os.Error {\n \treturn dec.DecodeValue(value)\n }\n \n-// DecodeValue reads the next value from the connection and stores\n-// it in the data represented by the reflection value.\n-// The value must be the correct type for the next\n-// data item received, or it may be nil, which means the\n-// value will be discarded.\n-func (dec *Decoder) DecodeValue(value reflect.Value) os.Error {\n+// DecodeValue reads the next value from the connection.\n+// If v is the zero reflect.Value (v.Kind() == Invalid), DecodeValue discards the value.\n+// Otherwise, it stores the value into v.  In that case, v must represent\n+// a non-nil pointer to data or be an assignable reflect.Value (v.CanSet())\n+func (dec *Decoder) DecodeValue(v reflect.Value) os.Error {\n+\tif v.IsValid() {\n+\t\tif v.Kind() == reflect.Ptr && !v.IsNil() {\n+\t\t\t// That's okay, we'll store through the pointer.\n+\t\t} else if !v.CanSet() {\n+\t\t\treturn os.ErrorString(\"gob: DecodeValue of unassignable value\")\n+\t\t}\n+\t}\n \t// Make sure we're single-threaded through here.\n \tdec.mutex.Lock()\n \tdefer dec.mutex.Unlock()\n@@ -185,7 +191,7 @@ func (dec *Decoder) DecodeValue(value reflect.Value) os.Error {\n \tdec.err = nil\n \tid := dec.decodeTypeSequence(false)\n \tif dec.err == nil {\n-\t\tdec.decodeValue(id, value)\n+\t\tdec.decodeValue(id, v)\n \t}\n \treturn dec.err\n }"}, {"sha": "850759bbda685244fa740cba0a83b71df3b9e65b", "filename": "libgo/go/gob/doc.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgob%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgob%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fdoc.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -3,7 +3,7 @@\n // license that can be found in the LICENSE file.\n \n /*\n-The gob package manages streams of gobs - binary values exchanged between an\n+Package gob manages streams of gobs - binary values exchanged between an\n Encoder (transmitter) and a Decoder (receiver).  A typical use is transporting\n arguments and results of remote procedure calls (RPCs) such as those provided by\n package \"rpc\".\n@@ -159,7 +159,7 @@ description, constructed from these types:\n \t\tElem typeId\n \t\tLen  int\n \t}\n-\ttype CommonType {\n+\ttype CommonType struct {\n \t\tName string // the name of the struct type\n \t\tId  int    // the id of the type, repeated so it's inside the type\n \t}"}, {"sha": "f9e691a2fa66eb19c8e06cf9ad7509579e49e58e", "filename": "libgo/go/gob/encode.go", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgob%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgob%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fencode.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -384,7 +384,7 @@ func (enc *Encoder) encodeArray(b *bytes.Buffer, p uintptr, op encOp, elemWid ui\n \t\tup := unsafe.Pointer(elemp)\n \t\tif elemIndir > 0 {\n \t\t\tif up = encIndirect(up, elemIndir); up == nil {\n-\t\t\t\terrorf(\"gob: encodeArray: nil element\")\n+\t\t\t\terrorf(\"encodeArray: nil element\")\n \t\t\t}\n \t\t\telemp = uintptr(up)\n \t\t}\n@@ -396,27 +396,27 @@ func (enc *Encoder) encodeArray(b *bytes.Buffer, p uintptr, op encOp, elemWid ui\n \n // encodeReflectValue is a helper for maps. It encodes the value v.\n func encodeReflectValue(state *encoderState, v reflect.Value, op encOp, indir int) {\n-\tfor i := 0; i < indir && v != nil; i++ {\n+\tfor i := 0; i < indir && v.IsValid(); i++ {\n \t\tv = reflect.Indirect(v)\n \t}\n-\tif v == nil {\n-\t\terrorf(\"gob: encodeReflectValue: nil element\")\n+\tif !v.IsValid() {\n+\t\terrorf(\"encodeReflectValue: nil element\")\n \t}\n-\top(nil, state, unsafe.Pointer(v.UnsafeAddr()))\n+\top(nil, state, unsafe.Pointer(unsafeAddr(v)))\n }\n \n // encodeMap encodes a map as unsigned count followed by key:value pairs.\n // Because map internals are not exposed, we must use reflection rather than\n // addresses.\n-func (enc *Encoder) encodeMap(b *bytes.Buffer, mv *reflect.MapValue, keyOp, elemOp encOp, keyIndir, elemIndir int) {\n+func (enc *Encoder) encodeMap(b *bytes.Buffer, mv reflect.Value, keyOp, elemOp encOp, keyIndir, elemIndir int) {\n \tstate := enc.newEncoderState(b)\n \tstate.fieldnum = -1\n \tstate.sendZero = true\n-\tkeys := mv.Keys()\n+\tkeys := mv.MapKeys()\n \tstate.encodeUint(uint64(len(keys)))\n \tfor _, key := range keys {\n \t\tencodeReflectValue(state, key, keyOp, keyIndir)\n-\t\tencodeReflectValue(state, mv.Elem(key), elemOp, elemIndir)\n+\t\tencodeReflectValue(state, mv.MapIndex(key), elemOp, elemIndir)\n \t}\n \tenc.freeEncoderState(state)\n }\n@@ -426,7 +426,7 @@ func (enc *Encoder) encodeMap(b *bytes.Buffer, mv *reflect.MapValue, keyOp, elem\n // by the type identifier (which might require defining that type right now), followed\n // by the concrete value.  A nil value gets sent as the empty string for the name,\n // followed by no value.\n-func (enc *Encoder) encodeInterface(b *bytes.Buffer, iv *reflect.InterfaceValue) {\n+func (enc *Encoder) encodeInterface(b *bytes.Buffer, iv reflect.Value) {\n \tstate := enc.newEncoderState(b)\n \tstate.fieldnum = -1\n \tstate.sendZero = true\n@@ -438,7 +438,7 @@ func (enc *Encoder) encodeInterface(b *bytes.Buffer, iv *reflect.InterfaceValue)\n \tut := userType(iv.Elem().Type())\n \tname, ok := concreteTypeToName[ut.base]\n \tif !ok {\n-\t\terrorf(\"gob: type not registered for interface: %s\", ut.base)\n+\t\terrorf(\"type not registered for interface: %s\", ut.base)\n \t}\n \t// Send the name.\n \tstate.encodeUint(uint64(len(name)))\n@@ -525,8 +525,8 @@ func (enc *Encoder) encOpFor(rt reflect.Type, inProgress map[reflect.Type]*encOp\n \tif op == nil {\n \t\tinProgress[rt] = &op\n \t\t// Special cases\n-\t\tswitch t := typ.(type) {\n-\t\tcase *reflect.SliceType:\n+\t\tswitch t := typ; t.Kind() {\n+\t\tcase reflect.Slice:\n \t\t\tif t.Elem().Kind() == reflect.Uint8 {\n \t\t\t\top = encUint8Array\n \t\t\t\tbreak\n@@ -541,29 +541,29 @@ func (enc *Encoder) encOpFor(rt reflect.Type, inProgress map[reflect.Type]*encOp\n \t\t\t\tstate.update(i)\n \t\t\t\tstate.enc.encodeArray(state.b, slice.Data, *elemOp, t.Elem().Size(), indir, int(slice.Len))\n \t\t\t}\n-\t\tcase *reflect.ArrayType:\n+\t\tcase reflect.Array:\n \t\t\t// True arrays have size in the type.\n \t\t\telemOp, indir := enc.encOpFor(t.Elem(), inProgress)\n \t\t\top = func(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \t\t\t\tstate.update(i)\n \t\t\t\tstate.enc.encodeArray(state.b, uintptr(p), *elemOp, t.Elem().Size(), indir, t.Len())\n \t\t\t}\n-\t\tcase *reflect.MapType:\n+\t\tcase reflect.Map:\n \t\t\tkeyOp, keyIndir := enc.encOpFor(t.Key(), inProgress)\n \t\t\telemOp, elemIndir := enc.encOpFor(t.Elem(), inProgress)\n \t\t\top = func(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \t\t\t\t// Maps cannot be accessed by moving addresses around the way\n \t\t\t\t// that slices etc. can.  We must recover a full reflection value for\n \t\t\t\t// the iteration.\n-\t\t\t\tv := reflect.NewValue(unsafe.Unreflect(t, unsafe.Pointer(p)))\n-\t\t\t\tmv := reflect.Indirect(v).(*reflect.MapValue)\n+\t\t\t\tv := reflect.ValueOf(unsafe.Unreflect(t, unsafe.Pointer(p)))\n+\t\t\t\tmv := reflect.Indirect(v)\n \t\t\t\tif !state.sendZero && mv.Len() == 0 {\n \t\t\t\t\treturn\n \t\t\t\t}\n \t\t\t\tstate.update(i)\n \t\t\t\tstate.enc.encodeMap(state.b, mv, *keyOp, *elemOp, keyIndir, elemIndir)\n \t\t\t}\n-\t\tcase *reflect.StructType:\n+\t\tcase reflect.Struct:\n \t\t\t// Generate a closure that calls out to the engine for the nested type.\n \t\t\tenc.getEncEngine(userType(typ))\n \t\t\tinfo := mustGetTypeInfo(typ)\n@@ -572,13 +572,13 @@ func (enc *Encoder) encOpFor(rt reflect.Type, inProgress map[reflect.Type]*encOp\n \t\t\t\t// indirect through info to delay evaluation for recursive structs\n \t\t\t\tstate.enc.encodeStruct(state.b, info.encoder, uintptr(p))\n \t\t\t}\n-\t\tcase *reflect.InterfaceType:\n+\t\tcase reflect.Interface:\n \t\t\top = func(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \t\t\t\t// Interfaces transmit the name and contents of the concrete\n \t\t\t\t// value they contain.\n-\t\t\t\tv := reflect.NewValue(unsafe.Unreflect(t, unsafe.Pointer(p)))\n-\t\t\t\tiv := reflect.Indirect(v).(*reflect.InterfaceValue)\n-\t\t\t\tif !state.sendZero && (iv == nil || iv.IsNil()) {\n+\t\t\t\tv := reflect.ValueOf(unsafe.Unreflect(t, unsafe.Pointer(p)))\n+\t\t\t\tiv := reflect.Indirect(v)\n+\t\t\t\tif !state.sendZero && (!iv.IsValid() || iv.IsNil()) {\n \t\t\t\t\treturn\n \t\t\t\t}\n \t\t\t\tstate.update(i)\n@@ -587,7 +587,7 @@ func (enc *Encoder) encOpFor(rt reflect.Type, inProgress map[reflect.Type]*encOp\n \t\t}\n \t}\n \tif op == nil {\n-\t\terrorf(\"gob enc: can't happen: encode type %s\", rt.String())\n+\t\terrorf(\"can't happen: encode type %s\", rt.String())\n \t}\n \treturn &op, indir\n }\n@@ -599,7 +599,7 @@ func methodIndex(rt reflect.Type, method string) int {\n \t\t\treturn i\n \t\t}\n \t}\n-\terrorf(\"gob: internal error: can't find method %s\", method)\n+\terrorf(\"internal error: can't find method %s\", method)\n \treturn 0\n }\n \n@@ -611,17 +611,17 @@ func (enc *Encoder) gobEncodeOpFor(ut *userTypeInfo) (*encOp, int) {\n \t\trt = reflect.PtrTo(rt)\n \t} else if ut.encIndir > 0 {\n \t\tfor i := int8(0); i < ut.encIndir; i++ {\n-\t\t\trt = rt.(*reflect.PtrType).Elem()\n+\t\t\trt = rt.Elem()\n \t\t}\n \t}\n \tvar op encOp\n \top = func(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \t\tvar v reflect.Value\n \t\tif ut.encIndir == -1 {\n \t\t\t// Need to climb up one level to turn value into pointer.\n-\t\t\tv = reflect.NewValue(unsafe.Unreflect(rt, unsafe.Pointer(&p)))\n+\t\t\tv = reflect.ValueOf(unsafe.Unreflect(rt, unsafe.Pointer(&p)))\n \t\t} else {\n-\t\t\tv = reflect.NewValue(unsafe.Unreflect(rt, p))\n+\t\t\tv = reflect.ValueOf(unsafe.Unreflect(rt, p))\n \t\t}\n \t\tstate.update(i)\n \t\tstate.enc.encodeGobEncoder(state.b, v, methodIndex(rt, gobEncodeMethodName))\n@@ -631,14 +631,15 @@ func (enc *Encoder) gobEncodeOpFor(ut *userTypeInfo) (*encOp, int) {\n \n // compileEnc returns the engine to compile the type.\n func (enc *Encoder) compileEnc(ut *userTypeInfo) *encEngine {\n-\tsrt, isStruct := ut.base.(*reflect.StructType)\n+\tsrt := ut.base\n \tengine := new(encEngine)\n \tseen := make(map[reflect.Type]*encOp)\n \trt := ut.base\n \tif ut.isGobEncoder {\n \t\trt = ut.user\n \t}\n-\tif !ut.isGobEncoder && isStruct {\n+\tif !ut.isGobEncoder &&\n+\t\tsrt.Kind() == reflect.Struct {\n \t\tfor fieldNum, wireFieldNum := 0, 0; fieldNum < srt.NumField(); fieldNum++ {\n \t\t\tf := srt.Field(fieldNum)\n \t\t\tif !isExported(f.Name) {\n@@ -649,7 +650,7 @@ func (enc *Encoder) compileEnc(ut *userTypeInfo) *encEngine {\n \t\t\twireFieldNum++\n \t\t}\n \t\tif srt.NumField() > 0 && len(engine.instr) == 0 {\n-\t\t\terrorf(\"gob: type %s has no exported fields\", rt)\n+\t\t\terrorf(\"type %s has no exported fields\", rt)\n \t\t}\n \t\tengine.instr = append(engine.instr, encInstr{encStructTerminator, 0, 0, 0})\n \t} else {\n@@ -694,8 +695,8 @@ func (enc *Encoder) encode(b *bytes.Buffer, value reflect.Value, ut *userTypeInf\n \t\tvalue = reflect.Indirect(value)\n \t}\n \tif !ut.isGobEncoder && value.Type().Kind() == reflect.Struct {\n-\t\tenc.encodeStruct(b, engine, value.UnsafeAddr())\n+\t\tenc.encodeStruct(b, engine, unsafeAddr(value))\n \t} else {\n-\t\tenc.encodeSingle(b, engine, value.UnsafeAddr())\n+\t\tenc.encodeSingle(b, engine, unsafeAddr(value))\n \t}\n }"}, {"sha": "65ee5bf67c8a05b05ebf2d799dc1dfd607f40645", "filename": "libgo/go/gob/encoder.go", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgob%2Fencoder.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgob%2Fencoder.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fencoder.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -97,7 +97,7 @@ func (enc *Encoder) sendActualType(w io.Writer, state *encoderState, ut *userTyp\n \t// Id:\n \tstate.encodeInt(-int64(info.id))\n \t// Type:\n-\tenc.encode(state.b, reflect.NewValue(info.wire), wireTypeUserInfo)\n+\tenc.encode(state.b, reflect.ValueOf(info.wire), wireTypeUserInfo)\n \tenc.writeMessage(w, state.b)\n \tif enc.err != nil {\n \t\treturn\n@@ -109,12 +109,15 @@ func (enc *Encoder) sendActualType(w io.Writer, state *encoderState, ut *userTyp\n \t\tenc.sent[ut.user] = info.id\n \t}\n \t// Now send the inner types\n-\tswitch st := actual.(type) {\n-\tcase *reflect.StructType:\n+\tswitch st := actual; st.Kind() {\n+\tcase reflect.Struct:\n \t\tfor i := 0; i < st.NumField(); i++ {\n \t\t\tenc.sendType(w, state, st.Field(i).Type)\n \t\t}\n-\tcase reflect.ArrayOrSliceType:\n+\tcase reflect.Array, reflect.Slice:\n+\t\tenc.sendType(w, state, st.Elem())\n+\tcase reflect.Map:\n+\t\tenc.sendType(w, state, st.Key())\n \t\tenc.sendType(w, state, st.Elem())\n \t}\n \treturn true\n@@ -130,27 +133,27 @@ func (enc *Encoder) sendType(w io.Writer, state *encoderState, origt reflect.Typ\n \t}\n \n \t// It's a concrete value, so drill down to the base type.\n-\tswitch rt := ut.base.(type) {\n+\tswitch rt := ut.base; rt.Kind() {\n \tdefault:\n \t\t// Basic types and interfaces do not need to be described.\n \t\treturn\n-\tcase *reflect.SliceType:\n+\tcase reflect.Slice:\n \t\t// If it's []uint8, don't send; it's considered basic.\n \t\tif rt.Elem().Kind() == reflect.Uint8 {\n \t\t\treturn\n \t\t}\n \t\t// Otherwise we do send.\n \t\tbreak\n-\tcase *reflect.ArrayType:\n+\tcase reflect.Array:\n \t\t// arrays must be sent so we know their lengths and element types.\n \t\tbreak\n-\tcase *reflect.MapType:\n+\tcase reflect.Map:\n \t\t// maps must be sent so we know their lengths and key/value types.\n \t\tbreak\n-\tcase *reflect.StructType:\n+\tcase reflect.Struct:\n \t\t// structs must be sent so we know their fields.\n \t\tbreak\n-\tcase *reflect.ChanType, *reflect.FuncType:\n+\tcase reflect.Chan, reflect.Func:\n \t\t// Probably a bad field in a struct.\n \t\tenc.badType(rt)\n \t\treturn\n@@ -162,7 +165,7 @@ func (enc *Encoder) sendType(w io.Writer, state *encoderState, origt reflect.Typ\n // Encode transmits the data item represented by the empty interface value,\n // guaranteeing that all necessary type information has been transmitted first.\n func (enc *Encoder) Encode(e interface{}) os.Error {\n-\treturn enc.EncodeValue(reflect.NewValue(e))\n+\treturn enc.EncodeValue(reflect.ValueOf(e))\n }\n \n // sendTypeDescriptor makes sure the remote side knows about this type."}, {"sha": "792afbd77528769acbe06ddd116324b68cd4a873", "filename": "libgo/go/gob/encoder_test.go", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgob%2Fencoder_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgob%2Fencoder_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fencoder_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -170,7 +170,7 @@ func TestTypeToPtrType(t *testing.T) {\n \t\tA int\n \t}\n \tt0 := Type0{7}\n-\tt0p := (*Type0)(nil)\n+\tt0p := new(Type0)\n \tif err := encAndDec(t0, t0p); err != nil {\n \t\tt.Error(err)\n \t}\n@@ -339,7 +339,7 @@ func TestSingletons(t *testing.T) {\n \t\t\tcontinue\n \t\t}\n \t\t// Get rid of the pointer in the rhs\n-\t\tval := reflect.NewValue(test.out).(*reflect.PtrValue).Elem().Interface()\n+\t\tval := reflect.ValueOf(test.out).Elem().Interface()\n \t\tif !reflect.DeepEqual(test.in, val) {\n \t\t\tt.Errorf(\"decoding singleton: expected %v got %v\", test.in, val)\n \t\t}\n@@ -514,3 +514,38 @@ func TestNestedInterfaces(t *testing.T) {\n \t\tt.Fatalf(\"final value %d; expected %d\", inner.A, 7)\n \t}\n }\n+\n+// The bugs keep coming. We forgot to send map subtypes before the map.\n+\n+type Bug1Elem struct {\n+\tName string\n+\tId   int\n+}\n+\n+type Bug1StructMap map[string]Bug1Elem\n+\n+func bug1EncDec(in Bug1StructMap, out *Bug1StructMap) os.Error {\n+\treturn nil\n+}\n+\n+func TestMapBug1(t *testing.T) {\n+\tin := make(Bug1StructMap)\n+\tin[\"val1\"] = Bug1Elem{\"elem1\", 1}\n+\tin[\"val2\"] = Bug1Elem{\"elem2\", 2}\n+\n+\tb := new(bytes.Buffer)\n+\tenc := NewEncoder(b)\n+\terr := enc.Encode(in)\n+\tif err != nil {\n+\t\tt.Fatal(\"encode:\", err)\n+\t}\n+\tdec := NewDecoder(b)\n+\tout := make(Bug1StructMap)\n+\terr = dec.Decode(&out)\n+\tif err != nil {\n+\t\tt.Fatal(\"decode:\", err)\n+\t}\n+\tif !reflect.DeepEqual(in, out) {\n+\t\tt.Errorf(\"mismatch: %v %v\", in, out)\n+\t}\n+}"}, {"sha": "bfd38fc16d392b0b605a228db7949a310c47418e", "filename": "libgo/go/gob/error.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgob%2Ferror.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgob%2Ferror.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Ferror.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -22,8 +22,9 @@ type gobError struct {\n }\n \n // errorf is like error but takes Printf-style arguments to construct an os.Error.\n+// It always prefixes the message with \"gob: \".\n func errorf(format string, args ...interface{}) {\n-\terror(fmt.Errorf(format, args...))\n+\terror(fmt.Errorf(\"gob: \"+format, args...))\n }\n \n // error wraps the argument error and uses it as the argument to panic."}, {"sha": "e94534f4c333ba7250e9d36ef1ad1b216631a2d7", "filename": "libgo/go/gob/gobencdec_test.go", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgob%2Fgobencdec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgob%2Fgobencdec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fgobencdec_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -24,6 +24,10 @@ type StringStruct struct {\n \ts string // not an exported field\n }\n \n+type ArrayStruct struct {\n+\ta [8192]byte // not an exported field\n+}\n+\n type Gobber int\n \n type ValueGobber string // encodes with a value, decodes with a pointer.\n@@ -74,6 +78,18 @@ func (g *StringStruct) GobDecode(data []byte) os.Error {\n \treturn nil\n }\n \n+func (a *ArrayStruct) GobEncode() ([]byte, os.Error) {\n+\treturn a.a[:], nil\n+}\n+\n+func (a *ArrayStruct) GobDecode(data []byte) os.Error {\n+\tif len(data) != len(a.a) {\n+\t\treturn os.ErrorString(\"wrong length in array decode\")\n+\t}\n+\tcopy(a.a[:], data)\n+\treturn nil\n+}\n+\n func (g *Gobber) GobEncode() ([]byte, os.Error) {\n \treturn []byte(fmt.Sprintf(\"VALUE=%d\", *g)), nil\n }\n@@ -138,6 +154,16 @@ type GobTestIndirectEncDec struct {\n \tG ***StringStruct // indirections to the receiver.\n }\n \n+type GobTestArrayEncDec struct {\n+\tX int         // guarantee we have  something in common with GobTest*\n+\tA ArrayStruct // not a pointer.\n+}\n+\n+type GobTestIndirectArrayEncDec struct {\n+\tX int            // guarantee we have  something in common with GobTest*\n+\tA ***ArrayStruct // indirections to a large receiver.\n+}\n+\n func TestGobEncoderField(t *testing.T) {\n \tb := new(bytes.Buffer)\n \t// First a field that's a structure.\n@@ -216,6 +242,64 @@ func TestGobEncoderIndirectField(t *testing.T) {\n \t}\n }\n \n+// Test with a large field with methods.\n+func TestGobEncoderArrayField(t *testing.T) {\n+\tb := new(bytes.Buffer)\n+\tenc := NewEncoder(b)\n+\tvar a GobTestArrayEncDec\n+\ta.X = 17\n+\tfor i := range a.A.a {\n+\t\ta.A.a[i] = byte(i)\n+\t}\n+\terr := enc.Encode(a)\n+\tif err != nil {\n+\t\tt.Fatal(\"encode error:\", err)\n+\t}\n+\tdec := NewDecoder(b)\n+\tx := new(GobTestArrayEncDec)\n+\terr = dec.Decode(x)\n+\tif err != nil {\n+\t\tt.Fatal(\"decode error:\", err)\n+\t}\n+\tfor i, v := range x.A.a {\n+\t\tif v != byte(i) {\n+\t\t\tt.Errorf(\"expected %x got %x\", byte(i), v)\n+\t\t\tbreak\n+\t\t}\n+\t}\n+}\n+\n+// Test an indirection to a large field with methods.\n+func TestGobEncoderIndirectArrayField(t *testing.T) {\n+\tb := new(bytes.Buffer)\n+\tenc := NewEncoder(b)\n+\tvar a GobTestIndirectArrayEncDec\n+\ta.X = 17\n+\tvar array ArrayStruct\n+\tap := &array\n+\tapp := &ap\n+\ta.A = &app\n+\tfor i := range array.a {\n+\t\tarray.a[i] = byte(i)\n+\t}\n+\terr := enc.Encode(a)\n+\tif err != nil {\n+\t\tt.Fatal(\"encode error:\", err)\n+\t}\n+\tdec := NewDecoder(b)\n+\tx := new(GobTestIndirectArrayEncDec)\n+\terr = dec.Decode(x)\n+\tif err != nil {\n+\t\tt.Fatal(\"decode error:\", err)\n+\t}\n+\tfor i, v := range (***x.A).a {\n+\t\tif v != byte(i) {\n+\t\t\tt.Errorf(\"expected %x got %x\", byte(i), v)\n+\t\t\tbreak\n+\t\t}\n+\t}\n+}\n+\n // As long as the fields have the same name and implement the\n // interface, we can cross-connect them.  Not sure it's useful\n // and may even be bad but it works and it's hard to prevent"}, {"sha": "c5b8fb5d9d13fdd53cb5c6987c1fa7bc8119c50b", "filename": "libgo/go/gob/type.go", "status": "modified", "additions": 45, "deletions": 61, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgob%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgob%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Ftype.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -60,8 +60,8 @@ func validUserType(rt reflect.Type) (ut *userTypeInfo, err os.Error) {\n \t// half speed. If they meet up, there's a cycle.\n \tslowpoke := ut.base // walks half as fast as ut.base\n \tfor {\n-\t\tpt, ok := ut.base.(*reflect.PtrType)\n-\t\tif !ok {\n+\t\tpt := ut.base\n+\t\tif pt.Kind() != reflect.Ptr {\n \t\t\tbreak\n \t\t}\n \t\tut.base = pt.Elem()\n@@ -70,12 +70,12 @@ func validUserType(rt reflect.Type) (ut *userTypeInfo, err os.Error) {\n \t\t\treturn nil, os.ErrorString(\"can't represent recursive pointer type \" + ut.base.String())\n \t\t}\n \t\tif ut.indir%2 == 0 {\n-\t\t\tslowpoke = slowpoke.(*reflect.PtrType).Elem()\n+\t\t\tslowpoke = slowpoke.Elem()\n \t\t}\n \t\tut.indir++\n \t}\n-\tut.isGobEncoder, ut.encIndir = implementsInterface(ut.user, gobEncoderCheck)\n-\tut.isGobDecoder, ut.decIndir = implementsInterface(ut.user, gobDecoderCheck)\n+\tut.isGobEncoder, ut.encIndir = implementsInterface(ut.user, gobEncoderInterfaceType)\n+\tut.isGobDecoder, ut.decIndir = implementsInterface(ut.user, gobDecoderInterfaceType)\n \tuserTypeCache[rt] = ut\n \treturn\n }\n@@ -85,43 +85,27 @@ const (\n \tgobDecodeMethodName = \"GobDecode\"\n )\n \n-// implements returns whether the type implements the interface, as encoded\n-// in the check function.\n-func implements(typ reflect.Type, check func(typ reflect.Type) bool) bool {\n-\tif typ.NumMethod() == 0 { // avoid allocations etc. unless there's some chance\n-\t\treturn false\n-\t}\n-\treturn check(typ)\n-}\n-\n-// gobEncoderCheck makes the type assertion a boolean function.\n-func gobEncoderCheck(typ reflect.Type) bool {\n-\t_, ok := reflect.MakeZero(typ).Interface().(GobEncoder)\n-\treturn ok\n-}\n-\n-// gobDecoderCheck makes the type assertion a boolean function.\n-func gobDecoderCheck(typ reflect.Type) bool {\n-\t_, ok := reflect.MakeZero(typ).Interface().(GobDecoder)\n-\treturn ok\n-}\n+var (\n+\tgobEncoderInterfaceType = reflect.TypeOf(new(GobEncoder)).Elem()\n+\tgobDecoderInterfaceType = reflect.TypeOf(new(GobDecoder)).Elem()\n+)\n \n // implementsInterface reports whether the type implements the\n-// interface. (The actual check is done through the provided function.)\n+// gobEncoder/gobDecoder interface.\n // It also returns the number of indirections required to get to the\n // implementation.\n-func implementsInterface(typ reflect.Type, check func(typ reflect.Type) bool) (success bool, indir int8) {\n+func implementsInterface(typ, gobEncDecType reflect.Type) (success bool, indir int8) {\n \tif typ == nil {\n \t\treturn\n \t}\n \trt := typ\n \t// The type might be a pointer and we need to keep\n \t// dereferencing to the base type until we find an implementation.\n \tfor {\n-\t\tif implements(rt, check) {\n+\t\tif rt.Implements(gobEncDecType) {\n \t\t\treturn true, indir\n \t\t}\n-\t\tif p, ok := rt.(*reflect.PtrType); ok {\n+\t\tif p := rt; p.Kind() == reflect.Ptr {\n \t\t\tindir++\n \t\t\tif indir > 100 { // insane number of indirections\n \t\t\t\treturn false, 0\n@@ -132,9 +116,9 @@ func implementsInterface(typ reflect.Type, check func(typ reflect.Type) bool) (s\n \t\tbreak\n \t}\n \t// No luck yet, but if this is a base type (non-pointer), the pointer might satisfy.\n-\tif _, ok := typ.(*reflect.PtrType); !ok {\n+\tif typ.Kind() != reflect.Ptr {\n \t\t// Not a pointer, but does the pointer work?\n-\t\tif implements(reflect.PtrTo(typ), check) {\n+\t\tif reflect.PtrTo(typ).Implements(gobEncDecType) {\n \t\t\treturn true, -1\n \t\t}\n \t}\n@@ -243,18 +227,18 @@ var (\n )\n \n // Predefined because it's needed by the Decoder\n-var tWireType = mustGetTypeInfo(reflect.Typeof(wireType{})).id\n+var tWireType = mustGetTypeInfo(reflect.TypeOf(wireType{})).id\n var wireTypeUserInfo *userTypeInfo // userTypeInfo of (*wireType)\n \n func init() {\n \t// Some magic numbers to make sure there are no surprises.\n \tcheckId(16, tWireType)\n-\tcheckId(17, mustGetTypeInfo(reflect.Typeof(arrayType{})).id)\n-\tcheckId(18, mustGetTypeInfo(reflect.Typeof(CommonType{})).id)\n-\tcheckId(19, mustGetTypeInfo(reflect.Typeof(sliceType{})).id)\n-\tcheckId(20, mustGetTypeInfo(reflect.Typeof(structType{})).id)\n-\tcheckId(21, mustGetTypeInfo(reflect.Typeof(fieldType{})).id)\n-\tcheckId(23, mustGetTypeInfo(reflect.Typeof(mapType{})).id)\n+\tcheckId(17, mustGetTypeInfo(reflect.TypeOf(arrayType{})).id)\n+\tcheckId(18, mustGetTypeInfo(reflect.TypeOf(CommonType{})).id)\n+\tcheckId(19, mustGetTypeInfo(reflect.TypeOf(sliceType{})).id)\n+\tcheckId(20, mustGetTypeInfo(reflect.TypeOf(structType{})).id)\n+\tcheckId(21, mustGetTypeInfo(reflect.TypeOf(fieldType{})).id)\n+\tcheckId(23, mustGetTypeInfo(reflect.TypeOf(mapType{})).id)\n \n \tbuiltinIdToType = make(map[typeId]gobType)\n \tfor k, v := range idToType {\n@@ -268,7 +252,7 @@ func init() {\n \t}\n \tnextId = firstUserId\n \tregisterBasics()\n-\twireTypeUserInfo = userType(reflect.Typeof((*wireType)(nil)))\n+\twireTypeUserInfo = userType(reflect.TypeOf((*wireType)(nil)))\n }\n \n // Array type\n@@ -431,30 +415,30 @@ func newTypeObject(name string, ut *userTypeInfo, rt reflect.Type) (gobType, os.\n \t}()\n \t// Install the top-level type before the subtypes (e.g. struct before\n \t// fields) so recursive types can be constructed safely.\n-\tswitch t := rt.(type) {\n+\tswitch t := rt; t.Kind() {\n \t// All basic types are easy: they are predefined.\n-\tcase *reflect.BoolType:\n+\tcase reflect.Bool:\n \t\treturn tBool.gobType(), nil\n \n-\tcase *reflect.IntType:\n+\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n \t\treturn tInt.gobType(), nil\n \n-\tcase *reflect.UintType:\n+\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n \t\treturn tUint.gobType(), nil\n \n-\tcase *reflect.FloatType:\n+\tcase reflect.Float32, reflect.Float64:\n \t\treturn tFloat.gobType(), nil\n \n-\tcase *reflect.ComplexType:\n+\tcase reflect.Complex64, reflect.Complex128:\n \t\treturn tComplex.gobType(), nil\n \n-\tcase *reflect.StringType:\n+\tcase reflect.String:\n \t\treturn tString.gobType(), nil\n \n-\tcase *reflect.InterfaceType:\n+\tcase reflect.Interface:\n \t\treturn tInterface.gobType(), nil\n \n-\tcase *reflect.ArrayType:\n+\tcase reflect.Array:\n \t\tat := newArrayType(name)\n \t\ttypes[rt] = at\n \t\ttype0, err = getBaseType(\"\", t.Elem())\n@@ -472,7 +456,7 @@ func newTypeObject(name string, ut *userTypeInfo, rt reflect.Type) (gobType, os.\n \t\tat.init(type0, t.Len())\n \t\treturn at, nil\n \n-\tcase *reflect.MapType:\n+\tcase reflect.Map:\n \t\tmt := newMapType(name)\n \t\ttypes[rt] = mt\n \t\ttype0, err = getBaseType(\"\", t.Key())\n@@ -486,7 +470,7 @@ func newTypeObject(name string, ut *userTypeInfo, rt reflect.Type) (gobType, os.\n \t\tmt.init(type0, type1)\n \t\treturn mt, nil\n \n-\tcase *reflect.SliceType:\n+\tcase reflect.Slice:\n \t\t// []byte == []uint8 is a special case\n \t\tif t.Elem().Kind() == reflect.Uint8 {\n \t\t\treturn tBytes.gobType(), nil\n@@ -500,7 +484,7 @@ func newTypeObject(name string, ut *userTypeInfo, rt reflect.Type) (gobType, os.\n \t\tst.init(type0)\n \t\treturn st, nil\n \n-\tcase *reflect.StructType:\n+\tcase reflect.Struct:\n \t\tst := newStructType(name)\n \t\ttypes[rt] = st\n \t\tidToType[st.id()] = st\n@@ -569,7 +553,7 @@ func checkId(want, got typeId) {\n // used for building the basic types; called only from init().  the incoming\n // interface always refers to a pointer.\n func bootstrapType(name string, e interface{}, expect typeId) typeId {\n-\trt := reflect.Typeof(e).(*reflect.PtrType).Elem()\n+\trt := reflect.TypeOf(e).Elem()\n \t_, present := types[rt]\n \tif present {\n \t\tpanic(\"bootstrap type already present: \" + name + \", \" + rt.String())\n@@ -658,17 +642,17 @@ func getTypeInfo(ut *userTypeInfo) (*typeInfo, os.Error) {\n \t}\n \n \tt := info.id.gobType()\n-\tswitch typ := rt.(type) {\n-\tcase *reflect.ArrayType:\n+\tswitch typ := rt; typ.Kind() {\n+\tcase reflect.Array:\n \t\tinfo.wire = &wireType{ArrayT: t.(*arrayType)}\n-\tcase *reflect.MapType:\n+\tcase reflect.Map:\n \t\tinfo.wire = &wireType{MapT: t.(*mapType)}\n-\tcase *reflect.SliceType:\n+\tcase reflect.Slice:\n \t\t// []byte == []uint8 is a special case handled separately\n \t\tif typ.Elem().Kind() != reflect.Uint8 {\n \t\t\tinfo.wire = &wireType{SliceT: t.(*sliceType)}\n \t\t}\n-\tcase *reflect.StructType:\n+\tcase reflect.Struct:\n \t\tinfo.wire = &wireType{StructT: t.(*structType)}\n \t}\n \ttypeInfoMap[rt] = info\n@@ -723,7 +707,7 @@ func RegisterName(name string, value interface{}) {\n \t\t// reserved for nil\n \t\tpanic(\"attempt to register empty name\")\n \t}\n-\tbase := userType(reflect.Typeof(value)).base\n+\tbase := userType(reflect.TypeOf(value)).base\n \t// Check for incompatible duplicates.\n \tif t, ok := nameToConcreteType[name]; ok && t != base {\n \t\tpanic(\"gob: registering duplicate types for \" + name)\n@@ -732,7 +716,7 @@ func RegisterName(name string, value interface{}) {\n \t\tpanic(\"gob: registering duplicate names for \" + base.String())\n \t}\n \t// Store the name and type provided by the user....\n-\tnameToConcreteType[name] = reflect.Typeof(value)\n+\tnameToConcreteType[name] = reflect.TypeOf(value)\n \t// but the flattened type in the type table, since that's what decode needs.\n \tconcreteTypeToName[base] = name\n }\n@@ -745,14 +729,14 @@ func RegisterName(name string, value interface{}) {\n // between types and names is not a bijection.\n func Register(value interface{}) {\n \t// Default to printed representation for unnamed types\n-\trt := reflect.Typeof(value)\n+\trt := reflect.TypeOf(value)\n \tname := rt.String()\n \n \t// But for named types (or pointers to them), qualify with import path.\n \t// Dereference one pointer looking for a named type.\n \tstar := \"\"\n \tif rt.Name() == \"\" {\n-\t\tif pt, ok := rt.(*reflect.PtrType); ok {\n+\t\tif pt := rt; pt.Kind() == reflect.Ptr {\n \t\t\tstar = \"*\"\n \t\t\trt = pt\n \t\t}"}, {"sha": "411ffb7971b1c18ae3a9f1766a2af67b5bdbcd8c", "filename": "libgo/go/gob/type_test.go", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgob%2Ftype_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fgob%2Ftype_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Ftype_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -47,34 +47,34 @@ func TestBasic(t *testing.T) {\n \n // Reregister some basic types to check registration is idempotent.\n func TestReregistration(t *testing.T) {\n-\tnewtyp := getTypeUnlocked(\"int\", reflect.Typeof(int(0)))\n+\tnewtyp := getTypeUnlocked(\"int\", reflect.TypeOf(int(0)))\n \tif newtyp != tInt.gobType() {\n \t\tt.Errorf(\"reregistration of %s got new type\", newtyp.string())\n \t}\n-\tnewtyp = getTypeUnlocked(\"uint\", reflect.Typeof(uint(0)))\n+\tnewtyp = getTypeUnlocked(\"uint\", reflect.TypeOf(uint(0)))\n \tif newtyp != tUint.gobType() {\n \t\tt.Errorf(\"reregistration of %s got new type\", newtyp.string())\n \t}\n-\tnewtyp = getTypeUnlocked(\"string\", reflect.Typeof(\"hello\"))\n+\tnewtyp = getTypeUnlocked(\"string\", reflect.TypeOf(\"hello\"))\n \tif newtyp != tString.gobType() {\n \t\tt.Errorf(\"reregistration of %s got new type\", newtyp.string())\n \t}\n }\n \n func TestArrayType(t *testing.T) {\n \tvar a3 [3]int\n-\ta3int := getTypeUnlocked(\"foo\", reflect.Typeof(a3))\n-\tnewa3int := getTypeUnlocked(\"bar\", reflect.Typeof(a3))\n+\ta3int := getTypeUnlocked(\"foo\", reflect.TypeOf(a3))\n+\tnewa3int := getTypeUnlocked(\"bar\", reflect.TypeOf(a3))\n \tif a3int != newa3int {\n \t\tt.Errorf(\"second registration of [3]int creates new type\")\n \t}\n \tvar a4 [4]int\n-\ta4int := getTypeUnlocked(\"goo\", reflect.Typeof(a4))\n+\ta4int := getTypeUnlocked(\"goo\", reflect.TypeOf(a4))\n \tif a3int == a4int {\n \t\tt.Errorf(\"registration of [3]int creates same type as [4]int\")\n \t}\n \tvar b3 [3]bool\n-\ta3bool := getTypeUnlocked(\"\", reflect.Typeof(b3))\n+\ta3bool := getTypeUnlocked(\"\", reflect.TypeOf(b3))\n \tif a3int == a3bool {\n \t\tt.Errorf(\"registration of [3]bool creates same type as [3]int\")\n \t}\n@@ -87,14 +87,14 @@ func TestArrayType(t *testing.T) {\n \n func TestSliceType(t *testing.T) {\n \tvar s []int\n-\tsint := getTypeUnlocked(\"slice\", reflect.Typeof(s))\n+\tsint := getTypeUnlocked(\"slice\", reflect.TypeOf(s))\n \tvar news []int\n-\tnewsint := getTypeUnlocked(\"slice1\", reflect.Typeof(news))\n+\tnewsint := getTypeUnlocked(\"slice1\", reflect.TypeOf(news))\n \tif sint != newsint {\n \t\tt.Errorf(\"second registration of []int creates new type\")\n \t}\n \tvar b []bool\n-\tsbool := getTypeUnlocked(\"\", reflect.Typeof(b))\n+\tsbool := getTypeUnlocked(\"\", reflect.TypeOf(b))\n \tif sbool == sint {\n \t\tt.Errorf(\"registration of []bool creates same type as []int\")\n \t}\n@@ -107,14 +107,14 @@ func TestSliceType(t *testing.T) {\n \n func TestMapType(t *testing.T) {\n \tvar m map[string]int\n-\tmapStringInt := getTypeUnlocked(\"map\", reflect.Typeof(m))\n+\tmapStringInt := getTypeUnlocked(\"map\", reflect.TypeOf(m))\n \tvar newm map[string]int\n-\tnewMapStringInt := getTypeUnlocked(\"map1\", reflect.Typeof(newm))\n+\tnewMapStringInt := getTypeUnlocked(\"map1\", reflect.TypeOf(newm))\n \tif mapStringInt != newMapStringInt {\n \t\tt.Errorf(\"second registration of map[string]int creates new type\")\n \t}\n \tvar b map[string]bool\n-\tmapStringBool := getTypeUnlocked(\"\", reflect.Typeof(b))\n+\tmapStringBool := getTypeUnlocked(\"\", reflect.TypeOf(b))\n \tif mapStringBool == mapStringInt {\n \t\tt.Errorf(\"registration of map[string]bool creates same type as map[string]int\")\n \t}\n@@ -143,7 +143,7 @@ type Foo struct {\n }\n \n func TestStructType(t *testing.T) {\n-\tsstruct := getTypeUnlocked(\"Foo\", reflect.Typeof(Foo{}))\n+\tsstruct := getTypeUnlocked(\"Foo\", reflect.TypeOf(Foo{}))\n \tstr := sstruct.string()\n \t// If we can print it correctly, we built it correctly.\n \texpected := \"Foo = struct { A int; B int; C string; D bytes; E float; F float; G Bar = struct { X string; }; H Bar; I Foo; }\""}, {"sha": "84943d9ae4c2ebf0941a2c204bb2ad2e59168667", "filename": "libgo/go/hash/adler32/adler32.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhash%2Fadler32%2Fadler32.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhash%2Fadler32%2Fadler32.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Fadler32%2Fadler32.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This package implements the Adler-32 checksum.\n+// Package adler32 implements the Adler-32 checksum.\n // Defined in RFC 1950:\n //\tAdler-32 is composed of two sums accumulated per byte: s1 is\n //\tthe sum of all bytes, s2 is the sum of all s1 values. Both sums\n@@ -43,8 +43,8 @@ func (d *digest) Size() int { return Size }\n \n // Add p to the running checksum a, b.\n func update(a, b uint32, p []byte) (aa, bb uint32) {\n-\tfor i := 0; i < len(p); i++ {\n-\t\ta += uint32(p[i])\n+\tfor _, pi := range p {\n+\t\ta += uint32(pi)\n \t\tb += a\n \t\t// invariant: a <= b\n \t\tif b > (0xffffffff-255)/2 {"}, {"sha": "01f931c6859850b309a2b2b5db90326e29ddd55f", "filename": "libgo/go/hash/adler32/adler32_test.go", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhash%2Fadler32%2Fadler32_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhash%2Fadler32%2Fadler32_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Fadler32%2Fadler32_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -5,6 +5,7 @@\n package adler32\n \n import (\n+\t\"bytes\"\n \t\"io\"\n \t\"testing\"\n )\n@@ -61,3 +62,16 @@ func TestGolden(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func BenchmarkGolden(b *testing.B) {\n+\tb.StopTimer()\n+\tc := New()\n+\tvar buf bytes.Buffer\n+\tfor _, g := range golden {\n+\t\tbuf.Write([]byte(g.in))\n+\t}\n+\tb.StartTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tc.Write(buf.Bytes())\n+\t}\n+}"}, {"sha": "88a449971684b35139c3a59a289a92ef7ce49f71", "filename": "libgo/go/hash/crc32/crc32.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhash%2Fcrc32%2Fcrc32.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhash%2Fcrc32%2Fcrc32.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Fcrc32%2Fcrc32.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,8 +2,9 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This package implements the 32-bit cyclic redundancy check, or CRC-32, checksum.\n-// See http://en.wikipedia.org/wiki/Cyclic_redundancy_check for information.\n+// Package crc32 implements the 32-bit cyclic redundancy check, or CRC-32,\n+// checksum. See http://en.wikipedia.org/wiki/Cyclic_redundancy_check for\n+// information.\n package crc32\n \n import ("}, {"sha": "ae37e781cd0ad8972b334ab4d8b8ab79d79f71de", "filename": "libgo/go/hash/crc64/crc64.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhash%2Fcrc64%2Fcrc64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhash%2Fcrc64%2Fcrc64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Fcrc64%2Fcrc64.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,8 +2,9 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This package implements the 64-bit cyclic redundancy check, or CRC-64, checksum.\n-// See http://en.wikipedia.org/wiki/Cyclic_redundancy_check for information.\n+// Package crc64 implements the 64-bit cyclic redundancy check, or CRC-64,\n+// checksum. See http://en.wikipedia.org/wiki/Cyclic_redundancy_check for\n+// information.\n package crc64\n \n import ("}, {"sha": "9a1c6a0f2db97989ab3e891e76876f95f545053d", "filename": "libgo/go/hash/fnv/fnv.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhash%2Ffnv%2Ffnv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhash%2Ffnv%2Ffnv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Ffnv%2Ffnv.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,9 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// The fnv package implements FNV-1 and FNV-1a,\n-// non-cryptographic hash functions created by\n-// Glenn Fowler, Landon Curt Noll, and Phong Vo.\n+// Package fnv implements FNV-1 and FNV-1a, non-cryptographic hash functions\n+// created by Glenn Fowler, Landon Curt Noll, and Phong Vo.\n // See http://isthe.com/chongo/tech/comp/fnv/.\n package fnv\n "}, {"sha": "429230c80b4f58b8f4033da190543bf0f9f9b020", "filename": "libgo/go/hash/fnv/fnv_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhash%2Ffnv%2Ffnv_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhash%2Ffnv%2Ffnv_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Ffnv%2Ffnv_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -154,7 +154,7 @@ func benchmark(b *testing.B, h hash.Hash) {\n \tb.ResetTimer()\n \tb.SetBytes(testDataSize)\n \tdata := make([]byte, testDataSize)\n-\tfor i, _ := range data {\n+\tfor i := range data {\n \t\tdata[i] = byte(i + 'a')\n \t}\n "}, {"sha": "3536c0b6a64a89dbb279276ded71ef47525bab90", "filename": "libgo/go/hash/hash.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhash%2Fhash.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhash%2Fhash.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Fhash.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// Package hash provides interfaces for hash functions.\n package hash\n \n import \"io\""}, {"sha": "55135c3d05fb198324a9884f6ca8463a66438c79", "filename": "libgo/go/html/doc.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhtml%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhtml%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fdoc.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -3,7 +3,7 @@\n // license that can be found in the LICENSE file.\n \n /*\n-The html package implements an HTML5-compliant tokenizer and parser.\n+Package html implements an HTML5-compliant tokenizer and parser.\n \n Tokenization is done by creating a Tokenizer for an io.Reader r. It is the\n caller's responsibility to ensure that r provides UTF-8 encoded HTML."}, {"sha": "3fa35d5dbe4c5eb3fd0cc5a59884cfb92c3be162", "filename": "libgo/go/html/parse_test.go", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhtml%2Fparse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhtml%2Fparse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fparse_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -15,12 +15,6 @@ import (\n \t\"testing\"\n )\n \n-type devNull struct{}\n-\n-func (devNull) Write(p []byte) (int, os.Error) {\n-\treturn len(p), nil\n-}\n-\n func pipeErr(err os.Error) io.Reader {\n \tpr, pw := io.Pipe()\n \tpw.CloseWithError(err)\n@@ -141,7 +135,7 @@ func TestParser(t *testing.T) {\n \t\t\t\tt.Fatal(err)\n \t\t\t}\n \t\t\t// Skip the #error section.\n-\t\t\tif _, err := io.Copy(devNull{}, <-rc); err != nil {\n+\t\t\tif _, err := io.Copy(ioutil.Discard, <-rc); err != nil {\n \t\t\t\tt.Fatal(err)\n \t\t\t}\n \t\t\t// Compare the parsed tree to the #document section."}, {"sha": "e1ad7ad32211ace01b3c3263d1c129d995e08f6b", "filename": "libgo/go/http/cgi/child.go", "status": "modified", "additions": 48, "deletions": 41, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fcgi%2Fchild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fcgi%2Fchild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fcgi%2Fchild.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -9,10 +9,12 @@ package cgi\n \n import (\n \t\"bufio\"\n+\t\"crypto/tls\"\n \t\"fmt\"\n \t\"http\"\n \t\"io\"\n \t\"io/ioutil\"\n+\t\"net\"\n \t\"os\"\n \t\"strconv\"\n \t\"strings\"\n@@ -21,8 +23,16 @@ import (\n // Request returns the HTTP request as represented in the current\n // environment. This assumes the current program is being run\n // by a web server in a CGI environment.\n+// The returned Request's Body is populated, if applicable.\n func Request() (*http.Request, os.Error) {\n-\treturn requestFromEnvironment(envMap(os.Environ()))\n+\tr, err := RequestFromMap(envMap(os.Environ()))\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif r.ContentLength > 0 {\n+\t\tr.Body = ioutil.NopCloser(io.LimitReader(os.Stdin, r.ContentLength))\n+\t}\n+\treturn r, nil\n }\n \n func envMap(env []string) map[string]string {\n@@ -42,37 +52,44 @@ var skipHeader = map[string]bool{\n \t\"HTTP_USER_AGENT\": true,\n }\n \n-func requestFromEnvironment(env map[string]string) (*http.Request, os.Error) {\n+// RequestFromMap creates an http.Request from CGI variables.\n+// The returned Request's Body field is not populated.\n+func RequestFromMap(params map[string]string) (*http.Request, os.Error) {\n \tr := new(http.Request)\n-\tr.Method = env[\"REQUEST_METHOD\"]\n+\tr.Method = params[\"REQUEST_METHOD\"]\n \tif r.Method == \"\" {\n \t\treturn nil, os.NewError(\"cgi: no REQUEST_METHOD in environment\")\n \t}\n+\n+\tr.Proto = params[\"SERVER_PROTOCOL\"]\n+\tvar ok bool\n+\tr.ProtoMajor, r.ProtoMinor, ok = http.ParseHTTPVersion(r.Proto)\n+\tif !ok {\n+\t\treturn nil, os.NewError(\"cgi: invalid SERVER_PROTOCOL version\")\n+\t}\n+\n \tr.Close = true\n \tr.Trailer = http.Header{}\n \tr.Header = http.Header{}\n \n-\tr.Host = env[\"HTTP_HOST\"]\n-\tr.Referer = env[\"HTTP_REFERER\"]\n-\tr.UserAgent = env[\"HTTP_USER_AGENT\"]\n+\tr.Host = params[\"HTTP_HOST\"]\n+\tr.Referer = params[\"HTTP_REFERER\"]\n+\tr.UserAgent = params[\"HTTP_USER_AGENT\"]\n \n-\t// CGI doesn't allow chunked requests, so these should all be accurate:\n-\tr.Proto = \"HTTP/1.0\"\n-\tr.ProtoMajor = 1\n-\tr.ProtoMinor = 0\n-\tr.TransferEncoding = nil\n-\n-\tif lenstr := env[\"CONTENT_LENGTH\"]; lenstr != \"\" {\n+\tif lenstr := params[\"CONTENT_LENGTH\"]; lenstr != \"\" {\n \t\tclen, err := strconv.Atoi64(lenstr)\n \t\tif err != nil {\n \t\t\treturn nil, os.NewError(\"cgi: bad CONTENT_LENGTH in environment: \" + lenstr)\n \t\t}\n \t\tr.ContentLength = clen\n-\t\tr.Body = ioutil.NopCloser(io.LimitReader(os.Stdin, clen))\n+\t}\n+\n+\tif ct := params[\"CONTENT_TYPE\"]; ct != \"\" {\n+\t\tr.Header.Set(\"Content-Type\", ct)\n \t}\n \n \t// Copy \"HTTP_FOO_BAR\" variables to \"Foo-Bar\" Headers\n-\tfor k, v := range env {\n+\tfor k, v := range params {\n \t\tif !strings.HasPrefix(k, \"HTTP_\") || skipHeader[k] {\n \t\t\tcontinue\n \t\t}\n@@ -84,7 +101,7 @@ func requestFromEnvironment(env map[string]string) (*http.Request, os.Error) {\n \tif r.Host != \"\" {\n \t\t// Hostname is provided, so we can reasonably construct a URL,\n \t\t// even if we have to assume 'http' for the scheme.\n-\t\tr.RawURL = \"http://\" + r.Host + env[\"REQUEST_URI\"]\n+\t\tr.RawURL = \"http://\" + r.Host + params[\"REQUEST_URI\"]\n \t\turl, err := http.ParseURL(r.RawURL)\n \t\tif err != nil {\n \t\t\treturn nil, os.NewError(\"cgi: failed to parse host and REQUEST_URI into a URL: \" + r.RawURL)\n@@ -94,13 +111,25 @@ func requestFromEnvironment(env map[string]string) (*http.Request, os.Error) {\n \t// Fallback logic if we don't have a Host header or the URL\n \t// failed to parse\n \tif r.URL == nil {\n-\t\tr.RawURL = env[\"REQUEST_URI\"]\n+\t\tr.RawURL = params[\"REQUEST_URI\"]\n \t\turl, err := http.ParseURL(r.RawURL)\n \t\tif err != nil {\n \t\t\treturn nil, os.NewError(\"cgi: failed to parse REQUEST_URI into a URL: \" + r.RawURL)\n \t\t}\n \t\tr.URL = url\n \t}\n+\n+\t// There's apparently a de-facto standard for this.\n+\t// http://docstore.mik.ua/orelly/linux/cgi/ch03_02.htm#ch03-35636\n+\tif s := params[\"HTTPS\"]; s == \"on\" || s == \"ON\" || s == \"1\" {\n+\t\tr.TLS = &tls.ConnectionState{HandshakeComplete: true}\n+\t}\n+\n+\t// Request.RemoteAddr has its port set by Go's standard http\n+\t// server, so we do here too. We don't have one, though, so we\n+\t// use a dummy one.\n+\tr.RemoteAddr = net.JoinHostPort(params[\"REMOTE_ADDR\"], \"0\")\n+\n \treturn r, nil\n }\n \n@@ -139,10 +168,6 @@ func (r *response) Flush() {\n \tr.bufw.Flush()\n }\n \n-func (r *response) RemoteAddr() string {\n-\treturn os.Getenv(\"REMOTE_ADDR\")\n-}\n-\n func (r *response) Header() http.Header {\n \treturn r.header\n }\n@@ -168,25 +193,7 @@ func (r *response) WriteHeader(code int) {\n \t\tr.header.Add(\"Content-Type\", \"text/html; charset=utf-8\")\n \t}\n \n-\t// TODO: add a method on http.Header to write itself to an io.Writer?\n-\t// This is duplicated code.\n-\tfor k, vv := range r.header {\n-\t\tfor _, v := range vv {\n-\t\t\tv = strings.Replace(v, \"\\n\", \"\", -1)\n-\t\t\tv = strings.Replace(v, \"\\r\", \"\", -1)\n-\t\t\tv = strings.TrimSpace(v)\n-\t\t\tfmt.Fprintf(r.bufw, \"%s: %s\\r\\n\", k, v)\n-\t\t}\n-\t}\n-\tr.bufw.Write([]byte(\"\\r\\n\"))\n+\tr.header.Write(r.bufw)\n+\tr.bufw.WriteString(\"\\r\\n\")\n \tr.bufw.Flush()\n }\n-\n-func (r *response) UsingTLS() bool {\n-\t// There's apparently a de-facto standard for this.\n-\t// http://docstore.mik.ua/orelly/linux/cgi/ch03_02.htm#ch03-35636\n-\tif s := os.Getenv(\"HTTPS\"); s == \"on\" || s == \"ON\" || s == \"1\" {\n-\t\treturn true\n-\t}\n-\treturn false\n-}"}, {"sha": "d12947814e1e799f38c9794c7fb3012424ae8e4c", "filename": "libgo/go/http/cgi/child_test.go", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fcgi%2Fchild_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fcgi%2Fchild_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fcgi%2Fchild_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -12,17 +12,21 @@ import (\n \n func TestRequest(t *testing.T) {\n \tenv := map[string]string{\n+\t\t\"SERVER_PROTOCOL\": \"HTTP/1.1\",\n \t\t\"REQUEST_METHOD\":  \"GET\",\n \t\t\"HTTP_HOST\":       \"example.com\",\n \t\t\"HTTP_REFERER\":    \"elsewhere\",\n \t\t\"HTTP_USER_AGENT\": \"goclient\",\n \t\t\"HTTP_FOO_BAR\":    \"baz\",\n \t\t\"REQUEST_URI\":     \"/path?a=b\",\n \t\t\"CONTENT_LENGTH\":  \"123\",\n+\t\t\"CONTENT_TYPE\":    \"text/xml\",\n+\t\t\"HTTPS\":           \"1\",\n+\t\t\"REMOTE_ADDR\":     \"5.6.7.8\",\n \t}\n-\treq, err := requestFromEnvironment(env)\n+\treq, err := RequestFromMap(env)\n \tif err != nil {\n-\t\tt.Fatalf(\"requestFromEnvironment: %v\", err)\n+\t\tt.Fatalf(\"RequestFromMap: %v\", err)\n \t}\n \tif g, e := req.UserAgent, \"goclient\"; e != g {\n \t\tt.Errorf(\"expected UserAgent %q; got %q\", e, g)\n@@ -34,6 +38,9 @@ func TestRequest(t *testing.T) {\n \t\t// Tests that we don't put recognized headers in the map\n \t\tt.Errorf(\"expected User-Agent %q; got %q\", e, g)\n \t}\n+\tif g, e := req.Header.Get(\"Content-Type\"), \"text/xml\"; e != g {\n+\t\tt.Errorf(\"expected Content-Type %q; got %q\", e, g)\n+\t}\n \tif g, e := req.ContentLength, int64(123); e != g {\n \t\tt.Errorf(\"expected ContentLength %d; got %d\", e, g)\n \t}\n@@ -58,18 +65,25 @@ func TestRequest(t *testing.T) {\n \tif req.Trailer == nil {\n \t\tt.Errorf(\"unexpected nil Trailer\")\n \t}\n+\tif req.TLS == nil {\n+\t\tt.Errorf(\"expected non-nil TLS\")\n+\t}\n+\tif e, g := \"5.6.7.8:0\", req.RemoteAddr; e != g {\n+\t\tt.Errorf(\"RemoteAddr: got %q; want %q\", g, e)\n+\t}\n }\n \n func TestRequestWithoutHost(t *testing.T) {\n \tenv := map[string]string{\n-\t\t\"HTTP_HOST\":      \"\",\n-\t\t\"REQUEST_METHOD\": \"GET\",\n-\t\t\"REQUEST_URI\":    \"/path?a=b\",\n-\t\t\"CONTENT_LENGTH\": \"123\",\n+\t\t\"SERVER_PROTOCOL\": \"HTTP/1.1\",\n+\t\t\"HTTP_HOST\":       \"\",\n+\t\t\"REQUEST_METHOD\":  \"GET\",\n+\t\t\"REQUEST_URI\":     \"/path?a=b\",\n+\t\t\"CONTENT_LENGTH\":  \"123\",\n \t}\n-\treq, err := requestFromEnvironment(env)\n+\treq, err := RequestFromMap(env)\n \tif err != nil {\n-\t\tt.Fatalf(\"requestFromEnvironment: %v\", err)\n+\t\tt.Fatalf(\"RequestFromMap: %v\", err)\n \t}\n \tif g, e := req.RawURL, \"/path?a=b\"; e != g {\n \t\tt.Errorf(\"expected RawURL %q; got %q\", e, g)"}, {"sha": "7e4ccf881d93ac9a3633d5b0dab14f504f7ed479", "filename": "libgo/go/http/cgi/host.go", "status": "modified", "additions": 77, "deletions": 11, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fcgi%2Fhost.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fcgi%2Fhost.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fcgi%2Fhost.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -15,8 +15,8 @@\n package cgi\n \n import (\n+\t\"bufio\"\n \t\"bytes\"\n-\t\"encoding/line\"\n \t\"exec\"\n \t\"fmt\"\n \t\"http\"\n@@ -51,6 +51,16 @@ type Handler struct {\n \tInheritEnv []string    // environment variables to inherit from host, as \"key\"\n \tLogger     *log.Logger // optional log for errors or nil to use log.Print\n \tArgs       []string    // optional arguments to pass to child process\n+\n+\t// PathLocationHandler specifies the root http Handler that\n+\t// should handle internal redirects when the CGI process\n+\t// returns a Location header value starting with a \"/\", as\n+\t// specified in RFC 3875 \u00a7 6.3.2. This will likely be\n+\t// http.DefaultServeMux.\n+\t//\n+\t// If nil, a CGI response with a local URI path is instead sent\n+\t// back to the client and not redirected internally.\n+\tPathLocationHandler http.Handler\n }\n \n func (h *Handler) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n@@ -78,6 +88,7 @@ func (h *Handler) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n \tenv := []string{\n \t\t\"SERVER_SOFTWARE=go\",\n \t\t\"SERVER_NAME=\" + req.Host,\n+\t\t\"SERVER_PROTOCOL=HTTP/1.1\",\n \t\t\"HTTP_HOST=\" + req.Host,\n \t\t\"GATEWAY_INTERFACE=CGI/1.1\",\n \t\t\"REQUEST_METHOD=\" + req.Method,\n@@ -172,30 +183,30 @@ func (h *Handler) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n \t\tgo io.Copy(cmd.Stdin, req.Body)\n \t}\n \n-\tlinebody := line.NewReader(cmd.Stdout, 1024)\n-\theaders := rw.Header()\n-\tstatusCode := http.StatusOK\n+\tlinebody, _ := bufio.NewReaderSize(cmd.Stdout, 1024)\n+\theaders := make(http.Header)\n+\tstatusCode := 0\n \tfor {\n \t\tline, isPrefix, err := linebody.ReadLine()\n \t\tif isPrefix {\n \t\t\trw.WriteHeader(http.StatusInternalServerError)\n-\t\t\th.printf(\"CGI: long header line from subprocess.\")\n+\t\t\th.printf(\"cgi: long header line from subprocess.\")\n \t\t\treturn\n \t\t}\n \t\tif err == os.EOF {\n \t\t\tbreak\n \t\t}\n \t\tif err != nil {\n \t\t\trw.WriteHeader(http.StatusInternalServerError)\n-\t\t\th.printf(\"CGI: error reading headers: %v\", err)\n+\t\t\th.printf(\"cgi: error reading headers: %v\", err)\n \t\t\treturn\n \t\t}\n \t\tif len(line) == 0 {\n \t\t\tbreak\n \t\t}\n \t\tparts := strings.Split(string(line), \":\", 2)\n \t\tif len(parts) < 2 {\n-\t\t\th.printf(\"CGI: bogus header line: %s\", string(line))\n+\t\t\th.printf(\"cgi: bogus header line: %s\", string(line))\n \t\t\tcontinue\n \t\t}\n \t\theader, val := parts[0], parts[1]\n@@ -204,25 +215,49 @@ func (h *Handler) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n \t\tswitch {\n \t\tcase header == \"Status\":\n \t\t\tif len(val) < 3 {\n-\t\t\t\th.printf(\"CGI: bogus status (short): %q\", val)\n+\t\t\t\th.printf(\"cgi: bogus status (short): %q\", val)\n \t\t\t\treturn\n \t\t\t}\n \t\t\tcode, err := strconv.Atoi(val[0:3])\n \t\t\tif err != nil {\n-\t\t\t\th.printf(\"CGI: bogus status: %q\", val)\n-\t\t\t\th.printf(\"CGI: line was %q\", line)\n+\t\t\t\th.printf(\"cgi: bogus status: %q\", val)\n+\t\t\t\th.printf(\"cgi: line was %q\", line)\n \t\t\t\treturn\n \t\t\t}\n \t\t\tstatusCode = code\n \t\tdefault:\n \t\t\theaders.Add(header, val)\n \t\t}\n \t}\n+\n+\tif loc := headers.Get(\"Location\"); loc != \"\" {\n+\t\tif strings.HasPrefix(loc, \"/\") && h.PathLocationHandler != nil {\n+\t\t\th.handleInternalRedirect(rw, req, loc)\n+\t\t\treturn\n+\t\t}\n+\t\tif statusCode == 0 {\n+\t\t\tstatusCode = http.StatusFound\n+\t\t}\n+\t}\n+\n+\tif statusCode == 0 {\n+\t\tstatusCode = http.StatusOK\n+\t}\n+\n+\t// Copy headers to rw's headers, after we've decided not to\n+\t// go into handleInternalRedirect, which won't want its rw\n+\t// headers to have been touched.\n+\tfor k, vv := range headers {\n+\t\tfor _, v := range vv {\n+\t\t\trw.Header().Add(k, v)\n+\t\t}\n+\t}\n+\n \trw.WriteHeader(statusCode)\n \n \t_, err = io.Copy(rw, linebody)\n \tif err != nil {\n-\t\th.printf(\"CGI: copy error: %v\", err)\n+\t\th.printf(\"cgi: copy error: %v\", err)\n \t}\n }\n \n@@ -234,6 +269,37 @@ func (h *Handler) printf(format string, v ...interface{}) {\n \t}\n }\n \n+func (h *Handler) handleInternalRedirect(rw http.ResponseWriter, req *http.Request, path string) {\n+\turl, err := req.URL.ParseURL(path)\n+\tif err != nil {\n+\t\trw.WriteHeader(http.StatusInternalServerError)\n+\t\th.printf(\"cgi: error resolving local URI path %q: %v\", path, err)\n+\t\treturn\n+\t}\n+\t// TODO: RFC 3875 isn't clear if only GET is supported, but it\n+\t// suggests so: \"Note that any message-body attached to the\n+\t// request (such as for a POST request) may not be available\n+\t// to the resource that is the target of the redirect.\"  We\n+\t// should do some tests against Apache to see how it handles\n+\t// POST, HEAD, etc. Does the internal redirect get the same\n+\t// method or just GET? What about incoming headers?\n+\t// (e.g. Cookies) Which headers, if any, are copied into the\n+\t// second request?\n+\tnewReq := &http.Request{\n+\t\tMethod:     \"GET\",\n+\t\tURL:        url,\n+\t\tRawURL:     path,\n+\t\tProto:      \"HTTP/1.1\",\n+\t\tProtoMajor: 1,\n+\t\tProtoMinor: 1,\n+\t\tHeader:     make(http.Header),\n+\t\tHost:       url.Host,\n+\t\tRemoteAddr: req.RemoteAddr,\n+\t\tTLS:        req.TLS,\n+\t}\n+\th.PathLocationHandler.ServeHTTP(rw, newReq)\n+}\n+\n func upperCaseAndUnderscore(rune int) int {\n \tswitch {\n \tcase rune >= 'a' && rune <= 'z':"}, {"sha": "9ac085f2f3aba7542d7d1d7d01b9f7609abe6965", "filename": "libgo/go/http/cgi/host_test.go", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fcgi%2Fhost_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fcgi%2Fhost_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fcgi%2Fhost_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -271,3 +271,40 @@ Transfer-Encoding: chunked\n \t\t\texpected, got)\n \t}\n }\n+\n+func TestRedirect(t *testing.T) {\n+\tif skipTest(t) {\n+\t\treturn\n+\t}\n+\th := &Handler{\n+\t\tPath: \"testdata/test.cgi\",\n+\t\tRoot: \"/test.cgi\",\n+\t}\n+\trec := runCgiTest(t, h, \"GET /test.cgi?loc=http://foo.com/ HTTP/1.0\\nHost: example.com\\n\\n\", nil)\n+\tif e, g := 302, rec.Code; e != g {\n+\t\tt.Errorf(\"expected status code %d; got %d\", e, g)\n+\t}\n+\tif e, g := \"http://foo.com/\", rec.Header().Get(\"Location\"); e != g {\n+\t\tt.Errorf(\"expected Location header of %q; got %q\", e, g)\n+\t}\n+}\n+\n+func TestInternalRedirect(t *testing.T) {\n+\tif skipTest(t) {\n+\t\treturn\n+\t}\n+\tbaseHandler := http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) {\n+\t\tfmt.Fprintf(rw, \"basepath=%s\\n\", req.URL.Path)\n+\t\tfmt.Fprintf(rw, \"remoteaddr=%s\\n\", req.RemoteAddr)\n+\t})\n+\th := &Handler{\n+\t\tPath:                \"testdata/test.cgi\",\n+\t\tRoot:                \"/test.cgi\",\n+\t\tPathLocationHandler: baseHandler,\n+\t}\n+\texpectedMap := map[string]string{\n+\t\t\"basepath\":   \"/foo\",\n+\t\t\"remoteaddr\": \"1.2.3.4\",\n+\t}\n+\trunCgiTest(t, h, \"GET /test.cgi?loc=/foo HTTP/1.0\\nHost: example.com\\n\\n\", expectedMap)\n+}"}, {"sha": "d73cbc8550cab60b1c0cb142e1d8d3bb46300658", "filename": "libgo/go/http/client.go", "status": "modified", "additions": 44, "deletions": 15, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fclient.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -22,6 +22,16 @@ import (\n // Client is not yet very configurable.\n type Client struct {\n \tTransport RoundTripper // if nil, DefaultTransport is used\n+\n+\t// If CheckRedirect is not nil, the client calls it before\n+\t// following an HTTP redirect. The arguments req and via\n+\t// are the upcoming request and the requests made already,\n+\t// oldest first. If CheckRedirect returns an error, the client\n+\t// returns that error instead of issue the Request req.\n+\t//\n+\t// If CheckRedirect is nil, the Client uses its default policy,\n+\t// which is to stop after 10 consecutive requests.\n+\tCheckRedirect func(req *Request, via []*Request) os.Error\n }\n \n // DefaultClient is the default Client and is used by Get, Head, and Post.\n@@ -109,7 +119,7 @@ func shouldRedirect(statusCode int) bool {\n }\n \n // Get issues a GET to the specified URL.  If the response is one of the following\n-// redirect codes, it follows the redirect, up to a maximum of 10 redirects:\n+// redirect codes, Get follows the redirect, up to a maximum of 10 redirects:\n //\n //    301 (Moved Permanently)\n //    302 (Found)\n@@ -126,35 +136,33 @@ func Get(url string) (r *Response, finalURL string, err os.Error) {\n \treturn DefaultClient.Get(url)\n }\n \n-// Get issues a GET to the specified URL.  If the response is one of the following\n-// redirect codes, it follows the redirect, up to a maximum of 10 redirects:\n+// Get issues a GET to the specified URL.  If the response is one of the\n+// following redirect codes, Get follows the redirect after calling the\n+// Client's CheckRedirect function.\n //\n //    301 (Moved Permanently)\n //    302 (Found)\n //    303 (See Other)\n //    307 (Temporary Redirect)\n //\n-// finalURL is the URL from which the response was fetched -- identical to the\n-// input URL unless redirects were followed.\n+// finalURL is the URL from which the response was fetched -- identical\n+// to the input URL unless redirects were followed.\n //\n // Caller should close r.Body when done reading from it.\n func (c *Client) Get(url string) (r *Response, finalURL string, err os.Error) {\n \t// TODO: if/when we add cookie support, the redirected request shouldn't\n \t// necessarily supply the same cookies as the original.\n-\t// TODO: set referrer header on redirects.\n \tvar base *URL\n-\t// TODO: remove this hard-coded 10 and use the Client's policy\n-\t// (ClientConfig) instead.\n-\tfor redirect := 0; ; redirect++ {\n-\t\tif redirect >= 10 {\n-\t\t\terr = os.ErrorString(\"stopped after 10 redirects\")\n-\t\t\tbreak\n-\t\t}\n+\tredirectChecker := c.CheckRedirect\n+\tif redirectChecker == nil {\n+\t\tredirectChecker = defaultCheckRedirect\n+\t}\n+\tvar via []*Request\n \n+\tfor redirect := 0; ; redirect++ {\n \t\tvar req Request\n \t\treq.Method = \"GET\"\n-\t\treq.ProtoMajor = 1\n-\t\treq.ProtoMinor = 1\n+\t\treq.Header = make(Header)\n \t\tif base == nil {\n \t\t\treq.URL, err = ParseURL(url)\n \t\t} else {\n@@ -163,6 +171,19 @@ func (c *Client) Get(url string) (r *Response, finalURL string, err os.Error) {\n \t\tif err != nil {\n \t\t\tbreak\n \t\t}\n+\t\tif len(via) > 0 {\n+\t\t\t// Add the Referer header.\n+\t\t\tlastReq := via[len(via)-1]\n+\t\t\tif lastReq.URL.Scheme != \"https\" {\n+\t\t\t\treq.Referer = lastReq.URL.String()\n+\t\t\t}\n+\n+\t\t\terr = redirectChecker(&req, via)\n+\t\t\tif err != nil {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\n \t\turl = req.URL.String()\n \t\tif r, err = send(&req, c.Transport); err != nil {\n \t\t\tbreak\n@@ -174,6 +195,7 @@ func (c *Client) Get(url string) (r *Response, finalURL string, err os.Error) {\n \t\t\t\tbreak\n \t\t\t}\n \t\t\tbase = req.URL\n+\t\t\tvia = append(via, &req)\n \t\t\tcontinue\n \t\t}\n \t\tfinalURL = url\n@@ -184,6 +206,13 @@ func (c *Client) Get(url string) (r *Response, finalURL string, err os.Error) {\n \treturn\n }\n \n+func defaultCheckRedirect(req *Request, via []*Request) os.Error {\n+\tif len(via) >= 10 {\n+\t\treturn os.ErrorString(\"stopped after 10 redirects\")\n+\t}\n+\treturn nil\n+}\n+\n // Post issues a POST to the specified URL.\n //\n // Caller should close r.Body when done reading from it."}, {"sha": "59d62c1c9d4cbd885e5299912a5d9b7e6658ab58", "filename": "libgo/go/http/client_test.go", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fclient_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fclient_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fclient_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -12,6 +12,7 @@ import (\n \t\"http/httptest\"\n \t\"io/ioutil\"\n \t\"os\"\n+\t\"strconv\"\n \t\"strings\"\n \t\"testing\"\n )\n@@ -75,3 +76,51 @@ func TestGetRequestFormat(t *testing.T) {\n \t\tt.Errorf(\"expected non-nil request Header\")\n \t}\n }\n+\n+func TestRedirects(t *testing.T) {\n+\tvar ts *httptest.Server\n+\tts = httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n+\t\tn, _ := strconv.Atoi(r.FormValue(\"n\"))\n+\t\t// Test Referer header. (7 is arbitrary position to test at)\n+\t\tif n == 7 {\n+\t\t\tif g, e := r.Referer, ts.URL+\"/?n=6\"; e != g {\n+\t\t\t\tt.Errorf(\"on request ?n=7, expected referer of %q; got %q\", e, g)\n+\t\t\t}\n+\t\t}\n+\t\tif n < 15 {\n+\t\t\tRedirect(w, r, fmt.Sprintf(\"/?n=%d\", n+1), StatusFound)\n+\t\t\treturn\n+\t\t}\n+\t\tfmt.Fprintf(w, \"n=%d\", n)\n+\t}))\n+\tdefer ts.Close()\n+\n+\tc := &Client{}\n+\t_, _, err := c.Get(ts.URL)\n+\tif e, g := \"Get /?n=10: stopped after 10 redirects\", fmt.Sprintf(\"%v\", err); e != g {\n+\t\tt.Errorf(\"with default client, expected error %q, got %q\", e, g)\n+\t}\n+\n+\tvar checkErr os.Error\n+\tvar lastVia []*Request\n+\tc = &Client{CheckRedirect: func(_ *Request, via []*Request) os.Error {\n+\t\tlastVia = via\n+\t\treturn checkErr\n+\t}}\n+\t_, finalUrl, err := c.Get(ts.URL)\n+\tif e, g := \"<nil>\", fmt.Sprintf(\"%v\", err); e != g {\n+\t\tt.Errorf(\"with custom client, expected error %q, got %q\", e, g)\n+\t}\n+\tif !strings.HasSuffix(finalUrl, \"/?n=15\") {\n+\t\tt.Errorf(\"expected final url to end in /?n=15; got url %q\", finalUrl)\n+\t}\n+\tif e, g := 15, len(lastVia); e != g {\n+\t\tt.Errorf(\"expected lastVia to have contained %d elements; got %d\", e, g)\n+\t}\n+\n+\tcheckErr = os.NewError(\"no redirects allowed\")\n+\t_, finalUrl, err = c.Get(ts.URL)\n+\tif e, g := \"Get /?n=1: no redirects allowed\", fmt.Sprintf(\"%v\", err); e != g {\n+\t\tt.Errorf(\"with redirects forbidden, expected error %q, got %q\", e, g)\n+\t}\n+}"}, {"sha": "cc51316438aa8377630e002731b7e1c192e221ac", "filename": "libgo/go/http/cookie.go", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fcookie.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fcookie.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fcookie.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -15,9 +15,9 @@ import (\n \t\"time\"\n )\n \n-// This implementation is done according to IETF draft-ietf-httpstate-cookie-23, found at\n+// This implementation is done according to RFC 6265:\n //\n-//    http://tools.ietf.org/html/draft-ietf-httpstate-cookie-23\n+//    http://tools.ietf.org/html/rfc6265\n \n // A Cookie represents an HTTP cookie as sent in the Set-Cookie header of an\n // HTTP response or the Cookie header of an HTTP request.\n@@ -142,12 +142,12 @@ func writeSetCookies(w io.Writer, kk []*Cookie) os.Error {\n \tvar b bytes.Buffer\n \tfor _, c := range kk {\n \t\tb.Reset()\n-\t\tfmt.Fprintf(&b, \"%s=%s\", c.Name, c.Value)\n+\t\tfmt.Fprintf(&b, \"%s=%s\", sanitizeName(c.Name), sanitizeValue(c.Value))\n \t\tif len(c.Path) > 0 {\n-\t\t\tfmt.Fprintf(&b, \"; Path=%s\", URLEscape(c.Path))\n+\t\t\tfmt.Fprintf(&b, \"; Path=%s\", sanitizeValue(c.Path))\n \t\t}\n \t\tif len(c.Domain) > 0 {\n-\t\t\tfmt.Fprintf(&b, \"; Domain=%s\", URLEscape(c.Domain))\n+\t\t\tfmt.Fprintf(&b, \"; Domain=%s\", sanitizeValue(c.Domain))\n \t\t}\n \t\tif len(c.Expires.Zone) > 0 {\n \t\t\tfmt.Fprintf(&b, \"; Expires=%s\", c.Expires.Format(time.RFC1123))\n@@ -225,7 +225,7 @@ func readCookies(h Header) []*Cookie {\n func writeCookies(w io.Writer, kk []*Cookie) os.Error {\n \tlines := make([]string, 0, len(kk))\n \tfor _, c := range kk {\n-\t\tlines = append(lines, fmt.Sprintf(\"Cookie: %s=%s\\r\\n\", c.Name, c.Value))\n+\t\tlines = append(lines, fmt.Sprintf(\"Cookie: %s=%s\\r\\n\", sanitizeName(c.Name), sanitizeValue(c.Value)))\n \t}\n \tsort.SortStrings(lines)\n \tfor _, l := range lines {\n@@ -236,6 +236,19 @@ func writeCookies(w io.Writer, kk []*Cookie) os.Error {\n \treturn nil\n }\n \n+func sanitizeName(n string) string {\n+\tn = strings.Replace(n, \"\\n\", \"-\", -1)\n+\tn = strings.Replace(n, \"\\r\", \"-\", -1)\n+\treturn n\n+}\n+\n+func sanitizeValue(v string) string {\n+\tv = strings.Replace(v, \"\\n\", \" \", -1)\n+\tv = strings.Replace(v, \"\\r\", \" \", -1)\n+\tv = strings.Replace(v, \";\", \" \", -1)\n+\treturn v\n+}\n+\n func unquoteCookieValue(v string) string {\n \tif len(v) > 1 && v[0] == '\"' && v[len(v)-1] == '\"' {\n \t\treturn v[1 : len(v)-1]"}, {"sha": "a3ae85cd6c956644131d722ad7a13417770e3b28", "filename": "libgo/go/http/cookie_test.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fcookie_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fcookie_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fcookie_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -21,9 +21,13 @@ var writeSetCookiesTests = []struct {\n \t\t[]*Cookie{\n \t\t\t&Cookie{Name: \"cookie-1\", Value: \"v$1\"},\n \t\t\t&Cookie{Name: \"cookie-2\", Value: \"two\", MaxAge: 3600},\n+\t\t\t&Cookie{Name: \"cookie-3\", Value: \"three\", Domain: \".example.com\"},\n+\t\t\t&Cookie{Name: \"cookie-4\", Value: \"four\", Path: \"/restricted/\"},\n \t\t},\n \t\t\"Set-Cookie: cookie-1=v$1\\r\\n\" +\n-\t\t\t\"Set-Cookie: cookie-2=two; Max-Age=3600\\r\\n\",\n+\t\t\t\"Set-Cookie: cookie-2=two; Max-Age=3600\\r\\n\" +\n+\t\t\t\"Set-Cookie: cookie-3=three; Domain=.example.com\\r\\n\" +\n+\t\t\t\"Set-Cookie: cookie-4=four; Path=/restricted/\\r\\n\",\n \t},\n }\n "}, {"sha": "358980f7cae46798de0032cea92747dfb76011c7", "filename": "libgo/go/http/dump.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fdump.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fdump.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fdump.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -31,6 +31,8 @@ func drainBody(b io.ReadCloser) (r1, r2 io.ReadCloser, err os.Error) {\n // DumpRequest is semantically a no-op, but in order to\n // dump the body, it reads the body data into memory and\n // changes req.Body to refer to the in-memory copy.\n+// The documentation for Request.Write details which fields\n+// of req are used.\n func DumpRequest(req *Request, body bool) (dump []byte, err os.Error) {\n \tvar b bytes.Buffer\n \tsave := req.Body"}, {"sha": "3fe658641f8b4e546a4b7b95f5bbb21f1a5e8dd2", "filename": "libgo/go/http/export_test.go", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fexport_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -14,7 +14,7 @@ func (t *Transport) IdleConnKeysForTesting() (keys []string) {\n \tif t.idleConn == nil {\n \t\treturn\n \t}\n-\tfor key, _ := range t.idleConn {\n+\tfor key := range t.idleConn {\n \t\tkeys = append(keys, key)\n \t}\n \treturn\n@@ -32,3 +32,10 @@ func (t *Transport) IdleConnCountForTesting(cacheKey string) int {\n \t}\n \treturn len(conns)\n }\n+\n+func NewTestTimeoutHandler(handler Handler, ch <-chan int64) Handler {\n+\tf := func() <-chan int64 {\n+\t\treturn ch\n+\t}\n+\treturn &timeoutHandler{handler, f, \"\"}\n+}"}, {"sha": "19718824c96f863989ef3e913812f8804fddb47b", "filename": "libgo/go/http/fcgi/child.go", "status": "added", "additions": 258, "deletions": 0, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Ffcgi%2Fchild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Ffcgi%2Fchild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ffcgi%2Fchild.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -0,0 +1,258 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package fcgi\n+\n+// This file implements FastCGI from the perspective of a child process.\n+\n+import (\n+\t\"fmt\"\n+\t\"http\"\n+\t\"http/cgi\"\n+\t\"io\"\n+\t\"net\"\n+\t\"os\"\n+\t\"time\"\n+)\n+\n+// request holds the state for an in-progress request. As soon as it's complete,\n+// it's converted to an http.Request.\n+type request struct {\n+\tpw        *io.PipeWriter\n+\treqId     uint16\n+\tparams    map[string]string\n+\tbuf       [1024]byte\n+\trawParams []byte\n+\tkeepConn  bool\n+}\n+\n+func newRequest(reqId uint16, flags uint8) *request {\n+\tr := &request{\n+\t\treqId:    reqId,\n+\t\tparams:   map[string]string{},\n+\t\tkeepConn: flags&flagKeepConn != 0,\n+\t}\n+\tr.rawParams = r.buf[:0]\n+\treturn r\n+}\n+\n+// parseParams reads an encoded []byte into Params.\n+func (r *request) parseParams() {\n+\ttext := r.rawParams\n+\tr.rawParams = nil\n+\tfor len(text) > 0 {\n+\t\tkeyLen, n := readSize(text)\n+\t\tif n == 0 {\n+\t\t\treturn\n+\t\t}\n+\t\ttext = text[n:]\n+\t\tvalLen, n := readSize(text)\n+\t\tif n == 0 {\n+\t\t\treturn\n+\t\t}\n+\t\ttext = text[n:]\n+\t\tkey := readString(text, keyLen)\n+\t\ttext = text[keyLen:]\n+\t\tval := readString(text, valLen)\n+\t\ttext = text[valLen:]\n+\t\tr.params[key] = val\n+\t}\n+}\n+\n+// response implements http.ResponseWriter.\n+type response struct {\n+\treq         *request\n+\theader      http.Header\n+\tw           *bufWriter\n+\twroteHeader bool\n+}\n+\n+func newResponse(c *child, req *request) *response {\n+\treturn &response{\n+\t\treq:    req,\n+\t\theader: http.Header{},\n+\t\tw:      newWriter(c.conn, typeStdout, req.reqId),\n+\t}\n+}\n+\n+func (r *response) Header() http.Header {\n+\treturn r.header\n+}\n+\n+func (r *response) Write(data []byte) (int, os.Error) {\n+\tif !r.wroteHeader {\n+\t\tr.WriteHeader(http.StatusOK)\n+\t}\n+\treturn r.w.Write(data)\n+}\n+\n+func (r *response) WriteHeader(code int) {\n+\tif r.wroteHeader {\n+\t\treturn\n+\t}\n+\tr.wroteHeader = true\n+\tif code == http.StatusNotModified {\n+\t\t// Must not have body.\n+\t\tr.header.Del(\"Content-Type\")\n+\t\tr.header.Del(\"Content-Length\")\n+\t\tr.header.Del(\"Transfer-Encoding\")\n+\t} else if r.header.Get(\"Content-Type\") == \"\" {\n+\t\tr.header.Set(\"Content-Type\", \"text/html; charset=utf-8\")\n+\t}\n+\n+\tif r.header.Get(\"Date\") == \"\" {\n+\t\tr.header.Set(\"Date\", time.UTC().Format(http.TimeFormat))\n+\t}\n+\n+\tfmt.Fprintf(r.w, \"Status: %d %s\\r\\n\", code, http.StatusText(code))\n+\tr.header.Write(r.w)\n+\tr.w.WriteString(\"\\r\\n\")\n+}\n+\n+func (r *response) Flush() {\n+\tif !r.wroteHeader {\n+\t\tr.WriteHeader(http.StatusOK)\n+\t}\n+\tr.w.Flush()\n+}\n+\n+func (r *response) Close() os.Error {\n+\tr.Flush()\n+\treturn r.w.Close()\n+}\n+\n+type child struct {\n+\tconn    *conn\n+\thandler http.Handler\n+}\n+\n+func newChild(rwc net.Conn, handler http.Handler) *child {\n+\treturn &child{newConn(rwc), handler}\n+}\n+\n+func (c *child) serve() {\n+\trequests := map[uint16]*request{}\n+\tdefer c.conn.Close()\n+\tvar rec record\n+\tvar br beginRequest\n+\tfor {\n+\t\tif err := rec.read(c.conn.rwc); err != nil {\n+\t\t\treturn\n+\t\t}\n+\n+\t\treq, ok := requests[rec.h.Id]\n+\t\tif !ok && rec.h.Type != typeBeginRequest && rec.h.Type != typeGetValues {\n+\t\t\t// The spec says to ignore unknown request IDs.\n+\t\t\tcontinue\n+\t\t}\n+\t\tif ok && rec.h.Type == typeBeginRequest {\n+\t\t\t// The server is trying to begin a request with the same ID\n+\t\t\t// as an in-progress request. This is an error.\n+\t\t\treturn\n+\t\t}\n+\n+\t\tswitch rec.h.Type {\n+\t\tcase typeBeginRequest:\n+\t\t\tif err := br.read(rec.content()); err != nil {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif br.role != roleResponder {\n+\t\t\t\tc.conn.writeEndRequest(rec.h.Id, 0, statusUnknownRole)\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\trequests[rec.h.Id] = newRequest(rec.h.Id, br.flags)\n+\t\tcase typeParams:\n+\t\t\t// NOTE(eds): Technically a key-value pair can straddle the boundary\n+\t\t\t// between two packets. We buffer until we've received all parameters.\n+\t\t\tif len(rec.content()) > 0 {\n+\t\t\t\treq.rawParams = append(req.rawParams, rec.content()...)\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\treq.parseParams()\n+\t\tcase typeStdin:\n+\t\t\tcontent := rec.content()\n+\t\t\tif req.pw == nil {\n+\t\t\t\tvar body io.ReadCloser\n+\t\t\t\tif len(content) > 0 {\n+\t\t\t\t\t// body could be an io.LimitReader, but it shouldn't matter\n+\t\t\t\t\t// as long as both sides are behaving.\n+\t\t\t\t\tbody, req.pw = io.Pipe()\n+\t\t\t\t}\n+\t\t\t\tgo c.serveRequest(req, body)\n+\t\t\t}\n+\t\t\tif len(content) > 0 {\n+\t\t\t\t// TODO(eds): This blocks until the handler reads from the pipe.\n+\t\t\t\t// If the handler takes a long time, it might be a problem.\n+\t\t\t\treq.pw.Write(content)\n+\t\t\t} else if req.pw != nil {\n+\t\t\t\treq.pw.Close()\n+\t\t\t}\n+\t\tcase typeGetValues:\n+\t\t\tvalues := map[string]string{\"FCGI_MPXS_CONNS\": \"1\"}\n+\t\t\tc.conn.writePairs(0, typeGetValuesResult, values)\n+\t\tcase typeData:\n+\t\t\t// If the filter role is implemented, read the data stream here.\n+\t\tcase typeAbortRequest:\n+\t\t\trequests[rec.h.Id] = nil, false\n+\t\t\tc.conn.writeEndRequest(rec.h.Id, 0, statusRequestComplete)\n+\t\t\tif !req.keepConn {\n+\t\t\t\t// connection will close upon return\n+\t\t\t\treturn\n+\t\t\t}\n+\t\tdefault:\n+\t\t\tb := make([]byte, 8)\n+\t\t\tb[0] = rec.h.Type\n+\t\t\tc.conn.writeRecord(typeUnknownType, 0, b)\n+\t\t}\n+\t}\n+}\n+\n+func (c *child) serveRequest(req *request, body io.ReadCloser) {\n+\tr := newResponse(c, req)\n+\thttpReq, err := cgi.RequestFromMap(req.params)\n+\tif err != nil {\n+\t\t// there was an error reading the request\n+\t\tr.WriteHeader(http.StatusInternalServerError)\n+\t\tc.conn.writeRecord(typeStderr, req.reqId, []byte(err.String()))\n+\t} else {\n+\t\thttpReq.Body = body\n+\t\tc.handler.ServeHTTP(r, httpReq)\n+\t}\n+\tif body != nil {\n+\t\tbody.Close()\n+\t}\n+\tr.Close()\n+\tc.conn.writeEndRequest(req.reqId, 0, statusRequestComplete)\n+\tif !req.keepConn {\n+\t\tc.conn.Close()\n+\t}\n+}\n+\n+// Serve accepts incoming FastCGI connections on the listener l, creating a new\n+// service thread for each. The service threads read requests and then call handler\n+// to reply to them.\n+// If l is nil, Serve accepts connections on stdin.\n+// If handler is nil, http.DefaultServeMux is used.\n+func Serve(l net.Listener, handler http.Handler) os.Error {\n+\tif l == nil {\n+\t\tvar err os.Error\n+\t\tl, err = net.FileListener(os.Stdin)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tdefer l.Close()\n+\t}\n+\tif handler == nil {\n+\t\thandler = http.DefaultServeMux\n+\t}\n+\tfor {\n+\t\trw, err := l.Accept()\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tc := newChild(rw, handler)\n+\t\tgo c.serve()\n+\t}\n+\tpanic(\"unreachable\")\n+}"}, {"sha": "8e2e1cd3cb3f7460bafc17337af914e79720f8e5", "filename": "libgo/go/http/fcgi/fcgi.go", "status": "added", "additions": 271, "deletions": 0, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Ffcgi%2Ffcgi.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Ffcgi%2Ffcgi.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ffcgi%2Ffcgi.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -0,0 +1,271 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package fcgi implements the FastCGI protocol.\n+// Currently only the responder role is supported.\n+// The protocol is defined at http://www.fastcgi.com/drupal/node/6?q=node/22\n+package fcgi\n+\n+// This file defines the raw protocol and some utilities used by the child and\n+// the host.\n+\n+import (\n+\t\"bufio\"\n+\t\"bytes\"\n+\t\"encoding/binary\"\n+\t\"io\"\n+\t\"os\"\n+\t\"sync\"\n+)\n+\n+const (\n+\t// Packet Types\n+\ttypeBeginRequest = iota + 1\n+\ttypeAbortRequest\n+\ttypeEndRequest\n+\ttypeParams\n+\ttypeStdin\n+\ttypeStdout\n+\ttypeStderr\n+\ttypeData\n+\ttypeGetValues\n+\ttypeGetValuesResult\n+\ttypeUnknownType\n+)\n+\n+// keep the connection between web-server and responder open after request\n+const flagKeepConn = 1\n+\n+const (\n+\tmaxWrite = 65535 // maximum record body\n+\tmaxPad   = 255\n+)\n+\n+const (\n+\troleResponder = iota + 1 // only Responders are implemented.\n+\troleAuthorizer\n+\troleFilter\n+)\n+\n+const (\n+\tstatusRequestComplete = iota\n+\tstatusCantMultiplex\n+\tstatusOverloaded\n+\tstatusUnknownRole\n+)\n+\n+const headerLen = 8\n+\n+type header struct {\n+\tVersion       uint8\n+\tType          uint8\n+\tId            uint16\n+\tContentLength uint16\n+\tPaddingLength uint8\n+\tReserved      uint8\n+}\n+\n+type beginRequest struct {\n+\trole     uint16\n+\tflags    uint8\n+\treserved [5]uint8\n+}\n+\n+func (br *beginRequest) read(content []byte) os.Error {\n+\tif len(content) != 8 {\n+\t\treturn os.NewError(\"fcgi: invalid begin request record\")\n+\t}\n+\tbr.role = binary.BigEndian.Uint16(content)\n+\tbr.flags = content[2]\n+\treturn nil\n+}\n+\n+// for padding so we don't have to allocate all the time\n+// not synchronized because we don't care what the contents are\n+var pad [maxPad]byte\n+\n+func (h *header) init(recType uint8, reqId uint16, contentLength int) {\n+\th.Version = 1\n+\th.Type = recType\n+\th.Id = reqId\n+\th.ContentLength = uint16(contentLength)\n+\th.PaddingLength = uint8(-contentLength & 7)\n+}\n+\n+// conn sends records over rwc\n+type conn struct {\n+\tmutex sync.Mutex\n+\trwc   io.ReadWriteCloser\n+\n+\t// to avoid allocations\n+\tbuf bytes.Buffer\n+\th   header\n+}\n+\n+func newConn(rwc io.ReadWriteCloser) *conn {\n+\treturn &conn{rwc: rwc}\n+}\n+\n+func (c *conn) Close() os.Error {\n+\tc.mutex.Lock()\n+\tdefer c.mutex.Unlock()\n+\treturn c.rwc.Close()\n+}\n+\n+type record struct {\n+\th   header\n+\tbuf [maxWrite + maxPad]byte\n+}\n+\n+func (rec *record) read(r io.Reader) (err os.Error) {\n+\tif err = binary.Read(r, binary.BigEndian, &rec.h); err != nil {\n+\t\treturn err\n+\t}\n+\tif rec.h.Version != 1 {\n+\t\treturn os.NewError(\"fcgi: invalid header version\")\n+\t}\n+\tn := int(rec.h.ContentLength) + int(rec.h.PaddingLength)\n+\tif _, err = io.ReadFull(r, rec.buf[:n]); err != nil {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func (r *record) content() []byte {\n+\treturn r.buf[:r.h.ContentLength]\n+}\n+\n+// writeRecord writes and sends a single record.\n+func (c *conn) writeRecord(recType uint8, reqId uint16, b []byte) os.Error {\n+\tc.mutex.Lock()\n+\tdefer c.mutex.Unlock()\n+\tc.buf.Reset()\n+\tc.h.init(recType, reqId, len(b))\n+\tif err := binary.Write(&c.buf, binary.BigEndian, c.h); err != nil {\n+\t\treturn err\n+\t}\n+\tif _, err := c.buf.Write(b); err != nil {\n+\t\treturn err\n+\t}\n+\tif _, err := c.buf.Write(pad[:c.h.PaddingLength]); err != nil {\n+\t\treturn err\n+\t}\n+\t_, err := c.rwc.Write(c.buf.Bytes())\n+\treturn err\n+}\n+\n+func (c *conn) writeBeginRequest(reqId uint16, role uint16, flags uint8) os.Error {\n+\tb := [8]byte{byte(role >> 8), byte(role), flags}\n+\treturn c.writeRecord(typeBeginRequest, reqId, b[:])\n+}\n+\n+func (c *conn) writeEndRequest(reqId uint16, appStatus int, protocolStatus uint8) os.Error {\n+\tb := make([]byte, 8)\n+\tbinary.BigEndian.PutUint32(b, uint32(appStatus))\n+\tb[4] = protocolStatus\n+\treturn c.writeRecord(typeEndRequest, reqId, b)\n+}\n+\n+func (c *conn) writePairs(recType uint8, reqId uint16, pairs map[string]string) os.Error {\n+\tw := newWriter(c, recType, reqId)\n+\tb := make([]byte, 8)\n+\tfor k, v := range pairs {\n+\t\tn := encodeSize(b, uint32(len(k)))\n+\t\tn += encodeSize(b[n:], uint32(len(k)))\n+\t\tif _, err := w.Write(b[:n]); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif _, err := w.WriteString(k); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif _, err := w.WriteString(v); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\tw.Close()\n+\treturn nil\n+}\n+\n+func readSize(s []byte) (uint32, int) {\n+\tif len(s) == 0 {\n+\t\treturn 0, 0\n+\t}\n+\tsize, n := uint32(s[0]), 1\n+\tif size&(1<<7) != 0 {\n+\t\tif len(s) < 4 {\n+\t\t\treturn 0, 0\n+\t\t}\n+\t\tn = 4\n+\t\tsize = binary.BigEndian.Uint32(s)\n+\t\tsize &^= 1 << 31\n+\t}\n+\treturn size, n\n+}\n+\n+func readString(s []byte, size uint32) string {\n+\tif size > uint32(len(s)) {\n+\t\treturn \"\"\n+\t}\n+\treturn string(s[:size])\n+}\n+\n+func encodeSize(b []byte, size uint32) int {\n+\tif size > 127 {\n+\t\tsize |= 1 << 31\n+\t\tbinary.BigEndian.PutUint32(b, size)\n+\t\treturn 4\n+\t}\n+\tb[0] = byte(size)\n+\treturn 1\n+}\n+\n+// bufWriter encapsulates bufio.Writer but also closes the underlying stream when\n+// Closed.\n+type bufWriter struct {\n+\tcloser io.Closer\n+\t*bufio.Writer\n+}\n+\n+func (w *bufWriter) Close() os.Error {\n+\tif err := w.Writer.Flush(); err != nil {\n+\t\tw.closer.Close()\n+\t\treturn err\n+\t}\n+\treturn w.closer.Close()\n+}\n+\n+func newWriter(c *conn, recType uint8, reqId uint16) *bufWriter {\n+\ts := &streamWriter{c: c, recType: recType, reqId: reqId}\n+\tw, _ := bufio.NewWriterSize(s, maxWrite)\n+\treturn &bufWriter{s, w}\n+}\n+\n+// streamWriter abstracts out the separation of a stream into discrete records.\n+// It only writes maxWrite bytes at a time.\n+type streamWriter struct {\n+\tc       *conn\n+\trecType uint8\n+\treqId   uint16\n+}\n+\n+func (w *streamWriter) Write(p []byte) (int, os.Error) {\n+\tnn := 0\n+\tfor len(p) > 0 {\n+\t\tn := len(p)\n+\t\tif n > maxWrite {\n+\t\t\tn = maxWrite\n+\t\t}\n+\t\tif err := w.c.writeRecord(w.recType, w.reqId, p[:n]); err != nil {\n+\t\t\treturn nn, err\n+\t\t}\n+\t\tnn += n\n+\t\tp = p[n:]\n+\t}\n+\treturn nn, nil\n+}\n+\n+func (w *streamWriter) Close() os.Error {\n+\t// send empty record to close the stream\n+\treturn w.c.writeRecord(w.recType, w.reqId, nil)\n+}"}, {"sha": "16a6243295e4d0d35f817436aeb089aacdb181c4", "filename": "libgo/go/http/fcgi/fcgi_test.go", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Ffcgi%2Ffcgi_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Ffcgi%2Ffcgi_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ffcgi%2Ffcgi_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -0,0 +1,114 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package fcgi\n+\n+import (\n+\t\"bytes\"\n+\t\"io\"\n+\t\"os\"\n+\t\"testing\"\n+)\n+\n+var sizeTests = []struct {\n+\tsize  uint32\n+\tbytes []byte\n+}{\n+\t{0, []byte{0x00}},\n+\t{127, []byte{0x7F}},\n+\t{128, []byte{0x80, 0x00, 0x00, 0x80}},\n+\t{1000, []byte{0x80, 0x00, 0x03, 0xE8}},\n+\t{33554431, []byte{0x81, 0xFF, 0xFF, 0xFF}},\n+}\n+\n+func TestSize(t *testing.T) {\n+\tb := make([]byte, 4)\n+\tfor i, test := range sizeTests {\n+\t\tn := encodeSize(b, test.size)\n+\t\tif !bytes.Equal(b[:n], test.bytes) {\n+\t\t\tt.Errorf(\"%d expected %x, encoded %x\", i, test.bytes, b)\n+\t\t}\n+\t\tsize, n := readSize(test.bytes)\n+\t\tif size != test.size {\n+\t\t\tt.Errorf(\"%d expected %d, read %d\", i, test.size, size)\n+\t\t}\n+\t\tif len(test.bytes) != n {\n+\t\t\tt.Errorf(\"%d did not consume all the bytes\", i)\n+\t\t}\n+\t}\n+}\n+\n+var streamTests = []struct {\n+\tdesc    string\n+\trecType uint8\n+\treqId   uint16\n+\tcontent []byte\n+\traw     []byte\n+}{\n+\t{\"single record\", typeStdout, 1, nil,\n+\t\t[]byte{1, typeStdout, 0, 1, 0, 0, 0, 0},\n+\t},\n+\t// this data will have to be split into two records\n+\t{\"two records\", typeStdin, 300, make([]byte, 66000),\n+\t\tbytes.Join([][]byte{\n+\t\t\t// header for the first record\n+\t\t\t[]byte{1, typeStdin, 0x01, 0x2C, 0xFF, 0xFF, 1, 0},\n+\t\t\tmake([]byte, 65536),\n+\t\t\t// header for the second\n+\t\t\t[]byte{1, typeStdin, 0x01, 0x2C, 0x01, 0xD1, 7, 0},\n+\t\t\tmake([]byte, 472),\n+\t\t\t// header for the empty record\n+\t\t\t[]byte{1, typeStdin, 0x01, 0x2C, 0, 0, 0, 0},\n+\t\t},\n+\t\t\tnil),\n+\t},\n+}\n+\n+type nilCloser struct {\n+\tio.ReadWriter\n+}\n+\n+func (c *nilCloser) Close() os.Error { return nil }\n+\n+func TestStreams(t *testing.T) {\n+\tvar rec record\n+outer:\n+\tfor _, test := range streamTests {\n+\t\tbuf := bytes.NewBuffer(test.raw)\n+\t\tvar content []byte\n+\t\tfor buf.Len() > 0 {\n+\t\t\tif err := rec.read(buf); err != nil {\n+\t\t\t\tt.Errorf(\"%s: error reading record: %v\", test.desc, err)\n+\t\t\t\tcontinue outer\n+\t\t\t}\n+\t\t\tcontent = append(content, rec.content()...)\n+\t\t}\n+\t\tif rec.h.Type != test.recType {\n+\t\t\tt.Errorf(\"%s: got type %d expected %d\", test.desc, rec.h.Type, test.recType)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif rec.h.Id != test.reqId {\n+\t\t\tt.Errorf(\"%s: got request ID %d expected %d\", test.desc, rec.h.Id, test.reqId)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif !bytes.Equal(content, test.content) {\n+\t\t\tt.Errorf(\"%s: read wrong content\", test.desc)\n+\t\t\tcontinue\n+\t\t}\n+\t\tbuf.Reset()\n+\t\tc := newConn(&nilCloser{buf})\n+\t\tw := newWriter(c, test.recType, test.reqId)\n+\t\tif _, err := w.Write(test.content); err != nil {\n+\t\t\tt.Errorf(\"%s: error writing record: %v\", test.desc, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif err := w.Close(); err != nil {\n+\t\t\tt.Errorf(\"%s: error closing stream: %v\", test.desc, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif !bytes.Equal(buf.Bytes(), test.raw) {\n+\t\t\tt.Errorf(\"%s: wrote wrong content\", test.desc)\n+\t\t}\n+\t}\n+}"}, {"sha": "17d5297b82c86614d849a7d9ef33b3a8b13b2c4e", "filename": "libgo/go/http/fs.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Ffs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Ffs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ffs.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -143,7 +143,7 @@ func serveFile(w ResponseWriter, r *Request, name string, redirect bool) {\n \t\t\tn, _ := io.ReadFull(f, buf[:])\n \t\t\tb := buf[:n]\n \t\t\tif isText(b) {\n-\t\t\t\tctype = \"text-plain; charset=utf-8\"\n+\t\t\t\tctype = \"text/plain; charset=utf-8\"\n \t\t\t} else {\n \t\t\t\t// generic binary\n \t\t\t\tctype = \"application/octet-stream\""}, {"sha": "09d0981f26ee6814d1d72f2d1341e38d7909e3f5", "filename": "libgo/go/http/fs_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Ffs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Ffs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ffs_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -104,7 +104,7 @@ func TestServeFileContentType(t *testing.T) {\n \t\t\tt.Errorf(\"Content-Type mismatch: got %q, want %q\", h, want)\n \t\t}\n \t}\n-\tget(\"text-plain; charset=utf-8\")\n+\tget(\"text/plain; charset=utf-8\")\n \toverride = true\n \tget(ctype)\n }"}, {"sha": "95140b01f2a84ddfba3a1c3546b7a5ec848bd9de", "filename": "libgo/go/http/header.go", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fheader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fheader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fheader.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -4,7 +4,14 @@\n \n package http\n \n-import \"net/textproto\"\n+import (\n+\t\"fmt\"\n+\t\"io\"\n+\t\"net/textproto\"\n+\t\"os\"\n+\t\"sort\"\n+\t\"strings\"\n+)\n \n // A Header represents the key-value pairs in an HTTP header.\n type Header map[string][]string\n@@ -35,6 +42,37 @@ func (h Header) Del(key string) {\n \ttextproto.MIMEHeader(h).Del(key)\n }\n \n+// Write writes a header in wire format.\n+func (h Header) Write(w io.Writer) os.Error {\n+\treturn h.WriteSubset(w, nil)\n+}\n+\n+// WriteSubset writes a header in wire format.\n+// If exclude is not nil, keys where exclude[key] == true are not written.\n+func (h Header) WriteSubset(w io.Writer, exclude map[string]bool) os.Error {\n+\tkeys := make([]string, 0, len(h))\n+\tfor k := range h {\n+\t\tif exclude == nil || !exclude[k] {\n+\t\t\tkeys = append(keys, k)\n+\t\t}\n+\t}\n+\tsort.SortStrings(keys)\n+\tfor _, k := range keys {\n+\t\tfor _, v := range h[k] {\n+\t\t\tv = strings.Replace(v, \"\\n\", \" \", -1)\n+\t\t\tv = strings.Replace(v, \"\\r\", \" \", -1)\n+\t\t\tv = strings.TrimSpace(v)\n+\t\t\tif v == \"\" {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif _, err := fmt.Fprintf(w, \"%s: %s\\r\\n\", k, v); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n // CanonicalHeaderKey returns the canonical format of the\n // header key s.  The canonicalization converts the first\n // letter and any letter following a hyphen to upper case;"}, {"sha": "7e24cb069c632a5320c308ae8268929bc7f78b83", "filename": "libgo/go/http/header_test.go", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fheader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fheader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fheader_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -0,0 +1,71 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package http\n+\n+import (\n+\t\"bytes\"\n+\t\"testing\"\n+)\n+\n+var headerWriteTests = []struct {\n+\th        Header\n+\texclude  map[string]bool\n+\texpected string\n+}{\n+\t{Header{}, nil, \"\"},\n+\t{\n+\t\tHeader{\n+\t\t\t\"Content-Type\":   {\"text/html; charset=UTF-8\"},\n+\t\t\t\"Content-Length\": {\"0\"},\n+\t\t},\n+\t\tnil,\n+\t\t\"Content-Length: 0\\r\\nContent-Type: text/html; charset=UTF-8\\r\\n\",\n+\t},\n+\t{\n+\t\tHeader{\n+\t\t\t\"Content-Length\": {\"0\", \"1\", \"2\"},\n+\t\t},\n+\t\tnil,\n+\t\t\"Content-Length: 0\\r\\nContent-Length: 1\\r\\nContent-Length: 2\\r\\n\",\n+\t},\n+\t{\n+\t\tHeader{\n+\t\t\t\"Expires\":          {\"-1\"},\n+\t\t\t\"Content-Length\":   {\"0\"},\n+\t\t\t\"Content-Encoding\": {\"gzip\"},\n+\t\t},\n+\t\tmap[string]bool{\"Content-Length\": true},\n+\t\t\"Content-Encoding: gzip\\r\\nExpires: -1\\r\\n\",\n+\t},\n+\t{\n+\t\tHeader{\n+\t\t\t\"Expires\":          {\"-1\"},\n+\t\t\t\"Content-Length\":   {\"0\", \"1\", \"2\"},\n+\t\t\t\"Content-Encoding\": {\"gzip\"},\n+\t\t},\n+\t\tmap[string]bool{\"Content-Length\": true},\n+\t\t\"Content-Encoding: gzip\\r\\nExpires: -1\\r\\n\",\n+\t},\n+\t{\n+\t\tHeader{\n+\t\t\t\"Expires\":          {\"-1\"},\n+\t\t\t\"Content-Length\":   {\"0\"},\n+\t\t\t\"Content-Encoding\": {\"gzip\"},\n+\t\t},\n+\t\tmap[string]bool{\"Content-Length\": true, \"Expires\": true, \"Content-Encoding\": true},\n+\t\t\"\",\n+\t},\n+}\n+\n+func TestHeaderWrite(t *testing.T) {\n+\tvar buf bytes.Buffer\n+\tfor i, test := range headerWriteTests {\n+\t\ttest.h.WriteSubset(&buf, test.exclude)\n+\t\tif buf.String() != test.expected {\n+\t\t\tt.Errorf(\"#%d:\\n got: %q\\nwant: %q\", i, buf.String(), test.expected)\n+\t\t}\n+\t\tbuf.Reset()\n+\t}\n+}"}, {"sha": "f2fedefcfd1cc5e4ef3c9c3fe78f0bd1ac09d0be", "filename": "libgo/go/http/httptest/recorder.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fhttptest%2Frecorder.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fhttptest%2Frecorder.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fhttptest%2Frecorder.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// The httptest package provides utilities for HTTP testing.\n+// Package httptest provides utilities for HTTP testing.\n package httptest\n \n import ("}, {"sha": "e4eea6815d0afc31b7068462038d23a0955d94de", "filename": "libgo/go/http/persist.go", "status": "modified", "additions": 31, "deletions": 13, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fpersist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fpersist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fpersist.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -20,8 +20,8 @@ var (\n \n // A ServerConn reads requests and sends responses over an underlying\n // connection, until the HTTP keepalive logic commands an end. ServerConn\n-// does not close the underlying connection. Instead, the user calls Close\n-// and regains control over the connection. ServerConn supports pipe-lining,\n+// also allows hijacking the underlying connection by calling Hijack\n+// to regain control over the connection. ServerConn supports pipe-lining,\n // i.e. requests can be read out of sync (but in the same order) while the\n // respective responses are sent.\n type ServerConn struct {\n@@ -45,11 +45,11 @@ func NewServerConn(c net.Conn, r *bufio.Reader) *ServerConn {\n \treturn &ServerConn{c: c, r: r, pipereq: make(map[*Request]uint)}\n }\n \n-// Close detaches the ServerConn and returns the underlying connection as well\n-// as the read-side bufio which may have some left over data. Close may be\n+// Hijack detaches the ServerConn and returns the underlying connection as well\n+// as the read-side bufio which may have some left over data. Hijack may be\n // called before Read has signaled the end of the keep-alive logic. The user\n-// should not call Close while Read or Write is in progress.\n-func (sc *ServerConn) Close() (c net.Conn, r *bufio.Reader) {\n+// should not call Hijack while Read or Write is in progress.\n+func (sc *ServerConn) Hijack() (c net.Conn, r *bufio.Reader) {\n \tsc.lk.Lock()\n \tdefer sc.lk.Unlock()\n \tc = sc.c\n@@ -59,6 +59,15 @@ func (sc *ServerConn) Close() (c net.Conn, r *bufio.Reader) {\n \treturn\n }\n \n+// Close calls Hijack and then also closes the underlying connection\n+func (sc *ServerConn) Close() os.Error {\n+\tc, _ := sc.Hijack()\n+\tif c != nil {\n+\t\treturn c.Close()\n+\t}\n+\treturn nil\n+}\n+\n // Read returns the next request on the wire. An ErrPersistEOF is returned if\n // it is gracefully determined that there are no more requests (e.g. after the\n // first request on an HTTP/1.0 connection, or after a Connection:close on a\n@@ -199,9 +208,9 @@ func (sc *ServerConn) Write(req *Request, resp *Response) os.Error {\n }\n \n // A ClientConn sends request and receives headers over an underlying\n-// connection, while respecting the HTTP keepalive logic. ClientConn is not\n-// responsible for closing the underlying connection. One must call Close to\n-// regain control of that connection and deal with it as desired.\n+// connection, while respecting the HTTP keepalive logic. ClientConn\n+// supports hijacking the connection calling Hijack to\n+// regain control of the underlying net.Conn and deal with it as desired.\n type ClientConn struct {\n \tlk              sync.Mutex // read-write protects the following fields\n \tc               net.Conn\n@@ -239,11 +248,11 @@ func NewProxyClientConn(c net.Conn, r *bufio.Reader) *ClientConn {\n \treturn cc\n }\n \n-// Close detaches the ClientConn and returns the underlying connection as well\n-// as the read-side bufio which may have some left over data. Close may be\n+// Hijack detaches the ClientConn and returns the underlying connection as well\n+// as the read-side bufio which may have some left over data. Hijack may be\n // called before the user or Read have signaled the end of the keep-alive\n-// logic. The user should not call Close while Read or Write is in progress.\n-func (cc *ClientConn) Close() (c net.Conn, r *bufio.Reader) {\n+// logic. The user should not call Hijack while Read or Write is in progress.\n+func (cc *ClientConn) Hijack() (c net.Conn, r *bufio.Reader) {\n \tcc.lk.Lock()\n \tdefer cc.lk.Unlock()\n \tc = cc.c\n@@ -253,6 +262,15 @@ func (cc *ClientConn) Close() (c net.Conn, r *bufio.Reader) {\n \treturn\n }\n \n+// Close calls Hijack and then also closes the underlying connection\n+func (cc *ClientConn) Close() os.Error {\n+\tc, _ := cc.Hijack()\n+\tif c != nil {\n+\t\treturn c.Close()\n+\t}\n+\treturn nil\n+}\n+\n // Write writes a request. An ErrPersistEOF error is returned if the connection\n // has been closed in an HTTP keepalive sense. If req.Close equals true, the\n // keepalive connection is logically closed after this request and the opposing"}, {"sha": "917c7f877a32a5dedd1a40e8de72675b3a20c593", "filename": "libgo/go/http/pprof/pprof.go", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fpprof%2Fpprof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fpprof%2Fpprof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fpprof%2Fpprof.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -26,6 +26,7 @@ package pprof\n \n import (\n \t\"bufio\"\n+\t\"bytes\"\n \t\"fmt\"\n \t\"http\"\n \t\"os\"\n@@ -88,10 +89,14 @@ func Profile(w http.ResponseWriter, r *http.Request) {\n func Symbol(w http.ResponseWriter, r *http.Request) {\n \tw.Header().Set(\"Content-Type\", \"text/plain; charset=utf-8\")\n \n+\t// We have to read the whole POST body before\n+\t// writing any output.  Buffer the output here.\n+\tvar buf bytes.Buffer\n+\n \t// We don't know how many symbols we have, but we\n \t// do have symbol information.  Pprof only cares whether\n \t// this number is 0 (no symbols available) or > 0.\n-\tfmt.Fprintf(w, \"num_symbols: 1\\n\")\n+\tfmt.Fprintf(&buf, \"num_symbols: 1\\n\")\n \n \tvar b *bufio.Reader\n \tif r.Method == \"POST\" {\n@@ -109,14 +114,19 @@ func Symbol(w http.ResponseWriter, r *http.Request) {\n \t\tif pc != 0 {\n \t\t\tf := runtime.FuncForPC(uintptr(pc))\n \t\t\tif f != nil {\n-\t\t\t\tfmt.Fprintf(w, \"%#x %s\\n\", pc, f.Name())\n+\t\t\t\tfmt.Fprintf(&buf, \"%#x %s\\n\", pc, f.Name())\n \t\t\t}\n \t\t}\n \n \t\t// Wait until here to check for err; the last\n \t\t// symbol will have an err because it doesn't end in +.\n \t\tif err != nil {\n+\t\t\tif err != os.EOF {\n+\t\t\t\tfmt.Fprintf(&buf, \"reading request: %v\\n\", err)\n+\t\t\t}\n \t\t\tbreak\n \t\t}\n \t}\n+\n+\tw.Write(buf.Bytes())\n }"}, {"sha": "308bf44b48aec78f161592c0c050976cd97e76a7", "filename": "libgo/go/http/proxy_test.go", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fproxy_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fproxy_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fproxy_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -16,9 +16,15 @@ var UseProxyTests = []struct {\n \thost  string\n \tmatch bool\n }{\n-\t{\"localhost\", false},      // match completely\n+\t// Never proxy localhost:\n+\t{\"localhost:80\", false},\n+\t{\"127.0.0.1\", false},\n+\t{\"127.0.0.2\", false},\n+\t{\"[::1]\", false},\n+\t{\"[::2]\", true}, // not a loopback address\n+\n \t{\"barbaz.net\", false},     // match as .barbaz.net\n-\t{\"foobar.com:443\", false}, // have a port but match \n+\t{\"foobar.com\", false},     // have a port but match \n \t{\"foofoobar.com\", true},   // not match as a part of foobar.com\n \t{\"baz.com\", true},         // not match as a part of barbaz.com\n \t{\"localhost.net\", true},   // not match as suffix of address\n@@ -29,19 +35,16 @@ var UseProxyTests = []struct {\n \n func TestUseProxy(t *testing.T) {\n \toldenv := os.Getenv(\"NO_PROXY\")\n-\tno_proxy := \"foobar.com, .barbaz.net   , localhost\"\n-\tos.Setenv(\"NO_PROXY\", no_proxy)\n \tdefer os.Setenv(\"NO_PROXY\", oldenv)\n \n+\tno_proxy := \"foobar.com, .barbaz.net\"\n+\tos.Setenv(\"NO_PROXY\", no_proxy)\n+\n \ttr := &Transport{}\n \n \tfor _, test := range UseProxyTests {\n-\t\tif tr.useProxy(test.host) != test.match {\n-\t\t\tif test.match {\n-\t\t\t\tt.Errorf(\"useProxy(%v) = %v, want %v\", test.host, !test.match, test.match)\n-\t\t\t} else {\n-\t\t\t\tt.Errorf(\"not expected: '%s' shouldn't match as '%s'\", test.host, no_proxy)\n-\t\t\t}\n+\t\tif tr.useProxy(test.host+\":80\") != test.match {\n+\t\t\tt.Errorf(\"useProxy(%v) = %v, want %v\", test.host, !test.match, test.match)\n \t\t}\n \t}\n }"}, {"sha": "8545d75660a829d5464bd9a38af2cf36e4967089", "filename": "libgo/go/http/request.go", "status": "modified", "additions": 144, "deletions": 18, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Frequest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Frequest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Frequest.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -4,9 +4,8 @@\n \n // HTTP Request reading and parsing.\n \n-// The http package implements parsing of HTTP requests, replies,\n-// and URLs and provides an extensible HTTP server and a basic\n-// HTTP client.\n+// Package http implements parsing of HTTP requests, replies, and URLs and\n+// provides an extensible HTTP server and a basic HTTP client.\n package http\n \n import (\n@@ -25,12 +24,17 @@ import (\n )\n \n const (\n-\tmaxLineLength  = 4096 // assumed <= bufio.defaultBufSize\n-\tmaxValueLength = 4096\n-\tmaxHeaderLines = 1024\n-\tchunkSize      = 4 << 10 // 4 KB chunks\n+\tmaxLineLength    = 4096 // assumed <= bufio.defaultBufSize\n+\tmaxValueLength   = 4096\n+\tmaxHeaderLines   = 1024\n+\tchunkSize        = 4 << 10  // 4 KB chunks\n+\tdefaultMaxMemory = 32 << 20 // 32 MB\n )\n \n+// ErrMissingFile is returned by FormFile when the provided file field name\n+// is either not present in the request or not a file field.\n+var ErrMissingFile = os.ErrorString(\"http: no such file\")\n+\n // HTTP request parsing errors.\n type ProtocolError struct {\n \tos.ErrorString\n@@ -65,9 +69,12 @@ var reqExcludeHeader = map[string]bool{\n \n // A Request represents a parsed HTTP request header.\n type Request struct {\n-\tMethod     string // GET, POST, PUT, etc.\n-\tRawURL     string // The raw URL given in the request.\n-\tURL        *URL   // Parsed URL.\n+\tMethod string // GET, POST, PUT, etc.\n+\tRawURL string // The raw URL given in the request.\n+\tURL    *URL   // Parsed URL.\n+\n+\t// The protocol version for incoming requests.\n+\t// Outgoing requests always use HTTP/1.1.\n \tProto      string // \"HTTP/1.0\"\n \tProtoMajor int    // 1\n \tProtoMinor int    // 0\n@@ -134,6 +141,10 @@ type Request struct {\n \t// The parsed form. Only available after ParseForm is called.\n \tForm map[string][]string\n \n+\t// The parsed multipart form, including file uploads.\n+\t// Only available after ParseMultipartForm is called.\n+\tMultipartForm *multipart.Form\n+\n \t// Trailer maps trailer keys to values.  Like for Header, if the\n \t// response has multiple trailer lines with the same key, they will be\n \t// concatenated, delimited by commas.\n@@ -163,9 +174,30 @@ func (r *Request) ProtoAtLeast(major, minor int) bool {\n \t\tr.ProtoMajor == major && r.ProtoMinor >= minor\n }\n \n+// multipartByReader is a sentinel value.\n+// Its presence in Request.MultipartForm indicates that parsing of the request\n+// body has been handed off to a MultipartReader instead of ParseMultipartFrom.\n+var multipartByReader = &multipart.Form{\n+\tValue: make(map[string][]string),\n+\tFile:  make(map[string][]*multipart.FileHeader),\n+}\n+\n // MultipartReader returns a MIME multipart reader if this is a\n // multipart/form-data POST request, else returns nil and an error.\n+// Use this function instead of ParseMultipartForm to\n+// process the request body as a stream.\n func (r *Request) MultipartReader() (multipart.Reader, os.Error) {\n+\tif r.MultipartForm == multipartByReader {\n+\t\treturn nil, os.NewError(\"http: MultipartReader called twice\")\n+\t}\n+\tif r.MultipartForm != nil {\n+\t\treturn nil, os.NewError(\"http: multipart handled by ParseMultipartForm\")\n+\t}\n+\tr.MultipartForm = multipartByReader\n+\treturn r.multipartReader()\n+}\n+\n+func (r *Request) multipartReader() (multipart.Reader, os.Error) {\n \tv := r.Header.Get(\"Content-Type\")\n \tif v == \"\" {\n \t\treturn nil, ErrNotMultipart\n@@ -199,10 +231,14 @@ const defaultUserAgent = \"Go http package\"\n //\tUserAgent (defaults to defaultUserAgent)\n //\tReferer\n //\tHeader\n+//\tCookie\n+//\tContentLength\n+//\tTransferEncoding\n //\tBody\n //\n-// If Body is present, Write forces \"Transfer-Encoding: chunked\" as a header\n-// and then closes Body when finished sending it.\n+// If Body is present but Content-Length is <= 0, Write adds\n+// \"Transfer-Encoding: chunked\" to the header. Body is closed after\n+// it is sent.\n func (req *Request) Write(w io.Writer) os.Error {\n \treturn req.write(w, false)\n }\n@@ -264,7 +300,7 @@ func (req *Request) write(w io.Writer, usingProxy bool) os.Error {\n \t// from Request, and introduce Request methods along the lines of\n \t// Response.{GetHeader,AddHeader} and string constants for \"Host\",\n \t// \"User-Agent\" and \"Referer\".\n-\terr = writeSortedHeader(w, req.Header, reqExcludeHeader)\n+\terr = req.Header.WriteSubset(w, reqExcludeHeader)\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -420,6 +456,29 @@ func (cr *chunkedReader) Read(b []uint8) (n int, err os.Error) {\n \treturn n, cr.err\n }\n \n+// NewRequest returns a new Request given a method, URL, and optional body.\n+func NewRequest(method, url string, body io.Reader) (*Request, os.Error) {\n+\tu, err := ParseURL(url)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\trc, ok := body.(io.ReadCloser)\n+\tif !ok && body != nil {\n+\t\trc = ioutil.NopCloser(body)\n+\t}\n+\treq := &Request{\n+\t\tMethod:     method,\n+\t\tURL:        u,\n+\t\tProto:      \"HTTP/1.1\",\n+\t\tProtoMajor: 1,\n+\t\tProtoMinor: 1,\n+\t\tHeader:     make(Header),\n+\t\tBody:       rc,\n+\t\tHost:       u.Host,\n+\t}\n+\treturn req, nil\n+}\n+\n // ReadRequest reads and parses a request from b.\n func ReadRequest(b *bufio.Reader) (req *Request, err os.Error) {\n \n@@ -549,7 +608,9 @@ func parseQuery(m map[string][]string, query string) (err os.Error) {\n \treturn err\n }\n \n-// ParseForm parses the request body as a form for POST requests, or the raw query for GET requests.\n+// ParseForm parses the raw query.\n+// For POST requests, it also parses the request body as a form.\n+// ParseMultipartForm calls ParseForm automatically.\n // It is idempotent.\n func (r *Request) ParseForm() (err os.Error) {\n \tif r.Form != nil {\n@@ -567,37 +628,102 @@ func (r *Request) ParseForm() (err os.Error) {\n \t\tct := r.Header.Get(\"Content-Type\")\n \t\tswitch strings.Split(ct, \";\", 2)[0] {\n \t\tcase \"text/plain\", \"application/x-www-form-urlencoded\", \"\":\n-\t\t\tb, e := ioutil.ReadAll(r.Body)\n+\t\t\tconst maxFormSize = int64(10 << 20) // 10 MB is a lot of text.\n+\t\t\tb, e := ioutil.ReadAll(io.LimitReader(r.Body, maxFormSize+1))\n \t\t\tif e != nil {\n \t\t\t\tif err == nil {\n \t\t\t\t\terr = e\n \t\t\t\t}\n \t\t\t\tbreak\n \t\t\t}\n+\t\t\tif int64(len(b)) > maxFormSize {\n+\t\t\t\treturn os.NewError(\"http: POST too large\")\n+\t\t\t}\n \t\t\te = parseQuery(r.Form, string(b))\n \t\t\tif err == nil {\n \t\t\t\terr = e\n \t\t\t}\n-\t\t// TODO(dsymonds): Handle multipart/form-data\n+\t\tcase \"multipart/form-data\":\n+\t\t\t// handled by ParseMultipartForm\n \t\tdefault:\n \t\t\treturn &badStringError{\"unknown Content-Type\", ct}\n \t\t}\n \t}\n \treturn err\n }\n \n+// ParseMultipartForm parses a request body as multipart/form-data.\n+// The whole request body is parsed and up to a total of maxMemory bytes of\n+// its file parts are stored in memory, with the remainder stored on\n+// disk in temporary files.\n+// ParseMultipartForm calls ParseForm if necessary.\n+// After one call to ParseMultipartForm, subsequent calls have no effect.\n+func (r *Request) ParseMultipartForm(maxMemory int64) os.Error {\n+\tif r.Form == nil {\n+\t\terr := r.ParseForm()\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\tif r.MultipartForm != nil {\n+\t\treturn nil\n+\t}\n+\tif r.MultipartForm == multipartByReader {\n+\t\treturn os.NewError(\"http: multipart handled by MultipartReader\")\n+\t}\n+\n+\tmr, err := r.multipartReader()\n+\tif err == ErrNotMultipart {\n+\t\treturn nil\n+\t} else if err != nil {\n+\t\treturn err\n+\t}\n+\n+\tf, err := mr.ReadForm(maxMemory)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tfor k, v := range f.Value {\n+\t\tr.Form[k] = append(r.Form[k], v...)\n+\t}\n+\tr.MultipartForm = f\n+\n+\treturn nil\n+}\n+\n // FormValue returns the first value for the named component of the query.\n-// FormValue calls ParseForm if necessary.\n+// FormValue calls ParseMultipartForm and ParseForm if necessary.\n func (r *Request) FormValue(key string) string {\n \tif r.Form == nil {\n-\t\tr.ParseForm()\n+\t\tr.ParseMultipartForm(defaultMaxMemory)\n \t}\n \tif vs := r.Form[key]; len(vs) > 0 {\n \t\treturn vs[0]\n \t}\n \treturn \"\"\n }\n \n+// FormFile returns the first file for the provided form key.\n+// FormFile calls ParseMultipartForm and ParseForm if necessary.\n+func (r *Request) FormFile(key string) (multipart.File, *multipart.FileHeader, os.Error) {\n+\tif r.MultipartForm == multipartByReader {\n+\t\treturn nil, nil, os.NewError(\"http: multipart handled by MultipartReader\")\n+\t}\n+\tif r.MultipartForm == nil {\n+\t\terr := r.ParseMultipartForm(defaultMaxMemory)\n+\t\tif err != nil {\n+\t\t\treturn nil, nil, err\n+\t\t}\n+\t}\n+\tif r.MultipartForm != nil && r.MultipartForm.File != nil {\n+\t\tif fhs := r.MultipartForm.File[key]; len(fhs) > 0 {\n+\t\t\tf, err := fhs[0].Open()\n+\t\t\treturn f, fhs[0], err\n+\t\t}\n+\t}\n+\treturn nil, nil, ErrMissingFile\n+}\n+\n func (r *Request) expectsContinue() bool {\n \treturn strings.ToLower(r.Header.Get(\"Expect\")) == \"100-continue\"\n }"}, {"sha": "f79d3a24240c390e8a70101c7d1dc9bb92bd09e7", "filename": "libgo/go/http/request_test.go", "status": "modified", "additions": 143, "deletions": 7, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Frequest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Frequest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Frequest_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -10,6 +10,8 @@ import (\n \t. \"http\"\n \t\"http/httptest\"\n \t\"io\"\n+\t\"io/ioutil\"\n+\t\"mime/multipart\"\n \t\"os\"\n \t\"reflect\"\n \t\"regexp\"\n@@ -82,7 +84,7 @@ func TestPostQuery(t *testing.T) {\n \treq.Header = Header{\n \t\t\"Content-Type\": {\"application/x-www-form-urlencoded; boo!\"},\n \t}\n-\treq.Body = nopCloser{strings.NewReader(\"z=post&both=y\")}\n+\treq.Body = ioutil.NopCloser(strings.NewReader(\"z=post&both=y\"))\n \tif q := req.FormValue(\"q\"); q != \"foo\" {\n \t\tt.Errorf(`req.FormValue(\"q\") = %q, want \"foo\"`, q)\n \t}\n@@ -115,7 +117,7 @@ func TestPostContentTypeParsing(t *testing.T) {\n \t\treq := &Request{\n \t\t\tMethod: \"POST\",\n \t\t\tHeader: Header(test.contentType),\n-\t\t\tBody:   nopCloser{bytes.NewBufferString(\"body\")},\n+\t\t\tBody:   ioutil.NopCloser(bytes.NewBufferString(\"body\")),\n \t\t}\n \t\terr := req.ParseForm()\n \t\tif !test.error && err != nil {\n@@ -131,7 +133,7 @@ func TestMultipartReader(t *testing.T) {\n \treq := &Request{\n \t\tMethod: \"POST\",\n \t\tHeader: Header{\"Content-Type\": {`multipart/form-data; boundary=\"foo123\"`}},\n-\t\tBody:   nopCloser{new(bytes.Buffer)},\n+\t\tBody:   ioutil.NopCloser(new(bytes.Buffer)),\n \t}\n \tmultipart, err := req.MultipartReader()\n \tif multipart == nil {\n@@ -170,9 +172,143 @@ func TestRedirect(t *testing.T) {\n \t}\n }\n \n-// TODO: stop copy/pasting this around.  move to io/ioutil?\n-type nopCloser struct {\n-\tio.Reader\n+func TestMultipartRequest(t *testing.T) {\n+\t// Test that we can read the values and files of a \n+\t// multipart request with FormValue and FormFile,\n+\t// and that ParseMultipartForm can be called multiple times.\n+\treq := newTestMultipartRequest(t)\n+\tif err := req.ParseMultipartForm(25); err != nil {\n+\t\tt.Fatal(\"ParseMultipartForm first call:\", err)\n+\t}\n+\tdefer req.MultipartForm.RemoveAll()\n+\tvalidateTestMultipartContents(t, req, false)\n+\tif err := req.ParseMultipartForm(25); err != nil {\n+\t\tt.Fatal(\"ParseMultipartForm second call:\", err)\n+\t}\n+\tvalidateTestMultipartContents(t, req, false)\n+}\n+\n+func TestMultipartRequestAuto(t *testing.T) {\n+\t// Test that FormValue and FormFile automatically invoke\n+\t// ParseMultipartForm and return the right values.\n+\treq := newTestMultipartRequest(t)\n+\tdefer func() {\n+\t\tif req.MultipartForm != nil {\n+\t\t\treq.MultipartForm.RemoveAll()\n+\t\t}\n+\t}()\n+\tvalidateTestMultipartContents(t, req, true)\n+}\n+\n+func TestEmptyMultipartRequest(t *testing.T) {\n+\t// Test that FormValue and FormFile automatically invoke\n+\t// ParseMultipartForm and return the right values.\n+\treq, err := NewRequest(\"GET\", \"/\", nil)\n+\tif err != nil {\n+\t\tt.Errorf(\"NewRequest err = %q\", err)\n+\t}\n+\ttestMissingFile(t, req)\n+}\n+\n+func testMissingFile(t *testing.T, req *Request) {\n+\tf, fh, err := req.FormFile(\"missing\")\n+\tif f != nil {\n+\t\tt.Errorf(\"FormFile file = %q, want nil\", f, nil)\n+\t}\n+\tif fh != nil {\n+\t\tt.Errorf(\"FormFile file header = %q, want nil\", fh, nil)\n+\t}\n+\tif err != ErrMissingFile {\n+\t\tt.Errorf(\"FormFile err = %q, want nil\", err, ErrMissingFile)\n+\t}\n }\n \n-func (nopCloser) Close() os.Error { return nil }\n+func newTestMultipartRequest(t *testing.T) *Request {\n+\tb := bytes.NewBufferString(strings.Replace(message, \"\\n\", \"\\r\\n\", -1))\n+\treq, err := NewRequest(\"POST\", \"/\", b)\n+\tif err != nil {\n+\t\tt.Fatalf(\"NewRequest:\", err)\n+\t}\n+\tctype := fmt.Sprintf(`multipart/form-data; boundary=\"%s\"`, boundary)\n+\treq.Header.Set(\"Content-type\", ctype)\n+\treturn req\n+}\n+\n+func validateTestMultipartContents(t *testing.T, req *Request, allMem bool) {\n+\tif g, e := req.FormValue(\"texta\"), textaValue; g != e {\n+\t\tt.Errorf(\"texta value = %q, want %q\", g, e)\n+\t}\n+\tif g, e := req.FormValue(\"texta\"), textaValue; g != e {\n+\t\tt.Errorf(\"texta value = %q, want %q\", g, e)\n+\t}\n+\tif g := req.FormValue(\"missing\"); g != \"\" {\n+\t\tt.Errorf(\"missing value = %q, want empty string\", g)\n+\t}\n+\n+\tassertMem := func(n string, fd multipart.File) {\n+\t\tif _, ok := fd.(*os.File); ok {\n+\t\t\tt.Error(n, \" is *os.File, should not be\")\n+\t\t}\n+\t}\n+\tfd := testMultipartFile(t, req, \"filea\", \"filea.txt\", fileaContents)\n+\tassertMem(\"filea\", fd)\n+\tfd = testMultipartFile(t, req, \"fileb\", \"fileb.txt\", filebContents)\n+\tif allMem {\n+\t\tassertMem(\"fileb\", fd)\n+\t} else {\n+\t\tif _, ok := fd.(*os.File); !ok {\n+\t\t\tt.Errorf(\"fileb has unexpected underlying type %T\", fd)\n+\t\t}\n+\t}\n+\n+\ttestMissingFile(t, req)\n+}\n+\n+func testMultipartFile(t *testing.T, req *Request, key, expectFilename, expectContent string) multipart.File {\n+\tf, fh, err := req.FormFile(key)\n+\tif err != nil {\n+\t\tt.Fatalf(\"FormFile(%q):\", key, err)\n+\t}\n+\tif fh.Filename != expectFilename {\n+\t\tt.Errorf(\"filename = %q, want %q\", fh.Filename, expectFilename)\n+\t}\n+\tvar b bytes.Buffer\n+\t_, err = io.Copy(&b, f)\n+\tif err != nil {\n+\t\tt.Fatal(\"copying contents:\", err)\n+\t}\n+\tif g := b.String(); g != expectContent {\n+\t\tt.Errorf(\"contents = %q, want %q\", g, expectContent)\n+\t}\n+\treturn f\n+}\n+\n+const (\n+\tfileaContents = \"This is a test file.\"\n+\tfilebContents = \"Another test file.\"\n+\ttextaValue    = \"foo\"\n+\ttextbValue    = \"bar\"\n+\tboundary      = `MyBoundary`\n+)\n+\n+const message = `\n+--MyBoundary\n+Content-Disposition: form-data; name=\"filea\"; filename=\"filea.txt\"\n+Content-Type: text/plain\n+\n+` + fileaContents + `\n+--MyBoundary\n+Content-Disposition: form-data; name=\"fileb\"; filename=\"fileb.txt\"\n+Content-Type: text/plain\n+\n+` + filebContents + `\n+--MyBoundary\n+Content-Disposition: form-data; name=\"texta\"\n+\n+` + textaValue + `\n+--MyBoundary\n+Content-Disposition: form-data; name=\"textb\"\n+\n+` + textbValue + `\n+--MyBoundary--\n+`"}, {"sha": "bb000c701ff5b48c65ab6f35e6d4744ece0772bd", "filename": "libgo/go/http/requestwrite_test.go", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Frequestwrite_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Frequestwrite_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Frequestwrite_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -6,7 +6,10 @@ package http\n \n import (\n \t\"bytes\"\n+\t\"io\"\n \t\"io/ioutil\"\n+\t\"os\"\n+\t\"strings\"\n \t\"testing\"\n )\n \n@@ -133,6 +136,41 @@ var reqWriteTests = []reqWriteTest{\n \t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\" +\n \t\t\t\"6\\r\\nabcdef\\r\\n0\\r\\n\\r\\n\",\n \t},\n+\n+\t// HTTP/1.1 POST with Content-Length, no chunking\n+\t{\n+\t\tRequest{\n+\t\t\tMethod: \"POST\",\n+\t\t\tURL: &URL{\n+\t\t\t\tScheme: \"http\",\n+\t\t\t\tHost:   \"www.google.com\",\n+\t\t\t\tPath:   \"/search\",\n+\t\t\t},\n+\t\t\tProtoMajor:    1,\n+\t\t\tProtoMinor:    1,\n+\t\t\tHeader:        Header{},\n+\t\t\tClose:         true,\n+\t\t\tContentLength: 6,\n+\t\t},\n+\n+\t\t[]byte(\"abcdef\"),\n+\n+\t\t\"POST /search HTTP/1.1\\r\\n\" +\n+\t\t\t\"Host: www.google.com\\r\\n\" +\n+\t\t\t\"User-Agent: Go http package\\r\\n\" +\n+\t\t\t\"Connection: close\\r\\n\" +\n+\t\t\t\"Content-Length: 6\\r\\n\" +\n+\t\t\t\"\\r\\n\" +\n+\t\t\t\"abcdef\",\n+\n+\t\t\"POST http://www.google.com/search HTTP/1.1\\r\\n\" +\n+\t\t\t\"User-Agent: Go http package\\r\\n\" +\n+\t\t\t\"Connection: close\\r\\n\" +\n+\t\t\t\"Content-Length: 6\\r\\n\" +\n+\t\t\t\"\\r\\n\" +\n+\t\t\t\"abcdef\",\n+\t},\n+\n \t// default to HTTP/1.1\n \t{\n \t\tRequest{\n@@ -189,3 +227,26 @@ func TestRequestWrite(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+type closeChecker struct {\n+\tio.Reader\n+\tclosed bool\n+}\n+\n+func (rc *closeChecker) Close() os.Error {\n+\trc.closed = true\n+\treturn nil\n+}\n+\n+// TestRequestWriteClosesBody tests that Request.Write does close its request.Body.\n+// It also indirectly tests NewRequest and that it doesn't wrap an existing Closer\n+// inside a NopCloser.\n+func TestRequestWriteClosesBody(t *testing.T) {\n+\trc := &closeChecker{Reader: strings.NewReader(\"my body\")}\n+\treq, _ := NewRequest(\"GET\", \"http://foo.com/\", rc)\n+\tbuf := new(bytes.Buffer)\n+\treq.Write(buf)\n+\tif !rc.closed {\n+\t\tt.Error(\"body not closed after write\")\n+\t}\n+}"}, {"sha": "a65c2b14df6fa171563ab832b8670169e9a5daf7", "filename": "libgo/go/http/response.go", "status": "modified", "additions": 1, "deletions": 27, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fresponse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fresponse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fresponse.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -8,11 +8,9 @@ package http\n \n import (\n \t\"bufio\"\n-\t\"fmt\"\n \t\"io\"\n \t\"net/textproto\"\n \t\"os\"\n-\t\"sort\"\n \t\"strconv\"\n \t\"strings\"\n )\n@@ -192,7 +190,7 @@ func (resp *Response) Write(w io.Writer) os.Error {\n \t}\n \n \t// Rest of header\n-\terr = writeSortedHeader(w, resp.Header, respExcludeHeader)\n+\terr = resp.Header.WriteSubset(w, respExcludeHeader)\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -213,27 +211,3 @@ func (resp *Response) Write(w io.Writer) os.Error {\n \t// Success\n \treturn nil\n }\n-\n-func writeSortedHeader(w io.Writer, h Header, exclude map[string]bool) os.Error {\n-\tkeys := make([]string, 0, len(h))\n-\tfor k := range h {\n-\t\tif exclude == nil || !exclude[k] {\n-\t\t\tkeys = append(keys, k)\n-\t\t}\n-\t}\n-\tsort.SortStrings(keys)\n-\tfor _, k := range keys {\n-\t\tfor _, v := range h[k] {\n-\t\t\tv = strings.Replace(v, \"\\n\", \" \", -1)\n-\t\t\tv = strings.Replace(v, \"\\r\", \" \", -1)\n-\t\t\tv = strings.TrimSpace(v)\n-\t\t\tif v == \"\" {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tif _, err := fmt.Fprintf(w, \"%s: %s\\r\\n\", k, v); err != nil {\n-\t\t\t\treturn err\n-\t\t\t}\n-\t\t}\n-\t}\n-\treturn nil\n-}"}, {"sha": "9e77c20c40b72be1afd3fc634418d6b3d8fa45e6", "filename": "libgo/go/http/response_test.go", "status": "modified", "additions": 132, "deletions": 5, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fresponse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fresponse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fresponse_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -7,8 +7,12 @@ package http\n import (\n \t\"bufio\"\n \t\"bytes\"\n+\t\"compress/gzip\"\n+\t\"crypto/rand\"\n \t\"fmt\"\n+\t\"os\"\n \t\"io\"\n+\t\"io/ioutil\"\n \t\"reflect\"\n \t\"testing\"\n )\n@@ -117,7 +121,9 @@ var respTests = []respTest{\n \t\t\t\"Transfer-Encoding: chunked\\r\\n\" +\n \t\t\t\"\\r\\n\" +\n \t\t\t\"0a\\r\\n\" +\n-\t\t\t\"Body here\\n\" +\n+\t\t\t\"Body here\\n\\r\\n\" +\n+\t\t\t\"09\\r\\n\" +\n+\t\t\t\"continued\\r\\n\" +\n \t\t\t\"0\\r\\n\" +\n \t\t\t\"\\r\\n\",\n \n@@ -134,7 +140,7 @@ var respTests = []respTest{\n \t\t\tTransferEncoding: []string{\"chunked\"},\n \t\t},\n \n-\t\t\"Body here\\n\",\n+\t\t\"Body here\\ncontinued\",\n \t},\n \n \t// Chunked response with Content-Length.\n@@ -186,6 +192,29 @@ var respTests = []respTest{\n \t\t\"\",\n \t},\n \n+\t// explicit Content-Length of 0.\n+\t{\n+\t\t\"HTTP/1.1 200 OK\\r\\n\" +\n+\t\t\t\"Content-Length: 0\\r\\n\" +\n+\t\t\t\"\\r\\n\",\n+\n+\t\tResponse{\n+\t\t\tStatus:        \"200 OK\",\n+\t\t\tStatusCode:    200,\n+\t\t\tProto:         \"HTTP/1.1\",\n+\t\t\tProtoMajor:    1,\n+\t\t\tProtoMinor:    1,\n+\t\t\tRequestMethod: \"GET\",\n+\t\t\tHeader: Header{\n+\t\t\t\t\"Content-Length\": {\"0\"},\n+\t\t\t},\n+\t\t\tClose:         false,\n+\t\t\tContentLength: 0,\n+\t\t},\n+\n+\t\t\"\",\n+\t},\n+\n \t// Status line without a Reason-Phrase, but trailing space.\n \t// (permitted by RFC 2616)\n \t{\n@@ -250,17 +279,115 @@ func TestReadResponse(t *testing.T) {\n \t}\n }\n \n+var readResponseCloseInMiddleTests = []struct {\n+\tchunked, compressed bool\n+}{\n+\t{false, false},\n+\t{true, false},\n+\t{true, true},\n+}\n+\n+// TestReadResponseCloseInMiddle tests that closing a body after\n+// reading only part of its contents advances the read to the end of\n+// the request, right up until the next request.\n+func TestReadResponseCloseInMiddle(t *testing.T) {\n+\tfor _, test := range readResponseCloseInMiddleTests {\n+\t\tfatalf := func(format string, args ...interface{}) {\n+\t\t\targs = append([]interface{}{test.chunked, test.compressed}, args...)\n+\t\t\tt.Fatalf(\"on test chunked=%v, compressed=%v: \"+format, args...)\n+\t\t}\n+\t\tcheckErr := func(err os.Error, msg string) {\n+\t\t\tif err == nil {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tfatalf(msg+\": %v\", err)\n+\t\t}\n+\t\tvar buf bytes.Buffer\n+\t\tbuf.WriteString(\"HTTP/1.1 200 OK\\r\\n\")\n+\t\tif test.chunked {\n+\t\t\tbuf.WriteString(\"Transfer-Encoding: chunked\\r\\n\")\n+\t\t} else {\n+\t\t\tbuf.WriteString(\"Content-Length: 1000000\\r\\n\")\n+\t\t}\n+\t\tvar wr io.Writer = &buf\n+\t\tif test.chunked {\n+\t\t\twr = &chunkedWriter{wr}\n+\t\t}\n+\t\tif test.compressed {\n+\t\t\tbuf.WriteString(\"Content-Encoding: gzip\\r\\n\")\n+\t\t\tvar err os.Error\n+\t\t\twr, err = gzip.NewWriter(wr)\n+\t\t\tcheckErr(err, \"gzip.NewWriter\")\n+\t\t}\n+\t\tbuf.WriteString(\"\\r\\n\")\n+\n+\t\tchunk := bytes.Repeat([]byte{'x'}, 1000)\n+\t\tfor i := 0; i < 1000; i++ {\n+\t\t\tif test.compressed {\n+\t\t\t\t// Otherwise this compresses too well.\n+\t\t\t\t_, err := io.ReadFull(rand.Reader, chunk)\n+\t\t\t\tcheckErr(err, \"rand.Reader ReadFull\")\n+\t\t\t}\n+\t\t\twr.Write(chunk)\n+\t\t}\n+\t\tif test.compressed {\n+\t\t\terr := wr.(*gzip.Compressor).Close()\n+\t\t\tcheckErr(err, \"compressor close\")\n+\t\t}\n+\t\tif test.chunked {\n+\t\t\tbuf.WriteString(\"0\\r\\n\\r\\n\")\n+\t\t}\n+\t\tbuf.WriteString(\"Next Request Here\")\n+\n+\t\tbufr := bufio.NewReader(&buf)\n+\t\tresp, err := ReadResponse(bufr, \"GET\")\n+\t\tcheckErr(err, \"ReadResponse\")\n+\t\texpectedLength := int64(-1)\n+\t\tif !test.chunked {\n+\t\t\texpectedLength = 1000000\n+\t\t}\n+\t\tif resp.ContentLength != expectedLength {\n+\t\t\tfatalf(\"expected response length %d, got %d\", expectedLength, resp.ContentLength)\n+\t\t}\n+\t\tif resp.Body == nil {\n+\t\t\tfatalf(\"nil body\")\n+\t\t}\n+\t\tif test.compressed {\n+\t\t\tgzReader, err := gzip.NewReader(resp.Body)\n+\t\t\tcheckErr(err, \"gzip.NewReader\")\n+\t\t\tresp.Body = &readFirstCloseBoth{gzReader, resp.Body}\n+\t\t}\n+\n+\t\trbuf := make([]byte, 2500)\n+\t\tn, err := io.ReadFull(resp.Body, rbuf)\n+\t\tcheckErr(err, \"2500 byte ReadFull\")\n+\t\tif n != 2500 {\n+\t\t\tfatalf(\"ReadFull only read %d bytes\", n)\n+\t\t}\n+\t\tif test.compressed == false && !bytes.Equal(bytes.Repeat([]byte{'x'}, 2500), rbuf) {\n+\t\t\tfatalf(\"ReadFull didn't read 2500 'x'; got %q\", string(rbuf))\n+\t\t}\n+\t\tresp.Body.Close()\n+\n+\t\trest, err := ioutil.ReadAll(bufr)\n+\t\tcheckErr(err, \"ReadAll on remainder\")\n+\t\tif e, g := \"Next Request Here\", string(rest); e != g {\n+\t\t\tfatalf(\"for chunked=%v remainder = %q, expected %q\", g, e)\n+\t\t}\n+\t}\n+}\n+\n func diff(t *testing.T, prefix string, have, want interface{}) {\n-\thv := reflect.NewValue(have).(*reflect.PtrValue).Elem().(*reflect.StructValue)\n-\twv := reflect.NewValue(want).(*reflect.PtrValue).Elem().(*reflect.StructValue)\n+\thv := reflect.ValueOf(have).Elem()\n+\twv := reflect.ValueOf(want).Elem()\n \tif hv.Type() != wv.Type() {\n \t\tt.Errorf(\"%s: type mismatch %v vs %v\", prefix, hv.Type(), wv.Type())\n \t}\n \tfor i := 0; i < hv.NumField(); i++ {\n \t\thf := hv.Field(i).Interface()\n \t\twf := wv.Field(i).Interface()\n \t\tif !reflect.DeepEqual(hf, wf) {\n-\t\t\tt.Errorf(\"%s: %s = %v want %v\", prefix, hv.Type().(*reflect.StructType).Field(i).Name, hf, wf)\n+\t\t\tt.Errorf(\"%s: %s = %v want %v\", prefix, hv.Type().Field(i).Name, hf, wf)\n \t\t}\n \t}\n }"}, {"sha": "e4ce1e34c79b54081237817a5b1949fe21204407", "filename": "libgo/go/http/reverseproxy.go", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Freverseproxy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Freverseproxy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Freverseproxy.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -0,0 +1,100 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// HTTP reverse proxy handler\n+\n+package http\n+\n+import (\n+\t\"io\"\n+\t\"log\"\n+\t\"net\"\n+\t\"strings\"\n+)\n+\n+// ReverseProxy is an HTTP Handler that takes an incoming request and\n+// sends it to another server, proxying the response back to the\n+// client.\n+type ReverseProxy struct {\n+\t// Director must be a function which modifies\n+\t// the request into a new request to be sent\n+\t// using Transport. Its response is then copied\n+\t// back to the original client unmodified.\n+\tDirector func(*Request)\n+\n+\t// The Transport used to perform proxy requests.\n+\t// If nil, DefaultTransport is used.\n+\tTransport RoundTripper\n+}\n+\n+func singleJoiningSlash(a, b string) string {\n+\taslash := strings.HasSuffix(a, \"/\")\n+\tbslash := strings.HasPrefix(b, \"/\")\n+\tswitch {\n+\tcase aslash && bslash:\n+\t\treturn a + b[1:]\n+\tcase !aslash && !bslash:\n+\t\treturn a + \"/\" + b\n+\t}\n+\treturn a + b\n+}\n+\n+// NewSingleHostReverseProxy returns a new ReverseProxy that rewrites\n+// URLs to the scheme, host, and base path provided in target. If the\n+// target's path is \"/base\" and the incoming request was for \"/dir\",\n+// the target request will be for /base/dir.\n+func NewSingleHostReverseProxy(target *URL) *ReverseProxy {\n+\tdirector := func(req *Request) {\n+\t\treq.URL.Scheme = target.Scheme\n+\t\treq.URL.Host = target.Host\n+\t\treq.URL.Path = singleJoiningSlash(target.Path, req.URL.Path)\n+\t\tif q := req.URL.RawQuery; q != \"\" {\n+\t\t\treq.URL.RawPath = req.URL.Path + \"?\" + q\n+\t\t} else {\n+\t\t\treq.URL.RawPath = req.URL.Path\n+\t\t}\n+\t\treq.URL.RawQuery = target.RawQuery\n+\t}\n+\treturn &ReverseProxy{Director: director}\n+}\n+\n+func (p *ReverseProxy) ServeHTTP(rw ResponseWriter, req *Request) {\n+\ttransport := p.Transport\n+\tif transport == nil {\n+\t\ttransport = DefaultTransport\n+\t}\n+\n+\toutreq := new(Request)\n+\t*outreq = *req // includes shallow copies of maps, but okay\n+\n+\tp.Director(outreq)\n+\toutreq.Proto = \"HTTP/1.1\"\n+\toutreq.ProtoMajor = 1\n+\toutreq.ProtoMinor = 1\n+\toutreq.Close = false\n+\n+\tif clientIp, _, err := net.SplitHostPort(req.RemoteAddr); err == nil {\n+\t\toutreq.Header.Set(\"X-Forwarded-For\", clientIp)\n+\t}\n+\n+\tres, err := transport.RoundTrip(outreq)\n+\tif err != nil {\n+\t\tlog.Printf(\"http: proxy error: %v\", err)\n+\t\trw.WriteHeader(StatusInternalServerError)\n+\t\treturn\n+\t}\n+\n+\thdr := rw.Header()\n+\tfor k, vv := range res.Header {\n+\t\tfor _, v := range vv {\n+\t\t\thdr.Add(k, v)\n+\t\t}\n+\t}\n+\n+\trw.WriteHeader(res.StatusCode)\n+\n+\tif res.Body != nil {\n+\t\tio.Copy(rw, res.Body)\n+\t}\n+}"}, {"sha": "8cf7705d74553610f14497d1eb800b3b996b32fe", "filename": "libgo/go/http/reverseproxy_test.go", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Freverseproxy_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Freverseproxy_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Freverseproxy_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Reverse proxy tests.\n+\n+package http_test\n+\n+import (\n+\t. \"http\"\n+\t\"http/httptest\"\n+\t\"io/ioutil\"\n+\t\"testing\"\n+)\n+\n+func TestReverseProxy(t *testing.T) {\n+\tconst backendResponse = \"I am the backend\"\n+\tconst backendStatus = 404\n+\tbackend := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n+\t\tif r.Header.Get(\"X-Forwarded-For\") == \"\" {\n+\t\t\tt.Errorf(\"didn't get X-Forwarded-For header\")\n+\t\t}\n+\t\tw.Header().Set(\"X-Foo\", \"bar\")\n+\t\tw.WriteHeader(backendStatus)\n+\t\tw.Write([]byte(backendResponse))\n+\t}))\n+\tdefer backend.Close()\n+\tbackendURL, err := ParseURL(backend.URL)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tproxyHandler := NewSingleHostReverseProxy(backendURL)\n+\tfrontend := httptest.NewServer(proxyHandler)\n+\tdefer frontend.Close()\n+\n+\tres, _, err := Get(frontend.URL)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Get: %v\", err)\n+\t}\n+\tif g, e := res.StatusCode, backendStatus; g != e {\n+\t\tt.Errorf(\"got res.StatusCode %d; expected %d\", g, e)\n+\t}\n+\tif g, e := res.Header.Get(\"X-Foo\"), \"bar\"; g != e {\n+\t\tt.Errorf(\"got X-Foo %q; expected %q\", g, e)\n+\t}\n+\tbodyBytes, _ := ioutil.ReadAll(res.Body)\n+\tif g, e := string(bodyBytes), backendResponse; g != e {\n+\t\tt.Errorf(\"got body %q; expected %q\", g, e)\n+\t}\n+}"}, {"sha": "7ff6ef04b1af78a241e8f2064a24b187764442fd", "filename": "libgo/go/http/serve_test.go", "status": "modified", "additions": 162, "deletions": 3, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fserve_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fserve_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fserve_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -231,7 +231,7 @@ func TestMuxRedirectLeadingSlashes(t *testing.T) {\n \n func TestServerTimeouts(t *testing.T) {\n \t// TODO(bradfitz): convert this to use httptest.Server\n-\tl, err := net.ListenTCP(\"tcp\", &net.TCPAddr{Port: 0})\n+\tl, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n \tif err != nil {\n \t\tt.Fatalf(\"listen error: %v\", err)\n \t}\n@@ -247,7 +247,7 @@ func TestServerTimeouts(t *testing.T) {\n \tserver := &Server{Handler: handler, ReadTimeout: 0.25 * second, WriteTimeout: 0.25 * second}\n \tgo server.Serve(l)\n \n-\turl := fmt.Sprintf(\"http://localhost:%d/\", addr.Port)\n+\turl := fmt.Sprintf(\"http://%s/\", addr)\n \n \t// Hit the HTTP server successfully.\n \ttr := &Transport{DisableKeepAlives: true} // they interfere with this test\n@@ -265,7 +265,7 @@ func TestServerTimeouts(t *testing.T) {\n \n \t// Slow client that should timeout.\n \tt1 := time.Nanoseconds()\n-\tconn, err := net.Dial(\"tcp\", fmt.Sprintf(\"localhost:%d\", addr.Port))\n+\tconn, err := net.Dial(\"tcp\", addr.String())\n \tif err != nil {\n \t\tt.Fatalf(\"Dial: %v\", err)\n \t}\n@@ -534,3 +534,162 @@ func TestTLSServer(t *testing.T) {\n \t\tt.Errorf(\"expected body %q; got %q\", e, g)\n \t}\n }\n+\n+type serverExpectTest struct {\n+\tcontentLength    int    // of request body\n+\texpectation      string // e.g. \"100-continue\"\n+\treadBody         bool   // whether handler should read the body (if false, sends StatusUnauthorized)\n+\texpectedResponse string // expected substring in first line of http response\n+}\n+\n+var serverExpectTests = []serverExpectTest{\n+\t// Normal 100-continues, case-insensitive.\n+\t{100, \"100-continue\", true, \"100 Continue\"},\n+\t{100, \"100-cOntInUE\", true, \"100 Continue\"},\n+\n+\t// No 100-continue.\n+\t{100, \"\", true, \"200 OK\"},\n+\n+\t// 100-continue but requesting client to deny us,\n+\t// so it never eads the body.\n+\t{100, \"100-continue\", false, \"401 Unauthorized\"},\n+\t// Likewise without 100-continue:\n+\t{100, \"\", false, \"401 Unauthorized\"},\n+\n+\t// Non-standard expectations are failures\n+\t{0, \"a-pony\", false, \"417 Expectation Failed\"},\n+\n+\t// Expect-100 requested but no body\n+\t{0, \"100-continue\", true, \"400 Bad Request\"},\n+}\n+\n+// Tests that the server responds to the \"Expect\" request header\n+// correctly.\n+func TestServerExpect(t *testing.T) {\n+\tts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n+\t\t// Note using r.FormValue(\"readbody\") because for POST\n+\t\t// requests that would read from r.Body, which we only\n+\t\t// conditionally want to do.\n+\t\tif strings.Contains(r.URL.RawPath, \"readbody=true\") {\n+\t\t\tioutil.ReadAll(r.Body)\n+\t\t\tw.Write([]byte(\"Hi\"))\n+\t\t} else {\n+\t\t\tw.WriteHeader(StatusUnauthorized)\n+\t\t}\n+\t}))\n+\tdefer ts.Close()\n+\n+\trunTest := func(test serverExpectTest) {\n+\t\tconn, err := net.Dial(\"tcp\", ts.Listener.Addr().String())\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"Dial: %v\", err)\n+\t\t}\n+\t\tdefer conn.Close()\n+\t\tsendf := func(format string, args ...interface{}) {\n+\t\t\t_, err := fmt.Fprintf(conn, format, args...)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"On test %#v, error writing %q: %v\", test, format, err)\n+\t\t\t}\n+\t\t}\n+\t\tgo func() {\n+\t\t\tsendf(\"POST /?readbody=%v HTTP/1.1\\r\\n\"+\n+\t\t\t\t\"Connection: close\\r\\n\"+\n+\t\t\t\t\"Content-Length: %d\\r\\n\"+\n+\t\t\t\t\"Expect: %s\\r\\nHost: foo\\r\\n\\r\\n\",\n+\t\t\t\ttest.readBody, test.contentLength, test.expectation)\n+\t\t\tif test.contentLength > 0 && strings.ToLower(test.expectation) != \"100-continue\" {\n+\t\t\t\tbody := strings.Repeat(\"A\", test.contentLength)\n+\t\t\t\tsendf(body)\n+\t\t\t}\n+\t\t}()\n+\t\tbufr := bufio.NewReader(conn)\n+\t\tline, err := bufr.ReadString('\\n')\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"ReadString: %v\", err)\n+\t\t}\n+\t\tif !strings.Contains(line, test.expectedResponse) {\n+\t\t\tt.Errorf(\"for test %#v got first line=%q\", test, line)\n+\t\t}\n+\t}\n+\n+\tfor _, test := range serverExpectTests {\n+\t\trunTest(test)\n+\t}\n+}\n+\n+func TestServerConsumesRequestBody(t *testing.T) {\n+\tconn := new(testConn)\n+\tbody := strings.Repeat(\"x\", 1<<20)\n+\tconn.readBuf.Write([]byte(fmt.Sprintf(\n+\t\t\"POST / HTTP/1.1\\r\\n\"+\n+\t\t\t\"Host: test\\r\\n\"+\n+\t\t\t\"Content-Length: %d\\r\\n\"+\n+\t\t\t\"\\r\\n\",len(body))))\n+\tconn.readBuf.Write([]byte(body))\n+\n+\tdone := make(chan bool)\n+\n+\tls := &oneConnListener{conn}\n+\tgo Serve(ls, HandlerFunc(func(rw ResponseWriter, req *Request) {\n+\t\tif conn.readBuf.Len() < len(body)/2 {\n+\t\t\tt.Errorf(\"on request, read buffer length is %d; expected about 1MB\", conn.readBuf.Len())\n+\t\t}\n+\t\trw.WriteHeader(200)\n+\t\tif g, e := conn.readBuf.Len(), 0; g != e {\n+\t\t\tt.Errorf(\"after WriteHeader, read buffer length is %d; want %d\", g, e)\n+\t\t}\n+\t\tdone <- true\n+\t}))\n+\t<-done\n+}\n+\n+func TestTimeoutHandler(t *testing.T) {\n+\tsendHi := make(chan bool, 1)\n+\twriteErrors := make(chan os.Error, 1)\n+\tsayHi := HandlerFunc(func(w ResponseWriter, r *Request) {\n+\t\t<-sendHi\n+\t\t_, werr := w.Write([]byte(\"hi\"))\n+\t\twriteErrors <- werr\n+\t})\n+\ttimeout := make(chan int64, 1) // write to this to force timeouts\n+\tts := httptest.NewServer(NewTestTimeoutHandler(sayHi, timeout))\n+\tdefer ts.Close()\n+\n+\t// Succeed without timing out:\n+\tsendHi <- true\n+\tres, _, err := Get(ts.URL)\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t}\n+\tif g, e := res.StatusCode, StatusOK; g != e {\n+\t\tt.Errorf(\"got res.StatusCode %d; expected %d\", g, e)\n+\t}\n+\tbody, _ := ioutil.ReadAll(res.Body)\n+\tif g, e := string(body), \"hi\"; g != e {\n+\t\tt.Errorf(\"got body %q; expected %q\", g, e)\n+\t}\n+\tif g := <-writeErrors; g != nil {\n+\t\tt.Errorf(\"got unexpected Write error on first request: %v\", g)\n+\t}\n+\n+\t// Times out:\n+\ttimeout <- 1\n+\tres, _, err = Get(ts.URL)\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t}\n+\tif g, e := res.StatusCode, StatusServiceUnavailable; g != e {\n+\t\tt.Errorf(\"got res.StatusCode %d; expected %d\", g, e)\n+\t}\n+\tbody, _ = ioutil.ReadAll(res.Body)\n+\tif !strings.Contains(string(body), \"<title>Timeout</title>\") {\n+\t\tt.Errorf(\"expected timeout body; got %q\", string(body))\n+\t}\n+\n+\t// Now make the previously-timed out handler speak again,\n+\t// which verifies the panic is handled:\n+\tsendHi <- true\n+\tif g, e := <-writeErrors, ErrHandlerTimeout; g != e {\n+\t\tt.Errorf(\"expected Write error of %v; got %v\", e, g)\n+\t}\n+}"}, {"sha": "d155f06a2d2d0a3c37671431fb507900bc169ac0", "filename": "libgo/go/http/server.go", "status": "modified", "additions": 138, "deletions": 7, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fserver.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -22,6 +22,7 @@ import (\n \t\"path\"\n \t\"strconv\"\n \t\"strings\"\n+\t\"sync\"\n \t\"time\"\n )\n \n@@ -141,9 +142,13 @@ func newConn(rwc net.Conn, handler Handler) (c *conn, err os.Error) {\n type expectContinueReader struct {\n \tresp       *response\n \treadCloser io.ReadCloser\n+\tclosed     bool\n }\n \n func (ecr *expectContinueReader) Read(p []byte) (n int, err os.Error) {\n+\tif ecr.closed {\n+\t\treturn 0, os.NewError(\"http: Read after Close on request Body\")\n+\t}\n \tif !ecr.resp.wroteContinue && !ecr.resp.conn.hijacked {\n \t\tecr.resp.wroteContinue = true\n \t\tio.WriteString(ecr.resp.conn.buf, \"HTTP/1.1 100 Continue\\r\\n\\r\\n\")\n@@ -153,6 +158,7 @@ func (ecr *expectContinueReader) Read(p []byte) (n int, err os.Error) {\n }\n \n func (ecr *expectContinueReader) Close() os.Error {\n+\tecr.closed = true\n \treturn ecr.readCloser.Close()\n }\n \n@@ -180,12 +186,6 @@ func (c *conn) readRequest() (w *response, err os.Error) {\n \tw.req = req\n \tw.header = make(Header)\n \tw.contentLength = -1\n-\n-\t// Expect 100 Continue support\n-\tif req.expectsContinue() && req.ProtoAtLeast(1, 1) {\n-\t\t// Wrap the Body reader with one that replies on the connection\n-\t\treq.Body = &expectContinueReader{readCloser: req.Body, resp: w}\n-\t}\n \treturn w, nil\n }\n \n@@ -202,6 +202,16 @@ func (w *response) WriteHeader(code int) {\n \t\tlog.Print(\"http: multiple response.WriteHeader calls\")\n \t\treturn\n \t}\n+\n+\t// Per RFC 2616, we should consume the request body before\n+\t// replying, if the handler hasn't already done so.\n+\tif w.req.ContentLength != 0 {\n+\t\tecr, isExpecter := w.req.Body.(*expectContinueReader)\n+\t\tif !isExpecter || ecr.resp.wroteContinue {\n+\t\t\tw.req.Body.Close()\n+\t\t}\n+\t}\n+\n \tw.wroteHeader = true\n \tw.status = code\n \tif code == StatusNotModified {\n@@ -299,7 +309,7 @@ func (w *response) WriteHeader(code int) {\n \t\ttext = \"status code \" + codestring\n \t}\n \tio.WriteString(w.conn.buf, proto+\" \"+codestring+\" \"+text+\"\\r\\n\")\n-\twriteSortedHeader(w.conn.buf, w.header, nil)\n+\tw.header.Write(w.conn.buf)\n \tio.WriteString(w.conn.buf, \"\\r\\n\")\n }\n \n@@ -413,6 +423,9 @@ func (w *response) finishRequest() {\n \t}\n \tw.conn.buf.Flush()\n \tw.req.Body.Close()\n+\tif w.req.MultipartForm != nil {\n+\t\tw.req.MultipartForm.RemoveAll()\n+\t}\n \n \tif w.contentLength != -1 && w.contentLength != w.written {\n \t\t// Did not write enough. Avoid getting out of sync.\n@@ -446,6 +459,38 @@ func (c *conn) serve() {\n \t\tif err != nil {\n \t\t\tbreak\n \t\t}\n+\n+\t\t// Expect 100 Continue support\n+\t\treq := w.req\n+\t\tif req.expectsContinue() {\n+\t\t\tif req.ProtoAtLeast(1, 1) {\n+\t\t\t\t// Wrap the Body reader with one that replies on the connection\n+\t\t\t\treq.Body = &expectContinueReader{readCloser: req.Body, resp: w}\n+\t\t\t}\n+\t\t\tif req.ContentLength == 0 {\n+\t\t\t\tw.Header().Set(\"Connection\", \"close\")\n+\t\t\t\tw.WriteHeader(StatusBadRequest)\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\treq.Header.Del(\"Expect\")\n+\t\t} else if req.Header.Get(\"Expect\") != \"\" {\n+\t\t\t// TODO(bradfitz): let ServeHTTP handlers handle\n+\t\t\t// requests with non-standard expectation[s]? Seems\n+\t\t\t// theoretical at best, and doesn't fit into the\n+\t\t\t// current ServeHTTP model anyway.  We'd need to\n+\t\t\t// make the ResponseWriter an optional\n+\t\t\t// \"ExpectReplier\" interface or something.\n+\t\t\t//\n+\t\t\t// For now we'll just obey RFC 2616 14.20 which says\n+\t\t\t// \"If a server receives a request containing an\n+\t\t\t// Expect field that includes an expectation-\n+\t\t\t// extension that it does not support, it MUST\n+\t\t\t// respond with a 417 (Expectation Failed) status.\"\n+\t\t\tw.Header().Set(\"Connection\", \"close\")\n+\t\t\tw.WriteHeader(StatusExpectationFailed)\n+\t\t\tbreak\n+\t\t}\n+\n \t\t// HTTP cannot have multiple simultaneous active requests.[*]\n \t\t// Until the server replies to this request, it can't read another,\n \t\t// so we might as well run the handler in this goroutine.\n@@ -857,3 +902,89 @@ func ListenAndServeTLS(addr string, certFile string, keyFile string, handler Han\n \ttlsListener := tls.NewListener(conn, config)\n \treturn Serve(tlsListener, handler)\n }\n+\n+// TimeoutHandler returns a Handler that runs h with the given time limit.\n+//\n+// The new Handler calls h.ServeHTTP to handle each request, but if a\n+// call runs for more than ns nanoseconds, the handler responds with\n+// a 503 Service Unavailable error and the given message in its body.\n+// (If msg is empty, a suitable default message will be sent.)\n+// After such a timeout, writes by h to its ResponseWriter will return\n+// ErrHandlerTimeout.\n+func TimeoutHandler(h Handler, ns int64, msg string) Handler {\n+\tf := func() <-chan int64 {\n+\t\treturn time.After(ns)\n+\t}\n+\treturn &timeoutHandler{h, f, msg}\n+}\n+\n+// ErrHandlerTimeout is returned on ResponseWriter Write calls\n+// in handlers which have timed out.\n+var ErrHandlerTimeout = os.NewError(\"http: Handler timeout\")\n+\n+type timeoutHandler struct {\n+\thandler Handler\n+\ttimeout func() <-chan int64 // returns channel producing a timeout\n+\tbody    string\n+}\n+\n+func (h *timeoutHandler) errorBody() string {\n+\tif h.body != \"\" {\n+\t\treturn h.body\n+\t}\n+\treturn \"<html><head><title>Timeout</title></head><body><h1>Timeout</h1></body></html>\"\n+}\n+\n+func (h *timeoutHandler) ServeHTTP(w ResponseWriter, r *Request) {\n+\tdone := make(chan bool)\n+\ttw := &timeoutWriter{w: w}\n+\tgo func() {\n+\t\th.handler.ServeHTTP(tw, r)\n+\t\tdone <- true\n+\t}()\n+\tselect {\n+\tcase <-done:\n+\t\treturn\n+\tcase <-h.timeout():\n+\t\ttw.mu.Lock()\n+\t\tdefer tw.mu.Unlock()\n+\t\tif !tw.wroteHeader {\n+\t\t\ttw.w.WriteHeader(StatusServiceUnavailable)\n+\t\t\ttw.w.Write([]byte(h.errorBody()))\n+\t\t}\n+\t\ttw.timedOut = true\n+\t}\n+}\n+\n+type timeoutWriter struct {\n+\tw ResponseWriter\n+\n+\tmu          sync.Mutex\n+\ttimedOut    bool\n+\twroteHeader bool\n+}\n+\n+func (tw *timeoutWriter) Header() Header {\n+\treturn tw.w.Header()\n+}\n+\n+func (tw *timeoutWriter) Write(p []byte) (int, os.Error) {\n+\ttw.mu.Lock()\n+\ttimedOut := tw.timedOut\n+\ttw.mu.Unlock()\n+\tif timedOut {\n+\t\treturn 0, ErrHandlerTimeout\n+\t}\n+\treturn tw.w.Write(p)\n+}\n+\n+func (tw *timeoutWriter) WriteHeader(code int) {\n+\ttw.mu.Lock()\n+\tif tw.timedOut || tw.wroteHeader {\n+\t\ttw.mu.Unlock()\n+\t\treturn\n+\t}\n+\ttw.wroteHeader = true\n+\ttw.mu.Unlock()\n+\ttw.w.WriteHeader(code)\n+}"}, {"sha": "d584ea232eab0a06a31f019b6dfbcfa3cb91a3a5", "filename": "libgo/go/http/spdy/protocol.go", "status": "added", "additions": 367, "deletions": 0, "changes": 367, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fspdy%2Fprotocol.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fspdy%2Fprotocol.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fspdy%2Fprotocol.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -0,0 +1,367 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package spdy is an incomplete implementation of the SPDY protocol.\n+//\n+// The implementation follows draft 2 of the spec:\n+// https://sites.google.com/a/chromium.org/dev/spdy/spdy-protocol/spdy-protocol-draft2\n+package spdy\n+\n+import (\n+\t\"bytes\"\n+\t\"compress/zlib\"\n+\t\"encoding/binary\"\n+\t\"http\"\n+\t\"io\"\n+\t\"os\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"sync\"\n+)\n+\n+// Version is the protocol version number that this package implements.\n+const Version = 2\n+\n+// ControlFrameType stores the type field in a control frame header.\n+type ControlFrameType uint16\n+\n+// Control frame type constants\n+const (\n+\tTypeSynStream    ControlFrameType = 0x0001\n+\tTypeSynReply     = 0x0002\n+\tTypeRstStream    = 0x0003\n+\tTypeSettings     = 0x0004\n+\tTypeNoop         = 0x0005\n+\tTypePing         = 0x0006\n+\tTypeGoaway       = 0x0007\n+\tTypeHeaders      = 0x0008\n+\tTypeWindowUpdate = 0x0009\n+)\n+\n+func (t ControlFrameType) String() string {\n+\tswitch t {\n+\tcase TypeSynStream:\n+\t\treturn \"SYN_STREAM\"\n+\tcase TypeSynReply:\n+\t\treturn \"SYN_REPLY\"\n+\tcase TypeRstStream:\n+\t\treturn \"RST_STREAM\"\n+\tcase TypeSettings:\n+\t\treturn \"SETTINGS\"\n+\tcase TypeNoop:\n+\t\treturn \"NOOP\"\n+\tcase TypePing:\n+\t\treturn \"PING\"\n+\tcase TypeGoaway:\n+\t\treturn \"GOAWAY\"\n+\tcase TypeHeaders:\n+\t\treturn \"HEADERS\"\n+\tcase TypeWindowUpdate:\n+\t\treturn \"WINDOW_UPDATE\"\n+\t}\n+\treturn \"Type(\" + strconv.Itoa(int(t)) + \")\"\n+}\n+\n+type FrameFlags uint8\n+\n+// Stream frame flags\n+const (\n+\tFlagFin            FrameFlags = 0x01\n+\tFlagUnidirectional = 0x02\n+)\n+\n+// SETTINGS frame flags\n+const (\n+\tFlagClearPreviouslyPersistedSettings FrameFlags = 0x01\n+)\n+\n+// MaxDataLength is the maximum number of bytes that can be stored in one frame.\n+const MaxDataLength = 1<<24 - 1\n+\n+// A Frame is a framed message as sent between clients and servers.\n+// There are two types of frames: control frames and data frames.\n+type Frame struct {\n+\tHeader [4]byte\n+\tFlags  FrameFlags\n+\tData   []byte\n+}\n+\n+// ControlFrame creates a control frame with the given information.\n+func ControlFrame(t ControlFrameType, f FrameFlags, data []byte) Frame {\n+\treturn Frame{\n+\t\tHeader: [4]byte{\n+\t\t\t(Version&0xff00)>>8 | 0x80,\n+\t\t\t(Version & 0x00ff),\n+\t\t\tbyte((t & 0xff00) >> 8),\n+\t\t\tbyte((t & 0x00ff) >> 0),\n+\t\t},\n+\t\tFlags: f,\n+\t\tData:  data,\n+\t}\n+}\n+\n+// DataFrame creates a data frame with the given information.\n+func DataFrame(streamId uint32, f FrameFlags, data []byte) Frame {\n+\treturn Frame{\n+\t\tHeader: [4]byte{\n+\t\t\tbyte(streamId & 0x7f000000 >> 24),\n+\t\t\tbyte(streamId & 0x00ff0000 >> 16),\n+\t\t\tbyte(streamId & 0x0000ff00 >> 8),\n+\t\t\tbyte(streamId & 0x000000ff >> 0),\n+\t\t},\n+\t\tFlags: f,\n+\t\tData:  data,\n+\t}\n+}\n+\n+// ReadFrame reads an entire frame into memory.\n+func ReadFrame(r io.Reader) (f Frame, err os.Error) {\n+\t_, err = io.ReadFull(r, f.Header[:])\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\terr = binary.Read(r, binary.BigEndian, &f.Flags)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tvar lengthField [3]byte\n+\t_, err = io.ReadFull(r, lengthField[:])\n+\tif err != nil {\n+\t\tif err == os.EOF {\n+\t\t\terr = io.ErrUnexpectedEOF\n+\t\t}\n+\t\treturn\n+\t}\n+\tvar length uint32\n+\tlength |= uint32(lengthField[0]) << 16\n+\tlength |= uint32(lengthField[1]) << 8\n+\tlength |= uint32(lengthField[2]) << 0\n+\tif length > 0 {\n+\t\tf.Data = make([]byte, int(length))\n+\t\t_, err = io.ReadFull(r, f.Data)\n+\t\tif err == os.EOF {\n+\t\t\terr = io.ErrUnexpectedEOF\n+\t\t}\n+\t} else {\n+\t\tf.Data = []byte{}\n+\t}\n+\treturn\n+}\n+\n+// IsControl returns whether the frame holds a control frame.\n+func (f Frame) IsControl() bool {\n+\treturn f.Header[0]&0x80 != 0\n+}\n+\n+// Type obtains the type field if the frame is a control frame, otherwise it returns zero.\n+func (f Frame) Type() ControlFrameType {\n+\tif !f.IsControl() {\n+\t\treturn 0\n+\t}\n+\treturn (ControlFrameType(f.Header[2])<<8 | ControlFrameType(f.Header[3]))\n+}\n+\n+// StreamId returns the stream ID field if the frame is a data frame, otherwise it returns zero.\n+func (f Frame) StreamId() (id uint32) {\n+\tif f.IsControl() {\n+\t\treturn 0\n+\t}\n+\tid |= uint32(f.Header[0]) << 24\n+\tid |= uint32(f.Header[1]) << 16\n+\tid |= uint32(f.Header[2]) << 8\n+\tid |= uint32(f.Header[3]) << 0\n+\treturn\n+}\n+\n+// WriteTo writes the frame in the SPDY format.\n+func (f Frame) WriteTo(w io.Writer) (n int64, err os.Error) {\n+\tvar nn int\n+\t// Header\n+\tnn, err = w.Write(f.Header[:])\n+\tn += int64(nn)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t// Flags\n+\tnn, err = w.Write([]byte{byte(f.Flags)})\n+\tn += int64(nn)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t// Length\n+\tnn, err = w.Write([]byte{\n+\t\tbyte(len(f.Data) & 0x00ff0000 >> 16),\n+\t\tbyte(len(f.Data) & 0x0000ff00 >> 8),\n+\t\tbyte(len(f.Data) & 0x000000ff),\n+\t})\n+\tn += int64(nn)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t// Data\n+\tif len(f.Data) > 0 {\n+\t\tnn, err = w.Write(f.Data)\n+\t\tn += int64(nn)\n+\t}\n+\treturn\n+}\n+\n+// headerDictionary is the dictionary sent to the zlib compressor/decompressor.\n+// Even though the specification states there is no null byte at the end, Chrome sends it.\n+const headerDictionary = \"optionsgetheadpostputdeletetrace\" +\n+\t\"acceptaccept-charsetaccept-encodingaccept-languageauthorizationexpectfromhost\" +\n+\t\"if-modified-sinceif-matchif-none-matchif-rangeif-unmodifiedsince\" +\n+\t\"max-forwardsproxy-authorizationrangerefererteuser-agent\" +\n+\t\"100101200201202203204205206300301302303304305306307400401402403404405406407408409410411412413414415416417500501502503504505\" +\n+\t\"accept-rangesageetaglocationproxy-authenticatepublicretry-after\" +\n+\t\"servervarywarningwww-authenticateallowcontent-basecontent-encodingcache-control\" +\n+\t\"connectiondatetrailertransfer-encodingupgradeviawarning\" +\n+\t\"content-languagecontent-lengthcontent-locationcontent-md5content-rangecontent-typeetagexpireslast-modifiedset-cookie\" +\n+\t\"MondayTuesdayWednesdayThursdayFridaySaturdaySunday\" +\n+\t\"JanFebMarAprMayJunJulAugSepOctNovDec\" +\n+\t\"chunkedtext/htmlimage/pngimage/jpgimage/gifapplication/xmlapplication/xhtmltext/plainpublicmax-age\" +\n+\t\"charset=iso-8859-1utf-8gzipdeflateHTTP/1.1statusversionurl\\x00\"\n+\n+// hrSource is a reader that passes through reads from another reader.\n+// When the underlying reader reaches EOF, Read will block until another reader is added via change.\n+type hrSource struct {\n+\tr io.Reader\n+\tm sync.RWMutex\n+\tc *sync.Cond\n+}\n+\n+func (src *hrSource) Read(p []byte) (n int, err os.Error) {\n+\tsrc.m.RLock()\n+\tfor src.r == nil {\n+\t\tsrc.c.Wait()\n+\t}\n+\tn, err = src.r.Read(p)\n+\tsrc.m.RUnlock()\n+\tif err == os.EOF {\n+\t\tsrc.change(nil)\n+\t\terr = nil\n+\t}\n+\treturn\n+}\n+\n+func (src *hrSource) change(r io.Reader) {\n+\tsrc.m.Lock()\n+\tdefer src.m.Unlock()\n+\tsrc.r = r\n+\tsrc.c.Broadcast()\n+}\n+\n+// A HeaderReader reads zlib-compressed headers.\n+type HeaderReader struct {\n+\tsource       hrSource\n+\tdecompressor io.ReadCloser\n+}\n+\n+// NewHeaderReader creates a HeaderReader with the initial dictionary.\n+func NewHeaderReader() (hr *HeaderReader) {\n+\thr = new(HeaderReader)\n+\thr.source.c = sync.NewCond(hr.source.m.RLocker())\n+\treturn\n+}\n+\n+// ReadHeader reads a set of headers from a reader.\n+func (hr *HeaderReader) ReadHeader(r io.Reader) (h http.Header, err os.Error) {\n+\thr.source.change(r)\n+\th, err = hr.read()\n+\treturn\n+}\n+\n+// Decode reads a set of headers from a block of bytes.\n+func (hr *HeaderReader) Decode(data []byte) (h http.Header, err os.Error) {\n+\thr.source.change(bytes.NewBuffer(data))\n+\th, err = hr.read()\n+\treturn\n+}\n+\n+func (hr *HeaderReader) read() (h http.Header, err os.Error) {\n+\tvar count uint16\n+\tif hr.decompressor == nil {\n+\t\thr.decompressor, err = zlib.NewReaderDict(&hr.source, []byte(headerDictionary))\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\terr = binary.Read(hr.decompressor, binary.BigEndian, &count)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\th = make(http.Header, int(count))\n+\tfor i := 0; i < int(count); i++ {\n+\t\tvar name, value string\n+\t\tname, err = readHeaderString(hr.decompressor)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tvalue, err = readHeaderString(hr.decompressor)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tvalueList := strings.Split(string(value), \"\\x00\", -1)\n+\t\tfor _, v := range valueList {\n+\t\t\th.Add(name, v)\n+\t\t}\n+\t}\n+\treturn\n+}\n+\n+func readHeaderString(r io.Reader) (s string, err os.Error) {\n+\tvar length uint16\n+\terr = binary.Read(r, binary.BigEndian, &length)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tdata := make([]byte, int(length))\n+\t_, err = io.ReadFull(r, data)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\treturn string(data), nil\n+}\n+\n+// HeaderWriter will write zlib-compressed headers on different streams.\n+type HeaderWriter struct {\n+\tcompressor *zlib.Writer\n+\tbuffer     *bytes.Buffer\n+}\n+\n+// NewHeaderWriter creates a HeaderWriter ready to compress headers.\n+func NewHeaderWriter(level int) (hw *HeaderWriter) {\n+\thw = &HeaderWriter{buffer: new(bytes.Buffer)}\n+\thw.compressor, _ = zlib.NewWriterDict(hw.buffer, level, []byte(headerDictionary))\n+\treturn\n+}\n+\n+// WriteHeader writes a header block directly to an output.\n+func (hw *HeaderWriter) WriteHeader(w io.Writer, h http.Header) (err os.Error) {\n+\thw.write(h)\n+\t_, err = io.Copy(w, hw.buffer)\n+\thw.buffer.Reset()\n+\treturn\n+}\n+\n+// Encode returns a compressed header block.\n+func (hw *HeaderWriter) Encode(h http.Header) (data []byte) {\n+\thw.write(h)\n+\tdata = make([]byte, hw.buffer.Len())\n+\thw.buffer.Read(data)\n+\treturn\n+}\n+\n+func (hw *HeaderWriter) write(h http.Header) {\n+\tbinary.Write(hw.compressor, binary.BigEndian, uint16(len(h)))\n+\tfor k, vals := range h {\n+\t\tk = strings.ToLower(k)\n+\t\tbinary.Write(hw.compressor, binary.BigEndian, uint16(len(k)))\n+\t\tbinary.Write(hw.compressor, binary.BigEndian, []byte(k))\n+\t\tv := strings.Join(vals, \"\\x00\")\n+\t\tbinary.Write(hw.compressor, binary.BigEndian, uint16(len(v)))\n+\t\tbinary.Write(hw.compressor, binary.BigEndian, []byte(v))\n+\t}\n+\thw.compressor.Flush()\n+}"}, {"sha": "998ff998bc7fcace613e6d1296c870df85fe391c", "filename": "libgo/go/http/spdy/protocol_test.go", "status": "added", "additions": 259, "deletions": 0, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fspdy%2Fprotocol_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Fspdy%2Fprotocol_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fspdy%2Fprotocol_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -0,0 +1,259 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package spdy\n+\n+import (\n+\t\"bytes\"\n+\t\"compress/zlib\"\n+\t\"http\"\n+\t\"os\"\n+\t\"testing\"\n+)\n+\n+type frameIoTest struct {\n+\tdesc      string\n+\tdata      []byte\n+\tframe     Frame\n+\treadError os.Error\n+\treadOnly  bool\n+}\n+\n+var frameIoTests = []frameIoTest{\n+\t{\n+\t\t\"noop frame\",\n+\t\t[]byte{\n+\t\t\t0x80, 0x02, 0x00, 0x05,\n+\t\t\t0x00, 0x00, 0x00, 0x00,\n+\t\t},\n+\t\tControlFrame(\n+\t\t\tTypeNoop,\n+\t\t\t0x00,\n+\t\t\t[]byte{},\n+\t\t),\n+\t\tnil,\n+\t\tfalse,\n+\t},\n+\t{\n+\t\t\"ping frame\",\n+\t\t[]byte{\n+\t\t\t0x80, 0x02, 0x00, 0x06,\n+\t\t\t0x00, 0x00, 0x00, 0x04,\n+\t\t\t0x00, 0x00, 0x00, 0x01,\n+\t\t},\n+\t\tControlFrame(\n+\t\t\tTypePing,\n+\t\t\t0x00,\n+\t\t\t[]byte{0x00, 0x00, 0x00, 0x01},\n+\t\t),\n+\t\tnil,\n+\t\tfalse,\n+\t},\n+\t{\n+\t\t\"syn_stream frame\",\n+\t\t[]byte{\n+\t\t\t0x80, 0x02, 0x00, 0x01,\n+\t\t\t0x01, 0x00, 0x00, 0x53,\n+\t\t\t0x00, 0x00, 0x00, 0x01,\n+\t\t\t0x00, 0x00, 0x00, 0x00,\n+\t\t\t0x00, 0x00, 0x78, 0xbb,\n+\t\t\t0xdf, 0xa2, 0x51, 0xb2,\n+\t\t\t0x62, 0x60, 0x66, 0x60,\n+\t\t\t0xcb, 0x4d, 0x2d, 0xc9,\n+\t\t\t0xc8, 0x4f, 0x61, 0x60,\n+\t\t\t0x4e, 0x4f, 0x2d, 0x61,\n+\t\t\t0x60, 0x2e, 0x2d, 0xca,\n+\t\t\t0x61, 0x10, 0xcb, 0x28,\n+\t\t\t0x29, 0x29, 0xb0, 0xd2,\n+\t\t\t0xd7, 0x2f, 0x2f, 0x2f,\n+\t\t\t0xd7, 0x4b, 0xcf, 0xcf,\n+\t\t\t0x4f, 0xcf, 0x49, 0xd5,\n+\t\t\t0x4b, 0xce, 0xcf, 0xd5,\n+\t\t\t0x67, 0x60, 0x2f, 0x4b,\n+\t\t\t0x2d, 0x2a, 0xce, 0xcc,\n+\t\t\t0xcf, 0x63, 0xe0, 0x00,\n+\t\t\t0x29, 0xd0, 0x37, 0xd4,\n+\t\t\t0x33, 0x04, 0x00, 0x00,\n+\t\t\t0x00, 0xff, 0xff,\n+\t\t},\n+\t\tControlFrame(\n+\t\t\tTypeSynStream,\n+\t\t\t0x01,\n+\t\t\t[]byte{\n+\t\t\t\t0x00, 0x00, 0x00, 0x01,\n+\t\t\t\t0x00, 0x00, 0x00, 0x00,\n+\t\t\t\t0x00, 0x00, 0x78, 0xbb,\n+\t\t\t\t0xdf, 0xa2, 0x51, 0xb2,\n+\t\t\t\t0x62, 0x60, 0x66, 0x60,\n+\t\t\t\t0xcb, 0x4d, 0x2d, 0xc9,\n+\t\t\t\t0xc8, 0x4f, 0x61, 0x60,\n+\t\t\t\t0x4e, 0x4f, 0x2d, 0x61,\n+\t\t\t\t0x60, 0x2e, 0x2d, 0xca,\n+\t\t\t\t0x61, 0x10, 0xcb, 0x28,\n+\t\t\t\t0x29, 0x29, 0xb0, 0xd2,\n+\t\t\t\t0xd7, 0x2f, 0x2f, 0x2f,\n+\t\t\t\t0xd7, 0x4b, 0xcf, 0xcf,\n+\t\t\t\t0x4f, 0xcf, 0x49, 0xd5,\n+\t\t\t\t0x4b, 0xce, 0xcf, 0xd5,\n+\t\t\t\t0x67, 0x60, 0x2f, 0x4b,\n+\t\t\t\t0x2d, 0x2a, 0xce, 0xcc,\n+\t\t\t\t0xcf, 0x63, 0xe0, 0x00,\n+\t\t\t\t0x29, 0xd0, 0x37, 0xd4,\n+\t\t\t\t0x33, 0x04, 0x00, 0x00,\n+\t\t\t\t0x00, 0xff, 0xff,\n+\t\t\t},\n+\t\t),\n+\t\tnil,\n+\t\tfalse,\n+\t},\n+\t{\n+\t\t\"data frame\",\n+\t\t[]byte{\n+\t\t\t0x00, 0x00, 0x00, 0x05,\n+\t\t\t0x01, 0x00, 0x00, 0x04,\n+\t\t\t0x01, 0x02, 0x03, 0x04,\n+\t\t},\n+\t\tDataFrame(\n+\t\t\t5,\n+\t\t\t0x01,\n+\t\t\t[]byte{0x01, 0x02, 0x03, 0x04},\n+\t\t),\n+\t\tnil,\n+\t\tfalse,\n+\t},\n+\t{\n+\t\t\"too much data\",\n+\t\t[]byte{\n+\t\t\t0x00, 0x00, 0x00, 0x05,\n+\t\t\t0x01, 0x00, 0x00, 0x04,\n+\t\t\t0x01, 0x02, 0x03, 0x04,\n+\t\t\t0x05, 0x06, 0x07, 0x08,\n+\t\t},\n+\t\tDataFrame(\n+\t\t\t5,\n+\t\t\t0x01,\n+\t\t\t[]byte{0x01, 0x02, 0x03, 0x04},\n+\t\t),\n+\t\tnil,\n+\t\ttrue,\n+\t},\n+\t{\n+\t\t\"not enough data\",\n+\t\t[]byte{\n+\t\t\t0x00, 0x00, 0x00, 0x05,\n+\t\t},\n+\t\tFrame{},\n+\t\tos.EOF,\n+\t\ttrue,\n+\t},\n+}\n+\n+func TestReadFrame(t *testing.T) {\n+\tfor _, tt := range frameIoTests {\n+\t\tf, err := ReadFrame(bytes.NewBuffer(tt.data))\n+\t\tif err != tt.readError {\n+\t\t\tt.Errorf(\"%s: ReadFrame: %s\", tt.desc, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif err == nil {\n+\t\t\tif !bytes.Equal(f.Header[:], tt.frame.Header[:]) {\n+\t\t\t\tt.Errorf(\"%s: header %q != %q\", tt.desc, string(f.Header[:]), string(tt.frame.Header[:]))\n+\t\t\t}\n+\t\t\tif f.Flags != tt.frame.Flags {\n+\t\t\t\tt.Errorf(\"%s: flags %#02x != %#02x\", tt.desc, f.Flags, tt.frame.Flags)\n+\t\t\t}\n+\t\t\tif !bytes.Equal(f.Data, tt.frame.Data) {\n+\t\t\t\tt.Errorf(\"%s: data %q != %q\", tt.desc, string(f.Data), string(tt.frame.Data))\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+func TestWriteTo(t *testing.T) {\n+\tfor _, tt := range frameIoTests {\n+\t\tif tt.readOnly {\n+\t\t\tcontinue\n+\t\t}\n+\t\tb := new(bytes.Buffer)\n+\t\t_, err := tt.frame.WriteTo(b)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"%s: WriteTo: %s\", tt.desc, err)\n+\t\t}\n+\t\tif !bytes.Equal(b.Bytes(), tt.data) {\n+\t\t\tt.Errorf(\"%s: data %q != %q\", tt.desc, string(b.Bytes()), string(tt.data))\n+\t\t}\n+\t}\n+}\n+\n+var headerDataTest = []byte{\n+\t0x78, 0xbb, 0xdf, 0xa2,\n+\t0x51, 0xb2, 0x62, 0x60,\n+\t0x66, 0x60, 0xcb, 0x4d,\n+\t0x2d, 0xc9, 0xc8, 0x4f,\n+\t0x61, 0x60, 0x4e, 0x4f,\n+\t0x2d, 0x61, 0x60, 0x2e,\n+\t0x2d, 0xca, 0x61, 0x10,\n+\t0xcb, 0x28, 0x29, 0x29,\n+\t0xb0, 0xd2, 0xd7, 0x2f,\n+\t0x2f, 0x2f, 0xd7, 0x4b,\n+\t0xcf, 0xcf, 0x4f, 0xcf,\n+\t0x49, 0xd5, 0x4b, 0xce,\n+\t0xcf, 0xd5, 0x67, 0x60,\n+\t0x2f, 0x4b, 0x2d, 0x2a,\n+\t0xce, 0xcc, 0xcf, 0x63,\n+\t0xe0, 0x00, 0x29, 0xd0,\n+\t0x37, 0xd4, 0x33, 0x04,\n+\t0x00, 0x00, 0x00, 0xff,\n+\t0xff,\n+}\n+\n+func TestReadHeader(t *testing.T) {\n+\tr := NewHeaderReader()\n+\th, err := r.Decode(headerDataTest)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Error: %v\", err)\n+\t\treturn\n+\t}\n+\tif len(h) != 3 {\n+\t\tt.Errorf(\"Header count = %d (expected 3)\", len(h))\n+\t}\n+\tif h.Get(\"Url\") != \"http://www.google.com/\" {\n+\t\tt.Errorf(\"Url: %q != %q\", h.Get(\"Url\"), \"http://www.google.com/\")\n+\t}\n+\tif h.Get(\"Method\") != \"get\" {\n+\t\tt.Errorf(\"Method: %q != %q\", h.Get(\"Method\"), \"get\")\n+\t}\n+\tif h.Get(\"Version\") != \"http/1.1\" {\n+\t\tt.Errorf(\"Version: %q != %q\", h.Get(\"Version\"), \"http/1.1\")\n+\t}\n+}\n+\n+func TestWriteHeader(t *testing.T) {\n+\tfor level := zlib.NoCompression; level <= zlib.BestCompression; level++ {\n+\t\tr := NewHeaderReader()\n+\t\tw := NewHeaderWriter(level)\n+\t\tfor i := 0; i < 100; i++ {\n+\t\t\tb := new(bytes.Buffer)\n+\t\t\tgold := http.Header{\n+\t\t\t\t\"Url\":     []string{\"http://www.google.com/\"},\n+\t\t\t\t\"Method\":  []string{\"get\"},\n+\t\t\t\t\"Version\": []string{\"http/1.1\"},\n+\t\t\t}\n+\t\t\tw.WriteHeader(b, gold)\n+\t\t\th, err := r.Decode(b.Bytes())\n+\t\t\tif err != nil {\n+\t\t\t\tt.Errorf(\"(level=%d i=%d) Error: %v\", level, i, err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif len(h) != len(gold) {\n+\t\t\t\tt.Errorf(\"(level=%d i=%d) Header count = %d (expected %d)\", level, i, len(h), len(gold))\n+\t\t\t}\n+\t\t\tfor k, _ := range h {\n+\t\t\t\tif h.Get(k) != gold.Get(k) {\n+\t\t\t\t\tt.Errorf(\"(level=%d i=%d) %s: %q != %q\", level, i, k, h.Get(k), gold.Get(k))\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+}"}, {"sha": "0fa8bed43aa922a1f1dc79eb02adcdd754eb1372", "filename": "libgo/go/http/transfer.go", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Ftransfer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Ftransfer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ftransfer.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -7,6 +7,7 @@ package http\n import (\n \t\"bufio\"\n \t\"io\"\n+\t\"io/ioutil\"\n \t\"os\"\n \t\"strconv\"\n \t\"strings\"\n@@ -438,26 +439,39 @@ type body struct {\n \thdr     interface{}   // non-nil (Response or Request) value means read trailer\n \tr       *bufio.Reader // underlying wire-format reader for the trailer\n \tclosing bool          // is the connection to be closed after reading body?\n+\tclosed  bool\n+}\n+\n+// ErrBodyReadAfterClose is returned when reading a Request Body after\n+// the body has been closed. This typically happens when the body is\n+// read after an HTTP Handler calls WriteHeader or Write on its\n+// ResponseWriter.\n+var ErrBodyReadAfterClose = os.NewError(\"http: invalid Read on closed request Body\")\n+\n+func (b *body) Read(p []byte) (n int, err os.Error) {\n+\tif b.closed {\n+\t\treturn 0, ErrBodyReadAfterClose\n+\t}\n+\treturn b.Reader.Read(p)\n }\n \n func (b *body) Close() os.Error {\n+\tif b.closed {\n+\t\treturn nil\n+\t}\n+\tdefer func() {\n+\t\tb.closed = true\n+\t}()\n \tif b.hdr == nil && b.closing {\n \t\t// no trailer and closing the connection next.\n \t\t// no point in reading to EOF.\n \t\treturn nil\n \t}\n \n-\ttrashBuf := make([]byte, 1024) // local for thread safety\n-\tfor {\n-\t\t_, err := b.Read(trashBuf)\n-\t\tif err == nil {\n-\t\t\tcontinue\n-\t\t}\n-\t\tif err == os.EOF {\n-\t\t\tbreak\n-\t\t}\n+\tif _, err := io.Copy(ioutil.Discard, b); err != nil {\n \t\treturn err\n \t}\n+\n \tif b.hdr == nil { // not reading trailer\n \t\treturn nil\n \t}"}, {"sha": "73a2c2191ea403adec3cdd57f2d9ba6b031a0288", "filename": "libgo/go/http/transport.go", "status": "modified", "additions": 77, "deletions": 5, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Ftransport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Ftransport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ftransport.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -6,6 +6,8 @@ package http\n \n import (\n \t\"bufio\"\n+\t\"bytes\"\n+\t\"compress/gzip\"\n \t\"crypto/tls\"\n \t\"encoding/base64\"\n \t\"fmt\"\n@@ -39,8 +41,9 @@ type Transport struct {\n \t// TODO: tunable on timeout on cached connections\n \t// TODO: optional pipelining\n \n-\tIgnoreEnvironment bool // don't look at environment variables for proxy configuration\n-\tDisableKeepAlives bool\n+\tIgnoreEnvironment  bool // don't look at environment variables for proxy configuration\n+\tDisableKeepAlives  bool\n+\tDisableCompression bool\n \n \t// MaxIdleConnsPerHost, if non-zero, controls the maximum idle\n \t// (keep-alive) to keep to keep per-host.  If zero,\n@@ -215,6 +218,9 @@ func (t *Transport) getConn(cm *connectMethod) (*persistConn, os.Error) {\n \n \tconn, err := net.Dial(\"tcp\", cm.addr())\n \tif err != nil {\n+\t\tif cm.proxyURL != nil {\n+\t\t\terr = fmt.Errorf(\"http: error connecting to proxy %s: %v\", cm.proxyURL, err)\n+\t\t}\n \t\treturn nil, err\n \t}\n \n@@ -286,10 +292,28 @@ func (t *Transport) getConn(cm *connectMethod) (*persistConn, os.Error) {\n \n // useProxy returns true if requests to addr should use a proxy,\n // according to the NO_PROXY or no_proxy environment variable.\n+// addr is always a canonicalAddr with a host and port.\n func (t *Transport) useProxy(addr string) bool {\n \tif len(addr) == 0 {\n \t\treturn true\n \t}\n+\thost, _, err := net.SplitHostPort(addr)\n+\tif err != nil {\n+\t\treturn false\n+\t}\n+\tif host == \"localhost\" {\n+\t\treturn false\n+\t}\n+\tif ip := net.ParseIP(host); ip != nil {\n+\t\tif ip4 := ip.To4(); ip4 != nil && ip4[0] == 127 {\n+\t\t\t// 127.0.0.0/8 loopback isn't proxied.\n+\t\t\treturn false\n+\t\t}\n+\t\tif bytes.Equal(ip, net.IPv6loopback) {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\n \tno_proxy := t.getenvEitherCase(\"NO_PROXY\")\n \tif no_proxy == \"*\" {\n \t\treturn false\n@@ -474,6 +498,19 @@ func (pc *persistConn) roundTrip(req *Request) (resp *Response, err os.Error) {\n \t\tpc.mutateRequestFunc(req)\n \t}\n \n+\t// Ask for a compressed version if the caller didn't set their\n+\t// own value for Accept-Encoding. We only attempted to\n+\t// uncompress the gzip stream if we were the layer that\n+\t// requested it.\n+\trequestedGzip := false\n+\tif !pc.t.DisableCompression && req.Header.Get(\"Accept-Encoding\") == \"\" {\n+\t\t// Request gzip only, not deflate. Deflate is ambiguous and \n+\t\t// as universally supported anyway.\n+\t\t// See: http://www.gzip.org/zlib/zlib_faq.html#faq38\n+\t\trequestedGzip = true\n+\t\treq.Header.Set(\"Accept-Encoding\", \"gzip\")\n+\t}\n+\n \tpc.lk.Lock()\n \tpc.numExpectedResponses++\n \tpc.lk.Unlock()\n@@ -490,6 +527,20 @@ func (pc *persistConn) roundTrip(req *Request) (resp *Response, err os.Error) {\n \tpc.lk.Lock()\n \tpc.numExpectedResponses--\n \tpc.lk.Unlock()\n+\n+\tif re.err == nil && requestedGzip && re.res.Header.Get(\"Content-Encoding\") == \"gzip\" {\n+\t\tre.res.Header.Del(\"Content-Encoding\")\n+\t\tre.res.Header.Del(\"Content-Length\")\n+\t\tre.res.ContentLength = -1\n+\t\tesb := re.res.Body.(*bodyEOFSignal)\n+\t\tgzReader, err := gzip.NewReader(esb.body)\n+\t\tif err != nil {\n+\t\t\tpc.close()\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tesb.body = &readFirstCloseBoth{gzReader, esb.body}\n+\t}\n+\n \treturn re.res, re.err\n }\n \n@@ -526,7 +577,7 @@ func responseIsKeepAlive(res *Response) bool {\n func readResponseWithEOFSignal(r *bufio.Reader, requestMethod string) (resp *Response, err os.Error) {\n \tresp, err = ReadResponse(r, requestMethod)\n \tif err == nil && resp.ContentLength != 0 {\n-\t\tresp.Body = &bodyEOFSignal{resp.Body, nil}\n+\t\tresp.Body = &bodyEOFSignal{body: resp.Body}\n \t}\n \treturn\n }\n@@ -535,12 +586,16 @@ func readResponseWithEOFSignal(r *bufio.Reader, requestMethod string) (resp *Res\n // once, right before the final Read() or Close() call returns, but after\n // EOF has been seen.\n type bodyEOFSignal struct {\n-\tbody io.ReadCloser\n-\tfn   func()\n+\tbody     io.ReadCloser\n+\tfn       func()\n+\tisClosed bool\n }\n \n func (es *bodyEOFSignal) Read(p []byte) (n int, err os.Error) {\n \tn, err = es.body.Read(p)\n+\tif es.isClosed && n > 0 {\n+\t\tpanic(\"http: unexpected bodyEOFSignal Read after Close; see issue 1725\")\n+\t}\n \tif err == os.EOF && es.fn != nil {\n \t\tes.fn()\n \t\tes.fn = nil\n@@ -549,10 +604,27 @@ func (es *bodyEOFSignal) Read(p []byte) (n int, err os.Error) {\n }\n \n func (es *bodyEOFSignal) Close() (err os.Error) {\n+\tes.isClosed = true\n \terr = es.body.Close()\n \tif err == nil && es.fn != nil {\n \t\tes.fn()\n \t\tes.fn = nil\n \t}\n \treturn\n }\n+\n+type readFirstCloseBoth struct {\n+\tio.ReadCloser\n+\tio.Closer\n+}\n+\n+func (r *readFirstCloseBoth) Close() os.Error {\n+\tif err := r.ReadCloser.Close(); err != nil {\n+\t\tr.Closer.Close()\n+\t\treturn err\n+\t}\n+\tif err := r.Closer.Close(); err != nil {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}"}, {"sha": "7610856738de6349b4e34b046f03ea2c0340a1ee", "filename": "libgo/go/http/transport_test.go", "status": "modified", "additions": 204, "deletions": 24, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Ftransport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Ftransport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ftransport_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -7,11 +7,16 @@\n package http_test\n \n import (\n+\t\"bytes\"\n+\t\"compress/gzip\"\n+\t\"crypto/rand\"\n \t\"fmt\"\n \t. \"http\"\n \t\"http/httptest\"\n+\t\"io\"\n \t\"io/ioutil\"\n \t\"os\"\n+\t\"strconv\"\n \t\"testing\"\n \t\"time\"\n )\n@@ -24,7 +29,7 @@ var hostPortHandler = HandlerFunc(func(w ResponseWriter, r *Request) {\n \tif r.FormValue(\"close\") == \"true\" {\n \t\tw.Header().Set(\"Connection\", \"close\")\n \t}\n-\tfmt.Fprintf(w, \"%s\", r.RemoteAddr)\n+\tw.Write([]byte(r.RemoteAddr))\n })\n \n // Two subsequent requests and verify their response is the same.\n@@ -177,35 +182,47 @@ func TestTransportIdleCacheKeys(t *testing.T) {\n }\n \n func TestTransportMaxPerHostIdleConns(t *testing.T) {\n-\tch := make(chan string)\n+\tresch := make(chan string)\n+\tgotReq := make(chan bool)\n \tts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n-\t\tfmt.Fprintf(w, \"%s\", <-ch)\n+\t\tgotReq <- true\n+\t\tmsg := <-resch\n+\t\t_, err := w.Write([]byte(msg))\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"Write: %v\", err)\n+\t\t}\n \t}))\n \tdefer ts.Close()\n \tmaxIdleConns := 2\n \ttr := &Transport{DisableKeepAlives: false, MaxIdleConnsPerHost: maxIdleConns}\n \tc := &Client{Transport: tr}\n \n-\t// Start 3 outstanding requests (will hang until we write to\n-\t// ch)\n+\t// Start 3 outstanding requests and wait for the server to get them.\n+\t// Their responses will hang until we we write to resch, though.\n \tdonech := make(chan bool)\n \tdoReq := func() {\n \t\tresp, _, err := c.Get(ts.URL)\n \t\tif err != nil {\n \t\t\tt.Error(err)\n \t\t}\n-\t\tioutil.ReadAll(resp.Body)\n+\t\t_, err = ioutil.ReadAll(resp.Body)\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"ReadAll: %v\", err)\n+\t\t}\n \t\tdonech <- true\n \t}\n \tgo doReq()\n+\t<-gotReq\n \tgo doReq()\n+\t<-gotReq\n \tgo doReq()\n+\t<-gotReq\n \n \tif e, g := 0, len(tr.IdleConnKeysForTesting()); e != g {\n \t\tt.Fatalf(\"Before writes, expected %d idle conn cache keys; got %d\", e, g)\n \t}\n \n-\tch <- \"res1\"\n+\tresch <- \"res1\"\n \t<-donech\n \tkeys := tr.IdleConnKeysForTesting()\n \tif e, g := 1, len(keys); e != g {\n@@ -219,13 +236,13 @@ func TestTransportMaxPerHostIdleConns(t *testing.T) {\n \t\tt.Errorf(\"after first response, expected %d idle conns; got %d\", e, g)\n \t}\n \n-\tch <- \"res2\"\n+\tresch <- \"res2\"\n \t<-donech\n \tif e, g := 2, tr.IdleConnCountForTesting(cacheKey); e != g {\n \t\tt.Errorf(\"after second response, expected %d idle conns; got %d\", e, g)\n \t}\n \n-\tch <- \"res3\"\n+\tresch <- \"res3\"\n \t<-donech\n \tif e, g := maxIdleConns, tr.IdleConnCountForTesting(cacheKey); e != g {\n \t\tt.Errorf(\"after third response, still expected %d idle conns; got %d\", e, g)\n@@ -239,26 +256,44 @@ func TestTransportServerClosingUnexpectedly(t *testing.T) {\n \ttr := &Transport{}\n \tc := &Client{Transport: tr}\n \n-\tfetch := func(n int) string {\n-\t\tres, _, err := c.Get(ts.URL)\n-\t\tif err != nil {\n-\t\t\tt.Fatalf(\"error in req #%d, GET: %v\", n, err)\n+\tfetch := func(n, retries int) string {\n+\t\tcondFatalf := func(format string, arg ...interface{}) {\n+\t\t\tif retries <= 0 {\n+\t\t\t\tt.Fatalf(format, arg...)\n+\t\t\t}\n+\t\t\tt.Logf(\"retrying shortly after expected error: \"+format, arg...)\n+\t\t\ttime.Sleep(1e9 / int64(retries))\n \t\t}\n-\t\tbody, err := ioutil.ReadAll(res.Body)\n-\t\tif err != nil {\n-\t\t\tt.Fatalf(\"error in req #%d, ReadAll: %v\", n, err)\n+\t\tfor retries >= 0 {\n+\t\t\tretries--\n+\t\t\tres, _, err := c.Get(ts.URL)\n+\t\t\tif err != nil {\n+\t\t\t\tcondFatalf(\"error in req #%d, GET: %v\", n, err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tbody, err := ioutil.ReadAll(res.Body)\n+\t\t\tif err != nil {\n+\t\t\t\tcondFatalf(\"error in req #%d, ReadAll: %v\", n, err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tres.Body.Close()\n+\t\t\treturn string(body)\n \t\t}\n-\t\tres.Body.Close()\n-\t\treturn string(body)\n+\t\tpanic(\"unreachable\")\n \t}\n \n-\tbody1 := fetch(1)\n-\tbody2 := fetch(2)\n+\tbody1 := fetch(1, 0)\n+\tbody2 := fetch(2, 0)\n \n \tts.CloseClientConnections() // surprise!\n-\ttime.Sleep(25e6)            // idle for a bit (test is inherently racey, but expectedly)\n \n-\tbody3 := fetch(3)\n+\t// This test has an expected race. Sleeping for 25 ms prevents\n+\t// it on most fast machines, causing the next fetch() call to\n+\t// succeed quickly.  But if we do get errors, fetch() will retry 5\n+\t// times with some delays between.\n+\ttime.Sleep(25e6)\n+\n+\tbody3 := fetch(3, 5)\n \n \tif body1 != body2 {\n \t\tt.Errorf(\"expected body1 and body2 to be equal\")\n@@ -288,10 +323,10 @@ func TestTransportHeadResponses(t *testing.T) {\n \t\t\tt.Errorf(\"error on loop %d: %v\", i, err)\n \t\t}\n \t\tif e, g := \"123\", res.Header.Get(\"Content-Length\"); e != g {\n-\t\t\tt.Errorf(\"loop %d: expected Content-Length header of %q, got %q\", e, g)\n+\t\t\tt.Errorf(\"loop %d: expected Content-Length header of %q, got %q\", i, e, g)\n \t\t}\n \t\tif e, g := int64(0), res.ContentLength; e != g {\n-\t\t\tt.Errorf(\"loop %d: expected res.ContentLength of %v, got %v\", e, g)\n+\t\t\tt.Errorf(\"loop %d: expected res.ContentLength of %v, got %v\", i, e, g)\n \t\t}\n \t}\n }\n@@ -338,6 +373,7 @@ func TestTransportNilURL(t *testing.T) {\n \treq.Proto = \"HTTP/1.1\"\n \treq.ProtoMajor = 1\n \treq.ProtoMinor = 1\n+\treq.Header = make(Header)\n \n \ttr := &Transport{}\n \tres, err := tr.RoundTrip(req)\n@@ -349,3 +385,147 @@ func TestTransportNilURL(t *testing.T) {\n \t\tt.Fatalf(\"Expected response body of %q; got %q\", e, g)\n \t}\n }\n+\n+func TestTransportGzip(t *testing.T) {\n+\tconst testString = \"The test string aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n+\tconst nRandBytes = 1024 * 1024\n+\tts := httptest.NewServer(HandlerFunc(func(rw ResponseWriter, req *Request) {\n+\t\tif g, e := req.Header.Get(\"Accept-Encoding\"), \"gzip\"; g != e {\n+\t\t\tt.Errorf(\"Accept-Encoding = %q, want %q\", g, e)\n+\t\t}\n+\t\trw.Header().Set(\"Content-Encoding\", \"gzip\")\n+\n+\t\tvar w io.Writer = rw\n+\t\tvar buf bytes.Buffer\n+\t\tif req.FormValue(\"chunked\") == \"0\" {\n+\t\t\tw = &buf\n+\t\t\tdefer io.Copy(rw, &buf)\n+\t\t\tdefer func() {\n+\t\t\t\trw.Header().Set(\"Content-Length\", strconv.Itoa(buf.Len()))\n+\t\t\t}()\n+\t\t}\n+\t\tgz, _ := gzip.NewWriter(w)\n+\t\tgz.Write([]byte(testString))\n+\t\tif req.FormValue(\"body\") == \"large\" {\n+\t\t\tio.Copyn(gz, rand.Reader, nRandBytes)\n+\t\t}\n+\t\tgz.Close()\n+\t}))\n+\tdefer ts.Close()\n+\n+\tfor _, chunked := range []string{\"1\", \"0\"} {\n+\t\tc := &Client{Transport: &Transport{}}\n+\n+\t\t// First fetch something large, but only read some of it.\n+\t\tres, _, err := c.Get(ts.URL + \"?body=large&chunked=\" + chunked)\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"large get: %v\", err)\n+\t\t}\n+\t\tbuf := make([]byte, len(testString))\n+\t\tn, err := io.ReadFull(res.Body, buf)\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"partial read of large response: size=%d, %v\", n, err)\n+\t\t}\n+\t\tif e, g := testString, string(buf); e != g {\n+\t\t\tt.Errorf(\"partial read got %q, expected %q\", g, e)\n+\t\t}\n+\t\tres.Body.Close()\n+\t\t// Read on the body, even though it's closed\n+\t\tn, err = res.Body.Read(buf)\n+\t\tif n != 0 || err == nil {\n+\t\t\tt.Errorf(\"expected error post-closed large Read; got = %d, %v\", n, err)\n+\t\t}\n+\n+\t\t// Then something small.\n+\t\tres, _, err = c.Get(ts.URL + \"?chunked=\" + chunked)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tbody, err := ioutil.ReadAll(res.Body)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tif g, e := string(body), testString; g != e {\n+\t\t\tt.Fatalf(\"body = %q; want %q\", g, e)\n+\t\t}\n+\t\tif g, e := res.Header.Get(\"Content-Encoding\"), \"\"; g != e {\n+\t\t\tt.Fatalf(\"Content-Encoding = %q; want %q\", g, e)\n+\t\t}\n+\n+\t\t// Read on the body after it's been fully read:\n+\t\tn, err = res.Body.Read(buf)\n+\t\tif n != 0 || err == nil {\n+\t\t\tt.Errorf(\"expected Read error after exhausted reads; got %d, %v\", n, err)\n+\t\t}\n+\t\tres.Body.Close()\n+\t\tn, err = res.Body.Read(buf)\n+\t\tif n != 0 || err == nil {\n+\t\t\tt.Errorf(\"expected Read error after Close; got %d, %v\", n, err)\n+\t\t}\n+\t}\n+}\n+\n+// TestTransportGzipRecursive sends a gzip quine and checks that the\n+// client gets the same value back. This is more cute than anything,\n+// but checks that we don't recurse forever, and checks that\n+// Content-Encoding is removed.\n+func TestTransportGzipRecursive(t *testing.T) {\n+\tts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n+\t\tw.Header().Set(\"Content-Encoding\", \"gzip\")\n+\t\tw.Write(rgz)\n+\t}))\n+\tdefer ts.Close()\n+\n+\tc := &Client{Transport: &Transport{}}\n+\tres, _, err := c.Get(ts.URL)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tbody, err := ioutil.ReadAll(res.Body)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif !bytes.Equal(body, rgz) {\n+\t\tt.Fatalf(\"Incorrect result from recursive gz:\\nhave=%x\\nwant=%x\",\n+\t\t\tbody, rgz)\n+\t}\n+\tif g, e := res.Header.Get(\"Content-Encoding\"), \"\"; g != e {\n+\t\tt.Fatalf(\"Content-Encoding = %q; want %q\", g, e)\n+\t}\n+}\n+\n+// rgz is a gzip quine that uncompresses to itself.\n+var rgz = []byte{\n+\t0x1f, 0x8b, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00,\n+\t0x00, 0x00, 0x72, 0x65, 0x63, 0x75, 0x72, 0x73,\n+\t0x69, 0x76, 0x65, 0x00, 0x92, 0xef, 0xe6, 0xe0,\n+\t0x60, 0x00, 0x83, 0xa2, 0xd4, 0xe4, 0xd2, 0xa2,\n+\t0xe2, 0xcc, 0xb2, 0x54, 0x06, 0x00, 0x00, 0x17,\n+\t0x00, 0xe8, 0xff, 0x92, 0xef, 0xe6, 0xe0, 0x60,\n+\t0x00, 0x83, 0xa2, 0xd4, 0xe4, 0xd2, 0xa2, 0xe2,\n+\t0xcc, 0xb2, 0x54, 0x06, 0x00, 0x00, 0x17, 0x00,\n+\t0xe8, 0xff, 0x42, 0x12, 0x46, 0x16, 0x06, 0x00,\n+\t0x05, 0x00, 0xfa, 0xff, 0x42, 0x12, 0x46, 0x16,\n+\t0x06, 0x00, 0x05, 0x00, 0xfa, 0xff, 0x00, 0x05,\n+\t0x00, 0xfa, 0xff, 0x00, 0x14, 0x00, 0xeb, 0xff,\n+\t0x42, 0x12, 0x46, 0x16, 0x06, 0x00, 0x05, 0x00,\n+\t0xfa, 0xff, 0x00, 0x05, 0x00, 0xfa, 0xff, 0x00,\n+\t0x14, 0x00, 0xeb, 0xff, 0x42, 0x88, 0x21, 0xc4,\n+\t0x00, 0x00, 0x14, 0x00, 0xeb, 0xff, 0x42, 0x88,\n+\t0x21, 0xc4, 0x00, 0x00, 0x14, 0x00, 0xeb, 0xff,\n+\t0x42, 0x88, 0x21, 0xc4, 0x00, 0x00, 0x14, 0x00,\n+\t0xeb, 0xff, 0x42, 0x88, 0x21, 0xc4, 0x00, 0x00,\n+\t0x14, 0x00, 0xeb, 0xff, 0x42, 0x88, 0x21, 0xc4,\n+\t0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,\n+\t0x00, 0xff, 0xff, 0x00, 0x17, 0x00, 0xe8, 0xff,\n+\t0x42, 0x88, 0x21, 0xc4, 0x00, 0x00, 0x00, 0x00,\n+\t0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00,\n+\t0x17, 0x00, 0xe8, 0xff, 0x42, 0x12, 0x46, 0x16,\n+\t0x06, 0x00, 0x00, 0x00, 0xff, 0xff, 0x01, 0x08,\n+\t0x00, 0xf7, 0xff, 0x3d, 0xb1, 0x20, 0x85, 0xfa,\n+\t0x00, 0x00, 0x00, 0x42, 0x12, 0x46, 0x16, 0x06,\n+\t0x00, 0x00, 0x00, 0xff, 0xff, 0x01, 0x08, 0x00,\n+\t0xf7, 0xff, 0x3d, 0xb1, 0x20, 0x85, 0xfa, 0x00,\n+\t0x00, 0x00, 0x3d, 0xb1, 0x20, 0x85, 0xfa, 0x00,\n+\t0x00, 0x00,\n+}"}, {"sha": "d7ee14ee84ae3702b79e4615f7e3a722bd39c11a", "filename": "libgo/go/http/url.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Furl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fhttp%2Furl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Furl.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -449,7 +449,7 @@ func ParseURLReference(rawurlref string) (url *URL, err os.Error) {\n //\n // There are redundant fields stored in the URL structure:\n // the String method consults Scheme, Path, Host, RawUserinfo,\n-// RawQuery, and Fragment, but not Raw, RawPath or Authority.\n+// RawQuery, and Fragment, but not Raw, RawPath or RawAuthority.\n func (url *URL) String() string {\n \tresult := \"\"\n \tif url.Scheme != \"\" {"}, {"sha": "fee537cf1a2649a6b16f04f81ee077b56b8f209c", "filename": "libgo/go/image/decode_test.go", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Fdecode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Fdecode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fdecode_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -10,9 +10,11 @@ import (\n \t\"os\"\n \t\"testing\"\n \n-\t// TODO(nigeltao): implement bmp, gif and tiff decoders.\n+\t// TODO(nigeltao): implement bmp decoder.\n+\t_ \"image/gif\"\n \t_ \"image/jpeg\"\n \t_ \"image/png\"\n+\t_ \"image/tiff\"\n )\n \n const goldenFile = \"testdata/video-001.png\"\n@@ -26,11 +28,11 @@ var imageTests = []imageTest{\n \t//{\"testdata/video-001.bmp\", 0},\n \t// GIF images are restricted to a 256-color palette and the conversion\n \t// to GIF loses significant image quality.\n-\t//{\"testdata/video-001.gif\", 64<<8},\n+\t{\"testdata/video-001.gif\", 64 << 8},\n \t// JPEG is a lossy format and hence needs a non-zero tolerance.\n \t{\"testdata/video-001.jpeg\", 8 << 8},\n \t{\"testdata/video-001.png\", 0},\n-\t//{\"testdata/video-001.tiff\", 0},\n+\t{\"testdata/video-001.tiff\", 0},\n }\n \n func decode(filename string) (image.Image, string, os.Error) {"}, {"sha": "b4859325e1dbedb4d96d63a67d505c22d45885d7", "filename": "libgo/go/image/format.go", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Fformat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Fformat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fformat.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -25,7 +25,8 @@ var formats []format\n \n // RegisterFormat registers an image format for use by Decode.\n // Name is the name of the format, like \"jpeg\" or \"png\".\n-// Magic is the magic prefix that identifies the format's encoding.\n+// Magic is the magic prefix that identifies the format's encoding. The magic\n+// string can contain \"?\" wildcards that each match any one byte.\n // Decode is the function that decodes the encoded image.\n // DecodeConfig is the function that decodes just its configuration.\n func RegisterFormat(name, magic string, decode func(io.Reader) (Image, os.Error), decodeConfig func(io.Reader) (Config, os.Error)) {\n@@ -46,11 +47,24 @@ func asReader(r io.Reader) reader {\n \treturn bufio.NewReader(r)\n }\n \n-// sniff determines the format of r's data.\n+// Match returns whether magic matches b. Magic may contain \"?\" wildcards.\n+func match(magic string, b []byte) bool {\n+\tif len(magic) != len(b) {\n+\t\treturn false\n+\t}\n+\tfor i, c := range b {\n+\t\tif magic[i] != c && magic[i] != '?' {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+// Sniff determines the format of r's data.\n func sniff(r reader) format {\n \tfor _, f := range formats {\n-\t\ts, err := r.Peek(len(f.magic))\n-\t\tif err == nil && string(s) == f.magic {\n+\t\tb, err := r.Peek(len(f.magic))\n+\t\tif err == nil && match(f.magic, b) {\n \t\t\treturn f\n \t\t}\n \t}"}, {"sha": "d37f52689eec75325ddb56894d84518ca08e9f07", "filename": "libgo/go/image/gif/reader.go", "status": "added", "additions": 392, "deletions": 0, "changes": 392, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Fgif%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Fgif%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fgif%2Freader.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -0,0 +1,392 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package gif implements a GIF image decoder.\n+//\n+// The GIF specification is at http://www.w3.org/Graphics/GIF/spec-gif89a.txt.\n+package gif\n+\n+import (\n+\t\"bufio\"\n+\t\"compress/lzw\"\n+\t\"fmt\"\n+\t\"image\"\n+\t\"io\"\n+\t\"os\"\n+)\n+\n+// If the io.Reader does not also have ReadByte, then decode will introduce its own buffering.\n+type reader interface {\n+\tio.Reader\n+\tio.ByteReader\n+}\n+\n+// Masks etc.\n+const (\n+\t// Fields.\n+\tfColorMapFollows = 1 << 7\n+\n+\t// Image fields.\n+\tifInterlace = 1 << 6\n+\n+\t// Graphic control flags.\n+\tgcTransparentColorSet = 1 << 0\n+)\n+\n+// Section indicators.\n+const (\n+\tsExtension       = 0x21\n+\tsImageDescriptor = 0x2C\n+\tsTrailer         = 0x3B\n+)\n+\n+// Extensions.\n+const (\n+\teText           = 0x01 // Plain Text\n+\teGraphicControl = 0xF9 // Graphic Control\n+\teComment        = 0xFE // Comment\n+\teApplication    = 0xFF // Application\n+)\n+\n+// decoder is the type used to decode a GIF file.\n+type decoder struct {\n+\tr reader\n+\n+\t// From header.\n+\tvers            string\n+\twidth           int\n+\theight          int\n+\tflags           byte\n+\theaderFields    byte\n+\tbackgroundIndex byte\n+\tloopCount       int\n+\tdelayTime       int\n+\n+\t// Unused from header.\n+\taspect byte\n+\n+\t// From image descriptor.\n+\timageFields byte\n+\n+\t// From graphics control.\n+\ttransparentIndex byte\n+\n+\t// Computed.\n+\tpixelSize      uint\n+\tglobalColorMap image.PalettedColorModel\n+\n+\t// Used when decoding.\n+\tdelay []int\n+\timage []*image.Paletted\n+\ttmp   [1024]byte // must be at least 768 so we can read color map\n+}\n+\n+// blockReader parses the block structure of GIF image data, which\n+// comprises (n, (n bytes)) blocks, with 1 <= n <= 255.  It is the\n+// reader given to the LZW decoder, which is thus immune to the\n+// blocking.  After the LZW decoder completes, there will be a 0-byte\n+// block remaining (0, ()), but under normal execution blockReader\n+// doesn't consume it, so it is handled in decode.\n+type blockReader struct {\n+\tr     reader\n+\tslice []byte\n+\ttmp   [256]byte\n+}\n+\n+func (b *blockReader) Read(p []byte) (n int, err os.Error) {\n+\tif len(p) == 0 {\n+\t\treturn\n+\t}\n+\tif len(b.slice) > 0 {\n+\t\tn = copy(p, b.slice)\n+\t\tb.slice = b.slice[n:]\n+\t\treturn\n+\t}\n+\tvar blockLen uint8\n+\tblockLen, err = b.r.ReadByte()\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tif blockLen == 0 {\n+\t\treturn 0, os.EOF\n+\t}\n+\tb.slice = b.tmp[0:blockLen]\n+\tif _, err = io.ReadFull(b.r, b.slice); err != nil {\n+\t\treturn\n+\t}\n+\treturn b.Read(p)\n+}\n+\n+// decode reads a GIF image from r and stores the result in d.\n+func (d *decoder) decode(r io.Reader, configOnly bool) os.Error {\n+\t// Add buffering if r does not provide ReadByte.\n+\tif rr, ok := r.(reader); ok {\n+\t\td.r = rr\n+\t} else {\n+\t\td.r = bufio.NewReader(r)\n+\t}\n+\n+\terr := d.readHeaderAndScreenDescriptor()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif configOnly {\n+\t\treturn nil\n+\t}\n+\n+\tif d.headerFields&fColorMapFollows != 0 {\n+\t\tif d.globalColorMap, err = d.readColorMap(); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\td.image = nil\n+\n+Loop:\n+\tfor err == nil {\n+\t\tvar c byte\n+\t\tc, err = d.r.ReadByte()\n+\t\tif err == os.EOF {\n+\t\t\tbreak\n+\t\t}\n+\t\tswitch c {\n+\t\tcase sExtension:\n+\t\t\terr = d.readExtension()\n+\n+\t\tcase sImageDescriptor:\n+\t\t\tvar m *image.Paletted\n+\t\t\tm, err = d.newImageFromDescriptor()\n+\t\t\tif err != nil {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tif d.imageFields&fColorMapFollows != 0 {\n+\t\t\t\tm.Palette, err = d.readColorMap()\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\t// TODO: do we set transparency in this map too? That would be\n+\t\t\t\t// d.setTransparency(m.Palette)\n+\t\t\t} else {\n+\t\t\t\tm.Palette = d.globalColorMap\n+\t\t\t}\n+\t\t\tvar litWidth uint8\n+\t\t\tlitWidth, err = d.r.ReadByte()\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tif litWidth > 8 {\n+\t\t\t\treturn fmt.Errorf(\"gif: pixel size in decode out of range: %d\", litWidth)\n+\t\t\t}\n+\t\t\t// A wonderfully Go-like piece of magic. Unfortunately it's only at its\n+\t\t\t// best for 8-bit pixels.\n+\t\t\tlzwr := lzw.NewReader(&blockReader{r: d.r}, lzw.LSB, int(litWidth))\n+\t\t\tif _, err = io.ReadFull(lzwr, m.Pix); err != nil {\n+\t\t\t\tbreak\n+\t\t\t}\n+\n+\t\t\t// There should be a \"0\" block remaining; drain that.\n+\t\t\tc, err = d.r.ReadByte()\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tif c != 0 {\n+\t\t\t\treturn os.ErrorString(\"gif: extra data after image\")\n+\t\t\t}\n+\t\t\td.image = append(d.image, m)\n+\t\t\td.delay = append(d.delay, d.delayTime)\n+\t\t\td.delayTime = 0 // TODO: is this correct, or should we hold on to the value?\n+\n+\t\tcase sTrailer:\n+\t\t\tbreak Loop\n+\n+\t\tdefault:\n+\t\t\terr = fmt.Errorf(\"gif: unknown block type: 0x%.2x\", c)\n+\t\t}\n+\t}\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif len(d.image) == 0 {\n+\t\treturn io.ErrUnexpectedEOF\n+\t}\n+\treturn nil\n+}\n+\n+func (d *decoder) readHeaderAndScreenDescriptor() os.Error {\n+\t_, err := io.ReadFull(d.r, d.tmp[0:13])\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\td.vers = string(d.tmp[0:6])\n+\tif d.vers != \"GIF87a\" && d.vers != \"GIF89a\" {\n+\t\treturn fmt.Errorf(\"gif: can't recognize format %s\", d.vers)\n+\t}\n+\td.width = int(d.tmp[6]) + int(d.tmp[7])<<8\n+\td.height = int(d.tmp[8]) + int(d.tmp[9])<<8\n+\td.headerFields = d.tmp[10]\n+\td.backgroundIndex = d.tmp[11]\n+\td.aspect = d.tmp[12]\n+\td.loopCount = -1\n+\td.pixelSize = uint(d.headerFields&7) + 1\n+\treturn nil\n+}\n+\n+func (d *decoder) readColorMap() (image.PalettedColorModel, os.Error) {\n+\tif d.pixelSize > 8 {\n+\t\treturn nil, fmt.Errorf(\"gif: can't handle %d bits per pixel\", d.pixelSize)\n+\t}\n+\tnumColors := 1 << d.pixelSize\n+\tnumValues := 3 * numColors\n+\t_, err := io.ReadFull(d.r, d.tmp[0:numValues])\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"gif: short read on color map: %s\", err)\n+\t}\n+\tcolorMap := make(image.PalettedColorModel, numColors)\n+\tj := 0\n+\tfor i := range colorMap {\n+\t\tcolorMap[i] = image.RGBAColor{d.tmp[j+0], d.tmp[j+1], d.tmp[j+2], 0xFF}\n+\t\tj += 3\n+\t}\n+\treturn colorMap, nil\n+}\n+\n+func (d *decoder) readExtension() os.Error {\n+\textension, err := d.r.ReadByte()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tsize := 0\n+\tswitch extension {\n+\tcase eText:\n+\t\tsize = 13\n+\tcase eGraphicControl:\n+\t\treturn d.readGraphicControl()\n+\tcase eComment:\n+\t\t// nothing to do but read the data.\n+\tcase eApplication:\n+\t\tb, err := d.r.ReadByte()\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t// The spec requires size be 11, but Adobe sometimes uses 10.\n+\t\tsize = int(b)\n+\tdefault:\n+\t\treturn fmt.Errorf(\"gif: unknown extension 0x%.2x\", extension)\n+\t}\n+\tif size > 0 {\n+\t\tif _, err := d.r.Read(d.tmp[0:size]); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\t// Application Extension with \"NETSCAPE2.0\" as string and 1 in data means\n+\t// this extension defines a loop count.\n+\tif extension == eApplication && string(d.tmp[:size]) == \"NETSCAPE2.0\" {\n+\t\tn, err := d.readBlock()\n+\t\tif n == 0 || err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif n == 3 && d.tmp[0] == 1 {\n+\t\t\td.loopCount = int(d.tmp[1]) | int(d.tmp[2])<<8\n+\t\t}\n+\t}\n+\tfor {\n+\t\tn, err := d.readBlock()\n+\t\tif n == 0 || err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\tpanic(\"unreachable\")\n+}\n+\n+func (d *decoder) readGraphicControl() os.Error {\n+\tif _, err := io.ReadFull(d.r, d.tmp[0:6]); err != nil {\n+\t\treturn fmt.Errorf(\"gif: can't read graphic control: %s\", err)\n+\t}\n+\td.flags = d.tmp[1]\n+\td.delayTime = int(d.tmp[2]) | int(d.tmp[3])<<8\n+\tif d.flags&gcTransparentColorSet != 0 {\n+\t\td.transparentIndex = d.tmp[4]\n+\t\td.setTransparency(d.globalColorMap)\n+\t}\n+\treturn nil\n+}\n+\n+func (d *decoder) setTransparency(colorMap image.PalettedColorModel) {\n+\tif int(d.transparentIndex) < len(colorMap) {\n+\t\tcolorMap[d.transparentIndex] = image.RGBAColor{}\n+\t}\n+}\n+\n+func (d *decoder) newImageFromDescriptor() (*image.Paletted, os.Error) {\n+\tif _, err := io.ReadFull(d.r, d.tmp[0:9]); err != nil {\n+\t\treturn nil, fmt.Errorf(\"gif: can't read image descriptor: %s\", err)\n+\t}\n+\t_ = int(d.tmp[0]) + int(d.tmp[1])<<8 // TODO: honor left value\n+\t_ = int(d.tmp[2]) + int(d.tmp[3])<<8 // TODO: honor top value\n+\twidth := int(d.tmp[4]) + int(d.tmp[5])<<8\n+\theight := int(d.tmp[6]) + int(d.tmp[7])<<8\n+\td.imageFields = d.tmp[8]\n+\tif d.imageFields&ifInterlace != 0 {\n+\t\treturn nil, os.ErrorString(\"gif: can't handle interlaced images\")\n+\t}\n+\treturn image.NewPaletted(width, height, nil), nil\n+}\n+\n+func (d *decoder) readBlock() (int, os.Error) {\n+\tn, err := d.r.ReadByte()\n+\tif n == 0 || err != nil {\n+\t\treturn 0, err\n+\t}\n+\treturn io.ReadFull(d.r, d.tmp[0:n])\n+}\n+\n+// Decode reads a GIF image from r and returns the first embedded\n+// image as an image.Image.\n+// Limitation: The file must be 8 bits per pixel and have no interlacing.\n+func Decode(r io.Reader) (image.Image, os.Error) {\n+\tvar d decoder\n+\tif err := d.decode(r, false); err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn d.image[0], nil\n+}\n+\n+// GIF represents the possibly multiple images stored in a GIF file.\n+type GIF struct {\n+\tImage     []*image.Paletted // The successive images.\n+\tDelay     []int             // The successive delay times, one per frame, in 100ths of a second.\n+\tLoopCount int               // The loop count.\n+}\n+\n+// DecodeAll reads a GIF image from r and returns the sequential frames\n+// and timing information.\n+// Limitation: The file must be 8 bits per pixel and have no interlacing.\n+func DecodeAll(r io.Reader) (*GIF, os.Error) {\n+\tvar d decoder\n+\tif err := d.decode(r, false); err != nil {\n+\t\treturn nil, err\n+\t}\n+\tgif := &GIF{\n+\t\tImage:     d.image,\n+\t\tLoopCount: d.loopCount,\n+\t\tDelay:     d.delay,\n+\t}\n+\treturn gif, nil\n+}\n+\n+// DecodeConfig returns the color model and dimensions of a GIF image without\n+// decoding the entire image.\n+func DecodeConfig(r io.Reader) (image.Config, os.Error) {\n+\tvar d decoder\n+\tif err := d.decode(r, true); err != nil {\n+\t\treturn image.Config{}, err\n+\t}\n+\tcolorMap := d.globalColorMap\n+\treturn image.Config{colorMap, d.width, d.height}, nil\n+}\n+\n+func init() {\n+\timage.RegisterFormat(\"gif\", \"GIF8?a\", Decode, DecodeConfig)\n+}"}, {"sha": "4350acc82036f2a5cbd7591926ffe3377a0b512a", "filename": "libgo/go/image/image.go", "status": "modified", "additions": 57, "deletions": 1, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Fimage.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Fimage.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fimage.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// The image package implements a basic 2-D image library.\n+// Package image implements a basic 2-D image library.\n package image\n \n // A Config consists of an image's color model and dimensions.\n@@ -51,6 +51,13 @@ func (p *RGBA) Set(x, y int, c Color) {\n \tp.Pix[y*p.Stride+x] = toRGBAColor(c).(RGBAColor)\n }\n \n+func (p *RGBA) SetRGBA(x, y int, c RGBAColor) {\n+\tif !p.Rect.Contains(Point{x, y}) {\n+\t\treturn\n+\t}\n+\tp.Pix[y*p.Stride+x] = c\n+}\n+\n // Opaque scans the entire image and returns whether or not it is fully opaque.\n func (p *RGBA) Opaque() bool {\n \tif p.Rect.Empty() {\n@@ -103,6 +110,13 @@ func (p *RGBA64) Set(x, y int, c Color) {\n \tp.Pix[y*p.Stride+x] = toRGBA64Color(c).(RGBA64Color)\n }\n \n+func (p *RGBA64) SetRGBA64(x, y int, c RGBA64Color) {\n+\tif !p.Rect.Contains(Point{x, y}) {\n+\t\treturn\n+\t}\n+\tp.Pix[y*p.Stride+x] = c\n+}\n+\n // Opaque scans the entire image and returns whether or not it is fully opaque.\n func (p *RGBA64) Opaque() bool {\n \tif p.Rect.Empty() {\n@@ -155,6 +169,13 @@ func (p *NRGBA) Set(x, y int, c Color) {\n \tp.Pix[y*p.Stride+x] = toNRGBAColor(c).(NRGBAColor)\n }\n \n+func (p *NRGBA) SetNRGBA(x, y int, c NRGBAColor) {\n+\tif !p.Rect.Contains(Point{x, y}) {\n+\t\treturn\n+\t}\n+\tp.Pix[y*p.Stride+x] = c\n+}\n+\n // Opaque scans the entire image and returns whether or not it is fully opaque.\n func (p *NRGBA) Opaque() bool {\n \tif p.Rect.Empty() {\n@@ -207,6 +228,13 @@ func (p *NRGBA64) Set(x, y int, c Color) {\n \tp.Pix[y*p.Stride+x] = toNRGBA64Color(c).(NRGBA64Color)\n }\n \n+func (p *NRGBA64) SetNRGBA64(x, y int, c NRGBA64Color) {\n+\tif !p.Rect.Contains(Point{x, y}) {\n+\t\treturn\n+\t}\n+\tp.Pix[y*p.Stride+x] = c\n+}\n+\n // Opaque scans the entire image and returns whether or not it is fully opaque.\n func (p *NRGBA64) Opaque() bool {\n \tif p.Rect.Empty() {\n@@ -259,6 +287,13 @@ func (p *Alpha) Set(x, y int, c Color) {\n \tp.Pix[y*p.Stride+x] = toAlphaColor(c).(AlphaColor)\n }\n \n+func (p *Alpha) SetAlpha(x, y int, c AlphaColor) {\n+\tif !p.Rect.Contains(Point{x, y}) {\n+\t\treturn\n+\t}\n+\tp.Pix[y*p.Stride+x] = c\n+}\n+\n // Opaque scans the entire image and returns whether or not it is fully opaque.\n func (p *Alpha) Opaque() bool {\n \tif p.Rect.Empty() {\n@@ -311,6 +346,13 @@ func (p *Alpha16) Set(x, y int, c Color) {\n \tp.Pix[y*p.Stride+x] = toAlpha16Color(c).(Alpha16Color)\n }\n \n+func (p *Alpha16) SetAlpha16(x, y int, c Alpha16Color) {\n+\tif !p.Rect.Contains(Point{x, y}) {\n+\t\treturn\n+\t}\n+\tp.Pix[y*p.Stride+x] = c\n+}\n+\n // Opaque scans the entire image and returns whether or not it is fully opaque.\n func (p *Alpha16) Opaque() bool {\n \tif p.Rect.Empty() {\n@@ -363,6 +405,13 @@ func (p *Gray) Set(x, y int, c Color) {\n \tp.Pix[y*p.Stride+x] = toGrayColor(c).(GrayColor)\n }\n \n+func (p *Gray) SetGray(x, y int, c GrayColor) {\n+\tif !p.Rect.Contains(Point{x, y}) {\n+\t\treturn\n+\t}\n+\tp.Pix[y*p.Stride+x] = c\n+}\n+\n // Opaque scans the entire image and returns whether or not it is fully opaque.\n func (p *Gray) Opaque() bool {\n \treturn true\n@@ -401,6 +450,13 @@ func (p *Gray16) Set(x, y int, c Color) {\n \tp.Pix[y*p.Stride+x] = toGray16Color(c).(Gray16Color)\n }\n \n+func (p *Gray16) SetGray16(x, y int, c Gray16Color) {\n+\tif !p.Rect.Contains(Point{x, y}) {\n+\t\treturn\n+\t}\n+\tp.Pix[y*p.Stride+x] = c\n+}\n+\n // Opaque scans the entire image and returns whether or not it is fully opaque.\n func (p *Gray16) Opaque() bool {\n \treturn true"}, {"sha": "3f8be4e32608e2444bf0592588c61b72aef19998", "filename": "libgo/go/image/jpeg/fdct.go", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Fjpeg%2Ffdct.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Fjpeg%2Ffdct.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Ffdct.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -0,0 +1,190 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package jpeg\n+\n+// This file implements a Forward Discrete Cosine Transformation.\n+\n+/*\n+It is based on the code in jfdctint.c from the Independent JPEG Group,\n+found at http://www.ijg.org/files/jpegsrc.v8c.tar.gz.\n+\n+The \"LEGAL ISSUES\" section of the README in that archive says:\n+\n+In plain English:\n+\n+1. We don't promise that this software works.  (But if you find any bugs,\n+   please let us know!)\n+2. You can use this software for whatever you want.  You don't have to pay us.\n+3. You may not pretend that you wrote this software.  If you use it in a\n+   program, you must acknowledge somewhere in your documentation that\n+   you've used the IJG code.\n+\n+In legalese:\n+\n+The authors make NO WARRANTY or representation, either express or implied,\n+with respect to this software, its quality, accuracy, merchantability, or\n+fitness for a particular purpose.  This software is provided \"AS IS\", and you,\n+its user, assume the entire risk as to its quality and accuracy.\n+\n+This software is copyright (C) 1991-2011, Thomas G. Lane, Guido Vollbeding.\n+All Rights Reserved except as specified below.\n+\n+Permission is hereby granted to use, copy, modify, and distribute this\n+software (or portions thereof) for any purpose, without fee, subject to these\n+conditions:\n+(1) If any part of the source code for this software is distributed, then this\n+README file must be included, with this copyright and no-warranty notice\n+unaltered; and any additions, deletions, or changes to the original files\n+must be clearly indicated in accompanying documentation.\n+(2) If only executable code is distributed, then the accompanying\n+documentation must state that \"this software is based in part on the work of\n+the Independent JPEG Group\".\n+(3) Permission for use of this software is granted only if the user accepts\n+full responsibility for any undesirable consequences; the authors accept\n+NO LIABILITY for damages of any kind.\n+\n+These conditions apply to any software derived from or based on the IJG code,\n+not just to the unmodified library.  If you use our work, you ought to\n+acknowledge us.\n+\n+Permission is NOT granted for the use of any IJG author's name or company name\n+in advertising or publicity relating to this software or products derived from\n+it.  This software may be referred to only as \"the Independent JPEG Group's\n+software\".\n+\n+We specifically permit and encourage the use of this software as the basis of\n+commercial products, provided that all warranty or liability claims are\n+assumed by the product vendor.\n+*/\n+\n+// Trigonometric constants in 13-bit fixed point format.\n+const (\n+\tfix_0_298631336 = 2446\n+\tfix_0_390180644 = 3196\n+\tfix_0_541196100 = 4433\n+\tfix_0_765366865 = 6270\n+\tfix_0_899976223 = 7373\n+\tfix_1_175875602 = 9633\n+\tfix_1_501321110 = 12299\n+\tfix_1_847759065 = 15137\n+\tfix_1_961570560 = 16069\n+\tfix_2_053119869 = 16819\n+\tfix_2_562915447 = 20995\n+\tfix_3_072711026 = 25172\n+)\n+\n+const (\n+\tconstBits     = 13\n+\tpass1Bits     = 2\n+\tcenterJSample = 128\n+)\n+\n+// fdct performs a forward DCT on an 8x8 block of coefficients, including a\n+// level shift.\n+func fdct(b *block) {\n+\t// Pass 1: process rows.\n+\tfor y := 0; y < 8; y++ {\n+\t\tx0 := b[y*8+0]\n+\t\tx1 := b[y*8+1]\n+\t\tx2 := b[y*8+2]\n+\t\tx3 := b[y*8+3]\n+\t\tx4 := b[y*8+4]\n+\t\tx5 := b[y*8+5]\n+\t\tx6 := b[y*8+6]\n+\t\tx7 := b[y*8+7]\n+\n+\t\ttmp0 := x0 + x7\n+\t\ttmp1 := x1 + x6\n+\t\ttmp2 := x2 + x5\n+\t\ttmp3 := x3 + x4\n+\n+\t\ttmp10 := tmp0 + tmp3\n+\t\ttmp12 := tmp0 - tmp3\n+\t\ttmp11 := tmp1 + tmp2\n+\t\ttmp13 := tmp1 - tmp2\n+\n+\t\ttmp0 = x0 - x7\n+\t\ttmp1 = x1 - x6\n+\t\ttmp2 = x2 - x5\n+\t\ttmp3 = x3 - x4\n+\n+\t\tb[y*8+0] = (tmp10 + tmp11 - 8*centerJSample) << pass1Bits\n+\t\tb[y*8+4] = (tmp10 - tmp11) << pass1Bits\n+\t\tz1 := (tmp12 + tmp13) * fix_0_541196100\n+\t\tz1 += 1 << (constBits - pass1Bits - 1)\n+\t\tb[y*8+2] = (z1 + tmp12*fix_0_765366865) >> (constBits - pass1Bits)\n+\t\tb[y*8+6] = (z1 - tmp13*fix_1_847759065) >> (constBits - pass1Bits)\n+\n+\t\ttmp10 = tmp0 + tmp3\n+\t\ttmp11 = tmp1 + tmp2\n+\t\ttmp12 = tmp0 + tmp2\n+\t\ttmp13 = tmp1 + tmp3\n+\t\tz1 = (tmp12 + tmp13) * fix_1_175875602\n+\t\tz1 += 1 << (constBits - pass1Bits - 1)\n+\t\ttmp0 = tmp0 * fix_1_501321110\n+\t\ttmp1 = tmp1 * fix_3_072711026\n+\t\ttmp2 = tmp2 * fix_2_053119869\n+\t\ttmp3 = tmp3 * fix_0_298631336\n+\t\ttmp10 = tmp10 * -fix_0_899976223\n+\t\ttmp11 = tmp11 * -fix_2_562915447\n+\t\ttmp12 = tmp12 * -fix_0_390180644\n+\t\ttmp13 = tmp13 * -fix_1_961570560\n+\n+\t\ttmp12 += z1\n+\t\ttmp13 += z1\n+\t\tb[y*8+1] = (tmp0 + tmp10 + tmp12) >> (constBits - pass1Bits)\n+\t\tb[y*8+3] = (tmp1 + tmp11 + tmp13) >> (constBits - pass1Bits)\n+\t\tb[y*8+5] = (tmp2 + tmp11 + tmp12) >> (constBits - pass1Bits)\n+\t\tb[y*8+7] = (tmp3 + tmp10 + tmp13) >> (constBits - pass1Bits)\n+\t}\n+\t// Pass 2: process columns.\n+\t// We remove pass1Bits scaling, but leave results scaled up by an overall factor of 8.\n+\tfor x := 0; x < 8; x++ {\n+\t\ttmp0 := b[0*8+x] + b[7*8+x]\n+\t\ttmp1 := b[1*8+x] + b[6*8+x]\n+\t\ttmp2 := b[2*8+x] + b[5*8+x]\n+\t\ttmp3 := b[3*8+x] + b[4*8+x]\n+\n+\t\ttmp10 := tmp0 + tmp3 + 1<<(pass1Bits-1)\n+\t\ttmp12 := tmp0 - tmp3\n+\t\ttmp11 := tmp1 + tmp2\n+\t\ttmp13 := tmp1 - tmp2\n+\n+\t\ttmp0 = b[0*8+x] - b[7*8+x]\n+\t\ttmp1 = b[1*8+x] - b[6*8+x]\n+\t\ttmp2 = b[2*8+x] - b[5*8+x]\n+\t\ttmp3 = b[3*8+x] - b[4*8+x]\n+\n+\t\tb[0*8+x] = (tmp10 + tmp11) >> pass1Bits\n+\t\tb[4*8+x] = (tmp10 - tmp11) >> pass1Bits\n+\n+\t\tz1 := (tmp12 + tmp13) * fix_0_541196100\n+\t\tz1 += 1 << (constBits + pass1Bits - 1)\n+\t\tb[2*8+x] = (z1 + tmp12*fix_0_765366865) >> (constBits + pass1Bits)\n+\t\tb[6*8+x] = (z1 - tmp13*fix_1_847759065) >> (constBits + pass1Bits)\n+\n+\t\ttmp10 = tmp0 + tmp3\n+\t\ttmp11 = tmp1 + tmp2\n+\t\ttmp12 = tmp0 + tmp2\n+\t\ttmp13 = tmp1 + tmp3\n+\t\tz1 = (tmp12 + tmp13) * fix_1_175875602\n+\t\tz1 += 1 << (constBits + pass1Bits - 1)\n+\t\ttmp0 = tmp0 * fix_1_501321110\n+\t\ttmp1 = tmp1 * fix_3_072711026\n+\t\ttmp2 = tmp2 * fix_2_053119869\n+\t\ttmp3 = tmp3 * fix_0_298631336\n+\t\ttmp10 = tmp10 * -fix_0_899976223\n+\t\ttmp11 = tmp11 * -fix_2_562915447\n+\t\ttmp12 = tmp12 * -fix_0_390180644\n+\t\ttmp13 = tmp13 * -fix_1_961570560\n+\n+\t\ttmp12 += z1\n+\t\ttmp13 += z1\n+\t\tb[1*8+x] = (tmp0 + tmp10 + tmp12) >> (constBits + pass1Bits)\n+\t\tb[3*8+x] = (tmp1 + tmp11 + tmp13) >> (constBits + pass1Bits)\n+\t\tb[5*8+x] = (tmp2 + tmp11 + tmp12) >> (constBits + pass1Bits)\n+\t\tb[7*8+x] = (tmp3 + tmp10 + tmp13) >> (constBits + pass1Bits)\n+\t}\n+}"}, {"sha": "e5a2f40f5db7bcce89e9ddc715c2e408c4ab7dbd", "filename": "libgo/go/image/jpeg/idct.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Fjpeg%2Fidct.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Fjpeg%2Fidct.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Fidct.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -63,7 +63,7 @@ const (\n //\n // For more on the actual algorithm, see Z. Wang, \"Fast algorithms for the discrete W transform and\n // for the discrete Fourier transform\", IEEE Trans. on ASSP, Vol. ASSP- 32, pp. 803-816, Aug. 1984.\n-func idct(b *[blockSize]int) {\n+func idct(b *block) {\n \t// Horizontal 1-D IDCT.\n \tfor y := 0; y < 8; y++ {\n \t\t// If all the AC components are zero, then the IDCT is trivial."}, {"sha": "21a6fff969824163fce9be1b68a98f61daef40e6", "filename": "libgo/go/image/jpeg/reader.go", "status": "modified", "additions": 80, "deletions": 74, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Fjpeg%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Fjpeg%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Freader.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,18 +2,22 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// The jpeg package implements a decoder for JPEG images, as defined in ITU-T T.81.\n+// Package jpeg implements a JPEG image decoder and encoder.\n+//\n+// JPEG is defined in ITU-T T.81: http://www.w3.org/Graphics/JPEG/itu-t81.pdf.\n package jpeg\n \n-// See http://www.w3.org/Graphics/JPEG/itu-t81.pdf\n-\n import (\n \t\"bufio\"\n \t\"image\"\n+\t\"image/ycbcr\"\n \t\"io\"\n \t\"os\"\n )\n \n+// TODO(nigeltao): fix up the doc comment style so that sentences start with\n+// the name of the type or function that they annotate.\n+\n // A FormatError reports that the input is not a valid JPEG.\n type FormatError string\n \n@@ -26,12 +30,14 @@ func (e UnsupportedError) String() string { return \"unsupported JPEG feature: \"\n \n // Component specification, specified in section B.2.2.\n type component struct {\n+\th  int   // Horizontal sampling factor.\n+\tv  int   // Vertical sampling factor.\n \tc  uint8 // Component identifier.\n-\th  uint8 // Horizontal sampling factor.\n-\tv  uint8 // Vertical sampling factor.\n \ttq uint8 // Quantization table destination selector.\n }\n \n+type block [blockSize]int\n+\n const (\n \tblockSize = 64 // A DCT block is 8x8.\n \n@@ -84,13 +90,13 @@ type Reader interface {\n type decoder struct {\n \tr             Reader\n \twidth, height int\n-\timage         *image.RGBA\n+\timg           *ycbcr.YCbCr\n \tri            int // Restart Interval.\n \tcomps         [nComponent]component\n \thuff          [maxTc + 1][maxTh + 1]huffman\n-\tquant         [maxTq + 1][blockSize]int\n+\tquant         [maxTq + 1]block\n \tb             bits\n-\tblocks        [nComponent][maxH * maxV][blockSize]int\n+\tblocks        [nComponent][maxH * maxV]block\n \ttmp           [1024]byte\n }\n \n@@ -130,9 +136,9 @@ func (d *decoder) processSOF(n int) os.Error {\n \t}\n \tfor i := 0; i < nComponent; i++ {\n \t\thv := d.tmp[7+3*i]\n+\t\td.comps[i].h = int(hv >> 4)\n+\t\td.comps[i].v = int(hv & 0x0f)\n \t\td.comps[i].c = d.tmp[6+3*i]\n-\t\td.comps[i].h = hv >> 4\n-\t\td.comps[i].v = hv & 0x0f\n \t\td.comps[i].tq = d.tmp[8+3*i]\n \t\t// We only support YCbCr images, and 4:4:4, 4:2:2 or 4:2:0 chroma downsampling ratios. This implies that\n \t\t// the (h, v) values for the Y component are either (1, 1), (2, 1) or (2, 2), and the\n@@ -176,71 +182,47 @@ func (d *decoder) processDQT(n int) os.Error {\n \treturn nil\n }\n \n-// Set the Pixel (px, py)'s RGB value, based on its YCbCr value.\n-func (d *decoder) calcPixel(px, py, lumaBlock, lumaIndex, chromaIndex int) {\n-\ty, cb, cr := d.blocks[0][lumaBlock][lumaIndex], d.blocks[1][0][chromaIndex], d.blocks[2][0][chromaIndex]\n-\t// The JFIF specification (http://www.w3.org/Graphics/JPEG/jfif3.pdf, page 3) gives the formula\n-\t// for translating YCbCr to RGB as:\n-\t//   R = Y + 1.402 (Cr-128)\n-\t//   G = Y - 0.34414 (Cb-128) - 0.71414 (Cr-128)\n-\t//   B = Y + 1.772 (Cb-128)\n-\tyPlusHalf := 100000*y + 50000\n-\tcb -= 128\n-\tcr -= 128\n-\tr := (yPlusHalf + 140200*cr) / 100000\n-\tg := (yPlusHalf - 34414*cb - 71414*cr) / 100000\n-\tb := (yPlusHalf + 177200*cb) / 100000\n-\tif r < 0 {\n-\t\tr = 0\n-\t} else if r > 255 {\n-\t\tr = 255\n+// Clip x to the range [0, 255] inclusive.\n+func clip(x int) uint8 {\n+\tif x < 0 {\n+\t\treturn 0\n \t}\n-\tif g < 0 {\n-\t\tg = 0\n-\t} else if g > 255 {\n-\t\tg = 255\n+\tif x > 255 {\n+\t\treturn 255\n \t}\n-\tif b < 0 {\n-\t\tb = 0\n-\t} else if b > 255 {\n-\t\tb = 255\n-\t}\n-\td.image.Pix[py*d.image.Stride+px] = image.RGBAColor{uint8(r), uint8(g), uint8(b), 0xff}\n+\treturn uint8(x)\n }\n \n-// Convert the MCU from YCbCr to RGB.\n-func (d *decoder) convertMCU(mx, my, h0, v0 int) {\n-\tlumaBlock := 0\n+// Store the MCU to the image.\n+func (d *decoder) storeMCU(mx, my int) {\n+\th0, v0 := d.comps[0].h, d.comps[0].v\n+\t// Store the luma blocks.\n \tfor v := 0; v < v0; v++ {\n \t\tfor h := 0; h < h0; h++ {\n-\t\t\tchromaBase := 8*4*v + 4*h\n-\t\t\tpy := 8 * (v0*my + v)\n-\t\t\tfor y := 0; y < 8 && py < d.height; y++ {\n-\t\t\t\tpx := 8 * (h0*mx + h)\n-\t\t\t\tlumaIndex := 8 * y\n-\t\t\t\tchromaIndex := chromaBase + 8*(y/v0)\n-\t\t\t\tfor x := 0; x < 8 && px < d.width; x++ {\n-\t\t\t\t\td.calcPixel(px, py, lumaBlock, lumaIndex, chromaIndex)\n-\t\t\t\t\tif h0 == 1 {\n-\t\t\t\t\t\tchromaIndex += 1\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tchromaIndex += x % 2\n-\t\t\t\t\t}\n-\t\t\t\t\tlumaIndex++\n-\t\t\t\t\tpx++\n+\t\t\tp := 8 * ((v0*my+v)*d.img.YStride + (h0*mx + h))\n+\t\t\tfor y := 0; y < 8; y++ {\n+\t\t\t\tfor x := 0; x < 8; x++ {\n+\t\t\t\t\td.img.Y[p] = clip(d.blocks[0][h0*v+h][8*y+x])\n+\t\t\t\t\tp++\n \t\t\t\t}\n-\t\t\t\tpy++\n+\t\t\t\tp += d.img.YStride - 8\n \t\t\t}\n-\t\t\tlumaBlock++\n \t\t}\n \t}\n+\t// Store the chroma blocks.\n+\tp := 8 * (my*d.img.CStride + mx)\n+\tfor y := 0; y < 8; y++ {\n+\t\tfor x := 0; x < 8; x++ {\n+\t\t\td.img.Cb[p] = clip(d.blocks[1][0][8*y+x])\n+\t\t\td.img.Cr[p] = clip(d.blocks[2][0][8*y+x])\n+\t\t\tp++\n+\t\t}\n+\t\tp += d.img.CStride - 8\n+\t}\n }\n \n // Specified in section B.2.3.\n func (d *decoder) processSOS(n int) os.Error {\n-\tif d.image == nil {\n-\t\td.image = image.NewRGBA(d.width, d.height)\n-\t}\n \tif n != 4+2*nComponent {\n \t\treturn UnsupportedError(\"SOS has wrong length\")\n \t}\n@@ -255,7 +237,6 @@ func (d *decoder) processSOS(n int) os.Error {\n \t\ttd uint8 // DC table selector.\n \t\tta uint8 // AC table selector.\n \t}\n-\th0, v0 := int(d.comps[0].h), int(d.comps[0].v) // The h and v values from the Y components.\n \tfor i := 0; i < nComponent; i++ {\n \t\tcs := d.tmp[1+2*i] // Component selector.\n \t\tif cs != d.comps[i].c {\n@@ -265,17 +246,42 @@ func (d *decoder) processSOS(n int) os.Error {\n \t\tscanComps[i].ta = d.tmp[2+2*i] & 0x0f\n \t}\n \t// mxx and myy are the number of MCUs (Minimum Coded Units) in the image.\n-\tmxx := (d.width + 8*int(h0) - 1) / (8 * int(h0))\n-\tmyy := (d.height + 8*int(v0) - 1) / (8 * int(v0))\n+\th0, v0 := d.comps[0].h, d.comps[0].v // The h and v values from the Y components.\n+\tmxx := (d.width + 8*h0 - 1) / (8 * h0)\n+\tmyy := (d.height + 8*v0 - 1) / (8 * v0)\n+\tif d.img == nil {\n+\t\tvar subsampleRatio ycbcr.SubsampleRatio\n+\t\tn := h0 * v0\n+\t\tswitch n {\n+\t\tcase 1:\n+\t\t\tsubsampleRatio = ycbcr.SubsampleRatio444\n+\t\tcase 2:\n+\t\t\tsubsampleRatio = ycbcr.SubsampleRatio422\n+\t\tcase 4:\n+\t\t\tsubsampleRatio = ycbcr.SubsampleRatio420\n+\t\tdefault:\n+\t\t\tpanic(\"unreachable\")\n+\t\t}\n+\t\tb := make([]byte, mxx*myy*(1*8*8*n+2*8*8))\n+\t\td.img = &ycbcr.YCbCr{\n+\t\t\tY:              b[mxx*myy*(0*8*8*n+0*8*8) : mxx*myy*(1*8*8*n+0*8*8)],\n+\t\t\tCb:             b[mxx*myy*(1*8*8*n+0*8*8) : mxx*myy*(1*8*8*n+1*8*8)],\n+\t\t\tCr:             b[mxx*myy*(1*8*8*n+1*8*8) : mxx*myy*(1*8*8*n+2*8*8)],\n+\t\t\tSubsampleRatio: subsampleRatio,\n+\t\t\tYStride:        mxx * 8 * h0,\n+\t\t\tCStride:        mxx * 8,\n+\t\t\tRect:           image.Rect(0, 0, d.width, d.height),\n+\t\t}\n+\t}\n \n \tmcu, expectedRST := 0, uint8(rst0Marker)\n-\tvar allZeroes [blockSize]int\n+\tvar allZeroes block\n \tvar dc [nComponent]int\n \tfor my := 0; my < myy; my++ {\n \t\tfor mx := 0; mx < mxx; mx++ {\n \t\t\tfor i := 0; i < nComponent; i++ {\n \t\t\t\tqt := &d.quant[d.comps[i].tq]\n-\t\t\t\tfor j := 0; j < int(d.comps[i].h*d.comps[i].v); j++ {\n+\t\t\t\tfor j := 0; j < d.comps[i].h*d.comps[i].v; j++ {\n \t\t\t\t\td.blocks[i][j] = allZeroes\n \n \t\t\t\t\t// Decode the DC coefficient, as specified in section F.2.2.1.\n@@ -299,20 +305,20 @@ func (d *decoder) processSOS(n int) os.Error {\n \t\t\t\t\t\tif err != nil {\n \t\t\t\t\t\t\treturn err\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tv0 := value >> 4\n-\t\t\t\t\t\tv1 := value & 0x0f\n-\t\t\t\t\t\tif v1 != 0 {\n-\t\t\t\t\t\t\tk += int(v0)\n+\t\t\t\t\t\tval0 := value >> 4\n+\t\t\t\t\t\tval1 := value & 0x0f\n+\t\t\t\t\t\tif val1 != 0 {\n+\t\t\t\t\t\t\tk += int(val0)\n \t\t\t\t\t\t\tif k > blockSize {\n \t\t\t\t\t\t\t\treturn FormatError(\"bad DCT index\")\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tac, err := d.receiveExtend(v1)\n+\t\t\t\t\t\t\tac, err := d.receiveExtend(val1)\n \t\t\t\t\t\t\tif err != nil {\n \t\t\t\t\t\t\t\treturn err\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\td.blocks[i][j][unzig[k]] = ac * qt[k]\n \t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tif v0 != 0x0f {\n+\t\t\t\t\t\t\tif val0 != 0x0f {\n \t\t\t\t\t\t\t\tbreak\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tk += 0x0f\n@@ -322,7 +328,7 @@ func (d *decoder) processSOS(n int) os.Error {\n \t\t\t\t\tidct(&d.blocks[i][j])\n \t\t\t\t} // for j\n \t\t\t} // for i\n-\t\t\td.convertMCU(mx, my, int(d.comps[0].h), int(d.comps[0].v))\n+\t\t\td.storeMCU(mx, my)\n \t\t\tmcu++\n \t\t\tif d.ri > 0 && mcu%d.ri == 0 && mcu < mxx*myy {\n \t\t\t\t// A more sophisticated decoder could use RST[0-7] markers to resynchronize from corrupt input,\n@@ -431,7 +437,7 @@ func (d *decoder) decode(r io.Reader, configOnly bool) (image.Image, os.Error) {\n \t\t\treturn nil, err\n \t\t}\n \t}\n-\treturn d.image, nil\n+\treturn d.img, nil\n }\n \n // Decode reads a JPEG image from r and returns it as an image.Image."}, {"sha": "52b3dc4e2c1a3c474654d4aff6f1f90f48ab5dee", "filename": "libgo/go/image/jpeg/writer.go", "status": "added", "additions": 553, "deletions": 0, "changes": 553, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -0,0 +1,553 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package jpeg\n+\n+import (\n+\t\"bufio\"\n+\t\"image\"\n+\t\"image/ycbcr\"\n+\t\"io\"\n+\t\"os\"\n+)\n+\n+// min returns the minimum of two integers.\n+func min(x, y int) int {\n+\tif x < y {\n+\t\treturn x\n+\t}\n+\treturn y\n+}\n+\n+// div returns a/b rounded to the nearest integer, instead of rounded to zero.\n+func div(a int, b int) int {\n+\tif a >= 0 {\n+\t\treturn (a + (b >> 1)) / b\n+\t}\n+\treturn -((-a + (b >> 1)) / b)\n+}\n+\n+// bitCount counts the number of bits needed to hold an integer.\n+var bitCount = [256]byte{\n+\t0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,\n+\t5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+\t6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n+\t6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n+\t7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n+\t7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n+\t7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n+\t7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n+\t8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n+\t8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n+\t8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n+\t8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n+\t8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n+\t8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n+\t8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n+\t8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n+}\n+\n+type quantIndex int\n+\n+const (\n+\tquantIndexLuminance quantIndex = iota\n+\tquantIndexChrominance\n+\tnQuantIndex\n+)\n+\n+// unscaledQuant are the unscaled quantization tables. Each encoder copies and\n+// scales the tables according to its quality parameter.\n+var unscaledQuant = [nQuantIndex][blockSize]byte{\n+\t// Luminance.\n+\t{\n+\t\t16, 11, 10, 16, 24, 40, 51, 61,\n+\t\t12, 12, 14, 19, 26, 58, 60, 55,\n+\t\t14, 13, 16, 24, 40, 57, 69, 56,\n+\t\t14, 17, 22, 29, 51, 87, 80, 62,\n+\t\t18, 22, 37, 56, 68, 109, 103, 77,\n+\t\t24, 35, 55, 64, 81, 104, 113, 92,\n+\t\t49, 64, 78, 87, 103, 121, 120, 101,\n+\t\t72, 92, 95, 98, 112, 100, 103, 99,\n+\t},\n+\t// Chrominance.\n+\t{\n+\t\t17, 18, 24, 47, 99, 99, 99, 99,\n+\t\t18, 21, 26, 66, 99, 99, 99, 99,\n+\t\t24, 26, 56, 99, 99, 99, 99, 99,\n+\t\t47, 66, 99, 99, 99, 99, 99, 99,\n+\t\t99, 99, 99, 99, 99, 99, 99, 99,\n+\t\t99, 99, 99, 99, 99, 99, 99, 99,\n+\t\t99, 99, 99, 99, 99, 99, 99, 99,\n+\t\t99, 99, 99, 99, 99, 99, 99, 99,\n+\t},\n+}\n+\n+type huffIndex int\n+\n+const (\n+\thuffIndexLuminanceDC huffIndex = iota\n+\thuffIndexLuminanceAC\n+\thuffIndexChrominanceDC\n+\thuffIndexChrominanceAC\n+\tnHuffIndex\n+)\n+\n+// huffmanSpec specifies a Huffman encoding.\n+type huffmanSpec struct {\n+\t// count[i] is the number of codes of length i bits.\n+\tcount [16]byte\n+\t// value[i] is the decoded value of the i'th codeword.\n+\tvalue []byte\n+}\n+\n+// theHuffmanSpec is the Huffman encoding specifications.\n+// This encoder uses the same Huffman encoding for all images.\n+var theHuffmanSpec = [nHuffIndex]huffmanSpec{\n+\t// Luminance DC.\n+\t{\n+\t\t[16]byte{0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0},\n+\t\t[]byte{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11},\n+\t},\n+\t// Luminance AC.\n+\t{\n+\t\t[16]byte{0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125},\n+\t\t[]byte{\n+\t\t\t0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12,\n+\t\t\t0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07,\n+\t\t\t0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08,\n+\t\t\t0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0,\n+\t\t\t0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16,\n+\t\t\t0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28,\n+\t\t\t0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,\n+\t\t\t0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,\n+\t\t\t0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,\n+\t\t\t0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,\n+\t\t\t0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,\n+\t\t\t0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,\n+\t\t\t0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98,\n+\t\t\t0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n+\t\t\t0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6,\n+\t\t\t0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5,\n+\t\t\t0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4,\n+\t\t\t0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2,\n+\t\t\t0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea,\n+\t\t\t0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8,\n+\t\t\t0xf9, 0xfa,\n+\t\t},\n+\t},\n+\t// Chrominance DC.\n+\t{\n+\t\t[16]byte{0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0},\n+\t\t[]byte{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11},\n+\t},\n+\t// Chrominance AC.\n+\t{\n+\t\t[16]byte{0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119},\n+\t\t[]byte{\n+\t\t\t0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21,\n+\t\t\t0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71,\n+\t\t\t0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91,\n+\t\t\t0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0,\n+\t\t\t0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34,\n+\t\t\t0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26,\n+\t\t\t0x27, 0x28, 0x29, 0x2a, 0x35, 0x36, 0x37, 0x38,\n+\t\t\t0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,\n+\t\t\t0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,\n+\t\t\t0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,\n+\t\t\t0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,\n+\t\t\t0x79, 0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n+\t\t\t0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96,\n+\t\t\t0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5,\n+\t\t\t0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4,\n+\t\t\t0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3,\n+\t\t\t0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2,\n+\t\t\t0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda,\n+\t\t\t0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9,\n+\t\t\t0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8,\n+\t\t\t0xf9, 0xfa,\n+\t\t},\n+\t},\n+}\n+\n+// huffmanLUT is a compiled look-up table representation of a huffmanSpec.\n+// Each value maps to a uint32 of which the 8 most significant bits hold the\n+// codeword size in bits and the 24 least significant bits hold the codeword.\n+// The maximum codeword size is 16 bits.\n+type huffmanLUT []uint32\n+\n+func (h *huffmanLUT) init(s huffmanSpec) {\n+\tmaxValue := 0\n+\tfor _, v := range s.value {\n+\t\tif int(v) > maxValue {\n+\t\t\tmaxValue = int(v)\n+\t\t}\n+\t}\n+\t*h = make([]uint32, maxValue+1)\n+\tcode, k := uint32(0), 0\n+\tfor i := 0; i < len(s.count); i++ {\n+\t\tnBits := uint32(i+1) << 24\n+\t\tfor j := uint8(0); j < s.count[i]; j++ {\n+\t\t\t(*h)[s.value[k]] = nBits | code\n+\t\t\tcode++\n+\t\t\tk++\n+\t\t}\n+\t\tcode <<= 1\n+\t}\n+}\n+\n+// theHuffmanLUT are compiled representations of theHuffmanSpec.\n+var theHuffmanLUT [4]huffmanLUT\n+\n+func init() {\n+\tfor i, s := range theHuffmanSpec {\n+\t\ttheHuffmanLUT[i].init(s)\n+\t}\n+}\n+\n+// writer is a buffered writer.\n+type writer interface {\n+\tFlush() os.Error\n+\tWrite([]byte) (int, os.Error)\n+\tWriteByte(byte) os.Error\n+}\n+\n+// encoder encodes an image to the JPEG format.\n+type encoder struct {\n+\t// w is the writer to write to. err is the first error encountered during\n+\t// writing. All attempted writes after the first error become no-ops.\n+\tw   writer\n+\terr os.Error\n+\t// buf is a scratch buffer.\n+\tbuf [16]byte\n+\t// bits and nBits are accumulated bits to write to w.\n+\tbits  uint32\n+\tnBits uint8\n+\t// quant is the scaled quantization tables.\n+\tquant [nQuantIndex][blockSize]byte\n+}\n+\n+func (e *encoder) flush() {\n+\tif e.err != nil {\n+\t\treturn\n+\t}\n+\te.err = e.w.Flush()\n+}\n+\n+func (e *encoder) write(p []byte) {\n+\tif e.err != nil {\n+\t\treturn\n+\t}\n+\t_, e.err = e.w.Write(p)\n+}\n+\n+func (e *encoder) writeByte(b byte) {\n+\tif e.err != nil {\n+\t\treturn\n+\t}\n+\te.err = e.w.WriteByte(b)\n+}\n+\n+// emit emits the least significant nBits bits of bits to the bitstream.\n+// The precondition is bits < 1<<nBits && nBits <= 16.\n+func (e *encoder) emit(bits uint32, nBits uint8) {\n+\tnBits += e.nBits\n+\tbits <<= 32 - nBits\n+\tbits |= e.bits\n+\tfor nBits >= 8 {\n+\t\tb := uint8(bits >> 24)\n+\t\te.writeByte(b)\n+\t\tif b == 0xff {\n+\t\t\te.writeByte(0x00)\n+\t\t}\n+\t\tbits <<= 8\n+\t\tnBits -= 8\n+\t}\n+\te.bits, e.nBits = bits, nBits\n+}\n+\n+// emitHuff emits the given value with the given Huffman encoder.\n+func (e *encoder) emitHuff(h huffIndex, value int) {\n+\tx := theHuffmanLUT[h][value]\n+\te.emit(x&(1<<24-1), uint8(x>>24))\n+}\n+\n+// emitHuffRLE emits a run of runLength copies of value encoded with the given\n+// Huffman encoder.\n+func (e *encoder) emitHuffRLE(h huffIndex, runLength, value int) {\n+\ta, b := value, value\n+\tif a < 0 {\n+\t\ta, b = -value, value-1\n+\t}\n+\tvar nBits uint8\n+\tif a < 0x100 {\n+\t\tnBits = bitCount[a]\n+\t} else {\n+\t\tnBits = 8 + bitCount[a>>8]\n+\t}\n+\te.emitHuff(h, runLength<<4|int(nBits))\n+\tif nBits > 0 {\n+\t\te.emit(uint32(b)&(1<<nBits-1), nBits)\n+\t}\n+}\n+\n+// writeMarkerHeader writes the header for a marker with the given length.\n+func (e *encoder) writeMarkerHeader(marker uint8, markerlen int) {\n+\te.buf[0] = 0xff\n+\te.buf[1] = marker\n+\te.buf[2] = uint8(markerlen >> 8)\n+\te.buf[3] = uint8(markerlen & 0xff)\n+\te.write(e.buf[:4])\n+}\n+\n+// writeDQT writes the Define Quantization Table marker.\n+func (e *encoder) writeDQT() {\n+\tmarkerlen := 2\n+\tfor _, q := range e.quant {\n+\t\tmarkerlen += 1 + len(q)\n+\t}\n+\te.writeMarkerHeader(dqtMarker, markerlen)\n+\tfor i, q := range e.quant {\n+\t\te.writeByte(uint8(i))\n+\t\te.write(q[:])\n+\t}\n+}\n+\n+// writeSOF0 writes the Start Of Frame (Baseline) marker.\n+func (e *encoder) writeSOF0(size image.Point) {\n+\tmarkerlen := 8 + 3*nComponent\n+\te.writeMarkerHeader(sof0Marker, markerlen)\n+\te.buf[0] = 8 // 8-bit color.\n+\te.buf[1] = uint8(size.Y >> 8)\n+\te.buf[2] = uint8(size.Y & 0xff)\n+\te.buf[3] = uint8(size.X >> 8)\n+\te.buf[4] = uint8(size.X & 0xff)\n+\te.buf[5] = nComponent\n+\tfor i := 0; i < nComponent; i++ {\n+\t\te.buf[3*i+6] = uint8(i + 1)\n+\t\t// We use 4:2:0 chroma subsampling.\n+\t\te.buf[3*i+7] = \"\\x22\\x11\\x11\"[i]\n+\t\te.buf[3*i+8] = \"\\x00\\x01\\x01\"[i]\n+\t}\n+\te.write(e.buf[:3*(nComponent-1)+9])\n+}\n+\n+// writeDHT writes the Define Huffman Table marker.\n+func (e *encoder) writeDHT() {\n+\tmarkerlen := 2\n+\tfor _, s := range theHuffmanSpec {\n+\t\tmarkerlen += 1 + 16 + len(s.value)\n+\t}\n+\te.writeMarkerHeader(dhtMarker, markerlen)\n+\tfor i, s := range theHuffmanSpec {\n+\t\te.writeByte(\"\\x00\\x10\\x01\\x11\"[i])\n+\t\te.write(s.count[:])\n+\t\te.write(s.value)\n+\t}\n+}\n+\n+// writeBlock writes a block of pixel data using the given quantization table,\n+// returning the post-quantized DC value of the DCT-transformed block.\n+func (e *encoder) writeBlock(b *block, q quantIndex, prevDC int) int {\n+\tfdct(b)\n+\t// Emit the DC delta.\n+\tdc := div(b[0], (8 * int(e.quant[q][0])))\n+\te.emitHuffRLE(huffIndex(2*q+0), 0, dc-prevDC)\n+\t// Emit the AC components.\n+\th, runLength := huffIndex(2*q+1), 0\n+\tfor k := 1; k < blockSize; k++ {\n+\t\tac := div(b[unzig[k]], (8 * int(e.quant[q][k])))\n+\t\tif ac == 0 {\n+\t\t\trunLength++\n+\t\t} else {\n+\t\t\tfor runLength > 15 {\n+\t\t\t\te.emitHuff(h, 0xf0)\n+\t\t\t\trunLength -= 16\n+\t\t\t}\n+\t\t\te.emitHuffRLE(h, runLength, ac)\n+\t\t\trunLength = 0\n+\t\t}\n+\t}\n+\tif runLength > 0 {\n+\t\te.emitHuff(h, 0x00)\n+\t}\n+\treturn dc\n+}\n+\n+// toYCbCr converts the 8x8 region of m whose top-left corner is p to its\n+// YCbCr values.\n+func toYCbCr(m image.Image, p image.Point, yBlock, cbBlock, crBlock *block) {\n+\tb := m.Bounds()\n+\txmax := b.Max.X - 1\n+\tymax := b.Max.Y - 1\n+\tfor j := 0; j < 8; j++ {\n+\t\tfor i := 0; i < 8; i++ {\n+\t\t\tr, g, b, _ := m.At(min(p.X+i, xmax), min(p.Y+j, ymax)).RGBA()\n+\t\t\tyy, cb, cr := ycbcr.RGBToYCbCr(uint8(r>>8), uint8(g>>8), uint8(b>>8))\n+\t\t\tyBlock[8*j+i] = int(yy)\n+\t\t\tcbBlock[8*j+i] = int(cb)\n+\t\t\tcrBlock[8*j+i] = int(cr)\n+\t\t}\n+\t}\n+}\n+\n+// rgbaToYCbCr is a specialized version of toYCbCr for image.RGBA images.\n+func rgbaToYCbCr(m *image.RGBA, p image.Point, yBlock, cbBlock, crBlock *block) {\n+\tb := m.Bounds()\n+\txmax := b.Max.X - 1\n+\tymax := b.Max.Y - 1\n+\tfor j := 0; j < 8; j++ {\n+\t\tsj := p.Y + j\n+\t\tif sj > ymax {\n+\t\t\tsj = ymax\n+\t\t}\n+\t\tyoff := sj * m.Stride\n+\t\tfor i := 0; i < 8; i++ {\n+\t\t\tsx := p.X + i\n+\t\t\tif sx > xmax {\n+\t\t\t\tsx = xmax\n+\t\t\t}\n+\t\t\tcol := &m.Pix[yoff+sx]\n+\t\t\tyy, cb, cr := ycbcr.RGBToYCbCr(col.R, col.G, col.B)\n+\t\t\tyBlock[8*j+i] = int(yy)\n+\t\t\tcbBlock[8*j+i] = int(cb)\n+\t\t\tcrBlock[8*j+i] = int(cr)\n+\t\t}\n+\t}\n+}\n+\n+// scale scales the 16x16 region represented by the 4 src blocks to the 8x8\n+// dst block.\n+func scale(dst *block, src *[4]block) {\n+\tfor i := 0; i < 4; i++ {\n+\t\tdstOff := (i&2)<<4 | (i&1)<<2\n+\t\tfor y := 0; y < 4; y++ {\n+\t\t\tfor x := 0; x < 4; x++ {\n+\t\t\t\tj := 16*y + 2*x\n+\t\t\t\tsum := src[i][j] + src[i][j+1] + src[i][j+8] + src[i][j+9]\n+\t\t\t\tdst[8*y+x+dstOff] = (sum + 2) >> 2\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+// sosHeader is the SOS marker \"\\xff\\xda\" followed by 12 bytes:\n+//\t- the marker length \"\\x00\\x0c\",\n+//\t- the number of components \"\\x03\",\n+//\t- component 1 uses DC table 0 and AC table 0 \"\\x01\\x00\",\n+//\t- component 2 uses DC table 1 and AC table 1 \"\\x02\\x11\",\n+//\t- component 3 uses DC table 1 and AC table 1 \"\\x03\\x11\",\n+//\t- padding \"\\x00\\x00\\x00\".\n+var sosHeader = []byte{\n+\t0xff, 0xda, 0x00, 0x0c, 0x03, 0x01, 0x00, 0x02,\n+\t0x11, 0x03, 0x11, 0x00, 0x00, 0x00,\n+}\n+\n+// writeSOS writes the StartOfScan marker.\n+func (e *encoder) writeSOS(m image.Image) {\n+\te.write(sosHeader)\n+\tvar (\n+\t\t// Scratch buffers to hold the YCbCr values.\n+\t\tyBlock  block\n+\t\tcbBlock [4]block\n+\t\tcrBlock [4]block\n+\t\tcBlock  block\n+\t\t// DC components are delta-encoded.\n+\t\tprevDCY, prevDCCb, prevDCCr int\n+\t)\n+\tbounds := m.Bounds()\n+\trgba, _ := m.(*image.RGBA)\n+\tfor y := bounds.Min.Y; y < bounds.Max.Y; y += 16 {\n+\t\tfor x := bounds.Min.X; x < bounds.Max.X; x += 16 {\n+\t\t\tfor i := 0; i < 4; i++ {\n+\t\t\t\txOff := (i & 1) * 8\n+\t\t\t\tyOff := (i & 2) * 4\n+\t\t\t\tp := image.Point{x + xOff, y + yOff}\n+\t\t\t\tif rgba != nil {\n+\t\t\t\t\trgbaToYCbCr(rgba, p, &yBlock, &cbBlock[i], &crBlock[i])\n+\t\t\t\t} else {\n+\t\t\t\t\ttoYCbCr(m, p, &yBlock, &cbBlock[i], &crBlock[i])\n+\t\t\t\t}\n+\t\t\t\tprevDCY = e.writeBlock(&yBlock, 0, prevDCY)\n+\t\t\t}\n+\t\t\tscale(&cBlock, &cbBlock)\n+\t\t\tprevDCCb = e.writeBlock(&cBlock, 1, prevDCCb)\n+\t\t\tscale(&cBlock, &crBlock)\n+\t\t\tprevDCCr = e.writeBlock(&cBlock, 1, prevDCCr)\n+\t\t}\n+\t}\n+\t// Pad the last byte with 1's.\n+\te.emit(0x7f, 7)\n+}\n+\n+// DefaultQuality is the default quality encoding parameter.\n+const DefaultQuality = 75\n+\n+// Options are the encoding parameters.\n+// Quality ranges from 1 to 100 inclusive, higher is better.\n+type Options struct {\n+\tQuality int\n+}\n+\n+// Encode writes the Image m to w in JPEG 4:2:0 baseline format with the given\n+// options. Default parameters are used if a nil *Options is passed.\n+func Encode(w io.Writer, m image.Image, o *Options) os.Error {\n+\tb := m.Bounds()\n+\tif b.Dx() >= 1<<16 || b.Dy() >= 1<<16 {\n+\t\treturn os.NewError(\"jpeg: image is too large to encode\")\n+\t}\n+\tvar e encoder\n+\tif ww, ok := w.(writer); ok {\n+\t\te.w = ww\n+\t} else {\n+\t\te.w = bufio.NewWriter(w)\n+\t}\n+\t// Clip quality to [1, 100].\n+\tquality := DefaultQuality\n+\tif o != nil {\n+\t\tquality = o.Quality\n+\t\tif quality < 1 {\n+\t\t\tquality = 1\n+\t\t} else if quality > 100 {\n+\t\t\tquality = 100\n+\t\t}\n+\t}\n+\t// Convert from a quality rating to a scaling factor.\n+\tvar scale int\n+\tif quality < 50 {\n+\t\tscale = 5000 / quality\n+\t} else {\n+\t\tscale = 200 - quality*2\n+\t}\n+\t// Initialize the quantization tables.\n+\tfor i := range e.quant {\n+\t\tfor j := range e.quant[i] {\n+\t\t\tx := int(unscaledQuant[i][j])\n+\t\t\tx = (x*scale + 50) / 100\n+\t\t\tif x < 1 {\n+\t\t\t\tx = 1\n+\t\t\t} else if x > 255 {\n+\t\t\t\tx = 255\n+\t\t\t}\n+\t\t\te.quant[i][j] = uint8(x)\n+\t\t}\n+\t}\n+\t// Write the Start Of Image marker.\n+\te.buf[0] = 0xff\n+\te.buf[1] = 0xd8\n+\te.write(e.buf[:2])\n+\t// Write the quantization tables.\n+\te.writeDQT()\n+\t// Write the image dimensions.\n+\te.writeSOF0(b.Size())\n+\t// Write the Huffman tables.\n+\te.writeDHT()\n+\t// Write the image data.\n+\te.writeSOS(m)\n+\t// Write the End Of Image marker.\n+\te.buf[0] = 0xff\n+\te.buf[1] = 0xd9\n+\te.write(e.buf[:2])\n+\te.flush()\n+\treturn e.err\n+}"}, {"sha": "7aec70f016e295435c02ccd7099df87a8876328f", "filename": "libgo/go/image/jpeg/writer_test.go", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -0,0 +1,115 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package jpeg\n+\n+import (\n+\t\"bytes\"\n+\t\"image\"\n+\t\"image/png\"\n+\t\"io/ioutil\"\n+\t\"rand\"\n+\t\"os\"\n+\t\"testing\"\n+)\n+\n+var testCase = []struct {\n+\tfilename  string\n+\tquality   int\n+\ttolerance int64\n+}{\n+\t{\"../testdata/video-001.png\", 1, 24 << 8},\n+\t{\"../testdata/video-001.png\", 20, 12 << 8},\n+\t{\"../testdata/video-001.png\", 60, 8 << 8},\n+\t{\"../testdata/video-001.png\", 80, 6 << 8},\n+\t{\"../testdata/video-001.png\", 90, 4 << 8},\n+\t{\"../testdata/video-001.png\", 100, 2 << 8},\n+}\n+\n+func delta(u0, u1 uint32) int64 {\n+\td := int64(u0) - int64(u1)\n+\tif d < 0 {\n+\t\treturn -d\n+\t}\n+\treturn d\n+}\n+\n+func readPng(filename string) (image.Image, os.Error) {\n+\tf, err := os.Open(filename)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer f.Close()\n+\treturn png.Decode(f)\n+}\n+\n+func TestWriter(t *testing.T) {\n+\tfor _, tc := range testCase {\n+\t\t// Read the image.\n+\t\tm0, err := readPng(tc.filename)\n+\t\tif err != nil {\n+\t\t\tt.Error(tc.filename, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\t// Encode that image as JPEG.\n+\t\tbuf := bytes.NewBuffer(nil)\n+\t\terr = Encode(buf, m0, &Options{Quality: tc.quality})\n+\t\tif err != nil {\n+\t\t\tt.Error(tc.filename, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\t// Decode that JPEG.\n+\t\tm1, err := Decode(buf)\n+\t\tif err != nil {\n+\t\t\tt.Error(tc.filename, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\t// Compute the average delta in RGB space.\n+\t\tb := m0.Bounds()\n+\t\tvar sum, n int64\n+\t\tfor y := b.Min.Y; y < b.Max.Y; y++ {\n+\t\t\tfor x := b.Min.X; x < b.Max.X; x++ {\n+\t\t\t\tc0 := m0.At(x, y)\n+\t\t\t\tc1 := m1.At(x, y)\n+\t\t\t\tr0, g0, b0, _ := c0.RGBA()\n+\t\t\t\tr1, g1, b1, _ := c1.RGBA()\n+\t\t\t\tsum += delta(r0, r1)\n+\t\t\t\tsum += delta(g0, g1)\n+\t\t\t\tsum += delta(b0, b1)\n+\t\t\t\tn += 3\n+\t\t\t}\n+\t\t}\n+\t\t// Compare the average delta to the tolerance level.\n+\t\tif sum/n > tc.tolerance {\n+\t\t\tt.Errorf(\"%s, quality=%d: average delta is too high\", tc.filename, tc.quality)\n+\t\t\tcontinue\n+\t\t}\n+\t}\n+}\n+\n+func BenchmarkEncodeRGBOpaque(b *testing.B) {\n+\tb.StopTimer()\n+\timg := image.NewRGBA(640, 480)\n+\t// Set all pixels to 0xFF alpha to force opaque mode.\n+\tbo := img.Bounds()\n+\trnd := rand.New(rand.NewSource(123))\n+\tfor y := bo.Min.Y; y < bo.Max.Y; y++ {\n+\t\tfor x := bo.Min.X; x < bo.Max.X; x++ {\n+\t\t\timg.Set(x, y, image.RGBAColor{\n+\t\t\t\tuint8(rnd.Intn(256)),\n+\t\t\t\tuint8(rnd.Intn(256)),\n+\t\t\t\tuint8(rnd.Intn(256)),\n+\t\t\t\t255})\n+\t\t}\n+\t}\n+\tif !img.Opaque() {\n+\t\tpanic(\"expected image to be opaque\")\n+\t}\n+\tb.SetBytes(640 * 480 * 4)\n+\tb.StartTimer()\n+\toptions := &Options{Quality: 90}\n+\tfor i := 0; i < b.N; i++ {\n+\t\tEncode(ioutil.Discard, img, options)\n+\t}\n+}"}, {"sha": "8c76afa72c6a02e99b49fc45cc2d21cde4bccc20", "filename": "libgo/go/image/png/reader.go", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Fpng%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Fpng%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Freader.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// The png package implements a PNG image decoder and encoder.\n+// Package png implements a PNG image decoder and encoder.\n //\n // The PNG specification is at http://www.libpng.org/pub/png/spec/1.2/PNG-Contents.html\n package png\n@@ -378,38 +378,38 @@ func (d *decoder) idatReader(idat io.Reader) (image.Image, os.Error) {\n \t\t\tfor x := 0; x < d.width; x += 8 {\n \t\t\t\tb := cdat[x/8]\n \t\t\t\tfor x2 := 0; x2 < 8 && x+x2 < d.width; x2++ {\n-\t\t\t\t\tgray.Set(x+x2, y, image.GrayColor{(b >> 7) * 0xff})\n+\t\t\t\t\tgray.SetGray(x+x2, y, image.GrayColor{(b >> 7) * 0xff})\n \t\t\t\t\tb <<= 1\n \t\t\t\t}\n \t\t\t}\n \t\tcase cbG2:\n \t\t\tfor x := 0; x < d.width; x += 4 {\n \t\t\t\tb := cdat[x/4]\n \t\t\t\tfor x2 := 0; x2 < 4 && x+x2 < d.width; x2++ {\n-\t\t\t\t\tgray.Set(x+x2, y, image.GrayColor{(b >> 6) * 0x55})\n+\t\t\t\t\tgray.SetGray(x+x2, y, image.GrayColor{(b >> 6) * 0x55})\n \t\t\t\t\tb <<= 2\n \t\t\t\t}\n \t\t\t}\n \t\tcase cbG4:\n \t\t\tfor x := 0; x < d.width; x += 2 {\n \t\t\t\tb := cdat[x/2]\n \t\t\t\tfor x2 := 0; x2 < 2 && x+x2 < d.width; x2++ {\n-\t\t\t\t\tgray.Set(x+x2, y, image.GrayColor{(b >> 4) * 0x11})\n+\t\t\t\t\tgray.SetGray(x+x2, y, image.GrayColor{(b >> 4) * 0x11})\n \t\t\t\t\tb <<= 4\n \t\t\t\t}\n \t\t\t}\n \t\tcase cbG8:\n \t\t\tfor x := 0; x < d.width; x++ {\n-\t\t\t\tgray.Set(x, y, image.GrayColor{cdat[x]})\n+\t\t\t\tgray.SetGray(x, y, image.GrayColor{cdat[x]})\n \t\t\t}\n \t\tcase cbGA8:\n \t\t\tfor x := 0; x < d.width; x++ {\n \t\t\t\tycol := cdat[2*x+0]\n-\t\t\t\tnrgba.Set(x, y, image.NRGBAColor{ycol, ycol, ycol, cdat[2*x+1]})\n+\t\t\t\tnrgba.SetNRGBA(x, y, image.NRGBAColor{ycol, ycol, ycol, cdat[2*x+1]})\n \t\t\t}\n \t\tcase cbTC8:\n \t\t\tfor x := 0; x < d.width; x++ {\n-\t\t\t\trgba.Set(x, y, image.RGBAColor{cdat[3*x+0], cdat[3*x+1], cdat[3*x+2], 0xff})\n+\t\t\t\trgba.SetRGBA(x, y, image.RGBAColor{cdat[3*x+0], cdat[3*x+1], cdat[3*x+2], 0xff})\n \t\t\t}\n \t\tcase cbP1:\n \t\t\tfor x := 0; x < d.width; x += 8 {\n@@ -456,33 +456,33 @@ func (d *decoder) idatReader(idat io.Reader) (image.Image, os.Error) {\n \t\t\t}\n \t\tcase cbTCA8:\n \t\t\tfor x := 0; x < d.width; x++ {\n-\t\t\t\tnrgba.Set(x, y, image.NRGBAColor{cdat[4*x+0], cdat[4*x+1], cdat[4*x+2], cdat[4*x+3]})\n+\t\t\t\tnrgba.SetNRGBA(x, y, image.NRGBAColor{cdat[4*x+0], cdat[4*x+1], cdat[4*x+2], cdat[4*x+3]})\n \t\t\t}\n \t\tcase cbG16:\n \t\t\tfor x := 0; x < d.width; x++ {\n \t\t\t\tycol := uint16(cdat[2*x+0])<<8 | uint16(cdat[2*x+1])\n-\t\t\t\tgray16.Set(x, y, image.Gray16Color{ycol})\n+\t\t\t\tgray16.SetGray16(x, y, image.Gray16Color{ycol})\n \t\t\t}\n \t\tcase cbGA16:\n \t\t\tfor x := 0; x < d.width; x++ {\n \t\t\t\tycol := uint16(cdat[4*x+0])<<8 | uint16(cdat[4*x+1])\n \t\t\t\tacol := uint16(cdat[4*x+2])<<8 | uint16(cdat[4*x+3])\n-\t\t\t\tnrgba64.Set(x, y, image.NRGBA64Color{ycol, ycol, ycol, acol})\n+\t\t\t\tnrgba64.SetNRGBA64(x, y, image.NRGBA64Color{ycol, ycol, ycol, acol})\n \t\t\t}\n \t\tcase cbTC16:\n \t\t\tfor x := 0; x < d.width; x++ {\n \t\t\t\trcol := uint16(cdat[6*x+0])<<8 | uint16(cdat[6*x+1])\n \t\t\t\tgcol := uint16(cdat[6*x+2])<<8 | uint16(cdat[6*x+3])\n \t\t\t\tbcol := uint16(cdat[6*x+4])<<8 | uint16(cdat[6*x+5])\n-\t\t\t\trgba64.Set(x, y, image.RGBA64Color{rcol, gcol, bcol, 0xffff})\n+\t\t\t\trgba64.SetRGBA64(x, y, image.RGBA64Color{rcol, gcol, bcol, 0xffff})\n \t\t\t}\n \t\tcase cbTCA16:\n \t\t\tfor x := 0; x < d.width; x++ {\n \t\t\t\trcol := uint16(cdat[8*x+0])<<8 | uint16(cdat[8*x+1])\n \t\t\t\tgcol := uint16(cdat[8*x+2])<<8 | uint16(cdat[8*x+3])\n \t\t\t\tbcol := uint16(cdat[8*x+4])<<8 | uint16(cdat[8*x+5])\n \t\t\t\tacol := uint16(cdat[8*x+6])<<8 | uint16(cdat[8*x+7])\n-\t\t\t\tnrgba64.Set(x, y, image.NRGBA64Color{rcol, gcol, bcol, acol})\n+\t\t\t\tnrgba64.SetNRGBA64(x, y, image.NRGBA64Color{rcol, gcol, bcol, acol})\n \t\t\t}\n \t\t}\n "}, {"sha": "bcc1a3db475609e79224372ce2596ab64e909f07", "filename": "libgo/go/image/png/reader_test.go", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Fpng%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Fpng%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Freader_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -28,6 +28,7 @@ var filenames = []string{\n \t\"basn3p02\",\n \t\"basn3p04\",\n \t\"basn3p08\",\n+\t\"basn3p08-trns\",\n \t\"basn4a08\",\n \t\"basn4a16\",\n \t\"basn6a08\",\n@@ -98,17 +99,30 @@ func sng(w io.WriteCloser, filename string, png image.Image) {\n \t// (the PNG spec section 11.3 says \"Ancillary chunks may be ignored by a decoder\").\n \tio.WriteString(w, \"gAMA {1.0000}\\n\")\n \n-\t// Write the PLTE (if applicable).\n+\t// Write the PLTE and tRNS (if applicable).\n \tif cpm != nil {\n+\t\tlastAlpha := -1\n \t\tio.WriteString(w, \"PLTE {\\n\")\n-\t\tfor i := 0; i < len(cpm); i++ {\n-\t\t\tr, g, b, _ := cpm[i].RGBA()\n+\t\tfor i, c := range cpm {\n+\t\t\tr, g, b, a := c.RGBA()\n+\t\t\tif a != 0xffff {\n+\t\t\t\tlastAlpha = i\n+\t\t\t}\n \t\t\tr >>= 8\n \t\t\tg >>= 8\n \t\t\tb >>= 8\n \t\t\tfmt.Fprintf(w, \"    (%3d,%3d,%3d)     # rgb = (0x%02x,0x%02x,0x%02x)\\n\", r, g, b, r, g, b)\n \t\t}\n \t\tio.WriteString(w, \"}\\n\")\n+\t\tif lastAlpha != -1 {\n+\t\t\tio.WriteString(w, \"tRNS {\\n\")\n+\t\t\tfor i := 0; i <= lastAlpha; i++ {\n+\t\t\t\t_, _, _, a := cpm[i].RGBA()\n+\t\t\t\ta >>= 8\n+\t\t\t\tfmt.Fprintf(w, \" %d\", a)\n+\t\t\t}\n+\t\t\tio.WriteString(w, \"}\\n\")\n+\t\t}\n \t}\n \n \t// Write the IMAGE."}, {"sha": "c0f78bde87a567bb8ab9017d3ee0b4abc7fc0155", "filename": "libgo/go/image/png/testdata/pngsuite/README", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Fpngsuite%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Fpngsuite%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Fpngsuite%2FREADME?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -10,6 +10,9 @@ The files basn0g01-30.png, basn0g02-29.png and basn0g04-31.png are in fact\n not part of pngsuite but were created from files in pngsuite. Their non-power-\n of-two sizes makes them useful for testing bit-depths smaller than a byte.\n \n+basn3a08.png was generated from basn6a08.png using the pngnq tool, which\n+converted it to the 8-bit paletted image with alpha values in tRNS chunk.\n+\n The *.sng files in this directory were generated from the *.png files\n by the sng command-line tool and some hand editing. The files\n basn0g0{1,2,4}.sng were actually generated by first converting the PNG"}, {"sha": "a27586f2394e1ff1bb43bacc0cbf93048251483d", "filename": "libgo/go/image/png/writer.go", "status": "modified", "additions": 41, "deletions": 12, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Fpng%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Fpng%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Fwriter.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27", "patch": "@@ -130,19 +130,30 @@ func (e *encoder) writePLTE(p image.PalettedColorModel) {\n \t\te.err = FormatError(\"bad palette length: \" + strconv.Itoa(len(p)))\n \t\treturn\n \t}\n-\tfor i := 0; i < len(p); i++ {\n-\t\tr, g, b, a := p[i].RGBA()\n-\t\tif a != 0xffff {\n-\t\t\te.err = UnsupportedError(\"non-opaque palette color\")\n-\t\t\treturn\n-\t\t}\n+\tfor i, c := range p {\n+\t\tr, g, b, _ := c.RGBA()\n \t\te.tmp[3*i+0] = uint8(r >> 8)\n \t\te.tmp[3*i+1] = uint8(g >> 8)\n \t\te.tmp[3*i+2] = uint8(b >> 8)\n \t}\n \te.writeChunk(e.tmp[0:3*len(p)], \"PLTE\")\n }\n \n+func (e *encoder) maybeWritetRNS(p image.PalettedColorModel) {\n+\tlast := -1\n+\tfor i, c := range p {\n+\t\t_, _, _, a := c.RGBA()\n+\t\tif a != 0xffff {\n+\t\t\tlast = i\n+\t\t}\n+\t\te.tmp[i] = uint8(a >> 8)\n+\t}\n+\tif last == -1 {\n+\t\treturn\n+\t}\n+\te.writeChunk(e.tmp[:last+1], \"tRNS\")\n+}\n+\n // An encoder is an io.Writer that satisfies writes by writing PNG IDAT chunks,\n // including an 8-byte header and 4-byte CRC checksum per Write call. Such calls\n // should be relatively infrequent, since writeIDATs uses a bufio.Writer.\n@@ -263,7 +274,12 @@ func writeImage(w io.Writer, m image.Image, cb int) os.Error {\n \tdefer zw.Close()\n \n \tbpp := 0 // Bytes per pixel.\n+\n+\t// Used by fast paths for common image types\n \tvar paletted *image.Paletted\n+\tvar rgba *image.RGBA\n+\trgba, _ = m.(*image.RGBA)\n+\n \tswitch cb {\n \tcase cbG8:\n \t\tbpp = 1\n@@ -303,12 +319,24 @@ func writeImage(w io.Writer, m image.Image, cb int) os.Error {\n \t\t\t\tcr[0][x+1] = c.Y\n \t\t\t}\n \t\tcase cbTC8:\n-\t\t\tfor x := b.Min.X; x < b.Max.X; x++ {\n-\t\t\t\t// We have previously verified that the alpha value is fully opaque.\n-\t\t\t\tr, g, b, _ := m.At(x, y).RGBA()\n-\t\t\t\tcr[0][3*x+1] = uint8(r >> 8)\n-\t\t\t\tcr[0][3*x+2] = uint8(g >> 8)\n-\t\t\t\tcr[0][3*x+3] = uint8(b >> 8)\n+\t\t\t// We have previously verified that the alpha value is fully opaque.\n+\t\t\tcr0 := cr[0]\n+\t\t\tif rgba != nil {\n+\t\t\t\tyoff := y * rgba.Stride\n+\t\t\t\txoff := 3*b.Min.X + 1\n+\t\t\t\tfor _, color := range rgba.Pix[yoff+b.Min.X : yoff+b.Max.X] {\n+\t\t\t\t\tcr0[xoff] = color.R\n+\t\t\t\t\tcr0[xoff+1] = color.G\n+\t\t\t\t\tcr0[xoff+2] = color.B\n+\t\t\t\t\txoff += 3\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tfor x := b.Min.X; x < b.Max.X; x++ {\n+\t\t\t\t\tr, g, b, _ := m.At(x, y).RGBA()\n+\t\t\t\t\tcr0[3*x+1] = uint8(r >> 8)\n+\t\t\t\t\tcr0[3*x+2] = uint8(g >> 8)\n+\t\t\t\t\tcr0[3*x+3] = uint8(b >> 8)\n+\t\t\t\t}\n \t\t\t}\n \t\tcase cbP8:\n \t\t\trowOffset := y * paletted.Stride\n@@ -430,6 +458,7 @@ func Encode(w io.Writer, m image.Image) os.Error {\n \te.writeIHDR()\n \tif pal != nil {\n \t\te.writePLTE(pal.Palette)\n+\t\te.maybeWritetRNS(pal.Palette)\n \t}\n \te.writeIDATs()\n \te.writeIEND()"}, {"sha": "6b054aaa893c9c0754de033664b7f280789b7cea", "filename": "libgo/go/image/png/writer_test.go", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Fpng%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Fpng%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Fwriter_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "ca3dd42a7c9157d2cd4c6775c91968c8867dd7f7", "filename": "libgo/go/image/testdata/video-001.bmp", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.bmp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.bmp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.bmp?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "ca06af61bba1cd8f24a975ce30b2f6640f41b5df", "filename": "libgo/go/image/testdata/video-001.gif", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.gif", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.gif", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.gif?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "1b87c933bb7656b03671a46463ac94ed1be95800", "filename": "libgo/go/image/testdata/video-001.jpeg", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.jpeg", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.jpeg", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.jpeg?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "d3468bbe8fc346b0dca8559a6702d06f34b59bce", "filename": "libgo/go/image/testdata/video-001.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.png?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "0dd6cd9313321bc05f1c51c113e8bd20326dcd1d", "filename": "libgo/go/image/testdata/video-001.tiff", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.tiff", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.tiff", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.tiff?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "7c0714225f1f59cfbc520893e938f85d06b820f7", "filename": "libgo/go/image/tiff/buffer.go", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Ftiff%2Fbuffer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Ftiff%2Fbuffer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftiff%2Fbuffer.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "4f3e68e838cf09c08e4e45a8f2f1898f327db897", "filename": "libgo/go/image/tiff/buffer_test.go", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Ftiff%2Fbuffer_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Ftiff%2Fbuffer_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftiff%2Fbuffer_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "761ac9d909451ae277f2ebb880b25b150e76118a", "filename": "libgo/go/image/tiff/consts.go", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Ftiff%2Fconsts.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Ftiff%2Fconsts.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftiff%2Fconsts.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "40f659c36c8b01658e8f8bf5aee03ce8f81bc934", "filename": "libgo/go/image/tiff/reader.go", "status": "added", "additions": 385, "deletions": 0, "changes": 385, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Ftiff%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Ftiff%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftiff%2Freader.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "cda45996df04007856732aebba6b6611cf227498", "filename": "libgo/go/image/ycbcr/ycbcr.go", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Fycbcr%2Fycbcr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Fycbcr%2Fycbcr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fycbcr%2Fycbcr.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "2e60a6f61f9196dd4fe9c8d3eae1ec1646862457", "filename": "libgo/go/image/ycbcr/ycbcr_test.go", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Fycbcr%2Fycbcr_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fimage%2Fycbcr%2Fycbcr_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fycbcr%2Fycbcr_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "079b7d8ed0bcfef8d1bec107147c72d1d4afc605", "filename": "libgo/go/index/suffixarray/suffixarray.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Findex%2Fsuffixarray%2Fsuffixarray.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Findex%2Fsuffixarray%2Fsuffixarray.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Findex%2Fsuffixarray%2Fsuffixarray.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "0bc73d67dd93dbc7e2e58bb779e0283a6d1b63ba", "filename": "libgo/go/io/io.go", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fio%2Fio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fio%2Fio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fio.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "bc4f354af40ed7b8cc54bbc81b0cd4f66b1dffb4", "filename": "libgo/go/io/io_test.go", "status": "modified", "additions": 28, "deletions": 5, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fio%2Fio_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fio%2Fio_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fio_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "5f1eecaabedd7127be53a9decfb28035fda71731", "filename": "libgo/go/io/ioutil/ioutil.go", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fio%2Fioutil%2Fioutil.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fio%2Fioutil%2Fioutil.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fioutil%2Fioutil.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "d702d46c725717f34a709b48dba5f0736a1f1bb0", "filename": "libgo/go/io/multi.go", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fio%2Fmulti.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fio%2Fmulti.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fmulti.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "e78b60ccb54c0e2b154f8ab182fbdb6349608570", "filename": "libgo/go/json/decode.go", "status": "modified", "additions": 82, "deletions": 72, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fjson%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fjson%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fjson%2Fdecode.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "bf8bf10bf89b10582c0d5fc5f4c24ed40f05b7a7", "filename": "libgo/go/json/decode_test.go", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fjson%2Fdecode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fjson%2Fdecode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fjson%2Fdecode_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "ec0a14a6a4d77077a8a96b1f1e5da54bd7dccea6", "filename": "libgo/go/json/encode.go", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fjson%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fjson%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fjson%2Fencode.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "49c2edd545384c7f1eee91ef651dad82a1b365a3", "filename": "libgo/go/json/scanner.go", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fjson%2Fscanner.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fjson%2Fscanner.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fjson%2Fscanner.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "f143b3f0ade62020b8c0bf0632296b3c85240adc", "filename": "libgo/go/json/stream.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fjson%2Fstream.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fjson%2Fstream.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fjson%2Fstream.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "00bce6a17dc23e6351be5df644862d7e1e330e29", "filename": "libgo/go/log/log.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Flog%2Flog.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Flog%2Flog.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Flog%2Flog.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "a108d3e294d9a0a8f54759ca2fad4ffd591a64a1", "filename": "libgo/go/math/const.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fmath%2Fconst.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fmath%2Fconst.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fconst.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "f28ff3e9681ea8a9f35a494894558b791b92cfc6", "filename": "libgo/go/mime/mediatype.go", "status": "modified", "additions": 181, "deletions": 9, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fmime%2Fmediatype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fmime%2Fmediatype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Fmediatype.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "454ddd037781e618a7e4776d44544968fba8e031", "filename": "libgo/go/mime/mediatype_test.go", "status": "modified", "additions": 142, "deletions": 12, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fmime%2Fmediatype_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fmime%2Fmediatype_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Fmediatype_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "5f3286565908f15c5dbf095110bfc14296fd303e", "filename": "libgo/go/mime/multipart/formdata.go", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fmime%2Fmultipart%2Fformdata.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fmime%2Fmultipart%2Fformdata.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Fmultipart%2Fformdata.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "b56e2a430e0aadc0351700e23a71c10ea6674835", "filename": "libgo/go/mime/multipart/formdata_test.go", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fmime%2Fmultipart%2Fformdata_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fmime%2Fmultipart%2Fformdata_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Fmultipart%2Fformdata_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "9affa11261168480db4878dbc04acc2b2919ff60", "filename": "libgo/go/mime/multipart/multipart.go", "status": "modified", "additions": 132, "deletions": 126, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fmime%2Fmultipart%2Fmultipart.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fmime%2Fmultipart%2Fmultipart.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Fmultipart%2Fmultipart.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "8222fbd8a4db43a6b6c1738142a38cb7cf4f3247", "filename": "libgo/go/mime/multipart/multipart_test.go", "status": "modified", "additions": 154, "deletions": 42, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fmime%2Fmultipart%2Fmultipart_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fmime%2Fmultipart%2Fmultipart_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Fmultipart%2Fmultipart_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "8c43b81b0c56c70ea8ce918c862fe982575cde27", "filename": "libgo/go/mime/type.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fmime%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fmime%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Ftype.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "d9fef45de0ad1c1b2766903d7782ed7b735b76ee", "filename": "libgo/go/net/cgo_bsd.go", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fcgo_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fcgo_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fcgo_bsd.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "482435221e09100dff2c138d6e75328fb6c395e3", "filename": "libgo/go/net/cgo_linux.go", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fcgo_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fcgo_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fcgo_linux.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "c6277cb657cbafd1b9d8090b70c9ec663a76e2eb", "filename": "libgo/go/net/cgo_stub.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fcgo_stub.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fcgo_stub.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fcgo_stub.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "b80901812937c407bb2ab391391b9e60f6a7aacc", "filename": "libgo/go/net/cgo_unix.go", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fcgo_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fcgo_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fcgo_unix.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "16896b4269b5517e069e6da2e605487d59d063e8", "filename": "libgo/go/net/dial.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fdial.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fdial.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdial.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "e90c4f3f894d578f2befccca50fa1323d5536e3f", "filename": "libgo/go/net/dialgoogle_test.go", "status": "modified", "additions": 83, "deletions": 26, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fdialgoogle_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fdialgoogle_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdialgoogle_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "3466003fab8eae531237df4c91a96ec8e16809cc", "filename": "libgo/go/net/dnsclient.go", "status": "modified", "additions": 59, "deletions": 32, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fdnsclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fdnsclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdnsclient.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "731efe26a444be7c81d4f8ce5410f2c09cb1e4d5", "filename": "libgo/go/net/dnsmsg.go", "status": "modified", "additions": 79, "deletions": 77, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fdnsmsg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fdnsmsg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdnsmsg.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "20c9f02b0b4d33576919b79635069515f762ac2c", "filename": "libgo/go/net/dnsmsg_test.go", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fdnsmsg_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fdnsmsg_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdnsmsg_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "e5793eef2c72c1245d96907f80fed9daa3d49c88", "filename": "libgo/go/net/hosts_test.go", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fhosts_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fhosts_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhosts_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "61b2c687e2fe28bbd28319e78ebd1f617f911ea3", "filename": "libgo/go/net/ip.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fip.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fip.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fip.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "2008953ef3822df9bf1212f695f2170ddbcdd58a", "filename": "libgo/go/net/ip_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fip_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fip_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fip_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "0c0b675f875929b72bf4d888c1b72517d16faf19", "filename": "libgo/go/net/ipraw_test.go", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fipraw_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fipraw_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fipraw_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "5be6fe4e0b9bdc61a30a270e30e92adc854372f2", "filename": "libgo/go/net/iprawsock.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fiprawsock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fiprawsock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fiprawsock.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "e8bcac646038ce3280d02a86ed33941219394539", "filename": "libgo/go/net/ipsock.go", "status": "modified", "additions": 38, "deletions": 8, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fipsock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fipsock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fipsock.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "eeb22a8ae3d83c6cd36f9992870d1408905c98dd", "filename": "libgo/go/net/lookup.go", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Flookup.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Flookup.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Flookup.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "be6dbf2dc19fef15db5c154a5ad0f1f52373f89f", "filename": "libgo/go/net/multicast_test.go", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fmulticast_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fmulticast_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fmulticast_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "51db107395401b9a77bfb7aaad9e4bff33a03661", "filename": "libgo/go/net/net.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fnet.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fnet.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fnet.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "f7c3f51bef1b0691435d6d71d9aa6f62f2593d29", "filename": "libgo/go/net/resolv_windows.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fresolv_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fresolv_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fresolv_windows.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "075748b83b0140f65d235d9f305b500a390feb5c", "filename": "libgo/go/net/server_test.go", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fserver_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fserver_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fserver_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "21bd5f03e89c6bfd30b27c2df3ef2d3a38b54db7", "filename": "libgo/go/net/sock.go", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fsock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fsock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsock.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "5fd52074ad360283bd2f53ebf0a5102c0977dfb9", "filename": "libgo/go/net/sock_bsd.go", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fsock_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fsock_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsock_bsd.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "ec31e803b6f29b9b2ac589d09b37b128d657a983", "filename": "libgo/go/net/sock_linux.go", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fsock_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fsock_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsock_linux.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "e17c60b98b6e11ab49f8854a8032145c6f5f9e4f", "filename": "libgo/go/net/sock_windows.go", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fsock_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fsock_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsock_windows.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "f1c7a0ab498e20075679a112781d3ef5b493b8f5", "filename": "libgo/go/net/srv_test.go", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fsrv_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fsrv_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsrv_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "d9aa7cf19a5bc97f843771a596ae8492256166df", "filename": "libgo/go/net/tcpsock.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Ftcpsock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Ftcpsock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftcpsock.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "9f19b5495d12e060a908e12cddecaae59f2233a6", "filename": "libgo/go/net/textproto/textproto.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Ftextproto%2Ftextproto.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Ftextproto%2Ftextproto.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftextproto%2Ftextproto.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "67684471b7283da9044b8afd5561d58cd45e0231", "filename": "libgo/go/net/udpsock.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fudpsock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnet%2Fudpsock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fudpsock.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "a319391bf168b41416fd7a92bf8615f8273c3d92", "filename": "libgo/go/netchan/common.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnetchan%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnetchan%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnetchan%2Fcommon.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "1e5ccdb5cba8d529e1e9eabaa4d11a179f022508", "filename": "libgo/go/netchan/export.go", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnetchan%2Fexport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnetchan%2Fexport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnetchan%2Fexport.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "0a700ca2b9906a9f01eda51075dc81f7b17a1538", "filename": "libgo/go/netchan/import.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnetchan%2Fimport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fnetchan%2Fimport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnetchan%2Fimport.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "d9514191d79d2970b0a58cf3bc0c2a90173c5e25", "filename": "libgo/go/os/dir_plan9.go", "status": "modified", "additions": 33, "deletions": 49, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fos%2Fdir_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fos%2Fdir_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fdir_plan9.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "3772c090b8ffb64c3470311bd6d4e60157cf0293", "filename": "libgo/go/os/env.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fos%2Fenv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fos%2Fenv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fenv.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "8aa71e83a0c1d2061aa5edb95c50ed7ddc4863ab", "filename": "libgo/go/os/env_unix.go", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fos%2Fenv_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fos%2Fenv_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fenv_unix.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "3374775b8e7d0c4f99bdc4938d4b69e0d3ddb240", "filename": "libgo/go/os/error_plan9.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fos%2Ferror_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fos%2Ferror_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ferror_plan9.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "dff8fa862cee8de54f93de8553513ada7ec6a16b", "filename": "libgo/go/os/file.go", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fos%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fos%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "7b473f802216f791f67374c556ef9f59b33e27df", "filename": "libgo/go/os/file_plan9.go", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fos%2Ffile_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fos%2Ffile_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile_plan9.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "f1191d61feb7a427064e51bae059c5d78bacc255", "filename": "libgo/go/os/file_posix.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fos%2Ffile_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fos%2Ffile_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile_posix.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "4c69cc8380274dac99984feca5c46a31b3af8035", "filename": "libgo/go/os/file_unix.go", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fos%2Ffile_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fos%2Ffile_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile_unix.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "7c7b7698feb82ba9adc2a3a7acec3d5a6a90a39a", "filename": "libgo/go/os/inotify/inotify_linux.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fos%2Finotify%2Finotify_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fos%2Finotify%2Finotify_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Finotify%2Finotify_linux.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "e29a46d6c2d123724a3fdabaa66f83d2ebfd8cf1", "filename": "libgo/go/os/inotify/inotify_linux_test.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fos%2Finotify%2Finotify_linux_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fos%2Finotify%2Finotify_linux_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Finotify%2Finotify_linux_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "8b8a8434970cfd992eec2fc5e8baba3822c0f6fd", "filename": "libgo/go/os/os_test.go", "status": "modified", "additions": 47, "deletions": 3, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fos%2Fos_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fos%2Fos_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fos_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "2f08f70fd5760212c599b6cc26c952017eb40bdd", "filename": "libgo/go/os/user/lookup_stubs.go", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fos%2Fuser%2Flookup_stubs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fos%2Fuser%2Flookup_stubs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fuser%2Flookup_stubs.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "7060530154a2d3589207b4dfa3772e9e6262d8a5", "filename": "libgo/go/os/user/lookup_unix.go", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fos%2Fuser%2Flookup_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fos%2Fuser%2Flookup_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fuser%2Flookup_unix.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "dd009211d76421d961701ade4ccf7c2972e70618", "filename": "libgo/go/os/user/user.go", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fos%2Fuser%2Fuser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fos%2Fuser%2Fuser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fuser%2Fuser.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "2c142bf18171e41a648a59d67e5a128f5a2632df", "filename": "libgo/go/os/user/user_test.go", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fos%2Fuser%2Fuser_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fos%2Fuser%2Fuser_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fuser%2Fuser_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "541a233066a159a2036825c6c4676361b15cfccf", "filename": "libgo/go/path/filepath/path.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "235384667c678c2c1630368ee30640cd630926c8", "filename": "libgo/go/path/path.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fpath%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fpath%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Fpath.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "145fd520f5d27eddd45752be8db22ff5c1a97cce", "filename": "libgo/go/reflect/all_test.go", "status": "modified", "additions": 403, "deletions": 349, "changes": 752, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Freflect%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Freflect%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fall_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "a483135b01764edecf2514ee259c630f4d9018cb", "filename": "libgo/go/reflect/deepequal.go", "status": "modified", "additions": 49, "deletions": 58, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Freflect%2Fdeepequal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Freflect%2Fdeepequal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fdeepequal.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "8135a4cd148ef61764ceef31e5f524e82a53ee7e", "filename": "libgo/go/reflect/set_test.go", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Freflect%2Fset_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Freflect%2Fset_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fset_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "5f5c52b778aa491218f3f7ce7a27072b3b4418d7", "filename": "libgo/go/reflect/tostring_test.go", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Freflect%2Ftostring_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Freflect%2Ftostring_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Ftostring_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "30bf54a1f18100e04ef28206dd3d60352596e160", "filename": "libgo/go/reflect/type.go", "status": "modified", "additions": 608, "deletions": 371, "changes": 979, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Freflect%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Freflect%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Ftype.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "ea48b02f14b9a4e4668a94b4f15f6af00b712b69", "filename": "libgo/go/reflect/value.go", "status": "modified", "additions": 1412, "deletions": 1037, "changes": 2449, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Freflect%2Fvalue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Freflect%2Fvalue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fvalue.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "acadeec37f0a7b95f0974bdfe07f794531f35fae", "filename": "libgo/go/rpc/server.go", "status": "modified", "additions": 42, "deletions": 28, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Frpc%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Frpc%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Frpc%2Fserver.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "cfff0c9ad50cc96af2664e149666b3d88458e3fe", "filename": "libgo/go/rpc/server_test.go", "status": "modified", "additions": 38, "deletions": 21, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Frpc%2Fserver_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Frpc%2Fserver_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Frpc%2Fserver_test.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}, {"sha": "e5fae632b13cde25f14fba25459d4511fd58553d", "filename": "libgo/go/runtime/debug/stack.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fruntime%2Fdebug%2Fstack.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ff56c9570642711d5b7ab29920ecf5dbff14a27/libgo%2Fgo%2Fruntime%2Fdebug%2Fstack.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fdebug%2Fstack.go?ref=9ff56c9570642711d5b7ab29920ecf5dbff14a27"}]}