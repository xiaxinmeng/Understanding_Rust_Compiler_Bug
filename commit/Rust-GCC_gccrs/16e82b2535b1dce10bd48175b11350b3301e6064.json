{"sha": "16e82b2535b1dce10bd48175b11350b3301e6064", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTZlODJiMjUzNWIxZGNlMTBiZDQ4MTc1YjExMzUwYjMzMDFlNjA2NA==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2012-10-16T13:02:02Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2012-10-16T13:02:02Z"}, "message": "re PR fortran/50981 ([OOP] Wrong-code for scalarizing ELEMENTAL call with absent OPTIONAL argument)\n\n2012-10-16  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/50981\n        PR fortran/54618\n        * trans.h (gfc_conv_derived_to_class, gfc_conv_class_to_class):\n        Update prototype.\n        * trans-stmt.c (trans_associate_var,gfc_trans_allocate): Update\n        calls to those functions.\n        * trans-expr.c (gfc_conv_derived_to_class,\n        * gfc_conv_class_to_class,\n        gfc_conv_expr_present): Handle absent polymorphic arguments.\n        (class_scalar_coarray_to_class): New function.\n        (gfc_conv_procedure_call): Update calls.\n\n2012-10-16  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/50981\n        PR fortran/54618\n        * gfortran.dg/class_optional_1.f90: New.\n        * gfortran.dg/class_optional_2.f90: New.\n\nFrom-SVN: r192495", "tree": {"sha": "0578db74885676fe6fbe9da0d761bbf5c9274c86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0578db74885676fe6fbe9da0d761bbf5c9274c86"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16e82b2535b1dce10bd48175b11350b3301e6064", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16e82b2535b1dce10bd48175b11350b3301e6064", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16e82b2535b1dce10bd48175b11350b3301e6064", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16e82b2535b1dce10bd48175b11350b3301e6064/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0fe03ac31859b5cdc6760e605dc17ffbccfe1860", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fe03ac31859b5cdc6760e605dc17ffbccfe1860", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fe03ac31859b5cdc6760e605dc17ffbccfe1860"}], "stats": {"total": 1363, "additions": 1320, "deletions": 43}, "files": [{"sha": "e1b174075071d4b4b435254d181ac233545fe62b", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16e82b2535b1dce10bd48175b11350b3301e6064/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16e82b2535b1dce10bd48175b11350b3301e6064/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=16e82b2535b1dce10bd48175b11350b3301e6064", "patch": "@@ -1,3 +1,16 @@\n+2012-10-16  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/50981\n+\tPR fortran/54618\n+\t* trans.h (gfc_conv_derived_to_class, gfc_conv_class_to_class):\n+\tUpdate prototype.\n+\t* trans-stmt.c (trans_associate_var,gfc_trans_allocate): Update\n+\tcalls to those functions.\n+\t* trans-expr.c (gfc_conv_derived_to_class, gfc_conv_class_to_class,\n+\tgfc_conv_expr_present): Handle absent polymorphic arguments.\n+\t(class_scalar_coarray_to_class): New function.\n+\t(gfc_conv_procedure_call): Update calls.\n+\n 2012-10-12  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/40453"}, {"sha": "cf9f34672a4e860749720524b2883c1a6cd82fcd", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 318, "deletions": 38, "changes": 356, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16e82b2535b1dce10bd48175b11350b3301e6064/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16e82b2535b1dce10bd48175b11350b3301e6064/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=16e82b2535b1dce10bd48175b11350b3301e6064", "patch": "@@ -231,12 +231,16 @@ class_array_data_assign (stmtblock_t *block, tree lhs_desc, tree rhs_desc,\n \n /* Takes a derived type expression and returns the address of a temporary\n    class object of the 'declared' type.  If vptr is not NULL, this is\n-   used for the temporary class object.  */ \n+   used for the temporary class object.\n+   optional_alloc_ptr is false when the dummy is neither allocatable\n+   nor a pointer; that's only relevant for the optional handling.  */\n void\n gfc_conv_derived_to_class (gfc_se *parmse, gfc_expr *e,\n-\t\t\t   gfc_typespec class_ts, tree vptr)\n+\t\t\t   gfc_typespec class_ts, tree vptr, bool optional,\n+\t\t\t   bool optional_alloc_ptr)\n {\n   gfc_symbol *vtab;\n+  tree cond_optional = NULL_TREE;\n   gfc_ss *ss;\n   tree ctree;\n   tree var;\n@@ -269,13 +273,21 @@ gfc_conv_derived_to_class (gfc_se *parmse, gfc_expr *e,\n   /* Now set the data field.  */\n   ctree =  gfc_class_data_get (var);\n \n+  if (optional)\n+    cond_optional = gfc_conv_expr_present (e->symtree->n.sym);\n+\n   if (parmse->ss && parmse->ss->info->useflags)\n     {\n       /* For an array reference in an elemental procedure call we need\n \t to retain the ss to provide the scalarized array reference.  */\n       gfc_conv_expr_reference (parmse, e);\n       tmp = fold_convert (TREE_TYPE (ctree), parmse->expr);\n+      if (optional)\n+\ttmp = build3_loc (input_location, COND_EXPR, TREE_TYPE (tmp),\n+\t\t\t  cond_optional, tmp,\n+\t\t\t  fold_convert (TREE_TYPE (tmp), null_pointer_node));\n       gfc_add_modify (&parmse->pre, ctree, tmp);\n+\n     }\n   else\n     {\n@@ -293,28 +305,145 @@ gfc_conv_derived_to_class (gfc_se *parmse, gfc_expr *e,\n \t\t\t\t\t\t    gfc_expr_attr (e));\n \t      gfc_add_modify (&parmse->pre, gfc_conv_descriptor_dtype (ctree),\n \t\t\t      gfc_get_dtype (type));\n+\t      if (optional)\n+\t\tparmse->expr = build3_loc (input_location, COND_EXPR,\n+\t\t\t\t\t   TREE_TYPE (parmse->expr),\n+\t\t\t\t\t   cond_optional, parmse->expr,\n+\t\t\t\t\t   fold_convert (TREE_TYPE (parmse->expr),\n+\t\t\t\t\t\t\t null_pointer_node));\n \t      gfc_conv_descriptor_data_set (&parmse->pre, ctree, parmse->expr);\n \t    }\n           else\n \t    {\n \t      tmp = fold_convert (TREE_TYPE (ctree), parmse->expr);\n+\t      if (optional)\n+\t\ttmp = build3_loc (input_location, COND_EXPR, TREE_TYPE (tmp),\n+\t\t\t\t  cond_optional, tmp,\n+\t\t\t\t  fold_convert (TREE_TYPE (tmp),\n+\t\t\t\t\t\tnull_pointer_node));\n \t      gfc_add_modify (&parmse->pre, ctree, tmp);\n \t    }\n \t}\n       else\n \t{\n+\t  stmtblock_t block;\n+\t  gfc_init_block (&block);\n+\n \t  parmse->ss = ss;\n \t  gfc_conv_expr_descriptor (parmse, e);\n \n \t  if (e->rank != class_ts.u.derived->components->as->rank)\n-\t    class_array_data_assign (&parmse->pre, ctree, parmse->expr, true);\n+\t    class_array_data_assign (&block, ctree, parmse->expr, true);\n+\t  else\n+\t    {\n+\t      if (gfc_expr_attr (e).codimension)\n+\t\tparmse->expr = fold_build1_loc (input_location,\n+\t\t\t\t\t\tVIEW_CONVERT_EXPR,\n+\t\t\t\t\t\tTREE_TYPE (ctree),\n+\t\t\t\t\t\tparmse->expr);\n+\t      gfc_add_modify (&block, ctree, parmse->expr);\n+\t    }\n+\n+\t  if (optional)\n+\t    {\n+\t      tmp = gfc_finish_block (&block);\n+\n+\t      gfc_init_block (&block);\n+\t      gfc_conv_descriptor_data_set (&block, ctree, null_pointer_node);\n+\n+\t      tmp = build3_v (COND_EXPR, cond_optional, tmp,\n+\t\t\t      gfc_finish_block (&block));\n+\t      gfc_add_expr_to_block (&parmse->pre, tmp);\n+\t    }\n \t  else\n-\t    gfc_add_modify (&parmse->pre, ctree, parmse->expr);\n+\t    gfc_add_block_to_block (&parmse->pre, &block);\n \t}\n     }\n \n   /* Pass the address of the class object.  */\n   parmse->expr = gfc_build_addr_expr (NULL_TREE, var);\n+\n+  if (optional && optional_alloc_ptr)\n+    parmse->expr = build3_loc (input_location, COND_EXPR,\n+\t\t\t       TREE_TYPE (parmse->expr),\n+\t\t\t       cond_optional, parmse->expr,\n+\t\t\t       fold_convert (TREE_TYPE (parmse->expr),\n+\t\t\t\t\t     null_pointer_node));\n+}\n+\n+\n+/* Create a new class container, which is required as scalar coarrays\n+   have an array descriptor while normal scalars haven't. Optionally,\n+   NULL pointer checks are added if the argument is OPTIONAL.  */\n+\n+static void\n+class_scalar_coarray_to_class (gfc_se *parmse, gfc_expr *e,\n+\t\t\t       gfc_typespec class_ts, bool optional)\n+{\n+  tree var, ctree, tmp;\n+  stmtblock_t block;\n+  gfc_ref *ref;\n+  gfc_ref *class_ref;\n+\n+  gfc_init_block (&block);\n+\n+  class_ref = NULL;\n+  for (ref = e->ref; ref; ref = ref->next)\n+    {\n+      if (ref->type == REF_COMPONENT\n+\t    && ref->u.c.component->ts.type == BT_CLASS)\n+\tclass_ref = ref;\n+    }\n+\n+  if (class_ref == NULL\n+\t&& e->symtree && e->symtree->n.sym->ts.type == BT_CLASS)\n+    tmp = e->symtree->n.sym->backend_decl;\n+  else\n+    {\n+      /* Remove everything after the last class reference, convert the\n+\t expression and then recover its tailend once more.  */\n+      gfc_se tmpse;\n+      ref = class_ref->next;\n+      class_ref->next = NULL;\n+      gfc_init_se (&tmpse, NULL);\n+      gfc_conv_expr (&tmpse, e);\n+      class_ref->next = ref;\n+      tmp = tmpse.expr;\n+    }\n+\n+  var = gfc_typenode_for_spec (&class_ts);\n+  var = gfc_create_var (var, \"class\");\n+\n+  ctree = gfc_class_vptr_get (var);\n+  gfc_add_modify (&block, ctree,\n+\t\t  fold_convert (TREE_TYPE (ctree), gfc_class_vptr_get (tmp)));\n+\n+  ctree = gfc_class_data_get (var);\n+  tmp = gfc_conv_descriptor_data_get (gfc_class_data_get (tmp));\n+  gfc_add_modify (&block, ctree, fold_convert (TREE_TYPE (ctree), tmp));\n+\n+  /* Pass the address of the class object.  */\n+  parmse->expr = gfc_build_addr_expr (NULL_TREE, var);\n+\n+  if (optional)\n+    {\n+      tree cond = gfc_conv_expr_present (e->symtree->n.sym);\n+      tree tmp2;\n+\n+      tmp = gfc_finish_block (&block);\n+\n+      gfc_init_block (&block);\n+      tmp2 = gfc_class_data_get (var);\n+      gfc_add_modify (&block, tmp2, fold_convert (TREE_TYPE (tmp2),\n+\t\t\t\t\t\t  null_pointer_node));\n+      tmp2 = gfc_finish_block (&block);\n+\n+      tmp = build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\tcond, tmp, tmp2);\n+      gfc_add_expr_to_block (&parmse->pre, tmp);\n+    }\n+  else\n+    gfc_add_block_to_block (&parmse->pre, &block);\n }\n \n \n@@ -323,19 +452,29 @@ gfc_conv_derived_to_class (gfc_se *parmse, gfc_expr *e,\n    type.  \n    OOP-TODO: This could be improved by adding code that branched on\n    the dynamic type being the same as the declared type. In this case\n-   the original class expression can be passed directly.  */ \n+   the original class expression can be passed directly.\n+   optional_alloc_ptr is false when the dummy is neither allocatable\n+   nor a pointer; that's relevant for the optional handling.\n+   Set copyback to true if class container's _data and _vtab pointers\n+   might get modified.  */\n+\n void\n-gfc_conv_class_to_class (gfc_se *parmse, gfc_expr *e,\n-\t\t\t gfc_typespec class_ts, bool elemental)\n+gfc_conv_class_to_class (gfc_se *parmse, gfc_expr *e, gfc_typespec class_ts,\n+\t\t\t bool elemental, bool copyback, bool optional,\n+\t\t         bool optional_alloc_ptr)\n {\n   tree ctree;\n   tree var;\n   tree tmp;\n   tree vptr;\n+  tree cond = NULL_TREE;\n   gfc_ref *ref;\n   gfc_ref *class_ref;\n+  stmtblock_t block;\n   bool full_array = false;\n \n+  gfc_init_block (&block);\n+\n   class_ref = NULL;\n   for (ref = e->ref; ref; ref = ref->next)\n     {\n@@ -353,7 +492,11 @@ gfc_conv_class_to_class (gfc_se *parmse, gfc_expr *e,\n     return;\n \n   /* Test for FULL_ARRAY.  */\n-  gfc_is_class_array_ref (e, &full_array);\n+  if (e->rank == 0 && gfc_expr_attr (e).codimension\n+      && gfc_expr_attr (e).dimension)\n+    full_array = true;\n+  else\n+    gfc_is_class_array_ref (e, &full_array);\n \n   /* The derived type needs to be converted to a temporary\n      CLASS object.  */\n@@ -369,22 +512,30 @@ gfc_conv_class_to_class (gfc_se *parmse, gfc_expr *e,\n \t{\n \t  tree type = get_scalar_to_descriptor_type (parmse->expr,\n \t\t\t\t\t\t     gfc_expr_attr (e));\n-\t  gfc_add_modify (&parmse->pre, gfc_conv_descriptor_dtype (ctree),\n+\t  gfc_add_modify (&block, gfc_conv_descriptor_dtype (ctree),\n \t\t\t  gfc_get_dtype (type));\n-\t  gfc_conv_descriptor_data_set (&parmse->pre, ctree,\n-\t\t\t\t\tgfc_class_data_get (parmse->expr));\n \n+\t  tmp = gfc_class_data_get (parmse->expr);\n+\t  if (!POINTER_TYPE_P (TREE_TYPE (tmp)))\n+\t    tmp = gfc_build_addr_expr (NULL_TREE, tmp);\n+\n+\t  gfc_conv_descriptor_data_set (&block, ctree, tmp);\n \t}\n       else\n-\tclass_array_data_assign (&parmse->pre, ctree, parmse->expr, false);\n+\tclass_array_data_assign (&block, ctree, parmse->expr, false);\n     }\n   else\n-    gfc_add_modify (&parmse->pre, ctree, parmse->expr);\n+    {\n+      if (CLASS_DATA (e)->attr.codimension)\n+\tparmse->expr = fold_build1_loc (input_location, VIEW_CONVERT_EXPR,\n+\t\t\t\t\tTREE_TYPE (ctree), parmse->expr);\n+      gfc_add_modify (&block, ctree, parmse->expr);\n+    }\n \n   /* Return the data component, except in the case of scalarized array\n      references, where nullification of the cannot occur and so there\n      is no need.  */\n-  if (!elemental && full_array)\n+  if (!elemental && full_array && copyback)\n     {\n       if (class_ts.u.derived->components->as\n \t  && e->rank != class_ts.u.derived->components->as->rank)\n@@ -429,17 +580,51 @@ gfc_conv_class_to_class (gfc_se *parmse, gfc_expr *e,\n     tmp = build_fold_indirect_ref_loc (input_location, tmp);\n \n   vptr = gfc_class_vptr_get (tmp);\n-  gfc_add_modify (&parmse->pre, ctree,\n+  gfc_add_modify (&block, ctree,\n \t\t  fold_convert (TREE_TYPE (ctree), vptr));\n \n   /* Return the vptr component, except in the case of scalarized array\n      references, where the dynamic type cannot change.  */\n-  if (!elemental && full_array)\n+  if (!elemental && full_array && copyback)\n     gfc_add_modify (&parmse->post, vptr,\n \t\t    fold_convert (TREE_TYPE (vptr), ctree));\n \n+  gcc_assert (!optional || (optional && !copyback));\n+  if (optional)\n+    {\n+      tree tmp2;\n+\n+      cond = gfc_conv_expr_present (e->symtree->n.sym);\n+      tmp = gfc_finish_block (&block);\n+\n+      if (optional_alloc_ptr)\n+\ttmp2 = build_empty_stmt (input_location);\n+      else\n+\t{\n+\t  gfc_init_block (&block);\n+\n+\t  tmp2 = gfc_conv_descriptor_data_get (gfc_class_data_get (var));\n+\t  gfc_add_modify (&block, tmp2, fold_convert (TREE_TYPE (tmp2),\n+\t\t\t\t\t\t      null_pointer_node));\n+\t  tmp2 = gfc_finish_block (&block);\n+\t}\n+\n+      tmp = build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\tcond, tmp, tmp2);\n+      gfc_add_expr_to_block (&parmse->pre, tmp);\n+    }\n+  else\n+    gfc_add_block_to_block (&parmse->pre, &block);\n+\n   /* Pass the address of the class object.  */\n   parmse->expr = gfc_build_addr_expr (NULL_TREE, var);\n+\n+  if (optional && optional_alloc_ptr)\n+    parmse->expr = build3_loc (input_location, COND_EXPR,\n+\t\t\t       TREE_TYPE (parmse->expr),\n+\t\t\t       cond, parmse->expr,\n+\t\t\t       fold_convert (TREE_TYPE (parmse->expr),\n+\t\t\t\t\t     null_pointer_node));\n }\n \n \n@@ -857,19 +1042,43 @@ gfc_conv_expr_present (gfc_symbol * sym)\n \n   /* Fortran 2008 allows to pass null pointers and non-associated pointers\n      as actual argument to denote absent dummies. For array descriptors,\n-     we thus also need to check the array descriptor.  */\n-  if (!sym->attr.pointer && !sym->attr.allocatable\n-      && sym->as && (sym->as->type == AS_ASSUMED_SHAPE\n-\t\t     || sym->as->type == AS_ASSUMED_RANK)\n-      && (gfc_option.allow_std & GFC_STD_F2008) != 0)\n+     we thus also need to check the array descriptor.  For BT_CLASS, it\n+     can also occur for scalars and F2003 due to type->class wrapping and\n+     class->class wrapping.  Note futher that BT_CLASS always uses an\n+     array descriptor for arrays, also for explicit-shape/assumed-size.  */\n+\n+  if (!sym->attr.allocatable\n+      && ((sym->ts.type != BT_CLASS && !sym->attr.pointer)\n+\t  || (sym->ts.type == BT_CLASS\n+\t      && !CLASS_DATA (sym)->attr.allocatable\n+\t      && !CLASS_DATA (sym)->attr.class_pointer))\n+      && ((gfc_option.allow_std & GFC_STD_F2008) != 0\n+\t  || sym->ts.type == BT_CLASS))\n     {\n       tree tmp;\n-      tmp = build_fold_indirect_ref_loc (input_location, decl);\n-      tmp = gfc_conv_array_data (tmp);\n-      tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, tmp,\n-\t\t\t     fold_convert (TREE_TYPE (tmp), null_pointer_node));\n-      cond = fold_build2_loc (input_location, TRUTH_ANDIF_EXPR,\n-\t\t\t      boolean_type_node, cond, tmp);\n+\n+      if ((sym->as && (sym->as->type == AS_ASSUMED_SHAPE\n+\t\t       || sym->as->type == AS_ASSUMED_RANK\n+\t\t       || sym->attr.codimension))\n+\t  || (sym->ts.type == BT_CLASS && CLASS_DATA (sym)->as))\n+\t{\n+\t  tmp = build_fold_indirect_ref_loc (input_location, decl);\n+\t  if (sym->ts.type == BT_CLASS)\n+\t    tmp = gfc_class_data_get (tmp);\n+\t  tmp = gfc_conv_array_data (tmp);\n+\t}\n+      else if (sym->ts.type == BT_CLASS)\n+\ttmp = gfc_class_data_get (decl);\n+      else\n+\ttmp = NULL_TREE;\n+\n+      if (tmp != NULL_TREE)\n+\t{\n+\t  tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, tmp,\n+\t\t\t\t fold_convert (TREE_TYPE (tmp), null_pointer_node));\n+\t  cond = fold_build2_loc (input_location, TRUTH_ANDIF_EXPR,\n+\t\t\t\t  boolean_type_node, cond, tmp);\n+\t}\n     }\n \n   return cond;\n@@ -3714,7 +3923,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n       if (e && e->expr_type == EXPR_VARIABLE\n \t    && !e->ref\n \t    && e->ts.type == BT_CLASS\n-\t    && CLASS_DATA (e)->attr.dimension)\n+\t    && (CLASS_DATA (e)->attr.codimension\n+\t\t|| CLASS_DATA (e)->attr.dimension))\n \t{\n \t  gfc_typespec temp_ts = e->ts;\n \t  gfc_add_class_array_ref (e);\n@@ -3763,7 +3973,12 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  /* The derived type needs to be converted to a temporary\n \t     CLASS object.  */\n \t  gfc_init_se (&parmse, se);\n-\t  gfc_conv_derived_to_class (&parmse, e, fsym->ts, NULL);\n+\t  gfc_conv_derived_to_class (&parmse, e, fsym->ts, NULL,\n+\t\t\t\t     fsym->attr.optional\n+\t\t\t\t     && e->expr_type == EXPR_VARIABLE\n+\t\t\t\t     && e->symtree->n.sym->attr.optional,\n+\t\t\t\t     CLASS_DATA (fsym)->attr.class_pointer\n+\t\t\t\t     || CLASS_DATA (fsym)->attr.allocatable);\n \t}\n       else if (se->ss && se->ss->info->useflags)\n \t{\n@@ -3789,7 +4004,20 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \n \t  if (fsym && fsym->ts.type == BT_DERIVED\n \t      && gfc_is_class_container_ref (e))\n-\t    parmse.expr = gfc_class_data_get (parmse.expr);\n+\t    {\n+\t      parmse.expr = gfc_class_data_get (parmse.expr);\n+\n+\t      if (fsym->attr.optional && e->expr_type == EXPR_VARIABLE\n+\t\t  && e->symtree->n.sym->attr.optional)\n+\t\t{\n+\t\t  tree cond = gfc_conv_expr_present (e->symtree->n.sym);\n+\t\t  parmse.expr = build3_loc (input_location, COND_EXPR,\n+\t\t\t\t\tTREE_TYPE (parmse.expr),\n+\t\t\t\t\tcond, parmse.expr,\n+\t\t\t\t\tfold_convert (TREE_TYPE (parmse.expr),\n+\t\t\t\t\t\t      null_pointer_node));\n+\t\t}\n+\t    }\n \n \t  /* If we are passing an absent array as optional dummy to an\n \t     elemental procedure, make sure that we pass NULL when the data\n@@ -3817,23 +4045,43 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  /* The scalarizer does not repackage the reference to a class\n \t     array - instead it returns a pointer to the data element.  */\n \t  if (fsym && fsym->ts.type == BT_CLASS && e->ts.type == BT_CLASS)\n-\t    gfc_conv_class_to_class (&parmse, e, fsym->ts, true);\n+\t    gfc_conv_class_to_class (&parmse, e, fsym->ts, true,\n+\t\t\t\t     fsym->attr.intent != INTENT_IN\n+\t\t\t\t     && (CLASS_DATA (fsym)->attr.class_pointer\n+\t\t\t\t\t || CLASS_DATA (fsym)->attr.allocatable),\n+\t\t\t\t     fsym->attr.optional\n+\t\t\t\t     && e->expr_type == EXPR_VARIABLE\n+\t\t\t\t     && e->symtree->n.sym->attr.optional,\n+\t\t\t\t     CLASS_DATA (fsym)->attr.class_pointer\n+\t\t\t\t     || CLASS_DATA (fsym)->attr.allocatable);\n \t}\n       else\n \t{\n \t  bool scalar;\n \t  gfc_ss *argss;\n \n+\t  gfc_init_se (&parmse, NULL);\n+\n \t  /* Check whether the expression is a scalar or not; we cannot use\n \t     e->rank as it can be nonzero for functions arguments.  */\n \t  argss = gfc_walk_expr (e);\n \t  scalar = argss == gfc_ss_terminator;\n \t  if (!scalar)\n \t    gfc_free_ss_chain (argss);\n \n+\t  /* Special handling for passing scalar polymorphic coarrays;\n+\t     otherwise one passes \"class->_data.data\" instead of \"&class\".  */\n+\t  if (e->rank == 0 && e->ts.type == BT_CLASS\n+\t      && fsym && fsym->ts.type == BT_CLASS\n+\t      && CLASS_DATA (fsym)->attr.codimension\n+\t      && !CLASS_DATA (fsym)->attr.dimension)\n+\t    {\n+\t      gfc_add_class_array_ref (e);\n+              parmse.want_coarray = 1;\n+\t      scalar = false;\n+\t    }\n+\n \t  /* A scalar or transformational function.  */\n-\t  gfc_init_se (&parmse, NULL);\n-          \n \t  if (scalar)\n \t    {\n \t      if (e->expr_type == EXPR_VARIABLE\n@@ -3888,7 +4136,23 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t}\n \t      else\n \t\t{\n-\t\t  gfc_conv_expr_reference (&parmse, e);\n+\t\t  if (e->ts.type == BT_CLASS && fsym\n+\t\t      && fsym->ts.type == BT_CLASS\n+\t\t      && (!CLASS_DATA (fsym)->as\n+\t\t\t  || CLASS_DATA (fsym)->as->type != AS_ASSUMED_RANK)\n+\t\t      && CLASS_DATA (e)->attr.codimension)\n+\t\t    {\n+\t\t      gcc_assert (!CLASS_DATA (fsym)->attr.codimension);\n+\t\t      gcc_assert (!CLASS_DATA (fsym)->as);\n+\t\t      gfc_add_class_array_ref (e);\n+\t\t      parmse.want_coarray = 1;\n+\t\t      gfc_conv_expr_reference (&parmse, e);\n+\t\t      class_scalar_coarray_to_class (&parmse, e, fsym->ts,\n+\t\t\t\t     fsym->attr.optional\n+\t\t\t\t     && e->expr_type == EXPR_VARIABLE);\n+\t\t    }\n+\t\t  else\n+\t\t    gfc_conv_expr_reference (&parmse, e);\n \n \t\t  /* Catch base objects that are not variables.  */\n \t\t  if (e->ts.type == BT_CLASS\n@@ -3904,7 +4168,15 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t\t&& ((CLASS_DATA (fsym)->as\n \t\t\t     && CLASS_DATA (fsym)->as->type == AS_ASSUMED_RANK)\n \t\t\t    || CLASS_DATA (e)->attr.dimension))\n-\t\t    gfc_conv_class_to_class (&parmse, e, fsym->ts, false);\n+\t\t    gfc_conv_class_to_class (&parmse, e, fsym->ts, false,\n+\t\t\t\t     fsym->attr.intent != INTENT_IN\n+\t\t\t\t     && (CLASS_DATA (fsym)->attr.class_pointer\n+\t\t\t\t\t || CLASS_DATA (fsym)->attr.allocatable),\n+\t\t\t\t     fsym->attr.optional\n+\t\t\t\t     && e->expr_type == EXPR_VARIABLE\n+\t\t\t\t     && e->symtree->n.sym->attr.optional,\n+\t\t\t\t     CLASS_DATA (fsym)->attr.class_pointer\n+\t\t\t\t     || CLASS_DATA (fsym)->attr.allocatable);\n \n \t\t  if (fsym && (fsym->ts.type == BT_DERIVED\n \t\t\t       || fsym->ts.type == BT_ASSUMED)\n@@ -4005,14 +4277,22 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t    }\n \t  else if (e->ts.type == BT_CLASS\n \t\t    && fsym && fsym->ts.type == BT_CLASS\n-\t\t    && CLASS_DATA (fsym)->attr.dimension)\n+\t\t    && (CLASS_DATA (fsym)->attr.dimension\n+\t\t\t|| CLASS_DATA (fsym)->attr.codimension))\n \t    {\n \t      /* Pass a class array.  */\n-\t      gfc_init_se (&parmse, se);\n \t      gfc_conv_expr_descriptor (&parmse, e);\n \t      /* The conversion does not repackage the reference to a class\n \t         array - _data descriptor.  */\n-\t      gfc_conv_class_to_class (&parmse, e, fsym->ts, false);\n+\t      gfc_conv_class_to_class (&parmse, e, fsym->ts, false,\n+\t\t\t\t     fsym->attr.intent != INTENT_IN\n+\t\t\t\t     && (CLASS_DATA (fsym)->attr.class_pointer\n+\t\t\t\t\t || CLASS_DATA (fsym)->attr.allocatable),\n+\t\t\t\t     fsym->attr.optional\n+\t\t\t\t     && e->expr_type == EXPR_VARIABLE\n+\t\t\t\t     && e->symtree->n.sym->attr.optional,\n+\t\t\t\t     CLASS_DATA (fsym)->attr.class_pointer\n+\t\t\t\t     || CLASS_DATA (fsym)->attr.allocatable);\n \t    }\n \t  else\n \t    {"}, {"sha": "b95c8dae75891e98ea1713e27d6989f7aaf3b4c0", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16e82b2535b1dce10bd48175b11350b3301e6064/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16e82b2535b1dce10bd48175b11350b3301e6064/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=16e82b2535b1dce10bd48175b11350b3301e6064", "patch": "@@ -1228,7 +1228,7 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n \t  gfc_conv_expr_descriptor (&se, e);\n \n \t  /* Obtain a temporary class container for the result.  */ \n-\t  gfc_conv_class_to_class (&se, e, sym->ts, false);\n+\t  gfc_conv_class_to_class (&se, e, sym->ts, false, true, false, false);\n \t  se.expr = build_fold_indirect_ref_loc (input_location, se.expr);\n \n \t  /* Set the offset.  */\n@@ -1255,7 +1255,7 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n \t  /* Get the _vptr component of the class object.  */ \n \t  tmp = gfc_get_vptr_from_expr (se.expr);\n \t  /* Obtain a temporary class container for the result.  */\n-\t  gfc_conv_derived_to_class (&se, e, sym->ts, tmp);\n+\t  gfc_conv_derived_to_class (&se, e, sym->ts, tmp, false, false);\n \t  se.expr = build_fold_indirect_ref_loc (input_location, se.expr);\n \t}\n       else\n@@ -4874,7 +4874,7 @@ gfc_trans_allocate (gfc_code * code)\n \t  gfc_init_se (&se_sz, NULL);\n \t  gfc_conv_expr_reference (&se_sz, code->expr3);\n \t  gfc_conv_class_to_class (&se_sz, code->expr3,\n-\t\t\t\t   code->expr3->ts, false);\n+\t\t\t\t   code->expr3->ts, false, true, false, false);\n \t  gfc_add_block_to_block (&se.pre, &se_sz.pre);\n \t  gfc_add_block_to_block (&se.post, &se_sz.post);\n \t  classexpr = build_fold_indirect_ref_loc (input_location,"}, {"sha": "7e6d58c1bb63a5dea6616f047dc4679eac3f4a78", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16e82b2535b1dce10bd48175b11350b3301e6064/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16e82b2535b1dce10bd48175b11350b3301e6064/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=16e82b2535b1dce10bd48175b11350b3301e6064", "patch": "@@ -351,8 +351,10 @@ tree gfc_vtable_copy_get (tree);\n tree gfc_get_vptr_from_expr (tree);\n tree gfc_get_class_array_ref (tree, tree);\n tree gfc_copy_class_to_class (tree, tree, tree);\n-void gfc_conv_derived_to_class (gfc_se *, gfc_expr *, gfc_typespec, tree);\n-void gfc_conv_class_to_class (gfc_se *, gfc_expr *, gfc_typespec, bool);\n+void gfc_conv_derived_to_class (gfc_se *, gfc_expr *, gfc_typespec, tree, bool,\n+\t\t\t\tbool);\n+void gfc_conv_class_to_class (gfc_se *, gfc_expr *, gfc_typespec, bool, bool,\n+\t\t\t      bool, bool);\n \n /* Initialize an init/cleanup block.  */\n void gfc_start_wrapped_block (gfc_wrapped_block* block, tree code);"}, {"sha": "5ebe169568cfd2b1ef101a7a3a4c52a8f3f7f434", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16e82b2535b1dce10bd48175b11350b3301e6064/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16e82b2535b1dce10bd48175b11350b3301e6064/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=16e82b2535b1dce10bd48175b11350b3301e6064", "patch": "@@ -1,3 +1,10 @@\n+2012-10-16  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/50981\n+\tPR fortran/54618\n+\t* gfortran.dg/class_optional_1.f90: New.\n+\t* gfortran.dg/class_optional_2.f90: New.\n+\n 2012-10-16  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/54796"}, {"sha": "2b408dbda05c8e8595aac6a116790d93c5afada1", "filename": "gcc/testsuite/gfortran.dg/class_optional_1.f90", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16e82b2535b1dce10bd48175b11350b3301e6064/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_optional_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16e82b2535b1dce10bd48175b11350b3301e6064/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_optional_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_optional_1.f90?ref=16e82b2535b1dce10bd48175b11350b3301e6064", "patch": "@@ -0,0 +1,175 @@\n+! { dg-do run }\n+! { dg-options \"-fcoarray=single\" }\n+!\n+! PR fortran/50981\n+! PR fortran/54618\n+!\n+\n+  implicit none\n+  type t\n+   integer, allocatable :: i\n+  end type t\n+  type, extends (t):: t2\n+   integer, allocatable :: j\n+  end type t2\n+\n+  class(t), allocatable :: xa, xa2(:), xac[:], xa2c(:)[:]\n+  class(t), pointer :: xp, xp2(:)\n+\n+  xp => null()\n+  xp2 => null()\n+\n+  call suba(alloc=.false., prsnt=.false.)\n+  call suba(xa, alloc=.false., prsnt=.true.)\n+  if (.not. allocated (xa)) call abort ()\n+  if (.not. allocated (xa%i)) call abort ()\n+  if (xa%i /= 5) call abort ()\n+  xa%i = -3\n+  call suba(xa, alloc=.true., prsnt=.true.)\n+  if (allocated (xa)) call abort ()\n+\n+  call suba2(alloc=.false., prsnt=.false.)\n+  call suba2(xa2, alloc=.false., prsnt=.true.)\n+  if (.not. allocated (xa2)) call abort ()\n+  if (size (xa2) /= 1) call abort ()\n+  if (.not. allocated (xa2(1)%i)) call abort ()\n+  if (xa2(1)%i /= 5) call abort ()\n+  xa2(1)%i = -3\n+  call suba2(xa2, alloc=.true., prsnt=.true.)\n+  if (allocated (xa2)) call abort ()\n+\n+  call subp(alloc=.false., prsnt=.false.)\n+  call subp(xp, alloc=.false., prsnt=.true.)\n+  if (.not. associated (xp)) call abort ()\n+  if (.not. allocated (xp%i)) call abort ()\n+  if (xp%i /= 5) call abort ()\n+  xp%i = -3\n+  call subp(xp, alloc=.true., prsnt=.true.)\n+  if (associated (xp)) call abort ()\n+\n+  call subp2(alloc=.false., prsnt=.false.)\n+  call subp2(xp2, alloc=.false., prsnt=.true.)\n+  if (.not. associated (xp2)) call abort ()\n+  if (size (xp2) /= 1) call abort ()\n+  if (.not. allocated (xp2(1)%i)) call abort ()\n+  if (xp2(1)%i /= 5) call abort ()\n+  xp2(1)%i = -3\n+  call subp2(xp2, alloc=.true., prsnt=.true.)\n+  if (associated (xp2)) call abort ()\n+\n+  call subac(alloc=.false., prsnt=.false.)\n+  call subac(xac, alloc=.false., prsnt=.true.)\n+  if (.not. allocated (xac)) call abort ()\n+  if (.not. allocated (xac%i)) call abort ()\n+  if (xac%i /= 5) call abort ()\n+  xac%i = -3\n+  call subac(xac, alloc=.true., prsnt=.true.)\n+  if (allocated (xac)) call abort ()\n+\n+  call suba2c(alloc=.false., prsnt=.false.)\n+  call suba2c(xa2c, alloc=.false., prsnt=.true.)\n+  if (.not. allocated (xa2c)) call abort ()\n+  if (size (xa2c) /= 1) call abort ()\n+  if (.not. allocated (xa2c(1)%i)) call abort ()\n+  if (xa2c(1)%i /= 5) call abort ()\n+  xa2c(1)%i = -3\n+  call suba2c(xa2c, alloc=.true., prsnt=.true.)\n+  if (allocated (xa2c)) call abort ()\n+\n+contains\n+ subroutine suba2c(x, prsnt, alloc)\n+   class(t), optional, allocatable :: x(:)[:]\n+   logical prsnt, alloc\n+   if (present (x) .neqv. prsnt) call abort ()\n+   if (prsnt) then\n+     if (alloc .neqv. allocated(x)) call abort ()\n+     if (.not. allocated (x)) then\n+       allocate (x(1)[*])\n+       x(1)%i = 5\n+     else\n+       if (x(1)%i /= -3) call abort()\n+       deallocate (x)\n+     end if\n+   end if\n+ end subroutine suba2c\n+\n+ subroutine subac(x, prsnt, alloc)\n+   class(t), optional, allocatable :: x[:]\n+   logical prsnt, alloc\n+   if (present (x) .neqv. prsnt) call abort ()\n+   if (present (x)) then\n+     if (alloc .neqv. allocated(x)) call abort ()\n+     if (.not. allocated (x)) then\n+       allocate (x[*])\n+       x%i = 5\n+     else\n+       if (x%i /= -3) call abort()\n+       deallocate (x)\n+     end if\n+   end if\n+ end subroutine subac\n+\n+ subroutine suba2(x, prsnt, alloc)\n+   class(t), optional, allocatable :: x(:)\n+   logical prsnt, alloc\n+   if (present (x) .neqv. prsnt) call abort ()\n+   if (prsnt) then\n+     if (alloc .neqv. allocated(x)) call abort ()\n+     if (.not. allocated (x)) then\n+       allocate (x(1))\n+       x(1)%i = 5\n+     else\n+       if (x(1)%i /= -3) call abort()\n+       deallocate (x)\n+     end if\n+   end if\n+ end subroutine suba2\n+\n+ subroutine suba(x, prsnt, alloc)\n+   class(t), optional, allocatable :: x\n+   logical prsnt, alloc\n+   if (present (x) .neqv. prsnt) call abort ()\n+   if (present (x)) then\n+     if (alloc .neqv. allocated(x)) call abort ()\n+     if (.not. allocated (x)) then\n+       allocate (x)\n+       x%i = 5\n+     else\n+       if (x%i /= -3) call abort()\n+       deallocate (x)\n+     end if\n+   end if\n+ end subroutine suba\n+\n+ subroutine subp2(x, prsnt, alloc)\n+   class(t), optional, pointer :: x(:)\n+   logical prsnt, alloc\n+   if (present (x) .neqv. prsnt) call abort ()\n+   if (present (x)) then\n+     if (alloc .neqv. associated(x)) call abort ()\n+     if (.not. associated (x)) then\n+       allocate (x(1))\n+       x(1)%i = 5\n+     else\n+       if (x(1)%i /= -3) call abort()\n+       deallocate (x)\n+     end if\n+   end if\n+ end subroutine subp2\n+\n+ subroutine subp(x, prsnt, alloc)\n+   class(t), optional, pointer :: x\n+   logical prsnt, alloc\n+   if (present (x) .neqv. prsnt) call abort ()\n+   if (present (x)) then\n+     if (alloc .neqv. associated(x)) call abort ()\n+     if (.not. associated (x)) then\n+       allocate (x)\n+       x%i = 5\n+     else\n+       if (x%i /= -3) call abort()\n+       deallocate (x)\n+     end if\n+   end if\n+ end subroutine subp\n+end"}, {"sha": "90b1719c117c411879a1a99f015637d5dd62058d", "filename": "gcc/testsuite/gfortran.dg/class_optional_2.f90", "status": "added", "additions": 800, "deletions": 0, "changes": 800, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16e82b2535b1dce10bd48175b11350b3301e6064/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_optional_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16e82b2535b1dce10bd48175b11350b3301e6064/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_optional_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_optional_2.f90?ref=16e82b2535b1dce10bd48175b11350b3301e6064", "patch": "@@ -0,0 +1,800 @@\n+! { dg-do run }\n+! { dg-options \"-fcoarray=single\" }\n+!\n+! PR fortran/50981\n+! PR fortran/54618\n+!\n+\n+  implicit none\n+  type t\n+   integer, allocatable :: i\n+  end type t\n+  type, extends (t):: t2\n+   integer, allocatable :: j\n+  end type t2\n+\n+  call s1a1()\n+  call s1a()\n+  call s1ac1()\n+  call s1ac()\n+  call s2()\n+  call s2p(psnt=.false.)\n+  call s2caf()\n+  call s2elem()\n+  call s2elem_t()\n+  call s2elem_t2()\n+  call s2t()\n+  call s2tp(psnt=.false.)\n+  call s2t2()\n+  call s2t2p(psnt=.false.)\n+\n+  call a1a1()\n+  call a1a()\n+  call a1ac1()\n+  call a1ac()\n+  call a2()\n+  call a2p(psnt=.false.)\n+  call a2caf()\n+\n+  call a3a1()\n+  call a3a()\n+  call a3ac1()\n+  call a3ac()\n+  call a4()\n+  call a4p(psnt=.false.)\n+  call a4caf()\n+\n+  call ar1a1()\n+  call ar1a()\n+  call ar1ac1()\n+  call ar1ac()\n+  call ar()\n+  call art()\n+  call arp(psnt=.false.)\n+  call artp(psnt=.false.)\n+\n+contains\n+\n+ subroutine s1a1(z, z2, z3, z4, z5)\n+   type(t), optional :: z, z4[*]\n+   type(t), pointer, optional :: z2\n+   type(t), allocatable, optional :: z3, z5[:]\n+   type(t), allocatable :: x\n+   type(t), pointer :: y\n+   y => null()\n+   call s2(x)\n+   call s2(y)\n+   call s2(z)\n+   call s2(z2)\n+   call s2(z3)\n+   call s2(z4)\n+   call s2(z5)\n+   call s2p(y,psnt=.true.)\n+   call s2p(z2,psnt=.false.)\n+   call s2elem(x)\n+   call s2elem(y)\n+   call s2elem(z)\n+   call s2elem(z2)\n+   call s2elem(z3)\n+   call s2elem(z4)\n+   call s2elem(z5)\n+   call s2elem_t(x)\n+   call s2elem_t(y)\n+   call s2elem_t(z)\n+!   call s2elem_t(z2) ! FIXME: Segfault\n+!   call s2elem_t(z3) ! FIXME: Segfault\n+!   call s2elem_t(z4) ! FIXME: Segfault\n+!   call s2elem_t(z5) ! FIXME: Segfault\n+   call s2caf(z4)\n+   call s2caf(z5)\n+   call ar(x)\n+   call ar(y)\n+   call ar(z)\n+   call ar(z2)\n+   call ar(z3)\n+   call ar(z4)\n+   call ar(z5)\n+   call arp(y,psnt=.true.)\n+   call arp(z2,psnt=.false.)\n+   call s2t(x)\n+   call s2t(y)\n+   call s2t(z)\n+!  call s2t(z2) ! FIXME: Segfault\n+!   call s2t(z3) ! FIXME: Segfault\n+!   call s2t(z4) ! FIXME: Segfault\n+!   call s2t(z5) ! FIXME: Segfault\n+   call s2tp(y,psnt=.true.)\n+   call s2tp(z2,psnt=.false.)\n+ end subroutine s1a1\n+ subroutine s1a(z, z2, z3, z4, z5)\n+   type(t2), optional :: z, z4[*]\n+   type(t2), optional, pointer :: z2\n+   type(t2), optional, allocatable :: z3, z5[:]\n+   type(t2), allocatable :: x\n+   type(t2), pointer :: y\n+   y => null()\n+   call s2(x)\n+   call s2(y)\n+   call s2(z)\n+   call s2(z2)\n+   call s2(z3)\n+   call s2(z4)\n+   call s2(z5)\n+   call s2p(y,psnt=.true.)\n+   call s2p(z2,psnt=.false.)\n+   call s2elem(x)\n+   call s2elem(y)\n+   call s2elem(z)\n+   call s2elem(z2)\n+   call s2elem(z3)\n+   call s2elem(z4)\n+   call s2elem(z5)\n+   call s2elem_t2(x)\n+   call s2elem_t2(y)\n+   call s2elem_t2(z)\n+!   call s2elem_t2(z2) ! FIXME: Segfault\n+!   call s2elem_t2(z3) ! FIXME: Segfault\n+!   call s2elem_t2(z4) ! FIXME: Segfault\n+!   call s2elem_t2(z5) ! FIXME: Segfault\n+   call s2caf(z4)\n+   call s2caf(z5)\n+   call ar(x)\n+   call ar(y)\n+   call ar(z)\n+   call ar(z2)\n+   call ar(z3)\n+   call ar(z4)\n+   call ar(z5)\n+   call arp(y,psnt=.true.)\n+   call arp(z2,psnt=.false.)\n+   call s2t2(x)\n+   call s2t2(y)\n+   call s2t2(z)\n+!   call s2t2(z2) ! FIXME: Segfault\n+!   call s2t2(z3) ! FIXME: Segfault\n+   call s2t2(z4)\n+!   call s2t2(z5) ! FIXME: Segfault\n+   call s2t2p(y,psnt=.true.)\n+   call s2t2p(z2,psnt=.false.)\n+ end subroutine s1a\n+ subroutine s1ac1(z, z2, z3, z4, z5)\n+   class(t), optional :: z, z4[*]\n+   class(t), optional, pointer :: z2\n+   class(t), optional, allocatable :: z3, z5[:]\n+   class(t), allocatable :: x\n+   class(t), pointer :: y\n+   y => null()\n+   call s2(x)\n+   call s2(y)\n+   call s2(z)\n+   call s2(z2)\n+   call s2(z3)\n+   call s2(z4)\n+   call s2(z5)\n+   call s2p(y,psnt=.true.)\n+   call s2p(z2,psnt=.false.)\n+   call s2elem(x)\n+   call s2elem(y)\n+   call s2elem(z)\n+   call s2elem(z2)\n+   call s2elem(z3)\n+   call s2elem(z4)\n+   call s2elem(z5)\n+   call s2elem_t(x)\n+   call s2elem_t(y)\n+!   call s2elem_t(z) ! FIXME: Segfault\n+!   call s2elem_t(z2) ! FIXME: Segfault\n+!   call s2elem_t(z3) ! FIXME: Segfault\n+!   call s2elem_t(z4) ! FIXME: Segfault\n+!   call s2elem_t(z5) ! FIXME: Segfault\n+   call s2caf(z4)\n+   call s2caf(z5)\n+   call ar(x)\n+   call ar(y)\n+   call ar(z)\n+   call ar(z2)\n+   call ar(z3)\n+   call ar(z4)\n+   call ar(z5)\n+   call arp(y,psnt=.true.)\n+   call arp(z2,psnt=.false.)\n+   call s2t(x)\n+   call s2t(y)\n+!   call s2t(z) ! FIXME: Segfault\n+!   call s2t(z2) ! FIXME: Segfault\n+!   call s2t(z3) ! FIXME: Segfault\n+!   call s2t(z4) ! FIXME: Segfault\n+!   call s2t(z5) ! FIXME: Segfault\n+   call s2tp(y,psnt=.true.)\n+   call s2tp(z2,psnt=.false.)\n+ end subroutine s1ac1\n+ subroutine s1ac(z, z2, z3, z4, z5)\n+   class(t2), optional :: z, z4[*]\n+   class(t2), optional, pointer :: z2\n+   class(t2), optional, allocatable :: z3, z5[:]\n+   class(t2), allocatable :: x\n+   class(t2), pointer :: y\n+   y => null()\n+   call s2(x)\n+   call s2(y)\n+   call s2(z)\n+   call s2(z2)\n+   call s2(z3)\n+   call s2(z4)\n+   call s2(z5)\n+   call s2p(y,psnt=.true.)\n+   call s2p(z2,psnt=.false.)\n+   call s2elem(x)\n+   call s2elem(y)\n+   call s2elem(z)\n+   call s2elem(z2)\n+   call s2elem(z3)\n+   call s2elem(z4)\n+   call s2elem(z5)\n+   call s2elem_t2(x)\n+!   call s2elem_t2(y) ! FIXME: Segfault\n+!   call s2elem_t2(z) ! FIXME: Segfault\n+!   call s2elem_t2(z2) ! FIXME: Segfault\n+!   call s2elem_t2(z3) ! FIXME: Segfault\n+!   call s2elem_t2(z4) ! FIXME: Segfault\n+!   call s2elem_t2(z5) ! FIXME: Segfault\n+   call s2caf(z4)\n+   call s2caf(z5)\n+   call ar(x)\n+   call ar(y)\n+   call ar(z)\n+   call ar(z2)\n+   call ar(z3)\n+   call ar(z4)\n+   call ar(z5)\n+   call arp(y,psnt=.true.)\n+   call arp(z2,psnt=.false.)\n+   call s2t2(x)\n+   call s2t2(y)\n+!   call s2t2(z) ! FIXME: Segfault\n+!   call s2t2(z2) ! FIXME: Segfault\n+!   call s2t2(z3) ! FIXME: Segfault\n+!   call s2t2(z4) ! FIXME: Segfault\n+!   call s2t2(z5) ! FIXME: Segfault\n+   call s2t2p(y,psnt=.true.)\n+   call s2t2p(z2,psnt=.false.)\n+ end subroutine s1ac\n+\n+ subroutine s2(x)\n+   class(t), intent(in), optional :: x\n+   if (present (x)) call abort ()\n+   !print *, present(x)\n+ end subroutine s2\n+ subroutine s2p(x,psnt)\n+   class(t), intent(in), pointer, optional :: x\n+   logical psnt\n+   if (present (x).neqv. psnt) call abort ()\n+   !print *, present(x)\n+ end subroutine s2p\n+ subroutine s2caf(x)\n+   class(t), intent(in), optional :: x[*]\n+   if (present (x)) call abort ()\n+   !print *, present(x)\n+ end subroutine s2caf\n+ subroutine s2t(x)\n+   type(t), intent(in), optional :: x\n+   if (present (x)) call abort ()\n+   !print *, present(x)\n+ end subroutine s2t\n+ subroutine s2t2(x)\n+   type(t2), intent(in), optional :: x\n+   if (present (x)) call abort ()\n+   !print *, present(x)\n+ end subroutine s2t2\n+ subroutine s2tp(x, psnt)\n+   type(t), pointer, intent(in), optional :: x\n+   logical psnt\n+   if (present (x).neqv. psnt) call abort ()\n+   !print *, present(x)\n+ end subroutine s2tp\n+ subroutine s2t2p(x, psnt)\n+   type(t2), pointer, intent(in), optional :: x\n+   logical psnt\n+   if (present (x).neqv. psnt) call abort ()\n+   !print *, present(x)\n+ end subroutine s2t2p\n+ impure elemental subroutine s2elem(x)\n+   class(t), intent(in), optional :: x\n+   if (present (x)) call abort ()\n+   !print *, present(x)\n+ end subroutine s2elem\n+ impure elemental subroutine s2elem_t(x)\n+   type(t), intent(in), optional :: x\n+   if (present (x)) call abort ()\n+   !print *, present(x)\n+ end subroutine s2elem_t\n+ impure elemental subroutine s2elem_t2(x)\n+   type(t2), intent(in), optional :: x\n+   if (present (x)) call abort ()\n+   !print *, present(x)\n+ end subroutine s2elem_t2\n+\n+\n+ subroutine a1a1(z, z2, z3, z4, z5)\n+   type(t), optional :: z(:), z4(:)[*]\n+   type(t), optional, pointer :: z2(:)\n+   type(t), optional, allocatable :: z3(:), z5(:)[:]\n+   type(t), allocatable :: x(:)\n+   type(t), pointer :: y(:)\n+   y => null()\n+   call a2(x)\n+   call a2(y)\n+   call a2(z)\n+   call a2(z2)\n+   call a2(z3)\n+   call a2(z4)\n+   call a2(z5)\n+   call a2p(y,psnt=.true.)\n+   call a2p(z2,psnt=.false.)\n+   call a2caf(z4)\n+   call a2caf(z5)\n+   call ar(x)\n+   call ar(y)\n+   call ar(z)\n+   call ar(z2)\n+   call ar(z3)\n+   call ar(z4)\n+   call ar(z5)\n+   call arp(y,psnt=.true.)\n+   call arp(z2,psnt=.false.)\n+!   call s2elem(x) ! FIXME: Segfault\n+!   call s2elem(y) ! FIXME: Segfault\n+!   call s2elem(z) ! FIXME: Segfault\n+!   call s2elem(z2) ! FIXME: Segfault\n+!   call s2elem(z3) ! FIXME: Segfault\n+!   call s2elem(z4) ! FIXME: Segfault\n+!   call s2elem(z5) ! FIXME: Segfault\n+!   call s2elem_t(x) ! FIXME: Conditional jump or move depends on uninitialised value\n+!   call s2elem_t(y) ! FIXME: Conditional jump or move depends on uninitialised value\n+!   call s2elem_t(z) ! FIXME: Conditional jump or move depends on uninitialised value\n+!   call s2elem_t(z2) ! FIXME: Segfault\n+!   call s2elem_t(z3) ! FIXME: Segfault\n+!   call s2elem_t(z4) ! FIXME: Segfault\n+!   call s2elem_t(z5) ! FIXME: Segfault\n+ end subroutine a1a1\n+ subroutine a1a(z, z2, z3, z4, z5)\n+   type(t2), optional :: z(:), z4(:)[*]\n+   type(t2), optional, pointer :: z2(:)\n+   type(t2), optional, allocatable :: z3(:), z5(:)[:]\n+   type(t2), allocatable :: x(:)\n+   type(t2), pointer :: y(:)\n+   y => null()\n+   call a2(x)\n+   call a2(y)\n+   call a2(z)\n+   call a2(z2)\n+   call a2(z3)\n+   call a2(z4)\n+   call a2(z5)\n+   call a2p(y,psnt=.true.)\n+   call a2p(z2,psnt=.false.)\n+   call a2caf(z4)\n+   call a2caf(z5)\n+   call ar(x)\n+   call ar(y)\n+   call ar(z)\n+   call ar(z2)\n+   call ar(z3)\n+   call ar(z4)\n+   call ar(z5)\n+   call arp(y,psnt=.true.)\n+   call arp(z2,psnt=.false.)\n+!   call s2elem(x) ! FIXME: Segfault\n+!   call s2elem(y) ! FIXME: Segfault\n+!   call s2elem(z) ! FIXME: Segfault\n+!   call s2elem(z2) ! FIXME: Segfault\n+!   call s2elem(z3) ! FIXME: Segfault\n+!   call s2elem(z4) ! FIXME: Segfault\n+!   call s2elem(z5) ! FIXME: Segfault\n+!   call s2elem_t2(x) ! FIXME: Conditional jump or move depends on uninitialised value\n+!   call s2elem_t2(y) ! FIXME: Conditional jump or move depends on uninitialised value\n+!   call s2elem_t2(z) ! FIXME: Conditional jump or move depends on uninitialised value\n+!   call s2elem_t2(z2) ! FIXME: Segfault\n+!   call s2elem_t2(z3) ! FIXME: Segfault\n+!   call s2elem_t2(z4) ! FIXME: Segfault\n+!   call s2elem_t2(z5) ! FIXME: Segfault\n+ end subroutine a1a\n+ subroutine a1ac1(z, z2, z3, z4, z5)\n+   class(t), optional :: z(:), z4(:)[*]\n+   class(t), optional, pointer :: z2(:)\n+   class(t), optional, allocatable :: z3(:), z5(:)[:]\n+   class(t), allocatable :: x(:)\n+   class(t), pointer :: y(:)\n+   y => null()\n+   call a2(x)\n+   call a2(y)\n+   call a2(z)\n+   call a2(z2)\n+   call a2(z3)\n+   call a2(z4)\n+   call a2(z5)\n+   call a2p(y,psnt=.true.)\n+   call a2p(z2,psnt=.false.)\n+   call a2caf(z4)\n+   call a2caf(z5)\n+   call ar(x)\n+   call ar(y)\n+   call ar(z)\n+   call ar(z2)\n+   call ar(z3)\n+   call ar(z4)\n+   call ar(z5)\n+   call arp(y,psnt=.true.)\n+   call arp(z2,psnt=.false.)\n+!   call s2elem(x) ! FIXME: Segfault\n+!   call s2elem(y) ! FIXME: Segfault\n+!   call s2elem(z) ! FIXME: Segfault\n+!   call s2elem(z2) ! FIXME: Segfault\n+!   call s2elem(z3) ! FIXME: Segfault\n+!   call s2elem(z4) ! FIXME: Segfault\n+!   call s2elem(z5) ! FIXME: Segfault\n+!   call s2elem_t(x) ! FIXME: Segfault\n+!   call s2elem_t(y) ! FIXME: Segfault\n+!   call s2elem_t(z) ! FIXME: Segfault\n+!   call s2elem_t(z2) ! FIXME: Segfault\n+!   call s2elem_t(z3) ! FIXME: Segfault\n+!   call s2elem_t(z4) ! FIXME: Segfault\n+!   call s2elem_t(z5) ! FIXME: Segfault\n+ end subroutine a1ac1\n+ subroutine a1ac(z, z2, z3, z4, z5)\n+   class(t2), optional :: z(:), z4(:)[*]\n+   class(t2), optional, pointer :: z2(:)\n+   class(t2), optional, allocatable :: z3(:), z5(:)[:]\n+   class(t2), allocatable :: x(:)\n+   class(t2), pointer :: y(:)\n+   y => null()\n+   call a2(x)\n+   call a2(y)\n+   call a2(z)\n+   call a2(z2)\n+   call a2(z3)\n+   call a2(z4)\n+   call a2(z5)\n+   call a2p(y,psnt=.true.)\n+   call a2p(z2,psnt=.false.)\n+   call a2caf(z4)\n+   call a2caf(z5)\n+   call ar(x)\n+   call ar(y)\n+   call ar(z)\n+   call ar(z2)\n+   call ar(z3)\n+   call ar(z4)\n+   call ar(z5)\n+   call arp(y,psnt=.true.)\n+   call arp(z2,psnt=.false.)\n+!   call s2elem(x) ! FIXME: Segfault\n+!   call s2elem(y) ! FIXME: Segfault\n+!   call s2elem(z) ! FIXME: Segfault\n+!   call s2elem(z2) ! FIXME: Segfault\n+!   call s2elem(z3) ! FIXME: Segfault\n+!   call s2elem(z4) ! FIXME: Segfault\n+!   call s2elem(z5) ! FIXME: Segfault\n+!   call s2elem_t2(x) ! FIXME: Segfault\n+!   call s2elem_t2(y) ! FIXME: Segfault\n+!   call s2elem_t2(z) ! FIXME: Segfault\n+!   call s2elem_t2(z2) ! FIXME: Segfault\n+!   call s2elem_t2(z3) ! FIXME: Segfault\n+!   call s2elem_t2(z4) ! FIXME: Segfault\n+!   call s2elem_t2(z5) ! FIXME: Segfault\n+ end subroutine a1ac\n+\n+ subroutine a2(x)\n+   class(t), intent(in), optional :: x(:)\n+   if (present (x)) call abort ()\n+   ! print *, present(x)\n+ end subroutine a2\n+ subroutine a2p(x, psnt)\n+   class(t), pointer, intent(in), optional :: x(:)\n+   logical psnt\n+   if (present (x).neqv. psnt) call abort ()\n+   ! print *, present(x)\n+ end subroutine a2p\n+ subroutine a2caf(x)\n+   class(t), intent(in), optional :: x(:)[*]\n+   if (present (x)) call abort ()\n+   ! print *, present(x)\n+ end subroutine a2caf\n+\n+\n+ subroutine a3a1(z, z2, z3, z4, z5)\n+   type(t), optional :: z(4), z4(4)[*]\n+   type(t), optional, pointer :: z2(:)\n+   type(t), optional, allocatable :: z3(:), z5(:)[:]\n+   type(t), allocatable :: x(:)\n+   type(t), pointer :: y(:)\n+   y => null()\n+   call a4(x)\n+   call a4(y)\n+   call a4(z)\n+   call a4(z2)\n+   call a4(z3)\n+   call a4(z4)\n+   call a4(z5)\n+   call a4p(y,psnt=.true.)\n+   call a4p(z2,psnt=.false.)\n+   call a4t(x)\n+   call a4t(y)\n+   call a4t(z)\n+!   call a4t(z2) ! FIXME: Segfault\n+!   call a4t(z3) ! FIXME: Segfault\n+!   call a4t(z4) ! FIXME: Segfault\n+!   call a4t(z5) ! FIXME: Segfault\n+   call a4tp(y,psnt=.true.)\n+   call a4tp(z2,psnt=.false.)\n+   call a4caf(z4)\n+   call a4caf(z5)\n+   call ar(x)\n+   call ar(y)\n+   call ar(z)\n+   call ar(z2)\n+   call ar(z3)\n+   call ar(z4)\n+   call ar(z5)\n+   call arp(y,psnt=.true.)\n+   call arp(z2,psnt=.false.)\n+!   call s2elem(x) ! FIXME: Segfault\n+!   call s2elem(y) ! FIXME: Segfault\n+!   call s2elem(z) ! FIXME: Segfault\n+!   call s2elem(z2) ! FIXME: Segfault\n+!   call s2elem(z3) ! FIXME: Segfault\n+!   call s2elem(z4) ! FIXME: Segfault\n+!   call s2elem(z5) ! FIXME: Segfault\n+!   call s2elem_t(x) ! FIXME: Conditional jump or move depends on uninitialised value\n+!   call s2elem_t(y) ! FIXME: Conditional jump or move depends on uninitialised value\n+!   call s2elem_t(z) ! FIXME: Conditional jump or move depends on uninitialised value\n+!   call s2elem_t(z2) ! FIXME: Segfault\n+!   call s2elem_t(z3) ! FIXME: Segfault\n+!   call s2elem_t(z4) ! FIXME: Segfault\n+!   call s2elem_t(z5) ! FIXME: Segfault\n+ end subroutine a3a1\n+ subroutine a3a(z, z2, z3)\n+   type(t2), optional :: z(4)\n+   type(t2), optional, pointer :: z2(:)\n+   type(t2), optional, allocatable :: z3(:)\n+   type(t2), allocatable :: x(:)\n+   type(t2), pointer :: y(:)\n+   y => null()\n+   call a4(x)\n+   call a4(y)\n+   call a4(z)\n+   call a4(z2)\n+   call a4(z3)\n+   call a4p(y,psnt=.true.)\n+   call a4p(z2,psnt=.false.)\n+   call a4t2(x)\n+   call a4t2(y)\n+   call a4t2(z)\n+!   call a4t2(z2) ! FIXME: Segfault\n+!   call a4t2(z3) ! FIXME: Segfault\n+   call a4t2p(y,psnt=.true.)\n+   call a4t2p(z2,psnt=.false.)\n+   call ar(x)\n+   call ar(y)\n+   call ar(z)\n+   call ar(z2)\n+   call ar(z3)\n+   call arp(y,psnt=.true.)\n+   call arp(z2,psnt=.false.)\n+!   call s2elem(x) ! FIXME: Segfault\n+!   call s2elem(y) ! FIXME: Segfault\n+!   call s2elem(z) ! FIXME: Segfault\n+!   call s2elem(z2) ! FIXME: Segfault\n+!   call s2elem(z3) ! FIXME: Segfault\n+!   call s2elem(z4) ! FIXME: Segfault\n+!   call s2elem(z5) ! FIXME: Segfault\n+!   call s2elem_t2(x) ! FIXME: Conditional jump or move depends on uninitialised value\n+!   call s2elem_t2(y) ! FIXME: Conditional jump or move depends on uninitialised value\n+!   call s2elem_t2(z) ! FIXME: Conditional jump or move depends on uninitialised value\n+!   call s2elem_t2(z2) ! FIXME: Segfault\n+!   call s2elem_t2(z3) ! FIXME: Segfault\n+!   call s2elem_t2(z4) ! FIXME: Segfault\n+!   call s2elem_t2(z5) ! FIXME: Segfault\n+ end subroutine a3a\n+ subroutine a3ac1(z, z2, z3, z4, z5)\n+   class(t), optional :: z(4), z4(4)[*]\n+   class(t), optional, pointer :: z2(:)\n+   class(t), optional, allocatable :: z3(:), z5(:)[:]\n+   class(t), allocatable :: x(:)\n+   class(t), pointer :: y(:)\n+   y => null()\n+   call a4(x)\n+   call a4(y)\n+   call a4(z)\n+   call a4(z2)\n+   call a4(z3)\n+   call a4(z4)\n+   call a4(z5)\n+   call a4p(y,psnt=.true.)\n+   call a4p(z2,psnt=.false.)\n+!   call a4t(x) ! FIXME: Segfault\n+!   call a4t(y) ! FIXME: Segfault\n+!   call a4t(z) ! FIXME: Segfault\n+!   call a4t(z2) ! FIXME: Segfault\n+!   call a4t(z3) ! FIXME: Segfault\n+!   call a4t(z4) ! FIXME: Segfault\n+!   call a4t(z5) ! FIXME: Segfault\n+!   call a4tp(y,psnt=.true.) ! FIXME: Segfault\n+!   call a4tp(z2,psnt=.false.) ! FIXME: Segfault\n+   call a4caf(z4)\n+   call a4caf(z5)\n+   call ar(x)\n+   call ar(y)\n+   call ar(z)\n+   call ar(z2)\n+   call ar(z3)\n+   call ar(z4)\n+   call ar(z5)\n+   call arp(y,psnt=.true.)\n+   call arp(z2,psnt=.false.)\n+!   call s2elem(x) ! FIXME: Conditional jump or move depends on uninitialised value\n+!   call s2elem(y) ! FIXME: Conditional jump or move depends on uninitialised value\n+!   call s2elem(z) ! FIXME: Segfault\n+!   call s2elem(z2) ! FIXME: Segfault\n+!   call s2elem(z3) ! FIXME: Segfault\n+!   call s2elem(z4) ! FIXME: Segfault\n+!   call s2elem(z5) ! FIXME: Segfault\n+!   call s2elem_t(x) ! FIXME: Conditional jump or move depends on uninitialised value\n+!   call s2elem_t(y) ! FIXME: Conditional jump or move depends on uninitialised value\n+!   call s2elem_t(z) ! FIXME: Segfault\n+!   call s2elem_t(z2) ! FIXME: Segfault\n+!   call s2elem_t(z3) ! FIXME: Segfault\n+!   call s2elem_t(z4) ! FIXME: Segfault\n+!   call s2elem_t(z5) ! FIXME: Segfault\n+ end subroutine a3ac1\n+ subroutine a3ac(z, z2, z3, z4, z5)\n+   class(t2), optional :: z(4), z4(4)[*]\n+   class(t2), optional, pointer :: z2(:)\n+   class(t2), optional, allocatable :: z3(:), z5(:)[:]\n+   class(t2), allocatable :: x(:)\n+   class(t2), pointer :: y(:)\n+   y => null()\n+   call a4(x)\n+   call a4(y)\n+   call a4(z)\n+   call a4(z2)\n+   call a4(z3)\n+   call a4(z4)\n+   call a4(z5)\n+   call a4p(y,psnt=.true.)\n+   call a4p(z2,psnt=.false.)\n+!   call a4t2(x) ! FIXME: Segfault\n+!   call a4t2(y) ! FIXME: Segfault\n+!   call a4t2(z) ! FIXME: Segfault\n+!   call a4t2(z2) ! FIXME: Segfault\n+!   call a4t2(z3) ! FIXME: Segfault\n+!   call a4t2(z4) ! FIXME: Segfault\n+!   call a4t2(z5) ! FIXME: Segfault\n+!   call a4t2p(y,psnt=.true.) ! FIXME: Segfault\n+!   call a4t2p(z2,psnt=.false.) ! FIXME: Segfault\n+   call a4caf(z4)\n+   call a4caf(z5)\n+   call ar(x)\n+   call ar(y)\n+   call ar(z)\n+   call ar(z2)\n+   call ar(z3)\n+   call ar(z4)\n+   call ar(z5)\n+   call arp(y,psnt=.true.) \n+   call arp(z2,psnt=.false.)\n+ end subroutine a3ac\n+\n+ subroutine a4(x)\n+   class(t), intent(in), optional :: x(4)\n+   if (present (x)) call abort ()\n+   !print *, present(x)\n+ end subroutine a4\n+ subroutine a4p(x, psnt)\n+   class(t), pointer, intent(in), optional :: x(:)\n+   logical psnt\n+   if (present (x).neqv. psnt) call abort ()\n+   !print *, present(x)\n+ end subroutine a4p\n+ subroutine a4caf(x)\n+   class(t), intent(in), optional :: x(4)[*]\n+   if (present (x)) call abort ()\n+   !print *, present(x)\n+ end subroutine a4caf\n+ subroutine a4t(x)\n+   type(t), intent(in), optional :: x(4)\n+   if (present (x)) call abort ()\n+   !print *, present(x)\n+ end subroutine a4t\n+ subroutine a4t2(x)\n+   type(t2), intent(in), optional :: x(4)\n+   if (present (x)) call abort ()\n+   !print *, present(x)\n+ end subroutine a4t2\n+ subroutine a4tp(x, psnt)\n+   type(t), pointer, intent(in), optional :: x(:)\n+   logical psnt\n+   if (present (x).neqv. psnt) call abort ()\n+   !print *, present(x)\n+ end subroutine a4tp\n+ subroutine a4t2p(x, psnt)\n+   type(t2), pointer, intent(in), optional :: x(:)\n+   logical psnt\n+   if (present (x).neqv. psnt) call abort ()\n+   !print *, present(x)\n+ end subroutine a4t2p\n+\n+\n+ subroutine ar(x)\n+   class(t), intent(in), optional :: x(..)\n+   if (present (x)) call abort ()\n+   !print *, present(x)\n+ end subroutine ar\n+\n+ subroutine art(x)\n+   type(t), intent(in), optional :: x(..)\n+   if (present (x)) call abort ()\n+   !print *, present(x)\n+ end subroutine art\n+\n+ subroutine arp(x, psnt)\n+   class(t), pointer, intent(in), optional :: x(..)\n+   logical psnt\n+   if (present (x).neqv. psnt) call abort ()\n+   !print *, present(x)\n+ end subroutine arp\n+\n+ subroutine artp(x, psnt)\n+   type(t), intent(in), pointer, optional :: x(..)\n+   logical psnt\n+   if (present (x).neqv. psnt) call abort ()\n+   !print *, present(x)\n+ end subroutine artp\n+\n+\n+\n+ subroutine ar1a1(z, z2, z3)\n+   type(t), optional :: z(..)\n+   type(t), pointer, optional :: z2(..)\n+   type(t), allocatable, optional :: z3(..)\n+   call ar(z)\n+   call ar(z2)\n+   call ar(z3)\n+   call art(z)\n+   call art(z2)\n+   call art(z3)\n+   call arp(z2, .false.)\n+   call artp(z2, .false.)\n+ end subroutine ar1a1\n+ subroutine ar1a(z, z2, z3)\n+   type(t2), optional :: z(..)\n+   type(t2), optional, pointer :: z2(..)\n+   type(t2), optional, allocatable :: z3(..)\n+   call ar(z)\n+   call ar(z2)\n+   call ar(z3)\n+   call arp(z2, .false.)\n+ end subroutine ar1a\n+ subroutine ar1ac1(z, z2, z3)\n+   class(t), optional :: z(..)\n+   class(t), optional, pointer :: z2(..)\n+   class(t), optional, allocatable :: z3(..)\n+   call ar(z)\n+   call ar(z2)\n+   call ar(z3)\n+!   call art(z) ! FIXME: ICE - This requires packing support for assumed-rank\n+!   call art(z2)! FIXME: ICE - This requires packing support for assumed-rank\n+!   call art(z3)! FIXME: ICE - This requires packing support for assumed-rank\n+   call arp(z2, .false.)\n+!   call artp(z2, .false.) ! FIXME: ICE\n+ end subroutine ar1ac1\n+ subroutine ar1ac(z, z2, z3)\n+   class(t2), optional :: z(..)\n+   class(t2), optional, pointer :: z2(..)\n+   class(t2), optional, allocatable :: z3(..)\n+   call ar(z)\n+   call ar(z2)\n+   call ar(z3)\n+   call arp(z2, .false.)\n+ end subroutine ar1ac\n+end"}]}