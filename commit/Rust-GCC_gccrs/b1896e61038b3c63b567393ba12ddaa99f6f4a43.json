{"sha": "b1896e61038b3c63b567393ba12ddaa99f6f4a43", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjE4OTZlNjEwMzhiM2M2M2I1NjczOTNiYTEyZGRhYTk5ZjZmNGE0Mw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2002-04-06T19:42:22Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2002-04-06T19:42:22Z"}, "message": "re PR rtl-optimization/5120 (tail recursion incorrect using -O2)\n\n\tPR opt/5120\n\t* sibcall.c (optimize_sibling_and_tail_recursive_call): Clear\n\tRTX_UNCHANGING_P for the functions arguments when a tail call\n\tis made.\n\nFrom-SVN: r51969", "tree": {"sha": "1bbe36ac9cb6e53aa6cc59b0bee82e20c63cf21e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1bbe36ac9cb6e53aa6cc59b0bee82e20c63cf21e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1896e61038b3c63b567393ba12ddaa99f6f4a43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1896e61038b3c63b567393ba12ddaa99f6f4a43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1896e61038b3c63b567393ba12ddaa99f6f4a43", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1896e61038b3c63b567393ba12ddaa99f6f4a43/comments", "author": null, "committer": null, "parents": [{"sha": "b01488847164f74449ebd08cd35f95660b91de8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b01488847164f74449ebd08cd35f95660b91de8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b01488847164f74449ebd08cd35f95660b91de8b"}], "stats": {"total": 147, "additions": 147, "deletions": 0}, "files": [{"sha": "548caa9c81f78bb43b9c3b7228cdf82e80d1f854", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1896e61038b3c63b567393ba12ddaa99f6f4a43/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1896e61038b3c63b567393ba12ddaa99f6f4a43/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b1896e61038b3c63b567393ba12ddaa99f6f4a43", "patch": "@@ -1,3 +1,10 @@\n+2002-04-06  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR opt/5120\n+\t* sibcall.c (optimize_sibling_and_tail_recursive_call): Clear\n+\tRTX_UNCHANGING_P for the functions arguments when a tail call\n+\tis made.\n+\n 2002-04-06  Jason Merrill  <jason@redhat.com>\n \n \t* toplev.c (flag_no_inline, flag_really_no_inline): Default to 2."}, {"sha": "6e753fa2fa99bbcc3459f2d16c9a22776a05b486", "filename": "gcc/sibcall.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1896e61038b3c63b567393ba12ddaa99f6f4a43/gcc%2Fsibcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1896e61038b3c63b567393ba12ddaa99f6f4a43/gcc%2Fsibcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsibcall.c?ref=b1896e61038b3c63b567393ba12ddaa99f6f4a43", "patch": "@@ -31,6 +31,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"basic-block.h\"\n #include \"output.h\"\n #include \"except.h\"\n+#include \"tree.h\"\n \n /* In case alternate_exit_block contains copy from pseudo, to return value,\n    record the pseudo here.  In such case the pseudo must be set to function\n@@ -730,6 +731,7 @@ optimize_sibling_and_tail_recursive_calls ()\n   if (successful_sibling_call)\n     {\n       rtx insn;\n+      tree arg;\n \n       /* A sibling call sequence invalidates any REG_EQUIV notes made for\n \t this function's incoming arguments. \n@@ -754,6 +756,16 @@ optimize_sibling_and_tail_recursive_calls ()\n \t  if (INSN_P (insn))\n \t    purge_mem_unchanging_flag (PATTERN (insn));\n \t}\n+\n+      /* Similarly, invalidate RTX_UNCHANGING_P for any incoming\n+\t arguments passed in registers. */\n+      for (arg = DECL_ARGUMENTS (current_function_decl); \n+\t   arg; \n+\t   arg = TREE_CHAIN (arg))\n+\t{\n+\t  if (REG_P (DECL_RTL (arg)))\n+\t    RTX_UNCHANGING_P (DECL_RTL (arg)) = false;\n+\t}\n     }\n \n   /* There may have been NOTE_INSN_BLOCK_{BEGIN,END} notes in the "}, {"sha": "ddd75d41ea888bc994d8844584aed6305c716fc2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1896e61038b3c63b567393ba12ddaa99f6f4a43/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1896e61038b3c63b567393ba12ddaa99f6f4a43/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b1896e61038b3c63b567393ba12ddaa99f6f4a43", "patch": "@@ -1,3 +1,8 @@\n+2002-04-06  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c/5120\n+\t* gcc.dg/20020406-1.c: New test.\n+\n 2002-04-04  David S. Miller  <davem@redhat.com>\n \n \t* gcc.c-torture/execute/20020404-1.c: New test."}, {"sha": "6d4967eae55c8ec9cd2e4c6b4f6404982127ce95", "filename": "gcc/testsuite/gcc.c-torture/execute/20020406-1.c", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1896e61038b3c63b567393ba12ddaa99f6f4a43/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20020406-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1896e61038b3c63b567393ba12ddaa99f6f4a43/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20020406-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20020406-1.c?ref=b1896e61038b3c63b567393ba12ddaa99f6f4a43", "patch": "@@ -0,0 +1,123 @@\n+// Origin: abbott@dima.unige.it\n+// PR c/5120\n+\n+typedef unsigned int FFelem;\n+\n+FFelem FFmul(const FFelem x, const FFelem y)\n+{\n+  return x;\n+}\n+\n+\n+struct DUPFFstruct\n+{\n+  int maxdeg;\n+  int deg;\n+  FFelem *coeffs;\n+};\n+\n+typedef struct DUPFFstruct *DUPFF;\n+\n+\n+int DUPFFdeg(const DUPFF f)\n+{\n+  return f->deg;\n+}\n+\n+\n+DUPFF DUPFFnew(const int maxdeg)\n+{\n+  DUPFF ans = (DUPFF)malloc(sizeof(struct DUPFFstruct));\n+  ans->coeffs = 0;\n+  if (maxdeg >= 0) ans->coeffs = (FFelem*)malloc((maxdeg+1)*sizeof(FFelem));\n+  ans->maxdeg = maxdeg;\n+  ans->deg = -1;\n+  return ans;\n+}\n+\n+void DUPFFfree(DUPFF x)\n+{\n+}\n+\n+void DUPFFswap(DUPFF x, DUPFF y)\n+{\n+}\n+\n+\n+DUPFF DUPFFcopy(const DUPFF x)\n+{\n+  return x;\n+}\n+\n+\n+void DUPFFshift_add(DUPFF f, const DUPFF g, int deg, const FFelem coeff)\n+{\n+}\n+\n+\n+DUPFF DUPFFexgcd(DUPFF *fcofac, DUPFF *gcofac, const DUPFF f, const DUPFF g)\n+{\n+  DUPFF u, v, uf, ug, vf, vg;\n+  FFelem q, lcu, lcvrecip, p;\n+  int df, dg, du, dv;\n+\n+  printf(\"DUPFFexgcd called on degrees %d and %d\\n\", DUPFFdeg(f), DUPFFdeg(g));\n+  if (DUPFFdeg(f) < DUPFFdeg(g)) return DUPFFexgcd(gcofac, fcofac, g, f);  /*** BUG IN THIS LINE ***/\n+  if (DUPFFdeg(f) != 2 || DUPFFdeg(g) != 1) abort();\n+  if (f->coeffs[0] == 0) return f;\n+  /****** NEVER REACH HERE IN THE EXAMPLE ******/\n+  p = 2;\n+\n+  df = DUPFFdeg(f);  if (df < 0) df = 0; /* both inputs are zero */\n+  dg = DUPFFdeg(g);  if (dg < 0) dg = 0; /* one input is zero */\n+  u = DUPFFcopy(f);\n+  v = DUPFFcopy(g);\n+\n+  uf = DUPFFnew(dg); uf->coeffs[0] = 1; uf->deg = 0;\n+  ug = DUPFFnew(df);\n+  vf = DUPFFnew(dg);\n+  vg = DUPFFnew(df); vg->coeffs[0] = 1; vg->deg = 0;\n+\n+  while (DUPFFdeg(v) > 0)\n+  {\n+    dv = DUPFFdeg(v);\n+    lcvrecip = FFmul(1, v->coeffs[dv]);\n+    while (DUPFFdeg(u) >= dv)\n+    {\n+      du = DUPFFdeg(u);\n+      lcu = u->coeffs[du];\n+      q = FFmul(lcu, lcvrecip);\n+      DUPFFshift_add(u, v, du-dv, p-q);\n+      DUPFFshift_add(uf, vf, du-dv, p-q);\n+      DUPFFshift_add(ug, vg, du-dv, p-q);\n+    }\n+    DUPFFswap(u, v);\n+    DUPFFswap(uf, vf);\n+    DUPFFswap(ug, vg);\n+  }\n+  if (DUPFFdeg(v) == 0)\n+  {\n+    DUPFFswap(u, v);\n+    DUPFFswap(uf, vf);\n+    DUPFFswap(ug, vg);\n+  }\n+  DUPFFfree(vf);\n+  DUPFFfree(vg);\n+  DUPFFfree(v);\n+  *fcofac = uf;\n+  *gcofac = ug;\n+  return u;\n+}\n+\n+\n+\n+int main()\n+{\n+  DUPFF f, g, cf, cg, h;\n+  f = DUPFFnew(1); f->coeffs[1] = 1; f->deg = 1;\n+  g = DUPFFnew(2); g->coeffs[2] = 1; g->deg = 2;\n+\n+  printf(\"calling DUPFFexgcd on degrees %d and %d\\n\", DUPFFdeg(f), DUPFFdeg(g)) ;\n+  h = DUPFFexgcd(&cf, &cg, f, g);\n+  return 0;\n+}"}]}