{"sha": "82f7c45f924ec4b3b905c5b930fb50a405cc7d94", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODJmN2M0NWY5MjRlYzRiM2I5MDVjNWI5MzBmYjUwYTQwNWNjN2Q5NA==", "commit": {"author": {"name": "Geert Bosch", "email": "bosch@adacore.com", "date": "2008-10-17T19:22:42Z"}, "committer": {"name": "Geert Bosch", "email": "bosch@gcc.gnu.org", "date": "2008-10-17T19:22:42Z"}, "message": "trans.c (gnat_to_gnu): Simplify expansion to use only a single check instead of three...\n\n\t* gcc-interface/trans.c (gnat_to_gnu) <N_Slice>: Simplify expansion\n\tto use only a single check instead of three, and avoid unnecessary\n\tCOMPOUND_EXPR.\n\t(emit_check): Avoid useless COMPOUND_EXPRs and SAVE_EXPRs, sometimes\n\tcreating more opportunities for optimizations.\n\nFrom-SVN: r141198", "tree": {"sha": "0290671889364d0a3a7a5d741ded8b27aefe54f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0290671889364d0a3a7a5d741ded8b27aefe54f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82f7c45f924ec4b3b905c5b930fb50a405cc7d94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82f7c45f924ec4b3b905c5b930fb50a405cc7d94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82f7c45f924ec4b3b905c5b930fb50a405cc7d94", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82f7c45f924ec4b3b905c5b930fb50a405cc7d94/comments", "author": null, "committer": null, "parents": [{"sha": "1f6d0c60bacd58ed5dea39bad23e540e01de65ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f6d0c60bacd58ed5dea39bad23e540e01de65ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f6d0c60bacd58ed5dea39bad23e540e01de65ce"}], "stats": {"total": 95, "additions": 48, "deletions": 47}, "files": [{"sha": "caee7260244f5becd2f43073e5e0c5862b5c0ae6", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82f7c45f924ec4b3b905c5b930fb50a405cc7d94/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82f7c45f924ec4b3b905c5b930fb50a405cc7d94/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=82f7c45f924ec4b3b905c5b930fb50a405cc7d94", "patch": "@@ -1,3 +1,11 @@\n+2008-10-17  Geert Bosch  <bosch@adacore.com>\n+\n+\t* gcc-interface/trans.c (gnat_to_gnu) <N_Slice>: Simplify expansion\n+\tto use only a single check instead of three, and avoid unnecessary\n+\tCOMPOUND_EXPR.\n+\t(emit_check): Avoid useless COMPOUND_EXPRs and SAVE_EXPRs, sometimes\n+\tcreating more opportunities for optimizations.\n+\n 2008-10-13  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/37601"}, {"sha": "6ade56869d9f58d49782200185677f579183a314", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 40, "deletions": 47, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82f7c45f924ec4b3b905c5b930fb50a405cc7d94/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82f7c45f924ec4b3b905c5b930fb50a405cc7d94/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=82f7c45f924ec4b3b905c5b930fb50a405cc7d94", "patch": "@@ -3563,32 +3563,40 @@ gnat_to_gnu (Node_Id gnat_node)\n \t    /* Get the permitted bounds.  */\n \t    tree gnu_base_index_type\n \t      = TYPE_INDEX_TYPE (TYPE_DOMAIN (gnu_type));\n-\t    tree gnu_base_min_expr = TYPE_MIN_VALUE (gnu_base_index_type);\n-\t    tree gnu_base_max_expr = TYPE_MAX_VALUE (gnu_base_index_type);\n+\t    tree gnu_base_min_expr = SUBSTITUTE_PLACEHOLDER_IN_EXPR\n+\t      (TYPE_MIN_VALUE (gnu_base_index_type), gnu_result);\n+\t    tree gnu_base_max_expr = SUBSTITUTE_PLACEHOLDER_IN_EXPR\n+\t      (TYPE_MAX_VALUE (gnu_base_index_type), gnu_result);\n \t    tree gnu_expr_l, gnu_expr_h, gnu_expr_type;\n \n-\t    /* Check to see that the minimum slice value is in range.  */\n-\t    gnu_expr_l = emit_index_check (gnu_result,\n-\t\t\t\t\t   gnu_min_expr,\n-\t\t\t\t\t   gnu_base_min_expr,\n-\t\t\t\t\t   gnu_base_max_expr);\n-\n-\t    /* Check to see that the maximum slice value is in range.  */\n-\t    gnu_expr_h = emit_index_check (gnu_result,\n-\t\t\t\t\t   gnu_max_expr,\n-\t\t\t\t\t   gnu_base_min_expr,\n-\t\t\t\t\t   gnu_base_max_expr);\n+\t   gnu_min_expr = protect_multiple_eval (gnu_min_expr);\n+\t   gnu_max_expr = protect_multiple_eval (gnu_max_expr);\n \n \t    /* Derive a good type to convert everything to.  */\n-\t    gnu_expr_type = get_base_type (TREE_TYPE (gnu_expr_l));\n-\n-\t    /* Build a compound expression that does the range checks and\n-\t       returns the low bound.  */\n-\t    gnu_expr = build_binary_op (COMPOUND_EXPR, gnu_expr_type,\n-\t\t\t\t\tconvert (gnu_expr_type, gnu_expr_h),\n-\t\t\t\t\tconvert (gnu_expr_type, gnu_expr_l));\n-\n-\t   /* Build a conditional expression that does the range check and\n+\t    gnu_expr_type = get_base_type (TREE_TYPE (gnu_index_type));\n+\n+\t    /* Test whether the minimum slice value is too small.  */\n+\t    gnu_expr_l = build_binary_op (LT_EXPR, integer_type_node,\n+\t\t\t\t\t  convert (gnu_expr_type,\n+\t\t\t\t\t\t   gnu_min_expr),\n+\t\t\t\t\t  convert (gnu_expr_type,\n+\t\t\t\t\t\t   gnu_base_min_expr));\n+\n+\t    /* Test whether the maximum slice value is too large.  */\n+\t    gnu_expr_h = build_binary_op (GT_EXPR, integer_type_node,\n+\t\t\t\t\t  convert (gnu_expr_type,\n+\t\t\t\t\t\t   gnu_max_expr),\n+\t\t\t\t\t  convert (gnu_expr_type,\n+\t\t\t\t\t\t   gnu_base_max_expr));\n+\n+\t    /* Build a slice index check that returns the low bound,\n+               assuming the slice is not empty.  */\n+\t    gnu_expr = emit_check\n+\t      (build_binary_op (TRUTH_ORIF_EXPR, integer_type_node,\n+\t\t\t\tgnu_expr_l, gnu_expr_h),\n+\t       gnu_min_expr, CE_Index_Check_Failed);\n+\n+\t   /* Build a conditional expression that does the index checks and\n \t      returns the low bound if the slice is not empty (max >= min),\n \t      and returns the naked low bound otherwise (max < min), unless\n \t      it is non-constant and the high bound is; this prevents VRP\n@@ -6186,33 +6194,18 @@ emit_index_check (tree gnu_array_object,\n static tree\n emit_check (tree gnu_cond, tree gnu_expr, int reason)\n {\n-  tree gnu_call;\n-  tree gnu_result;\n+  tree gnu_call = build_call_raise (reason, Empty, N_Raise_Constraint_Error);\n+  tree gnu_result\n+    = fold_build3 (COND_EXPR, TREE_TYPE (gnu_expr), gnu_cond,\n+\t\t   build2 (COMPOUND_EXPR, TREE_TYPE (gnu_expr), gnu_call,\n+\t\t\t   convert (TREE_TYPE (gnu_expr), integer_zero_node)),\n+\t\t   gnu_expr);\n \n-  gnu_call = build_call_raise (reason, Empty, N_Raise_Constraint_Error);\n-\n-  /* Use an outer COMPOUND_EXPR to make sure that GNU_EXPR will get evaluated\n-     in front of the comparison in case it ends up being a SAVE_EXPR.  Put the\n-     whole thing inside its own SAVE_EXPR so the inner SAVE_EXPR doesn't leak\n-     out.  */\n-  gnu_result = fold_build3 (COND_EXPR, TREE_TYPE (gnu_expr), gnu_cond,\n-\t\t\t    build2 (COMPOUND_EXPR, TREE_TYPE (gnu_expr),\n-\t\t\t\t    gnu_call, gnu_expr),\n-\t\t\t    gnu_expr);\n-\n-  /* If GNU_EXPR has side effects, make the outer COMPOUND_EXPR and\n-     protect it.  Otherwise, show GNU_RESULT has no side effects: we\n-     don't need to evaluate it just for the check.  */\n-  if (TREE_SIDE_EFFECTS (gnu_expr))\n-    gnu_result\n-      = build2 (COMPOUND_EXPR, TREE_TYPE (gnu_expr), gnu_expr, gnu_result);\n-  else\n-    TREE_SIDE_EFFECTS (gnu_result) = 0;\n+  /* GNU_RESULT has side effects if and only if GNU_EXPR has:\n+     we don't need to evaluate it just for the check.  */\n+  TREE_SIDE_EFFECTS (gnu_result) = TREE_SIDE_EFFECTS (gnu_expr);\n \n-  /* ??? Unfortunately, if we don't put a SAVE_EXPR around this whole thing,\n-     we will repeatedly do the test.  It would be nice if GCC was able\n-     to optimize this and only do it once.  */\n-  return save_expr (gnu_result);\n+  return gnu_result;\n }\n \f\n /* Return an expression that converts GNU_EXPR to GNAT_TYPE, doing"}]}