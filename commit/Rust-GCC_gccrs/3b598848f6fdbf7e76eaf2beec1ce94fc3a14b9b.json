{"sha": "3b598848f6fdbf7e76eaf2beec1ce94fc3a14b9b", "node_id": "C_kwDOANBUbNoAKDNiNTk4ODQ4ZjZmZGJmN2U3NmVhZjJiZWVjMWNlOTRmYzNhMTRiOWI", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-06-13T11:32:53Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-06-13T11:35:33Z"}, "message": "Introduce -finstrument-functions-once\n\nThe goal is to make it possible to use it in (large) production binaries\nto do function-level coverage, so the overhead must be minimum and, in\nparticular, there is no protection against data races so the \"once\"\nmoniker is imprecise.\n\ngcc/\n\t* common.opt (finstrument-functions): Set explicit value.\n\t(-finstrument-functions-once): New option.\n\t* doc/invoke.texi (Program Instrumentation Options): Document it.\n\t* gimplify.cc (build_instrumentation_call): New static function.\n\t(gimplify_function_tree): Call it to emit the instrumentation calls\n\tif -finstrument-functions[-once] is specified.\ngcc/testsuite/\n\t* gcc.dg/instrument-4.c: New test.", "tree": {"sha": "0689dfb33dff5dfea9006f428831f3a6b4f5e1e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0689dfb33dff5dfea9006f428831f3a6b4f5e1e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b598848f6fdbf7e76eaf2beec1ce94fc3a14b9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b598848f6fdbf7e76eaf2beec1ce94fc3a14b9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b598848f6fdbf7e76eaf2beec1ce94fc3a14b9b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b598848f6fdbf7e76eaf2beec1ce94fc3a14b9b/comments", "author": null, "committer": null, "parents": [{"sha": "cb1ecf3819f19a4fc35468010b66b5c1a7b21ee8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb1ecf3819f19a4fc35468010b66b5c1a7b21ee8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb1ecf3819f19a4fc35468010b66b5c1a7b21ee8"}], "stats": {"total": 168, "additions": 133, "deletions": 35}, "files": [{"sha": "8e961f16b0ef16f807761f54f757d20476671bec", "filename": "gcc/common.opt", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b598848f6fdbf7e76eaf2beec1ce94fc3a14b9b/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b598848f6fdbf7e76eaf2beec1ce94fc3a14b9b/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=3b598848f6fdbf7e76eaf2beec1ce94fc3a14b9b", "patch": "@@ -1890,9 +1890,13 @@ EnumValue\n Enum(cf_protection_level) String(none) Value(CF_NONE)\n \n finstrument-functions\n-Common Var(flag_instrument_function_entry_exit)\n+Common Var(flag_instrument_function_entry_exit,1)\n Instrument function entry and exit with profiling calls.\n \n+finstrument-functions-once\n+Common Var(flag_instrument_function_entry_exit,2)\n+Instrument function entry and exit with profiling calls invoked once.\n+\n finstrument-functions-exclude-function-list=\n Common RejectNegative Joined\n -finstrument-functions-exclude-function-list=name,...\tDo not instrument listed functions."}, {"sha": "b6c0305f198f9e5a9e3d9d247a0c46dd2ba13f33", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b598848f6fdbf7e76eaf2beec1ce94fc3a14b9b/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b598848f6fdbf7e76eaf2beec1ce94fc3a14b9b/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=3b598848f6fdbf7e76eaf2beec1ce94fc3a14b9b", "patch": "@@ -618,7 +618,7 @@ Objective-C and Objective-C++ Dialects}.\n -fno-stack-limit  -fsplit-stack @gol\n -fvtable-verify=@r{[}std@r{|}preinit@r{|}none@r{]} @gol\n -fvtv-counts  -fvtv-debug @gol\n--finstrument-functions @gol\n+-finstrument-functions  -finstrument-functions-once @gol\n -finstrument-functions-exclude-function-list=@var{sym},@var{sym},@dots{} @gol\n -finstrument-functions-exclude-file-list=@var{file},@var{file},@dots{}} @gol\n -fprofile-prefix-map=@var{old}=@var{new}\n@@ -16395,6 +16395,22 @@ cannot safely be called (perhaps signal handlers, if the profiling\n routines generate output or allocate memory).\n @xref{Common Function Attributes}.\n \n+@item -finstrument-functions-once\n+@opindex -finstrument-functions-once\n+This is similar to @option{-finstrument-functions}, but the profiling\n+functions are called only once per instrumented function, i.e. the first\n+profiling function is called after the first entry into the instrumented\n+function and the second profiling function is called before the exit\n+corresponding to this first entry.\n+\n+The definition of @code{once} for the purpose of this option is a little\n+vague because the implementation is not protected against data races.\n+As a result, the implementation only guarantees that the profiling\n+functions are called at @emph{least} once per process and at @emph{most}\n+once per thread, but the calls are always paired, that is to say, if a\n+thread calls the first function, then it will call the second function,\n+unless it never reaches the exit of the instrumented function.\n+\n @item -finstrument-functions-exclude-file-list=@var{file},@var{file},@dots{}\n @opindex finstrument-functions-exclude-file-list\n "}, {"sha": "04990ad91a6be31ec93f16db59d1ede10d3f28ae", "filename": "gcc/gimplify.cc", "status": "modified", "additions": 104, "deletions": 33, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b598848f6fdbf7e76eaf2beec1ce94fc3a14b9b/gcc%2Fgimplify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b598848f6fdbf7e76eaf2beec1ce94fc3a14b9b/gcc%2Fgimplify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.cc?ref=3b598848f6fdbf7e76eaf2beec1ce94fc3a14b9b", "patch": "@@ -16586,6 +16586,51 @@ flag_instrument_functions_exclude_p (tree fndecl)\n   return false;\n }\n \n+/* Build a call to the instrumentation function FNCODE and add it to SEQ.\n+   If COND_VAR is not NULL, it is a boolean variable guarding the call to\n+   the instrumentation function.  IF STMT is not NULL, it is a statement\n+   to be executed just before the call to the instrumentation function.  */\n+\n+static void\n+build_instrumentation_call (gimple_seq *seq, enum built_in_function fncode,\n+\t\t\t    tree cond_var, gimple *stmt)\n+{\n+  /* The instrumentation hooks aren't going to call the instrumented\n+     function and the address they receive is expected to be matchable\n+     against symbol addresses.  Make sure we don't create a trampoline,\n+     in case the current function is nested.  */\n+  tree this_fn_addr = build_fold_addr_expr (current_function_decl);\n+  TREE_NO_TRAMPOLINE (this_fn_addr) = 1;\n+\n+  tree label_true, label_false;\n+  if (cond_var)\n+    {\n+      label_true = create_artificial_label (UNKNOWN_LOCATION);\n+      label_false = create_artificial_label (UNKNOWN_LOCATION);\n+      gcond *cond = gimple_build_cond (EQ_EXPR, cond_var, boolean_false_node,\n+\t\t\t\t      label_true, label_false);\n+      gimplify_seq_add_stmt (seq, cond);\n+      gimplify_seq_add_stmt (seq, gimple_build_label (label_true));\n+      gimplify_seq_add_stmt (seq, gimple_build_predict (PRED_COLD_LABEL,\n+\t\t\t\t\t\t\tNOT_TAKEN));\n+    }\n+\n+  if (stmt)\n+    gimplify_seq_add_stmt (seq, stmt);\n+\n+  tree x = builtin_decl_implicit (BUILT_IN_RETURN_ADDRESS);\n+  gcall *call = gimple_build_call (x, 1, integer_zero_node);\n+  tree tmp_var = create_tmp_var (ptr_type_node, \"return_addr\");\n+  gimple_call_set_lhs (call, tmp_var);\n+  gimplify_seq_add_stmt (seq, call);\n+  x = builtin_decl_implicit (fncode);\n+  call = gimple_build_call (x, 2, this_fn_addr, tmp_var);\n+  gimplify_seq_add_stmt (seq, call);\n+\n+  if (cond_var)\n+    gimplify_seq_add_stmt (seq, gimple_build_label (label_false));\n+}\n+\n /* Entry point to the gimplification pass.  FNDECL is the FUNCTION_DECL\n    node for the function we want to gimplify.\n \n@@ -16636,40 +16681,66 @@ gimplify_function_tree (tree fndecl)\n \t   && DECL_DISREGARD_INLINE_LIMITS (fndecl))\n       && !flag_instrument_functions_exclude_p (fndecl))\n     {\n-      tree x;\n-      gbind *new_bind;\n-      gimple *tf;\n-      gimple_seq cleanup = NULL, body = NULL;\n-      tree tmp_var, this_fn_addr;\n-      gcall *call;\n-\n-      /* The instrumentation hooks aren't going to call the instrumented\n-\t function and the address they receive is expected to be matchable\n-\t against symbol addresses.  Make sure we don't create a trampoline,\n-\t in case the current function is nested.  */\n-      this_fn_addr = build_fold_addr_expr (current_function_decl);\n-      TREE_NO_TRAMPOLINE (this_fn_addr) = 1;\n-\n-      x = builtin_decl_implicit (BUILT_IN_RETURN_ADDRESS);\n-      call = gimple_build_call (x, 1, integer_zero_node);\n-      tmp_var = create_tmp_var (ptr_type_node, \"return_addr\");\n-      gimple_call_set_lhs (call, tmp_var);\n-      gimplify_seq_add_stmt (&cleanup, call);\n-      x = builtin_decl_implicit (BUILT_IN_PROFILE_FUNC_EXIT);\n-      call = gimple_build_call (x, 2, this_fn_addr, tmp_var);\n-      gimplify_seq_add_stmt (&cleanup, call);\n-      tf = gimple_build_try (seq, cleanup, GIMPLE_TRY_FINALLY);\n-\n-      x = builtin_decl_implicit (BUILT_IN_RETURN_ADDRESS);\n-      call = gimple_build_call (x, 1, integer_zero_node);\n-      tmp_var = create_tmp_var (ptr_type_node, \"return_addr\");\n-      gimple_call_set_lhs (call, tmp_var);\n-      gimplify_seq_add_stmt (&body, call);\n-      x = builtin_decl_implicit (BUILT_IN_PROFILE_FUNC_ENTER);\n-      call = gimple_build_call (x, 2, this_fn_addr, tmp_var);\n-      gimplify_seq_add_stmt (&body, call);\n+      gimple_seq body = NULL, cleanup = NULL;\n+      gassign *assign;\n+      tree cond_var;\n+\n+      /* If -finstrument-functions-once is specified, generate:\n+\n+\t   static volatile bool C.0 = false;\n+\t   bool tmp_called;\n+\n+\t   tmp_called = C.0;\n+\t   if (!tmp_called)\n+\t     {\n+\t       C.0 = true;\n+\t       [call profiling enter function]\n+\t     }\n+\n+\t without specific protection for data races.  */\n+      if (flag_instrument_function_entry_exit > 1)\n+\t{\n+\t  tree first_var\n+\t    = build_decl (DECL_SOURCE_LOCATION (current_function_decl),\n+\t\t\t  VAR_DECL,\n+\t\t\t  create_tmp_var_name (\"C\"),\n+\t\t\t  boolean_type_node);\n+\t  DECL_ARTIFICIAL (first_var) = 1;\n+\t  DECL_IGNORED_P (first_var) = 1;\n+\t  TREE_STATIC (first_var) = 1;\n+\t  TREE_THIS_VOLATILE (first_var) = 1;\n+\t  TREE_USED (first_var) = 1;\n+\t  DECL_INITIAL (first_var) = boolean_false_node;\n+\t  varpool_node::add (first_var);\n+\n+\t  cond_var = create_tmp_var (boolean_type_node, \"tmp_called\");\n+\t  assign = gimple_build_assign (cond_var, first_var);\n+\t  gimplify_seq_add_stmt (&body, assign);\n+\n+\t  assign = gimple_build_assign (first_var, boolean_true_node);\n+\t}\n+\n+      else\n+\t{\n+\t  cond_var = NULL_TREE;\n+\t  assign = NULL;\n+\t}\n+\n+      build_instrumentation_call (&body, BUILT_IN_PROFILE_FUNC_ENTER,\n+\t\t\t\t  cond_var, assign);\n+\n+      /* If -finstrument-functions-once is specified, generate:\n+\n+\t   if (!tmp_called)\n+\t     [call profiling exit function]\n+\n+\t without specific protection for data races.  */\n+      build_instrumentation_call (&cleanup, BUILT_IN_PROFILE_FUNC_EXIT,\n+\t\t\t\t  cond_var, NULL);\n+\n+      gimple *tf = gimple_build_try (seq, cleanup, GIMPLE_TRY_FINALLY);\n       gimplify_seq_add_stmt (&body, tf);\n-      new_bind = gimple_build_bind (NULL, body, NULL);\n+      gbind *new_bind = gimple_build_bind (NULL, body, NULL);\n \n       /* Replace the current function body with the body\n          wrapped in the try/finally TF.  */"}, {"sha": "c19e8bf397183121952e751a8876e27a54fdf0a2", "filename": "gcc/testsuite/gcc.dg/instrument-4.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b598848f6fdbf7e76eaf2beec1ce94fc3a14b9b/gcc%2Ftestsuite%2Fgcc.dg%2Finstrument-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b598848f6fdbf7e76eaf2beec1ce94fc3a14b9b/gcc%2Ftestsuite%2Fgcc.dg%2Finstrument-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Finstrument-4.c?ref=3b598848f6fdbf7e76eaf2beec1ce94fc3a14b9b", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-finstrument-functions-once\" } */\n+\n+void fn () { }\n+\n+/* { dg-final { scan-assembler \"__cyg_profile_func_enter\" } } */\n+/* { dg-final { scan-assembler \"__cyg_profile_func_exit\" } } */"}]}