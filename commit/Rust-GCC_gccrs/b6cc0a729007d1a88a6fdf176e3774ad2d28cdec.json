{"sha": "b6cc0a729007d1a88a6fdf176e3774ad2d28cdec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjZjYzBhNzI5MDA3ZDFhODhhNmZkZjE3NmUzNzc0YWQyZDI4Y2RlYw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2000-08-02T15:28:44Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-08-02T15:28:44Z"}, "message": "* fold-const.c: Fix formatting.\n\nFrom-SVN: r35425", "tree": {"sha": "1c85364c1500fab7318cf8e09bce7e2ed2652815", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c85364c1500fab7318cf8e09bce7e2ed2652815"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6cc0a729007d1a88a6fdf176e3774ad2d28cdec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6cc0a729007d1a88a6fdf176e3774ad2d28cdec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6cc0a729007d1a88a6fdf176e3774ad2d28cdec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6cc0a729007d1a88a6fdf176e3774ad2d28cdec/comments", "author": null, "committer": null, "parents": [{"sha": "4e9efe546e1443219d13d8fab76adaed392cd6c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e9efe546e1443219d13d8fab76adaed392cd6c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e9efe546e1443219d13d8fab76adaed392cd6c7"}], "stats": {"total": 728, "additions": 363, "deletions": 365}, "files": [{"sha": "38eeb62314559cea1ff28fd73f9115a165d58566", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6cc0a729007d1a88a6fdf176e3774ad2d28cdec/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6cc0a729007d1a88a6fdf176e3774ad2d28cdec/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b6cc0a729007d1a88a6fdf176e3774ad2d28cdec", "patch": "@@ -1,3 +1,7 @@\n+2000-08-02  Kazu Hirata  <kazu@hxi.com>\n+\n+\t* fold-const.c: Fix formatting.\n+\n Wed Aug  2 16:26:15 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n \n \t* i386.c (legitimate_address_p): Accept other bases than"}, {"sha": "73c7a47553ed7b8b9eb87b0d7ac4d22f256b8a9f", "filename": "gcc/fold-const.c", "status": "modified", "additions": 359, "deletions": 365, "changes": 724, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6cc0a729007d1a88a6fdf176e3774ad2d28cdec/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6cc0a729007d1a88a6fdf176e3774ad2d28cdec/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=b6cc0a729007d1a88a6fdf176e3774ad2d28cdec", "patch": "@@ -27,7 +27,6 @@ Boston, MA 02111-1307, USA.  */\n   @@ This would also make life easier when this technology is used\n   @@ for cross-compilers.  */\n \n-\n /* The entry points in this file are fold, size_int_wide, size_binop\n    and force_fit_type.\n \n@@ -113,7 +112,6 @@ static int count_cond\t\tPARAMS ((tree, int));\n #define CHARMASK 0x7f\n #endif\n \n-\n /* We know that A1 + B1 = SUM1, using 2's complement arithmetic and ignoring\n    overflow.  Suppose A, B and SUM have the same respective signs as A1, B1,\n    and SUM1.  Then this yields nonzero if overflow occurred during the\n@@ -293,8 +291,8 @@ neg_double (l1, h1, lv, hv)\n     }\n   else\n     {\n-      *lv = - l1;\n-      *hv = ~ h1;\n+      *lv = -l1;\n+      *hv = ~h1;\n       return 0;\n     }\n }\n@@ -345,7 +343,7 @@ mul_double (l1, h1, l2, h2, lv, hv)\n \n   /* Check for overflow by calculating the top half of the answer in full;\n      it should agree with the low half's sign bit.  */\n-  decode (prod+4, &toplow, &tophigh);\n+  decode (prod + 4, &toplow, &tophigh);\n   if (h1 < 0)\n     {\n       neg_double (l2, h2, &neglow, &neghigh);\n@@ -376,10 +374,10 @@ lshift_double (l1, h1, count, prec, lv, hv, arith)\n {\n   if (count < 0)\n     {\n-      rshift_double (l1, h1, - count, prec, lv, hv, arith);\n+      rshift_double (l1, h1, -count, prec, lv, hv, arith);\n       return;\n     }\n-  \n+\n #ifdef SHIFT_COUNT_TRUNCATED\n   if (SHIFT_COUNT_TRUNCATED)\n     count %= prec;\n@@ -541,7 +539,7 @@ div_and_round_double (code, uns,\n     overflow = 1, lden = 1;\n \n   /* calculate quotient sign and convert operands to unsigned.  */\n-  if (!uns) \n+  if (!uns)\n     {\n       if (hnum < 0)\n \t{\n@@ -551,7 +549,7 @@ div_and_round_double (code, uns,\n \t      && ((HOST_WIDE_INT) lden & hden) == -1)\n \t    overflow = 1;\n \t}\n-      if (hden < 0) \n+      if (hden < 0)\n \t{\n \t  quo_neg = ~ quo_neg;\n \t  neg_double (lden, hden, &lden, &hden);\n@@ -580,7 +578,7 @@ div_and_round_double (code, uns,\n   bzero ((char *) num, sizeof num);\t/* to zero 9th element */\n   bzero ((char *) den, sizeof den);\n \n-  encode (num, lnum, hnum); \n+  encode (num, lnum, hnum);\n   encode (den, lden, hden);\n \n   /* Special code for when the divisor < BASE.  */\n@@ -602,11 +600,12 @@ div_and_round_double (code, uns,\n       unsigned HOST_WIDE_INT quo_est, scale;\n \n       /* Find the highest non-zero divisor digit.  */\n-      for (i = 4 - 1; ; i--)\n-\tif (den[i] != 0) {\n-\t  den_hi_sig = i;\n-\t  break;\n-\t}\n+      for (i = 4 - 1;; i--)\n+\tif (den[i] != 0)\n+\t  {\n+\t    den_hi_sig = i;\n+\t    break;\n+\t  }\n \n       /* Insure that the first digit of the divisor is at least BASE/2.\n \t This is required by the quotient digit estimation algorithm.  */\n@@ -733,7 +732,7 @@ div_and_round_double (code, uns,\n       else\n \treturn overflow;\n       break;\n-    \n+\n     case ROUND_DIV_EXPR:\n     case ROUND_MOD_EXPR:\t/* round to closest integer */\n       {\n@@ -821,7 +820,7 @@ target_isinf (x)\n       unsigned mantissa1 : 20;\n       unsigned exponent  : 11;\n       unsigned sign      :  1;\n-    } big_endian;    \n+    } big_endian;\n   } u;\n \n   u.d = dconstm1;\n@@ -861,7 +860,7 @@ target_isnan (x)\n       unsigned mantissa1 : 20;\n       unsigned exponent  : 11;\n       unsigned sign      :  1;\n-    } big_endian;    \n+    } big_endian;\n   } u;\n \n   u.d = dconstm1;\n@@ -901,7 +900,7 @@ target_negative (x)\n       unsigned mantissa1 : 20;\n       unsigned exponent  : 11;\n       unsigned sign      :  1;\n-    } big_endian;    \n+    } big_endian;\n   } u;\n \n   u.d = dconstm1;\n@@ -1049,228 +1048,228 @@ real_hex_to_f (s, mode)\n    char *s;\n    enum machine_mode mode;\n {\n-   REAL_VALUE_TYPE ip;\n-   char *p = s;\n-   unsigned HOST_WIDE_INT low, high;\n-   int shcount, nrmcount, k;\n-   int sign, expsign, isfloat;\n-   int lost = 0;/* Nonzero low order bits shifted out and discarded.  */\n-   int frexpon = 0;  /* Bits after the decimal point.  */\n-   int expon = 0;  /* Value of exponent.  */\n-   int decpt = 0;  /* How many decimal points.  */\n-   int gotp = 0;  /* How many P's.  */\n-   char c;\n-\n-   isfloat = 0;\n-   expsign = 1;\n-   ip = 0.0;\n-\n-   while (*p == ' ' || *p == '\\t')\n-     ++p;\n-\n-   /* Sign, if any, comes first.  */\n-   sign = 1;\n-   if (*p == '-')\n-     {\n-       sign = -1;\n-       ++p;\n-     }\n-\n-   /* The string is supposed to start with 0x or 0X .  */\n-   if (*p == '0')\n-     {\n-       ++p;\n-       if (*p == 'x' || *p == 'X')\n-\t ++p;\n-       else\n-\t abort ();\n-     }\n-   else\n-     abort ();\n-\n-   while (*p == '0')\n-     ++p;\n-\n-   high = 0;\n-   low = 0;\n-   shcount = 0;\n-   while ((c = *p) != '\\0')\n-     {\n-       if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F')\n-\t   || (c >= 'a' && c <= 'f'))\n-\t {\n-\t   k = c & CHARMASK;\n-\t   if (k >= 'a' && k <= 'f')\n-\t     k = k - 'a' + 10;\n-\t   else if (k >= 'A')\n-\t     k = k - 'A' + 10;\n-\t   else\n-\t     k = k - '0';\n-\n-\t   if ((high & 0xf0000000) == 0)\n-\t     {\n-\t       high = (high << 4) + ((low >> 28) & 15);\n-\t       low = (low << 4) + k;\n-\t       shcount += 4;\n-\t       if (decpt)\n-\t\t frexpon += 4;\n-\t     }\n-\t   else\n-\t     {\n-\t       /* Record nonzero lost bits.  */\n-\t       lost |= k;\n-\t       if (! decpt)\n-\t\t frexpon -= 4;\n-\t     }\n-\t   ++p;\n-\t }\n-       else if ( c == '.')\n-\t {\n-\t   ++decpt;\n-\t   ++p;\n-\t }\n-\n-       else if (c == 'p' || c == 'P')\n-\t {\n-\t   ++gotp;\n-\t   ++p;\n-\t   /* Sign of exponent.  */\n-\t   if (*p == '-')\n-\t     {\n-\t       expsign = -1;\n-\t       ++p;\n-\t     }\n-\n-\t   /* Value of exponent.\n-\t      The exponent field is a decimal integer.  */\n-\t   while (ISDIGIT(*p))\n-\t     {\n-\t       k = (*p++ & CHARMASK) - '0';\n-\t       expon = 10 * expon + k;\n-\t     }\n-\n-\t   expon *= expsign;\n-\t   /* F suffix is ambiguous in the significand part\n-\t      so it must appear after the decimal exponent field.  */\n-\t   if (*p == 'f' || *p == 'F')\n-\t     {\n-\t       isfloat = 1;\n-\t       ++p;\n-\t       break;\n-\t     }\n-\t }\n-\n-       else if (c == 'l' || c == 'L')\n-\t {\n-\t   ++p;\n-\t   break;\n-\t }\n-       else\n-\t break;\n-     }\n-\n-   /* Abort if last character read was not legitimate.  */\n-   c = *p;\n-   if ((c != '\\0' && c != ' ' && c != '\\n' && c != '\\r') || (decpt > 1))\n-     abort ();\n-\n-   /* There must be either one decimal point or one p.  */\n-   if (decpt == 0 && gotp == 0)\n-     abort ();\n-\n-   shcount -= 4;\n-   if (high == 0 && low == 0)\n-     return dconst0;\n-\n-   /* Normalize.  */\n-   nrmcount = 0;\n-   if (high == 0)\n-     {\n-       high = low;\n-       low = 0;\n-       nrmcount += 32;\n-     }\n-\n-   /* Leave a high guard bit for carry-out.  */\n-   if ((high & 0x80000000) != 0)\n-     {\n-       lost |= low & 1;\n-       low = (low >> 1) | (high << 31);\n-       high = high >> 1;\n-       nrmcount -= 1;\n-     }\n-\n-   if ((high & 0xffff8000) == 0)\n-     {\n-       high = (high << 16) + ((low >> 16) & 0xffff);\n-       low = low << 16;\n-       nrmcount += 16;\n-     }\n-\n-   while ((high & 0xc0000000) == 0)\n-     {\n-       high = (high << 1) + ((low >> 31) & 1);\n-       low = low << 1;\n-       nrmcount += 1;\n-     }\n-\n-   if (isfloat || GET_MODE_SIZE(mode) == UNITS_PER_WORD)\n-     {\n-       /* Keep 24 bits precision, bits 0x7fffff80.\n-\t  Rounding bit is 0x40.  */\n-       lost = lost | low | (high & 0x3f);\n-       low = 0;\n-       if (high & 0x40)\n-\t {\n-\t   if ((high & 0x80) || lost)\n-\t     high += 0x40;\n-\t }\n-       high &= 0xffffff80;\n-     }\n-   else\n-     {\n-       /* We need real.c to do long double formats, so here default\n-\t  to double precision.  */\n+  REAL_VALUE_TYPE ip;\n+  char *p = s;\n+  unsigned HOST_WIDE_INT low, high;\n+  int shcount, nrmcount, k;\n+  int sign, expsign, isfloat;\n+  int lost = 0;/* Nonzero low order bits shifted out and discarded.  */\n+  int frexpon = 0;  /* Bits after the decimal point.  */\n+  int expon = 0;  /* Value of exponent.  */\n+  int decpt = 0;  /* How many decimal points.  */\n+  int gotp = 0;  /* How many P's.  */\n+  char c;\n+\n+  isfloat = 0;\n+  expsign = 1;\n+  ip = 0.0;\n+\n+  while (*p == ' ' || *p == '\\t')\n+    ++p;\n+\n+  /* Sign, if any, comes first.  */\n+  sign = 1;\n+  if (*p == '-')\n+    {\n+      sign = -1;\n+      ++p;\n+    }\n+\n+  /* The string is supposed to start with 0x or 0X .  */\n+  if (*p == '0')\n+    {\n+      ++p;\n+      if (*p == 'x' || *p == 'X')\n+\t++p;\n+      else\n+\tabort ();\n+    }\n+  else\n+    abort ();\n+\n+  while (*p == '0')\n+    ++p;\n+\n+  high = 0;\n+  low = 0;\n+  shcount = 0;\n+  while ((c = *p) != '\\0')\n+    {\n+      if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F')\n+\t  || (c >= 'a' && c <= 'f'))\n+\t{\n+\t  k = c & CHARMASK;\n+\t  if (k >= 'a' && k <= 'f')\n+\t    k = k - 'a' + 10;\n+\t  else if (k >= 'A')\n+\t    k = k - 'A' + 10;\n+\t  else\n+\t    k = k - '0';\n+\n+\t  if ((high & 0xf0000000) == 0)\n+\t    {\n+\t      high = (high << 4) + ((low >> 28) & 15);\n+\t      low = (low << 4) + k;\n+\t      shcount += 4;\n+\t      if (decpt)\n+\t\tfrexpon += 4;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Record nonzero lost bits.  */\n+\t      lost |= k;\n+\t      if (! decpt)\n+\t\tfrexpon -= 4;\n+\t    }\n+\t  ++p;\n+\t}\n+      else if (c == '.')\n+\t{\n+\t  ++decpt;\n+\t  ++p;\n+\t}\n+\n+      else if (c == 'p' || c == 'P')\n+\t{\n+\t  ++gotp;\n+\t  ++p;\n+\t  /* Sign of exponent.  */\n+\t  if (*p == '-')\n+\t    {\n+\t      expsign = -1;\n+\t      ++p;\n+\t    }\n+\n+\t  /* Value of exponent.\n+\t     The exponent field is a decimal integer.  */\n+\t  while (ISDIGIT (*p))\n+\t    {\n+\t      k = (*p++ & CHARMASK) - '0';\n+\t      expon = 10 * expon + k;\n+\t    }\n+\n+\t  expon *= expsign;\n+\t  /* F suffix is ambiguous in the significand part\n+\t     so it must appear after the decimal exponent field.  */\n+\t  if (*p == 'f' || *p == 'F')\n+\t    {\n+\t      isfloat = 1;\n+\t      ++p;\n+\t      break;\n+\t    }\n+\t}\n+\n+      else if (c == 'l' || c == 'L')\n+\t{\n+\t  ++p;\n+\t  break;\n+\t}\n+      else\n+\tbreak;\n+    }\n+\n+  /* Abort if last character read was not legitimate.  */\n+  c = *p;\n+  if ((c != '\\0' && c != ' ' && c != '\\n' && c != '\\r') || (decpt > 1))\n+    abort ();\n+\n+  /* There must be either one decimal point or one p.  */\n+  if (decpt == 0 && gotp == 0)\n+    abort ();\n+\n+  shcount -= 4;\n+  if (high == 0 && low == 0)\n+    return dconst0;\n+\n+  /* Normalize.  */\n+  nrmcount = 0;\n+  if (high == 0)\n+    {\n+      high = low;\n+      low = 0;\n+      nrmcount += 32;\n+    }\n+\n+  /* Leave a high guard bit for carry-out.  */\n+  if ((high & 0x80000000) != 0)\n+    {\n+      lost |= low & 1;\n+      low = (low >> 1) | (high << 31);\n+      high = high >> 1;\n+      nrmcount -= 1;\n+    }\n+\n+  if ((high & 0xffff8000) == 0)\n+    {\n+      high = (high << 16) + ((low >> 16) & 0xffff);\n+      low = low << 16;\n+      nrmcount += 16;\n+    }\n+\n+  while ((high & 0xc0000000) == 0)\n+    {\n+      high = (high << 1) + ((low >> 31) & 1);\n+      low = low << 1;\n+      nrmcount += 1;\n+    }\n+\n+  if (isfloat || GET_MODE_SIZE (mode) == UNITS_PER_WORD)\n+    {\n+      /* Keep 24 bits precision, bits 0x7fffff80.\n+\t Rounding bit is 0x40.  */\n+      lost = lost | low | (high & 0x3f);\n+      low = 0;\n+      if (high & 0x40)\n+\t{\n+\t  if ((high & 0x80) || lost)\n+\t    high += 0x40;\n+\t}\n+      high &= 0xffffff80;\n+    }\n+  else\n+    {\n+      /* We need real.c to do long double formats, so here default\n+\t to double precision.  */\n #if HOST_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\n-       /* IEEE double.\n-\t  Keep 53 bits precision, bits 0x7fffffff fffffc00.\n-\t  Rounding bit is low word 0x200.  */\n-       lost = lost | (low & 0x1ff);\n-       if (low & 0x200)\n-\t {\n-\t   if ((low & 0x400) || lost)\n-\t     {\n-\t       low = (low + 0x200) & 0xfffffc00;\n-\t       if (low == 0)\n-\t\t high += 1;\n-\t     }\n-\t }\n-       low &= 0xfffffc00;\n+      /* IEEE double.\n+\t Keep 53 bits precision, bits 0x7fffffff fffffc00.\n+\t Rounding bit is low word 0x200.  */\n+      lost = lost | (low & 0x1ff);\n+      if (low & 0x200)\n+\t{\n+\t  if ((low & 0x400) || lost)\n+\t    {\n+\t      low = (low + 0x200) & 0xfffffc00;\n+\t      if (low == 0)\n+\t\thigh += 1;\n+\t    }\n+\t}\n+      low &= 0xfffffc00;\n #else\n-       /* Assume it's a VAX with 56-bit significand,\n-          bits 0x7fffffff ffffff80.  */\n-       lost = lost | (low & 0x7f);\n-       if (low & 0x40)\n-\t {\n-\t   if ((low & 0x80) || lost)\n-\t     {\n-\t       low = (low + 0x40) & 0xffffff80;\n-\t       if (low == 0)\n-\t\t high += 1;\n-\t     }\n-\t }\n-       low &= 0xffffff80;\n+      /* Assume it's a VAX with 56-bit significand,\n+\t bits 0x7fffffff ffffff80.  */\n+      lost = lost | (low & 0x7f);\n+      if (low & 0x40)\n+\t{\n+\t  if ((low & 0x80) || lost)\n+\t    {\n+\t      low = (low + 0x40) & 0xffffff80;\n+\t      if (low == 0)\n+\t\thigh += 1;\n+\t    }\n+\t}\n+      low &= 0xffffff80;\n #endif\n-     }\n+    }\n \n-   ip = (double) high;\n-   ip =  REAL_VALUE_LDEXP (ip, 32) + (double) low;\n-   /* Apply shifts and exponent value as power of 2.  */\n-   ip = REAL_VALUE_LDEXP (ip, expon - (nrmcount + frexpon));\n+  ip = (double) high;\n+  ip = REAL_VALUE_LDEXP (ip, 32) + (double) low;\n+  /* Apply shifts and exponent value as power of 2.  */\n+  ip = REAL_VALUE_LDEXP (ip, expon - (nrmcount + frexpon));\n \n-   if (sign < 0)\n-     ip = -ip;\n-   return ip;\n+  if (sign < 0)\n+    ip = -ip;\n+  return ip;\n }\n \n #endif /* no REAL_ARITHMETIC */\n@@ -1495,7 +1494,7 @@ int_const_binop (code, arg1, arg2, notrunc, forsize)\n       break;\n \n     case RSHIFT_EXPR:\n-      int2l = - int2l;\n+      int2l = -int2l;\n     case LSHIFT_EXPR:\n       /* It's unclear from the C standard whether shifts can overflow.\n \t The following code ignores overflow; perhaps a C standard\n@@ -1544,7 +1543,7 @@ int_const_binop (code, arg1, arg2, notrunc, forsize)\n \n       /* ... fall through ... */\n \n-    case ROUND_DIV_EXPR: \n+    case ROUND_DIV_EXPR:\n       if (int2h == 0 && int2l == 1)\n \t{\n \t  low = int1l, hi = int1h;\n@@ -1577,7 +1576,7 @@ int_const_binop (code, arg1, arg2, notrunc, forsize)\n \n       /* ... fall through ... */\n \n-    case ROUND_MOD_EXPR: \n+    case ROUND_MOD_EXPR:\n       overflow = div_and_round_double (code, uns,\n \t\t\t\t       int1l, int1h, int2l, int2h,\n \t\t\t\t       &garbagel, &garbageh, &low, &hi);\n@@ -1636,18 +1635,18 @@ int_const_binop (code, arg1, arg2, notrunc, forsize)\n /* Define input and output argument for const_binop_1.  */\n struct cb_args\n {\n-  enum tree_code code;\t\t/* Input: tree code for operation*/\n-  tree type;\t\t\t/* Input: tree type for operation. */\n-  REAL_VALUE_TYPE d1, d2;\t/* Input: floating point operands. */\n-  tree t;\t\t\t/* Output: constant for result. */\n+  enum tree_code code;\t\t/* Input: tree code for operation.  */\n+  tree type;\t\t\t/* Input: tree type for operation.  */\n+  REAL_VALUE_TYPE d1, d2;\t/* Input: floating point operands.  */\n+  tree t;\t\t\t/* Output: constant for result.  */\n };\n \n /* Do the real arithmetic for const_binop while protected by a\n    float overflow handler.  */\n \n static void\n const_binop_1 (data)\n-  PTR data;\n+     PTR data;\n {\n   struct cb_args *args = (struct cb_args *) data;\n   REAL_VALUE_TYPE value;\n@@ -1660,32 +1659,32 @@ const_binop_1 (data)\n     case PLUS_EXPR:\n       value = args->d1 + args->d2;\n       break;\n-      \n+\n     case MINUS_EXPR:\n       value = args->d1 - args->d2;\n       break;\n-      \n+\n     case MULT_EXPR:\n       value = args->d1 * args->d2;\n       break;\n-      \n+\n     case RDIV_EXPR:\n #ifndef REAL_INFINITY\n       if (args->d2 == 0)\n \tabort ();\n #endif\n-      \n+\n       value = args->d1 / args->d2;\n       break;\n-      \n+\n     case MIN_EXPR:\n       value = MIN (args->d1, args->d2);\n       break;\n-      \n+\n     case MAX_EXPR:\n       value = MAX (args->d1, args->d2);\n       break;\n-      \n+\n     default:\n       abort ();\n     }\n@@ -1708,7 +1707,8 @@ const_binop (code, arg1, arg2, notrunc)\n      register tree arg1, arg2;\n      int notrunc;\n {\n-  STRIP_NOPS (arg1); STRIP_NOPS (arg2);\n+  STRIP_NOPS (arg1);\n+  STRIP_NOPS (arg2);\n \n   if (TREE_CODE (arg1) == INTEGER_CST)\n     return int_const_binop (code, arg1, arg2, notrunc, 0);\n@@ -1737,7 +1737,7 @@ const_binop (code, arg1, arg2, notrunc)\n       args.d1 = d1;\n       args.d2 = d2;\n       args.code = code;\n-      \n+\n       if (do_float_handler (const_binop_1, (PTR) &args))\n \t/* Receive output from const_binop_1. */\n \tt = args.t;\n@@ -1859,7 +1859,7 @@ size_int_type_wide (number, type)\n   static tree size_table[2048 + 1];\n   static int init_p = 0;\n   tree t;\n-  \n+\n   if (ggc_p && ! init_p)\n     {\n       ggc_add_tree_root ((tree *) size_table,\n@@ -1994,9 +1994,9 @@ struct fc_args\n \n static void\n fold_convert_1 (data)\n-  PTR data;\n+     PTR data;\n {\n-  struct fc_args * args = (struct fc_args *) data;\n+  struct fc_args *args = (struct fc_args *) data;\n \n   args->t = build_real (args->type,\n \t\t\treal_value_truncate (TYPE_MODE (args->type),\n@@ -2135,7 +2135,7 @@ fold_convert (t, arg1)\n       if (TREE_CODE (arg1) == REAL_CST)\n \t{\n \t  struct fc_args args;\n-\t  \n+\n \t  if (REAL_VALUE_ISNAN (TREE_REAL_CST (arg1)))\n \t    {\n \t      t = arg1;\n@@ -2146,7 +2146,7 @@ fold_convert (t, arg1)\n \t  /* Setup input for fold_convert_1() */\n \t  args.arg1 = arg1;\n \t  args.type = type;\n-\t  \n+\n \t  if (do_float_handler (fold_convert_1, (PTR) &args))\n \t    {\n \t      /* Receive output from fold_convert_1() */\n@@ -2419,18 +2419,18 @@ operand_equal_p (arg0, arg1, only_const)\n       if (TREE_CODE (arg0) == RTL_EXPR)\n \treturn rtx_equal_p (RTL_EXPR_RTL (arg0), RTL_EXPR_RTL (arg1));\n       return 0;\n-      \n+\n     default:\n       return 0;\n     }\n }\n \f\n /* Similar to operand_equal_p, but see if ARG0 might have been made by\n-   shorten_compare from ARG1 when ARG1 was being compared with OTHER. \n+   shorten_compare from ARG1 when ARG1 was being compared with OTHER.\n \n    When in doubt, return 0.  */\n \n-static int \n+static int\n operand_equal_for_comparison_p (arg0, arg1, other)\n      tree arg0, arg1;\n      tree other;\n@@ -2450,7 +2450,8 @@ operand_equal_for_comparison_p (arg0, arg1, other)\n      and see if the inner values are the same.  This removes any\n      signedness comparison, which doesn't matter here.  */\n   primarg0 = arg0, primarg1 = arg1;\n-  STRIP_NOPS (primarg0);  STRIP_NOPS (primarg1);\n+  STRIP_NOPS (primarg0);\n+  STRIP_NOPS (primarg1);\n   if (operand_equal_p (primarg0, primarg1, 0))\n     return 1;\n \n@@ -2473,8 +2474,8 @@ operand_equal_for_comparison_p (arg0, arg1, other)\n       /* Make sure shorter operand is extended the right way\n \t to match the longer operand.  */\n       primarg1 = convert (signed_or_unsigned_type (unsignedp1,\n-\t\t\t\t\t\t  TREE_TYPE (primarg1)),\n-\t\t\t primarg1);\n+\t\t\t\t\t\t   TREE_TYPE (primarg1)),\n+\t\t\t  primarg1);\n \n       if (operand_equal_p (arg0, convert (type, primarg1), 0))\n \treturn 1;\n@@ -2544,7 +2545,7 @@ twoval_comparison_p (arg, cval1, cval2, save_p)\n \t\t&& twoval_comparison_p (TREE_OPERAND (arg, 2),\n \t\t\t\t\tcval1, cval2, save_p));\n       return 0;\n-\t  \n+\n     case '<':\n       /* First see if we can handle the first operand, then the second.  For\n \t the second operand, we know *CVAL1 can't be zero.  It must be that\n@@ -2699,8 +2700,6 @@ pedantic_omit_one_operand (type, result, omitted)\n \n   return pedantic_non_lvalue (t);\n }\n-\n-\n \f\n /* Return a simplified tree node for the truth-negation of ARG.  This\n    never alters ARG itself.  We assume that ARG is an operation that\n@@ -3005,7 +3004,7 @@ optimize_bit_field_compare (code, compare_type, lhs, rhs)\n      error case below.  If we didn't, we might generate wrong code.\n \n      For unsigned fields, the constant shifted right by the field length should\n-     be all zero.  For signed fields, the high-order bits should agree with \n+     be all zero.  For signed fields, the high-order bits should agree with\n      the sign bit.  */\n \n   if (lunsignedp)\n@@ -3102,7 +3101,7 @@ decode_field_reference (exp, pbitsize, pbitpos, pmode, punsignedp,\n   unsigned int precision;\n   unsigned int alignment;\n \n-  /* All the optimizations using this function assume integer fields.  \n+  /* All the optimizations using this function assume integer fields.\n      There are problems with FP fields since the type_for_size call\n      below can fail for, e.g., XFmode.  */\n   if (! INTEGRAL_TYPE_P (TREE_TYPE (exp)))\n@@ -3119,14 +3118,13 @@ decode_field_reference (exp, pbitsize, pbitpos, pmode, punsignedp,\n \treturn 0;\n     }\n \n-\n   inner = get_inner_reference (exp, pbitsize, pbitpos, &offset, pmode,\n \t\t\t       punsignedp, pvolatilep, &alignment);\n   if ((inner == exp && and_mask == 0)\n       || *pbitsize < 0 || offset != 0\n       || TREE_CODE (inner) == PLACEHOLDER_EXPR)\n     return 0;\n-  \n+\n   /* Compute the mask to access the bitfield.  */\n   unsigned_type = type_for_size (*pbitsize, 1);\n   precision = TYPE_PRECISION (unsigned_type);\n@@ -3163,7 +3161,7 @@ all_ones_mask_p (mask, size)\n   TREE_TYPE (tmask) = signed_type (type);\n   force_fit_type (tmask, 0);\n   return\n-    tree_int_cst_equal (mask, \n+    tree_int_cst_equal (mask,\n \t\t\tconst_binop (RSHIFT_EXPR,\n \t\t\t\t     const_binop (LSHIFT_EXPR, tmask,\n \t\t\t\t\t\t  size_int (precision - size),\n@@ -3174,7 +3172,7 @@ all_ones_mask_p (mask, size)\n /* Subroutine for fold_truthop: determine if an operand is simple enough\n    to be evaluated unconditionally.  */\n \n-static int \n+static int\n simple_operand_p (exp)\n      tree exp;\n {\n@@ -3296,7 +3294,7 @@ range_binop (code, type, arg0, upper0_p, arg1, upper1_p)\n \n   return convert (type, result ? integer_one_node : integer_zero_node);\n }\n-\f      \n+\f\n /* Given EXP, a logical expression, set the range it is testing into\n    variables denoted by PIN_P, PLOW, and PHIGH.  Return the expression\n    actually being tested.  *PLOW and *PHIGH will be made of the same type\n@@ -3330,13 +3328,13 @@ make_range (exp, pin_p, plow, phigh)\n       if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (code)))\n \t{\n \t  arg0 = TREE_OPERAND (exp, 0);\n-\t  if (TREE_CODE_CLASS (code) == '<' \n+\t  if (TREE_CODE_CLASS (code) == '<'\n \t      || TREE_CODE_CLASS (code) == '1'\n \t      || TREE_CODE_CLASS (code) == '2')\n \t    type = TREE_TYPE (arg0);\n-\t  if (TREE_CODE_CLASS (code) == '2' \n+\t  if (TREE_CODE_CLASS (code) == '2'\n \t      || TREE_CODE_CLASS (code) == '<'\n-\t      || (TREE_CODE_CLASS (code) == 'e' \n+\t      || (TREE_CODE_CLASS (code) == 'e'\n \t\t  && TREE_CODE_LENGTH (code) > 1))\n \t    arg1 = TREE_OPERAND (exp, 1);\n \t}\n@@ -3511,7 +3509,7 @@ make_range (exp, pin_p, plow, phigh)\n \t      high_positive = fold (build (RSHIFT_EXPR, type,\n \t\t\t\t\t   convert (type, high_positive),\n \t\t\t\t\t   convert (type, integer_one_node)));\n-\t\t\t\n+\n \t      /* If the low bound is specified, \"and\" the range with the\n \t\t range for which the original unsigned value will be\n \t\t positive.  */\n@@ -3614,7 +3612,7 @@ build_range_check (type, exp, in_p, low, high)\n     return 0;\n }\n \f\n-/* Given two ranges, see if we can merge them into one.  Return 1 if we \n+/* Given two ranges, see if we can merge them into one.  Return 1 if we\n    can, 0 if we can't.  Set the output range into the specified parameters.  */\n \n static int\n@@ -3639,7 +3637,7 @@ merge_ranges (pin_p, plow, phigh, in0_p, low0, high0, in1_p, low1, high1)\n \n   /* Make range 0 be the range that starts first, or ends last if they\n      start at the same value.  Swap them if it isn't.  */\n-  if (integer_onep (range_binop (GT_EXPR, integer_type_node, \n+  if (integer_onep (range_binop (GT_EXPR, integer_type_node,\n \t\t\t\t low0, 0, low1, 0))\n       || (lowequal\n \t  && integer_onep (range_binop (GT_EXPR, integer_type_node,\n@@ -3691,7 +3689,7 @@ merge_ranges (pin_p, plow, phigh, in0_p, low0, high0, in1_p, low1, high1)\n \t{\n \t  in_p = 1, high = high0;\n \t  low = range_binop (PLUS_EXPR, NULL_TREE, high1, 0,\n-\t\t\t     integer_one_node, 0);\t  \n+\t\t\t     integer_one_node, 0);\n \t}\n       else if (! subset || highequal)\n \t{\n@@ -3847,7 +3845,7 @@ unextend (c, p, unsignedp, mask)\n \n   /* We must use a signed type in order to get an arithmetic right shift.\n      However, we must also avoid introducing accidental overflows, so that\n-     a subsequent call to integer_zerop will work.  Hence we must \n+     a subsequent call to integer_zerop will work.  Hence we must\n      do the type conversion here.  At this point, the constant is either\n      zero or one, and the conversion to a signed type can never overflow.\n      We could get an overflow if this conversion is done anywhere else.  */\n@@ -3896,7 +3894,7 @@ fold_truthop (code, truth_type, lhs, rhs)\n {\n   /* If this is the \"or\" of two comparisons, we can do something if\n      the comparisons are NE_EXPR.  If this is the \"and\", we can do something\n-     if the comparisons are EQ_EXPR.  I.e., \n+     if the comparisons are EQ_EXPR.  I.e.,\n      \t(a->b == 2 && a->c == 4) can become (a->new == NEW).\n \n      WANTED_CODE is this operation code.  For single bit fields, we can\n@@ -3947,7 +3945,7 @@ fold_truthop (code, truth_type, lhs, rhs)\n   lr_arg = TREE_OPERAND (lhs, 1);\n   rl_arg = TREE_OPERAND (rhs, 0);\n   rr_arg = TREE_OPERAND (rhs, 1);\n-  \n+\n   /* If the RHS can be evaluated unconditionally and its operands are\n      simple, it wins to evaluate the RHS unconditionally on machines\n      with expensive branches.  In this case, this isn't a comparison\n@@ -4063,15 +4061,15 @@ fold_truthop (code, truth_type, lhs, rhs)\n   if (l_const)\n     {\n       l_const = convert (lntype, l_const);\n-      l_const = unextend (l_const,  ll_bitsize, ll_unsignedp, ll_and_mask);\n+      l_const = unextend (l_const, ll_bitsize, ll_unsignedp, ll_and_mask);\n       l_const = const_binop (LSHIFT_EXPR, l_const, size_int (xll_bitpos), 0);\n       if (! integer_zerop (const_binop (BIT_AND_EXPR, l_const,\n \t\t\t\t\tfold (build1 (BIT_NOT_EXPR,\n \t\t\t\t\t\t      lntype, ll_mask)),\n \t\t\t\t\t0)))\n \t{\n \t  warning (\"comparison is always %d\", wanted_code == NE_EXPR);\n-\t  \n+\n \t  return convert (truth_type,\n \t\t\t  wanted_code == NE_EXPR\n \t\t\t  ? integer_one_node : integer_zero_node);\n@@ -4158,7 +4156,7 @@ fold_truthop (code, truth_type, lhs, rhs)\n \t field containing them both.\n \n \t Note that we still must mask the lhs/rhs expressions.  Furthermore,\n-\t the mask must be shifted to account for the shift done by \n+\t the mask must be shifted to account for the shift done by\n \t make_bit_field_ref.  */\n       if ((ll_bitsize + ll_bitpos == rl_bitpos\n \t   && lr_bitsize + lr_bitpos == rr_bitpos)\n@@ -4243,7 +4241,7 @@ fold_truthop (code, truth_type, lhs, rhs)\n \t\tconst_binop (BIT_IOR_EXPR, l_const, r_const, 0));\n }\n \f\n-/* Optimize T, which is a comparison of a MIN_EXPR or MAX_EXPR with a \n+/* Optimize T, which is a comparison of a MIN_EXPR or MAX_EXPR with a\n    constant.  */\n \n static tree\n@@ -4367,7 +4365,7 @@ extract_muldiv (t, c, code, wide_type)\n {\n   tree type = TREE_TYPE (t);\n   enum tree_code tcode = TREE_CODE (t);\n-  tree ctype = (wide_type != 0 && (GET_MODE_SIZE (TYPE_MODE (wide_type)) \n+  tree ctype = (wide_type != 0 && (GET_MODE_SIZE (TYPE_MODE (wide_type))\n \t\t\t\t   > GET_MODE_SIZE (TYPE_MODE (type)))\n \t\t? wide_type : type);\n   tree t1, t2;\n@@ -4587,7 +4585,7 @@ extract_muldiv (t, c, code, wide_type)\n       /* If these operations \"cancel\" each other, we have the main\n \t optimizations of this pass, which occur when either constant is a\n \t multiple of the other, in which case we replace this with either an\n-\t operation or CODE or TCODE. \n+\t operation or CODE or TCODE.\n \n \t If we have an unsigned type that is not a sizetype, we canot do\n \t this since it will change the result if the original computation\n@@ -4667,8 +4665,8 @@ constant_boolean_node (value, type)\n     return value ? integer_one_node : integer_zero_node;\n   else if (TREE_CODE (type) == BOOLEAN_TYPE)\n     return truthvalue_conversion (value ? integer_one_node :\n-\t\t\t\t  integer_zero_node); \n-  else \n+\t\t\t\t  integer_zero_node);\n+  else\n     {\n       tree t = build_int_2 (value, 0);\n \n@@ -4707,7 +4705,7 @@ count_cond (expr, lim)\n    but we can constant-fold them if they have constant operands.  */\n \n tree\n-fold (expr) \n+fold (expr)\n      tree expr;\n {\n   register tree t = expr;\n@@ -4722,7 +4720,7 @@ fold (expr)\n      if all operands are constant.  */\n   int wins = 1;\n \n-  /* Don't try to process an RTL_EXPR since its operands aren't trees. \n+  /* Don't try to process an RTL_EXPR since its operands aren't trees.\n      Likewise for a SAVE_EXPR that's already been evaluated.  */\n   if (code == RTL_EXPR || (code == SAVE_EXPR && SAVE_EXPR_RTL (t)) != 0)\n     return t;\n@@ -4734,7 +4732,7 @@ fold (expr)\n \treturn DECL_INITIAL (t);\n       return t;\n     }\n-  \n+\n #ifdef MAX_INTEGER_COMPUTATION_MODE\n   check_max_integer_computation_mode (expr);\n #endif\n@@ -4787,7 +4785,7 @@ fold (expr)\n \t  else\n \t    /* Strip any conversions that don't change the mode.  */\n \t    STRIP_NOPS (op);\n-\t  \n+\n \t  if (TREE_CODE (op) == COMPLEX_CST)\n \t    subop = TREE_REALPART (op);\n \t  else\n@@ -4838,7 +4836,7 @@ fold (expr)\n      one of the operands is a comparison and the other is a comparison, a\n      BIT_AND_EXPR with the constant 1, or a truth value.  In that case, the\n      code below would make the expression more complex.  Change it to a\n-     TRUTH_{AND,OR}_EXPR.  Likewise, convert a similar NE_EXPR to \n+     TRUTH_{AND,OR}_EXPR.  Likewise, convert a similar NE_EXPR to\n      TRUTH_XOR_EXPR and an EQ_EXPR to the inversion of a TRUTH_XOR_EXPR.  */\n \n   if ((code == BIT_AND_EXPR || code == BIT_IOR_EXPR\n@@ -4903,7 +4901,7 @@ fold (expr)\n \t\t\t       TREE_OPERAND (TREE_OPERAND (t, 2), 0)));\n \t  return t;\n \t}\n-      else if (TREE_CODE_CLASS (TREE_CODE (arg0)) == '<') \n+      else if (TREE_CODE_CLASS (TREE_CODE (arg0)) == '<')\n \treturn fold (build (COND_EXPR, type, arg0,\n \t\t\t    fold (build1 (code, type, integer_one_node)),\n \t\t\t    fold (build1 (code, type, integer_zero_node))));\n@@ -5056,7 +5054,7 @@ fold (expr)\n \t   && TREE_CODE (arg1) == COMPOUND_EXPR)\n     return build (COMPOUND_EXPR, type, TREE_OPERAND (arg1, 0),\n \t\t  fold (build (code, type, arg0, TREE_OPERAND (arg1, 1))));\n-\t  \n+\n   switch (code)\n     {\n     case INTEGER_CST:\n@@ -5101,7 +5099,7 @@ fold (expr)\n \t  unsigned int final_prec = TYPE_PRECISION (final_type);\n \t  int final_unsignedp = TREE_UNSIGNED (final_type);\n \n-\t  /* In addition to the cases of two conversions in a row \n+\t  /* In addition to the cases of two conversions in a row\n \t     handled below, if we are converting something to its own\n \t     type via an object of identical or wider precision, neither\n \t     conversion is needed.  */\n@@ -5140,7 +5138,7 @@ fold (expr)\n \t       and the outermost type is wider than the intermediate, or\n \t     - the initial type is a pointer type and the precisions of the\n \t       intermediate and final types differ, or\n-\t     - the final type is a pointer type and the precisions of the \n+\t     - the final type is a pointer type and the precisions of the\n \t       initial and intermediate types differ.  */\n \t  if (! inside_float && ! inter_float && ! final_float\n \t      && (inter_prec > inside_prec || inter_prec > final_prec)\n@@ -5338,12 +5336,12 @@ fold (expr)\n \t    }\n \n \t  /* Reassociate (plus (plus (mult) (foo)) (mult)) as\n-\t     (plus (plus (mult) (mult)) (foo)) so that we can \n+\t     (plus (plus (mult) (mult)) (foo)) so that we can\n \t     take advantage of the factoring cases below.  */\n \t  if ((TREE_CODE (arg0) == PLUS_EXPR\n \t       && TREE_CODE (arg1) == MULT_EXPR)\n \t      || (TREE_CODE (arg1) == PLUS_EXPR\n-\t          && TREE_CODE (arg0) == MULT_EXPR))\n+\t\t  && TREE_CODE (arg0) == MULT_EXPR))\n \t    {\n \t      tree parg0, parg1, parg, marg;\n \n@@ -5424,7 +5422,7 @@ fold (expr)\n \t\t}\n \n \t      if (same)\n-\t        return fold (build (MULT_EXPR, type,\n+\t\treturn fold (build (MULT_EXPR, type,\n \t\t\t\t    fold (build (PLUS_EXPR, type, alt0, alt1)),\n \t\t\t\t    same));\n \t    }\n@@ -5445,13 +5443,13 @@ fold (expr)\n       /* (A << B) + (A >> (Z - B)) if A is unsigned and Z is the size of A\n \t is a rotate of A by B bits.  */\n       {\n-        register enum tree_code code0, code1;\n-        code0 = TREE_CODE (arg0);\n-        code1 = TREE_CODE (arg1);\n-        if (((code0 == RSHIFT_EXPR && code1 == LSHIFT_EXPR)\n-\t    || (code1 == RSHIFT_EXPR && code0 == LSHIFT_EXPR))\n+\tregister enum tree_code code0, code1;\n+\tcode0 = TREE_CODE (arg0);\n+\tcode1 = TREE_CODE (arg1);\n+\tif (((code0 == RSHIFT_EXPR && code1 == LSHIFT_EXPR)\n+\t     || (code1 == RSHIFT_EXPR && code0 == LSHIFT_EXPR))\n \t    && operand_equal_p (TREE_OPERAND (arg0, 0),\n-\t\t\t        TREE_OPERAND (arg1,0), 0)\n+\t\t\t        TREE_OPERAND (arg1, 0), 0)\n \t    && TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (arg0, 0))))\n \t  {\n \t    register tree tree01, tree11;\n@@ -5464,53 +5462,52 @@ fold (expr)\n \t    code01 = TREE_CODE (tree01);\n \t    code11 = TREE_CODE (tree11);\n \t    if (code01 == INTEGER_CST\n-\t      && code11 == INTEGER_CST\n-\t      && TREE_INT_CST_HIGH (tree01) == 0\n-\t      && TREE_INT_CST_HIGH (tree11) == 0\n-\t      && ((TREE_INT_CST_LOW (tree01) + TREE_INT_CST_LOW (tree11))\n-\t        == TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (arg0, 0)))))\n+\t\t&& code11 == INTEGER_CST\n+\t\t&& TREE_INT_CST_HIGH (tree01) == 0\n+\t\t&& TREE_INT_CST_HIGH (tree11) == 0\n+\t\t&& ((TREE_INT_CST_LOW (tree01) + TREE_INT_CST_LOW (tree11))\n+\t\t    == TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (arg0, 0)))))\n \t      return build (LROTATE_EXPR, type, TREE_OPERAND (arg0, 0),\n-\t\t        code0 == LSHIFT_EXPR ? tree01 : tree11);\n+\t\t\t    code0 == LSHIFT_EXPR ? tree01 : tree11);\n \t    else if (code11 == MINUS_EXPR)\n \t      {\n-\t        tree tree110, tree111;\n-\t        tree110 = TREE_OPERAND (tree11, 0);\n-\t        tree111 = TREE_OPERAND (tree11, 1);\n-\t        STRIP_NOPS (tree110);\n-\t        STRIP_NOPS (tree111);\n-\t        if (TREE_CODE (tree110) == INTEGER_CST\n+\t\ttree tree110, tree111;\n+\t\ttree110 = TREE_OPERAND (tree11, 0);\n+\t\ttree111 = TREE_OPERAND (tree11, 1);\n+\t\tSTRIP_NOPS (tree110);\n+\t\tSTRIP_NOPS (tree111);\n+\t\tif (TREE_CODE (tree110) == INTEGER_CST\n \t\t    && 0 == compare_tree_int (tree110,\n \t\t\t\t\t      TYPE_PRECISION\n \t\t\t\t\t      (TREE_TYPE (TREE_OPERAND\n \t\t\t\t\t\t\t  (arg0, 0))))\n \t\t    && operand_equal_p (tree01, tree111, 0))\n-\t\t  return build ((code0 == LSHIFT_EXPR \n-\t\t\t         ? LROTATE_EXPR \n-\t\t\t         : RROTATE_EXPR),\n-\t\t\t        type, TREE_OPERAND (arg0, 0), tree01);\n+\t\t  return build ((code0 == LSHIFT_EXPR\n+\t\t\t\t ? LROTATE_EXPR\n+\t\t\t\t : RROTATE_EXPR),\n+\t\t\t\ttype, TREE_OPERAND (arg0, 0), tree01);\n \t      }\n \t    else if (code01 == MINUS_EXPR)\n \t      {\n-\t        tree tree010, tree011;\n-\t        tree010 = TREE_OPERAND (tree01, 0);\n-\t        tree011 = TREE_OPERAND (tree01, 1);\n-\t        STRIP_NOPS (tree010);\n-\t        STRIP_NOPS (tree011);\n-\t        if (TREE_CODE (tree010) == INTEGER_CST\n+\t\ttree tree010, tree011;\n+\t\ttree010 = TREE_OPERAND (tree01, 0);\n+\t\ttree011 = TREE_OPERAND (tree01, 1);\n+\t\tSTRIP_NOPS (tree010);\n+\t\tSTRIP_NOPS (tree011);\n+\t\tif (TREE_CODE (tree010) == INTEGER_CST\n \t\t    && 0 == compare_tree_int (tree010,\n \t\t\t\t\t      TYPE_PRECISION\n \t\t\t\t\t      (TREE_TYPE (TREE_OPERAND\n \t\t\t\t\t\t\t  (arg0, 0))))\n \t\t    && operand_equal_p (tree11, tree011, 0))\n-\t\t  return build ((code0 != LSHIFT_EXPR \n-\t\t\t         ? LROTATE_EXPR \n-\t\t\t         : RROTATE_EXPR),\n-\t\t\t         type, TREE_OPERAND (arg0, 0), tree11);\n+\t\t  return build ((code0 != LSHIFT_EXPR\n+\t\t\t\t ? LROTATE_EXPR\n+\t\t\t\t : RROTATE_EXPR),\n+\t\t\t\ttype, TREE_OPERAND (arg0, 0), tree11);\n \t      }\n \t  }\n       }\n \n-\n     associate:\n       /* In most languages, can't associate operations on floats through\n \t parentheses.  Rather than remember where the parentheses were, we\n@@ -5570,7 +5567,7 @@ fold (expr)\n       /* (-A) - CST -> (-CST) - A   for floating point (what about ints ?)  */\n       if (TREE_CODE (arg0) == NEGATE_EXPR && TREE_CODE (arg1) == REAL_CST)\n \treturn\n-\t  fold (build (MINUS_EXPR, type, \n+\t  fold (build (MINUS_EXPR, type,\n \t\t       build_real (TREE_TYPE (arg1),\n \t\t\t\t   REAL_VALUE_NEGATE (TREE_REAL_CST (arg1))),\n \t\t       TREE_OPERAND (arg0, 0)));\n@@ -5607,7 +5604,7 @@ fold (expr)\n \t    return non_lvalue (convert (type, arg0));\n \t}\n \n-      /* Fold &x - &x.  This can happen from &x.foo - &x. \n+      /* Fold &x - &x.  This can happen from &x.foo - &x.\n \t This is unsafe for certain floats even in non-IEEE formats.\n \t In IEEE, it is unsafe because it does wrong for NaNs.\n \t Also note that operand_equal_p is always false if an operand\n@@ -5623,7 +5620,7 @@ fold (expr)\n       /* (-A) * (-B) -> A * B  */\n       if (TREE_CODE (arg0) == NEGATE_EXPR && TREE_CODE (arg1) == NEGATE_EXPR)\n \treturn fold (build (MULT_EXPR, type, TREE_OPERAND (arg0, 0),\n-\t\t            TREE_OPERAND (arg1, 0)));\n+\t\t\t    TREE_OPERAND (arg1, 0)));\n \n       if (! FLOAT_TYPE_P (type))\n \t{\n@@ -5682,7 +5679,7 @@ fold (expr)\n \n       /* Convert (or (not arg0) (not arg1)) to (not (and (arg0) (arg1))).\n \n-\t This results in more efficient code for machines without a NAND \n+\t This results in more efficient code for machines without a NAND\n \t instruction.  Combine will canonicalize to the first form\n \t which will allow use of NAND instructions provided by the\n \t backend if they exist.  */\n@@ -5716,10 +5713,10 @@ fold (expr)\n \t  && integer_zerop (const_binop (BIT_AND_EXPR,\n \t\t\t\t\t TREE_OPERAND (arg0, 1),\n \t\t\t\t\t TREE_OPERAND (arg1, 1), 0)))\n-        {\n-           code = BIT_IOR_EXPR;\n-\t   goto bit_ior;\n-        }\n+\t{\n+\t  code = BIT_IOR_EXPR;\n+\t  goto bit_ior;\n+\t}\n \n       /* See if this can be simplified into a rotate first.  If that\n \t is unsuccessful continue in the association code.  */\n@@ -5760,7 +5757,7 @@ fold (expr)\n \n       /* Convert (and (not arg0) (not arg1)) to (not (or (arg0) (arg1))).\n \n-\t This results in more efficient code for machines without a NOR \n+\t This results in more efficient code for machines without a NOR\n \t instruction.  Combine will canonicalize to the first form\n \t which will allow use of NOR instructions provided by the\n \t backend if they exist.  */\n@@ -5824,10 +5821,10 @@ fold (expr)\n \t      REAL_VALUE_TYPE r;\n \t      r = TREE_REAL_CST (arg1);\n \t      if (exact_real_inverse (TYPE_MODE(TREE_TYPE(arg0)), &r))\n-\t\t  {\n-\t\t    tem = build_real (type, r);\n-\t\t    return fold (build (MULT_EXPR, type, arg0, tem));\n-\t\t  }\n+\t\t{\n+\t\t  tem = build_real (type, r);\n+\t\t  return fold (build (MULT_EXPR, type, arg0, tem));\n+\t\t}\n \t    }\n \t}\n       goto binary;\n@@ -5852,7 +5849,7 @@ fold (expr)\n \t  && multiple_of_p (type, arg0, arg1))\n \treturn fold (build (EXACT_DIV_EXPR, type, arg0, arg1));\n \n-        if (TREE_CODE (arg1) == INTEGER_CST\n+      if (TREE_CODE (arg1) == INTEGER_CST\n \t  && 0 != (tem = extract_muldiv (TREE_OPERAND (t, 0), arg1,\n \t\t\t\t\t code, NULL_TREE)))\n \treturn convert (type, tem);\n@@ -6097,10 +6094,10 @@ fold (expr)\n \t  if (TREE_CODE (arg0) == NEGATE_EXPR && TREE_CODE (arg1) == REAL_CST)\n \t    return\n \t      fold (build\n-\t\t     (swap_tree_comparison (code), type,\n-\t\t      TREE_OPERAND (arg0, 0),\n-\t\t      build_real (TREE_TYPE (arg1),\n-\t\t\t\t  REAL_VALUE_NEGATE (TREE_REAL_CST (arg1)))));\n+\t\t    (swap_tree_comparison (code), type,\n+\t\t     TREE_OPERAND (arg0, 0),\n+\t\t     build_real (TREE_TYPE (arg1),\n+\t\t\t\t REAL_VALUE_NEGATE (TREE_REAL_CST (arg1)))));\n \t  /* IEEE doesn't distinguish +0 and -0 in comparisons.  */\n \t  /* a CMP (-0) -> a CMP 0  */\n \t  if (TREE_CODE (arg1) == REAL_CST\n@@ -6109,7 +6106,6 @@ fold (expr)\n \t\t\t\tbuild_real (TREE_TYPE (arg1), dconst0)));\n \t}\n \n-\n       /* If one arg is a constant integer, put it last.  */\n       if (TREE_CODE (arg0) == INTEGER_CST\n \t  && TREE_CODE (arg1) != INTEGER_CST)\n@@ -6197,7 +6193,6 @@ fold (expr)\n \t\t\t\t\t    convert (TREE_TYPE (varop),\n \t\t\t\t\t\t     mask)));\n \t\t  }\n-\t\t\t\t\t\t\t \n \n \t\tt = build (code, type,\n \t\t\t   (constopnum == 0) ? newconst : varop,\n@@ -6259,7 +6254,6 @@ fold (expr)\n \t\t\t\t\t    convert (TREE_TYPE (varop),\n \t\t\t\t\t\t     mask)));\n \t\t  }\n-\t\t\t\t\t\t\t \n \n \t\tt = build (code, type,\n \t\t\t   (constopnum == 0) ? newconst : varop,\n@@ -6334,7 +6328,7 @@ fold (expr)\n \t\t   || (TREE_CODE (t1) == INTEGER_CST\n \t\t       && int_fits_type_p (t1, TREE_TYPE (tem)))))\n \treturn fold (build (code, type, tem, convert (TREE_TYPE (tem), t1)));\n-      \n+\n       /* If this is comparing a constant with a MIN_EXPR or a MAX_EXPR of a\n \t constant, we can simplify it.  */\n       else if (TREE_CODE (arg1) == INTEGER_CST\n@@ -6358,7 +6352,7 @@ fold (expr)\n \t\t\t    build (GE_EXPR, type, TREE_OPERAND (arg0, 0), tem),\n \t\t\t    build (LE_EXPR, type,\n \t\t\t\t   TREE_OPERAND (arg0, 0), arg1)));\n-\t  \n+\n       /* If this is an EQ or NE comparison with zero and ARG0 is\n \t (1 << foo) & bar, convert it to (bar >> foo) & 1.  Both require\n \t two operations, but the latter can be done in one less insn\n@@ -6435,7 +6429,7 @@ fold (expr)\n \t  && TREE_UNSIGNED (TREE_TYPE (arg0))\n \t  && TREE_CODE (arg1) == LSHIFT_EXPR\n \t  && integer_onep (TREE_OPERAND (arg1, 0)))\n-\treturn build (code == LT_EXPR ? EQ_EXPR : NE_EXPR, type, \n+\treturn build (code == LT_EXPR ? EQ_EXPR : NE_EXPR, type,\n \t\t      build (RSHIFT_EXPR, TREE_TYPE (arg0), arg0,\n \t\t\t     TREE_OPERAND (arg1, 1)),\n \t\t      convert (TREE_TYPE (arg0), integer_zero_node));\n@@ -6578,7 +6572,7 @@ fold (expr)\n \t\t      && (TREE_INT_CST_LOW (arg1)\n \t\t\t  == ((unsigned HOST_WIDE_INT) 1 << (width - 1)) - 1)\n \t\t      && TREE_UNSIGNED (TREE_TYPE (arg1)))\n-\t      \n+\n \t      switch (TREE_CODE (t))\n \t\t{\n \t\tcase LE_EXPR:\n@@ -6951,7 +6945,7 @@ fold (expr)\n \t\tcase LT_EXPR:\n \t\t  /* In C++ a ?: expression can be an lvalue, so put the\n \t\t     operand which will be used if they are equal first\n-\t\t     so that we can convert this back to the \n+\t\t     so that we can convert this back to the\n \t\t     corresponding COND_EXPR.  */\n \t\t  return pedantic_non_lvalue\n \t\t    (convert (type, fold (build (MIN_EXPR, comp_type,\n@@ -7066,7 +7060,7 @@ fold (expr)\n       if (integer_onep (TREE_OPERAND (t, 1))\n \t  && integer_zerop (TREE_OPERAND (t, 2))\n \t  /* If we try to convert TREE_OPERAND (t, 0) to our type, the\n-\t     call to fold will try to move the conversion inside \n+\t     call to fold will try to move the conversion inside\n \t     a COND, which will recurse.  In that case, the COND_EXPR\n \t     is probably the best choice, so leave it alone.  */\n \t  && type == TREE_TYPE (arg0))\n@@ -7146,7 +7140,7 @@ fold (expr)\n \ttree arg01;\n \n \tif (kind0 == '1' || code0 == TRUTH_NOT_EXPR)\n-\t  return fold (build1 (code0, type, \n+\t  return fold (build1 (code0, type,\n \t\t\t       fold (build1 (CLEANUP_POINT_EXPR,\n \t\t\t\t\t     TREE_TYPE (arg00), arg00))));\n "}]}