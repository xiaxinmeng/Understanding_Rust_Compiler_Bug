{"sha": "5cedffbc3249a3f14ea57567a5f089d502cad8d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWNlZGZmYmMzMjQ5YTNmMTRlYTU3NTY3YTVmMDg5ZDUwMmNhZDhkMw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2018-02-15T16:54:12Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2018-02-15T16:54:12Z"}, "message": "PR c++/84314 - ICE with templates and fastcall attribute.\n\n\t* attribs.c (build_type_attribute_qual_variant): Don't clobber\n\tTYPE_CANONICAL on an existing type.\n\nFrom-SVN: r257695", "tree": {"sha": "1478e723a54aba8f641e33069ff42a56ef1984c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1478e723a54aba8f641e33069ff42a56ef1984c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5cedffbc3249a3f14ea57567a5f089d502cad8d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cedffbc3249a3f14ea57567a5f089d502cad8d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cedffbc3249a3f14ea57567a5f089d502cad8d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cedffbc3249a3f14ea57567a5f089d502cad8d3/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e72f7e3e763c1091c0007a851f252f13310f6255", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e72f7e3e763c1091c0007a851f252f13310f6255", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e72f7e3e763c1091c0007a851f252f13310f6255"}], "stats": {"total": 129, "additions": 122, "deletions": 7}, "files": [{"sha": "4062532e80477f2b9501aa9faa1902083332c212", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cedffbc3249a3f14ea57567a5f089d502cad8d3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cedffbc3249a3f14ea57567a5f089d502cad8d3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5cedffbc3249a3f14ea57567a5f089d502cad8d3", "patch": "@@ -1,3 +1,9 @@\n+2018-02-15  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/84314 - ICE with templates and fastcall attribute.\n+\t* attribs.c (build_type_attribute_qual_variant): Don't clobber\n+\tTYPE_CANONICAL on an existing type.\n+\n 2018-02-15  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/84383"}, {"sha": "caa30b99fc6fe35b5932df3bc16bd718b89e0442", "filename": "gcc/attribs.c", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cedffbc3249a3f14ea57567a5f089d502cad8d3/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cedffbc3249a3f14ea57567a5f089d502cad8d3/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=5cedffbc3249a3f14ea57567a5f089d502cad8d3", "patch": "@@ -1143,19 +1143,29 @@ build_type_attribute_qual_variant (tree otype, tree attribute, int quals)\n \tttype = (lang_hooks.types.copy_lang_qualifiers\n \t\t (ttype, TYPE_MAIN_VARIANT (otype)));\n \n-      ntype = build_distinct_type_copy (ttype);\n+      tree dtype = ntype = build_distinct_type_copy (ttype);\n \n       TYPE_ATTRIBUTES (ntype) = attribute;\n \n       hashval_t hash = type_hash_canon_hash (ntype);\n       ntype = type_hash_canon (hash, ntype);\n \n-      /* If the target-dependent attributes make NTYPE different from\n-\t its canonical type, we will need to use structural equality\n-\t checks for this type.  */\n-      if (TYPE_STRUCTURAL_EQUALITY_P (ttype)\n-\t  || !comp_type_attributes (ntype, ttype))\n-\tSET_TYPE_STRUCTURAL_EQUALITY (ntype);\n+      if (ntype != dtype)\n+\t/* This variant was already in the hash table, don't mess with\n+\t   TYPE_CANONICAL.  */;\n+      else if (TYPE_STRUCTURAL_EQUALITY_P (ttype)\n+\t       || !comp_type_attributes (ntype, ttype))\n+\t{\n+\t  /* If the target-dependent attributes make NTYPE different from\n+\t     its canonical type, we will need to use structural equality\n+\t     checks for this type.\n+\n+\t     But make sure we don't get here for stripping attributes from a\n+\t     type; the no-attribute type might not need structural comparison,\n+\t     and it should have been in the hash table already.  */\n+\t  gcc_assert (attribute);\n+\t  SET_TYPE_STRUCTURAL_EQUALITY (ntype);\n+\t}\n       else if (TYPE_CANONICAL (ntype) == ntype)\n \tTYPE_CANONICAL (ntype) = TYPE_CANONICAL (ttype);\n "}, {"sha": "dc0cdc48b7a245aa41686c8b510f2300011a23d6", "filename": "gcc/testsuite/g++.dg/ext/attrib55.C", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cedffbc3249a3f14ea57567a5f089d502cad8d3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattrib55.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cedffbc3249a3f14ea57567a5f089d502cad8d3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattrib55.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattrib55.C?ref=5cedffbc3249a3f14ea57567a5f089d502cad8d3", "patch": "@@ -0,0 +1,99 @@\n+// PR c++/84314\n+// { dg-do compile { target { { i?86-*-* x86_64-*-* } && ia32 } } }\n+// { dg-additional-options \"-w -std=c++11\" }\n+\n+template <typename a, a b> struct c { static constexpr a d = b; };\n+template <bool b> using e = c<bool, b>;\n+template <bool, typename, typename> struct conditional;\n+template <typename...> struct f;\n+template <typename g, typename h>\n+struct f<g, h> : conditional<g::d, g, h>::i {};\n+template <typename...> struct j;\n+template <typename g, typename h> struct j<g, h> : conditional<1, h, g>::i {};\n+template <typename g, typename h, typename k, typename... l>\n+struct j<g, h, k, l...> : conditional<1, j<h, k>, g>::i {};\n+struct aa : e<!bool()> {};\n+template <typename, typename> struct m : c<bool, false> {};\n+template <typename, typename n> struct o {\n+  template <typename> static c<bool, true> p(int);\n+  typedef decltype(p<n>(0)) i;\n+};\n+template <typename, typename> struct ab : o<int, int>::i {};\n+template <typename> struct s { typedef int ad; };\n+template <bool, typename = void> struct q;\n+template <typename a> struct q<true, a> { typedef a i; };\n+template <bool, typename ae, typename> struct conditional { typedef ae i; };\n+template <typename ae, typename r> struct conditional<false, ae, r> {\n+  typedef r i;\n+};\n+struct B {\n+  B(int);\n+};\n+template <unsigned, typename...> struct af;\n+template <unsigned ag, typename t, typename... ah>\n+struct af<ag, t, ah...> : af<1, ah...>, B {\n+  typedef af<1, ah...> ai;\n+  ai al(af);\n+  template <typename... am> af(af<ag, am...> p1) : ai(al(p1)), B(0) {}\n+};\n+template <unsigned ag, typename t> struct af<ag, t> {};\n+template <int, typename... ao> struct ap {\n+  template <typename... am> static constexpr bool ar() {\n+    return j<ab<am, ao>...>::d;\n+  }\n+};\n+template <typename... ao> class as : public af<0, ao...> {\n+  typedef af<0, ao...> ai;\n+\n+public:\n+  template <typename...> using au = ap<m<int, int>::d, ao...>;\n+  template <typename... am,\n+            typename q<au<>::template ar<am...>(), bool>::i = true>\n+  as(as<am...> an) : ai(an) {}\n+};\n+template <typename... ao> as<typename s<ao>::ad...> ax(ao...);\n+namespace ay {\n+class az {};\n+}\n+using ay::az;\n+namespace ay {\n+template <typename ba> struct C { typedef ba bc; };\n+}\n+template <typename> class bd;\n+template <typename bi, typename n> using bj = f<m<bi, n>, ab<bi, n>>;\n+template <typename bf, typename... bh> class bd<bf(bh...)> {\n+  struct F : bj<int, bf> {};\n+  template <typename bl, typename> using bm = typename q<bl::d>::i;\n+\n+public:\n+  template <typename bg, typename = bm<aa, void>, typename = bm<F, void>>\n+  bd(bg);\n+  using bn = bf;\n+  bn bo;\n+};\n+template <typename bf, typename... bh>\n+template <typename bg, typename, typename>\n+bd<bf(bh...)>::bd(bg) {\n+  bo;\n+}\n+typedef long long(__attribute__((fastcall)) bq)(int *);\n+struct v : ay::C<as<bq, bq, int>> {\n+  bc bt() { return ax(nullptr, nullptr, az()); }\n+};\n+class w {\n+public:\n+  int *cc();\n+};\n+class x : w {\n+  void ce();\n+};\n+namespace u {\n+class cf {\n+public:\n+  static cf cg(int, int *, int, az, bd<long long(int *)>);\n+};\n+}\n+void x::ce() {\n+  auto bu = 0;\n+  u::cf::cg(bu, cc(), 1, {}, 0);\n+}"}]}