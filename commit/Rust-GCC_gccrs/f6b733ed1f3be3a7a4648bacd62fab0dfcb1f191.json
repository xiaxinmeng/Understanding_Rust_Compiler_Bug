{"sha": "f6b733ed1f3be3a7a4648bacd62fab0dfcb1f191", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjZiNzMzZWQxZjNiZTNhN2E0NjQ4YmFjZDYyZmFiMGRmY2IxZjE5MQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2001-11-16T19:59:16Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2001-11-16T19:59:16Z"}, "message": "verify.cc (_Jv_BytecodeVerifier::is_assignable_from_slow): New method.\n\n\t* verify.cc (_Jv_BytecodeVerifier::is_assignable_from_slow): New\n\tmethod.\n\t(type::compatible): Use it.\n\t(type::merge): Likewise.\n\t(type::promote): Return a `type&'.\n\t(get_one_type): Promote return value.\n\nFrom-SVN: r47097", "tree": {"sha": "837ac2ca256a2f2916d0506882f8b2e7e5b170fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/837ac2ca256a2f2916d0506882f8b2e7e5b170fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f6b733ed1f3be3a7a4648bacd62fab0dfcb1f191", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6b733ed1f3be3a7a4648bacd62fab0dfcb1f191", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6b733ed1f3be3a7a4648bacd62fab0dfcb1f191", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6b733ed1f3be3a7a4648bacd62fab0dfcb1f191/comments", "author": null, "committer": null, "parents": [{"sha": "29628f27db3ae12da95fd98e3755be5a06596855", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29628f27db3ae12da95fd98e3755be5a06596855", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29628f27db3ae12da95fd98e3755be5a06596855"}], "stats": {"total": 71, "additions": 63, "deletions": 8}, "files": [{"sha": "2d7835b67103b3047b515534613f2df65f3ef809", "filename": "libjava/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6b733ed1f3be3a7a4648bacd62fab0dfcb1f191/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6b733ed1f3be3a7a4648bacd62fab0dfcb1f191/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=f6b733ed1f3be3a7a4648bacd62fab0dfcb1f191", "patch": "@@ -1,5 +1,12 @@\n 2001-11-16  Tom Tromey  <tromey@redhat.com>\n \n+\t* verify.cc (_Jv_BytecodeVerifier::is_assignable_from_slow): New\n+\tmethod.\n+\t(type::compatible): Use it.\n+\t(type::merge): Likewise.\n+\t(type::promote): Return a `type&'.\n+\t(get_one_type): Promote return value.\n+\n \tRe-merge with Classpath, from Brian Jones:\n \t* java/lang/Integer.java (getInteger): Attempt to decode the value\n \tof the system property instead of the name of the system property."}, {"sha": "5dc90c6ec3d387b49382317e0cabbf4c00341b46", "filename": "libjava/verify.cc", "status": "modified", "additions": 56, "deletions": 8, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6b733ed1f3be3a7a4648bacd62fab0dfcb1f191/libjava%2Fverify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6b733ed1f3be3a7a4648bacd62fab0dfcb1f191/libjava%2Fverify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fverify.cc?ref=f6b733ed1f3be3a7a4648bacd62fab0dfcb1f191", "patch": "@@ -168,6 +168,53 @@ class _Jv_BytecodeVerifier\n     return get_type_val_for_signature ((jchar) k->method_count);\n   }\n \n+  // This is like _Jv_IsAssignableFrom, but it works even if SOURCE or\n+  // TARGET haven't been prepared.\n+  static bool is_assignable_from_slow (jclass target, jclass source)\n+  {\n+    // This will terminate when SOURCE==Object.\n+    while (true)\n+      {\n+\tif (source == target)\n+\t  return true;\n+\n+\tif (target->isPrimitive () || source->isPrimitive ())\n+\t  return false;\n+\n+\t// _Jv_IsAssignableFrom can handle a target which is an\n+\t// interface even if it hasn't been prepared.\n+\tif ((target->state > JV_STATE_LINKED || target->isInterface ())\n+\t    && source->state > JV_STATE_LINKED)\n+\t  return _Jv_IsAssignableFrom (target, source);\n+\n+\tif (target->isArray ())\n+\t  {\n+\t    if (! source->isArray ())\n+\t      return false;\n+\t    target = target->getComponentType ();\n+\t    source = source->getComponentType ();\n+\t  }\n+\telse if (target->isInterface ())\n+\t  {\n+\t    for (int i = 0; i < source->interface_count; ++i)\n+\t      {\n+\t\t// We use a recursive call because we also need to\n+\t\t// check superinterfaces.\n+\t\tif (is_assignable_from_slow (target, source->interfaces[i]))\n+\t\t    return true;\n+\t      }\n+\t    return false;\n+\t  }\n+\telse if (target == &java::lang::Object::class$)\n+\t  return true;\n+\telse if (source->isInterface ()\n+\t\t || source == &java::lang::Object::class$)\n+\t  return false;\n+\telse\n+\t  source = source->getSuperclass ();\n+      }\n+  }\n+\n   // This is used to keep track of which `jsr's correspond to a given\n   // jsr target.\n   struct subr_info\n@@ -274,11 +321,12 @@ class _Jv_BytecodeVerifier\n     }\n \n     // Promote a numeric type.\n-    void promote ()\n+    type &promote ()\n     {\n       if (key == boolean_type || key == char_type\n \t  || key == byte_type || key == short_type)\n \tkey = int_type;\n+      return *this;\n     }\n \n     // If *THIS is an unresolved reference type, resolve it.\n@@ -373,9 +421,7 @@ class _Jv_BytecodeVerifier\n       // We must resolve both types and check assignability.\n       resolve ();\n       k.resolve ();\n-      // Use _Jv_IsAssignableFrom to avoid premature class\n-      // initialization.\n-      return _Jv_IsAssignableFrom (data.klass, k.data.klass);\n+      return is_assignable_from_slow (data.klass, k.data.klass);\n     }\n \n     bool isvoid () const\n@@ -539,9 +585,7 @@ class _Jv_BytecodeVerifier\n \t\t  // This loop will end when we hit Object.\n \t\t  while (true)\n \t\t    {\n-\t\t      // Use _Jv_IsAssignableFrom to avoid premature\n-\t\t      // class initialization.\n-\t\t      if (_Jv_IsAssignableFrom (k, oldk))\n+\t\t      if (is_assignable_from_slow (k, oldk))\n \t\t\tbreak;\n \t\t      k = k->getSuperclass ();\n \t\t      changed = true;\n@@ -1543,7 +1587,11 @@ class _Jv_BytecodeVerifier\n     type_val rt = get_type_val_for_signature (jchar (v));\n \n     if (arraycount == 0)\n-      return type (rt);\n+      {\n+\t// Callers of this function eventually push their arguments on\n+\t// the stack.  So, promote them here.\n+\treturn type (rt).promote ();\n+      }\n \n     jclass k = construct_primitive_array_type (rt);\n     while (--arraycount > 0)"}]}