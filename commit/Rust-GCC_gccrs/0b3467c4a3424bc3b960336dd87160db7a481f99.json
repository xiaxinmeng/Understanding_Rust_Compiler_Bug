{"sha": "0b3467c4a3424bc3b960336dd87160db7a481f99", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGIzNDY3YzRhMzQyNGJjM2I5NjAzMzZkZDg3MTYwZGI3YTQ4MWY5OQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-04-15T12:40:15Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-04-15T12:40:15Z"}, "message": "trans.c (call_to_gnu): Open a nesting level if this is a statement.\n\n\t* gcc-interface/trans.c (call_to_gnu): Open a nesting level if this is\n\ta statement.  Otherwise, if at top-level, push the processing of the\n\telaboration routine.  In the misaligned case, issue the error messages\n\tagain on entry and create the temporary explicitly.  Do not issue them\n\tfor CONSTRUCTORs.\n\tFor a function call, emit the range check if necessary.\n\tIn the copy-in copy-out case, create the temporary for the return\n\tvalue explicitly.\n\tDo not unnecessarily convert by-ref parameters to the formal's type.\n\tRemove obsolete guards in conditions.\n\t(gnat_to_gnu) <N_Assignment_Statement>: For a function call, pass the\n\ttarget to call_to_gnu in all cases.\n\t(gnat_gimplify_expr) <ADDR_EXPR>: Remove handling of SAVE_EXPR.\n\t(addressable_p) <CONSTRUCTOR>: Return false if not static.\n\t<COMPOUND_EXPR>: New case.\n\t* gcc-interface/utils2.c (build_unary_op) <ADDR_EXPR>: Fold a compound\n\texpression if it has unconstrained array type.\n\t(gnat_mark_addressable) <COMPOUND_EXPR>: New case.\n\t(gnat_stabilize_reference) <COMPOUND_EXPR>: Stabilize operands on an\n\tindividual basis.\n\nFrom-SVN: r158371", "tree": {"sha": "79c65e316aef5e9cf69d332b87560705466eeb62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79c65e316aef5e9cf69d332b87560705466eeb62"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b3467c4a3424bc3b960336dd87160db7a481f99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b3467c4a3424bc3b960336dd87160db7a481f99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b3467c4a3424bc3b960336dd87160db7a481f99", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b3467c4a3424bc3b960336dd87160db7a481f99/comments", "author": null, "committer": null, "parents": [{"sha": "a09d56d8c7cf30531965eb461d0e58adcb7d72d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a09d56d8c7cf30531965eb461d0e58adcb7d72d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a09d56d8c7cf30531965eb461d0e58adcb7d72d9"}], "stats": {"total": 283, "additions": 188, "deletions": 95}, "files": [{"sha": "3fad5a58e16d17414c569026d29a799b92fb9279", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3467c4a3424bc3b960336dd87160db7a481f99/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3467c4a3424bc3b960336dd87160db7a481f99/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0b3467c4a3424bc3b960336dd87160db7a481f99", "patch": "@@ -1,3 +1,26 @@\n+2010-04-15  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.c (call_to_gnu): Open a nesting level if this is\n+\ta statement.  Otherwise, if at top-level, push the processing of the\n+\telaboration routine.  In the misaligned case, issue the error messages\n+\tagain on entry and create the temporary explicitly.  Do not issue them\n+\tfor CONSTRUCTORs.\n+\tFor a function call, emit the range check if necessary.\n+\tIn the copy-in copy-out case, create the temporary for the return\n+\tvalue explicitly.\n+\tDo not unnecessarily convert by-ref parameters to the formal's type.\n+\tRemove obsolete guards in conditions.\n+\t(gnat_to_gnu) <N_Assignment_Statement>: For a function call, pass the\n+\ttarget to call_to_gnu in all cases.\n+\t(gnat_gimplify_expr) <ADDR_EXPR>: Remove handling of SAVE_EXPR.\n+\t(addressable_p) <CONSTRUCTOR>: Return false if not static.\n+\t<COMPOUND_EXPR>: New case.\n+\t* gcc-interface/utils2.c (build_unary_op) <ADDR_EXPR>: Fold a compound\n+\texpression if it has unconstrained array type.\n+\t(gnat_mark_addressable) <COMPOUND_EXPR>: New case.\n+\t(gnat_stabilize_reference) <COMPOUND_EXPR>: Stabilize operands on an\n+\tindividual basis.\n+\n 2010-04-15  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/trans.c (gigi): Do not start statement group."}, {"sha": "b404ccdca39363435d471f7efecc31a148ce60bd", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 137, "deletions": 94, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3467c4a3424bc3b960336dd87160db7a481f99/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3467c4a3424bc3b960336dd87160db7a481f99/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=0b3467c4a3424bc3b960336dd87160db7a481f99", "patch": "@@ -2470,8 +2470,8 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n /* Subroutine of gnat_to_gnu to translate gnat_node, either an N_Function_Call\n    or an N_Procedure_Call_Statement, to a GCC tree, which is returned.\n    GNU_RESULT_TYPE_P is a pointer to where we should place the result type.\n-   If GNU_TARGET is non-null, this must be a function call and the result\n-   of the call is to be placed into that object.  */\n+   If GNU_TARGET is non-null, this must be a function call on the RHS of a\n+   N_Assignment_Statement and the result is to be placed into that object.  */\n \n static tree\n call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n@@ -2491,6 +2491,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n   tree gnu_before_list = NULL_TREE;\n   tree gnu_after_list = NULL_TREE;\n   tree gnu_call;\n+  bool went_into_elab_proc = false;\n \n   gcc_assert (TREE_CODE (gnu_subprog_type) == FUNCTION_TYPE);\n \n@@ -2527,6 +2528,22 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n   else\n     gnat_formal = First_Formal_With_Extras (Entity (Name (gnat_node)));\n \n+  /* If we are translating a statement, open a new nesting level that will\n+     surround it to declare the temporaries created for the call.  */\n+  if (Nkind (gnat_node) == N_Procedure_Call_Statement || gnu_target)\n+    {\n+      start_stmt_group ();\n+      gnat_pushlevel ();\n+    }\n+\n+  /* The lifetime of the temporaries created for the call ends with the call\n+     so we can give them the scope of the elaboration routine at top level.  */\n+  else if (!current_function_decl)\n+    {\n+      current_function_decl = TREE_VALUE (gnu_elab_proc_stack);\n+      went_into_elab_proc = true;\n+    }\n+\n   /* Create the list of the actual parameters as GCC expects it, namely a\n      chain of TREE_LIST nodes in which the TREE_VALUE field of each node\n      is an expression and the TREE_PURPOSE field is null.  But skip Out\n@@ -2576,7 +2593,34 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t  && (gnu_name_type = gnat_to_gnu_type (Etype (gnat_name)))\n \t  && !addressable_p (gnu_name, gnu_name_type))\n \t{\n-\t  tree gnu_copy = gnu_name;\n+\t  tree gnu_orig = gnu_name, gnu_temp, gnu_stmt;\n+\n+\t  /* Do not issue warnings for CONSTRUCTORs since this is not a copy\n+\t     but sort of an instantiation for them.  */\n+\t  if (TREE_CODE (gnu_name) == CONSTRUCTOR)\n+\t    ;\n+\n+\t  /* If the type is passed by reference, a copy is not allowed.  */\n+\t  else if (TREE_ADDRESSABLE (gnu_formal_type))\n+\t    post_error (\"misaligned actual cannot be passed by reference\",\n+\t\t        gnat_actual);\n+\n+\t  /* For users of Starlet we issue a warning because the interface\n+\t     apparently assumes that by-ref parameters outlive the procedure\n+\t     invocation.  The code still will not work as intended, but we\n+\t     cannot do much better since low-level parts of the back-end\n+\t     would allocate temporaries at will because of the misalignment\n+\t     if we did not do so here.  */\n+\t  else if (Is_Valued_Procedure (Entity (Name (gnat_node))))\n+\t    {\n+\t      post_error\n+\t\t(\"?possible violation of implicit assumption\", gnat_actual);\n+\t      post_error_ne\n+\t\t(\"?made by pragma Import_Valued_Procedure on &\", gnat_actual,\n+\t\t Entity (Name (gnat_node)));\n+\t      post_error_ne (\"?because of misalignment of &\", gnat_actual,\n+\t\t\t     gnat_formal);\n+\t    }\n \n \t  /* If the actual type of the object is already the nominal type,\n \t     we have nothing to do, except if the size is self-referential\n@@ -2585,11 +2629,11 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t      && !CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_name_type)))\n \t    ;\n \n-\t  /* Otherwise remove unpadding from the object and reset the copy.  */\n+\t  /* Otherwise remove the unpadding from all the objects.  */\n \t  else if (TREE_CODE (gnu_name) == COMPONENT_REF\n \t\t   && TYPE_IS_PADDING_P\n \t\t      (TREE_TYPE (TREE_OPERAND (gnu_name, 0))))\n-\t    gnu_name = gnu_copy = TREE_OPERAND (gnu_name, 0);\n+\t    gnu_orig = gnu_name = TREE_OPERAND (gnu_name, 0);\n \n \t  /* Otherwise convert to the nominal type of the object if it's\n \t     a record type.  There are several cases in which we need to\n@@ -2604,46 +2648,31 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t\t\t\t\t\t   gnu_name_type)))\n \t    gnu_name = convert (gnu_name_type, gnu_name);\n \n-\t  /* Make a SAVE_EXPR to force the creation of a temporary.  Special\n-\t     code in gnat_gimplify_expr ensures that the same temporary is\n-\t     used as the object and copied back after the call if needed.  */\n-\t  gnu_name = build1 (SAVE_EXPR, TREE_TYPE (gnu_name), gnu_name);\n-\t  TREE_SIDE_EFFECTS (gnu_name) = 1;\n-\n-\t  /* If the type is passed by reference, a copy is not allowed.  */\n-\t  if (TREE_ADDRESSABLE (gnu_formal_type))\n-\t    {\n-\t      post_error (\"misaligned actual cannot be passed by reference\",\n-\t\t\t  gnat_actual);\n+\t  /* Create an explicit temporary holding the copy.  This ensures that\n+\t     its lifetime is as narrow as possible around a statement.  */\n+\t  gnu_temp = create_var_decl (create_tmp_var_name (\"A\"), NULL_TREE,\n+\t\t\t\t      TREE_TYPE (gnu_name), NULL_TREE, false,\n+\t\t\t\t      false, false, false, NULL, Empty);\n+\t  DECL_ARTIFICIAL (gnu_temp) = 1;\n+\t  DECL_IGNORED_P (gnu_temp) = 1;\n \n-\t      /* Avoid the back-end assertion on temporary creation.  */\n-\t      gnu_name = TREE_OPERAND (gnu_name, 0);\n-\t    }\n+\t  /* But initialize it on the fly like for an implicit temporary as\n+\t     we aren't necessarily dealing with a statement.  */\n+\t  gnu_stmt\n+\t    = build_binary_op (INIT_EXPR, NULL_TREE, gnu_temp, gnu_name);\n+\t  set_expr_location_from_node (gnu_stmt, gnat_actual);\n \n-\t  /* For users of Starlet we issue a warning because the interface\n-\t     apparently assumes that by-ref parameters outlive the procedure\n-\t     invocation.  The code still will not work as intended, but we\n-\t     cannot do much better since low-level parts of the back-end\n-\t     would allocate temporaries at will because of the misalignment\n-\t     if we did not do so here.  */\n-\t  else if (Is_Valued_Procedure (Entity (Name (gnat_node))))\n-\t    {\n-\t      post_error\n-\t\t(\"?possible violation of implicit assumption\", gnat_actual);\n-\t      post_error_ne\n-\t\t(\"?made by pragma Import_Valued_Procedure on &\", gnat_actual,\n-\t\t Entity (Name (gnat_node)));\n-\t      post_error_ne (\"?because of misalignment of &\", gnat_actual,\n-\t\t\t     gnat_formal);\n-\t    }\n+\t  /* From now on, the real object is the temporary.  */\n+\t  gnu_name = build2 (COMPOUND_EXPR, TREE_TYPE (gnu_name), gnu_stmt,\n+\t\t\t     gnu_temp);\n \n \t  /* Set up to move the copy back to the original if needed.  */\n \t  if (Ekind (gnat_formal) != E_In_Parameter)\n \t    {\n-\t      tree stmt = build_binary_op (MODIFY_EXPR, NULL_TREE, gnu_copy,\n-\t\t\t\t\t   gnu_name);\n-\t      set_expr_location_from_node (stmt, gnat_node);\n-\t      append_to_statement_list (stmt, &gnu_after_list);\n+\t      gnu_stmt = build_binary_op (MODIFY_EXPR, NULL_TREE, gnu_orig,\n+\t\t\t\t\t  gnu_temp);\n+\t      set_expr_location_from_node (gnu_stmt, gnat_node);\n+\t      append_to_statement_list (gnu_stmt, &gnu_after_list);\n \t    }\n \t}\n \n@@ -2676,10 +2705,6 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \tgnu_actual\n \t  = emit_range_check (gnu_actual, Etype (gnat_formal), gnat_actual);\n \n-      /* And convert it to this type.  */\n-      if (TREE_CODE (gnu_actual) != SAVE_EXPR)\n-\tgnu_actual = convert (gnu_formal_type, gnu_actual);\n-\n       /* Unless this is an In parameter, we must remove any justified modular\n \t building from GNU_NAME to get an lvalue.  */\n       if (Ekind (gnat_formal) != E_In_Parameter\n@@ -2691,7 +2716,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \n       /* If we have not saved a GCC object for the formal, it means it is an\n \t Out parameter not passed by reference and that need not be copied in.\n-\t Otherwise, first see if the PARM_DECL is passed by reference.  */\n+\t Otherwise, first see if the parameter is passed by reference.  */\n       if (gnu_formal\n \t  && TREE_CODE (gnu_formal) == PARM_DECL\n \t  && DECL_BY_REF_P (gnu_formal))\n@@ -2704,8 +2729,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t      gnu_actual = gnu_name;\n \n \t      /* If we have a padded type, be sure we've removed padding.  */\n-\t      if (TYPE_IS_PADDING_P (TREE_TYPE (gnu_actual))\n-\t\t  && TREE_CODE (gnu_actual) != SAVE_EXPR)\n+\t      if (TYPE_IS_PADDING_P (TREE_TYPE (gnu_actual)))\n \t\tgnu_actual = convert (get_unpadded_type (Etype (gnat_actual)),\n \t\t\t\t      gnu_actual);\n \n@@ -2717,13 +2741,18 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t\t and takes its address.  */\n \t      if (TREE_CODE (TREE_TYPE (gnu_actual)) == RECORD_TYPE\n \t\t  && TYPE_CONTAINS_TEMPLATE_P (TREE_TYPE (gnu_actual))\n-\t\t  && TREE_CODE (gnu_actual) != SAVE_EXPR\n \t\t  && Is_Constr_Subt_For_UN_Aliased (Etype (gnat_actual))\n \t\t  && Is_Array_Type (Etype (gnat_actual)))\n \t\tgnu_actual = convert (gnat_to_gnu_type (Etype (gnat_actual)),\n \t\t\t\t      gnu_actual);\n \t    }\n \n+\t  /* There is no need to convert the actual to the formal's type before\n+\t     taking its address.  The only exception is for unconstrained array\n+\t     types because of the way we build fat pointers.  */\n+\t  else if (TREE_CODE (gnu_formal_type) == UNCONSTRAINED_ARRAY_TYPE)\n+\t    gnu_actual = convert (gnu_formal_type, gnu_actual);\n+\n \t  /* The symmetry of the paths to the type of an entity is broken here\n \t     since arguments don't know that they will be passed by ref.  */\n \t  gnu_formal_type = TREE_TYPE (get_gnu_tree (gnat_formal));\n@@ -2749,14 +2778,14 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t     possibility that the ARRAY_REF might return a constant and we'd be\n \t     getting the wrong address.  Neither approach is exactly correct,\n \t     but this is the most likely to work in all cases.  */\n-\t  gnu_actual = convert (gnu_formal_type,\n-\t\t\t\tbuild_unary_op (ADDR_EXPR, NULL_TREE,\n-\t\t\t\t\t\tgnu_actual));\n+\t  gnu_actual = build_unary_op (ADDR_EXPR, gnu_formal_type, gnu_actual);\n \t}\n       else if (gnu_formal\n \t       && TREE_CODE (gnu_formal) == PARM_DECL\n \t       && DECL_BY_DESCRIPTOR_P (gnu_formal))\n \t{\n+\t  gnu_actual = convert (gnu_formal_type, gnu_actual);\n+\n \t  /* If this is 'Null_Parameter, pass a zero descriptor.  */\n \t  if ((TREE_CODE (gnu_actual) == INDIRECT_REF\n \t       || TREE_CODE (gnu_actual) == UNCONSTRAINED_ARRAY_REF)\n@@ -2784,6 +2813,8 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t      continue;\n \t    }\n \n+\t  gnu_actual = convert (gnu_formal_type, gnu_actual);\n+\n \t  /* If this is 'Null_Parameter, pass a zero even though we are\n \t     dereferencing it.  */\n \t  if (TREE_CODE (gnu_actual) == INDIRECT_REF\n@@ -2814,7 +2845,6 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n   if (Nkind (gnat_node) == N_Function_Call)\n     {\n       tree gnu_result = gnu_call;\n-      enum tree_code op_code;\n \n       /* If the function returns an unconstrained array or by direct reference,\n \t we have to dereference the pointer.  */\n@@ -2824,6 +2854,15 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \n       if (gnu_target)\n \t{\n+\t  Node_Id gnat_parent = Parent (gnat_node);\n+\t  enum tree_code op_code;\n+\n+\t  /* If range check is needed, emit code to generate it.  */\n+\t  if (Do_Range_Check (gnat_node))\n+\t    gnu_result\n+\t      = emit_range_check (gnu_result, Etype (Name (gnat_parent)),\n+\t\t\t\t  gnat_parent);\n+\n \t  /* ??? If the return type has non-constant size, then force the\n \t     return slot optimization as we would not be able to generate\n \t     a temporary.  That's what has been done historically.  */\n@@ -2834,9 +2873,16 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \n \t  gnu_result\n \t    = build_binary_op (op_code, NULL_TREE, gnu_target, gnu_result);\n+\t  add_stmt_with_node (gnu_result, gnat_parent);\n+\t  gnat_poplevel ();\n+\t  gnu_result = end_stmt_group ();\n \t}\n       else\n-\t*gnu_result_type_p = get_unpadded_type (Etype (gnat_node));\n+\t{\n+\t  if (went_into_elab_proc)\n+\t    current_function_decl = NULL_TREE;\n+\t  *gnu_result_type_p = get_unpadded_type (Etype (gnat_node));\n+\t}\n \n       return gnu_result;\n     }\n@@ -2846,17 +2892,31 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n      passing mechanism must be used.  */\n   if (TYPE_CI_CO_LIST (gnu_subprog_type))\n     {\n-      /* List of FIELD_DECLs associated with the PARM_DECLs of the copy\n-\t in copy out parameters.  */\n+      /* List of FIELD_DECLs associated with the PARM_DECLs of the copy-in/\n+\t copy-out parameters.  */\n       tree gnu_cico_list = TYPE_CI_CO_LIST (gnu_subprog_type);\n       const int length = list_length (gnu_cico_list);\n \n       if (length > 1)\n \t{\n+\t  tree gnu_temp, gnu_stmt;\n+\n \t  /* The call sequence must contain one and only one call, even though\n-\t     the function is const or pure.  So force a SAVE_EXPR.  */\n-\t  gnu_call = build1 (SAVE_EXPR, TREE_TYPE (gnu_call), gnu_call);\n-\t  TREE_SIDE_EFFECTS (gnu_call) = 1;\n+\t     the function is pure.  Save the result into a temporary.  */\n+\t  gnu_temp = create_var_decl (create_tmp_var_name (\"R\"), NULL_TREE,\n+\t\t\t\t      TREE_TYPE (gnu_call), NULL_TREE, false,\n+\t\t\t\t      false, false, false, NULL, Empty);\n+\t  DECL_ARTIFICIAL (gnu_temp) = 1;\n+\t  DECL_IGNORED_P (gnu_temp) = 1;\n+\n+\t  gnu_stmt\n+\t    = build_binary_op (INIT_EXPR, NULL_TREE, gnu_temp, gnu_call);\n+\t  set_expr_location_from_node (gnu_stmt, gnat_node);\n+\n+\t  /* Add the call statement to the list and start from its result.  */\n+\t  append_to_statement_list (gnu_stmt, &gnu_before_list);\n+\t  gnu_call = gnu_temp;\n+\n \t  gnu_name_list = nreverse (gnu_name_list);\n \t}\n \n@@ -2959,7 +3019,9 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \n   append_to_statement_list (gnu_after_list, &gnu_before_list);\n \n-  return gnu_before_list;\n+  add_stmt (gnu_before_list);\n+  gnat_poplevel ();\n+  return end_stmt_group ();\n }\n \f\n /* Subroutine of gnat_to_gnu to translate gnat_node, an\n@@ -4538,9 +4600,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \n     case N_Assignment_Statement:\n       /* Get the LHS and RHS of the statement and convert any reference to an\n-\t unconstrained array into a reference to the underlying array.\n-\t If we are not to do range checking and the RHS is an N_Function_Call,\n-\t pass the LHS to the call function.  */\n+\t unconstrained array into a reference to the underlying array.  */\n       gnu_lhs = maybe_unconstrained_array (gnat_to_gnu (Name (gnat_node)));\n \n       /* If the type has a size that overflows, convert this into raise of\n@@ -4549,10 +4609,9 @@ gnat_to_gnu (Node_Id gnat_node)\n \t   && TREE_OVERFLOW (TYPE_SIZE_UNIT (TREE_TYPE (gnu_lhs))))\n \tgnu_result = build_call_raise (SE_Object_Too_Large, gnat_node,\n \t\t\t\t       N_Raise_Storage_Error);\n-      else if (Nkind (Expression (gnat_node)) == N_Function_Call\n-\t       && !Do_Range_Check (Expression (gnat_node)))\n-\tgnu_result = call_to_gnu (Expression (gnat_node),\n-\t\t\t\t  &gnu_result_type, gnu_lhs);\n+      else if (Nkind (Expression (gnat_node)) == N_Function_Call)\n+\tgnu_result\n+\t  = call_to_gnu (Expression (gnat_node), &gnu_result_type, gnu_lhs);\n       else\n \t{\n \t  gnu_rhs\n@@ -5816,34 +5875,6 @@ gnat_gimplify_expr (tree *expr_p, gimple_seq *pre_p,\n \t  return GS_ALL_DONE;\n \t}\n \n-      /* If we are taking the address of a SAVE_EXPR, we are typically dealing\n-\t with a misaligned argument to be passed by reference in a subprogram\n-\t call.  We cannot let the common gimplifier code perform the creation\n-\t of the temporary and its initialization because, in order to ensure\n-\t that the final copy operation is a store and since the temporary made\n-\t for a SAVE_EXPR is not addressable, it may create another temporary,\n-\t addressable this time, which would break the back copy mechanism for\n-\t an IN OUT parameter.  */\n-      if (TREE_CODE (op) == SAVE_EXPR && !SAVE_EXPR_RESOLVED_P (op))\n-\t{\n-\t  tree mod, val = TREE_OPERAND (op, 0);\n-\t  tree new_var = create_tmp_var (TREE_TYPE (op), \"S\");\n-\t  TREE_ADDRESSABLE (new_var) = 1;\n-\n-\t  mod = build2 (INIT_EXPR, TREE_TYPE (new_var), new_var, val);\n-\t  if (EXPR_HAS_LOCATION (val))\n-\t    SET_EXPR_LOCATION (mod, EXPR_LOCATION (val));\n-\t  gimplify_and_add (mod, pre_p);\n-\t  ggc_free (mod);\n-\n-\t  TREE_OPERAND (op, 0) = new_var;\n-\t  SAVE_EXPR_RESOLVED_P (op) = 1;\n-\n-\t  TREE_OPERAND (expr, 0) = new_var;\n-\t  recompute_tree_invariant_for_addr_expr (expr);\n-\t  return GS_ALL_DONE;\n-\t}\n-\n       return GS_UNHANDLED;\n \n     case DECL_EXPR:\n@@ -6927,11 +6958,19 @@ addressable_p (tree gnu_expr, tree gnu_type)\n \n     case UNCONSTRAINED_ARRAY_REF:\n     case INDIRECT_REF:\n+      /* Taking the address of a dereference yields the original pointer.  */\n       return true;\n \n-    case CONSTRUCTOR:\n     case STRING_CST:\n     case INTEGER_CST:\n+      /* Taking the address yields a pointer to the constant pool.  */\n+      return true;\n+\n+    case CONSTRUCTOR:\n+      /* Taking the address of a static constructor yields a pointer to the\n+\t tree constant pool.  */\n+      return TREE_STATIC (gnu_expr) ? true : false;\n+\n     case NULL_EXPR:\n     case SAVE_EXPR:\n     case CALL_EXPR:\n@@ -6945,6 +6984,10 @@ addressable_p (tree gnu_expr, tree gnu_type)\n \t force a temporary to be created by the middle-end.  */\n       return true;\n \n+    case COMPOUND_EXPR:\n+      /* The address of a compound expression is that of its 2nd operand.  */\n+      return addressable_p (TREE_OPERAND (gnu_expr, 1), gnu_type);\n+\n     case COND_EXPR:\n       /* We accept &COND_EXPR as soon as both operands are addressable and\n \t expect the outcome to be the address of the selected operand.  */"}, {"sha": "8257507285229e018d0467ae9a6d225c7ec0b49f", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3467c4a3424bc3b960336dd87160db7a481f99/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3467c4a3424bc3b960336dd87160db7a481f99/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=0b3467c4a3424bc3b960336dd87160db7a481f99", "patch": "@@ -1025,6 +1025,22 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \t  TREE_TYPE (result) = type = build_pointer_type (type);\n \t  break;\n \n+\tcase COMPOUND_EXPR:\n+\t  /* Fold a compound expression if it has unconstrained array type\n+\t     since the middle-end cannot handle it.  But we don't it in the\n+\t     general case because it may introduce aliasing issues if the\n+\t     first operand is an indirect assignment and the second operand\n+\t     the corresponding address, e.g. for an allocator.  */\n+\t  if (TREE_CODE (type) == UNCONSTRAINED_ARRAY_TYPE)\n+\t    {\n+\t      result = build_unary_op (ADDR_EXPR, result_type,\n+\t\t\t\t       TREE_OPERAND (operand, 1));\n+\t      result = build2 (COMPOUND_EXPR, TREE_TYPE (result),\n+\t\t\t       TREE_OPERAND (operand, 0), result);\n+\t      break;\n+\t    }\n+\t  goto common;\n+\n \tcase ARRAY_REF:\n \tcase ARRAY_RANGE_REF:\n \tcase COMPONENT_REF:\n@@ -2119,6 +2135,10 @@ gnat_mark_addressable (tree t)\n \tt = TREE_OPERAND (t, 0);\n \tbreak;\n \n+      case COMPOUND_EXPR:\n+\tt = TREE_OPERAND (t, 1);\n+\tbreak;\n+\n       case CONSTRUCTOR:\n \tTREE_ADDRESSABLE (t) = 1;\n \treturn true;\n@@ -2377,10 +2397,17 @@ gnat_stabilize_reference (tree ref, bool force, bool *success)\n       break;\n \n     case CALL_EXPR:\n-    case COMPOUND_EXPR:\n       result = gnat_stabilize_reference_1 (ref, force);\n       break;\n \n+    case COMPOUND_EXPR:\n+      result = build2 (COMPOUND_EXPR, type,\n+\t\t       gnat_stabilize_reference (TREE_OPERAND (ref, 0), force,\n+\t\t\t\t\t\t success),\n+\t\t       gnat_stabilize_reference_1 (TREE_OPERAND (ref, 1),\n+\t\t\t\t\t\t   force));\n+      break;\n+\n     case CONSTRUCTOR:\n       /* Constructors with 1 element are used extensively to formally\n \t convert objects to special wrapping types.  */"}]}