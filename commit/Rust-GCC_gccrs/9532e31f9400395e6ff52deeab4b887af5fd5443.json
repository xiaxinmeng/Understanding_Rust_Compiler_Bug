{"sha": "9532e31f9400395e6ff52deeab4b887af5fd5443", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTUzMmUzMWY5NDAwMzk1ZTZmZjUyZGVlYWI0Yjg4N2FmNWZkNTQ0Mw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.co.uk", "date": "2000-11-10T17:10:29Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2000-11-10T17:10:29Z"}, "message": "Several fixes to make reload handle POST_MODIFY correctly.\n\nFrom-SVN: r37370", "tree": {"sha": "74fd6f3ab15c83065ab514c600485d8685ff24f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74fd6f3ab15c83065ab514c600485d8685ff24f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9532e31f9400395e6ff52deeab4b887af5fd5443", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9532e31f9400395e6ff52deeab4b887af5fd5443", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9532e31f9400395e6ff52deeab4b887af5fd5443", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9532e31f9400395e6ff52deeab4b887af5fd5443/comments", "author": null, "committer": null, "parents": [{"sha": "29e9c0c4f1c93a8a591628890da8852eb69bde73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29e9c0c4f1c93a8a591628890da8852eb69bde73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29e9c0c4f1c93a8a591628890da8852eb69bde73"}], "stats": {"total": 121, "additions": 83, "deletions": 38}, "files": [{"sha": "532a9c6bfd5e12355a30fba87eddca981f7bf14a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9532e31f9400395e6ff52deeab4b887af5fd5443/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9532e31f9400395e6ff52deeab4b887af5fd5443/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9532e31f9400395e6ff52deeab4b887af5fd5443", "patch": "@@ -1,3 +1,12 @@\n+2000-11-10  Bernd Schmidt  <bernds@redhat.co.uk>\n+\n+\t* reload.c (find_reloads_address_1, case POST_MODIFY): Use RELOAD_OTHER\n+\tfor address reloads.  Push replacements for REG_INC notes.\n+\t(regno_clobbered_p): New arg SETS.  Examine SETs if it's nonzero.  All\n+\tcallers changed.\n+\t* reload1.c (choose_reload_regs): Registers set in the insn can't be\n+\tused for RELOAD_OTHER reloads.\n+\n 2000-11-10  Mark Mitchell  <mark@codesourcery.com>\n \n \t* c-dump.h: New file."}, {"sha": "86d80c1af23bd670f753bd0231058e9539ba2e7d", "filename": "gcc/reload.c", "status": "modified", "additions": 33, "deletions": 17, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9532e31f9400395e6ff52deeab4b887af5fd5443/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9532e31f9400395e6ff52deeab4b887af5fd5443/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=9532e31f9400395e6ff52deeab4b887af5fd5443", "patch": "@@ -4536,7 +4536,7 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels, insn)\n \n       else if (regno < FIRST_PSEUDO_REGISTER\n \t       && REGNO_MODE_OK_FOR_BASE_P (regno, mode)\n-\t       && ! regno_clobbered_p (regno, this_insn, mode))\n+\t       && ! regno_clobbered_p (regno, this_insn, mode, 0))\n \treturn 0;\n \n       /* If we do not have one of the cases above, we must do the reload.  */\n@@ -5155,7 +5155,9 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \n \tif (REG_P (XEXP (op1, 0)))\n \t  {\n-\t    register int regno = REGNO (XEXP (op1, 0));\n+\t    rtx link;\n+\t    int regno = REGNO (XEXP (op1, 0));\n+\t    int reloadnum;\n \n \t    /* A register that is incremented cannot be constant!  */\n \t    if (regno >= FIRST_PSEUDO_REGISTER\n@@ -5178,15 +5180,17 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t\t       write back the value after reading it, hence we actually\n \t\t       need two registers.  */\n \t\t    find_reloads_address (GET_MODE (tem), 0, XEXP (tem, 0),\n-\t\t\t\t\t  &XEXP (tem, 0), opnum, type,\n+\t\t\t\t\t  &XEXP (tem, 0), opnum,\n+\t\t\t\t\t  RELOAD_OTHER,\n \t\t\t\t\t  ind_levels, insn);\n \n \t\t    /* Then reload the memory location into a base\n \t\t       register.  */\n-\t\t    push_reload (tem, tem, &XEXP (x, 0), &XEXP (op1, 0),\n-\t\t\t\t BASE_REG_CLASS, GET_MODE (x), GET_MODE (x),\n-\t\t\t\t 0, 0, opnum, RELOAD_OTHER);\n-\t\t    break;\n+\t\t    reloadnum = push_reload (tem, tem, &XEXP (x, 0),\n+\t\t\t\t\t     &XEXP (op1, 0), BASE_REG_CLASS,\n+\t\t\t\t\t     GET_MODE (x), GET_MODE (x), 0,\n+\t\t\t\t\t     0, opnum, RELOAD_OTHER);\n+\t\t    goto reg_inc;\n \t\t  }\n \t      }\n \n@@ -5196,12 +5200,19 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t    /* We require a base register here...  */\n \t    if (!REGNO_MODE_OK_FOR_BASE_P (regno, GET_MODE (x)))\n \t      {\n-\t\tpush_reload (XEXP (op1, 0), XEXP (x, 0),\n-\t\t\t     &XEXP (op1, 0), &XEXP (x, 0),\n-\t\t\t     BASE_REG_CLASS,\n-\t\t\t     GET_MODE (x), GET_MODE (x), 0, 0,\n-\t\t\t     opnum, RELOAD_OTHER);\n+\t\treloadnum = push_reload (XEXP (op1, 0), XEXP (x, 0),\n+\t\t\t\t\t &XEXP (op1, 0), &XEXP (x, 0),\n+\t\t\t\t\t BASE_REG_CLASS,\n+\t\t\t\t\t GET_MODE (x), GET_MODE (x), 0, 0,\n+\t\t\t\t\t opnum, RELOAD_OTHER);\n \t      }\n+\n+\t    /* Update the REG_INC notes.  */\n+\t  reg_inc:\n+\t    for (link = REG_NOTES (this_insn); link; link = XEXP (link, 1))\n+\t      if (REG_NOTE_KIND (link) == REG_INC\n+\t\t  && REGNO (XEXP (link, 0)) == regno)\n+\t\tpush_replacement (&XEXP (link, 0), reloadnum, VOIDmode);\n \t  }\n \telse\n \t  abort ();\n@@ -5441,7 +5452,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t   in this insn, reload it into some other register to be safe.\n \t   The CLOBBER is supposed to make the register unavailable\n \t   from before this insn to after it.  */\n-\tif (regno_clobbered_p (regno, this_insn, GET_MODE (x)))\n+\tif (regno_clobbered_p (regno, this_insn, GET_MODE (x), 0))\n \t  {\n \t    push_reload (x, NULL_RTX, loc, NULL_PTR,\n \t\t\t (context ? INDEX_REG_CLASS : BASE_REG_CLASS),\n@@ -6552,18 +6563,21 @@ find_inc_amount (x, inced)\n   return 0;\n }\n \f\n-/* Return 1 if register REGNO is the subject of a clobber in insn INSN.  */\n+/* Return 1 if register REGNO is the subject of a clobber in insn INSN.\n+   If SETS is nonzero, also consider SETs.  */\n \n int\n-regno_clobbered_p (regno, insn, mode)\n+regno_clobbered_p (regno, insn, mode, sets)\n      unsigned int regno;\n      rtx insn;\n      enum machine_mode mode;\n+     int sets;\n {\n   int nregs = HARD_REGNO_NREGS (regno, mode);\n   int endregno = regno + nregs;\n \n-  if (GET_CODE (PATTERN (insn)) == CLOBBER\n+  if ((GET_CODE (PATTERN (insn)) == CLOBBER\n+       || (sets && GET_CODE (PATTERN (insn)) == SET))\n       && GET_CODE (XEXP (PATTERN (insn), 0)) == REG)\n     {\n       int test = REGNO (XEXP (PATTERN (insn), 0));\n@@ -6578,7 +6592,9 @@ regno_clobbered_p (regno, insn, mode)\n       for (; i >= 0; i--)\n \t{\n \t  rtx elt = XVECEXP (PATTERN (insn), 0, i);\n-\t  if (GET_CODE (elt) == CLOBBER && GET_CODE (XEXP (elt, 0)) == REG)\n+\t  if ((GET_CODE (elt) == CLOBBER\n+\t       || (sets && GET_CODE (PATTERN (insn)) == SET))\n+\t      && GET_CODE (XEXP (elt, 0)) == REG)\n \t    {\n \t      int test = REGNO (XEXP (elt, 0));\n \t      "}, {"sha": "7841c7ad7d1383ee201ece4351d3e3a64a06973e", "filename": "gcc/reload.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9532e31f9400395e6ff52deeab4b887af5fd5443/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9532e31f9400395e6ff52deeab4b887af5fd5443/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=9532e31f9400395e6ff52deeab4b887af5fd5443", "patch": "@@ -335,7 +335,8 @@ extern rtx find_equiv_reg PARAMS ((rtx, rtx, enum reg_class, int, short *,\n \t\t\t\t int, enum machine_mode));\n \n /* Return 1 if register REGNO is the subject of a clobber in insn INSN.  */\n-extern int regno_clobbered_p PARAMS ((unsigned int, rtx, enum machine_mode));\n+extern int regno_clobbered_p PARAMS ((unsigned int, rtx, enum machine_mode,\n+\t\t\t\t      int));\n \n /* Return 1 if X is an operand of an insn that is being earlyclobbered.  */\n int earlyclobber_operand_p PARAMS ((rtx));"}, {"sha": "fe749293dbfa1586b3a2c2ea1c1ce18a4cb67b4d", "filename": "gcc/reload1.c", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9532e31f9400395e6ff52deeab4b887af5fd5443/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9532e31f9400395e6ff52deeab4b887af5fd5443/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=9532e31f9400395e6ff52deeab4b887af5fd5443", "patch": "@@ -5544,25 +5544,44 @@ choose_reload_regs (chain)\n \t\t In particular, we then can't use EQUIV for a\n \t\t RELOAD_FOR_OUTPUT_ADDRESS reload.  */\n \n-\t      if (equiv != 0 && regno_clobbered_p (regno, insn, rld[r].mode))\n-\t\t{\n-\t\t  switch (rld[r].when_needed)\n-\t\t    {\n-\t\t    case RELOAD_FOR_OTHER_ADDRESS:\n-\t\t    case RELOAD_FOR_INPADDR_ADDRESS:\n-\t\t    case RELOAD_FOR_INPUT_ADDRESS:\n-\t\t    case RELOAD_FOR_OPADDR_ADDR:\n-\t\t      break;\n-\t\t    case RELOAD_OTHER:\n-\t\t    case RELOAD_FOR_INPUT:\n-\t\t    case RELOAD_FOR_OPERAND_ADDRESS:\n-\t\t      if (! rld[r].optional)\n-\t\t\treload_override_in[r] = equiv;\n-\t\t      /* Fall through.  */\n-\t\t    default:\n-\t\t      equiv = 0;\n-\t\t      break;\n-\t\t    }\n+\t      if (equiv != 0)\n+  \t\t{\n+\t\t  if (regno_clobbered_p (regno, insn, rld[r].mode, 0))\n+\t\t    switch (rld[r].when_needed)\n+\t\t      {\n+\t\t      case RELOAD_FOR_OTHER_ADDRESS:\n+\t\t      case RELOAD_FOR_INPADDR_ADDRESS:\n+\t\t      case RELOAD_FOR_INPUT_ADDRESS:\n+\t\t      case RELOAD_FOR_OPADDR_ADDR:\n+\t\t\tbreak;\n+\t\t      case RELOAD_OTHER:\n+\t\t      case RELOAD_FOR_INPUT:\n+\t\t      case RELOAD_FOR_OPERAND_ADDRESS:\n+\t\t\tif (! rld[r].optional)\n+\t\t\t  reload_override_in[r] = equiv;\n+\t\t\t/* Fall through.  */\n+\t\t      default:\n+\t\t\tequiv = 0;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  else if (regno_clobbered_p (regno, insn, rld[r].mode, 1))\n+\t\t    switch (rld[r].when_needed)\n+\t\t      {\n+\t\t      case RELOAD_FOR_OTHER_ADDRESS:\n+\t\t      case RELOAD_FOR_INPADDR_ADDRESS:\n+\t\t      case RELOAD_FOR_INPUT_ADDRESS:\n+\t\t      case RELOAD_FOR_OPADDR_ADDR:\n+\t\t      case RELOAD_FOR_OPERAND_ADDRESS:\n+\t\t      case RELOAD_FOR_INPUT:\n+\t\t\tbreak;\n+\t\t      case RELOAD_OTHER:\n+\t\t\tif (! rld[r].optional)\n+\t\t\t  reload_override_in[r] = equiv;\n+\t\t\t/* Fall through.  */\n+\t\t      default:\n+\t\t\tequiv = 0;\n+\t\t\tbreak;\n+\t\t      }\n \t\t}\n \n \t      /* If we found an equivalent reg, say no code need be generated\n@@ -6567,7 +6586,7 @@ emit_output_reload_insns (chain, rl, j)\n \t  || !(set = single_set (insn))\n \t  || rtx_equal_p (old, SET_DEST (set))\n \t  || !reg_mentioned_p (old, SET_SRC (set))\n-\t  || !regno_clobbered_p (REGNO (old), insn, rl->mode))\n+\t  || !regno_clobbered_p (REGNO (old), insn, rl->mode, 0))\n \tgen_reload (old, reloadreg, rl->opnum,\n \t\t    rl->when_needed);\n     }"}]}