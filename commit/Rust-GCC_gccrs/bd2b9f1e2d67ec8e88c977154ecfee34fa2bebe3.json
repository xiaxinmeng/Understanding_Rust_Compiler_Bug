{"sha": "bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQyYjlmMWUyZDY3ZWM4ZTg4Yzk3NzE1NGVjZmVlMzRmYTJiZWJlMw==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2018-02-09T02:21:57Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2018-02-09T02:21:57Z"}, "message": "[LVU] Introduce location views\n\nThis patch introduces an option to enable the generation of location\nviews along with location lists.  The exact format depends on the\nDWARF version: it can be a separate attribute (DW_AT_GNU_locviews) or\n(DW_LLE_view_pair) entries in DWARF5+ loclists.\n\nLine number tables are also affected.  If the assembler is found, at\ncompiler build time, to support .loc views, we use them and\nassembler-computed view labels, otherwise we output compiler-generated\nline number programs with conservatively-computed view labels.  In\neither case, we output view information next to line number changes\nwhen verbose assembly output is requested.\n\nThis patch requires an LVU patch that modifies the exported API of\nfinal_scan_insn.  It also expects the entire SFN patchset to be\ninstalled first, although SFN is not a requirement for LVU.\n\nfor  include/ChangeLog\n\n\t* dwarf2.def (DW_AT_GNU_locviews): New.\n\t* dwarf2.h (enum dwarf_location_list_entry_type): Add\n\tDW_LLE_GNU_view_pair.\n\t(DW_LLE_view_pair): Define.\n\nfor  gcc/ChangeLog\n\n\t* common.opt (gvariable-location-views): New.\n\t(gvariable-location-views=incompat5): New.\n\t* config.in: Rebuilt.\n\t* configure: Rebuilt.\n\t* configure.ac: Test assembler for view support.\n\t* dwarf2asm.c (dw2_asm_output_symname_uleb128): New.\n\t* dwarf2asm.h (dw2_asm_output_symname_uleb128): Declare.\n\t* dwarf2out.c (var_loc_view): New typedef.\n\t(struct dw_loc_list_struct): Add vl_symbol, vbegin, vend.\n\t(dwarf2out_locviews_in_attribute): New.\n\t(dwarf2out_locviews_in_loclist): New.\n\t(dw_val_equal_p): Compare val_view_list of dw_val_class_view_lists.\n\t(enum dw_line_info_opcode): Add LI_adv_address.\n\t(struct dw_line_info_table): Add view.\n\t(RESET_NEXT_VIEW, RESETTING_VIEW_P): New macros.\n\t(DWARF2_ASM_VIEW_DEBUG_INFO): Define default.\n\t(zero_view_p): New variable.\n\t(ZERO_VIEW_P): New macro.\n\t(output_asm_line_debug_info): New.\n\t(struct var_loc_node): Add view.\n\t(add_AT_view_list, AT_loc_list): New.\n\t(add_var_loc_to_decl): Add view param.  Test it against last.\n\t(new_loc_list): Add view params.  Record them.\n\t(AT_loc_list_ptr): Handle loc and view lists.\n\t(view_list_to_loc_list_val_node): New.\n\t(print_dw_val): Handle dw_val_class_view_list.\n\t(size_of_die): Likewise.\n\t(value_format): Likewise.\n\t(loc_list_has_views): New.\n\t(gen_llsym): Set vl_symbol too.\n\t(maybe_gen_llsym, skip_loc_list_entry): New.\n\t(dwarf2out_maybe_output_loclist_view_pair): New.\n\t(output_loc_list): Output view list or entries too.\n\t(output_view_list_offset): New.\n\t(output_die): Handle dw_val_class_view_list.\n\t(output_dwarf_version): New.\n\t(output_compilation_unit_header): Use it.\n\t(output_skeleton_debug_sections): Likewise.\n\t(output_rnglists, output_line_info): Likewise.\n\t(output_pubnames, output_aranges): Update version comments.\n\t(output_one_line_info_table): Output view numbers in asm comments.\n\t(dw_loc_list): Determine current endview, pass it to new_loc_list.\n\tCall maybe_gen_llsym.\n\t(loc_list_from_tree_1): Adjust.\n\t(add_AT_location_description): Create view list attribute if\n\tneeded, check it's absent otherwise.\n\t(convert_cfa_to_fb_loc_list): Adjust.\n\t(maybe_emit_file): Call output_asm_line_debug_info for test.\n\t(dwarf2out_var_location): Reset views as needed.  Precompute\n\tadd_var_loc_to_decl args.  Call get_attr_min_length only if we have the\n\tattribute.  Set view.\n\t(new_line_info_table): Reset next view.\n\t(set_cur_line_info_table): Call output_asm_line_debug_info for test.\n\t(dwarf2out_source_line): Likewise.  Output view resets and labels to\n\tthe assembler, or select appropriate line info opcodes.\n\t(prune_unused_types_walk_attribs): Handle dw_val_class_view_list.\n\t(optimize_string_length): Catch it.  Adjust.\n\t(resolve_addr): Copy vl_symbol along with ll_symbol.  Handle\n\tdw_val_class_view_list, and remove it if no longer needed.\n\t(hash_loc_list): Hash view numbers.\n\t(loc_list_hasher::equal): Compare them.\n\t(optimize_location_lists): Check whether a view list symbol is\n\tneeded, and whether the locview attribute is present, and\n\twhether they match.  Remove the locview attribute if no longer\n\tneeded.\n\t(index_location_lists): Call skip_loc_list_entry for test.\n\t(dwarf2out_finish): Call output_asm_line_debug_info for test.\n\tUse output_dwarf_version.\n\t* dwarf2out.h (enum dw_val_class): Add dw_val_class_view_list.\n\t(struct dw_val_node): Add val_view_list.\n\t* final.c (SEEN_NEXT_VIEW): New.\n\t(set_next_view_needed): New.\n\t(clear_next_view_needed): New.\n\t(maybe_output_next_view): New.\n\t(final_start_function): Rename to...\n\t(final_start_function_1): ... this.  Take pointer to FIRST,\n\tadd SEEN parameter.  Emit param bindings in the initial view.\n\t(final_start_function): Reintroduce SEEN-less interface.\n\t(final): Rename to...\n\t(final_1): ... this.  Take SEEN parameter.  Output final pending\n\tnext view at the end.\n\t(final): Reintroduce seen-less interface.\n\t(final_scan_insn): Output pending next view before switching\n\tsections or ending a block.  Mark the next view as needed when\n\toutputting variable locations.  Notify debug backend of section\n\tchanges, and of location view changes.\n\t(rest_of_handle_final): Adjust.\n\t* toplev.c (process_options): Autodetect value for debug variable\n\tlocation views option.  Warn on incompat5 without -gdwarf-5.\n\t* doc/invoke.texi (gvariable-location-views): New.\n\t(gvariable-location-views=incompat5): New.\n\t(gno-variable-location-views): New.\n\nFrom-SVN: r257510", "tree": {"sha": "58637fc40fa0fa1fe325f3d6003266432b3bc8ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58637fc40fa0fa1fe325f3d6003266432b3bc8ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3/comments", "author": null, "committer": null, "parents": [{"sha": "6d3aa24cd6535dcfc9f0701579eca53aa191768c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d3aa24cd6535dcfc9f0701579eca53aa191768c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d3aa24cd6535dcfc9f0701579eca53aa191768c"}], "stats": {"total": 1119, "additions": 1038, "deletions": 81}, "files": [{"sha": "1d9c97298e885d0f3665ef01357b9a43126dd499", "filename": "gcc/ChangeLog", "status": "modified", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3", "patch": "@@ -1,3 +1,98 @@\n+2018-02-09  Alexandre Oliva <aoliva@redhat.com>\n+\n+\t* common.opt (gvariable-location-views): New.\n+\t(gvariable-location-views=incompat5): New.\n+\t* config.in: Rebuilt.\n+\t* configure: Rebuilt.\n+\t* configure.ac: Test assembler for view support.\n+\t* dwarf2asm.c (dw2_asm_output_symname_uleb128): New.\n+\t* dwarf2asm.h (dw2_asm_output_symname_uleb128): Declare.\n+\t* dwarf2out.c (var_loc_view): New typedef.\n+\t(struct dw_loc_list_struct): Add vl_symbol, vbegin, vend.\n+\t(dwarf2out_locviews_in_attribute): New.\n+\t(dwarf2out_locviews_in_loclist): New.\n+\t(dw_val_equal_p): Compare val_view_list of dw_val_class_view_lists.\n+\t(enum dw_line_info_opcode): Add LI_adv_address.\n+\t(struct dw_line_info_table): Add view.\n+\t(RESET_NEXT_VIEW, RESETTING_VIEW_P): New macros.\n+\t(DWARF2_ASM_VIEW_DEBUG_INFO): Define default.\n+\t(zero_view_p): New variable.\n+\t(ZERO_VIEW_P): New macro.\n+\t(output_asm_line_debug_info): New.\n+\t(struct var_loc_node): Add view.\n+\t(add_AT_view_list, AT_loc_list): New.\n+\t(add_var_loc_to_decl): Add view param.  Test it against last.\n+\t(new_loc_list): Add view params.  Record them.\n+\t(AT_loc_list_ptr): Handle loc and view lists.\n+\t(view_list_to_loc_list_val_node): New.\n+\t(print_dw_val): Handle dw_val_class_view_list.\n+\t(size_of_die): Likewise.\n+\t(value_format): Likewise.\n+\t(loc_list_has_views): New.\n+\t(gen_llsym): Set vl_symbol too.\n+\t(maybe_gen_llsym, skip_loc_list_entry): New.\n+\t(dwarf2out_maybe_output_loclist_view_pair): New.\n+\t(output_loc_list): Output view list or entries too.\n+\t(output_view_list_offset): New.\n+\t(output_die): Handle dw_val_class_view_list.\n+\t(output_dwarf_version): New.\n+\t(output_compilation_unit_header): Use it.\n+\t(output_skeleton_debug_sections): Likewise.\n+\t(output_rnglists, output_line_info): Likewise.\n+\t(output_pubnames, output_aranges): Update version comments.\n+\t(output_one_line_info_table): Output view numbers in asm comments.\n+\t(dw_loc_list): Determine current endview, pass it to new_loc_list.\n+\tCall maybe_gen_llsym.\n+\t(loc_list_from_tree_1): Adjust.\n+\t(add_AT_location_description): Create view list attribute if\n+\tneeded, check it's absent otherwise.\n+\t(convert_cfa_to_fb_loc_list): Adjust.\n+\t(maybe_emit_file): Call output_asm_line_debug_info for test.\n+\t(dwarf2out_var_location): Reset views as needed.  Precompute\n+\tadd_var_loc_to_decl args.  Call get_attr_min_length only if we have the\n+\tattribute.  Set view.\n+\t(new_line_info_table): Reset next view.\n+\t(set_cur_line_info_table): Call output_asm_line_debug_info for test.\n+\t(dwarf2out_source_line): Likewise.  Output view resets and labels to\n+\tthe assembler, or select appropriate line info opcodes.\n+\t(prune_unused_types_walk_attribs): Handle dw_val_class_view_list.\n+\t(optimize_string_length): Catch it.  Adjust.\n+\t(resolve_addr): Copy vl_symbol along with ll_symbol.  Handle\n+\tdw_val_class_view_list, and remove it if no longer needed.\n+\t(hash_loc_list): Hash view numbers.\n+\t(loc_list_hasher::equal): Compare them.\n+\t(optimize_location_lists): Check whether a view list symbol is\n+\tneeded, and whether the locview attribute is present, and\n+\twhether they match.  Remove the locview attribute if no longer\n+\tneeded.\n+\t(index_location_lists): Call skip_loc_list_entry for test.\n+\t(dwarf2out_finish): Call output_asm_line_debug_info for test.\n+\tUse output_dwarf_version.\n+\t* dwarf2out.h (enum dw_val_class): Add dw_val_class_view_list.\n+\t(struct dw_val_node): Add val_view_list.\n+\t* final.c (SEEN_NEXT_VIEW): New.\n+\t(set_next_view_needed): New.\n+\t(clear_next_view_needed): New.\n+\t(maybe_output_next_view): New.\n+\t(final_start_function): Rename to...\n+\t(final_start_function_1): ... this.  Take pointer to FIRST,\n+\tadd SEEN parameter.  Emit param bindings in the initial view.\n+\t(final_start_function): Reintroduce SEEN-less interface.\n+\t(final): Rename to...\n+\t(final_1): ... this.  Take SEEN parameter.  Output final pending\n+\tnext view at the end.\n+\t(final): Reintroduce seen-less interface.\n+\t(final_scan_insn): Output pending next view before switching\n+\tsections or ending a block.  Mark the next view as needed when\n+\toutputting variable locations.  Notify debug backend of section\n+\tchanges, and of location view changes.\n+\t(rest_of_handle_final): Adjust.\n+\t* toplev.c (process_options): Autodetect value for debug variable\n+\tlocation views option.  Warn on incompat5 without -gdwarf-5.\n+\t* doc/invoke.texi (gvariable-location-views): New.\n+\t(gvariable-location-views=incompat5): New.\n+\t(gno-variable-location-views): New.\n+\n 2018-02-08  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR tree-optimization/84136"}, {"sha": "40ec0088c57eef82ae7cd02423cf0aa311fb3074", "filename": "gcc/common.opt", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3", "patch": "@@ -2956,6 +2956,13 @@ gtoggle\n Common Driver Report Var(flag_gtoggle)\n Toggle debug information generation.\n \n+gvariable-location-views\n+Common Driver Var(debug_variable_location_views, 1) Init(2)\n+Augment variable location lists with progressive views.\n+\n+gvariable-location-views=incompat5\n+Common Driver RejectNegative Var(debug_variable_location_views, -1) Init(2)\n+\n gvms\n Common Driver JoinedOrMissing Negative(gxcoff)\n Generate debug information in VMS format."}, {"sha": "5bccb408016ba05ed002f0ac8ba7b596c45db6c9", "filename": "gcc/config.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3", "patch": "@@ -358,6 +358,12 @@\n #endif\n \n \n+/* Define if your assembler supports views in dwarf2 .loc directives. */\n+#ifndef USED_FOR_TARGET\n+#undef HAVE_AS_DWARF2_DEBUG_VIEW\n+#endif\n+\n+\n /* Define if your assembler supports the R_PPC64_ENTRY relocation. */\n #ifndef USED_FOR_TARGET\n #undef HAVE_AS_ENTRY_MARKERS"}, {"sha": "b12628725b675a898e28e8bfd394a8069ab264e1", "filename": "gcc/configure", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3", "patch": "@@ -27825,6 +27825,52 @@ $as_echo \"$gcc_cv_as_dwarf2_file_buggy\" >&6; }\n \n $as_echo \"#define HAVE_AS_DWARF2_DEBUG_LINE 1\" >>confdefs.h\n \n+\n+    if test $gcc_cv_as_leb128 = yes; then\n+\tconftest_s=\"\\\n+\t.file 1 \\\"conftest.s\\\"\n+\t.loc 1 3 0 view .LVU1\n+\t$insn\n+\t.data\n+\t.uleb128 .LVU1\n+\t.uleb128 .LVU1\n+\"\n+\t{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking assembler for dwarf2 debug_view support\" >&5\n+$as_echo_n \"checking assembler for dwarf2 debug_view support... \" >&6; }\n+if test \"${gcc_cv_as_dwarf2_debug_view+set}\" = set; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  gcc_cv_as_dwarf2_debug_view=no\n+    if test $in_tree_gas = yes; then\n+    if test $in_tree_gas_is_elf = yes \\\n+  && test $gcc_cv_gas_vers -ge `expr \\( \\( 2 \\* 1000 \\) + 27 \\) \\* 1000 + 0`\n+  then gcc_cv_as_dwarf2_debug_view=yes\n+fi\n+  elif test x$gcc_cv_as != x; then\n+    $as_echo \"$conftest_s\" > conftest.s\n+    if { ac_try='$gcc_cv_as $gcc_cv_as_flags  -o conftest.o conftest.s >&5'\n+  { { eval echo \"\\\"\\$as_me\\\":${as_lineno-$LINENO}: \\\"$ac_try\\\"\"; } >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  $as_echo \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n+  test $ac_status = 0; }; }\n+    then\n+\tgcc_cv_as_dwarf2_debug_view=yes\n+    else\n+      echo \"configure: failed program was\" >&5\n+      cat conftest.s >&5\n+    fi\n+    rm -f conftest.o conftest.s\n+  fi\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $gcc_cv_as_dwarf2_debug_view\" >&5\n+$as_echo \"$gcc_cv_as_dwarf2_debug_view\" >&6; }\n+if test $gcc_cv_as_dwarf2_debug_view = yes; then\n+\n+$as_echo \"#define HAVE_AS_DWARF2_DEBUG_VIEW 1\" >>confdefs.h\n+\n+fi\n+    fi\n  fi\n \n  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking assembler for --gdwarf2 option\" >&5"}, {"sha": "140c804412a7a9ab0d4bc397484823206e6c448f", "filename": "gcc/configure.ac", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3", "patch": "@@ -4902,9 +4902,25 @@ if test x\"$insn\" != x; then\n \n  if test $gcc_cv_as_dwarf2_debug_line = yes \\\n  && test $gcc_cv_as_dwarf2_file_buggy = no; then\n-\tAC_DEFINE(HAVE_AS_DWARF2_DEBUG_LINE, 1,\n+    AC_DEFINE(HAVE_AS_DWARF2_DEBUG_LINE, 1,\n   [Define if your assembler supports dwarf2 .file/.loc directives,\n    and preserves file table indices exactly as given.])\n+\n+    if test $gcc_cv_as_leb128 = yes; then\n+\tconftest_s=\"\\\n+\t.file 1 \\\"conftest.s\\\"\n+\t.loc 1 3 0 view .LVU1\n+\t$insn\n+\t.data\n+\t.uleb128 .LVU1\n+\t.uleb128 .LVU1\n+\"\n+\tgcc_GAS_CHECK_FEATURE([dwarf2 debug_view support],\n+\t  gcc_cv_as_dwarf2_debug_view,\n+\t  [elf,2,27,0],,[$conftest_s],,\n+\t  [AC_DEFINE(HAVE_AS_DWARF2_DEBUG_VIEW, 1,\n+  [Define if your assembler supports views in dwarf2 .loc directives.])])\n+    fi\n  fi\n \n  gcc_GAS_CHECK_FEATURE([--gdwarf2 option],"}, {"sha": "df357bea7dc2f8c715edb04177da5174322c5467", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3", "patch": "@@ -348,6 +348,7 @@ Objective-C and Objective-C++ Dialects}.\n -gstabs  -gstabs+  -gstrict-dwarf  -gno-strict-dwarf @gol\n -gcolumn-info  -gno-column-info @gol\n -gstatement-frontiers  -gno-statement-frontiers @gol\n+-gvariable-location-views  -gno-variable-location-views @gol\n -gvms  -gxcoff  -gxcoff+  -gz@r{[}=@var{type}@r{]} @gol\n -fdebug-prefix-map=@var{old}=@var{new}  -fdebug-types-section @gol\n -fno-eliminate-unused-debug-types @gol\n@@ -7255,6 +7256,34 @@ markers in the line number table.  This is enabled by default when\n compiling with optimization (@option{-Os}, @option{-O}, @option{-O2},\n @dots{}), and outputting DWARF 2 debug information at the normal level.\n \n+@item -gvariable-location-views\n+@item -gvariable-location-views=incompat5\n+@item -gno-variable-location-views\n+@opindex gvariable-location-views\n+@opindex gvariable-location-views=incompat5\n+@opindex gno-variable-location-views\n+Augment variable location lists with progressive view numbers implied\n+from the line number table.  This enables debug information consumers to\n+inspect state at certain points of the program, even if no instructions\n+associated with the corresponding source locations are present at that\n+point.  If the assembler lacks support for view numbers in line number\n+tables, this will cause the compiler to emit the line number table,\n+which generally makes them somewhat less compact.  The augmented line\n+number tables and location lists are fully backward-compatible, so they\n+can be consumed by debug information consumers that are not aware of\n+these augmentations, but they won't derive any benefit from them either.\n+This is enabled by default when outputting DWARF 2 debug information at\n+the normal level, as long as @option{-fvar-tracking-assignments} is\n+enabled and @option{-gstrict-dwarf} is not.\n+\n+There is a proposed representation for view numbers that is not backward\n+compatible with the location list format introduced in DWARF 5, that can\n+be enabled with @option{-gvariable-location-views=incompat5}.  This\n+option may be removed in the future, is only provided as a reference\n+implementation of the proposed representation.  Debug information\n+consumers are not expected to support this extended format, and they\n+would be rendered unable to decode location lists using it.\n+\n @item -gz@r{[}=@var{type}@r{]}\n @opindex gz\n Produce compressed debug sections in DWARF format, if that is supported."}, {"sha": "e9b18b8b78520131116ced6d0431db568af1b307", "filename": "gcc/dwarf2asm.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3/gcc%2Fdwarf2asm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3/gcc%2Fdwarf2asm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2asm.c?ref=bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3", "patch": "@@ -767,6 +767,35 @@ dw2_asm_output_data_sleb128 (HOST_WIDE_INT value,\n   va_end (ap);\n }\n \n+/* Output symbol LAB1 as an unsigned LEB128 quantity.  LAB1 should be\n+   an assembler-computed constant, e.g. a view number, because we\n+   can't have relocations in LEB128 quantities.  */\n+\n+void\n+dw2_asm_output_symname_uleb128 (const char *lab1 ATTRIBUTE_UNUSED,\n+\t\t\t\tconst char *comment, ...)\n+{\n+  va_list ap;\n+\n+  va_start (ap, comment);\n+\n+#ifdef HAVE_AS_LEB128\n+  fputs (\"\\t.uleb128 \", asm_out_file);\n+  assemble_name (asm_out_file, lab1);\n+#else\n+  gcc_unreachable ();\n+#endif\n+\n+  if (flag_debug_asm && comment)\n+    {\n+      fprintf (asm_out_file, \"\\t%s \", ASM_COMMENT_START);\n+      vfprintf (asm_out_file, comment, ap);\n+    }\n+  fputc ('\\n', asm_out_file);\n+\n+  va_end (ap);\n+}\n+\n void\n dw2_asm_output_delta_uleb128 (const char *lab1 ATTRIBUTE_UNUSED,\n \t\t\t      const char *lab2 ATTRIBUTE_UNUSED,"}, {"sha": "1b76909a1c91026551193d22a793912d3fcc0080", "filename": "gcc/dwarf2asm.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3/gcc%2Fdwarf2asm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3/gcc%2Fdwarf2asm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2asm.h?ref=bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3", "patch": "@@ -70,6 +70,10 @@ extern void dw2_asm_output_data_sleb128\t(HOST_WIDE_INT,\n \t\t\t\t\t const char *, ...)\n      ATTRIBUTE_NULL_PRINTF_2;\n \n+extern void dw2_asm_output_symname_uleb128 (const char *,\n+\t\t\t\t\t    const char *, ...)\n+     ATTRIBUTE_NULL_PRINTF_2;\n+\n extern void dw2_asm_output_delta_uleb128 (const char *, const char *,\n \t\t\t\t\t  const char *, ...)\n      ATTRIBUTE_NULL_PRINTF_3;"}, {"sha": "56d3e14b81bf1c2cc8d668219c6bd4c3f7c669f3", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 632, "deletions": 68, "changes": 700, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3", "patch": "@@ -1291,6 +1291,8 @@ struct GTY((for_user)) addr_table_entry {\n   GTY ((desc (\"%1.kind\"))) addr;\n };\n \n+typedef unsigned int var_loc_view;\n+\n /* Location lists are ranges + location descriptions for that range,\n    so you can track variables that are in different places over\n    their entire life.  */\n@@ -1300,9 +1302,11 @@ typedef struct GTY(()) dw_loc_list_struct {\n   addr_table_entry *begin_entry;\n   const char *end;  /* Label for end of range */\n   char *ll_symbol; /* Label for beginning of location list.\n-\t\t      Only on head of list */\n+\t\t      Only on head of list.  */\n+  char *vl_symbol; /* Label for beginning of view list.  Ditto.  */\n   const char *section; /* Section this loclist is relative to */\n   dw_loc_descr_ref expr;\n+  var_loc_view vbegin, vend;\n   hashval_t hash;\n   /* True if all addresses in this and subsequent lists are known to be\n      resolved.  */\n@@ -1339,6 +1343,29 @@ dwarf_stack_op_name (unsigned int op)\n   return \"OP_<unknown>\";\n }\n \n+/* Return TRUE iff we're to output location view lists as a separate\n+   attribute next to the location lists, as an extension compatible\n+   with DWARF 2 and above.  */\n+\n+static inline bool\n+dwarf2out_locviews_in_attribute ()\n+{\n+  return debug_variable_location_views == 1;\n+}\n+\n+/* Return TRUE iff we're to output location view lists as part of the\n+   location lists, as proposed for standardization after DWARF 5.  */\n+\n+static inline bool\n+dwarf2out_locviews_in_loclist ()\n+{\n+#ifndef DW_LLE_view_pair\n+  return false;\n+#else\n+  return debug_variable_location_views == -1;\n+#endif\n+}\n+\n /* Return a pointer to a newly allocated location description.  Location\n    descriptions are simple expression terms that can be strung\n    together to form more complicated location (address) descriptions.  */\n@@ -1401,6 +1428,8 @@ dw_val_equal_p (dw_val_node *a, dw_val_node *b)\n       return a->v.val_loc == b->v.val_loc;\n     case dw_val_class_loc_list:\n       return a->v.val_loc_list == b->v.val_loc_list;\n+    case dw_val_class_view_list:\n+      return a->v.val_view_list == b->v.val_view_list;\n     case dw_val_class_die_ref:\n       return a->v.val_die_ref.die == b->v.val_die_ref.die;\n     case dw_val_class_fde_ref:\n@@ -2875,7 +2904,15 @@ enum dw_line_info_opcode {\n   LI_set_epilogue_begin,\n \n   /* Emit a DW_LNE_set_discriminator.  */\n-  LI_set_discriminator\n+  LI_set_discriminator,\n+\n+  /* Output a Fixed Advance PC; the target PC is the label index; the\n+     base PC is the previous LI_adv_address or LI_set_address entry.\n+     We only use this when emitting debug views without assembler\n+     support, at explicit user request.  Ideally, we should only use\n+     it when the offset might be zero but we can't tell: it's the only\n+     way to maybe change the PC without resetting the view number.  */\n+  LI_adv_address\n };\n \n typedef struct GTY(()) dw_line_info_struct {\n@@ -2897,6 +2934,25 @@ struct GTY(()) dw_line_info_table {\n   bool is_stmt;\n   bool in_use;\n \n+  /* This denotes the NEXT view number.\n+\n+     If it is 0, it is known that the NEXT view will be the first view\n+     at the given PC.\n+\n+     If it is -1, we've advanced PC but we haven't emitted a line location yet,\n+     so we shouldn't use this view number.\n+\n+     The meaning of other nonzero values depends on whether we're\n+     computing views internally or leaving it for the assembler to do\n+     so.  If we're emitting them internally, view denotes the view\n+     number since the last known advance of PC.  If we're leaving it\n+     for the assembler, it denotes the LVU label number that we're\n+     going to ask the assembler to assign.  */\n+  var_loc_view view;\n+\n+#define RESET_NEXT_VIEW(x) ((x) = (var_loc_view)0)\n+#define RESETTING_VIEW_P(x) ((x) == (var_loc_view)0)\n+\n   vec<dw_line_info_entry, va_gc> *entries;\n };\n \n@@ -3098,6 +3154,71 @@ skeleton_chain_node;\n #endif\n #endif\n \n+/* Use assembler views in line directives if available.  */\n+#ifndef DWARF2_ASM_VIEW_DEBUG_INFO\n+#ifdef HAVE_AS_DWARF2_DEBUG_VIEW\n+#define DWARF2_ASM_VIEW_DEBUG_INFO 1\n+#else\n+#define DWARF2_ASM_VIEW_DEBUG_INFO 0\n+#endif\n+#endif\n+\n+/* A bit is set in ZERO_VIEW_P if we are using the assembler-supported\n+   view computation, and it refers to a view identifier for which we\n+   will not emit a label because it is known to map to a view number\n+   zero.  We won't allocate the bitmap if we're not using assembler\n+   support for location views, but we have to make the variable\n+   visible for GGC and for code that will be optimized out for lack of\n+   support but that's still parsed and compiled.  We could abstract it\n+   out with macros, but it's not worth it.  */\n+static GTY(()) bitmap zero_view_p;\n+\n+/* Evaluate to TRUE iff N is known to identify the first location view\n+   at its PC.  When not using assembler location view computation,\n+   that must be view number zero.  Otherwise, ZERO_VIEW_P is allocated\n+   and views label numbers recorded in it are the ones known to be\n+   zero.  */\n+#define ZERO_VIEW_P(N) (zero_view_p\t\t\t\t\\\n+\t\t\t? bitmap_bit_p (zero_view_p, (N))\t\\\n+\t\t\t: (N) == 0)\n+\n+/* Return true iff we're to emit .loc directives for the assembler to\n+   generate line number sections.\n+\n+   When we're not emitting views, all we need from the assembler is\n+   support for .loc directives.\n+\n+   If we are emitting views, we can only use the assembler's .loc\n+   support if it also supports views.\n+\n+   When the compiler is emitting the line number programs and\n+   computing view numbers itself, it resets view numbers at known PC\n+   changes and counts from that, and then it emits view numbers as\n+   literal constants in locviewlists.  There are cases in which the\n+   compiler is not sure about PC changes, e.g. when extra alignment is\n+   requested for a label.  In these cases, the compiler may not reset\n+   the view counter, and the potential PC advance in the line number\n+   program will use an opcode that does not reset the view counter\n+   even if the PC actually changes, so that compiler and debug info\n+   consumer can keep view numbers in sync.\n+\n+   When the compiler defers view computation to the assembler, it\n+   emits symbolic view numbers in locviewlists, with the exception of\n+   views known to be zero (forced resets, or reset after\n+   compiler-visible PC changes): instead of emitting symbols for\n+   these, we emit literal zero and assert the assembler agrees with\n+   the compiler's assessment.  We could use symbolic views everywhere,\n+   instead of special-casing zero views, but then we'd be unable to\n+   optimize out locviewlists that contain only zeros.  */\n+\n+static bool\n+output_asm_line_debug_info (void)\n+{\n+  return (DWARF2_ASM_VIEW_DEBUG_INFO\n+\t  || (DWARF2_ASM_LINE_DEBUG_INFO\n+\t      && !debug_variable_location_views));\n+}\n+\n /* Minimum line offset in a special line info. opcode.\n    This value was chosen to give a reasonable range of values.  */\n #define DWARF_LINE_BASE  -10\n@@ -3207,6 +3328,7 @@ struct GTY ((chain_next (\"%h.next\"))) var_loc_node {\n   rtx GTY (()) loc;\n   const char * GTY (()) label;\n   struct var_loc_node * GTY (()) next;\n+  var_loc_view view;\n };\n \n /* Variable location list.  */\n@@ -3415,6 +3537,8 @@ static inline dw_loc_descr_ref AT_loc (dw_attr_node *);\n static void add_AT_loc_list (dw_die_ref, enum dwarf_attribute,\n \t\t\t     dw_loc_list_ref);\n static inline dw_loc_list_ref AT_loc_list (dw_attr_node *);\n+static void add_AT_view_list (dw_die_ref, enum dwarf_attribute);\n+static inline dw_loc_list_ref AT_loc_list (dw_attr_node *);\n static addr_table_entry *add_addr_table_entry (void *, enum ate_kind);\n static void remove_addr_table_entry (addr_table_entry *);\n static void add_AT_addr (dw_die_ref, enum dwarf_attribute, rtx, bool);\n@@ -3451,7 +3575,7 @@ static void equate_type_number_to_die (tree, dw_die_ref);\n static dw_die_ref lookup_decl_die (tree);\n static var_loc_list *lookup_decl_loc (const_tree);\n static void equate_decl_number_to_die (tree, dw_die_ref);\n-static struct var_loc_node *add_var_loc_to_decl (tree, rtx, const char *);\n+static struct var_loc_node *add_var_loc_to_decl (tree, rtx, const char *, var_loc_view);\n static void print_spaces (FILE *);\n static void print_die (dw_die_ref, FILE *);\n static void loc_checksum (dw_loc_descr_ref, struct md5_ctx *);\n@@ -3651,8 +3775,8 @@ static void gen_tagged_type_die (tree, dw_die_ref, enum debug_info_usage);\n static void gen_type_die_with_usage (tree, dw_die_ref, enum debug_info_usage);\n static void splice_child_die (dw_die_ref, dw_die_ref);\n static int file_info_cmp (const void *, const void *);\n-static dw_loc_list_ref new_loc_list (dw_loc_descr_ref, const char *,\n-\t\t\t\t     const char *, const char *);\n+static dw_loc_list_ref new_loc_list (dw_loc_descr_ref, const char *, var_loc_view,\n+\t\t\t\t     const char *, var_loc_view, const char *);\n static void output_loc_list (dw_loc_list_ref);\n static char *gen_internal_sym (const char *);\n static bool want_pubnames (void);\n@@ -4648,11 +4772,65 @@ AT_loc_list (dw_attr_node *a)\n   return a->dw_attr_val.v.val_loc_list;\n }\n \n+/* Add a view list attribute to DIE.  It must have a DW_AT_location\n+   attribute, because the view list complements the location list.  */\n+\n+static inline void\n+add_AT_view_list (dw_die_ref die, enum dwarf_attribute attr_kind)\n+{\n+  dw_attr_node attr;\n+\n+  if (XCOFF_DEBUGGING_INFO && !HAVE_XCOFF_DWARF_EXTRAS)\n+    return;\n+\n+  attr.dw_attr = attr_kind;\n+  attr.dw_attr_val.val_class = dw_val_class_view_list;\n+  attr.dw_attr_val.val_entry = NULL;\n+  attr.dw_attr_val.v.val_view_list = die;\n+  add_dwarf_attr (die, &attr);\n+  gcc_checking_assert (get_AT (die, DW_AT_location));\n+  gcc_assert (have_location_lists);\n+}\n+\n+/* Return a pointer to the location list referenced by the attribute.\n+   If the named attribute is a view list, look up the corresponding\n+   DW_AT_location attribute and return its location list.  */\n+\n static inline dw_loc_list_ref *\n AT_loc_list_ptr (dw_attr_node *a)\n {\n-  gcc_assert (a && AT_class (a) == dw_val_class_loc_list);\n-  return &a->dw_attr_val.v.val_loc_list;\n+  gcc_assert (a);\n+  switch (AT_class (a))\n+    {\n+    case dw_val_class_loc_list:\n+      return &a->dw_attr_val.v.val_loc_list;\n+    case dw_val_class_view_list:\n+      {\n+\tdw_attr_node *l;\n+\tl = get_AT (a->dw_attr_val.v.val_view_list, DW_AT_location);\n+\tif (!l)\n+\t  return NULL;\n+\tgcc_checking_assert (l + 1 == a);\n+\treturn AT_loc_list_ptr (l);\n+      }\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Return the location attribute value associated with a view list\n+   attribute value.  */\n+\n+static inline dw_val_node *\n+view_list_to_loc_list_val_node (dw_val_node *val)\n+{\n+  gcc_assert (val->val_class == dw_val_class_view_list);\n+  dw_attr_node *loc = get_AT (val->v.val_view_list, DW_AT_location);\n+  if (!loc)\n+    return NULL;\n+  gcc_checking_assert (&(loc + 1)->dw_attr_val == val);\n+  gcc_assert (AT_class (loc) == dw_val_class_loc_list);\n+  return &loc->dw_attr_val;\n }\n \n struct addr_hasher : ggc_ptr_hash<addr_table_entry>\n@@ -5907,7 +6085,7 @@ adjust_piece_list (rtx *dest, rtx *src, rtx *inner,\n /* Add a variable location node to the linked list for DECL.  */\n \n static struct var_loc_node *\n-add_var_loc_to_decl (tree decl, rtx loc_note, const char *label)\n+add_var_loc_to_decl (tree decl, rtx loc_note, const char *label, var_loc_view view)\n {\n   unsigned int decl_id;\n   var_loc_list *temp;\n@@ -5996,7 +6174,7 @@ add_var_loc_to_decl (tree decl, rtx loc_note, const char *label)\n       /* TEMP->LAST here is either pointer to the last but one or\n \t last element in the chained list, LAST is pointer to the\n \t last element.  */\n-      if (label && strcmp (last->label, label) == 0)\n+      if (label && strcmp (last->label, label) == 0 && last->view == view)\n \t{\n \t  /* For SRA optimized variables if there weren't any real\n \t     insns since last note, just modify the last node.  */\n@@ -6012,7 +6190,7 @@ add_var_loc_to_decl (tree decl, rtx loc_note, const char *label)\n \t      temp->last->next = NULL;\n \t      unused = last;\n \t      last = temp->last;\n-\t      gcc_assert (strcmp (last->label, label) != 0);\n+\t      gcc_assert (strcmp (last->label, label) != 0 || last->view != view);\n \t    }\n \t  else\n \t    {\n@@ -6147,6 +6325,12 @@ print_dw_val (dw_val_node *val, bool recurse, FILE *outfile)\n       fprintf (outfile, \"location list -> label:%s\",\n \t       val->v.val_loc_list->ll_symbol);\n       break;\n+    case dw_val_class_view_list:\n+      val = view_list_to_loc_list_val_node (val);\n+      fprintf (outfile, \"location list with views -> labels:%s and %s\",\n+\t       val->v.val_loc_list->ll_symbol,\n+\t       val->v.val_loc_list->vl_symbol);\n+      break;\n     case dw_val_class_range_list:\n       fprintf (outfile, \"range list\");\n       break;\n@@ -9007,6 +9191,7 @@ size_of_die (dw_die_ref die)\n \t  }\n \t  break;\n \tcase dw_val_class_loc_list:\n+\tcase dw_val_class_view_list:\n \t  if (dwarf_split_debug_info && dwarf_version >= 5)\n \t    {\n \t      gcc_assert (AT_loc_list (a)->num_assigned);\n@@ -9378,6 +9563,7 @@ value_format (dw_attr_node *a)\n \t  gcc_unreachable ();\n \t}\n     case dw_val_class_loc_list:\n+    case dw_val_class_view_list:\n       if (dwarf_split_debug_info\n \t  && dwarf_version >= 5\n \t  && AT_loc_list (a)->num_assigned)\n@@ -9652,7 +9838,8 @@ output_abbrev_section (void)\n    expression.  */\n \n static inline dw_loc_list_ref\n-new_loc_list (dw_loc_descr_ref expr, const char *begin, const char *end,\n+new_loc_list (dw_loc_descr_ref expr, const char *begin, var_loc_view vbegin,\n+\t      const char *end, var_loc_view vend,\n \t      const char *section)\n {\n   dw_loc_list_ref retlist = ggc_cleared_alloc<dw_loc_list_node> ();\n@@ -9662,10 +9849,28 @@ new_loc_list (dw_loc_descr_ref expr, const char *begin, const char *end,\n   retlist->end = end;\n   retlist->expr = expr;\n   retlist->section = section;\n+  retlist->vbegin = vbegin;\n+  retlist->vend = vend;\n \n   return retlist;\n }\n \n+/* Return true iff there's any nonzero view number in the loc list.  */\n+\n+static bool\n+loc_list_has_views (dw_loc_list_ref list)\n+{\n+  if (!debug_variable_location_views)\n+    return false;\n+\n+  for (dw_loc_list_ref loc = list;\n+       loc != NULL; loc = loc->dw_loc_next)\n+    if (!ZERO_VIEW_P (loc->vbegin) || !ZERO_VIEW_P (loc->vend))\n+      return true;\n+\n+  return false;\n+}\n+\n /* Generate a new internal symbol for this location list node, if it\n    hasn't got one yet.  */\n \n@@ -9674,41 +9879,184 @@ gen_llsym (dw_loc_list_ref list)\n {\n   gcc_assert (!list->ll_symbol);\n   list->ll_symbol = gen_internal_sym (\"LLST\");\n+\n+  if (!loc_list_has_views (list))\n+    return;\n+\n+  if (dwarf2out_locviews_in_attribute ())\n+    {\n+      /* Use the same label_num for the view list.  */\n+      label_num--;\n+      list->vl_symbol = gen_internal_sym (\"LVUS\");\n+    }\n+  else\n+    list->vl_symbol = list->ll_symbol;\n+}\n+\n+/* Generate a symbol for the list, but only if we really want to emit\n+   it as a list.  */\n+\n+static inline void\n+maybe_gen_llsym (dw_loc_list_ref list)\n+{\n+  if (!list || (!list->dw_loc_next && !loc_list_has_views (list)))\n+    return;\n+\n+  gen_llsym (list);\n+}\n+\n+/* Determine whether or not to skip loc_list entry CURR.  If we're not\n+   to skip it, and SIZEP is non-null, store the size of CURR->expr's\n+   representation in *SIZEP.  */\n+\n+static bool\n+skip_loc_list_entry (dw_loc_list_ref curr, unsigned long *sizep = 0)\n+{\n+  /* Don't output an entry that starts and ends at the same address.  */\n+  if (strcmp (curr->begin, curr->end) == 0\n+      && curr->vbegin == curr->vend && !curr->force)\n+    return true;\n+\n+  unsigned long size = size_of_locs (curr->expr);\n+\n+  /* If the expression is too large, drop it on the floor.  We could\n+     perhaps put it into DW_TAG_dwarf_procedure and refer to that\n+     in the expression, but >= 64KB expressions for a single value\n+     in a single range are unlikely very useful.  */\n+  if (dwarf_version < 5 && size > 0xffff)\n+    return true;\n+\n+  if (sizep)\n+    *sizep = size;\n+\n+  return false;\n+}\n+\n+/* Output a view pair loclist entry for CURR, if it requires one.  */\n+\n+static void\n+dwarf2out_maybe_output_loclist_view_pair (dw_loc_list_ref curr)\n+{\n+  if (!dwarf2out_locviews_in_loclist ())\n+    return;\n+\n+  if (ZERO_VIEW_P (curr->vbegin) && ZERO_VIEW_P (curr->vend))\n+    return;\n+\n+#ifdef DW_LLE_view_pair\n+  dw2_asm_output_data (1, DW_LLE_view_pair, \"DW_LLE_view_pair\");\n+\n+# if DWARF2_ASM_VIEW_DEBUG_INFO\n+  if (ZERO_VIEW_P (curr->vbegin))\n+    dw2_asm_output_data_uleb128 (0, \"Location view begin\");\n+  else\n+    {\n+      char label[MAX_ARTIFICIAL_LABEL_BYTES];\n+      ASM_GENERATE_INTERNAL_LABEL (label, \"LVU\", curr->vbegin);\n+      dw2_asm_output_symname_uleb128 (label, \"Location view begin\");\n+    }\n+\n+  if (ZERO_VIEW_P (curr->vend))\n+    dw2_asm_output_data_uleb128 (0, \"Location view end\");\n+  else\n+    {\n+      char label[MAX_ARTIFICIAL_LABEL_BYTES];\n+      ASM_GENERATE_INTERNAL_LABEL (label, \"LVU\", curr->vend);\n+      dw2_asm_output_symname_uleb128 (label, \"Location view end\");\n+    }\n+# else /* !DWARF2_ASM_VIEW_DEBUG_INFO */\n+  dw2_asm_output_data_uleb128 (curr->vbegin, \"Location view begin\");\n+  dw2_asm_output_data_uleb128 (curr->vend, \"Location view end\");\n+# endif /* DWARF2_ASM_VIEW_DEBUG_INFO */\n+#endif /* DW_LLE_view_pair */\n+\n+  return;\n }\n \n /* Output the location list given to us.  */\n \n static void\n output_loc_list (dw_loc_list_ref list_head)\n {\n+  int vcount = 0, lcount = 0;\n+\n   if (list_head->emitted)\n     return;\n   list_head->emitted = true;\n \n+  if (list_head->vl_symbol && dwarf2out_locviews_in_attribute ())\n+    {\n+      ASM_OUTPUT_LABEL (asm_out_file, list_head->vl_symbol);\n+\n+      for (dw_loc_list_ref curr = list_head; curr != NULL;\n+\t   curr = curr->dw_loc_next)\n+\t{\n+\t  if (skip_loc_list_entry (curr))\n+\t    continue;\n+\n+\t  vcount++;\n+\n+\t  /* ?? dwarf_split_debug_info?  */\n+#if DWARF2_ASM_VIEW_DEBUG_INFO\n+\t  char label[MAX_ARTIFICIAL_LABEL_BYTES];\n+\n+\t  if (!ZERO_VIEW_P (curr->vbegin))\n+\t    {\n+\t      ASM_GENERATE_INTERNAL_LABEL (label, \"LVU\", curr->vbegin);\n+\t      dw2_asm_output_symname_uleb128 (label,\n+\t\t\t\t\t      \"View list begin (%s)\",\n+\t\t\t\t\t      list_head->vl_symbol);\n+\t    }\n+\t  else\n+\t    dw2_asm_output_data_uleb128 (0,\n+\t\t\t\t\t \"View list begin (%s)\",\n+\t\t\t\t\t list_head->vl_symbol);\n+\n+\t  if (!ZERO_VIEW_P (curr->vend))\n+\t    {\n+\t      ASM_GENERATE_INTERNAL_LABEL (label, \"LVU\", curr->vend);\n+\t      dw2_asm_output_symname_uleb128 (label,\n+\t\t\t\t\t      \"View list end (%s)\",\n+\t\t\t\t\t      list_head->vl_symbol);\n+\t    }\n+\t  else\n+\t    dw2_asm_output_data_uleb128 (0,\n+\t\t\t\t\t \"View list end (%s)\",\n+\t\t\t\t\t list_head->vl_symbol);\n+#else /* !DWARF2_ASM_VIEW_DEBUG_INFO */\n+\t  dw2_asm_output_data_uleb128 (curr->vbegin,\n+\t\t\t\t       \"View list begin (%s)\",\n+\t\t\t\t       list_head->vl_symbol);\n+\t  dw2_asm_output_data_uleb128 (curr->vend,\n+\t\t\t\t       \"View list end (%s)\",\n+\t\t\t\t       list_head->vl_symbol);\n+#endif\n+\t}\n+    }\n+\n   ASM_OUTPUT_LABEL (asm_out_file, list_head->ll_symbol);\n \n-  dw_loc_list_ref curr = list_head;\n   const char *last_section = NULL;\n   const char *base_label = NULL;\n \n   /* Walk the location list, and output each range + expression.  */\n-  for (curr = list_head; curr != NULL; curr = curr->dw_loc_next)\n+  for (dw_loc_list_ref curr = list_head; curr != NULL;\n+       curr = curr->dw_loc_next)\n     {\n       unsigned long size;\n-      /* Don't output an entry that starts and ends at the same address.  */\n-      if (strcmp (curr->begin, curr->end) == 0 && !curr->force)\n-\tcontinue;\n-      size = size_of_locs (curr->expr);\n-      /* If the expression is too large, drop it on the floor.  We could\n-\t perhaps put it into DW_TAG_dwarf_procedure and refer to that\n-\t in the expression, but >= 64KB expressions for a single value\n-\t in a single range are unlikely very useful.  */\n-      if (dwarf_version < 5 && size > 0xffff)\n+\n+      /* Skip this entry?  If we skip it here, we must skip it in the\n+\t view list above as well. */\n+      if (skip_loc_list_entry (curr, &size))\n \tcontinue;\n+\n+      lcount++;\n+\n       if (dwarf_version >= 5)\n \t{\n \t  if (dwarf_split_debug_info)\n \t    {\n+\t      dwarf2out_maybe_output_loclist_view_pair (curr);\n \t      /* For -gsplit-dwarf, emit DW_LLE_starx_length, which has\n \t\t uleb128 index into .debug_addr and uleb128 length.  */\n \t      dw2_asm_output_data (1, DW_LLE_startx_length,\n@@ -9726,6 +10074,7 @@ output_loc_list (dw_loc_list_ref list_head)\n \t    }\n \t  else if (!have_multiple_function_sections && HAVE_AS_LEB128)\n \t    {\n+\t      dwarf2out_maybe_output_loclist_view_pair (curr);\n \t      /* If all code is in .text section, the base address is\n \t\t already provided by the CU attributes.  Use\n \t\t DW_LLE_offset_pair where both addresses are uleb128 encoded\n@@ -9776,6 +10125,7 @@ output_loc_list (dw_loc_list_ref list_head)\n \t\t length.  */\n \t      if (last_section == NULL)\n \t\t{\n+\t\t  dwarf2out_maybe_output_loclist_view_pair (curr);\n \t\t  dw2_asm_output_data (1, DW_LLE_start_length,\n \t\t\t\t       \"DW_LLE_start_length (%s)\",\n \t\t\t\t       list_head->ll_symbol);\n@@ -9790,6 +10140,7 @@ output_loc_list (dw_loc_list_ref list_head)\n \t\t DW_LLE_base_address.  */\n \t      else\n \t\t{\n+\t\t  dwarf2out_maybe_output_loclist_view_pair (curr);\n \t\t  dw2_asm_output_data (1, DW_LLE_offset_pair,\n \t\t\t\t       \"DW_LLE_offset_pair (%s)\",\n \t\t\t\t       list_head->ll_symbol);\n@@ -9805,6 +10156,7 @@ output_loc_list (dw_loc_list_ref list_head)\n \t     DW_LLE_start_end with a pair of absolute addresses.  */\n \t  else\n \t    {\n+\t      dwarf2out_maybe_output_loclist_view_pair (curr);\n \t      dw2_asm_output_data (1, DW_LLE_start_end,\n \t\t\t\t   \"DW_LLE_start_end (%s)\",\n \t\t\t\t   list_head->ll_symbol);\n@@ -9883,6 +10235,9 @@ output_loc_list (dw_loc_list_ref list_head)\n \t\t\t   \"Location list terminator end (%s)\",\n \t\t\t   list_head->ll_symbol);\n     }\n+\n+  gcc_assert (!list_head->vl_symbol\n+\t      || vcount == lcount * (dwarf2out_locviews_in_attribute () ? 1 : 0));\n }\n \n /* Output a range_list offset into the .debug_ranges or .debug_rnglists\n@@ -9947,6 +10302,22 @@ output_loc_list_offset (dw_attr_node *a)\n \t\t\t  \"%s\", dwarf_attr_name (a->dw_attr));\n }\n \n+/* Output the offset into the debug_loc section.  */\n+\n+static void\n+output_view_list_offset (dw_attr_node *a)\n+{\n+  char *sym = (*AT_loc_list_ptr (a))->vl_symbol;\n+\n+  gcc_assert (sym);\n+  if (dwarf_split_debug_info)\n+    dw2_asm_output_delta (DWARF_OFFSET_SIZE, sym, loc_section_label,\n+                          \"%s\", dwarf_attr_name (a->dw_attr));\n+  else\n+    dw2_asm_output_offset (DWARF_OFFSET_SIZE, sym, debug_loc_section,\n+                           \"%s\", dwarf_attr_name (a->dw_attr));\n+}\n+\n /* Output an attribute's index or value appropriately.  */\n \n static void\n@@ -10172,6 +10543,10 @@ output_die (dw_die_ref die)\n \t  output_loc_list_offset (a);\n \t  break;\n \n+\tcase dw_val_class_view_list:\n+\t  output_view_list_offset (a);\n+\t  break;\n+\n \tcase dw_val_class_die_ref:\n \t  if (AT_ref_external (a))\n \t    {\n@@ -10356,6 +10731,28 @@ output_die (dw_die_ref die)\n \t\t\t (unsigned long) die->die_offset);\n }\n \n+/* Output the dwarf version number.  */\n+\n+static void\n+output_dwarf_version ()\n+{\n+  /* ??? For now, if -gdwarf-6 is specified, we output version 5 with\n+     views in loclist.  That will change eventually.  */\n+  if (dwarf_version == 6)\n+    {\n+      static bool once;\n+      if (!once)\n+\t{\n+\t  warning (0,\n+\t\t   \"-gdwarf-6 is output as version 5 with incompatibilities\");\n+\t  once = true;\n+\t}\n+      dw2_asm_output_data (2, 5, \"DWARF version number\");\n+    }\n+  else\n+    dw2_asm_output_data (2, dwarf_version, \"DWARF version number\");\n+}\n+\n /* Output the compilation unit that appears at the beginning of the\n    .debug_info section, and precedes the DIE descriptions.  */\n \n@@ -10372,7 +10769,7 @@ output_compilation_unit_header (enum dwarf_unit_type ut)\n \t\t\t   \"Length of Compilation Unit Info\");\n     }\n \n-  dw2_asm_output_data (2, dwarf_version, \"DWARF version number\");\n+  output_dwarf_version ();\n   if (dwarf_version >= 5)\n     {\n       const char *name;\n@@ -10584,7 +10981,7 @@ output_skeleton_debug_sections (dw_die_ref comp_unit,\n                        - DWARF_INITIAL_LENGTH_SIZE\n                        + size_of_die (comp_unit),\n                       \"Length of Compilation Unit Info\");\n-  dw2_asm_output_data (2, dwarf_version, \"DWARF version number\");\n+  output_dwarf_version ();\n   if (dwarf_version >= 5)\n     {\n       dw2_asm_output_data (1, DW_UT_skeleton, \"DW_UT_skeleton\");\n@@ -10883,7 +11280,7 @@ output_pubnames (vec<pubname_entry, va_gc> *names)\n     }\n \n   /* Version number for pubnames/pubtypes is independent of dwarf version.  */\n-  dw2_asm_output_data (2, 2, \"DWARF Version\");\n+  dw2_asm_output_data (2, 2, \"DWARF pubnames/pubtypes version\");\n \n   if (dwarf_split_debug_info)\n     dw2_asm_output_offset (DWARF_OFFSET_SIZE, debug_skeleton_info_section_label,\n@@ -10965,7 +11362,7 @@ output_aranges (void)\n     }\n \n   /* Version number for aranges is still 2, even up to DWARF5.  */\n-  dw2_asm_output_data (2, 2, \"DWARF Version\");\n+  dw2_asm_output_data (2, 2, \"DWARF aranges version\");\n   if (dwarf_split_debug_info)\n     dw2_asm_output_offset (DWARF_OFFSET_SIZE, debug_skeleton_info_section_label,\n                            debug_skeleton_info_section,\n@@ -11230,7 +11627,7 @@ output_rnglists (unsigned generation)\n   dw2_asm_output_delta (DWARF_OFFSET_SIZE, l2, l1,\n \t\t\t\"Length of Range Lists\");\n   ASM_OUTPUT_LABEL (asm_out_file, l1);\n-  dw2_asm_output_data (2, dwarf_version, \"DWARF Version\");\n+  output_dwarf_version ();\n   dw2_asm_output_data (1, DWARF2_ADDR_SIZE, \"Address Size\");\n   dw2_asm_output_data (1, 0, \"Segment Size\");\n   /* Emit the offset table only for -gsplit-dwarf.  If we don't care\n@@ -11864,8 +12261,11 @@ output_one_line_info_table (dw_line_info_table *table)\n   char line_label[MAX_ARTIFICIAL_LABEL_BYTES];\n   unsigned int current_line = 1;\n   bool current_is_stmt = DWARF_LINE_DEFAULT_IS_STMT_START;\n-  dw_line_info_entry *ent;\n+  dw_line_info_entry *ent, *prev_addr;\n   size_t i;\n+  unsigned int view;\n+\n+  view = 0;\n \n   FOR_EACH_VEC_SAFE_ELT (table->entries, i, ent)\n     {\n@@ -11880,14 +12280,36 @@ output_one_line_info_table (dw_line_info_table *table)\n \t     to determine when it is safe to use DW_LNS_fixed_advance_pc.  */\n \t  ASM_GENERATE_INTERNAL_LABEL (line_label, LINE_CODE_LABEL, ent->val);\n \n+\t  view = 0;\n+\n \t  /* This can handle any delta.  This takes\n \t     4+DWARF2_ADDR_SIZE bytes.  */\n-\t  dw2_asm_output_data (1, 0, \"set address %s\", line_label);\n+\t  dw2_asm_output_data (1, 0, \"set address %s%s\", line_label,\n+\t\t\t       debug_variable_location_views\n+\t\t\t       ? \", reset view to 0\" : \"\");\n \t  dw2_asm_output_data_uleb128 (1 + DWARF2_ADDR_SIZE, NULL);\n \t  dw2_asm_output_data (1, DW_LNE_set_address, NULL);\n \t  dw2_asm_output_addr (DWARF2_ADDR_SIZE, line_label, NULL);\n+\n+\t  prev_addr = ent;\n \t  break;\n \n+\tcase LI_adv_address:\n+\t  {\n+\t    ASM_GENERATE_INTERNAL_LABEL (line_label, LINE_CODE_LABEL, ent->val);\n+\t    char prev_label[MAX_ARTIFICIAL_LABEL_BYTES];\n+\t    ASM_GENERATE_INTERNAL_LABEL (prev_label, LINE_CODE_LABEL, prev_addr->val);\n+\n+\t    view++;\n+\n+\t    dw2_asm_output_data (1, DW_LNS_fixed_advance_pc, \"fixed advance PC, increment view to %i\", view);\n+\t    dw2_asm_output_delta (2, line_label, prev_label,\n+\t\t\t\t  \"from %s to %s\", prev_label, line_label);\n+\n+\t    prev_addr = ent;\n+\t    break;\n+\t  }\n+\n \tcase LI_set_line:\n \t  if (ent->val == current_line)\n \t    {\n@@ -11995,7 +12417,7 @@ output_line_info (bool prologue_only)\n \n   ASM_OUTPUT_LABEL (asm_out_file, l1);\n \n-  dw2_asm_output_data (2, dwarf_version, \"DWARF Version\");\n+  output_dwarf_version ();\n   if (dwarf_version >= 5)\n     {\n       dw2_asm_output_data (1, DWARF2_ADDR_SIZE, \"Address Size\");\n@@ -16453,6 +16875,7 @@ static dw_loc_list_ref\n dw_loc_list (var_loc_list *loc_list, tree decl, int want_address)\n {\n   const char *endname, *secname;\n+  var_loc_view endview;\n   rtx varloc;\n   enum var_init_status initialized;\n   struct var_loc_node *node;\n@@ -16517,24 +16940,27 @@ dw_loc_list (var_loc_list *loc_list, tree decl, int want_address)\n \t\t  && current_function_decl)\n \t\t{\n \t\t  endname = cfun->fde->dw_fde_end;\n+\t\t  endview = 0;\n \t\t  range_across_switch = true;\n \t\t}\n \t      /* The variable has a location between NODE->LABEL and\n \t\t NODE->NEXT->LABEL.  */\n \t      else if (node->next)\n-\t\tendname = node->next->label;\n+\t\tendname = node->next->label, endview = node->next->view;\n \t      /* If the variable has a location at the last label\n \t\t it keeps its location until the end of function.  */\n \t      else if (!current_function_decl)\n-\t\tendname = text_end_label;\n+\t\tendname = text_end_label, endview = 0;\n \t      else\n \t\t{\n \t\t  ASM_GENERATE_INTERNAL_LABEL (label_id, FUNC_END_LABEL,\n \t\t\t\t\t       current_function_funcdef_no);\n \t\t  endname = ggc_strdup (label_id);\n+\t\t  endview = 0;\n \t\t}\n \n-\t      *listp = new_loc_list (descr, node->label, endname, secname);\n+\t      *listp = new_loc_list (descr, node->label, node->view,\n+\t\t\t\t     endname, endview, secname);\n \t      if (TREE_CODE (decl) == PARM_DECL\n \t\t  && node == loc_list->first\n \t\t  && NOTE_P (node->loc)\n@@ -16569,11 +16995,11 @@ dw_loc_list (var_loc_list *loc_list, tree decl, int want_address)\n \t  /* The variable has a location between NODE->LABEL and\n \t     NODE->NEXT->LABEL.  */\n \t  if (node->next)\n-\t    endname = node->next->label;\n+\t    endname = node->next->label, endview = node->next->view;\n \t  else\n-\t    endname = cfun->fde->dw_fde_second_end;\n-\t  *listp = new_loc_list (descr, cfun->fde->dw_fde_second_begin,\n-\t\t\t\t endname, secname);\n+\t    endname = cfun->fde->dw_fde_second_end, endview = 0;\n+\t  *listp = new_loc_list (descr, cfun->fde->dw_fde_second_begin, 0,\n+\t\t\t\t endname, endview, secname);\n \t  listp = &(*listp)->dw_loc_next;\n \t}\n     }\n@@ -16584,8 +17010,7 @@ dw_loc_list (var_loc_list *loc_list, tree decl, int want_address)\n      representable, we don't want to pretend a single entry that was\n      applies to the entire scope in which the variable is\n      available.  */\n-  if (list && loc_list->first->next)\n-    gen_llsym (list);\n+  maybe_gen_llsym (list);\n \n   return list;\n }\n@@ -17404,7 +17829,7 @@ loc_list_from_tree_1 (tree loc, int want_address,\n     {\n       if (dwarf_version >= 3 || !dwarf_strict)\n \treturn new_loc_list (new_loc_descr (DW_OP_push_object_address, 0, 0),\n-\t\t\t     NULL, NULL, NULL);\n+\t\t\t     NULL, 0, NULL, 0, NULL);\n       else\n \treturn NULL;\n     }\n@@ -18220,7 +18645,7 @@ loc_list_from_tree_1 (tree loc, int want_address,\n \tadd_loc_descr_to_each (list_ret, new_loc_descr (op, size, 0));\n     }\n   if (ret)\n-    list_ret = new_loc_list (ret, NULL, NULL, NULL);\n+    list_ret = new_loc_list (ret, NULL, 0, NULL, 0, NULL);\n \n   return list_ret;\n }\n@@ -18544,12 +18969,25 @@ static inline void\n add_AT_location_description (dw_die_ref die, enum dwarf_attribute attr_kind,\n \t\t\t     dw_loc_list_ref descr)\n {\n+  bool check_no_locviews = true;\n   if (descr == 0)\n     return;\n   if (single_element_loc_list_p (descr))\n     add_AT_loc (die, attr_kind, descr->expr);\n   else\n-    add_AT_loc_list (die, attr_kind, descr);\n+    {\n+      add_AT_loc_list (die, attr_kind, descr);\n+      gcc_assert (descr->ll_symbol);\n+      if (attr_kind == DW_AT_location && descr->vl_symbol\n+\t  && dwarf2out_locviews_in_attribute ())\n+\t{\n+\t  add_AT_view_list (die, DW_AT_GNU_locviews);\n+\t  check_no_locviews = false;\n+\t}\n+    }\n+\n+  if (check_no_locviews)\n+    gcc_assert (!get_AT (die, DW_AT_GNU_locviews));\n }\n \n /* Add DW_AT_accessibility attribute to DIE if needed.  */\n@@ -19738,7 +20176,7 @@ convert_cfa_to_fb_loc_list (HOST_WIDE_INT offset)\n       /* If the first partition contained no CFI adjustments, the\n \t CIE opcodes apply to the whole first partition.  */\n       *list_tail = new_loc_list (build_cfa_loc (&last_cfa, offset),\n-\t\t\t\t fde->dw_fde_begin, fde->dw_fde_end, section);\n+\t\t\t\t fde->dw_fde_begin, 0, fde->dw_fde_end, 0, section);\n       list_tail =&(*list_tail)->dw_loc_next;\n       start_label = last_label = fde->dw_fde_second_begin;\n     }\n@@ -19754,7 +20192,7 @@ convert_cfa_to_fb_loc_list (HOST_WIDE_INT offset)\n \t  if (!cfa_equal_p (&last_cfa, &next_cfa))\n \t    {\n \t      *list_tail = new_loc_list (build_cfa_loc (&last_cfa, offset),\n-\t\t\t\t\t start_label, last_label, section);\n+\t\t\t\t\t start_label, 0, last_label, 0, section);\n \n \t      list_tail = &(*list_tail)->dw_loc_next;\n \t      last_cfa = next_cfa;\n@@ -19776,14 +20214,14 @@ convert_cfa_to_fb_loc_list (HOST_WIDE_INT offset)\n \t  if (!cfa_equal_p (&last_cfa, &next_cfa))\n \t    {\n \t      *list_tail = new_loc_list (build_cfa_loc (&last_cfa, offset),\n-\t\t\t\t\t start_label, last_label, section);\n+\t\t\t\t\t start_label, 0, last_label, 0, section);\n \n \t      list_tail = &(*list_tail)->dw_loc_next;\n \t      last_cfa = next_cfa;\n \t      start_label = last_label;\n \t    }\n \t  *list_tail = new_loc_list (build_cfa_loc (&last_cfa, offset),\n-\t\t\t\t     start_label, fde->dw_fde_end, section);\n+\t\t\t\t     start_label, 0, fde->dw_fde_end, 0, section);\n \t  list_tail = &(*list_tail)->dw_loc_next;\n \t  start_label = last_label = fde->dw_fde_second_begin;\n \t}\n@@ -19792,19 +20230,18 @@ convert_cfa_to_fb_loc_list (HOST_WIDE_INT offset)\n   if (!cfa_equal_p (&last_cfa, &next_cfa))\n     {\n       *list_tail = new_loc_list (build_cfa_loc (&last_cfa, offset),\n-\t\t\t\t start_label, last_label, section);\n+\t\t\t\t start_label, 0, last_label, 0, section);\n       list_tail = &(*list_tail)->dw_loc_next;\n       start_label = last_label;\n     }\n \n   *list_tail = new_loc_list (build_cfa_loc (&next_cfa, offset),\n-\t\t\t     start_label,\n+\t\t\t     start_label, 0,\n \t\t\t     fde->dw_fde_second_begin\n-\t\t\t     ? fde->dw_fde_second_end : fde->dw_fde_end,\n+\t\t\t     ? fde->dw_fde_second_end : fde->dw_fde_end, 0,\n \t\t\t     section);\n \n-  if (list && list->dw_loc_next)\n-    gen_llsym (list);\n+  maybe_gen_llsym (list);\n \n   return list;\n }\n@@ -26164,7 +26601,7 @@ maybe_emit_file (struct dwarf_file_data * fd)\n \tfd->emitted_number = 1;\n       last_emitted_file = fd;\n \n-      if (DWARF2_ASM_LINE_DEBUG_INFO)\n+      if (output_asm_line_debug_info ())\n \t{\n \t  fprintf (asm_out_file, \"\\t.file %u \", fd->emitted_number);\n \t  output_quoted_string (asm_out_file,\n@@ -26358,11 +26795,13 @@ dwarf2out_var_location (rtx_insn *loc_note)\n   static rtx_insn *expected_next_loc_note;\n   tree decl;\n   bool var_loc_p;\n+  var_loc_view view = 0;\n \n   if (!NOTE_P (loc_note))\n     {\n       if (CALL_P (loc_note))\n \t{\n+\t  RESET_NEXT_VIEW (cur_line_info_table->view);\n \t  call_site_count++;\n \t  if (SIBLING_CALL_P (loc_note))\n \t    tail_call_site_count++;\n@@ -26396,6 +26835,18 @@ dwarf2out_var_location (rtx_insn *loc_note)\n \t\t}\n \t    }\n \t}\n+      else if (!debug_variable_location_views)\n+\tgcc_unreachable ();\n+      else if (JUMP_TABLE_DATA_P (loc_note))\n+\tRESET_NEXT_VIEW (cur_line_info_table->view);\n+      else if (GET_CODE (loc_note) == USE\n+\t       || GET_CODE (loc_note) == CLOBBER\n+\t       || GET_CODE (loc_note) == ASM_INPUT\n+\t       || asm_noperands (loc_note) >= 0)\n+\t;\n+      else if (get_attr_min_length (loc_note) > 0)\n+\tRESET_NEXT_VIEW (cur_line_info_table->view);\n+\n       return;\n     }\n \n@@ -26459,10 +26910,11 @@ dwarf2out_var_location (rtx_insn *loc_note)\n \n   if (var_loc_p)\n     {\n+      const char *label\n+\t= NOTE_DURING_CALL_P (loc_note) ? last_postcall_label : last_label;\n+      view = cur_line_info_table->view;\n       decl = NOTE_VAR_LOCATION_DECL (loc_note);\n-      newloc = add_var_loc_to_decl (decl, loc_note,\n-\t\t\t\t    NOTE_DURING_CALL_P (loc_note)\n-\t\t\t\t    ? last_postcall_label : last_label);\n+      newloc = add_var_loc_to_decl (decl, loc_note, label, view);\n       if (newloc == NULL)\n \treturn;\n     }\n@@ -26503,8 +26955,8 @@ dwarf2out_var_location (rtx_insn *loc_note)\n \t\telse if (GET_CODE (body) == ASM_INPUT\n \t\t\t || asm_noperands (body) >= 0)\n \t\t  continue;\n-#ifdef HAVE_attr_length\n-\t\telse if (get_attr_min_length (insn) == 0)\n+#ifdef HAVE_ATTR_length /* ??? We don't include insn-attr.h.  */\n+\t\telse if (HAVE_ATTR_length && get_attr_min_length (insn) == 0)\n \t\t  continue;\n #endif\n \t\telse\n@@ -26572,7 +27024,10 @@ dwarf2out_var_location (rtx_insn *loc_note)\n       call_arg_loc_last = ca_loc;\n     }\n   else if (loc_note != NULL_RTX && !NOTE_DURING_CALL_P (loc_note))\n-    newloc->label = last_label;\n+    {\n+      newloc->label = last_label;\n+      newloc->view = view;\n+    }\n   else\n     {\n       if (!last_postcall_label)\n@@ -26581,6 +27036,7 @@ dwarf2out_var_location (rtx_insn *loc_note)\n \t  last_postcall_label = ggc_strdup (loclabel);\n \t}\n       newloc->label = last_postcall_label;\n+      newloc->view = view;\n     }\n \n   if (var_loc_p && flag_debug_asm)\n@@ -26652,6 +27108,7 @@ new_line_info_table (void)\n   table->file_num = 1;\n   table->line_num = 1;\n   table->is_stmt = DWARF_LINE_DEFAULT_IS_STMT_START;\n+  RESET_NEXT_VIEW (table->view);\n \n   return table;\n }\n@@ -26700,7 +27157,7 @@ set_cur_line_info_table (section *sec)\n       vec_safe_push (separate_line_info, table);\n     }\n \n-  if (DWARF2_ASM_LINE_DEBUG_INFO)\n+  if (output_asm_line_debug_info ())\n     table->is_stmt = (cur_line_info_table\n \t\t      ? cur_line_info_table->is_stmt\n \t\t      : DWARF_LINE_DEFAULT_IS_STMT_START);\n@@ -26881,7 +27338,7 @@ dwarf2out_source_line (unsigned int line, unsigned int column,\n \t\t filename, line);\n     }\n \n-  if (DWARF2_ASM_LINE_DEBUG_INFO)\n+  if (output_asm_line_debug_info ())\n     {\n       /* Emit the .loc directive understood by GNU as.  */\n       /* \"\\t.loc %u %u 0 is_stmt %u discriminator %u\",\n@@ -26904,6 +27361,50 @@ dwarf2out_source_line (unsigned int line, unsigned int column,\n \t  fputs (\" discriminator \", asm_out_file);\n \t  fprint_ul (asm_out_file, (unsigned long) discriminator);\n \t}\n+      if (debug_variable_location_views)\n+\t{\n+\t  static var_loc_view lvugid;\n+\t  if (!lvugid)\n+\t    {\n+\t      gcc_assert (!zero_view_p);\n+\t      zero_view_p = BITMAP_GGC_ALLOC ();\n+\t      bitmap_set_bit (zero_view_p, 0);\n+\t    }\n+\t  if (!RESETTING_VIEW_P (table->view))\n+\t    {\n+\t      /* When we're using the assembler to compute view\n+\t\t numbers, we output symbolic labels after \"view\" in\n+\t\t .loc directives, and the assembler will set them for\n+\t\t us, so that we can refer to the view numbers in\n+\t\t location lists.  The only exceptions are when we know\n+\t\t a view will be zero: \"-0\" is a forced reset, used\n+\t\t e.g. in the beginning of functions, whereas \"0\" tells\n+\t\t the assembler to check that there was a PC change\n+\t\t since the previous view, in a way that implicitly\n+\t\t resets the next view.  */\n+\t      fputs (\" view \", asm_out_file);\n+\t      char label[MAX_ARTIFICIAL_LABEL_BYTES];\n+\t      ASM_GENERATE_INTERNAL_LABEL (label, \"LVU\", table->view);\n+\t      assemble_name (asm_out_file, label);\n+\t      table->view = ++lvugid;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (!table->in_use)\n+\t\tfputs (\" view -0\", asm_out_file);\n+\t      else\n+\t\tfputs (\" view 0\", asm_out_file);\n+\t      /* Mark the present view as a zero view.  Earlier debug\n+\t\t binds may have already added its id to loclists to be\n+\t\t emitted later, so we can't reuse the id for something\n+\t\t else.  However, it's good to know whether a view is\n+\t\t known to be zero, because then we may be able to\n+\t\t optimize out locviews that are all zeros, so take\n+\t\t note of it in zero_view_p.  */\n+\t      bitmap_set_bit (zero_view_p, lvugid);\n+\t      table->view = ++lvugid;\n+\t    }\n+\t}\n       putc ('\\n', asm_out_file);\n     }\n   else\n@@ -26912,7 +27413,19 @@ dwarf2out_source_line (unsigned int line, unsigned int column,\n \n       targetm.asm_out.internal_label (asm_out_file, LINE_CODE_LABEL, label_num);\n \n-      push_dw_line_info_entry (table, LI_set_address, label_num);\n+      if (debug_variable_location_views && table->view)\n+\tpush_dw_line_info_entry (table, LI_adv_address, label_num);\n+      else\n+\tpush_dw_line_info_entry (table, LI_set_address, label_num);\n+      if (debug_variable_location_views)\n+\t{\n+\t  if (flag_debug_asm)\n+\t    fprintf (asm_out_file, \"\\t%s view %s%d\\n\",\n+\t\t     ASM_COMMENT_START,\n+\t\t     table->in_use ? \"\" : \"-\",\n+\t\t     table->view);\n+\t  table->view++;\n+\t}\n       if (file_num != table->file_num)\n \tpush_dw_line_info_entry (table, LI_set_file, file_num);\n       if (discriminator != table->discrim_num)\n@@ -27588,9 +28101,10 @@ init_sections_and_labels (bool early_lto_debug)\n \t\t\t\t\t    SECTION_DEBUG, NULL);\n       debug_str_section = get_section (DEBUG_STR_SECTION,\n \t\t\t\t       DEBUG_STR_SECTION_FLAGS, NULL);\n-      if (!dwarf_split_debug_info && !DWARF2_ASM_LINE_DEBUG_INFO)\n+      if (!dwarf_split_debug_info && !output_asm_line_debug_info ())\n \tdebug_line_str_section = get_section (DEBUG_LINE_STR_SECTION,\n \t\t\t\t\t      DEBUG_STR_SECTION_FLAGS, NULL);\n+\n       debug_ranges_section = get_section (dwarf_version >= 5\n \t\t\t\t\t  ? DEBUG_RNGLISTS_SECTION\n \t\t\t\t\t  : DEBUG_RANGES_SECTION,\n@@ -27976,6 +28490,11 @@ prune_unused_types_walk_attribs (dw_die_ref die)\n \t    prune_unused_types_walk_loc_descr (list->expr);\n \t  break;\n \n+\tcase dw_val_class_view_list:\n+\t  /* This points to a loc_list in another attribute, so it's\n+\t     already covered.  */\n+\t  break;\n+\n \tcase dw_val_class_die_ref:\n \t  /* A reference to another DIE.\n \t     Make sure that it will get emitted.\n@@ -29075,6 +29594,8 @@ optimize_string_length (dw_attr_node *a)\n \tif (d->expr && non_dwarf_expression (d->expr))\n \t  non_dwarf_expr = true;\n       break;\n+    case dw_val_class_view_list:\n+      gcc_unreachable ();\n     case dw_val_class_loc:\n       lv = AT_loc (av);\n       if (lv == NULL)\n@@ -29119,7 +29640,7 @@ optimize_string_length (dw_attr_node *a)\n \t  lv = copy_deref_exprloc (d->expr);\n \t  if (lv)\n \t    {\n-\t      *p = new_loc_list (lv, d->begin, d->end, d->section);\n+\t      *p = new_loc_list (lv, d->begin, d->vbegin, d->end, d->vend, d->section);\n \t      p = &(*p)->dw_loc_next;\n \t    }\n \t  else if (!dwarf_strict && d->expr)\n@@ -29189,6 +29710,7 @@ resolve_addr (dw_die_ref die)\n \t\t      {\n \t\t\tgcc_assert (!next->ll_symbol);\n \t\t\tnext->ll_symbol = (*curr)->ll_symbol;\n+\t\t\tnext->vl_symbol = (*curr)->vl_symbol;\n \t\t      }\n                     if (dwarf_split_debug_info)\n                       remove_loc_list_addr_table_entries (l);\n@@ -29214,6 +29736,21 @@ resolve_addr (dw_die_ref die)\n \t    ix--;\n \t  }\n \tbreak;\n+      case dw_val_class_view_list:\n+\t{\n+\t  gcc_checking_assert (a->dw_attr == DW_AT_GNU_locviews);\n+\t  gcc_checking_assert (dwarf2out_locviews_in_attribute ());\n+\t  dw_val_node *llnode\n+\t    = view_list_to_loc_list_val_node (&a->dw_attr_val);\n+\t  /* If we no longer have a loclist, or it no longer needs\n+\t     views, drop this attribute.  */\n+\t  if (!llnode || !llnode->v.val_loc_list->vl_symbol)\n+\t    {\n+\t      remove_AT (die, a->dw_attr);\n+\t      ix--;\n+\t    }\n+\t  break;\n+\t}\n       case dw_val_class_loc:\n \t{\n \t  dw_loc_descr_ref l = AT_loc (a);\n@@ -29610,6 +30147,8 @@ hash_loc_list (dw_loc_list_ref list_head)\n     {\n       hstate.add (curr->begin, strlen (curr->begin) + 1);\n       hstate.add (curr->end, strlen (curr->end) + 1);\n+      hstate.add_object (curr->vbegin);\n+      hstate.add_object (curr->vend);\n       if (curr->section)\n \thstate.add (curr->section, strlen (curr->section) + 1);\n       hash_locs (curr->expr, hstate);\n@@ -29831,6 +30370,7 @@ loc_list_hasher::equal (const dw_loc_list_struct *a,\n \t|| strcmp (a->end, b->end) != 0\n \t|| (a->section == NULL) != (b->section == NULL)\n \t|| (a->section && strcmp (a->section, b->section) != 0)\n+\t|| a->vbegin != b->vbegin || a->vend != b->vend\n \t|| !compare_locs (a->expr, b->expr))\n       break;\n   return a == NULL && b == NULL;\n@@ -29849,6 +30389,8 @@ optimize_location_lists_1 (dw_die_ref die, loc_list_hash_type *htab)\n   dw_attr_node *a;\n   unsigned ix;\n   dw_loc_list_struct **slot;\n+  bool drop_locviews = false;\n+  bool has_locviews = false;\n \n   FOR_EACH_VEC_SAFE_ELT (die->die_attr, ix, a)\n     if (AT_class (a) == dw_val_class_loc_list)\n@@ -29859,11 +30401,33 @@ optimize_location_lists_1 (dw_die_ref die, loc_list_hash_type *htab)\n \thash_loc_list (list);\n \tslot = htab->find_slot_with_hash (list, list->hash, INSERT);\n \tif (*slot == NULL)\n-\t  *slot = list;\n+\t  {\n+\t    *slot = list;\n+\t    if (loc_list_has_views (list))\n+\t      gcc_assert (list->vl_symbol);\n+\t    else if (list->vl_symbol)\n+\t      {\n+\t\tdrop_locviews = true;\n+\t\tlist->vl_symbol = NULL;\n+\t      }\n+\t  }\n \telse\n-          a->dw_attr_val.v.val_loc_list = *slot;\n+\t  {\n+\t    if (list->vl_symbol && !(*slot)->vl_symbol)\n+\t      drop_locviews = true;\n+\t    a->dw_attr_val.v.val_loc_list = *slot;\n+\t  }\n+      }\n+    else if (AT_class (a) == dw_val_class_view_list)\n+      {\n+\tgcc_checking_assert (a->dw_attr == DW_AT_GNU_locviews);\n+\thas_locviews = true;\n       }\n \n+\n+  if (drop_locviews && has_locviews)\n+    remove_AT (die, DW_AT_GNU_locviews);\n+\n   FOR_EACH_CHILD (die, c, optimize_location_lists_1 (c, htab));\n }\n \n@@ -29888,7 +30452,7 @@ index_location_lists (dw_die_ref die)\n             /* Don't index an entry that has already been indexed\n                or won't be output.  */\n             if (curr->begin_entry != NULL\n-                || (strcmp (curr->begin, curr->end) == 0 && !curr->force))\n+                || skip_loc_list_entry (curr))\n               continue;\n \n             curr->begin_entry\n@@ -30312,7 +30876,7 @@ dwarf2out_finish (const char *)\n \t  dw2_asm_output_delta (DWARF_OFFSET_SIZE, l2, l1,\n \t\t\t    \"Length of Location Lists\");\n \t  ASM_OUTPUT_LABEL (asm_out_file, l1);\n-\t  dw2_asm_output_data (2, dwarf_version, \"DWARF Version\");\n+\t  output_dwarf_version ();\n \t  dw2_asm_output_data (1, DWARF2_ADDR_SIZE, \"Address Size\");\n \t  dw2_asm_output_data (1, 0, \"Segment Size\");\n \t  dw2_asm_output_data (4, dwarf_split_debug_info ? loc_list_idx : 0,\n@@ -30371,7 +30935,7 @@ dwarf2out_finish (const char *)\n      used by the debug_info section are marked as 'used'.  */\n   switch_to_section (debug_line_section);\n   ASM_OUTPUT_LABEL (asm_out_file, debug_line_section_label);\n-  if (! DWARF2_ASM_LINE_DEBUG_INFO)\n+  if (! output_asm_line_debug_info ())\n     output_line_info (false);\n \n   if (dwarf_split_debug_info && info_section_emitted)"}, {"sha": "a1856a5185e22bc0177c6f8770ba1bf358b4868b", "filename": "gcc/dwarf2out.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3/gcc%2Fdwarf2out.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3/gcc%2Fdwarf2out.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.h?ref=bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3", "patch": "@@ -160,7 +160,8 @@ enum dw_val_class\n   dw_val_class_discr_list,\n   dw_val_class_const_implicit,\n   dw_val_class_unsigned_const_implicit,\n-  dw_val_class_file_implicit\n+  dw_val_class_file_implicit,\n+  dw_val_class_view_list\n };\n \n /* Describe a floating point constant value, or a vector constant value.  */\n@@ -203,6 +204,7 @@ struct GTY(()) dw_val_node {\n       rtx GTY ((tag (\"dw_val_class_addr\"))) val_addr;\n       unsigned HOST_WIDE_INT GTY ((tag (\"dw_val_class_offset\"))) val_offset;\n       dw_loc_list_ref GTY ((tag (\"dw_val_class_loc_list\"))) val_loc_list;\n+      dw_die_ref GTY ((tag (\"dw_val_class_view_list\"))) val_view_list;\n       dw_loc_descr_ref GTY ((tag (\"dw_val_class_loc\"))) val_loc;\n       HOST_WIDE_INT GTY ((default)) val_int;\n       unsigned HOST_WIDE_INT"}, {"sha": "68397b3ded36acdcaf822e1e6a922f64f9451d18", "filename": "gcc/final.c", "status": "modified", "additions": 138, "deletions": 11, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3", "patch": "@@ -110,6 +110,7 @@ along with GCC; see the file COPYING3.  If not see\n /* Bitflags used by final_scan_insn.  */\n #define SEEN_NOTE\t1\n #define SEEN_EMITTED\t2\n+#define SEEN_NEXT_VIEW\t4\n \n /* Last insn processed by final_scan_insn.  */\n static rtx_insn *debug_insn;\n@@ -1692,19 +1693,83 @@ get_some_local_dynamic_name ()\n   return 0;\n }\n \n+/* Arrange for us to emit a source location note before any further\n+   real insns or section changes, by setting the SEEN_NEXT_VIEW bit in\n+   *SEEN, as long as we are keeping track of location views.  The bit\n+   indicates we have referenced the next view at the current PC, so we\n+   have to emit it.  This should be called next to the var_location\n+   debug hook.  */\n+\n+static inline void\n+set_next_view_needed (int *seen)\n+{\n+  if (debug_variable_location_views)\n+    *seen |= SEEN_NEXT_VIEW;\n+}\n+\n+/* Clear the flag in *SEEN indicating we need to emit the next view.\n+   This should be called next to the source_line debug hook.  */\n+\n+static inline void\n+clear_next_view_needed (int *seen)\n+{\n+  *seen &= ~SEEN_NEXT_VIEW;\n+}\n+\n+/* Test whether we have a pending request to emit the next view in\n+   *SEEN, and emit it if needed, clearing the request bit.  */\n+\n+static inline void\n+maybe_output_next_view (int *seen)\n+{\n+  if ((*seen & SEEN_NEXT_VIEW) != 0)\n+    {\n+      clear_next_view_needed (seen);\n+      (*debug_hooks->source_line) (last_linenum, last_columnnum,\n+\t\t\t\t   last_filename, last_discriminator,\n+\t\t\t\t   false);\n+    }\n+}\n+\n+/* We want to emit param bindings (before the first begin_stmt) in the\n+   initial view, if we are emitting views.  To that end, we may\n+   consume initial notes in the function, processing them in\n+   final_start_function, before signaling the beginning of the\n+   prologue, rather than in final.\n+\n+   We don't test whether the DECLs are PARM_DECLs: the assumption is\n+   that there will be a NOTE_INSN_BEGIN_STMT marker before any\n+   non-parameter NOTE_INSN_VAR_LOCATION.  It's ok if the marker is not\n+   there, we'll just have more variable locations bound in the initial\n+   view, which is consistent with their being bound without any code\n+   that would give them a value.  */\n+\n+static inline bool\n+in_initial_view_p (rtx_insn *insn)\n+{\n+  return (!DECL_IGNORED_P (current_function_decl)\n+\t  && debug_variable_location_views\n+\t  && insn && GET_CODE (insn) == NOTE\n+\t  && (NOTE_KIND (insn) == NOTE_INSN_VAR_LOCATION\n+\t      || NOTE_KIND (insn) == NOTE_INSN_DELETED));\n+}\n+\n /* Output assembler code for the start of a function,\n    and initialize some of the variables in this file\n    for the new function.  The label for the function and associated\n    assembler pseudo-ops have already been output in `assemble_start_function'.\n \n    FIRST is the first insn of the rtl for the function being compiled.\n    FILE is the file to write assembler code to.\n+   SEEN should be initially set to zero, and it may be updated to\n+   indicate we have references to the next location view, that would\n+   require us to emit it at the current PC.\n    OPTIMIZE_P is nonzero if we should eliminate redundant\n      test and compare insns.  */\n \n-void\n-final_start_function (rtx_insn *first, FILE *file,\n-\t\t      int optimize_p ATTRIBUTE_UNUSED)\n+static void\n+final_start_function_1 (rtx_insn **firstp, FILE *file, int *seen,\n+\t\t\tint optimize_p ATTRIBUTE_UNUSED)\n {\n   block_depth = 0;\n \n@@ -1722,8 +1787,21 @@ final_start_function (rtx_insn *first, FILE *file,\n   if (flag_sanitize & SANITIZE_ADDRESS)\n     asan_function_start ();\n \n+  rtx_insn *first = *firstp;\n+  if (in_initial_view_p (first))\n+    {\n+      do\n+\t{\n+\t  final_scan_insn (first, file, 0, 0, seen);\n+\t  first = NEXT_INSN (first);\n+\t}\n+      while (in_initial_view_p (first));\n+      *firstp = first;\n+    }\n+\n   if (!DECL_IGNORED_P (current_function_decl))\n-    debug_hooks->begin_prologue (last_linenum, last_columnnum, last_filename);\n+    debug_hooks->begin_prologue (last_linenum, last_columnnum,\n+\t\t\t\t last_filename);\n \n   if (!dwarf2_debug_info_emitted_p (current_function_decl))\n     dwarf2out_begin_prologue (0, 0, NULL);\n@@ -1799,6 +1877,17 @@ final_start_function (rtx_insn *first, FILE *file,\n     profile_after_prologue (file);\n }\n \n+/* This is an exported final_start_function_1, callable without SEEN.  */\n+\n+void\n+final_start_function (rtx_insn *first, FILE *file,\n+\t\t      int optimize_p ATTRIBUTE_UNUSED)\n+{\n+  int seen = 0;\n+  final_start_function_1 (&first, file, &seen, optimize_p);\n+  gcc_assert (seen == 0);\n+}\n+\n static void\n profile_after_prologue (FILE *file ATTRIBUTE_UNUSED)\n {\n@@ -1928,11 +2017,10 @@ dump_basic_block_info (FILE *file, rtx_insn *insn, basic_block *start_to_bb,\n /* Output assembler code for some insns: all or part of a function.\n    For description of args, see `final_start_function', above.  */\n \n-void\n-final (rtx_insn *first, FILE *file, int optimize_p)\n+static void\n+final_1 (rtx_insn *first, FILE *file, int seen, int optimize_p)\n {\n   rtx_insn *insn, *next;\n-  int seen = 0;\n \n   /* Used for -dA dump.  */\n   basic_block *start_to_bb = NULL;\n@@ -1999,6 +2087,8 @@ final (rtx_insn *first, FILE *file, int optimize_p)\n       insn = final_scan_insn (insn, file, optimize_p, 0, &seen);\n     }\n \n+  maybe_output_next_view (&seen);\n+\n   if (flag_debug_asm)\n     {\n       free (start_to_bb);\n@@ -2015,6 +2105,23 @@ final (rtx_insn *first, FILE *file, int optimize_p)\n \tdelete_insn (insn);\n     }\n }\n+\n+/* This is an exported final_1, callable without SEEN.  */\n+\n+void\n+final (rtx_insn *first, FILE *file, int optimize_p)\n+{\n+  /* Those that use the internal final_start_function_1/final_1 API\n+     skip initial debug bind notes in final_start_function_1, and pass\n+     the modified FIRST to final_1.  But those that use the public\n+     final_start_function/final APIs, final_start_function can't move\n+     FIRST because it's not passed by reference, so if they were\n+     skipped there, skip them again here.  */\n+  while (in_initial_view_p (first))\n+    first = NEXT_INSN (first);\n+\n+  final_1 (first, file, 0, optimize_p);\n+}\n \f\n const char *\n get_insn_template (int code, rtx insn)\n@@ -2155,6 +2262,8 @@ final_scan_insn (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \t  break;\n \n \tcase NOTE_INSN_SWITCH_TEXT_SECTIONS:\n+\t  maybe_output_next_view (seen);\n+\n \t  in_cold_section_p = !in_cold_section_p;\n \n \t  if (in_cold_section_p)\n@@ -2301,6 +2410,8 @@ final_scan_insn (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \t  break;\n \n \tcase NOTE_INSN_BLOCK_END:\n+\t  maybe_output_next_view (seen);\n+\n \t  if (debug_info_level == DINFO_LEVEL_NORMAL\n \t      || debug_info_level == DINFO_LEVEL_VERBOSE\n \t      || write_symbols == DWARF2_DEBUG\n@@ -2357,7 +2468,10 @@ final_scan_insn (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \tcase NOTE_INSN_VAR_LOCATION:\n \tcase NOTE_INSN_CALL_ARG_LOCATION:\n \t  if (!DECL_IGNORED_P (current_function_decl))\n-\t    debug_hooks->var_location (insn);\n+\t    {\n+\t      debug_hooks->var_location (insn);\n+\t      set_next_view_needed (seen);\n+\t    }\n \t  break;\n \n \tcase NOTE_INSN_BEGIN_STMT:\n@@ -2368,6 +2482,7 @@ final_scan_insn (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \t      (*debug_hooks->source_line) (last_linenum, last_columnnum,\n \t\t\t\t\t   last_filename, last_discriminator,\n \t\t\t\t\t   true);\n+\t      clear_next_view_needed (seen);\n \t    }\n \t  break;\n \n@@ -2563,6 +2678,10 @@ final_scan_insn (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \n \t    switch_to_section (current_function_section ());\n \n+\t    if (debug_variable_location_views\n+\t\t&& !DECL_IGNORED_P (current_function_decl))\n+\t      debug_hooks->var_location (insn);\n+\n \t    break;\n \t  }\n \t/* Output this line note if it is the first or the last line\n@@ -2575,7 +2694,12 @@ final_scan_insn (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \t    (*debug_hooks->source_line) (last_linenum, last_columnnum,\n \t\t\t\t\t last_filename, last_discriminator,\n \t\t\t\t\t is_stmt);\n+\t    clear_next_view_needed (seen);\n \t  }\n+\telse\n+\t  maybe_output_next_view (seen);\n+\n+\tgcc_checking_assert (!DEBUG_INSN_P (insn));\n \n \tif (GET_CODE (body) == PARALLEL\n \t    && GET_CODE (XVECEXP (body, 0, 0)) == ASM_INPUT)\n@@ -3042,7 +3166,8 @@ final_scan_insn (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \t/* Let the debug info back-end know about this call.  We do this only\n \t   after the instruction has been emitted because labels that may be\n \t   created to reference the call instruction must appear after it.  */\n-\tif (call_insn != NULL && !DECL_IGNORED_P (current_function_decl))\n+\tif ((debug_variable_location_views || call_insn != NULL)\n+\t    && !DECL_IGNORED_P (current_function_decl))\n \t  debug_hooks->var_location (insn);\n \n \tcurrent_output_insn = debug_insn = 0;\n@@ -4481,8 +4606,10 @@ rest_of_handle_final (void)\n     delete_vta_debug_insns (false);\n \n   assemble_start_function (current_function_decl, fnname);\n-  final_start_function (get_insns (), asm_out_file, optimize);\n-  final (get_insns (), asm_out_file, optimize);\n+  rtx_insn *first = get_insns ();\n+  int seen = 0;\n+  final_start_function_1 (&first, asm_out_file, &seen, optimize);\n+  final_1 (first, asm_out_file, seen, optimize);\n   if (flag_ipa_ra\n       && !lookup_attribute (\"noipa\", DECL_ATTRIBUTES (current_function_decl)))\n     collect_fn_hard_reg_usage ();"}, {"sha": "23db0636fc79b43cbf349ed31e5cd5eee9845640", "filename": "gcc/toplev.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3", "patch": "@@ -1558,6 +1558,22 @@ process_options (void)\n \t     || write_symbols == VMS_AND_DWARF2_DEBUG)\n \t && !(flag_selective_scheduling || flag_selective_scheduling2));\n \n+  if (debug_variable_location_views == AUTODETECT_VALUE)\n+    {\n+      debug_variable_location_views = flag_var_tracking\n+\t&& debug_info_level >= DINFO_LEVEL_NORMAL\n+\t&& (write_symbols == DWARF2_DEBUG\n+\t    || write_symbols == VMS_AND_DWARF2_DEBUG)\n+\t&& !dwarf_strict;\n+    }\n+  else if (debug_variable_location_views == -1 && dwarf_version != 5)\n+    {\n+      warning_at (UNKNOWN_LOCATION, 0,\n+\t\t  \"without -gdwarf-5, -gvariable-location-views=incompat5 \"\n+\t\t  \"is equivalent to -gvariable-location-views\");\n+      debug_variable_location_views = 1;\n+    }\n+\n   if (flag_tree_cselim == AUTODETECT_VALUE)\n     {\n       if (HAVE_conditional_move)"}, {"sha": "dbf59719df8235df57404ae28ee4d9fad8f5881f", "filename": "include/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3", "patch": "@@ -1,3 +1,10 @@\n+2018-02-09  Alexandre Oliva <aoliva@redhat.com>\n+\n+\t* dwarf2.def (DW_AT_GNU_locviews): New.\n+\t* dwarf2.h (enum dwarf_location_list_entry_type): Add\n+\tDW_LLE_GNU_view_pair.\n+\t(DW_LLE_view_pair): Define.\n+\n 2018-01-03  Jakub Jelinek  <jakub@redhat.com>\n \n \tUpdate copyright years."}, {"sha": "c454506d1eda9ca0085f5dbf9e3566c75db7b72c", "filename": "include/dwarf2.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3/include%2Fdwarf2.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3/include%2Fdwarf2.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fdwarf2.def?ref=bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3", "patch": "@@ -443,6 +443,7 @@ DW_AT (DW_AT_GNU_pubtypes, 0x2135)\n /* Attribute for discriminator.\n    See http://gcc.gnu.org/wiki/Discriminator  */\n DW_AT (DW_AT_GNU_discriminator, 0x2136)\n+DW_AT (DW_AT_GNU_locviews, 0x2137)\n /* VMS extensions.  */\n DW_AT (DW_AT_VMS_rtnbeg_pd_address, 0x2201)\n /* GNAT extensions.  */"}, {"sha": "cf0039a92ab4e837c6e028cfc2ac085c0776ccb3", "filename": "include/dwarf2.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3/include%2Fdwarf2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3/include%2Fdwarf2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fdwarf2.h?ref=bd2b9f1e2d67ec8e88c977154ecfee34fa2bebe3", "patch": "@@ -298,6 +298,14 @@ enum dwarf_location_list_entry_type\n     DW_LLE_start_end = 0x07,\n     DW_LLE_start_length = 0x08,\n \n+    /* <http://lists.dwarfstd.org/private.cgi/dwarf-discuss-dwarfstd.org/2017-April/004347.html>\n+       has the proposal for now; only available to list members.\n+\n+       A (possibly updated) copy of the proposal is available at\n+       <http://people.redhat.com/aoliva/papers/sfn/dwarf6-sfn-lvu.txt>.  */\n+    DW_LLE_GNU_view_pair = 0x09,\n+#define DW_LLE_view_pair DW_LLE_GNU_view_pair\n+\n     /* Former extension for Fission.\n        See http://gcc.gnu.org/wiki/DebugFission.  */\n     DW_LLE_GNU_end_of_list_entry = 0x00,"}]}