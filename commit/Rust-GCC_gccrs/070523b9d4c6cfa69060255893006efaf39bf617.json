{"sha": "070523b9d4c6cfa69060255893006efaf39bf617", "node_id": "C_kwDOANBUbNoAKDA3MDUyM2I5ZDRjNmNmYTY5MDYwMjU1ODkzMDA2ZWZhZjM5YmY2MTc", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2023-03-01T13:54:43Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2023-03-01T13:54:43Z"}, "message": "analyzer: fix infinite recursion false +ves [PR108935]\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/108935\n\t* infinite-recursion.cc (contains_unknown_p): New.\n\t(sufficiently_different_region_binding_p): New function, splitting\n\tout inner loop from...\n\t(sufficiently_different_p): ...here.  Extend detection of unknown\n\tsvalues to also include svalues that contain unknown.  Treat\n\tchanges in frames below the entry to the recursion as being\n\tsufficiently different to reject being an infinite recursion.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/108935\n\t* gcc.dg/analyzer/infinite-recursion-pr108935-1.c: New test.\n\t* gcc.dg/analyzer/infinite-recursion-pr108935-1a.c: New test.\n\t* gcc.dg/analyzer/infinite-recursion-pr108935-2.c: New test.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "519d59ab9ec81597143a2a6fdc764f3854bc17a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/519d59ab9ec81597143a2a6fdc764f3854bc17a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/070523b9d4c6cfa69060255893006efaf39bf617", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/070523b9d4c6cfa69060255893006efaf39bf617", "html_url": "https://github.com/Rust-GCC/gccrs/commit/070523b9d4c6cfa69060255893006efaf39bf617", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/070523b9d4c6cfa69060255893006efaf39bf617/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f769d22ab685671095525d09ef29eeeed0ae3cee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f769d22ab685671095525d09ef29eeeed0ae3cee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f769d22ab685671095525d09ef29eeeed0ae3cee"}], "stats": {"total": 203, "additions": 152, "deletions": 51}, "files": [{"sha": "c262e391953881d7113039f8a6f76748045036fc", "filename": "gcc/analyzer/infinite-recursion.cc", "status": "modified", "additions": 100, "deletions": 51, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/070523b9d4c6cfa69060255893006efaf39bf617/gcc%2Fanalyzer%2Finfinite-recursion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/070523b9d4c6cfa69060255893006efaf39bf617/gcc%2Fanalyzer%2Finfinite-recursion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Finfinite-recursion.cc?ref=070523b9d4c6cfa69060255893006efaf39bf617", "patch": "@@ -394,12 +394,108 @@ remap_enclosing_frame (const region *base_reg,\n     }\n }\n \n+/* Return true iff SVAL is unknown, or contains an unknown svalue.  */\n+\n+static bool\n+contains_unknown_p (const svalue *sval)\n+{\n+  if (sval->get_kind () == SK_UNKNOWN)\n+    return true;\n+  if (const compound_svalue *compound_sval\n+\t= sval->dyn_cast_compound_svalue ())\n+    for (auto iter : *compound_sval)\n+      if (iter.second->get_kind () == SK_UNKNOWN)\n+\treturn true;\n+  return false;\n+}\n+\n+/* Subroutine of sufficiently_different_p.  Compare the store bindings\n+   for BASE_REG within NEW_ENTRY_ENODE and PREV_ENTRY_ENODE.\n+\n+   Return true if the state of NEW_ENTRY_ENODE is sufficiently different\n+   from PREV_ENTRY_ENODE within BASE_REG to suggest that some variant is\n+   being modified, and thus the recursion isn't infinite.\n+\n+   Return false if the states for BASE_REG are effectively the same.  */\n+\n+static bool\n+sufficiently_different_region_binding_p (exploded_node *new_entry_enode,\n+\t\t\t\t\t exploded_node *prev_entry_enode,\n+\t\t\t\t\t const region *base_reg)\n+{\n+  /* Compare the stores of the two enodes.  */\n+  const region_model &new_model\n+    = *new_entry_enode->get_state ().m_region_model;\n+  const region_model &prev_model\n+    = *prev_entry_enode->get_state ().m_region_model;\n+\n+  /* Get the value within the new frame.  */\n+  const svalue *new_sval\n+    = new_model.get_store_value (base_reg, NULL);\n+\n+  /* If any part of the value is UNKNOWN (e.g. due to hitting\n+     complexity limits) assume that it differs from the previous\n+     value.  */\n+  if (contains_unknown_p (new_sval))\n+    return true;\n+\n+  /* Get the equivalent value within the old enode.  */\n+  const svalue *prev_sval;\n+\n+  if (const frame_region *enclosing_frame\n+      = base_reg->maybe_get_frame_region ())\n+    {\n+      /* We have a binding within a frame in the new entry enode.  */\n+\n+      /* Consider changes in bindings below the original entry\n+\t to the recursion.  */\n+      const int old_stack_depth = prev_entry_enode->get_stack_depth ();\n+      if (enclosing_frame->get_stack_depth () < old_stack_depth)\n+\tprev_sval = prev_model.get_store_value (base_reg, NULL);\n+      else\n+\t{\n+\t  /* Ignore bindings within frames below the new entry node.  */\n+\t  const int new_stack_depth = new_entry_enode->get_stack_depth ();\n+\t  if (enclosing_frame->get_stack_depth () < new_stack_depth)\n+\t    return false;\n+\n+\t  /* We have a binding within the frame of the new entry node,\n+\t     presumably a parameter.  */\n+\n+\t  /* Get the value within the equivalent frame of\n+\t     the old entrypoint; typically will be the initial_svalue\n+\t     of the parameter.  */\n+\t  const frame_region *equiv_prev_frame\n+\t    = prev_model.get_current_frame ();\n+\t  const region *equiv_prev_base_reg\n+\t    = remap_enclosing_frame (base_reg,\n+\t\t\t\t     enclosing_frame,\n+\t\t\t\t     equiv_prev_frame,\n+\t\t\t\t     new_model.get_manager ());\n+\t  prev_sval\n+\t    = prev_model.get_store_value (equiv_prev_base_reg, NULL);\n+\t}\n+    }\n+  else\n+    prev_sval = prev_model.get_store_value (base_reg, NULL);\n+\n+  /* If the prev_sval contains UNKNOWN (e.g. due to hitting complexity limits)\n+     assume that it will differ from any new value.  */\n+  if (contains_unknown_p (prev_sval))\n+    return true;\n+\n+  if (new_sval != prev_sval)\n+    return true;\n+\n+  return false;\n+}\n+\n /* Compare the state of memory at NEW_ENTRY_ENODE and PREV_ENTRY_ENODE,\n    both of which are entrypoints to the same function, where recursion has\n    occurred.\n \n    Return true if the state of NEW_ENTRY_ENODE is sufficiently different\n-   from PREV_ENTRY_ENODE to suggests that some variant is being modified,\n+   from PREV_ENTRY_ENODE to suggest that some variant is being modified,\n    and thus the recursion isn't infinite.\n \n    Return false if the states are effectively the same, suggesting that\n@@ -459,64 +555,17 @@ sufficiently_different_p (exploded_node *new_entry_enode,\n   gcc_assert (is_entrypoint_p (new_entry_enode));\n   gcc_assert (is_entrypoint_p (prev_entry_enode));\n \n-  const int new_stack_depth = new_entry_enode->get_stack_depth ();\n-\n   /* Compare the stores of the two enodes.  */\n   const region_model &new_model\n     = *new_entry_enode->get_state ().m_region_model;\n-  const region_model &prev_model\n-    = *prev_entry_enode->get_state ().m_region_model;\n   const store &new_store = *new_model.get_store ();\n \n   for (auto kv : new_store)\n     {\n       const region *base_reg = kv.first;\n-\n-      /* Get the value within the new frame.  */\n-      const svalue *new_sval\n-\t= new_model.get_store_value (base_reg, NULL);\n-\n-      /* If the value is UNKNOWN (e.g. due to hitting complexity limits)\n-\t assume that it differs from the previous value.  */\n-      if (new_sval->get_kind () == SK_UNKNOWN)\n-\treturn true;\n-\n-      /* Get the equivalent value within the old enode.  */\n-      const svalue *prev_sval;\n-\n-      if (const frame_region *enclosing_frame\n-\t    = base_reg->maybe_get_frame_region ())\n-\t{\n-\t  /* We have a binding within a frame in the new entry enode.  */\n-\n-\t  /* Ignore bindings within frames below the new entry node.  */\n-\t  if (enclosing_frame->get_stack_depth () < new_stack_depth)\n-\t    continue;\n-\n-\t  /* We have a binding within the frame of the new entry node,\n-\t     presumably a parameter.  */\n-\n-\t  /* Get the value within the equivalent frame of\n-\t     the old entrypoint; typically will be the initial_svalue\n-\t     of the parameter.  */\n-\t  const frame_region *equiv_prev_frame\n-\t    = prev_model.get_current_frame ();\n-\t  const region *equiv_prev_base_reg\n-\t    = remap_enclosing_frame (base_reg,\n-\t\t\t\t     enclosing_frame,\n-\t\t\t\t     equiv_prev_frame,\n-\t\t\t\t     new_model.get_manager ());\n-\t  prev_sval = prev_model.get_store_value (equiv_prev_base_reg, NULL);\n-\t}\n-      else\n-\tprev_sval = prev_model.get_store_value (base_reg, NULL);\n-\n-      /* If the prev_sval is UNKNOWN (e.g. due to hitting complexity limits)\n-\t assume that it will differ from any new value.  */\n-      if (prev_sval->get_kind () == SK_UNKNOWN)\n-\treturn true;\n-\n-      if (new_sval != prev_sval)\n+      if (sufficiently_different_region_binding_p (new_entry_enode,\n+\t\t\t\t\t\t   prev_entry_enode,\n+\t\t\t\t\t\t   base_reg))\n \treturn true;\n     }\n "}, {"sha": "83efe9bb7e0c7d6fd5077d799b2f20ca48642b69", "filename": "gcc/testsuite/gcc.dg/analyzer/infinite-recursion-pr108935-1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/070523b9d4c6cfa69060255893006efaf39bf617/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-pr108935-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/070523b9d4c6cfa69060255893006efaf39bf617/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-pr108935-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-pr108935-1.c?ref=070523b9d4c6cfa69060255893006efaf39bf617", "patch": "@@ -0,0 +1,17 @@\n+typedef struct {\n+    unsigned idx;\n+    int vals[512];\n+} foo_t;\n+\n+int ended(foo_t* f) {\n+    return f->idx >= 512;\n+}\n+unsigned foo(foo_t* f) {\n+    if (ended(f)) {\n+        return f->idx;\n+    }\n+    do {\n+        f->idx++;\n+    } while(!ended(f) && !f->vals[f->idx]);\n+    return foo(f); /* { dg-bogus \"infinite recursion\" } */\n+}"}, {"sha": "b3c4920b10d2b7c28207c64a9d2452741d44a7d9", "filename": "gcc/testsuite/gcc.dg/analyzer/infinite-recursion-pr108935-1a.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/070523b9d4c6cfa69060255893006efaf39bf617/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-pr108935-1a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/070523b9d4c6cfa69060255893006efaf39bf617/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-pr108935-1a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-pr108935-1a.c?ref=070523b9d4c6cfa69060255893006efaf39bf617", "patch": "@@ -0,0 +1,17 @@\n+typedef struct {\n+    unsigned idx;\n+    int vals[512];\n+} foo_t;\n+\n+int ended(foo_t* f) {\n+    return f->idx >= 512;\n+}\n+unsigned foo(foo_t* f) {\n+    if (ended(f)) {\n+        return f->idx;\n+    }\n+    do {\n+        f->idx += 1000;\n+    } while(!ended(f) && !f->vals[f->idx]);\n+    return foo(f); /* { dg-bogus \"infinite recursion\" } */\n+}"}, {"sha": "c46f1f8012c823b84a0539414d7fc1cc3dd8e0a9", "filename": "gcc/testsuite/gcc.dg/analyzer/infinite-recursion-pr108935-2.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/070523b9d4c6cfa69060255893006efaf39bf617/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-pr108935-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/070523b9d4c6cfa69060255893006efaf39bf617/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-pr108935-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion-pr108935-2.c?ref=070523b9d4c6cfa69060255893006efaf39bf617", "patch": "@@ -0,0 +1,18 @@\n+typedef struct {\n+    unsigned done;\n+} foo_t;\n+\n+unsigned foo(foo_t* f) {\n+    if (f->done) {\n+        return f->done;\n+    }\n+    f->done = 1;\n+    return foo(f); /* { dg-bogus \"infinite recursion\" } */\n+}\n+\n+int main() {\n+    foo_t f = (foo_t){\n+        .done = 0,\n+    };\n+    foo(&f);\n+}"}]}