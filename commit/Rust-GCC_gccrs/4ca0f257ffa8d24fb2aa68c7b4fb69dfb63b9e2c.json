{"sha": "4ca0f257ffa8d24fb2aa68c7b4fb69dfb63b9e2c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGNhMGYyNTdmZmE4ZDI0ZmIyYWE2OGM3YjRmYjY5ZGZiNjNiOWUyYw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-10-20T17:54:49Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-10-20T17:54:49Z"}, "message": "regrename.c (rr_replace_reg): Rewrite to use recog_data to perform substitutions...\n\n        * regrename.c (rr_replace_reg): Rewrite to use recog_data to\n        perform substitutions, and apply_change_group to see if it worked.\n\nFrom-SVN: r36971", "tree": {"sha": "17e20885b9b6a6b336ca83bd8420b0e17c168955", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17e20885b9b6a6b336ca83bd8420b0e17c168955"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ca0f257ffa8d24fb2aa68c7b4fb69dfb63b9e2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ca0f257ffa8d24fb2aa68c7b4fb69dfb63b9e2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ca0f257ffa8d24fb2aa68c7b4fb69dfb63b9e2c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ca0f257ffa8d24fb2aa68c7b4fb69dfb63b9e2c/comments", "author": null, "committer": null, "parents": [{"sha": "444751385724c1ed44e29047bfd96bcdba91f522", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/444751385724c1ed44e29047bfd96bcdba91f522", "html_url": "https://github.com/Rust-GCC/gccrs/commit/444751385724c1ed44e29047bfd96bcdba91f522"}], "stats": {"total": 173, "additions": 61, "deletions": 112}, "files": [{"sha": "6414aec6f87dd3d0f2b7632968d1ade4e8388e51", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca0f257ffa8d24fb2aa68c7b4fb69dfb63b9e2c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca0f257ffa8d24fb2aa68c7b4fb69dfb63b9e2c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4ca0f257ffa8d24fb2aa68c7b4fb69dfb63b9e2c", "patch": "@@ -7,6 +7,9 @@ Fri Oct 20 13:33:16 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* function.c (locate_and_pad_parm): Zero alignment_pad.\n \n+\t* regrename.c (rr_replace_reg): Rewrite to use recog_data to\n+\tperform substitutions, and apply_change_group to see if it worked.\n+\n Fri Oct 20 13:33:16 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* dwarf2out.c (add_bound_info): Also ignore COND_EXPR."}, {"sha": "968b8b9b1cabefb047c4e1c3b3ec5016ab6e60aa", "filename": "gcc/regrename.c", "status": "modified", "additions": 58, "deletions": 112, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca0f257ffa8d24fb2aa68c7b4fb69dfb63b9e2c/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca0f257ffa8d24fb2aa68c7b4fb69dfb63b9e2c/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=4ca0f257ffa8d24fb2aa68c7b4fb69dfb63b9e2c", "patch": "@@ -83,8 +83,7 @@ static int replace_reg_in_block\t\tPARAMS ((def_uses *, varray_type *,\n static int consider_def\t\t\tPARAMS ((rtx, int, def_uses *, int));\n static int consider_available\t\tPARAMS ((rtx, int, HARD_REG_SET *,\n \t\t\t\t\t\t int, def_uses *, int));\n-static rtx rr_replace_reg\t\tPARAMS ((rtx, rtx, rtx, int, rtx,\n-\t\t\t\t\t\t int *));\n+static void rr_replace_reg\t\tPARAMS ((rtx, rtx, int, rtx, int *));\n static int consider_use\t\t\tPARAMS ((rtx, int, int, int));\n static int condmove_p\t\t\tPARAMS ((rtx));\n static void dump_def_use_chain\t\tPARAMS ((HARD_REG_SET *, def_uses *,\n@@ -527,8 +526,8 @@ replace_reg_in_block (du, uid_ruid, def, reg_def, avail_reg)\n   rtx reg_use = 0;\n   rtx new_reg = gen_rtx_REG (GET_MODE (reg_def), avail_reg);\n \n-  rr_replace_reg (PATTERN (VARRAY_RTX (*uid_ruid, def)), reg_def, new_reg,\n-\t\t  DESTINATION, VARRAY_RTX (*uid_ruid, def), &status);\n+  rr_replace_reg (reg_def, new_reg, DESTINATION,\n+\t\t  VARRAY_RTX (*uid_ruid, def), &status);\n \n   if (!status)\n     return status;\n@@ -568,9 +567,8 @@ replace_reg_in_block (du, uid_ruid, def, reg_def, avail_reg)\n \t{\n \t  new_reg = gen_rtx_REG (GET_MODE (reg_use), avail_reg);\n \t  \n-\t  rr_replace_reg (PATTERN (VARRAY_RTX (*uid_ruid, du_idx)), reg_use,\n-\t\t\t  new_reg, SOURCE, VARRAY_RTX (*uid_ruid, du_idx),\n-\t\t\t  &status);\n+\t  rr_replace_reg (reg_use, new_reg, SOURCE,\n+\t\t\t  VARRAY_RTX (*uid_ruid, du_idx), &status);\n \t  death_note = find_reg_note (VARRAY_RTX (*uid_ruid, du_idx),\n \t\t\t\t      REG_DEAD, reg_use);\n \t  if (death_note)\n@@ -628,134 +626,82 @@ replace_reg_in_block (du, uid_ruid, def, reg_def, avail_reg)\n /* Try to replace REG_USE in X with REG_SUB if INSN has a REPLACE_TYPE.\n    STATUS is zero if the resulting pattern is not valid. */\n \n-static rtx\n-rr_replace_reg (x, reg_use, reg_sub, replace_type, insn, status)\n-     rtx x;\n+static void\n+rr_replace_reg (reg_use, reg_sub, replace_type, insn, status)\n      rtx reg_use;\n      rtx reg_sub;\n      int replace_type;\n      rtx insn;\n      int *status;\n {\n-  enum rtx_code code;\n   int i;\n-  const char *fmt;\n-  int n;\n+  int changed = 0;\n \n-  if (x == 0)\n-    return x;\n+  /* We only perform replacements on operands, since everything else\n+     is by definition hard-coded.  Begin by extracting insn information\n+     so that we know where the operands and dups exist.  */\n+  extract_insn (insn);\n \n-  code = GET_CODE (x);\n-  switch (code)\n+  for (i = recog_data.n_operands - 1; i >= 0; --i)\n     {\n-    case REG:\n-      if (REGNO (x) == REGNO (reg_use))\n-\t{\n-\t  if (GET_MODE (x) == GET_MODE (reg_use))\n-\t    return reg_sub;\n-\t  else\n-\t    return gen_rtx_REG (GET_MODE (x), REGNO (reg_sub));\n-\t}\n+      rtx op;\n \n-      return x;\n+      /* Match replace_type with operand_type and skip those we aren't\n+\t supposed to touch.  Note that OP_INOUT does _not_ match either\n+\t replace_type.  */\n+      if (replace_type == DESTINATION && recog_data.operand_type[i] != OP_OUT)\n+\tcontinue;\n+      if (replace_type == SOURCE && recog_data.operand_type[i] != OP_IN)\n+\tcontinue;\n \n-    case SET:\n-      if (replace_type == DESTINATION)\n-\tSET_DEST (x) = rr_replace_reg (SET_DEST (x), reg_use, reg_sub,\n-\t\t\t\t       replace_type, insn, status);\n-      else if (replace_type == SOURCE)\n-\t{\n-\t  unsigned int dest_subregno = 0;\n-\t  int had_subreg = GET_CODE (SET_DEST (x)) == SUBREG;\n-\n-\t  if (had_subreg)\n-\t    dest_subregno = REGNO (XEXP (SET_DEST (x), 0));\n-\n-\t  SET_SRC (x) = rr_replace_reg (SET_SRC (x), reg_use, reg_sub,\n-\t\t\t\t\treplace_type, insn, status);\n-\n-\t  /* If the replacement register is not part of the source\n-\t     then it may be part of a source mem operand. */\n-\t  if (GET_CODE (SET_DEST (x)) == MEM\n-\t      || GET_CODE (SET_DEST (x)) == ZERO_EXTRACT\n-\t      || GET_CODE (SET_DEST (x)) == SIGN_EXTRACT\n-\t      || GET_CODE (SET_DEST (x)) == STRICT_LOW_PART)\n-\t    SET_DEST (x) = rr_replace_reg (SET_DEST (x), reg_use, reg_sub,\n-\t\t\t\t\t   replace_type, insn, status);\n-\t  /* Shared rtl sanity check. */\n-\t  if (had_subreg && dest_subregno != REGNO (XEXP (SET_DEST (x), 0)))\n-\t    {\n-\t      *status = 0;\n-\t      return x;\n-\t    }\n-\t}\n+      op = recog_data.operand[i];\n+      if (GET_CODE (op) != REG)\n+\tcontinue;\n \n-      n = recog_memoized (insn);\n-      if (n >= 0)\n+      if (REGNO (op) == REGNO (reg_use))\n \t{\n-\t  int id;\n-\n-\t  extract_insn (insn);\n-\n-\t  /* Any MATCH_DUP's which are REGs must still match */\n-\t  for (id = insn_data[n].n_dups - 1; id >= 0; id--)\n-\t    {\n-\t      int opno = recog_data.dup_num[id];\n+\t  rtx new = reg_sub;\n+\t  if (GET_MODE (op) != GET_MODE (reg_use))\n+\t    new = gen_rtx_REG (GET_MODE (op), REGNO (reg_sub));\n \n-\t      if (GET_CODE (*recog_data.dup_loc[id]) == REG\n-\t\t  && GET_CODE (*recog_data.operand_loc[opno]) == REG\n-\t\t  && (REGNO (*recog_data.dup_loc[id])\n-\t\t      != REGNO (*recog_data.operand_loc[opno])))\n-\t\t*status = 0;\n-\t    }\n+\t  validate_change (insn, recog_data.operand_loc[i], new, 1);\n+\t  recog_data.operand[i] = new;\n \n-\t  if (!constrain_operands (1))\n-\t    {\n-\t      *status = 0;\n-\t      validate_replace_rtx (reg_sub, reg_use, insn);\n-\t    }\n+\t  changed |= 1 << i;\n \t}\n-      else\n-\t*status = 0;\n-\n-      return x;\n-\n-    default:\n-      break;\n     }\n \n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+  /* Any MATCH_DUP's for changed operands must also be changed.  */\n+  /* ??? This more or less assumes that operand_type is correct, in\n+     that the dup will be of the appropriate replace_type.  */\n+  for (i = recog_data.n_dups - 1; i >= 0; i--)\n     {\n-      if (fmt[i] == 'e')\n-\tXEXP (x, i) = rr_replace_reg (XEXP (x, i), reg_use, reg_sub,\n-\t\t\t\t      replace_type, insn, status);\n-      if (fmt[i] == 'E')\n-\t{\n-\t  register int xv;\n+      int opno = recog_data.dup_num[i];\n+      if ((changed >> opno) & 1)\n+\tvalidate_change (insn, recog_data.dup_loc[i],\n+\t\t\t recog_data.operand[i], 1);\n+    }\n \n-\t  for (xv = 0; xv < XVECLEN (x, i); xv++)\n-\t    {\n-\t      XVECEXP (x, i, xv) = rr_replace_reg (XVECEXP (x, i, xv), reg_use,\n-\t\t\t\t\t\treg_sub, replace_type, insn,\n-\t\t\t\t\t\t   status);\n-\t      n = recog_memoized (insn);\n-\t      if (n >= 0)\n-\t\t{\n-\t\t  extract_insn (insn);\n-\t\t  if (!constrain_operands (1))\n-\t\t    {\n-\t\t      *status = 0;\n-\t\t      validate_replace_rtx (reg_sub, reg_use, insn);\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\t*status = 0;\n-\t    }\n-\t}\n+  /* Verify that the changes applied so far result in a recognizable insn.  */\n+  if (! apply_change_group ())\n+    {\n+      *status = 0;\n+      return;\n     }\n \n-  return x;\n+  /* Verify that there are no other references of the given type to the\n+     register in question.  That is, there are no hard-coded references\n+     to this hard register left in the insn.  */\n+  if (replace_type == DESTINATION)\n+    {\n+      if (reg_set_p (reg_use, insn))\n+\t*status = 0;\n+    }\n+  else\n+    {\n+      if (reg_referenced_p (reg_use, PATTERN (insn)))\n+\t*status = 0;\n+    }\n }\n \n /* Can REGNO in INSN be considered for renaming, given def INUM in d/u"}]}