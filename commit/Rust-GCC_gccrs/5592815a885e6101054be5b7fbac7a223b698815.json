{"sha": "5592815a885e6101054be5b7fbac7a223b698815", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTU5MjgxNWE4ODVlNjEwMTA1NGJlNWI3ZmJhYzdhMjIzYjY5ODgxNQ==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-08-20T20:54:20Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-08-20T20:54:20Z"}, "message": "re PR rtl-optimization/50489 ([UPC/IA64] mis-schedule of MEM ref with -ftree-vectorize and -fschedule-insns2)\n\n\tPR target/50489\n\t* config/sh/sh.md (rotcr, *rotcr, shar, shlr): New insns and splits.\n\t(ashrdi3_k, lshrdi3_k): Rewrite as insn_and_split.\n\t* config/sh/sh.c (sh_lshrsi_clobbers_t_reg_p): New function.\n\t* config/sh/sh-protos.h (sh_lshrsi_clobbers_t_reg_p): Declare it.\n\n\tPR target/50489\n\t* gcc.target/sh/pr54089-1.c: New.\n\nFrom-SVN: r190545", "tree": {"sha": "1735ecce6bebefc95e794764b6a81b5216e2b0ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1735ecce6bebefc95e794764b6a81b5216e2b0ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5592815a885e6101054be5b7fbac7a223b698815", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5592815a885e6101054be5b7fbac7a223b698815", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5592815a885e6101054be5b7fbac7a223b698815", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5592815a885e6101054be5b7fbac7a223b698815/comments", "author": null, "committer": null, "parents": [{"sha": "6774855070fac75d8ea3b4814a3c4a81d23d1811", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6774855070fac75d8ea3b4814a3c4a81d23d1811", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6774855070fac75d8ea3b4814a3c4a81d23d1811"}], "stats": {"total": 251, "additions": 241, "deletions": 10}, "files": [{"sha": "b284ae2388578e4a9f959bd54da151eeded7dcf5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5592815a885e6101054be5b7fbac7a223b698815/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5592815a885e6101054be5b7fbac7a223b698815/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5592815a885e6101054be5b7fbac7a223b698815", "patch": "@@ -1,3 +1,11 @@\n+2012-08-20  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/50489\n+\t* config/sh/sh.md (rotcr, *rotcr, shar, shlr): New insns and splits.\n+\t(ashrdi3_k, lshrdi3_k): Rewrite as insn_and_split.\n+\t* config/sh/sh.c (sh_lshrsi_clobbers_t_reg_p): New function.\n+\t* config/sh/sh-protos.h (sh_lshrsi_clobbers_t_reg_p): Declare it.\n+\n 2012-08-20  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/51244"}, {"sha": "8cc5cc6b48883d393df151acd29a41c1dea42c3d", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5592815a885e6101054be5b7fbac7a223b698815/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5592815a885e6101054be5b7fbac7a223b698815/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=5592815a885e6101054be5b7fbac7a223b698815", "patch": "@@ -74,6 +74,7 @@ extern rtx sh_emit_cheap_store_flag (enum machine_mode, enum rtx_code, rtx, rtx)\n extern void sh_emit_compare_and_branch (rtx *, enum machine_mode);\n extern void sh_emit_compare_and_set (rtx *, enum machine_mode);\n extern bool sh_ashlsi_clobbers_t_reg_p (rtx);\n+extern bool sh_lshrsi_clobbers_t_reg_p (rtx);\n extern void gen_shifty_op (int, rtx *);\n extern void gen_shifty_hi_op (int, rtx *);\n extern bool expand_ashiftrt (rtx *);"}, {"sha": "0760cbcbc4c72b65cfbf5e2940dcbb0b4f8226e9", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5592815a885e6101054be5b7fbac7a223b698815/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5592815a885e6101054be5b7fbac7a223b698815/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=5592815a885e6101054be5b7fbac7a223b698815", "patch": "@@ -2892,6 +2892,14 @@ sh_ashlsi_clobbers_t_reg_p (rtx shift_amount)\n \t  & ASHL_CLOBBERS_T) != 0;\n }\n \n+bool\n+sh_lshrsi_clobbers_t_reg_p (rtx shift_amount)\n+{\n+  gcc_assert (CONST_INT_P (shift_amount));\n+  return (ashl_lshr_seq[INTVAL (shift_amount) & 31].clobbers_t\n+\t  & LSHR_CLOBBERS_T) != 0;\n+}\n+\n /* Assuming we have a value that has been sign-extended by at least one bit,\n    can we use the ext_shift_amounts with the last shift turned to an arithmetic shift\n    to shift it by N without data loss, and quicker than by other means?  */"}, {"sha": "d38fd20a33461f42ee1a88c8fe69ff69c262358c", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 136, "deletions": 10, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5592815a885e6101054be5b7fbac7a223b698815/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5592815a885e6101054be5b7fbac7a223b698815/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=5592815a885e6101054be5b7fbac7a223b698815", "patch": "@@ -3827,6 +3827,100 @@ label:\n     FAIL;\n })\n \n+;; The rotcr insn is used primarily in DImode right shifts (arithmetic\n+;; and logical).  It can also be used to implement things like\n+;;\tbool t = a == b;\n+;;\tint x = (y >> 1) | (t << 31);\n+(define_insn \"rotcr\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n+\t(ior:SI (lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n+\t\t\t     (const_int 1))\n+\t\t(ashift:SI (match_operand:SI 2 \"t_reg_operand\")\n+\t\t\t   (const_int 31))))\n+   (set (reg:SI T_REG)\n+\t(and:SI (match_dup 1) (const_int 1)))]\n+  \"TARGET_SH1\"\n+  \"rotcr\t%0\"\n+  [(set_attr \"type\" \"arith\")])\n+\n+;; Simplified rotcr version for combine, which allows arbitrary shift\n+;; amounts for the reg.  If the shift amount is '1' rotcr can be used\n+;; directly.  Otherwise we have to insert a shift in between.\n+(define_insn_and_split \"*rotcr\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(ior:SI (lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\")\n+\t\t\t     (match_operand:SI 2 \"const_int_operand\"))\n+\t\t(ashift:SI (match_operand:SI 3 \"t_reg_operand\")\n+\t\t\t   (const_int 31))))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1\"\n+  \"#\"\n+  \"&& can_create_pseudo_p ()\"\n+  [(const_int 0)]\n+{\n+  if (INTVAL (operands[2]) > 1)\n+    {\n+      /* use plus_constant function ?? */\n+      const int shift_count = INTVAL (operands[2]) - 1;\n+      const rtx shift_count_rtx = GEN_INT (shift_count);\n+      rtx shift_res = gen_reg_rtx (SImode);\n+\n+      rtx prev_set_t_insn = NULL_RTX;\n+      rtx tmp_t_reg = NULL_RTX;\n+\n+      /* If we're going to emit a shift sequence that clobbers the T_REG,\n+\t try to find the previous insn that sets the T_REG and emit the \n+\t shift insn before that insn, to remove the T_REG dependency.\n+\t If the insn that sets the T_REG cannot be found, store the T_REG\n+\t in a temporary reg and restore it after the shift.  */\n+      if (sh_lshrsi_clobbers_t_reg_p (shift_count_rtx)\n+\t  && ! sh_dynamicalize_shift_p (shift_count_rtx))\n+\t{\n+\t  prev_set_t_insn = prev_nonnote_insn_bb (curr_insn);\n+\t  if (! (prev_set_t_insn != NULL_RTX\n+\t\t && reg_set_p (get_t_reg_rtx (), prev_set_t_insn)\n+\t\t && ! reg_referenced_p (get_t_reg_rtx (),\n+\t\t\t\t\tPATTERN (prev_set_t_insn))))\n+\t    {\n+\t      prev_set_t_insn = NULL_RTX;\n+\t      tmp_t_reg = gen_reg_rtx (SImode);\n+\t      emit_insn (gen_move_insn (tmp_t_reg, get_t_reg_rtx ()));\n+\t    } \n+\t}\n+\n+      rtx shift_rtx = gen_lshrsi3 (shift_res, operands[1], shift_count_rtx);\n+      operands[1] = shift_res;\n+\n+      /* Emit the shift insn before the insn that sets T_REG, if possible.  */\n+      if (prev_set_t_insn != NULL_RTX)\n+\temit_insn_before (shift_rtx, prev_set_t_insn);\n+      else\n+\temit_insn (shift_rtx);\n+\n+      /* Restore T_REG if it has been saved before.  */\n+      if (tmp_t_reg != NULL_RTX)\n+\temit_insn (gen_cmpgtsi_t (tmp_t_reg, const0_rtx));\n+    }\n+\n+  emit_insn (gen_rotcr (operands[0], operands[1], operands[3]));\n+  DONE;\n+})\n+\n+;; rotcr combine bridge pattern which will make combine try out more\n+;; complex patterns.\n+(define_insn_and_split \"*rotcr\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(ashift:SI (match_operand:SI 1 \"t_reg_operand\") (const_int 31)))]\n+  \"TARGET_SH1\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (match_dup 0) (match_dup 1))\n+   (parallel [(set (match_dup 0)\n+\t\t   (ior:SI (lshiftrt:SI (match_dup 0) (const_int 1))\n+\t\t\t   (ashift:SI (match_dup 1) (const_int 31))))\n+\t      (set (reg:SI T_REG)\n+\t\t   (and:SI (match_dup 0) (const_int 1)))])])\n+\n ;; . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n ;; SImode shift left\n \n@@ -4146,6 +4240,16 @@ label:\n     FAIL;\n })\n \n+(define_insn \"shar\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n+\t\t     (const_int 1)))\n+   (set (reg:SI T_REG)\n+\t(and:SI (match_dup 1) (const_int 1)))]\n+  \"TARGET_SH1\"\n+  \"shar\t%0\"\n+  [(set_attr \"type\" \"arith\")])\n+\n (define_insn \"ashrsi3_k\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n \t(ashiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n@@ -4233,16 +4337,22 @@ label:\n     FAIL;\n })\n \n-;; This should be a define_insn_and_split\n-(define_insn \"ashrdi3_k\"\n+(define_insn_and_split \"ashrdi3_k\"\n   [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n \t(ashiftrt:DI (match_operand:DI 1 \"arith_reg_operand\" \"0\")\n \t\t     (const_int 1)))\n    (clobber (reg:SI T_REG))]\n   \"TARGET_SH1\"\n-  \"shar\t%S0\\;rotcr\t%R0\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"arith\")])\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  rtx high = gen_highpart (SImode, operands[0]);\n+  rtx low = gen_lowpart (SImode, operands[0]);\n+  emit_insn (gen_shar (high, high));\n+  emit_insn (gen_rotcr (low, low, get_t_reg_rtx ()));\n+  DONE;\n+})\n \n (define_insn \"ashrdi3_media\"\n   [(set (match_operand:DI 0 \"ext_dest_operand\" \"=r,r\")\n@@ -4322,6 +4432,16 @@ label:\n   \"shld\t%2,%0\"\n   [(set_attr \"type\" \"dyn_shift\")])\n \n+(define_insn \"shlr\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n+\t\t     (const_int 1)))\n+   (set (reg:SI T_REG)\n+\t(and:SI (match_dup 1) (const_int 1)))]\n+  \"TARGET_SH1\"\n+  \"shlr\t%0\"\n+  [(set_attr \"type\" \"arith\")])\n+\n (define_insn \"lshrsi3_m\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n \t(lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n@@ -4384,16 +4504,22 @@ label:\n     FAIL;\n })\n \n-;; This should be a define_insn_and_split\n-(define_insn \"lshrdi3_k\"\n+(define_insn_and_split \"lshrdi3_k\"\n   [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n \t(lshiftrt:DI (match_operand:DI 1 \"arith_reg_operand\" \"0\")\n \t\t     (const_int 1)))\n    (clobber (reg:SI T_REG))]\n   \"TARGET_SH1\"\n-  \"shlr\t%S0\\;rotcr\t%R0\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"arith\")])\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  rtx high = gen_highpart (SImode, operands[0]);\n+  rtx low = gen_lowpart (SImode, operands[0]);\n+  emit_insn (gen_shlr (high, high));\n+  emit_insn (gen_rotcr (low, low, get_t_reg_rtx ()));\n+  DONE;\n+})\n \n (define_insn \"lshrdi3_media\"\n   [(set (match_operand:DI 0 \"ext_dest_operand\" \"=r,r\")"}, {"sha": "0db9e172aa764bf40dec8caf57c1223d8b591380", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5592815a885e6101054be5b7fbac7a223b698815/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5592815a885e6101054be5b7fbac7a223b698815/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5592815a885e6101054be5b7fbac7a223b698815", "patch": "@@ -1,3 +1,8 @@\n+2012-08-20  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/50489\n+\t* gcc.target/sh/pr54089-1.c: New.\n+\n 2012-08-20  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/51244"}, {"sha": "2101c53585a00d348114addd6ad1436bf3b787de", "filename": "gcc/testsuite/gcc.target/sh/pr54089-1.c", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5592815a885e6101054be5b7fbac7a223b698815/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54089-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5592815a885e6101054be5b7fbac7a223b698815/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54089-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54089-1.c?ref=5592815a885e6101054be5b7fbac7a223b698815", "patch": "@@ -0,0 +1,83 @@\n+/* Check that the rotcr instruction is generated.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O1\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\"} { \"\" } }  */\n+/* { dg-final { scan-assembler-times \"rotcr\" 11 } } */\n+\n+typedef char bool;\n+\n+long long\n+test_00 (long long a)\n+{\n+  return a >> 1;\n+}\n+\n+unsigned int\n+test_01 (unsigned int a, int b, int c)\n+{\n+  bool r = b == c;\n+  return ((a >> 1) | (r << 31));\n+}\n+\n+unsigned int\n+test_02 (unsigned int a, int b, int c)\n+{\n+  bool r = b == c;\n+  return ((a >> 2) | (r << 31));\n+}\n+\n+unsigned int\n+test_03 (unsigned int a, int b, int c)\n+{\n+  bool r = b == c;\n+  return ((a >> 3) | (r << 31));\n+}\n+\n+unsigned int\n+test_04 (unsigned int a, int b, int c)\n+{\n+  bool r = b == c;\n+  return ((a >> 4) | (r << 31));\n+}\n+\n+unsigned int\n+test_05 (unsigned int a, int b, int c)\n+{\n+  bool r = b == c;\n+  return ((a >> 5) | (r << 31));\n+}\n+\n+unsigned int\n+test_06 (unsigned int a, int b, int c)\n+{\n+  bool r = b == c;\n+  return ((a >> 6) | (r << 31));\n+}\n+\n+unsigned int\n+test_07 (unsigned int a, int b, int c)\n+{\n+  bool r = b == c;\n+  return ((a >> 7) | (r << 31));\n+}\n+\n+unsigned int\n+test_08 (unsigned int a, int b, int c)\n+{\n+  bool r = b == c;\n+  return ((a >> 8) | (r << 31));\n+}\n+\n+unsigned int\n+test_09 (unsigned int a, int b, int c)\n+{\n+  bool r = b == c;\n+  return ((a >> 31) | (r << 31));\n+}\n+\n+int\n+test_10 (int a, int b)\n+{\n+  bool r = a == b;\n+  return r << 31;\n+}"}]}