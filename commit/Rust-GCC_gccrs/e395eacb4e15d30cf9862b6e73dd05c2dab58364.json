{"sha": "e395eacb4e15d30cf9862b6e73dd05c2dab58364", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTM5NWVhY2I0ZTE1ZDMwY2Y5ODYyYjZlNzNkZDA1YzJkYWI1ODM2NA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-10-02T22:22:28Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-10-02T22:22:28Z"}, "message": "compiler: Fix parse of (<- chan <- chan <- int)(x).\n\nFrom-SVN: r192011", "tree": {"sha": "b3483b5c8da16d6e9e82cbe8d4f7e81eeed60319", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3483b5c8da16d6e9e82cbe8d4f7e81eeed60319"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e395eacb4e15d30cf9862b6e73dd05c2dab58364", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e395eacb4e15d30cf9862b6e73dd05c2dab58364", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e395eacb4e15d30cf9862b6e73dd05c2dab58364", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e395eacb4e15d30cf9862b6e73dd05c2dab58364/comments", "author": null, "committer": null, "parents": [{"sha": "d8ea0885d7c1403a7f9e85fe2b67d0c223565992", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8ea0885d7c1403a7f9e85fe2b67d0c223565992", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8ea0885d7c1403a7f9e85fe2b67d0c223565992"}], "stats": {"total": 91, "additions": 83, "deletions": 8}, "files": [{"sha": "1ec283dca56bb3793b594e5c63e7ebf34f7b67ae", "filename": "gcc/go/gofrontend/parse.cc", "status": "modified", "additions": 81, "deletions": 8, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e395eacb4e15d30cf9862b6e73dd05c2dab58364/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e395eacb4e15d30cf9862b6e73dd05c2dab58364/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.cc?ref=e395eacb4e15d30cf9862b6e73dd05c2dab58364", "patch": "@@ -3315,6 +3315,61 @@ Parse::unary_expr(bool may_be_sink, bool may_be_composite_lit,\n \t\t  bool* is_type_switch)\n {\n   const Token* token = this->peek_token();\n+\n+  // There is a complex parse for <- chan.  The choices are\n+  // Convert x to type <- chan int:\n+  //   (<- chan int)(x)         \n+  // Receive from (x converted to type chan <- chan int):\n+  //   (<- chan <- chan int (x))\n+  // Convert x to type <- chan (<- chan int).\n+  //   (<- chan <- chan int)(x)\n+  if (token->is_op(OPERATOR_CHANOP))\n+    {\n+      Location location = token->location();\n+      if (this->advance_token()->is_keyword(KEYWORD_CHAN))\n+\t{\n+\t  Expression* expr = this->primary_expr(false, may_be_composite_lit,\n+\t\t\t\t\t\tNULL);\n+\t  if (expr->is_error_expression())\n+\t    return expr;\n+\t  else if (!expr->is_type_expression())\n+\t    return Expression::make_receive(expr, location);\n+\t  else\n+\t    {\n+\t      if (expr->type()->is_error_type())\n+\t\treturn expr;\n+\n+\t      // We picked up \"chan TYPE\", but it is not a type\n+\t      // conversion.\n+\t      Channel_type* ct = expr->type()->channel_type();\n+\t      if (ct == NULL)\n+\t\t{\n+\t\t  // This is probably impossible.\n+\t\t  error_at(location, \"expected channel type\");\n+\t\t  return Expression::make_error(location);\n+\t\t}\n+\t      else if (ct->may_receive())\n+\t\t{\n+\t\t  // <- chan TYPE.\n+\t\t  Type* t = Type::make_channel_type(false, true,\n+\t\t\t\t\t\t    ct->element_type());\n+\t\t  return Expression::make_type(t, location);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  // <- chan <- TYPE.  Because we skipped the leading\n+\t\t  // <-, we parsed this as chan <- TYPE.  With the\n+\t\t  // leading <-, we parse it as <- chan (<- TYPE).\n+\t\t  Type *t = this->reassociate_chan_direction(ct, location);\n+\t\t  return Expression::make_type(t, location);\n+\t\t}\n+\t    }\n+\t}\n+\n+      this->unget_token(Token::make_operator_token(OPERATOR_CHANOP, location));\n+      token = this->peek_token();\n+    }\n+\n   if (token->is_op(OPERATOR_PLUS)\n       || token->is_op(OPERATOR_MINUS)\n       || token->is_op(OPERATOR_NOT)\n@@ -3327,14 +3382,6 @@ Parse::unary_expr(bool may_be_sink, bool may_be_composite_lit,\n       Operator op = token->op();\n       this->advance_token();\n \n-      if (op == OPERATOR_CHANOP\n-\t  && this->peek_token()->is_keyword(KEYWORD_CHAN))\n-\t{\n-\t  // This is \"<- chan\" which must be the start of a type.\n-\t  this->unget_token(Token::make_operator_token(op, location));\n-\t  return Expression::make_type(this->type(), location);\n-\t}\n-\n       Expression* expr = this->unary_expr(false, may_be_composite_lit, NULL);\n       if (expr->is_error_expression())\n \t;\n@@ -3354,6 +3401,32 @@ Parse::unary_expr(bool may_be_sink, bool may_be_composite_lit,\n \t\t\t      is_type_switch);\n }\n \n+// This is called for the obscure case of\n+//   (<- chan <- chan int)(x)\n+// In unary_expr we remove the leading <- and parse the remainder,\n+// which gives us\n+//   chan <- (chan int)\n+// When we add the leading <- back in, we really want\n+//   <- chan (<- chan int)\n+// This means that we need to reassociate.\n+\n+Type*\n+Parse::reassociate_chan_direction(Channel_type *ct, Location location)\n+{\n+  Channel_type* ele = ct->element_type()->channel_type();\n+  if (ele == NULL)\n+    {\n+      error_at(location, \"parse error\");\n+      return Type::make_error_type();\n+    }\n+  Type* sub = ele;\n+  if (ele->may_send())\n+    sub = Type::make_channel_type(false, true, ele->element_type());\n+  else\n+    sub = this->reassociate_chan_direction(ele, location);\n+  return Type::make_channel_type(false, true, sub);\n+}\n+\n // Statement =\n //\tDeclaration | LabeledStmt | SimpleStmt |\n //\tGoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |"}, {"sha": "fb5c1f1641101efb0df69f1c76cbfbd4330023c7", "filename": "gcc/go/gofrontend/parse.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e395eacb4e15d30cf9862b6e73dd05c2dab58364/gcc%2Fgo%2Fgofrontend%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e395eacb4e15d30cf9862b6e73dd05c2dab58364/gcc%2Fgo%2Fgofrontend%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.h?ref=e395eacb4e15d30cf9862b6e73dd05c2dab58364", "patch": "@@ -14,6 +14,7 @@ class Named_object;\n class Type;\n class Typed_identifier;\n class Typed_identifier_list;\n+class Channel_type;\n class Function_type;\n class Block;\n class Expression;\n@@ -229,6 +230,7 @@ class Parse\n   bool expression_may_start_here();\n   Expression* unary_expr(bool may_be_sink, bool may_be_composite_lit,\n \t\t\t bool* is_type_switch);\n+  Type* reassociate_chan_direction(Channel_type*, Location);\n   Expression* qualified_expr(Expression*, Location);\n   Expression* id_to_expression(const std::string&, Location);\n   void statement(Label*);"}]}