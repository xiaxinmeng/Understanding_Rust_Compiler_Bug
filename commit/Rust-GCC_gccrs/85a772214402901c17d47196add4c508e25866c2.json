{"sha": "85a772214402901c17d47196add4c508e25866c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODVhNzcyMjE0NDAyOTAxYzE3ZDQ3MTk2YWRkNGM1MDhlMjU4NjZjMg==", "commit": {"author": {"name": "Alexander Ivchenko", "email": "alexander.ivchenko@intel.com", "date": "2013-09-11T07:32:30Z"}, "committer": {"name": "Kirill Yukhin", "email": "kyukhin@gcc.gnu.org", "date": "2013-09-11T07:32:30Z"}, "message": "constraints.md (k): New.\n\n* config/i386/constraints.md (k): New.\n(Yk): Ditto.\n* config/i386/i386.c (const regclass_map): Add new mask registers.\n(dbx_register_map): Ditto.\n(dbx64_register_map): Ditto.\n(svr4_dbx_register_map): Ditto.\n(ix86_conditional_register_usage): Squash mask registers if AVX512F is\ndisabled.\n(ix86_preferred_reload_class): Disable constants for mask registers.\n(ix86_secondary_reload): Do spill of mask register using 32-bit insn.\n(ix86_hard_regno_mode_ok): Support new mask registers.\n(x86_order_regs_for_local_alloc): Ditto.\n* config/i386/i386.h (FIRST_PSEUDO_REGISTER): Update.\n(FIXED_REGISTERS): Add new mask registers.\n(CALL_USED_REGISTERS): Ditto.\n(REG_ALLOC_ORDER): Ditto.\n(VALID_MASK_REG_MODE): New.\n(FIRST_MASK_REG): Ditto.\n(LAST_MASK_REG): Ditto.\n(reg_class): Add MASK_EVEX_REGS, MASK_REGS.\n(MAYBE_MASK_CLASS_P): New.\n(REG_CLASS_NAMES): Add MASK_EVEX_REGS, MASK_REGS.\n(REG_CLASS_CONTENTS): Ditto.\n(MASK_REGNO_P): New.\n(ANY_MASK_REG_P): Ditto.\n(HI_REGISTER_NAMES): Add new mask registers.\n* config/i386/i386.md (MASK0_REG, MASK1_REG, MASK2_REG,\nMASK3_REG, MASK4_REG, MASK5_REG, MASK6_REG,\nMASK7_REG): Constants for new mask registers.\n(attribute \"type\"): Add mskmov, msklog.\n(attribute \"length_immediate\"): Support them.\n(attribute \"memory\"): Ditto.\n(attribute \"prefix_0f\"): Ditto.\n(*movhi_internal): Support new mask registers.\n(*movqi_internal): Ditto.\n(define_split): Split out clobber pattern is a logic\ninsn on mask registers.\n(*k<logic><mode>): New.\n(*andhi_1): Extend to support mask regs.\n(*andqi_1): Extend to support mask regs.\n(kandn<mode>): New.\n(define_split): Split and-not to and and not if operands\nare not mask regs.\n(*<code><mode>_1): Separate HI mode to new pattern...\n(*<code>hi_1): This.\n(*<code>qi_1): Extend to support mask regs.\n(kxnor<mode>): New.\n(kortestzhi): Ditto.\n(kortestchi): Ditto.\n(kunpckhi): Ditto.\n(*one_cmpl<mode>2_1): Remove HImode and handle it...\n(*one_cmplhi2_1): ...Here, now with mask registers support.\n(*one_cmplqi2_1): Support new mask registers.\n(HI/QImode arithmetics splitter): Don't split if mask registers are used.\n(HI/QImode not splitter): Ditto.\n* config/i386/predicated.md (mask_reg_operand): New.\n(general_reg_operand): Ditto.\n\n\nCo-Authored-By: Andrey Turetskiy <andrey.turetskiy@intel.com>\nCo-Authored-By: Anna Tikhonova <anna.tikhonova@intel.com>\nCo-Authored-By: Ilya Tocar <ilya.tocar@intel.com>\nCo-Authored-By: Ilya Verbin <ilya.verbin@intel.com>\nCo-Authored-By: Kirill Yukhin <kirill.yukhin@intel.com>\nCo-Authored-By: Maxim Kuznetsov <maxim.kuznetsov@intel.com>\nCo-Authored-By: Michael Zolotukhin <michael.v.zolotukhin@intel.com>\nCo-Authored-By: Sergey Lega <sergey.s.lega@intel.com>\n\nFrom-SVN: r202491", "tree": {"sha": "b6da176aa4314e7d30c478bc8a2b2861c1b8d757", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6da176aa4314e7d30c478bc8a2b2861c1b8d757"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85a772214402901c17d47196add4c508e25866c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85a772214402901c17d47196add4c508e25866c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85a772214402901c17d47196add4c508e25866c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85a772214402901c17d47196add4c508e25866c2/comments", "author": null, "committer": null, "parents": [{"sha": "7e570821527734991f2468a15aaec706e23e9e92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e570821527734991f2468a15aaec706e23e9e92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e570821527734991f2468a15aaec706e23e9e92"}], "stats": {"total": 447, "additions": 385, "deletions": 62}, "files": [{"sha": "1e78b100ce6f4c4ef980e538ef165a4a2be5f150", "filename": "gcc/ChangeLog", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a772214402901c17d47196add4c508e25866c2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a772214402901c17d47196add4c508e25866c2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=85a772214402901c17d47196add4c508e25866c2", "patch": "@@ -1,3 +1,71 @@\n+2013-09-11  Alexander Ivchenko  <alexander.ivchenko@intel.com>\n+\t    Maxim Kuznetsov  <maxim.kuznetsov@intel.com>\n+\t    Sergey Lega  <sergey.s.lega@intel.com>\n+\t    Anna Tikhonova  <anna.tikhonova@intel.com>\n+\t    Ilya Tocar  <ilya.tocar@intel.com>\n+\t    Andrey Turetskiy  <andrey.turetskiy@intel.com>\n+\t    Ilya Verbin  <ilya.verbin@intel.com>\n+\t    Kirill Yukhin  <kirill.yukhin@intel.com>\n+\t    Michael Zolotukhin  <michael.v.zolotukhin@intel.com>\n+\n+\t* config/i386/constraints.md (k): New.\n+\t(Yk): Ditto.\n+\t* config/i386/i386.c (const regclass_map): Add new mask registers.\n+\t(dbx_register_map): Ditto.\n+\t(dbx64_register_map): Ditto.\n+\t(svr4_dbx_register_map): Ditto.\n+\t(ix86_conditional_register_usage): Squash mask registers if AVX512F is\n+\tdisabled.\n+\t(ix86_preferred_reload_class): Disable constants for mask registers.\n+\t(ix86_secondary_reload): Do spill of mask register using 32-bit insn.\n+\t(ix86_hard_regno_mode_ok): Support new mask registers.\n+\t(x86_order_regs_for_local_alloc): Ditto.\n+\t* config/i386/i386.h (FIRST_PSEUDO_REGISTER): Update.\n+\t(FIXED_REGISTERS): Add new mask registers.\n+\t(CALL_USED_REGISTERS): Ditto.\n+\t(REG_ALLOC_ORDER): Ditto.\n+\t(VALID_MASK_REG_MODE): New.\n+\t(FIRST_MASK_REG): Ditto.\n+\t(LAST_MASK_REG): Ditto.\n+\t(reg_class): Add MASK_EVEX_REGS, MASK_REGS.\n+\t(MAYBE_MASK_CLASS_P): New.\n+\t(REG_CLASS_NAMES): Add MASK_EVEX_REGS, MASK_REGS.\n+\t(REG_CLASS_CONTENTS): Ditto.\n+\t(MASK_REGNO_P): New.\n+\t(ANY_MASK_REG_P): Ditto.\n+\t(HI_REGISTER_NAMES): Add new mask registers.\n+\t* config/i386/i386.md (MASK0_REG, MASK1_REG, MASK2_REG,\n+\tMASK3_REG, MASK4_REG, MASK5_REG, MASK6_REG,\n+\tMASK7_REG): Constants for new mask registers.\n+\t(attribute \"type\"): Add mskmov, msklog.\n+\t(attribute \"length_immediate\"): Support them.\n+\t(attribute \"memory\"): Ditto.\n+\t(attribute \"prefix_0f\"): Ditto.\n+\t(*movhi_internal): Support new mask registers.\n+\t(*movqi_internal): Ditto.\n+\t(define_split): Split out clobber pattern is a logic\n+\tinsn on mask registers.\n+\t(*k<logic><mode>): New.\n+\t(*andhi_1): Extend to support mask regs.\n+\t(*andqi_1): Extend to support mask regs.\n+\t(kandn<mode>): New.\n+\t(define_split): Split and-not to and and not if operands\n+\tare not mask regs.\n+\t(*<code><mode>_1): Separate HI mode to new pattern...\n+\t(*<code>hi_1): This.\n+\t(*<code>qi_1): Extend to support mask regs.\n+\t(kxnor<mode>): New.\n+\t(kortestzhi): Ditto.\n+\t(kortestchi): Ditto.\n+\t(kunpckhi): Ditto.\n+\t(*one_cmpl<mode>2_1): Remove HImode and handle it...\n+\t(*one_cmplhi2_1): ...Here, now with mask registers support.\n+\t(*one_cmplqi2_1): Support new mask registers.\n+\t(HI/QImode arithmetics splitter): Don't split if mask registers are used.\n+\t(HI/QImode not splitter): Ditto.\n+\t* config/i386/predicated.md (mask_reg_operand): New.\n+\t(general_reg_operand): Ditto.\n+\n 2013-09-11  Alexander Ivchenko  <alexander.ivchenko@intel.com>\n \n \t* doc/invoke.texi: Document fxsr, xsave and xsaveopt options."}, {"sha": "92e0c053fac032c26a066d90bdcf4036f61550fd", "filename": "gcc/config/i386/constraints.md", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a772214402901c17d47196add4c508e25866c2/gcc%2Fconfig%2Fi386%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a772214402901c17d47196add4c508e25866c2/gcc%2Fconfig%2Fi386%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fconstraints.md?ref=85a772214402901c17d47196add4c508e25866c2", "patch": "@@ -19,7 +19,7 @@\n \n ;;; Unused letters:\n ;;;     B     H           T\n-;;;           h jk\n+;;;           h j\n \n ;; Integer register constraints.\n ;; It is not necessary to define 'r' here.\n@@ -78,6 +78,12 @@\n  \"TARGET_80387 || TARGET_FLOAT_RETURNS_IN_80387 ? FP_SECOND_REG : NO_REGS\"\n  \"Second from top of 80387 floating-point stack (@code{%st(1)}).\")\n \n+(define_register_constraint \"k\" \"TARGET_AVX512F ? MASK_EVEX_REGS : NO_REGS\"\n+\"@internal Any mask register that can be used as predicate, i.e. k1-k7.\")\n+\n+(define_register_constraint \"Yk\" \"TARGET_AVX512F ? MASK_REGS : NO_REGS\"\n+\"@internal Any mask register.\")\n+\n ;; Vector registers (also used for plain floating point nowadays).\n (define_register_constraint \"y\" \"TARGET_MMX ? MMX_REGS : NO_REGS\"\n  \"Any MMX register.\")"}, {"sha": "72549e928736428c30c08657085e5990f0e2cfaa", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a772214402901c17d47196add4c508e25866c2/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a772214402901c17d47196add4c508e25866c2/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=85a772214402901c17d47196add4c508e25866c2", "patch": "@@ -2032,6 +2032,9 @@ enum reg_class const regclass_map[FIRST_PSEUDO_REGISTER] =\n   EVEX_SSE_REGS, EVEX_SSE_REGS, EVEX_SSE_REGS, EVEX_SSE_REGS,\n   EVEX_SSE_REGS, EVEX_SSE_REGS, EVEX_SSE_REGS, EVEX_SSE_REGS,\n   EVEX_SSE_REGS, EVEX_SSE_REGS, EVEX_SSE_REGS, EVEX_SSE_REGS,\n+  /* Mask registers.  */\n+  MASK_REGS, MASK_EVEX_REGS, MASK_EVEX_REGS, MASK_EVEX_REGS,\n+  MASK_EVEX_REGS, MASK_EVEX_REGS, MASK_EVEX_REGS, MASK_EVEX_REGS,\n };\n \n /* The \"default\" register map used in 32bit mode.  */\n@@ -2047,6 +2050,7 @@ int const dbx_register_map[FIRST_PSEUDO_REGISTER] =\n   -1, -1, -1, -1, -1, -1, -1, -1,\t/* extended SSE registers */\n   -1, -1, -1, -1, -1, -1, -1, -1,       /* AVX-512 registers 16-23*/\n   -1, -1, -1, -1, -1, -1, -1, -1,       /* AVX-512 registers 24-31*/\n+  93, 94, 95, 96, 97, 98, 99, 100,      /* Mask registers */\n };\n \n /* The \"default\" register map used in 64bit mode.  */\n@@ -2062,6 +2066,7 @@ int const dbx64_register_map[FIRST_PSEUDO_REGISTER] =\n   25, 26, 27, 28, 29, 30, 31, 32,\t/* extended SSE registers */\n   67, 68, 69, 70, 71, 72, 73, 74,       /* AVX-512 registers 16-23 */\n   75, 76, 77, 78, 79, 80, 81, 82,       /* AVX-512 registers 24-31 */\n+  118, 119, 120, 121, 122, 123, 124, 125, /* Mask registers */\n };\n \n /* Define the register numbers to be used in Dwarf debugging information.\n@@ -2129,6 +2134,7 @@ int const svr4_dbx_register_map[FIRST_PSEUDO_REGISTER] =\n   -1, -1, -1, -1, -1, -1, -1, -1,\t/* extended SSE registers */\n   -1, -1, -1, -1, -1, -1, -1, -1,       /* AVX-512 registers 16-23*/\n   -1, -1, -1, -1, -1, -1, -1, -1,       /* AVX-512 registers 24-31*/\n+  93, 94, 95, 96, 97, 98, 99, 100,      /* Mask registers */\n };\n \n /* Define parameter passing and return registers.  */\n@@ -4224,8 +4230,13 @@ ix86_conditional_register_usage (void)\n \n   /* If AVX512F is disabled, squash the registers.  */\n   if (! TARGET_AVX512F)\n-    for (i = FIRST_EXT_REX_SSE_REG; i <= LAST_EXT_REX_SSE_REG; i++)\n-      fixed_regs[i] = call_used_regs[i] = 1, reg_names[i] = \"\";\n+    {\n+      for (i = FIRST_EXT_REX_SSE_REG; i <= LAST_EXT_REX_SSE_REG; i++)\n+\tfixed_regs[i] = call_used_regs[i] = 1, reg_names[i] = \"\";\n+\n+      for (i = FIRST_MASK_REG; i <= LAST_MASK_REG; i++)\n+\tfixed_regs[i] = call_used_regs[i] = 1, reg_names[i] = \"\";\n+    }\n }\n \n \f\n@@ -33918,10 +33929,12 @@ ix86_preferred_reload_class (rtx x, reg_class_t regclass)\n     return regclass;\n \n   /* Force constants into memory if we are loading a (nonzero) constant into\n-     an MMX or SSE register.  This is because there are no MMX/SSE instructions\n-     to load from a constant.  */\n+     an MMX, SSE or MASK register.  This is because there are no MMX/SSE/MASK\n+     instructions to load from a constant.  */\n   if (CONSTANT_P (x)\n-      && (MAYBE_MMX_CLASS_P (regclass) || MAYBE_SSE_CLASS_P (regclass)))\n+      && (MAYBE_MMX_CLASS_P (regclass)\n+\t  || MAYBE_SSE_CLASS_P (regclass)\n+\t  || MAYBE_MASK_CLASS_P (regclass)))\n     return NO_REGS;\n \n   /* Prefer SSE regs only, if we can use them for math.  */\n@@ -34025,10 +34038,11 @@ ix86_secondary_reload (bool in_p, rtx x, reg_class_t rclass,\n \n   /* QImode spills from non-QI registers require\n      intermediate register on 32bit targets.  */\n-  if (!TARGET_64BIT\n-      && !in_p && mode == QImode\n-      && INTEGER_CLASS_P (rclass)\n-      && MAYBE_NON_Q_CLASS_P (rclass))\n+  if (mode == QImode\n+      && (MAYBE_MASK_CLASS_P (rclass)\n+\t  || (!TARGET_64BIT && !in_p\n+\t      && INTEGER_CLASS_P (rclass)\n+\t      && MAYBE_NON_Q_CLASS_P (rclass))))\n     {\n       int regno;\n \n@@ -34450,6 +34464,8 @@ ix86_hard_regno_mode_ok (int regno, enum machine_mode mode)\n     return false;\n   if (STACK_REGNO_P (regno))\n     return VALID_FP_MODE_P (mode);\n+  if (MASK_REGNO_P (regno))\n+    return VALID_MASK_REG_MODE (mode);\n   if (SSE_REGNO_P (regno))\n     {\n       /* We implement the move patterns for all vector modes into and\n@@ -35259,6 +35275,10 @@ x86_order_regs_for_local_alloc (void)\n    for (i = FIRST_EXT_REX_SSE_REG; i <= LAST_EXT_REX_SSE_REG; i++)\n      reg_alloc_order [pos++] = i;\n \n+   /* Mask register.  */\n+   for (i = FIRST_MASK_REG; i <= LAST_MASK_REG; i++)\n+     reg_alloc_order [pos++] = i;\n+\n    /* x87 registers.  */\n    if (TARGET_SSE_MATH)\n      for (i = FIRST_STACK_REG; i <= LAST_STACK_REG; i++)"}, {"sha": "709d3edfef3771aecbcaaa0a6ed1ff507ea6e40a", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a772214402901c17d47196add4c508e25866c2/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a772214402901c17d47196add4c508e25866c2/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=85a772214402901c17d47196add4c508e25866c2", "patch": "@@ -893,7 +893,7 @@ enum target_cpu_default\n    eliminated during reloading in favor of either the stack or frame\n    pointer.  */\n \n-#define FIRST_PSEUDO_REGISTER 69\n+#define FIRST_PSEUDO_REGISTER 77\n \n /* Number of hardware registers that go into the DWARF-2 unwind info.\n    If not defined, equals FIRST_PSEUDO_REGISTER.  */\n@@ -923,7 +923,9 @@ enum target_cpu_default\n /*xmm16,xmm17,xmm18,xmm19,xmm20,xmm21,xmm22,xmm23*/\t\t\\\n      0,   0,    0,    0,    0,    0,    0,    0,\t\t\\\n /*xmm24,xmm25,xmm26,xmm27,xmm28,xmm29,xmm30,xmm31*/\t\t\\\n-     0,   0,    0,    0,    0,    0,    0,    0 }\n+     0,   0,    0,    0,    0,    0,    0,    0,\t\t\\\n+/*  k0,  k1, k2, k3, k4, k5, k6, k7*/\t\t\t\t\\\n+     0,  0,   0,  0,  0,  0,  0,  0 }\n \n /* 1 for registers not available across function calls.\n    These must include the FIXED_REGISTERS and also any\n@@ -955,7 +957,9 @@ enum target_cpu_default\n /*xmm16,xmm17,xmm18,xmm19,xmm20,xmm21,xmm22,xmm23*/\t\t\\\n      6,    6,     6,    6,    6,    6,    6,    6,\t\t\\\n /*xmm24,xmm25,xmm26,xmm27,xmm28,xmm29,xmm30,xmm31*/\t\t\\\n-     6,    6,     6,    6,    6,    6,    6,    6 }\n+     6,    6,     6,    6,    6,    6,    6,    6,\t\t\\\n+ /* k0,  k1,  k2,  k3,  k4,  k5,  k6,  k7*/\t\t\t\\\n+     1,   1,   1,   1,   1,   1,   1,   1 }\n \n /* Order in which to allocate registers.  Each register must be\n    listed once, even those in FIXED_REGISTERS.  List frame pointer\n@@ -971,7 +975,7 @@ enum target_cpu_default\n    18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,\t\\\n    33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,  \\\n    48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,\t\\\n-   63, 64, 65, 66, 67, 68 }\n+   63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76 }\n \n /* ADJUST_REG_ALLOC_ORDER is a macro which permits reg_alloc_order\n    to be rearranged based on a particular function.  When using sse math,\n@@ -1068,6 +1072,8 @@ enum target_cpu_default\n    || (MODE) == V16SImode || (MODE) == V32HImode || (MODE) == V8DFmode\t\\\n    || (MODE) == V16SFmode)\n \n+#define VALID_MASK_REG_MODE(MODE) ((MODE) == HImode || (MODE) == QImode)\n+\n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.  */\n \n #define HARD_REGNO_MODE_OK(REGNO, MODE)\t\\\n@@ -1093,8 +1099,10 @@ enum target_cpu_default\n   (CC_REGNO_P (REGNO) ? VOIDmode\t\t\t\t\t\\\n    : (MODE) == VOIDmode && (NREGS) != 1 ? VOIDmode\t\t\t\\\n    : (MODE) == VOIDmode ? choose_hard_reg_mode ((REGNO), (NREGS), false) \\\n-   : (MODE) == HImode && !TARGET_PARTIAL_REG_STALL ? SImode\t\t\\\n-   : (MODE) == QImode && !(TARGET_64BIT || QI_REGNO_P (REGNO)) ? SImode\t\\\n+   : (MODE) == HImode && !(TARGET_PARTIAL_REG_STALL\t\t\t\\\n+\t\t\t   || MASK_REGNO_P (REGNO)) ? SImode\t\t\\\n+   : (MODE) == QImode && !(TARGET_64BIT || QI_REGNO_P (REGNO)\t\t\\\n+\t\t\t   || MASK_REGNO_P (REGNO)) ? SImode\t\t\\\n    : (MODE))\n \n /* The only ABI that saves SSE registers across calls is Win64 (thus no\n@@ -1141,6 +1149,9 @@ enum target_cpu_default\n #define FIRST_EXT_REX_SSE_REG  (LAST_REX_SSE_REG + 1) /*53*/\n #define LAST_EXT_REX_SSE_REG   (FIRST_EXT_REX_SSE_REG + 15) /*68*/\n \n+#define FIRST_MASK_REG  (LAST_EXT_REX_SSE_REG + 1) /*69*/\n+#define LAST_MASK_REG   (FIRST_MASK_REG + 7) /*76*/\n+\n /* Override this in other tm.h files to cope with various OS lossage\n    requiring a frame pointer.  */\n #ifndef SUBTARGET_FRAME_POINTER_REQUIRED\n@@ -1229,6 +1240,8 @@ enum reg_class\n   FLOAT_INT_REGS,\n   INT_SSE_REGS,\n   FLOAT_INT_SSE_REGS,\n+  MASK_EVEX_REGS,\n+  MASK_REGS,\n   ALL_REGS, LIM_REG_CLASSES\n };\n \n@@ -1250,6 +1263,8 @@ enum reg_class\n   reg_classes_intersect_p ((CLASS), ALL_SSE_REGS)\n #define MAYBE_MMX_CLASS_P(CLASS) \\\n   reg_classes_intersect_p ((CLASS), MMX_REGS)\n+#define MAYBE_MASK_CLASS_P(CLASS) \\\n+  reg_classes_intersect_p ((CLASS), MASK_REGS)\n \n #define Q_CLASS_P(CLASS) \\\n   reg_class_subset_p ((CLASS), Q_REGS)\n@@ -1282,6 +1297,8 @@ enum reg_class\n    \"FLOAT_INT_REGS\",\t\t\t\\\n    \"INT_SSE_REGS\",\t\t\t\\\n    \"FLOAT_INT_SSE_REGS\",\t\t\\\n+   \"MASK_EVEX_REGS\",\t\t\t\\\n+   \"MASK_REGS\",\t\t\t\t\\\n    \"ALL_REGS\" }\n \n /* Define which registers fit in which classes.  This is an initializer\n@@ -1319,7 +1336,9 @@ enum reg_class\n {   0x11ffff,    0x1fe0,   0x0 },       /* FLOAT_INT_REGS */            \\\n { 0x1ff100ff,0xffffffe0,  0x1f },       /* INT_SSE_REGS */              \\\n { 0x1ff1ffff,0xffffffe0,  0x1f },       /* FLOAT_INT_SSE_REGS */        \\\n-{ 0xffffffff,0xffffffff,  0x1f }                                        \\\n+       { 0x0,       0x0,0x1fc0 },       /* MASK_EVEX_REGS */           \\\n+       { 0x0,       0x0,0x1fe0 },       /* MASK_REGS */                 \\\n+{ 0xffffffff,0xffffffff,0x1fff }                                        \\\n }\n \n /* The same information, inverted:\n@@ -1377,6 +1396,8 @@ enum reg_class\n          : (N) <= LAST_REX_SSE_REG ? (FIRST_REX_SSE_REG + (N) - 8) \\\n                                    : (FIRST_EXT_REX_SSE_REG + (N) - 16))\n \n+#define MASK_REGNO_P(N) IN_RANGE ((N), FIRST_MASK_REG, LAST_MASK_REG)\n+#define ANY_MASK_REG_P(X) (REG_P (X) && MASK_REGNO_P (REGNO (X)))\n \n #define SSE_FLOAT_MODE_P(MODE) \\\n   ((TARGET_SSE && (MODE) == SFmode) || (TARGET_SSE2 && (MODE) == DFmode))\n@@ -1933,7 +1954,8 @@ do {\t\t\t\t\t\t\t\\\n  \"xmm16\", \"xmm17\", \"xmm18\", \"xmm19\",\t\t\t\t\t\\\n  \"xmm20\", \"xmm21\", \"xmm22\", \"xmm23\",\t\t\t\t\t\\\n  \"xmm24\", \"xmm25\", \"xmm26\", \"xmm27\",\t\t\t\t\t\\\n- \"xmm28\", \"xmm29\", \"xmm30\", \"xmm31\" }\n+ \"xmm28\", \"xmm29\", \"xmm30\", \"xmm31\",\t\t\t\t\t\\\n+ \"k0\", \"k1\", \"k2\", \"k3\", \"k4\", \"k5\", \"k6\", \"k7\" }\n \n #define REGISTER_NAMES HI_REGISTER_NAMES\n "}, {"sha": "013673ab9baf1926cac05202c9f2dd34f27a54e6", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 242, "deletions": 44, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a772214402901c17d47196add4c508e25866c2/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a772214402901c17d47196add4c508e25866c2/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=85a772214402901c17d47196add4c508e25866c2", "patch": "@@ -328,6 +328,14 @@\n    (XMM29_REG\t\t\t66)\n    (XMM30_REG\t\t\t67)\n    (XMM31_REG\t\t\t68)\n+   (MASK0_REG\t\t\t69)\n+   (MASK1_REG\t\t\t70)\n+   (MASK2_REG\t\t\t71)\n+   (MASK3_REG\t\t\t72)\n+   (MASK4_REG\t\t\t73)\n+   (MASK5_REG\t\t\t74)\n+   (MASK6_REG\t\t\t75)\n+   (MASK7_REG\t\t\t76)\n   ])\n \n ;; Insns whose names begin with \"x86_\" are emitted by gen_FOO calls\n@@ -360,7 +368,7 @@\n    sseishft,sseishft1,ssecmp,ssecomi,\n    ssecvt,ssecvt1,sseicvt,sseins,\n    sseshuf,sseshuf1,ssemuladd,sse4arg,\n-   lwp,\n+   lwp,mskmov,msklog,\n    mmx,mmxmov,mmxadd,mmxmul,mmxcmp,mmxcvt,mmxshft\"\n   (const_string \"other\"))\n \n@@ -379,7 +387,7 @@\n \t\t\t  ssemul,sseimul,ssediv,sselog,sselog1,\n \t\t\t  sseishft,sseishft1,ssecmp,ssecomi,\n \t\t\t  ssecvt,ssecvt1,sseicvt,sseins,\n-\t\t\t  sseshuf,sseshuf1,ssemuladd,sse4arg\")\n+\t\t\t  sseshuf,sseshuf1,ssemuladd,sse4arg,mskmov\")\n \t   (const_string \"sse\")\n \t (eq_attr \"type\" \"mmx,mmxmov,mmxadd,mmxmul,mmxcmp,mmxcvt,mmxshft\")\n \t   (const_string \"mmx\")\n@@ -390,7 +398,7 @@\n ;; The (bounding maximum) length of an instruction immediate.\n (define_attr \"length_immediate\" \"\"\n   (cond [(eq_attr \"type\" \"incdec,setcc,icmov,str,lea,other,multi,idiv,leave,\n-\t\t\t  bitmanip,imulx\")\n+\t\t\t  bitmanip,imulx,msklog,mskmov\")\n \t   (const_int 0)\n \t (eq_attr \"unit\" \"i387,sse,mmx\")\n \t   (const_int 0)\n@@ -451,7 +459,7 @@\n ;; Set when 0f opcode prefix is used.\n (define_attr \"prefix_0f\" \"\"\n   (if_then_else\n-    (ior (eq_attr \"type\" \"imovx,setcc,icmov,bitmanip\")\n+    (ior (eq_attr \"type\" \"imovx,setcc,icmov,bitmanip,msklog,mskmov\")\n \t (eq_attr \"unit\" \"sse,mmx\"))\n     (const_int 1)\n     (const_int 0)))\n@@ -651,7 +659,7 @@\n \t\t   fmov,fcmp,fsgn,\n \t\t   sse,ssemov,ssecmp,ssecomi,ssecvt,ssecvt1,sseicvt,\n \t\t   sselog1,sseshuf1,sseadd1,sseiadd1,sseishft1,\n-\t\t   mmx,mmxmov,mmxcmp,mmxcvt\")\n+\t\t   mmx,mmxmov,mmxcmp,mmxcvt,mskmov,msklog\")\n \t      (match_operand 2 \"memory_operand\"))\n \t   (const_string \"load\")\n \t (and (eq_attr \"type\" \"icmov,ssemuladd,sse4arg\")\n@@ -695,7 +703,7 @@\n ;; Used to control the \"enabled\" attribute on a per-instruction basis.\n (define_attr \"isa\" \"base,x64,x64_sse4,x64_sse4_noavx,x64_avx,nox64,\n \t\t    sse2,sse2_noavx,sse3,sse4,sse4_noavx,avx,noavx,\n-\t\t    avx2,noavx2,bmi2,fma4,fma,avx512f,noavx512f,fma_avx512f\"\n+\t\t    avx2,noavx2,bmi,bmi2,fma4,fma,avx512f,noavx512f,fma_avx512f\"\n   (const_string \"base\"))\n \n (define_attr \"enabled\" \"\"\n@@ -718,6 +726,7 @@\n \t (eq_attr \"isa\" \"noavx\") (symbol_ref \"!TARGET_AVX\")\n \t (eq_attr \"isa\" \"avx2\") (symbol_ref \"TARGET_AVX2\")\n \t (eq_attr \"isa\" \"noavx2\") (symbol_ref \"!TARGET_AVX2\")\n+\t (eq_attr \"isa\" \"bmi\") (symbol_ref \"TARGET_BMI\")\n \t (eq_attr \"isa\" \"bmi2\") (symbol_ref \"TARGET_BMI2\")\n \t (eq_attr \"isa\" \"fma4\") (symbol_ref \"TARGET_FMA4\")\n \t (eq_attr \"isa\" \"fma\") (symbol_ref \"TARGET_FMA\")\n@@ -2213,8 +2222,8 @@\n \t   (const_string \"SI\")))])\n \n (define_insn \"*movhi_internal\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r ,r ,m\")\n-\t(match_operand:HI 1 \"general_operand\"\t   \"r ,rn,rm,rn\"))]\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r ,r ,m ,Yk,Yk,rm\")\n+\t(match_operand:HI 1 \"general_operand\"      \"r ,rn,rm,rn,rm,Yk,Yk\"))]\n   \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n {\n   switch (get_attr_type (insn))\n@@ -2223,6 +2232,16 @@\n       /* movzwl is faster than movw on p2 due to partial word stalls,\n \t though not as fast as an aligned movl.  */\n       return \"movz{wl|x}\\t{%1, %k0|%k0, %1}\";\n+\n+    case TYPE_MSKMOV:\n+      switch (which_alternative)\n+        {\n+\tcase 4: return \"kmovw\\t{%k1, %0|%0, %k1}\";\n+\tcase 5: return \"kmovw\\t{%1, %0|%0, %1}\";\n+\tcase 6: return \"kmovw\\t{%1, %k0|%k0, %1}\";\n+\tdefault: gcc_unreachable ();\n+\t}\n+\n     default:\n       if (get_attr_mode (insn) == MODE_SI)\n         return \"mov{l}\\t{%k1, %k0|%k0, %k1}\";\n@@ -2240,11 +2259,17 @@\n \t    (and (eq_attr \"alternative\" \"1,2\")\n \t\t (match_operand:HI 1 \"aligned_operand\"))\n \t      (const_string \"imov\")\n+\t    (eq_attr \"alternative\" \"4,5,6\")\n+\t      (const_string \"mskmov\")\n \t    (and (match_test \"TARGET_MOVX\")\n \t\t (eq_attr \"alternative\" \"0,2\"))\n \t      (const_string \"imovx\")\n \t   ]\n \t   (const_string \"imov\")))\n+    (set (attr \"prefix\")\n+      (if_then_else (eq_attr \"alternative\" \"4,5,6\")\n+\t(const_string \"vex\")\n+\t(const_string \"orig\")))\n     (set (attr \"mode\")\n       (cond [(eq_attr \"type\" \"imovx\")\n \t       (const_string \"SI\")\n@@ -2269,15 +2294,25 @@\n ;; register stall machines with, where we use QImode instructions, since\n ;; partial register stall can be caused there.  Then we use movzx.\n (define_insn \"*movqi_internal\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=q,q ,q ,r,r ,?r,m\")\n-\t(match_operand:QI 1 \"general_operand\"      \"q ,qn,qm,q,rn,qm,qn\"))]\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=q,q ,q ,r,r ,?r,m ,Yk,Yk,r\")\n+\t(match_operand:QI 1 \"general_operand\"      \"q ,qn,qm,q,rn,qm,qn,r ,Yk,Yk\"))]\n   \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n {\n   switch (get_attr_type (insn))\n     {\n     case TYPE_IMOVX:\n       gcc_assert (ANY_QI_REG_P (operands[1]) || MEM_P (operands[1]));\n       return \"movz{bl|x}\\t{%1, %k0|%k0, %1}\";\n+\n+    case TYPE_MSKMOV:\n+      switch (which_alternative)\n+        {\n+\tcase 7: return \"kmovw\\t{%k1, %0|%0, %k1}\";\n+\tcase 8: return \"kmovw\\t{%1, %0|%0, %1}\";\n+\tcase 9: return \"kmovw\\t{%1, %k0|%k0, %1}\";\n+\tdefault: gcc_unreachable ();\n+\t}\n+\n     default:\n       if (get_attr_mode (insn) == MODE_SI)\n         return \"mov{l}\\t{%k1, %k0|%k0, %k1}\";\n@@ -2297,11 +2332,17 @@\n \t      (const_string \"imov\")\n \t    (eq_attr \"alternative\" \"3,5\")\n \t      (const_string \"imovx\")\n+\t    (eq_attr \"alternative\" \"7,8,9\")\n+\t      (const_string \"mskmov\")\n \t    (and (match_test \"TARGET_MOVX\")\n \t\t (eq_attr \"alternative\" \"2\"))\n \t      (const_string \"imovx\")\n \t   ]\n \t   (const_string \"imov\")))\n+   (set (attr \"prefix\")\n+     (if_then_else (eq_attr \"alternative\" \"7,8,9\")\n+       (const_string \"vex\")\n+       (const_string \"orig\")))\n    (set (attr \"mode\")\n       (cond [(eq_attr \"alternative\" \"3,4,5\")\n \t       (const_string \"SI\")\n@@ -7494,6 +7535,26 @@\n   operands[3] = gen_lowpart (QImode, operands[3]);\n })\n \n+(define_split\n+  [(set (match_operand:SWI12 0 \"mask_reg_operand\")\n+\t(any_logic:SWI12 (match_operand:SWI12 1 \"mask_reg_operand\")\n+\t\t\t (match_operand:SWI12 2 \"mask_reg_operand\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_AVX512F && reload_completed\"\n+  [(set (match_dup 0)\n+\t(any_logic:SWI12 (match_dup 1)\n+\t\t\t (match_dup 2)))])\n+\n+(define_insn \"*k<logic><mode>\"\n+  [(set (match_operand:SWI12 0 \"mask_reg_operand\" \"=Yk\")\n+\t(any_logic:SWI12 (match_operand:SWI12 1 \"mask_reg_operand\" \"Yk\")\n+\t\t\t (match_operand:SWI12 2 \"mask_reg_operand\" \"Yk\")))]\n+  \"TARGET_AVX512F\"\n+  \"k<logic>w\\t{%2, %1, %0|%0, %1, %2}\";\n+  [(set_attr \"mode\" \"<MODE>\")\n+   (set_attr \"type\" \"msklog\")\n+   (set_attr \"prefix\" \"vex\")])\n+\n ;; %%% This used to optimize known byte-wide and operations to memory,\n ;; and sometimes to QImode registers.  If this is considered useful,\n ;; it should be done with splitters.\n@@ -7617,9 +7678,9 @@\n    (set_attr \"mode\" \"SI\")])\n \n (define_insn \"*andhi_1\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm,r,Ya\")\n-\t(and:HI (match_operand:HI 1 \"nonimmediate_operand\" \"%0,0,qm\")\n-\t\t(match_operand:HI 2 \"general_operand\" \"rn,rm,L\")))\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm,r,Ya,!Yk\")\n+\t(and:HI (match_operand:HI 1 \"nonimmediate_operand\" \"%0,0,qm,Yk\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"rn,rm,L,Yk\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"ix86_binary_operator_ok (AND, HImode, operands)\"\n {\n@@ -7628,34 +7689,38 @@\n     case TYPE_IMOVX:\n       return \"#\";\n \n+    case TYPE_MSKLOG:\n+      return \"kandw\\t{%2, %1, %0|%0, %1, %2}\";\n+\n     default:\n       gcc_assert (rtx_equal_p (operands[0], operands[1]));\n       return \"and{w}\\t{%2, %0|%0, %2}\";\n     }\n }\n-  [(set_attr \"type\" \"alu,alu,imovx\")\n-   (set_attr \"length_immediate\" \"*,*,0\")\n+  [(set_attr \"type\" \"alu,alu,imovx,msklog\")\n+   (set_attr \"length_immediate\" \"*,*,0,*\")\n    (set (attr \"prefix_rex\")\n      (if_then_else\n        (and (eq_attr \"type\" \"imovx\")\n \t    (match_operand 1 \"ext_QIreg_operand\"))\n        (const_string \"1\")\n        (const_string \"*\")))\n-   (set_attr \"mode\" \"HI,HI,SI\")])\n+   (set_attr \"mode\" \"HI,HI,SI,HI\")])\n \n ;; %%% Potential partial reg stall on alternative 2.  What to do?\n (define_insn \"*andqi_1\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm,q,r\")\n-\t(and:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0,0\")\n-\t\t(match_operand:QI 2 \"general_operand\" \"qn,qmn,rn\")))\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm,q,r,!Yk\")\n+\t(and:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0,0,Yk\")\n+\t\t(match_operand:QI 2 \"general_operand\" \"qn,qmn,rn,Yk\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"ix86_binary_operator_ok (AND, QImode, operands)\"\n   \"@\n    and{b}\\t{%2, %0|%0, %2}\n    and{b}\\t{%2, %0|%0, %2}\n-   and{l}\\t{%k2, %k0|%k0, %k2}\"\n-  [(set_attr \"type\" \"alu\")\n-   (set_attr \"mode\" \"QI,QI,SI\")])\n+   and{l}\\t{%k2, %k0|%k0, %k2}\n+   kandw\\t{%2, %1, %0|%0, %1, %2}\"\n+  [(set_attr \"type\" \"alu,alu,alu,msklog\")\n+   (set_attr \"mode\" \"QI,QI,SI,HI\")])\n \n (define_insn \"*andqi_1_slp\"\n   [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+qm,q\"))\n@@ -7668,6 +7733,40 @@\n   [(set_attr \"type\" \"alu1\")\n    (set_attr \"mode\" \"QI\")])\n \n+(define_insn \"kandn<mode>\"\n+  [(set (match_operand:SWI12 0 \"register_operand\" \"=r,&r,!Yk\")\n+\t(and:SWI12\n+\t  (not:SWI12\n+\t    (match_operand:SWI12 1 \"register_operand\" \"r,0,Yk\"))\n+\t  (match_operand:SWI12 2 \"register_operand\" \"r,r,Yk\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_AVX512F\"\n+  \"@\n+   andn\\t{%k2, %k1, %k0|%k0, %k1, %k2}\n+   #\n+   kandnw\\t{%2, %1, %0|%0, %1, %2}\"\n+  [(set_attr \"isa\" \"bmi,*,avx512f\")\n+   (set_attr \"type\" \"bitmanip,*,msklog\")\n+   (set_attr \"prefix\" \"*,*,vex\")\n+   (set_attr \"btver2_decode\" \"direct,*,*\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_split\n+  [(set (match_operand:SWI12 0 \"general_reg_operand\")\n+\t(and:SWI12\n+\t  (not:SWI12\n+\t    (match_dup 0))\n+\t  (match_operand:SWI12 1 \"general_reg_operand\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_AVX512F && !TARGET_BMI && reload_completed\"\n+  [(set (match_dup 0)\n+\t(not:HI (match_dup 0)))\n+   (parallel [(set (match_dup 0)\n+\t\t   (and:HI (match_dup 0)\n+\t\t\t   (match_dup 1)))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n+  \"\")\n+\n ;; Turn *anddi_1 into *andsi_1_zext if possible.\n (define_split\n   [(set (match_operand:DI 0 \"register_operand\")\n@@ -7999,29 +8098,44 @@\n   \"ix86_expand_binary_operator (<CODE>, <MODE>mode, operands); DONE;\")\n \n (define_insn \"*<code><mode>_1\"\n-  [(set (match_operand:SWI248 0 \"nonimmediate_operand\" \"=r,rm\")\n-\t(any_or:SWI248\n-\t (match_operand:SWI248 1 \"nonimmediate_operand\" \"%0,0\")\n-\t (match_operand:SWI248 2 \"<general_operand>\" \"<g>,r<i>\")))\n+  [(set (match_operand:SWI48 0 \"nonimmediate_operand\" \"=r,rm\")\n+\t(any_or:SWI48\n+\t (match_operand:SWI48 1 \"nonimmediate_operand\" \"%0,0\")\n+\t (match_operand:SWI48 2 \"<general_operand>\" \"<g>,r<i>\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)\"\n   \"<logic>{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n+(define_insn \"*<code>hi_1\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,rm,!Yk\")\n+\t(any_or:HI\n+\t (match_operand:HI 1 \"nonimmediate_operand\" \"%0,0,Yk\")\n+\t (match_operand:HI 2 \"general_operand\" \"<g>,r<i>,Yk\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"ix86_binary_operator_ok (<CODE>, HImode, operands)\"\n+  \"@\n+  <logic>{w}\\t{%2, %0|%0, %2}\n+  <logic>{w}\\t{%2, %0|%0, %2}\n+  k<logic>w\\t{%2, %1, %0|%0, %1, %2}\"\n+  [(set_attr \"type\" \"alu,alu,msklog\")\n+   (set_attr \"mode\" \"HI\")])\n+\n ;; %%% Potential partial reg stall on alternative 2.  What to do?\n (define_insn \"*<code>qi_1\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=q,m,r\")\n-\t(any_or:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0,0\")\n-\t\t   (match_operand:QI 2 \"general_operand\" \"qmn,qn,rn\")))\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=q,m,r,!Yk\")\n+\t(any_or:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0,0,Yk\")\n+\t\t   (match_operand:QI 2 \"general_operand\" \"qmn,qn,rn,Yk\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"ix86_binary_operator_ok (<CODE>, QImode, operands)\"\n   \"@\n    <logic>{b}\\t{%2, %0|%0, %2}\n    <logic>{b}\\t{%2, %0|%0, %2}\n-   <logic>{l}\\t{%k2, %k0|%k0, %k2}\"\n-  [(set_attr \"type\" \"alu\")\n-   (set_attr \"mode\" \"QI,QI,SI\")])\n+   <logic>{l}\\t{%k2, %k0|%k0, %k2}\n+   k<logic>w\\t{%2, %1, %0|%0, %1, %2}\"\n+  [(set_attr \"type\" \"alu,alu,alu,msklog\")\n+   (set_attr \"mode\" \"QI,QI,SI,HI\")])\n \n ;; See comment for addsi_1_zext why we do use nonimmediate_operand\n (define_insn \"*<code>si_1_zext\"\n@@ -8071,6 +8185,74 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n+(define_insn \"kxnor<mode>\"\n+  [(set (match_operand:SWI12 0 \"register_operand\" \"=r,!Yk\")\n+\t(not:SWI12\n+\t  (xor:SWI12\n+\t    (match_operand:SWI12 1 \"register_operand\" \"0,Yk\")\n+\t    (match_operand:SWI12 2 \"register_operand\" \"r,Yk\"))))]\n+  \"TARGET_AVX512F\"\n+  \"@\n+   #\n+   kxnorw\\t{%2, %1, %0|%0, %1, %2}\"\n+  [(set_attr \"type\" \"*,msklog\")\n+   (set_attr \"prefix\" \"*,vex\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_split\n+  [(set (match_operand:SWI12 0 \"general_reg_operand\")\n+\t(not:SWI12\n+\t  (xor:SWI12\n+\t    (match_dup 0)\n+\t    (match_operand:SWI12 1 \"general_reg_operand\"))))]\n+  \"TARGET_AVX512F && reload_completed\"\n+   [(parallel [(set (match_dup 0)\n+\t\t    (xor:HI (match_dup 0)\n+\t\t\t    (match_dup 1)))\n+\t       (clobber (reg:CC FLAGS_REG))])\n+    (set (match_dup 0)\n+\t (not:HI (match_dup 0)))]\n+  \"\")\n+\n+(define_insn \"kortestzhi\"\n+  [(set (reg:CCZ FLAGS_REG)\n+\t(compare:CCZ\n+\t  (ior:HI\n+\t    (match_operand:HI 0 \"register_operand\" \"Yk\")\n+\t    (match_operand:HI 1 \"register_operand\" \"Yk\"))\n+\t  (const_int 0)))]\n+  \"TARGET_AVX512F && ix86_match_ccmode (insn, CCZmode)\"\n+  \"kortestw\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"mode\" \"HI\")\n+   (set_attr \"type\" \"msklog\")\n+   (set_attr \"prefix\" \"vex\")])\n+\n+(define_insn \"kortestchi\"\n+  [(set (reg:CCC FLAGS_REG)\n+\t(compare:CCC\n+\t  (ior:HI\n+\t    (match_operand:HI 0 \"register_operand\" \"Yk\")\n+\t    (match_operand:HI 1 \"register_operand\" \"Yk\"))\n+\t  (const_int -1)))]\n+  \"TARGET_AVX512F && ix86_match_ccmode (insn, CCCmode)\"\n+  \"kortestw\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"mode\" \"HI\")\n+   (set_attr \"type\" \"msklog\")\n+   (set_attr \"prefix\" \"vex\")])\n+\n+(define_insn \"kunpckhi\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=Yk\")\n+\t(ior:HI\n+\t  (ashift:HI\n+\t    (match_operand:HI 1 \"register_operand\" \"Yk\")\n+\t    (const_int 8))\n+\t  (zero_extend:HI (match_operand:QI 2 \"register_operand\" \"Yk\"))))]\n+  \"TARGET_AVX512F\"\n+  \"kunpckbw\\t{%2, %1, %0|%0, %1, %2}\"\n+  [(set_attr \"mode\" \"HI\")\n+   (set_attr \"type\" \"msklog\")\n+   (set_attr \"prefix\" \"vex\")])\n+\n ;; See comment for addsi_1_zext why we do use nonimmediate_operand\n ;; ??? Special case for immediate operand is missing - it is tricky.\n (define_insn \"*<code>si_2_zext\"\n@@ -8640,23 +8822,38 @@\n   \"ix86_expand_unary_operator (NOT, <MODE>mode, operands); DONE;\")\n \n (define_insn \"*one_cmpl<mode>2_1\"\n-  [(set (match_operand:SWI248 0 \"nonimmediate_operand\" \"=rm\")\n-\t(not:SWI248 (match_operand:SWI248 1 \"nonimmediate_operand\" \"0\")))]\n+  [(set (match_operand:SWI48 0 \"nonimmediate_operand\" \"=rm\")\n+\t(not:SWI48 (match_operand:SWI48 1 \"nonimmediate_operand\" \"0\")))]\n   \"ix86_unary_operator_ok (NOT, <MODE>mode, operands)\"\n   \"not{<imodesuffix>}\\t%0\"\n   [(set_attr \"type\" \"negnot\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n+(define_insn \"*one_cmplhi2_1\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm,!Yk\")\n+\t(not:HI (match_operand:HI 1 \"nonimmediate_operand\" \"0,Yk\")))]\n+  \"ix86_unary_operator_ok (NOT, HImode, operands)\"\n+  \"@\n+   not{w}\\t%0\n+   knotw\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"isa\" \"*,avx512f\")\n+   (set_attr \"type\" \"negnot,msklog\")\n+   (set_attr \"prefix\" \"*,vex\")\n+   (set_attr \"mode\" \"HI\")])\n+\n ;; %%% Potential partial reg stall on alternative 1.  What to do?\n (define_insn \"*one_cmplqi2_1\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm,r\")\n-\t(not:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0,0\")))]\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm,r,!Yk\")\n+\t(not:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0,0,Yk\")))]\n   \"ix86_unary_operator_ok (NOT, QImode, operands)\"\n   \"@\n    not{b}\\t%0\n-   not{l}\\t%k0\"\n-  [(set_attr \"type\" \"negnot\")\n-   (set_attr \"mode\" \"QI,SI\")])\n+   not{l}\\t%k0\n+   knotw\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"isa\" \"*,*,avx512f\")\n+   (set_attr \"type\" \"negnot,negnot,msklog\")\n+   (set_attr \"prefix\" \"*,*,vex\")\n+   (set_attr \"mode\" \"QI,SI,QI\")])\n \n ;; ??? Currently never generated - xor is used instead.\n (define_insn \"*one_cmplsi2_1_zext\"\n@@ -16423,11 +16620,11 @@\n })\n \n ;; Avoid redundant prefixes by splitting HImode arithmetic to SImode.\n-\n+;; Do not split instructions with mask registers.\n (define_split\n-  [(set (match_operand 0 \"register_operand\")\n+  [(set (match_operand 0 \"general_reg_operand\")\n \t(match_operator 3 \"promotable_binary_operator\"\n-\t   [(match_operand 1 \"register_operand\")\n+\t   [(match_operand 1 \"general_reg_operand\")\n \t    (match_operand 2 \"aligned_operand\")]))\n    (clobber (reg:CC FLAGS_REG))]\n   \"! TARGET_PARTIAL_REG_STALL && reload_completed\n@@ -16522,9 +16719,10 @@\n   operands[1] = gen_lowpart (SImode, operands[1]);\n })\n \n+;; Do not split instructions with mask regs.\n (define_split\n-  [(set (match_operand 0 \"register_operand\")\n-\t(not (match_operand 1 \"register_operand\")))]\n+  [(set (match_operand 0 \"general_reg_operand\")\n+\t(not (match_operand 1 \"general_reg_operand\")))]\n   \"! TARGET_PARTIAL_REG_STALL && reload_completed\n    && (GET_MODE (operands[0]) == HImode\n        || (GET_MODE (operands[0]) == QImode"}, {"sha": "18f425c4b8729796fa64a82032d9d4780acc93d7", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a772214402901c17d47196add4c508e25866c2/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a772214402901c17d47196add4c508e25866c2/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=85a772214402901c17d47196add4c508e25866c2", "patch": "@@ -32,6 +32,11 @@\n   (and (match_code \"reg\")\n        (not (match_test \"ANY_FP_REGNO_P (REGNO (op))\"))))\n \n+;; True if the operand is a GENERAL class register.\n+(define_predicate \"general_reg_operand\"\n+  (and (match_code \"reg\")\n+       (match_test \"GENERAL_REG_P (op)\")))\n+\n ;; Return true if OP is a register operand other than an i387 fp register.\n (define_predicate \"register_and_not_fp_reg_operand\"\n   (and (match_code \"reg\")\n@@ -52,6 +57,10 @@\n   (and (match_code \"reg\")\n        (match_test \"EXT_REX_SSE_REGNO_P (REGNO (op))\")))\n \n+;; True if the operand is an AVX-512 mask register.\n+(define_predicate \"mask_reg_operand\"\n+  (and (match_code \"reg\")\n+       (match_test \"MASK_REGNO_P (REGNO (op))\")))\n \n ;; True if the operand is a Q_REGS class register.\n (define_predicate \"q_regs_operand\""}]}