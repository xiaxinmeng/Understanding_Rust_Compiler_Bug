{"sha": "bd0485f20f4794f9787237706a6308473a8e9415", "node_id": "C_kwDOANBUbNoAKGJkMDQ4NWYyMGY0Nzk0Zjk3ODcyMzc3MDZhNjMwODQ3M2E4ZTk0MTU", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-12-06T23:10:48Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-12-08T18:43:25Z"}, "message": "c++: build initializer_list<string> in a loop [PR105838]\n\nThe previous patch avoided building an initializer_list<string> at all when\nbuilding a vector<string>, but in situations where that isn't possible, we\ncould still build the initializer_list with a loop over a constant array.\n\nThis is represented using a VEC_INIT_EXPR, which required adjusting a couple\nof places that expected the initializer array to have the same type as the\ntarget array and fixing build_vec_init not to undo our efforts.\n\n\tPR c++/105838\n\ngcc/cp/ChangeLog:\n\n\t* call.cc (convert_like_internal) [ck_list]: Use\n\tmaybe_init_list_as_array.\n\t* constexpr.cc (cxx_eval_vec_init_1): Init might have\n\ta different type.\n\t* tree.cc (build_vec_init_elt): Likewise.\n\t* init.cc (build_vec_init): Handle from_array from a\n\tTARGET_EXPR.  Retain TARGET_EXPR of a different type.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/tree-ssa/initlist-opt2.C: New test.", "tree": {"sha": "fce5865dde25c38a2f1d403cf3ba3154b3d0e5f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fce5865dde25c38a2f1d403cf3ba3154b3d0e5f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd0485f20f4794f9787237706a6308473a8e9415", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd0485f20f4794f9787237706a6308473a8e9415", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd0485f20f4794f9787237706a6308473a8e9415", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd0485f20f4794f9787237706a6308473a8e9415/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d081807d8d70e3e87eae41e1560e54d503f4d465", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d081807d8d70e3e87eae41e1560e54d503f4d465", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d081807d8d70e3e87eae41e1560e54d503f4d465"}], "stats": {"total": 56, "additions": 48, "deletions": 8}, "files": [{"sha": "14aa96dd3283d662ab5cad856cb27c9871141195", "filename": "gcc/cp/call.cc", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd0485f20f4794f9787237706a6308473a8e9415/gcc%2Fcp%2Fcall.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd0485f20f4794f9787237706a6308473a8e9415/gcc%2Fcp%2Fcall.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.cc?ref=bd0485f20f4794f9787237706a6308473a8e9415", "patch": "@@ -8501,7 +8501,16 @@ convert_like_internal (conversion *convs, tree expr, tree fn, int argnum,\n \tunsigned len = CONSTRUCTOR_NELTS (expr);\n \ttree array;\n \n-\tif (len)\n+\tif (tree init = maybe_init_list_as_array (elttype, expr))\n+\t  {\n+\t    elttype = cp_build_qualified_type\n+\t      (elttype, cp_type_quals (elttype) | TYPE_QUAL_CONST);\n+\t    array = build_array_of_n_type (elttype, len);\n+\t    array = build_vec_init_expr (array, init, complain);\n+\t    array = get_target_expr (array);\n+\t    array = cp_build_addr_expr (array, complain);\n+\t  }\n+\telse if (len)\n \t  {\n \t    tree val; unsigned ix;\n "}, {"sha": "3f7892aa88a9f9b949eab33c771ce58e1523092c", "filename": "gcc/cp/constexpr.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd0485f20f4794f9787237706a6308473a8e9415/gcc%2Fcp%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd0485f20f4794f9787237706a6308473a8e9415/gcc%2Fcp%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.cc?ref=bd0485f20f4794f9787237706a6308473a8e9415", "patch": "@@ -5255,12 +5255,12 @@ cxx_eval_vec_init_1 (const constexpr_ctx *ctx, tree atype, tree init,\n       else\n \t{\n \t  /* Copying an element.  */\n-\t  gcc_assert (same_type_ignoring_top_level_qualifiers_p\n-\t\t      (atype, TREE_TYPE (init)));\n \t  eltinit = cp_build_array_ref (input_location, init, idx, complain);\n \t  if (!lvalue_p (init))\n \t    eltinit = move (eltinit);\n-\t  eltinit = force_rvalue (eltinit, complain);\n+\t  eltinit = (perform_implicit_conversion_flags\n+\t\t     (elttype, eltinit, complain,\n+\t\t      LOOKUP_IMPLICIT|LOOKUP_NO_NARROWING));\n \t  eltinit = cxx_eval_constant_expression (&new_ctx, eltinit, lval,\n \t\t\t\t\t\t  non_constant_p, overflow_p);\n \t}"}, {"sha": "1ccde7cf8ad20edec6d96cc8ad230db2a56ef7fe", "filename": "gcc/cp/init.cc", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd0485f20f4794f9787237706a6308473a8e9415/gcc%2Fcp%2Finit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd0485f20f4794f9787237706a6308473a8e9415/gcc%2Fcp%2Finit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.cc?ref=bd0485f20f4794f9787237706a6308473a8e9415", "patch": "@@ -4420,7 +4420,9 @@ build_vec_init (tree base, tree maxindex, tree init,\n   /* Look through the TARGET_EXPR around a compound literal.  */\n   if (init && TREE_CODE (init) == TARGET_EXPR\n       && TREE_CODE (TARGET_EXPR_INITIAL (init)) == CONSTRUCTOR\n-      && from_array != 2)\n+      && from_array != 2\n+      && (same_type_ignoring_top_level_qualifiers_p\n+\t  (TREE_TYPE (init), atype)))\n     init = TARGET_EXPR_INITIAL (init);\n \n   if (tree vi = get_vec_init_expr (init))\n@@ -4546,7 +4548,14 @@ build_vec_init (tree base, tree maxindex, tree init,\n     {\n       if (lvalue_kind (init) & clk_rvalueref)\n \txvalue = true;\n-      base2 = decay_conversion (init, complain);\n+      if (TREE_CODE (init) == TARGET_EXPR)\n+\t{\n+\t  /* Avoid error in decay_conversion.  */\n+\t  base2 = decay_conversion (TARGET_EXPR_SLOT (init), complain);\n+\t  base2 = cp_build_compound_expr (init, base2, tf_none);\n+\t}\n+      else\n+\tbase2 = decay_conversion (init, complain);\n       if (base2 == error_mark_node)\n \treturn error_mark_node;\n       itype = TREE_TYPE (base2);"}, {"sha": "a600178239cd9bdbbcd0fd92a8c077206388d41c", "filename": "gcc/cp/tree.cc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd0485f20f4794f9787237706a6308473a8e9415/gcc%2Fcp%2Ftree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd0485f20f4794f9787237706a6308473a8e9415/gcc%2Fcp%2Ftree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.cc?ref=bd0485f20f4794f9787237706a6308473a8e9415", "patch": "@@ -785,8 +785,6 @@ build_vec_init_elt (tree type, tree init, tsubst_flags_t complain)\n   releasing_vec argvec;\n   if (init && !BRACE_ENCLOSED_INITIALIZER_P (init))\n     {\n-      gcc_assert (same_type_ignoring_top_level_qualifiers_p\n-\t\t  (type, TREE_TYPE (init)));\n       tree init_type = strip_array_types (TREE_TYPE (init));\n       tree dummy = build_dummy_object (init_type);\n       if (!lvalue_p (init))"}, {"sha": "fc928bb540501d0df8d56b303a5d5f73fba74a55", "filename": "gcc/testsuite/g++.dg/tree-ssa/initlist-opt2.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd0485f20f4794f9787237706a6308473a8e9415/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Finitlist-opt2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd0485f20f4794f9787237706a6308473a8e9415/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Finitlist-opt2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Finitlist-opt2.C?ref=bd0485f20f4794f9787237706a6308473a8e9415", "patch": "@@ -0,0 +1,24 @@\n+// PR c++/105838\n+// { dg-additional-options -fdump-tree-gimple }\n+// { dg-do compile { target c++11 } }\n+\n+// Check that we call the basic_string constructor once (and define it once).\n+// { dg-final { scan-tree-dump-times {>::basic_string} 2 \"gimple\" } }\n+\n+#include <string>\n+\n+void g (const void *);\n+\n+void f (const char *p)\n+{\n+  std::initializer_list<std::string> lst = {\n+  \"aahing\", \"aaliis\", \"aarrgh\", \"abacas\", \"abacus\", \"abakas\", \"abamps\", \"abands\", \"abased\", \"abaser\", \"abases\", \"abasia\",\n+  \"abated\", \"abater\", \"abates\", \"abatis\", \"abator\", \"abattu\", \"abayas\", \"abbacy\", \"abbess\", \"abbeys\", \"abbots\", \"abcees\",\n+  \"abdabs\", \"abduce\", \"abduct\", \"abears\", \"abeigh\", \"abeles\", \"abelia\", \"abends\", \"abhors\", \"abided\", \"abider\", \"abides\",\n+  \"abject\", \"abjure\", \"ablate\", \"ablaut\", \"ablaze\", \"ablest\", \"ablets\", \"abling\", \"ablins\", \"abloom\", \"ablush\", \"abmhos\",\n+  \"aboard\", \"aboded\", \"abodes\", \"abohms\", \"abolla\", \"abomas\", \"aboral\", \"abords\", \"aborne\", \"aborts\", \"abound\", \"abouts\",\n+  \"aboves\", \"abrade\", \"abraid\", \"abrash\", \"abrays\", \"abrazo\", \"abrege\", \"abrins\", \"abroad\", \"abrupt\", \"abseil\", \"absent\",\n+  };\n+\n+  g(&lst);\n+}"}]}