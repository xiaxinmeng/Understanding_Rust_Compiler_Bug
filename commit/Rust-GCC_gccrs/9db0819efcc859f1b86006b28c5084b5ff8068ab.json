{"sha": "9db0819efcc859f1b86006b28c5084b5ff8068ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWRiMDgxOWVmY2M4NTlmMWI4NjAwNmIyOGM1MDg0YjVmZjgwNjhhYg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-01-07T09:42:49Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-01-07T09:42:49Z"}, "message": "Makefile.in (DRIVER_DEFINES): Define ENABLE_SHARED_LIBGCC and NO_SHARED_LIBGCC_MULTILIB as required for the...\n\n        * Makefile.in (DRIVER_DEFINES): Define ENABLE_SHARED_LIBGCC and\n        NO_SHARED_LIBGCC_MULTILIB as required for the target.\n        * gcc.c (init_spec): Massage the existing libgcc_spec into a\n        variant that handles a shared libgcc.\n        (process_command): Always validate -{static,shared}-libgcc.\n        (do_spec_1): New 'M' case.\n        * invoke.text (Link Options): Document -{static,shared}-libgcc.\n\nFrom-SVN: r38762", "tree": {"sha": "f39bc2df99af0a24cd634620376f299d4b678975", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f39bc2df99af0a24cd634620376f299d4b678975"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9db0819efcc859f1b86006b28c5084b5ff8068ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9db0819efcc859f1b86006b28c5084b5ff8068ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9db0819efcc859f1b86006b28c5084b5ff8068ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9db0819efcc859f1b86006b28c5084b5ff8068ab/comments", "author": null, "committer": null, "parents": [{"sha": "2bbea3a6c7e33c373b99411c1e6e2f67c5358fac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bbea3a6c7e33c373b99411c1e6e2f67c5358fac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bbea3a6c7e33c373b99411c1e6e2f67c5358fac"}], "stats": {"total": 141, "additions": 134, "deletions": 7}, "files": [{"sha": "c2fdbf949c18b82dd60a03cdf296fa485633728c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9db0819efcc859f1b86006b28c5084b5ff8068ab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9db0819efcc859f1b86006b28c5084b5ff8068ab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9db0819efcc859f1b86006b28c5084b5ff8068ab", "patch": "@@ -1,3 +1,13 @@\n+2001-01-07  Richard Henderson  <rth@redhat.com>\n+\n+\t* Makefile.in (DRIVER_DEFINES): Define ENABLE_SHARED_LIBGCC and\n+\tNO_SHARED_LIBGCC_MULTILIB as required for the target.\n+\t* gcc.c (init_spec): Massage the existing libgcc_spec into a\n+\tvariant that handles a shared libgcc.\n+\t(process_command): Always validate -{static,shared}-libgcc.\n+\t(do_spec_1): New 'M' case.\n+\t* invoke.text (Link Options): Document -{static,shared}-libgcc.\n+\n 2001-01-07  Richard Henderson  <rth@redhat.com>\n \n \t* Makefile.in (slibdir): New variable."}, {"sha": "74ced6eafabcab7b4ae1d49ab3aac5fcd5376c15", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9db0819efcc859f1b86006b28c5084b5ff8068ab/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9db0819efcc859f1b86006b28c5084b5ff8068ab/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=9db0819efcc859f1b86006b28c5084b5ff8068ab", "patch": "@@ -1248,7 +1248,10 @@ DRIVER_DEFINES = \\\n   -DDEFAULT_TARGET_VERSION=\\\"$(version)\\\" \\\n   -DDEFAULT_TARGET_MACHINE=\\\"$(target_alias)\\\" \\\n   -DSTANDARD_BINDIR_PREFIX=\\\"$(bindir)/\\\" \\\n-  -DTOOLDIR_BASE_PREFIX=\\\"$(unlibsubdir)/../\\\"\n+  -DTOOLDIR_BASE_PREFIX=\\\"$(unlibsubdir)/../\\\" \\\n+  `test \"$SHLIB_LINK\" -a \"@enable_shared@\" = \"yes\" && echo \"-DENABLE_SHARED_LIBGCC\"` \\\n+  `test \"$SHLIB_MULTILIB\" && echo \"-DNO_SHARED_LIBGCC_MULTILIB\"`\n+\n gcc.o: gcc.c $(CONFIG_H) system.h intl.h multilib.h \\\n     Makefile $(lang_specs_files) prefix.h $(GCC_H)\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\"}, {"sha": "9d73608fa5a6f605b260661894807748abd14669", "filename": "gcc/gcc.c", "status": "modified", "additions": 100, "deletions": 5, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9db0819efcc859f1b86006b28c5084b5ff8068ab/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9db0819efcc859f1b86006b28c5084b5ff8068ab/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=9db0819efcc859f1b86006b28c5084b5ff8068ab", "patch": "@@ -373,10 +373,12 @@ or with constant text in a single argument.\n  %l     process LINK_SPEC as a spec.\n  %L     process LIB_SPEC as a spec.\n  %G     process LIBGCC_SPEC as a spec.\n+ %M     output multilib_dir with directory separators replaced with \"_\";\n+\tif multilib_dir is not set or is \".\", output \"\".\n  %S     process STARTFILE_SPEC as a spec.  A capital S is actually used here.\n  %E     process ENDFILE_SPEC as a spec.  A capital E is actually used here.\n  %c\tprocess SIGNED_CHAR_SPEC as a spec.\n- %C     process CPP_SPEC as a spec.  A capital C is actually used here.\n+ %C     process CPP_SPEC as a spec.\n  %1\tprocess CC1_SPEC as a spec.\n  %2\tprocess CC1PLUS_SPEC as a spec.\n  %|\toutput \"-\" if the input for the current command is coming from a pipe.\n@@ -1283,6 +1285,80 @@ init_spec ()\n       next = sl;\n     }\n \n+#ifdef ENABLE_SHARED_LIBGCC\n+  /* ??? If neither -shared-libgcc nor --static-libgcc was\n+     seen, then we should be making an educated guess.  Some proposed\n+     heuristics for ELF include:\n+\n+\t(1) If \"-Wl,--export-dynamic\", then it's a fair bet that the\n+\t    program will be doing dynamic loading, which will likely\n+\t    need the shared libgcc.\n+\n+\t(2) If \"-ldl\", then it's also a fair bet that we're doing\n+\t    dynamic loading.\n+\n+\t(3) For each ET_DYN we're linking against (either through -lfoo\n+\t    or /some/path/foo.so), check to see whether it or one of\n+\t    its dependancies depends on a shared libgcc.\n+\n+\t(4) If \"-shared\"\n+\n+\t    If the runtime is fixed to look for program headers instead\n+\t    of calling __register_frame_info at all, for each object,\n+\t    use the shared libgcc if any EH symbol referenced.\n+\n+\t    If crtstuff is fixed to not invoke __register_frame_info\n+\t    automatically, for each object, use the shared libgcc if\n+\t    any non-empty unwind section found.\n+\n+     Doing any of this probably requires invoking an external program to\n+     do the actual object file scanning.  */\n+  {\n+    const char *p = libgcc_spec;\n+    int in_sep = 1;\n+ \n+    /* Transform the extant libgcc_spec into one that uses the shared libgcc\n+       when given the proper command line arguments.  */\n+    while (*p)\n+      {\n+\tconst char *r;\n+        if (in_sep && *p == '-' && strncmp (p, \"-lgcc\", 5) == 0)\n+\t  {\n+#ifdef NO_SHARED_LIBGCC_MULTILIB\n+\t    r = \"%{shared-libgcc:-lgcc_s}%{!shared-libgcc:-lgcc}\";\n+#else\n+\t    r = \"%{shared-libgcc:-lgcc_s%M}%{!shared-libgcc:-lgcc}\";\n+#endif\n+\t    obstack_grow (&obstack, r, strlen(r));\n+\t    p += 5;\n+\t    in_sep = 0;\n+\t  }\n+\telse if (in_sep && *p == 'l' && strncmp (p, \"libgcc.a%s\", 10) == 0)\n+\t  {\n+\t    /* Ug.  We don't know shared library extensions.  Hope that\n+\t       systems that use this form don't do shared libraries.  */\n+#ifdef NO_SHARED_LIBGCC_MULTILIB\n+\t    r = \"%{shared-libgcc:-lgcc_s}%{!shared-libgcc:libgcc.a%s}\";\n+#else\n+\t    r = \"%{shared-libgcc:-lgcc_s%M}%{!shared-libgcc:libgcc.a%s}\";\n+#endif\n+\t    obstack_grow (&obstack, r, strlen(r));\n+\t    p += 10;\n+\t    in_sep = 0;\n+\t  }\n+\telse\n+\t  {\n+\t    obstack_1grow (&obstack, *p);\n+\t    in_sep = (*p == ' ');\n+\t    p += 1;\n+\t  }\n+      }\n+\n+    obstack_1grow (&obstack, '\\0');\n+    libgcc_spec = obstack_finish (&obstack);\n+  }\n+#endif\n+\n   specs = sl;\n }\n \f\n@@ -3552,7 +3628,7 @@ process_command (argc, argv)\n            switches[n_switches].part1     = \"--target-help\";\n            switches[n_switches].args      = 0;\n            switches[n_switches].live_cond = SWITCH_OK;\n-           switches[n_switches].validated     = 0;\n+           switches[n_switches].validated = 0;\n \n            n_switches++;\n         }\n@@ -3570,7 +3646,7 @@ process_command (argc, argv)\n \t      switches[n_switches].part1     = \"--help\";\n \t      switches[n_switches].args      = 0;\n \t      switches[n_switches].live_cond = SWITCH_OK;\n-\t      switches[n_switches].validated     = 0;\n+\t      switches[n_switches].validated = 0;\n \n \t      n_switches++;\n \t    }\n@@ -3697,8 +3773,10 @@ process_command (argc, argv)\n \n \t  switches[n_switches].live_cond = SWITCH_OK;\n \t  switches[n_switches].validated = 0;\n-\t  /* This is always valid, since gcc.c itself understands it.  */\n-\t  if (!strcmp (p, \"save-temps\"))\n+\t  /* These are always valid, since gcc.c itself understands it.  */\n+\t  if (!strcmp (p, \"save-temps\")\n+\t      || !strcmp (p, \"static-libgcc\")\n+\t      || !strcmp (p, \"shared-libgcc\"))\n \t    switches[n_switches].validated = 1;\n \t  else\n \t    {\n@@ -4346,6 +4424,23 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t      return value;\n \t    break;\n \n+\t  case 'M':\n+\t    if (multilib_dir && strcmp (multilib_dir, \".\") != 0)\n+\t      {\n+\t\tchar *p;\n+\t\tconst char *q;\n+\t\tsize_t len;\n+\n+\t\tlen = strlen (multilib_dir);\n+\t\tobstack_blank (&obstack, len + 1);\n+\t\tp = obstack_next_free (&obstack) - len;\n+\n+\t\t*p++ = '_';\n+\t\tfor (q = multilib_dir; *q ; ++q, ++p)\n+\t\t  *p = (IS_DIR_SEPARATOR (*q) ? '_' : *q);\n+\t      }\n+\t    break;\n+\n \t  case 'p':\n \t    {\n \t      char *x = (char *) alloca (strlen (cpp_predefines) + 1);"}, {"sha": "941029f0074aaf4b1cbefe4f304e25350baf23a0", "filename": "gcc/invoke.texi", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9db0819efcc859f1b86006b28c5084b5ff8068ab/gcc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9db0819efcc859f1b86006b28c5084b5ff8068ab/gcc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finvoke.texi?ref=9db0819efcc859f1b86006b28c5084b5ff8068ab", "patch": "@@ -276,7 +276,7 @@ in the following sections.\n @smallexample\n @var{object-file-name}  -l@var{library}\n -nostartfiles  -nodefaultlibs  -nostdlib\n--s  -static  -shared  -symbolic\n+-s  -static  -static-libgcc  -shared  -shared-libgcc  -symbolic\n -Wl,@var{option}  -Xlinker @var{option}\n -u @var{symbol}\n @end smallexample\n@@ -3502,6 +3502,25 @@ libraries to link against.  Failing to supply the correct flags may lead\n to subtle defects. Supplying them in cases where they are not necessary\n is innocuous.}\n \n+@item -shared-libgcc\n+@itemx -static-libgcc\n+On systems that provide @file{libgcc} as a shared library, these options\n+force the use of either the shared or static version respectively.\n+If no shared version of @file{libgcc} was built when the compiler was\n+configured, these options have no effect.\n+\n+There are several situations in which an application should use the\n+shared @file{libgcc} instead of the static version.  The most common\n+of these is when the application wishes to throw and catch exceptions\n+across different shared libraries.  In that case, each of the libraries\n+as well as the application itself should use the shared @file{libgcc}.\n+\n+At present the GCC driver makes no attempt to recognize the situations\n+in which the shared @file{libgcc} should be used, and defaults to using\n+the static @file{libgcc} always.  This will likely change in the future,\n+at which time @samp{-static-libgcc} becomes useful as a means for \n+overriding GCC's choice.\n+\n @item -symbolic\n Bind references to global symbols when building a shared object.  Warn\n about any unresolved references (unless overridden by the link editor"}]}