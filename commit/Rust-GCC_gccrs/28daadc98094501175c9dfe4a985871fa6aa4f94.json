{"sha": "28daadc98094501175c9dfe4a985871fa6aa4f94", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjhkYWFkYzk4MDk0NTAxMTc1YzlkZmU0YTk4NTg3MWZhNmFhNGY5NA==", "commit": {"author": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2021-01-06T08:33:27Z"}, "committer": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2021-06-01T01:58:14Z"}, "message": "Extend is_cond_scalar_reduction to handle nop_expr after/before scalar reduction.[PR98365]\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/98365\n\t* tree-if-conv.c (strip_nop_cond_scalar_reduction): New function.\n\t(is_cond_scalar_reduction): Handle nop_expr in cond scalar reduction.\n\t(convert_scalar_cond_reduction): Ditto.\n\t(predicate_scalar_phi): Ditto.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/98365\n\t* gcc.target/i386/pr98365.c: New test.", "tree": {"sha": "54832e2f67bb6faa9e11f4c0f7df11b35a98183c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/54832e2f67bb6faa9e11f4c0f7df11b35a98183c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/28daadc98094501175c9dfe4a985871fa6aa4f94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28daadc98094501175c9dfe4a985871fa6aa4f94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28daadc98094501175c9dfe4a985871fa6aa4f94", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28daadc98094501175c9dfe4a985871fa6aa4f94/comments", "author": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "committer": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "715914d3f9e4e40af58d22103c7650cdd720ef92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/715914d3f9e4e40af58d22103c7650cdd720ef92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/715914d3f9e4e40af58d22103c7650cdd720ef92"}], "stats": {"total": 164, "additions": 146, "deletions": 18}, "files": [{"sha": "652210dcdd5da9c4aaa34a14480b3430995df583", "filename": "gcc/testsuite/gcc.target/i386/pr98365.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28daadc98094501175c9dfe4a985871fa6aa4f94/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr98365.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28daadc98094501175c9dfe4a985871fa6aa4f94/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr98365.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr98365.c?ref=28daadc98094501175c9dfe4a985871fa6aa4f94", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mavx2 -ftree-vectorize -fdump-tree-vect-details\" } */\n+/* { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 2 \"vect\" } } */\n+short foo1 (short* a, short* c, int n)\n+{\n+  int i;\n+  short cnt=0;\n+  for (int i = 0;i != n; i++)\n+    if (a[i] == c[i])\n+      cnt++;\n+  return cnt;\n+}\n+\n+char foo2 (char* a, char* c, int n)\n+{\n+  int i;\n+  char cnt=0;\n+  for (int i = 0;i != n; i++)\n+    if (a[i] == c[i])\n+      cnt++;\n+  return cnt;\n+}"}, {"sha": "345488e2a19eb4657f830764b99d2b2423c8cbbf", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 124, "deletions": 18, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28daadc98094501175c9dfe4a985871fa6aa4f94/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28daadc98094501175c9dfe4a985871fa6aa4f94/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=28daadc98094501175c9dfe4a985871fa6aa4f94", "patch": "@@ -1579,6 +1579,31 @@ if_convertible_loop_p (class loop *loop)\n   return res;\n }\n \n+/* Return reduc_1 if has_nop.\n+\n+   if (...)\n+     tmp1 = (unsigned type) reduc_1;\n+     tmp2 = tmp1 + rhs2;\n+     reduc_3 = (signed type) tmp2.  */\n+static tree\n+strip_nop_cond_scalar_reduction (bool has_nop, tree op)\n+{\n+  if (!has_nop)\n+    return op;\n+\n+  if (TREE_CODE (op) != SSA_NAME)\n+    return NULL_TREE;\n+\n+  gassign *stmt = safe_dyn_cast <gassign *> (SSA_NAME_DEF_STMT (op));\n+  if (!stmt\n+      || !CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (stmt))\n+      || !tree_nop_conversion_p (TREE_TYPE (op), TREE_TYPE\n+\t\t\t\t (gimple_assign_rhs1 (stmt))))\n+    return NULL_TREE;\n+\n+  return gimple_assign_rhs1 (stmt);\n+}\n+\n /* Returns true if def-stmt for phi argument ARG is simple increment/decrement\n    which is in predicated basic block.\n    In fact, the following PHI pattern is searching:\n@@ -1595,9 +1620,10 @@ if_convertible_loop_p (class loop *loop)\n \n static bool\n is_cond_scalar_reduction (gimple *phi, gimple **reduc, tree arg_0, tree arg_1,\n-\t\t\t  tree *op0, tree *op1, bool extended)\n+\t\t\t  tree *op0, tree *op1, bool extended, bool* has_nop,\n+\t\t\t  gimple **nop_reduc)\n {\n-  tree lhs, r_op1, r_op2;\n+  tree lhs, r_op1, r_op2, r_nop1, r_nop2;\n   gimple *stmt;\n   gimple *header_phi = NULL;\n   enum tree_code reduction_op;\n@@ -1608,7 +1634,7 @@ is_cond_scalar_reduction (gimple *phi, gimple **reduc, tree arg_0, tree arg_1,\n   use_operand_p use_p;\n   edge e;\n   edge_iterator ei;\n-  bool result = false;\n+  bool result = *has_nop = false;\n   if (TREE_CODE (arg_0) != SSA_NAME || TREE_CODE (arg_1) != SSA_NAME)\n     return false;\n \n@@ -1656,18 +1682,77 @@ is_cond_scalar_reduction (gimple *phi, gimple **reduc, tree arg_0, tree arg_1,\n     return false;\n \n   reduction_op = gimple_assign_rhs_code (stmt);\n+\n+    /* Catch something like below\n+\n+     loop-header:\n+     reduc_1 = PHI <..., reduc_2>\n+     ...\n+     if (...)\n+     tmp1 = (unsigned type) reduc_1;\n+     tmp2 = tmp1 + rhs2;\n+     reduc_3 = (signed type) tmp2;\n+\n+     reduc_2 = PHI <reduc_1, reduc_3>\n+\n+     and convert to\n+\n+     reduc_2 = PHI <0, reduc_3>\n+     tmp1 = (unsigned type)reduce_1;\n+     ifcvt = cond_expr ? rhs2 : 0\n+     tmp2 = tmp1 +/- ifcvt;\n+     reduce_1 = (signed type)tmp2;  */\n+\n+  if (CONVERT_EXPR_CODE_P (reduction_op))\n+    {\n+      lhs = gimple_assign_rhs1 (stmt);\n+      if (TREE_CODE (lhs) != SSA_NAME\n+\t  || !has_single_use (lhs))\n+\treturn false;\n+\n+      *nop_reduc = stmt;\n+      stmt = SSA_NAME_DEF_STMT (lhs);\n+      if (gimple_bb (stmt) != gimple_bb (*nop_reduc)\n+\t  || !is_gimple_assign (stmt))\n+\treturn false;\n+\n+      *has_nop = true;\n+      reduction_op = gimple_assign_rhs_code (stmt);\n+    }\n+\n   if (reduction_op != PLUS_EXPR && reduction_op != MINUS_EXPR)\n     return false;\n   r_op1 = gimple_assign_rhs1 (stmt);\n   r_op2 = gimple_assign_rhs2 (stmt);\n \n+  r_nop1 = strip_nop_cond_scalar_reduction (*has_nop, r_op1);\n+  r_nop2 = strip_nop_cond_scalar_reduction (*has_nop, r_op2);\n+\n   /* Make R_OP1 to hold reduction variable.  */\n-  if (r_op2 == PHI_RESULT (header_phi)\n+  if (r_nop2 == PHI_RESULT (header_phi)\n       && reduction_op == PLUS_EXPR)\n-    std::swap (r_op1, r_op2);\n-  else if (r_op1 != PHI_RESULT (header_phi))\n+    {\n+      std::swap (r_op1, r_op2);\n+      std::swap (r_nop1, r_nop2);\n+    }\n+  else if (r_nop1 != PHI_RESULT (header_phi))\n     return false;\n \n+  if (*has_nop)\n+    {\n+      /* Check that R_NOP1 is used in nop_stmt or in PHI only.  */\n+      FOR_EACH_IMM_USE_FAST (use_p, imm_iter, r_nop1)\n+\t{\n+\t  gimple *use_stmt = USE_STMT (use_p);\n+\t  if (is_gimple_debug (use_stmt))\n+\t    continue;\n+\t  if (use_stmt == SSA_NAME_DEF_STMT (r_op1))\n+\t    continue;\n+\t  if (use_stmt != phi)\n+\t    return false;\n+\t}\n+    }\n+\n   /* Check that R_OP1 is used in reduction stmt or in PHI only.  */\n   FOR_EACH_IMM_USE_FAST (use_p, imm_iter, r_op1)\n     {\n@@ -1705,7 +1790,8 @@ is_cond_scalar_reduction (gimple *phi, gimple **reduc, tree arg_0, tree arg_1,\n \n static tree\n convert_scalar_cond_reduction (gimple *reduc, gimple_stmt_iterator *gsi,\n-\t\t\t       tree cond, tree op0, tree op1, bool swap)\n+\t\t\t       tree cond, tree op0, tree op1, bool swap,\n+\t\t\t       bool has_nop, gimple* nop_reduc)\n {\n   gimple_stmt_iterator stmt_it;\n   gimple *new_assign;\n@@ -1714,6 +1800,7 @@ convert_scalar_cond_reduction (gimple *reduc, gimple_stmt_iterator *gsi,\n   tree tmp = make_temp_ssa_name (TREE_TYPE (rhs1), NULL, \"_ifc_\");\n   tree c;\n   tree zero = build_zero_cst (TREE_TYPE (rhs1));\n+  gimple_seq stmts = NULL;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -1732,8 +1819,18 @@ convert_scalar_cond_reduction (gimple *reduc, gimple_stmt_iterator *gsi,\n   new_assign = gimple_build_assign (tmp, c);\n   gsi_insert_before (gsi, new_assign, GSI_SAME_STMT);\n   /* Build rhs for unconditional increment/decrement.  */\n-  rhs = fold_build2 (gimple_assign_rhs_code (reduc),\n-\t\t     TREE_TYPE (rhs1), op0, tmp);\n+  rhs = gimple_build (&stmts, gimple_assign_rhs_code (reduc),\n+\t\t      TREE_TYPE (rhs1), op0, tmp);\n+\n+  if (has_nop)\n+    {\n+      rhs = gimple_convert (&stmts,\n+\t\t\t    TREE_TYPE (gimple_assign_lhs (nop_reduc)), rhs);\n+      stmt_it = gsi_for_stmt (nop_reduc);\n+      gsi_remove (&stmt_it, true);\n+      release_defs (nop_reduc);\n+    }\n+  gsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n \n   /* Delete original reduction stmt.  */\n   stmt_it = gsi_for_stmt (reduc);\n@@ -1808,14 +1905,15 @@ ifcvt_follow_ssa_use_edges (tree val)\n static void\n predicate_scalar_phi (gphi *phi, gimple_stmt_iterator *gsi)\n {\n-  gimple *new_stmt = NULL, *reduc;\n+  gimple *new_stmt = NULL, *reduc, *nop_reduc;\n   tree rhs, res, arg0, arg1, op0, op1, scev;\n   tree cond;\n   unsigned int index0;\n   unsigned int max, args_len;\n   edge e;\n   basic_block bb;\n   unsigned int i;\n+  bool has_nop;\n \n   res = gimple_phi_result (phi);\n   if (virtual_operand_p (res))\n@@ -1876,10 +1974,15 @@ predicate_scalar_phi (gphi *phi, gimple_stmt_iterator *gsi)\n \t  arg1 = gimple_phi_arg_def (phi, 1);\n \t}\n       if (is_cond_scalar_reduction (phi, &reduc, arg0, arg1,\n-\t\t\t\t    &op0, &op1, false))\n-\t/* Convert reduction stmt into vectorizable form.  */\n-\trhs = convert_scalar_cond_reduction (reduc, gsi, cond, op0, op1,\n-\t\t\t\t\t     true_bb != gimple_bb (reduc));\n+\t\t\t\t    &op0, &op1, false, &has_nop,\n+\t\t\t\t    &nop_reduc))\n+\t{\n+\t  /* Convert reduction stmt into vectorizable form.  */\n+\t  rhs = convert_scalar_cond_reduction (reduc, gsi, cond, op0, op1,\n+\t\t\t\t\t       true_bb != gimple_bb (reduc),\n+\t\t\t\t\t       has_nop, nop_reduc);\n+\t  redundant_ssa_names.safe_push (std::make_pair (res, rhs));\n+\t}\n       else\n \t/* Build new RHS using selected condition and arguments.  */\n \trhs = fold_build_cond_expr (TREE_TYPE (res), unshare_expr (cond),\n@@ -1961,14 +2064,17 @@ predicate_scalar_phi (gphi *phi, gimple_stmt_iterator *gsi)\n \t\t\t\t\t is_gimple_condexpr, NULL_TREE,\n \t\t\t\t\t true, GSI_SAME_STMT);\n       if (!(is_cond_scalar_reduction (phi, &reduc, arg0 , arg1,\n-\t\t\t\t      &op0, &op1, true)))\n+\t\t\t\t      &op0, &op1, true, &has_nop, &nop_reduc)))\n \trhs = fold_build_cond_expr (TREE_TYPE (res), unshare_expr (cond),\n \t\t\t\t    swap? arg1 : arg0,\n \t\t\t\t    swap? arg0 : arg1);\n       else\n-\t/* Convert reduction stmt into vectorizable form.  */\n-\trhs = convert_scalar_cond_reduction (reduc, gsi, cond, op0, op1,\n-\t\t\t\t\t     swap);\n+\t{\n+\t  /* Convert reduction stmt into vectorizable form.  */\n+\t  rhs = convert_scalar_cond_reduction (reduc, gsi, cond, op0, op1,\n+\t\t\t\t\t       swap,has_nop, nop_reduc);\n+\t  redundant_ssa_names.safe_push (std::make_pair (res, rhs));\n+\t}\n       new_stmt = gimple_build_assign (res, rhs);\n       gsi_insert_before (gsi, new_stmt, GSI_SAME_STMT);\n       update_stmt (new_stmt);"}]}