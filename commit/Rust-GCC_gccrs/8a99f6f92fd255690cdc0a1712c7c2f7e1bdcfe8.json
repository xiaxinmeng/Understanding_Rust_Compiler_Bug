{"sha": "8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGE5OWY2ZjkyZmQyNTU2OTBjZGMwYTE3MTJjN2MyZjdlMWJkY2ZlOA==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@st.com", "date": "2005-11-24T18:55:53Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2005-11-24T18:55:53Z"}, "message": "re PR target/21623 (ICE in reload_cse_simplify_operands, at postreload.c:391)\n\n\tPR target/21623:\n\n\t* regclass.c (FORBIDDEN_INC_DEC_CLASSES): Remove\n\tSECONDARY_INPUT_RELOAD_CLASS and SECONDARY_OUTPUT_RELOAD_CLASS tests.\n\t(init_fake_stack_mems): Remove HAVE_SECONDARY_RELOADS test.\n\t(memory_move_secondary_cost, init_reg_autoinc): Remove\n\tSECONDARY_INPUT_RELOAD_CLASS / SECONDARY_OUTPUT_RELOAD_CLASS tests.\n\tReplace SECONDARY_{IN,OUT}PUT_RELOAD_CLASS use with\n\tsecondary_reload_class call.\n\t(copy_cost): Likewise.  Add new parameter prev_sri.  Changed all\n\tcallers.\n\t* reload.c (entire file): Remove HAVE_SECONDARY_RELOADS checks.\n\t(push_secondary_reload): Use secondary_reload target hook.\n\t(secondary_reload_class, scratch_reload_class): New functions.\n\t(push_reload): Remove SECONDARY_INPUT_RELOAD_CLASS and\n\tSECONDARY_OUTPUT_RELOAD_CLASS tests.  Replace\n\tSECONDARY_{IN,OUT}PUT_RELOAD_CLASS use with secondary_reload_class call.\n\t* reload.h (HAVE_SECONDARY_RELOADS): Don't define nor test.\n\t(secondary_reload_class, scratch_reload_class): Declare.\n\t* reload1.c: Include target.h.\n\t(reload_adjust_reg_for_temp): New function.\n\t(reload_adjust_reg_for_icode): Likewise.\n\t(choose_reload_regs): Remove SECONDARY_INPUT_RELOAD_CLASS test.\n\tReplace SECONDARY_INPUT_RELOAD_CLASS use with secondary_reload_class\n\tcall.\n\t(emit_input_reload_insns): Likewise.  Rewrite secondary reload checks\n\tfor inheritance.  Support case when both secondary & tertiary reloads\n\tare for intermediate registers.\n\t(emit_output_reload_insns): Replace SECONDARY_OUTPUT_RELOAD_CLASS use\n        with secondary_reload_class call.  Support case when both secondary\n\t& tertiary reloads are for intermediate registers.\n\t* target-def.h (TARGET_SECONDARY_RELOAD): Provide default definition.\n\t(TARGET_INITIALIZER) Add TARGET_SECONDARY_RELOAD.\n\t* target.h (secondary_reload_info): New struct / typedef.\n\t(struct gcc_target): New member secondary_reload.\n\t* targhooks.c Include reload.h, optabs.h and recog.h.\n\t(default_secondary_reload): New function.\n\t* targhooks.h (default_secondary_reload): Declare.\n\t* doc/tm.texi: Document secondary_reload target hook.  Update\n\tdescription of SECONDARY_*RELOAD_CLASS and reload_{in,out}<mode>.\n\t* doc/md.texi: Likewise.\n\n\t* sh-protos.h (sh_secondary_reload): Declare.\n\t* sh.c (TARGET_SECONDARY_RELOAD): Override.\n\t(sh_secondary_reload): New function.\n\t* sh.h (SECONDARY_INOUT_RELOAD_CLASS): Don't define.\n\t(SECONDARY_OUTPUT_RELOAD_CLASS): Likewise.\n\t(SECONDARY_INPUT_RELOAD_CLASS): Likewise.\n\t(HAVE_SECONDARY_RELOADS): Define.\n\t* sh.md (reload_indf): Rename to:\n\t(reload_indf__frn).\n\t(reload_outdf): Rename to:\n\t(reload_outdf__RnFRm).\n\t(reload_insf): Rename to:\n\t(reload_insf__frn).\n\t(reload_insi): Rename to:\n\t(reload_insi__i_fpul).\n\nFrom-SVN: r107468", "tree": {"sha": "c4e97f2cd689b954ad779a8f0f2c7757912a91f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c4e97f2cd689b954ad779a8f0f2c7757912a91f8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8/comments", "author": null, "committer": null, "parents": [{"sha": "1a598a979ba864052b8a922d957c038493411e47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a598a979ba864052b8a922d957c038493411e47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a598a979ba864052b8a922d957c038493411e47"}], "stats": {"total": 1015, "additions": 693, "deletions": 322}, "files": [{"sha": "5d869abcd27bde1aeb1951bca133c63fc10387a4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8", "patch": "@@ -1,3 +1,62 @@\n+2005-11-24  J\"orn Rennecke <joern.rennecke@st.com>\n+\tPR target/21623:\n+\n+\t* regclass.c (FORBIDDEN_INC_DEC_CLASSES): Remove\n+\tSECONDARY_INPUT_RELOAD_CLASS and SECONDARY_OUTPUT_RELOAD_CLASS tests.\n+\t(init_fake_stack_mems): Remove HAVE_SECONDARY_RELOADS test.\n+\t(memory_move_secondary_cost, init_reg_autoinc): Remove\n+\tSECONDARY_INPUT_RELOAD_CLASS / SECONDARY_OUTPUT_RELOAD_CLASS tests.\n+\tReplace SECONDARY_{IN,OUT}PUT_RELOAD_CLASS use with\n+\tsecondary_reload_class call.\n+\t(copy_cost): Likewise.  Add new parameter prev_sri.  Changed all\n+\tcallers.\n+\t* reload.c (entire file): Remove HAVE_SECONDARY_RELOADS checks.\n+\t(push_secondary_reload): Use secondary_reload target hook.\n+\t(secondary_reload_class, scratch_reload_class): New functions.\n+\t(push_reload): Remove SECONDARY_INPUT_RELOAD_CLASS and\n+\tSECONDARY_OUTPUT_RELOAD_CLASS tests.  Replace\n+\tSECONDARY_{IN,OUT}PUT_RELOAD_CLASS use with secondary_reload_class call.\n+\t* reload.h (HAVE_SECONDARY_RELOADS): Don't define nor test.\n+\t(secondary_reload_class, scratch_reload_class): Declare.\n+\t* reload1.c: Include target.h.\n+\t(reload_adjust_reg_for_temp): New function.\n+\t(reload_adjust_reg_for_icode): Likewise.\n+\t(choose_reload_regs): Remove SECONDARY_INPUT_RELOAD_CLASS test.\n+\tReplace SECONDARY_INPUT_RELOAD_CLASS use with secondary_reload_class\n+\tcall.\n+\t(emit_input_reload_insns): Likewise.  Rewrite secondary reload checks\n+\tfor inheritance.  Support case when both secondary & tertiary reloads\n+\tare for intermediate registers.\n+\t(emit_output_reload_insns): Replace SECONDARY_OUTPUT_RELOAD_CLASS use\n+        with secondary_reload_class call.  Support case when both secondary\n+\t& tertiary reloads are for intermediate registers.\n+\t* target-def.h (TARGET_SECONDARY_RELOAD): Provide default definition.\n+\t(TARGET_INITIALIZER) Add TARGET_SECONDARY_RELOAD.\n+\t* target.h (secondary_reload_info): New struct / typedef.\n+\t(struct gcc_target): New member secondary_reload.\n+\t* targhooks.c Include reload.h, optabs.h and recog.h.\n+\t(default_secondary_reload): New function.\n+\t* targhooks.h (default_secondary_reload): Declare.\n+\t* doc/tm.texi: Document secondary_reload target hook.  Update\n+\tdescription of SECONDARY_*RELOAD_CLASS and reload_{in,out}<mode>.\n+\t* doc/md.texi: Likewise.\n+\n+\t* sh-protos.h (sh_secondary_reload): Declare.\n+\t* sh.c (TARGET_SECONDARY_RELOAD): Override.\n+\t(sh_secondary_reload): New function.\n+\t* sh.h (SECONDARY_INOUT_RELOAD_CLASS): Don't define.\n+\t(SECONDARY_OUTPUT_RELOAD_CLASS): Likewise.\n+\t(SECONDARY_INPUT_RELOAD_CLASS): Likewise.\n+\t(HAVE_SECONDARY_RELOADS): Define.\n+\t* sh.md (reload_indf): Rename to:\n+\t(reload_indf__frn).\n+\t(reload_outdf): Rename to:\n+\t(reload_outdf__RnFRm).\n+\t(reload_insf): Rename to:\n+\t(reload_insf__frn).\n+\t(reload_insi): Rename to:\n+\t(reload_insi__i_fpul).\n+\n 2005-11-24  Uros Bizjak  <uros@kss-loka.si>\n \n \t* configure.ac: Require at least texinfo 4.4."}, {"sha": "a0661545b56e2130508a0534de81a8bf1f1cfd33", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8", "patch": "@@ -165,6 +165,10 @@ extern int shmedia_cleanup_truncate (rtx *, void *);\n \n extern int sh_contains_memref_p (rtx);\n extern rtx shmedia_prepare_call_address (rtx fnaddr, int is_sibcall);\n+struct secondary_reload_info;\n+extern enum reg_class sh_secondary_reload (bool, rtx, enum reg_class,\n+\t\t\t\t\t   enum machine_mode,\n+\t\t\t\t\t   struct secondary_reload_info *);\n \n #endif /* ! GCC_SH_PROTOS_H */\n "}, {"sha": "1bcf81d8bdc1b4b535248b2d569b1c7a7dde68f6", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8", "patch": "@@ -500,6 +500,9 @@ static int hard_regs_intersect_p (HARD_REG_SET *, HARD_REG_SET *);\n #define TARGET_ADJUST_UNROLL_MAX sh_adjust_unroll_max\n #endif\n \n+#undef TARGET_SECONDARY_RELOAD\n+#define TARGET_SECONDARY_RELOAD sh_secondary_reload\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Implement TARGET_HANDLE_OPTION.  */\n@@ -10672,6 +10675,106 @@ shmedia_prepare_call_address (rtx fnaddr, int is_sibcall)\n   return fnaddr;\n }\n \n+enum reg_class\n+sh_secondary_reload (bool in_p, rtx x, enum reg_class class,\n+\t\t     enum machine_mode mode, secondary_reload_info *sri)\n+{\n+  if (in_p)\n+    {\n+      if (REGCLASS_HAS_FP_REG (class)\n+\t  && ! TARGET_SHMEDIA\n+\t  && immediate_operand ((x), mode)\n+\t  && ! ((fp_zero_operand (x) || fp_one_operand (x))\n+\t\t&& mode == SFmode && fldi_ok ()))\n+\tswitch (mode)\n+\t  {\n+\t  case SFmode:\n+\t    sri->icode = CODE_FOR_reload_insf__frn;\n+\t    return NO_REGS;\n+\t  case DFmode:\n+\t    sri->icode = CODE_FOR_reload_indf__frn;\n+\t    return NO_REGS;\n+\t  case SImode:\n+\t    /* ??? If we knew that we are in the appropriate mode -\n+\t       single precision - we could use a reload pattern directly.  */\n+\t    return FPUL_REGS;\n+\t  default:\n+\t    abort ();\n+\t  }\n+      if (class == FPUL_REGS\n+          && ((GET_CODE (x) == REG\n+               && (REGNO (x) == MACL_REG || REGNO (x) == MACH_REG\n+                   || REGNO (x) == T_REG))\n+              || GET_CODE (x) == PLUS))\n+        return GENERAL_REGS;\n+      if (class == FPUL_REGS && immediate_operand (x, mode))\n+\t{\n+\t  if (GET_CODE (x) == CONST_INT && CONST_OK_FOR_I08 (INTVAL (x)))\n+\t    return GENERAL_REGS;\n+\t  sri->icode = CODE_FOR_reload_insi__i_fpul;\n+\t  return NO_REGS;\n+\t}\n+      if (class == FPSCR_REGS\n+          && ((GET_CODE (x) == REG && REGNO (x) >= FIRST_PSEUDO_REGISTER)\n+              || (GET_CODE (x) == MEM && GET_CODE (XEXP (x, 0)) == PLUS)))\n+        return GENERAL_REGS;\n+      if (REGCLASS_HAS_FP_REG (class)\n+          && TARGET_SHMEDIA\n+          && immediate_operand (x, mode)\n+          && x != CONST0_RTX (GET_MODE (x))\n+          && GET_MODE (x) != V4SFmode)\n+        return GENERAL_REGS;\n+      if ((mode == QImode || mode == HImode)\n+          && TARGET_SHMEDIA && inqhi_operand (x, mode))\n+\t{\n+\t  sri->icode = ((mode == QImode)\n+\t\t\t? CODE_FOR_reload_inqi : CODE_FOR_reload_inhi);\n+\t  return NO_REGS;\n+\t}\n+      if (TARGET_SHMEDIA && class == GENERAL_REGS\n+          && (GET_CODE (x) == LABEL_REF || PIC_DIRECT_ADDR_P (x)))\n+        return TARGET_REGS;\n+    } /* end of input-only processing.  */\n+\n+  if (((REGCLASS_HAS_FP_REG (class)\n+\t&& (GET_CODE (x) == REG\n+\t    && (GENERAL_OR_AP_REGISTER_P (REGNO (x))\n+\t\t|| (FP_REGISTER_P (REGNO (x)) && mode == SImode\n+\t\t    && TARGET_FMOVD))))\n+       || (REGCLASS_HAS_GENERAL_REG (class)\n+\t   && GET_CODE (x) == REG\n+\t   && FP_REGISTER_P (REGNO (x))))\n+      && ! TARGET_SHMEDIA\n+      && (mode == SFmode || mode == SImode))\n+    return FPUL_REGS;\n+  if ((class == FPUL_REGS\n+       || (REGCLASS_HAS_FP_REG (class)\n+           && ! TARGET_SHMEDIA && mode == SImode))\n+      && (GET_CODE (x) == MEM\n+          || (GET_CODE (x) == REG\n+              && (REGNO (x) >= FIRST_PSEUDO_REGISTER\n+                  || REGNO (x) == T_REG\n+                  || system_reg_operand (x, VOIDmode)))))\n+    {\n+      if (class == FPUL_REGS)\n+\treturn GENERAL_REGS;\n+      return FPUL_REGS;\n+    }\n+  if ((class == TARGET_REGS\n+       || (TARGET_SHMEDIA && class == SIBCALL_REGS))\n+      && !EXTRA_CONSTRAINT_Csy (x)\n+      && (GET_CODE (x) != REG || ! GENERAL_REGISTER_P (REGNO (x))))\n+    return GENERAL_REGS;\n+  if ((class == MAC_REGS || class == PR_REGS)\n+      && GET_CODE (x) == REG && ! GENERAL_REGISTER_P (REGNO (x))\n+      && class != REGNO_REG_CLASS (REGNO (x)))\n+    return GENERAL_REGS;\n+  if (class != GENERAL_REGS && GET_CODE (x) == REG\n+      && TARGET_REGISTER_P (REGNO (x)))\n+    return GENERAL_REGS;\n+  return NO_REGS;\n+}\n+\n enum sh_divide_strategy_e sh_div_strategy = SH_DIV_STRATEGY_DEFAULT;\n \n /* This defines the storage for the variable part of a -mboard= option."}, {"sha": "44b9c93c1f7375616b832c352374cccc1138efb1", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8", "patch": "@@ -1604,6 +1604,7 @@ extern enum reg_class reg_class_from_letter[];\n    ? GENERAL_REGS \\\n    : (CLASS)) \\\n \n+#if 0\n #define SECONDARY_INOUT_RELOAD_CLASS(CLASS,MODE,X,ELSE) \\\n   ((((REGCLASS_HAS_FP_REG (CLASS) \t\t\t\t\t\\\n       && (GET_CODE (X) == REG\t\t\t\t\t\t\\\n@@ -1675,6 +1676,9 @@ extern enum reg_class reg_class_from_letter[];\n       && (GET_CODE (X) == LABEL_REF || PIC_DIRECT_ADDR_P (X)))\t\t\\\n    ? TARGET_REGS\t\t\t\t\t\t\t\\\n    : SECONDARY_INOUT_RELOAD_CLASS((CLASS),(MODE),(X), NO_REGS))\n+#else\n+#define HAVE_SECONDARY_RELOADS\n+#endif\n \n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS."}, {"sha": "91e8ff834e8aaded266105810c7104787a80b9c2", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8", "patch": "@@ -5845,15 +5845,15 @@ label:\n \t      (clobber (scratch:SI))])]\n   \"\")\n \n-(define_expand \"reload_indf\"\n-  [(parallel [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+(define_expand \"reload_indf__frn\"\n+  [(parallel [(set (match_operand:DF 0 \"register_operand\" \"=a\")\n \t\t   (match_operand:DF 1 \"immediate_operand\" \"FQ\"))\n \t      (use (reg:PSI FPSCR_REG))\n \t      (clobber (match_operand:SI 2 \"register_operand\" \"=&z\"))])]\n   \"TARGET_SH1\"\n   \"\")\n \n-(define_expand \"reload_outdf\"\n+(define_expand \"reload_outdf__RnFRm\"\n   [(parallel [(set (match_operand:DF 0 \"register_operand\" \"=r,f\")\n \t\t   (match_operand:DF 1 \"register_operand\" \"af,r\"))\n \t      (clobber (match_operand:SI 2 \"register_operand\" \"=&y,y\"))])]\n@@ -6475,15 +6475,15 @@ label:\n   [(set_attr \"length\" \"0\")\n    (set_attr \"type\" \"nil\")])\n \n-(define_expand \"reload_insf\"\n+(define_expand \"reload_insf__frn\"\n   [(parallel [(set (match_operand:SF 0 \"register_operand\" \"=a\")\n \t\t   (match_operand:SF 1 \"immediate_operand\" \"FQ\"))\n \t      (use (reg:PSI FPSCR_REG))\n \t      (clobber (match_operand:SI 2 \"register_operand\" \"=&z\"))])]\n   \"TARGET_SH1\"\n   \"\")\n \n-(define_expand \"reload_insi\"\n+(define_expand \"reload_insi__i_fpul\"\n   [(parallel [(set (match_operand:SI 0 \"fpul_operand\" \"=y\")\n \t\t   (match_operand:SI 1 \"immediate_operand\" \"i\"))\n \t      (clobber (match_operand:SI 2 \"register_operand\" \"=&z\"))])]"}, {"sha": "54ad659cb5bf3434af569c57bac4c2c214413b75", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8", "patch": "@@ -2920,10 +2920,7 @@ If a scratch register is required to move an object to or from memory,\n it can be allocated using @code{gen_reg_rtx} prior to life analysis.\n \n If there are cases which need scratch registers during or after reload,\n-you must define @code{SECONDARY_INPUT_RELOAD_CLASS} and/or\n-@code{SECONDARY_OUTPUT_RELOAD_CLASS} to detect them, and provide\n-patterns @samp{reload_in@var{m}} or @samp{reload_out@var{m}} to handle\n-them.  @xref{Register Classes}.\n+you must provide an appropriate secondary_reload target hook.\n \n @findex no_new_pseudos\n The global variable @code{no_new_pseudos} can be used to determine if it\n@@ -2953,6 +2950,9 @@ reload into a floating point register.\n @cindex @code{reload_out} instruction pattern\n @item @samp{reload_in@var{m}}\n @itemx @samp{reload_out@var{m}}\n+These named patterns have been obsoleted by the target hook\n+@code{secondary_reload}.\n+\n Like @samp{mov@var{m}}, but used when a scratch register is required to\n move between operand 0 and operand 1.  Operand 2 describes the scratch\n register.  See the discussion of the @code{SECONDARY_RELOAD_CLASS}"}, {"sha": "b736855aaca36067ce6b14003378272ab9702fe9", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 100, "deletions": 17, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8", "patch": "@@ -2397,32 +2397,114 @@ Don't define this macro unless the target machine has limitations which\n require the macro to do something nontrivial.\n @end defmac\n \n-@defmac SECONDARY_RELOAD_CLASS (@var{class}, @var{mode}, @var{x})\n-@defmacx SECONDARY_INPUT_RELOAD_CLASS (@var{class}, @var{mode}, @var{x})\n-@defmacx SECONDARY_OUTPUT_RELOAD_CLASS (@var{class}, @var{mode}, @var{x})\n+@deftypefn {Target Hook} enum reg_class TARGET_SECONDARY_RELOAD (bool @var{in_p}, rtx @var{x}, enum reg_class @var{reload_class}, enum machine_mode @var{reload_mode}, secondary_reload_info *@var{sri})\n Many machines have some registers that cannot be copied directly to or\n from memory or even from other types of registers.  An example is the\n @samp{MQ} register, which on most machines, can only be copied to or\n-from general registers, but not memory.  Some machines allow copying all\n-registers to and from memory, but require a scratch register for stores\n-to some memory locations (e.g., those with symbolic address on the RT,\n-and those with certain symbolic address on the SPARC when compiling\n-PIC)@.  In some cases, both an intermediate and a scratch register are\n-required.\n+from general registers, but not memory.  Below, we shall be using the\n+term 'intermediate register' when a move operation cannot be performed\n+directly, but has to be done by copying the source into the intermediate\n+register first, and then copying the intermediate register to the\n+destination.  An intermediate register always has the same mode as\n+source and destination.  Since it holds the actual value being copied,\n+reload might apply optimizations to re-use an intermediate register\n+and eliding the copy from the source when it can determine that the\n+intermediate register still holds the required value.\n+\n+Another kind of secondary reload is required on some machines which\n+allow copying all registers to and from memory, but require a scratch\n+register for stores to some memory locations (e.g., those with symbolic\n+address on the RT, and those with certain symbolic address on the SPARC\n+when compiling PIC)@.  Scratch registers need not have the same mode\n+as the value being copied, and usually hold a different value that\n+that being copied.  Special patterns in the md file are needed to\n+describe how the copy is performed with the help of the scratch register;\n+these patterns also describe the number, register class(es) and mode(s)\n+of the scratch register(s).\n+\n+In some cases, both an intermediate and a scratch register are required.\n+\n+For input reloads, this target hook is called with nonzero @var{in_p},\n+and @var{x} is an rtx that needs to be copied to a register in of class\n+@var{reload_class} in @var{reload_mode}.  For output reloads, this target\n+hook is called with zero @var{in_p}, and a register of class @var{reload_mode}\n+needs to be copied to rtx @var{x} in @var{reload_mode}.\n+\n+If copying a register of @var{reload_class} from/to @var{x} requires\n+an intermediate register, the hook @code{secondary_reload} should\n+return the register class required for this intermediate register.\n+If no intermediate register is required, it should return NO_REGS.\n+If more than one intermediate register is required, describe the one\n+that is closest in the copy chain to the reload register.\n+\n+If scratch registers are needed, you also have to describe how to\n+perform the copy from/to the reload register to/from this\n+closest intermediate register.  Or if no intermediate register is\n+required, but still a scratch register is needed, describe the\n+copy  from/to the reload register to/from the reload operand @var{x}.\n+\n+You do this by setting @code{sri->icode} to the instruction code of a pattern\n+in the md file which performs the move.  Operands 0 and 1 are the output\n+and input of this copy, respectively.  Operands from operand 2 onward are\n+for scratch operands.  These scratch operands must have a mode, and a\n+single-register-class\n+@c [later: or memory]\n+output constraint.\n+\n+When an intermediate register is used, the @code{secondary_reload}\n+hook will be called again to determine how to copy the intermediate\n+register to/from the reload operand @var{x}, so your hook must also\n+have code to handle the register class of the intermediate operand.\n+\n+@c [For later: maybe we'll allow multi-alternative reload patterns -\n+@c   the port maintainer could name a mov<mode> pattern that has clobbers -\n+@c   and match the constraints of input and output to determine the required\n+@c   alternative.  A restriction would be that constraints used to match\n+@c   against reloads registers would have to be written as register class\n+@c   constraints, or we need a new target macro / hook that tells us if an\n+@c   arbitrary constraint can match an unknown register of a given class.\n+@c   Such a macro / hook would also be useful in other places.]\n+\n+\n+@var{x} might be a pseudo-register or a @code{subreg} of a\n+pseudo-register, which could either be in a hard register or in memory.\n+Use @code{true_regnum} to find out; it will return @minus{}1 if the pseudo is\n+in memory and the hard register number if it is in a register.\n+\n+Scratch operands in memory (constraint @code{\"=m\"} / @code{\"=&m\"}) are\n+currently not supported.  For the time being, you will have to continue\n+to use @code{SECONDARY_MEMORY_NEEDED} for that purpose.\n+\n+@code{copy_cost} also uses this target hook to find out how values are\n+copied.  If you want it to include some extra cost for the need to allocate\n+(a) scratch register(s), set @code{sri->extra_cost} to the additional cost.\n+Or if two dependent moves are supposed to have a lower cost than the sum\n+of the individual moves due to expected fortuitous scheduling and/or special\n+forwarding logic, you can set @code{sri->extra_cost} to a negative amount.\n+@end deftypefn\n+\n+@defmac SECONDARY_RELOAD_CLASS (@var{class}, @var{mode}, @var{x})\n+@defmacx SECONDARY_INPUT_RELOAD_CLASS (@var{class}, @var{mode}, @var{x})\n+@defmacx SECONDARY_OUTPUT_RELOAD_CLASS (@var{class}, @var{mode}, @var{x})\n+These macros are obsolete, new ports should use the target hook \n+@code{TARGET_SECONDARY_RELOAD} instead.\n \n-You should define these macros to indicate to the reload phase that it may\n+These are obsolete macros, replaced by the @code{TARGET_SECONDARY_RELOAD}\n+target hook.  Older ports still define these macros to indicate to the\n+reload phase that it may\n need to allocate at least one register for a reload in addition to the\n register to contain the data.  Specifically, if copying @var{x} to a\n register @var{class} in @var{mode} requires an intermediate register,\n-you should define @code{SECONDARY_INPUT_RELOAD_CLASS} to return the\n+you were supposed to define @code{SECONDARY_INPUT_RELOAD_CLASS} to return the\n largest register class all of whose registers can be used as\n intermediate registers or scratch registers.\n \n If copying a register @var{class} in @var{mode} to @var{x} requires an\n intermediate or scratch register, @code{SECONDARY_OUTPUT_RELOAD_CLASS}\n-should be defined to return the largest register class required.  If the\n-requirements for input and output reloads are the same, the macro\n-@code{SECONDARY_RELOAD_CLASS} should be used instead of defining both\n+was supposed to be defined be defined to return the largest register\n+class required.  If the\n+requirements for input and output reloads were the same, the macro\n+@code{SECONDARY_RELOAD_CLASS} should have been used instead of defining both\n macros identically.\n \n The values returned by these macros are often @code{GENERAL_REGS}.\n@@ -2432,14 +2514,15 @@ can be directly copied to or from a register of @var{class} in\n macro if it would always return @code{NO_REGS}.\n \n If a scratch register is required (either with or without an\n-intermediate register), you should define patterns for\n+intermediate register), you were supposed to define patterns for\n @samp{reload_in@var{m}} or @samp{reload_out@var{m}}, as required\n-(@pxref{Standard Names}.  These patterns, which will normally be\n+(@pxref{Standard Names}.  These patterns, which were normally\n implemented with a @code{define_expand}, should be similar to the\n @samp{mov@var{m}} patterns, except that operand 2 is the scratch\n register.\n \n-Define constraints for the reload register and scratch register that\n+These patterns need constraints for the reload register and scratch\n+register that\n contain a single register class.  If the original reload register (whose\n class is @var{class}) can meet the constraint given in the pattern, the\n value returned by these macros is used for the class of the scratch"}, {"sha": "9ef0d5afbdba24926881b3154bab35ae4e1d20ae", "filename": "gcc/optabs.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8", "patch": "@@ -5191,9 +5191,7 @@ init_optabs (void)\n       sync_lock_test_and_set[i] = CODE_FOR_nothing;\n       sync_lock_release[i] = CODE_FOR_nothing;\n \n-#ifdef HAVE_SECONDARY_RELOADS\n       reload_in_optab[i] = reload_out_optab[i] = CODE_FOR_nothing;\n-#endif\n     }\n \n   /* Fill in the optabs with the insns we support.  */"}, {"sha": "6839f67f0704acecd5f067cad89aa4fc866a0723", "filename": "gcc/regclass.c", "status": "modified", "additions": 32, "deletions": 66, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8", "patch": "@@ -46,19 +46,19 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"ggc.h\"\n #include \"timevar.h\"\n #include \"hashtab.h\"\n+#include \"target.h\"\n \n static void init_reg_sets_1 (void);\n static void init_reg_autoinc (void);\n \n /* If we have auto-increment or auto-decrement and we can have secondary\n    reloads, we are not allowed to use classes requiring secondary\n    reloads for pseudos auto-incremented since reload can't handle it.  */\n-\n-#ifdef AUTO_INC_DEC\n-#if defined(SECONDARY_INPUT_RELOAD_CLASS) || defined(SECONDARY_OUTPUT_RELOAD_CLASS)\n+/* We leave it to target hooks to decide if we have secondary reloads, so\n+   assume that we might have them.  */\n+#if defined(AUTO_INC_DEC) /* */\n #define FORBIDDEN_INC_DEC_CLASSES\n #endif\n-#endif\n \f\n /* Register tables used by many passes.  */\n \n@@ -597,17 +597,14 @@ init_regs (void)\n void\n init_fake_stack_mems (void)\n {\n-#ifdef HAVE_SECONDARY_RELOADS\n   {\n     int i;\n \n     for (i = 0; i < MAX_MACHINE_MODE; i++)\n       top_of_stack[i] = gen_rtx_MEM (i, stack_pointer_rtx);\n   }\n-#endif\n }\n \n-#ifdef HAVE_SECONDARY_RELOADS\n \n /* Compute extra cost of moving registers to/from memory due to reloads.\n    Only needed if secondary reloads are required for memory moves.  */\n@@ -622,22 +619,7 @@ memory_move_secondary_cost (enum machine_mode mode, enum reg_class class, int in\n   rtx mem ATTRIBUTE_UNUSED = top_of_stack[(int) mode];\n \n \n-  if (in)\n-    {\n-#ifdef SECONDARY_INPUT_RELOAD_CLASS\n-      altclass = SECONDARY_INPUT_RELOAD_CLASS (class, mode, mem);\n-#else\n-      altclass = NO_REGS;\n-#endif\n-    }\n-  else\n-    {\n-#ifdef SECONDARY_OUTPUT_RELOAD_CLASS\n-      altclass = SECONDARY_OUTPUT_RELOAD_CLASS (class, mode, mem);\n-#else\n-      altclass = NO_REGS;\n-#endif\n-    }\n+  altclass = secondary_reload_class (in ? 1 : 0, class, mode, mem);\n \n   if (altclass == NO_REGS)\n     return 0;\n@@ -661,7 +643,6 @@ memory_move_secondary_cost (enum machine_mode mode, enum reg_class class, int in\n      secondary reload.  */\n   return memory_move_secondary_cost (mode, altclass, in) + partial_cost;\n }\n-#endif\n \n /* Return a machine mode that is legitimate for hard reg REGNO and large\n    enough to save nregs.  If we can't find one, return VOIDmode.\n@@ -878,7 +859,8 @@ static void dump_regclass (FILE *);\n static void record_reg_classes (int, int, rtx *, enum machine_mode *,\n \t\t\t\tconst char **, rtx, struct costs *,\n \t\t\t\tstruct reg_pref *);\n-static int copy_cost (rtx, enum machine_mode, enum reg_class, int);\n+static int copy_cost (rtx, enum machine_mode, enum reg_class, int,\n+\t\t      secondary_reload_info *);\n static void record_address_regs (rtx, enum reg_class, int);\n #ifdef FORBIDDEN_INC_DEC_CLASSES\n static int auto_inc_dec_reg_p (rtx, enum machine_mode);\n@@ -1175,28 +1157,17 @@ init_reg_autoinc (void)\n \t\t m = (enum machine_mode) ((int) m + 1))\n \t      if (HARD_REGNO_MODE_OK (j, m))\n \t\t{\n+\t\t  enum reg_class base_class = MODE_BASE_REG_CLASS (VOIDmode);\n+\n \t\t  PUT_MODE (r, m);\n \n \t\t  /* If a register is not directly suitable for an\n \t\t     auto-increment or decrement addressing mode and\n \t\t     requires secondary reloads, disallow its class from\n \t\t     being used in such addresses.  */\n \n-\t\t  if ((0\n-#ifdef SECONDARY_RELOAD_CLASS\n-\t\t       || (SECONDARY_RELOAD_CLASS (MODE_BASE_REG_CLASS (VOIDmode), m, r)\n-\t\t\t   != NO_REGS)\n-#else\n-#ifdef SECONDARY_INPUT_RELOAD_CLASS\n-\t\t       || (SECONDARY_INPUT_RELOAD_CLASS (MODE_BASE_REG_CLASS (VOIDmode), m, r)\n-\t\t\t   != NO_REGS)\n-#endif\n-#ifdef SECONDARY_OUTPUT_RELOAD_CLASS\n-\t\t       || (SECONDARY_OUTPUT_RELOAD_CLASS (MODE_BASE_REG_CLASS (VOIDmode), m, r)\n-\t\t\t   != NO_REGS)\n-#endif\n-#endif\n-\t\t       )\n+\t\t  if ((secondary_reload_class (1, base_class, m, r)\n+\t\t       || secondary_reload_class (1, base_class, m, r))\n \t\t      && ! auto_inc_dec_reg_p (r, m))\n \t\t    forbidden_inc_dec_class[i] = 1;\n \t\t}\n@@ -1473,7 +1444,10 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t     operand to the register used for the other operand.  */\n \n \t\t  else if (classes[j] != NO_REGS)\n-\t\t    alt_cost += copy_cost (op, mode, classes[j], 1), win = 1;\n+\t\t    {\n+\t\t      alt_cost += copy_cost (op, mode, classes[j], 1, NULL);\n+\t\t      win = 1;\n+\t\t    }\n \t\t}\n \t      else if (!REG_P (ops[j])\n \t\t       || REGNO (ops[j]) < FIRST_PSEUDO_REGISTER)\n@@ -1491,7 +1465,7 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t     operand.  */\n \n \t\t  else\n-\t\t    alt_cost += copy_cost (ops[j], mode, classes[j], 1);\n+\t\t    alt_cost += copy_cost (ops[j], mode, classes[j], 1, NULL);\n \t\t}\n \t      else\n \t\t{\n@@ -1777,10 +1751,10 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t  else if (classes[i] != NO_REGS)\n \t    {\n \t      if (recog_data.operand_type[i] != OP_OUT)\n-\t\talt_cost += copy_cost (op, mode, classes[i], 1);\n+\t\talt_cost += copy_cost (op, mode, classes[i], 1, NULL);\n \n \t      if (recog_data.operand_type[i] != OP_IN)\n-\t\talt_cost += copy_cost (op, mode, classes[i], 0);\n+\t\talt_cost += copy_cost (op, mode, classes[i], 0, NULL);\n \t    }\n \n \t  /* The only other way this alternative can be used is if this is a\n@@ -1878,12 +1852,11 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n    X must not be a pseudo.  */\n \n static int\n-copy_cost (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED,\n-\t   enum reg_class class, int to_p ATTRIBUTE_UNUSED)\n+copy_cost (rtx x, enum machine_mode mode, enum reg_class class, int to_p,\n+\t   secondary_reload_info *prev_sri)\n {\n-#ifdef HAVE_SECONDARY_RELOADS\n   enum reg_class secondary_class = NO_REGS;\n-#endif\n+  secondary_reload_info sri;\n \n   /* If X is a SCRATCH, there is actually nothing to move since we are\n      assuming optimal allocation.  */\n@@ -1894,40 +1867,33 @@ copy_cost (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED,\n   /* Get the class we will actually use for a reload.  */\n   class = PREFERRED_RELOAD_CLASS (x, class);\n \n-#ifdef HAVE_SECONDARY_RELOADS\n-  /* If we need a secondary reload (we assume here that we are using\n-     the secondary reload as an intermediate, not a scratch register), the\n+  /* If we need a secondary reload for an intermediate, the\n      cost is that to load the input into the intermediate register, then\n-     to copy them.  We use a special value of TO_P to avoid recursion.  */\n+     to copy it.  */\n \n-#ifdef SECONDARY_INPUT_RELOAD_CLASS\n-  if (to_p == 1)\n-    secondary_class = SECONDARY_INPUT_RELOAD_CLASS (class, mode, x);\n-#endif\n-\n-#ifdef SECONDARY_OUTPUT_RELOAD_CLASS\n-  if (! to_p)\n-    secondary_class = SECONDARY_OUTPUT_RELOAD_CLASS (class, mode, x);\n-#endif\n+  sri.prev_sri = prev_sri;\n+  sri.extra_cost = 0;\n+  secondary_class = targetm.secondary_reload (to_p, x, class, mode, &sri);\n \n   if (secondary_class != NO_REGS)\n     return (move_cost[mode][(int) secondary_class][(int) class]\n-\t    + copy_cost (x, mode, secondary_class, 2));\n-#endif  /* HAVE_SECONDARY_RELOADS */\n+\t    + sri.extra_cost\n+\t    + copy_cost (x, mode, secondary_class, to_p, &sri));\n \n   /* For memory, use the memory move cost, for (hard) registers, use the\n      cost to move between the register classes, and use 2 for everything\n      else (constants).  */\n \n   if (MEM_P (x) || class == NO_REGS)\n-    return MEMORY_MOVE_COST (mode, class, to_p);\n+    return sri.extra_cost + MEMORY_MOVE_COST (mode, class, to_p);\n \n   else if (REG_P (x))\n-    return move_cost[mode][(int) REGNO_REG_CLASS (REGNO (x))][(int) class];\n+    return (sri.extra_cost\n+\t    + move_cost[mode][(int) REGNO_REG_CLASS (REGNO (x))][(int) class]);\n \n   else\n     /* If this is a constant, we may eventually want to call rtx_cost here.  */\n-    return COSTS_N_INSNS (1);\n+    return sri.extra_cost + COSTS_N_INSNS (1);\n }\n \f\n /* Record the pseudo registers we must reload into hard registers"}, {"sha": "718825776863ec424442cef35703862159fdc372", "filename": "gcc/reload.c", "status": "modified", "additions": 100, "deletions": 155, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8", "patch": "@@ -242,11 +242,9 @@ static int output_reloadnum;\n       ? RELOAD_FOR_OUTADDR_ADDRESS\t\t\t\\\n       : (type)))\n \n-#ifdef HAVE_SECONDARY_RELOADS\n static int push_secondary_reload (int, rtx, int, int, enum reg_class,\n \t\t\t\t  enum machine_mode, enum reload_type,\n-\t\t\t\t  enum insn_code *);\n-#endif\n+\t\t\t\t  enum insn_code *, secondary_reload_info *);\n static enum reg_class find_valid_class (enum machine_mode, enum machine_mode,\n \t\t\t\t\tint, unsigned int);\n static int reload_inner_reg_of_subreg (rtx, enum machine_mode, int);\n@@ -283,8 +281,6 @@ static int refers_to_mem_for_reload_p (rtx);\n static int refers_to_regno_for_reload_p (unsigned int, unsigned int,\n \t\t\t\t\t rtx, rtx *);\n \f\n-#ifdef HAVE_SECONDARY_RELOADS\n-\n /* Determine if any secondary reloads are needed for loading (if IN_P is\n    nonzero) or storing (if IN_P is zero) X to or from a reload register of\n    register class RELOAD_CLASS in mode RELOAD_MODE.  If secondary reloads\n@@ -298,16 +294,18 @@ static int\n push_secondary_reload (int in_p, rtx x, int opnum, int optional,\n \t\t       enum reg_class reload_class,\n \t\t       enum machine_mode reload_mode, enum reload_type type,\n-\t\t       enum insn_code *picode)\n+\t\t       enum insn_code *picode, secondary_reload_info *prev_sri)\n {\n   enum reg_class class = NO_REGS;\n+  enum reg_class scratch_class;\n   enum machine_mode mode = reload_mode;\n   enum insn_code icode = CODE_FOR_nothing;\n-  enum reg_class t_class = NO_REGS;\n-  enum machine_mode t_mode = VOIDmode;\n-  enum insn_code t_icode = CODE_FOR_nothing;\n+  enum insn_code t_icode;\n   enum reload_type secondary_type;\n   int s_reload, t_reload = -1;\n+  const char *scratch_constraint;\n+  char letter;\n+  secondary_reload_info sri;\n \n   if (type == RELOAD_FOR_INPUT_ADDRESS\n       || type == RELOAD_FOR_OUTPUT_ADDRESS\n@@ -339,36 +337,21 @@ push_secondary_reload (int in_p, rtx x, int opnum, int optional,\n       && reg_equiv_mem[REGNO (x)] != 0)\n     x = reg_equiv_mem[REGNO (x)];\n \n-#ifdef SECONDARY_INPUT_RELOAD_CLASS\n-  if (in_p)\n-    class = SECONDARY_INPUT_RELOAD_CLASS (reload_class, reload_mode, x);\n-#endif\n-\n-#ifdef SECONDARY_OUTPUT_RELOAD_CLASS\n-  if (! in_p)\n-    class = SECONDARY_OUTPUT_RELOAD_CLASS (reload_class, reload_mode, x);\n-#endif\n+  sri.icode = CODE_FOR_nothing;\n+  sri.prev_sri = prev_sri;\n+  class = targetm.secondary_reload (in_p, x, reload_class, reload_mode, &sri);\n+  icode = sri.icode;\n \n   /* If we don't need any secondary registers, done.  */\n-  if (class == NO_REGS)\n+  if (class == NO_REGS && icode == CODE_FOR_nothing)\n     return -1;\n \n-  /* Get a possible insn to use.  If the predicate doesn't accept X, don't\n-     use the insn.  */\n+  if (class != NO_REGS)\n+    t_reload = push_secondary_reload (in_p, x, opnum, optional, class,\n+\t\t\t\t      reload_mode, type, &t_icode, &sri);\n \n-  icode = (in_p ? reload_in_optab[(int) reload_mode]\n-\t   : reload_out_optab[(int) reload_mode]);\n-\n-  if (icode != CODE_FOR_nothing\n-      && insn_data[(int) icode].operand[in_p].predicate\n-      && (! (insn_data[(int) icode].operand[in_p].predicate) (x, reload_mode)))\n-    icode = CODE_FOR_nothing;\n-\n-  /* If we will be using an insn, see if it can directly handle the reload\n-     register we will be using.  If it can, the secondary reload is for a\n-     scratch register.  If it can't, we will use the secondary reload for\n-     an intermediate register and require a tertiary reload for the scratch\n-     register.  */\n+  /* If we will be using an insn, the secondary reload is for a\n+     scratch register.  */\n \n   if (icode != CODE_FOR_nothing)\n     {\n@@ -377,45 +360,29 @@ push_secondary_reload (int in_p, rtx x, int opnum, int optional,\n \t in operand 1.  Outputs should have an initial \"=\", which we must\n \t skip.  */\n \n-      enum reg_class insn_class;\n-\n-      if (insn_data[(int) icode].operand[!in_p].constraint[0] == 0)\n-\tinsn_class = ALL_REGS;\n-      else\n-\t{\n-\t  const char *insn_constraint\n-\t    = &insn_data[(int) icode].operand[!in_p].constraint[in_p];\n-\t  char insn_letter = *insn_constraint;\n-\t  insn_class\n-\t    = (insn_letter == 'r' ? GENERAL_REGS\n-\t       : REG_CLASS_FROM_CONSTRAINT ((unsigned char) insn_letter,\n-\t\t\t\t\t    insn_constraint));\n-\n-          gcc_assert (insn_class != NO_REGS);\n-\t  gcc_assert (!in_p\n-\t\t      || insn_data[(int) icode].operand[!in_p].constraint[0]\n-\t\t\t == '=');\n-\t}\n-\n-      /* The scratch register's constraint must start with \"=&\".  */\n-      gcc_assert (insn_data[(int) icode].operand[2].constraint[0] == '='\n-\t\t  && insn_data[(int) icode].operand[2].constraint[1] == '&');\n-\n-      if (reg_class_subset_p (reload_class, insn_class))\n-\tmode = insn_data[(int) icode].operand[2].mode;\n-      else\n-\t{\n-\t  const char *t_constraint\n-\t    = &insn_data[(int) icode].operand[2].constraint[2];\n-\t  char t_letter = *t_constraint;\n-\t  class = insn_class;\n-\t  t_mode = insn_data[(int) icode].operand[2].mode;\n-\t  t_class = (t_letter == 'r' ? GENERAL_REGS\n-\t\t     : REG_CLASS_FROM_CONSTRAINT ((unsigned char) t_letter,\n-\t\t\t\t\t\t  t_constraint));\n-\t  t_icode = icode;\n-\t  icode = CODE_FOR_nothing;\n-\t}\n+      /* ??? It would be useful to be able to handle only two, or more than\n+\t three, operands, but for now we can only handle the case of having\n+\t exactly three: output, input and one temp/scratch.  */\n+      gcc_assert (insn_data[(int) icode].n_operands == 3);\n+\n+      /* ??? We currently have no way to represent a reload that needs\n+\t an icode to reload from an intermediate tertiaty reload register.\n+\t We should probably have a new field in struct reload to tag a\n+\t chain of scratch operand reloads onto.   */\n+      gcc_assert (class == NO_REGS);\n+\n+      scratch_constraint = insn_data[(int) icode].operand[2].constraint;\n+      gcc_assert (*scratch_constraint == '=');\n+      scratch_constraint++;\n+      if (*scratch_constraint == '&')\n+\tscratch_constraint++;\n+      letter = *scratch_constraint;\n+      scratch_class = (letter == 'r' ? GENERAL_REGS\n+\t\t       : REG_CLASS_FROM_CONSTRAINT ((unsigned char) letter,\n+\t\t\t\t\t\t    insn_constraint));\n+\n+      class = scratch_class;\n+      mode = insn_data[(int) icode].operand[2].mode;\n     }\n \n   /* This case isn't valid, so fail.  Reload is allowed to use the same\n@@ -435,68 +402,6 @@ push_secondary_reload (int in_p, rtx x, int opnum, int optional,\n   gcc_assert (!in_p || class != reload_class || icode != CODE_FOR_nothing\n \t      || t_icode != CODE_FOR_nothing);\n \n-  /* If we need a tertiary reload, see if we have one we can reuse or else\n-     make a new one.  */\n-\n-  if (t_class != NO_REGS)\n-    {\n-      for (t_reload = 0; t_reload < n_reloads; t_reload++)\n-\tif (rld[t_reload].secondary_p\n-\t    && (reg_class_subset_p (t_class, rld[t_reload].class)\n-\t\t|| reg_class_subset_p (rld[t_reload].class, t_class))\n-\t    && ((in_p && rld[t_reload].inmode == t_mode)\n-\t\t|| (! in_p && rld[t_reload].outmode == t_mode))\n-\t    && ((in_p && (rld[t_reload].secondary_in_icode\n-\t\t\t  == CODE_FOR_nothing))\n-\t\t|| (! in_p &&(rld[t_reload].secondary_out_icode\n-\t\t\t      == CODE_FOR_nothing)))\n-\t    && (SMALL_REGISTER_CLASS_P (t_class) || SMALL_REGISTER_CLASSES)\n-\t    && MERGABLE_RELOADS (secondary_type,\n-\t\t\t\t rld[t_reload].when_needed,\n-\t\t\t\t opnum, rld[t_reload].opnum))\n-\t  {\n-\t    if (in_p)\n-\t      rld[t_reload].inmode = t_mode;\n-\t    if (! in_p)\n-\t      rld[t_reload].outmode = t_mode;\n-\n-\t    if (reg_class_subset_p (t_class, rld[t_reload].class))\n-\t      rld[t_reload].class = t_class;\n-\n-\t    rld[t_reload].opnum = MIN (rld[t_reload].opnum, opnum);\n-\t    rld[t_reload].optional &= optional;\n-\t    rld[t_reload].secondary_p = 1;\n-\t    if (MERGE_TO_OTHER (secondary_type, rld[t_reload].when_needed,\n-\t\t\t\topnum, rld[t_reload].opnum))\n-\t      rld[t_reload].when_needed = RELOAD_OTHER;\n-\t  }\n-\n-      if (t_reload == n_reloads)\n-\t{\n-\t  /* We need to make a new tertiary reload for this register class.  */\n-\t  rld[t_reload].in = rld[t_reload].out = 0;\n-\t  rld[t_reload].class = t_class;\n-\t  rld[t_reload].inmode = in_p ? t_mode : VOIDmode;\n-\t  rld[t_reload].outmode = ! in_p ? t_mode : VOIDmode;\n-\t  rld[t_reload].reg_rtx = 0;\n-\t  rld[t_reload].optional = optional;\n-\t  rld[t_reload].inc = 0;\n-\t  /* Maybe we could combine these, but it seems too tricky.  */\n-\t  rld[t_reload].nocombine = 1;\n-\t  rld[t_reload].in_reg = 0;\n-\t  rld[t_reload].out_reg = 0;\n-\t  rld[t_reload].opnum = opnum;\n-\t  rld[t_reload].when_needed = secondary_type;\n-\t  rld[t_reload].secondary_in_reload = -1;\n-\t  rld[t_reload].secondary_out_reload = -1;\n-\t  rld[t_reload].secondary_in_icode = CODE_FOR_nothing;\n-\t  rld[t_reload].secondary_out_icode = CODE_FOR_nothing;\n-\t  rld[t_reload].secondary_p = 1;\n-\n-\t  n_reloads++;\n-\t}\n-    }\n-\n   /* See if we can reuse an existing secondary reload.  */\n   for (s_reload = 0; s_reload < n_reloads; s_reload++)\n     if (rld[s_reload].secondary_p\n@@ -581,7 +486,58 @@ push_secondary_reload (int in_p, rtx x, int opnum, int optional,\n   *picode = icode;\n   return s_reload;\n }\n-#endif /* HAVE_SECONDARY_RELOADS */\n+\n+/* If a secondary reload is needed, return its class.  If both an intermediate\n+   register and a scratch register is needed, we return the class of the\n+   intermediate register.  */\n+enum reg_class\n+secondary_reload_class (bool in_p, enum reg_class class,\n+\t\t\tenum machine_mode mode, rtx x)\n+{\n+  enum insn_code icode;\n+  secondary_reload_info sri;\n+\n+  sri.icode = CODE_FOR_nothing;\n+  sri.prev_sri = NULL;\n+  class = targetm.secondary_reload (in_p, x, class, mode, &sri);\n+  icode = sri.icode;\n+\n+  /* If there are no secondary reloads at all, we return NO_REGS.\n+     If an intermediate register is needed, we return its class.  */\n+  if (icode == CODE_FOR_nothing || class != NO_REGS)\n+    return class;\n+\n+  /* No intermediate register is needed, but we have a special reload\n+     pattern, which we assume for now needs a scratch register.  */\n+  return scratch_reload_class (icode);\n+}\n+\n+/* ICODE is the insn_code of a reload pattern.  Check that it has exactly\n+   three operands, verify that operand 2 is an output operand, and return\n+   its register class.\n+   ??? We'd like to be able to handle any pattern with at least 2 operands,\n+   for zero or more scratch registers, but that needs more infrastructure.  */\n+enum reg_class\n+scratch_reload_class (enum insn_code icode)\n+{\n+  const char *scratch_constraint;\n+  char scratch_letter;\n+  enum reg_class class;\n+\n+  gcc_assert (insn_data[(int) icode].n_operands == 3);\n+  scratch_constraint = insn_data[(int) icode].operand[2].constraint;\n+  gcc_assert (*scratch_constraint == '=');\n+  scratch_constraint++;\n+  if (*scratch_constraint == '&')\n+    scratch_constraint++;\n+  scratch_letter = *scratch_constraint;\n+  if (scratch_letter == 'r')\n+    return GENERAL_REGS;\n+  class = REG_CLASS_FROM_CONSTRAINT ((unsigned char) scratch_letter,\n+\t\t\t\t     scratch_constraint);\n+  gcc_assert (class != NO_REGS);\n+  return class;\n+}\n \f\n #ifdef SECONDARY_MEMORY_NEEDED\n \n@@ -1058,13 +1014,10 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t\t       != (int) hard_regno_nregs[REGNO (SUBREG_REG (in))]\n \t\t\t\t\t\t[GET_MODE (SUBREG_REG (in))]))\n \t\t  || ! HARD_REGNO_MODE_OK (subreg_regno (in), inmode)))\n-#ifdef SECONDARY_INPUT_RELOAD_CLASS\n-\t  || (SECONDARY_INPUT_RELOAD_CLASS (class, inmode, in) != NO_REGS\n-\t      && (SECONDARY_INPUT_RELOAD_CLASS (class,\n-\t\t\t\t\t\tGET_MODE (SUBREG_REG (in)),\n-\t\t\t\t\t\tSUBREG_REG (in))\n+\t  || (secondary_reload_class (1, class, inmode, in) != NO_REGS\n+\t      && (secondary_reload_class (1, class, GET_MODE (SUBREG_REG (in)),\n+\t\t\t\t\t  SUBREG_REG (in))\n \t\t  == NO_REGS))\n-#endif\n #ifdef CANNOT_CHANGE_MODE_CLASS\n \t  || (REG_P (SUBREG_REG (in))\n \t      && REGNO (SUBREG_REG (in)) < FIRST_PSEUDO_REGISTER\n@@ -1154,13 +1107,10 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t\t       != (int) hard_regno_nregs[REGNO (SUBREG_REG (out))]\n \t\t\t\t\t\t[GET_MODE (SUBREG_REG (out))]))\n \t\t  || ! HARD_REGNO_MODE_OK (subreg_regno (out), outmode)))\n-#ifdef SECONDARY_OUTPUT_RELOAD_CLASS\n-\t  || (SECONDARY_OUTPUT_RELOAD_CLASS (class, outmode, out) != NO_REGS\n-\t      && (SECONDARY_OUTPUT_RELOAD_CLASS (class,\n-\t\t\t\t\t\t GET_MODE (SUBREG_REG (out)),\n-\t\t\t\t\t\t SUBREG_REG (out))\n+\t  || (secondary_reload_class (0, class, outmode, out) != NO_REGS\n+\t      && (secondary_reload_class (0, class, GET_MODE (SUBREG_REG (out)),\n+\t\t\t\t\t  SUBREG_REG (out))\n \t\t  == NO_REGS))\n-#endif\n #ifdef CANNOT_CHANGE_MODE_CLASS\n \t  || (REG_P (SUBREG_REG (out))\n \t      && REGNO (SUBREG_REG (out)) < FIRST_PSEUDO_REGISTER\n@@ -1310,19 +1260,14 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t and IN or CLASS and OUT.  Get the icode and push any required reloads\n \t needed for each of them if so.  */\n \n-#ifdef SECONDARY_INPUT_RELOAD_CLASS\n       if (in != 0)\n \tsecondary_in_reload\n \t  = push_secondary_reload (1, in, opnum, optional, class, inmode, type,\n-\t\t\t\t   &secondary_in_icode);\n-#endif\n-\n-#ifdef SECONDARY_OUTPUT_RELOAD_CLASS\n+\t\t\t\t   &secondary_in_icode, NULL);\n       if (out != 0 && GET_CODE (out) != SCRATCH)\n \tsecondary_out_reload\n \t  = push_secondary_reload (0, out, opnum, optional, class, outmode,\n-\t\t\t\t   type, &secondary_out_icode);\n-#endif\n+\t\t\t\t   type, &secondary_out_icode, NULL);\n \n       /* We found no existing reload suitable for re-use.\n \t So add an additional reload.  */"}, {"sha": "2792e9a5fd925963827fb75603c7fb33aaa2bb11", "filename": "gcc/reload.h", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8", "patch": "@@ -30,19 +30,10 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n   SECONDARY_RELOAD_CLASS (CLASS, MODE, X)\n #endif\n \n-/* If either macro is defined, show that we need secondary reloads.  */\n-#if defined(SECONDARY_INPUT_RELOAD_CLASS) || defined(SECONDARY_OUTPUT_RELOAD_CLASS)\n-#define HAVE_SECONDARY_RELOADS\n-#endif\n-\n /* If MEMORY_MOVE_COST isn't defined, give it a default here.  */\n #ifndef MEMORY_MOVE_COST\n-#ifdef HAVE_SECONDARY_RELOADS\n #define MEMORY_MOVE_COST(MODE,CLASS,IN) \\\n   (4 + memory_move_secondary_cost ((MODE), (CLASS), (IN)))\n-#else\n-#define MEMORY_MOVE_COST(MODE,CLASS,IN) 4\n-#endif\n #endif\n extern int memory_move_secondary_cost (enum machine_mode, enum reg_class, int);\n \n@@ -252,6 +243,13 @@ extern void compute_use_by_pseudos (HARD_REG_SET *, regset);\n \n /* Functions from reload.c:  */\n \n+extern enum reg_class secondary_reload_class (bool, enum reg_class,\n+\t\t\t\t\t      enum machine_mode, rtx);\n+\n+#ifdef GCC_INSN_CODES_H\n+extern enum reg_class scratch_reload_class (enum insn_code);\n+#endif\n+\n /* Return a memory location that will be used to copy X in mode MODE.\n    If we haven't already made a location for this mode in this insn,\n    call find_reloads_address on the location being returned.  */"}, {"sha": "970f5ec39bc52f0a29f15782eff24af09d4c2310", "filename": "gcc/reload1.c", "status": "modified", "additions": 161, "deletions": 64, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8", "patch": "@@ -43,6 +43,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"toplev.h\"\n #include \"except.h\"\n #include \"tree.h\"\n+#include \"target.h\"\n \n /* This file contains the reload pass of the compiler, which is\n    run after register allocation has been done.  It checks that\n@@ -5540,11 +5541,9 @@ choose_reload_regs (struct insn_chain *chain)\n \t\t\t     enough.  */\n \t\t\t  || ((REGISTER_MOVE_COST (mode, last_class, class)\n \t\t\t       < MEMORY_MOVE_COST (mode, class, 1))\n-#ifdef SECONDARY_INPUT_RELOAD_CLASS\n-\t\t\t      && (SECONDARY_INPUT_RELOAD_CLASS (class, mode,\n-\t\t\t\t\t\t\t\tlast_reg)\n+\t\t\t      && (secondary_reload_class (1, class, mode,\n+\t\t\t\t\t\t\t  last_reg)\n \t\t\t\t  == NO_REGS)\n-#endif\n #ifdef SECONDARY_MEMORY_NEEDED\n \t\t\t      && ! SECONDARY_MEMORY_NEEDED (last_class, class,\n \t\t\t\t\t\t\t    mode)\n@@ -6205,6 +6204,55 @@ static rtx other_output_reload_insns[MAX_RECOG_OPERANDS];\n static rtx new_spill_reg_store[FIRST_PSEUDO_REGISTER];\n static HARD_REG_SET reg_reloaded_died;\n \n+/* Check if *RELOAD_REG is suitable as an intermediate or scratch register\n+   of class NEW_CLASS with mode NEW_MODE.  Or alternatively, if alt_reload_reg\n+   is nonzero, if that is suitable.  On success, change *RELOAD_REG to the\n+   adjusted register, and return true.  Otherwise, return false.  */\n+static bool\n+reload_adjust_reg_for_temp (rtx *reload_reg, rtx alt_reload_reg,\n+\t\t\t    enum reg_class new_class,\n+\t\t\t    enum machine_mode new_mode)\n+\n+{\n+  rtx reg;\n+\n+  for (reg = *reload_reg; reg; reg = alt_reload_reg, alt_reload_reg = 0)\n+    {\n+      unsigned regno = REGNO (reg);\n+\n+      if (!TEST_HARD_REG_BIT (reg_class_contents[(int) new_class], regno))\n+\tcontinue;\n+      if (GET_MODE (reg) != new_mode)\n+\t{\n+\t  if (!HARD_REGNO_MODE_OK (regno, new_mode))\n+\t    continue;\n+\t  if (hard_regno_nregs[regno][new_mode]\n+\t      > hard_regno_nregs[regno][GET_MODE (reg)])\n+\t    continue;\n+\t  reg = reload_adjust_reg_for_mode (reg, new_mode);\n+\t}\n+      *reload_reg = reg;\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* Check if *RELOAD_REG is suitable as a scratch register for the reload\n+   pattern with insn_code ICODE, or alternatively, if alt_reload_reg is\n+   nonzero, if that is suitable.  On success, change *RELOAD_REG to the\n+   adjusted register, and return true.  Otherwise, return false.  */\n+static bool\n+reload_adjust_reg_for_icode (rtx *reload_reg, rtx alt_reload_reg,\n+\t\t\t     enum insn_code icode)\n+\n+{\n+  enum reg_class new_class = scratch_reload_class (icode);\n+  enum machine_mode new_mode = insn_data[(int) icode].operand[2].mode;\n+\n+  return reload_adjust_reg_for_temp (reload_reg, alt_reload_reg,\n+\t\t\t\t     new_class, new_mode);\n+}\n+\n /* Generate insns to perform reload RL, which is for the insn in CHAIN and\n    has the number J.  OLD contains the value to be used as input.  */\n \n@@ -6256,7 +6304,6 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n   if (mode == VOIDmode)\n     mode = rl->inmode;\n \n-#ifdef SECONDARY_INPUT_RELOAD_CLASS\n   /* If we need a secondary register for this operation, see if\n      the value is already in a register in that class.  Don't\n      do this if the secondary register will be used as a scratch\n@@ -6269,7 +6316,6 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n       = find_equiv_reg (old, insn,\n \t\t\trld[rl->secondary_in_reload].class,\n \t\t\t-1, NULL, 0, mode);\n-#endif\n \n   /* If reloading from memory, see if there is a register\n      that already holds the same value.  If so, reload from there.\n@@ -6306,11 +6352,8 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n \t       && (REGISTER_MOVE_COST (mode, REGNO_REG_CLASS (regno),\n \t\t\t\t       rl->class)\n \t\t   >= MEMORY_MOVE_COST (mode, rl->class, 1)))\n-#ifdef SECONDARY_INPUT_RELOAD_CLASS\n-\t      || (SECONDARY_INPUT_RELOAD_CLASS (rl->class,\n-\t\t\t\t\t\tmode, oldequiv)\n+\t      || (secondary_reload_class (1, rl->class, mode, oldequiv)\n \t\t  != NO_REGS)\n-#endif\n #ifdef SECONDARY_MEMORY_NEEDED\n \t      || SECONDARY_MEMORY_NEEDED (REGNO_REG_CLASS (regno),\n \t\t\t\t\t  rl->class,\n@@ -6496,7 +6539,6 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n \n   /* We can't do that, so output an insn to load RELOADREG.  */\n \n-#ifdef SECONDARY_INPUT_RELOAD_CLASS\n   /* If we have a secondary reload, pick up the secondary register\n      and icode, if any.  If OLDEQUIV and OLD are different or\n      if this is an in-out reload, recompute whether or not we\n@@ -6511,11 +6553,13 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n   if (! special && rl->secondary_in_reload >= 0)\n     {\n       rtx second_reload_reg = 0;\n+      rtx third_reload_reg = 0;\n       int secondary_reload = rl->secondary_in_reload;\n       rtx real_oldequiv = oldequiv;\n       rtx real_old = old;\n       rtx tmp;\n       enum insn_code icode;\n+      enum insn_code tertiary_icode = CODE_FOR_nothing;\n \n       /* If OLDEQUIV is a pseudo with a MEM, get the real MEM\n \t and similarly for OLD.\n@@ -6563,53 +6607,89 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n \t}\n \n       second_reload_reg = rld[secondary_reload].reg_rtx;\n+      if (rld[secondary_reload].secondary_in_reload >= 0)\n+\t{\n+\t  int tertiary_reload = rld[secondary_reload].secondary_in_reload;\n+\n+\t  third_reload_reg = rld[tertiary_reload].reg_rtx;\n+\t  tertiary_icode = rld[secondary_reload].secondary_in_icode;\n+\t  /* We'd have to add more code for quartary reloads.  */\n+\t  gcc_assert (rld[tertiary_reload].secondary_in_reload < 0);\n+\t}\n       icode = rl->secondary_in_icode;\n \n       if ((old != oldequiv && ! rtx_equal_p (old, oldequiv))\n \t  || (rl->in != 0 && rl->out != 0))\n \t{\n-\t  enum reg_class new_class\n-\t    = SECONDARY_INPUT_RELOAD_CLASS (rl->class,\n-\t\t\t\t\t    mode, real_oldequiv);\n+\t  secondary_reload_info sri, sri2;\n+\t  enum reg_class new_class, new_t_class;\n \n-\t  if (new_class == NO_REGS)\n+\t  sri.icode = CODE_FOR_nothing;\n+\t  sri.prev_sri = NULL;\n+\t  new_class = targetm.secondary_reload (1, real_oldequiv, rl->class,\n+\t\t\t\t\t\tmode, &sri);\n+\n+\t  if (new_class == NO_REGS && sri.icode == CODE_FOR_nothing)\n \t    second_reload_reg = 0;\n-\t  else\n+\t  else if (new_class == NO_REGS)\n \t    {\n-\t      enum insn_code new_icode;\n-\t      enum machine_mode new_mode;\n-\n-\t      if (! TEST_HARD_REG_BIT (reg_class_contents[(int) new_class],\n-\t\t\t\t       REGNO (second_reload_reg)))\n-\t\toldequiv = old, real_oldequiv = real_old;\n+\t      if (reload_adjust_reg_for_icode (&second_reload_reg,\n+\t\t\t\t\t       third_reload_reg, sri.icode))\n+\t\ticode = sri.icode, third_reload_reg = 0;\n \t      else\n+\t\toldequiv = old, real_oldequiv = real_old;\n+\t    }\n+\t  else if (sri.icode != CODE_FOR_nothing)\n+\t    /* We currently lack a way to express this in reloads.  */\n+\t    gcc_unreachable ();\n+\t  else\n+\t    {\n+\t      sri2.icode = CODE_FOR_nothing;\n+\t      sri2.prev_sri = &sri;\n+\t      new_t_class = targetm.secondary_reload (1, real_oldequiv,\n+\t\t\t\t\t\t      new_class, mode, &sri);\n+\t      if (new_t_class == NO_REGS && sri2.icode == CODE_FOR_nothing)\n \t\t{\n-\t\t  new_icode = reload_in_optab[(int) mode];\n-\t\t  if (new_icode != CODE_FOR_nothing\n-\t\t      && ((insn_data[(int) new_icode].operand[0].predicate\n-\t\t\t   && ! ((*insn_data[(int) new_icode].operand[0].predicate)\n-\t\t\t\t (reloadreg, mode)))\n-\t\t\t  || (insn_data[(int) new_icode].operand[1].predicate\n-\t\t\t      && ! ((*insn_data[(int) new_icode].operand[1].predicate)\n-\t\t\t\t    (real_oldequiv, mode)))))\n-\t\t    new_icode = CODE_FOR_nothing;\n-\n-\t\t  if (new_icode == CODE_FOR_nothing)\n-\t\t    new_mode = mode;\n+\t\t  if (reload_adjust_reg_for_temp (&second_reload_reg,\n+\t\t\t\t\t\t  third_reload_reg,\n+\t\t\t\t\t\t  new_class, mode))\n+\t\t    third_reload_reg = 0, tertiary_icode = sri2.icode;\n \t\t  else\n-\t\t    new_mode = insn_data[(int) new_icode].operand[2].mode;\n+\t\t    oldequiv = old, real_oldequiv = real_old;\n+\t\t}\n+\t      else if (new_t_class == NO_REGS && sri2.icode != CODE_FOR_nothing)\n+\t\t{\n+\t\t  rtx intermediate = second_reload_reg;\n \n-\t\t  if (GET_MODE (second_reload_reg) != new_mode)\n+\t\t  if (reload_adjust_reg_for_temp (&intermediate, NULL,\n+\t\t\t\t\t\t  new_class, mode)\n+\t\t      && reload_adjust_reg_for_icode (&third_reload_reg, NULL,\n+\t\t\t\t\t\t      sri2.icode))\n \t\t    {\n-\t\t      if (!HARD_REGNO_MODE_OK (REGNO (second_reload_reg),\n-\t\t\t\t\t       new_mode))\n-\t\t\toldequiv = old, real_oldequiv = real_old;\n-\t\t      else\n-\t\t\tsecond_reload_reg\n-\t\t\t  = reload_adjust_reg_for_mode (second_reload_reg,\n-\t\t\t\t\t\t\tnew_mode);\n+\t\t      second_reload_reg = intermediate;\n+\t\t      tertiary_icode = sri2.icode;\n+\t\t    }\n+\t\t  else\n+\t\t    oldequiv = old, real_oldequiv = real_old;\n+\t\t}\n+\t      else if (new_t_class != NO_REGS && sri2.icode == CODE_FOR_nothing)\n+\t\t{\n+\t\t  rtx intermediate = second_reload_reg;\n+\n+\t\t  if (reload_adjust_reg_for_temp (&intermediate, NULL,\n+\t\t\t\t\t\t  new_class, mode)\n+\t\t      && reload_adjust_reg_for_temp (&third_reload_reg, NULL,\n+\t\t\t\t\t\t      new_t_class, mode))\n+\t\t    {\n+\t\t      second_reload_reg = intermediate;\n+\t\t      tertiary_icode = sri2.icode;\n \t\t    }\n+\t\t  else\n+\t\t    oldequiv = old, real_oldequiv = real_old;\n \t\t}\n+\t      else\n+\t\t/* This could be handled more intelligently too.  */\n+\t\toldequiv = old, real_oldequiv = real_old;\n \t    }\n \t}\n \n@@ -6624,6 +6704,9 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n \t{\n \t  if (icode != CODE_FOR_nothing)\n \t    {\n+\t      /* We'd have to add extra code to handle this case.  */\n+\t      gcc_assert (!third_reload_reg);\n+\n \t      emit_insn (GEN_FCN (icode) (reloadreg, real_oldequiv,\n \t\t\t\t\t  second_reload_reg));\n \t      special = 1;\n@@ -6632,18 +6715,21 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n \t    {\n \t      /* See if we need a scratch register to load the\n \t\t intermediate register (a tertiary reload).  */\n-\t      enum insn_code tertiary_icode\n-\t\t= rld[secondary_reload].secondary_in_icode;\n-\n \t      if (tertiary_icode != CODE_FOR_nothing)\n \t\t{\n-\t\t  rtx third_reload_reg\n-\t\t    = rld[rld[secondary_reload].secondary_in_reload].reg_rtx;\n-\n \t\t  emit_insn ((GEN_FCN (tertiary_icode)\n \t\t\t      (second_reload_reg, real_oldequiv,\n \t\t\t       third_reload_reg)));\n \t\t}\n+\t      else if (third_reload_reg)\n+\t\t{\n+\t\t  gen_reload (third_reload_reg, real_oldequiv,\n+\t\t\t      rl->opnum,\n+\t\t\t      rl->when_needed);\n+\t\t  gen_reload (second_reload_reg, third_reload_reg,\n+\t\t\t      rl->opnum,\n+\t\t\t      rl->when_needed);\n+\t\t}\n \t      else\n \t\tgen_reload (second_reload_reg, real_oldequiv,\n \t\t\t    rl->opnum,\n@@ -6653,7 +6739,6 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n \t    }\n \t}\n     }\n-#endif\n \n   if (! special && ! rtx_equal_p (reloadreg, oldequiv))\n     {\n@@ -6729,31 +6814,32 @@ emit_output_reload_insns (struct insn_chain *chain, struct reload *rl,\n   if (GET_MODE (reloadreg) != mode)\n     reloadreg = reload_adjust_reg_for_mode (reloadreg, mode);\n \n-#ifdef SECONDARY_OUTPUT_RELOAD_CLASS\n-\n   /* If we need two reload regs, set RELOADREG to the intermediate\n      one, since it will be stored into OLD.  We might need a secondary\n      register only for an input reload, so check again here.  */\n \n   if (rl->secondary_out_reload >= 0)\n     {\n       rtx real_old = old;\n+      int secondary_reload = rl->secondary_out_reload;\n+      int tertiary_reload = rld[secondary_reload].secondary_out_reload;\n \n       if (REG_P (old) && REGNO (old) >= FIRST_PSEUDO_REGISTER\n \t  && reg_equiv_mem[REGNO (old)] != 0)\n \treal_old = reg_equiv_mem[REGNO (old)];\n \n-      if ((SECONDARY_OUTPUT_RELOAD_CLASS (rl->class,\n-\t\t\t\t\t  mode, real_old)\n-\t   != NO_REGS))\n+      if (secondary_reload_class (0, rl->class, mode, real_old) != NO_REGS)\n \t{\n \t  rtx second_reloadreg = reloadreg;\n-\t  reloadreg = rld[rl->secondary_out_reload].reg_rtx;\n+\t  reloadreg = rld[secondary_reload].reg_rtx;\n \n \t  /* See if RELOADREG is to be used as a scratch register\n \t     or as an intermediate register.  */\n \t  if (rl->secondary_out_icode != CODE_FOR_nothing)\n \t    {\n+\t      /* We'd have to add extra code to handle this case.  */\n+\t      gcc_assert (tertiary_reload < 0);\n+\n \t      emit_insn ((GEN_FCN (rl->secondary_out_icode)\n \t\t\t  (real_old, second_reloadreg, reloadreg)));\n \t      special = 1;\n@@ -6763,17 +6849,19 @@ emit_output_reload_insns (struct insn_chain *chain, struct reload *rl,\n \t      /* See if we need both a scratch and intermediate reload\n \t\t register.  */\n \n-\t      int secondary_reload = rl->secondary_out_reload;\n \t      enum insn_code tertiary_icode\n \t\t= rld[secondary_reload].secondary_out_icode;\n \n+\t      /* We'd have to add more code for quartary reloads.  */\n+\t      gcc_assert (tertiary_reload < 0\n+\t\t\t  || rld[tertiary_reload].secondary_out_reload < 0);\n+\n \t      if (GET_MODE (reloadreg) != mode)\n \t\treloadreg = reload_adjust_reg_for_mode (reloadreg, mode);\n \n \t      if (tertiary_icode != CODE_FOR_nothing)\n \t\t{\n-\t\t  rtx third_reloadreg\n-\t\t    = rld[rld[secondary_reload].secondary_out_reload].reg_rtx;\n+\t\t  rtx third_reloadreg = rld[tertiary_reload].reg_rtx;\n \t\t  rtx tem;\n \n \t\t  /* Copy primary reload reg to secondary reload reg.\n@@ -6799,15 +6887,24 @@ emit_output_reload_insns (struct insn_chain *chain, struct reload *rl,\n \t\t}\n \n \t      else\n-\t\t/* Copy between the reload regs here and then to\n-\t\t   OUT later.  */\n+\t\t{\n+\t\t  /* Copy between the reload regs here and then to\n+\t\t     OUT later.  */\n+\n+\t\t  gen_reload (reloadreg, second_reloadreg,\n+\t\t\t      rl->opnum, rl->when_needed);\n+\t\t  if (tertiary_reload >= 0)\n+\t\t    {\n+\t\t      rtx third_reloadreg = rld[tertiary_reload].reg_rtx;\n \n-\t\tgen_reload (reloadreg, second_reloadreg,\n-\t\t\t    rl->opnum, rl->when_needed);\n+\t\t      gen_reload (third_reloadreg, reloadreg,\n+\t\t\t\t  rl->opnum, rl->when_needed);\n+\t\t      reloadreg = third_reloadreg;\n+\t\t    }\n+\t\t}\n \t    }\n \t}\n     }\n-#endif\n \n   /* Output the last reload insn.  */\n   if (! special)"}, {"sha": "90dc55c4f25970a27405a9ffb648aa9fa71c151a", "filename": "gcc/target-def.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8", "patch": "@@ -480,6 +480,10 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n #define TARGET_HANDLE_PRAGMA_EXTERN_PREFIX 0\n #endif\n \n+#ifndef TARGET_SECONDARY_RELOAD\n+#define TARGET_SECONDARY_RELOAD default_secondary_reload\n+#endif\n+\n \n /* C++ specific.  */\n #ifndef TARGET_CXX_GUARD_TYPE\n@@ -609,6 +613,7 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n   TARGET_INVALID_CONVERSION,\t\t\t\\\n   TARGET_INVALID_UNARY_OP,\t\t\t\\\n   TARGET_INVALID_BINARY_OP,\t\t\t\\\n+  TARGET_SECONDARY_RELOAD,\t\t\t\\\n   TARGET_CXX,\t\t\t\t\t\\\n   TARGET_UNWIND_TABLES_DEFAULT,\t\t\t\\\n   TARGET_HAVE_NAMED_SECTIONS,\t\t\t\\"}, {"sha": "8d679d328576197ff70443131f1eb854fee2695b", "filename": "gcc/target.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8", "patch": "@@ -52,6 +52,21 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n \n struct stdarg_info;\n \n+/* The struct used by the secondary_reload target hook.  */\n+typedef struct secondary_reload_info\n+{\n+  /* icode is actually an enum insn_code, but we don't want to force every\n+     file that includes target.h to include optabs.h .  */\n+  int icode;\n+  int extra_cost; /* Cost for using (a) scratch register(s) to be taken\n+\t\t     into account by copy_cost.  */\n+  /* The next two members are for the use of the backward\n+     compatibility hook.  */\n+  struct secondary_reload_info *prev_sri;\n+  int t_icode; /* Actually an enum insn_code - see above.  */\n+} secondary_reload_info;\n+\n+\n struct gcc_target\n {\n   /* Functions that output assembler for the target.  */\n@@ -631,6 +646,11 @@ struct gcc_target\n      is not permitted on TYPE1 and TYPE2, NULL otherwise.  */\n   const char *(*invalid_binary_op) (int op, tree type1, tree type2);\n \n+  /* Return the class for a secondary reload, and fill in extra information.  */\n+  enum reg_class (*secondary_reload) (bool, rtx, enum reg_class,\n+\t\t\t\t      enum machine_mode,\n+\t\t\t\t      struct secondary_reload_info *);\n+\n   /* Functions specific to the C++ frontend.  */\n   struct cxx {\n     /* Return the integer type used for guard variables.  */"}, {"sha": "1d5a7fec42cc682173b28e283feb5dba4e80d467", "filename": "gcc/targhooks.c", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8", "patch": "@@ -63,6 +63,9 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"target-def.h\"\n #include \"ggc.h\"\n #include \"hard-reg-set.h\"\n+#include \"reload.h\"\n+#include \"optabs.h\"\n+#include \"recog.h\"\n \n \n void\n@@ -455,4 +458,87 @@ default_internal_arg_pointer (void)\n     return virtual_incoming_args_rtx;\n }\n \n+enum reg_class\n+default_secondary_reload (bool in_p ATTRIBUTE_UNUSED, rtx x ATTRIBUTE_UNUSED,\n+\t\t\t  enum reg_class reload_class ATTRIBUTE_UNUSED,\n+\t\t\t  enum machine_mode reload_mode ATTRIBUTE_UNUSED,\n+\t\t\t  secondary_reload_info *sri)\n+{\n+  enum reg_class class = NO_REGS;\n+\n+  if (sri->prev_sri && sri->prev_sri->t_icode != CODE_FOR_nothing)\n+    {\n+      sri->icode = sri->prev_sri->t_icode;\n+      return NO_REGS;\n+    }\n+#ifdef SECONDARY_INPUT_RELOAD_CLASS\n+  if (in_p)\n+    class = SECONDARY_INPUT_RELOAD_CLASS (reload_class, reload_mode, x);\n+#endif\n+#ifdef SECONDARY_OUTPUT_RELOAD_CLASS\n+  if (! in_p)\n+    class = SECONDARY_OUTPUT_RELOAD_CLASS (reload_class, reload_mode, x);\n+#endif\n+  if (class != NO_REGS)\n+    {\n+      enum insn_code icode = (in_p ? reload_in_optab[(int) reload_mode]\n+\t\t\t      : reload_out_optab[(int) reload_mode]);\n+\n+      if (icode != CODE_FOR_nothing\n+\t  && insn_data[(int) icode].operand[in_p].predicate\n+\t  && ! insn_data[(int) icode].operand[in_p].predicate (x, reload_mode))\n+\ticode = CODE_FOR_nothing;\n+      else if (icode != CODE_FOR_nothing)\n+\t{\n+\t  const char *insn_constraint, *scratch_constraint;\n+\t  char insn_letter, scratch_letter;\n+\t  enum reg_class insn_class, scratch_class;\n+\n+\t  gcc_assert (insn_data[(int) icode].n_operands == 3);\n+\t  insn_constraint = insn_data[(int) icode].operand[!in_p].constraint;\n+\t  if (!*insn_constraint)\n+\t    insn_class = ALL_REGS;\n+\t  else\n+\t    {\n+\t      if (in_p)\n+\t\t{\n+\t\t  gcc_assert (*insn_constraint == '=');\n+\t\t  insn_constraint++;\n+\t\t}\n+\t      insn_letter = *insn_constraint;\n+\t      insn_class\n+\t\t= (insn_letter == 'r' ? GENERAL_REGS\n+\t\t   : REG_CLASS_FROM_CONSTRAINT ((unsigned char) insn_letter,\n+\t\t\t\t\t\tinsn_constraint));\n+\t      gcc_assert (insn_class != NO_REGS);\n+\t    }\n+\n+\t  scratch_constraint = insn_data[(int) icode].operand[2].constraint;\n+\t  /* The scratch register's constraint must start with \"=&\".  */\n+\t  gcc_assert (scratch_constraint[0] == '='\n+\t\t      && scratch_constraint[1] == '&');\n+\t  scratch_constraint += 2;\n+\t  scratch_letter = *scratch_constraint;\n+\t  scratch_class\n+\t    = (scratch_letter == 'r' ? GENERAL_REGS\n+\t       : REG_CLASS_FROM_CONSTRAINT ((unsigned char) scratch_letter,\n+\t\t\t\t\t    scratch_constraint));\n+\n+\t  if (reg_class_subset_p (reload_class, insn_class))\n+\t    {\n+\t      gcc_assert (scratch_class == class);\n+\t      class = NO_REGS;\n+\t    }\n+\t  else\n+\t    class = insn_class;\n+\n+        }\n+      if (class == NO_REGS)\n+\tsri->icode = icode;\n+      else\n+\tsri->t_icode = icode;\n+    }\n+  return class;\n+}\n+\n #include \"gt-targhooks.h\""}, {"sha": "8acccfdcb052c569de92d104926d708a5cc2249d", "filename": "gcc/targhooks.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=8a99f6f92fd255690cdc0a1712c7c2f7e1bdcfe8", "patch": "@@ -69,3 +69,6 @@ extern const char *hook_invalid_arg_for_unprototyped_fn\n extern bool hook_bool_rtx_commutative_p (rtx, int);\n extern rtx default_function_value (tree, tree, bool);\n extern rtx default_internal_arg_pointer (void);\n+extern enum reg_class default_secondary_reload (bool, rtx, enum reg_class,\n+\t\t\t\t\t\tenum machine_mode,\n+\t\t\t\t\t\tsecondary_reload_info *);"}]}