{"sha": "79f57f2322dd98a72d36a98c186ad0818d629519", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzlmNTdmMjMyMmRkOThhNzJkMzZhOThjMTg2YWQwODE4ZDYyOTUxOQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@unitus.it", "date": "2001-12-07T09:07:55Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2001-12-07T09:07:55Z"}, "message": "basic_string.tcc (_M_mutate, _M_clone): Implement exponential growth policy to meet linear amortized time requirements...\n\n\n2001-12-06  Paolo Carlini  <pcarlini@unitus.it>\n\t    Loren J. Rittle <ljrittle@acm.org>\n\n\t* include/bits/basic_string.tcc (_M_mutate, _M_clone): Implement\n\texponential growth policy to meet linear amortized time\n\trequirements of the standard.\n        (_S_create): Adjust comment.\n\nCo-Authored-By: Loren J. Rittle <ljrittle@acm.org>\n\nFrom-SVN: r47750", "tree": {"sha": "9f5cc675e39a1cb61ecbb03f1b99609b570deddc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f5cc675e39a1cb61ecbb03f1b99609b570deddc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79f57f2322dd98a72d36a98c186ad0818d629519", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79f57f2322dd98a72d36a98c186ad0818d629519", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79f57f2322dd98a72d36a98c186ad0818d629519", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79f57f2322dd98a72d36a98c186ad0818d629519/comments", "author": null, "committer": null, "parents": [{"sha": "d385b9dd9d191ae1b1539e97dae815b1ac50156d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d385b9dd9d191ae1b1539e97dae815b1ac50156d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d385b9dd9d191ae1b1539e97dae815b1ac50156d"}], "stats": {"total": 53, "additions": 46, "deletions": 7}, "files": [{"sha": "afbb23417411e3bcc26ac9c23c727599cec03e20", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f57f2322dd98a72d36a98c186ad0818d629519/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f57f2322dd98a72d36a98c186ad0818d629519/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=79f57f2322dd98a72d36a98c186ad0818d629519", "patch": "@@ -1,3 +1,11 @@\n+2001-12-06  Paolo Carlini  <pcarlini@unitus.it>\n+\t    Loren J. Rittle <ljrittle@acm.org>\n+\n+\t* include/bits/basic_string.tcc (_M_mutate, _M_clone): Implement\n+\texponential growth policy to meet linear amortized time\n+\trequirements of the standard.\n+        (_S_create): Adjust comment.\n+\n 2001-12-06  Benjamin Kosnik  <bkoz@redhat.com>\n \n \tlibstdc++/3720"}, {"sha": "cbaf88361da1cc8fc07055077f3556d5fec00ec5", "filename": "libstdc++-v3/include/bits/basic_string.tcc", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f57f2322dd98a72d36a98c186ad0818d629519/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f57f2322dd98a72d36a98c186ad0818d629519/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.tcc?ref=79f57f2322dd98a72d36a98c186ad0818d629519", "patch": "@@ -265,6 +265,12 @@ namespace std\n       _M_rep()->_M_set_leaked();\n     }\n \n+  // _M_mutate and, below, _M_clone, include, in the same form, an exponential\n+  // growth policy, necessary to meet amortized linear time requirements of\n+  // the library: see http://gcc.gnu.org/ml/libstdc++/2001-07/msg00085.html.\n+  // The policy is active for allocations requiring an amount of memory above\n+  // system pagesize. This is consistent with the requirements of the standard:\n+  // see, f.i., http://gcc.gnu.org/ml/libstdc++/2001-07/msg00130.html\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     void\n     basic_string<_CharT, _Traits, _Alloc>::\n@@ -279,7 +285,21 @@ namespace std\n \t{\n \t  // Must reallocate.\n \t  allocator_type __a = get_allocator();\n-\t  _Rep* __r = _Rep::_S_create(__new_size, __a);\n+\t  // See below (_S_create) for the meaning and value of these\n+\t  // constants.\n+\t  const size_type __pagesize = 4096;\n+\t  const size_type __malloc_header_size = 4 * sizeof (void*);\n+\t  // The biggest string which fits in a memory page\n+\t  const size_type __page_capacity = !(__pagesize - __malloc_header_size\n+\t\t\t\t\t      - sizeof(_Rep) - sizeof(_CharT)) \n+\t    \t\t\t\t      / sizeof(_CharT);\n+\t  _Rep* __r;\n+\t  if (__new_size > capacity() && __new_size > __page_capacity)\n+\t    // Growing exponentially.\n+\t    __r = _Rep::_S_create(__new_size > 2*capacity() ?\n+\t\t\t\t  __new_size : 2*capacity(), __a);\n+\t  else\n+\t    __r = _Rep::_S_create(__new_size, __a);\n \t  try \n \t    {\n \t      if (__pos)\n@@ -380,11 +400,6 @@ namespace std\n       // with tuned parameters to get this perfect for any particular\n       // malloc implementation.  Fortunately, generalizations about\n       // common features seen among implementations seems to suffice.\n-      // This algorithm does not replace the need for an exponential\n-      // growth shaper to meet library specification.  Note: THIS IS\n-      // NOT THE CORRECT LOCATION FOR AN EXPONENTIAL GROWTH SHAPER\n-      // (since this code affect initial allocation as well as\n-      // reallocation).\n \n       // __pagesize need not match the actual VM page size for good\n       // results in practice, thus we pick a common value on the low\n@@ -430,7 +445,23 @@ namespace std\n     basic_string<_CharT, _Traits, _Alloc>::_Rep::\n     _M_clone(const _Alloc& __alloc, size_type __res)\n     {\n-      _Rep* __r = _Rep::_S_create(_M_length + __res, __alloc);\n+      // Requested capacity of the clone.\n+      const size_type __requested_cap = _M_length + __res;\n+      // See above (_S_create) for the meaning and value of these constants.\n+      const size_type __pagesize = 4096;\n+      const size_type __malloc_header_size = 4 * sizeof (void*);\n+      // The biggest string which fits in a memory page.\n+      const size_type __page_capacity =\n+        (__pagesize - __malloc_header_size - sizeof(_Rep) - sizeof(_CharT))\n+        / sizeof(_CharT);\n+      _Rep* __r;\n+      if (__requested_cap > _M_capacity && __requested_cap > __page_capacity)\n+        // Growing exponentially.\n+        __r = _Rep::_S_create(__requested_cap > 2*_M_capacity ?\n+                              __requested_cap : 2*_M_capacity, __alloc);\n+      else\n+        __r = _Rep::_S_create(__requested_cap, __alloc);\n+      \n       if (_M_length)\n \t{\n \t  try "}]}