{"sha": "b6ca239df2bf48d4671284ab7872927942e5fcd1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjZjYTIzOWRmMmJmNDhkNDY3MTI4NGFiNzg3MjkyNzk0MmU1ZmNkMQ==", "commit": {"author": {"name": "Ulrich Drepper", "email": "drepper@gcc.gnu.org", "date": "1998-12-02T10:44:51Z"}, "committer": {"name": "Ulrich Drepper", "email": "drepper@gcc.gnu.org", "date": "1998-12-02T10:44:51Z"}, "message": "Fix indentation from last patch.\n\nRemove trailing whitespace.\n\nFrom-SVN: r24062", "tree": {"sha": "9ee2718dbec8fe91c3f75fd21fb4a5bb2966d17d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ee2718dbec8fe91c3f75fd21fb4a5bb2966d17d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6ca239df2bf48d4671284ab7872927942e5fcd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6ca239df2bf48d4671284ab7872927942e5fcd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6ca239df2bf48d4671284ab7872927942e5fcd1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6ca239df2bf48d4671284ab7872927942e5fcd1/comments", "author": null, "committer": null, "parents": [{"sha": "75cb8865aeb49acf813a8eb900466aa40b6954cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75cb8865aeb49acf813a8eb900466aa40b6954cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75cb8865aeb49acf813a8eb900466aa40b6954cd"}], "stats": {"total": 308, "additions": 154, "deletions": 154}, "files": [{"sha": "7261e29f6294e0b54a350dfcfb7a0818c6bbc569", "filename": "gcc/real.c", "status": "modified", "additions": 154, "deletions": 154, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6ca239df2bf48d4671284ab7872927942e5fcd1/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6ca239df2bf48d4671284ab7872927942e5fcd1/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=b6ca239df2bf48d4671284ab7872927942e5fcd1", "patch": "@@ -89,7 +89,7 @@ netlib.att.com: netlib/cephes.   */\n    both mean DFmode.  In this case, the software floating-point\n    support available here is activated by writing\n       #define REAL_ARITHMETIC\n-   in tm.h. \n+   in tm.h.\n \n    The case LONG_DOUBLE_TYPE_SIZE = 128 activates TFmode support\n    and may deactivate XFmode since `long double' is used to refer\n@@ -461,7 +461,7 @@ static void esqrt\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *));\n    swapping ends if required, into output array of longs.  The\n    result is normally passed to fprintf by the ASM_OUTPUT_ macros.   */\n \n-static void \n+static void\n endian (e, x, mode)\n      unsigned EMUSHORT e[];\n      long x[];\n@@ -558,7 +558,7 @@ endian (e, x, mode)\n \n /* This is the implementation of the REAL_ARITHMETIC macro.  */\n \n-void \n+void\n earith (value, icode, r1, r2)\n      REAL_VALUE_TYPE *value;\n      int icode;\n@@ -637,7 +637,7 @@ PUT_REAL (v, value);\n /* Truncate REAL_VALUE_TYPE toward zero to signed HOST_WIDE_INT.\n    implements REAL_VALUE_RNDZINT (x) (etrunci (x)).  */\n \n-REAL_VALUE_TYPE \n+REAL_VALUE_TYPE\n etrunci (x)\n      REAL_VALUE_TYPE x;\n {\n@@ -660,7 +660,7 @@ etrunci (x)\n /* Truncate REAL_VALUE_TYPE toward zero to unsigned HOST_WIDE_INT;\n    implements REAL_VALUE_UNSIGNED_RNDZINT (x) (etruncui (x)).  */\n \n-REAL_VALUE_TYPE \n+REAL_VALUE_TYPE\n etruncui (x)\n      REAL_VALUE_TYPE x;\n {\n@@ -684,7 +684,7 @@ etruncui (x)\n    string to binary, rounding off as indicated by the machine_mode argument.\n    Then it promotes the rounded value to REAL_VALUE_TYPE.  */\n \n-REAL_VALUE_TYPE \n+REAL_VALUE_TYPE\n ereal_atof (s, t)\n      char *s;\n      enum machine_mode t;\n@@ -734,7 +734,7 @@ ereal_atof (s, t)\n \n /* Expansion of REAL_NEGATE.  */\n \n-REAL_VALUE_TYPE \n+REAL_VALUE_TYPE\n ereal_negate (x)\n      REAL_VALUE_TYPE x;\n {\n@@ -796,7 +796,7 @@ efixui (x)\n \n /* REAL_VALUE_FROM_INT macro.  */\n \n-void \n+void\n ereal_from_int (d, i, j, mode)\n      REAL_VALUE_TYPE *d;\n      HOST_WIDE_INT i, j;\n@@ -863,7 +863,7 @@ ereal_from_int (d, i, j, mode)\n \n /* REAL_VALUE_FROM_UNSIGNED_INT macro.   */\n \n-void \n+void\n ereal_from_uint (d, i, j, mode)\n      REAL_VALUE_TYPE *d;\n      unsigned HOST_WIDE_INT i, j;\n@@ -917,7 +917,7 @@ ereal_from_uint (d, i, j, mode)\n \n /* REAL_VALUE_TO_INT macro.  */\n \n-void \n+void\n ereal_to_int (low, high, rr)\n      HOST_WIDE_INT *low, *high;\n      REAL_VALUE_TYPE rr;\n@@ -1167,15 +1167,15 @@ debug_real (r)\n \n   REAL_VALUE_TO_DECIMAL (r, \"%.20g\", dstr);\n   fprintf (stderr, \"%s\", dstr);\n-}  \n+}\n \n \f\n /* The following routines convert REAL_VALUE_TYPE to the various floating\n    point formats that are meaningful to supported computers.\n \n-   The results are returned in 32-bit pieces, each piece stored in a `long'.  \n+   The results are returned in 32-bit pieces, each piece stored in a `long'.\n    This is so they can be printed by statements like\n- \n+\n       fprintf (file, \"%lx, %lx\", L[0],  L[1]);\n \n    that will work on both narrow- and wide-word host computers.  */\n@@ -1184,7 +1184,7 @@ debug_real (r)\n    contains four 32-bit pieces of the result, in the order they would appear\n    in memory.  */\n \n-void \n+void\n etartdouble (r, l)\n      REAL_VALUE_TYPE r;\n      long l[];\n@@ -1200,7 +1200,7 @@ etartdouble (r, l)\n    contains three 32-bit pieces of the result, in the order they would\n    appear in memory.  */\n \n-void \n+void\n etarldouble (r, l)\n      REAL_VALUE_TYPE r;\n      long l[];\n@@ -1215,7 +1215,7 @@ etarldouble (r, l)\n /* Convert R to a double precision value.  The output array L contains two\n    32-bit pieces of the result, in the order they would appear in memory.  */\n \n-void \n+void\n etardouble (r, l)\n      REAL_VALUE_TYPE r;\n      long l[];\n@@ -1313,11 +1313,11 @@ ereal_isneg (x)\n  \t\t\t\t most significant word first,\n  \t\t\t\t most significant bit is set)\n   ei[NI-1]\tlow guard word\t(0x8000 bit is rounding place)\n- \n- \n- \n+\n+\n+\n  \t\tRoutines for external format e-type numbers\n- \n+\n  \tasctoe (string, e)\tASCII string to extended double e type\n  \tasctoe64 (string, &d)\tASCII string to long double\n  \tasctoe53 (string, &d)\tASCII string to double\n@@ -1364,10 +1364,10 @@ ereal_isneg (x)\n \teisinf (e)              1 if e has maximum exponent (non-IEEE)\n  \t\t\t\tor is infinite (IEEE)\n         eisnan (e)              1 if e is a NaN\n- \n+\n \n  \t\tRoutines for internal format exploded e-type numbers\n- \n+\n  \teaddm (ai, bi)\t\tadd significands, bi = bi + ai\n  \tecleaz (ei)\t\tei = 0\n  \tecleazs (ei)\t\tset ei = 0 but leave its sign alone\n@@ -1399,21 +1399,21 @@ ereal_isneg (x)\n   after each arithmetic operation.\n \n   Exception flags are NOT fully supported.\n- \n+\n   Signaling NaN's are NOT supported; they are treated the same\n   as quiet NaN's.\n- \n+\n   Define INFINITY for support of infinity; otherwise a\n   saturation arithmetic is implemented.\n- \n+\n   Define NANS for support of Not-a-Number items; otherwise the\n   arithmetic will never produce a NaN output, and might be confused\n   by a NaN input.\n   If NaN's are supported, the output of `ecmp (a,b)' is -2 if\n   either a or b is a NaN. This means asking `if (ecmp (a,b) < 0)'\n   may not be legitimate. Use `if (ecmp (a,b) == -1)' for `less than'\n   if in doubt.\n- \n+\n   Denormals are always supported here where appropriate (e.g., not\n   for conversion to DEC numbers).  */\n \n@@ -1426,28 +1426,28 @@ ereal_isneg (x)\n   mode, most floating point constants are given as arrays\n   of octal integers to eliminate decimal to binary conversion\n   errors that might be introduced by the compiler.\n- \n+\n   For computers, such as IBM PC, that follow the IEEE\n   Standard for Binary Floating Point Arithmetic (ANSI/IEEE\n   Std 754-1985), the symbol IEEE should be defined.\n   These numbers have 53-bit significands.  In this mode, constants\n   are provided as arrays of hexadecimal 16 bit integers.\n   The endian-ness of generated values is controlled by\n   REAL_WORDS_BIG_ENDIAN.\n- \n+\n   To accommodate other types of computer arithmetic, all\n   constants are also provided in a normal decimal radix\n   which one can hope are correctly converted to a suitable\n   format by the available C language compiler.  To invoke\n   this mode, the symbol UNK is defined.\n- \n+\n   An important difference among these modes is a predefined\n   set of machine arithmetic constants for each.  The numbers\n   MACHEP (the machine roundoff error), MAXNUM (largest number\n   represented), and several other parameters are preset by\n   the configuration symbol.  Check the file const.c to\n   ensure that these values are correct for your computer.\n- \n+\n   For ANSI C compatibility, define ANSIC equal to 1.  Currently\n   this affects only the atan2 function and others that use it.  */\n \n@@ -1540,7 +1540,7 @@ extern int rndprc;\n \n /*  Clear out entire e-type number X.  */\n \n-static void \n+static void\n eclear (x)\n      register unsigned EMUSHORT *x;\n {\n@@ -1552,7 +1552,7 @@ eclear (x)\n \n /* Move e-type number from A to B.  */\n \n-static void \n+static void\n emov (a, b)\n      register unsigned EMUSHORT *a, *b;\n {\n@@ -1566,18 +1566,18 @@ emov (a, b)\n #if 0\n /* Absolute value of e-type X.  */\n \n-static void \n+static void\n eabs (x)\n      unsigned EMUSHORT x[];\n {\n   /* sign is top bit of last word of external format */\n-  x[NE - 1] &= 0x7fff;\t\t\n+  x[NE - 1] &= 0x7fff;\n }\n #endif /* 0 */\n \n /* Negate the e-type number X.  */\n \n-static void \n+static void\n eneg (x)\n      unsigned EMUSHORT x[];\n {\n@@ -1587,7 +1587,7 @@ eneg (x)\n \n /* Return 1 if sign bit of e-type number X is nonzero, else zero.  */\n \n-static int \n+static int\n eisneg (x)\n      unsigned EMUSHORT x[];\n {\n@@ -1600,7 +1600,7 @@ eisneg (x)\n \n /* Return 1 if e-type number X is infinity, else return zero.  */\n \n-static int \n+static int\n eisinf (x)\n      unsigned EMUSHORT x[];\n {\n@@ -1618,7 +1618,7 @@ eisinf (x)\n /* Check if e-type number is not a number.  The bit pattern is one that we\n    defined, so we know for sure how to detect it.  */\n \n-static int \n+static int\n eisnan (x)\n      unsigned EMUSHORT x[];\n {\n@@ -1642,7 +1642,7 @@ eisnan (x)\n /*  Fill e-type number X with infinity pattern (IEEE)\n     or largest possible number (non-IEEE).  */\n \n-static void \n+static void\n einfin (x)\n      register unsigned EMUSHORT *x;\n {\n@@ -1685,7 +1685,7 @@ einfin (x)\n    This generates Intel's quiet NaN pattern for extended real.\n    The exponent is 7fff, the leading mantissa word is c000.  */\n \n-static void \n+static void\n enan (x, sign)\n      register unsigned EMUSHORT *x;\n      int sign;\n@@ -1700,7 +1700,7 @@ enan (x, sign)\n \n /* Move in an e-type number A, converting it to exploded e-type B.  */\n \n-static void \n+static void\n emovi (a, b)\n      unsigned EMUSHORT *a, *b;\n {\n@@ -1747,7 +1747,7 @@ emovi (a, b)\n \n /* Move out exploded e-type number A, converting it to e type B.  */\n \n-static void \n+static void\n emovo (a, b)\n      unsigned EMUSHORT *a, *b;\n {\n@@ -1786,7 +1786,7 @@ emovo (a, b)\n \n /* Clear out exploded e-type number XI.  */\n \n-static void \n+static void\n ecleaz (xi)\n      register unsigned EMUSHORT *xi;\n {\n@@ -1798,7 +1798,7 @@ ecleaz (xi)\n \n /* Clear out exploded e-type XI, but don't touch the sign.  */\n \n-static void \n+static void\n ecleazs (xi)\n      register unsigned EMUSHORT *xi;\n {\n@@ -1811,7 +1811,7 @@ ecleazs (xi)\n \n /* Move exploded e-type number from A to B.  */\n \n-static void \n+static void\n emovz (a, b)\n      register unsigned EMUSHORT *a, *b;\n {\n@@ -1839,7 +1839,7 @@ einan (x)\n \n /* Return nonzero if exploded e-type X is a NaN.  */\n \n-static int \n+static int\n eiisnan (x)\n      unsigned EMUSHORT x[];\n {\n@@ -1858,7 +1858,7 @@ eiisnan (x)\n \n /* Return nonzero if sign of exploded e-type X is nonzero.  */\n \n-static int \n+static int\n eiisneg (x)\n      unsigned EMUSHORT x[];\n {\n@@ -1882,7 +1882,7 @@ eiinfin (x)\n \n /* Return nonzero if exploded e-type X is infinite.  */\n \n-static int \n+static int\n eiisinf (x)\n      unsigned EMUSHORT x[];\n {\n@@ -1928,7 +1928,7 @@ ecmpm (a, b)\n \n /* Shift significand of exploded e-type X down by 1 bit.  */\n \n-static void \n+static void\n eshdn1 (x)\n      register unsigned EMUSHORT *x;\n {\n@@ -1952,7 +1952,7 @@ eshdn1 (x)\n \n /* Shift significand of exploded e-type X up by 1 bit.  */\n \n-static void \n+static void\n eshup1 (x)\n      register unsigned EMUSHORT *x;\n {\n@@ -1977,7 +1977,7 @@ eshup1 (x)\n \n /* Shift significand of exploded e-type X down by 8 bits.  */\n \n-static void \n+static void\n eshdn8 (x)\n      register unsigned EMUSHORT *x;\n {\n@@ -1998,7 +1998,7 @@ eshdn8 (x)\n \n /* Shift significand of exploded e-type X up by 8 bits.  */\n \n-static void \n+static void\n eshup8 (x)\n      register unsigned EMUSHORT *x;\n {\n@@ -2020,7 +2020,7 @@ eshup8 (x)\n \n /* Shift significand of exploded e-type X up by 16 bits.  */\n \n-static void \n+static void\n eshup6 (x)\n      register unsigned EMUSHORT *x;\n {\n@@ -2038,7 +2038,7 @@ eshup6 (x)\n \n /* Shift significand of exploded e-type X down by 16 bits.  */\n \n-static void \n+static void\n eshdn6 (x)\n      register unsigned EMUSHORT *x;\n {\n@@ -2056,7 +2056,7 @@ eshdn6 (x)\n \n /* Add significands of exploded e-type X and Y.  X + Y replaces Y.  */\n \n-static void \n+static void\n eaddm (x, y)\n      unsigned EMUSHORT *x, *y;\n {\n@@ -2082,7 +2082,7 @@ eaddm (x, y)\n \n /* Subtract significands of exploded e-type X and Y.  Y - X replaces Y.  */\n \n-static void \n+static void\n esubm (x, y)\n      unsigned EMUSHORT *x, *y;\n {\n@@ -2116,7 +2116,7 @@ static unsigned EMUSHORT equot[NI];\n \n /* Divide significands */\n \n-int \n+int\n edivm (den, num)\n      unsigned EMUSHORT den[], num[];\n {\n@@ -2214,7 +2214,7 @@ edivm (den, num)\n \n /* Multiply significands */\n \n-int \n+int\n emulm (a, b)\n      unsigned EMUSHORT a[], b[];\n {\n@@ -2420,15 +2420,15 @@ emulm (a, b)\n \n   The internal format number to be rounded is S.\n   Input LOST is 0 if the value is exact.  This is the so-called sticky bit.\n- \n+\n   Input SUBFLG indicates whether the number was obtained\n   by a subtraction operation.  In that case if LOST is nonzero\n   then the number is slightly smaller than indicated.\n- \n+\n   Input EXP is the biased exponent, which may be negative.\n   the exponent field of S is ignored but is replaced by\n   EXP as adjusted by normalization and rounding.\n- \n+\n   Input RCNTRL is the rounding control.  If it is nonzero, the\n   returned value will be rounded to RNDPRC bits.\n \n@@ -2437,7 +2437,7 @@ emulm (a, b)\n    adjusted to be the actual value it would have after conversion to\n    the final floating point type.  This adjustment has been\n    implemented for all type conversions (etoe53, etc.) and decimal\n-   conversions, but not for the arithmetic functions (eadd, etc.). \n+   conversions, but not for the arithmetic functions (eadd, etc.).\n    Data types having standard 15-bit exponents are not affected by\n    this, but SFmode and DFmode are affected. For example, ediv with\n    rndprc = 24 will not round correctly to 24-bit precision if the\n@@ -2451,7 +2451,7 @@ static unsigned EMUSHORT rebit = 0;\n static int re = 0;\n static unsigned EMUSHORT rbit[NI];\n \n-static void \n+static void\n emdnorm (s, lost, subflg, exp, rcntrl)\n      unsigned EMUSHORT s[];\n      int lost;\n@@ -2667,7 +2667,7 @@ emdnorm (s, lost, subflg, exp, rcntrl)\n \n static int subflg = 0;\n \n-static void \n+static void\n esub (a, b, c)\n      unsigned EMUSHORT *a, *b, *c;\n {\n@@ -2699,7 +2699,7 @@ esub (a, b, c)\n \n /* Add.  C = A + B, all e type.  */\n \n-static void \n+static void\n eadd (a, b, c)\n      unsigned EMUSHORT *a, *b, *c;\n {\n@@ -2732,7 +2732,7 @@ eadd (a, b, c)\n \n /* Arithmetic common to both addition and subtraction.  */\n \n-static void \n+static void\n eadd1 (a, b, c)\n      unsigned EMUSHORT *a, *b, *c;\n {\n@@ -2843,7 +2843,7 @@ eadd1 (a, b, c)\n \n /* Divide: C = B/A, all e type.  */\n \n-static void \n+static void\n ediv (a, b, c)\n      unsigned EMUSHORT *a, *b, *c;\n {\n@@ -2947,7 +2947,7 @@ ediv (a, b, c)\n \n /* Multiply e-types A and B, return e-type product C.   */\n \n-static void \n+static void\n emul (a, b, c)\n      unsigned EMUSHORT *a, *b, *c;\n {\n@@ -3137,7 +3137,7 @@ e53toe (pe, y)\n #endif\n   eshift (yy, -5);\n   if (denorm)\n-    {\t\t\t\n+    {\n \t/* If zero exponent, then normalize the significand.  */\n       if ((k = enormlz (yy)) > NBITS)\n \tecleazs (yy);\n@@ -3152,7 +3152,7 @@ e53toe (pe, y)\n \n /* Convert double extended precision float PE to e type Y.  */\n \n-static void \n+static void\n e64toe (pe, y)\n      unsigned EMUSHORT *pe, *y;\n {\n@@ -3274,7 +3274,7 @@ e64toe (pe, y)\n \n /* Convert 128-bit long double precision float PE to e type Y.  */\n \n-static void \n+static void\n e113toe (pe, y)\n      unsigned EMUSHORT *pe, *y;\n {\n@@ -3359,7 +3359,7 @@ e113toe (pe, y)\n \n /* Convert single precision float PE to e type Y.  */\n \n-static void \n+static void\n e24toe (pe, y)\n      unsigned EMUSHORT *pe, *y;\n {\n@@ -3462,7 +3462,7 @@ e24toe (pe, y)\n \n /* Convert e-type X to IEEE 128-bit long double format E.  */\n \n-static void \n+static void\n etoe113 (x, e)\n      unsigned EMUSHORT *x, *e;\n {\n@@ -3495,7 +3495,7 @@ etoe113 (x, e)\n /* Convert exploded e-type X, that has already been rounded to\n    113-bit precision, to IEEE 128-bit long double format Y.  */\n \n-static void \n+static void\n toe113 (a, b)\n      unsigned EMUSHORT *a, *b;\n {\n@@ -3553,7 +3553,7 @@ toe113 (a, b)\n \n /* Convert e-type X to IEEE double extended format E.  */\n \n-static void \n+static void\n etoe64 (x, e)\n      unsigned EMUSHORT *x, *e;\n {\n@@ -3587,7 +3587,7 @@ etoe64 (x, e)\n /* Convert exploded e-type X, that has already been rounded to\n    64-bit precision, to IEEE double extended format Y.  */\n \n-static void \n+static void\n toe64 (a, b)\n      unsigned EMUSHORT *a, *b;\n {\n@@ -3703,7 +3703,7 @@ toe64 (a, b)\n #ifdef DEC\n /* Convert e-type X to DEC-format double E.  */\n \n-static void \n+static void\n etoe53 (x, e)\n      unsigned EMUSHORT *x, *e;\n {\n@@ -3713,7 +3713,7 @@ etoe53 (x, e)\n /* Convert exploded e-type X, that has already been rounded to\n    56-bit double precision, to DEC double Y.  */\n \n-static void \n+static void\n toe53 (x, y)\n      unsigned EMUSHORT *x, *y;\n {\n@@ -3724,7 +3724,7 @@ toe53 (x, y)\n #ifdef IBM\n /* Convert e-type X to IBM 370-format double E.  */\n \n-static void \n+static void\n etoe53 (x, e)\n      unsigned EMUSHORT *x, *e;\n {\n@@ -3734,7 +3734,7 @@ etoe53 (x, e)\n /* Convert exploded e-type X, that has already been rounded to\n    56-bit precision, to IBM 370 double Y.  */\n \n-static void \n+static void\n toe53 (x, y)\n      unsigned EMUSHORT *x, *y;\n {\n@@ -3745,7 +3745,7 @@ toe53 (x, y)\n #ifdef C4X\n /* Convert e-type X to C4X-format long double E.  */\n \n-static void \n+static void\n etoe53 (x, e)\n      unsigned EMUSHORT *x, *e;\n {\n@@ -3755,7 +3755,7 @@ etoe53 (x, e)\n /* Convert exploded e-type X, that has already been rounded to\n    56-bit precision, to IBM 370 double Y.  */\n \n-static void \n+static void\n toe53 (x, y)\n      unsigned EMUSHORT *x, *y;\n {\n@@ -3766,7 +3766,7 @@ toe53 (x, y)\n \n /* Convert e-type X to IEEE double E.  */\n \n-static void \n+static void\n etoe53 (x, e)\n      unsigned EMUSHORT *x, *e;\n {\n@@ -3800,7 +3800,7 @@ etoe53 (x, e)\n /* Convert exploded e-type X, that has already been rounded to\n    53-bit precision, to IEEE double Y.  */\n \n-static void \n+static void\n toe53 (x, y)\n      unsigned EMUSHORT *x, *y;\n {\n@@ -3897,7 +3897,7 @@ toe53 (x, y)\n #ifdef IBM\n /* Convert e-type X to IBM 370 float E.  */\n \n-static void \n+static void\n etoe24 (x, e)\n      unsigned EMUSHORT *x, *e;\n {\n@@ -3907,7 +3907,7 @@ etoe24 (x, e)\n /* Convert exploded e-type X, that has already been rounded to\n    float precision, to IBM 370 float Y.  */\n \n-static void \n+static void\n toe24 (x, y)\n      unsigned EMUSHORT *x, *y;\n {\n@@ -3919,7 +3919,7 @@ toe24 (x, y)\n #ifdef C4X\n /* Convert e-type X to C4X float E.  */\n \n-static void \n+static void\n etoe24 (x, e)\n      unsigned EMUSHORT *x, *e;\n {\n@@ -3929,7 +3929,7 @@ etoe24 (x, e)\n /* Convert exploded e-type X, that has already been rounded to\n    float precision, to IBM 370 float Y.  */\n \n-static void \n+static void\n toe24 (x, y)\n      unsigned EMUSHORT *x, *y;\n {\n@@ -3940,7 +3940,7 @@ toe24 (x, y)\n \n /* Convert e-type X to IEEE float E.  DEC float is the same as IEEE float.  */\n \n-static void \n+static void\n etoe24 (x, e)\n      unsigned EMUSHORT *x, *e;\n {\n@@ -3974,7 +3974,7 @@ etoe24 (x, e)\n /* Convert exploded e-type X, that has already been rounded to\n    float precision, to IEEE float Y.  */\n \n-static void \n+static void\n toe24 (x, y)\n      unsigned EMUSHORT *x, *y;\n {\n@@ -4066,13 +4066,13 @@ toe24 (x, y)\n #endif  /* not C4X */\n #endif  /* not IBM */\n \n-/* Compare two e type numbers. \n+/* Compare two e type numbers.\n    Return +1 if a > b\n            0 if a == b\n           -1 if a < b\n           -2 if either a or b is a NaN.  */\n \n-static int \n+static int\n ecmp (a, b)\n      unsigned EMUSHORT *a, *b;\n {\n@@ -4135,7 +4135,7 @@ ecmp (a, b)\n #if 0\n /* Find e-type nearest integer to X, as floor (X + 0.5).  */\n \n-static void \n+static void\n eround (x, y)\n      unsigned EMUSHORT *x, *y;\n {\n@@ -4146,7 +4146,7 @@ eround (x, y)\n \n /* Convert HOST_WIDE_INT LP to e type Y.  */\n \n-static void \n+static void\n ltoe (lp, y)\n      HOST_WIDE_INT *lp;\n      unsigned EMUSHORT *y;\n@@ -4188,7 +4188,7 @@ ltoe (lp, y)\n \n /* Convert unsigned HOST_WIDE_INT LP to e type Y.  */\n \n-static void \n+static void\n ultoe (lp, y)\n      unsigned HOST_WIDE_INT *lp;\n      unsigned EMUSHORT *y;\n@@ -4228,7 +4228,7 @@ ultoe (lp, y)\n    The output e-type fraction FRAC is the positive fractional\n    part of abs (X).  */\n \n-static void \n+static void\n eifrac (x, i, frac)\n      unsigned EMUSHORT *x;\n      HOST_WIDE_INT *i;\n@@ -4311,7 +4311,7 @@ eifrac (x, i, frac)\n    FRAC of e-type X.  A negative input yields integer output = 0 but\n    correct fraction.  */\n \n-static void \n+static void\n euifrac (x, i, frac)\n      unsigned EMUSHORT *x;\n      unsigned HOST_WIDE_INT *i;\n@@ -4380,7 +4380,7 @@ euifrac (x, i, frac)\n \n /* Shift the significand of exploded e-type X up or down by SC bits.  */\n \n-static int \n+static int\n eshift (x, sc)\n      unsigned EMUSHORT *x;\n      int sc;\n@@ -4446,7 +4446,7 @@ eshift (x, sc)\n /* Shift normalize the significand area of exploded e-type X.\n    Return the shift count (up = positive).  */\n \n-static int \n+static int\n enormlz (x)\n      unsigned EMUSHORT x[];\n {\n@@ -4618,7 +4618,7 @@ static unsigned EMUSHORT emtens[NTEN + 1][NE] =\n /* Convert float value X to ASCII string STRING with NDIG digits after\n    the decimal point.  */\n \n-static void \n+static void\n e24toasc (x, string, ndigs)\n      unsigned EMUSHORT x[];\n      char *string;\n@@ -4633,7 +4633,7 @@ e24toasc (x, string, ndigs)\n /* Convert double value X to ASCII string STRING with NDIG digits after\n    the decimal point.  */\n \n-static void \n+static void\n e53toasc (x, string, ndigs)\n      unsigned EMUSHORT x[];\n      char *string;\n@@ -4648,7 +4648,7 @@ e53toasc (x, string, ndigs)\n /* Convert double extended value X to ASCII string STRING with NDIG digits\n    after the decimal point.  */\n \n-static void \n+static void\n e64toasc (x, string, ndigs)\n      unsigned EMUSHORT x[];\n      char *string;\n@@ -4663,7 +4663,7 @@ e64toasc (x, string, ndigs)\n /* Convert 128-bit long double value X to ASCII string STRING with NDIG digits\n    after the decimal point.  */\n \n-static void \n+static void\n e113toasc (x, string, ndigs)\n      unsigned EMUSHORT x[];\n      char *string;\n@@ -4681,7 +4681,7 @@ e113toasc (x, string, ndigs)\n \n static char wstring[80];\t/* working storage for ASCII output */\n \n-static void \n+static void\n etoasc (x, string, ndigs)\n      unsigned EMUSHORT x[];\n      char *string;\n@@ -4999,7 +4999,7 @@ etoasc (x, string, ndigs)\n \n /* Convert ASCII string S to single precision float value Y.  */\n \n-static void \n+static void\n asctoe24 (s, y)\n      char *s;\n      unsigned EMUSHORT *y;\n@@ -5010,7 +5010,7 @@ asctoe24 (s, y)\n \n /* Convert ASCII string S to double precision value Y.  */\n \n-static void \n+static void\n asctoe53 (s, y)\n      char *s;\n      unsigned EMUSHORT *y;\n@@ -5029,7 +5029,7 @@ asctoe53 (s, y)\n \n /* Convert ASCII string S to double extended value Y.  */\n \n-static void \n+static void\n asctoe64 (s, y)\n      char *s;\n      unsigned EMUSHORT *y;\n@@ -5039,7 +5039,7 @@ asctoe64 (s, y)\n \n /* Convert ASCII string S to 128-bit long double Y.  */\n \n-static void \n+static void\n asctoe113 (s, y)\n      char *s;\n      unsigned EMUSHORT *y;\n@@ -5049,7 +5049,7 @@ asctoe113 (s, y)\n \n /* Convert ASCII string S to e type Y.  */\n \n-static void \n+static void\n asctoe (s, y)\n      char *s;\n      unsigned EMUSHORT *y;\n@@ -5060,7 +5060,7 @@ asctoe (s, y)\n /* Convert ASCII string SS to e type Y, with a specified rounding precision\n    of OPREC bits.  BASE is 16 for C9X hexadecimal floating constants.  */\n \n-static void \n+static void\n asctoeg (ss, y, oprec)\n      char *ss;\n      unsigned EMUSHORT *y;\n@@ -5106,7 +5106,7 @@ asctoeg (ss, y, oprec)\n \n  nxtcom:\n   if (*s >= '0' && *s <= '9')\n-  k = *s - '0';\n+    k = *s - '0';\n   else if (*s >= 'a')\n     k = 10 + *s - 'a';\n   else\n@@ -5149,7 +5149,7 @@ asctoeg (ss, y, oprec)\n \t{\n \t  if (base == 16)\n \t    {\n-\t  if (decflg)\n+\t      if (decflg)\n \t\tnexp += 4;\t/* count digits after decimal point */\n \n \t      eshup1 (yy);\t/* multiply current number by 16 */\n@@ -5160,13 +5160,13 @@ asctoeg (ss, y, oprec)\n \t  else\n \t    {\n \t      if (decflg)\n-\t    nexp += 1;\t\t/* count digits after decimal point */\n+\t\tnexp += 1;\t/* count digits after decimal point */\n \n-\t  eshup1 (yy);\t\t/* multiply current number by 10 */\n-\t  emovz (yy, xt);\n-\t  eshup1 (xt);\n-\t  eshup1 (xt);\n-\t  eaddm (xt, yy);\n+\t      eshup1 (yy);\t/* multiply current number by 10 */\n+\t      emovz (yy, xt);\n+\t      eshup1 (xt);\n+\t      eshup1 (xt);\n+\t      eaddm (xt, yy);\n \t    }\n \t  /* Insert the current digit.  */\n \t  ecleaz (xt);\n@@ -5181,10 +5181,10 @@ asctoeg (ss, y, oprec)\n \t  if (decflg == 0)\n \t    {\n \t      if (base == 10)\n-\t    nexp -= 1;\n+\t\tnexp -= 1;\n \t      else\n \t\tnexp -= 4;\n-\t}\n+\t    }\n \t}\n       prec += 1;\n       goto donchr;\n@@ -5472,7 +5472,7 @@ static unsigned EMUSHORT bmask[] =\n   0x0000,\n };\n \n-static void \n+static void\n efloor (x, y)\n      unsigned EMUSHORT x[], y[];\n {\n@@ -5523,7 +5523,7 @@ efloor (x, y)\n /* Return S and EXP such that  S * 2^EXP = X and .5 <= S < 1.\n    For example, 1.1 = 0.55 * 2^1.  */\n \n-static void \n+static void\n efrexp (x, exp, s)\n      unsigned EMUSHORT x[];\n      int *exp;\n@@ -5548,7 +5548,7 @@ efrexp (x, exp, s)\n \n /* Return e type Y = X * 2^PWR2.  */\n \n-static void \n+static void\n eldexp (x, pwr2, y)\n      unsigned EMUSHORT x[];\n      int pwr2;\n@@ -5571,7 +5571,7 @@ eldexp (x, pwr2, y)\n /* C = remainder after dividing B by A, all e type values.\n    Least significant integer quotient bits left in EQUOT.  */\n \n-static void \n+static void\n eremain (a, b, c)\n      unsigned EMUSHORT a[], b[], c[];\n {\n@@ -5608,7 +5608,7 @@ eremain (a, b, c)\n /*  Return quotient of exploded e-types NUM / DEN in EQUOT,\n     remainder in NUM.  */\n \n-static void \n+static void\n eiremain (den, num)\n      unsigned EMUSHORT den[], num[];\n {\n@@ -5641,7 +5641,7 @@ eiremain (den, num)\n    CODE is one of the following:\n \n     Mnemonic        Value          Significance\n- \n+\n      DOMAIN            1       argument domain error\n      SING              2       function singularity\n      OVERFLOW          3       overflow range error\n@@ -5651,7 +5651,7 @@ eiremain (den, num)\n      INVALID           7       NaN - producing operation\n      EDOM             33       Unix domain error code\n      ERANGE           34       Unix range error code\n- \n+\n    The order of appearance of the following messages is bound to the\n    error codes defined above.  */\n \n@@ -5671,7 +5671,7 @@ static char *ermsg[NMSGS] =\n int merror = 0;\n extern int merror;\n \n-static void \n+static void\n mtherr (name, code)\n      char *name;\n      int code;\n@@ -5694,7 +5694,7 @@ mtherr (name, code)\n #ifdef DEC\n /* Convert DEC double precision D to e type E.  */\n \n-static void \n+static void\n dectoe (d, e)\n      unsigned EMUSHORT *d;\n      unsigned EMUSHORT *e;\n@@ -5734,7 +5734,7 @@ dectoe (d, e)\n \n /* Convert e type X to DEC double precision D.  */\n \n-static void \n+static void\n etodec (x, d)\n      unsigned EMUSHORT *x, *d;\n {\n@@ -5756,7 +5756,7 @@ etodec (x, d)\n /* Convert exploded e-type X, that has already been rounded to\n    56-bit precision, to DEC format double Y.  */\n \n-static void \n+static void\n todec (x, y)\n      unsigned EMUSHORT *x, *y;\n {\n@@ -5802,7 +5802,7 @@ todec (x, y)\n #ifdef IBM\n /* Convert IBM single/double precision to e type.  */\n \n-static void \n+static void\n ibmtoe (d, e, mode)\n      unsigned EMUSHORT *d;\n      unsigned EMUSHORT *e;\n@@ -5846,7 +5846,7 @@ ibmtoe (d, e, mode)\n \n /* Convert e type to IBM single/double precision.  */\n \n-static void \n+static void\n etoibm (x, d, mode)\n      unsigned EMUSHORT *x, *d;\n      enum machine_mode mode;\n@@ -5865,7 +5865,7 @@ etoibm (x, d, mode)\n   toibm (xi, d, mode);\n }\n \n-static void \n+static void\n toibm (x, y, mode)\n      unsigned EMUSHORT *x, *y;\n      enum machine_mode mode;\n@@ -5923,7 +5923,7 @@ toibm (x, y, mode)\n #ifdef C4X\n /* Convert C4X single/double precision to e type.  */\n \n-static void \n+static void\n c4xtoe (d, e, mode)\n      unsigned EMUSHORT *d;\n      unsigned EMUSHORT *e;\n@@ -5961,7 +5961,7 @@ c4xtoe (d, e, mode)\n   {\n      isnegative = FALSE;\n   }\n-     \n+\n   r >>= 8;\t\t\t/* Shift exponent word down 8 bits.  */\n   if (r & 0x80)\t\t\t/* Make the exponent negative if it is. */\n   {\n@@ -5973,7 +5973,7 @@ c4xtoe (d, e, mode)\n      /* Now do the high order mantissa.  We don't \"or\" on the high bit\n \tbecause it is 2 (not 1) and is handled a little differently\n \tbelow.  */\n-     y[M] = d[0] & 0x7f;\t\n+     y[M] = d[0] & 0x7f;\n \n      y[M+1] = d[1];\n      if (mode != QFmode)\t/* There are only 2 words in QFmode.  */\n@@ -6018,11 +6018,11 @@ c4xtoe (d, e, mode)\n   {\n     /* Add our e type exponent offset to form our exponent.  */\n      r += EXONE;\n-     y[1] = r;\t\t\t\n+     y[1] = r;\n \n      /* Now do the high order mantissa strip off the exponent and sign\n \tbits and add the high 1 bit.  */\n-     y[M] = (d[0] & 0x7f) | 0x80;\t\n+     y[M] = (d[0] & 0x7f) | 0x80;\n \n      y[M+1] = d[1];\n      if (mode != QFmode)\t/* There are only 2 words in QFmode.  */\n@@ -6039,7 +6039,7 @@ c4xtoe (d, e, mode)\n \n /* Convert e type to C4X single/double precision.  */\n \n-static void \n+static void\n etoc4x (x, d, mode)\n      unsigned EMUSHORT *x, *d;\n      enum machine_mode mode;\n@@ -6061,15 +6061,15 @@ etoc4x (x, d, mode)\n   toc4x (xi, d, mode);\n }\n \n-static void \n+static void\n toc4x (x, y, mode)\n      unsigned EMUSHORT *x, *y;\n      enum machine_mode mode;\n {\n   int i;\n   int v;\n   int carry;\n-  \n+\n   /* Short-circuit the zero case */\n   if ((x[0] == 0)\t/* Zero exponent and sign */\n       && (x[1] == 0)\n@@ -6088,17 +6088,17 @@ toc4x (x, y, mode)\n         }\n       return;\n     }\n-  \n+\n   *y = 0;\n-  \n+\n   /* Negative number require a two's complement conversion of the\n      mantissa. */\n   if (x[0])\n     {\n       *y = 0x0080;\n-      \n+\n       i = ((int) x[1]) - 0x7f;\n-      \n+\n       /* Now add 1 to the inverted data to do the two's complement. */\n       if (mode != QFmode)\n \tv = 4 + M;\n@@ -6118,7 +6118,7 @@ toc4x (x, y, mode)\n \t    }\n \t  v--;\n \t}\n-      \n+\n       /* The following is a special case.  The C4X negative float requires\n \t a zero in the high bit (because the format is (2 - x) x 2^m), so\n \t if a one is in that bit, we have to shift left one to get rid\n@@ -6150,11 +6150,11 @@ toc4x (x, y, mode)\n #endif\n       return;\n     }\n-  \n+\n   y[0] |= ((i & 0xff) << 8);\n-  \n+\n   eshift (x, 8);\n-  \n+\n   y[0] |= x[M] & 0x7f;\n   y[1] = x[M + 1];\n   if (mode != QFmode)\n@@ -6503,7 +6503,7 @@ ditoe (di, e)\n \n /* Convert e-type to unsigned 64-bit int.  */\n \n-static void \n+static void\n etoudi (x, i)\n      unsigned EMUSHORT *x;\n      unsigned EMUSHORT *i;\n@@ -6586,7 +6586,7 @@ etoudi (x, i)\n \n /* Convert e-type to signed 64-bit int.  */\n \n-static void \n+static void\n etodi (x, i)\n      unsigned EMUSHORT *x;\n      unsigned EMUSHORT *i;\n@@ -6688,7 +6688,7 @@ etodi (x, i)\n static int esqinited = 0;\n static unsigned short sqrndbit[NI];\n \n-static void \n+static void\n esqrt (x, y)\n      unsigned EMUSHORT *x, *y;\n {\n@@ -6809,7 +6809,7 @@ significand_size (mode)\n switch (GET_MODE_BITSIZE (mode))\n   {\n   case 32:\n- \n+\n #if TARGET_FLOAT_FORMAT == C4X_FLOAT_FORMAT\n     return 56;\n #endif"}]}