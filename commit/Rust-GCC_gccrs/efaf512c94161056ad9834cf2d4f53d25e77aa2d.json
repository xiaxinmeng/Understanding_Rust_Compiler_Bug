{"sha": "efaf512c94161056ad9834cf2d4f53d25e77aa2d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWZhZjUxMmM5NDE2MTA1NmFkOTgzNGNmMmQ0ZjUzZDI1ZTc3YWEyZA==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2013-11-04T16:12:29Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2013-11-04T16:12:29Z"}, "message": "re PR rtl-optimization/58968 (Powerpc -mlra cannot compile ormas1.f in gamess Spec 2006 with -m32 -mcpu=power7 -O3 -mlra -w -ffast-math  -funroll-loops)\n\n2013-11-04  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/58968\n\t* lra-spills.c (return_regno_p): New function.\n\t(lra_final_code_change): Use it.\n\n2013-11-04  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/58968\n\t* gfortran.dg/pr58968.f: New\n\nFrom-SVN: r204353", "tree": {"sha": "7ba1b744ef9280834c03863b29bc4aac6b0378e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ba1b744ef9280834c03863b29bc4aac6b0378e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/efaf512c94161056ad9834cf2d4f53d25e77aa2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efaf512c94161056ad9834cf2d4f53d25e77aa2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efaf512c94161056ad9834cf2d4f53d25e77aa2d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efaf512c94161056ad9834cf2d4f53d25e77aa2d/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "55a7f02f06688ffea709e2b3de25004f10b8708d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55a7f02f06688ffea709e2b3de25004f10b8708d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55a7f02f06688ffea709e2b3de25004f10b8708d"}], "stats": {"total": 176, "additions": 153, "deletions": 23}, "files": [{"sha": "7e0b752c3ed486f2db6a649edeb6e0a9fa997a8c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efaf512c94161056ad9834cf2d4f53d25e77aa2d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efaf512c94161056ad9834cf2d4f53d25e77aa2d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=efaf512c94161056ad9834cf2d4f53d25e77aa2d", "patch": "@@ -1,3 +1,9 @@\n+2013-11-04  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/58968\n+\t* lra-spills.c (return_regno_p): New function.\n+\t(lra_final_code_change): Use it.\n+\n 2013-11-04  Joseph Myers  <joseph@codesourcery.com>\n \n \t* doc/cpp.texi (__GCC_IEC_559, __GCC_IEC_559_COMPLEX): Document"}, {"sha": "4ab10c25b98ed3d7f74604a215bc162d90526603", "filename": "gcc/lra-spills.c", "status": "modified", "additions": 46, "deletions": 23, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efaf512c94161056ad9834cf2d4f53d25e77aa2d/gcc%2Flra-spills.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efaf512c94161056ad9834cf2d4f53d25e77aa2d/gcc%2Flra-spills.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-spills.c?ref=efaf512c94161056ad9834cf2d4f53d25e77aa2d", "patch": "@@ -618,14 +618,41 @@ alter_subregs (rtx *loc, bool final_p)\n   return res;\n }\n \n+/* Return true if REGNO is used for return in the current\n+   function.  */\n+static bool\n+return_regno_p (unsigned int regno)\n+{\n+  rtx outgoing = crtl->return_rtx;\n+\n+  if (! outgoing)\n+    return false;\n+\n+  if (REG_P (outgoing))\n+    return REGNO (outgoing) == regno;\n+  else if (GET_CODE (outgoing) == PARALLEL)\n+    {\n+      int i;\n+\n+      for (i = 0; i < XVECLEN (outgoing, 0); i++)\n+\t{\n+\t  rtx x = XEXP (XVECEXP (outgoing, 0, i), 0);\n+\n+\t  if (REG_P (x) && REGNO (x) == regno)\n+\t    return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n /* Final change of pseudos got hard registers into the corresponding\n    hard registers and removing temporary clobbers.  */\n void\n lra_final_code_change (void)\n {\n   int i, hard_regno;\n   basic_block bb;\n-  rtx insn, curr, set;\n+  rtx insn, curr;\n   int max_regno = max_reg_num ();\n \n   for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n@@ -636,7 +663,6 @@ lra_final_code_change (void)\n     FOR_BB_INSNS_SAFE (bb, insn, curr)\n       if (INSN_P (insn))\n \t{\n-\t  bool change_p;\n \t  rtx pat = PATTERN (insn);\n \n \t  if (GET_CODE (pat) == CLOBBER && LRA_TEMP_CLOBBER_P (pat))\n@@ -649,12 +675,24 @@ lra_final_code_change (void)\n \t      continue;\n \t    }\n \n-\t  set = single_set (insn);\n-\t  change_p = (set != NULL\n-\t\t      && REG_P (SET_SRC (set)) && REG_P (SET_DEST (set))\n-\t\t      && REGNO (SET_SRC (set)) >= FIRST_PSEUDO_REGISTER\n-\t\t      && REGNO (SET_DEST (set)) >= FIRST_PSEUDO_REGISTER);\n-\t  \n+\t  /* IRA can generate move insns involving pseudos.  It is\n+\t     better remove them earlier to speed up compiler a bit.\n+\t     It is also better to do it here as they might not pass\n+\t     final RTL check in LRA, (e.g. insn moving a control\n+\t     register into itself).  So remove an useless move insn\n+\t     unless next insn is USE marking the return reg (we should\n+\t     save this as some subsequent optimizations assume that\n+\t     such original insns are saved).  */\n+\t  if (NONJUMP_INSN_P (insn) && GET_CODE (pat) == SET\n+\t      && REG_P (SET_SRC (pat)) && REG_P (SET_DEST (pat))\n+\t      && REGNO (SET_SRC (pat)) == REGNO (SET_DEST (pat))\n+\t      && ! return_regno_p (REGNO (SET_SRC (pat))))\n+\t    {\n+\t      lra_invalidate_insn_data (insn);\n+\t      delete_insn (insn);\n+\t      continue;\n+\t    }\n+\t\n \t  lra_insn_recog_data_t id = lra_get_insn_recog_data (insn);\n \t  struct lra_static_insn_data *static_id = id->insn_static_data;\n \t  bool insn_change_p = false;\n@@ -668,20 +706,5 @@ lra_final_code_change (void)\n \t      }\n \t  if (insn_change_p)\n \t    lra_update_operator_dups (id);\n-\n-\t  if (change_p && REGNO (SET_SRC (set)) == REGNO (SET_DEST (set)))\n-\t    {\n-\t      /* Remove an useless move insn but only involving\n-\t\t pseudos as some subsequent optimizations are based on\n-\t\t that move insns involving originally hard registers\n-\t\t are preserved.  IRA can generate move insns involving\n-\t\t pseudos.  It is better remove them earlier to speed\n-\t\t up compiler a bit.  It is also better to do it here\n-\t\t as they might not pass final RTL check in LRA,\n-\t\t (e.g. insn moving a control register into\n-\t\t itself).  */\n-\t      lra_invalidate_insn_data (insn);\n-\t      delete_insn (insn);\n-\t    }\n \t}\n }"}, {"sha": "1f487d7f82245e99244b6c9aac481487b372d23f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efaf512c94161056ad9834cf2d4f53d25e77aa2d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efaf512c94161056ad9834cf2d4f53d25e77aa2d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=efaf512c94161056ad9834cf2d4f53d25e77aa2d", "patch": "@@ -1,3 +1,8 @@\n+2013-11-04  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/58968\n+\t* gfortran.dg/pr58968.f: New\n+\n 2013-11-04  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/58979"}, {"sha": "db06d50fa27fac95d83330bb01d1969c8f390c52", "filename": "gcc/testsuite/gfortran.dg/pr58968.f", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efaf512c94161056ad9834cf2d4f53d25e77aa2d/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr58968.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efaf512c94161056ad9834cf2d4f53d25e77aa2d/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr58968.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr58968.f?ref=efaf512c94161056ad9834cf2d4f53d25e77aa2d", "patch": "@@ -0,0 +1,96 @@\n+C PR rtl-optimization/58968.f\n+C { dg-do compile { target powerpc*-*-*} }\n+C { dg-options \"-mcpu=power7 -O3 -w -ffast-math  -funroll-loops\" }\n+      SUBROUTINE MAKTABS(IW,SOME,LBOX1,LBOX2,LBOX3,NSPACE,NA,NB,\n+     *            LBST,X,\n+     *            NX,IAMA,IAMI,IBMA,IBMI,MNUM,IDIM,MSTA,IBO,\n+     *            IDSYM,ISYM1,NSYM,\n+     *            NACT,LWRK,KTAB,LGMUL,\n+     *            LCON,LCOA,LCOB,\n+     *            LANDET,LBNDET,NAST,NBST,LSYMA,LSYMB,LGCOM,\n+     *            MINI,MAXI,LSPA,LSPB,LDISB,\n+     *            LSAS,LSBS,LSAC,LSBC,\n+     *            ITGA,ITGB,IAST,IBST,NCI,NA1EX,NB1EX,FDIRCT)\n+      IMPLICIT DOUBLE PRECISION(A-H,O-Z)\n+      LOGICAL SOME\n+      DIMENSION LBOX1(NSPACE),LBOX2(NSPACE),LBOX3(NSPACE),LBST(NSPACE)\n+      DIMENSION X(NX)\n+      DIMENSION IAMA(NSPACE),IAMI(NSPACE),IBMA(NSPACE),IBMI(NSPACE)\n+      DIMENSION MNUM(NSPACE),IDIM(NSPACE),MSTA(NSPACE+1),IBO(NACT)\n+      DIMENSION LWRK(43),KTAB(NSYM),LGMUL(NSYM,NSYM)\n+      DIMENSION LCON(NA)\n+      DIMENSION LCOA(NSYM,ITGA),LCOB(NSYM,ITGB)\n+      DIMENSION LANDET(NSPACE,ITGA),LBNDET(NSPACE,ITGB)\n+      DIMENSION NAST(ITGA+1),NBST(ITGB+1)\n+      DIMENSION LSYMA(IAST),LSYMB(IBST)\n+      DIMENSION LGCOM(ITGB,ITGA)\n+      DIMENSION MINI(NSPACE),MAXI(NSPACE)\n+      DIMENSION LSPA(IAST),LSPB(IBST)\n+      DIMENSION LDISB(NSYM,ITGB,ITGA)\n+      DIMENSION LSAS(NSYM+1,ITGA),LSBS(NSYM+1,ITGB)\n+      DIMENSION LSAC(IAST),LSBC(IBST)\n+      LOGICAL FDIRCT\n+      LCOA = 0\n+      LCOB = 0\n+      ISTA1 = LBST(1)\n+      CALL RESETCO(LBOX1,NSPACE,NB,IBMA,IBMI,LBOX2)\n+      NAST(1) = 0\n+      NBST(1) = 0\n+      DO II=1,ITGA\n+         ITOT = 1\n+         DO JJ=1,NSPACE\n+            ITOT = ITOT * LANDET(JJ,II)\n+         ENDDO\n+         NAST(II+1) = NAST(II) + ITOT\n+      ENDDO\n+      DO II=1,ITGB\n+         ITOT = 1\n+         DO JJ=1,NSPACE\n+            ITOT = ITOT * LBNDET(JJ,II)\n+         ENDDO\n+         NBST(II+1) = NBST(II) + ITOT\n+      ENDDO\n+      ICOMP = 0\n+      CALL RESETCO(LBOX1,NSPACE,NA,IAMA,IAMI,LBOX3)\n+      NA1EX = 0\n+      NB1EX = 0\n+      CALL RESETCO(LBOX1,NSPACE,NB,IBMA,IBMI,LBOX3)\n+      DO IIB = 1,ITGB\n+         CALL RESETDE(LBOX1,NSPACE,NB,MSTA,LCON)\n+         DO KKB=NBST(IIB)+1,NBST(IIB+1)\n+            DO II=1,NSPACE\n+               LBOX2(II) = LBOX1(II)\n+            ENDDO\n+            IEBS = NB+1\n+            DO ISPB1=NSPACE,1,-1\n+               IOC1 = LBOX1(ISPB1)\n+               IEBE = IEBS - 1\n+               IEBS = IEBS - IOC1\n+               LBOX2(ISPB1) = LBOX2(ISPB1)-1\n+               DO IB1=IEBE,IEBS,-1\n+                  IO1 = LCON(IB1)\n+                  IGBE = IEBE - LBOX1(ISPB1)\n+                  DO ISPB2=ISPB1,NSPACE\n+                     IGBS = IGBE + 1\n+                     IGBE = IGBE + LBOX1(ISPB2)\n+                     LBOX2(ISPB2) = LBOX2(ISPB2) + 1\n+                     IGBA = MAX(IB1+1,IGBS)\n+                     DO IGAP=IGBA,IGBE+1\n+                        DO JJ=ISTA,IEND\n+                           NB1EX = NB1EX + 1\n+                        ENDDO\n+                        ISTA = LCON(IGAP)+1\n+                        IEND = LCON(IGAP+1)-1\n+                        IF (IGAP.EQ.IGBE) IEND=MSTA(ISPB2+1)-1\n+                     ENDDO\n+                     LBOX2(ISPB2) = LBOX2(ISPB2) - 1\n+                  ENDDO\n+               ENDDO\n+               LBOX2(ISPB1) = LBOX2(ISPB1) + 1\n+            ENDDO\n+            CALL MOVEUP2(LBOX1,NSPACE,NB,MSTA,LCON)\n+         ENDDO\n+         CALL PUSHCO(LBOX1,NSPACE,NB,IBMA,IBMI,LBOX3,IEND)\n+      ENDDO \n+      RETURN\n+      END"}]}