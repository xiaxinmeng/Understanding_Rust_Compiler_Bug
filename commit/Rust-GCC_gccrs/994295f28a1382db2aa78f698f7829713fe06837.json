{"sha": "994295f28a1382db2aa78f698f7829713fe06837", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTk0Mjk1ZjI4YTEzODJkYjJhYTc4ZjY5OGY3ODI5NzEzZmUwNjgzNw==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-02-24T22:18:29Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-02-24T22:18:29Z"}, "message": "Correct typos and formatting problems.\n\n(MODE_DISP_OK_[12]): Delete.\n(GO_IF_LEGITIMATE_INDEX): Delete uses of MODE_DISP_OK_[12].\n(RTX_COSTS): Add LSHIFTRT.\n(table_lab): Delete declaration.\n(enum processor_type): New enum.\n(sh_cpu_attr): New macro.\n(sh_cpu): Change type to enum processor_type to avoid incomplete\nenum type.\n\nFrom-SVN: r9061", "tree": {"sha": "29cc472b1c8a946924eb9f16ed4b7c759bb0f29f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/29cc472b1c8a946924eb9f16ed4b7c759bb0f29f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/994295f28a1382db2aa78f698f7829713fe06837", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/994295f28a1382db2aa78f698f7829713fe06837", "html_url": "https://github.com/Rust-GCC/gccrs/commit/994295f28a1382db2aa78f698f7829713fe06837", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/994295f28a1382db2aa78f698f7829713fe06837/comments", "author": null, "committer": null, "parents": [{"sha": "07a45e5ce18354606fc1706633b6a855029104a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07a45e5ce18354606fc1706633b6a855029104a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07a45e5ce18354606fc1706633b6a855029104a4"}], "stats": {"total": 277, "additions": 123, "deletions": 154}, "files": [{"sha": "0cf70dc49efe9917f56e9a034f4e19333b6ca11a", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 123, "deletions": 154, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994295f28a1382db2aa78f698f7829713fe06837/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994295f28a1382db2aa78f698f7829713fe06837/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=994295f28a1382db2aa78f698f7829713fe06837", "patch": "@@ -33,7 +33,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n #define DBX_DEBUGGING_INFO\n \n-/* Generate SDB debugging information by default. */\n+/* Generate SDB debugging information by default.  */\n \n #define PREFERRED_DEBUGGING_TYPE SDB_DEBUG\n \n@@ -52,15 +52,14 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n \n #define CONDITIONAL_REGISTER_USAGE\t\t\t\t\\\n-  /* Hitachi saves and restores mac registers on call */        \\\n+  /* Hitachi saves and restores mac registers on call.  */\t\\\n   if (TARGET_HITACHI)\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\\\n      call_used_regs[MACH_REG] = 0;\t\t\t\t\\\n      call_used_regs[MACL_REG] = 0;\t\t\t\t\\\n-  }\t\t\t\t\t\n-\n+  }\n \f\n-/* Run-time compilation parameters selecting different hardware subsets. */\n+/* Run-time compilation parameters selecting different hardware subsets.  */\n \n extern int target_flags;\n #define ISIZE_BIT      \t(1<<1)\n@@ -83,52 +82,54 @@ extern int target_flags;\n #define PACKSTRUCT_BIT  (1<<28)\n #define LITTLE_ENDIAN_BIT (1<<29)\n \n-/* Nonzero if we should generate code using type 0 insns */\n+/* Nonzero if we should generate code using type 0 insns.  */\n #define TARGET_SH0 (target_flags & SH0_BIT)\n \n-/* Nonzero if we should generate code using type 1 insns */\n+/* Nonzero if we should generate code using type 1 insns.  */\n #define TARGET_SH1 (target_flags & SH1_BIT)\n \n-/* Nonzero if we should generate code using type 2 insns */\n+/* Nonzero if we should generate code using type 2 insns.  */\n #define TARGET_SH2 (target_flags & SH2_BIT)\n \n-/* Nonzero if we should generate code using type 3 insns */\n+/* Nonzero if we should generate code using type 3 insns.  */\n #define TARGET_SH3 (target_flags & SH3_BIT)\n \n-/* Nonzero if we should generate faster code rather than smaller code */\n+/* Nonzero if we should generate faster code rather than smaller code.  */\n #define TARGET_FASTCODE   (target_flags & FAST_BIT)\n \n-/* Nonzero if we should generate smaller code rather than faster code */\n+/* Nonzero if we should generate smaller code rather than faster code.  */\n #define TARGET_SMALLCODE   (target_flags & SPACE_BIT)\n \n-/* Nonzero if we should dump out instruction size info */\n+/* Nonzero if we should dump out instruction size info.  */\n #define TARGET_DUMPISIZE  (target_flags & ISIZE_BIT)\n \n-/* Nonzero if we should dump the rtl in the assembly file. */\n+/* Nonzero if we should dump the rtl in the assembly file.  */\n #define TARGET_DUMP_RTL\t  (target_flags & RTL_BIT)\n \n-/* Nonzero if we should dump the rtl somewher else. */\n+/* Nonzero if we should dump the rtl somewher else.  */\n #define TARGET_DUMP_R\t  (target_flags & R_BIT)\n \n-/* Nonzero to align doubles on 64 bit boundaries */\n+/* Nonzero to align doubles on 64 bit boundaries.  */\n #define TARGET_ALIGN_DOUBLE (target_flags & DALIGN_BIT)\n \n-/* Nonzero to use long jump tables */\n+/* Nonzero to use long jump tables.  */\n #define TARGET_BIGTABLE     (target_flags & BIGTABLE_BIT)\n \n-/* Nonzero if combine dumping wanted */\n+/* Nonzero if combine dumping wanted.  */\n #define TARGET_CDUMP (target_flags & C_BIT)\n \n-/* Select max size of computed constant code sequences to be 3 insns */\n+/* Select max size of computed constant code sequences to be 3 insns.  */\n #define TARGET_CLEN3 (target_flags & CONSTLEN_3_BIT)\n \n-/* Select max size of computed constant code sequences to be 0 insns - ie don't do it */\n+/* Select max size of computed constant code sequences to be 0 insns -\n+   i.e. don't do it.  */\n #define TARGET_CLEN0 (target_flags & CONSTLEN_0_BIT)\n \n-/* Nonzero if using Hitachi's calling convention */\n+/* Nonzero if using Hitachi's calling convention.  */\n #define TARGET_HITACHI \t\t(target_flags & HITACHI_BIT)\n \n-/* Nonzero if packing structures as small as they'll go (incompatible with Hitachi's compiler) */\n+/* Nonzero if packing structures as small as they'll go (incompatible\n+   with Hitachi's compiler).  */\n #define TARGET_PACKSTRUCT       (target_flags & PACKSTRUCT_BIT)\n \n \n@@ -177,13 +178,13 @@ do {\t\t\t\t\t\t\t\t\\\n     sh_cpu = CPU_SH3|CPU_SH2;\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n   /*  We *MUST* always define optimize since we *HAVE* to run   \\\n-      shorten branches to get correct code. */                  \\\n+      shorten branches to get correct code.  */                 \\\n                                                                 \\\n   optimize = 1;                                                 \\\n   flag_delayed_branch = 1;\t\t\t\t\t\\\n   /* But never run scheduling before reload, since than can     \\\n      break global alloc, and generates slower code anyway due   \\\n-     to the pressure on R0. */                                  \\\n+     to the pressure on R0.  */                                 \\\n   flag_schedule_insns = 0;            \t\t\t\t\\\n   if (max_si)\t\t\t\t\t\t\t\\\n     max_count_si = atoi (max_si);\t\t\t\t\\\n@@ -194,12 +195,11 @@ do {\t\t\t\t\t\t\t\t\\\n   else      \t\t\t\t\t\t\t\\\n     max_count_hi = 500;\t\t\t\t                \\\n } while (0)\n-\n \f\n /* Target machine storage Layout.  */\n \n /* Define to use software floating point emulator for REAL_ARITHMETIC and\n-   decimal <-> binary conversion. */\n+   decimal <-> binary conversion.  */\n #define REAL_ARITHMETIC\n \n /* Define this if most significant bit is lowest numbered\n@@ -224,7 +224,7 @@ do {\t\t\t\t\t\t\t\t\\\n #define LIBGCC2_WORDS_BIG_ENDIAN 1\n #endif\n \n-/* Number of bits in an addressable storage unit */\n+/* Number of bits in an addressable storage unit.  */\n #define BITS_PER_UNIT  8\n \n /* Width in bits of a \"word\", which is the contents of a machine register.\n@@ -275,13 +275,12 @@ do {\t\t\t\t\t\t\t\t\\\n \n /* Number of bits which any structure or union's size must be a\n    multiple of.  Each structure or union's size is rounded up to a\n-   multiple of this. */\n+   multiple of this.  */\n #define STRUCTURE_SIZE_BOUNDARY (TARGET_PACKSTRUCT ? 8 : 32)\n \n /* Set this nonzero if move instructions will actually fail to work\n    when given unaligned data.  */\n #define STRICT_ALIGNMENT 1\n-\n \f\n /* Standard register usage.  */\n \n@@ -296,17 +295,16 @@ do {\t\t\t\t\t\t\t\t\\\n \tap\t\targ pointer (doesn't really exist, always eliminated)\n \tpr\t\tsubroutine return address\n \tt               t bit\n-\tmach\t\tmultiply/accumulate result\n-\tmacl\n-*/\n+\tmach\t\tmultiply/accumulate result, high part\n+\tmacl\t\tmultiply/accumulate result, low part.  */\n \n /* Number of actual hardware registers.\n    The hardware registers are assigned numbers for the compiler\n    from 0 to just below FIRST_PSEUDO_REGISTER.\n    All registers that the compiler knows about must be given numbers,\n-   even those that are not normally considered general registers. */\n+   even those that are not normally considered general registers.  */\n \n-#define AP_REG   16  \n+#define AP_REG   16\n #define PR_REG   17\n #define T_REG    18\n #define GBR_REG  19\n@@ -316,12 +314,12 @@ do {\t\t\t\t\t\t\t\t\\\n #define FIRST_PSEUDO_REGISTER 22\n \n /* 1 for registers that have pervasive standard uses\n-   and are not available for the register allocator. \n+   and are not available for the register allocator.\n \n    Mach register is fixed 'cause it's only 10 bits wide for SH1.\n    It is 32 bits wide for SH2.  */\n \n- /*  r0  r1  r2  r3 \n+ /*  r0  r1  r2  r3\n      r4  r5  r6  r7\n      r8  r9  r10 r11\n      r12 r13 r14 r15\n@@ -344,11 +342,11 @@ do {\t\t\t\t\t\t\t\t\\\n    and the register where structure-value addresses are passed.\n    Aside from that, you can include as many other registers as you like.  */\n \n- /*  r0  r1  r2  r3  \n-     r4  r5  r6  r7 \n+ /*  r0  r1  r2  r3\n+     r4  r5  r6  r7\n      r8  r9  r10 r11\n      r12 r13 r14 r15\n-     ap  pr  t   gbr \n+     ap  pr  t   gbr\n      mh  ml */\n \n #define CALL_USED_REGISTERS \t\\\n@@ -357,20 +355,20 @@ do {\t\t\t\t\t\t\t\t\\\n      0,  0,  0,  0,\t\t\\\n      0,  0,  0,  1,\t\t\\\n      1,  0,  1,  1,\t\t\\\n-     1,  1}\t\n+     1,  1}\n \n /* Return number of consecutive hard regs needed starting at reg REGNO\n    to hold something of mode MODE.\n    This is ordinarily the length in words of a value of mode MODE\n    but can be less for certain modes in special long registers.\n \n-   On the SH regs are UNITS_PER_WORD bits wide; */\n+   On the SH regs are UNITS_PER_WORD bits wide.  */\n \n #define HARD_REGNO_NREGS(REGNO, MODE)  \\\n    (((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n-   We may keep double values in even registers */\n+   We may keep double values in even registers.  */\n \n extern int hard_regno_mode_ok[];\n #define HARD_REGNO_MODE_OK(REGNO, MODE)  \\\n@@ -437,7 +435,7 @@ extern int hard_regno_mode_ok[];\n /* Register in which the static-chain is passed to a function.  */\n #define STATIC_CHAIN_REGNUM\t13\n \n-/* The register in which a struct value address is passed */\n+/* The register in which a struct value address is passed.  */\n \n #define STRUCT_VALUE_REGNUM 2\n \n@@ -453,7 +451,6 @@ extern int hard_regno_mode_ok[];\n    exactly how to return structures in the RETURN_IN_MEMORY macro.  */\n \n #define DEFAULT_PCC_STRUCT_RETURN 0\n-\n \f\n /* Define the classes of registers for register constraints in the\n    machine description.  Also define ranges of constants.\n@@ -475,10 +472,10 @@ extern int hard_regno_mode_ok[];\n    For any two classes, it is very desirable that there be another\n    class that represents their union.  */\n \n-/* The SH has two sorts of general registers, R0 and the rest.  R0 can \n+/* The SH has two sorts of general registers, R0 and the rest.  R0 can\n    be used as the destination of some of the arithmetic ops. There are\n    also some special purpose registers; the T bit register, the\n-   Procedure Return Register and the Multipy Accumulate Registers */\n+   Procedure Return Register and the Multipy Accumulate Registers.  */\n \n enum reg_class\n {\n@@ -494,7 +491,7 @@ enum reg_class\n \n #define N_REG_CLASSES  (int) LIM_REG_CLASSES\n \n-/* Give names of register classes as strings for dump file.   */\n+/* Give names of register classes as strings for dump file.  */\n #define REG_CLASS_NAMES  \\\n {\t\t\t\\\n   \"NO_REGS\",\t\t\\\n@@ -531,7 +528,7 @@ extern int regno_reg_class[];\n \n /* When defined, the compiler allows registers explicitly used in the\n    rtl to be used as spill registers but prevents the compiler from\n-   extending the lifetime of these registers. */\n+   extending the lifetime of these registers.  */\n \n #define SMALL_REGISTER_CLASSES\n \n@@ -543,8 +540,8 @@ extern int regno_reg_class[];\n #define INDEX_REG_CLASS  R0_REGS\n #define BASE_REG_CLASS\t GENERAL_REGS\n \n-/* Get reg_class from a letter such as appears in the machine \n-   description. */\n+/* Get reg_class from a letter such as appears in the machine\n+   description.  */\n extern enum reg_class reg_class_from_letter[];\n \n #define REG_CLASS_FROM_LETTER(C) \\\n@@ -591,19 +588,12 @@ extern enum reg_class reg_class_from_letter[];\n \n #define PREFERRED_RELOAD_CLASS(X, CLASS) CLASS\n \n-/* Return the register class of a scratch register needed to copy IN into\n-   or out of a register in CLASS in MODE.  If it can be done directly,\n-   NO_REGS is returned.  */\n-\n-\n /* Return the maximum number of consecutive registers\n-   needed to represent mode MODE in a register of class CLASS. \n+   needed to represent mode MODE in a register of class CLASS.\n \n-   On SH this is the size of MODE in words */\n+   On SH this is the size of MODE in words.  */\n #define CLASS_MAX_NREGS(CLASS, MODE)  \\\n      ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n-\n \f\n /* Stack layout; function entry, exit and calling.  */\n \n@@ -615,17 +605,16 @@ extern enum reg_class reg_class_from_letter[];\n \n /* Define this if pushing a word on the stack\n    makes the stack pointer a smaller address.  */\n-#define STACK_GROWS_DOWNWARD  \n+#define STACK_GROWS_DOWNWARD\n \n /*  Define this macro if the addresses of local variable slots are at\n     negative offsets from the frame pointer.\n \n-    The SH only has positive indexes, so grow the frame up \n-*/\n+    The SH only has positive indexes, so grow the frame up.  */\n /* #define FRAME_GROWS_DOWNWARD */\n \n /* Offset from the frame pointer to the first local variable slot to\n-   be allocated. */\n+   be allocated.  */\n #define STARTING_FRAME_OFFSET  0\n \n /* If we generate an insn to push BYTES bytes,\n@@ -666,12 +655,10 @@ extern enum reg_class reg_class_from_letter[];\n #define FUNCTION_VALUE_REGNO_P(REGNO)  \\\n \t  ((REGNO) == FIRST_RET_REG)\n \n-/* 1 if N is a possible register number for function argument passing.*/\n+/* 1 if N is a possible register number for function argument passing.  */\n \n #define FUNCTION_ARG_REGNO_P(REGNO)  \\\n   ((REGNO) >= FIRST_PARM_REG && (REGNO) < (NPARM_REGS + FIRST_PARM_REG))\n-\n-\n \f\n /* Define a data type for recording info about an argument list\n    during the scan of that argument list.  This data type should\n@@ -689,11 +676,11 @@ extern enum reg_class reg_class_from_letter[];\n #define ROUND_ADVANCE(SIZE)\t\\\n   ((SIZE + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-/* Round a register number up to a proper boundary for an arg of mode \n-   MODE. \n-   \n+/* Round a register number up to a proper boundary for an arg of mode\n+   MODE.\n+\n    The SH doesn't care about double alignment, so we only\n-   round doubles to even regs when asked to explicitly. */\n+   round doubles to even regs when asked to explicitly.  */\n \n #define ROUND_REG(X, MODE) \t\t\t\t\t\\\n   ((TARGET_ALIGN_DOUBLE \t\t\t\t\t\\\n@@ -740,7 +727,6 @@ extern enum reg_class reg_class_from_letter[];\n    NPARM_REGS words is at least partially passed in a register unless\n    its data type forbids.  */\n \n-\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n     sh_function_arg (CUM, MODE, TYPE, NAMED)\n \n@@ -749,22 +735,21 @@ extern struct rtx_def *sh_function_arg();\n /* For an arg passed partly in registers and partly in memory,\n    this is the number of registers used.\n    For args passed entirely in registers or entirely in memory, zero.\n-   \n-   We sometimes split args */\n+\n+   We sometimes split args.  */\n \n #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n   sh_function_arg_partial_nregs (CUM, MODE, TYPE, NAMED)\n \n extern int current_function_anonymous_args;\n \n /* Perform any needed actions needed for a function that is receiving a\n-   variable number of arguments. */\n+   variable number of arguments.  */\n \n #define SETUP_INCOMING_VARARGS(ASF, MODE, TYPE, PAS, ST) \\\n   current_function_anonymous_args = 1;\n \n-\n-/* Call the function profiler with a given profile label. */\n+/* Call the function profiler with a given profile label.  */\n \n #define FUNCTION_PROFILER(STREAM,LABELNO)\t\t\t\\\n {\t\t\t\t\t\t\t\t\\\n@@ -773,20 +758,18 @@ extern int current_function_anonymous_args;\n \tfprintf(STREAM, \"\t.long\tLP%d\\n\", (LABELNO));\t\\\n }\n \n-\n /* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n    the stack pointer does not matter.  The value is tested only in\n    functions that have frame pointers.\n    No definition is equivalent to always zero.  */\n \n #define EXIT_IGNORE_STACK 1\n \n-/* Generate the assembly code for function exit \n-   Just dump out any accumulated constant table.*/\n+/* Generate the assembly code for function exit\n+   Just dump out any accumulated constant table.  */\n \n #define FUNCTION_EPILOGUE(STREAM, SIZE)  function_epilogue (STREAM, SIZE)\n \n-\n /* Output assembler code for a block containing the constant parts\n    of a trampoline, leaving space for the variable parts.\n \n@@ -796,8 +779,7 @@ extern int current_function_anonymous_args;\n    3 0004 4D2B     \t\tjmp\t@r13\n    4 0006 200B     \t\tor\tr0,r0\n    5 0008 00000000 \tl1:  \t.long   function\n-   6 000c 00000000 \tl2:\t.long   area\t\n-*/\n+   6 000c 00000000 \tl2:\t.long   area  */\n #define TRAMPOLINE_TEMPLATE(FILE)  \t\t\\\n {\t\t\t\t\t\t\\\n   fprintf ((FILE), \"\t.word\t0xd301\\n\");\t\\\n@@ -825,7 +807,6 @@ extern int current_function_anonymous_args;\n   emit_move_insn (gen_rtx (MEM, SImode, plus_constant ((TRAMP), 12)),\t\\\n \t\t  (FNADDR));\t\t\t\t\t\t\\\n }\n-\n \f\n /* Addressing modes, and classification of registers for them.  */\n #define HAVE_POST_INCREMENT  1\n@@ -839,17 +820,15 @@ extern int current_function_anonymous_args;\n    They give nonzero only if REGNO is a hard reg of the suitable class\n    or a pseudo reg currently allocated to a suitable hard reg.\n    Since they use reg_renumber, they are safe only once reg_renumber\n-   has been allocated, which happens in local-alloc.c.\n-\n-*/\n+   has been allocated, which happens in local-alloc.c.  */\n \n #define REGNO_OK_FOR_BASE_P(REGNO)  \\\n   ((REGNO) < PR_REG || (unsigned) reg_renumber[(REGNO)] < PR_REG)\n #define REGNO_OK_FOR_INDEX_P(REGNO)   \\\n   ((REGNO) == 0 || (unsigned) reg_renumber[(REGNO)] == 0)\n \n-/* Maximum number of registers that can appear in a valid memory \n-   address. */\n+/* Maximum number of registers that can appear in a valid memory\n+   address.  */\n \n #define MAX_REGS_PER_ADDRESS 2\n \n@@ -858,12 +837,11 @@ extern int current_function_anonymous_args;\n #define CONSTANT_ADDRESS_P(X) \t\\\n   (GET_CODE (X) == LABEL_REF)\n \n-/* Nonzero if the constant value X is a legitimate general operand. */\n+/* Nonzero if the constant value X is a legitimate general operand.  */\n \n #define LEGITIMATE_CONSTANT_P(X) \\\n   (GET_CODE(X) != CONST_DOUBLE /*&& GET_CODE(X) != LABEL_REF*/)\n \n-\n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n    and check its validity for a certain class.\n    We have two alternate definitions for each of them.\n@@ -873,13 +851,9 @@ extern int current_function_anonymous_args;\n \n #define MODE_DISP_OK_4(X,MODE) ((GET_MODE_SIZE(MODE)==4) && ((unsigned)INTVAL(X)<64) && (!(INTVAL(X) &3)))\n #define MODE_DISP_OK_8(X,MODE) ((GET_MODE_SIZE(MODE)==8) && ((unsigned)INTVAL(X)<60) && (!(INTVAL(X) &3)))\n-/* ??? These two work only if the target is R0, so we do not support them.  */\n-#define MODE_DISP_OK_2(X,MODE) (0)\n-#define MODE_DISP_OK_1(X,MODE) (0)\n \n #ifndef REG_OK_STRICT\n \n-\n /* Nonzero if X is a hard reg that can be used as a base reg\n    or if it is a pseudo reg.  */\n #define REG_OK_FOR_BASE_P(X) \\\n@@ -906,7 +880,7 @@ extern int current_function_anonymous_args;\n \t(REGNO_OK_FOR_BASE_P (REGNO (X)))\n #endif\n \n-/* The Q is a pc relative load operand */\n+/* The Q is a pc relative load operand.  */\n #define EXTRA_CONSTRAINT_Q(OP)                          \t\t\\\n   (GET_CODE (OP) == MEM && \t\t\t\t\t\t\\\n    ((GET_CODE (XEXP (OP, 0)) == LABEL_REF)\t\t\t\t\\\n@@ -925,7 +899,6 @@ extern int current_function_anonymous_args;\n #define EXTRA_CONSTRAINT(OP, C)   \\\n      ((C) == 'Q' ? EXTRA_CONSTRAINT_Q (OP)   \\\n     : 0)\n-\n \f\n /* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n    that is a valid memory address for an instruction.\n@@ -943,30 +916,27 @@ extern int current_function_anonymous_args;\n \n /* Jump to LABEL if X is a valid address RTX.  This must also take\n    REG_OK_STRICT into account when deciding about valid registers, but it uses\n-   the above macros so we are in luck.  \n- \n+   the above macros so we are in luck.\n+\n    Allow  REG\n \t  REG+disp\n \t  REG+r0\n \t  REG++\n-\t  --REG\n-*/\n+\t  --REG  */\n \n-/* The SH allows a displacement in a QI or HI amode, but only when the \n+/* The SH allows a displacement in a QI or HI amode, but only when the\n    other operand is R0. GCC doesn't handle this very well, so we forgo\n    all of that.\n \n-   A legitimate index for a QI or HI is 0, SI and above can be any \n-   number 0..63 */\n+   A legitimate index for a QI or HI is 0, SI and above can be any\n+   number 0..63.  */\n \n #define GO_IF_LEGITIMATE_INDEX(MODE, REGNO, OP, LABEL)  \t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n     if (GET_CODE (OP) == CONST_INT) \t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n \tif (MODE_DISP_OK_4 (OP, MODE))  goto LABEL;\t\t      \t\\\n \tif (MODE_DISP_OK_8 (OP, MODE))  goto LABEL;\t\t      \t\\\n-\tif (MODE_DISP_OK_2 (OP, MODE))  goto LABEL;\t\t      \t\\\n-\tif (MODE_DISP_OK_1 (OP, MODE))  goto LABEL;\t\t      \t\\\n       }\t\t\t\t\t\t\t\t\t\\\n   } while(0)\n \n@@ -998,10 +968,9 @@ extern int current_function_anonymous_args;\n \t   && GET_CODE (XEXP (X, 0)) == REG\t\t\t  \\\n \t   && REG_OK_FOR_PRE_POST_P (XEXP (X, 0)))\t\t  \\\n     goto LABEL;                                                   \\\n-}\t\t\t\t\t\t\t\t   \n-\t\t\t\t\t\t\t\t   \n-\f\t\t\t\t\t\t\t\t   \n-/* Try machine-dependent ways of modifying an illegitimate address \n+}\n+\f\n+/* Try machine-dependent ways of modifying an illegitimate address\n    to be legitimate.  If we find one, return the new, valid address.\n    This macro is used in only one place: `memory_address' in explow.c.\n \n@@ -1012,9 +981,7 @@ extern int current_function_anonymous_args;\n    GO_IF_LEGITIMATE_ADDRESS.\n \n    It is always safe for this macro to do nothing.  It exists to recognize\n-   opportunities to optimize the output.\n-\n-  */\n+   opportunities to optimize the output.  */\n \n #define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN) ;\n \n@@ -1034,15 +1001,15 @@ extern int current_function_anonymous_args;\n /* Define this if the tablejump instruction expects the table\n    to contain offsets from the address of the table.\n    Do not define this if the table should contain absolute addresses.  */\n-#define CASE_VECTOR_PC_RELATIVE \n+#define CASE_VECTOR_PC_RELATIVE\n \n /* Specify the tree operation to be used to convert reals to integers.  */\n #define IMPLICIT_FIX_EXPR  FIX_ROUND_EXPR\n \n /* This is the kind of divide that is easiest to do in the general case.  */\n #define EASY_DIV_EXPR  TRUNC_DIV_EXPR\n \n-/* 'char' is signed by default */\n+/* 'char' is signed by default.  */\n #define DEFAULT_SIGNED_CHAR  1\n \n /* The type of size_t unsigned int.  */\n@@ -1069,7 +1036,7 @@ extern int current_function_anonymous_args;\n #define LOAD_EXTEND_OP(MODE) SIGN_EXTEND\n \n /* Define this if zero-extension is slow (more than one real instruction).\n-   On the SH, it's only one instruction */\n+   On the SH, it's only one instruction.  */\n /* #define SLOW_ZERO_EXTEND */\n \n /* Nonzero if access to memory by bytes is slow and undesirable.  */\n@@ -1099,7 +1066,7 @@ extern int current_function_anonymous_args;\n /* Chars and shorts should be passed as ints.  */\n #define PROMOTE_PROTOTYPES 1\n \n-/* The machine modes of pointers and functions */\n+/* The machine modes of pointers and functions.  */\n #define Pmode  SImode\n #define FUNCTION_MODE  Pmode\n \n@@ -1131,6 +1098,7 @@ extern int current_function_anonymous_args;\n     return COSTS_N_INSNS (multcosts (X));\t\t\\\n   case ASHIFT:\t\t\t\t\t\t\\\n   case ASHIFTRT:\t\t\t\t\t\\\n+  case LSHIFTRT:\t\t\t\t\t\\\n     return COSTS_N_INSNS (shiftcosts (X)) ;\t\t\\\n   case DIV:\t\t\t\t\t\t\\\n   case UDIV:\t\t\t\t\t\t\\\n@@ -1146,8 +1114,8 @@ extern int current_function_anonymous_args;\n    are actually function calls with some special constraints on arguments\n    and register usage.\n \n-   These macros tell reorg that the references to arguments and \n-   register clobbers for insns of type sfunc do not appear to happen \n+   These macros tell reorg that the references to arguments and\n+   register clobbers for insns of type sfunc do not appear to happen\n    until after the millicode call.  This allows reorg to put insns\n    which set the argument registers into the delay slot of the millicode\n    call -- thus they act more like traditional CALL_INSNs.\n@@ -1168,35 +1136,33 @@ extern int current_function_anonymous_args;\n     && GET_CODE (PATTERN (X)) != SEQUENCE\t\\\n     && GET_CODE (PATTERN (X)) != USE\t\t\\\n     && GET_CODE (PATTERN (X)) != CLOBBER\t\\\n-    && get_attr_type (X) == TYPE_SFUNC))\t\n+    && get_attr_type (X) == TYPE_SFUNC))\n \n /* Compute extra cost of moving data between one register class\n-   and another.  \n+   and another.\n \n    On the SH it is hard to move into the T reg, but simple to load\n-   from it.\n-*/\n+   from it.  */\n \n #define REGISTER_MOVE_COST(SRCCLASS, DSTCLASS)  \\\n \t(((DSTCLASS == T_REGS) || (DSTCLASS == PR_REG)) ? 10 : 1)\n \f\n-/* Assembler output control */\n+/* Assembler output control.  */\n \n-/* The text to go at the start of the assembler file */\n-#define ASM_FILE_START(STREAM) \t\t\t\t\t\t\t\\\n-  output_file_start (STREAM, f_options, sizeof f_options / sizeof f_options[0], \\\n-\t\t     W_options, sizeof W_options / sizeof W_options[0]); \t\n-\n-\n-#define ASM_FILE_END(STREAM) \n+/* The text to go at the start of the assembler file.  */\n+#define ASM_FILE_START(STREAM) \t\t\t\t\t\t\\\n+  output_file_start (STREAM, f_options,\t\t\t\t\t\\\n+\t\t     sizeof f_options / sizeof f_options[0],\t\t\\\n+\t\t     W_options, sizeof W_options / sizeof W_options[0]);\n \n+#define ASM_FILE_END(STREAM)\n \n #define ASM_APP_ON  \t\t\"\"\n #define ASM_APP_OFF  \t\t\"\"\n #define FILE_ASM_OP \t\t\"\\t.file\\n\"\n #define IDENT_ASM_OP \t\t\"\\t.ident\\n\"\n \n-/* How to change between sections. */\n+/* How to change between sections.  */\n \n #define TEXT_SECTION_ASM_OP  \t\t\"\\t.text\"\n #define DATA_SECTION_ASM_OP  \t\t\"\\t.data\"\n@@ -1222,7 +1188,7 @@ dtors_section() \t\t\t\t\t     \\\n       fprintf (asm_out_file, \"%s\\n\", DTORS_SECTION_ASM_OP);  \\\n       in_section = in_dtors;\t\t\t\t     \\\n     }\t\t\t\t\t\t\t     \\\n-}                                                            \n+}\n \n /* A C statement to output something to the assembler file to switch to section\n    NAME for object DECL which is either a FUNCTION_DECL, a VAR_DECL or\n@@ -1238,7 +1204,7 @@ dtors_section() \t\t\t\t\t     \\\n #define ASM_OUTPUT_DESTRUCTOR(FILE,NAME)\t\\\n    do {  dtors_section();  fprintf(FILE,\"\\t.long\\t_%s\\n\", NAME); } while (0)\n \n-#undef DO_GLOBAL_CTORS_BODY                     \n+#undef DO_GLOBAL_CTORS_BODY\n \n #define DO_GLOBAL_CTORS_BODY\t\t\t\\\n {\t\t\t\t\t\t\\\n@@ -1250,9 +1216,9 @@ dtors_section() \t\t\t\t\t     \\\n     {\t\t\t\t\t\t\\\n       (*--p)();\t\t\t\t\t\\\n     }\t\t\t\t\t\t\\\n-}\t\t\t\t\t\t\n+}\n \n-#undef DO_GLOBAL_DTORS_BODY\t\t\t \n+#undef DO_GLOBAL_DTORS_BODY\n #define DO_GLOBAL_DTORS_BODY                    \\\n {\t\t\t\t\t\t\\\n   typedef (*pfunc)();\t\t\t\t\\\n@@ -1263,7 +1229,7 @@ dtors_section() \t\t\t\t\t     \\\n     {\t\t\t\t\t\t\\\n       (*p)();\t\t\t\t\t\\\n     }\t\t\t\t\t\t\\\n-}\t\t\t\t\t\t \n+}\n \n \n #define ASM_OUTPUT_REG_PUSH(file, v) \\\n@@ -1272,7 +1238,7 @@ dtors_section() \t\t\t\t\t     \\\n #define ASM_OUTPUT_REG_POP(file, v) \\\n   fprintf (file, \"\\tmov.l\t@r15+,r%s\\n\", v);\n \n-  \n+\n /* The assembler's names for the registers.  RFP need not always be used as\n    the Real framepointer; it can also be used as a normal general register.\n    Note that the name `fp' is horribly misleading since `fp' is in fact only\n@@ -1284,7 +1250,7 @@ dtors_section() \t\t\t\t\t     \\\n   \"ap\", \"pr\", \"t\",  \"gbr\", \"mach\",\"macl\" \t\t\\\n }\n \n-/* DBX register number for a given compiler register number */\n+/* DBX register number for a given compiler register number.  */\n #define DBX_REGISTER_NUMBER(REGNO)  (REGNO)\n \n /* Output a label definition.  */\n@@ -1329,19 +1295,19 @@ dtors_section() \t\t\t\t\t     \\\n   ((OUTVAR) = (char *) alloca (strlen (NAME) + 10),  \\\n    sprintf ((OUTVAR), \"%s.%d\", (NAME), (NUMBER)))\n \n-/* Jump tables must be 32 bit aligned, no matter the size of the element */\n+/* Jump tables must be 32 bit aligned, no matter the size of the element.  */\n #define ASM_OUTPUT_CASE_LABEL(STREAM,PREFIX,NUM,TABLE) \\\n     fprintf (STREAM, \"\\t.align 2\\n%s%d:\\n\",  PREFIX, NUM);\n \n-/* Output a relative address table. */\n+/* Output a relative address table.  */\n \n #define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM,VALUE,REL)  \t\t\t\\\n   if (TARGET_BIGTABLE) \t\t\t\t\t\t\t\\\n \tfprintf (STREAM, \"\\t.long\tL%d-L%d\\n\", VALUE,REL); \t\\\n   else\t\t\t\t\t\t\t\t\t\\\n \tfprintf (STREAM, \"\\t.word\tL%d-L%d\\n\", VALUE,REL); \t\\\n \n-/* Output an absolute table element */\n+/* Output an absolute table element.  */\n \n #define ASM_OUTPUT_ADDR_VEC_ELT(STREAM,VALUE)  \t\t\t\t\\\n   if (TARGET_BIGTABLE) \t\t\t\t\t\t\t\\\n@@ -1352,7 +1318,7 @@ dtors_section() \t\t\t\t\t     \\\n /* Output various types of constants.  */\n \n \n-/* This is how to output an assembler line defining a `double' */\n+/* This is how to output an assembler line defining a `double'.  */\n \n #define ASM_OUTPUT_DOUBLE(FILE,VALUE)\t\t\t\\\n do { char dstr[30];\t\t\t\t\t\\\n@@ -1371,12 +1337,12 @@ do { char dstr[30];\t\t\t\t\t\\\n #define ASM_OUTPUT_INT(STREAM, EXP)  \t\\\n   (fprintf (STREAM, \"\\t.long\\t\"),      \t\\\n    output_addr_const (STREAM, (EXP)),  \t\\\n-   fputc ('\\n', STREAM))\t\t\n+   fputc ('\\n', STREAM))\n \n #define ASM_OUTPUT_SHORT(STREAM, EXP)  \\\n   (fprintf (STREAM, \"\\t.short\\t\"),     \\\n    output_addr_const (STREAM, (EXP)),  \\\n-   fputc ('\\n', STREAM))\t\t\n+   fputc ('\\n', STREAM))\n \n #define ASM_OUTPUT_CHAR(STREAM, EXP)  \t\\\n   (fprintf (STREAM, \"\\t.byte\\t\"),      \t\\\n@@ -1422,7 +1388,6 @@ do { char dstr[30];\t\t\t\t\t\\\n #define TARGET_FF\t014\n #define TARGET_CR\t015\n \f\n-\n /* Only perform branch elimination (by making instructions conditional) if\n    we're optimising.  Otherwise it's of no use anyway.  */\n #define FINAL_PRESCAN_INSN(INSN, OPVEC, NOPERANDS)  \\\n@@ -1440,19 +1405,26 @@ do { char dstr[30];\t\t\t\t\t\\\n \n #define PRINT_OPERAND_PUNCT_VALID_P(CHAR) \\\n   ((CHAR)=='.' || (CHAR) == '#' || (CHAR)=='@')\n-\n \f\n extern struct rtx_def *sh_compare_op0;\n extern struct rtx_def *sh_compare_op1;\n extern struct rtx_def *prepare_scc_operands();\n-extern struct rtx_def *table_lab;\n \n \n-/* ??? Wrong, this is an incomplete enum type.  Fix this to do it the same\n-   way that the mips compiler does this.  */\n-extern enum attr_cpu sh_cpu;\t/* target cpu */\n+/* Which processor to schedule for.  The elements of the enumeration must\n+   match exactly the cpu attribute in the sh.md file.  */\n \n-/* Declare functions defined in sh.c and used in templates. */\n+enum processor_type {\n+  PROCESSOR_SH0,\n+  PROCESSOR_SH1,\n+  PROCESSOR_SH2,\n+  PROCESSOR_SH3\n+};\n+\n+#define sh_cpu_attr ((enum attr_cpu)sh_cpu)\n+extern enum processor_type sh_cpu;\n+\n+/* Declare functions defined in sh.c and used in templates.  */\n \n extern char *output_branch();\n extern char *output_shift();\n@@ -1461,7 +1433,6 @@ extern char *output_movepcrel();\n extern char *output_jump_label_table();\n extern char *output_far_jump();\n \n-\n #define MACHINE_DEPENDENT_REORG(X) machine_dependent_reorg(X)\n \n /* Generate calls to memcpy, memcmp and memset.  */\n@@ -1470,7 +1441,7 @@ extern char *output_far_jump();\n \n #define HANDLE_PRAGMA(finput) return handle_pragma (finput)\n \n-/* Set when processing a function with pragma interrupt turned on. */\n+/* Set when processing a function with pragma interrupt turned on.  */\n \n extern int pragma_interrupt;\n #define MOVE_RATIO (TARGET_SMALLCODE ? 4 : 16)\n@@ -1483,8 +1454,6 @@ extern int max_count_hi;\n /* Instructions with unfilled delay slots take up an extra two bytes for\n    the nop in the delay slot.  */\n \n-/* ??? Does this catch conditional branches when -m2?  */\n-\n #define ADJUST_INSN_LENGTH(X, LENGTH)\t\t\t\t\\\n   if (((GET_CODE (X) == INSN\t\t\t\t\t\\\n \t&& GET_CODE (PATTERN (X)) != SEQUENCE\t\t\t\\"}]}