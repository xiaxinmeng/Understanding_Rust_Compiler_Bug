{"sha": "3245eea08ab719267d7f74ffba7043130dde8478", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzI0NWVlYTA4YWI3MTkyNjdkN2Y3NGZmYmE3MDQzMTMwZGRlODQ3OA==", "commit": {"author": {"name": "Charles Hannum", "email": "mycroft@gnu.org", "date": "1992-07-06T19:55:04Z"}, "committer": {"name": "Charles Hannum", "email": "mycroft@gnu.org", "date": "1992-07-06T19:55:04Z"}, "message": "entered into RCS\n\nFrom-SVN: r1466", "tree": {"sha": "ccd880ce2afcd724a5eb67c4c75ccbd616e3afbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ccd880ce2afcd724a5eb67c4c75ccbd616e3afbf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3245eea08ab719267d7f74ffba7043130dde8478", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3245eea08ab719267d7f74ffba7043130dde8478", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3245eea08ab719267d7f74ffba7043130dde8478", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3245eea08ab719267d7f74ffba7043130dde8478/comments", "author": null, "committer": null, "parents": [{"sha": "f2b63869e3f184f3092f549caadb89f0f12416ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2b63869e3f184f3092f549caadb89f0f12416ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2b63869e3f184f3092f549caadb89f0f12416ab"}], "stats": {"total": 366, "additions": 349, "deletions": 17}, "files": [{"sha": "bd9fdf3058709d151512130d48f2e4c7a753e59c", "filename": "gcc/basic-block.h", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3245eea08ab719267d7f74ffba7043130dde8478/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3245eea08ab719267d7f74ffba7043130dde8478/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=3245eea08ab719267d7f74ffba7043130dde8478", "patch": "@@ -0,0 +1,68 @@\n+/* Define control and data flow tables, and regsets.\n+   Copyright (C) 1987 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* Number of bits in each actual element of a regset.  */\n+\n+#define REGSET_ELT_BITS HOST_BITS_PER_WIDE_INT\n+\n+/* Type to use for a regset element.  Note that lots of code assumes\n+   that the initial part of a regset that contains information on the\n+   hard registers is the same format as a HARD_REG_SET.  */\n+\n+#define REGSET_ELT_TYPE HOST_WIDE_INT\n+\n+/* Define the type for a pointer to a set with a bit for each\n+   (hard or pseudo) register.  */\n+\n+typedef REGSET_ELT_TYPE *regset;\n+\n+/* Size of a regset for the current function,\n+   in (1) bytes and (2) elements.  */\n+\n+extern int regset_bytes;\n+extern int regset_size;\n+\n+/* Number of basic blocks in the current function.  */\n+\n+extern int n_basic_blocks;\n+\n+/* Index by basic block number, get first insn in the block.  */\n+\n+extern rtx *basic_block_head;\n+\n+/* Index by basic block number, get last insn in the block.  */\n+\n+extern rtx *basic_block_end;\n+\n+/* Index by basic block number, get address of regset\n+   describing the registers live at the start of that block.  */\n+\n+extern regset *basic_block_live_at_start;\n+\n+/* Indexed by n, gives number of basic block that  (REG n) is used in.\n+   If the value is REG_BLOCK_GLOBAL (-2),\n+   it means (REG n) is used in more than one basic block.\n+   REG_BLOCK_UNKNOWN (-1) means it hasn't been seen yet so we don't know.\n+   This information remains valid for the rest of the compilation\n+   of the current function; it is used to control register allocation.  */\n+\n+#define REG_BLOCK_UNKNOWN -1\n+#define REG_BLOCK_GLOBAL -2\n+extern short *reg_basic_block;"}, {"sha": "025543a725ebe0185919449a2be776416c539bb6", "filename": "gcc/caller-save.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3245eea08ab719267d7f74ffba7043130dde8478/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3245eea08ab719267d7f74ffba7043130dde8478/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=3245eea08ab719267d7f74ffba7043130dde8478", "patch": "@@ -165,8 +165,7 @@ init_caller_save ()\n \n   for (offset = 1 << (HOST_BITS_PER_INT / 2); offset; offset >>= 1)\n     {\n-      address = gen_rtx (PLUS, Pmode, addr_reg,\n-\t\t\t gen_rtx (CONST_INT, VOIDmode, offset));\n+      address = gen_rtx (PLUS, Pmode, addr_reg, GEN_INT (offset));\n \n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \tif (regno_save_mode[i] != VOIDmode\n@@ -275,7 +274,7 @@ setup_save_areas (pchanged)\n     if (regno_save_mem[i] != 0)\n       ok &= strict_memory_address_p (regno_save_mode[i],\n \t\t\t\t     XEXP (eliminate_regs (regno_save_mem[i],\n-\t\t\t\t\t\t\t   0, 0),\n+\t\t\t\t\t\t\t   0, NULL_RTX),\n \t\t\t\t\t   0));\n \n   return ok;\n@@ -297,7 +296,8 @@ save_call_clobbered_regs (insn_mode)\n   for (b = 0; b < n_basic_blocks; b++)\n     {\n       regset regs_live = basic_block_live_at_start[b];\n-      int offset, bit, i, j;\n+      REGSET_ELT_TYPE bit;\n+      int offset, i, j;\n       int regno;\n \n       /* Compute hard regs live at start of block -- this is the\n@@ -318,7 +318,7 @@ save_call_clobbered_regs (insn_mode)\n       for (offset = 0, i = 0; offset < regset_size; offset++)\n \t{\n \t  if (regs_live[offset] == 0)\n-\t    i += HOST_BITS_PER_INT;\n+\t    i += REGSET_ELT_BITS;\n \t  else\n \t    for (bit = 1; bit && i < max_regno; bit <<= 1, i++)\n \t      if ((regs_live[offset] & bit)"}, {"sha": "6b6d9bf93ac6695679faf5fdf6f98d047d33798f", "filename": "gcc/expr.h", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3245eea08ab719267d7f74ffba7043130dde8478/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3245eea08ab719267d7f74ffba7043130dde8478/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=3245eea08ab719267d7f74ffba7043130dde8478", "patch": "@@ -153,10 +153,10 @@ struct args_size\n \n /* Convert the implicit sum in a `struct args_size' into an rtx.  */\n #define ARGS_SIZE_RTX(SIZE)\t\t\t\t\t\t\\\n-((SIZE).var == 0 ? gen_rtx (CONST_INT, VOIDmode, (SIZE).constant)\t\\\n+((SIZE).var == 0 ? GEN_INT ((SIZE).constant)\t\\\n  : expand_expr (size_binop (PLUS_EXPR, (SIZE).var,\t\t\t\\\n \t\t\t    size_int ((SIZE).constant)),\t\t\\\n-\t\t0, VOIDmode, 0))\n+\t\tNULL_RTX, VOIDmode, 0))\n \n /* Convert the implicit sum in a `struct args_size' into a tree.  */\n #define ARGS_SIZE_TREE(SIZE)\t\t\t\t\t\t\\\n@@ -527,9 +527,6 @@ extern rtx force_operand ();\n /* Return an rtx for the size in bytes of the value of an expr.  */\n extern rtx expr_size ();\n \n-/* Return an rtx for the sum of an rtx and an integer.  */\n-extern rtx plus_constant ();\n-\n extern rtx lookup_static_chain ();\n \n /* Return an rtx like arg but sans any constant terms."}, {"sha": "1c3342a1c115b308c4187eaffe0d4f73e7f50079", "filename": "gcc/hard-reg-set.h", "status": "added", "additions": 267, "deletions": 0, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3245eea08ab719267d7f74ffba7043130dde8478/gcc%2Fhard-reg-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3245eea08ab719267d7f74ffba7043130dde8478/gcc%2Fhard-reg-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhard-reg-set.h?ref=3245eea08ab719267d7f74ffba7043130dde8478", "patch": "@@ -0,0 +1,267 @@\n+/* Sets (bit vectors) of hard registers, and operations on them.\n+   Copyright (C) 1987, 1992 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* Define the type of a set of hard registers.  */\n+\n+/* If HARD_REG_SET is a macro, its definition is a scalar type\n+   that has enough bits for all the target machine's hard registers.\n+   Otherwise, it is a typedef for a suitable array of HOST_WIDE_INTs,\n+   and HARD_REG_SET_LONGS is how many.\n+\n+   Note that lots of code assumes that the first part of a regset is\n+   the same format as a HARD_REG_SET.  To help make sure this is true,\n+   we only try the widest integer mode (HOST_WIDE_INT) instead of all the\n+   smaller types.  This only loses if there are a very few registers and\n+   then only in the few cases where we have an array of HARD_REG_SETs,\n+   so it isn't worth making this as complex as it used to be.  */\n+\n+#if FIRST_PSEUDO_REGISTER <= HOST_BITS_PER_WIDE_INT\n+#define HARD_REG_SET HOST_WIDE_INT\n+\n+#else\n+\n+#define HARD_REG_SET_LONGS \\\n+ ((FIRST_PSEUDO_REGISTER + HOST_BITS_PER_WIDE_INT - 1)\t\\\n+  / HOST_BITS_PER_WIDE_INT)\n+typedef HOST_WIDE_INT HARD_REG_SET[HARD_REG_SET_LONGS];\n+\n+#endif\n+\n+/* HARD_CONST is used to cast a constant to a HARD_REG_SET\n+   if that is a scalar wider than an integer.  */\n+\n+#ifdef HARD_REG_SET\n+#define HARD_CONST(X) ((HARD_REG_SET) (X))\n+#else\n+#define HARD_CONST(X) (X)\n+#endif\n+\n+/* Define macros SET_HARD_REG_BIT, CLEAR_HARD_REG_BIT and TEST_HARD_REG_BIT\n+   to set, clear or test one bit in a hard reg set of type HARD_REG_SET.\n+   All three take two arguments: the set and the register number.\n+\n+   In the case where sets are arrays of longs, the first argument\n+   is actually a pointer to a long.\n+\n+   Define two macros for initializing a set:\n+   CLEAR_HARD_REG_SET and SET_HARD_REG_SET.\n+   These take just one argument.\n+\n+   Also define macros for copying hard reg sets:\n+   COPY_HARD_REG_SET and COMPL_HARD_REG_SET.\n+   These take two arguments TO and FROM; they read from FROM\n+   and store into TO.  COMPL_HARD_REG_SET complements each bit.\n+\n+   Also define macros for combining hard reg sets:\n+   IOR_HARD_REG_SET and AND_HARD_REG_SET.\n+   These take two arguments TO and FROM; they read from FROM\n+   and combine bitwise into TO.  Define also two variants\n+   IOR_COMPL_HARD_REG_SET and AND_COMPL_HARD_REG_SET\n+   which use the complement of the set FROM.\n+\n+   Also define GO_IF_HARD_REG_SUBSET (X, Y, TO):\n+   if X is a subset of Y, go to TO.\n+*/\n+\n+#ifdef HARD_REG_SET\n+\n+#define SET_HARD_REG_BIT(SET, BIT)  \\\n+ ((SET) |= HARD_CONST (1) << (BIT))\n+#define CLEAR_HARD_REG_BIT(SET, BIT)  \\\n+ ((SET) &= ~(HARD_CONST (1) << (BIT)))\n+#define TEST_HARD_REG_BIT(SET, BIT)  \\\n+ ((SET) & (HARD_CONST (1) << (BIT)))\n+\n+#define CLEAR_HARD_REG_SET(TO) ((TO) = HARD_CONST (0))\n+#define SET_HARD_REG_SET(TO) ((TO) = HARD_CONST (-1))\n+\n+#define COPY_HARD_REG_SET(TO, FROM) ((TO) = (FROM))\n+#define COMPL_HARD_REG_SET(TO, FROM) ((TO) = ~(FROM))\n+\n+#define IOR_HARD_REG_SET(TO, FROM) ((TO) |= (FROM))\n+#define IOR_COMPL_HARD_REG_SET(TO, FROM) ((TO) |= ~ (FROM))\n+#define AND_HARD_REG_SET(TO, FROM) ((TO) &= (FROM))\n+#define AND_COMPL_HARD_REG_SET(TO, FROM) ((TO) &= ~ (FROM))\n+\n+#define GO_IF_HARD_REG_SUBSET(X,Y,TO) if (HARD_CONST (0) == ((X) & ~(Y))) goto TO\n+\n+#define GO_IF_HARD_REG_EQUAL(X,Y,TO) if ((X) == (Y)) goto TO\n+#else\n+\n+#define UHOST_BITS_PER_WIDE_INT ((unsigned) HOST_BITS_PER_WIDE_INT)\n+\n+#define SET_HARD_REG_BIT(SET, BIT)\t\t\\\n+  ((SET)[(BIT) / UHOST_BITS_PER_WIDE_INT]\t\\\n+   |= (HOST_WIDE_INT) 1 << ((BIT) % UHOST_BITS_PER_WIDE_INT))\n+\n+#define CLEAR_HARD_REG_BIT(SET, BIT)\t\t\\\n+  ((SET)[(BIT) / UHOST_BITS_PER_WIDE_INT]\t\\\n+   &= ~((HOST_WIDE_INT) 1 << ((BIT) % UHOST_BITS_PER_WIDE_INT)))\n+\n+#define TEST_HARD_REG_BIT(SET, BIT)\t\t\\\n+  ((SET)[(BIT) / UHOST_BITS_PER_WIDE_INT]\t\\\n+   & ((HOST_WIDE_INT) 1 << ((BIT) % UHOST_BITS_PER_WIDE_INT)))\n+\n+#define CLEAR_HARD_REG_SET(TO)  \\\n+do { register HOST_WIDE_INT *scan_tp_ = (TO);\t\t\t\\\n+     register int i;\t\t\t\t\t\t\\\n+     for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n+       *scan_tp_++ = 0; } while (0)\n+\n+#define SET_HARD_REG_SET(TO)  \\\n+do { register HOST_WIDE_INT *scan_tp_ = (TO);\t\t\t\\\n+     register int i;\t\t\t\t\t\t\\\n+     for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n+       *scan_tp_++ = -1; } while (0)\n+\n+#define COPY_HARD_REG_SET(TO, FROM)  \\\n+do { register HOST_WIDE_INT *scan_tp_ = (TO), *scan_fp_ = (FROM); \\\n+     register int i;\t\t\t\t\t\t\\\n+     for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n+       *scan_tp_++ = *scan_fp_++; } while (0)\n+\n+#define COMPL_HARD_REG_SET(TO, FROM)  \\\n+do { register HOST_WIDE_INT *scan_tp_ = (TO), *scan_fp_ = (FROM); \\\n+     register int i;\t\t\t\t\t\t\\\n+     for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n+       *scan_tp_++ = ~ *scan_fp_++; } while (0)\n+\n+#define AND_HARD_REG_SET(TO, FROM)  \\\n+do { register HOST_WIDE_INT *scan_tp_ = (TO), *scan_fp_ = (FROM); \\\n+     register int i;\t\t\t\t\t\t\\\n+     for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n+       *scan_tp_++ &= *scan_fp_++; } while (0)\n+\n+#define AND_COMPL_HARD_REG_SET(TO, FROM)  \\\n+do { register HOST_WIDE_INT *scan_tp_ = (TO), *scan_fp_ = (FROM); \\\n+     register int i;\t\t\t\t\t\t\\\n+     for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n+       *scan_tp_++ &= ~ *scan_fp_++; } while (0)\n+\n+#define IOR_HARD_REG_SET(TO, FROM)  \\\n+do { register HOST_WIDE_INT *scan_tp_ = (TO), *scan_fp_ = (FROM); \\\n+     register int i;\t\t\t\t\t\t\\\n+     for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n+       *scan_tp_++ |= *scan_fp_++; } while (0)\n+\n+#define IOR_COMPL_HARD_REG_SET(TO, FROM)  \\\n+do { register HOST_WIDE_INT *scan_tp_ = (TO), *scan_fp_ = (FROM); \\\n+     register int i;\t\t\t\t\t\t\\\n+     for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n+       *scan_tp_++ |= ~ *scan_fp_++; } while (0)\n+\n+#define GO_IF_HARD_REG_SUBSET(X,Y,TO)  \\\n+do { register HOST_WIDE_INT *scan_xp_ = (X), *scan_yp_ = (Y);\t\\\n+     register int i;\t\t\t\t\t\t\\\n+     for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n+       if (0 != (*scan_xp_++ & ~*scan_yp_++)) break;\t\t\\\n+     if (i == HARD_REG_SET_LONGS) goto TO; } while (0)\n+\n+#define GO_IF_HARD_REG_EQUAL(X,Y,TO)  \\\n+do { register HOST_WIDE_INT *scan_xp_ = (X), *scan_yp_ = (Y);\t\\\n+     register int i;\t\t\t\t\t\t\\\n+     for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n+       if (*scan_xp_++ != ~*scan_yp_++)) break;\t\t\t\\\n+     if (i == HARD_REG_SET_LONGS) goto TO; } while (0)\n+\n+#endif\n+\n+/* Define some standard sets of registers.  */\n+\n+/* Indexed by hard register number, contains 1 for registers\n+   that are fixed use (stack pointer, pc, frame pointer, etc.).\n+   These are the registers that cannot be used to allocate\n+   a pseudo reg whose life does not cross calls.  */\n+\n+extern char fixed_regs[FIRST_PSEUDO_REGISTER];\n+\n+/* The same info as a HARD_REG_SET.  */\n+\n+extern HARD_REG_SET fixed_reg_set;\n+\n+/* Indexed by hard register number, contains 1 for registers\n+   that are fixed use or are clobbered by function calls.\n+   These are the registers that cannot be used to allocate\n+   a pseudo reg whose life crosses calls.  */\n+\n+extern char call_used_regs[FIRST_PSEUDO_REGISTER];\n+\n+/* The same info as a HARD_REG_SET.  */\n+\n+extern HARD_REG_SET call_used_reg_set;\n+  \n+/* Indexed by hard register number, contains 1 for registers that are\n+   fixed use -- i.e. in fixed_regs -- or a function value return register\n+   or STRUCT_VALUE_REGNUM or STATIC_CHAIN_REGNUM.  These are the\n+   registers that cannot hold quantities across calls even if we are\n+   willing to save and restore them.  */\n+\n+extern char call_fixed_regs[FIRST_PSEUDO_REGISTER];\n+\n+/* The same info as a HARD_REG_SET.  */\n+\n+extern HARD_REG_SET call_fixed_reg_set;\n+\n+/* Indexed by hard register number, contains 1 for registers\n+   that are being used for global register decls.\n+   These must be exempt from ordinary flow analysis\n+   and are also considered fixed.  */\n+\n+extern char global_regs[FIRST_PSEUDO_REGISTER];\n+\n+/* Table of register numbers in the order in which to try to use them.  */\n+\n+#ifdef REG_ALLOC_ORDER   /* Avoid undef symbol in certain broken linkers.  */\n+extern int reg_alloc_order[FIRST_PSEUDO_REGISTER];\n+#endif\n+\n+/* For each reg class, a HARD_REG_SET saying which registers are in it.  */\n+\n+extern HARD_REG_SET reg_class_contents[];\n+\n+/* For each reg class, number of regs it contains.  */\n+\n+extern int reg_class_size[N_REG_CLASSES];\n+\n+/* For each reg class, table listing all the containing classes.  */\n+\n+extern enum reg_class reg_class_superclasses[N_REG_CLASSES][N_REG_CLASSES];\n+\n+/* For each reg class, table listing all the classes contained in it.  */\n+\n+extern enum reg_class reg_class_subclasses[N_REG_CLASSES][N_REG_CLASSES];\n+\n+/* For each pair of reg classes,\n+   a largest reg class contained in their union.  */\n+\n+extern enum reg_class reg_class_subunion[N_REG_CLASSES][N_REG_CLASSES];\n+\n+/* For each pair of reg classes,\n+   the smallest reg class that contains their union.  */\n+\n+extern enum reg_class reg_class_superunion[N_REG_CLASSES][N_REG_CLASSES];\n+\n+/* Number of non-fixed registers.  */\n+\n+extern int n_non_fixed_regs;\n+\n+/* Vector indexed by hardware reg giving its name.  */\n+\n+extern char *reg_names[FIRST_PSEUDO_REGISTER];"}, {"sha": "7def978ea2835a95566e93ec2bb2c1d83e79d239", "filename": "gcc/loop.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3245eea08ab719267d7f74ffba7043130dde8478/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3245eea08ab719267d7f74ffba7043130dde8478/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=3245eea08ab719267d7f74ffba7043130dde8478", "patch": "@@ -100,7 +100,7 @@ struct induction\n   struct induction *same;\t/* If this giv has been combined with another\n \t\t\t\t   giv, this points to the base giv.  The base\n \t\t\t\t   giv will have COMBINED_WITH non-zero.  */\n-  int const_adjust;\t\t/* Used by loop unrolling, when an address giv\n+  HOST_WIDE_INT const_adjust;\t/* Used by loop unrolling, when an address giv\n \t\t\t\t   is split, and a constant is eliminated from\n \t\t\t\t   the address, the -constant is stored here\n \t\t\t\t   for later use. */\n@@ -141,7 +141,7 @@ extern int max_uid_for_loop;\n extern int *uid_loop_num;\n extern int *loop_outer_loop;\n extern rtx *loop_number_exit_labels;\n-extern unsigned long loop_n_iterations;\n+extern unsigned HOST_WIDE_INT loop_n_iterations;\n extern int max_reg_before_loop;\n \n extern FILE *loop_dump_stream;\n@@ -169,7 +169,7 @@ void unroll_block_trees ();\n \n void unroll_loop ();\n rtx biv_total_increment ();\n-unsigned long loop_iterations ();\n+unsigned HOST_WIDE_INT loop_iterations ();\n rtx final_biv_value ();\n rtx final_giv_value ();\n void emit_unrolled_add ();"}, {"sha": "7e6579fff6e05f0e764f1a7a0545f774a3374ab8", "filename": "gcc/real.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3245eea08ab719267d7f74ffba7043130dde8478/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3245eea08ab719267d7f74ffba7043130dde8478/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=3245eea08ab719267d7f74ffba7043130dde8478", "patch": "@@ -53,7 +53,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define\tREAL_IS_NOT_DOUBLE\n #ifndef REAL_VALUE_TYPE\n #define REAL_VALUE_TYPE \\\n-  struct real_value { long i[sizeof (double) / sizeof (long)]; }\n+  struct real_value{ HOST_WIDE_INT i[sizeof (double)/sizeof (HOST_WIDE_INT)]; }\n #endif /* no REAL_VALUE_TYPE */\n #endif /* formats differ */\n #endif /* 0 */\n@@ -196,7 +196,7 @@ extern REAL_VALUE_TYPE dconstm1;\n union real_extract \n {\n   REAL_VALUE_TYPE d;\n-  int i[sizeof (REAL_VALUE_TYPE) / sizeof (int)];\n+  HOST_WIDE_INT i[sizeof (REAL_VALUE_TYPE) / sizeof (HOST_WIDE_INT)];\n };\n \n /* For a CONST_DOUBLE:\n@@ -206,8 +206,8 @@ union real_extract\n    For a float, the number of ints varies,\n     and CONST_DOUBLE_LOW is the one that should come first *in memory*.\n     So use &CONST_DOUBLE_LOW(r) as the address of an array of ints.  */\n-#define CONST_DOUBLE_LOW(r) XINT (r, 2)\n-#define CONST_DOUBLE_HIGH(r) XINT (r, 3)\n+#define CONST_DOUBLE_LOW(r) XWINT (r, 2)\n+#define CONST_DOUBLE_HIGH(r) XWINT (r, 3)\n \n /* Link for chain of all CONST_DOUBLEs in use in current function.  */\n #define CONST_DOUBLE_CHAIN(r) XEXP (r, 1)"}]}