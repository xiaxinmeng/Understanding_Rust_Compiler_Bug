{"sha": "0e99e0933984e0c30fda1d089bfbd6857fc9273f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGU5OWUwOTMzOTg0ZTBjMzBmZGExZDA4OWJmYmQ2ODU3ZmM5MjczZg==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2019-08-13T08:24:43Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2019-08-13T08:24:43Z"}, "message": "PR fortran/91414: Improved PRNG\n\nUpdate the PRNG from xorshift1024* to xoshiro256** by the same\nauthor. For details see\n\nhttp://prng.di.unimi.it/\n\nand the paper at\n\nhttps://arxiv.org/abs/1805.01407\n\nAlso the seeding is slightly improved, by reading only 8 bytes from\nthe operating system and using the simple splitmix64 PRNG to fill in\nthe rest of the PRNG state (as recommended by the xoshiro author),\ninstead of reading the entire state from the OS.\n\nRegtested on x86_64-pc-linux-gnu, Ok for trunk?\n\ngcc/fortran/ChangeLog:\n\n2019-08-13  Janne Blomqvist  <jb@gcc.gnu.org>\n\n\tPR fortran/91414\n\t* check.c (gfc_check_random_seed): Reduce seed_size.\n\t* intrinsic.texi (RANDOM_NUMBER): Update to match new PRNG.\n\ngcc/testsuite/ChangeLog:\n\n2019-08-13  Janne Blomqvist  <jb@gcc.gnu.org>\n\n\tPR fortran/91414\n\t* gfortran.dg/random_seed_1.f90: Update to match new seed size.\n\nlibgfortran/ChangeLog:\n\n2019-08-13  Janne Blomqvist  <jb@gcc.gnu.org>\n\n\tPR fortran/91414\n\t* intrinsics/random.c (prng_state): Update state struct.\n\t(master_state): Update to match new size.\n\t(get_rand_state): Update to match new PRNG.\n\t(rotl): New function.\n\t(xorshift1024star): Replace with prng_next.\n\t(prng_next): New function.\n\t(jump): Update for new PRNG.\n\t(lcg_parkmiller): Replace with splitmix64.\n\t(splitmix64): New function.\n\t(getosrandom): Fix return value, simplify.\n\t(init_rand_state): Use getosrandom only to get 8 bytes, splitmix64\n\tto fill rest of state.\n\t(random_r4): Update to new function and struct names.\n\t(random_r8): Likewise.\n\t(random_r10): Likewise.\n\t(random_r16): Likewise.\n\t(arandom_r4): Liekwise.\n\t(arandom_r8): Likewise.\n\t(arandom_r10): Likwewise.\n\t(arandom_r16): Likewise.\n\t(xor_keys): Reduce size to match new PRNG.\n\t(random_seed_i4): Update to new function and struct names, remove\n\tspecial handling of variable p used in previous PRNG.\n\t(random_seed_i8): Likewise.\n\nFrom-SVN: r274361", "tree": {"sha": "3f4221e36f548096ee6f0e64dab1b2660ceda1c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f4221e36f548096ee6f0e64dab1b2660ceda1c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e99e0933984e0c30fda1d089bfbd6857fc9273f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e99e0933984e0c30fda1d089bfbd6857fc9273f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e99e0933984e0c30fda1d089bfbd6857fc9273f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e99e0933984e0c30fda1d089bfbd6857fc9273f/comments", "author": null, "committer": null, "parents": [{"sha": "519acab098317f6eab49b612e49d8fcc6562da8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/519acab098317f6eab49b612e49d8fcc6562da8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/519acab098317f6eab49b612e49d8fcc6562da8f"}], "stats": {"total": 274, "additions": 149, "deletions": 125}, "files": [{"sha": "7131d0fb7f9d345604746f04b7c4c89a76e83a0f", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e99e0933984e0c30fda1d089bfbd6857fc9273f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e99e0933984e0c30fda1d089bfbd6857fc9273f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=0e99e0933984e0c30fda1d089bfbd6857fc9273f", "patch": "@@ -1,3 +1,9 @@\n+2019-08-13  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+        PR fortran/91414\n+        * check.c (gfc_check_random_seed): Reduce seed_size.\n+        * intrinsic.texi (RANDOM_NUMBER): Update to match new PRNG.\n+\n 2019-08-12  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/91424"}, {"sha": "2bd8bc3755672405eb67b78beb115c53ae529860", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e99e0933984e0c30fda1d089bfbd6857fc9273f/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e99e0933984e0c30fda1d089bfbd6857fc9273f/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=0e99e0933984e0c30fda1d089bfbd6857fc9273f", "patch": "@@ -6484,9 +6484,8 @@ gfc_check_random_seed (gfc_expr *size, gfc_expr *put, gfc_expr *get)\n   mpz_t put_size, get_size;\n \n   /* Keep the number of bytes in sync with master_state in\n-     libgfortran/intrinsics/random.c. +1 due to the integer p which is\n-     part of the state too.  */\n-  seed_size = 128 / gfc_default_integer_kind + 1;\n+     libgfortran/intrinsics/random.c.  */\n+  seed_size = 32 / gfc_default_integer_kind;\n \n   if (size != NULL)\n     {"}, {"sha": "3aa068dba9dbc171579251901c0fc8696cfe10ab", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e99e0933984e0c30fda1d089bfbd6857fc9273f/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e99e0933984e0c30fda1d089bfbd6857fc9273f/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=0e99e0933984e0c30fda1d089bfbd6857fc9273f", "patch": "@@ -11792,10 +11792,10 @@ end program test_random_seed\n Returns a single pseudorandom number or an array of pseudorandom numbers\n from the uniform distribution over the range @math{ 0 \\leq x < 1}.\n \n-The runtime-library implements the xorshift1024* random number\n-generator (RNG). This generator has a period of @math{2^{1024} - 1},\n-and when using multiple threads up to @math{2^{512}} threads can each\n-generate @math{2^{512}} random numbers before any aliasing occurs.\n+The runtime-library implements the xoshiro256** pseudorandom number\n+generator (PRNG). This generator has a period of @math{2^{256} - 1},\n+and when using multiple threads up to @math{2^{128}} threads can each\n+generate @math{2^{128}} random numbers before any aliasing occurs.\n \n Note that in a multi-threaded program (e.g. using OpenMP directives),\n each thread will have its own random number state. For details of the\n@@ -11852,7 +11852,7 @@ called either without arguments or with the @var{PUT} argument, the\n given seed is copied into a master seed as well as the seed of the\n current thread. When a new thread uses @code{RANDOM_NUMBER} for the\n first time, the seed is copied from the master seed, and forwarded\n-@math{N * 2^{512}} steps to guarantee that the random stream does not\n+@math{N * 2^{128}} steps to guarantee that the random stream does not\n alias any other stream in the system, where @var{N} is the number of\n threads that have used @code{RANDOM_NUMBER} so far during the program\n execution."}, {"sha": "9326a92d8a3417d36a1e3f83b1e4bea2c07cb886", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e99e0933984e0c30fda1d089bfbd6857fc9273f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e99e0933984e0c30fda1d089bfbd6857fc9273f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0e99e0933984e0c30fda1d089bfbd6857fc9273f", "patch": "@@ -1,3 +1,8 @@\n+2019-08-13  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+        PR fortran/91414\n+        * gfortran.dg/random_seed_1.f90: Update to match new seed size.\n+\n 2019-08-13  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/discr56.adb, gnat.dg/discr56.ads,"}, {"sha": "a97e53059f81fa0a8130e4a4a24fc1ef01867f58", "filename": "gcc/testsuite/gfortran.dg/random_seed_1.f90", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e99e0933984e0c30fda1d089bfbd6857fc9273f/gcc%2Ftestsuite%2Fgfortran.dg%2Frandom_seed_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e99e0933984e0c30fda1d089bfbd6857fc9273f/gcc%2Ftestsuite%2Fgfortran.dg%2Frandom_seed_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frandom_seed_1.f90?ref=0e99e0933984e0c30fda1d089bfbd6857fc9273f", "patch": "@@ -10,11 +10,12 @@\n PROGRAM random_seed_1\n   IMPLICIT NONE\n \n-  INTEGER, PARAMETER :: nbytes = 128\n+  ! Should match sizeof(master_state) in\n+  ! libgfortran/intrinsics/random.c\n+  INTEGER, PARAMETER :: nbytes = 32\n \n-  ! +1 due to the special 'p' value in xorshift1024*\n   ! '+1' to avoid out-of-bounds warnings\n-  INTEGER, PARAMETER    :: n = nbytes / KIND(n) + 2\n+  INTEGER, PARAMETER    :: n = nbytes / KIND(n) + 1\n   INTEGER, DIMENSION(n) :: seed\n \n   ! Get seed, array too small"}, {"sha": "7a11ca29fd3ff927e107d4f269afa9748f1f865a", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e99e0933984e0c30fda1d089bfbd6857fc9273f/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e99e0933984e0c30fda1d089bfbd6857fc9273f/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=0e99e0933984e0c30fda1d089bfbd6857fc9273f", "patch": "@@ -1,3 +1,31 @@\n+2019-08-13  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+        PR fortran/91414\n+        * intrinsics/random.c (prng_state): Update state struct.\n+        (master_state): Update to match new size.\n+        (get_rand_state): Update to match new PRNG.\n+        (rotl): New function.\n+        (xorshift1024star): Replace with prng_next.\n+        (prng_next): New function.\n+        (jump): Update for new PRNG.\n+        (lcg_parkmiller): Replace with splitmix64.\n+        (splitmix64): New function.\n+        (getosrandom): Fix return value, simplify.\n+        (init_rand_state): Use getosrandom only to get 8 bytes, splitmix64\n+        to fill rest of state.\n+        (random_r4): Update to new function and struct names.\n+        (random_r8): Likewise.\n+        (random_r10): Likewise.\n+        (random_r16): Likewise.\n+        (arandom_r4): Liekwise.\n+        (arandom_r8): Likewise.\n+        (arandom_r10): Likwewise.\n+        (arandom_r16): Likewise.\n+        (xor_keys): Reduce size to match new PRNG.\n+        (random_seed_i4): Update to new function and struct names, remove\n+        special handling of variable p used in previous PRNG.\n+        (random_seed_i8): Likewise.\n+\n 2019-08-07  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \tPR fortran/53796"}, {"sha": "cad21fedb5770371de42def84c2bf5ebc5f4c388", "filename": "libgfortran/intrinsics/random.c", "status": "modified", "additions": 99, "deletions": 114, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e99e0933984e0c30fda1d089bfbd6857fc9273f/libgfortran%2Fintrinsics%2Frandom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e99e0933984e0c30fda1d089bfbd6857fc9273f/libgfortran%2Fintrinsics%2Frandom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Frandom.c?ref=0e99e0933984e0c30fda1d089bfbd6857fc9273f", "patch": "@@ -164,23 +164,23 @@ rnumber_16 (GFC_REAL_16 *f, GFC_UINTEGER_8 v1, GFC_UINTEGER_8 v2)\n \n /*\n \n-   We use the xorshift1024* generator, a fast high-quality generator\n+   We use the xoshiro256** generator, a fast high-quality generator\n    that:\n \n    - passes TestU1 without any failures\n \n    - provides a \"jump\" function making it easy to provide many\n      independent parallel streams.\n \n-   - Long period of 2**1024 - 1\n+   - Long period of 2**256 - 1\n \n    A description can be found at\n \n-   http://vigna.di.unimi.it/ftp/papers/xorshift.pdf\n+   http://prng.di.unimi.it/\n \n    or\n \n-   http://arxiv.org/abs/1402.6246\n+   https://arxiv.org/abs/1805.01407\n \n    The paper includes public domain source code which is the basis for\n    the implementation below.\n@@ -189,10 +189,9 @@ rnumber_16 (GFC_REAL_16 *f, GFC_UINTEGER_8 v1, GFC_UINTEGER_8 v2)\n typedef struct\n {\n   bool init;\n-  int p;\n-  uint64_t s[16];\n+  uint64_t s[4];\n }\n-xorshift1024star_state;\n+prng_state;\n \n \n /* master_init, njumps, and master_state are the only variables\n@@ -201,28 +200,24 @@ static bool master_init;\n static unsigned njumps; /* How many times we have jumped.  */\n static uint64_t master_state[] = {\n   0xad63fa1ed3b55f36ULL, 0xd94473e78978b497ULL, 0xbc60592a98172477ULL,\n-  0xa3de7c6e81265301ULL, 0x586640c5e785af27ULL, 0x7a2a3f63b67ce5eaULL,\n-  0x9fde969f922d9b82ULL, 0xe6fe34379b3f3822ULL, 0x6c277eac3e99b6c2ULL,\n-  0x9197290ab0d3f069ULL, 0xdb227302f6c25576ULL, 0xee0209aee527fae9ULL,\n-  0x675666a793cd05b9ULL, 0xd048c99fbc70c20fULL, 0x775f8c3dba385ef5ULL,\n-  0x625288bc262faf33ULL\n+  0xa3de7c6e81265301ULL\n };\n \n \n static __gthread_key_t rand_state_key;\n \n-static xorshift1024star_state*\n+static prng_state*\n get_rand_state (void)\n {\n   /* For single threaded apps.  */\n-  static xorshift1024star_state rand_state;\n+  static prng_state rand_state;\n \n   if (__gthread_active_p ())\n     {\n       void* p = __gthread_getspecific (rand_state_key);\n       if (!p)\n \t{\n-\t  p = xcalloc (1, sizeof (xorshift1024star_state));\n+\t  p = xcalloc (1, sizeof (prng_state));\n \t  __gthread_setspecific (rand_state_key, p);\n \t}\n       return p;\n@@ -231,76 +226,79 @@ get_rand_state (void)\n     return &rand_state;\n }\n \n+static inline uint64_t\n+rotl (const uint64_t x, int k)\n+{\n+\treturn (x << k) | (x >> (64 - k));\n+}\n+\n \n static uint64_t\n-xorshift1024star (xorshift1024star_state* rs)\n+prng_next (prng_state* rs)\n {\n-  int p = rs->p;\n-  const uint64_t s0 = rs->s[p];\n-  uint64_t s1 = rs->s[p = (p + 1) & 15];\n-  s1 ^= s1 << 31;\n-  rs->s[p] = s1 ^ s0 ^ (s1 >> 11) ^ (s0 >> 30);\n-  rs->p = p;\n-  return rs->s[p] * UINT64_C(1181783497276652981);\n+  const uint64_t result = rotl(rs->s[1] * 5, 7) * 9;\n+\n+  const uint64_t t = rs->s[1] << 17;\n+\n+  rs->s[2] ^= rs->s[0];\n+  rs->s[3] ^= rs->s[1];\n+  rs->s[1] ^= rs->s[2];\n+  rs->s[0] ^= rs->s[3];\n+\n+  rs->s[2] ^= t;\n+\n+  rs->s[3] = rotl(rs->s[3], 45);\n+\n+  return result;\n }\n \n \n /* This is the jump function for the generator. It is equivalent to\n-   2^512 calls to xorshift1024star(); it can be used to generate 2^512\n+   2^128 calls to prng_next(); it can be used to generate 2^128\n    non-overlapping subsequences for parallel computations. */\n \n static void\n-jump (xorshift1024star_state* rs)\n+jump (prng_state* rs)\n {\n-  static const uint64_t JUMP[] = {\n-    0x84242f96eca9c41dULL, 0xa3c65b8776f96855ULL, 0x5b34a39f070b5837ULL,\n-    0x4489affce4f31a1eULL, 0x2ffeeb0a48316f40ULL, 0xdc2d9891fe68c022ULL,\n-    0x3659132bb12fea70ULL, 0xaac17d8efa43cab8ULL, 0xc4cb815590989b13ULL,\n-    0x5ee975283d71c93bULL, 0x691548c86c1bd540ULL, 0x7910c41d10a1e6a5ULL,\n-    0x0b5fc64563b3e2a8ULL, 0x047f7684e9fc949dULL, 0xb99181f2d8f685caULL,\n-    0x284600e3f30e38c3ULL\n-  };\n-\n-  uint64_t t[16] = { 0 };\n+  static const uint64_t JUMP[] = { 0x180ec6d33cfd0aba, 0xd5a61266f0c9392c, 0xa9582618e03fc9aa, 0x39abdc4529b1661c };\n+\n+  uint64_t s0 = 0;\n+  uint64_t s1 = 0;\n+  uint64_t s2 = 0;\n+  uint64_t s3 = 0;\n   for(size_t i = 0; i < sizeof JUMP / sizeof *JUMP; i++)\n-    for(int b = 0; b < 64; b++)\n-      {\n-\tif (JUMP[i] & 1ULL << b)\n-\t  for(int j = 0; j < 16; j++)\n-\t    t[j] ^= rs->s[(j + rs->p) & 15];\n-\txorshift1024star (rs);\n+    for(int b = 0; b < 64; b++) {\n+      if (JUMP[i] & UINT64_C(1) << b) {\n+\ts0 ^= rs->s[0];\n+\ts1 ^= rs->s[1];\n+\ts2 ^= rs->s[2];\n+\ts3 ^= rs->s[3];\n       }\n-  for(int j = 0; j < 16; j++)\n-    rs->s[(j + rs->p) & 15] = t[j];\n-}\n+      prng_next (rs);\n+    }\n \n+  rs->s[0] = s0;\n+  rs->s[1] = s1;\n+  rs->s[2] = s2;\n+  rs->s[3] = s3;\n+}\n \n-/* Super-simple LCG generator used in getosrandom () if /dev/urandom\n-   doesn't exist.  */\n \n-#define M 2147483647 /* 2^31 - 1 (A large prime number) */\n-#define A 16807      /* Prime root of M, passes statistical tests and produces a full cycle */\n-#define Q 127773 /* M / A (To avoid overflow on A * seed) */\n-#define R 2836   /* M % A (To avoid overflow on A * seed) */\n+/* Splitmix64 recommended by xoshiro author for initializing.  After\n+   getting one uint64_t value from the OS, this is used to fill in the\n+   rest of the xoshiro state.  */\n \n-__attribute__((unused)) static uint32_t\n-lcg_parkmiller(uint32_t seed)\n+static uint64_t\n+splitmix64 (uint64_t x)\n {\n-    uint32_t hi = seed / Q;\n-    uint32_t lo = seed % Q;\n-    int32_t test = A * lo - R * hi;\n-    if (test <= 0)\n-        test += M;\n-    return test;\n+  uint64_t z = (x += 0x9e3779b97f4a7c15);\n+  z = (z ^ (z >> 30)) * 0xbf58476d1ce4e5b9;\n+  z = (z ^ (z >> 27)) * 0x94d049bb133111eb;\n+  return z ^ (z >> 31);\n }\n \n-#undef M\n-#undef A\n-#undef Q\n-#undef R\n \n-\n-/* Get some random bytes from the operating system in order to seed\n+/* Get some bytes from the operating system in order to seed\n    the PRNG.  */\n \n static int\n@@ -315,7 +313,7 @@ getosrandom (void *buf, size_t buflen)\n #else\n #ifdef HAVE_GETENTROPY\n   if (getentropy (buf, buflen) == 0)\n-    return 0;\n+    return buflen;\n #endif\n   int flags = O_RDONLY;\n #ifdef O_CLOEXEC\n@@ -328,7 +326,7 @@ getosrandom (void *buf, size_t buflen)\n       close (fd);\n       return res;\n     }\n-  uint32_t seed = 1234567890;\n+  uint64_t seed = 0x047f7684e9fc949dULL;\n   time_t secs;\n   long usecs;\n   if (gf_gettime (&secs, &usecs) == 0)\n@@ -340,13 +338,9 @@ getosrandom (void *buf, size_t buflen)\n   pid_t pid = getpid();\n   seed ^= pid;\n #endif\n-  uint32_t* ub = buf;\n-  for (size_t i = 0; i < buflen / sizeof (uint32_t); i++)\n-    {\n-      ub[i] = seed;\n-      seed = lcg_parkmiller (seed);\n-    }\n-  return buflen;\n+  size_t size = buflen < sizeof (uint64_t) ? buflen : sizeof (uint64_t);\n+  memcpy (buf, &seed, size);\n+  return size;\n #endif /* __MINGW64_VERSION_MAJOR  */\n }\n \n@@ -355,13 +349,16 @@ getosrandom (void *buf, size_t buflen)\n    using the master state and the number of times we must jump.  */\n \n static void\n-init_rand_state (xorshift1024star_state* rs, const bool locked)\n+init_rand_state (prng_state* rs, const bool locked)\n {\n   if (!locked)\n     __gthread_mutex_lock (&random_lock);\n   if (!master_init)\n     {\n-      getosrandom (master_state, sizeof (master_state));\n+      uint64_t os_seed;\n+      getosrandom (&os_seed, sizeof (os_seed));\n+      for (uint64_t i = 0; i < sizeof (master_state) / sizeof (uint64_t); i++)\n+\tmaster_state[i] = splitmix64 (os_seed);\n       njumps = 0;\n       master_init = true;\n     }\n@@ -381,11 +378,11 @@ init_rand_state (xorshift1024star_state* rs, const bool locked)\n void\n random_r4 (GFC_REAL_4 *x)\n {\n-  xorshift1024star_state* rs = get_rand_state();\n+  prng_state* rs = get_rand_state();\n \n   if (unlikely (!rs->init))\n     init_rand_state (rs, false);\n-  uint64_t r = xorshift1024star (rs);\n+  uint64_t r = prng_next (rs);\n   /* Take the higher bits, ensuring that a stream of real(4), real(8),\n      and real(10) will be identical (except for precision).  */\n   uint32_t high = (uint32_t) (r >> 32);\n@@ -400,11 +397,11 @@ void\n random_r8 (GFC_REAL_8 *x)\n {\n   GFC_UINTEGER_8 r;\n-  xorshift1024star_state* rs = get_rand_state();\n+  prng_state* rs = get_rand_state();\n \n   if (unlikely (!rs->init))\n     init_rand_state (rs, false);\n-  r = xorshift1024star (rs);\n+  r = prng_next (rs);\n   rnumber_8 (x, r);\n }\n iexport(random_r8);\n@@ -418,11 +415,11 @@ void\n random_r10 (GFC_REAL_10 *x)\n {\n   GFC_UINTEGER_8 r;\n-  xorshift1024star_state* rs = get_rand_state();\n+  prng_state* rs = get_rand_state();\n \n   if (unlikely (!rs->init))\n     init_rand_state (rs, false);\n-  r = xorshift1024star (rs);\n+  r = prng_next (rs);\n   rnumber_10 (x, r);\n }\n iexport(random_r10);\n@@ -438,12 +435,12 @@ void\n random_r16 (GFC_REAL_16 *x)\n {\n   GFC_UINTEGER_8 r1, r2;\n-  xorshift1024star_state* rs = get_rand_state();\n+  prng_state* rs = get_rand_state();\n \n   if (unlikely (!rs->init))\n     init_rand_state (rs, false);\n-  r1 = xorshift1024star (rs);\n-  r2 = xorshift1024star (rs);\n+  r1 = prng_next (rs);\n+  r2 = prng_next (rs);\n   rnumber_16 (x, r1, r2);\n }\n iexport(random_r16);\n@@ -463,7 +460,7 @@ arandom_r4 (gfc_array_r4 *x)\n   index_type stride0;\n   index_type dim;\n   GFC_REAL_4 *dest;\n-  xorshift1024star_state* rs = get_rand_state();\n+  prng_state* rs = get_rand_state();\n \n   dest = x->base_addr;\n \n@@ -486,7 +483,7 @@ arandom_r4 (gfc_array_r4 *x)\n   while (dest)\n     {\n       /* random_r4 (dest);  */\n-      uint64_t r = xorshift1024star (rs);\n+      uint64_t r = prng_next (rs);\n       uint32_t high = (uint32_t) (r >> 32);\n       rnumber_4 (dest, high);\n \n@@ -530,7 +527,7 @@ arandom_r8 (gfc_array_r8 *x)\n   index_type stride0;\n   index_type dim;\n   GFC_REAL_8 *dest;\n-  xorshift1024star_state* rs = get_rand_state();\n+  prng_state* rs = get_rand_state();\n \n   dest = x->base_addr;\n \n@@ -553,7 +550,7 @@ arandom_r8 (gfc_array_r8 *x)\n   while (dest)\n     {\n       /* random_r8 (dest);  */\n-      uint64_t r = xorshift1024star (rs);\n+      uint64_t r = prng_next (rs);\n       rnumber_8 (dest, r);\n \n       /* Advance to the next element.  */\n@@ -598,7 +595,7 @@ arandom_r10 (gfc_array_r10 *x)\n   index_type stride0;\n   index_type dim;\n   GFC_REAL_10 *dest;\n-  xorshift1024star_state* rs = get_rand_state();\n+  prng_state* rs = get_rand_state();\n \n   dest = x->base_addr;\n \n@@ -621,7 +618,7 @@ arandom_r10 (gfc_array_r10 *x)\n   while (dest)\n     {\n       /* random_r10 (dest);  */\n-      uint64_t r = xorshift1024star (rs);\n+      uint64_t r = prng_next (rs);\n       rnumber_10 (dest, r);\n \n       /* Advance to the next element.  */\n@@ -668,7 +665,7 @@ arandom_r16 (gfc_array_r16 *x)\n   index_type stride0;\n   index_type dim;\n   GFC_REAL_16 *dest;\n-  xorshift1024star_state* rs = get_rand_state();\n+  prng_state* rs = get_rand_state();\n \n   dest = x->base_addr;\n \n@@ -691,8 +688,8 @@ arandom_r16 (gfc_array_r16 *x)\n   while (dest)\n     {\n       /* random_r16 (dest);  */\n-      uint64_t r1 = xorshift1024star (rs);\n-      uint64_t r2 = xorshift1024star (rs);\n+      uint64_t r1 = prng_next (rs);\n+      uint64_t r2 = prng_next (rs);\n       rnumber_16 (dest, r1, r2);\n \n       /* Advance to the next element.  */\n@@ -734,11 +731,7 @@ arandom_r16 (gfc_array_r16 *x)\n \n static const uint64_t xor_keys[] = {\n   0xbd0c5b6e50c2df49ULL, 0xd46061cd46e1df38ULL, 0xbb4f4d4ed6103544ULL,\n-  0x114a583d0756ad39ULL, 0x4b5ad8623d0aaab6ULL, 0x3f2ed7afbe0c0f21ULL,\n-  0xdec83fd65f113445ULL, 0x3824f8fbc4f10d24ULL, 0x5d9025af05878911ULL,\n-  0x500bc46b540340e9ULL, 0x8bd53298e0d00530ULL, 0x57886e40a952e06aULL,\n-  0x926e76c88e31cdb6ULL, 0xbd0724dac0a3a5f9ULL, 0xc5c8981b858ab796ULL,\n-  0xbb12ab2694c2b32cULL\n+  0x114a583d0756ad39ULL\n };\n \n \n@@ -768,9 +761,9 @@ random_seed_i4 (GFC_INTEGER_4 *size, gfc_array_i4 *put, gfc_array_i4 *get)\n     runtime_error (\"RANDOM_SEED should have at most one argument present.\");\n \n   if (size != NULL)\n-    *size = SZ + 1;\n+    *size = SZ;\n \n-  xorshift1024star_state* rs = get_rand_state();\n+  prng_state* rs = get_rand_state();\n \n   /* Return the seed to GET data.  */\n   if (get != NULL)\n@@ -780,7 +773,7 @@ random_seed_i4 (GFC_INTEGER_4 *size, gfc_array_i4 *put, gfc_array_i4 *get)\n \truntime_error (\"Array rank of GET is not 1.\");\n \n       /* If the array is too small, abort.  */\n-      if (GFC_DESCRIPTOR_EXTENT(get,0) < (index_type) SZ + 1)\n+      if (GFC_DESCRIPTOR_EXTENT(get,0) < (index_type) SZ)\n \truntime_error (\"Array size of GET is too small.\");\n \n       if (!rs->init)\n@@ -794,9 +787,6 @@ random_seed_i4 (GFC_INTEGER_4 *size, gfc_array_i4 *put, gfc_array_i4 *get)\n \tmemcpy (&(get->base_addr[(SZ - 1 - i) * GFC_DESCRIPTOR_STRIDE(get,0)]),\n \t\t(unsigned char*) seed + i * sizeof(GFC_UINTEGER_4),\n                sizeof(GFC_UINTEGER_4));\n-\n-      /* Finally copy the value of p after the seed.  */\n-      get->base_addr[SZ * GFC_DESCRIPTOR_STRIDE(get, 0)] = rs->p;\n     }\n \n   else\n@@ -818,7 +808,7 @@ random_seed_i4 (GFC_INTEGER_4 *size, gfc_array_i4 *put, gfc_array_i4 *get)\n         runtime_error (\"Array rank of PUT is not 1.\");\n \n       /* If the array is too small, abort.  */\n-      if (GFC_DESCRIPTOR_EXTENT(put,0) < (index_type) SZ + 1)\n+      if (GFC_DESCRIPTOR_EXTENT(put,0) < (index_type) SZ)\n         runtime_error (\"Array size of PUT is too small.\");\n \n       /*  We copy the seed given by the user.  */\n@@ -833,8 +823,6 @@ random_seed_i4 (GFC_INTEGER_4 *size, gfc_array_i4 *put, gfc_array_i4 *get)\n       njumps = 0;\n       master_init = true;\n       init_rand_state (rs, true);\n-\n-      rs->p = put->base_addr[SZ * GFC_DESCRIPTOR_STRIDE(put, 0)] & 15;\n     }\n \n   __gthread_mutex_unlock (&random_lock);\n@@ -855,9 +843,9 @@ random_seed_i8 (GFC_INTEGER_8 *size, gfc_array_i8 *put, gfc_array_i8 *get)\n \n #define SZ (sizeof (master_state) / sizeof (GFC_INTEGER_8))\n   if (size != NULL)\n-    *size = SZ + 1;\n+    *size = SZ;\n \n-  xorshift1024star_state* rs = get_rand_state();\n+  prng_state* rs = get_rand_state();\n \n   /* Return the seed to GET data.  */\n   if (get != NULL)\n@@ -867,7 +855,7 @@ random_seed_i8 (GFC_INTEGER_8 *size, gfc_array_i8 *put, gfc_array_i8 *get)\n \truntime_error (\"Array rank of GET is not 1.\");\n \n       /* If the array is too small, abort.  */\n-      if (GFC_DESCRIPTOR_EXTENT(get,0) < (index_type) SZ + 1)\n+      if (GFC_DESCRIPTOR_EXTENT(get,0) < (index_type) SZ)\n \truntime_error (\"Array size of GET is too small.\");\n \n       if (!rs->init)\n@@ -880,8 +868,6 @@ random_seed_i8 (GFC_INTEGER_8 *size, gfc_array_i8 *put, gfc_array_i8 *get)\n       for (size_t i = 0; i < SZ; i++)\n \tmemcpy (&(get->base_addr[i * GFC_DESCRIPTOR_STRIDE(get,0)]), &seed[i],\n \t\tsizeof (GFC_UINTEGER_8));\n-\n-      get->base_addr[SZ * GFC_DESCRIPTOR_STRIDE(get, 0)] = rs->p;\n     }\n \n   else\n@@ -903,7 +889,7 @@ random_seed_i8 (GFC_INTEGER_8 *size, gfc_array_i8 *put, gfc_array_i8 *get)\n         runtime_error (\"Array rank of PUT is not 1.\");\n \n       /* If the array is too small, abort.  */\n-      if (GFC_DESCRIPTOR_EXTENT(put,0) < (index_type) SZ + 1)\n+      if (GFC_DESCRIPTOR_EXTENT(put,0) < (index_type) SZ)\n         runtime_error (\"Array size of PUT is too small.\");\n \n       /*  This code now should do correct strides.  */\n@@ -915,7 +901,6 @@ random_seed_i8 (GFC_INTEGER_8 *size, gfc_array_i8 *put, gfc_array_i8 *get)\n       njumps = 0;\n       master_init = true;\n       init_rand_state (rs, true);\n-      rs->p = put->base_addr[SZ * GFC_DESCRIPTOR_STRIDE(put, 0)] & 15;\n      }\n \n "}]}