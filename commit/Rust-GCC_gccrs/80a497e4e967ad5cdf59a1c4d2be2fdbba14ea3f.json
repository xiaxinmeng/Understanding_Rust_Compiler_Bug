{"sha": "80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODBhNDk3ZTRlOTY3YWQ1Y2RmNTlhMWM0ZDJiZTJmZGJiYTE0ZWEzZg==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm28@cam.ac.uk", "date": "2001-10-02T07:19:47Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2001-10-02T07:19:47Z"}, "message": "c-common.c (c_format_attribute_table): Make format and format_arg attributes apply to function types rather than to decls.\n\n\t* c-common.c (c_format_attribute_table): Make format and\n\tformat_arg attributes apply to function types rather than to\n\tdecls.\n\t(is_valid_printf_arglist): Construct an attribute list and pass\n\tthat to check_function_format rather than a name.\n\t* c-common.h (check_function_format): Adjust prototype.\n\t* c-decl.c (duplicate_decls): Preserve attributes from type of\n\tbuilt-in decl when allowing for harmless conflict in types.\n\t* c-format.c (record_function_format,\n\trecord_international_format, function_format_list,\n\tinternational_format_info, international_format_list): Remove.\n\t(function_format_info): Remove next, name and assembler_name.\n\tMake format_num and first_arg_num be unsigned HOST_WIDE_INT.\n\t(decode_format_attr): New.\n\t(handle_format_attribute): Handle receiving a type rather than a\n\tdecl.  Call decode_format_attr.  Store format information in a\n\tfunction_format_info.\n\t(handle_format_arg_attribute): Correct comment.  Handle receiving\n\ta type rather than a decl.  Use unsigned HOST_WIDE_INT for\n\targ_num.\n\t(check_format_info_recurse, check_format_info_main): Take argument\n\tnumbers as unsigned HOST_WIDE_INT.\n\t(check_function_format): Take a list of attributes from the\n\tfunction type rather than a name or assembler name.  Check for\n\tformat attributes in that list and the attributes on the type of\n\tthe current function rather than looking through\n\tfunction_format_list.\n\t(check_format_info): Use unsigned HOST_WIDE_INT for argument\n\tnumbers.\n\t(check_format_info_recurse): Take format_arg attributes from the\n\ttype of the function calls rather than using\n\tinternational_format_list.  Allow for multiple format_arg\n\tattributes.\n\t* c-typeck.c (build_function_call): Pass type attributes to\n\tcheck_function_format rather than name or assembler name.  Don't\n\trequire there to be a name or assembler name to check formats.\n\ncp:\n\t* call.c (build_over_call), typeck.c (build_function_call_real):\n\tPass type attributes to check_function_format rather than name or\n\tassembler name.  Don't require there to be a name or assembler\n\tname to check formats.\n\ntestsuite:\n\t* g++.dg/warn/format2.C, gcc.dg/format/attr-7.c,\n\tgcc.dg/format/multattr-1.c, gcc.dg/format/multattr-2.c,\n\tgcc.dg/format/multattr-3.c: New tests.\n\t* gcc.dg/format/attr-3.c: Update expected error texts.  Remove\n\ttests for format attributes on function pointers being rejected.\n\nFrom-SVN: r45945", "tree": {"sha": "08f1b7a84cfb385dccaaf67b7162f37545d3fd09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/08f1b7a84cfb385dccaaf67b7162f37545d3fd09"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3b5d92c88835a1a64eae771baf053ff4c98dec7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3b5d92c88835a1a64eae771baf053ff4c98dec7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3b5d92c88835a1a64eae771baf053ff4c98dec7"}], "stats": {"total": 656, "additions": 411, "deletions": 245}, "files": [{"sha": "72e101e6d4fb032772e13397040884f526cc94b3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f", "patch": "@@ -1,3 +1,42 @@\n+2001-10-02  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* c-common.c (c_format_attribute_table): Make format and\n+\tformat_arg attributes apply to function types rather than to\n+\tdecls.\n+\t(is_valid_printf_arglist): Construct an attribute list and pass\n+\tthat to check_function_format rather than a name.\n+\t* c-common.h (check_function_format): Adjust prototype.\n+\t* c-decl.c (duplicate_decls): Preserve attributes from type of\n+\tbuilt-in decl when allowing for harmless conflict in types.\n+\t* c-format.c (record_function_format,\n+\trecord_international_format, function_format_list,\n+\tinternational_format_info, international_format_list): Remove.\n+\t(function_format_info): Remove next, name and assembler_name.\n+\tMake format_num and first_arg_num be unsigned HOST_WIDE_INT.\n+\t(decode_format_attr): New.\n+\t(handle_format_attribute): Handle receiving a type rather than a\n+\tdecl.  Call decode_format_attr.  Store format information in a\n+\tfunction_format_info.\n+\t(handle_format_arg_attribute): Correct comment.  Handle receiving\n+\ta type rather than a decl.  Use unsigned HOST_WIDE_INT for\n+\targ_num.\n+\t(check_format_info_recurse, check_format_info_main): Take argument\n+\tnumbers as unsigned HOST_WIDE_INT.\n+\t(check_function_format): Take a list of attributes from the\n+\tfunction type rather than a name or assembler name.  Check for\n+\tformat attributes in that list and the attributes on the type of\n+\tthe current function rather than looking through\n+\tfunction_format_list.\n+\t(check_format_info): Use unsigned HOST_WIDE_INT for argument\n+\tnumbers.\n+\t(check_format_info_recurse): Take format_arg attributes from the\n+\ttype of the function calls rather than using\n+\tinternational_format_list.  Allow for multiple format_arg\n+\tattributes.\n+\t* c-typeck.c (build_function_call): Pass type attributes to\n+\tcheck_function_format rather than name or assembler name.  Don't\n+\trequire there to be a name or assembler name to check formats.\n+\n 2001-10-02  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* attribs.c (decl_attributes): Possibly call"}, {"sha": "e6c81c385c04b46efd6445d144e237c6a734a6a4", "filename": "gcc/c-common.c", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f", "patch": "@@ -2329,9 +2329,10 @@ c_alignof_expr (expr)\n \n static const struct attribute_spec c_format_attribute_table[] =\n {\n-  { \"format\",                 3, 3, true,  false, false,\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n+  { \"format\",                 3, 3, false, true,  true,\n \t\t\t      handle_format_attribute },\n-  { \"format_arg\",             1, 1, true,  false, false,\n+  { \"format_arg\",             1, 1, false, true,  true,\n \t\t\t      handle_format_arg_attribute },\n   { NULL,                     0, 0, false, false, false, NULL }\n };\n@@ -3551,14 +3552,22 @@ is_valid_printf_arglist (arglist)\n   /* Save this value so we can restore it later.  */\n   const int SAVE_pedantic = pedantic;\n   int diagnostic_occurred = 0;\n+  tree attrs;\n \n   /* Set this to a known value so the user setting won't affect code\n      generation.  */\n   pedantic = 1;\n   /* Check to make sure there are no format specifier errors.  */\n-  check_function_format (&diagnostic_occurred,\n-\t\t\t maybe_get_identifier(\"printf\"),\n-\t\t\t NULL_TREE, arglist);\n+  attrs = tree_cons (get_identifier (\"format\"),\n+\t\t     tree_cons (NULL_TREE,\n+\t\t\t\tget_identifier (\"printf\"),\n+\t\t\t\ttree_cons (NULL_TREE,\n+\t\t\t\t\t   integer_one_node,\n+\t\t\t\t\t   tree_cons (NULL_TREE,\n+\t\t\t\t\t\t      build_int_2 (2, 0),\n+\t\t\t\t\t\t      NULL_TREE))),\n+\t\t     NULL_TREE);\n+  check_function_format (&diagnostic_occurred, attrs, arglist);\n \n   /* Restore the value of `pedantic'.  */\n   pedantic = SAVE_pedantic;"}, {"sha": "aadbee8f3c492017a51f726c0476c392be617226", "filename": "gcc/c-common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f", "patch": "@@ -503,7 +503,7 @@ extern const char *fname_as_string\t\tPARAMS ((int));\n extern tree fname_decl\t\t\t\tPARAMS ((unsigned, tree));\n extern const char *fname_string\t\t\tPARAMS ((unsigned));\n \n-extern void check_function_format\t\tPARAMS ((int *, tree, tree, tree));\n+extern void check_function_format\t\tPARAMS ((int *, tree, tree));\n extern void set_Wformat\t\t\t\tPARAMS ((int));\n extern tree handle_format_attribute\t\tPARAMS ((tree *, tree, tree,\n \t\t\t\t\t\t\t int, bool *));"}, {"sha": "ac09d264db7c1b5422b1d01c2e40274c607f13fd", "filename": "gcc/c-decl.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f", "patch": "@@ -1498,6 +1498,8 @@ duplicate_decls (newdecl, olddecl, different_binding_level)\n \t      tree trytype\n \t\t= build_function_type (newreturntype,\n \t\t\t\t       TYPE_ARG_TYPES (oldtype));\n+\t      trytype = build_type_attribute_variant (trytype,\n+\t\t\t\t\t\t      TYPE_ATTRIBUTES (oldtype));\n \n               types_match = comptypes (newtype, trytype);\n \t      if (types_match)\n@@ -1519,6 +1521,8 @@ duplicate_decls (newdecl, olddecl, different_binding_level)\n \t\t\t\t       tree_cons (NULL_TREE,\n \t\t\t\t\t\t  TREE_VALUE (TYPE_ARG_TYPES (newtype)),\n \t\t\t\t\t\t  TREE_CHAIN (TYPE_ARG_TYPES (oldtype))));\n+\t      trytype = build_type_attribute_variant (trytype,\n+\t\t\t\t\t\t      TYPE_ATTRIBUTES (oldtype));\n \n \t      types_match = comptypes (newtype, trytype);\n \t      if (types_match)"}, {"sha": "ea6ef57fa6d11b932045c31d673bf3faebe2d35a", "filename": "gcc/c-format.c", "status": "modified", "additions": 142, "deletions": 218, "changes": 360, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f/gcc%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f/gcc%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-format.c?ref=80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f", "patch": "@@ -77,10 +77,16 @@ enum format_type { printf_format_type, scanf_format_type,\n \t\t   strftime_format_type, strfmon_format_type,\n \t\t   format_type_error };\n \n+typedef struct function_format_info\n+{\n+  enum format_type format_type;\t/* type of format (printf, scanf, etc.) */\n+  unsigned HOST_WIDE_INT format_num;\t/* number of format argument */\n+  unsigned HOST_WIDE_INT first_arg_num;\t/* number of first arg (zero for varargs) */\n+} function_format_info;\n+\n+static bool decode_format_attr\t\tPARAMS ((tree,\n+\t\t\t\t\t\t function_format_info *, int));\n static enum format_type decode_format_type\tPARAMS ((const char *));\n-static void record_function_format\tPARAMS ((tree, tree, enum format_type,\n-\t\t\t\t\t\t int, int));\n-static void record_international_format\tPARAMS ((tree, tree, int));\n \n /* Handle a \"format\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n@@ -92,72 +98,13 @@ handle_format_attribute (node, name, args, flags, no_add_attrs)\n      int flags;\n      bool *no_add_attrs;\n {\n-  tree decl = *node;\n-  tree type = TREE_TYPE (decl);\n-  tree format_type_id = TREE_VALUE (args);\n-  tree format_num_expr = TREE_VALUE (TREE_CHAIN (args));\n-  tree first_arg_num_expr\n-    = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (args)));\n-  unsigned HOST_WIDE_INT format_num, first_arg_num;\n-  enum format_type format_type;\n+  tree type = *node;\n+  function_format_info info;\n   tree argument;\n-  unsigned int arg_num;\n+  unsigned HOST_WIDE_INT arg_num;\n \n-  if (TREE_CODE (decl) != FUNCTION_DECL)\n+  if (!decode_format_attr (args, &info, 0))\n     {\n-      error_with_decl (decl,\n-\t\t       \"argument format specified for non-function `%s'\");\n-      *no_add_attrs = true;\n-      return NULL_TREE;\n-    }\n-\n-  if (TREE_CODE (format_type_id) != IDENTIFIER_NODE)\n-    {\n-      error (\"unrecognized format specifier\");\n-      *no_add_attrs = true;\n-      return NULL_TREE;\n-    }\n-  else\n-    {\n-      const char *p = IDENTIFIER_POINTER (format_type_id);\n-\n-      format_type = decode_format_type (p);\n-\n-      if (format_type == format_type_error)\n-\t{\n-\t  warning (\"`%s' is an unrecognized format function type\", p);\n-\t  *no_add_attrs = true;\n-\t  return NULL_TREE;\n-\t}\n-    }\n-\n-  /* Strip any conversions from the string index and first arg number\n-     and verify they are constants.  */\n-  while (TREE_CODE (format_num_expr) == NOP_EXPR\n-\t || TREE_CODE (format_num_expr) == CONVERT_EXPR\n-\t || TREE_CODE (format_num_expr) == NON_LVALUE_EXPR)\n-    format_num_expr = TREE_OPERAND (format_num_expr, 0);\n-\n-  while (TREE_CODE (first_arg_num_expr) == NOP_EXPR\n-\t || TREE_CODE (first_arg_num_expr) == CONVERT_EXPR\n-\t || TREE_CODE (first_arg_num_expr) == NON_LVALUE_EXPR)\n-    first_arg_num_expr = TREE_OPERAND (first_arg_num_expr, 0);\n-\n-  if (TREE_CODE (format_num_expr) != INTEGER_CST\n-      || TREE_INT_CST_HIGH (format_num_expr) != 0\n-      || TREE_CODE (first_arg_num_expr) != INTEGER_CST\n-      || TREE_INT_CST_HIGH (first_arg_num_expr) != 0)\n-    {\n-      error (\"format string has invalid operand number\");\n-      *no_add_attrs = true;\n-      return NULL_TREE;\n-    }\n-\n-  format_num = TREE_INT_CST_LOW (format_num_expr);\n-  first_arg_num = TREE_INT_CST_LOW (first_arg_num_expr);\n-  if (first_arg_num != 0 && first_arg_num <= format_num)\n-    {\n-      error (\"format string arg follows the args to be formatted\");\n       *no_add_attrs = true;\n       return NULL_TREE;\n     }\n@@ -168,7 +115,7 @@ handle_format_attribute (node, name, args, flags, no_add_attrs)\n   argument = TYPE_ARG_TYPES (type);\n   if (argument)\n     {\n-      for (arg_num = 1; argument != 0 && arg_num != format_num;\n+      for (arg_num = 1; argument != 0 && arg_num != info.format_num;\n \t   ++arg_num, argument = TREE_CHAIN (argument))\n \t;\n \n@@ -183,14 +130,14 @@ handle_format_attribute (node, name, args, flags, no_add_attrs)\n \t  return NULL_TREE;\n \t}\n \n-      else if (first_arg_num != 0)\n+      else if (info.first_arg_num != 0)\n \t{\n \t  /* Verify that first_arg_num points to the last arg,\n \t     the ...  */\n \t  while (argument)\n \t    arg_num++, argument = TREE_CHAIN (argument);\n \n-\t  if (arg_num != first_arg_num)\n+\t  if (arg_num != info.first_arg_num)\n \t    {\n \t      if (!(flags & (int) ATTR_FLAG_BUILT_IN))\n \t\terror (\"args to be formatted is not '...'\");\n@@ -200,20 +147,18 @@ handle_format_attribute (node, name, args, flags, no_add_attrs)\n \t}\n     }\n \n-  if (format_type == strftime_format_type && first_arg_num != 0)\n+  if (info.format_type == strftime_format_type && info.first_arg_num != 0)\n     {\n       error (\"strftime formats cannot format arguments\");\n       *no_add_attrs = true;\n       return NULL_TREE;\n     }\n \n-  record_function_format (DECL_NAME (decl), DECL_ASSEMBLER_NAME (decl),\n-\t\t\t  format_type, format_num, first_arg_num);\n   return NULL_TREE;\n }\n \n \n-/* Handle a \"format\" attribute; arguments as in\n+/* Handle a \"format_arg\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n tree\n handle_format_arg_attribute (node, name, args, flags, no_add_attrs)\n@@ -223,21 +168,12 @@ handle_format_arg_attribute (node, name, args, flags, no_add_attrs)\n      int flags;\n      bool *no_add_attrs;\n {\n-  tree decl = *node;\n-  tree type = TREE_TYPE (decl);\n+  tree type = *node;\n   tree format_num_expr = TREE_VALUE (args);\n   unsigned HOST_WIDE_INT format_num;\n-  unsigned int arg_num;\n+  unsigned HOST_WIDE_INT arg_num;\n   tree argument;\n \n-  if (TREE_CODE (decl) != FUNCTION_DECL)\n-    {\n-      error_with_decl (decl,\n-\t\t       \"argument format specified for non-function `%s'\");\n-      *no_add_attrs = true;\n-      return NULL_TREE;\n-    }\n-\n   /* Strip any conversions from the first arg number and verify it\n      is a constant.  */\n   while (TREE_CODE (format_num_expr) == NOP_EXPR\n@@ -277,8 +213,8 @@ handle_format_arg_attribute (node, name, args, flags, no_add_attrs)\n \t}\n     }\n \n-  if (TREE_CODE (TREE_TYPE (TREE_TYPE (decl))) != POINTER_TYPE\n-      || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (TREE_TYPE (decl))))\n+  if (TREE_CODE (TREE_TYPE (type)) != POINTER_TYPE\n+      || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (type)))\n \t  != char_type_node))\n     {\n       if (!(flags & (int) ATTR_FLAG_BUILT_IN))\n@@ -287,114 +223,85 @@ handle_format_arg_attribute (node, name, args, flags, no_add_attrs)\n       return NULL_TREE;\n     }\n \n-  record_international_format (DECL_NAME (decl), DECL_ASSEMBLER_NAME (decl),\n-\t\t\t       format_num);\n   return NULL_TREE;\n }\n \n-typedef struct function_format_info\n-{\n-  struct function_format_info *next;  /* next structure on the list */\n-  tree name;\t\t\t/* identifier such as \"printf\" */\n-  tree assembler_name;\t\t/* optional mangled identifier (for C++) */\n-  enum format_type format_type;\t/* type of format (printf, scanf, etc.) */\n-  int format_num;\t\t/* number of format argument */\n-  int first_arg_num;\t\t/* number of first arg (zero for varargs) */\n-} function_format_info;\n-\n-static function_format_info *function_format_list = NULL;\n \n-typedef struct international_format_info\n-{\n-  struct international_format_info *next;  /* next structure on the list */\n-  tree name;\t\t\t/* identifier such as \"gettext\" */\n-  tree assembler_name;\t\t/* optional mangled identifier (for C++) */\n-  int format_num;\t\t/* number of format argument */\n-} international_format_info;\n-\n-static international_format_info *international_format_list = NULL;\n-\n-/* Record information for argument format checking.  FUNCTION_IDENT is\n-   the identifier node for the name of the function to check (its decl\n-   need not exist yet).\n-   FORMAT_TYPE specifies the type of format checking.  FORMAT_NUM is the number\n-   of the argument which is the format control string (starting from 1).\n-   FIRST_ARG_NUM is the number of the first actual argument to check\n-   against the format string, or zero if no checking is not be done\n-   (e.g. for varargs such as vfprintf).  */\n+/* Decode the arguments to a \"format\" attribute into a function_format_info\n+   structure.  It is already known that the list is of the right length.\n+   If VALIDATED_P is true, then these attributes have already been validated\n+   and this function will abort if they are erroneous; if false, it\n+   will give an error message.  Returns true if the attributes are\n+   successfully decoded, false otherwise.  */\n \n-static void\n-record_function_format (name, assembler_name, format_type,\n-\t\t\tformat_num, first_arg_num)\n-      tree name;\n-      tree assembler_name;\n-      enum format_type format_type;\n-      int format_num;\n-      int first_arg_num;\n+static bool\n+decode_format_attr (args, info, validated_p)\n+     tree args;\n+     function_format_info *info;\n+     int validated_p;\n {\n-  function_format_info *info;\n-\n-  /* Re-use existing structure if it's there.  */\n+  tree format_type_id = TREE_VALUE (args);\n+  tree format_num_expr = TREE_VALUE (TREE_CHAIN (args));\n+  tree first_arg_num_expr\n+    = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (args)));\n \n-  for (info = function_format_list; info; info = info->next)\n+  if (TREE_CODE (format_type_id) != IDENTIFIER_NODE)\n     {\n-      if (info->name == name && info->assembler_name == assembler_name)\n-\tbreak;\n+      if (validated_p)\n+\tabort ();\n+      error (\"unrecognized format specifier\");\n+      return false;\n     }\n-  if (! info)\n+  else\n     {\n-      info = (function_format_info *) xmalloc (sizeof (function_format_info));\n-      info->next = function_format_list;\n-      function_format_list = info;\n+      const char *p = IDENTIFIER_POINTER (format_type_id);\n \n-      info->name = name;\n-      info->assembler_name = assembler_name;\n-    }\n+      info->format_type = decode_format_type (p);\n \n-  info->format_type = format_type;\n-  info->format_num = format_num;\n-  info->first_arg_num = first_arg_num;\n-}\n-\n-/* Record information for the names of function that modify the format\n-   argument to format functions.  FUNCTION_IDENT is the identifier node for\n-   the name of the function (its decl need not exist yet) and FORMAT_NUM is\n-   the number of the argument which is the format control string (starting\n-   from 1).  */\n+      if (info->format_type == format_type_error)\n+\t{\n+\t  if (validated_p)\n+\t    abort ();\n+\t  warning (\"`%s' is an unrecognized format function type\", p);\n+\t  return false;\n+\t}\n+    }\n \n-static void\n-record_international_format (name, assembler_name, format_num)\n-      tree name;\n-      tree assembler_name;\n-      int format_num;\n-{\n-  international_format_info *info;\n+  /* Strip any conversions from the string index and first arg number\n+     and verify they are constants.  */\n+  while (TREE_CODE (format_num_expr) == NOP_EXPR\n+\t || TREE_CODE (format_num_expr) == CONVERT_EXPR\n+\t || TREE_CODE (format_num_expr) == NON_LVALUE_EXPR)\n+    format_num_expr = TREE_OPERAND (format_num_expr, 0);\n \n-  /* Re-use existing structure if it's there.  */\n+  while (TREE_CODE (first_arg_num_expr) == NOP_EXPR\n+\t || TREE_CODE (first_arg_num_expr) == CONVERT_EXPR\n+\t || TREE_CODE (first_arg_num_expr) == NON_LVALUE_EXPR)\n+    first_arg_num_expr = TREE_OPERAND (first_arg_num_expr, 0);\n \n-  for (info = international_format_list; info; info = info->next)\n+  if (TREE_CODE (format_num_expr) != INTEGER_CST\n+      || TREE_INT_CST_HIGH (format_num_expr) != 0\n+      || TREE_CODE (first_arg_num_expr) != INTEGER_CST\n+      || TREE_INT_CST_HIGH (first_arg_num_expr) != 0)\n     {\n-      if (info->name == name && info->assembler_name == assembler_name)\n-\tbreak;\n+      if (validated_p)\n+\tabort ();\n+      error (\"format string has invalid operand number\");\n+      return false;\n     }\n \n-  if (! info)\n+  info->format_num = TREE_INT_CST_LOW (format_num_expr);\n+  info->first_arg_num = TREE_INT_CST_LOW (first_arg_num_expr);\n+  if (info->first_arg_num != 0 && info->first_arg_num <= info->format_num)\n     {\n-      info\n-\t= (international_format_info *)\n-\t  xmalloc (sizeof (international_format_info));\n-      info->next = international_format_list;\n-      international_format_list = info;\n-\n-      info->name = name;\n-      info->assembler_name = assembler_name;\n+      if (validated_p)\n+\tabort ();\n+      error (\"format string arg follows the args to be formatted\");\n+      return false;\n     }\n \n-  info->format_num = format_num;\n+  return true;\n }\n-\n-\n-\n \f\n /* Check a call to a format function against a parameter list.  */\n \n@@ -988,10 +895,11 @@ typedef struct\n static void check_format_info\tPARAMS ((int *, function_format_info *, tree));\n static void check_format_info_recurse PARAMS ((int *, format_check_results *,\n \t\t\t\t\t       function_format_info *, tree,\n-\t\t\t\t\t       tree, int));\n+\t\t\t\t\t       tree, unsigned HOST_WIDE_INT));\n static void check_format_info_main PARAMS ((int *, format_check_results *,\n \t\t\t\t\t    function_format_info *,\n-\t\t\t\t\t    const char *, int, tree, int));\n+\t\t\t\t\t    const char *, int, tree,\n+\t\t\t\t\t    unsigned HOST_WIDE_INT));\n static void status_warning PARAMS ((int *, const char *, ...))\n      ATTRIBUTE_PRINTF_2;\n \n@@ -1032,43 +940,42 @@ decode_format_type (s)\n \n \f\n /* Check the argument list of a call to printf, scanf, etc.\n-   NAME is the function identifier.\n-   ASSEMBLER_NAME is the function's assembler identifier.\n-   (Either NAME or ASSEMBLER_NAME, but not both, may be NULL_TREE.)\n+   ATTRS are the attributes on the function type.\n    PARAMS is the list of argument values.  Also, if -Wmissing-format-attribute,\n    warn for calls to vprintf or vscanf in functions with no such format\n    attribute themselves.  */\n \n void\n-check_function_format (status, name, assembler_name, params)\n+check_function_format (status, attrs, params)\n      int *status;\n-     tree name;\n-     tree assembler_name;\n+     tree attrs;\n      tree params;\n {\n-  function_format_info *info;\n+  tree a;\n \n-  /* See if this function is a format function.  */\n-  for (info = function_format_list; info; info = info->next)\n+  /* See if this function has any format attributes.  */\n+  for (a = attrs; a; a = TREE_CHAIN (a))\n     {\n-      if (info->assembler_name\n-\t  ? (info->assembler_name == assembler_name)\n-\t  : (info->name == name))\n+      if (is_attribute_p (\"format\", TREE_PURPOSE (a)))\n \t{\n \t  /* Yup; check it.  */\n-\t  check_format_info (status, info, params);\n-\t  if (warn_missing_format_attribute && info->first_arg_num == 0\n-\t      && (format_types[info->format_type].flags\n+\t  function_format_info info;\n+\t  decode_format_attr (TREE_VALUE (a), &info, 1);\n+\t  check_format_info (status, &info, params);\n+\t  if (warn_missing_format_attribute && info.first_arg_num == 0\n+\t      && (format_types[info.format_type].flags\n \t\t  & (int) FMT_FLAG_ARG_CONVERT))\n \t    {\n-\t      function_format_info *info2;\n-\t      for (info2 = function_format_list; info2; info2 = info2->next)\n-\t\tif ((info2->assembler_name\n-\t\t     ? (info2->assembler_name == DECL_ASSEMBLER_NAME (current_function_decl))\n-\t\t     : (info2->name == DECL_NAME (current_function_decl)))\n-\t\t    && info2->format_type == info->format_type)\n+\t      tree c;\n+\t      for (c = TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl));\n+\t\t   c;\n+\t\t   c = TREE_CHAIN (c))\n+\t\tif (is_attribute_p (\"format\", TREE_PURPOSE (c))\n+\t\t    && (decode_format_type (IDENTIFIER_POINTER\n+\t\t\t\t\t    (TREE_VALUE (TREE_VALUE (c))))\n+\t\t\t== info.format_type))\n \t\t  break;\n-\t      if (info2 == NULL)\n+\t      if (c == NULL_TREE)\n \t\t{\n \t\t  /* Check if the current function has a parameter to which\n \t\t     the format attribute could be attached; if not, it\n@@ -1086,10 +993,9 @@ check_function_format (status, name, assembler_name, params)\n \t\t    }\n \t\t  if (args != 0)\n \t\t    warning (\"function might be possible candidate for `%s' format attribute\",\n-\t\t\t     format_types[info->format_type].name);\n+\t\t\t     format_types[info.format_type].name);\n \t\t}\n \t    }\n-\t  break;\n \t}\n     }\n }\n@@ -1347,7 +1253,7 @@ check_format_info (status, info, params)\n      function_format_info *info;\n      tree params;\n {\n-  int arg_num;\n+  unsigned HOST_WIDE_INT arg_num;\n   tree format_tree;\n   format_check_results res;\n   /* Skip to format argument.  If the argument isn't available, there's\n@@ -1442,7 +1348,7 @@ check_format_info_recurse (status, res, info, format_tree, params, arg_num)\n      function_format_info *info;\n      tree format_tree;\n      tree params;\n-     int arg_num;\n+     unsigned HOST_WIDE_INT arg_num;\n {\n   int format_length;\n   HOST_WIDE_INT offset;\n@@ -1459,40 +1365,58 @@ check_format_info_recurse (status, res, info, format_tree, params, arg_num)\n       return;\n     }\n \n-  if (TREE_CODE (format_tree) == CALL_EXPR\n-      && TREE_CODE (TREE_OPERAND (format_tree, 0)) == ADDR_EXPR\n-      && (TREE_CODE (TREE_OPERAND (TREE_OPERAND (format_tree, 0), 0))\n-\t  == FUNCTION_DECL))\n+  if (TREE_CODE (format_tree) == CALL_EXPR)\n     {\n-      tree function = TREE_OPERAND (TREE_OPERAND (format_tree, 0), 0);\n+      tree type = TREE_TYPE (TREE_TYPE (TREE_OPERAND (format_tree, 0)));\n+      tree attrs;\n+      bool found_format_arg = false;\n \n       /* See if this is a call to a known internationalization function\n-\t that modifies the format arg.  */\n-      international_format_info *iinfo;\n+\t that modifies the format arg.  Such a function may have multiple\n+\t format_arg attributes (for example, ngettext).  */\n \n-      for (iinfo = international_format_list; iinfo; iinfo = iinfo->next)\n-\tif (iinfo->assembler_name\n-\t    ? (iinfo->assembler_name == DECL_ASSEMBLER_NAME (function))\n-\t    : (iinfo->name == DECL_NAME (function)))\n+      for (attrs = TYPE_ATTRIBUTES (type);\n+\t   attrs;\n+\t   attrs = TREE_CHAIN (attrs))\n+\tif (is_attribute_p (\"format_arg\", TREE_PURPOSE (attrs)))\n \t  {\n \t    tree inner_args;\n+\t    tree format_num_expr;\n+\t    int format_num;\n \t    int i;\n \n+\t    /* Extract the argument number, which was previously checked\n+\t       to be valid.  */\n+\t    format_num_expr = TREE_VALUE (TREE_VALUE (attrs));\n+\t    while (TREE_CODE (format_num_expr) == NOP_EXPR\n+\t\t   || TREE_CODE (format_num_expr) == CONVERT_EXPR\n+\t\t   || TREE_CODE (format_num_expr) == NON_LVALUE_EXPR)\n+\t      format_num_expr = TREE_OPERAND (format_num_expr, 0);\n+\n+\t    if (TREE_CODE (format_num_expr) != INTEGER_CST\n+\t\t|| TREE_INT_CST_HIGH (format_num_expr) != 0)\n+\t      abort ();\n+\n+\t    format_num = TREE_INT_CST_LOW (format_num_expr);\n+\n \t    for (inner_args = TREE_OPERAND (format_tree, 1), i = 1;\n \t\t inner_args != 0;\n \t\t inner_args = TREE_CHAIN (inner_args), i++)\n-\t      if (i == iinfo->format_num)\n+\t      if (i == format_num)\n \t\t{\n-\t\t  /* FIXME: with Marc Espie's __attribute__((nonnull))\n-\t\t     patch in GCC, we will have chained attributes,\n-\t\t     and be able to handle functions like ngettext\n-\t\t     with multiple format_arg attributes properly.  */\n \t\t  check_format_info_recurse (status, res, info,\n \t\t\t\t\t     TREE_VALUE (inner_args), params,\n \t\t\t\t\t     arg_num);\n-\t\t  return;\n+\t\t  found_format_arg = true;\n+\t\t  break;\n \t\t}\n \t  }\n+\n+      /* If we found a format_arg attribute and did a recursive check,\n+\t we are done with checking this format string.  Otherwise, we\n+\t continue and this will count as a non-literal format string.  */\n+      if (found_format_arg)\n+\treturn;\n     }\n \n   if (TREE_CODE (format_tree) == COND_EXPR)\n@@ -1666,7 +1590,7 @@ check_format_info_main (status, res, info, format_chars, format_length,\n      const char *format_chars;\n      int format_length;\n      tree params;\n-     int arg_num;\n+     unsigned HOST_WIDE_INT arg_num;\n {\n   const char *orig_format_chars = format_chars;\n   tree first_fillin_param = params;"}, {"sha": "09ebf4d4b9f43b329ff919d3eae64ab34d54d045", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f", "patch": "@@ -1510,8 +1510,8 @@ build_function_call (function, params)\n \n   /* Check for errors in format strings.  */\n \n-  if (warn_format && (name || assembler_name))\n-    check_function_format (NULL, name, assembler_name, coerced_params);\n+  if (warn_format)\n+    check_function_format (NULL, TYPE_ATTRIBUTES (fntype), coerced_params);\n \n   /* Recognize certain built-in functions so we can make tree-codes\n      other than CALL_EXPR.  We do this when it enables fold-const.c"}, {"sha": "54db0bdd9e3956c1358bfddf60500df092811923", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f", "patch": "@@ -1,3 +1,10 @@\n+2001-10-02  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* call.c (build_over_call), typeck.c (build_function_call_real):\n+\tPass type attributes to check_function_format rather than name or\n+\tassembler name.  Don't require there to be a name or assembler\n+\tname to check formats.\n+\n 2001-10-02  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* decl.c (init_decl_processing): Don't call"}, {"sha": "437d67cf5b88884428bf10603fa067b99b4ce8d5", "filename": "gcc/cp/call.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f", "patch": "@@ -4204,9 +4204,9 @@ build_over_call (cand, args, flags)\n \n   converted_args = nreverse (converted_args);\n \n-  if (warn_format && (DECL_NAME (fn) || DECL_ASSEMBLER_NAME (fn)))\n-    check_function_format (NULL, DECL_NAME (fn), DECL_ASSEMBLER_NAME (fn),\n-\t\t\t   converted_args); \n+  if (warn_format)\n+    check_function_format (NULL, TYPE_ATTRIBUTES (TREE_TYPE (fn)),\n+\t\t\t   converted_args);\n \n   /* Avoid actually calling copy constructors and copy assignment operators,\n      if possible.  */"}, {"sha": "c57bb08ab3ecec3ceb006a4fb1d22dce97bb8fb4", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f", "patch": "@@ -3035,8 +3035,8 @@ build_function_call_real (function, params, require_complete, flags)\n \n   /* Check for errors in format strings.  */\n \n-  if (warn_format && (name || assembler_name))\n-    check_function_format (NULL, name, assembler_name, coerced_params);\n+  if (warn_format)\n+    check_function_format (NULL, TYPE_ATTRIBUTES (fntype), coerced_params);\n \n   /* Recognize certain built-in functions so we can make tree-codes\n      other than CALL_EXPR.  We do this when it enables fold-const.c"}, {"sha": "087feed8da173f9a6d064d4f51c169576034befe", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f", "patch": "@@ -1,3 +1,11 @@\n+2001-10-02  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* g++.dg/warn/format2.C, gcc.dg/format/attr-7.c,\n+\tgcc.dg/format/multattr-1.c, gcc.dg/format/multattr-2.c,\n+\tgcc.dg/format/multattr-3.c: New tests.\n+\t* gcc.dg/format/attr-3.c: Update expected error texts.  Remove\n+\ttests for format attributes on function pointers being rejected.\n+\n 2001-10-02  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* gcc.dg/format/attr-5.c, gcc.dg/format/attr-6.c: New tests."}, {"sha": "639bc668bc591d320261ad2c7a8c9d1d9683561e", "filename": "gcc/testsuite/g++.dg/warn/format2.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fformat2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fformat2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fformat2.C?ref=80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f", "patch": "@@ -0,0 +1,32 @@\n+// Test for format attributes: test applying them to types in C++.\n+// Origin: Joseph Myers <jsm28@cam.ac.uk>\n+// { dg-do compile }\n+// { dg-options \"-Wformat\" }\n+\n+__attribute__((format(printf, 1, 2))) void (*tformatprintf0) (const char *, ...);\n+void (*tformatprintf1) (const char *, ...) __attribute__((format(printf, 1, 2)));\n+void (__attribute__((format(printf, 1, 2))) *tformatprintf2) (const char *, ...);\n+void (__attribute__((format(printf, 1, 2))) ****tformatprintf3) (const char *, ...);\n+\n+char * (__attribute__((format_arg(1))) *tformat_arg) (const char *);\n+\n+void\n+baz (int i)\n+{\n+  (*tformatprintf0) (\"%d\", i);\n+  (*tformatprintf0) ((*tformat_arg) (\"%d\"), i);\n+  (*tformatprintf0) (\"%\"); // { dg-warning \"format\" \"prefix\" }\n+  (*tformatprintf0) ((*tformat_arg) (\"%\")); // { dg-warning \"format\" \"prefix\" }\n+  (*tformatprintf1) (\"%d\", i);\n+  (*tformatprintf1) ((*tformat_arg) (\"%d\"), i);\n+  (*tformatprintf1) (\"%\"); // { dg-warning \"format\" \"postfix\" }\n+  (*tformatprintf1) ((*tformat_arg) (\"%\")); // { dg-warning \"format\" \"postfix\" }\n+  (*tformatprintf2) (\"%d\", i);\n+  (*tformatprintf2) ((*tformat_arg) (\"%d\"), i);\n+  (*tformatprintf2) (\"%\"); // { dg-warning \"format\" \"nested\" }\n+  (*tformatprintf2) ((*tformat_arg) (\"%\")); // { dg-warning \"format\" \"nested\" }\n+  (****tformatprintf3) (\"%d\", i);\n+  (****tformatprintf3) ((*tformat_arg) (\"%d\"), i);\n+  (****tformatprintf3) (\"%\"); // { dg-warning \"format\" \"nested 2\" }\n+  (****tformatprintf3) ((*tformat_arg) (\"%\")); // { dg-warning \"format\" \"nested 2\" }\n+}"}, {"sha": "9627497ea5241bfee91783e1a931fe16e4e60c2a", "filename": "gcc/testsuite/gcc.dg/format/attr-3.c", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fattr-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fattr-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fattr-3.c?ref=80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f", "patch": "@@ -25,21 +25,13 @@ extern void fc3 (const char *) __attribute__((format_arg(1, 2))); /* { dg-error\n /* These attributes presently only apply to declarations, not to types.\n    Eventually, they should be usable with declarators for function types\n    anywhere, but still not with structure/union/enum types.  */\n-struct s0 { int i; } __attribute__((format(printf, 1, 2))); /* { dg-error \"does not apply\" \"format on struct\" } */\n-union u0 { int i; } __attribute__((format(printf, 1, 2))); /* { dg-error \"does not apply\" \"format on union\" } */\n-enum e0 { E0V0 } __attribute__((format(printf, 1, 2))); /* { dg-error \"does not apply\" \"format on enum\" } */\n+struct s0 { int i; } __attribute__((format(printf, 1, 2))); /* { dg-error \"does not apply|only applies\" \"format on struct\" } */\n+union u0 { int i; } __attribute__((format(printf, 1, 2))); /* { dg-error \"does not apply|only applies\" \"format on union\" } */\n+enum e0 { E0V0 } __attribute__((format(printf, 1, 2))); /* { dg-error \"does not apply|only applies\" \"format on enum\" } */\n \n-struct s1 { int i; } __attribute__((format_arg(1))); /* { dg-error \"does not apply\" \"format_arg on struct\" } */\n-union u1 { int i; } __attribute__((format_arg(1))); /* { dg-error \"does not apply\" \"format_arg on union\" } */\n-enum e1 { E1V0 } __attribute__((format_arg(1))); /* { dg-error \"does not apply\" \"format_arg on enum\" } */\n-\n-/* At present, only functions can be declared with these attributes.\n-   Once they can be applied to function types in function pointers, etc.,\n-   these tests should be removed, and tests should be added (say in a new\n-   testcase attr-<num>.c) that such attributes work and calls through such\n-   function pointers (etc.) get checked.  */\n-extern void (*fd0) (const char *, ...) __attribute__((format(printf, 1, 2))); /* { dg-error \"non-function\" \"format on non-function\" } */\n-extern char *(*fd1) (const char *) __attribute__((format_arg(1))); /* { dg-error \"non-function\" \"format on non-function\" } */\n+struct s1 { int i; } __attribute__((format_arg(1))); /* { dg-error \"does not apply|only applies\" \"format_arg on struct\" } */\n+union u1 { int i; } __attribute__((format_arg(1))); /* { dg-error \"does not apply|only applies\" \"format_arg on union\" } */\n+enum e1 { E1V0 } __attribute__((format_arg(1))); /* { dg-error \"does not apply|only applies\" \"format_arg on enum\" } */\n \n /* The format type must be an identifier, one of those recognised.  */\n extern void fe0 (const char *, ...) __attribute__((format(12345, 1, 2))); /* { dg-error \"format specifier\" \"non-id format\" } */"}, {"sha": "78526a5e9bbe8387942a7c2a06757eb0a739b800", "filename": "gcc/testsuite/gcc.dg/format/attr-7.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fattr-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fattr-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fattr-7.c?ref=80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f", "patch": "@@ -0,0 +1,34 @@\n+/* Test for format attributes: test applying them to types.  */\n+/* Origin: Joseph Myers <jsm28@cam.ac.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu99 -Wformat\" } */\n+\n+#include \"format.h\"\n+\n+__attribute__((format(printf, 1, 2))) void (*tformatprintf0) (const char *, ...);\n+void (*tformatprintf1) (const char *, ...) __attribute__((format(printf, 1, 2)));\n+void (__attribute__((format(printf, 1, 2))) *tformatprintf2) (const char *, ...);\n+void (__attribute__((format(printf, 1, 2))) ****tformatprintf3) (const char *, ...);\n+\n+char * (__attribute__((format_arg(1))) *tformat_arg) (const char *);\n+\n+void\n+baz (int i)\n+{\n+  (*tformatprintf0) (\"%d\", i);\n+  (*tformatprintf0) ((*tformat_arg) (\"%d\"), i);\n+  (*tformatprintf0) (\"%\"); /* { dg-warning \"format\" \"prefix\" } */\n+  (*tformatprintf0) ((*tformat_arg) (\"%\")); /* { dg-warning \"format\" \"prefix\" } */\n+  (*tformatprintf1) (\"%d\", i);\n+  (*tformatprintf1) ((*tformat_arg) (\"%d\"), i);\n+  (*tformatprintf1) (\"%\"); /* { dg-warning \"format\" \"postfix\" } */\n+  (*tformatprintf1) ((*tformat_arg) (\"%\")); /* { dg-warning \"format\" \"postfix\" } */\n+  (*tformatprintf2) (\"%d\", i);\n+  (*tformatprintf2) ((*tformat_arg) (\"%d\"), i);\n+  (*tformatprintf2) (\"%\"); /* { dg-warning \"format\" \"nested\" } */\n+  (*tformatprintf2) ((*tformat_arg) (\"%\")); /* { dg-warning \"format\" \"nested\" } */\n+  (****tformatprintf3) (\"%d\", i);\n+  (****tformatprintf3) ((*tformat_arg) (\"%d\"), i);\n+  (****tformatprintf3) (\"%\"); /* { dg-warning \"format\" \"nested 2\" } */\n+  (****tformatprintf3) ((*tformat_arg) (\"%\")); /* { dg-warning \"format\" \"nested 2\" } */\n+}"}, {"sha": "7691aba5bd8780ffe0901ee3d288964486024bbc", "filename": "gcc/testsuite/gcc.dg/format/multattr-1.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fmultattr-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fmultattr-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fmultattr-1.c?ref=80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f", "patch": "@@ -0,0 +1,50 @@\n+/* Test for multiple format attributes.  Test for printf and scanf attributes\n+   together.  */\n+/* Origin: Joseph Myers <jsm28@cam.ac.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu99 -Wformat\" } */\n+\n+#include \"format.h\"\n+\n+/* If we specify multiple attributes for a single function, they should\n+   all apply.  This should apply whether they are on the same declaration\n+   or on different declarations.  */\n+\n+extern void my_vprintf_scanf (const char *, va_list, const char *, ...)\n+     __attribute__((__format__(__printf__, 1, 0)))\n+     __attribute__((__format__(__scanf__, 3, 4)));\n+\n+extern void my_vprintf_scanf2 (const char *, va_list, const char *, ...)\n+     __attribute__((__format__(__scanf__, 3, 4)))\n+     __attribute__((__format__(__printf__, 1, 0)));\n+\n+extern void my_vprintf_scanf3 (const char *, va_list, const char *, ...)\n+     __attribute__((__format__(__printf__, 1, 0)));\n+extern void my_vprintf_scanf3 (const char *, va_list, const char *, ...)\n+     __attribute__((__format__(__scanf__, 3, 4)));\n+\n+extern void my_vprintf_scanf4 (const char *, va_list, const char *, ...)\n+     __attribute__((__format__(__scanf__, 3, 4)));\n+extern void my_vprintf_scanf4 (const char *, va_list, const char *, ...)\n+     __attribute__((__format__(__printf__, 1, 0)));\n+\n+void\n+foo (va_list ap, int *ip, long *lp)\n+{\n+  my_vprintf_scanf (\"%d\", ap, \"%d\", ip);\n+  my_vprintf_scanf (\"%d\", ap, \"%ld\", lp);\n+  my_vprintf_scanf (\"%\", ap, \"%d\", ip); /* { dg-warning \"format\" \"printf\" } */\n+  my_vprintf_scanf (\"%d\", ap, \"%ld\", ip); /* { dg-warning \"format\" \"scanf\" } */\n+  my_vprintf_scanf2 (\"%d\", ap, \"%d\", ip);\n+  my_vprintf_scanf2 (\"%d\", ap, \"%ld\", lp);\n+  my_vprintf_scanf2 (\"%\", ap, \"%d\", ip); /* { dg-warning \"format\" \"printf\" } */\n+  my_vprintf_scanf2 (\"%d\", ap, \"%ld\", ip); /* { dg-warning \"format\" \"scanf\" } */\n+  my_vprintf_scanf3 (\"%d\", ap, \"%d\", ip);\n+  my_vprintf_scanf3 (\"%d\", ap, \"%ld\", lp);\n+  my_vprintf_scanf3 (\"%\", ap, \"%d\", ip); /* { dg-warning \"format\" \"printf\" } */\n+  my_vprintf_scanf3 (\"%d\", ap, \"%ld\", ip); /* { dg-warning \"format\" \"scanf\" } */\n+  my_vprintf_scanf4 (\"%d\", ap, \"%d\", ip);\n+  my_vprintf_scanf4 (\"%d\", ap, \"%ld\", lp);\n+  my_vprintf_scanf4 (\"%\", ap, \"%d\", ip); /* { dg-warning \"format\" \"printf\" } */\n+  my_vprintf_scanf4 (\"%d\", ap, \"%ld\", ip); /* { dg-warning \"format\" \"scanf\" } */\n+}"}, {"sha": "1d78840aecb906a80e7085be24d2767313117d1c", "filename": "gcc/testsuite/gcc.dg/format/multattr-2.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fmultattr-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fmultattr-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fmultattr-2.c?ref=80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f", "patch": "@@ -0,0 +1,39 @@\n+/* Test for multiple format attributes.  Test for printf and scanf attributes\n+   together, in different places on the declarations.  */\n+/* Origin: Joseph Myers <jsm28@cam.ac.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu99 -Wformat\" } */\n+\n+#include \"format.h\"\n+\n+/* If we specify multiple attributes for a single function, they should\n+   all apply, wherever they are placed on the declarations.  */\n+\n+extern __attribute__((__format__(__printf__, 1, 0))) void\n+     my_vprintf_scanf (const char *, va_list, const char *, ...)\n+     __attribute__((__format__(__scanf__, 3, 4)));\n+\n+extern void (__attribute__((__format__(__printf__, 1, 0))) my_vprintf_scanf2)\n+     (const char *, va_list, const char *, ...)\n+     __attribute__((__format__(__scanf__, 3, 4)));\n+\n+extern __attribute__((__format__(__scanf__, 3, 4))) void\n+     (__attribute__((__format__(__printf__, 1, 0))) my_vprintf_scanf3)\n+     (const char *, va_list, const char *, ...);\n+\n+void\n+foo (va_list ap, int *ip, long *lp)\n+{\n+  my_vprintf_scanf (\"%d\", ap, \"%d\", ip);\n+  my_vprintf_scanf (\"%d\", ap, \"%ld\", lp);\n+  my_vprintf_scanf (\"%\", ap, \"%d\", ip); /* { dg-warning \"format\" \"printf\" } */\n+  my_vprintf_scanf (\"%d\", ap, \"%ld\", ip); /* { dg-warning \"format\" \"scanf\" } */\n+  my_vprintf_scanf2 (\"%d\", ap, \"%d\", ip);\n+  my_vprintf_scanf2 (\"%d\", ap, \"%ld\", lp);\n+  my_vprintf_scanf2 (\"%\", ap, \"%d\", ip); /* { dg-warning \"format\" \"printf\" } */\n+  my_vprintf_scanf2 (\"%d\", ap, \"%ld\", ip); /* { dg-warning \"format\" \"scanf\" } */\n+  my_vprintf_scanf3 (\"%d\", ap, \"%d\", ip);\n+  my_vprintf_scanf3 (\"%d\", ap, \"%ld\", lp);\n+  my_vprintf_scanf3 (\"%\", ap, \"%d\", ip); /* { dg-warning \"format\" \"printf\" } */\n+  my_vprintf_scanf3 (\"%d\", ap, \"%ld\", ip); /* { dg-warning \"format\" \"scanf\" } */\n+}"}, {"sha": "40467fe2d4c6f524768779ef8203e8f7fc393781", "filename": "gcc/testsuite/gcc.dg/format/multattr-3.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fmultattr-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fmultattr-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fmultattr-3.c?ref=80a497e4e967ad5cdf59a1c4d2be2fdbba14ea3f", "patch": "@@ -0,0 +1,28 @@\n+/* Test for multiple format_arg attributes.  Test for both branches\n+   getting checked.  */\n+/* Origin: Joseph Myers <jsm28@cam.ac.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu99 -Wformat\" } */\n+\n+#include \"format.h\"\n+\n+extern char *ngettext (const char *, const char *, unsigned long int)\n+     __attribute__((__format_arg__(1))) __attribute__((__format_arg__(2)));\n+\n+void\n+foo (long l, int nfoo)\n+{\n+  printf (ngettext (\"%d foo\", \"%d foos\", nfoo), nfoo);\n+  printf (ngettext (\"%d foo\", \"%d foos\", l), l); /* { dg-warning \"int format\" \"wrong type in conditional expr\" } */\n+  printf (ngettext (\"%d foo\", \"%ld foos\", l), l); /* { dg-warning \"int format\" \"wrong type in conditional expr\" } */\n+  printf (ngettext (\"%ld foo\", \"%d foos\", l), l); /* { dg-warning \"int format\" \"wrong type in conditional expr\" } */\n+  /* Should allow one case to have extra arguments.  */\n+  printf (ngettext (\"1 foo\", \"%d foos\", nfoo), nfoo);\n+  printf (ngettext (\"1 foo\", \"many foos\", nfoo), nfoo); /* { dg-warning \"too many\" \"too many args in all branches\" } */\n+  printf (ngettext (\"\", \"%d foos\", nfoo), nfoo);\n+  printf (ngettext (\"1 foo\", (nfoo > 0) ? \"%d foos\" : \"no foos\", nfoo), nfoo);\n+  printf (ngettext (\"%d foo\", (nfoo > 0) ? \"%d foos\" : \"no foos\", nfoo), nfoo);\n+  printf (ngettext (\"%ld foo\", (nfoo > 0) ? \"%d foos\" : \"no foos\", nfoo), nfoo); /* { dg-warning \"long int format\" \"wrong type\" } */\n+  printf (ngettext (\"%d foo\", (nfoo > 0) ? \"%ld foos\" : \"no foos\", nfoo), nfoo); /* { dg-warning \"long int format\" \"wrong type\" } */\n+  printf (ngettext (\"%d foo\", (nfoo > 0) ? \"%d foos\" : \"%ld foos\", nfoo), nfoo); /* { dg-warning \"long int format\" \"wrong type\" } */\n+}"}]}