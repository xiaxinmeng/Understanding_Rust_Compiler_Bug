{"sha": "7c5222ff1a2283b0f8c889da777c7dae5d4224ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2M1MjIyZmYxYTIyODNiMGY4Yzg4OWRhNzc3YzdkYWU1ZDQyMjRiYQ==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2009-06-16T07:21:12Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2009-06-16T07:21:12Z"}, "message": "tree-parloops.c (loop_parallel_p): Call vect_is_simple_reduction with additional parameter.\n\n\n\t* tree-parloops.c (loop_parallel_p): Call vect_is_simple_reduction\n\twith additional parameter.\n\t* tree-vectorizer.h (enum vect_def_type): Add new value \n\tvect_nested_cycle.\n\t(enum vect_relevant): Add comments.\n\t(vect_is_simple_reduction): Add new argument.\n\t* tree-vect-loop.c (vect_analyze_scalar_cycles_1): Add comments.\n\tDetect nested cycles.\n\t(vect_is_simple_reduction): Update documentation, add an argument to\n\tdistinguish inner-loop reduction from nested cycle, detect nested\n\tcycles, fix printings and indentation, don't swap operands in case\n\tof nested cycle.\n\t(get_initial_def_for_reduction): Handle subtraction.\n\t(vect_create_epilog_for_reduction): Add new argument to specify\n\treduction variable.\n\t(vect_finalize_reduction): Handle subtraction, fix comments.\n\t(vectorizable_reduction): Handle nested cycles. In case of nested cycle\n\tkeep track of the reduction variable position. Call \n\tvect_is_simple_reduction with additional parameter. Use original \n\tstatement code in reduction epilogue for nested cycle. Call\n\tvect_create_epilog_for_reduction with additional parameter.\n\t* tree-vect-patterns.c (vect_recog_dot_prod_pattern): Assert inner-loop\n\tvectorization.\n\t(vect_recog_widen_sum_pattern): Likewise.\n\t* tree-vect-stmts.c (process_use): Distinguish between nested cycles\n\tand reductions.\n\t(vect_mark_stmts_to_be_vectorized): Likewise.\n\t(vect_get_vec_def_for_operand): Handle nested cycles.\n\nFrom-SVN: r148518", "tree": {"sha": "aaaf3e70f41a000974285e5e7f0db250fa701499", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aaaf3e70f41a000974285e5e7f0db250fa701499"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c5222ff1a2283b0f8c889da777c7dae5d4224ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c5222ff1a2283b0f8c889da777c7dae5d4224ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c5222ff1a2283b0f8c889da777c7dae5d4224ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c5222ff1a2283b0f8c889da777c7dae5d4224ba/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3ba558dba3cf0a581a1a70cf8e6de5c2d26dcf96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ba558dba3cf0a581a1a70cf8e6de5c2d26dcf96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ba558dba3cf0a581a1a70cf8e6de5c2d26dcf96"}], "stats": {"total": 518, "additions": 408, "deletions": 110}, "files": [{"sha": "716f1b326c05de01ddc5639940506fa35ea216fc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c5222ff1a2283b0f8c889da777c7dae5d4224ba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c5222ff1a2283b0f8c889da777c7dae5d4224ba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7c5222ff1a2283b0f8c889da777c7dae5d4224ba", "patch": "@@ -1,3 +1,34 @@\n+2009-06-16  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* tree-parloops.c (loop_parallel_p): Call vect_is_simple_reduction\n+\twith additional parameter.\n+\t* tree-vectorizer.h (enum vect_def_type): Add new value \n+\tvect_nested_cycle.\n+\t(enum vect_relevant): Add comments.\n+\t(vect_is_simple_reduction): Add new argument.\n+\t* tree-vect-loop.c (vect_analyze_scalar_cycles_1): Add comments.\n+\tDetect nested cycles.\n+\t(vect_is_simple_reduction): Update documentation, add an argument to\n+\tdistinguish inner-loop reduction from nested cycle, detect nested\n+\tcycles, fix printings and indentation, don't swap operands in case\n+\tof nested cycle.\n+\t(get_initial_def_for_reduction): Handle subtraction.\n+\t(vect_create_epilog_for_reduction): Add new argument to specify\n+\treduction variable.\n+\t(vect_finalize_reduction): Handle subtraction, fix comments.\n+\t(vectorizable_reduction): Handle nested cycles. In case of nested cycle\n+\tkeep track of the reduction variable position. Call \n+\tvect_is_simple_reduction with additional parameter. Use original \n+\tstatement code in reduction epilogue for nested cycle. Call\n+\tvect_create_epilog_for_reduction with additional parameter.\n+\t* tree-vect-patterns.c (vect_recog_dot_prod_pattern): Assert inner-loop\n+\tvectorization.\n+\t(vect_recog_widen_sum_pattern): Likewise.\n+\t* tree-vect-stmts.c (process_use): Distinguish between nested cycles\n+\tand reductions.\n+\t(vect_mark_stmts_to_be_vectorized): Likewise.\n+\t(vect_get_vec_def_for_operand): Handle nested cycles.\n+\n 2009-06-16  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n \n \t* doc/invoke.texi (Debugging Options): Fix option index entries"}, {"sha": "cf97ed17b5e6a39fbbf743ac10eb4ebe4031a37c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c5222ff1a2283b0f8c889da777c7dae5d4224ba/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c5222ff1a2283b0f8c889da777c7dae5d4224ba/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7c5222ff1a2283b0f8c889da777c7dae5d4224ba", "patch": "@@ -1,3 +1,15 @@\n+2009-06-16  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* gcc.dg/vect/vect-outer-4g.c: Don't look for pattern not allowed \n+\tprinting.\n+\t* gcc.dg/vect/vect-outer-4k.c, gcc.dg/vect/vect-outer-4l.c,\n+\tgcc.dg/vect/vect-outer-4f.c: Likewise.\n+\t* gcc.dg/vect/vect-nest-cycle-1.c: New test.\n+\t* gcc.dg/vect/vect-nest-cycle-2.c, gcc.dg/vect/vect-nest-cycle-3.c: \n+\tLikewise.\n+\t* gcc.dg/vect/vect-outer-1a.c: Fail because of strided access in outer \n+\tloop.\n+\n 2009-06-16  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/40383"}, {"sha": "0cf2ca06d14d7065a43d613de44104e688efcfb3", "filename": "gcc/testsuite/gcc.dg/vect/vect-nest-cycle-1.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c5222ff1a2283b0f8c889da777c7dae5d4224ba/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-nest-cycle-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c5222ff1a2283b0f8c889da777c7dae5d4224ba/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-nest-cycle-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-nest-cycle-1.c?ref=7c5222ff1a2283b0f8c889da777c7dae5d4224ba", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-require-effective-target vect_float } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16 \n+\n+float in[N] = {232,132,32,432,532,321,327,323,321,324,322,329,432,832,932,232};\n+float out[N];\n+float check_res[N] = {112,-4,-120,264,348,121,111,91,73,60,42,33,120,504,588,-128};\n+float a[2*N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31};\n+\n+/* Outer-loop vectorization.  */\n+\n+__attribute__ ((noinline)) void \n+foo () \n+{\n+  int i, j;\n+  float res;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      res = in[i];\n+\n+      for (j = 0; j < N; j++) \n+        res = res - a[i+j];\n+        \n+      out[i] = res;\n+    }\n+\n+  for (i = 0; i < N; i++)  \n+    if (out[i] != check_res[i])\n+      abort ();\n+\n+}\n+\n+int main ()\n+{\n+  check_vect ();\n+\n+  foo();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "fd63a785d00a0c8acfc425326ea4f6289b5474b6", "filename": "gcc/testsuite/gcc.dg/vect/vect-nest-cycle-2.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c5222ff1a2283b0f8c889da777c7dae5d4224ba/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-nest-cycle-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c5222ff1a2283b0f8c889da777c7dae5d4224ba/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-nest-cycle-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-nest-cycle-2.c?ref=7c5222ff1a2283b0f8c889da777c7dae5d4224ba", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-require-effective-target vect_float } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16 \n+\n+float out[N];\n+float check_res[N] = {880,864,848,832,816,800,784,768,752,736,720,704,688,672,656,640};\n+float a[2*N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31};\n+\n+/* Outer-loop vectorization.  */\n+\n+__attribute__ ((noinline)) void \n+foo () \n+{\n+  int i, j;\n+  float res;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      res = 1000;\n+\n+      for (j = 0; j < N; j++) \n+        res = res - a[i+j];\n+        \n+      out[i] = res;\n+    }\n+\n+  for (i = 0; i < N; i++)  \n+    if (out[i] != check_res[i])\n+      abort ();\n+\n+}\n+\n+int main ()\n+{\n+  check_vect ();\n+\n+  foo();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "70fa6b84d98d7eb66287cf5f3c6aa938086ca559", "filename": "gcc/testsuite/gcc.dg/vect/vect-nest-cycle-3.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c5222ff1a2283b0f8c889da777c7dae5d4224ba/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-nest-cycle-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c5222ff1a2283b0f8c889da777c7dae5d4224ba/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-nest-cycle-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-nest-cycle-3.c?ref=7c5222ff1a2283b0f8c889da777c7dae5d4224ba", "patch": "@@ -0,0 +1,57 @@\n+/* { dg-require-effective-target vect_float } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+#define DIFF 82\n+\n+float c[N][N], b[N][N], a[N];\n+\n+__attribute__ ((noinline)) int \n+main1 ()\n+{\n+  int i, j;\n+  float diff;\n+\n+  /* In inner loop vectorization -funsafe-math-optimizations is needed to \n+     vectorize the summation. But in outer loop vectorization the order of\n+     calculation doesn't change, therefore, there is no need in that flag.  */\n+  for (i = 0; i < N; i++)\n+    {\n+      diff = 2;\n+      for (j = 0; j < N; j++) \n+        diff += (b[j][i] - c[j][i]);\n+\n+      a[i] = diff;\n+    }\n+\n+  /* Check results:  */\n+  for (i = 0; i < N; i++)\n+    if (a[i] != DIFF)\n+      abort ();\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  int i, j;\n+\n+  for (i = 0; i < N; i++)\n+    for (j = 0; j < N; j++)\n+      {\n+        b[i][j] = i+j+5;\n+        c[i][j] = i+j;\n+      }\n+         \n+  check_vect ();\n+  \n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "f88dd21059bf21e8ad160c85488cd12377e1ec0a", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-1a.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c5222ff1a2283b0f8c889da777c7dae5d4224ba/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-1a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c5222ff1a2283b0f8c889da777c7dae5d4224ba/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-1a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-1a.c?ref=7c5222ff1a2283b0f8c889da777c7dae5d4224ba", "patch": "@@ -4,9 +4,7 @@\n signed short image[N][N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));\n signed short block[N][N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));\n \n-/* Can't do outer-loop vectorization because of non-consecutive access.\n-   Currently fails to vectorize because the reduction pattern is not\n-   recognized.  */\n+/* Can't do outer-loop vectorization because of non-consecutive access.  */\n \n int\n foo (){\n@@ -22,7 +20,5 @@ foo (){\n }\n \n /* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { xfail *-*-* } } } */\n-/* FORNOW */\n-/* { dg-final { scan-tree-dump-times \"strided access in outer loop\" 1 \"vect\" { xfail *-*-* } } } */\n-/* { dg-final { scan-tree-dump-times \"unexpected pattern\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"strided access in outer loop\" 1 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "c6cc4a8d1a408eb3d062083850f41d56c96b1b96", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-4f.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c5222ff1a2283b0f8c889da777c7dae5d4224ba/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4f.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c5222ff1a2283b0f8c889da777c7dae5d4224ba/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4f.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4f.c?ref=7c5222ff1a2283b0f8c889da777c7dae5d4224ba", "patch": "@@ -66,5 +66,4 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { xfail *-*-* } } } */\n-/* { dg-final { scan-tree-dump-times \"vect_recog_widen_sum_pattern: not allowed\" 1 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "c6cc4a8d1a408eb3d062083850f41d56c96b1b96", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-4g.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c5222ff1a2283b0f8c889da777c7dae5d4224ba/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4g.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c5222ff1a2283b0f8c889da777c7dae5d4224ba/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4g.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4g.c?ref=7c5222ff1a2283b0f8c889da777c7dae5d4224ba", "patch": "@@ -66,5 +66,4 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { xfail *-*-* } } } */\n-/* { dg-final { scan-tree-dump-times \"vect_recog_widen_sum_pattern: not allowed\" 1 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "c6cc4a8d1a408eb3d062083850f41d56c96b1b96", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-4k.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c5222ff1a2283b0f8c889da777c7dae5d4224ba/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c5222ff1a2283b0f8c889da777c7dae5d4224ba/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4k.c?ref=7c5222ff1a2283b0f8c889da777c7dae5d4224ba", "patch": "@@ -66,5 +66,4 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { xfail *-*-* } } } */\n-/* { dg-final { scan-tree-dump-times \"vect_recog_widen_sum_pattern: not allowed\" 1 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "c6cc4a8d1a408eb3d062083850f41d56c96b1b96", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-4l.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c5222ff1a2283b0f8c889da777c7dae5d4224ba/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4l.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c5222ff1a2283b0f8c889da777c7dae5d4224ba/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4l.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4l.c?ref=7c5222ff1a2283b0f8c889da777c7dae5d4224ba", "patch": "@@ -66,5 +66,4 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { xfail *-*-* } } } */\n-/* { dg-final { scan-tree-dump-times \"vect_recog_widen_sum_pattern: not allowed\" 1 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "5f11fc77a1b43c59dbfb842c73c6daf2c81efb65", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c5222ff1a2283b0f8c889da777c7dae5d4224ba/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c5222ff1a2283b0f8c889da777c7dae5d4224ba/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=7c5222ff1a2283b0f8c889da777c7dae5d4224ba", "patch": "@@ -290,7 +290,7 @@ loop_parallel_p (struct loop *loop, htab_t reduction_list,\n       if (!is_gimple_reg (PHI_RESULT (phi)))\n \tcontinue;\n       if (simple_loop_info)\n-\treduc_stmt = vect_is_simple_reduction (simple_loop_info, phi);\n+\treduc_stmt = vect_is_simple_reduction (simple_loop_info, phi, true);\n \n       /*  Create a reduction_info struct, initialize it and insert it to \n          the reduction list.  */"}, {"sha": "a37e3c00f72f5ba39aee2049189d00bd2d5cf80d", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 167, "deletions": 57, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c5222ff1a2283b0f8c889da777c7dae5d4224ba/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c5222ff1a2283b0f8c889da777c7dae5d4224ba/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=7c5222ff1a2283b0f8c889da777c7dae5d4224ba", "patch": "@@ -414,7 +414,9 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_analyze_scalar_cycles ===\");\n \n-  /* First - identify all inductions.  */\n+  /* First - identify all inductions. Reduction detection assumes that all the\n+     inductions have been identified, therefore, this order must not be \n+     changed.  */\n   for (gsi = gsi_start_phis  (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n       gimple phi = gsi_stmt (gsi);\n@@ -456,13 +458,14 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n     }\n \n \n-  /* Second - identify all reductions.  */\n+  /* Second - identify all reductions and nested cycles.  */\n   while (VEC_length (gimple, worklist) > 0)\n     {\n       gimple phi = VEC_pop (gimple, worklist);\n       tree def = PHI_RESULT (phi);\n       stmt_vec_info stmt_vinfo = vinfo_for_stmt (phi);\n       gimple reduc_stmt;\n+      bool nested_cycle;\n \n       if (vect_print_dump_info (REPORT_DETAILS))\n         { \n@@ -473,22 +476,35 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n       gcc_assert (is_gimple_reg (SSA_NAME_VAR (def)));\n       gcc_assert (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_unknown_def_type);\n \n-      reduc_stmt = vect_is_simple_reduction (loop_vinfo, phi);\n+      nested_cycle = (loop != LOOP_VINFO_LOOP (loop_vinfo));\n+      reduc_stmt = vect_is_simple_reduction (loop_vinfo, phi, !nested_cycle);\n       if (reduc_stmt)\n         {\n-          if (vect_print_dump_info (REPORT_DETAILS))\n-            fprintf (vect_dump, \"Detected reduction.\");\n-          STMT_VINFO_DEF_TYPE (stmt_vinfo) = vect_reduction_def;\n-          STMT_VINFO_DEF_TYPE (vinfo_for_stmt (reduc_stmt)) =\n+          if (nested_cycle)\n+            {\n+              if (vect_print_dump_info (REPORT_DETAILS))\n+                fprintf (vect_dump, \"Detected vectorizable nested cycle.\");\n+\n+              STMT_VINFO_DEF_TYPE (stmt_vinfo) = vect_nested_cycle;\n+              STMT_VINFO_DEF_TYPE (vinfo_for_stmt (reduc_stmt)) =\n+                                                        vect_nested_cycle;\n+            }\n+          else\n+            {\n+              if (vect_print_dump_info (REPORT_DETAILS))\n+                fprintf (vect_dump, \"Detected reduction.\");\n+\n+              STMT_VINFO_DEF_TYPE (stmt_vinfo) = vect_reduction_def;\n+              STMT_VINFO_DEF_TYPE (vinfo_for_stmt (reduc_stmt)) =\n                                                         vect_reduction_def;\n+            }\n         }\n       else\n         if (vect_print_dump_info (REPORT_DETAILS))\n           fprintf (vect_dump, \"Unknown def-use cycle pattern.\");\n     }\n \n   VEC_free (gimple, heap, worklist);\n-  return;\n }\n \n \n@@ -1501,15 +1517,19 @@ report_vect_op (gimple stmt, const char *msg)\n   \n    such that:\n    1. operation is commutative and associative and it is safe to \n-      change the order of the computation.\n+      change the order of the computation (if CHECK_REDUCTION is true)\n    2. no uses for a2 in the loop (a2 is used out of the loop)\n    3. no uses of a1 in the loop besides the reduction operation.\n \n    Condition 1 is tested here.\n-   Conditions 2,3 are tested in vect_mark_stmts_to_be_vectorized.  */\n+   Conditions 2,3 are tested in vect_mark_stmts_to_be_vectorized.  \n+\n+   Also detect a cross-iteration def-use cycle in nested loops, i.e., nested\n+   cycles, if CHECK_REDUCTION is false.  */\n \n gimple\n-vect_is_simple_reduction (loop_vec_info loop_info, gimple phi)\n+vect_is_simple_reduction (loop_vec_info loop_info, gimple phi, \n+                          bool check_reduction)\n {\n   struct loop *loop = (gimple_bb (phi))->loop_father;\n   struct loop *vect_loop = LOOP_VINFO_LOOP (loop_info);\n@@ -1524,7 +1544,10 @@ vect_is_simple_reduction (loop_vec_info loop_info, gimple phi)\n   imm_use_iterator imm_iter;\n   use_operand_p use_p;\n \n-  gcc_assert (loop == vect_loop || flow_loop_nested_p (vect_loop, loop));\n+  /* If CHECK_REDUCTION is true, we assume inner-most loop vectorization,\n+     otherwise, we assume outer loop vectorization.  */\n+  gcc_assert ((check_reduction && loop == vect_loop) \n+              || (!check_reduction && flow_loop_nested_p (vect_loop, loop)));\n \n   name = PHI_RESULT (phi);\n   nloop_uses = 0;\n@@ -1587,7 +1610,8 @@ vect_is_simple_reduction (loop_vec_info loop_info, gimple phi)\n \n   code = gimple_assign_rhs_code (def_stmt);\n \n-  if (!commutative_tree_code (code) || !associative_tree_code (code))\n+  if (check_reduction \n+      && (!commutative_tree_code (code) || !associative_tree_code (code)))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n         report_vect_op (def_stmt, \"reduction: not commutative/associative: \");\n@@ -1610,7 +1634,6 @@ vect_is_simple_reduction (loop_vec_info loop_info, gimple phi)\n       return NULL;\n     }\n \n-  /* Check that it's ok to change the order of the computation.  */\n   type = TREE_TYPE (gimple_assign_lhs (def_stmt));\n   if (TYPE_MAIN_VARIANT (type) != TYPE_MAIN_VARIANT (TREE_TYPE (op1))\n       || TYPE_MAIN_VARIANT (type) != TYPE_MAIN_VARIANT (TREE_TYPE (op2)))\n@@ -1627,7 +1650,8 @@ vect_is_simple_reduction (loop_vec_info loop_info, gimple phi)\n       return NULL;\n     }\n \n-  /* Generally, when vectorizing a reduction we change the order of the\n+  /* Check that it's ok to change the order of the computation.  \n+     Generally, when vectorizing a reduction we change the order of the\n      computation.  This may change the behavior of the program in some\n      cases, so we need to check that this is ok.  One exception is when \n      vectorizing an outer-loop: the inner-loop is executed sequentially,\n@@ -1636,22 +1660,22 @@ vect_is_simple_reduction (loop_vec_info loop_info, gimple phi)\n \n   /* CHECKME: check for !flag_finite_math_only too?  */\n   if (SCALAR_FLOAT_TYPE_P (type) && !flag_associative_math\n-      && !nested_in_vect_loop_p (vect_loop, def_stmt)) \n+      && check_reduction) \n     {\n       /* Changing the order of operations changes the semantics.  */\n       if (vect_print_dump_info (REPORT_DETAILS))\n \treport_vect_op (def_stmt, \"reduction: unsafe fp math optimization: \");\n       return NULL;\n     }\n   else if (INTEGRAL_TYPE_P (type) && TYPE_OVERFLOW_TRAPS (type)\n-\t   && !nested_in_vect_loop_p (vect_loop, def_stmt))\n+\t   && check_reduction)\n     {\n       /* Changing the order of operations changes the semantics.  */\n       if (vect_print_dump_info (REPORT_DETAILS))\n \treport_vect_op (def_stmt, \"reduction: unsafe int math optimization: \");\n       return NULL;\n     }\n-  else if (SAT_FIXED_POINT_TYPE_P (type))\n+  else if (SAT_FIXED_POINT_TYPE_P (type) && check_reduction)\n     {\n       /* Changing the order of operations changes the semantics.  */\n       if (vect_print_dump_info (REPORT_DETAILS))\n@@ -1660,10 +1684,10 @@ vect_is_simple_reduction (loop_vec_info loop_info, gimple phi)\n       return NULL;\n     }\n \n-  /* reduction is safe. we're dealing with one of the following:\n+  /* Reduction is safe. We're dealing with one of the following:\n      1) integer arithmetic and no trapv\n-     2) floating point arithmetic, and special flags permit this optimization.\n-   */\n+     2) floating point arithmetic, and special flags permit this optimization\n+     3) nested cycle (i.e., outer loop vectorization).  */\n   def1 = SSA_NAME_DEF_STMT (op1);\n   def2 = SSA_NAME_DEF_STMT (op2);\n   if (!def1 || !def2 || gimple_nop_p (def1) || gimple_nop_p (def2))\n@@ -1683,35 +1707,49 @@ vect_is_simple_reduction (loop_vec_info loop_info, gimple phi)\n       && (is_gimple_assign (def1)\n \t  || STMT_VINFO_DEF_TYPE (vinfo_for_stmt (def1)) == vect_induction_def\n \t  || (gimple_code (def1) == GIMPLE_PHI\n-\t      && STMT_VINFO_DEF_TYPE (vinfo_for_stmt (def1)) == vect_internal_def\n+\t      && STMT_VINFO_DEF_TYPE (vinfo_for_stmt (def1)) \n+                  == vect_internal_def\n \t      && !is_loop_header_bb_p (gimple_bb (def1)))))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n-\treport_vect_op (def_stmt, \"detected reduction:\");\n+\treport_vect_op (def_stmt, \"detected reduction: \");\n       return def_stmt;\n     }\n   else if (def1 == phi\n \t   && flow_bb_inside_loop_p (loop, gimple_bb (def2))\n \t   && (is_gimple_assign (def2)\n-\t       || STMT_VINFO_DEF_TYPE (vinfo_for_stmt (def2)) == vect_induction_def\n+\t       || STMT_VINFO_DEF_TYPE (vinfo_for_stmt (def2))\n+                    == vect_induction_def\n \t       || (gimple_code (def2) == GIMPLE_PHI\n-\t\t   && STMT_VINFO_DEF_TYPE (vinfo_for_stmt (def2)) == vect_internal_def\n+\t\t   && STMT_VINFO_DEF_TYPE (vinfo_for_stmt (def2)) \n+                    == vect_internal_def\n \t\t   && !is_loop_header_bb_p (gimple_bb (def2)))))\n     {\n-      /* Swap operands (just for simplicity - so that the rest of the code\n-\t can assume that the reduction variable is always the last (second)\n-\t argument).  */\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\treport_vect_op (def_stmt ,\n-\t\t        \"detected reduction: need to swap operands:\");\n-      swap_tree_operands (def_stmt, gimple_assign_rhs1_ptr (def_stmt),\n-\t\t\t  gimple_assign_rhs2_ptr (def_stmt));\n+      if (check_reduction)\n+        {\n+          /* Swap operands (just for simplicity - so that the rest of the code\n+\t     can assume that the reduction variable is always the last (second)\n+\t     argument).  */\n+          if (vect_print_dump_info (REPORT_DETAILS))\n+\t    report_vect_op (def_stmt,\n+\t  \t            \"detected reduction: need to swap operands: \");\n+\n+          swap_tree_operands (def_stmt, gimple_assign_rhs1_ptr (def_stmt),\n+ \t\t\t      gimple_assign_rhs2_ptr (def_stmt));\n+        }\n+      else\n+        {\n+          if (vect_print_dump_info (REPORT_DETAILS))\n+            report_vect_op (def_stmt, \"detected reduction: \");\n+        }\n+\n       return def_stmt;\n     }\n   else\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n-\treport_vect_op (def_stmt, \"reduction: unknown pattern.\");\n+\treport_vect_op (def_stmt, \"reduction: unknown pattern: \");\n+\n       return NULL;\n     }\n }\n@@ -2529,6 +2567,7 @@ get_initial_def_for_reduction (gimple stmt, tree init_val, tree *adjustment_def)\n   case WIDEN_SUM_EXPR:\n   case DOT_PROD_EXPR:\n   case PLUS_EXPR:\n+  case MINUS_EXPR:\n     if (nested_in_vect_loop)\n       *adjustment_def = vect_get_vec_def_for_operand (init_val, stmt, NULL);\n     else\n@@ -2572,6 +2611,8 @@ get_initial_def_for_reduction (gimple stmt, tree init_val, tree *adjustment_def)\n      in vectorizable_operation.\n    STMT is the scalar reduction stmt that is being vectorized.\n    REDUCTION_PHI is the phi-node that carries the reduction computation.\n+   REDUC_INDEX is the index of the operand in the right hand side of the \n+     statement that is defined by REDUCTION_PHI.\n \n    This function:\n    1. Creates the reduction def-use cycle: sets the arguments for \n@@ -2615,7 +2656,8 @@ static void\n vect_create_epilog_for_reduction (tree vect_def, gimple stmt,\n \t\t\t\t  int ncopies,\n \t\t\t\t  enum tree_code reduc_code,\n-\t\t\t\t  gimple reduction_phi)\n+\t\t\t\t  gimple reduction_phi,\n+                                  int reduc_index)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   stmt_vec_info prev_phi_info;\n@@ -2659,14 +2701,16 @@ vect_create_epilog_for_reduction (tree vect_def, gimple stmt,\n   switch (get_gimple_rhs_class (gimple_assign_rhs_code (stmt)))\n     {\n     case GIMPLE_SINGLE_RHS:\n-      gcc_assert (TREE_OPERAND_LENGTH (gimple_assign_rhs1 (stmt)) == ternary_op);\n-      reduction_op = TREE_OPERAND (gimple_assign_rhs1 (stmt), 2);\n+      gcc_assert (TREE_OPERAND_LENGTH (gimple_assign_rhs1 (stmt)) \n+                                       == ternary_op);\n+      reduction_op = TREE_OPERAND (gimple_assign_rhs1 (stmt), reduc_index);\n       break;\n     case GIMPLE_UNARY_RHS:\n       reduction_op = gimple_assign_rhs1 (stmt);\n       break;\n     case GIMPLE_BINARY_RHS:\n-      reduction_op = gimple_assign_rhs2 (stmt);\n+      reduction_op = reduc_index ? \n+                     gimple_assign_rhs2 (stmt) : gimple_assign_rhs1 (stmt);\n       break;\n     default:\n       gcc_unreachable ();\n@@ -2754,6 +2798,7 @@ vect_create_epilog_for_reduction (tree vect_def, gimple stmt,\n       SET_PHI_ARG_DEF (phi, single_exit (loop)->dest_idx, def);\n       prev_phi_info = vinfo_for_stmt (phi);\n     }\n+\n   exit_gsi = gsi_after_labels (exit_bb);\n \n   /* 2.2 Get the relevant tree-code to use in the epilog for schemes 2,3 \n@@ -2778,6 +2823,7 @@ vect_create_epilog_for_reduction (tree vect_def, gimple stmt,\n       gcc_assert (STMT_VINFO_IN_PATTERN_P (stmt_vinfo));\n       gcc_assert (STMT_VINFO_RELATED_STMT (stmt_vinfo) == stmt);\n     }\n+\n   code = gimple_assign_rhs_code (orig_stmt);\n   scalar_dest = gimple_assign_lhs (orig_stmt);\n   scalar_type = TREE_TYPE (scalar_dest);\n@@ -2970,6 +3016,11 @@ vect_create_epilog_for_reduction (tree vect_def, gimple stmt,\n     {\n       if (nested_in_vect_loop)\n \t{\n+          /* For MINUS_EXPR we create new_temp = loop_exit_def + adjustment_def\n+             since the initial value is [0,0,...,0].  */\n+          if (code == MINUS_EXPR)\n+            code = PLUS_EXPR;\n+\n \t  gcc_assert (TREE_CODE (TREE_TYPE (adjustment_def)) == VECTOR_TYPE);\n \t  expr = build2 (code, vectype, PHI_RESULT (new_phi), adjustment_def);\n \t  new_dest = vect_create_destination_var (scalar_dest, vectype);\n@@ -2980,6 +3031,7 @@ vect_create_epilog_for_reduction (tree vect_def, gimple stmt,\n \t  expr = build2 (code, scalar_type, new_temp, adjustment_def);\n \t  new_dest = vect_create_destination_var (scalar_dest, scalar_type);\n \t}\n+\n       epilog_stmt = gimple_build_assign (new_dest, expr);\n       new_temp = make_ssa_name (new_dest, epilog_stmt);\n       gimple_assign_set_lhs (epilog_stmt, new_temp);\n@@ -3043,7 +3095,7 @@ vect_create_epilog_for_reduction (tree vect_def, gimple stmt,\n \n    Check if STMT performs a reduction operation that can be vectorized.\n    If VEC_STMT is also passed, vectorize the STMT: create a vectorized\n-   stmt to replace it, put it in VEC_STMT, and insert it at BSI.\n+   stmt to replace it, put it in VEC_STMT, and insert it at GSI.\n    Return FALSE if not a vectorizable STMT, TRUE otherwise.\n \n    This function also handles reduction idioms (patterns) that have been \n@@ -3115,9 +3167,16 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n   gimple new_stmt = NULL;\n   int j;\n   tree ops[3];\n+  bool nested_cycle = false, found_nested_cycle_def = false;\n+  gimple reduc_def_stmt = NULL;\n+  /* The default is that the reduction variable is the last in statement.  */\n+  int reduc_index = 2;\n \n   if (nested_in_vect_loop_p (loop, stmt))\n-    loop = loop->inner;\n+    {\n+      loop = loop->inner;\n+      nested_cycle = true;\n+    }\n \n   gcc_assert (ncopies >= 1);\n \n@@ -3138,7 +3197,8 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n     return false;\n \n   /* Make sure it was already recognized as a reduction computation.  */\n-  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_reduction_def)\n+  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_reduction_def\n+      && STMT_VINFO_DEF_TYPE (stmt_info) != vect_nested_cycle)\n     return false;\n \n   /* 2. Has this been recognized as a reduction pattern? \n@@ -3202,7 +3262,9 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n     return false;\n \n   /* All uses but the last are expected to be defined in the loop.\n-     The last use is the reduction variable.  */\n+     The last use is the reduction variable. In case of nested cycle this \n+     assumption is not true: we use reduc_index to record the index of the\n+     reduction variable.  */\n   for (i = 0; i < op_type-1; i++)\n     {\n       is_simple_use = vect_is_simple_use (ops[i], loop_vinfo, NULL, &def_stmt,\n@@ -3211,21 +3273,39 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n       if (dt != vect_internal_def\n \t  && dt != vect_external_def\n \t  && dt != vect_constant_def\n-\t  && dt != vect_induction_def)\n+\t  && dt != vect_induction_def\n+          && dt != vect_nested_cycle)\n \treturn false;\n+\n+      if (dt == vect_nested_cycle)\n+        {\n+          found_nested_cycle_def = true;\n+          reduc_def_stmt = def_stmt;\n+          reduc_index = i;\n+        }\n     }\n \n   is_simple_use = vect_is_simple_use (ops[i], loop_vinfo, NULL, &def_stmt, \n                                       &def, &dt);\n   gcc_assert (is_simple_use);\n-  gcc_assert (dt == vect_reduction_def);\n-  gcc_assert (gimple_code (def_stmt) == GIMPLE_PHI);\n+  gcc_assert (dt == vect_reduction_def\n+              || dt == vect_nested_cycle\n+              || ((dt == vect_internal_def || dt == vect_external_def \n+                   || dt == vect_constant_def || dt == vect_induction_def)\n+                   && nested_cycle && found_nested_cycle_def)); \n+  if (!found_nested_cycle_def)\n+    reduc_def_stmt = def_stmt;\n+\n+  gcc_assert (gimple_code (reduc_def_stmt) == GIMPLE_PHI);\n   if (orig_stmt) \n-    gcc_assert (orig_stmt == vect_is_simple_reduction (loop_vinfo, def_stmt));\n+    gcc_assert (orig_stmt == vect_is_simple_reduction (loop_vinfo, \n+                                                       reduc_def_stmt, \n+                                                       !nested_cycle));\n   else\n-    gcc_assert (stmt == vect_is_simple_reduction (loop_vinfo, def_stmt));\n+    gcc_assert (stmt == vect_is_simple_reduction (loop_vinfo, reduc_def_stmt, \n+                                                  !nested_cycle));\n   \n-  if (STMT_VINFO_LIVE_P (vinfo_for_stmt (def_stmt)))\n+  if (STMT_VINFO_LIVE_P (vinfo_for_stmt (reduc_def_stmt)))\n     return false;\n \n   /* 4. Supportable by target?  */\n@@ -3320,8 +3400,12 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n       orig_code = code;\n     }\n \n-  if (!reduction_code_for_scalar_code (orig_code, &epilog_reduc_code))\n-    return false;\n+  if (nested_cycle)\n+    epilog_reduc_code = orig_code;\n+  else\n+    if (!reduction_code_for_scalar_code (orig_code, &epilog_reduc_code))\n+      return false;\n+\n   reduc_optab = optab_for_tree_code (epilog_reduc_code, vectype, optab_default);\n   if (!reduc_optab)\n     {\n@@ -3402,13 +3486,20 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n       /* Handle uses.  */\n       if (j == 0)\n         {\n-\t  loop_vec_def0 = vect_get_vec_def_for_operand (ops[0], stmt, NULL);\n+\t  loop_vec_def0 = vect_get_vec_def_for_operand (ops[!reduc_index], \n+                                                        stmt, NULL);\n           if (op_type == ternary_op)\n             {\n-\t      loop_vec_def1 = vect_get_vec_def_for_operand (ops[1], stmt, NULL);\n+              if (reduc_index == 0)\n+ \t        loop_vec_def1 = vect_get_vec_def_for_operand (ops[2], stmt, \n+                                                              NULL);\n+              else\n+                loop_vec_def1 = vect_get_vec_def_for_operand (ops[1], stmt, \n+                                                              NULL);\n             }\n \n-          /* Get the vector def for the reduction variable from the phi node */\n+          /* Get the vector def for the reduction variable from the phi \n+             node.  */\n           reduc_def = PHI_RESULT (new_phi);\n \t  first_phi = new_phi;\n         }\n@@ -3427,12 +3518,31 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n \t  STMT_VINFO_RELATED_STMT (prev_phi_info) = new_phi;\n         }\n \n+      \n       /* Arguments are ready. create the new vector stmt.  */\n       if (op_type == binary_op)\n-        expr = build2 (code, vectype, loop_vec_def0, reduc_def);\n+        {\n+          if (reduc_index == 0)\n+            expr = build2 (code, vectype, reduc_def, loop_vec_def0);\n+          else\n+            expr = build2 (code, vectype, loop_vec_def0, reduc_def);\n+        }\n       else\n-        expr = build3 (code, vectype, loop_vec_def0, loop_vec_def1, \n-\t\t       reduc_def);\n+        {\n+          if (reduc_index == 0)\n+            expr = build3 (code, vectype, reduc_def, loop_vec_def0, \n+                           loop_vec_def1);\n+          else \n+            {\n+              if (reduc_index == 1)\n+                expr = build3 (code, vectype, loop_vec_def0, reduc_def, \n+                               loop_vec_def1);\n+              else\n+                expr = build3 (code, vectype, loop_vec_def0, loop_vec_def1, \n+\t     \t               reduc_def);\n+            }\n+        }\n+\n       new_stmt = gimple_build_assign (vec_dest, expr);\n       new_temp = make_ssa_name (vec_dest, new_stmt);\n       gimple_assign_set_lhs (new_stmt, new_temp);\n@@ -3451,7 +3561,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n   if (!single_defuse_cycle)\n     new_temp = gimple_assign_lhs (*vec_stmt);\n   vect_create_epilog_for_reduction (new_temp, stmt, epilog_copies,\n-\t\t\t\t    epilog_reduc_code, first_phi);\n+\t\t\t\t    epilog_reduc_code, first_phi, reduc_index);\n   return true;\n }\n "}, {"sha": "1971e6ad4d3a0ece2e6035cc68f84521932a7b14", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c5222ff1a2283b0f8c889da777c7dae5d4224ba/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c5222ff1a2283b0f8c889da777c7dae5d4224ba/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=7c5222ff1a2283b0f8c889da777c7dae5d4224ba", "patch": "@@ -319,12 +319,7 @@ vect_recog_dot_prod_pattern (gimple last_stmt, tree *type_in, tree *type_out)\n \n   /* We don't allow changing the order of the computation in the inner-loop\n      when doing outer-loop vectorization.  */\n-  if (nested_in_vect_loop_p (loop, last_stmt))\n-    {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"vect_recog_dot_prod_pattern: not allowed.\");\n-      return NULL;\n-    }\n+  gcc_assert (!nested_in_vect_loop_p (loop, last_stmt));\n \n   return pattern_stmt;\n }\n@@ -638,12 +633,7 @@ vect_recog_widen_sum_pattern (gimple last_stmt, tree *type_in, tree *type_out)\n \n   /* We don't allow changing the order of the computation in the inner-loop\n      when doing outer-loop vectorization.  */\n-  if (nested_in_vect_loop_p (loop, last_stmt))\n-    {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"vect_recog_widen_sum_pattern: not allowed.\");\n-      return NULL;\n-    }\n+  gcc_assert (!nested_in_vect_loop_p (loop, last_stmt));\n \n   return pattern_stmt;\n }"}, {"sha": "586e906b1dea36339b4299bed3231c135b6a00f2", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 34, "deletions": 29, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c5222ff1a2283b0f8c889da777c7dae5d4224ba/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c5222ff1a2283b0f8c889da777c7dae5d4224ba/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=7c5222ff1a2283b0f8c889da777c7dae5d4224ba", "patch": "@@ -300,19 +300,24 @@ process_use (gimple stmt, tree use, loop_vec_info loop_vinfo, bool live_p,\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"outer-loop def-stmt defining inner-loop stmt.\");\n+\n       switch (relevant)\n \t{\n \tcase vect_unused_in_scope:\n-\t  relevant = (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_reduction_def) ?\n-\t\t\tvect_used_by_reduction : vect_unused_in_scope;\n+\t  relevant = (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_nested_cycle) ?\n+\t\t      vect_used_in_scope : vect_unused_in_scope;\n \t  break;\n+\n \tcase vect_used_in_outer_by_reduction:\n+          gcc_assert (STMT_VINFO_DEF_TYPE (stmt_vinfo) != vect_reduction_def);\n \t  relevant = vect_used_by_reduction;\n \t  break;\n+\n \tcase vect_used_in_outer:\n+          gcc_assert (STMT_VINFO_DEF_TYPE (stmt_vinfo) != vect_reduction_def);\n \t  relevant = vect_used_in_scope;\n \t  break;\n-\tcase vect_used_by_reduction: \n+\n \tcase vect_used_in_scope:\n \t  break;\n \n@@ -332,17 +337,14 @@ process_use (gimple stmt, tree use, loop_vec_info loop_vinfo, bool live_p,\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"inner-loop def-stmt defining outer-loop stmt.\");\n+\n       switch (relevant)\n         {\n         case vect_unused_in_scope:\n           relevant = (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_reduction_def) ?\n                       vect_used_in_outer_by_reduction : vect_unused_in_scope;\n           break;\n \n-        case vect_used_in_outer_by_reduction:\n-        case vect_used_in_outer:\n-          break;\n-\n         case vect_used_by_reduction:\n           relevant = vect_used_in_outer_by_reduction;\n           break;\n@@ -461,19 +463,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t those that are used by a reduction computation, and those that are \n \t (also) used by a regular computation. This allows us later on to \n \t identify stmts that are used solely by a reduction, and therefore the \n-\t order of the results that they produce does not have to be kept.\n-\n-\t Reduction phis are expected to be used by a reduction stmt, or by\n-\t in an outer loop;  Other reduction stmts are expected to be\n-\t in the loop, and possibly used by a stmt in an outer loop. \n-\t Here are the expected values of \"relevant\" for reduction phis/stmts:\n-\n-\t relevance:\t\t\t\tphi\tstmt\n-\t vect_unused_in_scope\t\t\t\tok\n-\t vect_used_in_outer_by_reduction\tok\tok\n-\t vect_used_in_outer\t\t\tok\tok\n-\t vect_used_by_reduction\t\t\tok\n-\t vect_used_in_scope\t\t\t\t              */\n+\t order of the results that they produce does not have to be kept.  */\n \n       if (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_reduction_def)\n         {\n@@ -485,28 +475,41 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t      relevant = vect_used_by_reduction;\n \t      break;\n \n-\t    case vect_used_in_outer_by_reduction:\n-\t    case vect_used_in_outer:\n-\t      gcc_assert (gimple_code (stmt) != GIMPLE_ASSIGN\n-                          || (gimple_assign_rhs_code (stmt) != WIDEN_SUM_EXPR\n-                              && (gimple_assign_rhs_code (stmt)\n-                                  != DOT_PROD_EXPR)));\n-\t      break;\n-\n \t    case vect_used_by_reduction:\n \t      if (gimple_code (stmt) == GIMPLE_PHI)\n \t\tbreak;\n \t      /* fall through */\n-\t    case vect_used_in_scope:\n+\n \t    default:\n \t      if (vect_print_dump_info (REPORT_DETAILS))\n \t        fprintf (vect_dump, \"unsupported use of reduction.\");\n \t      VEC_free (gimple, heap, worklist);\n \t      return false;\n \t    }\n+\n \t  live_p = false;\t\n \t}\n+      else if (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_nested_cycle)\n+        {\n+          enum vect_relevant tmp_relevant = relevant;\n+          switch (tmp_relevant)\n+            {\n+              case vect_unused_in_scope:\n+              case vect_used_in_outer_by_reduction:\n+              case vect_used_in_outer:\n+                break;\n \n+              default:\n+                if (vect_print_dump_info (REPORT_DETAILS))\n+                  fprintf (vect_dump, \"unsupported use of nested cycle.\");\n+\n+                VEC_free (gimple, heap, worklist);\n+                return false;\n+            }\n+\n+          live_p = false; \n+        }\n+ \n       FOR_EACH_PHI_OR_STMT_USE (use_p, stmt, iter, SSA_OP_USE)\n \t{\n \t  tree op = USE_FROM_PTR (use_p);\n@@ -971,6 +974,7 @@ vect_get_vec_def_for_operand (tree op, gimple stmt, tree *scalar_def)\n \n     /* Case 4: operand is defined by a loop header phi - reduction  */\n     case vect_reduction_def:\n+    case vect_nested_cycle:\n       {\n \tstruct loop *loop;\n \n@@ -3929,6 +3933,7 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n         break;\n \n       case vect_reduction_def:\n+      case vect_nested_cycle:\n          gcc_assert (!bb_vinfo && (relevance == vect_used_in_outer\n                      || relevance == vect_used_in_outer_by_reduction\n                      || relevance == vect_unused_in_scope));"}, {"sha": "6e8f879caf30772bc77a3dba59c8e7c71bb7adcb", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c5222ff1a2283b0f8c889da777c7dae5d4224ba/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c5222ff1a2283b0f8c889da777c7dae5d4224ba/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=7c5222ff1a2283b0f8c889da777c7dae5d4224ba", "patch": "@@ -61,6 +61,7 @@ enum vect_def_type {\n   vect_internal_def,\n   vect_induction_def,\n   vect_reduction_def,\n+  vect_nested_cycle,\n   vect_unknown_def_type\n };\n \n@@ -339,7 +340,11 @@ enum stmt_vec_info_type {\n    block.  */\n enum vect_relevant {\n   vect_unused_in_scope = 0,\n+  /* The def is in the inner loop, and the use is in the outer loop, and the\n+     use is a reduction stmt.  */\n   vect_used_in_outer_by_reduction,\n+  /* The def is in the inner loop, and the use is in the outer loop (and is\n+     not part of reduction).  */\n   vect_used_in_outer,\n \n   /* defs that feed computations that end up (only) in a reduction. These\n@@ -817,7 +822,7 @@ extern tree vect_create_addr_base_for_vector_ref (gimple, gimple_seq *,\n /* In tree-vect-loop.c.  */\n /* FORNOW: Used in tree-parloops.c.  */\n extern void destroy_loop_vec_info (loop_vec_info, bool);\n-extern gimple vect_is_simple_reduction (loop_vec_info, gimple);\n+extern gimple vect_is_simple_reduction (loop_vec_info, gimple, bool);\n /* Drive for loop analysis stage.  */\n extern loop_vec_info vect_analyze_loop (struct loop *);\n /* Drive for loop transformation stage.  */"}]}