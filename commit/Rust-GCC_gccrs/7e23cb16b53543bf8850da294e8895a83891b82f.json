{"sha": "7e23cb16b53543bf8850da294e8895a83891b82f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2UyM2NiMTZiNTM1NDNiZjg4NTBkYTI5NGU4ODk1YTgzODkxYjgyZg==", "commit": {"author": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-10-11T02:04:13Z"}, "committer": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-10-11T02:04:13Z"}, "message": "abi64 support\n\nFrom-SVN: r12949", "tree": {"sha": "97e0fb4c892fd98d95438fad69fa8b2ff61c6c0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97e0fb4c892fd98d95438fad69fa8b2ff61c6c0d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e23cb16b53543bf8850da294e8895a83891b82f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e23cb16b53543bf8850da294e8895a83891b82f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e23cb16b53543bf8850da294e8895a83891b82f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e23cb16b53543bf8850da294e8895a83891b82f/comments", "author": null, "committer": null, "parents": [{"sha": "82280d5eeaaadd317ee8989c71c36760948a242d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82280d5eeaaadd317ee8989c71c36760948a242d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82280d5eeaaadd317ee8989c71c36760948a242d"}], "stats": {"total": 310, "additions": 239, "deletions": 71}, "files": [{"sha": "5959d946cd5a60401d32c232116efdf1169461f2", "filename": "gcc/config/mips/iris6.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e23cb16b53543bf8850da294e8895a83891b82f/gcc%2Fconfig%2Fmips%2Firis6.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e23cb16b53543bf8850da294e8895a83891b82f/gcc%2Fconfig%2Fmips%2Firis6.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Firis6.h?ref=7e23cb16b53543bf8850da294e8895a83891b82f", "patch": "@@ -102,6 +102,11 @@ Boston, MA 02111-1307, USA.  */\n #undef PREFERRED_DEBUGGING_TYPE\n #define PREFERRED_DEBUGGING_TYPE DWARF_DEBUG\n \n+/* The size in bytes of a DWARF field indicating an offset or length\n+   relative to a debug info section, specified to be 4 bytes in the DWARF-2\n+   specification.  The SGI/MIPS ABI defines it to be the same as PTR_SIZE.  */\n+#define DWARF_OFFSET_SIZE PTR_SIZE\n+\n #undef MACHINE_TYPE\n #define MACHINE_TYPE \"SGI running IRIX 6.x\"\n \n@@ -322,6 +327,21 @@ dtors_section ()\t\t\t\t\t\t\t\\\n \n #endif\n \n+/* A C statement to output something to the assembler file to switch to section\n+   NAME for object DECL which is either a FUNCTION_DECL, a VAR_DECL or\n+   NULL_TREE.  */\n+\n+#define ASM_OUTPUT_SECTION_NAME(F, DECL, NAME)\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  extern FILE *asm_out_text_file;\t\t\t\t\t\\\n+  if ((DECL) && TREE_CODE (DECL) == FUNCTION_DECL)\t\t\t\\\n+    fprintf (asm_out_text_file, \"\\t.section %s,1,6,4,4\\n\", (NAME));\t\\\n+  else if ((DECL) && TREE_READONLY (DECL))\t\t\t\t\\\n+    fprintf (F, \"\\t.section %s,1,2,0,8\\n\", (NAME));\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    fprintf (F, \"\\t.section %s,1,3,0,8\\n\", (NAME));\t\t\t\\\n+} while (0)\n+\n /* Stuff for constructors.  End here.  */\n \n /* ??? Perhaps just include svr4.h in this file?  */"}, {"sha": "0f6138f865257bae6886c9531a1fa24bdc5629c8", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 219, "deletions": 71, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e23cb16b53543bf8850da294e8895a83891b82f/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e23cb16b53543bf8850da294e8895a83891b82f/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=7e23cb16b53543bf8850da294e8895a83891b82f", "patch": "@@ -312,31 +312,43 @@ extern char *language_string;\n #define PTR_SIZE (POINTER_SIZE / 8)\n #endif\n \n+/* The size in bytes of a DWARF field indicating an offset or length\n+   relative to a debug info section, specified to be 4 bytes in the DWARF-2\n+   specification.  The SGI/MIPS ABI defines it to be the same as PTR_SIZE.  */\n+#ifndef DWARF_OFFSET_SIZE\n+#define DWARF_OFFSET_SIZE 4\n+#endif\n+\n /* Fixed size portion of the DWARF compilation unit header.  */\n-#define DWARF_COMPILE_UNIT_HEADER_SIZE 11\n+#define DWARF_COMPILE_UNIT_HEADER_SIZE (2 * DWARF_OFFSET_SIZE + 3)\n \n /* Fixed size portion of debugging line information prolog.  */\n #define DWARF_LINE_PROLOG_HEADER_SIZE 5\n \n /* Fixed size portion of public names info.  */\n-#define DWARF_PUBNAMES_HEADER_SIZE 10\n+#define DWARF_PUBNAMES_HEADER_SIZE (2 * DWARF_OFFSET_SIZE + 2)\n+\n+/* Round SIZE up to the nearest BOUNDARY.  */\n+#define DWARF_ROUND(SIZE,BOUNDARY) \\\n+  (((SIZE) + (BOUNDARY) - 1) & ~((BOUNDARY) - 1))\n \n /* Fixed size portion of the address range info.  */\n-#define DWARF_ARANGES_HEADER_SIZE 12\n+#define DWARF_ARANGES_HEADER_SIZE \\\n+  (DWARF_ROUND (2 * DWARF_OFFSET_SIZE + 4, PTR_SIZE * 2) - DWARF_OFFSET_SIZE)\n \n /* Fixed size portion of the Common Information Entry (including\n    the length field).  */\n-#define DWARF_CIE_HEADER_SIZE 16\n+#define DWARF_CIE_HEADER_SIZE (2 * DWARF_OFFSET_SIZE + 8)\n \n /* Fixed size of the Common Information Entry in the call frame\n-   information (.debug_frame) section rounded up to an 8 byte boundary.  */\n-#define DWARF_CIE_SIZE ((DWARF_CIE_HEADER_SIZE + 7) & ~7)\n+   information (.debug_frame) section rounded up to a word boundary.  */\n+#define DWARF_CIE_SIZE DWARF_ROUND (DWARF_CIE_HEADER_SIZE, PTR_SIZE)\n \n /* Offsets recorded in opcodes are a multiple of this alignment factor.  */\n #define DWARF_CIE_DATA_ALIGNMENT -4\n \n /* Fixed size portion of the FDE.  */\n-#define DWARF_FDE_HEADER_SIZE (4 + 4 + (2 * PTR_SIZE))\n+#define DWARF_FDE_HEADER_SIZE (2 * DWARF_OFFSET_SIZE + 2 * PTR_SIZE)\n \n /* Define the architecture-dependent minimum instruction length (in bytes).\n    In this implementation of DWARF, this field is used for information\n@@ -556,6 +568,10 @@ static unsigned current_funcdef_fde;\n    attribute can be set properly in gen_subprogram_die.  */\n static long int current_funcdef_frame_size = 0;\n \n+/* Record whether the function being analyzed contains inlined functions.  */\n+static int current_function_has_inlines;\n+static int comp_unit_has_inlines;\n+\n /* DWARF requires that the compiler's primary datatypes\n    are mapped into a reference to a DIE that defines that\n    primary (base) type.  The base_type_info structure is used\n@@ -620,7 +636,7 @@ static void add_type_attribute ();\n static void decls_for_scope ();\n static void gen_decl_die ();\n static unsigned lookup_filename ();\n-\n+static int constant_size PROTO((long unsigned));\n \n /* Definitions of defaults for assembler-dependent names of various\n    pseudo-ops and section names.\n@@ -632,10 +648,27 @@ static unsigned lookup_filename ();\n #ifndef UNALIGNED_INT_ASM_OP\n #define UNALIGNED_INT_ASM_OP\t\".4byte\"\n #endif\n+#ifndef UNALIGNED_DOUBLE_INT_ASM_OP\n+#define UNALIGNED_DOUBLE_INT_ASM_OP\t\".8byte\"\n+#endif\n #ifndef ASM_BYTE_OP\n #define ASM_BYTE_OP\t\t\".byte\"\n #endif\n \n+#ifndef UNALIGNED_OFFSET_ASM_OP\n+#define UNALIGNED_OFFSET_ASM_OP \\\n+  (DWARF_OFFSET_SIZE == 8 ? UNALIGNED_DOUBLE_INT_ASM_OP : UNALIGNED_INT_ASM_OP)\n+#endif\n+\n+#ifndef UNALIGNED_WORD_ASM_OP\n+#define UNALIGNED_WORD_ASM_OP \\\n+  (PTR_SIZE == 8 ? UNALIGNED_DOUBLE_INT_ASM_OP : UNALIGNED_INT_ASM_OP)\n+#endif\n+\n+/* Data and reference forms for relocatable data.  */\n+#define DW_FORM_data (DWARF_OFFSET_SIZE == 8 ? DW_FORM_data8 : DW_FORM_data4)\n+#define DW_FORM_ref (DWARF_OFFSET_SIZE == 8 ? DW_FORM_ref8 : DW_FORM_ref4)\n+\n /* Pseudo-op for defining a new section.  */\n #ifndef SECTION_ASM_OP\n #define SECTION_ASM_OP\t\".section\"\n@@ -798,16 +831,41 @@ static unsigned lookup_filename ();\n   } while (0)\n #endif\n \n+#ifndef ASM_OUTPUT_DWARF_DELTA\n+#define ASM_OUTPUT_DWARF_DELTA(FILE,LABEL1,LABEL2)\t\t\t\\\n+ do {\tfprintf ((FILE), \"\\t%s\\t\", UNALIGNED_OFFSET_ASM_OP);\t\t\\\n+\tassemble_name (FILE, LABEL1);\t\t\t\t\t\\\n+\tfprintf (FILE, \"-\");\t\t\t\t\t\t\\\n+\tassemble_name (FILE, LABEL2);\t\t\t\t\t\\\n+  } while (0)\n+#endif\n+\n+#ifndef ASM_OUTPUT_DWARF_ADDR_DELTA\n+#define ASM_OUTPUT_DWARF_ADDR_DELTA(FILE,LABEL1,LABEL2)\t\t\t\\\n+ do {\tfprintf ((FILE), \"\\t%s\\t\", UNALIGNED_WORD_ASM_OP);\t\t\\\n+\tassemble_name (FILE, LABEL1);\t\t\t\t\t\\\n+\tfprintf (FILE, \"-\");\t\t\t\t\t\t\\\n+\tassemble_name (FILE, LABEL2);\t\t\t\t\t\\\n+  } while (0)\n+#endif\n+\n #ifndef ASM_OUTPUT_DWARF_ADDR\n #define ASM_OUTPUT_DWARF_ADDR(FILE,LABEL)\t\t\t\t\\\n- do {\tfprintf ((FILE), \"\\t%s\\t\", UNALIGNED_INT_ASM_OP);\t\t\\\n+ do {\tfprintf ((FILE), \"\\t%s\\t\", UNALIGNED_WORD_ASM_OP);\t\t\\\n \tassemble_name (FILE, LABEL);\t\t\t\t\t\\\n   } while (0)\n #endif\n \n #ifndef ASM_OUTPUT_DWARF_ADDR_CONST\n #define ASM_OUTPUT_DWARF_ADDR_CONST(FILE,ADDR)\t\t\t\t\\\n-    fprintf ((FILE), \"\\t%s\\t%s\", UNALIGNED_INT_ASM_OP, (ADDR))\n+  fprintf ((FILE), \"\\t%s\\t%s\", UNALIGNED_WORD_ASM_OP, (ADDR))\n+#endif\n+\n+#ifndef ASM_OUTPUT_DWARF_OFFSET\n+#define ASM_OUTPUT_DWARF_OFFSET(FILE,LABEL)\t\t\t\t\\\n+ do {\tfprintf ((FILE), \"\\t%s\\t\", UNALIGNED_OFFSET_ASM_OP);\t\t\\\n+\tassemble_name (FILE, LABEL);\t\t\t\t\t\\\n+  } while (0)\n #endif\n \n #ifndef ASM_OUTPUT_DWARF_DATA1\n@@ -825,6 +883,18 @@ static unsigned lookup_filename ();\n   fprintf ((FILE), \"\\t%s\\t0x%x\", UNALIGNED_INT_ASM_OP, (unsigned) VALUE)\n #endif\n \n+#ifndef ASM_OUTPUT_DWARF_DATA\n+#define ASM_OUTPUT_DWARF_DATA(FILE,VALUE) \\\n+  fprintf ((FILE), \"\\t%s\\t0x%lx\", UNALIGNED_OFFSET_ASM_OP, \\\n+\t   (unsigned long) VALUE)\n+#endif\n+\n+#ifndef ASM_OUTPUT_DWARF_ADDR_DATA\n+#define ASM_OUTPUT_DWARF_ADDR_DATA(FILE,VALUE) \\\n+  fprintf ((FILE), \"\\t%s\\t0x%lx\", UNALIGNED_WORD_ASM_OP, \\\n+\t   (unsigned long) VALUE)\n+#endif\n+\n #ifndef ASM_OUTPUT_DWARF_DATA8\n #define ASM_OUTPUT_DWARF_DATA8(FILE,HIGH_VALUE,LOW_VALUE)\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n@@ -1363,7 +1433,6 @@ dwarf_attr_name (attr)\n     case DW_AT_vtable_elem_location:\n       return \"DW_AT_vtable_elem_location\";\n \n-#ifdef MIPS_DEBUGGING_INFO\n     case DW_AT_MIPS_fde:\n       return \"DW_AT_MIPS_fde\";\n     case DW_AT_MIPS_loop_begin:\n@@ -1378,7 +1447,14 @@ dwarf_attr_name (attr)\n       return \"DW_AT_MIPS_software_pipeline_depth\";\n     case DW_AT_MIPS_linkage_name:\n       return \"DW_AT_MIPS_linkage_name\";\n-#endif\n+    case DW_AT_MIPS_stride:\n+      return \"DW_AT_MIPS_stride\";\n+    case DW_AT_MIPS_abstract_name:\n+      return \"DW_AT_MIPS_abstract_name\";\n+    case DW_AT_MIPS_clone_origin:\n+      return \"DW_AT_MIPS_clone_origin\";\n+    case DW_AT_MIPS_has_inlines:\n+      return \"DW_AT_MIPS_has_inlines\";\n \n     case DW_AT_sf_names:\n       return \"DW_AT_sf_names\";\n@@ -2169,7 +2245,7 @@ get_AT (die, attr_kind)\n      register enum dwarf_attribute attr_kind;\n {\n   register dw_attr_ref a;\n-  register dw_die_ref spec;\n+  register dw_die_ref spec = NULL;\n   \n   if (die != NULL)\n     {\n@@ -2700,7 +2776,13 @@ build_abbrev_table (die)\n \t\t{\n \t\t  if ((a_attr->dw_attr != d_attr->dw_attr)\n \t\t      || (a_attr->dw_attr_val.val_class\n-\t\t\t  != d_attr->dw_attr_val.val_class))\n+\t\t\t  != d_attr->dw_attr_val.val_class)\n+\t\t      || (a_attr->dw_attr_val.val_class\n+\t\t\t  == dw_val_class_unsigned_const\n+\t\t\t  && (constant_size (a_attr->dw_attr_val\n+\t\t\t\t\t     .v.val_unsigned)\n+\t\t\t      != constant_size (d_attr->dw_attr_val\n+\t\t\t\t\t\t.v.val_unsigned))))\n \t\t    {\n \t\t      break;\n \t\t    }\n@@ -2897,6 +2979,24 @@ size_of_loc_descr (loc)\n   return size;\n }\n \n+/* Return the power-of-two number of bytes necessary to represent VALUE.  */\n+static int\n+constant_size (value)\n+     long unsigned value;\n+{\n+  int log;\n+\n+  if (value == 0)\n+    log = 0;\n+  else\n+    log = floor_log2 (value);\n+\n+  log = log / 8;\n+  log = 1 << (floor_log2 (log) + 1);\n+\n+  return log;\n+}\n+\n /* Return the size of a DIE, as it is represented in the\n    .debug_info section.  */\n static unsigned long\n@@ -2912,7 +3012,7 @@ size_of_die (die)\n       switch (a->dw_attr_val.val_class)\n \t{\n \tcase dw_val_class_addr:\n-\t  size += 4;\n+\t  size += PTR_SIZE;\n \t  break;\n \tcase dw_val_class_loc:\n \t  /* Block length.  */\n@@ -2927,7 +3027,7 @@ size_of_die (die)\n \t  size += 4;\n \t  break;\n \tcase dw_val_class_unsigned_const:\n-\t  size += 4;\n+\t  size += constant_size (a->dw_attr_val.v.val_unsigned);\n \t  break;\n \tcase dw_val_class_double_const:\n \t  size += 8;\n@@ -2936,16 +3036,16 @@ size_of_die (die)\n \t  size += 1;\n \t  break;\n \tcase dw_val_class_die_ref:\n-\t  size += 4;\n+\t  size += DWARF_OFFSET_SIZE;\n \t  break;\n \tcase dw_val_class_fde_ref:\n-\t  size += 4;\n+\t  size += DWARF_OFFSET_SIZE;\n \t  break;\n \tcase dw_val_class_lbl_id:\n-\t  size += 4;\n+\t  size += PTR_SIZE;\n \t  break;\n \tcase dw_val_class_section_offset:\n-\t  size += 4;\n+\t  size += DWARF_OFFSET_SIZE;\n \t  break;\n \tcase dw_val_class_str:\n \t  size += size_of_string (a->dw_attr_val.v.val_str);\n@@ -3028,7 +3128,7 @@ size_of_line_info ()\n   /* Version number.  */\n   size = 2;\n   /* Prolog length specifier.  */\n-  size += 4;\n+  size += DWARF_OFFSET_SIZE;\n   /* Prolog.  */\n   size += size_of_line_prolog ();\n   /* Set address register instruction.  */\n@@ -3147,9 +3247,9 @@ size_of_pubnames ()\n   for (i = 0; i < pubname_table_in_use; ++i)\n     {\n       register pubname_ref p = &pubname_table[i];\n-      size += 4 + size_of_string (p->name);\n+      size += DWARF_OFFSET_SIZE + size_of_string (p->name);\n     }\n-  size += 4;\n+  size += DWARF_OFFSET_SIZE;\n   return size;\n }\n \n@@ -3160,10 +3260,10 @@ size_of_aranges ()\n   register unsigned long size;\n   size = DWARF_ARANGES_HEADER_SIZE;\n   /* Count the address/length pair for this compilation unit.  */\n-  size += 8;\n-  size += 8 * arange_table_in_use;\n+  size += 2 * PTR_SIZE;\n+  size += 2 * PTR_SIZE * arange_table_in_use;\n   /* Count the two zero words used to terminated the address range table.  */\n-  size += 8;\n+  size += 2 * PTR_SIZE;\n   return size;\n }\n \f\n@@ -3239,7 +3339,20 @@ output_value_format (v)\n       form = DW_FORM_data4;\n       break;\n     case dw_val_class_unsigned_const:\n-      form = DW_FORM_data4;\n+      switch (constant_size (v->v.val_unsigned))\n+\t{\n+\tcase 1:\n+\t  form = DW_FORM_data1;\n+\t  break;\n+\tcase 2:\n+\t  form = DW_FORM_data2;\n+\t  break;\n+\tcase 4:\n+\t  form = DW_FORM_data4;\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n       break;\n     case dw_val_class_double_const:\n       form = DW_FORM_data8;\n@@ -3248,16 +3361,16 @@ output_value_format (v)\n       form = DW_FORM_flag;\n       break;\n     case dw_val_class_die_ref:\n-      form = DW_FORM_ref4;\n+      form = DW_FORM_ref;\n       break;\n     case dw_val_class_fde_ref:\n-      form = DW_FORM_data4;\n+      form = DW_FORM_data;\n       break;\n     case dw_val_class_lbl_id:\n       form = DW_FORM_addr;\n       break;\n     case dw_val_class_section_offset:\n-      form = DW_FORM_data4;\n+      form = DW_FORM_data;\n       break;\n     case dw_val_class_str:\n       form = DW_FORM_string;\n@@ -3525,7 +3638,23 @@ output_die (die)\n \t  ASM_OUTPUT_DWARF_DATA4 (asm_out_file, a->dw_attr_val.v.val_int);\n \t  break;\n \tcase dw_val_class_unsigned_const:\n-\t  ASM_OUTPUT_DWARF_DATA4 (asm_out_file, a->dw_attr_val.v.val_unsigned);\n+\t  switch (constant_size (a->dw_attr_val.v.val_unsigned))\n+\t    {\n+\t    case 1:\n+\t      ASM_OUTPUT_DWARF_DATA1\n+\t\t(asm_out_file, a->dw_attr_val.v.val_unsigned);\n+\t      break;\n+\t    case 2:\n+\t      ASM_OUTPUT_DWARF_DATA2\n+\t\t(asm_out_file, a->dw_attr_val.v.val_unsigned);\n+\t      break;\n+\t    case 4:\n+\t      ASM_OUTPUT_DWARF_DATA4\n+\t\t(asm_out_file, a->dw_attr_val.v.val_unsigned);\n+\t      break;\n+\t    default:\n+\t      abort ();\n+\t    }\n \t  break;\n \tcase dw_val_class_double_const:\n \t  ASM_OUTPUT_DWARF_DATA8 (asm_out_file,\n@@ -3548,19 +3677,19 @@ output_die (die)\n \t    {\n \t      abort ();\n \t    }\n-\t  ASM_OUTPUT_DWARF_DATA4 (asm_out_file, ref_offset);\n+\t  ASM_OUTPUT_DWARF_DATA (asm_out_file, ref_offset);\n \t  break;\n \tcase dw_val_class_fde_ref:\n \t  ref_offset = fde_table[a->dw_attr_val.v.val_fde_index].dw_fde_offset;\n-\t  fprintf (asm_out_file, \"\\t%s\\t%s+0x%x\", UNALIGNED_INT_ASM_OP,\n+\t  fprintf (asm_out_file, \"\\t%s\\t%s+0x%x\", UNALIGNED_OFFSET_ASM_OP,\n \t\t   stripattributes (FRAME_SECTION), ref_offset);\n \t  break;\n \tcase dw_val_class_lbl_id:\n \t  ASM_OUTPUT_DWARF_ADDR (asm_out_file, a->dw_attr_val.v.val_lbl_id);\n \t  break;\n \tcase dw_val_class_section_offset:\n-\t  ASM_OUTPUT_DWARF_ADDR (asm_out_file,\n-\t\t\t\t stripattributes (a->dw_attr_val.v.val_section));\n+\t  ASM_OUTPUT_DWARF_OFFSET\n+\t    (asm_out_file, stripattributes (a->dw_attr_val.v.val_section));\n \t  break;\n \tcase dw_val_class_str:\n \t  ASM_OUTPUT_DWARF_STRING (asm_out_file, a->dw_attr_val.v.val_str);\n@@ -3595,32 +3724,28 @@ output_die (die)\n static void\n output_compilation_unit_header ()\n {\n-  /* ??? The dwarf standard says this must be a 4 byte integer, but the\n-     SGI dwarf reader assumes this is the same size as a pointer.  */\n-  fprintf (asm_out_file, \"\\t%s\\t0x%x\",\n-\t   UNALIGNED_INT_ASM_OP, next_die_offset - 4);\n+  ASM_OUTPUT_DWARF_DATA (asm_out_file, next_die_offset - DWARF_OFFSET_SIZE);\n   if (flag_verbose_asm)\n     {\n       fprintf (asm_out_file, \"\\t%s Length of Compilation Unit Info.\",\n \t       ASM_COMMENT_START);\n     }\n   fputc ('\\n', asm_out_file);\n-  fprintf (asm_out_file, \"\\t%s\\t0x%x\", UNALIGNED_SHORT_ASM_OP, DWARF_VERSION);\n+  ASM_OUTPUT_DWARF_DATA2 (asm_out_file, DWARF_VERSION);\n   if (flag_verbose_asm)\n     {\n       fprintf (asm_out_file, \"\\t%s DWARF version number\",\n \t       ASM_COMMENT_START);\n     }\n   fputc ('\\n', asm_out_file);\n-  fprintf (asm_out_file, \"\\t%s\\t%s\", UNALIGNED_INT_ASM_OP,\n-\t   stripattributes (ABBREV_SECTION));\n+  ASM_OUTPUT_DWARF_OFFSET (asm_out_file, stripattributes (ABBREV_SECTION));\n   if (flag_verbose_asm)\n     {\n       fprintf (asm_out_file, \"\\t%s Offset Into Abbrev. Section\",\n \t       ASM_COMMENT_START);\n     }\n   fputc ('\\n', asm_out_file);\n-  fprintf (asm_out_file, \"\\t%s\\t0x%x\", ASM_BYTE_OP, PTR_SIZE);\n+  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, PTR_SIZE);\n   if (flag_verbose_asm)\n     {\n       fprintf (asm_out_file, \"\\t%s Pointer Size (in bytes)\",\n@@ -3699,8 +3824,8 @@ size_of_fde (fde, npad)\n     {\n \tsize += size_of_cfi(cfi);\n     }\n-  /* Round the size up to an 8 byte boundary.  */\n-  aligned_size = (size + 7) & ~7;\n+  /* Round the size up to a word boundary.  */\n+  aligned_size = DWARF_ROUND (size, PTR_SIZE);\n   *npad = aligned_size - size;\n   return aligned_size;\n }\n@@ -3850,7 +3975,7 @@ output_call_frame_info ()\n   unsigned long fde_pad;\n \n   /* Output the CIE. */\n-  ASM_OUTPUT_DWARF_DATA4 (asm_out_file, DWARF_CIE_SIZE - 4);\n+  ASM_OUTPUT_DWARF_DATA (asm_out_file, DWARF_CIE_SIZE - DWARF_OFFSET_SIZE);\n   if (flag_verbose_asm)\n     {\n       fprintf (asm_out_file, \"\\t%s Length of Common Information Entry\",\n@@ -3864,6 +3989,11 @@ output_call_frame_info ()\n \t       ASM_COMMENT_START);\n     }\n   fputc ('\\n', asm_out_file);\n+  if (DWARF_OFFSET_SIZE == 8)\n+    {\n+      ASM_OUTPUT_DWARF_DATA4 (asm_out_file, DW_CIE_ID);\n+      fputc ('\\n', asm_out_file);\n+    }\n   ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_CIE_VERSION);\n   if (flag_verbose_asm)\n     {\n@@ -3932,14 +4062,14 @@ output_call_frame_info ()\n     {\n       fde = &fde_table[i];\n       fde_size = size_of_fde (fde, &fde_pad);\n-      ASM_OUTPUT_DWARF_DATA4 (asm_out_file, fde_size - 4);\n+      ASM_OUTPUT_DWARF_DATA (asm_out_file, fde_size - DWARF_OFFSET_SIZE);\n       if (flag_verbose_asm)\n \t{\n \t  fprintf (asm_out_file, \"\\t%s FDE Length\",\n \t\t   ASM_COMMENT_START);\n \t}\n       fputc ('\\n', asm_out_file);\n-      ASM_OUTPUT_DWARF_ADDR (asm_out_file, stripattributes (FRAME_SECTION));\n+      ASM_OUTPUT_DWARF_OFFSET (asm_out_file, stripattributes (FRAME_SECTION));\n       if (flag_verbose_asm)\n \t{\n \t  fprintf (asm_out_file, \"\\t%s FDE CIE offset\",\n@@ -3953,8 +4083,8 @@ output_call_frame_info ()\n \t\t   ASM_COMMENT_START);\n \t}\n       fputc ('\\n', asm_out_file);\n-      ASM_OUTPUT_DWARF_DELTA4 (asm_out_file,\n-\t\t\t       fde->dw_fde_end, fde->dw_fde_begin);\n+      ASM_OUTPUT_DWARF_ADDR_DELTA\n+\t(asm_out_file, fde->dw_fde_end, fde->dw_fde_begin);\n       if (flag_verbose_asm)\n \t{\n \t  fprintf (asm_out_file, \"\\t%s FDE address range\",\n@@ -4014,7 +4144,7 @@ output_pubnames ()\n   register unsigned i;\n   {\n     register unsigned long pubnames_length = size_of_pubnames ();\n-    ASM_OUTPUT_DWARF_DATA4 (asm_out_file, pubnames_length);\n+    ASM_OUTPUT_DWARF_DATA (asm_out_file, pubnames_length);\n   }\n   if (flag_verbose_asm)\n     {\n@@ -4029,14 +4159,14 @@ output_pubnames ()\n \t       ASM_COMMENT_START);\n     }\n   fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_DWARF_ADDR (asm_out_file, stripattributes (DEBUG_SECTION));\n+  ASM_OUTPUT_DWARF_OFFSET (asm_out_file, stripattributes (DEBUG_SECTION));\n   if (flag_verbose_asm)\n     {\n       fprintf (asm_out_file, \"\\t%s Offset of Compilation Unit Info.\",\n \t       ASM_COMMENT_START);\n     }\n   fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_DWARF_DATA4 (asm_out_file, next_die_offset);\n+  ASM_OUTPUT_DWARF_DATA (asm_out_file, next_die_offset);\n   if (flag_verbose_asm)\n     {\n       fprintf (asm_out_file, \"\\t%s Compilation Unit Length\",\n@@ -4046,7 +4176,7 @@ output_pubnames ()\n   for (i = 0; i < pubname_table_in_use; ++i)\n     {\n       register pubname_ref pub = &pubname_table[i];\n-      ASM_OUTPUT_DWARF_DATA4 (asm_out_file, pub->die->die_offset);\n+      ASM_OUTPUT_DWARF_DATA (asm_out_file, pub->die->die_offset);\n       if (flag_verbose_asm)\n \t{\n \t  fprintf (asm_out_file, \"\\t%s DIE offset\",\n@@ -4062,7 +4192,7 @@ output_pubnames ()\n \t}\n       fputc ('\\n', asm_out_file);\n     }\n-  ASM_OUTPUT_DWARF_DATA4 (asm_out_file, 0);\n+  ASM_OUTPUT_DWARF_DATA (asm_out_file, 0);\n   fputc ('\\n', asm_out_file);\n }\n \n@@ -4093,7 +4223,7 @@ output_aranges ()\n   register unsigned i;\n   {\n     register unsigned long aranges_length = size_of_aranges ();\n-    ASM_OUTPUT_DWARF_DATA4 (asm_out_file, aranges_length);\n+    ASM_OUTPUT_DWARF_DATA (asm_out_file, aranges_length);\n   }\n   if (flag_verbose_asm)\n     {\n@@ -4108,7 +4238,7 @@ output_aranges ()\n \t       ASM_COMMENT_START);\n     }\n   fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_DWARF_ADDR (asm_out_file, stripattributes (DEBUG_SECTION));\n+  ASM_OUTPUT_DWARF_OFFSET (asm_out_file, stripattributes (DEBUG_SECTION));\n   if (flag_verbose_asm)\n     {\n       fprintf (asm_out_file, \"\\t%s Offset of Compilation Unit Info.\",\n@@ -4130,10 +4260,12 @@ output_aranges ()\n     }\n   fputc ('\\n', asm_out_file);\n   ASM_OUTPUT_DWARF_DATA4 (asm_out_file, 4);\n+  if (PTR_SIZE == 8)\n+    fprintf (asm_out_file, \",0,0\");\n   if (flag_verbose_asm)\n     {\n-      fprintf (asm_out_file, \"\\t%s Pad to 8 byte boundary\",\n-\t       ASM_COMMENT_START);\n+      fprintf (asm_out_file, \"\\t%s Pad to %d byte boundary\",\n+\t       ASM_COMMENT_START, 2 * PTR_SIZE);\n     }\n   fputc ('\\n', asm_out_file);\n   ASM_OUTPUT_DWARF_ADDR (asm_out_file, TEXT_SECTION);\n@@ -4142,7 +4274,7 @@ output_aranges ()\n       fprintf (asm_out_file, \"\\t%s Address\", ASM_COMMENT_START);\n     }\n   fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_DWARF_DELTA4 (asm_out_file, TEXT_END_LABEL, TEXT_SECTION);\n+  ASM_OUTPUT_DWARF_ADDR_DELTA (asm_out_file, TEXT_END_LABEL, TEXT_SECTION);\n   if (flag_verbose_asm)\n     {\n       fprintf (asm_out_file, \"%s Length\", ASM_COMMENT_START);\n@@ -4161,21 +4293,21 @@ output_aranges ()\n \t}\n       fputc ('\\n', asm_out_file);\n       if (a->die_tag == DW_TAG_subprogram)\n-\tASM_OUTPUT_DWARF_DELTA4 (asm_out_file, get_AT_hi_pc (a),\n-\t\t\t\t get_AT_low_pc (a));\n+\tASM_OUTPUT_DWARF_ADDR_DELTA (asm_out_file, get_AT_hi_pc (a),\n+\t\t\t\t     get_AT_low_pc (a));\n       else\n-\tASM_OUTPUT_DWARF_DATA4 (asm_out_file,\n-\t\t\t\tget_AT_unsigned (a, DW_AT_byte_size));\n+\tASM_OUTPUT_DWARF_ADDR_DATA (asm_out_file,\n+\t\t\t\t    get_AT_unsigned (a, DW_AT_byte_size));\n       if (flag_verbose_asm)\n \t{\n \t  fprintf (asm_out_file, \"%s Length\", ASM_COMMENT_START);\n \t}\n       fputc ('\\n', asm_out_file);\n     }\n   /* Output the terminator words.  */\n-  ASM_OUTPUT_DWARF_DATA4 (asm_out_file, 0);\n+  ASM_OUTPUT_DWARF_ADDR_DATA (asm_out_file, 0);\n   fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_DWARF_DATA4 (asm_out_file, 0);\n+  ASM_OUTPUT_DWARF_ADDR_DATA (asm_out_file, 0);\n   fputc ('\\n', asm_out_file);\n }\n \n@@ -4195,7 +4327,7 @@ output_line_info ()\n   register long line_delta;\n   register unsigned long current_file;\n   register unsigned long function;\n-  ASM_OUTPUT_DWARF_DATA4 (asm_out_file, size_of_line_info ());\n+  ASM_OUTPUT_DWARF_DATA (asm_out_file, size_of_line_info ());\n   if (flag_verbose_asm)\n     {\n       fprintf (asm_out_file, \"\\t%s Length of Source Line Info.\",\n@@ -4209,7 +4341,7 @@ output_line_info ()\n \t       ASM_COMMENT_START);\n     }\n   fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_DWARF_DATA4 (asm_out_file, size_of_line_prolog ());\n+  ASM_OUTPUT_DWARF_DATA (asm_out_file, size_of_line_prolog ());\n   if (flag_verbose_asm)\n     {\n       fprintf (asm_out_file, \"\\t%s Prolog Length\",\n@@ -6604,7 +6736,21 @@ gen_subprogram_die (decl, context_die)\n      any blocks used for the base and member initializers of a C++\n      constructor function.  */\n   if (outer_scope && TREE_CODE (outer_scope) != ERROR_MARK)\n-    decls_for_scope (outer_scope, subr_die, 0);\n+    {\n+      current_function_has_inlines = 0;\n+      decls_for_scope (outer_scope, subr_die, 0);\n+#ifdef MIPS_DEBUGGING_INFO\n+      if (current_function_has_inlines)\n+\t{\n+\t  add_AT_flag (subr_die, DW_AT_MIPS_has_inlines, 1);\n+\t  if (! comp_unit_has_inlines)\n+\t    {\n+\t      add_AT_flag (comp_unit_die, DW_AT_MIPS_has_inlines, 1);\n+\t      comp_unit_has_inlines = 1;\n+\t    }\n+\t}\n+#endif\n+    }\n }\n \n /* Generate a DIE to represent a declared data object.  */\n@@ -6655,7 +6801,8 @@ gen_variable_die (decl, context_die)\n     }\n   else if (!DECL_EXTERNAL (decl))\n     {\n-      equate_decl_number_to_die (decl, var_die);\n+      if (TREE_STATIC (decl))\n+\tequate_decl_number_to_die (decl, var_die);\n       add_location_or_const_value_attribute (var_die, decl);\n       add_pubname (decl, var_die);\n     }\n@@ -6738,14 +6885,15 @@ gen_inlined_subroutine_die (stmt, context_die, depth)\n   if (!BLOCK_ABSTRACT (stmt))\n     {\n       register dw_die_ref subr_die = new_die (DW_TAG_inlined_subroutine,\n-\t\t\t\t\t  context_die);\n+\t\t\t\t\t      context_die);\n       char label[MAX_ARTIFICIAL_LABEL_BYTES];\n       add_abstract_origin_attribute (subr_die, block_ultimate_origin (stmt));\n       sprintf (label, BLOCK_BEGIN_LABEL_FMT, next_block_number);\n       add_AT_lbl_id (subr_die, DW_AT_low_pc, label);\n       sprintf (label, BLOCK_END_LABEL_FMT, next_block_number);\n       add_AT_lbl_id (subr_die, DW_AT_high_pc, label);\n       decls_for_scope (stmt, subr_die, depth);\n+      current_function_has_inlines = 1;\n     }\n }\n "}]}