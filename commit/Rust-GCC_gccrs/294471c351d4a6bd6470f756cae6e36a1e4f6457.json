{"sha": "294471c351d4a6bd6470f756cae6e36a1e4f6457", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjk0NDcxYzM1MWQ0YTZiZDY0NzBmNzU2Y2FlNmUzNmExZTRmNjQ1Nw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchell@usa.net", "date": "1998-04-17T21:25:38Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-04-17T21:25:38Z"}, "message": "cp-tree.h (type_as_string_real): New function.\n\nFri Apr 17 21:25:00 1998  Mark Mitchell  <mmitchell@usa.net>\n\t* cp-tree.h (type_as_string_real): New function.\n\t* pt.c (mangle_class_name_for_template): Use it.\n\t* error.c (dump_aggr_type): Change prototype.\n\t(dump_type_prefix): Likewise.\n\t(dump_type_suffix): Likewise.\n\t(dump_type_real): Convert from dump_type.  If desired, the\n\t\"canonica\" name of a typedef, i.e., the name of the underlying\n\ttype, can be printed.\n\t(dump_type): Call dump_type_real.\n\nFrom-SVN: r19273", "tree": {"sha": "2b4acb5094abb3872468b20ba4161dae536e6153", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b4acb5094abb3872468b20ba4161dae536e6153"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/294471c351d4a6bd6470f756cae6e36a1e4f6457", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/294471c351d4a6bd6470f756cae6e36a1e4f6457", "html_url": "https://github.com/Rust-GCC/gccrs/commit/294471c351d4a6bd6470f756cae6e36a1e4f6457", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/294471c351d4a6bd6470f756cae6e36a1e4f6457/comments", "author": null, "committer": null, "parents": [{"sha": "45df6aeae210e9cbd871d1695041929d7918becb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45df6aeae210e9cbd871d1695041929d7918becb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45df6aeae210e9cbd871d1695041929d7918becb"}], "stats": {"total": 131, "additions": 78, "deletions": 53}, "files": [{"sha": "3d8f991a4e9256c202f488a941304d231de6c73f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/294471c351d4a6bd6470f756cae6e36a1e4f6457/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/294471c351d4a6bd6470f756cae6e36a1e4f6457/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=294471c351d4a6bd6470f756cae6e36a1e4f6457", "patch": "@@ -1,3 +1,15 @@\n+Fri Apr 17 21:25:00 1998  Mark Mitchell  <mmitchell@usa.net>\n+\n+\t* cp-tree.h (type_as_string_real): New function.\n+\t* pt.c (mangle_class_name_for_template): Use it.\n+\t* error.c (dump_aggr_type): Change prototype.\n+\t(dump_type_prefix): Likewise.\n+\t(dump_type_suffix): Likewise.\n+\t(dump_type_real): Convert from dump_type.  If desired, the\n+\t\"canonica\" name of a typedef, i.e., the name of the underlying\n+\ttype, can be printed.\n+\t(dump_type): Call dump_type_real.\n+\n Fri Apr 17 14:30:45 1998  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* decl2.c (lang_decode_option): -fnew-abi implies -fvtable-thunks."}, {"sha": "e2f68aa816f5ae991402dd3d5f76e0719bacc56b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/294471c351d4a6bd6470f756cae6e36a1e4f6457/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/294471c351d4a6bd6470f756cae6e36a1e4f6457/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=294471c351d4a6bd6470f756cae6e36a1e4f6457", "patch": "@@ -2272,6 +2272,7 @@ extern void cp_sprintf\t\t\t\t();\n extern void init_error\t\t\t\tPROTO((void));\n extern char *fndecl_as_string\t\t\tPROTO((tree, int));\n extern char *type_as_string\t\t\tPROTO((tree, int));\n+extern char *type_as_string_real\t\tPROTO((tree, int, int));\n extern char *args_as_string\t\t\tPROTO((tree, int));\n extern char *decl_as_string\t\t\tPROTO((tree, int));\n extern char *expr_as_string\t\t\tPROTO((tree, int));"}, {"sha": "a9e9661490ca3f633da9df9a7712743af759803c", "filename": "gcc/cp/error.c", "status": "modified", "additions": 62, "deletions": 38, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/294471c351d4a6bd6470f756cae6e36a1e4f6457/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/294471c351d4a6bd6470f756cae6e36a1e4f6457/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=294471c351d4a6bd6470f756cae6e36a1e4f6457", "patch": "@@ -88,14 +88,15 @@ static char *scratch_firstobj;\n enum pad { none, before, after };\n \n static void dump_type PROTO((tree, int));\n+static void dump_type_real PROTO((tree, int, int));\n static void dump_decl PROTO((tree, int));\n static void dump_function_decl PROTO((tree, int));\n static void dump_expr PROTO((tree, int));\n static void dump_unary_op PROTO((char *, tree, int));\n static void dump_binary_op PROTO((char *, tree));\n-static void dump_aggr_type PROTO((tree, int));\n-static void dump_type_prefix PROTO((tree, int));\n-static void dump_type_suffix PROTO((tree, int));\n+static void dump_aggr_type PROTO((tree, int, int));\n+static void dump_type_prefix PROTO((tree, int, int));\n+static void dump_type_suffix PROTO((tree, int, int));\n static void dump_function_name PROTO((tree));\n static void dump_expr_list PROTO((tree));\n static void dump_global_iord PROTO((tree));\n@@ -136,7 +137,7 @@ static char digit_buffer[128];\n /* Dump into the obstack a human-readable equivalent of TYPE.  */\n \n static void\n-dump_type (t, v)\n+dump_type_real (t, v, canonical_name)\n      tree t;\n      int v;\t\t\t/* verbose? */\n {\n@@ -160,7 +161,7 @@ dump_type (t, v)\n       /* i.e. function taking no arguments */\n       if (t != void_list_node)\n \t{\n-\t  dump_type (TREE_VALUE (t), v);\n+\t  dump_type_real (TREE_VALUE (t), v, canonical_name);\n \t  /* Can this happen other than for default arguments? */\n \t  if (TREE_PURPOSE (t) && v)\n \t    {\n@@ -172,7 +173,7 @@ dump_type (t, v)\n \t      if (TREE_CHAIN (t) != void_list_node)\n \t\t{\n \t\t  OB_PUTC2 (',', ' ');\n-\t\t  dump_type (TREE_CHAIN (t), v);\n+\t\t  dump_type_real (TREE_CHAIN (t), v, canonical_name);\n \t\t}\n \t    }\n \t  else OB_PUTS (\" ...\");\n@@ -184,7 +185,7 @@ dump_type (t, v)\n       break;\n \n     case TREE_VEC:\n-      dump_type (BINFO_TYPE (t), v);\n+      dump_type_real (BINFO_TYPE (t), v, canonical_name);\n       break;\n \n     case RECORD_TYPE:\n@@ -195,14 +196,14 @@ dump_type (t, v)\n \t{\n \t  if (TYPE_READONLY (t) | TYPE_VOLATILE (t))\n \t    dump_readonly_or_volatile (t, after);\n-\t  dump_type (SIGNATURE_TYPE (t), v);\n+\t  dump_type_real (SIGNATURE_TYPE (t), v, canonical_name);\n \t  if (IS_SIGNATURE_POINTER (t))\n \t    OB_PUTC ('*');\n \t  else\n \t    OB_PUTC ('&');\n \t}\n       else\n-\tdump_aggr_type (t, v);\n+\tdump_aggr_type (t, v, canonical_name);\n       break;\n \n     case TYPE_DECL:\n@@ -212,7 +213,7 @@ dump_type (t, v)\n \n     case COMPLEX_TYPE:\n       OB_PUTS (\"complex \");\n-      dump_type (TREE_TYPE (t), v);\n+      dump_type_real (TREE_TYPE (t), v, canonical_name);\n       break;\n \n     case INTEGER_TYPE:\n@@ -226,7 +227,7 @@ dump_type (t, v)\n     case VOID_TYPE:\n     case BOOLEAN_TYPE:\n       dump_readonly_or_volatile (t, after);\n-      OB_PUTID (TYPE_IDENTIFIER (t));\n+      OB_PUTID (TYPE_IDENTIFIER (canonical_name ? TYPE_MAIN_VARIANT (t) : t));\n       break;\n \n     case TEMPLATE_TEMPLATE_PARM:\n@@ -249,7 +250,7 @@ dump_type (t, v)\n \t      tree arg = TREE_VEC_ELT (args, i);\n \t      if (TREE_CODE_CLASS (TREE_CODE (arg)) == 't'\n \t\t  || TREE_CODE (arg) == TEMPLATE_DECL)\n-\t        dump_type (arg, 0);\n+\t        dump_type_real (arg, 0, canonical_name);\n \t      else\n \t        dump_expr (arg, 0);\n \t      if (i < TREE_VEC_LENGTH (args)-1)\n@@ -276,13 +277,13 @@ dump_type (t, v)\n     offset_type:\n     case FUNCTION_TYPE:\n     case METHOD_TYPE:\n-      dump_type_prefix (t, v);\n-      dump_type_suffix (t, v);\n+      dump_type_prefix (t, v, canonical_name);\n+      dump_type_suffix (t, v, canonical_name);\n       break;\n \n     case TYPENAME_TYPE:\n       OB_PUTS (\"typename \");\n-      dump_type (TYPE_CONTEXT (t), 0);\n+      dump_type_real (TYPE_CONTEXT (t), 0, canonical_name);\n       OB_PUTS (\"::\");\n       OB_PUTID (TYPE_IDENTIFIER (t));\n       break;\n@@ -309,12 +310,21 @@ aggr_variety (t)\n     return \"struct\";\n }\n \n+static void\n+dump_type (t, v)\n+     tree t;\n+     int v;\t\t\t/* verbose? */\n+{\n+  dump_type_real (t, v, 0);\n+}\n+\n /* Print out a class declaration, in the form `class foo'.  */\n \n static void\n-dump_aggr_type (t, v)\n+dump_aggr_type (t, v, canonical_name)\n      tree t;\n      int v;\t\t\t/* verbose? */\n+     int canonical_name;\n {\n   tree name;\n   char *variety = aggr_variety (t);\n@@ -327,7 +337,7 @@ dump_aggr_type (t, v)\n       OB_PUTC (' ');\n     }\n   \n-  name = TYPE_NAME (t);\n+  name = TYPE_NAME (canonical_name ? TYPE_MAIN_VARIANT (t) : t);\n \n   if (name && DECL_CONTEXT (name))\n     {\n@@ -366,9 +376,10 @@ dump_aggr_type (t, v)\n    int *[]&.  */\n \n static void\n-dump_type_prefix (t, v)\n+dump_type_prefix (t, v, canonical_name)\n      tree t;\n      int v;\t\t\t/* verbosity */\n+     int canonical_name;\n {\n   if (TYPE_PTRMEMFUNC_P (t))\n     {\n@@ -382,7 +393,7 @@ dump_type_prefix (t, v)\n       {\n \ttree sub = TREE_TYPE (t);\n \t\n-\tdump_type_prefix (sub, v);\n+\tdump_type_prefix (sub, v, canonical_name);\n \t/* A tree for a member pointer looks like pointer to offset,\n \t   so let the OFFSET_TYPE case handle it.  */\n \tif (TREE_CODE (sub) != OFFSET_TYPE)\n@@ -416,7 +427,7 @@ dump_type_prefix (t, v)\n     case REFERENCE_TYPE:\n       {\n \ttree sub = TREE_TYPE (t);\n-\tdump_type_prefix (sub, v);\n+\tdump_type_prefix (sub, v, canonical_name);\n \n \tswitch (TREE_CODE (sub))\n \t  {\n@@ -440,11 +451,11 @@ dump_type_prefix (t, v)\n \n     case OFFSET_TYPE:\n     offset_type:\n-      dump_type_prefix (TREE_TYPE (t), v);\n+      dump_type_prefix (TREE_TYPE (t), v, canonical_name);\n       if (TREE_CODE (t) == OFFSET_TYPE)\t/* pmfs deal with this in d_t_p */\n \t{\n \t  OB_PUTC (' ');\n-\t  dump_type (TYPE_OFFSET_BASETYPE (t), 0);\n+\t  dump_type_real (TYPE_OFFSET_BASETYPE (t), 0, canonical_name);\n \t  OB_PUTC2 (':', ':');\n \t}\n       OB_PUTC ('*');\n@@ -454,19 +465,19 @@ dump_type_prefix (t, v)\n       /* Can only be reached through function pointer -- this would not be\n          correct if FUNCTION_DECLs used it.  */\n     case FUNCTION_TYPE:\n-      dump_type_prefix (TREE_TYPE (t), v);\n+      dump_type_prefix (TREE_TYPE (t), v, canonical_name);\n       OB_PUTC2 (' ', '(');\n       break;\n \n     case METHOD_TYPE:\n-      dump_type_prefix (TREE_TYPE (t), v);\n+      dump_type_prefix (TREE_TYPE (t), v, canonical_name);\n       OB_PUTC2 (' ', '(');\n-      dump_aggr_type (TYPE_METHOD_BASETYPE (t), 0);\n+      dump_aggr_type (TYPE_METHOD_BASETYPE (t), 0, canonical_name);\n       OB_PUTC2 (':', ':');\n       break;\n \n     case ARRAY_TYPE:\n-      dump_type_prefix (TREE_TYPE (t), v);\n+      dump_type_prefix (TREE_TYPE (t), v, canonical_name);\n       break;\n \n     case ENUMERAL_TYPE:\n@@ -486,7 +497,7 @@ dump_type_prefix (t, v)\n     case VOID_TYPE:\n     case TYPENAME_TYPE:\n     case COMPLEX_TYPE:\n-      dump_type (t, v);\n+      dump_type_real (t, v, canonical_name);\n       break;\n       \n     default:\n@@ -496,9 +507,10 @@ dump_type_prefix (t, v)\n }\n \n static void\n-dump_type_suffix (t, v)\n+dump_type_suffix (t, v, canonical_name)\n      tree t;\n      int v;\t\t\t/* verbose? */\n+     int canonical_name;\n {\n   if (TYPE_PTRMEMFUNC_P (t))\n     t = TYPE_PTRMEMFUNC_FN_TYPE (t);\n@@ -510,7 +522,7 @@ dump_type_suffix (t, v)\n     case OFFSET_TYPE:\n       if (TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE)\n \tOB_PUTC (')');\n-      dump_type_suffix (TREE_TYPE (t), v);\n+      dump_type_suffix (TREE_TYPE (t), v, canonical_name);\n       break;\n \n       /* Can only be reached through function pointer */\n@@ -531,7 +543,7 @@ dump_type_suffix (t, v)\n \tif (TREE_CODE (t) == METHOD_TYPE)\n \t  dump_readonly_or_volatile\n \t    (TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (t))), before);\n-\tdump_type_suffix (TREE_TYPE (t), v);\n+\tdump_type_suffix (TREE_TYPE (t), v, canonical_name);\n \tbreak;\n       }\n \n@@ -549,7 +561,7 @@ dump_type_suffix (t, v)\n \t\t\t      integer_one_node, 1)), 0);\n \t}\n       OB_PUTC (']');\n-      dump_type_suffix (TREE_TYPE (t), v);\n+      dump_type_suffix (TREE_TYPE (t), v, canonical_name);\n       break;\n       \n     case ENUMERAL_TYPE:\n@@ -676,7 +688,7 @@ dump_decl (t, v)\n     general:\n       if (v > 0)\n \t{\n-\t  dump_type_prefix (TREE_TYPE (t), v);\n+\t  dump_type_prefix (TREE_TYPE (t), v, 0);\n \t  OB_PUTC (' ');\n \t  dump_readonly_or_volatile (t, after);\n \t}\n@@ -692,7 +704,7 @@ dump_decl (t, v)\n       else\n \tOB_PUTS (\"{anon}\");\n       if (v > 0)\n-\tdump_type_suffix (TREE_TYPE (t), v);\n+\tdump_type_suffix (TREE_TYPE (t), v, 0);\n       break;\n \n     case NAMESPACE_DECL:\n@@ -922,7 +934,7 @@ dump_function_decl (t, v)\n \t  && ! DECL_CONSTRUCTOR_P (t)\n \t  && ! DESTRUCTOR_NAME_P (name))\n \t{\n-\t  dump_type_prefix (TREE_TYPE (fntype), 1);\n+\t  dump_type_prefix (TREE_TYPE (fntype), 1, 0);\n \t  OB_PUTC (' ');\n \t}\n     }\n@@ -953,7 +965,7 @@ dump_function_decl (t, v)\n   OB_PUTC (')');\n \n   if (v && ! IDENTIFIER_TYPENAME_P (name))\n-    dump_type_suffix (TREE_TYPE (fntype), 1);\n+    dump_type_suffix (TREE_TYPE (fntype), 1, 0);\n \n   if (TREE_CODE (fntype) == METHOD_TYPE)\n     {\n@@ -1653,22 +1665,34 @@ fndecl_as_string (fndecl, print_ret_type_p)\n \n /* Same, but handle a _TYPE.\n    Called from convert_to_reference, mangle_class_name_for_template,\n-   build_unary_op, and GNU_xref_decl.  */\n+   build_unary_op, and GNU_xref_decl.  If CANONICAL_NAME is non-zero,\n+   when describing a typedef, we use the name of the type described,\n+   rather than the name of the typedef.  */\n \n char *\n-type_as_string (typ, v)\n+type_as_string_real (typ, v, canonical_name)\n      tree typ;\n      int v;\n+     int canonical_name;\n {\n   OB_INIT ();\n \n-  dump_type (typ, v);\n+  dump_type_real (typ, v, canonical_name);\n \n   OB_FINISH ();\n \n   return (char *)obstack_base (&scratch_obstack);\n }\n \n+\n+char *\n+type_as_string (typ, v)\n+     tree typ;\n+     int v;\n+{\n+  return type_as_string_real (typ, v, 0);\n+}\n+\n char *\n expr_as_string (decl, v)\n      tree decl;"}, {"sha": "8de724a9026015a9428cb7d85f0864e4c8bcd00a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/294471c351d4a6bd6470f756cae6e36a1e4f6457/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/294471c351d4a6bd6470f756cae6e36a1e4f6457/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=294471c351d4a6bd6470f756cae6e36a1e4f6457", "patch": "@@ -2559,13 +2559,7 @@ mangle_class_name_for_template (name, parms, arglist, ctx)\n       if (TREE_CODE (ctx) == FUNCTION_DECL)\n \ts = fndecl_as_string (ctx, 0);\n       else if (TREE_CODE_CLASS (TREE_CODE (ctx)) == 't')\n-\t{\n-\t  /* We can't use a typedef type name here.  */\n-\t  ctx = build_type_variant (TYPE_MAIN_VARIANT (ctx),\n-\t\t\t\t    TYPE_READONLY (ctx),\n-\t\t\t\t    TYPE_VOLATILE (ctx));\n-\t  s = type_as_string (ctx, 0);\n-\t}\n+\ts = type_as_string_real (ctx, 0, 1);\n       else\n \tmy_friendly_abort (0);\n       cat (s);\n@@ -2583,15 +2577,9 @@ mangle_class_name_for_template (name, parms, arglist, ctx)\n       if (i)\n \tccat (',');\n \n-      /* We can't use a typedef type name here.  */\n-      if (TREE_CODE_CLASS (TREE_CODE (arg)) == 't')\n-\targ = build_type_variant (TYPE_MAIN_VARIANT (arg),\n-\t\t\t\t  TYPE_READONLY (arg),\n-\t\t\t\t  TYPE_VOLATILE (arg));\n-\n       if (TREE_CODE (parm) == TYPE_DECL)\n \t{\n-\t  cat (type_as_string (arg, 0));\n+\t  cat (type_as_string_real (arg, 0, 1));\n \t  continue;\n \t}\n       else if (TREE_CODE (parm) == TEMPLATE_DECL)\n@@ -2602,7 +2590,7 @@ mangle_class_name_for_template (name, parms, arglist, ctx)\n \t    cat (IDENTIFIER_POINTER (DECL_NAME (arg)));\n \t  else\n \t    /* Output the parameter declaration */\n-\t    cat (type_as_string (arg, 0));\n+\t    cat (type_as_string_real (arg, 0, 1));\n \t  continue;\n \t}\n       else"}]}