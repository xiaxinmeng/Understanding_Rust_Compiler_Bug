{"sha": "ca1afa261d03c9343dff1208325f87d9ba69ec7a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ExYWZhMjYxZDAzYzkzNDNkZmYxMjA4MzI1Zjg3ZDliYTY5ZWM3YQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-08-26T08:30:15Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-08-26T08:30:15Z"}, "message": "dwarf2out: Fix up dwarf2out_next_real_insn caching [PR96729]\n\nThe addition of NOTE_INSN_BEGIN_STMT and NOTE_INSN_INLINE_ENTRY notes\nreintroduced quadratic behavior into dwarf2out_var_location.\nThis function needs to know the next real instruction to which the var\nlocation note applies, but the way final_scan_insn is called outside of\nfinal.c main loop doesn't make it easy to look up the next real insn in\nthere (and for non-dwarf it is even useless).  Usually next real insn is\nonly a few notes away, but we can have hundreds of thousands of consecutive\nnotes only followed by a real insn.  dwarf2out_var_location to avoid the\nquadratic behavior contains a cache, it remembers the next note and when it\nis called again on that loc_note, it can use the previously computed\ndwarf2out_next_real_insn result, rather than walking the insn chain once\nagain.  But, for NOTE_INSN_{BEGIN_STMT,INLINE_ENTRY} dwarf2out_var_location\nis not called while the code puts into the cache those notes, which means if\nwe have e.g. in the worst case NOTE_INSN_VAR_LOCATION and\nNOTE_INSN_BEGIN_STMT notes alternating, the cache is not really used.\n\nThe following patch fixes it by looking up the next NOTE_INSN_VAR_LOCATION\nif any.  While the lookup could be perhaps done together with looking for\nthe next real insn once (e.g. in dwarf2out_next_real_insn or its copy),\nthere are other dwarf2out_next_real_insn callers which don't need/want that\nbehavior and if there are more than two NOTE_INSN_VAR_LOCATION notes\nfollowed by the same real insn, we need to do that \"find next\nNOTE_INSN_VAR_LOCATION\" walk anyway.\n\nOn the testcase from the PR this patch speeds it 2.8times, from 0m0.674s\nto 0m0.236s (why it takes for the reporter more than 60s is unknown).\n\n2020-08-26  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR debug/96729\n\t* dwarf2out.c (dwarf2out_next_real_insn): Adjust function comment.\n\t(dwarf2out_var_location): Look for next_note only if next_real is\n\tnon-NULL, in that case look for the first non-deleted\n\tNOTE_INSN_VAR_LOCATION between loc_note and next_real, if any.", "tree": {"sha": "65848b3ed80b729e2779d5abd1a06dd9a1723207", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65848b3ed80b729e2779d5abd1a06dd9a1723207"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca1afa261d03c9343dff1208325f87d9ba69ec7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca1afa261d03c9343dff1208325f87d9ba69ec7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca1afa261d03c9343dff1208325f87d9ba69ec7a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca1afa261d03c9343dff1208325f87d9ba69ec7a/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "387d0773f39a56b2a831a2b7e7ed189d6ffc2f36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/387d0773f39a56b2a831a2b7e7ed189d6ffc2f36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/387d0773f39a56b2a831a2b7e7ed189d6ffc2f36"}], "stats": {"total": 36, "additions": 20, "deletions": 16}, "files": [{"sha": "b6ab49bb548214ce4a17cd0386bc0a1b10f4a2ca", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca1afa261d03c9343dff1208325f87d9ba69ec7a/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca1afa261d03c9343dff1208325f87d9ba69ec7a/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=ca1afa261d03c9343dff1208325f87d9ba69ec7a", "patch": "@@ -27204,7 +27204,7 @@ static bool maybe_at_text_label_p = true;\n /* One above highest N where .LVLN label might be equal to .Ltext0 label.  */\n static unsigned int first_loclabel_num_not_at_text_label;\n \n-/* Look ahead for a real insn, or for a begin stmt marker.  */\n+/* Look ahead for a real insn.  */\n \n static rtx_insn *\n dwarf2out_next_real_insn (rtx_insn *loc_note)\n@@ -27229,7 +27229,7 @@ dwarf2out_var_location (rtx_insn *loc_note)\n {\n   char loclabel[MAX_ARTIFICIAL_LABEL_BYTES + 2];\n   struct var_loc_node *newloc;\n-  rtx_insn *next_real, *next_note;\n+  rtx_insn *next_real;\n   rtx_insn *call_insn = NULL;\n   static const char *last_label;\n   static const char *last_postcall_label;\n@@ -27254,7 +27254,6 @@ dwarf2out_var_location (rtx_insn *loc_note)\n \t      var_loc_p = false;\n \n \t      next_real = dwarf2out_next_real_insn (call_insn);\n-\t      next_note = NULL;\n \t      cached_next_real_insn = NULL;\n \t      goto create_label;\n \t    }\n@@ -27282,7 +27281,6 @@ dwarf2out_var_location (rtx_insn *loc_note)\n \t\t  var_loc_p = false;\n \n \t\t  next_real = dwarf2out_next_real_insn (call_insn);\n-\t\t  next_note = NULL;\n \t\t  cached_next_real_insn = NULL;\n \t\t  goto create_label;\n \t\t}\n@@ -27311,22 +27309,28 @@ dwarf2out_var_location (rtx_insn *loc_note)\n \tnext_real = NULL;\n     }\n \n-  next_note = NEXT_INSN (loc_note);\n-  if (! next_note\n-      || next_note->deleted ()\n-      || ! NOTE_P (next_note)\n-      || (NOTE_KIND (next_note) != NOTE_INSN_VAR_LOCATION\n-\t  && NOTE_KIND (next_note) != NOTE_INSN_BEGIN_STMT\n-\t  && NOTE_KIND (next_note) != NOTE_INSN_INLINE_ENTRY))\n-    next_note = NULL;\n-\n   if (! next_real)\n     next_real = dwarf2out_next_real_insn (loc_note);\n \n-  if (next_note)\n+  if (next_real)\n     {\n-      expected_next_loc_note = next_note;\n-      cached_next_real_insn = next_real;\n+      rtx_insn *next_note = NEXT_INSN (loc_note);\n+      while (next_note != next_real)\n+\t{\n+\t  if (! next_note->deleted ()\n+\t      && NOTE_P (next_note)\n+\t      && NOTE_KIND (next_note) == NOTE_INSN_VAR_LOCATION)\n+\t    break;\n+\t  next_note = NEXT_INSN (next_note);\n+\t}\n+\n+      if (next_note == next_real)\n+\tcached_next_real_insn = NULL;\n+      else\n+\t{\n+\t  expected_next_loc_note = next_note;\n+\t  cached_next_real_insn = next_real;\n+\t}\n     }\n   else\n     cached_next_real_insn = NULL;"}]}