{"sha": "5c824000a5b855d454483bee7d32850f161ecdab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWM4MjQwMDBhNWI4NTVkNDU0NDgzYmVlN2QzMjg1MGYxNjFlY2RhYg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2010-05-12T17:34:15Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2010-05-12T17:34:15Z"}, "message": "call.c (add_candidates): Add first_arg and return_type parms.\n\n\t* call.c (add_candidates): Add first_arg and return_type parms.\n\tAdd special constructor/conversion op handling.\n\t(convert_class_to_reference): Use it.\n\t(build_user_type_conversion_1): Likewise.\n\t(build_op_call): Likewise.\n\t(build_new_method_call): Likewise.\n\t(build_new_op): Adjust.\n\t(perform_overload_resolution): Adjust.\n\nFrom-SVN: r159332", "tree": {"sha": "745079a1dbccb8a8aeb388354725e36ec502ff4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/745079a1dbccb8a8aeb388354725e36ec502ff4f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c824000a5b855d454483bee7d32850f161ecdab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c824000a5b855d454483bee7d32850f161ecdab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c824000a5b855d454483bee7d32850f161ecdab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c824000a5b855d454483bee7d32850f161ecdab/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1df439077d1f123c12e9947dc56a749d5a44d1f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1df439077d1f123c12e9947dc56a749d5a44d1f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1df439077d1f123c12e9947dc56a749d5a44d1f8"}], "stats": {"total": 375, "additions": 160, "deletions": 215}, "files": [{"sha": "5c8ff3a739a08fa605ca1941c9ddf04f7dd62d60", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c824000a5b855d454483bee7d32850f161ecdab/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c824000a5b855d454483bee7d32850f161ecdab/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5c824000a5b855d454483bee7d32850f161ecdab", "patch": "@@ -1,3 +1,14 @@\n+2010-05-12  Jason Merrill  <jason@redhat.com>\n+\n+\t* call.c (add_candidates): Add first_arg and return_type parms.\n+\tAdd special constructor/conversion op handling.\n+\t(convert_class_to_reference): Use it.\n+\t(build_user_type_conversion_1): Likewise.\n+\t(build_op_call): Likewise.\n+\t(build_new_method_call): Likewise.\n+\t(build_new_op): Adjust.\n+\t(perform_overload_resolution): Adjust.\n+\n 2010-05-11  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/34272"}, {"sha": "17ad99e84267a6a9769f2a3afdc583c4dbd4b708", "filename": "gcc/cp/call.c", "status": "modified", "additions": 143, "deletions": 215, "changes": 358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c824000a5b855d454483bee7d32850f161ecdab/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c824000a5b855d454483bee7d32850f161ecdab/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=5c824000a5b855d454483bee7d32850f161ecdab", "patch": "@@ -197,8 +197,8 @@ static bool promoted_arithmetic_type_p (tree);\n static conversion *conditional_conversion (tree, tree);\n static char *name_as_c_string (tree, tree, bool *);\n static tree prep_operand (tree);\n-static void add_candidates (tree, const VEC(tree,gc) *, tree, bool, tree, tree,\n-\t\t\t    int, struct z_candidate **);\n+static void add_candidates (tree, tree, const VEC(tree,gc) *, tree, tree, bool,\n+\t\t\t    tree, tree, int, struct z_candidate **);\n static conversion *merge_conversion_sequences (conversion *, conversion *);\n static bool magic_varargs_p (tree);\n static tree build_temp (tree, tree, int, diagnostic_t *);\n@@ -1056,57 +1056,28 @@ convert_class_to_reference (tree reference_type, tree s, tree expr, int flags)\n   for (; conversions; conversions = TREE_CHAIN (conversions))\n     {\n       tree fns = TREE_VALUE (conversions);\n+      tree binfo = TREE_PURPOSE (conversions);\n+      struct z_candidate *old_candidates = candidates;;\n \n-      for (; fns; fns = OVL_NEXT (fns))\n+      add_candidates (fns, first_arg, NULL, reference_type,\n+\t\t      NULL_TREE, false,\n+\t\t      binfo, TYPE_BINFO (s),\n+\t\t      flags, &candidates);\n+\n+      for (cand = candidates; cand != old_candidates; cand = cand->next)\n \t{\n-\t  tree f = OVL_CURRENT (fns);\n+\t  /* Now, see if the conversion function really returns\n+\t     an lvalue of the appropriate type.  From the\n+\t     point of view of unification, simply returning an\n+\t     rvalue of the right type is good enough.  */\n+\t  tree f = cand->fn;\n \t  tree t2 = TREE_TYPE (TREE_TYPE (f));\n-\n-\t  if (DECL_NONCONVERTING_P (f)\n-\t      && (flags & LOOKUP_ONLYCONVERTING))\n-\t    continue;\n-\n-\t  cand = NULL;\n-\n-\t  /* If this is a template function, try to get an exact\n-\t     match.  */\n-\t  if (TREE_CODE (f) == TEMPLATE_DECL)\n+\t  if (TREE_CODE (t2) != REFERENCE_TYPE\n+\t      || !reference_compatible_p (t, TREE_TYPE (t2)))\n \t    {\n-\t      cand = add_template_candidate (&candidates,\n-\t\t\t\t\t     f, s,\n-\t\t\t\t\t     NULL_TREE,\n-\t\t\t\t\t     first_arg,\n-\t\t\t\t\t     NULL,\n-\t\t\t\t\t     reference_type,\n-\t\t\t\t\t     TYPE_BINFO (s),\n-\t\t\t\t\t     TREE_PURPOSE (conversions),\n-\t\t\t\t\t     LOOKUP_NORMAL,\n-\t\t\t\t\t     DEDUCE_CONV);\n-\n-\t      if (cand)\n-\t\t{\n-\t\t  /* Now, see if the conversion function really returns\n-\t\t     an lvalue of the appropriate type.  From the\n-\t\t     point of view of unification, simply returning an\n-\t\t     rvalue of the right type is good enough.  */\n-\t\t  f = cand->fn;\n-\t\t  t2 = TREE_TYPE (TREE_TYPE (f));\n-\t\t  if (TREE_CODE (t2) != REFERENCE_TYPE\n-\t\t      || !reference_compatible_p (t, TREE_TYPE (t2)))\n-\t\t    {\n-\t\t      candidates = candidates->next;\n-\t\t      cand = NULL;\n-\t\t    }\n-\t\t}\n+\t      cand->viable = 0;\n \t    }\n-\t  else if (TREE_CODE (t2) == REFERENCE_TYPE\n-\t\t   && reference_compatible_p (t, TREE_TYPE (t2)))\n-\t    cand = add_function_candidate (&candidates, f, s, first_arg,\n-\t\t\t\t\t   NULL, TYPE_BINFO (s),\n-\t\t\t\t\t   TREE_PURPOSE (conversions),\n-\t\t\t\t\t   LOOKUP_NORMAL);\n-\n-\t  if (cand)\n+\t  else\n \t    {\n \t      conversion *identity_conv;\n \t      /* Build a standard conversion sequence indicating the\n@@ -2874,6 +2845,8 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n \n   candidates = 0;\n   flags |= LOOKUP_NO_CONVERSION;\n+  if (BRACE_ENCLOSED_INITIALIZER_P (expr))\n+    flags |= LOOKUP_NO_NARROWING;\n \n   /* It's OK to bind a temporary for converting constructor arguments, but\n      not in converting the return value of a conversion operator.  */\n@@ -2882,18 +2855,25 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n \n   if (ctors)\n     {\n+      int ctorflags = flags;\n       ctors = BASELINK_FUNCTIONS (ctors);\n \n       first_arg = build_int_cst (build_pointer_type (totype), 0);\n-      if (BRACE_ENCLOSED_INITIALIZER_P (expr)\n-\t  && !TYPE_HAS_LIST_CTOR (totype))\n+      if (BRACE_ENCLOSED_INITIALIZER_P (expr))\n \t{\n-\t  args = ctor_to_vec (expr);\n-\t  /* We still allow more conversions within an init-list.  */\n-\t  flags = ((flags & ~LOOKUP_NO_CONVERSION)\n-\t\t   /* But not for the copy ctor.  */\n-\t\t   |LOOKUP_NO_COPY_CTOR_CONVERSION\n-\t\t   |LOOKUP_NO_NARROWING);\n+\t  /* For list-initialization we consider explicit constructors, but\n+\t     give an error if one is selected.  */\n+\t  ctorflags &= ~LOOKUP_ONLYCONVERTING;\n+\t  if (TYPE_HAS_LIST_CTOR (totype))\n+\t    args = make_tree_vector_single (expr);\n+\t  else\n+\t    {\n+\t      args = ctor_to_vec (expr);\n+\t      /* We still allow more conversions within an init-list.  */\n+\t      ctorflags &= ~LOOKUP_NO_CONVERSION;\n+\t      /* But not for the copy ctor.  */\n+\t      ctorflags |= LOOKUP_NO_COPY_CTOR_CONVERSION;\n+\t    }\n \t}\n       else\n \targs = make_tree_vector_single (expr);\n@@ -2902,28 +2882,12 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n \t from here.  */\n       gcc_assert (!DECL_HAS_IN_CHARGE_PARM_P (OVL_CURRENT (ctors))\n \t\t  && !DECL_HAS_VTT_PARM_P (OVL_CURRENT (ctors)));\n-    }\n-  for (; ctors; ctors = OVL_NEXT (ctors))\n-    {\n-      tree ctor = OVL_CURRENT (ctors);\n-      if (DECL_NONCONVERTING_P (ctor)\n-\t  && !BRACE_ENCLOSED_INITIALIZER_P (expr))\n-\tcontinue;\n \n-      if (TREE_CODE (ctor) == TEMPLATE_DECL)\n-\tcand = add_template_candidate (&candidates, ctor, totype,\n-\t\t\t\t       NULL_TREE, first_arg, args, NULL_TREE,\n-\t\t\t\t       TYPE_BINFO (totype),\n-\t\t\t\t       TYPE_BINFO (totype),\n-\t\t\t\t       flags,\n-\t\t\t\t       DEDUCE_CALL);\n-      else\n-\tcand = add_function_candidate (&candidates, ctor, totype,\n-\t\t\t\t       first_arg, args, TYPE_BINFO (totype),\n-\t\t\t\t       TYPE_BINFO (totype),\n-\t\t\t\t       flags);\n+      add_candidates (ctors, first_arg, args, NULL_TREE, NULL_TREE, false,\n+\t\t      TYPE_BINFO (totype), TYPE_BINFO (totype),\n+\t\t      ctorflags, &candidates);\n \n-      if (cand)\n+      for (cand = candidates; cand; cand = cand->next)\n \t{\n \t  cand->second_conv = build_identity_conv (totype, NULL_TREE);\n \n@@ -2947,8 +2911,8 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n \n   for (; conv_fns; conv_fns = TREE_CHAIN (conv_fns))\n     {\n-      tree fns;\n       tree conversion_path = TREE_PURPOSE (conv_fns);\n+      struct z_candidate *old_candidates;\n \n       /* If we are called to convert to a reference type, we are trying to\n \t find an lvalue binding, so don't even consider temporaries.  If\n@@ -2957,65 +2921,40 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n       if (TREE_CODE (totype) == REFERENCE_TYPE)\n \tconvflags |= LOOKUP_NO_TEMP_BIND;\n \n-      for (fns = TREE_VALUE (conv_fns); fns; fns = OVL_NEXT (fns))\n+      old_candidates = candidates;\n+      add_candidates (TREE_VALUE (conv_fns), first_arg, NULL, totype,\n+\t\t      NULL_TREE, false,\n+\t\t      conversion_path, TYPE_BINFO (fromtype),\n+\t\t      flags, &candidates);\n+\n+      for (cand = candidates; cand != old_candidates; cand = cand->next)\n \t{\n-\t  tree fn = OVL_CURRENT (fns);\n-\n-\t  if (DECL_NONCONVERTING_P (fn)\n-\t      && (flags & LOOKUP_ONLYCONVERTING))\n-\t    continue;\n-\n-\t  /* [over.match.funcs] For conversion functions, the function\n-\t     is considered to be a member of the class of the implicit\n-\t     object argument for the purpose of defining the type of\n-\t     the implicit object parameter.\n-\n-\t     So we pass fromtype as CTYPE to add_*_candidate.  */\n-\n-\t  if (TREE_CODE (fn) == TEMPLATE_DECL)\n-\t    cand = add_template_candidate (&candidates, fn, fromtype,\n-\t\t\t\t\t   NULL_TREE,\n-\t\t\t\t\t   first_arg, NULL, totype,\n-\t\t\t\t\t   TYPE_BINFO (fromtype),\n-\t\t\t\t\t   conversion_path,\n-\t\t\t\t\t   flags,\n-\t\t\t\t\t   DEDUCE_CONV);\n-\t  else\n-\t    cand = add_function_candidate (&candidates, fn, fromtype,\n-\t\t\t\t\t   first_arg, NULL,\n-\t\t\t\t\t   TYPE_BINFO (fromtype),\n-\t\t\t\t\t   conversion_path,\n-\t\t\t\t\t   flags);\n+\t  conversion *ics\n+\t    = implicit_conversion (totype,\n+\t\t\t\t   TREE_TYPE (TREE_TYPE (cand->fn)),\n+\t\t\t\t   0,\n+\t\t\t\t   /*c_cast_p=*/false, convflags);\n \n-\t  if (cand)\n-\t    {\n-\t      conversion *ics\n-\t\t= implicit_conversion (totype,\n-\t\t\t\t       TREE_TYPE (TREE_TYPE (cand->fn)),\n-\t\t\t\t       0,\n-\t\t\t\t       /*c_cast_p=*/false, convflags);\n-\n-\t      /* If LOOKUP_NO_TEMP_BIND isn't set, then this is\n-\t\t copy-initialization.  In that case, \"The result of the\n-\t\t call is then used to direct-initialize the object that is\n-\t\t the destination of the copy-initialization.\"  [dcl.init]\n-\n-\t\t We represent this in the conversion sequence with an\n-\t\t rvalue conversion, which means a constructor call.  But\n-\t\t don't add a second rvalue conversion if there's already\n-\t\t one there.  Which there really shouldn't be, but it's\n-\t\t harmless since we'd add it here anyway. */\n-\t      if (ics && MAYBE_CLASS_TYPE_P (totype) && ics->kind != ck_rvalue\n-\t\t  && !(convflags & LOOKUP_NO_TEMP_BIND))\n-\t\tics = build_conv (ck_rvalue, totype, ics);\n-\n-\t      cand->second_conv = ics;\n-\n-\t      if (!ics)\n-\t\tcand->viable = 0;\n-\t      else if (candidates->viable == 1 && ics->bad_p)\n-\t\tcand->viable = -1;\n-\t    }\n+\t  /* If LOOKUP_NO_TEMP_BIND isn't set, then this is\n+\t     copy-initialization.  In that case, \"The result of the\n+\t     call is then used to direct-initialize the object that is\n+\t     the destination of the copy-initialization.\"  [dcl.init]\n+\n+\t     We represent this in the conversion sequence with an\n+\t     rvalue conversion, which means a constructor call.  But\n+\t     don't add a second rvalue conversion if there's already\n+\t     one there.  Which there really shouldn't be, but it's\n+\t     harmless since we'd add it here anyway. */\n+\t  if (ics && MAYBE_CLASS_TYPE_P (totype) && ics->kind != ck_rvalue\n+\t      && !(convflags & LOOKUP_NO_TEMP_BIND))\n+\t    ics = build_conv (ck_rvalue, totype, ics);\n+\n+\t  cand->second_conv = ics;\n+\n+\t  if (!ics)\n+\t    cand->viable = 0;\n+\t  else if (cand->viable == 1 && ics->bad_p)\n+\t    cand->viable = -1;\n \t}\n     }\n \n@@ -3145,7 +3084,8 @@ perform_overload_resolution (tree fn,\n     }\n \n   /* Add the various candidate functions.  */\n-  add_candidates (fn, args, explicit_targs, template_only,\n+  add_candidates (fn, NULL_TREE, args, NULL_TREE,\n+\t\t  explicit_targs, template_only,\n \t\t  /*conversion_path=*/NULL_TREE,\n \t\t  /*access_path=*/NULL_TREE,\n \t\t  LOOKUP_NORMAL,\n@@ -3383,24 +3323,13 @@ build_op_call (tree obj, VEC(tree,gc) **args, tsubst_flags_t complain)\n \n   if (fns)\n     {\n-      tree base = BINFO_TYPE (BASELINK_BINFO (fns));\n       first_mem_arg = build_this (obj);\n \n-      for (fns = BASELINK_FUNCTIONS (fns); fns; fns = OVL_NEXT (fns))\n-\t{\n-\t  tree fn = OVL_CURRENT (fns);\n-\n-\t  if (TREE_CODE (fn) == TEMPLATE_DECL)\n-\t    add_template_candidate (&candidates, fn, base, NULL_TREE,\n-\t\t\t\t    first_mem_arg, *args, NULL_TREE,\n-\t\t\t\t    TYPE_BINFO (type),\n-\t\t\t\t    TYPE_BINFO (type),\n-\t\t\t\t    LOOKUP_NORMAL, DEDUCE_CALL);\n-\t  else\n-\t    add_function_candidate\n-\t      (&candidates, fn, base, first_mem_arg, *args, TYPE_BINFO (type),\n-\t       TYPE_BINFO (type), LOOKUP_NORMAL);\n-\t}\n+      add_candidates (BASELINK_FUNCTIONS (fns),\n+\t\t      first_mem_arg, *args, NULL_TREE,\n+\t\t      NULL_TREE, false,\n+\t\t      BASELINK_BINFO (fns), BASELINK_ACCESS_BINFO (fns),\n+\t\t      LOOKUP_NORMAL, &candidates);\n     }\n \n   convs = lookup_conversions (type, /*lookup_template_convs_p=*/true);\n@@ -4058,53 +3987,86 @@ prep_operand (tree operand)\n \n /* Add each of the viable functions in FNS (a FUNCTION_DECL or\n    OVERLOAD) to the CANDIDATES, returning an updated list of\n-   CANDIDATES.  The ARGS are the arguments provided to the call,\n-   without any implicit object parameter.  This may change ARGS.  The\n+   CANDIDATES.  The ARGS are the arguments provided to the call;\n+   if FIRST_ARG is non-null it is the implicit object argument,\n+   otherwise the first element of ARGS is used if needed.  The\n    EXPLICIT_TARGS are explicit template arguments provided.\n    TEMPLATE_ONLY is true if only template functions should be\n    considered.  CONVERSION_PATH, ACCESS_PATH, and FLAGS are as for\n    add_function_candidate.  */\n \n static void\n-add_candidates (tree fns, const VEC(tree,gc) *args,\n+add_candidates (tree fns, tree first_arg, const VEC(tree,gc) *args,\n+\t\ttree return_type,\n \t\ttree explicit_targs, bool template_only,\n \t\ttree conversion_path, tree access_path,\n \t\tint flags,\n \t\tstruct z_candidate **candidates)\n {\n   tree ctype;\n-  VEC(tree,gc) *non_static_args;\n-  tree first_arg;\n+  const VEC(tree,gc) *non_static_args;\n+  bool check_converting;\n+  unification_kind_t strict;\n+  tree fn;\n+\n+  if (!fns)\n+    return;\n+\n+  /* Precalculate special handling of constructors and conversion ops.  */\n+  fn = OVL_CURRENT (fns);\n+  if (DECL_CONV_FN_P (fn))\n+    {\n+      check_converting = !!(flags & LOOKUP_ONLYCONVERTING);\n+      strict = DEDUCE_CONV;\n+      /* [over.match.funcs] For conversion functions, the function\n+\t is considered to be a member of the class of the implicit\n+\t object argument for the purpose of defining the type of\n+\t the implicit object parameter.  */\n+      ctype = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (first_arg)));\n+    }\n+  else\n+    {\n+      if (DECL_CONSTRUCTOR_P (fn))\n+\tcheck_converting = !!(flags & LOOKUP_ONLYCONVERTING);\n+      else\n+\tcheck_converting = false;\n+      strict = DEDUCE_CALL;\n+      ctype = conversion_path ? BINFO_TYPE (conversion_path) : NULL_TREE;\n+    }\n \n-  ctype = conversion_path ? BINFO_TYPE (conversion_path) : NULL_TREE;\n-  /* Delay creating the implicit this parameter until it is needed.  */\n-  non_static_args = NULL;\n-  first_arg = NULL_TREE;\n+  if (first_arg)\n+    non_static_args = args;\n+  else\n+    /* Delay creating the implicit this parameter until it is needed.  */\n+    non_static_args = NULL;\n \n-  while (fns)\n+  for (; fns; fns = OVL_NEXT (fns))\n     {\n-      tree fn;\n       tree fn_first_arg;\n       const VEC(tree,gc) *fn_args;\n \n       fn = OVL_CURRENT (fns);\n+\n+      if (check_converting && DECL_NONCONVERTING_P (fn))\n+\tcontinue;\n+\n       /* Figure out which set of arguments to use.  */\n       if (DECL_NONSTATIC_MEMBER_FUNCTION_P (fn))\n \t{\n-\t  /* If this function is a non-static member, prepend the implicit\n-\t     object parameter.  */\n-\t  if (non_static_args == NULL)\n+\t  /* If this function is a non-static member and we didn't get an\n+\t     implicit object argument, move it out of args.  */\n+\t  if (first_arg == NULL_TREE)\n \t    {\n \t      unsigned int ix;\n \t      tree arg;\n-\n-\t      non_static_args = VEC_alloc (tree, gc,\n-\t\t\t\t\t   VEC_length (tree, args) - 1);\n+\t      VEC(tree,gc) *tempvec\n+\t\t= VEC_alloc (tree, gc, VEC_length (tree, args) - 1);\n \t      for (ix = 1; VEC_iterate (tree, args, ix, arg); ++ix)\n-\t\tVEC_quick_push (tree, non_static_args, arg);\n+\t\tVEC_quick_push (tree, tempvec, arg);\n+\t      non_static_args = tempvec;\n+\t      first_arg = build_this (VEC_index (tree, args, 0));\n \t    }\n-\t  if (first_arg == NULL_TREE)\n-\t    first_arg = build_this (VEC_index (tree, args, 0));\n+\n \t  fn_first_arg = first_arg;\n \t  fn_args = non_static_args;\n \t}\n@@ -4122,11 +4084,11 @@ add_candidates (tree fns, const VEC(tree,gc) *args,\n \t\t\t\texplicit_targs,\n \t\t\t\tfn_first_arg, \n \t\t\t\tfn_args,\n-\t\t\t\tNULL_TREE,\n+\t\t\t\treturn_type,\n \t\t\t\taccess_path,\n \t\t\t\tconversion_path,\n \t\t\t\tflags,\n-\t\t\t\tDEDUCE_CALL);\n+\t\t\t\tstrict);\n       else if (!template_only)\n \tadd_function_candidate (candidates,\n \t\t\t\tfn,\n@@ -4136,7 +4098,6 @@ add_candidates (tree fns, const VEC(tree,gc) *args,\n \t\t\t\taccess_path,\n \t\t\t\tconversion_path,\n \t\t\t\tflags);\n-      fns = OVL_NEXT (fns);\n     }\n }\n \n@@ -4247,7 +4208,8 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n   /* Add namespace-scope operators to the list of functions to\n      consider.  */\n   add_candidates (lookup_function_nonclass (fnname, arglist, /*block_p=*/true),\n-\t\t  arglist, NULL_TREE, false, NULL_TREE, NULL_TREE,\n+\t\t  NULL_TREE, arglist, NULL_TREE,\n+\t\t  NULL_TREE, false, NULL_TREE, NULL_TREE,\n \t\t  flags, &candidates);\n   /* Add class-member operators to the candidate set.  */\n   if (CLASS_TYPE_P (TREE_TYPE (arg1)))\n@@ -4261,10 +4223,11 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n \t  goto user_defined_result_ready;\n \t}\n       if (fns)\n-\tadd_candidates (BASELINK_FUNCTIONS (fns), arglist,\n+\tadd_candidates (BASELINK_FUNCTIONS (fns),\n+\t\t\tNULL_TREE, arglist, NULL_TREE,\n \t\t\tNULL_TREE, false,\n \t\t\tBASELINK_BINFO (fns),\n-\t\t\tTYPE_BINFO (TREE_TYPE (arg1)),\n+\t\t\tBASELINK_ACCESS_BINFO (fns),\n \t\t\tflags, &candidates);\n     }\n \n@@ -6210,7 +6173,6 @@ build_new_method_call (tree instance, tree fns, VEC(tree,gc) **args,\n   VEC(tree,gc) *user_args;\n   tree call;\n   tree fn;\n-  tree class_type;\n   int template_only = 0;\n   bool any_viable_p;\n   tree orig_instance;\n@@ -6340,48 +6302,14 @@ build_new_method_call (tree instance, tree fns, VEC(tree,gc) **args,\n       *args = ctor_to_vec (VEC_index (tree, *args, 0));\n     }\n \n-  class_type = (conversion_path ? BINFO_TYPE (conversion_path) : NULL_TREE);\n   first_mem_arg = instance_ptr;\n \n   /* Get the high-water mark for the CONVERSION_OBSTACK.  */\n   p = conversion_obstack_alloc (0);\n \n-  for (fn = fns; fn; fn = OVL_NEXT (fn))\n-    {\n-      tree t = OVL_CURRENT (fn);\n-      tree this_first_arg;\n-\n-      /* We can end up here for copy-init of same or base class.  */\n-      if ((flags & LOOKUP_ONLYCONVERTING)\n-\t  && DECL_NONCONVERTING_P (t))\n-\tcontinue;\n-\n-      if (DECL_NONSTATIC_MEMBER_FUNCTION_P (t))\n-\tthis_first_arg = first_mem_arg;\n-      else\n-\tthis_first_arg = NULL_TREE;\n-\n-      if (TREE_CODE (t) == TEMPLATE_DECL)\n-\t/* A member template.  */\n-\tadd_template_candidate (&candidates, t,\n-\t\t\t\tclass_type,\n-\t\t\t\texplicit_targs,\n-\t\t\t\tthis_first_arg,\n-\t\t\t\targs == NULL ? NULL : *args,\n-\t\t\t\toptype,\n-\t\t\t\taccess_binfo,\n-\t\t\t\tconversion_path,\n-\t\t\t\tflags,\n-\t\t\t\tDEDUCE_CALL);\n-      else if (! template_only)\n-\tadd_function_candidate (&candidates, t,\n-\t\t\t\tclass_type,\n-\t\t\t\tthis_first_arg,\n-\t\t\t\targs == NULL ? NULL : *args,\n-\t\t\t\taccess_binfo,\n-\t\t\t\tconversion_path,\n-\t\t\t\tflags);\n-    }\n+  add_candidates (fns, first_mem_arg, args ? *args : NULL, optype,\n+\t\t  explicit_targs, template_only, conversion_path,\n+\t\t  access_binfo, flags, &candidates);\n \n   candidates = splice_viable (candidates, pedantic, &any_viable_p);\n   if (!any_viable_p)"}, {"sha": "6425c9ecdbfbc5d49e59253ee9aa96fe26582f5e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c824000a5b855d454483bee7d32850f161ecdab/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c824000a5b855d454483bee7d32850f161ecdab/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5c824000a5b855d454483bee7d32850f161ecdab", "patch": "@@ -1,3 +1,7 @@\n+2010-05-12  Jason Merrill  <jason@redhat.com>\n+\n+\t* g++.old-deja/g++.robertl/eb43.C: Prune \"candidates\" messages.\n+\n 2010-05-12  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/44088"}, {"sha": "1dc43284c43163d979db35ace55bb8b9ae942543", "filename": "gcc/testsuite/g++.old-deja/g++.robertl/eb43.C", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c824000a5b855d454483bee7d32850f161ecdab/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb43.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c824000a5b855d454483bee7d32850f161ecdab/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb43.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb43.C?ref=5c824000a5b855d454483bee7d32850f161ecdab", "patch": "@@ -4,6 +4,8 @@\n // The first one should still fail because it requires an implicit conversion\n // to pointer_to_binary_function, which has an `explicit' constructor.\n \n+// { dg-prune-output \"note\" }\n+\n #include <vector>\n #include <algorithm>\n #include <functional>"}]}