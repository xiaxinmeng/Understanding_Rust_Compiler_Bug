{"sha": "bf1df0a046ed0a4d272d0ee2c2a930e3ad9d1831", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmYxZGYwYTA0NmVkMGE0ZDI3MmQwZWUyYzJhOTMwZTNhZDlkMTgzMQ==", "commit": {"author": {"name": "Bud Davis", "email": "bdavis9659@comcast.net", "date": "2004-07-05T01:19:08Z"}, "committer": {"name": "Bud Davis", "email": "bdavis@gcc.gnu.org", "date": "2004-07-05T01:19:08Z"}, "message": "re PR libfortran/15472 (implicit open for unformatted file causes run-time error)\n\n2004-07-04  Bud Davis  <bdavis9659@comcast.net>\n            Paul Brook  <paul@codesourcery.com>\n\n        PR fortran/15472\n        * io/transfer.c(us_write): set recl for seq unform writes to max size.\n        * io/transfer.c(data_transfer_init): handle un-opened seq unform unit.\n        * io/unix.c(fd_alloc_w_at): handle requests at start, fd_flush at\n          right time.\n        * io/unix.c(is_seekable): set based upon the file/device, not the\n          method being used to access it (fd or mmap).\n        * io/unix.c(fd_flush): don't set file_size if !seekable.\n        * io/unix.c(fd_truncate: ditto.\n        * gfortran.fortran-torture/execute/seq_io.f90: New test.\n\nCo-Authored-By: Paul Brook <paul@codesourcery.com>\n\nFrom-SVN: r84104", "tree": {"sha": "b268954c8950b71cc4b9784da0d2cc8172c33fc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b268954c8950b71cc4b9784da0d2cc8172c33fc5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf1df0a046ed0a4d272d0ee2c2a930e3ad9d1831", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf1df0a046ed0a4d272d0ee2c2a930e3ad9d1831", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf1df0a046ed0a4d272d0ee2c2a930e3ad9d1831", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf1df0a046ed0a4d272d0ee2c2a930e3ad9d1831/comments", "author": null, "committer": null, "parents": [{"sha": "91a8b4596b7555f113eef0097a573ad24bdc17db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91a8b4596b7555f113eef0097a573ad24bdc17db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91a8b4596b7555f113eef0097a573ad24bdc17db"}], "stats": {"total": 162, "additions": 144, "deletions": 18}, "files": [{"sha": "b90f61d17ac9fc880b1b8fe659b75465634cfa3a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1df0a046ed0a4d272d0ee2c2a930e3ad9d1831/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1df0a046ed0a4d272d0ee2c2a930e3ad9d1831/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bf1df0a046ed0a4d272d0ee2c2a930e3ad9d1831", "patch": "@@ -1,3 +1,7 @@\n+2004-07-04  Bud Davis  <bdavis9659@comcast.net>\n+\n+\t* gfortran.fortran-torture/execute/seq_io.f90: New test.\n+\n 2004-07-04  Neil Booth  <neil@duron.akihabara.co.uk>\n \n \t* gcc.dg/cpp/if-mop.c: Two new testcases."}, {"sha": "e1688882989c38e8b04458b34555ca6db7a9b45e", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/seq_io.f90", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1df0a046ed0a4d272d0ee2c2a930e3ad9d1831/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fseq_io.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1df0a046ed0a4d272d0ee2c2a930e3ad9d1831/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fseq_io.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fseq_io.f90?ref=bf1df0a046ed0a4d272d0ee2c2a930e3ad9d1831", "patch": "@@ -0,0 +1,81 @@\n+! pr 15472\n+! sequential access files\n+!\n+!  this test verifies the most basic sequential unformatted I/O\n+!      write 3 records of various sizes\n+!      then read them back\n+!      and compare with what was written\n+!\n+       implicit none\n+       integer size\n+       parameter(size=100)\n+       logical debug \n+       data debug /.FALSE./\n+! set debug to true for help in debugging failures.\n+       integer m(2)\n+       integer n\n+       real*4 r(size)\n+       integer i\n+       m(1) = Z'11111111'\n+       m(2) = Z'22222222'\n+       n    = Z'33333333'\n+       do i = 1,size\n+         r(i) = i\n+       end do\n+       write(9)m  ! an array of 2\n+       write(9)n  ! an integer\n+       write(9)r  ! an array of reals\n+! zero all the results so we can compare after they are read back\n+       do i = 1,size\n+          r(i) = 0\n+       end do\n+       m(1) = 0\n+       m(2) = 0\n+       n = 0\n+\n+       rewind(9)\n+       read(9)m\n+       read(9)n\n+       read(9)r\n+!\n+! check results\n+       if (m(1).ne.Z'11111111') then\n+         if (debug) then\n+            print '(A,Z8)','m(1) incorrect.  m(1) = ',m(1)\n+         else\n+            call abort\n+         endif\n+       endif\n+\n+       if (m(2).ne.Z'22222222') then\n+         if (debug) then\n+            print '(A,Z8)','m(2) incorrect.  m(2) = ',m(2)\n+         else\n+            call abort\n+         endif\n+       endif\n+\n+       if (n.ne.Z'33333333') then\n+         if (debug) then\n+            print '(A,Z8)','n incorrect.  n = ',n\n+         else\n+            call abort\n+         endif\n+       endif\n+\n+       do i = 1,size\n+          if (int(r(i)).ne.i) then\n+            if (debug) then\n+              print*,'element ',i,' was ',r(i),' should be ',i\n+            else\n+              call abort\n+            endif\n+          endif\n+       end do\n+! use hexdump to look at the file \"fort.9\"\n+       if (debug) then\n+         close(9)\n+       else\n+         close(9,status='DELETE')\n+       endif\n+       end"}, {"sha": "14a6349f0231aa03ae9658ef21517dd8a7bcd2e9", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1df0a046ed0a4d272d0ee2c2a930e3ad9d1831/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1df0a046ed0a4d272d0ee2c2a930e3ad9d1831/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=bf1df0a046ed0a4d272d0ee2c2a930e3ad9d1831", "patch": "@@ -1,3 +1,16 @@\n+2004-07-04  Bud Davis  <bdavis9659@comcast.net>\n+\t    Paul Brook  <paul@codesourcery.com>\n+\n+\tPR fortran/15472\n+\t* io/transfer.c(us_write): set recl for seq unform writes to max size.\n+\t* io/transfer.c(data_transfer_init): handle un-opened seq unform unit.\n+\t* io/unix.c(fd_alloc_w_at): handle requests at start, fd_flush at \n+\t  right time.\n+\t* io/unix.c(is_seekable): set based upon the file/device, not the\n+          method being used to access it (fd or mmap).\n+\t* io/unix.c(fd_flush): don't set file_size if !seekable.\n+\t* io/unix.c(fd_truncate: ditto.\n+\n 2004-07-04  Janne Blomqvist  <jblomqvi@cc.hut.fi>\n \tPaul Brook  <paul@codesourcery.com>\n "}, {"sha": "ff4bc26f317630fd979b2597d93bfb802e9f9235", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1df0a046ed0a4d272d0ee2c2a930e3ad9d1831/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1df0a046ed0a4d272d0ee2c2a930e3ad9d1831/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=bf1df0a046ed0a4d272d0ee2c2a930e3ad9d1831", "patch": "@@ -835,6 +835,11 @@ us_write (void)\n   if (sfree (current_unit->s) == FAILURE)\n     generate_error (ERROR_OS, NULL);\n \n+  /* for sequential unformatted, we write until we have more bytes than\n+      can fit in the record markers. if disk space runs out first it will\n+      error on the write */\n+  current_unit->recl = g.max_offset;\n+\n   current_unit->bytes_left = current_unit->recl;\n }\n \n@@ -890,7 +895,11 @@ data_transfer_init (int read_flag)\n      memset (&u_flags, '\\0', sizeof (u_flags));\n      u_flags.access = ACCESS_SEQUENTIAL;\n      u_flags.action = ACTION_READWRITE;\n-     u_flags.form = FORM_UNSPECIFIED;\n+     /* is it unformatted ?*/\n+     if (ioparm.format == NULL && !ioparm.list_format)\n+       u_flags.form = FORM_UNFORMATTED;\n+     else\n+       u_flags.form = FORM_UNSPECIFIED;\n      u_flags.delim = DELIM_UNSPECIFIED;\n      u_flags.blank = BLANK_UNSPECIFIED;\n      u_flags.pad = PAD_UNSPECIFIED;"}, {"sha": "0c652581c0450740e28b0051b3367d73a7a0e01c", "filename": "libgfortran/io/unix.c", "status": "modified", "additions": 36, "deletions": 17, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1df0a046ed0a4d272d0ee2c2a930e3ad9d1831/libgfortran%2Fio%2Funix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1df0a046ed0a4d272d0ee2c2a930e3ad9d1831/libgfortran%2Fio%2Funix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funix.c?ref=bf1df0a046ed0a4d272d0ee2c2a930e3ad9d1831", "patch": "@@ -90,7 +90,7 @@ typedef struct\n   gfc_offset physical_offset;\t/* Current physical file offset */\n   gfc_offset logical_offset;\t/* Current logical file offset */\n   gfc_offset dirty_offset;\t/* Start of modified bytes in buffer */\n-  gfc_offset file_length;\t\t/* Length of the file, -1 if not seekable. */\n+  gfc_offset file_length;\t/* Length of the file, -1 if not seekable. */\n \n   char *buffer;\n   int len;\t\t\t/* Physical length of the current buffer */\n@@ -280,7 +280,9 @@ fd_flush (unix_stream * s)\n     return FAILURE;\n \n   s->physical_offset = s->dirty_offset + s->ndirty;\n-  if (s->physical_offset > s->file_length)\n+\n+  /* don't increment file_length if the file is non-seekable */\n+  if (s->file_length != -1 && s->physical_offset > s->file_length)\n     s->file_length = s->physical_offset;\n   s->ndirty = 0;\n \n@@ -406,18 +408,28 @@ fd_alloc_w_at (unix_stream * s, int *len, gfc_offset where)\n     }\n \n   /* Return a position within the current buffer */\n-\n-  if (s->ndirty == 0)\n-    {\t\t\t\t/* First write into a clean buffer */\n-      s->dirty_offset = where;\n-      s->ndirty = *len;\n+  if (s->ndirty == 0 \n+      || where > s->dirty_offset + s->ndirty    \n+      || s->dirty_offset > where + *len)\n+    {  /* Discontiguous blocks, start with a clean buffer.  */  \n+        /* Flush the buffer.  */  \n+       if (s->ndirty != 0)    \n+         fd_flush (s);  \n+       s->dirty_offset = where;  \n+       s->ndirty = *len;\n     }\n   else\n-    {\n-      if (s->dirty_offset + s->ndirty == where)\n-\ts->ndirty += *len;\n-      else\n-\tfd_flush (s);\t\t/* Can't combine two dirty blocks */\n+    {  \n+      gfc_offset start;  /* Merge with the existing data.  */  \n+      if (where < s->dirty_offset)    \n+        start = where;  \n+      else    \n+        start = s->dirty_offset;  \n+      if (where + *len > s->dirty_offset + s->ndirty)    \n+        s->ndirty = where + *len - start;  \n+      else    \n+        s->ndirty = s->dirty_offset + s->ndirty - start;  \n+        s->dirty_offset = start;\n     }\n \n   s->logical_offset = where + *len;\n@@ -461,13 +473,18 @@ static try\n fd_truncate (unix_stream * s)\n {\n \n-  if (ftruncate (s->fd, s->logical_offset))\n+  if (lseek (s->fd, s->logical_offset, SEEK_SET) == -1)\n     return FAILURE;\n \n-  s->physical_offset = s->file_length = s->logical_offset;\n+  /* non-seekable files, like terminals and fifo's fail the lseek.\n+     the fd is a regular file at this point */\n \n-  if (lseek (s->fd, s->file_length, SEEK_SET) == -1)\n+  if (ftruncate (s->fd, s->logical_offset))\n+   {\n     return FAILURE;\n+   }\n+\n+  s->physical_offset = s->file_length = s->logical_offset;\n \n   return SUCCESS;\n }\n@@ -1390,8 +1407,10 @@ file_position (stream * s)\n int\n is_seekable (stream * s)\n {\n-\n-  return ((unix_stream *) s)->mmaped;\n+  /* by convention, if file_length == -1, the file is not seekable\n+     note that a mmapped file is always seekable, an fd_ file may\n+     or may not be. */\n+  return ((unix_stream *) s)->file_length!=-1;\n }\n \n try"}]}