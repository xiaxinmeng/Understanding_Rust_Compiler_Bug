{"sha": "0c312c2dbb2459087f1c7a7d02a2d573a4fb2377", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGMzMTJjMmRiYjI0NTkwODdmMWM3YTdkMDJhMmQ1NzNhNGZiMjM3Nw==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2008-03-26T22:29:13Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2008-03-26T22:29:13Z"}, "message": "testsuite_abi.h: Remove symbol_objects, symbol_names typedefs.\n\n\n2008-03-26  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* testsuite/util/testsuite_abi.h: Remove symbol_objects,\n\tsymbol_names typedefs.\t\n\t* testsuite/util/testsuite_abi.cc (compare_symbols): Correct check\n\tfor long double compatiblity symbols, simplify data structures used.\n\nFrom-SVN: r133621", "tree": {"sha": "d0a079274cba1205fc7d654dcc3d05cbbcdf6d27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0a079274cba1205fc7d654dcc3d05cbbcdf6d27"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c312c2dbb2459087f1c7a7d02a2d573a4fb2377", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c312c2dbb2459087f1c7a7d02a2d573a4fb2377", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c312c2dbb2459087f1c7a7d02a2d573a4fb2377", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c312c2dbb2459087f1c7a7d02a2d573a4fb2377/comments", "author": null, "committer": null, "parents": [{"sha": "b8ab1f4adeb070fc6458b805e6985ab2c6d1f768", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8ab1f4adeb070fc6458b805e6985ab2c6d1f768", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8ab1f4adeb070fc6458b805e6985ab2c6d1f768"}], "stats": {"total": 167, "additions": 85, "deletions": 82}, "files": [{"sha": "4f2e2bd2c29f5fd028434912dc27e0d44ce53449", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c312c2dbb2459087f1c7a7d02a2d573a4fb2377/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c312c2dbb2459087f1c7a7d02a2d573a4fb2377/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=0c312c2dbb2459087f1c7a7d02a2d573a4fb2377", "patch": "@@ -1,3 +1,10 @@\n+2008-03-26  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* testsuite/util/testsuite_abi.h: Remove symbol_objects,\n+\tsymbol_names typedefs.\t\n+\t* testsuite/util/testsuite_abi.cc (compare_symbols): Correct check\n+\tfor long double compatiblity symbols, simplify data structures used.\n+\n 2008-03-25  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* scripts/run_doxygen: Remove html_output_dir. Downgrade to"}, {"sha": "6466fbabcd80b037aa64e3127bba6302f7fab151", "filename": "libstdc++-v3/testsuite/util/testsuite_abi.cc", "status": "modified", "additions": 73, "deletions": 74, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c312c2dbb2459087f1c7a7d02a2d573a4fb2377/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_abi.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c312c2dbb2459087f1c7a7d02a2d573a4fb2377/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_abi.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_abi.cc?ref=0c312c2dbb2459087f1c7a7d02a2d573a4fb2377", "patch": "@@ -218,6 +218,15 @@ check_version(symbol& test, bool added)\n       if (added && test.version_name == known_versions[0])\n \ttest.version_status = symbol::incompatible;\n       \n+      // Check that long double compatibility symbols demangled as\n+      // __float128 are put into some _LDBL_ version name.\n+      if (added && test.demangled_name.find(\"__float128\") != std::string::npos)\n+\t{\n+\t  // Has to be in _LDBL_ version name.\n+\t  if (test.version_name.find(\"_LDBL_\") == std::string::npos)\n+\t    test.version_status = symbol::incompatible;\n+\t}\n+\n       // Check for weak label.\n       if (it1 == end && it2 == end)\n \ttest.version_status = symbol::incompatible;\n@@ -294,28 +303,22 @@ check_compatible(symbol& lhs, symbol& rhs, bool verbose)\n }\n \n \n-bool\n-has_symbol(const string& mangled, const symbols& s) throw()\n-{\n-  const symbol_names& names = s.first;\n-  symbol_names::const_iterator i = find(names.begin(), names.end(), mangled);\n-  return i != names.end();\n-}\n+inline bool\n+has_symbol(const string& name, const symbols& s) throw()\n+{ return s.find(name) != s.end(); }\n \n-symbol&\n-get_symbol(const string& mangled, const symbols& s)\n+const symbol&\n+get_symbol(const string& name, const symbols& s)\n {\n-  const symbol_names& names = s.first;\n-  symbol_names::const_iterator i = find(names.begin(), names.end(), mangled);\n-  if (i != names.end())\n+  symbols::const_iterator i = s.find(name);\n+  if (i != s.end())\n     {\n-      symbol_objects objects = s.second;\n-      return objects[mangled];\n+      return i->second;\n     }\n   else\n     {\n       ostringstream os;\n-      os << \"get_symbol failed for symbol \" << mangled;\n+      os << \"get_symbol failed for symbol \" << name;\n       __throw_logic_error(os.str().c_str());\n     }\n }\n@@ -326,7 +329,7 @@ examine_symbol(const char* name, const char* file)\n   try\n     {\n       symbols s = create_symbols(file);\n-      symbol& sym = get_symbol(name, s);\n+      const symbol& sym = get_symbol(name, s);\n       sym.print();\n     }\n   catch(...)\n@@ -340,97 +343,95 @@ compare_symbols(const char* baseline_file, const char* test_file,\n   // Input both lists of symbols into container.\n   symbols baseline = create_symbols(baseline_file);\n   symbols test = create_symbols(test_file);\n-  symbol_names& baseline_names = baseline.first;\n-  symbol_objects& baseline_objects = baseline.second;\n-  symbol_names& test_names = test.first;\n-  symbol_objects& test_objects = test.second;\n \n   //  Sanity check results.\n-  const symbol_names::size_type baseline_size = baseline_names.size();\n-  const symbol_names::size_type test_size = test_names.size();\n-  if (!baseline_size || !test_size)\n+  if (!baseline.size() || !test.size())\n     {\n       cerr << \"Problems parsing the list of exported symbols.\" << endl;\n       exit(2);\n     }\n \n   // Check to see if any long double compatibility symbols are produced.\n   bool ld_version_found(false);\n-  symbol_objects::iterator li(test_objects.begin());\n-  while (!ld_version_found && li != test_objects.end())\n+  symbols::iterator li(test.begin());\n+  while (!ld_version_found && li != test.end())\n     {\n-      if (li->second.version_name.find(\"GLIBCXX_LDBL_\") != std::string::npos)\n+      if (li->second.version_name.find(\"_LDBL_\") != std::string::npos)\n \tld_version_found = true;\n       ++li;\n     }\n \n   // Sort out names.\n-  // Assuming baseline_names, test_names are both unique w/ no duplicates.\n+  // Assuming all baseline names and test names are both unique w/ no\n+  // duplicates.\n   //\n-  // The names added to missing_names are baseline_names not found in\n-  // test_names \n+  // The names added to missing_names are baseline names not found in\n+  // test names \n   // -> symbols that have been deleted.\n   //\n-  // The names added to added_names are test_names not in\n-  // baseline_names\n+  // The names added to added_names are test names not in\n+  // baseline names\n   // -> symbols that have been added.\n+  typedef std::vector<std::string> symbol_names;\n   symbol_names shared_names;\n   symbol_names missing_names;\n-  symbol_names added_names = test_names;\n-  for (size_t i = 0; i < baseline_size; ++i)\n+  symbol_names added_names;\n+  for (li = test.begin(); li != test.end(); ++li)\n+    added_names.push_back(li->first);\n+\n+  for (symbols::iterator i = baseline.begin(); i != baseline.end(); ++i)\n     {\n-      string what(baseline_names[i]);\n+      string name(i->first);\n       symbol_names::iterator end = added_names.end();\n-      symbol_names::iterator it = find(added_names.begin(), end, what);\n+      symbol_names::iterator it = find(added_names.begin(), end, name);\n       if (it != end)\n \t{\n \t  // Found.\n-\t  shared_names.push_back(what);\n+\t  shared_names.push_back(name);\n \t  added_names.erase(it);\n \t}\n-      else\n-\tmissing_names.push_back(what);\n+       else\n+\t{\n+\t  // Iff no test long double compatibility symbols at all and the symbol\n+\t  // missing is a baseline long double compatibility symbol, skip.\n+\t  string version_name(i->second.version_name);\n+\t  bool base_ld(version_name.find(\"_LDBL_\") != std::string::npos);\n+\t  if (!base_ld || base_ld && ld_version_found)\n+\t    missing_names.push_back(name);\n+\t}\n     }\n \n-  // Check missing names for compatibility.\n+  // Fill out list of incompatible symbols.\n   typedef pair<symbol, symbol> symbol_pair;\n   vector<symbol_pair> incompatible;\n-  const symbol_names::size_type missing_size = missing_names.size();\n-  for (size_t j = 0; j < missing_size; ++j)\n+\n+  // Check missing names for compatibility.\n+  for (size_t j = 0; j < missing_names.size(); ++j)\n     {\n-      symbol& base = baseline_objects[missing_names[j]];\n-      \n-      // Iff no test long double symbols at all and the symbol missing\n-      // is a baseline long double symbol, skip.\n-      if (!ld_version_found\n-\t  && base.version_name.find(\"GLIBCXX_LDBL_\") != std::string::npos)\n-\tcontinue;\n-      else\n-\t{\n-\t  base.status = symbol::subtracted;\n-\t  incompatible.push_back(symbol_pair(base, base));\n-\t}\n+      symbol& sbase = baseline[missing_names[j]];\n+      sbase.status = symbol::subtracted;\n+      incompatible.push_back(symbol_pair(sbase, sbase));\n     }\n \n   // Check shared names for compatibility.\n   const symbol_names::size_type shared_size = shared_names.size();\n   for (size_t k = 0; k < shared_size; ++k)\n     {\n-      symbol& base = baseline_objects[shared_names[k]];\n-      symbol& test = test_objects[shared_names[k]];\n-      test.status = symbol::existing;\n-      if (!check_compatible(base, test))\n-\tincompatible.push_back(symbol_pair(base, test));\n+      symbol& sbase = baseline[shared_names[k]];\n+      symbol& stest = test[shared_names[k]];\n+      stest.status = symbol::existing;\n+      if (!check_compatible(sbase, stest))\n+\tincompatible.push_back(symbol_pair(sbase, stest));\n     }\n \n   // Check added names for compatibility.\n   const symbol_names::size_type added_size = added_names.size();\n   for (size_t l = 0; l < added_size; ++l)\n     {\n-      symbol& test = test_objects[added_names[l]];\n-      test.status = symbol::added;\n-      if (!check_version(test, true))\n-\tincompatible.push_back(symbol_pair(test, test));\n+      symbol& stest = test[added_names[l]];\n+      stest.status = symbol::added;\n+      if (!check_version(stest, true))\n+\tincompatible.push_back(symbol_pair(stest, stest));\n     }\n \n   // Report results.\n@@ -440,7 +441,7 @@ compare_symbols(const char* baseline_file, const char* test_file,\n       for (size_t j = 0; j < added_names.size() ; ++j)\n \t{\n \t  cout << j << endl;\n-\t  test_objects[added_names[j]].print();\n+\t  test[added_names[j]].print();\n \t}\n     }\n   \n@@ -450,7 +451,7 @@ compare_symbols(const char* baseline_file, const char* test_file,\n       for (size_t j = 0; j < missing_names.size() ; ++j)\n \t{\n \t  cout << j << endl;\n-\t  baseline_objects[missing_names[j]].print();\n+\t  baseline[missing_names[j]].print();\n \t}\n     }\n   \n@@ -463,12 +464,12 @@ compare_symbols(const char* baseline_file, const char* test_file,\n \t  cout << j << endl;\n \n \t  // Second, report name.\n-\t  symbol& base = incompatible[j].first;\n-\t  symbol& test = incompatible[j].second;\n-\t  test.print();\n+\t  symbol& sbase = incompatible[j].first;\n+\t  symbol& stest = incompatible[j].second;\n+\t  stest.print();\n \t  \n \t  // Second, report reason or reasons incompatible.\n-\t  check_compatible(base, test, true);\n+\t  check_compatible(sbase, stest, true);\n \t}\n     }\n   \n@@ -491,18 +492,16 @@ create_symbols(const char* file)\n   ifstream ifs(file);\n   if (ifs.is_open())\n     {\n-      // Organize file data into container of symbol objects, and a\n-      // container of mangled names without versioning information.\n-      symbol_names& names = s.first;\n-      symbol_objects& objects = s.second;\n+      // Organize file data into an associated container (symbols) of symbol\n+      // objects mapped to mangled names without versioning\n+      // information.\n       const string empty;\n       string line = empty;\n       while (getline(ifs, line).good())\n \t{\n \t  symbol tmp;\n \t  tmp.init(line);\n-\t  objects[tmp.name] = tmp;\n-\t  names.push_back(tmp.name);\n+\t  s[tmp.name] = tmp;\n \t  line = empty;\n \t}\n     }"}, {"sha": "4b148d11b667e0b247bc8a1080ad227ae55c135a", "filename": "libstdc++-v3/testsuite/util/testsuite_abi.h", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c312c2dbb2459087f1c7a7d02a2d573a4fb2377/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_abi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c312c2dbb2459087f1c7a7d02a2d573a4fb2377/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_abi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_abi.h?ref=0c312c2dbb2459087f1c7a7d02a2d573a4fb2377", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n \n-// Copyright (C) 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n+// Copyright (C) 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n \n // This library is free software; you can redistribute it and/or\n // modify it under the terms of the GNU General Public License as\n@@ -31,7 +31,7 @@\n \n #include <string>\n #include <stdexcept>\n-#include <deque>\n+#include <vector>\n #include <locale>\n #include <tr1/unordered_map>\n #include <cxxabi.h>\n@@ -75,11 +75,8 @@ struct symbol\n   init(std::string& data);\n };\n \n-typedef std::tr1::unordered_map<std::string, symbol> \tsymbol_objects;\n-\n-typedef std::deque<std::string>\t\t\t\tsymbol_names;\n-\n-typedef std::pair<symbol_names, symbol_objects>\t\tsymbols;\n+// Map type between symbol names and full symbol info.\n+typedef std::tr1::unordered_map<std::string, symbol> \tsymbols;\n \n \n // Check.\n@@ -94,7 +91,7 @@ check_compatible(symbol& lhs, symbol& rhs, bool verbose = false);\n bool\n has_symbol(const std::string& mangled, const symbols& list) throw();\n \n-symbol&\n+const symbol&\n get_symbol(const std::string& mangled, const symbols& list);\n \n extern \"C\" void"}]}