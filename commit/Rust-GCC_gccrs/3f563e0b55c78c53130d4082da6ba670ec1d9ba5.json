{"sha": "3f563e0b55c78c53130d4082da6ba670ec1d9ba5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Y1NjNlMGI1NWM3OGM1MzEzMGQ0MDgyZGE2YmE2NzBlYzFkOWJhNQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2017-10-27T18:13:14Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2017-10-27T18:13:14Z"}, "message": "re PR target/82692 (Ordered comparisons used for unordered built-ins)\n\n\tPR target/82692\n\t* config/i386/i386-modes.def (CCFPU): Remove definition.\n\t* config/i386/i386.c (put_condition_mode): Remove CCFPU mode handling.\n\t(ix86_cc_modes_compatible): Ditto.\n\t(ix86_expand_carry_flag_compare): Ditto.\n\t(ix86_expand_int_movcc): Ditto.\n\t(ix86_expand_int_addcc): Ditto.\n\t(ix86_reverse_condition): Ditto.\n\t(ix86_unordered_fp_compare): Rename from ix86_fp_compare_mode.\n\tReturn true/false for unordered/ordered fp comparisons.\n\t(ix86_cc_mode): Always return CCFPmode for float mode comparisons.\n\t(ix86_prepare_fp_compare_args): Update for rename.\n\t(ix86_expand_fp_compare): Update for rename.  Generate unordered\n\tcompare RTXes wrapped with UNSPEC_NOTRAP unspec.\n\t(ix86_expand_sse_compare_and_jump): Ditto.\n\t* config/i386/predicates.md (fcmov_comparison_operator):\n\tRemove CCFPU mode handling.\n\t(ix86_comparison_operator): Ditto.\n\t(ix86_carry_flag_operator): Ditto.\n\t* config/i386/i386.md (UNSPEC_NOTRAP): New unspec.\n\t(*cmpu<mode>_i387): Wrap compare RTX with UNSPEC_NOTRAP unspec.\n\t(*cmpu<mode>_cc_i387): Ditto.\n\t(FPCMP): Remove mode iterator.\n\t(unord): Remove mode attribute.\n\t(unord_subst): New define_subst transformation\n\t(unord): New define_subst attribute.\n\t(unordered): Ditto.\n\t(*cmpi<unord><MODEF:mode>): Rewrite using unord_subst transformation.\n\t(*cmpi<unord>xf_i387): Ditto.\n\t* config/i386/sse.md (<sse>_<unord>comi<round_saeonly_name>): Merge\n\tfrom <sse>_comi<round_saeonly_name> and <sse>_ucomi<round_saeonly_name>\n\tusing unord_subst transformation.\n\t* config/i386/subst.md (SUBST_A): Remove CCFP and CCFPU modes.\n\t(round_saeonly): Also handle CCFP mode.\n\t* reg-stack.c (subst_stack_regs_pat): Handle UNSPEC_NOTRAP unspec.\n\tRemove UNSPEC_SAHF unspec handling.\n\ntestsuite/ChangeLog:\n\n\tPR target/82692\n\t* gcc.dg/torture/pr82692.c: New test.\n\nFrom-SVN: r254167", "tree": {"sha": "5af560de442226cf7a9e26e94255a1d408a4f722", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5af560de442226cf7a9e26e94255a1d408a4f722"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f563e0b55c78c53130d4082da6ba670ec1d9ba5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f563e0b55c78c53130d4082da6ba670ec1d9ba5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f563e0b55c78c53130d4082da6ba670ec1d9ba5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f563e0b55c78c53130d4082da6ba670ec1d9ba5/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "68d1c4bfd74adad56b748125cd463940928e09da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68d1c4bfd74adad56b748125cd463940928e09da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68d1c4bfd74adad56b748125cd463940928e09da"}], "stats": {"total": 285, "additions": 177, "deletions": 108}, "files": [{"sha": "7c3f1e5459028ffeaf90c9f3f3aede76db4f4995", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f563e0b55c78c53130d4082da6ba670ec1d9ba5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f563e0b55c78c53130d4082da6ba670ec1d9ba5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3f563e0b55c78c53130d4082da6ba670ec1d9ba5", "patch": "@@ -1,3 +1,42 @@\n+2017-10-27  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR target/82692\n+\t* config/i386/i386-modes.def (CCFPU): Remove definition.\n+\t* config/i386/i386.c (put_condition_mode): Remove CCFPU mode handling.\n+\t(ix86_cc_modes_compatible): Ditto.\n+\t(ix86_expand_carry_flag_compare): Ditto.\n+\t(ix86_expand_int_movcc): Ditto.\n+\t(ix86_expand_int_addcc): Ditto.\n+\t(ix86_reverse_condition): Ditto.\n+\t(ix86_unordered_fp_compare): Rename from ix86_fp_compare_mode.\n+\tReturn true/false for unordered/ordered fp comparisons.\n+\t(ix86_cc_mode): Always return CCFPmode for float mode comparisons.\n+\t(ix86_prepare_fp_compare_args): Update for rename.\n+\t(ix86_expand_fp_compare): Update for rename.  Generate unordered\n+\tcompare RTXes wrapped with UNSPEC_NOTRAP unspec.\n+\t(ix86_expand_sse_compare_and_jump): Ditto.\n+\t* config/i386/predicates.md (fcmov_comparison_operator):\n+\tRemove CCFPU mode handling.\n+\t(ix86_comparison_operator): Ditto.\n+\t(ix86_carry_flag_operator): Ditto.\n+\t* config/i386/i386.md (UNSPEC_NOTRAP): New unspec.\n+\t(*cmpu<mode>_i387): Wrap compare RTX with UNSPEC_NOTRAP unspec.\n+\t(*cmpu<mode>_cc_i387): Ditto.\n+\t(FPCMP): Remove mode iterator.\n+\t(unord): Remove mode attribute.\n+\t(unord_subst): New define_subst transformation\n+\t(unord): New define_subst attribute.\n+\t(unordered): Ditto.\n+\t(*cmpi<unord><MODEF:mode>): Rewrite using unord_subst transformation.\n+\t(*cmpi<unord>xf_i387): Ditto.\n+\t* config/i386/sse.md (<sse>_<unord>comi<round_saeonly_name>): Merge\n+\tfrom <sse>_comi<round_saeonly_name> and <sse>_ucomi<round_saeonly_name>\n+\tusing unord_subst transformation.\n+\t* config/i386/subst.md (SUBST_A): Remove CCFP and CCFPU modes.\n+\t(round_saeonly): Also handle CCFP mode.\n+\t* reg-stack.c (subst_stack_regs_pat): Handle UNSPEC_NOTRAP unspec.\n+\tRemove UNSPEC_SAHF unspec handling.\n+\n 2017-10-27  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* x86-tune.def (X86_TUNE_INTER_UNIT_MOVES_TO_VEC): Disable for Zen."}, {"sha": "dcf6854b57dbc2a5eded13485663af79162013ae", "filename": "gcc/config/i386/i386-modes.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f563e0b55c78c53130d4082da6ba670ec1d9ba5/gcc%2Fconfig%2Fi386%2Fi386-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f563e0b55c78c53130d4082da6ba670ec1d9ba5/gcc%2Fconfig%2Fi386%2Fi386-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-modes.def?ref=3f563e0b55c78c53130d4082da6ba670ec1d9ba5", "patch": "@@ -72,8 +72,8 @@ CC_MODE (CCO);\n CC_MODE (CCP);\n CC_MODE (CCS);\n CC_MODE (CCZ);\n+\n CC_MODE (CCFP);\n-CC_MODE (CCFPU);\n \n /* Vector modes.  Note that VEC_CONCAT patterns require vector\n    sizes twice as big as implemented in hardware.  */"}, {"sha": "8a2e2dac6b703aa6e002a0e57792e02c20bfbe9b", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 39, "deletions": 37, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f563e0b55c78c53130d4082da6ba670ec1d9ba5/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f563e0b55c78c53130d4082da6ba670ec1d9ba5/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=3f563e0b55c78c53130d4082da6ba670ec1d9ba5", "patch": "@@ -16930,7 +16930,7 @@ put_condition_code (enum rtx_code code, machine_mode mode, bool reverse,\n {\n   const char *suffix;\n \n-  if (mode == CCFPmode || mode == CCFPUmode)\n+  if (mode == CCFPmode)\n     {\n       code = ix86_fp_compare_code_to_integer (code);\n       mode = CCmode;\n@@ -21695,22 +21695,21 @@ ix86_expand_int_compare (enum rtx_code code, rtx op0, rtx op1)\n   return gen_rtx_fmt_ee (code, VOIDmode, flags, const0_rtx);\n }\n \n-/* Figure out whether to use ordered or unordered fp comparisons.\n-   Return the appropriate mode to use.  */\n+/* Figure out whether to use unordered fp comparisons.  */\n \n-machine_mode\n-ix86_fp_compare_mode (enum rtx_code code)\n+static bool\n+ix86_unordered_fp_compare (enum rtx_code code)\n {\n   if (!TARGET_IEEE_FP)\n-    return CCFPmode;\n+    return false;\n \n   switch (code)\n     {\n     case GT:\n     case GE:\n     case LT:\n     case LE:\n-      return CCFPmode;\n+      return false;\n \n     case EQ:\n     case NE:\n@@ -21723,7 +21722,7 @@ ix86_fp_compare_mode (enum rtx_code code)\n     case UNGT:\n     case UNGE:\n     case UNEQ:\n-      return CCFPUmode;\n+      return true;\n \n     default:\n       gcc_unreachable ();\n@@ -21738,7 +21737,7 @@ ix86_cc_mode (enum rtx_code code, rtx op0, rtx op1)\n   if (SCALAR_FLOAT_MODE_P (mode))\n     {\n       gcc_assert (!DECIMAL_FLOAT_MODE_P (mode));\n-      return ix86_fp_compare_mode (code);\n+      return CCFPmode;\n     }\n \n   switch (code)\n@@ -21860,7 +21859,6 @@ ix86_cc_modes_compatible (machine_mode m1, machine_mode m2)\n \t}\n \n     case E_CCFPmode:\n-    case E_CCFPUmode:\n       /* These are only compatible with themselves, which we already\n \t checked above.  */\n       return VOIDmode;\n@@ -21964,7 +21962,7 @@ ix86_fp_comparison_strategy (enum rtx_code)\n static enum rtx_code\n ix86_prepare_fp_compare_args (enum rtx_code code, rtx *pop0, rtx *pop1)\n {\n-  machine_mode fpcmp_mode = ix86_fp_compare_mode (code);\n+  bool unordered_compare = ix86_unordered_fp_compare (code);\n   rtx op0 = *pop0, op1 = *pop1;\n   machine_mode op_mode = GET_MODE (op0);\n   bool is_sse = TARGET_SSE_MATH && SSE_FLOAT_MODE_P (op_mode);\n@@ -21976,7 +21974,7 @@ ix86_prepare_fp_compare_args (enum rtx_code code, rtx *pop0, rtx *pop1)\n      floating point.  */\n \n   if (!is_sse\n-      && (fpcmp_mode == CCFPUmode\n+      && (unordered_compare\n \t  || (op_mode == XFmode\n \t      && ! (standard_80387_constant_p (op0) == 1\n \t\t    || standard_80387_constant_p (op1) == 1)\n@@ -22073,27 +22071,29 @@ ix86_fp_compare_code_to_integer (enum rtx_code code)\n static rtx\n ix86_expand_fp_compare (enum rtx_code code, rtx op0, rtx op1, rtx scratch)\n {\n-  machine_mode fpcmp_mode, intcmp_mode;\n+  bool unordered_compare = ix86_unordered_fp_compare (code);\n+  machine_mode intcmp_mode;\n   rtx tmp, tmp2;\n \n-  fpcmp_mode = ix86_fp_compare_mode (code);\n   code = ix86_prepare_fp_compare_args (code, &op0, &op1);\n \n   /* Do fcomi/sahf based test when profitable.  */\n   switch (ix86_fp_comparison_strategy (code))\n     {\n     case IX86_FPCMP_COMI:\n-      intcmp_mode = fpcmp_mode;\n-      tmp = gen_rtx_COMPARE (fpcmp_mode, op0, op1);\n-      tmp = gen_rtx_SET (gen_rtx_REG (fpcmp_mode, FLAGS_REG), tmp);\n-      emit_insn (tmp);\n+      intcmp_mode = CCFPmode;\n+      tmp = gen_rtx_COMPARE (CCFPmode, op0, op1);\n+      if (unordered_compare)\n+\ttmp = gen_rtx_UNSPEC (CCFPmode, gen_rtvec (1, tmp), UNSPEC_NOTRAP);\n+      emit_insn (gen_rtx_SET (gen_rtx_REG (CCFPmode, FLAGS_REG), tmp));\n       break;\n \n     case IX86_FPCMP_SAHF:\n-      intcmp_mode = fpcmp_mode;\n-      tmp = gen_rtx_COMPARE (fpcmp_mode, op0, op1);\n-      tmp = gen_rtx_SET (gen_rtx_REG (fpcmp_mode, FLAGS_REG), tmp);\n-\n+      intcmp_mode = CCFPmode;\n+      tmp = gen_rtx_COMPARE (CCFPmode, op0, op1);\n+      if (unordered_compare)\n+\ttmp = gen_rtx_UNSPEC (CCFPmode, gen_rtvec (1, tmp), UNSPEC_NOTRAP);\n+      tmp = gen_rtx_SET (gen_rtx_REG (CCFPmode, FLAGS_REG), tmp);\n       if (!scratch)\n \tscratch = gen_reg_rtx (HImode);\n       tmp2 = gen_rtx_CLOBBER (VOIDmode, scratch);\n@@ -22102,11 +22102,13 @@ ix86_expand_fp_compare (enum rtx_code code, rtx op0, rtx op1, rtx scratch)\n \n     case IX86_FPCMP_ARITH:\n       /* Sadness wrt reg-stack pops killing fpsr -- gotta get fnstsw first.  */\n-      tmp = gen_rtx_COMPARE (fpcmp_mode, op0, op1);\n-      tmp2 = gen_rtx_UNSPEC (HImode, gen_rtvec (1, tmp), UNSPEC_FNSTSW);\n+      tmp = gen_rtx_COMPARE (CCFPmode, op0, op1);\n+      if (unordered_compare)\n+\ttmp = gen_rtx_UNSPEC (CCFPmode, gen_rtvec (1, tmp), UNSPEC_NOTRAP);\n+      tmp = gen_rtx_UNSPEC (HImode, gen_rtvec (1, tmp), UNSPEC_FNSTSW);\n       if (!scratch)\n \tscratch = gen_reg_rtx (HImode);\n-      emit_insn (gen_rtx_SET (scratch, tmp2));\n+      emit_insn (gen_rtx_SET (scratch, tmp));\n \n       /* In the unordered case, we have to check C2 for NaN's, which\n \t doesn't happen to work out to anything nice combination-wise.\n@@ -22548,8 +22550,7 @@ ix86_expand_carry_flag_compare (enum rtx_code code, rtx op0, rtx op1, rtx *pop)\n       compare_seq = get_insns ();\n       end_sequence ();\n \n-      if (GET_MODE (XEXP (compare_op, 0)) == CCFPmode\n-\t  || GET_MODE (XEXP (compare_op, 0)) == CCFPUmode)\n+      if (GET_MODE (XEXP (compare_op, 0)) == CCFPmode)\n         code = ix86_fp_compare_code_to_integer (GET_CODE (compare_op));\n       else\n \tcode = GET_CODE (compare_op);\n@@ -22689,8 +22690,7 @@ ix86_expand_int_movcc (rtx operands[])\n \n \t      flags = XEXP (compare_op, 0);\n \n-\t      if (GET_MODE (flags) == CCFPmode\n-\t\t  || GET_MODE (flags) == CCFPUmode)\n+\t      if (GET_MODE (flags) == CCFPmode)\n \t\t{\n \t\t  fpcmp = true;\n \t\t  compare_code\n@@ -24730,8 +24730,7 @@ ix86_expand_int_addcc (rtx operands[])\n \n   flags = XEXP (compare_op, 0);\n \n-  if (GET_MODE (flags) == CCFPmode\n-      || GET_MODE (flags) == CCFPUmode)\n+  if (GET_MODE (flags) == CCFPmode)\n     {\n       fpcmp = true;\n       code = ix86_fp_compare_code_to_integer (code);\n@@ -43190,7 +43189,7 @@ ix86_encode_section_info (tree decl, rtx rtl, int first)\n enum rtx_code\n ix86_reverse_condition (enum rtx_code code, machine_mode mode)\n {\n-  return (mode != CCFPmode && mode != CCFPUmode\n+  return (mode != CCFPmode\n \t  ? reverse_condition (code)\n \t  : reverse_condition_maybe_unordered (code));\n }\n@@ -43805,17 +43804,20 @@ static rtx_code_label *\n ix86_expand_sse_compare_and_jump (enum rtx_code code, rtx op0, rtx op1,\n                                   bool swap_operands)\n {\n-  machine_mode fpcmp_mode = ix86_fp_compare_mode (code);\n+  bool unordered_compare = ix86_unordered_fp_compare (code);\n   rtx_code_label *label;\n-  rtx tmp;\n+  rtx tmp, reg;\n \n   if (swap_operands)\n     std::swap (op0, op1);\n \n   label = gen_label_rtx ();\n-  tmp = gen_rtx_REG (fpcmp_mode, FLAGS_REG);\n-  emit_insn (gen_rtx_SET (tmp, gen_rtx_COMPARE (fpcmp_mode, op0, op1)));\n-  tmp = gen_rtx_fmt_ee (code, VOIDmode, tmp, const0_rtx);\n+  tmp = gen_rtx_COMPARE (CCFPmode, op0, op1);\n+  if (unordered_compare)\n+    tmp = gen_rtx_UNSPEC (CCFPmode, gen_rtvec (1, tmp), UNSPEC_NOTRAP);\n+  reg = gen_rtx_REG (CCFPmode, FLAGS_REG);\n+  emit_insn (gen_rtx_SET (reg, tmp));\n+  tmp = gen_rtx_fmt_ee (code, VOIDmode, reg, const0_rtx);\n   tmp = gen_rtx_IF_THEN_ELSE (VOIDmode, tmp,\n \t\t\t      gen_rtx_LABEL_REF (VOIDmode, label), pc_rtx);\n   tmp = emit_jump_insn (gen_rtx_SET (pc_rtx, tmp));"}, {"sha": "d48decbb7d99768567be64b5537fe468a0511947", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 35, "deletions": 24, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f563e0b55c78c53130d4082da6ba670ec1d9ba5/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f563e0b55c78c53130d4082da6ba670ec1d9ba5/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=3f563e0b55c78c53130d4082da6ba670ec1d9ba5", "patch": "@@ -99,6 +99,7 @@\n   UNSPEC_SCAS\n   UNSPEC_FNSTSW\n   UNSPEC_SAHF\n+  UNSPEC_NOTRAP\n   UNSPEC_PARITY\n   UNSPEC_FSTCW\n   UNSPEC_FLDCW\n@@ -1478,9 +1479,6 @@\n \n ;; FP compares, step 1:\n ;; Set the FP condition codes.\n-;;\n-;; CCFPmode\tcompare with exceptions\n-;; CCFPUmode\tcompare with no exceptions\n \n ;; We may not use \"#\" to split and emit these, since the REG_DEAD notes\n ;; used to manage the reg stack popping would not be preserved.\n@@ -1587,9 +1585,11 @@\n (define_insn \"*cmpu<mode>_i387\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=a\")\n \t(unspec:HI\n-\t  [(compare:CCFPU\n-\t     (match_operand:X87MODEF 1 \"register_operand\" \"f\")\n-\t     (match_operand:X87MODEF 2 \"register_operand\" \"f\"))]\n+\t  [(unspec:CCFP\n+\t     [(compare:CCFP\n+\t\t(match_operand:X87MODEF 1 \"register_operand\" \"f\")\n+\t\t(match_operand:X87MODEF 2 \"register_operand\" \"f\"))]\n+\t     UNSPEC_NOTRAP)]\n \t  UNSPEC_FNSTSW))]\n   \"TARGET_80387\"\n   \"* return output_fp_compare (insn, operands, false, true);\"\n@@ -1598,18 +1598,22 @@\n    (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn_and_split \"*cmpu<mode>_cc_i387\"\n-  [(set (reg:CCFPU FLAGS_REG)\n-\t(compare:CCFPU\n-\t  (match_operand:X87MODEF 1 \"register_operand\" \"f\")\n-\t  (match_operand:X87MODEF 2 \"register_operand\" \"f\")))\n+  [(set (reg:CCFP FLAGS_REG)\n+\t(unspec:CCFP\n+\t  [(compare:CCFP\n+\t     (match_operand:X87MODEF 1 \"register_operand\" \"f\")\n+\t     (match_operand:X87MODEF 2 \"register_operand\" \"f\"))]\n+\t  UNSPEC_NOTRAP))\n    (clobber (match_operand:HI 0 \"register_operand\" \"=a\"))]\n   \"TARGET_80387 && TARGET_SAHF && !TARGET_CMOVE\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 0)\n \t(unspec:HI\n-\t  [(compare:CCFPU (match_dup 1)(match_dup 2))]\n-\tUNSPEC_FNSTSW))\n+\t  [(unspec:CCFP\n+\t     [(compare:CCFP (match_dup 1)(match_dup 2))]\n+\t     UNSPEC_NOTRAP)]\n+\t  UNSPEC_FNSTSW))\n    (set (reg:CC FLAGS_REG)\n \t(unspec:CC [(match_dup 0)] UNSPEC_SAHF))]\n   \"\"\n@@ -1697,20 +1701,28 @@\n ;; Pentium Pro can do steps 1 through 3 in one go.\n ;; (these instructions set flags directly)\n \n-(define_mode_iterator FPCMP [CCFP CCFPU])\n-(define_mode_attr unord [(CCFP \"\") (CCFPU \"u\")])\n+(define_subst_attr \"unord\" \"unord_subst\" \"\" \"u\")\n+(define_subst_attr \"unordered\" \"unord_subst\" \"false\" \"true\")\n+\n+(define_subst \"unord_subst\"\n+  [(set (match_operand:CCFP 0)\n+        (match_operand:CCFP 1))]\n+  \"\"\n+  [(set (match_dup 0)\n+        (unspec:CCFP\n+\t  [(match_dup 1)]\n+\t  UNSPEC_NOTRAP))])\n \n-(define_insn \"*cmpi<FPCMP:unord><MODEF:mode>\"\n-  [(set (reg:FPCMP FLAGS_REG)\n-\t(compare:FPCMP\n+(define_insn \"*cmpi<unord><MODEF:mode>\"\n+  [(set (reg:CCFP FLAGS_REG)\n+\t(compare:CCFP\n \t  (match_operand:MODEF 0 \"register_operand\" \"f,v\")\n \t  (match_operand:MODEF 1 \"register_ssemem_operand\" \"f,vm\")))]\n   \"(SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_SSE_MATH)\n    || (TARGET_80387 && TARGET_CMOVE)\"\n   \"@\n-   * return output_fp_compare (insn, operands, true, \\\n-\t\t\t       <FPCMP:MODE>mode == CCFPUmode);\n-   %v<FPCMP:unord>comi<MODEF:ssemodesuffix>\\t{%1, %0|%0, %1}\"\n+   * return output_fp_compare (insn, operands, true, <unordered>);\n+   %v<unord>comi<MODEF:ssemodesuffix>\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"fcmp,ssecomi\")\n    (set_attr \"prefix\" \"orig,maybe_vex\")\n    (set_attr \"mode\" \"<MODEF:MODE>\")\n@@ -1739,13 +1751,12 @@\n \t (symbol_ref \"false\"))))])\n \n (define_insn \"*cmpi<unord>xf_i387\"\n-  [(set (reg:FPCMP FLAGS_REG)\n-\t(compare:FPCMP\n+  [(set (reg:CCFP FLAGS_REG)\n+\t(compare:CCFP\n \t  (match_operand:XF 0 \"register_operand\" \"f\")\n \t  (match_operand:XF 1 \"register_operand\" \"f\")))]\n   \"TARGET_80387 && TARGET_CMOVE\"\n-  \"* return output_fp_compare (insn, operands, true,\n-\t\t\t       <MODE>mode == CCFPUmode);\"\n+  \"* return output_fp_compare (insn, operands, true, <unordered>);\"\n   [(set_attr \"type\" \"fcmp\")\n    (set_attr \"mode\" \"XF\")\n    (set_attr \"athlon_decode\" \"vector\")"}, {"sha": "be9be85a3f24b49d04a29765de45bb1451c716fc", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f563e0b55c78c53130d4082da6ba670ec1d9ba5/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f563e0b55c78c53130d4082da6ba670ec1d9ba5/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=3f563e0b55c78c53130d4082da6ba670ec1d9ba5", "patch": "@@ -1301,7 +1301,7 @@\n   machine_mode inmode = GET_MODE (XEXP (op, 0));\n   enum rtx_code code = GET_CODE (op);\n \n-  if (inmode == CCFPmode || inmode == CCFPUmode)\n+  if (inmode == CCFPmode)\n     {\n       if (!ix86_trivial_fp_comparison_operator (op, mode))\n \treturn false;\n@@ -1311,7 +1311,7 @@\n   switch (code)\n     {\n     case LTU: case GTU: case LEU: case GEU:\n-      if (inmode == CCmode || inmode == CCFPmode || inmode == CCFPUmode\n+      if (inmode == CCmode || inmode == CCFPmode\n \t  || inmode == CCCmode)\n \treturn true;\n       return false;\n@@ -1348,7 +1348,7 @@\n   machine_mode inmode = GET_MODE (XEXP (op, 0));\n   enum rtx_code code = GET_CODE (op);\n \n-  if (inmode == CCFPmode || inmode == CCFPUmode)\n+  if (inmode == CCFPmode)\n     return ix86_trivial_fp_comparison_operator (op, mode);\n \n   switch (code)\n@@ -1391,7 +1391,7 @@\n   machine_mode inmode = GET_MODE (XEXP (op, 0));\n   enum rtx_code code = GET_CODE (op);\n \n-  if (inmode == CCFPmode || inmode == CCFPUmode)\n+  if (inmode == CCFPmode)\n     {\n       if (!ix86_trivial_fp_comparison_operator (op, mode))\n \treturn false;"}, {"sha": "562751555446cbe6f67a80bd48ba917e275ec6ce", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f563e0b55c78c53130d4082da6ba670ec1d9ba5/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f563e0b55c78c53130d4082da6ba670ec1d9ba5/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=3f563e0b55c78c53130d4082da6ba670ec1d9ba5", "patch": "@@ -2755,7 +2755,7 @@\n    (set_attr \"prefix\" \"evex\")\n    (set_attr \"mode\" \"<sseinsnmode>\")])\n \n-(define_insn \"<sse>_comi<round_saeonly_name>\"\n+(define_insn \"<sse>_<unord>comi<round_saeonly_name>\"\n   [(set (reg:CCFP FLAGS_REG)\n \t(compare:CCFP\n \t  (vec_select:MODEF\n@@ -2765,27 +2765,7 @@\n \t    (match_operand:<ssevecmode> 1 \"<round_saeonly_nimm_scalar_predicate>\" \"<round_saeonly_constraint>\")\n \t    (parallel [(const_int 0)]))))]\n   \"SSE_FLOAT_MODE_P (<MODE>mode)\"\n-  \"%vcomi<ssemodesuffix>\\t{<round_saeonly_op2>%1, %0|%0, %<iptr>1<round_saeonly_op2>}\"\n-  [(set_attr \"type\" \"ssecomi\")\n-   (set_attr \"prefix\" \"maybe_vex\")\n-   (set_attr \"prefix_rep\" \"0\")\n-   (set (attr \"prefix_data16\")\n-\t(if_then_else (eq_attr \"mode\" \"DF\")\n-\t\t      (const_string \"1\")\n-\t\t      (const_string \"0\")))\n-   (set_attr \"mode\" \"<MODE>\")])\n-\n-(define_insn \"<sse>_ucomi<round_saeonly_name>\"\n-  [(set (reg:CCFPU FLAGS_REG)\n-\t(compare:CCFPU\n-\t  (vec_select:MODEF\n-\t    (match_operand:<ssevecmode> 0 \"register_operand\" \"v\")\n-\t    (parallel [(const_int 0)]))\n-\t  (vec_select:MODEF\n-\t    (match_operand:<ssevecmode> 1 \"<round_saeonly_nimm_scalar_predicate>\" \"<round_saeonly_constraint>\")\n-\t    (parallel [(const_int 0)]))))]\n-  \"SSE_FLOAT_MODE_P (<MODE>mode)\"\n-  \"%vucomi<ssemodesuffix>\\t{<round_saeonly_op2>%1, %0|%0, %<iptr>1<round_saeonly_op2>}\"\n+  \"%v<unord>comi<ssemodesuffix>\\t{<round_saeonly_op2>%1, %0|%0, %<iptr>1<round_saeonly_op2>}\"\n   [(set_attr \"type\" \"ssecomi\")\n    (set_attr \"prefix\" \"maybe_vex\")\n    (set_attr \"prefix_rep\" \"0\")"}, {"sha": "d9100c8d6b0e9575427cafa1646663edfc518dbb", "filename": "gcc/config/i386/subst.md", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f563e0b55c78c53130d4082da6ba670ec1d9ba5/gcc%2Fconfig%2Fi386%2Fsubst.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f563e0b55c78c53130d4082da6ba670ec1d9ba5/gcc%2Fconfig%2Fi386%2Fsubst.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsubst.md?ref=3f563e0b55c78c53130d4082da6ba670ec1d9ba5", "patch": "@@ -37,8 +37,7 @@\n    V8DI  V4DI  V2DI\n    V16SF V8SF  V4SF\n    V8DF  V4DF  V2DF\n-   QI HI SI DI SF DF\n-   CCFP CCFPU])\n+   QI HI SI DI SF DF])\n \n (define_subst_attr \"mask_name\" \"mask\" \"\" \"_mask\")\n (define_subst_attr \"mask_applied\" \"mask\" \"false\" \"true\")\n@@ -183,6 +182,16 @@\n \t  UNSPEC_EMBEDDED_ROUNDING))\n ])\n \n+(define_subst \"round_saeonly\"\n+  [(set (match_operand:CCFP 0)\n+        (match_operand:CCFP 1))]\n+  \"TARGET_AVX512F\"\n+  [(set (match_dup 0)\n+\t(unspec:CCFP [(match_dup 1)\n+\t  (match_operand:SI 2 \"const48_operand\")]\n+\t  UNSPEC_EMBEDDED_ROUNDING))\n+])\n+\n (define_subst_attr \"round_expand_name\" \"round_expand\" \"\" \"_round\")\n (define_subst_attr \"round_expand_nimm_predicate\" \"round_expand\" \"nonimmediate_operand\" \"register_operand\")\n (define_subst_attr \"round_expand_operand\" \"round_expand\" \"\" \", operands[5]\")"}, {"sha": "83fc47626710055d6540d027f07b06f37e9f8440", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f563e0b55c78c53130d4082da6ba670ec1d9ba5/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f563e0b55c78c53130d4082da6ba670ec1d9ba5/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=3f563e0b55c78c53130d4082da6ba670ec1d9ba5", "patch": "@@ -1560,12 +1560,6 @@ subst_stack_regs_pat (rtx_insn *insn, stack_ptr regstack, rtx pat)\n \n \tswitch (GET_CODE (pat_src))\n \t  {\n-\t  case COMPARE:\n-\t    /* `fcomi' insn can't pop two regs.  */\n-\t    compare_for_stack_reg (insn, regstack, pat_src,\n-\t\t\t\t   REGNO (*dest) != FLAGS_REG);\n-\t    break;\n-\n \t  case CALL:\n \t    {\n \t      int count;\n@@ -1966,31 +1960,35 @@ subst_stack_regs_pat (rtx_insn *insn, stack_ptr regstack, rtx pat)\n \t\treplace_reg (src2, FIRST_STACK_REG + 1);\n \t\tbreak;\n \n-\t      case UNSPEC_SAHF:\n-\t\t/* (unspec [(unspec [(compare)] UNSPEC_FNSTSW)] UNSPEC_SAHF)\n-\t\t   The combination matches the PPRO fcomi instruction.  */\n-\n-\t\tpat_src = XVECEXP (pat_src, 0, 0);\n-\t\tgcc_assert (GET_CODE (pat_src) == UNSPEC);\n-\t\tgcc_assert (XINT (pat_src, 1) == UNSPEC_FNSTSW);\n-\t\t/* Fall through.  */\n-\n \t      case UNSPEC_FNSTSW:\n \t\t/* Combined fcomp+fnstsw generated for doing well with\n \t\t   CSE.  When optimizing this would have been broken\n \t\t   up before now.  */\n \n \t\tpat_src = XVECEXP (pat_src, 0, 0);\n-\t\tgcc_assert (GET_CODE (pat_src) == COMPARE);\n+\t\tif (GET_CODE (pat_src) == COMPARE)\n+\t\t  goto do_compare;\n \n-\t\tcompare_for_stack_reg (insn, regstack, pat_src, true);\n-\t\tbreak;\n+\t\t/* Fall through.  */\n+\n+\t      case UNSPEC_NOTRAP:\n+\n+\t\tpat_src = XVECEXP (pat_src, 0, 0);\n+\t\tgcc_assert (GET_CODE (pat_src) == COMPARE);\n+\t\tgoto do_compare;\n \n \t      default:\n \t\tgcc_unreachable ();\n \t      }\n \t    break;\n \n+\t  case COMPARE:\n+\t  do_compare:\n+\t    /* `fcomi' insn can't pop two regs.  */\n+\t    compare_for_stack_reg (insn, regstack, pat_src,\n+\t\t\t\t   REGNO (*dest) != FLAGS_REG);\n+\t    break;\n+\n \t  case IF_THEN_ELSE:\n \t    /* This insn requires the top of stack to be the destination.  */\n "}, {"sha": "f227e7ec36f332c8ce4c3a572d152cee7643dfe4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f563e0b55c78c53130d4082da6ba670ec1d9ba5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f563e0b55c78c53130d4082da6ba670ec1d9ba5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3f563e0b55c78c53130d4082da6ba670ec1d9ba5", "patch": "@@ -1,3 +1,8 @@\n+2017-10-27  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR target/82692\n+\t* gcc.dg/torture/pr82692.c: New test.\n+\n 2017-10-27  Will Schmidt  <will_schmidt@vnet.ibm.com>\n \n \t* gcc.target/powerpc/fold-vec-neg-char.c: New."}, {"sha": "7f16804c1961186eb0bf1ea7daeea23f3d1848ae", "filename": "gcc/testsuite/gcc.target/i386/pr82692.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f563e0b55c78c53130d4082da6ba670ec1d9ba5/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82692.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f563e0b55c78c53130d4082da6ba670ec1d9ba5/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82692.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82692.c?ref=3f563e0b55c78c53130d4082da6ba670ec1d9ba5", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-require-effective-target fenv_exceptions } */\n+\n+#include <fenv.h>\n+\n+extern void abort (void);\n+extern void exit (int);\n+\n+double __attribute__ ((noinline, noclone))\n+foo (double x)\n+{\n+  if (__builtin_islessequal (x, 0.0) || __builtin_isgreater (x, 1.0))\n+    return x + x;\n+  return x * x;\n+}\n+\n+int\n+main (void)\n+{\n+  volatile double x = foo (__builtin_nan (\"\"));\n+  if (fetestexcept (FE_INVALID))\n+    abort ();\n+  exit (0);\n+}"}]}