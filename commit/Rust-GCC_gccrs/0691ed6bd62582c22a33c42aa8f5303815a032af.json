{"sha": "0691ed6bd62582c22a33c42aa8f5303815a032af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDY5MWVkNmJkNjI1ODJjMjJhMzNjNDJhYThmNTMwMzgxNWEwMzJhZg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-07T09:33:27Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-07T09:33:27Z"}, "message": "[multiple changes]\n\n2017-09-07  Ed Schonberg  <schonberg@adacore.com>\n\n\t* par-ch6.adb (P_Subprogram): Improve error message on null\n\tprocedure with misplaced aspect specification, which the parser\n\tfirst attempts to interpret as a malformed expression function.\n\n2017-09-07  Gary Dismukes  <dismukes@adacore.com>\n\n\t* sem_attr.adb (Analyze_Attribute_Old_Result):\n\tAllow attributes Result and Old in the case of an expression\n\tfunction.\n\n2017-09-07  Justin Squirek  <squirek@adacore.com>\n\n\t* sem_prag.adb (Process_Atomic_Independent_Shared_Volatile): Propagate\n\tVolatile to subcomponents.\n\n2017-09-07  Bob Duff  <duff@adacore.com>\n\n\t* exp_ch7.adb (Find_Last_Init): Check for the\n\tcase where a build-in-place function call has been replaced by a\n\t'Reference attribute reference.\n\n2017-09-07  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* sem_ch7.adb (Has_Referencer): Recurse on Actions of freeze\n\tnodes.\n\n2017-09-07  Bob Duff  <duff@adacore.com>\n\n\t* exp_ch6.adb (Make_Build_In_Place_Call_In_Object_Declaration,\n\tMake_Build_In_Place_Call_In_Anonymous_Context): Do not use the\n\tsecondary stack for all functions that return limited tagged\n\ttypes -- just do it for dispatching calls.  Misc cleanup.\n\t* sem_util.ads, sem_util.adb (Unqual_Conv): New function to\n\tremove qualifications and type conversions. Fix various bugs\n\twhere only a single level of qualification or conversion was\n\tremoved, so e.g. \"T1'(T2'(X))\" would incorrectly return \"T2'(X)\"\n\tinstead of \"X\".\n\t* checks.adb, exp_util.ads, exp_util.adb, sem_res.adb: Misc related\n\tcleanup.\n\n2017-09-07  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb (setr_Actual_Subtypes): Within a predicate function\n\tdo not create actual subtypes that may generate further predicate\n\tfunctions.\n\t* sem_ch13.adb (Build_Predicate_Functions): Indicate that entity\n\tof body is a predicate function as well.\n\t(Resolve_Aspect_Expressions, Resolve_Name): For a component\n\tassociation, only the expression needs resolution, not the name.\n\t(Resolve_Aspect_Expressions, case Predicates): Construct and\n\tanalyze the predicate function declaration in the scope of the\n\ttype, before making the type and its discriminants visible.\n\nFrom-SVN: r251835", "tree": {"sha": "e4b6bbaacc1c819244efef808bb5225ae75309b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e4b6bbaacc1c819244efef808bb5225ae75309b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0691ed6bd62582c22a33c42aa8f5303815a032af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0691ed6bd62582c22a33c42aa8f5303815a032af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0691ed6bd62582c22a33c42aa8f5303815a032af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0691ed6bd62582c22a33c42aa8f5303815a032af/comments", "author": null, "committer": null, "parents": [{"sha": "a3064a99eeb5f1fd97b4a41b306decb52b036ec4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3064a99eeb5f1fd97b4a41b306decb52b036ec4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3064a99eeb5f1fd97b4a41b306decb52b036ec4"}], "stats": {"total": 954, "additions": 492, "deletions": 462}, "files": [{"sha": "7ab4ed4cd4a967025a8de8aa7f32f9c157511499", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0691ed6bd62582c22a33c42aa8f5303815a032af/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0691ed6bd62582c22a33c42aa8f5303815a032af/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0691ed6bd62582c22a33c42aa8f5303815a032af", "patch": "@@ -1,3 +1,58 @@\n+2017-09-07  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* par-ch6.adb (P_Subprogram): Improve error message on null\n+\tprocedure with misplaced aspect specification, which the parser\n+\tfirst attempts to interpret as a malformed expression function.\n+\n+2017-09-07  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* sem_attr.adb (Analyze_Attribute_Old_Result):\n+\tAllow attributes Result and Old in the case of an expression\n+\tfunction.\n+\n+2017-09-07  Justin Squirek  <squirek@adacore.com>\n+\n+\t* sem_prag.adb (Process_Atomic_Independent_Shared_Volatile): Propagate\n+\tVolatile to subcomponents.\n+\n+2017-09-07  Bob Duff  <duff@adacore.com>\n+\n+\t* exp_ch7.adb (Find_Last_Init): Check for the\n+\tcase where a build-in-place function call has been replaced by a\n+\t'Reference attribute reference.\n+\n+2017-09-07  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* sem_ch7.adb (Has_Referencer): Recurse on Actions of freeze\n+\tnodes.\n+\n+2017-09-07  Bob Duff  <duff@adacore.com>\n+\n+\t* exp_ch6.adb (Make_Build_In_Place_Call_In_Object_Declaration,\n+\tMake_Build_In_Place_Call_In_Anonymous_Context): Do not use the\n+\tsecondary stack for all functions that return limited tagged\n+\ttypes -- just do it for dispatching calls.  Misc cleanup.\n+\t* sem_util.ads, sem_util.adb (Unqual_Conv): New function to\n+\tremove qualifications and type conversions. Fix various bugs\n+\twhere only a single level of qualification or conversion was\n+\tremoved, so e.g. \"T1'(T2'(X))\" would incorrectly return \"T2'(X)\"\n+\tinstead of \"X\".\n+\t* checks.adb, exp_util.ads, exp_util.adb, sem_res.adb: Misc related\n+\tcleanup.\n+\n+2017-09-07  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb (setr_Actual_Subtypes): Within a predicate function\n+\tdo not create actual subtypes that may generate further predicate\n+\tfunctions.\n+\t* sem_ch13.adb (Build_Predicate_Functions): Indicate that entity\n+\tof body is a predicate function as well.\n+\t(Resolve_Aspect_Expressions, Resolve_Name): For a component\n+\tassociation, only the expression needs resolution, not the name.\n+\t(Resolve_Aspect_Expressions, case Predicates): Construct and\n+\tanalyze the predicate function declaration in the scope of the\n+\ttype, before making the type and its discriminants visible.\n+\n 2017-09-06  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (warn_on_field_placement): Issue the warning"}, {"sha": "39b11f812aa30d9f439202b625ff042eeae64416", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 310, "deletions": 353, "changes": 663, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0691ed6bd62582c22a33c42aa8f5303815a032af/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0691ed6bd62582c22a33c42aa8f5303815a032af/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=0691ed6bd62582c22a33c42aa8f5303815a032af", "patch": "@@ -136,6 +136,14 @@ package body Exp_Ch6 is\n    --  the activation Chain. Note: Master_Actual can be Empty, but only if\n    --  there are no tasks.\n \n+   function Caller_Known_Size\n+     (Func_Call : Node_Id; Result_Subt : Entity_Id) return Boolean;\n+   --  True if result subtype is definite, or has a size that does not require\n+   --  secondary stack usage (i.e. no variant part or components whose type\n+   --  depends on discriminants). In particular, untagged types with only\n+   --  access discriminants do not require secondary stack use. Note we must\n+   --  always use the secondary stack for dispatching-on-result calls.\n+\n    procedure Check_Overriding_Operation (Subp : Entity_Id);\n    --  Subp is a dispatching operation. Check whether it may override an\n    --  inherited private operation, in which case its DT entry is that of\n@@ -824,6 +832,18 @@ package body Exp_Ch6 is\n       return New_Body;\n    end Build_Procedure_Body_Form;\n \n+   -----------------------\n+   -- Caller_Known_Size --\n+   -----------------------\n+\n+   function Caller_Known_Size\n+     (Func_Call : Node_Id; Result_Subt : Entity_Id) return Boolean is\n+   begin\n+      return (Is_Definite_Subtype (Underlying_Type (Result_Subt))\n+              and then No (Controlling_Argument (Func_Call)))\n+          or else not Requires_Transient_Scope (Underlying_Type (Result_Subt));\n+   end Caller_Known_Size;\n+\n    --------------------------------\n    -- Check_Overriding_Operation --\n    --------------------------------\n@@ -1631,22 +1651,10 @@ package body Exp_Ch6 is\n          Expr    : Node_Id;\n          Obj     : Node_Id;\n          Obj_Typ : Entity_Id;\n-         Var     : Node_Id;\n+         Var     : constant Node_Id := Unqual_Conv (Act);\n          Var_Id  : Entity_Id;\n \n       begin\n-         Var := Act;\n-\n-         --  Use the expression when the context qualifies a reference in some\n-         --  fashion.\n-\n-         while Nkind_In (Var, N_Qualified_Expression,\n-                              N_Type_Conversion,\n-                              N_Unchecked_Type_Conversion)\n-         loop\n-            Var := Expression (Var);\n-         end loop;\n-\n          --  Copy the value of the validation variable back into the object\n          --  being validated.\n \n@@ -6796,12 +6804,7 @@ package body Exp_Ch6 is\n                Discrim_Source := Original_Node (Discrim_Source);\n             end if;\n \n-            while Nkind_In (Discrim_Source, N_Qualified_Expression,\n-                                            N_Type_Conversion,\n-                                            N_Unchecked_Type_Conversion)\n-            loop\n-               Discrim_Source := Expression (Discrim_Source);\n-            end loop;\n+            Discrim_Source := Unqual_Conv (Discrim_Source);\n \n             case Nkind (Discrim_Source) is\n                when N_Defining_Identifier =>\n@@ -7099,7 +7102,7 @@ package body Exp_Ch6 is\n    -------------------------------------\n \n    function Is_Build_In_Place_Function_Call (N : Node_Id) return Boolean is\n-      Exp_Node    : Node_Id := N;\n+      Exp_Node    : constant Node_Id := Unqual_Conv (N);\n       Function_Id : Entity_Id;\n \n    begin\n@@ -7119,17 +7122,6 @@ package body Exp_Ch6 is\n          return False;\n       end if;\n \n-      --  Step past qualification, type conversion (which can occur in actual\n-      --  parameter contexts), and unchecked conversion (which can occur in\n-      --  cases of calls to 'Input).\n-\n-      if Nkind_In (Exp_Node, N_Qualified_Expression,\n-                             N_Type_Conversion,\n-                             N_Unchecked_Type_Conversion)\n-      then\n-         Exp_Node := Expression (N);\n-      end if;\n-\n       if Nkind (Exp_Node) /= N_Function_Call then\n          return False;\n \n@@ -7771,32 +7763,13 @@ package body Exp_Ch6 is\n      (Function_Call : Node_Id)\n    is\n       Loc             : Source_Ptr;\n-      Func_Call       : Node_Id := Function_Call;\n+      Func_Call       : constant Node_Id := Unqual_Conv (Function_Call);\n       Function_Id     : Entity_Id;\n       Result_Subt     : Entity_Id;\n       Return_Obj_Id   : Entity_Id;\n       Return_Obj_Decl : Entity_Id;\n \n-      Definite : Boolean;\n-      --  True if result subtype is definite, or has a size that does not\n-      --  require secondary stack usage (i.e. no variant part or components\n-      --  whose type depends on discriminants). In particular, untagged types\n-      --  with only access discriminants do not require secondary stack use.\n-      --  Note that if the return type is tagged we must always use the sec.\n-      --  stack because the call may dispatch on result.\n-\n    begin\n-      --  Step past qualification, type conversion (which can occur in actual\n-      --  parameter contexts), and unchecked conversion (which can occur in\n-      --  cases of calls to 'Input).\n-\n-      if Nkind_In (Func_Call, N_Qualified_Expression,\n-                              N_Type_Conversion,\n-                              N_Unchecked_Type_Conversion)\n-      then\n-         Func_Call := Expression (Func_Call);\n-      end if;\n-\n       --  If the call has already been processed to add build-in-place actuals\n       --  then return. One place this can occur is for calls to build-in-place\n       --  functions that occur within a call to a protected operation, where\n@@ -7824,10 +7797,6 @@ package body Exp_Ch6 is\n       end if;\n \n       Result_Subt := Etype (Function_Id);\n-      Definite :=\n-        (Is_Definite_Subtype (Underlying_Type (Result_Subt))\n-             and then not Is_Tagged_Type (Result_Subt))\n-          or else not Requires_Transient_Scope (Underlying_Type (Result_Subt));\n \n       --  If the build-in-place function returns a controlled object, then the\n       --  object needs to be finalized immediately after the context. Since\n@@ -7869,7 +7838,7 @@ package body Exp_Ch6 is\n       --  When the result subtype is definite, an object of the subtype is\n       --  declared and an access value designating it is passed as an actual.\n \n-      elsif Definite then\n+      elsif Caller_Known_Size (Func_Call, Result_Subt) then\n \n          --  Create a temporary object to hold the function result\n \n@@ -7942,7 +7911,7 @@ package body Exp_Ch6 is\n       Function_Call : Node_Id)\n    is\n       Lhs          : constant Node_Id := Name (Assign);\n-      Func_Call    : Node_Id := Function_Call;\n+      Func_Call    : constant Node_Id := Unqual_Conv (Function_Call);\n       Func_Id      : Entity_Id;\n       Loc          : Source_Ptr;\n       Obj_Decl     : Node_Id;\n@@ -7954,15 +7923,6 @@ package body Exp_Ch6 is\n       Target       : Node_Id;\n \n    begin\n-      --  Step past qualification or unchecked conversion (the latter can occur\n-      --  in cases of calls to 'Input).\n-\n-      if Nkind_In (Func_Call, N_Qualified_Expression,\n-                              N_Unchecked_Type_Conversion)\n-      then\n-         Func_Call := Expression (Func_Call);\n-      end if;\n-\n       --  If the call has already been processed to add build-in-place actuals\n       --  then return. This should not normally occur in an assignment context,\n       --  but we add the protection as a defensive measure.\n@@ -8085,7 +8045,7 @@ package body Exp_Ch6 is\n       Caller_Object   : Node_Id;\n       Def_Id          : Entity_Id;\n       Fmaster_Actual  : Node_Id := Empty;\n-      Func_Call       : Node_Id := Function_Call;\n+      Func_Call       : constant Node_Id := Unqual_Conv (Function_Call);\n       Function_Id     : Entity_Id;\n       Pool_Actual     : Node_Id;\n       Ptr_Typ         : Entity_Id;\n@@ -8094,24 +8054,7 @@ package body Exp_Ch6 is\n       Res_Decl        : Node_Id;\n       Result_Subt     : Entity_Id;\n \n-      Definite : Boolean;\n-      --  True if result subtype is definite, or has a size that does not\n-      --  require secondary stack usage (i.e. no variant part or components\n-      --  whose type depends on discriminants). In particular, untagged types\n-      --  with only access discriminants do not require secondary stack use.\n-      --  Note that if the return type is tagged we must always use the sec.\n-      --  stack because the call may dispatch on result.\n-\n    begin\n-      --  Step past qualification or unchecked conversion (the latter can occur\n-      --  in cases of calls to 'Input).\n-\n-      if Nkind_In (Func_Call, N_Qualified_Expression,\n-                              N_Unchecked_Type_Conversion)\n-      then\n-         Func_Call := Expression (Func_Call);\n-      end if;\n-\n       --  If the call has already been processed to add build-in-place actuals\n       --  then return. This should not normally occur in an object declaration,\n       --  but we add the protection as a defensive measure.\n@@ -8135,327 +8078,341 @@ package body Exp_Ch6 is\n       end if;\n \n       Result_Subt := Etype (Function_Id);\n-      Definite :=\n-        (Is_Definite_Subtype (Underlying_Type (Result_Subt))\n-             and then not Is_Tagged_Type (Result_Subt))\n-          or else not Requires_Transient_Scope (Underlying_Type (Result_Subt));\n \n-      --  Create an access type designating the function's result subtype. We\n-      --  use the type of the original call because it may be a call to an\n-      --  inherited operation, which the expansion has replaced with the parent\n-      --  operation that yields the parent type. Note that this access type\n-      --  must be declared before we establish a transient scope, so that it\n-      --  receives the proper accessibility level.\n+      declare\n+         Definite : constant Boolean :=\n+           Caller_Known_Size (Func_Call, Result_Subt);\n+      begin\n+         --  Create an access type designating the function's result subtype.\n+         --  We use the type of the original call because it may be a call to\n+         --  an inherited operation, which the expansion has replaced with the\n+         --  parent operation that yields the parent type. Note that this\n+         --  access type must be declared before we establish a transient\n+         --  scope, so that it receives the proper accessibility level.\n+\n+         Ptr_Typ := Make_Temporary (Loc, 'A');\n+         Ptr_Typ_Decl :=\n+           Make_Full_Type_Declaration (Loc,\n+             Defining_Identifier => Ptr_Typ,\n+             Type_Definition     =>\n+               Make_Access_To_Object_Definition (Loc,\n+                 All_Present        => True,\n+                 Subtype_Indication =>\n+                   New_Occurrence_Of (Etype (Function_Call), Loc)));\n+\n+         --  The access type and its accompanying object must be inserted after\n+         --  the object declaration in the constrained case, so that the\n+         --  function call can be passed access to the object. In the\n+         --  indefinite case, or if the object declaration is for a return\n+         --  object, the access type and object must be inserted before the\n+         --  object, since the object declaration is rewritten to be a renaming\n+         --  of a dereference of the access object. Note: we need to freeze\n+         --  Ptr_Typ explicitly, because the result object is in a different\n+         --  (transient) scope, so won't cause freezing.\n+\n+         if Definite\n+           and then not Is_Return_Object (Defining_Identifier (Obj_Decl))\n+         then\n+            Insert_After_And_Analyze (Obj_Decl, Ptr_Typ_Decl);\n+         else\n+            Insert_Action (Obj_Decl, Ptr_Typ_Decl);\n+         end if;\n \n-      Ptr_Typ := Make_Temporary (Loc, 'A');\n-      Ptr_Typ_Decl :=\n-        Make_Full_Type_Declaration (Loc,\n-          Defining_Identifier => Ptr_Typ,\n-          Type_Definition     =>\n-            Make_Access_To_Object_Definition (Loc,\n-              All_Present        => True,\n-              Subtype_Indication =>\n-                New_Occurrence_Of (Etype (Function_Call), Loc)));\n-\n-      --  The access type and its accompanying object must be inserted after\n-      --  the object declaration in the constrained case, so that the function\n-      --  call can be passed access to the object. In the indefinite case,\n-      --  or if the object declaration is for a return object, the access type\n-      --  and object must be inserted before the object, since the object\n-      --  declaration is rewritten to be a renaming of a dereference of the\n-      --  access object. Note: we need to freeze Ptr_Typ explicitly, because\n-      --  the result object is in a different (transient) scope, so won't\n-      --  cause freezing.\n-\n-      if Definite\n-        and then not Is_Return_Object (Defining_Identifier (Obj_Decl))\n-      then\n-         Insert_After_And_Analyze (Obj_Decl, Ptr_Typ_Decl);\n-      else\n-         Insert_Action (Obj_Decl, Ptr_Typ_Decl);\n-      end if;\n+         --  Force immediate freezing of Ptr_Typ because Res_Decl will be\n+         --  elaborated in an inner (transient) scope and thus won't cause\n+         --  freezing by itself.\n \n-      --  Force immediate freezing of Ptr_Typ because Res_Decl will be\n-      --  elaborated in an inner (transient) scope and thus won't cause\n-      --  freezing by itself.\n+         declare\n+            Ptr_Typ_Freeze_Ref : constant Node_Id :=\n+                                   New_Occurrence_Of (Ptr_Typ, Loc);\n+         begin\n+            Set_Parent (Ptr_Typ_Freeze_Ref, Ptr_Typ_Decl);\n+            Freeze_Expression (Ptr_Typ_Freeze_Ref);\n+         end;\n \n-      declare\n-         Ptr_Typ_Freeze_Ref : constant Node_Id :=\n-                                New_Occurrence_Of (Ptr_Typ, Loc);\n-      begin\n-         Set_Parent (Ptr_Typ_Freeze_Ref, Ptr_Typ_Decl);\n-         Freeze_Expression (Ptr_Typ_Freeze_Ref);\n-      end;\n+         --  If the object is a return object of an enclosing build-in-place\n+         --  function, then the implicit build-in-place parameters of the\n+         --  enclosing function are simply passed along to the called function.\n+         --  (Unfortunately, this won't cover the case of extension aggregates\n+         --  where the ancestor part is a build-in-place indefinite function\n+         --  call that should be passed along the caller's parameters.\n+         --  Currently those get mishandled by reassigning the result of the\n+         --  call to the aggregate return object, when the call result should\n+         --  really be directly built in place in the aggregate and not in a\n+         --  temporary. ???)\n+\n+         if Is_Return_Object (Defining_Identifier (Obj_Decl)) then\n+            Pass_Caller_Acc := True;\n+\n+            --  When the enclosing function has a BIP_Alloc_Form formal then we\n+            --  pass it along to the callee (such as when the enclosing\n+            --  function has an unconstrained or tagged result type).\n+\n+            if Needs_BIP_Alloc_Form (Encl_Func) then\n+               if RTE_Available (RE_Root_Storage_Pool_Ptr) then\n+                  Pool_Actual :=\n+                    New_Occurrence_Of\n+                      (Build_In_Place_Formal\n+                        (Encl_Func, BIP_Storage_Pool), Loc);\n+\n+               --  The build-in-place pool formal is not built on e.g. ZFP\n \n-      --  If the object is a return object of an enclosing build-in-place\n-      --  function, then the implicit build-in-place parameters of the\n-      --  enclosing function are simply passed along to the called function.\n-      --  (Unfortunately, this won't cover the case of extension aggregates\n-      --  where the ancestor part is a build-in-place indefinite function\n-      --  call that should be passed along the caller's parameters. Currently\n-      --  those get mishandled by reassigning the result of the call to the\n-      --  aggregate return object, when the call result should really be\n-      --  directly built in place in the aggregate and not in a temporary. ???)\n-\n-      if Is_Return_Object (Defining_Identifier (Obj_Decl)) then\n-         Pass_Caller_Acc := True;\n-\n-         --  When the enclosing function has a BIP_Alloc_Form formal then we\n-         --  pass it along to the callee (such as when the enclosing function\n-         --  has an unconstrained or tagged result type).\n-\n-         if Needs_BIP_Alloc_Form (Encl_Func) then\n-            if RTE_Available (RE_Root_Storage_Pool_Ptr) then\n-               Pool_Actual :=\n-                 New_Occurrence_Of\n-                   (Build_In_Place_Formal (Encl_Func, BIP_Storage_Pool), Loc);\n+               else\n+                  Pool_Actual := Empty;\n+               end if;\n+\n+               Add_Unconstrained_Actuals_To_Build_In_Place_Call\n+                 (Function_Call  => Func_Call,\n+                  Function_Id    => Function_Id,\n+                  Alloc_Form_Exp =>\n+                    New_Occurrence_Of\n+                      (Build_In_Place_Formal (Encl_Func, BIP_Alloc_Form), Loc),\n+                  Pool_Actual    => Pool_Actual);\n \n-            --  The build-in-place pool formal is not built on e.g. ZFP\n+            --  Otherwise, if enclosing function has a definite result subtype,\n+            --  then caller allocation will be used.\n \n             else\n-               Pool_Actual := Empty;\n+               Add_Unconstrained_Actuals_To_Build_In_Place_Call\n+                 (Func_Call, Function_Id, Alloc_Form => Caller_Allocation);\n             end if;\n \n-            Add_Unconstrained_Actuals_To_Build_In_Place_Call\n-              (Function_Call  => Func_Call,\n-               Function_Id    => Function_Id,\n-               Alloc_Form_Exp =>\n+            if Needs_BIP_Finalization_Master (Encl_Func) then\n+               Fmaster_Actual :=\n                  New_Occurrence_Of\n-                   (Build_In_Place_Formal (Encl_Func, BIP_Alloc_Form), Loc),\n-               Pool_Actual    => Pool_Actual);\n+                   (Build_In_Place_Formal\n+                      (Encl_Func, BIP_Finalization_Master), Loc);\n+            end if;\n \n-         --  Otherwise, if enclosing function has a definite result subtype,\n-         --  then caller allocation will be used.\n+            --  Retrieve the BIPacc formal from the enclosing function and\n+            --  convert it to the access type of the callee's BIP_Object_Access\n+            --  formal.\n+\n+            Caller_Object :=\n+              Make_Unchecked_Type_Conversion (Loc,\n+                Subtype_Mark =>\n+                  New_Occurrence_Of\n+                    (Etype\n+                       (Build_In_Place_Formal\n+                         (Function_Id, BIP_Object_Access)),\n+                     Loc),\n+                Expression   =>\n+                  New_Occurrence_Of\n+                    (Build_In_Place_Formal (Encl_Func, BIP_Object_Access),\n+                     Loc));\n+\n+         --  In the definite case, add an implicit actual to the function call\n+         --  that provides access to the declared object. An unchecked\n+         --  conversion to the (specific) result type of the function is\n+         --  inserted to handle the case where the object is declared with a\n+         --  class-wide type.\n+\n+         elsif Definite then\n+            Caller_Object :=\n+               Make_Unchecked_Type_Conversion (Loc,\n+                 Subtype_Mark => New_Occurrence_Of (Result_Subt, Loc),\n+                 Expression   => New_Occurrence_Of (Obj_Def_Id, Loc));\n+\n+            --  When the function has a controlling result, an allocation-form\n+            --  parameter must be passed indicating that the caller is\n+            --  allocating the result object. This is needed because such a\n+            --  function can be called as a dispatching operation and must be\n+            --  treated similarly to functions with indefinite result subtypes.\n \n-         else\n             Add_Unconstrained_Actuals_To_Build_In_Place_Call\n               (Func_Call, Function_Id, Alloc_Form => Caller_Allocation);\n-         end if;\n-\n-         if Needs_BIP_Finalization_Master (Encl_Func) then\n-            Fmaster_Actual :=\n-              New_Occurrence_Of\n-                (Build_In_Place_Formal\n-                   (Encl_Func, BIP_Finalization_Master), Loc);\n-         end if;\n-\n-         --  Retrieve the BIPacc formal from the enclosing function and convert\n-         --  it to the access type of the callee's BIP_Object_Access formal.\n-\n-         Caller_Object :=\n-           Make_Unchecked_Type_Conversion (Loc,\n-             Subtype_Mark =>\n-               New_Occurrence_Of\n-                 (Etype\n-                    (Build_In_Place_Formal (Function_Id, BIP_Object_Access)),\n-                  Loc),\n-             Expression   =>\n-               New_Occurrence_Of\n-                 (Build_In_Place_Formal (Encl_Func, BIP_Object_Access),\n-                  Loc));\n-\n-      --  In the definite case, add an implicit actual to the function call\n-      --  that provides access to the declared object. An unchecked conversion\n-      --  to the (specific) result type of the function is inserted to handle\n-      --  the case where the object is declared with a class-wide type.\n \n-      elsif Definite then\n-         Caller_Object :=\n-            Make_Unchecked_Type_Conversion (Loc,\n-              Subtype_Mark => New_Occurrence_Of (Result_Subt, Loc),\n-              Expression   => New_Occurrence_Of (Obj_Def_Id, Loc));\n+         --  The allocation for indefinite library-level objects occurs on the\n+         --  heap as opposed to the secondary stack. This accommodates DLLs\n+         --  where the secondary stack is destroyed after each library\n+         --  unload. This is a hybrid mechanism where a stack-allocated object\n+         --  lives on the heap.\n \n-         --  When the function has a controlling result, an allocation-form\n-         --  parameter must be passed indicating that the caller is allocating\n-         --  the result object. This is needed because such a function can be\n-         --  called as a dispatching operation and must be treated similarly\n-         --  to functions with indefinite result subtypes.\n+         elsif Is_Library_Level_Entity (Defining_Identifier (Obj_Decl))\n+           and then not Restriction_Active (No_Implicit_Heap_Allocations)\n+         then\n+            Add_Unconstrained_Actuals_To_Build_In_Place_Call\n+              (Func_Call, Function_Id, Alloc_Form => Global_Heap);\n+            Caller_Object := Empty;\n \n-         Add_Unconstrained_Actuals_To_Build_In_Place_Call\n-           (Func_Call, Function_Id, Alloc_Form => Caller_Allocation);\n+            --  Create a finalization master for the access result type to\n+            --  ensure that the heap allocation can properly chain the object\n+            --  and later finalize it when the library unit goes out of scope.\n \n-      --  The allocation for indefinite library-level objects occurs on the\n-      --  heap as opposed to the secondary stack. This accommodates DLLs where\n-      --  the secondary stack is destroyed after each library unload. This is\n-      --  a hybrid mechanism where a stack-allocated object lives on the heap.\n+            if Needs_Finalization (Etype (Func_Call)) then\n+               Build_Finalization_Master\n+                 (Typ            => Ptr_Typ,\n+                  For_Lib_Level  => True,\n+                  Insertion_Node => Ptr_Typ_Decl);\n \n-      elsif Is_Library_Level_Entity (Defining_Identifier (Obj_Decl))\n-        and then not Restriction_Active (No_Implicit_Heap_Allocations)\n-      then\n-         Add_Unconstrained_Actuals_To_Build_In_Place_Call\n-           (Func_Call, Function_Id, Alloc_Form => Global_Heap);\n-         Caller_Object := Empty;\n+               Fmaster_Actual :=\n+                 Make_Attribute_Reference (Loc,\n+                   Prefix         =>\n+                     New_Occurrence_Of (Finalization_Master (Ptr_Typ), Loc),\n+                   Attribute_Name => Name_Unrestricted_Access);\n+            end if;\n \n-         --  Create a finalization master for the access result type to ensure\n-         --  that the heap allocation can properly chain the object and later\n-         --  finalize it when the library unit goes out of scope.\n+         --  In other indefinite cases, pass an indication to do the allocation\n+         --  on the secondary stack and set Caller_Object to Empty so that a\n+         --  null value will be passed for the caller's object address. A\n+         --  transient scope is established to ensure eventual cleanup of the\n+         --  result.\n \n-         if Needs_Finalization (Etype (Func_Call)) then\n-            Build_Finalization_Master\n-              (Typ            => Ptr_Typ,\n-               For_Lib_Level  => True,\n-               Insertion_Node => Ptr_Typ_Decl);\n+         else\n+            Add_Unconstrained_Actuals_To_Build_In_Place_Call\n+              (Func_Call, Function_Id, Alloc_Form => Secondary_Stack);\n+            Caller_Object := Empty;\n \n-            Fmaster_Actual :=\n-              Make_Attribute_Reference (Loc,\n-                Prefix         =>\n-                  New_Occurrence_Of (Finalization_Master (Ptr_Typ), Loc),\n-                Attribute_Name => Name_Unrestricted_Access);\n+            Establish_Transient_Scope (Obj_Decl, Sec_Stack => True);\n          end if;\n \n-      --  In other indefinite cases, pass an indication to do the allocation\n-      --  on the secondary stack and set Caller_Object to Empty so that a null\n-      --  value will be passed for the caller's object address. A transient\n-      --  scope is established to ensure eventual cleanup of the result.\n-\n-      else\n-         Add_Unconstrained_Actuals_To_Build_In_Place_Call\n-           (Func_Call, Function_Id, Alloc_Form => Secondary_Stack);\n-         Caller_Object := Empty;\n+         --  Pass along any finalization master actual, which is needed in the\n+         --  case where the called function initializes a return object of an\n+         --  enclosing build-in-place function.\n \n-         Establish_Transient_Scope (Obj_Decl, Sec_Stack => True);\n-      end if;\n-\n-      --  Pass along any finalization master actual, which is needed in the\n-      --  case where the called function initializes a return object of an\n-      --  enclosing build-in-place function.\n-\n-      Add_Finalization_Master_Actual_To_Build_In_Place_Call\n-        (Func_Call  => Func_Call,\n-         Func_Id    => Function_Id,\n-         Master_Exp => Fmaster_Actual);\n+         Add_Finalization_Master_Actual_To_Build_In_Place_Call\n+           (Func_Call  => Func_Call,\n+            Func_Id    => Function_Id,\n+            Master_Exp => Fmaster_Actual);\n \n-      if Nkind (Parent (Obj_Decl)) = N_Extended_Return_Statement\n-        and then Has_Task (Result_Subt)\n-      then\n-         --  Here we're passing along the master that was passed in to this\n-         --  function.\n+         if Nkind (Parent (Obj_Decl)) = N_Extended_Return_Statement\n+           and then Has_Task (Result_Subt)\n+         then\n+            --  Here we're passing along the master that was passed in to this\n+            --  function.\n \n-         Add_Task_Actuals_To_Build_In_Place_Call\n-           (Func_Call, Function_Id,\n-            Master_Actual =>\n-              New_Occurrence_Of\n-                (Build_In_Place_Formal (Encl_Func, BIP_Task_Master), Loc));\n+            Add_Task_Actuals_To_Build_In_Place_Call\n+              (Func_Call, Function_Id,\n+               Master_Actual =>\n+                 New_Occurrence_Of\n+                   (Build_In_Place_Formal (Encl_Func, BIP_Task_Master), Loc));\n \n-      else\n-         Add_Task_Actuals_To_Build_In_Place_Call\n-           (Func_Call, Function_Id, Make_Identifier (Loc, Name_uMaster));\n-      end if;\n+         else\n+            Add_Task_Actuals_To_Build_In_Place_Call\n+              (Func_Call, Function_Id, Make_Identifier (Loc, Name_uMaster));\n+         end if;\n \n-      Add_Access_Actual_To_Build_In_Place_Call\n-        (Func_Call, Function_Id, Caller_Object, Is_Access => Pass_Caller_Acc);\n+         Add_Access_Actual_To_Build_In_Place_Call\n+           (Func_Call,\n+            Function_Id,\n+            Caller_Object,\n+            Is_Access => Pass_Caller_Acc);\n \n-      --  Finally, create an access object initialized to a reference to the\n-      --  function call. We know this access value cannot be null, so mark the\n-      --  entity accordingly to suppress the access check.\n+         --  Finally, create an access object initialized to a reference to the\n+         --  function call. We know this access value cannot be null, so mark\n+         --  the entity accordingly to suppress the access check.\n \n-      Def_Id := Make_Temporary (Loc, 'R', Func_Call);\n-      Set_Etype (Def_Id, Ptr_Typ);\n-      Set_Is_Known_Non_Null (Def_Id);\n+         Def_Id := Make_Temporary (Loc, 'R', Func_Call);\n+         Set_Etype (Def_Id, Ptr_Typ);\n+         Set_Is_Known_Non_Null (Def_Id);\n \n-      Res_Decl :=\n-        Make_Object_Declaration (Loc,\n-          Defining_Identifier => Def_Id,\n-          Constant_Present    => True,\n-          Object_Definition   => New_Occurrence_Of (Ptr_Typ, Loc),\n-          Expression          =>\n-            Make_Reference (Loc, Relocate_Node (Func_Call)));\n+         Res_Decl :=\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Def_Id,\n+             Constant_Present    => True,\n+             Object_Definition   => New_Occurrence_Of (Ptr_Typ, Loc),\n+             Expression          =>\n+               Make_Reference (Loc, Relocate_Node (Func_Call)));\n \n-      Insert_After_And_Analyze (Ptr_Typ_Decl, Res_Decl);\n+         Insert_After_And_Analyze (Ptr_Typ_Decl, Res_Decl);\n \n-      --  If the result subtype of the called function is definite and is not\n-      --  itself the return expression of an enclosing BIP function, then mark\n-      --  the object as having no initialization.\n+         --  If the result subtype of the called function is definite and is\n+         --  not itself the return expression of an enclosing BIP function,\n+         --  then mark the object as having no initialization.\n \n-      if Definite\n-        and then not Is_Return_Object (Defining_Identifier (Obj_Decl))\n-      then\n-         --  The related object declaration is encased in a transient block\n-         --  because the build-in-place function call contains at least one\n-         --  nested function call that produces a controlled transient\n-         --  temporary:\n+         if Definite\n+           and then not Is_Return_Object (Defining_Identifier (Obj_Decl))\n+         then\n+            --  The related object declaration is encased in a transient block\n+            --  because the build-in-place function call contains at least one\n+            --  nested function call that produces a controlled transient\n+            --  temporary:\n \n-         --    Obj : ... := BIP_Func_Call (Ctrl_Func_Call);\n+            --    Obj : ... := BIP_Func_Call (Ctrl_Func_Call);\n \n-         --  Since the build-in-place expansion decouples the call from the\n-         --  object declaration, the finalization machinery lacks the context\n-         --  which prompted the generation of the transient block. To resolve\n-         --  this scenario, store the build-in-place call.\n+            --  Since the build-in-place expansion decouples the call from the\n+            --  object declaration, the finalization machinery lacks the\n+            --  context which prompted the generation of the transient\n+            --  block. To resolve this scenario, store the build-in-place call.\n \n-         if Scope_Is_Transient and then Node_To_Be_Wrapped = Obj_Decl then\n-            Set_BIP_Initialization_Call (Obj_Def_Id, Res_Decl);\n-         end if;\n+            if Scope_Is_Transient and then Node_To_Be_Wrapped = Obj_Decl then\n+               Set_BIP_Initialization_Call (Obj_Def_Id, Res_Decl);\n+            end if;\n \n-         Set_Expression (Obj_Decl, Empty);\n-         Set_No_Initialization (Obj_Decl);\n+            Set_Expression (Obj_Decl, Empty);\n+            Set_No_Initialization (Obj_Decl);\n \n-      --  In case of an indefinite result subtype, or if the call is the\n-      --  return expression of an enclosing BIP function, rewrite the object\n-      --  declaration as an object renaming where the renamed object is a\n-      --  dereference of <function_Call>'reference:\n-      --\n-      --      Obj : Subt renames <function_call>'Ref.all;\n+         --  In case of an indefinite result subtype, or if the call is the\n+         --  return expression of an enclosing BIP function, rewrite the object\n+         --  declaration as an object renaming where the renamed object is a\n+         --  dereference of <function_Call>'reference:\n+         --\n+         --      Obj : Subt renames <function_call>'Ref.all;\n \n-      else\n-         Call_Deref :=\n-           Make_Explicit_Dereference (Obj_Loc,\n-             Prefix => New_Occurrence_Of (Def_Id, Obj_Loc));\n-\n-         Rewrite (Obj_Decl,\n-           Make_Object_Renaming_Declaration (Obj_Loc,\n-             Defining_Identifier => Make_Temporary (Obj_Loc, 'D'),\n-             Subtype_Mark        => New_Occurrence_Of (Result_Subt, Obj_Loc),\n-             Name                => Call_Deref));\n-\n-         Set_Renamed_Object (Defining_Identifier (Obj_Decl), Call_Deref);\n-\n-         --  If the original entity comes from source, then mark the new\n-         --  entity as needing debug information, even though it's defined\n-         --  by a generated renaming that does not come from source, so that\n-         --  the Materialize_Entity flag will be set on the entity when\n-         --  Debug_Renaming_Declaration is called during analysis.\n-\n-         if Comes_From_Source (Obj_Def_Id) then\n-            Set_Debug_Info_Needed (Defining_Identifier (Obj_Decl));\n-         end if;\n+         else\n+            Call_Deref :=\n+              Make_Explicit_Dereference (Obj_Loc,\n+                Prefix => New_Occurrence_Of (Def_Id, Obj_Loc));\n+\n+            Rewrite (Obj_Decl,\n+              Make_Object_Renaming_Declaration (Obj_Loc,\n+                Defining_Identifier => Make_Temporary (Obj_Loc, 'D'),\n+                Subtype_Mark => New_Occurrence_Of (Result_Subt, Obj_Loc),\n+                Name => Call_Deref));\n+\n+            Set_Renamed_Object (Defining_Identifier (Obj_Decl), Call_Deref);\n+\n+            --  If the original entity comes from source, then mark the new\n+            --  entity as needing debug information, even though it's defined\n+            --  by a generated renaming that does not come from source, so that\n+            --  the Materialize_Entity flag will be set on the entity when\n+            --  Debug_Renaming_Declaration is called during analysis.\n+\n+            if Comes_From_Source (Obj_Def_Id) then\n+               Set_Debug_Info_Needed (Defining_Identifier (Obj_Decl));\n+            end if;\n \n-         Analyze (Obj_Decl);\n+            Analyze (Obj_Decl);\n \n-         --  Replace the internal identifier of the renaming declaration's\n-         --  entity with identifier of the original object entity. We also have\n-         --  to exchange the entities containing their defining identifiers to\n-         --  ensure the correct replacement of the object declaration by the\n-         --  object renaming declaration to avoid homograph conflicts (since\n-         --  the object declaration's defining identifier was already entered\n-         --  in current scope). The Next_Entity links of the two entities also\n-         --  have to be swapped since the entities are part of the return\n-         --  scope's entity list and the list structure would otherwise be\n-         --  corrupted. Finally, the homonym chain must be preserved as well.\n+            --  Replace the internal identifier of the renaming declaration's\n+            --  entity with identifier of the original object entity. We also\n+            --  have to exchange the entities containing their defining\n+            --  identifiers to ensure the correct replacement of the object\n+            --  declaration by the object renaming declaration to avoid\n+            --  homograph conflicts (since the object declaration's defining\n+            --  identifier was already entered in current scope). The\n+            --  Next_Entity links of the two entities also have to be swapped\n+            --  since the entities are part of the return scope's entity list\n+            --  and the list structure would otherwise be corrupted. Finally,\n+            --  the homonym chain must be preserved as well.\n \n-         declare\n-            Ren_Id  : constant Entity_Id := Defining_Entity (Obj_Decl);\n-            Next_Id : constant Entity_Id := Next_Entity (Ren_Id);\n+            declare\n+               Ren_Id  : constant Entity_Id := Defining_Entity (Obj_Decl);\n+               Next_Id : constant Entity_Id := Next_Entity (Ren_Id);\n \n-         begin\n-            Set_Chars (Ren_Id, Chars (Obj_Def_Id));\n+            begin\n+               Set_Chars (Ren_Id, Chars (Obj_Def_Id));\n \n-            --  Swap next entity links in preparation for exchanging entities\n+               --  Swap next entity links in preparation for exchanging\n+               --  entities.\n \n-            Set_Next_Entity (Ren_Id, Next_Entity (Obj_Def_Id));\n-            Set_Next_Entity (Obj_Def_Id, Next_Id);\n-            Set_Homonym     (Ren_Id, Homonym (Obj_Def_Id));\n+               Set_Next_Entity (Ren_Id, Next_Entity (Obj_Def_Id));\n+               Set_Next_Entity (Obj_Def_Id, Next_Id);\n+               Set_Homonym     (Ren_Id, Homonym (Obj_Def_Id));\n \n-            Exchange_Entities (Ren_Id, Obj_Def_Id);\n+               Exchange_Entities (Ren_Id, Obj_Def_Id);\n \n-            --  Preserve source indication of original declaration, so that\n-            --  xref information is properly generated for the right entity.\n+               --  Preserve source indication of original declaration, so that\n+               --  xref information is properly generated for the right entity.\n \n-            Preserve_Comes_From_Source (Obj_Decl, Original_Node (Obj_Decl));\n-            Preserve_Comes_From_Source (Obj_Def_Id, Original_Node (Obj_Decl));\n+               Preserve_Comes_From_Source (Obj_Decl, Original_Node (Obj_Decl));\n+               Preserve_Comes_From_Source\n+                 (Obj_Def_Id, Original_Node (Obj_Decl));\n \n-            Set_Comes_From_Source (Ren_Id, False);\n-         end;\n-      end if;\n+               Set_Comes_From_Source (Ren_Id, False);\n+            end;\n+         end if;\n+      end;\n \n       --  If the object entity has a class-wide Etype, then we need to change\n       --  it to the result subtype of the function call, because otherwise the"}, {"sha": "28950fca8a4f86fb1385fe1ab01d3ded2bab0456", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0691ed6bd62582c22a33c42aa8f5303815a032af/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0691ed6bd62582c22a33c42aa8f5303815a032af/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=0691ed6bd62582c22a33c42aa8f5303815a032af", "patch": "@@ -2763,9 +2763,30 @@ package body Exp_Ch7 is\n \n             Stmt := Next_Suitable_Statement (Decl);\n \n-            --  Nothing to do for an object with suppressed initialization\n+            --  For an object with suppressed initialization, we check whether\n+            --  there is in fact no initialization expression. If there is not,\n+            --  then this is an object declaration that has been turned into a\n+            --  different object declaration that calls the build-in-place\n+            --  function in a 'Reference attribute, as in \"F(...)'Reference\".\n+            --  We search for that later object declaration, so that the\n+            --  Inc_Decl will be inserted after the call. Otherwise, if the\n+            --  call raises an exception, we will finalize the (uninitialized)\n+            --  object, which is wrong.\n \n             if No_Initialization (Decl) then\n+               if No (Expression (Last_Init)) then\n+                  loop\n+                     Last_Init := Next (Last_Init);\n+                     exit when No (Last_Init);\n+                     exit when Nkind (Last_Init) = N_Object_Declaration\n+                       and then Nkind (Expression (Last_Init)) = N_Reference\n+                       and then Nkind (Prefix (Expression (Last_Init))) =\n+                                  N_Function_Call\n+                       and then Is_Expanded_Build_In_Place_Call\n+                                  (Prefix (Expression (Last_Init)));\n+                  end loop;\n+               end if;\n+\n                return;\n \n             --  In all other cases the initialization calls follow the related\n@@ -2955,7 +2976,7 @@ package body Exp_Ch7 is\n \n          if No (Finalizer_Insert_Nod) then\n \n-            --  Insertion after an abort deffered block\n+            --  Insertion after an abort deferred block\n \n             if Present (Body_Ins) then\n                Finalizer_Insert_Nod := Body_Ins;"}, {"sha": "ff1a7523457d06ed587827c7b280d28d8f44e454", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 1, "deletions": 78, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0691ed6bd62582c22a33c42aa8f5303815a032af/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0691ed6bd62582c22a33c42aa8f5303815a032af/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=0691ed6bd62582c22a33c42aa8f5303815a032af", "patch": "@@ -8274,79 +8274,6 @@ package body Exp_Util is\n           and then not Is_Build_In_Place_Function_Call (Prefix (Expr));\n    end Is_Non_BIP_Func_Call;\n \n-   ------------------------------------\n-   -- Is_Object_Access_BIP_Func_Call --\n-   ------------------------------------\n-\n-   function Is_Object_Access_BIP_Func_Call\n-      (Expr   : Node_Id;\n-       Obj_Id : Entity_Id) return Boolean\n-   is\n-      Access_Nam : Name_Id := No_Name;\n-      Actual     : Node_Id;\n-      Call       : Node_Id;\n-      Formal     : Node_Id;\n-      Param      : Node_Id;\n-\n-   begin\n-      --  Build-in-place calls usually appear in 'reference format. Note that\n-      --  the accessibility check machinery may add an extra 'reference due to\n-      --  side effect removal.\n-\n-      Call := Expr;\n-      while Nkind (Call) = N_Reference loop\n-         Call := Prefix (Call);\n-      end loop;\n-\n-      if Nkind_In (Call, N_Qualified_Expression,\n-                         N_Unchecked_Type_Conversion)\n-      then\n-         Call := Expression (Call);\n-      end if;\n-\n-      if Is_Build_In_Place_Function_Call (Call) then\n-\n-         --  Examine all parameter associations of the function call\n-\n-         Param := First (Parameter_Associations (Call));\n-         while Present (Param) loop\n-            if Nkind (Param) = N_Parameter_Association\n-              and then Nkind (Selector_Name (Param)) = N_Identifier\n-            then\n-               Formal := Selector_Name (Param);\n-               Actual := Explicit_Actual_Parameter (Param);\n-\n-               --  Construct the name of formal BIPaccess. It is much easier to\n-               --  extract the name of the function using an arbitrary formal's\n-               --  scope rather than the Name field of Call.\n-\n-               if Access_Nam = No_Name and then Present (Entity (Formal)) then\n-                  Access_Nam :=\n-                    New_External_Name\n-                      (Chars (Scope (Entity (Formal))),\n-                       BIP_Formal_Suffix (BIP_Object_Access));\n-               end if;\n-\n-               --  A match for BIPaccess => Obj_Id'Unrestricted_Access has been\n-               --  found.\n-\n-               if Chars (Formal) = Access_Nam\n-                 and then Nkind (Actual) = N_Attribute_Reference\n-                 and then Attribute_Name (Actual) = Name_Unrestricted_Access\n-                 and then Nkind (Prefix (Actual)) = N_Identifier\n-                 and then Entity (Prefix (Actual)) = Obj_Id\n-               then\n-                  return True;\n-               end if;\n-            end if;\n-\n-            Next (Param);\n-         end loop;\n-      end if;\n-\n-      return False;\n-   end Is_Object_Access_BIP_Func_Call;\n-\n    ----------------------------------\n    -- Is_Possibly_Unaligned_Object --\n    ----------------------------------\n@@ -8739,11 +8666,7 @@ package body Exp_Util is\n          Call := Prefix (Call);\n       end loop;\n \n-      if Nkind_In (Call, N_Qualified_Expression,\n-                         N_Unchecked_Type_Conversion)\n-      then\n-         Call := Expression (Call);\n-      end if;\n+      Call := Unqual_Conv (Call);\n \n       if Is_Build_In_Place_Function_Call (Call) then\n "}, {"sha": "70ae80b7cea8c86400ceeada965e4253ffadf7f5", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0691ed6bd62582c22a33c42aa8f5303815a032af/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0691ed6bd62582c22a33c42aa8f5303815a032af/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=0691ed6bd62582c22a33c42aa8f5303815a032af", "patch": "@@ -774,12 +774,6 @@ package Exp_Util is\n    function Is_Non_BIP_Func_Call (Expr : Node_Id) return Boolean;\n    --  Determine whether node Expr denotes a non build-in-place function call\n \n-   function Is_Object_Access_BIP_Func_Call\n-      (Expr   : Node_Id;\n-       Obj_Id : Entity_Id) return Boolean;\n-   --  Determine if Expr denotes a build-in-place function which stores its\n-   --  result in the BIPaccess actual parameter whose prefix must match Obj_Id.\n-\n    function Is_Possibly_Unaligned_Object (N : Node_Id) return Boolean;\n    --  Node N is an object reference. This function returns True if it is\n    --  possible that the object may not be aligned according to the normal"}, {"sha": "58c46a95a28bcf61734f1683bfb37aeb8cec2bcc", "filename": "gcc/ada/par-ch6.adb", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0691ed6bd62582c22a33c42aa8f5303815a032af/gcc%2Fada%2Fpar-ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0691ed6bd62582c22a33c42aa8f5303815a032af/gcc%2Fada%2Fpar-ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch6.adb?ref=0691ed6bd62582c22a33c42aa8f5303815a032af", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -810,10 +810,15 @@ package body Ch6 is\n                      end if;\n                   end if;\n \n-                  --  Fall through if we have a likely expression function\n+                  --  Fall through if we have a likely expression function.\n+                  --  If the starting keyword is not \"function\" the error\n+                  --  will be reported elsewhere.\n+\n+                  if Func then\n+                     Error_Msg_SC\n+                       (\"expression function must be enclosed in parentheses\");\n+                  end if;\n \n-                  Error_Msg_SC\n-                    (\"expression function must be enclosed in parentheses\");\n                   return True;\n                end Likely_Expression_Function;\n \n@@ -844,12 +849,20 @@ package body Ch6 is\n \n                   --  This case is correctly processed by the parser because\n                   --  the expression function first appears as a subprogram\n-                  --  declaration to the parser.\n+                  --  declaration to the parser. The starting keyword may\n+                  --  not have been \"function\" in which case the error is\n+                  --  on a malformed procedure.\n \n                   if Is_Non_Empty_List (Aspects) then\n-                     Error_Msg\n-                       (\"aspect specifications must come after parenthesized \"\n-                        & \"expression\", Sloc (First (Aspects)));\n+                     if Func then\n+                        Error_Msg (\"aspect specifications must come after \"\n+                          & \"parenthesized expression\",\n+                            Sloc (First (Aspects)));\n+                     else\n+                        Error_Msg (\"aspect specifications must come after \"\n+                          & \"subprogram specification\",\n+                            Sloc (First (Aspects)));\n+                     end if;\n                   end if;\n \n                   --  Parse out expression and build expression function"}, {"sha": "feef95a3283ba615589807063ae2e2d87d81f0a9", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0691ed6bd62582c22a33c42aa8f5303815a032af/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0691ed6bd62582c22a33c42aa8f5303815a032af/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=0691ed6bd62582c22a33c42aa8f5303815a032af", "patch": "@@ -1394,6 +1394,7 @@ package body Sem_Attr is\n \n          elsif not Nkind_In (Subp_Decl, N_Abstract_Subprogram_Declaration,\n                                         N_Entry_Declaration,\n+                                        N_Expression_Function,\n                                         N_Generic_Subprogram_Declaration,\n                                         N_Subprogram_Body,\n                                         N_Subprogram_Body_Stub,"}, {"sha": "a99d2ee065c4832ef851f37c031c4c6027d9885c", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0691ed6bd62582c22a33c42aa8f5303815a032af/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0691ed6bd62582c22a33c42aa8f5303815a032af/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=0691ed6bd62582c22a33c42aa8f5303815a032af", "patch": "@@ -8700,6 +8700,9 @@ package body Sem_Ch13 is\n             FBody : Node_Id;\n \n          begin\n+            Set_Ekind (SIdB, E_Function);\n+            Set_Is_Predicate_Function (SIdB);\n+\n             --  The predicate function is shared between views of a type\n \n             if Is_Private_Type (Typ) and then Present (Full_View (Typ)) then\n@@ -12664,6 +12667,7 @@ package body Sem_Ch13 is\n       ------------------\n \n       function Resolve_Name (N : Node_Id) return Traverse_Result is\n+         Dummy : Traverse_Result;\n       begin\n          if Nkind (N) = N_Selected_Component then\n             if Nkind (Prefix (N)) = N_Identifier\n@@ -12681,6 +12685,12 @@ package body Sem_Ch13 is\n                Set_Entity (N, Empty);\n             end if;\n \n+         --  The name is component association needs no resolution.\n+\n+         elsif Nkind (N) = N_Component_Association then\n+            Dummy := Resolve_Name (Expression (N));\n+            return Skip;\n+\n          elsif Nkind (N) = N_Quantified_Expression then\n             return Skip;\n          end if;\n@@ -12722,14 +12732,19 @@ package body Sem_Ch13 is\n                      | Aspect_Static_Predicate\n                   =>\n                      --  Build predicate function specification and preanalyze\n-                     --  expression after type replacement.\n+                     --  expression after type replacement. The function\n+                     --  declaration must be analyzed in the scope of the\n+                     --  type, but the expression must see components.\n \n                      if No (Predicate_Function (E)) then\n+                        Uninstall_Discriminants_And_Pop_Scope (E);\n                         declare\n                            FDecl : constant Node_Id :=\n                                      Build_Predicate_Function_Declaration (E);\n                            pragma Unreferenced (FDecl);\n+\n                         begin\n+                           Push_Scope_And_Install_Discriminants (E);\n                            Resolve_Aspect_Expression (Expr);\n                         end;\n                      end if;"}, {"sha": "7e2225565ab911d8b169bef73e15d5bd68510fc3", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0691ed6bd62582c22a33c42aa8f5303815a032af/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0691ed6bd62582c22a33c42aa8f5303815a032af/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=0691ed6bd62582c22a33c42aa8f5303815a032af", "patch": "@@ -11588,6 +11588,12 @@ package body Sem_Ch6 is\n \n       if Ekind (Subp) = E_Procedure and then Is_Null_Init_Proc (Subp) then\n          return;\n+\n+      --  Within a predicate function we do not want to generate local\n+      --  subtypes that may generate nested predicate functions.\n+\n+      elsif Is_Subprogram (Subp) and then Is_Predicate_Function (Subp) then\n+         return;\n       end if;\n \n       --  The subtype declarations may freeze the formals. The body generated"}, {"sha": "f96c073f3afbac38660b0f5984700f76c5158de8", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0691ed6bd62582c22a33c42aa8f5303815a032af/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0691ed6bd62582c22a33c42aa8f5303815a032af/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=0691ed6bd62582c22a33c42aa8f5303815a032af", "patch": "@@ -402,6 +402,18 @@ package body Sem_Ch7 is\n                      end if;\n                   end if;\n \n+               --  Freeze node\n+\n+               elsif Nkind (Decl) = N_Freeze_Entity then\n+                  declare\n+                     Discard : Boolean;\n+                     pragma Unreferenced (Discard);\n+                  begin\n+                     --  Inspect the actions to find references to subprograms\n+\n+                     Discard := Has_Referencer (Actions (Decl));\n+                  end;\n+\n                --  Exceptions, objects and renamings do not need to be public\n                --  if they are not followed by a construct which can reference\n                --  and export them. The Is_Public flag is reset on top level\n@@ -484,7 +496,7 @@ package body Sem_Ch7 is\n \n          --  Local variables\n \n-         Discard : Boolean := True;\n+         Discard : Boolean;\n          pragma Unreferenced (Discard);\n \n       --  Start of processing for Hide_Public_Entities"}, {"sha": "bb3658478b20f33a96a6e2e39e7abf70c92623c4", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0691ed6bd62582c22a33c42aa8f5303815a032af/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0691ed6bd62582c22a33c42aa8f5303815a032af/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=0691ed6bd62582c22a33c42aa8f5303815a032af", "patch": "@@ -7138,6 +7138,24 @@ package body Sem_Prag is\n                Set_Treat_As_Volatile (Underlying_Type (E));\n             end if;\n \n+            --  Apply Volatile to the composite type's individual components,\n+            --  (RM C.6(8/3)).\n+\n+            if Prag_Id = Pragma_Volatile\n+              and then Is_Record_Type (Etype (E))\n+            then\n+               declare\n+                  Comp : Entity_Id;\n+               begin\n+                  Comp := First_Component (E);\n+                  while Present (Comp) loop\n+                     Mark_Component_Or_Object (Comp);\n+\n+                     Next_Component (Comp);\n+                  end loop;\n+               end;\n+            end if;\n+\n          --  Deal with the case where the pragma/attribute applies to a\n          --  component or object declaration.\n "}, {"sha": "3ca92ce3fb752e25e6cdf1e56dec877fd4111b34", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0691ed6bd62582c22a33c42aa8f5303815a032af/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0691ed6bd62582c22a33c42aa8f5303815a032af/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=0691ed6bd62582c22a33c42aa8f5303815a032af", "patch": "@@ -15734,22 +15734,10 @@ package body Sem_Util is\n    --------------------------------------\n \n    function Is_Validation_Variable_Reference (N : Node_Id) return Boolean is\n-      Var    : Node_Id;\n+      Var    : constant Node_Id := Unqual_Conv (N);\n       Var_Id : Entity_Id;\n \n    begin\n-      Var := N;\n-\n-      --  Use the expression when the context qualifies a reference in some\n-      --  fashion.\n-\n-      while Nkind_In (Var, N_Qualified_Expression,\n-                           N_Type_Conversion,\n-                           N_Unchecked_Type_Conversion)\n-      loop\n-         Var := Expression (Var);\n-      end loop;\n-\n       Var_Id := Empty;\n \n       if Is_Entity_Name (Var) then\n@@ -22497,6 +22485,28 @@ package body Sem_Util is\n       end if;\n    end Unqualify;\n \n+   -----------------\n+   -- Unqual_Conv --\n+   -----------------\n+\n+   function Unqual_Conv (Expr : Node_Id) return Node_Id is\n+   begin\n+      --  Recurse to handle unlikely case of multiple levels of qualification\n+      --  and/or conversion.\n+\n+      if Nkind_In (Expr, N_Qualified_Expression,\n+                         N_Type_Conversion,\n+                         N_Unchecked_Type_Conversion)\n+      then\n+         return Unqual_Conv (Expression (Expr));\n+\n+      --  Normal case, not a qualified expression\n+\n+      else\n+         return Expr;\n+      end if;\n+   end Unqual_Conv;\n+\n    -----------------------\n    -- Visible_Ancestors --\n    -----------------------"}, {"sha": "bc7622425f50a8611d1539d3157be1858cd890de", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0691ed6bd62582c22a33c42aa8f5303815a032af/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0691ed6bd62582c22a33c42aa8f5303815a032af/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=0691ed6bd62582c22a33c42aa8f5303815a032af", "patch": "@@ -2571,6 +2571,11 @@ package Sem_Util is\n    --  Removes any qualifications from Expr. For example, for T1'(T2'(X)), this\n    --  returns X. If Expr is not a qualified expression, returns Expr.\n \n+   function Unqual_Conv (Expr : Node_Id) return Node_Id;\n+   pragma Inline (Unqual_Conv);\n+   --  Similar to Unqualify, but removes qualified expressions, type\n+   --  conversions, and unchecked conversions.\n+\n    function Visible_Ancestors (Typ : Entity_Id) return Elist_Id;\n    --  [Ada 2012:AI-0125-1]: Collect all the visible parents and progenitors\n    --  of a type extension or private extension declaration. If the full-view"}]}