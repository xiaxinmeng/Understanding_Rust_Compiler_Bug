{"sha": "7e204bd2f189850cb940677c99d8d93eb7dd40cd", "node_id": "C_kwDOANBUbNoAKDdlMjA0YmQyZjE4OTg1MGNiOTQwNjc3Yzk5ZDhkOTNlYjdkZDQwY2Q", "commit": {"author": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2022-01-24T03:05:47Z"}, "committer": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2022-02-13T09:57:38Z"}, "message": "Add vect_recog_cond_expr_convert_pattern.\n\nThe pattern converts (cond (cmp a b) (convert c) (convert d))\nto (convert (cond (cmp a b) c d)) when\n1) types_match (c, d)\n2) single_use for (convert c) and (convert d)\n3) TYPE_PRECISION (TREE_TYPE (c)) == TYPE_PRECISION (TREE_TYPE (a))\n4) INTEGERAL_TYPE_P (TREE_TYPE (c))\n\nThe pattern can save packing of mask and data(partial for data, 2 vs\n1).\n\ngcc/ChangeLog:\n\n\tPR target/103771\n\t* match.pd (cond_expr_convert_p): New match.\n\t* tree-vect-patterns.cc (gimple_cond_expr_convert_p): Declare.\n\t(vect_recog_cond_expr_convert_pattern): New.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/i386/pr103771-2.c: New test.\n\t* gcc.target/i386/pr103771-3.c: New test.", "tree": {"sha": "3d8eb6dd756e3aa0792cd257f77689c2450155ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d8eb6dd756e3aa0792cd257f77689c2450155ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e204bd2f189850cb940677c99d8d93eb7dd40cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e204bd2f189850cb940677c99d8d93eb7dd40cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e204bd2f189850cb940677c99d8d93eb7dd40cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e204bd2f189850cb940677c99d8d93eb7dd40cd/comments", "author": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "committer": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23756b70630d6576c9d498cc85ae1dde38a1d5d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23756b70630d6576c9d498cc85ae1dde38a1d5d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23756b70630d6576c9d498cc85ae1dde38a1d5d0"}], "stats": {"total": 139, "additions": 139, "deletions": 0}, "files": [{"sha": "05a10ab6bfd1162d876a467755b2b88f78da7ca0", "filename": "gcc/match.pd", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e204bd2f189850cb940677c99d8d93eb7dd40cd/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e204bd2f189850cb940677c99d8d93eb7dd40cd/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=7e204bd2f189850cb940677c99d8d93eb7dd40cd", "patch": "@@ -7686,3 +7686,17 @@ and,\n    to the number of trailing zeroes.  */\n (match (ctz_table_index @1 @2 @3)\n   (rshift (mult (bit_and:c (negate @1) @1) INTEGER_CST@2) INTEGER_CST@3))\n+\n+(match (cond_expr_convert_p @0 @2 @3 @6)\n+ (cond (simple_comparison@6 @0 @1) (convert@4 @2) (convert@5 @3))\n+  (if (INTEGRAL_TYPE_P (type)\n+       && INTEGRAL_TYPE_P (TREE_TYPE (@2))\n+       && INTEGRAL_TYPE_P (TREE_TYPE (@0))\n+       && INTEGRAL_TYPE_P (TREE_TYPE (@3))\n+       && TYPE_PRECISION (type) != TYPE_PRECISION (TREE_TYPE (@0))\n+       && TYPE_PRECISION (TREE_TYPE (@0))\n+\t  == TYPE_PRECISION (TREE_TYPE (@2))\n+       && TYPE_PRECISION (TREE_TYPE (@0))\n+\t  == TYPE_PRECISION (TREE_TYPE (@3))\n+       && single_use (@4)\n+       && single_use (@5))))"}, {"sha": "962a3a74ecf0571a01f6202788bc2d53161f8076", "filename": "gcc/testsuite/gcc.target/i386/pr103771-2.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e204bd2f189850cb940677c99d8d93eb7dd40cd/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103771-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e204bd2f189850cb940677c99d8d93eb7dd40cd/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103771-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103771-2.c?ref=7e204bd2f189850cb940677c99d8d93eb7dd40cd", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=cascadelake -O3\" } */\n+/* { dg-final { scan-assembler-not \"kunpck\" } } */\n+/* { dg-final { scan-assembler-not \"kand\" } } */\n+/* { dg-final { scan-assembler-not \"kor\" } } */\n+/* { dg-final { scan-assembler-not \"kshift\" } } */\n+\n+#include \"pr103771.c\""}, {"sha": "ef379b23b12655b97aaf06d382ddbed1cd0f6862", "filename": "gcc/testsuite/gcc.target/i386/pr103771-3.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e204bd2f189850cb940677c99d8d93eb7dd40cd/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103771-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e204bd2f189850cb940677c99d8d93eb7dd40cd/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103771-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103771-3.c?ref=7e204bd2f189850cb940677c99d8d93eb7dd40cd", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=cascadelake -O3\" } */\n+/* { dg-final { scan-assembler-not \"kunpck\" } } */\n+/* { dg-final { scan-assembler-not \"kand\" } } */\n+/* { dg-final { scan-assembler-not \"kor\" } } */\n+/* { dg-final { scan-assembler-not \"kshift\" } } */\n+\n+typedef unsigned char uint8_t;\n+\n+static uint8_t x264_clip_uint8 (int x, unsigned int y)\n+{\n+  return x & (~255) ? (-x) >> 31 : y;\n+}\n+\n+void\n+mc_weight (uint8_t* __restrict dst, uint8_t* __restrict src,\n+\t   int i_width,int i_scale, unsigned int* __restrict y)\n+{\n+  for(int x = 0; x < i_width; x++)\n+    dst[x] = x264_clip_uint8 (src[x] * i_scale, y[x]);\n+}"}, {"sha": "a8f96d59643de757bb5a8cc9408856de308c1d48", "filename": "gcc/tree-vect-patterns.cc", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e204bd2f189850cb940677c99d8d93eb7dd40cd/gcc%2Ftree-vect-patterns.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e204bd2f189850cb940677c99d8d93eb7dd40cd/gcc%2Ftree-vect-patterns.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.cc?ref=7e204bd2f189850cb940677c99d8d93eb7dd40cd", "patch": "@@ -924,6 +924,101 @@ vect_reassociating_reduction_p (vec_info *vinfo,\n   return true;\n }\n \n+/* match.pd function to match\n+   (cond (cmp@3 a b) (convert@1 c) (convert@2 d))\n+   with conditions:\n+   1) @1, @2, c, d, a, b are all integral type.\n+   2) There's single_use for both @1 and @2.\n+   3) a, c and d have same precision.\n+   4) c and @1 have different precision.\n+\n+   record a and c and d and @3.  */\n+\n+extern bool gimple_cond_expr_convert_p (tree, tree*, tree (*)(tree));\n+\n+/* Function vect_recog_cond_expr_convert\n+\n+   Try to find the following pattern:\n+\n+   TYPE_AB A,B;\n+   TYPE_CD C,D;\n+   TYPE_E E;\n+   TYPE_E op_true = (TYPE_E) A;\n+   TYPE_E op_false = (TYPE_E) B;\n+\n+   E = C cmp D ? op_true : op_false;\n+\n+   where\n+   TYPE_PRECISION (TYPE_E) != TYPE_PRECISION (TYPE_CD);\n+   TYPE_PRECISION (TYPE_AB) == TYPE_PRECISION (TYPE_CD);\n+   single_use of op_true and op_false.\n+   TYPE_AB could differ in sign.\n+\n+   Input:\n+\n+   * STMT_VINFO: The stmt from which the pattern search begins.\n+   here it starts with E = c cmp D ? op_true : op_false;\n+\n+   Output:\n+\n+   TYPE1 E' = C cmp D ? A : B;\n+   TYPE3 E = (TYPE3) E';\n+\n+   There may extra nop_convert for A or B to handle different signness.\n+\n+   * TYPE_OUT: The vector type of the output of this pattern.\n+\n+   * Return value: A new stmt that will be used to replace the sequence of\n+   stmts that constitute the pattern. In this case it will be:\n+   E = (TYPE3)E';\n+   E' = C cmp D ? A : B; is recorded in pattern definition statements;  */\n+\n+static gimple *\n+vect_recog_cond_expr_convert_pattern (vec_info *vinfo,\n+\t\t\t\t      stmt_vec_info stmt_vinfo, tree *type_out)\n+{\n+  gassign *last_stmt = dyn_cast <gassign *> (stmt_vinfo->stmt);\n+  tree lhs, match[4], temp, type, new_lhs, op2;\n+  gimple *cond_stmt;\n+  gimple *pattern_stmt;\n+\n+  if (!last_stmt)\n+    return NULL;\n+\n+  lhs = gimple_assign_lhs (last_stmt);\n+\n+  /* Find E = C cmp D ? (TYPE3) A ? (TYPE3) B;\n+     TYPE_PRECISION (A) == TYPE_PRECISION (C).  */\n+  if (!gimple_cond_expr_convert_p (lhs, &match[0], NULL))\n+    return NULL;\n+\n+  vect_pattern_detected (\"vect_recog_cond_expr_convert_pattern\", last_stmt);\n+\n+  op2 = match[2];\n+  type = TREE_TYPE (match[1]);\n+  if (TYPE_SIGN (type) != TYPE_SIGN (TREE_TYPE (match[2])))\n+    {\n+      op2 = vect_recog_temp_ssa_var (type, NULL);\n+      gimple* nop_stmt = gimple_build_assign (op2, NOP_EXPR, match[2]);\n+      append_pattern_def_seq (vinfo, stmt_vinfo, nop_stmt,\n+\t\t\t      get_vectype_for_scalar_type (vinfo, type));\n+    }\n+\n+  temp = vect_recog_temp_ssa_var (type, NULL);\n+  cond_stmt = gimple_build_assign (temp, build3 (COND_EXPR, type, match[3],\n+\t\t\t\t\t\t match[1], op2));\n+  append_pattern_def_seq (vinfo, stmt_vinfo, cond_stmt,\n+\t\t\t  get_vectype_for_scalar_type (vinfo, type));\n+  new_lhs = vect_recog_temp_ssa_var (TREE_TYPE (lhs), NULL);\n+  pattern_stmt = gimple_build_assign (new_lhs, NOP_EXPR, temp);\n+  *type_out = STMT_VINFO_VECTYPE (stmt_vinfo);\n+\n+  if (dump_enabled_p ())\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"created pattern stmt: %G\", pattern_stmt);\n+  return pattern_stmt;\n+}\n+\n /* Function vect_recog_dot_prod_pattern\n \n    Try to find the following pattern:\n@@ -5492,6 +5587,7 @@ static vect_recog_func vect_vect_recog_func_ptrs[] = {\n   /* Must come after over_widening, which narrows the shift as much as\n      possible beforehand.  */\n   { vect_recog_average_pattern, \"average\" },\n+  { vect_recog_cond_expr_convert_pattern, \"cond_expr_convert\" },\n   { vect_recog_mulhs_pattern, \"mult_high\" },\n   { vect_recog_cast_forwprop_pattern, \"cast_forwprop\" },\n   { vect_recog_widen_mult_pattern, \"widen_mult\" },"}]}