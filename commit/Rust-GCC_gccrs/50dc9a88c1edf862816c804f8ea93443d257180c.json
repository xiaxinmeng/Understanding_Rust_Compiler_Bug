{"sha": "50dc9a88c1edf862816c804f8ea93443d257180c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTBkYzlhODhjMWVkZjg2MjgxNmM4MDRmOGVhOTM0NDNkMjU3MTgwYw==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@redhat.com", "date": "2004-08-18T18:21:23Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2004-08-18T18:21:23Z"}, "message": "tree-dfa.c (add_referenced_var): Only global variables are call-clobbered.\n\n\n\t* tree-dfa.c (add_referenced_var): Only global variables are\n\tcall-clobbered.\n\t* tree-flow.h (struct ptr_info_def): Add field pt_global_mem.\n\t* tree-ssa-alias.c (compute_points_to_and_addr_escape): Mark\n\tall pointers dereferenced if the statement dereferences them.\n\t(create_name_tags): Do not create memory tags for pointers\n\tthat have PT_ANYTHING set.\n\tAlso check if PT_VARS is not empty before creating a name tag.\n\t(compute_flow_sensitive_aliasing): Don't mark call-clobbered\n\tvariables that share the same alias set with a pointer that\n\tmay point anywhere.\n\t(add_may_alias): Add FIXME comment to remove clobbering\n\taliased variables and tags.\n\t(replace_may_alias): Likewise.\n\t(set_pt_anything): Do not clear PT_VARS nor IS_DEREFERENCED.\n\t(merge_pointed_to_info): If the original variable has not\n\tpoints-to information, call set_pt_anything.\n\t(add_pointed_to_var): Do not prevent adding a pointed-to\n\tvariable if the pointers is PT_ANYTHING.\n\tIf the variable is a global, set PT_GLOBAL_MEM.\n\t(collect_points_to_info_r): Don't assume that PLUS_EXPRs of\n\tpointer type only come in PTR+OFFSET flavours.\n\tAlways call merge_pointed_to_info on PHI arguments that are\n\tSSA_NAMEs.\n\t(get_nmt_for): Mark call-clobbered tags whose pointer points\n\tto global memory.\n\t* tree-ssa-operands.c (opf_kill_def, opf_no_vops): Switch\n\tvalues.\n\t(get_indirect_ref_operands): Always clear OPF_KILL_DEF from\n\tFLAGS.\n\t(add_stmt_operand): Abort if the caller tried to add a killing\n\tdefinition for a memory tag.\n\t* tree-ssa.c (verify_flow_sensitive_alias_info): Remove\n\tunnecessary checks.\n\nFrom-SVN: r86198", "tree": {"sha": "44097e1b0caa8eb28b72d009d6ad0158ac4c06a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44097e1b0caa8eb28b72d009d6ad0158ac4c06a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50dc9a88c1edf862816c804f8ea93443d257180c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50dc9a88c1edf862816c804f8ea93443d257180c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50dc9a88c1edf862816c804f8ea93443d257180c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50dc9a88c1edf862816c804f8ea93443d257180c/comments", "author": null, "committer": null, "parents": [{"sha": "bb0452b18763a8aa8e082a289ae5848a1753ba3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb0452b18763a8aa8e082a289ae5848a1753ba3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb0452b18763a8aa8e082a289ae5848a1753ba3e"}], "stats": {"total": 229, "additions": 129, "deletions": 100}, "files": [{"sha": "d4e6bc38b7ce7f640535bedc5cdd5eb0deedb951", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dc9a88c1edf862816c804f8ea93443d257180c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dc9a88c1edf862816c804f8ea93443d257180c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=50dc9a88c1edf862816c804f8ea93443d257180c", "patch": "@@ -1,3 +1,40 @@\n+2004-08-18  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* tree-dfa.c (add_referenced_var): Only global variables are\n+\tcall-clobbered.\n+\t* tree-flow.h (struct ptr_info_def): Add field pt_global_mem.\n+\t* tree-ssa-alias.c (compute_points_to_and_addr_escape): Mark\n+\tall pointers dereferenced if the statement dereferences them.\n+\t(create_name_tags): Do not create memory tags for pointers\n+\tthat have PT_ANYTHING set.\n+\tAlso check if PT_VARS is not empty before creating a name tag.\n+\t(compute_flow_sensitive_aliasing): Don't mark call-clobbered\n+\tvariables that share the same alias set with a pointer that\n+\tmay point anywhere.\n+\t(add_may_alias): Add FIXME comment to remove clobbering\n+\taliased variables and tags.\n+\t(replace_may_alias): Likewise.\n+\t(set_pt_anything): Do not clear PT_VARS nor IS_DEREFERENCED.\n+\t(merge_pointed_to_info): If the original variable has not\n+\tpoints-to information, call set_pt_anything.\n+\t(add_pointed_to_var): Do not prevent adding a pointed-to\n+\tvariable if the pointers is PT_ANYTHING.\n+\tIf the variable is a global, set PT_GLOBAL_MEM.\n+\t(collect_points_to_info_r): Don't assume that PLUS_EXPRs of\n+\tpointer type only come in PTR+OFFSET flavours.\n+\tAlways call merge_pointed_to_info on PHI arguments that are\n+\tSSA_NAMEs.\n+\t(get_nmt_for): Mark call-clobbered tags whose pointer points\n+\tto global memory.\n+\t* tree-ssa-operands.c (opf_kill_def, opf_no_vops): Switch\n+\tvalues.\n+\t(get_indirect_ref_operands): Always clear OPF_KILL_DEF from\n+\tFLAGS.\n+\t(add_stmt_operand): Abort if the caller tried to add a killing\n+\tdefinition for a memory tag.\n+\t* tree-ssa.c (verify_flow_sensitive_alias_info): Remove\n+\tunnecessary checks.\n+\n 2004-08-18  J\"orn Rennecke <joern.rennecke@superh.com>\n \n \t* sh.h (CONDITIONAL_REGISTER_USAGE): Don't exclude fixed registers"}, {"sha": "b8a9b03324f7f0265124539a95a92357cbc34f9f", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dc9a88c1edf862816c804f8ea93443d257180c/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dc9a88c1edf862816c804f8ea93443d257180c/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=50dc9a88c1edf862816c804f8ea93443d257180c", "patch": "@@ -903,10 +903,8 @@ add_referenced_var (tree var, struct walk_state *walk_state)\n       v_ann->uid = num_referenced_vars;\n       VARRAY_PUSH_TREE (referenced_vars, var);\n \n-      /* Initially assume that all memory variables are\n-\t call-clobbered.  This will be refined later by the alias\n-\t analyzer.  */\n-      if (needs_to_live_in_memory (var))\n+      /* Global variables are always call-clobbered.  */\n+      if (is_global_var (var))\n \tmark_call_clobbered (var);\n \n       /* If an initialized global variable then register the initializer"}, {"sha": "ca5897afa49ae6a592add31a3e51aa5495003c59", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dc9a88c1edf862816c804f8ea93443d257180c/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dc9a88c1edf862816c804f8ea93443d257180c/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=50dc9a88c1edf862816c804f8ea93443d257180c", "patch": "@@ -62,6 +62,9 @@ struct ptr_info_def GTY(())\n   /* Nonzero if this pointer is dereferenced.  */\n   unsigned int is_dereferenced : 1;\n \n+  /* Nonzero if this pointer points to a global variable.  */\n+  unsigned int pt_global_mem : 1;\n+\n   /* Set of variables that this pointer may point to.  */\n   bitmap pt_vars;\n "}, {"sha": "8cfc65ad35fc93ba804eb47f8f13e8951398fe0b", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 61, "deletions": 73, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dc9a88c1edf862816c804f8ea93443d257180c/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dc9a88c1edf862816c804f8ea93443d257180c/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=50dc9a88c1edf862816c804f8ea93443d257180c", "patch": "@@ -653,16 +653,14 @@ compute_points_to_and_addr_escape (struct alias_info *ai)\n \n \t      collect_points_to_info_for (ai, op);\n \n-\t      pi =  SSA_NAME_PTR_INFO (op);\n+\t      pi = SSA_NAME_PTR_INFO (op);\n \t      if (ptr_is_dereferenced_by (op, stmt, &is_store))\n \t\t{\n-\t\t  /* If we found OP to point to a set of variables or\n-\t\t     malloc, then mark it as being dereferenced.  In a\n-\t\t     subsequent pass, dereferenced pointers that point\n-\t\t     to a set of variables will be assigned a name tag\n-\t\t     to alias all the variables OP points to.  */\n-\t\t  if (pi->pt_malloc || pi->pt_vars)\n-\t\t    pi->is_dereferenced = 1;\n+\t\t  /* Mark OP as dereferenced.  In a subsequent pass,\n+\t\t     dereferenced pointers that point to a set of\n+\t\t     variables will be assigned a name tag to alias\n+\t\t     all the variables OP points to.  */\n+\t\t  pi->is_dereferenced = 1;\n \n \t\t  /* Keep track of how many time we've dereferenced each\n \t\t     pointer.  Again, we don't need to grow\n@@ -762,15 +760,16 @@ create_name_tags (struct alias_info *ai)\n       tree ptr = VARRAY_TREE (ai->processed_ptrs, i);\n       struct ptr_info_def *pi = SSA_NAME_PTR_INFO (ptr);\n \n-      if (!pi->is_dereferenced)\n+      if (pi->pt_anything || !pi->is_dereferenced)\n \t{\n \t  /* No name tags for pointers that have not been\n-\t     dereferenced.  */\n+\t     dereferenced or point to an arbitrary location.  */\n \t  pi->name_mem_tag = NULL_TREE;\n \t  continue;\n \t}\n \n-      if (pi->pt_vars)\n+      if (pi->pt_vars\n+\t  && bitmap_first_set_bit (pi->pt_vars) >= 0)\n \t{\n \t  size_t j;\n \t  tree old_name_tag = pi->name_mem_tag;\n@@ -859,38 +858,14 @@ compute_flow_sensitive_aliasing (struct alias_info *ai)\n       if (pi->value_escapes_p || pi->pt_anything)\n \t{\n \t  /* If PTR escapes or may point to anything, then its associated\n-\t     memory tags are call-clobbered.  */\n+\t     memory tags and pointed-to variables are call-clobbered.  */\n \t  if (pi->name_mem_tag)\n \t    mark_call_clobbered (pi->name_mem_tag);\n \n \t  if (v_ann->type_mem_tag)\n \t    mark_call_clobbered (v_ann->type_mem_tag);\n \n-\t  /* If PTR may point to anything, mark call-clobbered all the\n-\t     addressables with the same alias set as the type pointed-to by\n-\t     PTR.  */\n-\t  if (pi->pt_anything)\n-\t    {\n-\t      HOST_WIDE_INT ptr_set;\n-\t      ptr_set = get_alias_set (TREE_TYPE (TREE_TYPE (ptr)));\n-\t      for (j = 0; j < ai->num_addressable_vars; j++)\n-\t\t{\n-\t\t  struct alias_map_d *alias_map = ai->addressable_vars[j];\n-\t\t  if (alias_map->set == ptr_set)\n-\t\t    mark_call_clobbered (alias_map->var);\n-\t\t}\n-\t    }\n-\n-\t  /* If PTR's value may escape and PTR is never dereferenced, we\n-\t     need to mark all the variables PTR points-to as\n-\t     call-clobbered.  Note that we only need do this it PTR is\n-\t     never dereferenced.  If PTR is dereferenced, it will have a\n-\t     name memory tag, which will have been marked call-clobbered.\n-\t     This will in turn mark the pointed-to variables as\n-\t     call-clobbered when we call add_may_alias below.  */\n-\t  if (pi->value_escapes_p\n-\t      && pi->name_mem_tag == NULL_TREE\n-\t      && pi->pt_vars)\n+\t  if (pi->pt_vars)\n \t    EXECUTE_IF_SET_IN_BITMAP (pi->pt_vars, 0, j,\n \t\tmark_call_clobbered (referenced_var (j)));\n \t}\n@@ -1684,7 +1659,9 @@ add_may_alias (tree var, tree alias)\n     if (alias == VARRAY_TREE (v_ann->may_aliases, i))\n       return;\n \n-  /* If VAR is a call-clobbered variable, so is its new ALIAS.  */\n+  /* If VAR is a call-clobbered variable, so is its new ALIAS.\n+     FIXME, call-clobbering should only depend on whether an address\n+     escapes.  It should be independent of aliasing.  */\n   if (is_call_clobbered (var))\n     mark_call_clobbered (alias);\n \n@@ -1705,7 +1682,9 @@ replace_may_alias (tree var, size_t i, tree new_alias)\n   var_ann_t v_ann = var_ann (var);\n   VARRAY_TREE (v_ann->may_aliases, i) = new_alias;\n \n-  /* If VAR is a call-clobbered variable, so is NEW_ALIAS.  */\n+  /* If VAR is a call-clobbered variable, so is NEW_ALIAS.\n+     FIXME, call-clobbering should only depend on whether an address\n+     escapes.  It should be independent of aliasing.  */\n   if (is_call_clobbered (var))\n     mark_call_clobbered (new_alias);\n \n@@ -1724,8 +1703,6 @@ set_pt_anything (tree ptr)\n \n   pi->pt_anything = 1;\n   pi->pt_malloc = 0;\n-  pi->pt_vars = NULL;\n-  pi->is_dereferenced = 0;\n \n   /* The pointer used to have a name tag, but we now found it pointing\n      to an arbitrary location.  The name tag needs to be renamed and\n@@ -1812,6 +1789,8 @@ merge_pointed_to_info (struct alias_info *ai, tree dest, tree orig)\n \t\t           orig_pi->pt_vars);\n \t}\n     }\n+  else\n+    set_pt_anything (dest);\n }\n \n \n@@ -1882,14 +1861,14 @@ add_pointed_to_var (struct alias_info *ai, tree ptr, tree value)\n       uid = var_ann (pt_var)->uid;\n       bitmap_set_bit (ai->addresses_needed, uid);\n \n-      /* If PTR has already been found to point anywhere, don't\n-\t add the variable to PTR's points-to set.  */\n-      if (!pi->pt_anything)\n-\t{\n-\t  if (pi->pt_vars == NULL)\n-\t    pi->pt_vars = BITMAP_GGC_ALLOC ();\n-\t  bitmap_set_bit (pi->pt_vars, uid);\n-\t}\n+      if (pi->pt_vars == NULL)\n+\tpi->pt_vars = BITMAP_GGC_ALLOC ();\n+      bitmap_set_bit (pi->pt_vars, uid);\n+\n+      /* If the variable is a global, mark the pointer as pointing to\n+\t global memory (which will make its tag a global variable).  */\n+      if (is_global_var (pt_var))\n+\tpi->pt_global_mem = 1;\n     }\n }\n \n@@ -1937,17 +1916,33 @@ collect_points_to_info_r (tree var, tree stmt, void *data)\n \t  tree op0 = TREE_OPERAND (rhs, 0);\n \t  tree op1 = TREE_OPERAND (rhs, 1);\n \n-\t  if (TREE_CODE (op0) == SSA_NAME\n-\t      && POINTER_TYPE_P (TREE_TYPE (op0)))\n-\t    merge_pointed_to_info (ai, var, op0);\n-\t  else if (TREE_CODE (op1) == SSA_NAME\n-\t\t   && POINTER_TYPE_P (TREE_TYPE (op1)))\n-\t    merge_pointed_to_info (ai, var, op1);\n-\t  else if (TREE_CODE (op0) == ADDR_EXPR)\n-\t    add_pointed_to_var (ai, var, op0);\n-\t  else if (TREE_CODE (op1) == ADDR_EXPR)\n-\t    add_pointed_to_var (ai, var, op1);\n-\t  else\n+\t  /* Both operands may be of pointer type.  FIXME: Shouldn't\n+\t     we just expect PTR + OFFSET always?  */\n+\t  if (POINTER_TYPE_P (TREE_TYPE (op0)))\n+\t    {\n+\t      if (TREE_CODE (op0) == SSA_NAME)\n+\t\tmerge_pointed_to_info (ai, var, op0);\n+\t      else if (TREE_CODE (op0) == ADDR_EXPR)\n+\t\tadd_pointed_to_var (ai, var, op0);\n+\t      else\n+\t\tadd_pointed_to_expr (var, op0);\n+\t    }\n+\n+\t  if (POINTER_TYPE_P (TREE_TYPE (op1)))\n+\t    {\n+\t      if (TREE_CODE (op1) == SSA_NAME)\n+\t\tmerge_pointed_to_info (ai, var, op1);\n+\t      else if (TREE_CODE (op1) == ADDR_EXPR)\n+\t\tadd_pointed_to_var (ai, var, op1);\n+\t      else\n+\t\tadd_pointed_to_expr (var, op1);\n+\t    }\n+\n+\t  /* Neither operand is a pointer?  VAR can be pointing\n+\t     anywhere.   FIXME: Is this right?  If we get here, we\n+\t     found PTR = INT_CST + INT_CST.  */\n+\t  if (!POINTER_TYPE_P (TREE_TYPE (op0))\n+\t      && !POINTER_TYPE_P (TREE_TYPE (op1)))\n \t    add_pointed_to_expr (var, rhs);\n \t}\n \n@@ -1980,12 +1975,7 @@ collect_points_to_info_r (tree var, tree stmt, void *data)\n       if (TREE_CODE (var) == ADDR_EXPR)\n \tadd_pointed_to_var (ai, lhs, var);\n       else if (TREE_CODE (var) == SSA_NAME)\n-\t{\n-\t  if (bitmap_bit_p (ai->ssa_names_visited, SSA_NAME_VERSION (var)))\n-\t    merge_pointed_to_info (ai, lhs, var);\n-\t  else\n-\t    set_pt_anything (lhs);\n-\t}\n+\tmerge_pointed_to_info (ai, lhs, var);\n       else if (is_gimple_min_invariant (var))\n \tadd_pointed_to_expr (lhs, var);\n       else\n@@ -2106,13 +2096,11 @@ get_nmt_for (tree ptr)\n   if (tag == NULL_TREE)\n     tag = create_memory_tag (TREE_TYPE (TREE_TYPE (ptr)), false);\n \n-  /* If PTR is a PARM_DECL, its memory tag should be considered a global\n-     variable.  */\n-  if (TREE_CODE (SSA_NAME_VAR (ptr)) == PARM_DECL)\n-    mark_call_clobbered (tag);\n-\n-  /* Similarly, if PTR points to malloc, then TAG is a global.  */\n-  if (pi->pt_malloc)\n+  /* If PTR is a PARM_DECL, it points to a global variable or malloc,\n+     then its name tag should be considered a global variable.  */\n+  if (TREE_CODE (SSA_NAME_VAR (ptr)) == PARM_DECL\n+      || pi->pt_malloc\n+      || pi->pt_global_mem)\n     mark_call_clobbered (tag);\n \n   return tag;"}, {"sha": "230167f84e94f8476f97498f5047aa8c172a56b0", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dc9a88c1edf862816c804f8ea93443d257180c/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dc9a88c1edf862816c804f8ea93443d257180c/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=50dc9a88c1edf862816c804f8ea93443d257180c", "patch": "@@ -89,15 +89,15 @@ Boston, MA 02111-1307, USA.  */\n #define opf_is_def \t(1 << 0)\n \n /* Operand is the target of an assignment expression.  */\n-#define opf_kill_def \t(1 << 2)\n+#define opf_kill_def \t(1 << 1)\n \n /* No virtual operands should be created in the expression.  This is used\n    when traversing ADDR_EXPR nodes which have different semantics than\n    other expressions.  Inside an ADDR_EXPR node, the only operands that we\n    need to consider are indices into arrays.  For instance, &a.b[i] should\n    generate a USE of 'i' but it should not generate a VUSE for 'a' nor a\n    VUSE for 'b'.  */\n-#define opf_no_vops \t(1 << 1)\n+#define opf_no_vops \t(1 << 2)\n \n /* Array for building all the def operands.  */\n static GTY (()) varray_type build_defs;\n@@ -1273,6 +1273,8 @@ get_indirect_ref_operands (tree stmt, tree expr, int flags)\n   tree ptr = *pptr;\n   stmt_ann_t ann = stmt_ann (stmt);\n \n+  /* Stores into INDIRECT_REF operands are never killing definitions.  */\n+  flags &= ~opf_kill_def;\n \n   if (SSA_VAR_P (ptr))\n     {\n@@ -1456,20 +1458,31 @@ add_stmt_operand (tree *var_p, tree stmt, int flags)\n \t    {\n \t      if (v_ann->is_alias_tag)\n \t        {\n-\t\t  /* Alias tagged vars get regular V_MAY_DEF  */\n+\t\t  /* Alias tagged vars get V_MAY_DEF to avoid breaking\n+\t\t     def-def chains with the other variables in their\n+\t\t     alias sets.  */\n \t\t  if (s_ann)\n \t\t    s_ann->makes_aliased_stores = 1;\n \t\t  append_v_may_def (var);\n \t\t}\n-\t      else if ((flags & opf_kill_def) \n-\t                && v_ann->mem_tag_kind == NOT_A_TAG)\n-\t        /* V_MUST_DEF for non-aliased non-GIMPLE register \n-\t\t   variable definitions. Avoid memory tags.  */\n-\t        append_v_must_def (var);\n+\t      else if (flags & opf_kill_def)\n+\t\t{\n+#if defined ENABLE_CHECKING\n+\t\t  /* Only regular variables may get a V_MUST_DEF\n+\t\t     operand.  */\n+\t\t  if (v_ann->mem_tag_kind != NOT_A_TAG)\n+\t\t    abort ();\n+#endif\n+\t\t  /* V_MUST_DEF for non-aliased, non-GIMPLE register \n+\t\t    variable definitions.  */\n+\t\t  append_v_must_def (var);\n+\t\t}\n \t      else\n-\t        /* Call-clobbered variables & memory tags get \n-\t\t   V_MAY_DEF  */\n-\t\tappend_v_may_def (var);\n+\t\t{\n+\t\t  /* Add a V_MAY_DEF for call-clobbered variables and\n+\t\t     memory tags.  */\n+\t\t  append_v_may_def (var);\n+\t\t}\n \t    }\n \t  else\n \t    {\n@@ -1506,6 +1519,8 @@ add_stmt_operand (tree *var_p, tree stmt, int flags)\n \t    }\n \t  else\n \t    {\n+\t      /* Similarly, append a virtual uses for VAR itself, when\n+\t\t it is an alias tag.  */\n \t      if (v_ann->is_alias_tag)\n \t\tappend_vuse (var);\n "}, {"sha": "743c08433668b130839f7af06c5a7e8dac08bad3", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dc9a88c1edf862816c804f8ea93443d257180c/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dc9a88c1edf862816c804f8ea93443d257180c/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=50dc9a88c1edf862816c804f8ea93443d257180c", "patch": "@@ -433,18 +433,6 @@ verify_flow_sensitive_alias_info (void)\n \t  goto err;\n \t}\n \n-      if (pi->pt_anything && (pi->pt_malloc || pi->pt_vars))\n-\t{\n-\t  error (\"Pointers that point to anything should not point to malloc or other vars\");\n-\t  goto err;\n-\t}\n-      \n-      if (pi->pt_malloc && pi->pt_vars)\n-\t{\n-\t  error (\"Pointers pointing to malloc get a unique tag and cannot point to other vars\");\n-\t  goto err;\n-\t}\n-\n       if (pi->name_mem_tag\n \t  && !pi->pt_malloc\n \t  && (pi->pt_vars == NULL"}]}