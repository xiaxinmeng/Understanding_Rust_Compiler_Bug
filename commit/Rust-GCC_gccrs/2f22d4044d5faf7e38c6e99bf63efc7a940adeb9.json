{"sha": "2f22d4044d5faf7e38c6e99bf63efc7a940adeb9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmYyMmQ0MDQ0ZDVmYWY3ZTM4YzZlOTliZjYzZWZjN2E5NDBhZGViOQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1999-03-30T00:31:55Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1999-03-30T00:31:55Z"}, "message": "dwarf2out.c (output_line_info): Don't emit redundant info.\n\n\t* dwarf2out.c (output_line_info): Don't emit redundant info.\n\tDo start a new row if the file changes and the line # doesn't.\n\nFrom-SVN: r26061", "tree": {"sha": "702e1788943748e4b1116e49a7ca10249d7cf1a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/702e1788943748e4b1116e49a7ca10249d7cf1a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f22d4044d5faf7e38c6e99bf63efc7a940adeb9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f22d4044d5faf7e38c6e99bf63efc7a940adeb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f22d4044d5faf7e38c6e99bf63efc7a940adeb9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f22d4044d5faf7e38c6e99bf63efc7a940adeb9/comments", "author": null, "committer": null, "parents": [{"sha": "9af3a23b20a2afcbd77a601a3641e372bb72d1d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9af3a23b20a2afcbd77a601a3641e372bb72d1d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9af3a23b20a2afcbd77a601a3641e372bb72d1d1"}], "stats": {"total": 123, "additions": 81, "deletions": 42}, "files": [{"sha": "715422e5128d5d321e5401234250e07448bfa899", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f22d4044d5faf7e38c6e99bf63efc7a940adeb9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f22d4044d5faf7e38c6e99bf63efc7a940adeb9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2f22d4044d5faf7e38c6e99bf63efc7a940adeb9", "patch": "@@ -1,3 +1,8 @@\n+Tue Mar 30 00:26:34 1999  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* dwarf2out.c (output_line_info): Don't emit redundant info.\n+\tDo start a new row if the file changes and the line # doesn't.\n+\n Mon Mar 29 15:48:39 1999  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* invoke.texi (Invoking G++, C++ Dialect Options): Update."}, {"sha": "393dbc54323ba010dc223953717889ea85e419d0", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 76, "deletions": 42, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f22d4044d5faf7e38c6e99bf63efc7a940adeb9/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f22d4044d5faf7e38c6e99bf63efc7a940adeb9/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=2f22d4044d5faf7e38c6e99bf63efc7a940adeb9", "patch": "@@ -4826,14 +4826,15 @@ size_of_line_info ()\n   /* Prolog.  */\n   size += size_of_line_prolog ();\n \n-  /* Set address register instruction.  */\n-  size += size_of_set_address;\n-\n   current_file = 1;\n   current_line = 1;\n   for (lt_index = 1; lt_index < line_info_table_in_use; ++lt_index)\n     {\n-      register dw_line_info_ref line_info;\n+      register dw_line_info_ref line_info = &line_info_table[lt_index];\n+\n+      if (line_info->dw_line_num == current_line\n+\t  && line_info->dw_file_num == current_file)\n+\tcontinue;\n \n       /* Advance pc instruction.  */\n       /* ??? See the DW_LNS_advance_pc comment in output_line_info.  */\n@@ -4842,7 +4843,6 @@ size_of_line_info ()\n       else\n \tsize += size_of_set_address;\n \n-      line_info = &line_info_table[lt_index];\n       if (line_info->dw_file_num != current_file)\n \t{\n \t  /* Set file number instruction.  */\n@@ -4886,6 +4886,12 @@ size_of_line_info ()\n     {\n       register dw_separate_line_info_ref line_info\n \t= &separate_line_info_table[lt_index];\n+\n+      if (line_info->dw_line_num == current_line\n+\t  && line_info->dw_file_num == current_file\n+\t  && line_info->function == function)\n+\tgoto cont;\n+\n       if (function != line_info->function)\n \t{\n \t  function = line_info->function;\n@@ -4928,6 +4934,7 @@ size_of_line_info ()\n \t    }\n \t}\n \n+    cont:\n       ++lt_index;\n \n       /* If we're done with a function, end its sequence.  */\n@@ -5834,18 +5841,9 @@ output_line_info ()\n   ASM_OUTPUT_DWARF_DATA1 (asm_out_file, 0);\n   fputc ('\\n', asm_out_file);\n \n-  /* Set the address register to the first location in the text section */\n-  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, 0);\n-  if (flag_debug_asm)\n-    fprintf (asm_out_file, \"\\t%s DW_LNE_set_address\", ASM_COMMENT_START);\n-\n-  fputc ('\\n', asm_out_file);\n-  output_uleb128 (1 + PTR_SIZE);\n-  fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNE_set_address);\n-  fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_DWARF_ADDR (asm_out_file, text_section_label);\n-  fputc ('\\n', asm_out_file);\n+  /* We used to set the address register to the first location in the text\n+     section here, but that didn't accomplish anything since we already\n+     have a line note for the opening brace of the first function.  */\n \n   /* Generate the line number to PC correspondence table, encoded as\n      a series of state machine operations.  */\n@@ -5854,7 +5852,14 @@ output_line_info ()\n   strcpy (prev_line_label, text_section_label);\n   for (lt_index = 1; lt_index < line_info_table_in_use; ++lt_index)\n     {\n-      register dw_line_info_ref line_info;\n+      register dw_line_info_ref line_info = &line_info_table[lt_index];\n+\n+      /* Don't emit anything for redundant notes.  Just updating the\n+         address doesn't accomplish anything, because we already assume\n+         that anything after the last address is this line.  */\n+      if (line_info->dw_line_num == current_line\n+\t  && line_info->dw_file_num == current_file)\n+\tcontinue;\n \n       /* Emit debug info for the address of the current line, choosing\n \t the encoding that uses the least amount of space.  */\n@@ -5898,7 +5903,6 @@ output_line_info ()\n \n       /* Emit debug info for the source file of the current line, if\n \t different from the previous line.  */\n-      line_info = &line_info_table[lt_index];\n       if (line_info->dw_file_num != current_file)\n \t{\n \t  current_file = line_info->dw_file_num;\n@@ -5916,35 +5920,48 @@ output_line_info ()\n \n       /* Emit debug info for the current line number, choosing the encoding\n \t that uses the least amount of space.  */\n-      line_offset = line_info->dw_line_num - current_line;\n-      line_delta = line_offset - DWARF_LINE_BASE;\n-      current_line = line_info->dw_line_num;\n-      if (line_delta >= 0 && line_delta < (DWARF_LINE_RANGE - 1))\n+      if (line_info->dw_line_num != current_line)\n \t{\n-\t  /* This can handle deltas from -10 to 234, using the current\n-\t     definitions of DWARF_LINE_BASE and DWARF_LINE_RANGE.  This\n-\t     takes 1 byte.  */\n-\t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file,\n-\t\t\t\t  DWARF_LINE_OPCODE_BASE + line_delta);\n-\t  if (flag_debug_asm)\n-\t      fprintf (asm_out_file,\n-\t\t       \"\\t%s line %ld\", ASM_COMMENT_START, current_line);\n+\t  line_offset = line_info->dw_line_num - current_line;\n+\t  line_delta = line_offset - DWARF_LINE_BASE;\n+\t  current_line = line_info->dw_line_num;\n+\t  if (line_delta >= 0 && line_delta < (DWARF_LINE_RANGE - 1))\n+\t    {\n+\t      /* This can handle deltas from -10 to 234, using the current\n+\t\t definitions of DWARF_LINE_BASE and DWARF_LINE_RANGE.  This\n+\t\t takes 1 byte.  */\n+\t      ASM_OUTPUT_DWARF_DATA1 (asm_out_file,\n+\t\t\t\t      DWARF_LINE_OPCODE_BASE + line_delta);\n+\t      if (flag_debug_asm)\n+\t\tfprintf (asm_out_file,\n+\t\t\t \"\\t%s line %ld\", ASM_COMMENT_START, current_line);\n \n-\t  fputc ('\\n', asm_out_file);\n+\t      fputc ('\\n', asm_out_file);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* This can handle any delta.  This takes at least 4 bytes,\n+\t\t depending on the value being encoded.  */\n+\t      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNS_advance_line);\n+\t      if (flag_debug_asm)\n+\t\tfprintf (asm_out_file, \"\\t%s advance to line %ld\",\n+\t\t\t ASM_COMMENT_START, current_line);\n+\n+\t      fputc ('\\n', asm_out_file);\n+\t      output_sleb128 (line_offset);\n+\t      fputc ('\\n', asm_out_file);\n+\t      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNS_copy);\n+\t      if (flag_debug_asm)\n+\t\tfprintf (asm_out_file, \"\\t%s DW_LNS_copy\", ASM_COMMENT_START);\n+\t      fputc ('\\n', asm_out_file);\n+\t    }\n \t}\n       else\n \t{\n-\t  /* This can handle any delta.  This takes at least 4 bytes, depending\n-\t     on the value being encoded.  */\n-\t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNS_advance_line);\n-\t  if (flag_debug_asm)\n-\t    fprintf (asm_out_file, \"\\t%s advance to line %ld\",\n-\t\t     ASM_COMMENT_START, current_line);\n-\n-\t  fputc ('\\n', asm_out_file);\n-\t  output_sleb128 (line_offset);\n-\t  fputc ('\\n', asm_out_file);\n+\t  /* We still need to start a new row, so output a copy insn.  */\n \t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNS_copy);\n+\t  if (flag_debug_asm)\n+\t    fprintf (asm_out_file, \"\\t%s DW_LNS_copy\", ASM_COMMENT_START);\n \t  fputc ('\\n', asm_out_file);\n \t}\n     }\n@@ -5994,6 +6011,12 @@ output_line_info ()\n       register dw_separate_line_info_ref line_info\n \t= &separate_line_info_table[lt_index];\n \n+      /* Don't emit anything for redundant notes.  */\n+      if (line_info->dw_line_num == current_line\n+\t  && line_info->dw_file_num == current_file\n+\t  && line_info->function == function)\n+\tgoto cont;\n+\n       /* Emit debug info for the address of the current line.  If this is\n \t a new function, or the first line of a function, then we need\n \t to handle it differently.  */\n@@ -6094,10 +6117,21 @@ output_line_info ()\n \t      output_sleb128 (line_offset);\n \t      fputc ('\\n', asm_out_file);\n \t      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNS_copy);\n+\t      if (flag_debug_asm)\n+\t\tfprintf (asm_out_file, \"\\t%s DW_LNS_copy\", ASM_COMMENT_START);\n \t      fputc ('\\n', asm_out_file);\n \t    }\n \t}\n+      else\n+\t{\n+\t  /* We still need to start a new row, so output a copy insn.  */\n+\t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNS_copy);\n+\t  if (flag_debug_asm)\n+\t    fprintf (asm_out_file, \"\\t%s DW_LNS_copy\", ASM_COMMENT_START);\n+\t  fputc ('\\n', asm_out_file);\n+\t}\n \n+    cont:\n       ++lt_index;\n \n       /* If we're done with a function, end its sequence.  */"}]}