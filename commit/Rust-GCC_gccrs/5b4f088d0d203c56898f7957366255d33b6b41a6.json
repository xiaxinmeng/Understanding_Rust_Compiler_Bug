{"sha": "5b4f088d0d203c56898f7957366255d33b6b41a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWI0ZjA4OGQwZDIwM2M1Njg5OGY3OTU3MzY2MjU1ZDMzYjZiNDFhNg==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2017-01-03T23:14:44Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2017-01-03T23:14:44Z"}, "message": "PR tree-optimization/78696 - [7 Regression] -fprintf-return-value misoptimizes %.Ng where N is greater than 10\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/78696\n\t* gimple-ssa-sprintf.c (format_floating): Correct handling of\n\tprecision.  Use MPFR for %f for greater fidelity.  Correct handling\n\tof %g.\n\t(pass_sprintf_length::compute_format_length): Set width and precision\n\tspecified by asrerisk to void_node for vararg functions.\n\t(try_substitute_return_value): Adjust dump output.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/78696\n\t* gcc.dg/tree-ssa/builtin-sprintf-5.c: Remove incorrect test cases.\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-7.c: Correct off-by-1 errors.\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-9.c: New test.\n\t* gcc.dg/tree-ssa/builtin-sprintf.c: Add test cases.\n\nFrom-SVN: r244037", "tree": {"sha": "5331a51b6c1ca01b2f03916a9d7018b572c715ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5331a51b6c1ca01b2f03916a9d7018b572c715ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b4f088d0d203c56898f7957366255d33b6b41a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b4f088d0d203c56898f7957366255d33b6b41a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b4f088d0d203c56898f7957366255d33b6b41a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b4f088d0d203c56898f7957366255d33b6b41a6/comments", "author": null, "committer": null, "parents": [{"sha": "0f2a6e84c6e4edd122228be318a014dd88d1c4f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f2a6e84c6e4edd122228be318a014dd88d1c4f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f2a6e84c6e4edd122228be318a014dd88d1c4f2"}], "stats": {"total": 741, "additions": 617, "deletions": 124}, "files": [{"sha": "882856412e2ee2ef1e70f031707b0479d6294b19", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b4f088d0d203c56898f7957366255d33b6b41a6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b4f088d0d203c56898f7957366255d33b6b41a6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5b4f088d0d203c56898f7957366255d33b6b41a6", "patch": "@@ -1,3 +1,13 @@\n+2017-01-03  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/78696\n+\t* gimple-ssa-sprintf.c (format_floating): Correct handling of\n+\tprecision.  Use MPFR for %f for greater fidelity.  Correct handling\n+\tof %g.\n+\t(pass_sprintf_length::compute_format_length): Set width and precision\n+\tspecified by asrerisk to void_node for vararg functions.\n+\t(try_substitute_return_value): Adjust dump output.\n+\n 2017-01-03  David Edelsohn  <dje.gcc@gmail.com>\n \n \t* doc/invoke.texi (RS6000 options): LRA is enabled by default."}, {"sha": "d468cd7f369d93a8061bbccd330f4e37a5ad928b", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 138, "deletions": 110, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b4f088d0d203c56898f7957366255d33b6b41a6/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b4f088d0d203c56898f7957366255d33b6b41a6/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=5b4f088d0d203c56898f7957366255d33b6b41a6", "patch": "@@ -483,9 +483,11 @@ struct conversion_spec\n   /* Numeric precision as in \"%.32s\".  */\n   int precision;\n \n-  /* Width specified via the '*' character.  */\n+  /* Width specified via the '*' character.  Need not be INTEGER_CST.\n+     For vararg functions set to void_node.  */\n   tree star_width;\n-  /* Precision specified via the asterisk.  */\n+  /* Precision specified via the asterisk.  Need not be INTEGER_CST.\n+     For vararg functions set to void_node.  */\n   tree star_precision;\n \n   /* Length modifier.  */\n@@ -1246,15 +1248,26 @@ get_mpfr_format_length (mpfr_ptr x, const char *flags, HOST_WIDE_INT prec,\n   fmtstr[len + 5] = spec;\n   fmtstr[len + 6] = '\\0';\n \n-  /* Avoid passing negative precisions with larger magnitude to MPFR\n-     to avoid exposing its bugs.  (A negative precision is supposed\n-     to be ignored.)  */\n-  if (prec < 0)\n-    prec = -1;\n+  spec = TOUPPER (spec);\n+  if (spec == 'E' || spec == 'F')\n+    {\n+      /* For %e, specify the precision explicitly since mpfr_sprintf\n+\t does its own thing just to be different (see MPFR bug 21088).  */\n+      if (prec < 0)\n+\tprec = 6;\n+    }\n+  else\n+    {\n+      /* Avoid passing negative precisions with larger magnitude to MPFR\n+\t to avoid exposing its bugs.  (A negative precision is supposed\n+\t to be ignored.)  */\n+      if (prec < 0)\n+\tprec = -1;\n+    }\n \n   HOST_WIDE_INT p = prec;\n \n-  if (TOUPPER (spec) == 'G')\n+  if (spec == 'G')\n     {\n       /* For G/g, precision gives the maximum number of significant\n \t digits which is bounded by LDBL_MAX_10_EXP, or, for a 128\n@@ -1287,7 +1300,8 @@ get_mpfr_format_length (mpfr_ptr x, const char *flags, HOST_WIDE_INT prec,\n }\n \n /* Return the number of bytes to format using the format specifier\n-   SPEC the largest value in the real floating TYPE.  */\n+   SPEC and the precision PREC the largest value in the real floating\n+   TYPE.  */\n \n static unsigned HOST_WIDE_INT\n format_floating_max (tree type, char spec, HOST_WIDE_INT prec)\n@@ -1329,7 +1343,6 @@ format_floating (const conversion_spec &spec, HOST_WIDE_INT width,\n \t\t HOST_WIDE_INT prec)\n {\n   tree type;\n-  bool ldbl = false;\n \n   switch (spec.modifier)\n     {\n@@ -1340,12 +1353,10 @@ format_floating (const conversion_spec &spec, HOST_WIDE_INT width,\n \n     case FMT_LEN_L:\n       type = long_double_type_node;\n-      ldbl = true;\n       break;\n \n     case FMT_LEN_ll:\n       type = long_double_type_node;\n-      ldbl = true;\n       break;\n \n     default:\n@@ -1355,95 +1366,94 @@ format_floating (const conversion_spec &spec, HOST_WIDE_INT width,\n   /* The minimum and maximum number of bytes produced by the directive.  */\n   fmtresult res;\n \n-  /* Log10 of of the maximum number of exponent digits for the type.  */\n-  int logexpdigs = 2;\n+  /* The result is always bounded (though the range may be all of int).  */\n+  res.bounded = true;\n \n-  if (REAL_MODE_FORMAT (TYPE_MODE (type))->b == 2)\n-    {\n-      /* The base in which the exponent is represented should always\n-\t be 2 in GCC.  */\n+  /* The minimum output as determined by flags.  It's always at least 1.  */\n+  int flagmin = (1 /* for the first digit */\n+\t\t + (spec.get_flag ('+') | spec.get_flag (' '))\n+\t\t + (prec == 0 && spec.get_flag ('#')));\n \n-      const double log10_2 = .30102999566398119521;\n-\n-      /* Compute T_MAX_EXP for base 2.  */\n-      int expdigs = REAL_MODE_FORMAT (TYPE_MODE (type))->emax * log10_2;\n-      logexpdigs = ilog (expdigs, 10);\n+  if (width == INT_MIN || prec == INT_MIN)\n+    {\n+      /* When either width or precision is specified but unknown\n+\t the upper bound is the maximum.  Otherwise it will be\n+\t computed for each directive below.  */\n+      res.range.max = HOST_WIDE_INT_MAX;\n     }\n+  else\n+    res.range.max = HOST_WIDE_INT_M1U;\n \n   switch (spec.specifier)\n     {\n     case 'A':\n     case 'a':\n       {\n-\t/* The minimum output is \"0x.p+0\".  */\n-\tres.range.min = 6 + (prec > 0 ? prec : 0);\n-\tres.range.max = (width == INT_MIN\n-\t\t\t ? HOST_WIDE_INT_MAX\n-\t\t\t : format_floating_max (type, 'a', prec));\n-\n-\t/* The output of \"%a\" is fully specified only when precision\n-\t   is explicitly specified and width isn't unknown.  */\n-\tres.bounded = INT_MIN != width && -1 < prec;\n+\tres.range.min = flagmin + 5 + (prec > 0 ? prec + 1 : 0);\n+\tif (res.range.max == HOST_WIDE_INT_M1U)\n+\t  {\n+\t    /* Compute the upper bound for -TYPE_MAX.  */\n+\t    res.range.max = format_floating_max (type, 'a', prec);\n+\t  }\n+\n \tbreak;\n       }\n \n     case 'E':\n     case 'e':\n       {\n-\tbool sign = spec.get_flag ('+') || spec.get_flag (' ');\n \t/* The minimum output is \"[-+]1.234567e+00\" regardless\n \t   of the value of the actual argument.  */\n-\tres.range.min = (sign\n-\t\t\t + 1 /* unit */ + (prec < 0 ? 7 : prec ? prec + 1 : 0)\n+\tres.range.min = (flagmin\n+\t\t\t + (prec == INT_MIN\n+\t\t\t    ? 0 : prec < 0 ? 7 : prec ? prec + 1 : 0)\n \t\t\t + 2 /* e+ */ + 2);\n-\t/* Unless width is uknown the maximum output is the minimum plus\n-\t   sign (unless already included), plus the difference between\n-\t   the minimum exponent of 2 and the maximum exponent for the type.  */\n-\tres.range.max = (width == INT_MIN\n-\t\t\t ? HOST_WIDE_INT_M1U\n-\t\t\t : res.range.min + !sign + logexpdigs - 2);\n-\n-\t/* \"%e\" is fully specified and the range of bytes is bounded\n-\t   unless width is unknown.  */\n-\tres.bounded = INT_MIN != width;\n+\n+\tif (res.range.max == HOST_WIDE_INT_M1U)\n+\t  {\n+\t    /* MPFR uses a precision of 16 by default for some reason.\n+\t       Set it to the C default of 6.  */\n+\t    res.range.max = format_floating_max (type, 'e',\n+\t\t\t\t\t\t -1 == prec ? 6 : prec);\n+\t  }\n \tbreak;\n       }\n \n     case 'F':\n     case 'f':\n       {\n-\t/* The minimum output is \"1.234567\" regardless of the value\n-\t   of the actual argument.  */\n-\tres.range.min = 2 + (prec < 0 ? 6 : prec);\n-\n-\t/* Compute the maximum just once.  */\n-\tconst HOST_WIDE_INT f_max[] = {\n-\t  format_floating_max (double_type_node, 'f', prec),\n-\t  format_floating_max (long_double_type_node, 'f', prec)\n-\t};\n-\tres.range.max = width == INT_MIN ? HOST_WIDE_INT_MAX : f_max [ldbl];\n-\n-\t/* \"%f\" is fully specified and the range of bytes is bounded\n-\t   unless width is unknown.  */\n-\tres.bounded = INT_MIN != width;\n+\t/* The lower bound when precision isn't specified is 8 bytes\n+\t   (\"1.23456\" since precision is taken to be 6).  When precision\n+\t   is zero, the lower bound is 1 byte (e.g., \"1\").  Otherwise,\n+\t   when precision is greater than zero, then the lower bound\n+\t   is 2 plus precision (plus flags).  */\n+\tres.range.min = (flagmin\n+\t\t\t + (prec != INT_MIN)   /* for decimal point */\n+\t\t\t + (prec == INT_MIN\n+\t\t\t    ? 0 : prec < 0 ? 6 : prec ? prec : -1));\n+\n+\tif (res.range.max == HOST_WIDE_INT_M1U)\n+\t  {\n+\t    /* Compute the upper bound for -TYPE_MAX.  */\n+\t    res.range.max = format_floating_max (type, 'f', prec);\n+\t  }\n \tbreak;\n       }\n+\n     case 'G':\n     case 'g':\n       {\n-\t/* The minimum is the same as for '%F'.  */\n-\tres.range.min = 1;\n-\n-\t/* Compute the maximum just once.  */\n-\tconst HOST_WIDE_INT g_max[] = {\n-\t  format_floating_max (double_type_node, 'g', prec),\n-\t  format_floating_max (long_double_type_node, 'g', prec)\n-\t};\n-\tres.range.max = width == INT_MIN ? HOST_WIDE_INT_MAX : g_max [ldbl];\n-\n-\t/* \"%g\" is fully specified and the range of bytes is bounded\n-\t   unless width is unknown.  */\n-\tres.bounded = INT_MIN != width;\n+\t/* The %g output depends on precision and the exponent of\n+\t   the argument.  Since the value of the argument isn't known\n+\t   the lower bound on the range of bytes (not counting flags\n+\t   or width) is 1.  */\n+\tres.range.min = flagmin;\n+\tif (res.range.max == HOST_WIDE_INT_M1U)\n+\t  {\n+\t    /* Compute the upper bound for -TYPE_MAX which should be\n+\t       the lesser of %e and %f.  */\n+\t    res.range.max = format_floating_max (type, 'g', prec);\n+\t  }\n \tbreak;\n       }\n \n@@ -1453,6 +1463,7 @@ format_floating (const conversion_spec &spec, HOST_WIDE_INT width,\n \n   if (width > 0)\n     {\n+      /* If width has been specified use it to adjust the range.  */\n       if (res.range.min < (unsigned)width)\n \tres.range.min = width;\n       if (res.range.max < (unsigned)width)\n@@ -1469,9 +1480,9 @@ format_floating (const conversion_spec &spec, HOST_WIDE_INT width,\n static fmtresult\n format_floating (const conversion_spec &spec, tree arg)\n {\n-  /* Set WIDTH to -1 when it's not specified, to INT_MIN when it is\n-     specified by the asterisk to an unknown value, and otherwise to\n-     a non-negative value corresponding to the specified width.  */\n+  /* Set WIDTH to -1 when it's not specified, to HOST_WIDE_INT_MIN when\n+     it is specified by the asterisk to an unknown value, and otherwise\n+     to a non-negative value corresponding to the specified width.  */\n   HOST_WIDE_INT width = -1;\n   HOST_WIDE_INT prec = -1;\n \n@@ -1498,13 +1509,13 @@ format_floating (const conversion_spec &spec, tree arg)\n   else if (spec.star_precision)\n     {\n       if (TREE_CODE (spec.star_precision) == INTEGER_CST)\n-\tprec = tree_to_shwi (spec.star_precision);\n-      else\n \t{\n-\t  /* FIXME: Handle non-constant precision.  */\n-\t  res.range.min = res.range.max = HOST_WIDE_INT_M1U;\n-\t  return res;\n+\t  prec = tree_to_shwi (spec.star_precision);\n+\t  if (prec < 0)\n+\t    prec = -1;\n \t}\n+      else\n+\tprec = INT_MIN;\n     }\n   else if (res.constant && TOUPPER (spec.specifier) != 'A')\n     {\n@@ -1515,11 +1526,6 @@ format_floating (const conversion_spec &spec, tree arg)\n \n   if (res.constant)\n     {\n-      /* Set up an array to easily iterate over.  */\n-      unsigned HOST_WIDE_INT* const minmax[] = {\n-\t&res.range.min, &res.range.max\n-      };\n-\n       /* Get the real type format desription for the target.  */\n       const REAL_VALUE_TYPE *rvp = TREE_REAL_CST_PTR (arg);\n       const real_format *rfmt = REAL_MODE_FORMAT (TYPE_MODE (TREE_TYPE (arg)));\n@@ -1541,26 +1547,42 @@ format_floating (const conversion_spec &spec, tree arg)\n \n       *pfmt = '\\0';\n \n-      for (int i = 0; i != sizeof minmax / sizeof *minmax; ++i)\n+      {\n+\t/* Set up an array to easily iterate over below.  */\n+\tunsigned HOST_WIDE_INT* const minmax[] = {\n+\t  &res.range.min, &res.range.max\n+\t};\n+\t\n+\tfor (int i = 0; i != sizeof minmax / sizeof *minmax; ++i)\n+\t  {\n+\t    /* Use the MPFR rounding specifier to round down in the first\n+\t       iteration and then up.  In most but not all cases this will\n+\t       result in the same number of bytes.  */\n+\t    char rndspec = \"DU\"[i];\n+\n+\t    /* Format it and store the result in the corresponding member\n+\t       of the result struct.  */\n+\t    unsigned HOST_WIDE_INT len\n+\t      = get_mpfr_format_length (mpfrval, fmtstr, prec,\n+\t\t\t\t\tspec.specifier, rndspec);\n+\t    if (0 < width && len < (unsigned)width)\n+\t      len = width;\n+\n+\t    *minmax[i] = len;\n+\t}\n+      }\n+\n+      /* Make sure the minimum is less than the maximum (MPFR rounding\n+\t in the call to mpfr_snprintf can result in the reverse.  */\n+      if (res.range.max < res.range.min)\n \t{\n-\t  /* Use the MPFR rounding specifier to round down in the first\n-\t     iteration and then up.  In most but not all cases this will\n-\t     result in the same number of bytes.  */\n-\t  char rndspec = \"DU\"[i];\n-\n-\t  /* Format it and store the result in the corresponding member\n-\t     of the result struct.  */\n-\t  unsigned HOST_WIDE_INT len\n-\t    = get_mpfr_format_length (mpfrval, fmtstr, prec,\n-\t\t\t\t      spec.specifier, rndspec);\n-\t  if (0 < width && len < (unsigned)width)\n-\t    len = width;\n-\n-\t  *minmax[i] = len;\n+\t  unsigned HOST_WIDE_INT tmp = res.range.min;\n+\t  res.range.min = res.range.max;\n+\t  res.range.max = tmp;\n \t}\n \n       /* The range of output is known even if the result isn't bounded.  */\n-      if (width == INT_MIN)\n+      if (width == HOST_WIDE_INT_MIN)\n \t{\n \t  res.knownrange = false;\n \t  res.range.max = HOST_WIDE_INT_MAX;\n@@ -2420,10 +2442,10 @@ pass_sprintf_length::compute_format_length (call_info &info,\n \t{\n \t  /* Similarly to the block above, this could be either a POSIX\n \t     positional argument or a width, depending on what follows.  */\n-\t  if (gimple_call_num_args (info.callstmt) <= argno)\n-\t    return false;\n-\n-\t  spec.star_width = gimple_call_arg (info.callstmt, argno++);\n+\t  if (argno < gimple_call_num_args (info.callstmt))\n+\t    spec.star_width = gimple_call_arg (info.callstmt, argno++);\n+\t  else\n+\t    spec.star_width = void_node;\n \t  ++pf;\n \t}\n \n@@ -2499,7 +2521,10 @@ pass_sprintf_length::compute_format_length (call_info &info,\n \t    }\n \t  else if ('*' == *pf)\n \t    {\n-\t      spec.star_width = gimple_call_arg (info.callstmt, argno++);\n+\t      if (argno < gimple_call_num_args (info.callstmt))\n+\t\tspec.star_width = gimple_call_arg (info.callstmt, argno++);\n+\t      else\n+\t\tspec.star_width = void_node;\n \t      ++pf;\n \t    }\n \t  else if ('\\'' == *pf)\n@@ -2527,7 +2552,10 @@ pass_sprintf_length::compute_format_length (call_info &info,\n \t    }\n \t  else if ('*' == *pf)\n \t    {\n-\t      spec.star_precision = gimple_call_arg (info.callstmt, argno++);\n+\t      if (argno < gimple_call_num_args (info.callstmt))\n+\t\tspec.star_precision = gimple_call_arg (info.callstmt, argno++);\n+\t      else\n+\t\tspec.star_precision = void_node;\n \t      ++pf;\n \t    }\n \t  else\n@@ -2795,11 +2823,11 @@ try_substitute_return_value (gimple_stmt_iterator *gsi,\n \t    fprintf (dump_file,\n \t\t     \" %s-bounds return value in range [%lu, %lu]%s.\\n\",\n \t\t     inbounds,\n-\t\t     (unsigned long)res.number_chars_min,\n-\t\t     (unsigned long)res.number_chars_max, ign);\n+\t\t     (unsigned long)res.number_chars_min - 1,\n+\t\t     (unsigned long)res.number_chars_max - 1, ign);\n \t  else\n \t    fprintf (dump_file, \" %s-bounds return value %lu%s.\\n\",\n-\t\t     inbounds, (unsigned long)res.number_chars, ign);\n+\t\t     inbounds, (unsigned long)res.number_chars - 1, ign);\n \t}\n     }\n }"}, {"sha": "c12b94a85f95dc27c6b89227e7283d99d8c591f6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b4f088d0d203c56898f7957366255d33b6b41a6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b4f088d0d203c56898f7957366255d33b6b41a6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5b4f088d0d203c56898f7957366255d33b6b41a6", "patch": "@@ -1,3 +1,43 @@\n+2017-01-03  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/78696\n+\t* gcc.dg/tree-ssa/builtin-sprintf-5.c: Remove incorrect test cases.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-7.c: Correct off-by-1 errors.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-9.c: New test.\n+\t* gcc.dg/tree-ssa/builtin-sprintf.c: Add test cases.\n+\n+2017-01-03  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* gcc.dg/dg-test-1.c: Add tests of relative line specifications\n+\twith more than one digit.\n+\t* lib/gcc-dg.exp (process-message): Support more than one digit\n+\tin relative line specifications.\n+\n+2017-01-03  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/78965\n+\t* gcc.dg/pr78965.c: New test.\n+\n+\tPR middle-end/78901\n+\t* g++.dg/opt/pr78901.C: New test.\n+\n+2017-01-03  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\tPR fortran/78534\n+\tPR fortran/66310\n+\t* gfortran.dg/dependency_49.f90: Change scan-tree-dump-times\n+\tdue to gfc_trans_string_copy change to avoid -Wstringop-overflow.\n+\t* gfortran.dg/repeat_4.f90: Use integers of kind C_SIZE_T.\n+\t* gfortran.dg/repeat_7.f90: New test for PR 66310.\n+\t* gfortran.dg/scan_2.f90: Handle potential cast in assignment.\n+\t* gfortran.dg/string_1.f90: Limit to ilp32 targets.\n+\t* gfortran.dg/string_1_lp64.f90: New test.\n+\t* gfortran.dg/string_3.f90: Limit to ilp32 targets.\n+\t* gfortran.dg/string_3_lp64.f90: New test.\n+\t* gfortran.dg/transfer_intrinsic_1.f90: Change\n+\tscan-tree-dump-times due to gfc_trans_string_copy change to\n+\tavoid -Wstringop-overflow.\n+\n 2017-01-02  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/78967"}, {"sha": "c915a351f53c53cdcc15289fea5726ce7de92ddf", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-5.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b4f088d0d203c56898f7957366255d33b6b41a6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b4f088d0d203c56898f7957366255d33b6b41a6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-5.c?ref=5b4f088d0d203c56898f7957366255d33b6b41a6", "patch": "@@ -21,6 +21,7 @@\n       FAIL (__LINE__)(value);\t\t\t\\\n   } while (0)\n \n+/* Verify that EXPECT == snprintf(0, 0, ...).  */\n #define EQL(expect, ...)\t\t\t\t\\\n   do {\t\t\t\t\t\t\t\\\n     int n = __builtin_snprintf (0, 0, __VA_ARGS__);\t\\\n@@ -140,6 +141,7 @@ void test_arg_multiarg (int i, double d)\n   EQL (16, \"%*i %s\", 12, i, \"abc\");\n }\n \n+/* Verify that EXPECT == vsnprintf(0, 0, ...).  */\n #define EQLv(expect, fmt, va)\t\t\t\t\\\n   do {\t\t\t\t\t\t\t\\\n     int n = __builtin_vsnprintf (0, 0, fmt, va);\t\\\n@@ -149,9 +151,7 @@ void test_arg_multiarg (int i, double d)\n void test_va_int (__builtin_va_list va)\n {\n   EQLv ( 2, \"%02hhx\", va);\n-  EQLv ( 2, \"%02.*hhx\", va);\n   EQLv ( 4, \"%04hx\", va);\n-  EQLv ( 4, \"%04.*hx\", va);\n }\n \n void test_va_multiarg (__builtin_va_list va)"}, {"sha": "778725500bd3f1be368ec1a753ef3a5883c00db7", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-7.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b4f088d0d203c56898f7957366255d33b6b41a6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b4f088d0d203c56898f7957366255d33b6b41a6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-7.c?ref=5b4f088d0d203c56898f7957366255d33b6b41a6", "patch": "@@ -63,19 +63,22 @@ void test_floating_a_var (double x)\n \n   T (0, \"%.*a\", INT_MIN, x);     /* { dg-warning \"writing between 6 and 24 bytes\" } */\n \n-  T (0, \"%.*a\", INT_MAX, x);     /* { dg-warning \"writing between 2147483653 and 2147483658 bytes\" } */\n+  /* Expected output is \"0x0.\" followed by INT_MAX digits followed by\n+     \"p+\" followed by 1 to four digits, with a byte count in the range\n+     [3 + INT_MAX + 2 + 1, 3 + INT_MAX + 2 + 4].  */\n+  T (0, \"%.*a\", INT_MAX, x);     /* { dg-warning \"writing between 2147483654 and 2147483658 bytes\" } */\n \n   T (0, \"%*.*a\", INT_MIN, INT_MIN, x);   /* { dg-warning \"writing 2147483648 bytes\" } */\n \n-  T (0, \"%*.*a\", INT_MAX, INT_MAX, x);   /* { dg-warning \"writing between 2147483653 and 2147483658 bytes\" } */\n+  T (0, \"%*.*a\", INT_MAX, INT_MAX, x);   /* { dg-warning \"writing between 2147483654 and 2147483658 bytes\" } */\n }\n \n void test_floating_e_cst (void)\n {\n   T (0, \"%*e\",  INT_MIN, 0.);     /* { dg-warning \"writing 2147483648 bytes\" } */\n   T (0, \"%*e\",  INT_MAX, 0.);     /* { dg-warning \"writing 2147483647 bytes\" } */\n \n-  T (0, \"%.*e\", INT_MIN, 0.);     /* { dg-warning \"writing 5 bytes\" } */\n+  T (0, \"%.*e\", INT_MIN, 0.);     /* { dg-warning \"writing 12 bytes\" } */\n \n   T (0, \"%.*e\", INT_MAX, 0.);     /* { dg-warning \"writing 2147483653 bytes\" } */\n \n@@ -103,7 +106,7 @@ void test_floating_f_cst (void)\n   T (0, \"%*f\",  INT_MIN, 0.);     /* { dg-warning \"writing 2147483648 bytes\" } */\n   T (0, \"%*f\",  INT_MAX, 0.);     /* { dg-warning \"writing 2147483647 bytes\" } */\n \n-  T (0, \"%.*f\", INT_MIN, 0.);     /* { dg-warning \"writing 1 byte\" } */\n+  T (0, \"%.*f\", INT_MIN, 0.);     /* { dg-warning \"writing 8 byte\" } */\n \n   T (0, \"%.*f\", INT_MAX, 0.);     /* { dg-warning \"writing 2147483649 bytes\" } */\n "}, {"sha": "c8c6405c7d1c0f81c5e643974e4ff169e5a1fa30", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-9.c", "status": "added", "additions": 276, "deletions": 0, "changes": 276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b4f088d0d203c56898f7957366255d33b6b41a6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b4f088d0d203c56898f7957366255d33b6b41a6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-9.c?ref=5b4f088d0d203c56898f7957366255d33b6b41a6", "patch": "@@ -0,0 +1,276 @@\n+/* 78696 - -fprintf-return-value misoptimizes %.Ng where N is greater than 10\n+   Test to verify the correctness of ranges of output computed for floating\n+   point directives.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wformat -Wformat-length -ftrack-macro-expansion=0\" } */\n+\n+typedef __builtin_va_list va_list;\n+\n+char dst[1];\n+\n+extern void sink (int, void*);\n+\n+/* Macro to test either width or precision specified by the asterisk\n+   (but not both).  */\n+#define T1(fmt, a)    sink (__builtin_sprintf (dst + 1, fmt, a, x), dst)\n+\n+/* Macro to test both width and precision specified by the asterisk.  */\n+#define T2(fmt, w, p) sink (__builtin_sprintf (dst + 1, fmt, w, p, x), dst)\n+\n+/* Macro to test vsprintf with both width and precision specified by\n+   the asterisk.  */\n+#define T(fmt) sink (__builtin_vsprintf (dst + 1, fmt, va), dst)\n+\n+/* Exercise %a.  */\n+void test_a (int w, int p, double x)\n+{\n+  T1 (\"%.*a\", 0);     /* { dg-warning \"between 6 and 10 bytes\" } */\n+  T1 (\"%.*a\", 1);     /* { dg-warning \"between 8 and 12 bytes\" } */\n+  T1 (\"%.*a\", 2);     /* { dg-warning \"between 9 and 13 bytes\" } */\n+  T1 (\"%.*a\", 99);    /* { dg-warning \"between 106 and 110 bytes\" } */\n+  T1 (\"%.*a\", 199);   /* { dg-warning \"between 206 and 210 bytes\" } */\n+  T1 (\"%.*a\", 1099);  /* { dg-warning \"between 1106 and 1110 bytes\" } */\n+\n+  T1 (\"%*.a\", 0);     /* { dg-warning \"between 6 and 10 bytes\" } */\n+  T1 (\"%*.a\", 1);     /* { dg-warning \"between 6 and 10 bytes\" } */\n+  T1 (\"%*.a\", 3);     /* { dg-warning \"between 6 and 10 bytes\" } */\n+  T1 (\"%*.a\", 6);     /* { dg-warning \"between 6 and 10 bytes\" } */\n+  T1 (\"%*.a\", 7);     /* { dg-warning \"between 7 and 10 bytes\" } */\n+\n+  T1 (\"%*.a\", w);     /* { dg-warning \"writing 6 or more bytes\" } */\n+  T1 (\"%*.0a\", w);    /* { dg-warning \"writing 6 or more bytes\" } */\n+  T1 (\"%*.1a\", w);    /* { dg-warning \"writing 8 or more bytes\" } */\n+  T1 (\"%*.2a\", w);    /* { dg-warning \"writing 9 or more bytes\" } */\n+\n+  T1 (\"%.*a\",  p);    /* { dg-warning \"writing 6 or more bytes\" } */\n+  T1 (\"%1.*a\", p);    /* { dg-warning \"writing 6 or more bytes\" } */\n+  T1 (\"%2.*a\", p);    /* { dg-warning \"writing 6 or more bytes\" } */\n+  T1 (\"%3.*a\", p);    /* { dg-warning \"writing 6 or more bytes\" } */\n+\n+  T2 (\"%*.*a\", w, p); /* { dg-warning \"writing 6 or more bytes\" } */\n+  T2 (\"%*.*a\", w, p); /* { dg-warning \"writing 6 or more bytes\" } */\n+  T2 (\"%*.*a\", w, p); /* { dg-warning \"writing 6 or more bytes\" } */\n+}\n+\n+/* Exercise %e.  */\n+void test_e (int w, int p, double x)\n+{\n+  T1 (\"%.*e\", 0);     /* { dg-warning \"between 5 and 7 bytes\" } */\n+  T1 (\"%.*e\", 1);     /* { dg-warning \"between 7 and 9 bytes\" } */\n+  T1 (\"%.*e\", 2);     /* { dg-warning \"between 8 and 10 bytes\" } */\n+  T1 (\"%.*e\", 99);    /* { dg-warning \"between 105 and 107 bytes\" } */\n+  T1 (\"%.*e\", 199);   /* { dg-warning \"between 205 and 207 bytes\" } */\n+  T1 (\"%.*e\", 1099);  /* { dg-warning \"between 1105 and 1107 bytes\" } */\n+\n+  T1 (\"%*.e\", 0);     /* { dg-warning \"between 5 and 7 bytes\" } */\n+  T1 (\"%*.e\", 1);     /* { dg-warning \"between 5 and 7 bytes\" } */\n+  T1 (\"%*.e\", 1);     /* { dg-warning \"between 5 and 7 bytes\" } */\n+  T1 (\"%*.e\", 3);     /* { dg-warning \"between 5 and 7 bytes\" } */\n+  T1 (\"%*.e\", 6);     /* { dg-warning \"between 6 and 7 bytes\" } */\n+  T1 (\"%*.e\", 7);     /* { dg-warning \"writing 7 bytes\" } */\n+\n+  T1 (\"%*.e\", w);     /* { dg-warning \"writing 5 or more bytes\" } */\n+  T1 (\"%*.0e\", w);    /* { dg-warning \"writing 5 or more bytes\" } */\n+  T1 (\"%*.1e\", w);    /* { dg-warning \"writing 7 or more bytes\" } */\n+  T1 (\"%*.2e\", w);    /* { dg-warning \"writing 8 or more bytes\" } */\n+\n+  T1 (\"%.*e\",  p);    /* { dg-warning \"writing 5 or more bytes\" } */\n+  T1 (\"%1.*e\", p);    /* { dg-warning \"writing 5 or more bytes\" } */\n+  T1 (\"%2.*e\", p);    /* { dg-warning \"writing 5 or more bytes\" } */\n+  T1 (\"%3.*e\", p);    /* { dg-warning \"writing 5 or more bytes\" } */\n+\n+  T2 (\"%*.*e\", w, p); /* { dg-warning \"writing 5 or more bytes\" } */\n+  T2 (\"%*.*e\", w, p); /* { dg-warning \"writing 5 or more bytes\" } */\n+  T2 (\"%*.*e\", w, p); /* { dg-warning \"writing 5 or more bytes\" } */\n+}\n+\n+/* Exercise %f.  */\n+void test_f (int w, int p, double x)\n+{\n+  T1 (\"%.*f\", 0);           /* { dg-warning \"between 1 and 310 bytes\" } */\n+  T1 (\"%.*f\", 1);           /* { dg-warning \"between 3 and 312 bytes\" } */\n+  T1 (\"%.*f\", 2);           /* { dg-warning \"between 4 and 313 bytes\" } */\n+  T1 (\"%.*f\", 99);          /* { dg-warning \"between 101 and 410 bytes\" } */\n+  T1 (\"%.*f\", 199);         /* { dg-warning \"between 201 and 510 bytes\" } */\n+  T1 (\"%.*f\", 1099);        /* { dg-warning \"between 1101 and 1410 bytes\" } */\n+\n+  T2 (\"%*.*f\", 0, 0);       /* { dg-warning \"between 1 and 310 bytes\" } */\n+  T2 (\"%*.*f\", 1, 0);       /* { dg-warning \"between 1 and 310 bytes\" } */\n+  T2 (\"%*.*f\", 2, 0);       /* { dg-warning \"between 2 and 310 bytes\" } */\n+  T2 (\"%*.*f\", 3, 0);       /* { dg-warning \"between 3 and 310 bytes\" } */\n+  T2 (\"%*.*f\", 310, 0);     /* { dg-warning \"writing 310 bytes\" } */\n+  T2 (\"%*.*f\", 311, 0);     /* { dg-warning \"writing 311 bytes\" } */\n+  T2 (\"%*.*f\", 312, 312);   /* { dg-warning \"between 314 and 623 bytes\" } */\n+  T2 (\"%*.*f\", 312, 313);   /* { dg-warning \"between 315 and 624 bytes\" } */\n+\n+  T1 (\"%*.f\", w);           /* { dg-warning \"writing 1 or more bytes\" } */\n+  T1 (\"%*.0f\", w);          /* { dg-warning \"writing 1 or more bytes\" } */\n+  T1 (\"%*.1f\", w);          /* { dg-warning \"writing 3 or more bytes\" } */\n+  T1 (\"%*.2f\", w);          /* { dg-warning \"writing 4 or more bytes\" } */\n+\n+  T1 (\"%.*f\",  p);          /* { dg-warning \"writing 1 or more bytes\" } */\n+  T1 (\"%1.*f\", p);          /* { dg-warning \"writing 1 or more bytes\" } */\n+  T1 (\"%2.*f\", p);          /* { dg-warning \"writing 2 or more bytes\" } */\n+  T1 (\"%3.*f\", p);          /* { dg-warning \"writing 3 or more bytes\" } */\n+\n+  T2 (\"%*.*f\", w, p);       /* { dg-warning \"writing 1 or more bytes\" } */\n+  T2 (\"%*.*f\", w, p);       /* { dg-warning \"writing 1 or more bytes\" } */\n+  T2 (\"%*.*f\", w, p);       /* { dg-warning \"writing 1 or more bytes\" } */\n+}\n+\n+/* Exercise %g.  The expected output is the lesser of %e and %f.  */\n+void test_g (double x)\n+{\n+  T1 (\"%.*g\", 0);           /* { dg-warning \"between 1 and 7 bytes\" } */\n+  T1 (\"%.*g\", 1);           /* { dg-warning \"between 1 and 7 bytes\" } */\n+  T1 (\"%.*g\", 2);           /* { dg-warning \"between 1 and 9 bytes\" } */\n+  T1 (\"%.*g\", 99);          /* { dg-warning \"between 1 and 106 bytes\" } */\n+  T1 (\"%.*g\", 199);         /* { dg-warning \"between 1 and 206 bytes\" } */\n+  T1 (\"%.*g\", 1099);        /* { dg-warning \"between 1 and 310 bytes\" } */\n+\n+  T2 (\"%*.*g\", 0, 0);       /* { dg-warning \"between 1 and 7 bytes\" } */\n+  T2 (\"%*.*g\", 1, 0);       /* { dg-warning \"between 1 and 7 bytes\" } */\n+  T2 (\"%*.*g\", 2, 0);       /* { dg-warning \"between 2 and 7 bytes\" } */\n+  T2 (\"%*.*g\", 3, 0);       /* { dg-warning \"between 3 and 7 bytes\" } */\n+  T2 (\"%*.*g\", 7, 0);       /* { dg-warning \"writing 7 bytes\" } */\n+  T2 (\"%*.*g\", 310, 0);     /* { dg-warning \"writing 310 bytes\" } */\n+  T2 (\"%*.*g\", 311, 0);     /* { dg-warning \"writing 311 bytes\" } */\n+  T2 (\"%*.*g\", 312, 312);   /* { dg-warning \"writing 312 bytes\" } */\n+  T2 (\"%*.*g\", 312, 313);   /* { dg-warning \"writing 312 bytes\" } */\n+  T2 (\"%*.*g\", 333, 999);   /* { dg-warning \"writing 333 bytes\" } */\n+}\n+\n+/* Exercise %a.  */\n+void test_a_va (va_list va)\n+{\n+  T (\"%.0a\");       /* { dg-warning \"between 6 and 10 bytes\" } */\n+  T (\"%.1a\");       /* { dg-warning \"between 8 and 12 bytes\" } */\n+  T (\"%.2a\");       /* { dg-warning \"between 9 and 13 bytes\" } */\n+  T (\"%.99a\");      /* { dg-warning \"between 106 and 110 bytes\" } */\n+  T (\"%.199a\");     /* { dg-warning \"between 206 and 210 bytes\" } */\n+  T (\"%.1099a\");    /* { dg-warning \"between 1106 and 1110 bytes\" } */\n+\n+  T (\"%0.a\");       /* { dg-warning \"between 6 and 10 bytes\" } */\n+  T (\"%1.a\");       /* { dg-warning \"between 6 and 10 bytes\" } */\n+  T (\"%3.a\");       /* { dg-warning \"between 6 and 10 bytes\" } */\n+  T (\"%6.a\");       /* { dg-warning \"between 6 and 10 bytes\" } */\n+  T (\"%7.a\");       /* { dg-warning \"between 7 and 10 bytes\" } */\n+\n+  T (\"%*.a\");       /* { dg-warning \"writing 6 or more bytes\" } */\n+  T (\"%*.0a\");      /* { dg-warning \"writing 6 or more bytes\" } */\n+  T (\"%*.1a\");      /* { dg-warning \"writing 8 or more bytes\" } */\n+  T (\"%*.2a\");      /* { dg-warning \"writing 9 or more bytes\" } */\n+\n+  T (\"%.*a\");       /* { dg-warning \"writing 6 or more bytes\" } */\n+  T (\"%1.*a\");      /* { dg-warning \"writing 6 or more bytes\" } */\n+  T (\"%2.*a\");      /* { dg-warning \"writing 6 or more bytes\" } */\n+  T (\"%6.*a\");      /* { dg-warning \"writing 6 or more bytes\" } */\n+  T (\"%9.*a\");      /* { dg-warning \"writing 9 or more bytes\" } */\n+\n+  T (\"%*.*a\");      /* { dg-warning \"writing 6 or more bytes\" } */\n+}\n+\n+/* Exercise %e.  */\n+void test_e_va (va_list va)\n+{\n+  T (\"%e\");         /* { dg-warning \"between 12 and 14 bytes\" } */\n+  T (\"%+e\");        /* { dg-warning \"between 13 and 14 bytes\" } */\n+  T (\"% e\");        /* { dg-warning \"between 13 and 14 bytes\" } */\n+  T (\"%#e\");        /* { dg-warning \"between 12 and 14 bytes\" } */\n+  T (\"%#+e\");       /* { dg-warning \"between 13 and 14 bytes\" } */\n+  T (\"%# e\");       /* { dg-warning \"between 13 and 14 bytes\" } */\n+\n+  T (\"%.e\");        /* { dg-warning \"between 5 and 7 bytes\" } */\n+  T (\"%.0e\");       /* { dg-warning \"between 5 and 7 bytes\" } */\n+  T (\"%.1e\");       /* { dg-warning \"between 7 and 9 bytes\" } */\n+  T (\"%.2e\");       /* { dg-warning \"between 8 and 10 bytes\" } */\n+  T (\"%.99e\");      /* { dg-warning \"between 105 and 107 bytes\" } */\n+  T (\"%.199e\");     /* { dg-warning \"between 205 and 207 bytes\" } */\n+  T (\"%.1099e\");    /* { dg-warning \"between 1105 and 1107 bytes\" } */\n+\n+  T (\"%0.e\");       /* { dg-warning \"between 5 and 7 bytes\" } */\n+  T (\"%1.e\");       /* { dg-warning \"between 5 and 7 bytes\" } */\n+  T (\"%1.e\");       /* { dg-warning \"between 5 and 7 bytes\" } */\n+  T (\"%3.e\");       /* { dg-warning \"between 5 and 7 bytes\" } */\n+  T (\"%6.e\");       /* { dg-warning \"between 6 and 7 bytes\" } */\n+  T (\"%7.e\");       /* { dg-warning \"writing 7 bytes\" } */\n+\n+  T (\"%.*e\");       /* { dg-warning \"writing 5 or more bytes\" } */\n+  T (\"%1.*e\");      /* { dg-warning \"writing 5 or more bytes\" } */\n+  T (\"%6.*e\");      /* { dg-warning \"writing 6 or more bytes\" } */\n+  T (\"%9.*e\");      /* { dg-warning \"writing 9 or more bytes\" } */\n+\n+  T (\"%*.*e\");      /* { dg-warning \"writing 5 or more bytes\" } */\n+}\n+\n+/* Exercise %f.  */\n+void test_f_va (va_list va)\n+{\n+  T (\"%f\");         /* { dg-warning \"between 8 and 317 bytes\" } */\n+  T (\"%+f\");        /* { dg-warning \"between 9 and 317 bytes\" } */\n+  T (\"% f\");        /* { dg-warning \"between 9 and 317 bytes\" } */\n+  T (\"%#f\");        /* { dg-warning \"between 8 and 317 bytes\" } */\n+  T (\"%+f\");        /* { dg-warning \"between 9 and 317 bytes\" } */\n+  T (\"% f\");        /* { dg-warning \"between 9 and 317 bytes\" } */\n+  T (\"%#+f\");       /* { dg-warning \"between 9 and 317 bytes\" } */\n+  T (\"%# f\");       /* { dg-warning \"between 9 and 317 bytes\" } */\n+\n+  T (\"%.f\");        /* { dg-warning \"between 1 and 310 bytes\" } */\n+  T (\"%.0f\");       /* { dg-warning \"between 1 and 310 bytes\" } */\n+  T (\"%.1f\");       /* { dg-warning \"between 3 and 312 bytes\" } */\n+  T (\"%.2f\");       /* { dg-warning \"between 4 and 313 bytes\" } */\n+  T (\"%.99f\");      /* { dg-warning \"between 101 and 410 bytes\" } */\n+  T (\"%.199f\");     /* { dg-warning \"between 201 and 510 bytes\" } */\n+  T (\"%.1099f\");    /* { dg-warning \"between 1101 and 1410 bytes\" } */\n+\n+  T (\"%0.0f\");      /* { dg-warning \"between 1 and 310 bytes\" } */\n+  T (\"%1.0f\");      /* { dg-warning \"between 1 and 310 bytes\" } */\n+  T (\"%2.0f\");      /* { dg-warning \"between 2 and 310 bytes\" } */\n+  T (\"%3.0f\");      /* { dg-warning \"between 3 and 310 bytes\" } */\n+  T (\"%310.0f\");    /* { dg-warning \"writing 310 bytes\" } */\n+  T (\"%311.0f\");    /* { dg-warning \"writing 311 bytes\" } */\n+  T (\"%312.312f\");  /* { dg-warning \"between 314 and 623 bytes\" } */\n+  T (\"%312.313f\");  /* { dg-warning \"between 315 and 624 bytes\" } */\n+\n+  T (\"%.*f\");       /* { dg-warning \"writing 1 or more bytes\" } */\n+  T (\"%1.*f\");      /* { dg-warning \"writing 1 or more bytes\" } */\n+  T (\"%3.*f\");      /* { dg-warning \"writing 3 or more bytes\" } */\n+\n+  T (\"%*.*f\");      /* { dg-warning \"writing 1 or more bytes\" } */\n+}\n+\n+/* Exercise %g.  The expected output is the lesser of %e and %f.  */\n+void test_g_va (va_list va)\n+{\n+  T (\"%g\");         /* { dg-warning \"between 1 and 13 bytes\" } */\n+  T (\"%+g\");        /* { dg-warning \"between 2 and 13 bytes\" } */\n+  T (\"% g\");        /* { dg-warning \"between 2 and 13 bytes\" } */\n+  T (\"%#g\");        /* { dg-warning \"between 1 and 13 bytes\" } */\n+  T (\"%#+g\");       /* { dg-warning \"between 2 and 13 bytes\" } */\n+  T (\"%# g\");       /* { dg-warning \"between 2 and 13 bytes\" } */\n+\n+  T (\"%.g\");        /* { dg-warning \"between 1 and 7 bytes\" } */\n+  T (\"%.0g\");       /* { dg-warning \"between 1 and 7 bytes\" } */\n+  T (\"%.1g\");       /* { dg-warning \"between 1 and 7 bytes\" } */\n+  T (\"%.2g\");       /* { dg-warning \"between 1 and 9 bytes\" } */\n+  T (\"%.99g\");      /* { dg-warning \"between 1 and 106 bytes\" } */\n+  T (\"%.199g\");     /* { dg-warning \"between 1 and 206 bytes\" } */\n+  T (\"%.1099g\");    /* { dg-warning \"between 1 and 310 bytes\" } */\n+\n+  T (\"%0.0g\");      /* { dg-warning \"between 1 and 7 bytes\" } */\n+  T (\"%1.0g\");      /* { dg-warning \"between 1 and 7 bytes\" } */\n+  T (\"%2.0g\");      /* { dg-warning \"between 2 and 7 bytes\" } */\n+  T (\"%3.0g\");      /* { dg-warning \"between 3 and 7 bytes\" } */\n+  T (\"%7.0g\");      /* { dg-warning \"writing 7 bytes\" } */\n+  T (\"%310.0g\");    /* { dg-warning \"writing 310 bytes\" } */\n+  T (\"%311.0g\");    /* { dg-warning \"writing 311 bytes\" } */\n+  T (\"%312.312g\");  /* { dg-warning \"writing 312 bytes\" } */\n+  T (\"%312.313g\");  /* { dg-warning \"writing 312 bytes\" } */\n+  T (\"%333.999g\");  /* { dg-warning \"writing 333 bytes\" } */\n+\n+  T (\"%.*g\");       /* { dg-warning \"writing 1 or more bytes\" } */\n+  T (\"%1.*g\");      /* { dg-warning \"writing 1 or more bytes\" } */\n+  T (\"%4.*g\");      /* { dg-warning \"writing 4 or more bytes\" } */\n+\n+  T (\"%*.*g\");      /* { dg-warning \"writing 1 or more bytes\" } */\n+}"}, {"sha": "96892c16425b716f6576930a5fdb3b12256c2150", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf.c", "status": "modified", "additions": 144, "deletions": 8, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b4f088d0d203c56898f7957366255d33b6b41a6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b4f088d0d203c56898f7957366255d33b6b41a6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf.c?ref=5b4f088d0d203c56898f7957366255d33b6b41a6", "patch": "@@ -56,9 +56,12 @@ checkv (const char *func, int line, int res, int min, int max,\n \n \t  fail = 1;\n \t}\n-      else\n+      else if (min == max)\n \t__builtin_printf (\"PASS: %s:%i: \\\"%s\\\" result %i: \\\"%s\\\"\\n\",\n \t\t\t  func, line, fmt, n, dst);\n+      else\n+\t__builtin_printf (\"PASS: %s:%i: \\\"%s\\\" result %i in [%i, %i]: \\\"%s\\\"\\n\",\n+\t\t\t  func, line, fmt, n, min, max, dst);\n     }\n \n   if (fail)\n@@ -75,7 +78,7 @@ check (const char *func, int line, int res, int min, int max,\n   __builtin_va_end (va);\n }\n \n-char buffer[256];\n+char buffer[4100];\n char* volatile dst = buffer;\n char* ptr = buffer;\n \n@@ -415,6 +418,8 @@ test_a_double (double d)\n   EQL ( 9, 10, \"%.2a\", 4.0);        /* 0x8.00p-1 */\n   EQL (10, 11, \"%.3a\", 5.0);        /* 0xa.000p-1 */\n \n+  EQL (11, 12, \"%.*a\", 4, 6.0);     /* 0xc.0000p-1 */\n+  EQL (12, 13, \"%.*a\", 5, 7.0);     /* 0xe.00000p-1 */\n \t                            /* d is in [ 0, -DBL_MAX ] */\n   RNG ( 6, 10, 11, \"%.0a\", d);      /* 0x0p+0 ... -0x2p+1023 */\n   RNG ( 6, 12, 13, \"%.1a\", d);      /* 0x0p+0 ... -0x2.0p+1023 */\n@@ -432,7 +437,7 @@ test_a_long_double (void)\n }\n \n static void __attribute__ ((noinline, noclone))\n-test_e_double (void)\n+test_e_double (double d)\n {\n   EQL (12, 13, \"%e\",  1.0e0);\n   EQL (13, 14, \"%e\", -1.0e0);\n@@ -454,10 +459,34 @@ test_e_double (void)\n   EQL (12, 13, \"%e\",  1.0e-1);\n   EQL (12, 13, \"%e\",  1.0e-12);\n   EQL (13, 14, \"%e\",  1.0e-123);\n+\n+  RNG (12, 14, 15, \"%e\", d);\n+  RNG ( 5,  7,  8, \"%.e\", d);\n+  RNG ( 5,  7,  8, \"%.0e\", d);\n+  RNG ( 7,  9, 10, \"%.1e\", d);\n+  RNG ( 8, 10, 11, \"%.2e\", d);\n+  RNG ( 9, 11, 12, \"%.3e\", d);\n+  RNG (10, 12, 13, \"%.4e\", d);\n+  RNG (11, 13, 14, \"%.5e\", d);\n+  RNG (12, 14, 15, \"%.6e\", d);\n+  RNG (13, 15, 16, \"%.7e\", d);\n+\n+  RNG (4006, 4008, 4009, \"%.4000e\", d);\n+\n+  RNG ( 5,  7,  8, \"%.*e\", 0, d);\n+  RNG ( 7,  9, 10, \"%.*e\", 1, d);\n+  RNG ( 8, 10, 11, \"%.*e\", 2, d);\n+  RNG ( 9, 11, 12, \"%.*e\", 3, d);\n+  RNG (10, 12, 13, \"%.*e\", 4, d);\n+  RNG (11, 13, 14, \"%.*e\", 5, d);\n+  RNG (12, 14, 15, \"%.*e\", 6, d);\n+  RNG (13, 15, 16, \"%.*e\", 7, d);\n+\n+  RNG (4006, 4008, 4009, \"%.*e\", 4000, d);\n }\n \n static void __attribute__ ((noinline, noclone))\n-test_e_long_double (void)\n+test_e_long_double (long double d)\n {\n   EQL (12, 13, \"%Le\",  1.0e0L);\n   EQL (13, 14, \"%Le\", -1.0e0L);\n@@ -490,10 +519,32 @@ test_e_long_double (void)\n   EQL ( 8,  9, \"%.1Le\",   1.0e-111L);\n   EQL (19, 20, \"%.12Le\",  1.0e-112L);\n   EQL (20, 21, \"%.13Le\",  1.0e-113L);\n+\n+  /* The following correspond to the double results plus 1 for the upper\n+     bound accounting for the four-digit exponent.  */\n+  RNG (12, 15, 16, \"%Le\", d);    /* 0.000000e+00 ...  -1.189732e+4932 */\n+  RNG ( 5,  8,  9, \"%.Le\", d);\n+  RNG ( 5,  9, 10, \"%.0Le\", d);\n+  RNG ( 7, 10, 11, \"%.1Le\", d);  /* 0.0e+00      ...  -1.2e+4932 */\n+  RNG ( 8, 11, 12, \"%.2Le\", d);  /* 0.00e+00     ...  -1.19e+4932 */\n+  RNG ( 9, 12, 13, \"%.3Le\", d);\n+  RNG (10, 13, 14, \"%.4Le\", d);\n+  RNG (11, 14, 15, \"%.5Le\", d);\n+  RNG (12, 15, 16, \"%.6Le\", d);  /* same as plain \"%Le\" */\n+  RNG (13, 16, 17, \"%.7Le\", d);  /* 0.0000000e+00 ... -1.1897315e+4932 */\n+\n+  RNG ( 5,  9, 10, \"%.*Le\", 0, d);\n+  RNG ( 7, 10, 11, \"%.*Le\", 1, d);\n+  RNG ( 8, 11, 12, \"%.*Le\", 2, d);\n+  RNG ( 9, 12, 13, \"%.*Le\", 3, d);\n+  RNG (10, 13, 14, \"%.*Le\", 4, d);\n+  RNG (11, 14, 15, \"%.*Le\", 5, d);\n+  RNG (12, 15, 16, \"%.*Le\", 6, d);\n+  RNG (13, 16, 17, \"%.*Le\", 7, d);\n }\n \n static void __attribute__ ((noinline, noclone))\n-test_f_double (void)\n+test_f_double (double d)\n {\n   EQL (  8,   9, \"%f\", 0.0e0);\n   EQL (  8,   9, \"%f\", 0.1e0);\n@@ -511,6 +562,8 @@ test_f_double (void)\n   EQL (  8,   9, \"%f\", 1.0e-1);\n   EQL (  8,   9, \"%f\", 1.0e-12);\n   EQL (  8,   9, \"%f\", 1.0e-123);\n+\n+  RNG (  8, 317, 318, \"%f\", d);\n }\n \n static void __attribute__ ((noinline, noclone))\n@@ -534,6 +587,87 @@ test_f_long_double (void)\n   EQL (  8,   9, \"%Lf\", 1.0e-123L);\n }\n \n+static void __attribute__ ((noinline, noclone))\n+test_g_double (double d)\n+{\n+  /* Numbers exactly representable in binary floating point.  */\n+  EQL (  1,   2, \"%g\", 0.0);\n+  EQL (  3,   4, \"%g\", 1.0 / 2);\n+  EQL (  4,   5, \"%g\", 1.0 / 4);\n+  EQL (  5,   6, \"%g\", 1.0 / 8);\n+  EQL (  6,   7, \"%g\", 1.0 / 16);\n+  EQL (  7,   8, \"%g\", 1.0 / 32);\n+  EQL (  8,   9, \"%g\", 1.0 / 64);\n+  EQL (  9,  10, \"%g\", 1.0 / 128);\n+  EQL ( 10,  11, \"%g\", 1.0 / 256);\n+  EQL ( 10,  11, \"%g\", 1.0 / 512);\n+\n+  /* Numbers that are not exactly representable.  */\n+  RNG ( 3,  8,  9, \"%g\", 0.1);\n+  RNG ( 4,  8,  9, \"%g\", 0.12);\n+  RNG ( 5,  8,  9, \"%g\", 0.123);\n+  RNG ( 6,  8,  9, \"%g\", 0.1234);\n+  RNG ( 7,  8,  9, \"%g\", 0.12345);\n+  RNG ( 8,  8,  9, \"%g\", 0.123456);\n+\n+  RNG ( 4,  7,  8, \"%g\", 0.123e+1);\n+  EQL (     8,  9, \"%g\", 0.123e+12);\n+  RNG ( 9, 12, 13, \"%g\", 0.123e+134);\n+\n+  RNG ( 1, 13, 14, \"%g\", d);\n+  RNG ( 1,  7,  8, \"%.g\", d);\n+  RNG ( 1,  7,  8, \"%.0g\", d);\n+  RNG ( 1,  7,  8, \"%.1g\", d);\n+  RNG ( 1,  9, 10, \"%.2g\", d);\n+  RNG ( 1, 10, 11, \"%.3g\", d);\n+  RNG ( 1, 11, 12, \"%.4g\", d);\n+  RNG ( 1, 12, 13, \"%.5g\", d);\n+  RNG ( 1, 13, 14, \"%.6g\", d);\n+  RNG ( 1, 14, 15, \"%.7g\", d);\n+  RNG ( 1, 15, 16, \"%.8g\", d);\n+\n+  RNG ( 1,310,311, \"%.9999g\", d);\n+\n+  RNG ( 1,  7,  8, \"%.*g\", 0, d);\n+  RNG ( 1,  7,  8, \"%.*g\", 1, d);\n+  RNG ( 1,  9, 10, \"%.*g\", 2, d);\n+  RNG ( 1, 10, 11, \"%.*g\", 3, d);\n+  RNG ( 1, 11, 12, \"%.*g\", 4, d);\n+  RNG ( 1, 12, 13, \"%.*g\", 5, d);\n+  RNG ( 1, 13, 14, \"%.*g\", 6, d);\n+  RNG ( 1, 14, 15, \"%.*g\", 7, d);\n+  RNG ( 1, 15, 16, \"%.*g\", 8, d);\n+  RNG ( 1,310,311, \"%.*g\", 9999, d);\n+}\n+\n+static void __attribute__ ((noinline, noclone))\n+test_g_long_double (void)\n+{\n+  /* Numbers exactly representable in binary floating point.  */\n+  EQL (  1,   2, \"%Lg\", 0.0L);\n+  EQL (  3,   4, \"%Lg\", 1.0L / 2);\n+  EQL (  4,   5, \"%Lg\", 1.0L / 4);\n+  EQL (  5,   6, \"%Lg\", 1.0L / 8);\n+  EQL (  6,   7, \"%Lg\", 1.0L / 16);\n+  EQL (  7,   8, \"%Lg\", 1.0L / 32);\n+  EQL (  8,   9, \"%Lg\", 1.0L / 64);\n+  EQL (  9,  10, \"%Lg\", 1.0L / 128);\n+  EQL ( 10,  11, \"%Lg\", 1.0L / 256);\n+  EQL ( 10,  11, \"%Lg\", 1.0L / 512);\n+\n+  /* Numbers that are not exactly representable.  */\n+  RNG ( 3,  8,  9, \"%Lg\", 0.1L);\n+  RNG ( 4,  8,  9, \"%Lg\", 0.12L);\n+  RNG ( 5,  8,  9, \"%Lg\", 0.123L);\n+  RNG ( 6,  8,  9, \"%Lg\", 0.1234L);\n+  RNG ( 7,  8,  9, \"%Lg\", 0.12345L);\n+  RNG ( 8,  8,  9, \"%Lg\", 0.123456L);\n+\n+  RNG ( 4,  7,  8, \"%Lg\", 0.123e+1L);\n+  EQL (     8,  9, \"%Lg\", 0.123e+12L);\n+  RNG ( 9, 12, 13, \"%Lg\", 0.123e+134L);\n+}\n+\n static void __attribute__ ((noinline, noclone))\n test_s (int i)\n {\n@@ -577,12 +711,14 @@ int main (void)\n   test_x ('?', 0xdead, 0xdeadbeef);\n \n   test_a_double (0.0);\n-  test_e_double ();\n-  test_f_double ();\n+  test_e_double (0.0);\n+  test_f_double (0.0);\n+  test_g_double (0.0);\n \n   test_a_long_double ();\n-  test_e_long_double ();\n+  test_e_long_double (0.0);\n   test_f_long_double ();\n+  test_g_long_double ();\n \n   test_s (0);\n "}]}