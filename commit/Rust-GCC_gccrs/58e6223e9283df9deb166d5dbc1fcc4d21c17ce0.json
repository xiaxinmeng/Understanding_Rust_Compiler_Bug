{"sha": "58e6223e9283df9deb166d5dbc1fcc4d21c17ce0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NThlNjIyM2U5MjgzZGY5ZGViMTY2ZDVkYmMxZmNjNGQyMWMxN2NlMA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-07-25T21:46:32Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-07-25T21:46:32Z"}, "message": "re PR target/44707 (operand requires impossible reload)\n\n\tPR target/44707\n\t* config/sparc/sparc-protos.h (sparc_legitimize_reload_address): New.\n\t* config/sparc/sparc.c: Include reload.h.\n\t(legitimize_tls_address): Rename into...\n\t(sparc_legitimize_tls_address): ...this.\n\t(legitimize_pic_address): Rename into...\n\t(sparc_legitimize_pic_address): ...this.\n\t(sparc_expand_move): Adjust to above renaming.\n\t(sparc_tls_referenced_p): Likewise.\n\t(sparc_legitimize_tls_address): Likewise.\n\t(sparc_legitimize_pic_address): Likewise.\n\t(sparc_legitimize_address): Likewise.\n\t(sparc_output_mi_thunk): Likewise.\n\t(sparc_legitimize_reload_address): New global function.  Recognize\n\t(lo_sum (high ...) ...) patterns generated by earlier passes.\n\t* config/sparc/sparc.h (LEGITIMIZE_RELOAD_ADDRESS): Use above function.\n\nFrom-SVN: r162521", "tree": {"sha": "284105be708372bf5543c50132112c18baf16068", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/284105be708372bf5543c50132112c18baf16068"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58e6223e9283df9deb166d5dbc1fcc4d21c17ce0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58e6223e9283df9deb166d5dbc1fcc4d21c17ce0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58e6223e9283df9deb166d5dbc1fcc4d21c17ce0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58e6223e9283df9deb166d5dbc1fcc4d21c17ce0/comments", "author": null, "committer": null, "parents": [{"sha": "bfb7cccf060832bc63e0fdac12674cfb888a6ea2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfb7cccf060832bc63e0fdac12674cfb888a6ea2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfb7cccf060832bc63e0fdac12674cfb888a6ea2"}], "stats": {"total": 150, "additions": 101, "deletions": 49}, "files": [{"sha": "8fc9c977e734da5f7f21f6e8f620dfcf44b832e2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58e6223e9283df9deb166d5dbc1fcc4d21c17ce0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58e6223e9283df9deb166d5dbc1fcc4d21c17ce0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=58e6223e9283df9deb166d5dbc1fcc4d21c17ce0", "patch": "@@ -1,3 +1,22 @@\n+2010-07-25  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR target/44707\n+\t* config/sparc/sparc-protos.h (sparc_legitimize_reload_address): New.\n+\t* config/sparc/sparc.c: Include reload.h.\n+\t(legitimize_tls_address): Rename into...\n+\t(sparc_legitimize_tls_address): ...this.\n+\t(legitimize_pic_address): Rename into...\n+\t(sparc_legitimize_pic_address): ...this.\n+\t(sparc_expand_move): Adjust to above renaming.\n+\t(sparc_tls_referenced_p): Likewise.\n+\t(sparc_legitimize_tls_address): Likewise.\n+\t(sparc_legitimize_pic_address): Likewise.\n+\t(sparc_legitimize_address): Likewise.\n+\t(sparc_output_mi_thunk): Likewise.\n+\t(sparc_legitimize_reload_address): New global function.  Recognize\n+\t(lo_sum (high ...) ...) patterns generated by earlier passes.\n+\t* config/sparc/sparc.h (LEGITIMIZE_RELOAD_ADDRESS): Use above function.\n+\n 2010-07-25  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR target/44484"}, {"sha": "f5efcb988f2e802c4dfec56ae2fd796368daf922", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58e6223e9283df9deb166d5dbc1fcc4d21c17ce0/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58e6223e9283df9deb166d5dbc1fcc4d21c17ce0/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=58e6223e9283df9deb166d5dbc1fcc4d21c17ce0", "patch": "@@ -63,6 +63,8 @@ extern void emit_tfmode_cvt (enum rtx_code, rtx *);\n extern bool legitimate_constant_p (rtx);\n extern bool constant_address_p (rtx);\n extern bool legitimate_pic_operand_p (rtx);\n+extern rtx sparc_legitimize_reload_address (rtx, enum machine_mode, int, int,\n+\t\t\t\t\t    int, int *win);\n extern void sparc_emit_call_insn (rtx, rtx);\n extern void sparc_defer_case_vector (rtx, rtx, int);\n extern bool sparc_expand_move (enum machine_mode, rtx *);"}, {"sha": "48cf00e902a7a438c73fbec283451a0e0c325d9e", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 72, "deletions": 19, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58e6223e9283df9deb166d5dbc1fcc4d21c17ce0/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58e6223e9283df9deb166d5dbc1fcc4d21c17ce0/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=58e6223e9283df9deb166d5dbc1fcc4d21c17ce0", "patch": "@@ -51,6 +51,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfglayout.h\"\n #include \"gimple.h\"\n #include \"langhooks.h\"\n+#include \"reload.h\"\n #include \"params.h\"\n #include \"df.h\"\n #include \"dwarf2out.h\"\n@@ -416,8 +417,8 @@ static void sparc_va_start (tree, rtx);\n static tree sparc_gimplify_va_arg (tree, tree, gimple_seq *, gimple_seq *);\n static bool sparc_vector_mode_supported_p (enum machine_mode);\n static bool sparc_tls_referenced_p (rtx);\n-static rtx legitimize_tls_address (rtx);\n-static rtx legitimize_pic_address (rtx, rtx);\n+static rtx sparc_legitimize_tls_address (rtx);\n+static rtx sparc_legitimize_pic_address (rtx, rtx);\n static rtx sparc_legitimize_address (rtx, rtx, enum machine_mode);\n static bool sparc_mode_dependent_address_p (const_rtx);\n static bool sparc_pass_by_reference (CUMULATIVE_ARGS *,\n@@ -1006,15 +1007,15 @@ sparc_expand_move (enum machine_mode mode, rtx *operands)\n       && CONSTANT_P (operands[1])\n       && sparc_tls_referenced_p (operands [1]))\n     {\n-      operands[1] = legitimize_tls_address (operands[1]);\n+      operands[1] = sparc_legitimize_tls_address (operands[1]);\n       return false;\n     }\n \n   /* Fixup PIC cases.  */\n   if (flag_pic && CONSTANT_P (operands[1]))\n     {\n       if (pic_address_needs_scratch (operands[1]))\n-\toperands[1] = legitimize_pic_address (operands[1], NULL_RTX);\n+\toperands[1] = sparc_legitimize_pic_address (operands[1], NULL_RTX);\n \n       /* VxWorks does not impose a fixed gap between segments; the run-time\n \t gap can be different from the object-file gap.  We therefore can't\n@@ -1041,9 +1042,10 @@ sparc_expand_move (enum machine_mode mode, rtx *operands)\n \n       if (symbolic_operand (operands[1], mode))\n \t{\n-\t  operands[1] = legitimize_pic_address (operands[1],\n-\t\t\t\t\t\treload_in_progress\n-\t\t\t\t\t\t? operands[0] : NULL_RTX);\n+\t  operands[1]\n+\t    = sparc_legitimize_pic_address (operands[1],\n+\t\t\t\t\t    reload_in_progress\n+\t\t\t\t\t    ? operands[0] : NULL_RTX);\n \t  return false;\n \t}\n     }\n@@ -3217,15 +3219,15 @@ sparc_tls_referenced_p (rtx x)\n   if (GET_CODE (x) == SYMBOL_REF && SYMBOL_REF_TLS_MODEL (x))\n     return true;\n \n-  /* That's all we handle in legitimize_tls_address for now.  */\n+  /* That's all we handle in sparc_legitimize_tls_address for now.  */\n   return false;\n }\n \n /* ADDR contains a thread-local SYMBOL_REF.  Generate code to compute\n    this (thread-local) address.  */\n \n static rtx\n-legitimize_tls_address (rtx addr)\n+sparc_legitimize_tls_address (rtx addr)\n {\n   rtx temp1, temp2, temp3, ret, o0, got, insn;\n \n@@ -3354,7 +3356,7 @@ legitimize_tls_address (rtx addr)\n \n       gcc_assert (GET_CODE (XEXP (addr, 0)) == PLUS);\n \n-      base = legitimize_tls_address (XEXP (XEXP (addr, 0), 0));\n+      base = sparc_legitimize_tls_address (XEXP (XEXP (addr, 0), 0));\n       offset = XEXP (XEXP (addr, 0), 1);\n \n       base = force_operand (base, NULL_RTX);\n@@ -3375,7 +3377,7 @@ legitimize_tls_address (rtx addr)\n    necessary.  */\n \n static rtx\n-legitimize_pic_address (rtx orig, rtx reg)\n+sparc_legitimize_pic_address (rtx orig, rtx reg)\n {\n   bool gotdata_op = false;\n \n@@ -3424,10 +3426,12 @@ legitimize_pic_address (rtx orig, rtx reg)\n       if (gotdata_op)\n \t{\n \t  if (TARGET_ARCH64)\n-\t    insn = emit_insn (gen_movdi_pic_gotdata_op (reg, pic_offset_table_rtx,\n+\t    insn = emit_insn (gen_movdi_pic_gotdata_op (reg,\n+\t\t\t\t\t\t\tpic_offset_table_rtx,\n \t\t\t\t\t\t\taddress, orig));\n \t  else\n-\t    insn = emit_insn (gen_movsi_pic_gotdata_op (reg, pic_offset_table_rtx,\n+\t    insn = emit_insn (gen_movsi_pic_gotdata_op (reg,\n+\t\t\t\t\t\t\tpic_offset_table_rtx,\n \t\t\t\t\t\t\taddress, orig));\n \t}\n       else\n@@ -3457,9 +3461,9 @@ legitimize_pic_address (rtx orig, rtx reg)\n \t}\n \n       gcc_assert (GET_CODE (XEXP (orig, 0)) == PLUS);\n-      base = legitimize_pic_address (XEXP (XEXP (orig, 0), 0), reg);\n-      offset = legitimize_pic_address (XEXP (XEXP (orig, 0), 1),\n-\t\t\t \t       base == reg ? NULL_RTX : reg);\n+      base = sparc_legitimize_pic_address (XEXP (XEXP (orig, 0), 0), reg);\n+      offset = sparc_legitimize_pic_address (XEXP (XEXP (orig, 0), 1),\n+\t\t\t \t\t     base == reg ? NULL_RTX : reg);\n \n       if (GET_CODE (offset) == CONST_INT)\n \t{\n@@ -3515,9 +3519,9 @@ sparc_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n     return x;\n \n   if (sparc_tls_referenced_p (x))\n-    x = legitimize_tls_address (x);\n+    x = sparc_legitimize_tls_address (x);\n   else if (flag_pic)\n-    x = legitimize_pic_address (x, NULL_RTX);\n+    x = sparc_legitimize_pic_address (x, NULL_RTX);\n   else if (GET_CODE (x) == PLUS && CONSTANT_ADDRESS_P (XEXP (x, 1)))\n     x = gen_rtx_PLUS (Pmode, XEXP (x, 0),\n \t\t      copy_to_mode_reg (Pmode, XEXP (x, 1)));\n@@ -3532,6 +3536,55 @@ sparc_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n   return x;\n }\n \n+/* SPARC implementation of LEGITIMIZE_RELOAD_ADDRESS.  Returns a value to\n+   replace the input X, or the original X if no replacement is called for.\n+   The output parameter *WIN is 1 if the calling macro should goto WIN,\n+   0 if it should not.\n+\n+   For SPARC, we wish to handle addresses by splitting them into\n+   HIGH+LO_SUM pairs, retaining the LO_SUM in the memory reference.\n+   This cuts the number of extra insns by one.\n+\n+   Do nothing when generating PIC code and the address is a symbolic\n+   operand or requires a scratch register.  */\n+\n+rtx\n+sparc_legitimize_reload_address (rtx x, enum machine_mode mode,\n+\t\t\t\t int opnum, int type,\n+\t\t\t\t int ind_levels ATTRIBUTE_UNUSED, int *win)\n+{\n+  /* Decompose SImode constants into HIGH+LO_SUM.  */\n+  if (CONSTANT_P (x)\n+      && (mode != TFmode || TARGET_ARCH64)\n+      && GET_MODE (x) == SImode\n+      && GET_CODE (x) != LO_SUM\n+      && GET_CODE (x) != HIGH\n+      && sparc_cmodel <= CM_MEDLOW\n+      && !(flag_pic\n+\t   && (symbolic_operand (x, Pmode) || pic_address_needs_scratch (x))))\n+    {\n+      x = gen_rtx_LO_SUM (GET_MODE (x), gen_rtx_HIGH (GET_MODE (x), x), x);\n+      push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,\n+\t\t   BASE_REG_CLASS, GET_MODE (x), VOIDmode, 0, 0,\n+\t\t   opnum, (enum reload_type)type);\n+      *win = 1;\n+      return x;\n+    }\n+\n+  /* We have to recognize what we have already generated above.  */\n+  if (GET_CODE (x) == LO_SUM && GET_CODE (XEXP (x, 0)) == HIGH)\n+    {\n+      push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,\n+\t\t   BASE_REG_CLASS, GET_MODE (x), VOIDmode, 0, 0,\n+\t\t   opnum, (enum reload_type)type);\n+      *win = 1;\n+      return x;\n+    }\n+\n+  *win = 0;\n+  return x;\n+}\n+\n /* Return true if ADDR (a legitimate address expression)\n    has an effect that depends on the machine mode it is used for.\n \n@@ -9111,7 +9164,7 @@ sparc_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \t  /* Delay emitting the PIC helper function because it needs to\n \t     change the section and we are emitting assembly code.  */\n \t  load_pic_register ();  /* clobbers %o7 */\n-\t  scratch = legitimize_pic_address (funexp, scratch);\n+\t  scratch = sparc_legitimize_pic_address (funexp, scratch);\n \t  seq = get_insns ();\n \t  end_sequence ();\n \t  emit_and_preserve (seq, spill_reg, spill_reg2);"}, {"sha": "eae39597023b371fc8704194a2180c66a46de7f0", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 8, "deletions": 30, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58e6223e9283df9deb166d5dbc1fcc4d21c17ce0/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58e6223e9283df9deb166d5dbc1fcc4d21c17ce0/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=58e6223e9283df9deb166d5dbc1fcc4d21c17ce0", "patch": "@@ -1801,36 +1801,14 @@ do {\t\t\t\t\t\t\t\t\t\\\n \f\n /* Try a machine-dependent way of reloading an illegitimate address\n    operand.  If we find one, push the reload and jump to WIN.  This\n-   macro is used in only one place: `find_reloads_address' in reload.c.\n-\n-   For SPARC 32, we wish to handle addresses by splitting them into\n-   HIGH+LO_SUM pairs, retaining the LO_SUM in the memory reference.\n-   This cuts the number of extra insns by one.\n-\n-   Do nothing when generating PIC code and the address is a\n-   symbolic operand or requires a scratch register.  */\n-\n-#define LEGITIMIZE_RELOAD_ADDRESS(X,MODE,OPNUM,TYPE,IND_LEVELS,WIN)     \\\n-do {                                                                    \\\n-  /* Decompose SImode constants into hi+lo_sum.  We do have to \t\t\\\n-     rerecognize what we produce, so be careful.  */\t\t\t\\\n-  if (CONSTANT_P (X)\t\t\t\t\t\t\t\\\n-      && (MODE != TFmode || TARGET_ARCH64)\t\t\t\t\\\n-      && GET_MODE (X) == SImode\t\t\t\t\t\t\\\n-      && GET_CODE (X) != LO_SUM && GET_CODE (X) != HIGH\t\t\t\\\n-      && ! (flag_pic\t\t\t\t\t\t\t\\\n-\t    && (symbolic_operand (X, Pmode)\t\t\t\t\\\n-\t\t|| pic_address_needs_scratch (X)))\t\t\t\\\n-      && sparc_cmodel <= CM_MEDLOW)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      X = gen_rtx_LO_SUM (GET_MODE (X),\t\t\t\t\t\\\n-\t\t\t  gen_rtx_HIGH (GET_MODE (X), X), X);\t\t\\\n-      push_reload (XEXP (X, 0), NULL_RTX, &XEXP (X, 0), NULL,\t\t\\\n-                   BASE_REG_CLASS, GET_MODE (X), VOIDmode, 0, 0,\t\\\n-                   OPNUM, TYPE);\t\t\t\t\t\\\n-      goto WIN;\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  /* ??? 64-bit reloads.  */\t\t\t\t\t\t\\\n+   macro is used in only one place: `find_reloads_address' in reload.c.  */\n+#define LEGITIMIZE_RELOAD_ADDRESS(X,MODE,OPNUM,TYPE,IND_LEVELS,WIN)\t   \\\n+do {\t\t\t\t\t\t\t\t\t   \\\n+  int win;\t\t\t\t\t\t\t\t   \\\n+  (X) = sparc_legitimize_reload_address ((X), (MODE), (OPNUM),\t\t   \\\n+\t\t\t\t\t (int)(TYPE), (IND_LEVELS), &win); \\\n+  if (win)\t\t\t\t\t\t\t\t   \\\n+    goto WIN;\t\t\t\t\t\t\t\t   \\\n } while (0)\n \f\n /* Specify the machine mode that this machine uses"}]}