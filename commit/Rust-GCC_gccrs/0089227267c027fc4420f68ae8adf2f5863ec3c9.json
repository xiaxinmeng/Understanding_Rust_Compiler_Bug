{"sha": "0089227267c027fc4420f68ae8adf2f5863ec3c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDA4OTIyNzI2N2MwMjdmYzQ0MjBmNjhhZThhZGYyZjU4NjNlYzNjOQ==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2013-01-14T15:08:45Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2013-01-14T15:08:45Z"}, "message": "* Fix typos.  Remove trailing blanks.  Fix coding style.\n\nFrom-SVN: r195151", "tree": {"sha": "967119b7ca2f6f310aa970a49bd7a7df7a493add", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/967119b7ca2f6f310aa970a49bd7a7df7a493add"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0089227267c027fc4420f68ae8adf2f5863ec3c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0089227267c027fc4420f68ae8adf2f5863ec3c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0089227267c027fc4420f68ae8adf2f5863ec3c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0089227267c027fc4420f68ae8adf2f5863ec3c9/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0ad394c5e95de3ad312be53bd6399a679b3b27d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0ad394c5e95de3ad312be53bd6399a679b3b27d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0ad394c5e95de3ad312be53bd6399a679b3b27d"}], "stats": {"total": 2003, "additions": 1036, "deletions": 967}, "files": [{"sha": "64df290c6d01732d18f1e8ca7e61f792fd1e8db8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0089227267c027fc4420f68ae8adf2f5863ec3c9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0089227267c027fc4420f68ae8adf2f5863ec3c9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0089227267c027fc4420f68ae8adf2f5863ec3c9", "patch": "@@ -1,3 +1,27 @@\n+2013-01-14  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\t* config/avr/avr-stdint.h: Remove trailing blanks.\n+\t* config/avr/avr-log.h: Same.\n+\t* config/avr/avr-arch.h: Same.\n+\t* config/avr/avr-devices.c: Same.\n+\t* config/avr/avr-dimode.md: Same.\n+\t* config/avr/predicates.md: Same.\n+\t* config/avr/avr-c.c: Same.  And fix typo.\n+\t\n+\t* config/avr/avr-protos.h: Same.  And:\n+\t(function_arg_regno_p): Rename to avr_function_arg_regno_p.\n+\t(init_cumulative_args): Rename to avr_init_cumulative_args.\n+\t(expand_prologue): Rename to avr_expand_prologue.\n+\t(expand_epilogue): Rename to avr_expand_epilogue.\n+\t(adjust_insn_length): Rename to avr_adjust_insn_length.\n+\t(notice_update_cc): Rename to avr_notice_update_cc.\n+\t(final_prescan_insn): Rename to avr_final_prescan_insn.\n+\t* config/avr/avr.c: Same.\n+\t* config/avr/avr.h: Same.\n+\t* config/avr/avr.md: Remove trailing blanks.\n+\t(prologue): Use avr_expand_prologue.\n+\t(epilogue, sibcall_epilogue): Use avr_expand_epilogue.\n+\n 2013-01-14  Richard Biener  <rguenther@suse.de>\n \n \t* tree-cfg.c (verify_expr_location, verify_expr_location_1,"}, {"sha": "a2673370a857720040da010c1ed37accf708827a", "filename": "gcc/config/avr/avr-arch.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0089227267c027fc4420f68ae8adf2f5863ec3c9/gcc%2Fconfig%2Favr%2Favr-arch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0089227267c027fc4420f68ae8adf2f5863ec3c9/gcc%2Fconfig%2Favr%2Favr-arch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-arch.h?ref=0089227267c027fc4420f68ae8adf2f5863ec3c9", "patch": "@@ -74,7 +74,7 @@ struct base_arch_s\n   /* This core has the RAMPD special function register\n      and thus also the RAMPX, RAMPY and RAMPZ registers.  */\n   int have_rampd;\n-  \n+\n   /* Default start of data section address for architecture.  */\n   int default_data_section_start;\n \n@@ -84,9 +84,9 @@ struct base_arch_s\n \n   /* Architecture id to built-in define __AVR_ARCH__ (NULL -> no macro) */\n   const char *const macro;\n-  \n+\n   /* Architecture name.  */\n-  const char *const arch_name;  \n+  const char *const arch_name;\n };\n \n \n@@ -96,16 +96,16 @@ struct mcu_type_s\n {\n   /* Device name.  */\n   const char *const name;\n-  \n+\n   /* Index in avr_arch_types[].  */\n-  enum avr_arch arch; \n-  \n+  enum avr_arch arch;\n+\n   /* Must lie outside user's namespace.  NULL == no macro.  */\n   const char *const macro;\n-  \n+\n   /* Stack pointer have 8 bits width.  */\n   int short_sp;\n-  \n+\n   /* Some AVR devices have a core erratum when skipping a 2-word instruction.\n      Skip instructions are:  SBRC, SBRS, SBIC, SBIS, CPSE.\n      Problems will occur with return address is IRQ executes during the\n@@ -125,15 +125,15 @@ struct mcu_type_s\n \n   /* Core Erratum:  Must not skip 2-word instruction.  */\n   int errata_skip;\n-  \n+\n   /* Start of data section.  */\n   int data_section_start;\n-  \n+\n   /* Number of 64k segments in the flash.  */\n   int n_flash;\n \n   /* Name of device library.  */\n-  const char *const library_name; \n+  const char *const library_name;\n };\n \n /* Map architecture to its texinfo string.  */"}, {"sha": "f8b2b200e0b181df86b96272fd279076de49da48", "filename": "gcc/config/avr/avr-c.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0089227267c027fc4420f68ae8adf2f5863ec3c9/gcc%2Fconfig%2Favr%2Favr-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0089227267c027fc4420f68ae8adf2f5863ec3c9/gcc%2Fconfig%2Favr%2Favr-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-c.c?ref=0089227267c027fc4420f68ae8adf2f5863ec3c9", "patch": "@@ -40,7 +40,7 @@ avr_register_target_pragmas (void)\n   gcc_assert (ADDR_SPACE_GENERIC == ADDR_SPACE_RAM);\n \n   /* Register address spaces.  The order must be the same as in the respective\n-     enum from avr.h (or designated initialized must be used in avr.c).  */\n+     enum from avr.h (or designated initializers must be used in avr.c).  */\n \n   for (i = 0; i < ADDR_SPACE_COUNT; i++)\n     {\n@@ -52,22 +52,22 @@ avr_register_target_pragmas (void)\n }\n \n \n-/* Transorm LO into uppercase and write the result to UP.\n+/* Transform LO into uppercase and write the result to UP.\n    You must provide enough space for UP.  Return UP.  */\n \n static char*\n avr_toupper (char *up, const char *lo)\n {\n   char *up0 = up;\n-  \n+\n   for (; *lo; lo++, up++)\n     *up = TOUPPER (*lo);\n \n   *up = '\\0';\n \n   return up0;\n }\n-             \n+\n /* Worker function for TARGET_CPU_CPP_BUILTINS.  */\n \n static const char *const avr_builtin_name[] =\n@@ -82,7 +82,7 @@ void\n avr_cpu_cpp_builtins (struct cpp_reader *pfile)\n {\n   int i;\n-  \n+\n   builtin_define_std (\"AVR\");\n \n   if (avr_current_arch->macro)\n@@ -139,24 +139,24 @@ avr_cpu_cpp_builtins (struct cpp_reader *pfile)\n   if (avr_current_device->errata_skip)\n     {\n       cpp_define (pfile, \"__AVR_ERRATA_SKIP__\");\n-      \n+\n       if (avr_current_arch->have_jmp_call)\n         cpp_define (pfile, \"__AVR_ERRATA_SKIP_JMP_CALL__\");\n     }\n \n   cpp_define_formatted (pfile, \"__AVR_SFR_OFFSET__=0x%x\",\n                         avr_current_arch->sfr_offset);\n-    \n+\n #ifdef WITH_AVRLIBC\n   cpp_define (pfile, \"__WITH_AVRLIBC__\");\n #endif /* WITH_AVRLIBC */\n-      \n-  /* Define builtin macros so that the user can easily query if or if not\n-     non-generic address spaces (and which) are supported.\n+\n+  /* Define builtin macros so that the user can easily query whether\n+     non-generic address spaces (and which) are supported or not.\n      This is only supported for C.  For C++, a language extension is needed\n      (as mentioned in ISO/IEC DTR 18037; Annex F.2) which is not\n      implemented in GCC up to now.  */\n-  \n+\n   if (!strcmp (lang_hooks.name, \"GNU C\"))\n     {\n       for (i = 0; i < ADDR_SPACE_COUNT; i++)\n@@ -174,8 +174,8 @@ avr_cpu_cpp_builtins (struct cpp_reader *pfile)\n           }\n     }\n \n-  /* Define builtin macros so that the user can easily query if or\n-     if not a specific builtin is available. */\n+  /* Define builtin macros so that the user can easily query whether or\n+     not a specific builtin is available. */\n \n   for (i = 0; avr_builtin_name[i]; i++)\n     {"}, {"sha": "6fa700bc260ad6af4ea9cb9bdf239d06413347b4", "filename": "gcc/config/avr/avr-devices.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0089227267c027fc4420f68ae8adf2f5863ec3c9/gcc%2Fconfig%2Favr%2Favr-devices.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0089227267c027fc4420f68ae8adf2f5863ec3c9/gcc%2Fconfig%2Favr%2Favr-devices.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-devices.c?ref=0089227267c027fc4420f68ae8adf2f5863ec3c9", "patch": "@@ -35,7 +35,7 @@ avr_arch_types[] =\n   /*\n     A  M  J  LM E  E  E  X  R   d S   S O   A\n     S  U  M  PO L  L  I  M  A   a t   F ff  r\n-    M  L  P  MV P  P  J  E  M   t a   R s   c \n+    M  L  P  MV P  P  J  E  M   t a   R s   c\n              XW M  M  M  G  P   a r     e   h\n                    X  P  A  D     t     t   ID   */\n   { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, \"1\",   \"avr1\"  },"}, {"sha": "71793fd587751c2b4eef551583951c62fd5fd812", "filename": "gcc/config/avr/avr-dimode.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0089227267c027fc4420f68ae8adf2f5863ec3c9/gcc%2Fconfig%2Favr%2Favr-dimode.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0089227267c027fc4420f68ae8adf2f5863ec3c9/gcc%2Fconfig%2Favr%2Favr-dimode.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-dimode.md?ref=0089227267c027fc4420f68ae8adf2f5863ec3c9", "patch": "@@ -31,7 +31,7 @@\n ;; The DImode insns are all straight forward -- except movdi.  The approach\n ;; of this implementation is to provide DImode insns without the burden of\n ;; introducing movdi.\n-;; \n+;;\n ;; The caveat is that if there are insns for some mode, there must also be a\n ;; respective move insn that describes reloads.  Therefore, this\n ;; implementation uses an accumulator-based model with two hard-coded,\n@@ -75,7 +75,7 @@\n       {\n         emit_move_insn (gen_rtx_REG (QImode, REG_X), operands[2]);\n         emit_insn (gen_adddi3_const8_insn ());\n-      }        \n+      }\n     else if (const_operand (operands[2], GET_MODE (operands[2])))\n       {\n         emit_insn (gen_add<mode>3_const_insn (operands[2]));\n@@ -344,7 +344,7 @@\n       {\n         emit_move_insn (gen_rtx_REG (QImode, REG_X), operands[2]);\n         emit_insn (gen_compare_const8_di2 ());\n-      }        \n+      }\n     else if (const_operand (operands[2], GET_MODE (operands[2])))\n       {\n         emit_insn (gen_compare_const_<mode>2 (operands[2]));"}, {"sha": "9e538e601248964ef0c9594e98640453dec275a8", "filename": "gcc/config/avr/avr-log.c", "status": "modified", "additions": 44, "deletions": 43, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0089227267c027fc4420f68ae8adf2f5863ec3c9/gcc%2Fconfig%2Favr%2Favr-log.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0089227267c027fc4420f68ae8adf2f5863ec3c9/gcc%2Fconfig%2Favr%2Favr-log.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-log.c?ref=0089227267c027fc4420f68ae8adf2f5863ec3c9", "patch": "@@ -41,8 +41,8 @@\n    avr_edump (fmt, ...) is a shortcut for avr_fdump (stderr, fmt, ...)\n \n   == known %-codes ==\n-  \n-  b: bool  \n+\n+  b: bool\n   r: rtx\n   t: tree\n   T: tree (brief)\n@@ -55,7 +55,7 @@\n   H: location_t\n \n   == no arguments ==\n-  \n+\n   A: call abort()\n   f: current_function_name()\n   F: caller (via __FUNCTION__)\n@@ -65,7 +65,7 @@\n      else return.\n \n   == same as printf ==\n-  \n+\n   %: %\n   c: char\n   s: string\n@@ -95,24 +95,24 @@ static int\n avr_log_fdump_e (const char *fmt, ...)\n {\n   va_list ap;\n-        \n+\n   va_start (ap, fmt);\n   avr_log_vadump (stderr, fmt, ap);\n   va_end (ap);\n-    \n+\n   return 1;\n }\n \n static int\n avr_log_fdump_f (FILE *stream, const char *fmt, ...)\n {\n   va_list ap;\n-        \n+\n   va_start (ap, fmt);\n   if (stream)\n     avr_log_vadump (stream, fmt, ap);\n   va_end (ap);\n-    \n+\n   return 1;\n }\n \n@@ -124,7 +124,7 @@ avr_log_set_caller_e (const char *caller)\n      )(const char*, ...)\n {\n   avr_log_caller = caller;\n-  \n+\n   return avr_log_fdump_e;\n }\n \n@@ -192,19 +192,19 @@ avr_log_vadump (FILE *file, const char *fmt, va_list ap)\n         default:\n           fputc (*(fmt-1), file);\n           break;\n-          \n+\n         case '\\\\':\n           bs[1] = *fmt++;\n           fputs (bs, file);\n           break;\n-          \n+\n         case '%':\n           switch (*fmt++)\n             {\n             case '%':\n               fputc ('%', file);\n               break;\n-              \n+\n             case 't':\n               {\n                 tree t = va_arg (ap, tree);\n@@ -222,39 +222,39 @@ avr_log_vadump (FILE *file, const char *fmt, va_list ap)\n                   }\n                 break;\n               }\n-              \n+\n             case 'T':\n               print_node_brief (file, \"\", va_arg (ap, tree), 3);\n               break;\n-              \n+\n             case 'd':\n               fprintf (file, \"%d\", va_arg (ap, int));\n               break;\n-              \n+\n             case 'D':\n               dump_double_int (file, va_arg (ap, double_int), false);\n               break;\n \n             case 'X':\n               avr_dump_double_int_hex (file, va_arg (ap, double_int));\n               break;\n-              \n+\n             case 'x':\n               fprintf (file, \"%x\", va_arg (ap, int));\n               break;\n-                        \n+\n             case 'b':\n               fprintf (file, \"%s\", va_arg (ap, int) ? \"true\" : \"false\");\n               break;\n-                        \n+\n             case 'c':\n               fputc (va_arg (ap, int), file);\n               break;\n-                        \n+\n             case 'r':\n               print_inline_rtx (file, va_arg (ap, rtx), 0);\n               break;\n-                        \n+\n             case 'L':\n               {\n                 rtx insn = va_arg (ap, rtx);\n@@ -267,85 +267,86 @@ avr_log_vadump (FILE *file, const char *fmt, va_list ap)\n                   }\n                 break;\n               }\n-                        \n+\n             case 'f':\n               if (cfun && cfun->decl)\n                 fputs (current_function_name(), file);\n               break;\n-                        \n+\n             case 's':\n               {\n                 const char *str = va_arg (ap, char*);\n                 fputs (str ? str : \"(null)\", file);\n               }\n               break;\n-                        \n+\n             case 'm':\n-              fputs (GET_MODE_NAME ((enum machine_mode) va_arg (ap, int)), file);\n+              fputs (GET_MODE_NAME ((enum machine_mode) va_arg (ap, int)),\n+                     file);\n               break;\n-              \n+\n             case 'C':\n               fputs (rtx_name[va_arg (ap, int)], file);\n               break;\n-              \n+\n             case 'R':\n               fputs (reg_class_names[va_arg (ap, int)], file);\n               break;\n-              \n+\n             case 'F':\n               fputs (avr_log_caller, file);\n               break;\n-              \n+\n             case 'H':\n               {\n                 location_t loc = va_arg (ap, location_t);\n-                \n+\n                 if (BUILTINS_LOCATION == loc)\n                   fprintf (file, \"<BUILTIN-LOCATION>\");\n                 else if (UNKNOWN_LOCATION == loc)\n                   fprintf (file, \"<UNKNOWN-LOCATION>\");\n                 else\n                   fprintf (file, \"%s:%d\",\n                            LOCATION_FILE (loc), LOCATION_LINE (loc));\n-                \n+\n                 break;\n               }\n-              \n+\n             case '!':\n               if (!current_pass)\n                 return;\n               /* FALLTHRU */\n-              \n+\n             case '?':\n               avr_log_fdump_f (file, \"%F[%f:%P]\");\n               break;\n-                        \n+\n             case 'P':\n               if (current_pass)\n-                fprintf (file, \"%s(%d)\", \n+                fprintf (file, \"%s(%d)\",\n                          current_pass->name,\n                          current_pass->static_pass_number);\n               else\n                 fprintf (file, \"pass=?\");\n-                        \n+\n               break;\n-                        \n+\n             case 'A':\n               fflush (file);\n               abort();\n-              \n+\n             default:\n               /* Unknown %-code: Stop printing */\n-              \n+\n               fprintf (file, \"??? %%%c ???%s\\n\", *(fmt-1), fmt);\n               fmt = \"\";\n-              \n+\n               break;\n             }\n           break; /* % */\n         }\n     }\n-    \n+\n   fflush (file);\n }\n \n@@ -357,14 +358,14 @@ void\n avr_log_set_avr_log (void)\n {\n   bool all = TARGET_ALL_DEBUG != 0;\n-  \n+\n   if (all || avr_log_details)\n     {\n       /* Adding , at beginning and end of string makes searching easier.  */\n-      \n+\n       char *str = (char*) alloca (3 + strlen (avr_log_details));\n       bool info;\n-      \n+\n       str[0] = ',';\n       strcat (stpcpy (str+1, avr_log_details), \",\");\n "}, {"sha": "5246d063799f7b3b69af04f7a9f66a89d65aa006", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0089227267c027fc4420f68ae8adf2f5863ec3c9/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0089227267c027fc4420f68ae8adf2f5863ec3c9/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=0089227267c027fc4420f68ae8adf2f5863ec3c9", "patch": "@@ -20,11 +20,11 @@\n    <http://www.gnu.org/licenses/>.  */\n \n \n-extern int function_arg_regno_p (int r);\n+extern int avr_function_arg_regno_p (int r);\n extern void avr_cpu_cpp_builtins (struct cpp_reader * pfile);\n extern enum reg_class avr_regno_reg_class (int r);\n extern void asm_globalize_label (FILE *file, const char *name);\n-extern void order_regs_for_local_alloc (void);\n+extern void avr_adjust_reg_alloc_order (void);\n extern int avr_initial_elimination_offset (int from, int to);\n extern int avr_simple_epilogue (void);\n extern int avr_hard_regno_rename_ok (unsigned int, unsigned int);\n@@ -38,8 +38,7 @@ extern void asm_output_external (FILE *file, tree decl, char *name);\n extern int avr_progmem_p (tree decl, tree attributes);\n \n #ifdef RTX_CODE /* inside TREE_CODE */\n-extern void init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype,\n-\t\t\t\t  rtx libname, tree fndecl);\n+extern void avr_init_cumulative_args (CUMULATIVE_ARGS*, tree, rtx, tree);\n #endif /* RTX_CODE inside TREE_CODE */\n \n #endif /* TREE_CODE */\n@@ -78,8 +77,8 @@ extern bool avr_rotate_bytes (rtx operands[]);\n extern const char* avr_out_fract (rtx, rtx[], bool, int*);\n extern rtx avr_to_int_mode (rtx);\n \n-extern void expand_prologue (void);\n-extern void expand_epilogue (bool);\n+extern void avr_expand_prologue (void);\n+extern void avr_expand_epilogue (bool);\n extern bool avr_emit_movmemhi (rtx*);\n extern int avr_epilogue_uses (int regno);\n extern int avr_starting_frame_offset (void);\n@@ -96,20 +95,20 @@ extern bool avr_popcount_each_byte (rtx, int, int);\n extern bool avr_has_nibble_0xf (rtx);\n \n extern int extra_constraint_Q (rtx x);\n-extern int adjust_insn_length (rtx insn, int len);\n+extern int avr_adjust_insn_length (rtx insn, int len);\n extern const char* output_reload_inhi (rtx*, rtx, int*);\n extern const char* output_reload_insisf (rtx*, rtx, int*);\n extern const char* avr_out_reload_inpsi (rtx*, rtx, int*);\n extern const char* avr_out_lpm (rtx, rtx*, int*);\n-extern void notice_update_cc (rtx body, rtx insn);\n+extern void avr_notice_update_cc (rtx body, rtx insn);\n extern int reg_unused_after (rtx insn, rtx reg);\n extern int _reg_unused_after (rtx insn, rtx reg);\n extern int avr_jump_mode (rtx x, rtx insn);\n extern int test_hard_reg_class (enum reg_class rclass, rtx x);\n extern int jump_over_one_insn_p (rtx insn, rtx dest);\n \n extern int avr_hard_regno_mode_ok (int regno, enum machine_mode mode);\n-extern void final_prescan_insn (rtx insn, rtx *operand, int num_operands);\n+extern void avr_final_prescan_insn (rtx insn, rtx *operand, int num_operands);\n extern int avr_simplify_comparison_p (enum machine_mode mode,\n \t\t\t\t      RTX_CODE op, rtx x);\n extern RTX_CODE avr_normalize_condition (RTX_CODE condition);"}, {"sha": "8e7278f389a10edc606f44b82f262cd1baa9eeb2", "filename": "gcc/config/avr/avr-stdint.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0089227267c027fc4420f68ae8adf2f5863ec3c9/gcc%2Fconfig%2Favr%2Favr-stdint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0089227267c027fc4420f68ae8adf2f5863ec3c9/gcc%2Fconfig%2Favr%2Favr-stdint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-stdint.h?ref=0089227267c027fc4420f68ae8adf2f5863ec3c9", "patch": "@@ -30,7 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n    - For the same reason, [u]int_fast8_t is defined as 8-bit type.\n \n */\n-   \n+\n #define SIG_ATOMIC_TYPE \"char\"\n \n #define INT8_TYPE \"signed char\""}, {"sha": "93f174b90f3d88f1c8955f6f83a6b49f48c4c433", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 760, "deletions": 726, "changes": 1486, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0089227267c027fc4420f68ae8adf2f5863ec3c9/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0089227267c027fc4420f68ae8adf2f5863ec3c9/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=0089227267c027fc4420f68ae8adf2f5863ec3c9"}, {"sha": "7491f348a252d9fdd334ac5803b21b7b728e7e3b", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0089227267c027fc4420f68ae8adf2f5863ec3c9/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0089227267c027fc4420f68ae8adf2f5863ec3c9/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=0089227267c027fc4420f68ae8adf2f5863ec3c9", "patch": "@@ -201,10 +201,11 @@ enum\n     32,33,34,35\t\t\t\t\t\\\n     }\n \n-#define ADJUST_REG_ALLOC_ORDER order_regs_for_local_alloc ()\n+#define ADJUST_REG_ALLOC_ORDER avr_adjust_reg_alloc_order()\n \n \n-#define HARD_REGNO_NREGS(REGNO, MODE) ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+#define HARD_REGNO_NREGS(REGNO, MODE)                                   \\\n+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n #define HARD_REGNO_MODE_OK(REGNO, MODE) avr_hard_regno_mode_ok(REGNO, MODE)\n \n@@ -318,15 +319,19 @@ enum reg_class {\n    for POST_DEC targets (PR27386).  */\n /*#define PUSH_ROUNDING(NPUSHED) (NPUSHED)*/\n \n-typedef struct avr_args {\n-  int nregs;\t\t\t/* # registers available for passing */\n-  int regno;\t\t\t/* next available register number */\n+typedef struct avr_args\n+{\n+  /* # Registers available for passing */\n+  int nregs;\n+\n+  /* Next available register number */\n+  int regno;\n } CUMULATIVE_ARGS;\n \n #define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, FNDECL, N_NAMED_ARGS) \\\n-  init_cumulative_args (&(CUM), FNTYPE, LIBNAME, FNDECL)\n+  avr_init_cumulative_args (&(CUM), FNTYPE, LIBNAME, FNDECL)\n \n-#define FUNCTION_ARG_REGNO_P(r) function_arg_regno_p(r)\n+#define FUNCTION_ARG_REGNO_P(r) avr_function_arg_regno_p(r)\n \n #define DEFAULT_PCC_STRUCT_RETURN 0\n \n@@ -415,7 +420,8 @@ typedef struct avr_args {\n     \"r24\",\"r25\",\"r26\",\"r27\",\"r28\",\"r29\",\"r30\",\"r31\",\t\\\n     \"__SP_L__\",\"__SP_H__\",\"argL\",\"argH\"}\n \n-#define FINAL_PRESCAN_INSN(insn, operand, nop) final_prescan_insn (insn, operand,nop)\n+#define FINAL_PRESCAN_INSN(insn, operand, nop)  \\\n+  avr_final_prescan_insn (insn, operand,nop)\n \n #define ASM_OUTPUT_REG_PUSH(STREAM, REGNO)\t\\\n {\t\t\t\t\t\t\\\n@@ -429,8 +435,8 @@ typedef struct avr_args {\n   fprintf (STREAM, \"\\tpop\\tr%d\", REGNO);\t\\\n }\n \n-#define ASM_OUTPUT_ADDR_VEC_ELT(STREAM, VALUE)\t\t\\\n-  avr_output_addr_vec_elt(STREAM, VALUE)\n+#define ASM_OUTPUT_ADDR_VEC_ELT(STREAM, VALUE)  \\\n+  avr_output_addr_vec_elt (STREAM, VALUE)\n \n #define ASM_OUTPUT_ALIGN(STREAM, POWER)                 \\\n   do {                                                  \\\n@@ -459,7 +465,7 @@ typedef struct avr_args {\n    after execution of an instruction whose pattern is EXP.\n    Do not alter them if the instruction would not alter the cc's.  */\n \n-#define NOTICE_UPDATE_CC(EXP, INSN) notice_update_cc(EXP, INSN)\n+#define NOTICE_UPDATE_CC(EXP, INSN) avr_notice_update_cc (EXP, INSN)\n \n /* The add insns don't set overflow in a usable way.  */\n #define CC_OVERFLOW_UNUSABLE 01000\n@@ -477,8 +483,8 @@ typedef struct avr_args {\n #define FUNCTION_PROFILER(FILE, LABELNO)  \\\n   fprintf (FILE, \"/* profiler %d */\", (LABELNO))\n \n-#define ADJUST_INSN_LENGTH(INSN, LENGTH) (LENGTH =\\\n-\t\t\t\t\t  adjust_insn_length (INSN, LENGTH))\n+#define ADJUST_INSN_LENGTH(INSN, LENGTH)                \\\n+    (LENGTH = avr_adjust_insn_length (INSN, LENGTH))\n \n extern const char *avr_device_to_arch (int argc, const char **argv);\n extern const char *avr_device_to_data_start (int argc, const char **argv);"}, {"sha": "6432d638220d2ea31d8eb9071a3573349bcf6879", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 93, "deletions": 93, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0089227267c027fc4420f68ae8adf2f5863ec3c9/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0089227267c027fc4420f68ae8adf2f5863ec3c9/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=0089227267c027fc4420f68ae8adf2f5863ec3c9", "patch": "@@ -82,7 +82,7 @@\n    UNSPECV_WDR\n    UNSPECV_DELAY_CYCLES\n    ])\n-    \n+\n \n (include \"predicates.md\")\n (include \"constraints.md\")\n@@ -166,23 +166,23 @@\n (define_attr \"enabled\" \"\"\n   (cond [(eq_attr \"isa\" \"standard\")\n          (const_int 1)\n-         \n+\n          (and (eq_attr \"isa\" \"mov\")\n               (match_test \"!AVR_HAVE_MOVW\"))\n          (const_int 1)\n \n          (and (eq_attr \"isa\" \"movw\")\n               (match_test \"AVR_HAVE_MOVW\"))\n          (const_int 1)\n-         \n+\n          (and (eq_attr \"isa\" \"rjmp\")\n               (match_test \"!AVR_HAVE_JMP_CALL\"))\n          (const_int 1)\n \n          (and (eq_attr \"isa\" \"jmp\")\n               (match_test \"AVR_HAVE_JMP_CALL\"))\n          (const_int 1)\n-         \n+\n          (and (eq_attr \"isa\" \"ijmp\")\n               (match_test \"!AVR_HAVE_EIJMP_EICALL\"))\n          (const_int 1)\n@@ -295,20 +295,20 @@\n ;; The code derived from builtins.c.\n \n (define_expand \"nonlocal_goto_receiver\"\n-  [(set (reg:HI REG_Y) \n+  [(set (reg:HI REG_Y)\n         (unspec_volatile:HI [(const_int 0)] UNSPECV_GOTO_RECEIVER))]\n   \"\"\n   {\n-    emit_move_insn (virtual_stack_vars_rtx, \n-                    gen_rtx_PLUS (Pmode, hard_frame_pointer_rtx, \n+    emit_move_insn (virtual_stack_vars_rtx,\n+                    gen_rtx_PLUS (Pmode, hard_frame_pointer_rtx,\n                                   gen_int_mode (STARTING_FRAME_OFFSET,\n                                                 Pmode)));\n     /* ; This might change the hard frame pointer in ways that aren't\n        ; apparent to early optimization passes, so force a clobber.  */\n     emit_clobber (hard_frame_pointer_rtx);\n     DONE;\n   })\n-  \n+\n \n ;; Defining nonlocal_goto_receiver means we must also define this.\n ;; even though its function is identical to that in builtins.c\n@@ -335,7 +335,7 @@\n     emit_use (stack_pointer_rtx);\n \n     emit_indirect_jump (r_label);\n- \n+\n     DONE;\n   })\n \n@@ -410,9 +410,9 @@\n \n ;; \"loadqi_libgcc\"\n ;; \"loadhi_libgcc\"\n-;; \"loadpsi_libgcc\"    \n-;; \"loadsi_libgcc\"    \n-;; \"loadsf_libgcc\"    \n+;; \"loadpsi_libgcc\"\n+;; \"loadsi_libgcc\"\n+;; \"loadsf_libgcc\"\n (define_expand \"load<mode>_libgcc\"\n   [(set (match_dup 3)\n         (match_dup 2))\n@@ -430,9 +430,9 @@\n \n ;; \"load_qi_libgcc\"\n ;; \"load_hi_libgcc\"\n-;; \"load_psi_libgcc\"    \n-;; \"load_si_libgcc\"    \n-;; \"load_sf_libgcc\"    \n+;; \"load_psi_libgcc\"\n+;; \"load_si_libgcc\"\n+;; \"load_sf_libgcc\"\n (define_insn \"load_<mode>_libgcc\"\n   [(set (reg:MOVMODE 22)\n         (match_operand:MOVMODE 0 \"memory_operand\" \"m,m\"))]\n@@ -573,11 +573,11 @@\n   \"\"\n   {\n     rtx dest = operands[0];\n-    rtx src  = operands[1]; \n-    \n+    rtx src  = operands[1];\n+\n     if (avr_mem_flash_p (dest))\n       DONE;\n-  \n+\n     /* One of the operands has to be in a register.  */\n     if (!register_operand (dest, <MODE>mode)\n         && !reg_or_0_operand (src, <MODE>mode))\n@@ -757,7 +757,7 @@\n     operands[5] = gen_rtx_REG (HImode, REGNO (operands[3]));\n   })\n \n-;; For LPM loads from AS1 we split \n+;; For LPM loads from AS1 we split\n ;;    R = *Z\n ;; to\n ;;    R = *Z++\n@@ -793,7 +793,7 @@\n \n ;;==========================================================================\n ;; xpointer move (24 bit)\n-  \n+\n (define_peephole2 ; *reload_inpsi\n   [(match_scratch:QI 2 \"d\")\n    (set (match_operand:PSI 0 \"l_register_operand\" \"\")\n@@ -804,7 +804,7 @@\n   [(parallel [(set (match_dup 0)\n                    (match_dup 1))\n               (clobber (match_dup 2))])])\n-  \n+\n ;; '*' because it is not used in rtl generation.\n (define_insn \"*reload_inpsi\"\n   [(set (match_operand:PSI 0 \"register_operand\" \"=r\")\n@@ -830,7 +830,7 @@\n   [(set_attr \"length\" \"3,3,8,9,4,10\")\n    (set_attr \"adjust_len\" \"mov24\")\n    (set_attr \"cc\" \"none,none,clobber,clobber,none,clobber\")])\n-  \n+\n ;;==========================================================================\n ;; move double word (32 bit)\n \n@@ -897,7 +897,7 @@\n         (match_operand:SF 1 \"const_double_operand\" \"\"))\n    (match_dup 2)]\n   \"operands[1] != CONST0_RTX (SFmode)\"\n-  [(parallel [(set (match_dup 0) \n+  [(parallel [(set (match_dup 0)\n                    (match_dup 1))\n               (clobber (match_dup 2))])])\n \n@@ -926,7 +926,7 @@\n   {\n     if (avr_emit_movmemhi (operands))\n       DONE;\n-    \n+\n     FAIL;\n   })\n \n@@ -1062,7 +1062,7 @@\n     if (operands[2] != const0_rtx)\n       FAIL;\n     addr = copy_to_mode_reg (Pmode, XEXP (operands[1], 0));\n-    operands[1] = gen_rtx_MEM (BLKmode, addr); \n+    operands[1] = gen_rtx_MEM (BLKmode, addr);\n     operands[5] = addr;\n     operands[4] = gen_reg_rtx (HImode);\n   })\n@@ -1495,7 +1495,7 @@\n \tclr __zero_reg__\"\n   [(set_attr \"length\" \"3\")\n    (set_attr \"cc\" \"clobber\")])\n-  \n+\n \n ;; Used when expanding div or mod inline for some special values\n (define_insn \"*subqi3.ashiftrt7\"\n@@ -1563,7 +1563,7 @@\n   \"%~call __umulqihi3\"\n   [(set_attr \"type\" \"xcall\")\n    (set_attr \"cc\" \"clobber\")])\n-  \n+\n ;; \"umulqihi3\"\n ;; \"mulqihi3\"\n (define_insn \"<extend_u>mulqihi3\"\n@@ -1637,7 +1637,7 @@\n         (plus:QI (mult:QI (match_operand:QI 1 \"register_operand\" \"r\")\n                           (match_operand:QI 2 \"register_operand\" \"r\"))\n                  (match_operand:QI 3 \"register_operand\"          \"0\")))]\n-  \n+\n   \"AVR_HAVE_MUL\"\n   \"mul %1,%2\n \tadd %A0,r0\n@@ -1718,7 +1718,7 @@\n         (plus:HI (mult:HI (any_extend:HI (match_operand:QI 1 \"register_operand\" \"<mul_r_d>\"))\n                           (any_extend:HI (match_operand:QI 2 \"register_operand\" \"<mul_r_d>\")))\n                  (match_operand:HI 3 \"register_operand\"                         \"0\")))]\n-  \n+\n   \"AVR_HAVE_MUL\"\n   \"mul<extend_s> %1,%2\n \tadd %A0,r0\n@@ -2163,7 +2163,7 @@\n         if (u8_operand (operands[2], HImode))\n           {\n             emit_insn (gen_muluqihi3 (operands[0], reg, operands[1]));\n-          } \n+          }\n         else if (s8_operand (operands[2], HImode))\n           {\n             emit_insn (gen_mulsqihi3 (operands[0], reg, operands[1]));\n@@ -2250,7 +2250,7 @@\n   \"&& 1\"\n   [(set (reg:SI 18)\n         (match_dup 1))\n-   (set (reg:SI 22) \n+   (set (reg:SI 22)\n         (match_dup 2))\n    (parallel [(set (reg:SI 22)\n                    (mult:SI (reg:SI 22)\n@@ -2297,7 +2297,7 @@\n   {\n     /* Do the QI -> HI extension explicitely before the multiplication.  */\n     /* Do the HI -> SI extension implicitely and after the multiplication.  */\n-       \n+\n     if (QImode == <MODE>mode)\n       operands[1] = gen_rtx_ZERO_EXTEND (HImode, operands[1]);\n \n@@ -2333,7 +2333,7 @@\n   {\n     /* Do the QI -> HI extension explicitely before the multiplication.  */\n     /* Do the HI -> SI extension implicitely and after the multiplication.  */\n-       \n+\n     if (QImode == <MODE>mode)\n       operands[1] = gen_rtx_SIGN_EXTEND (HImode, operands[1]);\n \n@@ -2357,7 +2357,7 @@\n \n (define_insn_and_split \"mulohisi3\"\n   [(set (match_operand:SI 0 \"pseudo_register_operand\"                          \"=r\")\n-        (mult:SI (not:SI (zero_extend:SI \n+        (mult:SI (not:SI (zero_extend:SI\n                           (not:HI (match_operand:HI 1 \"pseudo_register_operand\" \"r\"))))\n                  (match_operand:SI 2 \"pseudo_register_or_const_int_operand\"     \"rn\")))\n    (clobber (reg:HI 26))\n@@ -2422,7 +2422,7 @@\n \n     /* Do the QI -> HI extension explicitely before the multiplication.  */\n     /* Do the HI -> SI extension implicitely and after the multiplication.  */\n-       \n+\n     if (QImode == <QIHI:MODE>mode)\n       xop1 = gen_rtx_fmt_e (<any_extend:CODE>, HImode, xop1);\n \n@@ -2536,16 +2536,16 @@\n ;;  - we get both the quotient and the remainder at no extra cost\n ;;  - we split the patterns only after the first CSE passes because\n ;;    CSE has problems to operate on hard regs.\n-;; \n+;;\n (define_insn_and_split \"divmodqi4\"\n-  [(parallel [(set (match_operand:QI 0 \"pseudo_register_operand\" \"\") \n-                   (div:QI (match_operand:QI 1 \"pseudo_register_operand\" \"\") \n+  [(parallel [(set (match_operand:QI 0 \"pseudo_register_operand\" \"\")\n+                   (div:QI (match_operand:QI 1 \"pseudo_register_operand\" \"\")\n                            (match_operand:QI 2 \"pseudo_register_operand\" \"\")))\n-              (set (match_operand:QI 3 \"pseudo_register_operand\" \"\") \n+              (set (match_operand:QI 3 \"pseudo_register_operand\" \"\")\n                    (mod:QI (match_dup 1) (match_dup 2)))\n-              (clobber (reg:QI 22)) \n-              (clobber (reg:QI 23)) \n-              (clobber (reg:QI 24)) \n+              (clobber (reg:QI 22))\n+              (clobber (reg:QI 23))\n+              (clobber (reg:QI 24))\n               (clobber (reg:QI 25))])]\n   \"\"\n   \"this divmodqi4 pattern should have been splitted;\"\n@@ -2570,18 +2570,18 @@\n    (set_attr \"cc\" \"clobber\")])\n \n (define_insn_and_split \"udivmodqi4\"\n- [(parallel [(set (match_operand:QI 0 \"pseudo_register_operand\" \"\") \n-                  (udiv:QI (match_operand:QI 1 \"pseudo_register_operand\" \"\") \n+ [(parallel [(set (match_operand:QI 0 \"pseudo_register_operand\" \"\")\n+                  (udiv:QI (match_operand:QI 1 \"pseudo_register_operand\" \"\")\n                            (match_operand:QI 2 \"pseudo_register_operand\" \"\")))\n-             (set (match_operand:QI 3 \"pseudo_register_operand\" \"\") \n+             (set (match_operand:QI 3 \"pseudo_register_operand\" \"\")\n                   (umod:QI (match_dup 1) (match_dup 2)))\n              (clobber (reg:QI 22))\n              (clobber (reg:QI 23))\n              (clobber (reg:QI 24))\n              (clobber (reg:QI 25))])]\n   \"\"\n   \"this udivmodqi4 pattern should have been splitted;\"\n-  \"\" \n+  \"\"\n   [(set (reg:QI 24) (match_dup 1))\n    (set (reg:QI 22) (match_dup 2))\n    (parallel [(set (reg:QI 24) (udiv:QI (reg:QI 24) (reg:QI 22)))\n@@ -2600,10 +2600,10 @@\n    (set_attr \"cc\" \"clobber\")])\n \n (define_insn_and_split \"divmodhi4\"\n-  [(parallel [(set (match_operand:HI 0 \"pseudo_register_operand\" \"\") \n-                   (div:HI (match_operand:HI 1 \"pseudo_register_operand\" \"\") \n+  [(parallel [(set (match_operand:HI 0 \"pseudo_register_operand\" \"\")\n+                   (div:HI (match_operand:HI 1 \"pseudo_register_operand\" \"\")\n                            (match_operand:HI 2 \"pseudo_register_operand\" \"\")))\n-              (set (match_operand:HI 3 \"pseudo_register_operand\" \"\") \n+              (set (match_operand:HI 3 \"pseudo_register_operand\" \"\")\n                    (mod:HI (match_dup 1) (match_dup 2)))\n               (clobber (reg:QI 21))\n               (clobber (reg:HI 22))\n@@ -2632,10 +2632,10 @@\n    (set_attr \"cc\" \"clobber\")])\n \n (define_insn_and_split \"udivmodhi4\"\n-  [(parallel [(set (match_operand:HI 0 \"pseudo_register_operand\" \"\") \n+  [(parallel [(set (match_operand:HI 0 \"pseudo_register_operand\" \"\")\n                    (udiv:HI (match_operand:HI 1 \"pseudo_register_operand\" \"\")\n                             (match_operand:HI 2 \"pseudo_register_operand\" \"\")))\n-              (set (match_operand:HI 3 \"pseudo_register_operand\" \"\") \n+              (set (match_operand:HI 3 \"pseudo_register_operand\" \"\")\n                    (umod:HI (match_dup 1) (match_dup 2)))\n               (clobber (reg:QI 21))\n               (clobber (reg:HI 22))\n@@ -2748,7 +2748,7 @@\n   \"&& 1\"\n   [(set (reg:PSI 18)\n         (match_dup 1))\n-   (set (reg:PSI 22) \n+   (set (reg:PSI 22)\n         (match_dup 2))\n    (parallel [(set (reg:PSI 22)\n                    (mult:PSI (reg:PSI 22)\n@@ -2864,17 +2864,17 @@\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n \n (define_insn_and_split \"divmodsi4\"\n-  [(parallel [(set (match_operand:SI 0 \"pseudo_register_operand\" \"\") \n-                   (div:SI (match_operand:SI 1 \"pseudo_register_operand\" \"\") \n+  [(parallel [(set (match_operand:SI 0 \"pseudo_register_operand\" \"\")\n+                   (div:SI (match_operand:SI 1 \"pseudo_register_operand\" \"\")\n                            (match_operand:SI 2 \"pseudo_register_operand\" \"\")))\n-              (set (match_operand:SI 3 \"pseudo_register_operand\" \"\") \n+              (set (match_operand:SI 3 \"pseudo_register_operand\" \"\")\n                    (mod:SI (match_dup 1) (match_dup 2)))\n               (clobber (reg:SI 18))\n               (clobber (reg:SI 22))\n               (clobber (reg:HI 26))\n               (clobber (reg:HI 30))])]\n   \"\"\n-  \"this divmodsi4 pattern should have been splitted;\" \n+  \"this divmodsi4 pattern should have been splitted;\"\n   \"\"\n   [(set (reg:SI 22) (match_dup 1))\n    (set (reg:SI 18) (match_dup 2))\n@@ -2896,10 +2896,10 @@\n    (set_attr \"cc\" \"clobber\")])\n \n (define_insn_and_split \"udivmodsi4\"\n-  [(parallel [(set (match_operand:SI 0 \"pseudo_register_operand\" \"\") \n-                   (udiv:SI (match_operand:SI 1 \"pseudo_register_operand\" \"\") \n+  [(parallel [(set (match_operand:SI 0 \"pseudo_register_operand\" \"\")\n+                   (udiv:SI (match_operand:SI 1 \"pseudo_register_operand\" \"\")\n                            (match_operand:SI 2 \"pseudo_register_operand\" \"\")))\n-              (set (match_operand:SI 3 \"pseudo_register_operand\" \"\") \n+              (set (match_operand:SI 3 \"pseudo_register_operand\" \"\")\n                    (umod:SI (match_dup 1) (match_dup 2)))\n               (clobber (reg:SI 18))\n               (clobber (reg:SI 22))\n@@ -3206,7 +3206,7 @@\n       FAIL;\n \n     offset = INTVAL (operands[2]);\n- \n+\n     if (0 == offset % 8)\n       {\n         if (AVR_HAVE_MOVW && 0 == offset % 16)\n@@ -3614,15 +3614,15 @@\n         if (IN_RANGE (INTVAL (operands[2]), 3, 6))\n           {\n             rtx xoffset = force_reg (QImode, gen_int_mode (1 << INTVAL (operands[2]), QImode));\n-            emit_insn (gen_mulsqipsi3 (operands[0], xoffset, operands[1])); \n+            emit_insn (gen_mulsqipsi3 (operands[0], xoffset, operands[1]));\n             DONE;\n           }\n         else if (optimize_insn_for_speed_p ()\n                  && INTVAL (operands[2]) != 16\n                  && IN_RANGE (INTVAL (operands[2]), 9, 22))\n           {\n             rtx xoffset = force_reg (PSImode, gen_int_mode (1 << INTVAL (operands[2]), PSImode));\n-            emit_insn (gen_mulpsi3 (operands[0], operands[1], xoffset)); \n+            emit_insn (gen_mulpsi3 (operands[0], operands[1], xoffset));\n             DONE;\n           }\n       }\n@@ -4447,7 +4447,7 @@\n       case 0:\n       case 1:\n         return avr_out_tsthi (insn, operands, NULL);\n-        \n+\n       case 2:\n         return \"cp %A0,%A1\\;cpc %B0,%B1\";\n \n@@ -4457,15 +4457,15 @@\n         return reg_unused_after (insn, operands[0])\n                ? \"subi %A0,lo8(%1)\\;sbci %B0,hi8(%1)\"\n                : \"ldi %2,hi8(%1)\\;cpi %A0,lo8(%1)\\;cpc %B0,%2\";\n-               \n+\n       case 4:\n         if (<MODE>mode != HImode)\n           break;\n         return \"ldi %2,lo8(%1)\\;cp %A0,%2\\;ldi %2,hi8(%1)\\;cpc %B0,%2\";\n       }\n-      \n+\n     return avr_out_compare (insn, operands, NULL);\n-  } \n+  }\n   [(set_attr \"cc\" \"compare\")\n    (set_attr \"length\" \"1,2,2,3,4,2,4\")\n    (set_attr \"adjust_len\" \"tsthi,tsthi,*,*,*,compare,compare\")])\n@@ -4489,11 +4489,11 @@\n         return reg_unused_after (insn, operands[0])\n                ? \"subi %A0,lo8(%1)\\;sbci %B0,hi8(%1)\\;sbci %C0,hh8(%1)\"\n                : \"cpi %A0,lo8(%1)\\;ldi %2,hi8(%1)\\;cpc %B0,%2\\;ldi %2,hh8(%1)\\;cpc %C0,%2\";\n-               \n+\n       case 3:\n         return \"ldi %2,lo8(%1)\\;cp %A0,%2\\;ldi %2,hi8(%1)\\;cpc %B0,%2\\;ldi %2,hh8(%1)\\;cpc %C0,%2\";\n       }\n-    \n+\n     return avr_out_compare (insn, operands, NULL);\n   }\n   [(set_attr \"cc\" \"compare\")\n@@ -4514,7 +4514,7 @@\n       return avr_out_tstsi (insn, operands, NULL);\n     else if (1 == which_alternative)\n       return \"cp %A0,%A1\\;cpc %B0,%B1\\;cpc %C0,%C1\\;cpc %D0,%D1\";\n-      \n+\n     return avr_out_compare (insn, operands, NULL);\n   }\n   [(set_attr \"cc\" \"compare\")\n@@ -4758,7 +4758,7 @@\n \n (define_insn \"rvbranch\"\n   [(set (pc)\n-        (if_then_else (match_operator 1 \"simple_comparison_operator\" \n+        (if_then_else (match_operator 1 \"simple_comparison_operator\"\n                                       [(cc0)\n                                        (const_int 0)])\n                       (pc)\n@@ -4772,7 +4772,7 @@\n \n (define_insn \"difficult_rvbranch\"\n   [(set (pc)\n-        (if_then_else (match_operator 1 \"difficult_comparison_operator\" \n+        (if_then_else (match_operator 1 \"difficult_comparison_operator\"\n                                       [(cc0)\n                                        (const_int 0)])\n                       (pc)\n@@ -4940,7 +4940,7 @@\n                    (compare (match_dup 6)\n                             (match_operand:HI 2 \"register_operand\" \"\")))\n               (clobber (match_scratch:QI 9 \"\"))])\n-   \n+\n    (set (pc)\n         (if_then_else (gtu (cc0)\n                            (const_int 0))\n@@ -5317,13 +5317,13 @@\n ;;\n ;; Notice that the peephole is always shorter than cmpqi + branch.\n ;; The reason to write it as peephole is that sequences like\n-;;     \n+;;\n ;;     AND   Rm, Rn\n ;;     BRNE  .La\n ;;\n ;; shall not be superseeded.  With a respective combine pattern\n-;; the latter sequence would be \n-;;     \n+;; the latter sequence would be\n+;;\n ;;     AND   Rm, Rn\n ;;     CPSE  Rm, __zero_reg__\n ;;     RJMP  .La\n@@ -5412,7 +5412,7 @@\n   [(set_attr \"length\" \"5,6\")\n    (set_attr \"cc\" \"clobber\")\n    (set_attr \"isa\" \"rjmp,jmp\")])\n-  \n+\n ;  epilogue  restores using library\n (define_insn \"epilogue_restores\"\n   [(unspec_volatile:QI [(const_int 0)] UNSPECV_EPILOGUE_RESTORES)\n@@ -5429,7 +5429,7 @@\n   [(set_attr \"length\" \"2,3\")\n    (set_attr \"cc\" \"clobber\")\n    (set_attr \"isa\" \"rjmp,jmp\")])\n-  \n+\n ; return\n (define_insn \"return\"\n   [(return)]\n@@ -5440,8 +5440,8 @@\n \n (define_insn \"return_from_epilogue\"\n   [(return)]\n-  \"reload_completed \n-   && cfun->machine \n+  \"reload_completed\n+   && cfun->machine\n    && !(cfun->machine->is_interrupt || cfun->machine->is_signal)\n    && !cfun->machine->is_naked\"\n   \"ret\"\n@@ -5450,8 +5450,8 @@\n \n (define_insn \"return_from_interrupt_epilogue\"\n   [(return)]\n-  \"reload_completed \n-   && cfun->machine \n+  \"reload_completed\n+   && cfun->machine\n    && (cfun->machine->is_interrupt || cfun->machine->is_signal)\n    && !cfun->machine->is_naked\"\n   \"reti\"\n@@ -5460,8 +5460,8 @@\n \n (define_insn \"return_from_naked_epilogue\"\n   [(return)]\n-  \"reload_completed \n-   && cfun->machine \n+  \"reload_completed\n+   && cfun->machine\n    && cfun->machine->is_naked\"\n   \"\"\n   [(set_attr \"cc\" \"none\")\n@@ -5471,23 +5471,23 @@\n   [(const_int 0)]\n   \"\"\n   {\n-    expand_prologue (); \n+    avr_expand_prologue ();\n     DONE;\n   })\n \n (define_expand \"epilogue\"\n   [(const_int 0)]\n   \"\"\n   {\n-    expand_epilogue (false /* sibcall_p */);\n+    avr_expand_epilogue (false /* sibcall_p */);\n     DONE;\n   })\n \n (define_expand \"sibcall_epilogue\"\n   [(const_int 0)]\n   \"\"\n   {\n-    expand_epilogue (true /* sibcall_p */);\n+    avr_expand_epilogue (true /* sibcall_p */);\n     DONE;\n   })\n \n@@ -5915,7 +5915,7 @@\n   \"bst %D2,7\\;bld %D0,7\"\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"none\")])\n-  \n+\n ;; Swap Bytes (change byte-endianess)\n \n (define_expand \"bswapsi2\"\n@@ -5937,9 +5937,9 @@\n \n ;; CPU instructions\n \n-;; NOP taking 1 or 2 Ticks \n+;; NOP taking 1 or 2 Ticks\n (define_expand \"nopv\"\n-  [(parallel [(unspec_volatile [(match_operand:SI 0 \"const_int_operand\" \"\")] \n+  [(parallel [(unspec_volatile [(match_operand:SI 0 \"const_int_operand\" \"\")]\n                                UNSPECV_NOP)\n               (set (match_dup 1)\n                    (unspec_volatile:BLK [(match_dup 1)]\n@@ -5951,7 +5951,7 @@\n   })\n \n (define_insn \"*nopv\"\n-  [(unspec_volatile [(match_operand:SI 0 \"const_int_operand\" \"P,K\")] \n+  [(unspec_volatile [(match_operand:SI 0 \"const_int_operand\" \"P,K\")]\n                     UNSPECV_NOP)\n    (set (match_operand:BLK 1 \"\" \"\")\n \t(unspec_volatile:BLK [(match_dup 1)] UNSPECV_MEMORY_BARRIER))]\n@@ -5982,7 +5982,7 @@\n   \"sleep\"\n   [(set_attr \"length\" \"1\")\n    (set_attr \"cc\" \"none\")])\n- \n+\n ;; WDR\n (define_expand \"wdr\"\n   [(parallel [(unspec_volatile [(const_int 0)] UNSPECV_WDR)\n@@ -6003,7 +6003,7 @@\n   \"wdr\"\n   [(set_attr \"length\" \"1\")\n    (set_attr \"cc\" \"none\")])\n-  \n+\n ;; FMUL\n (define_expand \"fmul\"\n   [(set (reg:QI 24)\n@@ -6330,7 +6330,7 @@\n \n (define_insn_and_split \"*extzv.qihi2\"\n   [(set (match_operand:HI 0 \"register_operand\"                      \"=r\")\n-        (zero_extend:HI \n+        (zero_extend:HI\n          (zero_extract:QI (match_operand:QI 1 \"register_operand\"     \"r\")\n                           (const_int 1)\n                           (match_operand:QI 2 \"const_0_to_7_operand\" \"n\"))))]"}, {"sha": "4983c963b474a94a39b67e6dbb5dd78b4c410f3a", "filename": "gcc/config/avr/predicates.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0089227267c027fc4420f68ae8adf2f5863ec3c9/gcc%2Fconfig%2Favr%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0089227267c027fc4420f68ae8adf2f5863ec3c9/gcc%2Fconfig%2Favr%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fpredicates.md?ref=0089227267c027fc4420f68ae8adf2f5863ec3c9", "patch": "@@ -162,11 +162,11 @@\n ;; True for EQ & NE\n (define_predicate \"eqne_operator\"\n   (match_code \"eq,ne\"))\n-       \n+\n ;; True for GE & LT\n (define_predicate \"gelt_operator\"\n   (match_code \"ge,lt\"))\n-       \n+\n ;; True for GT, GTU, LE & LEU\n (define_predicate \"difficult_comparison_operator\"\n   (match_code \"gt,gtu,le,leu\"))"}, {"sha": "8629b85e8ad0c15301d5d3615e8bec7668495292", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0089227267c027fc4420f68ae8adf2f5863ec3c9/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0089227267c027fc4420f68ae8adf2f5863ec3c9/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=0089227267c027fc4420f68ae8adf2f5863ec3c9", "patch": "@@ -1,3 +1,8 @@\n+2013-01-14  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\t* config/avr/lib1funcs.S: Remove trailing blanks.\n+\t* config/avr/lib1funcs-fixed.S: Ditto.\n+\n 2013-01-14  Georg-Johann Lay  <avr@gjlay.de>\n \n \t* config/avr/avr-lib.h: Add GPL copyright notice."}, {"sha": "0863c6299f4c71dc702854f06f47bd5fb9ed341c", "filename": "libgcc/config/avr/lib1funcs-fixed.S", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0089227267c027fc4420f68ae8adf2f5863ec3c9/libgcc%2Fconfig%2Favr%2Flib1funcs-fixed.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0089227267c027fc4420f68ae8adf2f5863ec3c9/libgcc%2Fconfig%2Favr%2Flib1funcs-fixed.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Flib1funcs-fixed.S?ref=0089227267c027fc4420f68ae8adf2f5863ec3c9", "patch": "@@ -1,5 +1,5 @@\n /*  -*- Mode: Asm -*-  */\n-;;    Copyright (C) 2012\n+;;    Copyright (C) 2012-2013\n ;;    Free Software Foundation, Inc.\n ;;    Contributed by Sean D'Epagnier  (sean@depagnier.com)\n ;;                   Georg-Johann Lay (avr@gjlay.de)\n@@ -163,7 +163,7 @@ ENDF __fractusasf\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;; Conversions from float\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n-       \n+\n #if defined (L_fractsfqq)\n DEFUN __fractsfqq\n     ;; Multiply with 2^{24+7} to get a QQ result in r25\n@@ -408,14 +408,14 @@ DEFUN __mulusa3_round\n \n     mul A1, B0  $  add  C3, r0  $  adc C0, r1\n     mul A0, B1  $  add  C3, r0  $  adc C0, r1  $  rol C1\n-    \n+\n     ;; Round if T = 1.  Store guarding bits outside the result for rounding\n     ;; and left-shift by the signed version (function below).\n     brtc 0f\n     sbrc C3, 7\n     adiw C0, 1\n 0:  push C3\n-    \n+\n     ;; The following MULs don't have LSBs outside the result.\n     ;; C2/C3 is the high part.\n \n@@ -429,11 +429,11 @@ DEFUN __mulusa3_round\n     mul  A2, B1  $  add C1, r0  $  adc C2, r1  $  sbci C3, 0\n     mul  A3, B0  $  add C1, r0  $  adc C2, r1  $  sbci C3, 0\n     neg  C3\n-    \n+\n     mul  A1, B3  $  add C2, r0  $  adc C3, r1\n     mul  A2, B2  $  add C2, r0  $  adc C3, r1\n     mul  A3, B1  $  add C2, r0  $  adc C3, r1\n-    \n+\n     mul  A2, B3  $  add C3, r0\n     mul  A3, B2  $  add C3, r0\n \n@@ -636,7 +636,7 @@ DEFUN __mulusa3_round\n     adc     C1, __zero_reg__\n     adc     C2, __zero_reg__\n     adc     C3, __zero_reg__\n-6:  \n+6:\n     pop     GUARD\n     ;; Epilogue\n     pop     CC3"}, {"sha": "436c511bcdad244e6b17abd2dd185f90daef7050", "filename": "libgcc/config/avr/lib1funcs.S", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0089227267c027fc4420f68ae8adf2f5863ec3c9/libgcc%2Fconfig%2Favr%2Flib1funcs.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0089227267c027fc4420f68ae8adf2f5863ec3c9/libgcc%2Fconfig%2Favr%2Flib1funcs.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Flib1funcs.S?ref=0089227267c027fc4420f68ae8adf2f5863ec3c9", "patch": "@@ -1,5 +1,5 @@\n /*  -*- Mode: Asm -*-  */\n-/* Copyright (C) 1998, 1999, 2000, 2007, 2008, 2009\n+/* Copyright (C) 1998-2013\n    Free Software Foundation, Inc.\n    Contributed by Denis Chertykov <chertykov@gmail.com>\n \n@@ -151,16 +151,16 @@ __mulqi3_loop:\n \tadd\tr_res,r_arg2\n \tadd\tr_arg2,r_arg2\t; shift multiplicand\n \tbreq\t__mulqi3_exit\t; while multiplicand != 0\n-\tlsr\tr_arg1\t\t; \n+\tlsr\tr_arg1\t\t;\n \tbrne\t__mulqi3_loop\t; exit if multiplier = 0\n __mulqi3_exit:\t\n \tmov\tr_arg1,r_res\t; result to return register\n \tret\n ENDF __mulqi3\n \n-#undef r_arg2  \n-#undef r_arg1  \n-#undef r_res   \n+#undef r_arg2\n+#undef r_arg1\n+#undef r_res\n \t\n #endif \t/* defined (L_mulqi3) */\n \n@@ -370,7 +370,7 @@ DEFUN __mulsi3_helper\n \n 2:  ;; B <<= 1\n     lsl  B0      $  rol  B1      $  rol  B2      $  rol  B3\n-    \n+\n 3:  ;; A >>= 1:  Carry = n-th bit of A\n     lsr  A3      $  ror  A2      $  ror  A1      $  ror  A0\n \n@@ -409,7 +409,7 @@ ENDF __mulsi3_helper\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n \f\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n-#if defined (__AVR_HAVE_MUL__)    \n+#if defined (__AVR_HAVE_MUL__)\n #define A0 26\n #define B0 18\n #define C0 22\n@@ -427,7 +427,7 @@ ENDF __mulsi3_helper\n /*******************************************************\n     Widening Multiplication  32 = 16 x 16  with MUL\n *******************************************************/\n-                              \n+\n #if defined (L_mulhisi3)\n ;;; R25:R22 = (signed long) R27:R26 * (signed long) R19:R18\n ;;; C3:C0   = (signed long) A1:A0   * (signed long) B1:B0\n@@ -512,7 +512,7 @@ DEFUN __mulshisi3\n     XJMP    __muluhisi3\n     ;; FALLTHRU\n ENDF __mulshisi3\n-    \n+\n ;;; R25:R22 = (one-extended long) R27:R26 * R21:R18\n ;;; (C3:C0) = (one-extended long) A1:A0   * B3:B0\n ;;; Clobbers: __tmp_reg__\n@@ -647,23 +647,23 @@ DEFUN __mulpsi3\n     ;; C[] = 0\n     clr     __tmp_reg__\n     clr     C2\n-    \n+\n 0:  ;; Shift N-th Bit of B[] into Carry.  N = 24 - Loop\n     LSR  B2     $  ror  B1     $  ror  B0\n-    \n+\n     ;; If the N-th Bit of B[] was set...\n     brcc    1f\n-    \n+\n     ;; ...then add A[] * 2^N to the Result C[]\n     ADD  C0,A0  $  adc  C1,A1  $  adc  C2,A2\n-    \n+\n 1:  ;; Multiply A[] by 2\n     LSL  A0     $  rol  A1     $  rol  A2\n-    \n+\n     ;; Loop until B[] is 0\n     subi B0,0   $  sbci B1,0   $  sbci B2,0\n     brne    0b\n-    \n+\n     ;; Copy C[] to the return Register A[]\n     wmov    A0, C0\n     mov     A2, C2\n@@ -1002,7 +1002,7 @@ __udivmodqi4_ep:\n \trol\tr_arg1\t\t; shift dividend (with CARRY)\n \tdec\tr_cnt\t\t; decrement loop counter\n \tbrne\t__udivmodqi4_loop\n-\tcom\tr_arg1\t\t; complement result \n+\tcom\tr_arg1\t\t; complement result\n \t\t\t\t; because C flag was complemented in loop\n \tret\n ENDF __udivmodqi4\n@@ -1112,14 +1112,14 @@ __divmodhi4_exit:\n ENDF __divmodhi4\n #endif /* defined (L_divmodhi4) */\n \n-#undef r_remH  \n-#undef r_remL  \n-             \n-#undef r_arg1H \n-#undef r_arg1L \n-             \n-#undef r_arg2H \n-#undef r_arg2L \n+#undef r_remH\n+#undef r_remL\n+\n+#undef r_arg1H\n+#undef r_arg1L\n+\n+#undef r_arg2H\n+#undef r_arg2L\n              \t\n #undef r_cnt   \t\n \n@@ -1501,8 +1501,8 @@ DEFUN __udivmod64\n \n 1:  ;; Compare shifted Devidend against Divisor\n     ;; If -- even after Shifting -- it is smaller...\n-    CP  A7,B0  $  cpc C0,B1  $  cpc C1,B2  $  cpc C2,B3  \n-    cpc C3,B4  $  cpc C4,B5  $  cpc C5,B6  $  cpc C6,B7  \n+    CP  A7,B0  $  cpc C0,B1  $  cpc C1,B2  $  cpc C2,B3\n+    cpc C3,B4  $  cpc C4,B5  $  cpc C5,B6  $  cpc C6,B7\n     brcc    2f\n \n     ;; ...then we can subtract it.  Thus, it is legal to shift left\n@@ -1596,7 +1596,7 @@ DEFUN __udivmod64\n \n ENDF __udivmod64\n #endif /* L_udivmod64 */\n-    \n+\n \n #if defined (L_divdi3)\n \n@@ -1622,7 +1622,7 @@ DEFUN  __divdi3_moddi3\n     brmi    0f\n     ;; Both Signs are 0:  the following Complexitiy is not needed\n     XJMP    __udivdi3_umoddi3\n-#endif /* SPEED_DIV */    \n+#endif /* SPEED_DIV */\n \n 0:  ;; The Prologue\n     ;; Save 12 Registers:  Y, 17...8\n@@ -1645,7 +1645,7 @@ DEFUN  __divdi3_moddi3\n #else\n     brpl    21f\n #endif /* SPEED_DIV */\n-   \n+\n     XCALL   __negdi2\n \n     ;; Adjust Divisor's Sign and SS.7 as needed\n@@ -1809,7 +1809,7 @@ ENDF __negdi2\n \n \f\n .section .text.libgcc.prologue, \"ax\", @progbits\n-    \n+\n /**********************************\n  * This is a prologue subroutine\n  **********************************/\n@@ -1944,7 +1944,7 @@ _cleanup:\n \n \f\n .section .text.libgcc, \"ax\", @progbits\n-    \n+\n #ifdef L_tablejump\n DEFUN __tablejump2__\n \tlsl\tr30\n@@ -2146,7 +2146,7 @@ ENDF __do_global_dtors\n #endif /* L_dtors */\n \n .section .text.libgcc, \"ax\", @progbits\n-    \n+\n #ifdef L_tablejump_elpm\n DEFUN __tablejump_elpm__\n #if defined (__AVR_HAVE_ELPMX__)\n@@ -2484,7 +2484,7 @@ DEFUN __loop_ffsqi2\n     brcc __loop_ffsqi2\n     mov  r24, r26\n     clr  r25\n-    ret    \n+    ret\n ENDF __loop_ffsqi2\n #endif /* defined (L_loop_ffsqi2) */\n \n@@ -2586,7 +2586,7 @@ ENDF __clzhi2\n \n \f\n /**********************************\n- * Parity \n+ * Parity\n  **********************************/\n \n #if defined (L_paritydi2)\n@@ -2702,20 +2702,20 @@ ENDF __popcountdi2\n DEFUN __popcountqi2\n     mov  __tmp_reg__, r24\n     andi r24, 1\n-    lsr  __tmp_reg__    \n-    lsr  __tmp_reg__    \n+    lsr  __tmp_reg__\n+    lsr  __tmp_reg__\n     adc  r24, __zero_reg__\n-    lsr  __tmp_reg__    \n+    lsr  __tmp_reg__\n     adc  r24, __zero_reg__\n-    lsr  __tmp_reg__    \n+    lsr  __tmp_reg__\n     adc  r24, __zero_reg__\n-    lsr  __tmp_reg__    \n+    lsr  __tmp_reg__\n     adc  r24, __zero_reg__\n-    lsr  __tmp_reg__    \n+    lsr  __tmp_reg__\n     adc  r24, __zero_reg__\n-    lsr  __tmp_reg__    \n-    adc  r24, __tmp_reg__    \n-    ret    \n+    lsr  __tmp_reg__\n+    adc  r24, __tmp_reg__\n+    ret\n ENDF __popcountqi2\n #endif /* defined (L_popcountqi2) */\n \n@@ -2850,10 +2850,10 @@ ENDF __rotldi3\n \f\n .section .text.libgcc.fmul, \"ax\", @progbits\n \n-/***********************************************************/    \n+/***********************************************************/\n ;;; Softmul versions of FMUL, FMULS and FMULSU to implement\n ;;; __builtin_avr_fmul* if !AVR_HAVE_MUL\n-/***********************************************************/    \n+/***********************************************************/\n \n #define A1 24\n #define B1 25"}]}