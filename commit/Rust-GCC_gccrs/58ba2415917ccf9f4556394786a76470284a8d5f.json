{"sha": "58ba2415917ccf9f4556394786a76470284a8d5f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NThiYTI0MTU5MTdjY2Y5ZjQ1NTYzOTQ3ODZhNzY0NzAyODRhOGQ1Zg==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2016-04-18T12:18:16Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-18T12:18:16Z"}, "message": "par-ch2.adb (P_Expression_Or_Reserved_Word): New routine.\n\n2016-04-18  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* par-ch2.adb (P_Expression_Or_Reserved_Word): New routine.\n\t(P_Pragma): Signal Scan_Pragma_Argument_Association when the use\n\tof reserved words is OK.\n\t(Scan_Pragma_Argument_Association):\n\tAdd new formal Reserved_Words_OK and update the comment on\n\tusage. Code cleanup. Parse an expression or a reserved word in\n\tidentifier form for pragmas Restriction_Warnings and Restrictions\n\tNo_Use_Of_Attribute.\n\t* restrict.adb (Check_Restriction_No_Use_Of_Attribute):\n\tReimplemented.\t(Check_Restriction_No_Use_Of_Pragma): Code cleanup.\n\t(Set_Restriction_No_Specification_Of_Aspect): Properly set the warning\n\tflag for an aspect.\n\t(Set_Restriction_No_Use_Of_Attribute): Properly set the warning\n\tflag for an attribute.\t(Set_Restriction_No_Use_Of_Entity):\n\tUpdate the parameter profile.\n\t(Set_Restriction_No_Use_Of_Pragma): Properly set the warning flag for\n\ta pragma.\n\t* restrict.ads (Check_Restriction_No_Use_Of_Attribute): Update\n\tthe comment on usage.\n\t(Set_Restriction_No_Use_Of_Entity): Update the parameter profile.\n\t* sem_attr.adb (Analyze_Attribute): Check restriction\n\tNo_Use_Of_Attribute.\n\t* sem_ch13.adb (Analyze_Attribute_Definition_Clause): Check\n\trestriction No_Use_Of_Attribute before any rewritings have\n\ttaken place.\n\t* sem_prag.adb (Analyze_Pragma): Check restriction\n\tNo_Use_Of_Pragma before any rewritings have taken place.\n\nFrom-SVN: r235134", "tree": {"sha": "7e77e20fef7992846e861b1e6e5fd7ac34e740b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e77e20fef7992846e861b1e6e5fd7ac34e740b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58ba2415917ccf9f4556394786a76470284a8d5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58ba2415917ccf9f4556394786a76470284a8d5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58ba2415917ccf9f4556394786a76470284a8d5f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58ba2415917ccf9f4556394786a76470284a8d5f/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "95e01976cb7327298faf3c5692a2b209c6ab98c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95e01976cb7327298faf3c5692a2b209c6ab98c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95e01976cb7327298faf3c5692a2b209c6ab98c7"}], "stats": {"total": 460, "additions": 294, "deletions": 166}, "files": [{"sha": "071966487d474f1a8bc703751660543ce908f7c0", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58ba2415917ccf9f4556394786a76470284a8d5f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58ba2415917ccf9f4556394786a76470284a8d5f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=58ba2415917ccf9f4556394786a76470284a8d5f", "patch": "@@ -1,3 +1,33 @@\n+2016-04-18  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* par-ch2.adb (P_Expression_Or_Reserved_Word): New routine.\n+\t(P_Pragma): Signal Scan_Pragma_Argument_Association when the use\n+\tof reserved words is OK.\n+\t(Scan_Pragma_Argument_Association):\n+\tAdd new formal Reserved_Words_OK and update the comment on\n+\tusage. Code cleanup. Parse an expression or a reserved word in\n+\tidentifier form for pragmas Restriction_Warnings and Restrictions\n+\tNo_Use_Of_Attribute.\n+\t* restrict.adb (Check_Restriction_No_Use_Of_Attribute):\n+\tReimplemented.\t(Check_Restriction_No_Use_Of_Pragma): Code cleanup.\n+\t(Set_Restriction_No_Specification_Of_Aspect): Properly set the warning\n+\tflag for an aspect.\n+\t(Set_Restriction_No_Use_Of_Attribute): Properly set the warning\n+\tflag for an attribute.\t(Set_Restriction_No_Use_Of_Entity):\n+\tUpdate the parameter profile.\n+\t(Set_Restriction_No_Use_Of_Pragma): Properly set the warning flag for\n+\ta pragma.\n+\t* restrict.ads (Check_Restriction_No_Use_Of_Attribute): Update\n+\tthe comment on usage.\n+\t(Set_Restriction_No_Use_Of_Entity): Update the parameter profile.\n+\t* sem_attr.adb (Analyze_Attribute): Check restriction\n+\tNo_Use_Of_Attribute.\n+\t* sem_ch13.adb (Analyze_Attribute_Definition_Clause): Check\n+\trestriction No_Use_Of_Attribute before any rewritings have\n+\ttaken place.\n+\t* sem_prag.adb (Analyze_Pragma): Check restriction\n+\tNo_Use_Of_Pragma before any rewritings have taken place.\n+\n 2016-04-18  Bob Duff  <duff@adacore.com>\n \n \t* sem_ch6.adb (Is_Inline_Pragma): The pragma"}, {"sha": "0e1fc34c02c9e7f0a370824a73abfbded418e6b8", "filename": "gcc/ada/par-ch2.adb", "status": "modified", "additions": 103, "deletions": 22, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58ba2415917ccf9f4556394786a76470284a8d5f/gcc%2Fada%2Fpar-ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58ba2415917ccf9f4556394786a76470284a8d5f/gcc%2Fada%2Fpar-ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch2.adb?ref=58ba2415917ccf9f4556394786a76470284a8d5f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,13 +33,16 @@ package body Ch2 is\n    --  Local functions, used only in this chapter\n \n    procedure Scan_Pragma_Argument_Association\n-     (Identifier_Seen : in out Boolean;\n-      Association     : out Node_Id);\n-   --  Scans out a pragma argument association. Identifier_Seen is true on\n-   --  entry if a previous association had an identifier, and gets set True if\n-   --  the scanned association has an identifier (this is used to check the\n+     (Identifier_Seen   : in out Boolean;\n+      Association       : out Node_Id;\n+      Reserved_Words_OK : Boolean := False);\n+   --  Scans out a pragma argument association. Identifier_Seen is True on\n+   --  entry if a previous association had an identifier, and gets set True\n+   --  if the scanned association has an identifier (this is used to check the\n    --  rule that no associations without identifiers can follow an association\n-   --  which has an identifier). The result is returned in Association.\n+   --  which has an identifier). The result is returned in Association. Flag\n+   --  For_Pragma_Restrictions should be set when arguments are being parsed\n+   --  for pragma Restrictions.\n    --\n    --  Note: We allow attribute forms Pre'Class, Post'Class, Invariant'Class,\n    --  Type_Invariant'Class in place of a pragma argument identifier. Rather\n@@ -279,8 +282,8 @@ package body Ch2 is\n       if Ada_Version >= Ada_2005\n         and then Token = Tok_Interface\n       then\n-         Prag_Name := Name_Interface;\n-         Ident_Node  := Make_Identifier (Token_Ptr, Name_Interface);\n+         Prag_Name  := Name_Interface;\n+         Ident_Node := Make_Identifier (Token_Ptr, Name_Interface);\n          Scan; -- past INTERFACE\n       else\n          Ident_Node := P_Identifier;\n@@ -317,7 +320,13 @@ package body Ch2 is\n \n          loop\n             Arg_Count := Arg_Count + 1;\n-            Scan_Pragma_Argument_Association (Identifier_Seen, Assoc_Node);\n+\n+            Scan_Pragma_Argument_Association\n+              (Identifier_Seen   => Identifier_Seen,\n+               Association       => Assoc_Node,\n+               Reserved_Words_OK =>\n+                 Nam_In (Prag_Name, Name_Restriction_Warnings,\n+                                    Name_Restrictions));\n \n             if Arg_Count = 2\n               and then (Interface_Check_Required or else Import_Check_Required)\n@@ -476,17 +485,73 @@ package body Ch2 is\n    --  Error recovery: cannot raise Error_Resync\n \n    procedure Scan_Pragma_Argument_Association\n-     (Identifier_Seen : in out Boolean;\n-      Association     : out Node_Id)\n+     (Identifier_Seen   : in out Boolean;\n+      Association       : out Node_Id;\n+      Reserved_Words_OK : Boolean := False)\n    is\n-      Scan_State      : Saved_Scan_State;\n+      function P_Expression_Or_Reserved_Word return Node_Id;\n+      --  Parse an expression or if the token denotes one of the following\n+      --  reserved words, construct an identifier with proper Chars field.\n+      --    Access\n+      --    Delta\n+      --    Digits\n+      --    Mod\n+      --    Range\n+\n+      -----------------------------------\n+      -- P_Expression_Or_Reserved_Word --\n+      -----------------------------------\n+\n+      function P_Expression_Or_Reserved_Word return Node_Id is\n+         Word    : Node_Id;\n+         Word_Id : Name_Id;\n+\n+      begin\n+         Word_Id := No_Name;\n+\n+         if Token = Tok_Access then\n+            Word_Id := Name_Access;\n+            Scan; -- past ACCESS\n+\n+         elsif Token = Tok_Delta then\n+            Word_Id := Name_Delta;\n+            Scan; -- past DELTA\n+\n+         elsif Token = Tok_Digits then\n+            Word_Id := Name_Digits;\n+            Scan; -- past DIGITS\n+\n+         elsif Token = Tok_Mod then\n+            Word_Id := Name_Mod;\n+            Scan; -- past MOD\n+\n+         elsif Token = Tok_Range then\n+            Word_Id := Name_Range;\n+            Scan; -- post RANGE\n+         end if;\n+\n+         if Word_Id = No_Name then\n+            return P_Expression;\n+         else\n+            Word := New_Node (N_Identifier, Token_Ptr);\n+            Set_Chars (Word, Word_Id);\n+            return Word;\n+         end if;\n+      end P_Expression_Or_Reserved_Word;\n+\n+      --  Local variables\n+\n+      Expression_Node : Node_Id;\n       Identifier_Node : Node_Id;\n-      Id_Present      : Boolean;\n+      Identifier_OK   : Boolean;\n+      Scan_State      : Saved_Scan_State;\n+\n+   --  Start of processing for Scan_Pragma_Argument_Association\n \n    begin\n       Association := New_Node (N_Pragma_Argument_Association, Token_Ptr);\n       Set_Chars (Association, No_Name);\n-      Id_Present := False;\n+      Identifier_OK := False;\n \n       --  Argument starts with identifier\n \n@@ -497,7 +562,7 @@ package body Ch2 is\n \n          if Token = Tok_Arrow then\n             Scan; -- past arrow\n-            Id_Present := True;\n+            Identifier_OK := True;\n \n          --  Case of one of the special aspect forms\n \n@@ -520,7 +585,7 @@ package body Ch2 is\n                --  Here we have scanned identifier'Class =>\n \n                else\n-                  Id_Present := True;\n+                  Identifier_OK := True;\n                   Scan; -- past arrow\n \n                   case Chars (Identifier_Node) is\n@@ -550,7 +615,7 @@ package body Ch2 is\n \n          --  Identifier was present\n \n-         if Id_Present then\n+         if Identifier_OK then\n             Set_Chars (Association, Chars (Identifier_Node));\n             Identifier_Seen := True;\n \n@@ -569,16 +634,32 @@ package body Ch2 is\n       --  message in Relaxed_RM_Semantics mode to help legacy code using e.g.\n       --  codepeer.\n \n-      if Identifier_Seen and not Id_Present and not Relaxed_RM_Semantics then\n+      if Identifier_Seen\n+        and not Identifier_OK\n+        and not Relaxed_RM_Semantics\n+      then\n          Error_Msg_SC (\"|pragma argument identifier required here\");\n          Error_Msg_SC (\"\\since previous argument had identifier (RM 2.8(4))\");\n       end if;\n \n-      if Id_Present then\n-         Set_Expression (Association, P_Expression);\n+      if Identifier_OK then\n+\n+         --  Certain pragmas such as Restriction_Warninds and Restrictions\n+         --  allow reserved words to appear as expressions when checking for\n+         --  prohibited uses of attributes.\n+\n+         if Reserved_Words_OK\n+           and then Chars (Identifier_Node) = Name_No_Use_Of_Attribute\n+         then\n+            Expression_Node := P_Expression_Or_Reserved_Word;\n+         else\n+            Expression_Node := P_Expression;\n+         end if;\n       else\n-         Set_Expression (Association, P_Expression_If_OK);\n+         Expression_Node := P_Expression_If_OK;\n       end if;\n+\n+      Set_Expression (Association, Expression_Node);\n    end Scan_Pragma_Argument_Association;\n \n end Ch2;"}, {"sha": "f49f9d8e8fa7ffa4bcd1ec9dc6307006d141fd6c", "filename": "gcc/ada/restrict.adb", "status": "modified", "additions": 145, "deletions": 134, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58ba2415917ccf9f4556394786a76470284a8d5f/gcc%2Fada%2Frestrict.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58ba2415917ccf9f4556394786a76470284a8d5f/gcc%2Fada%2Frestrict.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frestrict.adb?ref=58ba2415917ccf9f4556394786a76470284a8d5f", "patch": "@@ -195,6 +195,15 @@ package body Restrict is\n       Check_Restriction (No_Elaboration_Code, N);\n    end Check_Elaboration_Code_Allowed;\n \n+   -----------------------------------------\n+   -- Check_Implicit_Dynamic_Code_Allowed --\n+   -----------------------------------------\n+\n+   procedure Check_Implicit_Dynamic_Code_Allowed (N : Node_Id) is\n+   begin\n+      Check_Restriction (No_Implicit_Dynamic_Code, N);\n+   end Check_Implicit_Dynamic_Code_Allowed;\n+\n    --------------------------------\n    -- Check_No_Implicit_Aliasing --\n    --------------------------------\n@@ -267,15 +276,6 @@ package body Restrict is\n       Check_Restriction (No_Implicit_Aliasing, Obj);\n    end Check_No_Implicit_Aliasing;\n \n-   -----------------------------------------\n-   -- Check_Implicit_Dynamic_Code_Allowed --\n-   -----------------------------------------\n-\n-   procedure Check_Implicit_Dynamic_Code_Allowed (N : Node_Id) is\n-   begin\n-      Check_Restriction (No_Implicit_Dynamic_Code, N);\n-   end Check_Implicit_Dynamic_Code_Allowed;\n-\n    ----------------------------------\n    -- Check_No_Implicit_Heap_Alloc --\n    ----------------------------------\n@@ -676,31 +676,44 @@ package body Restrict is\n    --------------------------------------------\n \n    procedure Check_Restriction_No_Use_Of_Attribute (N : Node_Id) is\n-      Id   : constant Name_Id      := Chars (N);\n-      A_Id : constant Attribute_Id := Get_Attribute_Id (Id);\n+      Attr_Id  : Attribute_Id;\n+      Attr_Nam : Name_Id;\n \n    begin\n-      --  Ignore call if node N is not in the main source unit, since we only\n-      --  give messages for the main unit. This avoids giving messages for\n-      --  aspects that are specified in withed units.\n+      --  Nothing to do if the attribute is not in the main source unit, since\n+      --  we only give messages for the main unit. This avoids giving messages\n+      --  for attributes that are specified in withed units.\n \n       if not In_Extended_Main_Source_Unit (N) then\n          return;\n-      end if;\n \n-      --  If nothing set, nothing to check\n+      --  Nothing to do if not checking No_Use_Of_Attribute\n+\n+      elsif not No_Use_Of_Attribute_Set then\n+         return;\n+\n+      --  Do not consider internally generated attributes because this leads to\n+      --  bizarre errors.\n \n-      if not No_Use_Of_Attribute_Set then\n+      elsif not Comes_From_Source (N) then\n          return;\n       end if;\n \n-      Error_Msg_Sloc := No_Use_Of_Attribute (A_Id);\n+      if Nkind (N) = N_Attribute_Definition_Clause then\n+         Attr_Nam := Chars (N);\n+      else\n+         pragma Assert (Nkind (N) = N_Attribute_Reference);\n+         Attr_Nam := Attribute_Name (N);\n+      end if;\n+\n+      Attr_Id        := Get_Attribute_Id (Attr_Nam);\n+      Error_Msg_Sloc := No_Use_Of_Attribute (Attr_Id);\n \n       if Error_Msg_Sloc /= No_Location then\n-         Error_Msg_Node_1 := N;\n-         Error_Msg_Warn := No_Use_Of_Attribute_Warning (A_Id);\n+         Error_Msg_Name_1 := Attr_Nam;\n+         Error_Msg_Warn   := No_Use_Of_Attribute_Warning (Attr_Id);\n          Error_Msg_N\n-           (\"<*<violation of restriction `No_Use_Of_Attribute '='> &`#\", N);\n+           (\"<*<violation of restriction `No_Use_Of_Attribute '='> %` #\", N);\n       end if;\n    end Check_Restriction_No_Use_Of_Attribute;\n \n@@ -723,10 +736,10 @@ package body Restrict is\n          return;\n       end if;\n \n-      --  Restriction is only recognized within a configuration\n-      --  pragma file, or within a unit of the main extended\n-      --  program. Note: the test for Main_Unit is needed to\n-      --  properly include the case of configuration pragma files.\n+      --  Restriction is only recognized within a configuration pragma file,\n+      --  or within a unit of the main extended program. Note: the test for\n+      --  Main_Unit is needed to properly include the case of configuration\n+      --  pragma files.\n \n       if Current_Sem_Unit /= Main_Unit\n         and then not In_Extended_Main_Source_Unit (N)\n@@ -805,30 +818,122 @@ package body Restrict is\n       P_Id : constant Pragma_Id := Get_Pragma_Id (Chars (Id));\n \n    begin\n-      --  Ignore call if node N is not in the main source unit, since we only\n-      --  give messages for the main unit. This avoids giving messages for\n-      --  aspects that are specified in withed units.\n+      --  Nothing to do if the pragma is not in the main source unit, since we\n+      --  only give messages for the main unit. This avoids giving messages for\n+      --  pragmas that are specified in withed units.\n \n       if not In_Extended_Main_Source_Unit (N) then\n          return;\n-      end if;\n \n-      --  If nothing set, nothing to check\n+      --  Nothing to do if not checking No_Use_Of_Pragma\n+\n+      elsif not No_Use_Of_Pragma_Set then\n+         return;\n+\n+      --  Do not consider internally generated pragmas because this leads to\n+      --  bizarre errors.\n \n-      if not No_Use_Of_Pragma_Set then\n+      elsif not Comes_From_Source (N) then\n          return;\n       end if;\n \n       Error_Msg_Sloc := No_Use_Of_Pragma (P_Id);\n \n       if Error_Msg_Sloc /= No_Location then\n-         Error_Msg_Node_1 := Id;\n          Error_Msg_Warn := No_Use_Of_Pragma_Warning (P_Id);\n          Error_Msg_N\n-           (\"<*<violation of restriction `No_Use_Of_Pragma '='> &`#\", Id);\n+           (\"<*<violation of restriction `No_Use_Of_Pragma '='> &` #\", Id);\n       end if;\n    end Check_Restriction_No_Use_Of_Pragma;\n \n+   --------------------------------\n+   -- Check_SPARK_05_Restriction --\n+   --------------------------------\n+\n+   procedure Check_SPARK_05_Restriction\n+     (Msg   : String;\n+      N     : Node_Id;\n+      Force : Boolean := False)\n+   is\n+      Msg_Issued          : Boolean;\n+      Save_Error_Msg_Sloc : Source_Ptr;\n+      Onode               : constant Node_Id := Original_Node (N);\n+\n+   begin\n+      --  Output message if Force set\n+\n+      if Force\n+\n+        --  Or if this node comes from source\n+\n+        or else Comes_From_Source (N)\n+\n+        --  Or if this is a range node which rewrites a range attribute and\n+        --  the range attribute comes from source.\n+\n+        or else (Nkind (N) = N_Range\n+                  and then Nkind (Onode) = N_Attribute_Reference\n+                  and then Attribute_Name (Onode) = Name_Range\n+                  and then Comes_From_Source (Onode))\n+\n+        --  Or this is an expression that does not come from source, which is\n+        --  a rewriting of an expression that does come from source.\n+\n+        or else (Nkind (N) in N_Subexpr and then Comes_From_Source (Onode))\n+      then\n+         if Restriction_Check_Required (SPARK_05)\n+           and then Is_In_Hidden_Part_In_SPARK (Sloc (N))\n+         then\n+            return;\n+         end if;\n+\n+         --  Since the call to Restriction_Msg from Check_Restriction may set\n+         --  Error_Msg_Sloc to the location of the pragma restriction, save and\n+         --  restore the previous value of the global variable around the call.\n+\n+         Save_Error_Msg_Sloc := Error_Msg_Sloc;\n+         Check_Restriction (Msg_Issued, SPARK_05, First_Node (N));\n+         Error_Msg_Sloc := Save_Error_Msg_Sloc;\n+\n+         if Msg_Issued then\n+            Error_Msg_F (\"\\\\| \" & Msg, N);\n+         end if;\n+      end if;\n+   end Check_SPARK_05_Restriction;\n+\n+   procedure Check_SPARK_05_Restriction\n+     (Msg1 : String;\n+      Msg2 : String;\n+      N    : Node_Id)\n+   is\n+      Msg_Issued          : Boolean;\n+      Save_Error_Msg_Sloc : Source_Ptr;\n+\n+   begin\n+      pragma Assert (Msg2'Length /= 0 and then Msg2 (Msg2'First) = '\\');\n+\n+      if Comes_From_Source (Original_Node (N)) then\n+         if Restriction_Check_Required (SPARK_05)\n+           and then Is_In_Hidden_Part_In_SPARK (Sloc (N))\n+         then\n+            return;\n+         end if;\n+\n+         --  Since the call to Restriction_Msg from Check_Restriction may set\n+         --  Error_Msg_Sloc to the location of the pragma restriction, save and\n+         --  restore the previous value of the global variable around the call.\n+\n+         Save_Error_Msg_Sloc := Error_Msg_Sloc;\n+         Check_Restriction (Msg_Issued, SPARK_05, First_Node (N));\n+         Error_Msg_Sloc := Save_Error_Msg_Sloc;\n+\n+         if Msg_Issued then\n+            Error_Msg_F (\"\\\\| \" & Msg1, N);\n+            Error_Msg_F (Msg2, N);\n+         end if;\n+      end if;\n+   end Check_SPARK_05_Restriction;\n+\n    --------------------------------------\n    -- Check_Wide_Character_Restriction --\n    --------------------------------------\n@@ -1527,7 +1632,7 @@ package body Restrict is\n \n    procedure Set_Restriction_No_Use_Of_Entity\n      (Entity  : Node_Id;\n-      Warn    : Boolean;\n+      Warning : Boolean;\n       Profile : Profile_Name := No_Profile)\n    is\n       Nam : Node_Id;\n@@ -1543,7 +1648,7 @@ package body Restrict is\n \n             --  Error has precedence over warning\n \n-            if not Warn then\n+            if not Warning then\n                No_Use_Of_Entity.Table (J).Warn := False;\n             end if;\n \n@@ -1553,7 +1658,7 @@ package body Restrict is\n \n       --  Entry is not currently in table\n \n-      No_Use_Of_Entity.Append ((Entity, Warn, Profile));\n+      No_Use_Of_Entity.Append ((Entity, Warning, Profile));\n \n       --  Now we need to find the direct name and set Boolean2 flag\n \n@@ -1580,13 +1685,9 @@ package body Restrict is\n       A_Id : constant Aspect_Id_Exclude_No_Aspect := Get_Aspect_Id (Chars (N));\n \n    begin\n-      No_Specification_Of_Aspects (A_Id) := Sloc (N);\n-\n-      if Warning = False then\n-         No_Specification_Of_Aspect_Warning (A_Id) := False;\n-      end if;\n-\n       No_Specification_Of_Aspect_Set := True;\n+      No_Specification_Of_Aspects (A_Id) := Sloc (N);\n+      No_Specification_Of_Aspect_Warning (A_Id) := Warning;\n    end Set_Restriction_No_Specification_Of_Aspect;\n \n    procedure Set_Restriction_No_Specification_Of_Aspect (A_Id : Aspect_Id) is\n@@ -1609,10 +1710,7 @@ package body Restrict is\n    begin\n       No_Use_Of_Attribute_Set := True;\n       No_Use_Of_Attribute (A_Id) := Sloc (N);\n-\n-      if Warning = False then\n-         No_Use_Of_Attribute_Warning (A_Id) := False;\n-      end if;\n+      No_Use_Of_Attribute_Warning (A_Id) := Warning;\n    end Set_Restriction_No_Use_Of_Attribute;\n \n    procedure Set_Restriction_No_Use_Of_Attribute (A_Id : Attribute_Id) is\n@@ -1635,10 +1733,7 @@ package body Restrict is\n    begin\n       No_Use_Of_Pragma_Set := True;\n       No_Use_Of_Pragma (A_Id) := Sloc (N);\n-\n-      if Warning = False then\n-         No_Use_Of_Pragma_Warning (A_Id) := False;\n-      end if;\n+      No_Use_Of_Pragma_Warning (A_Id) := Warning;\n    end Set_Restriction_No_Use_Of_Pragma;\n \n    procedure Set_Restriction_No_Use_Of_Pragma (A_Id : Pragma_Id) is\n@@ -1648,90 +1743,6 @@ package body Restrict is\n       No_Use_Of_Pragma_Warning (A_Id) := False;\n    end Set_Restriction_No_Use_Of_Pragma;\n \n-   --------------------------------\n-   -- Check_SPARK_05_Restriction --\n-   --------------------------------\n-\n-   procedure Check_SPARK_05_Restriction\n-     (Msg   : String;\n-      N     : Node_Id;\n-      Force : Boolean := False)\n-   is\n-      Msg_Issued          : Boolean;\n-      Save_Error_Msg_Sloc : Source_Ptr;\n-      Onode               : constant Node_Id := Original_Node (N);\n-\n-   begin\n-      --  Output message if Force set\n-\n-      if Force\n-\n-        --  Or if this node comes from source\n-\n-        or else Comes_From_Source (N)\n-\n-        --  Or if this is a range node which rewrites a range attribute and\n-        --  the range attribute comes from source.\n-\n-        or else (Nkind (N) = N_Range\n-                  and then Nkind (Onode) = N_Attribute_Reference\n-                  and then Attribute_Name (Onode) = Name_Range\n-                  and then Comes_From_Source (Onode))\n-\n-        --  Or this is an expression that does not come from source, which is\n-        --  a rewriting of an expression that does come from source.\n-\n-        or else (Nkind (N) in N_Subexpr and then Comes_From_Source (Onode))\n-      then\n-         if Restriction_Check_Required (SPARK_05)\n-           and then Is_In_Hidden_Part_In_SPARK (Sloc (N))\n-         then\n-            return;\n-         end if;\n-\n-         --  Since the call to Restriction_Msg from Check_Restriction may set\n-         --  Error_Msg_Sloc to the location of the pragma restriction, save and\n-         --  restore the previous value of the global variable around the call.\n-\n-         Save_Error_Msg_Sloc := Error_Msg_Sloc;\n-         Check_Restriction (Msg_Issued, SPARK_05, First_Node (N));\n-         Error_Msg_Sloc := Save_Error_Msg_Sloc;\n-\n-         if Msg_Issued then\n-            Error_Msg_F (\"\\\\| \" & Msg, N);\n-         end if;\n-      end if;\n-   end Check_SPARK_05_Restriction;\n-\n-   procedure Check_SPARK_05_Restriction (Msg1, Msg2 : String; N : Node_Id) is\n-      Msg_Issued          : Boolean;\n-      Save_Error_Msg_Sloc : Source_Ptr;\n-\n-   begin\n-      pragma Assert (Msg2'Length /= 0 and then Msg2 (Msg2'First) = '\\');\n-\n-      if Comes_From_Source (Original_Node (N)) then\n-         if Restriction_Check_Required (SPARK_05)\n-           and then Is_In_Hidden_Part_In_SPARK (Sloc (N))\n-         then\n-            return;\n-         end if;\n-\n-         --  Since the call to Restriction_Msg from Check_Restriction may set\n-         --  Error_Msg_Sloc to the location of the pragma restriction, save and\n-         --  restore the previous value of the global variable around the call.\n-\n-         Save_Error_Msg_Sloc := Error_Msg_Sloc;\n-         Check_Restriction (Msg_Issued, SPARK_05, First_Node (N));\n-         Error_Msg_Sloc := Save_Error_Msg_Sloc;\n-\n-         if Msg_Issued then\n-            Error_Msg_F (\"\\\\| \" & Msg1, N);\n-            Error_Msg_F (Msg2, N);\n-         end if;\n-      end if;\n-   end Check_SPARK_05_Restriction;\n-\n    ----------------------------------\n    -- Suppress_Restriction_Message --\n    ----------------------------------"}, {"sha": "3f05cd4f61766cb5a2c38fcadec49e536b7da354", "filename": "gcc/ada/restrict.ads", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58ba2415917ccf9f4556394786a76470284a8d5f/gcc%2Fada%2Frestrict.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58ba2415917ccf9f4556394786a76470284a8d5f/gcc%2Fada%2Frestrict.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frestrict.ads?ref=58ba2415917ccf9f4556394786a76470284a8d5f", "patch": "@@ -287,9 +287,9 @@ package Restrict is\n    --  for this aspect using Set_No_Specification_Of_Aspect.\n \n    procedure Check_Restriction_No_Use_Of_Attribute (N : Node_Id);\n-   --  N is the node of an attribute definition clause. An error message\n-   --  (warning) will be issued if a restriction (warning) was previously set\n-   --  for this attribute using Set_No_Use_Of_Attribute.\n+   --  N denotes an attribute definition clause or an attribute reference. An\n+   --  error message (warning) will be issued if a restriction (warning) was\n+   --  previously set for this attribute using Set_No_Use_Of_Attribute.\n \n    procedure Check_Restriction_No_Use_Of_Entity (N : Node_Id);\n    --  N is the node id for an entity reference. An error message (warning)\n@@ -316,7 +316,10 @@ package Restrict is\n    --  the SPARK_05 restriction is set, then an error is issued on N. Msg\n    --  is appended to the restriction failure message.\n \n-   procedure Check_SPARK_05_Restriction (Msg1, Msg2 : String; N : Node_Id);\n+   procedure Check_SPARK_05_Restriction\n+     (Msg1 : String;\n+      Msg2 : String;\n+      N    : Node_Id);\n    --  Same as Check_SPARK_05_Restriction except there is a continuation\n    --  message Msg2 following the initial message Msg1.\n \n@@ -490,7 +493,7 @@ package Restrict is\n \n    procedure Set_Restriction_No_Use_Of_Entity\n      (Entity  : Node_Id;\n-      Warn    : Boolean;\n+      Warning : Boolean;\n       Profile : Profile_Name := No_Profile);\n    --  Sets given No_Use_Of_Entity restriction in table if not there already.\n    --  Warn is True if from Restriction_Warnings, or for Restrictions if the"}, {"sha": "80a5aaa6bbaea919f589da33cc05a9a304a698ff", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58ba2415917ccf9f4556394786a76470284a8d5f/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58ba2415917ccf9f4556394786a76470284a8d5f/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=58ba2415917ccf9f4556394786a76470284a8d5f", "patch": "@@ -2624,13 +2624,15 @@ package body Sem_Attr is\n    --  Start of processing for Analyze_Attribute\n \n    begin\n-      --  Immediate return if unrecognized attribute (already diagnosed\n-      --  by parser, so there is nothing more that we need to do)\n+      --  Immediate return if unrecognized attribute (already diagnosed by\n+      --  parser, so there is nothing more that we need to do).\n \n       if not Is_Attribute_Name (Aname) then\n          raise Bad_Attribute;\n       end if;\n \n+      Check_Restriction_No_Use_Of_Attribute (N);\n+\n       --  Deal with Ada 83 issues\n \n       if Comes_From_Source (N) then"}, {"sha": "00ecfaae1d4673be5237ae30b0fde14a4eb5d960", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58ba2415917ccf9f4556394786a76470284a8d5f/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58ba2415917ccf9f4556394786a76470284a8d5f/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=58ba2415917ccf9f4556394786a76470284a8d5f", "patch": "@@ -4395,6 +4395,8 @@ package body Sem_Ch13 is\n          Set_Analyzed (N, True);\n       end if;\n \n+      Check_Restriction_No_Use_Of_Attribute (N);\n+\n       --  Ignore some selected attributes in CodePeer mode since they are not\n       --  relevant in this context.\n \n@@ -4580,7 +4582,6 @@ package body Sem_Ch13 is\n       end if;\n \n       Set_Entity (N, U_Ent);\n-      Check_Restriction_No_Use_Of_Attribute (N);\n \n       --  Switch on particular attribute\n "}, {"sha": "acf3f94d08c3744515c2925e090113129af03de6", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58ba2415917ccf9f4556394786a76470284a8d5f/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58ba2415917ccf9f4556394786a76470284a8d5f/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=58ba2415917ccf9f4556394786a76470284a8d5f", "patch": "@@ -10046,6 +10046,8 @@ package body Sem_Prag is\n          Set_Analyzed (N);\n       end if;\n \n+      Check_Restriction_No_Use_Of_Pragma (N);\n+\n       --  Deal with unrecognized pragma\n \n       Pname := Pragma_Name (N);\n@@ -10149,8 +10151,6 @@ package body Sem_Prag is\n          end if;\n       end if;\n \n-      Check_Restriction_No_Use_Of_Pragma (N);\n-\n       --  An enumeration type defines the pragmas that are supported by the\n       --  implementation. Get_Pragma_Id (in package Prag) transforms a name\n       --  into the corresponding enumeration value for the following case."}]}