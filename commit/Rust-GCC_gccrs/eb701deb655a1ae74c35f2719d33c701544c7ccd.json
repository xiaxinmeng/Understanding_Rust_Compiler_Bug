{"sha": "eb701deb655a1ae74c35f2719d33c701544c7ccd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWI3MDFkZWI2NTVhMWFlNzRjMzVmMjcxOWQzM2M3MDE1NDRjN2NjZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-01-11T21:33:14Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-01-11T21:33:14Z"}, "message": "re PR rtl-optimization/13366 (ICE using MMX/SSE builtins with -O)\n\n\tPR target/13366\n\t* config/i386/i386.h (enum ix86_builtins): Move ...\n\t* config/i386/i386.c: ... here.\n\t(IX86_BUILTIN_MOVDDUP, IX86_BUILTIN_MMX_ZERO, IX86_BUILTIN_PEXTRW,\n\tIX86_BUILTIN_PINSRW, IX86_BUILTIN_LOADAPS, IX86_BUILTIN_LOADSS,\n\tIX86_BUILTIN_STORESS, IX86_BUILTIN_SSE_ZERO, IX86_BUILTIN_PEXTRW128,\n\tIX86_BUILTIN_PINSRW128, IX86_BUILTIN_LOADAPD, IX86_BUILTIN_LOADSD,\n\tIX86_BUILTIN_STOREAPD, IX86_BUILTIN_STORESD,  IX86_BUILTIN_STOREHPD,\n\tIX86_BUILTIN_STORELPD, IX86_BUILTIN_SETPD1, IX86_BUILTIN_SETPD,\n\tIX86_BUILTIN_CLRPD, IX86_BUILTIN_LOADPD1, IX86_BUILTIN_LOADRPD,\n\tIX86_BUILTIN_STOREPD1, IX86_BUILTIN_STORERPD, IX86_BUILTIN_LOADDQA,\n\tIX86_BUILTIN_STOREDQA, IX86_BUILTIN_CLRTI,\n\tIX86_BUILTIN_LOADDDUP): Remove.\n\t(IX86_BUILTIN_VEC_INIT_V2SI, IX86_BUILTIN_VEC_INIT_V4HI,\n\tIX86_BUILTIN_VEC_INIT_V8QI, IX86_BUILTIN_VEC_EXT_V2DF,\n\tIX86_BUILTIN_VEC_EXT_V2DI, IX86_BUILTIN_VEC_EXT_V4SF,\n\tIX86_BUILTIN_VEC_EXT_V8HI, IX86_BUILTIN_VEC_EXT_V4HI,\n\tIX86_BUILTIN_VEC_SET_V8HI, IX86_BUILTIN_VEC_SET_V4HI): New.\n\t(ix86_init_builtins): Make static.\n\t(ix86_init_mmx_sse_builtins): Update for changed builtins.\n\t(ix86_expand_binop_builtin): Only use ix86_fixup_binary_operands\n\tif all the modes match.  Otherwise, fake it.\n\t(get_element_number, ix86_expand_vec_init_builtin,\n\tix86_expand_vec_ext_builtin, ix86_expand_vec_set_builtin): New.\n\t(ix86_expand_builtin): Make static.  Update for changed builtins.\n\t(ix86_expand_vector_move_misalign): Use sse2_loadlpd with zero\n\toperand instead of sse2_loadsd.  Cast sse1 fallback to V4SFmode.\n\t(ix86_expand_vector_init_duplicate): New.\n\t(ix86_expand_vector_init_low_nonzero): New.\n\t(ix86_expand_vector_init_one_var, ix86_expand_vector_init_general):\n\tSplit out from ix86_expand_vector_init; handle integer modes.\n\t(ix86_expand_vector_init): Use them.\n\t(ix86_expand_vector_set, ix86_expand_vector_extract): New.\n\t* config/i386/i386-protos.h: Update.\n\t* config/i386/predicates.md (reg_or_0_operand): New.\n\t* config/i386/mmx.md (mov<MMXMODEI>_internal): Add 'r' variants.\n\t(movv2sf_internal): Likewise.  And a splitter to match them all.\n\t(vec_dupv2sf, mmx_concatv2sf, vec_setv2sf, vec_extractv2sf,\n\tvec_initv2sf, vec_dupv4hi, vec_dupv2si, mmx_concatv2si, vec_setv2si,\n\tvec_extractv2si, vec_initv2si, vec_setv4hi, vec_extractv4hi,\n\tvec_initv4hi, vec_setv8qi, vec_extractv8qi, vec_initv8qi): New.\n\t(mmx_pinsrw): Fix operand ordering.\n\t* config/i386/sse.md (movv4sf splitter): Use direct pattern,\n\trather than sse_loadss expander.\n\t(movv2df splitter): Similarly.\n\t(sse_loadss, sse_loadlss): Remove.\n\t(vec_dupv4sf, sse_concatv2sf, sse_concatv4sf, vec_extractv4sf_0): New.\n\t(vec_setv4sf, vec_setv2df): Use ix86_expand_vector_set.\n\t(vec_extractv4sf, vec_extractv2df): Use ix86_expand_vector_extract.\n\t(sse3_movddup): Rename with '*'.\n\t(sse3_movddup splitter): Use gen_rtx_REG instead of gen_lowpart.\n\t(sse2_loadsd): Remove.\n\t(vec_dupv2df_sse3): Rename from sse3_loadddup.\n\t(vec_dupv2df, vec_concatv2df_sse3, vec_concatv2df): New.\n\t(sse2_pinsrw): Fix argument ordering.\n\t(sse2_loadld, sse2_loadq): Add sse1 alternatives.\n\t(sse2_stored): Remove 'r' destination.\n\t(vec_dupv4si, vec_dupv2di, sse2_concatv2si, sse1_concatv2si,\n\tvec_concatv4si_1, vec_concatv2di, vec_setv2di, vec_extractv2di,\n\tvec_initv2di, vec_setv4si, vec_extractv4si, vec_initv4si,\n\tvec_setv8hi, vec_extractv8hi, vec_initv8hi, vec_setv16qi,\n\tvec_extractv16qi, vec_initv16qi): New.\n\n\t* config/i386/emmintrin.h (__m128i, __m128d): Use typedef, not define.\n\t(_mm_set_sd, _mm_set1_pd, _mm_setzero_pd, _mm_set_epi64x,\n\t_mm_set_epi32, _mm_set_epi16, _mm_set_epi8, _mm_setzero_si128): Use\n\tconstructor form.\n\t(_mm_load_pd, _mm_store_pd): Use plain dereference.\n\t(_mm_load_si128, _mm_store_si128): Likewise.\n\t(_mm_load1_pd): Use _mm_set1_pd.\n\t(_mm_load_sd): Use _mm_set_sd.\n\t(_mm_store_sd, _mm_storeh_pd): Use __builtin_ia32_vec_ext_v2df.\n\t(_mm_store1_pd, _mm_storer_pd): Use _mm_store_pd.\n\t(_mm_set_epi64): Use _mm_set_epi64x.\n\t(_mm_set1_epi64x, _mm_set1_epi64, _mm_set1_epi32, _mm_set_epi16,\n\t_mm_set1_epi8, _mm_setr_epi64, _mm_setr_epi32, _mm_setr_epi16,\n\t_mm_setr_epi8): Use _mm_set_foo form.\n\t(_mm_loadl_epi64, _mm_movpi64_epi64, _mm_move_epi64): Use _mm_set_epi64.\n\t(_mm_storel_epi64, _mm_movepi64_pi64): Use __builtin_ia32_vec_ext_v2di.\n\t(_mm_extract_epi16): Use __builtin_ia32_vec_ext_v8hi.\n\t(_mm_insert_epi16): Use __builtin_ia32_vec_set_v8hi.\n\t* config/i386/mmintrin.h (_mm_setzero_si64): Use plain cast.\n\t(_mm_set_pi32): Use __builtin_ia32_vec_init_v2si.\n\t(_mm_set_pi16): Use __builtin_ia32_vec_init_v4hi.\n\t(_mm_set_pi8): Use __builtin_ia32_vec_init_v8qi.\n\t(_mm_set1_pi16, _mm_set1_pi8): Use _mm_set_piN variant.\n\t* config/i386/pmmintrin.h (_mm_loaddup_pd): Use _mm_load1_pd.\n\t(_mm_movedup_pd): Use _mm_shuffle_pd.\n\t* config/i386/xmmintrin.h (_mm_setzero_ps, _mm_set_ss,\n\t_mm_set1_ps, _mm_set_ps, _mm_setr_ps): Use constructor form.\n\t(_mm_cvtpi16_ps, _mm_cvtpu16_ps, _mm_cvtpi8_ps, _mm_cvtpu8_ps,\n\t_mm_cvtps_pi8, _mm_cvtpi32x2_ps): Avoid __builtin_ia32_mmx_zero;\n\tUse _mm_setzero_ps.\n\t(_mm_load_ss, _mm_load1_ps): Use _mm_set* form.\n\t(_mm_load_ps, _mm_loadr_ps): Use raw dereference.\n\t(_mm_store_ss): Use __builtin_ia32_vec_ext_v4sf.\n\t(_mm_store_ps): Use raw dereference.\n\t(_mm_store1_ps): Use _mm_storeu_ps.\n\t(_mm_storer_ps): Use _mm_store_ps.\n\t(_mm_extract_pi16): Use __builtin_ia32_vec_ext_v4hi.\n\t(_mm_insert_pi16): Use __builtin_ia32_vec_set_v4hi.\n\nFrom-SVN: r93199", "tree": {"sha": "41dfb70d2dcb0969d9a1eb218ace89a7d8b7331b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41dfb70d2dcb0969d9a1eb218ace89a7d8b7331b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb701deb655a1ae74c35f2719d33c701544c7ccd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb701deb655a1ae74c35f2719d33c701544c7ccd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb701deb655a1ae74c35f2719d33c701544c7ccd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb701deb655a1ae74c35f2719d33c701544c7ccd/comments", "author": null, "committer": null, "parents": [{"sha": "d9e4e4f5c7d21a023980292a3f967ecdb4775f4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9e4e4f5c7d21a023980292a3f967ecdb4775f4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9e4e4f5c7d21a023980292a3f967ecdb4775f4d"}], "stats": {"total": 3593, "additions": 2249, "deletions": 1344}, "files": [{"sha": "d57a3b059eb20ae33035bc91bc7349ae50630623", "filename": "gcc/ChangeLog", "status": "modified", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb701deb655a1ae74c35f2719d33c701544c7ccd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb701deb655a1ae74c35f2719d33c701544c7ccd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eb701deb655a1ae74c35f2719d33c701544c7ccd", "patch": "@@ -1,3 +1,107 @@\n+2005-01-11  Richard Henderson  <rth@redhat.com>\n+\n+\tPR target/13366\n+\t* config/i386/i386.h (enum ix86_builtins): Move ...\n+\t* config/i386/i386.c: ... here.\n+\t(IX86_BUILTIN_MOVDDUP, IX86_BUILTIN_MMX_ZERO, IX86_BUILTIN_PEXTRW,\n+\tIX86_BUILTIN_PINSRW, IX86_BUILTIN_LOADAPS, IX86_BUILTIN_LOADSS,\n+\tIX86_BUILTIN_STORESS, IX86_BUILTIN_SSE_ZERO, IX86_BUILTIN_PEXTRW128,\n+\tIX86_BUILTIN_PINSRW128, IX86_BUILTIN_LOADAPD, IX86_BUILTIN_LOADSD,\n+\tIX86_BUILTIN_STOREAPD, IX86_BUILTIN_STORESD,  IX86_BUILTIN_STOREHPD,\n+\tIX86_BUILTIN_STORELPD, IX86_BUILTIN_SETPD1, IX86_BUILTIN_SETPD,\n+\tIX86_BUILTIN_CLRPD, IX86_BUILTIN_LOADPD1, IX86_BUILTIN_LOADRPD,\n+\tIX86_BUILTIN_STOREPD1, IX86_BUILTIN_STORERPD, IX86_BUILTIN_LOADDQA,\n+\tIX86_BUILTIN_STOREDQA, IX86_BUILTIN_CLRTI,\n+\tIX86_BUILTIN_LOADDDUP): Remove.\n+\t(IX86_BUILTIN_VEC_INIT_V2SI, IX86_BUILTIN_VEC_INIT_V4HI,\n+\tIX86_BUILTIN_VEC_INIT_V8QI, IX86_BUILTIN_VEC_EXT_V2DF,\n+\tIX86_BUILTIN_VEC_EXT_V2DI, IX86_BUILTIN_VEC_EXT_V4SF,\n+\tIX86_BUILTIN_VEC_EXT_V8HI, IX86_BUILTIN_VEC_EXT_V4HI,\n+\tIX86_BUILTIN_VEC_SET_V8HI, IX86_BUILTIN_VEC_SET_V4HI): New.\n+\t(ix86_init_builtins): Make static.\n+\t(ix86_init_mmx_sse_builtins): Update for changed builtins.\n+\t(ix86_expand_binop_builtin): Only use ix86_fixup_binary_operands\n+\tif all the modes match.  Otherwise, fake it.\n+\t(get_element_number, ix86_expand_vec_init_builtin,\n+\tix86_expand_vec_ext_builtin, ix86_expand_vec_set_builtin): New.\n+\t(ix86_expand_builtin): Make static.  Update for changed builtins.\n+\t(ix86_expand_vector_move_misalign): Use sse2_loadlpd with zero\n+\toperand instead of sse2_loadsd.  Cast sse1 fallback to V4SFmode.\n+\t(ix86_expand_vector_init_duplicate): New.\n+\t(ix86_expand_vector_init_low_nonzero): New.\n+\t(ix86_expand_vector_init_one_var, ix86_expand_vector_init_general):\n+\tSplit out from ix86_expand_vector_init; handle integer modes.\n+\t(ix86_expand_vector_init): Use them.\n+\t(ix86_expand_vector_set, ix86_expand_vector_extract): New.\n+\t* config/i386/i386-protos.h: Update.\n+\t* config/i386/predicates.md (reg_or_0_operand): New.\n+\t* config/i386/mmx.md (mov<MMXMODEI>_internal): Add 'r' variants.\n+\t(movv2sf_internal): Likewise.  And a splitter to match them all.\n+\t(vec_dupv2sf, mmx_concatv2sf, vec_setv2sf, vec_extractv2sf,\n+\tvec_initv2sf, vec_dupv4hi, vec_dupv2si, mmx_concatv2si, vec_setv2si,\n+\tvec_extractv2si, vec_initv2si, vec_setv4hi, vec_extractv4hi,\n+\tvec_initv4hi, vec_setv8qi, vec_extractv8qi, vec_initv8qi): New.\n+\t(mmx_pinsrw): Fix operand ordering.\n+\t* config/i386/sse.md (movv4sf splitter): Use direct pattern,\n+\trather than sse_loadss expander.\n+\t(movv2df splitter): Similarly.\n+\t(sse_loadss, sse_loadlss): Remove.\n+\t(vec_dupv4sf, sse_concatv2sf, sse_concatv4sf, vec_extractv4sf_0): New.\n+\t(vec_setv4sf, vec_setv2df): Use ix86_expand_vector_set.\n+\t(vec_extractv4sf, vec_extractv2df): Use ix86_expand_vector_extract.\n+\t(sse3_movddup): Rename with '*'.\n+\t(sse3_movddup splitter): Use gen_rtx_REG instead of gen_lowpart.\n+\t(sse2_loadsd): Remove.\n+\t(vec_dupv2df_sse3): Rename from sse3_loadddup.\n+\t(vec_dupv2df, vec_concatv2df_sse3, vec_concatv2df): New.\n+\t(sse2_pinsrw): Fix argument ordering.\n+\t(sse2_loadld, sse2_loadq): Add sse1 alternatives.\n+\t(sse2_stored): Remove 'r' destination.\n+\t(vec_dupv4si, vec_dupv2di, sse2_concatv2si, sse1_concatv2si,\n+\tvec_concatv4si_1, vec_concatv2di, vec_setv2di, vec_extractv2di,\n+\tvec_initv2di, vec_setv4si, vec_extractv4si, vec_initv4si,\n+\tvec_setv8hi, vec_extractv8hi, vec_initv8hi, vec_setv16qi,\n+\tvec_extractv16qi, vec_initv16qi): New.\n+\n+\t* config/i386/emmintrin.h (__m128i, __m128d): Use typedef, not define.\n+\t(_mm_set_sd, _mm_set1_pd, _mm_setzero_pd, _mm_set_epi64x, \n+\t_mm_set_epi32, _mm_set_epi16, _mm_set_epi8, _mm_setzero_si128): Use\n+\tconstructor form.\n+\t(_mm_load_pd, _mm_store_pd): Use plain dereference.\n+\t(_mm_load_si128, _mm_store_si128): Likewise.\n+\t(_mm_load1_pd): Use _mm_set1_pd.\n+\t(_mm_load_sd): Use _mm_set_sd.\n+\t(_mm_store_sd, _mm_storeh_pd): Use __builtin_ia32_vec_ext_v2df.\n+\t(_mm_store1_pd, _mm_storer_pd): Use _mm_store_pd.\n+\t(_mm_set_epi64): Use _mm_set_epi64x.\n+\t(_mm_set1_epi64x, _mm_set1_epi64, _mm_set1_epi32, _mm_set_epi16,\n+\t_mm_set1_epi8, _mm_setr_epi64, _mm_setr_epi32, _mm_setr_epi16,\n+\t_mm_setr_epi8): Use _mm_set_foo form.\n+\t(_mm_loadl_epi64, _mm_movpi64_epi64, _mm_move_epi64): Use _mm_set_epi64.\n+\t(_mm_storel_epi64, _mm_movepi64_pi64): Use __builtin_ia32_vec_ext_v2di.\n+\t(_mm_extract_epi16): Use __builtin_ia32_vec_ext_v8hi.\n+\t(_mm_insert_epi16): Use __builtin_ia32_vec_set_v8hi.\n+\t* config/i386/mmintrin.h (_mm_setzero_si64): Use plain cast.\n+\t(_mm_set_pi32): Use __builtin_ia32_vec_init_v2si.\n+\t(_mm_set_pi16): Use __builtin_ia32_vec_init_v4hi.\n+\t(_mm_set_pi8): Use __builtin_ia32_vec_init_v8qi.\n+\t(_mm_set1_pi16, _mm_set1_pi8): Use _mm_set_piN variant.\n+\t* config/i386/pmmintrin.h (_mm_loaddup_pd): Use _mm_load1_pd.\n+\t(_mm_movedup_pd): Use _mm_shuffle_pd.\n+\t* config/i386/xmmintrin.h (_mm_setzero_ps, _mm_set_ss,\n+\t_mm_set1_ps, _mm_set_ps, _mm_setr_ps): Use constructor form.\n+\t(_mm_cvtpi16_ps, _mm_cvtpu16_ps, _mm_cvtpi8_ps, _mm_cvtpu8_ps,\n+\t_mm_cvtps_pi8, _mm_cvtpi32x2_ps): Avoid __builtin_ia32_mmx_zero;\n+\tUse _mm_setzero_ps.\n+\t(_mm_load_ss, _mm_load1_ps): Use _mm_set* form.\n+\t(_mm_load_ps, _mm_loadr_ps): Use raw dereference.\n+\t(_mm_store_ss): Use __builtin_ia32_vec_ext_v4sf.\n+\t(_mm_store_ps): Use raw dereference.\n+\t(_mm_store1_ps): Use _mm_storeu_ps.\n+\t(_mm_storer_ps): Use _mm_store_ps.\n+\t(_mm_extract_pi16): Use __builtin_ia32_vec_ext_v4hi.\n+\t(_mm_insert_pi16): Use __builtin_ia32_vec_set_v4hi.\n+\n 2005-01-11  Stan Shebs  <shebs@apple.com>\n \n \t* config/rs6000/rs6000.c (machopic_output_stub): Issue"}, {"sha": "aa7b25e750426c6d0368430e33ee8340ecc1d518", "filename": "gcc/config/i386/emmintrin.h", "status": "modified", "additions": 169, "deletions": 270, "changes": 439, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb701deb655a1ae74c35f2719d33c701544c7ccd/gcc%2Fconfig%2Fi386%2Femmintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb701deb655a1ae74c35f2719d33c701544c7ccd/gcc%2Fconfig%2Fi386%2Femmintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Femmintrin.h?ref=eb701deb655a1ae74c35f2719d33c701544c7ccd", "patch": "@@ -40,141 +40,156 @@ typedef int __v4si __attribute__ ((__vector_size__ (16)));\n typedef short __v8hi __attribute__ ((__vector_size__ (16)));\n typedef char __v16qi __attribute__ ((__vector_size__ (16)));\n \n+typedef __v2di __m128i;\n+typedef __v2df __m128d;\n+\n /* Create a selector for use with the SHUFPD instruction.  */\n #define _MM_SHUFFLE2(fp1,fp0) \\\n  (((fp1) << 1) | (fp0))\n \n-#define __m128i __v2di\n-#define __m128d __v2df\n+/* Create a vector with element 0 as F and the rest zero.  */\n+static __inline __m128d\n+_mm_set_sd (double __F)\n+{\n+  return (__m128d){ __F, 0 };\n+}\n \n-/* Create a vector with element 0 as *P and the rest zero.  */\n+/* Create a vector with both elements equal to F.  */\n static __inline __m128d\n-_mm_load_sd (double const *__P)\n+_mm_set1_pd (double __F)\n {\n-  return (__m128d) __builtin_ia32_loadsd (__P);\n+  return (__m128d){ __F, __F };\n }\n \n-/* Create a vector with all two elements equal to *P.  */\n static __inline __m128d\n-_mm_load1_pd (double const *__P)\n+_mm_set_pd1 (double __F)\n {\n-  __v2df __tmp = __builtin_ia32_loadsd (__P);\n-  return (__m128d) __builtin_ia32_shufpd (__tmp, __tmp, _MM_SHUFFLE2 (0,0));\n+  return _mm_set1_pd (__F);\n }\n \n+/* Create a vector with the lower value X and upper value W.  */\n static __inline __m128d\n-_mm_load_pd1 (double const *__P)\n+_mm_set_pd (double __W, double __X)\n {\n-  return _mm_load1_pd (__P);\n+  return (__m128d){ __X, __W };\n }\n \n-/* Load two DPFP values from P.  The address must be 16-byte aligned.  */\n+/* Create a vector with the lower value W and upper value X.  */\n static __inline __m128d\n-_mm_load_pd (double const *__P)\n+_mm_setr_pd (double __W, double __X)\n {\n-  return (__m128d) __builtin_ia32_loadapd (__P);\n+  return (__m128d){ __W, __X };\n }\n \n-/* Load two DPFP values from P.  The address need not be 16-byte aligned.  */\n+/* Create a vector of zeros.  */\n static __inline __m128d\n-_mm_loadu_pd (double const *__P)\n+_mm_setzero_pd (void)\n {\n-  return (__m128d) __builtin_ia32_loadupd (__P);\n+  return (__m128d){ 0.0, 0.0 };\n }\n \n-/* Load two DPFP values in reverse order.  The address must be aligned.  */\n+/* Sets the low DPFP value of A from the low value of B.  */\n static __inline __m128d\n-_mm_loadr_pd (double const *__P)\n+_mm_move_sd (__m128d __A, __m128d __B)\n {\n-  __v2df __tmp = __builtin_ia32_loadapd (__P);\n-  return (__m128d) __builtin_ia32_shufpd (__tmp, __tmp, _MM_SHUFFLE2 (0,1));\n+  return (__m128d) __builtin_ia32_movsd ((__v2df)__A, (__v2df)__B);\n }\n \n-/* Create a vector with element 0 as F and the rest zero.  */\n+/* Load two DPFP values from P.  The address must be 16-byte aligned.  */\n static __inline __m128d\n-_mm_set_sd (double __F)\n+_mm_load_pd (double const *__P)\n {\n-  return (__m128d) __builtin_ia32_loadsd (&__F);\n+  return *(__m128d *)__P;\n }\n \n-/* Create a vector with all two elements equal to F.  */\n+/* Load two DPFP values from P.  The address need not be 16-byte aligned.  */\n static __inline __m128d\n-_mm_set1_pd (double __F)\n+_mm_loadu_pd (double const *__P)\n {\n-  __v2df __tmp = __builtin_ia32_loadsd (&__F);\n-  return (__m128d) __builtin_ia32_shufpd (__tmp, __tmp, _MM_SHUFFLE2 (0,0));\n+  return __builtin_ia32_loadupd (__P);\n }\n \n+/* Create a vector with all two elements equal to *P.  */\n static __inline __m128d\n-_mm_set_pd1 (double __F)\n+_mm_load1_pd (double const *__P)\n {\n-  return _mm_set1_pd (__F);\n+  return _mm_set1_pd (*__P);\n }\n \n-/* Create the vector [Z Y].  */\n+/* Create a vector with element 0 as *P and the rest zero.  */\n static __inline __m128d\n-_mm_set_pd (double __Z, double __Y)\n+_mm_load_sd (double const *__P)\n {\n-  return (__v2df) {__Y, __Z};\n+  return _mm_set_sd (*__P);\n }\n \n-/* Create the vector [Y Z].  */\n static __inline __m128d\n-_mm_setr_pd (double __Z, double __Y)\n+_mm_load_pd1 (double const *__P)\n {\n-  return _mm_set_pd (__Y, __Z);\n+  return _mm_load1_pd (__P);\n }\n \n-/* Create a vector of zeros.  */\n+/* Load two DPFP values in reverse order.  The address must be aligned.  */\n static __inline __m128d\n-_mm_setzero_pd (void)\n+_mm_loadr_pd (double const *__P)\n {\n-  return (__m128d) __builtin_ia32_setzeropd ();\n+  __m128d __tmp = _mm_load_pd (__P);\n+  return __builtin_ia32_shufpd (__tmp, __tmp, _MM_SHUFFLE2 (0,1));\n+}\n+\n+/* Store two DPFP values.  The address must be 16-byte aligned.  */\n+static __inline void\n+_mm_store_pd (double *__P, __m128d __A)\n+{\n+  *(__m128d *)__P = __A;\n+}\n+\n+/* Store two DPFP values.  The address need not be 16-byte aligned.  */\n+static __inline void\n+_mm_storeu_pd (double *__P, __m128d __A)\n+{\n+  __builtin_ia32_storeupd (__P, __A);\n }\n \n /* Stores the lower DPFP value.  */\n static __inline void\n _mm_store_sd (double *__P, __m128d __A)\n {\n-  __builtin_ia32_storesd (__P, (__v2df)__A);\n+  *__P = __builtin_ia32_vec_ext_v2df (__A, 0);\n }\n \n-/* Store the lower DPFP value across two words.  */\n static __inline void\n-_mm_store1_pd (double *__P, __m128d __A)\n+_mm_storel_pd (double *__P, __m128d __A)\n {\n-  __v2df __va = (__v2df)__A;\n-  __v2df __tmp = __builtin_ia32_shufpd (__va, __va, _MM_SHUFFLE2 (0,0));\n-  __builtin_ia32_storeapd (__P, __tmp);\n+  _mm_store_sd (__P, __A);\n }\n \n+/* Stores the upper DPFP value.  */\n static __inline void\n-_mm_store_pd1 (double *__P, __m128d __A)\n+_mm_storeh_pd (double *__P, __m128d __A)\n {\n-  _mm_store1_pd (__P, __A);\n+  *__P = __builtin_ia32_vec_ext_v2df (__A, 1);\n }\n \n-/* Store two DPFP values.  The address must be 16-byte aligned.  */\n+/* Store the lower DPFP value across two words.\n+   The address must be 16-byte aligned.  */\n static __inline void\n-_mm_store_pd (double *__P, __m128d __A)\n+_mm_store1_pd (double *__P, __m128d __A)\n {\n-  __builtin_ia32_storeapd (__P, (__v2df)__A);\n+  _mm_store_pd (__P, __builtin_ia32_shufpd (__A, __A, _MM_SHUFFLE2 (0,0)));\n }\n \n-/* Store two DPFP values.  The address need not be 16-byte aligned.  */\n static __inline void\n-_mm_storeu_pd (double *__P, __m128d __A)\n+_mm_store_pd1 (double *__P, __m128d __A)\n {\n-  __builtin_ia32_storeupd (__P, (__v2df)__A);\n+  _mm_store1_pd (__P, __A);\n }\n \n /* Store two DPFP values in reverse order.  The address must be aligned.  */\n static __inline void\n _mm_storer_pd (double *__P, __m128d __A)\n {\n-  __v2df __va = (__v2df)__A;\n-  __v2df __tmp = __builtin_ia32_shufpd (__va, __va, _MM_SHUFFLE2 (0,1));\n-  __builtin_ia32_storeapd (__P, __tmp);\n+  _mm_store_pd (__P, __builtin_ia32_shufpd (__A, __A, _MM_SHUFFLE2 (0,1)));\n }\n \n static __inline int\n@@ -193,13 +208,6 @@ _mm_cvtsi128_si64x (__m128i __A)\n }\n #endif\n \n-/* Sets the low DPFP value of A from the low value of B.  */\n-static __inline __m128d\n-_mm_move_sd (__m128d __A, __m128d __B)\n-{\n-  return (__m128d) __builtin_ia32_movsd ((__v2df)__A, (__v2df)__B);\n-}\n-\n \n static __inline __m128d\n _mm_add_pd (__m128d __A, __m128d __B)\n@@ -543,277 +551,171 @@ _mm_ucomineq_sd (__m128d __A, __m128d __B)\n   return __builtin_ia32_ucomisdneq ((__v2df)__A, (__v2df)__B);\n }\n \n-/* Create a vector with element 0 as *P and the rest zero.  */\n+/* Create a vector of Qi, where i is the element number.  */\n \n static __inline __m128i\n-_mm_load_si128 (__m128i const *__P)\n+_mm_set_epi64x (long long __q1, long long __q0)\n {\n-  return (__m128i) __builtin_ia32_loaddqa ((char const *)__P);\n+  return (__m128i)(__v2di){ __q0, __q1 };\n }\n \n static __inline __m128i\n-_mm_loadu_si128 (__m128i const *__P)\n+_mm_set_epi64 (__m64 __q1,  __m64 __q0)\n {\n-  return (__m128i) __builtin_ia32_loaddqu ((char const *)__P);\n+  return _mm_set_epi64x ((long long)__q1, (long long)__q0);\n }\n \n static __inline __m128i\n-_mm_loadl_epi64 (__m128i const *__P)\n+_mm_set_epi32 (int __q3, int __q2, int __q1, int __q0)\n {\n-  return (__m128i) __builtin_ia32_movq2dq (*(unsigned long long *)__P);\n+  return (__m128i)(__v4si){ __q0, __q1, __q2, __q3 };\n }\n \n-static __inline void\n-_mm_store_si128 (__m128i *__P, __m128i __B)\n+static __inline __m128i\n+_mm_set_epi16 (short __q7, short __q6, short __q5, short __q4,\n+\t       short __q3, short __q2, short __q1, short __q0)\n {\n-  __builtin_ia32_storedqa ((char *)__P, (__v16qi)__B);\n+  return (__m128i)(__v8hi){ __q0, __q1, __q2, __q3, __q4, __q5, __q6, __q7 };\n }\n \n-static __inline void\n-_mm_storeu_si128 (__m128i *__P, __m128i __B)\n+static __inline __m128i\n+_mm_set_epi8 (char __q15, char __q14, char __q13, char __q12,\n+\t      char __q11, char __q10, char __q09, char __q08,\n+\t      char __q07, char __q06, char __q05, char __q04,\n+\t      char __q03, char __q02, char __q01, char __q00)\n {\n-  __builtin_ia32_storedqu ((char *)__P, (__v16qi)__B);\n+  return (__m128i)(__v16qi){\n+    __q00, __q01, __q02, __q03, __q04, __q05, __q06, __q07,\n+    __q08, __q09, __q10, __q11, __q12, __q13, __q14, __q15\n+  };\n }\n \n-static __inline void\n-_mm_storel_epi64 (__m128i *__P, __m128i __B)\n-{\n-  *(long long *)__P = __builtin_ia32_movdq2q ((__v2di)__B);\n-}\n+/* Set all of the elements of the vector to A.  */\n \n-static __inline __m64\n-_mm_movepi64_pi64 (__m128i __B)\n+static __inline __m128i\n+_mm_set1_epi64x (long long __A)\n {\n-  return (__m64) __builtin_ia32_movdq2q ((__v2di)__B);\n+  return _mm_set_epi64x (__A, __A);\n }\n \n static __inline __m128i\n-_mm_move_epi64 (__m128i __A)\n+_mm_set1_epi64 (__m64 __A)\n {\n-  return (__m128i) __builtin_ia32_movq ((__v2di)__A);\n+  return _mm_set_epi64 (__A, __A);\n }\n \n-/* Create a vector of zeros.  */\n static __inline __m128i\n-_mm_setzero_si128 (void)\n+_mm_set1_epi32 (int __A)\n {\n-  return (__m128i) __builtin_ia32_setzero128 ();\n+  return _mm_set_epi32 (__A, __A, __A, __A);\n }\n \n static __inline __m128i\n-_mm_set_epi64 (__m64 __A,  __m64 __B)\n+_mm_set1_epi16 (short __A)\n {\n-  __v2di __tmp = (__v2di)__builtin_ia32_movq2dq ((unsigned long long)__A);\n-  __v2di __tmp2 = (__v2di)__builtin_ia32_movq2dq ((unsigned long long)__B);\n-  return (__m128i)__builtin_ia32_punpcklqdq128 (__tmp2, __tmp);\n+  return _mm_set_epi16 (__A, __A, __A, __A, __A, __A, __A, __A);\n }\n \n-/* Create the vector [Z Y X W].  */\n static __inline __m128i\n-_mm_set_epi32 (int __Z, int __Y, int __X, int __W)\n+_mm_set1_epi8 (char __A)\n {\n-  union {\n-    int __a[4];\n-    __m128i __v;\n-  } __u;\n+  return _mm_set_epi8 (__A, __A, __A, __A, __A, __A, __A, __A,\n+\t\t       __A, __A, __A, __A, __A, __A, __A, __A);\n+}\n \n-  __u.__a[0] = __W;\n-  __u.__a[1] = __X;\n-  __u.__a[2] = __Y;\n-  __u.__a[3] = __Z;\n+/* Create a vector of Qi, where i is the element number.\n+   The parameter order is reversed from the _mm_set_epi* functions.  */\n \n-  return __u.__v;\n+static __inline __m128i\n+_mm_setr_epi64 (__m64 __q0, __m64 __q1)\n+{\n+  return _mm_set_epi64 (__q1, __q0);\n }\n \n-#ifdef __x86_64__\n-/* Create the vector [Z Y].  */\n static __inline __m128i\n-_mm_set_epi64x (long long __Z, long long __Y)\n+_mm_setr_epi32 (int __q0, int __q1, int __q2, int __q3)\n {\n-  union {\n-    long __a[2];\n-    __m128i __v;\n-  } __u;\n-\n-  __u.__a[0] = __Y;\n-  __u.__a[1] = __Z;\n-\n-  return __u.__v;\n+  return _mm_set_epi32 (__q3, __q2, __q1, __q0);\n }\n-#endif\n \n-/* Create the vector [S T U V Z Y X W].  */\n static __inline __m128i\n-_mm_set_epi16 (short __Z, short __Y, short __X, short __W,\n-\t       short __V, short __U, short __T, short __S)\n+_mm_setr_epi16 (short __q0, short __q1, short __q2, short __q3,\n+\t        short __q4, short __q5, short __q6, short __q7)\n {\n-  union {\n-    short __a[8];\n-    __m128i __v;\n-  } __u;\n-\n-  __u.__a[0] = __S;\n-  __u.__a[1] = __T;\n-  __u.__a[2] = __U;\n-  __u.__a[3] = __V;\n-  __u.__a[4] = __W;\n-  __u.__a[5] = __X;\n-  __u.__a[6] = __Y;\n-  __u.__a[7] = __Z;\n-\n-  return __u.__v;\n+  return _mm_set_epi16 (__q7, __q6, __q5, __q4, __q3, __q2, __q1, __q0);\n }\n \n-/* Create the vector [S T U V Z Y X W].  */\n static __inline __m128i\n-_mm_set_epi8 (char __Z, char __Y, char __X, char __W,\n-\t      char __V, char __U, char __T, char __S,\n-\t      char __Z1, char __Y1, char __X1, char __W1,\n-\t      char __V1, char __U1, char __T1, char __S1)\n+_mm_setr_epi8 (char __q00, char __q01, char __q02, char __q03,\n+\t       char __q04, char __q05, char __q06, char __q07,\n+\t       char __q08, char __q09, char __q10, char __q11,\n+\t       char __q12, char __q13, char __q14, char __q15)\n {\n-  union {\n-    char __a[16];\n-    __m128i __v;\n-  } __u;\n+  return _mm_set_epi8 (__q15, __q14, __q13, __q12, __q11, __q10, __q09, __q08,\n+\t\t       __q07, __q06, __q05, __q04, __q03, __q02, __q01, __q00);\n+}\n \n-  __u.__a[0] = __S1;\n-  __u.__a[1] = __T1;\n-  __u.__a[2] = __U1;\n-  __u.__a[3] = __V1;\n-  __u.__a[4] = __W1;\n-  __u.__a[5] = __X1;\n-  __u.__a[6] = __Y1;\n-  __u.__a[7] = __Z1;\n-  __u.__a[8] = __S;\n-  __u.__a[9] = __T;\n-  __u.__a[10] = __U;\n-  __u.__a[11] = __V;\n-  __u.__a[12] = __W;\n-  __u.__a[13] = __X;\n-  __u.__a[14] = __Y;\n-  __u.__a[15] = __Z;\n+/* Create a vector with element 0 as *P and the rest zero.  */\n \n-  return __u.__v;\n+static __inline __m128i\n+_mm_load_si128 (__m128i const *__P)\n+{\n+  return *__P;\n }\n \n static __inline __m128i\n-_mm_set1_epi64 (__m64 __A)\n+_mm_loadu_si128 (__m128i const *__P)\n {\n-  __v2di __tmp = (__v2di)__builtin_ia32_movq2dq ((unsigned long long)__A);\n-  return (__m128i)__builtin_ia32_punpcklqdq128 (__tmp, __tmp);\n+  return (__m128i) __builtin_ia32_loaddqu ((char const *)__P);\n }\n \n static __inline __m128i\n-_mm_set1_epi32 (int __A)\n+_mm_loadl_epi64 (__m128i const *__P)\n {\n-  __v4si __tmp = (__v4si)__builtin_ia32_loadd (&__A);\n-  return (__m128i) __builtin_ia32_pshufd ((__v4si)__tmp, _MM_SHUFFLE (0,0,0,0));\n+  return _mm_set_epi64 ((__m64)0LL, *(__m64 *)__P);\n }\n \n-#ifdef __x86_64__\n-static __inline __m128i\n-_mm_set1_epi64x (long long __A)\n+static __inline void\n+_mm_store_si128 (__m128i *__P, __m128i __B)\n {\n-  __v2di __tmp = (__v2di)__builtin_ia32_movq2dq ((unsigned long long)__A);\n-  return (__m128i) __builtin_ia32_shufpd ((__v2df)__tmp, (__v2df)__tmp, _MM_SHUFFLE2 (0,0));\n+  *__P = __B;\n }\n-#endif\n \n-static __inline __m128i\n-_mm_set1_epi16 (short __A)\n+static __inline void\n+_mm_storeu_si128 (__m128i *__P, __m128i __B)\n {\n-  int __Acopy = (unsigned short)__A;\n-  __v4si __tmp = (__v4si)__builtin_ia32_loadd (&__Acopy);\n-  __tmp = (__v4si)__builtin_ia32_punpcklwd128 ((__v8hi)__tmp, (__v8hi)__tmp);\n-  return (__m128i) __builtin_ia32_pshufd ((__v4si)__tmp, _MM_SHUFFLE (0,0,0,0));\n+  __builtin_ia32_storedqu ((char *)__P, (__v16qi)__B);\n }\n \n-static __inline __m128i\n-_mm_set1_epi8 (char __A)\n+static __inline void\n+_mm_storel_epi64 (__m128i *__P, __m128i __B)\n {\n-  int __Acopy = (unsigned char)__A;\n-  __v4si __tmp = (__v4si)__builtin_ia32_loadd (&__Acopy);\n-  __tmp = (__v4si)__builtin_ia32_punpcklbw128 ((__v16qi)__tmp, (__v16qi)__tmp);\n-  __tmp = (__v4si)__builtin_ia32_punpcklbw128 ((__v16qi)__tmp, (__v16qi)__tmp);\n-  return (__m128i) __builtin_ia32_pshufd ((__v4si)__tmp, _MM_SHUFFLE (0,0,0,0));\n+  *(long long *)__P = __builtin_ia32_vec_ext_v2di ((__v2di)__B, 0);\n }\n \n-static __inline __m128i\n-_mm_setr_epi64 (__m64 __A,  __m64 __B)\n+static __inline __m64\n+_mm_movepi64_pi64 (__m128i __B)\n {\n-  __v2di __tmp = (__v2di)__builtin_ia32_movq2dq ((unsigned long long)__A);\n-  __v2di __tmp2 = (__v2di)__builtin_ia32_movq2dq ((unsigned long long)__B);\n-  return (__m128i)__builtin_ia32_punpcklqdq128 (__tmp, __tmp2);\n+  return (__m64) __builtin_ia32_vec_ext_v2di ((__v2di)__B, 0);\n }\n \n-/* Create the vector [Z Y X W].  */\n static __inline __m128i\n-_mm_setr_epi32 (int __W, int __X, int __Y, int __Z)\n+_mm_movpi64_epi64 (__m64 __A)\n {\n-  union {\n-    int __a[4];\n-    __m128i __v;\n-  } __u;\n-\n-  __u.__a[0] = __W;\n-  __u.__a[1] = __X;\n-  __u.__a[2] = __Y;\n-  __u.__a[3] = __Z;\n-\n-  return __u.__v;\n+  return _mm_set_epi64 ((__m64)0LL, __A);\n }\n-/* Create the vector [S T U V Z Y X W].  */\n+\n static __inline __m128i\n-_mm_setr_epi16 (short __S, short __T, short __U, short __V,\n-\t        short __W, short __X, short __Y, short __Z)\n+_mm_move_epi64 (__m128i __A)\n {\n-  union {\n-    short __a[8];\n-    __m128i __v;\n-  } __u;\n-\n-  __u.__a[0] = __S;\n-  __u.__a[1] = __T;\n-  __u.__a[2] = __U;\n-  __u.__a[3] = __V;\n-  __u.__a[4] = __W;\n-  __u.__a[5] = __X;\n-  __u.__a[6] = __Y;\n-  __u.__a[7] = __Z;\n-\n-  return __u.__v;\n+  return _mm_set_epi64 ((__m64)0LL, _mm_movepi64_pi64 (__A));\n }\n \n-/* Create the vector [S T U V Z Y X W].  */\n+/* Create a vector of zeros.  */\n static __inline __m128i\n-_mm_setr_epi8 (char __S1, char __T1, char __U1, char __V1,\n-\t       char __W1, char __X1, char __Y1, char __Z1,\n-\t       char __S, char __T, char __U, char __V,\n-\t       char __W, char __X, char __Y, char __Z)\n+_mm_setzero_si128 (void)\n {\n-  union {\n-    char __a[16];\n-    __m128i __v;\n-  } __u;\n-\n-  __u.__a[0] = __S1;\n-  __u.__a[1] = __T1;\n-  __u.__a[2] = __U1;\n-  __u.__a[3] = __V1;\n-  __u.__a[4] = __W1;\n-  __u.__a[5] = __X1;\n-  __u.__a[6] = __Y1;\n-  __u.__a[7] = __Z1;\n-  __u.__a[8] = __S;\n-  __u.__a[9] = __T;\n-  __u.__a[10] = __U;\n-  __u.__a[11] = __V;\n-  __u.__a[12] = __W;\n-  __u.__a[13] = __X;\n-  __u.__a[14] = __Y;\n-  __u.__a[15] = __Z;\n-\n-  return __u.__v;\n+  return (__m128i)(__v4si){ 0, 0, 0, 0 };\n }\n \n static __inline __m128d\n@@ -956,24 +858,12 @@ _mm_loadh_pd (__m128d __A, double const *__B)\n   return (__m128d)__builtin_ia32_loadhpd ((__v2df)__A, __B);\n }\n \n-static __inline void\n-_mm_storeh_pd (double *__A, __m128d __B)\n-{\n-  __builtin_ia32_storehpd (__A, (__v2df)__B);\n-}\n-\n static __inline __m128d\n _mm_loadl_pd (__m128d __A, double const *__B)\n {\n   return (__m128d)__builtin_ia32_loadlpd ((__v2df)__A, __B);\n }\n \n-static __inline void\n-_mm_storel_pd (double *__A, __m128d __B)\n-{\n-  __builtin_ia32_storelpd (__A, (__v2df)__B);\n-}\n-\n static __inline int\n _mm_movemask_pd (__m128d __A)\n {\n@@ -1365,9 +1255,24 @@ _mm_cmpgt_epi32 (__m128i __A, __m128i __B)\n   return (__m128i)__builtin_ia32_pcmpgtd128 ((__v4si)__A, (__v4si)__B);\n }\n \n-#define _mm_extract_epi16(__A, __B) __builtin_ia32_pextrw128 ((__v8hi)__A, __B)\n+#if 0\n+static __inline int __attribute__((__always_inline__))\n+_mm_extract_epi16 (__m128i const __A, int const __N)\n+{\n+  return __builtin_ia32_vec_ext_v8hi ((__v8hi)__A, __N);\n+}\n \n-#define _mm_insert_epi16(__A, __B, __C) ((__m128i)__builtin_ia32_pinsrw128 ((__v8hi)__A, __B, __C))\n+static __inline __m128i __attribute__((__always_inline__))\n+_mm_insert_epi16 (__m128i const __A, int const __D, int const __N)\n+{\n+  return (__m128i) __builtin_ia32_vec_set_v8hi ((__v8hi)__A, __D, __N);\n+}\n+#else\n+#define _mm_extract_epi16(A, N) \\\n+  ((int) __builtin_ia32_vec_ext_v8hi ((__v8hi)(A), (N))\n+#define _mm_insert_epi16(A, D, N) \\\n+  ((__m128i) __builtin_ia32_vec_set_v8hi ((__v8hi)(A), (D), (N)))\n+#endif\n \n static __inline __m128i\n _mm_max_epi16 (__m128i __A, __m128i __B)\n@@ -1451,12 +1356,6 @@ _mm_stream_pd (double *__A, __m128d __B)\n   __builtin_ia32_movntpd (__A, (__v2df)__B);\n }\n \n-static __inline __m128i\n-_mm_movpi64_epi64 (__m64 __A)\n-{\n-  return (__m128i)__builtin_ia32_movq2dq ((unsigned long long)__A);\n-}\n-\n static __inline void\n _mm_clflush (void const *__A)\n {"}, {"sha": "33bf6fc6c9bc73ce82be1588823542403dd0e482", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb701deb655a1ae74c35f2719d33c701544c7ccd/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb701deb655a1ae74c35f2719d33c701544c7ccd/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=eb701deb655a1ae74c35f2719d33c701544c7ccd", "patch": "@@ -198,8 +198,6 @@ extern rtx function_arg (CUMULATIVE_ARGS *, enum machine_mode, tree, int);\n extern void function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t  tree, int);\n extern rtx ix86_function_value (tree);\n-extern void ix86_init_builtins (void);\n-extern rtx ix86_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n #endif\n \n #endif\n@@ -219,7 +217,10 @@ extern int x86_field_alignment (tree, int);\n \n extern rtx ix86_tls_get_addr (void);\n \n-extern void ix86_expand_vector_init (rtx, rtx);\n+extern void ix86_expand_vector_init (bool, rtx, rtx);\n+extern void ix86_expand_vector_set (bool, rtx, rtx, int);\n+extern void ix86_expand_vector_extract (bool, rtx, rtx, int);\n+\n /* In winnt.c  */\n extern int i386_pe_dllexport_name_p (const char *);\n extern int i386_pe_dllimport_name_p (const char *);"}, {"sha": "d9dcca590d9283d15a1139aa80a742ebffc7388b", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1300, "deletions": 296, "changes": 1596, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb701deb655a1ae74c35f2719d33c701544c7ccd/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb701deb655a1ae74c35f2719d33c701544c7ccd/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=eb701deb655a1ae74c35f2719d33c701544c7ccd", "patch": "@@ -921,6 +921,8 @@ static tree ix86_md_asm_clobbers (tree clobbers);\n static bool ix86_must_pass_in_stack (enum machine_mode mode, tree type);\n static bool ix86_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t    tree, bool);\n+static void ix86_init_builtins (void);\n+static rtx ix86_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n \n /* This function is only used on Solaris.  */\n static void i386_solaris_elf_named_section (const char *, unsigned int, tree)\n@@ -973,7 +975,6 @@ static void init_ext_80387_constants (void);\n \n #undef TARGET_INIT_BUILTINS\n #define TARGET_INIT_BUILTINS ix86_init_builtins\n-\n #undef TARGET_EXPAND_BUILTIN\n #define TARGET_EXPAND_BUILTIN ix86_expand_builtin\n \n@@ -7668,15 +7669,14 @@ ix86_expand_vector_move_misalign (enum machine_mode mode, rtx operands[])\n \n       if (TARGET_SSE2 && mode == V2DFmode)\n \t{\n+\t  rtx zero;\n+\n \t  /* When SSE registers are split into halves, we can avoid\n \t     writing to the top half twice.  */\n \t  if (TARGET_SSE_SPLIT_REGS)\n \t    {\n \t      emit_insn (gen_rtx_CLOBBER (VOIDmode, op0));\n-\t      m = adjust_address (op1, DFmode, 0);\n-\t      emit_insn (gen_sse2_loadlpd (op0, op0, m));\n-\t      m = adjust_address (op1, DFmode, 8);\n-\t      emit_insn (gen_sse2_loadhpd (op0, op0, m));\n+\t      zero = op0;\n \t    }\n \t  else\n \t    {\n@@ -7688,11 +7688,13 @@ ix86_expand_vector_move_misalign (enum machine_mode mode, rtx operands[])\n \t\t followed by an unpacklpd, but this is unconfirmed.  And\n \t\t given that the dependency depth of the unpacklpd would\n \t\t still be one, I'm not sure why this would be better.  */\n-\t      m = adjust_address (op1, DFmode, 0);\n-\t      emit_insn (gen_sse2_loadsd (op0, m));\n-\t      m = adjust_address (op1, DFmode, 8);\n-\t      emit_insn (gen_sse2_loadhpd (op0, op0, m));\n+\t      zero = CONST0_RTX (V2DFmode);\n \t    }\n+\n+\t  m = adjust_address (op1, DFmode, 0);\n+\t  emit_insn (gen_sse2_loadlpd (op0, zero, m));\n+\t  m = adjust_address (op1, DFmode, 8);\n+\t  emit_insn (gen_sse2_loadhpd (op0, op0, m));\n \t}\n       else\n \t{\n@@ -7735,15 +7737,15 @@ ix86_expand_vector_move_misalign (enum machine_mode mode, rtx operands[])\n \t  emit_insn (gen_sse2_storelpd (m, op1));\n \t  m = adjust_address (op0, DFmode, 8);\n \t  emit_insn (gen_sse2_storehpd (m, op1));\n-\t  return;\n \t}\n       else\n \t{\n+\t  if (mode != V4SFmode)\n+\t    op1 = gen_lowpart (V4SFmode, op1);\n \t  m = adjust_address (op0, V2SFmode, 0);\n \t  emit_insn (gen_sse_storelps (m, op1));\n \t  m = adjust_address (op0, V2SFmode, 8);\n \t  emit_insn (gen_sse_storehps (m, op1));\n-\t  return;\n \t}\n     }\n   else\n@@ -12178,6 +12180,441 @@ x86_initialize_trampoline (rtx tramp, rtx fnaddr, rtx cxt)\n #endif\n }\n \f\n+/* Codes for all the SSE/MMX builtins.  */\n+enum ix86_builtins\n+{\n+  IX86_BUILTIN_ADDPS,\n+  IX86_BUILTIN_ADDSS,\n+  IX86_BUILTIN_DIVPS,\n+  IX86_BUILTIN_DIVSS,\n+  IX86_BUILTIN_MULPS,\n+  IX86_BUILTIN_MULSS,\n+  IX86_BUILTIN_SUBPS,\n+  IX86_BUILTIN_SUBSS,\n+\n+  IX86_BUILTIN_CMPEQPS,\n+  IX86_BUILTIN_CMPLTPS,\n+  IX86_BUILTIN_CMPLEPS,\n+  IX86_BUILTIN_CMPGTPS,\n+  IX86_BUILTIN_CMPGEPS,\n+  IX86_BUILTIN_CMPNEQPS,\n+  IX86_BUILTIN_CMPNLTPS,\n+  IX86_BUILTIN_CMPNLEPS,\n+  IX86_BUILTIN_CMPNGTPS,\n+  IX86_BUILTIN_CMPNGEPS,\n+  IX86_BUILTIN_CMPORDPS,\n+  IX86_BUILTIN_CMPUNORDPS,\n+  IX86_BUILTIN_CMPNEPS,\n+  IX86_BUILTIN_CMPEQSS,\n+  IX86_BUILTIN_CMPLTSS,\n+  IX86_BUILTIN_CMPLESS,\n+  IX86_BUILTIN_CMPNEQSS,\n+  IX86_BUILTIN_CMPNLTSS,\n+  IX86_BUILTIN_CMPNLESS,\n+  IX86_BUILTIN_CMPNGTSS,\n+  IX86_BUILTIN_CMPNGESS,\n+  IX86_BUILTIN_CMPORDSS,\n+  IX86_BUILTIN_CMPUNORDSS,\n+  IX86_BUILTIN_CMPNESS,\n+\n+  IX86_BUILTIN_COMIEQSS,\n+  IX86_BUILTIN_COMILTSS,\n+  IX86_BUILTIN_COMILESS,\n+  IX86_BUILTIN_COMIGTSS,\n+  IX86_BUILTIN_COMIGESS,\n+  IX86_BUILTIN_COMINEQSS,\n+  IX86_BUILTIN_UCOMIEQSS,\n+  IX86_BUILTIN_UCOMILTSS,\n+  IX86_BUILTIN_UCOMILESS,\n+  IX86_BUILTIN_UCOMIGTSS,\n+  IX86_BUILTIN_UCOMIGESS,\n+  IX86_BUILTIN_UCOMINEQSS,\n+\n+  IX86_BUILTIN_CVTPI2PS,\n+  IX86_BUILTIN_CVTPS2PI,\n+  IX86_BUILTIN_CVTSI2SS,\n+  IX86_BUILTIN_CVTSI642SS,\n+  IX86_BUILTIN_CVTSS2SI,\n+  IX86_BUILTIN_CVTSS2SI64,\n+  IX86_BUILTIN_CVTTPS2PI,\n+  IX86_BUILTIN_CVTTSS2SI,\n+  IX86_BUILTIN_CVTTSS2SI64,\n+\n+  IX86_BUILTIN_MAXPS,\n+  IX86_BUILTIN_MAXSS,\n+  IX86_BUILTIN_MINPS,\n+  IX86_BUILTIN_MINSS,\n+\n+  IX86_BUILTIN_LOADUPS,\n+  IX86_BUILTIN_STOREUPS,\n+  IX86_BUILTIN_MOVSS,\n+\n+  IX86_BUILTIN_MOVHLPS,\n+  IX86_BUILTIN_MOVLHPS,\n+  IX86_BUILTIN_LOADHPS,\n+  IX86_BUILTIN_LOADLPS,\n+  IX86_BUILTIN_STOREHPS,\n+  IX86_BUILTIN_STORELPS,\n+\n+  IX86_BUILTIN_MASKMOVQ,\n+  IX86_BUILTIN_MOVMSKPS,\n+  IX86_BUILTIN_PMOVMSKB,\n+\n+  IX86_BUILTIN_MOVNTPS,\n+  IX86_BUILTIN_MOVNTQ,\n+\n+  IX86_BUILTIN_LOADDQU,\n+  IX86_BUILTIN_STOREDQU,\n+  IX86_BUILTIN_MOVQ,\n+  IX86_BUILTIN_LOADD,\n+  IX86_BUILTIN_STORED,\n+\n+  IX86_BUILTIN_PACKSSWB,\n+  IX86_BUILTIN_PACKSSDW,\n+  IX86_BUILTIN_PACKUSWB,\n+\n+  IX86_BUILTIN_PADDB,\n+  IX86_BUILTIN_PADDW,\n+  IX86_BUILTIN_PADDD,\n+  IX86_BUILTIN_PADDQ,\n+  IX86_BUILTIN_PADDSB,\n+  IX86_BUILTIN_PADDSW,\n+  IX86_BUILTIN_PADDUSB,\n+  IX86_BUILTIN_PADDUSW,\n+  IX86_BUILTIN_PSUBB,\n+  IX86_BUILTIN_PSUBW,\n+  IX86_BUILTIN_PSUBD,\n+  IX86_BUILTIN_PSUBQ,\n+  IX86_BUILTIN_PSUBSB,\n+  IX86_BUILTIN_PSUBSW,\n+  IX86_BUILTIN_PSUBUSB,\n+  IX86_BUILTIN_PSUBUSW,\n+\n+  IX86_BUILTIN_PAND,\n+  IX86_BUILTIN_PANDN,\n+  IX86_BUILTIN_POR,\n+  IX86_BUILTIN_PXOR,\n+\n+  IX86_BUILTIN_PAVGB,\n+  IX86_BUILTIN_PAVGW,\n+\n+  IX86_BUILTIN_PCMPEQB,\n+  IX86_BUILTIN_PCMPEQW,\n+  IX86_BUILTIN_PCMPEQD,\n+  IX86_BUILTIN_PCMPGTB,\n+  IX86_BUILTIN_PCMPGTW,\n+  IX86_BUILTIN_PCMPGTD,\n+\n+  IX86_BUILTIN_PMADDWD,\n+\n+  IX86_BUILTIN_PMAXSW,\n+  IX86_BUILTIN_PMAXUB,\n+  IX86_BUILTIN_PMINSW,\n+  IX86_BUILTIN_PMINUB,\n+\n+  IX86_BUILTIN_PMULHUW,\n+  IX86_BUILTIN_PMULHW,\n+  IX86_BUILTIN_PMULLW,\n+\n+  IX86_BUILTIN_PSADBW,\n+  IX86_BUILTIN_PSHUFW,\n+\n+  IX86_BUILTIN_PSLLW,\n+  IX86_BUILTIN_PSLLD,\n+  IX86_BUILTIN_PSLLQ,\n+  IX86_BUILTIN_PSRAW,\n+  IX86_BUILTIN_PSRAD,\n+  IX86_BUILTIN_PSRLW,\n+  IX86_BUILTIN_PSRLD,\n+  IX86_BUILTIN_PSRLQ,\n+  IX86_BUILTIN_PSLLWI,\n+  IX86_BUILTIN_PSLLDI,\n+  IX86_BUILTIN_PSLLQI,\n+  IX86_BUILTIN_PSRAWI,\n+  IX86_BUILTIN_PSRADI,\n+  IX86_BUILTIN_PSRLWI,\n+  IX86_BUILTIN_PSRLDI,\n+  IX86_BUILTIN_PSRLQI,\n+\n+  IX86_BUILTIN_PUNPCKHBW,\n+  IX86_BUILTIN_PUNPCKHWD,\n+  IX86_BUILTIN_PUNPCKHDQ,\n+  IX86_BUILTIN_PUNPCKLBW,\n+  IX86_BUILTIN_PUNPCKLWD,\n+  IX86_BUILTIN_PUNPCKLDQ,\n+\n+  IX86_BUILTIN_SHUFPS,\n+\n+  IX86_BUILTIN_RCPPS,\n+  IX86_BUILTIN_RCPSS,\n+  IX86_BUILTIN_RSQRTPS,\n+  IX86_BUILTIN_RSQRTSS,\n+  IX86_BUILTIN_SQRTPS,\n+  IX86_BUILTIN_SQRTSS,\n+\n+  IX86_BUILTIN_UNPCKHPS,\n+  IX86_BUILTIN_UNPCKLPS,\n+\n+  IX86_BUILTIN_ANDPS,\n+  IX86_BUILTIN_ANDNPS,\n+  IX86_BUILTIN_ORPS,\n+  IX86_BUILTIN_XORPS,\n+\n+  IX86_BUILTIN_EMMS,\n+  IX86_BUILTIN_LDMXCSR,\n+  IX86_BUILTIN_STMXCSR,\n+  IX86_BUILTIN_SFENCE,\n+\n+  /* 3DNow! Original */\n+  IX86_BUILTIN_FEMMS,\n+  IX86_BUILTIN_PAVGUSB,\n+  IX86_BUILTIN_PF2ID,\n+  IX86_BUILTIN_PFACC,\n+  IX86_BUILTIN_PFADD,\n+  IX86_BUILTIN_PFCMPEQ,\n+  IX86_BUILTIN_PFCMPGE,\n+  IX86_BUILTIN_PFCMPGT,\n+  IX86_BUILTIN_PFMAX,\n+  IX86_BUILTIN_PFMIN,\n+  IX86_BUILTIN_PFMUL,\n+  IX86_BUILTIN_PFRCP,\n+  IX86_BUILTIN_PFRCPIT1,\n+  IX86_BUILTIN_PFRCPIT2,\n+  IX86_BUILTIN_PFRSQIT1,\n+  IX86_BUILTIN_PFRSQRT,\n+  IX86_BUILTIN_PFSUB,\n+  IX86_BUILTIN_PFSUBR,\n+  IX86_BUILTIN_PI2FD,\n+  IX86_BUILTIN_PMULHRW,\n+\n+  /* 3DNow! Athlon Extensions */\n+  IX86_BUILTIN_PF2IW,\n+  IX86_BUILTIN_PFNACC,\n+  IX86_BUILTIN_PFPNACC,\n+  IX86_BUILTIN_PI2FW,\n+  IX86_BUILTIN_PSWAPDSI,\n+  IX86_BUILTIN_PSWAPDSF,\n+\n+  /* SSE2 */\n+  IX86_BUILTIN_ADDPD,\n+  IX86_BUILTIN_ADDSD,\n+  IX86_BUILTIN_DIVPD,\n+  IX86_BUILTIN_DIVSD,\n+  IX86_BUILTIN_MULPD,\n+  IX86_BUILTIN_MULSD,\n+  IX86_BUILTIN_SUBPD,\n+  IX86_BUILTIN_SUBSD,\n+\n+  IX86_BUILTIN_CMPEQPD,\n+  IX86_BUILTIN_CMPLTPD,\n+  IX86_BUILTIN_CMPLEPD,\n+  IX86_BUILTIN_CMPGTPD,\n+  IX86_BUILTIN_CMPGEPD,\n+  IX86_BUILTIN_CMPNEQPD,\n+  IX86_BUILTIN_CMPNLTPD,\n+  IX86_BUILTIN_CMPNLEPD,\n+  IX86_BUILTIN_CMPNGTPD,\n+  IX86_BUILTIN_CMPNGEPD,\n+  IX86_BUILTIN_CMPORDPD,\n+  IX86_BUILTIN_CMPUNORDPD,\n+  IX86_BUILTIN_CMPNEPD,\n+  IX86_BUILTIN_CMPEQSD,\n+  IX86_BUILTIN_CMPLTSD,\n+  IX86_BUILTIN_CMPLESD,\n+  IX86_BUILTIN_CMPNEQSD,\n+  IX86_BUILTIN_CMPNLTSD,\n+  IX86_BUILTIN_CMPNLESD,\n+  IX86_BUILTIN_CMPORDSD,\n+  IX86_BUILTIN_CMPUNORDSD,\n+  IX86_BUILTIN_CMPNESD,\n+\n+  IX86_BUILTIN_COMIEQSD,\n+  IX86_BUILTIN_COMILTSD,\n+  IX86_BUILTIN_COMILESD,\n+  IX86_BUILTIN_COMIGTSD,\n+  IX86_BUILTIN_COMIGESD,\n+  IX86_BUILTIN_COMINEQSD,\n+  IX86_BUILTIN_UCOMIEQSD,\n+  IX86_BUILTIN_UCOMILTSD,\n+  IX86_BUILTIN_UCOMILESD,\n+  IX86_BUILTIN_UCOMIGTSD,\n+  IX86_BUILTIN_UCOMIGESD,\n+  IX86_BUILTIN_UCOMINEQSD,\n+\n+  IX86_BUILTIN_MAXPD,\n+  IX86_BUILTIN_MAXSD,\n+  IX86_BUILTIN_MINPD,\n+  IX86_BUILTIN_MINSD,\n+\n+  IX86_BUILTIN_ANDPD,\n+  IX86_BUILTIN_ANDNPD,\n+  IX86_BUILTIN_ORPD,\n+  IX86_BUILTIN_XORPD,\n+\n+  IX86_BUILTIN_SQRTPD,\n+  IX86_BUILTIN_SQRTSD,\n+\n+  IX86_BUILTIN_UNPCKHPD,\n+  IX86_BUILTIN_UNPCKLPD,\n+\n+  IX86_BUILTIN_SHUFPD,\n+\n+  IX86_BUILTIN_LOADUPD,\n+  IX86_BUILTIN_STOREUPD,\n+  IX86_BUILTIN_MOVSD,\n+\n+  IX86_BUILTIN_LOADHPD,\n+  IX86_BUILTIN_LOADLPD,\n+\n+  IX86_BUILTIN_CVTDQ2PD,\n+  IX86_BUILTIN_CVTDQ2PS,\n+\n+  IX86_BUILTIN_CVTPD2DQ,\n+  IX86_BUILTIN_CVTPD2PI,\n+  IX86_BUILTIN_CVTPD2PS,\n+  IX86_BUILTIN_CVTTPD2DQ,\n+  IX86_BUILTIN_CVTTPD2PI,\n+\n+  IX86_BUILTIN_CVTPI2PD,\n+  IX86_BUILTIN_CVTSI2SD,\n+  IX86_BUILTIN_CVTSI642SD,\n+\n+  IX86_BUILTIN_CVTSD2SI,\n+  IX86_BUILTIN_CVTSD2SI64,\n+  IX86_BUILTIN_CVTSD2SS,\n+  IX86_BUILTIN_CVTSS2SD,\n+  IX86_BUILTIN_CVTTSD2SI,\n+  IX86_BUILTIN_CVTTSD2SI64,\n+\n+  IX86_BUILTIN_CVTPS2DQ,\n+  IX86_BUILTIN_CVTPS2PD,\n+  IX86_BUILTIN_CVTTPS2DQ,\n+\n+  IX86_BUILTIN_MOVNTI,\n+  IX86_BUILTIN_MOVNTPD,\n+  IX86_BUILTIN_MOVNTDQ,\n+\n+  /* SSE2 MMX */\n+  IX86_BUILTIN_MASKMOVDQU,\n+  IX86_BUILTIN_MOVMSKPD,\n+  IX86_BUILTIN_PMOVMSKB128,\n+  IX86_BUILTIN_MOVQ2DQ,\n+  IX86_BUILTIN_MOVDQ2Q,\n+\n+  IX86_BUILTIN_PACKSSWB128,\n+  IX86_BUILTIN_PACKSSDW128,\n+  IX86_BUILTIN_PACKUSWB128,\n+\n+  IX86_BUILTIN_PADDB128,\n+  IX86_BUILTIN_PADDW128,\n+  IX86_BUILTIN_PADDD128,\n+  IX86_BUILTIN_PADDQ128,\n+  IX86_BUILTIN_PADDSB128,\n+  IX86_BUILTIN_PADDSW128,\n+  IX86_BUILTIN_PADDUSB128,\n+  IX86_BUILTIN_PADDUSW128,\n+  IX86_BUILTIN_PSUBB128,\n+  IX86_BUILTIN_PSUBW128,\n+  IX86_BUILTIN_PSUBD128,\n+  IX86_BUILTIN_PSUBQ128,\n+  IX86_BUILTIN_PSUBSB128,\n+  IX86_BUILTIN_PSUBSW128,\n+  IX86_BUILTIN_PSUBUSB128,\n+  IX86_BUILTIN_PSUBUSW128,\n+\n+  IX86_BUILTIN_PAND128,\n+  IX86_BUILTIN_PANDN128,\n+  IX86_BUILTIN_POR128,\n+  IX86_BUILTIN_PXOR128,\n+\n+  IX86_BUILTIN_PAVGB128,\n+  IX86_BUILTIN_PAVGW128,\n+\n+  IX86_BUILTIN_PCMPEQB128,\n+  IX86_BUILTIN_PCMPEQW128,\n+  IX86_BUILTIN_PCMPEQD128,\n+  IX86_BUILTIN_PCMPGTB128,\n+  IX86_BUILTIN_PCMPGTW128,\n+  IX86_BUILTIN_PCMPGTD128,\n+\n+  IX86_BUILTIN_PMADDWD128,\n+\n+  IX86_BUILTIN_PMAXSW128,\n+  IX86_BUILTIN_PMAXUB128,\n+  IX86_BUILTIN_PMINSW128,\n+  IX86_BUILTIN_PMINUB128,\n+\n+  IX86_BUILTIN_PMULUDQ,\n+  IX86_BUILTIN_PMULUDQ128,\n+  IX86_BUILTIN_PMULHUW128,\n+  IX86_BUILTIN_PMULHW128,\n+  IX86_BUILTIN_PMULLW128,\n+\n+  IX86_BUILTIN_PSADBW128,\n+  IX86_BUILTIN_PSHUFHW,\n+  IX86_BUILTIN_PSHUFLW,\n+  IX86_BUILTIN_PSHUFD,\n+\n+  IX86_BUILTIN_PSLLW128,\n+  IX86_BUILTIN_PSLLD128,\n+  IX86_BUILTIN_PSLLQ128,\n+  IX86_BUILTIN_PSRAW128,\n+  IX86_BUILTIN_PSRAD128,\n+  IX86_BUILTIN_PSRLW128,\n+  IX86_BUILTIN_PSRLD128,\n+  IX86_BUILTIN_PSRLQ128,\n+  IX86_BUILTIN_PSLLDQI128,\n+  IX86_BUILTIN_PSLLWI128,\n+  IX86_BUILTIN_PSLLDI128,\n+  IX86_BUILTIN_PSLLQI128,\n+  IX86_BUILTIN_PSRAWI128,\n+  IX86_BUILTIN_PSRADI128,\n+  IX86_BUILTIN_PSRLDQI128,\n+  IX86_BUILTIN_PSRLWI128,\n+  IX86_BUILTIN_PSRLDI128,\n+  IX86_BUILTIN_PSRLQI128,\n+\n+  IX86_BUILTIN_PUNPCKHBW128,\n+  IX86_BUILTIN_PUNPCKHWD128,\n+  IX86_BUILTIN_PUNPCKHDQ128,\n+  IX86_BUILTIN_PUNPCKHQDQ128,\n+  IX86_BUILTIN_PUNPCKLBW128,\n+  IX86_BUILTIN_PUNPCKLWD128,\n+  IX86_BUILTIN_PUNPCKLDQ128,\n+  IX86_BUILTIN_PUNPCKLQDQ128,\n+\n+  IX86_BUILTIN_CLFLUSH,\n+  IX86_BUILTIN_MFENCE,\n+  IX86_BUILTIN_LFENCE,\n+\n+  /* Prescott New Instructions.  */\n+  IX86_BUILTIN_ADDSUBPS,\n+  IX86_BUILTIN_HADDPS,\n+  IX86_BUILTIN_HSUBPS,\n+  IX86_BUILTIN_MOVSHDUP,\n+  IX86_BUILTIN_MOVSLDUP,\n+  IX86_BUILTIN_ADDSUBPD,\n+  IX86_BUILTIN_HADDPD,\n+  IX86_BUILTIN_HSUBPD,\n+  IX86_BUILTIN_LDDQU,\n+\n+  IX86_BUILTIN_MONITOR,\n+  IX86_BUILTIN_MWAIT,\n+\n+  IX86_BUILTIN_VEC_INIT_V2SI,\n+  IX86_BUILTIN_VEC_INIT_V4HI,\n+  IX86_BUILTIN_VEC_INIT_V8QI,\n+  IX86_BUILTIN_VEC_EXT_V2DF,\n+  IX86_BUILTIN_VEC_EXT_V2DI,\n+  IX86_BUILTIN_VEC_EXT_V4SF,\n+  IX86_BUILTIN_VEC_EXT_V8HI,\n+  IX86_BUILTIN_VEC_EXT_V4HI,\n+  IX86_BUILTIN_VEC_SET_V8HI,\n+  IX86_BUILTIN_VEC_SET_V4HI,\n+\n+  IX86_BUILTIN_MAX\n+};\n+\n #define def_builtin(MASK, NAME, TYPE, CODE)\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n   if ((MASK) & target_flags\t\t\t\t\t\t\\\n@@ -12549,10 +12986,9 @@ static const struct builtin_description bdesc_1arg[] =\n   /* SSE3 */\n   { MASK_SSE3, CODE_FOR_sse3_movshdup, 0, IX86_BUILTIN_MOVSHDUP, 0, 0 },\n   { MASK_SSE3, CODE_FOR_sse3_movsldup, 0, IX86_BUILTIN_MOVSLDUP, 0, 0 },\n-  { MASK_SSE3, CODE_FOR_sse3_movddup,  0, IX86_BUILTIN_MOVDDUP, 0, 0 }\n };\n \n-void\n+static void\n ix86_init_builtins (void)\n {\n   if (TARGET_MMX)\n@@ -12616,13 +13052,7 @@ ix86_init_mmx_sse_builtins (void)\n   tree v4sf_ftype_v4sf_v2si\n     = build_function_type_list (V4SF_type_node,\n \t\t\t\tV4SF_type_node, V2SI_type_node, NULL_TREE);\n-  tree int_ftype_v4hi_int\n-    = build_function_type_list (integer_type_node,\n-\t\t\t\tV4HI_type_node, integer_type_node, NULL_TREE);\n-  tree v4hi_ftype_v4hi_int_int\n-    = build_function_type_list (V4HI_type_node, V4HI_type_node,\n-\t\t\t\tinteger_type_node, integer_type_node,\n-\t\t\t\tNULL_TREE);\n+\n   /* Miscellaneous.  */\n   tree v8qi_ftype_v4hi_v4hi\n     = build_function_type_list (V8QI_type_node,\n@@ -12661,10 +13091,6 @@ ix86_init_mmx_sse_builtins (void)\n \t\t\t\tNULL_TREE);\n   tree unsigned_ftype_void\n     = build_function_type (unsigned_type_node, void_list_node);\n-  tree di_ftype_void\n-    = build_function_type (long_long_unsigned_type_node, void_list_node);\n-  tree v4sf_ftype_void\n-    = build_function_type (V4SF_type_node, void_list_node);\n   tree v2si_ftype_v4sf\n     = build_function_type_list (V2SI_type_node, V4SF_type_node, NULL_TREE);\n   /* Loads/stores.  */\n@@ -12737,10 +13163,6 @@ ix86_init_mmx_sse_builtins (void)\n     = build_function_type_list (integer_type_node,\n \t\t\t\tV2DF_type_node, V2DF_type_node, NULL_TREE);\n \n-  tree ti_ftype_void\n-    = build_function_type (intTI_type_node, void_list_node);\n-  tree v2di_ftype_void\n-    = build_function_type (V2DI_type_node, void_list_node);\n   tree ti_ftype_ti_ti\n     = build_function_type_list (intTI_type_node,\n \t\t\t\tintTI_type_node, intTI_type_node, NULL_TREE);\n@@ -12826,18 +13248,6 @@ ix86_init_mmx_sse_builtins (void)\n \t\t\t\tV2DF_type_node, V2DF_type_node, NULL_TREE);\n   tree v2df_ftype_v2df\n     = build_function_type_list (V2DF_type_node, V2DF_type_node, NULL_TREE);\n-  tree v2df_ftype_double\n-    = build_function_type_list (V2DF_type_node, double_type_node, NULL_TREE);\n-  tree v2df_ftype_double_double\n-    = build_function_type_list (V2DF_type_node,\n-\t\t\t\tdouble_type_node, double_type_node, NULL_TREE);\n-  tree int_ftype_v8hi_int\n-    = build_function_type_list (integer_type_node,\n-\t\t\t\tV8HI_type_node, integer_type_node, NULL_TREE);\n-  tree v8hi_ftype_v8hi_int_int\n-    = build_function_type_list (V8HI_type_node,\n-\t\t\t\tV8HI_type_node, integer_type_node,\n-\t\t\t\tinteger_type_node, NULL_TREE);\n   tree v2di_ftype_v2di_int\n     = build_function_type_list (V2DI_type_node,\n \t\t\t\tV2DI_type_node, integer_type_node, NULL_TREE);\n@@ -12885,6 +13295,7 @@ ix86_init_mmx_sse_builtins (void)\n \n   tree float80_type;\n   tree float128_type;\n+  tree ftype;\n \n   /* The __float80 type.  */\n   if (TYPE_MODE (long_double_type_node) == XFmode)\n@@ -12970,7 +13381,6 @@ ix86_init_mmx_sse_builtins (void)\n     }\n \n   /* Add the remaining MMX insns with somewhat more complicated types.  */\n-  def_builtin (MASK_MMX, \"__builtin_ia32_mmx_zero\", di_ftype_void, IX86_BUILTIN_MMX_ZERO);\n   def_builtin (MASK_MMX, \"__builtin_ia32_emms\", void_ftype_void, IX86_BUILTIN_EMMS);\n   def_builtin (MASK_MMX, \"__builtin_ia32_psllw\", v4hi_ftype_v4hi_di, IX86_BUILTIN_PSLLW);\n   def_builtin (MASK_MMX, \"__builtin_ia32_pslld\", v2si_ftype_v2si_di, IX86_BUILTIN_PSLLD);\n@@ -13009,17 +13419,10 @@ ix86_init_mmx_sse_builtins (void)\n   def_builtin (MASK_SSE, \"__builtin_ia32_cvttss2si\", int_ftype_v4sf, IX86_BUILTIN_CVTTSS2SI);\n   def_builtin (MASK_SSE | MASK_64BIT, \"__builtin_ia32_cvttss2si64\", int64_ftype_v4sf, IX86_BUILTIN_CVTTSS2SI64);\n \n-  def_builtin (MASK_SSE | MASK_3DNOW_A, \"__builtin_ia32_pextrw\", int_ftype_v4hi_int, IX86_BUILTIN_PEXTRW);\n-  def_builtin (MASK_SSE | MASK_3DNOW_A, \"__builtin_ia32_pinsrw\", v4hi_ftype_v4hi_int_int, IX86_BUILTIN_PINSRW);\n-\n   def_builtin (MASK_SSE | MASK_3DNOW_A, \"__builtin_ia32_maskmovq\", void_ftype_v8qi_v8qi_pchar, IX86_BUILTIN_MASKMOVQ);\n \n-  def_builtin (MASK_SSE, \"__builtin_ia32_loadaps\", v4sf_ftype_pcfloat, IX86_BUILTIN_LOADAPS);\n   def_builtin (MASK_SSE, \"__builtin_ia32_loadups\", v4sf_ftype_pcfloat, IX86_BUILTIN_LOADUPS);\n-  def_builtin (MASK_SSE, \"__builtin_ia32_loadss\", v4sf_ftype_pcfloat, IX86_BUILTIN_LOADSS);\n-  def_builtin (MASK_SSE, \"__builtin_ia32_storeaps\", void_ftype_pfloat_v4sf, IX86_BUILTIN_STOREAPS);\n   def_builtin (MASK_SSE, \"__builtin_ia32_storeups\", void_ftype_pfloat_v4sf, IX86_BUILTIN_STOREUPS);\n-  def_builtin (MASK_SSE, \"__builtin_ia32_storess\", void_ftype_pfloat_v4sf, IX86_BUILTIN_STORESS);\n \n   def_builtin (MASK_SSE, \"__builtin_ia32_loadhps\", v4sf_ftype_v4sf_pv2si, IX86_BUILTIN_LOADHPS);\n   def_builtin (MASK_SSE, \"__builtin_ia32_loadlps\", v4sf_ftype_v4sf_pv2si, IX86_BUILTIN_LOADLPS);\n@@ -13074,27 +13477,16 @@ ix86_init_mmx_sse_builtins (void)\n   def_builtin (MASK_3DNOW_A, \"__builtin_ia32_pswapdsf\", v2sf_ftype_v2sf, IX86_BUILTIN_PSWAPDSF);\n   def_builtin (MASK_3DNOW_A, \"__builtin_ia32_pswapdsi\", v2si_ftype_v2si, IX86_BUILTIN_PSWAPDSI);\n \n-  def_builtin (MASK_SSE, \"__builtin_ia32_setzerops\", v4sf_ftype_void, IX86_BUILTIN_SSE_ZERO);\n-\n   /* SSE2 */\n-  def_builtin (MASK_SSE2, \"__builtin_ia32_pextrw128\", int_ftype_v8hi_int, IX86_BUILTIN_PEXTRW128);\n-  def_builtin (MASK_SSE2, \"__builtin_ia32_pinsrw128\", v8hi_ftype_v8hi_int_int, IX86_BUILTIN_PINSRW128);\n-\n   def_builtin (MASK_SSE2, \"__builtin_ia32_maskmovdqu\", void_ftype_v16qi_v16qi_pchar, IX86_BUILTIN_MASKMOVDQU);\n   def_builtin (MASK_SSE2, \"__builtin_ia32_movq2dq\", v2di_ftype_di, IX86_BUILTIN_MOVQ2DQ);\n   def_builtin (MASK_SSE2, \"__builtin_ia32_movdq2q\", di_ftype_v2di, IX86_BUILTIN_MOVDQ2Q);\n \n-  def_builtin (MASK_SSE2, \"__builtin_ia32_loadapd\", v2df_ftype_pcdouble, IX86_BUILTIN_LOADAPD);\n   def_builtin (MASK_SSE2, \"__builtin_ia32_loadupd\", v2df_ftype_pcdouble, IX86_BUILTIN_LOADUPD);\n-  def_builtin (MASK_SSE2, \"__builtin_ia32_loadsd\", v2df_ftype_pcdouble, IX86_BUILTIN_LOADSD);\n-  def_builtin (MASK_SSE2, \"__builtin_ia32_storeapd\", void_ftype_pdouble_v2df, IX86_BUILTIN_STOREAPD);\n   def_builtin (MASK_SSE2, \"__builtin_ia32_storeupd\", void_ftype_pdouble_v2df, IX86_BUILTIN_STOREUPD);\n-  def_builtin (MASK_SSE2, \"__builtin_ia32_storesd\", void_ftype_pdouble_v2df, IX86_BUILTIN_STORESD);\n \n   def_builtin (MASK_SSE2, \"__builtin_ia32_loadhpd\", v2df_ftype_v2df_pcdouble, IX86_BUILTIN_LOADHPD);\n   def_builtin (MASK_SSE2, \"__builtin_ia32_loadlpd\", v2df_ftype_v2df_pcdouble, IX86_BUILTIN_LOADLPD);\n-  def_builtin (MASK_SSE2, \"__builtin_ia32_storehpd\", void_ftype_pdouble_v2df, IX86_BUILTIN_STOREHPD);\n-  def_builtin (MASK_SSE2, \"__builtin_ia32_storelpd\", void_ftype_pdouble_v2df, IX86_BUILTIN_STORELPD);\n \n   def_builtin (MASK_SSE2, \"__builtin_ia32_movmskpd\", int_ftype_v2df, IX86_BUILTIN_MOVMSKPD);\n   def_builtin (MASK_SSE2, \"__builtin_ia32_pmovmskb128\", int_ftype_v16qi, IX86_BUILTIN_PMOVMSKB128);\n@@ -13137,28 +13529,16 @@ ix86_init_mmx_sse_builtins (void)\n   def_builtin (MASK_SSE2, \"__builtin_ia32_cvtsd2ss\", v4sf_ftype_v4sf_v2df, IX86_BUILTIN_CVTSD2SS);\n   def_builtin (MASK_SSE2, \"__builtin_ia32_cvtss2sd\", v2df_ftype_v2df_v4sf, IX86_BUILTIN_CVTSS2SD);\n \n-  def_builtin (MASK_SSE2, \"__builtin_ia32_setpd1\", v2df_ftype_double, IX86_BUILTIN_SETPD1);\n-  def_builtin (MASK_SSE2, \"__builtin_ia32_setpd\", v2df_ftype_double_double, IX86_BUILTIN_SETPD);\n-  def_builtin (MASK_SSE2, \"__builtin_ia32_setzeropd\", ti_ftype_void, IX86_BUILTIN_CLRPD);\n-  def_builtin (MASK_SSE2, \"__builtin_ia32_loadpd1\", v2df_ftype_pcdouble, IX86_BUILTIN_LOADPD1);\n-  def_builtin (MASK_SSE2, \"__builtin_ia32_loadrpd\", v2df_ftype_pcdouble, IX86_BUILTIN_LOADRPD);\n-  def_builtin (MASK_SSE2, \"__builtin_ia32_storepd1\", void_ftype_pdouble_v2df, IX86_BUILTIN_STOREPD1);\n-  def_builtin (MASK_SSE2, \"__builtin_ia32_storerpd\", void_ftype_pdouble_v2df, IX86_BUILTIN_STORERPD);\n-\n   def_builtin (MASK_SSE2, \"__builtin_ia32_clflush\", void_ftype_pcvoid, IX86_BUILTIN_CLFLUSH);\n   def_builtin (MASK_SSE2, \"__builtin_ia32_lfence\", void_ftype_void, IX86_BUILTIN_LFENCE);\n   def_builtin (MASK_SSE2, \"__builtin_ia32_mfence\", void_ftype_void, IX86_BUILTIN_MFENCE);\n \n-  def_builtin (MASK_SSE2, \"__builtin_ia32_loaddqa\", v16qi_ftype_pcchar, IX86_BUILTIN_LOADDQA);\n   def_builtin (MASK_SSE2, \"__builtin_ia32_loaddqu\", v16qi_ftype_pcchar, IX86_BUILTIN_LOADDQU);\n   def_builtin (MASK_SSE2, \"__builtin_ia32_loadd\", v4si_ftype_pcint, IX86_BUILTIN_LOADD);\n-  def_builtin (MASK_SSE2, \"__builtin_ia32_storedqa\", void_ftype_pchar_v16qi, IX86_BUILTIN_STOREDQA);\n   def_builtin (MASK_SSE2, \"__builtin_ia32_storedqu\", void_ftype_pchar_v16qi, IX86_BUILTIN_STOREDQU);\n   def_builtin (MASK_SSE2, \"__builtin_ia32_stored\", void_ftype_pcint_v4si, IX86_BUILTIN_STORED);\n   def_builtin (MASK_SSE2, \"__builtin_ia32_movq\", v2di_ftype_v2di, IX86_BUILTIN_MOVQ);\n \n-  def_builtin (MASK_SSE, \"__builtin_ia32_setzero128\", v2di_ftype_void, IX86_BUILTIN_CLRTI);\n-\n   def_builtin (MASK_SSE2, \"__builtin_ia32_pmuludq\", di_ftype_v2si_v2si, IX86_BUILTIN_PMULUDQ);\n   def_builtin (MASK_SSE2, \"__builtin_ia32_pmuludq128\", v2di_ftype_v4si_v4si, IX86_BUILTIN_PMULUDQ128);\n \n@@ -13203,10 +13583,67 @@ ix86_init_mmx_sse_builtins (void)\n \t       IX86_BUILTIN_MOVSLDUP);\n   def_builtin (MASK_SSE3, \"__builtin_ia32_lddqu\",\n \t       v16qi_ftype_pcchar, IX86_BUILTIN_LDDQU);\n-  def_builtin (MASK_SSE3, \"__builtin_ia32_loadddup\",\n-\t       v2df_ftype_pcdouble, IX86_BUILTIN_LOADDDUP);\n-  def_builtin (MASK_SSE3, \"__builtin_ia32_movddup\",\n-\t       v2df_ftype_v2df, IX86_BUILTIN_MOVDDUP);\n+\n+  /* Access to the vec_init patterns.  */\n+  ftype = build_function_type_list (V2SI_type_node, integer_type_node,\n+\t\t\t\t    integer_type_node, NULL_TREE);\n+  def_builtin (MASK_MMX, \"__builtin_ia32_vec_init_v2si\",\n+\t       ftype, IX86_BUILTIN_VEC_INIT_V2SI);\n+\n+  ftype = build_function_type_list (V4HI_type_node, short_integer_type_node,\n+\t\t\t\t    short_integer_type_node,\n+\t\t\t\t    short_integer_type_node,\n+\t\t\t\t    short_integer_type_node, NULL_TREE);\n+  def_builtin (MASK_MMX, \"__builtin_ia32_vec_init_v4hi\",\n+\t       ftype, IX86_BUILTIN_VEC_INIT_V4HI);\n+\n+  ftype = build_function_type_list (V8QI_type_node, char_type_node,\n+\t\t\t\t    char_type_node, char_type_node,\n+\t\t\t\t    char_type_node, char_type_node,\n+\t\t\t\t    char_type_node, char_type_node,\n+\t\t\t\t    char_type_node, NULL_TREE);\n+  def_builtin (MASK_MMX, \"__builtin_ia32_vec_init_v8qi\",\n+\t       ftype, IX86_BUILTIN_VEC_INIT_V8QI);\n+\n+  /* Access to the vec_extract patterns.  */\n+  ftype = build_function_type_list (double_type_node, V2DF_type_node,\n+\t\t\t\t    integer_type_node, NULL_TREE);\n+  def_builtin (MASK_SSE, \"__builtin_ia32_vec_ext_v2df\",\n+\t       ftype, IX86_BUILTIN_VEC_EXT_V2DF);\n+\n+  ftype = build_function_type_list (long_long_integer_type_node,\n+\t\t\t\t    V2DI_type_node, integer_type_node,\n+\t\t\t\t    NULL_TREE);\n+  def_builtin (MASK_SSE, \"__builtin_ia32_vec_ext_v2di\",\n+\t       ftype, IX86_BUILTIN_VEC_EXT_V2DI);\n+\n+  ftype = build_function_type_list (float_type_node, V4SF_type_node,\n+\t\t\t\t    integer_type_node, NULL_TREE);\n+  def_builtin (MASK_SSE, \"__builtin_ia32_vec_ext_v4sf\",\n+\t       ftype, IX86_BUILTIN_VEC_EXT_V4SF);\n+\n+  ftype = build_function_type_list (intHI_type_node, V8HI_type_node,\n+\t\t\t\t    integer_type_node, NULL_TREE);\n+  def_builtin (MASK_SSE, \"__builtin_ia32_vec_ext_v8hi\",\n+\t       ftype, IX86_BUILTIN_VEC_EXT_V8HI);\n+\n+  ftype = build_function_type_list (intHI_type_node, V4HI_type_node,\n+\t\t\t\t    integer_type_node, NULL_TREE);\n+  def_builtin (MASK_SSE | MASK_3DNOW_A, \"__builtin_ia32_vec_ext_v4hi\",\n+\t       ftype, IX86_BUILTIN_VEC_EXT_V4HI);\n+\n+  /* Access to the vec_set patterns.  */\n+  ftype = build_function_type_list (V8HI_type_node, V8HI_type_node,\n+\t\t\t\t    intHI_type_node,\n+\t\t\t\t    integer_type_node, NULL_TREE);\n+  def_builtin (MASK_SSE, \"__builtin_ia32_vec_set_v8hi\",\n+\t       ftype, IX86_BUILTIN_VEC_SET_V8HI);\n+  \n+  ftype = build_function_type_list (V4HI_type_node, V4HI_type_node,\n+\t\t\t\t    intHI_type_node,\n+\t\t\t\t    integer_type_node, NULL_TREE);\n+  def_builtin (MASK_SSE | MASK_3DNOW_A, \"__builtin_ia32_vec_set_v4hi\",\n+\t       ftype, IX86_BUILTIN_VEC_SET_V4HI);\n }\n \n /* Errors in the source file can cause expand_expr to return const0_rtx\n@@ -13262,12 +13699,27 @@ ix86_expand_binop_builtin (enum insn_code icode, tree arglist, rtx target)\n   if (!(*insn_data[icode].operand[2].predicate) (op1, mode1))\n     op1 = copy_to_mode_reg (mode1, op1);\n \n+  /* ??? Using ix86_fixup_binary_operands is problematic when\n+     we've got mismatched modes.  Fake it.  */\n+\n   xops[0] = target;\n   xops[1] = op0;\n   xops[2] = op1;\n-  target = ix86_fixup_binary_operands (UNKNOWN, tmode, xops);\n \n-  pat = GEN_FCN (icode) (target, xops[1], xops[2]);\n+  if (tmode == mode0 && tmode == mode1)\n+    {\n+      target = ix86_fixup_binary_operands (UNKNOWN, tmode, xops);\n+      op0 = xops[1];\n+      op1 = xops[2];\n+    }\n+  else if (optimize || !ix86_binary_operator_ok (UNKNOWN, tmode, xops))\n+    {\n+      op0 = force_reg (mode0, op0);\n+      op1 = force_reg (mode1, op1);\n+      target = gen_reg_rtx (tmode);\n+    }\n+\n+  pat = GEN_FCN (icode) (target, op0, op1);\n   if (! pat)\n     return 0;\n   emit_insn (pat);\n@@ -13476,13 +13928,132 @@ ix86_expand_sse_comi (const struct builtin_description *d, tree arglist,\n   return SUBREG_REG (target);\n }\n \n+/* Return the integer constant in ARG.  Constrain it to be in the range\n+   of the subparts of VEC_TYPE; issue an error if not.  */\n+\n+static int\n+get_element_number (tree vec_type, tree arg)\n+{\n+  unsigned HOST_WIDE_INT elt, max = TYPE_VECTOR_SUBPARTS (vec_type) - 1;\n+\n+  if (!host_integerp (arg, 1)\n+      || (elt = tree_low_cst (arg, 1), elt > max))\n+    {\n+      error (\"selector must be an integer constant in the range 0..%i\", max);\n+      return 0;\n+    }\n+\n+  return elt;\n+}\n+\n+/* A subroutine of ix86_expand_builtin.  These builtins are a wrapper around\n+   ix86_expand_vector_init.  We DO have language-level syntax for this, in\n+   the form of  (type){ init-list }.  Except that since we can't place emms\n+   instructions from inside the compiler, we can't allow the use of MMX\n+   registers unless the user explicitly asks for it.  So we do *not* define\n+   vec_set/vec_extract/vec_init patterns for MMX modes in mmx.md.  Instead\n+   we have builtins invoked by mmintrin.h that gives us license to emit \n+   these sorts of instructions.  */\n+\n+static rtx\n+ix86_expand_vec_init_builtin (tree type, tree arglist, rtx target)\n+{\n+  enum machine_mode tmode = TYPE_MODE (type);\n+  enum machine_mode inner_mode = GET_MODE_INNER (tmode);\n+  int i, n_elt = GET_MODE_NUNITS (tmode);\n+  rtvec v = rtvec_alloc (n_elt);\n+\n+  gcc_assert (VECTOR_MODE_P (tmode));\n+\n+  for (i = 0; i < n_elt; ++i, arglist = TREE_CHAIN (arglist))\n+    {\n+      rtx x = expand_expr (TREE_VALUE (arglist), NULL_RTX, VOIDmode, 0);\n+      RTVEC_ELT (v, i) = gen_lowpart (inner_mode, x);\n+    }\n+\n+  gcc_assert (arglist == NULL);\n+\n+  if (!target || !register_operand (target, tmode))\n+    target = gen_reg_rtx (tmode);\n+\n+  ix86_expand_vector_init (true, target, gen_rtx_PARALLEL (tmode, v));\n+  return target;\n+}\n+\n+/* A subroutine of ix86_expand_builtin.  These builtins are a wrapper around\n+   ix86_expand_vector_extract.  They would be redundant (for non-MMX) if we\n+   had a language-level syntax for referencing vector elements.  */\n+\n+static rtx\n+ix86_expand_vec_ext_builtin (tree arglist, rtx target)\n+{\n+  enum machine_mode tmode, mode0;\n+  tree arg0, arg1;\n+  int elt;\n+  rtx op0;\n+\n+  arg0 = TREE_VALUE (arglist);\n+  arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+\n+  op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n+  elt = get_element_number (TREE_TYPE (arg0), arg1);\n+\n+  tmode = TYPE_MODE (TREE_TYPE (TREE_TYPE (arg0)));\n+  mode0 = TYPE_MODE (TREE_TYPE (arg0));\n+  gcc_assert (VECTOR_MODE_P (mode0));\n+\n+  op0 = force_reg (mode0, op0);\n+\n+  if (optimize || !target || !register_operand (target, tmode))\n+    target = gen_reg_rtx (tmode);\n+\n+  ix86_expand_vector_extract (true, target, op0, elt);\n+\n+  return target;\n+}\n+\n+/* A subroutine of ix86_expand_builtin.  These builtins are a wrapper around\n+   ix86_expand_vector_set.  They would be redundant (for non-MMX) if we had\n+   a language-level syntax for referencing vector elements.  */\n+\n+static rtx\n+ix86_expand_vec_set_builtin (tree arglist)\n+{\n+  enum machine_mode tmode, mode1;\n+  tree arg0, arg1, arg2;\n+  int elt;\n+  rtx op0, op1;\n+\n+  arg0 = TREE_VALUE (arglist);\n+  arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+  arg2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+\n+  tmode = TYPE_MODE (TREE_TYPE (arg0));\n+  mode1 = TYPE_MODE (TREE_TYPE (TREE_TYPE (arg0)));\n+  gcc_assert (VECTOR_MODE_P (tmode));\n+\n+  op0 = expand_expr (arg0, NULL_RTX, tmode, 0);\n+  op1 = expand_expr (arg1, NULL_RTX, mode1, 0);\n+  elt = get_element_number (TREE_TYPE (arg0), arg2);\n+\n+  if (GET_MODE (op1) != mode1 && GET_MODE (op1) != VOIDmode)\n+    op1 = convert_modes (mode1, GET_MODE (op1), op1, true);\n+\n+  op0 = force_reg (tmode, op0);\n+  op1 = force_reg (mode1, op1);\n+\n+  ix86_expand_vector_set (true, op0, op1, elt);\n+\n+  return op0;\n+}\n+\n /* Expand an expression EXP that calls a built-in function,\n    with result going to TARGET if that's convenient\n    (and in mode MODE if that's convenient).\n    SUBTARGET may be used as the target for computing one of EXP's operands.\n    IGNORE is nonzero if the value is to be ignored.  */\n \n-rtx\n+static rtx\n ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \t\t     enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t     int ignore ATTRIBUTE_UNUSED)\n@@ -13507,74 +14078,6 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n       emit_insn (gen_sse_sfence ());\n       return 0;\n \n-    case IX86_BUILTIN_PEXTRW:\n-    case IX86_BUILTIN_PEXTRW128:\n-      icode = (fcode == IX86_BUILTIN_PEXTRW\n-\t       ? CODE_FOR_mmx_pextrw\n-\t       : CODE_FOR_sse2_pextrw);\n-      arg0 = TREE_VALUE (arglist);\n-      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n-      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n-      op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n-      tmode = insn_data[icode].operand[0].mode;\n-      mode0 = insn_data[icode].operand[1].mode;\n-      mode1 = insn_data[icode].operand[2].mode;\n-\n-      if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n-\top0 = copy_to_mode_reg (mode0, op0);\n-      if (! (*insn_data[icode].operand[2].predicate) (op1, mode1))\n-\t{\n-\t  error (\"selector must be an integer constant in the range 0..%i\",\n-\t\t  fcode == IX86_BUILTIN_PEXTRW ? 3:7);\n-\t  return gen_reg_rtx (tmode);\n-\t}\n-      if (target == 0\n-\t  || GET_MODE (target) != tmode\n-\t  || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n-\ttarget = gen_reg_rtx (tmode);\n-      pat = GEN_FCN (icode) (target, op0, op1);\n-      if (! pat)\n-\treturn 0;\n-      emit_insn (pat);\n-      return target;\n-\n-    case IX86_BUILTIN_PINSRW:\n-    case IX86_BUILTIN_PINSRW128:\n-      icode = (fcode == IX86_BUILTIN_PINSRW\n-\t       ? CODE_FOR_mmx_pinsrw\n-\t       : CODE_FOR_sse2_pinsrw);\n-      arg0 = TREE_VALUE (arglist);\n-      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n-      arg2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n-      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n-      op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n-      op2 = expand_expr (arg2, NULL_RTX, VOIDmode, 0);\n-      tmode = insn_data[icode].operand[0].mode;\n-      mode0 = insn_data[icode].operand[1].mode;\n-      mode1 = insn_data[icode].operand[2].mode;\n-      mode2 = insn_data[icode].operand[3].mode;\n-\n-      if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n-\top0 = copy_to_mode_reg (mode0, op0);\n-      if ((optimize && !register_operand (op1, mode1))\n-\t  || ! (*insn_data[icode].operand[2].predicate) (op1, mode1))\n-\top1 = copy_to_mode_reg (mode1, op1);\n-      if (! (*insn_data[icode].operand[3].predicate) (op2, mode2))\n-\t{\n-\t  error (\"selector must be an integer constant in the range 0..%i\",\n-\t\t  fcode == IX86_BUILTIN_PINSRW ? 3:7);\n-\t  return const0_rtx;\n-\t}\n-      if (target == 0\n-\t  || GET_MODE (target) != tmode\n-\t  || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n-\ttarget = gen_reg_rtx (tmode);\n-      pat = GEN_FCN (icode) (target, op0, op1, op2);\n-      if (! pat)\n-\treturn 0;\n-      emit_insn (pat);\n-      return target;\n-\n     case IX86_BUILTIN_MASKMOVQ:\n     case IX86_BUILTIN_MASKMOVDQU:\n       icode = (fcode == IX86_BUILTIN_MASKMOVQ\n@@ -13613,24 +14116,12 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n     case IX86_BUILTIN_RCPSS:\n       return ix86_expand_unop1_builtin (CODE_FOR_sse_vmrcpv4sf2, arglist, target);\n \n-    case IX86_BUILTIN_LOADAPS:\n-      return ix86_expand_unop_builtin (CODE_FOR_movv4sf, arglist, target, 1);\n-\n     case IX86_BUILTIN_LOADUPS:\n       return ix86_expand_unop_builtin (CODE_FOR_sse_movups, arglist, target, 1);\n \n-    case IX86_BUILTIN_STOREAPS:\n-      return ix86_expand_store_builtin (CODE_FOR_movv4sf, arglist);\n-\n     case IX86_BUILTIN_STOREUPS:\n       return ix86_expand_store_builtin (CODE_FOR_sse_movups, arglist);\n \n-    case IX86_BUILTIN_LOADSS:\n-      return ix86_expand_unop_builtin (CODE_FOR_sse_loadss, arglist, target, 1);\n-\n-    case IX86_BUILTIN_STORESS:\n-      return ix86_expand_store_builtin (CODE_FOR_sse_storess, arglist);\n-\n     case IX86_BUILTIN_LOADHPS:\n     case IX86_BUILTIN_LOADLPS:\n     case IX86_BUILTIN_LOADHPD:\n@@ -13661,12 +14152,8 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \n     case IX86_BUILTIN_STOREHPS:\n     case IX86_BUILTIN_STORELPS:\n-    case IX86_BUILTIN_STOREHPD:\n-    case IX86_BUILTIN_STORELPD:\n       icode = (fcode == IX86_BUILTIN_STOREHPS ? CODE_FOR_sse_storehps\n-\t       : fcode == IX86_BUILTIN_STORELPS ? CODE_FOR_sse_storelps\n-\t       : fcode == IX86_BUILTIN_STOREHPD ? CODE_FOR_sse2_storehpd\n-\t       : CODE_FOR_sse2_storelpd);\n+\t       : CODE_FOR_sse_storelps);\n       arg0 = TREE_VALUE (arglist);\n       arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n       op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n@@ -13879,75 +14366,13 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n     case IX86_BUILTIN_PSWAPDSF:\n       return ix86_expand_unop_builtin (CODE_FOR_mmx_pswapdv2sf2, arglist, target, 0);\n \n-    case IX86_BUILTIN_SSE_ZERO:\n-      return CONST0_RTX (V4SFmode);\n-\n-    case IX86_BUILTIN_MMX_ZERO:\n-      return const0_rtx;\n-\n-    case IX86_BUILTIN_CLRTI:\n-      return const0_rtx;\n-\n     case IX86_BUILTIN_SQRTSD:\n       return ix86_expand_unop1_builtin (CODE_FOR_sse2_vmsqrtv2df2, arglist, target);\n-    case IX86_BUILTIN_LOADAPD:\n-      return ix86_expand_unop_builtin (CODE_FOR_movv2df, arglist, target, 1);\n     case IX86_BUILTIN_LOADUPD:\n       return ix86_expand_unop_builtin (CODE_FOR_sse2_movupd, arglist, target, 1);\n-\n-    case IX86_BUILTIN_STOREAPD:\n-      return ix86_expand_store_builtin (CODE_FOR_movv2df, arglist);\n     case IX86_BUILTIN_STOREUPD:\n       return ix86_expand_store_builtin (CODE_FOR_sse2_movupd, arglist);\n \n-    case IX86_BUILTIN_LOADSD:\n-      return ix86_expand_unop_builtin (CODE_FOR_sse2_loadsd, arglist, target, 1);\n-\n-    case IX86_BUILTIN_STORESD:\n-      return ix86_expand_store_builtin (CODE_FOR_sse2_storelpd, arglist);\n-\n-    case IX86_BUILTIN_SETPD1:\n-      target = assign_386_stack_local (DFmode, 0);\n-      arg0 = TREE_VALUE (arglist);\n-      emit_move_insn (adjust_address (target, DFmode, 0),\n-\t\t      expand_expr (arg0, NULL_RTX, VOIDmode, 0));\n-      op0 = gen_reg_rtx (V2DFmode);\n-      emit_insn (gen_sse2_loadsd (op0, adjust_address (target, V2DFmode, 0)));\n-      emit_insn (gen_sse2_shufpd (op0, op0, op0, const0_rtx));\n-      return op0;\n-\n-    case IX86_BUILTIN_SETPD:\n-      target = assign_386_stack_local (V2DFmode, 0);\n-      arg0 = TREE_VALUE (arglist);\n-      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n-      emit_move_insn (adjust_address (target, DFmode, 0),\n-\t\t      expand_expr (arg0, NULL_RTX, VOIDmode, 0));\n-      emit_move_insn (adjust_address (target, DFmode, 8),\n-\t\t      expand_expr (arg1, NULL_RTX, VOIDmode, 0));\n-      op0 = gen_reg_rtx (V2DFmode);\n-      emit_move_insn (op0, target);\n-      return op0;\n-\n-    case IX86_BUILTIN_LOADRPD:\n-      target = ix86_expand_unop_builtin (CODE_FOR_movv2df, arglist,\n-\t\t\t\t\t gen_reg_rtx (V2DFmode), 1);\n-      emit_insn (gen_sse2_shufpd (target, target, target, const1_rtx));\n-      return target;\n-\n-    case IX86_BUILTIN_LOADPD1:\n-      target = ix86_expand_unop_builtin (CODE_FOR_sse2_loadsd, arglist,\n-\t\t\t\t\t gen_reg_rtx (V2DFmode), 1);\n-      emit_insn (gen_sse2_shufpd (target, target, target, const0_rtx));\n-      return target;\n-\n-    case IX86_BUILTIN_STOREPD1:\n-      return ix86_expand_store_builtin (CODE_FOR_movv2df, arglist);\n-    case IX86_BUILTIN_STORERPD:\n-      return ix86_expand_store_builtin (CODE_FOR_movv2df, arglist);\n-\n-    case IX86_BUILTIN_CLRPD:\n-      return CONST0_RTX (V2DFmode);\n-\n     case IX86_BUILTIN_MFENCE:\n \temit_insn (gen_sse2_mfence ());\n \treturn 0;\n@@ -13972,15 +14397,11 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n     case IX86_BUILTIN_MOVNTI:\n       return ix86_expand_store_builtin (CODE_FOR_sse2_movntsi, arglist);\n \n-    case IX86_BUILTIN_LOADDQA:\n-      return ix86_expand_unop_builtin (CODE_FOR_movv2di, arglist, target, 1);\n     case IX86_BUILTIN_LOADDQU:\n       return ix86_expand_unop_builtin (CODE_FOR_sse2_movdqu, arglist, target, 1);\n     case IX86_BUILTIN_LOADD:\n       return ix86_expand_unop_builtin (CODE_FOR_sse2_loadd, arglist, target, 1);\n \n-    case IX86_BUILTIN_STOREDQA:\n-      return ix86_expand_store_builtin (CODE_FOR_movv2di, arglist);\n     case IX86_BUILTIN_STOREDQU:\n       return ix86_expand_store_builtin (CODE_FOR_sse2_movdqu, arglist);\n     case IX86_BUILTIN_STORED:\n@@ -14014,12 +14435,25 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n       emit_insn (gen_sse3_mwait (op0, op1));\n       return 0;\n \n-    case IX86_BUILTIN_LOADDDUP:\n-      return ix86_expand_unop_builtin (CODE_FOR_sse3_loadddup, arglist, target, 1);\n-\n     case IX86_BUILTIN_LDDQU:\n-      return ix86_expand_unop_builtin (CODE_FOR_sse3_lddqu, arglist, target,\n-\t\t\t\t       1);\n+      return ix86_expand_unop_builtin (CODE_FOR_sse3_lddqu, arglist,\n+\t\t\t\t       target, 1);\n+\n+    case IX86_BUILTIN_VEC_INIT_V2SI:\n+    case IX86_BUILTIN_VEC_INIT_V4HI:\n+    case IX86_BUILTIN_VEC_INIT_V8QI:\n+      return ix86_expand_vec_init_builtin (TREE_TYPE (exp), arglist, target);\n+\n+    case IX86_BUILTIN_VEC_EXT_V2DF:\n+    case IX86_BUILTIN_VEC_EXT_V2DI:\n+    case IX86_BUILTIN_VEC_EXT_V4SF:\n+    case IX86_BUILTIN_VEC_EXT_V8HI:\n+    case IX86_BUILTIN_VEC_EXT_V4HI:\n+      return ix86_expand_vec_ext_builtin (arglist, target);\n+\n+    case IX86_BUILTIN_VEC_SET_V8HI:\n+    case IX86_BUILTIN_VEC_SET_V4HI:\n+      return ix86_expand_vec_set_builtin (arglist);\n \n     default:\n       break;\n@@ -15382,100 +15816,670 @@ x86_emit_floatuns (rtx operands[2])\n \n   emit_label (donelab);\n }\n+\f\n+/* A subroutine of ix86_expand_vector_init.  Store into TARGET a vector\n+   with all elements equal to VAR.  Return true if successful.  */\n+\n+static bool\n+ix86_expand_vector_init_duplicate (bool mmx_ok, enum machine_mode mode,\n+\t\t\t\t   rtx target, rtx val)\n+{\n+  enum machine_mode smode, wsmode, wvmode;\n+  rtx x;\n+\n+  switch (mode)\n+    {\n+    case V2SImode:\n+    case V2SFmode:\n+      if (!mmx_ok && !TARGET_SSE)\n+\treturn false;\n+      /* FALLTHRU */\n+\n+    case V2DFmode:\n+    case V2DImode:\n+    case V4SFmode:\n+    case V4SImode:\n+      val = force_reg (GET_MODE_INNER (mode), val);\n+      x = gen_rtx_VEC_DUPLICATE (mode, val);\n+      emit_insn (gen_rtx_SET (VOIDmode, target, x));\n+      return true;\n+\n+    case V4HImode:\n+      if (!mmx_ok)\n+\treturn false;\n+      val = gen_lowpart (SImode, val);\n+      x = gen_rtx_TRUNCATE (HImode, val);\n+      x = gen_rtx_VEC_DUPLICATE (mode, x);\n+      emit_insn (gen_rtx_SET (VOIDmode, target, x));\n+      return true;\n+\n+    case V8QImode:\n+      if (!mmx_ok)\n+\treturn false;\n+      smode = QImode;\n+      wsmode = HImode;\n+      wvmode = V4HImode;\n+      goto widen;\n+    case V8HImode:\n+      smode = HImode;\n+      wsmode = SImode;\n+      wvmode = V4SImode;\n+      goto widen;\n+    case V16QImode:\n+      smode = QImode;\n+      wsmode = HImode;\n+      wvmode = V8HImode;\n+      goto widen;\n+    widen:\n+      /* Replicate the value once into the next wider mode and recurse.  */\n+      val = convert_modes (wsmode, smode, val, true);\n+      x = expand_simple_binop (wsmode, ASHIFT, val,\n+\t\t\t       GEN_INT (GET_MODE_BITSIZE (smode)),\n+\t\t\t       NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+      val = expand_simple_binop (wsmode, IOR, val, x, x, 1, OPTAB_LIB_WIDEN);\n+\n+      x = gen_reg_rtx (wvmode);\n+      if (!ix86_expand_vector_init_duplicate (mmx_ok, wvmode, x, val))\n+\tgcc_unreachable ();\n+      emit_move_insn (target, gen_lowpart (mode, x));\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* A subroutine of ix86_expand_vector_init.  Store into TARGET a vector\n+   whose low element is VAR, and other elements are zero.  Return true\n+   if successful.  */\n+\n+static bool\n+ix86_expand_vector_init_low_nonzero (bool mmx_ok, enum machine_mode mode,\n+\t\t\t\t     rtx target, rtx var)\n+{\n+  enum machine_mode vsimode;\n+  rtx x;\n+\n+  switch (mode)\n+    {\n+    case V2SFmode:\n+    case V2SImode:\n+      if (!mmx_ok && !TARGET_SSE)\n+\treturn false;\n+      /* FALLTHRU */\n+\n+    case V2DFmode:\n+    case V2DImode:\n+      var = force_reg (GET_MODE_INNER (mode), var);\n+      x = gen_rtx_VEC_CONCAT (mode, var, CONST0_RTX (GET_MODE_INNER (mode)));\n+      emit_insn (gen_rtx_SET (VOIDmode, target, x));\n+      return true;\n+\n+    case V4SFmode:\n+    case V4SImode:\n+      var = force_reg (GET_MODE_INNER (mode), var);\n+      x = gen_rtx_VEC_DUPLICATE (mode, var);\n+      x = gen_rtx_VEC_MERGE (mode, x, CONST0_RTX (mode), const1_rtx);\n+      emit_insn (gen_rtx_SET (VOIDmode, target, x));\n+      return true;\n+\n+    case V8HImode:\n+    case V16QImode:\n+      vsimode = V4SImode;\n+      goto widen;\n+    case V4HImode:\n+    case V8QImode:\n+      if (!mmx_ok)\n+\treturn false;\n+      vsimode = V2SImode;\n+      goto widen;\n+    widen:\n+      /* Zero extend the variable element to SImode and recurse.  */\n+      var = convert_modes (SImode, GET_MODE_INNER (mode), var, true);\n+\n+      x = gen_reg_rtx (vsimode);\n+      if (!ix86_expand_vector_init_low_nonzero (mmx_ok, vsimode, x, var))\n+\tgcc_unreachable ();\n+\n+      emit_move_insn (target, gen_lowpart (mode, x));\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* A subroutine of ix86_expand_vector_init.  Store into TARGET a vector\n+   consisting of the values in VALS.  It is known that all elements\n+   except ONE_VAR are constants.  Return true if successful.  */\n+\n+static bool\n+ix86_expand_vector_init_one_var (bool mmx_ok, enum machine_mode mode,\n+\t\t\t\t rtx target, rtx vals, int one_var)\n+{\n+  rtx var = XVECEXP (vals, 0, one_var);\n+  enum machine_mode wmode;\n+  rtx const_vec, x;\n+\n+  XVECEXP (vals, 0, one_var) = CONST0_RTX (GET_MODE_INNER (mode));\n+  const_vec = gen_rtx_CONST_VECTOR (mode, XVEC (vals, 0)); \n+\n+  switch (mode)\n+    {\n+    case V2DFmode:\n+    case V2DImode:\n+    case V2SFmode:\n+    case V2SImode:\n+      /* For the two element vectors, it's just as easy to use\n+\t the general case.  */\n+      return false;\n+\n+    case V4SFmode:\n+    case V4SImode:\n+    case V8HImode:\n+    case V4HImode:\n+      break;\n+\n+    case V16QImode:\n+      wmode = V8HImode;\n+      goto widen;\n+    case V8QImode:\n+      wmode = V4HImode;\n+      goto widen;\n+    widen:\n+      /* There's no way to set one QImode entry easily.  Combine\n+\t the variable value with its adjacent constant value, and\n+\t promote to an HImode set.  */\n+      x = XVECEXP (vals, 0, one_var ^ 1);\n+      if (one_var & 1)\n+\t{\n+\t  var = convert_modes (HImode, QImode, var, true);\n+\t  var = expand_simple_binop (HImode, ASHIFT, var, GEN_INT (8),\n+\t\t\t\t     NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+\t  x = GEN_INT (INTVAL (x) & 0xff);\n+\t}\n+      else\n+\t{\n+\t  var = convert_modes (HImode, QImode, var, true);\n+\t  x = gen_int_mode (INTVAL (x) << 8, HImode);\n+\t}\n+      if (x != const0_rtx)\n+\tvar = expand_simple_binop (HImode, IOR, var, x, var,\n+\t\t\t\t   1, OPTAB_LIB_WIDEN);\n+\n+      x = gen_reg_rtx (wmode);\n+      emit_move_insn (x, gen_lowpart (wmode, const_vec));\n+      ix86_expand_vector_set (mmx_ok, target, var, one_var >> 1);\n+\n+      emit_move_insn (target, gen_lowpart (mode, x));\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+\n+  emit_move_insn (target, const_vec);\n+  ix86_expand_vector_set (mmx_ok, target, var, one_var);\n+  return true;\n+}\n+\n+/* A subroutine of ix86_expand_vector_init.  Handle the most general case:\n+   all values variable, and none identical.  */\n+\n+static void\n+ix86_expand_vector_init_general (bool mmx_ok, enum machine_mode mode,\n+\t\t\t\t rtx target, rtx vals)\n+{\n+  enum machine_mode half_mode = GET_MODE_INNER (mode);\n+  rtx op0 = NULL, op1 = NULL;\n+  bool use_vec_concat = false;\n+\n+  switch (mode)\n+    {\n+    case V2SFmode:\n+    case V2SImode:\n+      if (!mmx_ok && !TARGET_SSE)\n+\tbreak;\n+      /* FALLTHRU */\n+\n+    case V2DFmode:\n+    case V2DImode:\n+      /* For the two element vectors, we always implement VEC_CONCAT.  */\n+      op0 = XVECEXP (vals, 0, 0);\n+      op1 = XVECEXP (vals, 0, 1);\n+      use_vec_concat = true;\n+      break;\n+\n+    case V4SFmode:\n+      half_mode = V2SFmode;\n+      goto half;\n+    case V4SImode:\n+      half_mode = V2SImode;\n+      goto half;\n+    half:\n+      {\n+\trtvec v;\n+\n+\t/* For V4SF and V4SI, we implement a concat of two V2 vectors.\n+\t   Recurse to load the two halves.  */\n+\n+\top0 = gen_reg_rtx (half_mode);\n+\tv = gen_rtvec (2, XVECEXP (vals, 0, 0), XVECEXP (vals, 0, 1));\n+\tix86_expand_vector_init (false, op0, gen_rtx_PARALLEL (half_mode, v));\n+\n+\top1 = gen_reg_rtx (half_mode);\n+\tv = gen_rtvec (2, XVECEXP (vals, 0, 2), XVECEXP (vals, 0, 3));\n+\tix86_expand_vector_init (false, op1, gen_rtx_PARALLEL (half_mode, v));\n+\n+\tuse_vec_concat = true;\n+      }\n+      break;\n+\n+    case V8HImode:\n+    case V16QImode:\n+    case V4HImode:\n+    case V8QImode:\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  if (use_vec_concat)\n+    {\n+      if (!register_operand (op0, half_mode))\n+\top0 = force_reg (half_mode, op0);\n+      if (!register_operand (op1, half_mode))\n+\top1 = force_reg (half_mode, op1);\n+\n+      emit_insn (gen_rtx_SET (VOIDmode, target, \n+\t\t\t      gen_rtx_VEC_CONCAT (mode, op0, op1)));\n+    }\n+  else\n+    {\n+      int i, j, n_elts, n_words, n_elt_per_word;\n+      enum machine_mode inner_mode;\n+      rtx words[4], shift;\n+\n+      inner_mode = GET_MODE_INNER (mode);\n+      n_elts = GET_MODE_NUNITS (mode);\n+      n_words = GET_MODE_SIZE (mode) / UNITS_PER_WORD;\n+      n_elt_per_word = n_elts / n_words;\n+      shift = GEN_INT (GET_MODE_BITSIZE (inner_mode));\n+\n+      for (i = 0; i < n_words; ++i)\n+\t{\n+\t  rtx word = NULL_RTX;\n+\n+\t  for (j = 0; j < n_elt_per_word; ++j)\n+\t    {\n+\t      rtx elt = XVECEXP (vals, 0, (i+1)*n_elt_per_word - j - 1);\n+\t      elt = convert_modes (word_mode, inner_mode, elt, true);\n+\n+\t      if (j == 0)\n+\t\tword = elt;\n+\t      else\n+\t\t{\n+\t\t  word = expand_simple_binop (word_mode, ASHIFT, word, shift,\n+\t\t\t\t\t      word, 1, OPTAB_LIB_WIDEN);\n+\t\t  word = expand_simple_binop (word_mode, IOR, word, elt,\n+\t\t\t\t\t      word, 1, OPTAB_LIB_WIDEN);\n+\t\t}\n+\t    }\n+\n+\t  words[i] = word;\n+\t}\n+\n+      if (n_words == 1)\n+\temit_move_insn (target, gen_lowpart (mode, words[0]));\n+      else if (n_words == 2)\n+\t{\n+\t  rtx tmp = gen_reg_rtx (mode);\n+\t  emit_insn (gen_rtx_CLOBBER (VOIDmode, tmp));\n+\t  emit_move_insn (gen_lowpart (word_mode, tmp), words[0]);\n+\t  emit_move_insn (gen_highpart (word_mode, tmp), words[1]);\n+\t  emit_move_insn (target, tmp);\n+\t}\n+      else if (n_words == 4)\n+\t{\n+\t  rtx tmp = gen_reg_rtx (V4SImode);\n+\t  vals = gen_rtx_PARALLEL (V4SImode, gen_rtvec_v (4, words));\n+\t  ix86_expand_vector_init_general (false, V4SImode, target, vals);\n+\t  emit_move_insn (target, gen_lowpart (mode, tmp));\n+\t}\n+      else\n+\tgcc_unreachable ();\n+    }\n+}\n+\n+/* Initialize vector TARGET via VALS.  Suppress the use of MMX \n+   instructions unless MMX_OK is true.  */\n \n-/* Initialize vector TARGET via VALS.  */\n void\n-ix86_expand_vector_init (rtx target, rtx vals)\n+ix86_expand_vector_init (bool mmx_ok, rtx target, rtx vals)\n {\n   enum machine_mode mode = GET_MODE (target);\n-  int elt_size = GET_MODE_SIZE (GET_MODE_INNER (mode));\n-  int n_elts = (GET_MODE_SIZE (mode) / elt_size);\n+  enum machine_mode inner_mode = GET_MODE_INNER (mode);\n+  int n_elts = GET_MODE_NUNITS (mode);\n+  int n_var = 0, one_var = -1;\n+  bool all_same = true, all_const_zero = true;\n   int i;\n+  rtx x;\n \n-  for (i = n_elts - 1; i >= 0; i--)\n-    if (GET_CODE (XVECEXP (vals, 0, i)) != CONST_INT\n-\t&& GET_CODE (XVECEXP (vals, 0, i)) != CONST_DOUBLE)\n-      break;\n+  for (i = 0; i < n_elts; ++i)\n+    {\n+      x = XVECEXP (vals, 0, i);\n+      if (!CONSTANT_P (x))\n+\tn_var++, one_var = i;\n+      else if (x != CONST0_RTX (inner_mode))\n+\tall_const_zero = false;\n+      if (i > 0 && !rtx_equal_p (x, XVECEXP (vals, 0, 0)))\n+\tall_same = false;\n+    }\n \n-  /* Few special cases first...\n-     ... constants are best loaded from constant pool.  */\n-  if (i < 0)\n+  /* Constants are best loaded from the constant pool.  */\n+  if (n_var == 0)\n     {\n       emit_move_insn (target, gen_rtx_CONST_VECTOR (mode, XVEC (vals, 0)));\n       return;\n     }\n \n-  /* ... values where only first field is non-constant are best loaded\n-     from the pool and overwritten via move later.  */\n-  if (i == 0)\n+  /* If all values are identical, broadcast the value.  */\n+  if (all_same\n+      && ix86_expand_vector_init_duplicate (mmx_ok, mode, target,\n+\t\t\t\t\t    XVECEXP (vals, 0, 0)))\n+    return;\n+\n+  /* Values where only one field is non-constant are best loaded from\n+     the pool and overwritten via move later.  */\n+  if (n_var == 1)\n     {\n-      XVECEXP (vals, 0, 0) = CONST0_RTX (GET_MODE_INNER (mode));\n-      emit_move_insn (target, gen_rtx_CONST_VECTOR (mode, XVEC (vals, 0)));\n+      if (all_const_zero && one_var == 0\n+\t  && ix86_expand_vector_init_low_nonzero (mmx_ok, mode, target,\n+\t\t\t\t\t\t  XVECEXP (vals, 0, 0)))\n+\treturn;\n+\n+      if (ix86_expand_vector_init_one_var (mmx_ok, mode, target, vals, one_var))\n+\treturn;\n+    }\n+\n+  ix86_expand_vector_init_general (mmx_ok, mode, target, vals);\n+}\n+\n+void\n+ix86_expand_vector_set (bool mmx_ok, rtx target, rtx val, int elt)\n+{\n+  enum machine_mode mode = GET_MODE (target);\n+  enum machine_mode inner_mode = GET_MODE_INNER (mode);\n+  bool use_vec_merge = false;\n+  rtx tmp;\n+\n+  switch (mode)\n+    {\n+    case V2SFmode:\n+    case V2SImode:\n+      if (!mmx_ok)\n+\tbreak;\n+      /* FALLTHRU */\n+\n+    case V2DFmode:\n+    case V2DImode:\n+      {\n+\trtx op0, op1;\n+\n+\t/* For the two element vectors, we implement a VEC_CONCAT with\n+\t   the extraction of the other element.  */\n+\n+\ttmp = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (1, GEN_INT (1 - elt)));\n+\ttmp = gen_rtx_VEC_SELECT (inner_mode, target, tmp);\n+\n+\tif (elt == 0)\n+\t  op0 = val, op1 = tmp;\n+\telse\n+\t  op0 = tmp, op1 = val;\n+\n+\ttmp = gen_rtx_VEC_CONCAT (mode, op0, op1);\n+\temit_insn (gen_rtx_SET (VOIDmode, target, tmp));\n+      }\n+      return;\n \n-      switch (GET_MODE (target))\n+    case V4SFmode:\n+      switch (elt)\n \t{\n-\tcase V2DFmode:\n-\t  emit_insn (gen_sse2_loadlpd (target, target, XVECEXP (vals, 0, 0)));\n+\tcase 0:\n+\t  use_vec_merge = true;\n \t  break;\n \n-\tcase V4SFmode:\n-\t  {\n-\t    /* ??? We can represent this better.  */\n-\t    rtx op = simplify_gen_subreg (mode, XVECEXP (vals, 0, 0),\n-\t\t\t\t          GET_MODE_INNER (mode), 0);\n-\t    op = force_reg (mode, op);\n-\t    emit_insn (gen_sse_movss (target, target, op));\n-\t  }\n-\t  break;\n+\tcase 1:\n+\t  /* tmp = op0 = A B C D */\n+\t  tmp = copy_to_reg (target);\n+\n+\t  /* op0 = C C D D */\n+\t  emit_insn (gen_sse_unpcklps (target, target, target));\n+\n+\t  /* op0 = C C D X */\n+\t  ix86_expand_vector_set (false, target, val, 0);\n+\n+\t  /* op0 = A B X D  */\n+\t  emit_insn (gen_sse_shufps_1 (target, target, tmp,\n+\t\t\t\t       GEN_INT (1), GEN_INT (0),\n+\t\t\t\t       GEN_INT (2), GEN_INT (3)));\n+\t  return;\n+\n+\tcase 2:\n+\t  tmp = copy_to_reg (target);\n+\t  ix86_expand_vector_set (false, target, val, 0);\n+\t  emit_insn (gen_sse_shufps_1 (target, target, tmp,\n+\t\t\t\t       GEN_INT (0), GEN_INT (1),\n+\t\t\t\t       GEN_INT (0), GEN_INT (3)));\n+\t  return;\n+\n+\tcase 3:\n+\t  tmp = copy_to_reg (target);\n+\t  ix86_expand_vector_set (false, target, val, 0);\n+\t  emit_insn (gen_sse_shufps_1 (target, target, tmp,\n+\t\t\t\t       GEN_INT (0), GEN_INT (1),\n+\t\t\t\t       GEN_INT (2), GEN_INT (0)));\n+\t  return;\n \n \tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      break;\n+\n+    case V4SImode:\n+      /* Element 0 handled by vec_merge below.  */\n+      if (elt == 0)\n+\t{\n+\t  use_vec_merge = true;\n \t  break;\n \t}\n+\n+      if (TARGET_SSE2)\n+\t{\n+\t  /* With SSE2, use integer shuffles to swap element 0 and ELT,\n+\t     store into element 0, then shuffle them back.  */\n+\n+\t  rtx order[4];\n+\n+\t  order[0] = GEN_INT (elt);\n+\t  order[1] = const1_rtx;\n+\t  order[2] = const2_rtx;\n+\t  order[3] = GEN_INT (3);\n+\t  order[elt] = const0_rtx;\n+\n+\t  emit_insn (gen_sse2_pshufd_1 (target, target, order[0],\n+\t\t\t\t\torder[1], order[2], order[3]));\n+\n+\t  ix86_expand_vector_set (false, target, val, 0);\n+\n+\t  emit_insn (gen_sse2_pshufd_1 (target, target, order[0],\n+\t\t\t\t\torder[1], order[2], order[3]));\n+\t}\n+      else\n+\t{\n+\t  /* For SSE1, we have to reuse the V4SF code.  */\n+\t  ix86_expand_vector_set (false, gen_lowpart (V4SFmode, target),\n+\t\t\t\t  gen_lowpart (SFmode, val), elt);\n+\t}\n       return;\n+\n+    case V8HImode:\n+      use_vec_merge = TARGET_SSE2;\n+      break;\n+    case V4HImode:\n+      use_vec_merge = mmx_ok && (TARGET_SSE || TARGET_3DNOW_A);\n+      break;\n+\n+    case V16QImode:\n+    case V8QImode:\n+    default:\n+      break;\n     }\n \n-  /* And the busy sequence doing rotations.  */\n-  switch (GET_MODE (target))\n+  if (use_vec_merge)\n     {\n-      case V2DFmode:\n+      tmp = gen_rtx_VEC_DUPLICATE (mode, val);\n+      tmp = gen_rtx_VEC_MERGE (mode, tmp, target, GEN_INT (1 << elt));\n+      emit_insn (gen_rtx_SET (VOIDmode, target, tmp));\n+    }\n+  else\n+    {\n+      rtx mem = assign_stack_temp (mode, GET_MODE_SIZE (mode), false);\n+\n+      emit_move_insn (mem, target);\n+\n+      tmp = adjust_address (mem, inner_mode, elt*GET_MODE_SIZE (inner_mode));\n+      emit_move_insn (tmp, val);\n+\n+      emit_move_insn (target, mem);\n+    }\n+}\n+\n+void\n+ix86_expand_vector_extract (bool mmx_ok, rtx target, rtx vec, int elt)\n+{\n+  enum machine_mode mode = GET_MODE (vec);\n+  enum machine_mode inner_mode = GET_MODE_INNER (mode);\n+  bool use_vec_extr = false;\n+  rtx tmp;\n+\n+  switch (mode)\n+    {\n+    case V2SImode:\n+    case V2SFmode:\n+      if (!mmx_ok)\n+\tbreak;\n+      /* FALLTHRU */\n+\n+    case V2DFmode:\n+    case V2DImode:\n+      use_vec_extr = true;\n+      break;\n+\n+    case V4SFmode:\n+      switch (elt)\n \t{\n-\t  rtx vecop0 =\n-\t    simplify_gen_subreg (V2DFmode, XVECEXP (vals, 0, 0), DFmode, 0);\n-\t  rtx vecop1 =\n-\t    simplify_gen_subreg (V2DFmode, XVECEXP (vals, 0, 1), DFmode, 0);\n+\tcase 0:\n+\t  tmp = vec;\n+\t  break;\n \n-\t  vecop0 = force_reg (V2DFmode, vecop0);\n-\t  vecop1 = force_reg (V2DFmode, vecop1);\n-\t  emit_insn (gen_sse2_unpcklpd (target, vecop0, vecop1));\n+\tcase 1:\n+\tcase 3:\n+\t  tmp = gen_reg_rtx (mode);\n+\t  emit_insn (gen_sse_shufps_1 (tmp, vec, vec,\n+\t\t\t\t       GEN_INT (elt), GEN_INT (elt),\n+\t\t\t\t       GEN_INT (elt), GEN_INT (elt)));\n+\t  break;\n+\n+\tcase 2:\n+\t  tmp = gen_reg_rtx (mode);\n+\t  emit_insn (gen_sse_unpckhps (tmp, vec, vec));\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n-\tbreak;\n-      case V4SFmode:\n+      vec = tmp;\n+      use_vec_extr = true;\n+      break;\n+\n+    case V4SImode:\n+      if (TARGET_SSE2)\n \t{\n-\t  rtx vecop0 =\n-\t    simplify_gen_subreg (V4SFmode, XVECEXP (vals, 0, 0), SFmode, 0);\n-\t  rtx vecop1 =\n-\t    simplify_gen_subreg (V4SFmode, XVECEXP (vals, 0, 1), SFmode, 0);\n-\t  rtx vecop2 =\n-\t    simplify_gen_subreg (V4SFmode, XVECEXP (vals, 0, 2), SFmode, 0);\n-\t  rtx vecop3 =\n-\t    simplify_gen_subreg (V4SFmode, XVECEXP (vals, 0, 3), SFmode, 0);\n-\t  rtx tmp1 = gen_reg_rtx (V4SFmode);\n-\t  rtx tmp2 = gen_reg_rtx (V4SFmode);\n-\n-\t  vecop0 = force_reg (V4SFmode, vecop0);\n-\t  vecop1 = force_reg (V4SFmode, vecop1);\n-\t  vecop2 = force_reg (V4SFmode, vecop2);\n-\t  vecop3 = force_reg (V4SFmode, vecop3);\n-\t  emit_insn (gen_sse_unpcklps (tmp1, vecop1, vecop3));\n-\t  emit_insn (gen_sse_unpcklps (tmp2, vecop0, vecop2));\n-\t  emit_insn (gen_sse_unpcklps (target, tmp2, tmp1));\n+\t  switch (elt)\n+\t    {\n+\t    case 0:\n+\t      tmp = vec;\n+\t      break;\n+\n+\t    case 1:\n+\t    case 3:\n+\t      tmp = gen_reg_rtx (mode);\n+\t      emit_insn (gen_sse2_pshufd_1 (tmp, vec,\n+\t\t\t\t\t    GEN_INT (elt), GEN_INT (elt),\n+\t\t\t\t\t    GEN_INT (elt), GEN_INT (elt)));\n+\t      break;\n+\n+\t    case 2:\n+\t      tmp = gen_reg_rtx (mode);\n+\t      emit_insn (gen_sse2_punpckhdq (tmp, vec, vec));\n+\t      break;\n+\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t  vec = tmp;\n+\t  use_vec_extr = true;\n \t}\n-\tbreak;\n-      default:\n-\tabort ();\n+      else\n+\t{\n+\t  /* For SSE1, we have to reuse the V4SF code.  */\n+\t  ix86_expand_vector_extract (false, gen_lowpart (SFmode, target),\n+\t\t\t\t      gen_lowpart (V4SFmode, vec), elt);\n+\t  return;\n+\t}\n+      break;\n+\n+    case V8HImode:\n+      use_vec_extr = TARGET_SSE2;\n+      break;\n+    case V4HImode:\n+      use_vec_extr = mmx_ok && (TARGET_SSE || TARGET_3DNOW_A);\n+      break;\n+\n+    case V16QImode:\n+    case V8QImode:\n+      /* ??? Could extract the appropriate HImode element and shift.  */\n+    default:\n+      break;\n     }\n-}\n \n+  if (use_vec_extr)\n+    {\n+      tmp = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (1, GEN_INT (elt)));\n+      tmp = gen_rtx_VEC_SELECT (inner_mode, vec, tmp);\n+\n+      /* Let the rtl optimizers know about the zero extension performed.  */\n+      if (inner_mode == HImode)\n+\t{\n+\t  tmp = gen_rtx_ZERO_EXTEND (SImode, tmp);\n+\t  target = gen_lowpart (SImode, target);\n+\t}\n+\n+      emit_insn (gen_rtx_SET (VOIDmode, target, tmp));\n+    }\n+  else\n+    {\n+      rtx mem = assign_stack_temp (mode, GET_MODE_SIZE (mode), false);\n+\n+      emit_move_insn (mem, vec);\n+\n+      tmp = adjust_address (mem, inner_mode, elt*GET_MODE_SIZE (inner_mode));\n+      emit_move_insn (target, tmp);\n+    }\n+}\n+\f\n /* Implements target hook vector_mode_supported_p.  */\n static bool\n ix86_vector_mode_supported_p (enum machine_mode mode)"}, {"sha": "d359fd4c9c0a48118b865b98e614945e7444ed78", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 0, "deletions": 458, "changes": 458, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb701deb655a1ae74c35f2719d33c701544c7ccd/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb701deb655a1ae74c35f2719d33c701544c7ccd/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=eb701deb655a1ae74c35f2719d33c701544c7ccd", "patch": "@@ -2031,464 +2031,6 @@ do {\t\t\t\t\t\t\t\\\n    goto LABEL;\t\t\t\t\t\t\\\n } while (0)\n \f\n-/* Codes for all the SSE/MMX builtins.  */\n-enum ix86_builtins\n-{\n-  IX86_BUILTIN_ADDPS,\n-  IX86_BUILTIN_ADDSS,\n-  IX86_BUILTIN_DIVPS,\n-  IX86_BUILTIN_DIVSS,\n-  IX86_BUILTIN_MULPS,\n-  IX86_BUILTIN_MULSS,\n-  IX86_BUILTIN_SUBPS,\n-  IX86_BUILTIN_SUBSS,\n-\n-  IX86_BUILTIN_CMPEQPS,\n-  IX86_BUILTIN_CMPLTPS,\n-  IX86_BUILTIN_CMPLEPS,\n-  IX86_BUILTIN_CMPGTPS,\n-  IX86_BUILTIN_CMPGEPS,\n-  IX86_BUILTIN_CMPNEQPS,\n-  IX86_BUILTIN_CMPNLTPS,\n-  IX86_BUILTIN_CMPNLEPS,\n-  IX86_BUILTIN_CMPNGTPS,\n-  IX86_BUILTIN_CMPNGEPS,\n-  IX86_BUILTIN_CMPORDPS,\n-  IX86_BUILTIN_CMPUNORDPS,\n-  IX86_BUILTIN_CMPNEPS,\n-  IX86_BUILTIN_CMPEQSS,\n-  IX86_BUILTIN_CMPLTSS,\n-  IX86_BUILTIN_CMPLESS,\n-  IX86_BUILTIN_CMPNEQSS,\n-  IX86_BUILTIN_CMPNLTSS,\n-  IX86_BUILTIN_CMPNLESS,\n-  IX86_BUILTIN_CMPNGTSS,\n-  IX86_BUILTIN_CMPNGESS,\n-  IX86_BUILTIN_CMPORDSS,\n-  IX86_BUILTIN_CMPUNORDSS,\n-  IX86_BUILTIN_CMPNESS,\n-\n-  IX86_BUILTIN_COMIEQSS,\n-  IX86_BUILTIN_COMILTSS,\n-  IX86_BUILTIN_COMILESS,\n-  IX86_BUILTIN_COMIGTSS,\n-  IX86_BUILTIN_COMIGESS,\n-  IX86_BUILTIN_COMINEQSS,\n-  IX86_BUILTIN_UCOMIEQSS,\n-  IX86_BUILTIN_UCOMILTSS,\n-  IX86_BUILTIN_UCOMILESS,\n-  IX86_BUILTIN_UCOMIGTSS,\n-  IX86_BUILTIN_UCOMIGESS,\n-  IX86_BUILTIN_UCOMINEQSS,\n-\n-  IX86_BUILTIN_CVTPI2PS,\n-  IX86_BUILTIN_CVTPS2PI,\n-  IX86_BUILTIN_CVTSI2SS,\n-  IX86_BUILTIN_CVTSI642SS,\n-  IX86_BUILTIN_CVTSS2SI,\n-  IX86_BUILTIN_CVTSS2SI64,\n-  IX86_BUILTIN_CVTTPS2PI,\n-  IX86_BUILTIN_CVTTSS2SI,\n-  IX86_BUILTIN_CVTTSS2SI64,\n-\n-  IX86_BUILTIN_MAXPS,\n-  IX86_BUILTIN_MAXSS,\n-  IX86_BUILTIN_MINPS,\n-  IX86_BUILTIN_MINSS,\n-\n-  IX86_BUILTIN_LOADAPS,\n-  IX86_BUILTIN_LOADUPS,\n-  IX86_BUILTIN_STOREAPS,\n-  IX86_BUILTIN_STOREUPS,\n-  IX86_BUILTIN_LOADSS,\n-  IX86_BUILTIN_STORESS,\n-  IX86_BUILTIN_MOVSS,\n-\n-  IX86_BUILTIN_MOVHLPS,\n-  IX86_BUILTIN_MOVLHPS,\n-  IX86_BUILTIN_LOADHPS,\n-  IX86_BUILTIN_LOADLPS,\n-  IX86_BUILTIN_STOREHPS,\n-  IX86_BUILTIN_STORELPS,\n-\n-  IX86_BUILTIN_MASKMOVQ,\n-  IX86_BUILTIN_MOVMSKPS,\n-  IX86_BUILTIN_PMOVMSKB,\n-\n-  IX86_BUILTIN_MOVNTPS,\n-  IX86_BUILTIN_MOVNTQ,\n-\n-  IX86_BUILTIN_LOADDQA,\n-  IX86_BUILTIN_LOADDQU,\n-  IX86_BUILTIN_STOREDQA,\n-  IX86_BUILTIN_STOREDQU,\n-  IX86_BUILTIN_MOVQ,\n-  IX86_BUILTIN_LOADD,\n-  IX86_BUILTIN_STORED,\n-\n-  IX86_BUILTIN_CLRTI,\n-\n-  IX86_BUILTIN_PACKSSWB,\n-  IX86_BUILTIN_PACKSSDW,\n-  IX86_BUILTIN_PACKUSWB,\n-\n-  IX86_BUILTIN_PADDB,\n-  IX86_BUILTIN_PADDW,\n-  IX86_BUILTIN_PADDD,\n-  IX86_BUILTIN_PADDQ,\n-  IX86_BUILTIN_PADDSB,\n-  IX86_BUILTIN_PADDSW,\n-  IX86_BUILTIN_PADDUSB,\n-  IX86_BUILTIN_PADDUSW,\n-  IX86_BUILTIN_PSUBB,\n-  IX86_BUILTIN_PSUBW,\n-  IX86_BUILTIN_PSUBD,\n-  IX86_BUILTIN_PSUBQ,\n-  IX86_BUILTIN_PSUBSB,\n-  IX86_BUILTIN_PSUBSW,\n-  IX86_BUILTIN_PSUBUSB,\n-  IX86_BUILTIN_PSUBUSW,\n-\n-  IX86_BUILTIN_PAND,\n-  IX86_BUILTIN_PANDN,\n-  IX86_BUILTIN_POR,\n-  IX86_BUILTIN_PXOR,\n-\n-  IX86_BUILTIN_PAVGB,\n-  IX86_BUILTIN_PAVGW,\n-\n-  IX86_BUILTIN_PCMPEQB,\n-  IX86_BUILTIN_PCMPEQW,\n-  IX86_BUILTIN_PCMPEQD,\n-  IX86_BUILTIN_PCMPGTB,\n-  IX86_BUILTIN_PCMPGTW,\n-  IX86_BUILTIN_PCMPGTD,\n-\n-  IX86_BUILTIN_PEXTRW,\n-  IX86_BUILTIN_PINSRW,\n-\n-  IX86_BUILTIN_PMADDWD,\n-\n-  IX86_BUILTIN_PMAXSW,\n-  IX86_BUILTIN_PMAXUB,\n-  IX86_BUILTIN_PMINSW,\n-  IX86_BUILTIN_PMINUB,\n-\n-  IX86_BUILTIN_PMULHUW,\n-  IX86_BUILTIN_PMULHW,\n-  IX86_BUILTIN_PMULLW,\n-\n-  IX86_BUILTIN_PSADBW,\n-  IX86_BUILTIN_PSHUFW,\n-\n-  IX86_BUILTIN_PSLLW,\n-  IX86_BUILTIN_PSLLD,\n-  IX86_BUILTIN_PSLLQ,\n-  IX86_BUILTIN_PSRAW,\n-  IX86_BUILTIN_PSRAD,\n-  IX86_BUILTIN_PSRLW,\n-  IX86_BUILTIN_PSRLD,\n-  IX86_BUILTIN_PSRLQ,\n-  IX86_BUILTIN_PSLLWI,\n-  IX86_BUILTIN_PSLLDI,\n-  IX86_BUILTIN_PSLLQI,\n-  IX86_BUILTIN_PSRAWI,\n-  IX86_BUILTIN_PSRADI,\n-  IX86_BUILTIN_PSRLWI,\n-  IX86_BUILTIN_PSRLDI,\n-  IX86_BUILTIN_PSRLQI,\n-\n-  IX86_BUILTIN_PUNPCKHBW,\n-  IX86_BUILTIN_PUNPCKHWD,\n-  IX86_BUILTIN_PUNPCKHDQ,\n-  IX86_BUILTIN_PUNPCKLBW,\n-  IX86_BUILTIN_PUNPCKLWD,\n-  IX86_BUILTIN_PUNPCKLDQ,\n-\n-  IX86_BUILTIN_SHUFPS,\n-\n-  IX86_BUILTIN_RCPPS,\n-  IX86_BUILTIN_RCPSS,\n-  IX86_BUILTIN_RSQRTPS,\n-  IX86_BUILTIN_RSQRTSS,\n-  IX86_BUILTIN_SQRTPS,\n-  IX86_BUILTIN_SQRTSS,\n-\n-  IX86_BUILTIN_UNPCKHPS,\n-  IX86_BUILTIN_UNPCKLPS,\n-\n-  IX86_BUILTIN_ANDPS,\n-  IX86_BUILTIN_ANDNPS,\n-  IX86_BUILTIN_ORPS,\n-  IX86_BUILTIN_XORPS,\n-\n-  IX86_BUILTIN_EMMS,\n-  IX86_BUILTIN_LDMXCSR,\n-  IX86_BUILTIN_STMXCSR,\n-  IX86_BUILTIN_SFENCE,\n-\n-  /* 3DNow! Original */\n-  IX86_BUILTIN_FEMMS,\n-  IX86_BUILTIN_PAVGUSB,\n-  IX86_BUILTIN_PF2ID,\n-  IX86_BUILTIN_PFACC,\n-  IX86_BUILTIN_PFADD,\n-  IX86_BUILTIN_PFCMPEQ,\n-  IX86_BUILTIN_PFCMPGE,\n-  IX86_BUILTIN_PFCMPGT,\n-  IX86_BUILTIN_PFMAX,\n-  IX86_BUILTIN_PFMIN,\n-  IX86_BUILTIN_PFMUL,\n-  IX86_BUILTIN_PFRCP,\n-  IX86_BUILTIN_PFRCPIT1,\n-  IX86_BUILTIN_PFRCPIT2,\n-  IX86_BUILTIN_PFRSQIT1,\n-  IX86_BUILTIN_PFRSQRT,\n-  IX86_BUILTIN_PFSUB,\n-  IX86_BUILTIN_PFSUBR,\n-  IX86_BUILTIN_PI2FD,\n-  IX86_BUILTIN_PMULHRW,\n-\n-  /* 3DNow! Athlon Extensions */\n-  IX86_BUILTIN_PF2IW,\n-  IX86_BUILTIN_PFNACC,\n-  IX86_BUILTIN_PFPNACC,\n-  IX86_BUILTIN_PI2FW,\n-  IX86_BUILTIN_PSWAPDSI,\n-  IX86_BUILTIN_PSWAPDSF,\n-\n-  IX86_BUILTIN_SSE_ZERO,\n-  IX86_BUILTIN_MMX_ZERO,\n-\n-  /* SSE2 */\n-  IX86_BUILTIN_ADDPD,\n-  IX86_BUILTIN_ADDSD,\n-  IX86_BUILTIN_DIVPD,\n-  IX86_BUILTIN_DIVSD,\n-  IX86_BUILTIN_MULPD,\n-  IX86_BUILTIN_MULSD,\n-  IX86_BUILTIN_SUBPD,\n-  IX86_BUILTIN_SUBSD,\n-\n-  IX86_BUILTIN_CMPEQPD,\n-  IX86_BUILTIN_CMPLTPD,\n-  IX86_BUILTIN_CMPLEPD,\n-  IX86_BUILTIN_CMPGTPD,\n-  IX86_BUILTIN_CMPGEPD,\n-  IX86_BUILTIN_CMPNEQPD,\n-  IX86_BUILTIN_CMPNLTPD,\n-  IX86_BUILTIN_CMPNLEPD,\n-  IX86_BUILTIN_CMPNGTPD,\n-  IX86_BUILTIN_CMPNGEPD,\n-  IX86_BUILTIN_CMPORDPD,\n-  IX86_BUILTIN_CMPUNORDPD,\n-  IX86_BUILTIN_CMPNEPD,\n-  IX86_BUILTIN_CMPEQSD,\n-  IX86_BUILTIN_CMPLTSD,\n-  IX86_BUILTIN_CMPLESD,\n-  IX86_BUILTIN_CMPNEQSD,\n-  IX86_BUILTIN_CMPNLTSD,\n-  IX86_BUILTIN_CMPNLESD,\n-  IX86_BUILTIN_CMPORDSD,\n-  IX86_BUILTIN_CMPUNORDSD,\n-  IX86_BUILTIN_CMPNESD,\n-\n-  IX86_BUILTIN_COMIEQSD,\n-  IX86_BUILTIN_COMILTSD,\n-  IX86_BUILTIN_COMILESD,\n-  IX86_BUILTIN_COMIGTSD,\n-  IX86_BUILTIN_COMIGESD,\n-  IX86_BUILTIN_COMINEQSD,\n-  IX86_BUILTIN_UCOMIEQSD,\n-  IX86_BUILTIN_UCOMILTSD,\n-  IX86_BUILTIN_UCOMILESD,\n-  IX86_BUILTIN_UCOMIGTSD,\n-  IX86_BUILTIN_UCOMIGESD,\n-  IX86_BUILTIN_UCOMINEQSD,\n-\n-  IX86_BUILTIN_MAXPD,\n-  IX86_BUILTIN_MAXSD,\n-  IX86_BUILTIN_MINPD,\n-  IX86_BUILTIN_MINSD,\n-\n-  IX86_BUILTIN_ANDPD,\n-  IX86_BUILTIN_ANDNPD,\n-  IX86_BUILTIN_ORPD,\n-  IX86_BUILTIN_XORPD,\n-\n-  IX86_BUILTIN_SQRTPD,\n-  IX86_BUILTIN_SQRTSD,\n-\n-  IX86_BUILTIN_UNPCKHPD,\n-  IX86_BUILTIN_UNPCKLPD,\n-\n-  IX86_BUILTIN_SHUFPD,\n-\n-  IX86_BUILTIN_LOADAPD,\n-  IX86_BUILTIN_LOADUPD,\n-  IX86_BUILTIN_STOREAPD,\n-  IX86_BUILTIN_STOREUPD,\n-  IX86_BUILTIN_LOADSD,\n-  IX86_BUILTIN_STORESD,\n-  IX86_BUILTIN_MOVSD,\n-\n-  IX86_BUILTIN_LOADHPD,\n-  IX86_BUILTIN_LOADLPD,\n-  IX86_BUILTIN_STOREHPD,\n-  IX86_BUILTIN_STORELPD,\n-\n-  IX86_BUILTIN_CVTDQ2PD,\n-  IX86_BUILTIN_CVTDQ2PS,\n-\n-  IX86_BUILTIN_CVTPD2DQ,\n-  IX86_BUILTIN_CVTPD2PI,\n-  IX86_BUILTIN_CVTPD2PS,\n-  IX86_BUILTIN_CVTTPD2DQ,\n-  IX86_BUILTIN_CVTTPD2PI,\n-\n-  IX86_BUILTIN_CVTPI2PD,\n-  IX86_BUILTIN_CVTSI2SD,\n-  IX86_BUILTIN_CVTSI642SD,\n-\n-  IX86_BUILTIN_CVTSD2SI,\n-  IX86_BUILTIN_CVTSD2SI64,\n-  IX86_BUILTIN_CVTSD2SS,\n-  IX86_BUILTIN_CVTSS2SD,\n-  IX86_BUILTIN_CVTTSD2SI,\n-  IX86_BUILTIN_CVTTSD2SI64,\n-\n-  IX86_BUILTIN_CVTPS2DQ,\n-  IX86_BUILTIN_CVTPS2PD,\n-  IX86_BUILTIN_CVTTPS2DQ,\n-\n-  IX86_BUILTIN_MOVNTI,\n-  IX86_BUILTIN_MOVNTPD,\n-  IX86_BUILTIN_MOVNTDQ,\n-\n-  IX86_BUILTIN_SETPD1,\n-  IX86_BUILTIN_SETPD,\n-  IX86_BUILTIN_CLRPD,\n-  IX86_BUILTIN_SETRPD,\n-  IX86_BUILTIN_LOADPD1,\n-  IX86_BUILTIN_LOADRPD,\n-  IX86_BUILTIN_STOREPD1,\n-  IX86_BUILTIN_STORERPD,\n-\n-  /* SSE2 MMX */\n-  IX86_BUILTIN_MASKMOVDQU,\n-  IX86_BUILTIN_MOVMSKPD,\n-  IX86_BUILTIN_PMOVMSKB128,\n-  IX86_BUILTIN_MOVQ2DQ,\n-  IX86_BUILTIN_MOVDQ2Q,\n-\n-  IX86_BUILTIN_PACKSSWB128,\n-  IX86_BUILTIN_PACKSSDW128,\n-  IX86_BUILTIN_PACKUSWB128,\n-\n-  IX86_BUILTIN_PADDB128,\n-  IX86_BUILTIN_PADDW128,\n-  IX86_BUILTIN_PADDD128,\n-  IX86_BUILTIN_PADDQ128,\n-  IX86_BUILTIN_PADDSB128,\n-  IX86_BUILTIN_PADDSW128,\n-  IX86_BUILTIN_PADDUSB128,\n-  IX86_BUILTIN_PADDUSW128,\n-  IX86_BUILTIN_PSUBB128,\n-  IX86_BUILTIN_PSUBW128,\n-  IX86_BUILTIN_PSUBD128,\n-  IX86_BUILTIN_PSUBQ128,\n-  IX86_BUILTIN_PSUBSB128,\n-  IX86_BUILTIN_PSUBSW128,\n-  IX86_BUILTIN_PSUBUSB128,\n-  IX86_BUILTIN_PSUBUSW128,\n-\n-  IX86_BUILTIN_PAND128,\n-  IX86_BUILTIN_PANDN128,\n-  IX86_BUILTIN_POR128,\n-  IX86_BUILTIN_PXOR128,\n-\n-  IX86_BUILTIN_PAVGB128,\n-  IX86_BUILTIN_PAVGW128,\n-\n-  IX86_BUILTIN_PCMPEQB128,\n-  IX86_BUILTIN_PCMPEQW128,\n-  IX86_BUILTIN_PCMPEQD128,\n-  IX86_BUILTIN_PCMPGTB128,\n-  IX86_BUILTIN_PCMPGTW128,\n-  IX86_BUILTIN_PCMPGTD128,\n-\n-  IX86_BUILTIN_PEXTRW128,\n-  IX86_BUILTIN_PINSRW128,\n-\n-  IX86_BUILTIN_PMADDWD128,\n-\n-  IX86_BUILTIN_PMAXSW128,\n-  IX86_BUILTIN_PMAXUB128,\n-  IX86_BUILTIN_PMINSW128,\n-  IX86_BUILTIN_PMINUB128,\n-\n-  IX86_BUILTIN_PMULUDQ,\n-  IX86_BUILTIN_PMULUDQ128,\n-  IX86_BUILTIN_PMULHUW128,\n-  IX86_BUILTIN_PMULHW128,\n-  IX86_BUILTIN_PMULLW128,\n-\n-  IX86_BUILTIN_PSADBW128,\n-  IX86_BUILTIN_PSHUFHW,\n-  IX86_BUILTIN_PSHUFLW,\n-  IX86_BUILTIN_PSHUFD,\n-\n-  IX86_BUILTIN_PSLLW128,\n-  IX86_BUILTIN_PSLLD128,\n-  IX86_BUILTIN_PSLLQ128,\n-  IX86_BUILTIN_PSRAW128,\n-  IX86_BUILTIN_PSRAD128,\n-  IX86_BUILTIN_PSRLW128,\n-  IX86_BUILTIN_PSRLD128,\n-  IX86_BUILTIN_PSRLQ128,\n-  IX86_BUILTIN_PSLLDQI128,\n-  IX86_BUILTIN_PSLLWI128,\n-  IX86_BUILTIN_PSLLDI128,\n-  IX86_BUILTIN_PSLLQI128,\n-  IX86_BUILTIN_PSRAWI128,\n-  IX86_BUILTIN_PSRADI128,\n-  IX86_BUILTIN_PSRLDQI128,\n-  IX86_BUILTIN_PSRLWI128,\n-  IX86_BUILTIN_PSRLDI128,\n-  IX86_BUILTIN_PSRLQI128,\n-\n-  IX86_BUILTIN_PUNPCKHBW128,\n-  IX86_BUILTIN_PUNPCKHWD128,\n-  IX86_BUILTIN_PUNPCKHDQ128,\n-  IX86_BUILTIN_PUNPCKHQDQ128,\n-  IX86_BUILTIN_PUNPCKLBW128,\n-  IX86_BUILTIN_PUNPCKLWD128,\n-  IX86_BUILTIN_PUNPCKLDQ128,\n-  IX86_BUILTIN_PUNPCKLQDQ128,\n-\n-  IX86_BUILTIN_CLFLUSH,\n-  IX86_BUILTIN_MFENCE,\n-  IX86_BUILTIN_LFENCE,\n-\n-  /* Prescott New Instructions.  */\n-  IX86_BUILTIN_ADDSUBPS,\n-  IX86_BUILTIN_HADDPS,\n-  IX86_BUILTIN_HSUBPS,\n-  IX86_BUILTIN_MOVSHDUP,\n-  IX86_BUILTIN_MOVSLDUP,\n-  IX86_BUILTIN_ADDSUBPD,\n-  IX86_BUILTIN_HADDPD,\n-  IX86_BUILTIN_HSUBPD,\n-  IX86_BUILTIN_LOADDDUP,\n-  IX86_BUILTIN_MOVDDUP,\n-  IX86_BUILTIN_LDDQU,\n-\n-  IX86_BUILTIN_MONITOR,\n-  IX86_BUILTIN_MWAIT,\n-\n-  IX86_BUILTIN_MAX\n-};\n-\f\n /* Max number of args passed in registers.  If this is more than 3, we will\n    have problems with ebx (register #4), since it is a caller save register and\n    is also used as the pic register in ELF.  So for now, don't allow more than"}, {"sha": "4f2af6de15aaba453144c97827d68eb8defa0c9a", "filename": "gcc/config/i386/mmintrin.h", "status": "modified", "additions": 8, "deletions": 36, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb701deb655a1ae74c35f2719d33c701544c7ccd/gcc%2Fconfig%2Fi386%2Fmmintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb701deb655a1ae74c35f2719d33c701544c7ccd/gcc%2Fconfig%2Fi386%2Fmmintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fmmintrin.h?ref=eb701deb655a1ae74c35f2719d33c701544c7ccd", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.\n+/* Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -818,55 +818,30 @@ _m_pcmpgtd (__m64 __m1, __m64 __m2)\n static __inline __m64\n _mm_setzero_si64 (void)\n {\n-  return (__m64)__builtin_ia32_mmx_zero ();\n+  return (__m64)0LL;\n }\n \n /* Creates a vector of two 32-bit values; I0 is least significant.  */\n static __inline __m64\n _mm_set_pi32 (int __i1, int __i0)\n {\n-  union {\n-    __m64 __q;\n-    struct {\n-      unsigned int __i0;\n-      unsigned int __i1;\n-    } __s;\n-  } __u;\n-\n-  __u.__s.__i0 = __i0;\n-  __u.__s.__i1 = __i1;\n-\n-  return __u.__q;\n+  return (__m64) __builtin_ia32_vec_init_v2si (__i0, __i1);\n }\n \n /* Creates a vector of four 16-bit values; W0 is least significant.  */\n static __inline __m64\n _mm_set_pi16 (short __w3, short __w2, short __w1, short __w0)\n {\n-  unsigned int __i1 = (unsigned short)__w3 << 16 | (unsigned short)__w2;\n-  unsigned int __i0 = (unsigned short)__w1 << 16 | (unsigned short)__w0;\n-  return _mm_set_pi32 (__i1, __i0);\n-\t\t       \n+  return (__m64) __builtin_ia32_vec_init_v4hi (__w0, __w1, __w2, __w3);\n }\n \n /* Creates a vector of eight 8-bit values; B0 is least significant.  */\n static __inline __m64\n _mm_set_pi8 (char __b7, char __b6, char __b5, char __b4,\n \t     char __b3, char __b2, char __b1, char __b0)\n {\n-  unsigned int __i1, __i0;\n-\n-  __i1 = (unsigned char)__b7;\n-  __i1 = __i1 << 8 | (unsigned char)__b6;\n-  __i1 = __i1 << 8 | (unsigned char)__b5;\n-  __i1 = __i1 << 8 | (unsigned char)__b4;\n-\n-  __i0 = (unsigned char)__b3;\n-  __i0 = __i0 << 8 | (unsigned char)__b2;\n-  __i0 = __i0 << 8 | (unsigned char)__b1;\n-  __i0 = __i0 << 8 | (unsigned char)__b0;\n-\n-  return _mm_set_pi32 (__i1, __i0);\n+  return (__m64) __builtin_ia32_vec_init_v8qi (__b0, __b1, __b2, __b3,\n+\t\t\t\t\t       __b4, __b5, __b6, __b7);\n }\n \n /* Similar, but with the arguments in reverse order.  */\n@@ -900,17 +875,14 @@ _mm_set1_pi32 (int __i)\n static __inline __m64\n _mm_set1_pi16 (short __w)\n {\n-  unsigned int __i = (unsigned short)__w << 16 | (unsigned short)__w;\n-  return _mm_set1_pi32 (__i);\n+  return _mm_set_pi16 (__w, __w, __w, __w);\n }\n \n /* Creates a vector of eight 8-bit values, all elements containing B.  */\n static __inline __m64\n _mm_set1_pi8 (char __b)\n {\n-  unsigned int __w = (unsigned char)__b << 8 | (unsigned char)__b;\n-  unsigned int __i = __w << 16 | __w;\n-  return _mm_set1_pi32 (__i);\n+  return _mm_set_pi8 (__b, __b, __b, __b, __b, __b, __b, __b);\n }\n \n #endif /* __MMX__ */"}, {"sha": "2f710a4e0e18741f978190d1c0b7c0fc2e9f2238", "filename": "gcc/config/i386/mmx.md", "status": "modified", "additions": 202, "deletions": 13, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb701deb655a1ae74c35f2719d33c701544c7ccd/gcc%2Fconfig%2Fi386%2Fmmx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb701deb655a1ae74c35f2719d33c701544c7ccd/gcc%2Fconfig%2Fi386%2Fmmx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fmmx.md?ref=eb701deb655a1ae74c35f2719d33c701544c7ccd", "patch": "@@ -87,9 +87,9 @@\n \n (define_insn \"*mov<mode>_internal\"\n   [(set (match_operand:MMXMODEI 0 \"nonimmediate_operand\"\n-\t\t\t\t\"=*y,*y ,m ,*y,*Y,*Y,*Y ,m ,*x,*x,*x,m\")\n+\t\t\t\"=*y,*y ,m ,*y,*Y,*Y,*Y ,m ,*x,*x,*x,m ,?r ,?m\")\n \t(match_operand:MMXMODEI 1 \"vector_move_operand\"\n-\t\t\t\t\"C  ,*ym,*y,*Y,*y,C ,*Ym,*Y,C ,*x,m ,*x\"))]\n+\t\t\t\"C  ,*ym,*y,*Y,*y,C ,*Ym,*Y,C ,*x,m ,*x,irm,r\"))]\n   \"TARGET_MMX\n    && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\"\n   \"@\n@@ -104,9 +104,11 @@\n     xorps\\t%0, %0\n     movaps\\t{%1, %0|%0, %1}\n     movlps\\t{%1, %0|%0, %1}\n-    movlps\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"mmxmov,mmxmov,mmxmov,ssecvt,ssecvt,ssemov,ssemov,ssemov,ssemov,ssemov,ssemov,ssemov\")\n-   (set_attr \"mode\" \"DI,DI,DI,DI,DI,TI,DI,DI,V4SF,V4SF,V2SF,V2SF\")])\n+    movlps\\t{%1, %0|%0, %1}\n+    #\n+    #\"\n+  [(set_attr \"type\" \"mmxmov,mmxmov,mmxmov,ssecvt,ssecvt,ssemov,ssemov,ssemov,ssemov,ssemov,ssemov,ssemov,*,*\")\n+   (set_attr \"mode\" \"DI,DI,DI,DI,DI,TI,DI,DI,V4SF,V4SF,V2SF,V2SF,DI,DI\")])\n \n (define_expand \"movv2sf\"\n   [(set (match_operand:V2SF 0 \"nonimmediate_operand\" \"\")\n@@ -142,9 +144,9 @@\n \n (define_insn \"*movv2sf_internal\"\n   [(set (match_operand:V2SF 0 \"nonimmediate_operand\"\n-\t\t\t\t\t\"=*y,*y ,m,*y,*Y,*x,*x ,m\")\n+\t\t\t\t\t\"=*y,*y ,m,*y,*Y,*x,*x ,m ,?r ,?m\")\n         (match_operand:V2SF 1 \"vector_move_operand\"\n-\t\t\t\t\t\"C ,*ym,*y,*Y,*y,C ,*xm,*x\"))]\n+\t\t\t\t\t\"C ,*ym,*y,*Y,*y,C ,*xm,*x,irm,r\"))]\n   \"TARGET_MMX\n    && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\"\n   \"@\n@@ -155,9 +157,21 @@\n     movq2dq\\t{%1, %0|%0, %1}\n     xorps\\t%0, %0\n     movlps\\t{%1, %0|%0, %1}\n-    movlps\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"mmxmov,mmxmov,mmxmov,ssecvt,ssecvt,ssemov,ssemov,ssemov\")\n-   (set_attr \"mode\" \"DI,DI,DI,DI,DI,V4SF,V2SF,V2SF\")])\n+    movlps\\t{%1, %0|%0, %1}\n+    #\n+    #\"\n+  [(set_attr \"type\" \"mmxmov,mmxmov,mmxmov,ssecvt,ssecvt,ssemov,ssemov,ssemov,*,*\")\n+   (set_attr \"mode\" \"DI,DI,DI,DI,DI,V4SF,V2SF,V2SF,DI,DI\")])\n+\n+;; %%% This multiword shite has got to go.\n+(define_split\n+  [(set (match_operand:MMXMODE 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:MMXMODE 1 \"general_operand\" \"\"))]\n+  \"!TARGET_64BIT && reload_completed\n+   && (!MMX_REG_P (operands[0]) && !SSE_REG_P (operands[0]))\n+   && (!MMX_REG_P (operands[1]) && !SSE_REG_P (operands[1]))\"\n+  [(const_int 0)]\n+  \"ix86_split_long_move (operands); DONE;\")\n \n (define_expand \"movmisalign<mode>\"\n   [(set (match_operand:MMXMODE 0 \"nonimmediate_operand\" \"\")\n@@ -426,6 +440,58 @@\n   [(set_attr \"type\" \"mmxcvt\")\n    (set_attr \"mode\" \"V2SF\")])\n \n+(define_insn \"*vec_dupv2sf\"\n+  [(set (match_operand:V2SF 0 \"register_operand\" \"=y\")\n+\t(vec_duplicate:V2SF\n+\t  (match_operand:SF 1 \"register_operand\" \"0\")))]\n+  \"TARGET_MMX\"\n+  \"punpckldq\\t%0, %0\"\n+  [(set_attr \"type\" \"mmxcvt\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_insn \"*mmx_concatv2sf\"\n+  [(set (match_operand:V2SF 0 \"register_operand\"     \"=y,y\")\n+\t(vec_concat:V2SF\n+\t  (match_operand:SF 1 \"nonimmediate_operand\" \" 0,rm\")\n+\t  (match_operand:SF 2 \"vector_move_operand\"  \"ym,C\")))]\n+  \"TARGET_MMX && !TARGET_SSE\"\n+  \"@\n+   punpckldq\\t{%2, %0|%0, %2}\n+   movd\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"mmxcvt,mmxmov\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_expand \"vec_setv2sf\"\n+  [(match_operand:V2SF 0 \"register_operand\" \"\")\n+   (match_operand:SF 1 \"register_operand\" \"\")\n+   (match_operand 2 \"const_int_operand\" \"\")]\n+  \"TARGET_MMX\"\n+{\n+  ix86_expand_vector_set (false, operands[0], operands[1],\n+\t\t\t  INTVAL (operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"vec_extractv2sf\"\n+  [(match_operand:SF 0 \"register_operand\" \"\")\n+   (match_operand:V2SF 1 \"register_operand\" \"\")\n+   (match_operand 2 \"const_int_operand\" \"\")]\n+  \"TARGET_MMX\"\n+{\n+  ix86_expand_vector_extract (false, operands[0], operands[1],\n+\t\t\t      INTVAL (operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"vec_initv2sf\"\n+  [(match_operand:V2SF 0 \"register_operand\" \"\")\n+   (match_operand 1 \"\" \"\")]\n+  \"TARGET_SSE\"\n+{\n+  ix86_expand_vector_init (false, operands[0], operands[1]);\n+  DONE;\n+})\n+\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;;\n ;; Parallel integral arithmetic\n@@ -902,9 +968,9 @@\n (define_expand \"mmx_pinsrw\"\n   [(set (match_operand:V4HI 0 \"register_operand\" \"\")\n         (vec_merge:V4HI\n-\t  (match_operand:V4HI 1 \"register_operand\" \"\")\n           (vec_duplicate:V4HI\n             (match_operand:SI 2 \"nonimmediate_operand\" \"\"))\n+\t  (match_operand:V4HI 1 \"register_operand\" \"\")\n           (match_operand:SI 3 \"const_0_to_3_operand\" \"\")))]\n   \"TARGET_SSE || TARGET_3DNOW_A\"\n {\n@@ -915,9 +981,9 @@\n (define_insn \"*mmx_pinsrw\"\n   [(set (match_operand:V4HI 0 \"register_operand\" \"=y\")\n         (vec_merge:V4HI\n-\t  (match_operand:V4HI 1 \"register_operand\" \"0\")\n           (vec_duplicate:V4HI\n             (match_operand:HI 2 \"nonimmediate_operand\" \"rm\"))\n+\t  (match_operand:V4HI 1 \"register_operand\" \"0\")\n           (match_operand:SI 3 \"const_pow2_1_to_8_operand\" \"n\")))]\n   \"TARGET_SSE || TARGET_3DNOW_A\"\n {\n@@ -938,7 +1004,6 @@\n   [(set_attr \"type\" \"mmxcvt\")\n    (set_attr \"mode\" \"DI\")])\n \n-\n (define_expand \"mmx_pshufw\"\n   [(match_operand:V4HI 0 \"register_operand\" \"\")\n    (match_operand:V4HI 1 \"nonimmediate_operand\" \"\")\n@@ -986,6 +1051,130 @@\n   [(set_attr \"type\" \"mmxcvt\")\n    (set_attr \"mode\" \"DI\")])\n \n+(define_insn \"*vec_dupv4hi\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=y\")\n+\t(vec_duplicate:V4HI\n+\t  (truncate:HI\n+\t    (match_operand:SI 1 \"register_operand\" \"0\"))))]\n+  \"TARGET_MMX\"\n+  \"pshufw\\t{$0, %0, %0|%0, %0, 0}\"\n+  [(set_attr \"type\" \"mmxcvt\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_insn \"*vec_dupv2si\"\n+  [(set (match_operand:V2SI 0 \"register_operand\" \"=y\")\n+\t(vec_duplicate:V2SI\n+\t  (match_operand:SI 1 \"register_operand\" \"0\")))]\n+  \"TARGET_MMX\"\n+  \"punpckldq\\t%0, %0\"\n+  [(set_attr \"type\" \"mmxcvt\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_insn \"*mmx_concatv2si\"\n+  [(set (match_operand:V2SI 0 \"register_operand\"     \"=y,y\")\n+\t(vec_concat:V2SI\n+\t  (match_operand:SI 1 \"nonimmediate_operand\" \" 0,rm\")\n+\t  (match_operand:SI 2 \"vector_move_operand\"  \"ym,C\")))]\n+  \"TARGET_MMX && !TARGET_SSE\"\n+  \"@\n+   punpckldq\\t{%2, %0|%0, %2}\n+   movd\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"mmxcvt,mmxmov\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_expand \"vec_setv2si\"\n+  [(match_operand:V2SI 0 \"register_operand\" \"\")\n+   (match_operand:SI 1 \"register_operand\" \"\")\n+   (match_operand 2 \"const_int_operand\" \"\")]\n+  \"TARGET_MMX\"\n+{\n+  ix86_expand_vector_set (false, operands[0], operands[1],\n+\t\t\t  INTVAL (operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"vec_extractv2si\"\n+  [(match_operand:SI 0 \"register_operand\" \"\")\n+   (match_operand:V2SI 1 \"register_operand\" \"\")\n+   (match_operand 2 \"const_int_operand\" \"\")]\n+  \"TARGET_MMX\"\n+{\n+  ix86_expand_vector_extract (false, operands[0], operands[1],\n+\t\t\t      INTVAL (operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"vec_initv2si\"\n+  [(match_operand:V2SI 0 \"register_operand\" \"\")\n+   (match_operand 1 \"\" \"\")]\n+  \"TARGET_SSE\"\n+{\n+  ix86_expand_vector_init (false, operands[0], operands[1]);\n+  DONE;\n+})\n+\n+(define_expand \"vec_setv4hi\"\n+  [(match_operand:V4HI 0 \"register_operand\" \"\")\n+   (match_operand:HI 1 \"register_operand\" \"\")\n+   (match_operand 2 \"const_int_operand\" \"\")]\n+  \"TARGET_MMX\"\n+{\n+  ix86_expand_vector_set (false, operands[0], operands[1],\n+\t\t\t  INTVAL (operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"vec_extractv4hi\"\n+  [(match_operand:HI 0 \"register_operand\" \"\")\n+   (match_operand:V4HI 1 \"register_operand\" \"\")\n+   (match_operand 2 \"const_int_operand\" \"\")]\n+  \"TARGET_MMX\"\n+{\n+  ix86_expand_vector_extract (false, operands[0], operands[1],\n+\t\t\t      INTVAL (operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"vec_initv4hi\"\n+  [(match_operand:V4HI 0 \"register_operand\" \"\")\n+   (match_operand 1 \"\" \"\")]\n+  \"TARGET_SSE\"\n+{\n+  ix86_expand_vector_init (false, operands[0], operands[1]);\n+  DONE;\n+})\n+\n+(define_expand \"vec_setv8qi\"\n+  [(match_operand:V8QI 0 \"register_operand\" \"\")\n+   (match_operand:QI 1 \"register_operand\" \"\")\n+   (match_operand 2 \"const_int_operand\" \"\")]\n+  \"TARGET_MMX\"\n+{\n+  ix86_expand_vector_set (false, operands[0], operands[1],\n+\t\t\t  INTVAL (operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"vec_extractv8qi\"\n+  [(match_operand:QI 0 \"register_operand\" \"\")\n+   (match_operand:V8QI 1 \"register_operand\" \"\")\n+   (match_operand 2 \"const_int_operand\" \"\")]\n+  \"TARGET_MMX\"\n+{\n+  ix86_expand_vector_extract (false, operands[0], operands[1],\n+\t\t\t      INTVAL (operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"vec_initv8qi\"\n+  [(match_operand:V8QI 0 \"register_operand\" \"\")\n+   (match_operand 1 \"\" \"\")]\n+  \"TARGET_SSE\"\n+{\n+  ix86_expand_vector_init (false, operands[0], operands[1]);\n+  DONE;\n+})\n+\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;;\n ;; Miscellaneous"}, {"sha": "26c1f0f0e73f4a5b2f8cf69c49141b16e231104c", "filename": "gcc/config/i386/pmmintrin.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb701deb655a1ae74c35f2719d33c701544c7ccd/gcc%2Fconfig%2Fi386%2Fpmmintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb701deb655a1ae74c35f2719d33c701544c7ccd/gcc%2Fconfig%2Fi386%2Fpmmintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpmmintrin.h?ref=eb701deb655a1ae74c35f2719d33c701544c7ccd", "patch": "@@ -95,13 +95,13 @@ _mm_hsub_pd (__m128d __X, __m128d __Y)\n static __inline __m128d\n _mm_loaddup_pd (double const *__P)\n {\n-  return (__m128d) __builtin_ia32_loadddup (__P);\n+  return _mm_load1_pd (__P);\n }\n \n static __inline __m128d\n _mm_movedup_pd (__m128d __X)\n {\n-  return (__m128d) __builtin_ia32_movddup ((__v2df)__X);\n+  return _mm_shuffle_pd (__X, __X, _MM_SHUFFLE2 (0,0));\n }\n \n static __inline __m128i"}, {"sha": "73352b995b9291669b7e578559c8acb9e9472ed3", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb701deb655a1ae74c35f2719d33c701544c7ccd/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb701deb655a1ae74c35f2719d33c701544c7ccd/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=eb701deb655a1ae74c35f2719d33c701544c7ccd", "patch": "@@ -641,6 +641,11 @@\n   (ior (match_operand 0 \"nonimmediate_operand\")\n        (match_operand 0 \"const0_operand\")))\n \n+;; Return true if OP is a register or a zero.\n+(define_predicate \"reg_or_0_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"const0_operand\")))\n+\n ;; Return true if op if a valid address, and does not contain\n ;; a segment override.\n (define_special_predicate \"no_seg_address_operand\""}, {"sha": "0f5ed7fdf1cc7299b4390b473a56c0a98efef763", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 373, "deletions": 189, "changes": 562, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb701deb655a1ae74c35f2719d33c701544c7ccd/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb701deb655a1ae74c35f2719d33c701544c7ccd/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=eb701deb655a1ae74c35f2719d33c701544c7ccd", "patch": "@@ -123,11 +123,14 @@\n   [(set (match_operand:V4SF 0 \"register_operand\" \"\")\n \t(match_operand:V4SF 1 \"zero_extended_scalar_load_operand\" \"\"))]\n   \"TARGET_SSE && reload_completed\"\n-  [(const_int 0)]\n+  [(set (match_dup 0)\n+\t(vec_merge:V4SF\n+\t  (vec_duplicate:V4SF (match_dup 1))\n+\t  (match_dup 2)\n+\t  (const_int 1)))]\n {\n-  rtx x = simplify_gen_subreg (SFmode, operands[1], V4SFmode, 0);\n-  emit_insn (gen_sse_loadss (operands[0], x));\n-  DONE;\n+  operands[1] = simplify_gen_subreg (SFmode, operands[1], V4SFmode, 0);\n+  operands[2] = CONST0_RTX (V4SFmode);\n })\n \n (define_expand \"movv2df\"\n@@ -185,11 +188,10 @@\n   [(set (match_operand:V2DF 0 \"register_operand\" \"\")\n \t(match_operand:V2DF 1 \"zero_extended_scalar_load_operand\" \"\"))]\n   \"TARGET_SSE2 && reload_completed\"\n-  [(const_int 0)]\n+  [(set (match_dup 0) (vec_concat:V2DF (match_dup 1) (match_dup 2)))]\n {\n-  rtx x = simplify_gen_subreg (DFmode, operands[1], V2DFmode, 0);\n-  emit_insn (gen_sse2_loadsd (operands[0], x));\n-  DONE;\n+  operands[1] = simplify_gen_subreg (DFmode, operands[1], V2DFmode, 0);\n+  operands[2] = CONST0_RTX (DFmode);\n })\n \n (define_expand \"movmisalign<mode>\"\n@@ -1041,16 +1043,63 @@\n   [(set_attr \"type\" \"sselog,ssemov,ssemov\")\n    (set_attr \"mode\" \"V4SF,V2SF,V2SF\")])\n \n-(define_expand \"sse_loadss\"\n-  [(set (match_operand:V4SF 0 \"nonimmediate_operand\" \"\")\n+(define_insn \"sse_movss\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n \t(vec_merge:V4SF\n-\t  (vec_duplicate:V4SF (match_operand:SF 1 \"nonimmediate_operand\" \"\"))\n-\t  (match_dup 2)\n+\t  (match_operand:V4SF 2 \"register_operand\" \"x\")\n+\t  (match_operand:V4SF 1 \"register_operand\" \"0\")\n \t  (const_int 1)))]\n   \"TARGET_SSE\"\n-  \"operands[2] = CONST0_RTX (V4SFmode);\")\n+  \"movss\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"ssemov\")\n+   (set_attr \"mode\" \"SF\")])\n+\n+(define_insn \"*vec_dupv4sf\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n+\t(vec_duplicate:V4SF\n+\t  (match_operand:SF 1 \"register_operand\" \"0\")))]\n+  \"TARGET_SSE\"\n+  \"shufps\\t{$0, %0, %0|%0, %0, 0}\"\n+  [(set_attr \"type\" \"sselog1\")\n+   (set_attr \"mode\" \"V4SF\")])\n+\n+;; ??? In theory we can match memory for the MMX alternative, but allowing\n+;; nonimmediate_operand for operand 2 and *not* allowing memory for the SSE\n+;; alternatives pretty much forces the MMX alternative to be chosen.\n+(define_insn \"*sse_concatv2sf\"\n+  [(set (match_operand:V2SF 0 \"register_operand\" \"=x,*y\")\n+\t(vec_concat:V2SF\n+\t  (match_operand:SF 1 \"register_operand\" \" 0, 0\")\n+\t  (match_operand:SF 2 \"register_operand\" \" x,*y\")))]\n+  \"TARGET_SSE\"\n+  \"@\n+   unpcklps\\t{%2, %0|%0, %2}\n+   punpckldq\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sselog,mmxcvt\")\n+   (set_attr \"mode\" \"V4SF,DI\")])\n+\n+(define_insn \"*sse_concatv4sf\"\n+  [(set (match_operand:V4SF 0 \"register_operand\"   \"=x,x\")\n+\t(vec_concat:V4SF\n+\t  (match_operand:V2SF 1 \"register_operand\" \" 0,0\")\n+\t  (match_operand:V2SF 2 \"nonimmediate_operand\" \" x,m\")))]\n+  \"TARGET_SSE\"\n+  \"@\n+   movlhps\\t{%2, %0|%0, %2}\n+   movhps\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"ssemov\")\n+   (set_attr \"mode\" \"V4SF,V2SF\")])\n+\n+(define_expand \"vec_initv4sf\"\n+  [(match_operand:V4SF 0 \"register_operand\" \"\")\n+   (match_operand 1 \"\" \"\")]\n+  \"TARGET_SSE\"\n+{\n+  ix86_expand_vector_init (false, operands[0], operands[1]);\n+  DONE;\n+})\n \n-(define_insn \"sse_loadlss\"\n+(define_insn \"*vec_setv4sf_0\"\n   [(set (match_operand:V4SF 0 \"nonimmediate_operand\"  \"=x,x,Y ,m\")\n \t(vec_merge:V4SF\n \t  (vec_duplicate:V4SF\n@@ -1080,18 +1129,18 @@\n   DONE;\n })\n \n-(define_insn \"sse_movss\"\n-  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n-\t(vec_merge:V4SF\n-\t  (match_operand:V4SF 2 \"register_operand\" \"x\")\n-\t  (match_operand:V4SF 1 \"register_operand\" \"0\")\n-\t  (const_int 1)))]\n+(define_expand \"vec_setv4sf\"\n+  [(match_operand:V4SF 0 \"register_operand\" \"\")\n+   (match_operand:SF 1 \"register_operand\" \"\")\n+   (match_operand 2 \"const_int_operand\" \"\")]\n   \"TARGET_SSE\"\n-  \"movss\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"ssemov\")\n-   (set_attr \"mode\" \"SF\")])\n+{\n+  ix86_expand_vector_set (false, operands[0], operands[1],\n+\t\t\t  INTVAL (operands[2]));\n+  DONE;\n+})\n \n-(define_insn_and_split \"sse_storess\"\n+(define_insn_and_split \"*vec_extractv4sf_0\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=x,m,fr\")\n \t(vec_select:SF\n \t  (match_operand:V4SF 1 \"nonimmediate_operand\" \"xm,x,m\")\n@@ -1101,56 +1150,12 @@\n   \"&& reload_completed\"\n   [(const_int 0)]\n {\n-  emit_move_insn (operands[0], gen_lowpart (SFmode, operands[1]));\n-  DONE;\n-})\n-\n-(define_expand \"vec_setv4sf\"\n-  [(match_operand:V4SF 0 \"register_operand\" \"\")\n-   (match_operand:SF 1 \"register_operand\" \"\")\n-   (match_operand 2 \"const_int_operand\" \"\")]\n-  \"TARGET_SSE\"\n-{\n-  rtx tmp, op0 = operands[0], op1 = operands[1];\n-\n-  switch (INTVAL (operands[2]))\n-    {\n-    case 0:\n-      emit_insn (gen_sse_loadlss (op0, op0, op1));\n-      break;\n-\n-    case 1:\n-      /* tmp = op0 = A B C D */\n-      tmp = copy_to_reg (op0);\n-\n-      /* op0 = C C D D */\n-      emit_insn (gen_sse_unpcklps (op0, op0, op0));\n-\n-      /* op0 = C C D X */\n-      emit_insn (gen_sse_loadlss (op0, op0, op1));\n-\n-      /* op0 = A B X D  */\n-      emit_insn (gen_sse_shufps_1 (op0, op0, tmp, GEN_INT (1), GEN_INT (0),\n-\t\t\t\t   GEN_INT (2), GEN_INT (3)));\n-      break;\n-\n-    case 2:\n-      tmp = copy_to_reg (op0);\n-      emit_insn (gen_sse_loadlss (op0, op0, op1));\n-      emit_insn (gen_sse_shufps_1 (op0, op0, tmp, GEN_INT (0), GEN_INT (1),\n-\t\t\t\t   GEN_INT (0), GEN_INT (3)));\n-      break;\n-\n-    case 3:\n-      tmp = copy_to_reg (op0);\n-      emit_insn (gen_sse_loadlss (op0, op0, op1));\n-      emit_insn (gen_sse_shufps_1 (op0, op0, tmp, GEN_INT (0), GEN_INT (1),\n-\t\t\t\t   GEN_INT (2), GEN_INT (0)));\n-      break;\n-\n-    default:\n-      abort ();\n-    }\n+  rtx op1 = operands[1];\n+  if (REG_P (op1))\n+    op1 = gen_rtx_REG (SFmode, REGNO (op1));\n+  else\n+    op1 = gen_lowpart (SFmode, op1);\n+  emit_move_insn (operands[0], op1);\n   DONE;\n })\n \n@@ -1160,49 +1165,11 @@\n    (match_operand 2 \"const_int_operand\" \"\")]\n   \"TARGET_SSE\"\n {\n-  rtx tmp, op0 = operands[0], op1 = operands[1];\n-\n-  switch (INTVAL (operands[2]))\n-    {\n-    case 0:\n-      tmp = op1;\n-      break;\n-\n-    case 1:\n-      tmp = copy_to_reg (op1);\n-      emit_insn (gen_sse_shufps_1 (tmp, tmp, tmp, GEN_INT (1), GEN_INT (1),\n-\t\t\t\t   GEN_INT (2), GEN_INT (3)));\n-      break;\n-\n-    case 2:\n-      tmp = copy_to_reg (op1);\n-      emit_insn (gen_sse_unpckhps (tmp, tmp, tmp));\n-      break;\n-\n-    case 3:\n-      tmp = copy_to_reg (op1);\n-      emit_insn (gen_sse_shufps_1 (tmp, tmp, tmp, GEN_INT (3), GEN_INT (1),\n-\t\t\t\t   GEN_INT (2), GEN_INT (3)));\n-      break;\n-\n-    default:\n-      abort ();\n-    }\n-\n-  emit_insn (gen_sse_storess (op0, op1));\n+  ix86_expand_vector_extract (false, operands[0], operands[1],\n+\t\t\t      INTVAL (operands[2]));\n   DONE;\n })\n \n-(define_expand \"vec_initv4sf\"\n-  [(match_operand:V4SF 0 \"register_operand\" \"\")\n-   (match_operand 1 \"\" \"\")]\n-  \"TARGET_SSE\"\n-{\n-  ix86_expand_vector_init (operands[0], operands[1]);\n-  DONE;\n-})\n-\n-\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;;\n ;; Parallel double-precision floating point arithmetic\n@@ -1814,7 +1781,7 @@\n   [(set_attr \"type\" \"sselog,ssemov,ssemov\")\n    (set_attr \"mode\" \"V2DF,V1DF,V1DF\")])\n \n-(define_insn \"sse3_movddup\"\n+(define_insn \"*sse3_movddup\"\n   [(set (match_operand:V2DF 0 \"nonimmediate_operand\"     \"=x,o\")\n \t(vec_select:V2DF\n \t  (vec_concat:V4DF\n@@ -1840,7 +1807,7 @@\n   \"TARGET_SSE3 && reload_completed\"\n   [(const_int 0)]\n {\n-  rtx low = gen_lowpart (DFmode, operands[1]);\n+  rtx low = gen_rtx_REG (DFmode, REGNO (operands[1]));\n   emit_move_insn (adjust_address (operands[0], DFmode, 0), low);\n   emit_move_insn (adjust_address (operands[0], DFmode, 8), low);\n   DONE;\n@@ -1939,10 +1906,15 @@\n \t  (match_operand:V2DF 1 \"nonimmediate_operand\" \"\")\n \t  (parallel [(const_int 0)])))]\n   \"TARGET_SSE2 && reload_completed\"\n-  [(set (match_dup 0) (match_dup 1))]\n+  [(const_int 0)]\n {\n-  operands[0] = gen_lowpart (DFmode, operands[0]);\n-  operands[1] = gen_lowpart (DFmode, operands[1]);\n+  rtx op1 = operands[1];\n+  if (REG_P (op1))\n+    op1 = gen_rtx_REG (DFmode, REGNO (op1));\n+  else\n+    op1 = gen_lowpart (DFmode, op1);\n+  emit_move_insn (operands[0], op1);\n+  DONE;\n })\n \n (define_insn \"sse2_loadhpd\"\n@@ -2001,14 +1973,6 @@\n   operands[0] = adjust_address (operands[0], DFmode, 8);\n })\n \n-(define_expand \"sse2_loadsd\"\n-  [(set (match_operand:V2DF 0 \"register_operand\" \"\")\n-\t(vec_concat:V2DF\n-\t  (match_operand:DF 1 \"nonimmediate_operand\" \"\")\n-\t  (vec_select:DF (match_dup 2) (parallel [(const_int 1)]))))]\n-  \"TARGET_SSE2\"\n-  \"operands[2] = CONST0_RTX (V2DFmode);\")\n-\n (define_insn \"sse2_movsd\"\n   [(set (match_operand:V2DF 0 \"nonimmediate_operand\"   \"=x,x,m,x,x,o\")\n \t(vec_merge:V2DF\n@@ -2026,61 +1990,77 @@\n   [(set_attr \"type\" \"ssemov,ssemov,ssemov,sselog,ssemov,ssemov\")\n    (set_attr \"mode\" \"DF,V1DF,V1DF,V2DF,V1DF,V1DF\")])\n \n-(define_insn \"sse3_loadddup\"\n+(define_insn \"*vec_dupv2df_sse3\"\n   [(set (match_operand:V2DF 0 \"register_operand\" \"=x\")\n \t(vec_duplicate:V2DF\n \t  (match_operand:DF 1 \"nonimmediate_operand\" \"xm\")))]\n   \"TARGET_SSE3\"\n   \"movddup\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"ssecvt\")\n+  [(set_attr \"type\" \"sselog1\")\n+   (set_attr \"mode\" \"DF\")])\n+\n+(define_insn \"*vec_dupv2df\"\n+  [(set (match_operand:V2DF 0 \"register_operand\" \"=x\")\n+\t(vec_duplicate:V2DF\n+\t  (match_operand:DF 1 \"register_operand\" \"0\")))]\n+  \"TARGET_SSE2\"\n+  \"unpcklpd\\t%0, %0\"\n+  [(set_attr \"type\" \"sselog1\")\n+   (set_attr \"mode\" \"V4SF\")])\n+\n+(define_insn \"*vec_concatv2df_sse3\"\n+  [(set (match_operand:V2DF 0 \"register_operand\" \"=x\")\n+\t(vec_concat:V2DF\n+\t  (match_operand:DF 1 \"nonimmediate_operand\" \"xm\")\n+\t  (match_dup 1)))]\n+  \"TARGET_SSE3\"\n+  \"movddup\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sselog1\")\n    (set_attr \"mode\" \"DF\")])\n \n+(define_insn \"*vec_concatv2df\"\n+  [(set (match_operand:V2DF 0 \"register_operand\"     \"=Y,Y,Y,x,x\")\n+\t(vec_concat:V2DF\n+\t  (match_operand:DF 1 \"nonimmediate_operand\" \" 0,0,m,0,0\")\n+\t  (match_operand:DF 2 \"vector_move_operand\"  \" Y,m,C,x,m\")))]\n+  \"TARGET_SSE\"\n+  \"@\n+   unpcklpd\\t{%2, %0|%0, %2}\n+   movhpd\\t{%2, %0|%0, %2}\n+   movsd\\t{%1, %0|%0, %1}\n+   movlhps\\t{%2, %0|%0, %2}\n+   movhps\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sselog,ssemov,ssemov,ssemov,ssemov\")\n+   (set_attr \"mode\" \"V2DF,V1DF,DF,V4SF,V2SF\")])\n+\n (define_expand \"vec_setv2df\"\n   [(match_operand:V2DF 0 \"register_operand\" \"\")\n    (match_operand:DF 1 \"register_operand\" \"\")\n    (match_operand 2 \"const_int_operand\" \"\")]\n-  \"TARGET_SSE2\"\n+  \"TARGET_SSE\"\n {\n-  switch (INTVAL (operands[2]))\n-    {\n-    case 0:\n-      emit_insn (gen_sse2_loadlpd (operands[0], operands[0], operands[1]));\n-      break;\n-    case 1:\n-      emit_insn (gen_sse2_loadhpd (operands[0], operands[0], operands[1]));\n-      break;\n-    default:\n-      abort ();\n-    }\n+  ix86_expand_vector_set (false, operands[0], operands[1],\n+\t\t\t  INTVAL (operands[2]));\n   DONE;\n })\n \n (define_expand \"vec_extractv2df\"\n   [(match_operand:DF 0 \"register_operand\" \"\")\n    (match_operand:V2DF 1 \"register_operand\" \"\")\n    (match_operand 2 \"const_int_operand\" \"\")]\n-  \"TARGET_SSE2\"\n+  \"TARGET_SSE\"\n {\n-  switch (INTVAL (operands[2]))\n-    {\n-    case 0:\n-      emit_insn (gen_sse2_storelpd (operands[0], operands[1]));\n-      break;\n-    case 1:\n-      emit_insn (gen_sse2_storehpd (operands[0], operands[1]));\n-      break;\n-    default:\n-      abort ();\n-    }\n+  ix86_expand_vector_extract (false, operands[0], operands[1],\n+\t\t\t      INTVAL (operands[2]));\n   DONE;\n })\n \n (define_expand \"vec_initv2df\"\n   [(match_operand:V2DF 0 \"register_operand\" \"\")\n    (match_operand 1 \"\" \"\")]\n-  \"TARGET_SSE2\"\n+  \"TARGET_SSE\"\n {\n-  ix86_expand_vector_init (operands[0], operands[1]);\n+  ix86_expand_vector_init (false, operands[0], operands[1]);\n   DONE;\n })\n \n@@ -2661,9 +2641,9 @@\n (define_expand \"sse2_pinsrw\"\n   [(set (match_operand:V8HI 0 \"register_operand\" \"\")\n \t(vec_merge:V8HI\n-\t  (match_operand:V8HI 1 \"register_operand\" \"\")\n \t  (vec_duplicate:V8HI\n \t    (match_operand:SI 2 \"nonimmediate_operand\" \"\"))\n+\t  (match_operand:V8HI 1 \"register_operand\" \"\")\n \t  (match_operand:SI 3 \"const_0_to_7_operand\" \"\")))]\n   \"TARGET_SSE2\"\n {\n@@ -2674,9 +2654,9 @@\n (define_insn \"*sse2_pinsrw\"\n   [(set (match_operand:V8HI 0 \"register_operand\" \"=x\")\n \t(vec_merge:V8HI\n-\t  (match_operand:V8HI 1 \"register_operand\" \"0\")\n \t  (vec_duplicate:V8HI\n \t    (match_operand:HI 2 \"nonimmediate_operand\" \"rm\"))\n+\t  (match_operand:V8HI 1 \"register_operand\" \"0\")\n \t  (match_operand:SI 3 \"const_pow2_1_to_128_operand\" \"n\")))]\n   \"TARGET_SSE2\"\n {\n@@ -2823,69 +2803,66 @@\n \t    (match_operand:SI 1 \"nonimmediate_operand\" \"\"))\n \t  (match_dup 2)\n \t  (const_int 1)))]\n-  \"TARGET_SSE2\"\n+  \"TARGET_SSE\"\n   \"operands[2] = CONST0_RTX (V4SImode);\")\n \n (define_insn \"sse2_loadld\"\n-  [(set (match_operand:V4SI 0 \"register_operand\" \"=x,x\")\n+  [(set (match_operand:V4SI 0 \"register_operand\"       \"=Y,x,x\")\n \t(vec_merge:V4SI\n \t  (vec_duplicate:V4SI\n-\t    (match_operand:SI 2 \"nonimmediate_operand\" \"mr,x\"))\n-\t  (match_operand:V4SI 1 \"vector_move_operand\" \"C,0\")\n+\t    (match_operand:SI 2 \"nonimmediate_operand\" \"mr,m,x\"))\n+\t  (match_operand:V4SI 1 \"vector_move_operand\"  \" C,C,0\")\n \t  (const_int 1)))]\n-  \"TARGET_SSE2\"\n+  \"TARGET_SSE\"\n   \"@\n    movd\\t{%2, %0|%0, %2}\n+   movss\\t{%2, %0|%0, %2}\n    movss\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"ssemov\")\n-   (set_attr \"mode\" \"TI\")])\n+   (set_attr \"mode\" \"TI,V4SF,SF\")])\n \n+;; ??? The hardware supports more, but TARGET_INTER_UNIT_MOVES must\n+;; be taken into account, and movdi isn't fully populated even without.\n (define_insn_and_split \"sse2_stored\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=mrx\")\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=mx\")\n \t(vec_select:SI\n \t  (match_operand:V4SI 1 \"register_operand\" \"x\")\n \t  (parallel [(const_int 0)])))]\n-  \"TARGET_SSE2\"\n+  \"TARGET_SSE\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 0) (match_dup 1))]\n {\n-  operands[1] = gen_lowpart (SImode, operands[1]);\n+  operands[1] = gen_rtx_REG (SImode, REGNO (operands[1]));\n })\n \n-(define_expand \"sse2_storeq\"\n+(define_expand \"sse_storeq\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n \t(vec_select:DI\n \t  (match_operand:V2DI 1 \"register_operand\" \"\")\n \t  (parallel [(const_int 0)])))]\n-  \"TARGET_SSE2\"\n+  \"TARGET_SSE\"\n   \"\")\n \n+;; ??? The hardware supports more, but TARGET_INTER_UNIT_MOVES must\n+;; be taken into account, and movdi isn't fully populated even without.\n (define_insn \"*sse2_storeq\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=myx\")\n-\t(vec_select:DI\n-\t  (match_operand:V2DI 1 \"register_operand\" \"x\")\n-\t  (parallel [(const_int 0)])))]\n-  \"TARGET_SSE2 && !TARGET_64BIT\"\n-  \"#\")\n-\n-(define_insn \"*sse2_storeq_rex64\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=myxr\")\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=mx\")\n \t(vec_select:DI\n \t  (match_operand:V2DI 1 \"register_operand\" \"x\")\n \t  (parallel [(const_int 0)])))]\n-  \"TARGET_SSE2 && TARGET_64BIT\"\n+  \"TARGET_SSE\"\n   \"#\")\n \n (define_split\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n \t(vec_select:DI\n \t  (match_operand:V2DI 1 \"register_operand\" \"\")\n \t  (parallel [(const_int 0)])))]\n-  \"TARGET_SSE2 && reload_completed\"\n+  \"TARGET_SSE && reload_completed\"\n   [(set (match_dup 0) (match_dup 1))]\n {\n-  operands[1] = gen_lowpart (DImode, operands[1]);\n+  operands[1] = gen_rtx_REG (DImode, REGNO (operands[1]));\n })\n \n (define_expand \"sse2_loadq\"\n@@ -2895,29 +2872,30 @@\n \t    (match_operand:DI 1 \"nonimmediate_operand\" \"\"))\n \t  (match_dup 2)\n \t  (const_int 1)))]\t  \n-  \"TARGET_SSE2\"\n+  \"TARGET_SSE\"\n   \"operands[2] = CONST0_RTX (V2DImode);\")\n \n (define_insn \"*sse2_loadq\"\n-  [(set (match_operand:V2DI 0 \"register_operand\"     \"=x,?x,x\")\n+  [(set (match_operand:V2DI 0 \"register_operand\"       \"=Y,?Y,Y,x\")\n \t(vec_merge:V2DI\n \t  (vec_duplicate:V2DI\n-\t    (match_operand:DI 1 \"nonimmediate_operand\" \" m, y,x\"))\n-\t  (match_operand:V2DI 2 \"vector_move_operand\"  \" C, C,0\")\n+\t    (match_operand:DI 1 \"nonimmediate_operand\" \" m,*y,Y,0\"))\n+\t  (match_operand:V2DI 2 \"vector_move_operand\"  \" C, C,0,x\")\n \t  (const_int 1)))]\n-  \"TARGET_SSE2 && !TARGET_64BIT\"\n+  \"TARGET_SSE && !TARGET_64BIT\"\n   \"@\n    movq\\t{%1, %0|%0, %1}\n    movq2dq\\t{%1, %0|%0, %1}\n-   movq\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"ssemov\")\n-   (set_attr \"mode\" \"TI\")])\n+   movq\\t{%1, %0|%0, %1}\n+   shufps\\t{$0xe4, %1, %0|%0, %1, 0xe4}\"\n+  [(set_attr \"type\" \"ssemov,ssemov,ssemov,sselog\")\n+   (set_attr \"mode\" \"TI,TI,TI,V4SF\")])\n \n (define_insn \"*sse2_loadq_rex64\"\n   [(set (match_operand:V2DI 0 \"register_operand\"       \"=x,?x,?x,x\")\n \t(vec_merge:V2DI\n \t  (vec_duplicate:V2DI\n-\t    (match_operand:DI 1 \"nonimmediate_operand\" \" m, y, r,x\"))\n+\t    (match_operand:DI 1 \"nonimmediate_operand\" \" m,*y, r,x\"))\n \t  (match_operand:V2DI 2 \"vector_move_operand\"  \" C, C, C,0\")\n \t  (const_int 1)))]\n   \"TARGET_SSE2 && TARGET_64BIT\"\n@@ -2929,6 +2907,212 @@\n   [(set_attr \"type\" \"ssemov\")\n    (set_attr \"mode\" \"TI\")])\n \n+(define_insn \"*vec_dupv4si\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=Y,x\")\n+\t(vec_duplicate:V4SI\n+\t  (match_operand:SI 1 \"register_operand\" \" Y,0\")))]\n+  \"TARGET_SSE\"\n+  \"@\n+   pshufd\\t{$0, %1, %0|%0, %1, 0}\n+   shufps\\t{$0, %0, %0|%0, %0, 0}\"\n+  [(set_attr \"type\" \"sselog1\")\n+   (set_attr \"mode\" \"TI,V4SF\")])\n+\n+(define_insn \"*vec_dupv2di\"\n+  [(set (match_operand:V2DI 0 \"register_operand\" \"=Y,x\")\n+\t(vec_duplicate:V2DI\n+\t  (match_operand:DI 1 \"register_operand\" \" 0,0\")))]\n+  \"TARGET_SSE\"\n+  \"@\n+   punpcklqdq\\t%0, %0\n+   movlhps\\t%0, %0\"\n+  [(set_attr \"type\" \"sselog1,ssemov\")\n+   (set_attr \"mode\" \"TI,V4SF\")])\n+\n+;; ??? In theory we can match memory for the MMX alternative, but allowing\n+;; nonimmediate_operand for operand 2 and *not* allowing memory for the SSE\n+;; alternatives pretty much forces the MMX alternative to be chosen.\n+(define_insn \"*sse2_concatv2si\"\n+  [(set (match_operand:V2SI 0 \"register_operand\"     \"=Y, Y,*y,*y\")\n+\t(vec_concat:V2SI\n+\t  (match_operand:SI 1 \"nonimmediate_operand\" \" 0,rm, 0,rm\")\n+\t  (match_operand:SI 2 \"reg_or_0_operand\"     \" Y, C,*y, C\")))]\n+  \"TARGET_SSE2\"\n+  \"@\n+   punpckldq\\t{%2, %0|%0, %2}\n+   movd\\t{%1, %0|%0, %1}\n+   punpckldq\\t{%2, %0|%0, %2}\n+   movd\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sselog,ssemov,mmxcvt,mmxmov\")\n+   (set_attr \"mode\" \"TI,TI,DI,DI\")])\n+\n+(define_insn \"*sse1_concatv2si\"\n+  [(set (match_operand:V2SI 0 \"register_operand\"     \"=x,x,*y,*y\")\n+\t(vec_concat:V2SI\n+\t  (match_operand:SI 1 \"nonimmediate_operand\" \" 0,m, 0,*rm\")\n+\t  (match_operand:SI 2 \"reg_or_0_operand\"     \" x,C,*y,C\")))]\n+  \"TARGET_SSE\"\n+  \"@\n+   unpcklps\\t{%2, %0|%0, %2}\n+   movss\\t{%1, %0|%0, %1}\n+   punpckldq\\t{%2, %0|%0, %2}\n+   movd\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sselog,ssemov,mmxcvt,mmxmov\")\n+   (set_attr \"mode\" \"V4SF,V4SF,DI,DI\")])\n+\n+(define_insn \"*vec_concatv4si_1\"\n+  [(set (match_operand:V4SI 0 \"register_operand\"       \"=Y,x,x\")\n+\t(vec_concat:V4SI\n+\t  (match_operand:V2SI 1 \"register_operand\"     \" 0,0,0\")\n+\t  (match_operand:V2SI 2 \"nonimmediate_operand\" \" Y,x,m\")))]\n+  \"TARGET_SSE\"\n+  \"@\n+   punpcklqdq\\t{%2, %0|%0, %2}\n+   movlhps\\t{%2, %0|%0, %2}\n+   movhps\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sselog,ssemov,ssemov\")\n+   (set_attr \"mode\" \"TI,V4SF,V2SF\")])\n+\n+(define_insn \"*vec_concatv2di\"\n+  [(set (match_operand:V2DI 0 \"register_operand\"     \"=Y,?Y,Y,x,x,x\")\n+\t(vec_concat:V2DI\n+\t  (match_operand:DI 1 \"nonimmediate_operand\" \" m,*y,0,0,0,m\")\n+\t  (match_operand:DI 2 \"vector_move_operand\"  \" C, C,Y,x,m,0\")))]\n+  \"TARGET_SSE\"\n+  \"@\n+   movq\\t{%1, %0|%0, %1}\n+   movq2dq\\t{%1, %0|%0, %1}\n+   punpcklqdq\\t{%2, %0|%0, %2}\n+   movlhps\\t{%2, %0|%0, %2}\n+   movhps\\t{%2, %0|%0, %2}\n+   movlps\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"ssemov,ssemov,sselog,ssemov,ssemov,ssemov\")\n+   (set_attr \"mode\" \"TI,TI,TI,V4SF,V2SF,V2SF\")])\n+\n+(define_expand \"vec_setv2di\"\n+  [(match_operand:V2DI 0 \"register_operand\" \"\")\n+   (match_operand:DI 1 \"register_operand\" \"\")\n+   (match_operand 2 \"const_int_operand\" \"\")]\n+  \"TARGET_SSE\"\n+{\n+  ix86_expand_vector_set (false, operands[0], operands[1],\n+\t\t\t  INTVAL (operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"vec_extractv2di\"\n+  [(match_operand:DI 0 \"register_operand\" \"\")\n+   (match_operand:V2DI 1 \"register_operand\" \"\")\n+   (match_operand 2 \"const_int_operand\" \"\")]\n+  \"TARGET_SSE\"\n+{\n+  ix86_expand_vector_extract (false, operands[0], operands[1],\n+\t\t\t      INTVAL (operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"vec_initv2di\"\n+  [(match_operand:V2DI 0 \"register_operand\" \"\")\n+   (match_operand 1 \"\" \"\")]\n+  \"TARGET_SSE\"\n+{\n+  ix86_expand_vector_init (false, operands[0], operands[1]);\n+  DONE;\n+})\n+\n+(define_expand \"vec_setv4si\"\n+  [(match_operand:V4SI 0 \"register_operand\" \"\")\n+   (match_operand:SI 1 \"register_operand\" \"\")\n+   (match_operand 2 \"const_int_operand\" \"\")]\n+  \"TARGET_SSE\"\n+{\n+  ix86_expand_vector_set (false, operands[0], operands[1],\n+\t\t\t  INTVAL (operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"vec_extractv4si\"\n+  [(match_operand:SI 0 \"register_operand\" \"\")\n+   (match_operand:V4SI 1 \"register_operand\" \"\")\n+   (match_operand 2 \"const_int_operand\" \"\")]\n+  \"TARGET_SSE\"\n+{\n+  ix86_expand_vector_extract (false, operands[0], operands[1],\n+\t\t\t      INTVAL (operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"vec_initv4si\"\n+  [(match_operand:V4SI 0 \"register_operand\" \"\")\n+   (match_operand 1 \"\" \"\")]\n+  \"TARGET_SSE\"\n+{\n+  ix86_expand_vector_init (false, operands[0], operands[1]);\n+  DONE;\n+})\n+\n+(define_expand \"vec_setv8hi\"\n+  [(match_operand:V8HI 0 \"register_operand\" \"\")\n+   (match_operand:HI 1 \"register_operand\" \"\")\n+   (match_operand 2 \"const_int_operand\" \"\")]\n+  \"TARGET_SSE\"\n+{\n+  ix86_expand_vector_set (false, operands[0], operands[1],\n+\t\t\t  INTVAL (operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"vec_extractv8hi\"\n+  [(match_operand:HI 0 \"register_operand\" \"\")\n+   (match_operand:V8HI 1 \"register_operand\" \"\")\n+   (match_operand 2 \"const_int_operand\" \"\")]\n+  \"TARGET_SSE\"\n+{\n+  ix86_expand_vector_extract (false, operands[0], operands[1],\n+\t\t\t      INTVAL (operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"vec_initv8hi\"\n+  [(match_operand:V8HI 0 \"register_operand\" \"\")\n+   (match_operand 1 \"\" \"\")]\n+  \"TARGET_SSE\"\n+{\n+  ix86_expand_vector_init (false, operands[0], operands[1]);\n+  DONE;\n+})\n+\n+(define_expand \"vec_setv16qi\"\n+  [(match_operand:V16QI 0 \"register_operand\" \"\")\n+   (match_operand:QI 1 \"register_operand\" \"\")\n+   (match_operand 2 \"const_int_operand\" \"\")]\n+  \"TARGET_SSE\"\n+{\n+  ix86_expand_vector_set (false, operands[0], operands[1],\n+\t\t\t  INTVAL (operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"vec_extractv16qi\"\n+  [(match_operand:QI 0 \"register_operand\" \"\")\n+   (match_operand:V16QI 1 \"register_operand\" \"\")\n+   (match_operand 2 \"const_int_operand\" \"\")]\n+  \"TARGET_SSE\"\n+{\n+  ix86_expand_vector_extract (false, operands[0], operands[1],\n+\t\t\t      INTVAL (operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"vec_initv16qi\"\n+  [(match_operand:V16QI 0 \"register_operand\" \"\")\n+   (match_operand 1 \"\" \"\")]\n+  \"TARGET_SSE\"\n+{\n+  ix86_expand_vector_init (false, operands[0], operands[1]);\n+  DONE;\n+})\n+\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;;\n ;; Miscelaneous"}, {"sha": "6c56973f0db1dc98e5c5c762f38f6cf862953673", "filename": "gcc/config/i386/xmmintrin.h", "status": "modified", "additions": 69, "deletions": 77, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb701deb655a1ae74c35f2719d33c701544c7ccd/gcc%2Fconfig%2Fi386%2Fxmmintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb701deb655a1ae74c35f2719d33c701544c7ccd/gcc%2Fconfig%2Fi386%2Fxmmintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fxmmintrin.h?ref=eb701deb655a1ae74c35f2719d33c701544c7ccd", "patch": "@@ -86,6 +86,13 @@ enum _mm_hint\n #define _MM_FLUSH_ZERO_ON     0x8000\n #define _MM_FLUSH_ZERO_OFF    0x0000\n \n+/* Create a vector of zeros.  */\n+static __inline __m128\n+_mm_setzero_ps (void)\n+{\n+  return (__m128){ 0.0f, 0.0f, 0.0f, 0.0f };\n+}\n+\n /* Perform the respective operation on the lower SPFP (single-precision\n    floating-point) values of A and B; the upper three SPFP values are\n    passed through from A.  */\n@@ -590,15 +597,14 @@ _mm_cvtpi16_ps (__m64 __A)\n   /* This comparison against zero gives us a mask that can be used to\n      fill in the missing sign bits in the unpack operations below, so\n      that we get signed values after unpacking.  */\n-  __sign = (__v4hi) __builtin_ia32_mmx_zero ();\n-  __sign = __builtin_ia32_pcmpgtw (__sign, (__v4hi)__A);\n+  __sign = __builtin_ia32_pcmpgtw ((__v4hi)0LL, (__v4hi)__A);\n \n   /* Convert the four words to doublewords.  */\n   __hisi = (__v2si) __builtin_ia32_punpckhwd ((__v4hi)__A, __sign);\n   __losi = (__v2si) __builtin_ia32_punpcklwd ((__v4hi)__A, __sign);\n \n   /* Convert the doublewords to floating point two at a time.  */\n-  __r = (__v4sf) __builtin_ia32_setzerops ();\n+  __r = (__v4sf) _mm_setzero_ps ();\n   __r = __builtin_ia32_cvtpi2ps (__r, __hisi);\n   __r = __builtin_ia32_movlhps (__r, __r);\n   __r = __builtin_ia32_cvtpi2ps (__r, __losi);\n@@ -610,16 +616,15 @@ _mm_cvtpi16_ps (__m64 __A)\n static __inline __m128\n _mm_cvtpu16_ps (__m64 __A)\n {\n-  __v4hi __zero = (__v4hi) __builtin_ia32_mmx_zero ();\n   __v2si __hisi, __losi;\n   __v4sf __r;\n \n   /* Convert the four words to doublewords.  */\n-  __hisi = (__v2si) __builtin_ia32_punpckhwd ((__v4hi)__A, __zero);\n-  __losi = (__v2si) __builtin_ia32_punpcklwd ((__v4hi)__A, __zero);\n+  __hisi = (__v2si) __builtin_ia32_punpckhwd ((__v4hi)__A, (__v4hi)0LL);\n+  __losi = (__v2si) __builtin_ia32_punpcklwd ((__v4hi)__A, (__v4hi)0LL);\n \n   /* Convert the doublewords to floating point two at a time.  */\n-  __r = (__v4sf) __builtin_ia32_setzerops ();\n+  __r = (__v4sf) _mm_setzero_ps ();\n   __r = __builtin_ia32_cvtpi2ps (__r, __hisi);\n   __r = __builtin_ia32_movlhps (__r, __r);\n   __r = __builtin_ia32_cvtpi2ps (__r, __losi);\n@@ -636,8 +641,7 @@ _mm_cvtpi8_ps (__m64 __A)\n   /* This comparison against zero gives us a mask that can be used to\n      fill in the missing sign bits in the unpack operations below, so\n      that we get signed values after unpacking.  */\n-  __sign = (__v8qi) __builtin_ia32_mmx_zero ();\n-  __sign = __builtin_ia32_pcmpgtb (__sign, (__v8qi)__A);\n+  __sign = __builtin_ia32_pcmpgtb ((__v8qi)0LL, (__v8qi)__A);\n \n   /* Convert the four low bytes to words.  */\n   __A = (__m64) __builtin_ia32_punpcklbw ((__v8qi)__A, __sign);\n@@ -649,16 +653,15 @@ _mm_cvtpi8_ps (__m64 __A)\n static __inline __m128\n _mm_cvtpu8_ps(__m64 __A)\n {\n-  __v8qi __zero = (__v8qi) __builtin_ia32_mmx_zero ();\n-  __A = (__m64) __builtin_ia32_punpcklbw ((__v8qi)__A, __zero);\n+  __A = (__m64) __builtin_ia32_punpcklbw ((__v8qi)__A, (__v8qi)0LL);\n   return _mm_cvtpu16_ps(__A);\n }\n \n /* Convert the four signed 32-bit values in A and B to SPFP form.  */\n static __inline __m128\n _mm_cvtpi32x2_ps(__m64 __A, __m64 __B)\n {\n-  __v4sf __zero = (__v4sf) __builtin_ia32_setzerops ();\n+  __v4sf __zero = (__v4sf) _mm_setzero_ps ();\n   __v4sf __sfa = __builtin_ia32_cvtpi2ps (__zero, (__v2si)__A);\n   __v4sf __sfb = __builtin_ia32_cvtpi2ps (__zero, (__v2si)__B);\n   return (__m128) __builtin_ia32_movlhps (__sfa, __sfb);\n@@ -680,8 +683,7 @@ static __inline __m64\n _mm_cvtps_pi8(__m128 __A)\n {\n   __v4hi __tmp = (__v4hi) _mm_cvtps_pi16 (__A);\n-  __v4hi __zero = (__v4hi) __builtin_ia32_mmx_zero ();\n-  return (__m64) __builtin_ia32_packsswb (__tmp, __zero);\n+  return (__m64) __builtin_ia32_packsswb (__tmp, (__v4hi)0LL);\n }\n \n /* Selects four specific SPFP values from A and B based on MASK.  */\n@@ -826,19 +828,38 @@ _MM_SET_FLUSH_ZERO_MODE (unsigned int __mode)\n   _mm_setcsr((_mm_getcsr() & ~_MM_FLUSH_ZERO_MASK) | __mode);\n }\n \n+/* Create a vector with element 0 as F and the rest zero.  */\n+static __inline __m128\n+_mm_set_ss (float __F)\n+{\n+  return (__m128)(__v4sf){ __F, 0, 0, 0 };\n+}\n+\n+/* Create a vector with all four elements equal to F.  */\n+static __inline __m128\n+_mm_set1_ps (float __F)\n+{\n+  return (__m128)(__v4sf){ __F, __F, __F, __F };\n+}\n+\n+static __inline __m128\n+_mm_set_ps1 (float __F)\n+{\n+  return _mm_set1_ps (__F);\n+}\n+\n /* Create a vector with element 0 as *P and the rest zero.  */\n static __inline __m128\n _mm_load_ss (float const *__P)\n {\n-  return (__m128) __builtin_ia32_loadss (__P);\n+  return _mm_set_ss (*__P);\n }\n \n /* Create a vector with all four elements equal to *P.  */\n static __inline __m128\n _mm_load1_ps (float const *__P)\n {\n-  __v4sf __tmp = __builtin_ia32_loadss (__P);\n-  return (__m128) __builtin_ia32_shufps (__tmp, __tmp, _MM_SHUFFLE (0,0,0,0));\n+  return _mm_set1_ps (*__P);\n }\n \n static __inline __m128\n@@ -851,7 +872,7 @@ _mm_load_ps1 (float const *__P)\n static __inline __m128\n _mm_load_ps (float const *__P)\n {\n-  return (__m128) __builtin_ia32_loadaps (__P);\n+  return (__m128) *(__v4sf *)__P;\n }\n \n /* Load four SPFP values from P.  The address need not be 16-byte aligned.  */\n@@ -865,86 +886,58 @@ _mm_loadu_ps (float const *__P)\n static __inline __m128\n _mm_loadr_ps (float const *__P)\n {\n-  __v4sf __tmp = __builtin_ia32_loadaps (__P);\n+  __v4sf __tmp = *(__v4sf *)__P;\n   return (__m128) __builtin_ia32_shufps (__tmp, __tmp, _MM_SHUFFLE (0,1,2,3));\n }\n \n-/* Create a vector with element 0 as F and the rest zero.  */\n-static __inline __m128\n-_mm_set_ss (float __F)\n-{\n-  return (__m128) __builtin_ia32_loadss (&__F);\n-}\n-\n-/* Create a vector with all four elements equal to F.  */\n-static __inline __m128\n-_mm_set1_ps (float __F)\n-{\n-  __v4sf __tmp = __builtin_ia32_loadss (&__F);\n-  return (__m128) __builtin_ia32_shufps (__tmp, __tmp, _MM_SHUFFLE (0,0,0,0));\n-}\n-\n-static __inline __m128\n-_mm_set_ps1 (float __F)\n-{\n-  return _mm_set1_ps (__F);\n-}\n-\n /* Create the vector [Z Y X W].  */\n static __inline __m128\n _mm_set_ps (const float __Z, const float __Y, const float __X, const float __W)\n {\n-  return (__v4sf) {__W, __X, __Y, __Z};\n+  return (__m128)(__v4sf){ __W, __X, __Y, __Z };\n }\n \n /* Create the vector [W X Y Z].  */\n static __inline __m128\n _mm_setr_ps (float __Z, float __Y, float __X, float __W)\n {\n-  return _mm_set_ps (__W, __X, __Y, __Z);\n-}\n-\n-/* Create a vector of zeros.  */\n-static __inline __m128\n-_mm_setzero_ps (void)\n-{\n-  return (__m128) __builtin_ia32_setzerops ();\n+  return (__m128)(__v4sf){ __Z, __Y, __X, __W };\n }\n \n /* Stores the lower SPFP value.  */\n static __inline void\n _mm_store_ss (float *__P, __m128 __A)\n {\n-  __builtin_ia32_storess (__P, (__v4sf)__A);\n+  *__P = __builtin_ia32_vec_ext_v4sf ((__v4sf)__A, 0);\n }\n \n-/* Store the lower SPFP value across four words.  */\n+/* Store four SPFP values.  The address must be 16-byte aligned.  */\n static __inline void\n-_mm_store1_ps (float *__P, __m128 __A)\n+_mm_store_ps (float *__P, __m128 __A)\n {\n-  __v4sf __va = (__v4sf)__A;\n-  __v4sf __tmp = __builtin_ia32_shufps (__va, __va, _MM_SHUFFLE (0,0,0,0));\n-  __builtin_ia32_storeaps (__P, __tmp);\n+  *(__v4sf *)__P = (__v4sf)__A;\n }\n \n+/* Store four SPFP values.  The address need not be 16-byte aligned.  */\n static __inline void\n-_mm_store_ps1 (float *__P, __m128 __A)\n+_mm_storeu_ps (float *__P, __m128 __A)\n {\n-  _mm_store1_ps (__P, __A);\n+  __builtin_ia32_storeups (__P, (__v4sf)__A);\n }\n \n-/* Store four SPFP values.  The address must be 16-byte aligned.  */\n+/* Store the lower SPFP value across four words.  */\n static __inline void\n-_mm_store_ps (float *__P, __m128 __A)\n+_mm_store1_ps (float *__P, __m128 __A)\n {\n-  __builtin_ia32_storeaps (__P, (__v4sf)__A);\n+  __v4sf __va = (__v4sf)__A;\n+  __v4sf __tmp = __builtin_ia32_shufps (__va, __va, _MM_SHUFFLE (0,0,0,0));\n+  _mm_storeu_ps (__P, __tmp);\n }\n \n-/* Store four SPFP values.  The address need not be 16-byte aligned.  */\n static __inline void\n-_mm_storeu_ps (float *__P, __m128 __A)\n+_mm_store_ps1 (float *__P, __m128 __A)\n {\n-  __builtin_ia32_storeups (__P, (__v4sf)__A);\n+  _mm_store1_ps (__P, __A);\n }\n \n /* Store four SPFP values in reverse order.  The address must be aligned.  */\n@@ -953,7 +946,7 @@ _mm_storer_ps (float *__P, __m128 __A)\n {\n   __v4sf __va = (__v4sf)__A;\n   __v4sf __tmp = __builtin_ia32_shufps (__va, __va, _MM_SHUFFLE (0,1,2,3));\n-  __builtin_ia32_storeaps (__P, __tmp);\n+  _mm_store_ps (__P, __tmp);\n }\n \n /* Sets the low SPFP value of A from the low value of B.  */\n@@ -965,40 +958,39 @@ _mm_move_ss (__m128 __A, __m128 __B)\n \n /* Extracts one of the four words of A.  The selector N must be immediate.  */\n #if 0\n-static __inline int\n-_mm_extract_pi16 (__m64 __A, int __N)\n+static __inline int __attribute__((__always_inline__))\n+_mm_extract_pi16 (__m64 const __A, int const __N)\n {\n-  return __builtin_ia32_pextrw ((__v4hi)__A, __N);\n+  return __builtin_ia32_vec_ext_v4hi ((__v4hi)__A, __N);\n }\n \n-static __inline int\n-_m_pextrw (__m64 __A, int __N)\n+static __inline int __attribute__((__always_inline__))\n+_m_pextrw (__m64 const __A, int const __N)\n {\n   return _mm_extract_pi16 (__A, __N);\n }\n #else\n-#define _mm_extract_pi16(A, N) \\\n-  __builtin_ia32_pextrw ((__v4hi)(A), (N))\n+#define _mm_extract_pi16(A, N)\t__builtin_ia32_vec_ext_v4hi ((__v4hi)(A), (N))\n #define _m_pextrw(A, N)\t\t_mm_extract_pi16((A), (N))\n #endif\n \n /* Inserts word D into one of four words of A.  The selector N must be\n    immediate.  */\n #if 0\n-static __inline __m64\n-_mm_insert_pi16 (__m64 __A, int __D, int __N)\n+static __inline __m64 __attribute__((__always_inline__))\n+_mm_insert_pi16 (__m64 const __A, int const __D, int const __N)\n {\n-  return (__m64)__builtin_ia32_pinsrw ((__v4hi)__A, __D, __N);\n+  return (__m64) __builtin_ia32_vec_set_v4hi ((__v4hi)__A, __D, __N);\n }\n \n-static __inline __m64\n-_m_pinsrw (__m64 __A, int __D, int __N)\n+static __inline __m64 __attribute__((__always_inline__))\n+_m_pinsrw (__m64 const __A, int const __D, int const __N)\n {\n   return _mm_insert_pi16 (__A, __D, __N);\n }\n #else\n #define _mm_insert_pi16(A, D, N) \\\n-  ((__m64) __builtin_ia32_pinsrw ((__v4hi)(A), (D), (N)))\n+  ((__m64) __builtin_ia32_vec_set_v4hi ((__v4hi)(A), (D), (N)))\n #define _m_pinsrw(A, D, N)\t _mm_insert_pi16((A), (D), (N))\n #endif\n "}, {"sha": "f0dce0b2402011570582b183c7cf5e70642e20c3", "filename": "gcc/testsuite/gcc.target/i386/pr13366.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb701deb655a1ae74c35f2719d33c701544c7ccd/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr13366.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb701deb655a1ae74c35f2719d33c701544c7ccd/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr13366.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr13366.c?ref=eb701deb655a1ae74c35f2719d33c701544c7ccd", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -msse\" } */\n+\n+#include <xmmintrin.h>\n+\n+typedef unsigned short v4hi __attribute__ ((vector_size (8)));\n+\n+int f(unsigned short n)\n+{\n+   __m64 vec = (__m64)(v4hi){ 0, 0, 1, n };\n+   __m64 hw = _mm_mulhi_pi16 (vec, vec);\n+   return _mm_extract_pi16 (hw, 0);\n+}"}]}