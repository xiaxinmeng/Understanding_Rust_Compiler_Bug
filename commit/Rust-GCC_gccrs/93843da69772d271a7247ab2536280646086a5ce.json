{"sha": "93843da69772d271a7247ab2536280646086a5ce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTM4NDNkYTY5NzcyZDI3MWE3MjQ3YWIyNTM2MjgwNjQ2MDg2YTVjZQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-04-20T16:50:10Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-04-20T16:50:10Z"}, "message": "libstdc++: Add comparison operators to associative containers\n\nThe last C++20 changes from P1614R2, \"The Mothership has Landed\"\n\n\t* include/bits/stl_map.h (map): Define operator<=> and remove\n\toperator< for C++20.\n\t* include/bits/stl_multimap.h (multimap): Likewise.\n\t* include/bits/stl_multiset.h (multiset): Likewise.\n\t* include/bits/stl_set.h (set): Likewise.\n\t* include/bits/stl_tree.h (_Rb_tree): Likewise.\n\t(_Rb_tree_iterator, _Rb_tree_const_iterator): Remove redundant\n\toperator!= for C++20.\n\t* include/debug/map.h (__gnu_debug::map): Define operator<=> for C++20.\n\t* include/debug/multimap.h (__gnu_debug::multimap): Likewise.\n\t* include/debug/multiset.h (__gnu_debug::multiset): Likewise.\n\t* include/debug/set.h (__gnu_debug::set): Likewise.\n\t* testsuite/23_containers/map/operators/cmp_c++20.cc: New test.\n\t* testsuite/23_containers/multimap/operators/cmp_c++20.cc: New test.\n\t* testsuite/23_containers/multiset/operators/cmp_c++20.cc: New test.\n\t* testsuite/23_containers/set/operators/cmp_c++20.cc: New test.", "tree": {"sha": "ac24f19cc4285e116b942136827d9de82eda5791", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac24f19cc4285e116b942136827d9de82eda5791"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93843da69772d271a7247ab2536280646086a5ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93843da69772d271a7247ab2536280646086a5ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93843da69772d271a7247ab2536280646086a5ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93843da69772d271a7247ab2536280646086a5ce/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e1e6cdb8fb5ba4cb8a9836a4400f0317ffe0344", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e1e6cdb8fb5ba4cb8a9836a4400f0317ffe0344", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e1e6cdb8fb5ba4cb8a9836a4400f0317ffe0344"}], "stats": {"total": 631, "additions": 624, "deletions": 7}, "files": [{"sha": "3d0ddf5f36ebf5a2cfe47b0e92604293ad2e490a", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93843da69772d271a7247ab2536280646086a5ce/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93843da69772d271a7247ab2536280646086a5ce/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=93843da69772d271a7247ab2536280646086a5ce", "patch": "@@ -1,3 +1,22 @@\n+2020-04-20  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* include/bits/stl_map.h (map): Define operator<=> and remove\n+\toperator< for C++20.\n+\t* include/bits/stl_multimap.h (multimap): Likewise.\n+\t* include/bits/stl_multiset.h (multiset): Likewise.\n+\t* include/bits/stl_set.h (set): Likewise.\n+\t* include/bits/stl_tree.h (_Rb_tree): Likewise.\n+\t(_Rb_tree_iterator, _Rb_tree_const_iterator): Remove redundant\n+\toperator!= for C++20.\n+\t* include/debug/map.h (__gnu_debug::map): Define operator<=> for C++20.\n+\t* include/debug/multimap.h (__gnu_debug::multimap): Likewise.\n+\t* include/debug/multiset.h (__gnu_debug::multiset): Likewise.\n+\t* include/debug/set.h (__gnu_debug::set): Likewise.\n+\t* testsuite/23_containers/map/operators/cmp_c++20.cc: New test.\n+\t* testsuite/23_containers/multimap/operators/cmp_c++20.cc: New test.\n+\t* testsuite/23_containers/multiset/operators/cmp_c++20.cc: New test.\n+\t* testsuite/23_containers/set/operators/cmp_c++20.cc: New test.\n+\n 2020-04-20  Matthias Kretz  <kretz@kde.org>\n \n \t* testsuite/lib/libstdc++.exp: Avoid illegal argument to verbose."}, {"sha": "5039efd86b742ac061d257e5f8361af266ef2d62", "filename": "libstdc++-v3/include/bits/stl_map.h", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93843da69772d271a7247ab2536280646086a5ce/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93843da69772d271a7247ab2536280646086a5ce/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h?ref=93843da69772d271a7247ab2536280646086a5ce", "patch": "@@ -1400,10 +1400,17 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \toperator==(const map<_K1, _T1, _C1, _A1>&,\n \t\t   const map<_K1, _T1, _C1, _A1>&);\n \n+#if __cpp_lib_three_way_comparison\n+      template<typename _K1, typename _T1, typename _C1, typename _A1>\n+\tfriend __detail::__synth3way_t<pair<const _K1, _T1>>\n+\toperator<=>(const map<_K1, _T1, _C1, _A1>&,\n+\t\t    const map<_K1, _T1, _C1, _A1>&);\n+#else\n       template<typename _K1, typename _T1, typename _C1, typename _A1>\n \tfriend bool\n \toperator<(const map<_K1, _T1, _C1, _A1>&,\n \t\t  const map<_K1, _T1, _C1, _A1>&);\n+#endif\n     };\n \n \n@@ -1440,7 +1447,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     map(initializer_list<pair<_Key, _Tp>>, _Allocator)\n     -> map<_Key, _Tp, less<_Key>, _Allocator>;\n \n-#endif\n+#endif // deduction guides\n \n   /**\n    *  @brief  Map equality comparison.\n@@ -1458,6 +1465,27 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t       const map<_Key, _Tp, _Compare, _Alloc>& __y)\n     { return __x._M_t == __y._M_t; }\n \n+#if __cpp_lib_three_way_comparison\n+  /**\n+   *  @brief  Map ordering relation.\n+   *  @param  __x  A `map`.\n+   *  @param  __y  A `map` of the same type as `x`.\n+   *  @return  A value indicating whether `__x` is less than, equal to,\n+   *           greater than, or incomparable with `__y`.\n+   *\n+   *  This is a total ordering relation.  It is linear in the size of the\n+   *  maps.  The elements must be comparable with @c <.\n+   *\n+   *  See `std::lexicographical_compare_three_way()` for how the determination\n+   *  is made. This operator is used to synthesize relational operators like\n+   *  `<` and `>=` etc.\n+  */\n+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+    inline __detail::__synth3way_t<pair<const _Key, _Tp>>\n+    operator<=>(const map<_Key, _Tp, _Compare, _Alloc>& __x,\n+\t\tconst map<_Key, _Tp, _Compare, _Alloc>& __y)\n+    { return __x._M_t <=> __y._M_t; }\n+#else\n   /**\n    *  @brief  Map ordering relation.\n    *  @param  __x  A %map.\n@@ -1502,6 +1530,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     operator>=(const map<_Key, _Tp, _Compare, _Alloc>& __x,\n \t       const map<_Key, _Tp, _Compare, _Alloc>& __y)\n     { return !(__x < __y); }\n+#endif // three-way comparison\n \n   /// See std::map::swap().\n   template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>"}, {"sha": "65f4d0117a42685c0da33e508143f836a4fc7584", "filename": "libstdc++-v3/include/bits/stl_multimap.h", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93843da69772d271a7247ab2536280646086a5ce/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93843da69772d271a7247ab2536280646086a5ce/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h?ref=93843da69772d271a7247ab2536280646086a5ce", "patch": "@@ -1065,10 +1065,17 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \toperator==(const multimap<_K1, _T1, _C1, _A1>&,\n \t\t   const multimap<_K1, _T1, _C1, _A1>&);\n \n+#if __cpp_lib_three_way_comparison\n+      template<typename _K1, typename _T1, typename _C1, typename _A1>\n+\tfriend __detail::__synth3way_t<pair<const _K1, _T1>>\n+\toperator<=>(const multimap<_K1, _T1, _C1, _A1>&,\n+\t\t    const multimap<_K1, _T1, _C1, _A1>&);\n+#else\n       template<typename _K1, typename _T1, typename _C1, typename _A1>\n \tfriend bool\n \toperator<(const multimap<_K1, _T1, _C1, _A1>&,\n \t\t  const multimap<_K1, _T1, _C1, _A1>&);\n+#endif\n   };\n \n #if __cpp_deduction_guides >= 201606\n@@ -1104,7 +1111,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     multimap(initializer_list<pair<_Key, _Tp>>, _Allocator)\n     -> multimap<_Key, _Tp, less<_Key>, _Allocator>;\n \n-#endif\n+#endif // deduction guides\n \n   /**\n    *  @brief  Multimap equality comparison.\n@@ -1122,6 +1129,27 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t       const multimap<_Key, _Tp, _Compare, _Alloc>& __y)\n     { return __x._M_t == __y._M_t; }\n \n+#if __cpp_lib_three_way_comparison\n+  /**\n+   *  @brief  Multimap ordering relation.\n+   *  @param  __x  A `multimap`.\n+   *  @param  __y  A `multimap` of the same type as `x`.\n+   *  @return  A value indicating whether `__x` is less than, equal to,\n+   *           greater than, or incomparable with `__y`.\n+   *\n+   *  This is a total ordering relation.  It is linear in the size of the\n+   *  maps.  The elements must be comparable with @c <.\n+   *\n+   *  See `std::lexicographical_compare_three_way()` for how the determination\n+   *  is made. This operator is used to synthesize relational operators like\n+   *  `<` and `>=` etc.\n+  */\n+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+    inline __detail::__synth3way_t<pair<const _Key, _Tp>>\n+    operator<=>(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n+\t\tconst multimap<_Key, _Tp, _Compare, _Alloc>& __y)\n+    { return __x._M_t <=> __y._M_t; }\n+#else\n   /**\n    *  @brief  Multimap ordering relation.\n    *  @param  __x  A %multimap.\n@@ -1166,6 +1194,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     operator>=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n \t       const multimap<_Key, _Tp, _Compare, _Alloc>& __y)\n     { return !(__x < __y); }\n+#endif // three-way comparison\n \n   /// See std::multimap::swap().\n   template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>"}, {"sha": "bf6ae7de095f7eea083adf785be3c34f7d5201f7", "filename": "libstdc++-v3/include/bits/stl_multiset.h", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93843da69772d271a7247ab2536280646086a5ce/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93843da69772d271a7247ab2536280646086a5ce/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h?ref=93843da69772d271a7247ab2536280646086a5ce", "patch": "@@ -903,10 +903,17 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \toperator==(const multiset<_K1, _C1, _A1>&,\n \t\t   const multiset<_K1, _C1, _A1>&);\n \n+#if __cpp_lib_three_way_comparison\n+      template<typename _K1, typename _C1, typename _A1>\n+\tfriend __detail::__synth3way_t<_K1>\n+\toperator<=>(const multiset<_K1, _C1, _A1>&,\n+\t\t    const multiset<_K1, _C1, _A1>&);\n+#else\n       template<typename _K1, typename _C1, typename _A1>\n \tfriend bool\n \toperator< (const multiset<_K1, _C1, _A1>&,\n \t\t   const multiset<_K1, _C1, _A1>&);\n+#endif\n     };\n \n #if __cpp_deduction_guides >= 201606\n@@ -946,7 +953,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     multiset(initializer_list<_Key>, _Allocator)\n     -> multiset<_Key, less<_Key>, _Allocator>;\n \n-#endif\n+#endif // deduction guides\n \n   /**\n    *  @brief  Multiset equality comparison.\n@@ -965,6 +972,27 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t       const multiset<_Key, _Compare, _Alloc>& __y)\n     { return __x._M_t == __y._M_t; }\n \n+#if __cpp_lib_three_way_comparison\n+  /**\n+   *  @brief  Multiset ordering relation.\n+   *  @param  __x  A `multiset`.\n+   *  @param  __y  A `multiset` of the same type as `x`.\n+   *  @return  A value indicating whether `__x` is less than, equal to,\n+   *           greater than, or incomparable with `__y`.\n+   *\n+   *  This is a total ordering relation.  It is linear in the size of the\n+   *  maps.  The elements must be comparable with @c <.\n+   *\n+   *  See `std::lexicographical_compare_three_way()` for how the determination\n+   *  is made. This operator is used to synthesize relational operators like\n+   *  `<` and `>=` etc.\n+  */\n+  template<typename _Key, typename _Compare, typename _Alloc>\n+    inline __detail::__synth3way_t<_Key>\n+    operator<=>(const multiset<_Key, _Compare, _Alloc>& __x,\n+\t\tconst multiset<_Key, _Compare, _Alloc>& __y)\n+    { return __x._M_t <=> __y._M_t; }\n+#else\n   /**\n    *  @brief  Multiset ordering relation.\n    *  @param  __x  A %multiset.\n@@ -1009,6 +1037,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     operator>=(const multiset<_Key, _Compare, _Alloc>& __x,\n \t       const multiset<_Key, _Compare, _Alloc>& __y)\n     { return !(__x < __y); }\n+#endif // three-way comparison\n \n   /// See std::multiset::swap().\n   template<typename _Key, typename _Compare, typename _Alloc>"}, {"sha": "da426650815a45962aecba166d82601f15f1939e", "filename": "libstdc++-v3/include/bits/stl_set.h", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93843da69772d271a7247ab2536280646086a5ce/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93843da69772d271a7247ab2536280646086a5ce/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h?ref=93843da69772d271a7247ab2536280646086a5ce", "patch": "@@ -921,9 +921,15 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \tfriend bool\n \toperator==(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);\n \n+#if __cpp_lib_three_way_comparison\n+      template<typename _K1, typename _C1, typename _A1>\n+\tfriend __detail::__synth3way_t<_K1>\n+\toperator<=>(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);\n+#else\n       template<typename _K1, typename _C1, typename _A1>\n \tfriend bool\n \toperator<(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);\n+#endif\n     };\n \n #if __cpp_deduction_guides >= 201606\n@@ -962,7 +968,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     set(initializer_list<_Key>, _Allocator)\n     -> set<_Key, less<_Key>, _Allocator>;\n \n-#endif\n+#endif // deduction guides\n \n   /**\n    *  @brief  Set equality comparison.\n@@ -980,6 +986,27 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t       const set<_Key, _Compare, _Alloc>& __y)\n     { return __x._M_t == __y._M_t; }\n \n+#if __cpp_lib_three_way_comparison\n+  /**\n+   *  @brief  Set ordering relation.\n+   *  @param  __x  A `set`.\n+   *  @param  __y  A `set` of the same type as `x`.\n+   *  @return  A value indicating whether `__x` is less than, equal to,\n+   *           greater than, or incomparable with `__y`.\n+   *\n+   *  This is a total ordering relation.  It is linear in the size of the\n+   *  maps.  The elements must be comparable with @c <.\n+   *\n+   *  See `std::lexicographical_compare_three_way()` for how the determination\n+   *  is made. This operator is used to synthesize relational operators like\n+   *  `<` and `>=` etc.\n+  */\n+  template<typename _Key, typename _Compare, typename _Alloc>\n+    inline __detail::__synth3way_t<_Key>\n+    operator<=>(const set<_Key, _Compare, _Alloc>& __x,\n+\t\tconst set<_Key, _Compare, _Alloc>& __y)\n+    { return __x._M_t <=> __y._M_t; }\n+#else\n   /**\n    *  @brief  Set ordering relation.\n    *  @param  __x  A %set.\n@@ -1024,6 +1051,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     operator>=(const set<_Key, _Compare, _Alloc>& __x,\n \t       const set<_Key, _Compare, _Alloc>& __y)\n     { return !(__x < __y); }\n+#endif // three-way comparison\n \n   /// See std::set::swap().\n   template<typename _Key, typename _Compare, typename _Alloc>"}, {"sha": "5be15afa25754f8a7a2c405c55328a08bbf1be34", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93843da69772d271a7247ab2536280646086a5ce/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93843da69772d271a7247ab2536280646086a5ce/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=93843da69772d271a7247ab2536280646086a5ce", "patch": "@@ -315,9 +315,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       operator==(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT\n       { return __x._M_node == __y._M_node; }\n \n+#if ! __cpp_lib_three_way_comparison\n       friend bool\n       operator!=(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT\n       { return __x._M_node != __y._M_node; }\n+#endif\n \n       _Base_ptr _M_node;\n   };\n@@ -394,9 +396,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       operator==(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT\n       { return __x._M_node == __y._M_node; }\n \n+#if ! __cpp_lib_three_way_comparison\n       friend bool\n       operator!=(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT\n       { return __x._M_node != __y._M_node; }\n+#endif\n \n       _Base_ptr _M_node;\n     };\n@@ -1610,6 +1614,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  && std::equal(__x.begin(), __x.end(), __y.begin());\n       }\n \n+#if __cpp_lib_three_way_comparison\n+      friend auto\n+      operator<=>(const _Rb_tree& __x, const _Rb_tree& __y)\n+      {\n+\tif constexpr (requires { typename __detail::__synth3way_t<_Val>; })\n+\t  return std::lexicographical_compare_three_way(__x.begin(), __x.end(),\n+\t\t\t\t\t\t\t__y.begin(), __y.end(),\n+\t\t\t\t\t\t\t__detail::__synth3way);\n+      }\n+#else\n       friend bool\n       operator<(const _Rb_tree& __x, const _Rb_tree& __y)\n       {\n@@ -1632,6 +1646,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       friend bool _GLIBCXX_DEPRECATED\n       operator>=(const _Rb_tree& __x, const _Rb_tree& __y)\n       { return !(__x < __y); }\n+#endif\n     };\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,"}, {"sha": "adbabf62915cb8360d591820012918b46eebddb4", "filename": "libstdc++-v3/include/debug/map.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93843da69772d271a7247ab2536280646086a5ce/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93843da69772d271a7247ab2536280646086a5ce/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmap.h?ref=93843da69772d271a7247ab2536280646086a5ce", "patch": "@@ -731,7 +731,7 @@ namespace __debug\n     map(initializer_list<pair<_Key, _Tp>>, _Allocator)\n     -> map<_Key, _Tp, less<_Key>, _Allocator>;\n \n-#endif\n+#endif // deduction guides\n \n   template<typename _Key, typename _Tp,\n \t   typename _Compare, typename _Allocator>\n@@ -740,6 +740,13 @@ namespace __debug\n \t       const map<_Key, _Tp, _Compare, _Allocator>& __rhs)\n     { return __lhs._M_base() == __rhs._M_base(); }\n \n+#if __cpp_lib_three_way_comparison\n+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+    inline __detail::__synth3way_t<pair<const _Key, _Tp>>\n+    operator<=>(const map<_Key, _Tp, _Compare, _Alloc>& __lhs,\n+\t\tconst map<_Key, _Tp, _Compare, _Alloc>& __rhs)\n+    { return __lhs._M_base() <=> __rhs._M_base(); }\n+#else\n   template<typename _Key, typename _Tp,\n \t   typename _Compare, typename _Allocator>\n     inline bool\n@@ -774,6 +781,7 @@ namespace __debug\n     operator>(const map<_Key, _Tp, _Compare, _Allocator>& __lhs,\n \t      const map<_Key, _Tp, _Compare, _Allocator>& __rhs)\n     { return __lhs._M_base() > __rhs._M_base(); }\n+#endif // three-way comparison\n \n   template<typename _Key, typename _Tp,\n \t   typename _Compare, typename _Allocator>"}, {"sha": "6cba52d35dc1c03b891dee70e0f6bb572526dca0", "filename": "libstdc++-v3/include/debug/multimap.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93843da69772d271a7247ab2536280646086a5ce/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93843da69772d271a7247ab2536280646086a5ce/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultimap.h?ref=93843da69772d271a7247ab2536280646086a5ce", "patch": "@@ -621,6 +621,13 @@ namespace __debug\n \t       const multimap<_Key, _Tp, _Compare, _Allocator>& __rhs)\n     { return __lhs._M_base() == __rhs._M_base(); }\n \n+#if __cpp_lib_three_way_comparison\n+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+    inline __detail::__synth3way_t<pair<const _Key, _Tp>>\n+    operator<=>(const multimap<_Key, _Tp, _Compare, _Alloc>& __lhs,\n+\t\tconst multimap<_Key, _Tp, _Compare, _Alloc>& __rhs)\n+    { return __lhs._M_base() <=> __rhs._M_base(); }\n+#else\n   template<typename _Key, typename _Tp,\n \t   typename _Compare, typename _Allocator>\n     inline bool\n@@ -655,6 +662,7 @@ namespace __debug\n     operator>(const multimap<_Key, _Tp, _Compare, _Allocator>& __lhs,\n \t      const multimap<_Key, _Tp, _Compare, _Allocator>& __rhs)\n     { return __lhs._M_base() > __rhs._M_base(); }\n+#endif // three-way comparison\n \n   template<typename _Key, typename _Tp,\n \t   typename _Compare, typename _Allocator>"}, {"sha": "a2d5e717b34460b0cb2169b71a209cf55c2f4def", "filename": "libstdc++-v3/include/debug/multiset.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93843da69772d271a7247ab2536280646086a5ce/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93843da69772d271a7247ab2536280646086a5ce/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultiset.h?ref=93843da69772d271a7247ab2536280646086a5ce", "patch": "@@ -584,14 +584,21 @@ namespace __debug\n     multiset(initializer_list<_Key>, _Allocator)\n     -> multiset<_Key, less<_Key>, _Allocator>;\n \n-#endif\n+#endif // deduction guides\n \n   template<typename _Key, typename _Compare, typename _Allocator>\n     inline bool\n     operator==(const multiset<_Key, _Compare, _Allocator>& __lhs,\n \t       const multiset<_Key, _Compare, _Allocator>& __rhs)\n     { return __lhs._M_base() == __rhs._M_base(); }\n \n+#if __cpp_lib_three_way_comparison\n+  template<typename _Key, typename _Compare, typename _Alloc>\n+    inline __detail::__synth3way_t<_Key>\n+    operator<=>(const multiset<_Key, _Compare, _Alloc>& __lhs,\n+\t\tconst multiset<_Key, _Compare, _Alloc>& __rhs)\n+    { return __lhs._M_base() <=> __rhs._M_base(); }\n+#else\n   template<typename _Key, typename _Compare, typename _Allocator>\n     inline bool\n     operator!=(const multiset<_Key, _Compare, _Allocator>& __lhs,\n@@ -621,6 +628,7 @@ namespace __debug\n     operator>(const multiset<_Key, _Compare, _Allocator>& __lhs,\n \t      const multiset<_Key, _Compare, _Allocator>& __rhs)\n     { return __lhs._M_base() > __rhs._M_base(); }\n+#endif // three-way comparison\n \n   template<typename _Key, typename _Compare, typename _Allocator>\n     void"}, {"sha": "210186623dfdcef282bcf5d7d3bdfdb7296b94cc", "filename": "libstdc++-v3/include/debug/set.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93843da69772d271a7247ab2536280646086a5ce/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93843da69772d271a7247ab2536280646086a5ce/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fset.h?ref=93843da69772d271a7247ab2536280646086a5ce", "patch": "@@ -595,14 +595,21 @@ namespace __debug\n     set(initializer_list<_Key>, _Allocator)\n     -> set<_Key, less<_Key>, _Allocator>;\n \n-#endif\n+#endif // deduction guides\n \n   template<typename _Key, typename _Compare, typename _Allocator>\n     inline bool\n     operator==(const set<_Key, _Compare, _Allocator>& __lhs,\n \t       const set<_Key, _Compare, _Allocator>& __rhs)\n     { return __lhs._M_base() == __rhs._M_base(); }\n \n+#if __cpp_lib_three_way_comparison\n+  template<typename _Key, typename _Compare, typename _Alloc>\n+    inline __detail::__synth3way_t<_Key>\n+    operator<=>(const set<_Key, _Compare, _Alloc>& __lhs,\n+\t\tconst set<_Key, _Compare, _Alloc>& __rhs)\n+    { return __lhs._M_base() <=> __rhs._M_base(); }\n+#else\n   template<typename _Key, typename _Compare, typename _Allocator>\n     inline bool\n     operator!=(const set<_Key, _Compare, _Allocator>& __lhs,\n@@ -632,6 +639,7 @@ namespace __debug\n     operator>(const set<_Key, _Compare, _Allocator>& __lhs,\n \t      const set<_Key, _Compare, _Allocator>& __rhs)\n     { return __lhs._M_base() > __rhs._M_base(); }\n+#endif // three-way comparison\n \n   template<typename _Key, typename _Compare, typename _Allocator>\n     void"}, {"sha": "a586a6df648b8f3b6c6fbe81eae1b03a76a36454", "filename": "libstdc++-v3/testsuite/23_containers/map/operators/cmp_c++20.cc", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93843da69772d271a7247ab2536280646086a5ce/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Foperators%2Fcmp_c%2B%2B20.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93843da69772d271a7247ab2536280646086a5ce/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Foperators%2Fcmp_c%2B%2B20.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Foperators%2Fcmp_c%2B%2B20.cc?ref=93843da69772d271a7247ab2536280646086a5ce", "patch": "@@ -0,0 +1,111 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <map>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  std::map<int, int> c1{ {1,1}, {2,1}, {3,1} };\n+  std::map<int, int> c2{ {1,1}, {2,1}, {3,1}, {4,1} };\n+  std::map<int, int> c3{ {1,1}, {2,1}, {3,2} };\n+  VERIFY( c1 == c1 );\n+  VERIFY( std::is_eq(c1 <=> c1) );\n+  VERIFY( c1 < c2 );\n+  VERIFY( std::is_lt(c1 <=> c2) );\n+  VERIFY( c1 < c3 );\n+  VERIFY( std::is_lt(c1 <=> c3) );\n+  VERIFY( c2 < c3 );\n+  VERIFY( std::is_lt(c2 <=> c3) );\n+\n+  static_assert( std::totally_ordered<std::map<int, int>> );\n+\n+  static_assert( std::three_way_comparable<std::map<int, int>,\n+\t\t\t\t\t   std::strong_ordering> );\n+  static_assert( ! std::three_way_comparable<std::map<int, float>,\n+\t\t\t\t\t     std::strong_ordering> );\n+  static_assert( ! std::three_way_comparable<std::map<int, float>,\n+\t\t\t\t\t     std::weak_ordering> );\n+  static_assert( std::three_way_comparable<std::map<int, float>,\n+\t\t\t\t\t   std::partial_ordering> );\n+\n+  struct E\n+  {\n+    bool operator==(E) { return true; }\n+  };\n+  static_assert( ! std::totally_ordered<std::map<int, E>> );\n+  static_assert( ! std::three_way_comparable<E> );\n+  static_assert( ! std::three_way_comparable<std::map<int, E>> );\n+}\n+\n+void\n+test02()\n+{\n+  struct W\n+  {\n+    int value = 0;\n+\n+    bool operator==(W rhs) const noexcept\n+    { return (value | 1) == (rhs.value | 1); }\n+\n+    std::weak_ordering\n+    operator<=>(W rhs) const noexcept\n+    { return (value | 1) <=> (rhs.value | 1); }\n+  };\n+\n+  static_assert( std::totally_ordered<std::map<int, W>> );\n+\n+  using P = std::pair<const W, W>;\n+  std::map<W, W> c1{ P{1,1}, P{2,2}, P{3,3} }, c2{ P{1,0}, P{3,2}, P{3,3} };\n+  static_assert( std::same_as<decltype(c1 <=> c1), std::weak_ordering> );\n+  VERIFY( c1 == c2 );\n+  VERIFY( std::is_eq(c1 <=> c2) );\n+}\n+\n+void\n+test04()\n+{\n+  struct L\n+  {\n+    int value = 0;\n+\n+    bool operator<(L rhs) const noexcept { return value < rhs.value; }\n+  };\n+\n+  static_assert( std::totally_ordered<std::map<int, L>> );\n+\n+  using P = std::pair<const L, L>;\n+  std::map<L, L> c{ P{1,1}, P{2,2}, P{3,3} }, d{ P{1,1}, P{2,2}, P{3,4} };\n+  static_assert( std::same_as<decltype(c <=> c), std::weak_ordering> );\n+  VERIFY( std::is_lt(c <=> d) );\n+}\n+\n+// Associative container iterators are not random access\n+static_assert( ! std::totally_ordered<std::map<int, int>::iterator> );\n+static_assert( ! std::three_way_comparable<std::map<int, int>::iterator> );\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test04();\n+}"}, {"sha": "350ed3e6a1511a8b1f844b3fcfb9ba66750be22e", "filename": "libstdc++-v3/testsuite/23_containers/multimap/operators/cmp_c++20.cc", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93843da69772d271a7247ab2536280646086a5ce/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Foperators%2Fcmp_c%2B%2B20.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93843da69772d271a7247ab2536280646086a5ce/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Foperators%2Fcmp_c%2B%2B20.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Foperators%2Fcmp_c%2B%2B20.cc?ref=93843da69772d271a7247ab2536280646086a5ce", "patch": "@@ -0,0 +1,111 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <map>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  std::multimap<int, int> c1{ {1,1}, {2,1}, {3,1} };\n+  std::multimap<int, int> c2{ {1,1}, {2,1}, {3,1}, {4,1} };\n+  std::multimap<int, int> c3{ {1,1}, {2,1}, {3,2} };\n+  VERIFY( c1 == c1 );\n+  VERIFY( std::is_eq(c1 <=> c1) );\n+  VERIFY( c1 < c2 );\n+  VERIFY( std::is_lt(c1 <=> c2) );\n+  VERIFY( c1 < c3 );\n+  VERIFY( std::is_lt(c1 <=> c3) );\n+  VERIFY( c2 < c3 );\n+  VERIFY( std::is_lt(c2 <=> c3) );\n+\n+  static_assert( std::totally_ordered<std::multimap<int, int>> );\n+\n+  static_assert( std::three_way_comparable<std::multimap<int, int>,\n+\t\t\t\t\t   std::strong_ordering> );\n+  static_assert( ! std::three_way_comparable<std::multimap<int, float>,\n+\t\t\t\t\t     std::strong_ordering> );\n+  static_assert( ! std::three_way_comparable<std::multimap<int, float>,\n+\t\t\t\t\t     std::weak_ordering> );\n+  static_assert( std::three_way_comparable<std::multimap<int, float>,\n+\t\t\t\t\t   std::partial_ordering> );\n+\n+  struct E\n+  {\n+    bool operator==(E) { return true; }\n+  };\n+  static_assert( ! std::totally_ordered<std::multimap<int, E>> );\n+  static_assert( ! std::three_way_comparable<E> );\n+  static_assert( ! std::three_way_comparable<std::multimap<int, E>> );\n+}\n+\n+void\n+test02()\n+{\n+  struct W\n+  {\n+    int value = 0;\n+\n+    bool operator==(W rhs) const noexcept\n+    { return (value | 1) == (rhs.value | 1); }\n+\n+    std::weak_ordering\n+    operator<=>(W rhs) const noexcept\n+    { return (value | 1) <=> (rhs.value | 1); }\n+  };\n+\n+  static_assert( std::totally_ordered<std::multimap<int, W>> );\n+\n+  using P = std::pair<const W, W>;\n+  std::multimap<W, W> c1{ P{1,1}, P{2,2}, P{3,3} }, c2{ P{1,0}, P{3,2}, P{3,3} };\n+  static_assert( std::same_as<decltype(c1 <=> c1), std::weak_ordering> );\n+  VERIFY( c1 == c2 );\n+  VERIFY( std::is_eq(c1 <=> c2) );\n+}\n+\n+void\n+test04()\n+{\n+  struct L\n+  {\n+    int value = 0;\n+\n+    bool operator<(L rhs) const noexcept { return value < rhs.value; }\n+  };\n+\n+  static_assert( std::totally_ordered<std::multimap<int, L>> );\n+\n+  using P = std::pair<const L, L>;\n+  std::multimap<L, L> c{ P{1,1}, P{2,2}, P{3,3} }, d{ P{1,1}, P{2,2}, P{3,4} };\n+  static_assert( std::same_as<decltype(c <=> c), std::weak_ordering> );\n+  VERIFY( std::is_lt(c <=> d) );\n+}\n+\n+// Associative container iterators are not random access\n+static_assert( ! std::totally_ordered<std::multimap<int, int>::iterator> );\n+static_assert( ! std::three_way_comparable<std::multimap<int, int>::iterator> );\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test04();\n+}"}, {"sha": "94cb799189187c994209e9d1d2a0504c4e646d2c", "filename": "libstdc++-v3/testsuite/23_containers/multiset/operators/cmp_c++20.cc", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93843da69772d271a7247ab2536280646086a5ce/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Foperators%2Fcmp_c%2B%2B20.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93843da69772d271a7247ab2536280646086a5ce/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Foperators%2Fcmp_c%2B%2B20.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Foperators%2Fcmp_c%2B%2B20.cc?ref=93843da69772d271a7247ab2536280646086a5ce", "patch": "@@ -0,0 +1,107 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <set>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  std::multiset<int> c1{ 1, 2, 3 }, c2{ 1, 2, 3, 4 }, c3{ 1, 2, 4 };\n+  VERIFY( c1 == c1 );\n+  VERIFY( std::is_eq(c1 <=> c1) );\n+  VERIFY( c1 < c2 );\n+  VERIFY( std::is_lt(c1 <=> c2) );\n+  VERIFY( c1 < c3 );\n+  VERIFY( std::is_lt(c1 <=> c3) );\n+  VERIFY( c2 < c3 );\n+  VERIFY( std::is_lt(c2 <=> c3) );\n+\n+  static_assert( std::totally_ordered<std::multiset<int>> );\n+\n+  static_assert( std::three_way_comparable<std::multiset<int>,\n+\t\t\t\t\t   std::strong_ordering> );\n+  static_assert( ! std::three_way_comparable<std::multiset<float>,\n+\t\t\t\t\t     std::strong_ordering> );\n+  static_assert( ! std::three_way_comparable<std::multiset<float>,\n+\t\t\t\t\t     std::weak_ordering> );\n+  static_assert( std::three_way_comparable<std::multiset<float>,\n+\t\t\t\t\t   std::partial_ordering> );\n+\n+  struct E\n+  {\n+    bool operator==(E) { return true; }\n+  };\n+  static_assert( ! std::totally_ordered<std::multiset<E>> );\n+  static_assert( ! std::three_way_comparable<E> );\n+  static_assert( ! std::three_way_comparable<std::multiset<E>> );\n+}\n+\n+void\n+test02()\n+{\n+  struct W\n+  {\n+    int value = 0;\n+\n+    bool operator==(W rhs) const noexcept\n+    { return (value | 1) == (rhs.value | 1); }\n+\n+    std::weak_ordering\n+    operator<=>(W rhs) const noexcept\n+    { return (value | 1) <=> (rhs.value | 1); }\n+  };\n+\n+  static_assert( std::totally_ordered<std::multiset<W>> );\n+\n+  std::multiset<W> c1{ {1}, {2}, {3} }, c2{ {0}, {3}, {3} };\n+  static_assert( std::same_as<decltype(c1 <=> c1), std::weak_ordering> );\n+  VERIFY( c1 == c2 );\n+  VERIFY( std::is_eq(c1 <=> c2) );\n+}\n+\n+void\n+test04()\n+{\n+  struct L\n+  {\n+    int value = 0;\n+\n+    bool operator<(L rhs) const noexcept { return value < rhs.value; }\n+  };\n+\n+  static_assert( std::totally_ordered<std::multiset<L>> );\n+\n+  std::multiset<L> c{ {1}, {2}, {3} }, d{ {1}, {2}, {3}, {4} };\n+  static_assert( std::same_as<decltype(c <=> c), std::weak_ordering> );\n+  VERIFY( std::is_lt(c <=> d) );\n+}\n+\n+// Associative container iterators are not random access\n+static_assert( ! std::totally_ordered<std::multiset<int>::iterator> );\n+static_assert( ! std::three_way_comparable<std::multiset<int>::iterator> );\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test04();\n+}"}, {"sha": "fbc95c4c6f02874f42b529e2e88ce4dc73db40a9", "filename": "libstdc++-v3/testsuite/23_containers/set/operators/cmp_c++20.cc", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93843da69772d271a7247ab2536280646086a5ce/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Foperators%2Fcmp_c%2B%2B20.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93843da69772d271a7247ab2536280646086a5ce/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Foperators%2Fcmp_c%2B%2B20.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Foperators%2Fcmp_c%2B%2B20.cc?ref=93843da69772d271a7247ab2536280646086a5ce", "patch": "@@ -0,0 +1,107 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <set>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  std::set<int> c1{ 1, 2, 3 }, c2{ 1, 2, 3, 4 }, c3{ 1, 2, 4 };\n+  VERIFY( c1 == c1 );\n+  VERIFY( std::is_eq(c1 <=> c1) );\n+  VERIFY( c1 < c2 );\n+  VERIFY( std::is_lt(c1 <=> c2) );\n+  VERIFY( c1 < c3 );\n+  VERIFY( std::is_lt(c1 <=> c3) );\n+  VERIFY( c2 < c3 );\n+  VERIFY( std::is_lt(c2 <=> c3) );\n+\n+  static_assert( std::totally_ordered<std::set<int>> );\n+\n+  static_assert( std::three_way_comparable<std::set<int>,\n+\t\t\t\t\t   std::strong_ordering> );\n+  static_assert( ! std::three_way_comparable<std::set<float>,\n+\t\t\t\t\t     std::strong_ordering> );\n+  static_assert( ! std::three_way_comparable<std::set<float>,\n+\t\t\t\t\t     std::weak_ordering> );\n+  static_assert( std::three_way_comparable<std::set<float>,\n+\t\t\t\t\t   std::partial_ordering> );\n+\n+  struct E\n+  {\n+    bool operator==(E) { return true; }\n+  };\n+  static_assert( ! std::totally_ordered<std::set<E>> );\n+  static_assert( ! std::three_way_comparable<E> );\n+  static_assert( ! std::three_way_comparable<std::set<E>> );\n+}\n+\n+void\n+test02()\n+{\n+  struct W\n+  {\n+    int value = 0;\n+\n+    bool operator==(W rhs) const noexcept\n+    { return (value | 1) == (rhs.value | 1); }\n+\n+    std::weak_ordering\n+    operator<=>(W rhs) const noexcept\n+    { return (value | 1) <=> (rhs.value | 1); }\n+  };\n+\n+  static_assert( std::totally_ordered<std::set<W>> );\n+\n+  std::set<W> c1{ {1}, {2}, {3} }, c2{ {0}, {3}, {3} };\n+  static_assert( std::same_as<decltype(c1 <=> c1), std::weak_ordering> );\n+  VERIFY( c1 == c2 );\n+  VERIFY( std::is_eq(c1 <=> c2) );\n+}\n+\n+void\n+test04()\n+{\n+  struct L\n+  {\n+    int value = 0;\n+\n+    bool operator<(L rhs) const noexcept { return value < rhs.value; }\n+  };\n+\n+  static_assert( std::totally_ordered<std::set<L>> );\n+\n+  std::set<L> c{ {1}, {2}, {3} }, d{ {1}, {2}, {3}, {4} };\n+  static_assert( std::same_as<decltype(c <=> c), std::weak_ordering> );\n+  VERIFY( std::is_lt(c <=> d) );\n+}\n+\n+// Associative container iterators are not random access\n+static_assert( ! std::totally_ordered<std::set<int>::iterator> );\n+static_assert( ! std::three_way_comparable<std::set<int>::iterator> );\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test04();\n+}"}]}