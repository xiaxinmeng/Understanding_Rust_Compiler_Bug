{"sha": "d80aeff0bf2f455e9099def756f612bfbcd2cb0d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDgwYWVmZjBiZjJmNDU1ZTkwOTlkZWY3NTZmNjEyYmZiY2QyY2IwZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-05-13T14:53:48Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-05-13T14:53:48Z"}, "message": "openmp: Add testcases to verify OpenMP 5.0 2.14 and OpenMP 5.1 2.17 rules [PR99928]\n\nIn preparation of PR99928 patch review, I've prepared testcases with clauses\nthat need more interesting handling on combined/composite constructs,\nin particular firstprivate, lastprivate, firstprivate+lastprivate, linear\n(explicit on non-iv, explicit on simd iv, implicit on simd iv, implicit on\nsimd iv declared in the construct), reduction (scalars, array sections of\narray variables, array sections with pointer bases) and in_reduction.\n\nOpenMP 5.0 had the wording broken for reduction, the intended rule to use\nmap(tofrom:) on target when combined with it was bound only on inscan modifier\npresence which makes no sense, as then inscan may not be used, this has\nbeen fixed in 5.1 and I'm just assuming 5.1 wording for that.\n\nThere are various cases where e.g. from historical or optimization reasons\nGCC slightly deviates from the rules, but in most cases it is something\nthat shouldn't be really observable, e.g. whether\n  #pragma omp parallel for firstprivate(x)\nis handled as\n  #pragma omp parallel shared(x)\n  #pragma omp for firstprivate(x)\nor\n  #pragma omp parallel firstprivate(x)\n  #pragma omp for\nshouldn't be possible to distinguish in user code.  I've added FIXMEs\nin the testcases about that, but maybe we just should keep it as is\n(alternative would be to do it in standard compliant way and transform\ninto whatever we like after gimplification (e.g. early during omplower)).\nSome cases we for historical reasons implement even with clauses on\nconstructs which in the standard don't accept them that way and then\nhandling those magically in omp lowering/expansion, in particular e.g.\n  #pragma omp parallel for firstprivate(x) lastprivate(x)\nwe treat as\n  #pragma omp parallel firstprivate(x) lastprivate(x)\n  #pragma omp for\neven when lastprivate is not valid on parallel.  Maybe one day we\ncould change that if we make sure we don't regress generated code quality.\n\nI've also found a bug in OpenMP 5.0/5.1,\n  #pragma omp parallel sections firstprivate(x) lastprivate(x)\nincorrectly says that it should be handled as\n  #pragma omp parallel firstprivate(x)\n  #pragma omp sections lastprivate(x)\nwhich when written that way results in error; filed as\nhttps://github.com/OpenMP/spec/issues/2758\nto be fixed in OpenMP 5.2.  GCC handles it the way it used to do\nand users expect, so nothing to fix on the GCC side.\n\nAlso, we don't support yet in_reduction clause on target construct,\nwhich means the -11.c testcase can't include any tests about in_reduction\nhandling on all the composite constructs that include target.\n\nThe work found two kinds of bugs on the GCC side, one is the known thing\nthat we implement still the 4.5 behavior and don't mark for\nlastprivate/linear/reduction the list item as map(tofrom:) as mentioned\nin PR99928.  These cases are xfailed in the tests.\n\nAnd another one is with r21 and r28 in -{8,9,10}.c tests - we don't add\nreduction clause on teams for\n  #pragma omp {target ,}teams distribute simd reduction(+:r)\neven when the spec says that teams shouldn't receive reduction only\nwhen combined with loop construct.\n\nIn\nmake check-gcc check-g++ RUNTESTFLAGS='--target_board=unix\\{-m32,-m64\\} gomp.exp=pr99928*'\ntesting this shows:\n\n  # of expected passes\t\t5648\n  # of expected failures\t872\n\nand with Tobias' patch applied:\n\n  # of expected passes\t\t5648\n  # of unexpected successes\t384\n  # of expected failures\t488\n\n2021-05-13  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR middle-end/99928\n\t* c-c++-common/gomp/pr99928-1.c: New test.\n\t* c-c++-common/gomp/pr99928-2.c: New test.\n\t* c-c++-common/gomp/pr99928-3.c: New test.\n\t* c-c++-common/gomp/pr99928-4.c: New test.\n\t* c-c++-common/gomp/pr99928-5.c: New test.\n\t* c-c++-common/gomp/pr99928-6.c: New test.\n\t* c-c++-common/gomp/pr99928-7.c: New test.\n\t* c-c++-common/gomp/pr99928-8.c: New test.\n\t* c-c++-common/gomp/pr99928-9.c: New test.\n\t* c-c++-common/gomp/pr99928-10.c: New test.\n\t* c-c++-common/gomp/pr99928-11.c: New test.", "tree": {"sha": "857a34cecfeb50fb67d6da54c69c3cffa89ec493", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/857a34cecfeb50fb67d6da54c69c3cffa89ec493"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d80aeff0bf2f455e9099def756f612bfbcd2cb0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d80aeff0bf2f455e9099def756f612bfbcd2cb0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d80aeff0bf2f455e9099def756f612bfbcd2cb0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d80aeff0bf2f455e9099def756f612bfbcd2cb0d/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "efd471a980662f113dad8de0c0ef8593d0d38419", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efd471a980662f113dad8de0c0ef8593d0d38419", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efd471a980662f113dad8de0c0ef8593d0d38419"}], "stats": {"total": 1623, "additions": 1623, "deletions": 0}, "files": [{"sha": "37181fdeaa81b287b7aff6c560d8dfe691e71ef7", "filename": "gcc/testsuite/c-c++-common/gomp/pr99928-1.c", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d80aeff0bf2f455e9099def756f612bfbcd2cb0d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d80aeff0bf2f455e9099def756f612bfbcd2cb0d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-1.c?ref=d80aeff0bf2f455e9099def756f612bfbcd2cb0d", "patch": "@@ -0,0 +1,206 @@\n+/* PR middle-end/99928 */\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-gimple\" } */\n+\n+int f00, f01, f02, f03, f04, f05, f06, f07, f08, f09;\n+int f12, f13, f14, f15, f16, f17, f18, f19;\n+int f20, f21, f22, f23, f24, f25, f26, f27, f28, f29;\n+\n+void\n+foo (void)\n+{\n+  /* { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*firstprivate\\\\(f00\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*firstprivate\\\\(f00\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*firstprivate\\\\(f00\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  #pragma omp distribute parallel for firstprivate (f00)\n+  for (int i = 0; i < 64; i++)\n+    f00++;\n+  /* { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*firstprivate\\\\(f01\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*firstprivate\\\\(f01\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*firstprivate\\\\(f01\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump-not \"omp simd\\[^\\n\\r]*firstprivate\\\\(f01\\\\)\" \"gimple\" } } */\n+  #pragma omp distribute parallel for simd firstprivate (f01)\n+  for (int i = 0; i < 64; i++)\n+    f01++;\n+  /* { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*firstprivate\\\\(f02\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp simd\\[^\\n\\r]*firstprivate\\\\(f02\\\\)\" \"gimple\" } } */\n+  #pragma omp distribute simd firstprivate (f02)\n+  for (int i = 0; i < 64; i++)\n+    f02++;\n+}\n+\n+void\n+bar (void)\n+{\n+  int f10 = 0, f11 = 0;\n+  /* { dg-final { scan-tree-dump \"omp for\\[^\\n\\r]*firstprivate\\\\(f03\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp simd\\[^\\n\\r]*firstprivate\\\\(f03\\\\)\" \"gimple\" } } */\n+  #pragma omp for simd firstprivate (f03)\n+  for (int i = 0; i < 64; i++)\n+    f03++;\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*firstprivate\\\\(f04\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*firstprivate\\\\(f04\\\\)\" \"gimple\" } } */\n+  #pragma omp master taskloop firstprivate (f04)\n+  for (int i = 0; i < 64; i++)\n+    f04++;\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*firstprivate\\\\(f05\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*firstprivate\\\\(f05\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp simd\\[^\\n\\r]*firstprivate\\\\(f05\\\\)\" \"gimple\" } } */\n+  #pragma omp master taskloop simd firstprivate (f05)\n+  for (int i = 0; i < 64; i++)\n+    f05++;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*firstprivate\\\\(f06\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*firstprivate\\\\(f06\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  #pragma omp parallel for firstprivate (f06)\n+  for (int i = 0; i < 64; i++)\n+    f06++;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*firstprivate\\\\(f07\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*firstprivate\\\\(f07\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump-not \"omp simd\\[^\\n\\r]*firstprivate\\\\(f07\\\\)\" \"gimple\" } } */\n+  #pragma omp parallel for simd firstprivate (f07)\n+  for (int i = 0; i < 64; i++)\n+    f07++;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*firstprivate\\\\(f08\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*firstprivate\\\\(f08\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp simd\\[^\\n\\r]*firstprivate\\\\(f08\\\\)\" \"gimple\" } } */\n+  #pragma omp parallel loop firstprivate (f08)\n+  for (int i = 0; i < 64; i++)\n+    f08++;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*firstprivate\\\\(f09\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*firstprivate\\\\(f09\\\\)\" \"gimple\" } } */\n+  #pragma omp parallel master firstprivate (f09)\n+  f09++;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*shared\\\\(f10\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*firstprivate\\\\(f10\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*firstprivate\\\\(f10\\\\)\" \"gimple\" } } */\n+  #pragma omp parallel master taskloop firstprivate (f10)\n+  for (int i = 0; i < 64; i++)\n+    f10++;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*shared\\\\(f11\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*firstprivate\\\\(f11\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*firstprivate\\\\(f11\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp simd\\[^\\n\\r]*firstprivate\\\\(f11\\\\)\" \"gimple\" } } */\n+  #pragma omp parallel master taskloop simd firstprivate (f11)\n+  for (int i = 0; i < 64; i++)\n+    f11++;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*firstprivate\\\\(f12\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp sections\\[^\\n\\r]*firstprivate\\\\(f12\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp section \\[^\\n\\r]*firstprivate\\\\(f12\\\\)\" \"gimple\" } } */\n+  #pragma omp parallel sections firstprivate (f12)\n+  {\n+    f12++;\n+    #pragma omp section\n+    f12++;\n+  }\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*firstprivate\\\\(f13\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*firstprivate\\\\(f13\\\\)\" \"gimple\" } } */\n+  #pragma omp target parallel firstprivate (f13)\n+  f13++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*firstprivate\\\\(f14\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*firstprivate\\\\(f14\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*firstprivate\\\\(f14\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  #pragma omp target parallel for firstprivate (f14)\n+  for (int i = 0; i < 64; i++)\n+    f14++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*firstprivate\\\\(f15\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*firstprivate\\\\(f15\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*firstprivate\\\\(f15\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump-not \"omp simd\\[^\\n\\r]*firstprivate\\\\(f15\\\\)\" \"gimple\" } } */\n+  #pragma omp target parallel for simd firstprivate (f15)\n+  for (int i = 0; i < 64; i++)\n+    f15++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*firstprivate\\\\(f16\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*firstprivate\\\\(f16\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*firstprivate\\\\(f16\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp simd\\[^\\n\\r]*firstprivate\\\\(f16\\\\)\" \"gimple\" } } */\n+  #pragma omp target parallel loop firstprivate (f16)\n+  for (int i = 0; i < 64; i++)\n+    f16++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*firstprivate\\\\(f17\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*firstprivate\\\\(f17\\\\)\" \"gimple\" } } */\n+  #pragma omp target teams firstprivate (f17)\n+  f17++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*firstprivate\\\\(f18\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*firstprivate\\\\(f18\\\\)\" \"gimple\" } } *//* FIXME: This should be on distribute instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*firstprivate\\\\(f18\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  #pragma omp target teams distribute firstprivate (f18)\n+  for (int i = 0; i < 64; i++)\n+    f18++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*firstprivate\\\\(f19\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*firstprivate\\\\(f19\\\\)\" \"gimple\" } } *//* FIXME: This should be on distribute instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*firstprivate\\\\(f19\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*firstprivate\\\\(f19\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*firstprivate\\\\(f19\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  #pragma omp target teams distribute parallel for firstprivate (f19)\n+  for (int i = 0; i < 64; i++)\n+    f19++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*firstprivate\\\\(f20\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*firstprivate\\\\(f20\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*firstprivate\\\\(f20\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*firstprivate\\\\(f20\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*firstprivate\\\\(f20\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump-not \"omp simd\\[^\\n\\r]*firstprivate\\\\(f20\\\\)\" \"gimple\" } } */\n+  #pragma omp target teams distribute parallel for simd firstprivate (f20)\n+  for (int i = 0; i < 64; i++)\n+    f20++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*firstprivate\\\\(f21\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*firstprivate\\\\(f21\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*firstprivate\\\\(f21\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump-not \"omp simd\\[^\\n\\r]*firstprivate\\\\(f21\\\\)\" \"gimple\" } } */\n+  #pragma omp target teams distribute simd firstprivate (f21)\n+  for (int i = 0; i < 64; i++)\n+    f21++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*firstprivate\\\\(f22\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*firstprivate\\\\(f22\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*firstprivate\\\\(f22\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*shared\\\\(f22\\\\)\" \"gimple\" } } *//* NOTE: This is an implementation detail.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*firstprivate\\\\(f22\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp simd\\[^\\n\\r]*firstprivate\\\\(f22\\\\)\" \"gimple\" } } */\n+  #pragma omp target teams loop firstprivate (f22)\n+  for (int i = 0; i < 64; i++)\n+    f22++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*firstprivate\\\\(f23\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp simd\\[^\\n\\r]*firstprivate\\\\(f23\\\\)\" \"gimple\" } } */\n+  #pragma omp target simd firstprivate (f23)\n+  for (int i = 0; i < 64; i++)\n+    f23++;\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*firstprivate\\\\(f24\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp simd\\[^\\n\\r]*firstprivate\\\\(f24\\\\)\" \"gimple\" } } */\n+  #pragma omp taskloop simd firstprivate (f24)\n+  for (int i = 0; i < 64; i++)\n+    f24++;\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*firstprivate\\\\(f25\\\\)\" \"gimple\" } } *//* FIXME: This should be on distribute instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*firstprivate\\\\(f25\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  #pragma omp teams distribute firstprivate (f25)\n+  for (int i = 0; i < 64; i++)\n+    f25++;\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*firstprivate\\\\(f26\\\\)\" \"gimple\" } } *//* FIXME: This should be on distribute instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*firstprivate\\\\(f26\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*firstprivate\\\\(f26\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*firstprivate\\\\(f26\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  #pragma omp teams distribute parallel for firstprivate (f26)\n+  for (int i = 0; i < 64; i++)\n+    f26++;\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*firstprivate\\\\(f27\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*firstprivate\\\\(f27\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*firstprivate\\\\(f27\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*firstprivate\\\\(f27\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump-not \"omp simd\\[^\\n\\r]*firstprivate\\\\(f27\\\\)\" \"gimple\" } } */\n+  #pragma omp teams distribute parallel for simd firstprivate (f27)\n+  for (int i = 0; i < 64; i++)\n+    f27++;\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*firstprivate\\\\(f28\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*firstprivate\\\\(f28\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump-not \"omp simd\\[^\\n\\r]*firstprivate\\\\(f28\\\\)\" \"gimple\" } } */\n+  #pragma omp teams distribute simd firstprivate (f28)\n+  for (int i = 0; i < 64; i++)\n+    f28++;\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*firstprivate\\\\(f29\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*firstprivate\\\\(f29\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*shared\\\\(f29\\\\)\" \"gimple\" } } *//* NOTE: This is an implementation detail.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*firstprivate\\\\(f29\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp simd\\[^\\n\\r]*firstprivate\\\\(f29\\\\)\" \"gimple\" } } */\n+  #pragma omp teams loop firstprivate (f29)\n+  for (int i = 0; i < 64; i++)\n+    f29++;\n+}"}, {"sha": "4acff453013b313c2409eaae0c07caf0603fc930", "filename": "gcc/testsuite/c-c++-common/gomp/pr99928-10.c", "status": "added", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d80aeff0bf2f455e9099def756f612bfbcd2cb0d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d80aeff0bf2f455e9099def756f612bfbcd2cb0d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-10.c?ref=d80aeff0bf2f455e9099def756f612bfbcd2cb0d", "patch": "@@ -0,0 +1,231 @@\n+/* PR middle-end/99928 */\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-gimple\" } */\n+\n+int *r00, *r01, *r02, *r03, *r04, *r05;\n+int *r13, *r14, *r15, *r16, *r17, *r18, *r19;\n+int *r20, *r21, *r22, *r23, *r24;\n+int *baz (void);\n+\n+void\n+foo (void)\n+{\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r00 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r00 \\\\+ 4\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r00 \\\\+ 4\" \"gimple\" } } *//* FIXME.  */\n+  #pragma omp distribute parallel for reduction(+:r00[1:2])\n+  for (int i = 0; i < 64; i++)\n+    r00[1]++;\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r01 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r01 \\\\+ 4\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r01 \\\\+ 4\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r01 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp distribute parallel for simd reduction(+:r01[1:3])\n+  for (int i = 0; i < 64; i++)\n+    r01[1]++;\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r02 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r02 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp distribute simd reduction(+:r02[1:4])\n+  for (int i = 0; i < 64; i++)\n+    r02[1]++;\n+}\n+\n+void\n+bar (void)\n+{\n+  int *r06 = baz (), *r07 = baz (), *r08 = baz (), *r09 = baz ();\n+  int *r10 = baz (), *r11 = baz (), *r12 = baz ();\n+  int *r25 = baz (), *r26 = baz (), *r27 = baz (), *r28 = baz (), *r29 = baz ();\n+  /* { dg-final { scan-tree-dump \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r03 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r03 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp for simd reduction(+:r03[1:5])\n+  for (int i = 0; i < 64; i++)\n+    r03[1]++;\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r04 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r04 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp master taskloop reduction(+:r04[1:6])\n+  for (int i = 0; i < 64; i++)\n+    r04[1]++;\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r05 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r05 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r05 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp master taskloop simd reduction(+:r05[1:7])\n+  for (int i = 0; i < 64; i++)\n+    r05[1]++;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r06 \\\\+ 4\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r06 \\\\+ 4\" \"gimple\" } } *//* FIXME.  */\n+  #pragma omp parallel for reduction(+:r06[1:8])\n+  for (int i = 0; i < 64; i++)\n+    r06[1]++;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r07 \\\\+ 4\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r07 \\\\+ 4\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r07 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp parallel for simd reduction(+:r07[1:9])\n+  for (int i = 0; i < 64; i++)\n+    r07[1]++;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*firstprivate\\\\(r08\\\\)\" \"gimple\" } } *//* FIXME: Should be shared, but firstprivate is an optimization.  */\n+  /* { dg-final { scan-tree-dump \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r08 \\\\+ 4\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r08 \\\\+ 4\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  #pragma omp parallel loop reduction(+:r08[1:10])\n+  for (int i = 0; i < 64; i++)\n+    r08[1]++;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r09 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r09 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp parallel master reduction(+:r09[1:11])\n+  r09[1]++;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*firstprivate\\\\(r10\\\\)\" \"gimple\" } } *//* FIXME: Should be shared, but firstprivate is an optimization.  */\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r10 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r10 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp parallel master taskloop reduction(+:r10[1:12])\n+  for (int i = 0; i < 64; i++)\n+    r10[1]++;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*firstprivate\\\\(r11\\\\)\" \"gimple\" } } *//* FIXME: Should be shared, but firstprivate is an optimization.  */\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r11 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r11 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r11 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp parallel master taskloop simd reduction(+:r11[1:13])\n+  for (int i = 0; i < 64; i++)\n+    r11[1]++;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r12 \\\\+ 4\" \"gimple\" } } *//* FIXME: This should be on sections instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp sections\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r12 \\\\+ 4\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump-not \"omp section \\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r12 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp parallel sections reduction(+:r12[1:14])\n+  {\n+    r12[1]++;\n+    #pragma omp section\n+    r12[1]++;\n+  }\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:\\\\\\*_\\[0-9]* \\\\\\[len: 60\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(firstprivate:r13 \\\\\\[pointer assign, bias: 4\\\\\\]\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r13\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r13 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp target parallel reduction(+:r13[1:15])\n+  r13[1]++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:\\\\\\*_\\[0-9]* \\\\\\[len: 64\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(firstprivate:r14 \\\\\\[pointer assign, bias: 4\\\\\\]\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r14\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r14 \\\\+ 4\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r14 \\\\+ 4\" \"gimple\" } } *//* FIXME.  */\n+  #pragma omp target parallel for reduction(+:r14[1:16])\n+  for (int i = 0; i < 64; i++)\n+    r14[1]++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:\\\\\\*_\\[0-9]* \\\\\\[len: 68\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(firstprivate:r15 \\\\\\[pointer assign, bias: 4\\\\\\]\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r15\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r15 \\\\+ 4\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r15 \\\\+ 4\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r15 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp target parallel for simd reduction(+:r15[1:17])\n+  for (int i = 0; i < 64; i++)\n+    r15[1]++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:\\\\\\*_\\[0-9]* \\\\\\[len: 72\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(firstprivate:r16 \\\\\\[pointer assign, bias: 4\\\\\\]\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r16\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*firstprivate\\\\(r16\\\\)\" \"gimple\" } } *//* FIXME: Should be shared, but firstprivate is an optimization.  */\n+  /* { dg-final { scan-tree-dump \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r16 \\\\+ 4\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r16 \\\\+ 4\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  #pragma omp target parallel loop reduction(+:r16[1:18])\n+  for (int i = 0; i < 64; i++)\n+    r16[1]++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:\\\\\\*_\\[0-9]* \\\\\\[len: 76\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(firstprivate:r17 \\\\\\[pointer assign, bias: 4\\\\\\]\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r17\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r17 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp target teams reduction(+:r17[1:19])\n+  r17[1]++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:\\\\\\*_\\[0-9]* \\\\\\[len: 80\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(firstprivate:r18 \\\\\\[pointer assign, bias: 4\\\\\\]\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r18\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r18 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r18 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp target teams distribute reduction(+:r18[1:20])\n+  for (int i = 0; i < 64; i++)\n+    r18[1]++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:\\\\\\*_\\[0-9]* \\\\\\[len: 84\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(firstprivate:r19 \\\\\\[pointer assign, bias: 4\\\\\\]\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r19\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r19 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r19 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r19 \\\\+ 4\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r19 \\\\+ 4\" \"gimple\" } } *//* FIXME.  */\n+  #pragma omp target teams distribute parallel for reduction(+:r19[1:21])\n+  for (int i = 0; i < 64; i++)\n+    r19[1]++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:\\\\\\*_\\[0-9]* \\\\\\[len: 88\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(firstprivate:r20 \\\\\\[pointer assign, bias: 4\\\\\\]\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r20\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r20 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r20 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r20 \\\\+ 4\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r20 \\\\+ 4\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r20 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp target teams distribute parallel for simd reduction(+:r20[1:22])\n+  for (int i = 0; i < 64; i++)\n+    r20[1]++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:\\\\\\*_\\[0-9]* \\\\\\[len: 92\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(firstprivate:r21 \\\\\\[pointer assign, bias: 4\\\\\\]\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r21\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r21 \\\\+ 4\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r21 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r21 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp target teams distribute simd reduction(+:r21[1:23])\n+  for (int i = 0; i < 64; i++)\n+    r21[1]++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:\\\\\\*_\\[0-9]* \\\\\\[len: 96\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(firstprivate:r22 \\\\\\[pointer assign, bias: 4\\\\\\]\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r22\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*firstprivate\\\\(r22\\\\)\" \"gimple\" } } *//* FIXME: Should be shared, but firstprivate is an optimization.  */\n+  /* { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r22 \\\\+ 4\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*firstprivate\\\\(r22\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r22 \\\\+ 4\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r22 \\\\+ 4\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  #pragma omp target teams loop reduction(+:r22[1:24])\n+  for (int i = 0; i < 64; i++)\n+    r22[1]++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:\\\\\\*_\\[0-9]* \\\\\\[len: 100\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(firstprivate:r23 \\\\\\[pointer assign, bias: 4\\\\\\]\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r23\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r23 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp target simd reduction(+:r23[1:25])\n+  for (int i = 0; i < 64; i++)\n+    r23[1]++;\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r24 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r24 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp taskloop simd reduction(+:r24[1:26])\n+  for (int i = 0; i < 64; i++)\n+    r24[1]++;\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r25 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r25 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp teams distribute reduction(+:r25[1:27])\n+  for (int i = 0; i < 64; i++)\n+    r25[1]++;\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r26 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r26 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r26 \\\\+ 4\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r26 \\\\+ 4\" \"gimple\" } } *//* FIXME.  */\n+  #pragma omp teams distribute parallel for reduction(+:r26[1:28])\n+  for (int i = 0; i < 64; i++)\n+    r26[1]++;\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r27 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r27 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r27 \\\\+ 4\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r27 \\\\+ 4\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r27 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp teams distribute parallel for simd reduction(+:r27[1:29])\n+  for (int i = 0; i < 64; i++)\n+    r27[1]++;\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r28 \\\\+ 4\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r28 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r28 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp teams distribute simd reduction(+:r28[1:30])\n+  for (int i = 0; i < 64; i++)\n+    r28[1]++;\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*firstprivate\\\\(r29\\\\)\" \"gimple\" } } *//* FIXME: Should be shared, but firstprivate is an optimization.  */\n+  /* { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r29 \\\\+ 4\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*firstprivate\\\\(r29\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r29 \\\\+ 4\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*\\\\)r29 \\\\+ 4\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  #pragma omp teams loop reduction(+:r29[1:31])\n+  for (int i = 0; i < 64; i++)\n+    r29[1]++;\n+}"}, {"sha": "66c2feb36d3e43bd7b09a993ca67a8ebb40de4ad", "filename": "gcc/testsuite/c-c++-common/gomp/pr99928-11.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d80aeff0bf2f455e9099def756f612bfbcd2cb0d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d80aeff0bf2f455e9099def756f612bfbcd2cb0d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-11.c?ref=d80aeff0bf2f455e9099def756f612bfbcd2cb0d", "patch": "@@ -0,0 +1,28 @@\n+/* PR middle-end/99928 */\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-gimple\" } */\n+\n+int r00, r01, r02;\n+\n+void\n+bar (void)\n+{\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*in_reduction\\\\(\\\\+:r00\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*in_reduction\\\\(\\\\+:r00\\\\)\" \"gimple\" } } */\n+  #pragma omp master taskloop in_reduction(+:r00)\n+  for (int i = 0; i < 64; i++)\n+    r00++;\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*in_reduction\\\\(\\\\+:r01\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*in_reduction\\\\(\\\\+:r01\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp simd\\[^\\n\\r]*in_reduction\\\\(\\\\+:r01\\\\)\" \"gimple\" } } */\n+  #pragma omp master taskloop simd in_reduction(+:r01)\n+  for (int i = 0; i < 64; i++)\n+    r01++;\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*in_reduction\\\\(\\\\+:r02\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp simd\\[^\\n\\r]*in_reduction\\\\(\\\\+:r02\\\\)\" \"gimple\" } } */\n+  #pragma omp taskloop simd in_reduction(+:r02)\n+  for (int i = 0; i < 64; i++)\n+    r02++;\n+  /* FIXME: We don't support in_reduction clause on target yet, once we do, should\n+     add testcase coverage for all combined/composite constructs with target as leaf construct.  */\n+}"}, {"sha": "313374cd2444362bab2f7fa995b84d7b045feb0b", "filename": "gcc/testsuite/c-c++-common/gomp/pr99928-2.c", "status": "added", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d80aeff0bf2f455e9099def756f612bfbcd2cb0d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d80aeff0bf2f455e9099def756f612bfbcd2cb0d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-2.c?ref=d80aeff0bf2f455e9099def756f612bfbcd2cb0d", "patch": "@@ -0,0 +1,208 @@\n+/* PR middle-end/99928 */\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-gimple\" } */\n+\n+int l00, l01, l02, l03, l04, l05, l06, l07;\n+int l10, l11, l12, l13, l14, l15, l16, l17, l18;\n+\n+void\n+foo (void)\n+{\n+  /* { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*lastprivate\\\\(l00\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*lastprivate\\\\(l00\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(l00\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  #pragma omp distribute parallel for lastprivate (l00)\n+  for (int i = 0; i < 64; i++)\n+    l00 = i;\n+  /* { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*lastprivate\\\\(l01\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*lastprivate\\\\(l01\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(l01\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*lastprivate\\\\(l01\\\\)\" \"gimple\" } } */\n+  #pragma omp distribute parallel for simd lastprivate (l01)\n+  for (int i = 0; i < 64; i++)\n+    l01 = i;\n+  /* { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*lastprivate\\\\(l02\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*lastprivate\\\\(l02\\\\)\" \"gimple\" } } */\n+  #pragma omp distribute simd lastprivate (l02)\n+  for (int i = 0; i < 64; i++)\n+    l02 = i;\n+}\n+\n+void\n+bar (void)\n+{\n+  int j00, j01, j02, j03;\n+  int l08 = 0, l09 = 0, l19 = 0, l20 = 0, l21 = 0, l22 = 0;\n+  /* { dg-final { scan-tree-dump \"omp for\\[^\\n\\r]*lastprivate\\\\(l03\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*lastprivate\\\\(l03\\\\)\" \"gimple\" } } */\n+  #pragma omp for simd lastprivate (l03)\n+  for (int i = 0; i < 64; i++)\n+    l03 = i;\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*lastprivate\\\\(l04\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*shared\\\\(l04\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*lastprivate\\\\(l04\\\\)\" \"gimple\" } } */\n+  #pragma omp master taskloop lastprivate (l04)\n+  for (int i = 0; i < 64; i++)\n+    l04 = i;\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*lastprivate\\\\(l05\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*shared\\\\(l05\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*lastprivate\\\\(l05\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*lastprivate\\\\(l05\\\\)\" \"gimple\" } } */\n+  #pragma omp master taskloop simd lastprivate (l05)\n+  for (int i = 0; i < 64; i++)\n+    l05 = i;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*lastprivate\\\\(l06\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(l06\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  #pragma omp parallel for lastprivate (l06)\n+  for (int i = 0; i < 64; i++)\n+    l06 = i;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*lastprivate\\\\(l07\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(l07\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*lastprivate\\\\(l07\\\\)\" \"gimple\" } } */\n+  #pragma omp parallel for simd lastprivate (l07)\n+  for (int i = 0; i < 64; i++)\n+    l07 = i;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*shared\\\\(j00\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp for\\[^\\n\\r]*lastprivate\\\\(j00\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*lastprivate\\\\(j00\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  #pragma omp parallel loop lastprivate (j00)\n+  for (j00 = 0; j00 < 64; j00++)\n+    ;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*shared\\\\(l08\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*lastprivate\\\\(l08\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*shared\\\\(l08\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*lastprivate\\\\(l08\\\\)\" \"gimple\" } } */\n+  #pragma omp parallel master taskloop lastprivate (l08)\n+  for (int i = 0; i < 64; i++)\n+    l08 = i;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*shared\\\\(l09\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*lastprivate\\\\(l09\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*shared\\\\(l09\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*lastprivate\\\\(l09\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*lastprivate\\\\(l09\\\\)\" \"gimple\" } } */\n+  #pragma omp parallel master taskloop simd lastprivate (l09)\n+  for (int i = 0; i < 64; i++)\n+    l09 = i;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*lastprivate\\\\(l10\\\\)\" \"gimple\" } } *//* FIXME: This should be on sections instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp sections\\[^\\n\\r]*lastprivate\\\\(l10\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump-not \"omp section \\[^\\n\\r]*lastprivate\\\\(l10\\\\)\" \"gimple\" } } */\n+  #pragma omp parallel sections lastprivate (l10)\n+  {\n+    l10 = 1;\n+    #pragma omp section\n+    l10 = 2;\n+  }\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:l11\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(l11\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*lastprivate\\\\(l11\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(l11\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  #pragma omp target parallel for lastprivate (l11)\n+  for (int i = 0; i < 64; i++)\n+    l11 = i;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:l12\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(l12\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*lastprivate\\\\(l12\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(l12\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*lastprivate\\\\(l12\\\\)\" \"gimple\" } } */\n+  #pragma omp target parallel for simd lastprivate (l12)\n+  for (int i = 0; i < 64; i++)\n+    l12 = i;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:j01\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(j01\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*shared\\\\(j01\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp for\\[^\\n\\r]*lastprivate\\\\(j01\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*lastprivate\\\\(j01\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  #pragma omp target parallel loop lastprivate (j01)\n+  for (j01 = 0; j01 < 64; j01++)\n+    ;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:l13\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(l13\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*shared\\\\(l13\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*lastprivate\\\\(l13\\\\)\" \"gimple\" } } */\n+  #pragma omp target teams distribute lastprivate (l13)\n+  for (int i = 0; i < 64; i++)\n+    l13 = i;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:l14\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(l14\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*shared\\\\(l14\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*lastprivate\\\\(l14\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*lastprivate\\\\(l14\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(l14\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  #pragma omp target teams distribute parallel for lastprivate (l14)\n+  for (int i = 0; i < 64; i++)\n+    l14 = i;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:l15\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(l15\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*shared\\\\(l15\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*lastprivate\\\\(l15\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*lastprivate\\\\(l15\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(l15\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*lastprivate\\\\(l15\\\\)\" \"gimple\" } } */\n+  #pragma omp target teams distribute parallel for simd lastprivate (l15)\n+  for (int i = 0; i < 64; i++)\n+    l15 = i;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:l16\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(l16\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*shared\\\\(l16\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*lastprivate\\\\(l16\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*lastprivate\\\\(l16\\\\)\" \"gimple\" } } */\n+  #pragma omp target teams distribute simd lastprivate (l16)\n+  for (int i = 0; i < 64; i++)\n+    l16 = i;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:j02\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(j02\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*shared\\\\(j02\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*lastprivate\\\\(j02\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*shared\\\\(j02\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp for\\[^\\n\\r]*lastprivate\\\\(j02\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*lastprivate\\\\(j02\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  #pragma omp target teams loop lastprivate (j02)\n+  for (j02 = 0; j02 < 64; j02++)\n+    ;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:l17\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(l17\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*lastprivate\\\\(l17\\\\)\" \"gimple\" } } */\n+  #pragma omp target simd lastprivate (l17)\n+  for (int i = 0; i < 64; i++)\n+    l17 = i;\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*shared\\\\(l18\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*lastprivate\\\\(l18\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*lastprivate\\\\(l18\\\\)\" \"gimple\" } } */\n+  #pragma omp taskloop simd lastprivate (l18)\n+  for (int i = 0; i < 64; i++)\n+    l18 = i;\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*shared\\\\(l19\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*lastprivate\\\\(l19\\\\)\" \"gimple\" } } */\n+  #pragma omp teams distribute lastprivate (l19)\n+  for (int i = 0; i < 64; i++)\n+    l19 = i;\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*shared\\\\(l20\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*lastprivate\\\\(l20\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*lastprivate\\\\(l20\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(l20\\\\)\" \"gimple\" } } *//* FIXME.  */\n+ #pragma omp teams distribute parallel for lastprivate (l20)\n+  for (int i = 0; i < 64; i++)\n+    l20 = i;\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*shared\\\\(l21\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*lastprivate\\\\(l21\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*lastprivate\\\\(l21\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(l21\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*lastprivate\\\\(l21\\\\)\" \"gimple\" } } */\n+ #pragma omp teams distribute parallel for simd lastprivate (l21)\n+  for (int i = 0; i < 64; i++)\n+    l21 = i;\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*shared\\\\(l22\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*lastprivate\\\\(l22\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*lastprivate\\\\(l22\\\\)\" \"gimple\" } } */\n+  #pragma omp teams distribute simd lastprivate (l22)\n+  for (int i = 0; i < 64; i++)\n+    l22 = i;\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*shared\\\\(j03\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*lastprivate\\\\(j03\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*shared\\\\(j03\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp for\\[^\\n\\r]*lastprivate\\\\(j03\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*lastprivate\\\\(j03\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  #pragma omp teams loop lastprivate (j03)\n+  for (j03 = 0; j03 < 64; j03++)\n+    ;\n+}"}, {"sha": "67f590bb7ef4a40679de965d57ff46876defbdf2", "filename": "gcc/testsuite/c-c++-common/gomp/pr99928-3.c", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d80aeff0bf2f455e9099def756f612bfbcd2cb0d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d80aeff0bf2f455e9099def756f612bfbcd2cb0d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-3.c?ref=d80aeff0bf2f455e9099def756f612bfbcd2cb0d", "patch": "@@ -0,0 +1,119 @@\n+/* PR middle-end/99928 */\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-gimple\" } */\n+\n+int l00, l01, l02, l03, l04, l07, l08, l09;\n+int l10, l11;\n+\n+void\n+bar (void)\n+{\n+  int l05 = 0, l06 = 0;\n+  /* { dg-final { scan-tree-dump \"omp for\\[^\\n\\r]*firstprivate\\\\(l00\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp for\\[^\\n\\r]*lastprivate\\\\(l00\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp simd\\[^\\n\\r]*firstprivate\\\\(l00\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*lastprivate\\\\(l00\\\\)\" \"gimple\" } } */\n+  #pragma omp for simd firstprivate (l00) lastprivate (l00)\n+  for (int i = 0; i < 64; i++)\n+    l00 = i;\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*firstprivate\\\\(l01\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*lastprivate\\\\(l01\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*firstprivate\\\\(l01\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*lastprivate\\\\(l01\\\\)\" \"gimple\" } } */\n+  #pragma omp master taskloop firstprivate (l01) lastprivate (l01)\n+  for (int i = 0; i < 64; i++)\n+    l01 = i;\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*firstprivate\\\\(l02\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*lastprivate\\\\(l02\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*firstprivate\\\\(l02\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*lastprivate\\\\(l02\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp simd\\[^\\n\\r]*firstprivate\\\\(l02\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*lastprivate\\\\(l02\\\\)\" \"gimple\" } } */\n+  #pragma omp master taskloop simd firstprivate (l02) lastprivate (l02)\n+  for (int i = 0; i < 64; i++)\n+    l02 = i;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*firstprivate\\\\(l03\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*lastprivate\\\\(l03\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*firstprivate\\\\(l03\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(l03\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  #pragma omp parallel for firstprivate (l03) lastprivate (l03)\n+  for (int i = 0; i < 64; i++)\n+    l03 = i;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*firstprivate\\\\(l04\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*lastprivate\\\\(l04\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*firstprivate\\\\(l04\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(l04\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump-not \"omp simd\\[^\\n\\r]*firstprivate\\\\(l04\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*lastprivate\\\\(l04\\\\)\" \"gimple\" } } */\n+  #pragma omp parallel for simd firstprivate (l04) lastprivate (l04)\n+  for (int i = 0; i < 64; i++)\n+    l04 = i;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*shared\\\\(l05\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*firstprivate\\\\(l05\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*lastprivate\\\\(l05\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*firstprivate\\\\(l05\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*lastprivate\\\\(l05\\\\)\" \"gimple\" } } */\n+  #pragma omp parallel master taskloop firstprivate (l05) lastprivate (l05)\n+  for (int i = 0; i < 64; i++)\n+    l05 = i;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*shared\\\\(l06\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*firstprivate\\\\(l06\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*lastprivate\\\\(l06\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*firstprivate\\\\(l06\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*lastprivate\\\\(l06\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp simd\\[^\\n\\r]*firstprivate\\\\(l06\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*lastprivate\\\\(l06\\\\)\" \"gimple\" } } */\n+  #pragma omp parallel master taskloop simd firstprivate (l06) lastprivate (l06)\n+  for (int i = 0; i < 64; i++)\n+    l06 = i;\n+  /* FIXME: OpenMP 5.0/5.1 broken here, conceptually it should be shared on parallel and\n+     firstprivate+lastprivate on sections, in GCC implementation we put firstprivate+lastprivate\n+     on parallel for historic reasons, but OpenMP 5.0/5.1 mistakenly say firstprivate\n+     should be on parallel and lastprivate on sections.  */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*firstprivate\\\\(l07\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*lastprivate\\\\(l07\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp sections\\[^\\n\\r]*firstprivate\\\\(l07\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp sections\\[^\\n\\r]*lastprivate\\\\(l07\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp section \\[^\\n\\r]*firstprivate\\\\(l07\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp section \\[^\\n\\r]*lastprivate\\\\(l07\\\\)\" \"gimple\" } } */\n+  #pragma omp parallel sections firstprivate (l07) lastprivate (l07)\n+  {\n+    l07 = 1;\n+    #pragma omp section\n+    l07 = 2;\n+  }\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:l08\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(l08\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*firstprivate\\\\(l08\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*lastprivate\\\\(l08\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*firstprivate\\\\(l08\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(l08\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  #pragma omp target parallel for firstprivate (l08) lastprivate (l08)\n+  for (int i = 0; i < 64; i++)\n+    l08 = i;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:l09\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(l09\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*firstprivate\\\\(l09\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*lastprivate\\\\(l09\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*firstprivate\\\\(l09\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(l09\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump-not \"omp simd\\[^\\n\\r]*firstprivate\\\\(l09\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*lastprivate\\\\(l09\\\\)\" \"gimple\" } } */\n+  #pragma omp target parallel for simd firstprivate (l09) lastprivate (l09)\n+  for (int i = 0; i < 64; i++)\n+    l09 = i;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:l10\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(l10\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp simd\\[^\\n\\r]*firstprivate\\\\(l10\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*lastprivate\\\\(l10\\\\)\" \"gimple\" } } */\n+  #pragma omp target simd firstprivate (l10) lastprivate (l10)\n+  for (int i = 0; i < 64; i++)\n+    l10 = i;\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*firstprivate\\\\(l11\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*lastprivate\\\\(l11\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp simd\\[^\\n\\r]*firstprivate\\\\(l11\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*lastprivate\\\\(l11\\\\)\" \"gimple\" } } */\n+ #pragma omp taskloop simd firstprivate (l11) lastprivate (l11)\n+  for (int i = 0; i < 64; i++)\n+    l11 = i;\n+}"}, {"sha": "c03afc4df89e5717cb82ab46e5356b0c3af90d06", "filename": "gcc/testsuite/c-c++-common/gomp/pr99928-4.c", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d80aeff0bf2f455e9099def756f612bfbcd2cb0d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d80aeff0bf2f455e9099def756f612bfbcd2cb0d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-4.c?ref=d80aeff0bf2f455e9099def756f612bfbcd2cb0d", "patch": "@@ -0,0 +1,76 @@\n+/* PR middle-end/99928 */\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-gimple\" } */\n+\n+int l00, l01, l05, l06, l07, l08;\n+\n+void\n+bar (void)\n+{\n+  int l02 = 0, l03 = 0, l04 = 0;\n+  /* { dg-final { scan-tree-dump \"omp for\\[^\\n\\r]*firstprivate\\\\(l00\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp for\\[^\\n\\r]*lastprivate\\\\(l00\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(l00:1\\\\)\" \"gimple\" } } */\n+  #pragma omp for simd linear (l00)\n+  for (int i = 0; i < 64; i++)\n+    l00++;\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*firstprivate\\\\(l01\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*lastprivate\\\\(l01\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*firstprivate\\\\(l01\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*lastprivate\\\\(l01\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(l01:1\\\\)\" \"gimple\" } } */\n+  #pragma omp master taskloop simd linear (l01)\n+  for (int i = 0; i < 64; i++)\n+    l01++;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*shared\\\\(l02\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp for\\[^\\n\\r]*linear\\\\(l02:1\\\\)\" \"gimple\" } } */\n+  #pragma omp parallel for linear (l02)\n+  for (int i = 0; i < 64; i++)\n+    l02++;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*firstprivate\\\\(l03\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*lastprivate\\\\(l03\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*firstprivate\\\\(l03\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(l03\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(l03:1\\\\)\" \"gimple\" } } */\n+  #pragma omp parallel for simd linear (l03)\n+  for (int i = 0; i < 64; i++)\n+    l03++;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*shared\\\\(l04\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*firstprivate\\\\(l04\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*lastprivate\\\\(l04\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*firstprivate\\\\(l04\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*lastprivate\\\\(l04\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(l04:1\\\\)\" \"gimple\" } } */\n+  #pragma omp parallel master taskloop simd linear (l04)\n+  for (int i = 0; i < 64; i++)\n+    l04++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:l05\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(l05\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*shared\\\\(l05\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp for\\[^\\n\\r]*linear\\\\(l05:1\\\\)\" \"gimple\" } } */\n+  #pragma omp target parallel for linear (l05)\n+  for (int i = 0; i < 64; i++)\n+    l05++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:l06\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(l06\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*firstprivate\\\\(l06\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*lastprivate\\\\(l06\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*firstprivate\\\\(l06\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(l06\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(l06:1\\\\)\" \"gimple\" } } */\n+  #pragma omp target parallel for simd linear (l06)\n+  for (int i = 0; i < 64; i++)\n+    l06++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:l07\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(l07\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(l07:1\\\\)\" \"gimple\" } } */\n+  #pragma omp target simd linear (l07)\n+  for (int i = 0; i < 64; i++)\n+    l07++;\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*firstprivate\\\\(l08\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*lastprivate\\\\(l08\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(l08:1\\\\)\" \"gimple\" } } */\n+  #pragma omp taskloop simd linear (l08)\n+  for (int i = 0; i < 64; i++)\n+    l08++;\n+}"}, {"sha": "6eca9c8d952c1a6fe4e18f7f427974c9073dd1d8", "filename": "gcc/testsuite/c-c++-common/gomp/pr99928-5.c", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d80aeff0bf2f455e9099def756f612bfbcd2cb0d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d80aeff0bf2f455e9099def756f612bfbcd2cb0d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-5.c?ref=d80aeff0bf2f455e9099def756f612bfbcd2cb0d", "patch": "@@ -0,0 +1,107 @@\n+/* PR middle-end/99928 */\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-gimple\" } */\n+\n+int j00, j01, j02, j03, j04, j06, j07, j08, j09;\n+int j10;\n+\n+void\n+foo (void)\n+{\n+  /* { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*lastprivate\\\\(j00\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*lastprivate\\\\(j00\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(j00\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j00:1\\\\)\" \"gimple\" } } */\n+  #pragma omp distribute parallel for simd linear (j00)\n+  for (j00 = 0; j00 < 64; j00++)\n+    ;\n+  /* { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*lastprivate\\\\(j01\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j01:1\\\\)\" \"gimple\" } } */\n+  #pragma omp distribute simd linear (j01)\n+  for (j01 = 0; j01 < 64; j01++)\n+    ;\n+}\n+\n+void\n+bar (void)\n+{\n+  int j05, j11, j12;\n+  /* { dg-final { scan-tree-dump \"omp for\\[^\\n\\r]*lastprivate\\\\(j02\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j02:1\\\\)\" \"gimple\" } } */\n+  #pragma omp for simd linear (j02)\n+  for (j02 = 0; j02 < 64; j02++)\n+    ;\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*lastprivate\\\\(j03\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*shared\\\\(j03\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*lastprivate\\\\(j03\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j03:1\\\\)\" \"gimple\" } } */\n+  #pragma omp master taskloop simd linear (j03)\n+  for (j03 = 0; j03 < 64; j03++)\n+    ;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*lastprivate\\\\(j04\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(j04\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j04:1\\\\)\" \"gimple\" } } */\n+  #pragma omp parallel for simd linear (j04)\n+  for (j04 = 0; j04 < 64; j04++)\n+    ;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*shared\\\\(j05\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*lastprivate\\\\(j05\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*shared\\\\(j05\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*lastprivate\\\\(j05\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j05:1\\\\)\" \"gimple\" } } */\n+  #pragma omp parallel master taskloop simd linear (j05)\n+  for (j05 = 0; j05 < 64; j05++)\n+    ;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:j06\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(j06\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*lastprivate\\\\(j06\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(j06\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j06:1\\\\)\" \"gimple\" } } */\n+  #pragma omp target parallel for simd linear (j06)\n+  for (j06 = 0; j06 < 64; j06++)\n+    ;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:j07\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(j07\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j07:1\\\\)\" \"gimple\" } } */\n+  #pragma omp target simd linear (j07)\n+  for (j07 = 0; j07 < 64; j07++)\n+    ;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:j08\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(j08\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*shared\\\\(j08\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*lastprivate\\\\(j08\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*lastprivate\\\\(j08\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(j08\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j08:1\\\\)\" \"gimple\" } } */\n+  #pragma omp target teams distribute parallel for simd linear (j08)\n+  for (j08 = 0; j08 < 64; j08++)\n+    ;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:j09\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(j09\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*shared\\\\(j09\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*lastprivate\\\\(j09\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j09:1\\\\)\" \"gimple\" } } */\n+  #pragma omp target teams distribute simd linear (j09)\n+  for (j09 = 0; j09 < 64; j09++)\n+    ;\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*shared\\\\(j10\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*lastprivate\\\\(j10\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j10:1\\\\)\" \"gimple\" } } */\n+  #pragma omp taskloop simd linear (j10)\n+  for (j10 = 0; j10 < 64; j10++)\n+    ;\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*shared\\\\(j11\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*lastprivate\\\\(j11\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*lastprivate\\\\(j11\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(j11\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j11:1\\\\)\" \"gimple\" } } */\n+  #pragma omp teams distribute parallel for simd linear (j11)\n+  for (j11 = 0; j11 < 64; j11++)\n+    ;\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*shared\\\\(j12\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*lastprivate\\\\(j12\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j12:1\\\\)\" \"gimple\" } } */\n+  #pragma omp teams distribute simd linear (j12)\n+  for (j12 = 0; j12 < 64; j12++)\n+    ;\n+}"}, {"sha": "9934047f8be8303fc8a2b2e0cb05d927728a2dc3", "filename": "gcc/testsuite/c-c++-common/gomp/pr99928-6.c", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d80aeff0bf2f455e9099def756f612bfbcd2cb0d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d80aeff0bf2f455e9099def756f612bfbcd2cb0d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-6.c?ref=d80aeff0bf2f455e9099def756f612bfbcd2cb0d", "patch": "@@ -0,0 +1,107 @@\n+/* PR middle-end/99928 */\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-gimple\" } */\n+\n+int j00, j01, j02, j03, j04, j06, j07, j08, j09;\n+int j10;\n+\n+void\n+foo (void)\n+{\n+  /* { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*lastprivate\\\\(j00\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*lastprivate\\\\(j00\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(j00\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j00:1\\\\)\" \"gimple\" } } */\n+  #pragma omp distribute parallel for simd\n+  for (j00 = 0; j00 < 64; j00++)\n+    ;\n+  /* { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*lastprivate\\\\(j01\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j01:1\\\\)\" \"gimple\" } } */\n+  #pragma omp distribute simd\n+  for (j01 = 0; j01 < 64; j01++)\n+    ;\n+}\n+\n+void\n+bar (void)\n+{\n+  int j05, j11, j12;\n+  /* { dg-final { scan-tree-dump \"omp for\\[^\\n\\r]*lastprivate\\\\(j02\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j02:1\\\\)\" \"gimple\" } } */\n+  #pragma omp for simd\n+  for (j02 = 0; j02 < 64; j02++)\n+    ;\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*lastprivate\\\\(j03\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*shared\\\\(j03\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*lastprivate\\\\(j03\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j03:1\\\\)\" \"gimple\" } } */\n+  #pragma omp master taskloop simd\n+  for (j03 = 0; j03 < 64; j03++)\n+    ;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*lastprivate\\\\(j04\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(j04\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j04:1\\\\)\" \"gimple\" } } */\n+  #pragma omp parallel for simd\n+  for (j04 = 0; j04 < 64; j04++)\n+    ;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*shared\\\\(j05\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*lastprivate\\\\(j05\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*shared\\\\(j05\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*lastprivate\\\\(j05\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j05:1\\\\)\" \"gimple\" } } */\n+  #pragma omp parallel master taskloop simd\n+  for (j05 = 0; j05 < 64; j05++)\n+    ;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:j06\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(j06\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*lastprivate\\\\(j06\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(j06\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j06:1\\\\)\" \"gimple\" } } */\n+  #pragma omp target parallel for simd\n+  for (j06 = 0; j06 < 64; j06++)\n+    ;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:j07\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(j07\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j07:1\\\\)\" \"gimple\" } } */\n+  #pragma omp target simd\n+  for (j07 = 0; j07 < 64; j07++)\n+    ;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:j08\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(j08\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*shared\\\\(j08\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*lastprivate\\\\(j08\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*lastprivate\\\\(j08\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(j08\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j08:1\\\\)\" \"gimple\" } } */\n+  #pragma omp target teams distribute parallel for simd\n+  for (j08 = 0; j08 < 64; j08++)\n+    ;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:j09\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(j09\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*shared\\\\(j09\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*lastprivate\\\\(j09\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j09:1\\\\)\" \"gimple\" } } */\n+  #pragma omp target teams distribute simd\n+  for (j09 = 0; j09 < 64; j09++)\n+    ;\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*shared\\\\(j10\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*lastprivate\\\\(j10\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j10:1\\\\)\" \"gimple\" } } */\n+  #pragma omp taskloop simd\n+  for (j10 = 0; j10 < 64; j10++)\n+    ;\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*shared\\\\(j11\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*lastprivate\\\\(j11\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*lastprivate\\\\(j11\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(j11\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j11:1\\\\)\" \"gimple\" } } */\n+  #pragma omp teams distribute parallel for simd\n+  for (j11 = 0; j11 < 64; j11++)\n+    ;\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*shared\\\\(j12\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*lastprivate\\\\(j12\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j12:1\\\\)\" \"gimple\" } } */\n+  #pragma omp teams distribute simd\n+  for (j12 = 0; j12 < 64; j12++)\n+    ;\n+}"}, {"sha": "5db1101e23bdf9e4e995a656aab1dab94defd8aa", "filename": "gcc/testsuite/c-c++-common/gomp/pr99928-7.c", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d80aeff0bf2f455e9099def756f612bfbcd2cb0d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d80aeff0bf2f455e9099def756f612bfbcd2cb0d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-7.c?ref=d80aeff0bf2f455e9099def756f612bfbcd2cb0d", "patch": "@@ -0,0 +1,103 @@\n+/* PR middle-end/99928 */\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-gimple\" } */\n+\n+void\n+foo (void)\n+{\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*lastprivate\\\\(j00\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp parallel\\[^\\n\\r]*lastprivate\\\\(j00\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(j00\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j00:1\\\\)\" \"gimple\" } } */\n+  #pragma omp distribute parallel for simd\n+  for (int j00 = 0; j00 < 64; j00++)\n+    ;\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*lastprivate\\\\(j01\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j01:1\\\\)\" \"gimple\" } } */\n+  #pragma omp distribute simd\n+  for (int j01 = 0; j01 < 64; j01++)\n+    ;\n+}\n+\n+void\n+bar (void)\n+{\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(j02\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j02:1\\\\)\" \"gimple\" } } */\n+  #pragma omp for simd\n+  for (int j02 = 0; j02 < 64; j02++)\n+    ;\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*lastprivate\\\\(j03\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp taskloop\\[^\\n\\r]*lastprivate\\\\(j03\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j03:1\\\\)\" \"gimple\" } } */\n+  #pragma omp master taskloop simd\n+  for (int j03 = 0; j03 < 64; j03++)\n+    ;\n+  /* { dg-final { scan-tree-dump-not \"omp parallel\\[^\\n\\r]*lastprivate\\\\(j04\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(j04\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j04:1\\\\)\" \"gimple\" } } */\n+  #pragma omp parallel for simd\n+  for (int j04 = 0; j04 < 64; j04++)\n+    ;\n+  /* { dg-final { scan-tree-dump-not \"omp parallel\\[^\\n\\r]*shared\\\\(j05\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*lastprivate\\\\(j05\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp taskloop\\[^\\n\\r]*lastprivate\\\\(j05\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j05:1\\\\)\" \"gimple\" } } */\n+  #pragma omp parallel master taskloop simd\n+  for (int j05 = 0; j05 < 64; j05++)\n+    ;\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*map\\\\(tofrom:j06\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(j06\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp parallel\\[^\\n\\r]*shared\\\\(j06\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp parallel\\[^\\n\\r]*lastprivate\\\\(j06\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(j06\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j06:1\\\\)\" \"gimple\" } } */\n+  #pragma omp target parallel for simd\n+  for (int j06 = 0; j06 < 64; j06++)\n+    ;\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*map\\\\(tofrom:j07\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(j07\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j07:1\\\\)\" \"gimple\" } } */\n+  #pragma omp target simd\n+  for (int j07 = 0; j07 < 64; j07++)\n+    ;\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*map\\\\(tofrom:j08\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(j08\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp teams\\[^\\n\\r]*shared\\\\(j08\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*lastprivate\\\\(j08\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp parallel\\[^\\n\\r]*shared\\\\(j08\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp parallel\\[^\\n\\r]*lastprivate\\\\(j08\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(j08\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j08:1\\\\)\" \"gimple\" } } */\n+  #pragma omp target teams distribute parallel for simd\n+  for (int j08 = 0; j08 < 64; j08++)\n+    ;\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*map\\\\(tofrom:j09\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(j09\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp teams\\[^\\n\\r]*shared\\\\(j09\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*lastprivate\\\\(j09\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j09:1\\\\)\" \"gimple\" } } */\n+  #pragma omp target teams distribute simd\n+  for (int j09 = 0; j09 < 64; j09++)\n+    ;\n+  /* { dg-final { scan-tree-dump-not \"omp taskloop\\[^\\n\\r]*lastprivate\\\\(j10\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j10:1\\\\)\" \"gimple\" } } */\n+  #pragma omp taskloop simd\n+  for (int j10 = 0; j10 < 64; j10++)\n+    ;\n+  /* { dg-final { scan-tree-dump-not \"omp teams\\[^\\n\\r]*shared\\\\(j11\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*lastprivate\\\\(j11\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp parallel\\[^\\n\\r]*shared\\\\(j11\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp parallel\\[^\\n\\r]*lastprivate\\\\(j11\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*lastprivate\\\\(j11\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j11:1\\\\)\" \"gimple\" } } */\n+  #pragma omp teams distribute parallel for simd\n+  for (int j11 = 0; j11 < 64; j11++)\n+    ;\n+  /* { dg-final { scan-tree-dump-not \"omp teams\\[^\\n\\r]*shared\\\\(j12\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*lastprivate\\\\(j12\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*linear\\\\(j12:1\\\\)\" \"gimple\" } } */\n+  #pragma omp teams distribute simd\n+  for (int j12 = 0; j12 < 64; j12++)\n+    ;\n+}"}, {"sha": "755da3b0d6563ad76b7f0948271b4c906a861d09", "filename": "gcc/testsuite/c-c++-common/gomp/pr99928-8.c", "status": "added", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d80aeff0bf2f455e9099def756f612bfbcd2cb0d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d80aeff0bf2f455e9099def756f612bfbcd2cb0d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-8.c?ref=d80aeff0bf2f455e9099def756f612bfbcd2cb0d", "patch": "@@ -0,0 +1,219 @@\n+/* PR middle-end/99928 */\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-gimple\" } */\n+\n+int r00, r01, r02, r03, r04, r05;\n+int r13, r14, r15, r16, r17, r18, r19;\n+int r20, r21, r22, r23, r24;\n+\n+void\n+foo (void)\n+{\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:r00\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:r00\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:r00\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  #pragma omp distribute parallel for reduction(+:r00)\n+  for (int i = 0; i < 64; i++)\n+    r00++;\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:r01\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:r01\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:r01\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:r01\\\\)\" \"gimple\" } } */\n+  #pragma omp distribute parallel for simd reduction(+:r01)\n+  for (int i = 0; i < 64; i++)\n+    r01++;\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:r02\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:r02\\\\)\" \"gimple\" } } */\n+  #pragma omp distribute simd reduction(+:r02)\n+  for (int i = 0; i < 64; i++)\n+    r02++;\n+}\n+\n+void\n+bar (void)\n+{\n+  int r06 = 0, r07 = 0, r08 = 0, r09 = 0;\n+  int r10 = 0, r11 = 0, r12 = 0;\n+  int r25 = 0, r26 = 0, r27 = 0, r28 = 0, r29 = 0;\n+  /* { dg-final { scan-tree-dump \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:r03\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:r03\\\\)\" \"gimple\" } } */\n+  #pragma omp for simd reduction(+:r03)\n+  for (int i = 0; i < 64; i++)\n+    r03++;\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*reduction\\\\(\\\\+:r04\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*reduction\\\\(\\\\+:r04\\\\)\" \"gimple\" } } */\n+  #pragma omp master taskloop reduction(+:r04)\n+  for (int i = 0; i < 64; i++)\n+    r04++;\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*reduction\\\\(\\\\+:r05\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*reduction\\\\(\\\\+:r05\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:r05\\\\)\" \"gimple\" } } */\n+  #pragma omp master taskloop simd reduction(+:r05)\n+  for (int i = 0; i < 64; i++)\n+    r05++;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:r06\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:r06\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  #pragma omp parallel for reduction(+:r06)\n+  for (int i = 0; i < 64; i++)\n+    r06++;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:r07\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:r07\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:r07\\\\)\" \"gimple\" } } */\n+  #pragma omp parallel for simd reduction(+:r07)\n+  for (int i = 0; i < 64; i++)\n+    r07++;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*shared\\\\(r08\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:r08\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:r08\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  #pragma omp parallel loop reduction(+:r08)\n+  for (int i = 0; i < 64; i++)\n+    r08++;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:r09\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*reduction\\\\(\\\\+:r09\\\\)\" \"gimple\" } } */\n+  #pragma omp parallel master reduction(+:r09)\n+  r09++;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*shared\\\\(r10\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*reduction\\\\(\\\\+:r10\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*reduction\\\\(\\\\+:r10\\\\)\" \"gimple\" } } */\n+  #pragma omp parallel master taskloop reduction(+:r10)\n+  for (int i = 0; i < 64; i++)\n+    r10++;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*shared\\\\(r11\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*reduction\\\\(\\\\+:r11\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*reduction\\\\(\\\\+:r11\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:r11\\\\)\" \"gimple\" } } */\n+  #pragma omp parallel master taskloop simd reduction(+:r11)\n+  for (int i = 0; i < 64; i++)\n+    r11++;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:r12\\\\)\" \"gimple\" } } *//* FIXME: This should be on sections instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp sections\\[^\\n\\r]*reduction\\\\(\\\\+:r12\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump-not \"omp section \\[^\\n\\r]*reduction\\\\(\\\\+:r12\\\\)\" \"gimple\" } } */\n+  #pragma omp parallel sections reduction(+:r12)\n+  {\n+    r12++;\n+    #pragma omp section\n+    r12++;\n+  }\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r13\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r13\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:r13\\\\)\" \"gimple\" } } */\n+  #pragma omp target parallel reduction(+:r13)\n+  r13++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r14\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r14\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:r14\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:r14\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  #pragma omp target parallel for reduction(+:r14)\n+  for (int i = 0; i < 64; i++)\n+    r14++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r15\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r15\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:r15\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:r15\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:r15\\\\)\" \"gimple\" } } */\n+  #pragma omp target parallel for simd reduction(+:r15)\n+  for (int i = 0; i < 64; i++)\n+    r15++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r16\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r16\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*shared\\\\(r16\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:r16\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:r16\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  #pragma omp target parallel loop reduction(+:r16)\n+  for (int i = 0; i < 64; i++)\n+    r16++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r17\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r17\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:r17\\\\)\" \"gimple\" } } */\n+  #pragma omp target teams reduction(+:r17)\n+  r17++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r18\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r18\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:r18\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:r18\\\\)\" \"gimple\" } } */\n+  #pragma omp target teams distribute reduction(+:r18)\n+  for (int i = 0; i < 64; i++)\n+    r18++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r19\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r19\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:r19\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:r19\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:r19\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:r19\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  #pragma omp target teams distribute parallel for reduction(+:r19)\n+  for (int i = 0; i < 64; i++)\n+    r19++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r20\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r20\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:r20\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:r20\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:r20\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:r20\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:r20\\\\)\" \"gimple\" } } */\n+  #pragma omp target teams distribute parallel for simd reduction(+:r20)\n+  for (int i = 0; i < 64; i++)\n+    r20++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r21\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r21\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:r21\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:r21\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:r21\\\\)\" \"gimple\" } } */\n+  #pragma omp target teams distribute simd reduction(+:r21)\n+  for (int i = 0; i < 64; i++)\n+    r21++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r22\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r22\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*shared\\\\(r22\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:r22\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*shared\\\\(r22\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:r22\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:r22\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  #pragma omp target teams loop reduction(+:r22)\n+  for (int i = 0; i < 64; i++)\n+    r22++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r23\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r23\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:r23\\\\)\" \"gimple\" } } */\n+  #pragma omp target simd reduction(+:r23)\n+  for (int i = 0; i < 64; i++)\n+    r23++;\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*reduction\\\\(\\\\+:r24\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:r24\\\\)\" \"gimple\" } } */\n+  #pragma omp taskloop simd reduction(+:r24)\n+  for (int i = 0; i < 64; i++)\n+    r24++;\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:r25\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:r25\\\\)\" \"gimple\" } } */\n+  #pragma omp teams distribute reduction(+:r25)\n+  for (int i = 0; i < 64; i++)\n+    r25++;\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:r26\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:r26\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:r26\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:r26\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  #pragma omp teams distribute parallel for reduction(+:r26)\n+  for (int i = 0; i < 64; i++)\n+    r26++;\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:r27\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:r27\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:r27\\\\)\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:r27\\\\)\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:r27\\\\)\" \"gimple\" } } */\n+  #pragma omp teams distribute parallel for simd reduction(+:r27)\n+  for (int i = 0; i < 64; i++)\n+    r27++;\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:r28\\\\)\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:r28\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:r28\\\\)\" \"gimple\" } } */\n+  #pragma omp teams distribute simd reduction(+:r28)\n+  for (int i = 0; i < 64; i++)\n+    r28++;\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*shared\\\\(r29\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:r29\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*shared\\\\(r29\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:r29\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:r29\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  #pragma omp teams loop reduction(+:r29)\n+  for (int i = 0; i < 64; i++)\n+    r29++;\n+}"}, {"sha": "a766b72958bc96858f072ac8d0eb161e761c69fa", "filename": "gcc/testsuite/c-c++-common/gomp/pr99928-9.c", "status": "added", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d80aeff0bf2f455e9099def756f612bfbcd2cb0d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d80aeff0bf2f455e9099def756f612bfbcd2cb0d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99928-9.c?ref=d80aeff0bf2f455e9099def756f612bfbcd2cb0d", "patch": "@@ -0,0 +1,219 @@\n+/* PR middle-end/99928 */\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-gimple\" } */\n+\n+int r00[4], r01[4], r02[4], r03[4], r04[4], r05[4];\n+int r13[4], r14[4], r15[4], r16[4], r17[4], r18[4], r19[4];\n+int r20[4], r21[4], r22[4], r23[4], r24[4];\n+\n+void\n+foo (void)\n+{\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r00 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r00 \\\\+ 4\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r00 \\\\+ 4\" \"gimple\" } } *//* FIXME.  */\n+  #pragma omp distribute parallel for reduction(+:r00[1:2])\n+  for (int i = 0; i < 64; i++)\n+    r00[1]++;\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r01 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r01 \\\\+ 4\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r01 \\\\+ 4\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r01 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp distribute parallel for simd reduction(+:r01[1:2])\n+  for (int i = 0; i < 64; i++)\n+    r01[1]++;\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r02 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r02 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp distribute simd reduction(+:r02[1:2])\n+  for (int i = 0; i < 64; i++)\n+    r02[1]++;\n+}\n+\n+void\n+bar (void)\n+{\n+  int r06[4] = {}, r07[4] = {}, r08[4] = {}, r09[4] = {};\n+  int r10[4] = {}, r11[4] = {}, r12[4] = {};\n+  int r25[4] = {}, r26[4] = {}, r27[4] = {}, r28[4] = {}, r29[4] = {};\n+  /* { dg-final { scan-tree-dump \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r03 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r03 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp for simd reduction(+:r03[1:2])\n+  for (int i = 0; i < 64; i++)\n+    r03[1]++;\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r04 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r04 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp master taskloop reduction(+:r04[1:2])\n+  for (int i = 0; i < 64; i++)\n+    r04[1]++;\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r05 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r05 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r05 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp master taskloop simd reduction(+:r05[1:2])\n+  for (int i = 0; i < 64; i++)\n+    r05[1]++;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r06 \\\\+ 4\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r06 \\\\+ 4\" \"gimple\" } } *//* FIXME.  */\n+  #pragma omp parallel for reduction(+:r06[1:2])\n+  for (int i = 0; i < 64; i++)\n+    r06[1]++;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r07 \\\\+ 4\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r07 \\\\+ 4\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r07 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp parallel for simd reduction(+:r07[1:2])\n+  for (int i = 0; i < 64; i++)\n+    r07[1]++;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*shared\\\\(r08\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r08 \\\\+ 4\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r08 \\\\+ 4\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  #pragma omp parallel loop reduction(+:r08[1:2])\n+  for (int i = 0; i < 64; i++)\n+    r08[1]++;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r09 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r09 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp parallel master reduction(+:r09[1:2])\n+  r09[1]++;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*shared\\\\(r10\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r10 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r10 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp parallel master taskloop reduction(+:r10[1:2])\n+  for (int i = 0; i < 64; i++)\n+    r10[1]++;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*shared\\\\(r11\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp master\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r11 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r11 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r11 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp parallel master taskloop simd reduction(+:r11[1:2])\n+  for (int i = 0; i < 64; i++)\n+    r11[1]++;\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r12 \\\\+ 4\" \"gimple\" } } *//* FIXME: This should be on sections instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp sections\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r12 \\\\+ 4\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump-not \"omp section \\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r12 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp parallel sections reduction(+:r12[1:2])\n+  {\n+    r12[1]++;\n+    #pragma omp section\n+    r12[1]++;\n+  }\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r13\\\\\\[1\\\\\\] \\\\\\[len: 8\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r13\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r13 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp target parallel reduction(+:r13[1:2])\n+  r13[1]++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r14\\\\\\[1\\\\\\] \\\\\\[len: 8\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r14\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r14 \\\\+ 4\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r14 \\\\+ 4\" \"gimple\" } } *//* FIXME.  */\n+  #pragma omp target parallel for reduction(+:r14[1:2])\n+  for (int i = 0; i < 64; i++)\n+    r14[1]++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r15\\\\\\[1\\\\\\] \\\\\\[len: 8\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r15\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r15 \\\\+ 4\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r15 \\\\+ 4\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r15 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp target parallel for simd reduction(+:r15[1:2])\n+  for (int i = 0; i < 64; i++)\n+    r15[1]++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r16\\\\\\[1\\\\\\] \\\\\\[len: 8\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r16\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*shared\\\\(r16\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r16 \\\\+ 4\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r16 \\\\+ 4\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  #pragma omp target parallel loop reduction(+:r16[1:2])\n+  for (int i = 0; i < 64; i++)\n+    r16[1]++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r17\\\\\\[1\\\\\\] \\\\\\[len: 8\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r17\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r17 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp target teams reduction(+:r17[1:2])\n+  r17[1]++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r18\\\\\\[1\\\\\\] \\\\\\[len: 8\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r18\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r18 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r18 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp target teams distribute reduction(+:r18[1:2])\n+  for (int i = 0; i < 64; i++)\n+    r18[1]++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r19\\\\\\[1\\\\\\] \\\\\\[len: 8\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r19\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r19 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r19 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r19 \\\\+ 4\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r19 \\\\+ 4\" \"gimple\" } } *//* FIXME.  */\n+  #pragma omp target teams distribute parallel for reduction(+:r19[1:2])\n+  for (int i = 0; i < 64; i++)\n+    r19[1]++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r20\\\\\\[1\\\\\\] \\\\\\[len: 8\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r20\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r20 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r20 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r20 \\\\+ 4\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r20 \\\\+ 4\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r20 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp target teams distribute parallel for simd reduction(+:r20[1:2])\n+  for (int i = 0; i < 64; i++)\n+    r20[1]++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r21\\\\\\[1\\\\\\] \\\\\\[len: 8\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r21\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r21 \\\\+ 4\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r21 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r21 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp target teams distribute simd reduction(+:r21[1:2])\n+  for (int i = 0; i < 64; i++)\n+    r21[1]++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r22\\\\\\[1\\\\\\] \\\\\\[len: 8\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r22\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*shared\\\\(r22\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r22 \\\\+ 4\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*shared\\\\(r22\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r22 \\\\+ 4\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r22 \\\\+ 4\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  #pragma omp target teams loop reduction(+:r22[1:2])\n+  for (int i = 0; i < 64; i++)\n+    r22[1]++;\n+  /* { dg-final { scan-tree-dump \"omp target\\[^\\n\\r]*map\\\\(tofrom:r23\\\\\\[1\\\\\\] \\\\\\[len: 8\\\\\\]\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp target\\[^\\n\\r]*firstprivate\\\\(r23\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r23 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp target simd reduction(+:r23[1:2])\n+  for (int i = 0; i < 64; i++)\n+    r23[1]++;\n+  /* { dg-final { scan-tree-dump \"omp taskloop\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r24 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r24 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp taskloop simd reduction(+:r24[1:2])\n+  for (int i = 0; i < 64; i++)\n+    r24[1]++;\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r25 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r25 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp teams distribute reduction(+:r25[1:2])\n+  for (int i = 0; i < 64; i++)\n+    r25[1]++;\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r26 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r26 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r26 \\\\+ 4\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r26 \\\\+ 4\" \"gimple\" } } *//* FIXME.  */\n+  #pragma omp teams distribute parallel for reduction(+:r26[1:2])\n+  for (int i = 0; i < 64; i++)\n+    r26[1]++;\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r27 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r27 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r27 \\\\+ 4\" \"gimple\" } } *//* FIXME: This should be on for instead.  */\n+  /* { dg-final { scan-tree-dump-not \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r27 \\\\+ 4\" \"gimple\" } } *//* FIXME.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r27 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp teams distribute parallel for simd reduction(+:r27[1:2])\n+  for (int i = 0; i < 64; i++)\n+    r27[1]++;\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r28 \\\\+ 4\" \"gimple\" { xfail *-*-* } } } */\n+  /* { dg-final { scan-tree-dump-not \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r28 \\\\+ 4\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r28 \\\\+ 4\" \"gimple\" } } */\n+  #pragma omp teams distribute simd reduction(+:r28[1:2])\n+  for (int i = 0; i < 64; i++)\n+    r28[1]++;\n+  /* { dg-final { scan-tree-dump \"omp teams\\[^\\n\\r]*shared\\\\(r29\\\\)\" \"gimple\" } } */\n+  /* { dg-final { scan-tree-dump \"omp distribute\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r29 \\\\+ 4\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp parallel\\[^\\n\\r]*shared\\\\(r29\\\\)\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp for\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r29 \\\\+ 4\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  /* { dg-final { scan-tree-dump \"omp simd\\[^\\n\\r]*reduction\\\\(\\\\+:MEM\\[^\\n\\r]*&r29 \\\\+ 4\" \"gimple\" } } *//* NOTE: This is implementation detail.  */\n+  #pragma omp teams loop reduction(+:r29[1:2])\n+  for (int i = 0; i < 64; i++)\n+    r29[1]++;\n+}"}]}