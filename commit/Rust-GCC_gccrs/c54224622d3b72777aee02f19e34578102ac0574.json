{"sha": "c54224622d3b72777aee02f19e34578102ac0574", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzU0MjI0NjIyZDNiNzI3NzdhZWUwMmYxOWUzNDU3ODEwMmFjMDU3NA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-10-21T18:10:00Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-10-21T18:10:00Z"}, "message": "re PR fortran/33749 (Wrong evaluation of expressions in lhs of assignment statements)\n\n2007-10-21  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/33749\n\t* resolve.c (resolve_ordinary_assign): New function that takes\n\tthe code to resolve an assignment from resolve_code. In\n\taddition, it makes a temporary of any vector index, on the\n\tlhs, using gfc_get_parentheses.\n\t(resolve_code): On EXEC_ASSIGN call the new function.\n\n2007-10-21  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/33749\n\t* gfortran.dg/assign_9.f90: New test.\n\nFrom-SVN: r129539", "tree": {"sha": "8163e6bfc15353c46b6961d460e5ee335728259e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8163e6bfc15353c46b6961d460e5ee335728259e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c54224622d3b72777aee02f19e34578102ac0574", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c54224622d3b72777aee02f19e34578102ac0574", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c54224622d3b72777aee02f19e34578102ac0574", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c54224622d3b72777aee02f19e34578102ac0574/comments", "author": null, "committer": null, "parents": [{"sha": "68d9cb44aec1cc792c19cbb9f879309f5e2eeb33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68d9cb44aec1cc792c19cbb9f879309f5e2eeb33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68d9cb44aec1cc792c19cbb9f879309f5e2eeb33"}], "stats": {"total": 207, "additions": 134, "deletions": 73}, "files": [{"sha": "8d7abb2a0b4d17e82637f83b39bcac1a6f9a6f40", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c54224622d3b72777aee02f19e34578102ac0574/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c54224622d3b72777aee02f19e34578102ac0574/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=c54224622d3b72777aee02f19e34578102ac0574", "patch": "@@ -1,3 +1,12 @@\n+2007-10-21  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/33749\n+\t* resolve.c (resolve_ordinary_assign): New function that takes\n+\tthe code to resolve an assignment from resolve_code. In\n+\taddition, it makes a temporary of any vector index, on the\n+\tlhs, using gfc_get_parentheses.\n+\t(resolve_code): On EXEC_ASSIGN call the new function.\n+\n 2007-10-20  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/33818"}, {"sha": "9c4aa8a7347a1b619a30283bf02f2d84094a7343", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 106, "deletions": 73, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c54224622d3b72777aee02f19e34578102ac0574/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c54224622d3b72777aee02f19e34578102ac0574/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=c54224622d3b72777aee02f19e34578102ac0574", "patch": "@@ -5958,6 +5958,110 @@ gfc_resolve_blocks (gfc_code *b, gfc_namespace *ns)\n }\n \n \n+/* Does everything to resolve an ordinary assignment.  Returns true\n+   if this is an interface asignment.  */\n+static bool\n+resolve_ordinary_assign (gfc_code *code, gfc_namespace *ns)\n+{\n+  bool rval = false;\n+  gfc_expr *lhs;\n+  gfc_expr *rhs;\n+  int llen = 0;\n+  int rlen = 0;\n+  int n;\n+  gfc_ref *ref;\n+\n+\n+  if (gfc_extend_assign (code, ns) == SUCCESS)\n+    {\n+      lhs = code->ext.actual->expr;\n+      rhs = code->ext.actual->next->expr;\n+      if (gfc_pure (NULL) && !gfc_pure (code->symtree->n.sym))\n+\t{\n+\t  gfc_error (\"Subroutine '%s' called instead of assignment at \"\n+\t\t     \"%L must be PURE\", code->symtree->n.sym->name,\n+\t\t     &code->loc);\n+\t  return rval;\n+\t}\n+\n+      /* Make a temporary rhs when there is a default initializer\n+\t and rhs is the same symbol as the lhs.  */\n+      if (rhs->expr_type == EXPR_VARIABLE\n+\t    && rhs->symtree->n.sym->ts.type == BT_DERIVED\n+\t    && has_default_initializer (rhs->symtree->n.sym->ts.derived)\n+\t    && (lhs->symtree->n.sym == rhs->symtree->n.sym))\n+        code->ext.actual->next->expr = gfc_get_parentheses (rhs);\n+\n+      return true;\n+    }\n+\n+  lhs = code->expr;\n+  rhs = code->expr2;\n+\n+  if (lhs->ts.type == BT_CHARACTER\n+\t&& gfc_option.warn_character_truncation)\n+    {\n+      if (lhs->ts.cl != NULL\n+\t    && lhs->ts.cl->length != NULL\n+\t    && lhs->ts.cl->length->expr_type == EXPR_CONSTANT)\n+\tllen = mpz_get_si (lhs->ts.cl->length->value.integer);\n+\n+      if (rhs->expr_type == EXPR_CONSTANT)\n+ \trlen = rhs->value.character.length;\n+\n+      else if (rhs->ts.cl != NULL\n+\t         && rhs->ts.cl->length != NULL\n+\t\t && rhs->ts.cl->length->expr_type == EXPR_CONSTANT)\n+\trlen = mpz_get_si (rhs->ts.cl->length->value.integer);\n+\n+      if (rlen && llen && rlen > llen)\n+\tgfc_warning_now (\"CHARACTER expression will be truncated \"\n+\t\t\t \"in assignment (%d/%d) at %L\",\n+\t\t\t llen, rlen, &code->loc);\n+    }\n+\n+  /* Ensure that a vector index expression for the lvalue is evaluated\n+     to a temporary.  */\n+  if (lhs->rank)\n+    {\n+      for (ref = lhs->ref; ref; ref= ref->next)\n+\tif (ref->type == REF_ARRAY)\n+\t  {\n+\t    for (n = 0; n < ref->u.ar.dimen; n++)\n+\t      if (ref->u.ar.dimen_type[n] == DIMEN_VECTOR)\n+\t\tref->u.ar.start[n]\n+\t\t\t= gfc_get_parentheses (ref->u.ar.start[n]);\n+\t  }\n+    }\n+\n+  if (gfc_pure (NULL))\n+    {\n+      if (gfc_impure_variable (lhs->symtree->n.sym))\n+\t{\n+\t  gfc_error (\"Cannot assign to variable '%s' in PURE \"\n+\t\t     \"procedure at %L\",\n+\t\t      lhs->symtree->n.sym->name,\n+\t\t      &lhs->where);\n+\t  return rval;\n+\t}\n+\n+      if (lhs->ts.type == BT_DERIVED\n+\t    && lhs->expr_type == EXPR_VARIABLE\n+\t    && lhs->ts.derived->attr.pointer_comp\n+\t    && gfc_impure_variable (rhs->symtree->n.sym))\n+\t{\n+\t  gfc_error (\"The impure variable at %L is assigned to \"\n+\t\t     \"a derived type variable with a POINTER \"\n+\t\t     \"component in a PURE procedure (12.6)\",\n+\t\t     &rhs->where);\n+\t  return rval;\n+\t}\n+    }\n+\n+  gfc_check_assign (lhs, rhs, 1);\n+  return false;\n+}\n+\n /* Given a block of code, recursively resolve everything pointed to by this\n    code block.  */\n \n@@ -6075,80 +6179,9 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \t  if (t == FAILURE)\n \t    break;\n \n-\t  if (gfc_extend_assign (code, ns) == SUCCESS)\n-\t    {\n-\t      gfc_expr *lhs = code->ext.actual->expr;\n-\t      gfc_expr *rhs = code->ext.actual->next->expr;\n-\n-\t      if (gfc_pure (NULL) && !gfc_pure (code->symtree->n.sym))\n-\t\t{\n-\t\t  gfc_error (\"Subroutine '%s' called instead of assignment at \"\n-\t\t\t     \"%L must be PURE\", code->symtree->n.sym->name,\n-\t\t\t     &code->loc);\n-\t\t  break;\n-\t\t}\n-\n-\t      /* Make a temporary rhs when there is a default initializer\n-\t\t and rhs is the same symbol as the lhs.  */\n-\t      if (rhs->expr_type == EXPR_VARIABLE\n-\t\t    && rhs->symtree->n.sym->ts.type == BT_DERIVED\n-\t\t    && has_default_initializer (rhs->symtree->n.sym->ts.derived)\n-\t\t    && (lhs->symtree->n.sym == rhs->symtree->n.sym))\n-\t        code->ext.actual->next->expr = gfc_get_parentheses (rhs);\n-\n-\t      goto call;\n-\t    }\n-\n-\t  if (code->expr->ts.type == BT_CHARACTER\n-\t      && gfc_option.warn_character_truncation)\n-\t    {\n-\t      int llen = 0, rlen = 0;\n-\n-\t      if (code->expr->ts.cl != NULL\n-\t\t  && code->expr->ts.cl->length != NULL\n-\t\t  && code->expr->ts.cl->length->expr_type == EXPR_CONSTANT)\n-\t\tllen = mpz_get_si (code->expr->ts.cl->length->value.integer);\n-\n-\t      if (code->expr2->expr_type == EXPR_CONSTANT)\n-\t\trlen = code->expr2->value.character.length;\n-\n-\t      else if (code->expr2->ts.cl != NULL\n-\t\t       && code->expr2->ts.cl->length != NULL\n-\t\t       && code->expr2->ts.cl->length->expr_type\n-\t\t\t  == EXPR_CONSTANT)\n-\t\trlen = mpz_get_si (code->expr2->ts.cl->length->value.integer);\n-\n-\t      if (rlen && llen && rlen > llen)\n-\t\tgfc_warning_now (\"CHARACTER expression will be truncated \"\n-\t\t\t\t \"in assignment (%d/%d) at %L\",\n-\t\t\t\t llen, rlen, &code->loc);\n-\t    }\n-\n-\t  if (gfc_pure (NULL))\n-\t    {\n-\t      if (gfc_impure_variable (code->expr->symtree->n.sym))\n-\t\t{\n-\t\t  gfc_error (\"Cannot assign to variable '%s' in PURE \"\n-\t\t\t     \"procedure at %L\",\n-\t\t\t     code->expr->symtree->n.sym->name,\n-\t\t\t     &code->expr->where);\n-\t\t  break;\n-\t\t}\n-\n-\t      if (code->expr->ts.type == BT_DERIVED\n-\t\t    && code->expr->expr_type == EXPR_VARIABLE\n-\t\t    && code->expr->ts.derived->attr.pointer_comp\n-\t\t    && gfc_impure_variable (code->expr2->symtree->n.sym))\n-\t\t{\n-\t\t  gfc_error (\"The impure variable at %L is assigned to \"\n-\t\t\t     \"a derived type variable with a POINTER \"\n-\t\t\t     \"component in a PURE procedure (12.6)\",\n-\t\t\t     &code->expr2->where);\n-\t\t  break;\n-\t\t}\n-\t    }\n+\t  if (resolve_ordinary_assign (code, ns))\n+\t    goto call;\n \n-\t    gfc_check_assign (code->expr, code->expr2, 1);\n \t  break;\n \n \tcase EXEC_LABEL_ASSIGN:"}, {"sha": "3207a0b71d85ba8c726c04c9aee3e90d6b7be2c5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c54224622d3b72777aee02f19e34578102ac0574/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c54224622d3b72777aee02f19e34578102ac0574/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c54224622d3b72777aee02f19e34578102ac0574", "patch": "@@ -1,3 +1,8 @@\n+2007-10-21  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/33749\n+\t* gfortran.dg/assign_9.f90: New test.\n+\n 2007-10-21  Richard Sandiford  <rsandifo@nildram.co.uk>\n \n \t* gcc.target/mips/mips.exp (setup_mips_tests): Set mips_mips16."}, {"sha": "2c2337ec0f47c24c493c9bb3322eb705e9f65afa", "filename": "gcc/testsuite/gfortran.dg/assign_9.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c54224622d3b72777aee02f19e34578102ac0574/gcc%2Ftestsuite%2Fgfortran.dg%2Fassign_9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c54224622d3b72777aee02f19e34578102ac0574/gcc%2Ftestsuite%2Fgfortran.dg%2Fassign_9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassign_9.f90?ref=c54224622d3b72777aee02f19e34578102ac0574", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do run }\n+! Tests the fix for PR33749, in which one of the two assignments\n+! below would not produce a temporary for the index expression.\n+!\n+! Contributed by Dick Hendrickson on comp.lang.fortran,\n+! \" Most elegant syntax for inverting a permutation?\" 20071006\n+!\n+  integer(4) :: p(4) = (/2,4,1,3/)\n+  integer(8) :: q(4) = (/2,4,1,3/)\n+  p(p) = (/(i, i = 1, 4)/)\n+  q(q) = (/(i, i = 1, 4)/)\n+  if (any(p .ne. q)) call abort ()\n+end\n+"}]}