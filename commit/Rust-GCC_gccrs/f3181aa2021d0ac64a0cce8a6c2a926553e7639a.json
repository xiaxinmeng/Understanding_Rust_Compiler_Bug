{"sha": "f3181aa2021d0ac64a0cce8a6c2a926553e7639a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjMxODFhYTIwMjFkMGFjNjRhMGNjZThhNmMyYTkyNjU1M2U3NjM5YQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2011-04-24T10:43:00Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-04-24T10:43:00Z"}, "message": "ipa-prop.c (ipa_propagate_indirect_call_infos): Remove obsolette WPA hack.\n\n\t* ipa-prop.c (ipa_propagate_indirect_call_infos): Remove obsolette\n\tWPA hack.\n\t* ipa-prop.h (ipa_get_param, ipa_is_param_used, ipa_param_cannot_devirtualize_p,\n\tipa_param_types_vec_empty, ipa_get_ith_jump_func, ipa_get_lattice):\n\tFortify array bounds.\n\t* ipa-inline-analysis.c (add_clause): Fix clause ordering.\n\t(and_predicates, or_predicates, predicates_equal_p, evaulate_predicate):\n\tSanity check predicate length.\n\t(remap_predicate): Likewise; sanity check jump functions.\n\t(inline_read_section, inline_write_summary): Sanity check\n\tpredicate length.\n\nFrom-SVN: r172914", "tree": {"sha": "169486f39c22a6680ce791881b07a86b570a02a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/169486f39c22a6680ce791881b07a86b570a02a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3181aa2021d0ac64a0cce8a6c2a926553e7639a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3181aa2021d0ac64a0cce8a6c2a926553e7639a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3181aa2021d0ac64a0cce8a6c2a926553e7639a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3181aa2021d0ac64a0cce8a6c2a926553e7639a/comments", "author": null, "committer": null, "parents": [{"sha": "739986ef4a4143b0b358a2fe77cb0a62da78ac7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/739986ef4a4143b0b358a2fe77cb0a62da78ac7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/739986ef4a4143b0b358a2fe77cb0a62da78ac7e"}], "stats": {"total": 70, "additions": 54, "deletions": 16}, "files": [{"sha": "3a7ebf0e42425e2d9e46e42b2c9c8a2c56cd20e8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3181aa2021d0ac64a0cce8a6c2a926553e7639a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3181aa2021d0ac64a0cce8a6c2a926553e7639a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f3181aa2021d0ac64a0cce8a6c2a926553e7639a", "patch": "@@ -1,3 +1,17 @@\n+2011-04-24  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-prop.c (ipa_propagate_indirect_call_infos): Remove obsolette\n+\tWPA hack.\n+\t* ipa-prop.h (ipa_get_param, ipa_is_param_used, ipa_param_cannot_devirtualize_p,\n+\tipa_param_types_vec_empty, ipa_get_ith_jump_func, ipa_get_lattice):\n+\tFortify array bounds.\n+\t* ipa-inline-analysis.c (add_clause): Fix clause ordering.\n+\t(and_predicates, or_predicates, predicates_equal_p, evaulate_predicate):\n+\tSanity check predicate length.\n+\t(remap_predicate): Likewise; sanity check jump functions.\n+\t(inline_read_section, inline_write_summary): Sanity check\n+\tpredicate length.\n+\n 2011-04-24  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR other/48748"}, {"sha": "bedd9633da8527dfbe2336a936e1dcf0c9850c13", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 34, "deletions": 12, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3181aa2021d0ac64a0cce8a6c2a926553e7639a/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3181aa2021d0ac64a0cce8a6c2a926553e7639a/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=f3181aa2021d0ac64a0cce8a6c2a926553e7639a", "patch": "@@ -200,7 +200,7 @@ static inline void\n add_clause (struct predicate *p, clause_t clause)\n {\n   int i;\n-  int insert_here = 0;\n+  int insert_here = -1;\n   /* True clause.  */\n   if (!clause)\n     return;\n@@ -211,7 +211,7 @@ add_clause (struct predicate *p, clause_t clause)\n       p->clause[0] = (1 << predicate_false_condition);\n       p->clause[1] = 0;\n     }\n-  for (i = 0; i < MAX_CLAUSES; i++)\n+  for (i = 0; i < MAX_CLAUSES - 1; i++)\n     {\n       if (p->clause[i] == clause)\n         return;\n@@ -225,8 +225,11 @@ add_clause (struct predicate *p, clause_t clause)\n     return;\n   /* Keep clauses ordered by index, so equivalence testing is easy.  */\n   p->clause[i + 1] = 0;\n-  for (;i > insert_here; i--)\n-    p->clause[i] = p->clause[i - 1];\n+  if (insert_here >= 0)\n+    for (;i > insert_here; i--)\n+      p->clause[i] = p->clause[i - 1];\n+  else\n+    insert_here = i;\n   p->clause[insert_here] = clause;\n }\n \n@@ -239,7 +242,10 @@ and_predicates (struct predicate *p, struct predicate *p2)\n   struct predicate out = *p;\n   int i;\n   for (i = 0; p2->clause[i]; i++)\n-    add_clause (&out, p2->clause[i]);\n+    {\n+      gcc_checking_assert (i < MAX_CLAUSES);\n+      add_clause (&out, p2->clause[i]);\n+    }\n   return out;\n }\n \n@@ -264,7 +270,10 @@ or_predicates (struct predicate *p, struct predicate *p2)\n     }\n   for (i = 0; p->clause[i]; i++)\n     for (j = 0; p2->clause[j]; j++)\n-      add_clause (&out, p->clause[i] | p2->clause[j]);\n+      {\n+        gcc_checking_assert (i < MAX_CLAUSES && j < MAX_CLAUSES);\n+        add_clause (&out, p->clause[i] | p2->clause[j]);\n+      }\n   return out;\n }\n \n@@ -276,8 +285,11 @@ predicates_equal_p (struct predicate *p, struct predicate *p2)\n {\n   int i;\n   for (i = 0; p->clause[i]; i++)\n-    if (p->clause[i] != p2->clause[i])\n-      return false;\n+    {\n+      gcc_checking_assert (i < MAX_CLAUSES);\n+      if (p->clause[i] != p2->clause[i])\n+        return false;\n+    }\n   return !p2->clause[i];\n }\n \n@@ -296,8 +308,11 @@ evaulate_predicate (struct predicate *p, clause_t possible_truths)\n \n   /* See if we can find clause we can disprove.  */\n   for (i = 0; p->clause[i]; i++)\n-    if (!(p->clause[i] & possible_truths))\n-      return false;\n+    {\n+      gcc_checking_assert (i < MAX_CLAUSES);\n+      if (!(p->clause[i] & possible_truths))\n+        return false;\n+    }\n   return true;\n }\n \n@@ -1166,6 +1181,8 @@ remap_predicate (struct inline_summary *info, struct inline_summary *callee_info\n       int cond;\n       struct predicate clause_predicate = false_predicate ();\n \n+      gcc_assert (i < MAX_CLAUSES);\n+\n       for (cond = 0; cond < NUM_CONDITIONS; cond ++)\n \t/* Do we have condition we can't disprove?   */\n \tif (clause & possible_truths & (1 << cond))\n@@ -1240,6 +1257,7 @@ inline_merge_summary (struct cgraph_edge *edge)\n \t      && jfunc->value.pass_through.operation == NOP_EXPR)\n \t    map = jfunc->value.pass_through.formal_id;\n \t  VEC_replace (int, operand_map, i, map);\n+\t  gcc_assert (map < ipa_get_param_count (IPA_NODE_REF (to)));\n \t}\n     }\n   for (i = 0; VEC_iterate (size_time_entry, callee_info->entry, i, e); i++)\n@@ -1544,6 +1562,7 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n \t  do \n \t    {\n \t      clause = e.predicate.clause[k++] = lto_input_uleb128 (&ib);\n+\t      gcc_assert (k < MAX_CLAUSES);\n \t    }\n \t  while (clause);\n \n@@ -1658,8 +1677,11 @@ inline_write_summary (cgraph_node_set set,\n \t      lto_output_uleb128_stream (ob->main_stream,\n \t\t\t\t\t e->time);\n \t      for (j = 0; e->predicate.clause[j]; j++)\n-\t\tlto_output_uleb128_stream (ob->main_stream,\n-\t\t\t\t\t   e->predicate.clause[j]);\n+\t\t{\n+\t\t   gcc_assert (j < MAX_CLAUSES);\n+\t\t   lto_output_uleb128_stream (ob->main_stream,\n+\t\t\t\t\t      e->predicate.clause[j]);\n+\t\t}\n \t      lto_output_uleb128_stream (ob->main_stream, 0);\n \t    }\n \t}"}, {"sha": "5691193ce0deddb9c19f10acecc6bb614735b546", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3181aa2021d0ac64a0cce8a6c2a926553e7639a/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3181aa2021d0ac64a0cce8a6c2a926553e7639a/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=f3181aa2021d0ac64a0cce8a6c2a926553e7639a", "patch": "@@ -1890,10 +1890,6 @@ bool\n ipa_propagate_indirect_call_infos (struct cgraph_edge *cs,\n \t\t\t\t   VEC (cgraph_edge_p, heap) **new_edges)\n {\n-  /* FIXME lto: We do not stream out indirect call information.  */\n-  if (flag_wpa)\n-    return false;\n-\n   /* Do nothing if the preparation phase has not been carried out yet\n      (i.e. during early inlining).  */\n   if (!ipa_node_params_vector)"}, {"sha": "d5f1bc6de2875ad4df95de5dd61a88055e4e0105", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3181aa2021d0ac64a0cce8a6c2a926553e7639a/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3181aa2021d0ac64a0cce8a6c2a926553e7639a/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=f3181aa2021d0ac64a0cce8a6c2a926553e7639a", "patch": "@@ -228,6 +228,7 @@ ipa_get_param_count (struct ipa_node_params *info)\n static inline tree\n ipa_get_param (struct ipa_node_params *info, int i)\n {\n+  gcc_assert (i >= 0 && i <= info->param_count);\n   return info->params[i].decl;\n }\n \n@@ -237,6 +238,7 @@ ipa_get_param (struct ipa_node_params *info, int i)\n static inline bool\n ipa_is_param_used (struct ipa_node_params *info, int i)\n {\n+  gcc_assert (i >= 0 && i <= info->param_count);\n   return info->params[i].used;\n }\n \n@@ -247,6 +249,7 @@ ipa_is_param_used (struct ipa_node_params *info, int i)\n static inline bool\n ipa_param_cannot_devirtualize_p (struct ipa_node_params *info, int i)\n {\n+  gcc_assert (i >= 0 && i <= info->param_count);\n   return info->params[i].cannot_devirtualize;\n }\n \n@@ -256,6 +259,7 @@ ipa_param_cannot_devirtualize_p (struct ipa_node_params *info, int i)\n static inline bool\n ipa_param_types_vec_empty (struct ipa_node_params *info, int i)\n {\n+  gcc_assert (i >= 0 && i <= info->param_count);\n   return info->params[i].types == NULL;\n }\n \n@@ -315,6 +319,7 @@ ipa_get_cs_argument_count (struct ipa_edge_args *args)\n static inline struct ipa_jump_func *\n ipa_get_ith_jump_func (struct ipa_edge_args *args, int i)\n {\n+  gcc_assert (i >= 0 && i <= args->argument_count);\n   return &args->jump_functions[i];\n }\n \n@@ -528,6 +533,7 @@ tree build_ref_for_offset (location_t, tree, HOST_WIDE_INT, tree,\n static inline struct ipcp_lattice *\n ipa_get_lattice (struct ipa_node_params *info, int i)\n {\n+  gcc_assert (i >= 0 && i <= info->param_count);\n   return &(info->params[i].ipcp_lattice);\n }\n "}]}