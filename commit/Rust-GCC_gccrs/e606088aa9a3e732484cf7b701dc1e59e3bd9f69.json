{"sha": "e606088aa9a3e732484cf7b701dc1e59e3bd9f69", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTYwNjA4OGFhOWEzZTczMjQ4NGNmN2I3MDFkYzFlNTllM2JkOWY2OQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-19T10:37:41Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-19T10:37:41Z"}, "message": "[multiple changes]\n\n2010-10-19  Geert Bosch  <bosch@adacore.com>\n\n\t* ttypef.ads: Change VAXDF_Last to be -VAXDF_First, as type is\n\tsymmetric.\n\n2010-10-19  Robert Dewar  <dewar@adacore.com>\n\n\t* atree.h (Field29): Fix incorrect definition.\n\t* einfo.adb (Invariant_Procedure): New attribute\n\t(Has_Invariants): New flag\n\t(Has_Inheritable_Invariants): New flag\n\t(OK_To_Reference): New flag\n\tMinor code reorganization (use Next_Rep_Item function)\n\t* einfo.ads (Invariant_Procedure): New attribute\n\t(Has_Invariants): New flag\n\t(Has_Inheritable_Invariants): New flag\n\t(OK_To_Reference): New flag\n\t* exp_ch3.adb (Expand_N_Object_Declaration): Add check for invariant\n\t* exp_ch4.adb (Expand_N_Type_Conversion): Check invariant on type\n\tconversion.  Minor reformatting.\n\t* exp_util.ads, exp_util.adb (Make_Invariant_Call): New procedure.\n\t* opt.ads (List_Inherited_Aspects): New name for List_Inherited_Pre_Post\n\t* par-prag.adb: Add dummy entry for pragma Invariant.\n\t* sem_ch13.adb (Build_Invariant_Procedure): New procedure\n\t(Analyze_Aspect_Specification): Add support for Invariant aspect\n\t* sem_ch13.ads (Build_Invariant_Procedure): New procedure\n\t* sem_ch3.adb (Build_Derived_Type): Propagate invariant information\n\t(Process_Full_View): Deal with invariants, building invariant procedure\n\tMinor reformatting\n\t* sem_ch6.adb (Process_PPCs): Add processing of invariants\n\t* sem_ch7.adb (Analyze_Package_Specification): Build invariant\n\tprocedures.\n\t* sem_prag.adb: Implement pragma Invariant.\n\t* sem_res.adb (Resolve_Entity_Name): Allow type reference if\n\tOK_To_Reference set.\n\t* sem_warn.adb (List_Inherited_Aspects): New name for\n\tList_Inherited_Pre_Post.\n\t* snames.ads-tmpl: Add entries for pragma Invariant.\n\t* treepr.adb (Print_Entity_Information): Add handling of Field29.\n\t* usage.adb: Warning .l/.L applies to invariant as well as pre/post.\n\nFrom-SVN: r165694", "tree": {"sha": "3a8f635ec7941d35e5630c74c102a5b8ac101976", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a8f635ec7941d35e5630c74c102a5b8ac101976"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e606088aa9a3e732484cf7b701dc1e59e3bd9f69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e606088aa9a3e732484cf7b701dc1e59e3bd9f69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e606088aa9a3e732484cf7b701dc1e59e3bd9f69", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/comments", "author": null, "committer": null, "parents": [{"sha": "c95e0edc4588b3811bec2fc4d4aa1bf0b7a0456a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c95e0edc4588b3811bec2fc4d4aa1bf0b7a0456a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c95e0edc4588b3811bec2fc4d4aa1bf0b7a0456a"}], "stats": {"total": 1109, "additions": 986, "deletions": 123}, "files": [{"sha": "b2df102bd0a07ffadc5ccc2a483083e13f3c1836", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e606088aa9a3e732484cf7b701dc1e59e3bd9f69", "patch": "@@ -1,3 +1,44 @@\n+2010-10-19  Geert Bosch  <bosch@adacore.com>\n+\n+\t* ttypef.ads: Change VAXDF_Last to be -VAXDF_First, as type is\n+\tsymmetric.\n+\n+2010-10-19  Robert Dewar  <dewar@adacore.com>\n+\n+\t* atree.h (Field29): Fix incorrect definition.\n+\t* einfo.adb (Invariant_Procedure): New attribute\n+\t(Has_Invariants): New flag\n+\t(Has_Inheritable_Invariants): New flag\n+\t(OK_To_Reference): New flag\n+\tMinor code reorganization (use Next_Rep_Item function)\n+\t* einfo.ads (Invariant_Procedure): New attribute\n+\t(Has_Invariants): New flag\n+\t(Has_Inheritable_Invariants): New flag\n+\t(OK_To_Reference): New flag\n+\t* exp_ch3.adb (Expand_N_Object_Declaration): Add check for invariant\n+\t* exp_ch4.adb (Expand_N_Type_Conversion): Check invariant on type\n+\tconversion.  Minor reformatting.\n+\t* exp_util.ads, exp_util.adb (Make_Invariant_Call): New procedure.\n+\t* opt.ads (List_Inherited_Aspects): New name for List_Inherited_Pre_Post\n+\t* par-prag.adb: Add dummy entry for pragma Invariant.\n+\t* sem_ch13.adb (Build_Invariant_Procedure): New procedure\n+\t(Analyze_Aspect_Specification): Add support for Invariant aspect\n+\t* sem_ch13.ads (Build_Invariant_Procedure): New procedure\n+\t* sem_ch3.adb (Build_Derived_Type): Propagate invariant information\n+\t(Process_Full_View): Deal with invariants, building invariant procedure\n+\tMinor reformatting\n+\t* sem_ch6.adb (Process_PPCs): Add processing of invariants\n+\t* sem_ch7.adb (Analyze_Package_Specification): Build invariant\n+\tprocedures.\n+\t* sem_prag.adb: Implement pragma Invariant.\n+\t* sem_res.adb (Resolve_Entity_Name): Allow type reference if\n+\tOK_To_Reference set.\n+\t* sem_warn.adb (List_Inherited_Aspects): New name for\n+\tList_Inherited_Pre_Post.\n+\t* snames.ads-tmpl: Add entries for pragma Invariant.\n+\t* treepr.adb (Print_Entity_Information): Add handling of Field29.\n+\t* usage.adb: Warning .l/.L applies to invariant as well as pre/post.\n+\n 2010-10-19  Javier Miranda  <miranda@adacore.com>\n \n \t* par-ch4.adb: Update documentation of Ada 2012 syntax rules for"}, {"sha": "e6a429c01ef6cacc9d048ab4a9d751c5e291c305", "filename": "gcc/ada/atree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Fatree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Fatree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.h?ref=e606088aa9a3e732484cf7b701dc1e59e3bd9f69", "patch": "@@ -382,7 +382,7 @@ extern Node_Id Current_Error_Node;\n #define Field26(N)    (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.field8)\n #define Field27(N)    (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.field9)\n #define Field28(N)    (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.field10)\n-#define Field29(N)    (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.field11)\n+#define Field29(N)    (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.X.field11)\n \n #define Node1(N)      Field1  (N)\n #define Node2(N)      Field2  (N)"}, {"sha": "a442cd2d9e0fa9d16dd0fb0b36d79ec7612443d0", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 74, "deletions": 11, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=e606088aa9a3e732484cf7b701dc1e59e3bd9f69", "patch": "@@ -230,7 +230,7 @@ package body Einfo is\n    --    Extra_Formals                   Node28\n    --    Underlying_Record_View          Node28\n \n-   --    (unused)                        Node29\n+   --    Invariant_Procedure             Node29\n \n    ---------------------------------------------\n    -- Usage of Flags in Defining Entity Nodes --\n@@ -241,7 +241,7 @@ package body Einfo is\n    --  sense for them to be set true for certain subsets of entity kinds. See\n    --  the spec of Einfo for further details.\n \n-   --  Note: Flag1-Flag2 are absent from this list, for historical reasons\n+   --  Note: Flag1-Flag3 are absent from this list, for historical reasons\n \n    --    Is_Frozen                       Flag4\n    --    Has_Discriminants               Flag5\n@@ -494,6 +494,7 @@ package body Einfo is\n    --    Has_Pragma_Inline_Always        Flag230\n \n    --    Renamed_In_Spec                 Flag231\n+   --    Has_Invariants                  Flag232\n    --    Has_Pragma_Unmodified           Flag233\n    --    Is_Dispatch_Table_Entity        Flag234\n    --    Is_Trivial_Subprogram           Flag235\n@@ -510,10 +511,9 @@ package body Einfo is\n    --    Is_Private_Primitive            Flag245\n    --    Is_Underlying_Record_View       Flag246\n    --    OK_To_Rename                    Flag247\n+   --    Has_Inheritable_Invariants      Flag248\n+   --    OK_To_Reference                 Flag249\n \n-   --    (unused)                        Flag232\n-   --    (unused)                        Flag248\n-   --    (unused)                        Flag249\n    --    (unused)                        Flag250\n    --    (unused)                        Flag251\n    --    (unused)                        Flag252\n@@ -543,7 +543,7 @@ package body Einfo is\n          then\n             return Ritem;\n          else\n-            Ritem := Next_Rep_Item (Ritem);\n+            Next_Rep_Item (Ritem);\n          end if;\n       end loop;\n \n@@ -1273,13 +1273,24 @@ package body Einfo is\n       return Flag56 (Id);\n    end Has_Homonym;\n \n+   function Has_Inheritable_Invariants (Id : E) return B is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      return Flag248 (Id);\n+   end Has_Inheritable_Invariants;\n+\n    function Has_Initial_Value (Id : E) return B is\n    begin\n-      pragma Assert\n-        (Ekind (Id) = E_Variable or else Is_Formal (Id));\n+      pragma Assert (Ekind (Id) = E_Variable or else Is_Formal (Id));\n       return Flag219 (Id);\n    end Has_Initial_Value;\n \n+   function Has_Invariants (Id : E) return B is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      return Flag232 (Id);\n+   end Has_Invariants;\n+\n    function Has_Machine_Radix_Clause (Id : E) return B is\n    begin\n       pragma Assert (Is_Decimal_Fixed_Point_Type (Id));\n@@ -1555,6 +1566,12 @@ package body Einfo is\n       return Elist25 (Id);\n    end Interfaces;\n \n+   function Invariant_Procedure (Id : E) return N is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      return Node29 (Id);\n+   end Invariant_Procedure;\n+\n    function In_Package_Body (Id : E) return B is\n    begin\n       return Flag48 (Id);\n@@ -2286,6 +2303,12 @@ package body Einfo is\n       return Uint10 (Id);\n    end Normalized_Position_Max;\n \n+   function OK_To_Reference (Id : E) return B is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      return Flag249 (Id);\n+   end OK_To_Reference;\n+\n    function OK_To_Rename (Id : E) return B is\n    begin\n       pragma Assert (Ekind (Id) = E_Variable);\n@@ -3685,12 +3708,24 @@ package body Einfo is\n       Set_Flag56 (Id, V);\n    end Set_Has_Homonym;\n \n+   procedure Set_Has_Inheritable_Invariants (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      Set_Flag248 (Id, V);\n+   end Set_Has_Inheritable_Invariants;\n+\n    procedure Set_Has_Initial_Value (Id : E; V : B := True) is\n    begin\n       pragma Assert (Ekind_In (Id, E_Variable, E_Out_Parameter));\n       Set_Flag219 (Id, V);\n    end Set_Has_Initial_Value;\n \n+   procedure Set_Has_Invariants (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      Set_Flag232 (Id, V);\n+   end Set_Has_Invariants;\n+\n    procedure Set_Has_Machine_Radix_Clause (Id : E; V : B := True) is\n    begin\n       pragma Assert (Is_Decimal_Fixed_Point_Type (Id));\n@@ -3977,6 +4012,12 @@ package body Einfo is\n       Set_Elist25 (Id, V);\n    end Set_Interfaces;\n \n+   procedure Set_Invariant_Procedure (Id : E; V : N) is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      Set_Node29 (Id, V);\n+   end Set_Invariant_Procedure;\n+\n    procedure Set_In_Package_Body (Id : E; V : B := True) is\n    begin\n       Set_Flag48 (Id, V);\n@@ -4743,6 +4784,12 @@ package body Einfo is\n       Set_Uint10 (Id, V);\n    end Set_Normalized_Position_Max;\n \n+   procedure Set_OK_To_Reference (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      Set_Flag249 (Id, V);\n+   end Set_OK_To_Reference;\n+\n    procedure Set_OK_To_Rename (Id : E; V : B := True) is\n    begin\n       pragma Assert (Ekind (Id) = E_Variable);\n@@ -5899,7 +5946,7 @@ package body Einfo is\n          then\n             return True;\n          else\n-            Ritem := Next_Rep_Item (Ritem);\n+            Next_Rep_Item (Ritem);\n          end if;\n       end loop;\n \n@@ -5972,7 +6019,7 @@ package body Einfo is\n          then\n             return True;\n          else\n-            Ritem := Next_Rep_Item (Ritem);\n+            Next_Rep_Item (Ritem);\n          end if;\n       end loop;\n \n@@ -6991,7 +7038,9 @@ package body Einfo is\n       W (\"Has_Fully_Qualified_Name\",        Flag173 (Id));\n       W (\"Has_Gigi_Rep_Item\",               Flag82  (Id));\n       W (\"Has_Homonym\",                     Flag56  (Id));\n+      W (\"Has_Inheritable_Invariants\",      Flag248 (Id));\n       W (\"Has_Initial_Value\",               Flag219 (Id));\n+      W (\"Has_Invariants\",                  Flag232 (Id));\n       W (\"Has_Machine_Radix_Clause\",        Flag83  (Id));\n       W (\"Has_Master_Entity\",               Flag21  (Id));\n       W (\"Has_Missing_Return\",              Flag142 (Id));\n@@ -7156,6 +7205,7 @@ package body Einfo is\n       W (\"No_Strict_Aliasing\",              Flag136 (Id));\n       W (\"Non_Binary_Modulus\",              Flag58  (Id));\n       W (\"Nonzero_Is_True\",                 Flag162 (Id));\n+      W (\"OK_To_Reference\",                 Flag249 (Id));\n       W (\"OK_To_Rename\",                    Flag247 (Id));\n       W (\"OK_To_Reorder_Components\",        Flag239 (Id));\n       W (\"Optimize_Alignment_Space\",        Flag241 (Id));\n@@ -8143,7 +8193,6 @@ package body Einfo is\n \n          when E_Procedure                                  |\n               E_Function                                   =>\n-\n             if Is_Dispatching_Operation (Id) then\n                Write_Str (\"Overridden_Operation\");\n             else\n@@ -8197,6 +8246,9 @@ package body Einfo is\n    procedure Write_Field28_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n+         when Private_Kind =>\n+            Write_Str (\"Invariant_Procedure\");\n+\n          when E_Procedure | E_Function | E_Entry           =>\n             Write_Str (\"Extra_Formals\");\n \n@@ -8208,6 +8260,17 @@ package body Einfo is\n       end case;\n    end Write_Field28_Name;\n \n+   procedure Write_Field29_Name (Id : Entity_Id) is\n+   begin\n+      case Ekind (Id) is\n+         when Type_Kind =>\n+            Write_Str (\"Invariant_Procedure\");\n+\n+         when others                                       =>\n+            Write_Str (\"Field29??\");\n+      end case;\n+   end Write_Field29_Name;\n+\n    -------------------------\n    -- Iterator Procedures --\n    -------------------------"}, {"sha": "bbfa09bbe348f2c68f3550c404d5ef1f77ef2219", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 63, "deletions": 7, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=e606088aa9a3e732484cf7b701dc1e59e3bd9f69", "patch": "@@ -504,7 +504,7 @@ package Einfo is\n --       which can never have a null value. This is set True for constant\n --       access values initialized to a non-null value. This is also True for\n --       all access parameters in Ada 83 and Ada 95 modes, and for access\n---       parameters that explicily exlude null in Ada 2005.\n+--       parameters that explicily exclude null in Ada 2005.\n --\n --       This is used to avoid unnecessary resetting of the Is_Known_Non_Null\n --       flag for such entities. In Ada 2005 mode, this is also used when\n@@ -1505,6 +1505,25 @@ package Einfo is\n --       definition contains at least one procedure to which a pragma\n --       Interrupt_Handler applies.\n \n+--    Has_Invariants (Flag232)\n+--       Present in all type entities. Set True in private types if an\n+--       Invariant or Invariant'Class aspect applies to the type, or if the\n+--       type inherits one or more Invariant'Class aspects. Also set in the\n+--       corresponding full type. Note: if this flag is set True, then usually\n+--       the Invariant_Procedure field is set once the type is frozen, however\n+--       this may not be true in some error situations. Note that it might be\n+--       the full type which has inheritable invariants, and then the flag will\n+--       also be set in the private type.\n+\n+--    Has_Inheritable_Invariants (Flag248)\n+--       Present in all type entities. Set True in private types from which one\n+--       or more Invariant'Class aspects will be inherited if a another type is\n+--       derived from the type (i.e. those types which have an Invariant'Class\n+--       aspect, or which inherit one or more Invariant'Class aspects). Also\n+--       set in the corresponding full types. Note that it might be the full\n+--       type which has inheritable invariants, and in this case the flag will\n+--       also be set in the private type.\n+\n --    Has_Machine_Radix_Clause (Flag83)\n --       Present in decimal types and subtypes, set if a Machine_Radix\n --       representation clause is present. This flag is used to detect\n@@ -1716,10 +1735,10 @@ package Einfo is\n --       representation clause, and thus is not inherited by a derived type.\n --       This flag is always False for non-record types.\n \n---    Has_Specified_Stream_Input  (Flag190)\n+--    Has_Specified_Stream_Input (Flag190)\n --    Has_Specified_Stream_Output (Flag191)\n---    Has_Specified_Stream_Read   (Flag192)\n---    Has_Specified_Stream_Write  (Flag193)\n+--    Has_Specified_Stream_Read (Flag192)\n+--    Has_Specified_Stream_Write (Flag193)\n --       Present in all type and subtype entities. Set for a given view if the\n --       corresponding stream-oriented attribute has been defined by an\n --       attribute definition clause. When such a clause occurs, a TSS is set\n@@ -1880,6 +1899,16 @@ package Einfo is\n --       External_Name of the imported Java field (which is generally needed,\n --       because Java names are case sensitive).\n \n+--    Invariant_Procedure (Node29)\n+--       Present in types and subtypes. Set for private types if one or more\n+--       Invariant, or Invariant'Class, or inherited Invariant'Class aspects\n+--       apply to the type. Points to the entity for a procedure which checks\n+--       the invariant. This invariant procedure takes a single argument of the\n+--       given type, and returns if the invariant holds, or raises exception\n+--       Assertion_Error with an appropriate message if it does not hold. This\n+--       field is present but always empty for private subtypes. This field is\n+--       also set for the corresponding full type.\n+\n --    In_Use (Flag8)\n --       Present in packages and types. Set when analyzing a use clause for\n --       the corresponding entity. Reset at end of corresponding declarative\n@@ -3108,6 +3137,12 @@ package Einfo is\n --       Applies to subprograms and subprogram types. Yields the number of\n --       formals as a value of type Pos.\n \n+--    OK_To_Reference (Flag249)\n+--       Present in all entities for types and subtypes. If set it indicates\n+--       that a naked reference to the type is permitted within an expression\n+--       that is being analyzed or preanalyed (for example, a type name may\n+--       be referenced within the Invariant aspect expression for the type).\n+\n --    OK_To_Rename (Flag247)\n --       Present only in entities for variables. If this flag is set, it\n --       means that if the entity is used as the initial value of an object\n@@ -4697,6 +4732,7 @@ package Einfo is\n    --    Alignment                           (Uint14)\n    --    Related_Expression                  (Node24)\n    --    Current_Use_Clause                  (Node27)\n+   --    Invariant_Procedure                 (Node29)\n \n    --    Depends_On_Private                  (Flag14)\n    --    Discard_Names                       (Flag88)\n@@ -4709,6 +4745,8 @@ package Einfo is\n    --    Has_Complex_Representation          (Flag140)  (base type only)\n    --    Has_Constrained_Partial_View        (Flag187)\n    --    Has_Discriminants                   (Flag5)\n+   --    Has_Inheritable_Invariants          (Flag248)\n+   --    Has_Invariants                      (Flag232)\n    --    Has_Non_Standard_Rep                (Flag75)   (base type only)\n    --    Has_Object_Size_Clause              (Flag172)\n    --    Has_Pragma_Preelab_Init             (Flag221)\n@@ -4743,6 +4781,7 @@ package Einfo is\n    --    Known_To_Have_Preelab_Init          (Flag207)\n    --    Must_Be_On_Byte_Boundary            (Flag183)\n    --    Must_Have_Preelab_Init              (Flag208)\n+   --    OK_To_Reference                     (Flag249)\n    --    Optimize_Alignment_Space            (Flag241)\n    --    Optimize_Alignment_Time             (Flag242)\n    --    Size_Depends_On_Discriminant        (Flag177)\n@@ -5897,7 +5936,9 @@ package Einfo is\n    function Has_Fully_Qualified_Name            (Id : E) return B;\n    function Has_Gigi_Rep_Item                   (Id : E) return B;\n    function Has_Homonym                         (Id : E) return B;\n+   function Has_Inheritable_Invariants          (Id : E) return B;\n    function Has_Initial_Value                   (Id : E) return B;\n+   function Has_Invariants                      (Id : E) return B;\n    function Has_Interrupt_Handler               (Id : E) return B;\n    function Has_Machine_Radix_Clause            (Id : E) return B;\n    function Has_Master_Entity                   (Id : E) return B;\n@@ -5954,6 +5995,7 @@ package Einfo is\n    function Interface_Alias                     (Id : E) return E;\n    function Interfaces                          (Id : E) return L;\n    function Interface_Name                      (Id : E) return N;\n+   function Invariant_Procedure                 (Id : E) return N;\n    function Is_AST_Entry                        (Id : E) return B;\n    function Is_Abstract_Subprogram              (Id : E) return B;\n    function Is_Abstract_Type                    (Id : E) return B;\n@@ -6075,6 +6117,7 @@ package Einfo is\n    function Normalized_First_Bit                (Id : E) return U;\n    function Normalized_Position                 (Id : E) return U;\n    function Normalized_Position_Max             (Id : E) return U;\n+   function OK_To_Reference                     (Id : E) return B;\n    function OK_To_Rename                        (Id : E) return B;\n    function OK_To_Reorder_Components            (Id : E) return B;\n    function Optimize_Alignment_Space            (Id : E) return B;\n@@ -6460,7 +6503,9 @@ package Einfo is\n    procedure Set_Has_Fully_Qualified_Name        (Id : E; V : B := True);\n    procedure Set_Has_Gigi_Rep_Item               (Id : E; V : B := True);\n    procedure Set_Has_Homonym                     (Id : E; V : B := True);\n+   procedure Set_Has_Inheritable_Invariants      (Id : E; V : B := True);\n    procedure Set_Has_Initial_Value               (Id : E; V : B := True);\n+   procedure Set_Has_Invariants                  (Id : E; V : B := True);\n    procedure Set_Has_Machine_Radix_Clause        (Id : E; V : B := True);\n    procedure Set_Has_Master_Entity               (Id : E; V : B := True);\n    procedure Set_Has_Missing_Return              (Id : E; V : B := True);\n@@ -6517,6 +6562,7 @@ package Einfo is\n    procedure Set_Inner_Instances                 (Id : E; V : L);\n    procedure Set_Interface_Alias                 (Id : E; V : E);\n    procedure Set_Interface_Name                  (Id : E; V : N);\n+   procedure Set_Invariant_Procedure             (Id : E; V : N);\n    procedure Set_Is_AST_Entry                    (Id : E; V : B := True);\n    procedure Set_Is_Abstract_Subprogram          (Id : E; V : B := True);\n    procedure Set_Is_Abstract_Type                (Id : E; V : B := True);\n@@ -6645,6 +6691,7 @@ package Einfo is\n    procedure Set_Normalized_First_Bit            (Id : E; V : U);\n    procedure Set_Normalized_Position             (Id : E; V : U);\n    procedure Set_Normalized_Position_Max         (Id : E; V : U);\n+   procedure Set_OK_To_Reference                 (Id : E; V : B := True);\n    procedure Set_OK_To_Rename                    (Id : E; V : B := True);\n    procedure Set_OK_To_Reorder_Components        (Id : E; V : B := True);\n    procedure Set_Optimize_Alignment_Space        (Id : E; V : B := True);\n@@ -7002,9 +7049,10 @@ package Einfo is\n    procedure Write_Field26_Name (Id : Entity_Id);\n    procedure Write_Field27_Name (Id : Entity_Id);\n    procedure Write_Field28_Name (Id : Entity_Id);\n-   --  These routines are used to output a nice symbolic name for the given\n-   --  field, depending on the Ekind. No blanks or end of lines are output,\n-   --  just the characters of the field name.\n+   procedure Write_Field29_Name (Id : Entity_Id);\n+   --  These routines are used in Treepr to output a nice symbolic name for\n+   --  the given field, depending on the Ekind. No blanks or end of lines are\n+   --  output, just the characters of the field name.\n \n    --------------------\n    -- Inline Pragmas --\n@@ -7135,7 +7183,9 @@ package Einfo is\n    pragma Inline (Has_Fully_Qualified_Name);\n    pragma Inline (Has_Gigi_Rep_Item);\n    pragma Inline (Has_Homonym);\n+   pragma Inline (Has_Inheritable_Invariants);\n    pragma Inline (Has_Initial_Value);\n+   pragma Inline (Has_Invariants);\n    pragma Inline (Has_Machine_Radix_Clause);\n    pragma Inline (Has_Master_Entity);\n    pragma Inline (Has_Missing_Return);\n@@ -7192,6 +7242,7 @@ package Einfo is\n    pragma Inline (Inner_Instances);\n    pragma Inline (Interface_Alias);\n    pragma Inline (Interface_Name);\n+   pragma Inline (Invariant_Procedure);\n    pragma Inline (Is_AST_Entry);\n    pragma Inline (Is_Abstract_Subprogram);\n    pragma Inline (Is_Abstract_Type);\n@@ -7362,6 +7413,7 @@ package Einfo is\n    pragma Inline (Normalized_First_Bit);\n    pragma Inline (Normalized_Position);\n    pragma Inline (Normalized_Position_Max);\n+   pragma Inline (OK_To_Reference);\n    pragma Inline (OK_To_Rename);\n    pragma Inline (OK_To_Reorder_Components);\n    pragma Inline (Optimize_Alignment_Space);\n@@ -7568,7 +7620,9 @@ package Einfo is\n    pragma Inline (Set_Has_Fully_Qualified_Name);\n    pragma Inline (Set_Has_Gigi_Rep_Item);\n    pragma Inline (Set_Has_Homonym);\n+   pragma Inline (Set_Has_Inheritable_Invariants);\n    pragma Inline (Set_Has_Initial_Value);\n+   pragma Inline (Set_Has_Invariants);\n    pragma Inline (Set_Has_Machine_Radix_Clause);\n    pragma Inline (Set_Has_Master_Entity);\n    pragma Inline (Set_Has_Missing_Return);\n@@ -7625,6 +7679,7 @@ package Einfo is\n    pragma Inline (Set_Inner_Instances);\n    pragma Inline (Set_Interface_Alias);\n    pragma Inline (Set_Interface_Name);\n+   pragma Inline (Set_Invariant_Procedure);\n    pragma Inline (Set_Is_AST_Entry);\n    pragma Inline (Set_Is_Abstract_Subprogram);\n    pragma Inline (Set_Is_Abstract_Type);\n@@ -7754,6 +7809,7 @@ package Einfo is\n    pragma Inline (Set_Normalized_Position);\n    pragma Inline (Set_Normalized_Position_Max);\n    pragma Inline (Set_OK_To_Reorder_Components);\n+   pragma Inline (Set_OK_To_Reference);\n    pragma Inline (Set_OK_To_Rename);\n    pragma Inline (Set_Optimize_Alignment_Space);\n    pragma Inline (Set_Optimize_Alignment_Time);"}, {"sha": "957dc0bd20264fee4b36e3f4127ced55cedc0f9b", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=e606088aa9a3e732484cf7b701dc1e59e3bd9f69", "patch": "@@ -4570,6 +4570,19 @@ package body Exp_Ch3 is\n \n       if No (Expr) then\n \n+         --  For the default initialization case, if we have a private type\n+         --  with invariants, and invariant checks are enabled, then insert an\n+         --  invariant check after the object declaration. Note that it is OK\n+         --  to clobber the object with an invalid value since if the exception\n+         --  is raised, then the object will go out of scope.\n+\n+         if Is_Private_Type (Typ)\n+           and then Present (Invariant_Procedure (Typ))\n+         then\n+            Insert_After (N,\n+              Make_Invariant_Call (New_Occurrence_Of (Def_Id, Loc)));\n+         end if;\n+\n          --  Expand Initialize call for controlled objects. One may wonder why\n          --  the Initialize Call is not done in the regular Init procedure\n          --  attached to the record type. That's because the init procedure is\n@@ -5176,9 +5189,10 @@ package body Exp_Ch3 is\n             Set_Renamed_Object (Defining_Identifier (N), Expr_Q);\n             Set_Analyzed (N);\n          end if;\n-\n       end if;\n \n+   --  Exception on library entity not available\n+\n    exception\n       when RE_Not_Available =>\n          return;"}, {"sha": "682f07581f422f7452003c20ad03d7a65bd894d9", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 49, "deletions": 12, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=e606088aa9a3e732484cf7b701dc1e59e3bd9f69", "patch": "@@ -4349,12 +4349,17 @@ package body Exp_Ch4 is\n \n          begin\n             if (Is_Entity_Name (Alt) and then Is_Type (Entity (Alt)))\n-               or else Nkind (Alt) = N_Range\n+              or else Nkind (Alt) = N_Range\n             then\n-               Cond := Make_In (Sloc (Alt), Left_Opnd  => L, Right_Opnd => R);\n+               Cond :=\n+                 Make_In (Sloc (Alt),\n+                   Left_Opnd  => L,\n+                   Right_Opnd => R);\n             else\n                Cond :=\n-                 Make_Op_Eq (Sloc (Alt), Left_Opnd  => L, Right_Opnd => R);\n+                 Make_Op_Eq (Sloc (Alt),\n+                   Left_Opnd  => L,\n+                   Right_Opnd => R);\n             end if;\n \n             return Cond;\n@@ -4472,17 +4477,17 @@ package body Exp_Ch4 is\n          begin\n             --  If test is explicit x'First .. x'Last, replace by valid check\n \n+            --  Could use some individual comments for this complex test ???\n+\n             if Is_Scalar_Type (Ltyp)\n               and then Nkind (Lo_Orig) = N_Attribute_Reference\n               and then Attribute_Name (Lo_Orig) = Name_First\n               and then Nkind (Prefix (Lo_Orig)) in N_Has_Entity\n               and then Entity (Prefix (Lo_Orig)) = Ltyp\n-\n               and then Nkind (Hi_Orig) = N_Attribute_Reference\n               and then Attribute_Name (Hi_Orig) = Name_Last\n               and then Nkind (Prefix (Hi_Orig)) in N_Has_Entity\n               and then Entity (Prefix (Hi_Orig)) = Ltyp\n-\n               and then Comes_From_Source (N)\n               and then VM_Target = No_VM\n             then\n@@ -8143,7 +8148,7 @@ package body Exp_Ch4 is\n          end if;\n \n          Rewrite (N, Relocate_Node (Operand));\n-         return;\n+         goto Done;\n       end if;\n \n       --  Nothing to do if this is the second argument of read. This is a\n@@ -8154,7 +8159,34 @@ package body Exp_Ch4 is\n         and then Attribute_Name (Parent (N)) = Name_Read\n         and then Next (First (Expressions (Parent (N)))) = N\n       then\n-         return;\n+         goto Done;\n+      end if;\n+\n+      --  Check for case of converting to a type that has an invariant\n+      --  associated with it. This required an invariant check. We convert\n+\n+      --    typ (expr)\n+\n+      --  into\n+\n+      --    do invariant_check (typ (expr)) in typ (expr);\n+\n+      --  using Duplicate_Subexpr to avoid multiple side effects\n+\n+      --  Note: the Comes_From_Source check, and then the resetting of this\n+      --  flag prevents what would otherwise be an infinite recursion.\n+\n+      if Present (Invariant_Procedure (Target_Type))\n+        and then Comes_From_Source (N)\n+      then\n+         Set_Comes_From_Source (N, False);\n+         Rewrite (N,\n+           Make_Expression_With_Actions (Loc,\n+             Actions    => New_List (\n+               Make_Invariant_Call (Duplicate_Subexpr (N))),\n+             Expression => Duplicate_Subexpr_No_Checks (N)));\n+         Analyze_And_Resolve (N, Target_Type);\n+         goto Done;\n       end if;\n \n       --  Here if we may need to expand conversion\n@@ -8227,7 +8259,7 @@ package body Exp_Ch4 is\n                 Expression   => Opnd));\n \n             Analyze_And_Resolve (N, Target_Type);\n-            return;\n+            goto Done;\n          end;\n       end if;\n \n@@ -8300,7 +8332,7 @@ package body Exp_Ch4 is\n                       Type_Access_Level (Target_Type)\n          then\n             Raise_Accessibility_Error;\n-            return;\n+            goto Done;\n          end if;\n       end if;\n \n@@ -8328,7 +8360,7 @@ package body Exp_Ch4 is\n          --  Sem_Ch8, and the expansion can interfere with this error check.\n \n          if Is_Access_Type (Target_Type) and then Is_Renamed_Object (N) then\n-            return;\n+            goto Done;\n          end if;\n \n          --  Otherwise, proceed with processing tagged conversion\n@@ -8410,7 +8442,7 @@ package body Exp_Ch4 is\n \n             if Is_Interface (Actual_Op_Typ) then\n                Expand_Interface_Conversion (N, Is_Static => False);\n-               return;\n+               goto Done;\n             end if;\n \n             if not Tag_Checks_Suppressed (Actual_Targ_Typ) then\n@@ -8764,8 +8796,13 @@ package body Exp_Ch4 is\n         and then (Vax_Float (Operand_Type) or else Vax_Float (Target_Type))\n       then\n          Expand_Vax_Conversion (N);\n-         return;\n+         goto Done;\n       end if;\n+\n+      --  Here at end of processing\n+\n+      <<Done>>\n+         null;\n    end Expand_N_Type_Conversion;\n \n    -----------------------------------"}, {"sha": "af1cfc45b4dcd0566f03923d66259ccae9526bc4", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=e606088aa9a3e732484cf7b701dc1e59e3bd9f69", "patch": "@@ -45,6 +45,7 @@ with Sem;      use Sem;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Eval; use Sem_Eval;\n+with Sem_Prag; use Sem_Prag;\n with Sem_Res;  use Sem_Res;\n with Sem_Type; use Sem_Type;\n with Sem_Util; use Sem_Util;\n@@ -3987,6 +3988,31 @@ package body Exp_Util is\n       return Equiv_Type;\n    end Make_CW_Equivalent_Type;\n \n+   -------------------------\n+   -- Make_Invariant_Call --\n+   -------------------------\n+\n+   function Make_Invariant_Call (Expr : Node_Id) return Node_Id is\n+      Loc : constant Source_Ptr := Sloc (Expr);\n+      Typ : constant Entity_Id  := Etype (Expr);\n+\n+   begin\n+      if Check_Enabled (Name_Invariant)\n+           or else\n+         Check_Enabled (Name_Assertion)\n+      then\n+         return\n+           Make_Procedure_Call_Statement (Loc,\n+             Name                   =>\n+               New_Occurrence_Of (Invariant_Procedure (Typ), Loc),\n+             Parameter_Associations => New_List (Relocate_Node (Expr)));\n+\n+      else\n+         return\n+           Make_Null_Statement (Loc);\n+      end if;\n+   end Make_Invariant_Call;\n+\n    ------------------------\n    -- Make_Literal_Range --\n    ------------------------"}, {"sha": "405d1fa1db1987bda30df31a9e104e28c5b6121d", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=e606088aa9a3e732484cf7b701dc1e59e3bd9f69", "patch": "@@ -562,6 +562,12 @@ package Exp_Util is\n    --  and returns True if so. Returns False otherwise. It is an error to call\n    --  this function if N is not of an access type.\n \n+   function Make_Invariant_Call (Expr : Node_Id) return Node_Id;\n+   --  Expr is an object of a type which Has_Invariants set (and which thus\n+   --  also has an Invariant_Procedure set). If invariants are enabled, this\n+   --  function returns a call to the Invariant procedure passing Expr as the\n+   --  argument.\n+\n    function Make_Subtype_From_Expr\n      (E       : Node_Id;\n       Unc_Typ : Entity_Id) return Node_Id;"}, {"sha": "91247c8a15112a3d55eec5b12035ee54eded1720", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=e606088aa9a3e732484cf7b701dc1e59e3bd9f69", "patch": "@@ -739,10 +739,10 @@ package Opt is\n    --  Set to True to skip compile and bind steps (except when Bind_Only is\n    --  set to True).\n \n-   List_Inherited_Pre_Post : Boolean := True;\n+   List_Inherited_Aspects : Boolean := True;\n    --  GNAT\n-   --  List inherited preconditions and postconditions from Pre'Class and\n-   --  Post'Class aspects for ancestor subprograms.\n+   --  List inherited invariants, preconditions, and postconditions from\n+   --  Invariant'Class, Pre'Class, and Post'Class aspects.\n \n    List_Restrictions : Boolean := False;\n    --  GNATBIND"}, {"sha": "a6f382649c065332c3c253c604302f1c82d813ee", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=e606088aa9a3e732484cf7b701dc1e59e3bd9f69", "patch": "@@ -1172,6 +1172,7 @@ begin\n            Pragma_Interrupt_Handler             |\n            Pragma_Interrupt_State               |\n            Pragma_Interrupt_Priority            |\n+           Pragma_Invariant                     |\n            Pragma_Java_Constructor              |\n            Pragma_Java_Interface                |\n            Pragma_Keep_Names                    |"}, {"sha": "fcef81dc113751c67dbb171fc7227eca7ecdf25c", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 370, "deletions": 9, "changes": 379, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=e606088aa9a3e732484cf7b701dc1e59e3bd9f69", "patch": "@@ -54,6 +54,7 @@ with Sinput;   use Sinput;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Sinfo;    use Sinfo;\n+with Stringt;  use Stringt;\n with Targparm; use Targparm;\n with Ttypes;   use Ttypes;\n with Tbuild;   use Tbuild;\n@@ -740,9 +741,9 @@ package body Sem_Ch13 is\n                when No_Aspect =>\n                   raise Program_Error;\n \n-                  --  Aspects taking an optional boolean argument. For all of\n-                  --  these we just create a matching pragma and insert it,\n-                  --  setting flag Cancel_Aspect if the expression is False.\n+               --  Aspects taking an optional boolean argument. For all of\n+               --  these we just create a matching pragma and insert it,\n+               --  setting flag Cancel_Aspect if the expression is False.\n \n                when Aspect_Ada_2005                     |\n                     Aspect_Ada_2012                     |\n@@ -803,8 +804,7 @@ package body Sem_Ch13 is\n                      end if;\n                   end if;\n \n-               --  Aspects corresponding to attribute definition clauses with\n-               --  the exception of Address which is treated specially.\n+               --  Aspects corresponding to attribute definition clauses\n \n                when Aspect_Address        |\n                     Aspect_Alignment      |\n@@ -924,7 +924,8 @@ package body Sem_Ch13 is\n                --  with a first argument that is the expression, and a second\n                --  argument that is an informative message if the test fails.\n                --  This is inserted right after the declaration, to get the\n-               --  required pragma placement.\n+               --  required pragma placement. The processing for the pragmas\n+               --  takes care of the required delay.\n \n                when Aspect_Pre | Aspect_Post => declare\n                   Pname : Name_Id;\n@@ -1007,11 +1008,48 @@ package body Sem_Ch13 is\n                   goto Continue;\n                end;\n \n-                  --  Aspects currently unimplemented\n+               --  Invariant aspect generates an Invariant pragma with a first\n+               --  argument that is the entity, and the second argument is the\n+               --  expression. This is inserted right after the declaration, to\n+               --  get the required pragma placement. The processing for the\n+               --  pragma takes care of the required delay.\n \n-               when Aspect_Invariant |\n-                    Aspect_Predicate =>\n+               when Aspect_Invariant =>\n \n+                  --  Construct the pragma\n+\n+                  Aitem :=\n+                    Make_Pragma (Loc,\n+                      Pragma_Argument_Associations =>\n+                        New_List (Ent, Relocate_Node (Expr)),\n+                      Class_Present                => Class_Present (Aspect),\n+                      Pragma_Identifier            =>\n+                        Make_Identifier (Sloc (Id), Name_Invariant));\n+\n+                  --  Add message unless exception messages are suppressed\n+\n+                  if not Opt.Exception_Locations_Suppressed then\n+                     Append_To (Pragma_Argument_Associations (Aitem),\n+                       Make_Pragma_Argument_Association (Eloc,\n+                         Chars     => Name_Message,\n+                         Expression =>\n+                           Make_String_Literal (Eloc,\n+                             Strval => \"failed invariant from \"\n+                                       & Build_Location_String (Eloc))));\n+                  end if;\n+\n+                  Set_From_Aspect_Specification (Aitem, True);\n+\n+                  --  For Invariant case, insert immediately after the entity\n+                  --  declaration. We do not have to worry about delay issues\n+                  --  since the pragma processing takes care of this.\n+\n+                  Insert_After (N, Aitem);\n+                  goto Continue;\n+\n+               --  Aspects currently unimplemented\n+\n+               when Aspect_Predicate =>\n                   Error_Msg_N (\"aspect& not implemented\", Identifier (Aspect));\n                   goto Continue;\n             end case;\n@@ -3393,6 +3431,329 @@ package body Sem_Ch13 is\n       end if;\n    end Analyze_Record_Representation_Clause;\n \n+   -------------------------------\n+   -- Build_Invariant_Procedure --\n+   -------------------------------\n+\n+   --  The procedure that is constructed here has the form\n+\n+   --  procedure typInvariant (Ixxx : typ) is\n+   --  begin\n+   --     pragma Check (Invariant, exp, \"failed invariant from xxx\");\n+   --     pragma Check (Invariant, exp, \"failed invariant from xxx\");\n+   --     ...\n+   --     pragma Check (Invariant, exp, \"failed inherited invariant from xxx\");\n+   --     ...\n+   --  end typInvariant;\n+\n+   procedure Build_Invariant_Procedure\n+     (Typ   : Entity_Id;\n+      PDecl : out Node_Id;\n+      PBody : out Node_Id)\n+   is\n+      Loc   : constant Source_Ptr := Sloc (Typ);\n+      Stmts : List_Id;\n+      Spec  : Node_Id;\n+      SId   : Entity_Id;\n+\n+      procedure Add_Invariants (T : Entity_Id; Inherit : Boolean);\n+      --  Appends statements to Stmts for any invariants in the rep item chain\n+      --  of the given type. If Inherit is False, then we only process entries\n+      --  on the chain for the type Typ. If Inherit is True, then we ignore any\n+      --  Invariant aspects, but we process all Invariant'Class aspects, adding\n+      --  \"inherited\" to the exception message and generating an informational\n+      --  message about the inheritance of an invariant.\n+\n+      Object_Name : constant Name_Id := New_Internal_Name ('I');\n+      --  Name for argument of invariant procedure\n+\n+      --------------------\n+      -- Add_Invariants --\n+      --------------------\n+\n+      procedure Add_Invariants (T : Entity_Id; Inherit : Boolean) is\n+         Ritem : Node_Id;\n+         Arg1  : Node_Id;\n+         Arg2  : Node_Id;\n+         Arg3  : Node_Id;\n+         Exp   : Node_Id;\n+         Loc   : Source_Ptr;\n+         Assoc : List_Id;\n+         Str   : String_Id;\n+\n+         function Replace_Node (N : Node_Id) return Traverse_Result;\n+         --  Process single node for traversal to replace type references\n+\n+         procedure Replace_Type is new Traverse_Proc (Replace_Node);\n+         --  Traverse an expression changing every occurrence of an entity\n+         --  reference to type T with a reference to the object argument.\n+\n+         ------------------\n+         -- Replace_Node --\n+         ------------------\n+\n+         function Replace_Node (N : Node_Id) return Traverse_Result is\n+         begin\n+            --  Case of entity name referencing the type\n+\n+            if Is_Entity_Name (N)\n+              and then Entity (N) = T\n+            then\n+               --  Invariant'Class, replace with T'Class (obj)\n+\n+               if Class_Present (Ritem) then\n+                  Rewrite (N,\n+                    Make_Type_Conversion (Loc,\n+                      Subtype_Mark =>\n+                        Make_Attribute_Reference (Loc,\n+                          Prefix         =>\n+                            New_Occurrence_Of (T, Loc),\n+                          Attribute_Name => Name_Class),\n+                      Expression =>\n+                        Make_Identifier (Loc,\n+                          Chars => Object_Name)));\n+\n+               --  Invariant, replace with obj\n+\n+               else\n+                  Rewrite (N,\n+                    Make_Identifier (Loc,\n+                      Chars => Object_Name));\n+               end if;\n+\n+               --  All done with this node\n+\n+               return Skip;\n+\n+            --  Not an instance of the type entity, keep going\n+\n+            else\n+               return OK;\n+            end if;\n+         end Replace_Node;\n+\n+      --  Start of processing for Add_Invariants\n+\n+      begin\n+         Ritem := First_Rep_Item (T);\n+         while Present (Ritem) loop\n+            if Nkind (Ritem) = N_Pragma\n+              and then Pragma_Name (Ritem) = Name_Invariant\n+            then\n+               Arg1 := First (Pragma_Argument_Associations (Ritem));\n+               Arg2 := Next (Arg1);\n+               Arg3 := Next (Arg2);\n+\n+               Arg1 := Get_Pragma_Arg (Arg1);\n+               Arg2 := Get_Pragma_Arg (Arg2);\n+\n+               --  For Inherit case, ignore Invariant, process only Class case\n+\n+               if Inherit then\n+                  if not Class_Present (Ritem) then\n+                     goto Continue;\n+                  end if;\n+\n+               --  For Inherit false, process only item for right type\n+\n+               else\n+                  if Entity (Arg1) /= Typ then\n+                     goto Continue;\n+                  end if;\n+               end if;\n+\n+               if No (Stmts) then\n+                  Stmts := Empty_List;\n+               end if;\n+\n+               Exp := New_Copy_Tree (Arg2);\n+               Loc := Sloc (Exp);\n+\n+               --  We need to replace any occurrences of the name of the type\n+               --  with references to the object, converted to type'Class in\n+               --  the case of Invariant'Class aspects. We do this by first\n+               --  doing a preanalysis, to identify all the entities, then\n+               --  we traverse looking for the type entity, and doing the\n+               --  necessary substitution. The preanalysis is done with the\n+               --  special OK_To_Reference flag set on the type, so that if\n+               --  we get an occurrence of this type, it will be reognized\n+               --  as legitimate.\n+\n+               Set_OK_To_Reference (T, True);\n+               Preanalyze_Spec_Expression (Exp, Standard_Boolean);\n+               Set_OK_To_Reference (T, False);\n+\n+               --  Do the traversal\n+\n+               Replace_Type (Exp);\n+\n+               --  Build first two arguments for Check pragma\n+\n+               Assoc := New_List (\n+                 Make_Pragma_Argument_Association (Loc,\n+                    Expression =>\n+                      Make_Identifier (Loc,\n+                        Chars => Name_Invariant)),\n+                  Make_Pragma_Argument_Association (Loc,\n+                    Expression => Exp));\n+\n+               --  Add message if present in Invariant pragma\n+\n+               if Present (Arg3) then\n+                  Str := Strval (Get_Pragma_Arg (Arg3));\n+\n+                  --  If inherited case, and message starts \"failed invariant\",\n+                  --  change it to be \"failed inherited invariant\".\n+\n+                  if Inherit then\n+                     String_To_Name_Buffer (Str);\n+\n+                     if Name_Buffer (1 .. 16) = \"failed invariant\" then\n+                        Insert_Str_In_Name_Buffer (\"inherited \", 8);\n+                        Str := String_From_Name_Buffer;\n+                     end if;\n+                  end if;\n+\n+                  Append_To (Assoc,\n+                    Make_Pragma_Argument_Association (Loc,\n+                      Expression => Make_String_Literal (Loc, Str)));\n+               end if;\n+\n+               --  Add Check pragma to list of statements\n+\n+               Append_To (Stmts,\n+                 Make_Pragma (Loc,\n+                   Pragma_Identifier            =>\n+                     Make_Identifier (Loc,\n+                       Chars => Name_Check),\n+                   Pragma_Argument_Associations => Assoc));\n+\n+               --  If Inherited case and option enabled, output info msg. Note\n+               --  that we know this is a case of Invariant'Class.\n+\n+               if Inherit and Opt.List_Inherited_Aspects then\n+                  Error_Msg_Sloc := Sloc (Ritem);\n+                  Error_Msg_N\n+                    (\"?info: & inherits `Invariant''Class` aspect from #\",\n+                     Typ);\n+               end if;\n+            end if;\n+\n+         <<Continue>>\n+            Next_Rep_Item (Ritem);\n+         end loop;\n+      end Add_Invariants;\n+\n+   --  Start of processing for Build_Invariant_Procedure\n+\n+   begin\n+      Stmts := No_List;\n+      PDecl := Empty;\n+      PBody := Empty;\n+\n+      --  Add invariants for the current type\n+\n+      Add_Invariants (Typ, Inherit => False);\n+\n+      --  Add invariants for parent types\n+\n+      declare\n+         Current_Typ : Entity_Id;\n+         Parent_Typ  : Entity_Id;\n+\n+      begin\n+         Current_Typ := Typ;\n+         loop\n+            Parent_Typ := Etype (Current_Typ);\n+\n+            if Is_Private_Type (Parent_Typ)\n+              and then Present (Full_View (Base_Type (Parent_Typ)))\n+            then\n+               Parent_Typ := Full_View (Base_Type (Parent_Typ));\n+            end if;\n+\n+            exit when Parent_Typ = Current_Typ;\n+\n+            Current_Typ := Parent_Typ;\n+            Add_Invariants (Current_Typ, Inherit => True);\n+         end loop;\n+      end;\n+\n+      --  Add invariants for inherited interfaces\n+      --  (commented out because it blows up on simpleinv in J701-022)\n+\n+--        declare\n+--           Ifaces : Elist_Id;\n+--           Iface  : Elmt_Id;\n+--\n+--        begin\n+--           Collect_Interfaces\n+--             (T               => Typ,\n+--              Ifaces_List     => Ifaces,\n+--              Exclude_Parents => True,\n+--              Use_Full_View   => True);\n+--\n+--           loop\n+--              Iface := First_Elmt (Ifaces);\n+--              exit when Iface = No_Elmt;\n+--              Add_Invariants (Node (Iface), Inherit => True);\n+--              Remove_Elmt (Ifaces, Iface);\n+--           end loop;\n+--        end;\n+\n+      --  Build the procedure if we generated at least one Check pragma\n+\n+      if Stmts /= No_List then\n+\n+         --  Build procedure declaration\n+\n+         SId :=\n+           Make_Defining_Identifier (Loc,\n+             Chars => New_External_Name (Chars (Typ), \"Invariant\"));\n+         Set_Invariant_Procedure (Typ, SId);\n+\n+         Spec :=\n+           Make_Procedure_Specification (Loc,\n+             Defining_Unit_Name       => SId,\n+             Parameter_Specifications => New_List (\n+               Make_Parameter_Specification (Loc,\n+                 Defining_Identifier =>\n+                   Make_Defining_Identifier (Loc,\n+                     Chars => Object_Name),\n+                 Parameter_Type =>\n+                   New_Occurrence_Of (Typ, Loc))));\n+\n+         PDecl :=\n+           Make_Subprogram_Declaration (Loc,\n+             Specification => Spec);\n+\n+         --  Build procedure body\n+\n+         SId :=\n+           Make_Defining_Identifier (Loc,\n+             Chars => New_External_Name (Chars (Typ), \"Invariant\"));\n+\n+         Spec :=\n+           Make_Procedure_Specification (Loc,\n+             Defining_Unit_Name       => SId,\n+             Parameter_Specifications => New_List (\n+               Make_Parameter_Specification (Loc,\n+                 Defining_Identifier =>\n+                   Make_Defining_Identifier (Loc,\n+                     Chars => Object_Name),\n+                 Parameter_Type =>\n+                   New_Occurrence_Of (Typ, Loc))));\n+\n+         PBody :=\n+           Make_Subprogram_Body (Loc,\n+             Specification              => Spec,\n+             Declarations               => Empty_List,\n+             Handled_Statement_Sequence =>\n+               Make_Handled_Sequence_Of_Statements (Loc,\n+                 Statements => Stmts));\n+      end if;\n+   end Build_Invariant_Procedure;\n+\n    -----------------------------------\n    -- Check_Constant_Address_Clause --\n    -----------------------------------"}, {"sha": "85a9085518ea457748204b601c0385d077f9c05d", "filename": "gcc/ada/sem_ch13.ads", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Fsem_ch13.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Fsem_ch13.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.ads?ref=e606088aa9a3e732484cf7b701dc1e59e3bd9f69", "patch": "@@ -52,6 +52,17 @@ package Sem_Ch13 is\n    --  order is specified and there is at least one component clause. Adjusts\n    --  component positions according to either Ada 95 or Ada 2005 (AI-133).\n \n+   procedure Build_Invariant_Procedure\n+     (Typ   : Entity_Id;\n+      PDecl : out Node_Id;\n+      PBody : out Node_Id);\n+   --  If Typ has Invariants (indicated by Has_Invariants being set for Typ,\n+   --  indicating the presence of Pragma Invariant entries on the rep chain,\n+   --  note that Invariant aspects are converted to pragma Invariant), then\n+   --  this procedure builds the spec and body for the corresponding Invariant\n+   --  procedure, returning themn in PDecl and PBody. In some error situations\n+   --  no procedure is built, in which case PDecl/PBody are empty on return.\n+\n    procedure Check_Record_Representation_Clause (N : Node_Id);\n    --  This procedure completes the analysis of a record representation clause\n    --  N. It is called at freeze time after adjustment of component clause bit"}, {"sha": "92f1333bcaa974026918bb342901b3b794e9ba43", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 76, "deletions": 5, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=e606088aa9a3e732484cf7b701dc1e59e3bd9f69", "patch": "@@ -3592,6 +3592,8 @@ package body Sem_Ch3 is\n \n       Generate_Definition (T);\n \n+      --  For other than Ada 2012, just enter the name in the current scope\n+\n       if Ada_Version < Ada_2012 then\n          Enter_Name (T);\n \n@@ -7657,6 +7659,15 @@ package body Sem_Ch3 is\n       Set_Is_Controlled  (Derived_Type, Is_Controlled  (Parent_Type));\n       Set_Is_Tagged_Type (Derived_Type, Is_Tagged_Type (Parent_Type));\n \n+      --  Propagate invariant information. The new type has invariants if\n+      --  they are inherited from the parent type, and these invariants can\n+      --  be further inherited, so both flags are set.\n+\n+      if Has_Inheritable_Invariants (Parent_Type) then\n+         Set_Has_Inheritable_Invariants (Derived_Type);\n+         Set_Has_Invariants (Derived_Type);\n+      end if;\n+\n       --  The derived type inherits the representation clauses of the parent.\n       --  However, for a private type that is completed by a derivation, there\n       --  may be operation attributes that have been specified already (stream\n@@ -14171,8 +14182,8 @@ package body Sem_Ch3 is\n \n          elsif Ekind (Prev) = E_Incomplete_Type\n            and then (Ada_Version < Ada_2012\n-                       or else No (Full_View (Prev))\n-                       or else not Is_Private_Type (Full_View (Prev)))\n+                      or else No (Full_View (Prev))\n+                      or else not Is_Private_Type (Full_View (Prev)))\n          then\n \n             --  Indicate that the incomplete declaration has a matching full\n@@ -16038,14 +16049,16 @@ package body Sem_Ch3 is\n          --  A return statement for a build-in-place function returning a\n          --  synchronized type also introduces an unchecked conversion.\n \n-         when N_Type_Conversion | N_Unchecked_Type_Conversion =>\n+         when N_Type_Conversion           |\n+              N_Unchecked_Type_Conversion =>\n             return not Comes_From_Source (Exp)\n               and then\n                 OK_For_Limited_Init_In_05\n                   (Typ, Expression (Original_Node (Exp)));\n \n-         when N_Indexed_Component | N_Selected_Component |\n-               N_Explicit_Dereference  =>\n+         when N_Indexed_Component     |\n+              N_Selected_Component    |\n+              N_Explicit_Dereference  =>\n             return Nkind (Exp) = N_Function_Call;\n \n          --  A use of 'Input is a function call, hence allowed. Normally the\n@@ -17106,18 +17119,76 @@ package body Sem_Ch3 is\n       --  If the private view has user specified stream attributes, then so has\n       --  the full view.\n \n+      --  Why the test, how could these flags be already set in Full_T ???\n+\n       if Has_Specified_Stream_Read (Priv_T) then\n          Set_Has_Specified_Stream_Read (Full_T);\n       end if;\n+\n       if Has_Specified_Stream_Write (Priv_T) then\n          Set_Has_Specified_Stream_Write (Full_T);\n       end if;\n+\n       if Has_Specified_Stream_Input (Priv_T) then\n          Set_Has_Specified_Stream_Input (Full_T);\n       end if;\n+\n       if Has_Specified_Stream_Output (Priv_T) then\n          Set_Has_Specified_Stream_Output (Full_T);\n       end if;\n+\n+      --  Deal with invariants\n+\n+      if Has_Invariants (Full_T)\n+           or else\n+         Has_Invariants (Priv_T)\n+      then\n+         Set_Has_Invariants (Full_T);\n+         Set_Has_Invariants (Priv_T);\n+      end if;\n+\n+      if Has_Inheritable_Invariants (Full_T)\n+           or else\n+         Has_Inheritable_Invariants (Priv_T)\n+      then\n+         Set_Has_Inheritable_Invariants (Full_T);\n+         Set_Has_Inheritable_Invariants (Priv_T);\n+      end if;\n+\n+      --  This is where we build the invariant procedure if needed\n+\n+      if Has_Invariants (Priv_T) then\n+         declare\n+            PDecl : Entity_Id;\n+            PBody : Entity_Id;\n+            Packg : constant Node_Id := Declaration_Node (Scope (Priv_T));\n+\n+         begin\n+            Build_Invariant_Procedure (Full_T, PDecl, PBody);\n+\n+            --  Error defense, normally these should be set\n+\n+            if Present (PDecl) and then Present (PBody) then\n+\n+               --  Spec goes at the end of the public part of the package.\n+               --  That's behind us, so we have to manually analyze the\n+               --  inserted spec.\n+\n+               Append_To (Visible_Declarations (Packg), PDecl);\n+               Analyze (PDecl);\n+\n+               --  Body goes at the end of the private part of the package.\n+               --  That's ahead of us so it will get analyzed later on when\n+               --  we come to it.\n+\n+               Append_To (Private_Declarations (Packg), PBody);\n+\n+               --  Copy Invariant procedure to private declaration\n+\n+               Set_Invariant_Procedure (Priv_T, Invariant_Procedure (Full_T));\n+            end if;\n+         end;\n+      end if;\n    end Process_Full_View;\n \n    -----------------------------------"}, {"sha": "4fb85b60406f06d0311a9ac245a760c212272f59", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 129, "deletions": 36, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=e606088aa9a3e732484cf7b701dc1e59e3bd9f69", "patch": "@@ -207,7 +207,8 @@ package body Sem_Ch6 is\n    --  conditions for the body and assembling and inserting the _postconditions\n    --  procedure. N is the node for the subprogram body and Body_Id/Spec_Id are\n    --  the entities for the body and separate spec (if there is no separate\n-   --  spec, Spec_Id is Empty).\n+   --  spec, Spec_Id is Empty). Note that invariants also provide a source\n+   --  of postconditions, which are also handled in this procedure.\n \n    procedure Set_Formal_Validity (Formal_Id : Entity_Id);\n    --  Formal_Id is an formal parameter entity. This procedure deals with\n@@ -2940,7 +2941,6 @@ package body Sem_Ch6 is\n       if Nkind (N) = N_Function_Specification then\n          Set_Ekind (Designator, E_Function);\n          Set_Mechanism (Designator, Default_Mechanism);\n-\n       else\n          Set_Ekind (Designator, E_Procedure);\n          Set_Etype (Designator, Standard_Void_Type);\n@@ -3011,13 +3011,16 @@ package body Sem_Ch6 is\n \n       elsif Nkind (N) = N_Function_Specification then\n          Push_Scope (Designator);\n-\n          Analyze_Return_Type (N);\n-\n          End_Scope;\n       end if;\n \n+      --  Function case\n+\n       if Nkind (N) = N_Function_Specification then\n+\n+         --  Deal with operator symbol case\n+\n          if Nkind (Designator) = N_Defining_Operator_Symbol then\n             Valid_Operator_Definition (Designator);\n          end if;\n@@ -3041,7 +3044,7 @@ package body Sem_Ch6 is\n                Error_Msg_N\n                  (\"function that returns abstract type must be abstract\", N);\n \n-            --  Ada 2012 (AI-0073): extend this test to subprograms with an\n+            --  Ada 2012 (AI-0073): Extend this test to subprograms with an\n             --  access result whose designated type is abstract.\n \n             elsif Nkind (Result_Definition (N)) = N_Access_Definition\n@@ -6944,7 +6947,7 @@ package body Sem_Ch6 is\n \n    procedure List_Inherited_Pre_Post_Aspects (E : Entity_Id) is\n    begin\n-      if Opt.List_Inherited_Pre_Post\n+      if Opt.List_Inherited_Aspects\n         and then (Is_Subprogram (E) or else Is_Generic_Subprogram (E))\n       then\n          declare\n@@ -8621,9 +8624,11 @@ package body Sem_Ch6 is\n    is\n       Loc   : constant Source_Ptr := Sloc (N);\n       Prag  : Node_Id;\n-      Subp  : Entity_Id;\n       Parms : List_Id;\n \n+      Designator : Entity_Id;\n+      --  Subprogram designator, set from Spec_Id if present, else Body_Id\n+\n       Precond : Node_Id := Empty;\n       --  Set non-Empty if we prepend precondition to the declarations. This\n       --  is used to hook up inherited preconditions (adding the condition\n@@ -8633,8 +8638,8 @@ package body Sem_Ch6 is\n       --  Precondition inherited from parent subprogram\n \n       Inherited : constant Subprogram_List :=\n-                    Inherited_Subprograms (Spec_Id);\n-      --  List of subprograms inherited by this subprogram, null if no Spec_Id\n+                     Inherited_Subprograms (Spec_Id);\n+      --  List of subprograms inherited by this subprogram\n \n       Plist : List_Id := No_List;\n       --  List of generated postconditions\n@@ -8647,6 +8652,10 @@ package body Sem_Ch6 is\n       --  references to parameters of the inherited subprogram to point to the\n       --  corresponding parameters of the current subprogram.\n \n+      function Invariants_Present return Boolean;\n+      --  Determines if any invariants are present for any OUT or IN OUT\n+      --  parameters of the subprogram, or (for a function) for the return.\n+\n       --------------\n       -- Grab_PPC --\n       --------------\n@@ -8672,7 +8681,7 @@ package body Sem_Ch6 is\n             begin\n                Map := New_Elmt_List;\n                PF := First_Formal (Pspec);\n-               CF := First_Formal (Spec_Id);\n+               CF := First_Formal (Designator);\n                while Present (PF) loop\n                   Append_Elmt (PF, Map);\n                   Append_Elmt (CF, Map);\n@@ -8744,9 +8753,49 @@ package body Sem_Ch6 is\n          return CP;\n       end Grab_PPC;\n \n+      ------------------------\n+      -- Invariants_Present --\n+      ------------------------\n+\n+      function Invariants_Present return Boolean is\n+         Formal     : Entity_Id;\n+\n+      begin\n+         --  Check function return result\n+\n+         if Ekind (Designator) /= E_Procedure\n+           and then Has_Invariants (Etype (Designator))\n+         then\n+            return True;\n+         end if;\n+\n+         --  Check parameters\n+\n+         Formal := First_Formal (Designator);\n+         while Present (Formal) loop\n+            if Ekind (Formal) /= E_In_Parameter\n+              and then Has_Invariants (Etype (Formal))\n+            then\n+               return True;\n+            end if;\n+\n+            Next_Formal (Formal);\n+         end loop;\n+\n+         return False;\n+      end Invariants_Present;\n+\n    --  Start of processing for Process_PPCs\n \n    begin\n+      --  Capture designator from spec if present, else from body\n+\n+      if Present (Spec_Id) then\n+         Designator := Spec_Id;\n+      else\n+         Designator := Body_Id;\n+      end if;\n+\n       --  Grab preconditions from spec\n \n       if Present (Spec_Id) then\n@@ -8882,6 +8931,9 @@ package body Sem_Ch6 is\n       --        pragma Check (Postcondition, condition [,message]);\n       --        pragma Check (Postcondition, condition [,message]);\n       --        ...\n+      --        Invariant_Procedure (_Result) ...\n+      --        Invariant_Procedure (Arg1)\n+      --        ...\n       --     end;\n \n       --  First we deal with the postconditions in the body\n@@ -8933,7 +8985,7 @@ package body Sem_Ch6 is\n       --  Now deal with any postconditions from the spec\n \n       if Present (Spec_Id) then\n-         declare\n+         Spec_Postconditions : declare\n             procedure Process_Post_Conditions\n               (Spec  : Node_Id;\n                Class : Boolean);\n@@ -8983,6 +9035,8 @@ package body Sem_Ch6 is\n                end loop;\n             end Process_Post_Conditions;\n \n+         --  Start of processing for Spec_Postconditions\n+\n          begin\n             if Present (Spec_PPC_List (Spec_Id)) then\n                Process_Post_Conditions (Spec_Id, Class => False);\n@@ -8995,32 +9049,79 @@ package body Sem_Ch6 is\n                   Process_Post_Conditions (Inherited (J), Class => True);\n                end if;\n             end loop;\n-         end;\n+         end Spec_Postconditions;\n       end if;\n \n-      --  If we had any postconditions and expansion is enabled, build\n-      --  the _Postconditions procedure.\n+      --  If we had any postconditions and expansion is enabled, or if the\n+      --  procedure has invariants, then build the _Postconditions procedure.\n \n-      if Present (Plist)\n+      if (Present (Plist) or else Invariants_Present)\n         and then Expander_Active\n       then\n-         Subp := Defining_Entity (N);\n+         if No (Plist) then\n+            Plist := Empty_List;\n+         end if;\n+\n+         --  Special processing for function case\n+\n+         if Ekind (Designator) /= E_Procedure then\n+            declare\n+               Rent : constant Entity_Id :=\n+                        Make_Defining_Identifier (Loc,\n+                          Chars => Name_uResult);\n+               Ftyp : constant Entity_Id := Etype (Designator);\n+\n+            begin\n+               Set_Etype (Rent, Ftyp);\n+\n+               --  Add argument for return\n+\n+               Parms :=\n+                 New_List (\n+                   Make_Parameter_Specification (Loc,\n+                     Parameter_Type      => New_Occurrence_Of (Ftyp, Loc),\n+                     Defining_Identifier => Rent));\n+\n+               --  Add invariant call if returning type with invariants\n+\n+               if Present (Invariant_Procedure (Etype (Rent))) then\n+                  Append_To (Plist,\n+                    Make_Invariant_Call (New_Occurrence_Of (Rent, Loc)));\n+               end if;\n+            end;\n+\n+         --  Procedure rather than a function\n \n-         if Etype (Subp) /= Standard_Void_Type then\n-            Parms := New_List (\n-              Make_Parameter_Specification (Loc,\n-                Defining_Identifier =>\n-                  Make_Defining_Identifier (Loc,\n-                    Chars => Name_uResult),\n-                Parameter_Type => New_Occurrence_Of (Etype (Subp), Loc)));\n          else\n             Parms := No_List;\n          end if;\n \n+         --  Add invariant calls for parameters. Note that this is done for\n+         --  functions as well, since in Ada 2012 they can have IN OUT args.\n+\n+         declare\n+            Formal : Entity_Id;\n+\n+         begin\n+            Formal := First_Formal (Designator);\n+            while Present (Formal) loop\n+               if Ekind (Formal) /= E_In_Parameter\n+                 and then Present (Invariant_Procedure (Etype (Formal)))\n+               then\n+                  Append_To (Plist,\n+                    Make_Invariant_Call (New_Occurrence_Of (Formal, Loc)));\n+               end if;\n+\n+               Next_Formal (Formal);\n+            end loop;\n+         end;\n+\n+         --  Build and insert postcondition procedure\n+\n          declare\n             Post_Proc : constant Entity_Id :=\n-                   Make_Defining_Identifier (Loc,\n-                     Chars => Name_uPostconditions);\n+                          Make_Defining_Identifier (Loc,\n+                            Chars => Name_uPostconditions);\n             --  The entity for the _Postconditions procedure\n \n          begin\n@@ -9040,20 +9141,12 @@ package body Sem_Ch6 is\n             --  If this is a procedure, set the Postcondition_Proc attribute on\n             --  the proper defining entity for the subprogram.\n \n-            if Etype (Subp) = Standard_Void_Type then\n-               if Present (Spec_Id) then\n-                  Set_Postcondition_Proc (Spec_Id, Post_Proc);\n-               else\n-                  Set_Postcondition_Proc (Body_Id, Post_Proc);\n-               end if;\n+            if Ekind (Designator) = E_Procedure then\n+               Set_Postcondition_Proc (Designator, Post_Proc);\n             end if;\n          end;\n \n-         if Present (Spec_Id) then\n-            Set_Has_Postconditions (Spec_Id);\n-         else\n-            Set_Has_Postconditions (Body_Id);\n-         end if;\n+         Set_Has_Postconditions (Designator);\n       end if;\n    end Process_PPCs;\n "}, {"sha": "9b725581cdb7cd36c76ce35e3c3c183416ceaf0d", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=e606088aa9a3e732484cf7b701dc1e59e3bd9f69", "patch": "@@ -1159,7 +1159,6 @@ package body Sem_Ch7 is\n          declare\n             Orig_Spec : constant Node_Id := Specification (Orig_Decl);\n             Save_Priv : constant List_Id := Private_Declarations (Orig_Spec);\n-\n          begin\n             Set_Private_Declarations (Orig_Spec, Empty_List);\n             Save_Global_References   (Orig_Decl);\n@@ -1919,6 +1918,8 @@ package body Sem_Ch7 is\n \n    procedure New_Private_Type (N : Node_Id; Id : Entity_Id; Def : Node_Id) is\n    begin\n+      --  For other than Ada 2012, enter tha name in the current scope\n+\n       if Ada_Version < Ada_2012 then\n          Enter_Name (Id);\n \n@@ -1928,14 +1929,12 @@ package body Sem_Ch7 is\n       else\n          declare\n             Prev : Entity_Id;\n-\n          begin\n             Prev := Find_Type_Name (N);\n-\n             pragma Assert (Prev = Id\n               or else (Ekind (Prev) = E_Incomplete_Type\n-                         and then Present (Full_View (Prev))\n-                         and then Full_View (Prev) = Id));\n+                        and then Present (Full_View (Prev))\n+                        and then Full_View (Prev) = Id));\n          end;\n       end if;\n "}, {"sha": "54546f04bc31c5fb01b0ce918f93d3bed7cc7385", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 66, "deletions": 1, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=e606088aa9a3e732484cf7b701dc1e59e3bd9f69", "patch": "@@ -7133,8 +7133,11 @@ package body Sem_Prag is\n \n             if Nkind (Expression (Arg1)) = N_Null then\n                Analyze (Expression (Arg1));\n+\n+               --  This is an odd case, this is not really an expression, so\n+               --  we don't have a type for it. So just set the type to Empty.\n+\n                Set_Etype (Expression (Arg1), Empty);\n-               --  It's not really an expression, and we have no type for it\n \n             --  Case of Default_Storage_Pool (storage_pool_NAME);\n \n@@ -9272,6 +9275,67 @@ package body Sem_Prag is\n             end loop;\n          end Interrupt_State;\n \n+         ---------------\n+         -- Invariant --\n+         ---------------\n+\n+         --  pragma Invariant\n+         --    ([Entity =>]    type_LOCAL_NAME,\n+         --     [Check  =>]    EXPRESSION\n+         --     [,[Message =>] String_Expression]);\n+\n+         when Pragma_Invariant => Invariant : declare\n+            Type_Id : Node_Id;\n+            Typ     : Entity_Id;\n+\n+            Discard : Boolean;\n+            pragma Unreferenced (Discard);\n+\n+         begin\n+            GNAT_Pragma;\n+            Check_At_Least_N_Arguments (2);\n+            Check_At_Most_N_Arguments (3);\n+            Check_Optional_Identifier (Arg1, Name_Entity);\n+            Check_Optional_Identifier (Arg2, Name_Check);\n+\n+            if Arg_Count = 3 then\n+               Check_Optional_Identifier (Arg3, Name_Message);\n+               Check_Arg_Is_Static_Expression (Arg3, Standard_String);\n+            end if;\n+\n+            Check_Arg_Is_Local_Name (Arg1);\n+\n+            Type_Id := Get_Pragma_Arg (Arg1);\n+            Find_Type (Type_Id);\n+            Typ := Entity (Type_Id);\n+\n+            if Typ = Any_Type then\n+               return;\n+\n+            elsif not Ekind_In (Typ, E_Private_Type,\n+                                     E_Record_Type_With_Private,\n+                                     E_Limited_Private_Type)\n+            then\n+               Error_Pragma_Arg\n+                 (\"pragma% only allowed for private type\", Arg1);\n+            end if;\n+\n+            --  Note that the type has at least one invariant, and also that\n+            --  it has inheritable invariants if we have Invariant'Class.\n+\n+            Set_Has_Invariants (Typ);\n+\n+            if Class_Present (N) then\n+               Set_Has_Inheritable_Invariants (Typ);\n+            end if;\n+\n+            --  The remaining processing is simply to link the pragma on to\n+            --  the rep item chain, for processing when the type is frozen.\n+            --  This is accomplished by a call to Rep_Item_Too_Late.\n+\n+            Discard := Rep_Item_Too_Late (Typ, N, FOnly => True);\n+         end Invariant;\n+\n          ----------------------\n          -- Java_Constructor --\n          ----------------------\n@@ -13707,6 +13771,7 @@ package body Sem_Prag is\n       Pragma_Interrupt_Handler             => -1,\n       Pragma_Interrupt_Priority            => -1,\n       Pragma_Interrupt_State               => -1,\n+      Pragma_Invariant                     => -1,\n       Pragma_Java_Constructor              => -1,\n       Pragma_Java_Interface                => -1,\n       Pragma_Keep_Names                    =>  0,"}, {"sha": "c05bda9e95074cca78e0bc246b173f4036cc48a6", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=e606088aa9a3e732484cf7b701dc1e59e3bd9f69", "patch": "@@ -5930,16 +5930,28 @@ package body Sem_Res is\n          Set_Entity_With_Style_Check (N, E);\n          Eval_Entity_Name (N);\n \n-      --  Allow use of subtype only if it is a concurrent type where we are\n-      --  currently inside the body. This will eventually be expanded into a\n-      --  call to Self (for tasks) or _object (for protected objects). Any\n-      --  other use of a subtype is invalid.\n+      --  Case of subtype name appearing as an operand in expression\n \n       elsif Is_Type (E) then\n+\n+         --  Allow use of subtype if it is a concurrent type where we are\n+         --  currently inside the body. This will eventually be expanded into a\n+         --  call to Self (for tasks) or _object (for protected objects). Any\n+         --  other use of a subtype is invalid.\n+\n          if Is_Concurrent_Type (E)\n            and then In_Open_Scopes (E)\n          then\n             null;\n+\n+         --  Allow reference to type specifically marked as being OK in this\n+         --  context (this is used for example for type names in invariants).\n+\n+         elsif OK_To_Reference (E) then\n+            null;\n+\n+         --  Any other use is an eror\n+\n          else\n             Error_Msg_N\n                (\"invalid use of subtype mark in expression or call\", N);"}, {"sha": "0bd8b42426173b51fcf9f4e770f6134b3ad63414", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=e606088aa9a3e732484cf7b701dc1e59e3bd9f69", "patch": "@@ -3068,7 +3068,7 @@ package body Sem_Warn is\n             Elab_Warnings                       := True;\n             Implementation_Unit_Warnings        := True;\n             Ineffective_Inline_Warnings         := True;\n-            List_Inherited_Pre_Post             := True;\n+            List_Inherited_Aspects              := True;\n             Warn_On_Ada_2005_Compatibility      := True;\n             Warn_On_Ada_2012_Compatibility      := True;\n             Warn_On_All_Unread_Out_Parameters   := True;\n@@ -3115,10 +3115,10 @@ package body Sem_Warn is\n             Warn_On_Overlap                     := False;\n \n          when 'l' =>\n-            List_Inherited_Pre_Post             := True;\n+            List_Inherited_Aspects              := True;\n \n          when 'L' =>\n-            List_Inherited_Pre_Post             := False;\n+            List_Inherited_Aspects              := False;\n \n          when 'm' =>\n             Warn_On_Suspicious_Modulus_Value    := True;\n@@ -3196,7 +3196,7 @@ package body Sem_Warn is\n       Elab_Warnings                       := False;\n       Implementation_Unit_Warnings        := False;\n       Ineffective_Inline_Warnings         := True;\n-      List_Inherited_Pre_Post             := False;\n+      List_Inherited_Aspects              := False;\n       Warn_On_Ada_2005_Compatibility      := True;\n       Warn_On_Ada_2012_Compatibility      := True;\n       Warn_On_All_Unread_Out_Parameters   := False;\n@@ -3239,7 +3239,7 @@ package body Sem_Warn is\n             Constant_Condition_Warnings         := True;\n             Implementation_Unit_Warnings        := True;\n             Ineffective_Inline_Warnings         := True;\n-            List_Inherited_Pre_Post             := True;\n+            List_Inherited_Aspects              := True;\n             Warn_On_Ada_2005_Compatibility      := True;\n             Warn_On_Ada_2012_Compatibility      := True;\n             Warn_On_Assertion_Failure           := True;\n@@ -3270,7 +3270,7 @@ package body Sem_Warn is\n             Elab_Warnings                       := False;\n             Implementation_Unit_Warnings        := False;\n             Ineffective_Inline_Warnings         := False;\n-            List_Inherited_Pre_Post             := False;\n+            List_Inherited_Aspects              := False;\n             Warn_On_Ada_2005_Compatibility      := False;\n             Warn_On_Ada_2012_Compatibility      := False;\n             Warn_On_All_Unread_Out_Parameters   := False;"}, {"sha": "9d886a2a7ec79bbe0c5b364ce70bcb6b5c79b573", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=e606088aa9a3e732484cf7b701dc1e59e3bd9f69", "patch": "@@ -137,7 +137,6 @@ package Snames is\n    --  Names of aspects for which there are no matching pragmas or attributes\n    --  so that they need to be included for aspect specification use.\n \n-   Name_Invariant                      : constant Name_Id := N + $;\n    Name_Post                           : constant Name_Id := N + $;\n    Name_Pre                            : constant Name_Id := N + $;\n    Name_Predicate                      : constant Name_Id := N + $;\n@@ -483,6 +482,7 @@ package Snames is\n    Name_Interface_Name                 : constant Name_Id := N + $; -- GNAT\n    Name_Interrupt_Handler              : constant Name_Id := N + $;\n    Name_Interrupt_Priority             : constant Name_Id := N + $;\n+   Name_Invariant                      : constant Name_Id := N + $; -- GNAT\n    Name_Java_Constructor               : constant Name_Id := N + $; -- GNAT\n    Name_Java_Interface                 : constant Name_Id := N + $; -- GNAT\n    Name_Keep_Names                     : constant Name_Id := N + $; -- GNAT\n@@ -1566,6 +1566,7 @@ package Snames is\n       Pragma_Interface_Name,\n       Pragma_Interrupt_Handler,\n       Pragma_Interrupt_Priority,\n+      Pragma_Invariant,\n       Pragma_Java_Constructor,\n       Pragma_Java_Interface,\n       Pragma_Keep_Names,"}, {"sha": "fb31f38b0dbdd8f94a7c67e700fb5859f197bf0d", "filename": "gcc/ada/treepr.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Ftreepr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Ftreepr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftreepr.adb?ref=e606088aa9a3e732484cf7b701dc1e59e3bd9f69", "patch": "@@ -636,6 +636,14 @@ package body Treepr is\n          Print_Eol;\n       end if;\n \n+      if Field_Present (Field29 (Ent)) then\n+         Print_Str (Prefix);\n+         Write_Field29_Name (Ent);\n+         Write_Str (\" = \");\n+         Print_Field (Field29 (Ent));\n+         Print_Eol;\n+      end if;\n+\n       Write_Entity_Flags (Ent, Prefix);\n    end Print_Entity_Info;\n "}, {"sha": "0970021f3c58be228ad5dc1270173a0bce923013", "filename": "gcc/ada/ttypef.ads", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Fttypef.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Fttypef.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fttypef.ads?ref=e606088aa9a3e732484cf7b701dc1e59e3bd9f69", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -123,20 +123,20 @@ package Ttypef is\n    IEEES_Model_Epsilon     : constant := 2#1.0#E-23;\n    IEEEL_Model_Epsilon     : constant := 2#1.0#E-52;\n    IEEEX_Model_Epsilon     : constant := 2#1.0#E-63;\n-   VAXFF_Model_Epsilon     : constant := 16#0.1000_000#E-4;\n-   VAXDF_Model_Epsilon     : constant := 16#0.4000_0000_0000_000#E-7;\n-   VAXGF_Model_Epsilon     : constant := 16#0.4000_0000_0000_00#E-12;\n+   VAXFF_Model_Epsilon     : constant := 2#1.0#E-23;\n+   VAXDF_Model_Epsilon     : constant := 2#1.0#E-55;\n+   VAXGF_Model_Epsilon     : constant := 2#1.0#E-52;\n    AAMPS_Model_Epsilon     : constant := 2#1.0#E-23;\n    AAMPL_Model_Epsilon     : constant := 2#1.0#E-39;\n \n    IEEES_Model_Small       : constant := 2#1.0#E-126;\n    IEEEL_Model_Small       : constant := 2#1.0#E-1022;\n-   IEEEX_Model_Small       : constant := 2#1.0#E-16381;\n-   VAXFF_Model_Small       : constant := 16#0.8000_000#E-21;\n-   VAXDF_Model_Small       : constant := 16#0.8000_0000_0000_000#E-31;\n-   VAXGF_Model_Small       : constant := 16#0.8000_0000_0000_00#E-51;\n-   AAMPS_Model_Small       : constant := 16#0.8000_000#E-21;\n-   AAMPL_Model_Small       : constant := 16#0.8000_0000_000#E-31;\n+   IEEEX_Model_Small       : constant := 2#1.0#E-16382;\n+   VAXFF_Model_Small       : constant := 2#1.0#E-128;\n+   VAXDF_Model_Small       : constant := 2#1.0#E-128;\n+   VAXGF_Model_Small       : constant := 2#1.0#E-1024;\n+   AAMPS_Model_Small       : constant := 2#1.0#E-128;\n+   AAMPL_Model_Small       : constant := 2#1.0#E-128;\n \n    IEEES_Safe_First        : constant := -16#0.FFFF_FF#E+32;\n    IEEEL_Safe_First        : constant := -16#0.FFFF_FFFF_FFFF_F8#E+256;\n@@ -167,12 +167,12 @@ package Ttypef is\n \n    IEEES_Safe_Small        : constant := 2#1.0#E-126;\n    IEEEL_Safe_Small        : constant := 2#1.0#E-1022;\n-   IEEEX_Safe_Small        : constant := 2#1.0#E-16381;\n-   VAXFF_Safe_Small        : constant := 16#0.1000_000#E-31;\n-   VAXDF_Safe_Small        : constant := 16#0.1000_0000_0000_000#E-31;\n-   VAXGF_Safe_Small        : constant := 16#0.1000_0000_0000_00#E-255;\n-   AAMPS_Safe_Small        : constant := 16#0.1000_000#E-31;\n-   AAMPL_Safe_Small        : constant := 16#0.1000_0000_000#E-31;\n+   IEEEX_Safe_Small        : constant := 2#1.0#E-16382;\n+   VAXFF_Safe_Small        : constant := 2#1.0#E-128;\n+   VAXDF_Safe_Small        : constant := 2#1.0#E-128;\n+   VAXGF_Safe_Small        : constant := 2#1.0#E-1024;\n+   AAMPS_Safe_Small        : constant := 2#1.0#E-128;\n+   AAMPL_Safe_Small        : constant := 2#1.0#E-128;\n \n    ----------------------\n    -- Typed Attributes --\n@@ -196,7 +196,7 @@ package Ttypef is\n    IEEEL_Last              : constant := 16#0.FFFF_FFFF_FFFF_F8#E+256;\n    IEEEX_Last              : constant := 16#0.FFFF_FFFF_FFFF_FFFF#E+4096;\n    VAXFF_Last              : constant := 16#0.7FFF_FF8#E+32;\n-   VAXDF_Last              : constant := 16#0.7FFF_FFFF_FFFF_FC0#E+32;\n+   VAXDF_Last              : constant := 16#0.7FFF_FFFF_FFFF_FF8#E+32;\n    VAXGF_Last              : constant := 16#0.7FFF_FFFF_FFFF_FC#E+256;\n    AAMPS_Last              : constant := 16#0.7FFF_FF8#E+32;\n    AAMPL_Last              : constant := 16#0.7FFF_FFFF_FF8#E+32;"}, {"sha": "c4402cda391d97a9ccd29af4273180de738709b1", "filename": "gcc/ada/usage.adb", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Fusage.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e606088aa9a3e732484cf7b701dc1e59e3bd9f69/gcc%2Fada%2Fusage.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fusage.adb?ref=e606088aa9a3e732484cf7b701dc1e59e3bd9f69", "patch": "@@ -438,10 +438,8 @@ begin\n                                                   \"elaboration pragma\");\n    Write_Line (\"        L*   turn off warnings for missing \" &\n                                                   \"elaboration pragma\");\n-   Write_Line (\"        .l*  turn on info messages for inherited pre/\" &\n-                                                  \"postconditions\");\n-   Write_Line (\"        .L   turn off info messages for inherited pre/\" &\n-                                                  \"postconditions\");\n+   Write_Line (\"        .l*  turn on info messages for inherited aspects\");\n+   Write_Line (\"        .L   turn off info messages for inherited aspects\");\n    Write_Line (\"        m+   turn on warnings for variable assigned \" &\n                                                   \"but not read\");\n    Write_Line (\"        M*   turn off warnings for variable assigned \" &"}]}