{"sha": "9b3bd4249d2e0e46d4bec0909e626543bbd14d3b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWIzYmQ0MjQ5ZDJlMGU0NmQ0YmVjMDkwOWU2MjY1NDNiYmQxNGQzYg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-09-07T18:14:32Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-09-07T18:14:32Z"}, "message": "loop.c (record_giv): Avoid simplifying MULT to ASHIFT.\n\n        * loop.c (record_giv): Avoid simplifying MULT to ASHIFT.\n        (express_from_1): Wrap lines.\n        * rtlanal.c (commutative_operand_precedence): Rename from\n        operand_preference; export.\n        * rtl.h: Declare it.\n        * simplify-rtx.c (simplify_gen_binary): Tidy +/- const_int handling.\n        (simplify_binary_operation): Invoke simplify_plus_minus on\n        (CONST (PLUS ...)) as well.\n        (struct simplify_plus_minus_op_data): New.\n        (simplify_plus_minus_op_data_cmp): New.\n        (simplify_plus_minus): Use them.  Avoid infinite recursion with\n        simplify_binary_operation wrt CONST.\n\nFrom-SVN: r45473", "tree": {"sha": "fdd0e020da43b19ca8c6fe9ea8eb332cf71d6eba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fdd0e020da43b19ca8c6fe9ea8eb332cf71d6eba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b3bd4249d2e0e46d4bec0909e626543bbd14d3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b3bd4249d2e0e46d4bec0909e626543bbd14d3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b3bd4249d2e0e46d4bec0909e626543bbd14d3b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b3bd4249d2e0e46d4bec0909e626543bbd14d3b/comments", "author": null, "committer": null, "parents": [{"sha": "9978052974a84e9666af3c1f69bdf599c43cd5d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9978052974a84e9666af3c1f69bdf599c43cd5d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9978052974a84e9666af3c1f69bdf599c43cd5d0"}], "stats": {"total": 345, "additions": 224, "deletions": 121}, "files": [{"sha": "c3e93f6c9d0b05e34bdbcfa89e8c13ab1360d72c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b3bd4249d2e0e46d4bec0909e626543bbd14d3b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b3bd4249d2e0e46d4bec0909e626543bbd14d3b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9b3bd4249d2e0e46d4bec0909e626543bbd14d3b", "patch": "@@ -1,3 +1,18 @@\n+2001-09-07  Richard Henderson  <rth@redhat.com>\n+\n+\t* loop.c (record_giv): Avoid simplifying MULT to ASHIFT.\n+\t(express_from_1): Wrap lines.\n+\t* rtlanal.c (commutative_operand_precedence): Rename from\n+\toperand_preference; export.\n+\t* rtl.h: Declare it.\n+\t* simplify-rtx.c (simplify_gen_binary): Tidy +/- const_int handling.\n+\t(simplify_binary_operation): Invoke simplify_plus_minus on\n+\t(CONST (PLUS ...)) as well.\n+\t(struct simplify_plus_minus_op_data): New.\n+\t(simplify_plus_minus_op_data_cmp): New.\n+\t(simplify_plus_minus): Use them.  Avoid infinite recursion with\n+\tsimplify_binary_operation wrt CONST.\n+\n Fri Sep  7 11:52:30 2001   Kazu Hirata  <kazu@hxi.com>\n \n \t* h8300-protos.h (general_operand_dst_push): Remove."}, {"sha": "990826a5a7d500d0a409ea29fd1784de9878f5f6", "filename": "gcc/loop.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b3bd4249d2e0e46d4bec0909e626543bbd14d3b/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b3bd4249d2e0e46d4bec0909e626543bbd14d3b/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=9b3bd4249d2e0e46d4bec0909e626543bbd14d3b", "patch": "@@ -4922,9 +4922,12 @@ record_giv (loop, v, insn, src_reg, dest_reg, mult_val, add_val, ext_val,\n   rtx set = single_set (insn);\n   rtx temp;\n \n-  /* Attempt to prove constantness of the values.  */\n+  /* Attempt to prove constantness of the values.  Don't let simplity_rtx\n+     undo the MULT canonicalization that we performed earlier.  */\n   temp = simplify_rtx (add_val);\n-  if (temp)\n+  if (temp\n+      && ! (GET_CODE (add_val) == MULT\n+\t    && GET_CODE (temp) == ASHIFT))\n     add_val = temp;\n \n   v->insn = insn;\n@@ -6371,7 +6374,10 @@ express_from_1 (a, b, mult)\n     }\n   else if (CONSTANT_P (a))\n     {\n-      return simplify_gen_binary (MINUS, GET_MODE (b) != VOIDmode ? GET_MODE (b) : GET_MODE (a), b, a);\n+      enum machine_mode mode_a = GET_MODE (a);\n+      enum machine_mode mode_b = GET_MODE (b);\n+      enum machine_mode mode = mode_b == VOIDmode ? mode_a : mode_b;\n+      return simplify_gen_binary (MINUS, mode, b, a);\n     }\n   else if (GET_CODE (b) == PLUS)\n     {"}, {"sha": "75204b66de865deef164dfffe8dfe2fd20d638fa", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b3bd4249d2e0e46d4bec0909e626543bbd14d3b/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b3bd4249d2e0e46d4bec0909e626543bbd14d3b/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=9b3bd4249d2e0e46d4bec0909e626543bbd14d3b", "patch": "@@ -1374,6 +1374,7 @@ extern int reg_used_between_p\t\tPARAMS ((rtx, rtx, rtx));\n extern int reg_referenced_between_p\tPARAMS ((rtx, rtx, rtx));\n extern int reg_set_between_p\t\tPARAMS ((rtx, rtx, rtx));\n extern int regs_set_between_p\t\tPARAMS ((rtx, rtx, rtx));\n+extern int commutative_operand_precedence PARAMS ((rtx));\n extern int swap_commutative_operands_p\tPARAMS ((rtx, rtx));\n extern int modified_between_p\t\tPARAMS ((rtx, rtx, rtx));\n extern int no_labels_between_p\t\tPARAMS ((rtx, rtx));"}, {"sha": "9c8830d40007d8dce75536c6cf2c26320246a422", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b3bd4249d2e0e46d4bec0909e626543bbd14d3b/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b3bd4249d2e0e46d4bec0909e626543bbd14d3b/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=9b3bd4249d2e0e46d4bec0909e626543bbd14d3b", "patch": "@@ -30,7 +30,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n static void set_of_1\t\tPARAMS ((rtx, rtx, void *));\n static void insn_dependent_p_1\tPARAMS ((rtx, rtx, void *));\n static int computed_jump_p_1\tPARAMS ((rtx));\n-static int operand_preference\tPARAMS ((rtx));\n static void parms_set \t\tPARAMS ((rtx, rtx, void *));\n \n /* Bit flags that specify the machine subtype we are compiling for.\n@@ -2558,8 +2557,8 @@ regno_use_in (regno, x)\n    We use negative values to indicate a preference for the first operand\n    and positive values for the second operand.  */\n \n-static int\n-operand_preference (op)\n+int\n+commutative_operand_precedence (op)\n      rtx op;\n {\n   /* Constants always come the second operand.  Prefer \"nice\" constants.  */\n@@ -2597,7 +2596,8 @@ int\n swap_commutative_operands_p (x, y)\n      rtx x, y;\n {\n-  return operand_preference (x) < operand_preference (y);\n+  return (commutative_operand_precedence (x)\n+\t  < commutative_operand_precedence (y));\n }\n \n /* Return 1 if X is an autoincrement side effect and the register is"}, {"sha": "5e869bd7dec590aaab85b7519de100edad79d5f0", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 195, "deletions": 114, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b3bd4249d2e0e46d4bec0909e626543bbd14d3b/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b3bd4249d2e0e46d4bec0909e626543bbd14d3b/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=9b3bd4249d2e0e46d4bec0909e626543bbd14d3b", "patch": "@@ -95,6 +95,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define HWI_SIGN_EXTEND(low) \\\n  ((((HOST_WIDE_INT) low) < 0) ? ((HOST_WIDE_INT) -1) : ((HOST_WIDE_INT) 0))\n \n+static int simplify_plus_minus_op_data_cmp PARAMS ((const void *,\n+\t\t\t\t\t\t    const void *));\n static rtx simplify_plus_minus\t\tPARAMS ((enum rtx_code,\n \t\t\t\t\t\t enum machine_mode, rtx, rtx));\n static void check_fold_consts\t\tPARAMS ((PTR));\n@@ -130,12 +132,15 @@ simplify_gen_binary (code, mode, op0, op1)\n   /* Handle addition and subtraction of CONST_INT specially.  Otherwise,\n      just form the operation.  */\n \n-  if (code == PLUS && GET_CODE (op1) == CONST_INT\n-      && GET_MODE (op0) != VOIDmode)\n-    return plus_constant (op0, INTVAL (op1));\n-  else if (code == MINUS && GET_CODE (op1) == CONST_INT\n-\t   && GET_MODE (op0) != VOIDmode)\n-    return plus_constant (op0, - INTVAL (op1));\n+  if (GET_CODE (op1) == CONST_INT\n+      && GET_MODE (op0) != VOIDmode\n+      && (code == PLUS || code == MINUS))\n+    {\n+      HOST_WIDE_INT value = INTVAL (op1);\n+      if (code == MINUS)\n+\tvalue = -value;\n+      return plus_constant (op0, value);\n+    }\n   else\n     return gen_rtx_fmt_ee (code, mode, op0, op1);\n }\n@@ -1124,7 +1129,11 @@ simplify_binary_operation (code, mode, op0, op1)\n \n \t  if (INTEGRAL_MODE_P (mode)\n \t      && (GET_CODE (op0) == PLUS || GET_CODE (op0) == MINUS\n-\t\t  || GET_CODE (op1) == PLUS || GET_CODE (op1) == MINUS)\n+\t\t  || GET_CODE (op1) == PLUS || GET_CODE (op1) == MINUS\n+\t\t  || (GET_CODE (op0) == CONST\n+\t\t      && GET_CODE (XEXP (op0, 0)) == PLUS)\n+\t\t  || (GET_CODE (op1) == CONST\n+\t\t      && GET_CODE (XEXP (op1, 0)) == PLUS))\n \t      && (tem = simplify_plus_minus (code, mode, op0, op1)) != 0)\n \t    return tem;\n \t  break;\n@@ -1162,8 +1171,8 @@ simplify_binary_operation (code, mode, op0, op1)\n #endif\n \t\treturn xop00;\n \t    }\n-\n \t  break;\t      \n+\n \tcase MINUS:\n \t  /* None of these optimizations can be done for IEEE\n \t     floating point.  */\n@@ -1257,7 +1266,11 @@ simplify_binary_operation (code, mode, op0, op1)\n \n \t  if (INTEGRAL_MODE_P (mode)\n \t      && (GET_CODE (op0) == PLUS || GET_CODE (op0) == MINUS\n-\t\t  || GET_CODE (op1) == PLUS || GET_CODE (op1) == MINUS)\n+\t\t  || GET_CODE (op1) == PLUS || GET_CODE (op1) == MINUS\n+\t\t  || (GET_CODE (op0) == CONST\n+\t\t      && GET_CODE (XEXP (op0, 0)) == PLUS)\n+\t\t  || (GET_CODE (op1) == CONST\n+\t\t      && GET_CODE (XEXP (op1, 0)) == PLUS))\n \t      && (tem = simplify_plus_minus (code, mode, op0, op1)) != 0)\n \t    return tem;\n \n@@ -1680,17 +1693,34 @@ simplify_binary_operation (code, mode, op0, op1)\n    and do all possible simplifications until no more changes occur.  Then\n    we rebuild the operation.  */\n \n+struct simplify_plus_minus_op_data\n+{\n+  rtx op;\n+  int neg;\n+};\n+\n+static int\n+simplify_plus_minus_op_data_cmp (p1, p2)\n+     const void *p1;\n+     const void *p2;\n+{\n+  const struct simplify_plus_minus_op_data *d1 = p1;\n+  const struct simplify_plus_minus_op_data *d2 = p2;\n+\n+  return (commutative_operand_precedence (d2->op)\n+\t  - commutative_operand_precedence (d1->op));\n+}\n+\n static rtx\n simplify_plus_minus (code, mode, op0, op1)\n      enum rtx_code code;\n      enum machine_mode mode;\n      rtx op0, op1;\n {\n-  rtx ops[8];\n-  int negs[8];\n+  struct simplify_plus_minus_op_data ops[8];\n   rtx result, tem;\n-  int n_ops = 2, input_ops = 2, input_consts = 0, n_consts = 0;\n-  int first = 1, negate = 0, changed;\n+  int n_ops = 2, input_ops = 2, input_consts = 0, n_consts;\n+  int first, negate, changed;\n   int i, j;\n \n   memset ((char *) ops, 0, sizeof ops);\n@@ -1699,153 +1729,204 @@ simplify_plus_minus (code, mode, op0, op1)\n      changed.  If we run out of room in our array, give up; this should\n      almost never happen.  */\n \n-  ops[0] = op0, ops[1] = op1, negs[0] = 0, negs[1] = (code == MINUS);\n+  ops[0].op = op0;\n+  ops[0].neg = 0;\n+  ops[1].op = op1;\n+  ops[1].neg = (code == MINUS);\n \n-  changed = 1;\n-  while (changed)\n+  do\n     {\n       changed = 0;\n \n       for (i = 0; i < n_ops; i++)\n-\tswitch (GET_CODE (ops[i]))\n-\t  {\n-\t  case PLUS:\n-\t  case MINUS:\n-\t    if (n_ops == 7)\n-\t      return 0;\n-\n-\t    ops[n_ops] = XEXP (ops[i], 1);\n-\t    negs[n_ops++] = GET_CODE (ops[i]) == MINUS ? !negs[i] : negs[i];\n-\t    ops[i] = XEXP (ops[i], 0);\n-\t    input_ops++;\n-\t    changed = 1;\n-\t    break;\n-\n-\t  case NEG:\n-\t    ops[i] = XEXP (ops[i], 0);\n-\t    negs[i] = ! negs[i];\n-\t    changed = 1;\n-\t    break;\n+\t{\n+\t  rtx this_op = ops[i].op;\n+\t  int this_neg = ops[i].neg;\n+\t  enum rtx_code this_code = GET_CODE (this_op);\n \n-\t  case CONST:\n-\t    ops[i] = XEXP (ops[i], 0);\n-\t    input_consts++;\n-\t    changed = 1;\n-\t    break;\n+\t  switch (this_code)\n+\t    {\n+\t    case PLUS:\n+\t    case MINUS:\n+\t      if (n_ops == 7)\n+\t\treturn 0;\n \n-\t  case NOT:\n-\t    /* ~a -> (-a - 1) */\n-\t    if (n_ops != 7)\n-\t      {\n-\t\tops[n_ops] = constm1_rtx;\n-\t\tnegs[n_ops++] = negs[i];\n-\t\tops[i] = XEXP (ops[i], 0);\n-\t\tnegs[i] = ! negs[i];\n-\t\tchanged = 1;\n-\t      }\n-\t    break;\n+\t      ops[n_ops].op = XEXP (this_op, 1);\n+\t      ops[n_ops].neg = (this_code == MINUS) ^ this_neg;\n+\t      n_ops++;\n+\n+\t      ops[i].op = XEXP (this_op, 0);\n+\t      input_ops++;\n+\t      changed = 1;\n+\t      break;\n+\n+\t    case NEG:\n+\t      ops[i].op = XEXP (this_op, 0);\n+\t      ops[i].neg = ! this_neg;\n+\t      changed = 1;\n+\t      break;\n+\n+\t    case CONST:\n+\t      ops[i].op = XEXP (this_op, 0);\n+\t      input_consts++;\n+\t      changed = 1;\n+\t      break;\n+\n+\t    case NOT:\n+\t      /* ~a -> (-a - 1) */\n+\t      if (n_ops != 7)\n+\t\t{\n+\t\t  ops[n_ops].op = constm1_rtx;\n+\t\t  ops[n_ops].neg = this_neg;\n+\t\t  ops[i].op = XEXP (this_op, 0);\n+\t\t  ops[i].neg = !this_neg;\n+\t\t  changed = 1;\n+\t\t}\n+\t      break;\n \n-\t  case CONST_INT:\n-\t    if (negs[i])\n-\t      ops[i] = GEN_INT (- INTVAL (ops[i])), negs[i] = 0, changed = 1;\n-\t    break;\n+\t    case CONST_INT:\n+\t      if (this_neg)\n+\t\t{\n+\t\t  ops[i].op = GEN_INT (- INTVAL (this_op));\n+\t\t  ops[i].neg = 0;\n+\t\t  changed = 1;\n+\t\t}\n+\t      break;\n \n-\t  default:\n-\t    break;\n-\t  }\n+\t    default:\n+\t      break;\n+\t    }\n+\t}\n     }\n+  while (changed);\n \n   /* If we only have two operands, we can't do anything.  */\n   if (n_ops <= 2)\n-    return 0;\n+    return NULL_RTX;\n \n   /* Now simplify each pair of operands until nothing changes.  The first\n      time through just simplify constants against each other.  */\n \n-  changed = 1;\n-  while (changed)\n+  first = 1;\n+  do\n     {\n       changed = first;\n \n       for (i = 0; i < n_ops - 1; i++)\n \tfor (j = i + 1; j < n_ops; j++)\n-\t  if (ops[i] != 0 && ops[j] != 0\n-\t      && (! first || (CONSTANT_P (ops[i]) && CONSTANT_P (ops[j]))))\n-\t    {\n-\t      rtx lhs = ops[i], rhs = ops[j];\n-\t      enum rtx_code ncode = PLUS;\n-\n-\t      if (negs[i] && ! negs[j])\n-\t\tlhs = ops[j], rhs = ops[i], ncode = MINUS;\n-\t      else if (! negs[i] && negs[j])\n-\t\tncode = MINUS;\n-\n-\t      tem = simplify_binary_operation (ncode, mode, lhs, rhs);\n-\t      if (tem)\n-\t\t{\n-\t\t  ops[i] = tem, ops[j] = 0;\n-\t\t  negs[i] = negs[i] && negs[j];\n-\t\t  if (GET_CODE (tem) == NEG)\n-\t\t    ops[i] = XEXP (tem, 0), negs[i] = ! negs[i];\n+\t  {\n+\t    rtx lhs = ops[i].op, rhs = ops[j].op;\n+\t    int lneg = ops[i].neg, rneg = ops[j].neg;\n \n-\t\t  if (GET_CODE (ops[i]) == CONST_INT && negs[i])\n-\t\t    ops[i] = GEN_INT (- INTVAL (ops[i])), negs[i] = 0;\n-\t\t  changed = 1;\n-\t\t}\n-\t    }\n+\t    if (lhs != 0 && rhs != 0\n+\t\t&& (! first || (CONSTANT_P (lhs) && CONSTANT_P (rhs))))\n+\t      {\n+\t\tenum rtx_code ncode = PLUS;\n+\n+\t\tif (lneg != rneg)\n+\t\t  {\n+\t\t    ncode = MINUS;\n+\t\t    if (lneg)\n+\t\t      tem = lhs, lhs = rhs, rhs = tem;\n+\t\t  }\n+\t\telse if (swap_commutative_operands_p (lhs, rhs))\n+\t\t  tem = lhs, lhs = rhs, rhs = tem;\n+\n+\t\ttem = simplify_binary_operation (ncode, mode, lhs, rhs);\n+\n+\t\t/* Reject \"simplifications\" that just wrap the two \n+\t\t   arguments in a CONST.  Failure to do so can result\n+\t\t   in infinite recursion with simplify_binary_operation\n+\t\t   when it calls us to simplify CONST operations.  */\n+\t\tif (tem\n+\t\t    && ! (GET_CODE (tem) == CONST\n+\t\t\t  && GET_CODE (XEXP (tem, 0)) == ncode\n+\t\t\t  && XEXP (XEXP (tem, 0), 0) == lhs\n+\t\t\t  && XEXP (XEXP (tem, 0), 1) == rhs))\n+\t\t  {\n+\t\t    lneg &= rneg;\n+\t\t    if (GET_CODE (tem) == NEG)\n+\t\t      tem = XEXP (tem, 0), lneg = !lneg;\n+\t\t    if (GET_CODE (tem) == CONST_INT && lneg)\n+\t\t      tem = GEN_INT (- INTVAL (tem)), lneg = 0;\n+\n+\t\t    ops[i].op = tem;\n+\t\t    ops[i].neg = lneg;\n+\t\t    ops[j].op = NULL_RTX;\n+\t\t    changed = 1;\n+\t\t  }\n+\t      }\n+\t  }\n \n       first = 0;\n     }\n+  while (changed);\n \n-  /* Pack all the operands to the lower-numbered entries and give up if\n-     we didn't reduce the number of operands we had.  Make sure we\n-     count a CONST as two operands.  If we have the same number of\n-     operands, but have made more CONSTs than we had, this is also\n-     an improvement, so accept it.  */\n-\n+  /* Pack all the operands to the lower-numbered entries.  */\n   for (i = 0, j = 0; j < n_ops; j++)\n-    if (ops[j] != 0)\n-      {\n-\tops[i] = ops[j], negs[i++] = negs[j];\n-\tif (GET_CODE (ops[j]) == CONST)\n-\t  n_consts++;\n-      }\n+    if (ops[j].op)\n+      ops[i++] = ops[j];\n+  n_ops = i;\n \n-  if (i + n_consts > input_ops\n-      || (i + n_consts == input_ops && n_consts <= input_consts))\n-    return 0;\n+  /* Sort the operations based on swap_commutative_operands_p.  */\n+  qsort (ops, n_ops, sizeof (*ops), simplify_plus_minus_op_data_cmp);\n \n-  n_ops = i;\n+  /* We suppressed creation of trivial CONST expressions in the\n+     combination loop to avoid recursion.  Create one manually now.\n+     The combination loop should have ensured that there is exactly\n+     one CONST_INT, and the sort will have ensured that it is last\n+     in the array and that any other constant will be next-to-last.  */\n \n-  /* If we have a CONST_INT, put it last.  */\n-  for (i = 0; i < n_ops - 1; i++)\n-    if (GET_CODE (ops[i]) == CONST_INT)\n-      {\n-\ttem = ops[n_ops - 1], ops[n_ops - 1] = ops[i] , ops[i] = tem;\n-\tj = negs[n_ops - 1], negs[n_ops - 1] = negs[i], negs[i] = j;\n-      }\n+  if (n_ops > 1\n+      && GET_CODE (ops[n_ops - 1].op) == CONST_INT\n+      && CONSTANT_P (ops[n_ops - 2].op))\n+    {\n+      HOST_WIDE_INT value = INTVAL (ops[n_ops - 1].op);\n+      if (ops[n_ops - 1].neg)\n+\tvalue = -value;\n+      ops[n_ops - 2].op = plus_constant (ops[n_ops - 2].op, value);\n+      n_ops--;\n+    }\n+\n+  /* Count the number of CONSTs that we generated.  */\n+  n_consts = 0;\n+  for (i = 0; i < n_ops; i++)\n+    if (GET_CODE (ops[i].op) == CONST)\n+      n_consts++;\n+\n+  /* Give up if we didn't reduce the number of operands we had.  Make\n+     sure we count a CONST as two operands.  If we have the same\n+     number of operands, but have made more CONSTs than before, this\n+     is also an improvement, so accept it.  */\n+  if (n_ops + n_consts > input_ops\n+      || (n_ops + n_consts == input_ops && n_consts <= input_consts))\n+    return NULL_RTX;\n \n   /* Put a non-negated operand first.  If there aren't any, make all\n      operands positive and negate the whole thing later.  */\n-  for (i = 0; i < n_ops && negs[i]; i++)\n-    ;\n \n+  negate = 0;\n+  for (i = 0; i < n_ops && ops[i].neg; i++)\n+    continue;\n   if (i == n_ops)\n     {\n       for (i = 0; i < n_ops; i++)\n-\tnegs[i] = 0;\n+\tops[i].neg = 0;\n       negate = 1;\n     }\n   else if (i != 0)\n     {\n-      tem = ops[0], ops[0] = ops[i], ops[i] = tem;\n-      j = negs[0], negs[0] = negs[i], negs[i] = j;\n+      tem = ops[0].op;\n+      ops[0] = ops[i];\n+      ops[i].op = tem;\n+      ops[i].neg = 1;\n     }\n \n   /* Now make the result by performing the requested operations.  */\n-  result = ops[0];\n+  result = ops[0].op;\n   for (i = 1; i < n_ops; i++)\n-    result = simplify_gen_binary (negs[i] ? MINUS : PLUS, mode, result, ops[i]);\n+    result = gen_rtx_fmt_ee (ops[i].neg ? MINUS : PLUS,\n+\t\t\t     mode, result, ops[i].op);\n \n   return negate ? gen_rtx_NEG (mode, result) : result;\n }"}]}