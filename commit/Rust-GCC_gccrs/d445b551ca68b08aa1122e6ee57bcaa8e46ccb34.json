{"sha": "d445b551ca68b08aa1122e6ee57bcaa8e46ccb34", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQ0NWI1NTFjYTY4YjA4YWExMTIyZTZlZTU3YmNhYThlNDZjY2IzNA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-01-01T21:50:07Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-01-01T21:50:07Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r152", "tree": {"sha": "c38a21607359c2f9e77a1ba30f7d84f6d09452e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c38a21607359c2f9e77a1ba30f7d84f6d09452e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d445b551ca68b08aa1122e6ee57bcaa8e46ccb34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d445b551ca68b08aa1122e6ee57bcaa8e46ccb34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d445b551ca68b08aa1122e6ee57bcaa8e46ccb34", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d445b551ca68b08aa1122e6ee57bcaa8e46ccb34/comments", "author": null, "committer": null, "parents": [{"sha": "1d56e9834b5883aafdae85d9664b2bf2582fe58f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d56e9834b5883aafdae85d9664b2bf2582fe58f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d56e9834b5883aafdae85d9664b2bf2582fe58f"}], "stats": {"total": 152, "additions": 83, "deletions": 69}, "files": [{"sha": "8af7b0caa5876c8ebbde501dda1f08b585410bb8", "filename": "gcc/reload1.c", "status": "modified", "additions": 83, "deletions": 69, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d445b551ca68b08aa1122e6ee57bcaa8e46ccb34/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d445b551ca68b08aa1122e6ee57bcaa8e46ccb34/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=d445b551ca68b08aa1122e6ee57bcaa8e46ccb34", "patch": "@@ -494,7 +494,6 @@ reload (first, global, dumpfile)\n   int something_needs_elimination;\n   int new_basic_block_needs;\n   int caller_save_needs_spill;\n-  int old_caller_save_needed = caller_save_needed;\n \n   /* The basic block number currently being processed for INSN.  */\n   int this_block;\n@@ -517,9 +516,9 @@ reload (first, global, dumpfile)\n   bzero (spill_stack_slot, sizeof spill_stack_slot);\n   bzero (spill_stack_slot_width, sizeof spill_stack_slot_width);\n \n-  /* If caller-saves are needed, allocate the required save areas.  */\n-  if (caller_save_needed)\n-    allocate_save_areas ();\n+  /* If caller-saves are requested, initialize the required save areas.  */\n+  if (flag_caller_saves)\n+    init_save_areas ();\n     \n   /* Compute which hard registers are now in use\n      as homes for pseudo registers.\n@@ -581,7 +580,7 @@ reload (first, global, dumpfile)\n \t\t\treg_equiv_constant[i] = x;\n \t\t      else\n \t\t\treg_equiv_memory_loc[i]\n-\t\t\t  = force_const_mem (GET_MODE (x), x);\n+\t\t\t  = force_const_mem (GET_MODE (SET_DEST (set)), x);\n \t\t    }\n \t\t  else\n \t\t    continue;\n@@ -1205,33 +1204,21 @@ reload (first, global, dumpfile)\n \t  /* Note that there is a continue statement above.  */\n \t}\n \n-      /* If we have caller-saves, perform register elimination in the\n-\t save area addresses and see if caller-save will need a spill register.\n-\t If it will and we don't already have a need of class BASE_REG_CLASS,\n-\t create such a need.  If we didn't need caller-saves before this\n-\t pass, allocate the save area and show something changed.  */\n+      /* If we have caller-saves, set up the save areas and see if caller-save\n+\t will need a spill register.  If it will and we don't already have a\n+\t need of class BASE_REG_CLASS, create such a need.  */\n \n-      if (caller_save_needed)\n+      if (caller_save_needed\n+\t  && 0 != (caller_save_needs_spill\n+\t\t   = ! setup_save_areas (&something_changed))\n+\t  && max_needs[(int) BASE_REG_CLASS] == 0)\n \t{\n-\t  if (! old_caller_save_needed)\n-\t    {\n-\t      allocate_save_areas ();\n-\t      something_changed = 1;\n-\t    }\n+\t  register enum reg_class *p\n+\t    = reg_class_superclasses[(int) BASE_REG_CLASS];\n \n-\t  old_caller_save_needed = 1;\n-\n-\t  caller_save_needs_spill = ! elim_save_addrs ();\n-\t  if (caller_save_needs_spill\n-\t      && max_needs[(int) BASE_REG_CLASS] == 0)\n-\t    {\n-\t      register enum reg_class *p\n-\t\t= reg_class_superclasses[(int) BASE_REG_CLASS];\n-\n-\t      max_needs[(int) BASE_REG_CLASS] = 1;\n-\t      while (*p != LIM_REG_CLASSES)\n-\t\tmax_needs[(int) *p++] += 1;\n-\t    }\n+\t  max_needs[(int) BASE_REG_CLASS] = 1;\n+\t  while (*p != LIM_REG_CLASSES)\n+\t    max_needs[(int) *p++] += 1;\n \t}\n \n       /* Now deduct from the needs for the registers already\n@@ -1243,7 +1230,7 @@ reload (first, global, dumpfile)\n       /* First find all regs alone in their class\n \t and count them (if desired) for non-groups.\n \t We would be screwed if a group took the only reg in a class\n-\t for which a non-group reload ius needed.\n+\t for which a non-group reload is needed.\n \t (Note there is still a bug; if a class has 2 regs,\n \t both could be stolen by groups and we would lose the same way.\n \t With luck, no machine will need a nongroup in a 2-reg class.)  */\n@@ -4403,6 +4390,7 @@ emit_reload_insns (insn)\n \t  rtx oldequiv = 0;\n \t  enum machine_mode mode;\n \t  rtx where;\n+\t  rtx reload_insn;\n \n \t  /* Determine the mode to reload in.\n \t     This is very tricky because we have three to choose from.\n@@ -4615,20 +4603,24 @@ emit_reload_insns (insn)\n \t      enum insn_code icode;\n \n \t      /* If we have a secondary reload, pick up the secondary register\n-\t\t and icode, if any.  If OLDEQUIV and OLD are different,\n-\t\t recompute whether or not we still need a secondary register\n-\t\t and what the icode should be.  If we still need a secondary\n-\t\t register and the class or icode is different, go back to\n-\t\t reloading from OLD if using OLDEQUIV means that we got the\n-\t\t wrong type of register.  */\n+\t\t and icode, if any.  If OLDEQUIV and OLD are different or\n+\t\t if this is an in-out reload, recompute whether or not we\n+\t\t still need a secondary register and what the icode should\n+\t\t be.  If we still need a secondary register and the class or\n+\t\t icode is different, go back to reloading from OLD if using\n+\t\t OLDEQUIV means that we got the wrong type of register.  We\n+\t\t cannot have different class or icode due to an in-out reload\n+\t\t because we don't make such reloads when both the input and\n+\t\t output need secondary reload registers.  */\n \n \t      if (reload_secondary_reload[j] >= 0)\n \t\t{\n \t\t  int secondary_reload = reload_secondary_reload[j];\n \t\t  second_reload_reg = reload_reg_rtx[secondary_reload];\n \t\t  icode = reload_secondary_icode[j];\n \n-\t\t  if (old != oldequiv && ! rtx_equal_p (old, oldequiv))\n+\t\t  if ((old != oldequiv && ! rtx_equal_p (old, oldequiv))\n+\t\t      || (reload_in[j] != 0 && reload_out[j] != 0))\n \t\t    {\n \t\t      enum reg_class new_class\n \t\t\t= SECONDARY_INPUT_RELOAD_CLASS (reload_reg_class[j],\n@@ -4683,10 +4675,12 @@ emit_reload_insns (insn)\n \t\t    {\n \t\t      if (icode != CODE_FOR_nothing)\n \t\t\t{\n-\t\t\t  emit_insn_before (GEN_FCN (icode)\n-\t\t\t\t\t    (reloadreg, oldequiv,\n-\t\t\t\t\t     second_reload_reg),\n-\t\t\t\t\t    where);\n+\t\t\t  reload_insn = emit_insn_before (GEN_FCN (icode)\n+\t\t\t\t\t\t\t  (reloadreg, oldequiv,\n+\t\t\t\t\t\t\t   second_reload_reg),\n+\t\t\t\t\t\t\t  where);\n+\t\t\t  if (this_reload_insn == 0)\n+\t\t\t    this_reload_insn = reload_insn;\n \t\t\t  special = 1;\n \t\t\t}\n \t\t      else\n@@ -4701,15 +4695,22 @@ emit_reload_insns (insn)\n \t\t\t      rtx third_reload_reg\n \t\t\t        = reload_reg_rtx[reload_secondary_reload[secondary_reload]];\n \n-\t\t\t      emit_insn_before ((GEN_FCN (tertiary_icode)\n-\t\t\t\t\t\t (second_reload_reg, oldequiv,\n-\t\t\t\t\t\t  third_reload_reg)),\n-\t\t\t\t\t\twhere);\n+\t\t\t      reload_insn\n+\t\t\t\t= emit_insn_before ((GEN_FCN (tertiary_icode)\n+\t\t\t\t\t\t     (second_reload_reg,\n+\t\t\t\t\t\t      oldequiv,\n+\t\t\t\t\t\t      third_reload_reg)),\n+\t\t\t\t\t\t    where);\n+\t\t\t      if (this_reload_insn == 0)\n+\t\t\t\tthis_reload_insn = reload_insn;\n \t\t\t    }\n \t\t\t  else\n \t\t\t    {\n-\t\t\t      gen_input_reload (second_reload_reg,\n-\t\t\t\t\t\toldequiv, where);\n+\t\t\t      reload_insn\n+\t\t\t\t= gen_input_reload (second_reload_reg,\n+\t\t\t\t\t\t    oldequiv, where);\n+\t\t\t      if (this_reload_insn == 0)\n+\t\t\t\tthis_reload_insn = reload_insn;\n \t\t\t      oldequiv = second_reload_reg;\n \t\t\t    }\n \t\t\t}\n@@ -4718,8 +4719,12 @@ emit_reload_insns (insn)\n #endif\n \n \t      if (! special)\n-\t\tthis_reload_insn = gen_input_reload (reloadreg,\n-\t\t\t\t\t\t     oldequiv, where);\n+\t\t{\n+\t\t  reload_insn = gen_input_reload (reloadreg,\n+\t\t\t\t\t\t  oldequiv, where);\n+\t\t  if (this_reload_insn == 0)\n+\t\t    this_reload_insn = reload_insn;\n+\t\t}\n \n #if defined(SECONDARY_INPUT_RELOAD_CLASS) && defined(PRESERVE_DEATH_INFO_REGNO_P)\n \t      /* We may have to make a REG_DEAD note for the secondary reload\n@@ -5073,15 +5078,6 @@ emit_reload_insns (insn)\n \tnew_spill_reg_store[reload_spill_index[j]] = store_insn;\n     }\n \n-  /* Now update spill_reg_store for the reloads of this insn.  */\n-  /* Copy the elements that were updated in the loop above.  */\n-  for (j = 0; j < n_reloads; j++)\n-    {\n-      int regno = reload_spill_index[j];\n-      if (regno >= 0)\n-\tspill_reg_store[regno] = new_spill_reg_store[regno];\n-    }\n-\n   /* Move death notes from INSN\n      to output-operand-address and output reload insns.  */\n #ifdef PRESERVE_DEATH_INFO_REGNO_P\n@@ -5126,7 +5122,10 @@ emit_reload_insns (insn)\n \n   /* For all the spill regs newly reloaded in this instruction,\n      record what they were reloaded from, so subsequent instructions\n-     can inherit the reloads.  */\n+     can inherit the reloads.\n+\n+     Update spill_reg_store for the reloads of this insn.\n+     Copy the elements that were updated in the loop above.   */\n \n   for (j = 0; j < n_reloads; j++)\n     {\n@@ -5136,6 +5135,7 @@ emit_reload_insns (insn)\n       /* I is nonneg if this reload used one of the spill regs.\n \t If reload_reg_rtx[r] is 0, this is an optional reload\n \t that we opted to ignore.  */\n+\n       if (i >= 0 && reload_reg_rtx[r] != 0)\n \t{\n \t  /* First, clear out memory of what used to be in this spill reg.\n@@ -5154,14 +5154,18 @@ emit_reload_insns (insn)\n \t  if (reload_out[r] != 0 && GET_CODE (reload_out[r]) == REG)\n \t    {\n \t      register int nregno = REGNO (reload_out[r]);\n+\n+\t      spill_reg_store[i] = new_spill_reg_store[i];\n \t      reg_last_reload_reg[nregno] = reload_reg_rtx[r];\n+\n \t      for (k = 0; k < nr; k++)\n \t\t{\n \t\t  reg_reloaded_contents[spill_reg_order[spill_regs[i] + k]]\n \t\t    = nregno;\n \t\t  reg_reloaded_insn[spill_reg_order[spill_regs[i] + k]] = insn;\n \t\t}\n \t    }\n+\n \t  /* Maybe the spill reg contains a copy of reload_in.  */\n \t  else if (reload_out[r] == 0\n \t\t   && reload_in[r] != 0\n@@ -5186,6 +5190,12 @@ emit_reload_insns (insn)\n \t\t\t\t\t       reload_when_needed[r]))\n \t\t{\n \t\t  reg_last_reload_reg[nregno] = reload_reg_rtx[r];\n+\n+\t\t  /* Unless we inherited this reload, show we haven't\n+\t\t     recently done a store.  */\n+\t\t  if (! reload_inherited[r])\n+\t\t    spill_reg_store[i] = 0;\n+\n \t\t  for (k = 0; k < nr; k++)\n \t\t    {\n \t\t      reg_reloaded_contents[spill_reg_order[spill_regs[i] + k]]\n@@ -5214,7 +5224,7 @@ emit_reload_insns (insn)\n }\n \f\n /* Emit code before BEFORE_INSN to perform an input reload of IN to RELOADREG.\n-   Returns last insn emitted.  */\n+   Returns first insn emitted.  */\n \n rtx\n gen_input_reload (reloadreg, in, before_insn)\n@@ -5402,11 +5412,11 @@ delete_output_reload (insn, j, output_reload_insn)\n \t Search that range; see if any ref remains.  */\n       for (i2 = PREV_INSN (insn); i2; i2 = PREV_INSN (i2))\n \t{\n+\t  rtx set = single_set (i2);\n+\n \t  /* Uses which just store in the pseudo don't count,\n \t     since if they are the only uses, they are dead.  */\n-\t  if (GET_CODE (i2) == INSN\n-\t      && GET_CODE (PATTERN (i2)) == SET\n-\t      && SET_DEST (PATTERN (i2)) == reg)\n+\t  if (set != 0 && SET_DEST (set) == reg)\n \t    continue;\n \t  if (GET_CODE (i2) == CODE_LABEL\n \t      || GET_CODE (i2) == JUMP_INSN)\n@@ -5421,11 +5431,9 @@ delete_output_reload (insn, j, output_reload_insn)\n       /* Delete the now-dead stores into this pseudo.  */\n       for (i2 = PREV_INSN (insn); i2; i2 = PREV_INSN (i2))\n \t{\n-\t  /* Uses which just store in the pseudo don't count,\n-\t     since if they are the only uses, they are dead.  */\n-\t  if (GET_CODE (i2) == INSN\n-\t      && GET_CODE (PATTERN (i2)) == SET\n-\t      && SET_DEST (PATTERN (i2)) == reg)\n+\t  rtx set = single_set (i2);\n+\n+\t  if (set != 0 && SET_DEST (set) == reg)\n \t    delete_insn (i2);\n \t  if (GET_CODE (i2) == CODE_LABEL\n \t      || GET_CODE (i2) == JUMP_INSN)\n@@ -5593,7 +5601,8 @@ constraint_accepts_reg_p (string, reg)\n       }\n }\n \f\n-/* Return the number of places FIND appears within X.  */\n+/* Return the number of places FIND appears within X, but don't count\n+   an occurrence if some SET_DEST is FIND.  */\n \n static int\n count_occurrences (x, find)\n@@ -5622,6 +5631,11 @@ count_occurrences (x, find)\n     case PC:\n     case CC0:\n       return 0;\n+\n+    case SET:\n+      if (SET_DEST (x) == find)\n+\treturn count_occurrences (SET_SRC (x), find);\n+      break;\n     }\n \n   format_ptr = GET_RTX_FORMAT (code);"}]}