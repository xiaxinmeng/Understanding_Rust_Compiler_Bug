{"sha": "984417a0ae5aec2b3ef771b52d9d41b01c77ff02", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTg0NDE3YTBhZTVhZWMyYjNlZjc3MWI1MmQ5ZDQxYjAxYzc3ZmYwMg==", "commit": {"author": {"name": "Adam Butcher", "email": "adam@jessamine.co.uk", "date": "2013-09-12T21:04:52Z"}, "committer": {"name": "Adam Butcher", "email": "abutcher@gcc.gnu.org", "date": "2013-09-12T21:04:52Z"}, "message": "Support using 'auto' in a function parameter list to introduce an implicit template parameter.\n\n\t* cp-tree.h (type_uses_auto_or_concept): Declare.\n\t(is_auto_or_concept): Declare.\n\t* decl.c (grokdeclarator): Allow 'auto' parameters in lambdas with\n\t-std=gnu++1y or -std=c++1y or, as a GNU extension, in plain functions.\n\t* type-utils.h: New header defining ...\n\t(find_type_usage): ... this new function based on pt.c (type_uses_auto)\n\tfor searching a type tree given a predicate.\n\t* pt.c (type_uses_auto): Reimplement via type-utils.h (find_type_usage).\n\t(is_auto_or_concept): New function.\n\t(type_uses_auto_or_concept): New function.\n\t* parser.h (struct cp_parser): Add fully_implicit_function_template_p.\n\t* parser.c (cp_parser_new): Initialize fully_implicit_function_template_p.\n\t(cp_parser_new): Initialize fully_implicit_function_template_p.\n\t(cp_parser_lambda_expression): Copy and restore value of\n\tfully_implicit_function_template_p as per other parser fields.\n\t(cp_parser_parameter_declaration_list): Count generic\n\tparameters and call ...\n\t(add_implicit_template_parms): ... this new function to synthesize them\n\twith help from type-utils.h (find_type_usage), ...\n\t(tree_type_is_auto_or_concept): ... this new static function and ...\n\t(make_generic_type_name): ... this new static function.\n\t(cp_parser_direct_declarator): Account for implicit template parameters.\n\t(cp_parser_lambda_declarator_opt): Finish fully implicit template if\n\tnecessary by calling ...\n\t(finish_fully_implicit_template): ... this new function.\n\t(cp_parser_member_declaration): Likewise.\n\t(cp_parser_function_definition_after_declarator): Likewise.\n\t* Make-lang.in (cp/pt.o): Add dependency on type-utils.h.\n\t(cp/parser.o): Likewise.\n\nFrom-SVN: r202540", "tree": {"sha": "09aeca39dd9caaa23fee35767bb1452967741f26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09aeca39dd9caaa23fee35767bb1452967741f26"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/984417a0ae5aec2b3ef771b52d9d41b01c77ff02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/984417a0ae5aec2b3ef771b52d9d41b01c77ff02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/984417a0ae5aec2b3ef771b52d9d41b01c77ff02", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/984417a0ae5aec2b3ef771b52d9d41b01c77ff02/comments", "author": {"login": "abutcher-gh", "id": 10379705, "node_id": "MDQ6VXNlcjEwMzc5NzA1", "avatar_url": "https://avatars.githubusercontent.com/u/10379705?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abutcher-gh", "html_url": "https://github.com/abutcher-gh", "followers_url": "https://api.github.com/users/abutcher-gh/followers", "following_url": "https://api.github.com/users/abutcher-gh/following{/other_user}", "gists_url": "https://api.github.com/users/abutcher-gh/gists{/gist_id}", "starred_url": "https://api.github.com/users/abutcher-gh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abutcher-gh/subscriptions", "organizations_url": "https://api.github.com/users/abutcher-gh/orgs", "repos_url": "https://api.github.com/users/abutcher-gh/repos", "events_url": "https://api.github.com/users/abutcher-gh/events{/privacy}", "received_events_url": "https://api.github.com/users/abutcher-gh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c9469d539a89f1a488a743fdc45a06678dac0b2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9469d539a89f1a488a743fdc45a06678dac0b2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9469d539a89f1a488a743fdc45a06678dac0b2f"}], "stats": {"total": 349, "additions": 323, "deletions": 26}, "files": [{"sha": "470fa1f22d8564f13f8064a8f128ffd9e089b24c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/984417a0ae5aec2b3ef771b52d9d41b01c77ff02/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/984417a0ae5aec2b3ef771b52d9d41b01c77ff02/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=984417a0ae5aec2b3ef771b52d9d41b01c77ff02", "patch": "@@ -1,3 +1,35 @@\n+2013-09-12  Adam Butcher  <adam@jessamine.co.uk>\n+\n+\t* cp-tree.h (type_uses_auto_or_concept): Declare.\n+\t(is_auto_or_concept): Declare.\n+\t* decl.c (grokdeclarator): Allow 'auto' parameters in lambdas with\n+\t-std=gnu++1y or -std=c++1y or, as a GNU extension, in plain functions.\n+\t* type-utils.h: New header defining ...\n+\t(find_type_usage): ... this new function based on pt.c (type_uses_auto)\n+\tfor searching a type tree given a predicate.\n+\t* pt.c (type_uses_auto): Reimplement via type-utils.h (find_type_usage).\n+\t(is_auto_or_concept): New function.\n+\t(type_uses_auto_or_concept): New function.\n+\t* parser.h (struct cp_parser): Add fully_implicit_function_template_p.\n+\t* parser.c (cp_parser_new): Initialize fully_implicit_function_template_p.\n+\t(cp_parser_new): Initialize fully_implicit_function_template_p.\n+\t(cp_parser_lambda_expression): Copy and restore value of\n+\tfully_implicit_function_template_p as per other parser fields.\n+\t(cp_parser_parameter_declaration_list): Count generic\n+\tparameters and call ...\n+\t(add_implicit_template_parms): ... this new function to synthesize them\n+\twith help from type-utils.h (find_type_usage), ...\n+\t(tree_type_is_auto_or_concept): ... this new static function and ...\n+\t(make_generic_type_name): ... this new static function.\n+\t(cp_parser_direct_declarator): Account for implicit template parameters.\n+\t(cp_parser_lambda_declarator_opt): Finish fully implicit template if\n+\tnecessary by calling ...\n+\t(finish_fully_implicit_template): ... this new function.\n+\t(cp_parser_member_declaration): Likewise.\n+\t(cp_parser_function_definition_after_declarator): Likewise.\n+\t* Make-lang.in (cp/pt.o): Add dependency on type-utils.h.\n+\t(cp/parser.o): Likewise.\n+\n 2013-09-12  Adam Butcher  <adam@jessamine.co.uk>\n \n \t* parser.c (cp_parser_lambda_declarator_opt): Accept template parameter"}, {"sha": "e8d4913fbd195d83b71960f2cdc00e132f4ef1e7", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/984417a0ae5aec2b3ef771b52d9d41b01c77ff02/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/984417a0ae5aec2b3ef771b52d9d41b01c77ff02/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=984417a0ae5aec2b3ef771b52d9d41b01c77ff02", "patch": "@@ -320,7 +320,7 @@ cp/except.o: cp/except.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) \\\n cp/expr.o: cp/expr.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) $(TM_P_H)\n cp/pt.o: cp/pt.c $(CXX_TREE_H) $(TM_H) cp/decl.h cp/cp-objcp-common.h \\\n   toplev.h $(TREE_INLINE_H) pointer-set.h gt-cp-pt.h intl.h \\\n-  c-family/c-objc.h\n+  c-family/c-objc.h cp/type-utils.h\n cp/error.o: cp/error.c $(CXX_TREE_H) $(TM_H) $(DIAGNOSTIC_H) \\\n   $(FLAGS_H) $(REAL_H) $(LANGHOOKS_DEF_H) $(CXX_PRETTY_PRINT_H) \\\n   tree-diagnostic.h tree-pretty-print.h pointer-set.h c-family/c-objc.h\n@@ -339,7 +339,8 @@ cp/mangle.o: cp/mangle.c $(CXX_TREE_H) $(TM_H) $(REAL_H) \\\n   gt-cp-mangle.h $(TARGET_H) $(TM_P_H) $(CGRAPH_H)\n cp/parser.o: cp/parser.c $(CXX_TREE_H) $(TM_H) $(DIAGNOSTIC_CORE_H) \\\n   gt-cp-parser.h $(TARGET_H) $(PLUGIN_H) intl.h cp/decl.h \\\n-  c-family/c-objc.h tree-pretty-print.h $(CXX_PARSER_H) $(TIMEVAR_H)\n+  c-family/c-objc.h tree-pretty-print.h $(CXX_PARSER_H) $(TIMEVAR_H) \\\n+  cp/type-utils.h\n cp/cp-gimplify.o: cp/cp-gimplify.c $(CXX_TREE_H) $(C_COMMON_H) \\\n \t$(TM_H) coretypes.h pointer-set.h tree-iterator.h $(SPLAY_TREE_H)\n cp/vtable-class-hierarchy.o: cp/vtable-class-hierarchy.c \\"}, {"sha": "19e62727990bb7139ccc379c71b50e31c53c5857", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/984417a0ae5aec2b3ef771b52d9d41b01c77ff02/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/984417a0ae5aec2b3ef771b52d9d41b01c77ff02/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=984417a0ae5aec2b3ef771b52d9d41b01c77ff02", "patch": "@@ -5455,10 +5455,12 @@ extern tree make_auto\t\t\t\t(void);\n extern tree make_decltype_auto\t\t\t(void);\n extern tree do_auto_deduction\t\t\t(tree, tree, tree);\n extern tree type_uses_auto\t\t\t(tree);\n+extern tree type_uses_auto_or_concept\t\t(tree);\n extern void append_type_to_template_for_access_check (tree, tree, tree,\n \t\t\t\t\t\t      location_t);\n extern tree splice_late_return_type\t\t(tree, tree);\n extern bool is_auto\t\t\t\t(const_tree);\n+extern bool is_auto_or_concept\t\t\t(const_tree);\n extern tree process_template_parm\t\t(tree, location_t, tree, \n \t\t\t\t\t\t bool, bool);\n extern tree end_template_parm_list\t\t(tree);"}, {"sha": "6e026b2e01670e281b2da97f6dbd42e607927a08", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/984417a0ae5aec2b3ef771b52d9d41b01c77ff02/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/984417a0ae5aec2b3ef771b52d9d41b01c77ff02/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=984417a0ae5aec2b3ef771b52d9d41b01c77ff02", "patch": "@@ -10320,8 +10320,23 @@ grokdeclarator (const cp_declarator *declarator,\n \n       if (type_uses_auto (type))\n \t{\n-\t  error (\"parameter declared %<auto%>\");\n-\t  type = error_mark_node;\n+\t  if (current_class_type && LAMBDA_TYPE_P (current_class_type))\n+\t    {\n+\t      if (cxx_dialect < cxx1y)\n+\t\tpedwarn (location_of (type), 0,\n+\t\t\t \"use of %<auto%> in lambda parameter declaration \"\n+\t\t\t \"only available with \"\n+\t\t\t \"-std=c++1y or -std=gnu++1y\");\n+\t    }\n+\t  else if (cxx_dialect < cxx1y)\n+\t    pedwarn (location_of (type), 0,\n+\t\t     \"use of %<auto%> in parameter declaration \"\n+\t\t     \"only available with \"\n+\t\t     \"-std=c++1y or -std=gnu++1y\");\n+\t  else\n+\t    pedwarn (location_of (type), OPT_Wpedantic,\n+\t\t     \"ISO C++ forbids use of %<auto%> in parameter \"\n+\t\t     \"declaration\");\n \t}\n \n       /* A parameter declared as an array of T is really a pointer to T."}, {"sha": "5dbae7536fbc34f24d59edea4aebbc63ae7862ae", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 188, "deletions": 7, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/984417a0ae5aec2b3ef771b52d9d41b01c77ff02/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/984417a0ae5aec2b3ef771b52d9d41b01c77ff02/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=984417a0ae5aec2b3ef771b52d9d41b01c77ff02", "patch": "@@ -38,6 +38,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"plugin.h\"\n #include \"tree-pretty-print.h\"\n #include \"parser.h\"\n+#include \"type-utils.h\"\n \n \f\n /* The lexer.  */\n@@ -2063,6 +2064,11 @@ static vec<constructor_elt, va_gc> *cp_parser_initializer_list\n static bool cp_parser_ctor_initializer_opt_and_function_body\n   (cp_parser *, bool);\n \n+static tree add_implicit_template_parms\n+  (cp_parser *, size_t, tree);\n+static tree finish_fully_implicit_template\n+  (cp_parser *, tree);\n+\n /* Classes [gram.class] */\n \n static tree cp_parser_class_name\n@@ -3385,6 +3391,9 @@ cp_parser_new (void)\n   /* No template parameters apply.  */\n   parser->num_template_parameter_lists = 0;\n \n+  /* Not declaring an implicit function template.  */\n+  parser->fully_implicit_function_template_p = false;\n+\n   return parser;\n }\n \n@@ -8549,10 +8558,12 @@ cp_parser_lambda_expression (cp_parser* parser)\n         = parser->num_template_parameter_lists;\n     unsigned char in_statement = parser->in_statement;\n     bool in_switch_statement_p = parser->in_switch_statement_p;\n+    bool fully_implicit_function_template_p = parser->fully_implicit_function_template_p;\n \n     parser->num_template_parameter_lists = 0;\n     parser->in_statement = 0;\n     parser->in_switch_statement_p = false;\n+    parser->fully_implicit_function_template_p = false;\n \n     /* By virtue of defining a local class, a lambda expression has access to\n        the private variables of enclosing classes.  */\n@@ -8576,6 +8587,7 @@ cp_parser_lambda_expression (cp_parser* parser)\n     parser->num_template_parameter_lists = saved_num_template_parameter_lists;\n     parser->in_statement = in_statement;\n     parser->in_switch_statement_p = in_switch_statement_p;\n+    parser->fully_implicit_function_template_p = fully_implicit_function_template_p;\n   }\n \n   pop_deferring_access_checks ();\n@@ -8920,6 +8932,8 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n \t    finish_template_decl (template_param_list);\n \t    --parser->num_template_parameter_lists;\n \t  }\n+\telse if (parser->fully_implicit_function_template_p)\n+\t  fco = finish_fully_implicit_template (parser, fco);\n       }\n \n     finish_member_declaration (fco);\n@@ -16790,8 +16804,10 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t      /* Parse the parameter-declaration-clause.  */\n \t      params = cp_parser_parameter_declaration_clause (parser);\n \n+\t      /* Restore saved template parameter lists accounting for implicit\n+\t\t template parameters.  */\n \t      parser->num_template_parameter_lists\n-\t\t= saved_num_template_parameter_lists;\n+\t\t+= saved_num_template_parameter_lists;\n \n \t      /* Consume the `)'.  */\n \t      cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n@@ -17889,6 +17905,7 @@ cp_parser_parameter_declaration_list (cp_parser* parser, bool *is_error)\n   tree *tail = &parameters; \n   bool saved_in_unbraced_linkage_specification_p;\n   int index = 0;\n+  int implicit_template_parms = 0;\n \n   /* Assume all will go well.  */\n   *is_error = false;\n@@ -17916,11 +17933,18 @@ cp_parser_parameter_declaration_list (cp_parser* parser, bool *is_error)\n       deprecated_state = DEPRECATED_SUPPRESS;\n \n       if (parameter)\n-\tdecl = grokdeclarator (parameter->declarator,\n-\t\t\t       &parameter->decl_specifiers,\n-\t\t\t       PARM,\n-\t\t\t       parameter->default_argument != NULL_TREE,\n-\t\t\t       &parameter->decl_specifiers.attributes);\n+\t{\n+\t  decl = grokdeclarator (parameter->declarator,\n+\t\t\t\t &parameter->decl_specifiers,\n+\t\t\t\t PARM,\n+\t\t\t\t parameter->default_argument != NULL_TREE,\n+\t\t\t\t &parameter->decl_specifiers.attributes);\n+\n+\t  if (TREE_TYPE (decl) != error_mark_node\n+\t      && parameter->decl_specifiers.type\n+\t      && is_auto_or_concept (parameter->decl_specifiers.type))\n+\t      ++implicit_template_parms;\n+\t}\n \n       deprecated_state = DEPRECATED_NORMAL;\n \n@@ -18008,6 +18032,11 @@ cp_parser_parameter_declaration_list (cp_parser* parser, bool *is_error)\n   parser->in_unbraced_linkage_specification_p\n     = saved_in_unbraced_linkage_specification_p;\n \n+  if (parameters != error_mark_node && implicit_template_parms)\n+    parameters = add_implicit_template_parms (parser,\n+\t\t\t\t\t      implicit_template_parms,\n+\t\t\t\t\t      parameters);\n+\n   return parameters;\n }\n \n@@ -20014,7 +20043,11 @@ cp_parser_member_declaration (cp_parser* parser)\n \t\t\t\t\t\t\t      attributes);\n \t\t  /* If the member was not a friend, declare it here.  */\n \t\t  if (!friend_p)\n-\t\t    finish_member_declaration (decl);\n+\t\t    {\n+\t\t      if (parser->fully_implicit_function_template_p)\n+\t\t\tdecl = finish_fully_implicit_template (parser, decl);\n+\t\t      finish_member_declaration (decl);\n+\t\t    }\n \t\t  /* Peek at the next token.  */\n \t\t  token = cp_lexer_peek_token (parser->lexer);\n \t\t  /* If the next token is a semicolon, consume it.  */\n@@ -20030,6 +20063,8 @@ cp_parser_member_declaration (cp_parser* parser)\n \t\t\t\t  initializer, /*init_const_expr_p=*/true,\n \t\t\t\t  asm_specification,\n \t\t\t\t  attributes);\n+\t\tif (parser->fully_implicit_function_template_p)\n+\t\t  decl = finish_fully_implicit_template (parser, decl);\n \t    }\n \n \t  /* Reset PREFIX_ATTRIBUTES.  */\n@@ -22297,6 +22332,9 @@ cp_parser_function_definition_after_declarator (cp_parser* parser,\n     = saved_num_template_parameter_lists;\n   parser->in_function_body = saved_in_function_body;\n \n+  if (parser->fully_implicit_function_template_p)\n+    finish_fully_implicit_template (parser, /*member_decl_opt=*/0);\n+\n   return fn;\n }\n \n@@ -28842,4 +28880,147 @@ c_parse_file (void)\n   the_parser = NULL;\n }\n \n+/* Create an identifier for a generic parameter type (a synthesized\n+   template parameter implied by `auto' or a concept identifier). */\n+\n+static tree\n+make_generic_type_name (int i)\n+{\n+  char buf[32];\n+  sprintf (buf, \"__GenT%d\", i);\n+  return get_identifier (buf);\n+}\n+\n+/* Predicate that behaves as is_auto_or_concept but matches the parent\n+   node of the generic type rather than the generic type itself.  This\n+   allows for type transformation in add_implicit_template_parms.  */\n+\n+static inline bool\n+tree_type_is_auto_or_concept (const_tree t)\n+{\n+  return TREE_TYPE (t) && is_auto_or_concept (TREE_TYPE (t));\n+}\n+\n+/* Add COUNT implicit template parameters gleaned from the generic\n+   type parameters in PARAMETERS to the CURRENT_TEMPLATE_PARMS\n+   (creating a new template parameter list if necessary).  Returns\n+   PARAMETERS suitably rewritten to reference the newly created types\n+   or ERROR_MARK_NODE on failure.  */\n+\n+tree\n+add_implicit_template_parms (cp_parser *parser, size_t count, tree parameters)\n+{\n+  gcc_assert (current_binding_level->kind == sk_function_parms);\n+\n+  cp_binding_level *fn_parms_scope = current_binding_level;\n+\n+  bool become_template =\n+    fn_parms_scope->level_chain->kind != sk_template_parms;\n+\n+  size_t synth_idx = 0;\n+\n+  /* Roll back a scope level and either introduce a new template parameter list\n+     or update an existing one.  The function scope is added back after template\n+     parameter synthesis below.  */\n+  current_binding_level = fn_parms_scope->level_chain;\n+\n+  /* TPARMS tracks the function's template parameter list.  This is either a new\n+     chain in the case of a fully implicit function template or an extension of\n+     the function's explicitly specified template parameter list.  */\n+  tree tparms = NULL_TREE;\n+\n+  if (become_template)\n+    {\n+      push_deferring_access_checks (dk_deferred);\n+      begin_template_parm_list ();\n+\n+      parser->fully_implicit_function_template_p = true;\n+      ++parser->num_template_parameter_lists;\n+    }\n+  else\n+    {\n+      /* Roll back the innermost template parameter list such that it may be\n+\t extended in the loop below as if it were being explicitly declared.  */\n+\n+      gcc_assert (current_template_parms);\n+\n+      /* Pop the innermost template parms into TPARMS.  */\n+      tree inner_vec = INNERMOST_TEMPLATE_PARMS (current_template_parms);\n+      current_template_parms = TREE_CHAIN (current_template_parms);\n+\n+      size_t inner_vec_len = TREE_VEC_LENGTH (inner_vec);\n+      if (inner_vec_len != 0)\n+\t{\n+\t  tree t = tparms = TREE_VEC_ELT (inner_vec, 0);\n+\t  for (size_t n = 1; n < inner_vec_len; ++n)\n+\t    t = TREE_CHAIN (t) = TREE_VEC_ELT (inner_vec, n);\n+\t}\n+\n+      ++processing_template_parmlist;\n+    }\n+\n+  for (tree p = parameters; p && synth_idx < count; p = TREE_CHAIN (p))\n+    {\n+      tree generic_type_ptr\n+\t= find_type_usage (TREE_VALUE (p), tree_type_is_auto_or_concept);\n+\n+      if (!generic_type_ptr)\n+\tcontinue;\n+\n+      tree synth_id = make_generic_type_name (synth_idx++);\n+      tree synth_tmpl_parm = finish_template_type_parm (class_type_node,\n+\t\t\t\t\t\t\tsynth_id);\n+      tparms = process_template_parm (tparms, DECL_SOURCE_LOCATION (TREE_VALUE\n+\t\t\t\t\t\t\t\t    (p)),\n+\t\t\t\t      build_tree_list (NULL_TREE,\n+\t\t\t\t\t\t       synth_tmpl_parm),\n+\t\t\t\t      /*non_type=*/false,\n+\t\t\t\t      /*param_pack=*/false);\n+\n+      /* Rewrite the type of P to be the template_parm added above (getdecls is\n+         used to retrieve it since it is the most recent declaration in this\n+         scope).  Qualifiers need to be preserved also.  */\n+\n+      tree& cur_type = TREE_TYPE (generic_type_ptr);\n+      tree new_type = TREE_TYPE (getdecls ());\n+\n+      if (TYPE_QUALS (cur_type))\n+\tcur_type = cp_build_qualified_type (new_type, TYPE_QUALS (cur_type));\n+      else\n+\tcur_type = new_type;\n+    }\n+\n+  gcc_assert (synth_idx == count);\n+\n+  push_binding_level (fn_parms_scope);\n+\n+  end_template_parm_list (tparms);\n+\n+  return parameters;\n+}\n+\n+/* Finish the declaration of a fully implicit function template.  Such a\n+   template has no explicit template parameter list so has not been through the\n+   normal template head and tail processing.  add_implicit_template_parms tries\n+   to do the head; this tries to do the tail.  MEMBER_DECL_OPT should be\n+   provided if the declaration is a class member such that its template\n+   declaration can be completed.  If MEMBER_DECL_OPT is provided the finished\n+   form is returned.  Otherwise NULL_TREE is returned. */\n+\n+tree\n+finish_fully_implicit_template (cp_parser *parser, tree member_decl_opt)\n+{\n+  gcc_assert (parser->fully_implicit_function_template_p);\n+\n+  pop_deferring_access_checks ();\n+  if (member_decl_opt)\n+    member_decl_opt = finish_member_template_decl (member_decl_opt);\n+  end_template_decl ();\n+\n+  parser->fully_implicit_function_template_p = false;\n+  --parser->num_template_parameter_lists;\n+\n+  return member_decl_opt;\n+}\n+\n #include \"gt-cp-parser.h\""}, {"sha": "ffdddaf4a08f25d8b55a1b64b1f8d1f5b1907111", "filename": "gcc/cp/parser.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/984417a0ae5aec2b3ef771b52d9d41b01c77ff02/gcc%2Fcp%2Fparser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/984417a0ae5aec2b3ef771b52d9d41b01c77ff02/gcc%2Fcp%2Fparser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.h?ref=984417a0ae5aec2b3ef771b52d9d41b01c77ff02", "patch": "@@ -341,6 +341,12 @@ typedef struct GTY(()) cp_parser {\n   /* The number of template parameter lists that apply directly to the\n      current declaration.  */\n   unsigned num_template_parameter_lists;\n+\n+  /* TRUE if the function being declared was made a template due to its\n+     parameter list containing generic type specifiers (`auto' or concept\n+     identifiers) rather than an explicit template parameter list.  */\n+  bool fully_implicit_function_template_p;\n+\n } cp_parser;\n \n /* In parser.c  */"}, {"sha": "de1022efec27dfc1a4b74ec7f872527b35e4946a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/984417a0ae5aec2b3ef771b52d9d41b01c77ff02/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/984417a0ae5aec2b3ef771b52d9d41b01c77ff02/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=984417a0ae5aec2b3ef771b52d9d41b01c77ff02", "patch": "@@ -41,6 +41,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"toplev.h\"\n #include \"timevar.h\"\n #include \"tree-iterator.h\"\n+#include \"type-utils.h\"\n \n /* The type of functions taking a tree, and some additional data, and\n    returning an int.  */\n@@ -21110,31 +21111,35 @@ is_auto (const_tree type)\n     return false;\n }\n \n-/* Returns true iff TYPE contains a use of 'auto'.  Since auto can only\n-   appear as a type-specifier for the declaration in question, we don't\n-   have to look through the whole type.  */\n+/* Returns the TEMPLATE_TYPE_PARM in TYPE representing `auto' iff TYPE contains\n+   a use of `auto'.  Returns NULL_TREE otherwise.  */\n \n tree\n type_uses_auto (tree type)\n {\n-  enum tree_code code;\n-  if (is_auto (type))\n-    return type;\n+  return find_type_usage (type, is_auto);\n+}\n \n-  code = TREE_CODE (type);\n+/* Returns true iff TYPE is a TEMPLATE_TYPE_PARM representing 'auto',\n+   'decltype(auto)' or a concept.  */\n \n-  if (code == POINTER_TYPE || code == REFERENCE_TYPE\n-      || code == OFFSET_TYPE || code == FUNCTION_TYPE\n-      || code == METHOD_TYPE || code == ARRAY_TYPE)\n-    return type_uses_auto (TREE_TYPE (type));\n+bool\n+is_auto_or_concept (const_tree type)\n+{\n+  return is_auto (type); // or concept\n+}\n \n-  if (TYPE_PTRMEMFUNC_P (type))\n-    return type_uses_auto (TREE_TYPE (TREE_TYPE\n-\t\t\t\t   (TYPE_PTRMEMFUNC_FN_TYPE (type))));\n+/* Returns the TEMPLATE_TYPE_PARM in TYPE representing a generic type (`auto' or\n+   a concept identifier) iff TYPE contains a use of a generic type.  Returns\n+   NULL_TREE otherwise.  */\n \n-  return NULL_TREE;\n+tree\n+type_uses_auto_or_concept (tree type)\n+{\n+  return find_type_usage (type, is_auto_or_concept);\n }\n \n+\n /* For a given template T, return the vector of typedefs referenced\n    in T for which access check is needed at T instantiation time.\n    T is either  a FUNCTION_DECL or a RECORD_TYPE."}, {"sha": "3e82ca4f9576b7d25d76f71eb888689d432e01b6", "filename": "gcc/cp/type-utils.h", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/984417a0ae5aec2b3ef771b52d9d41b01c77ff02/gcc%2Fcp%2Ftype-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/984417a0ae5aec2b3ef771b52d9d41b01c77ff02/gcc%2Fcp%2Ftype-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftype-utils.h?ref=984417a0ae5aec2b3ef771b52d9d41b01c77ff02", "patch": "@@ -0,0 +1,55 @@\n+/* Utilities for querying and manipulating type trees.\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_CP_TYPE_UTILS_H\n+#define GCC_CP_TYPE_UTILS_H\n+\n+/* Returns the first tree within T that is directly matched by PRED.  T may be a\n+   type or PARM_DECL and is incrementally decomposed toward its type-specifier\n+   until a match is found.  NULL_TREE is returned if PRED does not match any\n+   part of T.\n+\n+   This is primarily intended for detecting whether T uses `auto' or a concept\n+   identifier.  Since either of these can only appear as a type-specifier for\n+   the declaration in question, only top-level qualifications are traversed;\n+   find_type_usage does not look through the whole type.  */\n+\n+inline tree\n+find_type_usage (tree t, bool (*pred) (const_tree))\n+{\n+  enum tree_code code;\n+  if (pred (t))\n+    return t;\n+\n+  code = TREE_CODE (t);\n+\n+  if (code == POINTER_TYPE || code == REFERENCE_TYPE\n+      || code == PARM_DECL || code == OFFSET_TYPE\n+      || code == FUNCTION_TYPE || code == METHOD_TYPE\n+      || code == ARRAY_TYPE)\n+    return find_type_usage (TREE_TYPE (t), pred);\n+\n+  if (TYPE_PTRMEMFUNC_P (t))\n+    return find_type_usage\n+      (TREE_TYPE (TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (t))), pred);\n+\n+  return NULL_TREE;\n+}\n+\n+#endif // GCC_CP_TYPE_UTILS_H"}]}