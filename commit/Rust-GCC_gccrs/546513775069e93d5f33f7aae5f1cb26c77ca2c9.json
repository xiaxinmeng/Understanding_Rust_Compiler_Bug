{"sha": "546513775069e93d5f33f7aae5f1cb26c77ca2c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQ2NTEzNzc1MDY5ZTkzZDVmMzNmN2FhZTVmMWNiMjZjNzdjYTJjOQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-30T11:12:14Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:12:14Z"}, "message": "[28/77] Use is_a <scalar_int_mode> for miscellaneous types of test\n\nThis patch adds is_a <scalar_int_mode> checks to various places\nthat were explicitly or implicitly restricted to integers already,\nin cases where adding an explicit is_a <scalar_int_mode> is useful\nfor later patches.\n\nIn simplify_if_then_else, the:\n\n  GET_MODE (XEXP (XEXP (t, 0), N))\n\nexpressions were equivalent to:\n\n  GET_MODE (XEXP (t, 0))\n\ndue to the type of operation.\n\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* combine.c (sign_extend_short_imm): Add is_a <scalar_int_mode>\n\tchecks.\n\t(try_combine): Likewise.\n\t(simplify_if_then_else): Likewise.\n\t* cse.c (cse_insn): Likewise.\n\t* dwarf2out.c (mem_loc_descriptor): Likewise.\n\t* emit-rtl.c (gen_lowpart_common): Likewise.\n\t* simplify-rtx.c (simplify_truncation): Likewise.\n\t(simplify_binary_operation_1): Likewise.\n\t(simplify_const_relational_operation): Likewise.\n\t(simplify_ternary_operation): Likewise.\n\t* tree-ssa-loop-ivopts.c (force_expr_to_var_cost): Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251480", "tree": {"sha": "8a383584e324e07a123acf20a153583961e949e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a383584e324e07a123acf20a153583961e949e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/546513775069e93d5f33f7aae5f1cb26c77ca2c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/546513775069e93d5f33f7aae5f1cb26c77ca2c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/546513775069e93d5f33f7aae5f1cb26c77ca2c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/546513775069e93d5f33f7aae5f1cb26c77ca2c9/comments", "author": null, "committer": null, "parents": [{"sha": "095a49c86a8ac69b5dd6d78edf17b9e3803e5bf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/095a49c86a8ac69b5dd6d78edf17b9e3803e5bf8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/095a49c86a8ac69b5dd6d78edf17b9e3803e5bf8"}], "stats": {"total": 185, "additions": 109, "deletions": 76}, "files": [{"sha": "ba1cd302c1a3bf69be2db3e23bbacfe34b25157e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/546513775069e93d5f33f7aae5f1cb26c77ca2c9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/546513775069e93d5f33f7aae5f1cb26c77ca2c9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=546513775069e93d5f33f7aae5f1cb26c77ca2c9", "patch": "@@ -1,3 +1,20 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* combine.c (sign_extend_short_imm): Add is_a <scalar_int_mode>\n+\tchecks.\n+\t(try_combine): Likewise.\n+\t(simplify_if_then_else): Likewise.\n+\t* cse.c (cse_insn): Likewise.\n+\t* dwarf2out.c (mem_loc_descriptor): Likewise.\n+\t* emit-rtl.c (gen_lowpart_common): Likewise.\n+\t* simplify-rtx.c (simplify_truncation): Likewise.\n+\t(simplify_binary_operation_1): Likewise.\n+\t(simplify_const_relational_operation): Likewise.\n+\t(simplify_ternary_operation): Likewise.\n+\t* tree-ssa-loop-ivopts.c (force_expr_to_var_cost): Likewise.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "f2a5388de0e8cce136903d0319d53bce53bde908", "filename": "gcc/combine.c", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/546513775069e93d5f33f7aae5f1cb26c77ca2c9/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/546513775069e93d5f33f7aae5f1cb26c77ca2c9/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=546513775069e93d5f33f7aae5f1cb26c77ca2c9", "patch": "@@ -1636,11 +1636,13 @@ setup_incoming_promotions (rtx_insn *first)\n static rtx\n sign_extend_short_imm (rtx src, machine_mode mode, unsigned int prec)\n {\n-  if (GET_MODE_PRECISION (mode) < prec\n-      && CONST_INT_P (src)\n+  scalar_int_mode int_mode;\n+  if (CONST_INT_P (src)\n+      && is_a <scalar_int_mode> (mode, &int_mode)\n+      && GET_MODE_PRECISION (int_mode) < prec\n       && INTVAL (src) > 0\n-      && val_signbit_known_set_p (mode, INTVAL (src)))\n-    src = GEN_INT (INTVAL (src) | ~GET_MODE_MASK (mode));\n+      && val_signbit_known_set_p (int_mode, INTVAL (src)))\n+    src = GEN_INT (INTVAL (src) | ~GET_MODE_MASK (int_mode));\n \n   return src;\n }\n@@ -3166,6 +3168,7 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n       rtx op0 = i2src, op1 = XEXP (SET_SRC (PATTERN (i3)), 1);\n       machine_mode compare_mode, orig_compare_mode;\n       enum rtx_code compare_code = UNKNOWN, orig_compare_code = UNKNOWN;\n+      scalar_int_mode mode;\n \n       newpat = PATTERN (i3);\n       newpat_dest = SET_DEST (newpat);\n@@ -3176,8 +3179,9 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \t\t\t\t\t    &cc_use_insn)))\n \t{\n \t  compare_code = orig_compare_code = GET_CODE (*cc_use_loc);\n-\t  compare_code = simplify_compare_const (compare_code,\n-\t\t\t\t\t\t GET_MODE (i2dest), op0, &op1);\n+\t  if (is_a <scalar_int_mode> (GET_MODE (i2dest), &mode))\n+\t    compare_code = simplify_compare_const (compare_code, mode,\n+\t\t\t\t\t\t   op0, &op1);\n \t  target_canonicalize_comparison (&compare_code, &op0, &op1, 1);\n \t}\n \n@@ -6288,7 +6292,7 @@ simplify_if_then_else (rtx x)\n   int i;\n   enum rtx_code false_code;\n   rtx reversed;\n-  scalar_int_mode int_mode;\n+  scalar_int_mode int_mode, inner_mode;\n \n   /* Simplify storing of the truth value.  */\n   if (comparison_p && true_rtx == const_true_rtx && false_rtx == const0_rtx)\n@@ -6500,6 +6504,7 @@ simplify_if_then_else (rtx x)\n \t       && rtx_equal_p (XEXP (t, 1), f))\n \tc1 = XEXP (t, 0), op = GET_CODE (t), z = f;\n       else if (GET_CODE (t) == SIGN_EXTEND\n+\t       && is_a <scalar_int_mode> (GET_MODE (XEXP (t, 0)), &inner_mode)\n \t       && (GET_CODE (XEXP (t, 0)) == PLUS\n \t\t   || GET_CODE (XEXP (t, 0)) == MINUS\n \t\t   || GET_CODE (XEXP (t, 0)) == IOR\n@@ -6513,13 +6518,14 @@ simplify_if_then_else (rtx x)\n \t       && (num_sign_bit_copies (f, GET_MODE (f))\n \t\t   > (unsigned int)\n \t\t     (GET_MODE_PRECISION (int_mode)\n-\t\t      - GET_MODE_PRECISION (GET_MODE (XEXP (XEXP (t, 0), 0))))))\n+\t\t      - GET_MODE_PRECISION (inner_mode))))\n \t{\n \t  c1 = XEXP (XEXP (t, 0), 1); z = f; op = GET_CODE (XEXP (t, 0));\n \t  extend_op = SIGN_EXTEND;\n-\t  m = GET_MODE (XEXP (t, 0));\n+\t  m = inner_mode;\n \t}\n       else if (GET_CODE (t) == SIGN_EXTEND\n+\t       && is_a <scalar_int_mode> (GET_MODE (XEXP (t, 0)), &inner_mode)\n \t       && (GET_CODE (XEXP (t, 0)) == PLUS\n \t\t   || GET_CODE (XEXP (t, 0)) == IOR\n \t\t   || GET_CODE (XEXP (t, 0)) == XOR)\n@@ -6529,13 +6535,14 @@ simplify_if_then_else (rtx x)\n \t       && (num_sign_bit_copies (f, GET_MODE (f))\n \t\t   > (unsigned int)\n \t\t     (GET_MODE_PRECISION (int_mode)\n-\t\t      - GET_MODE_PRECISION (GET_MODE (XEXP (XEXP (t, 0), 1))))))\n+\t\t      - GET_MODE_PRECISION (inner_mode))))\n \t{\n \t  c1 = XEXP (XEXP (t, 0), 0); z = f; op = GET_CODE (XEXP (t, 0));\n \t  extend_op = SIGN_EXTEND;\n-\t  m = GET_MODE (XEXP (t, 0));\n+\t  m = inner_mode;\n \t}\n       else if (GET_CODE (t) == ZERO_EXTEND\n+\t       && is_a <scalar_int_mode> (GET_MODE (XEXP (t, 0)), &inner_mode)\n \t       && (GET_CODE (XEXP (t, 0)) == PLUS\n \t\t   || GET_CODE (XEXP (t, 0)) == MINUS\n \t\t   || GET_CODE (XEXP (t, 0)) == IOR\n@@ -6548,14 +6555,15 @@ simplify_if_then_else (rtx x)\n \t       && subreg_lowpart_p (XEXP (XEXP (t, 0), 0))\n \t       && rtx_equal_p (SUBREG_REG (XEXP (XEXP (t, 0), 0)), f)\n \t       && ((nonzero_bits (f, GET_MODE (f))\n-\t\t    & ~GET_MODE_MASK (GET_MODE (XEXP (XEXP (t, 0), 0))))\n+\t\t    & ~GET_MODE_MASK (inner_mode))\n \t\t   == 0))\n \t{\n \t  c1 = XEXP (XEXP (t, 0), 1); z = f; op = GET_CODE (XEXP (t, 0));\n \t  extend_op = ZERO_EXTEND;\n-\t  m = GET_MODE (XEXP (t, 0));\n+\t  m = inner_mode;\n \t}\n       else if (GET_CODE (t) == ZERO_EXTEND\n+\t       && is_a <scalar_int_mode> (GET_MODE (XEXP (t, 0)), &inner_mode)\n \t       && (GET_CODE (XEXP (t, 0)) == PLUS\n \t\t   || GET_CODE (XEXP (t, 0)) == IOR\n \t\t   || GET_CODE (XEXP (t, 0)) == XOR)\n@@ -6564,12 +6572,12 @@ simplify_if_then_else (rtx x)\n \t       && subreg_lowpart_p (XEXP (XEXP (t, 0), 1))\n \t       && rtx_equal_p (SUBREG_REG (XEXP (XEXP (t, 0), 1)), f)\n \t       && ((nonzero_bits (f, GET_MODE (f))\n-\t\t    & ~GET_MODE_MASK (GET_MODE (XEXP (XEXP (t, 0), 1))))\n+\t\t    & ~GET_MODE_MASK (inner_mode))\n \t\t   == 0))\n \t{\n \t  c1 = XEXP (XEXP (t, 0), 0); z = f; op = GET_CODE (XEXP (t, 0));\n \t  extend_op = ZERO_EXTEND;\n-\t  m = GET_MODE (XEXP (t, 0));\n+\t  m = inner_mode;\n \t}\n \n       if (z)\n@@ -6613,17 +6621,17 @@ simplify_if_then_else (rtx x)\n      non-zero bit in A is C1.  */\n   if (true_code == NE && XEXP (cond, 1) == const0_rtx\n       && false_rtx == const0_rtx && CONST_INT_P (true_rtx)\n-      && INTEGRAL_MODE_P (GET_MODE (XEXP (cond, 0)))\n-      && (UINTVAL (true_rtx) & GET_MODE_MASK (mode))\n-\t  == nonzero_bits (XEXP (cond, 0), GET_MODE (XEXP (cond, 0)))\n-      && (i = exact_log2 (UINTVAL (true_rtx) & GET_MODE_MASK (mode))) >= 0)\n+      && is_a <scalar_int_mode> (mode, &int_mode)\n+      && is_a <scalar_int_mode> (GET_MODE (XEXP (cond, 0)), &inner_mode)\n+      && (UINTVAL (true_rtx) & GET_MODE_MASK (int_mode))\n+\t  == nonzero_bits (XEXP (cond, 0), inner_mode)\n+      && (i = exact_log2 (UINTVAL (true_rtx) & GET_MODE_MASK (int_mode))) >= 0)\n     {\n       rtx val = XEXP (cond, 0);\n-      machine_mode val_mode = GET_MODE (val);\n-      if (val_mode == mode)\n+      if (inner_mode == int_mode)\n         return val;\n-      else if (GET_MODE_PRECISION (val_mode) < GET_MODE_PRECISION (mode))\n-        return simplify_gen_unary (ZERO_EXTEND, mode, val, val_mode);\n+      else if (GET_MODE_PRECISION (inner_mode) < GET_MODE_PRECISION (int_mode))\n+        return simplify_gen_unary (ZERO_EXTEND, int_mode, val, inner_mode);\n     }\n \n   return x;"}, {"sha": "02f5fc3479511636b984d6287d5dfae45aad22d6", "filename": "gcc/cse.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/546513775069e93d5f33f7aae5f1cb26c77ca2c9/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/546513775069e93d5f33f7aae5f1cb26c77ca2c9/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=546513775069e93d5f33f7aae5f1cb26c77ca2c9", "patch": "@@ -4878,13 +4878,14 @@ cse_insn (rtx_insn *insn)\n \t value.  */\n \n       if (flag_expensive_optimizations && ! src_related\n+\t  && is_a <scalar_int_mode> (mode, &int_mode)\n \t  && GET_CODE (src) == AND && CONST_INT_P (XEXP (src, 1))\n-\t  && GET_MODE_SIZE (mode) < UNITS_PER_WORD)\n+\t  && GET_MODE_SIZE (int_mode) < UNITS_PER_WORD)\n \t{\n \t  machine_mode tmode;\n \t  rtx new_and = gen_rtx_AND (VOIDmode, NULL_RTX, XEXP (src, 1));\n \n-\t  FOR_EACH_WIDER_MODE (tmode, mode)\n+\t  FOR_EACH_WIDER_MODE (tmode, int_mode)\n \t    {\n \t      if (GET_MODE_SIZE (tmode) > UNITS_PER_WORD)\n \t\tbreak;\n@@ -4905,7 +4906,7 @@ cse_insn (rtx_insn *insn)\n \t\t    if (REG_P (larger_elt->exp))\n \t\t      {\n \t\t\tsrc_related\n-\t\t\t  = gen_lowpart (mode, larger_elt->exp);\n+\t\t\t  = gen_lowpart (int_mode, larger_elt->exp);\n \t\t\tbreak;\n \t\t      }\n "}, {"sha": "0637bddbb253fc21ee2b4dba5d657030e5ae35e3", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/546513775069e93d5f33f7aae5f1cb26c77ca2c9/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/546513775069e93d5f33f7aae5f1cb26c77ca2c9/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=546513775069e93d5f33f7aae5f1cb26c77ca2c9", "patch": "@@ -14824,31 +14824,29 @@ mem_loc_descriptor (rtx rtl, machine_mode mode,\n \n     case SIGN_EXTEND:\n     case ZERO_EXTEND:\n-      if (!is_a <scalar_int_mode> (mode, &int_mode))\n+      if (!is_a <scalar_int_mode> (mode, &int_mode)\n+\t  || !is_a <scalar_int_mode> (GET_MODE (XEXP (rtl, 0)), &inner_mode))\n \tbreak;\n-      op0 = mem_loc_descriptor (XEXP (rtl, 0), GET_MODE (XEXP (rtl, 0)),\n+      op0 = mem_loc_descriptor (XEXP (rtl, 0), inner_mode,\n \t\t\t\tmem_mode, VAR_INIT_STATUS_INITIALIZED);\n       if (op0 == 0)\n \tbreak;\n       else if (GET_CODE (rtl) == ZERO_EXTEND\n \t       && GET_MODE_SIZE (int_mode) <= DWARF2_ADDR_SIZE\n-\t       && GET_MODE_BITSIZE (GET_MODE (XEXP (rtl, 0)))\n-\t\t  < HOST_BITS_PER_WIDE_INT\n+\t       && GET_MODE_BITSIZE (inner_mode) < HOST_BITS_PER_WIDE_INT\n \t       /* If DW_OP_const{1,2,4}u won't be used, it is shorter\n \t\t  to expand zero extend as two shifts instead of\n \t\t  masking.  */\n-\t       && GET_MODE_SIZE (GET_MODE (XEXP (rtl, 0))) <= 4)\n+\t       && GET_MODE_SIZE (inner_mode) <= 4)\n \t{\n-\t  machine_mode imode = GET_MODE (XEXP (rtl, 0));\n \t  mem_loc_result = op0;\n \t  add_loc_descr (&mem_loc_result,\n-\t\t\t int_loc_descriptor (GET_MODE_MASK (imode)));\n+\t\t\t int_loc_descriptor (GET_MODE_MASK (inner_mode)));\n \t  add_loc_descr (&mem_loc_result, new_loc_descr (DW_OP_and, 0, 0));\n \t}\n       else if (GET_MODE_SIZE (int_mode) <= DWARF2_ADDR_SIZE)\n \t{\n-\t  int shift = DWARF2_ADDR_SIZE\n-\t\t      - GET_MODE_SIZE (GET_MODE (XEXP (rtl, 0)));\n+\t  int shift = DWARF2_ADDR_SIZE - GET_MODE_SIZE (inner_mode);\n \t  shift *= BITS_PER_UNIT;\n \t  if (GET_CODE (rtl) == SIGN_EXTEND)\n \t    op = DW_OP_shra;\n@@ -14865,7 +14863,7 @@ mem_loc_descriptor (rtx rtl, machine_mode mode,\n \t  dw_die_ref type_die1, type_die2;\n \t  dw_loc_descr_ref cvt;\n \n-\t  type_die1 = base_type_for_mode (GET_MODE (XEXP (rtl, 0)),\n+\t  type_die1 = base_type_for_mode (inner_mode,\n \t\t\t\t\t  GET_CODE (rtl) == ZERO_EXTEND);\n \t  if (type_die1 == NULL)\n \t    break;\n@@ -15410,14 +15408,15 @@ mem_loc_descriptor (rtx rtl, machine_mode mode,\n       if (CONST_INT_P (XEXP (rtl, 1))\n \t  && CONST_INT_P (XEXP (rtl, 2))\n \t  && is_a <scalar_int_mode> (mode, &int_mode)\n+\t  && is_a <scalar_int_mode> (GET_MODE (XEXP (rtl, 0)), &inner_mode)\n+\t  && GET_MODE_SIZE (int_mode) <= DWARF2_ADDR_SIZE\n+\t  && GET_MODE_SIZE (inner_mode) <= DWARF2_ADDR_SIZE\n \t  && ((unsigned) INTVAL (XEXP (rtl, 1))\n \t      + (unsigned) INTVAL (XEXP (rtl, 2))\n-\t      <= GET_MODE_BITSIZE (int_mode))\n-\t  && GET_MODE_SIZE (int_mode) <= DWARF2_ADDR_SIZE\n-\t  && GET_MODE_SIZE (GET_MODE (XEXP (rtl, 0))) <= DWARF2_ADDR_SIZE)\n+\t      <= GET_MODE_BITSIZE (int_mode)))\n \t{\n \t  int shift, size;\n-\t  op0 = mem_loc_descriptor (XEXP (rtl, 0), GET_MODE (XEXP (rtl, 0)),\n+\t  op0 = mem_loc_descriptor (XEXP (rtl, 0), inner_mode,\n \t\t\t\t    mem_mode, VAR_INIT_STATUS_INITIALIZED);\n \t  if (op0 == 0)\n \t    break;\n@@ -15429,8 +15428,7 @@ mem_loc_descriptor (rtx rtl, machine_mode mode,\n \t  size = INTVAL (XEXP (rtl, 1));\n \t  shift = INTVAL (XEXP (rtl, 2));\n \t  if (BITS_BIG_ENDIAN)\n-\t    shift = GET_MODE_BITSIZE (GET_MODE (XEXP (rtl, 0)))\n-\t\t    - shift - size;\n+\t    shift = GET_MODE_BITSIZE (inner_mode) - shift - size;\n \t  if (shift + size != (int) DWARF2_ADDR_SIZE)\n \t    {\n \t      add_loc_descr (&mem_loc_result,"}, {"sha": "0391bea259bc57ef723c3c50f5d9a2604fe35ce7", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/546513775069e93d5f33f7aae5f1cb26c77ca2c9/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/546513775069e93d5f33f7aae5f1cb26c77ca2c9/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=546513775069e93d5f33f7aae5f1cb26c77ca2c9", "patch": "@@ -1430,9 +1430,11 @@ gen_lowpart_common (machine_mode mode, rtx x)\n   if (SCALAR_FLOAT_MODE_P (mode) && msize > xsize)\n     return 0;\n \n+  scalar_int_mode int_mode, int_innermode, from_mode;\n   if ((GET_CODE (x) == ZERO_EXTEND || GET_CODE (x) == SIGN_EXTEND)\n-      && (GET_MODE_CLASS (mode) == MODE_INT\n-\t  || GET_MODE_CLASS (mode) == MODE_PARTIAL_INT))\n+      && is_a <scalar_int_mode> (mode, &int_mode)\n+      && is_a <scalar_int_mode> (innermode, &int_innermode)\n+      && is_a <scalar_int_mode> (GET_MODE (XEXP (x, 0)), &from_mode))\n     {\n       /* If we are getting the low-order part of something that has been\n \t sign- or zero-extended, we can either just use the object being\n@@ -1442,12 +1444,12 @@ gen_lowpart_common (machine_mode mode, rtx x)\n \n \t This case is used mostly by combine and cse.  */\n \n-      if (GET_MODE (XEXP (x, 0)) == mode)\n+      if (from_mode == int_mode)\n \treturn XEXP (x, 0);\n-      else if (msize < GET_MODE_SIZE (GET_MODE (XEXP (x, 0))))\n-\treturn gen_lowpart_common (mode, XEXP (x, 0));\n-      else if (msize < xsize)\n-\treturn gen_rtx_fmt_e (GET_CODE (x), mode, XEXP (x, 0));\n+      else if (GET_MODE_SIZE (int_mode) < GET_MODE_SIZE (from_mode))\n+\treturn gen_lowpart_common (int_mode, XEXP (x, 0));\n+      else if (GET_MODE_SIZE (int_mode) < GET_MODE_SIZE (int_innermode))\n+\treturn gen_rtx_fmt_e (GET_CODE (x), int_mode, XEXP (x, 0));\n     }\n   else if (GET_CODE (x) == SUBREG || REG_P (x)\n \t   || GET_CODE (x) == CONCAT || GET_CODE (x) == CONST_VECTOR"}, {"sha": "2255ccf1408adf85775e73111a5426dad6d32af0", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 31, "deletions": 26, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/546513775069e93d5f33f7aae5f1cb26c77ca2c9/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/546513775069e93d5f33f7aae5f1cb26c77ca2c9/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=546513775069e93d5f33f7aae5f1cb26c77ca2c9", "patch": "@@ -808,21 +808,22 @@ simplify_truncation (machine_mode mode, rtx op,\n      if the MEM has a mode-dependent address.  */\n   if ((GET_CODE (op) == LSHIFTRT\n        || GET_CODE (op) == ASHIFTRT)\n+      && is_a <scalar_int_mode> (mode, &int_mode)\n       && is_a <scalar_int_mode> (op_mode, &int_op_mode)\n       && MEM_P (XEXP (op, 0))\n       && CONST_INT_P (XEXP (op, 1))\n-      && (INTVAL (XEXP (op, 1)) % GET_MODE_BITSIZE (mode)) == 0\n+      && INTVAL (XEXP (op, 1)) % GET_MODE_BITSIZE (int_mode) == 0\n       && INTVAL (XEXP (op, 1)) > 0\n       && INTVAL (XEXP (op, 1)) < GET_MODE_BITSIZE (int_op_mode)\n       && ! mode_dependent_address_p (XEXP (XEXP (op, 0), 0),\n \t\t\t\t     MEM_ADDR_SPACE (XEXP (op, 0)))\n       && ! MEM_VOLATILE_P (XEXP (op, 0))\n-      && (GET_MODE_SIZE (mode) >= UNITS_PER_WORD\n+      && (GET_MODE_SIZE (int_mode) >= UNITS_PER_WORD\n \t  || WORDS_BIG_ENDIAN == BYTES_BIG_ENDIAN))\n     {\n-      int byte = subreg_lowpart_offset (mode, int_op_mode);\n+      int byte = subreg_lowpart_offset (int_mode, int_op_mode);\n       int shifted_bytes = INTVAL (XEXP (op, 1)) / BITS_PER_UNIT;\n-      return adjust_address_nv (XEXP (op, 0), mode,\n+      return adjust_address_nv (XEXP (op, 0), int_mode,\n \t\t\t\t(WORDS_BIG_ENDIAN\n \t\t\t\t ? byte - shifted_bytes\n \t\t\t\t : byte + shifted_bytes));\n@@ -2989,19 +2990,21 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n \t is (lt foo (const_int 0)), so we can perform the above\n \t simplification if STORE_FLAG_VALUE is 1.  */\n \n-      if (STORE_FLAG_VALUE == 1\n+      if (is_a <scalar_int_mode> (mode, &int_mode)\n+\t  && STORE_FLAG_VALUE == 1\n \t  && trueop1 == const1_rtx\n \t  && GET_CODE (op0) == LSHIFTRT\n \t  && CONST_INT_P (XEXP (op0, 1))\n-\t  && INTVAL (XEXP (op0, 1)) == GET_MODE_PRECISION (mode) - 1)\n-\treturn gen_rtx_GE (mode, XEXP (op0, 0), const0_rtx);\n+\t  && INTVAL (XEXP (op0, 1)) == GET_MODE_PRECISION (int_mode) - 1)\n+\treturn gen_rtx_GE (int_mode, XEXP (op0, 0), const0_rtx);\n \n       /* (xor (comparison foo bar) (const_int sign-bit))\n \t when STORE_FLAG_VALUE is the sign bit.  */\n-      if (val_signbit_p (mode, STORE_FLAG_VALUE)\n+      if (is_a <scalar_int_mode> (mode, &int_mode)\n+\t  && val_signbit_p (int_mode, STORE_FLAG_VALUE)\n \t  && trueop1 == const_true_rtx\n \t  && COMPARISON_P (op0)\n-\t  && (reversed = reversed_comparison (op0, mode)))\n+\t  && (reversed = reversed_comparison (op0, int_mode)))\n \treturn reversed;\n \n       tem = simplify_byte_swapping_operation (code, mode, op0, op1);\n@@ -3424,17 +3427,17 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n \treturn op0;\n       /* Optimize (lshiftrt (clz X) C) as (eq X 0).  */\n       if (GET_CODE (op0) == CLZ\n+\t  && is_a <scalar_int_mode> (GET_MODE (XEXP (op0, 0)), &inner_mode)\n \t  && CONST_INT_P (trueop1)\n \t  && STORE_FLAG_VALUE == 1\n \t  && INTVAL (trueop1) < (HOST_WIDE_INT)width)\n \t{\n-\t  machine_mode imode = GET_MODE (XEXP (op0, 0));\n \t  unsigned HOST_WIDE_INT zero_val = 0;\n \n-\t  if (CLZ_DEFINED_VALUE_AT_ZERO (imode, zero_val)\n-\t      && zero_val == GET_MODE_PRECISION (imode)\n+\t  if (CLZ_DEFINED_VALUE_AT_ZERO (inner_mode, zero_val)\n+\t      && zero_val == GET_MODE_PRECISION (inner_mode)\n \t      && INTVAL (trueop1) == exact_log2 (zero_val))\n-\t    return simplify_gen_relational (EQ, mode, imode,\n+\t    return simplify_gen_relational (EQ, mode, inner_mode,\n \t\t\t\t\t    XEXP (op0, 0), const0_rtx);\n \t}\n       goto canonicalize_shift;\n@@ -5275,7 +5278,9 @@ simplify_const_relational_operation (enum rtx_code code,\n     }\n \n   /* Optimize integer comparisons with zero.  */\n-  if (trueop1 == const0_rtx && !side_effects_p (trueop0))\n+  if (is_a <scalar_int_mode> (mode, &int_mode)\n+      && trueop1 == const0_rtx\n+      && !side_effects_p (trueop0))\n     {\n       /* Some addresses are known to be nonzero.  We don't know\n \t their sign, but equality comparisons are known.  */\n@@ -5294,7 +5299,7 @@ simplify_const_relational_operation (enum rtx_code code,\n \t  rtx inner_const = avoid_constant_pool_reference (XEXP (op0, 1));\n \t  if (CONST_INT_P (inner_const) && inner_const != const0_rtx)\n \t    {\n-\t      int sign_bitnum = GET_MODE_PRECISION (mode) - 1;\n+\t      int sign_bitnum = GET_MODE_PRECISION (int_mode) - 1;\n \t      int has_sign = (HOST_BITS_PER_WIDE_INT >= sign_bitnum\n \t\t\t      && (UINTVAL (inner_const)\n \t\t\t\t  & (HOST_WIDE_INT_1U\n@@ -5410,13 +5415,9 @@ simplify_ternary_operation (enum rtx_code code, machine_mode mode,\n \t\t\t    machine_mode op0_mode, rtx op0, rtx op1,\n \t\t\t    rtx op2)\n {\n-  unsigned int width = GET_MODE_PRECISION (mode);\n   bool any_change = false;\n   rtx tem, trueop2;\n-\n-  /* VOIDmode means \"infinite\" precision.  */\n-  if (width == 0)\n-    width = HOST_BITS_PER_WIDE_INT;\n+  scalar_int_mode int_mode, int_op0_mode;\n \n   switch (code)\n     {\n@@ -5450,17 +5451,21 @@ simplify_ternary_operation (enum rtx_code code, machine_mode mode,\n       if (CONST_INT_P (op0)\n \t  && CONST_INT_P (op1)\n \t  && CONST_INT_P (op2)\n-\t  && ((unsigned) INTVAL (op1) + (unsigned) INTVAL (op2) <= width)\n-\t  && width <= (unsigned) HOST_BITS_PER_WIDE_INT)\n+\t  && is_a <scalar_int_mode> (mode, &int_mode)\n+\t  && INTVAL (op1) + INTVAL (op2) <= GET_MODE_PRECISION (int_mode)\n+\t  && HWI_COMPUTABLE_MODE_P (int_mode))\n \t{\n \t  /* Extracting a bit-field from a constant */\n \t  unsigned HOST_WIDE_INT val = UINTVAL (op0);\n \t  HOST_WIDE_INT op1val = INTVAL (op1);\n \t  HOST_WIDE_INT op2val = INTVAL (op2);\n-\t  if (BITS_BIG_ENDIAN)\n-\t    val >>= GET_MODE_PRECISION (op0_mode) - op2val - op1val;\n-\t  else\n+\t  if (!BITS_BIG_ENDIAN)\n \t    val >>= op2val;\n+\t  else if (is_a <scalar_int_mode> (op0_mode, &int_op0_mode))\n+\t    val >>= GET_MODE_PRECISION (int_op0_mode) - op2val - op1val;\n+\t  else\n+\t    /* Not enough information to calculate the bit position.  */\n+\t    break;\n \n \t  if (HOST_BITS_PER_WIDE_INT != op1val)\n \t    {\n@@ -5473,7 +5478,7 @@ simplify_ternary_operation (enum rtx_code code, machine_mode mode,\n \t\tval |= ~ ((HOST_WIDE_INT_1U << op1val) - 1);\n \t    }\n \n-\t  return gen_int_mode (val, mode);\n+\t  return gen_int_mode (val, int_mode);\n \t}\n       break;\n "}, {"sha": "008df2e549c6ee88cc763616c0533106d3ce88e2", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/546513775069e93d5f33f7aae5f1cb26c77ca2c9/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/546513775069e93d5f33f7aae5f1cb26c77ca2c9/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=546513775069e93d5f33f7aae5f1cb26c77ca2c9", "patch": "@@ -4011,6 +4011,7 @@ force_expr_to_var_cost (tree expr, bool speed)\n   tree op0, op1;\n   comp_cost cost0, cost1, cost;\n   machine_mode mode;\n+  scalar_int_mode int_mode;\n \n   if (!costs_initialized)\n     {\n@@ -4133,8 +4134,9 @@ force_expr_to_var_cost (tree expr, bool speed)\n \t    mult = op0;\n \n \t  if (mult != NULL_TREE\n+\t      && is_a <scalar_int_mode> (mode, &int_mode)\n \t      && cst_and_fits_in_hwi (TREE_OPERAND (mult, 1))\n-\t      && get_shiftadd_cost (expr, mode, cost0, cost1, mult,\n+\t      && get_shiftadd_cost (expr, int_mode, cost0, cost1, mult,\n \t\t\t\t    speed, &sa_cost))\n \t    return sa_cost;\n \t}"}]}