{"sha": "48357ce4f22c8298ea5fb01d6873bc7bf56180e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDgzNTdjZTRmMjJjODI5OGVhNWZiMDFkNjg3M2JjN2JmNTYxODBlNQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-12-22T04:51:18Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-12-22T19:56:41Z"}, "message": "runtime: omit nil-channel cases from selectgo's orders\n\nThis is the gofrontend version of https://golang.org/cl/245123.\nOriginal CL description:\n\n    Currently, selectgo does an initial pass over the cases array to look\n    for entries with nil channels, so they can be easily recognized and\n    skipped later on. But this still involves actually visiting the cases.\n\n    This commit changes selectgo to omit cases with nil channels when\n    constructing pollorder, so that they'll be skipped over entirely later\n    on. It also checks for caseDefault up front, which will facilitate\n    changing it to use a \"block bool\" parameter instead.\n\n    Updates golang/go#40410\n\nThis is being brought over to gofrontend as a step toward upgrading to\nGo1.16beta1, setting up for more compiler changes related to select handling.\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/279733", "tree": {"sha": "bafb432735bae6fde8265a5c2d4a032c56c7780d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bafb432735bae6fde8265a5c2d4a032c56c7780d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48357ce4f22c8298ea5fb01d6873bc7bf56180e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48357ce4f22c8298ea5fb01d6873bc7bf56180e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48357ce4f22c8298ea5fb01d6873bc7bf56180e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48357ce4f22c8298ea5fb01d6873bc7bf56180e5/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1fa5fc7408d05710cb63a5e91c5df6c787b51019", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fa5fc7408d05710cb63a5e91c5df6c787b51019", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fa5fc7408d05710cb63a5e91c5df6c787b51019"}], "stats": {"total": 70, "additions": 29, "deletions": 41}, "files": [{"sha": "a7df843340357e622d3909e4f168a62657ba0e83", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48357ce4f22c8298ea5fb01d6873bc7bf56180e5/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48357ce4f22c8298ea5fb01d6873bc7bf56180e5/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=48357ce4f22c8298ea5fb01d6873bc7bf56180e5", "patch": "@@ -1,4 +1,4 @@\n-c8456995b0118a92820c6c1d8f996d4b1adf55c2\n+d0e56e82bb298268ec0f306fef99a715c892d4a7\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "d5087fbc045810cc7117f4b5efc577f86ce5b39e", "filename": "libgo/go/runtime/select.go", "status": "modified", "additions": 28, "deletions": 40, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48357ce4f22c8298ea5fb01d6873bc7bf56180e5/libgo%2Fgo%2Fruntime%2Fselect.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48357ce4f22c8298ea5fb01d6873bc7bf56180e5/libgo%2Fgo%2Fruntime%2Fselect.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fselect.go?ref=48357ce4f22c8298ea5fb01d6873bc7bf56180e5", "patch": "@@ -41,7 +41,7 @@ func sellock(scases []scase, lockorder []uint16) {\n \tvar c *hchan\n \tfor _, o := range lockorder {\n \t\tc0 := scases[o].c\n-\t\tif c0 != nil && c0 != c {\n+\t\tif c0 != c {\n \t\t\tc = c0\n \t\t\tlock(&c.lock)\n \t\t}\n@@ -57,11 +57,8 @@ func selunlock(scases []scase, lockorder []uint16) {\n \t// the G that calls select runnable again and schedules it for execution.\n \t// When the G runs on another M, it locks all the locks and frees sel.\n \t// Now if the first M touches sel, it will access freed memory.\n-\tfor i := len(scases) - 1; i >= 0; i-- {\n+\tfor i := len(lockorder) - 1; i >= 0; i-- {\n \t\tc := scases[lockorder[i]].c\n-\t\tif c == nil {\n-\t\t\tbreak\n-\t\t}\n \t\tif i > 0 && c == scases[lockorder[i-1]].c {\n \t\t\tcontinue // will unlock it on the next iteration\n \t\t}\n@@ -138,15 +135,6 @@ func selectgo(cas0 *scase, order0 *uint16, ncases int) (int, bool) {\n \tpollorder := order1[:ncases:ncases]\n \tlockorder := order1[ncases:][:ncases:ncases]\n \n-\t// Replace send/receive cases involving nil channels with\n-\t// caseNil so logic below can assume non-nil channel.\n-\tfor i := range scases {\n-\t\tcas := &scases[i]\n-\t\tif cas.c == nil && cas.kind != caseDefault {\n-\t\t\t*cas = scase{}\n-\t\t}\n-\t}\n-\n \tvar t0 int64\n \tif blockprofilerate > 0 {\n \t\tt0 = cputicks()\n@@ -166,15 +154,31 @@ func selectgo(cas0 *scase, order0 *uint16, ncases int) (int, bool) {\n \t}\n \n \t// generate permuted order\n-\tfor i := 1; i < ncases; i++ {\n-\t\tj := fastrandn(uint32(i + 1))\n-\t\tpollorder[i] = pollorder[j]\n+\tdfli := -1\n+\tnorder := 0\n+\tfor i := range scases {\n+\t\tcas := &scases[i]\n+\n+\t\t// Omit cases without channels from the poll and lock orders.\n+\t\tif cas.c == nil {\n+\t\t\tif cas.kind == caseDefault {\n+\t\t\t\tdfli = i\n+\t\t\t}\n+\t\t\tcas.elem = nil // allow GC\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tj := fastrandn(uint32(norder + 1))\n+\t\tpollorder[norder] = pollorder[j]\n \t\tpollorder[j] = uint16(i)\n+\t\tnorder++\n \t}\n+\tpollorder = pollorder[:norder]\n+\tlockorder = lockorder[:norder]\n \n \t// sort the cases by Hchan address to get the locking order.\n \t// simple heap sort, to guarantee n log n time and constant stack footprint.\n-\tfor i := 0; i < ncases; i++ {\n+\tfor i := range lockorder {\n \t\tj := i\n \t\t// Start with the pollorder to permute cases on the same channel.\n \t\tc := scases[pollorder[i]].c\n@@ -185,7 +189,7 @@ func selectgo(cas0 *scase, order0 *uint16, ncases int) (int, bool) {\n \t\t}\n \t\tlockorder[j] = pollorder[i]\n \t}\n-\tfor i := ncases - 1; i >= 0; i-- {\n+\tfor i := len(lockorder) - 1; i >= 0; i-- {\n \t\to := lockorder[i]\n \t\tc := scases[o].c\n \t\tlockorder[i] = lockorder[0]\n@@ -209,7 +213,7 @@ func selectgo(cas0 *scase, order0 *uint16, ncases int) (int, bool) {\n \t}\n \n \tif debugSelect {\n-\t\tfor i := 0; i+1 < ncases; i++ {\n+\t\tfor i := 0; i+1 < len(lockorder); i++ {\n \t\t\tif scases[lockorder[i]].c.sortkey() > scases[lockorder[i+1]].c.sortkey() {\n \t\t\t\tprint(\"i=\", i, \" x=\", lockorder[i], \" y=\", lockorder[i+1], \"\\n\")\n \t\t\t\tthrow(\"select: broken sort\")\n@@ -233,21 +237,16 @@ func selectgo(cas0 *scase, order0 *uint16, ncases int) (int, bool) {\n \n loop:\n \t// pass 1 - look for something already waiting\n-\tvar dfli int\n-\tvar dfl *scase\n \tvar casi int\n \tvar cas *scase\n \tvar caseReleaseTime int64 = -1\n \tvar recvOK bool\n-\tfor i := 0; i < ncases; i++ {\n-\t\tcasi = int(pollorder[i])\n+\tfor _, casei := range pollorder {\n+\t\tcasi = int(casei)\n \t\tcas = &scases[casi]\n \t\tc = cas.c\n \n \t\tswitch cas.kind {\n-\t\tcase caseNil:\n-\t\t\tcontinue\n-\n \t\tcase caseRecv:\n \t\t\tsg = c.sendq.dequeue()\n \t\t\tif sg != nil {\n@@ -271,17 +270,12 @@ loop:\n \t\t\tif c.qcount < c.dataqsiz {\n \t\t\t\tgoto bufsend\n \t\t\t}\n-\n-\t\tcase caseDefault:\n-\t\t\tdfli = casi\n-\t\t\tdfl = cas\n \t\t}\n \t}\n \n-\tif dfl != nil {\n+\tif dfli >= 0 {\n \t\tselunlock(scases, lockorder)\n \t\tcasi = dfli\n-\t\tcas = dfl\n \t\tgoto retc\n \t}\n \n@@ -294,9 +288,6 @@ loop:\n \tfor _, casei := range lockorder {\n \t\tcasi = int(casei)\n \t\tcas = &scases[casi]\n-\t\tif cas.kind == caseNil {\n-\t\t\tcontinue\n-\t\t}\n \t\tc = cas.c\n \t\tsg := acquireSudog()\n \t\tsg.g = gp\n@@ -355,9 +346,6 @@ loop:\n \n \tfor _, casei := range lockorder {\n \t\tk = &scases[casei]\n-\t\tif k.kind == caseNil {\n-\t\t\tcontinue\n-\t\t}\n \t\tif sg == sglist {\n \t\t\t// sg has already been dequeued by the G that woke us up.\n \t\t\tcasi = int(casei)\n@@ -468,7 +456,7 @@ retc:\n \n \t// Check preemption, since unlike gc we don't check on every call.\n \t// A test case for this one is BenchmarkPingPongHog in proc_test.go.\n-\tif dfl != nil && getg().preempt {\n+\tif dfli >= 0 && getg().preempt {\n \t\tcheckPreempt()\n \t}\n "}]}