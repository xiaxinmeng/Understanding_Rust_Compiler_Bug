{"sha": "cfee318d138c009b2eeb1038d00c6237a2fad4ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ZlZTMxOGQxMzhjMDA5YjJlZWIxMDM4ZDAwYzYyMzdhMmZhZDRlZQ==", "commit": {"author": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2010-12-10T19:16:48Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2010-12-10T19:16:48Z"}, "message": "Fix PR43023: fuse_partitions_with_similar_memory_accesses.\n\n2010-12-10  Sebastian Pop  <sebastian.pop@amd.com>\n\n\tPR tree-optimization/43023\n\t* tree-data-ref.c (mem_write_stride_of_same_size_as_unit_type_p):\n\tRemoved.\n\t(stores_zero_from_loop): Call stmt_stores_zero.\n\t* tree-data-ref.h (stmt_stores_zero): New.\n\t* tree-loop-distribution.c (generate_memset_zero): Do not return a\n\tboolean.  Call gcc_assert on stride_of_unit_type_p.\n\t(generate_builtin): Call stmt_stores_zero.\n\t(rdg_flag_all_uses): Removed.\n\t(rdg_flag_similar_memory_accesses): Removed.\n\t(build_rdg_partition_for_component): Removed parameter\n\tother_stores.  Removed call to rdg_flag_similar_memory_accesses.\n\t(can_generate_builtin): New.\n\t(similar_memory_accesses): New.\n\t(fuse_partitions_with_similar_memory_accesses): New.\n\t(rdg_build_partitions): Call\n\tfuse_partitions_with_similar_memory_accesses.\n\n\t* gfortran.dg/ldist-1.f90: Adjust pattern.\n\t* gfortran.dg/ldist-pr43023.f90: New.\n\nFrom-SVN: r167697", "tree": {"sha": "34ce9e6bf89c7dc61183702364d0d4937f9a309c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34ce9e6bf89c7dc61183702364d0d4937f9a309c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cfee318d138c009b2eeb1038d00c6237a2fad4ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfee318d138c009b2eeb1038d00c6237a2fad4ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfee318d138c009b2eeb1038d00c6237a2fad4ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfee318d138c009b2eeb1038d00c6237a2fad4ee/comments", "author": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b595b1a11eec6a11c32b8a01fd48427a01b75876", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b595b1a11eec6a11c32b8a01fd48427a01b75876", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b595b1a11eec6a11c32b8a01fd48427a01b75876"}], "stats": {"total": 301, "additions": 172, "deletions": 129}, "files": [{"sha": "038980644aeefcd1838174c3ecb87a7c5533a04f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfee318d138c009b2eeb1038d00c6237a2fad4ee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfee318d138c009b2eeb1038d00c6237a2fad4ee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cfee318d138c009b2eeb1038d00c6237a2fad4ee", "patch": "@@ -1,3 +1,23 @@\n+2010-12-10  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\tPR tree-optimization/43023\n+\t* tree-data-ref.c (mem_write_stride_of_same_size_as_unit_type_p):\n+\tRemoved.\n+\t(stores_zero_from_loop): Call stmt_stores_zero.\n+\t* tree-data-ref.h (stmt_stores_zero): New.\n+\t* tree-loop-distribution.c (generate_memset_zero): Do not return a\n+\tboolean.  Call gcc_assert on stride_of_unit_type_p.\n+\t(generate_builtin): Call stmt_stores_zero.\n+\t(rdg_flag_all_uses): Removed.\n+\t(rdg_flag_similar_memory_accesses): Removed.\n+\t(build_rdg_partition_for_component): Removed parameter\n+\tother_stores.  Removed call to rdg_flag_similar_memory_accesses.\n+\t(can_generate_builtin): New.\n+\t(similar_memory_accesses): New.\n+\t(fuse_partitions_with_similar_memory_accesses): New.\n+\t(rdg_build_partitions): Call\n+\tfuse_partitions_with_similar_memory_accesses.\n+\n 2010-12-10  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR rtl-optimization/46804\n@@ -108,9 +128,9 @@\n \t(abshi2): Delete.\n \t(neghi2, negqi2): Use PDPint iterator.\n \t* config/pdp11/pdp11.c (find_addr_reg, output_move_double,\n-\toutput_move_quad): Delete. \n+\toutput_move_quad): Delete.\n \t(pdp11_expand_operands, output_move_multiple): New functions.\n-\t\n+\n 2010-12-09  Joseph Myers  <joseph@codesourcery.com>\n \n \t* config/vax/linux.h (WCHAR_TYPE, WCHAR_TYPE_SIZE): Define."}, {"sha": "7bb46f3a7b5f96b65dd3bec9e6553d801b2ffacf", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfee318d138c009b2eeb1038d00c6237a2fad4ee/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfee318d138c009b2eeb1038d00c6237a2fad4ee/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cfee318d138c009b2eeb1038d00c6237a2fad4ee", "patch": "@@ -1,3 +1,9 @@\n+2010-12-10  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\tPR tree-optimization/43023\n+\t* gfortran.dg/ldist-1.f90: Adjust pattern.\n+\t* gfortran.dg/ldist-pr43023.f90: New.\n+\n 2010-12-10  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR rtl-optimization/46804\n@@ -45,8 +51,8 @@\n \t* obj-c++.dg/class-extension-3.mm: New.\n \t* obj-c++.dg/property/at-property-26.mm: New.\n \t* obj-c++.dg/property/at-property-27.mm: New.\n-\t* obj-c++.dg/property/at-property-28.mm: New.\t\n-\t\n+\t* obj-c++.dg/property/at-property-28.mm: New.\n+\n 2010-12-09  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \tPR target/46057\n@@ -113,12 +119,12 @@\n \t* obj-c++.dg/exceptions-7.mm: New.\n \t* obj-c++.dg/exceptions-3.mm: Adjust for new C++ messages.\n \t* obj-c++.dg/exceptions-5.mm: Same change.\n-\t\n+\n 2010-12-08  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc.dg/foreach-6.m: Updated location of error messages.\n \t* objc.dg/foreach-7.m: Same change.\n-\t\n+\n 2010-12-08  Richard Guenther  <rguenther@suse.de>\n \t    Sebastian Pop  <sebastian.pop@amd.com>\n "}, {"sha": "bbce2f355e12f4bc10a1d8ee8fc77ce84a0b9bda", "filename": "gcc/testsuite/gfortran.dg/ldist-1.f90", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfee318d138c009b2eeb1038d00c6237a2fad4ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fldist-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfee318d138c009b2eeb1038d00c6237a2fad4ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fldist-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fldist-1.f90?ref=cfee318d138c009b2eeb1038d00c6237a2fad4ee", "patch": "@@ -29,5 +29,8 @@ Subroutine PADEC(DKS,DKDS,HVAR,WM,WG,FN,NS,AN,BN,CN,IT)\n   return\n end Subroutine PADEC\n \n-! { dg-final { scan-tree-dump-times \"distributed: split to 4 loops\" 1 \"ldist\" } }\n+! There are 5 legal partitions in this code.  Based on the data\n+! locality heuristic, this loop should not be split.\n+\n+! { dg-final { scan-tree-dump-not \"distributed: split to\" \"ldist\" } }\n ! { dg-final { cleanup-tree-dump \"ldist\" } }"}, {"sha": "3e2d04c949017d956eac41666361ea0e528f98f6", "filename": "gcc/testsuite/gfortran.dg/ldist-pr43023.f90", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfee318d138c009b2eeb1038d00c6237a2fad4ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fldist-pr43023.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfee318d138c009b2eeb1038d00c6237a2fad4ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fldist-pr43023.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fldist-pr43023.f90?ref=cfee318d138c009b2eeb1038d00c6237a2fad4ee", "patch": "@@ -0,0 +1,31 @@\n+! { dg-do compile }\n+! { dg-options \"-O2 -ftree-loop-distribution\" }\n+\n+MODULE NFT_mod\n+\n+implicit none\n+integer :: Nangle\n+real:: Z0\n+real, dimension(:,:), allocatable :: Angle\n+real, dimension(:), allocatable :: exth, ezth, hxth, hyth, hyphi\n+\n+CONTAINS\n+\n+SUBROUTINE NFT_Init()\n+\n+real :: th, fi\n+integer :: n\n+\n+do n = 1,Nangle\n+  th = Angle(n,1)\n+  fi = Angle(n,2)\n+\n+  exth(n) =  cos(fi)*cos(th)\n+  ezth(n) = -sin(th)\n+  hxth(n) = -sin(fi)\n+  hyth(n) =  cos(fi)\n+  hyphi(n) = -sin(fi)\n+end do\n+END SUBROUTINE NFT_Init\n+\n+END MODULE NFT_mod"}, {"sha": "9a813702a6a16946d48428328eaa9c487f6750d3", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfee318d138c009b2eeb1038d00c6237a2fad4ee/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfee318d138c009b2eeb1038d00c6237a2fad4ee/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=cfee318d138c009b2eeb1038d00c6237a2fad4ee", "patch": "@@ -4509,7 +4509,7 @@ dump_rdg_vertex (FILE *file, struct graph *rdg, int i)\n     for (e = v->succ; e; e = e->succ_next)\n       fprintf (file, \" %d\", e->dest);\n \n-  fprintf (file, \") \\n\");\n+  fprintf (file, \")\\n\");\n   print_gimple_stmt (file, RDGV_STMT (v), 0, TDF_VOPS|TDF_MEMSYMS);\n   fprintf (file, \")\\n\");\n }\n@@ -4976,16 +4976,27 @@ stores_from_loop (struct loop *loop, VEC (gimple, heap) **stmts)\n   free (bbs);\n }\n \n-/* Returns true when STMT is an assignment that contains a data\n-   reference on its LHS with a stride of the same size as its unit\n-   type.  */\n+/* Returns true when the statement at STMT is of the form \"A[i] = 0\"\n+   that contains a data reference on its LHS with a stride of the same\n+   size as its unit type.  */\n \n-static bool\n-mem_write_stride_of_same_size_as_unit_type_p (gimple stmt)\n+bool\n+stmt_with_adjacent_zero_store_dr_p (gimple stmt)\n {\n-  struct data_reference *dr = XCNEW (struct data_reference);\n-  tree op0 = gimple_assign_lhs (stmt);\n+  tree op0, op1;\n   bool res;\n+  struct data_reference *dr;\n+\n+  if (!stmt\n+      || !gimple_vdef (stmt)\n+      || !is_gimple_assign (stmt)\n+      || !gimple_assign_single_p (stmt)\n+      || !(op1 = gimple_assign_rhs1 (stmt))\n+      || !(integer_zerop (op1) || real_zerop (op1)))\n+    return false;\n+\n+  dr = XCNEW (struct data_reference);\n+  op0 = gimple_assign_lhs (stmt);\n \n   DR_STMT (dr) = stmt;\n   DR_REF (dr) = op0;\n@@ -5007,18 +5018,12 @@ stores_zero_from_loop (struct loop *loop, VEC (gimple, heap) **stmts)\n   basic_block bb;\n   gimple_stmt_iterator si;\n   gimple stmt;\n-  tree op;\n   basic_block *bbs = get_loop_body_in_dom_order (loop);\n \n   for (i = 0; i < loop->num_nodes; i++)\n     for (bb = bbs[i], si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n       if ((stmt = gsi_stmt (si))\n-\t  && gimple_vdef (stmt)\n-\t  && is_gimple_assign (stmt)\n-\t  && gimple_assign_rhs_code (stmt) == INTEGER_CST\n-\t  && (op = gimple_assign_rhs1 (stmt))\n-\t  && (integer_zerop (op) || real_zerop (op))\n-\t  && mem_write_stride_of_same_size_as_unit_type_p (stmt))\n+\t  && stmt_with_adjacent_zero_store_dr_p (stmt))\n \tVEC_safe_push (gimple, heap, *stmts, gsi_stmt (si));\n \n   free (bbs);"}, {"sha": "b4f317f99ed8dd1dc76bf72c1d93f9e8e79d29fa", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfee318d138c009b2eeb1038d00c6237a2fad4ee/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfee318d138c009b2eeb1038d00c6237a2fad4ee/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=cfee318d138c009b2eeb1038d00c6237a2fad4ee", "patch": "@@ -602,6 +602,7 @@ void stores_zero_from_loop (struct loop *, VEC (gimple, heap) **);\n void remove_similar_memory_refs (VEC (gimple, heap) **);\n bool rdg_defs_used_in_other_loops_p (struct graph *, int);\n bool have_similar_memory_accesses (gimple, gimple);\n+bool stmt_with_adjacent_zero_store_dr_p (gimple);\n \n /* Returns true when STRIDE is equal in absolute value to the size of\n    the unit type of TYPE.  */"}, {"sha": "b60320945d46773b998ccfe5c80671751e3b9034", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 84, "deletions": 107, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfee318d138c009b2eeb1038d00c6237a2fad4ee/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfee318d138c009b2eeb1038d00c6237a2fad4ee/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=cfee318d138c009b2eeb1038d00c6237a2fad4ee", "patch": "@@ -241,7 +241,7 @@ build_size_arg_loc (location_t loc, tree nb_iter, tree op,\n \n /* Generate a call to memset.  Return true when the operation succeeded.  */\n \n-static bool\n+static void\n generate_memset_zero (gimple stmt, tree op0, tree nb_iter,\n \t\t      gimple_stmt_iterator bsi)\n {\n@@ -255,11 +255,8 @@ generate_memset_zero (gimple stmt, tree op0, tree nb_iter,\n \n   DR_STMT (dr) = stmt;\n   DR_REF (dr) = op0;\n-  if (!dr_analyze_innermost (dr))\n-    goto end;\n-\n-  if (!stride_of_unit_type_p (DR_STEP (dr), TREE_TYPE (op0)))\n-    goto end;\n+  res = dr_analyze_innermost (dr);\n+  gcc_assert (res && stride_of_unit_type_p (DR_STEP (dr), TREE_TYPE (op0)));\n \n   nb_bytes = build_size_arg_loc (loc, nb_iter, op0, &stmt_list);\n   addr_base = size_binop_loc (loc, PLUS_EXPR, DR_OFFSET (dr), DR_INIT (dr));\n@@ -286,14 +283,11 @@ generate_memset_zero (gimple stmt, tree op0, tree nb_iter,\n   fn_call = gimple_build_call (fn, 3, mem, integer_zero_node, nb_bytes);\n   gimple_seq_add_stmt (&stmt_list, fn_call);\n   gsi_insert_seq_after (&bsi, stmt_list, GSI_CONTINUE_LINKING);\n-  res = true;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"generated memset zero\\n\");\n \n- end:\n   free_data_ref (dr);\n-  return res;\n }\n \n /* Tries to generate a builtin function for the instructions of LOOP\n@@ -307,7 +301,6 @@ generate_builtin (struct loop *loop, bitmap partition, bool copy_p)\n   unsigned i, x = 0;\n   basic_block *bbs;\n   gimple write = NULL;\n-  tree op0, op1;\n   gimple_stmt_iterator bsi;\n   tree nb_iter = number_of_exit_cond_executions (loop);\n \n@@ -343,26 +336,17 @@ generate_builtin (struct loop *loop, bitmap partition, bool copy_p)\n \t}\n     }\n \n-  if (!write)\n-    goto end;\n-\n-  op0 = gimple_assign_lhs (write);\n-  op1 = gimple_assign_rhs1 (write);\n-\n-  if (!(TREE_CODE (op0) == ARRAY_REF\n-\t|| TREE_CODE (op0) == MEM_REF))\n+  if (!stmt_with_adjacent_zero_store_dr_p (write))\n     goto end;\n \n   /* The new statements will be placed before LOOP.  */\n   bsi = gsi_last_bb (loop_preheader_edge (loop)->src);\n-\n-  if (gimple_assign_rhs_code (write) == INTEGER_CST\n-      && (integer_zerop (op1) || real_zerop (op1)))\n-    res = generate_memset_zero (write, op0, nb_iter, bsi);\n+  generate_memset_zero (write, gimple_assign_lhs (write), nb_iter, bsi);\n+  res = true;\n \n   /* If this is the last partition for which we generate code, we have\n      to destroy the loop.  */\n-  if (res && !copy_p)\n+  if (!copy_p)\n     {\n       unsigned nbbs = loop->num_nodes;\n       edge exit = single_exit (loop);\n@@ -504,24 +488,6 @@ has_upstream_mem_writes (int u)\n static void rdg_flag_vertex_and_dependent (struct graph *, int, bitmap, bitmap,\n \t\t\t\t\t   bitmap, bool *);\n \n-/* Flag all the uses of U.  */\n-\n-static void\n-rdg_flag_all_uses (struct graph *rdg, int u, bitmap partition, bitmap loops,\n-\t\t   bitmap processed, bool *part_has_writes)\n-{\n-  struct graph_edge *e;\n-\n-  for (e = rdg->vertices[u].succ; e; e = e->succ_next)\n-    if (!bitmap_bit_p (processed, e->dest))\n-      {\n-\trdg_flag_vertex_and_dependent (rdg, e->dest, partition, loops,\n-\t\t\t\t       processed, part_has_writes);\n-\trdg_flag_all_uses (rdg, e->dest, partition, loops, processed,\n-\t\t\t   part_has_writes);\n-      }\n-}\n-\n /* Flag the uses of U stopping following the information from\n    upstream_mem_writes.  */\n \n@@ -689,68 +655,13 @@ rdg_flag_loop_exits (struct graph *rdg, bitmap loops, bitmap partition,\n     }\n }\n \n-/* Flag all the nodes of RDG containing memory accesses that could\n-   potentially belong to arrays already accessed in the current\n-   PARTITION.  */\n-\n-static void\n-rdg_flag_similar_memory_accesses (struct graph *rdg, bitmap partition,\n-\t\t\t\t  bitmap loops, bitmap processed,\n-\t\t\t\t  VEC (int, heap) **other_stores)\n-{\n-  bool foo;\n-  unsigned i, n;\n-  int j, k, kk;\n-  bitmap_iterator ii;\n-  struct graph_edge *e;\n-\n-  EXECUTE_IF_SET_IN_BITMAP (partition, 0, i, ii)\n-    if (RDG_MEM_WRITE_STMT (rdg, i)\n-\t|| RDG_MEM_READS_STMT (rdg, i))\n-      {\n-\tfor (j = 0; j < rdg->n_vertices; j++)\n-\t  if (!bitmap_bit_p (processed, j)\n-\t      && (RDG_MEM_WRITE_STMT (rdg, j)\n-\t\t  || RDG_MEM_READS_STMT (rdg, j))\n-\t      && rdg_has_similar_memory_accesses (rdg, i, j))\n-\t    {\n-\t      /* Flag first the node J itself, and all the nodes that\n-\t\t are needed to compute J.  */\n-\t      rdg_flag_vertex_and_dependent (rdg, j, partition, loops,\n-\t\t\t\t\t     processed, &foo);\n-\n-\t      /* When J is a read, we want to coalesce in the same\n-\t\t PARTITION all the nodes that are using J: this is\n-\t\t needed for better cache locality.  */\n-\t      rdg_flag_all_uses (rdg, j, partition, loops, processed, &foo);\n-\n-\t      /* Remove from OTHER_STORES the vertex that we flagged.  */\n-\t      if (RDG_MEM_WRITE_STMT (rdg, j))\n-\t\tFOR_EACH_VEC_ELT (int, *other_stores, k, kk)\n-\t\t  if (kk == j)\n-\t\t    {\n-\t\t      VEC_unordered_remove (int, *other_stores, k);\n-\t\t      break;\n-\t\t    }\n-\t    }\n-\n-\t/* If the node I has two uses, then keep these together in the\n-\t   same PARTITION.  */\n-\tfor (n = 0, e = rdg->vertices[i].succ; e; e = e->succ_next, n++);\n-\n-\tif (n > 1)\n-\t  rdg_flag_all_uses (rdg, i, partition, loops, processed, &foo);\n-      }\n-}\n-\n /* Returns a bitmap in which all the statements needed for computing\n    the strongly connected component C of the RDG are flagged, also\n    including the loop exit conditions.  */\n \n static bitmap\n build_rdg_partition_for_component (struct graph *rdg, rdgc c,\n-\t\t\t\t   bool *part_has_writes,\n-\t\t\t\t   VEC (int, heap) **other_stores)\n+\t\t\t\t   bool *part_has_writes)\n {\n   int i, v;\n   bitmap partition = BITMAP_ALLOC (NULL);\n@@ -762,14 +673,6 @@ build_rdg_partition_for_component (struct graph *rdg, rdgc c,\n       rdg_flag_vertex_and_dependent (rdg, v, partition, loops, processed,\n \t\t\t\t     part_has_writes);\n \n-  /* Also iterate on the array of stores not in the starting vertices,\n-     and determine those vertices that have some memory affinity with\n-     the current nodes in the component: these are stores to the same\n-     arrays, i.e. we're taking care of cache locality.  */\n-  if (!flag_tree_loop_distribute_patterns)\n-    rdg_flag_similar_memory_accesses (rdg, partition, loops, processed,\n-\t\t\t\t      other_stores);\n-\n   rdg_flag_loop_exits (rdg, loops, partition, processed, part_has_writes);\n \n   BITMAP_FREE (processed);\n@@ -832,6 +735,79 @@ rdg_build_components (struct graph *rdg, VEC (int, heap) *starting_vertices,\n   BITMAP_FREE (saved_components);\n }\n \n+/* Returns true when it is possible to generate a builtin pattern for\n+   the PARTITION of RDG.  For the moment we detect only the memset\n+   zero pattern.  */\n+\n+static bool\n+can_generate_builtin (struct graph *rdg, bitmap partition)\n+{\n+  unsigned i;\n+  bitmap_iterator bi;\n+  int nb_reads = 0;\n+  int nb_writes = 0;\n+  int stores_zero = 0;\n+\n+  EXECUTE_IF_SET_IN_BITMAP (partition, 0, i, bi)\n+    if (RDG_MEM_READS_STMT (rdg, i))\n+      nb_reads++;\n+    else if (RDG_MEM_WRITE_STMT (rdg, i))\n+      {\n+\tnb_writes++;\n+\tif (stmt_with_adjacent_zero_store_dr_p (RDG_STMT (rdg, i)))\n+\t  stores_zero++;\n+      }\n+\n+  return stores_zero == 1 && nb_writes == 1 && nb_reads == 0;\n+}\n+\n+/* Returns true when PARTITION1 and PARTITION2 have similar memory\n+   accesses in RDG.  */\n+\n+static bool\n+similar_memory_accesses (struct graph *rdg, bitmap partition1,\n+\t\t\t bitmap partition2)\n+{\n+  unsigned i, j;\n+  bitmap_iterator bi, bj;\n+\n+  EXECUTE_IF_SET_IN_BITMAP (partition1, 0, i, bi)\n+    if (RDG_MEM_WRITE_STMT (rdg, i)\n+\t|| RDG_MEM_READS_STMT (rdg, i))\n+      EXECUTE_IF_SET_IN_BITMAP (partition2, 0, j, bj)\n+\tif (RDG_MEM_WRITE_STMT (rdg, j)\n+\t    || RDG_MEM_READS_STMT (rdg, j))\n+\t  if (rdg_has_similar_memory_accesses (rdg, i, j))\n+\t    return true;\n+\n+  return false;\n+}\n+\n+/* Fuse all the partitions from PARTITIONS that contain similar memory\n+   references, i.e., we're taking care of cache locality.  This\n+   function does not fuse those partitions that contain patterns that\n+   can be code generated with builtins.  */\n+\n+static void\n+fuse_partitions_with_similar_memory_accesses (struct graph *rdg,\n+\t\t\t\t\t      VEC (bitmap, heap) **partitions)\n+{\n+  int p1, p2;\n+  bitmap partition1, partition2;\n+\n+  FOR_EACH_VEC_ELT (bitmap, *partitions, p1, partition1)\n+    if (!can_generate_builtin (rdg, partition1))\n+      FOR_EACH_VEC_ELT (bitmap, *partitions, p2, partition2)\n+\tif (p1 != p2\n+\t    && !can_generate_builtin (rdg, partition2)\n+\t    && similar_memory_accesses (rdg, partition1, partition2))\n+\t  {\n+\t    bitmap_ior_into (partition1, partition2);\n+\t    VEC_ordered_remove (bitmap, *partitions, p2);\n+\t    p2--;\n+\t  }\n+}\n+\n /* Aggregate several components into a useful partition that is\n    registered in the PARTITIONS vector.  Partitions will be\n    distributed in different loops.  */\n@@ -854,8 +830,7 @@ rdg_build_partitions (struct graph *rdg, VEC (rdgc, heap) *components,\n       if (bitmap_bit_p (processed, v))\n \tcontinue;\n \n-      np = build_rdg_partition_for_component (rdg, x, &part_has_writes,\n-\t\t\t\t\t      other_stores);\n+      np = build_rdg_partition_for_component (rdg, x, &part_has_writes);\n       bitmap_ior_into (partition, np);\n       bitmap_ior_into (processed, np);\n       BITMAP_FREE (np);\n@@ -901,6 +876,8 @@ rdg_build_partitions (struct graph *rdg, VEC (rdgc, heap) *components,\n     VEC_safe_push (bitmap, heap, *partitions, partition);\n   else\n     BITMAP_FREE (partition);\n+\n+  fuse_partitions_with_similar_memory_accesses (rdg, partitions);\n }\n \n /* Dump to FILE the PARTITIONS.  */"}]}