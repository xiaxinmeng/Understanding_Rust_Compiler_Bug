{"sha": "3ef397c1c6defdd895e5b1f41931176fe7706133", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2VmMzk3YzFjNmRlZmRkODk1ZTViMWY0MTkzMTE3NmZlNzcwNjEzMw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-12-21T02:11:10Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-12-21T02:11:10Z"}, "message": "cp-tree.h (CLASSTYPE_VFIELD_PARENT): Update comments.\n\n1999-12-20  Mark Mitchell  <mark@codesourcery.com>\n\n\t* cp-tree.h (CLASSTYPE_VFIELD_PARENT): Update comments.\n\t(CLASSTYPE_HAS_PRIMARY_BASE_P): New macro.\n\t(CLASSTYPE_PRIMARY_BINFO): Likewise.\n\t* class.c (check_methods): Don't set TYPE_HAS_COMPLEX_INIT_REF,\n\tTYPE_NEEDS_CONSTRUCTING, and CLASSTYPE_NON_AGGREGATE here.\n\t(check_bases_and_members): Set them here instead.\n\t(create_vtable_ptr): New function, split out from ...\n\t(finish_struct_1): ... here.  Use it.  Tidy.  Use\n\tCLASSTYPE_HAS_PRIMARY_BASE_P and CLASSTYPE_PRIMARY_BINFO.\n\t* search.c (dfs_init_vbase_pointers): Handle seeing TYPE_VFIELD as\n\tthe first field in the class.\n\t* tree.c (layout_basetypes): Use CLASSTYPE_N_BASECLASSES.  Handle\n\tseeing TYPE_VFIELD as the first field in the class.\n\nFrom-SVN: r31042", "tree": {"sha": "1baa694ed75cd886a2915d1c87150fa270a1062e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1baa694ed75cd886a2915d1c87150fa270a1062e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ef397c1c6defdd895e5b1f41931176fe7706133", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ef397c1c6defdd895e5b1f41931176fe7706133", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ef397c1c6defdd895e5b1f41931176fe7706133", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ef397c1c6defdd895e5b1f41931176fe7706133/comments", "author": null, "committer": null, "parents": [{"sha": "4c6b7393dcb6c97b57b5268dc84542369d5b367f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c6b7393dcb6c97b57b5268dc84542369d5b367f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c6b7393dcb6c97b57b5268dc84542369d5b367f"}], "stats": {"total": 312, "additions": 182, "deletions": 130}, "files": [{"sha": "9fa42692d0d3d011d30980271cc6c806905d4ef2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ef397c1c6defdd895e5b1f41931176fe7706133/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ef397c1c6defdd895e5b1f41931176fe7706133/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3ef397c1c6defdd895e5b1f41931176fe7706133", "patch": "@@ -1,5 +1,19 @@\n 1999-12-20  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* cp-tree.h (CLASSTYPE_VFIELD_PARENT): Update comments.\n+\t(CLASSTYPE_HAS_PRIMARY_BASE_P): New macro.\n+\t(CLASSTYPE_PRIMARY_BINFO): Likewise.\n+\t* class.c (check_methods): Don't set TYPE_HAS_COMPLEX_INIT_REF,\n+\tTYPE_NEEDS_CONSTRUCTING, and CLASSTYPE_NON_AGGREGATE here.\n+\t(check_bases_and_members): Set them here instead.\n+\t(create_vtable_ptr): New function, split out from ...\n+\t(finish_struct_1): ... here.  Use it.  Tidy.  Use\n+\tCLASSTYPE_HAS_PRIMARY_BASE_P and CLASSTYPE_PRIMARY_BINFO.\n+\t* search.c (dfs_init_vbase_pointers): Handle seeing TYPE_VFIELD as\n+\tthe first field in the class.\n+\t* tree.c (layout_basetypes): Use CLASSTYPE_N_BASECLASSES.  Handle\n+\tseeing TYPE_VFIELD as the first field in the class.\n+\t\n \t* cp-tree.h (TYPE_VIRTUAL_P): Rename to ...\n \t(TYPE_POLYMORPHIC_P): ... this.\n \t(TYPE_USES_COMPLEX_INHERITANCE): Rename to ..."}, {"sha": "14c67af4a7766ff8710f2e435587469c23453769", "filename": "gcc/cp/class.c", "status": "modified", "additions": 118, "deletions": 102, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ef397c1c6defdd895e5b1f41931176fe7706133/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ef397c1c6defdd895e5b1f41931176fe7706133/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=3ef397c1c6defdd895e5b1f41931176fe7706133", "patch": "@@ -133,6 +133,7 @@ static void check_methods PROTO((tree));\n static void remove_zero_width_bit_fields PROTO((tree));\n static void check_bases PROTO((tree, int *, int *, int *));\n static void check_bases_and_members PROTO((tree, int *));\n+static void create_vtable_ptr PROTO((tree, int *, int *, int *, tree *, tree *));\n \n /* Variables shared between class.c and call.c.  */\n \n@@ -3897,18 +3898,13 @@ build_base_fields (rec, empty_p)\n \n /* Go through the TYPE_METHODS of T issuing any appropriate\n    diagnostics, figuring out which methods override which other\n-   methods, and so forth.  Returns non-zero if this class has any\n-   virtual methods.  */\n+   methods, and so forth.  */\n \n static void\n check_methods (t)\n      tree t;\n {\n   tree x;\n-  int has_virtual;\n-\n-  /* Assume there are no virtual methods.  */\n-  has_virtual = 0;\n \n   for (x = TYPE_METHODS (t); x; x = TREE_CHAIN (x))\n     {\n@@ -3933,21 +3929,12 @@ check_methods (t)\n \t Save this in auxiliary field for later overloading.  */\n       if (DECL_VINDEX (x))\n \t{\n-\t  has_virtual = 1;\n+\t  TYPE_POLYMORPHIC_P (t) = 1;\n \t  if (DECL_ABSTRACT_VIRTUAL_P (x))\n \t    CLASSTYPE_ABSTRACT_VIRTUALS (t)\n \t      = tree_cons (NULL_TREE, x, CLASSTYPE_ABSTRACT_VIRTUALS (t));\n \t}\n     }\n-\n-  /* A class with virtual functions needs constructing because, if\n-     nothing else, the vtable pointer must be initialized.  */\n-  TYPE_HAS_COMPLEX_INIT_REF (t) |= has_virtual;\n-  TYPE_NEEDS_CONSTRUCTING (t) |= has_virtual;\n-  /* [dcl.init.aggr]\n-\n-     An aggregate is a ... class ... with ... no virtual functions.  */\n-  CLASSTYPE_NON_AGGREGATE (t) |= has_virtual;\n }\n \n /* Remove all zero-width bit-fields from T.  */\n@@ -4014,10 +4001,15 @@ check_bases_and_members (t, empty_p)\n   /* Do some bookkeeping that will guide the generation of implicitly\n      declared member functions.  */\n   TYPE_HAS_COMPLEX_INIT_REF (t)\n-    |= (TYPE_HAS_INIT_REF (t) || TYPE_USES_VIRTUAL_BASECLASSES (t));\n+    |= (TYPE_HAS_INIT_REF (t) \n+\t|| TYPE_USES_VIRTUAL_BASECLASSES (t)\n+\t|| TYPE_POLYMORPHIC_P (t));\n   TYPE_NEEDS_CONSTRUCTING (t)\n-    |= (TYPE_HAS_CONSTRUCTOR (t) || TYPE_USES_VIRTUAL_BASECLASSES (t));\n-  CLASSTYPE_NON_AGGREGATE (t) |= TYPE_HAS_CONSTRUCTOR (t);\n+    |= (TYPE_HAS_CONSTRUCTOR (t) \n+\t|| TYPE_USES_VIRTUAL_BASECLASSES (t)\n+\t|| TYPE_POLYMORPHIC_P (t));\n+  CLASSTYPE_NON_AGGREGATE (t) |= (TYPE_HAS_CONSTRUCTOR (t)\n+\t\t\t\t  || TYPE_POLYMORPHIC_P (t));\n   CLASSTYPE_NON_POD_P (t)\n     |= (CLASSTYPE_NON_AGGREGATE (t) || TYPE_HAS_DESTRUCTOR (t) \n \t|| TYPE_HAS_ASSIGN_REF (t));\n@@ -4044,6 +4036,84 @@ check_bases_and_members (t, empty_p)\n     }\n }\n \n+/* If T needs a pointer to its virtual function table, set TYPE_VFIELD\n+   accordingly, and, if necessary, add the TYPE_VFIELD to the\n+   TYPE_FIELDS list.  */\n+\n+static void\n+create_vtable_ptr (t, empty_p, has_virtual_p, max_has_virtual_p,\n+\t\t   pending_virtuals_p, pending_hard_virtuals_p)\n+     tree t;\n+     int *empty_p;\n+     int *has_virtual_p;\n+     int *max_has_virtual_p;\n+     tree *pending_virtuals_p;\n+     tree *pending_hard_virtuals_p;\n+{\n+  tree fn;\n+\n+  /* If possible, we reuse the virtual function table pointer from one\n+     of our base classes.  */\n+  if (CLASSTYPE_N_BASECLASSES (t))\n+    {\n+      struct base_info base_info;\n+\n+      /* Remember where we got our vfield from.  */\n+      CLASSTYPE_VFIELD_PARENT (t) = finish_base_struct (t, &base_info);\n+      *has_virtual_p = base_info.has_virtual;\n+      *max_has_virtual_p = base_info.max_has_virtual;\n+      TYPE_VFIELD (t) = base_info.vfield;\n+      CLASSTYPE_VFIELDS (t) = base_info.vfields;\n+      CLASSTYPE_RTTI (t) = base_info.rtti;\n+    }\n+\n+  /* Loop over the virtual functions, adding them to our various\n+     vtables.  */\n+  for (fn = TYPE_METHODS (t); fn; fn = TREE_CHAIN (fn))\n+    if (DECL_VINDEX (fn))\n+      add_virtual_function (pending_virtuals_p, pending_hard_virtuals_p,\n+\t\t\t    has_virtual_p, fn, t);\n+\n+  /* If we couldn't find an appropriate base class, create a new field\n+     here.  */\n+  if (*has_virtual_p && !TYPE_VFIELD (t))\n+    {\n+      /* We build this decl with vtbl_ptr_type_node, which is a\n+\t `vtable_entry_type*'.  It might seem more precise to use\n+\t `vtable_entry_type (*)[N]' where N is the number of firtual\n+\t functions.  However, that would require the vtable pointer in\n+\t base classes to have a different type than the vtable pointer\n+\t in derived classes.  We could make that happen, but that\n+\t still wouldn't solve all the problems.  In particular, the\n+\t type-based alias analysis code would decide that assignments\n+\t to the base class vtable pointer can't alias assignments to\n+\t the derived class vtable pointer, since they have different\n+\t types.  Thus, in an derived class destructor, where the base\n+\t class constructor was inlined, we could generate bad code for\n+\t setting up the vtable pointer.  \n+\n+         Therefore, we use one type for all vtable pointers.  We still\n+\t use a type-correct type; it's just doesn't indicate the array\n+\t bounds.  That's better than using `void*' or some such; it's\n+\t cleaner, and it let's the alias analysis code know that these\n+\t stores cannot alias stores to void*!  */\n+      TYPE_VFIELD (t) \n+\t= build_vtbl_or_vbase_field (get_vfield_name (t),\n+\t\t\t\t     get_identifier (VFIELD_BASE),\n+\t\t\t\t     vtbl_ptr_type_node,\n+\t\t\t\t     t,\n+\t\t\t\t     empty_p);\n+\n+      /* Add the new field to the list of fields in this class.  */\n+      TYPE_FIELDS (t) = chainon (TYPE_FIELDS (t), TYPE_VFIELD (t));\n+\n+      /* We can't yet add this new field to the list of all virtual\n+\t function table pointers in this class.  The\n+\t modify_all_vtables function depends on this not being done.\n+\t So, it is done later, in finish_struct_1.  */\n+    }\n+}\n+\n /* Create a RECORD_TYPE or UNION_TYPE node for a C struct or union declaration\n    (or C++ class declaration).\n \n@@ -4080,14 +4150,8 @@ finish_struct_1 (t)\n   int max_has_virtual;\n   tree pending_virtuals = NULL_TREE;\n   tree pending_hard_virtuals = NULL_TREE;\n-  tree vfield;\n-  tree vfields;\n   int n_fields = 0;\n-\n-  /* The index of the first base class which has virtual\n-     functions.  Only applied to non-virtual baseclasses.  */\n-  int first_vfn_base_index;\n-\n+  tree vfield;\n   int n_baseclasses;\n   int empty = 1;\n   tree inline_friends;\n@@ -4110,11 +4174,9 @@ finish_struct_1 (t)\n   TYPE_SIZE (t) = NULL_TREE;\n   CLASSTYPE_GOT_SEMICOLON (t) = 0;\n \n-  first_vfn_base_index = -1;\n+  CLASSTYPE_VFIELD_PARENT (t) = -1;\n   has_virtual = 0;\n   max_has_virtual = 0;\n-  vfield = NULL_TREE;\n-  vfields = NULL_TREE;\n   CLASSTYPE_RTTI (t) = NULL_TREE;\n   n_baseclasses = CLASSTYPE_N_BASECLASSES (t);\n \n@@ -4129,59 +4191,9 @@ finish_struct_1 (t)\n   TYPE_FIELDS (t) = chainon (build_base_fields (t, &empty), \n \t\t\t     TYPE_FIELDS (t));\n \n-  if (n_baseclasses > 0)\n-    {\n-      struct base_info base_info;\n-\n-      first_vfn_base_index = finish_base_struct (t, &base_info);\n-      /* Remember where we got our vfield from.  */\n-      CLASSTYPE_VFIELD_PARENT (t) = first_vfn_base_index;\n-      has_virtual = base_info.has_virtual;\n-      max_has_virtual = base_info.max_has_virtual;\n-      vfield = base_info.vfield;\n-      TYPE_VFIELD (t) = vfield;\n-      vfields = base_info.vfields;\n-      CLASSTYPE_VFIELDS (t) = vfields;\n-      CLASSTYPE_RTTI (t) = base_info.rtti;\n-    }\n-\n-  /* Loop over the virtual functions, adding them to our various\n-     vtables.  */\n-  for (x = TYPE_METHODS (t); x; x = TREE_CHAIN (x))\n-    if (DECL_VINDEX (x))\n-      add_virtual_function (&pending_virtuals, &pending_hard_virtuals,\n-\t\t\t    &has_virtual, x, t);\n-\n-  if (vfield == NULL_TREE && has_virtual)\n-    {\n-      /* We build this decl with vtbl_ptr_type_node, which is a\n-\t `vtable_entry_type*'.  It might seem more precise to use\n-\t `vtable_entry_type (*)[N]' where N is the number of firtual\n-\t functions.  However, that would require the vtable pointer in\n-\t base classes to have a different type than the vtable pointer\n-\t in derived classes.  We could make that happen, but that\n-\t still wouldn't solve all the problems.  In particular, the\n-\t type-based alias analysis code would decide that assignments\n-\t to the base class vtable pointer can't alias assignments to\n-\t the derived class vtable pointer, since they have different\n-\t types.  Thus, in an derived class destructor, where the base\n-\t class constructor was inlined, we could generate bad code for\n-\t setting up the vtable pointer.  \n-\n-         Therefore, we use one type for all vtable pointers.  We still\n-\t use a type-correct type; it's just doesn't indicate the array\n-\t bounds.  That's better than using `void*' or some such; it's\n-\t cleaner, and it let's the alias analysis code know that these\n-\t stores cannot alias stores to void*!  */\n-      vfield = build_vtbl_or_vbase_field (get_vfield_name (t),\n-\t\t\t\t\t  get_identifier (VFIELD_BASE),\n-\t\t\t\t\t  vtbl_ptr_type_node,\n-\t\t\t\t\t  t,\n-\t\t\t\t\t  &empty);\n-      TYPE_VFIELD (t) = vfield;\n-      TYPE_FIELDS (t) = chainon (TYPE_FIELDS (t), vfield);\n-      vfields = chainon (vfields, build_tree_list (NULL_TREE, t));\n-    }\n+  /* Create a pointer to our virtual function table.  */\n+  create_vtable_ptr (t, &empty, &has_virtual, &max_has_virtual,\n+\t\t     &pending_virtuals, &pending_hard_virtuals);\n \n   /* CLASSTYPE_INLINE_FRIENDS is really TYPE_NONCOPIED_PARTS.  Thus,\n      we have to save this before we start modifying\n@@ -4205,13 +4217,22 @@ finish_struct_1 (t)\n       TREE_STATIC (TYPE_NONCOPIED_PARTS (t)) = 1;\n     }\n \n+  /* Let the back-end lay out the type. Note that at this point we\n+     have only included non-virtual base-classes; we will lay out the\n+     virtual base classes later.  So, the TYPE_SIZE/TYPE_ALIGN after\n+     this call are not necessarily correct; they are just the size and\n+     alignment when no virtual base clases are used.  */\n   layout_type (t);\n \n   /* If we added an extra field to make this class non-empty, remove\n      it now.  */\n   if (empty)\n     TYPE_FIELDS (t) = TREE_CHAIN (TYPE_FIELDS (t));\n \n+  /* Delete all zero-width bit-fields from the list of fields.  Now\n+     that the type is laid out they are no longer important.  */\n+  remove_zero_width_bit_fields (t);\n+\n   /* Remember the size and alignment of the class before adding\n      the virtual bases.  */\n   if (empty && flag_new_abi)\n@@ -4232,16 +4253,11 @@ finish_struct_1 (t)\n   /* Now fix up any virtual base class types that we left lying\n      around.  We must get these done before we try to lay out the\n      virtual function table.  */\n-  pending_hard_virtuals = nreverse (pending_hard_virtuals);\n \n   if (n_baseclasses)\n     /* layout_basetypes will remove the base subobject fields.  */\n     max_has_virtual = layout_basetypes (t, max_has_virtual);\n \n-  /* Delete all zero-width bit-fields from the list of fields.  Now\n-     that we have layed out the type they are no longer important.  */\n-  remove_zero_width_bit_fields (t);\n-\n   if (TYPE_USES_VIRTUAL_BASECLASSES (t))\n     {\n       tree vbases;\n@@ -4275,6 +4291,7 @@ finish_struct_1 (t)\n   /* Set up the DECL_FIELD_BITPOS of the vfield if we need to, as we\n      might need to know it for setting up the offsets in the vtable\n      (or in thunks) below.  */\n+  vfield = TYPE_VFIELD (t);\n   if (vfield != NULL_TREE\n       && DECL_FIELD_CONTEXT (vfield) != t)\n     {\n@@ -4293,9 +4310,6 @@ finish_struct_1 (t)\n       TYPE_VFIELD (t) = vfield;\n     }\n \n-  /* If this vtbl pointer is new, add it to the list of vtbl\n-     pointers in this class.  */\n-    \n   if (has_virtual > max_has_virtual)\n     max_has_virtual = has_virtual;\n   if (max_has_virtual > 0)\n@@ -4335,7 +4349,7 @@ finish_struct_1 (t)\n     {\n       pending_virtuals = nreverse (pending_virtuals);\n       /* We must enter these virtuals into the table.  */\n-      if (first_vfn_base_index < 0)\n+      if (!CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n \t{\n \t  if (! CLASSTYPE_COM_INTERFACE (t))\n \t    {\n@@ -4357,7 +4371,7 @@ finish_struct_1 (t)\n \t     function table, but we will wait until later this function.  */\n \n \t  if (! BINFO_NEW_VTABLE_MARKED (TYPE_BINFO (t)))\n-\t    build_vtable (TREE_VEC_ELT (TYPE_BINFO_BASETYPES (t), first_vfn_base_index), t);\n+\t    build_vtable (CLASSTYPE_PRIMARY_BINFO (t), t);\n \t}\n \n       /* If this type has basetypes with constructors, then those\n@@ -4367,9 +4381,10 @@ finish_struct_1 (t)\n \n       CLASSTYPE_NEEDS_VIRTUAL_REINIT (t) = 1;\n     }\n-  else if (first_vfn_base_index >= 0)\n+  else if (CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n     {\n-      tree binfo = TREE_VEC_ELT (TYPE_BINFO_BASETYPES (t), first_vfn_base_index);\n+      tree binfo = CLASSTYPE_PRIMARY_BINFO (t);\n+\n       /* This class contributes nothing new to the virtual function\n \t table.  However, it may have declared functions which\n \t went into the virtual function table \"inherited\" from the\n@@ -4385,10 +4400,10 @@ finish_struct_1 (t)\n \tCLASSTYPE_NEEDS_VIRTUAL_REINIT (t) = 1;\n     }\n \n-  if (max_has_virtual || first_vfn_base_index >= 0)\n+  if (max_has_virtual || CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n     {\n       CLASSTYPE_VSIZE (t) = has_virtual;\n-      if (first_vfn_base_index >= 0)\n+      if (CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n \t{\n \t  if (pending_virtuals)\n \t    TYPE_BINFO_VIRTUALS (t) = chainon (TYPE_BINFO_VIRTUALS (t),\n@@ -4410,8 +4425,6 @@ finish_struct_1 (t)\n \n       layout_type (atype);\n \n-      TYPE_VFIELD (t) = vfield;\n-\n       /* We may have to grow the vtable.  */\n       if (TREE_TYPE (TYPE_BINFO_VTABLE (t)) != atype)\n \t{\n@@ -4425,9 +4438,12 @@ finish_struct_1 (t)\n \t\t   DECL_ALIGN (TYPE_BINFO_VTABLE (t)));\n \t}\n     }\n-  else if (first_vfn_base_index >= 0)\n-    TYPE_VFIELD (t) = vfield;\n-  CLASSTYPE_VFIELDS (t) = vfields;\n+\n+  /* If we created a new vtbl pointer for this class, add it to the\n+     list.  */\n+  if (TYPE_VFIELD (t) && CLASSTYPE_VFIELD_PARENT (t) == -1)\n+    CLASSTYPE_VFIELDS (t) \n+      = chainon (CLASSTYPE_VFIELDS (t), build_tree_list (NULL_TREE, t));\n \n   finish_struct_bits (t, max_has_virtual);\n \n@@ -4488,7 +4504,7 @@ finish_struct_1 (t)\n \t a place to find them.  */\n       TYPE_NONCOPIED_PARTS (t) \n \t= tree_cons (default_conversion (TYPE_BINFO_VTABLE (t)),\n-\t\t     vfield, TYPE_NONCOPIED_PARTS (t));\n+\t\t     TYPE_VFIELD (t), TYPE_NONCOPIED_PARTS (t));\n \n       if (warn_nonvdtor && TYPE_HAS_DESTRUCTOR (t)\n \t  && DECL_VINDEX (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (t), 1)) == NULL_TREE)"}, {"sha": "995bc516694901913a15d4e558d52f9a54b309b4", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ef397c1c6defdd895e5b1f41931176fe7706133/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ef397c1c6defdd895e5b1f41931176fe7706133/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=3ef397c1c6defdd895e5b1f41931176fe7706133", "patch": "@@ -1382,13 +1382,26 @@ struct lang_type\n    nested member class templates.  */\n #define CLASSTYPE_TAGS(NODE)\t\t(TYPE_LANG_SPECIFIC(NODE)->tags)\n \n-/* If this class has any bases, this is the number of the base class from\n-   which our VFIELD is based, -1 otherwise.  If this class has no base\n-   classes, this is not used.\n-   In D : B1, B2, PARENT would be 0, if D's vtable came from B1,\n-   1, if D's vtable came from B2.  */\n+/* If this value is non-negative, it is the index (in the\n+   TYPE_BINFO_BASETYPES) for the base-class whose vtable pointer we\n+   are reusing.  For example, in D : B1, B2, PARENT would be 0, if D's\n+   vtable came from B1, 1, if D's vtable came from B2.  */\n #define CLASSTYPE_VFIELD_PARENT(NODE)\t(TYPE_LANG_SPECIFIC(NODE)->vfield_parent)\n \n+/* Nonzero if NODE has a primary base class, i.e., a base class with\n+   which it shares the virtual fucntion table pointer.  */\n+#define CLASSTYPE_HAS_PRIMARY_BASE_P(NODE) \\\n+  (CLASSTYPE_VFIELD_PARENT (NODE) != -1)\n+\n+/* If non-NULL, this is the binfo for the primary base class, i.e.,\n+   the base class which contains the virtual function table pointer\n+   for this class.  */\n+#define CLASSTYPE_PRIMARY_BINFO(NODE) \t\t\t\\\n+  (CLASSTYPE_HAS_PRIMARY_BASE_P (NODE)\t\t\t\\\n+   ? TREE_VEC_ELT (TYPE_BINFO_BASETYPES (NODE),\t\t\\\n+\t\t   CLASSTYPE_VFIELD_PARENT (NODE))\t\\\n+   : NULL_TREE)\n+\n /* The number of virtual functions defined for this\n    _CLASSTYPE node.  */\n #define CLASSTYPE_VSIZE(NODE) (TYPE_LANG_SPECIFIC(NODE)->vsize)"}, {"sha": "8ee63f162cd14f93900084965bfd6630d0021acc", "filename": "gcc/cp/search.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ef397c1c6defdd895e5b1f41931176fe7706133/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ef397c1c6defdd895e5b1f41931176fe7706133/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=3ef397c1c6defdd895e5b1f41931176fe7706133", "patch": "@@ -2432,18 +2432,11 @@ dfs_init_vbase_pointers (binfo, data)\n {\n   struct vbase_info *vi = (struct vbase_info *) data;\n   tree type = BINFO_TYPE (binfo);\n-  tree fields = TYPE_FIELDS (type);\n+  tree fields;\n   tree this_vbase_ptr;\n \n   CLEAR_BINFO_VTABLE_PATH_MARKED (binfo);\n \n-#if 0\n-  /* See finish_struct_1 for when we can enable this.  */\n-  /* If we have a vtable pointer first, skip it.  */\n-  if (VFIELD_NAME_P (DECL_NAME (fields)))\n-    fields = TREE_CHAIN (fields);\n-#endif\n-\n   if (BINFO_INHERITANCE_CHAIN (binfo))\n     {\n       this_vbase_ptr = TREE_CHAIN (BINFO_INHERITANCE_CHAIN (binfo));\n@@ -2457,6 +2450,14 @@ dfs_init_vbase_pointers (binfo, data)\n   else\n     this_vbase_ptr = TREE_CHAIN (binfo);\n \n+  /* We're going to iterate through all the pointers to virtual\n+     base-classes.  They come at the beginning of the class.  */\n+  fields = TYPE_FIELDS (type);\n+  if (fields == TYPE_VFIELD (type))\n+    /* If the first field is the vtbl pointer (as happens in the new\n+       ABI), skip it.  */\n+    fields = TREE_CHAIN (fields);\n+\n   if (fields == NULL_TREE\n       || DECL_NAME (fields) == NULL_TREE\n       || ! VBASE_NAME_P (DECL_NAME (fields)))"}, {"sha": "39447eee1c7d277061fcdf3da08323901c48b2a0", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ef397c1c6defdd895e5b1f41931176fe7706133/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ef397c1c6defdd895e5b1f41931176fe7706133/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=3ef397c1c6defdd895e5b1f41931176fe7706133", "patch": "@@ -693,15 +693,7 @@ propagate_binfo_offsets (binfo, offset)\n \t\tbreak;\n \t      }\n \n-#if 0\n-\t  if (BINFO_OFFSET_ZEROP (base_binfo))\n-\t    BINFO_OFFSET (base_binfo) = offset;\n-\t  else\n-\t    BINFO_OFFSET (base_binfo)\n-\t      = size_binop (PLUS_EXPR, BINFO_OFFSET (base_binfo), offset);\n-#else\n \t  BINFO_OFFSET (base_binfo) = offset;\n-#endif\n \n \t  propagate_binfo_offsets (base_binfo, offset);\n \n@@ -759,9 +751,9 @@ layout_basetypes (rec, max)\n      int max;\n {\n   tree binfos = TYPE_BINFO_BASETYPES (rec);\n-  int i, n_baseclasses = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-\n+  int i, n_baseclasses = CLASSTYPE_N_BASECLASSES (rec);\n   tree vbase_types;\n+  tree *field;\n \n   unsigned int record_align = MAX (BITS_PER_UNIT, TYPE_ALIGN (rec));\n   unsigned int desired_align;\n@@ -835,27 +827,43 @@ layout_basetypes (rec, max)\n                                          size_int (BITS_PER_UNIT));\n     }\n \n-  /* Now propagate offset information throughout the lattice.  */\n+  /* Now propagate offset information throughout the lattice.\n+     Simultaneously, remove the temporary FIELD_DECLS we created in\n+     build_base_fields to refer to base types.  */\n+  field = &TYPE_FIELDS (rec);\n+  if (TYPE_VFIELD (rec) == *field)\n+    {\n+      /* If this class did not have a primary base, we create a\n+\t virtual function table pointer.  It will be the first thing\n+\t in the class, under the new ABI.  Skip it; the base fields\n+\t will follow it.  */\n+      my_friendly_assert (flag_new_abi \n+\t\t\t  && !CLASSTYPE_HAS_PRIMARY_BASE_P (rec),\n+\t\t\t  19991218);\n+      field = &TREE_CHAIN (*field);\n+    }\n+    \n   for (i = 0; i < n_baseclasses; i++)\n     {\n       register tree base_binfo = TREE_VEC_ELT (binfos, i);\n       register tree basetype = BINFO_TYPE (base_binfo);\n-      tree field = TYPE_FIELDS (rec);\n \n       if (TREE_VIA_VIRTUAL (base_binfo))\n \tcontinue;\n \n-      my_friendly_assert (TREE_TYPE (field) == basetype, 23897);\n+      my_friendly_assert (TREE_TYPE (*field) == basetype, 23897);\n \n       if (get_base_distance (basetype, rec, 0, (tree*)0) == -2)\n \tcp_warning (\"direct base `%T' inaccessible in `%T' due to ambiguity\",\n \t\t    basetype, rec);\n \n       BINFO_OFFSET (base_binfo)\n-\t= size_int (CEIL (TREE_INT_CST_LOW (DECL_FIELD_BITPOS (field)),\n+\t= size_int (CEIL (TREE_INT_CST_LOW (DECL_FIELD_BITPOS (*field)),\n \t\t\t  BITS_PER_UNIT));\n       propagate_binfo_offsets (base_binfo, BINFO_OFFSET (base_binfo));\n-      TYPE_FIELDS (rec) = TREE_CHAIN (field);\n+\n+      /* Remove this field.  */\n+      *field = TREE_CHAIN (*field);\n     }\n \n   for (vbase_types = CLASSTYPE_VBASECLASSES (rec); vbase_types;"}]}