{"sha": "961b7009ee1561d8a7aeb1c3b2a005baf9898610", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTYxYjcwMDllZTE1NjFkOGE3YWViMWMzYjJhMDA1YmFmOTg5ODYxMA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1996-08-12T16:36:42Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1996-08-12T16:36:42Z"}, "message": "Speed up genmultilib; Add MULTIB_EXTRA_OPTS\n\nFrom-SVN: r12623", "tree": {"sha": "18b3fb55a416937a381879e9ebe33fdb4254af8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18b3fb55a416937a381879e9ebe33fdb4254af8d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/961b7009ee1561d8a7aeb1c3b2a005baf9898610", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/961b7009ee1561d8a7aeb1c3b2a005baf9898610", "html_url": "https://github.com/Rust-GCC/gccrs/commit/961b7009ee1561d8a7aeb1c3b2a005baf9898610", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/961b7009ee1561d8a7aeb1c3b2a005baf9898610/comments", "author": null, "committer": null, "parents": [{"sha": "4e05a62cb769ebe4f413a9119d7729126e85302b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e05a62cb769ebe4f413a9119d7729126e85302b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e05a62cb769ebe4f413a9119d7729126e85302b"}], "stats": {"total": 252, "additions": 202, "deletions": 50}, "files": [{"sha": "71e89713b866ef909b2892deb3da839f800002a8", "filename": "gcc/Makefile.in", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961b7009ee1561d8a7aeb1c3b2a005baf9898610/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961b7009ee1561d8a7aeb1c3b2a005baf9898610/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=961b7009ee1561d8a7aeb1c3b2a005baf9898610", "patch": "@@ -550,7 +550,7 @@ CCCP=cccp\n STAGESTUFF = *$(objext) insn-flags.h insn-config.h insn-codes.h \\\n  insn-output.c insn-recog.c insn-emit.c insn-extract.c insn-peep.c \\\n  insn-attr.h insn-attrtab.c insn-opinit.c \\\n- stamp-flags stamp-config stamp-codes \\\n+ stamp-flags stamp-config stamp-codes stamp-mlib \\\n  stamp-output stamp-recog stamp-emit stamp-extract stamp-peep \\\n  stamp-attr stamp-attrtab stamp-opinit stamp-proto stamp-crt stamp-crtS stamp-crt0 \\\n  genemit$(exeext) genoutput$(exeext) genrecog$(exeext) genextract$(exeext) \\\n@@ -955,9 +955,16 @@ libgcc.a: $(LIBGCC1) $(LIBGCC2)\n # Use the genmultilib shell script to generate the information the gcc\n # driver program needs to select the library directory based on the\n # switches.\n-multilib.h: $(srcdir)/genmultilib Makefile\n-\t$(SHELL) $(srcdir)/genmultilib \"$(MULTILIB_OPTIONS)\" \\\n-\t  \"$(MULTILIB_DIRNAMES)\" \"$(MULTILIB_MATCHES)\" \"$(MULTILIB_EXCEPTIONS)\" > multilib.h\n+multilib.h: stamp-mlib; @true\n+stamp-mlib: $(srcdir)/genmultilib Makefile\n+\t$(SHELL) $(srcdir)/genmultilib \\\n+\t  \"$(MULTILIB_OPTIONS)\" \\\n+\t  \"$(MULTILIB_DIRNAMES)\" \\\n+\t  \"$(MULTILIB_MATCHES)\" \\\n+\t  \"$(MULTILIB_EXCEPTIONS)\" \\\n+\t  \"$(MULTILIB_EXTRA_OPTS)\" > tmp-mlib.h\n+\t$(srcdir)/move-if-change tmp-mlib.h multilib.h\n+\ttouch stamp-mlib\n \n # Build multiple copies of libgcc.a, one for each target switch.\n stmp-multilib: $(LIBGCC1) libgcc2.c libgcc2.ready $(CONFIG_H) \\"}, {"sha": "46ca22bc5434dd33408f014cbae249629f2a5b6d", "filename": "gcc/gcc.c", "status": "modified", "additions": 160, "deletions": 26, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961b7009ee1561d8a7aeb1c3b2a005baf9898610/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961b7009ee1561d8a7aeb1c3b2a005baf9898610/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=961b7009ee1561d8a7aeb1c3b2a005baf9898610", "patch": "@@ -491,12 +491,21 @@ static char *startfile_spec = STARTFILE_SPEC;\n static char *switches_need_spaces = SWITCHES_NEED_SPACES;\n \n /* Some compilers have limits on line lengths, and the multilib_select\n-   string can be very long, so we build it at run time.  */\n+   and/or multilib_matches strings can be very long, so we build them at\n+   run time.  */\n static struct obstack multilib_obstack;\n-static char *multilib_raw[] = {\n-#include \"multilib.h\"\n-};\n static char *multilib_select;\n+static char *multilib_matches;\n+static char *multilib_defaults;\n+#include \"multilib.h\"\n+\n+/* Check whether a particular argument is a default argument.  */\n+\n+#ifndef MULTILIB_DEFAULTS\n+#define MULTILIB_DEFAULTS { \"\" }\n+#endif\n+\n+static char *multilib_defaults_raw[] = MULTILIB_DEFAULTS;\n \n #ifdef EXTRA_SPECS\n static struct { char *name, *spec; } extra_specs[] = { EXTRA_SPECS };\n@@ -1223,6 +1232,12 @@ set_spec (name, spec)\n     cross_compile = atoi (sl->spec);\n   else if (! strcmp (name, \"multilib\"))\n     multilib_select = sl->spec;\n+  else if (! strcmp (name, \"multilib_matches\"))\n+    multilib_matches = sl->spec;\n+  else if (! strcmp (name, \"multilib_extra\"))\n+    multilib_extra = sl->spec;\n+  else if (! strcmp (name, \"multilib_defaults\"))\n+    multilib_defaults = sl->spec;\n #ifdef EXTRA_SPECS\n   else\n     {\n@@ -2244,6 +2259,9 @@ process_command (argc, argv)\n \t  printf (\"*predefines:\\n%s\\n\\n\", cpp_predefines);\n \t  printf (\"*cross_compile:\\n%d\\n\\n\", cross_compile);\n \t  printf (\"*multilib:\\n%s\\n\\n\", multilib_select);\n+\t  printf (\"*multilib_defaults:\\n%s\\n\\n\", multilib_defaults);\n+\t  printf (\"*multilib_extra:\\n%s\\n\\n\", multilib_extra);\n+\t  printf (\"*multilib_matches:\\n%s\\n\\n\", multilib_matches);\n \n #ifdef EXTRA_SPECS\n \t  {\n@@ -4027,17 +4045,41 @@ main (argc, argv)\n \n   obstack_init (&obstack);\n \n-  /* Build multilib_select from the separate lines that make up each multilib\n-     selection.  */\n+  /* Build multilib_select, et. al from the separate lines that make up each\n+     multilib selection.  */\n   {\n     char **q = multilib_raw;\n+    int need_space;\n \n     obstack_init (&multilib_obstack);\n     while ((p = *q++) != (char *) 0)\n       obstack_grow (&multilib_obstack, p, strlen (p));\n \n     obstack_1grow (&multilib_obstack, 0);\n     multilib_select = obstack_finish (&multilib_obstack);\n+\n+    q = multilib_matches_raw;\n+    while ((p = *q++) != (char *) 0)\n+      obstack_grow (&multilib_obstack, p, strlen (p));\n+\n+    obstack_1grow (&multilib_obstack, 0);\n+    multilib_matches = obstack_finish (&multilib_obstack);\n+\n+    need_space = FALSE;\n+    for (i = 0;\n+\t i < sizeof (multilib_defaults_raw) / sizeof (multilib_defaults_raw[0]);\n+\t i++)\n+      {\n+\tif (need_space)\n+\t  obstack_1grow (&multilib_obstack, ' ');\n+\tobstack_grow (&multilib_obstack,\n+\t\t      multilib_defaults_raw[i],\n+\t\t      strlen (multilib_defaults_raw[i]));\n+\tneed_space = TRUE;\n+      }\n+\n+    obstack_1grow (&multilib_obstack, 0);\n+    multilib_defaults = obstack_finish (&multilib_obstack);\n   }\n \n   /* Set up to remember the pathname of gcc and any options\n@@ -4825,43 +4867,114 @@ validate_switches (start)\n     }\n }\n \f\n-/* Check whether a particular argument was used.  */\n+/* Check whether a particular argument was used.  The first time we\n+   canonialize the switches to keep only the ones we care about.  */\n \n static int\n used_arg (p, len)\n      char *p;\n      int len;\n {\n-  int i;\n+  struct mswitchstr {\n+    char *str;\n+    char *replace;\n+    int len;\n+    int rep_len;\n+  };\n+\n+  static struct mswitchstr *mswitches;\n+  static int n_mswitches;\n+  int i, j;\n+\n+  if (!mswitches)\n+    {\n+      struct mswitchstr *matches;\n+      char *q;\n+      int cnt = (*multilib_matches != '\\0');\n+\n+      /* Break multilib_matches into the component strings of string and replacement\n+         string */\n+      for (p = multilib_matches; *p != '\\0'; p++)\n+\tif (*p == ';')\n+\t  cnt++;\n+\n+      matches = (struct mswitchstr *) alloca ((sizeof (struct mswitchstr)) * cnt);\n+      i = 0;\n+      q = multilib_matches;\n+      while (*q != '\\0')\n+\t{\n+\t  matches[i].str = q;\n+\t  while (*q != ' ')\n+\t    {\n+\t      if (*q == '\\0')\n+\t\tabort ();\n+\t      q++;\n+\t    }\n+\t  *q = '\\0';\n+\t  matches[i].len = q - matches[i].str;\n \n-  for (i = 0; i < n_switches; i++)\n-    if (! strncmp (switches[i].part1, p, len)\n-\t&& strlen (switches[i].part1) == len)\n-      return 1;\n-  return 0;\n-}\n+\t  matches[i].replace = ++q;\n+\t  while (*q != ';' && *q != '\\0')\n+\t    {\n+\t      if (*q == ' ')\n+\t\tabort ();\n+\t      q++;\n+\t    }\n+\t  matches[i].rep_len = q - matches[i].replace;\n+\t  i++;\n+\t  if (*q == ';')\n+\t    *q++ = '\\0';\n+\t  else\n+\t    break;\n+\t}\n \n-/* Check whether a particular argument is a default argument.  */\n+      /* Now build a list of the replacement string for switches that we care about */\n+      mswitches = (struct mswitchstr *) xmalloc ((sizeof (struct mswitchstr)) * n_switches);\n+      for (i = 0; i < n_switches; i++)\n+\t{\n+\t  int xlen = strlen (switches[i].part1);\n+\t  for (j = 0; j < cnt; j++)\n+\t    if (xlen == matches[j].len && ! strcmp (switches[i].part1, matches[j].str))\n+\t      {\n+\t\tmswitches[n_mswitches].str = matches[j].replace;\n+\t\tmswitches[n_mswitches].len = matches[j].rep_len;\n+\t\tmswitches[n_mswitches].replace = (char *)0;\n+\t\tmswitches[n_mswitches].rep_len = 0;\n+\t\tn_mswitches++;\n+\t\tbreak;\n+\t      }\n+\t}\n+    }\n \n-#ifndef MULTILIB_DEFAULTS\n-#define MULTILIB_DEFAULTS { NULL }\n-#endif\n+  for (i = 0; i < n_mswitches; i++)\n+    if (len == mswitches[i].len && ! strncmp (p, mswitches[i].str, len))\n+      return 1;\n \n-static char *multilib_defaults[] = MULTILIB_DEFAULTS;\n+  return 0;\n+}\n \n static int\n default_arg (p, len)\n      char *p;\n      int len;\n {\n-  int count = sizeof multilib_defaults / sizeof multilib_defaults[0];\n+  char *start, *end;\n   int i;\n \n-  for (i = 0; i < count; i++)\n-    if (multilib_defaults[i] != NULL\n-\t&& strncmp (multilib_defaults[i], p, len) == 0\n-\t&& multilib_defaults[i][len] == '\\0')\n-      return 1;\n+  for (start = multilib_defaults; *start != '\\0'; start = end+1)\n+    {\n+      while (*start == ' ' || *start == '\\t')\n+\tstart++;\n+\n+      if (*start == '\\0')\n+\tbreak;\n+\n+      for (end = start+1; *end != ' ' && *end != '\\t' && *end != '\\0'; end++)\n+\t;\n+\n+      if ((end - start) == len && strncmp (p, start, len) == 0)\n+\treturn 1;\n+    }\n \n   return 0;\n }\n@@ -5089,7 +5202,28 @@ print_multilib_info ()\n \t}\n \n       if (! skip)\n-\tputchar ('\\n');\n+\t{\n+\t  /* If there are extra options, print them now */\n+\t  if (multilib_extra && *multilib_extra)\n+\t    {\n+\t      int print_at = TRUE;\n+\t      char *q;\n+\n+\t      for (q = multilib_extra; *q != '\\0'; q++)\n+\t\t{\n+\t\t  if (*q == ' ')\n+\t\t    print_at = TRUE;\n+\t\t  else\n+\t\t    {\n+\t\t      if (print_at)\n+\t\t\tputchar ('@');\n+\t\t      putchar (*q);\n+\t\t      print_at = FALSE;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  putchar ('\\n');\n+\t}\n \n       ++p;\n     }"}, {"sha": "1ae690b697f6b79e3c6470e1b8659293abbde0c7", "filename": "gcc/genmultilib", "status": "modified", "additions": 31, "deletions": 20, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961b7009ee1561d8a7aeb1c3b2a005baf9898610/gcc%2Fgenmultilib", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961b7009ee1561d8a7aeb1c3b2a005baf9898610/gcc%2Fgenmultilib", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmultilib?ref=961b7009ee1561d8a7aeb1c3b2a005baf9898610", "patch": "@@ -1,6 +1,6 @@\n #!/bin/sh \n # Generates multilib.h.\n-#   Copyright (C) 1994, 1995 Free Software Foundation, Inc.\n+#   Copyright (C) 1994, 1995, 1996 Free Software Foundation, Inc.\n \n #This file is part of GNU CC.\n \n@@ -45,6 +45,9 @@\n # The optional fourth argument is a list of multilib directory \n # combinations that should not be built.\n \n+# The optional fifth argument is a list of options that should be\n+# used whenever building multilib libraries.\n+\n # The output looks like\n #   #define MULTILIB_MATCHES \"\\\n #   SUBDIRECTORY OPTIONS;\\\n@@ -81,6 +84,9 @@ options=$1\n dirnames=$2\n matches=$3\n exceptions=$4\n+extra=$5\n+\n+echo \"static char *multilib_raw[] = {\"\n \n # What we want to do is select all combinations of the sets in\n # options.  Each combination which includes a set of mutually\n@@ -158,16 +164,6 @@ if [ -n \"${dirnames}\" ]; then\n   done\n fi\n \n-# Construct a sed pattern which will add negations based on the\n-# matches.  The semicolons are easier than getting the shell to accept\n-# quoted spaces when expanding a variable.\n-matchnegations=\n-for i in ${matches}; do\n-  l=`echo $i | sed -e 's/=.*$//' -e 's/?/=/g'`\n-  r=`echo $i | sed -e 's/^.*=//' -e 's/?/=/g'`\n-  matchnegations=\"${matchnegations} -e s/;!${l};/;!${l};!${r};/\"\n-done\n-\n # We need another recursive shell script to correctly handle positive\n # matches.  If we are invoked as\n #   genmultilib \"opt1 opt2\" \"\" \"opt1=nopt1 opt2=nopt2\"\n@@ -207,9 +203,6 @@ for set in ${options}; do\n   done\n done\n optout=`echo ${optout} | sed -e 's/^ //'`\n-if [ -n \"${matchnegations}\" ]; then\n-  optout=`echo \";${optout};\" | sed -e 's/ /;/g' ${matchnegations} -e 's/^;//' -e 's/;$//' -e 's/;/ /g'`\n-fi\n echo \"\\\". ${optout};\\\",\"\n \n # Work over the list of combinations.  We have to translate each one\n@@ -241,18 +234,36 @@ for combo in ${combinations}; do\n   done\n   optout=`echo ${optout} | sed -e 's/^ //'`\n \n-  # Add any negations of matches.\n-  if [ -n \"${matchnegations}\" ]; then\n-    optout=`echo \";${optout};\" | sed -e 's/ /;/g' ${matchnegations} -e 's/^;//' -e 's/;$//' -e 's/;/ /g'`\n-  fi\n-\n   # Output the line with all appropriate matches.\n-  dirout=\"${dirout}\" optout=\"${optout}\" ./tmpmultilib2 ${matches}\n+  dirout=\"${dirout}\" optout=\"${optout}\" ./tmpmultilib2\n done\n \n # Terminate the list of string.\n echo \"NULL\"\n+echo \"};\"\n+\n+# Output all of the matches now as option and that is the same as that, with\n+# a semicolan trailer.  Include all of the normal options as well.\n+# Note, the format of the matches is reversed compared\n+# to what we want, so switch them around.\n+echo \"\"\n+echo \"static char *multilib_matches_raw[] = {\"\n+for match in ${matches}; do\n+  l=`echo ${match} | sed -e 's/=.*$//' -e 's/?/=/g'`\n+  r=`echo ${match} | sed -e 's/^.*=//' -e 's/?/=/g'`\n+  echo \"\\\"${r} ${l};\\\",\"\n+done\n+for set in ${options}; do\n+  for opt in `echo ${set} | sed -e 's|/| |'g`; do\n+    echo \"\\\"${opt} ${opt};\\\",\"\n+  done\n+done\n+echo \"NULL\"\n+echo \"};\"\n \n+# Output the default options now\n+echo \"\"\n+echo \"static char *multilib_extra = \\\"${extra}\\\";\"\n rm -f tmpmultilib2\n \n exit 0"}]}