{"sha": "6f46d14d4989b2711379807e4565585123c48118", "node_id": "C_kwDOANBUbNoAKDZmNDZkMTRkNDk4OWIyNzExMzc5ODA3ZTQ1NjU1ODUxMjNjNDgxMTg", "commit": {"author": {"name": "Lewis Hyatt", "email": "lhyatt@gmail.com", "date": "2022-11-02T20:04:36Z"}, "committer": {"name": "Lewis Hyatt", "email": "lhyatt@gmail.com", "date": "2022-11-21T22:47:19Z"}, "message": "libcpp: Fix paste error with unknown pragma after macro expansion\n\nIn directives.cc, do_pragma() contains logic to handle a case such as the new\ntestcase pragma-omp-unknown.c, where an unknown pragma was the result of macro\nexpansion (for pragma namespaces that permit expansion). This no longer works\ncorrectly as shown by the testcase, fixed by adding PREV_WHITE to the flags on\nthe second token to prevent an unwanted paste.  Also fixed the memory leak,\nsince the temporary tokens are pushed on their own context, nothing prevents\nfreeing of the buffer that holds them when the context is eventually popped.\n\nlibcpp/ChangeLog:\n\n\t* directives.cc (do_pragma): Fix memory leak in token buffer.  Fix\n\tunwanted paste between two tokens.\n\ngcc/testsuite/ChangeLog:\n\n\t* c-c++-common/gomp/pragma-omp-unknown.c: New test.", "tree": {"sha": "4d9b583c7133a103c323aa9271fa6507ebb0de54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d9b583c7133a103c323aa9271fa6507ebb0de54"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f46d14d4989b2711379807e4565585123c48118", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f46d14d4989b2711379807e4565585123c48118", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f46d14d4989b2711379807e4565585123c48118", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f46d14d4989b2711379807e4565585123c48118/comments", "author": null, "committer": null, "parents": [{"sha": "5c0d171f67d082c353ddc319859111d3b9126c17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c0d171f67d082c353ddc319859111d3b9126c17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c0d171f67d082c353ddc319859111d3b9126c17"}], "stats": {"total": 20, "additions": 15, "deletions": 5}, "files": [{"sha": "04881f786ab84eea9e9a6ce51b63fc4cd65b3fd9", "filename": "gcc/testsuite/c-c++-common/gomp/pragma-omp-unknown.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f46d14d4989b2711379807e4565585123c48118/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpragma-omp-unknown.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f46d14d4989b2711379807e4565585123c48118/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpragma-omp-unknown.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpragma-omp-unknown.c?ref=6f46d14d4989b2711379807e4565585123c48118", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do preprocess } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+#define X UNKNOWN1\n+#pragma omp X\n+/* { dg-final { scan-file pragma-omp-unknown.i \"#pragma omp UNKNOWN1\" } } */\n+\n+#define Y UNKNOWN2\n+_Pragma(\"omp Y\")\n+/* { dg-final { scan-file pragma-omp-unknown.i \"#pragma omp UNKNOWN2\" } } */"}, {"sha": "9dc4363c65aecf8ee8b64c7b670afaeac4a0e79d", "filename": "libcpp/directives.cc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f46d14d4989b2711379807e4565585123c48118/libcpp%2Fdirectives.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f46d14d4989b2711379807e4565585123c48118/libcpp%2Fdirectives.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fdirectives.cc?ref=6f46d14d4989b2711379807e4565585123c48118", "patch": "@@ -1565,15 +1565,15 @@ do_pragma (cpp_reader *pfile)\n \t{\n \t  /* Invalid name comes from macro expansion, _cpp_backup_tokens\n \t     won't allow backing 2 tokens.  */\n-\t  /* ??? The token buffer is leaked.  Perhaps if def_pragma hook\n-\t     reads both tokens, we could perhaps free it, but if it doesn't,\n-\t     we don't know the exact lifespan.  */\n-\t  cpp_token *toks = XNEWVEC (cpp_token, 2);\n+\t  const auto tok_buff = _cpp_get_buff (pfile, 2 * sizeof (cpp_token));\n+\t  const auto toks = (cpp_token *)tok_buff->base;\n \t  toks[0] = ns_token;\n \t  toks[0].flags |= NO_EXPAND;\n \t  toks[1] = *token;\n-\t  toks[1].flags |= NO_EXPAND;\n+\t  toks[1].flags |= NO_EXPAND | PREV_WHITE;\n \t  _cpp_push_token_context (pfile, NULL, toks, 2);\n+\t  /* Arrange to free this buffer when no longer needed.  */\n+\t  pfile->context->buff = tok_buff;\n \t}\n       pfile->cb.def_pragma (pfile, pfile->directive_line);\n     }"}]}