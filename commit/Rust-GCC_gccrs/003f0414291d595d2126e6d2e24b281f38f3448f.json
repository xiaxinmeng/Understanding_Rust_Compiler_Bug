{"sha": "003f0414291d595d2126e6d2e24b281f38f3448f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDAzZjA0MTQyOTFkNTk1ZDIxMjZlNmQyZTI0YjI4MWYzOGYzNDQ4Zg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2021-01-27T09:12:16Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2021-01-27T09:12:54Z"}, "message": "Fortran: Fix ICE due to elemental procedure pointers [PR98472].\n\n2021-01-27  Paul Thomas  <pault@gcc.gnu.org>\n\ngcc/fortran\n\tPR fortran/98472\n\t* trans-array.c (gfc_conv_expr_descriptor): Include elemental\n\tprocedure pointers in the assert under the comment 'elemental\n\tfunction' and eliminate the second, spurious assert.\n\ngcc/testsuite/\n\tPR fortran/98472\n\t* gfortran.dg/elemental_function_5.f90 : New test.", "tree": {"sha": "8b199de6aef2fdd1f57e2e06d18d88382803cbb7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b199de6aef2fdd1f57e2e06d18d88382803cbb7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/003f0414291d595d2126e6d2e24b281f38f3448f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/003f0414291d595d2126e6d2e24b281f38f3448f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/003f0414291d595d2126e6d2e24b281f38f3448f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/003f0414291d595d2126e6d2e24b281f38f3448f/comments", "author": null, "committer": null, "parents": [{"sha": "da5c25f37101cd71f08e31ad581a00840ef75497", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da5c25f37101cd71f08e31ad581a00840ef75497", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da5c25f37101cd71f08e31ad581a00840ef75497"}], "stats": {"total": 50, "additions": 48, "deletions": 2}, "files": [{"sha": "c346183e1299aba8bf7d6ec078e00ba3ee67aae3", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/003f0414291d595d2126e6d2e24b281f38f3448f/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/003f0414291d595d2126e6d2e24b281f38f3448f/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=003f0414291d595d2126e6d2e24b281f38f3448f", "patch": "@@ -7477,9 +7477,9 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n \t\t\t && expr->value.function.esym->attr.elemental)\n \t\t\t|| (expr->value.function.isym != NULL\n \t\t\t    && expr->value.function.isym->elemental)\n+\t\t\t|| (gfc_expr_attr (expr).proc_pointer\n+\t\t\t    && gfc_expr_attr (expr).elemental)\n \t\t\t|| gfc_inline_intrinsic_function_p (expr));\n-\t  else\n-\t    gcc_assert (ss_type == GFC_SS_INTRINSIC);\n \n \t  need_tmp = 1;\n \t  if (expr->ts.type == BT_CHARACTER"}, {"sha": "315ff9162b35782615f65be015fc33d222999211", "filename": "gcc/testsuite/gfortran.dg/elemental_function_5.f90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/003f0414291d595d2126e6d2e24b281f38f3448f/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_function_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/003f0414291d595d2126e6d2e24b281f38f3448f/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_function_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_function_5.f90?ref=003f0414291d595d2126e6d2e24b281f38f3448f", "patch": "@@ -0,0 +1,46 @@\n+! { dg-do compile }\n+!\n+! Test the fix for PR98472.\n+!\n+! Contributed by Rui Coelho  <ruicoelhopedro@hotmail.com>\n+!\n+module a\n+        type, abstract :: base\n+        contains\n+                procedure(elem_func), deferred, nopass :: add\n+        end type base\n+\n+        type, extends(base) :: derived\n+        contains\n+                procedure, nopass :: add => add_derived\n+        end type derived\n+\n+        abstract interface\n+                elemental function elem_func(x, y) result(out)\n+                        integer, intent(in) :: x, y\n+                        integer :: out\n+                end function elem_func\n+        end interface\n+\n+contains\n+        elemental function add_derived(x, y) result(out)\n+                integer, intent(in) :: x, y\n+                integer :: out\n+                out = x + y\n+        end function add_derived\n+end module a\n+\n+program main\n+        use a\n+        call foo\n+contains\n+        subroutine foo\n+               integer, dimension(:), allocatable :: vec\n+               class(base), allocatable :: instance\n+               allocate(derived :: instance)\n+               allocate(vec, source=instance%add([1, 2], [1, 2])) ! ICE here\n+               if (any (vec .ne. [2, 4])) stop 1\n+        end\n+end program main\n+\n+"}]}