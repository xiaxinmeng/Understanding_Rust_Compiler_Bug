{"sha": "b87971f33ef5446f674fb9f80c6ff16e82145ee1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjg3OTcxZjMzZWY1NDQ2ZjY3NGZiOWY4MGM2ZmYxNmU4MjE0NWVlMQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-10-28T13:31:51Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-10-28T13:31:51Z"}, "message": "[multiple changes]\n\n2009-10-28  Robert Dewar  <dewar@adacore.com>\n\n\t* a-ztexio.adb, a-ztexio.ads, a-witeio.ads, a-witeio.adb,\n\ta-textio.ads, a-textio.adb: Reorganize (moving specs from private part\n\tto body).\n\t(Initialize_Standard_Files): New procedure.\n\t* a-tienau.adb: Minor change to make EOF directly visible\n\t* a-tirsfi.ads, a-wrstfi.adb, a-wrstfi.ads, a-zrstfi.adb,\n\ta-zrstfi.ads, a-tirsfi.adb: New unit, initial version.\n\t* gnat_rm.texi: Add documentation for\n\tAda.[Wide_[Wide_]]Text_IO.Reset_Standard_Files.\n\t* Makefile.rtl: Add entries for\n\tAda.[Wide_[Wide_]]Text_IO.Reset_Standard_Files\n\n2009-10-28  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_ch9.ads: Minor reformatting\n\t* sem_ch3.adb: Minor reformatting\n\t* sem_aggr.adb: Minor reformatting.\n\t* sem_attr.adb: Minor reformatting\n\t* tbuild.adb, tbuild.ads, par-ch4.adb, exp_ch4.adb (Tbuild.New_Op_Node):\n\tNew subprogram.\n\tMinor code reorganization/factoring.\n\nFrom-SVN: r153656", "tree": {"sha": "148343d7b85f6796a501d41f02588446c25abfd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/148343d7b85f6796a501d41f02588446c25abfd8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b87971f33ef5446f674fb9f80c6ff16e82145ee1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b87971f33ef5446f674fb9f80c6ff16e82145ee1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b87971f33ef5446f674fb9f80c6ff16e82145ee1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b87971f33ef5446f674fb9f80c6ff16e82145ee1/comments", "author": null, "committer": null, "parents": [{"sha": "1307c758a3aad3df3e7af66f6ec68b4cb599b054", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1307c758a3aad3df3e7af66f6ec68b4cb599b054", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1307c758a3aad3df3e7af66f6ec68b4cb599b054"}], "stats": {"total": 1275, "additions": 787, "deletions": 488}, "files": [{"sha": "b7e74489054e8ec5fbc62cdc76cac060ce5f5147", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b87971f33ef5446f674fb9f80c6ff16e82145ee1", "patch": "@@ -1,3 +1,27 @@\n+2009-10-28  Robert Dewar  <dewar@adacore.com>\n+\n+\t* a-ztexio.adb, a-ztexio.ads, a-witeio.ads, a-witeio.adb,\n+\ta-textio.ads, a-textio.adb: Reorganize (moving specs from private part\n+\tto body).\n+\t(Initialize_Standard_Files): New procedure.\n+\t* a-tienau.adb: Minor change to make EOF directly visible\n+\t* a-tirsfi.ads, a-wrstfi.adb, a-wrstfi.ads, a-zrstfi.adb,\n+\ta-zrstfi.ads, a-tirsfi.adb: New unit, initial version.\n+\t* gnat_rm.texi: Add documentation for\n+\tAda.[Wide_[Wide_]]Text_IO.Reset_Standard_Files.\n+\t* Makefile.rtl: Add entries for\n+\tAda.[Wide_[Wide_]]Text_IO.Reset_Standard_Files\n+\n+2009-10-28  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_ch9.ads: Minor reformatting\n+\t* sem_ch3.adb: Minor reformatting\n+\t* sem_aggr.adb: Minor reformatting.\n+\t* sem_attr.adb: Minor reformatting\n+\t* tbuild.adb, tbuild.ads, par-ch4.adb, exp_ch4.adb (Tbuild.New_Op_Node):\n+\tNew subprogram.\n+\tMinor code reorganization/factoring.\n+\n 2009-10-27  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (purpose_member_field): New static function."}, {"sha": "4f26f1569b5efe155cff32ef84ee290448d245cc", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=b87971f33ef5446f674fb9f80c6ff16e82145ee1", "patch": "@@ -258,13 +258,15 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-timoau$(objext) \\\n   a-timoio$(objext) \\\n   a-tiocst$(objext) \\\n+  a-tirsfi$(objext) \\\n   a-titest$(objext) \\\n   a-tiunio$(objext) \\\n   a-unccon$(objext) \\\n   a-uncdea$(objext) \\\n   a-wichun$(objext) \\\n   a-widcha$(objext) \\\n   a-witeio$(objext) \\\n+  a-wrstfi$(objext) \\\n   a-wtcoau$(objext) \\\n   a-wtcoio$(objext) \\\n   a-wtcstr$(objext) \\\n@@ -286,6 +288,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-wwunio$(objext) \\\n   a-zchara$(objext) \\\n   a-zchuni$(objext) \\\n+  a-zrstfi$(objext) \\\n   a-ztcoau$(objext) \\\n   a-ztcoio$(objext) \\\n   a-ztcstr$(objext) \\"}, {"sha": "417efb5f54f73bcaa0e4ef33ec66954345cd0a37", "filename": "gcc/ada/a-textio.adb", "status": "modified", "additions": 97, "deletions": 68, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Fa-textio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Fa-textio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-textio.adb?ref=b87971f33ef5446f674fb9f80c6ff16e82145ee1", "patch": "@@ -57,15 +57,30 @@ package body Ada.Text_IO is\n \n    WC_Encoding : Character;\n    pragma Import (C, WC_Encoding, \"__gl_wc_encoding\");\n+   --  Default wide character encoding\n+\n+   Err_Name : aliased String := \"*stderr\" & ASCII.NUL;\n+   In_Name  : aliased String := \"*stdin\" & ASCII.NUL;\n+   Out_Name : aliased String := \"*stdout\" & ASCII.NUL;\n+   --  Names of standard files\n+   --\n+   --  Use \"preallocated\" strings to avoid calling \"new\" during the elaboration\n+   --  of the run time. This is needed in the tasking case to avoid calling\n+   --  Task_Lock too early. A filename is expected to end with a null character\n+   --  in the runtime, here the null characters are added just to have a\n+   --  correct filename length.\n+   --\n+   --  Note: the names for these files are bogus, and probably it would be\n+   --  better for these files to have no names, but the ACVC tests insist!\n+   --  We use names that are bound to fail in open etc.\n+\n+   Null_Str : aliased constant String := \"\";\n+   --  Used as form string for standard files\n \n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n \n-   function Getc_Immed (File : File_Type) return int;\n-   --  This routine is identical to Getc, except that the read is done in\n-   --  Get_Immediate mode (i.e. without waiting for a line return).\n-\n    function Get_Upper_Half_Char\n      (C    : Character;\n       File : File_Type) return Character;\n@@ -82,18 +97,48 @@ package body Ada.Text_IO is\n    --  This routine is identical to Get_Upper_Half_Char, except that the reads\n    --  are done in Get_Immediate mode (i.e. without waiting for a line return).\n \n+   function Getc (File : File_Type) return int;\n+   --  Gets next character from file, which has already been checked for being\n+   --  in read status, and returns the character read if no error occurs. The\n+   --  result is EOF if the end of file was read.\n+\n+   function Getc_Immed (File : File_Type) return int;\n+   --  This routine is identical to Getc, except that the read is done in\n+   --  Get_Immediate mode (i.e. without waiting for a line return).\n+\n    function Has_Upper_Half_Character (Item : String) return Boolean;\n    --  Returns True if any of the characters is in the range 16#80#-16#FF#\n \n+   function Nextc (File : File_Type) return int;\n+   --  Returns next character from file without skipping past it (i.e. it is a\n+   --  combination of Getc followed by an Ungetc).\n+\n    procedure Put_Encoded (File : File_Type; Char : Character);\n    --  Called to output a character Char to the given File, when the encoding\n    --  method for the file is other than brackets, and Char is upper half.\n \n+   procedure Putc (ch : int; File : File_Type);\n+   --  Outputs the given character to the file, which has already been checked\n+   --  for being in output status. Device_Error is raised if the character\n+   --  cannot be written.\n+\n    procedure Set_WCEM (File : in out File_Type);\n    --  Called by Open and Create to set the wide character encoding method for\n    --  the file, processing a WCEM form parameter if one is present. File is\n    --  IN OUT because it may be closed in case of an error.\n \n+   procedure Terminate_Line (File : File_Type);\n+   --  If the file is in Write_File or Append_File mode, and the current line\n+   --  is not terminated, then a line terminator is written using New_Line.\n+   --  Note that there is no Terminate_Page routine, because the page mark at\n+   --  the end of the file is implied if necessary.\n+\n+   procedure Ungetc (ch : int; File : File_Type);\n+   --  Pushes back character into stream, using ungetc. The caller has checked\n+   --  that the file is in read status. Device_Error is raised if the character\n+   --  cannot be pushed back. An attempt to push back and end of file character\n+   --  (EOF) is ignored.\n+\n    -------------------\n    -- AFCB_Allocate --\n    -------------------\n@@ -392,15 +437,6 @@ package body Ada.Text_IO is\n       return End_Of_Page (Current_In);\n    end End_Of_Page;\n \n-   --------------\n-   -- EOF_Char --\n-   --------------\n-\n-   function EOF_Char return Integer is\n-   begin\n-      return EOF;\n-   end EOF_Char;\n-\n    -----------\n    -- Flush --\n    -----------\n@@ -965,6 +1001,52 @@ package body Ada.Text_IO is\n       return False;\n    end Has_Upper_Half_Character;\n \n+   -------------------------------\n+   -- Initialize_Standard_Files --\n+   -------------------------------\n+\n+   procedure Initialize_Standard_Files is\n+   begin\n+      Standard_Err.Stream            := stderr;\n+      Standard_Err.Name              := Err_Name'Access;\n+      Standard_Err.Form              := Null_Str'Unrestricted_Access;\n+      Standard_Err.Mode              := FCB.Out_File;\n+      Standard_Err.Is_Regular_File   := is_regular_file (fileno (stderr)) /= 0;\n+      Standard_Err.Is_Temporary_File := False;\n+      Standard_Err.Is_System_File    := True;\n+      Standard_Err.Is_Text_File      := True;\n+      Standard_Err.Access_Method     := 'T';\n+      Standard_Err.Self              := Standard_Err;\n+      Standard_Err.WC_Method         := Default_WCEM;\n+\n+      Standard_In.Stream             := stdin;\n+      Standard_In.Name               := In_Name'Access;\n+      Standard_In.Form               := Null_Str'Unrestricted_Access;\n+      Standard_In.Mode               := FCB.In_File;\n+      Standard_In.Is_Regular_File    := is_regular_file (fileno (stdin)) /= 0;\n+      Standard_In.Is_Temporary_File  := False;\n+      Standard_In.Is_System_File     := True;\n+      Standard_In.Is_Text_File       := True;\n+      Standard_In.Access_Method      := 'T';\n+      Standard_In.Self               := Standard_In;\n+      Standard_In.WC_Method          := Default_WCEM;\n+\n+      Standard_Out.Stream            := stdout;\n+      Standard_Out.Name              := Out_Name'Access;\n+      Standard_Out.Form              := Null_Str'Unrestricted_Access;\n+      Standard_Out.Mode              := FCB.Out_File;\n+      Standard_Out.Is_Regular_File   := is_regular_file (fileno (stdout)) /= 0;\n+      Standard_Out.Is_Temporary_File := False;\n+      Standard_Out.Is_System_File    := True;\n+      Standard_Out.Is_Text_File      := True;\n+      Standard_Out.Access_Method     := 'T';\n+      Standard_Out.Self              := Standard_Out;\n+      Standard_Out.WC_Method         := Default_WCEM;\n+\n+      FIO.Make_Unbuffered (AP (Standard_Out));\n+      FIO.Make_Unbuffered (AP (Standard_Err));\n+   end Initialize_Standard_Files;\n+\n    -------------\n    -- Is_Open --\n    -------------\n@@ -2198,72 +2280,19 @@ package body Ada.Text_IO is\n       end if;\n    end Write;\n \n-   --  Use \"preallocated\" strings to avoid calling \"new\" during the\n-   --  elaboration of the run time. This is needed in the tasking case to\n-   --  avoid calling Task_Lock too early. A filename is expected to end with a\n-   --  null character in the runtime, here the null characters are added just\n-   --  to have a correct filename length.\n-\n-   Err_Name : aliased String := \"*stderr\" & ASCII.NUL;\n-   In_Name  : aliased String := \"*stdin\" & ASCII.NUL;\n-   Out_Name : aliased String := \"*stdout\" & ASCII.NUL;\n-\n begin\n-   -------------------------------\n-   -- Initialize Standard Files --\n-   -------------------------------\n+   --  Initialize Standard Files\n \n    for J in WC_Encoding_Method loop\n       if WC_Encoding = WC_Encoding_Letters (J) then\n          Default_WCEM := J;\n       end if;\n    end loop;\n \n-   --  Note: the names in these files are bogus, and probably it would be\n-   --  better for these files to have no names, but the ACVC test insist!\n-   --  We use names that are bound to fail in open etc.\n-\n-   Standard_Err.Stream            := stderr;\n-   Standard_Err.Name              := Err_Name'Access;\n-   Standard_Err.Form              := Null_Str'Unrestricted_Access;\n-   Standard_Err.Mode              := FCB.Out_File;\n-   Standard_Err.Is_Regular_File   := is_regular_file (fileno (stderr)) /= 0;\n-   Standard_Err.Is_Temporary_File := False;\n-   Standard_Err.Is_System_File    := True;\n-   Standard_Err.Is_Text_File      := True;\n-   Standard_Err.Access_Method     := 'T';\n-   Standard_Err.Self              := Standard_Err;\n-   Standard_Err.WC_Method         := Default_WCEM;\n-\n-   Standard_In.Stream             := stdin;\n-   Standard_In.Name               := In_Name'Access;\n-   Standard_In.Form               := Null_Str'Unrestricted_Access;\n-   Standard_In.Mode               := FCB.In_File;\n-   Standard_In.Is_Regular_File    := is_regular_file (fileno (stdin)) /= 0;\n-   Standard_In.Is_Temporary_File  := False;\n-   Standard_In.Is_System_File     := True;\n-   Standard_In.Is_Text_File       := True;\n-   Standard_In.Access_Method      := 'T';\n-   Standard_In.Self               := Standard_In;\n-   Standard_In.WC_Method          := Default_WCEM;\n-\n-   Standard_Out.Stream            := stdout;\n-   Standard_Out.Name              := Out_Name'Access;\n-   Standard_Out.Form              := Null_Str'Unrestricted_Access;\n-   Standard_Out.Mode              := FCB.Out_File;\n-   Standard_Out.Is_Regular_File   := is_regular_file (fileno (stdout)) /= 0;\n-   Standard_Out.Is_Temporary_File := False;\n-   Standard_Out.Is_System_File    := True;\n-   Standard_Out.Is_Text_File      := True;\n-   Standard_Out.Access_Method     := 'T';\n-   Standard_Out.Self              := Standard_Out;\n-   Standard_Out.WC_Method         := Default_WCEM;\n+   Initialize_Standard_Files;\n \n    FIO.Chain_File (AP (Standard_In));\n    FIO.Chain_File (AP (Standard_Out));\n    FIO.Chain_File (AP (Standard_Err));\n \n-   FIO.Make_Unbuffered (AP (Standard_Out));\n-   FIO.Make_Unbuffered (AP (Standard_Err));\n-\n end Ada.Text_IO;"}, {"sha": "44fe496db18437818436f050ce1499f996ba2f1b", "filename": "gcc/ada/a-textio.ads", "status": "modified", "additions": 5, "deletions": 45, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Fa-textio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Fa-textio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-textio.ads?ref=b87971f33ef5446f674fb9f80c6ff16e82145ee1", "patch": "@@ -41,6 +41,7 @@\n \n with Ada.IO_Exceptions;\n with Ada.Streams;\n+\n with System;\n with System.File_Control_Block;\n with System.WCh_Con;\n@@ -443,9 +444,6 @@ private\n    -- The Standard Files --\n    ------------------------\n \n-   Null_Str : aliased constant String := \"\";\n-   --  Used as name and form of standard files\n-\n    Standard_In_AFCB  : aliased Text_AFCB;\n    Standard_Out_AFCB : aliased Text_AFCB;\n    Standard_Err_AFCB : aliased Text_AFCB;\n@@ -460,47 +458,9 @@ private\n    Current_Err  : aliased File_Type := Standard_Err;\n    --  Current files\n \n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   --  These subprograms are in the private part of the spec so that they can\n-   --  be shared by the routines in the body of Ada.Text_IO.Wide_Text_IO.\n-\n-   --  Note: we use Integer in these declarations instead of the more accurate\n-   --  Interfaces.C_Streams.int, because we do not want to drag in the spec of\n-   --  this interfaces package with the spec of Ada.Text_IO, and we know that\n-   --  in fact these types are identical\n-\n-   function EOF_Char return Integer;\n-   --  Returns the system-specific character indicating the end of a text file.\n-   --  This is exported for use by child packages such as Enumeration_Aux to\n-   --  eliminate their needing to depend directly on Interfaces.C_Streams.\n-\n-   function Getc (File : File_Type) return Integer;\n-   --  Gets next character from file, which has already been checked for\n-   --  being in read status, and returns the character read if no error\n-   --  occurs. The result is EOF if the end of file was read.\n-\n-   function Nextc (File : File_Type) return Integer;\n-   --  Returns next character from file without skipping past it (i.e. it\n-   --  is a combination of Getc followed by an Ungetc).\n-\n-   procedure Putc (ch : Integer; File : File_Type);\n-   --  Outputs the given character to the file, which has already been\n-   --  checked for being in output status. Device_Error is raised if the\n-   --  character cannot be written.\n-\n-   procedure Terminate_Line (File : File_Type);\n-   --  If the file is in Write_File or Append_File mode, and the current\n-   --  line is not terminated, then a line terminator is written using\n-   --  New_Line. Note that there is no Terminate_Page routine, because\n-   --  the page mark at the end of the file is implied if necessary.\n-\n-   procedure Ungetc (ch : Integer; File : File_Type);\n-   --  Pushes back character into stream, using ungetc. The caller has\n-   --  checked that the file is in read status. Device_Error is raised\n-   --  if the character cannot be pushed back. An attempt to push back\n-   --  and end of file character (EOF) is ignored.\n+   procedure Initialize_Standard_Files;\n+   --  Initializes the file control blocks for the standard files. Called from\n+   --  the elaboration routine for this package, and from Reset_Standard_Files\n+   --  in package Ada.Text_IO.Reset_Standard_Files.\n \n end Ada.Text_IO;"}, {"sha": "e04a34281e285942b30a1891c6d55a32166f99e2", "filename": "gcc/ada/a-tienau.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Fa-tienau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Fa-tienau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tienau.adb?ref=b87971f33ef5446f674fb9f80c6ff16e82145ee1", "patch": "@@ -32,6 +32,8 @@\n with Ada.Text_IO.Generic_Aux; use Ada.Text_IO.Generic_Aux;\n with Ada.Characters.Handling; use Ada.Characters.Handling;\n \n+with Interfaces.C_Streams;    use Interfaces.C_Streams;\n+\n --  Note: this package does not yet deal properly with wide characters ???\n \n package body Ada.Text_IO.Enumeration_Aux is\n@@ -98,7 +100,7 @@ package body Ada.Text_IO.Enumeration_Aux is\n             Store_Char (File, Character'Pos (To_Upper (C)), Buf, Buflen);\n \n             ch := Getc (File);\n-            exit when ch = EOF_Char;\n+            exit when ch = EOF;\n             C := Character'Val (ch);\n \n             exit when not Is_Letter (C)"}, {"sha": "791c066bab3b48b17d4d12919d76b4dbe1dc349b", "filename": "gcc/ada/a-tirsfi.adb", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Fa-tirsfi.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Fa-tirsfi.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tirsfi.adb?ref=b87971f33ef5446f674fb9f80c6ff16e82145ee1", "patch": "@@ -0,0 +1,39 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--     A D A . T E X T _ I O . R E S E T _ S T A N D A R D _ F I L E S      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2009, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--------------------------------------\n+-- Ada.Text_IO.Reset_Standard_Files --\n+--------------------------------------\n+\n+procedure Ada.Text_IO.Reset_Standard_Files is\n+begin\n+   Ada.Text_IO.Initialize_Standard_Files;\n+end Ada.Text_IO.Reset_Standard_Files;"}, {"sha": "b3d4ab0afb99b7c4af53213505756ea6145cd710", "filename": "gcc/ada/a-tirsfi.ads", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Fa-tirsfi.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Fa-tirsfi.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tirsfi.ads?ref=b87971f33ef5446f674fb9f80c6ff16e82145ee1", "patch": "@@ -0,0 +1,40 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--     A D A . T E X T _ I O . R E S E T _ S T A N D A R D _ F I L E S      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2009, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides a reset routine that resets the standard files used\n+--  by Text_IO. This is useful in systems such as VxWorks where Ada.Text_IO is\n+--  elaborated at the program start, but a system restart may alter the status\n+--  of these files, resulting in incorrect operation of Text_IO (in particular\n+--  if the standard input file is changed to be interactive, then Get_Line may\n+--  hang looking for an extra character after the end of the line.\n+\n+procedure Ada.Text_IO.Reset_Standard_Files;\n+--  Reset standard Text_IO files as described above"}, {"sha": "efd5021849dec25e05b58a042027ee308418682e", "filename": "gcc/ada/a-witeio.adb", "status": "modified", "additions": 91, "deletions": 62, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Fa-witeio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Fa-witeio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-witeio.adb?ref=b87971f33ef5446f674fb9f80c6ff16e82145ee1", "patch": "@@ -57,26 +57,62 @@ package body Ada.Wide_Text_IO is\n \n    WC_Encoding : Character;\n    pragma Import (C, WC_Encoding, \"__gl_wc_encoding\");\n+   --  Default wide character encoding\n+\n+   Err_Name : aliased String := \"*stderr\" & ASCII.NUL;\n+   In_Name  : aliased String := \"*stdin\" & ASCII.NUL;\n+   Out_Name : aliased String := \"*stdout\" & ASCII.NUL;\n+   --  Names of standard files\n+   --\n+   --  Use \"preallocated\" strings to avoid calling \"new\" during the elaboration\n+   --  of the run time. This is needed in the tasking case to avoid calling\n+   --  Task_Lock too early. A filename is expected to end with a null character\n+   --  in the runtime, here the null characters are added just to have a\n+   --  correct filename length.\n+   --\n+   --  Note: the names for these files are bogus, and probably it would be\n+   --  better for these files to have no names, but the ACVC tests insist!\n+   --  We use names that are bound to fail in open etc.\n+\n+   Null_Str : aliased constant String := \"\";\n+   --  Used as form string for standard files\n \n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n \n-   function Getc_Immed (File : File_Type) return int;\n-   --  This routine is identical to Getc, except that the read is done in\n-   --  Get_Immediate mode (i.e. without waiting for a line return).\n-\n    function Get_Wide_Char_Immed\n      (C    : Character;\n       File : File_Type) return Wide_Character;\n    --  This routine is identical to Get_Wide_Char, except that the reads are\n    --  done in Get_Immediate mode (i.e. without waiting for a line return).\n \n+   function Getc_Immed (File : File_Type) return int;\n+   --  This routine is identical to Getc, except that the read is done in\n+   --  Get_Immediate mode (i.e. without waiting for a line return).\n+\n+   procedure Putc (ch : int; File : File_Type);\n+   --  Outputs the given character to the file, which has already been checked\n+   --  for being in output status. Device_Error is raised if the character\n+   --  cannot be written.\n+\n    procedure Set_WCEM (File : in out File_Type);\n    --  Called by Open and Create to set the wide character encoding method for\n    --  the file, processing a WCEM form parameter if one is present. File is\n    --  IN OUT because it may be closed in case of an error.\n \n+   procedure Terminate_Line (File : File_Type);\n+   --  If the file is in Write_File or Append_File mode, and the current line\n+   --  is not terminated, then a line terminator is written using New_Line.\n+   --  Note that there is no Terminate_Page routine, because the page mark at\n+   --  the end of the file is implied if necessary.\n+\n+   procedure Ungetc (ch : int; File : File_Type);\n+   --  Pushes back character into stream, using ungetc. The caller has checked\n+   --  that the file is in read status. Device_Error is raised if the character\n+   --  cannot be pushed back. An attempt to push back and end of file character\n+   --  (EOF) is ignored.\n+\n    -------------------\n    -- AFCB_Allocate --\n    -------------------\n@@ -843,6 +879,52 @@ package body Ada.Wide_Text_IO is\n       return ch;\n    end Getc_Immed;\n \n+   -------------------------------\n+   -- Initialize_Standard_Files --\n+   -------------------------------\n+\n+   procedure Initialize_Standard_Files is\n+   begin\n+      Standard_Err.Stream            := stderr;\n+      Standard_Err.Name              := Err_Name'Access;\n+      Standard_Err.Form              := Null_Str'Unrestricted_Access;\n+      Standard_Err.Mode              := FCB.Out_File;\n+      Standard_Err.Is_Regular_File   := is_regular_file (fileno (stderr)) /= 0;\n+      Standard_Err.Is_Temporary_File := False;\n+      Standard_Err.Is_System_File    := True;\n+      Standard_Err.Is_Text_File      := True;\n+      Standard_Err.Access_Method     := 'T';\n+      Standard_Err.Self              := Standard_Err;\n+      Standard_Err.WC_Method         := Default_WCEM;\n+\n+      Standard_In.Stream             := stdin;\n+      Standard_In.Name               := In_Name'Access;\n+      Standard_In.Form               := Null_Str'Unrestricted_Access;\n+      Standard_In.Mode               := FCB.In_File;\n+      Standard_In.Is_Regular_File    := is_regular_file (fileno (stdin)) /= 0;\n+      Standard_In.Is_Temporary_File  := False;\n+      Standard_In.Is_System_File     := True;\n+      Standard_In.Is_Text_File       := True;\n+      Standard_In.Access_Method      := 'T';\n+      Standard_In.Self               := Standard_In;\n+      Standard_In.WC_Method          := Default_WCEM;\n+\n+      Standard_Out.Stream            := stdout;\n+      Standard_Out.Name              := Out_Name'Access;\n+      Standard_Out.Form              := Null_Str'Unrestricted_Access;\n+      Standard_Out.Mode              := FCB.Out_File;\n+      Standard_Out.Is_Regular_File   := is_regular_file (fileno (stdout)) /= 0;\n+      Standard_Out.Is_Temporary_File := False;\n+      Standard_Out.Is_System_File    := True;\n+      Standard_Out.Is_Text_File      := True;\n+      Standard_Out.Access_Method     := 'T';\n+      Standard_Out.Self              := Standard_Out;\n+      Standard_Out.WC_Method         := Default_WCEM;\n+\n+      FIO.Make_Unbuffered (AP (Standard_Out));\n+      FIO.Make_Unbuffered (AP (Standard_Err));\n+   end Initialize_Standard_Files;\n+\n    -------------\n    -- Is_Open --\n    -------------\n@@ -856,9 +938,9 @@ package body Ada.Wide_Text_IO is\n    -- Line --\n    ----------\n \n-   --  Note: we assume that it is impossible in practice for the line\n-   --  to exceed the value of Count'Last, i.e. no check is required for\n-   --  overflow raising layout error.\n+   --  Note: we assume that it is impossible in practice for the line to exceed\n+   --  the value of Count'Last, i.e. no check is required for overflow raising\n+   --  layout error.\n \n    function Line (File : File_Type) return Positive_Count is\n    begin\n@@ -1840,72 +1922,19 @@ package body Ada.Wide_Text_IO is\n       set_text_mode (fileno (File.Stream));\n    end Write;\n \n-   --  Use \"preallocated\" strings to avoid calling \"new\" during the\n-   --  elaboration of the run time. This is needed in the tasking case to\n-   --  avoid calling Task_Lock too early. A filename is expected to end with\n-   --  a null character in the runtime, here the null characters are added\n-   --  just to have a correct filename length.\n-\n-   Err_Name : aliased String := \"*stderr\" & ASCII.NUL;\n-   In_Name  : aliased String := \"*stdin\" & ASCII.NUL;\n-   Out_Name : aliased String := \"*stdout\" & ASCII.NUL;\n-\n begin\n-   -------------------------------\n-   -- Initialize Standard Files --\n-   -------------------------------\n+   --  Initialize Standard Files\n \n    for J in WC_Encoding_Method loop\n       if WC_Encoding = WC_Encoding_Letters (J) then\n          Default_WCEM := J;\n       end if;\n    end loop;\n \n-   --  Note: the names in these files are bogus, and probably it would be\n-   --  better for these files to have no names, but the ACVC test insist!\n-   --  We use names that are bound to fail in open etc.\n-\n-   Standard_Err.Stream            := stderr;\n-   Standard_Err.Name              := Err_Name'Access;\n-   Standard_Err.Form              := Null_Str'Unrestricted_Access;\n-   Standard_Err.Mode              := FCB.Out_File;\n-   Standard_Err.Is_Regular_File   := is_regular_file (fileno (stderr)) /= 0;\n-   Standard_Err.Is_Temporary_File := False;\n-   Standard_Err.Is_System_File    := True;\n-   Standard_Err.Is_Text_File      := True;\n-   Standard_Err.Access_Method     := 'T';\n-   Standard_Err.Self              := Standard_Err;\n-   Standard_Err.WC_Method         := Default_WCEM;\n-\n-   Standard_In.Stream             := stdin;\n-   Standard_In.Name               := In_Name'Access;\n-   Standard_In.Form               := Null_Str'Unrestricted_Access;\n-   Standard_In.Mode               := FCB.In_File;\n-   Standard_In.Is_Regular_File    := is_regular_file (fileno (stdin)) /= 0;\n-   Standard_In.Is_Temporary_File  := False;\n-   Standard_In.Is_System_File     := True;\n-   Standard_In.Is_Text_File       := True;\n-   Standard_In.Access_Method      := 'T';\n-   Standard_In.Self               := Standard_In;\n-   Standard_In.WC_Method          := Default_WCEM;\n-\n-   Standard_Out.Stream            := stdout;\n-   Standard_Out.Name              := Out_Name'Access;\n-   Standard_Out.Form              := Null_Str'Unrestricted_Access;\n-   Standard_Out.Mode              := FCB.Out_File;\n-   Standard_Out.Is_Regular_File   := is_regular_file (fileno (stdout)) /= 0;\n-   Standard_Out.Is_Temporary_File := False;\n-   Standard_Out.Is_System_File    := True;\n-   Standard_Out.Is_Text_File      := True;\n-   Standard_Out.Access_Method     := 'T';\n-   Standard_Out.Self              := Standard_Out;\n-   Standard_Out.WC_Method         := Default_WCEM;\n+   Initialize_Standard_Files;\n \n    FIO.Chain_File (AP (Standard_In));\n    FIO.Chain_File (AP (Standard_Out));\n    FIO.Chain_File (AP (Standard_Err));\n \n-   FIO.Make_Unbuffered (AP (Standard_Out));\n-   FIO.Make_Unbuffered (AP (Standard_Err));\n-\n end Ada.Wide_Text_IO;"}, {"sha": "2cf02b69b05b82a2f641218a08b50616be2ff69d", "filename": "gcc/ada/a-witeio.ads", "status": "modified", "additions": 17, "deletions": 36, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Fa-witeio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Fa-witeio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-witeio.ads?ref=b87971f33ef5446f674fb9f80c6ff16e82145ee1", "patch": "@@ -42,6 +42,9 @@\n \n with Ada.IO_Exceptions;\n with Ada.Streams;\n+\n+with Interfaces.C_Streams;\n+\n with System;\n with System.File_Control_Block;\n with System.WCh_Con;\n@@ -441,9 +444,6 @@ private\n    -- The Standard Files --\n    ------------------------\n \n-   Null_Str : aliased constant String := \"\";\n-   --  Used as name and form of standard files\n-\n    Standard_Err_AFCB : aliased Wide_Text_AFCB;\n    Standard_In_AFCB  : aliased Wide_Text_AFCB;\n    Standard_Out_AFCB : aliased Wide_Text_AFCB;\n@@ -458,26 +458,24 @@ private\n    Current_Err  : aliased File_Type := Standard_Err;\n    --  Current files\n \n+   procedure Initialize_Standard_Files;\n+   --  Initializes the file control blocks for the standard files. Called from\n+   --  the elaboration routine for this package, and from Reset_Standard_Files\n+   --  in package Ada.Wide_Text_IO.Reset_Standard_Files.\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n \n    --  These subprograms are in the private part of the spec so that they can\n-   --  be shared by the routines in the body of Ada.Text_IO.Wide_Text_IO.\n-\n-   --  Note: we use Integer in these declarations instead of the more accurate\n-   --  Interfaces.C_Streams.int, because we do not want to drag in the spec of\n-   --  this interfaces package with the spec of Ada.Text_IO, and we know that\n-   --  in fact these types are identical\n+   --  be shared by the children of Ada.Wide_Text_IO.\n \n-   function Getc (File : File_Type) return Integer;\n-   --  Gets next character from file, which has already been checked for\n-   --  being in read status, and returns the character read if no error\n-   --  occurs. The result is EOF if the end of file was read.\n+   function Getc (File : File_Type) return Interfaces.C_Streams.int;\n+   --  Gets next character from file, which has already been checked for being\n+   --  in read status, and returns the character read if no error occurs. The\n+   --  result is EOF if the end of file was read.\n \n-   procedure Get_Character\n-     (File : File_Type;\n-      Item : out Character);\n+   procedure Get_Character (File : File_Type; Item : out Character);\n    --  This is essentially a copy of the normal Get routine from Text_IO. It\n    --  obtains a single character from the input file File, and places it in\n    --  Item. This character may be the leading character of a Wide_Character\n@@ -491,25 +489,8 @@ private\n    --  read and is passed in C. The wide character value is returned as the\n    --  result, and the file pointer is bumped past the character.\n \n-   function Nextc (File : File_Type) return Integer;\n-   --  Returns next character from file without skipping past it (i.e. it\n-   --  is a combination of Getc followed by an Ungetc).\n-\n-   procedure Putc (ch : Integer; File : File_Type);\n-   --  Outputs the given character to the file, which has already been\n-   --  checked for being in output status. Device_Error is raised if the\n-   --  character cannot be written.\n-\n-   procedure Terminate_Line (File : File_Type);\n-   --  If the file is in Write_File or Append_File mode, and the current\n-   --  line is not terminated, then a line terminator is written using\n-   --  New_Line. Note that there is no Terminate_Page routine, because\n-   --  the page mark at the end of the file is implied if necessary.\n-\n-   procedure Ungetc (ch : Integer; File : File_Type);\n-   --  Pushes back character into stream, using ungetc. The caller has\n-   --  checked that the file is in read status. Device_Error is raised\n-   --  if the character cannot be pushed back. An attempt to push back\n-   --  and end of file character (EOF) is ignored.\n+   function Nextc (File : File_Type) return Interfaces.C_Streams.int;\n+   --  Returns next character from file without skipping past it (i.e. it is a\n+   --  combination of Getc followed by an Ungetc).\n \n end Ada.Wide_Text_IO;"}, {"sha": "6b3f656b670f1f01a0261cc669d97d4bbe631cd3", "filename": "gcc/ada/a-wrstfi.adb", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Fa-wrstfi.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Fa-wrstfi.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wrstfi.adb?ref=b87971f33ef5446f674fb9f80c6ff16e82145ee1", "patch": "@@ -0,0 +1,39 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                  ADA.WIDE_TEXT_IO.RESET_STANDARD_FILES                   --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2009, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+-------------------------------------------\n+-- Ada.Wide_Text_IO.Reset_Standard_Files --\n+-------------------------------------------\n+\n+procedure Ada.Wide_Text_IO.Reset_Standard_Files is\n+begin\n+   Ada.Wide_Text_IO.Initialize_Standard_Files;\n+end Ada.Wide_Text_IO.Reset_Standard_Files;"}, {"sha": "5d6548eadc50467930ac7eab2fbe83611bc46840", "filename": "gcc/ada/a-wrstfi.ads", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Fa-wrstfi.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Fa-wrstfi.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wrstfi.ads?ref=b87971f33ef5446f674fb9f80c6ff16e82145ee1", "patch": "@@ -0,0 +1,41 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                  ADA.WIDE_TEXT_IO.RESET_STANDARD_FILES                   --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2009, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides a reset routine that resets the standard files used\n+--  by Ada.Wide_Text_IO. This is useful in systems such as VxWorks where\n+--  Ada.Wide_Text_IO is elaborated at the program start, but a system restart\n+--  may alter the status of these files, resulting in incorrect operation of\n+--  Wide_Text_IO (in particular if the standard input file is changed to be\n+--  interactive, then Get_Line may hang looking for an extra character after\n+--  the end of the line.\n+\n+procedure Ada.Wide_Text_IO.Reset_Standard_Files;\n+--  Reset standard Wide_Text_IO files as described above"}, {"sha": "e0a7f64b662a89e5260adb093eb0989c9904395c", "filename": "gcc/ada/a-zrstfi.adb", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Fa-zrstfi.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Fa-zrstfi.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-zrstfi.adb?ref=b87971f33ef5446f674fb9f80c6ff16e82145ee1", "patch": "@@ -0,0 +1,39 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                ADA.WIDE_WIDE_TEXT_IO.RESET_STANDARD_FILES                --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2009, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+------------------------------------------------\n+-- Ada.Wide_Wide_Text_IO.Reset_Standard_Files --\n+------------------------------------------------\n+\n+procedure Ada.Wide_Wide_Text_IO.Reset_Standard_Files is\n+begin\n+   Ada.Wide_Wide_Text_IO.Initialize_Standard_Files;\n+end Ada.Wide_Wide_Text_IO.Reset_Standard_Files;"}, {"sha": "80f2b1f2cdf724dc33509f10b54c908b4a63313c", "filename": "gcc/ada/a-zrstfi.ads", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Fa-zrstfi.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Fa-zrstfi.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-zrstfi.ads?ref=b87971f33ef5446f674fb9f80c6ff16e82145ee1", "patch": "@@ -0,0 +1,41 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                ADA.WIDE_WIDE_TEXT_IO.RESET_STANDARD_FILES                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2009, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides a reset routine that resets the standard files used\n+--  by Ada.Wide_Wide_Text_IO. This is useful in systems such as VxWorks where\n+--  Ada.Wide_Wide_Text_IO is elaborated at the program start, but a system\n+--  restart may alter the status of these files, resulting in incorrect\n+--  operation of Wide_Wide_Text_IO (in particular if the standard input file\n+--  is changed to be interactive, then Get_Line may hang looking for an extra\n+--  character after the end of the line.\n+\n+procedure Ada.Wide_Wide_Text_IO.Reset_Standard_Files;\n+--  Reset standard Wide_Wide_Text_IO files as described above"}, {"sha": "8be8a91d9e2e0d4f4e68c68173c7f79b65983ccb", "filename": "gcc/ada/a-ztexio.adb", "status": "modified", "additions": 88, "deletions": 59, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Fa-ztexio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Fa-ztexio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ztexio.adb?ref=b87971f33ef5446f674fb9f80c6ff16e82145ee1", "patch": "@@ -57,26 +57,62 @@ package body Ada.Wide_Wide_Text_IO is\n \n    WC_Encoding : Character;\n    pragma Import (C, WC_Encoding, \"__gl_wc_encoding\");\n+   --  Default wide character encoding\n+\n+   Err_Name : aliased String := \"*stderr\" & ASCII.NUL;\n+   In_Name  : aliased String := \"*stdin\" & ASCII.NUL;\n+   Out_Name : aliased String := \"*stdout\" & ASCII.NUL;\n+   --  Names of standard files\n+   --\n+   --  Use \"preallocated\" strings to avoid calling \"new\" during the elaboration\n+   --  of the run time. This is needed in the tasking case to avoid calling\n+   --  Task_Lock too early. A filename is expected to end with a null character\n+   --  in the runtime, here the null characters are added just to have a\n+   --  correct filename length.\n+   --\n+   --  Note: the names for these files are bogus, and probably it would be\n+   --  better for these files to have no names, but the ACVC tests insist!\n+   --  We use names that are bound to fail in open etc.\n+\n+   Null_Str : aliased constant String := \"\";\n+   --  Used as form string for standard files\n \n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n \n-   function Getc_Immed (File : File_Type) return int;\n-   --  This routine is identical to Getc, except that the read is done in\n-   --  Get_Immediate mode (i.e. without waiting for a line return).\n-\n    function Get_Wide_Wide_Char_Immed\n      (C    : Character;\n       File : File_Type) return Wide_Wide_Character;\n    --  This routine is identical to Get_Wide_Wide_Char, except that the reads\n    --  are done in Get_Immediate mode (i.e. without waiting for a line return).\n \n+   function Getc_Immed (File : File_Type) return int;\n+   --  This routine is identical to Getc, except that the read is done in\n+   --  Get_Immediate mode (i.e. without waiting for a line return).\n+\n+   procedure Putc (ch : int; File : File_Type);\n+   --  Outputs the given character to the file, which has already been checked\n+   --  for being in output status. Device_Error is raised if the character\n+   --  cannot be written.\n+\n    procedure Set_WCEM (File : in out File_Type);\n    --  Called by Open and Create to set the wide character encoding method for\n    --  the file, processing a WCEM form parameter if one is present. File is\n    --  IN OUT because it may be closed in case of an error.\n \n+   procedure Terminate_Line (File : File_Type);\n+   --  If the file is in Write_File or Append_File mode, and the current line\n+   --  is not terminated, then a line terminator is written using New_Line.\n+   --  Note that there is no Terminate_Page routine, because the page mark at\n+   --  the end of the file is implied if necessary.\n+\n+   procedure Ungetc (ch : int; File : File_Type);\n+   --  Pushes back character into stream, using ungetc. The caller has checked\n+   --  that the file is in read status. Device_Error is raised if the character\n+   --  cannot be pushed back. An attempt to push back and end of file character\n+   --  (EOF) is ignored.\n+\n    -------------------\n    -- AFCB_Allocate --\n    -------------------\n@@ -843,6 +879,52 @@ package body Ada.Wide_Wide_Text_IO is\n       return ch;\n    end Getc_Immed;\n \n+   -------------------------------\n+   -- Initialize_Standard_Files --\n+   -------------------------------\n+\n+   procedure Initialize_Standard_Files is\n+   begin\n+      Standard_Err.Stream            := stderr;\n+      Standard_Err.Name              := Err_Name'Access;\n+      Standard_Err.Form              := Null_Str'Unrestricted_Access;\n+      Standard_Err.Mode              := FCB.Out_File;\n+      Standard_Err.Is_Regular_File   := is_regular_file (fileno (stderr)) /= 0;\n+      Standard_Err.Is_Temporary_File := False;\n+      Standard_Err.Is_System_File    := True;\n+      Standard_Err.Is_Text_File      := True;\n+      Standard_Err.Access_Method     := 'T';\n+      Standard_Err.Self              := Standard_Err;\n+      Standard_Err.WC_Method         := Default_WCEM;\n+\n+      Standard_In.Stream             := stdin;\n+      Standard_In.Name               := In_Name'Access;\n+      Standard_In.Form               := Null_Str'Unrestricted_Access;\n+      Standard_In.Mode               := FCB.In_File;\n+      Standard_In.Is_Regular_File    := is_regular_file (fileno (stdin)) /= 0;\n+      Standard_In.Is_Temporary_File  := False;\n+      Standard_In.Is_System_File     := True;\n+      Standard_In.Is_Text_File       := True;\n+      Standard_In.Access_Method      := 'T';\n+      Standard_In.Self               := Standard_In;\n+      Standard_In.WC_Method          := Default_WCEM;\n+\n+      Standard_Out.Stream            := stdout;\n+      Standard_Out.Name              := Out_Name'Access;\n+      Standard_Out.Form              := Null_Str'Unrestricted_Access;\n+      Standard_Out.Mode              := FCB.Out_File;\n+      Standard_Out.Is_Regular_File   := is_regular_file (fileno (stdout)) /= 0;\n+      Standard_Out.Is_Temporary_File := False;\n+      Standard_Out.Is_System_File    := True;\n+      Standard_Out.Is_Text_File      := True;\n+      Standard_Out.Access_Method     := 'T';\n+      Standard_Out.Self              := Standard_Out;\n+      Standard_Out.WC_Method         := Default_WCEM;\n+\n+      FIO.Make_Unbuffered (AP (Standard_Out));\n+      FIO.Make_Unbuffered (AP (Standard_Err));\n+   end Initialize_Standard_Files;\n+\n    -------------\n    -- Is_Open --\n    -------------\n@@ -1840,72 +1922,19 @@ package body Ada.Wide_Wide_Text_IO is\n       set_text_mode (fileno (File.Stream));\n    end Write;\n \n-   --  Use \"preallocated\" strings to avoid calling \"new\" during the\n-   --  elaboration of the run time. This is needed in the tasking case to\n-   --  avoid calling Task_Lock too early. A filename is expected to end with\n-   --  a null character in the runtime, here the null characters are added\n-   --  just to have a correct filename length.\n-\n-   Err_Name : aliased String := \"*stderr\" & ASCII.NUL;\n-   In_Name  : aliased String := \"*stdin\" & ASCII.NUL;\n-   Out_Name : aliased String := \"*stdout\" & ASCII.NUL;\n-\n begin\n-   -------------------------------\n-   -- Initialize Standard Files --\n-   -------------------------------\n+   --  Initialize Standard Files\n \n    for J in WC_Encoding_Method loop\n       if WC_Encoding = WC_Encoding_Letters (J) then\n          Default_WCEM := J;\n       end if;\n    end loop;\n \n-   --  Note: the names in these files are bogus, and probably it would be\n-   --  better for these files to have no names, but the ACVC test insist!\n-   --  We use names that are bound to fail in open etc.\n-\n-   Standard_Err.Stream            := stderr;\n-   Standard_Err.Name              := Err_Name'Access;\n-   Standard_Err.Form              := Null_Str'Unrestricted_Access;\n-   Standard_Err.Mode              := FCB.Out_File;\n-   Standard_Err.Is_Regular_File   := is_regular_file (fileno (stderr)) /= 0;\n-   Standard_Err.Is_Temporary_File := False;\n-   Standard_Err.Is_System_File    := True;\n-   Standard_Err.Is_Text_File      := True;\n-   Standard_Err.Access_Method     := 'T';\n-   Standard_Err.Self              := Standard_Err;\n-   Standard_Err.WC_Method         := Default_WCEM;\n-\n-   Standard_In.Stream             := stdin;\n-   Standard_In.Name               := In_Name'Access;\n-   Standard_In.Form               := Null_Str'Unrestricted_Access;\n-   Standard_In.Mode               := FCB.In_File;\n-   Standard_In.Is_Regular_File    := is_regular_file (fileno (stdin)) /= 0;\n-   Standard_In.Is_Temporary_File  := False;\n-   Standard_In.Is_System_File     := True;\n-   Standard_In.Is_Text_File       := True;\n-   Standard_In.Access_Method      := 'T';\n-   Standard_In.Self               := Standard_In;\n-   Standard_In.WC_Method          := Default_WCEM;\n-\n-   Standard_Out.Stream            := stdout;\n-   Standard_Out.Name              := Out_Name'Access;\n-   Standard_Out.Form              := Null_Str'Unrestricted_Access;\n-   Standard_Out.Mode              := FCB.Out_File;\n-   Standard_Out.Is_Regular_File   := is_regular_file (fileno (stdout)) /= 0;\n-   Standard_Out.Is_Temporary_File := False;\n-   Standard_Out.Is_System_File    := True;\n-   Standard_Out.Is_Text_File      := True;\n-   Standard_Out.Access_Method     := 'T';\n-   Standard_Out.Self              := Standard_Out;\n-   Standard_Out.WC_Method         := Default_WCEM;\n+   Initialize_Standard_Files;\n \n    FIO.Chain_File (AP (Standard_In));\n    FIO.Chain_File (AP (Standard_Out));\n    FIO.Chain_File (AP (Standard_Err));\n \n-   FIO.Make_Unbuffered (AP (Standard_Out));\n-   FIO.Make_Unbuffered (AP (Standard_Err));\n-\n end Ada.Wide_Wide_Text_IO;"}, {"sha": "6c75acd193691e0e9d0bd1a642eb9960ad524aff", "filename": "gcc/ada/a-ztexio.ads", "status": "modified", "additions": 24, "deletions": 44, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Fa-ztexio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Fa-ztexio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ztexio.ads?ref=b87971f33ef5446f674fb9f80c6ff16e82145ee1", "patch": "@@ -42,6 +42,9 @@\n \n with Ada.IO_Exceptions;\n with Ada.Streams;\n+\n+with Interfaces.C_Streams;\n+\n with System;\n with System.File_Control_Block;\n with System.WCh_Con;\n@@ -357,13 +360,13 @@ private\n    PM : constant := Character'Pos (ASCII.FF);\n    --  Used as page mark, except at end of file where it is implied\n \n-   -------------------------------------\n+   ------------------------------------------\n    -- Wide_Wide_Text_IO File Control Block --\n-   -------------------------------------\n+   ------------------------------------------\n \n    Default_WCEM : WCh_Con.WC_Encoding_Method := WCh_Con.WCEM_UTF8;\n-   --  This gets modified during initialization (see body) using\n-   --  the default value established in the call to Set_Globals.\n+   --  This gets modified during initialization (see body) using the default\n+   --  value established in the call to Set_Globals.\n \n    package FCB renames System.File_Control_Block;\n \n@@ -443,9 +446,6 @@ private\n    -- The Standard Files --\n    ------------------------\n \n-   Null_Str : aliased constant String := \"\";\n-   --  Used as name and form of standard files\n-\n    Standard_Err_AFCB : aliased Wide_Wide_Text_AFCB;\n    Standard_In_AFCB  : aliased Wide_Wide_Text_AFCB;\n    Standard_Out_AFCB : aliased Wide_Wide_Text_AFCB;\n@@ -460,31 +460,28 @@ private\n    Current_Err  : aliased File_Type := Standard_Err;\n    --  Current files\n \n+   procedure Initialize_Standard_Files;\n+   --  Initializes the file control blocks for the standard files. Called from\n+   --  the elaboration routine for this package, and from Reset_Standard_Files\n+   --  in package Ada.Wide_Wide_Text_IO.Reset_Standard_Files.\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n \n    --  These subprograms are in the private part of the spec so that they can\n-   --  be shared by the routines in the body of Ada.Text_IO.Wide_Wide_Text_IO.\n-\n-   --  Note: we use Integer in these declarations instead of the more accurate\n-   --  Interfaces.C_Streams.int, because we do not want to drag in the spec of\n-   --  this interfaces package with the spec of Ada.Text_IO, and we know that\n-   --  in fact these types are identical\n+   --  be shared by the children of Ada.Text_IO.Wide_Wide_Text_IO.\n \n-   function Getc (File : File_Type) return Integer;\n-   --  Gets next character from file, which has already been checked for\n-   --  being in read status, and returns the character read if no error\n-   --  occurs. The result is EOF if the end of file was read.\n+   function Getc (File : File_Type) return Interfaces.C_Streams.int;\n+   --  Gets next character from file, which has already been checked for being\n+   --  in read status, and returns the character read if no error occurs. The\n+   --  result is EOF if the end of file was read.\n \n-   procedure Get_Character\n-     (File : File_Type;\n-      Item : out Character);\n-   --  This is essentially a copy of the normal Get routine from Text_IO. It\n+   procedure Get_Character (File : File_Type; Item : out Character);\n+   --  This is essentially copy of Wide_Wide_Text_IO.Get. It obtains a single\n    --  obtains a single character from the input file File, and places it in\n-   --  Item. This character may be the leading character of a\n-   --  Wide_Wide_Character sequence, but that is up to the caller to deal\n-   --  with.\n+   --  Item. This result may be the leading character of a Wide_Wide_Character\n+   --  sequence, but that is up to the caller to deal with.\n \n    function Get_Wide_Wide_Char\n      (C    : Character;\n@@ -494,25 +491,8 @@ private\n    --  read and is passed in C. The wide character value is returned as the\n    --  result, and the file pointer is bumped past the character.\n \n-   function Nextc (File : File_Type) return Integer;\n-   --  Returns next character from file without skipping past it (i.e. it\n-   --  is a combination of Getc followed by an Ungetc).\n-\n-   procedure Putc (ch : Integer; File : File_Type);\n-   --  Outputs the given character to the file, which has already been\n-   --  checked for being in output status. Device_Error is raised if the\n-   --  character cannot be written.\n-\n-   procedure Terminate_Line (File : File_Type);\n-   --  If the file is in Write_File or Append_File mode, and the current\n-   --  line is not terminated, then a line terminator is written using\n-   --  New_Line. Note that there is no Terminate_Page routine, because\n-   --  the page mark at the end of the file is implied if necessary.\n-\n-   procedure Ungetc (ch : Integer; File : File_Type);\n-   --  Pushes back character into stream, using ungetc. The caller has\n-   --  checked that the file is in read status. Device_Error is raised\n-   --  if the character cannot be pushed back. An attempt to push back\n-   --  and end of file character (EOF) is ignored.\n+   function Nextc (File : File_Type) return Interfaces.C_Streams.int;\n+   --  Returns next character from file without skipping past it (i.e. it is a\n+   --  combination of Getc followed by an Ungetc).\n \n end Ada.Wide_Wide_Text_IO;"}, {"sha": "c98e9823964a444e54de3a46d2ccb5b30e42e7c0", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=b87971f33ef5446f674fb9f80c6ff16e82145ee1", "patch": "@@ -8065,20 +8065,9 @@ package body Exp_Ch4 is\n                    Subtype_Mark => New_Reference_To (Standard_Integer, Loc),\n                    Expression   => Relocate_Node (Left_Opnd (Operand)));\n \n-               case Nkind (Operand) is\n-                  when N_Op_Add =>\n-                     Opnd := Make_Op_Add (Loc, L, R);\n-                  when N_Op_Divide =>\n-                     Opnd := Make_Op_Divide (Loc, L, R);\n-                  when N_Op_Expon =>\n-                     Opnd := Make_Op_Expon (Loc, L, R);\n-                  when N_Op_Multiply =>\n-                     Opnd := Make_Op_Multiply (Loc, L, R);\n-                  when N_Op_Subtract =>\n-                     Opnd := Make_Op_Subtract (Loc, L, R);\n-                  when others =>\n-                     raise Program_Error;\n-               end case;\n+               Opnd := New_Op_Node (Nkind (Operand), Loc);\n+               Set_Left_Opnd (Opnd, L);\n+               Set_Right_Opnd (Opnd, R);\n \n                Rewrite (N,\n                  Make_Type_Conversion (Loc,"}, {"sha": "61279d4eac5a0defcd3a6ada2905dd06f84c067f", "filename": "gcc/ada/exp_ch9.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Fexp_ch9.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Fexp_ch9.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.ads?ref=b87971f33ef5446f674fb9f80c6ff16e82145ee1", "patch": "@@ -173,8 +173,8 @@ package Exp_Ch9 is\n    --  meaning is to get the Task_Id for the currently executing task.\n \n    function Convert_Concurrent\n-     (N    : Node_Id;\n-      Typ  : Entity_Id) return Node_Id;\n+     (N   : Node_Id;\n+      Typ : Entity_Id) return Node_Id;\n    --  N is an expression of type Typ. If the type is not a concurrent type\n    --  then it is returned unchanged. If it is a task or protected reference,\n    --  Convert_Concurrent creates an unchecked conversion node from this"}, {"sha": "4b906fe91e954aaff47fbcc0fa4913cbf62a10ec", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=b87971f33ef5446f674fb9f80c6ff16e82145ee1", "patch": "@@ -307,10 +307,13 @@ The GNAT Library\n * Ada.Strings.Wide_Unbounded.Wide_Text_IO (a-swuwti.ads)::\n * Ada.Strings.Wide_Wide_Unbounded.Wide_Wide_Text_IO (a-szuzti.ads)::\n * Ada.Text_IO.C_Streams (a-tiocst.ads)::\n+* Ada.Text_IO.Reset_Standard_Files (a-tirsfi.ads)::\n * Ada.Wide_Characters.Unicode (a-wichun.ads)::\n * Ada.Wide_Text_IO.C_Streams (a-wtcstr.ads)::\n+* Ada.Wide_Text_IO.Reset_Standard_Files (a-wrstfi.ads)::\n * Ada.Wide_Wide_Characters.Unicode (a-zchuni.ads)::\n * Ada.Wide_Wide_Text_IO.C_Streams (a-ztcstr.ads)::\n+* Ada.Wide_Wide_Text_IO.Reset_Standard_Files (a-zrstfi.ads)::\n * GNAT.Altivec (g-altive.ads)::\n * GNAT.Altivec.Conversions (g-altcon.ads)::\n * GNAT.Altivec.Vector_Operations (g-alveop.ads)::\n@@ -13496,10 +13499,13 @@ of GNAT, and will generate a warning message.\n * Ada.Strings.Wide_Unbounded.Wide_Text_IO (a-swuwti.ads)::\n * Ada.Strings.Wide_Wide_Unbounded.Wide_Wide_Text_IO (a-szuzti.ads)::\n * Ada.Text_IO.C_Streams (a-tiocst.ads)::\n+* Ada.Text_IO.Reset_Standard_Files (a-tirsfi.ads)::\n * Ada.Wide_Characters.Unicode (a-wichun.ads)::\n * Ada.Wide_Text_IO.C_Streams (a-wtcstr.ads)::\n+* Ada.Wide_Text_IO.Reset_Standard_Files (a-wrstfi.ads)::\n * Ada.Wide_Wide_Characters.Unicode (a-zchuni.ads)::\n * Ada.Wide_Wide_Text_IO.C_Streams (a-ztcstr.ads)::\n+* Ada.Wide_Wide_Text_IO.Reset_Standard_Files (a-zrstfi.ads)::\n * GNAT.Altivec (g-altive.ads)::\n * GNAT.Altivec.Conversions (g-altcon.ads)::\n * GNAT.Altivec.Vector_Operations (g-alveop.ads)::\n@@ -13819,6 +13825,18 @@ C streams and @code{Text_IO}.  The stream identifier can be\n extracted from a file opened on the Ada side, and an Ada file\n can be constructed from a stream opened on the C side.\n \n+@node Ada.Text_IO.Reset_Standard_Files (a-tirsfi.ads)\n+@section @code{Ada.Text_IO.Reset_Standard_Files} (@file{a-tirsfi.ads})\n+@cindex @code{Ada.Text_IO.Reset_Standard_Files} (@file{a-tirsfi.ads})\n+@cindex @code{Text_IO} resetting standard files\n+\n+@noindent\n+This procedure is used to reset the status of the standard files used\n+by Ada.Text_IO.  This is useful in a situation (such as a restart in an\n+embedded application) where the status of the files may change during\n+execution (for example a standard input file may be redefined to be\n+interactive).\n+\n @node Ada.Wide_Characters.Unicode (a-wichun.ads)\n @section @code{Ada.Wide_Characters.Unicode} (@file{a-wichun.ads})\n @cindex @code{Ada.Wide_Characters.Unicode} (@file{a-wichun.ads})\n@@ -13839,6 +13857,18 @@ C streams and @code{Wide_Text_IO}.  The stream identifier can be\n extracted from a file opened on the Ada side, and an Ada file\n can be constructed from a stream opened on the C side.\n \n+@node Ada.Wide_Text_IO.Reset_Standard_Files (a-wrstfi.ads)\n+@section @code{Ada.Wide_Text_IO.Reset_Standard_Files} (@file{a-wrstfi.ads})\n+@cindex @code{Ada.Wide_Text_IO.Reset_Standard_Files} (@file{a-wrstfi.ads})\n+@cindex @code{Wide_Text_IO} resetting standard files\n+\n+@noindent\n+This procedure is used to reset the status of the standard files used\n+by Ada.Wide_Text_IO.  This is useful in a situation (such as a restart in an\n+embedded application) where the status of the files may change during\n+execution (for example a standard input file may be redefined to be\n+interactive).\n+\n @node Ada.Wide_Wide_Characters.Unicode (a-zchuni.ads)\n @section @code{Ada.Wide_Wide_Characters.Unicode} (@file{a-zchuni.ads})\n @cindex @code{Ada.Wide_Wide_Characters.Unicode} (@file{a-zchuni.ads})\n@@ -13859,6 +13889,18 @@ C streams and @code{Wide_Wide_Text_IO}.  The stream identifier can be\n extracted from a file opened on the Ada side, and an Ada file\n can be constructed from a stream opened on the C side.\n \n+@node Ada.Wide_Wide_Text_IO.Reset_Standard_Files (a-zrstfi.ads)\n+@section @code{Ada.Wide_Wide_Text_IO.Reset_Standard_Files} (@file{a-zrstfi.ads})\n+@cindex @code{Ada.Wide_Wide_Text_IO.Reset_Standard_Files} (@file{a-zrstfi.ads})\n+@cindex @code{Wide_Wide_Text_IO} resetting standard files\n+\n+@noindent\n+This procedure is used to reset the status of the standard files used\n+by Ada.Wide_Wide_Text_IO. This is useful in a situation (such as a\n+restart in an embedded application) where the status of the files may\n+change during execution (for example a standard input file may be\n+redefined to be interactive).\n+\n @node GNAT.Altivec (g-altive.ads)\n @section @code{GNAT.Altivec} (@file{g-altive.ads})\n @cindex @code{GNAT.Altivec} (@file{g-altive.ads})"}, {"sha": "2bb9d25fcc12add6ed1152387fec4635be0e3a60", "filename": "gcc/ada/par-ch4.adb", "status": "modified", "additions": 12, "deletions": 72, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Fpar-ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Fpar-ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch4.adb?ref=b87971f33ef5446f674fb9f80c6ff16e82145ee1", "patch": "@@ -89,9 +89,6 @@ package body Ch4 is\n    --  prefix. The current token is known to be an apostrophe and the\n    --  following token is known to be RANGE.\n \n-   procedure Set_Op_Name (Node : Node_Id);\n-   --  Procedure to set name field (Chars) in operator node\n-\n    -------------------------\n    -- Bad_Range_Attribute --\n    -------------------------\n@@ -102,51 +99,6 @@ package body Ch4 is\n       Resync_Expression;\n    end Bad_Range_Attribute;\n \n-   ------------------\n-   -- Set_Op_Name --\n-   ------------------\n-\n-   procedure Set_Op_Name (Node : Node_Id) is\n-      type Name_Of_Type is array (N_Op) of Name_Id;\n-      Name_Of : constant Name_Of_Type := Name_Of_Type'(\n-         N_Op_And                    => Name_Op_And,\n-         N_Op_Or                     => Name_Op_Or,\n-         N_Op_Xor                    => Name_Op_Xor,\n-         N_Op_Eq                     => Name_Op_Eq,\n-         N_Op_Ne                     => Name_Op_Ne,\n-         N_Op_Lt                     => Name_Op_Lt,\n-         N_Op_Le                     => Name_Op_Le,\n-         N_Op_Gt                     => Name_Op_Gt,\n-         N_Op_Ge                     => Name_Op_Ge,\n-         N_Op_Add                    => Name_Op_Add,\n-         N_Op_Subtract               => Name_Op_Subtract,\n-         N_Op_Concat                 => Name_Op_Concat,\n-         N_Op_Multiply               => Name_Op_Multiply,\n-         N_Op_Divide                 => Name_Op_Divide,\n-         N_Op_Mod                    => Name_Op_Mod,\n-         N_Op_Rem                    => Name_Op_Rem,\n-         N_Op_Expon                  => Name_Op_Expon,\n-         N_Op_Plus                   => Name_Op_Add,\n-         N_Op_Minus                  => Name_Op_Subtract,\n-         N_Op_Abs                    => Name_Op_Abs,\n-         N_Op_Not                    => Name_Op_Not,\n-\n-         --  We don't really need these shift operators, since they never\n-         --  appear as operators in the source, but the path of least\n-         --  resistance is to put them in (the aggregate must be complete)\n-\n-         N_Op_Rotate_Left            => Name_Rotate_Left,\n-         N_Op_Rotate_Right           => Name_Rotate_Right,\n-         N_Op_Shift_Left             => Name_Shift_Left,\n-         N_Op_Shift_Right            => Name_Shift_Right,\n-         N_Op_Shift_Right_Arithmetic => Name_Shift_Right_Arithmetic);\n-\n-   begin\n-      if Nkind (Node) in N_Op then\n-         Set_Chars (Node, Name_Of (Nkind (Node)));\n-      end if;\n-   end Set_Op_Name;\n-\n    --------------------------\n    -- 4.1  Name (also 6.4) --\n    --------------------------\n@@ -1600,10 +1552,9 @@ package body Ch4 is\n             end if;\n \n             Node2 := Node1;\n-            Node1 := New_Node (Logical_Op, Op_Location);\n+            Node1 := New_Op_Node (Logical_Op, Op_Location);\n             Set_Left_Opnd (Node1, Node2);\n             Set_Right_Opnd (Node1, P_Relation);\n-            Set_Op_Name (Node1);\n             exit when Token not in Token_Class_Logop;\n          end loop;\n \n@@ -1704,10 +1655,9 @@ package body Ch4 is\n             end if;\n \n             Node2 := Node1;\n-            Node1 := New_Node (Logical_Op, Op_Location);\n+            Node1 := New_Op_Node (Logical_Op, Op_Location);\n             Set_Left_Opnd (Node1, Node2);\n             Set_Right_Opnd (Node1, P_Relation);\n-            Set_Op_Name (Node1);\n             exit when Token not in Token_Class_Logop;\n          end loop;\n \n@@ -1768,9 +1718,8 @@ package body Ch4 is\n          --  P_Relational_Operator also parses the IN and NOT IN operations.\n \n          Optok := Token_Ptr;\n-         Node2 := New_Node (P_Relational_Operator, Optok);\n+         Node2 := New_Op_Node (P_Relational_Operator, Optok);\n          Set_Left_Opnd (Node2, Node1);\n-         Set_Op_Name (Node2);\n \n          --  Case of IN or NOT IN\n \n@@ -1881,18 +1830,17 @@ package body Ch4 is\n                   Style.Check_Exponentiation_Operator;\n                end if;\n \n-               Node2 := New_Node (N_Op_Expon, Token_Ptr);\n+               Node2 := New_Op_Node (N_Op_Expon, Token_Ptr);\n                Scan; -- past **\n                Set_Left_Opnd (Node2, Node1);\n                Set_Right_Opnd (Node2, P_Primary);\n-               Set_Op_Name (Node2);\n                Node1 := Node2;\n             end if;\n \n             loop\n                exit when Token not in Token_Class_Mulop;\n                Tokptr := Token_Ptr;\n-               Node2 := New_Node (P_Multiplying_Operator, Tokptr);\n+               Node2 := New_Op_Node (P_Multiplying_Operator, Tokptr);\n \n                if Style_Check then\n                   Style.Check_Binary_Operator;\n@@ -1901,14 +1849,13 @@ package body Ch4 is\n                Scan; -- past operator\n                Set_Left_Opnd (Node2, Node1);\n                Set_Right_Opnd (Node2, P_Factor);\n-               Set_Op_Name (Node2);\n                Node1 := Node2;\n             end loop;\n \n             loop\n                exit when Token not in Token_Class_Binary_Addop;\n                Tokptr := Token_Ptr;\n-               Node2 := New_Node (P_Binary_Adding_Operator, Tokptr);\n+               Node2 := New_Op_Node (P_Binary_Adding_Operator, Tokptr);\n \n                if Style_Check then\n                   Style.Check_Binary_Operator;\n@@ -1917,7 +1864,6 @@ package body Ch4 is\n                Scan; -- past operator\n                Set_Left_Opnd (Node2, Node1);\n                Set_Right_Opnd (Node2, P_Term);\n-               Set_Op_Name (Node2);\n                Node1 := Node2;\n             end loop;\n \n@@ -1931,15 +1877,14 @@ package body Ch4 is\n \n          if Token in Token_Class_Unary_Addop then\n             Tokptr := Token_Ptr;\n-            Node1 := New_Node (P_Unary_Adding_Operator, Tokptr);\n+            Node1 := New_Op_Node (P_Unary_Adding_Operator, Tokptr);\n \n             if Style_Check then\n                Style.Check_Unary_Plus_Or_Minus;\n             end if;\n \n             Scan; -- past operator\n             Set_Right_Opnd (Node1, P_Term);\n-            Set_Op_Name (Node1);\n          else\n             Node1 := P_Term;\n          end if;\n@@ -1981,12 +1926,11 @@ package body Ch4 is\n             loop\n                exit when Token not in Token_Class_Binary_Addop;\n                Tokptr := Token_Ptr;\n-               Node2 := New_Node (P_Binary_Adding_Operator, Tokptr);\n+               Node2 := New_Op_Node (P_Binary_Adding_Operator, Tokptr);\n                Scan; -- past operator\n                Set_Left_Opnd (Node2, Node1);\n                Node1 := P_Term;\n                Set_Right_Opnd (Node2, Node1);\n-               Set_Op_Name (Node2);\n \n                --  Check if we're still concatenating string literals\n \n@@ -2214,11 +2158,10 @@ package body Ch4 is\n       loop\n          exit when Token not in Token_Class_Mulop;\n          Tokptr := Token_Ptr;\n-         Node2 := New_Node (P_Multiplying_Operator, Tokptr);\n+         Node2 := New_Op_Node (P_Multiplying_Operator, Tokptr);\n          Scan; -- past operator\n          Set_Left_Opnd (Node2, Node1);\n          Set_Right_Opnd (Node2, P_Factor);\n-         Set_Op_Name (Node2);\n          Node1 := Node2;\n       end loop;\n \n@@ -2239,38 +2182,35 @@ package body Ch4 is\n \n    begin\n       if Token = Tok_Abs then\n-         Node1 := New_Node (N_Op_Abs, Token_Ptr);\n+         Node1 := New_Op_Node (N_Op_Abs, Token_Ptr);\n \n          if Style_Check then\n             Style.Check_Abs_Not;\n          end if;\n \n          Scan; -- past ABS\n          Set_Right_Opnd (Node1, P_Primary);\n-         Set_Op_Name (Node1);\n          return Node1;\n \n       elsif Token = Tok_Not then\n-         Node1 := New_Node (N_Op_Not, Token_Ptr);\n+         Node1 := New_Op_Node (N_Op_Not, Token_Ptr);\n \n          if Style_Check then\n             Style.Check_Abs_Not;\n          end if;\n \n          Scan; -- past NOT\n          Set_Right_Opnd (Node1, P_Primary);\n-         Set_Op_Name (Node1);\n          return Node1;\n \n       else\n          Node1 := P_Primary;\n \n          if Token = Tok_Double_Asterisk then\n-            Node2 := New_Node (N_Op_Expon, Token_Ptr);\n+            Node2 := New_Op_Node (N_Op_Expon, Token_Ptr);\n             Scan; -- past **\n             Set_Left_Opnd (Node2, Node1);\n             Set_Right_Opnd (Node2, P_Primary);\n-            Set_Op_Name (Node2);\n             return Node2;\n          else\n             return Node1;"}, {"sha": "ad01bd18117ef21832eae26d87b99be01a734ea6", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 69, "deletions": 72, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=b87971f33ef5446f674fb9f80c6ff16e82145ee1", "patch": "@@ -509,9 +509,8 @@ package body Sem_Aggr is\n    ------------------------\n \n    function Array_Aggr_Subtype\n-     (N    : Node_Id;\n-      Typ  : Entity_Id)\n-      return Entity_Id\n+     (N   : Node_Id;\n+      Typ : Entity_Id) return Entity_Id\n    is\n       Aggr_Dimension : constant Pos := Number_Dimensions (Typ);\n       --  Number of aggregate index dimensions\n@@ -618,16 +617,16 @@ package body Sem_Aggr is\n       --  Array_Aggr_Subtype variables\n \n       Itype : Entity_Id;\n-      --  the final itype of the overall aggregate\n+      --  The final itype of the overall aggregate\n \n       Index_Constraints : constant List_Id := New_List;\n       --  The list of index constraints of the aggregate itype\n \n    --  Start of processing for Array_Aggr_Subtype\n \n    begin\n-      --  Make sure that the list of index constraints is properly attached\n-      --  to the tree, and then collect the aggregate bounds.\n+      --  Make sure that the list of index constraints is properly attached to\n+      --  the tree, and then collect the aggregate bounds.\n \n       Set_Parent (Index_Constraints, N);\n       Collect_Aggr_Bounds (N, 1);\n@@ -672,13 +671,13 @@ package body Sem_Aggr is\n \n       Itype := Create_Itype (E_Array_Subtype, N);\n \n-      Set_First_Rep_Item         (Itype, First_Rep_Item         (Typ));\n-      Set_Convention             (Itype, Convention             (Typ));\n-      Set_Depends_On_Private     (Itype, Has_Private_Component  (Typ));\n-      Set_Etype                  (Itype, Base_Type              (Typ));\n-      Set_Has_Alignment_Clause   (Itype, Has_Alignment_Clause   (Typ));\n-      Set_Is_Aliased             (Itype, Is_Aliased             (Typ));\n-      Set_Depends_On_Private     (Itype, Depends_On_Private     (Typ));\n+      Set_First_Rep_Item         (Itype, First_Rep_Item        (Typ));\n+      Set_Convention             (Itype, Convention            (Typ));\n+      Set_Depends_On_Private     (Itype, Has_Private_Component (Typ));\n+      Set_Etype                  (Itype, Base_Type             (Typ));\n+      Set_Has_Alignment_Clause   (Itype, Has_Alignment_Clause  (Typ));\n+      Set_Is_Aliased             (Itype, Is_Aliased            (Typ));\n+      Set_Depends_On_Private     (Itype, Depends_On_Private    (Typ));\n \n       Copy_Suppress_Status (Index_Check,  Typ, Itype);\n       Copy_Suppress_Status (Length_Check, Typ, Itype);\n@@ -688,22 +687,23 @@ package body Sem_Aggr is\n       Set_Is_Internal    (Itype, True);\n \n       --  A simple optimization: purely positional aggregates of static\n-      --  components should be passed to gigi unexpanded whenever possible,\n-      --  and regardless of the staticness of the bounds themselves. Subse-\n-      --  quent checks in exp_aggr verify that type is not packed, etc.\n+      --  components should be passed to gigi unexpanded whenever possible, and\n+      --  regardless of the staticness of the bounds themselves. Subsequent\n+      --  checks in exp_aggr verify that type is not packed, etc.\n \n       Set_Size_Known_At_Compile_Time (Itype,\n          Is_Fully_Positional\n            and then Comes_From_Source (N)\n            and then Size_Known_At_Compile_Time (Component_Type (Typ)));\n \n-      --  We always need a freeze node for a packed array subtype, so that\n-      --  we can build the Packed_Array_Type corresponding to the subtype.\n-      --  If expansion is disabled, the packed array subtype is not built,\n-      --  and we must not generate a freeze node for the type, or else it\n-      --  will appear incomplete to gigi.\n+      --  We always need a freeze node for a packed array subtype, so that we\n+      --  can build the Packed_Array_Type corresponding to the subtype. If\n+      --  expansion is disabled, the packed array subtype is not built, and we\n+      --  must not generate a freeze node for the type, or else it will appear\n+      --  incomplete to gigi.\n \n-      if Is_Packed (Itype) and then not In_Spec_Expression\n+      if Is_Packed (Itype)\n+        and then not In_Spec_Expression\n         and then Expander_Active\n       then\n          Freeze_Itype (Itype, N);\n@@ -728,11 +728,10 @@ package body Sem_Aggr is\n       Component_Elmt    : Elmt_Id;\n \n    begin\n-      --  All the components of List are matched against Component and\n-      --  a count is maintained of possible misspellings. When at the\n-      --  end of the analysis there are one or two (not more!) possible\n-      --  misspellings, these misspellings will be suggested as\n-      --  possible correction.\n+      --  All the components of List are matched against Component and a count\n+      --  is maintained of possible misspellings. When at the end of the\n+      --  the analysis there are one or two (not more!) possible misspellings,\n+      --  these misspellings will be suggested as possible correction.\n \n       Component_Elmt := First_Elmt (Elements);\n       while Nr_Of_Suggestions <= Max_Suggestions\n@@ -872,7 +871,7 @@ package body Sem_Aggr is\n          Append_To (Exprs, C_Node);\n \n          P := P + 1;\n-         --  something special for wide strings ???\n+         --  Something special for wide strings???\n       end loop;\n \n       New_N := Make_Aggregate (Loc, Expressions => Exprs);\n@@ -904,9 +903,9 @@ package body Sem_Aggr is\n       end if;\n \n       --  Check for aggregates not allowed in configurable run-time mode.\n-      --  We allow all cases of aggregates that do not come from source,\n-      --  since these are all assumed to be small (e.g. bounds of a string\n-      --  literal). We also allow aggregates of types we know to be small.\n+      --  We allow all cases of aggregates that do not come from source, since\n+      --  these are all assumed to be small (e.g. bounds of a string literal).\n+      --  We also allow aggregates of types we know to be small.\n \n       if not Support_Aggregates_On_Target\n         and then Comes_From_Source (N)\n@@ -941,10 +940,10 @@ package body Sem_Aggr is\n          --  First a special test, for the case of a positional aggregate\n          --  of characters which can be replaced by a string literal.\n \n-         --  Do not perform this transformation if this was a string literal\n-         --  to start with, whose components needed constraint checks, or if\n-         --  the component type is non-static, because it will require those\n-         --  checks and be transformed back into an aggregate.\n+         --  Do not perform this transformation if this was a string literal to\n+         --  start with, whose components needed constraint checks, or if the\n+         --  component type is non-static, because it will require those checks\n+         --  and be transformed back into an aggregate.\n \n          if Number_Dimensions (Typ) = 1\n            and then Is_Standard_Character_Type (Component_Type (Typ))\n@@ -989,10 +988,10 @@ package body Sem_Aggr is\n             Aggr_Resolved : Boolean;\n \n             Aggr_Typ : constant Entity_Id := Etype (Typ);\n-            --  This is the unconstrained array type, which is the type\n-            --  against which the aggregate is to be resolved. Typ itself\n-            --  is the array type of the context which may not be the same\n-            --  subtype as the subtype for the final aggregate.\n+            --  This is the unconstrained array type, which is the type against\n+            --  which the aggregate is to be resolved. Typ itself is the array\n+            --  type of the context which may not be the same subtype as the\n+            --  subtype for the final aggregate.\n \n          begin\n             --  In the following we determine whether an others choice is\n@@ -1002,19 +1001,19 @@ package body Sem_Aggr is\n             --  choice is not allowed.\n \n             --  If expansion is disabled (generic context, or semantics-only\n-            --  mode) actual subtypes cannot be constructed, and the type of\n-            --  an object may be its unconstrained nominal type. However, if\n-            --  the context is an assignment, we assume that \"others\" is\n-            --  allowed, because the target of the assignment will have a\n-            --  constrained subtype when fully compiled.\n+            --  mode) actual subtypes cannot be constructed, and the type of an\n+            --  object may be its unconstrained nominal type. However, if the\n+            --  context is an assignment, we assume that \"others\" is allowed,\n+            --  because the target of the assignment will have a constrained\n+            --  subtype when fully compiled.\n \n             --  Note that there is no node for Explicit_Actual_Parameter.\n             --  To test for this context we therefore have to test for node\n             --  N_Parameter_Association which itself appears only if there is a\n             --  formal parameter. Consequently we also need to test for\n             --  N_Procedure_Call_Statement or N_Function_Call.\n \n-            Set_Etype (N, Aggr_Typ);  --  may be overridden later on\n+            Set_Etype (N, Aggr_Typ);  --  May be overridden later on\n \n             if Is_Constrained (Typ) and then\n               (Pkind = N_Assignment_Statement      or else\n@@ -1080,10 +1079,10 @@ package body Sem_Aggr is\n          Error_Msg_N (\"illegal context for aggregate\", N);\n       end if;\n \n-      --  If we can determine statically that the evaluation of the\n-      --  aggregate raises Constraint_Error, then replace the\n-      --  aggregate with an N_Raise_Constraint_Error node, but set the\n-      --  Etype to the right aggregate subtype. Gigi needs this.\n+      --  If we can determine statically that the evaluation of the aggregate\n+      --  raises Constraint_Error, then replace the aggregate with an\n+      --  N_Raise_Constraint_Error node, but set the Etype to the right\n+      --  aggregate subtype. Gigi needs this.\n \n       if Raises_Constraint_Error (N) then\n          Aggr_Subtyp := Etype (N);\n@@ -1115,13 +1114,13 @@ package body Sem_Aggr is\n       Index_Typ      : constant Entity_Id := Etype (Index);\n       Index_Typ_Low  : constant Node_Id   := Type_Low_Bound  (Index_Typ);\n       Index_Typ_High : constant Node_Id   := Type_High_Bound (Index_Typ);\n-      --  The type of the index corresponding to the array sub-aggregate\n-      --  along with its low and upper bounds\n+      --  The type of the index corresponding to the array sub-aggregate along\n+      --  with its low and upper bounds.\n \n       Index_Base      : constant Entity_Id := Base_Type (Index_Typ);\n       Index_Base_Low  : constant Node_Id   := Type_Low_Bound (Index_Base);\n       Index_Base_High : constant Node_Id   := Type_High_Bound (Index_Base);\n-      --  ditto for the base type\n+      --  Ditto for the base type\n \n       function Add (Val : Uint; To : Node_Id) return Node_Id;\n       --  Creates a new expression node where Val is added to expression To.\n@@ -1131,16 +1130,16 @@ package body Sem_Aggr is\n       procedure Check_Bound (BH : Node_Id; AH : in out Node_Id);\n       --  Checks that AH (the upper bound of an array aggregate) is <= BH\n       --  (the upper bound of the index base type). If the check fails a\n-      --  warning is emitted, the Raises_Constraint_Error Flag of N is set,\n+      --  warning is emitted, the Raises_Constraint_Error flag of N is set,\n       --  and AH is replaced with a duplicate of BH.\n \n       procedure Check_Bounds (L, H : Node_Id; AL, AH : Node_Id);\n       --  Checks that range AL .. AH is compatible with range L .. H. Emits a\n-      --  warning if not and sets the Raises_Constraint_Error Flag in N.\n+      --  warning if not and sets the Raises_Constraint_Error flag in N.\n \n       procedure Check_Length (L, H : Node_Id; Len : Uint);\n       --  Checks that range L .. H contains at least Len elements. Emits a\n-      --  warning if not and sets the Raises_Constraint_Error Flag in N.\n+      --  warning if not and sets the Raises_Constraint_Error flag in N.\n \n       function Dynamic_Or_Null_Range (L, H : Node_Id) return Boolean;\n       --  Returns True if range L .. H is dynamic or null\n@@ -1155,11 +1154,10 @@ package body Sem_Aggr is\n          Single_Elmt : Boolean) return Boolean;\n       --  Resolves aggregate expression Expr. Returns False if resolution\n       --  fails. If Single_Elmt is set to False, the expression Expr may be\n-      --  used to initialize several array aggregate elements (this can\n-      --  happen for discrete choices such as \"L .. H => Expr\" or the others\n-      --  choice). In this event we do not resolve Expr unless expansion is\n-      --  disabled. To know why, see the DELAYED COMPONENT RESOLUTION\n-      --  note above.\n+      --  used to initialize several array aggregate elements (this can happen\n+      --  for discrete choices such as \"L .. H => Expr\" or the others choice).\n+      --  In this event we do not resolve Expr unless expansion is disabled.\n+      --  To know why, see the DELAYED COMPONENT RESOLUTION note above.\n \n       ---------\n       -- Add --\n@@ -1642,8 +1640,8 @@ package body Sem_Aggr is\n             --  discrete association\n \n             Prev_Nb_Discrete_Choices : Nat;\n-            --  Used to keep track of the number of discrete choices\n-            --  in the current association.\n+            --  Used to keep track of the number of discrete choices in the\n+            --  current association.\n \n          begin\n             --  STEP 2 (A): Check discrete choices validity\n@@ -1690,9 +1688,8 @@ package body Sem_Aggr is\n                      Check_Non_Static_Context (Choice);\n \n                      --  Do not range check a choice. This check is redundant\n-                     --  since this test is already performed when we check\n-                     --  that the bounds of the array aggregate are within\n-                     --  range.\n+                     --  since this test is already done when we check that the\n+                     --  bounds of the array aggregate are within range.\n \n                      Set_Do_Range_Check (Choice, False);\n                   end if;\n@@ -1754,13 +1751,13 @@ package body Sem_Aggr is\n                end if;\n \n                --  Ada 2005 (AI-287): In case of default initialized component\n-               --  we delay the resolution to the expansion phase\n+               --  we delay the resolution to the expansion phase.\n \n                if Box_Present (Assoc) then\n \n-                  --  Ada 2005 (AI-287): In case of default initialization\n-                  --  of a component the expander will generate calls to\n-                  --  the corresponding initialization subprogram.\n+                  --  Ada 2005 (AI-287): In case of default initialization of a\n+                  --  component the expander will generate calls to the\n+                  --  corresponding initialization subprogram.\n \n                   null;\n \n@@ -1773,8 +1770,8 @@ package body Sem_Aggr is\n \n                --  We differentiate here two cases because the expression may\n                --  not be decorated. For example, the analysis and resolution\n-               --  of the expression associated with the others choice will\n-               --  be done later with the full aggregate. In such case we\n+               --  of the expression associated with the others choice will be\n+               --  done later with the full aggregate. In such case we\n                --  duplicate the expression tree to analyze the copy and\n                --  perform the required check.\n \n@@ -1810,7 +1807,7 @@ package body Sem_Aggr is\n             end loop;\n \n             --  If aggregate contains more than one choice then these must be\n-            --  static. Sort them and check that they are contiguous\n+            --  static. Sort them and check that they are contiguous.\n \n             if Nb_Discrete_Choices > 1 then\n                Sort_Case_Table (Table);"}, {"sha": "e37b216ca45984953ea2fd29902d4a2dcdb36b76", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=b87971f33ef5446f674fb9f80c6ff16e82145ee1", "patch": "@@ -667,8 +667,8 @@ package body Sem_Attr is\n                      end loop;\n \n                      if Present (Q) then\n-                        Set_Has_Per_Object_Constraint (\n-                          Defining_Identifier (Q), True);\n+                        Set_Has_Per_Object_Constraint\n+                          (Defining_Identifier (Q), True);\n                      end if;\n                   end;\n \n@@ -1991,9 +1991,10 @@ package body Sem_Attr is\n          --  entry wrappers, the attributes Count, Caller and AST_Entry require\n          --  a context check\n \n-         if Aname = Name_Count\n-           or else Aname = Name_Caller\n-           or else Aname = Name_AST_Entry\n+         if Ada_Version >= Ada_05\n+           and then (Aname = Name_Count\n+                      or else Aname = Name_Caller\n+                      or else Aname = Name_AST_Entry)\n          then\n             declare\n                Count : Natural := 0;"}, {"sha": "7dd9629da6a73f2af0f1d6e5d18d3b0fe2a2f44a", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=b87971f33ef5446f674fb9f80c6ff16e82145ee1", "patch": "@@ -784,7 +784,7 @@ package body Sem_Ch3 is\n \n       Anon_Type :=\n         Create_Itype\n-         (E_Anonymous_Access_Type, Related_Nod, Scope_Id =>  Anon_Scope);\n+         (E_Anonymous_Access_Type, Related_Nod, Scope_Id => Anon_Scope);\n \n       if All_Present (N)\n         and then Ada_Version >= Ada_05\n@@ -825,8 +825,7 @@ package body Sem_Ch3 is\n       Find_Type (Subtype_Mark (N));\n       Desig_Type := Entity (Subtype_Mark (N));\n \n-      Set_Directly_Designated_Type\n-                (Anon_Type, Desig_Type);\n+      Set_Directly_Designated_Type (Anon_Type, Desig_Type);\n       Set_Etype (Anon_Type, Anon_Type);\n \n       --  Make sure the anonymous access type has size and alignment fields\n@@ -2883,12 +2882,11 @@ package body Sem_Ch3 is\n             Apply_Length_Check (E, T);\n          end if;\n \n-      --  If the type is limited unconstrained with defaulted discriminants\n-      --  and there is no expression, then the object is constrained by the\n+      --  If the type is limited unconstrained with defaulted discriminants and\n+      --  there is no expression, then the object is constrained by the\n       --  defaults, so it is worthwhile building the corresponding subtype.\n \n-      elsif (Is_Limited_Record (T)\n-               or else Is_Concurrent_Type (T))\n+      elsif (Is_Limited_Record (T) or else Is_Concurrent_Type (T))\n         and then not Is_Constrained (T)\n         and then Has_Discriminants (T)\n       then"}, {"sha": "f1004d5a5c34803aaf549392b5f10f54257bb40c", "filename": "gcc/ada/tbuild.adb", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Ftbuild.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Ftbuild.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftbuild.adb?ref=b87971f33ef5446f674fb9f80c6ff16e82145ee1", "patch": "@@ -33,7 +33,6 @@ with Opt;      use Opt;\n with Restrict; use Restrict;\n with Rident;   use Rident;\n with Sem_Aux;  use Sem_Aux;\n-with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Stringt;  use Stringt;\n@@ -626,6 +625,56 @@ package body Tbuild is\n       return Occurrence;\n    end New_Occurrence_Of;\n \n+   -----------------\n+   -- New_Op_Node --\n+   -----------------\n+\n+   function New_Op_Node\n+     (New_Node_Kind : Node_Kind;\n+      New_Sloc      : Source_Ptr) return Node_Id\n+   is\n+      type Name_Of_Type is array (N_Op) of Name_Id;\n+      Name_Of : constant Name_Of_Type := Name_Of_Type'(\n+         N_Op_And                    => Name_Op_And,\n+         N_Op_Or                     => Name_Op_Or,\n+         N_Op_Xor                    => Name_Op_Xor,\n+         N_Op_Eq                     => Name_Op_Eq,\n+         N_Op_Ne                     => Name_Op_Ne,\n+         N_Op_Lt                     => Name_Op_Lt,\n+         N_Op_Le                     => Name_Op_Le,\n+         N_Op_Gt                     => Name_Op_Gt,\n+         N_Op_Ge                     => Name_Op_Ge,\n+         N_Op_Add                    => Name_Op_Add,\n+         N_Op_Subtract               => Name_Op_Subtract,\n+         N_Op_Concat                 => Name_Op_Concat,\n+         N_Op_Multiply               => Name_Op_Multiply,\n+         N_Op_Divide                 => Name_Op_Divide,\n+         N_Op_Mod                    => Name_Op_Mod,\n+         N_Op_Rem                    => Name_Op_Rem,\n+         N_Op_Expon                  => Name_Op_Expon,\n+         N_Op_Plus                   => Name_Op_Add,\n+         N_Op_Minus                  => Name_Op_Subtract,\n+         N_Op_Abs                    => Name_Op_Abs,\n+         N_Op_Not                    => Name_Op_Not,\n+\n+         --  We don't really need these shift operators, since they never\n+         --  appear as operators in the source, but the path of least\n+         --  resistance is to put them in (the aggregate must be complete)\n+\n+         N_Op_Rotate_Left            => Name_Rotate_Left,\n+         N_Op_Rotate_Right           => Name_Rotate_Right,\n+         N_Op_Shift_Left             => Name_Shift_Left,\n+         N_Op_Shift_Right            => Name_Shift_Right,\n+         N_Op_Shift_Right_Arithmetic => Name_Shift_Right_Arithmetic);\n+\n+      Nod : constant Node_Id := New_Node (New_Node_Kind, New_Sloc);\n+   begin\n+      if New_Node_Kind in Name_Of'Range then\n+         Set_Chars (Nod, Name_Of (New_Node_Kind));\n+      end if;\n+      return Nod;\n+   end New_Op_Node;\n+\n    ----------------------\n    -- New_Reference_To --\n    ----------------------"}, {"sha": "0b73a53d2205811263b0d734f777bd0eadd50d06", "filename": "gcc/ada/tbuild.ads", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Ftbuild.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87971f33ef5446f674fb9f80c6ff16e82145ee1/gcc%2Fada%2Ftbuild.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftbuild.ads?ref=b87971f33ef5446f674fb9f80c6ff16e82145ee1", "patch": "@@ -27,6 +27,7 @@\n --  building specific types of tree nodes.\n \n with Namet; use Namet;\n+with Sinfo; use Sinfo;\n with Types; use Types;\n \n package Tbuild is\n@@ -196,6 +197,12 @@ package Tbuild is\n    --  \"raise Constraint_Error\" and returns the root of this tree,\n    --  the N_Raise_Statement node.\n \n+   function New_Op_Node\n+     (New_Node_Kind : Node_Kind;\n+      New_Sloc      : Source_Ptr) return Node_Id;\n+   --  Create node using New_Node and, if its kind is in N_Op, set its Chars\n+   --  field accordingly.\n+\n    function New_External_Name\n      (Related_Id   : Name_Id;\n       Suffix       : Character := ' ';"}]}