{"sha": "4eda77ec3e5f61fa3cd1d5b431917c9b851b4228", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGVkYTc3ZWMzZTVmNjFmYTNjZDFkNWI0MzE5MTdjOWI4NTFiNDIyOA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1994-06-04T11:17:23Z"}, "committer": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1994-06-04T11:17:23Z"}, "message": "(FUNCTION_PROFILER): Delete duplicate definition.\n\n(FUNCTION_PROFILER, TRAMPOLINE_TEMPLATE, ASM_FILE_START,\n ASM_OUTPUT_REG_{PUSH,POP}, PRINT_OPERAND_ADDRESS):  Output register\n prefix before any explicit register name.\n(ASM_OUTPUT_LONG_DOUBLE, ASM_OUTPUT_DOUBLE, ASM_OUTPUT_FLOAT,\n ASM_OUTPUT_COMMON): Output the target dependent comment char.\n(ASM_FILE_START): Output register alias for r10.\n(REGISTER_NAMES): Output \"r9\" now for r9, not \"rfp\".\n(ADDITIONAL_REGISTER_NAMES): New macro.\n\nFrom-SVN: r7444", "tree": {"sha": "4ef2007d5c5ca4c6445365c7e1e298bbe50376fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ef2007d5c5ca4c6445365c7e1e298bbe50376fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4eda77ec3e5f61fa3cd1d5b431917c9b851b4228", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4eda77ec3e5f61fa3cd1d5b431917c9b851b4228", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4eda77ec3e5f61fa3cd1d5b431917c9b851b4228", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4eda77ec3e5f61fa3cd1d5b431917c9b851b4228/comments", "author": null, "committer": null, "parents": [{"sha": "916cc8c5aab7e00d534842768b7dfe2bc61fba7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/916cc8c5aab7e00d534842768b7dfe2bc61fba7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/916cc8c5aab7e00d534842768b7dfe2bc61fba7a"}], "stats": {"total": 156, "additions": 90, "deletions": 66}, "files": [{"sha": "bf5e8d1c67c55ea82ce53fb61e3ff11d2aa5a885", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 90, "deletions": 66, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eda77ec3e5f61fa3cd1d5b431917c9b851b4228/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eda77ec3e5f61fa3cd1d5b431917c9b851b4228/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=4eda77ec3e5f61fa3cd1d5b431917c9b851b4228", "patch": "@@ -684,12 +684,12 @@ enum reg_class\n    puts this BEFORE the prolog but gcc pust it afterwards.  The ``mov ip,lr''\n    seems like a good idea to stick with cc convention.  ``prof'' doesn't seem\n    to mind about this!  */\n-#define FUNCTION_PROFILER(STREAM,LABELNO)  \\\n-{\t\t\t\t\t\t\t\\\n-    fprintf(STREAM, \"\\tmov\\tip, lr\\n\");\t\t\t\\\n-    fprintf(STREAM, \"\\tbl\\tmcount\\n\");\t\t\t\\\n-    fprintf(STREAM, \"\\t.word\\tLP%d\\n\", (LABELNO));\t\\\n-    arm_increase_location (12);\t\t\t\t\\\n+#define FUNCTION_PROFILER(STREAM,LABELNO)  \t\t\t\t    \\\n+{\t\t\t\t\t\t\t\t\t    \\\n+    fprintf(STREAM, \"\\tmov\\t%sip, %slr\\n\", ARM_REG_PREFIX, ARM_REG_PREFIX); \\\n+    fprintf(STREAM, \"\\tbl\\tmcount\\n\");\t\t\t\t\t    \\\n+    fprintf(STREAM, \"\\t.word\\tLP%d\\n\", (LABELNO));\t\t\t    \\\n+    arm_increase_location (12);\t\t\t\t\t\t    \\\n }\n \n /* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n@@ -780,12 +780,14 @@ enum reg_class\n \t   ldr\t\tpc, [pc]\n \t   .word\tstatic chain value\n \t   .word\tfunction's address  */\n-#define TRAMPOLINE_TEMPLATE(FILE)  \\\n-{\t\t\t\t\t\t\\\n-  fprintf ((FILE), \"\\tldr\\tr8, [pc, #0]\\n\");\t\\\n-  fprintf ((FILE), \"\\tldr\\tpc, [pc, #0]\\n\");\t\\\n-  fprintf ((FILE), \"\\t.word\\t0\\n\");\t\t\\\n-  fprintf ((FILE), \"\\t.word\\t0\\n\");\t\t\\\n+#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  fprintf ((FILE), \"\\tldr\\t%sr8, [%spc, #0]\\n\", ARM_REG_PREFIX,\t\\\n+\t   ARM_REG_PREFIX);\t\t\t\t\t\\\n+  fprintf ((FILE), \"\\tldr\\t%spc, [%spc, #0]\\n\", ARM_REG_PREFIX,\t\\\n+\t   ARM_REG_PREFIX);\t\t\t\t\t\\\n+  fprintf ((FILE), \"\\t.word\\t0\\n\");\t\t\t\t\\\n+  fprintf ((FILE), \"\\t.word\\t0\\n\");\t\t\t\t\\\n }\n \n /* Length in units of the trampoline for entering a nested function.  */\n@@ -805,17 +807,6 @@ enum reg_class\n \t\t  (FNADDR));\t\t\t\t\t\t\\\n }\n \n-/* Call the function profiler with a given profile label.  The Acorn compiler\n-   puts this BEFORE the prolog but gcc pust it afterwards.  The ``mov ip,lr''\n-   seems like a good idea to stick with cc convention.  ``prof'' doesn't seem\n-   to mind about this!  */\n-#define FUNCTION_PROFILER(STREAM,LABELNO)  \\\n-{\t\t\t\t\t\t\t\\\n-    fprintf(STREAM, \"\\tmov\\tip, lr\\n\");\t\t\t\\\n-    fprintf(STREAM, \"\\tbl\\tmcount\\n\");\t\t\t\\\n-    fprintf(STREAM, \"\\t.word\\tLP%d\\n\", (LABELNO));\t\\\n-    arm_increase_location (12);\t\t\t\t\\\n-}\n \f\n /* Addressing modes, and classification of registers for them.  */\n \n@@ -1361,18 +1352,18 @@ extern int arm_compare_fp;\n #endif\n \n /* The text to go at the start of the assembler file */\n-#define ASM_FILE_START(STREAM)  \\\n-{                                                                             \\\n-  extern char *version_string;                                                \\\n-                                                                             \\\n-  fprintf (STREAM,\"@ Generated by gcc %s for ARM/%s\\n\", version_string,\t      \\\n-\t   ARM_OS_NAME); \t\t\t\t\t\t      \\\n-  fprintf (STREAM,\"rfp\\t.req\\tr9\\n\");                                         \\\n-  fprintf (STREAM,\"fp\\t.req\\tr11\\n\");\t\t\t\t              \\\n-  fprintf (STREAM,\"ip\\t.req\\tr12\\n\");\t\t\t\t              \\\n-  fprintf (STREAM,\"sp\\t.req\\tr13\\n\");\t\t\t\t              \\\n-  fprintf (STREAM,\"lr\\t.req\\tr14\\n\");\t\t\t\t\t      \\\n-  fprintf (STREAM,\"pc\\t.req\\tr15\\n\");\t\t\t\t              \\\n+#define ASM_FILE_START(STREAM)\t\t\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  extern char *version_string;\t\t\t\t\t\t  \\\n+  fprintf (STREAM,\"%c Generated by gcc %s for ARM/%s\\n\",\t\t  \\\n+\t   ARM_COMMENT_CHAR, version_string, ARM_OS_NAME);\t\t  \\\n+  fprintf (STREAM,\"%srfp\\t.req\\t%sr9\\n\", ARM_REG_PREFIX, ARM_REG_PREFIX); \\\n+  fprintf (STREAM,\"%ssl\\t.req\\t%sr10\\n\", ARM_REG_PREFIX, ARM_REG_PREFIX); \\\n+  fprintf (STREAM,\"%sfp\\t.req\\t%sr11\\n\", ARM_REG_PREFIX, ARM_REG_PREFIX); \\\n+  fprintf (STREAM,\"%sip\\t.req\\t%sr12\\n\", ARM_REG_PREFIX, ARM_REG_PREFIX); \\\n+  fprintf (STREAM,\"%ssp\\t.req\\t%sr13\\n\", ARM_REG_PREFIX, ARM_REG_PREFIX); \\\n+  fprintf (STREAM,\"%slr\\t.req\\t%sr14\\n\", ARM_REG_PREFIX, ARM_REG_PREFIX); \\\n+  fprintf (STREAM,\"%spc\\t.req\\t%sr15\\n\", ARM_REG_PREFIX, ARM_REG_PREFIX); \\\n }\n \n #define ASM_APP_ON  \"\"\n@@ -1382,17 +1373,41 @@ extern int arm_compare_fp;\n #define TEXT_SECTION_ASM_OP  \".text\"\n #define DATA_SECTION_ASM_OP  \".data\"\n \n-/* The assembler's names for the registers.  RFP need not always be used as\n-   the Real framepointer; it can also be used as a normal general register.\n-   Note that the name `fp' is horribly misleading since `fp' is in fact only\n-   the argument-and-return-context pointer.  */\n+/* The assembler's names for the registers.  */\n+#ifndef REGISTER_NAMES\n #define REGISTER_NAMES  \\\n {\t\t\t\t                   \\\n   \"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\",  \\\n-  \"r8\",\"rfp\", \"sl\", \"fp\", \"ip\", \"sp\", \"lr\", \"pc\",  \\\n+  \"r8\", \"r9\", \"sl\", \"fp\", \"ip\", \"sp\", \"lr\", \"pc\",  \\\n   \"f0\", \"f1\", \"f2\", \"f3\", \"f4\", \"f5\", \"f6\", \"f7\",  \\\n   \"cc\", \"sfp\", \"afp\"\t\t\t\t   \\\n }\n+#endif\n+\n+#ifndef ADDITIONAL_REGISTER_NAMES\n+#define ADDITIONAL_REGISTER_NAMES\t\t\\\n+{\t\t\t\t\t\t\\\n+  {\"a1\", 0},\t\t\t\t\t\\\n+  {\"a2\", 1},\t\t\t\t\t\\\n+  {\"a3\", 2},\t\t\t\t\t\\\n+  {\"a4\", 3},\t\t\t\t\t\\\n+  {\"v1\", 4},\t\t\t\t\t\\\n+  {\"v2\", 5},\t\t\t\t\t\\\n+  {\"v3\", 6},\t\t\t\t\t\\\n+  {\"v4\", 7},\t\t\t\t\t\\\n+  {\"v5\", 8},\t\t\t\t\t\\\n+  {\"v6\", 9},\t\t\t\t\t\\\n+  {\"rfp\", 9}, /* Gcc used to call it this */\t\\\n+  {\"sb\", 9},\t\t\t\t\t\\\n+  {\"v7\", 10},\t\t\t\t\t\\\n+  {\"r10\", 10},\t\t\t\t\t\\\n+  {\"r11\", 11},\t/* fp */\t\t\t\\\n+  {\"r12\", 12},\t/* ip */\t\t\t\\\n+  {\"r13\", 13},\t/* sp */\t\t\t\\\n+  {\"r14\", 14},\t/* lr */\t\t\t\\\n+  {\"r15\", 15}\t/* pc */\t\t\t\\\n+}\n+#endif\n \n /* Arm Assembler barfs on dollars */\n #define DOLLARS_IN_IDENTIFIERS 0\n@@ -1470,11 +1485,13 @@ do {\t\t\t\t\t\t\t\t\t\\\n    sprintf ((OUTVAR), \"%s.%d\", (NAME), (NUMBER)))\n \n /* Output a push or a pop instruction (only used when profiling).  */\n-#define ASM_OUTPUT_REG_PUSH(STREAM,REGNO)   \\\n-  fprintf(STREAM,\"\\tstmfd\\tsp!,{%s}\\n\", reg_names[REGNO])\n+#define ASM_OUTPUT_REG_PUSH(STREAM,REGNO)\t\t\t\t    \\\n+  fprintf(STREAM,\"\\tstmfd\\t%ssp!,{%s%s}\\n\", ARM_REG_PREFIX, ARM_REG_PREFIX, \\\n+\t  reg_names[REGNO])\n \n-#define ASM_OUTPUT_REG_POP(STREAM,REGNO)   \\\n-  fprintf(STREAM,\"\\tldmfd\\tsp!,{%s}\\n\", reg_names[REGNO])\n+#define ASM_OUTPUT_REG_POP(STREAM,REGNO)\t\t\t\t    \\\n+  fprintf(STREAM,\"\\tldmfd\\t%ssp!,{%s%s}\\n\", ARM_REG_PREFIX, ARM_REG_PREFIX, \\\n+\t  reg_names[REGNO])\n \n /* Output a relative address. Not needed since jump tables are absolute\n    but we must define it anyway.  */\n@@ -1497,11 +1514,11 @@ do { char dstr[30];\t\t\t\t\t\t\t\\\n      REAL_VALUE_TO_TARGET_LONG_DOUBLE (VALUE, l);\t\t\t\\\n      REAL_VALUE_TO_DECIMAL (VALUE, \"%.20g\", dstr);\t\t\t\\\n      if (sizeof (int) == sizeof (long))\t\t\t\t\t\\\n-       fprintf (STREAM, \"\\t.long 0x%x,0x%x,0x%x\\t@ long double %s\\n\",\t\\\n-\t\tl[2], l[1], l[0], dstr);\t\t\t\t\\\n+       fprintf (STREAM, \"\\t.long 0x%x,0x%x,0x%x\\t%c long double %s\\n\",\t\\\n+\t\tl[2], l[1], l[0], ARM_COMMENT_CHAR, dstr);\t\t\\\n      else\t\t\t\t\t\t\t\t\\\n-       fprintf (STREAM, \"\\t.long 0x%lx,0x%lx,0x%lx\\t@ long double %s\\n\",\\\n-\t\tl[0], l[1], l[2], dstr);\t\t\t\t\\\n+       fprintf (STREAM, \"\\t.long 0x%lx,0x%lx,0x%lx\\t%c long double %s\\n\",\\\n+\t\tl[0], l[1], l[2], ARM_COMMENT_CHAR, dstr);\t\t\\\n    } while (0)\n \n     \n@@ -1512,11 +1529,11 @@ do { char dstr[30];\t\t\t\t\t\t\t\\\n      REAL_VALUE_TO_TARGET_DOUBLE (VALUE, l);\t\t\t\t\\\n      REAL_VALUE_TO_DECIMAL (VALUE, \"%.14g\", dstr);\t\t\t\\\n      if (sizeof (int) == sizeof (long))\t\t\t\t\t\\\n-       fprintf (STREAM, \"\\t.long 0x%x, 0x%x\\t@ double %s\\n\", l[0], l[1],\\\n-\t\tdstr);\t\t\t\t\t\t\t\\\n+       fprintf (STREAM, \"\\t.long 0x%x, 0x%x\\t%c double %s\\n\", l[0],\t\\\n+\t\tl[1], ARM_COMMENT_CHAR, dstr);\t\t\t\t\\\n      else\t\t\t\t\t\t\t\t\\\n-       fprintf (STREAM, \"\\t.long 0x%lx, 0x%lx\\t@ double %s\\n\", l[0],\t\\\n-\t\tl[1], dstr);\t\t\t\t\t\t\\\n+       fprintf (STREAM, \"\\t.long 0x%lx, 0x%lx\\t%c double %s\\n\", l[0],\t\\\n+\t\tl[1], ARM_COMMENT_CHAR, dstr);\t\t\t\t\\\n    } while (0)\n \n #define ASM_OUTPUT_FLOAT(STREAM, VALUE)\t\t\t\t\t\\\n@@ -1526,9 +1543,11 @@ do { char dstr[30];\t\t\t\t\t\t\t\\\n      REAL_VALUE_TO_TARGET_SINGLE (VALUE, l);\t\t\t\t\\\n      REAL_VALUE_TO_DECIMAL (VALUE, \"%.7g\", dstr);\t\t\t\\\n      if (sizeof (int) == sizeof (long))\t\t\t\t\t\\\n-       fprintf (STREAM, \"\\t.word 0x%x\\t@ float %s\\n\", l, dstr);\t\t\\\n+       fprintf (STREAM, \"\\t.word 0x%x\\t%c float %s\\n\", l,\t\t\\\n+\t\tARM_COMMENT_CHAR, dstr);\t\t\t\t\\\n      else\t\t\t\t\t\t\t\t\\\n-       fprintf (STREAM, \"\\t.word 0x%lx\\t@ float %s\\n\", l, dstr);\t\\\n+       fprintf (STREAM, \"\\t.word 0x%lx\\t%c float %s\\n\", l,\t\t\\\n+\t\tARM_COMMENT_CHAR, dstr);\t\t\t\t\\\n    } while (0);\n \n #define ASM_OUTPUT_INT(STREAM, EXP)\t\\\n@@ -1579,10 +1598,10 @@ do { char dstr[30];\t\t\t\t\t\t\t\\\n     } while (0)\n \n /* Output a common block */\n-#define ASM_OUTPUT_COMMON(STREAM, NAME, SIZE, ROUNDED)  \\\n-  (fprintf (STREAM, \"\\t.comm\\t\"), \t\t     \\\n-   assemble_name ((STREAM), (NAME)),\t\t     \\\n-   fprintf(STREAM, \", %d\\t@%d\\n\", ROUNDED, SIZE))\n+#define ASM_OUTPUT_COMMON(STREAM, NAME, SIZE, ROUNDED)  \t\t\\\n+  (fprintf (STREAM, \"\\t.comm\\t\"), \t\t     \t\t\t\\\n+   assemble_name ((STREAM), (NAME)),\t\t     \t\t\t\\\n+   fprintf(STREAM, \", %d\\t%c%d\\n\", ROUNDED, ARM_COMMENT_CHAR, SIZE))\n \n /* Output a local common block.  /bin/as can't do this, so hack a `.space' into\n    the bss segment.  Note that this is *bad* practice.  */\n@@ -1644,7 +1663,8 @@ do { char dstr[30];\t\t\t\t\t\t\t\\\n     int is_minus = GET_CODE (X) == MINUS;\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n     if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n-\tfprintf (STREAM, \"[%s, #0]\", reg_names[REGNO (X)]);\t\t\\\n+\tfprintf (STREAM, \"[%s%s, #0]\", ARM_REG_PREFIX,\t\t\t\\\n+\t\t reg_names[REGNO (X)]);\t\t\t\t\t\\\n     else if (GET_CODE (X) == PLUS || is_minus)\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n \trtx base = XEXP (X, 0);\t\t\t\t\t\t\\\n@@ -1665,12 +1685,14 @@ do { char dstr[30];\t\t\t\t\t\t\t\\\n \t    offset = INTVAL (index);\t\t\t\t\t\\\n \t    if (is_minus)\t\t\t\t\t\t\\\n \t      offset = -offset;\t\t\t\t\t\t\\\n-\t    fprintf (STREAM, \"[%s, #%d]\", base_reg_name, offset);\t\\\n+\t    fprintf (STREAM, \"[%s%s, #%d]\", ARM_REG_PREFIX,\t\t\\\n+\t\t     base_reg_name, offset);\t\t\t\t\\\n \t    break;\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n \t  case REG:\t\t\t\t\t\t\t\\\n-\t    fprintf (STREAM, \"[%s, %s%s]\", base_reg_name,\t\t\\\n-\t\t     is_minus ? \"-\" : \"\", reg_names[REGNO (index)] );\t\\\n+\t    fprintf (STREAM, \"[%s%s, %s%s%s]\", ARM_REG_PREFIX,\t\t\\\n+\t\t     base_reg_name, is_minus ? \"-\" : \"\",\t\t\\\n+\t\t     ARM_REG_PREFIX, reg_names[REGNO (index)] );\t\\\n \t    break;\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n \t  case MULT:\t\t\t\t\t\t\t\\\n@@ -1679,8 +1701,8 @@ do { char dstr[30];\t\t\t\t\t\t\t\\\n \t  case ASHIFT:\t\t\t\t\t\t\t\\\n \t  case ROTATERT:\t\t\t\t\t\t\\\n \t  {\t\t\t\t\t\t\t\t\\\n-\t    fprintf (STREAM, \"[%s, %s%s, \", base_reg_name,\t\t\\\n-\t\t     is_minus ? \"-\" : \"\", \t\t\t\t\\\n+\t    fprintf (STREAM, \"[%s%s, %s%s%s, \", ARM_REG_PREFIX,\t\t\\\n+\t\t     base_reg_name, is_minus ? \"-\" : \"\", ARM_REG_PREFIX,\\\n \t\t     reg_names[REGNO (XEXP (index, 0))]);\t\t\\\n \t    arm_print_operand (STREAM, index, 'S');\t\t\t\\\n \t    fputs (\"]\", STREAM);\t\t\t\t\t\\\n@@ -1700,11 +1722,13 @@ do { char dstr[30];\t\t\t\t\t\t\t\\\n \tabort ();\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n       if (GET_CODE (X) == PRE_DEC || GET_CODE (X) == PRE_INC)\t\t\\\n-\tfprintf (STREAM, \"[%s, #%s%d]!\", reg_names[REGNO (XEXP (X, 0))],\\\n+\tfprintf (STREAM, \"[%s%s, #%s%d]!\", ARM_REG_PREFIX,\t\t\\\n+\t\t reg_names[REGNO (XEXP (X, 0))],\t\t\t\\\n \t\t GET_CODE (X) == PRE_DEC ? \"-\" : \"\",\t\t\t\\\n \t\t GET_MODE_SIZE (output_memory_reference_mode));\t\t\\\n       else\t\t\t\t\t\t\t\t\\\n-\tfprintf (STREAM, \"[%s], #%s%d\", reg_names[REGNO (XEXP (X, 0))],\t\\\n+\tfprintf (STREAM, \"[%s%s], #%s%d\", ARM_REG_PREFIX,\t\t\\\n+\t\t reg_names[REGNO (XEXP (X, 0))],\t\t\t\\\n \t\t GET_CODE (X) == POST_DEC ? \"-\" : \"\",\t\t\t\\\n \t\t GET_MODE_SIZE (output_memory_reference_mode));\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\"}]}