{"sha": "628448b35cdad27bf9064a252265a8c7f634091f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjI4NDQ4YjM1Y2RhZDI3YmY5MDY0YTI1MjI2NWE4YzdmNjM0MDkxZg==", "commit": {"author": {"name": "Stan Cox", "email": "coxs@gnu.org", "date": "1995-12-22T20:24:34Z"}, "committer": {"name": "Stan Cox", "email": "coxs@gnu.org", "date": "1995-12-22T20:24:34Z"}, "message": "(strlensi): New pattern.\n\nFrom-SVN: r10831", "tree": {"sha": "c6e0c47cd102c808d0b3d457260c9e9549160ea4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6e0c47cd102c808d0b3d457260c9e9549160ea4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/628448b35cdad27bf9064a252265a8c7f634091f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/628448b35cdad27bf9064a252265a8c7f634091f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/628448b35cdad27bf9064a252265a8c7f634091f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/628448b35cdad27bf9064a252265a8c7f634091f/comments", "author": null, "committer": null, "parents": [{"sha": "3f803cd94cdc0aa589dc959da7d438437f992e04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f803cd94cdc0aa589dc959da7d438437f992e04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f803cd94cdc0aa589dc959da7d438437f992e04"}], "stats": {"total": 76, "additions": 69, "deletions": 7}, "files": [{"sha": "43633159add7c64cc236f2ccf3c678d7a648fb02", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 69, "deletions": 7, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628448b35cdad27bf9064a252265a8c7f634091f/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628448b35cdad27bf9064a252265a8c7f634091f/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=628448b35cdad27bf9064a252265a8c7f634091f", "patch": "@@ -4183,7 +4183,7 @@\n \t\t\t (const_int 1)\n \t\t\t (match_operand:SI 2 \"general_operand\" \"r\"))\n \t(match_operand:SI 3 \"const_int_operand\" \"n\"))]\n-  \"TARGET_BIT_TEST && GET_CODE (operands[2]) != CONST_INT\"\n+  \"TARGET_USE_BIT_TEST && GET_CODE (operands[2]) != CONST_INT\"\n   \"*\n {\n   CC_STATUS_INIT;\n@@ -4201,7 +4201,7 @@\n \t(xor:SI (ashift:SI (const_int 1)\n \t\t\t   (match_operand:SI 1 \"general_operand\" \"r\"))\n \t\t(match_operand:SI 2 \"general_operand\" \"0\")))]\n-  \"TARGET_BIT_TEST && GET_CODE (operands[1]) != CONST_INT\"\n+  \"TARGET_USE_BIT_TEST && GET_CODE (operands[1]) != CONST_INT\"\n   \"*\n {\n   CC_STATUS_INIT;\n@@ -4214,7 +4214,7 @@\n \t(xor:SI (match_operand:SI 1 \"general_operand\" \"0\")\n \t\t(ashift:SI (const_int 1)\n \t\t\t   (match_operand:SI 2 \"general_operand\" \"r\"))))]\n-  \"TARGET_BIT_TEST && GET_CODE (operands[2]) != CONST_INT\"\n+  \"TARGET_USE_BIT_TEST && GET_CODE (operands[2]) != CONST_INT\"\n   \"*\n {\n   CC_STATUS_INIT;\n@@ -5742,17 +5742,58 @@\n (define_expand \"strlensi\"\n   [(parallel [(set (match_dup 4)\n \t\t   (unspec:SI [(mem:BLK (match_operand:BLK 1 \"general_operand\" \"\"))\n-\t\t\t       (match_operand:QI 2 \"register_operand\" \"\")\n+\t\t\t       (match_operand:QI 2 \"immediate_operand\" \"\")\n \t\t\t       (match_operand:SI 3 \"immediate_operand\" \"\")] 0))\n \t      (clobber (match_dup 1))])\n    (set (match_dup 5)\n \t(not:SI (match_dup 4)))\n    (set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(minus:SI (match_dup 5)\n-\t\t (const_int 1)))]\n+\t(plus:SI (match_dup 5)\n+\t         (const_int -1)))]\n   \"\"\n   \"\n {\n+  if (TARGET_UNROLL_STRLEN && operands[2] == const0_rtx && optimize > 1)\n+    {\n+      rtx address;\n+      rtx scratch;\n+\n+\t/* well it seems that some optimizer does not combine a call like\n+\t     foo(strlen(bar), strlen(bar));\n+\t   when the move and the subtraction is done here.  It does calculate\n+\t   the length just once when these instructions are done inside of\n+\t   output_strlen_unroll().  But I think since &bar[strlen(bar)] is\n+\t   often used and I use one fewer register for the lifetime of\n+\t   output_strlen_unroll() this is better.  */\n+      scratch = gen_reg_rtx (SImode);\n+      address = force_reg (SImode, XEXP (operands[1], 0));\n+\n+\t/* move address to scratch-register\n+\t   this is done here because the i586 can do the following and\n+\t   in the same cycle with the following move.  */\n+      if (GET_CODE (operands[3]) != CONST_INT || INTVAL (operands[3]) < 4)\n+\t  emit_insn (gen_movsi (scratch, address));\n+\n+      emit_insn (gen_movsi (operands[0], address));\n+\n+      if(TARGET_USE_Q_REG)\n+\temit_insn (gen_strlensi_unroll5 (operands[0],\n+\t\t\t\t\toperands[3],\n+\t\t\t\t\tscratch,\n+\t\t\t\t\toperands[0]));\n+      else\n+\temit_insn (gen_strlensi_unroll4 (operands[0],\n+\t\t\t\t\toperands[3],\n+\t\t\t\t\tscratch,\n+\t\t\t\t\toperands[0]));\n+\n+        /* gen_strlensi_unroll[45] returns the address of the zero\n+           at the end of the string, like memchr(), so compute the\n+           length by subtracting the startaddress.  */\n+      emit_insn (gen_subsi3 (operands[0], operands[0], address));\n+      DONE;\n+    }\n+\n   operands[1] = copy_to_mode_reg (SImode, XEXP (operands[1], 0));\n   operands[4] = gen_reg_rtx (SImode);\n   operands[5] = gen_reg_rtx (SImode);\n@@ -5765,7 +5806,7 @@\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=&c\")\n \t(unspec:SI [(mem:BLK (match_operand:SI 1 \"address_operand\" \"D\"))\n-\t\t    (match_operand:QI 2 \"register_operand\" \"a\")\n+\t\t    (match_operand:QI 2 \"immediate_operand\" \"a\")\n \t\t    (match_operand:SI 3 \"immediate_operand\" \"i\")] 0))\n    (clobber (match_dup 1))]\n   \"\"\n@@ -5779,3 +5820,24 @@\n   output_asm_insn (AS2 (mov%L0,%1,%0), xops);\n   return \\\"repnz\\;scas%B2\\\";\n }\")\n+\n+;; the only difference between the following patterns is the register preference\n+;; on a pentium using a q-register saves one clock cycle per 4 characters\n+\n+(define_insn \"strlensi_unroll4\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t\t   (unspec:SI [(mem:BLK (match_operand:SI 3 \"register_operand\" \"0,0\"))\n+\t\t\t       (match_operand:SI 1 \"immediate_operand\" \"i,i\")\n+\t\t\t       (match_operand:SI 2 \"register_operand\" \"=&q,&!r\")] 0))\n+   (clobber (match_dup 2))]\n+  \"(TARGET_USE_ANY_REG && optimize > 1)\"\n+  \"* return output_strlen_unroll (operands);\")\n+\n+(define_insn \"strlensi_unroll5\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t\t   (unspec:SI [(mem:BLK (match_operand:SI 3 \"register_operand\" \"0\"))\n+\t\t\t       (match_operand:SI 1 \"immediate_operand\" \"i\")\n+\t\t\t       (match_operand:SI 2 \"register_operand\" \"=&q\")] 0))\n+   (clobber (match_dup 2))]\n+  \"(TARGET_USE_Q_REG && optimize > 1)\"\n+  \"* return output_strlen_unroll (operands);\")"}]}