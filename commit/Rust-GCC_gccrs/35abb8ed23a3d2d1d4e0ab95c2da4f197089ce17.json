{"sha": "35abb8ed23a3d2d1d4e0ab95c2da4f197089ce17", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzVhYmI4ZWQyM2EzZDJkMWQ0ZTBhYjk1YzJkYTRmMTk3MDg5Y2UxNw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2014-11-17T17:00:38Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2014-11-17T17:00:38Z"}, "message": "re PR c++/52282 ([C++0x] rejects-valid issues with decltype/constexpr)\n\n\tPR c++/52282\n\t* decl.c (build_ptrmemfunc_type): Don't build a different\n\tRECORD_TYPE for a qualified PMF.\n\t* cp-tree.h (TYPE_PTRMEMFUNC_FN_TYPE): Merge cv-quals.\n\t(TYPE_PTRMEMFUNC_FN_TYPE_RAW): New.\n\t* decl2.c (cplus_decl_attributes): Use TYPE_PTRMEMFUNC_FN_TYPE_RAW.\n\t* tree.c (cp_walk_subtrees): Likewise.\n\t(cp_build_qualified_type_real): Remove special PMF handling.\n\nFrom-SVN: r217660", "tree": {"sha": "af183c88efc573185903a522afb12f621645f17c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af183c88efc573185903a522afb12f621645f17c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35abb8ed23a3d2d1d4e0ab95c2da4f197089ce17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35abb8ed23a3d2d1d4e0ab95c2da4f197089ce17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35abb8ed23a3d2d1d4e0ab95c2da4f197089ce17", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35abb8ed23a3d2d1d4e0ab95c2da4f197089ce17/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "72a4a8b0bc09f7600e05887f25de2cf9422e9d43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72a4a8b0bc09f7600e05887f25de2cf9422e9d43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72a4a8b0bc09f7600e05887f25de2cf9422e9d43"}], "stats": {"total": 177, "additions": 123, "deletions": 54}, "files": [{"sha": "42521c9b767b94d2754093f52d19735e2d2251e5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35abb8ed23a3d2d1d4e0ab95c2da4f197089ce17/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35abb8ed23a3d2d1d4e0ab95c2da4f197089ce17/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=35abb8ed23a3d2d1d4e0ab95c2da4f197089ce17", "patch": "@@ -1,3 +1,14 @@\n+2014-11-17  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/52282\n+\t* decl.c (build_ptrmemfunc_type): Don't build a different\n+\tRECORD_TYPE for a qualified PMF.\n+\t* cp-tree.h (TYPE_PTRMEMFUNC_FN_TYPE): Merge cv-quals.\n+\t(TYPE_PTRMEMFUNC_FN_TYPE_RAW): New.\n+\t* decl2.c (cplus_decl_attributes): Use TYPE_PTRMEMFUNC_FN_TYPE_RAW.\n+\t* tree.c (cp_walk_subtrees): Likewise.\n+\t(cp_build_qualified_type_real): Remove special PMF handling.\n+\n 2014-11-15  Jason Merrill  <jason@redhat.com>\n \n \t* parser.c (cp_parser_omp_declare_reduction_exprs): A block is not"}, {"sha": "54f7e9b863396c7342974e8c118204e3222b86f6", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35abb8ed23a3d2d1d4e0ab95c2da4f197089ce17/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35abb8ed23a3d2d1d4e0ab95c2da4f197089ce17/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=35abb8ed23a3d2d1d4e0ab95c2da4f197089ce17", "patch": "@@ -3623,6 +3623,12 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n    pointer to member function.  TYPE_PTRMEMFUNC_P _must_ be true,\n    before using this macro.  */\n #define TYPE_PTRMEMFUNC_FN_TYPE(NODE) \\\n+  (cp_build_qualified_type (TREE_TYPE (TYPE_FIELDS (NODE)),\\\n+\t\t\t    cp_type_quals (NODE)))\n+\n+/* As above, but can be used in places that want an lvalue at the expense\n+   of not necessarily having the correct cv-qualifiers.  */\n+#define TYPE_PTRMEMFUNC_FN_TYPE_RAW(NODE) \\\n   (TREE_TYPE (TYPE_FIELDS (NODE)))\n \n /* Returns `A' for a type like `int (A::*)(double)' */"}, {"sha": "1f22c265b8c93fa37e9ae555a5a6a4bf0c2b8a04", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35abb8ed23a3d2d1d4e0ab95c2da4f197089ce17/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35abb8ed23a3d2d1d4e0ab95c2da4f197089ce17/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=35abb8ed23a3d2d1d4e0ab95c2da4f197089ce17", "patch": "@@ -8131,7 +8131,6 @@ build_ptrmemfunc_type (tree type)\n {\n   tree field, fields;\n   tree t;\n-  tree unqualified_variant = NULL_TREE;\n \n   if (type == error_mark_node)\n     return type;\n@@ -8145,9 +8144,11 @@ build_ptrmemfunc_type (tree type)\n \n   /* Make sure that we always have the unqualified pointer-to-member\n      type first.  */\n-  if (cp_type_quals (type) != TYPE_UNQUALIFIED)\n-    unqualified_variant\n-      = build_ptrmemfunc_type (TYPE_MAIN_VARIANT (type));\n+  if (cp_cv_quals quals = cp_type_quals (type))\n+    {\n+      tree unqual = build_ptrmemfunc_type (TYPE_MAIN_VARIANT (type));\n+      return cp_build_qualified_type (unqual, quals);\n+    }\n \n   t = make_node (RECORD_TYPE);\n \n@@ -8168,22 +8169,6 @@ build_ptrmemfunc_type (tree type)\n      information for this anonymous RECORD_TYPE.  */\n   TYPE_NAME (t) = NULL_TREE;\n \n-  /* If this is not the unqualified form of this pointer-to-member\n-     type, set the TYPE_MAIN_VARIANT for this type to be the\n-     unqualified type.  Since they are actually RECORD_TYPEs that are\n-     not variants of each other, we must do this manually.\n-     As we just built a new type there is no need to do yet another copy.  */\n-  if (cp_type_quals (type) != TYPE_UNQUALIFIED)\n-    {\n-      int type_quals = cp_type_quals (type);\n-      TYPE_READONLY (t) = (type_quals & TYPE_QUAL_CONST) != 0;\n-      TYPE_VOLATILE (t) = (type_quals & TYPE_QUAL_VOLATILE) != 0;\n-      TYPE_RESTRICT (t) = (type_quals & TYPE_QUAL_RESTRICT) != 0;\n-      TYPE_MAIN_VARIANT (t) = unqualified_variant;\n-      TYPE_NEXT_VARIANT (t) = TYPE_NEXT_VARIANT (unqualified_variant);\n-      TYPE_NEXT_VARIANT (unqualified_variant) = t;\n-    }\n-\n   /* Cache this pointer-to-member type so that we can find it again\n      later.  */\n   TYPE_SET_PTRMEMFUNC_TYPE (type, t);"}, {"sha": "fb8d0c82e40d794d28c3f374b913000949612486", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35abb8ed23a3d2d1d4e0ab95c2da4f197089ce17/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35abb8ed23a3d2d1d4e0ab95c2da4f197089ce17/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=35abb8ed23a3d2d1d4e0ab95c2da4f197089ce17", "patch": "@@ -1474,7 +1474,7 @@ cplus_decl_attributes (tree *decl, tree attributes, int flags)\n     {\n       attributes\n \t= decl_attributes (decl, attributes, flags | ATTR_FLAG_FUNCTION_NEXT);\n-      decl_attributes (&TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (*decl)),\n+      decl_attributes (&TYPE_PTRMEMFUNC_FN_TYPE_RAW (TREE_TYPE (*decl)),\n \t\t       attributes, flags);\n     }\n   else"}, {"sha": "4502273fb572ca440af5d5324bb3cb2fbc6d143d", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 33, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35abb8ed23a3d2d1d4e0ab95c2da4f197089ce17/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35abb8ed23a3d2d1d4e0ab95c2da4f197089ce17/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=35abb8ed23a3d2d1d4e0ab95c2da4f197089ce17", "patch": "@@ -1082,18 +1082,6 @@ cp_build_qualified_type_real (tree type,\n \t= TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TYPE_MAIN_VARIANT (element_type));\n       return t;\n     }\n-  else if (TYPE_PTRMEMFUNC_P (type))\n-    {\n-      /* For a pointer-to-member type, we can't just return a\n-\t cv-qualified version of the RECORD_TYPE.  If we do, we\n-\t haven't changed the field that contains the actual pointer to\n-\t a method, and so TYPE_PTRMEMFUNC_FN_TYPE will be wrong.  */\n-      tree t;\n-\n-      t = TYPE_PTRMEMFUNC_FN_TYPE (type);\n-      t = cp_build_qualified_type_real (t, type_quals, complain);\n-      return build_ptrmemfunc_type (t);\n-    }\n   else if (TREE_CODE (type) == TYPE_PACK_EXPANSION)\n     {\n       tree t = PACK_EXPANSION_PATTERN (type);\n@@ -1154,26 +1142,6 @@ cp_build_qualified_type_real (tree type,\n       result = build_ref_qualified_type (result, type_memfn_rqual (type));\n     }\n \n-  /* If this was a pointer-to-method type, and we just made a copy,\n-     then we need to unshare the record that holds the cached\n-     pointer-to-member-function type, because these will be distinct\n-     between the unqualified and qualified types.  */\n-  if (result != type\n-      && TYPE_PTR_P (type)\n-      && TREE_CODE (TREE_TYPE (type)) == METHOD_TYPE\n-      && TYPE_LANG_SPECIFIC (result) == TYPE_LANG_SPECIFIC (type))\n-    TYPE_LANG_SPECIFIC (result) = NULL;\n-\n-  /* We may also have ended up building a new copy of the canonical\n-     type of a pointer-to-method type, which could have the same\n-     sharing problem described above.  */\n-  if (TYPE_CANONICAL (result) != TYPE_CANONICAL (type)\n-      && TYPE_PTR_P (type)\n-      && TREE_CODE (TREE_TYPE (type)) == METHOD_TYPE\n-      && (TYPE_LANG_SPECIFIC (TYPE_CANONICAL (result)) \n-          == TYPE_LANG_SPECIFIC (TYPE_CANONICAL (type))))\n-    TYPE_LANG_SPECIFIC (TYPE_CANONICAL (result)) = NULL;\n-\n   return result;\n }\n \n@@ -3705,7 +3673,7 @@ cp_walk_subtrees (tree *tp, int *walk_subtrees_p, walk_tree_fn func,\n \n     case RECORD_TYPE:\n       if (TYPE_PTRMEMFUNC_P (*tp))\n-\tWALK_SUBTREE (TYPE_PTRMEMFUNC_FN_TYPE (*tp));\n+\tWALK_SUBTREE (TYPE_PTRMEMFUNC_FN_TYPE_RAW (*tp));\n       break;\n \n     case TYPE_ARGUMENT_PACK:"}, {"sha": "1ff835036c8dbe0e9ac65a77c22963076de3d448", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-decltype1.C", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35abb8ed23a3d2d1d4e0ab95c2da4f197089ce17/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-decltype1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35abb8ed23a3d2d1d4e0ab95c2da4f197089ce17/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-decltype1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-decltype1.C?ref=35abb8ed23a3d2d1d4e0ab95c2da4f197089ce17", "patch": "@@ -0,0 +1,99 @@\n+// PR c++/52282\n+// { dg-do run { target c++11 } }\n+\n+template <typename T, T V>\n+struct W { static constexpr T value() { return V; } };\n+\n+template <typename T, T V>\n+struct X { typedef T type; static constexpr type value() { return V; } };\n+\n+template <typename T, T V>\n+struct Y { using type = T; static constexpr type value() { return V; } };\n+\n+template <typename T, T V>\n+struct Z { static constexpr decltype(V) value() { return V; } };\n+\n+template <typename T, T V>\n+struct W_ { static constexpr T value = V; };\n+\n+template <typename T, T V>\n+struct X_ { typedef T type; static constexpr type value = V; };\n+\n+template <typename T, T V>\n+struct Y_ { using type = T; static constexpr type value = V; };\n+\n+template <typename T, T V>\n+struct Z_ { static constexpr decltype(V) value = V; };\n+\n+\n+static_assert(W<int, 10>::value() == 10, \"oops\");\n+static_assert(X<int, 10>::value() == 10, \"oops\");\n+static_assert(Y<int, 10>::value() == 10, \"oops\");\n+static_assert(Z<int, 10>::value() == 10, \"oops\");\n+static_assert(W_<int, 10>::value == 10, \"oops\");\n+static_assert(X_<int, 10>::value == 10, \"oops\");\n+static_assert(Y_<int, 10>::value == 10, \"oops\");\n+static_assert(Z_<int, 10>::value == 10, \"oops\");\n+\n+extern constexpr int a = 10;\n+static_assert(*W<const int*, &a>::value() == 10, \"oops\");\n+static_assert(*X<const int*, &a>::value() == 10, \"oops\");\n+static_assert(*Y<const int*, &a>::value() == 10, \"oops\");\n+static_assert(*Z<const int*, &a>::value() == 10, \"oops\");\t// ICE\n+static_assert(*W_<const int*, &a>::value == 10, \"oops\");\n+static_assert(*X_<const int*, &a>::value == 10, \"oops\");\n+static_assert(*Y_<const int*, &a>::value == 10, \"oops\");\n+static_assert(*Z_<const int*, &a>::value == 10, \"oops\");\t// ICE\n+\n+template <int V> constexpr int b() { return V; }\n+static_assert((W<int(*)(), &b<10>>::value())() == 10, \"oops\");\n+static_assert((X<int(*)(), &b<10>>::value())() == 10, \"oops\");\t// incorrect evaluation\n+static_assert((Y<int(*)(), &b<10>>::value())() == 10, \"oops\");\t// incorrect evaluation\n+static_assert((Z<int(*)(), &b<10>>::value())() == 10, \"oops\");\t// ICE\n+static_assert(W_<int(*)(), &b<10>>::value() == 10, \"oops\");\n+static_assert(X_<int(*)(), &b<10>>::value() == 10, \"oops\");\n+static_assert(Y_<int(*)(), &b<10>>::value() == 10, \"oops\");\n+static_assert(Z_<int(*)(), &b<10>>::value() == 10, \"oops\");\t// ICE\n+\n+constexpr struct C {\n+    constexpr int c1() const { return 10; }\n+    static constexpr int c2() { return 10; }\n+} c;\n+\n+static_assert((c.*W<int(C::*)()const, &C::c1>::value())() == 10, \"oops\");\n+static_assert((c.*X<int(C::*)()const, &C::c1>::value())() == 10, \"oops\");\n+static_assert((c.*Y<int(C::*)()const, &C::c1>::value())() == 10, \"oops\");\n+static_assert((c.*Z<int(C::*)()const, &C::c1>::value())() == 10, \"oops\");\n+static_assert((c.*W_<int(C::*)()const, &C::c1>::value)() == 10, \"oops\");\t// incorrect evaluation\n+static_assert((c.*X_<int(C::*)()const, &C::c1>::value)() == 10, \"oops\");\t// incorrect evaluation\n+static_assert((c.*Y_<int(C::*)()const, &C::c1>::value)() == 10, \"oops\");\t// incorrect evaluation\n+static_assert((c.*Z_<int(C::*)()const, &C::c1>::value)() == 10, \"oops\");\t// incorrect evaluation\n+\n+static_assert((W<int(*)(), &C::c2>::value())() == 10, \"oops\");\n+static_assert((X<int(*)(), &C::c2>::value())() == 10, \"oops\");\t// incorrect evaluation\n+static_assert((Y<int(*)(), &C::c2>::value())() == 10, \"oops\");\t// incorrect evaluation\n+static_assert((Z<int(*)(), &C::c2>::value())() == 10, \"oops\");\t// ICE\n+static_assert(W_<int(*)(), &C::c2>::value() == 10, \"oops\");\n+static_assert(X_<int(*)(), &C::c2>::value() == 10, \"oops\");\n+static_assert(Y_<int(*)(), &C::c2>::value() == 10, \"oops\");\n+static_assert(Z_<int(*)(), &C::c2>::value() == 10, \"oops\");\t// ICE\n+\n+\n+#include <assert.h>\n+\n+template <typename T, T V>\n+constexpr typename X_<T, V>::type X_<T, V>::value;\n+\n+int main() {\n+  C c;\n+\n+  // correctly evaluates inside method scope\n+  int t1 = X<int(*)(), &b<10>>::value()();\n+  int t2 = (c.*X_<int(C::*)()const, &C::c1>::value)();\n+  int t3 = X<int(*)(), &C::c2>::value()();\n+\n+  assert(t1 == 10);\n+  assert(t2 == 10);\n+  assert(t3 == 10);\n+  return 0;\n+}"}]}