{"sha": "770da0766ad9701326509b5cd05c0425fb7f7e76", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzcwZGEwNzY2YWQ5NzAxMzI2NTA5YjVjZDA1YzA0MjVmYjdmN2U3Ng==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2013-09-05T20:28:36Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2013-09-05T20:28:36Z"}, "message": "tree-ssa-threadedge.c (thread_around_empty_blocks): Renamed from thread_around_empty_block.\n\n       * tree-ssa-threadedge.c (thread_around_empty_blocks): Renamed\n       from thread_around_empty_block.  Record threading path into PATH.\n       Recurse if threading through the initial block is successful.\n       (thread_across_edge): Corresponding changes to slightly simplify.\n\nFrom-SVN: r202296", "tree": {"sha": "d1c4112a8160886b5168cbb7639b00d4d89b7662", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1c4112a8160886b5168cbb7639b00d4d89b7662"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/770da0766ad9701326509b5cd05c0425fb7f7e76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/770da0766ad9701326509b5cd05c0425fb7f7e76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/770da0766ad9701326509b5cd05c0425fb7f7e76", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/770da0766ad9701326509b5cd05c0425fb7f7e76/comments", "author": null, "committer": null, "parents": [{"sha": "fe6f68e2bb8ba87612605cc0f6b55b188f002491", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe6f68e2bb8ba87612605cc0f6b55b188f002491", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe6f68e2bb8ba87612605cc0f6b55b188f002491"}], "stats": {"total": 165, "additions": 88, "deletions": 77}, "files": [{"sha": "ce0e39d88bb6d3f02f7957fe566298fd3f985363", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/770da0766ad9701326509b5cd05c0425fb7f7e76/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/770da0766ad9701326509b5cd05c0425fb7f7e76/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=770da0766ad9701326509b5cd05c0425fb7f7e76", "patch": "@@ -1,3 +1,10 @@\n+2013-09-05  Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-threadedge.c (thread_around_empty_blocks): Renamed\n+\tfrom thread_around_empty_block.  Record threading path into PATH.\n+\tRecurse if threading through the initial block is successful.\n+\t(thread_across_edge): Corresponding changes to slightly simplify.\n+\n 2013-09-05  James Greenhalgh  <james.greenhalgh@arm.com>\n \n \t* config/aarch64/aarch64.md"}, {"sha": "afdd0afe6d6af78ef97ba379bd448575e14b6a24", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 81, "deletions": 77, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/770da0766ad9701326509b5cd05c0425fb7f7e76/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/770da0766ad9701326509b5cd05c0425fb7f7e76/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=770da0766ad9701326509b5cd05c0425fb7f7e76", "patch": "@@ -738,46 +738,68 @@ propagate_threaded_block_debug_into (basic_block dest, basic_block src)\n     fewvars.release ();\n }\n \n-/* TAKEN_EDGE represents the an edge taken as a result of jump threading.\n-   See if we can thread around TAKEN_EDGE->dest as well.  If so, return\n-   the edge out of TAKEN_EDGE->dest that we can statically compute will be\n-   traversed.\n-\n-   We are much more restrictive as to the contents of TAKEN_EDGE->dest\n-   as the path isolation code in tree-ssa-threadupdate.c isn't prepared\n-   to handle copying intermediate blocks on a threaded path. \n-\n-   Long term a more consistent and structured approach to path isolation\n-   would be a huge help.   */\n-static edge\n-thread_around_empty_block (edge taken_edge,\n-\t\t\t   gimple dummy_cond,\n-\t\t\t   bool handle_dominating_asserts,\n-\t\t\t   tree (*simplify) (gimple, gimple),\n-\t\t\t   bitmap visited)\n+/* See if TAKEN_EDGE->dest is a threadable block with no side effecs (ie, it\n+   need not be duplicated as part of the CFG/SSA updating process).\n+\n+   If it is threadable, add it to PATH and VISITED and recurse, ultimately\n+   returning TRUE from the toplevel call.   Otherwise do nothing and\n+   return false.\n+\n+   DUMMY_COND, HANDLE_DOMINATING_ASSERTS and SIMPLIFY are used to\n+   try and simplify the condition at the end of TAKEN_EDGE->dest.  */\n+static bool\n+thread_around_empty_blocks (edge taken_edge,\n+\t\t\t    gimple dummy_cond,\n+\t\t\t    bool handle_dominating_asserts,\n+\t\t\t    tree (*simplify) (gimple, gimple),\n+\t\t\t    bitmap visited,\n+\t\t\t    vec<edge> *path)\n {\n   basic_block bb = taken_edge->dest;\n   gimple_stmt_iterator gsi;\n   gimple stmt;\n   tree cond;\n \n-  /* This block can have no PHI nodes.  This is overly conservative.  */\n+  /* The key property of these blocks is that they need not be duplicated\n+     when threading.  Thus they can not have visible side effects such\n+     as PHI nodes.  */\n   if (!gsi_end_p (gsi_start_phis (bb)))\n     return NULL;\n \n   /* Skip over DEBUG statements at the start of the block.  */\n   gsi = gsi_start_nondebug_bb (bb);\n \n+  /* If the block has no statements, but does have a single successor, then\n+     it's just a forwarding block and we can thread through it trivially.  */\n   if (gsi_end_p (gsi))\n-    return NULL;\n+    {\n+      if (single_succ_p (bb))\n+\t{\n+\t  taken_edge = single_succ_edge (bb);\n+\t  if ((taken_edge->flags & EDGE_DFS_BACK) == 0\n+\t      && !bitmap_bit_p (visited, taken_edge->dest->index))\n+\t    {\n+\t      bitmap_set_bit (visited, taken_edge->dest->index);\n+\t      path->safe_push (taken_edge);\n+\t      thread_around_empty_blocks (taken_edge,\n+\t\t\t\t\t  dummy_cond,\n+\t\t\t\t\t  handle_dominating_asserts,\n+\t\t\t\t\t  simplify,\n+\t\t\t\t\t  visited,\n+\t\t\t\t\t  path);\n+\t      return true;\n+\t    }\n+\t}\n+      return false;\n+    }\n \n-  /* This block can have no statements other than its control altering\n-     statement.  This is overly conservative.  */\n+  /* The only real statements this block can have are a control\n+     flow altering statement.  Anything else stops the thread.  */\n   stmt = gsi_stmt (gsi);\n   if (gimple_code (stmt) != GIMPLE_COND\n       && gimple_code (stmt) != GIMPLE_GOTO\n       && gimple_code (stmt) != GIMPLE_SWITCH)\n-    return NULL;\n+    return false;\n \n   /* Extract and simplify the condition.  */\n   cond = simplify_control_stmt_condition (taken_edge, stmt, dummy_cond,\n@@ -788,15 +810,22 @@ thread_around_empty_block (edge taken_edge,\n      path.  */\n   if (cond && is_gimple_min_invariant (cond))\n     {\n-      edge taken_edge = find_taken_edge (bb, cond);\n+      taken_edge = find_taken_edge (bb, cond);\n \n       if (bitmap_bit_p (visited, taken_edge->dest->index))\n-\treturn NULL;\n+\treturn false;\n       bitmap_set_bit (visited, taken_edge->dest->index);\n-      return taken_edge;\n+      path->safe_push (taken_edge);\n+      thread_around_empty_blocks (taken_edge,\n+\t\t\t\t  dummy_cond,\n+\t\t\t\t  handle_dominating_asserts,\n+\t\t\t\t  simplify,\n+\t\t\t\t  visited,\n+\t\t\t\t  path);\n+      return true;\n     }\n  \n-  return NULL;\n+  return false;\n }\n       \n /* E1 and E2 are edges into the same basic block.  Return TRUE if the\n@@ -896,51 +925,40 @@ thread_across_edge (gimple dummy_cond,\n \t  edge taken_edge = find_taken_edge (e->dest, cond);\n \t  basic_block dest = (taken_edge ? taken_edge->dest : NULL);\n \t  bitmap visited;\n-\t  edge e2;\n \n-\t  if (dest == e->dest)\n+\t  /* DEST could be NULL for a computed jump to an absolute\n+\t     address.  */\n+\t  if (dest == NULL || dest == e->dest)\n \t    goto fail;\n \n \t  vec<edge> path = vNULL;\n \t  path.safe_push (e);\n \t  path.safe_push (taken_edge);\n \n-\t  /* DEST could be null for a computed jump to an absolute\n-\t     address.  If DEST is not null, then see if we can thread\n-\t     through it as well, this helps capture secondary effects\n-\t     of threading without having to re-run DOM or VRP.  */\n-\t  if (dest\n-\t      && ((e->flags & EDGE_DFS_BACK) == 0\n-\t\t  || ! cond_arg_set_in_bb (taken_edge, e->dest)))\n+\t  /* See if we can thread through DEST as well, this helps capture\n+\t     secondary effects of threading without having to re-run DOM or\n+\t     VRP.  */\n+\t  if ((e->flags & EDGE_DFS_BACK) == 0\n+\t       || ! cond_arg_set_in_bb (taken_edge, e->dest))\n \t    {\n \t      /* We don't want to thread back to a block we have already\n  \t\t visited.  This may be overly conservative.  */\n \t      visited = BITMAP_ALLOC (NULL);\n \t      bitmap_set_bit (visited, dest->index);\n \t      bitmap_set_bit (visited, e->dest->index);\n-\t      do\n-\t\t{\n-\t\t  e2 = thread_around_empty_block (taken_edge,\n-\t\t\t\t\t\t  dummy_cond,\n-\t\t\t\t\t\t  handle_dominating_asserts,\n-\t\t\t\t\t\t  simplify,\n-\t\t\t\t\t\t  visited);\n-\t\t  if (e2)\n-\t\t    {\n-\t\t      taken_edge = e2;\n-\t\t      path.safe_push (e2);\n-\t\t    }\n-\t\t}\n-\t      while (e2);\n+\t      thread_around_empty_blocks (taken_edge,\n+\t\t\t\t\t  dummy_cond,\n+\t\t\t\t\t  handle_dominating_asserts,\n+\t\t\t\t\t  simplify,\n+\t\t\t\t\t  visited,\n+\t\t\t\t\t  &path);\n \t      BITMAP_FREE (visited);\n \t    }\n \n \t  remove_temporary_equivalences (stack);\n-\t  if (taken_edge)\n-\t    {\n-\t      propagate_threaded_block_debug_into (taken_edge->dest, e->dest);\n-\t      register_jump_thread (path, false);\n-\t    }\n+\t  propagate_threaded_block_debug_into (path[path.length () - 1]->dest,\n+\t\t\t\t\t       e->dest);\n+\t  register_jump_thread (path, false);\n \t  path.release ();\n \t  return;\n \t}\n@@ -958,7 +976,7 @@ thread_across_edge (gimple dummy_cond,\n     This is a stopgap until we have a more structured approach to path\n     isolation.  */\n   {\n-    edge e2, e3, taken_edge;\n+    edge taken_edge;\n     edge_iterator ei;\n     bool found = false;\n     bitmap visited = BITMAP_ALLOC (NULL);\n@@ -976,28 +994,14 @@ thread_across_edge (gimple dummy_cond,\n \t   of E->dest.  */\n \tpath.safe_push (e);\n \tpath.safe_push (taken_edge);\n-\tfound = false;\n-\te3 = taken_edge;\n-\tdo\n-\t  {\n-\t    if ((e->flags & EDGE_DFS_BACK) == 0\n-\t\t|| ! cond_arg_set_in_bb (e3, e->dest))\n-\t      e2 = thread_around_empty_block (e3,\n+\tif ((e->flags & EDGE_DFS_BACK) == 0\n+\t    || ! cond_arg_set_in_bb (path[path.length () - 1], e->dest))\n+\t  found = thread_around_empty_blocks (taken_edge,\n \t\t\t\t\t      dummy_cond,\n \t\t\t\t\t      handle_dominating_asserts,\n \t\t\t\t\t      simplify,\n-\t\t\t\t\t      visited);\n-\t    else\n-\t      e2 = NULL;\n-\n-\t    if (e2)\n-\t      {\n-\t\tpath.safe_push (e2);\n-\t        e3 = e2;\n-\t\tfound = true;\n-\t      }\n-\t  }\n-        while (e2);\n+\t\t\t\t\t      visited,\n+\t\t\t\t\t      &path);\n \n \t/* If we were able to thread through a successor of E->dest, then\n \t   record the jump threading opportunity.  */\n@@ -1008,10 +1012,10 @@ thread_across_edge (gimple dummy_cond,\n \t       (E2->src) to the final target (E3->dest), then make sure that\n \t       the PHI args associated with the edges E2 and E3 are the\n \t       same.  */\n-\t    tmp = find_edge (taken_edge->src, e3->dest);\n-\t    if (!tmp || phi_args_equal_on_edges (tmp, e3))\n+\t    tmp = find_edge (taken_edge->src, path[path.length () - 1]->dest);\n+\t    if (!tmp || phi_args_equal_on_edges (tmp, path[path.length () - 1]))\n \t      {\n-\t\tpropagate_threaded_block_debug_into (e3->dest,\n+\t\tpropagate_threaded_block_debug_into (path[path.length () - 1]->dest,\n \t\t\t\t\t\t     taken_edge->dest);\n \t\tregister_jump_thread (path, true);\n \t      }"}]}