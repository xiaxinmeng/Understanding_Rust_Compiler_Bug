{"sha": "c516c1ff9be00d5193f3928482e7cec720d3d717", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzUxNmMxZmY5YmUwMGQ1MTkzZjM5Mjg0ODJlN2NlYzcyMGQzZDcxNw==", "commit": {"author": {"name": "Ranjit Mathew", "email": "rmathew@hotmail.com", "date": "2004-07-04T15:19:16Z"}, "committer": {"name": "Ranjit Mathew", "email": "rmathew@gcc.gnu.org", "date": "2004-07-04T15:19:16Z"}, "message": "verify.c: Insert a short blurb at the start referring to the JVMS.\n\n\t* verify.c: Insert a short blurb at the start referring to the JVMS.\n\tMinor formatting fixes all over the place.\n\t(merge_type_state): Remove redundant nested if statement.\n\t(verify_jvm_instructions): Ensure current_subr is initialised to\n\tNULL_TREE.\n\nCii: Enter Log.  Lines beginning with `CVS:' are removed automaticalli\n\nFrom-SVN: r84084", "tree": {"sha": "83e6aa83d22e8a455bd96e59293ed115a1c0c95b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83e6aa83d22e8a455bd96e59293ed115a1c0c95b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c516c1ff9be00d5193f3928482e7cec720d3d717", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c516c1ff9be00d5193f3928482e7cec720d3d717", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c516c1ff9be00d5193f3928482e7cec720d3d717", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c516c1ff9be00d5193f3928482e7cec720d3d717/comments", "author": null, "committer": null, "parents": [{"sha": "b75941cbaa3e704709f1985169405d3e6efd9392", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b75941cbaa3e704709f1985169405d3e6efd9392", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b75941cbaa3e704709f1985169405d3e6efd9392"}], "stats": {"total": 321, "additions": 213, "deletions": 108}, "files": [{"sha": "638aa9db2b3676566aa16f9bcd4f5c3abbf82e17", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c516c1ff9be00d5193f3928482e7cec720d3d717/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c516c1ff9be00d5193f3928482e7cec720d3d717/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=c516c1ff9be00d5193f3928482e7cec720d3d717", "patch": "@@ -1,3 +1,11 @@\n+2004-07-04  Ranjit Mathew  <rmathew@hotmail.com>\n+\n+\t* verify.c: Insert a short blurb at the start referring to the JVMS.\n+\t(merge_type_state): Remove redundant nested if statement.\n+\t(verify_jvm_instructions): Ensure current_subr is initialised to\n+\tNULL_TREE.\n+\tMinor formatting fixes all over the place.\n+\n 2004-07-02  Richard Henderson  <rth@redhat.com>\n \n \t* jcf-write.c (generate_bytecode_insns <case SAVE_EXPR>): Rewrite."}, {"sha": "750c51780c75d19f239f6436f97da8ed3bd004d8", "filename": "gcc/java/verify.c", "status": "modified", "additions": 205, "deletions": 108, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c516c1ff9be00d5193f3928482e7cec720d3d717/gcc%2Fjava%2Fverify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c516c1ff9be00d5193f3928482e7cec720d3d717/gcc%2Fjava%2Fverify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fverify.c?ref=c516c1ff9be00d5193f3928482e7cec720d3d717", "patch": "@@ -24,6 +24,11 @@ Java and all Java-based marks are trademarks or registered trademarks\n of Sun Microsystems, Inc. in the United States and other countries.\n The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n \n+/* This bytecode verifier is an implementation of the bytecode\n+verification process described in section 4.9 of \"The Java(TM) Virtual\n+Machine Specification\", Second Edition, by Tim Lindholm and Frank Yellin,\n+published by Addison-Wesley in 1999.  */\n+\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n@@ -82,7 +87,7 @@ check_pending_block (tree target_label)\n       push_pending_label (target_label);\n     }\n \n-  if (current_subr == NULL)\n+  if (current_subr == NULL_TREE)\n     {\n       if (LABEL_IN_SUBR (target_label))\n \treturn \"might transfer control into subroutine\";\n@@ -113,7 +118,7 @@ subroutine_nesting (tree label)\n   int nesting = 0;\n   while (label != NULL_TREE && LABEL_IN_SUBR (label))\n     {\n-      if (! LABEL_IS_SUBR_START(label))\n+      if (! LABEL_IS_SUBR_START (label))\n \tlabel = LABEL_SUBR_START (label);\n       label = LABEL_SUBR_CONTEXT (label);\n       nesting++;\n@@ -250,11 +255,9 @@ merge_type_state (tree label)\n   tree return_map;\n   if (vec == NULL_TREE)\n     {\n-      if (!vec)\n-\t{\n-\t  vec = make_tree_vec (cur_length);\n-\t  LABEL_TYPE_STATE (label) = vec;\n-\t}\n+      vec = make_tree_vec (cur_length);\n+      LABEL_TYPE_STATE (label) = vec;\n+\n       while (--cur_length >= 0)\n \tTREE_VEC_ELT (vec, cur_length) = type_map [cur_length];\n       return 1;\n@@ -281,7 +284,7 @@ merge_type_state (tree label)\n \t      /* If there has been a change, note that since we must re-verify.\n \t\t However, if the label is the start of a subroutine,\n \t\t we don't care about local variables that are neither\n-\t\t set nor used in the sub-routine. */\n+\t\t set nor used in the subroutine. */\n \t      if (return_map == NULL_TREE || i >= nlocals\n \t\t  || TREE_VEC_ELT (return_map, i) != TYPE_UNUSED\n \t\t  || (TYPE_IS_WIDE (new_type)\n@@ -306,33 +309,33 @@ merge_type_state (tree label)\n static void\n type_stack_dup (int size, int offset)\n {\n-  tree type[4];\n+  tree type [4];\n   int index;\n   for (index = 0;  index < size + offset; index++)\n     {\n-      type[index] = stack_type_map[stack_pointer - 1];\n-      if (type[index] == void_type_node)\n+      type [index] = stack_type_map [stack_pointer - 1];\n+      if (type [index] == void_type_node)\n \t{\n \t  index++;\n-\t  type[index] = stack_type_map[stack_pointer - 2];\n-\t  if (! TYPE_IS_WIDE (type[index]))\n+\t  type [index] = stack_type_map [stack_pointer - 2];\n+\t  if (! TYPE_IS_WIDE (type [index]))\n \t    abort ();\n \t  if (index == size || index == size + offset)\n \t    /* Dup operation splits 64-bit number.  */\n \t    abort ();\n \t}\n-      pop_type (type[index]);\n+      pop_type (type [index]);\n     }\n   for (index = size;  --index >= 0; )\n     {\n-      if (type[index] != void_type_node)\n-\tpush_type (type[index]);\n+      if (type [index] != void_type_node)\n+\tpush_type (type [index]);\n     }\n \n   for (index = size + offset;  --index >= 0; )\n     {\n-      if (type[index] != void_type_node)\n-\tpush_type (type[index]);\n+      if (type [index] != void_type_node)\n+\tpush_type (type [index]);\n     }\n }\n \n@@ -437,7 +440,9 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \n   pending_blocks = NULL_TREE;\n \n-  /* Handle the exception table. */\n+  current_subr = NULL_TREE;\n+\n+  /* Handle the exception table.  */\n   method_init_exceptions ();\n   JCF_SEEK (jcf, DECL_CODE_OFFSET (current_function_decl) + length);\n   eh_count = JCF_readu2 (jcf);\n@@ -447,16 +452,16 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n   starts = xmalloc (eh_count * sizeof (struct pc_index));\n   for (i = 0; i < eh_count; ++i)\n     {\n-      starts[i].start_pc = GET_u2 (jcf->read_ptr + 8 * i);\n-      starts[i].index = i;\n+      starts [i].start_pc = GET_u2 (jcf->read_ptr + 8 * i);\n+      starts [i].index = i;\n     }\n   qsort (starts, eh_count, sizeof (struct pc_index), start_pc_cmp);\n \n   for (i = 0; i < eh_count; ++i)\n     {\n       int start_pc, end_pc, handler_pc, catch_type;\n \n-      p = jcf->read_ptr + 8 * starts[i].index;\n+      p = jcf->read_ptr + 8 * starts [i].index;\n \n       start_pc = GET_u2 (p);\n       end_pc = GET_u2 (p+2);\n@@ -490,64 +495,69 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n   for (PC = 0;;)\n     {\n       tree type, tmp;\n+\n       if (((PC != INVALID_PC\n \t   && instruction_bits [PC] & BCODE_TARGET) != 0)\n \t  || PC == 0)\n \t{\n \t  PUSH_PENDING (lookup_label (PC));\n \t  INVALIDATE_PC;\n \t}\n+\n       /* Check if there are any more pending blocks in the current\n \t subroutine.  Because we push pending blocks in a\n \t last-in-first-out order, and because we don't push anything\n \t from our caller until we are done with this subroutine or\n-\t anything nested in it, then we are done if the top of the\n+\t anything nested in it, we are done if the top of the\n \t pending_blocks stack is not in a subroutine, or it is in our\n \t caller. */\n-      if (current_subr \n-\t  && PC == INVALID_PC)\n+      if (current_subr && PC == INVALID_PC)\n \t{\n \t  if (pending_blocks == NULL_TREE\n \t      || (subroutine_nesting (pending_blocks)\n \t\t  < subroutine_nesting (current_subr)))\n \t    {\n-\t      int size = DECL_MAX_LOCALS(current_function_decl)+stack_pointer;\n+\t      int size\n+                = DECL_MAX_LOCALS (current_function_decl) + stack_pointer;\n+\n \t      tree ret_map = LABEL_RETURN_TYPE_STATE (current_subr);\n \t      tmp = LABEL_RETURN_LABELS (current_subr);\n \t      \n \t      /* FIXME: If we exit a subroutine via a throw, we might\n \t\t have returned to an earlier caller.  Obviously a\n \t\t \"ret\" can only return one level, but a throw may\n-\t\t return many levels.*/\n+\t\t return many levels.  */\n \t      current_subr = LABEL_SUBR_CONTEXT (current_subr);\n \n \t      if (RETURN_MAP_ADJUSTED (ret_map))\n \t\t{\n-\t\t  /* Since we are done with this subroutine , set up\n+\t\t  /* Since we are done with this subroutine, set up\n \t\t     the (so far known) return address as pending -\n-\t\t     with the merged type state. */\n+\t\t     with the merged type state.  */\n \t\t  for ( ; tmp != NULL_TREE;  tmp = TREE_CHAIN (tmp))\n \t\t    {\n \t\t      tree return_label = TREE_VALUE (tmp);\n \t\t      tree return_state = LABEL_TYPE_STATE (return_label);\n \t\t      if (return_state == NULL_TREE)\n \t\t\t{\n-\t\t\t  /* This means means we had not verified the\n-\t\t\t     subroutine earlier, so this is the first jsr to\n-\t\t\t     call it.  In this case, the type_map of the return\n+\t\t\t  /* This means we had not verified the subroutine\n+                             earlier, so this is the first jsr to call it.\n+                             In this case, the type_map of the return\n \t\t\t     address is just the current type_map - and that\n-\t\t\t     is handled by the following PUSH_PENDING. */\n+\t\t\t     is handled by the following PUSH_PENDING.  */\n \t\t\t}\n \t\t      else\n \t\t\t{\n \t\t\t  /* In this case we have to do a merge.  But first\n \t\t\t     restore the type_map for unused slots to those\n-\t\t\t     that were in effect at the jsr. */\n-\t\t\t  for (index = size;  --index >= 0; )\n+\t\t\t     that were in effect at the jsr.  */\n+\t\t\t  for (index = size; --index >= 0; )\n \t\t\t    {\n-\t\t\t      type_map[index] = TREE_VEC_ELT (ret_map, index);\n-\t\t\t      if (type_map[index] == TYPE_UNUSED)\n-\t\t\t\ttype_map[index]\n+\t\t\t      type_map [index]\n+                                = TREE_VEC_ELT (ret_map, index);\n+\n+\t\t\t      if (type_map [index] == TYPE_UNUSED)\n+\t\t\t\ttype_map [index]\n \t\t\t\t  = TREE_VEC_ELT (return_state, index);\n \t\t\t    }\n \t\t\t}\n@@ -556,11 +566,14 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t\t}\n \t    }\n \t}\n+\n       if (PC == INVALID_PC)\n \t{\n \t  label = pending_blocks;\n+\n \t  if (label == NULL_TREE)\n \t    break;  /* We're done! */\n+\n \t  pending_blocks = LABEL_PENDING_CHAIN (label);\n \t  LABEL_CHANGED (label) = 0;\n \n@@ -571,52 +584,60 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \n \t  /* Restore type_map and stack_pointer from\n \t     LABEL_TYPE_STATE (label), and continue\n-\t     compiling from there. */\n+\t     compiling from there.  */\n \t  load_type_state (label);\n+\n \t  PC = LABEL_PC (label);\n \t}\n       else if (PC >= length)\n-\tVERIFICATION_ERROR (\"falling through end of method\");\n+\tVERIFICATION_ERROR (\"falling through the end of the method\");\n \n-      /* fprintf (stderr, \"** %d\\n\", PC); */\n \n       oldpc = PC;\n \n-      if (!(instruction_bits [PC] & BCODE_INSTRUCTION_START) && ! wide)\n+      if (! (instruction_bits [PC] & BCODE_INSTRUCTION_START) && ! wide)\n \tVERIFICATION_ERROR (\"PC not at instruction start\");\n \n-      instruction_bits[PC] |= BCODE_VERIFIED;\n+      instruction_bits [PC] |= BCODE_VERIFIED;\n \n       eh_ranges = find_handler (oldpc);\n \n-      op_code = byte_ops[PC++];\n+      op_code = byte_ops [PC++];\n       switch (op_code)\n \t{\n \t  int is_static, is_putting;\n+\n \tcase OPCODE_nop:\n \t  break;\n+\n \tcase OPCODE_iconst_m1:\n \tcase OPCODE_iconst_0:\tcase OPCODE_iconst_1:\tcase OPCODE_iconst_2:\n \tcase OPCODE_iconst_3:\tcase OPCODE_iconst_4:\tcase OPCODE_iconst_5:\n \t  i = op_code - OPCODE_iconst_0;\n \t  goto push_int;\n \tpush_int:\n-\t  if (byte_ops[PC] == OPCODE_newarray\n-\t      || byte_ops[PC] == OPCODE_anewarray)\n+\t  if (byte_ops [PC] == OPCODE_newarray\n+\t      || byte_ops [PC] == OPCODE_anewarray)\n \t    int_value = i;\n \t  PUSH_TYPE (int_type_node);  break;\n+\n \tcase OPCODE_lconst_0:\tcase OPCODE_lconst_1:\n \t  PUSH_TYPE (long_type_node);  break;\n+\n \tcase OPCODE_fconst_0:\tcase OPCODE_fconst_1:\tcase OPCODE_fconst_2:\n \t  PUSH_TYPE (float_type_node);  break;\n+\n \tcase OPCODE_dconst_0:\tcase OPCODE_dconst_1:\n \t  PUSH_TYPE (double_type_node);  break;\n+\n \tcase OPCODE_bipush:\n \t  i = IMMEDIATE_s1;\n \t  goto push_int;\n+\n \tcase OPCODE_sipush:\n \t  i = IMMEDIATE_s2;\n \t  goto push_int;\n+\n \tcase OPCODE_iload:  type = int_type_node;  goto general_load;\n \tcase OPCODE_lload:  type = long_type_node;  goto general_load;\n \tcase OPCODE_fload:  type = float_type_node;  goto general_load;\n@@ -652,13 +673,13 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t\t>= DECL_MAX_LOCALS (current_function_decl)))\n \t  VERIFICATION_ERROR_WITH_INDEX\n \t    (\"invalid local variable index %d in load\");\n-\ttmp = type_map[index];\n+\ttmp = type_map [index];\n \tif (tmp == TYPE_UNKNOWN)\n \t  VERIFICATION_ERROR_WITH_INDEX\n \t    (\"loading local variable %d which has unknown type\");\n \telse if (tmp == TYPE_SECOND\n \t    || (TYPE_IS_WIDE (type)\n-\t\t&& type_map[index+1] != void_type_node)\n+\t\t&& type_map [index+1] != void_type_node)\n \t    || (type == ptr_type_node\n \t\t? TREE_CODE (tmp) != POINTER_TYPE\n \t\t: type == int_type_node\n@@ -707,21 +728,23 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t    return 0;\n \t  }\n \tPOP_TYPE_CONV (type, type, NULL);\n-\ttype_map[index] = type;\n+\ttype_map [index] = type;\n \n-\t/* If local variable changed, we need to reconsider eh handlers. */\n+\t/* If a local variable has changed, we need to reconsider exception\n+        handlers.  */\n \tprev_eh_ranges = NULL_EH_RANGE;\n \n \t/* Allocate decl and rtx for this variable now, so if we're not\n-\t   optimizing, we get a temporary that survives the whole method. */\n+\t   optimizing, we get a temporary that survives the whole method.  */\n \tfind_local_variable (index, type, oldpc);\n \n         if (TYPE_IS_WIDE (type))\n-          type_map[index+1] = TYPE_SECOND;\n+          type_map [index+1] = TYPE_SECOND;\n+\n \t/* ... fall through to note_used ... */\n \tnote_used:\n \t  /* For store or load, note that local variable INDEX is used.\n-\t     This is needed to verify try-finally sub-routines. */\n+\t     This is needed to verify try-finally subroutines. */\n \t  if (current_subr)\n \t    {\n \t      tree vec = LABEL_RETURN_TYPE_STATE (current_subr);\n@@ -772,33 +795,38 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t  type = double_type_node;  goto binop;\n \tcase OPCODE_dneg:\n \t  type = double_type_node;  goto unop;\n+\n \tunop:\n \t  pop_type (type);\n \t  PUSH_TYPE (type);\n \t  break;\n+\n \tbinop:\n \t  pop_type (type);\n \t  pop_type (type);\n \t  PUSH_TYPE (type);\n \t  break;\n+\n \tcase OPCODE_lshl:\n \tcase OPCODE_lshr:\n \tcase OPCODE_lushr:\n \t  pop_type (int_type_node);\n \t  pop_type (long_type_node);\n \t  PUSH_TYPE (long_type_node);\n \t  break;\n+\n \tcase OPCODE_iinc:\n \t  index = wide ? IMMEDIATE_u2 : IMMEDIATE_u1;\n \t  PC += wide + 1;\n \t  wide = 0;\n \t  if (index < 0 || index >= DECL_MAX_LOCALS (current_function_decl))\n \t    VERIFICATION_ERROR (\"invalid local variable index in iinc\");\n-\t  tmp = type_map[index];\n+\t  tmp = type_map [index];\n \t  if (tmp == NULL_TREE\n \t      || ! INTEGRAL_TYPE_P (tmp) || TYPE_PRECISION (tmp) > 32)\n \t    VERIFICATION_ERROR (\"invalid local variable type in iinc\");\n \t  break;\n+\n \tcase OPCODE_i2l:\n \t  pop_type (int_type_node);    PUSH_TYPE (long_type_node);   break;\n \tcase OPCODE_i2f:\n@@ -823,6 +851,7 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t  pop_type (double_type_node); PUSH_TYPE (long_type_node);   break;\n \tcase OPCODE_d2f:\n \t  pop_type (double_type_node); PUSH_TYPE (float_type_node);  break;\n+\n \tcase OPCODE_lcmp:\n \t  type = long_type_node;  goto compare;\n \tcase OPCODE_fcmpl:\n@@ -834,6 +863,7 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \tcompare:\n \t  pop_type (type);  pop_type (type);\n \t  PUSH_TYPE (int_type_node);  break;\n+\n \tcase OPCODE_ifeq:\n \tcase OPCODE_ifne:\n \tcase OPCODE_iflt:\n@@ -855,15 +885,18 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \tcase OPCODE_if_acmpne:\n \t  pop_type (object_ptr_type_node);  pop_type (object_ptr_type_node);\n \t  goto cond;\n+\n \tcond:\n \t  PUSH_PENDING (lookup_label (oldpc + IMMEDIATE_s2));\n \t  break;\n+          \n \tcase OPCODE_goto:\n \t  PUSH_PENDING (lookup_label (oldpc + IMMEDIATE_s2));\n \t  INVALIDATE_PC;\n \t  break;\n+\n \tcase OPCODE_wide:\n-\t  switch (byte_ops[PC])\n+\t  switch (byte_ops [PC])\n \t    {\n \t    case OPCODE_iload:  case OPCODE_lload:\n \t    case OPCODE_fload:  case OPCODE_dload:  case OPCODE_aload:\n@@ -877,6 +910,7 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t      VERIFICATION_ERROR (\"invalid use of wide instruction\");\n \t    }\n \t  break;\n+\n \tcase OPCODE_return:   type = void_type_node;   goto ret;\n \tcase OPCODE_ireturn:\n \t  if ((TREE_CODE (return_type) == BOOLEAN_TYPE\n@@ -896,13 +930,15 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t  else\n \t    type = NULL_TREE;\n \t  goto ret;\n+\n \tret:\n \t  if (type != return_type)\n \t    VERIFICATION_ERROR (\"incorrect ?return opcode\");\n \t  if (type != void_type_node)\n-\t    POP_TYPE(type, \"return value has wrong type\");\n+\t    POP_TYPE (type, \"return value has wrong type\");\n \t  INVALIDATE_PC;\n \t  break;\n+\n \tcase OPCODE_getstatic: is_putting = 0;  is_static = 1;  goto field;\n \tcase OPCODE_putstatic: is_putting = 1;  is_static = 1;  goto field;\n \tcase OPCODE_getfield:  is_putting = 0;  is_static = 0;  goto field;\n@@ -911,69 +947,90 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t  {\n \t    tree field_signature, field_type;\n \t    index = IMMEDIATE_u2;\n-\t    if (index <= 0 || index >= JPOOL_SIZE(current_jcf))\n+\n+\t    if (index <= 0 || index >= JPOOL_SIZE (current_jcf))\n \t      VERIFICATION_ERROR_WITH_INDEX (\"bad constant pool index %d\");\n+\n \t    if (JPOOL_TAG (current_jcf, index) != CONSTANT_Fieldref)\n \t      VERIFICATION_ERROR\n \t\t(\"field instruction does not reference a Fieldref\");\n-\t    field_signature = COMPONENT_REF_SIGNATURE (&current_jcf->cpool, index);\n+\n+\t    field_signature\n+              = COMPONENT_REF_SIGNATURE (&current_jcf->cpool, index);\n+\n \t    field_type = get_type_from_signature (field_signature);\n+\n \t    if (is_putting)\n \t      POP_TYPE (field_type, \"incorrect type for field\");\n+\n \t    if (! is_static)\n \t      {\n-\t\tint clindex = COMPONENT_REF_CLASS_INDEX (&current_jcf->cpool,\n-\t\t\t\t\t\t\tindex);\n+\t\tint clindex\n+                  = COMPONENT_REF_CLASS_INDEX (&current_jcf->cpool, index);\n+\n \t\ttree self_type = get_class_constant (current_jcf, clindex);\n+\n \t\t/* Defer actual checking until next pass. */\n-\t\tPOP_TYPE(self_type, \"incorrect type for field reference\");\n+\t\tPOP_TYPE (self_type, \"incorrect type for field reference\");\n \t      }\n+\n \t    if (! is_putting)\n \t      PUSH_TYPE (field_type);\n \t    break;\n \t  }\n+\n \tcase OPCODE_new:\n \t  PUSH_TYPE (get_class_constant (jcf, IMMEDIATE_u2));\n \t  break;\n+\n \tcase OPCODE_dup:     wide = 1; index = 0;  goto dup;\n \tcase OPCODE_dup_x1:  wide = 1; index = 1;  goto dup;\n \tcase OPCODE_dup_x2:  wide = 1; index = 2;  goto dup;\n \tcase OPCODE_dup2:    wide = 2; index = 0;  goto dup;\n \tcase OPCODE_dup2_x1: wide = 2; index = 1;  goto dup;\n \tcase OPCODE_dup2_x2: wide = 2; index = 2;  goto dup;\n+\n \tdup:\n \t  if (wide + index > stack_pointer)\n \t    VERIFICATION_ERROR (\"stack underflow - dup* operation\");\n \t  type_stack_dup (wide, index);\n \t  wide = 0;\n \t  break;\n+\n \tcase OPCODE_pop:  index = 1;  goto pop;\n \tcase OPCODE_pop2: index = 2;  goto pop;\n+\n \tpop:\n \t  if (stack_pointer < index)\n \t    VERIFICATION_ERROR (\"stack underflow\");\n \t  stack_pointer -= index;\n \t  break;\n+\n \tcase OPCODE_swap:\n \t  if (stack_pointer < 2)\n \t    VERIFICATION_ERROR (\"stack underflow (in swap)\");\n \t  else\n \t    {\n-\t      tree type1 = stack_type_map[stack_pointer - 1];\n-\t      tree type2 = stack_type_map[stack_pointer - 2];\n+\t      tree type1 = stack_type_map [stack_pointer - 1];\n+\t      tree type2 = stack_type_map [stack_pointer - 2];\n+\n \t      if (type1 == void_type_node || type2 == void_type_node)\n \t\tVERIFICATION_ERROR (\"verifier (swap):  double or long value\");\n-\t      stack_type_map[stack_pointer - 2] = type1;\n-\t      stack_type_map[stack_pointer - 1] = type2;\n+\n+\t      stack_type_map [stack_pointer - 2] = type1;\n+\t      stack_type_map [stack_pointer - 1] = type2;\n \t    }\n \t  break;\n+\n \tcase OPCODE_ldc:   index = IMMEDIATE_u1;  goto ldc;\n \tcase OPCODE_ldc2_w:\n \tcase OPCODE_ldc_w:\n \t  index = IMMEDIATE_u2;  goto ldc;\n+\n \tldc:\n-\t  if (index <= 0 || index >= JPOOL_SIZE(current_jcf))\n+\t  if (index <= 0 || index >= JPOOL_SIZE (current_jcf))\n \t    VERIFICATION_ERROR_WITH_INDEX (\"bad constant pool index %d in ldc\");\n+\n \t  int_value = -1;\n \t  switch (JPOOL_TAG (current_jcf, index) & ~CONSTANT_ResolvedFlag)\n \t    {\n@@ -1005,10 +1062,13 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t    tree sig, method_name, method_type, self_type;\n \t    int self_is_interface, tag;\n \t    index = IMMEDIATE_u2;\n-\t    if (index <= 0 || index >= JPOOL_SIZE(current_jcf))\n+\n+\t    if (index <= 0 || index >= JPOOL_SIZE (current_jcf))\n \t      VERIFICATION_ERROR_WITH_INDEX\n \t\t(\"bad constant pool index %d for invoke\");\n+\n \t    tag = JPOOL_TAG (current_jcf, index);\n+\n \t    if (op_code == OPCODE_invokeinterface)\n \t      {\n \t\tif (tag != CONSTANT_InterfaceMethodref)\n@@ -1020,29 +1080,37 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t\tif (tag != CONSTANT_Methodref)\n \t\t  VERIFICATION_ERROR (\"invoke does not reference a Methodref\");\n \t      }\n+\n \t    sig = COMPONENT_REF_SIGNATURE (&current_jcf->cpool, index);\n-\t    self_type = get_class_constant\n-\t      (current_jcf, COMPONENT_REF_CLASS_INDEX (&current_jcf->cpool,\n-\t\t\t\t\t\t       index));\n+\n+\t    self_type\n+              = get_class_constant (current_jcf,\n+                                    COMPONENT_REF_CLASS_INDEX\n+                                      (&current_jcf->cpool, index));\n+\n \t    if (! CLASS_LOADED_P (self_type))\n \t      load_class (self_type, 1);\n+\n \t    self_is_interface = CLASS_INTERFACE (TYPE_NAME (self_type));\n \t    method_name = COMPONENT_REF_NAME (&current_jcf->cpool, index);\n \t    method_type = parse_signature_string (IDENTIFIER_POINTER (sig),\n \t\t\t\t\t\t  IDENTIFIER_LENGTH (sig));\n+\n \t    if (TREE_CODE (method_type) != FUNCTION_TYPE)\n \t      VERIFICATION_ERROR (\"bad method signature\");\n+\n \t    pmessage = pop_argument_types (TYPE_ARG_TYPES (method_type));\n \t    if (pmessage != NULL)\n \t      {\n \t\tmessage = \"invalid argument type\";\n \t\tgoto pop_type_error;\n \t      }\n \n-\t    /* Can't invoke <clinit> */\n+\t    /* Can't invoke <clinit>.  */\n \t    if (ID_CLINIT_P (method_name))\n \t      VERIFICATION_ERROR (\"invoke opcode can't invoke <clinit>\");\n-\t    /* Apart invokespecial, can't invoke <init> */\n+\n+\t    /* Apart from invokespecial, can't invoke <init>.  */\n \t    if (op_code != OPCODE_invokespecial && ID_INIT_P (method_name))\n \t      VERIFICATION_ERROR (\"invoke opcode can't invoke <init>\");\n \n@@ -1060,11 +1128,14 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t\t  if (!nargs || notZero)\n \t\t      VERIFICATION_ERROR \n \t\t        (\"invalid argument number in invokeinterface\");\n+\n \t\t  /* If we verify/resolve the constant pool, as we should,\n \t\t     this test (and the one just following) are redundant.  */\n \t\t  if (! self_is_interface)\n-\t\t    VERIFICATION_ERROR (\"invokeinterface calls method not in interface\");\n+\t\t    VERIFICATION_ERROR\n+                      (\"invokeinterface calls method not in interface\");\n \t\t  break;\n+\n \t\tdefault:\n \t\t  if (self_is_interface)\n \t\t    VERIFICATION_ERROR (\"method in interface called\");\n@@ -1077,9 +1148,9 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t  }\n \n \tcase OPCODE_arraylength:\n-\t    /* Type checking actually made during code generation */\n-\t    pop_type( ptr_type_node );\n-\t    PUSH_TYPE( int_type_node );\n+\t    /* Type checking actually made during code generation.  */\n+\t    pop_type (ptr_type_node);\n+\t    PUSH_TYPE (int_type_node);\n \t    break;\n \t    \n         /* Q&D verification *or* more checking done during code generation\n@@ -1093,8 +1164,9 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \tcase OPCODE_bastore: type = int_type_node; goto astore;\n \tcase OPCODE_castore: type = int_type_node; goto astore;\n \tcase OPCODE_sastore: type = int_type_node; goto astore;\n+\n \tastore:\n-\t  /* FIXME - need better verification here */\n+\t  /* FIXME - need better verification here.  */\n \t  pop_type (type);\t     /* new value */\n \t  pop_type (int_type_node);  /* index */\n \t  pop_type (ptr_type_node);  /* array */\n@@ -1110,6 +1182,7 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \tcase OPCODE_baload: type = promote_type (byte_type_node);  goto aload;\n \tcase OPCODE_caload: type = promote_type (char_type_node);  goto aload;\n \tcase OPCODE_saload: type = promote_type (short_type_node); goto aload;\n+\n         aload:\n \t  pop_type (int_type_node);\n \t  tmp = pop_type (ptr_type_node);\n@@ -1135,9 +1208,9 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \tnewarray:\n \t  if (int_value >= 0 && prevpc >= 0)\n \t    {\n-\t      /* If previous instruction pushed int constant,\n+\t      /* If the previous instruction pushed an int constant,\n \t\t we want to use it. */\n-\t      switch (byte_ops[prevpc])\n+\t      switch (byte_ops [prevpc])\n \t\t{\n \t\tcase OPCODE_iconst_0: case OPCODE_iconst_1:\n \t\tcase OPCODE_iconst_2: case OPCODE_iconst_3:\n@@ -1151,6 +1224,7 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t    }\n \t  else\n \t    int_value = -1;\n+\n \t  type = build_java_array_type (type, int_value);\n \t  pop_type (int_type_node);\n \t  PUSH_TYPE (type);\n@@ -1162,11 +1236,13 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t    index = IMMEDIATE_u2;\n \t    ndim  = IMMEDIATE_u1;\n \n-            if( ndim < 1 )\n-              VERIFICATION_ERROR (\"number of dimension lower that 1 in multianewarray\" );\n+            if (ndim < 1)\n+              VERIFICATION_ERROR\n+                (\"number of dimension lower that 1 in multianewarray\" );\n \n-\t    for( i = 0; i < ndim; i++ )\n+\t    for (i = 0; i < ndim; i++)\n \t      pop_type (int_type_node);\n+\n \t    PUSH_TYPE (get_class_constant (current_jcf, index));\n \t    break;\n \t  }\n@@ -1176,7 +1252,7 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t  break;\n \n \tcase OPCODE_athrow:\n-\t  /* FIXME: athrow also empties the stack. */\n+\t  /* FIXME: athrow also empties the stack.  */\n \t  POP_TYPE (throwable_type_node, \"missing throwable at athrow\" );\n \t  INVALIDATE_PC;\n \t  break;\n@@ -1187,6 +1263,7 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t  type = get_class_constant (current_jcf, IMMEDIATE_u2);\n \t  PUSH_TYPE (type);\n \t  break;\n+\n \tcase OPCODE_instanceof:\n \t  POP_TYPE (object_ptr_type_node,\n \t\t    \"instanceof operand is not a pointer\");\n@@ -1199,12 +1276,14 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t    jint low, high;\n \n \t    POP_TYPE (int_type_node, \"missing int for tableswitch\");\n+\n \t    while (PC%4)\n \t      {\n-\t        if (byte_ops[PC++])\n+\t        if (byte_ops [PC++])\n \t\t  VERIFICATION_ERROR (\"bad alignment in tableswitch pad\");\n \t      }\n-\t    PUSH_PENDING (lookup_label (oldpc+IMMEDIATE_s4));\n+\n+\t    PUSH_PENDING (lookup_label (oldpc + IMMEDIATE_s4));\n \t    low  = IMMEDIATE_s4;\n \t    high = IMMEDIATE_s4;\n \n@@ -1213,6 +1292,7 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \n \t    while (low++ <= high)\n \t      PUSH_PENDING (lookup_label (oldpc + IMMEDIATE_s4));\n+\n \t    INVALIDATE_PC;\n \t    break;\n \t  }\n@@ -1222,13 +1302,14 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t    jint npairs, last = 0, not_registered = 1;\n \n \t    POP_TYPE (int_type_node, \"missing int for lookupswitch\");\n+\n \t    while (PC%4)\n \t      {\n-\t        if (byte_ops[PC++])\n+\t        if (byte_ops [PC++])\n \t\t  VERIFICATION_ERROR (\"bad alignment in lookupswitch pad\");\n \t      }\n \n-\t    PUSH_PENDING (lookup_label (oldpc+IMMEDIATE_s4));\n+\t    PUSH_PENDING (lookup_label (oldpc + IMMEDIATE_s4));\n \t    npairs = IMMEDIATE_s4;\n \t    \n \t    if (npairs < 0)\n@@ -1237,6 +1318,7 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t    while (npairs--)\n \t      {\n \t        int match = IMMEDIATE_s4;\n+\n \t\tif (not_registered)\n \t\t  not_registered = 0;\n \t\telse if (last >= match)\n@@ -1273,13 +1355,16 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t\tint nlocals = DECL_MAX_LOCALS (current_function_decl);\n \t\tindex = nlocals + DECL_MAX_STACK (current_function_decl);\n \t\treturn_type_map = make_tree_vec (index);\n+\n \t\twhile (index > nlocals)\n \t\t  TREE_VEC_ELT (return_type_map, --index) = TYPE_UNKNOWN;\n+\n \t\twhile (index > 0)\n \t\t  TREE_VEC_ELT (return_type_map, --index) = TYPE_UNUSED;\n+\n \t\tLABEL_RETURN_LABEL (target)\n \t\t  = build_decl (LABEL_DECL, NULL_TREE, TREE_TYPE (target));\n-\t\tLABEL_PC (LABEL_RETURN_LABEL (target)) = -1;\n+\t\tLABEL_PC (LABEL_RETURN_LABEL (target)) = INVALID_PC;\n \t\tLABEL_RETURN_TYPE_STATE (target) = return_type_map;\n \t\tLABEL_IS_SUBR_START (target) = 1;\n \t\tLABEL_IN_SUBR (target) = 1;\n@@ -1315,7 +1400,7 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t\twhile (--len >= 0)\n \t\t  {\n \t\t    if (TREE_VEC_ELT (return_map, len) != TYPE_UNUSED)\n-\t\t      type_map[len] = TREE_VEC_ELT (return_map, len);\n+\t\t      type_map [len] = TREE_VEC_ELT (return_map, len);\n \t\t  }\n \t\tcurrent_subr = LABEL_SUBR_CONTEXT (target);\n \t\tif (RETURN_MAP_ADJUSTED (return_map))\n@@ -1325,33 +1410,37 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t    INVALIDATE_PC;\n \t  }\n \t  break;\n+\n \tcase OPCODE_ret:\n-\t  if (current_subr == NULL)\n+\t  if (current_subr == NULL_TREE)\n \t    VERIFICATION_ERROR (\"ret instruction not in a jsr subroutine\");\n \t  else\n \t    {\n \t      tree ret_map = LABEL_RETURN_TYPE_STATE (current_subr);\n-\t      int size = DECL_MAX_LOCALS(current_function_decl)+stack_pointer;\n+\t      int size\n+                = DECL_MAX_LOCALS (current_function_decl) + stack_pointer;\n \t      index = wide ? IMMEDIATE_u2 : IMMEDIATE_u1;\n \t      wide = 0;\n \t      INVALIDATE_PC;\n \t      if (index < 0 || index >= DECL_MAX_LOCALS (current_function_decl)\n-\t\t  || type_map[index] != TYPE_RETURN_ADDR)\n+\t\t  || type_map [index] != TYPE_RETURN_ADDR)\n \t\tVERIFICATION_ERROR (\"invalid ret index\");\n \n \t      /* The next chunk of code is similar to an inlined version of\n-\t       *     merge_type_state (LABEL_RETURN_LABEL (current_subr)).\n-\t       * The main differences are that LABEL_RETURN_LABEL is\n-\t       * pre-allocated by the jsr (but we don't know the size then);\n-\t       * and that we have to handle TYPE_UNUSED. */\n+               merge_type_state (LABEL_RETURN_LABEL (current_subr)).\n+\t       The main differences are that LABEL_RETURN_LABEL is\n+\t       pre-allocated by the jsr (but we don't know the size then);\n+\t       and that we have to handle TYPE_UNUSED.  */\n \n \t      if (! RETURN_MAP_ADJUSTED (ret_map))\n-\t\t{ /* First return from this subroutine - fix stack pointer. */\n+\t\t{\n+                  /* First return from this subroutine - fix stack\n+                  pointer.  */\n \t\t  TREE_VEC_LENGTH (ret_map) = size;\n \t\t  for (index = size;  --index >= 0; )\n \t\t    {\n \t\t      if (TREE_VEC_ELT (ret_map, index) != TYPE_UNUSED)\n-\t\t\tTREE_VEC_ELT (ret_map, index) = type_map[index];\n+\t\t\tTREE_VEC_ELT (ret_map, index) = type_map [index];\n \t\t    }\n \t\t  RETURN_MAP_ADJUSTED (ret_map) = 1;\n \t\t}\n@@ -1377,10 +1466,9 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t\t\t}\n \t\t    }\n \t\t}\n-\n-\n             }\n           break;\n+\n         case OPCODE_jsr_w:        \n         case OPCODE_ret_w:\n         default:\n@@ -1393,17 +1481,18 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n       /* The following test is true if we have entered or exited an exception\n \t handler range *or* we have done a store to a local variable.\n \t In either case we need to consider any exception handlers that\n-\t might \"follow\" this instruction. */\n+\t might \"follow\" this instruction.  */\n \n       if (eh_ranges != prev_eh_ranges)\n \t{\n \t  int save_stack_pointer = stack_pointer;\n \t  int index = DECL_MAX_LOCALS (current_function_decl);\n-\t  tree save_type = type_map[index];\n+\t  tree save_type = type_map [index];\n \t  tree save_current_subr = current_subr;\n \t  struct eh_range *ranges = find_handler (oldpc);\n \t  stack_pointer = 1;\n-\t  for (; ranges != NULL_EH_RANGE;  ranges = ranges->outer)\n+\n+\t  for ( ; ranges != NULL_EH_RANGE; ranges = ranges->outer)\n \t    {\n \t      tree chain = ranges->handlers;\n \n@@ -1420,56 +1509,64 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t\t have that the current_subr is entirely within the catch range.\n \t\t In that case we can assume if that if a caller (the jsr) of\n \t\t a subroutine is within the catch range, then the handler is\n-\t\t *not* part of the subroutine, and vice versa. */\n+\t\t *not* part of the subroutine, and vice versa.  */\n \n \t      current_subr = save_current_subr;\n \t      for ( ; current_subr != NULL_TREE;\n \t\t    current_subr = LABEL_SUBR_CONTEXT (current_subr))\n \t\t{\n \t\t  tree return_labels = LABEL_RETURN_LABELS (current_subr);\n \t\t  /* There could be multiple return_labels, but\n-\t\t     we only need to check one. */\n+\t\t     we only need to check one.  */\n \t\t  int return_pc = LABEL_PC (TREE_VALUE (return_labels));\n \t\t  if (return_pc <= ranges->start_pc\n \t\t      || return_pc > ranges->end_pc)\n \t\t    break;\n \t\t}\n \n-\t      for ( ;  chain != NULL_TREE;  chain = TREE_CHAIN (chain))\n+\t      for ( ; chain != NULL_TREE; chain = TREE_CHAIN (chain))\n \t\t{\n \t\t  tree handler = TREE_VALUE (chain);\n \t\t  tree type = TREE_PURPOSE (chain);\n+\n \t\t  if (type == NULL_TREE)  /* a finally handler */\n \t\t    type = throwable_type_node;\n-\t\t  type_map[index] = promote_type (type);\n+\n+\t\t  type_map [index] = promote_type (type);\n \n \t\t  PUSH_PENDING (handler);\n \t\t}\n \t    }\n \t  stack_pointer = save_stack_pointer;\n \t  current_subr = save_current_subr;\n-\t  type_map[index] = save_type;\n+\t  type_map [index] = save_type;\n \t  prev_eh_ranges = eh_ranges;\n \t}\n     }\n+\n   return 1;\n+\n  pop_type_error:\n   error (\"verification error at PC=%d\", oldpc);\n   if (message != NULL)\n     error (\"%s\", message);\n   error (\"%s\", pmessage);\n   free (pmessage);\n   return 0;\n+\n  stack_overflow:\n   message = \"stack overflow\";\n   goto verify_error;\n+\n  bad_pc:\n   message = \"program counter out of range\";\n   goto verify_error;\n+\n  error_with_index:\n   error (\"verification error at PC=%d\", oldpc);\n   error (message, index);\n   return 0;\n+\n  verify_error:\n   error (\"verification error at PC=%d\", oldpc);\n   error (\"%s\", message);"}]}