{"sha": "10789329789fbb5b87883fca029e745a06ded6a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTA3ODkzMjk3ODlmYmI1Yjg3ODgzZmNhMDI5ZTc0NWEwNmRlZDZhMA==", "commit": {"author": {"name": "Jim Wilson", "email": "jimw@sifive.com", "date": "2018-02-15T01:14:23Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "2018-02-15T01:14:23Z"}, "message": "RISC-V: Change sp subtracts so prologue stores can compress.\n\n\tgcc/\n\t* config/riscv/riscv.c (riscv_first_stack_step): Move locals after\n\tfirst SMALL_OPERAND check.  New local min_second_step.  Move assert\n\tto where locals are set.  Add TARGET_RVC support.\n\t* config/riscv/riscv.h (C_SxSP_BITS, SWSP_REACH, SDSP_REACH): New.\n\nFrom-SVN: r257681", "tree": {"sha": "b5e6fe7f7bfd30e38823a79d94d8b8b50f921d6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5e6fe7f7bfd30e38823a79d94d8b8b50f921d6c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10789329789fbb5b87883fca029e745a06ded6a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10789329789fbb5b87883fca029e745a06ded6a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10789329789fbb5b87883fca029e745a06ded6a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10789329789fbb5b87883fca029e745a06ded6a0/comments", "author": null, "committer": null, "parents": [{"sha": "1622ba9cefbc2f3e21e42ed336700dd788f11c5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1622ba9cefbc2f3e21e42ed336700dd788f11c5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1622ba9cefbc2f3e21e42ed336700dd788f11c5c"}], "stats": {"total": 41, "additions": 35, "deletions": 6}, "files": [{"sha": "7c30a1ed0db63a761b0805d9247b5c4dd0532638", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10789329789fbb5b87883fca029e745a06ded6a0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10789329789fbb5b87883fca029e745a06ded6a0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=10789329789fbb5b87883fca029e745a06ded6a0", "patch": "@@ -1,3 +1,10 @@\n+2018-02-14  Jim Wilson  <jimw@sifive.com>\n+\n+\t* config/riscv/riscv.c (riscv_first_stack_step): Move locals after\n+\tfirst SMALL_OPERAND check.  New local min_second_step.  Move assert\n+\tto where locals are set.  Add TARGET_RVC support.\n+\t* config/riscv/riscv.h (C_SxSP_BITS, SWSP_REACH, SDSP_REACH): New.\n+\n 2018-02-14  Indu Bhagat  <indu.bhagat@oracle.com>\n \n \t* doc/invoke.texi: Correct -Wformat-overflow code sample."}, {"sha": "c38f6c394d54057fd6a6058e438bc5d565e49709", "filename": "gcc/config/riscv/riscv.c", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10789329789fbb5b87883fca029e745a06ded6a0/gcc%2Fconfig%2Friscv%2Friscv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10789329789fbb5b87883fca029e745a06ded6a0/gcc%2Fconfig%2Friscv%2Friscv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.c?ref=10789329789fbb5b87883fca029e745a06ded6a0", "patch": "@@ -3495,25 +3495,43 @@ riscv_output_gpr_save (unsigned mask)\n \n /* For stack frames that can't be allocated with a single ADDI instruction,\n    compute the best value to initially allocate.  It must at a minimum\n-   allocate enough space to spill the callee-saved registers.  */\n+   allocate enough space to spill the callee-saved registers.  If TARGET_RVC,\n+   try to pick a value that will allow compression of the register saves\n+   without adding extra instructions.  */\n \n static HOST_WIDE_INT\n riscv_first_stack_step (struct riscv_frame_info *frame)\n {\n-  HOST_WIDE_INT min_first_step = frame->total_size - frame->fp_sp_offset;\n-  HOST_WIDE_INT max_first_step = IMM_REACH / 2 - STACK_BOUNDARY / 8;\n-\n   if (SMALL_OPERAND (frame->total_size))\n     return frame->total_size;\n \n+  HOST_WIDE_INT min_first_step = frame->total_size - frame->fp_sp_offset;\n+  HOST_WIDE_INT max_first_step = IMM_REACH / 2 - STACK_BOUNDARY / 8;\n+  HOST_WIDE_INT min_second_step = frame->total_size - max_first_step;\n+  gcc_assert (min_first_step <= max_first_step);\n+\n   /* As an optimization, use the least-significant bits of the total frame\n      size, so that the second adjustment step is just LUI + ADD.  */\n-  if (!SMALL_OPERAND (frame->total_size - max_first_step)\n+  if (!SMALL_OPERAND (min_second_step)\n       && frame->total_size % IMM_REACH < IMM_REACH / 2\n       && frame->total_size % IMM_REACH >= min_first_step)\n     return frame->total_size % IMM_REACH;\n \n-  gcc_assert (min_first_step <= max_first_step);\n+  if (TARGET_RVC)\n+    {\n+      /* If we need two subtracts, and one is small enough to allow compressed\n+\t loads and stores, then put that one first.  */\n+      if (IN_RANGE (min_second_step, 0,\n+\t\t    (TARGET_64BIT ? SDSP_REACH : SWSP_REACH)))\n+\treturn MAX (min_second_step, min_first_step);\n+\n+      /* If we need LUI + ADDI + ADD for the second adjustment step, then start\n+\t with the minimum first step, so that we can get compressed loads and\n+\t stores.  */\n+      else if (!SMALL_OPERAND (min_second_step))\n+\treturn min_first_step;\n+    }\n+\n   return max_first_step;\n }\n "}, {"sha": "6144e267727731215c67e4a504528b0e48373ad7", "filename": "gcc/config/riscv/riscv.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10789329789fbb5b87883fca029e745a06ded6a0/gcc%2Fconfig%2Friscv%2Friscv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10789329789fbb5b87883fca029e745a06ded6a0/gcc%2Fconfig%2Friscv%2Friscv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.h?ref=10789329789fbb5b87883fca029e745a06ded6a0", "patch": "@@ -891,9 +891,13 @@ extern unsigned riscv_stack_boundary;\n #define SHIFT_RS1 15\n #define SHIFT_IMM 20\n #define IMM_BITS 12\n+#define C_SxSP_BITS 6\n \n #define IMM_REACH (1LL << IMM_BITS)\n #define CONST_HIGH_PART(VALUE) (((VALUE) + (IMM_REACH/2)) & ~(IMM_REACH-1))\n #define CONST_LOW_PART(VALUE) ((VALUE) - CONST_HIGH_PART (VALUE))\n \n+#define SWSP_REACH (4LL << C_SxSP_BITS)\n+#define SDSP_REACH (8LL << C_SxSP_BITS)\n+\n #endif /* ! GCC_RISCV_H */"}]}