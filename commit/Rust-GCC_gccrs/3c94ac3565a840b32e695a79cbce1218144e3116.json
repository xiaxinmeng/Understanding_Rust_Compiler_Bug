{"sha": "3c94ac3565a840b32e695a79cbce1218144e3116", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2M5NGFjMzU2NWE4NDBiMzJlNjk1YTc5Y2JjZTEyMTgxNDRlMzExNg==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-10-13T05:54:42Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-10-13T05:54:42Z"}, "message": "File.java: Reformated.\n\n2003-10-13  Michael Koch  <konqueror@gmx.de>\n\n\t* java/io/File.java: Reformated.\n\t(equals): Check for obj == null.\n\nFrom-SVN: r72421", "tree": {"sha": "e60814481dab0234f3b3d8c441acd4fc18036a08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e60814481dab0234f3b3d8c441acd4fc18036a08"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c94ac3565a840b32e695a79cbce1218144e3116", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c94ac3565a840b32e695a79cbce1218144e3116", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c94ac3565a840b32e695a79cbce1218144e3116", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c94ac3565a840b32e695a79cbce1218144e3116/comments", "author": null, "committer": null, "parents": [{"sha": "94f415861c876c2b755f7f5125d785e2c7b580e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94f415861c876c2b755f7f5125d785e2c7b580e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94f415861c876c2b755f7f5125d785e2c7b580e6"}], "stats": {"total": 196, "additions": 103, "deletions": 93}, "files": [{"sha": "1d45198c1e7044036c733586c8735fb6b4123a4c", "filename": "libjava/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c94ac3565a840b32e695a79cbce1218144e3116/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c94ac3565a840b32e695a79cbce1218144e3116/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=3c94ac3565a840b32e695a79cbce1218144e3116", "patch": "@@ -1,3 +1,8 @@\n+2003-10-13  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/io/File.java: Reformated.\n+\t(equals): Check for obj == null.\n+\n 2003-10-13  Michael Koch  <konqueror@gmx.de>\n \n \t* java/net/JarURLConnection.java"}, {"sha": "4800ba15c18eb56a01ca1f0a76beaa1791f67621", "filename": "libjava/java/io/File.java", "status": "modified", "additions": 98, "deletions": 93, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c94ac3565a840b32e695a79cbce1218144e3116/libjava%2Fjava%2Fio%2FFile.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c94ac3565a840b32e695a79cbce1218144e3116/libjava%2Fjava%2Fio%2FFile.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FFile.java?ref=3c94ac3565a840b32e695a79cbce1218144e3116", "patch": "@@ -124,7 +124,7 @@ public class File implements Serializable, Comparable\n         System.loadLibrary (\"javaio\");\n       }\n     \n-    init_native ();\n+    init_native();\n   }\n   \n   // Native function called at class initialization. This should should\n@@ -139,7 +139,7 @@ public class File implements Serializable, Comparable\n \n   // We keep a counter for use by createTempFile.  We choose the first\n   // value randomly to try to avoid clashes with other VMs.\n-  private static long counter = Double.doubleToLongBits (Math.random ());\n+  private static long counter = Double.doubleToLongBits (Math.random());\n \n   /**\n    * This method tests whether or not the current thread is allowed to\n@@ -154,9 +154,9 @@ public class File implements Serializable, Comparable\n    * @exception SecurityException If the <code>SecurityManager</code> \n    * does not allow access to the file\n    */\n-  public boolean canRead ()\n+  public boolean canRead()\n   {\n-    checkRead ();\n+    checkRead();\n     return _access (READ);\n   }\n \n@@ -174,9 +174,9 @@ public boolean canRead ()\n    * @exception SecurityException If the <code>SecurityManager</code> \n    * does not allow access to the file\n    */\n-  public boolean canWrite ()\n+  public boolean canWrite()\n   {\n-    checkWrite ();\n+    checkWrite();\n     return _access (WRITE);\n   }\n   \n@@ -201,14 +201,14 @@ public boolean canWrite ()\n    */\n   public boolean createNewFile() throws IOException\n   {\n-    checkWrite ();\n+    checkWrite();\n     return performCreate();\n   }\n  \n   /*\n    * This native method handles the actual deleting of the file\n    */\n-  private native boolean performDelete ();\n+  private native boolean performDelete();\n \n   /**\n    * This method deletes the file represented by this object.  If this file\n@@ -219,14 +219,14 @@ public boolean createNewFile() throws IOException\n    *\n    * @exception SecurityException If deleting of the file is not allowed\n    */\n-  public synchronized boolean delete ()\n+  public synchronized boolean delete()\n   {\n-    SecurityManager s = System.getSecurityManager ();\n+    SecurityManager s = System.getSecurityManager();\n     \n     if (s != null)\n       s.checkDelete (path);\n     \n-    return performDelete ();\n+    return performDelete();\n   }\n \n   /**\n@@ -246,14 +246,18 @@ public synchronized boolean delete ()\n    */\n   public boolean equals (Object obj)\n   {\n+    if (obj == null)\n+      return false;\n+    \n     if (! (obj instanceof File))\n       return false;\n     \n     File other = (File) obj;\n+\n     if (caseSensitive)\n-      return path.equals(other.path);\n+      return path.equals (other.path);\n     else\n-      return path.equalsIgnoreCase(other.path);\n+      return path.equalsIgnoreCase (other.path);\n   }\n \n   /**\n@@ -264,9 +268,9 @@ public boolean equals (Object obj)\n    *\n    * @exception SecurityException If reading of the file is not permitted\n    */\n-  public boolean exists ()\n+  public boolean exists()\n   {\n-    checkRead ();\n+    checkRead();\n     return _access (EXISTS);\n   }\n \n@@ -356,7 +360,7 @@ private String normalizePath(String p)\n   public File (String dirPath, String name)\n   {\n     if (name == null)\n-      throw new NullPointerException ();\n+      throw new NullPointerException();\n     if (dirPath != null && dirPath.length() > 0)\n       {\n \t// Try to be smart about the number of separator characters.\n@@ -394,20 +398,20 @@ public File (File directory, String name)\n    *\n    * @return The absolute path of this file\n    */\n-  public String getAbsolutePath ()\n+  public String getAbsolutePath()\n   {\n-    if (isAbsolute ())\n+    if (isAbsolute())\n       return path;\n     else if (separatorChar == '\\\\' \n-             && path.length () > 0 && path.charAt (0) == '\\\\')\n+             && path.length() > 0 && path.charAt (0) == '\\\\')\n       {\n         // On Windows, even if the path starts with a '\\\\' it is not\n         // really absolute until we prefix the drive specifier from\n         // the current working directory to it.\n         return System.getProperty (\"user.dir\").substring (0, 2) + path;\n       }\n     else if (separatorChar == '\\\\' \n-             && path.length () > 1 && path.charAt (1) == ':'\n+             && path.length() > 1 && path.charAt (1) == ':'\n              && ((path.charAt (0) >= 'a' && path.charAt (0) <= 'z')\n                  || (path.charAt (0) >= 'A' && path.charAt (0) <= 'Z')))\n       {\n@@ -418,7 +422,7 @@ else if (separatorChar == '\\\\'\n         String drvDir = null;\n         try\n           {\n-            drvDir = new File (path.substring (0, 2)).getCanonicalPath ();\n+            drvDir = new File (path.substring (0, 2)).getCanonicalPath();\n           }\n         catch (IOException e)\n           {\n@@ -428,8 +432,8 @@ else if (separatorChar == '\\\\'\n         // Note: this would return \"C:\\\\.\" for the path \"C:.\", if \"\\\"\n         // is the working folder on the C drive, but this is \n         // consistent with what Sun's JRE 1.4.1.01 actually returns!\n-        if (path.length () > 2)\n-          return drvDir + '\\\\' + path.substring (2, path.length ());\n+        if (path.length() > 2)\n+          return drvDir + '\\\\' + path.substring (2, path.length());\n         else\n           return drvDir;\n       }\n@@ -445,7 +449,7 @@ else if (separatorChar == '\\\\'\n    *\n    * @since 1.2\n    */\n-  public File getAbsoluteFile ()\n+  public File getAbsoluteFile()\n   {\n     return new File (getAbsolutePath());\n   }\n@@ -463,7 +467,7 @@ public File getAbsoluteFile ()\n    *\n    * @exception IOException If an error occurs\n    */\n-  public native String getCanonicalPath () throws IOException;\n+  public native String getCanonicalPath() throws IOException;\n \n   /**\n    * This method returns a <code>File</code> object representing the\n@@ -476,7 +480,7 @@ public File getAbsoluteFile ()\n    *\n    * @since 1.2\n    */\n-  public File getCanonicalFile () throws IOException\n+  public File getCanonicalFile() throws IOException\n   {\n     return new File (getCanonicalPath());\n   }\n@@ -488,11 +492,11 @@ public File getCanonicalFile () throws IOException\n    *\n    * @return The file name\n    */\n-  public String getName ()\n+  public String getName()\n   {\n     int nameSeqIndex = 0;\n \n-    if (separatorChar == '\\\\' && path.length () > 1)\n+    if (separatorChar == '\\\\' && path.length() > 1)\n       {\n         // On Windows, ignore the drive specifier or the leading '\\\\'\n         // of a UNC network path, if any (a.k.a. the \"prefix\").\n@@ -501,7 +505,7 @@ public String getName ()\n \t\t || (path.charAt (0) >= 'A' && path.charAt (0) <= 'Z'))\n \t\t&& path.charAt (1) == ':'))\n \t  {\n-\t    if (path.length () > 2)\n+\t    if (path.length() > 2)\n \t      nameSeqIndex = 2;\n \t    else\n \t      return \"\";\n@@ -523,7 +527,7 @@ public String getName ()\n    *\n    * @return The parent directory of this file\n    */\n-  public String getParent ()\n+  public String getParent()\n   {\n     String prefix = null;\n     int nameSeqIndex = 0;\n@@ -536,7 +540,7 @@ public String getParent ()\n         prefix = \"/\";\n         nameSeqIndex = 1;\n       }\n-    else if (separatorChar == '\\\\' && path.length () > 1)\n+    else if (separatorChar == '\\\\' && path.length() > 1)\n       {\n         if ((path.charAt (0) == '\\\\' && path.charAt (1) == '\\\\')\n             || (((path.charAt (0) >= 'a' && path.charAt (0) <= 'z')\n@@ -551,13 +555,13 @@ else if (separatorChar == '\\\\' && path.length () > 1)\n     // According to the JDK docs, the returned parent path is the \n     // portion of the name sequence before the last separator\n     // character, if found, prefixed by the prefix, otherwise null.\n-    if (nameSeqIndex < path.length ())\n+    if (nameSeqIndex < path.length())\n       {\n-        String nameSeq = path.substring (nameSeqIndex, path.length ());\n+        String nameSeq = path.substring (nameSeqIndex, path.length());\n         int last = nameSeq.lastIndexOf (separatorChar);\n         if (last == -1)\n           return prefix;\n-        else if (last == (nameSeq.length () - 1))\n+        else if (last == (nameSeq.length() - 1))\n           // Note: The path would not have a trailing separator\n           // except for cases like \"C:\\\" on Windows (see \n           // normalizePath( )), where Sun's JRE 1.4 returns null.\n@@ -587,10 +591,10 @@ else if (last == 0)\n    *\n    * @since 1.2\n    */\n-  public File getParentFile ()\n+  public File getParentFile()\n   {\n-    String parent = getParent ();\n-    return (parent == null ? null : new File (parent));\n+    String parent = getParent();\n+    return parent != null ? new File (parent) : null;\n   }\n \n   /**\n@@ -599,7 +603,7 @@ public File getParentFile ()\n    *\n    * @return The pathname of this file\n    */\n-  public String getPath ()\n+  public String getPath()\n   {\n     return path;\n   }\n@@ -611,12 +615,12 @@ public String getPath ()\n    *\n    * @return The hash code for this object\n    */\n-  public int hashCode ()\n+  public int hashCode()\n   {\n     if (caseSensitive)\n-      return (path.hashCode() ^ 1234321);\n+      return path.hashCode() ^ 1234321;\n     else\n-      return (path.toLowerCase().hashCode() ^ 1234321);\n+      return path.toLowerCase().hashCode() ^ 1234321;\n   }\n \n   /**\n@@ -628,7 +632,7 @@ public int hashCode ()\n    * @return <code>true</code> if this object represents an absolute \n    * file name, <code>false</code> otherwise.\n    */\n-  public native boolean isAbsolute ();\n+  public native boolean isAbsolute();\n \n   /**\n    * This method tests whether or not the file represented by this object\n@@ -640,9 +644,9 @@ public int hashCode ()\n    *\n    * @exception SecurityException If reading of the file is not permitted\n    */\n-  public boolean isDirectory ()\n+  public boolean isDirectory()\n   {\n-    checkRead ();\n+    checkRead();\n     return _stat (DIRECTORY);\n   }\n \n@@ -656,9 +660,9 @@ public boolean isDirectory ()\n    *\n    * @exception SecurityException If reading of the file is not permitted\n    */\n-  public boolean isFile ()\n+  public boolean isFile()\n   {\n-    checkRead ();\n+    checkRead();\n     return _stat (ISFILE);\n   }\n \n@@ -673,9 +677,9 @@ public boolean isFile ()\n    *\n    * @since 1.2\n    */\n-  public boolean isHidden ()\n+  public boolean isHidden()\n   {\n-    checkRead ();\n+    checkRead();\n     return _stat (ISHIDDEN);\n   }\n \n@@ -692,9 +696,9 @@ public boolean isHidden ()\n    *\n    * @exception SecurityException If reading of the file is not permitted\n    */\n-  public long lastModified ()\n+  public long lastModified()\n   {\n-    checkRead ();\n+    checkRead();\n     return attr (MODIFIED);\n   }\n \n@@ -706,9 +710,9 @@ public long lastModified ()\n    *\n    * @exception SecurityException If reading of the file is not permitted\n    */\n-  public long length ()\n+  public long length()\n   {\n-    checkRead ();\n+    checkRead();\n     return attr (LENGTH);\n   }\n \n@@ -749,7 +753,7 @@ private final native Object[] performList (FilenameFilter filter,\n    */\n   public String[] list (FilenameFilter filter)\n   {\n-    checkRead ();\n+    checkRead();\n     return (String[]) performList (filter, null, String.class);\n   }\n \n@@ -771,9 +775,9 @@ public String[] list (FilenameFilter filter)\n    * @exception SecurityException If read access is not allowed to the \n    * directory by the <code>SecurityManager</code>\n    */\n-  public String[] list ()\n+  public String[] list()\n   {\n-    checkRead ();\n+    checkRead();\n     return (String[]) performList (null, null, String.class);\n   }\n \n@@ -795,9 +799,9 @@ public String[] list ()\n    *\n    * @since 1.2\n    */\n-  public File[] listFiles ()\n+  public File[] listFiles()\n   {\n-    checkRead ();\n+    checkRead();\n     return (File[]) performList (null, null, File.class);\n   }\n   \n@@ -827,7 +831,7 @@ public File[] listFiles ()\n    */\n   public File[] listFiles (FilenameFilter filter)\n   {\n-    checkRead ();\n+    checkRead();\n     return (File[]) performList (filter, null, File.class);\n   }\n \n@@ -857,7 +861,7 @@ public File[] listFiles (FilenameFilter filter)\n    */\n   public File[] listFiles (FileFilter filter)\n   {\n-    checkRead ();\n+    checkRead();\n     return (File[]) performList (null, filter, File.class);\n   }\n \n@@ -867,7 +871,7 @@ public File[] listFiles (FileFilter filter)\n    *\n    * @return A <code>String</code> representation of this file\n    */\n-  public String toString ()\n+  public String toString()\n   {\n     return path;\n   }\n@@ -882,22 +886,22 @@ public String toString ()\n    * @exception MalformedURLException If the URL cannot be created \n    * successfully.\n    */\n-  public URL toURL () throws MalformedURLException\n+  public URL toURL() throws MalformedURLException\n   {\n     // On Win32, Sun's JDK returns URLs of the form \"file:/c:/foo/bar.txt\",\n     // while on UNIX, it returns URLs of the form \"file:/foo/bar.txt\". \n     if (separatorChar == '\\\\')\n-      return new URL (\"file:/\" + getAbsolutePath ().replace ('\\\\', '/')\n+      return new URL (\"file:/\" + getAbsolutePath().replace ('\\\\', '/')\n \t\t      + (isDirectory() ? \"/\" : \"\"));\n     else\n-      return new URL (\"file:\" + getAbsolutePath ()\n+      return new URL (\"file:\" + getAbsolutePath()\n \t\t      + (isDirectory() ? \"/\" : \"\"));\n   }\n \n   /*\n    * This native method actually creates the directory\n    */\n-  private final native boolean performMkdir ();\n+  private final native boolean performMkdir();\n \n   /**\n    * This method creates a directory for the path represented by this object.\n@@ -907,10 +911,10 @@ public URL toURL () throws MalformedURLException\n    *\n    * @exception SecurityException If write access is not allowed to this file\n    */\n-  public boolean mkdir ()\n+  public boolean mkdir()\n   {\n-    checkWrite ();\n-    return performMkdir ();\n+    checkWrite();\n+    return performMkdir();\n   }\n \n   private static boolean mkdirs (File x)\n@@ -938,15 +942,15 @@ private static boolean mkdirs (File x)\n    *\n    * @exception SecurityException If write access is not allowed to this file\n    */\n-  public boolean mkdirs ()\n+  public boolean mkdirs()\n   {\n-    checkWrite ();\n-    if (isDirectory ())\n+    checkWrite();\n+    if (isDirectory())\n       return false;\n     return mkdirs (new File (path));\n   }\n \n-  private static synchronized String nextValue ()\n+  private static synchronized String nextValue()\n   {\n     return Long.toString(counter++, Character.MAX_RADIX);\n   }\n@@ -993,31 +997,31 @@ public static File createTempFile (String prefix, String suffix,\n           throw new IOException (\"Cannot determine system temporary directory\"); \n \t\n         directory = new File (dirname);\n-        if (!directory.exists ())\n+        if (!directory.exists())\n           throw new IOException (\"System temporary directory \"\n-                                 + directory.getName () + \" does not exist.\");\n-        if (!directory.isDirectory ())\n+                                 + directory.getName() + \" does not exist.\");\n+        if (!directory.isDirectory())\n           throw new IOException (\"System temporary directory \"\n-                                 + directory.getName ()\n+                                 + directory.getName()\n                                  + \" is not really a directory.\");\n       }\n \n     // Now process the prefix and suffix.\n-    if (prefix.length () < 3)\n+    if (prefix.length() < 3)\n       throw new IllegalArgumentException (\"Prefix too short: \" + prefix);\n \n     if (suffix == null)\n       suffix = \".tmp\";\n \n     // Truncation rules.\n     // `6' is the number of characters we generate.\n-    if (prefix.length () + 6 + suffix.length () > maxPathLen)\n+    if (prefix.length() + 6 + suffix.length() > maxPathLen)\n       {\n \tint suf_len = 0;\n \tif (suffix.charAt(0) == '.')\n \t  suf_len = 4;\n \tsuffix = suffix.substring(0, suf_len);\n-\tif (prefix.length () + 6 + suf_len > maxPathLen)\n+\tif (prefix.length() + 6 + suf_len > maxPathLen)\n \t  prefix = prefix.substring(0, maxPathLen - 6 - suf_len);\n       }\n \n@@ -1027,7 +1031,7 @@ public static File createTempFile (String prefix, String suffix,\n     for (int i = 0; i < 100; ++i)\n       {\n \t// This is ugly.\n-\tString t = \"ZZZZZZ\" + nextValue ();\n+\tString t = \"ZZZZZZ\" + nextValue();\n \tString l = prefix + t.substring(t.length() - 6) + suffix;\n \ttry\n \t  {\n@@ -1062,9 +1066,9 @@ public static File createTempFile (String prefix, String suffix,\n    *\n    * @since 1.2\n    */\n-  public boolean setReadOnly ()\n+  public boolean setReadOnly()\n   {\n-    checkWrite ();\n+    checkWrite();\n     return performSetReadOnly();\n   }\n \n@@ -1081,7 +1085,7 @@ public boolean setReadOnly ()\n    *\n    * @since 1.2\n    */\n-  public static File[] listRoots ()\n+  public static File[] listRoots()\n   {\n     File[] roots = performListRoots();\n     \n@@ -1256,23 +1260,23 @@ public boolean setLastModified (long time)\n     if (time < 0)\n       throw new IllegalArgumentException(\"Negative modification time: \" + time);\n \n-    checkWrite ();\n+    checkWrite();\n     return performSetLastModified(time);\n   }\n \n-  private void checkWrite ()\n+  private void checkWrite()\n   {\n     // Check the SecurityManager\n-    SecurityManager s = System.getSecurityManager ();\n+    SecurityManager s = System.getSecurityManager();\n     \n     if (s != null)\n       s.checkWrite (path);\n   }\n \n-  private void checkRead ()\n+  private void checkRead()\n   {\n     // Check the SecurityManager\n-    SecurityManager s = System.getSecurityManager ();\n+    SecurityManager s = System.getSecurityManager();\n     \n     if (s != null)\n       s.checkRead (path);\n@@ -1287,33 +1291,34 @@ private void checkRead ()\n    * @since 1.2 \n    */\n   // FIXME: This should use the ShutdownHook API once we implement that.\n-  public void deleteOnExit ()\n+  public void deleteOnExit()\n   {\n     // Check the SecurityManager\n-    SecurityManager sm = System.getSecurityManager ();\n+    SecurityManager sm = System.getSecurityManager();\n     if (sm != null)\n-      sm.checkDelete (getName ());\n+      sm.checkDelete (getName());\n \n     FileDeleter.add (this);\n   }\n \n   private void writeObject (ObjectOutputStream oos) throws IOException\n   {\n-    oos.defaultWriteObject ();\n+    oos.defaultWriteObject();\n     oos.writeChar (separatorChar);\n   }\n \n   private void readObject (ObjectInputStream ois)\n     throws ClassNotFoundException, IOException\n   {\n-    ois.defaultReadObject ();\n+    ois.defaultReadObject();\n \n     // If the file was from an OS with a different dir separator,\n     // fixup the path to use the separator on this OS.\n-    char oldSeparatorChar = ois.readChar ();\n+    char oldSeparatorChar = ois.readChar();\n     \n     if (oldSeparatorChar != separatorChar)\n       path = path.replace (oldSeparatorChar, separatorChar);\n   }\n+  \n } // class File\n "}]}