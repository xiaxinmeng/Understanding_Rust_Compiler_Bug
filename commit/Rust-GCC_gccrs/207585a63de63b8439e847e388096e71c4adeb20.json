{"sha": "207585a63de63b8439e847e388096e71c4adeb20", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjA3NTg1YTYzZGU2M2I4NDM5ZTg0N2UzODgwOTZlNzFjNGFkZWIyMA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely.gcc@gmail.com", "date": "2012-11-19T21:33:52Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2012-11-19T21:33:52Z"}, "message": "hashtable.h: Improve comments.\n\n\t* include/bits/hashtable.h: Improve comments.\n\t* include/bits/hashtable_policy.h: Likewise.\n\nFrom-SVN: r193636", "tree": {"sha": "2276bb1ac1d3bf4bb3525dd917968fde2774668f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2276bb1ac1d3bf4bb3525dd917968fde2774668f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/207585a63de63b8439e847e388096e71c4adeb20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/207585a63de63b8439e847e388096e71c4adeb20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/207585a63de63b8439e847e388096e71c4adeb20", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/207585a63de63b8439e847e388096e71c4adeb20/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f4340fe3b4c1e6d5f0837470b049b44c105bc99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f4340fe3b4c1e6d5f0837470b049b44c105bc99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f4340fe3b4c1e6d5f0837470b049b44c105bc99"}], "stats": {"total": 60, "additions": 32, "deletions": 28}, "files": [{"sha": "9c5b23a8d527eb1c0ac8b20db67ccfc65db97dbb", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/207585a63de63b8439e847e388096e71c4adeb20/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/207585a63de63b8439e847e388096e71c4adeb20/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=207585a63de63b8439e847e388096e71c4adeb20", "patch": "@@ -1,3 +1,8 @@\n+2012-11-19  Jonathan Wakely  <jwakely.gcc@gmail.com>\n+\n+\t* include/bits/hashtable.h: Improve comments.\n+\t* include/bits/hashtable_policy.h: Likewise.\n+\n 2012-11-17  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR libstdc++/55363"}, {"sha": "6242e20663ae4f74a47abe8bbea3655908c40558", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/207585a63de63b8439e847e388096e71c4adeb20/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/207585a63de63b8439e847e388096e71c4adeb20/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=207585a63de63b8439e847e388096e71c4adeb20", "patch": "@@ -103,48 +103,48 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    *  - size_type       _M_bucket_count\n    *  - size_type       _M_element_count\n    *\n-   *  with _Bucket being _Hash_node* and _Hash_node constaining:\n+   *  with _Bucket being _Hash_node* and _Hash_node containing:\n    *\n    *  - _Hash_node*   _M_next\n    *  - Tp            _M_value\n-   *  - size_t        _M_code if cache_hash_code is true\n+   *  - size_t        _M_hash_code if cache_hash_code is true\n    *\n-   *  In terms of Standard containers the hastable is like the aggregation of:\n+   *  In terms of Standard containers the hashtable is like the aggregation of:\n    *\n    *  - std::forward_list<_Node> containing the elements\n    *  - std::vector<std::forward_list<_Node>::iterator> representing the buckets\n    *\n-   *  The non-empty buckets contain the node before the first bucket\n-   *  node. This design allow to implement something like a\n+   *  The non-empty buckets contain the node before the first node in the\n+   *  bucket. This design makes it possible to implement something like a\n    *  std::forward_list::insert_after on container insertion and\n    *  std::forward_list::erase_after on container erase\n    *  calls. _M_before_begin is equivalent to\n-   *  std::foward_list::before_begin. Empty buckets are containing\n-   *  nullptr.  Note that one of the non-empty bucket contains\n-   *  &_M_before_begin which is not a derefenrenceable node so the\n-   *  node pointers in buckets shall never be derefenrenced, only its\n+   *  std::forward_list::before_begin. Empty buckets contain\n+   *  nullptr.  Note that one of the non-empty buckets contains\n+   *  &_M_before_begin which is not a dereferenceable node so the\n+   *  node pointer in a bucket shall never be dereferenced, only its\n    *  next node can be.\n    *\n-   *  Walk through a bucket nodes require a check on the hash code to\n-   *  see if the node is still in the bucket. Such a design impose a\n+   *  Walking through a bucket's nodes requires a check on the hash code to\n+   *  see if each node is still in the bucket. Such a design assumes a\n    *  quite efficient hash functor and is one of the reasons it is\n-   *  highly advise to set __cache_hash_code to true.\n+   *  highly advisable to set __cache_hash_code to true.\n    *\n    *  The container iterators are simply built from nodes. This way\n    *  incrementing the iterator is perfectly efficient independent of\n    *  how many empty buckets there are in the container.\n    *\n-   *  On insert we compute element hash code and thanks to it find the\n-   *  bucket index. If the element must be inserted on an empty bucket\n+   *  On insert we compute the element's hash code and use it to find the\n+   *  bucket index. If the element must be inserted in an empty bucket\n    *  we add it at the beginning of the singly linked list and make the\n    *  bucket point to _M_before_begin. The bucket that used to point to\n    *  _M_before_begin, if any, is updated to point to its new before\n    *  begin node.\n    *\n-   *  On erase, the simple iterator design impose to use the hash\n+   *  On erase, the simple iterator design requires using the hash\n    *  functor to get the index of the bucket to update. For this\n-   *  reason, when __cache_hash_code is set to false, there is a static\n-   *  assertion that the hash functor cannot throw.\n+   *  reason, when __cache_hash_code is set to false the hash functor must\n+   *  not throw and this is enforced by a static assertion.\n    *\n    *  Functionality is implemented by decomposition into base classes,\n    *  where the derived _Hashtable class is used in _Map_base,\n@@ -1045,8 +1045,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    ++__result;\n \t  else if (__result)\n \t    // All equivalent values are next to each other, if we\n-\t    // found a not equivalent value after an equivalent one it\n-\t    // means that we won't find anymore an equivalent value.\n+\t    // found a non-equivalent value after an equivalent one it\n+\t    // means that we won't find any more equivalent values.\n \t    break;\n \t  if (!__p->_M_nxt || _M_bucket_index(__p->_M_next()) != __n)\n \t    break;\n@@ -1168,7 +1168,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       else\n \t{\n \t  // The bucket is empty, the new node is inserted at the\n-\t  // beginning of the singly linked list and the bucket will\n+\t  // beginning of the singly-linked list and the bucket will\n \t  // contain _M_before_begin pointer.\n \t  __node->_M_nxt = _M_before_begin()._M_nxt;\n \t  _M_before_begin()._M_nxt = __node;\n@@ -1366,7 +1366,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    // The inserted node has no equivalent in the\n \t    // hashtable. We must insert the new node at the\n \t    // beginning of the bucket to preserve equivalent\n-\t    // elements relative positions.\n+\t    // elements' relative positions.\n \t    _M_insert_bucket_begin(__bkt, __node);\n \t  ++_M_element_count;\n \t  return iterator(__node);\n@@ -1443,7 +1443,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       // Look for previous node to unlink it from the erased one, this\n       // is why we need buckets to contain the before begin to make\n-      // this research fast.\n+      // this search fast.\n       __node_base* __prev_n = _M_get_previous_node(__bkt, __n);\n       return _M_erase(__bkt, __prev_n, __n);\n     }"}, {"sha": "023f46df89aa5849327bc58d98e68c6242dda413", "filename": "libstdc++-v3/include/bits/hashtable_policy.h", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/207585a63de63b8439e847e388096e71c4adeb20/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/207585a63de63b8439e847e388096e71c4adeb20/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h?ref=207585a63de63b8439e847e388096e71c4adeb20", "patch": "@@ -79,8 +79,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return __distance_fw(__first, __last, _Tag());\n     }\n \n-  // Helper type used to detect when the hash functor is noexcept qualified or\n-  // not\n+  // Helper type used to detect whether the hash functor is noexcept.\n   template <typename _Key, typename _Hash>\n     struct __is_noexcept_hash : std::integral_constant<bool,\n \tnoexcept(declval<const _Hash&>()(declval<const _Key&>()))>\n@@ -111,20 +110,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    *\n    *  Important traits for hash tables.\n    *\n-   *  @tparam __cache_hash_code  Boolean value. True if the value of\n+   *  @tparam _Cache_hash_code  Boolean value. True if the value of\n    *  the hash function is stored along with the value. This is a\n    *  time-space tradeoff.  Storing it may improve lookup speed by\n    *  reducing the number of times we need to call the _Equal\n    *  function.\n    *\n-   *  @tparam __constant_iterators  Boolean value. True if iterator and\n+   *  @tparam _Constant_iterators  Boolean value. True if iterator and\n    *  const_iterator are both constant iterator types. This is true\n    *  for unordered_set and unordered_multiset, false for\n    *  unordered_map and unordered_multimap.\n    *\n-   *  @tparam __unique_keys  Boolean value. True if the return value\n+   *  @tparam _Unique_keys  Boolean value. True if the return value\n    *  of _Hashtable::count(k) is always at most one, false if it may\n-   *  be an arbitrary number. This true for unordered_set and\n+   *  be an arbitrary number. This is true for unordered_set and\n    *  unordered_map, false for unordered_multiset and\n    *  unordered_multimap.\n    */"}]}