{"sha": "421d0d0f54294a7bf2872b3b2ac521ce0fa9869e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDIxZDBkMGY1NDI5NGE3YmYyODcyYjNiMmFjNTIxY2UwZmE5ODY5ZQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-11-12T22:28:17Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-11-12T22:30:01Z"}, "message": "jit: add support for inline asm [PR87291]\n\nThis patch adds various entrypoints to libgccjit for directly embedding\nasm statements into a compile, analogous to inline asm in the C frontend:\n  gcc_jit_block_add_extended_asm\n  gcc_jit_block_end_with_extended_asm_goto\n  gcc_jit_extended_asm_as_object\n  gcc_jit_extended_asm_set_volatile_flag\n  gcc_jit_extended_asm_set_inline_flag\n  gcc_jit_extended_asm_add_output_operand\n  gcc_jit_extended_asm_add_input_operand\n  gcc_jit_extended_asm_add_clobber\n  gcc_jit_context_add_top_level_asm\n\ngcc/jit/ChangeLog:\n\tPR jit/87291\n\t* docs/cp/topics/asm.rst: New file.\n\t* docs/cp/topics/index.rst (Topic Reference): Add it.\n\t* docs/topics/asm.rst: New file.\n\t* docs/topics/compatibility.rst (LIBGCCJIT_ABI_15): New.\n\t* docs/topics/functions.rst (Statements): Add link to extended\n\tasm.\n\t* docs/topics/index.rst (Topic Reference): Add asm.rst.\n\t* docs/topics/objects.rst: Add gcc_jit_extended_asm to ASCII art.\n\t* docs/_build/texinfo/Makefile: Regenerate.\n\t* docs/_build/texinfo/libgccjit.texi: Regenerate.\n\t* jit-common.h (gcc::jit::recording::extended_asm): New forward\n\tdecl.\n\t(gcc::jit::recording::top_level_asm): Likewise.\n\t* jit-playback.c: Include \"stmt.h\".\n\t(build_string): New.\n\t(gcc::jit::playback::context::new_string_literal): Disambiguate\n\tbuild_string call.\n\t(gcc::jit::playback::context::add_top_level_asm): New.\n\t(build_operand_chain): New.\n\t(build_clobbers): New.\n\t(build_goto_operands): New.\n\t(gcc::jit::playback::block::add_extended_asm): New.\n\t* jit-playback.h (gcc::jit::playback::context::add_top_level_asm):\n\tNew decl.\n\t(struct gcc::jit::playback::asm_operand): New struct.\n\t(gcc::jit::playback::block::add_extended_asm): New decl.\n\t* jit-recording.c (gcc::jit::recording::context::dump_to_file):\n\tDump top-level asms.\n\t(gcc::jit::recording::context::add_top_level_asm): New.\n\t(gcc::jit::recording::block::add_extended_asm): New.\n\t(gcc::jit::recording::block::end_with_extended_asm_goto): New.\n\t(gcc::jit::recording::asm_operand::asm_operand): New.\n\t(gcc::jit::recording::asm_operand::print): New.\n\t(gcc::jit::recording::asm_operand::make_debug_string): New.\n\t(gcc::jit::recording::output_asm_operand::write_reproducer): New.\n\t(gcc::jit::recording::output_asm_operand::print): New.\n\t(gcc::jit::recording::input_asm_operand::write_reproducer): New.\n\t(gcc::jit::recording::input_asm_operand::print): New.\n\t(gcc::jit::recording::extended_asm::add_output_operand): New.\n\t(gcc::jit::recording::extended_asm::add_input_operand): New.\n\t(gcc::jit::recording::extended_asm::add_clobber): New.\n\t(gcc::jit::recording::extended_asm::replay_into): New.\n\t(gcc::jit::recording::extended_asm::make_debug_string): New.\n\t(gcc::jit::recording::extended_asm::write_flags): New.\n\t(gcc::jit::recording::extended_asm::write_clobbers): New.\n\t(gcc::jit::recording::extended_asm_simple::write_reproducer): New.\n\t(gcc::jit::recording::extended_asm::maybe_populate_playback_blocks):\n\tNew.\n\t(gcc::jit::recording::extended_asm_goto::extended_asm_goto): New.\n\t(gcc::jit::recording::extended_asm_goto::replay_into): New.\n\t(gcc::jit::recording::extended_asm_goto::write_reproducer): New.\n\t(gcc::jit::recording::extended_asm_goto::get_successor_blocks):\n\tNew.\n\t(gcc::jit::recording::extended_asm_goto::maybe_print_gotos): New.\n\t(gcc::jit::recording::extended_asm_goto::maybe_populate_playback_blocks):\n\tNew.\n\t(gcc::jit::recording::top_level_asm::top_level_asm): New.\n\t(gcc::jit::recording::top_level_asm::replay_into): New.\n\t(gcc::jit::recording::top_level_asm::make_debug_string): New.\n\t(gcc::jit::recording::top_level_asm::write_to_dump): New.\n\t(gcc::jit::recording::top_level_asm::write_reproducer): New.\n\t* jit-recording.h\n\t(gcc::jit::recording::context::add_top_level_asm): New decl.\n\t(gcc::jit::recording::context::m_top_level_asms): New field.\n\t(gcc::jit::recording::block::add_extended_asm): New decl.\n\t(gcc::jit::recording::block::end_with_extended_asm_goto): New\n\tdecl.\n\t(gcc::jit::recording::asm_operand): New class.\n\t(gcc::jit::recording::output_asm_operand): New class.\n\t(gcc::jit::recording::input_asm_operand): New class.\n\t(gcc::jit::recording::extended_asm): New class.\n\t(gcc::jit::recording::extended_asm_simple): New class.\n\t(gcc::jit::recording::extended_asm_goto): New class.\n\t(gcc::jit::recording::top_level_asm): New class.\n\t* libgccjit++.h (gccjit::extended_asm): New forward decl.\n\t(gccjit::context::add_top_level_asm): New.\n\t(gccjit::block::add_extended_asm): New.\n\t(gccjit::block::end_with_extended_asm_goto): New.\n\t(gccjit::extended_asm): New class.\n\t(gccjit::extended_asm::extended_asm): New ctors.\n\t(gccjit::extended_asm::set_volatile_flag): New.\n\t(gccjit::extended_asm::set_inline_flag): New.\n\t(gccjit::extended_asm::add_output_operand): New.\n\t(gccjit::extended_asm::add_input_operand): New.\n\t(gccjit::extended_asm::add_clobber): New.\n\t(gccjit::extended_asm::get_inner_extended_asm): New.\n\t* libgccjit.c (struct gcc_jit_extended_asm): New.\n\t(jit_error): Make \"loc\" param take a gcc::jit::recording::location *\n\trather than a gcc_jit_location *.\n\t(gcc_jit_block_add_extended_asm): New entrypoint.\n\t(gcc_jit_block_end_with_extended_asm_goto): New entrypoint.\n\t(gcc_jit_extended_asm_as_object): New entrypoint.\n\t(gcc_jit_extended_asm_set_volatile_flag): New entrypoint.\n\t(gcc_jit_extended_asm_set_inline_flag): New entrypoint.\n\t(gcc_jit_extended_asm_add_output_operand): New entrypoint.\n\t(gcc_jit_extended_asm_add_clobber): New entrypoint.\n\t(gcc_jit_context_add_top_level_asm): New entrypoint.\n\t* libgccjit.h: Add gcc_jit_extended_asm to ASCII art.\n\t(gcc_jit_extended_asm): New typedef.\n\t(LIBGCCJIT_HAVE_ASM_STATEMENTS): New define.\n\t(gcc_jit_block_add_extended_asm): New entrypoint.\n\t(gcc_jit_block_end_with_extended_asm_goto): New entrypoint.\n\t(gcc_jit_extended_asm_as_object): New entrypoint.\n\t(gcc_jit_extended_asm_set_volatile_flag): New entrypoint.\n\t(gcc_jit_extended_asm_set_inline_flag): New entrypoint.\n\t(gcc_jit_extended_asm_add_output_operand): New entrypoint.\n\t(gcc_jit_extended_asm_add_input_operand): New entrypoint.\n\t(gcc_jit_extended_asm_add_clobber): New entrypoint.\n\t(gcc_jit_context_add_top_level_asm): New entrypoint.\n\t* libgccjit.map (LIBGCCJIT_ABI_15): New.\n\ngcc/testsuite/ChangeLog:\n\tPR jit/87291\n\t* jit.dg/jit.exp: Load target-supports-dg.exp.\n\tSet dg-do-what-default.\n\t(jit-dg-test): Set dg-do-what and call dg-get-options, skipping\n\tthe test if it's not supported on the given target.\n\t* jit.dg/test-asm.c: New test.\n\t* jit.dg/test-asm.cc: New test.", "tree": {"sha": "750ae2f9567352ed7762d896424c2194c324f208", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/750ae2f9567352ed7762d896424c2194c324f208"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fec573408310139e1ffc42741fbe46b4f2947592", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fec573408310139e1ffc42741fbe46b4f2947592", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fec573408310139e1ffc42741fbe46b4f2947592"}], "stats": {"total": 4823, "additions": 4318, "deletions": 505}, "files": [{"sha": "e3b732cda78a79650901b3afc52a5a88359d6fe8", "filename": "gcc/jit/docs/_build/texinfo/Makefile", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2FMakefile", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2FMakefile", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2FMakefile?ref=421d0d0f54294a7bf2872b3b2ac521ce0fa9869e", "patch": "@@ -18,13 +18,20 @@ pdf: $(addsuffix .pdf,$(ALLDOCS))\n \n install-info: info\n \tfor f in *.info; do \\\n-\t  cp -t $(infodir) \"$$f\" && \\\n-\t  $(INSTALL_INFO) --info-dir=$(infodir) \"$$f\" ; \\\n+\t  mkdir -p $(infodir) && \\\n+\t  cp \"$$f\" $(infodir) && \\\n+\t  $(INSTALL_INFO) --info-dir=$(infodir) \"$$f\" && \\\n+\t  \\\n+\t  FIGURE_DIR=\"`basename \\\"$$f\\\" .info`-figures\" && \\\n+\t  if [ -e \"$$FIGURE_DIR\" ]; then \\\n+\t    cp -r \"$$FIGURE_DIR\" $(infodir) ; \\\n+\t  fi; \\\n \tdone\n \n uninstall-info: info\n \tfor f in *.info; do \\\n \t  rm -f \"$(infodir)/$$f\"  ; \\\n+\t  rm -rf \"$(infodir)/`basename '$$f' .info`-figures\" && \\\n \t  $(INSTALL_INFO) --delete --info-dir=$(infodir) \"$$f\" ; \\\n \tdone\n "}, {"sha": "7b957b79c945083dee3442ca34b64ee14318c42c", "filename": "gcc/jit/docs/_build/texinfo/libgccjit.texi", "status": "modified", "additions": 1337, "deletions": 500, "changes": 1837, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Flibgccjit.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Flibgccjit.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Flibgccjit.texi?ref=421d0d0f54294a7bf2872b3b2ac521ce0fa9869e"}, {"sha": "69e2d1e8da780ae866c796c9da6697c16f29cd33", "filename": "gcc/jit/docs/cp/topics/asm.rst", "status": "added", "additions": 308, "deletions": 0, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fasm.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fasm.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fasm.rst?ref=421d0d0f54294a7bf2872b3b2ac521ce0fa9869e", "patch": "@@ -0,0 +1,308 @@\n+.. Copyright (C) 2020 Free Software Foundation, Inc.\n+   Originally contributed by David Malcolm <dmalcolm@redhat.com>\n+\n+   This is free software: you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see\n+   <http://www.gnu.org/licenses/>.\n+\n+.. default-domain:: cpp\n+\n+Using Assembly Language with libgccjit++\n+========================================\n+\n+libgccjit has some support for directly embedding assembler instructions.\n+This is based on GCC's support for inline ``asm`` in C code, and the\n+following assumes a familiarity with that functionality.  See\n+`How to Use Inline Assembly Language in C Code <https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html>`_\n+in GCC's documentation, the \"Extended Asm\" section in particular.\n+\n+These entrypoints were added in :ref:`LIBGCCJIT_ABI_15`; you can test\n+for their presence using\n+\n+   .. code-block:: c\n+\n+      #ifdef LIBGCCJIT_HAVE_ASM_STATEMENTS\n+\n+Adding assembler instructions within a function\n+***********************************************\n+\n+.. class:: gccjit::extended_asm\n+\n+   A `gccjit::extended_asm` represents an extended ``asm`` statement: a\n+   series of low-level instructions inside a function that convert inputs\n+   to outputs.\n+\n+   :class:`gccjit::extended_asm` is a subclass of :class:`gccjit::object`.\n+   It is a thin wrapper around the C API's :c:type:`gcc_jit_extended_asm *`.\n+\n+   To avoid having an API entrypoint with a very large number of\n+   parameters, an extended ``asm`` statement is made in stages:\n+   an initial call to create the :type:`gccjit::extended_asm`,\n+   followed by calls to add operands and set other properties of the\n+   statement.\n+\n+   There are two API entrypoints for creating a :type:`gccjit::extended_asm`:\n+\n+   * :func:`gccjit::block::add_extended_asm` for an ``asm`` statement with\n+     no control flow, and\n+\n+   * :func:`gccjit::block::end_with_extended_asm_goto` for an ``asm goto``.\n+\n+   For example, to create the equivalent of:\n+\n+   .. literalinclude:: ../../../../testsuite/jit.dg/test-asm.cc\n+      :start-after: // Quote from here in docs/cp/topics/asm.rst: example 1: C\n+      :end-before: // Quote up to here in docs/cp/topics/asm.rst: example 1: C\n+      :language: c\n+\n+   the following API calls could be used:\n+\n+   .. literalinclude:: ../../../../testsuite/jit.dg/test-asm.cc\n+      :start-after: /* Quote from here in docs/cp/topics/asm.rst: example 1: jit.  */\n+      :end-before: /* Quote up to here in docs/cp/topics/asm.rst: example 1: jit.  */\n+      :language: c\n+\n+   .. warning::  When considering the numbering of operands within an\n+\t\t extended ``asm`` statement (e.g. the ``%0`` and ``%1``\n+\t\t above), the equivalent to the C syntax is followed i.e. all\n+\t\t output operands, then all input operands, regardless of\n+\t\t what order the calls to\n+\t\t :func:`gccjit::extended_asm::add_output_operand` and\n+\t\t :func:`gccjit::extended_asm::add_input_operand` were made in.\n+\n+   As in the C syntax, operands can be given symbolic names to avoid having\n+   to number them.  For example, to create the equivalent of:\n+\n+   .. literalinclude:: ../../../../testsuite/jit.dg/test-asm.cc\n+      :start-after: // Quote from here in docs/cp/topics/asm.rst: example 2: C\n+      :end-before: // Quote up to here in docs/cp/topics/asm.rst: example 2: C\n+      :language: c\n+\n+   the following API calls could be used:\n+\n+   .. literalinclude:: ../../../../testsuite/jit.dg/test-asm.cc\n+      :start-after: /* Quote from here in docs/cp/topics/asm.rst: example 2: jit.  */\n+      :end-before: /* Quote up to here in docs/cp/topics/asm.rst: example 2: jit.  */\n+      :language: c\n+\n+.. function:: extended_asm \\\n+\t      gccjit::block::add_extended_asm (const std::string &asm_template,\\\n+                                               gccjit::location loc = location ())\n+\n+   Create a :type:`gccjit::extended_asm` for an extended ``asm`` statement\n+   with no control flow (i.e. without the ``goto`` qualifier).\n+\n+   The parameter ``asm_template`` corresponds to the `AssemblerTemplate`\n+   within C's extended ``asm`` syntax.  It must be non-NULL.  The call takes\n+   a copy of the underlying string, so it is valid to pass in a pointer to\n+   an on-stack buffer.\n+\n+.. function:: extended_asm\\\n+              gccjit::block::end_with_extended_asm_goto (const std::string &asm_template,\\\n+                                                         std::vector<block> goto_blocks,\\\n+                                                         block *fallthrough_block,\\\n+                                                         location loc = location ())\n+\n+   Create a :type:`gccjit::extended_asm` for an extended ``asm`` statement\n+   that may perform jumps, and use it to terminate the given block.\n+   This is equivalent to the ``goto`` qualifier in C's extended ``asm``\n+   syntax.\n+\n+   For example, to create the equivalent of:\n+\n+   .. literalinclude:: ../../../../testsuite/jit.dg/test-asm.cc\n+      :start-after: // Quote from here in docs/cp/topics/asm.rst: example 3b: C\n+      :end-before: // Quote up to here in docs/cp/topics/asm.rst: example 3b: C\n+      :language: c\n+\n+   the following API calls could be used:\n+\n+   .. literalinclude:: ../../../../testsuite/jit.dg/test-asm.cc\n+      :start-after: /* Quote from here in docs/cp/topics/asm.rst: example 3: jit.  */\n+      :end-before: /* Quote up to here in docs/cp/topics/asm.rst: example 3: jit.  */\n+      :language: c\n+\n+   here referencing a :type:`gcc_jit_block` named \"carry\".\n+\n+   ``num_goto_blocks`` corresponds to the ``GotoLabels`` parameter within C's\n+   extended ``asm`` syntax.  The block names can be referenced within the\n+   assembler template.\n+\n+   ``fallthrough_block`` can be NULL.  If non-NULL, it specifies the block\n+   to fall through to after the statement.\n+\n+   .. note:: This is needed since each :type:`gccjit::block` must have a\n+\t     single exit point, as a basic block: you can't jump from the\n+\t     middle of a block.  A \"goto\" is implicitly added after the\n+\t     asm to handle the fallthrough case, which is equivalent to what\n+\t     would have happened in the C case.\n+\n+.. function:: gccjit::extended_asm &\\\n+\t      gccjit::extended_asm::set_volatile_flag (bool flag)\n+\n+   Set whether the :type:`gccjit::extended_asm` has side-effects, equivalent to the\n+   `volatile <https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#Volatile>`_\n+   qualifier in C's extended asm syntax.\n+\n+   For example, to create the equivalent of:\n+\n+   .. code-block:: c\n+\n+      asm volatile (\"rdtsc\\n\\t\"    // Returns the time in EDX:EAX.\n+                     \"shl $32, %%rdx\\n\\t\"  // Shift the upper bits left.\n+                     \"or %%rdx, %0\"        // 'Or' in the lower bits.\n+                     : \"=a\" (msr)\n+                     :\n+                     : \"rdx\");\n+\n+   the following API calls could be used:\n+\n+   .. literalinclude:: ../../../../testsuite/jit.dg/test-asm.cc\n+      :start-after: /* Quote from here in docs/cp/topics/asm.rst: example 4: jit.  */\n+      :end-before: /* Quote up to here in docs/cp/topics/asm.rst: example 4: jit.  */\n+      :language: c\n+\n+   where the :type:`gccjit::extended_asm` is flagged as volatile.\n+\n+.. function::  gccjit::extended_asm &\\\n+\t       gccjit::extended_asm::set_inline_flag (bool flag)\n+\n+   Set the equivalent of the\n+   `inline <https://gcc.gnu.org/onlinedocs/gcc/Size-of-an-asm.html#Size-of-an-asm>`_\n+   qualifier in C's extended ``asm`` syntax.\n+\n+.. function:: gccjit::extended_asm&\\\n+\t      gccjit::extended_asm::add_output_operand (const std::string &asm_symbolic_name,\\\n+                                                        const std::string &constraint,\\\n+                                                        gccjit::lvalue dest)\n+\n+   Add an output operand to the extended ``asm`` statement.  See the\n+   `Output Operands <https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#OutputOperands>`_\n+   section of the documentation of the C syntax.\n+\n+   ``asm_symbolic_name`` corresponds to the ``asmSymbolicName`` component of\n+   C's extended ``asm`` syntax, and specifies the symbolic name for the operand.\n+   See the overload below for an alternative that does not supply a symbolic\n+   name.\n+\n+   ``constraint`` corresponds to the ``constraint`` component of C's extended\n+   ``asm`` syntax.\n+\n+   ``dest`` corresponds to the ``cvariablename`` component of C's extended\n+   ``asm`` syntax.\n+\n+   .. code-block:: c++\n+\n+      // Example with a symbolic name (\"aIndex\"), the equivalent of:\n+      //   : [aIndex] \"=r\" (index)\n+      ext_asm.add_output_operand (\"aIndex\", \"=r\", index);\n+\n+   This function can't be called on an ``asm goto`` as such instructions can't\n+   have outputs; see the\n+   `Goto Labels <https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#GotoLabels>`_\n+   section of GCC's \"Extended Asm\" documentation.\n+\n+.. function:: gccjit::extended_asm&\\\n+              gccjit::extended_asm::add_output_operand (const std::string &constraint,\\\n+                                                        gccjit::lvalue dest)\n+\n+   As above, but don't supply a symbolic name for the operand.\n+\n+   .. code-block:: c++\n+\n+      // Example without a symbolic name, the equivalent of:\n+      //   : \"=r\" (dst)\n+      ext_asm.add_output_operand (\"=r\", dst);\n+\n+.. function:: gccjit::extended_asm&\\\n+              gccjit::extended_asm::add_input_operand (const std::string &asm_symbolic_name, \\\n+                                                       const std::string &constraint, \\\n+                                                       gccjit::rvalue src)\n+\n+   Add an input operand to the extended ``asm`` statement.  See the\n+   `Input Operands <https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#InputOperands>`_\n+   section of the documentation of the C syntax.\n+\n+   ``asm_symbolic_name`` corresponds to the ``asmSymbolicName`` component\n+   of C's extended ``asm`` syntax.  See the overload below for an alternative\n+   that does not supply a symbolic name.\n+\n+   ``constraint`` corresponds to the ``constraint`` component of C's extended\n+   ``asm`` syntax.\n+\n+   ``src`` corresponds to the ``cexpression`` component of C's extended\n+   ``asm`` syntax.\n+\n+   .. code-block:: c++\n+\n+      // Example with a symbolic name (\"aMask\"), the equivalent of:\n+      //   : [aMask] \"r\" (Mask)\n+      ext_asm.add_input_operand (\"aMask\", \"r\", mask);\n+\n+.. function:: gccjit::extended_asm&\\\n+              gccjit::extended_asm::add_input_operand (const std::string &constraint,\\\n+                                                       gccjit::rvalue src)\n+\n+   As above, but don't supply a symbolic name for the operand.\n+\n+   .. code-block:: c++\n+\n+      // Example without a symbolic name, the equivalent of:\n+      //   : \"r\" (src)\n+      ext_asm.add_input_operand (\"r\", src);\n+\n+.. function:: gccjit::extended_asm&\\\n+              gccjit::extended_asm::add_clobber (const std::string &victim)\n+\n+   Add `victim` to the list of registers clobbered by the extended ``asm``\n+   statement.  See the\n+   `Clobbers and Scratch Registers <https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#Clobbers-and-Scratch-Registers#>`_\n+   section of the documentation of the C syntax.\n+\n+   Statements with multiple clobbers will require multiple calls, one per\n+   clobber.\n+\n+   For example:\n+\n+   .. code-block:: c++\n+\n+     ext_asm.add_clobber (\"r0\").add_clobber (\"cc\").add_clobber (\"memory\");\n+\n+\n+Adding top-level assembler statements\n+*************************************\n+\n+In addition to creating extended ``asm`` instructions within a function,\n+there is support for creating \"top-level\" assembler statements, outside\n+of any function.\n+\n+.. function:: void\\\n+              gccjit::context::add_top_level_asm (const char *asm_stmts,\\\n+                                                  gccjit::location loc = location ())\n+\n+   Create a set of top-level asm statements, analogous to those created\n+   by GCC's \"basic\" ``asm`` syntax in C at file scope.\n+\n+   For example, to create the equivalent of:\n+\n+   .. literalinclude:: ../../../../testsuite/jit.dg/test-asm.cc\n+      :start-after: // Quote from here in docs/cp/topics/asm.rst: example 5: C\n+      :end-before: // Quote up to here in docs/cp/topics/asm.rst: example 5: C\n+      :language: c\n+\n+   the following API calls could be used:\n+\n+   .. literalinclude:: ../../../../testsuite/jit.dg/test-asm.cc\n+      :start-after: /* Quote from here in docs/cp/topics/asm.rst: example 5: jit.  */\n+      :end-before: /* Quote up to here in docs/cp/topics/asm.rst: example 5: jit.  */\n+      :language: c"}, {"sha": "721e70cfa1b355127b0fee4836eb12af4589041b", "filename": "gcc/jit/docs/cp/topics/index.rst", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Findex.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Findex.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Findex.rst?ref=421d0d0f54294a7bf2872b3b2ac521ce0fa9869e", "patch": "@@ -28,3 +28,4 @@ Topic Reference\n    functions.rst\n    locations.rst\n    compilation.rst\n+   asm.rst"}, {"sha": "b91514d4140ac0a65fc3bf24214afa1599369a1a", "filename": "gcc/jit/docs/topics/asm.rst", "status": "added", "additions": 311, "deletions": 0, "changes": 311, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Fjit%2Fdocs%2Ftopics%2Fasm.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Fjit%2Fdocs%2Ftopics%2Fasm.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Fasm.rst?ref=421d0d0f54294a7bf2872b3b2ac521ce0fa9869e", "patch": "@@ -0,0 +1,311 @@\n+.. Copyright (C) 2020 Free Software Foundation, Inc.\n+   Originally contributed by David Malcolm <dmalcolm@redhat.com>\n+\n+   This is free software: you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see\n+   <http://www.gnu.org/licenses/>.\n+\n+.. default-domain:: c\n+\n+Using Assembly Language with libgccjit\n+======================================\n+\n+libgccjit has some support for directly embedding assembler instructions.\n+This is based on GCC's support for inline ``asm`` in C code, and the\n+following assumes a familiarity with that functionality.  See\n+`How to Use Inline Assembly Language in C Code <https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html>`_\n+in GCC's documentation, the \"Extended Asm\" section in particular.\n+\n+These entrypoints were added in :ref:`LIBGCCJIT_ABI_15`; you can test\n+for their presence using\n+\n+   .. code-block:: c\n+\n+      #ifdef LIBGCCJIT_HAVE_ASM_STATEMENTS\n+\n+Adding assembler instructions within a function\n+***********************************************\n+\n+.. type:: gcc_jit_extended_asm\n+\n+   A `gcc_jit_extended_asm` represents an extended ``asm`` statement: a\n+   series of low-level instructions inside a function that convert inputs\n+   to outputs.\n+\n+   To avoid having an API entrypoint with a very large number of\n+   parameters, an extended ``asm`` statement is made in stages:\n+   an initial call to create the :type:`gcc_jit_extended_asm`,\n+   followed by calls to add operands and set other properties of the\n+   statement.\n+\n+   There are two API entrypoints for creating a :type:`gcc_jit_extended_asm`:\n+\n+   * :func:`gcc_jit_block_add_extended_asm` for an ``asm`` statement with\n+     no control flow, and\n+\n+   * :func:`gcc_jit_block_end_with_extended_asm_goto` for an ``asm goto``.\n+\n+   For example, to create the equivalent of:\n+\n+   .. literalinclude:: ../../../testsuite/jit.dg/test-asm.c\n+      :start-after: // Quote from here in docs/topics/asm.rst: example 1: C\n+      :end-before: // Quote up to here in docs/topics/asm.rst: example 1: C\n+      :language: c\n+\n+   the following API calls could be used:\n+\n+   .. literalinclude:: ../../../testsuite/jit.dg/test-asm.c\n+      :start-after: /* Quote from here in docs/topics/asm.rst: example 1: jit.  */\n+      :end-before: /* Quote up to here in docs/topics/asm.rst: example 1: jit.  */\n+      :language: c\n+\n+   .. warning::  When considering the numbering of operands within an\n+\t\t extended ``asm`` statement (e.g. the ``%0`` and ``%1``\n+\t\t above), the equivalent to the C syntax is followed i.e. all\n+\t\t output operands, then all input operands, regardless of\n+\t\t what order the calls to\n+\t\t :func:`gcc_jit_extended_asm_add_output_operand` and\n+\t\t :func:`gcc_jit_extended_asm_add_input_operand` were made in.\n+\n+   As in the C syntax, operands can be given symbolic names to avoid having\n+   to number them.  For example, to create the equivalent of:\n+\n+   .. literalinclude:: ../../../testsuite/jit.dg/test-asm.c\n+      :start-after: // Quote from here in docs/topics/asm.rst: example 2: C\n+      :end-before: // Quote up to here in docs/topics/asm.rst: example 2: C\n+      :language: c\n+\n+   the following API calls could be used:\n+\n+   .. literalinclude:: ../../../testsuite/jit.dg/test-asm.c\n+      :start-after: /* Quote from here in docs/topics/asm.rst: example 2: jit.  */\n+      :end-before: /* Quote up to here in docs/topics/asm.rst: example 2: jit.  */\n+      :language: c\n+\n+.. function:: gcc_jit_extended_asm *\\\n+              gcc_jit_block_add_extended_asm (gcc_jit_block *block,\\\n+                                              gcc_jit_location *loc,\\\n+                                              const char *asm_template)\n+\n+   Create a :type:`gcc_jit_extended_asm` for an extended ``asm`` statement\n+   with no control flow (i.e. without the ``goto`` qualifier).\n+\n+   The parameter ``asm_template`` corresponds to the `AssemblerTemplate`\n+   within C's extended ``asm`` syntax.  It must be non-NULL.  The call takes\n+   a copy of the underlying string, so it is valid to pass in a pointer to\n+   an on-stack buffer.\n+\n+.. function:: gcc_jit_extended_asm *\\\n+              gcc_jit_block_end_with_extended_asm_goto (gcc_jit_block *block,\\\n+                                                        gcc_jit_location *loc,\\\n+                                                        const char *asm_template,\\\n+                                                        int num_goto_blocks,\\\n+                                                        gcc_jit_block **goto_blocks,\\\n+                                                        gcc_jit_block *fallthrough_block)\n+\n+   Create a :type:`gcc_jit_extended_asm` for an extended ``asm`` statement\n+   that may perform jumps, and use it to terminate the given block.\n+   This is equivalent to the ``goto`` qualifier in C's extended ``asm``\n+   syntax.\n+\n+   For example, to create the equivalent of:\n+\n+   .. literalinclude:: ../../../testsuite/jit.dg/test-asm.c\n+      :start-after: // Quote from here in docs/topics/asm.rst: example 3b: C\n+      :end-before: // Quote up to here in docs/topics/asm.rst: example 3b: C\n+      :language: c\n+\n+   the following API calls could be used:\n+\n+   .. literalinclude:: ../../../testsuite/jit.dg/test-asm.c\n+      :start-after: /* Quote from here in docs/topics/asm.rst: example 3: jit.  */\n+      :end-before: /* Quote up to here in docs/topics/asm.rst: example 3: jit.  */\n+      :language: c\n+\n+   here referencing a :type:`gcc_jit_block` named \"carry\".\n+\n+   ``num_goto_blocks`` must be >= 0.\n+\n+   ``goto_blocks`` must be non-NULL.  This corresponds to the ``GotoLabels``\n+   parameter within C's extended ``asm`` syntax.  The block names can be\n+   referenced within the assembler template.\n+\n+   ``fallthrough_block`` can be NULL.  If non-NULL, it specifies the block\n+   to fall through to after the statement.\n+\n+   .. note:: This is needed since each :type:`gcc_jit_block` must have a\n+\t     single exit point, as a basic block: you can't jump from the\n+\t     middle of a block.  A \"goto\" is implicitly added after the\n+\t     asm to handle the fallthrough case, which is equivalent to what\n+\t     would have happened in the C case.\n+\n+.. function:: void\\\n+              gcc_jit_extended_asm_set_volatile_flag (gcc_jit_extended_asm *ext_asm,\\\n+                                                      int flag)\n+\n+   Set whether the :type:`gcc_jit_extended_asm` has side-effects, equivalent to the\n+   `volatile <https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#Volatile>`_\n+   qualifier in C's extended asm syntax.\n+\n+   For example, to create the equivalent of:\n+\n+   .. code-block:: c\n+\n+      asm volatile (\"rdtsc\\n\\t\"    // Returns the time in EDX:EAX.\n+                     \"shl $32, %%rdx\\n\\t\"  // Shift the upper bits left.\n+                     \"or %%rdx, %0\"        // 'Or' in the lower bits.\n+                     : \"=a\" (msr)\n+                     :\n+                     : \"rdx\");\n+\n+   the following API calls could be used:\n+\n+   .. literalinclude:: ../../../testsuite/jit.dg/test-asm.c\n+      :start-after: /* Quote from here in docs/topics/asm.rst: example 4: jit.  */\n+      :end-before: /* Quote up to here in docs/topics/asm.rst: example 4: jit.  */\n+      :language: c\n+\n+   where the :type:`gcc_jit_extended_asm` is flagged as volatile.\n+\n+.. function:: void\\\n+              gcc_jit_extended_asm_set_inline_flag (gcc_jit_extended_asm *ext_asm,\\\n+                                                    int flag)\n+\n+   Set the equivalent of the\n+   `inline <https://gcc.gnu.org/onlinedocs/gcc/Size-of-an-asm.html#Size-of-an-asm>`_\n+   qualifier in C's extended ``asm`` syntax.\n+\n+.. function:: void\\\n+              gcc_jit_extended_asm_add_output_operand (gcc_jit_extended_asm *ext_asm,\\\n+                                                       const char *asm_symbolic_name,\\\n+                                                       const char *constraint,\\\n+                                                       gcc_jit_lvalue *dest)\n+\n+   Add an output operand to the extended ``asm`` statement.  See the\n+   `Output Operands <https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#OutputOperands>`_\n+   section of the documentation of the C syntax.\n+\n+   ``asm_symbolic_name`` corresponds to the ``asmSymbolicName`` component of C's\n+   extended ``asm`` syntax.  It can be NULL.  If non-NULL it specifies the\n+   symbolic name for the operand.\n+\n+   ``constraint`` corresponds to the ``constraint`` component of C's extended\n+   ``asm`` syntax.  It must be non-NULL.\n+\n+   ``dest`` corresponds to the ``cvariablename`` component of C's extended\n+   ``asm`` syntax.  It must be non-NULL.\n+\n+   .. code-block:: c\n+\n+      // Example with a NULL symbolic name, the equivalent of:\n+      //   : \"=r\" (dst)\n+      gcc_jit_extended_asm_add_output_operand (ext_asm, NULL, \"=r\", dst);\n+\n+      // Example with a symbolic name (\"aIndex\"), the equivalent of:\n+      //   : [aIndex] \"=r\" (index)\n+      gcc_jit_extended_asm_add_output_operand (ext_asm, \"aIndex\", \"=r\", index);\n+\n+   This function can't be called on an ``asm goto`` as such instructions can't\n+   have outputs; see the\n+   `Goto Labels <https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#GotoLabels>`_\n+   section of GCC's \"Extended Asm\" documentation.\n+\n+.. function:: void\\\n+              gcc_jit_extended_asm_add_input_operand (gcc_jit_extended_asm *ext_asm,\\\n+                                                      const char *asm_symbolic_name,\\\n+                                                      const char *constraint,\\\n+                                                      gcc_jit_rvalue *src)\n+\n+   Add an input operand to the extended ``asm`` statement.  See the\n+   `Input Operands <https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#InputOperands>`_\n+   section of the documentation of the C syntax.\n+\n+   ``asm_symbolic_name`` corresponds to the ``asmSymbolicName`` component of C's\n+   extended ``asm`` syntax.  It can be NULL.  If non-NULL it specifies the\n+   symbolic name for the operand.\n+\n+   ``constraint`` corresponds to the ``constraint`` component of C's extended\n+   ``asm`` syntax.  It must be non-NULL.\n+\n+   ``src`` corresponds to the ``cexpression`` component of C's extended\n+   ``asm`` syntax.  It must be non-NULL.\n+\n+   .. code-block:: c\n+\n+      // Example with a NULL symbolic name, the equivalent of:\n+      //   : \"r\" (src)\n+      gcc_jit_extended_asm_add_input_operand (ext_asm, NULL, \"r\",\n+                                              gcc_jit_lvalue_as_rvalue (src));\n+\n+      // Example with a symbolic name (\"aMask\"), the equivalent of:\n+      //   : [aMask] \"r\" (Mask)\n+      gcc_jit_extended_asm_add_input_operand (ext_asm, \"aMask\", \"r\",\n+                                              gcc_jit_lvalue_as_rvalue (mask));\n+\n+.. function:: void\\\n+              gcc_jit_extended_asm_add_clobber (gcc_jit_extended_asm *ext_asm,\\\n+                                                const char *victim)\n+\n+   Add `victim` to the list of registers clobbered by the extended ``asm``\n+   statement.  It must be non-NULL.  See the\n+   `Clobbers and Scratch Registers <https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#Clobbers-and-Scratch-Registers#>`_\n+   section of the documentation of the C syntax.\n+\n+   Statements with multiple clobbers will require multiple calls, one per\n+   clobber.\n+\n+   For example:\n+\n+   .. code-block:: c\n+\n+     gcc_jit_extended_asm_add_clobber (ext_asm, \"r0\");\n+     gcc_jit_extended_asm_add_clobber (ext_asm, \"cc\");\n+     gcc_jit_extended_asm_add_clobber (ext_asm, \"memory\");\n+\n+A :type:`gcc_jit_extended_asm` is a :type:`gcc_jit_object` \"owned\" by\n+the block's context.  The following upcast is available:\n+\n+.. function:: gcc_jit_object *\\\n+              gcc_jit_extended_asm_as_object (gcc_jit_extended_asm *ext_asm)\n+\n+   Upcast from extended ``asm`` to object.\n+\n+\n+Adding top-level assembler statements\n+*************************************\n+\n+In addition to creating extended ``asm`` instructions within a function,\n+there is support for creating \"top-level\" assembler statements, outside\n+of any function.\n+\n+.. function:: void \\\n+              gcc_jit_context_add_top_level_asm (gcc_jit_context *ctxt,\\\n+                                                 gcc_jit_location *loc,\\\n+                                                 const char *asm_stmts)\n+\n+   Create a set of top-level asm statements, analogous to those created\n+   by GCC's \"basic\" ``asm`` syntax in C at file scope.\n+\n+   For example, to create the equivalent of:\n+\n+   .. literalinclude:: ../../../testsuite/jit.dg/test-asm.c\n+      :start-after: // Quote from here in docs/topics/asm.rst: example 5: C\n+      :end-before: // Quote up to here in docs/topics/asm.rst: example 5: C\n+      :language: c\n+\n+   the following API calls could be used:\n+\n+   .. literalinclude:: ../../../testsuite/jit.dg/test-asm.c\n+      :start-after: /* Quote from here in docs/topics/asm.rst: example 5: jit.  */\n+      :end-before: /* Quote up to here in docs/topics/asm.rst: example 5: jit.  */\n+      :language: c"}, {"sha": "b953da590f1c51ca570824d00c049c0eb74cafaa", "filename": "gcc/jit/docs/topics/compatibility.rst", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Fjit%2Fdocs%2Ftopics%2Fcompatibility.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Fjit%2Fdocs%2Ftopics%2Fcompatibility.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Fcompatibility.rst?ref=421d0d0f54294a7bf2872b3b2ac521ce0fa9869e", "patch": "@@ -226,3 +226,20 @@ entrypoints:\n --------------------\n ``LIBGCCJIT_ABI_14`` covers the addition of\n :func:`gcc_jit_global_set_initializer`\n+\n+.. _LIBGCCJIT_ABI_15:\n+\n+``LIBGCCJIT_ABI_15``\n+-----------------------\n+``LIBGCCJIT_ABI_15`` covers the addition of API entrypoints for directly\n+embedding assembler instructions:\n+\n+  * :func:`gcc_jit_block_add_extended_asm`\n+  * :func:`gcc_jit_block_end_with_extended_asm_goto`\n+  * :func:`gcc_jit_extended_asm_as_object`\n+  * :func:`gcc_jit_extended_asm_set_volatile_flag`\n+  * :func:`gcc_jit_extended_asm_set_inline_flag`\n+  * :func:`gcc_jit_extended_asm_add_output_operand`\n+  * :func:`gcc_jit_extended_asm_add_input_operand`\n+  * :func:`gcc_jit_extended_asm_add_clobber`\n+  * :func:`gcc_jit_context_add_top_level_asm`"}, {"sha": "b869256a1cd568d5ad4914953d07c34df214a0fa", "filename": "gcc/jit/docs/topics/functions.rst", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Fjit%2Fdocs%2Ftopics%2Ffunctions.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Fjit%2Fdocs%2Ftopics%2Ffunctions.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Ffunctions.rst?ref=421d0d0f54294a7bf2872b3b2ac521ce0fa9869e", "patch": "@@ -458,3 +458,6 @@ Statements\n        :start-after: /* Quote from here in docs/topics/functions.rst.  */\n        :end-before: /* Quote up to here in docs/topics/functions.rst.  */\n        :language: c\n+\n+See also :type:`gcc_jit_extended_asm` for entrypoints for adding inline\n+assembler statements to a function."}, {"sha": "d7cb86aa0d85db1e1161c5fe16f9524000d0dc4a", "filename": "gcc/jit/docs/topics/index.rst", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Fjit%2Fdocs%2Ftopics%2Findex.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Fjit%2Fdocs%2Ftopics%2Findex.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Findex.rst?ref=421d0d0f54294a7bf2872b3b2ac521ce0fa9869e", "patch": "@@ -31,3 +31,4 @@ Topic Reference\n    compilation.rst\n    compatibility.rst\n    performance.rst\n+   asm.rst"}, {"sha": "cdee2c0af6a8eb07e5b24f42efc78a04742cb166", "filename": "gcc/jit/docs/topics/objects.rst", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Fjit%2Fdocs%2Ftopics%2Fobjects.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Fjit%2Fdocs%2Ftopics%2Fobjects.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Fobjects.rst?ref=421d0d0f54294a7bf2872b3b2ac521ce0fa9869e", "patch": "@@ -48,6 +48,7 @@ looks like this::\n           +- gcc_jit_lvalue\n              +- gcc_jit_param\n       +- gcc_jit_case\n+      +- gcc_jit_extended_asm\n \n There are casting methods for upcasting from subclasses to parent classes.\n For example, :c:func:`gcc_jit_type_as_object`:"}, {"sha": "b8c3685c0733fac5511dc777329083530219b877", "filename": "gcc/jit/jit-common.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Fjit%2Fjit-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Fjit%2Fjit-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-common.h?ref=421d0d0f54294a7bf2872b3b2ac521ce0fa9869e", "patch": "@@ -131,7 +131,9 @@ namespace recording {\n       class base_call;\n       class function_pointer;\n     class statement;\n+      class extended_asm;\n     class case_;\n+  class top_level_asm;\n \n   /* End of recording types. */\n }"}, {"sha": "5bccf591a3f106edaa6905a3f403d81254b3cbc5", "filename": "gcc/jit/jit-playback.c", "status": "modified", "additions": 124, "deletions": 1, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Fjit%2Fjit-playback.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Fjit%2Fjit-playback.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-playback.c?ref=421d0d0f54294a7bf2872b3b2ac521ce0fa9869e", "patch": "@@ -39,6 +39,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"opt-suggestions.h\"\n #include \"gcc.h\"\n #include \"diagnostic.h\"\n+#include \"stmt.h\"\n \n #include <pthread.h>\n \n@@ -86,6 +87,18 @@ namespace jit {\n  Playback.\n  **********************************************************************/\n \n+/* Build a STRING_CST tree for STR, or return NULL if it is NULL.\n+   The TREE_TYPE is not initialized.  */\n+\n+static tree\n+build_string (const char *str)\n+{\n+  if (str)\n+    return ::build_string (strlen (str), str);\n+  else\n+    return NULL_TREE;\n+}\n+\n /* The constructor for gcc::jit::playback::context.  */\n \n playback::context::context (recording::context *ctxt)\n@@ -774,7 +787,7 @@ new_string_literal (const char *value)\n   tree a_type = build_array_type (char_type_node, i_type);\n   /* build_string len parameter must include NUL terminator when\n      building C strings.  */\n-  tree t_str = build_string (len + 1, value);\n+  tree t_str = ::build_string (len + 1, value);\n   TREE_TYPE (t_str) = a_type;\n \n   /* Convert to (const char*), loosely based on\n@@ -821,6 +834,18 @@ as_truth_value (tree expr, location *loc)\n   return expr;\n }\n \n+/* Add a \"top-level\" basic asm statement (i.e. one outside of any functions)\n+   containing ASM_STMTS.\n+\n+   Compare with c_parser_asm_definition.  */\n+\n+void\n+playback::context::add_top_level_asm (const char *asm_stmts)\n+{\n+  tree asm_str = build_string (asm_stmts);\n+  symtab->finalize_toplevel_asm (asm_str);\n+}\n+\n /* Construct a playback::rvalue instance (wrapping a tree) for a\n    unary op.  */\n \n@@ -1897,6 +1922,104 @@ add_switch (location *loc,\n   add_stmt (switch_stmt);\n }\n \n+/* Convert OPERANDS to a tree-based chain suitable for creating an\n+   extended asm stmt.\n+   Compare with c_parser_asm_operands.  */\n+\n+static tree\n+build_operand_chain (const auto_vec <playback::asm_operand> *operands)\n+{\n+  tree result = NULL_TREE;\n+  unsigned i;\n+  playback::asm_operand *asm_op;\n+  FOR_EACH_VEC_ELT (*operands, i, asm_op)\n+    {\n+      tree name = build_string (asm_op->m_asm_symbolic_name);\n+      tree str = build_string (asm_op->m_constraint);\n+      tree value = asm_op->m_expr;\n+      result = chainon (result,\n+\t\t\tbuild_tree_list (build_tree_list (name, str),\n+\t\t\t\t\t value));\n+    }\n+  return result;\n+}\n+\n+/* Convert CLOBBERS to a tree-based list suitable for creating an\n+   extended asm stmt.\n+   Compare with c_parser_asm_clobbers.  */\n+\n+static tree\n+build_clobbers (const auto_vec <const char *> *clobbers)\n+{\n+  tree list = NULL_TREE;\n+  unsigned i;\n+  const char *clobber;\n+  FOR_EACH_VEC_ELT (*clobbers, i, clobber)\n+    {\n+      tree str = build_string (clobber);\n+      list = tree_cons (NULL_TREE, str, list);\n+    }\n+  return list;\n+}\n+\n+/* Convert BLOCKS to a tree-based list suitable for creating an\n+   extended asm stmt.\n+   Compare with c_parser_asm_goto_operands.  */\n+\n+static tree\n+build_goto_operands (const auto_vec <playback::block *> *blocks)\n+{\n+  tree list = NULL_TREE;\n+  unsigned i;\n+  playback::block *b;\n+  FOR_EACH_VEC_ELT (*blocks, i, b)\n+    {\n+      tree label = b->as_label_decl ();\n+      tree name = build_string (IDENTIFIER_POINTER (DECL_NAME (label)));\n+      TREE_USED (label) = 1;\n+      list = tree_cons (name, label, list);\n+    }\n+  return nreverse (list);\n+}\n+\n+/* Add an extended asm statement to this block.\n+\n+   Compare with c_parser_asm_statement (in c/c-parser.c)\n+   and build_asm_expr (in c/c-typeck.c).  */\n+\n+void\n+playback::block::add_extended_asm (location *loc,\n+\t\t\t\t   const char *asm_template,\n+\t\t\t\t   bool is_volatile,\n+\t\t\t\t   bool is_inline,\n+\t\t\t\t   const auto_vec <asm_operand> *outputs,\n+\t\t\t\t   const auto_vec <asm_operand> *inputs,\n+\t\t\t\t   const auto_vec <const char *> *clobbers,\n+\t\t\t\t   const auto_vec <block *> *goto_blocks)\n+{\n+  tree t_string = build_string (asm_template);\n+  tree t_outputs = build_operand_chain (outputs);\n+  tree t_inputs = build_operand_chain (inputs);\n+  tree t_clobbers = build_clobbers (clobbers);\n+  tree t_labels = build_goto_operands (goto_blocks);\n+  t_string\n+    = resolve_asm_operand_names (t_string, t_outputs, t_inputs, t_labels);\n+  tree asm_stmt\n+    = build5 (ASM_EXPR, void_type_node,\n+\t      t_string, t_outputs, t_inputs, t_clobbers, t_labels);\n+\n+  /* asm statements without outputs, including simple ones, are treated\n+     as volatile.  */\n+  ASM_VOLATILE_P (asm_stmt) = (outputs->length () == 0);\n+  ASM_INPUT_P (asm_stmt) = 0; /* extended asm stmts are not \"simple\".  */\n+  ASM_INLINE_P (asm_stmt) = is_inline;\n+  if (is_volatile)\n+    ASM_VOLATILE_P (asm_stmt) = 1;\n+  if (loc)\n+    set_tree_location (asm_stmt, loc);\n+  add_stmt (asm_stmt);\n+}\n+\n /* Constructor for gcc::jit::playback::block.  */\n \n playback::block::"}, {"sha": "ff1f778d0268804973988f98b1104148ad583470", "filename": "gcc/jit/jit-playback.h", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Fjit%2Fjit-playback.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Fjit%2Fjit-playback.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-playback.h?ref=421d0d0f54294a7bf2872b3b2ac521ce0fa9869e", "patch": "@@ -252,6 +252,8 @@ class context : public log_user\n \n   timer *get_timer () const { return m_recording_ctxt->get_timer (); }\n \n+  void add_top_level_asm (const char *asm_stmts);\n+\n private:\n   void dump_generated_code ();\n \n@@ -514,6 +516,21 @@ struct case_\n   block *m_dest_block;\n };\n \n+struct asm_operand\n+{\n+  asm_operand (const char *asm_symbolic_name,\n+\t       const char *constraint,\n+\t       tree expr)\n+  : m_asm_symbolic_name (asm_symbolic_name),\n+    m_constraint (constraint),\n+    m_expr (expr)\n+  {}\n+\n+  const char *m_asm_symbolic_name;\n+  const char *m_constraint;\n+  tree m_expr;\n+};\n+\n class block : public wrapper\n {\n public:\n@@ -563,6 +580,16 @@ class block : public wrapper\n \t      block *default_block,\n \t      const auto_vec <case_> *cases);\n \n+  void\n+  add_extended_asm (location *loc,\n+\t\t    const char *asm_template,\n+\t\t    bool is_volatile,\n+\t\t    bool is_inline,\n+\t\t    const auto_vec <asm_operand> *outputs,\n+\t\t    const auto_vec <asm_operand> *inputs,\n+\t\t    const auto_vec <const char *> *clobbers,\n+\t\t    const auto_vec <block *> *goto_blocks);\n+\n private:\n   void\n   set_tree_location (tree t, location *loc)"}, {"sha": "1b0f8bc7db35ea4ce9669ffcaf7b0d6a2a230e58", "filename": "gcc/jit/jit-recording.c", "status": "modified", "additions": 514, "deletions": 0, "changes": 514, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Fjit%2Fjit-recording.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Fjit%2Fjit-recording.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-recording.c?ref=421d0d0f54294a7bf2872b3b2ac521ce0fa9869e", "patch": "@@ -1578,6 +1578,10 @@ recording::context::dump_to_file (const char *path, bool update_locations)\n     {\n       fn->write_to_dump (d);\n     }\n+\n+  top_level_asm *tla;\n+  FOR_EACH_VEC_ELT (m_top_level_asms, i, tla)\n+    tla->write_to_dump (d);\n }\n \n static const char * const\n@@ -1904,6 +1908,22 @@ recording::context::get_all_requested_dumps (vec <recording::requested_dump> *ou\n   out->splice (m_requested_dumps);\n }\n \n+/* Create a recording::top_level_asm instance and add it to this\n+   context's list of mementos and to m_top_level_asms.\n+\n+   Implements the post-error-checking part of\n+   gcc_jit_context_add_top_level_asm.  */\n+\n+void\n+recording::context::add_top_level_asm (recording::location *loc,\n+\t\t\t\t       const char *asm_stmts)\n+{\n+  recording::top_level_asm *asm_obj\n+    = new recording::top_level_asm (this, loc, new_string (asm_stmts));\n+  record (asm_obj);\n+  m_top_level_asms.safe_push (asm_obj);\n+}\n+\n /* This is a pre-compilation check for the context (and any parents).\n \n    Detect errors within the context, adding errors if any are found.  */\n@@ -4206,6 +4226,23 @@ recording::block::add_comment (recording::location *loc,\n   return result;\n }\n \n+/* Create a recording::extended_asm_simple instance and add it to\n+   the block's context's list of mementos, and to the block's\n+   list of statements.\n+\n+   Implements the heart of gcc_jit_block_add_extended_asm.  */\n+\n+recording::extended_asm *\n+recording::block::add_extended_asm (location *loc,\n+\t\t\t\t    const char *asm_template)\n+{\n+  extended_asm *result\n+    = new extended_asm_simple (this, loc, new_string (asm_template));\n+  m_ctxt->record (result);\n+  m_statements.safe_push (result);\n+  return result;\n+}\n+\n /* Create a recording::end_with_conditional instance and add it to\n    the block's context's list of mementos, and to the block's\n    list of statements.\n@@ -4288,6 +4325,30 @@ recording::block::end_with_switch (recording::location *loc,\n   return result;\n }\n \n+/* Create a recording::extended_asm_goto instance and add it to\n+   the block's context's list of mementos, and to the block's\n+   list of statements.\n+\n+   Implements the heart of gcc_jit_block_end_with_extended_asm_goto.  */\n+\n+\n+recording::extended_asm *\n+recording::block::end_with_extended_asm_goto (location *loc,\n+\t\t\t\t\t      const char *asm_template,\n+\t\t\t\t\t      int num_goto_blocks,\n+\t\t\t\t\t      block **goto_blocks,\n+\t\t\t\t\t      block *fallthrough_block)\n+{\n+  extended_asm *result\n+    = new extended_asm_goto (this, loc, new_string (asm_template),\n+\t\t\t     num_goto_blocks, goto_blocks,\n+\t\t\t     fallthrough_block);\n+  m_ctxt->record (result);\n+  m_statements.safe_push (result);\n+  m_has_been_terminated = true;\n+  return result;\n+}\n+\n /* Override the default implementation of\n    recording::memento::write_to_dump for blocks by writing\n    an unindented block name as a label, followed by the indented\n@@ -6508,6 +6569,459 @@ recording::switch_::write_reproducer (reproducer &r)\n \t     cases_id);\n }\n \n+/* class asm_operand : public memento.  */\n+\n+recording::asm_operand::asm_operand (extended_asm *ext_asm,\n+\t\t\t\t     string *asm_symbolic_name,\n+\t\t\t\t     string *constraint)\n+: memento (ext_asm->get_context ()),\n+  m_ext_asm (ext_asm),\n+  m_asm_symbolic_name (asm_symbolic_name),\n+  m_constraint (constraint)\n+{\n+}\n+\n+void\n+recording::asm_operand::print (pretty_printer *pp) const\n+{\n+  if (m_asm_symbolic_name)\n+    {\n+      pp_character (pp, '[');\n+      pp_string (pp, m_asm_symbolic_name->c_str ());\n+      pp_character (pp, ']');\n+      pp_space (pp);\n+    }\n+  pp_string (pp, m_constraint->get_debug_string ());\n+  /* Subclass will add lvalue/rvalue.  */\n+}\n+\n+recording::string *\n+recording::asm_operand::make_debug_string ()\n+{\n+  pretty_printer pp;\n+  print (&pp);\n+  return m_ctxt->new_string (pp_formatted_text (&pp), false);\n+}\n+\n+/* class output_asm_operand : public asm_operand.  */\n+\n+void\n+recording::output_asm_operand::write_reproducer (reproducer &r)\n+{\n+  const char *fmt =\n+    \"  gcc_jit_extended_asm_add_output_operand (%s, /* gcc_jit_extended_asm *ext_asm */\\n\"\n+    \"                                           %s, /* const char *asm_symbolic_name */\\n\"\n+    \"                                           %s, /* const char *constraint */\\n\"\n+    \"                                           %s); /* gcc_jit_lvalue *dest */\\n\";\n+  r.write (fmt,\n+\t   r.get_identifier (m_ext_asm),\n+\t   (m_asm_symbolic_name\n+\t    ? m_asm_symbolic_name->get_debug_string () : \"NULL\"),\n+\t   m_constraint->get_debug_string (),\n+\t   r.get_identifier (m_dest));\n+}\n+\n+void\n+recording::output_asm_operand::print (pretty_printer *pp) const\n+{\n+  asm_operand::print (pp);\n+  pp_string (pp, \" (\");\n+  pp_string (pp, m_dest->get_debug_string ());\n+  pp_string (pp, \")\");\n+}\n+\n+/* class input_asm_operand : public asm_operand.  */\n+\n+void\n+recording::input_asm_operand::write_reproducer (reproducer &r)\n+{\n+  const char *fmt =\n+    \"  gcc_jit_extended_asm_add_input_operand (%s, /* gcc_jit_extended_asm *ext_asm */\\n\"\n+    \"                                          %s, /* const char *asm_symbolic_name */\\n\"\n+    \"                                          %s, /* const char *constraint */\\n\"\n+    \"                                          %s); /* gcc_jit_rvalue *src */\\n\";\n+  r.write (fmt,\n+\t   r.get_identifier (m_ext_asm),\n+\t   (m_asm_symbolic_name\n+\t    ? m_asm_symbolic_name->get_debug_string () : \"NULL\"),\n+\t   m_constraint->get_debug_string (),\n+\t   r.get_identifier_as_rvalue (m_src));\n+}\n+\n+void\n+recording::input_asm_operand::print (pretty_printer *pp) const\n+{\n+  asm_operand::print (pp);\n+  pp_string (pp, \" (\");\n+  pp_string (pp, m_src->get_debug_string ());\n+  pp_string (pp, \")\");\n+}\n+\n+/* The implementation of class gcc::jit::recording::extended_asm.  */\n+\n+void\n+recording::extended_asm::add_output_operand (const char *asm_symbolic_name,\n+\t\t\t\t\t     const char *constraint,\n+\t\t\t\t\t     lvalue *dest)\n+{\n+  output_asm_operand *op\n+    = new output_asm_operand (this,\n+\t\t\t      new_string (asm_symbolic_name),\n+\t\t\t      new_string (constraint),\n+\t\t\t      dest);\n+  m_ctxt->record (op);\n+  m_output_ops.safe_push (op);\n+}\n+\n+void\n+recording::extended_asm::add_input_operand (const char *asm_symbolic_name,\n+\t\t\t\t\t    const char *constraint,\n+\t\t\t\t\t    rvalue *src)\n+{\n+  input_asm_operand *op\n+    = new input_asm_operand (this,\n+\t\t\t     new_string (asm_symbolic_name),\n+\t\t\t     new_string (constraint),\n+\t\t\t     src);\n+  m_ctxt->record (op);\n+  m_input_ops.safe_push (op);\n+}\n+\n+void\n+recording::extended_asm::add_clobber (const char *victim)\n+{\n+  m_clobbers.safe_push (new_string (victim));\n+}\n+\n+/* Implementation of recording::memento::replay_into\n+   for recording::extended_asm.  */\n+\n+void\n+recording::extended_asm::replay_into (replayer *r)\n+{\n+  auto_vec<playback::asm_operand> playback_output_ops;\n+  auto_vec<playback::asm_operand> playback_input_ops;\n+  auto_vec<const char *> playback_clobbers;\n+  auto_vec<playback::block *> playback_goto_blocks;\n+\n+  /* Populate outputs.  */\n+  {\n+    output_asm_operand *rec_asm_op;\n+    unsigned i;\n+    FOR_EACH_VEC_ELT (m_output_ops, i, rec_asm_op)\n+      {\n+\tplayback::asm_operand playback_asm_op\n+\t  (rec_asm_op->get_symbolic_name (),\n+\t   rec_asm_op->get_constraint (),\n+\t   rec_asm_op->get_lvalue ()->playback_lvalue ()->as_tree ());\n+\tplayback_output_ops.safe_push (playback_asm_op);\n+      }\n+  }\n+\n+  /* Populate inputs.  */\n+  {\n+    input_asm_operand *rec_asm_op;\n+    unsigned i;\n+    FOR_EACH_VEC_ELT (m_input_ops, i, rec_asm_op)\n+      {\n+\tplayback::asm_operand playback_asm_op\n+\t  (rec_asm_op->get_symbolic_name (),\n+\t   rec_asm_op->get_constraint (),\n+\t   rec_asm_op->get_rvalue ()->playback_rvalue ()->as_tree ());\n+\tplayback_input_ops.safe_push (playback_asm_op);\n+      }\n+  }\n+\n+  /* Populate clobbers.  */\n+  {\n+    string *rec_clobber;\n+    unsigned i;\n+    FOR_EACH_VEC_ELT (m_clobbers, i, rec_clobber)\n+      playback_clobbers.safe_push (rec_clobber->c_str ());\n+  }\n+\n+  /* Populate playback blocks if an \"asm goto\".  */\n+  maybe_populate_playback_blocks (&playback_goto_blocks);\n+\n+  playback_block (get_block ())\n+    ->add_extended_asm (playback_location (r),\n+\t\t\tm_asm_template->c_str (),\n+\t\t\tm_is_volatile, m_is_inline,\n+\t\t\t&playback_output_ops,\n+\t\t\t&playback_input_ops,\n+\t\t\t&playback_clobbers,\n+\t\t\t&playback_goto_blocks);\n+}\n+\n+/* Implementation of recording::memento::make_debug_string for\n+   an extended_asm \"statement\".  */\n+\n+recording::string *\n+recording::extended_asm::make_debug_string ()\n+{\n+  pretty_printer pp;\n+  pp_string (&pp, \"asm \");\n+  if (m_is_volatile)\n+    pp_string (&pp, \"volatile \");\n+  if (m_is_inline)\n+    pp_string (&pp, \"inline \");\n+  if (is_goto ())\n+    pp_string (&pp, \"goto \");\n+  pp_character (&pp, '(');\n+  pp_string (&pp, m_asm_template->get_debug_string ());\n+  pp_string (&pp, \" : \");\n+  unsigned i;\n+  {\n+    output_asm_operand *asm_op;\n+    FOR_EACH_VEC_ELT (m_output_ops, i, asm_op)\n+      {\n+\tif (i > 0)\n+\t  pp_string (&pp, \", \");\n+\tasm_op->print (&pp);\n+      }\n+  }\n+  pp_string (&pp, \" : \");\n+  {\n+    input_asm_operand *asm_op;\n+    FOR_EACH_VEC_ELT (m_input_ops, i, asm_op)\n+      {\n+\tif (i > 0)\n+\t  pp_string (&pp, \", \");\n+\tasm_op->print (&pp);\n+      }\n+  }\n+  pp_string (&pp, \" : \");\n+  string *rec_clobber;\n+  FOR_EACH_VEC_ELT (m_clobbers, i, rec_clobber)\n+      {\n+\tif (i > 0)\n+\t  pp_string (&pp, \", \");\n+\tpp_string (&pp, rec_clobber->get_debug_string ());\n+      }\n+  maybe_print_gotos (&pp);\n+  pp_character (&pp, ')');\n+  return new_string (pp_formatted_text (&pp));\n+}\n+\n+void\n+recording::extended_asm::write_flags (reproducer &r)\n+{\n+  if (m_is_volatile)\n+    r.write (\"  gcc_jit_extended_asm_set_volatile_flag (%s, 1);\\n\",\n+\t     r.get_identifier (this));\n+  if (m_is_inline)\n+    r.write (\"  gcc_jit_extended_asm_set_inline_flag (%s, 1);\\n\",\n+\t     r.get_identifier (this));\n+}\n+\n+void\n+recording::extended_asm::write_clobbers (reproducer &r)\n+{\n+  string *clobber;\n+  unsigned i;\n+  FOR_EACH_VEC_ELT (m_clobbers, i, clobber)\n+    r.write (\"  gcc_jit_extended_asm_add_clobber (%s, %s);\\n\",\n+\t     r.get_identifier (this),\n+\t     clobber->get_debug_string ());\n+}\n+\n+/* Implementation of recording::memento::write_reproducer for\n+   extended_asm_simple.  */\n+\n+void\n+recording::extended_asm_simple::write_reproducer (reproducer &r)\n+{\n+  const char *id = r.make_identifier (this, \"extended_asm\");\n+  r.write (\"  gcc_jit_extended_asm *%s =\\n\"\n+\t   \"    gcc_jit_block_add_extended_asm (%s, /*gcc_jit_block *block */\\n\"\n+\t   \"                                    %s, /* gcc_jit_location *loc */\\n\"\n+\t   \"                                    %s); /* const char *asm_template */\\n\",\n+\t   id,\n+\t   r.get_identifier (get_block ()),\n+\t   r.get_identifier (get_loc ()),\n+\t   m_asm_template->get_debug_string ());\n+  write_flags (r);\n+  write_clobbers (r);\n+}\n+\n+void\n+recording::extended_asm::\n+maybe_populate_playback_blocks (auto_vec <playback::block *> *)\n+{\n+  /* Do nothing; not an \"asm goto\".  */\n+}\n+\n+/* The implementation of class gcc::jit::recording::extended_asm_goto.  */\n+\n+/* recording::extended_asm_goto's ctor.  */\n+\n+recording::extended_asm_goto::extended_asm_goto (block *b,\n+\t\t\t\t\t\t location *loc,\n+\t\t\t\t\t\t string *asm_template,\n+\t\t\t\t\t\t int num_goto_blocks,\n+\t\t\t\t\t\t block **goto_blocks,\n+\t\t\t\t\t\t block *fallthrough_block)\n+: extended_asm (b, loc, asm_template),\n+  m_goto_blocks (num_goto_blocks),\n+  m_fallthrough_block (fallthrough_block)\n+{\n+  for (int i = 0; i < num_goto_blocks; i++)\n+    m_goto_blocks.quick_push (goto_blocks[i]);\n+}\n+\n+/* Implementation of recording::memento::replay_into\n+   for recording::extended_asm_goto.  */\n+\n+void\n+recording::extended_asm_goto::replay_into (replayer *r)\n+{\n+  /* Chain up to base class impl.  */\n+  recording::extended_asm::replay_into (r);\n+\n+  /* ...and potentially add a goto for the fallthrough.  */\n+  if (m_fallthrough_block)\n+    playback_block (get_block ())\n+      ->add_jump (playback_location (r),\n+\t\t  m_fallthrough_block->playback_block ());\n+}\n+\n+/* Implementation of recording::memento::write_reproducer for\n+   extended_asm_goto.  */\n+\n+void\n+recording::extended_asm_goto::write_reproducer (reproducer &r)\n+{\n+  const char *id = r.make_identifier (this, \"extended_asm\");\n+  const char *blocks_id = r.make_tmp_identifier (\"blocks_for\", this);\n+  r.write (\"  gcc_jit_block *%s[%i] = {\\n\",\n+\t   blocks_id,\n+\t   m_goto_blocks.length ());\n+  int i;\n+  block *b;\n+  FOR_EACH_VEC_ELT (m_goto_blocks, i, b)\n+    r.write (\"    %s,\\n\", r.get_identifier (b));\n+  r.write (\"  };\\n\");\n+  r.write (\"  gcc_jit_extended_asm *%s =\\n\"\n+\t   \"    gcc_jit_block_end_with_extended_asm_goto (%s, /*gcc_jit_block *block */\\n\"\n+\t   \"                                              %s, /* gcc_jit_location *loc */\\n\"\n+\t   \"                                              %s, /* const char *asm_template */\\n\"\n+\t   \"                                              %i, /* int num_goto_blocks */\\n\"\n+\t   \"                                              %s, /* gcc_jit_block **goto_blocks */\\n\"\n+\t   \"                                              %s); /* gcc_jit_block *fallthrough_block */\\n\",\n+\t   id,\n+\t   r.get_identifier (get_block ()),\n+\t   r.get_identifier (get_loc ()),\n+\t   m_asm_template->get_debug_string (),\n+\t   m_goto_blocks.length (),\n+\t   blocks_id,\n+\t   (m_fallthrough_block\n+\t    ? r.get_identifier (m_fallthrough_block)\n+\t    : \"NULL\"));\n+  write_flags (r);\n+  write_clobbers (r);\n+}\n+\n+/* Override the poisoned default implementation of\n+   gcc::jit::recording::statement::get_successor_blocks\n+\n+   An extended_asm_goto can jump to the m_goto_blocks, and to\n+   the (optional) m_fallthrough_block.  */\n+\n+vec <recording::block *>\n+recording::extended_asm_goto::get_successor_blocks () const\n+{\n+  vec <block *> result;\n+  result.create (m_goto_blocks.length () + 1);\n+  if (m_fallthrough_block)\n+    result.quick_push (m_fallthrough_block);\n+  result.splice (m_goto_blocks);\n+  return result;\n+}\n+\n+/* Vfunc for use by recording::extended_asm::make_debug_string.  */\n+\n+void\n+recording::extended_asm_goto::maybe_print_gotos (pretty_printer *pp) const\n+{\n+  pp_string (pp, \" : \");\n+  unsigned i;\n+  block *b;\n+  FOR_EACH_VEC_ELT (m_goto_blocks, i, b)\n+    {\n+      if (i > 0)\n+\tpp_string (pp, \", \");\n+      pp_string (pp, b->get_debug_string ());\n+    }\n+  /* Non-C syntax here.  */\n+  if (m_fallthrough_block)\n+    pp_printf (pp, \" [fallthrough: %s]\",\n+\t       m_fallthrough_block->get_debug_string ());\n+}\n+\n+/* Vfunc for use by recording::extended_asm::replay_into.  */\n+\n+void\n+recording::extended_asm_goto::\n+maybe_populate_playback_blocks (auto_vec <playback::block *> *out)\n+{\n+  unsigned i;\n+  block *b;\n+  FOR_EACH_VEC_ELT (m_goto_blocks, i, b)\n+    out->safe_push (b->playback_block ());\n+}\n+\n+/* class top_level_asm : public memento.  */\n+\n+recording::top_level_asm::top_level_asm (context *ctxt,\n+\t\t\t\t\t location *loc,\n+\t\t\t\t\t string *asm_stmts)\n+: memento (ctxt),\n+  m_loc (loc),\n+  m_asm_stmts (asm_stmts)\n+{\n+}\n+\n+/* Implementation of recording::memento::replay_into for top-level asm.  */\n+\n+void\n+recording::top_level_asm::replay_into (replayer *r)\n+{\n+  r->add_top_level_asm (m_asm_stmts->c_str ());\n+}\n+\n+/* Implementation of recording::memento::make_debug_string for\n+   top-level asm.  */\n+\n+recording::string *\n+recording::top_level_asm::make_debug_string ()\n+{\n+  return string::from_printf (m_ctxt, \"asm (%s)\",\n+\t\t\t      m_asm_stmts->get_debug_string ());\n+}\n+\n+/* Override the default implementation of\n+   recording::memento::write_to_dump.\n+   Don't indent the string.  */\n+\n+void\n+recording::top_level_asm::write_to_dump (dump &d)\n+{\n+  d.write (\"%s;\\n\", get_debug_string ());\n+}\n+\n+/* Implementation of recording::memento::write_reproducer for top-level asm. */\n+\n+void\n+recording::top_level_asm::write_reproducer (reproducer &r)\n+{\n+  r.write (\"  gcc_jit_context_add_top_level_asm (%s, /* gcc_jit_context *ctxt */\\n\"\n+\t   \"                                     %s, /* gcc_jit_location *loc */\\n\"\n+\t   \"                                     %s); /* const char *asm_stmts */\\n\",\n+\t   r.get_identifier (get_context ()),\n+\t   r.get_identifier (m_loc),\n+\t   m_asm_stmts->get_debug_string ());\n+}\n+\n } // namespace gcc::jit\n \n } // namespace gcc"}, {"sha": "e6948828d2a8760f29536507ad883b28fd608f27", "filename": "gcc/jit/jit-recording.h", "status": "modified", "additions": 215, "deletions": 0, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Fjit%2Fjit-recording.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Fjit%2Fjit-recording.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-recording.h?ref=421d0d0f54294a7bf2872b3b2ac521ce0fa9869e", "patch": "@@ -301,6 +301,8 @@ class context : public log_user\n   void set_timer (timer *t) { m_timer = t; }\n   timer *get_timer () const { return m_timer; }\n \n+  void add_top_level_asm (location *loc, const char *asm_stmts);\n+\n private:\n   void log_all_options () const;\n   void log_str_option (enum gcc_jit_str_option opt) const;\n@@ -344,6 +346,7 @@ class context : public log_user\n   auto_vec<compound_type *> m_compound_types;\n   auto_vec<global *> m_globals;\n   auto_vec<function *> m_functions;\n+  auto_vec<top_level_asm *> m_top_level_asms;\n \n   type *m_basic_types[NUM_GCC_JIT_TYPES];\n   type *m_FILE_type;\n@@ -1275,6 +1278,10 @@ class block : public memento\n   add_comment (location *loc,\n \t       const char *text);\n \n+  extended_asm *\n+  add_extended_asm (location *loc,\n+\t\t    const char *asm_template);\n+\n   statement *\n   end_with_conditional (location *loc,\n \t\t\trvalue *boolval,\n@@ -1296,6 +1303,13 @@ class block : public memento\n \t\t   int num_cases,\n \t\t   case_ **cases);\n \n+  extended_asm *\n+  end_with_extended_asm_goto (location *loc,\n+\t\t\t      const char *asm_template,\n+\t\t\t      int num_goto_blocks,\n+\t\t\t      block **goto_blocks,\n+\t\t\t      block *fallthrough_block);\n+\n   playback::block *\n   playback_block () const\n   {\n@@ -2112,6 +2126,207 @@ class switch_ : public statement\n   auto_vec <case_ *> m_cases;\n };\n \n+class asm_operand : public memento\n+{\n+public:\n+  asm_operand (extended_asm *ext_asm,\n+\t       string *asm_symbolic_name,\n+\t       string *constraint);\n+\n+  const char *get_symbolic_name () const\n+  {\n+    if (m_asm_symbolic_name)\n+      return m_asm_symbolic_name->c_str ();\n+    else\n+      return NULL;\n+  }\n+\n+  const char *get_constraint () const\n+  {\n+    return m_constraint->c_str ();\n+  }\n+\n+  virtual void print (pretty_printer *pp) const;\n+\n+private:\n+  string * make_debug_string () FINAL OVERRIDE;\n+\n+protected:\n+  extended_asm *m_ext_asm;\n+  string *m_asm_symbolic_name;\n+  string *m_constraint;\n+};\n+\n+class output_asm_operand : public asm_operand\n+{\n+public:\n+  output_asm_operand (extended_asm *ext_asm,\n+\t\t      string *asm_symbolic_name,\n+\t\t      string *constraint,\n+\t\t      lvalue *dest)\n+  : asm_operand (ext_asm, asm_symbolic_name, constraint),\n+    m_dest (dest)\n+  {}\n+\n+  lvalue *get_lvalue () const { return m_dest; }\n+\n+  void replay_into (replayer *) FINAL OVERRIDE {}\n+\n+  void print (pretty_printer *pp) const FINAL OVERRIDE;\n+\n+private:\n+  void write_reproducer (reproducer &r) FINAL OVERRIDE;\n+\n+private:\n+  lvalue *m_dest;\n+};\n+\n+class input_asm_operand : public asm_operand\n+{\n+public:\n+  input_asm_operand (extended_asm *ext_asm,\n+\t\t     string *asm_symbolic_name,\n+\t\t     string *constraint,\n+\t\t     rvalue *src)\n+  : asm_operand (ext_asm, asm_symbolic_name, constraint),\n+    m_src (src)\n+  {}\n+\n+  rvalue *get_rvalue () const { return m_src; }\n+\n+  void replay_into (replayer *) FINAL OVERRIDE {}\n+\n+  void print (pretty_printer *pp) const FINAL OVERRIDE;\n+\n+private:\n+  void write_reproducer (reproducer &r) FINAL OVERRIDE;\n+\n+private:\n+  rvalue *m_src;\n+};\n+\n+/* Abstract base class for extended_asm statements.  */\n+\n+class extended_asm : public statement\n+{\n+public:\n+  extended_asm (block *b,\n+\t\tlocation *loc,\n+\t\tstring *asm_template)\n+  : statement (b, loc),\n+    m_asm_template (asm_template),\n+    m_is_volatile (false),\n+    m_is_inline (false)\n+  {}\n+\n+  void set_volatile_flag (bool flag) { m_is_volatile = flag; }\n+  void set_inline_flag (bool flag) { m_is_inline = flag; }\n+\n+  void add_output_operand (const char *asm_symbolic_name,\n+\t\t\t   const char *constraint,\n+\t\t\t   lvalue *dest);\n+  void add_input_operand (const char *asm_symbolic_name,\n+\t\t\t  const char *constraint,\n+\t\t\t  rvalue *src);\n+  void add_clobber (const char *victim);\n+\n+  void replay_into (replayer *r) OVERRIDE;\n+\n+  string *get_asm_template () const { return m_asm_template; }\n+\n+  virtual bool is_goto () const = 0;\n+  virtual void maybe_print_gotos (pretty_printer *) const = 0;\n+\n+protected:\n+  void write_flags (reproducer &r);\n+  void write_clobbers (reproducer &r);\n+\n+private:\n+  string * make_debug_string () FINAL OVERRIDE;\n+  virtual void maybe_populate_playback_blocks\n+    (auto_vec <playback::block *> *out) = 0;\n+\n+protected:\n+  string *m_asm_template;\n+  bool m_is_volatile;\n+  bool m_is_inline;\n+  auto_vec<output_asm_operand *> m_output_ops;\n+  auto_vec<input_asm_operand *> m_input_ops;\n+  auto_vec<string *> m_clobbers;\n+};\n+\n+/* An extended_asm that's not a goto, as created by\n+   gcc_jit_block_add_extended_asm. */\n+\n+class extended_asm_simple : public extended_asm\n+{\n+public:\n+  extended_asm_simple (block *b,\n+\t\t       location *loc,\n+\t\t       string *asm_template)\n+  : extended_asm (b, loc, asm_template)\n+  {}\n+\n+  void write_reproducer (reproducer &r) OVERRIDE;\n+  bool is_goto () const FINAL OVERRIDE { return false; }\n+  void maybe_print_gotos (pretty_printer *) const FINAL OVERRIDE {}\n+\n+private:\n+  void maybe_populate_playback_blocks\n+    (auto_vec <playback::block *> *) FINAL OVERRIDE\n+  {}\n+};\n+\n+/* An extended_asm that's a asm goto, as created by\n+   gcc_jit_block_end_with_extended_asm_goto.  */\n+\n+class extended_asm_goto : public extended_asm\n+{\n+public:\n+  extended_asm_goto (block *b,\n+\t\t     location *loc,\n+\t\t     string *asm_template,\n+\t\t     int num_goto_blocks,\n+\t\t     block **goto_blocks,\n+\t\t     block *fallthrough_block);\n+\n+  void replay_into (replayer *r) FINAL OVERRIDE;\n+  void write_reproducer (reproducer &r) OVERRIDE;\n+\n+  vec <block *> get_successor_blocks () const FINAL OVERRIDE;\n+\n+  bool is_goto () const FINAL OVERRIDE { return true; }\n+  void maybe_print_gotos (pretty_printer *) const FINAL OVERRIDE;\n+\n+private:\n+  void maybe_populate_playback_blocks\n+    (auto_vec <playback::block *> *out) FINAL OVERRIDE;\n+\n+private:\n+  auto_vec <block *> m_goto_blocks;\n+  block *m_fallthrough_block;\n+};\n+\n+/* A group of top-level asm statements, as created by\n+   gcc_jit_context_add_top_level_asm.  */\n+\n+class top_level_asm : public memento\n+{\n+public:\n+  top_level_asm (context *ctxt, location *loc, string *asm_stmts);\n+\n+  void write_to_dump (dump &d) FINAL OVERRIDE;\n+\n+private:\n+  void replay_into (replayer *r) FINAL OVERRIDE;\n+  string * make_debug_string () FINAL OVERRIDE;\n+  void write_reproducer (reproducer &r) FINAL OVERRIDE;\n+\n+private:\n+  location *m_loc;\n+  string *m_asm_stmts;\n+};\n+\n } // namespace gcc::jit::recording\n \n /* Create a recording::memento_of_new_rvalue_from_const instance and add"}, {"sha": "b4901ceb68a8a9e7157e92974870debd45cfb780", "filename": "gcc/jit/libgccjit++.h", "status": "modified", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Fjit%2Flibgccjit%2B%2B.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Fjit%2Flibgccjit%2B%2B.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit%2B%2B.h?ref=421d0d0f54294a7bf2872b3b2ac521ce0fa9869e", "patch": "@@ -46,6 +46,7 @@ namespace gccjit\n      class lvalue;\n        class param;\n     class case_;\n+    class extended_asm;\n   class timer;\n   class auto_time;\n \n@@ -316,6 +317,9 @@ namespace gccjit\n \t\t    rvalue max_value,\n \t\t    block dest_block);\n \n+    void add_top_level_asm (const char *asm_stmts,\n+\t\t\t    location loc = location ());\n+\n   private:\n     gcc_jit_context *m_inner_ctxt;\n   };\n@@ -449,6 +453,13 @@ namespace gccjit\n \t\t\t  block default_block,\n \t\t\t  std::vector <case_> cases,\n \t\t\t  location loc = location ());\n+\n+    extended_asm add_extended_asm (const std::string &asm_template,\n+\t\t\t\t   location loc = location ());\n+    extended_asm end_with_extended_asm_goto (const std::string &asm_template,\n+\t\t\t\t\t     std::vector<block> goto_blocks,\n+\t\t\t\t\t     block *fallthrough_block,\n+\t\t\t\t\t     location loc = location ());\n   };\n \n   class rvalue : public object\n@@ -509,6 +520,40 @@ namespace gccjit\n     gcc_jit_case *get_inner_case () const;\n   };\n \n+  class extended_asm : public object\n+  {\n+  public:\n+    extended_asm ();\n+    extended_asm (gcc_jit_extended_asm *inner);\n+\n+    extended_asm &\n+    set_volatile_flag (bool flag);\n+\n+    extended_asm &\n+    set_inline_flag (bool flag);\n+\n+    extended_asm&\n+    add_output_operand (const std::string &asm_symbolic_name,\n+\t\t\tconst std::string &constraint,\n+\t\t\tgccjit::lvalue dest);\n+    extended_asm&\n+    add_output_operand (const std::string &constraint,\n+\t\t\tgccjit::lvalue dest);\n+\n+    extended_asm&\n+    add_input_operand (const std::string &asm_symbolic_name,\n+\t\t       const std::string &constraint,\n+\t\t       gccjit::rvalue src);\n+    extended_asm&\n+    add_input_operand (const std::string &constraint,\n+\t\t       gccjit::rvalue src);\n+\n+    extended_asm&\n+    add_clobber (const std::string &victim);\n+\n+    gcc_jit_extended_asm *get_inner_extended_asm () const;\n+  };\n+\n   /* Overloaded operators, for those who want the most terse API\n      (at the possible risk of being a little too magical).\n \n@@ -1259,6 +1304,14 @@ context::new_case (rvalue min_value,\n \t\t\t\t\t  dest_block.get_inner_block ()));\n }\n \n+inline void\n+context::add_top_level_asm (const char *asm_stmts, location loc)\n+{\n+  gcc_jit_context_add_top_level_asm (m_inner_ctxt,\n+\t\t\t\t     loc.get_inner_location (),\n+\t\t\t\t     asm_stmts);\n+}\n+\n // class object\n inline context\n object::get_context () const\n@@ -1554,6 +1607,37 @@ block::end_with_switch (rvalue expr,\n \t\t\t\t as_array_of_ptrs);\n }\n \n+inline extended_asm\n+block::add_extended_asm (const std::string &asm_template,\n+\t\t\t location loc)\n+{\n+  return gcc_jit_block_add_extended_asm (get_inner_block (),\n+\t\t\t\t\t loc.get_inner_location (),\n+\t\t\t\t\t asm_template.c_str ());\n+}\n+\n+inline extended_asm\n+block::end_with_extended_asm_goto (const std::string &asm_template,\n+\t\t\t\t   std::vector<block> goto_blocks,\n+\t\t\t\t   block *fallthrough_block,\n+\t\t\t\t   location loc)\n+{\n+  /* Treat std::vector as an array, relying on it not being resized: */\n+  block *as_array_of_wrappers = &goto_blocks[0];\n+\n+  /* Treat the array as being of the underlying pointers, relying on\n+     the wrapper type being such a pointer internally.  */\n+  gcc_jit_block **as_array_of_ptrs =\n+    reinterpret_cast<gcc_jit_block **> (as_array_of_wrappers);\n+  return gcc_jit_block_end_with_extended_asm_goto\n+    (get_inner_block (),\n+     loc.get_inner_location (),\n+     asm_template.c_str (),\n+     goto_blocks.size (),\n+     as_array_of_ptrs,\n+     fallthrough_block ? fallthrough_block->get_inner_block () : NULL);\n+}\n+\n inline rvalue\n block::add_call (function other,\n \t\t location loc)\n@@ -1767,6 +1851,92 @@ case_::get_inner_case () const\n   return reinterpret_cast<gcc_jit_case *> (get_inner_object ());\n }\n \n+// class extended_asm : public object\n+inline extended_asm::extended_asm () : object () {}\n+inline extended_asm::extended_asm (gcc_jit_extended_asm *inner)\n+  : object (gcc_jit_extended_asm_as_object (inner))\n+{\n+}\n+\n+inline extended_asm&\n+extended_asm::set_volatile_flag (bool flag)\n+{\n+  gcc_jit_extended_asm_set_volatile_flag (get_inner_extended_asm (), flag);\n+  return *this;\n+}\n+\n+inline extended_asm&\n+extended_asm::set_inline_flag (bool flag)\n+{\n+  gcc_jit_extended_asm_set_inline_flag (get_inner_extended_asm (), flag);\n+  return *this;\n+}\n+\n+inline extended_asm&\n+extended_asm::add_output_operand (const std::string &asm_symbolic_name,\n+\t\t\t\t  const std::string &constraint,\n+\t\t\t\t  gccjit::lvalue dest)\n+{\n+  gcc_jit_extended_asm_add_output_operand\n+    (get_inner_extended_asm (),\n+     asm_symbolic_name.c_str (),\n+     constraint.c_str (),\n+     dest.get_inner_lvalue ());\n+  return *this;\n+}\n+\n+inline extended_asm&\n+extended_asm::add_output_operand (const std::string &constraint,\n+\t\t\t\t  gccjit::lvalue dest)\n+{\n+  gcc_jit_extended_asm_add_output_operand\n+    (get_inner_extended_asm (),\n+     NULL, /* asm_symbolic_name */\n+     constraint.c_str (),\n+     dest.get_inner_lvalue ());\n+  return *this;\n+}\n+\n+inline extended_asm&\n+extended_asm::add_input_operand (const std::string &asm_symbolic_name,\n+\t\t\t\t const std::string &constraint,\n+\t\t\t\t gccjit::rvalue src)\n+{\n+  gcc_jit_extended_asm_add_input_operand\n+    (get_inner_extended_asm (),\n+     asm_symbolic_name.c_str (),\n+     constraint.c_str (),\n+     src.get_inner_rvalue ());\n+  return *this;\n+}\n+\n+inline extended_asm&\n+extended_asm::add_input_operand (const std::string &constraint,\n+\t\t\t\t gccjit::rvalue src)\n+{\n+  gcc_jit_extended_asm_add_input_operand\n+    (get_inner_extended_asm (),\n+     NULL, /* asm_symbolic_name */\n+     constraint.c_str (),\n+     src.get_inner_rvalue ());\n+  return *this;\n+}\n+\n+inline extended_asm&\n+extended_asm::add_clobber (const std::string &victim)\n+{\n+  gcc_jit_extended_asm_add_clobber (get_inner_extended_asm (),\n+\t\t\t\t    victim.c_str ());\n+  return *this;\n+}\n+\n+inline gcc_jit_extended_asm *\n+extended_asm::get_inner_extended_asm () const\n+{\n+  /* Manual downcast: */\n+  return reinterpret_cast<gcc_jit_extended_asm *> (get_inner_object ());\n+}\n+\n /* Overloaded operators.  */\n // Unary operators\n inline rvalue operator- (rvalue a)"}, {"sha": "f9c33c63c64bc34793a3ffffc8e8e3a96aa193a9", "filename": "gcc/jit/libgccjit.c", "status": "modified", "additions": 186, "deletions": 2, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Fjit%2Flibgccjit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Fjit%2Flibgccjit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.c?ref=421d0d0f54294a7bf2872b3b2ac521ce0fa9869e", "patch": "@@ -96,6 +96,11 @@ struct gcc_jit_timer : public timer\n {\n };\n \n+struct gcc_jit_extended_asm : public gcc::jit::recording::extended_asm\n+{\n+};\n+\n+\n /**********************************************************************\n  Error-handling.\n \n@@ -300,13 +305,13 @@ struct gcc_jit_timer : public timer\n \n static void\n jit_error (gcc::jit::recording::context *ctxt,\n-\t   gcc_jit_location *loc,\n+\t   gcc::jit::recording::location *loc,\n \t   const char *fmt, ...)\n   GNU_PRINTF(3, 4);\n \n static void\n jit_error (gcc::jit::recording::context *ctxt,\n-\t   gcc_jit_location *loc,\n+\t   gcc::jit::recording::location *loc,\n \t   const char *fmt, ...)\n {\n   va_list ap;\n@@ -3290,3 +3295,182 @@ gcc_jit_version_patchlevel (void)\n   version_info vi;\n   return vi.patchlevel;\n }\n+\n+/**********************************************************************\n+ Asm support.\n+ **********************************************************************/\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::block::add_extended_asm, in\n+   jit-recording.c.  */\n+\n+gcc_jit_extended_asm *\n+gcc_jit_block_add_extended_asm (gcc_jit_block *block,\n+\t\t\t\tgcc_jit_location *loc,\n+\t\t\t\tconst char *asm_template)\n+{\n+  RETURN_NULL_IF_NOT_VALID_BLOCK (block, loc);\n+  gcc::jit::recording::context *ctxt = block->get_context ();\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n+  /* LOC can be NULL.  */\n+  RETURN_NULL_IF_FAIL (asm_template, ctxt, loc, \"NULL asm_template\");\n+\n+  return (gcc_jit_extended_asm *)block->add_extended_asm (loc, asm_template);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::block::end_with_extended_asm_goto, in\n+   jit-recording.c.  */\n+\n+gcc_jit_extended_asm *\n+gcc_jit_block_end_with_extended_asm_goto (gcc_jit_block *block,\n+\t\t\t\t\t  gcc_jit_location *loc,\n+\t\t\t\t\t  const char *asm_template,\n+\t\t\t\t\t  int num_goto_blocks,\n+\t\t\t\t\t  gcc_jit_block **goto_blocks,\n+\t\t\t\t\t  gcc_jit_block *fallthrough_block)\n+{\n+  RETURN_NULL_IF_NOT_VALID_BLOCK (block, loc);\n+  gcc::jit::recording::context *ctxt = block->get_context ();\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n+  /* LOC can be NULL.  */\n+  RETURN_NULL_IF_FAIL (asm_template, ctxt, loc, \"NULL asm_template\");\n+  RETURN_NULL_IF_FAIL (num_goto_blocks >= 0, ctxt, loc, \"num_goto_blocks < 0\");\n+  for (int i = 0; i < num_goto_blocks; i++)\n+    RETURN_NULL_IF_FAIL_PRINTF1 (goto_blocks[i],\n+\t\t\t\t ctxt, loc,\n+\t\t\t\t \"NULL goto_blocks[%i]\", i);\n+  /* fallthrough_block can be NULL.  */\n+  return (gcc_jit_extended_asm *)block->end_with_extended_asm_goto\n+    (loc, asm_template,\n+     num_goto_blocks, (gcc::jit::recording::block **)goto_blocks,\n+     fallthrough_block);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, this calls the trivial\n+   gcc::jit::recording::memento::as_object method (an extended_asm is a\n+   memento), in jit-recording.h.  */\n+\n+gcc_jit_object *\n+gcc_jit_extended_asm_as_object (gcc_jit_extended_asm *ext_asm)\n+{\n+  RETURN_NULL_IF_FAIL (ext_asm, NULL, NULL, \"NULL ext_asm\");\n+\n+  return static_cast <gcc_jit_object *> (ext_asm->as_object ());\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::extended_asm::set_volatile_flag, in\n+   jit-recording.c.  */\n+\n+void\n+gcc_jit_extended_asm_set_volatile_flag (gcc_jit_extended_asm *ext_asm,\n+\t\t\t\t\tint flag)\n+{\n+  RETURN_IF_FAIL (ext_asm, NULL, NULL, \"NULL ext_asm\");\n+  ext_asm->set_volatile_flag (flag);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::extended_asm::set_inline_flag, in\n+   jit-recording.c.  */\n+\n+void\n+gcc_jit_extended_asm_set_inline_flag (gcc_jit_extended_asm *ext_asm,\n+\t\t\t\t      int flag)\n+{\n+  RETURN_IF_FAIL (ext_asm, NULL, NULL, \"NULL ext_asm\");\n+  ext_asm->set_inline_flag (flag);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::extended_asm::add_output_operand, in\n+   jit-recording.c.  */\n+\n+void\n+gcc_jit_extended_asm_add_output_operand (gcc_jit_extended_asm *ext_asm,\n+\t\t\t\t\t const char *asm_symbolic_name,\n+\t\t\t\t\t const char *constraint,\n+\t\t\t\t\t gcc_jit_lvalue *dest)\n+{\n+  RETURN_IF_FAIL (ext_asm, NULL, NULL, \"NULL ext_asm\");\n+  gcc::jit::recording::context *ctxt = ext_asm->get_context ();\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n+  gcc::jit::recording::location *loc = ext_asm->get_loc ();\n+  /* asm_symbolic_name can be NULL.  */\n+  RETURN_IF_FAIL (constraint, ctxt, loc, \"NULL constraint\");\n+  RETURN_IF_FAIL (dest, ctxt, loc, \"NULL dest\");\n+  RETURN_IF_FAIL (!ext_asm->is_goto (), ctxt, loc,\n+\t\t  \"cannot add output operand to asm goto\");\n+  ext_asm->add_output_operand (asm_symbolic_name, constraint, dest);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::extended_asm::add_input_operand, in\n+   jit-recording.c.  */\n+\n+extern void\n+gcc_jit_extended_asm_add_input_operand (gcc_jit_extended_asm *ext_asm,\n+\t\t\t\t\tconst char *asm_symbolic_name,\n+\t\t\t\t\tconst char *constraint,\n+\t\t\t\t\tgcc_jit_rvalue *src)\n+{\n+  RETURN_IF_FAIL (ext_asm, NULL, NULL, \"NULL ext_asm\");\n+  gcc::jit::recording::context *ctxt = ext_asm->get_context ();\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n+  gcc::jit::recording::location *loc = ext_asm->get_loc ();\n+  /* asm_symbolic_name can be NULL.  */\n+  RETURN_IF_FAIL (constraint, ctxt, loc, \"NULL constraint\");\n+  RETURN_IF_FAIL (src, ctxt, loc, \"NULL src\");\n+  ext_asm->add_input_operand (asm_symbolic_name, constraint, src);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::extended_asm::add_clobber, in\n+   jit-recording.c.  */\n+\n+void\n+gcc_jit_extended_asm_add_clobber (gcc_jit_extended_asm *ext_asm,\n+\t\t\t\t  const char *victim)\n+{\n+  RETURN_IF_FAIL (ext_asm, NULL, NULL, \"NULL ext_asm\");\n+  gcc::jit::recording::context *ctxt = ext_asm->get_context ();\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n+  gcc::jit::recording::location *loc = ext_asm->get_loc ();\n+  RETURN_IF_FAIL (victim, ctxt, loc, \"NULL victim\");\n+  ext_asm->add_clobber (victim);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::context::add_top_level_asm, in\n+   jit-recording.c.  */\n+\n+void\n+gcc_jit_context_add_top_level_asm (gcc_jit_context *ctxt,\n+\t\t\t\t   gcc_jit_location *loc,\n+\t\t\t\t   const char *asm_stmts)\n+{\n+  RETURN_IF_FAIL (ctxt, NULL, NULL, \"NULL ctxt\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n+  /* LOC can be NULL.  */\n+  RETURN_IF_FAIL (asm_stmts, ctxt, NULL, \"NULL asm_stmts\");\n+  ctxt->add_top_level_asm (loc, asm_stmts);\n+}"}, {"sha": "c523f93a821472ac8e898743119ee1202f30ff76", "filename": "gcc/jit/libgccjit.h", "status": "modified", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Fjit%2Flibgccjit.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Fjit%2Flibgccjit.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.h?ref=421d0d0f54294a7bf2872b3b2ac521ce0fa9869e", "patch": "@@ -68,6 +68,7 @@ typedef struct gcc_jit_result gcc_jit_result;\n \t     +- gcc_jit_lvalue\n \t\t +- gcc_jit_param\n \t +- gcc_jit_case\n+\t +- gcc_jit_extended_asm\n */\n typedef struct gcc_jit_object gcc_jit_object;\n \n@@ -138,6 +139,12 @@ typedef struct gcc_jit_param gcc_jit_param;\n    destination block.  */\n typedef struct gcc_jit_case gcc_jit_case;\n \n+/* A gcc_jit_extended_asm represents an assembly language statement,\n+   analogous to an extended \"asm\" statement in GCC's C front-end: a series\n+   of low-level instructions inside a function that convert inputs to\n+   outputs.  */\n+typedef struct gcc_jit_extended_asm gcc_jit_extended_asm;\n+\n /* Acquire a JIT-compilation context.  */\n extern gcc_jit_context *\n gcc_jit_context_acquire (void);\n@@ -1518,6 +1525,102 @@ gcc_jit_version_minor (void);\n extern int\n gcc_jit_version_patchlevel (void);\n \n+/**********************************************************************\n+ Asm support.\n+ **********************************************************************/\n+\n+/* Functions for adding inline assembler code, analogous to GCC's\n+   \"extended asm\" syntax.\n+\n+   See https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html\n+\n+   These API entrypoints were added in LIBGCCJIT_ABI_15; you can test for their\n+   presence using\n+     #ifdef LIBGCCJIT_HAVE_ASM_STATEMENTS\n+*/\n+\n+#define LIBGCCJIT_HAVE_ASM_STATEMENTS\n+\n+/* Create a gcc_jit_extended_asm for an extended asm statement\n+   with no control flow (i.e. without the goto qualifier).\n+\n+   The asm_template parameter  corresponds to the AssemblerTemplate\n+   within C's extended asm syntax.  It must be non-NULL.  */\n+\n+extern gcc_jit_extended_asm *\n+gcc_jit_block_add_extended_asm (gcc_jit_block *block,\n+\t\t\t\tgcc_jit_location *loc,\n+\t\t\t\tconst char *asm_template);\n+\n+/* Create a gcc_jit_extended_asm for an extended asm statement\n+   that may perform jumps, and use it to terminate the given block.\n+   This is equivalent to the \"goto\" qualifier in C's extended asm\n+   syntax.  */\n+\n+extern gcc_jit_extended_asm *\n+gcc_jit_block_end_with_extended_asm_goto (gcc_jit_block *block,\n+\t\t\t\t\t  gcc_jit_location *loc,\n+\t\t\t\t\t  const char *asm_template,\n+\t\t\t\t\t  int num_goto_blocks,\n+\t\t\t\t\t  gcc_jit_block **goto_blocks,\n+\t\t\t\t\t  gcc_jit_block *fallthrough_block);\n+\n+/* Upcasting from extended asm to object.  */\n+\n+extern gcc_jit_object *\n+gcc_jit_extended_asm_as_object (gcc_jit_extended_asm *ext_asm);\n+\n+/* Set whether the gcc_jit_extended_asm has side-effects, equivalent to\n+   the \"volatile\" qualifier in C's extended asm syntax.  */\n+\n+extern void\n+gcc_jit_extended_asm_set_volatile_flag (gcc_jit_extended_asm *ext_asm,\n+\t\t\t\t\tint flag);\n+\n+/* Set the equivalent of the \"inline\" qualifier in C's extended asm\n+   syntax.  */\n+\n+extern void\n+gcc_jit_extended_asm_set_inline_flag (gcc_jit_extended_asm *ext_asm,\n+\t\t\t\t      int flag);\n+\n+/* Add an output operand to the extended asm statement.\n+   \"asm_symbolic_name\" can be NULL.\n+   \"constraint\" and \"dest\" must be non-NULL.\n+   This function can't be called on an \"asm goto\" as such instructions\n+   can't have outputs  */\n+\n+extern void\n+gcc_jit_extended_asm_add_output_operand (gcc_jit_extended_asm *ext_asm,\n+\t\t\t\t\t const char *asm_symbolic_name,\n+\t\t\t\t\t const char *constraint,\n+\t\t\t\t\t gcc_jit_lvalue *dest);\n+\n+/* Add an input operand to the extended asm statement.\n+   \"asm_symbolic_name\" can be NULL.\n+   \"constraint\" and \"src\" must be non-NULL.  */\n+\n+extern void\n+gcc_jit_extended_asm_add_input_operand (gcc_jit_extended_asm *ext_asm,\n+\t\t\t\t\tconst char *asm_symbolic_name,\n+\t\t\t\t\tconst char *constraint,\n+\t\t\t\t\tgcc_jit_rvalue *src);\n+\n+/* Add \"victim\" to the list of registers clobbered by the extended\n+   asm statement.  It must be non-NULL.  */\n+\n+extern void\n+gcc_jit_extended_asm_add_clobber (gcc_jit_extended_asm *ext_asm,\n+\t\t\t\t  const char *victim);\n+\n+/* Add \"asm_stmts\", a set of top-level asm statements, analogous to\n+   those created by GCC's \"basic\" asm syntax in C at file scope.  */\n+\n+extern void\n+gcc_jit_context_add_top_level_asm (gcc_jit_context *ctxt,\n+\t\t\t\t   gcc_jit_location *loc,\n+\t\t\t\t   const char *asm_stmts);\n+\n #ifdef __cplusplus\n }\n #endif /* __cplusplus */"}, {"sha": "bcabe167c05e37326cdf59f59a56a9db277fad8f", "filename": "gcc/jit/libgccjit.map", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Fjit%2Flibgccjit.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Fjit%2Flibgccjit.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.map?ref=421d0d0f54294a7bf2872b3b2ac521ce0fa9869e", "patch": "@@ -192,3 +192,16 @@ LIBGCCJIT_ABI_14 {\n   global:\n     gcc_jit_global_set_initializer;\n } LIBGCCJIT_ABI_13;\n+\n+LIBGCCJIT_ABI_15 {\n+  global:\n+    gcc_jit_block_add_extended_asm;\n+    gcc_jit_block_end_with_extended_asm_goto;\n+    gcc_jit_extended_asm_as_object;\n+    gcc_jit_extended_asm_set_volatile_flag;\n+    gcc_jit_extended_asm_set_inline_flag;\n+    gcc_jit_extended_asm_add_output_operand;\n+    gcc_jit_extended_asm_add_input_operand;\n+    gcc_jit_extended_asm_add_clobber;\n+    gcc_jit_context_add_top_level_asm;\n+} LIBGCCJIT_ABI_14;"}, {"sha": "9af87f9c6ad690fab1ab3e852ddb35b25eb8e640", "filename": "gcc/testsuite/jit.dg/jit.exp", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Ftestsuite%2Fjit.dg%2Fjit.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Ftestsuite%2Fjit.dg%2Fjit.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Fjit.exp?ref=421d0d0f54294a7bf2872b3b2ac521ce0fa9869e", "patch": "@@ -37,12 +37,16 @@ load_lib target-libpath.exp\n load_lib gcc.exp\n load_lib g++.exp\n load_lib dejagnu.exp\n+load_lib target-supports-dg.exp\n \n # Skip these tests for targets that don't support -lgccjit\n if { ![check_effective_target_lgccjit] } {\n     return\n }\n \n+# The default do-what keyword.\n+set dg-do-what-default compile\n+\n # Look for lines of the form:\n #   definitely lost: 11,316 bytes in 235 blocks\n #   indirectly lost: 352 bytes in 4 blocks\n@@ -379,6 +383,33 @@ proc jit-dg-test { prog do_what extra_tool_flags } {\n     verbose \"  do_what: $do_what\"\n     verbose \"  extra_tool_flags: $extra_tool_flags\"\n \n+    global dg-do-what-default\n+    set dg-do-what [list ${dg-do-what-default} \"\" P]\n+\n+    set tmp [dg-get-options $prog]\n+    foreach op $tmp {\n+\tverbose \"Processing option: $op\" 3\n+\tset status [catch \"$op\" errmsg]\n+\tif { $status != 0 } {\n+\t    if { 0 && [info exists errorInfo] } {\n+\t\t# This also prints a backtrace which will just confuse\n+\t\t# testcase writers, so it's disabled.\n+\t\tperror \"$name: $errorInfo\\n\"\n+\t    } else {\n+\t\tperror \"$name: $errmsg for \\\"$op\\\"\\n\"\n+\t    }\n+\t    perror \"$name: $errmsg for \\\"$op\\\"\" 0\n+\t    return\n+\t}\n+    }\n+\n+    # If we're not supposed to try this test on this target, we're done.\n+    if { [lindex ${dg-do-what} 1] == \"N\" } {\n+\tunsupported \"$name\"\n+\tverbose \"$name not supported on this target, skipping it\" 3\n+\treturn\n+    }\n+\n     # test-threads.c needs to be linked against pthreads\n     if {[string match \"*test-threads.c\" $prog]} {\n \tappend extra_tool_flags \" -lpthread\""}, {"sha": "e7777eeb4feff6d81ed6330c44d602e17baa8c5e", "filename": "gcc/testsuite/jit.dg/test-asm.c", "status": "added", "additions": 492, "deletions": 0, "changes": 492, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Ftestsuite%2Fjit.dg%2Ftest-asm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Ftestsuite%2Fjit.dg%2Ftest-asm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-asm.c?ref=421d0d0f54294a7bf2872b3b2ac521ce0fa9869e", "patch": "@@ -0,0 +1,492 @@\n+/* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n+#include <stdint.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+/**********************************************************************\n+ Support fns for creating code.\n+ **********************************************************************/\n+\n+/* Make a \"void FUNC_NAME (void)\" function with a single block, returning\n+   that block.  */\n+\n+static gcc_jit_block *\n+make_single_block_func (gcc_jit_context *ctxt, const char *func_name)\n+{\n+  gcc_jit_type *void_type = gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_VOID);\n+  gcc_jit_function *func\n+    = gcc_jit_context_new_function (ctxt, NULL,\n+\t\t\t\t    GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t    void_type,\n+\t\t\t\t    func_name,\n+\t\t\t\t    0, NULL, 0);\n+  return gcc_jit_function_new_block (func, \"initial\");\n+}\n+\n+static const char *\n+get_desc (gcc_jit_extended_asm *ext_asm)\n+{\n+  return gcc_jit_object_get_debug_string\n+    (gcc_jit_extended_asm_as_object (ext_asm));\n+}\n+\n+/**********************************************************************\n+ Support fns for verifying code.\n+ **********************************************************************/\n+\n+typedef void (*void_void_fn) (void);\n+\n+static void_void_fn\n+get_test_fn (gcc_jit_result *result, const char *func_name)\n+{\n+  return (void_void_fn)gcc_jit_result_get_code (result, func_name);\n+}\n+\n+/**********************************************************************\n+ test_i386_basic_asm_1: simple example of asm\n+ **********************************************************************/\n+\n+/* Create the equivalent of:\n+\n+     int src;\n+     int dst;\n+\n+     void test_i386_basic_asm_1 (void)\n+     {\n+       // Quote from here in docs/topics/asm.rst: example 1: C\n+       asm (\"mov %1, %0\\n\\t\"\n+            \"add $1, %0\"\n+            : \"=r\" (dst)\n+            : \"r\" (src));\n+       // Quote up to here in docs/topics/asm.rst: example 1: C\n+     }\n+\n+     i.e. copy src to dst and add 1 to dst.  */\n+\n+static void\n+create_test_i386_basic_asm_1 (gcc_jit_context *ctxt)\n+{\n+  gcc_jit_type *int_type = gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+  gcc_jit_lvalue *dst\n+    = gcc_jit_context_new_global (ctxt, NULL,\n+\t\t\t\t  GCC_JIT_GLOBAL_EXPORTED,\n+\t\t\t\t  int_type, \"dst\");\n+  gcc_jit_lvalue *src\n+    = gcc_jit_context_new_global (ctxt, NULL,\n+\t\t\t\t  GCC_JIT_GLOBAL_EXPORTED,\n+\t\t\t\t  int_type, \"src\");\n+\n+  gcc_jit_block *block\n+    = make_single_block_func (ctxt, \"test_i386_basic_asm_1\");\n+\n+  /* Quote from here in docs/topics/asm.rst: example 1: jit.  */\n+  gcc_jit_extended_asm *ext_asm\n+    = gcc_jit_block_add_extended_asm (block, NULL,\n+\t\t\t\t      \"mov %1, %0\\n\\t\"\n+\t\t\t\t      \"add $1, %0\");\n+  gcc_jit_extended_asm_add_output_operand (ext_asm, NULL, \"=r\", dst);\n+  gcc_jit_extended_asm_add_input_operand (ext_asm, NULL, \"r\",\n+\t\t\t\t\t  gcc_jit_lvalue_as_rvalue (src));\n+  /* Quote up to here in docs/topics/asm.rst: example 1: jit.  */\n+\n+  const char *desc = get_desc (ext_asm);\n+  CHECK_STRING_VALUE\n+    (desc,\n+     \"asm (\\\"mov %1, %0\\\\n\\\\tadd $1, %0\\\" : \\\"=r\\\" (dst) : \\\"r\\\" (src) : )\");\n+\n+  gcc_jit_block_end_with_void_return (block, NULL);\n+}\n+\n+static void\n+verify_code_1 (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  void_void_fn test_i386_basic_asm_1\n+    = get_test_fn (result, \"test_i386_basic_asm_1\");\n+  CHECK_NON_NULL (test_i386_basic_asm_1);\n+\n+  int *dst_ptr = (int *)gcc_jit_result_get_global (result, \"dst\");\n+  CHECK_NON_NULL (dst_ptr);\n+  int *src_ptr = (int *)gcc_jit_result_get_global (result, \"src\");\n+  CHECK_NON_NULL (src_ptr);\n+\n+  *src_ptr = 42;\n+  *dst_ptr = 0;\n+  test_i386_basic_asm_1 ();\n+  CHECK_VALUE (*src_ptr, 42);\n+  CHECK_VALUE (*dst_ptr, 43);\n+}\n+\n+/**********************************************************************\n+ test_i386_basic_asm_2: test of symbolic names and clobbers\n+ **********************************************************************/\n+\n+/* Create the equivalent of:\n+     uint32_t test_i386_basic_asm_2 (uint32_t Mask)\n+     {\n+       uint32_t Index;\n+       // Quote from here in docs/topics/asm.rst: example 2: C\n+       asm (\"bsfl %[aMask], %[aIndex]\"\n+            : [aIndex] \"=r\" (Index)\n+            : [aMask] \"r\" (Mask)\n+            : \"cc\");\n+       // Quote up to here in docs/topics/asm.rst: example 2: C\n+       return Index;\n+     }\n+   i.e. return the first bit set in \"Mask\"\n+\n+   This exercises symbolic names and clobbers.  */\n+\n+static void\n+create_test_i386_basic_asm_2 (gcc_jit_context *ctxt)\n+{\n+  gcc_jit_type *uint32_type = gcc_jit_context_get_int_type (ctxt, 4, 0);\n+  gcc_jit_param *mask\n+    = gcc_jit_context_new_param (ctxt, NULL,\n+\t\t\t\t uint32_type, \"Mask\");\n+  gcc_jit_function *func\n+    = gcc_jit_context_new_function (ctxt, NULL,\n+\t\t\t\t    GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t    uint32_type,\n+\t\t\t\t    \"test_i386_basic_asm_2\",\n+\t\t\t\t    1, &mask, 0);\n+  gcc_jit_lvalue *index\n+    = gcc_jit_function_new_local (func, NULL,\n+\t\t\t\t  uint32_type, \"Index\");\n+  gcc_jit_block *block = gcc_jit_function_new_block (func, \"initial\");\n+\n+  /* Quote from here in docs/topics/asm.rst: example 2: jit.  */\n+  gcc_jit_extended_asm *ext_asm\n+    = gcc_jit_block_add_extended_asm (block, NULL,\n+\t\t\t\t      \"bsfl %[aMask], %[aIndex]\");\n+  gcc_jit_extended_asm_add_output_operand (ext_asm, \"aIndex\", \"=r\", index);\n+  gcc_jit_extended_asm_add_input_operand (ext_asm, \"aMask\", \"r\",\n+\t\t\t\t\t  gcc_jit_param_as_rvalue (mask));\n+  gcc_jit_extended_asm_add_clobber (ext_asm, \"cc\");\n+  /* Quote up to here in docs/topics/asm.rst: example 2: jit.  */\n+\n+  const char *desc = get_desc (ext_asm);\n+  CHECK_STRING_VALUE\n+    (desc,\n+     \"asm (\\\"bsfl %[aMask], %[aIndex]\\\"\"\n+     \" : [aIndex] \\\"=r\\\" (Index) : [aMask] \\\"r\\\" (Mask) : \\\"cc\\\")\");\n+\n+  gcc_jit_block_end_with_return (block, NULL,\n+\t\t\t\t gcc_jit_lvalue_as_rvalue (index));\n+}\n+\n+static void\n+verify_code_2 (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  typedef uint32_t (*fntype) (uint32_t);\n+  fntype test_i386_basic_asm_2\n+    = (fntype)gcc_jit_result_get_code (result, \"test_i386_basic_asm_2\");\n+  CHECK_NON_NULL (test_i386_basic_asm_2);\n+\n+  CHECK_VALUE (test_i386_basic_asm_2 (1), 0);\n+  CHECK_VALUE (test_i386_basic_asm_2 (2), 1);\n+  CHECK_VALUE (test_i386_basic_asm_2 (4), 2);\n+  CHECK_VALUE (test_i386_basic_asm_2 (8), 3);\n+}\n+\n+/**********************************************************************\n+ test_i386_basic_asm_3a/b: test of control flow: \"asm goto\"\n+ **********************************************************************/\n+\n+/* Create the equivalent of:\n+\n+     int test_i386_basic_asm_3a (int p1, int p2)\n+     {\n+       asm goto (\"btl %1, %0\\n\\t\"\n+\t\t \"jc %l2\"\n+\t\t : // No outputs\n+\t\t : \"r\" (p1), \"r\" (p2)\n+\t\t : \"cc\"\n+\t\t : carry);\n+\n+       return 0;\n+\n+      carry:\n+       return 1;\n+     }\n+\n+    or (the \"_3b\" variant) using a name rather than a number for the goto\n+    label:\n+\n+       // Quote from here in docs/topics/asm.rst: example 3b: C\n+       asm goto (\"btl %1, %0\\n\\t\"\n+                 \"jc %l[carry]\"\n+                 : // No outputs\n+                 : \"r\" (p1), \"r\" (p2)\n+                 : \"cc\"\n+                 : carry);\n+       // Quote up to here in docs/topics/asm.rst: example 3b: C\n+\n+    This exercises control flow with an asm.  */\n+\n+static void\n+create_test_i386_basic_asm_3 (gcc_jit_context *ctxt,\n+\t\t\t      const char *funcname,\n+\t\t\t      int use_name)\n+{\n+  gcc_jit_type *int_type = gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+  gcc_jit_param *p1 = gcc_jit_context_new_param (ctxt, NULL, int_type, \"p1\");\n+  gcc_jit_param *p2 = gcc_jit_context_new_param (ctxt, NULL, int_type, \"p2\");\n+  gcc_jit_param *params[2] = {p1, p2};\n+  gcc_jit_function *func\n+    = gcc_jit_context_new_function (ctxt, NULL,\n+\t\t\t\t    GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t    int_type,\n+\t\t\t\t    funcname,\n+\t\t\t\t    2, params, 0);\n+  gcc_jit_block *b_start = gcc_jit_function_new_block (func, \"start\");\n+  gcc_jit_block *b_fallthru = gcc_jit_function_new_block (func, \"fallthru\");\n+  gcc_jit_block *b_carry = gcc_jit_function_new_block (func, \"carry\");\n+\n+  gcc_jit_rvalue *zero\n+    = gcc_jit_context_new_rvalue_from_int (ctxt, int_type, 0);\n+  gcc_jit_rvalue *one\n+    = gcc_jit_context_new_rvalue_from_int (ctxt, int_type, 1);\n+\n+  /* Quote from here in docs/topics/asm.rst: example 3: jit.  */\n+  const char *asm_template =\n+    (use_name\n+     ? /* Label referred to by name: \"%l[carry]\".  */\n+       (\"btl %1, %0\\n\\t\"\n+        \"jc %l[carry]\")\n+     : /* Label referred to numerically: \"%l2\".  */\n+       (\"btl %1, %0\\n\\t\"\n+        \"jc %l2\"));\n+\n+  gcc_jit_extended_asm *ext_asm\n+    = gcc_jit_block_end_with_extended_asm_goto (b_start, NULL,\n+\t\t\t\t\t\tasm_template,\n+\t\t\t\t\t\t1, &b_carry,\n+\t\t\t\t\t\tb_fallthru);\n+  gcc_jit_extended_asm_add_input_operand (ext_asm, NULL, \"r\",\n+\t\t\t\t\t  gcc_jit_param_as_rvalue (p1));\n+  gcc_jit_extended_asm_add_input_operand (ext_asm, NULL, \"r\",\n+\t\t\t\t\t  gcc_jit_param_as_rvalue (p2));\n+  gcc_jit_extended_asm_add_clobber (ext_asm, \"cc\");\n+  /* Quote up to here in docs/topics/asm.rst: example 3: jit.  */\n+\n+  const char *desc = get_desc (ext_asm);\n+  CHECK_STRING_VALUE\n+    (desc,\n+     (use_name\n+      ? (\"asm goto (\\\"btl %1, %0\\\\n\\\\tjc %l[carry]\\\" \"\n+\t \":  : \\\"r\\\" (p1), \\\"r\\\" (p2) : \\\"cc\\\" \"\n+\t \": carry [fallthrough: fallthru])\")\n+      : (\"asm goto (\\\"btl %1, %0\\\\n\\\\tjc %l2\\\" \"\n+\t \":  : \\\"r\\\" (p1), \\\"r\\\" (p2) : \\\"cc\\\" \"\n+\t \": carry [fallthrough: fallthru])\")));\n+\n+  gcc_jit_block_end_with_return (b_fallthru, NULL, zero);\n+  gcc_jit_block_end_with_return (b_carry, NULL, one);\n+}\n+\n+static void\n+verify_code_3 (gcc_jit_context *ctxt, gcc_jit_result *result,\n+\t       const char *funcname)\n+{\n+  typedef int (*test_i386_basic_asm_3_type) (int, int);\n+\n+  test_i386_basic_asm_3_type test_i386_basic_asm_3\n+    = (test_i386_basic_asm_3_type) gcc_jit_result_get_code (result, funcname);\n+  CHECK_NON_NULL (test_i386_basic_asm_3);\n+\n+  /* The fn should test bits, returning 0 or 1.  */\n+  /* Bit 0.  */\n+  CHECK_VALUE (test_i386_basic_asm_3 (0x0000, 0), 0);\n+  CHECK_VALUE (test_i386_basic_asm_3 (0x0001, 0), 1);\n+  CHECK_VALUE (test_i386_basic_asm_3 (0x0002, 0), 0);\n+  CHECK_VALUE (test_i386_basic_asm_3 (0x0003, 0), 1);\n+  CHECK_VALUE (test_i386_basic_asm_3 (0x0004, 0), 0);\n+  /* Bit 1.  */\n+  CHECK_VALUE (test_i386_basic_asm_3 (0x0000, 1), 0);\n+  CHECK_VALUE (test_i386_basic_asm_3 (0x0001, 1), 0);\n+  CHECK_VALUE (test_i386_basic_asm_3 (0x0002, 1), 1);\n+  CHECK_VALUE (test_i386_basic_asm_3 (0x0003, 1), 1);\n+  CHECK_VALUE (test_i386_basic_asm_3 (0x0004, 1), 0);\n+\n+  for (int i = 0; i < 15; i++)\n+    {\n+      CHECK_VALUE (test_i386_basic_asm_3 (0x0000, i), 0);\n+      CHECK_VALUE (test_i386_basic_asm_3 (0xffff, i), 1);\n+    }\n+}\n+\n+/**********************************************************************\n+ test_i386_basic_asm_4: test of \"volatile\"\n+ **********************************************************************/\n+\n+/* Create the equivalent of:\n+     uint64_t test_i386_basic_asm_4 (void)\n+     {\n+       uint64_t start_time, end_time;\n+\n+       // Get start time\n+       asm volatile (\"rdtsc\\n\\t\"    // Returns the time in EDX:EAX.\n+                     \"shl $32, %%rdx\\n\\t\"  // Shift the upper bits left.\n+                     \"or %%rdx, %0\"        // 'Or' in the lower bits.\n+                     : \"=a\" (start_time)\n+                     :\n+                     : \"rdx\");\n+\n+       // could do other work here\n+\n+       // Get end time\n+       asm volatile (\"rdtsc\\n\\t\"    // Returns the time in EDX:EAX.\n+                     \"shl $32, %%rdx\\n\\t\"  // Shift the upper bits left.\n+                     \"or %%rdx, %0\"        // 'Or' in the lower bits.\n+                     : \"=a\" (start_time)\n+                     :\n+                     : \"rdx\");\n+\n+       // Get elapsed time\n+       return end_time - start_time;\n+     }\n+\n+   This exercises \"volatile\"; without it, the optimizer can assume that\n+   both asm generate the same value and thus the time difference is zero.  */\n+\n+static void\n+add_rdtsc (gcc_jit_block *block, gcc_jit_lvalue *msr)\n+{\n+  /* Quote from here in docs/topics/asm.rst: example 4: jit.  */\n+  gcc_jit_extended_asm *ext_asm\n+    = gcc_jit_block_add_extended_asm\n+\t(block, NULL,\n+\t \"rdtsc\\n\\t\"  /* Returns the time in EDX:EAX.  */\n+\t \"shl $32, %%rdx\\n\\t\"  /* Shift the upper bits left.  */\n+\t \"or %%rdx, %0\");  /* 'Or' in the lower bits.  */\n+  gcc_jit_extended_asm_set_volatile_flag (ext_asm, 1);\n+  gcc_jit_extended_asm_add_output_operand (ext_asm, NULL, \"=a\", msr);\n+  gcc_jit_extended_asm_add_clobber (ext_asm, \"rdx\");\n+  /* Quote up to here in docs/topics/asm.rst: example 4: jit.  */\n+\n+  const char *desc = get_desc (ext_asm);\n+  CHECK_STRING_STARTS_WITH (desc, \"asm volatile (\");\n+}\n+\n+static void\n+create_test_i386_basic_asm_4 (gcc_jit_context *ctxt)\n+{\n+  gcc_jit_type *uint64_type = gcc_jit_context_get_int_type (ctxt, 8, 0);\n+  gcc_jit_function *func\n+    = gcc_jit_context_new_function (ctxt, NULL,\n+\t\t\t\t    GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t    uint64_type,\n+\t\t\t\t    \"test_i386_basic_asm_4\",\n+\t\t\t\t    0, NULL, 0);\n+  gcc_jit_block *block = gcc_jit_function_new_block (func, NULL);\n+\n+  gcc_jit_lvalue *start_time\n+    = gcc_jit_function_new_local (func, NULL, uint64_type, \"start_time\");\n+  add_rdtsc (block, start_time);\n+\n+  gcc_jit_block_add_comment (block, NULL, \"other work here\");\n+\n+  gcc_jit_lvalue *end_time\n+    = gcc_jit_function_new_local (func, NULL, uint64_type, \"end_time\");\n+  add_rdtsc (block, end_time);\n+\n+  gcc_jit_rvalue *elapsed\n+    = gcc_jit_context_new_binary_op (ctxt, NULL, GCC_JIT_BINARY_OP_MINUS,\n+\t\t\t\t     uint64_type,\n+\t\t\t\t     gcc_jit_lvalue_as_rvalue (end_time),\n+\t\t\t\t     gcc_jit_lvalue_as_rvalue (start_time));\n+  gcc_jit_block_end_with_return (block, NULL, elapsed);\n+}\n+\n+static void\n+verify_code_4 (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  typedef uint64_t (*fntype) (void);\n+  fntype test_i386_basic_asm_4\n+    = (fntype)gcc_jit_result_get_code (result, \"test_i386_basic_asm_4\");\n+\n+  CHECK_NON_NULL (test_i386_basic_asm_4);\n+\n+  test_i386_basic_asm_4 ();\n+}\n+\n+/**********************************************************************\n+ test_i386_basic_asm_5: test of top-level asm\n+ **********************************************************************/\n+\n+/* Create the equivalent of:\n+\n+   // Quote from here in docs/topics/asm.rst: example 5: C\n+     asm (\"\\t.pushsection .text\\n\"\n+          \"\\t.globl add_asm\\n\"\n+          \"\\t.type add_asm, @function\\n\"\n+          \"add_asm:\\n\"\n+          \"\\tmovq %rdi, %rax\\n\"\n+          \"\\tadd %rsi, %rax\\n\"\n+          \"\\tret\\n\"\n+          \"\\t.popsection\\n\");\n+   // Quote up to here in docs/topics/asm.rst: example 5: C\n+\n+   to add a simple function (\"add_asm\") directly in assembly language.  */\n+\n+static void\n+create_test_i386_basic_asm_5 (gcc_jit_context *ctxt)\n+{\n+  /* Quote from here in docs/topics/asm.rst: example 5: jit.  */\n+  gcc_jit_context_add_top_level_asm (ctxt, NULL,\n+                                     \"\\t.pushsection .text\\n\"\n+                                     \"\\t.globl add_asm\\n\"\n+                                     \"\\t.type add_asm, @function\\n\"\n+                                     \"add_asm:\\n\"\n+                                     \"\\tmovq %rdi, %rax\\n\"\n+                                     \"\\tadd %rsi, %rax\\n\"\n+                                     \"\\tret\\n\"\n+                                     \"\\t# some asm here\\n\"\n+                                     \"\\t.popsection\\n\");\n+  /* Quote up to here in docs/topics/asm.rst: example 5: jit.  */\n+}\n+\n+static void\n+verify_code_5 (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  typedef int (*test_i386_basic_asm_5_type) (int, int);\n+  test_i386_basic_asm_5_type test_i386_basic_asm_5\n+    = (test_i386_basic_asm_5_type) gcc_jit_result_get_code (result, \"add_asm\");\n+  CHECK_NON_NULL (test_i386_basic_asm_5);\n+\n+  CHECK_VALUE (test_i386_basic_asm_5 (2, 2), 4);\n+  CHECK_VALUE (test_i386_basic_asm_5 (20, 7), 27);\n+}\n+\n+/**********************************************************************\n+ Code for harness\n+ **********************************************************************/\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  create_test_i386_basic_asm_1 (ctxt);\n+  create_test_i386_basic_asm_2 (ctxt);\n+  create_test_i386_basic_asm_3 (ctxt, \"test_i386_basic_asm_3a\", 0);\n+  create_test_i386_basic_asm_3 (ctxt, \"test_i386_basic_asm_3b\", 1);\n+  create_test_i386_basic_asm_4 (ctxt);\n+  create_test_i386_basic_asm_5 (ctxt);\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  CHECK_NON_NULL (result);\n+  verify_code_1 (ctxt, result);\n+  verify_code_2 (ctxt, result);\n+  verify_code_3 (ctxt, result, \"test_i386_basic_asm_3a\");\n+  verify_code_3 (ctxt, result, \"test_i386_basic_asm_3b\");\n+  verify_code_4 (ctxt, result);\n+  verify_code_5 (ctxt, result);\n+}"}, {"sha": "6f1828060ff6b8546b069321edc4df307ad02f6d", "filename": "gcc/testsuite/jit.dg/test-asm.cc", "status": "added", "additions": 453, "deletions": 0, "changes": 453, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Ftestsuite%2Fjit.dg%2Ftest-asm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e/gcc%2Ftestsuite%2Fjit.dg%2Ftest-asm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-asm.cc?ref=421d0d0f54294a7bf2872b3b2ac521ce0fa9869e", "patch": "@@ -0,0 +1,453 @@\n+/* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n+\n+#include \"libgccjit++.h\"\n+\n+#include \"harness.h\"\n+\n+/**********************************************************************\n+ Support fns for creating code.\n+ **********************************************************************/\n+\n+/* Make a \"void FUNC_NAME (void)\" function with a single block, returning\n+   that block.  */\n+\n+static gccjit::block\n+make_single_block_func (gccjit::context ctxt, const char *func_name)\n+{\n+  gccjit::type void_type = ctxt.get_type (GCC_JIT_TYPE_VOID);\n+  std::vector<gccjit::param> params;\n+  gccjit::function func\n+    = ctxt.new_function (GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t void_type,\n+\t\t\t func_name, params, 0);\n+  return func.new_block (\"initial\");\n+}\n+\n+/**********************************************************************\n+ Support fns for verifying code.\n+ **********************************************************************/\n+\n+typedef void (*void_void_fn) (void);\n+\n+static void_void_fn\n+get_test_fn (gcc_jit_result *result, const char *func_name)\n+{\n+  return (void_void_fn)gcc_jit_result_get_code (result, func_name);\n+}\n+\n+/**********************************************************************\n+ test_i386_basic_asm_1: simple example of asm\n+ **********************************************************************/\n+\n+/* Create the equivalent of:\n+\n+     int src;\n+     int dst;\n+\n+     void test_i386_basic_asm_1 (void)\n+     {\n+       // Quote from here in docs/cp/topics/asm.rst: example 1: C\n+       asm (\"mov %1, %0\\n\\t\"\n+            \"add $1, %0\"\n+            : \"=r\" (dst)\n+            : \"r\" (src));\n+       // Quote up to here in docs/cp/topics/asm.rst: example 1: C\n+     }\n+\n+     i.e. copy src to dst and add 1 to dst.  */\n+\n+static void\n+create_test_i386_basic_asm_1 (gcc_jit_context *c_ctxt)\n+{\n+  gccjit::context ctxt (c_ctxt);\n+  gccjit::type int_type = ctxt.get_type (GCC_JIT_TYPE_INT);\n+  gccjit::lvalue dst\n+    = ctxt.new_global (GCC_JIT_GLOBAL_EXPORTED, int_type, \"dst\");\n+  gccjit::lvalue src\n+    = ctxt.new_global (GCC_JIT_GLOBAL_EXPORTED, int_type, \"src\");\n+\n+  gccjit::block block\n+    = make_single_block_func (ctxt, \"test_i386_basic_asm_1\");\n+\n+  gccjit::extended_asm ext_asm =\n+  /* Quote from here in docs/cp/topics/asm.rst: example 1: jit.  */\n+    block.add_extended_asm (\"mov %1, %0\\n\\t\"\n+                            \"add $1, %0\")\n+    .add_output_operand (\"=r\", dst)\n+    .add_input_operand (\"r\", src);\n+  /* Quote up to here in docs/cp/topics/asm.rst: example 1: jit.  */\n+\n+  std::string desc = ext_asm.get_debug_string ();\n+  CHECK_STRING_VALUE\n+    (desc.c_str (),\n+     \"asm (\\\"mov %1, %0\\\\n\\\\tadd $1, %0\\\" : \\\"=r\\\" (dst) : \\\"r\\\" (src) : )\");\n+\n+  block.end_with_return ();\n+}\n+\n+static void\n+verify_code_1 (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  void_void_fn test_i386_basic_asm_1\n+    = get_test_fn (result, \"test_i386_basic_asm_1\");\n+  CHECK_NON_NULL (test_i386_basic_asm_1);\n+\n+  int *dst_ptr = (int *)gcc_jit_result_get_global (result, \"dst\");\n+  CHECK_NON_NULL (dst_ptr);\n+  int *src_ptr = (int *)gcc_jit_result_get_global (result, \"src\");\n+  CHECK_NON_NULL (src_ptr);\n+\n+  *src_ptr = 42;\n+  *dst_ptr = 0;\n+  test_i386_basic_asm_1 ();\n+  CHECK_VALUE (*src_ptr, 42);\n+  CHECK_VALUE (*dst_ptr, 43);\n+}\n+\n+/**********************************************************************\n+ test_i386_basic_asm_2: test of symbolic names and clobbers\n+ **********************************************************************/\n+\n+/* Create the equivalent of:\n+     uint32_t test_i386_basic_asm_2 (uint32_t Mask)\n+     {\n+       uint32_t Index;\n+       // Quote from here in docs/cp/topics/asm.rst: example 2: C\n+       asm (\"bsfl %[aMask], %[aIndex]\"\n+            : [aIndex] \"=r\" (Index)\n+            : [aMask] \"r\" (Mask)\n+            : \"cc\");\n+       // Quote up to here in docs/cp/topics/asm.rst: example 2: C\n+       return Index;\n+     }\n+   i.e. return the first bit set in \"Mask\"\n+\n+   This exercises symbolic names and clobbers.  */\n+\n+static void\n+create_test_i386_basic_asm_2 (gcc_jit_context *c_ctxt)\n+{\n+  gccjit::context ctxt (c_ctxt);\n+  gccjit::type uint32_type = ctxt.get_int_type (4, 0);\n+  gccjit::param mask = ctxt.new_param (uint32_type, \"Mask\");\n+  std::vector<gccjit::param> params {mask};\n+  gccjit::function func = ctxt.new_function (GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t\t     uint32_type,\n+\t\t\t\t\t     \"test_i386_basic_asm_2\",\n+\t\t\t\t\t     params, 0);\n+  gccjit::lvalue index = func.new_local (uint32_type, \"Index\");\n+  gccjit::block block = func.new_block (\"initial\");\n+  gccjit::extended_asm ext_asm =\n+  /* Quote from here in docs/cp/topics/asm.rst: example 2: jit.  */\n+    block.add_extended_asm (\"bsfl %[aMask], %[aIndex]\")\n+    .add_output_operand (\"aIndex\", \"=r\", index)\n+    .add_input_operand (\"aMask\", \"r\", mask)\n+    .add_clobber (\"cc\");\n+  /* Quote up to here in docs/cp/topics/asm.rst: example 2: jit.  */\n+\n+  std::string desc = ext_asm.get_debug_string ();\n+  CHECK_STRING_VALUE\n+    (desc.c_str (),\n+     \"asm (\\\"bsfl %[aMask], %[aIndex]\\\"\"\n+     \" : [aIndex] \\\"=r\\\" (Index) : [aMask] \\\"r\\\" (Mask) : \\\"cc\\\")\");\n+\n+  block.end_with_return (index);\n+}\n+\n+static void\n+verify_code_2 (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  typedef uint32_t (*fntype) (uint32_t);\n+  fntype test_i386_basic_asm_2\n+    = (fntype)gcc_jit_result_get_code (result, \"test_i386_basic_asm_2\");\n+  CHECK_NON_NULL (test_i386_basic_asm_2);\n+\n+  CHECK_VALUE (test_i386_basic_asm_2 (1), 0);\n+  CHECK_VALUE (test_i386_basic_asm_2 (2), 1);\n+  CHECK_VALUE (test_i386_basic_asm_2 (4), 2);\n+  CHECK_VALUE (test_i386_basic_asm_2 (8), 3);\n+}\n+\n+/**********************************************************************\n+ test_i386_basic_asm_3a/b: test of control flow: \"asm goto\"\n+ **********************************************************************/\n+\n+/* Create the equivalent of:\n+\n+     int test_i386_basic_asm_3a (int p1, int p2)\n+     {\n+       asm goto (\"btl %1, %0\\n\\t\"\n+\t\t \"jc %l2\"\n+\t\t : // No outputs\n+\t\t : \"r\" (p1), \"r\" (p2)\n+\t\t : \"cc\"\n+\t\t : carry);\n+\n+       return 0;\n+\n+      carry:\n+       return 1;\n+     }\n+\n+    or (the \"_3b\" variant) using a name rather than a number for the goto\n+    label:\n+\n+       // Quote from here in docs/cp/topics/asm.rst: example 3b: C\n+       asm goto (\"btl %1, %0\\n\\t\"\n+                 \"jc %l[carry]\"\n+                 : // No outputs\n+                 : \"r\" (p1), \"r\" (p2)\n+                 : \"cc\"\n+                 : carry);\n+       // Quote up to here in docs/cp/topics/asm.rst: example 3b: C\n+\n+    This exercises control flow with an asm.  */\n+\n+static void\n+create_test_i386_basic_asm_3 (gcc_jit_context *c_ctxt,\n+\t\t\t      const char *funcname,\n+\t\t\t      int use_name)\n+{\n+  gccjit::context ctxt (c_ctxt);\n+  gccjit::type int_type = ctxt.get_type (GCC_JIT_TYPE_INT);\n+  gccjit::param p1 = ctxt.new_param (int_type, \"p1\");\n+  gccjit::param p2 = ctxt.new_param (int_type, \"p2\");\n+  std::vector<gccjit::param> params ({p1, p2});\n+  gccjit::function func = ctxt.new_function (GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t\t     int_type,\n+\t\t\t\t\t     funcname,\n+\t\t\t\t\t     params, 0);\n+  gccjit::block b_start = func.new_block (\"start\");\n+  gccjit::block b_fallthru = func.new_block (\"fallthru\");\n+  gccjit::block b_carry = func.new_block (\"carry\");\n+\n+  gccjit::rvalue zero = ctxt.new_rvalue (int_type, 0);\n+  gccjit::rvalue one = ctxt.new_rvalue (int_type, 1);\n+\n+  /* Quote from here in docs/cp/topics/asm.rst: example 3: jit.  */\n+  const char *asm_template =\n+    (use_name\n+     ? /* Label referred to by name: \"%l[carry]\".  */\n+       (\"btl %1, %0\\n\\t\"\n+        \"jc %l[carry]\")\n+     : /* Label referred to numerically: \"%l2\".  */\n+       (\"btl %1, %0\\n\\t\"\n+        \"jc %l2\"));\n+\n+  std::vector<gccjit::block> goto_blocks ({b_carry});\n+  gccjit::extended_asm ext_asm\n+    = (b_start.end_with_extended_asm_goto (asm_template,\n+\t\t\t\t\t  goto_blocks,\n+\t\t\t\t\t  &b_fallthru)\n+       .add_input_operand (\"r\", p1)\n+       .add_input_operand (\"r\", p2)\n+       .add_clobber (\"cc\"));\n+  /* Quote up to here in docs/cp/topics/asm.rst: example 3: jit.  */\n+\n+  std::string desc = ext_asm.get_debug_string ();\n+  CHECK_STRING_VALUE\n+    (desc.c_str (),\n+     (use_name\n+      ? (\"asm goto (\\\"btl %1, %0\\\\n\\\\tjc %l[carry]\\\" \"\n+\t \":  : \\\"r\\\" (p1), \\\"r\\\" (p2) : \\\"cc\\\" \"\n+\t \": carry [fallthrough: fallthru])\")\n+      : (\"asm goto (\\\"btl %1, %0\\\\n\\\\tjc %l2\\\" \"\n+\t \":  : \\\"r\\\" (p1), \\\"r\\\" (p2) : \\\"cc\\\" \"\n+\t \": carry [fallthrough: fallthru])\")));\n+\n+  b_fallthru.end_with_return (zero);\n+  b_carry.end_with_return (one);\n+}\n+\n+static void\n+verify_code_3 (gcc_jit_context *ctxt, gcc_jit_result *result,\n+\t       const char *funcname)\n+{\n+  typedef int (*test_i386_basic_asm_3_type) (int, int);\n+\n+  test_i386_basic_asm_3_type test_i386_basic_asm_3\n+    = (test_i386_basic_asm_3_type) gcc_jit_result_get_code (result, funcname);\n+  CHECK_NON_NULL (test_i386_basic_asm_3);\n+\n+  /* The fn should test bits, returning 0 or 1.  */\n+  /* Bit 0.  */\n+  CHECK_VALUE (test_i386_basic_asm_3 (0x0000, 0), 0);\n+  CHECK_VALUE (test_i386_basic_asm_3 (0x0001, 0), 1);\n+  CHECK_VALUE (test_i386_basic_asm_3 (0x0002, 0), 0);\n+  CHECK_VALUE (test_i386_basic_asm_3 (0x0003, 0), 1);\n+  CHECK_VALUE (test_i386_basic_asm_3 (0x0004, 0), 0);\n+  /* Bit 1.  */\n+  CHECK_VALUE (test_i386_basic_asm_3 (0x0000, 1), 0);\n+  CHECK_VALUE (test_i386_basic_asm_3 (0x0001, 1), 0);\n+  CHECK_VALUE (test_i386_basic_asm_3 (0x0002, 1), 1);\n+  CHECK_VALUE (test_i386_basic_asm_3 (0x0003, 1), 1);\n+  CHECK_VALUE (test_i386_basic_asm_3 (0x0004, 1), 0);\n+\n+  for (int i = 0; i < 15; i++)\n+    {\n+      CHECK_VALUE (test_i386_basic_asm_3 (0x0000, i), 0);\n+      CHECK_VALUE (test_i386_basic_asm_3 (0xffff, i), 1);\n+    }\n+}\n+\n+/**********************************************************************\n+ test_i386_basic_asm_4: test of \"volatile\"\n+ **********************************************************************/\n+\n+/* Create the equivalent of:\n+     uint64_t test_i386_basic_asm_4 (void)\n+     {\n+       uint64_t start_time, end_time;\n+\n+       // Get start time\n+       asm volatile (\"rdtsc\\n\\t\"    // Returns the time in EDX:EAX.\n+                     \"shl $32, %%rdx\\n\\t\"  // Shift the upper bits left.\n+                     \"or %%rdx, %0\"        // 'Or' in the lower bits.\n+                     : \"=a\" (start_time)\n+                     :\n+                     : \"rdx\");\n+\n+       // could do other work here\n+\n+       // Get end time\n+       asm volatile (\"rdtsc\\n\\t\"    // Returns the time in EDX:EAX.\n+                     \"shl $32, %%rdx\\n\\t\"  // Shift the upper bits left.\n+                     \"or %%rdx, %0\"        // 'Or' in the lower bits.\n+                     : \"=a\" (start_time)\n+                     :\n+                     : \"rdx\");\n+\n+       // Get elapsed time\n+       return end_time - start_time;\n+     }\n+\n+   This exercises \"volatile\"; without it, the optimizer can assume that\n+   both asm generate the same value and thus the time difference is zero.  */\n+\n+static void\n+add_rdtsc (gccjit::block block, gccjit::lvalue msr)\n+{\n+  /* Quote from here in docs/cp/topics/asm.rst: example 4: jit.  */\n+  gccjit::extended_asm ext_asm\n+    = block.add_extended_asm\n+\t(\"rdtsc\\n\\t\"  /* Returns the time in EDX:EAX.  */\n+\t \"shl $32, %%rdx\\n\\t\"  /* Shift the upper bits left.  */\n+\t \"or %%rdx, %0\")  /* 'Or' in the lower bits.  */\n+    .set_volatile_flag (true)\n+    .add_output_operand (\"=a\", msr)\n+    .add_clobber (\"rdx\");\n+  /* Quote up to here in docs/cp/topics/asm.rst: example 4: jit.  */\n+\n+  std::string desc = ext_asm.get_debug_string ();\n+  CHECK_STRING_STARTS_WITH (desc.c_str (), \"asm volatile (\");\n+}\n+\n+static void\n+create_test_i386_basic_asm_4 (gcc_jit_context *c_ctxt)\n+{\n+  gccjit::context ctxt (c_ctxt);\n+  gccjit::type uint64_type = ctxt.get_int_type (8, 0);\n+  std::vector<gccjit::param> params;\n+  gccjit::function func = ctxt.new_function (GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t\t      uint64_type,\n+\t\t\t\t\t      \"test_i386_basic_asm_4\",\n+\t\t\t\t\t     params, 0);\n+  gccjit::block block = func.new_block ();\n+\n+  gccjit::lvalue start_time = func.new_local (uint64_type, \"start_time\");\n+  add_rdtsc (block, start_time);\n+\n+  block.add_comment (\"other work here\");\n+\n+  gccjit::lvalue end_time = func.new_local (uint64_type, \"end_time\");\n+  add_rdtsc (block, end_time);\n+\n+  block.end_with_return (end_time - start_time);\n+}\n+\n+static void\n+verify_code_4 (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  typedef uint64_t (*fntype) (void);\n+  fntype test_i386_basic_asm_4\n+    = (fntype)gcc_jit_result_get_code (result, \"test_i386_basic_asm_4\");\n+\n+  CHECK_NON_NULL (test_i386_basic_asm_4);\n+\n+  test_i386_basic_asm_4 ();\n+}\n+\n+/**********************************************************************\n+ test_i386_basic_asm_5: test of top-level asm\n+ **********************************************************************/\n+\n+/* Create the equivalent of:\n+\n+   // Quote from here in docs/cp/topics/asm.rst: example 5: C\n+     asm (\"\\t.pushsection .text\\n\"\n+          \"\\t.globl add_asm\\n\"\n+          \"\\t.type add_asm, @function\\n\"\n+          \"add_asm:\\n\"\n+          \"\\tmovq %rdi, %rax\\n\"\n+          \"\\tadd %rsi, %rax\\n\"\n+          \"\\tret\\n\"\n+          \"\\t.popsection\\n\");\n+   // Quote up to here in docs/cp/topics/asm.rst: example 5: C\n+\n+   to add a simple function (\"add_asm\") directly in assembly language.  */\n+\n+static void\n+create_test_i386_basic_asm_5 (gcc_jit_context *c_ctxt)\n+{\n+  gccjit::context ctxt (c_ctxt);\n+  /* Quote from here in docs/cp/topics/asm.rst: example 5: jit.  */\n+  ctxt.add_top_level_asm (\"\\t.pushsection .text\\n\"\n+                          \"\\t.globl add_asm\\n\"\n+                          \"\\t.type add_asm, @function\\n\"\n+                          \"add_asm:\\n\"\n+                          \"\\tmovq %rdi, %rax\\n\"\n+                          \"\\tadd %rsi, %rax\\n\"\n+                          \"\\tret\\n\"\n+                          \"\\t# some asm here\\n\"\n+                          \"\\t.popsection\\n\");\n+  /* Quote up to here in docs/cp/topics/asm.rst: example 5: jit.  */\n+}\n+\n+static void\n+verify_code_5 (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  typedef int (*test_i386_basic_asm_5_type) (int, int);\n+  test_i386_basic_asm_5_type test_i386_basic_asm_5\n+    = (test_i386_basic_asm_5_type) gcc_jit_result_get_code (result, \"add_asm\");\n+  CHECK_NON_NULL (test_i386_basic_asm_5);\n+\n+  CHECK_VALUE (test_i386_basic_asm_5 (2, 2), 4);\n+  CHECK_VALUE (test_i386_basic_asm_5 (20, 7), 27);\n+}\n+\n+/**********************************************************************\n+ Code for harness\n+ **********************************************************************/\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  create_test_i386_basic_asm_1 (ctxt);\n+  create_test_i386_basic_asm_2 (ctxt);\n+  create_test_i386_basic_asm_3 (ctxt, \"test_i386_basic_asm_3a\", 0);\n+  create_test_i386_basic_asm_3 (ctxt, \"test_i386_basic_asm_3b\", 1);\n+  create_test_i386_basic_asm_4 (ctxt);\n+  create_test_i386_basic_asm_5 (ctxt);\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  CHECK_NON_NULL (result);\n+  verify_code_1 (ctxt, result);\n+  verify_code_2 (ctxt, result);\n+  verify_code_3 (ctxt, result, \"test_i386_basic_asm_3a\");\n+  verify_code_3 (ctxt, result, \"test_i386_basic_asm_3b\");\n+  verify_code_4 (ctxt, result);\n+  verify_code_5 (ctxt, result);\n+}"}]}