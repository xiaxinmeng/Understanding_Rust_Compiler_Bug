{"sha": "3748bd9e22eafbd213c7d268d0a00b8b35faf743", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzc0OGJkOWUyMmVhZmJkMjEzYzdkMjY4ZDBhMDBiOGIzNWZhZjc0Mw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2002-11-20T09:52:14Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2002-11-20T09:52:14Z"}, "message": "global.c (find_reg): Check HARD_REGNO_NREGS before kicking out another register.\n\n\t* global.c (find_reg): Check HARD_REGNO_NREGS before kicking\n\tout another register.\n\nFrom-SVN: r59298", "tree": {"sha": "577d8857ebceccf6f97ebb912ea0316a3e005c83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/577d8857ebceccf6f97ebb912ea0316a3e005c83"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3748bd9e22eafbd213c7d268d0a00b8b35faf743", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3748bd9e22eafbd213c7d268d0a00b8b35faf743", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3748bd9e22eafbd213c7d268d0a00b8b35faf743", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3748bd9e22eafbd213c7d268d0a00b8b35faf743/comments", "author": null, "committer": null, "parents": [{"sha": "bc02f8d3f74173fa46f74934ebcc1fc3501b94da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc02f8d3f74173fa46f74934ebcc1fc3501b94da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc02f8d3f74173fa46f74934ebcc1fc3501b94da"}], "stats": {"total": 72, "additions": 72, "deletions": 0}, "files": [{"sha": "e3ddb43bf83a7d3c550c766d63d389f1f2068b99", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3748bd9e22eafbd213c7d268d0a00b8b35faf743/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3748bd9e22eafbd213c7d268d0a00b8b35faf743/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3748bd9e22eafbd213c7d268d0a00b8b35faf743", "patch": "@@ -1,3 +1,8 @@\n+2002-11-20  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* global.c (find_reg): Check HARD_REGNO_NREGS before kicking\n+\tout another register.\n+\n 2002-11-20  Jakub Jelinek  <jakub@redhat.com>\n \n \t* combine.c (force_to_mode): Only replace with (not Y) if all bits in fuller_mask"}, {"sha": "471e42e8fd9356ade2283261ad3787d8fcddd327", "filename": "gcc/global.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3748bd9e22eafbd213c7d268d0a00b8b35faf743/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3748bd9e22eafbd213c7d268d0a00b8b35faf743/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=3748bd9e22eafbd213c7d268d0a00b8b35faf743", "patch": "@@ -1192,6 +1192,11 @@ find_reg (num, losers, alt_regs_p, accept_call_clobbered, retrying)\n \t      /* Don't use a reg no good for this pseudo.  */\n \t      && ! TEST_HARD_REG_BIT (used2, regno)\n \t      && HARD_REGNO_MODE_OK (regno, mode)\n+\t      /* The code below assumes that we need only a single\n+\t\t register, but the check of allocno[num].size above\n+\t\t was not enough.  Sometimes we need more than one\n+\t\t register for a single-word value.  */\n+\t      && HARD_REGNO_NREGS (regno, mode) == 1\n \t      && (allocno[num].calls_crossed == 0\n \t\t  || accept_call_clobbered\n \t\t  || ! HARD_REGNO_CALL_PART_CLOBBERED (regno, mode))"}, {"sha": "1ba905f524ab50c8c7b4ecf632b320561da0dde8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3748bd9e22eafbd213c7d268d0a00b8b35faf743/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3748bd9e22eafbd213c7d268d0a00b8b35faf743/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3748bd9e22eafbd213c7d268d0a00b8b35faf743", "patch": "@@ -1,3 +1,7 @@\n+2002-11-20  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* gcc.c-torture/execute/20021120-1.c: New test.\n+\n 2002-11-20  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.c-torture/execute/20021118-3.c: New test."}, {"sha": "491d5d6a08142a48b5b6d90f4b1cc41f5b7720a0", "filename": "gcc/testsuite/gcc.c-torture/execute/20021120-1.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3748bd9e22eafbd213c7d268d0a00b8b35faf743/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20021120-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3748bd9e22eafbd213c7d268d0a00b8b35faf743/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20021120-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20021120-1.c?ref=3748bd9e22eafbd213c7d268d0a00b8b35faf743", "patch": "@@ -0,0 +1,58 @@\n+/* Macros to emit \"L Nxx R\" for each octal number xx between 000 and 037.  */\n+#define OP1(L, N, R, I, J) L N##I##J R\n+#define OP2(L, N, R, I) \\\n+    OP1(L, N, R, 0, I), OP1(L, N, R, 1, I), \\\n+    OP1(L, N, R, 2, I), OP1(L, N, R, 3, I)\n+#define OP(L, N, R) \\\n+    OP2(L, N, R, 0), OP2(L, N, R, 1), OP2(L, N, R, 2), OP2(L, N, R, 3), \\\n+    OP2(L, N, R, 4), OP2(L, N, R, 5), OP2(L, N, R, 6), OP2(L, N, R, 7)\n+\n+/* Declare 32 unique variables with prefix N.  */\n+#define DECLARE(N) OP (, N,)\n+\n+/* Copy 32 variables with prefix N from the array at ADDR.\n+   Leave ADDR pointing to the end of the array.  */\n+#define COPYIN(N, ADDR) OP (, N, = *(ADDR++))\n+\n+/* Likewise, but copy the other way.  */\n+#define COPYOUT(N, ADDR) OP (*(ADDR++) =, N,)\n+\n+/* Add the contents of the array at ADDR to 32 variables with prefix N.\n+   Leave ADDR pointing to the end of the array.  */\n+#define ADD(N, ADDR) OP (, N, += *(ADDR++))\n+\n+volatile double gd[32];\n+volatile float gf[32];\n+\n+void foo (int n)\n+{\n+  double DECLARE(d);\n+  float DECLARE(f);\n+  volatile double *pd;\n+  volatile float *pf;\n+  int i;\n+\n+  pd = gd; COPYIN (d, pd);\n+  for (i = 0; i < n; i++)\n+    {\n+      pf = gf; COPYIN (f, pf);\n+      pd = gd; ADD (d, pd);\n+      pd = gd; ADD (d, pd);\n+      pd = gd; ADD (d, pd);\n+      pf = gf; COPYOUT (f, pf);\n+    }\n+  pd = gd; COPYOUT (d, pd);\n+}\n+\n+int main ()\n+{\n+  int i;\n+\n+  for (i = 0; i < 32; i++)\n+    gd[i] = i, gf[i] = i;\n+  foo (1);\n+  for (i = 0; i < 32; i++)\n+    if (gd[i] != i * 4 || gf[i] != i)\n+      abort ();\n+  exit (0);\n+}"}]}