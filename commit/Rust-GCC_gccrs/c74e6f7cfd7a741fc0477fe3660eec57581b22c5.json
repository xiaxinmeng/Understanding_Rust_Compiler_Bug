{"sha": "c74e6f7cfd7a741fc0477fe3660eec57581b22c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzc0ZTZmN2NmZDdhNzQxZmMwNDc3ZmUzNjYwZWVjNTc1ODFiMjJjNQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-09-25T18:58:26Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-09-25T19:03:54Z"}, "message": "c++: Adjust pushdecl/duplicate_decls API\n\nThe decl pushing APIs and duplicate_decls take an 'is_friend' parm,\nwhen what they actually mean is 'hide this from name lookup'.  That\nconflation has gotten more anachronistic as time moved on.  We now\nhave anticipated builtins, and I plan to have injected extern decls\nsoon.  So this patch is mainly a renaming excercise.  is_friend ->\nhiding.  duplicate_decls gets an additional 'was_hidden' parm.  As\nI've already said, hiddenness is a property of the symbol table, not\nthe decl.  Builtins are now pushed requesting hiding, and pushdecl\nasserts that we don't attempt to push a thing that should be hidden\nwithout asking for it to be hidden.\n\nThis is the final piece of groundwork to get rid of a bunch of 'this\nis hidden' markers on decls and move the hiding management entirely\ninto name lookup.\n\n\tgcc/cp/\n\t* cp-tree.h (duplicate_decls): Replace 'is_friend' with 'hiding'\n\tand add 'was_hidden'.\n\t* name-lookup.h (pushdecl_namespace_level): Replace 'is_friend'\n\twith 'hiding'.\n\t(pushdecl): Likewise.\n\t(pushdecl_top_level): Drop is_friend parm.\n\t* decl.c (check_no_redeclaration_friend_default_args): Rename parm\n\tolddelc_hidden_p.\n\t(duplicate_decls): Replace 'is_friend' with 'hiding'\n\tand 'was_hidden'.  Do minimal adjustments in body.\n\t(cxx_builtin_function): Pass 'hiding' to pushdecl.\n\t* friend.c (do_friend): Pass 'hiding' to pushdecl.\n\t* name-lookup.c (supplement_binding_1): Drop defaulted arg to\n\tduplicate_decls.\n\t(update_binding): Replace 'is_friend' with 'hiding'.  Drop\n\tdefaulted arg to duplicate_decls.\n\t(do_pushdecl): Replace 'is_friend' with 'hiding'.  Assert no\n\tsurprise hidhing.  Adjust duplicate_decls calls to inform of old\n\tdecl's hiddennes.\n\t(pushdecl): Replace 'is_friend' with 'hiding'.\n\t(set_identifier_type_value_with_scope): Adjust update_binding\n\tcall.\n\t(do_pushdecl_with_scope): Replace 'is_friend' with 'hiding'.\n\t(pushdecl_outermost_localscope): Drop default arg to\n\tdo_pushdecl_with_scope.\n\t(pushdecl_namespace_level): Replace 'is_friend' with 'hiding'.\n\t(pushdecl_top_level): Drop is_friend parm.\n\t* pt.c (register_specialization): Comment duplicate_decls call\n\targs.\n\t(push_template_decl): Commont pushdecl_namespace_level.\n\t(tsubst_friend_function, tsubst_friend_class): Likewise.", "tree": {"sha": "691fb2e16c803bc886f172c5851735a8d05b6b81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/691fb2e16c803bc886f172c5851735a8d05b6b81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c74e6f7cfd7a741fc0477fe3660eec57581b22c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c74e6f7cfd7a741fc0477fe3660eec57581b22c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c74e6f7cfd7a741fc0477fe3660eec57581b22c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c74e6f7cfd7a741fc0477fe3660eec57581b22c5/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00aaae03db249e61dde41facbf373c3fcde38154", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00aaae03db249e61dde41facbf373c3fcde38154", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00aaae03db249e61dde41facbf373c3fcde38154"}], "stats": {"total": 143, "additions": 81, "deletions": 62}, "files": [{"sha": "b7f5b6b399f2c36601a94c385b521a2899c6ee09", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c74e6f7cfd7a741fc0477fe3660eec57581b22c5/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c74e6f7cfd7a741fc0477fe3660eec57581b22c5/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=c74e6f7cfd7a741fc0477fe3660eec57581b22c5", "patch": "@@ -6466,7 +6466,8 @@ extern void determine_local_discriminator\t(tree);\n extern int decls_match\t\t\t\t(tree, tree, bool = true);\n extern bool maybe_version_functions\t\t(tree, tree, bool);\n extern tree duplicate_decls\t\t\t(tree, tree,\n-\t\t\t\t\t\t bool is_friend = false);\n+\t\t\t\t\t\t bool hiding = false,\n+\t\t\t\t\t\t bool was_hidden = false);\n extern tree declare_local_label\t\t\t(tree);\n extern tree define_label\t\t\t(location_t, tree);\n extern void check_goto\t\t\t\t(tree);"}, {"sha": "c00b996294e3f5ae8fc29590bed76a5343733ba6", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 35, "deletions": 27, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c74e6f7cfd7a741fc0477fe3660eec57581b22c5/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c74e6f7cfd7a741fc0477fe3660eec57581b22c5/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=c74e6f7cfd7a741fc0477fe3660eec57581b22c5", "patch": "@@ -1341,17 +1341,16 @@ check_redeclaration_no_default_args (tree decl)\n \n static void\n check_no_redeclaration_friend_default_args (tree olddecl, tree newdecl,\n-\t\t\t\t\t    bool olddecl_hidden_friend_p)\n+\t\t\t\t\t    bool olddecl_hidden_p)\n {\n-  if (!olddecl_hidden_friend_p && !DECL_FRIEND_P (newdecl))\n+  if (!olddecl_hidden_p && !DECL_FRIEND_P (newdecl))\n     return;\n \n-  tree t1 = FUNCTION_FIRST_USER_PARMTYPE (olddecl);\n-  tree t2 = FUNCTION_FIRST_USER_PARMTYPE (newdecl);\n-\n-  for (; t1 && t1 != void_list_node;\n+  for (tree t1 = FUNCTION_FIRST_USER_PARMTYPE (olddecl),\n+\t t2 = FUNCTION_FIRST_USER_PARMTYPE (newdecl);\n+       t1 && t1 != void_list_node;\n        t1 = TREE_CHAIN (t1), t2 = TREE_CHAIN (t2))\n-    if ((olddecl_hidden_friend_p && TREE_PURPOSE (t1))\n+    if ((olddecl_hidden_p && TREE_PURPOSE (t1))\n \t|| (DECL_FRIEND_P (newdecl) && TREE_PURPOSE (t2)))\n       {\n \tauto_diagnostic_group d;\n@@ -1435,10 +1434,14 @@ duplicate_function_template_decls (tree newdecl, tree olddecl)\n    If NEWDECL is not a redeclaration of OLDDECL, NULL_TREE is\n    returned.\n \n-   NEWDECL_IS_FRIEND is true if NEWDECL was declared as a friend.  */\n+   HIDING is true if the new decl is being hidden.  WAS_HIDDEN is true\n+   if the old decl was hidden.\n+\n+   Hidden decls can be anticipated builtins, injected friends, or\n+   (coming soon) injected from a local-extern decl.   */\n \n tree\n-duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n+duplicate_decls (tree newdecl, tree olddecl, bool hiding, bool was_hidden)\n {\n   unsigned olddecl_uid = DECL_UID (olddecl);\n   int olddecl_friend = 0, types_match = 0, hidden_friend = 0;\n@@ -1510,7 +1513,7 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \t{\n \t  /* Avoid warnings redeclaring built-ins which have not been\n \t     explicitly declared.  */\n-\t  if (DECL_ANTICIPATED (olddecl))\n+\t  if (was_hidden)\n \t    {\n \t      tree t1, t2;\n \n@@ -1550,7 +1553,7 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \t\t\t    types_match = decls_match (newdecl, olddecl);\n \t\t\t    if (types_match)\n \t\t\t      return duplicate_decls (newdecl, olddecl,\n-\t\t\t\t\t\t      newdecl_is_friend);\n+\t\t\t\t\t\t      hiding, was_hidden);\n \t\t\t    TYPE_ARG_TYPES (TREE_TYPE (olddecl)) = oldargs;\n \t\t\t  }\n \t\t\tgoto next_arg;\n@@ -1985,7 +1988,7 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \t\t declaration of the function or function template in the\n \t\t translation unit.\"  */\n \t      check_no_redeclaration_friend_default_args\n-\t\t(olddecl, newdecl, DECL_HIDDEN_FRIEND_P (olddecl));\n+\t\t(olddecl, newdecl, was_hidden);\n \t    }\n \t}\n     }\n@@ -2075,8 +2078,8 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \t  && !(new_defines_function && DECL_INITIAL (olddecl) == NULL_TREE)\n \t  /* Don't warn about extern decl followed by definition.  */\n \t  && !(DECL_EXTERNAL (olddecl) && ! DECL_EXTERNAL (newdecl))\n-\t  /* Don't warn about friends, let add_friend take care of it.  */\n-\t  && ! (newdecl_is_friend || DECL_FRIEND_P (olddecl))\n+\t  /* Don't warn if at least one is/was hidden.  */\n+\t  && !(hiding || was_hidden)\n \t  /* Don't warn about declaration followed by specialization.  */\n \t  && (! DECL_TEMPLATE_SPECIALIZATION (newdecl)\n \t      || DECL_TEMPLATE_SPECIALIZATION (olddecl)))\n@@ -2134,11 +2137,9 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \n   if (DECL_DECLARES_FUNCTION_P (olddecl))\n     {\n-      olddecl_friend = DECL_FRIEND_P (olddecl);\n-      olddecl_hidden_friend = DECL_HIDDEN_FRIEND_P (olddecl);\n-      hidden_friend = (DECL_ANTICIPATED (olddecl)\n-\t\t       && DECL_HIDDEN_FRIEND_P (olddecl)\n-\t\t       && newdecl_is_friend);\n+      olddecl_friend = DECL_FRIEND_P (STRIP_TEMPLATE (olddecl));\n+      olddecl_hidden_friend = olddecl_friend && was_hidden;\n+      hidden_friend = olddecl_hidden_friend && hiding;\n       if (!hidden_friend)\n \t{\n \t  DECL_ANTICIPATED (olddecl) = 0;\n@@ -4714,16 +4715,23 @@ cxx_builtin_function (tree decl)\n \n   tree id = DECL_NAME (decl);\n   const char *name = IDENTIFIER_POINTER (id);\n+  bool hiding = false;\n   if (name[0] != '_' || name[1] != '_')\n-    /* In the user's namespace, it must be declared before use.  */\n-    DECL_ANTICIPATED (decl) = 1;\n+    {\n+      /* In the user's namespace, it must be declared before use.  */\n+      DECL_ANTICIPATED (decl) = 1;\n+      hiding = true;\n+    }\n   else if (IDENTIFIER_LENGTH (id) > strlen (\"___chk\")\n \t   && 0 != strncmp (name + 2, \"builtin_\", strlen (\"builtin_\"))\n \t   && 0 == memcmp (name + IDENTIFIER_LENGTH (id) - strlen (\"_chk\"),\n \t\t\t   \"_chk\", strlen (\"_chk\") + 1))\n-    /* Treat __*_chk fortification functions as anticipated as well,\n-       unless they are __builtin_*_chk.  */\n-    DECL_ANTICIPATED (decl) = 1;\n+    {\n+      /* Treat __*_chk fortification functions as anticipated as well,\n+\t unless they are __builtin_*_chk.  */\n+      DECL_ANTICIPATED (decl) = 1;\n+      hiding = true;\n+    }\n \n   /* All builtins that don't begin with an '_' should additionally\n      go in the 'std' namespace.  */\n@@ -4733,12 +4741,12 @@ cxx_builtin_function (tree decl)\n \n       push_nested_namespace (std_node);\n       DECL_CONTEXT (std_decl) = FROB_CONTEXT (std_node);\n-      pushdecl (std_decl);\n+      pushdecl (std_decl, hiding);\n       pop_nested_namespace (std_node);\n     }\n \n   DECL_CONTEXT (decl) = FROB_CONTEXT (current_namespace);\n-  decl = pushdecl (decl);\n+  decl = pushdecl (decl, hiding);\n \n   return decl;\n }\n@@ -9925,7 +9933,7 @@ grokfndecl (tree ctype,\n \t  /* Attempt to merge the declarations.  This can fail, in\n \t     the case of some invalid specialization declarations.  */\n \t  pushed_scope = push_scope (ctype);\n-\t  ok = duplicate_decls (decl, old_decl, friendp);\n+\t  ok = duplicate_decls (decl, old_decl);\n \t  if (pushed_scope)\n \t    pop_scope (pushed_scope);\n \t  if (!ok)"}, {"sha": "6a783a9d88ab4fbf1e9ae5473cd616524cb4efc3", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c74e6f7cfd7a741fc0477fe3660eec57581b22c5/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c74e6f7cfd7a741fc0477fe3660eec57581b22c5/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=c74e6f7cfd7a741fc0477fe3660eec57581b22c5", "patch": "@@ -598,8 +598,8 @@ do_friend (tree ctype, tree declarator, tree decl,\n       if (! DECL_USE_TEMPLATE (decl))\n \t{\n \t  /* We must check whether the decl refers to template\n-\t     arguments before push_template_decl_real adds a\n-\t     reference to the containing template class.  */\n+\t     arguments before push_template_decl adds a reference to\n+\t     the containing template class.  */\n \t  int warn = (warn_nontemplate_friend\n \t\t      && ! funcdef_flag && ! is_friend_template\n \t\t      && current_template_parms\n@@ -614,7 +614,7 @@ do_friend (tree ctype, tree declarator, tree decl,\n \t    decl = push_template_decl (decl, /*is_friend=*/true);\n \t  else if (current_function_decl)\n \t    /* pushdecl will check there's a local decl already.  */\n-\t    decl = pushdecl (decl, /*is_friend=*/true);\n+\t    decl = pushdecl (decl, /*hiding=*/true);\n \t  else\n \t    {\n \t      /* We can't use pushdecl, as we might be in a template\n@@ -624,7 +624,7 @@ do_friend (tree ctype, tree declarator, tree decl,\n \t      tree ns = decl_namespace_context (decl);\n \n \t      push_nested_namespace (ns);\n-\t      decl = pushdecl_namespace_level (decl, /*is_friend=*/true);\n+\t      decl = pushdecl_namespace_level (decl, /*hiding=*/true);\n \t      pop_nested_namespace (ns);\n \t    }\n "}, {"sha": "184e9c873e76ddc001aedfbeb555455c0af0bcb4", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 31, "deletions": 21, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c74e6f7cfd7a741fc0477fe3660eec57581b22c5/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c74e6f7cfd7a741fc0477fe3660eec57581b22c5/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=c74e6f7cfd7a741fc0477fe3660eec57581b22c5", "patch": "@@ -2232,7 +2232,7 @@ supplement_binding_1 (cxx_binding *binding, tree decl)\n \t   && DECL_EXTERNAL (target_decl) && DECL_EXTERNAL (target_bval)\n \t   && !DECL_CLASS_SCOPE_P (target_decl))\n     {\n-      duplicate_decls (decl, binding->value, /*newdecl_is_friend=*/false);\n+      duplicate_decls (decl, binding->value);\n       ok = false;\n     }\n   else if (TREE_CODE (decl) == NAMESPACE_DECL\n@@ -2354,7 +2354,7 @@ matching_fn_p (tree one, tree two)\n \n static tree\n update_binding (cp_binding_level *level, cxx_binding *binding, tree *slot,\n-\t\ttree old, tree decl, bool is_friend)\n+\t\ttree old, tree decl, bool hiding = false)\n {\n   tree to_val = decl;\n   tree old_type = slot ? MAYBE_STAT_TYPE (*slot) : binding->type;\n@@ -2410,13 +2410,14 @@ update_binding (cp_binding_level *level, cxx_binding *binding, tree *slot,\n \n \t      if (iter.using_p () && matching_fn_p (fn, decl))\n \t\t{\n+\t\t  gcc_checking_assert (!iter.hidden_p ());\n \t\t  /* If a function declaration in namespace scope or\n \t\t     block scope has the same name and the same\n \t\t     parameter-type- list (8.3.5) as a function\n \t\t     introduced by a using-declaration, and the\n \t\t     declarations do not declare the same function,\n \t\t     the program is ill-formed.  [namespace.udecl]/14 */\n-\t\t  if (tree match = duplicate_decls (decl, fn, is_friend))\n+\t\t  if (tree match = duplicate_decls (decl, fn, hiding))\n \t\t    return match;\n \t\t  else\n \t\t    /* FIXME: To preserve existing error behavior, we\n@@ -2468,7 +2469,7 @@ update_binding (cp_binding_level *level, cxx_binding *binding, tree *slot,\n \t variable, so long as they are `extern' declarations.  */\n       if (!DECL_EXTERNAL (old) || !DECL_EXTERNAL (decl))\n \tgoto conflict;\n-      else if (tree match = duplicate_decls (decl, old, false))\n+      else if (tree match = duplicate_decls (decl, old))\n \treturn match;\n       else\n \tgoto conflict;\n@@ -2989,12 +2990,12 @@ set_local_extern_decl_linkage (tree decl, bool shadowed)\n    says.  */\n \n static tree\n-do_pushdecl (tree decl, bool is_friend)\n+do_pushdecl (tree decl, bool hiding)\n {\n   if (decl == error_mark_node)\n     return error_mark_node;\n \n-  if (!DECL_TEMPLATE_PARM_P (decl) && current_function_decl && !is_friend)\n+  if (!DECL_TEMPLATE_PARM_P (decl) && current_function_decl && !hiding)\n     set_decl_context_in_fn (current_function_decl, decl);\n \n   /* The binding level we will be pushing into.  During local class\n@@ -3014,6 +3015,14 @@ do_pushdecl (tree decl, bool is_friend)\n       tree *slot = NULL; /* Binding slot in namespace.  */\n       tree old = NULL_TREE;\n \n+      if (!hiding)\n+\t/* We should never unknownly push an anticipated decl.  */\n+\tgcc_checking_assert (!((TREE_CODE (decl) == TYPE_DECL\n+\t\t\t\t|| TREE_CODE (decl) == FUNCTION_DECL\n+\t\t\t\t|| TREE_CODE (decl) == TEMPLATE_DECL)\n+\t\t\t       && DECL_LANG_SPECIFIC (decl)\n+\t\t\t       && DECL_ANTICIPATED (decl)));\n+\n       if (level->kind == sk_namespace)\n \t{\n \t  /* We look in the decl's namespace for an existing\n@@ -3044,15 +3053,16 @@ do_pushdecl (tree decl, bool is_friend)\n       for (ovl_iterator iter (old); iter; ++iter)\n \tif (iter.using_p ())\n \t  ; /* Ignore using decls here.  */\n-\telse if (tree match = duplicate_decls (decl, *iter, is_friend))\n+\telse if (tree match\n+\t\t = duplicate_decls (decl, *iter, hiding, iter.hidden_p ()))\n \t  {\n \t    if (match == error_mark_node)\n \t      ;\n \t    else if (TREE_CODE (match) == TYPE_DECL)\n \t      /* The IDENTIFIER will have the type referring to the\n \t\t now-smashed TYPE_DECL, because ...?  Reset it.  */\n \t      SET_IDENTIFIER_TYPE_VALUE (name, TREE_TYPE (match));\n-\t    else if (iter.hidden_p () && !DECL_HIDDEN_P (match))\n+\t    else if (iter.hidden_p () && !hiding)\n \t      {\n \t\t/* Unhiding a previously hidden decl.  */\n \t\ttree head = iter.reveal_node (old);\n@@ -3088,7 +3098,7 @@ do_pushdecl (tree decl, bool is_friend)\n \t{\n \t  check_default_args (decl);\n \n-\t  if (is_friend)\n+\t  if (hiding)\n \t    {\n \t      if (level->kind != sk_namespace)\n \t\t{\n@@ -3126,7 +3136,7 @@ do_pushdecl (tree decl, bool is_friend)\n \t  old = MAYBE_STAT_DECL (*slot);\n \t}\n \n-      old = update_binding (level, binding, slot, old, decl, is_friend);\n+      old = update_binding (level, binding, slot, old, decl, hiding);\n \n       if (old != decl)\n \t/* An existing decl matched, use it.  */\n@@ -3170,10 +3180,10 @@ do_pushdecl (tree decl, bool is_friend)\n    we push it.  */\n \n tree\n-pushdecl (tree x, bool is_friend)\n+pushdecl (tree x, bool hiding)\n {\n   bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n-  tree ret = do_pushdecl (x, is_friend);\n+  tree ret = do_pushdecl (x, hiding);\n   timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n   return ret;\n }\n@@ -3780,7 +3790,7 @@ set_identifier_type_value_with_scope (tree id, tree decl, cp_binding_level *b)\n     {\n       tree *slot = find_namespace_slot (current_namespace, id, true);\n       gcc_assert (decl);\n-      update_binding (b, NULL, slot, MAYBE_STAT_DECL (*slot), decl, false);\n+      update_binding (b, NULL, slot, MAYBE_STAT_DECL (*slot), decl);\n \n       /* Store marker instead of real type.  */\n       type = global_type_node;\n@@ -3836,12 +3846,13 @@ constructor_name_p (tree name, tree type)\n    closer binding level than LEVEL.  */\n \n static tree\n-do_pushdecl_with_scope (tree x, cp_binding_level *level, bool is_friend)\n+do_pushdecl_with_scope (tree x, cp_binding_level *level, bool hiding = false)\n {\n   cp_binding_level *b;\n \n   if (level->kind == sk_class)\n     {\n+      gcc_checking_assert (!hiding);\n       b = class_binding_level;\n       class_binding_level = level;\n       pushdecl_class_level (x);\n@@ -3854,7 +3865,7 @@ do_pushdecl_with_scope (tree x, cp_binding_level *level, bool is_friend)\n \tcurrent_function_decl = NULL_TREE;\n       b = current_binding_level;\n       current_binding_level = level;\n-      x = pushdecl (x, is_friend);\n+      x = pushdecl (x, hiding);\n       current_binding_level = b;\n       current_function_decl = function_decl;\n     }\n@@ -3874,7 +3885,7 @@ pushdecl_outermost_localscope (tree x)\n        n->kind != sk_function_parms; n = b->level_chain)\n     b = n;\n \n-  tree ret = b ? do_pushdecl_with_scope (x, b, false) : error_mark_node;\n+  tree ret = b ? do_pushdecl_with_scope (x, b) : error_mark_node;\n   timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n \n   return ret;\n@@ -5072,14 +5083,13 @@ do_namespace_alias (tree alias, tree name_space)\n    if appropriate.  */\n \n tree\n-pushdecl_namespace_level (tree x, bool is_friend)\n+pushdecl_namespace_level (tree x, bool hiding)\n {\n   cp_binding_level *b = current_binding_level;\n   tree t;\n \n   bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n-  t = do_pushdecl_with_scope\n-    (x, NAMESPACE_LEVEL (current_namespace), is_friend);\n+  t = do_pushdecl_with_scope (x, NAMESPACE_LEVEL (current_namespace), hiding);\n \n   /* Now, the type_shadowed stack may screw us.  Munge it so it does\n      what we want.  */\n@@ -7282,11 +7292,11 @@ finish_using_directive (tree target, tree attribs)\n /* Pushes X into the global namespace.  */\n \n tree\n-pushdecl_top_level (tree x, bool is_friend)\n+pushdecl_top_level (tree x)\n {\n   bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n   do_push_to_top_level ();\n-  x = pushdecl_namespace_level (x, is_friend);\n+  x = pushdecl_namespace_level (x);\n   do_pop_from_top_level ();\n   timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n   return x;"}, {"sha": "7b463386725a2632cfb1d94d163320ea32e8ccbd", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c74e6f7cfd7a741fc0477fe3660eec57581b22c5/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c74e6f7cfd7a741fc0477fe3660eec57581b22c5/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=c74e6f7cfd7a741fc0477fe3660eec57581b22c5", "patch": "@@ -337,7 +337,7 @@ extern tree lookup_qualified_name (tree scope, const char *name,\n \t\t\t\t   bool = true);\n extern bool is_local_extern (tree);\n extern bool pushdecl_class_level (tree);\n-extern tree pushdecl_namespace_level (tree, bool is_friend = false);\n+extern tree pushdecl_namespace_level (tree, bool hiding = false);\n extern bool push_class_level_binding (tree, tree);\n extern tree get_local_decls ();\n extern int function_parm_depth (void);\n@@ -363,9 +363,9 @@ extern void cp_emit_debug_info_for_using (tree, tree);\n \n extern void finish_nonmember_using_decl (tree scope, tree name);\n extern void finish_using_directive (tree target, tree attribs);\n-extern tree pushdecl (tree, bool is_friend = false);\n+extern tree pushdecl (tree, bool hiding = false);\n extern tree pushdecl_outermost_localscope (tree);\n-extern tree pushdecl_top_level (tree, bool is_friend = false);\n+extern tree pushdecl_top_level (tree);\n extern tree pushdecl_top_level_and_finish (tree, tree);\n extern tree pushtag (tree, tree, TAG_how = TAG_how::CURRENT_ONLY);\n extern int push_namespace (tree, bool make_inline = false);"}, {"sha": "199fe658f715e61d1fa647dfea90be568bfd9009", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c74e6f7cfd7a741fc0477fe3660eec57581b22c5/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c74e6f7cfd7a741fc0477fe3660eec57581b22c5/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=c74e6f7cfd7a741fc0477fe3660eec57581b22c5", "patch": "@@ -1635,7 +1635,7 @@ register_specialization (tree spec, tree tmpl, tree args, bool is_friend,\n \t\t for the specialization, we want this to look as if\n \t\t there were no definition, and vice versa.  */\n \t      DECL_INITIAL (fn) = NULL_TREE;\n-\t      duplicate_decls (spec, fn, is_friend);\n+\t      duplicate_decls (spec, fn, /*hiding=*/is_friend);\n \t      /* The call to duplicate_decls will have applied\n \t\t [temp.expl.spec]:\n \n@@ -1662,7 +1662,7 @@ register_specialization (tree spec, tree tmpl, tree args, bool is_friend,\n \t}\n       else if (DECL_TEMPLATE_SPECIALIZATION (fn))\n \t{\n-\t  tree dd = duplicate_decls (spec, fn, is_friend);\n+\t  tree dd = duplicate_decls (spec, fn, /*hiding=*/is_friend);\n \t  if (dd == error_mark_node)\n \t    /* We've already complained in duplicate_decls.  */\n \t    return error_mark_node;\n@@ -1677,7 +1677,7 @@ register_specialization (tree spec, tree tmpl, tree args, bool is_friend,\n \t}\n     }\n   else if (fn)\n-    return duplicate_decls (spec, fn, is_friend);\n+    return duplicate_decls (spec, fn, /*hiding=*/is_friend);\n \n   /* A specialization must be declared in the same namespace as the\n      template it is specializing.  */\n@@ -6018,7 +6018,7 @@ push_template_decl (tree decl, bool is_friend)\n       if (!ctx\n \t  && !(is_friend && template_class_depth (current_class_type) > 0))\n \t{\n-\t  tmpl = pushdecl_namespace_level (tmpl, is_friend);\n+\t  tmpl = pushdecl_namespace_level (tmpl, /*hiding=*/is_friend);\n \t  if (tmpl == error_mark_node)\n \t    return error_mark_node;\n \n@@ -11078,7 +11078,7 @@ tsubst_friend_function (tree decl, tree args)\n \t into the namespace of the template.  */\n       ns = decl_namespace_context (new_friend);\n       push_nested_namespace (ns);\n-      old_decl = pushdecl_namespace_level (new_friend, /*is_friend=*/true);\n+      old_decl = pushdecl_namespace_level (new_friend, /*hiding=*/true);\n       pop_nested_namespace (ns);\n \n       if (old_decl == error_mark_node)\n@@ -11323,7 +11323,7 @@ tsubst_friend_class (tree friend_tmpl, tree args)\n \t    }\n \n \t  /* Inject this template into the enclosing namspace scope.  */\n-\t  tmpl = pushdecl_namespace_level (tmpl, true);\n+\t  tmpl = pushdecl_namespace_level (tmpl, /*hiding=*/true);\n \t}\n     }\n "}]}