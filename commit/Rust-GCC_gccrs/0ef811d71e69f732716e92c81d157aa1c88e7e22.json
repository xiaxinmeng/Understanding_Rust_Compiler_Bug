{"sha": "0ef811d71e69f732716e92c81d157aa1c88e7e22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGVmODExZDcxZTY5ZjczMjcxNmU5MmM4MWQxNTdhYTFjODhlN2UyMg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2013-03-08T16:03:48Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2013-03-08T16:03:48Z"}, "message": "re PR c++/51494 (Legal program rejection - capturing \"this\" when using static method inside lambda)\n\n\tPR c++/51494\n\tPR c++/51884\n\tPR c++/56222\n\t* tree.c (maybe_dummy_object): Don't capture 'this'.\n\t* semantics.c (maybe_resolve_dummy): New.\n\t(finish_non_static_data_member): Use it.\n\t(finish_qualified_id_expr): Don't test is_dummy_object.\n\t* cp-tree.h: Declare maybe_resolve_dummy.\n\t* call.c (build_new_method_call_1): Use it.\n\nFrom-SVN: r196549", "tree": {"sha": "625454b1e858550bbc542f3e02625cff0632d3a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/625454b1e858550bbc542f3e02625cff0632d3a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ef811d71e69f732716e92c81d157aa1c88e7e22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ef811d71e69f732716e92c81d157aa1c88e7e22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ef811d71e69f732716e92c81d157aa1c88e7e22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ef811d71e69f732716e92c81d157aa1c88e7e22/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e48243d8403c76cd248a97c94d138936d856d543", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e48243d8403c76cd248a97c94d138936d856d543", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e48243d8403c76cd248a97c94d138936d856d543"}], "stats": {"total": 103, "additions": 86, "deletions": 17}, "files": [{"sha": "f9731a5538e234ce79d8103126a9e34f0e2f0dc3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ef811d71e69f732716e92c81d157aa1c88e7e22/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ef811d71e69f732716e92c81d157aa1c88e7e22/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0ef811d71e69f732716e92c81d157aa1c88e7e22", "patch": "@@ -1,5 +1,15 @@\n 2013-03-08  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/51494\n+\tPR c++/51884\n+\tPR c++/56222\n+\t* tree.c (maybe_dummy_object): Don't capture 'this'.\n+\t* semantics.c (maybe_resolve_dummy): New.\n+\t(finish_non_static_data_member): Use it.\n+\t(finish_qualified_id_expr): Don't test is_dummy_object.\n+\t* cp-tree.h: Declare maybe_resolve_dummy.\n+\t* call.c (build_new_method_call_1): Use it.\n+\n \tPR c++/56567\n \t* semantics.c (apply_deduced_return_type): Don't allow returning\n \tstd::initializer_list."}, {"sha": "530835b87c83823939087849eccbdbd8a877bdd3", "filename": "gcc/cp/call.c", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ef811d71e69f732716e92c81d157aa1c88e7e22/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ef811d71e69f732716e92c81d157aa1c88e7e22/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=0ef811d71e69f732716e92c81d157aa1c88e7e22", "patch": "@@ -7627,6 +7627,7 @@ build_new_method_call_1 (tree instance, tree fns, vec<tree, va_gc> **args,\n       else\n \t{\n \t  fn = cand->fn;\n+\t  call = NULL_TREE;\n \n \t  if (!(flags & LOOKUP_NONVIRTUAL)\n \t      && DECL_PURE_VIRTUAL_P (fn)\n@@ -7644,12 +7645,26 @@ build_new_method_call_1 (tree instance, tree fns, vec<tree, va_gc> **args,\n \t  if (TREE_CODE (TREE_TYPE (fn)) == METHOD_TYPE\n \t      && is_dummy_object (instance_ptr))\n \t    {\n-\t      if (complain & tf_error)\n-\t\terror (\"cannot call member function %qD without object\",\n-\t\t       fn);\n-\t      call = error_mark_node;\n+\t      instance = maybe_resolve_dummy (instance);\n+\t      if (instance == error_mark_node)\n+\t\tcall = error_mark_node;\n+\t      else if (!is_dummy_object (instance))\n+\t\t{\n+\t\t  /* We captured 'this' in the current lambda now that\n+\t\t     we know we really need it.  */\n+\t\t  instance_ptr = build_this (instance);\n+\t\t  cand->first_arg = instance_ptr;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (complain & tf_error)\n+\t\t    error (\"cannot call member function %qD without object\",\n+\t\t\t   fn);\n+\t\t  call = error_mark_node;\n+\t\t}\n \t    }\n-\t  else\n+\n+\t  if (call != error_mark_node)\n \t    {\n \t      /* Optimize away vtable lookup if we know that this\n \t\t function can't be overridden.  We need to check if"}, {"sha": "c3b2aecf3b1cd1eb8b8948436a954e5dffc4a304", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ef811d71e69f732716e92c81d157aa1c88e7e22/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ef811d71e69f732716e92c81d157aa1c88e7e22/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=0ef811d71e69f732716e92c81d157aa1c88e7e22", "patch": "@@ -5722,6 +5722,7 @@ extern bool is_capture_proxy\t\t\t(tree);\n extern bool is_normal_capture_proxy             (tree);\n extern void register_capture_members\t\t(tree);\n extern tree lambda_expr_this_capture            (tree);\n+extern tree maybe_resolve_dummy\t\t\t(tree);\n extern tree nonlambda_method_basetype\t\t(void);\n extern void maybe_add_lambda_conv_op            (tree);\n extern bool is_lambda_ignored_entity            (tree);"}, {"sha": "d11a4e4b2180c539588ec8cb5b97c4bec84e7c31", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ef811d71e69f732716e92c81d157aa1c88e7e22/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ef811d71e69f732716e92c81d157aa1c88e7e22/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=0ef811d71e69f732716e92c81d157aa1c88e7e22", "patch": "@@ -1544,6 +1544,7 @@ finish_non_static_data_member (tree decl, tree object, tree qualifying_scope)\n       object = maybe_dummy_object (scope, NULL);\n     }\n \n+  object = maybe_resolve_dummy (object);\n   if (object == error_mark_node)\n     return error_mark_node;\n \n@@ -1778,15 +1779,14 @@ finish_qualified_id_expr (tree qualifying_class,\n     }\n   else if (BASELINK_P (expr) && !processing_template_decl)\n     {\n-      tree ob;\n-\n       /* See if any of the functions are non-static members.  */\n       /* If so, the expression may be relative to 'this'.  */\n       if (!shared_member_p (expr)\n-\t  && (ob = maybe_dummy_object (qualifying_class, NULL),\n-\t      !is_dummy_object (ob)))\n+\t  && current_class_ptr\n+\t  && DERIVED_FROM_P (qualifying_class,\n+\t\t\t     current_nonlambda_class_type ()))\n \texpr = (build_class_member_access_expr\n-\t\t(ob,\n+\t\t(maybe_dummy_object (qualifying_class, NULL),\n \t\t expr,\n \t\t BASELINK_ACCESS_BINFO (expr),\n \t\t /*preserve_reference=*/false,\n@@ -9534,6 +9534,34 @@ lambda_expr_this_capture (tree lambda)\n   return result;\n }\n \n+/* We don't want to capture 'this' until we know we need it, i.e. after\n+   overload resolution has chosen a non-static member function.  At that\n+   point we call this function to turn a dummy object into a use of the\n+   'this' capture.  */\n+\n+tree\n+maybe_resolve_dummy (tree object)\n+{\n+  if (!is_dummy_object (object))\n+    return object;\n+\n+  tree type = TYPE_MAIN_VARIANT (TREE_TYPE (object));\n+  gcc_assert (TREE_CODE (type) != POINTER_TYPE);\n+\n+  if (type != current_class_type\n+      && current_class_type\n+      && LAMBDA_TYPE_P (current_class_type))\n+    {\n+      /* In a lambda, need to go through 'this' capture.  */\n+      tree lam = CLASSTYPE_LAMBDA_EXPR (current_class_type);\n+      tree cap = lambda_expr_this_capture (lam);\n+      object = build_x_indirect_ref (EXPR_LOCATION (object), cap,\n+\t\t\t\t     RO_NULL, tf_warning_or_error);\n+    }\n+\n+  return object;\n+}\n+\n /* Returns the method basetype of the innermost non-lambda function, or\n    NULL_TREE if none.  */\n "}, {"sha": "178b80aa24fdabed8b47c79ebf0867ad5b6a5413", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ef811d71e69f732716e92c81d157aa1c88e7e22/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ef811d71e69f732716e92c81d157aa1c88e7e22/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=0ef811d71e69f732716e92c81d157aa1c88e7e22", "patch": "@@ -2863,13 +2863,6 @@ maybe_dummy_object (tree type, tree* binfop)\n       && (same_type_ignoring_top_level_qualifiers_p\n \t  (TREE_TYPE (current_class_ref), context)))\n     decl = current_class_ref;\n-  else if (current != current_class_type\n-\t   && context == nonlambda_method_basetype ())\n-    /* In a lambda, need to go through 'this' capture.  */\n-    decl = (build_x_indirect_ref\n-\t    (input_location, (lambda_expr_this_capture\n-\t\t\t      (CLASSTYPE_LAMBDA_EXPR (current_class_type))),\n-\t     RO_NULL, tf_warning_or_error));\n   else\n     decl = build_dummy_object (context);\n "}, {"sha": "2618295662e6ab1e271a1f7fccc50218e605f41d", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-this11.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ef811d71e69f732716e92c81d157aa1c88e7e22/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-this11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ef811d71e69f732716e92c81d157aa1c88e7e22/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-this11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-this11.C?ref=0ef811d71e69f732716e92c81d157aa1c88e7e22", "patch": "@@ -0,0 +1,22 @@\n+// PR c++/51494, c++/56222\n+// Uses of static members and creating pointers to members aren't odr-uses\n+// of 'this'.\n+// { dg-do compile { target c++11 } }\n+\n+struct A\n+{\n+  static void f() {}\n+  static int i;\n+  int j;\n+  void f(int);\n+\n+  void foo()\n+  {\n+    [] () {\n+      ++i;\n+      f();\n+      &A::j;\n+      (void(*)())&A::f;\n+    };\n+  }\n+};"}]}