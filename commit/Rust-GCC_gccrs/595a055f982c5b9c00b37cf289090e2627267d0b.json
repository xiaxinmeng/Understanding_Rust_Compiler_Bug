{"sha": "595a055f982c5b9c00b37cf289090e2627267d0b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTk1YTA1NWY5ODJjNWI5YzAwYjM3Y2YyODkwOTBlMjYyNzI2N2QwYg==", "commit": {"author": {"name": "Matthew Heaney", "email": "heaney@adacore.com", "date": "2011-11-23T13:36:40Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-11-23T13:36:40Z"}, "message": "a-cdlili.adb, [...] (Iterator): Declared Iterator type as limited (First...\n\n2011-11-23  Matthew Heaney  <heaney@adacore.com>\n\n\t* a-cdlili.adb, a-cidlli.adb, a-cbdlli.adb (Iterator): Declared\n\tIterator type as limited (First, Last): Cursor return value\n\tdepends on iterator node value (Iterate): Use start position as\n\titerator node value (Next, Previous): Forward to corresponding\n\tcursor-based operation.\n\nFrom-SVN: r181667", "tree": {"sha": "cabd095bacd1f3177494ed7f99f6fd72076c5543", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cabd095bacd1f3177494ed7f99f6fd72076c5543"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/595a055f982c5b9c00b37cf289090e2627267d0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/595a055f982c5b9c00b37cf289090e2627267d0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/595a055f982c5b9c00b37cf289090e2627267d0b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/595a055f982c5b9c00b37cf289090e2627267d0b/comments", "author": null, "committer": null, "parents": [{"sha": "b38c20a636ec4e92cdabecbfa487b742829ebe93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b38c20a636ec4e92cdabecbfa487b742829ebe93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b38c20a636ec4e92cdabecbfa487b742829ebe93"}], "stats": {"total": 362, "additions": 293, "deletions": 69}, "files": [{"sha": "b462d0a14f1dd044638a6f300bb5b1a4d286a4bc", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/595a055f982c5b9c00b37cf289090e2627267d0b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/595a055f982c5b9c00b37cf289090e2627267d0b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=595a055f982c5b9c00b37cf289090e2627267d0b", "patch": "@@ -1,3 +1,11 @@\n+2011-11-23  Matthew Heaney  <heaney@adacore.com>\n+\n+\t* a-cdlili.adb, a-cidlli.adb, a-cbdlli.adb (Iterator): Declared\n+\tIterator type as limited (First, Last): Cursor return value\n+\tdepends on iterator node value (Iterate): Use start position as\n+\titerator node value (Next, Previous): Forward to corresponding\n+\tcursor-based operation.\n+\n 2011-11-23  Matthew Heaney  <heaney@adacore.com>\n \n \t* a-coorse.ads, a-ciorse.ads, a-cborse.ads (Set_Iterator_Interfaces):"}, {"sha": "85ead8aef0cf75b86e48c2fcbd91d2552eb7eaf3", "filename": "gcc/ada/a-cbdlli.adb", "status": "modified", "additions": 95, "deletions": 25, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/595a055f982c5b9c00b37cf289090e2627267d0b/gcc%2Fada%2Fa-cbdlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/595a055f982c5b9c00b37cf289090e2627267d0b/gcc%2Fada%2Fa-cbdlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbdlli.adb?ref=595a055f982c5b9c00b37cf289090e2627267d0b", "patch": "@@ -30,7 +30,8 @@\n with System;  use type System.Address;\n \n package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n-   type Iterator is new\n+\n+   type Iterator is limited new\n      List_Iterator_Interfaces.Reversible_Iterator with record\n         Container : List_Access;\n         Node      : Count_Type;\n@@ -544,10 +545,23 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n \n    function First (Object : Iterator) return Cursor is\n    begin\n-      if Object.Container = null then\n-         return No_Element;\n+      --  The value of the iterator object's Node component influences the\n+      --  behavior of the First (and Last) selector function.\n+\n+      --  When the Node component is 0, this means the iterator object was\n+      --  constructed without a start expression, in which case the (forward)\n+      --  iteration starts from the (logical) beginning of the entire sequence\n+      --  of items (corresponding to Container.First, for a forward iterator).\n+\n+      --  Otherwise, this is iteration over a partial sequence of items. When\n+      --  the Node component is positive, the iterator object was constructed\n+      --  with a start expression, that specifies the position from which the\n+      --  (forward) partial iteration begins.\n+\n+      if Object.Node = 0 then\n+         return Bounded_Doubly_Linked_Lists.First (Object.Container.all);\n       else\n-         return (Object.Container, Object.Container.First);\n+         return Cursor'(Object.Container, Object.Node);\n       end if;\n    end First;\n \n@@ -1075,24 +1089,61 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n \n    function Iterate\n      (Container : List)\n-      return List_Iterator_Interfaces.Reversible_Iterator'class\n+      return List_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n    begin\n-      if Container.Length = 0 then\n-         return Iterator'(null, Count_Type'First);\n-      else\n-         return Iterator'(Container'Unrestricted_Access, Container.First);\n-      end if;\n+      --  The value of the Node component influences the behavior of the First\n+      --  and Last selector functions of the iterator object. When the Node\n+      --  component is 0 (as is the case here), this means the iterator\n+      --  object was constructed without a start expression. This is a\n+      --  complete iterator, meaning that the iteration starts from the\n+      --  (logical) beginning of the sequence of items.\n+\n+      --  Note: For a forward iterator, Container.First is the beginning, and\n+      --  for a reverse iterator, Container.Last is the beginning.\n+\n+      return Iterator'(Container'Unrestricted_Access, Node => 0);\n    end Iterate;\n \n    function Iterate\n      (Container : List;\n       Start     : Cursor)\n       return List_Iterator_Interfaces.Reversible_Iterator'class\n    is\n-      It : constant Iterator := (Container'Unrestricted_Access, Start.Node);\n    begin\n-      return It;\n+      --  It was formerly the case that when Start = No_Element, the partial\n+      --  iterator was defined to behave the same as for a complete iterator,\n+      --  and iterate over the entire sequence of items. However, those\n+      --  semantics were unintuitive and arguably error-prone (it is too easy\n+      --  to accidentally create an endless loop), and so they were changed,\n+      --  per the ARG meeting in Denver on 2011/11. However, there was no\n+      --  consensus about what positive meaning this corner case should have,\n+      --  and so it was decided to simply raise an exception. This does imply,\n+      --  however, that it is not possible to use a partial iterator to specify\n+      --  an empty sequence of items.\n+\n+      if Start = No_Element then\n+         raise Constraint_Error with\n+           \"Start position for iterator equals No_Element\";\n+      end if;\n+\n+      if Start.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Start cursor of Iterate designates wrong list\";\n+      end if;\n+\n+      pragma Assert (Vet (Start), \"Start cursor of Iterate is bad\");\n+\n+      --  The value of the Node component influences the behavior of the First\n+      --  and Last selector functions of the iterator object. When the Node\n+      --  component is positive (as is the case here), it means that this\n+      --  is a partial iteration, over a subset of the complete sequence of\n+      --  items. The iterator object was constructed with a start expression,\n+      --  indicating the position from which the iteration begins. Note that\n+      --  the start position has the same value irrespective of whether this\n+      --  is a forward or reverse iteration.\n+\n+      return Iterator'(Container'Unrestricted_Access, Node => Start.Node);\n    end Iterate;\n \n    ----------\n@@ -1110,10 +1161,23 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n \n    function Last (Object : Iterator) return Cursor is\n    begin\n-      if Object.Container = null then\n-         return No_Element;\n+      --  The value of the iterator object's Node component influences the\n+      --  behavior of the Last (and First) selector function.\n+\n+      --  When the Node component is 0, this means the iterator object was\n+      --  constructed without a start expression, in which case the (reverse)\n+      --  iteration starts from the (logical) beginning of the entire sequence\n+      --  (corresponding to Container.Last, for a reverse iterator).\n+\n+      --  Otherwise, this is iteration over a partial sequence of items. When\n+      --  the Node component is positive, the iterator object was constructed\n+      --  with a start expression, that specifies the position from which the\n+      --  (reverse) partial iteration begins.\n+\n+      if Object.Node = 0 then\n+         return Bounded_Doubly_Linked_Lists.Last (Object.Container.all);\n       else\n-         return (Object.Container, Object.Container.Last);\n+         return Cursor'(Object.Container, Object.Node);\n       end if;\n    end Last;\n \n@@ -1260,14 +1324,17 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n      (Object   : Iterator;\n       Position : Cursor) return Cursor\n    is\n-      Nodes : Node_Array renames Position.Container.Nodes;\n-      Node  : constant Count_Type := Nodes (Position.Node).Next;\n    begin\n-      if Position.Node = Object.Container.Last then\n+      if Position.Container = null then\n          return No_Element;\n-      else\n-         return (Object.Container, Node);\n       end if;\n+\n+      if Position.Container /= Object.Container then\n+         raise Program_Error with\n+           \"Position cursor of Next designates wrong list\";\n+      end if;\n+\n+      return Next (Position);\n    end Next;\n \n    -------------\n@@ -1316,14 +1383,17 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n      (Object   : Iterator;\n       Position : Cursor) return Cursor\n    is\n-      Nodes : Node_Array renames Position.Container.Nodes;\n-      Node  : constant Count_Type := Nodes (Position.Node).Prev;\n    begin\n-      if Position.Node = 0 then\n+      if Position.Container = null then\n          return No_Element;\n-      else\n-         return (Object.Container, Node);\n       end if;\n+\n+      if Position.Container /= Object.Container then\n+         raise Program_Error with\n+           \"Position cursor of Previous designates wrong list\";\n+      end if;\n+\n+      return Previous (Position);\n    end Previous;\n \n    -------------------"}, {"sha": "63cae28aefeb8953ea383e5165b2e7bf295e9ec7", "filename": "gcc/ada/a-cdlili.adb", "status": "modified", "additions": 96, "deletions": 22, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/595a055f982c5b9c00b37cf289090e2627267d0b/gcc%2Fada%2Fa-cdlili.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/595a055f982c5b9c00b37cf289090e2627267d0b/gcc%2Fada%2Fa-cdlili.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cdlili.adb?ref=595a055f982c5b9c00b37cf289090e2627267d0b", "patch": "@@ -32,7 +32,8 @@ with System;  use type System.Address;\n with Ada.Unchecked_Deallocation;\n \n package body Ada.Containers.Doubly_Linked_Lists is\n-   type Iterator is new\n+\n+   type Iterator is limited new\n      List_Iterator_Interfaces.Reversible_Iterator with record\n         Container : List_Access;\n         Node      : Node_Access;\n@@ -445,10 +446,23 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n    function First (Object : Iterator) return Cursor is\n    begin\n-      if Object.Container = null then\n-         return No_Element;\n+      --  The value of the iterator object's Node component influences the\n+      --  behavior of the First (and Last) selector function.\n+\n+      --  When the Node component is null, this means the iterator object was\n+      --  constructed without a start expression, in which case the (forward)\n+      --  iteration starts from the (logical) beginning of the entire sequence\n+      --  of items (corresponding to Container.First, for a forward iterator).\n+\n+      --  Otherwise, this is iteration over a partial sequence of items. When\n+      --  the Node component is non-null, the iterator object was constructed\n+      --  with a start expression, that specifies the position from which the\n+      --  (forward) partial iteration begins.\n+\n+      if Object.Node = null then\n+         return Doubly_Linked_Lists.First (Object.Container.all);\n       else\n-         return (Object.Container, Object.Container.First);\n+         return Cursor'(Object.Container, Object.Node);\n       end if;\n    end First;\n \n@@ -866,22 +880,59 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    end Iterate;\n \n    function Iterate (Container : List)\n-     return List_Iterator_Interfaces.Reversible_Iterator'class\n+     return List_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n    begin\n-      if Container.Length = 0 then\n-         return Iterator'(null, null);\n-      else\n-         return Iterator'(Container'Unchecked_Access, Container.First);\n-      end if;\n+      --  The value of the Node component influences the behavior of the First\n+      --  and Last selector functions of the iterator object. When the Node\n+      --  component is null (as is the case here), this means the iterator\n+      --  object was constructed without a start expression. This is a\n+      --  complete iterator, meaning that the iteration starts from the\n+      --  (logical) beginning of the sequence of items.\n+\n+      --  Note: For a forward iterator, Container.First is the beginning, and\n+      --  for a reverse iterator, Container.Last is the beginning.\n+\n+      return Iterator'(Container'Unrestricted_Access, Node => null);\n    end Iterate;\n \n    function Iterate (Container : List; Start : Cursor)\n-     return List_Iterator_Interfaces.Reversible_Iterator'class\n+     return List_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n-      It : constant Iterator := (Container'Unchecked_Access, Start.Node);\n    begin\n-      return It;\n+      --  It was formerly the case that when Start = No_Element, the partial\n+      --  iterator was defined to behave the same as for a complete iterator,\n+      --  and iterate over the entire sequence of items. However, those\n+      --  semantics were unintuitive and arguably error-prone (it is too easy\n+      --  to accidentally create an endless loop), and so they were changed,\n+      --  per the ARG meeting in Denver on 2011/11. However, there was no\n+      --  consensus about what positive meaning this corner case should have,\n+      --  and so it was decided to simply raise an exception. This does imply,\n+      --  however, that it is not possible to use a partial iterator to specify\n+      --  an empty sequence of items.\n+\n+      if Start = No_Element then\n+         raise Constraint_Error with\n+           \"Start position for iterator equals No_Element\";\n+      end if;\n+\n+      if Start.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Start cursor of Iterate designates wrong list\";\n+      end if;\n+\n+      pragma Assert (Vet (Start), \"Start cursor of Iterate is bad\");\n+\n+      --  The value of the Node component influences the behavior of the First\n+      --  and Last selector functions of the iterator object. When the Node\n+      --  component is non-null (as is the case here), it means that this\n+      --  is a partial iteration, over a subset of the complete sequence of\n+      --  items. The iterator object was constructed with a start expression,\n+      --  indicating the position from which the iteration begins. Note that\n+      --  the start position has the same value irrespective of whether this\n+      --  is a forward or reverse iteration.\n+\n+      return Iterator'(Container'Unrestricted_Access, Node => Start.Node);\n    end Iterate;\n \n    ----------\n@@ -899,10 +950,23 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n    function Last (Object : Iterator) return Cursor is\n    begin\n-      if Object.Container = null then\n-         return No_Element;\n+      --  The value of the iterator object's Node component influences the\n+      --  behavior of the Last (and First) selector function.\n+\n+      --  When the Node component is null, this means the iterator object was\n+      --  constructed without a start expression, in which case the (reverse)\n+      --  iteration starts from the (logical) beginning of the entire sequence\n+      --  (corresponding to Container.Last, for a reverse iterator).\n+\n+      --  Otherwise, this is iteration over a partial sequence of items. When\n+      --  the Node component is non-null, the iterator object was constructed\n+      --  with a start expression, that specifies the position from which the\n+      --  (reverse) partial iteration begins.\n+\n+      if Object.Node = null then\n+         return Doubly_Linked_Lists.Last (Object.Container.all);\n       else\n-         return (Object.Container, Object.Container.Last);\n+         return Cursor'(Object.Container, Object.Node);\n       end if;\n    end Last;\n \n@@ -992,11 +1056,16 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       Position : Cursor) return Cursor\n    is\n    begin\n-      if Position.Node = Object.Container.Last then\n+      if Position.Container = null then\n          return No_Element;\n-      else\n-         return (Object.Container, Position.Node.Next);\n       end if;\n+\n+      if Position.Container /= Object.Container then\n+         raise Program_Error with\n+           \"Position cursor of Next designates wrong list\";\n+      end if;\n+\n+      return Next (Position);\n    end Next;\n \n    -------------\n@@ -1046,11 +1115,16 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       Position : Cursor) return Cursor\n    is\n    begin\n-      if Position.Node = Position.Container.First then\n+      if Position.Container = null then\n          return No_Element;\n-      else\n-         return (Object.Container, Position.Node.Prev);\n       end if;\n+\n+      if Position.Container /= Object.Container then\n+         raise Program_Error with\n+           \"Position cursor of Previous designates wrong list\";\n+      end if;\n+\n+      return Previous (Position);\n    end Previous;\n \n    -------------------"}, {"sha": "764325e4bdc1709ccbea8208de46ad8681575ba8", "filename": "gcc/ada/a-cidlli.adb", "status": "modified", "additions": 94, "deletions": 22, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/595a055f982c5b9c00b37cf289090e2627267d0b/gcc%2Fada%2Fa-cidlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/595a055f982c5b9c00b37cf289090e2627267d0b/gcc%2Fada%2Fa-cidlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cidlli.adb?ref=595a055f982c5b9c00b37cf289090e2627267d0b", "patch": "@@ -35,7 +35,7 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    procedure Free is\n      new Ada.Unchecked_Deallocation (Element_Type, Element_Access);\n \n-   type Iterator is new\n+   type Iterator is limited new\n      List_Iterator_Interfaces.Reversible_Iterator with record\n         Container : List_Access;\n         Node      : Node_Access;\n@@ -483,10 +483,23 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n    function First (Object : Iterator) return Cursor is\n    begin\n-      if Object.Container = null then\n-         return No_Element;\n+      --  The value of the iterator object's Node component influences the\n+      --  behavior of the First (and Last) selector function.\n+\n+      --  When the Node component is null, this means the iterator object was\n+      --  constructed without a start expression, in which case the (forward)\n+      --  iteration starts from the (logical) beginning of the entire sequence\n+      --  of items (corresponding to Container.First, for a forward iterator).\n+\n+      --  Otherwise, this is iteration over a partial sequence of items. When\n+      --  the Node component is non-null, the iterator object was constructed\n+      --  with a start expression, that specifies the position from which the\n+      --  (forward) partial iteration begins.\n+\n+      if Object.Node = null then\n+         return Indefinite_Doubly_Linked_Lists.First (Object.Container.all);\n       else\n-         return Cursor'(Object.Container, Object.Container.First);\n+         return Cursor'(Object.Container, Object.Node);\n       end if;\n    end First;\n \n@@ -895,24 +908,61 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n    function Iterate\n      (Container : List)\n-      return List_Iterator_Interfaces.Reversible_Iterator'class\n+      return List_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n    begin\n-      if Container.Length = 0 then\n-         return Iterator'(null, null);\n-      else\n-         return Iterator'(Container'Unchecked_Access, Container.First);\n-      end if;\n+      --  The value of the Node component influences the behavior of the First\n+      --  and Last selector functions of the iterator object. When the Node\n+      --  component is null (as is the case here), this means the iterator\n+      --  object was constructed without a start expression. This is a\n+      --  complete iterator, meaning that the iteration starts from the\n+      --  (logical) beginning of the sequence of items.\n+\n+      --  Note: For a forward iterator, Container.First is the beginning, and\n+      --  for a reverse iterator, Container.Last is the beginning.\n+\n+      return Iterator'(Container'Unrestricted_Access, Node => null);\n    end Iterate;\n \n    function Iterate\n      (Container : List;\n       Start     : Cursor)\n-      return List_Iterator_Interfaces.Reversible_Iterator'class\n+      return List_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n-      It : constant Iterator := (Container'Unchecked_Access, Start.Node);\n    begin\n-      return It;\n+      --  It was formerly the case that when Start = No_Element, the partial\n+      --  iterator was defined to behave the same as for a complete iterator,\n+      --  and iterate over the entire sequence of items. However, those\n+      --  semantics were unintuitive and arguably error-prone (it is too easy\n+      --  to accidentally create an endless loop), and so they were changed,\n+      --  per the ARG meeting in Denver on 2011/11. However, there was no\n+      --  consensus about what positive meaning this corner case should have,\n+      --  and so it was decided to simply raise an exception. This does imply,\n+      --  however, that it is not possible to use a partial iterator to specify\n+      --  an empty sequence of items.\n+\n+      if Start = No_Element then\n+         raise Constraint_Error with\n+           \"Start position for iterator equals No_Element\";\n+      end if;\n+\n+      if Start.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Start cursor of Iterate designates wrong list\";\n+      end if;\n+\n+      pragma Assert (Vet (Start), \"Start cursor of Iterate is bad\");\n+\n+      --  The value of the Node component influences the behavior of the First\n+      --  and Last selector functions of the iterator object. When the Node\n+      --  component is non-null (as is the case here), it means that this\n+      --  is a partial iteration, over a subset of the complete sequence of\n+      --  items. The iterator object was constructed with a start expression,\n+      --  indicating the position from which the iteration begins. Note that\n+      --  the start position has the same value irrespective of whether this\n+      --  is a forward or reverse iteration.\n+\n+      return Iterator'(Container'Unrestricted_Access, Node => Start.Node);\n    end Iterate;\n \n    ----------\n@@ -930,10 +980,23 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n    function Last (Object : Iterator) return Cursor is\n    begin\n-      if Object.Container = null then\n-         return No_Element;\n+      --  The value of the iterator object's Node component influences the\n+      --  behavior of the Last (and First) selector function.\n+\n+      --  When the Node component is null, this means the iterator object was\n+      --  constructed without a start expression, in which case the (reverse)\n+      --  iteration starts from the (logical) beginning of the entire sequence\n+      --  (corresponding to Container.Last, for a reverse iterator).\n+\n+      --  Otherwise, this is iteration over a partial sequence of items. When\n+      --  the Node component is non-null, the iterator object was constructed\n+      --  with a start expression, that specifies the position from which the\n+      --  (reverse) partial iteration begins.\n+\n+      if Object.Node = null then\n+         return Indefinite_Doubly_Linked_Lists.Last (Object.Container.all);\n       else\n-         return Cursor'(Object.Container, Object.Container.Last);\n+         return Cursor'(Object.Container, Object.Node);\n       end if;\n    end Last;\n \n@@ -1016,12 +1079,16 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n    function Next (Object : Iterator; Position : Cursor) return Cursor is\n    begin\n-      if Position.Node = Object.Container.Last then\n+      if Position.Container = null then\n          return No_Element;\n+      end if;\n \n-      else\n-         return (Object.Container, Position.Node.Next);\n+      if Position.Container /= Object.Container then\n+         raise Program_Error with\n+           \"Position cursor of Next designates wrong list\";\n       end if;\n+\n+      return Next (Position);\n    end Next;\n \n    -------------\n@@ -1067,11 +1134,16 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n    function Previous (Object : Iterator; Position : Cursor) return Cursor is\n    begin\n-      if Position.Node = Position.Container.First then\n+      if Position.Container = null then\n          return No_Element;\n-      else\n-         return (Object.Container, Position.Node.Prev);\n       end if;\n+\n+      if Position.Container /= Object.Container then\n+         raise Program_Error with\n+           \"Position cursor of Previous designates wrong list\";\n+      end if;\n+\n+      return Previous (Position);\n    end Previous;\n \n    -------------------"}]}