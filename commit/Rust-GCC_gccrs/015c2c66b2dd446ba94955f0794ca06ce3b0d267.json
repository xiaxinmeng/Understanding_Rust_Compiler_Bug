{"sha": "015c2c66b2dd446ba94955f0794ca06ce3b0d267", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDE1YzJjNjZiMmRkNDQ2YmE5NDk1NWYwNzk0Y2EwNmNlM2IwZDI2Nw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2006-08-20T23:53:10Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2006-08-20T23:53:10Z"}, "message": "re PR c++/28341 (ICE with references as template parameters)\n\n\tPR c++/28341\n\t* tree.c (cast_valid_in_integral_constant_expression_p): New\n\tfunction.\n\t* cp-tree.h (tsubst_copy_and_build): Adjust prototype.\n\t* pt.c (tsubst_expr): Add integral_constant_expression_p\n\tparameter.\n\t(fold_non_dependent_expr): Adjust callers of\n\ttsubst_{expr,copy_and_build}.\n\t(tsubst_friend_function): Likewise.\n\t(tsubst_template_arg): Likewise.\n\t(tsubst_default_argument): Likewise.\n\t(tsubst_decl): Likewise.\n\t(tsubst): Likewise.\n\t(tsubst_omp_clasuses): Likewise.\n\t(regenerate_decl_fromp_template): Likewise.\n\t(instantiate_decl): Likewise.\n\t(tsubst_initializer_list): Likewise.\n\t(tsubst_enum): Likewise.\n\t(tsubst_expr): Use RECUR throughout.\n\t(tsubst_copy_and_build): Change definition of RECUR.  Do not allow\n\tinvalid casts in integral constant expressions.\n\t* parser.c (cp_parser_postfix_expression): Use\n\tcast_valid_in_integral_constant_expression_p.\n\t(cp_parser_cast_expression): Likewise.\n\t(cp_parser_functional_cast): Likewise.\n\n\tPR c++/28346\n\t* pt.c (tsubst_qualified_id): Do not strip references from\n\tOFFSET_REFs. \n\n2006-08-20  Mark Mitchell  <mark@codesourcery.com>\n\n\tPR c++/28341\n\t* g++.dg/template/ref3.C: New test.\n\t* g++.dg/template/nontype13.C: New test.\n\n\tPR c++/28346\n\t* g++.dg/template/ptrmem17.C: New test.\n\n\n2006-08-20  Mark Mitchell  <mark@codesourcery.com>\n\n\t* objcp-lang.c (objcp_tsubst_copy_and_build): Adjust call to\n\ttsubst_copy_and_build.\n\nFrom-SVN: r116276", "tree": {"sha": "4756c8f497c36fa34840353e1ec97dc8da3e2992", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4756c8f497c36fa34840353e1ec97dc8da3e2992"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/015c2c66b2dd446ba94955f0794ca06ce3b0d267", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/015c2c66b2dd446ba94955f0794ca06ce3b0d267", "html_url": "https://github.com/Rust-GCC/gccrs/commit/015c2c66b2dd446ba94955f0794ca06ce3b0d267", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/015c2c66b2dd446ba94955f0794ca06ce3b0d267/comments", "author": null, "committer": null, "parents": [{"sha": "1057fc810fbf25761a2a9d14bad091c963020c62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1057fc810fbf25761a2a9d14bad091c963020c62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1057fc810fbf25761a2a9d14bad091c963020c62"}], "stats": {"total": 340, "additions": 230, "deletions": 110}, "files": [{"sha": "6fd125ab1d4883cd63e35f6552903bdc551a1918", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/015c2c66b2dd446ba94955f0794ca06ce3b0d267/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/015c2c66b2dd446ba94955f0794ca06ce3b0d267/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=015c2c66b2dd446ba94955f0794ca06ce3b0d267", "patch": "@@ -1,3 +1,35 @@\n+2006-08-20  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/28341\n+\t* tree.c (cast_valid_in_integral_constant_expression_p): New\n+\tfunction.\n+\t* cp-tree.h (tsubst_copy_and_build): Adjust prototype.\n+\t* pt.c (tsubst_expr): Add integral_constant_expression_p\n+\tparameter.\n+\t(fold_non_dependent_expr): Adjust callers of\n+\ttsubst_{expr,copy_and_build}.\n+\t(tsubst_friend_function): Likewise.\n+\t(tsubst_template_arg): Likewise.\n+\t(tsubst_default_argument): Likewise.\n+\t(tsubst_decl): Likewise.\n+\t(tsubst): Likewise.\n+\t(tsubst_omp_clasuses): Likewise.\n+\t(regenerate_decl_fromp_template): Likewise.\n+\t(instantiate_decl): Likewise.\n+\t(tsubst_initializer_list): Likewise.\n+\t(tsubst_enum): Likewise.\n+\t(tsubst_expr): Use RECUR throughout.\n+\t(tsubst_copy_and_build): Change definition of RECUR.  Do not allow\n+\tinvalid casts in integral constant expressions.\n+\t* parser.c (cp_parser_postfix_expression): Use\n+\tcast_valid_in_integral_constant_expression_p.\n+\t(cp_parser_cast_expression): Likewise.\n+\t(cp_parser_functional_cast): Likewise.\n+\n+\tPR c++/28346\n+\t* pt.c (tsubst_qualified_id): Do not strip references from\n+\tOFFSET_REFs. \n+\n 2006-08-17  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>\n \n \tPR c++/28606"}, {"sha": "79018a40878670d61441679943c929900cddc383", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/015c2c66b2dd446ba94955f0794ca06ce3b0d267/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/015c2c66b2dd446ba94955f0794ca06ce3b0d267/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=015c2c66b2dd446ba94955f0794ca06ce3b0d267", "patch": "@@ -4117,7 +4117,7 @@ extern void print_candidates\t\t\t(tree);\n extern void instantiate_pending_templates\t(int);\n extern tree tsubst_default_argument\t\t(tree, tree, tree);\n extern tree tsubst_copy_and_build\t\t(tree, tree, tsubst_flags_t,\n-\t\t\t\t\t\t tree, bool);\n+\t\t\t\t\t\t tree, bool, bool);\n extern tree most_general_template\t\t(tree);\n extern tree get_mostly_instantiated_function_type (tree);\n extern int problematic_instantiation_changed\t(void);\n@@ -4391,6 +4391,7 @@ extern tree fold_if_not_in_template\t\t(tree);\n extern tree rvalue\t\t\t\t(tree);\n extern tree convert_bitfield_to_declared_type   (tree);\n extern tree cp_save_expr\t\t\t(tree);\n+extern bool cast_valid_in_integral_constant_expression_p (tree);\n \n /* in typeck.c */\n extern int string_conv_p\t\t\t(tree, tree, int);"}, {"sha": "d015ae1d7a144cf1d9a8ba8278a9e0ee4013bdcd", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/015c2c66b2dd446ba94955f0794ca06ce3b0d267/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/015c2c66b2dd446ba94955f0794ca06ce3b0d267/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=015c2c66b2dd446ba94955f0794ca06ce3b0d267", "patch": "@@ -4004,9 +4004,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p)\n \n \t/* Only type conversions to integral or enumeration types\n \t   can be used in constant-expressions.  */\n-\tif (parser->integral_constant_expression_p\n-\t    && !dependent_type_p (type)\n-\t    && !INTEGRAL_OR_ENUMERATION_TYPE_P (type)\n+\tif (!cast_valid_in_integral_constant_expression_p (type)\n \t    && (cp_parser_non_integral_constant_expression\n \t\t(parser,\n \t\t \"a cast to a type other than an integral or \"\n@@ -5490,9 +5488,7 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p, bool cast_p)\n \n \t  /* Only type conversions to integral or enumeration types\n \t     can be used in constant-expressions.  */\n-\t  if (parser->integral_constant_expression_p\n-\t      && !dependent_type_p (type)\n-\t      && !INTEGRAL_OR_ENUMERATION_TYPE_P (type)\n+\t  if (!cast_valid_in_integral_constant_expression_p (type)\n \t      && (cp_parser_non_integral_constant_expression\n \t\t  (parser,\n \t\t   \"a cast to a type other than an integral or \"\n@@ -15695,13 +15691,11 @@ cp_parser_functional_cast (cp_parser* parser, tree type)\n      conversions to integral or enumeration type can be used\".  */\n   if (TREE_CODE (type) == TYPE_DECL)\n     type = TREE_TYPE (type);\n-  if (cast != error_mark_node && !dependent_type_p (type)\n-      && !INTEGRAL_OR_ENUMERATION_TYPE_P (type))\n-    {\n-      if (cp_parser_non_integral_constant_expression\n-\t  (parser, \"a call to a constructor\"))\n-\treturn error_mark_node;\n-    }\n+  if (cast != error_mark_node\n+      && !cast_valid_in_integral_constant_expression_p (type)\n+      && (cp_parser_non_integral_constant_expression\n+\t  (parser, \"a call to a constructor\")))\n+    return error_mark_node;\n   return cast;\n }\n "}, {"sha": "4a58ef3cb6d8a68e860037db4c121befe0fe05f5", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 138, "deletions": 93, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/015c2c66b2dd446ba94955f0794ca06ce3b0d267/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/015c2c66b2dd446ba94955f0794ca06ce3b0d267/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=015c2c66b2dd446ba94955f0794ca06ce3b0d267", "patch": "@@ -159,7 +159,7 @@ static int invalid_nontype_parm_type_p (tree, tsubst_flags_t);\n static int eq_local_specializations (const void *, const void *);\n static bool dependent_type_p_r (tree);\n static tree tsubst (tree, tree, tsubst_flags_t, tree);\n-static tree tsubst_expr\t(tree, tree, tsubst_flags_t, tree);\n+static tree tsubst_expr\t(tree, tree, tsubst_flags_t, tree, bool);\n static tree tsubst_copy\t(tree, tree, tsubst_flags_t, tree);\n \n /* Make the current scope suitable for access checking when we are\n@@ -3400,7 +3400,8 @@ fold_non_dependent_expr (tree expr)\n \t\t\t\t    /*args=*/NULL_TREE,\n \t\t\t\t    tf_error,\n \t\t\t\t    /*in_decl=*/NULL_TREE,\n-\t\t\t\t    /*function_p=*/false);\n+\t\t\t\t    /*function_p=*/false,\n+\t\t\t\t    /*integral_constant_expression_p=*/true);\n       processing_template_decl = saved_processing_template_decl;\n     }\n   return expr;\n@@ -5225,7 +5226,8 @@ tsubst_friend_function (tree decl, tree args)\n \t current cless with same name.  */\n       push_nested_namespace (ns);\n       fns = tsubst_expr (DECL_TI_TEMPLATE (decl), args,\n-\t\t\t tf_warning_or_error, NULL_TREE);\n+\t\t\t tf_warning_or_error, NULL_TREE,\n+\t\t\t /*integral_constant_expression_p=*/false);\n       pop_nested_namespace (ns);\n       arglist = tsubst (DECL_TI_ARGS (decl), args,\n \t\t\ttf_warning_or_error, NULL_TREE);\n@@ -6035,7 +6037,8 @@ tsubst_template_arg (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n     r = tsubst (t, args, complain, in_decl);\n   else\n     {\n-      r = tsubst_expr (t, args, complain, in_decl);\n+      r = tsubst_expr (t, args, complain, in_decl,\n+\t\t       /*integral_constant_expression_p=*/true);\n       r = fold_non_dependent_expr (r);\n     }\n   return r;\n@@ -6260,7 +6263,8 @@ tsubst_default_argument (tree fn, tree type, tree arg)\n      stack.  */\n   ++function_depth;\n   arg = tsubst_expr (arg, DECL_TI_ARGS (fn),\n-\t\t     tf_warning_or_error, NULL_TREE);\n+\t\t     tf_warning_or_error, NULL_TREE,\n+\t\t     /*integral_constant_expression_p=*/false);\n   --function_depth;\n   pop_deferring_access_checks();\n \n@@ -6721,10 +6725,13 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \tTREE_TYPE (r) = type;\n \tcp_apply_type_quals_to_decl (cp_type_quals (type), r);\n \n+\t/* DECL_INITIAL gives the number of bits in a bit-field.  */\n+\tDECL_INITIAL (r)\n+\t  = tsubst_expr (DECL_INITIAL (t), args,\n+\t\t\t complain, in_decl,\n+\t\t\t /*integral_constant_expression_p=*/true);\n \t/* We don't have to set DECL_CONTEXT here; it is set by\n \t   finish_member_declaration.  */\n-\tDECL_INITIAL (r) = tsubst_expr (DECL_INITIAL (t), args,\n-\t\t\t\t\tcomplain, in_decl);\n \tTREE_CHAIN (r) = NULL_TREE;\n \tif (VOID_TYPE_P (type))\n \t  error (\"instantiation of %q+D as type %qT\", r, type);\n@@ -6852,7 +6859,8 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t    if (DECL_HAS_VALUE_EXPR_P (t))\n \t      {\n \t\ttree ve = DECL_VALUE_EXPR (t);\n-\t\tve = tsubst_expr (ve, args, complain, in_decl);\n+\t\tve = tsubst_expr (ve, args, complain, in_decl,\n+\t\t\t\t  /*constant_expression_p=*/false);\n \t\tSET_DECL_VALUE_EXPR (r, ve);\n \t      }\n \t  }\n@@ -7658,7 +7666,8 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n     case ARRAY_REF:\n       {\n \ttree e1 = tsubst (TREE_OPERAND (t, 0), args, complain, in_decl);\n-\ttree e2 = tsubst_expr (TREE_OPERAND (t, 1), args, complain, in_decl);\n+\ttree e2 = tsubst_expr (TREE_OPERAND (t, 1), args, complain, in_decl,\n+\t\t\t       /*integral_constant_expression_p=*/false);\n \tif (e1 == error_mark_node || e2 == error_mark_node)\n \t  return error_mark_node;\n \n@@ -7680,8 +7689,10 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       {\n \ttree type;\n \n-\ttype = finish_typeof (tsubst_expr (TYPEOF_TYPE_EXPR (t), args,\n-\t\t\t\t\t   complain, in_decl));\n+\ttype = finish_typeof (tsubst_expr \n+\t\t\t      (TYPEOF_TYPE_EXPR (t), args,\n+\t\t\t       complain, in_decl,\n+\t\t\t       /*integral_constant_expression_p=*/false));\n \treturn cp_build_qualified_type_real (type,\n \t\t\t\t\t     cp_type_quals (t)\n \t\t\t\t\t     | cp_type_quals (type),\n@@ -7867,7 +7878,11 @@ tsubst_qualified_id (tree qualified_id, tree args,\n \t       /*template_arg_p=*/false));\n     }\n \n-  if (TREE_CODE (expr) != SCOPE_REF)\n+  /* Expressions do not generally have reference type.  */\n+  if (TREE_CODE (expr) != SCOPE_REF\n+      /* However, if we're about to form a pointer-to-member, we just\n+\t want the referenced member referenced.  */\n+      && TREE_CODE (expr) != OFFSET_REF)\n     expr = convert_from_reference (expr);\n \n   return expr;\n@@ -8276,7 +8291,8 @@ tsubst_omp_clauses (tree clauses, tree args, tsubst_flags_t complain,\n \tcase OMP_CLAUSE_NUM_THREADS:\n \tcase OMP_CLAUSE_SCHEDULE:\n \t  OMP_CLAUSE_OPERAND (nc, 0)\n-\t    = tsubst_expr (OMP_CLAUSE_OPERAND (oc, 0), args, complain, in_decl);\n+\t    = tsubst_expr (OMP_CLAUSE_OPERAND (oc, 0), args, complain, \n+\t\t\t   in_decl, /*integral_constant_expression_p=*/false);\n \t  break;\n \tcase OMP_CLAUSE_NOWAIT:\n \tcase OMP_CLAUSE_ORDERED:\n@@ -8305,7 +8321,8 @@ tsubst_copy_asm_operands (tree t, tree args, tsubst_flags_t complain,\n \n   if (TREE_CODE (t) != TREE_LIST)\n     return tsubst_copy_and_build (t, args, complain, in_decl,\n-\t\t\t\t  /*function_p=*/false);\n+\t\t\t\t  /*function_p=*/false,\n+\t\t\t\t  /*integral_constant_expression_p=*/false);\n \n   if (t == void_list_node)\n     return t;\n@@ -8327,8 +8344,13 @@ tsubst_copy_asm_operands (tree t, tree args, tsubst_flags_t complain,\n    processing.  */\n \n static tree\n-tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n+tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n+\t     bool integral_constant_expression_p)\n {\n+#define RECUR(NODE)\t\t\t\t\\\n+  tsubst_expr ((NODE), args, complain, in_decl,\t\\\n+\t       integral_constant_expression_p)\n+\n   tree stmt, tmp;\n \n   if (t == NULL_TREE || t == error_mark_node)\n@@ -8345,7 +8367,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       {\n \ttree_stmt_iterator i;\n \tfor (i = tsi_start (t); !tsi_end_p (i); tsi_next (&i))\n-\t  tsubst_expr (tsi_stmt (i), args, complain, in_decl);\n+\t  RECUR (tsi_stmt (i));\n \tbreak;\n       }\n \n@@ -8355,21 +8377,19 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       break;\n \n     case RETURN_EXPR:\n-      finish_return_stmt (tsubst_expr (TREE_OPERAND (t, 0),\n-\t\t\t\t       args, complain, in_decl));\n+      finish_return_stmt (RECUR (TREE_OPERAND (t, 0)));\n       break;\n \n     case EXPR_STMT:\n-      tmp = tsubst_expr (EXPR_STMT_EXPR (t), args, complain, in_decl);\n+      tmp = RECUR (EXPR_STMT_EXPR (t));\n       if (EXPR_STMT_STMT_EXPR_RESULT (t))\n \tfinish_stmt_expr_expr (tmp, cur_stmt_expr);\n       else\n \tfinish_expr_stmt (tmp);\n       break;\n \n     case USING_STMT:\n-      do_using_directive (tsubst_expr (USING_STMT_NAMESPACE (t),\n-\t\t\t\t       args, complain, in_decl));\n+      do_using_directive (RECUR (USING_STMT_NAMESPACE (t)));\n       break;\n \n     case DECL_EXPR:\n@@ -8386,7 +8406,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t    tree name = DECL_NAME (decl);\n \t    tree decl;\n \n-\t    scope = tsubst_expr (scope, args, complain, in_decl);\n+\t    scope = RECUR (scope);\n \t    decl = lookup_qualified_name (scope, name,\n \t\t\t\t\t  /*is_type_p=*/false,\n \t\t\t\t\t  /*complain=*/false);\n@@ -8425,7 +8445,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t\t\tinit = cp_fname_init (name, &TREE_TYPE (decl));\n \t\t      }\n \t\t    else\n-\t\t      init = tsubst_expr (init, args, complain, in_decl);\n+\t\t      init = RECUR (init);\n \t\t    finish_decl (decl, init, NULL_TREE);\n \t\t  }\n \t      }\n@@ -8438,43 +8458,43 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \n     case FOR_STMT:\n       stmt = begin_for_stmt ();\n-      tsubst_expr (FOR_INIT_STMT (t), args, complain, in_decl);\n+\t\t\t  RECUR (FOR_INIT_STMT (t));\n       finish_for_init_stmt (stmt);\n-      tmp = tsubst_expr (FOR_COND (t), args, complain, in_decl);\n+      tmp = RECUR (FOR_COND (t));\n       finish_for_cond (tmp, stmt);\n-      tmp = tsubst_expr (FOR_EXPR (t), args, complain, in_decl);\n+      tmp = RECUR (FOR_EXPR (t));\n       finish_for_expr (tmp, stmt);\n-      tsubst_expr (FOR_BODY (t), args, complain, in_decl);\n+      RECUR (FOR_BODY (t));\n       finish_for_stmt (stmt);\n       break;\n \n     case WHILE_STMT:\n       stmt = begin_while_stmt ();\n-      tmp = tsubst_expr (WHILE_COND (t), args, complain, in_decl);\n+      tmp = RECUR (WHILE_COND (t));\n       finish_while_stmt_cond (tmp, stmt);\n-      tsubst_expr (WHILE_BODY (t), args, complain, in_decl);\n+      RECUR (WHILE_BODY (t));\n       finish_while_stmt (stmt);\n       break;\n \n     case DO_STMT:\n       stmt = begin_do_stmt ();\n-      tsubst_expr (DO_BODY (t), args, complain, in_decl);\n+      RECUR (DO_BODY (t));\n       finish_do_body (stmt);\n-      tmp = tsubst_expr (DO_COND (t), args, complain, in_decl);\n+      tmp = RECUR (DO_COND (t));\n       finish_do_stmt (tmp, stmt);\n       break;\n \n     case IF_STMT:\n       stmt = begin_if_stmt ();\n-      tmp = tsubst_expr (IF_COND (t), args, complain, in_decl);\n+      tmp = RECUR (IF_COND (t));\n       finish_if_stmt_cond (tmp, stmt);\n-      tsubst_expr (THEN_CLAUSE (t), args, complain, in_decl);\n+      RECUR (THEN_CLAUSE (t));\n       finish_then_clause (stmt);\n \n       if (ELSE_CLAUSE (t))\n \t{\n \t  begin_else_clause (stmt);\n-\t  tsubst_expr (ELSE_CLAUSE (t), args, complain, in_decl);\n+\t  RECUR (ELSE_CLAUSE (t));\n \t  finish_else_clause (stmt);\n \t}\n \n@@ -8488,7 +8508,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \tstmt = begin_compound_stmt (BIND_EXPR_TRY_BLOCK (t)\n \t\t\t\t    ? BCS_TRY_BLOCK : 0);\n \n-      tsubst_expr (BIND_EXPR_BODY (t), args, complain, in_decl);\n+      RECUR (BIND_EXPR_BODY (t));\n \n       if (BIND_EXPR_BODY_BLOCK (t))\n \tfinish_function_body (stmt);\n@@ -8506,16 +8526,15 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \n     case SWITCH_STMT:\n       stmt = begin_switch_stmt ();\n-      tmp = tsubst_expr (SWITCH_STMT_COND (t), args, complain, in_decl);\n+      tmp = RECUR (SWITCH_STMT_COND (t));\n       finish_switch_cond (tmp, stmt);\n-      tsubst_expr (SWITCH_STMT_BODY (t), args, complain, in_decl);\n+      RECUR (SWITCH_STMT_BODY (t));\n       finish_switch_stmt (stmt);\n       break;\n \n     case CASE_LABEL_EXPR:\n-      finish_case_label (tsubst_expr (CASE_LOW (t), args, complain, in_decl),\n-\t\t\t tsubst_expr (CASE_HIGH (t), args, complain,\n-\t\t\t\t      in_decl));\n+      finish_case_label (RECUR (CASE_LOW (t)),\n+\t\t\t RECUR (CASE_HIGH (t)));\n       break;\n \n     case LABEL_EXPR:\n@@ -8528,7 +8547,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t/* Computed goto's must be tsubst'd into.  On the other hand,\n \t   non-computed gotos must not be; the identifier in question\n \t   will have no binding.  */\n-\ttmp = tsubst_expr (tmp, args, complain, in_decl);\n+\ttmp = RECUR (tmp);\n       else\n \ttmp = DECL_NAME (tmp);\n       finish_goto_stmt (tmp);\n@@ -8537,7 +8556,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n     case ASM_EXPR:\n       tmp = finish_asm_stmt\n \t(ASM_VOLATILE_P (t),\n-\t tsubst_expr (ASM_STRING (t), args, complain, in_decl),\n+\t RECUR (ASM_STRING (t)),\n \t tsubst_copy_asm_operands (ASM_OUTPUTS (t), args, complain, in_decl),\n \t tsubst_copy_asm_operands (ASM_INPUTS (t), args, complain, in_decl),\n \t tsubst_copy_asm_operands (ASM_CLOBBERS (t), args, complain, in_decl));\n@@ -8553,11 +8572,9 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       if (CLEANUP_P (t))\n \t{\n \t  stmt = begin_try_block ();\n-\t  tsubst_expr (TRY_STMTS (t), args, complain, in_decl);\n+\t  RECUR (TRY_STMTS (t));\n \t  finish_cleanup_try_block (stmt);\n-\t  finish_cleanup (tsubst_expr (TRY_HANDLERS (t), args,\n-\t\t\t\t       complain, in_decl),\n-\t\t\t  stmt);\n+\t  finish_cleanup (RECUR (TRY_HANDLERS (t)), stmt);\n \t}\n       else\n \t{\n@@ -8568,14 +8585,14 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t  else\n \t    stmt = begin_try_block ();\n \n-\t  tsubst_expr (TRY_STMTS (t), args, complain, in_decl);\n+\t  RECUR (TRY_STMTS (t));\n \n \t  if (FN_TRY_BLOCK_P (t))\n \t    finish_function_try_block (stmt);\n \t  else\n \t    finish_try_block (stmt);\n \n-\t  tsubst_expr (TRY_HANDLERS (t), args, complain, in_decl);\n+\t  RECUR (TRY_HANDLERS (t));\n \t  if (FN_TRY_BLOCK_P (t))\n \t    finish_function_handler_sequence (stmt, compound_stmt);\n \t  else\n@@ -8598,7 +8615,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t  }\n \tstmt = begin_handler ();\n \tfinish_handler_parms (decl, stmt);\n-\ttsubst_expr (HANDLER_BODY (t), args, complain, in_decl);\n+\tRECUR (HANDLER_BODY (t));\n \tfinish_handler (stmt);\n       }\n       break;\n@@ -8611,7 +8628,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       tmp = tsubst_omp_clauses (OMP_PARALLEL_CLAUSES (t),\n \t\t\t\targs, complain, in_decl);\n       stmt = begin_omp_parallel ();\n-      tsubst_expr (OMP_PARALLEL_BODY (t), args, complain, in_decl);\n+      RECUR (OMP_PARALLEL_BODY (t));\n       OMP_PARALLEL_COMBINED (finish_omp_parallel (tmp, stmt))\n \t= OMP_PARALLEL_COMBINED (t);\n       break;\n@@ -8624,19 +8641,19 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t\t\t\t      args, complain, in_decl);\n \tinit = OMP_FOR_INIT (t);\n \tgcc_assert (TREE_CODE (init) == MODIFY_EXPR);\n-\tdecl = tsubst_expr (TREE_OPERAND (init, 0), args, complain, in_decl);\n-\tinit = tsubst_expr (TREE_OPERAND (init, 1), args, complain, in_decl);\n-\tcond = tsubst_expr (OMP_FOR_COND (t), args, complain, in_decl);\n-\tincr = tsubst_expr (OMP_FOR_INCR (t), args, complain, in_decl);\n+\tdecl = RECUR (TREE_OPERAND (init, 0));\n+\tinit = RECUR (TREE_OPERAND (init, 1));\n+\tcond = RECUR (OMP_FOR_COND (t));\n+\tincr = RECUR (OMP_FOR_INCR (t));\n \n \tstmt = begin_omp_structured_block ();\n \n \tpre_body = push_stmt_list ();\n-\ttsubst_expr (OMP_FOR_PRE_BODY (t), args, complain, in_decl);\n+\tRECUR (OMP_FOR_PRE_BODY (t));\n \tpre_body = pop_stmt_list (pre_body);\n \n \tbody = push_stmt_list ();\n-\ttsubst_expr (OMP_FOR_BODY (t), args, complain, in_decl);\n+\tRECUR (OMP_FOR_BODY (t));\n \tbody = pop_stmt_list (body);\n \n \tt = finish_omp_for (EXPR_LOCATION (t), decl, init, cond, incr, body,\n@@ -8652,7 +8669,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n     case OMP_SINGLE:\n       tmp = tsubst_omp_clauses (OMP_CLAUSES (t), args, complain, in_decl);\n       stmt = push_stmt_list ();\n-      tsubst_expr (OMP_BODY (t), args, complain, in_decl);\n+      RECUR (OMP_BODY (t));\n       stmt = pop_stmt_list (stmt);\n \n       t = copy_node (t);\n@@ -8666,7 +8683,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n     case OMP_MASTER:\n     case OMP_ORDERED:\n       stmt = push_stmt_list ();\n-      tsubst_expr (OMP_BODY (t), args, complain, in_decl);\n+      RECUR (OMP_BODY (t));\n       stmt = pop_stmt_list (stmt);\n \n       t = copy_node (t);\n@@ -8677,8 +8694,8 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n     case OMP_ATOMIC:\n       {\n \ttree op0, op1;\n-\top0 = tsubst_expr (TREE_OPERAND (t, 0), args, complain, in_decl);\n-\top1 = tsubst_expr (TREE_OPERAND (t, 1), args, complain, in_decl);\n+\top0 = RECUR (TREE_OPERAND (t, 0));\n+\top1 = RECUR (TREE_OPERAND (t, 1));\n \tfinish_omp_atomic (OMP_ATOMIC_CODE (t), op0, op1);\n       }\n       break;\n@@ -8687,10 +8704,12 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       gcc_assert (!STATEMENT_CODE_P (TREE_CODE (t)));\n \n       return tsubst_copy_and_build (t, args, complain, in_decl,\n-\t\t\t\t    /*function_p=*/false);\n+\t\t\t\t    /*function_p=*/false,\n+\t\t\t\t    integral_constant_expression_p);\n     }\n \n   return NULL_TREE;\n+#undef RECUR\n }\n \n /* T is a postfix-expression that is not being used in a function\n@@ -8706,7 +8725,8 @@ tsubst_non_call_postfix_expression (tree t, tree args,\n \t\t\t     /*done=*/false, /*address_p=*/false);\n   else\n     t = tsubst_copy_and_build (t, args, complain, in_decl,\n-\t\t\t       /*function_p=*/false);\n+\t\t\t       /*function_p=*/false,\n+\t\t\t       /*integral_constant_expression_p=*/false);\n \n   return t;\n }\n@@ -8719,10 +8739,13 @@ tsubst_copy_and_build (tree t,\n \t\t       tree args,\n \t\t       tsubst_flags_t complain,\n \t\t       tree in_decl,\n-\t\t       bool function_p)\n+\t\t       bool function_p,\n+\t\t       bool integral_constant_expression_p)\n {\n-#define RECUR(NODE) \\\n-  tsubst_copy_and_build (NODE, args, complain, in_decl, /*function_p=*/false)\n+#define RECUR(NODE)\t\t\t\t\t\t\\\n+  tsubst_copy_and_build (NODE, args, complain, in_decl, \t\\\n+\t\t\t /*function_p=*/false,\t\t\t\\\n+\t\t\t integral_constant_expression_p)\n \n   tree op1;\n \n@@ -8757,7 +8780,7 @@ tsubst_copy_and_build (tree t,\n \n \tdecl = finish_id_expression (t, decl, NULL_TREE,\n \t\t\t\t     &idk,\n-\t\t\t\t     /*integral_constant_expression_p=*/false,\n+\t\t\t\t     integral_constant_expression_p,\n \t\t\t\t     /*allow_non_integral_constant_expression_p=*/false,\n \t\t\t\t     &non_integral_constant_expression_p,\n \t\t\t\t     /*template_p=*/false,\n@@ -8820,29 +8843,41 @@ tsubst_copy_and_build (tree t,\n \t RECUR (TREE_OPERAND (t, 0)));\n \n     case CAST_EXPR:\n-      return build_functional_cast\n-\t(tsubst (TREE_TYPE (t), args, complain, in_decl),\n-\t RECUR (TREE_OPERAND (t, 0)));\n-\n     case REINTERPRET_CAST_EXPR:\n-      return build_reinterpret_cast\n-\t(tsubst (TREE_TYPE (t), args, complain, in_decl),\n-\t RECUR (TREE_OPERAND (t, 0)));\n-\n     case CONST_CAST_EXPR:\n-      return build_const_cast\n-\t(tsubst (TREE_TYPE (t), args, complain, in_decl),\n-\t RECUR (TREE_OPERAND (t, 0)));\n-\n     case DYNAMIC_CAST_EXPR:\n-      return build_dynamic_cast\n-\t(tsubst (TREE_TYPE (t), args, complain, in_decl),\n-\t RECUR (TREE_OPERAND (t, 0)));\n-\n     case STATIC_CAST_EXPR:\n-      return build_static_cast\n-\t(tsubst (TREE_TYPE (t), args, complain, in_decl),\n-\t RECUR (TREE_OPERAND (t, 0)));\n+      {\n+\ttree type;\n+\ttree op;\n+\n+\ttype = tsubst (TREE_TYPE (t), args, complain, in_decl);\n+\tif (integral_constant_expression_p\n+\t    && !cast_valid_in_integral_constant_expression_p (type))\n+\t  {\n+\t    error (\"a cast to a type other than an integral or \"\n+\t\t   \"enumeration type cannot appear in a constant-expression\");\n+\t    return error_mark_node; \n+\t  }\n+\n+\top = RECUR (TREE_OPERAND (t, 0));\n+\n+\tswitch (TREE_CODE (t))\n+\t  {\n+\t  case CAST_EXPR:\n+\t    return build_functional_cast (type, op);\n+\t  case REINTERPRET_CAST_EXPR:\n+\t    return build_reinterpret_cast (type, op);\n+\t  case CONST_CAST_EXPR:\n+\t    return build_const_cast (type, op);\n+\t  case DYNAMIC_CAST_EXPR:\n+\t    return build_dynamic_cast (type, op);\n+\t  case STATIC_CAST_EXPR:\n+\t    return build_static_cast (type, op);\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n+      }\n \n     case POSTDECREMENT_EXPR:\n     case POSTINCREMENT_EXPR:\n@@ -8933,7 +8968,9 @@ tsubst_copy_and_build (tree t,\n       else\n \t{\n \t  ++skip_evaluation;\n-\t  op1 = RECUR (op1);\n+\t  op1 = tsubst_copy_and_build (op1, args, complain, in_decl,\n+\t\t\t\t       /*function_p=*/false,\n+\t\t\t\t       /*integral_constant_expression_p=*/false);\n \t  --skip_evaluation;\n \t}\n       if (TYPE_P (op1))\n@@ -9018,7 +9055,9 @@ tsubst_copy_and_build (tree t,\n \n \t    function = tsubst_copy_and_build (function, args, complain,\n \t\t\t\t\t      in_decl,\n-\t\t\t\t\t      !qualified_p);\n+\t\t\t\t\t      !qualified_p,\n+\t\t\t\t\t      integral_constant_expression_p);\n+\n \t    if (BASELINK_P (function))\n \t      qualified_p = true;\n \t  }\n@@ -9267,7 +9306,8 @@ tsubst_copy_and_build (tree t,\n \ttree stmt_expr = begin_stmt_expr ();\n \n \tcur_stmt_expr = stmt_expr;\n-\ttsubst_expr (STMT_EXPR_STMT (t), args, complain, in_decl);\n+\ttsubst_expr (STMT_EXPR_STMT (t), args, complain, in_decl,\n+\t\t     integral_constant_expression_p);\n \tstmt_expr = finish_stmt_expr (stmt_expr, false);\n \tcur_stmt_expr = old_stmt_expr;\n \n@@ -11751,7 +11791,8 @@ regenerate_decl_from_template (tree decl, tree tmpl)\n   else if (TREE_CODE (decl) == VAR_DECL)\n     DECL_INITIAL (decl) =\n       tsubst_expr (DECL_INITIAL (code_pattern), args,\n-\t\t   tf_error, DECL_TI_TEMPLATE (decl));\n+\t\t   tf_error, DECL_TI_TEMPLATE (decl),\n+\t\t   /*integral_constant_expression_p=*/false);\n   else\n     gcc_unreachable ();\n \n@@ -12000,7 +12041,8 @@ instantiate_decl (tree d, int defer_ok,\n \t  push_nested_class (DECL_CONTEXT (d));\n \t  init = tsubst_expr (DECL_INITIAL (code_pattern),\n \t\t\t      args,\n-\t\t\t      tf_warning_or_error, NULL_TREE);\n+\t\t\t      tf_warning_or_error, NULL_TREE,\n+\t\t\t      /*integral_constant_expression_p=*/false);\n \t  cp_finish_decl (d, init, /*init_const_expr_p=*/false,\n \t\t\t  /*asmspec_tree=*/NULL_TREE,\n \t\t\t  LOOKUP_ONLYCONVERTING);\n@@ -12131,7 +12173,8 @@ instantiate_decl (tree d, int defer_ok,\n \n       /* Substitute into the body of the function.  */\n       tsubst_expr (DECL_SAVED_TREE (code_pattern), args,\n-\t\t   tf_warning_or_error, tmpl);\n+\t\t   tf_warning_or_error, tmpl,\n+\t\t   /*integral_constant_expression_p=*/false);\n \n       /* We don't need the local specializations any more.  */\n       htab_delete (local_specializations);\n@@ -12285,7 +12328,8 @@ tsubst_initializer_list (tree t, tree argvec)\n \tin_base_initializer = 1;\n \n       init = tsubst_expr (TREE_VALUE (t), argvec, tf_warning_or_error,\n-\t\t\t  NULL_TREE);\n+\t\t\t  NULL_TREE, \n+\t\t\t  /*integral_constant_expression_p=*/false);\n       in_base_initializer = 0;\n \n       if (decl)\n@@ -12329,7 +12373,8 @@ tsubst_enum (tree tag, tree newtag, tree args)\n       /* Note that in a template enum, the TREE_VALUE is the\n \t CONST_DECL, not the corresponding INTEGER_CST.  */\n       value = tsubst_expr (DECL_INITIAL (decl),\n-\t\t\t   args, tf_warning_or_error, NULL_TREE);\n+\t\t\t   args, tf_warning_or_error, NULL_TREE,\n+\t\t\t   /*integral_constant_expression_p=*/true);\n \n       /* Give this enumeration constant the correct access.  */\n       set_current_access_from_decl (decl);"}, {"sha": "90839b73ab3e5ab4a8732f0c9c94d17aad4b0d01", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/015c2c66b2dd446ba94955f0794ca06ce3b0d267/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/015c2c66b2dd446ba94955f0794ca06ce3b0d267/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=015c2c66b2dd446ba94955f0794ca06ce3b0d267", "patch": "@@ -2376,6 +2376,17 @@ fold_if_not_in_template (tree expr)\n   return fold (expr);\n }\n \n+/* Returns true if a cast to TYPE may appear in an integral constant\n+   expression.  */\n+\n+bool\n+cast_valid_in_integral_constant_expression_p (tree type)\n+{\n+  return (INTEGRAL_OR_ENUMERATION_TYPE_P (type)\n+\t  || dependent_type_p (type)\n+\t  || type == error_mark_node);\n+}\n+\n \f\n #if defined ENABLE_TREE_CHECKING && (GCC_VERSION >= 2007)\n /* Complain that some language-specific thing hanging off a tree"}, {"sha": "38b9ffe63a4ba7dda9d1cd1995ba9e6c84deccfb", "filename": "gcc/objcp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/015c2c66b2dd446ba94955f0794ca06ce3b0d267/gcc%2Fobjcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/015c2c66b2dd446ba94955f0794ca06ce3b0d267/gcc%2Fobjcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2FChangeLog?ref=015c2c66b2dd446ba94955f0794ca06ce3b0d267", "patch": "@@ -1,3 +1,8 @@\n+2006-08-20  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* objcp-lang.c (objcp_tsubst_copy_and_build): Adjust call to\n+\ttsubst_copy_and_build.\n+\n 2006-07-28  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>\n \n \t* Make-lang.in: Use $(HEADER_H) instead of header.h in dependencies."}, {"sha": "19a865475a68fecde35fa6973872eedfa84d41f0", "filename": "gcc/objcp/objcp-lang.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/015c2c66b2dd446ba94955f0794ca06ce3b0d267/gcc%2Fobjcp%2Fobjcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/015c2c66b2dd446ba94955f0794ca06ce3b0d267/gcc%2Fobjcp%2Fobjcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2Fobjcp-lang.c?ref=015c2c66b2dd446ba94955f0794ca06ce3b0d267", "patch": "@@ -110,8 +110,10 @@ tree\n objcp_tsubst_copy_and_build (tree t, tree args, tsubst_flags_t complain, \n \t\t\t     tree in_decl, bool function_p ATTRIBUTE_UNUSED)\n {\n-#define RECURSE(NODE) \\\n-  tsubst_copy_and_build (NODE, args, complain, in_decl, /*function_p=*/false)\n+#define RECURSE(NODE)\t\t\t\t\t\t\t\\\n+  tsubst_copy_and_build (NODE, args, complain, in_decl, \t\t\\\n+\t\t\t /*function_p=*/false,\t\t\t\t\\\n+\t\t\t /*integral_constant_expression_p=*/false)\n \n   /* The following two can only occur in Objective-C++.  */\n "}, {"sha": "bc920d07795d81ca6244a2c7ce7ee7e42631f171", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/015c2c66b2dd446ba94955f0794ca06ce3b0d267/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/015c2c66b2dd446ba94955f0794ca06ce3b0d267/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=015c2c66b2dd446ba94955f0794ca06ce3b0d267", "patch": "@@ -1,3 +1,12 @@\n+2006-08-20  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/28341\n+\t* g++.dg/template/ref3.C: New test.\n+\t* g++.dg/template/nontype13.C: New test.\n+\n+\tPR c++/28346\n+\t* g++.dg/template/ptrmem17.C: New test.\n+\n 2006-08-20  Danny Smith  <dannysmith@users.sourceforge.net>\n \n \tPR target/28648 c:"}, {"sha": "9b76d1aa65abfffdc45c8bbdd948ac193eecc6e2", "filename": "gcc/testsuite/g++.dg/template/nontype13.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/015c2c66b2dd446ba94955f0794ca06ce3b0d267/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/015c2c66b2dd446ba94955f0794ca06ce3b0d267/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype13.C?ref=015c2c66b2dd446ba94955f0794ca06ce3b0d267", "patch": "@@ -11,7 +11,7 @@ struct Dummy\n   template<bool B>\n   void tester()\n   {\n-    bar<evil>()(); // { dg-error \"argument\" }\n+    bar<evil>()(); // { dg-error \"constant\" }\n   }\n   template<bool B>\n   struct bar"}, {"sha": "154f17a8d86f296a335d19ded63aef92c4a27985", "filename": "gcc/testsuite/g++.dg/template/ptrmem17.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/015c2c66b2dd446ba94955f0794ca06ce3b0d267/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fptrmem17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/015c2c66b2dd446ba94955f0794ca06ce3b0d267/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fptrmem17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fptrmem17.C?ref=015c2c66b2dd446ba94955f0794ca06ce3b0d267", "patch": "@@ -0,0 +1,10 @@\n+// PR c++/28346\n+\n+template<int> struct A\n+{\n+  int& i;\n+  A();\n+  ~A() { &A::i; } // { dg-error \"reference\" }\n+};\n+\n+A<0> a; // { dg-error \"instantiated\" }"}, {"sha": "4390f71b4077455ac7386407b9ec213b8aef7d14", "filename": "gcc/testsuite/g++.dg/template/ref3.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/015c2c66b2dd446ba94955f0794ca06ce3b0d267/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fref3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/015c2c66b2dd446ba94955f0794ca06ce3b0d267/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fref3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fref3.C?ref=015c2c66b2dd446ba94955f0794ca06ce3b0d267", "patch": "@@ -0,0 +1,11 @@\n+// PR c++/28341\n+\n+template<const int&> struct A {};\n+\n+template<typename T> struct B\n+{\n+  A<(T)0> b; // { dg-error \"constant\" }\n+  A<T(0)> a; // { dg-error \"constant\" }\n+};\n+\n+B<const int&> b;"}]}