{"sha": "f2cbd970083b0c0af05fb2cfca08ad4e8d02dc41", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjJjYmQ5NzAwODNiMGMwYWYwNWZiMmNmY2EwOGFkNGU4ZDAyZGM0MQ==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2008-04-08T06:47:55Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-04-08T06:47:55Z"}, "message": "a-tags.adb (Register_Interface_Offset): New subprogram.\n\n2008-04-08  Javier Miranda  <miranda@adacore.com>\n\t    Robert Dewar  <dewar@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\n\t* a-tags.adb (Register_Interface_Offset): New subprogram.\n\t(Set_Dynamic_Offset_To_Top): New subprogram (see previous comment).\n\t(To_Predef_Prims_Table_Ptr): Removed.\n\t(Acc_Size): Removed.\n\t(To_Acc_Size): Removed.\n\t(Parent_Size): Modified to the call the subprogram returning the size of\n\tthe parent by means of the new TSD component Size_Func.\n\n\t* a-tags.ads (Offset_To_Top_Ptr): New access type declaration.\n\t(DT_Offset_To_Top_Offset): New constant value that is used to generate\n\tcode referencing the Offset_To_Top component of the dispatch table's\n\tprologue.\n\t(Prim_Ptr): New declaration of access to procedure. Used to avoid the\n\tuse of 'address to initialize dispatch table slots.\n\t(Size_Func): New component of the TSD. Used by the run-time to call the\n\tsize primitive of the tagged type.\n\n\t* checks.adb (Apply_Access_Check): Avoid check when accessing the\n\tOffset_To_Top component of a dispatch table.\n\t(Null_Exclusion_Static_Checks): If the non-null access type appears in a\n\tdeferred constant declaration. do not add a null expression, to prevent\n\tspurious errors when full declaration is analyzed.\n\t(Apply_Discriminant_Check): If both discriminant constraints share a\n\tnode which is not static but has no side effects, do not generate a\n\tcheck for that discriminant.\n\t(Generate_Index_Checks): Set Name_Req to true in call to duplicate\n\tsubexpr, since the prefix of an attribute is a name.\n\n\t* checks.ads: Fix nit in comment.\n\n\t* exp_ch3.ads, exp_ch3.adb (Freeze_Record_Type): Do not add the spec\n\tand body of predefined primitives in case of CPP tagged type\n\tderivations.\n\t(Freeze_Type): Deal properly with no storage pool case\n\t(Make_Predefined_Primitive_Specs): Generate specification of abstract\n\tprimitive Deep_Adjust if a nonlimited interface is derived from a\n\tlimited interface.\n\t(Build_Dcheck_Functions): Create discriminant-checking functions only\n\tfor variants that have some component(s).\n\t(Build_Slice_Assignment): In expanded code for slice assignment, handle\n\tproperly the case where the slice bounds extend to the last value of the\n\tunderlying representation.\n\t(Get_Simple_Init_Val): New calling sequence, accomodate Invalid_Value\n\t(Is_Variable_Size_Record): An array component has a static size if\n\tindex bounds are enumeration literals.\n\n\t* exp_disp.adb (Make_DT): Use the first subtype to determine whether\n\tan external tag has been specified for the type.\n\t(Building_Static_DT): Add missing support for private types.\n\t(Make_DT): Add declaration of Parent_Typ to ensure consistent access\n\tto the entity associated with the parent of Typ. This is done to\n\tavoid wrong access when the parent is a private type.\n\t(Expand_Interface_Conversion): Improve error message when the\n\tconfigurable runtime has no support for dynamic interface conversion.\n\t(Expand_Interface_Thunk): Add missing support to interface types in\n\tconfigurable runtime.\n\t(Expand_Dispatching_Call): remove obsolete code.\n\t(Make_DT): Replace occurrences of RE_Address by RE_Prim_Ptr, and\n\tensure that all subtypes and aggregates associated with dispatch\n\ttables have the attribute Is_Dispatch_Table_Entity set to true.\n\t(Register_Primitive): Rename one variable to improve code reading.\n\tReplace occurrences of RE_Addres by RE_Prim_Ptr. Register copy o\n\tof the pointer to the 'size primitive in the TSD.\n\n\t* rtsfind.ads (RE_DT_Offset_To_Top_Offset): New entity.\n\t(RE_Offset_To_Top_Ptr): New entity.\n\t(RE_Register_Interface_Offset): New entity.\n\t(RE_Set_Dynamic_Offset_To_Top): New entity.\n\t(RE_Set_Offset_To_Top): Removed entity.\n\t(RE_Prim_Ptr): New entity\n\t(RE_Size_Func): New entity\n\t(RE_Size_Ptr): New entity\n\t(RTU_Id): Add Ada_Dispatching and Ada_Dispatching_EDF.\n\t(Ada_Dispatching_Child): Define this new subrange.\n\t(RE_Id): Add new required run-time calls (RE_Set_Deadline, RE_Clock,\n\t RE_Time_Span, and RE_Time_Span_Zero).\n\t(RE_Unit_Table): Add new required run-time calls\n\n\t* rtsfind.adb (Get_Unit_Name): Add processing for Ada.Dispatching\n\tchildren.\n\n\t* exp_atag.ads, exp_atag.adb (Build_Offset_To_Top): New subprogram.\n\t(Build_Set_Static_Offset_To_Top): New subprogram. Generates code that\n\t initializes the Offset_To_Top component of a dispatch table.\n\t(Build_Predef_Prims): Removed.\n\t(Build_Get_Predefined_Prim_Op_Address): Replace call to Predef_Prims by\n\t its actual code.\n\t(Build_Set_Size_Function): New subprogram.\n\n\t* exp_ch13.adb: Do not generate storage variable for storage_size zero\n\t(Expand): Handle setting/restoring flag Inside_Freezing_Actions\n\nFrom-SVN: r134020", "tree": {"sha": "1de7681091aaa76f00129510f3d08256cfb44e88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1de7681091aaa76f00129510f3d08256cfb44e88"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2cbd970083b0c0af05fb2cfca08ad4e8d02dc41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2cbd970083b0c0af05fb2cfca08ad4e8d02dc41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2cbd970083b0c0af05fb2cfca08ad4e8d02dc41", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2cbd970083b0c0af05fb2cfca08ad4e8d02dc41/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "868e30a5665dd5726c2da528e0dff23c3b18f1a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/868e30a5665dd5726c2da528e0dff23c3b18f1a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/868e30a5665dd5726c2da528e0dff23c3b18f1a8"}], "stats": {"total": 1393, "additions": 938, "deletions": 455}, "files": [{"sha": "3f841c622f4c15174383b03e5410862b2509150d", "filename": "gcc/ada/a-tags.adb", "status": "modified", "additions": 67, "deletions": 84, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2cbd970083b0c0af05fb2cfca08ad4e8d02dc41/gcc%2Fada%2Fa-tags.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2cbd970083b0c0af05fb2cfca08ad4e8d02dc41/gcc%2Fada%2Fa-tags.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tags.adb?ref=f2cbd970083b0c0af05fb2cfca08ad4e8d02dc41", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -105,25 +105,12 @@ package body Ada.Tags is\n    function To_Object_Specific_Data_Ptr is\n      new Ada.Unchecked_Conversion (System.Address, Object_Specific_Data_Ptr);\n \n-   function To_Predef_Prims_Table_Ptr is\n-     new Ada.Unchecked_Conversion (System.Address, Predef_Prims_Table_Ptr);\n-\n    function To_Tag_Ptr is\n      new Ada.Unchecked_Conversion (System.Address, Tag_Ptr);\n \n    function To_Type_Specific_Data_Ptr is\n      new Ada.Unchecked_Conversion (System.Address, Type_Specific_Data_Ptr);\n \n-   ------------------------------------------------\n-   -- Unchecked Conversions for other components --\n-   ------------------------------------------------\n-\n-   type Acc_Size\n-     is access function (A : System.Address) return Long_Long_Integer;\n-\n-   function To_Acc_Size is new Unchecked_Conversion (System.Address, Acc_Size);\n-   --  The profile of the implicitly defined _size primitive\n-\n    -------------------------------\n    -- Inline_Always Subprograms --\n    -------------------------------\n@@ -733,7 +720,7 @@ package body Ada.Tags is\n \n    begin\n       Len := 1;\n-      while Str (Len) /= ASCII.Nul loop\n+      while Str (Len) /= ASCII.NUL loop\n          Len := Len + 1;\n       end loop;\n \n@@ -778,35 +765,23 @@ package body Ada.Tags is\n       --  The tag of the parent is always in the first slot of the table of\n       --  ancestor tags.\n \n-      Size_Slot : constant Positive := 1;\n-      --  The pointer to the _size primitive is always in the first slot of\n-      --  the dispatch table.\n-\n       TSD_Ptr : constant Addr_Ptr :=\n                   To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n       TSD     : constant Type_Specific_Data_Ptr :=\n                   To_Type_Specific_Data_Ptr (TSD_Ptr.all);\n       --  Pointer to the TSD\n \n-      Parent_Tag              : constant Tag := TSD.Tags_Table (Parent_Slot);\n-      Parent_Predef_Prims_Ptr : constant Addr_Ptr :=\n-                                  To_Addr_Ptr (To_Address (Parent_Tag)\n-                                                - DT_Predef_Prims_Offset);\n-      Parent_Predef_Prims     : constant Predef_Prims_Table_Ptr :=\n-                                  To_Predef_Prims_Table_Ptr\n-                                    (Parent_Predef_Prims_Ptr.all);\n-\n-      --  The tag of the parent type through the dispatch table and its\n-      --  Predef_Prims field.\n-\n-      F : constant Acc_Size :=\n-            To_Acc_Size (Parent_Predef_Prims (Size_Slot));\n-      --  Access to the _size primitive of the parent\n+      Parent_Tag     : constant Tag := TSD.Tags_Table (Parent_Slot);\n+      Parent_TSD_Ptr : constant Addr_Ptr :=\n+                         To_Addr_Ptr (To_Address (Parent_Tag)\n+                                       - DT_Typeinfo_Ptr_Size);\n+      Parent_TSD     : constant Type_Specific_Data_Ptr :=\n+                         To_Type_Specific_Data_Ptr (Parent_TSD_Ptr.all);\n \n    begin\n       --  Here we compute the size of the _parent field of the object\n \n-      return SSE.Storage_Count (F.all (Obj));\n+      return SSE.Storage_Count (Parent_TSD.Size_Func.all (Obj));\n    end Parent_Size;\n \n    ----------------\n@@ -837,6 +812,56 @@ package body Ada.Tags is\n       end if;\n    end Parent_Tag;\n \n+   -------------------------------\n+   -- Register_Interface_Offset --\n+   -------------------------------\n+\n+   procedure Register_Interface_Offset\n+     (This         : System.Address;\n+      Interface_T  : Tag;\n+      Is_Static    : Boolean;\n+      Offset_Value : SSE.Storage_Offset;\n+      Offset_Func  : Offset_To_Top_Function_Ptr)\n+   is\n+      Prim_DT     : Dispatch_Table_Ptr;\n+      Iface_Table : Interface_Data_Ptr;\n+\n+   begin\n+      --  \"This\" points to the primary DT and we must save Offset_Value in\n+      --  the Offset_To_Top field of the corresponding dispatch table.\n+\n+      Prim_DT     := DT (To_Tag_Ptr (This).all);\n+      Iface_Table := To_Type_Specific_Data_Ptr (Prim_DT.TSD).Interfaces_Table;\n+\n+      --  Save Offset_Value in the table of interfaces of the primary DT.\n+      --  This data will be used by the subprogram \"Displace\" to give support\n+      --  to backward abstract interface type conversions.\n+\n+      --  Register the offset in the table of interfaces\n+\n+      if Iface_Table /= null then\n+         for Id in 1 .. Iface_Table.Nb_Ifaces loop\n+            if Iface_Table.Ifaces_Table (Id).Iface_Tag = Interface_T then\n+               if Is_Static or else Offset_Value = 0 then\n+                  Iface_Table.Ifaces_Table (Id).Static_Offset_To_Top := True;\n+                  Iface_Table.Ifaces_Table (Id).Offset_To_Top_Value :=\n+                    Offset_Value;\n+               else\n+                  Iface_Table.Ifaces_Table (Id).Static_Offset_To_Top := False;\n+                  Iface_Table.Ifaces_Table (Id).Offset_To_Top_Func :=\n+                    Offset_Func;\n+               end if;\n+\n+               return;\n+            end if;\n+         end loop;\n+      end if;\n+\n+      --  If we arrive here there is some error in the run-time data structure\n+\n+      raise Program_Error;\n+   end Register_Interface_Offset;\n+\n    ------------------\n    -- Register_Tag --\n    ------------------\n@@ -892,68 +917,26 @@ package body Ada.Tags is\n    -- Set_Offset_To_Top --\n    -----------------------\n \n-   procedure Set_Offset_To_Top\n+   procedure Set_Dynamic_Offset_To_Top\n      (This         : System.Address;\n       Interface_T  : Tag;\n-      Is_Static    : Boolean;\n       Offset_Value : SSE.Storage_Offset;\n       Offset_Func  : Offset_To_Top_Function_Ptr)\n    is\n-      Prim_DT     : Dispatch_Table_Ptr;\n-      Sec_Base    : System.Address;\n-      Sec_DT      : Dispatch_Table_Ptr;\n-      Iface_Table : Interface_Data_Ptr;\n-\n+      Sec_Base : System.Address;\n+      Sec_DT   : Dispatch_Table_Ptr;\n    begin\n       --  Save the offset to top field in the secondary dispatch table\n \n       if Offset_Value /= 0 then\n          Sec_Base := This + Offset_Value;\n-         Sec_DT   := DT (To_Tag_Ptr (Sec_Base).all);\n-\n-         if Is_Static then\n-            Sec_DT.Offset_To_Top := Offset_Value;\n-         else\n-            Sec_DT.Offset_To_Top := SSE.Storage_Offset'Last;\n-         end if;\n+         Sec_DT := DT (To_Tag_Ptr (Sec_Base).all);\n+         Sec_DT.Offset_To_Top := SSE.Storage_Offset'Last;\n       end if;\n \n-      --  \"This\" points to the primary DT and we must save Offset_Value in\n-      --  the Offset_To_Top field of the corresponding secondary dispatch\n-      --  table.\n-\n-      Prim_DT     := DT (To_Tag_Ptr (This).all);\n-      Iface_Table := To_Type_Specific_Data_Ptr (Prim_DT.TSD).Interfaces_Table;\n-\n-      --  Save Offset_Value in the table of interfaces of the primary DT.\n-      --  This data will be used by the subprogram \"Displace\" to give support\n-      --  to backward abstract interface type conversions.\n-\n-      --  Register the offset in the table of interfaces\n-\n-      if Iface_Table /= null then\n-         for Id in 1 .. Iface_Table.Nb_Ifaces loop\n-            if Iface_Table.Ifaces_Table (Id).Iface_Tag = Interface_T then\n-               Iface_Table.Ifaces_Table (Id).Static_Offset_To_Top :=\n-                 Is_Static;\n-\n-               if Is_Static then\n-                  Iface_Table.Ifaces_Table (Id).Offset_To_Top_Value\n-                    := Offset_Value;\n-               else\n-                  Iface_Table.Ifaces_Table (Id).Offset_To_Top_Func\n-                    := Offset_Func;\n-               end if;\n-\n-               return;\n-            end if;\n-         end loop;\n-      end if;\n-\n-      --  If we arrive here there is some error in the run-time data structure\n-\n-      raise Program_Error;\n-   end Set_Offset_To_Top;\n+      Register_Interface_Offset\n+        (This, Interface_T, False, Offset_Value, Offset_Func);\n+   end Set_Dynamic_Offset_To_Top;\n \n    ----------------------\n    -- Set_Prim_Op_Kind --"}, {"sha": "5117eea9ad7e552353229cea9c213ab7f22c555a", "filename": "gcc/ada/a-tags.ads", "status": "modified", "additions": 52, "deletions": 17, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2cbd970083b0c0af05fb2cfca08ad4e8d02dc41/gcc%2Fada%2Fa-tags.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2cbd970083b0c0af05fb2cfca08ad4e8d02dc41/gcc%2Fada%2Fa-tags.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tags.ads?ref=f2cbd970083b0c0af05fb2cfca08ad4e8d02dc41", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -222,7 +222,8 @@ private\n    --  type. This construct is used in the handling of dispatching triggers\n    --  in select statements.\n \n-   type Address_Array is array (Positive range <>) of System.Address;\n+   type Prim_Ptr is access procedure;\n+   type Address_Array is array (Positive range <>) of Prim_Ptr;\n \n    subtype Dispatch_Table is Address_Array (1 .. 1);\n    --  Used by GDB to identify the _tags and traverse the run-time structure\n@@ -242,8 +243,14 @@ private\n    type Tag_Ptr is access all Tag;\n    pragma No_Strict_Aliasing (Tag_Ptr);\n \n+   type Offset_To_Top_Ptr is access all SSE.Storage_Offset;\n+   pragma No_Strict_Aliasing (Offset_To_Top_Ptr);\n+\n    type Tag_Table is array (Natural range <>) of Tag;\n \n+   type Size_Ptr is\n+     access function (A : System.Address) return Long_Long_Integer;\n+\n    type Type_Specific_Data (Idepth : Natural) is record\n    --  The discriminant Idepth is the Inheritance Depth Level: Used to\n    --  implement the membership test associated with single inheritance of\n@@ -279,6 +286,12 @@ private\n       --  Controller Offset: Used to give support to tagged controlled objects\n       --  (see Get_Deep_Controller at s-finimp)\n \n+      Size_Func : Size_Ptr;\n+      --  Pointer to the subprogram computing the _size of the object. Used by\n+      --  the run-time whenever a call to the 'size primitive is required. We\n+      --  cannot assume that the contents of dispatch tables are addresses\n+      --  because in some architectures the ABI allows descriptors.\n+\n       Interfaces_Table : Interface_Data_Ptr;\n       --  Pointer to the table of interface tags. It is used to implement the\n       --  membership test associated with interfaces and also for backward\n@@ -370,6 +383,10 @@ private\n \n    use type System.Storage_Elements.Storage_Offset;\n \n+   DT_Offset_To_Top_Offset : constant SSE.Storage_Count :=\n+                               DT_Typeinfo_Ptr_Size\n+                                 + DT_Offset_To_Top_Size;\n+\n    DT_Predef_Prims_Offset : constant SSE.Storage_Count :=\n                               DT_Typeinfo_Ptr_Size\n                                 + DT_Offset_To_Top_Size\n@@ -474,28 +491,44 @@ private\n    pragma Export (Ada, Parent_Size, \"ada__tags__parent_size\");\n    --  This procedure is used in s-finimp and is thus exported manually\n \n+   procedure Register_Interface_Offset\n+     (This         : System.Address;\n+      Interface_T  : Tag;\n+      Is_Static    : Boolean;\n+      Offset_Value : SSE.Storage_Offset;\n+      Offset_Func  : Offset_To_Top_Function_Ptr);\n+   --  Register in the table of interfaces of the tagged type associated with\n+   --  \"This\" object the offset of the record component associated with the\n+   --  progenitor Interface_T (that is, the distance from \"This\" to the object\n+   --  component containing the tag of the secondary dispatch table). In case\n+   --  of constant offset, Is_Static is true and Offset_Value has such value.\n+   --  In case of variable offset, Is_Static is false and Offset_Func is an\n+   --  access to function that must be called to evaluate the offset.\n+\n    procedure Register_Tag (T : Tag);\n    --  Insert the Tag and its associated external_tag in a table for the\n    --  sake of Internal_Tag\n \n-   procedure Set_Entry_Index (T : Tag; Position : Positive; Value : Positive);\n-   --  Ada 2005 (AI-345): Set the entry index of a primitive operation in T's\n-   --  TSD table indexed by Position.\n-\n-   procedure Set_Offset_To_Top\n+   procedure Set_Dynamic_Offset_To_Top\n      (This         : System.Address;\n       Interface_T  : Tag;\n-      Is_Static    : Boolean;\n       Offset_Value : SSE.Storage_Offset;\n       Offset_Func  : Offset_To_Top_Function_Ptr);\n-   --  Ada 2005 (AI-251): Initialize the Offset_To_Top field in the prologue of\n-   --  the dispatch table. In primary dispatch tables the value of \"This\" is\n-   --  not required (and the compiler passes always the Null_Address value) and\n-   --  the Offset_Value is always cero; in secondary dispatch tables \"This\"\n-   --  points to the object, Interface_T is the interface for which the\n-   --  secondary dispatch table is being initialized, and Offset_Value is the\n-   --  distance from \"This\" to the object component containing the tag of the\n-   --  secondary dispatch table.\n+   --  Ada 2005 (AI-251): The compiler generates calls to this routine only\n+   --  when initializing the Offset_To_Top field of dispatch tables associated\n+   --  with tagged type whose parent has variable size components. \"This\" is\n+   --  the object whose dispatch table is being initialized. Interface_T is the\n+   --  interface for which the secondary dispatch table is being initialized,\n+   --  and Offset_Value is the distance from \"This\" to the object component\n+   --  containing the tag of the secondary dispatch table (a zero value means\n+   --  that this interface shares the primary dispatch table). Offset_Func\n+   --  references a function that must be called to evaluate the offset at\n+   --  runtime. This routine also takes care of registering these values in\n+   --  the table of interfaces of the type.\n+\n+   procedure Set_Entry_Index (T : Tag; Position : Positive; Value : Positive);\n+   --  Ada 2005 (AI-345): Set the entry index of a primitive operation in T's\n+   --  TSD table indexed by Position.\n \n    procedure Set_Prim_Op_Kind\n      (T        : Tag;\n@@ -532,5 +565,7 @@ private\n \n    type Addr_Ptr is access System.Address;\n    pragma No_Strict_Aliasing (Addr_Ptr);\n-   --  Why is this needed ???\n+   --  This type is used by the frontend to generate the code that handles\n+   --  dispatch table slots of types declared at the local level.\n+\n end Ada.Tags;"}, {"sha": "1dfd0de991453d996efc13abc2c439de6dee3042", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 42, "deletions": 21, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2cbd970083b0c0af05fb2cfca08ad4e8d02dc41/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2cbd970083b0c0af05fb2cfca08ad4e8d02dc41/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=f2cbd970083b0c0af05fb2cfca08ad4e8d02dc41", "patch": "@@ -450,6 +450,17 @@ package body Checks is\n          return;\n       end if;\n \n+      --  No check if accessing the Offset_To_Top component of a dispatch\n+      --  table. They are safe by construction.\n+\n+      if Present (Etype (P))\n+        and then RTU_Loaded (Ada_Tags)\n+        and then RTE_Available (RE_Offset_To_Top_Ptr)\n+        and then Etype (P) = RTE (RE_Offset_To_Top_Ptr)\n+      then\n+         return;\n+      end if;\n+\n       --  Otherwise go ahead and install the check\n \n       Install_Null_Excluding_Check (P);\n@@ -1239,12 +1250,23 @@ package body Checks is\n                   return;\n                end if;\n \n-               exit when\n-                 not Is_OK_Static_Expression (ItemS)\n-                   or else\n-                 not Is_OK_Static_Expression (ItemT);\n+               --  If the expressions for the discriminants are identical\n+               --  and it is side-effect free (for now just an entity),\n+               --  this may be a shared constraint, e.g. from a subtype\n+               --  without a constraint introduced as a generic actual.\n+               --  Examine other discriminants if any.\n+\n+               if ItemS = ItemT\n+                 and then Is_Entity_Name (ItemS)\n+               then\n+                  null;\n+\n+               elsif not Is_OK_Static_Expression (ItemS)\n+                 or else not Is_OK_Static_Expression (ItemT)\n+               then\n+                  exit;\n \n-               if Expr_Value (ItemS) /= Expr_Value (ItemT) then\n+               elsif Expr_Value (ItemS) /= Expr_Value (ItemT) then\n                   if Do_Access then   --  needs run-time check.\n                      exit;\n                   else\n@@ -2723,10 +2745,13 @@ package body Checks is\n          end if;\n       end if;\n \n-      --  Check that null-excluding objects are always initialized\n+      --  Check that null-excluding objects are always initialized, except for\n+      --  deferred constants, for which the expression will appear in the full\n+      --  declaration.\n \n       if K = N_Object_Declaration\n         and then No (Expression (N))\n+        and then not Constant_Present (N)\n         and then not No_Initialization (N)\n       then\n          --  Add an expression that assigns null. This node is needed by\n@@ -2742,9 +2767,9 @@ package body Checks is\n             Reason => CE_Null_Not_Allowed);\n       end if;\n \n-      --  Check that a null-excluding component, formal or object is not\n-      --  being assigned a null value. Otherwise generate a warning message\n-      --  and replace Expression (N) by a N_Constraint_Error node.\n+      --  Check that a null-excluding component, formal or object is not being\n+      --  assigned a null value. Otherwise generate a warning message and\n+      --  replace Expression (N) by an N_Contraint_Error node.\n \n       if K /= N_Function_Specification then\n          Expr := Expression (N);\n@@ -3368,14 +3393,14 @@ package body Checks is\n       --  Nothing to do if the range of the result is known OK. We skip this\n       --  for conversions, since the caller already did the check, and in any\n       --  case the condition for deleting the check for a type conversion is\n-      --  different in any case.\n+      --  different.\n \n       if Nkind (N) /= N_Type_Conversion then\n          Determine_Range (N, OK, Lo, Hi);\n \n-         --  Note in the test below that we assume that if a bound of the\n-         --  range is equal to that of the type. That's not quite accurate\n-         --  but we do this for the following reasons:\n+         --  Note in the test below that we assume that the range is not OK\n+         --  if a bound of the range is equal to that of the type. That's not\n+         --  quite accurate but we do this for the following reasons:\n \n          --   a) The way that Determine_Range works, it will typically report\n          --      the bounds of the value as being equal to the bounds of the\n@@ -3385,7 +3410,7 @@ package body Checks is\n          --   b) It is very unusual to have a situation in which this would\n          --      generate an unnecessary overflow check (an example would be\n          --      a subtype with a range 0 .. Integer'Last - 1 to which the\n-         --      literal value one is added.\n+         --      literal value one is added).\n \n          --   c) The alternative is a lot of special casing in this routine\n          --      which would partially duplicate Determine_Range processing.\n@@ -4121,12 +4146,7 @@ package body Checks is\n       --  appropriate one for our purposes.\n \n       if (Ekind (Ent) = E_Variable\n-            or else\n-          Ekind (Ent) = E_Constant\n-            or else\n-          Ekind (Ent) = E_Loop_Parameter\n-            or else\n-          Ekind (Ent) = E_In_Parameter)\n+            or else Is_Constant_Object (Ent))\n         and then not Is_Library_Level_Entity (Ent)\n       then\n          Entry_OK := True;\n@@ -4371,7 +4391,8 @@ package body Checks is\n                         Duplicate_Subexpr_Move_Checks (Sub)),\n                     Right_Opnd =>\n                       Make_Attribute_Reference (Loc,\n-                        Prefix         => Duplicate_Subexpr_Move_Checks (A),\n+                        Prefix         =>\n+                          Duplicate_Subexpr_Move_Checks (A, Name_Req => True),\n                         Attribute_Name => Name_Range,\n                         Expressions    => Num)),\n                 Reason => CE_Index_Check_Failed));"}, {"sha": "0c9049471b40ac14303ab62f646c3c5ce8c02918", "filename": "gcc/ada/checks.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2cbd970083b0c0af05fb2cfca08ad4e8d02dc41/gcc%2Fada%2Fchecks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2cbd970083b0c0af05fb2cfca08ad4e8d02dc41/gcc%2Fada%2Fchecks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.ads?ref=f2cbd970083b0c0af05fb2cfca08ad4e8d02dc41", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -211,7 +211,7 @@ package Checks is\n    --  by the back end, but many are done by the front end.\n \n    --  Overflow checks are similarly controlled by the Do_Overflow_Check flag.\n-   --  The difference here is that if Backend_Overflow_Checks is is\n+   --  The difference here is that if back end overflow checks are inactive\n    --  (Backend_Overflow_Checks_On_Target set False), then the actual overflow\n    --  checks are generated by the front end, but if back end overflow checks\n    --  are active (Backend_Overflow_Checks_On_Target set True), then the back"}, {"sha": "318614e598f9446b63a80d05a0b7e79bf8ad6168", "filename": "gcc/ada/exp_atag.adb", "status": "modified", "additions": 108, "deletions": 36, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2cbd970083b0c0af05fb2cfca08ad4e8d02dc41/gcc%2Fada%2Fexp_atag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2cbd970083b0c0af05fb2cfca08ad4e8d02dc41/gcc%2Fada%2Fexp_atag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_atag.adb?ref=f2cbd970083b0c0af05fb2cfca08ad4e8d02dc41", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2006-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2006-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -26,9 +26,11 @@\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Exp_Util; use Exp_Util;\n+with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Rtsfind;  use Rtsfind;\n+with Sinfo;    use Sinfo;\n with Sem_Util; use Sem_Util;\n with Stand;    use Stand;\n with Snames;   use Snames;\n@@ -57,15 +59,6 @@ package body Exp_Atag is\n    --  Generate: To_Type_Specific_Data_Ptr\n    --              (To_Addr_Ptr (To_Address (Tag) - Typeinfo_Offset).all);\n \n-   function Build_Predef_Prims\n-     (Loc      : Source_Ptr;\n-      Tag_Node : Node_Id) return Node_Id;\n-   --  Build code that retrieves the address of the dispatch table containing\n-   --  the predefined Ada primitives:\n-   --\n-   --  Generate: To_Predef_Prims_Table_Ptr\n-   --              (To_Addr_Ptr (To_Address (Tag) - Predef_Prims_Offset).all);\n-\n    ------------------------------------------------\n    -- Build_Common_Dispatching_Select_Statements --\n    ------------------------------------------------\n@@ -239,10 +232,33 @@ package body Exp_Atag is\n       Position : Uint) return Node_Id\n    is\n    begin\n+      --  Build code that retrieves the address of the dispatch table\n+      --  containing the predefined Ada primitives:\n+      --\n+      --  Generate:\n+      --    To_Predef_Prims_Table_Ptr\n+      --     (To_Addr_Ptr (To_Address (Tag) - Predef_Prims_Offset).all);\n+\n       return\n         Make_Indexed_Component (Loc,\n           Prefix =>\n-            Build_Predef_Prims (Loc, Tag_Node),\n+            Unchecked_Convert_To (RTE (RE_Predef_Prims_Table_Ptr),\n+              Make_Explicit_Dereference (Loc,\n+                Unchecked_Convert_To (RTE (RE_Addr_Ptr),\n+                  Make_Function_Call (Loc,\n+                    Name =>\n+                      Make_Expanded_Name (Loc,\n+                        Chars => Name_Op_Subtract,\n+                        Prefix =>\n+                          New_Reference_To\n+                            (RTU_Entity (System_Storage_Elements), Loc),\n+                        Selector_Name =>\n+                          Make_Identifier (Loc,\n+                            Chars => Name_Op_Subtract)),\n+                    Parameter_Associations => New_List (\n+                      Unchecked_Convert_To (RTE (RE_Address), Tag_Node),\n+                      New_Reference_To (RTE (RE_DT_Predef_Prims_Offset),\n+                                        Loc)))))),\n           Expressions =>\n             New_List (Make_Integer_Literal (Loc, Position)));\n    end Build_Get_Predefined_Prim_Op_Address;\n@@ -397,35 +413,37 @@ package body Exp_Atag is\n                   New_Reference_To (RTE (RE_Max_Predef_Prims), Loc))));\n    end Build_Inherit_Predefined_Prims;\n \n-   ------------------------\n-   -- Build_Predef_Prims --\n-   ------------------------\n+   -------------------------\n+   -- Build_Offset_To_Top --\n+   -------------------------\n \n-   function Build_Predef_Prims\n-     (Loc      : Source_Ptr;\n-      Tag_Node : Node_Id) return Node_Id\n+   function Build_Offset_To_Top\n+     (Loc       : Source_Ptr;\n+      This_Node : Node_Id) return Node_Id\n    is\n+      Tag_Node : Node_Id;\n+\n    begin\n-      return\n-        Unchecked_Convert_To (RTE (RE_Predef_Prims_Table_Ptr),\n-          Make_Explicit_Dereference (Loc,\n-            Unchecked_Convert_To (RTE (RE_Addr_Ptr),\n-              Make_Function_Call (Loc,\n-                Name =>\n-                  Make_Expanded_Name (Loc,\n-                    Chars => Name_Op_Subtract,\n-                    Prefix =>\n-                      New_Reference_To\n-                        (RTU_Entity (System_Storage_Elements), Loc),\n-                    Selector_Name =>\n-                      Make_Identifier (Loc,\n-                        Chars => Name_Op_Subtract)),\n+      Tag_Node :=\n+        Make_Explicit_Dereference (Loc,\n+          Unchecked_Convert_To (RTE (RE_Tag_Ptr), This_Node));\n \n-                Parameter_Associations => New_List (\n-                  Unchecked_Convert_To (RTE (RE_Address), Tag_Node),\n-                  New_Reference_To (RTE (RE_DT_Predef_Prims_Offset),\n-                                    Loc))))));\n-   end Build_Predef_Prims;\n+      return\n+        Make_Explicit_Dereference (Loc,\n+          Unchecked_Convert_To (RTE (RE_Offset_To_Top_Ptr),\n+            Make_Function_Call (Loc,\n+              Name =>\n+                Make_Expanded_Name (Loc,\n+                  Chars => Name_Op_Subtract,\n+                  Prefix => New_Reference_To\n+                             (RTU_Entity (System_Storage_Elements), Loc),\n+                  Selector_Name => Make_Identifier (Loc,\n+                                     Chars => Name_Op_Subtract)),\n+              Parameter_Associations => New_List (\n+                Unchecked_Convert_To (RTE (RE_Address), Tag_Node),\n+                New_Reference_To (RTE (RE_DT_Offset_To_Top_Offset),\n+                                  Loc)))));\n+   end Build_Offset_To_Top;\n \n    ------------------------------------------\n    -- Build_Set_Predefined_Prim_Op_Address --\n@@ -471,6 +489,60 @@ package body Exp_Atag is\n           Expression => Address_Node);\n    end Build_Set_Prim_Op_Address;\n \n+   -----------------------------\n+   -- Build_Set_Size_Function --\n+   -----------------------------\n+\n+   function Build_Set_Size_Function\n+     (Loc       : Source_Ptr;\n+      Tag_Node  : Node_Id;\n+      Size_Func : Entity_Id) return Node_Id is\n+   begin\n+      pragma Assert (Chars (Size_Func) = Name_uSize\n+        and then RTE_Record_Component_Available (RE_Size_Func));\n+      return\n+        Make_Assignment_Statement (Loc,\n+          Name =>\n+            Make_Selected_Component (Loc,\n+              Prefix => Build_TSD (Loc, Tag_Node),\n+              Selector_Name =>\n+                New_Reference_To\n+                  (RTE_Record_Component (RE_Size_Func), Loc)),\n+          Expression =>\n+            Unchecked_Convert_To (RTE (RE_Size_Ptr),\n+              Make_Attribute_Reference (Loc,\n+                Prefix => New_Reference_To (Size_Func, Loc),\n+                Attribute_Name => Name_Unrestricted_Access)));\n+   end Build_Set_Size_Function;\n+\n+   ------------------------------------\n+   -- Build_Set_Static_Offset_To_Top --\n+   ------------------------------------\n+\n+   function Build_Set_Static_Offset_To_Top\n+     (Loc          : Source_Ptr;\n+      Iface_Tag    : Node_Id;\n+      Offset_Value : Node_Id) return Node_Id is\n+   begin\n+      return\n+        Make_Assignment_Statement (Loc,\n+          Make_Explicit_Dereference (Loc,\n+            Unchecked_Convert_To (RTE (RE_Offset_To_Top_Ptr),\n+              Make_Function_Call (Loc,\n+                Name =>\n+                  Make_Expanded_Name (Loc,\n+                    Chars => Name_Op_Subtract,\n+                    Prefix => New_Reference_To\n+                               (RTU_Entity (System_Storage_Elements), Loc),\n+                    Selector_Name => Make_Identifier (Loc,\n+                                       Chars => Name_Op_Subtract)),\n+                Parameter_Associations => New_List (\n+                  Unchecked_Convert_To (RTE (RE_Address), Iface_Tag),\n+                  New_Reference_To (RTE (RE_DT_Offset_To_Top_Offset),\n+                                    Loc))))),\n+          Offset_Value);\n+   end Build_Set_Static_Offset_To_Top;\n+\n    ---------------\n    -- Build_TSD --\n    ---------------"}, {"sha": "2ac42a9d2547da5d34333ee024c348a596ab24a8", "filename": "gcc/ada/exp_atag.ads", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2cbd970083b0c0af05fb2cfca08ad4e8d02dc41/gcc%2Fada%2Fexp_atag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2cbd970083b0c0af05fb2cfca08ad4e8d02dc41/gcc%2Fada%2Fexp_atag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_atag.ads?ref=f2cbd970083b0c0af05fb2cfca08ad4e8d02dc41", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2006-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2006-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -117,6 +117,19 @@ package Exp_Atag is\n    --    New_Tag.Prims_Ptr (1 .. Num_Prims) :=\n    --      Old_Tag.Prims_Ptr (1 .. Num_Prims);\n \n+   function Build_Offset_To_Top\n+     (Loc       : Source_Ptr;\n+      This_Node : Node_Id) return Node_Id;\n+   --  Build code that references the Offset_To_Top component of the primary\n+   --  or secondary dispatch table associated with This_Node. This subprogram\n+   --  provides a subset of the functionality provided by the function\n+   --  Offset_To_Top of package Ada.Tags, and is only called by the frontend\n+   --  when such routine is not available in a configurable runtime.\n+   --\n+   --  Generates:\n+   --    Offset_To_Top_Ptr\n+   --      (Address!(Tag_Ptr!(This).all) - Offset_To_Top_Offset)\n+\n    function Build_Set_Predefined_Prim_Op_Address\n      (Loc          : Source_Ptr;\n       Tag_Node     : Node_Id;\n@@ -145,4 +158,23 @@ package Exp_Atag is\n    --\n    --  Generates: Tag.D (Position) := Value\n \n+   function Build_Set_Size_Function\n+     (Loc       : Source_Ptr;\n+      Tag_Node  : Node_Id;\n+      Size_Func : Entity_Id) return Node_Id;\n+   --  Build code that saves in the TSD the address of the function\n+   --  calculating _size of the object.\n+\n+   function Build_Set_Static_Offset_To_Top\n+     (Loc          : Source_Ptr;\n+      Iface_Tag    : Node_Id;\n+      Offset_Value : Node_Id) return Node_Id;\n+   --  Build code that initialize the Offset_To_Top component of the\n+   --  secondary dispatch table referenced by Iface_Tag.\n+   --\n+   --  Generates:\n+   --    Offset_To_Top_Ptr\n+   --      (Address!(Tag_Ptr!(This).all) - Offset_To_Top_Offset).all\n+   --     := Offset_Value\n+\n end Exp_Atag;"}, {"sha": "3ba47ec444666761f7c61a380a800ae2cae96bd5", "filename": "gcc/ada/exp_ch13.adb", "status": "modified", "additions": 34, "deletions": 13, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2cbd970083b0c0af05fb2cfca08ad4e8d02dc41/gcc%2Fada%2Fexp_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2cbd970083b0c0af05fb2cfca08ad4e8d02dc41/gcc%2Fada%2Fexp_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch13.adb?ref=f2cbd970083b0c0af05fb2cfca08ad4e8d02dc41", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -145,21 +145,29 @@ package body Exp_Ch13 is\n \n             --  For Storage_Size for an access type, create a variable to hold\n             --  the value of the specified size with name typeV and expand an\n-            --  assignment statement to initialze this value.\n+            --  assignment statement to initialize this value.\n \n             elsif Is_Access_Type (Ent) then\n-               V := Make_Defining_Identifier (Loc,\n-                      New_External_Name (Chars (Ent), 'V'));\n \n-               Insert_Action (N,\n-                 Make_Object_Declaration (Loc,\n-                   Defining_Identifier => V,\n-                   Object_Definition  =>\n-                     New_Reference_To (RTE (RE_Storage_Offset), Loc),\n-                   Expression =>\n-                     Convert_To (RTE (RE_Storage_Offset), Expression (N))));\n+               --  We don't need the variable for a storage size of zero\n+\n+               if not No_Pool_Assigned (Ent) then\n+                  V :=\n+                    Make_Defining_Identifier (Loc,\n+                      Chars => New_External_Name (Chars (Ent), 'V'));\n \n-               Set_Storage_Size_Variable (Ent, Entity_Id (V));\n+                  --  Insert the declaration of the object\n+\n+                  Insert_Action (N,\n+                    Make_Object_Declaration (Loc,\n+                      Defining_Identifier => V,\n+                      Object_Definition  =>\n+                        New_Reference_To (RTE (RE_Storage_Offset), Loc),\n+                      Expression =>\n+                        Convert_To (RTE (RE_Storage_Offset), Expression (N))));\n+\n+                  Set_Storage_Size_Variable (Ent, Entity_Id (V));\n+               end if;\n             end if;\n \n          --  Other attributes require no expansion\n@@ -207,6 +215,15 @@ package body Exp_Ch13 is\n          return;\n       end if;\n \n+      --  Remember that we are processing a freezing entity and its freezing\n+      --  nodes. This flag (non-zero = set) is used to avoid the need of\n+      --  climbing through the tree while processing the freezing actions (ie.\n+      --  to avoid generating spurious warnings or to avoid killing constant\n+      --  indications while processing the code associated with freezing\n+      --  actions). We use a counter to deal with nesting.\n+\n+      Inside_Freezing_Actions := Inside_Freezing_Actions + 1;\n+\n       --  If we are freezing entities defined in protected types, they belong\n       --  in the enclosing scope, given that the original type has been\n       --  expanded away. The same is true for entities in task types, in\n@@ -224,7 +241,6 @@ package body Exp_Ch13 is\n \n       elsif Ekind (E_Scope) = E_Subprogram_Body then\n          E_Scope := Corresponding_Spec (Unit_Declaration_Node (E_Scope));\n-\n       end if;\n \n       S := Current_Scope;\n@@ -339,6 +355,11 @@ package body Exp_Ch13 is\n       elsif In_Outer_Scope then\n          Pop_Scope;\n       end if;\n+\n+      --  Restore previous value of the nesting-level counter that records\n+      --  whether we are inside a (possibly nested) call to this procedure.\n+\n+      Inside_Freezing_Actions := Inside_Freezing_Actions - 1;\n    end Expand_N_Freeze_Entity;\n \n    -------------------------------------------"}, {"sha": "3ec27893af086419cf6d7978a21145c128ead4da", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 203, "deletions": 116, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2cbd970083b0c0af05fb2cfca08ad4e8d02dc41/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2cbd970083b0c0af05fb2cfca08ad4e8d02dc41/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=f2cbd970083b0c0af05fb2cfca08ad4e8d02dc41", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -570,7 +570,7 @@ package body Exp_Ch3 is\n                 Name => Comp,\n                 Expression =>\n                   Get_Simple_Init_Val\n-                    (Comp_Type, Loc, Component_Size (A_Type))));\n+                    (Comp_Type, Nod, Component_Size (A_Type))));\n \n          else\n             Clean_Task_Names (Comp_Type, Proc_Id);\n@@ -680,7 +680,18 @@ package body Exp_Ch3 is\n                    and then Root_Type (A_Type) /= Standard_Wide_Wide_String)\n       then\n          Proc_Id :=\n-           Make_Defining_Identifier (Loc, Make_Init_Proc_Name (A_Type));\n+           Make_Defining_Identifier (Loc,\n+             Chars => Make_Init_Proc_Name (A_Type));\n+\n+         --  If No_Default_Initialization restriction is active, then we don't\n+         --  want to build an init_proc, but we need to mark that an init_proc\n+         --  would be needed if this restriction was not active (so that we can\n+         --  detect attempts to call it), so set a dummy init_proc in place.\n+\n+         if Restriction_Active (No_Default_Initialization) then\n+            Set_Init_Proc (A_Type, Proc_Id);\n+            return;\n+         end if;\n \n          Body_Stmts := Init_One_Dimension (1);\n \n@@ -1018,15 +1029,17 @@ package body Exp_Ch3 is\n       begin\n          --  Build the discriminant checking function for each variant, label\n          --  all components of that variant with the function's name.\n+         --  We only Generate a discriminant-checking function only if the\n+         --  variant is not empty, to prevent the creation of dead code.\n \n          Discr_Name := Entity (Name (Variant_Part_Node));\n          Variant := First_Non_Pragma (Variants (Variant_Part_Node));\n \n          while Present (Variant) loop\n-            Func_Id := Build_Dcheck_Function (Discr_Name, Variant);\n             Component_List_Node := Component_List (Variant);\n \n             if not Null_Present (Component_List_Node) then\n+               Func_Id := Build_Dcheck_Function (Discr_Name, Variant);\n                Decl :=\n                  First_Non_Pragma (Component_Items (Component_List_Node));\n \n@@ -2172,10 +2185,6 @@ package body Exp_Ch3 is\n       begin\n          Body_Stmts := New_List;\n          Body_Node := New_Node (N_Subprogram_Body, Loc);\n-\n-         Proc_Id :=\n-           Make_Defining_Identifier (Loc,\n-             Chars => Make_Init_Proc_Name (Rec_Type));\n          Set_Ekind (Proc_Id, E_Procedure);\n \n          Proc_Spec_Node := New_Node (N_Procedure_Specification, Loc);\n@@ -2567,7 +2576,7 @@ package body Exp_Ch3 is\n                elsif Component_Needs_Simple_Initialization (Typ) then\n                   Stmts :=\n                     Build_Assignment\n-                      (Id, Get_Simple_Init_Val (Typ, Loc, Esize (Id)));\n+                      (Id, Get_Simple_Init_Val (Typ, N, Esize (Id)));\n \n                --  Nothing needed for this case\n \n@@ -2635,7 +2644,7 @@ package body Exp_Ch3 is\n                   elsif Component_Needs_Simple_Initialization (Typ) then\n                      Append_List_To (Statement_List,\n                        Build_Assignment\n-                         (Id, Get_Simple_Init_Val (Typ, Loc, Esize (Id))));\n+                         (Id, Get_Simple_Init_Val (Typ, N, Esize (Id))));\n                   end if;\n                end if;\n \n@@ -3003,7 +3012,6 @@ package body Exp_Ch3 is\n          end if;\n \n          Id := First_Component (Rec_Id);\n-\n          while Present (Id) loop\n             Comp_Decl := Parent (Id);\n             Typ := Etype (Id);\n@@ -3024,6 +3032,8 @@ package body Exp_Ch3 is\n    --  Start of processing for Build_Record_Init_Proc\n \n    begin\n+      --  Check for value type, which means no initialization required\n+\n       Rec_Type := Defining_Identifier (N);\n \n       if Is_Value_Type (Rec_Type) then\n@@ -3080,6 +3090,20 @@ package body Exp_Ch3 is\n       elsif Requires_Init_Proc (Rec_Type)\n         or else Is_Unchecked_Union (Rec_Type)\n       then\n+         Proc_Id :=\n+           Make_Defining_Identifier (Loc,\n+             Chars => Make_Init_Proc_Name (Rec_Type));\n+\n+         --  If No_Default_Initialization restriction is active, then we don't\n+         --  want to build an init_proc, but we need to mark that an init_proc\n+         --  would be needed if this restriction was not active (so that we can\n+         --  detect attempts to call it), so set a dummy init_proc in place.\n+\n+         if Restriction_Active (No_Default_Initialization) then\n+            Set_Init_Proc (Rec_Type, Proc_Id);\n+            return;\n+         end if;\n+\n          Build_Offset_To_Top_Functions;\n          Build_Init_Procedure;\n          Set_Is_Public (Proc_Id, Is_Public (Pe));\n@@ -3121,13 +3145,12 @@ package body Exp_Ch3 is\n             procedure Collect_Itypes (Comp : Node_Id) is\n                Ref      : Node_Id;\n                Sub_Aggr : Node_Id;\n-               Typ      : Entity_Id;\n+               Typ      : constant Entity_Id := Etype (Comp);\n \n             begin\n-               if Is_Array_Type (Etype (Comp))\n-                 and then Is_Itype (Etype (Comp))\n+               if Is_Array_Type (Typ)\n+                 and then Is_Itype (Typ)\n                then\n-                  Typ := Etype (Comp);\n                   Ref := Make_Itype_Reference (Loc);\n                   Set_Itype (Ref, Typ);\n                   Append_Freeze_Action (Rec_Type, Ref);\n@@ -3189,6 +3212,11 @@ package body Exp_Ch3 is\n    --       Ri1 : Index;\n \n    --    begin\n+\n+   --       if Left_Hi < Left_Lo then\n+   --          return;\n+   --       end if;\n+\n    --       if Rev  then\n    --          Li1 := Left_Hi;\n    --          Ri1 := Right_Hi;\n@@ -3198,18 +3226,14 @@ package body Exp_Ch3 is\n    --       end if;\n \n    --       loop\n-   --          if Rev then\n-   --             exit when Li1 < Left_Lo;\n-   --          else\n-   --             exit when Li1 > Left_Hi;\n-   --          end if;\n-\n    --          Target (Li1) := Source (Ri1);\n \n    --          if Rev then\n+   --             exit when Li1 = Left_Lo;\n    --             Li1 := Index'pred (Li1);\n    --             Ri1 := Index'pred (Ri1);\n    --          else\n+   --             exit when Li1 = Left_Hi;\n    --             Li1 := Index'succ (Li1);\n    --             Ri1 := Index'succ (Ri1);\n    --          end if;\n@@ -3276,6 +3300,16 @@ package body Exp_Ch3 is\n \n       Stats := New_List;\n \n+      --  Build test for empty slice case\n+\n+      Append_To (Stats,\n+        Make_If_Statement (Loc,\n+          Condition =>\n+             Make_Op_Lt (Loc,\n+               Left_Opnd  => New_Occurrence_Of (Left_Hi, Loc),\n+               Right_Opnd => New_Occurrence_Of (Left_Lo, Loc)),\n+          Then_Statements => New_List (Make_Simple_Return_Statement (Loc))));\n+\n       --  Build initializations for indices\n \n       declare\n@@ -3326,7 +3360,7 @@ package body Exp_Ch3 is\n                   Expressions => New_List (New_Occurrence_Of (Rnn, Loc))))),\n           End_Label  => Empty);\n \n-      --  Build exit condition\n+      --  Build the exit condition and increment/decrement statements\n \n       declare\n          F_Ass : constant List_Id := New_List;\n@@ -3336,31 +3370,10 @@ package body Exp_Ch3 is\n          Append_To (F_Ass,\n            Make_Exit_Statement (Loc,\n              Condition =>\n-               Make_Op_Gt (Loc,\n+               Make_Op_Eq (Loc,\n                  Left_Opnd  => New_Occurrence_Of (Lnn, Loc),\n                  Right_Opnd => New_Occurrence_Of (Left_Hi, Loc))));\n \n-         Append_To (B_Ass,\n-           Make_Exit_Statement (Loc,\n-             Condition =>\n-               Make_Op_Lt (Loc,\n-                 Left_Opnd  => New_Occurrence_Of (Lnn, Loc),\n-                 Right_Opnd => New_Occurrence_Of (Left_Lo, Loc))));\n-\n-         Prepend_To (Statements (Loops),\n-           Make_If_Statement (Loc,\n-             Condition       => New_Occurrence_Of (Rev, Loc),\n-             Then_Statements => B_Ass,\n-             Else_Statements => F_Ass));\n-      end;\n-\n-      --  Build the increment/decrement statements\n-\n-      declare\n-         F_Ass : constant List_Id := New_List;\n-         B_Ass : constant List_Id := New_List;\n-\n-      begin\n          Append_To (F_Ass,\n            Make_Assignment_Statement (Loc,\n              Name => New_Occurrence_Of (Lnn, Loc),\n@@ -3383,6 +3396,13 @@ package body Exp_Ch3 is\n                  Expressions => New_List (\n                    New_Occurrence_Of (Rnn, Loc)))));\n \n+         Append_To (B_Ass,\n+           Make_Exit_Statement (Loc,\n+             Condition =>\n+               Make_Op_Eq (Loc,\n+                 Left_Opnd  => New_Occurrence_Of (Lnn, Loc),\n+                 Right_Opnd => New_Occurrence_Of (Left_Lo, Loc))));\n+\n          Append_To (B_Ass,\n            Make_Assignment_Statement (Loc,\n              Name => New_Occurrence_Of (Lnn, Loc),\n@@ -4220,6 +4240,12 @@ package body Exp_Ch3 is\n \n             and then not Suppress_Init_Proc (Typ)\n          then\n+            Check_Restriction (No_Default_Initialization, N);\n+\n+            if Restriction_Active (No_Default_Initialization) then\n+               return;\n+            end if;\n+\n             --  The call to the initialization procedure does NOT freeze the\n             --  object being initialized. This is because the call is not a\n             --  source level call. This works fine, because the only possible\n@@ -4260,8 +4286,9 @@ package body Exp_Ch3 is\n            and then not Is_Internal (Def_Id)\n            and then not Has_Init_Expression (N)\n          then\n+            Check_Restriction (No_Default_Initialization, N);\n             Set_No_Initialization (N, False);\n-            Set_Expression (N, Get_Simple_Init_Val (Typ, Loc, Esize (Def_Id)));\n+            Set_Expression (N, Get_Simple_Init_Val (Typ, N, Esize (Def_Id)));\n             Analyze_And_Resolve (Expression (N), Typ);\n          end if;\n \n@@ -5437,10 +5464,18 @@ package body Exp_Ch3 is\n \n             Set_Is_Frozen (Def_Id, False);\n \n+            --  Do not add the spec of predefined primitives in case of\n+            --  CPP tagged type derivations that have convention CPP.\n+\n+            if Is_CPP_Class (Root_Type (Def_Id))\n+              and then Convention (Def_Id) = Convention_CPP\n+            then\n+               null;\n+\n             --  Do not add the spec of the predefined primitives if we are\n             --  compiling under restriction No_Dispatching_Calls\n \n-            if not Restriction_Active (No_Dispatching_Calls) then\n+            elsif not Restriction_Active (No_Dispatching_Calls) then\n                Make_Predefined_Primitive_Specs\n                  (Def_Id, Predef_List, Renamed_Eq);\n                Insert_List_Before_And_Analyze (N, Predef_List);\n@@ -5614,11 +5649,19 @@ package body Exp_Ch3 is\n       if Is_Tagged_Type (Def_Id)\n         and then not Is_Interface (Def_Id)\n       then\n+         --  Do not add the body of predefined primitives in case of\n+         --  CPP tagged type derivations that have convention CPP.\n+\n+         if Is_CPP_Class (Root_Type (Def_Id))\n+           and then Convention (Def_Id) = Convention_CPP\n+         then\n+            null;\n \n          --  Do not add the body of the predefined primitives if we are\n-         --  compiling under restriction No_Dispatching_Calls\n+         --  compiling under restriction No_Dispatching_Calls of if we\n+         --  are compiling a CPP tagged type.\n \n-         if not Restriction_Active (No_Dispatching_Calls) then\n+         elsif not Restriction_Active (No_Dispatching_Calls) then\n             Predef_List := Predefined_Primitive_Bodies (Def_Id, Renamed_Eq);\n             Append_Freeze_Actions (Def_Id, Predef_List);\n          end if;\n@@ -5814,28 +5857,18 @@ package body Exp_Ch3 is\n       then\n          declare\n             Loc         : constant Source_Ptr := Sloc (N);\n-            Desig_Type  : constant Entity_Id := Designated_Type (Def_Id);\n+            Desig_Type  : constant Entity_Id  := Designated_Type (Def_Id);\n             Pool_Object : Entity_Id;\n-            Siz_Exp     : Node_Id;\n \n             Freeze_Action_Typ : Entity_Id;\n \n          begin\n-            if Has_Storage_Size_Clause (Def_Id) then\n-               Siz_Exp := Expression (Parent (Storage_Size_Variable (Def_Id)));\n-            else\n-               Siz_Exp := Empty;\n-            end if;\n-\n             --  Case 1\n \n             --    Rep Clause \"for Def_Id'Storage_Size use 0;\"\n             --    ---> don't use any storage pool\n \n-            if Has_Storage_Size_Clause (Def_Id)\n-              and then Compile_Time_Known_Value (Siz_Exp)\n-              and then Expr_Value (Siz_Exp) = 0\n-            then\n+            if No_Pool_Assigned (Def_Id) then\n                null;\n \n             --  Case 2\n@@ -6046,9 +6079,10 @@ package body Exp_Ch3 is\n \n    function Get_Simple_Init_Val\n      (T    : Entity_Id;\n-      Loc  : Source_Ptr;\n+      N    : Node_Id;\n       Size : Uint := No_Uint) return Node_Id\n    is\n+      Loc    : constant Source_Ptr := Sloc (N);\n       Val    : Node_Id;\n       Result : Node_Id;\n       Val_RE : RE_Id;\n@@ -6057,6 +6091,10 @@ package body Exp_Ch3 is\n       --  This is the size to be used for computation of the appropriate\n       --  initial value for the Normalize_Scalars and Initialize_Scalars case.\n \n+      IV_Attribute : constant Boolean :=\n+                       Nkind (N) = N_Attribute_Reference\n+                         and then Attribute_Name (N) = Name_Invalid_Value;\n+\n       Lo_Bound : Uint;\n       Hi_Bound : Uint;\n       --  These are the values computed by the procedure Check_Subtype_Bounds\n@@ -6133,7 +6171,7 @@ package body Exp_Ch3 is\n       --  an Unchecked_Convert to the private type.\n \n       if Is_Private_Type (T) then\n-         Val := Get_Simple_Init_Val (Underlying_Type (T), Loc, Size);\n+         Val := Get_Simple_Init_Val (Underlying_Type (T), N, Size);\n \n          --  A special case, if the underlying value is null, then qualify it\n          --  with the underlying type, so that the null is properly typed\n@@ -6160,10 +6198,11 @@ package body Exp_Ch3 is\n \n          return Result;\n \n-      --  For scalars, we must have normalize/initialize scalars case\n+      --  For scalars, we must have normalize/initialize scalars case, or\n+      --  if the node N is an 'Invalid_Value attribute node.\n \n       elsif Is_Scalar_Type (T) then\n-         pragma Assert (Init_Or_Norm_Scalars);\n+         pragma Assert (Init_Or_Norm_Scalars or IV_Attribute);\n \n          --  Compute size of object. If it is given by the caller, we can use\n          --  it directly, otherwise we use Esize (T) as an estimate. As far as\n@@ -6188,7 +6227,7 @@ package body Exp_Ch3 is\n \n          --  Processing for Normalize_Scalars case\n \n-         if Normalize_Scalars then\n+         if Normalize_Scalars and then not IV_Attribute then\n \n             --  If zero is invalid, it is a convenient value to use that is\n             --  for sure an appropriate invalid value in all situations.\n@@ -6252,7 +6291,7 @@ package body Exp_Ch3 is\n                end;\n             end if;\n \n-         --  Here for Initialize_Scalars case\n+         --  Here for Initialize_Scalars case (or Invalid_Value attribute used)\n \n          else\n             --  For float types, use float values from System.Scalar_Values\n@@ -6347,7 +6386,7 @@ package body Exp_Ch3 is\n                    Make_Others_Choice (Loc)),\n                  Expression =>\n                    Get_Simple_Init_Val\n-                     (Component_Type (T), Loc, Esize (Root_Type (T))))));\n+                     (Component_Type (T), N, Esize (Root_Type (T))))));\n \n       --  Access type is initialized to null\n \n@@ -6615,14 +6654,6 @@ package body Exp_Ch3 is\n                   New_Reference_To (Iface_Tag, Loc)));\n          end if;\n \n-         --  Issue error if Set_Offset_To_Top is not available in a\n-         --  configurable run-time environment.\n-\n-         if not RTE_Available (RE_Set_Offset_To_Top) then\n-            Error_Msg_CRT (\"abstract interface types\", Typ);\n-            return;\n-         end if;\n-\n          Comp_Typ := Scope (Tag_Comp);\n \n          --  Initialize the entries of the table of interfaces. We generate a\n@@ -6636,17 +6667,26 @@ package body Exp_Ch3 is\n             pragma Assert\n               (Present (DT_Offset_To_Top_Func (Tag_Comp)));\n \n+            --  Issue error if Set_Dynamic_Offset_To_Top is not available in a\n+            --  configurable run-time environment.\n+\n+            if not RTE_Available (RE_Set_Dynamic_Offset_To_Top) then\n+               Error_Msg_CRT\n+                 (\"variable size record with interface types\", Typ);\n+               return;\n+            end if;\n+\n             --  Generate:\n-            --    Set_Offset_To_Top\n+            --    Set_Dynamic_Offset_To_Top\n             --      (This         => Init,\n             --       Interface_T  => Iface'Tag,\n-            --       Is_Constant  => False,\n             --       Offset_Value => n,\n             --       Offset_Func  => Fn'Address)\n \n             Append_To (Stmts_List,\n               Make_Procedure_Call_Statement (Loc,\n-                Name => New_Reference_To (RTE (RE_Set_Offset_To_Top), Loc),\n+                Name => New_Reference_To\n+                          (RTE (RE_Set_Dynamic_Offset_To_Top), Loc),\n                 Parameter_Associations => New_List (\n                   Make_Attribute_Reference (Loc,\n                     Prefix => New_Copy_Tree (Target),\n@@ -6657,8 +6697,6 @@ package body Exp_Ch3 is\n                       (Node (First_Elmt (Access_Disp_Table (Iface))),\n                        Loc)),\n \n-                  New_Occurrence_Of (Standard_False, Loc),\n-\n                   Unchecked_Convert_To\n                     (RTE (RE_Storage_Offset),\n                      Make_Attribute_Reference (Loc,\n@@ -6700,42 +6738,63 @@ package body Exp_Ch3 is\n          --  Normal case: No discriminants in the parent type\n \n          else\n+            --  Don't need to set any value if this interface shares\n+            --  the primary dispatch table\n+\n+            if not Is_Parent (Iface, Typ) then\n+               Append_To (Stmts_List,\n+                 Build_Set_Static_Offset_To_Top (Loc,\n+                   Iface_Tag =>\n+                     New_Reference_To (Iface_Tag, Loc),\n+                   Offset_Value =>\n+                     Unchecked_Convert_To (RTE (RE_Storage_Offset),\n+                       Make_Attribute_Reference (Loc,\n+                         Prefix =>\n+                           Make_Selected_Component (Loc,\n+                             Prefix => New_Copy_Tree (Target),\n+                             Selector_Name  =>\n+                               New_Reference_To (Tag_Comp, Loc)),\n+                         Attribute_Name => Name_Position))));\n+            end if;\n+\n             --  Generate:\n-            --    Set_Offset_To_Top\n+            --    Register_Interface_Offset\n             --      (This         => Init,\n             --       Interface_T  => Iface'Tag,\n             --       Is_Constant  => True,\n             --       Offset_Value => n,\n             --       Offset_Func  => null);\n \n-            Append_To (Stmts_List,\n-              Make_Procedure_Call_Statement (Loc,\n-                Name => New_Reference_To\n-                          (RTE (RE_Set_Offset_To_Top), Loc),\n-                Parameter_Associations => New_List (\n-                  Make_Attribute_Reference (Loc,\n-                    Prefix => New_Copy_Tree (Target),\n-                    Attribute_Name => Name_Address),\n+            if RTE_Available (RE_Register_Interface_Offset) then\n+               Append_To (Stmts_List,\n+                 Make_Procedure_Call_Statement (Loc,\n+                   Name => New_Reference_To\n+                             (RTE (RE_Register_Interface_Offset), Loc),\n+                   Parameter_Associations => New_List (\n+                     Make_Attribute_Reference (Loc,\n+                       Prefix => New_Copy_Tree (Target),\n+                       Attribute_Name => Name_Address),\n \n-                  Unchecked_Convert_To (RTE (RE_Tag),\n-                    New_Reference_To\n-                      (Node (First_Elmt\n-                             (Access_Disp_Table (Iface))),\n-                       Loc)),\n+                     Unchecked_Convert_To (RTE (RE_Tag),\n+                       New_Reference_To\n+                         (Node (First_Elmt\n+                                (Access_Disp_Table (Iface))),\n+                          Loc)),\n \n-                  New_Occurrence_Of (Standard_True, Loc),\n+                     New_Occurrence_Of (Standard_True, Loc),\n \n-                  Unchecked_Convert_To\n-                    (RTE (RE_Storage_Offset),\n-                     Make_Attribute_Reference (Loc,\n-                       Prefix =>\n-                         Make_Selected_Component (Loc,\n-                           Prefix => New_Copy_Tree (Target),\n-                           Selector_Name  =>\n-                             New_Reference_To (Tag_Comp, Loc)),\n-                      Attribute_Name => Name_Position)),\n+                     Unchecked_Convert_To\n+                       (RTE (RE_Storage_Offset),\n+                        Make_Attribute_Reference (Loc,\n+                          Prefix =>\n+                            Make_Selected_Component (Loc,\n+                              Prefix => New_Copy_Tree (Target),\n+                              Selector_Name  =>\n+                                New_Reference_To (Tag_Comp, Loc)),\n+                         Attribute_Name => Name_Position)),\n \n-                  Make_Null (Loc))));\n+                     Make_Null (Loc))));\n+            end if;\n          end if;\n       end Initialize_Tag;\n \n@@ -6816,6 +6875,32 @@ package body Exp_Ch3 is\n       Comp_Typ : Entity_Id;\n       Idx      : Node_Id;\n \n+      function Is_Constant_Bound (Exp : Node_Id) return Boolean;\n+      --  To simplify handling of array components. Determines whether the\n+      --  given bound is constant (a constant or enumeration literal, or an\n+      --  integer literal) as opposed to per-object, through an expression\n+      --  or a discriminant.\n+\n+      -----------------------\n+      -- Is_Constant_Bound --\n+      -----------------------\n+\n+      function Is_Constant_Bound (Exp : Node_Id) return Boolean is\n+      begin\n+         if Nkind (Exp) = N_Integer_Literal then\n+            return True;\n+         else\n+            return\n+              Is_Entity_Name (Exp)\n+                and then Present (Entity (Exp))\n+                and then\n+                 (Ekind (Entity (Exp)) = E_Constant\n+                   or else Ekind (Entity (Exp)) = E_Enumeration_Literal);\n+         end if;\n+      end Is_Constant_Bound;\n+\n+   --  Start of processing for Is_Variable_Sized_Record\n+\n    begin\n       pragma Assert (Is_Record_Type (E));\n \n@@ -6840,15 +6925,9 @@ package body Exp_Ch3 is\n             Idx := First_Index (Comp_Typ);\n             while Present (Idx) loop\n                if Nkind (Idx) = N_Range then\n-                  if (Nkind (Low_Bound (Idx)) = N_Identifier\n-                       and then Present (Entity (Low_Bound (Idx)))\n-                       and then\n-                         Ekind (Entity (Low_Bound (Idx))) /= E_Constant)\n-                    or else\n-                     (Nkind (High_Bound (Idx)) = N_Identifier\n-                       and then Present (Entity (High_Bound (Idx)))\n-                       and then\n-                         Ekind (Entity (High_Bound (Idx))) /= E_Constant)\n+                  if not Is_Constant_Bound (Low_Bound  (Idx))\n+                       or else\n+                     not Is_Constant_Bound (High_Bound (Idx))\n                   then\n                      return True;\n                   end if;\n@@ -7506,6 +7585,7 @@ package body Exp_Ch3 is\n \n       if Ada_Version >= Ada_05\n         and then VM_Target = No_VM\n+        and then RTE_Available (RE_Select_Specific_Data)\n       then\n          --  These primitives are defined abstract in interface types\n \n@@ -7608,8 +7688,14 @@ package body Exp_Ch3 is\n          --  initialization of its dispatch table.\n \n         or else (not Is_Interface (Tag_Typ)\n-                   and then\n-                 Is_Interface (Etype (Tag_Typ)))\n+                   and then Is_Interface (Etype (Tag_Typ)))\n+\n+         --  Ada 205 (AI-251): We must also generate these subprograms if\n+         --  the parent of an nonlimited interface is a limited interface\n+\n+        or else (Is_Interface (Tag_Typ)\n+                  and then not Is_Limited_Interface (Tag_Typ)\n+                  and then Is_Limited_Interface (Etype (Tag_Typ)))\n       then\n          if not Is_Limited_Type (Tag_Typ) then\n             Append_To (Res,\n@@ -7999,6 +8085,7 @@ package body Exp_Ch3 is\n               and then Is_Limited_Record (Etype (Tag_Typ)))\n            or else (Is_Concurrent_Record_Type (Tag_Typ)\n                      and then Has_Abstract_Interfaces (Tag_Typ)))\n+        and then RTE_Available (RE_Select_Specific_Data)\n       then\n          Append_To (Res, Make_Disp_Asynchronous_Select_Body (Tag_Typ));\n          Append_To (Res, Make_Disp_Conditional_Select_Body  (Tag_Typ));"}, {"sha": "d51724af3cd3e16b084dc0948dfbe84eb77895e4", "filename": "gcc/ada/exp_ch3.ads", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2cbd970083b0c0af05fb2cfca08ad4e8d02dc41/gcc%2Fada%2Fexp_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2cbd970083b0c0af05fb2cfca08ad4e8d02dc41/gcc%2Fada%2Fexp_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.ads?ref=f2cbd970083b0c0af05fb2cfca08ad4e8d02dc41", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -133,16 +133,18 @@ package Exp_Ch3 is\n \n    function Get_Simple_Init_Val\n      (T    : Entity_Id;\n-      Loc  : Source_Ptr;\n+      N    : Node_Id;\n       Size : Uint := No_Uint) return Node_Id;\n    --  For a type which Needs_Simple_Initialization (see above), prepares the\n-   --  tree for an expression representing the required initial value. Loc is\n-   --  the source location used in constructing this tree which is returned as\n-   --  the result of the call. The Size parameter indicates the target size of\n-   --  the object if it is known (indicated by a value that is not No_Uint and\n-   --  is greater than zero). If Size is not given (Size set to No_Uint, or\n-   --  non-positive), then the Esize of T is used as an estimate of the Size.\n-   --  The object size is needed to prepare a known invalid value for use by\n-   --  Normalize_Scalars.\n+   --  tree for an expression representing the required initial value. N is a\n+   --  node whose source location used in constructing this tree which is\n+   --  returned as the result of the call. The Size parameter indicates the\n+   --  target size of the object if it is known (indicated by a value that is\n+   --  not No_Uint and is greater than zero). If Size is not given (Size set to\n+   --  No_Uint, or non-positive), then the Esize of T is used as an estimate of\n+   --  the Size. The object size is needed to prepare a known invalid value for\n+   --  use by Normalize_Scalars. A call to this routine where T is a scalar\n+   --  type is only valid if we are in Normalize_Scalars or Initialize_Scalars\n+   --  mode, or if N is the node for a 'Invalid_Value attribute node.\n \n end Exp_Ch3;"}, {"sha": "b4efbf87cc773576e4940765ae6d3d8d6bd542e2", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 301, "deletions": 147, "changes": 448, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2cbd970083b0c0af05fb2cfca08ad4e8d02dc41/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2cbd970083b0c0af05fb2cfca08ad4e8d02dc41/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=f2cbd970083b0c0af05fb2cfca08ad4e8d02dc41", "patch": "@@ -99,15 +99,23 @@ package body Exp_Disp is\n    ------------------------\n \n    function Building_Static_DT (Typ : Entity_Id) return Boolean is\n+      Root_Typ : Entity_Id := Root_Type (Typ);\n+\n    begin\n+      --  Handle private types\n+\n+      if Present (Full_View (Root_Typ)) then\n+         Root_Typ := Full_View (Root_Typ);\n+      end if;\n+\n       return Static_Dispatch_Tables\n         and then Is_Library_Level_Tagged_Type (Typ)\n \n          --  If the type is derived from a CPP class we cannot statically\n          --  build the dispatch tables because we must inherit primitives\n          --  from the CPP side.\n \n-        and then not Is_CPP_Class (Root_Type (Typ));\n+        and then not Is_CPP_Class (Root_Typ);\n    end Building_Static_DT;\n \n    ----------------------------------\n@@ -548,7 +556,6 @@ package body Exp_Disp is\n       Subp_Typ := Create_Itype (E_Subprogram_Type, Call_Node);\n       Subp_Ptr_Typ := Create_Itype (E_Access_Subprogram_Type, Call_Node);\n       Set_Etype          (Subp_Typ, Res_Typ);\n-      Init_Size_Align    (Subp_Ptr_Typ);\n       Set_Returns_By_Ref (Subp_Typ, Returns_By_Ref (Subp));\n \n       --  Create a new list of parameters which is a copy of the old formal\n@@ -575,18 +582,11 @@ package body Exp_Disp is\n                   Set_Etype (New_Formal, Etype (Param));\n                end if;\n \n-               if Is_Itype (Etype (New_Formal)) then\n-                  Extra := New_Copy (Etype (New_Formal));\n-\n-                  if Ekind (Extra) = E_Record_Subtype\n-                    or else Ekind (Extra) = E_Class_Wide_Subtype\n-                  then\n-                     Set_Cloned_Subtype (Extra, Etype (New_Formal));\n-                  end if;\n-\n-                  Set_Etype (New_Formal, Extra);\n-                  Set_Scope (Etype (New_Formal), Subp_Typ);\n-               end if;\n+               --  If the type of the formal is an itype, there was code here\n+               --  introduced in 1998 in revision 1.46, to create a new itype\n+               --  by copy. This seems useless, and in fact leads to semantic\n+               --  errors when the itype is the completion of a type derived\n+               --  from a private type.\n \n                Extra := New_Formal;\n                Next_Formal (Old_Formal);\n@@ -780,7 +780,7 @@ package body Exp_Disp is\n          --  Give error if configurable run time and Displace not available\n \n          if not RTE_Available (RE_Displace) then\n-            Error_Msg_CRT (\"abstract interface types\", N);\n+            Error_Msg_CRT (\"dynamic interface conversion\", N);\n             return;\n          end if;\n \n@@ -839,9 +839,7 @@ package body Exp_Disp is\n \n          begin\n             New_Itype := Create_Itype (E_Anonymous_Access_Type, N);\n-            Set_Etype       (New_Itype, New_Itype);\n-            Init_Esize      (New_Itype);\n-            Init_Size_Align (New_Itype);\n+            Set_Etype (New_Itype, New_Itype);\n             Set_Directly_Designated_Type (New_Itype, Etyp);\n \n             Rewrite (N,\n@@ -1205,20 +1203,15 @@ package body Exp_Disp is\n       Decl_1          : Node_Id;\n       Decl_2          : Node_Id;\n       Formal          : Node_Id;\n+      New_Arg         : Node_Id;\n+      Offset_To_Top   : Node_Id;\n       Target          : Entity_Id;\n       Target_Formal   : Entity_Id;\n \n    begin\n       Thunk_Id   := Empty;\n       Thunk_Code := Empty;\n \n-      --  Give message if configurable run-time and Offset_To_Top unavailable\n-\n-      if not RTE_Available (RE_Offset_To_Top) then\n-         Error_Msg_CRT (\"abstract interface types\", Prim);\n-         return;\n-      end if;\n-\n       --  Traverse the list of alias to find the final target\n \n       Target := Prim;\n@@ -1284,6 +1277,20 @@ package body Exp_Disp is\n                         (Directly_Designated_Type\n                           (Etype (Target_Formal)), Loc)));\n \n+            New_Arg :=\n+              Unchecked_Convert_To (RTE (RE_Address),\n+                New_Reference_To (Defining_Identifier (Formal), Loc));\n+\n+            if not RTE_Available (RE_Offset_To_Top) then\n+               Offset_To_Top :=\n+                 Build_Offset_To_Top (Loc, New_Arg);\n+            else\n+               Offset_To_Top :=\n+                 Make_Function_Call (Loc,\n+                   Name => New_Reference_To (RTE (RE_Offset_To_Top), Loc),\n+                   Parameter_Associations => New_List (New_Arg));\n+            end if;\n+\n             Decl_1 :=\n               Make_Object_Declaration (Loc,\n                 Defining_Identifier =>\n@@ -1299,14 +1306,7 @@ package body Exp_Disp is\n                         (RTE (RE_Storage_Offset),\n                          New_Reference_To (Defining_Identifier (Formal), Loc)),\n                      Right_Opnd =>\n-                       Make_Function_Call (Loc,\n-                         Name =>\n-                           New_Reference_To (RTE (RE_Offset_To_Top), Loc),\n-                         Parameter_Associations => New_List (\n-                           Unchecked_Convert_To\n-                             (RTE (RE_Address),\n-                              New_Reference_To\n-                                (Defining_Identifier (Formal), Loc))))));\n+                       Offset_To_Top));\n \n             Append_To (Decl, Decl_2);\n             Append_To (Decl, Decl_1);\n@@ -1326,6 +1326,23 @@ package body Exp_Disp is\n             --                             - Offset_To_Top (Formal'Address)\n             --     S2 : Addr_Ptr := Addr_Ptr!(S1)\n \n+            New_Arg :=\n+              Make_Attribute_Reference (Loc,\n+                Prefix =>\n+                  New_Reference_To (Defining_Identifier (Formal), Loc),\n+                Attribute_Name =>\n+                  Name_Address);\n+\n+            if not RTE_Available (RE_Offset_To_Top) then\n+               Offset_To_Top :=\n+                 Build_Offset_To_Top (Loc, New_Arg);\n+            else\n+               Offset_To_Top :=\n+                 Make_Function_Call (Loc,\n+                   Name => New_Reference_To (RTE (RE_Offset_To_Top), Loc),\n+                   Parameter_Associations => New_List (New_Arg));\n+            end if;\n+\n             Decl_1 :=\n               Make_Object_Declaration (Loc,\n                 Defining_Identifier =>\n@@ -1344,15 +1361,7 @@ package body Exp_Disp is\n                                (Defining_Identifier (Formal), Loc),\n                            Attribute_Name => Name_Address)),\n                     Right_Opnd =>\n-                       Make_Function_Call (Loc,\n-                         Name =>\n-                           New_Reference_To (RTE (RE_Offset_To_Top), Loc),\n-                         Parameter_Associations => New_List (\n-                           Make_Attribute_Reference (Loc,\n-                             Prefix =>\n-                               New_Reference_To\n-                                 (Defining_Identifier (Formal), Loc),\n-                             Attribute_Name => Name_Address)))));\n+                      Offset_To_Top));\n \n             Decl_2 :=\n               Make_Object_Declaration (Loc,\n@@ -3042,6 +3051,10 @@ package body Exp_Disp is\n                                (Expression\n                                  (Parent (RTE (RE_Max_Predef_Prims)))));\n \n+      DT_Decl : constant Elist_Id := New_Elmt_List;\n+      DT_Aggr : constant Elist_Id := New_Elmt_List;\n+      --  Entities marked with attribute Is_Dispatch_Table_Entity\n+\n       procedure Check_Premature_Freezing (Subp : Entity_Id; Typ : Entity_Id);\n       --  Verify that all non-tagged types in the profile of a subprogram\n       --  are frozen at the point the subprogram is frozen. This enforces\n@@ -3229,6 +3242,7 @@ package body Exp_Disp is\n \n          declare\n             Prim_Table : array (Nat range 1 .. Nb_Predef_Prims) of Entity_Id;\n+            Decl       : Node_Id;\n             Thunk_Id   : Entity_Id;\n             Thunk_Code : Node_Id;\n \n@@ -3272,27 +3286,43 @@ package body Exp_Disp is\n             for J in Prim_Table'Range loop\n                if Present (Prim_Table (J)) then\n                   New_Node :=\n-                    Unchecked_Convert_To (RTE (RE_Address),\n+                    Unchecked_Convert_To (RTE (RE_Prim_Ptr),\n                       Make_Attribute_Reference (Loc,\n                         Prefix => New_Reference_To (Prim_Table (J), Loc),\n                         Attribute_Name => Name_Unrestricted_Access));\n                else\n-                  New_Node :=\n-                    New_Reference_To (RTE (RE_Null_Address), Loc);\n+                  New_Node := Make_Null (Loc);\n                end if;\n \n                Append_To (Prim_Ops_Aggr_List, New_Node);\n             end loop;\n \n+            New_Node :=\n+              Make_Aggregate (Loc,\n+                Expressions => Prim_Ops_Aggr_List);\n+\n+            --  Remember aggregates initializing dispatch tables\n+\n+            Append_Elmt (New_Node, DT_Aggr);\n+\n+            Decl :=\n+              Make_Subtype_Declaration (Loc,\n+                Defining_Identifier =>\n+                  Make_Defining_Identifier (Loc,\n+                    New_Internal_Name ('S')),\n+                Subtype_Indication =>\n+                  New_Reference_To (RTE (RE_Address_Array), Loc));\n+\n+            Append_To (Result, Decl);\n+\n             Append_To (Result,\n               Make_Object_Declaration (Loc,\n                 Defining_Identifier => Predef_Prims,\n                 Constant_Present    => Building_Static_DT (Typ),\n                 Aliased_Present     => True,\n-                Object_Definition   =>\n-                  New_Reference_To (RTE (RE_Address_Array), Loc),\n-                Expression => Make_Aggregate (Loc,\n-                  Expressions => Prim_Ops_Aggr_List)));\n+                Object_Definition   => New_Reference_To\n+                                         (Defining_Identifier (Decl), Loc),\n+                Expression => New_Node));\n \n             Append_To (Result,\n               Make_Attribute_Definition_Clause (Loc,\n@@ -3492,15 +3522,13 @@ package body Exp_Disp is\n          Prim_Ops_Aggr_List := New_List;\n \n          if Empty_DT then\n-            Append_To (Prim_Ops_Aggr_List,\n-              New_Reference_To (RTE (RE_Null_Address), Loc));\n+            Append_To (Prim_Ops_Aggr_List, Make_Null (Loc));\n \n          elsif Is_Abstract_Type (Typ)\n            or else not Building_Static_DT (Typ)\n          then\n             for J in 1 .. Nb_Prim loop\n-               Append_To (Prim_Ops_Aggr_List,\n-                 New_Reference_To (RTE (RE_Null_Address), Loc));\n+               Append_To (Prim_Ops_Aggr_List, Make_Null (Loc));\n             end loop;\n \n          else\n@@ -3556,23 +3584,28 @@ package body Exp_Disp is\n                for J in Prim_Table'Range loop\n                   if Present (Prim_Table (J)) then\n                      New_Node :=\n-                       Unchecked_Convert_To (RTE (RE_Address),\n+                       Unchecked_Convert_To (RTE (RE_Prim_Ptr),\n                          Make_Attribute_Reference (Loc,\n                            Prefix => New_Reference_To (Prim_Table (J), Loc),\n                            Attribute_Name => Name_Unrestricted_Access));\n                   else\n-                     New_Node :=\n-                       New_Reference_To (RTE (RE_Null_Address), Loc);\n+                     New_Node := Make_Null (Loc);\n                   end if;\n \n                   Append_To (Prim_Ops_Aggr_List, New_Node);\n                end loop;\n             end;\n          end if;\n \n-         Append_To (DT_Aggr_List,\n+         New_Node :=\n            Make_Aggregate (Loc,\n-             Expressions => Prim_Ops_Aggr_List));\n+             Expressions => Prim_Ops_Aggr_List);\n+\n+         Append_To (DT_Aggr_List, New_Node);\n+\n+         --  Remember aggregates initializing dispatch tables\n+\n+         Append_Elmt (New_Node, DT_Aggr);\n \n          Append_To (Result,\n            Make_Object_Declaration (Loc,\n@@ -3635,14 +3668,10 @@ package body Exp_Disp is\n                        (RTE_Record_Component (RE_Predef_Prims), Loc)),\n                  Attribute_Name => Name_Address)));\n \n-         --  Mark entities containing library level static dispatch tables.\n-         --  This attribute is later propagated to all the access-to-subprogram\n-         --  itypes generated to fill the dispatch table slots (see exp_attr).\n+         --  Remember entities containing dispatch tables\n \n-         if Building_Static_DT (Typ) then\n-            Set_Is_Static_Dispatch_Table_Entity (Predef_Prims);\n-            Set_Is_Static_Dispatch_Table_Entity (Iface_DT);\n-         end if;\n+         Append_Elmt (Predef_Prims, DT_Decl);\n+         Append_Elmt (Iface_DT, DT_Decl);\n       end Make_Secondary_DT;\n \n       --  Local variables\n@@ -3666,6 +3695,7 @@ package body Exp_Disp is\n       New_Node           : Node_Id;\n       No_Reg             : Node_Id;\n       Num_Ifaces         : Nat := 0;\n+      Parent_Typ         : Entity_Id;\n       Prim               : Entity_Id;\n       Prim_Elmt          : Elmt_Id;\n       Prim_Ops_Aggr_List : List_Id;\n@@ -3761,6 +3791,14 @@ package body Exp_Disp is\n          end if;\n       end if;\n \n+      --  Initialize Parent_Typ handling private types\n+\n+      Parent_Typ := Etype (Typ);\n+\n+      if Present (Full_View (Parent_Typ)) then\n+         Parent_Typ := Full_View (Parent_Typ);\n+      end if;\n+\n       --  Ensure that all the primitives are frozen. This is only required when\n       --  building static dispatch tables --- the primitives must be frozen to\n       --  be referenced (otherwise we have problems with the backend). It is\n@@ -4045,6 +4083,7 @@ package body Exp_Disp is\n       --            HT_Link            => HT_Link'Address,\n       --            Transportable      => <<boolean-value>>,\n       --            RC_Offset          => <<integer-value>>,\n+      --            [ Size_Func         => Size_Prim'Access ]\n       --            [ Interfaces_Table  => <<access-value>> ]\n       --            [ SSD               => SSD_Table'Address ]\n       --            Tags_Table         => (0 => null,\n@@ -4204,23 +4243,28 @@ package body Exp_Disp is\n       --  External tag of a library-level tagged type: Check for a definition\n       --  of External_Tag. The clause is considered only if it applies to this\n       --  specific tagged type, as opposed to one of its ancestors.\n+      --  If the type is an unconstrained type extension, we are building the\n+      --  dispatch table of its anonymous base type, so the external tag, if\n+      --  any was specified, must be retrieved from the first subtype.\n \n       else\n          declare\n-            Def : constant Node_Id := Get_Attribute_Definition_Clause (Typ,\n-                                        Attribute_External_Tag);\n+            Def : constant Node_Id := Get_Attribute_Definition_Clause\n+                                        (First_Subtype (Typ),\n+                                         Attribute_External_Tag);\n+\n             Old_Val : String_Id;\n             New_Val : String_Id;\n             E       : Entity_Id;\n \n          begin\n             if not Present (Def)\n-              or else Entity (Name (Def)) /= Typ\n+              or else Entity (Name (Def)) /= First_Subtype (Typ)\n             then\n                New_Node :=\n                  Unchecked_Convert_To (RTE (RE_Cstring_Ptr),\n                    Make_Attribute_Reference (Loc,\n-                     Prefix => New_Reference_To (Exname, Loc),\n+                     Prefix         => New_Reference_To (Exname, Loc),\n                      Attribute_Name => Name_Address));\n             else\n                Old_Val := Strval (Expr_Value_S (Expression (Def)));\n@@ -4320,15 +4364,8 @@ package body Exp_Disp is\n \n       declare\n          RC_Offset_Node : Node_Id;\n-         Parent_Typ     : Entity_Id;\n \n       begin\n-         if Present (Full_View (Etype (Typ))) then\n-            Parent_Typ := Full_View (Etype (Typ));\n-         else\n-            Parent_Typ := Etype (Typ);\n-         end if;\n-\n          if not Has_Controlled_Component (Typ) then\n             RC_Offset_Node := Make_Integer_Literal (Loc, 0);\n \n@@ -4368,6 +4405,52 @@ package body Exp_Disp is\n          Append_To (TSD_Aggr_List, RC_Offset_Node);\n       end;\n \n+      --  Size_Func\n+\n+      if RTE_Record_Component_Available (RE_Size_Func) then\n+         if not Building_Static_DT (Typ)\n+           or else Is_Interface (Typ)\n+         then\n+            Append_To (TSD_Aggr_List,\n+              Unchecked_Convert_To (RTE (RE_Size_Ptr),\n+                New_Reference_To (RTE (RE_Null_Address), Loc)));\n+\n+         else\n+            declare\n+               Prim_Elmt : Elmt_Id;\n+               Prim      : Entity_Id;\n+\n+            begin\n+               Prim_Elmt := First_Elmt (Primitive_Operations (Typ));\n+               while Present (Prim_Elmt) loop\n+                  Prim := Node (Prim_Elmt);\n+\n+                  if Chars (Prim) = Name_uSize then\n+                     while Present (Alias (Prim)) loop\n+                        Prim := Alias (Prim);\n+                     end loop;\n+\n+                     if Is_Abstract_Subprogram (Prim) then\n+                        Append_To (TSD_Aggr_List,\n+                          Unchecked_Convert_To (RTE (RE_Size_Ptr),\n+                            New_Reference_To (RTE (RE_Null_Address), Loc)));\n+                     else\n+                        Append_To (TSD_Aggr_List,\n+                          Unchecked_Convert_To (RTE (RE_Size_Ptr),\n+                            Make_Attribute_Reference (Loc,\n+                              Prefix => New_Reference_To (Prim, Loc),\n+                              Attribute_Name => Name_Unrestricted_Access)));\n+                     end if;\n+\n+                     exit;\n+                  end if;\n+\n+                  Next_Elmt (Prim_Elmt);\n+               end loop;\n+            end;\n+         end if;\n+      end if;\n+\n       --  Interfaces_Table (required for AI-405)\n \n       if RTE_Record_Component_Available (RE_Interfaces_Table) then\n@@ -4561,34 +4644,34 @@ package body Exp_Disp is\n       --  Initialize the table of ancestor tags. In case of interface types\n       --  this table is not needed.\n \n-      declare\n-         Current_Typ : Entity_Id;\n-         Parent_Typ  : Entity_Id;\n-         Pos         : Nat;\n+      TSD_Tags_List := New_List;\n \n-      begin\n-         TSD_Tags_List := New_List;\n+      --  If we are not statically allocating the dispatch table then we must\n+      --  fill position 0 with null because we still have not generated the\n+      --  tag of Typ.\n \n-         --  If we are not statically allocating the dispatch table then we\n-         --  must fill position 0 with null because we still have not\n-         --  generated the tag of Typ.\n+      if not Building_Static_DT (Typ)\n+        or else Is_Interface (Typ)\n+      then\n+         Append_To (TSD_Tags_List,\n+           Unchecked_Convert_To (RTE (RE_Tag),\n+             New_Reference_To (RTE (RE_Null_Address), Loc)));\n \n-         if not Building_Static_DT (Typ)\n-           or else Is_Interface (Typ)\n-         then\n-            Append_To (TSD_Tags_List,\n-              Unchecked_Convert_To (RTE (RE_Tag),\n-                New_Reference_To (RTE (RE_Null_Address), Loc)));\n+      --  Otherwise we can safely reference the tag\n \n-         --  Otherwise we can safely reference the tag\n+      else\n+         Append_To (TSD_Tags_List,\n+           New_Reference_To (DT_Ptr, Loc));\n+      end if;\n \n-         else\n-            Append_To (TSD_Tags_List,\n-              New_Reference_To (DT_Ptr, Loc));\n-         end if;\n+      --  Fill the rest of the table with the tags of the ancestors\n \n-         --  Fill the rest of the table with the tags of the ancestors\n+      declare\n+         Current_Typ : Entity_Id;\n+         Parent_Typ  : Entity_Id;\n+         Pos         : Nat;\n \n+      begin\n          Pos := 1;\n          Current_Typ := Typ;\n \n@@ -4775,6 +4858,7 @@ package body Exp_Disp is\n             declare\n                Prim_Table : array\n                               (Nat range 1 .. Nb_Predef_Prims) of Entity_Id;\n+               Decl       : Node_Id;\n                E          : Entity_Id;\n \n             begin\n@@ -4808,26 +4892,43 @@ package body Exp_Disp is\n                for J in Prim_Table'Range loop\n                   if Present (Prim_Table (J)) then\n                      New_Node :=\n-                       Unchecked_Convert_To (RTE (RE_Address),\n+                       Unchecked_Convert_To (RTE (RE_Prim_Ptr),\n                          Make_Attribute_Reference (Loc,\n                            Prefix => New_Reference_To (Prim_Table (J), Loc),\n                            Attribute_Name => Name_Unrestricted_Access));\n                   else\n-                     New_Node := New_Reference_To (RTE (RE_Null_Address), Loc);\n+                     New_Node := Make_Null (Loc);\n                   end if;\n \n                   Append_To (Prim_Ops_Aggr_List, New_Node);\n                end loop;\n \n+               New_Node :=\n+                 Make_Aggregate (Loc,\n+                   Expressions => Prim_Ops_Aggr_List);\n+\n+               Decl :=\n+                 Make_Subtype_Declaration (Loc,\n+                   Defining_Identifier =>\n+                     Make_Defining_Identifier (Loc,\n+                       New_Internal_Name ('S')),\n+                   Subtype_Indication =>\n+                     New_Reference_To (RTE (RE_Address_Array), Loc));\n+\n+               Append_To (Result, Decl);\n+\n                Append_To (Result,\n                  Make_Object_Declaration (Loc,\n                    Defining_Identifier => Predef_Prims,\n                    Aliased_Present     => True,\n                    Constant_Present    => Building_Static_DT (Typ),\n-                   Object_Definition   =>\n-                     New_Reference_To (RTE (RE_Address_Array), Loc),\n-                   Expression => Make_Aggregate (Loc,\n-                     Expressions => Prim_Ops_Aggr_List)));\n+                   Object_Definition   => New_Reference_To\n+                                           (Defining_Identifier (Decl), Loc),\n+                   Expression => New_Node));\n+\n+               --  Remember aggregates initializing dispatch tables\n+\n+               Append_Elmt (New_Node, DT_Aggr);\n \n                Append_To (Result,\n                  Make_Attribute_Definition_Clause (Loc,\n@@ -4880,9 +4981,7 @@ package body Exp_Disp is\n \n          --  Offset_To_Top\n \n-         if RTE_Record_Component_Available (RE_Offset_To_Top) then\n-            Append_To (DT_Aggr_List, Make_Integer_Literal (Loc, 0));\n-         end if;\n+         Append_To (DT_Aggr_List, Make_Integer_Literal (Loc, 0));\n \n          --  Typeinfo\n \n@@ -4896,13 +4995,11 @@ package body Exp_Disp is\n          Prim_Ops_Aggr_List := New_List;\n \n          if Nb_Prim = 0 then\n-            Append_To (Prim_Ops_Aggr_List,\n-              New_Reference_To (RTE (RE_Null_Address), Loc));\n+            Append_To (Prim_Ops_Aggr_List, Make_Null (Loc));\n \n          elsif not Building_Static_DT (Typ) then\n             for J in 1 .. Nb_Prim loop\n-               Append_To (Prim_Ops_Aggr_List,\n-                 New_Reference_To (RTE (RE_Null_Address), Loc));\n+               Append_To (Prim_Ops_Aggr_List, Make_Null (Loc));\n             end loop;\n \n          else\n@@ -4951,22 +5048,28 @@ package body Exp_Disp is\n                for J in Prim_Table'Range loop\n                   if Present (Prim_Table (J)) then\n                      New_Node :=\n-                       Unchecked_Convert_To (RTE (RE_Address),\n+                       Unchecked_Convert_To (RTE (RE_Prim_Ptr),\n                          Make_Attribute_Reference (Loc,\n                            Prefix => New_Reference_To (Prim_Table (J), Loc),\n                            Attribute_Name => Name_Unrestricted_Access));\n                   else\n-                     New_Node := New_Reference_To (RTE (RE_Null_Address), Loc);\n+                     New_Node := Make_Null (Loc);\n                   end if;\n \n                   Append_To (Prim_Ops_Aggr_List, New_Node);\n                end loop;\n             end;\n          end if;\n \n-         Append_To (DT_Aggr_List,\n+         New_Node :=\n            Make_Aggregate (Loc,\n-             Expressions => Prim_Ops_Aggr_List));\n+             Expressions => Prim_Ops_Aggr_List);\n+\n+         Append_To (DT_Aggr_List, New_Node);\n+\n+         --  Remember aggregates initializing dispatch tables\n+\n+         Append_Elmt (New_Node, DT_Aggr);\n \n          --  In case of locally defined tagged types we have already declared\n          --  and uninitialized object for the dispatch table, which is now\n@@ -5048,26 +5151,27 @@ package body Exp_Disp is\n       --  If the ancestor is a CPP_Class type we inherit the dispatch tables\n       --  in the init proc, and we don't need to fill them in here.\n \n-      elsif Is_CPP_Class (Etype (Typ)) then\n+      elsif Is_CPP_Class (Parent_Typ) then\n          null;\n \n       --  Otherwise we fill in the dispatch tables here\n \n       else\n-         if Typ /= Etype (Typ)\n+         if Typ /= Parent_Typ\n            and then not Is_Interface (Typ)\n            and then not Restriction_Active (No_Dispatching_Calls)\n          then\n             --  Inherit the dispatch table\n \n             if not Is_Interface (Typ)\n-              and then not Is_Interface (Etype (Typ))\n-              and then not Is_CPP_Class (Etype (Typ))\n+              and then not Is_Interface (Parent_Typ)\n+              and then not Is_CPP_Class (Parent_Typ)\n             then\n                declare\n                   Nb_Prims : constant Int :=\n                                UI_To_Int (DT_Entry_Count\n-                                 (First_Tag_Component (Etype (Typ))));\n+                                 (First_Tag_Component (Parent_Typ)));\n+\n                begin\n                   Append_To (Elab_Code,\n                     Build_Inherit_Predefined_Prims (Loc,\n@@ -5076,7 +5180,7 @@ package body Exp_Disp is\n                           (Node\n                            (Next_Elmt\n                             (First_Elmt\n-                             (Access_Disp_Table (Etype (Typ))))), Loc),\n+                             (Access_Disp_Table (Parent_Typ)))), Loc),\n                       New_Tag_Node =>\n                         New_Reference_To\n                           (Node\n@@ -5092,7 +5196,7 @@ package body Exp_Disp is\n                            New_Reference_To\n                              (Node\n                               (First_Elmt\n-                               (Access_Disp_Table (Etype (Typ)))), Loc),\n+                               (Access_Disp_Table (Parent_Typ))), Loc),\n                          New_Tag_Node => New_Reference_To (DT_Ptr, Loc),\n                          Num_Prims    => Nb_Prims));\n                   end if;\n@@ -5101,13 +5205,13 @@ package body Exp_Disp is\n \n             --  Inherit the secondary dispatch tables of the ancestor\n \n-            if not Is_CPP_Class (Etype (Typ)) then\n+            if not Is_CPP_Class (Parent_Typ) then\n                declare\n                   Sec_DT_Ancestor : Elmt_Id :=\n                                       Next_Elmt\n                                        (Next_Elmt\n                                         (First_Elmt\n-                                          (Access_Disp_Table (Etype (Typ)))));\n+                                          (Access_Disp_Table (Parent_Typ))));\n                   Sec_DT_Typ      : Elmt_Id :=\n                                       Next_Elmt\n                                        (Next_Elmt\n@@ -5327,18 +5431,49 @@ package body Exp_Disp is\n            Make_Select_Specific_Data_Table (Typ));\n       end if;\n \n-      --  Mark entities containing library level static dispatch tables. This\n-      --  attribute is later propagated to all the access-to-subprogram itypes\n-      --  generated to fill the dispatch table slots (see exp_attr).\n+      --  Remember entities containing dispatch tables\n \n-      if Building_Static_DT (Typ) then\n-         Set_Is_Static_Dispatch_Table_Entity (Predef_Prims);\n-         Set_Is_Static_Dispatch_Table_Entity (DT);\n-      end if;\n+      Append_Elmt (Predef_Prims, DT_Decl);\n+      Append_Elmt (DT, DT_Decl);\n \n       Analyze_List (Result, Suppress => All_Checks);\n       Set_Has_Dispatch_Table (Typ);\n \n+      --  Mark entities containing dispatch tables. Required by the\n+      --  backend to handle them properly.\n+\n+      if not Is_Interface (Typ) then\n+         declare\n+            Elmt : Elmt_Id;\n+\n+         begin\n+            --  Ensure that entities Prim_Ptr and Predef_Prims_Table_Ptr have\n+            --  the decoration required by the backend\n+\n+            Set_Is_Dispatch_Table_Entity (RTE (RE_Prim_Ptr));\n+            Set_Is_Dispatch_Table_Entity (RTE (RE_Predef_Prims_Table_Ptr));\n+\n+            --  Object declarations\n+\n+            Elmt := First_Elmt (DT_Decl);\n+            while Present (Elmt) loop\n+               Set_Is_Dispatch_Table_Entity (Node (Elmt));\n+               pragma Assert (Ekind (Etype (Node (Elmt))) = E_Array_Subtype\n+                 or else Ekind (Etype (Node (Elmt))) = E_Record_Subtype);\n+               Set_Is_Dispatch_Table_Entity (Etype (Node (Elmt)));\n+               Next_Elmt (Elmt);\n+            end loop;\n+\n+            --  Aggregates initializing dispatch tables\n+\n+            Elmt := First_Elmt (DT_Aggr);\n+            while Present (Elmt) loop\n+               Set_Is_Dispatch_Table_Entity (Etype (Node (Elmt)));\n+               Next_Elmt (Elmt);\n+            end loop;\n+         end;\n+      end if;\n+\n       return Result;\n    end Make_DT;\n \n@@ -5763,7 +5898,7 @@ package body Exp_Disp is\n       --     expand dispatching calls through the primary dispatch table.\n \n       --     Generate:\n-      --       type Typ_DT is array (1 .. Nb_Prims) of Address;\n+      --       type Typ_DT is array (1 .. Nb_Prims) of Prim_Ptr;\n       --       type Typ_DT_Acc is access Typ_DT;\n \n       declare\n@@ -5791,7 +5926,7 @@ package body Exp_Disp is\n                  Component_Definition =>\n                    Make_Component_Definition (Loc,\n                      Subtype_Indication =>\n-                       New_Reference_To (RTE (RE_Address), Loc)))));\n+                       New_Reference_To (RTE (RE_Prim_Ptr), Loc)))));\n \n          Append_To (Result,\n            Make_Full_Type_Declaration (Loc,\n@@ -5810,6 +5945,11 @@ package body Exp_Disp is\n \n          Analyze_List (Result);\n          Set_Suppress_Init_Proc (Base_Type (DT_Prims));\n+\n+         --  Mark entity of dispatch table. Required by the backend to handle\n+         --  the properly.\n+\n+         Set_Is_Dispatch_Table_Entity (DT_Prims);\n       end;\n \n       Set_Ekind        (DT_Ptr, E_Constant);\n@@ -5949,9 +6089,9 @@ package body Exp_Disp is\n       L             : List_Id;\n       Pos           : Uint;\n       Tag           : Entity_Id;\n+      Tag_Typ       : Entity_Id;\n       Thunk_Id      : Entity_Id;\n       Thunk_Code    : Node_Id;\n-      Typ           : Entity_Id;\n \n    begin\n       pragma Assert (not Restriction_Active (No_Dispatching_Calls));\n@@ -5961,35 +6101,49 @@ package body Exp_Disp is\n       end if;\n \n       if not Present (Abstract_Interface_Alias (Prim)) then\n-         Typ := Scope (DTC_Entity (Prim));\n+         Tag_Typ := Scope (DTC_Entity (Prim));\n          Pos := DT_Position (Prim);\n-         Tag := First_Tag_Component (Typ);\n+         Tag := First_Tag_Component (Tag_Typ);\n \n          if Is_Predefined_Dispatching_Operation (Prim)\n            or else Is_Predefined_Dispatching_Alias (Prim)\n          then\n-            DT_Ptr := Node (Next_Elmt (First_Elmt (Access_Disp_Table (Typ))));\n+            DT_Ptr :=\n+              Node (Next_Elmt (First_Elmt (Access_Disp_Table (Tag_Typ))));\n+\n             Insert_After (Ins_Nod,\n               Build_Set_Predefined_Prim_Op_Address (Loc,\n                 Tag_Node     => New_Reference_To (DT_Ptr, Loc),\n                 Position     => Pos,\n                 Address_Node =>\n-                  Unchecked_Convert_To (RTE (RE_Address),\n+                  Unchecked_Convert_To (RTE (RE_Prim_Ptr),\n                     Make_Attribute_Reference (Loc,\n                       Prefix => New_Reference_To (Prim, Loc),\n                       Attribute_Name => Name_Unrestricted_Access))));\n \n+            --  Register copy of the pointer to the 'size primitive in the TSD.\n+\n+            if Chars (Prim) = Name_uSize\n+              and then RTE_Record_Component_Available (RE_Size_Func)\n+            then\n+               DT_Ptr := Node (First_Elmt (Access_Disp_Table (Tag_Typ)));\n+               Insert_After (Ins_Nod,\n+                 Build_Set_Size_Function (Loc,\n+                   Tag_Node  => New_Reference_To (DT_Ptr, Loc),\n+                   Size_Func => Prim));\n+            end if;\n+\n          else\n             pragma Assert (Pos /= Uint_0 and then Pos <= DT_Entry_Count (Tag));\n \n-            DT_Ptr := Node (First_Elmt (Access_Disp_Table (Typ)));\n+            DT_Ptr := Node (First_Elmt (Access_Disp_Table (Tag_Typ)));\n             Insert_After (Ins_Nod,\n               Build_Set_Prim_Op_Address (Loc,\n-                Typ          => Typ,\n+                Typ          => Tag_Typ,\n                 Tag_Node     => New_Reference_To (DT_Ptr, Loc),\n                 Position     => Pos,\n                 Address_Node =>\n-                  Unchecked_Convert_To (RTE (RE_Address),\n+                  Unchecked_Convert_To (RTE (RE_Prim_Ptr),\n                     Make_Attribute_Reference (Loc,\n                       Prefix => New_Reference_To (Prim, Loc),\n                       Attribute_Name => Name_Unrestricted_Access))));\n@@ -6002,14 +6156,14 @@ package body Exp_Disp is\n       --  else to do here.\n \n       else\n-         Typ       := Find_Dispatching_Type (Alias (Prim));\n+         Tag_Typ   := Find_Dispatching_Type (Alias (Prim));\n          Iface_Typ := Find_Dispatching_Type (Abstract_Interface_Alias (Prim));\n \n          pragma Assert (Is_Interface (Iface_Typ));\n \n          Expand_Interface_Thunk (Prim, Thunk_Id, Thunk_Code);\n \n-         if not Is_Parent (Iface_Typ, Typ)\n+         if not Is_Parent (Iface_Typ, Tag_Typ)\n            and then Present (Thunk_Code)\n          then\n             --  Comment needed on why checks are suppressed. This is not just\n@@ -6022,7 +6176,7 @@ package body Exp_Disp is\n             --  the secondary dispatch table of Prim's controlling type with\n             --  Thunk_Id's address.\n \n-            Iface_DT_Elmt := Find_Interface_ADT (Typ, Iface_Typ);\n+            Iface_DT_Elmt := Find_Interface_ADT (Tag_Typ, Iface_Typ);\n             Iface_DT_Ptr  := Node (Iface_DT_Elmt);\n             pragma Assert (Has_Thunks (Iface_DT_Ptr));\n \n@@ -6040,7 +6194,7 @@ package body Exp_Disp is\n                      New_Reference_To (Node (Next_Elmt (Iface_DT_Elmt)), Loc),\n                    Position => Pos,\n                    Address_Node =>\n-                     Unchecked_Convert_To (RTE (RE_Address),\n+                     Unchecked_Convert_To (RTE (RE_Prim_Ptr),\n                        Make_Attribute_Reference (Loc,\n                          Prefix          => New_Reference_To (Thunk_Id, Loc),\n                          Attribute_Name  => Name_Unrestricted_Access))));\n@@ -6056,7 +6210,7 @@ package body Exp_Disp is\n                      New_Reference_To (Node (Next_Elmt (Iface_DT_Elmt)), Loc),\n                    Position => Pos,\n                    Address_Node =>\n-                     Unchecked_Convert_To (RTE (RE_Address),\n+                     Unchecked_Convert_To (RTE (RE_Prim_Ptr),\n                        Make_Attribute_Reference (Loc,\n                          Prefix => New_Reference_To (Alias (Prim), Loc),\n                          Attribute_Name  => Name_Unrestricted_Access))));\n@@ -6073,7 +6227,7 @@ package body Exp_Disp is\n                    Tag_Node     => New_Reference_To (Iface_DT_Ptr, Loc),\n                    Position     => Pos,\n                    Address_Node =>\n-                     Unchecked_Convert_To (RTE (RE_Address),\n+                     Unchecked_Convert_To (RTE (RE_Prim_Ptr),\n                        Make_Attribute_Reference (Loc,\n                          Prefix => New_Reference_To (Thunk_Id, Loc),\n                          Attribute_Name => Name_Unrestricted_Access))));\n@@ -6089,7 +6243,7 @@ package body Exp_Disp is\n                    Tag_Node     => New_Reference_To (Iface_DT_Ptr, Loc),\n                    Position     => Pos,\n                    Address_Node =>\n-                     Unchecked_Convert_To (RTE (RE_Address),\n+                     Unchecked_Convert_To (RTE (RE_Prim_Ptr),\n                        Make_Attribute_Reference (Loc,\n                          Prefix => New_Reference_To (Alias (Prim), Loc),\n                          Attribute_Name => Name_Unrestricted_Access))));"}, {"sha": "aceb6a11e111aa822e2541ac272969d916f5aca2", "filename": "gcc/ada/rtsfind.adb", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2cbd970083b0c0af05fb2cfca08ad4e8d02dc41/gcc%2Fada%2Frtsfind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2cbd970083b0c0af05fb2cfca08ad4e8d02dc41/gcc%2Fada%2Frtsfind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.adb?ref=f2cbd970083b0c0af05fb2cfca08ad4e8d02dc41", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -283,6 +283,9 @@ package body Rtsfind is\n          if U_Id in Ada_Calendar_Child then\n             Name_Buffer (13) := '.';\n \n+         elsif U_Id in Ada_Dispatching_Child then\n+            Name_Buffer (16) := '.';\n+\n          elsif U_Id in Ada_Finalization_Child then\n             Name_Buffer (17) := '.';\n \n@@ -311,6 +314,10 @@ package body Rtsfind is\n       elsif U_Id in System_Child then\n          Name_Buffer (7) := '.';\n \n+         if U_Id in System_Strings_Child then\n+            Name_Buffer (15) := '.';\n+         end if;\n+\n          if U_Id in System_Tasking_Child then\n             Name_Buffer (15) := '.';\n          end if;"}, {"sha": "86779cb28d2ca6977169830b197045215ef26d49", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 76, "deletions": 7, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2cbd970083b0c0af05fb2cfca08ad4e8d02dc41/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2cbd970083b0c0af05fb2cfca08ad4e8d02dc41/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=f2cbd970083b0c0af05fb2cfca08ad4e8d02dc41", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -78,6 +78,9 @@ package Rtsfind is\n    --    name is System.xxx. For example, the name System_Str_Concat refers to\n    --    package System.Str_Concat.\n \n+   --    Names of the form System_Strings_xxx are second level children of the\n+   --    package System.Strings.\n+\n    --    Names of the form System_Tasking_xxx are second level children of the\n    --    package System.Tasking. For example, System_Tasking_Stages refers to\n    --    refers to the package System.Tasking.Stages.\n@@ -112,6 +115,7 @@ package Rtsfind is\n       --  Children of Ada\n \n       Ada_Calendar,\n+      Ada_Dispatching,\n       Ada_Exceptions,\n       Ada_Finalization,\n       Ada_Interrupts,\n@@ -125,6 +129,10 @@ package Rtsfind is\n \n       Ada_Calendar_Delays,\n \n+      --  Children of Ada.Dispatching\n+\n+      Ada_Dispatching_EDF,\n+\n       --  Children of Ada.Finalization\n \n       Ada_Finalization_List_Controller,\n@@ -348,6 +356,10 @@ package Rtsfind is\n       System_WWd_Enum,\n       System_WWd_Wchar,\n \n+      --  Children of System.Strings\n+\n+      System_Strings_Stream_Ops,\n+\n       --  Children of System.Tasking\n \n       System_Tasking_Async_Delays,\n@@ -369,6 +381,10 @@ package Rtsfind is\n      range Ada_Calendar_Delays .. Ada_Calendar_Delays;\n    --  Range of values for children of Ada.Calendar\n \n+   subtype Ada_Dispatching_Child is RTU_Id\n+     range Ada_Dispatching_EDF .. Ada_Dispatching_EDF;\n+   --  Range of values for children of Ada.Dispatching\n+\n    subtype Ada_Finalization_Child is Ada_Child range\n      Ada_Finalization_List_Controller .. Ada_Finalization_List_Controller;\n    --  Range of values for children of Ada.Finalization\n@@ -404,6 +420,9 @@ package Rtsfind is\n      range System_Address_Image .. System_Tasking_Stages;\n    --  Range of values for children or grandchildren of System\n \n+   subtype System_Strings_Child is RTU_Id\n+     range System_Strings_Stream_Ops .. System_Strings_Stream_Ops;\n+\n    subtype System_Tasking_Child is System_Child\n      range System_Tasking_Async_Delays .. System_Tasking_Stages;\n    --  Range of values for children of System.Tasking\n@@ -451,6 +470,8 @@ package Rtsfind is\n \n      RE_Null,\n \n+     RE_Set_Deadline,                    -- Ada.Dispatching.EDF\n+\n      RE_Code_Loc,                        -- Ada.Exceptions\n      RE_Current_Target_Exception,        -- Ada.Exceptions (JGNAT use only)\n      RE_Exception_Id,                    -- Ada.Exceptions\n@@ -497,6 +518,7 @@ package Rtsfind is\n      RE_Dispatch_Table_Wrapper,          -- Ada.Tags\n      RE_Displace,                        -- Ada.Tags\n      RE_DT,                              -- Ada.Tags\n+     RE_DT_Offset_To_Top_Offset,         -- Ada.Tags\n      RE_DT_Predef_Prims_Offset,          -- Ada.Tags\n      RE_DT_Typeinfo_Ptr_Size,            -- Ada.Tags\n      RE_External_Tag,                    -- Ada.Tags\n@@ -520,6 +542,7 @@ package Rtsfind is\n      RE_Num_Prims,                       -- Ada.Tags\n      RE_Object_Specific_Data,            -- Ada.Tags\n      RE_Offset_To_Top,                   -- Ada.Tags\n+     RE_Offset_To_Top_Ptr,               -- Ada.Tags\n      RE_Offset_To_Top_Function_Ptr,      -- Ada.Tags\n      RE_OSD_Table,                       -- Ada.Tags\n      RE_OSD_Num_Prims,                   -- Ada.Tags\n@@ -534,20 +557,24 @@ package Rtsfind is\n      RE_Predef_Prims,                    -- Ada.Tags\n      RE_Predef_Prims_Table_Ptr,          -- Ada.Tags\n      RE_Prim_Op_Kind,                    -- Ada.Tags\n+     RE_Prim_Ptr,                        -- Ada.Tags\n      RE_Prims_Ptr,                       -- Ada.Tags\n      RE_Primary_DT,                      -- Ada.Tags\n      RE_Signature,                       -- Ada.Tags\n      RE_SSD,                             -- Ada.Tags\n      RE_TSD,                             -- Ada.Tags\n      RE_Type_Specific_Data,              -- Ada.Tags\n+     RE_Register_Interface_Offset,       -- Ada.Tags\n      RE_Register_Tag,                    -- Ada.Tags\n      RE_Transportable,                   -- Ada.Tags\n      RE_Secondary_DT,                    -- Ada.Tags\n      RE_Secondary_Tag,                   -- Ada.Tags\n      RE_Select_Specific_Data,            -- Ada.Tags\n      RE_Set_Entry_Index,                 -- Ada.Tags\n-     RE_Set_Offset_To_Top,               -- Ada.Tags\n+     RE_Set_Dynamic_Offset_To_Top,       -- Ada.Tags\n      RE_Set_Prim_Op_Kind,                -- Ada.Tags\n+     RE_Size_Func,                       -- Ada.Tags\n+     RE_Size_Ptr,                        -- Ada.Tags\n      RE_Tag,                             -- Ada.Tags\n      RE_Tag_Error,                       -- Ada.Tags\n      RE_Tag_Kind,                        -- Ada.Tags\n@@ -573,6 +600,9 @@ package Rtsfind is\n      RO_CA_Delay_Until,                  -- Ada.Calendar.Delays\n      RO_CA_To_Duration,                  -- Ada.Calendar.Delays\n \n+     RE_Clock,                           -- Ada.Real_Time\n+     RE_Time_Span,                       -- Ada.Real_Time\n+     RE_Time_Span_Zero,                  -- Ada.Real_Time\n      RO_RT_Time,                         -- Ada.Real_Time\n \n      RO_RT_Delay_Until,                  -- Ada.Real_Time.Delays\n@@ -749,6 +779,7 @@ package Rtsfind is\n      RE_Default_Interrupt_Priority,      -- System.Interrupts\n      RE_Dynamic_Interrupt_Protection,    -- System.Interrupts\n      RE_Install_Handlers,                -- System.Interrupts\n+     RE_Install_Restricted_Handlers,     -- System.Interrupts\n      RE_Register_Interrupt_Handler,      -- System.Interrupts\n      RE_Static_Interrupt_Protection,     -- System.Interrupts\n      RE_System_Interrupt_Id,             -- System.Interrupts\n@@ -1233,11 +1264,10 @@ package Rtsfind is\n      RE_Storage_Offset,                  -- System.Storage_Elements\n      RE_Storage_Array,                   -- System.Storage_Elements\n      RE_To_Address,                      -- System.Storage_Elements\n-     RE_Dummy_Communication_Block,       -- System.Storage_Elements\n \n      RE_Root_Storage_Pool,               -- System.Storage_Pools\n-     RE_Allocate_Any,                    -- System_Storage_Pools,\n-     RE_Deallocate_Any,                  -- System_Storage_Pools,\n+     RE_Allocate_Any,                    -- System.Storage_Pools,\n+     RE_Deallocate_Any,                  -- System.Storage_Pools,\n \n      RE_I_AD,                            -- System.Stream_Attributes\n      RE_I_AS,                            -- System.Stream_Attributes\n@@ -1292,6 +1322,19 @@ package Rtsfind is\n \n      RE_Str_Concat_5,                    -- System.String_Ops_Concat_5\n \n+     RE_String_Input,                    -- System.Strings.Stream_Ops\n+     RE_String_Output,                   -- System.Strings.Stream_Ops\n+     RE_String_Read,                     -- System.Strings.Stream_Ops\n+     RE_String_Write,                    -- System.Strings.Stream_Ops\n+     RE_Wide_String_Input,               -- System.Strings.Stream_Ops\n+     RE_Wide_String_Output,              -- System.Strings.Stream_Ops\n+     RE_Wide_String_Read,                -- System.Strings.Stream_Ops\n+     RE_Wide_String_Write,               -- System.Strings.Stream_Ops\n+     RE_Wide_Wide_String_Input,          -- System.Strings.Stream_Ops\n+     RE_Wide_Wide_String_Output,         -- System.Strings.Stream_Ops\n+     RE_Wide_Wide_String_Read,           -- System.Strings.Stream_Ops\n+     RE_Wide_Wide_String_Write,          -- System.Strings.Stream_Ops\n+\n      RE_Task_Info_Type,                  -- System.Task_Info\n      RE_Unspecified_Task_Info,           -- System.Task_Info\n \n@@ -1331,6 +1374,7 @@ package Rtsfind is\n      RE_Abort_Undefer,                   -- System.Soft_Links\n      RE_Complete_Master,                 -- System.Soft_Links\n      RE_Current_Master,                  -- System.Soft_Links\n+     RE_Dummy_Communication_Block,       -- System.Soft_Links\n      RE_Enter_Master,                    -- System.Soft_Links\n      RE_Get_Current_Excep,               -- System.Soft_Links\n      RE_Get_GNAT_Exception,              -- System.Soft_Links\n@@ -1555,6 +1599,8 @@ package Rtsfind is\n \n      RE_Null                             => RTU_Null,\n \n+     RE_Set_Deadline                     => Ada_Dispatching_EDF,\n+\n      RE_Code_Loc                         => Ada_Exceptions,\n      RE_Current_Target_Exception         => Ada_Exceptions, -- of JGNAT\n      RE_Exception_Id                     => Ada_Exceptions,\n@@ -1601,6 +1647,7 @@ package Rtsfind is\n      RE_Dispatch_Table_Wrapper           => Ada_Tags,\n      RE_Displace                         => Ada_Tags,\n      RE_DT                               => Ada_Tags,\n+     RE_DT_Offset_To_Top_Offset          => Ada_Tags,\n      RE_DT_Predef_Prims_Offset           => Ada_Tags,\n      RE_DT_Typeinfo_Ptr_Size             => Ada_Tags,\n      RE_External_Tag                     => Ada_Tags,\n@@ -1624,6 +1671,7 @@ package Rtsfind is\n      RE_Num_Prims                        => Ada_Tags,\n      RE_Object_Specific_Data             => Ada_Tags,\n      RE_Offset_To_Top                    => Ada_Tags,\n+     RE_Offset_To_Top_Ptr                => Ada_Tags,\n      RE_Offset_To_Top_Function_Ptr       => Ada_Tags,\n      RE_OSD_Table                        => Ada_Tags,\n      RE_OSD_Num_Prims                    => Ada_Tags,\n@@ -1638,20 +1686,24 @@ package Rtsfind is\n      RE_Predef_Prims                     => Ada_Tags,\n      RE_Predef_Prims_Table_Ptr           => Ada_Tags,\n      RE_Prim_Op_Kind                     => Ada_Tags,\n+     RE_Prim_Ptr                         => Ada_Tags,\n      RE_Prims_Ptr                        => Ada_Tags,\n      RE_Primary_DT                       => Ada_Tags,\n      RE_Signature                        => Ada_Tags,\n      RE_SSD                              => Ada_Tags,\n      RE_TSD                              => Ada_Tags,\n      RE_Type_Specific_Data               => Ada_Tags,\n+     RE_Register_Interface_Offset        => Ada_Tags,\n      RE_Register_Tag                     => Ada_Tags,\n      RE_Transportable                    => Ada_Tags,\n      RE_Secondary_DT                     => Ada_Tags,\n      RE_Secondary_Tag                    => Ada_Tags,\n      RE_Select_Specific_Data             => Ada_Tags,\n      RE_Set_Entry_Index                  => Ada_Tags,\n-     RE_Set_Offset_To_Top                => Ada_Tags,\n+     RE_Set_Dynamic_Offset_To_Top        => Ada_Tags,\n      RE_Set_Prim_Op_Kind                 => Ada_Tags,\n+     RE_Size_Func                        => Ada_Tags,\n+     RE_Size_Ptr                         => Ada_Tags,\n      RE_Tag                              => Ada_Tags,\n      RE_Tag_Error                        => Ada_Tags,\n      RE_Tag_Kind                         => Ada_Tags,\n@@ -1676,6 +1728,9 @@ package Rtsfind is\n      RO_CA_Delay_Until                   => Ada_Calendar_Delays,\n      RO_CA_To_Duration                   => Ada_Calendar_Delays,\n \n+     RE_Clock                            => Ada_Real_Time,\n+     RE_Time_Span                        => Ada_Real_Time,\n+     RE_Time_Span_Zero                   => Ada_Real_Time,\n      RO_RT_Time                          => Ada_Real_Time,\n      RO_RT_Delay_Until                   => Ada_Real_Time_Delays,\n      RO_RT_To_Duration                   => Ada_Real_Time_Delays,\n@@ -1851,6 +1906,7 @@ package Rtsfind is\n      RE_Default_Interrupt_Priority       => System_Interrupts,\n      RE_Dynamic_Interrupt_Protection     => System_Interrupts,\n      RE_Install_Handlers                 => System_Interrupts,\n+     RE_Install_Restricted_Handlers      => System_Interrupts,\n      RE_Register_Interrupt_Handler       => System_Interrupts,\n      RE_Static_Interrupt_Protection      => System_Interrupts,\n      RE_System_Interrupt_Id              => System_Interrupts,\n@@ -2335,7 +2391,6 @@ package Rtsfind is\n      RE_Storage_Offset                   => System_Storage_Elements,\n      RE_Storage_Array                    => System_Storage_Elements,\n      RE_To_Address                       => System_Storage_Elements,\n-     RE_Dummy_Communication_Block        => System_Storage_Elements,\n \n      RE_Root_Storage_Pool                => System_Storage_Pools,\n      RE_Allocate_Any                     => System_Storage_Pools,\n@@ -2394,6 +2449,19 @@ package Rtsfind is\n \n      RE_Str_Concat_5                     => System_String_Ops_Concat_5,\n \n+     RE_String_Input                     => System_Strings_Stream_Ops,\n+     RE_String_Output                    => System_Strings_Stream_Ops,\n+     RE_String_Read                      => System_Strings_Stream_Ops,\n+     RE_String_Write                     => System_Strings_Stream_Ops,\n+     RE_Wide_String_Input                => System_Strings_Stream_Ops,\n+     RE_Wide_String_Output               => System_Strings_Stream_Ops,\n+     RE_Wide_String_Read                 => System_Strings_Stream_Ops,\n+     RE_Wide_String_Write                => System_Strings_Stream_Ops,\n+     RE_Wide_Wide_String_Input           => System_Strings_Stream_Ops,\n+     RE_Wide_Wide_String_Output          => System_Strings_Stream_Ops,\n+     RE_Wide_Wide_String_Read            => System_Strings_Stream_Ops,\n+     RE_Wide_Wide_String_Write           => System_Strings_Stream_Ops,\n+\n      RE_Task_Info_Type                   => System_Task_Info,\n      RE_Unspecified_Task_Info            => System_Task_Info,\n \n@@ -2433,6 +2501,7 @@ package Rtsfind is\n      RE_Abort_Undefer                    => System_Soft_Links,\n      RE_Complete_Master                  => System_Soft_Links,\n      RE_Current_Master                   => System_Soft_Links,\n+     RE_Dummy_Communication_Block        => System_Soft_Links,\n      RE_Enter_Master                     => System_Soft_Links,\n      RE_Get_Current_Excep                => System_Soft_Links,\n      RE_Get_GNAT_Exception               => System_Soft_Links,"}]}