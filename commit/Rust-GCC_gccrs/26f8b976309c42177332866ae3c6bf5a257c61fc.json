{"sha": "26f8b976309c42177332866ae3c6bf5a257c61fc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjZmOGI5NzYzMDljNDIxNzczMzI4NjZhZTNjNmJmNWEyNTdjNjFmYw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2012-11-18T17:32:45Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2012-11-18T17:32:45Z"}, "message": "expmed.c (narrow_bit_field_mem): New function.\n\ngcc/\n\t* expmed.c (narrow_bit_field_mem): New function.\n\t(store_bit_field_using_insv, store_bit_field_1, store_fixed_bit_field)\n\t(extract_bit_field_1): Use it.\n\nFrom-SVN: r193602", "tree": {"sha": "d3308fcd82a8463340faa0e773e18fdd07c823f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3308fcd82a8463340faa0e773e18fdd07c823f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/26f8b976309c42177332866ae3c6bf5a257c61fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26f8b976309c42177332866ae3c6bf5a257c61fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26f8b976309c42177332866ae3c6bf5a257c61fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26f8b976309c42177332866ae3c6bf5a257c61fc/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5f2cbd0debd8670fdf8689891ea0d2e711a2fecd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f2cbd0debd8670fdf8689891ea0d2e711a2fecd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f2cbd0debd8670fdf8689891ea0d2e711a2fecd"}], "stats": {"total": 82, "additions": 51, "deletions": 31}, "files": [{"sha": "5d41ef9357a8ab68ec3f2b96059878ecffc3413b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26f8b976309c42177332866ae3c6bf5a257c61fc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26f8b976309c42177332866ae3c6bf5a257c61fc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=26f8b976309c42177332866ae3c6bf5a257c61fc", "patch": "@@ -1,3 +1,9 @@\n+2012-11-18  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* expmed.c (narrow_bit_field_mem): New function.\n+\t(store_bit_field_using_insv, store_bit_field_1, store_fixed_bit_field)\n+\t(extract_bit_field_1): Use it.\n+\n 2012-11-18  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* expr.h (adjust_address_1): Add a size parameter."}, {"sha": "106b78b7021b521d7bff116e3c9a6be47a72a062", "filename": "gcc/expmed.c", "status": "modified", "additions": 45, "deletions": 31, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26f8b976309c42177332866ae3c6bf5a257c61fc/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26f8b976309c42177332866ae3c6bf5a257c61fc/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=26f8b976309c42177332866ae3c6bf5a257c61fc", "patch": "@@ -387,6 +387,34 @@ mode_for_extraction (enum extraction_pattern pattern, int opno)\n   return data->operand[opno].mode;\n }\n \n+/* Adjust bitfield memory MEM so that it points to the first unit of mode\n+   MODE that contains a bitfield of size BITSIZE at bit position BITNUM.\n+   If MODE is BLKmode, return a reference to every byte in the bitfield.\n+   Set *NEW_BITNUM to the bit position of the field within the new memory.  */\n+\n+static rtx\n+narrow_bit_field_mem (rtx mem, enum machine_mode mode,\n+\t\t      unsigned HOST_WIDE_INT bitsize,\n+\t\t      unsigned HOST_WIDE_INT bitnum,\n+\t\t      unsigned HOST_WIDE_INT *new_bitnum)\n+{\n+  if (mode == BLKmode)\n+    {\n+      *new_bitnum = bitnum % BITS_PER_UNIT;\n+      HOST_WIDE_INT offset = bitnum / BITS_PER_UNIT;\n+      HOST_WIDE_INT size = ((*new_bitnum + bitsize + BITS_PER_UNIT - 1)\n+\t\t\t    / BITS_PER_UNIT);\n+      return adjust_bitfield_address_size (mem, mode, offset, size);\n+    }\n+  else\n+    {\n+      unsigned int unit = GET_MODE_BITSIZE (mode);\n+      *new_bitnum = bitnum % unit;\n+      HOST_WIDE_INT offset = (bitnum - *new_bitnum) / BITS_PER_UNIT;\n+      return adjust_bitfield_address (mem, mode, offset);\n+    }\n+}\n+\n /* Return true if a bitfield of size BITSIZE at bit number BITNUM within\n    a structure of mode STRUCT_MODE represents a lowpart subreg.   The subreg\n    offset is then BITNUM / BITS_PER_UNIT.  */\n@@ -424,11 +452,8 @@ store_bit_field_using_insv (rtx op0, unsigned HOST_WIDE_INT bitsize,\n     return false;\n \n   if (MEM_P (xop0))\n-    {\n-      /* Get a reference to the first byte of the field.  */\n-      xop0 = adjust_bitfield_address (xop0, byte_mode, bitnum / BITS_PER_UNIT);\n-      bitnum %= BITS_PER_UNIT;\n-    }\n+    /* Get a reference to the first byte of the field.  */\n+    xop0 = narrow_bit_field_mem (xop0, byte_mode, bitsize, bitnum, &bitnum);\n   else\n     {\n       /* Convert from counting within OP0 to counting in OP_MODE.  */\n@@ -831,18 +856,15 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t       && GET_MODE_BITSIZE (bestmode) > MEM_ALIGN (op0)))\n \t{\n \t  rtx last, tempreg, xop0;\n-\t  unsigned int unit;\n-\t  unsigned HOST_WIDE_INT offset, bitpos;\n+\t  unsigned HOST_WIDE_INT bitpos;\n \n \t  last = get_last_insn ();\n \n \t  /* Adjust address to point to the containing unit of\n \t     that mode.  Compute the offset as a multiple of this unit,\n \t     counting in bytes.  */\n-\t  unit = GET_MODE_BITSIZE (bestmode);\n-\t  offset = (bitnum / unit) * GET_MODE_SIZE (bestmode);\n-\t  bitpos = bitnum % unit;\n-\t  xop0 = adjust_bitfield_address (op0, bestmode, offset);\n+\t  xop0 = narrow_bit_field_mem (op0, bestmode, bitsize, bitnum,\n+\t\t\t\t       &bitpos);\n \n \t  /* Fetch that unit, store the bitfield in it, then store\n \t     the unit.  */\n@@ -975,9 +997,7 @@ store_fixed_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \t  return;\n \t}\n \n-      HOST_WIDE_INT bit_offset = bitnum - bitnum % GET_MODE_BITSIZE (mode);\n-      op0 = adjust_bitfield_address (op0, mode, bit_offset / BITS_PER_UNIT);\n-      bitnum -= bit_offset;\n+      op0 = narrow_bit_field_mem (op0, mode, bitsize, bitnum, &bitnum);\n     }\n \n   mode = GET_MODE (op0);\n@@ -1246,11 +1266,8 @@ extract_bit_field_using_extv (rtx op0, unsigned HOST_WIDE_INT bitsize,\n     return NULL_RTX;\n \n   if (MEM_P (op0))\n-    {\n-      /* Get a reference to the first byte of the field.  */\n-      op0 = adjust_bitfield_address (op0, byte_mode, bitnum / BITS_PER_UNIT);\n-      bitnum %= BITS_PER_UNIT;\n-    }\n+    /* Get a reference to the first byte of the field.  */\n+    op0 = narrow_bit_field_mem (op0, byte_mode, bitsize, bitnum, &bitnum);\n   else\n     {\n       /* Convert from counting within OP0 to counting in EXT_MODE.  */\n@@ -1640,23 +1657,20 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t  && !(SLOW_UNALIGNED_ACCESS (bestmode, MEM_ALIGN (op0))\n \t       && GET_MODE_BITSIZE (bestmode) > MEM_ALIGN (op0)))\n \t{\n-\t  unsigned HOST_WIDE_INT offset, bitpos;\n-\n-\t  /* Compute the offset as a multiple of this unit,\n-\t     counting in bytes.  */\n-\t  unsigned int unit = GET_MODE_BITSIZE (bestmode);\n-\t  offset = (bitnum / unit) * GET_MODE_SIZE (bestmode);\n-\t  bitpos = bitnum % unit;\n-\n-\t  /* Make sure the register is big enough for the whole field.  */\n-\t  if (bitpos + bitsize <= unit)\n+\t  unsigned HOST_WIDE_INT bitpos;\n+\t  rtx xop0 = narrow_bit_field_mem (op0, bestmode, bitsize, bitnum,\n+\t\t\t\t\t   &bitpos);\n+\n+\t  /* Make sure the register is big enough for the whole field.\n+\t     (It might not be if bestmode == GET_MODE (op0) and the input\n+\t     code was invalid.)  */\n+\t  if (bitpos + bitsize <= GET_MODE_BITSIZE (bestmode))\n \t    {\n-\t      rtx last, result, xop0;\n+\t      rtx last, result;\n \n \t      last = get_last_insn ();\n \n \t      /* Fetch it to a register in that size.  */\n-\t      xop0 = adjust_bitfield_address (op0, bestmode, offset);\n \t      xop0 = force_reg (bestmode, xop0);\n \t      result = extract_bit_field_1 (xop0, bitsize, bitpos,\n \t\t\t\t\t    unsignedp, packedp, target,"}]}