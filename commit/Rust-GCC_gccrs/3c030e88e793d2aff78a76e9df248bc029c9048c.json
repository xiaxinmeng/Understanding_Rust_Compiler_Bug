{"sha": "3c030e88e793d2aff78a76e9df248bc029c9048c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2MwMzBlODhlNzkzZDJhZmY3OGE3NmU5ZGYyNDhiYzAyOWM5MDQ4Yw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-09-16T20:21:30Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-09-16T20:21:30Z"}, "message": "basic-block.h (free_bb_for_insn): Declare.\n\n\t* basic-block.h (free_bb_for_insn): Declare.\n\t* bb-reorder.c (label_for_bb): Use block_label.\n\t(emit_jump_to_block_after): Remove.\n\t(insert_intra_1): Do not update block_for_insn.\n\t(insert_inter_bb_scope_notes): Likewise; update bb->end\n\t* cfg.c (free_bb_for_insn): New.\n\t(try_rediret_by_replacing_jump): Avoid set_block_for_new_insns call.\n\t(force_nonfallthru_and_redirect): Likewise; do not update BB boundaries.\n\t(commit_one_edge_insertion): Likewise.\n\t(commit_one_edge_insertion): Do not update BB boundary.\n\t(commit_edge_insertions): Do not call compute_bb_for_insn.\n\t* cfgbuild.c (find_basic_blocks): Do not free basic_block_for_insn.\n\t* cfgcleanup.c (merge_blocks_move_predecessor): Use reorder_insns_nobb.\n\t(merge_blocks_move_successor_nojumps): Likewise.\n\t(try_crossjump_to_edge): Do not update block_for_insn.\n\t* combine.c (combine_instructions): Remove compute_bb_for_insn call.\n\t* df.c (df_pattern_emit_later): Do not update BB boundary.\n\t(df_jump_pattern_emit_after): Likewise.\n\t(df_insn_move_before): Use emit_insn_before.\n\t* emit-rtl.c (try_split): Emit after trial to get bb boundary updated\n\t properly.\n\t(add_insn_after, add_insn_before, emit_insns_after): Update BB\n\tboundaries and basic_block_for_insn.\n\t(reorder_insns_nobb): Rename from reorder_insns.\n\t(reorder_insns): New.\n\t(emit_block_insn_before, emit_block_insn_after): Kill.\n\t* flow.c (check_function_return_warnings): Do not call\n\tcompute_bb_for_insn; Do not free basic_block_for_insn.\n\t(attempt_auto_inc): Do not update basic_block_for_insn.\n\t* function.c (emit_return_into_block): Likewise;\n\tdo not update BB boundaries.\n\t* gcse.c (handle_avail_expr): Do not update basic_block_for_insn.\n\t(insert_insn_end_bb): Use emit_insn_before; Likewise.\n\t(pre_insert_copy_insn): Likewise.\n\t(update_ld_motion_notes): Likewise.\n\t(insert_insn_start_bb): Likewise.\n\t(replace_store_insn): Likewise.\n\t* ifcvt.c (noce_process_if_block): Likewise.\n\t(if_convert): Do not call compute_bb_for_insn.\n\t* lcm.c (optimize_mode_switching): Do not update BB boundaries.\n\tUse emit_insn_before and emit_insn_after.\n\t* recog.c (split_all_insns): Do not update BB boundaries;\n\tDo not call compute_bb_for_insn.\n\t(peephole2_optimize): Do not update BB boundaries.\n\t* reg-stack.c (emit_pop_insn): Use emit_insn_after and\n\temit_insn_before.\n\t(emit_swap_insn): Likewise.\n\t(convert_regs_1): Likewise.\n\t* reload1.c (reload): Call compute_bb_for_insn.\n\t* rtl.h (reorder_insns_nobb): Declare.\n\t* ssa.c (rename_equivalent_regs): Use emit_insn_before.\n\t* toplev.c (rest_of_compilation): Call free_bb_for_insn\n\tat places CFG is invalidated; do not call compute_bb_for_insn.\n\n\t* cfg.c (expunge_block): Invalidate BB structure.\n\n\t* (merge_blocks_nomove): Update properly BLOCK_FOR_INSN\n\tarray.\n\n\t* cfg.c (verify_flow_info): Verify the basic_block_for_insn array.\n\nFrom-SVN: r45647", "tree": {"sha": "3f3b141a9f45004a367eed069d691638b036e04f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f3b141a9f45004a367eed069d691638b036e04f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c030e88e793d2aff78a76e9df248bc029c9048c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c030e88e793d2aff78a76e9df248bc029c9048c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c030e88e793d2aff78a76e9df248bc029c9048c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c030e88e793d2aff78a76e9df248bc029c9048c/comments", "author": null, "committer": null, "parents": [{"sha": "345894b43fd5709b3990ff7897ed2b941d62742c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/345894b43fd5709b3990ff7897ed2b941d62742c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/345894b43fd5709b3990ff7897ed2b941d62742c"}], "stats": {"total": 460, "additions": 242, "deletions": 218}, "files": [{"sha": "069d527c901b831c17d94e49a1e2cd7fd9aba8ab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3c030e88e793d2aff78a76e9df248bc029c9048c", "patch": "@@ -1,3 +1,66 @@\n+Sun Sep 16 21:59:46 CEST 2001  Jan hubicka  <jh@suse.cz>\n+\n+\t* basic-block.h (free_bb_for_insn): Declare.\n+\t* bb-reorder.c (label_for_bb): Use block_label.\n+\t(emit_jump_to_block_after): Remove.\n+\t(insert_intra_1): Do not update block_for_insn.\n+\t(insert_inter_bb_scope_notes): Likewise; update bb->end\n+\t* cfg.c (free_bb_for_insn): New.\n+\t(try_rediret_by_replacing_jump): Avoid set_block_for_new_insns call.\n+\t(force_nonfallthru_and_redirect): Likewise; do not update BB boundaries.\n+\t(commit_one_edge_insertion): Likewise.\n+\t(commit_one_edge_insertion): Do not update BB boundary.\n+\t(commit_edge_insertions): Do not call compute_bb_for_insn.\n+\t* cfgbuild.c (find_basic_blocks): Do not free basic_block_for_insn.\n+\t* cfgcleanup.c (merge_blocks_move_predecessor): Use reorder_insns_nobb.\n+\t(merge_blocks_move_successor_nojumps): Likewise.\n+\t(try_crossjump_to_edge): Do not update block_for_insn.\n+\t* combine.c (combine_instructions): Remove compute_bb_for_insn call.\n+\t* df.c (df_pattern_emit_later): Do not update BB boundary.\n+\t(df_jump_pattern_emit_after): Likewise.\n+\t(df_insn_move_before): Use emit_insn_before.\n+\t* emit-rtl.c (try_split): Emit after trial to get bb boundary updated\n+\t properly.\n+\t(add_insn_after, add_insn_before, emit_insns_after): Update BB\n+\tboundaries and basic_block_for_insn.\n+\t(reorder_insns_nobb): Rename from reorder_insns.\n+\t(reorder_insns): New.\n+\t(emit_block_insn_before, emit_block_insn_after): Kill.\n+\t* flow.c (check_function_return_warnings): Do not call\n+\tcompute_bb_for_insn; Do not free basic_block_for_insn.\n+\t(attempt_auto_inc): Do not update basic_block_for_insn.\n+\t* function.c (emit_return_into_block): Likewise;\n+\tdo not update BB boundaries.\n+\t* gcse.c (handle_avail_expr): Do not update basic_block_for_insn.\n+\t(insert_insn_end_bb): Use emit_insn_before; Likewise.\n+\t(pre_insert_copy_insn): Likewise.\n+\t(update_ld_motion_notes): Likewise.\n+\t(insert_insn_start_bb): Likewise.\n+\t(replace_store_insn): Likewise.\n+\t* ifcvt.c (noce_process_if_block): Likewise.\n+\t(if_convert): Do not call compute_bb_for_insn.\n+\t* lcm.c (optimize_mode_switching): Do not update BB boundaries.\n+\tUse emit_insn_before and emit_insn_after.\n+\t* recog.c (split_all_insns): Do not update BB boundaries;\n+\tDo not call compute_bb_for_insn.\n+\t(peephole2_optimize): Do not update BB boundaries.\n+\t* reg-stack.c (emit_pop_insn): Use emit_insn_after and\n+\temit_insn_before.\n+\t(emit_swap_insn): Likewise.\n+\t(convert_regs_1): Likewise.\n+\t* reload1.c (reload): Call compute_bb_for_insn.\n+\t* rtl.h (reorder_insns_nobb): Declare.\n+\t* ssa.c (rename_equivalent_regs): Use emit_insn_before.\n+\t* toplev.c (rest_of_compilation): Call free_bb_for_insn\n+\tat places CFG is invalidated; do not call compute_bb_for_insn.\n+\n+\t* cfg.c (expunge_block): Invalidate BB structure.\n+\n+\t* (merge_blocks_nomove): Update properly BLOCK_FOR_INSN\n+\tarray.\n+\n+\t* cfg.c (verify_flow_info): Verify the basic_block_for_insn array.\n+\n 2001-09-16  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* cpphash.h (_cpp_lex_token): Update prototype."}, {"sha": "8771b782c3e7c22cad0516e812205f335120af51", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=3c030e88e793d2aff78a76e9df248bc029c9048c", "patch": "@@ -288,6 +288,7 @@ extern varray_type basic_block_for_insn;\n #define BLOCK_NUM(INSN)\t      (BLOCK_FOR_INSN (INSN)->index + 0)\n \n extern void compute_bb_for_insn\t\tPARAMS ((int));\n+extern void free_bb_for_insn\t\tPARAMS ((void));\n extern void update_bb_for_insn\t\tPARAMS ((basic_block));\n extern void set_block_for_insn\t\tPARAMS ((rtx, basic_block));\n extern void set_block_for_new_insns\tPARAMS ((rtx, basic_block));"}, {"sha": "c471a6fa6e837999a8eb3197db7123f91a67be6b", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 6, "deletions": 56, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=3c030e88e793d2aff78a76e9df248bc029c9048c", "patch": "@@ -180,7 +180,6 @@ static void record_effective_endpoints\tPARAMS ((void));\n static void make_reorder_chain\t\tPARAMS ((void));\n static basic_block make_reorder_chain_1\tPARAMS ((basic_block, basic_block));\n static rtx label_for_bb\t\t\tPARAMS ((basic_block));\n-static rtx emit_jump_to_block_after\tPARAMS ((basic_block, rtx));\n static void fixup_reorder_chain\t\tPARAMS ((void));\n static void relate_bbs_with_scopes\tPARAMS ((scope));\n static scope make_new_scope\t\tPARAMS ((int, rtx));\n@@ -505,60 +504,15 @@ label_for_bb (bb)\n \tfprintf (rtl_dump_file, \"Emitting label for block %d\\n\",\n \t\t bb->index);\n \n-      label = emit_label_before (gen_label_rtx (), label);\n-      if (bb->head == RBI (bb)->eff_head)\n+      label = block_label (bb);\n+      if (bb->head == PREV_INSN (RBI (bb)->eff_head))\n \tRBI (bb)->eff_head = label;\n-      bb->head = label;\n-      if (basic_block_for_insn)\n-\tset_block_for_insn (label, bb);\n     }\n \n   return label;\n }\n \n \n-/* Emit a jump to BB after insn AFTER.  */\n-\n-static rtx\n-emit_jump_to_block_after (bb, after)\n-     basic_block bb;\n-     rtx after;\n-{\n-  rtx jump;\n-\n-  if (bb != EXIT_BLOCK_PTR)\n-    {\n-      rtx label = label_for_bb (bb);\n-      jump = emit_jump_insn_after (gen_jump (label), after);\n-      JUMP_LABEL (jump) = label;\n-      LABEL_NUSES (label) += 1;\n-      if (basic_block_for_insn)\n-\tset_block_for_new_insns (jump, bb);\n-\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \"Emitting jump to block %d\\n\",\n-\t\t bb->index);\n-    }\n-  else\n-    {\n-#ifdef HAVE_return\n-      if (! HAVE_return)\n-\tabort ();\n-      jump = emit_jump_insn_after (gen_return (), after);\n-      if (basic_block_for_insn)\n-\tset_block_for_new_insns (jump, bb);\n-\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \"Emitting return\\n\");\n-#else\n-      abort ();\n-#endif\n-    }\n-\n-  return jump;\n-}\n-\n-\n /* Given a reorder chain, rearrange the code to match.  */\n \n static void\n@@ -1122,8 +1076,6 @@ insert_intra_1 (s, ip, bb)\n     {  \n       *ip = emit_note_after (NOTE_INSN_BLOCK_BEG, *ip);\n       NOTE_BLOCK (*ip) = NOTE_BLOCK (s->note_beg);\n-      if (basic_block_for_insn)\n-\tset_block_for_insn (*ip, bb);\n     } \n \n   for (p = s->inner; p; p = p->next)\n@@ -1133,8 +1085,6 @@ insert_intra_1 (s, ip, bb)\n     {  \n       *ip = emit_note_after (NOTE_INSN_BLOCK_END, *ip);\n       NOTE_BLOCK (*ip) = NOTE_BLOCK (s->note_end);\n-      if (basic_block_for_insn)\n-\tset_block_for_insn (*ip, bb);\n     }\n }\n \n@@ -1220,6 +1170,8 @@ insert_inter_bb_scope_notes (bb1, bb2)\n   /* Close scopes.  */\n   if (bb1)\n     {\n+      rtx end = bb1->end;\n+\n       scope s = RBI (bb1)->scope;\n       ip = RBI (bb1)->eff_end;\n       while (s != com)\n@@ -1228,11 +1180,11 @@ insert_inter_bb_scope_notes (bb1, bb2)\n \t    {  \n \t      ip = emit_note_after (NOTE_INSN_BLOCK_END, ip);\n \t      NOTE_BLOCK (ip) = NOTE_BLOCK (s->note_end);\n-\t      if (basic_block_for_insn)\n-\t\tset_block_for_insn (ip, bb1);\n \t    }\n \t  s = s->outer;\n \t}\n+      /* Emitting note may move the end of basic block to unwanted place.  */\n+      bb1->end = end;\n     }\n \n   /* Open scopes.  */\n@@ -1246,8 +1198,6 @@ insert_inter_bb_scope_notes (bb1, bb2)\n \t    {  \n \t      ip = emit_note_before (NOTE_INSN_BLOCK_BEG, ip);\n \t      NOTE_BLOCK (ip) = NOTE_BLOCK (s->note_beg);\n-\t      if (basic_block_for_insn)\n-\t\tset_block_for_insn (ip, bb2);\n \t    }\n \t  s = s->outer;\n \t}"}, {"sha": "00645c221b8209bd617c25ac009665a084dbfb10", "filename": "gcc/cfg.c", "status": "modified", "additions": 33, "deletions": 28, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=3c030e88e793d2aff78a76e9df248bc029c9048c", "patch": "@@ -451,6 +451,9 @@ expunge_block (b)\n       x->index = i;\n     }\n \n+  /* Invalidate data to make bughunting easier.  */\n+  memset (b, 0, sizeof (*b));\n+  b->index = -3;\n   basic_block_info->num_elements--;\n   n_basic_blocks--;\n }\n@@ -552,6 +555,16 @@ compute_bb_for_insn (max)\n     }\n }\n \n+/* Release the basic_block_for_insn array.  */\n+\n+void\n+free_bb_for_insn ()\n+{\n+  if (basic_block_for_insn)\n+    VARRAY_FREE (basic_block_for_insn);\n+  basic_block_for_insn = 0;\n+}\n+\n /* Update insns block within BB.  */\n \n void\n@@ -933,7 +946,7 @@ merge_blocks_nomove (a, b)\n \t}\n #endif\n \n-      a_end = prev;\n+      a_end = PREV_INSN (del_first);\n     }\n   else if (GET_CODE (NEXT_INSN (a_end)) == BARRIER)\n     del_first = NEXT_INSN (a_end);\n@@ -960,13 +973,14 @@ merge_blocks_nomove (a, b)\n   /* Reassociate the insns of B with A.  */\n   if (!b_empty)\n     {\n+      rtx x = a_end;\n       if (basic_block_for_insn)\n \t{\n-\t  BLOCK_FOR_INSN (b_head) = a;\n-\t  while (b_head != b_end)\n+\t  BLOCK_FOR_INSN (x) = a;\n+\t  while (x != b_end)\n \t    {\n-\t      b_head = NEXT_INSN (b_head);\n-\t      BLOCK_FOR_INSN (b_head) = a;\n+\t      x = NEXT_INSN (x);\n+\t      BLOCK_FOR_INSN (x) = a;\n \t    }\n \t}\n       a_end = b_end;\n@@ -1061,8 +1075,6 @@ try_redirect_by_replacing_jump (e, target)\n       src->end = emit_jump_insn_before (gen_jump (target_label), kill_from);\n       JUMP_LABEL (src->end) = target_label;\n       LABEL_NUSES (target_label)++;\n-      if (basic_block_for_insn)\n-\tset_block_for_new_insns (src->end, src);\n       if (rtl_dump_file)\n \tfprintf (rtl_dump_file, \"Replacing insn %i by jump %i\\n\",\n \t\t INSN_UID (insn), INSN_UID (src->end));\n@@ -1279,11 +1291,9 @@ force_nonfallthru_and_redirect (e, target)\n     jump_block = e->src;\n   e->flags &= ~EDGE_FALLTHRU;\n   label = block_label (target);\n-  jump_block->end = emit_jump_insn_after (gen_jump (label), jump_block->end);\n+  emit_jump_insn_after (gen_jump (label), jump_block->end);\n   JUMP_LABEL (jump_block->end) = label;\n   LABEL_NUSES (label)++;\n-  if (basic_block_for_insn)\n-    set_block_for_new_insns (jump_block->end, jump_block);\n   emit_barrier_after (jump_block->end);\n   redirect_edge_succ_nodup (e, target);\n \n@@ -1641,28 +1651,13 @@ commit_one_edge_insertion (e)\n \n   /* Now that we've found the spot, do the insertion.  */\n \n-  /* Set the new block number for these insns, if structure is allocated.  */\n-  if (basic_block_for_insn)\n-    {\n-      rtx i;\n-      for (i = insns; i != NULL_RTX; i = NEXT_INSN (i))\n-\tset_block_for_insn (i, bb);\n-    }\n-\n   if (before)\n     {\n       emit_insns_before (insns, before);\n-      if (before == bb->head)\n-\tbb->head = insns;\n-\n       last = prev_nonnote_insn (before);\n     }\n   else\n-    {\n-      last = emit_insns_after (insns, after);\n-      if (after == bb->end)\n-\tbb->end = last;\n-    }\n+    last = emit_insns_after (insns, after);\n \n   if (returnjump_p (last))\n     {\n@@ -1679,7 +1674,6 @@ commit_one_edge_insertion (e)\n       e->flags &= ~EDGE_FALLTHRU;\n \n       emit_barrier_after (last);\n-      bb->end = last;\n \n       if (before)\n \tflow_delete_insn (before);\n@@ -1696,7 +1690,6 @@ commit_edge_insertions ()\n {\n   int i;\n   basic_block bb;\n-  compute_bb_for_insn (get_max_uid ());\n \n #ifdef ENABLE_CHECKING\n   verify_flow_info ();\n@@ -2171,6 +2164,18 @@ verify_flow_info ()\n \t  edge_checksum[e->dest->index + 2] -= (size_t) e;\n \t  e = e->pred_next;\n \t}\n+       for (x = bb->head; x != NEXT_INSN (bb->end); x = NEXT_INSN (x))\n+\t if (basic_block_for_insn && BLOCK_FOR_INSN (x) != bb)\n+\t   {\n+\t     debug_rtx (x);\n+\t     if (! BLOCK_FOR_INSN (x))\n+\t       error (\"Insn %d is inside basic block %d but block_for_insn is NULL\",\n+\t\t      INSN_UID (x), bb->index);\n+\t     else\n+\t       error (\"Insn %d is inside basic block %d but block_for_insn is %i\",\n+\t\t      INSN_UID (x), bb->index, BLOCK_FOR_INSN (x)->index);\n+\t     err = 1;\n+\t   }\n \n       /* OK pointers are correct.  Now check the header of basic\n          block.  It ought to contain optional CODE_LABEL followed"}, {"sha": "85185e562b34bb212fba46d11e78a06884bd4a12", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=3c030e88e793d2aff78a76e9df248bc029c9048c", "patch": "@@ -604,8 +604,6 @@ find_basic_blocks (f, nregs, file)\n   int max_uid;\n   timevar_push (TV_CFG);\n \n-  if (basic_block_for_insn)\n-    VARRAY_FREE (basic_block_for_insn);\n   basic_block_for_insn = 0;\n \n   /* Flush out existing data.  */"}, {"sha": "7e227f6ecf9474800888c4a30b241eea6eba09fa", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=3c030e88e793d2aff78a76e9df248bc029c9048c", "patch": "@@ -290,7 +290,7 @@ merge_blocks_move_predecessor_nojumps (a, b)\n \n   /* Scramble the insn chain.  */\n   if (a->end != PREV_INSN (b->head))\n-    reorder_insns (a->head, a->end, PREV_INSN (b->head));\n+    reorder_insns_nobb (a->head, a->end, PREV_INSN (b->head));\n \n   if (rtl_dump_file)\n     {\n@@ -349,7 +349,7 @@ merge_blocks_move_successor_nojumps (a, b)\n   squeeze_notes (&b->head, &b->end);\n \n   /* Scramble the insn chain.  */\n-  reorder_insns (b->head, b->end, a->end);\n+  reorder_insns_nobb (b->head, b->end, a->end);\n \n   /* Now blocks A and B are contiguous.  Merge them.  */\n   merge_blocks_nomove (a, b);\n@@ -904,8 +904,6 @@ try_crossjump_to_edge (mode, e1, e2)\n   src1->end = emit_jump_insn_before (gen_jump (label), newpos1);\n   JUMP_LABEL (src1->end) = label;\n   LABEL_NUSES (label)++;\n-  if (basic_block_for_insn)\n-    set_block_for_new_insns (src1->end, src1);\n \n   /* Delete the now unreachable instructions.  */\n   flow_delete_insn_chain (newpos1, last);"}, {"sha": "ed1c45f7b169628a65ca9e225394706aeac7d457", "filename": "gcc/combine.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=3c030e88e793d2aff78a76e9df248bc029c9048c", "patch": "@@ -717,7 +717,6 @@ combine_instructions (f, nregs)\n \n   if (need_refresh)\n     {\n-      compute_bb_for_insn (get_max_uid ());\n       update_life_info (refresh_blocks, UPDATE_LIFE_GLOBAL_RM_NOTES,\n \t\t\tPROP_DEATH_NOTES);\n     }"}, {"sha": "947ea457ce673b0e65ae368d5640669b7ded373e", "filename": "gcc/df.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2Fdf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2Fdf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.c?ref=3c030e88e793d2aff78a76e9df248bc029c9048c", "patch": "@@ -2959,9 +2959,6 @@ df_pattern_emit_after (df, pattern, bb, insn)\n   if (ret_insn == insn)\n     return ret_insn;\n \n-  if (bb->end == insn)\n-    bb->end = ret_insn;\n-\n   df_insns_modify (df, bb, NEXT_INSN (insn), ret_insn);\n   return ret_insn;\n }\n@@ -2981,9 +2978,6 @@ df_jump_pattern_emit_after (df, pattern, bb, insn)\n   if (ret_insn == insn)\n     return ret_insn;\n \n-  if (bb->end == insn)\n-    bb->end = ret_insn;\n-\n   df_insns_modify (df, bb, NEXT_INSN (insn), ret_insn);\n   return ret_insn;\n }\n@@ -3023,7 +3017,7 @@ df_insn_move_before (df, bb, insn, before_bb, before_insn)\n   /* ???? Perhaps all the insns moved should be stored on a list\n      which df_analyse removes when it recalculates data flow.  */\n \n-  return emit_block_insn_before (insn, before_insn, before_bb);\n+  return emit_insn_before (insn, before_insn);\n }\n \f\n /* Functions to query dataflow information.  */"}, {"sha": "82bff928711d47bce45e2f29e16d63a48d81943d", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 80, "deletions": 31, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=3c030e88e793d2aff78a76e9df248bc029c9048c", "patch": "@@ -2574,7 +2574,7 @@ try_split (pat, trial, last)\n \t      if (GET_CODE (XVECEXP (seq, 0, i)) == INSN)\n \t        mark_label_nuses (PATTERN (XVECEXP (seq, 0, i)));\n \n-\t  tem = emit_insn_after (seq, before);\n+\t  tem = emit_insn_after (seq, trial);\n \n \t  delete_insn (trial);\n \t  if (has_barrier)\n@@ -2710,6 +2710,7 @@ add_insn_after (insn, after)\n      rtx insn, after;\n {\n   rtx next = NEXT_INSN (after);\n+  basic_block bb;\n \n   if (optimize && INSN_DELETED_P (after))\n     abort ();\n@@ -2740,6 +2741,21 @@ add_insn_after (insn, after)\n \tabort ();\n     }\n \n+  if (basic_block_for_insn\n+      && (unsigned int)INSN_UID (after) < basic_block_for_insn->num_elements\n+      && (bb = BLOCK_FOR_INSN (after)))\n+    {\n+      set_block_for_insn (insn, bb);\n+      /* Should not happen as first in the BB is always\n+\t eigther NOTE or LABEL.  */\n+      if (bb->end == after\n+\t  /* Avoid clobbering of structure when creating new BB.  */\n+\t  && GET_CODE (insn) != BARRIER\n+\t  && (GET_CODE (insn) != NOTE\n+\t      || NOTE_LINE_NUMBER (insn) != NOTE_INSN_BASIC_BLOCK))\n+\tbb->end = insn;\n+    }\n+\n   NEXT_INSN (after) = insn;\n   if (GET_CODE (after) == INSN && GET_CODE (PATTERN (after)) == SEQUENCE)\n     {\n@@ -2758,6 +2774,7 @@ add_insn_before (insn, before)\n      rtx insn, before;\n {\n   rtx prev = PREV_INSN (before);\n+  basic_block bb;\n \n   if (optimize && INSN_DELETED_P (before))\n     abort ();\n@@ -2791,6 +2808,21 @@ add_insn_before (insn, before)\n \tabort ();\n     }\n \n+  if (basic_block_for_insn\n+      && (unsigned int)INSN_UID (before) < basic_block_for_insn->num_elements\n+      && (bb = BLOCK_FOR_INSN (before)))\n+    {\n+      set_block_for_insn (insn, bb);\n+      /* Should not happen as first in the BB is always\n+\t eigther NOTE or LABEl.  */\n+      if (bb->head == insn\n+\t  /* Avoid clobbering of structure when creating new BB.  */\n+\t  && GET_CODE (insn) != BARRIER\n+\t  && (GET_CODE (insn) != NOTE\n+\t      || NOTE_LINE_NUMBER (insn) != NOTE_INSN_BASIC_BLOCK))\n+\tabort ();\n+    }\n+\n   PREV_INSN (before) = insn;\n   if (GET_CODE (before) == INSN && GET_CODE (PATTERN (before)) == SEQUENCE)\n     PREV_INSN (XVECEXP (PATTERN (before), 0, 0)) = insn;\n@@ -2879,7 +2911,7 @@ delete_insns_since (from)\n    called after delay-slot filling has been done.  */\n \n void\n-reorder_insns (from, to, after)\n+reorder_insns_nobb (from, to, after)\n      rtx from, to, after;\n {\n   /* Splice this bunch out of where it is now.  */\n@@ -2903,6 +2935,38 @@ reorder_insns (from, to, after)\n     last_insn = to;\n }\n \n+/* Same as function above, but take care to update BB boundaries.  */\n+void\n+reorder_insns (from, to, after)\n+     rtx from, to, after;\n+{\n+  rtx prev = PREV_INSN (from);\n+  basic_block bb, bb2;\n+\n+  reorder_insns_nobb (from, to, after);\n+\n+  if (basic_block_for_insn\n+      && (unsigned int)INSN_UID (after) < basic_block_for_insn->num_elements\n+      && (bb = BLOCK_FOR_INSN (after)))\n+    {\n+      rtx x;\n+ \n+      if (basic_block_for_insn\n+\t  && (unsigned int)INSN_UID (from) < basic_block_for_insn->num_elements\n+\t  && (bb2 = BLOCK_FOR_INSN (from)))\n+\t{\n+\t  if (bb2->end == to)\n+\t    bb2->end = prev;\n+\t}\n+\n+      if (bb->end == after)\n+\tbb->end = to;\n+\n+      for (x = from; x != NEXT_INSN (to); x = NEXT_INSN (x))\n+\tset_block_for_insn (x, bb);\n+    }\n+}\n+\n /* Return the line note insn preceding INSN.  */\n \n static rtx\n@@ -3089,20 +3153,6 @@ emit_insn_before (pattern, before)\n   return insn;\n }\n \n-/* Similar to emit_insn_before, but update basic block boundaries as well.  */\n-\n-rtx\n-emit_block_insn_before (pattern, before, block)\n-     rtx pattern, before;\n-     basic_block block;\n-{\n-  rtx prev = PREV_INSN (before);\n-  rtx r = emit_insn_before (pattern, before);\n-  if (block && block->head == before)\n-    block->head = NEXT_INSN (prev);\n-  return r;\n-}\n-\n /* Make an instruction with body PATTERN and code JUMP_INSN\n    and output it before the instruction BEFORE.  */\n \n@@ -3243,19 +3293,6 @@ emit_insn_after_with_line_notes (pattern, after, from)\n \t\t\t  insn);\n }\n \n-/* Similar to emit_insn_after, but update basic block boundaries as well.  */\n-\n-rtx\n-emit_block_insn_after (pattern, after, block)\n-     rtx pattern, after;\n-     basic_block block;\n-{\n-  rtx r = emit_insn_after (pattern, after);\n-  if (block && block->end == after)\n-    block->end = r;\n-  return r;\n-}\n-\n /* Make an insn of code JUMP_INSN with body PATTERN\n    and output it after the insn AFTER.  */\n \n@@ -3431,15 +3468,27 @@ emit_insns_after (first, after)\n {\n   register rtx last;\n   register rtx after_after;\n+  basic_block bb;\n \n   if (!after)\n     abort ();\n \n   if (!first)\n     return first;\n \n-  for (last = first; NEXT_INSN (last); last = NEXT_INSN (last))\n-    continue;\n+  if (basic_block_for_insn\n+      && (unsigned int)INSN_UID (after) < basic_block_for_insn->num_elements\n+      && (bb = BLOCK_FOR_INSN (after)))\n+    {\n+      for (last = first; NEXT_INSN (last); last = NEXT_INSN (last))\n+\tset_block_for_insn (last, bb);\n+      set_block_for_insn (last, bb);\n+      if (bb->end == after)\n+\tbb->end = last;\n+    }\n+  else\n+    for (last = first; NEXT_INSN (last); last = NEXT_INSN (last))\n+      continue;\n \n   after_after = NEXT_INSN (after);\n "}, {"sha": "24352bfadc527b85f7c21520a7aa164ae7298df1", "filename": "gcc/flow.c", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=3c030e88e793d2aff78a76e9df248bc029c9048c", "patch": "@@ -377,8 +377,6 @@ check_function_return_warnings ()\n \t{\n \t  /* Recompute insn->block mapping, since the initial mapping is\n \t     set before we delete unreachable blocks.  */\n-\t  compute_bb_for_insn (max_uid);\n-\n \t  if (BLOCK_FOR_INSN (cfun->x_clobber_return_insn) != NULL)\n \t    warning (\"control reaches end of non-void function\");\n \t}\n@@ -739,12 +737,6 @@ void\n free_basic_block_vars (keep_head_end_p)\n      int keep_head_end_p;\n {\n-  if (basic_block_for_insn)\n-    {\n-      VARRAY_FREE (basic_block_for_insn);\n-      basic_block_for_insn = NULL;\n-    }\n-\n   if (! keep_head_end_p)\n     {\n       if (basic_block_info)\n@@ -3099,10 +3091,6 @@ attempt_auto_inc (pbi, inc, insn, mem, incr, incr_reg)\n       insns = get_insns ();\n       end_sequence ();\n \n-      if (basic_block_for_insn)\n-\tfor (temp = insns; temp; temp = NEXT_INSN (temp))\n-\t  set_block_for_insn (temp, pbi->bb);\n-\n       /* If we can't make the auto-inc, or can't make the\n \t replacement into Y, exit.  There's no point in making\n \t the change below if we can't do the auto-inc and doing"}, {"sha": "e6a269e6dc74617f91faca70ec78201f5668ca57", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=3c030e88e793d2aff78a76e9df248bc029c9048c", "patch": "@@ -7118,16 +7118,7 @@ emit_return_into_block (bb, line_note)\n   end = emit_jump_insn_after (gen_return (), bb->end);\n   if (line_note)\n     emit_line_note_after (NOTE_SOURCE_FILE (line_note),\n-\t\t\t  NOTE_LINE_NUMBER (line_note), bb->end);\n-\n-  while (1)\n-    {\n-      set_block_for_insn (p, bb);\n-      if (p == bb->end)\n-\tbreak;\n-      p = PREV_INSN (p);\n-    }\n-  bb->end = end;\n+\t\t\t  NOTE_LINE_NUMBER (line_note), PREV_INSN (bb->end));\n }\n #endif /* HAVE_return */\n \n@@ -7418,10 +7409,6 @@ thread_prologue_and_epilogue_insns (f)\n       i = PREV_INSN (insn);\n       newinsn = emit_insn_before (seq, insn);\n \n-      /* Update the UID to basic block map.  */\n-      for (i = NEXT_INSN (i); i != insn; i = NEXT_INSN (i))\n-\tset_block_for_insn (i, bb);\n-\n       /* Retain a map of the epilogue insns.  Used in life analysis to\n \t avoid getting rid of sibcall epilogue insns.  */\n       record_insns (GET_CODE (seq) == SEQUENCE"}, {"sha": "8e3187be247c490e5072da873be77c428605f37d", "filename": "gcc/gcse.c", "status": "modified", "additions": 3, "deletions": 31, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=3c030e88e793d2aff78a76e9df248bc029c9048c", "patch": "@@ -3508,9 +3508,6 @@ handle_avail_expr (insn, expr)\n \t\t\t\t\tSET_DEST (expr_set)),\n \t\t\t   insn_computes_expr);\n \n-      /* Keep block number table up to date.  */\n-      set_block_for_new_insns (new_insn, BLOCK_FOR_INSN (insn_computes_expr));\n-\n       /* Keep register set table up to date.  */\n       record_one_set (REGNO (to), new_insn);\n \n@@ -4636,7 +4633,7 @@ insert_insn_end_bb (expr, bb, pre)\n \t}\n #endif\n       /* FIXME: What if something in cc0/jump uses value set in new insn?  */\n-      new_insn = emit_block_insn_before (pat, insn, bb);\n+      new_insn = emit_insn_before (pat, insn);\n     }\n \n   /* Likewise if the last insn is a call, as will happen in the presence\n@@ -4674,13 +4671,10 @@ insert_insn_end_bb (expr, bb, pre)\n \t     || NOTE_INSN_BASIC_BLOCK_P (insn))\n \tinsn = NEXT_INSN (insn);\n \n-      new_insn = emit_block_insn_before (pat, insn, bb);\n+      new_insn = emit_insn_before (pat, insn);\n     }\n   else\n-    {\n-      new_insn = emit_insn_after (pat, insn);\n-      bb->end = new_insn;\n-    }\n+    new_insn = emit_insn_after (pat, insn);\n \n   /* Keep block number table up to date.\n      Note, PAT could be a multiple insn sequence, we have to make\n@@ -4690,8 +4684,6 @@ insert_insn_end_bb (expr, bb, pre)\n       for (i = 0; i < XVECLEN (pat, 0); i++)\n \t{\n \t  rtx insn = XVECEXP (pat, 0, i);\n-\n-\t  set_block_for_insn (insn, bb);\n \t  if (INSN_P (insn))\n \t    add_label_notes (PATTERN (insn), new_insn);\n \n@@ -4701,7 +4693,6 @@ insert_insn_end_bb (expr, bb, pre)\n   else\n     {\n       add_label_notes (SET_SRC (pat), new_insn);\n-      set_block_for_new_insns (new_insn, bb);\n \n       /* Keep register set table up to date.  */\n       record_one_set (regno, new_insn);\n@@ -4815,20 +4806,14 @@ pre_insert_copy_insn (expr, insn)\n   int indx = expr->bitmap_index;\n   rtx set = single_set (insn);\n   rtx new_insn;\n-  basic_block bb = BLOCK_FOR_INSN (insn);\n \n   if (!set)\n     abort ();\n \n   new_insn = emit_insn_after (gen_move_insn (reg, SET_DEST (set)), insn);\n \n-  /* Keep block number table up to date.  */\n-  set_block_for_new_insns (new_insn, bb);\n-\n   /* Keep register set table up to date.  */\n   record_one_set (regno, new_insn);\n-  if (insn == bb->end)\n-    bb->end = new_insn;\n \n   gcse_create_count++;\n \n@@ -6254,7 +6239,6 @@ update_ld_motion_stores (expr)\n \t  copy = gen_move_insn ( reg, SET_SRC (pat));\n \t  new = emit_insn_before (copy, insn);\n \t  record_one_set (REGNO (reg), new);\n-\t  set_block_for_new_insns (new, BLOCK_FOR_INSN (insn));\n \t  SET_SRC (pat) = reg;\n \n \t  /* un-recognize this pattern since it's probably different now.  */\n@@ -6753,11 +6737,6 @@ insert_insn_start_bb (insn, bb)\n \n   insn = emit_insn_after (insn, prev);\n \n-  if (prev == bb->end)\n-    bb->end = insn;\n-\n-  set_block_for_new_insns (insn, bb);\n-\n   if (gcse_file)\n     {\n       fprintf (gcse_file, \"STORE_MOTION  insert store at start of BB %d:\\n\",\n@@ -6846,7 +6825,6 @@ replace_store_insn (reg, del, bb)\n   \n   insn = gen_move_insn (reg, SET_SRC (PATTERN (del)));\n   insn = emit_insn_after (insn, del);\n-  set_block_for_new_insns (insn, bb);\n   \n   if (gcse_file)\n     {\n@@ -6858,12 +6836,6 @@ replace_store_insn (reg, del, bb)\n       fprintf(gcse_file, \"\\n\");\n     }\n   \n-  if (bb->end == del)\n-    bb->end = insn;\n-  \n-  if (bb->head == del)\n-    bb->head = insn;\n-  \n   delete_insn (del);\n }\n "}, {"sha": "fe4153d2b3e92c78b9b22d7ff65dbf1be0a712bd", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=3c030e88e793d2aff78a76e9df248bc029c9048c", "patch": "@@ -1971,7 +1971,11 @@ sched_init (dump_file)\n \t  && GET_CODE (insn) != CODE_LABEL\n \t  /* Don't emit a NOTE if it would end up before a BARRIER.  */\n \t  && GET_CODE (NEXT_INSN (insn)) != BARRIER))\n-    emit_note_after (NOTE_INSN_DELETED, BLOCK_END (n_basic_blocks - 1));\n+    {\n+      emit_note_after (NOTE_INSN_DELETED, BLOCK_END (n_basic_blocks - 1));\n+      /* Make insn to appear outside BB.  */\n+      BLOCK_END (n_basic_blocks - 1) = PREV_INSN (BLOCK_END (n_basic_blocks - 1));\n+    }\n \n   /* Compute INSN_REG_WEIGHT for all blocks.  We must do this before\n      removing death notes.  */"}, {"sha": "4a76d2290e09112213e50233bf01833100657f6e", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=3c030e88e793d2aff78a76e9df248bc029c9048c", "patch": "@@ -1796,7 +1796,7 @@ noce_process_if_block (test_bb, then_bb, else_bb, join_bb)\n       insn_b = gen_sequence ();\n       end_sequence ();\n \n-      test_bb->end = emit_insn_after (insn_b, test_bb->end);\n+      emit_insn_after (insn_b, test_bb->end);\n     }\n \n   /* Merge the blocks!  */\n@@ -2723,9 +2723,6 @@ if_convert (x_life_data_ok)\n   if (rtl_dump_file)\n     fflush (rtl_dump_file);\n \n-  /* Rebuild basic_block_for_insn for update_life_info and for gcse.  */\n-  compute_bb_for_insn (get_max_uid ());\n-\n   /* Rebuild life info for basic blocks that require it.  */\n   if (num_removed_blocks && life_data_ok)\n     {"}, {"sha": "95cc8fbdf80f9d9431c429aa2ad53b2df3c02bc1", "filename": "gcc/lcm.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=3c030e88e793d2aff78a76e9df248bc029c9048c", "patch": "@@ -1251,7 +1251,7 @@ optimize_mode_switching (file)\n \t\t     the case of EH edges, EH entry points also start\n \t\t     in normal mode, so a similar reasoning applies.  */\n \t\t  else if (GET_CODE (src_bb->end) == INSN)\n-\t\t    src_bb->end = emit_insn_after (mode_set, src_bb->end);\n+\t\t    emit_insn_after (mode_set, src_bb->end);\n \t\t  else\n \t\t    abort ();\n \t\t  bb_info[j][src_bb->index].computing = mode;\n@@ -1313,7 +1313,7 @@ optimize_mode_switching (file)\n \t\t  if (GET_CODE (eg->src->end) == JUMP_INSN)\n \t\t    emit_insn_before (mode_set, eg->src->end);\n \t\t  else if (GET_CODE (eg->src->end) == INSN)\n-\t\t    eg->src->end = emit_insn_after (mode_set, eg->src->end);\n+\t\t    emit_insn_after (mode_set, eg->src->end);\n \t\t  else\n \t\t    abort ();\n \t\t}\n@@ -1345,11 +1345,9 @@ optimize_mode_switching (file)\n \t\t  if (GET_CODE (ptr->insn_ptr) == NOTE\n \t\t      && (NOTE_LINE_NUMBER (ptr->insn_ptr)\n \t\t\t  == NOTE_INSN_BASIC_BLOCK))\n-\t\t    emit_block_insn_after (mode_set, ptr->insn_ptr,\n-\t\t                           BASIC_BLOCK (ptr->bbnum));\n+\t\t    emit_insn_after (mode_set, ptr->insn_ptr);\n \t\t  else\n-\t\t    emit_block_insn_before (mode_set, ptr->insn_ptr,\n-\t\t\t\t\t    BASIC_BLOCK (ptr->bbnum));\n+\t\t    emit_insn_before (mode_set, ptr->insn_ptr);\n \t\t}\n \n \t      free (ptr);"}, {"sha": "21de5e5f29b279aa9f3c66e48aa20a4599149290", "filename": "gcc/recog.c", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=3c030e88e793d2aff78a76e9df248bc029c9048c", "patch": "@@ -2742,10 +2742,14 @@ split_all_insns (upd_life)\n \t  last = split_insn (insn);\n \t  if (last)\n \t    {\n+\t      /* The split sequence may include barrier, but the\n+\t\t BB boundary we are interested in will be set to previous\n+\t\t one.  */\n+\n+\t      while (GET_CODE (last) == BARRIER)\n+\t\tlast = PREV_INSN (last);\n \t      SET_BIT (blocks, i);\n \t      changed = 1;\n-\t      if (insn == bb->end)\n-\t\tbb->end = last;\n \t      insn = last;\n \t    }\n \n@@ -2759,7 +2763,6 @@ split_all_insns (upd_life)\n \n   if (changed)\n     {\n-      compute_bb_for_insn (get_max_uid ());\n       for (i = 0; i < n_basic_blocks; i++)\n \tfind_sub_basic_blocks (BASIC_BLOCK (i));\n     }\n@@ -3061,14 +3064,8 @@ peephole2_optimize (dump_file)\n \t\t    i -= MAX_INSNS_PER_PEEP2 + 1;\n \n \t\t  /* Replace the old sequence with the new.  */\n+\t\t  try = emit_insn_after (try, peep2_insn_data[i].insn);\n \t\t  flow_delete_insn_chain (insn, peep2_insn_data[i].insn);\n-\t\t  try = emit_insn_after (try, prev);\n-\n-\t\t  /* Adjust the basic block boundaries.  */\n-\t\t  if (peep2_insn_data[i].insn == bb->end)\n-\t\t    bb->end = try;\n-\t\t  if (insn == bb->head)\n-\t\t    bb->head = NEXT_INSN (prev);\n \n #ifdef HAVE_conditional_execution\n \t\t  /* With conditional execution, we cannot back up the"}, {"sha": "a8a9ef12e38d306ef6eb77dc124ba3f5809ac117", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=3c030e88e793d2aff78a76e9df248bc029c9048c", "patch": "@@ -964,9 +964,9 @@ emit_pop_insn (insn, regstack, reg, where)\n \t\t\t FP_MODE_REG (FIRST_STACK_REG, DFmode));\n \n   if (where == EMIT_AFTER)\n-    pop_insn = emit_block_insn_after (pop_rtx, insn, current_block);\n+    pop_insn = emit_insn_after (pop_rtx, insn);\n   else\n-    pop_insn = emit_block_insn_before (pop_rtx, insn, current_block);\n+    pop_insn = emit_insn_before (pop_rtx, insn);\n \n   REG_NOTES (pop_insn)\n     = gen_rtx_EXPR_LIST (REG_DEAD, FP_MODE_REG (FIRST_STACK_REG, DFmode),\n@@ -1062,9 +1062,9 @@ emit_swap_insn (insn, regstack, reg)\n \t\t\t FP_MODE_REG (FIRST_STACK_REG, XFmode));\n \n   if (i1)\n-    emit_block_insn_after (swap_rtx, i1, current_block);\n+    emit_insn_after (swap_rtx, i1);\n   else if (current_block)\n-    emit_block_insn_before (swap_rtx, current_block->head, current_block);\n+    emit_insn_before (swap_rtx, current_block->head);\n   else\n     emit_insn_before (swap_rtx, insn);\n }\n@@ -2748,7 +2748,7 @@ convert_regs_1 (file, block)\n \n \t  set = gen_rtx_SET (VOIDmode, FP_MODE_REG (reg, SFmode),\n \t\t\t     nan);\n-\t  insn = emit_block_insn_after (set, insn, block);\n+\t  insn = emit_insn_after (set, insn);\n \t  subst_stack_regs (insn, &regstack);\n \t}\n     }"}, {"sha": "32303a562622cedde6428c2892ea1b1633671e68", "filename": "gcc/reload1.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=3c030e88e793d2aff78a76e9df248bc029c9048c", "patch": "@@ -1266,6 +1266,7 @@ reload (first, global)\n   /* Free all the insn_chain structures at once.  */\n   obstack_free (&reload_obstack, reload_startobj);\n   unused_insn_chains = 0;\n+  compute_bb_for_insn (get_max_uid ());\n   fixup_abnormal_edges ();\n \n   return failure;"}, {"sha": "0ac125e463eb0c4a7857f62d42c7edac93f71f8a", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=3c030e88e793d2aff78a76e9df248bc029c9048c", "patch": "@@ -1743,6 +1743,7 @@ extern void mark_reg_pointer\t\t\tPARAMS ((rtx, int));\n extern void mark_user_reg\t\t\tPARAMS ((rtx));\n extern void reset_used_flags\t\t\tPARAMS ((rtx));\n extern void reorder_insns\t\t\tPARAMS ((rtx, rtx, rtx));\n+extern void reorder_insns_nobb\t\t\tPARAMS ((rtx, rtx, rtx));\n extern int get_max_uid\t\t\t\tPARAMS ((void));\n extern int in_sequence_p\t\t\tPARAMS ((void));\n extern void force_next_line_note\t\tPARAMS ((void));"}, {"sha": "82be6776585e69d8b113321e98eb9377cef33fb4", "filename": "gcc/ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2Fssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2Fssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa.c?ref=3c030e88e793d2aff78a76e9df248bc029c9048c", "patch": "@@ -2121,7 +2121,7 @@ rename_equivalent_regs (reg_partition)\n \n \t\t  PATTERN (insn) = XVECEXP (s, 0, slen-1);\n \t\t  for (i = 0; i < slen - 1; i++)\n-\t\t    emit_block_insn_before (XVECEXP (s, 0, i), insn, b);\n+\t\t    emit_insn_before (XVECEXP (s, 0, i), insn);\n \t\t}\n \t    }\n "}, {"sha": "63643051639dc98e59794a17275cc7abb1367553", "filename": "gcc/toplev.c", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c030e88e793d2aff78a76e9df248bc029c9048c/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=3c030e88e793d2aff78a76e9df248bc029c9048c", "patch": "@@ -2751,6 +2751,9 @@ rest_of_compilation (decl)\n \t      find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n \t      cleanup_cfg (CLEANUP_PRE_SIBCALL | CLEANUP_PRE_LOOP);\n \t      optimize = saved_optimize;\n+\n+\t      /* CFG is no longer maitained up-to-date.  */\n+\t      free_bb_for_insn ();\n \t    }\n \n \t  current_function_nothrow = nothrow_function_p ();\n@@ -2859,6 +2862,9 @@ rest_of_compilation (decl)\n   rebuild_jump_labels (insns);\n   find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n   cleanup_cfg ((optimize ? CLEANUP_EXPENSIVE : 0) | CLEANUP_PRE_LOOP);\n+\n+  /* CFG is no longer maitained up-to-date.  */\n+  free_bb_for_insn ();\n   copy_loop_headers (insns);\n   purge_line_number_notes (insns);\n \n@@ -2940,6 +2946,8 @@ rest_of_compilation (decl)\n       timevar_pop (TV_FROM_SSA);\n \n       ggc_collect ();\n+      /* CFG is no longer maitained up-to-date.  */\n+      free_bb_for_insn ();\n     }\n \n   timevar_push (TV_JUMP);\n@@ -2957,6 +2965,8 @@ rest_of_compilation (decl)\n       if_convert (0);\n       timevar_pop (TV_IFCVT);\n \n+      /* CFG is no longer maitained up-to-date.  */\n+      free_bb_for_insn ();\n       /* Try to identify useless null pointer tests and delete them.  */\n       if (flag_delete_null_pointer_checks)\n \tdelete_null_pointer_checks (insns);\n@@ -3006,6 +3016,8 @@ rest_of_compilation (decl)\n \t  find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n \t  cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n \t  timevar_pop (TV_JUMP);\n+\t  /* CFG is no longer maitained up-to-date.  */\n+\t  free_bb_for_insn ();\n \t}\n \n       /* Run this after jump optmizations remove all the unreachable code\n@@ -3021,6 +3033,8 @@ rest_of_compilation (decl)\n \t  cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n \n \t  delete_null_pointer_checks (insns);\n+\t  /* CFG is no longer maitained up-to-date.  */\n+\t  free_bb_for_insn ();\n \t  timevar_pop (TV_JUMP);\n \t}\n \n@@ -3059,6 +3073,8 @@ rest_of_compilation (decl)\n       save_cfj = flag_cse_follow_jumps;\n       flag_cse_skip_blocks = flag_cse_follow_jumps = 0;\n \n+      /* CFG is no longer maitained up-to-date.  */\n+      free_bb_for_insn ();\n       /* If -fexpensive-optimizations, re-run CSE to clean up things done\n \t by gcse.  */\n       if (flag_expensive_optimizations)\n@@ -3080,6 +3096,8 @@ rest_of_compilation (decl)\n \t  delete_trivially_dead_insns (insns, max_reg_num (), 0);\n \t  find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n \t  cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n+\t  /* CFG is no longer maitained up-to-date.  */\n+\t  free_bb_for_insn ();\n \t  timevar_pop (TV_JUMP);\n \n \t  if (flag_expensive_optimizations)\n@@ -3105,6 +3123,7 @@ rest_of_compilation (decl)\n     {\n       timevar_push (TV_LOOP);\n       open_dump_file (DFI_loop, decl);\n+      free_bb_for_insn ();\n \n       if (flag_rerun_loop_opt)\n \t{\n@@ -3166,6 +3185,8 @@ rest_of_compilation (decl)\n \n \t  timevar_pop (TV_JUMP);\n \n+\t  /* CFG is no longer maitained up-to-date.  */\n+\t  free_bb_for_insn ();\n \t  reg_scan (insns, max_reg_num (), 0);\n \t  tem = cse_main (insns, max_reg_num (), 1, rtl_dump_file);\n \n@@ -3175,6 +3196,8 @@ rest_of_compilation (decl)\n \t      rebuild_jump_labels (insns);\n \t      find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n \t      cleanup_cfg (CLEANUP_EXPENSIVE);\n+\t      /* CFG is no longer maitained up-to-date.  */\n+\t      free_bb_for_insn ();\n \t      timevar_pop (TV_JUMP);\n \t    }\n \t}\n@@ -3488,8 +3511,6 @@ rest_of_compilation (decl)\n   verify_flow_info ();\n #endif\n \n-  compute_bb_for_insn (get_max_uid ());\n-\n   /* If optimizing, then go ahead and split insns now.  */\n   if (optimize > 0)\n     split_all_insns (0);\n@@ -3594,7 +3615,7 @@ rest_of_compilation (decl)\n \n   reg_to_stack (insns, rtl_dump_file);\n \n-  close_dump_file (DFI_stack, print_rtl, insns);\n+  close_dump_file (DFI_stack, print_rtl_with_bb, insns);\n   timevar_pop (TV_REG_STACK);\n \n   ggc_collect ();\n@@ -3619,6 +3640,9 @@ rest_of_compilation (decl)\n     }\n   compute_alignments ();\n \n+  /* CFG is no longer maitained up-to-date.  */\n+  free_bb_for_insn ();\n+\n   /* If a machine dependent reorganization is needed, call it.  */\n #ifdef MACHINE_DEPENDENT_REORG\n   timevar_push (TV_MACH_DEP);\n@@ -3632,8 +3656,6 @@ rest_of_compilation (decl)\n   ggc_collect ();\n #endif\n \n-  /* CFG no longer kept up to date.  */\n-\n   purge_line_number_notes (insns);\n   cleanup_barriers ();\n "}]}