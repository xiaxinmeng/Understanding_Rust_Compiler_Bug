{"sha": "43a8b705906034ecb3edfb54558a34bd362a7213", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDNhOGI3MDU5MDYwMzRlY2IzZWRmYjU0NTU4YTM0YmQzNjJhNzIxMw==", "commit": {"author": {"name": "Harsha Jagasia", "email": "harsha.jagasia@amd.com", "date": "2009-11-04T16:22:47Z"}, "committer": {"name": "Dwarakanath Rajagopal", "email": "dwarak@gcc.gnu.org", "date": "2009-11-04T16:22:47Z"}, "message": "config.gcc (i[34567]86-*-*): Include xopintrin.h.\n\n2009-11-04  Harsha Jagasia  <harsha.jagasia@amd.com>\n            Dwarakanath Rajagopal  <dwarak.rajagopal@amd.com>\n        \n        * config.gcc (i[34567]86-*-*): Include xopintrin.h.\n        (x86_64-*-*): Ditto.\n        * config/i386/xopintrin.h: New file, provide common x86 compiler\n        intrinisics for XOP.\n        * config/i386/cpuid.h (bit_XOP): Define XOP bit.\n        * config/i386/x86intrin.h: Add XOP check and xopintrin.h.\n        * config/i386/i386-c.c(ix86_target_macros_internal): Check\n        ISA_FLAG for XOP. \n        * config/i386/i386.h(TARGET_XOP): New macro for XOP.\n        * config/i386/i386.opt (-mxop): New switch for XOP support.\n        * config/i386/i386.md (UNSPEC_XOP_UNSIGNED_CMP)\n        (UNSPEC_XOP_TRUEFALSE)\n        (UNSPEC_XOP_PERMUTE)\n        (UNSPEC_FRCZ): Add new UNSPEC for XOP support.\n        (PPERM_*): New constants for vpperm instruction.\n        (xop_pcmov_<mode>): Add XOP conditional mov instructions.\n        * config/i386/i386.c (OPTION_MASK_ISA_XOP_SET): New.\n        (OPTION_MASK_ISA_XOP_UNSET): New.       \n        (OPTION_MASK_ISA_XOP_UNSET): Change definition to\n        depend on XOP.\n        (ix86_handle_option): Handle -mxop.\n        (isa_opts): Handle -mxop.\n        (enum pta_flags): Add PTA_XOP.\n        (override_options): Add XOP support.\n        (print_operand): Add code for XOP compare instructions.\n        (ix86_expand_sse_movcc): Extend for XOP conditional move\ninstruction.\n        (ix86_expand_int_vcond): Extend for XOP compare instruction.\n\n        (IX86_BUILTIN_VPCMOV): New for XOP intrinsic.\n        (IX86_BUILTIN_VPCMOV_V2DI): Ditto.\n        (IX86_BUILTIN_VPCMOV_V4SI): Ditto.\n        (IX86_BUILTIN_VPCMOV_V8HI): Ditto.\n        (IX86_BUILTIN_VPCMOV_V16QI): Ditto.\n        (IX86_BUILTIN_VPCMOV_V4SF): Ditto.\n        (IX86_BUILTIN_VPCMOV_V2DF): Ditto.\n\n        (IX86_BUILTIN_VPCMOV256): Ditto.\n        (IX86_BUILTIN_VPCMOV_V4DI256): Ditto.\n        (IX86_BUILTIN_VPCMOV_V8SI256): Ditto.\n        (IX86_BUILTIN_VPCMOV_V16HI256): Ditto.\n        (IX86_BUILTIN_VPCMOV_V32QI256): Ditto.\n        (IX86_BUILTIN_VPCMOV_V8SF256): Ditto.\n        (IX86_BUILTIN_VPCMOV_V4DF256): Ditto.\n\n        (IX86_BUILTIN_VPPERM): Ditto.\n\n        (IX86_BUILTIN_VPMACSSWW): Ditto.\n        (IX86_BUILTIN_VPMACSWW): Ditto.\n        (IX86_BUILTIN_VPMACSSWD): Ditto.\n        (IX86_BUILTIN_VPMACSWD): Ditto.\n        (IX86_BUILTIN_VPMACSSDD): Ditto.\n        (IX86_BUILTIN_VPMACSDD): Ditto.\n        (IX86_BUILTIN_VPMACSSDQL): Ditto.\n        (IX86_BUILTIN_VPMACSSDQH): Ditto.\n        (IX86_BUILTIN_VPMACSDQL): Ditto.\n        (IX86_BUILTIN_VPMACSDQH): Ditto.\n        (IX86_BUILTIN_VPMADCSSWD): Ditto.\n        (IX86_BUILTIN_VPMADCSWD): Ditto.\n\n        (IX86_BUILTIN_VPHADDBW): Ditto.\n        (IX86_BUILTIN_VPHADDBD): Ditto.\n        (IX86_BUILTIN_VPHADDBQ): Ditto.\n        (IX86_BUILTIN_VPHADDWD): Ditto.\n        (IX86_BUILTIN_VPHADDWQ): Ditto.\n        (IX86_BUILTIN_VPHADDDQ): Ditto.\n        (IX86_BUILTIN_VPHADDUBW): Ditto.\n        (IX86_BUILTIN_VPHADDUBD): Ditto.\n        (IX86_BUILTIN_VPHADDUBQ): Ditto.\n        (IX86_BUILTIN_VPHADDUWD): Ditto.\n        (IX86_BUILTIN_VPHADDUWQ): Ditto.\n        (IX86_BUILTIN_VPHADDUDQ): Ditto.\n        (IX86_BUILTIN_VPHSUBBW): Ditto.\n        (IX86_BUILTIN_VPHSUBWD): Ditto.\n        (IX86_BUILTIN_VPHSUBDQ): Ditto.\n\n        (IX86_BUILTIN_VPROTB): Ditto.\n        (IX86_BUILTIN_VPROTW): Ditto.\n        (IX86_BUILTIN_VPROTD): Ditto.\n        (IX86_BUILTIN_VPROTQ): Ditto.\n        (IX86_BUILTIN_VPROTB_IMM): Ditto.\n        (IX86_BUILTIN_VPROTW_IMM): Ditto.\n        (IX86_BUILTIN_VPROTD_IMM): Ditto.\n        (IX86_BUILTIN_VPROTQ_IMM): Ditto.\n\n        (IX86_BUILTIN_VPSHLB): Ditto.\n        (IX86_BUILTIN_VPSHLW): Ditto.\n        (IX86_BUILTIN_VPSHLD): Ditto.\n        (IX86_BUILTIN_VPSHLQ): Ditto.\n        (IX86_BUILTIN_VPSHAB): Ditto.\n        (IX86_BUILTIN_VPSHAW): Ditto.\n        (IX86_BUILTIN_VPSHAD): Ditto.\n        (IX86_BUILTIN_VPSHAQ): Ditto.\n\n        (IX86_BUILTIN_VFRCZSS): Ditto.\n        (IX86_BUILTIN_VFRCZSD): Ditto.\n        (IX86_BUILTIN_VFRCZPS): Ditto.\n        (IX86_BUILTIN_VFRCZPD): Ditto.\n        (IX86_BUILTIN_VFRCZPS256): Ditto.\n        (IX86_BUILTIN_VFRCZPD256): Ditto.\n\n        (IX86_BUILTIN_VPCOMEQUB): Ditto.\n        (IX86_BUILTIN_VPCOMNEUB): Ditto.\n        (IX86_BUILTIN_VPCOMLTUB): Ditto.\n        (IX86_BUILTIN_VPCOMLEUB): Ditto.\n        (IX86_BUILTIN_VPCOMGTUB): Ditto.\n        (IX86_BUILTIN_VPCOMGEUB): Ditto.\n        (IX86_BUILTIN_VPCOMFALSEUB): Ditto.\n        (IX86_BUILTIN_VPCOMTRUEUB): Ditto.\n\n        (IX86_BUILTIN_VPCOMEQUW): Ditto.\n        (IX86_BUILTIN_VPCOMNEUW): Ditto.\n        (IX86_BUILTIN_VPCOMLTUW): Ditto.\n        (IX86_BUILTIN_VPCOMLEUW): Ditto.\n        (IX86_BUILTIN_VPCOMGTUW): Ditto.\n        (IX86_BUILTIN_VPCOMGEUW): Ditto.\n        (IX86_BUILTIN_VPCOMFALSEUW): Ditto.\n        (IX86_BUILTIN_VPCOMTRUEUW): Ditto.\n\n        (IX86_BUILTIN_VPCOMEQUD): Ditto.\n        (IX86_BUILTIN_VPCOMNEUD): Ditto.\n        (IX86_BUILTIN_VPCOMLTUD): Ditto.\n        (IX86_BUILTIN_VPCOMLEUD): Ditto.\n        (IX86_BUILTIN_VPCOMGTUD): Ditto.\n        (IX86_BUILTIN_VPCOMGEUD): Ditto.\n        (IX86_BUILTIN_VPCOMFALSEUD): Ditto.\n        (IX86_BUILTIN_VPCOMTRUEUD): Ditto.\n\n        (IX86_BUILTIN_VPCOMEQUQ): Ditto.\n        (IX86_BUILTIN_VPCOMNEUQ): Ditto.\n        (IX86_BUILTIN_VPCOMLTUQ): Ditto.\n        (IX86_BUILTIN_VPCOMLEUQ): Ditto.\n        (IX86_BUILTIN_VPCOMGTUQ): Ditto.\n        (IX86_BUILTIN_VPCOMGEUQ): Ditto.\n        (IX86_BUILTIN_VPCOMFALSEUQ): Ditto.\n        (IX86_BUILTIN_VPCOMTRUEUQ): Ditto.\n\n        (IX86_BUILTIN_VPCOMEQB): Ditto.\n        (IX86_BUILTIN_VPCOMNEB): Ditto.\n        (IX86_BUILTIN_VPCOMLTB): Ditto.\n        (IX86_BUILTIN_VPCOMLEB): Ditto.\n        (IX86_BUILTIN_VPCOMGTB): Ditto.\n        (IX86_BUILTIN_VPCOMGEB): Ditto.\n        (IX86_BUILTIN_VPCOMFALSEB): Ditto.\n        (IX86_BUILTIN_VPCOMTRUEB): Ditto.\n\n        (IX86_BUILTIN_VPCOMEQW): Ditto.\n        (IX86_BUILTIN_VPCOMNEW): Ditto.\n        (IX86_BUILTIN_VPCOMLTW): Ditto.\n        (IX86_BUILTIN_VPCOMLEW): Ditto.\n        (IX86_BUILTIN_VPCOMGTW): Ditto.\n        (IX86_BUILTIN_VPCOMGEW): Ditto.\n        (IX86_BUILTIN_VPCOMFALSEW): Ditto.\n        (IX86_BUILTIN_VPCOMTRUEW): Ditto.\n\n        (IX86_BUILTIN_VPCOMEQD): Ditto.\n        (IX86_BUILTIN_VPCOMNED): Ditto.\n        (IX86_BUILTIN_VPCOMLTD): Ditto.\n        (IX86_BUILTIN_VPCOMLED): Ditto.\n        (IX86_BUILTIN_VPCOMGTD): Ditto.\n        (IX86_BUILTIN_VPCOMGED): Ditto.\n        (IX86_BUILTIN_VPCOMFALSED): Ditto.\n        (IX86_BUILTIN_VPCOMTRUED): Ditto.\n\n        (IX86_BUILTIN_VPCOMEQQ): Ditto.\n        (IX86_BUILTIN_VPCOMNEQ): Ditto.\n        (IX86_BUILTIN_VPCOMLTQ): Ditto.\n        (IX86_BUILTIN_VPCOMLEQ): Ditto.\n        (IX86_BUILTIN_VPCOMGTQ): Ditto.\n        (IX86_BUILTIN_VPCOMGEQ): Ditto.\n        (IX86_BUILTIN_VPCOMFALSEQ): Ditto.\n        (IX86_BUILTIN_VPCOMTRUEQ): Ditto.\n\n        (enum multi_arg_type): New enum for describing the various XOP\n        intrinsic argument types.\n        (bdesc_multi_arg): New table for XOP intrinsics.\n        (ix86_init_mmx_sse_builtins): Add XOP intrinsic support.\n        (ix86_expand_multi_arg_builtin): New function for creating XOP\n        intrinsics.\n\n        * config/i386/sse.md (sserotatemax): New mode attribute for XOP.\n        (xop_pmacsww): Ditto.\n        (xop_pmacssww): Ditto.\n        (xop_pmacsdd): Ditto.\n        (xop_pmacssdd): Ditto.\n        (xop_pmacssdql): Ditto.\n        (xop_pmacssdqh): Ditto.\n        (xop_pmacsdql): Ditto.\n        (xop_pmacsdql_mem): Ditto.\n        (xop_mulv2div2di3_low): Ditto.\n        (xop_pmacsdqh): Ditto.\n        (xop_pmacsdqh_mem): Ditto.\n        (xop_mulv2div2di3_high): Ditto.\n        (xop_pmacsswd): Ditto.\n        (xop_pmacswd): Ditto.\n        (xop_pmadcsswd): Ditto.\n        (xop_pmadcswd): Ditto.\n        (xop_pcmov_<mode>): Ditto.\n        (xop_pcmov_<mode>)256: Ditto.\n        (xop_phaddbw): Ditto.\n        (xop_phaddbd): Ditto.\n        (xop_phaddbq): Ditto.\n        (xop_phaddwd): Ditto.\n        (xop_phaddwq): Ditto.\n        (xop_phadddq): Ditto.\n        (xop_phaddubw): Ditto.\n        (xop_phaddubd): Ditto.\n        (xop_phaddubq): Ditto.\n        (xop_phadduwd): Ditto.\n        (xop_phadduwq): Ditto.\n        (xop_phaddudq): Ditto.\n        (xop_phsubbw): Ditto.\n        (xop_phsubwd): Ditto.\n        (xop_phsubdq): Ditto.\n        (xop_pperm): Ditto.\n        (rotl<mode>3): Ditto.\n        (rotr<mode>3): Ditto.\n        (xop_rotl<mode>3): Ditto.\n        (xop_rotr<mode>3): Ditto.\n        (vrotr<mode>3): Ditto.\n        (vrotl<mode>3): Ditto.\n        (xop_vrotl<mode>3): Ditto.\n        (vlshr<mode>3): Ditto.\n        (vashr<mode>3): Ditto.\n        (vashl<mode>3\n        (xop_ashl<mode>3): Ditto.\n        (xop_lshl<mode>3): Ditto.\n        (ashlv16qi3): Ditto.\n        (lshlv16qi3): Ditto.\n        (ashrv16qi3): Ditto.\n        (ashrv2di3): Ditto.\n        (xop_frcz<mode>2): Ditto.\n        (xop_vmfrcz<mode>2): Ditto.\n        (xop_frcz<mode>2256): Ditto.    \n        (xop_maskcmp<mode>3): Ditto.\n        (xop_maskcmp_uns<mode>3): Ditto.\n        (xop_maskcmp_uns2<mode>3): Ditto.\n        (xop_pcom_tf<mode>3): Ditto.\n\n        * doc/invoke.texi (-mxop): Add documentation.\n        * doc/extend.texi (x86 intrinsics): Add XOP intrinsics.\n\n        * gcc.target/i386/xop-check.h: New file.\n        * gcc.target/i386/xop-hadduX.c: Ditto.\n        * gcc.target/i386/xop-haddX.c: Ditto.\n        * gcc.target/i386/xop-hsubX.c: Ditto.\n        * gcc.target/i386/xop-imul32widen-vector.c: Ditto.\n        * gcc.target/i386/xop-imul32widen-vector.c: Ditto.\n        * gcc.target/i386/xop-pcmov2.c: Ditto.\n        * gcc.target/i386/xop-pcmov.c: Ditto.\n        * gcc.target/i386/xop-rotate1-vector.c: Ditto.\n        * gcc.target/i386/xop-rotate2-vector.c: Ditto.\n        * gcc.target/i386/xop-rotate3-vector.c: Ditto.\n        * gcc.target/i386/xop-shift1-vector.c: Ditto.\n        * gcc.target/i386/xop-shift2-vector.c: Ditto.\n        * gcc.target/i386/xop-shift3-vector.c: Ditto.\n        * gcc.target/i386/i386.exp:  Add check_effective_target_xop.\n        * gcc.target/i386/sse-12.c: Update with new compile options to \n        activate and check xopintrin.h intrinsic file.\n        * gcc.target/i386/sse-13.c: Ditto.\n        * gcc.target/i386/sse-14.c: Ditto.\n        * gcc.target/i386/sse-22.c: Ditto.\n        * gcc.target/i386/sse-23.c: Ditto.\n        * g++.dg/other/i386-2.C: Ditto.\n        * g++.dg/other/i386-3.C: Ditto.\n        * g++.dg/other/i386-5.C: Ditto.\n        * g++.dg/other/i386-6.C: Ditto.\n        \n\n\nCo-Authored-By: Dwarakanath Rajagopal <dwarak.rajagopal@amd.com>\n\nFrom-SVN: r153901", "tree": {"sha": "d827b83f3f35cc51de0a6d6b4c8dc8c266f3672f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d827b83f3f35cc51de0a6d6b4c8dc8c266f3672f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43a8b705906034ecb3edfb54558a34bd362a7213", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43a8b705906034ecb3edfb54558a34bd362a7213", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43a8b705906034ecb3edfb54558a34bd362a7213", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43a8b705906034ecb3edfb54558a34bd362a7213/comments", "author": null, "committer": null, "parents": [{"sha": "7d6ce94a23b0a7c6398faf7cf6aa515813fde153", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d6ce94a23b0a7c6398faf7cf6aa515813fde153", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d6ce94a23b0a7c6398faf7cf6aa515813fde153"}], "stats": {"total": 4479, "additions": 4393, "deletions": 86}, "files": [{"sha": "c3b8d865a8906da2085e9a23d1e0e3cb7373b072", "filename": "gcc/ChangeLog", "status": "modified", "additions": 244, "deletions": 0, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=43a8b705906034ecb3edfb54558a34bd362a7213", "patch": "@@ -1,3 +1,247 @@\n+2009-11-04  Harsha Jagasia  <harsha.jagasia@amd.com>\n+\t    Dwarakanath Rajagopal  <dwarak.rajagopal@amd.com>\n+\t\n+\t* config.gcc (i[34567]86-*-*): Include xopintrin.h.\n+\t(x86_64-*-*): Ditto.\n+\t* config/i386/xopintrin.h: New file, provide common x86 compiler\n+\tintrinisics for XOP.\n+\t* config/i386/cpuid.h (bit_XOP): Define XOP bit.\n+\t* config/i386/x86intrin.h: Add XOP check and xopintrin.h.\n+\t* config/i386/i386-c.c(ix86_target_macros_internal): Check\n+\tISA_FLAG for XOP. \n+\t* config/i386/i386.h(TARGET_XOP): New macro for XOP.\n+\t* config/i386/i386.opt (-mxop): New switch for XOP support.\n+\t* config/i386/i386.md (UNSPEC_XOP_UNSIGNED_CMP)\n+\t(UNSPEC_XOP_TRUEFALSE)\n+\t(UNSPEC_XOP_PERMUTE)\n+\t(UNSPEC_FRCZ): Add new UNSPEC for XOP support.\n+\t(PPERM_*): New constants for vpperm instruction.\n+\t(xop_pcmov_<mode>): Add XOP conditional mov instructions.\n+\t* config/i386/i386.c (OPTION_MASK_ISA_XOP_SET): New.\n+\t(OPTION_MASK_ISA_XOP_UNSET): New.\t\n+\t(OPTION_MASK_ISA_XOP_UNSET): Change definition to\n+\tdepend on XOP.\n+\t(ix86_handle_option): Handle -mxop.\n+\t(isa_opts): Handle -mxop.\n+\t(enum pta_flags): Add PTA_XOP.\n+\t(override_options): Add XOP support.\n+\t(print_operand): Add code for XOP compare instructions.\n+\t(ix86_expand_sse_movcc): Extend for XOP conditional move instruction.\n+\t(ix86_expand_int_vcond): Extend for XOP compare instruction.\n+\n+\t(IX86_BUILTIN_VPCMOV): New for XOP intrinsic.\n+\t(IX86_BUILTIN_VPCMOV_V2DI): Ditto.\n+\t(IX86_BUILTIN_VPCMOV_V4SI): Ditto.\n+\t(IX86_BUILTIN_VPCMOV_V8HI): Ditto.\n+\t(IX86_BUILTIN_VPCMOV_V16QI): Ditto.\n+\t(IX86_BUILTIN_VPCMOV_V4SF): Ditto.\n+\t(IX86_BUILTIN_VPCMOV_V2DF): Ditto.\n+\n+\t(IX86_BUILTIN_VPCMOV256): Ditto.\n+\t(IX86_BUILTIN_VPCMOV_V4DI256): Ditto.\n+\t(IX86_BUILTIN_VPCMOV_V8SI256): Ditto.\n+\t(IX86_BUILTIN_VPCMOV_V16HI256): Ditto.\n+\t(IX86_BUILTIN_VPCMOV_V32QI256): Ditto.\n+\t(IX86_BUILTIN_VPCMOV_V8SF256): Ditto.\n+\t(IX86_BUILTIN_VPCMOV_V4DF256): Ditto.\n+\n+\t(IX86_BUILTIN_VPPERM): Ditto.\n+\n+\t(IX86_BUILTIN_VPMACSSWW): Ditto.\n+\t(IX86_BUILTIN_VPMACSWW): Ditto.\n+\t(IX86_BUILTIN_VPMACSSWD): Ditto.\n+\t(IX86_BUILTIN_VPMACSWD): Ditto.\n+\t(IX86_BUILTIN_VPMACSSDD): Ditto.\n+\t(IX86_BUILTIN_VPMACSDD): Ditto.\n+\t(IX86_BUILTIN_VPMACSSDQL): Ditto.\n+\t(IX86_BUILTIN_VPMACSSDQH): Ditto.\n+\t(IX86_BUILTIN_VPMACSDQL): Ditto.\n+\t(IX86_BUILTIN_VPMACSDQH): Ditto.\n+\t(IX86_BUILTIN_VPMADCSSWD): Ditto.\n+\t(IX86_BUILTIN_VPMADCSWD): Ditto.\n+\n+\t(IX86_BUILTIN_VPHADDBW): Ditto.\n+\t(IX86_BUILTIN_VPHADDBD): Ditto.\n+\t(IX86_BUILTIN_VPHADDBQ): Ditto.\n+\t(IX86_BUILTIN_VPHADDWD): Ditto.\n+\t(IX86_BUILTIN_VPHADDWQ): Ditto.\n+\t(IX86_BUILTIN_VPHADDDQ): Ditto.\n+\t(IX86_BUILTIN_VPHADDUBW): Ditto.\n+\t(IX86_BUILTIN_VPHADDUBD): Ditto.\n+\t(IX86_BUILTIN_VPHADDUBQ): Ditto.\n+\t(IX86_BUILTIN_VPHADDUWD): Ditto.\n+\t(IX86_BUILTIN_VPHADDUWQ): Ditto.\n+\t(IX86_BUILTIN_VPHADDUDQ): Ditto.\n+\t(IX86_BUILTIN_VPHSUBBW): Ditto.\n+\t(IX86_BUILTIN_VPHSUBWD): Ditto.\n+\t(IX86_BUILTIN_VPHSUBDQ): Ditto.\n+\n+\t(IX86_BUILTIN_VPROTB): Ditto.\n+\t(IX86_BUILTIN_VPROTW): Ditto.\n+\t(IX86_BUILTIN_VPROTD): Ditto.\n+\t(IX86_BUILTIN_VPROTQ): Ditto.\n+\t(IX86_BUILTIN_VPROTB_IMM): Ditto.\n+\t(IX86_BUILTIN_VPROTW_IMM): Ditto.\n+\t(IX86_BUILTIN_VPROTD_IMM): Ditto.\n+\t(IX86_BUILTIN_VPROTQ_IMM): Ditto.\n+\n+\t(IX86_BUILTIN_VPSHLB): Ditto.\n+\t(IX86_BUILTIN_VPSHLW): Ditto.\n+\t(IX86_BUILTIN_VPSHLD): Ditto.\n+\t(IX86_BUILTIN_VPSHLQ): Ditto.\n+\t(IX86_BUILTIN_VPSHAB): Ditto.\n+\t(IX86_BUILTIN_VPSHAW): Ditto.\n+\t(IX86_BUILTIN_VPSHAD): Ditto.\n+\t(IX86_BUILTIN_VPSHAQ): Ditto.\n+\n+\t(IX86_BUILTIN_VFRCZSS): Ditto.\n+\t(IX86_BUILTIN_VFRCZSD): Ditto.\n+\t(IX86_BUILTIN_VFRCZPS): Ditto.\n+\t(IX86_BUILTIN_VFRCZPD): Ditto.\n+\t(IX86_BUILTIN_VFRCZPS256): Ditto.\n+\t(IX86_BUILTIN_VFRCZPD256): Ditto.\n+\n+\t(IX86_BUILTIN_VPCOMEQUB): Ditto.\n+\t(IX86_BUILTIN_VPCOMNEUB): Ditto.\n+\t(IX86_BUILTIN_VPCOMLTUB): Ditto.\n+\t(IX86_BUILTIN_VPCOMLEUB): Ditto.\n+\t(IX86_BUILTIN_VPCOMGTUB): Ditto.\n+\t(IX86_BUILTIN_VPCOMGEUB): Ditto.\n+\t(IX86_BUILTIN_VPCOMFALSEUB): Ditto.\n+\t(IX86_BUILTIN_VPCOMTRUEUB): Ditto.\n+\n+\t(IX86_BUILTIN_VPCOMEQUW): Ditto.\n+\t(IX86_BUILTIN_VPCOMNEUW): Ditto.\n+\t(IX86_BUILTIN_VPCOMLTUW): Ditto.\n+\t(IX86_BUILTIN_VPCOMLEUW): Ditto.\n+\t(IX86_BUILTIN_VPCOMGTUW): Ditto.\n+\t(IX86_BUILTIN_VPCOMGEUW): Ditto.\n+\t(IX86_BUILTIN_VPCOMFALSEUW): Ditto.\n+\t(IX86_BUILTIN_VPCOMTRUEUW): Ditto.\n+\n+\t(IX86_BUILTIN_VPCOMEQUD): Ditto.\n+\t(IX86_BUILTIN_VPCOMNEUD): Ditto.\n+\t(IX86_BUILTIN_VPCOMLTUD): Ditto.\n+\t(IX86_BUILTIN_VPCOMLEUD): Ditto.\n+\t(IX86_BUILTIN_VPCOMGTUD): Ditto.\n+\t(IX86_BUILTIN_VPCOMGEUD): Ditto.\n+\t(IX86_BUILTIN_VPCOMFALSEUD): Ditto.\n+\t(IX86_BUILTIN_VPCOMTRUEUD): Ditto.\n+\n+\t(IX86_BUILTIN_VPCOMEQUQ): Ditto.\n+\t(IX86_BUILTIN_VPCOMNEUQ): Ditto.\n+\t(IX86_BUILTIN_VPCOMLTUQ): Ditto.\n+\t(IX86_BUILTIN_VPCOMLEUQ): Ditto.\n+\t(IX86_BUILTIN_VPCOMGTUQ): Ditto.\n+\t(IX86_BUILTIN_VPCOMGEUQ): Ditto.\n+\t(IX86_BUILTIN_VPCOMFALSEUQ): Ditto.\n+\t(IX86_BUILTIN_VPCOMTRUEUQ): Ditto.\n+\n+\t(IX86_BUILTIN_VPCOMEQB): Ditto.\n+\t(IX86_BUILTIN_VPCOMNEB): Ditto.\n+\t(IX86_BUILTIN_VPCOMLTB): Ditto.\n+\t(IX86_BUILTIN_VPCOMLEB): Ditto.\n+\t(IX86_BUILTIN_VPCOMGTB): Ditto.\n+\t(IX86_BUILTIN_VPCOMGEB): Ditto.\n+\t(IX86_BUILTIN_VPCOMFALSEB): Ditto.\n+\t(IX86_BUILTIN_VPCOMTRUEB): Ditto.\n+\n+\t(IX86_BUILTIN_VPCOMEQW): Ditto.\n+\t(IX86_BUILTIN_VPCOMNEW): Ditto.\n+\t(IX86_BUILTIN_VPCOMLTW): Ditto.\n+\t(IX86_BUILTIN_VPCOMLEW): Ditto.\n+\t(IX86_BUILTIN_VPCOMGTW): Ditto.\n+\t(IX86_BUILTIN_VPCOMGEW): Ditto.\n+\t(IX86_BUILTIN_VPCOMFALSEW): Ditto.\n+\t(IX86_BUILTIN_VPCOMTRUEW): Ditto.\n+\n+\t(IX86_BUILTIN_VPCOMEQD): Ditto.\n+\t(IX86_BUILTIN_VPCOMNED): Ditto.\n+\t(IX86_BUILTIN_VPCOMLTD): Ditto.\n+\t(IX86_BUILTIN_VPCOMLED): Ditto.\n+\t(IX86_BUILTIN_VPCOMGTD): Ditto.\n+\t(IX86_BUILTIN_VPCOMGED): Ditto.\n+\t(IX86_BUILTIN_VPCOMFALSED): Ditto.\n+\t(IX86_BUILTIN_VPCOMTRUED): Ditto.\n+\n+\t(IX86_BUILTIN_VPCOMEQQ): Ditto.\n+\t(IX86_BUILTIN_VPCOMNEQ): Ditto.\n+\t(IX86_BUILTIN_VPCOMLTQ): Ditto.\n+\t(IX86_BUILTIN_VPCOMLEQ): Ditto.\n+\t(IX86_BUILTIN_VPCOMGTQ): Ditto.\n+\t(IX86_BUILTIN_VPCOMGEQ): Ditto.\n+\t(IX86_BUILTIN_VPCOMFALSEQ): Ditto.\n+\t(IX86_BUILTIN_VPCOMTRUEQ): Ditto.\n+\n+\t(enum multi_arg_type): New enum for describing the various XOP\n+\tintrinsic argument types.\n+\t(bdesc_multi_arg): New table for XOP intrinsics.\n+\t(ix86_init_mmx_sse_builtins): Add XOP intrinsic support.\n+\t(ix86_expand_multi_arg_builtin): New function for creating XOP\n+\tintrinsics.\n+\n+\t* config/i386/sse.md (sserotatemax): New mode attribute for XOP.\n+\t(xop_pmacsww): Ditto.\n+\t(xop_pmacssww): Ditto.\n+\t(xop_pmacsdd): Ditto.\n+\t(xop_pmacssdd): Ditto.\n+\t(xop_pmacssdql): Ditto.\n+\t(xop_pmacssdqh): Ditto.\n+\t(xop_pmacsdql): Ditto.\n+\t(xop_pmacsdql_mem): Ditto.\n+\t(xop_mulv2div2di3_low): Ditto.\n+\t(xop_pmacsdqh): Ditto.\n+\t(xop_pmacsdqh_mem): Ditto.\n+\t(xop_mulv2div2di3_high): Ditto.\n+\t(xop_pmacsswd): Ditto.\n+\t(xop_pmacswd): Ditto.\n+\t(xop_pmadcsswd): Ditto.\n+\t(xop_pmadcswd): Ditto.\n+\t(xop_pcmov_<mode>): Ditto.\n+\t(xop_pcmov_<mode>)256: Ditto.\n+\t(xop_phaddbw): Ditto.\n+\t(xop_phaddbd): Ditto.\n+\t(xop_phaddbq): Ditto.\n+\t(xop_phaddwd): Ditto.\n+\t(xop_phaddwq): Ditto.\n+\t(xop_phadddq): Ditto.\n+\t(xop_phaddubw): Ditto.\n+\t(xop_phaddubd): Ditto.\n+\t(xop_phaddubq): Ditto.\n+\t(xop_phadduwd): Ditto.\n+\t(xop_phadduwq): Ditto.\n+\t(xop_phaddudq): Ditto.\n+\t(xop_phsubbw): Ditto.\n+\t(xop_phsubwd): Ditto.\n+\t(xop_phsubdq): Ditto.\n+\t(xop_pperm): Ditto.\n+\t(rotl<mode>3): Ditto.\n+\t(rotr<mode>3): Ditto.\n+\t(xop_rotl<mode>3): Ditto.\n+\t(xop_rotr<mode>3): Ditto.\n+\t(vrotr<mode>3): Ditto.\n+\t(vrotl<mode>3): Ditto.\n+\t(xop_vrotl<mode>3): Ditto.\n+\t(vlshr<mode>3): Ditto.\n+\t(vashr<mode>3): Ditto.\n+\t(vashl<mode>3\n+\t(xop_ashl<mode>3): Ditto.\n+\t(xop_lshl<mode>3): Ditto.\n+\t(ashlv16qi3): Ditto.\n+\t(lshlv16qi3): Ditto.\n+\t(ashrv16qi3): Ditto.\n+\t(ashrv2di3): Ditto.\n+\t(xop_frcz<mode>2): Ditto.\n+\t(xop_vmfrcz<mode>2): Ditto.\n+\t(xop_frcz<mode>2256): Ditto.\t\n+\t(xop_maskcmp<mode>3): Ditto.\n+\t(xop_maskcmp_uns<mode>3): Ditto.\n+\t(xop_maskcmp_uns2<mode>3): Ditto.\n+\t(xop_pcom_tf<mode>3): Ditto.\n+\n+\t* doc/invoke.texi (-mxop): Add documentation.\n+\t* doc/extend.texi (x86 intrinsics): Add XOP intrinsics.\n+\t\n 2009-11-03  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR driver/11810"}, {"sha": "e79d2251364580ed9e59b63965598797611e7589", "filename": "gcc/config.gcc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=43a8b705906034ecb3edfb54558a34bd362a7213", "patch": "@@ -287,7 +287,7 @@ i[34567]86-*-*)\n \textra_headers=\"cpuid.h mmintrin.h mm3dnow.h xmmintrin.h emmintrin.h\n \t\t       pmmintrin.h tmmintrin.h ammintrin.h smmintrin.h\n \t\t       nmmintrin.h bmmintrin.h fma4intrin.h wmmintrin.h\n-\t\t       immintrin.h x86intrin.h avxintrin.h\n+\t\t       immintrin.h x86intrin.h avxintrin.h xopintrin.h\n \t\t       ia32intrin.h cross-stdarg.h\"\n \t;;\n x86_64-*-*)\n@@ -297,7 +297,7 @@ x86_64-*-*)\n \textra_headers=\"cpuid.h mmintrin.h mm3dnow.h xmmintrin.h emmintrin.h\n \t\t       pmmintrin.h tmmintrin.h ammintrin.h smmintrin.h\n \t\t       nmmintrin.h bmmintrin.h fma4intrin.h wmmintrin.h\n-\t\t       immintrin.h x86intrin.h avxintrin.h \n+\t\t       immintrin.h x86intrin.h avxintrin.h xopintrin.h\n \t\t       ia32intrin.h cross-stdarg.h\"\n \tneed_64bit_hwint=yes\n \t;;"}, {"sha": "c37a883c2605d59a07891989ab2dd65d2acc8d7e", "filename": "gcc/config/i386/cpuid.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Fconfig%2Fi386%2Fcpuid.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Fconfig%2Fi386%2Fcpuid.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcpuid.h?ref=43a8b705906034ecb3edfb54558a34bd362a7213", "patch": "@@ -46,9 +46,10 @@\n \n /* Extended Features */\n /* %ecx */\n+#define bit_FMA4        (1 << 16) \n #define bit_LAHF_LM\t(1 << 0)\n #define bit_SSE4a\t(1 << 6)\n-#define bit_FMA4\t(1 << 16)\n+#define bit_XOP         (1 << 11)\n \n /* %edx */\n #define bit_LM\t\t(1 << 29)"}, {"sha": "cc5c8824c3ac2429a3d99c7145f742d51d7877ad", "filename": "gcc/config/i386/i386-c.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Fconfig%2Fi386%2Fi386-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Fconfig%2Fi386%2Fi386-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-c.c?ref=43a8b705906034ecb3edfb54558a34bd362a7213", "patch": "@@ -232,6 +232,8 @@ ix86_target_macros_internal (int isa_flag,\n     def_or_undef (parse_in, \"__SSE4A__\");\n   if (isa_flag & OPTION_MASK_ISA_FMA4)\n     def_or_undef (parse_in, \"__FMA4__\");\n+  if (isa_flag & OPTION_MASK_ISA_XOP)\n+    def_or_undef (parse_in, \"__XOP__\");\n   if ((fpmath & FPMATH_SSE) && (isa_flag & OPTION_MASK_ISA_SSE))\n     def_or_undef (parse_in, \"__SSE_MATH__\");\n   if ((fpmath & FPMATH_SSE) && (isa_flag & OPTION_MASK_ISA_SSE2))"}, {"sha": "ce26a4d4ec610b6811e9cd47fe984effa5733cc2", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 678, "deletions": 50, "changes": 728, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=43a8b705906034ecb3edfb54558a34bd362a7213", "patch": "@@ -1964,6 +1964,8 @@ static int ix86_isa_flags_explicit;\n #define OPTION_MASK_ISA_FMA4_SET \\\n   (OPTION_MASK_ISA_FMA4 | OPTION_MASK_ISA_SSE4A_SET \\\n    | OPTION_MASK_ISA_AVX_SET)\n+#define OPTION_MASK_ISA_XOP_SET \\\n+  (OPTION_MASK_ISA_XOP | OPTION_MASK_ISA_FMA4_SET)\n \n /* AES and PCLMUL need SSE2 because they use xmm registers */\n #define OPTION_MASK_ISA_AES_SET \\\n@@ -2015,7 +2017,9 @@ static int ix86_isa_flags_explicit;\n #define OPTION_MASK_ISA_SSE4A_UNSET \\\n   (OPTION_MASK_ISA_SSE4A | OPTION_MASK_ISA_FMA4_UNSET)\n \n-#define OPTION_MASK_ISA_FMA4_UNSET OPTION_MASK_ISA_FMA4\n+#define OPTION_MASK_ISA_FMA4_UNSET \\\n+  (OPTION_MASK_ISA_FMA4 | OPTION_MASK_ISA_XOP_UNSET)\n+#define OPTION_MASK_ISA_XOP_UNSET OPTION_MASK_ISA_XOP\n \n #define OPTION_MASK_ISA_AES_UNSET OPTION_MASK_ISA_AES\n #define OPTION_MASK_ISA_PCLMUL_UNSET OPTION_MASK_ISA_PCLMUL\n@@ -2263,6 +2267,19 @@ ix86_handle_option (size_t code, const char *arg ATTRIBUTE_UNUSED, int value)\n \t}\n       return true;\n \n+   case OPT_mxop:\n+      if (value)\n+\t{\n+\t  ix86_isa_flags |= OPTION_MASK_ISA_XOP_SET;\n+\t  ix86_isa_flags_explicit |= OPTION_MASK_ISA_XOP_SET;\n+\t}\n+      else\n+\t{\n+\t  ix86_isa_flags &= ~OPTION_MASK_ISA_XOP_UNSET;\n+\t  ix86_isa_flags_explicit |= OPTION_MASK_ISA_XOP_UNSET;\n+\t}\n+      return true;\n+\n     case OPT_mabm:\n       if (value)\n \t{\n@@ -2391,6 +2408,7 @@ ix86_target_string (int isa, int flags, const char *arch, const char *tune,\n   {\n     { \"-m64\",\t\tOPTION_MASK_ISA_64BIT },\n     { \"-mfma4\",\t\tOPTION_MASK_ISA_FMA4 },\n+    { \"-mxop\",\t\tOPTION_MASK_ISA_XOP },\n     { \"-msse4a\",\tOPTION_MASK_ISA_SSE4A },\n     { \"-msse4.2\",\tOPTION_MASK_ISA_SSE4_2 },\n     { \"-msse4.1\",\tOPTION_MASK_ISA_SSE4_1 },\n@@ -2621,7 +2639,8 @@ override_options (bool main_args_p)\n       PTA_AVX = 1 << 18,\n       PTA_FMA = 1 << 19,\n       PTA_MOVBE = 1 << 20,\n-      PTA_FMA4 = 1 << 21\n+      PTA_FMA4 = 1 << 21,\n+      PTA_XOP = 1 << 22\n     };\n \n   static struct pta\n@@ -2967,6 +2986,9 @@ override_options (bool main_args_p)\n \tif (processor_alias_table[i].flags & PTA_FMA4\n \t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_FMA4))\n \t  ix86_isa_flags |= OPTION_MASK_ISA_FMA4;\n+\tif (processor_alias_table[i].flags & PTA_XOP\n+\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_XOP))\n+\t  ix86_isa_flags |= OPTION_MASK_ISA_XOP;\n \tif (processor_alias_table[i].flags & PTA_ABM\n \t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_ABM))\n \t  ix86_isa_flags |= OPTION_MASK_ISA_ABM;\n@@ -3649,6 +3671,7 @@ ix86_valid_target_attribute_inner_p (tree args, char *p_strings[])\n     IX86_ATTR_ISA (\"sse4a\",\tOPT_msse4a),\n     IX86_ATTR_ISA (\"ssse3\",\tOPT_mssse3),\n     IX86_ATTR_ISA (\"fma4\",\tOPT_mfma4),\n+    IX86_ATTR_ISA (\"xop\",\tOPT_mxop),\n \n     /* string options */\n     IX86_ATTR_STR (\"arch=\",\tIX86_FUNCTION_SPECIFIC_ARCH),\n@@ -11290,6 +11313,7 @@ get_some_local_dynamic_name (void)\n    X -- don't print any sort of PIC '@' suffix for a symbol.\n    & -- print some in-use local-dynamic symbol name.\n    H -- print a memory address offset by 8; used for sse high-parts\n+   Y -- print condition for XOP pcom* instruction.\n    + -- print a branch hint as 'cs' or 'ds' prefix\n    ; -- print a semicolon (after prefixes due to bug in older gas).\n  */\n@@ -11707,6 +11731,61 @@ print_operand (FILE *file, rtx x, int code)\n \t    return;\n \t  }\n \n+\tcase 'Y':\n+\t  switch (GET_CODE (x))\n+\t    {\n+\t    case NE:\n+\t      fputs (\"neq\", file);\n+\t      break;\n+\t    case EQ:\n+\t      fputs (\"eq\", file);\n+\t      break;\n+\t    case GE:\n+\t    case GEU:\n+\t      fputs (INTEGRAL_MODE_P (GET_MODE (x)) ? \"ge\" : \"unlt\", file);\n+\t      break;\n+\t    case GT:\n+\t    case GTU:\n+\t      fputs (INTEGRAL_MODE_P (GET_MODE (x)) ? \"gt\" : \"unle\", file);\n+\t      break;\n+\t    case LE:\n+\t    case LEU:\n+\t      fputs (\"le\", file);\n+\t      break;\n+\t    case LT:\n+\t    case LTU:\n+\t      fputs (\"lt\", file);\n+\t      break;\n+\t    case UNORDERED:\n+\t      fputs (\"unord\", file);\n+\t      break;\n+\t    case ORDERED:\n+\t      fputs (\"ord\", file);\n+\t      break;\n+\t    case UNEQ:\n+\t      fputs (\"ueq\", file);\n+\t      break;\n+\t    case UNGE:\n+\t      fputs (\"nlt\", file);\n+\t      break;\n+\t    case UNGT:\n+\t      fputs (\"nle\", file);\n+\t      break;\n+\t    case UNLE:\n+\t      fputs (\"ule\", file);\n+\t      break;\n+\t    case UNLT:\n+\t      fputs (\"ult\", file);\n+\t      break;\n+\t    case LTGT:\n+\t      fputs (\"une\", file);\n+\t      break;\n+\t    default:\n+\t      output_operand_lossage (\"operand is not a condition code, invalid operand code 'D'\");\n+\t      return;\n+\t    }\n+\t  return;\n+\n \tcase ';':\n #if TARGET_MACHO\n \t  fputs (\" ; \", file);\n@@ -15916,6 +15995,14 @@ ix86_expand_sse_movcc (rtx dest, rtx cmp, rtx op_true, rtx op_false)\n       x = gen_rtx_AND (mode, x, op_false);\n       emit_insn (gen_rtx_SET (VOIDmode, dest, x));\n     }\n+  else if (TARGET_XOP)\n+    {\n+      rtx pcmov = gen_rtx_SET (mode, dest,\n+\t\t\t       gen_rtx_IF_THEN_ELSE (mode, cmp,\n+\t\t\t\t\t\t     op_true,\n+\t\t\t\t\t\t     op_false));\n+      emit_insn (pcmov);\n+    }\n   else\n     {\n       op_true = force_reg (mode, op_true);\n@@ -16038,6 +16125,9 @@ ix86_expand_int_vcond (rtx operands[])\n   cop0 = operands[4];\n   cop1 = operands[5];\n \n+  /* XOP supports all of the comparisons on all vector int types.  */\n+  if (!TARGET_XOP)\n+    {\n   /* Canonicalize the comparison to EQ, GT, GTU.  */\n   switch (code)\n     {\n@@ -16148,6 +16238,7 @@ ix86_expand_int_vcond (rtx operands[])\n       cop0 = x;\n       cop1 = CONST0_RTX (mode);\n     }\n+    }\n \n   x = ix86_expand_sse_cmp (operands[0], code, cop0, cop1,\n \t\t\t   operands[1+negate], operands[2-negate]);\n@@ -20839,6 +20930,150 @@ enum ix86_builtins\n   IX86_BUILTIN_VFNMADDPD256,\n   IX86_BUILTIN_VFNMSUBPS256,\n   IX86_BUILTIN_VFNMSUBPD256,\n+\n+  IX86_BUILTIN_VPCMOV,\n+  IX86_BUILTIN_VPCMOV_V2DI,\n+  IX86_BUILTIN_VPCMOV_V4SI,\n+  IX86_BUILTIN_VPCMOV_V8HI,\n+  IX86_BUILTIN_VPCMOV_V16QI,\n+  IX86_BUILTIN_VPCMOV_V4SF,\n+  IX86_BUILTIN_VPCMOV_V2DF,\n+  IX86_BUILTIN_VPCMOV256,\n+  IX86_BUILTIN_VPCMOV_V4DI256,\n+  IX86_BUILTIN_VPCMOV_V8SI256,\n+  IX86_BUILTIN_VPCMOV_V16HI256,\n+  IX86_BUILTIN_VPCMOV_V32QI256,\n+  IX86_BUILTIN_VPCMOV_V8SF256,\n+  IX86_BUILTIN_VPCMOV_V4DF256,\n+\n+  IX86_BUILTIN_VPPERM,\n+\n+  IX86_BUILTIN_VPMACSSWW,\n+  IX86_BUILTIN_VPMACSWW,\n+  IX86_BUILTIN_VPMACSSWD,\n+  IX86_BUILTIN_VPMACSWD,\n+  IX86_BUILTIN_VPMACSSDD,\n+  IX86_BUILTIN_VPMACSDD,\n+  IX86_BUILTIN_VPMACSSDQL,\n+  IX86_BUILTIN_VPMACSSDQH,\n+  IX86_BUILTIN_VPMACSDQL,\n+  IX86_BUILTIN_VPMACSDQH,\n+  IX86_BUILTIN_VPMADCSSWD,\n+  IX86_BUILTIN_VPMADCSWD,\n+\n+  IX86_BUILTIN_VPHADDBW,\n+  IX86_BUILTIN_VPHADDBD,\n+  IX86_BUILTIN_VPHADDBQ,\n+  IX86_BUILTIN_VPHADDWD,\n+  IX86_BUILTIN_VPHADDWQ,\n+  IX86_BUILTIN_VPHADDDQ,\n+  IX86_BUILTIN_VPHADDUBW,\n+  IX86_BUILTIN_VPHADDUBD,\n+  IX86_BUILTIN_VPHADDUBQ,\n+  IX86_BUILTIN_VPHADDUWD,\n+  IX86_BUILTIN_VPHADDUWQ,\n+  IX86_BUILTIN_VPHADDUDQ,\n+  IX86_BUILTIN_VPHSUBBW,\n+  IX86_BUILTIN_VPHSUBWD,\n+  IX86_BUILTIN_VPHSUBDQ,\n+\n+  IX86_BUILTIN_VPROTB,\n+  IX86_BUILTIN_VPROTW,\n+  IX86_BUILTIN_VPROTD,\n+  IX86_BUILTIN_VPROTQ,\n+  IX86_BUILTIN_VPROTB_IMM,\n+  IX86_BUILTIN_VPROTW_IMM,\n+  IX86_BUILTIN_VPROTD_IMM,\n+  IX86_BUILTIN_VPROTQ_IMM,\n+\n+  IX86_BUILTIN_VPSHLB,\n+  IX86_BUILTIN_VPSHLW,\n+  IX86_BUILTIN_VPSHLD,\n+  IX86_BUILTIN_VPSHLQ,\n+  IX86_BUILTIN_VPSHAB,\n+  IX86_BUILTIN_VPSHAW,\n+  IX86_BUILTIN_VPSHAD,\n+  IX86_BUILTIN_VPSHAQ,\n+\n+  IX86_BUILTIN_VFRCZSS,\n+  IX86_BUILTIN_VFRCZSD,\n+  IX86_BUILTIN_VFRCZPS,\n+  IX86_BUILTIN_VFRCZPD,\n+  IX86_BUILTIN_VFRCZPS256,\n+  IX86_BUILTIN_VFRCZPD256,\n+\n+  IX86_BUILTIN_VPCOMEQUB,\n+  IX86_BUILTIN_VPCOMNEUB,\n+  IX86_BUILTIN_VPCOMLTUB,\n+  IX86_BUILTIN_VPCOMLEUB,\n+  IX86_BUILTIN_VPCOMGTUB,\n+  IX86_BUILTIN_VPCOMGEUB,\n+  IX86_BUILTIN_VPCOMFALSEUB,\n+  IX86_BUILTIN_VPCOMTRUEUB,\n+\n+  IX86_BUILTIN_VPCOMEQUW,\n+  IX86_BUILTIN_VPCOMNEUW,\n+  IX86_BUILTIN_VPCOMLTUW,\n+  IX86_BUILTIN_VPCOMLEUW,\n+  IX86_BUILTIN_VPCOMGTUW,\n+  IX86_BUILTIN_VPCOMGEUW,\n+  IX86_BUILTIN_VPCOMFALSEUW,\n+  IX86_BUILTIN_VPCOMTRUEUW,\n+\n+  IX86_BUILTIN_VPCOMEQUD,\n+  IX86_BUILTIN_VPCOMNEUD,\n+  IX86_BUILTIN_VPCOMLTUD,\n+  IX86_BUILTIN_VPCOMLEUD,\n+  IX86_BUILTIN_VPCOMGTUD,\n+  IX86_BUILTIN_VPCOMGEUD,\n+  IX86_BUILTIN_VPCOMFALSEUD,\n+  IX86_BUILTIN_VPCOMTRUEUD,\n+\n+  IX86_BUILTIN_VPCOMEQUQ,\n+  IX86_BUILTIN_VPCOMNEUQ,\n+  IX86_BUILTIN_VPCOMLTUQ,\n+  IX86_BUILTIN_VPCOMLEUQ,\n+  IX86_BUILTIN_VPCOMGTUQ,\n+  IX86_BUILTIN_VPCOMGEUQ,\n+  IX86_BUILTIN_VPCOMFALSEUQ,\n+  IX86_BUILTIN_VPCOMTRUEUQ,\n+\n+  IX86_BUILTIN_VPCOMEQB,\n+  IX86_BUILTIN_VPCOMNEB,\n+  IX86_BUILTIN_VPCOMLTB,\n+  IX86_BUILTIN_VPCOMLEB,\n+  IX86_BUILTIN_VPCOMGTB,\n+  IX86_BUILTIN_VPCOMGEB,\n+  IX86_BUILTIN_VPCOMFALSEB,\n+  IX86_BUILTIN_VPCOMTRUEB,\n+\n+  IX86_BUILTIN_VPCOMEQW,\n+  IX86_BUILTIN_VPCOMNEW,\n+  IX86_BUILTIN_VPCOMLTW,\n+  IX86_BUILTIN_VPCOMLEW,\n+  IX86_BUILTIN_VPCOMGTW,\n+  IX86_BUILTIN_VPCOMGEW,\n+  IX86_BUILTIN_VPCOMFALSEW,\n+  IX86_BUILTIN_VPCOMTRUEW,\n+\n+  IX86_BUILTIN_VPCOMEQD,\n+  IX86_BUILTIN_VPCOMNED,\n+  IX86_BUILTIN_VPCOMLTD,\n+  IX86_BUILTIN_VPCOMLED,\n+  IX86_BUILTIN_VPCOMGTD,\n+  IX86_BUILTIN_VPCOMGED,\n+  IX86_BUILTIN_VPCOMFALSED,\n+  IX86_BUILTIN_VPCOMTRUED,\n+\n+  IX86_BUILTIN_VPCOMEQQ,\n+  IX86_BUILTIN_VPCOMNEQ,\n+  IX86_BUILTIN_VPCOMLTQ,\n+  IX86_BUILTIN_VPCOMLEQ,\n+  IX86_BUILTIN_VPCOMGTQ,\n+  IX86_BUILTIN_VPCOMGEQ,\n+  IX86_BUILTIN_VPCOMFALSEQ,\n+  IX86_BUILTIN_VPCOMTRUEQ,\n+\n   IX86_BUILTIN_MAX\n };\n \n@@ -21912,13 +22147,58 @@ static const struct builtin_description bdesc_args[] =\n   { OPTION_MASK_ISA_AVX, CODE_FOR_avx_movmskps256, \"__builtin_ia32_movmskps256\", IX86_BUILTIN_MOVMSKPS256, UNKNOWN, (int) INT_FTYPE_V8SF },\n };\n \n-/* FMA4.  */\n+/* FMA4 and XOP.  */\n enum multi_arg_type {\n   MULTI_ARG_UNKNOWN,\n   MULTI_ARG_3_SF,\n   MULTI_ARG_3_DF,\n   MULTI_ARG_3_SF2,\n-  MULTI_ARG_3_DF2\n+  MULTI_ARG_3_DF2,\n+  MULTI_ARG_3_DI,\n+  MULTI_ARG_3_SI,\n+  MULTI_ARG_3_SI_DI,\n+  MULTI_ARG_3_HI,\n+  MULTI_ARG_3_HI_SI,\n+  MULTI_ARG_3_QI,\n+  MULTI_ARG_3_DI2,\n+  MULTI_ARG_3_SI2,\n+  MULTI_ARG_3_HI2,\n+  MULTI_ARG_3_QI2,\n+  MULTI_ARG_2_SF,\n+  MULTI_ARG_2_DF,\n+  MULTI_ARG_2_DI,\n+  MULTI_ARG_2_SI,\n+  MULTI_ARG_2_HI,\n+  MULTI_ARG_2_QI,\n+  MULTI_ARG_2_DI_IMM,\n+  MULTI_ARG_2_SI_IMM,\n+  MULTI_ARG_2_HI_IMM,\n+  MULTI_ARG_2_QI_IMM,\n+  MULTI_ARG_2_DI_CMP,\n+  MULTI_ARG_2_SI_CMP,\n+  MULTI_ARG_2_HI_CMP,\n+  MULTI_ARG_2_QI_CMP,\n+  MULTI_ARG_2_DI_TF,\n+  MULTI_ARG_2_SI_TF,\n+  MULTI_ARG_2_HI_TF,\n+  MULTI_ARG_2_QI_TF,\n+  MULTI_ARG_2_SF_TF,\n+  MULTI_ARG_2_DF_TF,\n+  MULTI_ARG_1_SF,\n+  MULTI_ARG_1_DF,\n+  MULTI_ARG_1_SF2,\n+  MULTI_ARG_1_DF2,\n+  MULTI_ARG_1_DI,\n+  MULTI_ARG_1_SI,\n+  MULTI_ARG_1_HI,\n+  MULTI_ARG_1_QI,\n+  MULTI_ARG_1_SI_DI,\n+  MULTI_ARG_1_HI_DI,\n+  MULTI_ARG_1_HI_SI,\n+  MULTI_ARG_1_QI_DI,\n+  MULTI_ARG_1_QI_SI,\n+  MULTI_ARG_1_QI_HI\n+\n };\n \n static const struct builtin_description bdesc_multi_arg[] =\n@@ -21959,7 +22239,160 @@ static const struct builtin_description bdesc_multi_arg[] =\n   { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_fmaddsubv8sf4,\t   \"__builtin_ia32_vfmaddsubps256\", IX86_BUILTIN_VFMADDSUBPS256,    UNKNOWN,      (int)MULTI_ARG_3_SF2 },\n   { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_fmaddsubv4df4,\t   \"__builtin_ia32_vfmaddsubpd256\", IX86_BUILTIN_VFMADDSUBPD256,    UNKNOWN,      (int)MULTI_ARG_3_DF2 },\n   { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_fmsubaddv8sf4,\t   \"__builtin_ia32_vfmsubaddps256\", IX86_BUILTIN_VFMSUBADDPS256,    UNKNOWN,      (int)MULTI_ARG_3_SF2 },\n-  { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_fmsubaddv4df4,\t   \"__builtin_ia32_vfmsubaddpd256\", IX86_BUILTIN_VFMSUBADDPD256,    UNKNOWN,      (int)MULTI_ARG_3_DF2 }\n+  { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_fmsubaddv4df4,\t   \"__builtin_ia32_vfmsubaddpd256\", IX86_BUILTIN_VFMSUBADDPD256,    UNKNOWN,      (int)MULTI_ARG_3_DF2 },\n+\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pcmov_v2di,        \"__builtin_ia32_vpcmov\",      IX86_BUILTIN_VPCMOV,\t UNKNOWN,      (int)MULTI_ARG_3_DI },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pcmov_v2di,        \"__builtin_ia32_vpcmov_v2di\", IX86_BUILTIN_VPCMOV_V2DI, UNKNOWN,      (int)MULTI_ARG_3_DI },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pcmov_v4si,        \"__builtin_ia32_vpcmov_v4si\", IX86_BUILTIN_VPCMOV_V4SI, UNKNOWN,      (int)MULTI_ARG_3_SI },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pcmov_v8hi,        \"__builtin_ia32_vpcmov_v8hi\", IX86_BUILTIN_VPCMOV_V8HI, UNKNOWN,      (int)MULTI_ARG_3_HI },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pcmov_v16qi,       \"__builtin_ia32_vpcmov_v16qi\",IX86_BUILTIN_VPCMOV_V16QI,UNKNOWN,      (int)MULTI_ARG_3_QI },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pcmov_v2df,        \"__builtin_ia32_vpcmov_v2df\", IX86_BUILTIN_VPCMOV_V2DF, UNKNOWN,      (int)MULTI_ARG_3_DF },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pcmov_v4sf,        \"__builtin_ia32_vpcmov_v4sf\", IX86_BUILTIN_VPCMOV_V4SF, UNKNOWN,      (int)MULTI_ARG_3_SF },\n+\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pcmov_v4di256,        \"__builtin_ia32_vpcmov256\",       IX86_BUILTIN_VPCMOV256,       UNKNOWN,      (int)MULTI_ARG_3_DI2 },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pcmov_v4di256,        \"__builtin_ia32_vpcmov_v4di256\",  IX86_BUILTIN_VPCMOV_V4DI256,  UNKNOWN,      (int)MULTI_ARG_3_DI2 },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pcmov_v8si256,        \"__builtin_ia32_vpcmov_v8si256\",  IX86_BUILTIN_VPCMOV_V8SI256,  UNKNOWN,      (int)MULTI_ARG_3_SI2 },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pcmov_v16hi256,       \"__builtin_ia32_vpcmov_v16hi256\", IX86_BUILTIN_VPCMOV_V16HI256, UNKNOWN,      (int)MULTI_ARG_3_HI2 },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pcmov_v32qi256,       \"__builtin_ia32_vpcmov_v32qi256\", IX86_BUILTIN_VPCMOV_V32QI256, UNKNOWN,      (int)MULTI_ARG_3_QI2 },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pcmov_v4df256,        \"__builtin_ia32_vpcmov_v4df256\",  IX86_BUILTIN_VPCMOV_V4DF256,  UNKNOWN,      (int)MULTI_ARG_3_DF2 },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pcmov_v8sf256,        \"__builtin_ia32_vpcmov_v8sf256\",  IX86_BUILTIN_VPCMOV_V8SF256,  UNKNOWN,      (int)MULTI_ARG_3_SF2 },\n+\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pperm,             \"__builtin_ia32_vpperm\",      IX86_BUILTIN_VPPERM,      UNKNOWN,      (int)MULTI_ARG_3_QI },\n+\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pmacssww,          \"__builtin_ia32_vpmacssww\",   IX86_BUILTIN_VPMACSSWW,   UNKNOWN,      (int)MULTI_ARG_3_HI },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pmacsww,           \"__builtin_ia32_vpmacsww\",    IX86_BUILTIN_VPMACSWW,    UNKNOWN,      (int)MULTI_ARG_3_HI },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pmacsswd,          \"__builtin_ia32_vpmacsswd\",   IX86_BUILTIN_VPMACSSWD,   UNKNOWN,      (int)MULTI_ARG_3_HI_SI },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pmacswd,           \"__builtin_ia32_vpmacswd\",    IX86_BUILTIN_VPMACSWD,    UNKNOWN,      (int)MULTI_ARG_3_HI_SI },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pmacssdd,          \"__builtin_ia32_vpmacssdd\",   IX86_BUILTIN_VPMACSSDD,   UNKNOWN,      (int)MULTI_ARG_3_SI },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pmacsdd,           \"__builtin_ia32_vpmacsdd\",    IX86_BUILTIN_VPMACSDD,    UNKNOWN,      (int)MULTI_ARG_3_SI },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pmacssdql,         \"__builtin_ia32_vpmacssdql\",  IX86_BUILTIN_VPMACSSDQL,  UNKNOWN,      (int)MULTI_ARG_3_SI_DI },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pmacssdqh,         \"__builtin_ia32_vpmacssdqh\",  IX86_BUILTIN_VPMACSSDQH,  UNKNOWN,      (int)MULTI_ARG_3_SI_DI },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pmacsdql,          \"__builtin_ia32_vpmacsdql\",   IX86_BUILTIN_VPMACSDQL,   UNKNOWN,      (int)MULTI_ARG_3_SI_DI },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pmacsdqh,          \"__builtin_ia32_vpmacsdqh\",   IX86_BUILTIN_VPMACSDQH,   UNKNOWN,      (int)MULTI_ARG_3_SI_DI },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pmadcsswd,         \"__builtin_ia32_vpmadcsswd\",  IX86_BUILTIN_VPMADCSSWD,  UNKNOWN,      (int)MULTI_ARG_3_HI_SI },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pmadcswd,          \"__builtin_ia32_vpmadcswd\",   IX86_BUILTIN_VPMADCSWD,   UNKNOWN,      (int)MULTI_ARG_3_HI_SI },\n+\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_vrotlv2di3,        \"__builtin_ia32_vprotq\",      IX86_BUILTIN_VPROTQ,      UNKNOWN,      (int)MULTI_ARG_2_DI },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_vrotlv4si3,        \"__builtin_ia32_vprotd\",      IX86_BUILTIN_VPROTD,      UNKNOWN,      (int)MULTI_ARG_2_SI },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_vrotlv8hi3,        \"__builtin_ia32_vprotw\",      IX86_BUILTIN_VPROTW,      UNKNOWN,      (int)MULTI_ARG_2_HI },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_vrotlv16qi3,       \"__builtin_ia32_vprotb\",      IX86_BUILTIN_VPROTB,      UNKNOWN,      (int)MULTI_ARG_2_QI },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_rotlv2di3,         \"__builtin_ia32_vprotqi\",     IX86_BUILTIN_VPROTQ_IMM,  UNKNOWN,      (int)MULTI_ARG_2_DI_IMM },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_rotlv4si3,         \"__builtin_ia32_vprotdi\",     IX86_BUILTIN_VPROTD_IMM,  UNKNOWN,      (int)MULTI_ARG_2_SI_IMM },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_rotlv8hi3,         \"__builtin_ia32_vprotwi\",     IX86_BUILTIN_VPROTW_IMM,  UNKNOWN,      (int)MULTI_ARG_2_HI_IMM },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_rotlv16qi3,        \"__builtin_ia32_vprotbi\",     IX86_BUILTIN_VPROTB_IMM,  UNKNOWN,      (int)MULTI_ARG_2_QI_IMM },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_ashlv2di3,         \"__builtin_ia32_vpshaq\",      IX86_BUILTIN_VPSHAQ,      UNKNOWN,      (int)MULTI_ARG_2_DI },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_ashlv4si3,         \"__builtin_ia32_vpshad\",      IX86_BUILTIN_VPSHAD,      UNKNOWN,      (int)MULTI_ARG_2_SI },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_ashlv8hi3,         \"__builtin_ia32_vpshaw\",      IX86_BUILTIN_VPSHAW,      UNKNOWN,      (int)MULTI_ARG_2_HI },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_ashlv16qi3,        \"__builtin_ia32_vpshab\",      IX86_BUILTIN_VPSHAB,      UNKNOWN,      (int)MULTI_ARG_2_QI },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_lshlv2di3,         \"__builtin_ia32_vpshlq\",      IX86_BUILTIN_VPSHLQ,      UNKNOWN,      (int)MULTI_ARG_2_DI },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_lshlv4si3,         \"__builtin_ia32_vpshld\",      IX86_BUILTIN_VPSHLD,      UNKNOWN,      (int)MULTI_ARG_2_SI },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_lshlv8hi3,         \"__builtin_ia32_vpshlw\",      IX86_BUILTIN_VPSHLW,      UNKNOWN,      (int)MULTI_ARG_2_HI },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_lshlv16qi3,        \"__builtin_ia32_vpshlb\",      IX86_BUILTIN_VPSHLB,      UNKNOWN,      (int)MULTI_ARG_2_QI },\n+\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_vmfrczv4sf2,       \"__builtin_ia32_vfrczss\",     IX86_BUILTIN_VFRCZSS,     UNKNOWN,      (int)MULTI_ARG_2_SF },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_vmfrczv2df2,       \"__builtin_ia32_vfrczsd\",     IX86_BUILTIN_VFRCZSD,     UNKNOWN,      (int)MULTI_ARG_2_DF },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_frczv4sf2,         \"__builtin_ia32_vfrczps\",     IX86_BUILTIN_VFRCZPS,     UNKNOWN,      (int)MULTI_ARG_1_SF },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_frczv2df2,         \"__builtin_ia32_vfrczpd\",     IX86_BUILTIN_VFRCZPD,     UNKNOWN,      (int)MULTI_ARG_1_DF },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_frczv8sf2256,         \"__builtin_ia32_vfrczps256\",  IX86_BUILTIN_VFRCZPS256,  UNKNOWN,      (int)MULTI_ARG_1_SF2 },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_frczv4df2256,         \"__builtin_ia32_vfrczpd256\",  IX86_BUILTIN_VFRCZPD256,  UNKNOWN,      (int)MULTI_ARG_1_DF2 },\n+\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_phaddbw,           \"__builtin_ia32_vphaddbw\",    IX86_BUILTIN_VPHADDBW,    UNKNOWN,      (int)MULTI_ARG_1_QI_HI },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_phaddbd,           \"__builtin_ia32_vphaddbd\",    IX86_BUILTIN_VPHADDBD,    UNKNOWN,      (int)MULTI_ARG_1_QI_SI },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_phaddbq,           \"__builtin_ia32_vphaddbq\",    IX86_BUILTIN_VPHADDBQ,    UNKNOWN,      (int)MULTI_ARG_1_QI_DI },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_phaddwd,           \"__builtin_ia32_vphaddwd\",    IX86_BUILTIN_VPHADDWD,    UNKNOWN,      (int)MULTI_ARG_1_HI_SI },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_phaddwq,           \"__builtin_ia32_vphaddwq\",    IX86_BUILTIN_VPHADDWQ,    UNKNOWN,      (int)MULTI_ARG_1_HI_DI },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_phadddq,           \"__builtin_ia32_vphadddq\",    IX86_BUILTIN_VPHADDDQ,    UNKNOWN,      (int)MULTI_ARG_1_SI_DI },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_phaddubw,          \"__builtin_ia32_vphaddubw\",   IX86_BUILTIN_VPHADDUBW,   UNKNOWN,      (int)MULTI_ARG_1_QI_HI },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_phaddubd,          \"__builtin_ia32_vphaddubd\",   IX86_BUILTIN_VPHADDUBD,   UNKNOWN,      (int)MULTI_ARG_1_QI_SI },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_phaddubq,          \"__builtin_ia32_vphaddubq\",   IX86_BUILTIN_VPHADDUBQ,   UNKNOWN,      (int)MULTI_ARG_1_QI_DI },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_phadduwd,          \"__builtin_ia32_vphadduwd\",   IX86_BUILTIN_VPHADDUWD,   UNKNOWN,      (int)MULTI_ARG_1_HI_SI },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_phadduwq,          \"__builtin_ia32_vphadduwq\",   IX86_BUILTIN_VPHADDUWQ,   UNKNOWN,      (int)MULTI_ARG_1_HI_DI },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_phaddudq,          \"__builtin_ia32_vphaddudq\",   IX86_BUILTIN_VPHADDUDQ,   UNKNOWN,      (int)MULTI_ARG_1_SI_DI },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_phsubbw,           \"__builtin_ia32_vphsubbw\",    IX86_BUILTIN_VPHSUBBW,    UNKNOWN,      (int)MULTI_ARG_1_QI_HI },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_phsubwd,           \"__builtin_ia32_vphsubwd\",    IX86_BUILTIN_VPHSUBWD,    UNKNOWN,      (int)MULTI_ARG_1_HI_SI },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_phsubdq,           \"__builtin_ia32_vphsubdq\",    IX86_BUILTIN_VPHSUBDQ,    UNKNOWN,      (int)MULTI_ARG_1_SI_DI },\n+\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmpv16qi3,     \"__builtin_ia32_vpcomeqb\",    IX86_BUILTIN_VPCOMEQB,    EQ,           (int)MULTI_ARG_2_QI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmpv16qi3,     \"__builtin_ia32_vpcomneb\",    IX86_BUILTIN_VPCOMNEB,    NE,           (int)MULTI_ARG_2_QI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmpv16qi3,     \"__builtin_ia32_vpcomneqb\",   IX86_BUILTIN_VPCOMNEB,    NE,           (int)MULTI_ARG_2_QI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmpv16qi3,     \"__builtin_ia32_vpcomltb\",    IX86_BUILTIN_VPCOMLTB,    LT,           (int)MULTI_ARG_2_QI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmpv16qi3,     \"__builtin_ia32_vpcomleb\",    IX86_BUILTIN_VPCOMLEB,    LE,           (int)MULTI_ARG_2_QI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmpv16qi3,     \"__builtin_ia32_vpcomgtb\",    IX86_BUILTIN_VPCOMGTB,    GT,           (int)MULTI_ARG_2_QI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmpv16qi3,     \"__builtin_ia32_vpcomgeb\",    IX86_BUILTIN_VPCOMGEB,    GE,           (int)MULTI_ARG_2_QI_CMP },\n+\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmpv8hi3,      \"__builtin_ia32_vpcomeqw\",    IX86_BUILTIN_VPCOMEQW,    EQ,           (int)MULTI_ARG_2_HI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmpv8hi3,      \"__builtin_ia32_vpcomnew\",    IX86_BUILTIN_VPCOMNEW,    NE,           (int)MULTI_ARG_2_HI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmpv8hi3,      \"__builtin_ia32_vpcomneqw\",   IX86_BUILTIN_VPCOMNEW,    NE,           (int)MULTI_ARG_2_HI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmpv8hi3,      \"__builtin_ia32_vpcomltw\",    IX86_BUILTIN_VPCOMLTW,    LT,           (int)MULTI_ARG_2_HI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmpv8hi3,      \"__builtin_ia32_vpcomlew\",    IX86_BUILTIN_VPCOMLEW,    LE,           (int)MULTI_ARG_2_HI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmpv8hi3,      \"__builtin_ia32_vpcomgtw\",    IX86_BUILTIN_VPCOMGTW,    GT,           (int)MULTI_ARG_2_HI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmpv8hi3,      \"__builtin_ia32_vpcomgew\",    IX86_BUILTIN_VPCOMGEW,    GE,           (int)MULTI_ARG_2_HI_CMP },\n+\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmpv4si3,      \"__builtin_ia32_vpcomeqd\",    IX86_BUILTIN_VPCOMEQD,    EQ,           (int)MULTI_ARG_2_SI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmpv4si3,      \"__builtin_ia32_vpcomned\",    IX86_BUILTIN_VPCOMNED,    NE,           (int)MULTI_ARG_2_SI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmpv4si3,      \"__builtin_ia32_vpcomneqd\",   IX86_BUILTIN_VPCOMNED,    NE,           (int)MULTI_ARG_2_SI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmpv4si3,      \"__builtin_ia32_vpcomltd\",    IX86_BUILTIN_VPCOMLTD,    LT,           (int)MULTI_ARG_2_SI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmpv4si3,      \"__builtin_ia32_vpcomled\",    IX86_BUILTIN_VPCOMLED,    LE,           (int)MULTI_ARG_2_SI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmpv4si3,      \"__builtin_ia32_vpcomgtd\",    IX86_BUILTIN_VPCOMGTD,    GT,           (int)MULTI_ARG_2_SI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmpv4si3,      \"__builtin_ia32_vpcomged\",    IX86_BUILTIN_VPCOMGED,    GE,           (int)MULTI_ARG_2_SI_CMP },\n+\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmpv2di3,      \"__builtin_ia32_vpcomeqq\",    IX86_BUILTIN_VPCOMEQQ,    EQ,           (int)MULTI_ARG_2_DI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmpv2di3,      \"__builtin_ia32_vpcomneq\",    IX86_BUILTIN_VPCOMNEQ,    NE,           (int)MULTI_ARG_2_DI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmpv2di3,      \"__builtin_ia32_vpcomneqq\",   IX86_BUILTIN_VPCOMNEQ,    NE,           (int)MULTI_ARG_2_DI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmpv2di3,      \"__builtin_ia32_vpcomltq\",    IX86_BUILTIN_VPCOMLTQ,    LT,           (int)MULTI_ARG_2_DI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmpv2di3,      \"__builtin_ia32_vpcomleq\",    IX86_BUILTIN_VPCOMLEQ,    LE,           (int)MULTI_ARG_2_DI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmpv2di3,      \"__builtin_ia32_vpcomgtq\",    IX86_BUILTIN_VPCOMGTQ,    GT,           (int)MULTI_ARG_2_DI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmpv2di3,      \"__builtin_ia32_vpcomgeq\",    IX86_BUILTIN_VPCOMGEQ,    GE,           (int)MULTI_ARG_2_DI_CMP },\n+\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmp_uns2v16qi3,\"__builtin_ia32_vpcomequb\",   IX86_BUILTIN_VPCOMEQUB,   EQ,           (int)MULTI_ARG_2_QI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmp_uns2v16qi3,\"__builtin_ia32_vpcomneub\",   IX86_BUILTIN_VPCOMNEUB,   NE,           (int)MULTI_ARG_2_QI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmp_uns2v16qi3,\"__builtin_ia32_vpcomnequb\",  IX86_BUILTIN_VPCOMNEUB,   NE,           (int)MULTI_ARG_2_QI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmp_unsv16qi3, \"__builtin_ia32_vpcomltub\",   IX86_BUILTIN_VPCOMLTUB,   LTU,          (int)MULTI_ARG_2_QI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmp_unsv16qi3, \"__builtin_ia32_vpcomleub\",   IX86_BUILTIN_VPCOMLEUB,   LEU,          (int)MULTI_ARG_2_QI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmp_unsv16qi3, \"__builtin_ia32_vpcomgtub\",   IX86_BUILTIN_VPCOMGTUB,   GTU,          (int)MULTI_ARG_2_QI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmp_unsv16qi3, \"__builtin_ia32_vpcomgeub\",   IX86_BUILTIN_VPCOMGEUB,   GEU,          (int)MULTI_ARG_2_QI_CMP },\n+\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmp_uns2v8hi3, \"__builtin_ia32_vpcomequw\",   IX86_BUILTIN_VPCOMEQUW,   EQ,           (int)MULTI_ARG_2_HI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmp_uns2v8hi3, \"__builtin_ia32_vpcomneuw\",   IX86_BUILTIN_VPCOMNEUW,   NE,           (int)MULTI_ARG_2_HI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmp_uns2v8hi3, \"__builtin_ia32_vpcomnequw\",  IX86_BUILTIN_VPCOMNEUW,   NE,           (int)MULTI_ARG_2_HI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmp_unsv8hi3,  \"__builtin_ia32_vpcomltuw\",   IX86_BUILTIN_VPCOMLTUW,   LTU,          (int)MULTI_ARG_2_HI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmp_unsv8hi3,  \"__builtin_ia32_vpcomleuw\",   IX86_BUILTIN_VPCOMLEUW,   LEU,          (int)MULTI_ARG_2_HI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmp_unsv8hi3,  \"__builtin_ia32_vpcomgtuw\",   IX86_BUILTIN_VPCOMGTUW,   GTU,          (int)MULTI_ARG_2_HI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmp_unsv8hi3,  \"__builtin_ia32_vpcomgeuw\",   IX86_BUILTIN_VPCOMGEUW,   GEU,          (int)MULTI_ARG_2_HI_CMP },\n+\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmp_uns2v4si3, \"__builtin_ia32_vpcomequd\",   IX86_BUILTIN_VPCOMEQUD,   EQ,           (int)MULTI_ARG_2_SI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmp_uns2v4si3, \"__builtin_ia32_vpcomneud\",   IX86_BUILTIN_VPCOMNEUD,   NE,           (int)MULTI_ARG_2_SI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmp_uns2v4si3, \"__builtin_ia32_vpcomnequd\",  IX86_BUILTIN_VPCOMNEUD,   NE,           (int)MULTI_ARG_2_SI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmp_unsv4si3,  \"__builtin_ia32_vpcomltud\",   IX86_BUILTIN_VPCOMLTUD,   LTU,          (int)MULTI_ARG_2_SI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmp_unsv4si3,  \"__builtin_ia32_vpcomleud\",   IX86_BUILTIN_VPCOMLEUD,   LEU,          (int)MULTI_ARG_2_SI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmp_unsv4si3,  \"__builtin_ia32_vpcomgtud\",   IX86_BUILTIN_VPCOMGTUD,   GTU,          (int)MULTI_ARG_2_SI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmp_unsv4si3,  \"__builtin_ia32_vpcomgeud\",   IX86_BUILTIN_VPCOMGEUD,   GEU,          (int)MULTI_ARG_2_SI_CMP },\n+\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmp_uns2v2di3, \"__builtin_ia32_vpcomequq\",   IX86_BUILTIN_VPCOMEQUQ,   EQ,           (int)MULTI_ARG_2_DI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmp_uns2v2di3, \"__builtin_ia32_vpcomneuq\",   IX86_BUILTIN_VPCOMNEUQ,   NE,           (int)MULTI_ARG_2_DI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmp_uns2v2di3, \"__builtin_ia32_vpcomnequq\",  IX86_BUILTIN_VPCOMNEUQ,   NE,           (int)MULTI_ARG_2_DI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmp_unsv2di3,  \"__builtin_ia32_vpcomltuq\",   IX86_BUILTIN_VPCOMLTUQ,   LTU,          (int)MULTI_ARG_2_DI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmp_unsv2di3,  \"__builtin_ia32_vpcomleuq\",   IX86_BUILTIN_VPCOMLEUQ,   LEU,          (int)MULTI_ARG_2_DI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmp_unsv2di3,  \"__builtin_ia32_vpcomgtuq\",   IX86_BUILTIN_VPCOMGTUQ,   GTU,          (int)MULTI_ARG_2_DI_CMP },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_maskcmp_unsv2di3,  \"__builtin_ia32_vpcomgeuq\",   IX86_BUILTIN_VPCOMGEUQ,   GEU,          (int)MULTI_ARG_2_DI_CMP },\n+\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pcom_tfv16qi3,     \"__builtin_ia32_vpcomfalseb\", IX86_BUILTIN_VPCOMFALSEB, (enum rtx_code) PCOM_FALSE,   (int)MULTI_ARG_2_QI_TF },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pcom_tfv8hi3,      \"__builtin_ia32_vpcomfalsew\", IX86_BUILTIN_VPCOMFALSEW, (enum rtx_code) PCOM_FALSE,   (int)MULTI_ARG_2_HI_TF },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pcom_tfv4si3,      \"__builtin_ia32_vpcomfalsed\", IX86_BUILTIN_VPCOMFALSED, (enum rtx_code) PCOM_FALSE,   (int)MULTI_ARG_2_SI_TF },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pcom_tfv2di3,      \"__builtin_ia32_vpcomfalseq\", IX86_BUILTIN_VPCOMFALSEQ, (enum rtx_code) PCOM_FALSE,   (int)MULTI_ARG_2_DI_TF },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pcom_tfv16qi3,     \"__builtin_ia32_vpcomfalseub\",IX86_BUILTIN_VPCOMFALSEUB,(enum rtx_code) PCOM_FALSE,   (int)MULTI_ARG_2_QI_TF },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pcom_tfv8hi3,      \"__builtin_ia32_vpcomfalseuw\",IX86_BUILTIN_VPCOMFALSEUW,(enum rtx_code) PCOM_FALSE,   (int)MULTI_ARG_2_HI_TF },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pcom_tfv4si3,      \"__builtin_ia32_vpcomfalseud\",IX86_BUILTIN_VPCOMFALSEUD,(enum rtx_code) PCOM_FALSE,   (int)MULTI_ARG_2_SI_TF },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pcom_tfv2di3,      \"__builtin_ia32_vpcomfalseuq\",IX86_BUILTIN_VPCOMFALSEUQ,(enum rtx_code) PCOM_FALSE,   (int)MULTI_ARG_2_DI_TF },\n+\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pcom_tfv16qi3,     \"__builtin_ia32_vpcomtrueb\",  IX86_BUILTIN_VPCOMTRUEB,  (enum rtx_code) PCOM_TRUE,    (int)MULTI_ARG_2_QI_TF },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pcom_tfv8hi3,      \"__builtin_ia32_vpcomtruew\",  IX86_BUILTIN_VPCOMTRUEW,  (enum rtx_code) PCOM_TRUE,    (int)MULTI_ARG_2_HI_TF },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pcom_tfv4si3,      \"__builtin_ia32_vpcomtrued\",  IX86_BUILTIN_VPCOMTRUED,  (enum rtx_code) PCOM_TRUE,    (int)MULTI_ARG_2_SI_TF },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pcom_tfv2di3,      \"__builtin_ia32_vpcomtrueq\",  IX86_BUILTIN_VPCOMTRUEQ,  (enum rtx_code) PCOM_TRUE,    (int)MULTI_ARG_2_DI_TF },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pcom_tfv16qi3,     \"__builtin_ia32_vpcomtrueub\", IX86_BUILTIN_VPCOMTRUEUB, (enum rtx_code) PCOM_TRUE,    (int)MULTI_ARG_2_QI_TF },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pcom_tfv8hi3,      \"__builtin_ia32_vpcomtrueuw\", IX86_BUILTIN_VPCOMTRUEUW, (enum rtx_code) PCOM_TRUE,    (int)MULTI_ARG_2_HI_TF },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pcom_tfv4si3,      \"__builtin_ia32_vpcomtrueud\", IX86_BUILTIN_VPCOMTRUEUD, (enum rtx_code) PCOM_TRUE,    (int)MULTI_ARG_2_SI_TF },\n+  { OPTION_MASK_ISA_XOP, CODE_FOR_xop_pcom_tfv2di3,      \"__builtin_ia32_vpcomtrueuq\", IX86_BUILTIN_VPCOMTRUEUQ, (enum rtx_code) PCOM_TRUE,    (int)MULTI_ARG_2_DI_TF },\n \n };\n \n@@ -22341,51 +22774,6 @@ ix86_init_mmx_sse_builtins (void)\n \t\t\t\tinteger_type_node,\n \t\t\t\tNULL_TREE);\n \n-\n-  tree v2di_ftype_v2di\n-    = build_function_type_list (V2DI_type_node, V2DI_type_node, NULL_TREE);\n-\n-  tree v16qi_ftype_v8hi_v8hi\n-    = build_function_type_list (V16QI_type_node,\n-\t\t\t\tV8HI_type_node, V8HI_type_node,\n-\t\t\t\tNULL_TREE);\n-  tree v8hi_ftype_v4si_v4si\n-    = build_function_type_list (V8HI_type_node,\n-\t\t\t\tV4SI_type_node, V4SI_type_node,\n-\t\t\t\tNULL_TREE);\n-  tree v8hi_ftype_v16qi_v16qi \n-    = build_function_type_list (V8HI_type_node,\n-\t\t\t\tV16QI_type_node, V16QI_type_node,\n-\t\t\t\tNULL_TREE);\n-  tree v4hi_ftype_v8qi_v8qi \n-    = build_function_type_list (V4HI_type_node,\n-\t\t\t\tV8QI_type_node, V8QI_type_node,\n-\t\t\t\tNULL_TREE);\n-  tree unsigned_ftype_unsigned_uchar\n-    = build_function_type_list (unsigned_type_node,\n-\t\t\t\tunsigned_type_node,\n-\t\t\t\tunsigned_char_type_node,\n-\t\t\t\tNULL_TREE);\n-  tree unsigned_ftype_unsigned_ushort\n-    = build_function_type_list (unsigned_type_node,\n-\t\t\t\tunsigned_type_node,\n-\t\t\t\tshort_unsigned_type_node,\n-\t\t\t\tNULL_TREE);\n-  tree unsigned_ftype_unsigned_unsigned\n-    = build_function_type_list (unsigned_type_node,\n-\t\t\t\tunsigned_type_node,\n-\t\t\t\tunsigned_type_node,\n-\t\t\t\tNULL_TREE);\n-  tree uint64_ftype_uint64_uint64\n-    = build_function_type_list (long_long_unsigned_type_node,\n-\t\t\t\tlong_long_unsigned_type_node,\n-\t\t\t\tlong_long_unsigned_type_node,\n-\t\t\t\tNULL_TREE);\n-  tree float_ftype_float\n-    = build_function_type_list (float_type_node,\n-\t\t\t\tfloat_type_node,\n-\t\t\t\tNULL_TREE);\n-\n   /* AVX builtins  */\n   tree V32QI_type_node = build_vector_type_for_mode (char_type_node,\n \t\t\t\t\t\t     V32QImode);\n@@ -22397,6 +22785,8 @@ ix86_init_mmx_sse_builtins (void)\n \t\t\t\t\t\t    V4DImode);\n   tree V4DF_type_node = build_vector_type_for_mode (double_type_node,\n \t\t\t\t\t\t    V4DFmode);\n+  tree V16HI_type_node = build_vector_type_for_mode (intHI_type_node,\n+\t\t\t\t\t\t     V16HImode);\n   tree v8sf_ftype_v8sf\n     = build_function_type_list (V8SF_type_node,\n \t\t\t\tV8SF_type_node,\n@@ -22641,6 +23031,138 @@ ix86_init_mmx_sse_builtins (void)\n     = build_function_type_list (V2DF_type_node,\n \t\t\t\tV2DF_type_node, V2DI_type_node, NULL_TREE);\n \n+  /* XOP instructions */\n+  tree v2di_ftype_v2di_v2di_v2di\n+    = build_function_type_list (V2DI_type_node,\n+\t\t\t\tV2DI_type_node,\n+\t\t\t\tV2DI_type_node,\n+\t\t\t\tV2DI_type_node,\n+\t\t\t\tNULL_TREE);\n+\n+  tree v4di_ftype_v4di_v4di_v4di\n+    = build_function_type_list (V4DI_type_node,\n+\t\t\t\tV4DI_type_node,\n+\t\t\t\tV4DI_type_node,\n+\t\t\t\tV4DI_type_node,\n+\t\t\t\tNULL_TREE);\n+\n+  tree v4si_ftype_v4si_v4si_v4si\n+    = build_function_type_list (V4SI_type_node,\n+\t\t\t\tV4SI_type_node,\n+\t\t\t\tV4SI_type_node,\n+\t\t\t\tV4SI_type_node,\n+\t\t\t\tNULL_TREE);\n+\n+  tree v8si_ftype_v8si_v8si_v8si\n+    = build_function_type_list (V8SI_type_node,\n+\t\t\t\tV8SI_type_node,\n+\t\t\t\tV8SI_type_node,\n+\t\t\t\tV8SI_type_node,\n+\t\t\t\tNULL_TREE);\n+\n+  tree v32qi_ftype_v32qi_v32qi_v32qi\n+    = build_function_type_list (V32QI_type_node,\n+\t\t\t\tV32QI_type_node,\n+\t\t\t\tV32QI_type_node,\n+\t\t\t\tV32QI_type_node,\n+\t\t\t\tNULL_TREE);\n+\n+  tree v4si_ftype_v4si_v4si_v2di\n+    = build_function_type_list (V4SI_type_node,\n+\t\t\t\tV4SI_type_node,\n+\t\t\t\tV4SI_type_node,\n+\t\t\t\tV2DI_type_node,\n+\t\t\t\tNULL_TREE);\n+\n+  tree v8hi_ftype_v8hi_v8hi_v8hi\n+    = build_function_type_list (V8HI_type_node,\n+\t\t\t\tV8HI_type_node,\n+\t\t\t\tV8HI_type_node,\n+\t\t\t\tV8HI_type_node,\n+\t\t\t\tNULL_TREE);\n+\n+  tree v16hi_ftype_v16hi_v16hi_v16hi\n+    = build_function_type_list (V16HI_type_node,\n+\t\t\t\tV16HI_type_node,\n+\t\t\t\tV16HI_type_node,\n+\t\t\t\tV16HI_type_node,\n+\t\t\t\tNULL_TREE);\n+\n+  tree v8hi_ftype_v8hi_v8hi_v4si\n+    = build_function_type_list (V8HI_type_node,\n+\t\t\t\tV8HI_type_node,\n+\t\t\t\tV8HI_type_node,\n+\t\t\t\tV4SI_type_node,\n+\t\t\t\tNULL_TREE);\n+\n+  tree v2di_ftype_v2di_si\n+    = build_function_type_list (V2DI_type_node,\n+\t\t\t\tV2DI_type_node,\n+\t\t\t\tinteger_type_node,\n+\t\t\t\tNULL_TREE);\n+\n+  tree v4si_ftype_v4si_si\n+    = build_function_type_list (V4SI_type_node,\n+\t\t\t\tV4SI_type_node,\n+\t\t\t\tinteger_type_node,\n+\t\t\t\tNULL_TREE);\n+\n+  tree v8hi_ftype_v8hi_si\n+    = build_function_type_list (V8HI_type_node,\n+\t\t\t\tV8HI_type_node,\n+\t\t\t\tinteger_type_node,\n+\t\t\t\tNULL_TREE);\n+\n+  tree v16qi_ftype_v16qi_si\n+    = build_function_type_list (V16QI_type_node,\n+\t\t\t\tV16QI_type_node,\n+\t\t\t\tinteger_type_node,\n+\t\t\t\tNULL_TREE);\n+\n+  tree v2di_ftype_v2di\n+    = build_function_type_list (V2DI_type_node, V2DI_type_node, NULL_TREE);\n+\n+  tree v16qi_ftype_v8hi_v8hi\n+    = build_function_type_list (V16QI_type_node,\n+\t\t\t\tV8HI_type_node, V8HI_type_node,\n+\t\t\t\tNULL_TREE);\n+  tree v8hi_ftype_v4si_v4si\n+    = build_function_type_list (V8HI_type_node,\n+\t\t\t\tV4SI_type_node, V4SI_type_node,\n+\t\t\t\tNULL_TREE);\n+  tree v8hi_ftype_v16qi_v16qi \n+    = build_function_type_list (V8HI_type_node,\n+\t\t\t\tV16QI_type_node, V16QI_type_node,\n+\t\t\t\tNULL_TREE);\n+  tree v4hi_ftype_v8qi_v8qi \n+    = build_function_type_list (V4HI_type_node,\n+\t\t\t\tV8QI_type_node, V8QI_type_node,\n+\t\t\t\tNULL_TREE);\n+  tree unsigned_ftype_unsigned_uchar\n+    = build_function_type_list (unsigned_type_node,\n+\t\t\t\tunsigned_type_node,\n+\t\t\t\tunsigned_char_type_node,\n+\t\t\t\tNULL_TREE);\n+  tree unsigned_ftype_unsigned_ushort\n+    = build_function_type_list (unsigned_type_node,\n+\t\t\t\tunsigned_type_node,\n+\t\t\t\tshort_unsigned_type_node,\n+\t\t\t\tNULL_TREE);\n+  tree unsigned_ftype_unsigned_unsigned\n+    = build_function_type_list (unsigned_type_node,\n+\t\t\t\tunsigned_type_node,\n+\t\t\t\tunsigned_type_node,\n+\t\t\t\tNULL_TREE);\n+  tree uint64_ftype_uint64_uint64\n+    = build_function_type_list (long_long_unsigned_type_node,\n+\t\t\t\tlong_long_unsigned_type_node,\n+\t\t\t\tlong_long_unsigned_type_node,\n+\t\t\t\tNULL_TREE);\n+  tree float_ftype_float\n+    = build_function_type_list (float_type_node,\n+\t\t\t\tfloat_type_node,\n+\t\t\t\tNULL_TREE);\n+\n   /* Integer intrinsics.  */\n   tree uint64_ftype_void\n     = build_function_type (long_long_unsigned_type_node,\n@@ -23409,6 +23931,50 @@ ix86_init_mmx_sse_builtins (void)\n \tcase MULTI_ARG_3_DF:     mtype = v2df_ftype_v2df_v2df_v2df; \tbreak;\n \tcase MULTI_ARG_3_SF2:    mtype = v8sf_ftype_v8sf_v8sf_v8sf; \tbreak;\n \tcase MULTI_ARG_3_DF2:    mtype = v4df_ftype_v4df_v4df_v4df; \tbreak;\n+\tcase MULTI_ARG_3_DI:     mtype = v2di_ftype_v2di_v2di_v2di; \tbreak;\n+\tcase MULTI_ARG_3_SI:     mtype = v4si_ftype_v4si_v4si_v4si; \tbreak;\n+\tcase MULTI_ARG_3_SI_DI:  mtype = v4si_ftype_v4si_v4si_v2di; \tbreak;\n+\tcase MULTI_ARG_3_HI:     mtype = v8hi_ftype_v8hi_v8hi_v8hi; \tbreak;\n+\tcase MULTI_ARG_3_HI_SI:  mtype = v8hi_ftype_v8hi_v8hi_v4si; \tbreak;\n+\tcase MULTI_ARG_3_QI:     mtype = v16qi_ftype_v16qi_v16qi_v16qi; break;\n+\tcase MULTI_ARG_3_DI2:    mtype = v4di_ftype_v4di_v4di_v4di; \tbreak;\n+\tcase MULTI_ARG_3_SI2:    mtype = v8si_ftype_v8si_v8si_v8si; \tbreak;\n+\tcase MULTI_ARG_3_HI2:    mtype = v16hi_ftype_v16hi_v16hi_v16hi; break;\n+\tcase MULTI_ARG_3_QI2:    mtype = v32qi_ftype_v32qi_v32qi_v32qi; break;\n+\tcase MULTI_ARG_2_SF:     mtype = v4sf_ftype_v4sf_v4sf;      \tbreak;\n+\tcase MULTI_ARG_2_DF:     mtype = v2df_ftype_v2df_v2df;      \tbreak;\n+\tcase MULTI_ARG_2_DI:     mtype = v2di_ftype_v2di_v2di;      \tbreak;\n+\tcase MULTI_ARG_2_SI:     mtype = v4si_ftype_v4si_v4si;      \tbreak;\n+\tcase MULTI_ARG_2_HI:     mtype = v8hi_ftype_v8hi_v8hi;      \tbreak;\n+\tcase MULTI_ARG_2_QI:     mtype = v16qi_ftype_v16qi_v16qi;      \tbreak;\n+\tcase MULTI_ARG_2_DI_IMM: mtype = v2di_ftype_v2di_si;        \tbreak;\n+\tcase MULTI_ARG_2_SI_IMM: mtype = v4si_ftype_v4si_si;        \tbreak;\n+\tcase MULTI_ARG_2_HI_IMM: mtype = v8hi_ftype_v8hi_si;        \tbreak;\n+\tcase MULTI_ARG_2_QI_IMM: mtype = v16qi_ftype_v16qi_si;        \tbreak;\n+\tcase MULTI_ARG_2_DI_CMP: mtype = v2di_ftype_v2di_v2di;      \tbreak;\n+\tcase MULTI_ARG_2_SI_CMP: mtype = v4si_ftype_v4si_v4si;      \tbreak;\n+\tcase MULTI_ARG_2_HI_CMP: mtype = v8hi_ftype_v8hi_v8hi;      \tbreak;\n+\tcase MULTI_ARG_2_QI_CMP: mtype = v16qi_ftype_v16qi_v16qi;      \tbreak;\n+\tcase MULTI_ARG_2_SF_TF:  mtype = v4sf_ftype_v4sf_v4sf;      \tbreak;\n+\tcase MULTI_ARG_2_DF_TF:  mtype = v2df_ftype_v2df_v2df;      \tbreak;\n+\tcase MULTI_ARG_2_DI_TF:  mtype = v2di_ftype_v2di_v2di;      \tbreak;\n+\tcase MULTI_ARG_2_SI_TF:  mtype = v4si_ftype_v4si_v4si;      \tbreak;\n+\tcase MULTI_ARG_2_HI_TF:  mtype = v8hi_ftype_v8hi_v8hi;      \tbreak;\n+\tcase MULTI_ARG_2_QI_TF:  mtype = v16qi_ftype_v16qi_v16qi;      \tbreak;\n+\tcase MULTI_ARG_1_SF:     mtype = v4sf_ftype_v4sf;           \tbreak;\n+\tcase MULTI_ARG_1_DF:     mtype = v2df_ftype_v2df;           \tbreak;\n+\tcase MULTI_ARG_1_SF2:    mtype = v8sf_ftype_v8sf;           \tbreak;\n+\tcase MULTI_ARG_1_DF2:    mtype = v4df_ftype_v4df;           \tbreak;\n+\tcase MULTI_ARG_1_DI:     mtype = v2di_ftype_v2di;           \tbreak;\n+\tcase MULTI_ARG_1_SI:     mtype = v4si_ftype_v4si;           \tbreak;\n+\tcase MULTI_ARG_1_HI:     mtype = v8hi_ftype_v8hi;           \tbreak;\n+\tcase MULTI_ARG_1_QI:     mtype = v16qi_ftype_v16qi;           \tbreak;\n+\tcase MULTI_ARG_1_SI_DI:  mtype = v2di_ftype_v4si;           \tbreak;\n+\tcase MULTI_ARG_1_HI_DI:  mtype = v2di_ftype_v8hi;           \tbreak;\n+\tcase MULTI_ARG_1_HI_SI:  mtype = v4si_ftype_v8hi;           \tbreak;\n+\tcase MULTI_ARG_1_QI_DI:  mtype = v2di_ftype_v16qi;           \tbreak;\n+\tcase MULTI_ARG_1_QI_SI:  mtype = v4si_ftype_v16qi;           \tbreak;\n+\tcase MULTI_ARG_1_QI_HI:  mtype = v8hi_ftype_v16qi;           \tbreak;\n \n \tcase MULTI_ARG_UNKNOWN:\n \tdefault:\n@@ -23628,9 +24194,71 @@ ix86_expand_multi_arg_builtin (enum insn_code icode, tree exp, rtx target,\n     case MULTI_ARG_3_DF:\n     case MULTI_ARG_3_SF2:\n     case MULTI_ARG_3_DF2:\n+    case MULTI_ARG_3_DI:\n+    case MULTI_ARG_3_SI:\n+    case MULTI_ARG_3_SI_DI:\n+    case MULTI_ARG_3_HI:\n+    case MULTI_ARG_3_HI_SI:\n+    case MULTI_ARG_3_QI:\n+    case MULTI_ARG_3_DI2:\n+    case MULTI_ARG_3_SI2:\n+    case MULTI_ARG_3_HI2:\n+    case MULTI_ARG_3_QI2:\n       nargs = 3;\n       break;\n \n+    case MULTI_ARG_2_SF:\n+    case MULTI_ARG_2_DF:\n+    case MULTI_ARG_2_DI:\n+    case MULTI_ARG_2_SI:\n+    case MULTI_ARG_2_HI:\n+    case MULTI_ARG_2_QI:\n+      nargs = 2;\n+      break;\n+\n+    case MULTI_ARG_2_DI_IMM:\n+    case MULTI_ARG_2_SI_IMM:\n+    case MULTI_ARG_2_HI_IMM:\n+    case MULTI_ARG_2_QI_IMM:\n+      nargs = 2;\n+      last_arg_constant = true;\n+      break;\n+\n+    case MULTI_ARG_1_SF:\n+    case MULTI_ARG_1_DF:\n+    case MULTI_ARG_1_SF2:\n+    case MULTI_ARG_1_DF2:\n+    case MULTI_ARG_1_DI:\n+    case MULTI_ARG_1_SI:\n+    case MULTI_ARG_1_HI:\n+    case MULTI_ARG_1_QI:\n+    case MULTI_ARG_1_SI_DI:\n+    case MULTI_ARG_1_HI_DI:\n+    case MULTI_ARG_1_HI_SI:\n+    case MULTI_ARG_1_QI_DI:\n+    case MULTI_ARG_1_QI_SI:\n+    case MULTI_ARG_1_QI_HI:\n+      nargs = 1;\n+      break;\n+\n+    case MULTI_ARG_2_DI_CMP:\n+    case MULTI_ARG_2_SI_CMP:\n+    case MULTI_ARG_2_HI_CMP:\n+    case MULTI_ARG_2_QI_CMP:\n+      nargs = 2;\n+      comparison_p = true;\n+      break;\n+\n+    case MULTI_ARG_2_SF_TF:\n+    case MULTI_ARG_2_DF_TF:\n+    case MULTI_ARG_2_DI_TF:\n+    case MULTI_ARG_2_SI_TF:\n+    case MULTI_ARG_2_HI_TF:\n+    case MULTI_ARG_2_QI_TF:\n+      nargs = 2;\n+      tf_p = true;\n+      break;\n+\n     case MULTI_ARG_UNKNOWN:\n     default:\n       gcc_unreachable ();"}, {"sha": "94114f8d711cdd09b9dbb6189ad727944b1216af", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=43a8b705906034ecb3edfb54558a34bd362a7213", "patch": "@@ -55,6 +55,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define TARGET_FMA\tOPTION_ISA_FMA\n #define TARGET_SSE4A\tOPTION_ISA_SSE4A\n #define TARGET_FMA4\tOPTION_ISA_FMA4\n+#define TARGET_XOP\tOPTION_ISA_XOP\n #define TARGET_ROUND\tOPTION_ISA_ROUND\n #define TARGET_ABM\tOPTION_ISA_ABM\n #define TARGET_POPCNT\tOPTION_ISA_POPCNT"}, {"sha": "0e051cdee6b123701759f28fc738b813e47036d5", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=43a8b705906034ecb3edfb54558a34bd362a7213", "patch": "@@ -57,6 +57,7 @@\n ;; X -- don't print any sort of PIC '@' suffix for a symbol.\n ;; & -- print some in-use local-dynamic symbol name.\n ;; H -- print a memory address offset by 8; used for sse high-parts\n+;; Y -- print condition for XOP pcom* instruction.\n ;; + -- print a branch hint as 'cs' or 'ds' prefix\n ;; ; -- print a semicolon (after prefixes due to bug in older gas).\n \n@@ -199,6 +200,11 @@\n    (UNSPEC_FMA4_INTRINSIC\t150)\n    (UNSPEC_FMA4_FMADDSUB\t151)\n    (UNSPEC_FMA4_FMSUBADD\t152)\n+   (UNSPEC_XOP_UNSIGNED_CMP\t151)\n+   (UNSPEC_XOP_TRUEFALSE\t152)\n+   (UNSPEC_XOP_PERMUTE\t\t153)\n+   (UNSPEC_FRCZ\t\t\t154)\n+\n    ; For AES support\n    (UNSPEC_AESENC\t\t159)\n    (UNSPEC_AESENCLAST\t\t160)\n@@ -254,6 +260,20 @@\n    (COM_TRUE_P\t\t\t5)\n   ])\n \n+;; Constants used in the XOP pperm instruction\n+(define_constants\n+  [(PPERM_SRC\t\t\t0x00)\t/* copy source */\n+   (PPERM_INVERT\t\t0x20)\t/* invert source */\n+   (PPERM_REVERSE\t\t0x40)\t/* bit reverse source */\n+   (PPERM_REV_INV\t\t0x60)\t/* bit reverse & invert src */\n+   (PPERM_ZERO\t\t\t0x80)\t/* all 0's */\n+   (PPERM_ONES\t\t\t0xa0)\t/* all 1's */\n+   (PPERM_SIGN\t\t\t0xc0)\t/* propagate sign bit */\n+   (PPERM_INV_SIGN\t\t0xe0)\t/* invert & propagate sign */\n+   (PPERM_SRC1\t\t\t0x00)\t/* use first source byte */\n+   (PPERM_SRC2\t\t\t0x10)\t/* use second source byte */\n+   ])\n+\n ;; Registers by name.\n (define_constants\n   [(AX_REG\t\t\t 0)\n@@ -19676,6 +19696,20 @@\n   [(set_attr \"type\" \"fcmov\")\n    (set_attr \"mode\" \"XF\")])\n \n+;; All moves in XOP pcmov instructions are 128 bits and hence we restrict\n+;; the scalar versions to have only XMM registers as operands.\n+\n+;; XOP conditional move\n+(define_insn \"*xop_pcmov_<mode>\"\n+  [(set (match_operand:MODEF 0 \"register_operand\" \"=x\")\n+\t(if_then_else:MODEF\n+\t  (match_operand:MODEF 1 \"register_operand\" \"x\")\n+\t  (match_operand:MODEF 2 \"register_operand\" \"x\")\n+\t  (match_operand:MODEF 3 \"register_operand\" \"x\")))]\n+  \"TARGET_XOP && ix86_fma4_valid_op_p (operands, insn, 4, true, 1, false)\"\n+  \"vpcmov\\t{%1, %3, %2, %0|%0, %2, %3, %1}\"\n+  [(set_attr \"type\" \"sse4arg\")])\n+\n ;; These versions of the min/max patterns are intentionally ignorant of\n ;; their behavior wrt -0.0 and NaN (via the commutative operand mark).\n ;; Since both the tree-level MAX_EXPR and the rtl-level SMAX operator"}, {"sha": "b63b84e7befeadd146a170064d013ac54d3b1e8c", "filename": "gcc/config/i386/i386.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Fconfig%2Fi386%2Fi386.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Fconfig%2Fi386%2Fi386.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.opt?ref=43a8b705906034ecb3edfb54558a34bd362a7213", "patch": "@@ -314,6 +314,10 @@ mfma4\n Target Report Mask(ISA_FMA4) Var(ix86_isa_flags) VarExists Save\n Support FMA4 built-in functions and code generation \n \n+mxop\n+Target Report Mask(ISA_XOP) Var(ix86_isa_flags) VarExists Save\n+Support XOP built-in functions and code generation \n+\n mabm\n Target Report Mask(ISA_ABM) Var(ix86_isa_flags) VarExists Save\n Support code generation of Advanced Bit Manipulation (ABM) instructions."}, {"sha": "bad39bb69c8da5c2947f9921a1f9f8cc5bf3dfff", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 1535, "deletions": 6, "changes": 1541, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=43a8b705906034ecb3edfb54558a34bd362a7213", "patch": "@@ -86,6 +86,9 @@\n \n (define_mode_attr ssemodesuffixf2c [(V4SF \"s\") (V2DF \"d\")])\n \n+;; Mapping of the max integer size for xop rotate immediate constraint\n+(define_mode_attr sserotatemax [(V16QI \"7\") (V8HI \"15\") (V4SI \"31\") (V2DI \"63\")])\n+\n ;; Mapping of vector modes back to the scalar modes\n (define_mode_attr ssescalarmode [(V4SF \"SF\") (V2DF \"DF\")\n \t\t\t\t (V16QI \"QI\") (V8HI \"HI\")\n@@ -1455,7 +1458,8 @@\n \t(match_operator:SSEMODEF4 3 \"sse_comparison_operator\"\n \t\t[(match_operand:SSEMODEF4 1 \"register_operand\" \"0\")\n \t\t (match_operand:SSEMODEF4 2 \"nonimmediate_operand\" \"xm\")]))]\n-  \"(SSE_FLOAT_MODE_P (<MODE>mode) || SSE_VEC_FLOAT_MODE_P (<MODE>mode))\"\n+  \"!TARGET_XOP \n+  && (SSE_FLOAT_MODE_P (<MODE>mode) || SSE_VEC_FLOAT_MODE_P (<MODE>mode))\"\n   \"cmp%D3<ssemodesuffixf4>\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"ssecmp\")\n    (set_attr \"length_immediate\" \"1\")\n@@ -5614,7 +5618,7 @@\n \t\t   (match_operand:V4SI 2 \"register_operand\" \"\")))]\n   \"TARGET_SSE2\"\n {\n-  if (TARGET_SSE4_1)\n+  if (TARGET_SSE4_1 || TARGET_XOP)\n     ix86_fixup_binary_operands_no_copy (MULT, V4SImode, operands);\n })\n \n@@ -5643,7 +5647,7 @@\n   [(set (match_operand:V4SI 0 \"register_operand\" \"\")\n \t(mult:V4SI (match_operand:V4SI 1 \"register_operand\" \"\")\n \t\t   (match_operand:V4SI 2 \"register_operand\" \"\")))]\n-  \"TARGET_SSE2 && !TARGET_SSE4_1\n+  \"TARGET_SSE2 && !TARGET_SSE4_1 && !TARGET_XOP\n    && can_create_pseudo_p ()\"\n   \"#\"\n   \"&& 1\"\n@@ -5705,6 +5709,42 @@\n   rtx t1, t2, t3, t4, t5, t6, thirtytwo;\n   rtx op0, op1, op2;\n \n+  if (TARGET_XOP)\n+    {\n+      /* op1: A,B,C,D, op2: E,F,G,H */\n+      op0 = operands[0];\n+      op1 = gen_lowpart (V4SImode, operands[1]);\n+      op2 = gen_lowpart (V4SImode, operands[2]);\n+      t1 = gen_reg_rtx (V4SImode);\n+      t2 = gen_reg_rtx (V4SImode);\n+      t3 = gen_reg_rtx (V4SImode);\n+      t4 = gen_reg_rtx (V2DImode);\n+      t5 = gen_reg_rtx (V2DImode);\n+\n+      /* t1: B,A,D,C */\n+      emit_insn (gen_sse2_pshufd_1 (t1, op1,\n+\t\t\t\t    GEN_INT (1),\n+\t\t\t\t    GEN_INT (0),\n+\t\t\t\t    GEN_INT (3),\n+\t\t\t\t    GEN_INT (2)));\n+\n+      /* t2: 0 */\n+      emit_move_insn (t2, CONST0_RTX (V4SImode));\n+\n+      /* t3: (B*E),(A*F),(D*G),(C*H) */\n+      emit_insn (gen_xop_pmacsdd (t3, t1, op2, t2));\n+\n+      /* t4: (B*E)+(A*F), (D*G)+(C*H) */\n+      emit_insn (gen_xop_phadddq (t4, t3));\n+\n+      /* t5: ((B*E)+(A*F))<<32, ((D*G)+(C*H))<<32 */\n+      emit_insn (gen_ashlv2di3 (t5, t4, GEN_INT (32)));\n+\n+      /* op0: (((B*E)+(A*F))<<32)+(B*F), (((D*G)+(C*H))<<32)+(D*H) */\n+      emit_insn (gen_xop_pmacsdql (op0, op1, op2, t5));\n+      DONE;\n+    }\n+\n   op0 = operands[0];\n   op1 = operands[1];\n   op2 = operands[2];\n@@ -5820,6 +5860,56 @@\n   DONE;\n })\n \n+(define_expand \"vec_widen_smult_hi_v4si\"\n+  [(match_operand:V2DI 0 \"register_operand\" \"\")\n+   (match_operand:V4SI 1 \"register_operand\" \"\")\n+   (match_operand:V4SI 2 \"register_operand\" \"\")]\n+  \"TARGET_XOP\"\n+{\n+  rtx t1, t2;\n+\n+  t1 = gen_reg_rtx (V4SImode);\n+  t2 = gen_reg_rtx (V4SImode);\n+\n+  emit_insn (gen_sse2_pshufd_1 (t1, operands[1],\n+\t\t\t\tGEN_INT (0),\n+\t\t\t\tGEN_INT (2),\n+\t\t\t\tGEN_INT (1),\n+\t\t\t\tGEN_INT (3)));\n+  emit_insn (gen_sse2_pshufd_1 (t2, operands[2],\n+\t\t\t\tGEN_INT (0),\n+\t\t\t\tGEN_INT (2),\n+\t\t\t\tGEN_INT (1),\n+\t\t\t\tGEN_INT (3)));\n+  emit_insn (gen_xop_mulv2div2di3_high (operands[0], t1, t2));\n+  DONE;\n+})\n+\n+(define_expand \"vec_widen_smult_lo_v4si\"\n+  [(match_operand:V2DI 0 \"register_operand\" \"\")\n+   (match_operand:V4SI 1 \"register_operand\" \"\")\n+   (match_operand:V4SI 2 \"register_operand\" \"\")]\n+  \"TARGET_XOP\"\n+{\n+  rtx t1, t2;\n+\n+  t1 = gen_reg_rtx (V4SImode);\n+  t2 = gen_reg_rtx (V4SImode);\n+\n+  emit_insn (gen_sse2_pshufd_1 (t1, operands[1],\n+\t\t\t\tGEN_INT (0),\n+\t\t\t\tGEN_INT (2),\n+\t\t\t\tGEN_INT (1),\n+\t\t\t\tGEN_INT (3)));\n+  emit_insn (gen_sse2_pshufd_1 (t2, operands[2],\n+\t\t\t\tGEN_INT (0),\n+\t\t\t\tGEN_INT (2),\n+\t\t\t\tGEN_INT (1),\n+\t\t\t\tGEN_INT (3)));\n+  emit_insn (gen_xop_mulv2div2di3_low (operands[0], t1, t2));\n+  DONE;\n+})\n+\n (define_expand \"vec_widen_umult_hi_v4si\"\n   [(match_operand:V2DI 0 \"register_operand\" \"\")\n    (match_operand:V4SI 1 \"register_operand\" \"\")\n@@ -6217,7 +6307,7 @@\n \t(eq:SSEMODE124\n \t  (match_operand:SSEMODE124 1 \"nonimmediate_operand\" \"\")\n \t  (match_operand:SSEMODE124 2 \"nonimmediate_operand\" \"\")))]\n-  \"TARGET_SSE2\"\n+  \"TARGET_SSE2 && !TARGET_XOP \"\n   \"ix86_fixup_binary_operands_no_copy (EQ, <MODE>mode, operands);\")\n \n (define_insn \"*avx_eq<mode>3\"\n@@ -6240,7 +6330,7 @@\n \t(eq:SSEMODE124\n \t  (match_operand:SSEMODE124 1 \"nonimmediate_operand\" \"%0\")\n \t  (match_operand:SSEMODE124 2 \"nonimmediate_operand\" \"xm\")))]\n-  \"TARGET_SSE2\n+  \"TARGET_SSE2 && !TARGET_XOP\n    && ix86_binary_operator_ok (EQ, <MODE>mode, operands)\"\n   \"pcmpeq<ssevecsize>\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"ssecmp\")\n@@ -6286,7 +6376,7 @@\n \t(gt:SSEMODE124\n \t  (match_operand:SSEMODE124 1 \"register_operand\" \"0\")\n \t  (match_operand:SSEMODE124 2 \"nonimmediate_operand\" \"xm\")))]\n-  \"TARGET_SSE2\"\n+  \"TARGET_SSE2 && !TARGET_XOP\"\n   \"pcmpgt<ssevecsize>\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"ssecmp\")\n    (set_attr \"prefix_data16\" \"1\")\n@@ -10364,6 +10454,1445 @@\n    (set_attr \"prefix\" \"maybe_vex\")\n    (set_attr \"mode\" \"TI\")])\n \n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; XOP instructions\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; XOP parallel integer multiply/add instructions.\n+;; Note the instruction does not allow the value being added to be a memory\n+;; operation.  However by pretending via the nonimmediate_operand predicate\n+;; that it does and splitting it later allows the following to be recognized:\n+;;\ta[i] = b[i] * c[i] + d[i];\n+(define_insn \"xop_pmacsww\"\n+  [(set (match_operand:V8HI 0 \"register_operand\" \"=x,x,x\")\n+        (plus:V8HI\n+\t (mult:V8HI\n+\t  (match_operand:V8HI 1 \"nonimmediate_operand\" \"%x,x,xm\")\n+\t  (match_operand:V8HI 2 \"nonimmediate_operand\" \"x,xm,x\"))\n+\t (match_operand:V8HI 3 \"register_operand\" \"x,x,x\")))]\n+  \"TARGET_XOP && ix86_fma4_valid_op_p (operands, insn, 4, false, 2, true)\"\n+  \"@\n+   vpmacsww\\t{%3, %2, %1, %0|%0, %1, %2, %3}\n+   vpmacsww\\t{%3, %2, %1, %0|%0, %1, %2, %3}\n+   vpmacsww\\t{%3, %1, %2, %0|%0, %2, %1, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+;; Split pmacsww with two memory operands into a load and the pmacsww.\n+(define_split\n+  [(set (match_operand:V8HI 0 \"register_operand\" \"\")\n+\t(plus:V8HI\n+\t (mult:V8HI (match_operand:V8HI 1 \"nonimmediate_operand\" \"\")\n+\t\t    (match_operand:V8HI 2 \"nonimmediate_operand\" \"\"))\n+\t (match_operand:V8HI 3 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_XOP\n+   && !ix86_fma4_valid_op_p (operands, insn, 4, false, 1, true)\n+   && ix86_fma4_valid_op_p (operands, insn, 4, false, 2, true)\n+   && !reg_mentioned_p (operands[0], operands[1])\n+   && !reg_mentioned_p (operands[0], operands[2])\n+   && !reg_mentioned_p (operands[0], operands[3])\"\n+  [(const_int 0)]\n+{\n+  ix86_expand_fma4_multiple_memory (operands, 4, V8HImode);\n+  emit_insn (gen_xop_pmacsww (operands[0], operands[1], operands[2],\n+\t\t\t      operands[3]));\n+  DONE;\n+})\n+\n+(define_insn \"xop_pmacssww\"\n+  [(set (match_operand:V8HI 0 \"register_operand\" \"=x,x,x\")\n+        (ss_plus:V8HI\n+\t (mult:V8HI (match_operand:V8HI 1 \"nonimmediate_operand\" \"%x,x,m\")\n+\t\t    (match_operand:V8HI 2 \"nonimmediate_operand\" \"x,m,x\"))\n+\t (match_operand:V8HI 3 \"register_operand\" \"x,x,x\")))]\n+  \"TARGET_XOP && ix86_fma4_valid_op_p (operands, insn, 4, false, 1, true)\"\n+  \"@\n+   vpmacssww\\t{%3, %2, %1, %0|%0, %1, %2, %3}\n+   vpmacssww\\t{%3, %2, %1, %0|%0, %1, %2, %3}\n+   vpmacssww\\t{%3, %1, %2, %0|%0, %2, %1, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+;; Note the instruction does not allow the value being added to be a memory\n+;; operation.  However by pretending via the nonimmediate_operand predicate\n+;; that it does and splitting it later allows the following to be recognized:\n+;;\ta[i] = b[i] * c[i] + d[i];\n+(define_insn \"xop_pmacsdd\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=x,x,x\")\n+        (plus:V4SI\n+\t (mult:V4SI\n+\t  (match_operand:V4SI 1 \"nonimmediate_operand\" \"%x,x,m\")\n+\t  (match_operand:V4SI 2 \"nonimmediate_operand\" \"x,m,x\"))\n+\t (match_operand:V4SI 3 \"register_operand\" \"x,x,x\")))]\n+  \"TARGET_XOP && ix86_fma4_valid_op_p (operands, insn, 4, false, 2, true)\"\n+  \"@\n+   vpmacsdd\\t{%3, %2, %1, %0|%0, %1, %2, %3}\n+   vpmacsdd\\t{%3, %2, %1, %0|%0, %1, %2, %3}\n+   vpmacsdd\\t{%3, %1, %2, %0|%0, %2, %1, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+;; Split pmacsdd with two memory operands into a load and the pmacsdd.\n+(define_split\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"\")\n+\t(plus:V4SI\n+\t (mult:V4SI (match_operand:V4SI 1 \"nonimmediate_operand\" \"\")\n+\t\t    (match_operand:V4SI 2 \"nonimmediate_operand\" \"\"))\n+\t (match_operand:V4SI 3 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_XOP\n+   && !ix86_fma4_valid_op_p (operands, insn, 4, false, 1, true)\n+   && ix86_fma4_valid_op_p (operands, insn, 4, false, 2, true)\n+   && !reg_mentioned_p (operands[0], operands[1])\n+   && !reg_mentioned_p (operands[0], operands[2])\n+   && !reg_mentioned_p (operands[0], operands[3])\"\n+  [(const_int 0)]\n+{\n+  ix86_expand_fma4_multiple_memory (operands, 4, V4SImode);\n+  emit_insn (gen_xop_pmacsdd (operands[0], operands[1], operands[2],\n+\t\t\t      operands[3]));\n+  DONE;\n+})\n+\n+(define_insn \"xop_pmacssdd\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=x,x,x\")\n+        (ss_plus:V4SI\n+\t (mult:V4SI (match_operand:V4SI 1 \"nonimmediate_operand\" \"%x,x,m\")\n+\t\t    (match_operand:V4SI 2 \"nonimmediate_operand\" \"x,m,x\"))\n+\t (match_operand:V4SI 3 \"register_operand\" \"x,x,x\")))]\n+  \"TARGET_XOP && ix86_fma4_valid_op_p (operands, insn, 4, false, 1, true)\"\n+  \"@\n+   vpmacssdd\\t{%3, %2, %1, %0|%0, %1, %2, %3}\n+   vpmacssdd\\t{%3, %2, %1, %0|%0, %1, %2, %3}\n+   vpmacssdd\\t{%3, %1, %2, %0|%0, %2, %1, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+(define_insn \"xop_pmacssdql\"\n+  [(set (match_operand:V2DI 0 \"register_operand\" \"=x,x,x\")\n+\t(ss_plus:V2DI\n+\t (mult:V2DI\n+\t  (sign_extend:V2DI\n+\t   (vec_select:V2SI\n+\t    (match_operand:V4SI 1 \"nonimmediate_operand\" \"%x,x,m\")\n+\t    (parallel [(const_int 1)\n+\t\t       (const_int 3)])))\n+\t  (vec_select:V2SI\n+\t   (match_operand:V4SI 2 \"nonimmediate_operand\" \"x,m,x\")\n+\t   (parallel [(const_int 1)\n+\t\t      (const_int 3)])))\n+\t (match_operand:V2DI 3 \"register_operand\" \"x,x,x\")))]\n+  \"TARGET_XOP && ix86_fma4_valid_op_p (operands, insn, 4, false, 1, true)\"\n+  \"@\n+   vpmacssdql\\t{%3, %2, %1, %0|%0, %1, %2, %3}\n+   vpmacssdql\\t{%3, %2, %1, %0|%0, %1, %2, %3}\n+   vpmacssdql\\t{%3, %1, %2, %0|%0, %2, %1, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+(define_insn \"xop_pmacssdqh\"\n+  [(set (match_operand:V2DI 0 \"register_operand\" \"=x,x,x\")\n+\t(ss_plus:V2DI\n+\t (mult:V2DI\n+\t  (sign_extend:V2DI\n+\t   (vec_select:V2SI\n+\t    (match_operand:V4SI 1 \"nonimmediate_operand\" \"%x,x,m\")\n+\t    (parallel [(const_int 0)\n+\t\t       (const_int 2)])))\n+\t  (sign_extend:V2DI\n+\t   (vec_select:V2SI\n+\t    (match_operand:V4SI 2 \"nonimmediate_operand\" \"x,m,x\")\n+\t    (parallel [(const_int 0)\n+\t\t       (const_int 2)]))))\n+\t (match_operand:V2DI 3 \"register_operand\" \"x,x,x\")))]\n+  \"TARGET_XOP && ix86_fma4_valid_op_p (operands, insn, 4, false, 1, true)\"\n+  \"@\n+   vpmacssdqh\\t{%3, %2, %1, %0|%0, %1, %2, %3}\n+   vpmacssdqh\\t{%3, %2, %1, %0|%0, %1, %2, %3}\n+   vpmacssdqh\\t{%3, %1, %2, %0|%0, %2, %1, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+(define_insn \"xop_pmacsdql\"\n+  [(set (match_operand:V2DI 0 \"register_operand\" \"=x,x,x\")\n+\t(plus:V2DI\n+\t (mult:V2DI\n+\t  (sign_extend:V2DI\n+\t   (vec_select:V2SI\n+\t    (match_operand:V4SI 1 \"nonimmediate_operand\" \"%x,x,m\")\n+\t    (parallel [(const_int 1)\n+\t\t       (const_int 3)])))\n+\t  (sign_extend:V2DI\n+\t   (vec_select:V2SI\n+\t    (match_operand:V4SI 2 \"nonimmediate_operand\" \"x,m,x\")\n+\t    (parallel [(const_int 1)\n+\t\t       (const_int 3)]))))\n+\t (match_operand:V2DI 3 \"register_operand\" \"x,x,x\")))]\n+  \"TARGET_XOP && ix86_fma4_valid_op_p (operands, insn, 4, false, 1, true)\"\n+  \"@\n+   vpmacsdql\\t{%3, %2, %1, %0|%0, %1, %2, %3}\n+   vpmacsdql\\t{%3, %2, %1, %0|%0, %1, %2, %3}\n+   vpmacsdql\\t{%3, %1, %2, %0|%0, %2, %1, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+(define_insn_and_split \"*xop_pmacsdql_mem\"\n+  [(set (match_operand:V2DI 0 \"register_operand\" \"=&x,&x,&x\")\n+\t(plus:V2DI\n+\t (mult:V2DI\n+\t  (sign_extend:V2DI\n+\t   (vec_select:V2SI\n+\t    (match_operand:V4SI 1 \"nonimmediate_operand\" \"%x,x,m\")\n+\t    (parallel [(const_int 1)\n+\t\t       (const_int 3)])))\n+\t  (sign_extend:V2DI\n+\t   (vec_select:V2SI\n+\t    (match_operand:V4SI 2 \"nonimmediate_operand\" \"x,m,x\")\n+\t    (parallel [(const_int 1)\n+\t\t       (const_int 3)]))))\n+\t (match_operand:V2DI 3 \"memory_operand\" \"m,m,m\")))]\n+  \"TARGET_XOP && ix86_fma4_valid_op_p (operands, insn, 4, false, -1, true)\"\n+  \"#\"\n+  \"&& (reload_completed\n+       || (!reg_mentioned_p (operands[0], operands[1])\n+\t   && !reg_mentioned_p (operands[0], operands[2])))\"\n+  [(set (match_dup 0)\n+\t(match_dup 3))\n+   (set (match_dup 0)\n+\t(plus:V2DI\n+\t (mult:V2DI\n+\t  (sign_extend:V2DI\n+\t   (vec_select:V2SI\n+\t    (match_dup 1)\n+\t    (parallel [(const_int 1)\n+\t\t       (const_int 3)])))\n+\t  (sign_extend:V2DI\n+\t   (vec_select:V2SI\n+\t    (match_dup 2)\n+\t    (parallel [(const_int 1)\n+\t\t       (const_int 3)]))))\n+\t (match_dup 0)))])\n+\n+;; We don't have a straight 32-bit parallel multiply and extend on XOP, so\n+;; fake it with a multiply/add.  In general, we expect the define_split to\n+;; occur before register allocation, so we have to handle the corner case where\n+;; the target is the same as operands 1/2\n+(define_insn_and_split \"xop_mulv2div2di3_low\"\n+  [(set (match_operand:V2DI 0 \"register_operand\" \"=&x\")\n+\t(mult:V2DI\n+\t  (sign_extend:V2DI\n+\t    (vec_select:V2SI\n+\t      (match_operand:V4SI 1 \"nonimmediate_operand\" \"%x\")\n+\t      (parallel [(const_int 1)\n+\t\t\t (const_int 3)])))\n+\t  (sign_extend:V2DI\n+\t    (vec_select:V2SI\n+\t      (match_operand:V4SI 2 \"nonimmediate_operand\" \"xm\")\n+\t      (parallel [(const_int 1)\n+\t\t\t (const_int 3)])))))]\n+  \"TARGET_XOP\"\n+  \"#\"\n+  \"&& (reload_completed\n+       || (!reg_mentioned_p (operands[0], operands[1])\n+\t   && !reg_mentioned_p (operands[0], operands[2])))\"\n+  [(set (match_dup 0)\n+\t(match_dup 3))\n+   (set (match_dup 0)\n+\t(plus:V2DI\n+\t (mult:V2DI\n+\t  (sign_extend:V2DI\n+\t   (vec_select:V2SI\n+\t    (match_dup 1)\n+\t    (parallel [(const_int 1)\n+\t\t       (const_int 3)])))\n+\t  (sign_extend:V2DI\n+\t   (vec_select:V2SI\n+\t    (match_dup 2)\n+\t    (parallel [(const_int 1)\n+\t\t       (const_int 3)]))))\n+\t (match_dup 0)))]\n+{\n+  operands[3] = CONST0_RTX (V2DImode);\n+}\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+(define_insn \"xop_pmacsdqh\"\n+  [(set (match_operand:V2DI 0 \"register_operand\" \"=x,x,x\")\n+\t(plus:V2DI\n+\t (mult:V2DI\n+\t  (sign_extend:V2DI\n+\t   (vec_select:V2SI\n+\t    (match_operand:V4SI 1 \"nonimmediate_operand\" \"%x,x,m\")\n+\t    (parallel [(const_int 0)\n+\t\t       (const_int 2)])))\n+\t  (sign_extend:V2DI\n+\t   (vec_select:V2SI\n+\t    (match_operand:V4SI 2 \"nonimmediate_operand\" \"x,m,x\")\n+\t    (parallel [(const_int 0)\n+\t\t       (const_int 2)]))))\n+\t (match_operand:V2DI 3 \"register_operand\" \"x,x,x\")))]\n+  \"TARGET_XOP && ix86_fma4_valid_op_p (operands, insn, 4, false, 1, true)\"\n+  \"@\n+   vpmacsdqh\\t{%3, %2, %1, %0|%0, %1, %2, %3}\n+   vpmacsdqh\\t{%3, %2, %1, %0|%0, %1, %2, %3}\n+   vpmacsdqh\\t{%3, %1, %2, %0|%0, %2, %1, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+(define_insn_and_split \"*xop_pmacsdqh_mem\"\n+  [(set (match_operand:V2DI 0 \"register_operand\" \"=&x,&x,&x\")\n+\t(plus:V2DI\n+\t (mult:V2DI\n+\t  (sign_extend:V2DI\n+\t   (vec_select:V2SI\n+\t    (match_operand:V4SI 1 \"nonimmediate_operand\" \"%x,x,m\")\n+\t    (parallel [(const_int 0)\n+\t\t       (const_int 2)])))\n+\t  (sign_extend:V2DI\n+\t   (vec_select:V2SI\n+\t    (match_operand:V4SI 2 \"nonimmediate_operand\" \"x,m,x\")\n+\t    (parallel [(const_int 0)\n+\t\t       (const_int 2)]))))\n+\t (match_operand:V2DI 3 \"memory_operand\" \"m,m,m\")))]\n+  \"TARGET_XOP && ix86_fma4_valid_op_p (operands, insn, 4, false, -1, true)\"\n+  \"#\"\n+  \"&& (reload_completed\n+       || (!reg_mentioned_p (operands[0], operands[1])\n+\t   && !reg_mentioned_p (operands[0], operands[2])))\"\n+  [(set (match_dup 0)\n+\t(match_dup 3))\n+   (set (match_dup 0)\n+\t(plus:V2DI\n+\t (mult:V2DI\n+\t  (sign_extend:V2DI\n+\t   (vec_select:V2SI\n+\t    (match_dup 1)\n+\t    (parallel [(const_int 0)\n+\t\t       (const_int 2)])))\n+\t  (sign_extend:V2DI\n+\t   (vec_select:V2SI\n+\t    (match_dup 2)\n+\t    (parallel [(const_int 0)\n+\t\t       (const_int 2)]))))\n+\t (match_dup 0)))])\n+\n+;; We don't have a straight 32-bit parallel multiply and extend on XOP, so\n+;; fake it with a multiply/add.  In general, we expect the define_split to\n+;; occur before register allocation, so we have to handle the corner case where\n+;; the target is the same as either operands[1] or operands[2]\n+(define_insn_and_split \"xop_mulv2div2di3_high\"\n+  [(set (match_operand:V2DI 0 \"register_operand\" \"=&x\")\n+\t(mult:V2DI\n+\t  (sign_extend:V2DI\n+\t    (vec_select:V2SI\n+\t      (match_operand:V4SI 1 \"nonimmediate_operand\" \"%x\")\n+\t      (parallel [(const_int 0)\n+\t\t\t (const_int 2)])))\n+\t  (sign_extend:V2DI\n+\t    (vec_select:V2SI\n+\t      (match_operand:V4SI 2 \"nonimmediate_operand\" \"xm\")\n+\t      (parallel [(const_int 0)\n+\t\t\t (const_int 2)])))))]\n+  \"TARGET_XOP\"\n+  \"#\"\n+  \"&& (reload_completed\n+       || (!reg_mentioned_p (operands[0], operands[1])\n+\t   && !reg_mentioned_p (operands[0], operands[2])))\"\n+  [(set (match_dup 0)\n+\t(match_dup 3))\n+   (set (match_dup 0)\n+\t(plus:V2DI\n+\t (mult:V2DI\n+\t  (sign_extend:V2DI\n+\t   (vec_select:V2SI\n+\t    (match_dup 1)\n+\t    (parallel [(const_int 0)\n+\t\t       (const_int 2)])))\n+\t  (sign_extend:V2DI\n+\t   (vec_select:V2SI\n+\t    (match_dup 2)\n+\t    (parallel [(const_int 0)\n+\t\t       (const_int 2)]))))\n+\t (match_dup 0)))]\n+{\n+  operands[3] = CONST0_RTX (V2DImode);\n+}\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+;; XOP parallel integer multiply/add instructions for the intrinisics\n+(define_insn \"xop_pmacsswd\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=x,x,x\")\n+\t(ss_plus:V4SI\n+\t (mult:V4SI\n+\t  (sign_extend:V4SI\n+\t   (vec_select:V4HI\n+\t    (match_operand:V8HI 1 \"nonimmediate_operand\" \"%x,x,m\")\n+\t    (parallel [(const_int 1)\n+\t\t       (const_int 3)\n+\t\t       (const_int 5)\n+\t\t       (const_int 7)])))\n+\t  (sign_extend:V4SI\n+\t   (vec_select:V4HI\n+\t    (match_operand:V8HI 2 \"nonimmediate_operand\" \"x,m,x\")\n+\t    (parallel [(const_int 1)\n+\t\t       (const_int 3)\n+\t\t       (const_int 5)\n+\t\t       (const_int 7)]))))\n+\t (match_operand:V4SI 3 \"register_operand\" \"x,x,x\")))]\n+  \"TARGET_XOP && ix86_fma4_valid_op_p (operands, insn, 4, false, 1, true)\"\n+  \"@\n+   vpmacsswd\\t{%3, %2, %1, %0|%0, %1, %2, %3}\n+   vpmacsswd\\t{%3, %2, %1, %0|%0, %1, %2, %3}\n+   vpmacsswd\\t{%3, %1, %2, %0|%0, %2, %1, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+(define_insn \"xop_pmacswd\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=x,x,x\")\n+\t(plus:V4SI\n+\t (mult:V4SI\n+\t  (sign_extend:V4SI\n+\t   (vec_select:V4HI\n+\t    (match_operand:V8HI 1 \"nonimmediate_operand\" \"%x,x,m\")\n+\t    (parallel [(const_int 1)\n+\t\t       (const_int 3)\n+\t\t       (const_int 5)\n+\t\t       (const_int 7)])))\n+\t  (sign_extend:V4SI\n+\t   (vec_select:V4HI\n+\t    (match_operand:V8HI 2 \"nonimmediate_operand\" \"x,m,x\")\n+\t    (parallel [(const_int 1)\n+\t\t       (const_int 3)\n+\t\t       (const_int 5)\n+\t\t       (const_int 7)]))))\n+\t (match_operand:V4SI 3 \"register_operand\" \"x,x,x\")))]\n+  \"TARGET_XOP && ix86_fma4_valid_op_p (operands, insn, 4, false, 1, true)\"\n+  \"@\n+   vpmacswd\\t{%3, %2, %1, %0|%0, %1, %2, %3}\n+   vpmacswd\\t{%3, %2, %1, %0|%0, %1, %2, %3}\n+   vpmacswd\\t{%3, %1, %2, %0|%0, %2, %1, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+(define_insn \"xop_pmadcsswd\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=x,x,x\")\n+\t(ss_plus:V4SI\n+\t (plus:V4SI\n+\t  (mult:V4SI\n+\t   (sign_extend:V4SI\n+\t    (vec_select:V4HI\n+\t     (match_operand:V8HI 1 \"nonimmediate_operand\" \"%x,x,m\")\n+\t     (parallel [(const_int 0)\n+\t\t\t(const_int 2)\n+\t\t\t(const_int 4)\n+\t\t\t(const_int 6)])))\n+\t   (sign_extend:V4SI\n+\t    (vec_select:V4HI\n+\t     (match_operand:V8HI 2 \"nonimmediate_operand\" \"x,m,x\")\n+\t     (parallel [(const_int 0)\n+\t\t\t(const_int 2)\n+\t\t\t(const_int 4)\n+\t\t\t(const_int 6)]))))\n+\t  (mult:V4SI\n+\t   (sign_extend:V4SI\n+\t    (vec_select:V4HI\n+\t     (match_dup 1)\n+\t     (parallel [(const_int 1)\n+\t\t\t(const_int 3)\n+\t\t\t(const_int 5)\n+\t\t\t(const_int 7)])))\n+\t   (sign_extend:V4SI\n+\t    (vec_select:V4HI\n+\t     (match_dup 2)\n+\t     (parallel [(const_int 1)\n+\t\t\t(const_int 3)\n+\t\t\t(const_int 5)\n+\t\t\t(const_int 7)])))))\n+\t (match_operand:V4SI 3 \"register_operand\" \"x,x,x\")))]\n+  \"TARGET_XOP && ix86_fma4_valid_op_p (operands, insn, 4, false, 1, true)\"\n+  \"@\n+   vpmadcsswd\\t{%3, %2, %1, %0|%0, %1, %2, %3}\n+   vpmadcsswd\\t{%3, %2, %1, %0|%0, %1, %2, %3}\n+   vpmadcsswd\\t{%3, %1, %2, %0|%0, %2, %1, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+(define_insn \"xop_pmadcswd\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=x,x,x\")\n+\t(plus:V4SI\n+\t (plus:V4SI\n+\t  (mult:V4SI\n+\t   (sign_extend:V4SI\n+\t    (vec_select:V4HI\n+\t     (match_operand:V8HI 1 \"nonimmediate_operand\" \"%x,x,m\")\n+\t     (parallel [(const_int 0)\n+\t\t\t(const_int 2)\n+\t\t\t(const_int 4)\n+\t\t\t(const_int 6)])))\n+\t   (sign_extend:V4SI\n+\t    (vec_select:V4HI\n+\t     (match_operand:V8HI 2 \"nonimmediate_operand\" \"x,m,x\")\n+\t     (parallel [(const_int 0)\n+\t\t\t(const_int 2)\n+\t\t\t(const_int 4)\n+\t\t\t(const_int 6)]))))\n+\t  (mult:V4SI\n+\t   (sign_extend:V4SI\n+\t    (vec_select:V4HI\n+\t     (match_dup 1)\n+\t     (parallel [(const_int 1)\n+\t\t\t(const_int 3)\n+\t\t\t(const_int 5)\n+\t\t\t(const_int 7)])))\n+\t   (sign_extend:V4SI\n+\t    (vec_select:V4HI\n+\t     (match_dup 2)\n+\t     (parallel [(const_int 1)\n+\t\t\t(const_int 3)\n+\t\t\t(const_int 5)\n+\t\t\t(const_int 7)])))))\n+\t (match_operand:V4SI 3 \"register_operand\" \"x,x,x\")))]\n+  \"TARGET_XOP && ix86_fma4_valid_op_p (operands, insn, 4, false, 1, true)\"\n+  \"@\n+   vpmadcswd\\t{%3, %2, %1, %0|%0, %1, %2, %3}\n+   vpmadcswd\\t{%3, %2, %1, %0|%0, %1, %2, %3}\n+   vpmadcswd\\t{%3, %1, %2, %0|%0, %2, %1, %3}\"\n+  [(set_attr \"type\" \"ssemuladd\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+;; XOP parallel XMM conditional moves\n+(define_insn \"xop_pcmov_<mode>\"\n+  [(set (match_operand:SSEMODE 0 \"register_operand\" \"=x,x,x\")\n+\t(if_then_else:SSEMODE\n+\t  (match_operand:SSEMODE 3 \"nonimmediate_operand\" \"x,x,xm\")\n+\t  (match_operand:SSEMODE 1 \"vector_move_operand\" \"x,xm,x\")\n+\t  (match_operand:SSEMODE 2 \"vector_move_operand\" \"xm,x,x\")))]\n+  \"TARGET_XOP && ix86_fma4_valid_op_p (operands, insn, 4, true, 1, false)\"\n+  \"@\n+   vpcmov\\t{%3, %2, %1, %0|%0, %1, %2, %3}\n+   vpcmov\\t{%3, %2, %1, %0|%0, %1, %2, %3}\n+   vpcmov\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"sse4arg\")])\n+\n+(define_insn \"xop_pcmov_<mode>256\"\n+  [(set (match_operand:AVX256MODE 0 \"register_operand\" \"=x,x,x\")\n+\t(if_then_else:AVX256MODE\n+\t  (match_operand:AVX256MODE 3 \"nonimmediate_operand\" \"x,x,xm\")\n+\t  (match_operand:AVX256MODE 1 \"vector_move_operand\" \"x,xm,x\")\n+\t  (match_operand:AVX256MODE 2 \"vector_move_operand\" \"xm,x,x\")))]\n+  \"TARGET_XOP && ix86_fma4_valid_op_p (operands, insn, 4, true, 1, false)\"\n+  \"@\n+   vpcmov\\t{%3, %2, %1, %0|%0, %1, %2, %3}\n+   vpcmov\\t{%3, %2, %1, %0|%0, %1, %2, %3}\n+   vpcmov\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"sse4arg\")])\n+\n+;; XOP horizontal add/subtract instructions\n+(define_insn \"xop_phaddbw\"\n+  [(set (match_operand:V8HI 0 \"register_operand\" \"=x\")\n+\t(plus:V8HI\n+\t (sign_extend:V8HI\n+\t  (vec_select:V8QI\n+\t   (match_operand:V16QI 1 \"nonimmediate_operand\" \"xm\")\n+\t   (parallel [(const_int 0)\n+\t\t      (const_int 2)\n+\t\t      (const_int 4)\n+\t\t      (const_int 6)\n+\t\t      (const_int 8)\n+\t\t      (const_int 10)\n+\t\t      (const_int 12)\n+\t\t      (const_int 14)])))\n+\t (sign_extend:V8HI\n+\t  (vec_select:V8QI\n+\t   (match_dup 1)\n+\t   (parallel [(const_int 1)\n+\t\t      (const_int 3)\n+\t\t      (const_int 5)\n+\t\t      (const_int 7)\n+\t\t      (const_int 9)\n+\t\t      (const_int 11)\n+\t\t      (const_int 13)\n+\t\t      (const_int 15)])))))]\n+  \"TARGET_XOP\"\n+  \"vphaddbw\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sseiadd1\")])\n+\n+(define_insn \"xop_phaddbd\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=x\")\n+\t(plus:V4SI\n+\t (plus:V4SI\n+\t  (sign_extend:V4SI\n+\t   (vec_select:V4QI\n+\t    (match_operand:V16QI 1 \"nonimmediate_operand\" \"xm\")\n+\t    (parallel [(const_int 0)\n+\t\t       (const_int 4)\n+\t\t       (const_int 8)\n+\t\t       (const_int 12)])))\n+\t  (sign_extend:V4SI\n+\t   (vec_select:V4QI\n+\t    (match_dup 1)\n+\t    (parallel [(const_int 1)\n+\t\t       (const_int 5)\n+\t\t       (const_int 9)\n+\t\t       (const_int 13)]))))\n+\t (plus:V4SI\n+\t  (sign_extend:V4SI\n+\t   (vec_select:V4QI\n+\t    (match_dup 1)\n+\t    (parallel [(const_int 2)\n+\t\t       (const_int 6)\n+\t\t       (const_int 10)\n+\t\t       (const_int 14)])))\n+\t  (sign_extend:V4SI\n+\t   (vec_select:V4QI\n+\t    (match_dup 1)\n+\t    (parallel [(const_int 3)\n+\t\t       (const_int 7)\n+\t\t       (const_int 11)\n+\t\t       (const_int 15)]))))))]\n+  \"TARGET_XOP\"\n+  \"vphaddbd\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sseiadd1\")])\n+\n+(define_insn \"xop_phaddbq\"\n+  [(set (match_operand:V2DI 0 \"register_operand\" \"=x\")\n+\t(plus:V2DI\n+\t (plus:V2DI\n+\t  (plus:V2DI\n+\t   (sign_extend:V2DI\n+\t    (vec_select:V2QI\n+\t     (match_operand:V16QI 1 \"nonimmediate_operand\" \"xm\")\n+\t     (parallel [(const_int 0)\n+\t\t\t(const_int 4)])))\n+\t   (sign_extend:V2DI\n+\t    (vec_select:V2QI\n+\t     (match_dup 1)\n+\t     (parallel [(const_int 1)\n+\t\t\t(const_int 5)]))))\n+\t  (plus:V2DI\n+\t   (sign_extend:V2DI\n+\t    (vec_select:V2QI\n+\t     (match_dup 1)\n+\t     (parallel [(const_int 2)\n+\t\t\t(const_int 6)])))\n+\t   (sign_extend:V2DI\n+\t    (vec_select:V2QI\n+\t     (match_dup 1)\n+\t     (parallel [(const_int 3)\n+\t\t\t(const_int 7)])))))\n+\t (plus:V2DI\n+\t  (plus:V2DI\n+\t   (sign_extend:V2DI\n+\t    (vec_select:V2QI\n+\t     (match_dup 1)\n+\t     (parallel [(const_int 8)\n+\t\t\t(const_int 12)])))\n+\t   (sign_extend:V2DI\n+\t    (vec_select:V2QI\n+\t     (match_dup 1)\n+\t     (parallel [(const_int 9)\n+\t\t\t(const_int 13)]))))\n+\t  (plus:V2DI\n+\t   (sign_extend:V2DI\n+\t    (vec_select:V2QI\n+\t     (match_dup 1)\n+\t     (parallel [(const_int 10)\n+\t\t\t(const_int 14)])))\n+\t   (sign_extend:V2DI\n+\t    (vec_select:V2QI\n+\t     (match_dup 1)\n+\t     (parallel [(const_int 11)\n+\t\t\t(const_int 15)])))))))]\n+  \"TARGET_XOP\"\n+  \"vphaddbq\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sseiadd1\")])\n+\n+(define_insn \"xop_phaddwd\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=x\")\n+\t(plus:V4SI\n+\t (sign_extend:V4SI\n+\t  (vec_select:V4HI\n+\t   (match_operand:V8HI 1 \"nonimmediate_operand\" \"xm\")\n+\t   (parallel [(const_int 0)\n+\t\t      (const_int 2)\n+\t\t      (const_int 4)\n+\t\t      (const_int 6)])))\n+\t (sign_extend:V4SI\n+\t  (vec_select:V4HI\n+\t   (match_dup 1)\n+\t   (parallel [(const_int 1)\n+\t\t      (const_int 3)\n+\t\t      (const_int 5)\n+\t\t      (const_int 7)])))))]\n+  \"TARGET_XOP\"\n+  \"vphaddwd\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sseiadd1\")])\n+\n+(define_insn \"xop_phaddwq\"\n+  [(set (match_operand:V2DI 0 \"register_operand\" \"=x\")\n+\t(plus:V2DI\n+\t (plus:V2DI\n+\t  (sign_extend:V2DI\n+\t   (vec_select:V2HI\n+\t    (match_operand:V8HI 1 \"nonimmediate_operand\" \"xm\")\n+\t    (parallel [(const_int 0)\n+\t\t       (const_int 4)])))\n+\t  (sign_extend:V2DI\n+\t   (vec_select:V2HI\n+\t    (match_dup 1)\n+\t    (parallel [(const_int 1)\n+\t\t       (const_int 5)]))))\n+\t (plus:V2DI\n+\t  (sign_extend:V2DI\n+\t   (vec_select:V2HI\n+\t    (match_dup 1)\n+\t    (parallel [(const_int 2)\n+\t\t       (const_int 6)])))\n+\t  (sign_extend:V2DI\n+\t   (vec_select:V2HI\n+\t    (match_dup 1)\n+\t    (parallel [(const_int 3)\n+\t\t       (const_int 7)]))))))]\n+  \"TARGET_XOP\"\n+  \"vphaddwq\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sseiadd1\")])\n+\n+(define_insn \"xop_phadddq\"\n+  [(set (match_operand:V2DI 0 \"register_operand\" \"=x\")\n+\t(plus:V2DI\n+\t (sign_extend:V2DI\n+\t  (vec_select:V2SI\n+\t   (match_operand:V4SI 1 \"nonimmediate_operand\" \"xm\")\n+\t   (parallel [(const_int 0)\n+\t\t      (const_int 2)])))\n+\t (sign_extend:V2DI\n+\t  (vec_select:V2SI\n+\t   (match_dup 1)\n+\t   (parallel [(const_int 1)\n+\t\t      (const_int 3)])))))]\n+  \"TARGET_XOP\"\n+  \"vphadddq\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sseiadd1\")])\n+\n+(define_insn \"xop_phaddubw\"\n+  [(set (match_operand:V8HI 0 \"register_operand\" \"=x\")\n+\t(plus:V8HI\n+\t (zero_extend:V8HI\n+\t  (vec_select:V8QI\n+\t   (match_operand:V16QI 1 \"nonimmediate_operand\" \"xm\")\n+\t   (parallel [(const_int 0)\n+\t\t      (const_int 2)\n+\t\t      (const_int 4)\n+\t\t      (const_int 6)\n+\t\t      (const_int 8)\n+\t\t      (const_int 10)\n+\t\t      (const_int 12)\n+\t\t      (const_int 14)])))\n+\t (zero_extend:V8HI\n+\t  (vec_select:V8QI\n+\t   (match_dup 1)\n+\t   (parallel [(const_int 1)\n+\t\t      (const_int 3)\n+\t\t      (const_int 5)\n+\t\t      (const_int 7)\n+\t\t      (const_int 9)\n+\t\t      (const_int 11)\n+\t\t      (const_int 13)\n+\t\t      (const_int 15)])))))]\n+  \"TARGET_XOP\"\n+  \"vphaddubw\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sseiadd1\")])\n+\n+(define_insn \"xop_phaddubd\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=x\")\n+\t(plus:V4SI\n+\t (plus:V4SI\n+\t  (zero_extend:V4SI\n+\t   (vec_select:V4QI\n+\t    (match_operand:V16QI 1 \"nonimmediate_operand\" \"xm\")\n+\t    (parallel [(const_int 0)\n+\t\t       (const_int 4)\n+\t\t       (const_int 8)\n+\t\t       (const_int 12)])))\n+\t  (zero_extend:V4SI\n+\t   (vec_select:V4QI\n+\t    (match_dup 1)\n+\t    (parallel [(const_int 1)\n+\t\t       (const_int 5)\n+\t\t       (const_int 9)\n+\t\t       (const_int 13)]))))\n+\t (plus:V4SI\n+\t  (zero_extend:V4SI\n+\t   (vec_select:V4QI\n+\t    (match_dup 1)\n+\t    (parallel [(const_int 2)\n+\t\t       (const_int 6)\n+\t\t       (const_int 10)\n+\t\t       (const_int 14)])))\n+\t  (zero_extend:V4SI\n+\t   (vec_select:V4QI\n+\t    (match_dup 1)\n+\t    (parallel [(const_int 3)\n+\t\t       (const_int 7)\n+\t\t       (const_int 11)\n+\t\t       (const_int 15)]))))))]\n+  \"TARGET_XOP\"\n+  \"vphaddubd\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sseiadd1\")])\n+\n+(define_insn \"xop_phaddubq\"\n+  [(set (match_operand:V2DI 0 \"register_operand\" \"=x\")\n+\t(plus:V2DI\n+\t (plus:V2DI\n+\t  (plus:V2DI\n+\t   (zero_extend:V2DI\n+\t    (vec_select:V2QI\n+\t     (match_operand:V16QI 1 \"nonimmediate_operand\" \"xm\")\n+\t     (parallel [(const_int 0)\n+\t\t\t(const_int 4)])))\n+\t   (sign_extend:V2DI\n+\t    (vec_select:V2QI\n+\t     (match_dup 1)\n+\t     (parallel [(const_int 1)\n+\t\t\t(const_int 5)]))))\n+\t  (plus:V2DI\n+\t   (zero_extend:V2DI\n+\t    (vec_select:V2QI\n+\t     (match_dup 1)\n+\t     (parallel [(const_int 2)\n+\t\t\t(const_int 6)])))\n+\t   (zero_extend:V2DI\n+\t    (vec_select:V2QI\n+\t     (match_dup 1)\n+\t     (parallel [(const_int 3)\n+\t\t\t(const_int 7)])))))\n+\t (plus:V2DI\n+\t  (plus:V2DI\n+\t   (zero_extend:V2DI\n+\t    (vec_select:V2QI\n+\t     (match_dup 1)\n+\t     (parallel [(const_int 8)\n+\t\t\t(const_int 12)])))\n+\t   (sign_extend:V2DI\n+\t    (vec_select:V2QI\n+\t     (match_dup 1)\n+\t     (parallel [(const_int 9)\n+\t\t\t(const_int 13)]))))\n+\t  (plus:V2DI\n+\t   (zero_extend:V2DI\n+\t    (vec_select:V2QI\n+\t     (match_dup 1)\n+\t     (parallel [(const_int 10)\n+\t\t\t(const_int 14)])))\n+\t   (zero_extend:V2DI\n+\t    (vec_select:V2QI\n+\t     (match_dup 1)\n+\t     (parallel [(const_int 11)\n+\t\t\t(const_int 15)])))))))]\n+  \"TARGET_XOP\"\n+  \"vphaddubq\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sseiadd1\")])\n+\n+(define_insn \"xop_phadduwd\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=x\")\n+\t(plus:V4SI\n+\t (zero_extend:V4SI\n+\t  (vec_select:V4HI\n+\t   (match_operand:V8HI 1 \"nonimmediate_operand\" \"xm\")\n+\t   (parallel [(const_int 0)\n+\t\t      (const_int 2)\n+\t\t      (const_int 4)\n+\t\t      (const_int 6)])))\n+\t (zero_extend:V4SI\n+\t  (vec_select:V4HI\n+\t   (match_dup 1)\n+\t   (parallel [(const_int 1)\n+\t\t      (const_int 3)\n+\t\t      (const_int 5)\n+\t\t      (const_int 7)])))))]\n+  \"TARGET_XOP\"\n+  \"vphadduwd\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sseiadd1\")])\n+\n+(define_insn \"xop_phadduwq\"\n+  [(set (match_operand:V2DI 0 \"register_operand\" \"=x\")\n+\t(plus:V2DI\n+\t (plus:V2DI\n+\t  (zero_extend:V2DI\n+\t   (vec_select:V2HI\n+\t    (match_operand:V8HI 1 \"nonimmediate_operand\" \"xm\")\n+\t    (parallel [(const_int 0)\n+\t\t       (const_int 4)])))\n+\t  (zero_extend:V2DI\n+\t   (vec_select:V2HI\n+\t    (match_dup 1)\n+\t    (parallel [(const_int 1)\n+\t\t       (const_int 5)]))))\n+\t (plus:V2DI\n+\t  (zero_extend:V2DI\n+\t   (vec_select:V2HI\n+\t    (match_dup 1)\n+\t    (parallel [(const_int 2)\n+\t\t       (const_int 6)])))\n+\t  (zero_extend:V2DI\n+\t   (vec_select:V2HI\n+\t    (match_dup 1)\n+\t    (parallel [(const_int 3)\n+\t\t       (const_int 7)]))))))]\n+  \"TARGET_XOP\"\n+  \"vphadduwq\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sseiadd1\")])\n+\n+(define_insn \"xop_phaddudq\"\n+  [(set (match_operand:V2DI 0 \"register_operand\" \"=x\")\n+\t(plus:V2DI\n+\t (zero_extend:V2DI\n+\t  (vec_select:V2SI\n+\t   (match_operand:V4SI 1 \"nonimmediate_operand\" \"xm\")\n+\t   (parallel [(const_int 0)\n+\t\t      (const_int 2)])))\n+\t (zero_extend:V2DI\n+\t  (vec_select:V2SI\n+\t   (match_dup 1)\n+\t   (parallel [(const_int 1)\n+\t\t      (const_int 3)])))))]\n+  \"TARGET_XOP\"\n+  \"vphaddudq\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sseiadd1\")])\n+\n+(define_insn \"xop_phsubbw\"\n+  [(set (match_operand:V8HI 0 \"register_operand\" \"=x\")\n+\t(minus:V8HI\n+\t (sign_extend:V8HI\n+\t  (vec_select:V8QI\n+\t   (match_operand:V16QI 1 \"nonimmediate_operand\" \"xm\")\n+\t   (parallel [(const_int 0)\n+\t\t      (const_int 2)\n+\t\t      (const_int 4)\n+\t\t      (const_int 6)\n+\t\t      (const_int 8)\n+\t\t      (const_int 10)\n+\t\t      (const_int 12)\n+\t\t      (const_int 14)])))\n+\t (sign_extend:V8HI\n+\t  (vec_select:V8QI\n+\t   (match_dup 1)\n+\t   (parallel [(const_int 1)\n+\t\t      (const_int 3)\n+\t\t      (const_int 5)\n+\t\t      (const_int 7)\n+\t\t      (const_int 9)\n+\t\t      (const_int 11)\n+\t\t      (const_int 13)\n+\t\t      (const_int 15)])))))]\n+  \"TARGET_XOP\"\n+  \"vphsubbw\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sseiadd1\")])\n+\n+(define_insn \"xop_phsubwd\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=x\")\n+\t(minus:V4SI\n+\t (sign_extend:V4SI\n+\t  (vec_select:V4HI\n+\t   (match_operand:V8HI 1 \"nonimmediate_operand\" \"xm\")\n+\t   (parallel [(const_int 0)\n+\t\t      (const_int 2)\n+\t\t      (const_int 4)\n+\t\t      (const_int 6)])))\n+\t (sign_extend:V4SI\n+\t  (vec_select:V4HI\n+\t   (match_dup 1)\n+\t   (parallel [(const_int 1)\n+\t\t      (const_int 3)\n+\t\t      (const_int 5)\n+\t\t      (const_int 7)])))))]\n+  \"TARGET_XOP\"\n+  \"vphsubwd\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sseiadd1\")])\n+\n+(define_insn \"xop_phsubdq\"\n+  [(set (match_operand:V2DI 0 \"register_operand\" \"=x\")\n+\t(minus:V2DI\n+\t (sign_extend:V2DI\n+\t  (vec_select:V2SI\n+\t   (match_operand:V4SI 1 \"nonimmediate_operand\" \"xm\")\n+\t   (parallel [(const_int 0)\n+\t\t      (const_int 2)])))\n+\t (sign_extend:V2DI\n+\t  (vec_select:V2SI\n+\t   (match_dup 1)\n+\t   (parallel [(const_int 1)\n+\t\t      (const_int 3)])))))]\n+  \"TARGET_XOP\"\n+  \"vphsubdq\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sseiadd1\")])\n+\n+;; XOP permute instructions\n+(define_insn \"xop_pperm\"\n+  [(set (match_operand:V16QI 0 \"register_operand\" \"=x,x,x\")\n+\t(unspec:V16QI\n+\t  [(match_operand:V16QI 1 \"nonimmediate_operand\" \"x,x,xm\")\n+\t   (match_operand:V16QI 2 \"nonimmediate_operand\" \"x,xm,x\")\n+\t   (match_operand:V16QI 3 \"nonimmediate_operand\" \"xm,x,x\")]\n+\t  UNSPEC_XOP_PERMUTE))]\n+  \"TARGET_XOP && ix86_fma4_valid_op_p (operands, insn, 4, true, 1, false)\"\n+  \"vpperm\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"sse4arg\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+;; XOP pack instructions that combine two vectors into a smaller vector\n+(define_insn \"xop_pperm_pack_v2di_v4si\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=x,x,x\")\n+\t(vec_concat:V4SI\n+\t (truncate:V2SI\n+\t  (match_operand:V2DI 1 \"nonimmediate_operand\" \"x,x,xm\"))\n+\t (truncate:V2SI\n+\t  (match_operand:V2DI 2 \"nonimmediate_operand\" \"x,xm,x\"))))\n+   (use (match_operand:V16QI 3 \"nonimmediate_operand\" \"xm,x,x\"))]\n+  \"TARGET_XOP && ix86_fma4_valid_op_p (operands, insn, 4, true, 1, false)\"\n+  \"vpperm\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"sse4arg\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+(define_insn \"xop_pperm_pack_v4si_v8hi\"\n+  [(set (match_operand:V8HI 0 \"register_operand\" \"=x,x,x\")\n+\t(vec_concat:V8HI\n+\t (truncate:V4HI\n+\t  (match_operand:V4SI 1 \"nonimmediate_operand\" \"x,x,xm\"))\n+\t (truncate:V4HI\n+\t  (match_operand:V4SI 2 \"nonimmediate_operand\" \"x,xm,x\"))))\n+   (use (match_operand:V16QI 3 \"nonimmediate_operand\" \"xm,x,x\"))]\n+  \"TARGET_XOP && ix86_fma4_valid_op_p (operands, insn, 4, true, 1, false)\"\n+  \"vpperm\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"sse4arg\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+(define_insn \"xop_pperm_pack_v8hi_v16qi\"\n+  [(set (match_operand:V16QI 0 \"register_operand\" \"=x,x,x\")\n+\t(vec_concat:V16QI\n+\t (truncate:V8QI\n+\t  (match_operand:V8HI 1 \"nonimmediate_operand\" \"x,x,xm\"))\n+\t (truncate:V8QI\n+\t  (match_operand:V8HI 2 \"nonimmediate_operand\" \"x,xm,x\"))))\n+   (use (match_operand:V16QI 3 \"nonimmediate_operand\" \"xm,x,x\"))]\n+  \"TARGET_XOP && ix86_fma4_valid_op_p (operands, insn, 4, true, 1, false)\"\n+  \"vpperm\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n+  [(set_attr \"type\" \"sse4arg\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+;; XOP packed rotate instructions\n+(define_expand \"rotl<mode>3\"\n+  [(set (match_operand:SSEMODE1248 0 \"register_operand\" \"\")\n+\t(rotate:SSEMODE1248\n+\t (match_operand:SSEMODE1248 1 \"nonimmediate_operand\" \"\")\n+\t (match_operand:SI 2 \"general_operand\")))]\n+  \"TARGET_XOP\"\n+{\n+  /* If we were given a scalar, convert it to parallel */\n+  if (! const_0_to_<sserotatemax>_operand (operands[2], SImode))\n+    {\n+      rtvec vs = rtvec_alloc (<ssescalarnum>);\n+      rtx par = gen_rtx_PARALLEL (<MODE>mode, vs);\n+      rtx reg = gen_reg_rtx (<MODE>mode);\n+      rtx op2 = operands[2];\n+      int i;\n+\n+      if (GET_MODE (op2) != <ssescalarmode>mode)\n+        {\n+\t  op2 = gen_reg_rtx (<ssescalarmode>mode);\n+\t  convert_move (op2, operands[2], false);\n+\t}\n+\n+      for (i = 0; i < <ssescalarnum>; i++)\n+\tRTVEC_ELT (vs, i) = op2;\n+\n+      emit_insn (gen_vec_init<mode> (reg, par));\n+      emit_insn (gen_xop_vrotl<mode>3 (operands[0], operands[1], reg));\n+      DONE;\n+    }\n+})\n+\n+(define_expand \"rotr<mode>3\"\n+  [(set (match_operand:SSEMODE1248 0 \"register_operand\" \"\")\n+\t(rotatert:SSEMODE1248\n+\t (match_operand:SSEMODE1248 1 \"nonimmediate_operand\" \"\")\n+\t (match_operand:SI 2 \"general_operand\")))]\n+  \"TARGET_XOP\"\n+{\n+  /* If we were given a scalar, convert it to parallel */\n+  if (! const_0_to_<sserotatemax>_operand (operands[2], SImode))\n+    {\n+      rtvec vs = rtvec_alloc (<ssescalarnum>);\n+      rtx par = gen_rtx_PARALLEL (<MODE>mode, vs);\n+      rtx neg = gen_reg_rtx (<MODE>mode);\n+      rtx reg = gen_reg_rtx (<MODE>mode);\n+      rtx op2 = operands[2];\n+      int i;\n+\n+      if (GET_MODE (op2) != <ssescalarmode>mode)\n+        {\n+\t  op2 = gen_reg_rtx (<ssescalarmode>mode);\n+\t  convert_move (op2, operands[2], false);\n+\t}\n+\n+      for (i = 0; i < <ssescalarnum>; i++)\n+\tRTVEC_ELT (vs, i) = op2;\n+\n+      emit_insn (gen_vec_init<mode> (reg, par));\n+      emit_insn (gen_neg<mode>2 (neg, reg));\n+      emit_insn (gen_xop_vrotl<mode>3 (operands[0], operands[1], neg));\n+      DONE;\n+    }\n+})\n+\n+(define_insn \"xop_rotl<mode>3\"\n+  [(set (match_operand:SSEMODE1248 0 \"register_operand\" \"=x\")\n+\t(rotate:SSEMODE1248\n+\t (match_operand:SSEMODE1248 1 \"nonimmediate_operand\" \"xm\")\n+\t (match_operand:SI 2 \"const_0_to_<sserotatemax>_operand\" \"n\")))]\n+  \"TARGET_XOP\"\n+  \"vprot<ssevecsize>\\t{%2, %1, %0|%0, %1, %2}\"\n+  [(set_attr \"type\" \"sseishft\")\n+   (set_attr \"length_immediate\" \"1\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+(define_insn \"xop_rotr<mode>3\"\n+  [(set (match_operand:SSEMODE1248 0 \"register_operand\" \"=x\")\n+\t(rotatert:SSEMODE1248\n+\t (match_operand:SSEMODE1248 1 \"nonimmediate_operand\" \"xm\")\n+\t (match_operand:SI 2 \"const_0_to_<sserotatemax>_operand\" \"n\")))]\n+  \"TARGET_XOP\"\n+{\n+  operands[3] = GEN_INT ((<ssescalarnum> * 8) - INTVAL (operands[2]));\n+  return \\\"vprot<ssevecsize>\\t{%3, %1, %0|%0, %1, %3}\\\";\n+}\n+  [(set_attr \"type\" \"sseishft\")\n+   (set_attr \"length_immediate\" \"1\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+(define_expand \"vrotr<mode>3\"\n+  [(match_operand:SSEMODE1248 0 \"register_operand\" \"\")\n+   (match_operand:SSEMODE1248 1 \"register_operand\" \"\")\n+   (match_operand:SSEMODE1248 2 \"register_operand\" \"\")]\n+  \"TARGET_XOP\"\n+{\n+  rtx reg = gen_reg_rtx (<MODE>mode);\n+  emit_insn (gen_neg<mode>2 (reg, operands[2]));\n+  emit_insn (gen_xop_vrotl<mode>3 (operands[0], operands[1], reg));\n+  DONE;\n+})\n+\n+(define_expand \"vrotl<mode>3\"\n+  [(match_operand:SSEMODE1248 0 \"register_operand\" \"\")\n+   (match_operand:SSEMODE1248 1 \"register_operand\" \"\")\n+   (match_operand:SSEMODE1248 2 \"register_operand\" \"\")]\n+  \"TARGET_XOP\"\n+{\n+  emit_insn (gen_xop_vrotl<mode>3 (operands[0], operands[1], operands[2]));\n+  DONE;\n+})\n+\n+(define_insn \"xop_vrotl<mode>3\"\n+  [(set (match_operand:SSEMODE1248 0 \"register_operand\" \"=x,x\")\n+\t(if_then_else:SSEMODE1248\n+\t (ge:SSEMODE1248\n+\t  (match_operand:SSEMODE1248 2 \"nonimmediate_operand\" \"xm,x\")\n+\t  (const_int 0))\n+\t (rotate:SSEMODE1248\n+\t  (match_operand:SSEMODE1248 1 \"nonimmediate_operand\" \"x,xm\")\n+\t  (match_dup 2))\n+\t (rotatert:SSEMODE1248\n+\t  (match_dup 1)\n+\t  (neg:SSEMODE1248 (match_dup 2)))))]\n+  \"TARGET_XOP && ix86_fma4_valid_op_p (operands, insn, 3, true, 1, false)\"\n+  \"vprot<ssevecsize>\\t{%2, %1, %0|%0, %1, %2}\"\n+  [(set_attr \"type\" \"sseishft\")\n+   (set_attr \"prefix_data16\" \"0\")\n+   (set_attr \"prefix_extra\" \"2\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+;; XOP packed shift instructions.\n+;; FIXME: add V2DI back in\n+(define_expand \"vlshr<mode>3\"\n+  [(match_operand:SSEMODE124 0 \"register_operand\" \"\")\n+   (match_operand:SSEMODE124 1 \"register_operand\" \"\")\n+   (match_operand:SSEMODE124 2 \"register_operand\" \"\")]\n+  \"TARGET_XOP\"\n+{\n+  rtx neg = gen_reg_rtx (<MODE>mode);\n+  emit_insn (gen_neg<mode>2 (neg, operands[2]));\n+  emit_insn (gen_xop_lshl<mode>3 (operands[0], operands[1], neg));\n+  DONE;\n+})\n+\n+(define_expand \"vashr<mode>3\"\n+  [(match_operand:SSEMODE124 0 \"register_operand\" \"\")\n+   (match_operand:SSEMODE124 1 \"register_operand\" \"\")\n+   (match_operand:SSEMODE124 2 \"register_operand\" \"\")]\n+  \"TARGET_XOP\"\n+{\n+  rtx neg = gen_reg_rtx (<MODE>mode);\n+  emit_insn (gen_neg<mode>2 (neg, operands[2]));\n+  emit_insn (gen_xop_ashl<mode>3 (operands[0], operands[1], neg));\n+  DONE;\n+})\n+\n+(define_expand \"vashl<mode>3\"\n+  [(match_operand:SSEMODE124 0 \"register_operand\" \"\")\n+   (match_operand:SSEMODE124 1 \"register_operand\" \"\")\n+   (match_operand:SSEMODE124 2 \"register_operand\" \"\")]\n+  \"TARGET_XOP\"\n+{\n+  emit_insn (gen_xop_ashl<mode>3 (operands[0], operands[1], operands[2]));\n+  DONE;\n+})\n+\n+(define_insn \"xop_ashl<mode>3\"\n+  [(set (match_operand:SSEMODE1248 0 \"register_operand\" \"=x,x\")\n+\t(if_then_else:SSEMODE1248\n+\t (ge:SSEMODE1248\n+\t  (match_operand:SSEMODE1248 2 \"nonimmediate_operand\" \"xm,x\")\n+\t  (const_int 0))\n+\t (ashift:SSEMODE1248\n+\t  (match_operand:SSEMODE1248 1 \"nonimmediate_operand\" \"x,xm\")\n+\t  (match_dup 2))\n+\t (ashiftrt:SSEMODE1248\n+\t  (match_dup 1)\n+\t  (neg:SSEMODE1248 (match_dup 2)))))]\n+  \"TARGET_XOP && ix86_fma4_valid_op_p (operands, insn, 3, true, 1, false)\"\n+  \"vpsha<ssevecsize>\\t{%2, %1, %0|%0, %1, %2}\"\n+  [(set_attr \"type\" \"sseishft\")\n+   (set_attr \"prefix_data16\" \"0\")\n+   (set_attr \"prefix_extra\" \"2\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+(define_insn \"xop_lshl<mode>3\"\n+  [(set (match_operand:SSEMODE1248 0 \"register_operand\" \"=x,x\")\n+\t(if_then_else:SSEMODE1248\n+\t (ge:SSEMODE1248\n+\t  (match_operand:SSEMODE1248 2 \"nonimmediate_operand\" \"xm,x\")\n+\t  (const_int 0))\n+\t (ashift:SSEMODE1248\n+\t  (match_operand:SSEMODE1248 1 \"nonimmediate_operand\" \"x,xm\")\n+\t  (match_dup 2))\n+\t (lshiftrt:SSEMODE1248\n+\t  (match_dup 1)\n+\t  (neg:SSEMODE1248 (match_dup 2)))))]\n+  \"TARGET_XOP && ix86_fma4_valid_op_p (operands, insn, 3, true, 1, false)\"\n+  \"vpshl<ssevecsize>\\t{%2, %1, %0|%0, %1, %2}\"\n+  [(set_attr \"type\" \"sseishft\")\n+   (set_attr \"prefix_data16\" \"0\")\n+   (set_attr \"prefix_extra\" \"2\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+;; SSE2 doesn't have some shift varients, so define versions for XOP\n+(define_expand \"ashlv16qi3\"\n+  [(match_operand:V16QI 0 \"register_operand\" \"\")\n+   (match_operand:V16QI 1 \"register_operand\" \"\")\n+   (match_operand:SI 2 \"nonmemory_operand\" \"\")]\n+  \"TARGET_XOP\"\n+{\n+  rtvec vs = rtvec_alloc (16);\n+  rtx par = gen_rtx_PARALLEL (V16QImode, vs);\n+  rtx reg = gen_reg_rtx (V16QImode);\n+  int i;\n+  for (i = 0; i < 16; i++)\n+    RTVEC_ELT (vs, i) = operands[2];\n+\n+  emit_insn (gen_vec_initv16qi (reg, par));\n+  emit_insn (gen_xop_ashlv16qi3 (operands[0], operands[1], reg));\n+  DONE;\n+})\n+\n+(define_expand \"lshlv16qi3\"\n+  [(match_operand:V16QI 0 \"register_operand\" \"\")\n+   (match_operand:V16QI 1 \"register_operand\" \"\")\n+   (match_operand:SI 2 \"nonmemory_operand\" \"\")]\n+  \"TARGET_XOP\"\n+{\n+  rtvec vs = rtvec_alloc (16);\n+  rtx par = gen_rtx_PARALLEL (V16QImode, vs);\n+  rtx reg = gen_reg_rtx (V16QImode);\n+  int i;\n+  for (i = 0; i < 16; i++)\n+    RTVEC_ELT (vs, i) = operands[2];\n+\n+  emit_insn (gen_vec_initv16qi (reg, par));\n+  emit_insn (gen_xop_lshlv16qi3 (operands[0], operands[1], reg));\n+  DONE;\n+})\n+\n+(define_expand \"ashrv16qi3\"\n+  [(match_operand:V16QI 0 \"register_operand\" \"\")\n+   (match_operand:V16QI 1 \"register_operand\" \"\")\n+   (match_operand:SI 2 \"nonmemory_operand\" \"\")]\n+  \"TARGET_XOP\"\n+{\n+  rtvec vs = rtvec_alloc (16);\n+  rtx par = gen_rtx_PARALLEL (V16QImode, vs);\n+  rtx reg = gen_reg_rtx (V16QImode);\n+  int i;\n+  rtx ele = ((CONST_INT_P (operands[2]))\n+\t     ? GEN_INT (- INTVAL (operands[2]))\n+\t     : operands[2]);\n+\n+  for (i = 0; i < 16; i++)\n+    RTVEC_ELT (vs, i) = ele;\n+\n+  emit_insn (gen_vec_initv16qi (reg, par));\n+\n+  if (!CONST_INT_P (operands[2]))\n+    {\n+      rtx neg = gen_reg_rtx (V16QImode);\n+      emit_insn (gen_negv16qi2 (neg, reg));\n+      emit_insn (gen_xop_ashlv16qi3 (operands[0], operands[1], neg));\n+    }\n+  else\n+    emit_insn (gen_xop_ashlv16qi3 (operands[0], operands[1], reg));\n+\n+  DONE;\n+})\n+\n+(define_expand \"ashrv2di3\"\n+  [(match_operand:V2DI 0 \"register_operand\" \"\")\n+   (match_operand:V2DI 1 \"register_operand\" \"\")\n+   (match_operand:DI 2 \"nonmemory_operand\" \"\")]\n+  \"TARGET_XOP\"\n+{\n+  rtvec vs = rtvec_alloc (2);\n+  rtx par = gen_rtx_PARALLEL (V2DImode, vs);\n+  rtx reg = gen_reg_rtx (V2DImode);\n+  rtx ele;\n+\n+  if (CONST_INT_P (operands[2]))\n+    ele = GEN_INT (- INTVAL (operands[2]));\n+  else if (GET_MODE (operands[2]) != DImode)\n+    {\n+      rtx move = gen_reg_rtx (DImode);\n+      ele = gen_reg_rtx (DImode);\n+      convert_move (move, operands[2], false);\n+      emit_insn (gen_negdi2 (ele, move));\n+    }\n+  else\n+    {\n+      ele = gen_reg_rtx (DImode);\n+      emit_insn (gen_negdi2 (ele, operands[2]));\n+    }\n+\n+  RTVEC_ELT (vs, 0) = ele;\n+  RTVEC_ELT (vs, 1) = ele;\n+  emit_insn (gen_vec_initv2di (reg, par));\n+  emit_insn (gen_xop_ashlv2di3 (operands[0], operands[1], reg));\n+  DONE;\n+})\n+\n+;; XOP FRCZ support\n+;; parallel insns\n+(define_insn \"xop_frcz<mode>2\"\n+  [(set (match_operand:SSEMODEF2P 0 \"register_operand\" \"=x\")\n+\t(unspec:SSEMODEF2P\n+\t [(match_operand:SSEMODEF2P 1 \"nonimmediate_operand\" \"xm\")]\n+\t UNSPEC_FRCZ))]\n+  \"TARGET_XOP\"\n+  \"vfrcz<ssemodesuffixf4>\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"ssecvt1\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; scalar insns\n+(define_insn \"xop_vmfrcz<mode>2\"\n+  [(set (match_operand:SSEMODEF2P 0 \"register_operand\" \"=x\")\n+\t(vec_merge:SSEMODEF2P\n+\t  (unspec:SSEMODEF2P\n+\t   [(match_operand:SSEMODEF2P 2 \"nonimmediate_operand\" \"xm\")]\n+\t   UNSPEC_FRCZ)\n+\t  (match_operand:SSEMODEF2P 1 \"register_operand\" \"0\")\n+\t  (const_int 1)))]\n+  \"TARGET_XOP\"\n+  \"vfrcz<ssemodesuffixf2s>\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"ssecvt1\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"xop_frcz<mode>2256\"\n+  [(set (match_operand:FMA4MODEF4 0 \"register_operand\" \"=x\")\n+\t(unspec:FMA4MODEF4\n+\t [(match_operand:FMA4MODEF4 1 \"nonimmediate_operand\" \"xm\")]\n+\t UNSPEC_FRCZ))]\n+  \"TARGET_XOP\"\n+  \"vfrcz<fma4modesuffixf4>\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"ssecvt1\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"xop_maskcmp<mode>3\"\n+  [(set (match_operand:SSEMODE1248 0 \"register_operand\" \"=x\")\n+\t(match_operator:SSEMODE1248 1 \"ix86_comparison_int_operator\"\n+\t [(match_operand:SSEMODE1248 2 \"register_operand\" \"x\")\n+\t  (match_operand:SSEMODE1248 3 \"nonimmediate_operand\" \"xm\")]))]\n+  \"TARGET_XOP\"\n+  \"vpcom%Y1<ssevecsize>\\t{%3, %2, %0|%0, %2, %3}\"\n+  [(set_attr \"type\" \"sse4arg\")\n+   (set_attr \"prefix_data16\" \"0\")\n+   (set_attr \"prefix_rep\" \"0\")\n+   (set_attr \"prefix_extra\" \"2\")\n+   (set_attr \"length_immediate\" \"1\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+(define_insn \"xop_maskcmp_uns<mode>3\"\n+  [(set (match_operand:SSEMODE1248 0 \"register_operand\" \"=x\")\n+\t(match_operator:SSEMODE1248 1 \"ix86_comparison_uns_operator\"\n+\t [(match_operand:SSEMODE1248 2 \"register_operand\" \"x\")\n+\t  (match_operand:SSEMODE1248 3 \"nonimmediate_operand\" \"xm\")]))]\n+  \"TARGET_XOP\"\n+  \"vpcom%Y1u<ssevecsize>\\t{%3, %2, %0|%0, %2, %3}\"\n+  [(set_attr \"type\" \"ssecmp\")\n+   (set_attr \"prefix_data16\" \"0\")\n+   (set_attr \"prefix_rep\" \"0\")\n+   (set_attr \"prefix_extra\" \"2\")\n+   (set_attr \"length_immediate\" \"1\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+;; Version of pcom*u* that is called from the intrinsics that allows pcomequ*\n+;; and pcomneu* not to be converted to the signed ones in case somebody needs\n+;; the exact instruction generated for the intrinsic.\n+(define_insn \"xop_maskcmp_uns2<mode>3\"\n+  [(set (match_operand:SSEMODE1248 0 \"register_operand\" \"=x\")\n+\t(unspec:SSEMODE1248\n+\t [(match_operator:SSEMODE1248 1 \"ix86_comparison_uns_operator\"\n+\t  [(match_operand:SSEMODE1248 2 \"register_operand\" \"x\")\n+\t   (match_operand:SSEMODE1248 3 \"nonimmediate_operand\" \"xm\")])]\n+\t UNSPEC_XOP_UNSIGNED_CMP))]\n+  \"TARGET_XOP\"\n+  \"vpcom%Y1u<ssevecsize>\\t{%3, %2, %0|%0, %2, %3}\"\n+  [(set_attr \"type\" \"ssecmp\")\n+   (set_attr \"prefix_data16\" \"0\")\n+   (set_attr \"prefix_extra\" \"2\")\n+   (set_attr \"length_immediate\" \"1\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+;; Pcomtrue and pcomfalse support.  These are useless instructions, but are\n+;; being added here to be complete.\n+(define_insn \"xop_pcom_tf<mode>3\"\n+  [(set (match_operand:SSEMODE1248 0 \"register_operand\" \"=x\")\n+\t(unspec:SSEMODE1248\n+\t  [(match_operand:SSEMODE1248 1 \"register_operand\" \"x\")\n+\t   (match_operand:SSEMODE1248 2 \"nonimmediate_operand\" \"xm\")\n+\t   (match_operand:SI 3 \"const_int_operand\" \"n\")]\n+\t  UNSPEC_XOP_TRUEFALSE))]\n+  \"TARGET_XOP\"\n+{\n+  return ((INTVAL (operands[3]) != 0)\n+\t  ? \"vpcomtrue<ssevecsize>\\t{%2, %1, %0|%0, %1, %2}\"\n+\t  : \"vpcomfalse<ssevecsize>\\t{%2, %1, %0|%0, %1, %2}\");\n+}\n+  [(set_attr \"type\" \"ssecmp\")\n+   (set_attr \"prefix_data16\" \"0\")\n+   (set_attr \"prefix_extra\" \"2\")\n+   (set_attr \"length_immediate\" \"1\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n (define_insn \"*avx_aesenc\"\n   [(set (match_operand:V2DI 0 \"register_operand\" \"=x\")\n \t(unspec:V2DI [(match_operand:V2DI 1 \"register_operand\" \"x\")"}, {"sha": "522415fb30a77eb28f9b195304b8f5dc6c108e7a", "filename": "gcc/config/i386/x86intrin.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Fconfig%2Fi386%2Fx86intrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Fconfig%2Fi386%2Fx86intrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fx86intrin.h?ref=43a8b705906034ecb3edfb54558a34bd362a7213", "patch": "@@ -58,6 +58,10 @@\n #include <fma4intrin.h>\n #endif\n \n+#ifdef __XOP__\n+#include <xopintrin.h>\n+#endif\n+\n #if defined (__AES__) || defined (__PCLMUL__)\n #include <wmmintrin.h>\n #endif"}, {"sha": "803417a6a4549181cb24a8bac5859d6c07ad7d67", "filename": "gcc/config/i386/xopintrin.h", "status": "added", "additions": 771, "deletions": 0, "changes": 771, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Fconfig%2Fi386%2Fxopintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Fconfig%2Fi386%2Fxopintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fxopintrin.h?ref=43a8b705906034ecb3edfb54558a34bd362a7213", "patch": "@@ -0,0 +1,771 @@\n+/* Copyright (C) 2007, 2008, 2009 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef _X86INTRIN_H_INCLUDED\n+# error \"Never use <xopintrin.h> directly; include <x86intrin.h> instead.\"\n+#endif\n+\n+#ifndef _XOPMMINTRIN_H_INCLUDED\n+#define _XOPMMINTRIN_H_INCLUDED\n+\n+#ifndef __XOP__\n+# error \"XOP instruction set not enabled\"\n+#else\n+\n+#include <fma4intrin.h>\n+\n+/* Integer multiply/add intructions. */\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_maccs_epi16(__m128i __A, __m128i __B, __m128i __C)\n+{\n+  return (__m128i) __builtin_ia32_vpmacssww ((__v8hi)__A,(__v8hi)__B, (__v8hi)__C);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_macc_epi16(__m128i __A, __m128i __B, __m128i __C)\n+{\n+  return (__m128i) __builtin_ia32_vpmacsww ((__v8hi)__A, (__v8hi)__B, (__v8hi)__C);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_maccsd_epi16(__m128i __A, __m128i __B, __m128i __C)\n+{\n+  return  (__m128i) __builtin_ia32_vpmacsswd ((__v8hi)__A, (__v8hi)__B, (__v4si)__C);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_maccd_epi16(__m128i __A, __m128i __B, __m128i __C)\n+{\n+  return  (__m128i) __builtin_ia32_vpmacswd ((__v8hi)__A, (__v8hi)__B, (__v4si)__C);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_maccs_epi32(__m128i __A, __m128i __B, __m128i __C)\n+{\n+  return  (__m128i) __builtin_ia32_vpmacssdd ((__v4si)__A, (__v4si)__B, (__v4si)__C);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_macc_epi32(__m128i __A, __m128i __B, __m128i __C)\n+{\n+  return  (__m128i) __builtin_ia32_vpmacsdd ((__v4si)__A, (__v4si)__B, (__v4si)__C);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_maccslo_epi32(__m128i __A, __m128i __B, __m128i __C)\n+{\n+  return  (__m128i) __builtin_ia32_vpmacssdql ((__v4si)__A, (__v4si)__B, (__v2di)__C);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_macclo_epi32(__m128i __A, __m128i __B, __m128i __C)\n+{\n+  return  (__m128i) __builtin_ia32_vpmacsdql ((__v4si)__A, (__v4si)__B, (__v2di)__C);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_maccshi_epi32(__m128i __A, __m128i __B, __m128i __C)\n+{\n+  return  (__m128i) __builtin_ia32_vpmacssdqh ((__v4si)__A, (__v4si)__B, (__v2di)__C);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_macchi_epi32(__m128i __A, __m128i __B, __m128i __C)\n+{\n+  return  (__m128i) __builtin_ia32_vpmacsdqh ((__v4si)__A, (__v4si)__B, (__v2di)__C);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_maddsd_epi16(__m128i __A, __m128i __B, __m128i __C)\n+{\n+  return  (__m128i) __builtin_ia32_vpmadcsswd ((__v8hi)__A,(__v8hi)__B,(__v4si)__C);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_maddd_epi16(__m128i __A, __m128i __B, __m128i __C)\n+{\n+  return  (__m128i) __builtin_ia32_vpmadcswd ((__v8hi)__A,(__v8hi)__B,(__v4si)__C);\n+}\n+\n+/* Packed Integer Horizontal Add and Subtract */\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_haddw_epi8(__m128i __A)\n+{\n+  return  (__m128i) __builtin_ia32_vphaddbw ((__v16qi)__A);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_haddd_epi8(__m128i __A)\n+{\n+  return  (__m128i) __builtin_ia32_vphaddbd ((__v16qi)__A);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_haddq_epi8(__m128i __A)\n+{\n+  return  (__m128i) __builtin_ia32_vphaddbq ((__v16qi)__A);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_haddd_epi16(__m128i __A)\n+{\n+  return  (__m128i) __builtin_ia32_vphaddwd ((__v8hi)__A);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_haddq_epi16(__m128i __A)\n+{\n+  return  (__m128i) __builtin_ia32_vphaddwq ((__v8hi)__A);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_haddq_epi32(__m128i __A)\n+{\n+  return  (__m128i) __builtin_ia32_vphadddq ((__v4si)__A);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_haddw_epu8(__m128i __A)\n+{\n+  return  (__m128i) __builtin_ia32_vphaddubw ((__v16qi)__A);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_haddd_epu8(__m128i __A)\n+{\n+  return  (__m128i) __builtin_ia32_vphaddubd ((__v16qi)__A);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_haddq_epu8(__m128i __A)\n+{\n+  return  (__m128i) __builtin_ia32_vphaddubq ((__v16qi)__A);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_haddd_epu16(__m128i __A)\n+{\n+  return  (__m128i) __builtin_ia32_vphadduwd ((__v8hi)__A);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_haddq_epu16(__m128i __A)\n+{\n+  return  (__m128i) __builtin_ia32_vphadduwq ((__v8hi)__A);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_haddq_epu32(__m128i __A)\n+{\n+  return  (__m128i) __builtin_ia32_vphaddudq ((__v4si)__A);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_hsubw_epi8(__m128i __A)\n+{\n+  return  (__m128i) __builtin_ia32_vphsubbw ((__v16qi)__A);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_hsubd_epi16(__m128i __A)\n+{\n+  return  (__m128i) __builtin_ia32_vphsubwd ((__v8hi)__A);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_hsubq_epi32(__m128i __A)\n+{\n+  return  (__m128i) __builtin_ia32_vphsubdq ((__v4si)__A);\n+}\n+\n+/* Vector conditional move and permute */\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmov_si128(__m128i __A, __m128i __B, __m128i __C)\n+{\n+  return  (__m128i) __builtin_ia32_vpcmov (__A, __B, __C);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_perm_epi8(__m128i __A, __m128i __B, __m128i __C)\n+{\n+  return  (__m128i) __builtin_ia32_vpperm ((__v16qi)__A, (__v16qi)__B, (__v16qi)__C);\n+}\n+\n+/* Packed Integer Rotates and Shifts\n+   Rotates - Non-Immediate form */\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_rot_epi8(__m128i __A,  __m128i __B)\n+{\n+  return  (__m128i) __builtin_ia32_vprotb ((__v16qi)__A, (__v16qi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_rot_epi16(__m128i __A,  __m128i __B)\n+{\n+  return  (__m128i) __builtin_ia32_vprotw ((__v8hi)__A, (__v8hi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_rot_epi32(__m128i __A,  __m128i __B)\n+{\n+  return  (__m128i) __builtin_ia32_vprotd ((__v4si)__A, (__v4si)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_rot_epi64(__m128i __A,  __m128i __B)\n+{\n+  return (__m128i)  __builtin_ia32_vprotq ((__v2di)__A, (__v2di)__B);\n+}\n+\n+/* Rotates - Immediate form */\n+\n+#ifdef __OPTIMIZE__\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_roti_epi8(__m128i __A, const int __B)\n+{\n+  return  (__m128i) __builtin_ia32_vprotbi ((__v16qi)__A, __B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_roti_epi16(__m128i __A, const int __B)\n+{\n+  return  (__m128i) __builtin_ia32_vprotwi ((__v8hi)__A, __B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_roti_epi32(__m128i __A, const int __B)\n+{\n+  return  (__m128i) __builtin_ia32_vprotdi ((__v4si)__A, __B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_roti_epi64(__m128i __A, const int __B)\n+{\n+  return  (__m128i) __builtin_ia32_vprotqi ((__v2di)__A, __B);\n+}\n+#else\n+#define _mm_roti_epi8(A, N) \\\n+  ((__m128i) __builtin_ia32_vprotbi ((__v16qi)(__m128i)(A), (int)(N)))\n+#define _mm_roti_epi16(A, N) \\\n+  ((__m128i) __builtin_ia32_vprotwi ((__v8hi)(__m128i)(A), (int)(N)))\n+#define _mm_roti_epi32(A, N) \\\n+  ((__m128i) __builtin_ia32_vprotdi ((__v4si)(__m128i)(A), (int)(N)))\n+#define _mm_roti_epi64(A, N) \\\n+  ((__m128i) __builtin_ia32_vprotqi ((__v2di)(__m128i)(A), (int)(N)))\n+#endif\n+\n+/* Shifts */\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_shl_epi8(__m128i __A,  __m128i __B)\n+{\n+  return  (__m128i) __builtin_ia32_vpshlb ((__v16qi)__A, (__v16qi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_shl_epi16(__m128i __A,  __m128i __B)\n+{\n+  return  (__m128i) __builtin_ia32_vpshlw ((__v8hi)__A, (__v8hi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_shl_epi32(__m128i __A,  __m128i __B)\n+{\n+  return  (__m128i) __builtin_ia32_vpshld ((__v4si)__A, (__v4si)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_shl_epi64(__m128i __A,  __m128i __B)\n+{\n+  return  (__m128i) __builtin_ia32_vpshlq ((__v2di)__A, (__v2di)__B);\n+}\n+\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_sha_epi8(__m128i __A,  __m128i __B)\n+{\n+  return  (__m128i) __builtin_ia32_vpshab ((__v16qi)__A, (__v16qi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_sha_epi16(__m128i __A,  __m128i __B)\n+{\n+  return  (__m128i) __builtin_ia32_vpshaw ((__v8hi)__A, (__v8hi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_sha_epi32(__m128i __A,  __m128i __B)\n+{\n+  return  (__m128i) __builtin_ia32_vpshad ((__v4si)__A, (__v4si)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_sha_epi64(__m128i __A,  __m128i __B)\n+{\n+  return  (__m128i) __builtin_ia32_vpshaq ((__v2di)__A, (__v2di)__B);\n+}\n+\n+/* Compare and Predicate Generation\n+   pcom (integer, unsinged bytes) */\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comlt_epu8(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomltub ((__v16qi)__A, (__v16qi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comle_epu8(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomleub ((__v16qi)__A, (__v16qi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comgt_epu8(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomgtub ((__v16qi)__A, (__v16qi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comge_epu8(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomgeub ((__v16qi)__A, (__v16qi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comeq_epu8(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomequb ((__v16qi)__A, (__v16qi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comneq_epu8(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomnequb ((__v16qi)__A, (__v16qi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comfalse_epu8(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomfalseub ((__v16qi)__A, (__v16qi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comtrue_epu8(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomtrueub ((__v16qi)__A, (__v16qi)__B);\n+}\n+\n+/*pcom (integer, unsinged words) */\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comlt_epu16(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomltuw ((__v8hi)__A, (__v8hi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comle_epu16(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomleuw ((__v8hi)__A, (__v8hi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comgt_epu16(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomgtuw ((__v8hi)__A, (__v8hi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comge_epu16(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomgeuw ((__v8hi)__A, (__v8hi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comeq_epu16(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomequw ((__v8hi)__A, (__v8hi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comneq_epu16(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomnequw ((__v8hi)__A, (__v8hi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comfalse_epu16(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomfalseuw ((__v8hi)__A, (__v8hi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comtrue_epu16(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomtrueuw ((__v8hi)__A, (__v8hi)__B);\n+}\n+\n+/*pcom (integer, unsinged double words) */\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comlt_epu32(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomltud ((__v4si)__A, (__v4si)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comle_epu32(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomleud ((__v4si)__A, (__v4si)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comgt_epu32(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomgtud ((__v4si)__A, (__v4si)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comge_epu32(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomgeud ((__v4si)__A, (__v4si)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comeq_epu32(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomequd ((__v4si)__A, (__v4si)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comneq_epu32(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomnequd ((__v4si)__A, (__v4si)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comfalse_epu32(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomfalseud ((__v4si)__A, (__v4si)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comtrue_epu32(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomtrueud ((__v4si)__A, (__v4si)__B);\n+}\n+\n+/*pcom (integer, unsinged quad words) */\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comlt_epu64(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomltuq ((__v2di)__A, (__v2di)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comle_epu64(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomleuq ((__v2di)__A, (__v2di)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comgt_epu64(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomgtuq ((__v2di)__A, (__v2di)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comge_epu64(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomgeuq ((__v2di)__A, (__v2di)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comeq_epu64(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomequq ((__v2di)__A, (__v2di)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comneq_epu64(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomnequq ((__v2di)__A, (__v2di)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comfalse_epu64(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomfalseuq ((__v2di)__A, (__v2di)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comtrue_epu64(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomtrueuq ((__v2di)__A, (__v2di)__B);\n+}\n+\n+/*pcom (integer, signed bytes) */\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comlt_epi8(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomltb ((__v16qi)__A, (__v16qi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comle_epi8(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomleb ((__v16qi)__A, (__v16qi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comgt_epi8(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomgtb ((__v16qi)__A, (__v16qi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comge_epi8(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomgeb ((__v16qi)__A, (__v16qi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comeq_epi8(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomeqb ((__v16qi)__A, (__v16qi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comneq_epi8(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomneqb ((__v16qi)__A, (__v16qi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comfalse_epi8(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomfalseb ((__v16qi)__A, (__v16qi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comtrue_epi8(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomtrueb ((__v16qi)__A, (__v16qi)__B);\n+}\n+\n+/*pcom (integer, signed words) */\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comlt_epi16(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomltw ((__v8hi)__A, (__v8hi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comle_epi16(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomlew ((__v8hi)__A, (__v8hi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comgt_epi16(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomgtw ((__v8hi)__A, (__v8hi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comge_epi16(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomgew ((__v8hi)__A, (__v8hi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comeq_epi16(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomeqw ((__v8hi)__A, (__v8hi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comneq_epi16(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomneqw ((__v8hi)__A, (__v8hi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comfalse_epi16(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomfalsew ((__v8hi)__A, (__v8hi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comtrue_epi16(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomtruew ((__v8hi)__A, (__v8hi)__B);\n+}\n+\n+/*pcom (integer, signed double words) */\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comlt_epi32(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomltd ((__v4si)__A, (__v4si)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comle_epi32(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomled ((__v4si)__A, (__v4si)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comgt_epi32(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomgtd ((__v4si)__A, (__v4si)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comge_epi32(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomged ((__v4si)__A, (__v4si)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comeq_epi32(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomeqd ((__v4si)__A, (__v4si)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comneq_epi32(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomneqd ((__v4si)__A, (__v4si)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comfalse_epi32(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomfalsed ((__v4si)__A, (__v4si)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comtrue_epi32(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomtrued ((__v4si)__A, (__v4si)__B);\n+}\n+\n+/*pcom (integer, signed quad words) */\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comlt_epi64(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomltq ((__v2di)__A, (__v2di)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comle_epi64(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomleq ((__v2di)__A, (__v2di)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comgt_epi64(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomgtq ((__v2di)__A, (__v2di)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comge_epi64(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomgeq ((__v2di)__A, (__v2di)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comeq_epi64(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomeqq ((__v2di)__A, (__v2di)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comneq_epi64(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomneqq ((__v2di)__A, (__v2di)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comfalse_epi64(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomfalseq ((__v2di)__A, (__v2di)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comtrue_epi64(__m128i __A, __m128i __B)\n+{\n+  return (__m128i) __builtin_ia32_vpcomtrueq ((__v2di)__A, (__v2di)__B);\n+}\n+\n+/* FRCZ */\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_frcz_ps (__m128 __A)\n+{\n+  return (__m128) __builtin_ia32_vfrczps ((__v4sf)__A);\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_frcz_pd (__m128d __A)\n+{\n+  return (__m128d) __builtin_ia32_vfrczpd ((__v2df)__A);\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_frcz_ss (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_vfrczss ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_frcz_sd (__m128d __A, __m128d __B)\n+{\n+  return (__m128d) __builtin_ia32_vfrczsd ((__v2df)__A, (__v2df)__B);\n+}\n+\n+extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm256_frcz_ps (__m256 __A)\n+{\n+  return (__m256) __builtin_ia32_vfrczps256 ((__v8sf)__A);\n+}\n+\n+extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm256_frcz_pd (__m256d __A)\n+{\n+  return (__m256d) __builtin_ia32_vfrczpd256 ((__v4df)__A);\n+}\n+\n+#endif /* __XOP__ */\n+\n+#endif /* _XOPMMINTRIN_H_INCLUDED */"}, {"sha": "19ab465f980e757d6abf2a353e18ba73d6b60be6", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=43a8b705906034ecb3edfb54558a34bd362a7213", "patch": "@@ -3207,6 +3207,11 @@ Enable/disable the generation of the SSE4A instructions.\n @cindex @code{target(\"fma4\")} attribute\n Enable/disable the generation of the FMA4 instructions.\n \n+@item xop\n+@itemx no-xop\n+@cindex @code{target(\"xop\")} attribute\n+Enable/disable the generation of the XOP instructions.\n+\n @item ssse3\n @itemx no-ssse3\n @cindex @code{target(\"ssse3\")} attribute\n@@ -8928,6 +8933,134 @@ v2di __builtin_ia32_insertq (v2di, v2di)\n v2di __builtin_ia32_insertqi (v2di, v2di, const unsigned int, const unsigned int)\n @end smallexample\n \n+The following built-in functions are available when @option{-mxop} is used.\n+@smallexample\n+v2df __builtin_ia32_vfrczpd (v2df)\n+v4sf __builtin_ia32_vfrczps (v4sf)\n+v2df __builtin_ia32_vfrczsd (v2df, v2df)\n+v4sf __builtin_ia32_vfrczss (v4sf, v4sf)\n+v4df __builtin_ia32_vfrczpd256 (v4df)\n+v8sf __builtin_ia32_vfrczps256 (v8sf)\n+v2di __builtin_ia32_vpcmov (v2di, v2di, v2di)\n+v2di __builtin_ia32_vpcmov_v2di (v2di, v2di, v2di)\n+v4si __builtin_ia32_vpcmov_v4si (v4si, v4si, v4si)\n+v8hi __builtin_ia32_vpcmov_v8hi (v8hi, v8hi, v8hi)\n+v16qi __builtin_ia32_vpcmov_v16qi (v16qi, v16qi, v16qi)\n+v2df __builtin_ia32_vpcmov_v2df (v2df, v2df, v2df)\n+v4sf __builtin_ia32_vpcmov_v4sf (v4sf, v4sf, v4sf)\n+v4di __builtin_ia32_vpcmov_v4di256 (v4di, v4di, v4di)\n+v8si __builtin_ia32_vpcmov_v8si256 (v8si, v8si, v8si)\n+v16hi __builtin_ia32_vpcmov_v16hi256 (v16hi, v16hi, v16hi)\n+v32qi __builtin_ia32_vpcmov_v32qi256 (v32qi, v32qi, v32qi)\n+v4df __builtin_ia32_vpcmov_v4df256 (v4df, v4df, v4df)\n+v8sf __builtin_ia32_vpcmov_v8sf256 (v8sf, v8sf, v8sf)\n+v16qi __builtin_ia32_vpcomeqb (v16qi, v16qi)\n+v8hi __builtin_ia32_vpcomeqw (v8hi, v8hi)\n+v4si __builtin_ia32_vpcomeqd (v4si, v4si)\n+v2di __builtin_ia32_vpcomeqq (v2di, v2di)\n+v16qi __builtin_ia32_vpcomequb (v16qi, v16qi)\n+v4si __builtin_ia32_vpcomequd (v4si, v4si)\n+v2di __builtin_ia32_vpcomequq (v2di, v2di)\n+v8hi __builtin_ia32_vpcomequw (v8hi, v8hi)\n+v8hi __builtin_ia32_vpcomeqw (v8hi, v8hi)\n+v16qi __builtin_ia32_vpcomfalseb (v16qi, v16qi)\n+v4si __builtin_ia32_vpcomfalsed (v4si, v4si)\n+v2di __builtin_ia32_vpcomfalseq (v2di, v2di)\n+v16qi __builtin_ia32_vpcomfalseub (v16qi, v16qi)\n+v4si __builtin_ia32_vpcomfalseud (v4si, v4si)\n+v2di __builtin_ia32_vpcomfalseuq (v2di, v2di)\n+v8hi __builtin_ia32_vpcomfalseuw (v8hi, v8hi)\n+v8hi __builtin_ia32_vpcomfalsew (v8hi, v8hi)\n+v16qi __builtin_ia32_vpcomgeb (v16qi, v16qi)\n+v4si __builtin_ia32_vpcomged (v4si, v4si)\n+v2di __builtin_ia32_vpcomgeq (v2di, v2di)\n+v16qi __builtin_ia32_vpcomgeub (v16qi, v16qi)\n+v4si __builtin_ia32_vpcomgeud (v4si, v4si)\n+v2di __builtin_ia32_vpcomgeuq (v2di, v2di)\n+v8hi __builtin_ia32_vpcomgeuw (v8hi, v8hi)\n+v8hi __builtin_ia32_vpcomgew (v8hi, v8hi)\n+v16qi __builtin_ia32_vpcomgtb (v16qi, v16qi)\n+v4si __builtin_ia32_vpcomgtd (v4si, v4si)\n+v2di __builtin_ia32_vpcomgtq (v2di, v2di)\n+v16qi __builtin_ia32_vpcomgtub (v16qi, v16qi)\n+v4si __builtin_ia32_vpcomgtud (v4si, v4si)\n+v2di __builtin_ia32_vpcomgtuq (v2di, v2di)\n+v8hi __builtin_ia32_vpcomgtuw (v8hi, v8hi)\n+v8hi __builtin_ia32_vpcomgtw (v8hi, v8hi)\n+v16qi __builtin_ia32_vpcomleb (v16qi, v16qi)\n+v4si __builtin_ia32_vpcomled (v4si, v4si)\n+v2di __builtin_ia32_vpcomleq (v2di, v2di)\n+v16qi __builtin_ia32_vpcomleub (v16qi, v16qi)\n+v4si __builtin_ia32_vpcomleud (v4si, v4si)\n+v2di __builtin_ia32_vpcomleuq (v2di, v2di)\n+v8hi __builtin_ia32_vpcomleuw (v8hi, v8hi)\n+v8hi __builtin_ia32_vpcomlew (v8hi, v8hi)\n+v16qi __builtin_ia32_vpcomltb (v16qi, v16qi)\n+v4si __builtin_ia32_vpcomltd (v4si, v4si)\n+v2di __builtin_ia32_vpcomltq (v2di, v2di)\n+v16qi __builtin_ia32_vpcomltub (v16qi, v16qi)\n+v4si __builtin_ia32_vpcomltud (v4si, v4si)\n+v2di __builtin_ia32_vpcomltuq (v2di, v2di)\n+v8hi __builtin_ia32_vpcomltuw (v8hi, v8hi)\n+v8hi __builtin_ia32_vpcomltw (v8hi, v8hi)\n+v16qi __builtin_ia32_vpcomneb (v16qi, v16qi)\n+v4si __builtin_ia32_vpcomned (v4si, v4si)\n+v2di __builtin_ia32_vpcomneq (v2di, v2di)\n+v16qi __builtin_ia32_vpcomneub (v16qi, v16qi)\n+v4si __builtin_ia32_vpcomneud (v4si, v4si)\n+v2di __builtin_ia32_vpcomneuq (v2di, v2di)\n+v8hi __builtin_ia32_vpcomneuw (v8hi, v8hi)\n+v8hi __builtin_ia32_vpcomnew (v8hi, v8hi)\n+v16qi __builtin_ia32_vpcomtrueb (v16qi, v16qi)\n+v4si __builtin_ia32_vpcomtrued (v4si, v4si)\n+v2di __builtin_ia32_vpcomtrueq (v2di, v2di)\n+v16qi __builtin_ia32_vpcomtrueub (v16qi, v16qi)\n+v4si __builtin_ia32_vpcomtrueud (v4si, v4si)\n+v2di __builtin_ia32_vpcomtrueuq (v2di, v2di)\n+v8hi __builtin_ia32_vpcomtrueuw (v8hi, v8hi)\n+v8hi __builtin_ia32_vpcomtruew (v8hi, v8hi)\n+v4si __builtin_ia32_vphaddbd (v16qi)\n+v2di __builtin_ia32_vphaddbq (v16qi)\n+v8hi __builtin_ia32_vphaddbw (v16qi)\n+v2di __builtin_ia32_vphadddq (v4si)\n+v4si __builtin_ia32_vphaddubd (v16qi)\n+v2di __builtin_ia32_vphaddubq (v16qi)\n+v8hi __builtin_ia32_vphaddubw (v16qi)\n+v2di __builtin_ia32_vphaddudq (v4si)\n+v4si __builtin_ia32_vphadduwd (v8hi)\n+v2di __builtin_ia32_vphadduwq (v8hi)\n+v4si __builtin_ia32_vphaddwd (v8hi)\n+v2di __builtin_ia32_vphaddwq (v8hi)\n+v8hi __builtin_ia32_vphsubbw (v16qi)\n+v2di __builtin_ia32_vphsubdq (v4si)\n+v4si __builtin_ia32_vphsubwd (v8hi)\n+v4si __builtin_ia32_vpmacsdd (v4si, v4si, v4si)\n+v2di __builtin_ia32_vpmacsdqh (v4si, v4si, v2di)\n+v2di __builtin_ia32_vpmacsdql (v4si, v4si, v2di)\n+v4si __builtin_ia32_vpmacssdd (v4si, v4si, v4si)\n+v2di __builtin_ia32_vpmacssdqh (v4si, v4si, v2di)\n+v2di __builtin_ia32_vpmacssdql (v4si, v4si, v2di)\n+v4si __builtin_ia32_vpmacsswd (v8hi, v8hi, v4si)\n+v8hi __builtin_ia32_vpmacssww (v8hi, v8hi, v8hi)\n+v4si __builtin_ia32_vpmacswd (v8hi, v8hi, v4si)\n+v8hi __builtin_ia32_vpmacsww (v8hi, v8hi, v8hi)\n+v4si __builtin_ia32_vpmadcsswd (v8hi, v8hi, v4si)\n+v4si __builtin_ia32_vpmadcswd (v8hi, v8hi, v4si)\n+v16qi __builtin_ia32_vpperm (v16qi, v16qi, v16qi)\n+v16qi __builtin_ia32_vprotb (v16qi, v16qi)\n+v4si __builtin_ia32_vprotd (v4si, v4si)\n+v2di __builtin_ia32_vprotq (v2di, v2di)\n+v8hi __builtin_ia32_vprotw (v8hi, v8hi)\n+v16qi __builtin_ia32_vpshab (v16qi, v16qi)\n+v4si __builtin_ia32_vpshad (v4si, v4si)\n+v2di __builtin_ia32_vpshaq (v2di, v2di)\n+v8hi __builtin_ia32_vpshaw (v8hi, v8hi)\n+v16qi __builtin_ia32_vpshlb (v16qi, v16qi)\n+v4si __builtin_ia32_vpshld (v4si, v4si)\n+v2di __builtin_ia32_vpshlq (v2di, v2di)\n+v8hi __builtin_ia32_vpshlw (v8hi, v8hi)\n+@end smallexample\n+\n The following built-in functions are available when @option{-mfma4} is used.\n All of them generate the machine instruction that is part of the name\n with MMX registers."}, {"sha": "0a913e0ebc89fce7be51811dc09b22bcd73c4092", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=43a8b705906034ecb3edfb54558a34bd362a7213", "patch": "@@ -594,7 +594,7 @@ Objective-C and Objective-C++ Dialects}.\n -mcld -mcx16 -msahf -mmovbe -mcrc32 -mrecip @gol\n -mmmx  -msse  -msse2 -msse3 -mssse3 -msse4.1 -msse4.2 -msse4 -mavx @gol\n -maes -mpclmul @gol\n--msse4a -m3dnow -mpopcnt -mabm -mfma4 @gol\n+-msse4a -m3dnow -mpopcnt -mabm -mfma4 -mxop @gol\n -mthreads  -mno-align-stringops  -minline-all-stringops @gol\n -minline-stringops-dynamically -mstringop-strategy=@var{alg} @gol\n -mpush-args  -maccumulate-outgoing-args  -m128bit-long-double @gol\n@@ -12005,6 +12005,8 @@ preferred alignment to @option{-mpreferred-stack-boundary=2}.\n @itemx -mno-sse4a\n @itemx -mfma4\n @itemx -mno-fma4\n+@itemx -mxop\n+@itemx -mno-xop\n @itemx -m3dnow\n @itemx -mno-3dnow\n @itemx -mpopcnt\n@@ -12018,8 +12020,8 @@ preferred alignment to @option{-mpreferred-stack-boundary=2}.\n @opindex m3dnow\n @opindex mno-3dnow\n These switches enable or disable the use of instructions in the MMX,\n-SSE, SSE2, SSE3, SSSE3, SSE4.1, AVX, AES, PCLMUL, SSE4A, FMA4, ABM or\n-3DNow!@: extended instruction sets.\n+SSE, SSE2, SSE3, SSSE3, SSE4.1, AVX, AES, PCLMUL, SSE4A, FMA4, XOP,\n+ABM or 3DNow!@: extended instruction sets.\n These extensions are also available as built-in functions: see\n @ref{X86 Built-in Functions}, for details of the functions enabled and\n disabled by these switches."}, {"sha": "a9df865c15f0c002c82bfd62f54b8db3dfcfc511", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=43a8b705906034ecb3edfb54558a34bd362a7213", "patch": "@@ -1,3 +1,32 @@\n+2009-11-04  Harsha Jagasia  <harsha.jagasia@amd.com>\n+\t    Dwarakanath Rajagopal  <dwarak.rajagopal@amd.com>\n+\n+\t* gcc.target/i386/xop-check.h: New file.\n+\t* gcc.target/i386/xop-hadduX.c: Ditto.\n+\t* gcc.target/i386/xop-haddX.c: Ditto.\n+\t* gcc.target/i386/xop-hsubX.c: Ditto.\n+\t* gcc.target/i386/xop-imul32widen-vector.c: Ditto.\n+\t* gcc.target/i386/xop-imul32widen-vector.c: Ditto.\n+\t* gcc.target/i386/xop-pcmov2.c: Ditto.\n+\t* gcc.target/i386/xop-pcmov.c: Ditto.\n+\t* gcc.target/i386/xop-rotate1-vector.c: Ditto.\n+\t* gcc.target/i386/xop-rotate2-vector.c: Ditto.\n+\t* gcc.target/i386/xop-rotate3-vector.c: Ditto.\n+\t* gcc.target/i386/xop-shift1-vector.c: Ditto.\n+\t* gcc.target/i386/xop-shift2-vector.c: Ditto.\n+\t* gcc.target/i386/xop-shift3-vector.c: Ditto.\n+\t* gcc.target/i386/i386.exp:  Add check_effective_target_xop.\n+\t* gcc.target/i386/sse-12.c: Update with new compile options to \n+\tactivate and check xopintrin.h intrinsic file.\n+\t* gcc.target/i386/sse-13.c: Ditto.\n+\t* gcc.target/i386/sse-14.c: Ditto.\n+\t* gcc.target/i386/sse-22.c: Ditto.\n+\t* gcc.target/i386/sse-23.c: Ditto.\n+\t* g++.dg/other/i386-2.C: Ditto.\n+\t* g++.dg/other/i386-3.C: Ditto.\n+\t* g++.dg/other/i386-5.C: Ditto.\n+\t* g++.dg/other/i386-6.C: Ditto.\n+\t\n 2009-11-04  Wei Guozhi  <carrot@google.com>\n \n \tPR target/40835"}, {"sha": "1ef6b2775d804a514b7f99989e9e2e348c902038", "filename": "gcc/testsuite/g++.dg/other/i386-2.C", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fi386-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fi386-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fi386-2.C?ref=43a8b705906034ecb3edfb54558a34bd362a7213", "patch": "@@ -1,8 +1,9 @@\n-/* Test that {,x,e,p,t,s,w,a,i}mmintrin.h, fma4intrin.h, mm3dnow.h and\n+/* Test that {,x,e,p,t,s,w,a,i}mmintrin.h, fma4intrin.h, xopintrin.h, mm3dnow.h and\n    mm_malloc.h are usable with -O -pedantic-errors.  */\n /* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n-/* { dg-options \"-O -pedantic-errors -march=k8 -m3dnow -mavx -msse4a -mfma4 -maes -mpclmul\" } */\n+/* { dg-options \"-O -pedantic-errors -march=k8 -m3dnow -mavx -msse4a -mfma4 -mxop -maes -mpclmul\" } */\n \n #include <x86intrin.h>\n \n int dummy;\n+"}, {"sha": "df33af8bbd9a7d887745084f6622381b54e3a033", "filename": "gcc/testsuite/g++.dg/other/i386-3.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fi386-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fi386-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fi386-3.C?ref=43a8b705906034ecb3edfb54558a34bd362a7213", "patch": "@@ -1,6 +1,6 @@\n-/* Test that {,x,e,p,t,s,w,a,i}mmintrin.h, fma4intrin.h, mm3dnow.h and\n+/* Test that {,x,e,p,t,s,w,a,i}mmintrin.h, fma4intrin.h, mm3dnow.h, xopintrin.h and\n     mm_malloc.h are usable with -O -fkeep-inline-functions.  */\n /* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n-/* { dg-options \"-O -fkeep-inline-functions -march=k8 -m3dnow -mavx -msse4a -mfma4 -maes -mpclmul\" } */\n+/* { dg-options \"-O -fkeep-inline-functions -march=k8 -m3dnow -mavx -msse4a -mfma4 -mxop -maes -mpclmul\" } */\n \n #include <x86intrin.h>"}, {"sha": "383aae365bb0b1f2efb75abafd1600a3d1a27925", "filename": "gcc/testsuite/g++.dg/other/i386-5.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fi386-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fi386-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fi386-5.C?ref=43a8b705906034ecb3edfb54558a34bd362a7213", "patch": "@@ -1,6 +1,6 @@\n-/* Test that {,x,e,p,t,s,w,a,i}mmintrin.h, fma4intrin.h, mm3dnow.h and\n+/* Test that {,x,e,p,t,s,w,a,i}mmintrin.h, fma4intrin.h, xopintrin.h, mm3dnow.h and\n    mm_malloc.h are usable with -O -fkeep-inline-functions.  */\n /* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n-/* { dg-options \"-O -fkeep-inline-functions -march=k8 -m3dnow -mavx -msse4a -mfma4 -maes -mpclmul\" } */\n+/* { dg-options \"-O -fkeep-inline-functions -march=k8 -m3dnow -mavx -msse4a -mfma4 -mxop -maes -mpclmul\" } */\n \n #include <x86intrin.h>"}, {"sha": "2bd4609d6719670874cf74c3d79aaa13756123c2", "filename": "gcc/testsuite/g++.dg/other/i386-6.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fi386-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fi386-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fi386-6.C?ref=43a8b705906034ecb3edfb54558a34bd362a7213", "patch": "@@ -1,7 +1,7 @@\n-/* Test that {,x,e,p,t,s,w,a,i}mmintrin.h, fma4intrin.h, mm3dnow.h and\n+/* Test that {,x,e,p,t,s,w,a,i}mmintrin.h, fma4intrin.h, xopintrin.h, mm3dnow.h and\n    mm_malloc.h are usable with -O -pedantic-errors.  */\n /* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n-/* { dg-options \"-O -pedantic-errors -march=k8 -m3dnow -mavx -msse4a -mfma4 -maes -mpclmul\" } */\n+/* { dg-options \"-O -pedantic-errors -march=k8 -m3dnow -mavx -msse4a -mfma4 -mxop -maes -mpclmul\" } */\n \n #include <x86intrin.h>\n "}, {"sha": "2708b04d06e57c38811c4a8f3515bb9ff18567a5", "filename": "gcc/testsuite/gcc.target/i386/i386.exp", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fi386.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fi386.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fi386.exp?ref=43a8b705906034ecb3edfb54558a34bd362a7213", "patch": "@@ -146,6 +146,20 @@ proc check_effective_target_fma4 { } {\n     } \"-O2 -mfma4\" ]\n }\n \n+# Return 1 if xop instructions can be compiled.\n+proc check_effective_target_xop { } {\n+    return [check_no_compiler_messages xop object {\n+\ttypedef long long __m128i __attribute__ ((__vector_size__ (16), __may_alias__));\n+\ttypedef short __v8hi __attribute__ ((__vector_size__ (16)));\n+\t__m128i _mm_maccs_epi16(__m128i __A, __m128i __B, __m128i __C)\n+\t{\n+\t    return (__m128i) __builtin_ia32_pmacssww ((__v8hi)__A,\n+\t\t\t\t\t\t      (__v8hi)__B,\n+\t\t\t\t\t\t      (__v8hi)__C);\n+\t}\n+    } \"-O2 -mxop\" ]\n+}\n+\n # If a testcase doesn't have special options, use these.\n global DEFAULT_CFLAGS\n if ![info exists DEFAULT_CFLAGS] then {"}, {"sha": "d03c41bf10a87b2dd26cd43a5e75e967568d361f", "filename": "gcc/testsuite/gcc.target/i386/sse-12.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-12.c?ref=43a8b705906034ecb3edfb54558a34bd362a7213", "patch": "@@ -1,7 +1,7 @@\n-/* Test that {,x,e,p,t,s,w,a,b,i}mmintrin.h, mm3dnow.h and mm_malloc.h are\n+/* Test that {,x,e,p,t,s,w,a,b,i}mmintrin.h, xopintrin.h, mm3dnow.h and mm_malloc.h are\n    usable with -O -std=c89 -pedantic-errors.  */\n /* { dg-do compile } */\n-/* { dg-options \"-O -std=c89 -pedantic-errors -march=k8 -m3dnow -mavx -mfma4 -maes -mpclmul\" } */\n+/* { dg-options \"-O -std=c89 -pedantic-errors -march=k8 -m3dnow -mavx -mfma4 -mxop -maes -mpclmul\" } */\n \n #include <x86intrin.h>\n "}, {"sha": "2ef63d5fc6892ce1528fd6f9d7c524f5b3bd1edb", "filename": "gcc/testsuite/gcc.target/i386/sse-13.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-13.c?ref=43a8b705906034ecb3edfb54558a34bd362a7213", "patch": "@@ -1,10 +1,10 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -Werror-implicit-function-declaration -march=k8 -m3dnow -mavx -maes -mpclmul\" } */\n+/* { dg-options \"-O2 -Werror-implicit-function-declaration -march=k8 -m3dnow -mavx -mxop -maes -mpclmul\" } */\n \n #include <mm_malloc.h>\n \n /* Test that the intrinsics compile with optimization.  All of them are\n-   defined as inline functions in {,x,e,p,t,s,w,a,b,i}mmintrin.h and mm3dnow.h\n+   defined as inline functions in {,x,e,p,t,s,w,a,b,i}mmintrin.h, xopintrin.h and mm3dnow.h\n    that reference the proper builtin functions.  Defining away \"extern\" and\n    \"__inline\" results in all of them being compiled as proper functions.  */\n \n@@ -125,4 +125,10 @@\n #define __builtin_ia32_vec_ext_v4hi(A, N) __builtin_ia32_vec_ext_v4hi(A, 0)\n #define __builtin_ia32_shufps(A, B, N) __builtin_ia32_shufps(A, B, 0)\n \n+/* xopintrin.h */\n+#define  __builtin_ia32_vprotbi(A, N) __builtin_ia32_vprotbi (A,1)\n+#define  __builtin_ia32_vprotwi(A, N) __builtin_ia32_vprotwi (A,1)\n+#define  __builtin_ia32_vprotdi(A, N) __builtin_ia32_vprotdi (A,1)\n+#define  __builtin_ia32_vprotqi(A, N) __builtin_ia32_vprotqi (A,1)\n+\n #include <x86intrin.h>"}, {"sha": "783cd0af106c51d0b003a832c070349fc6fb1534", "filename": "gcc/testsuite/gcc.target/i386/sse-14.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-14.c?ref=43a8b705906034ecb3edfb54558a34bd362a7213", "patch": "@@ -1,10 +1,10 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O0 -Werror-implicit-function-declaration -march=k8 -m3dnow -mavx -msse4a -maes -mpclmul\" } */\n+/* { dg-options \"-O0 -Werror-implicit-function-declaration -march=k8 -m3dnow -mavx -mxop -msse4a -maes -mpclmul\" } */\n \n #include <mm_malloc.h>\n \n /* Test that the intrinsics compile without optimization.  All of them are\n-   defined as inline functions in {,x,e,p,t,s,w,a}mmintrin.h  and mm3dnow.h\n+   defined as inline functions in {,x,e,p,t,s,w,a}mmintrin.h, xopintrin.h  and mm3dnow.h\n    that reference the proper builtin functions.  Defining away \"extern\" and\n    \"__inline\" results in all of them being compiled as proper functions.  */\n \n@@ -155,3 +155,10 @@ test_2 (_m_pinsrw, __m64, __m64, int, 1)\n test_1 (_mm_shuffle_pi16, __m64, __m64, 1)\n test_1 (_m_pshufw, __m64, __m64, 1)\n test_1 (_mm_prefetch, void, void *, _MM_HINT_NTA)\n+\n+/* xopintrin.h */\n+test_1 ( _mm_roti_epi8, __m128i, __m128i, 1)\n+test_1 ( _mm_roti_epi16, __m128i, __m128i, 1)\n+test_1 ( _mm_roti_epi32, __m128i, __m128i, 1)\n+test_1 ( _mm_roti_epi64, __m128i, __m128i, 1)\n+"}, {"sha": "541cad4d4394236668dc578246004bf526ba6a7c", "filename": "gcc/testsuite/gcc.target/i386/sse-22.c", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-22.c?ref=43a8b705906034ecb3edfb54558a34bd362a7213", "patch": "@@ -5,7 +5,7 @@\n #include <mm_malloc.h>\n \n /* Test that the intrinsics compile without optimization.  All of them are\n-   defined as inline functions in {,x,e,p,t,s,w,a}mmintrin.h  and mm3dnow.h\n+   defined as inline functions in {,x,e,p,t,s,w,a}mmintrin.h, xopintrin.h and mm3dnow.h\n    that reference the proper builtin functions.  Defining away \"extern\" and\n    \"__inline\" results in all of them being compiled as proper functions.  */\n \n@@ -37,7 +37,7 @@\n \n \n #ifndef DIFFERENT_PRAGMAS\n-#pragma GCC target (\"mmx,3dnow,sse,sse2,sse3,ssse3,sse4.1,sse4.2,sse4a,aes,pclmul\")\n+#pragma GCC target (\"mmx,3dnow,sse,sse2,sse3,ssse3,sse4.1,sse4.2,sse4a,aes,pclmul,xop\")\n #endif\n \n /* Following intrinsics require immediate arguments.  They\n@@ -159,3 +159,13 @@ test_1 (_mm_round_pd, __m128d, __m128d, 1)\n test_1 (_mm_round_ps, __m128, __m128, 1)\n test_2 (_mm_round_sd, __m128d, __m128d, __m128d, 1)\n test_2 (_mm_round_ss, __m128, __m128, __m128, 1)\n+\n+/* xopintrin.h (XOP). */\n+#ifdef DIFFERENT_PRAGMAS\n+#pragma GCC target (\"xop\")\n+#endif\n+#include <x86intrin.h>\n+test_1 ( _mm_roti_epi8, __m128i, __m128i, 1)\n+test_1 ( _mm_roti_epi16, __m128i, __m128i, 1)\n+test_1 ( _mm_roti_epi32, __m128i, __m128i, 1)\n+test_1 ( _mm_roti_epi64, __m128i, __m128i, 1)"}, {"sha": "3e0fa1f5ca4eafc6b81e4ff29ff4085dfbe8b656", "filename": "gcc/testsuite/gcc.target/i386/sse-23.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-23.c?ref=43a8b705906034ecb3edfb54558a34bd362a7213", "patch": "@@ -4,7 +4,7 @@\n #include <mm_malloc.h>\n \n /* Test that the intrinsics compile with optimization.  All of them are\n-   defined as inline functions in {,x,e,p,t,s,w,a,b}mmintrin.h and mm3dnow.h\n+   defined as inline functions in {,x,e,p,t,s,w,a}mmintrin.h, xopintrin.h and mm3dnow.h\n    that reference the proper builtin functions.  Defining away \"extern\" and\n    \"__inline\" results in all of them being compiled as proper functions.  */\n \n@@ -93,14 +93,13 @@\n #define __builtin_ia32_vec_ext_v4hi(A, N) __builtin_ia32_vec_ext_v4hi(A, 0)\n #define __builtin_ia32_shufps(A, B, N) __builtin_ia32_shufps(A, B, 0)\n \n-/* bmmintrin.h */\n-#define __builtin_ia32_protbi(A, B) __builtin_ia32_protbi(A,1)\n-#define __builtin_ia32_protwi(A, B) __builtin_ia32_protwi(A,1)\n-#define __builtin_ia32_protdi(A, B) __builtin_ia32_protdi(A,1)\n-#define __builtin_ia32_protqi(A, B) __builtin_ia32_protqi(A,1)\n+/* xopintrin.h */\n+#define __builtin_ia32_vprotbi(A, B) __builtin_ia32_vprotbi(A,1)\n+#define __builtin_ia32_vprotwi(A, B) __builtin_ia32_vprotwi(A,1)\n+#define __builtin_ia32_vprotdi(A, B) __builtin_ia32_vprotdi(A,1)\n+#define __builtin_ia32_vprotqi(A, B) __builtin_ia32_vprotqi(A,1)\n \n-\n-#pragma GCC target (\"3dnow,sse4,sse4a,aes,pclmul\")\n+#pragma GCC target (\"3dnow,sse4,sse4a,aes,pclmul,xop\")\n #include <wmmintrin.h>\n #include <smmintrin.h>\n #include <mm3dnow.h>"}, {"sha": "2dede33d8513cc9a965daebbec50e6def86e4b0a", "filename": "gcc/testsuite/gcc.target/i386/xop-check.h", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-check.h?ref=43a8b705906034ecb3edfb54558a34bd362a7213", "patch": "@@ -0,0 +1,20 @@\n+#include <stdlib.h>\n+\n+#include \"cpuid.h\"\n+\n+static void xop_test (void);\n+\n+int\n+main ()\n+{\n+  unsigned int eax, ebx, ecx, edx;\n+ \n+  if (!__get_cpuid (0x80000001, &eax, &ebx, &ecx, &edx))\n+    return 0;\n+\n+  /* Run XOP test only if host has XOP support.  */\n+  if (ecx & bit_XOP)\n+    xop_test ();\n+\n+  exit (0);\n+}"}, {"sha": "7d3220baffef7c0f832e25ba86396e0f9a3aef4b", "filename": "gcc/testsuite/gcc.target/i386/xop-haddX.c", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-haddX.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-haddX.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-haddX.c?ref=43a8b705906034ecb3edfb54558a34bd362a7213", "patch": "@@ -0,0 +1,206 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target xop } */\n+/* { dg-options \"-O2 -mxop\" } */\n+\n+#include \"xop-check.h\"\n+\n+#include <x86intrin.h>\n+#include <string.h>\n+\n+#define NUM 10\n+\n+union\n+{\n+  __m128i x[NUM];\n+  signed char ssi[NUM * 16];\n+  short si[NUM * 8];\n+  int li[NUM * 4];\n+  long long lli[NUM * 2];\n+} dst, res, src1;\n+\n+static void\n+init_sbyte ()\n+{\n+  int i;\n+  for (i=0; i < NUM * 16; i++)\n+    src1.ssi[i] = i;\n+}\n+\n+static void\n+init_sword ()\n+{\n+  int i;\n+  for (i=0; i < NUM * 8; i++)\n+    src1.si[i] = i;\n+}\n+\n+\n+static void\n+init_sdword ()\n+{\n+  int i;\n+  for (i=0; i < NUM * 4; i++)\n+    src1.li[i] = i;\n+}\n+\n+static int \n+check_sbyte2word ()\n+{\n+  int i, j, s, t, check_fails = 0;\n+  for (i = 0; i < NUM * 16; i = i + 16)\n+    {\n+      for (j = 0; j < 8; j++)\n+\t{\n+\t  t = i + (2 * j);\n+\t  s = (i / 2) + j;\n+\t  res.si[s] = src1.ssi[t] + src1.ssi[t + 1] ;\n+\t  if (res.si[s] != dst.si[s]) \n+\t    check_fails++;\t\n+\t}\n+    }\n+}\n+\n+static int \n+check_sbyte2dword ()\n+{\n+  int i, j, s, t, check_fails = 0;\n+  for (i = 0; i < NUM * 16; i = i + 16)\n+    {\n+      for (j = 0; j < 4; j++)\n+\t{\n+\t  t = i + (4 * j);\n+\t  s = (i / 4) + j;\n+\t  res.li[s] = (src1.ssi[t] + src1.ssi[t + 1]) + (src1.ssi[t + 2]\n+\t              + src1.ssi[t + 3]); \n+\t  if (res.li[s] != dst.li[s]) \n+\t    check_fails++;\n+\t}\n+    }\n+  return check_fails++;\n+}\n+\n+static int\n+check_sbyte2qword ()\n+{\n+  int i, j, s, t, check_fails = 0;\n+  for (i = 0; i < NUM * 16; i = i + 16)\n+    {\n+      for (j = 0; j < 2; j++)\n+\t{\n+\t  t = i + (8 * j);\n+\t  s = (i / 8) + j;\n+\t  res.lli[s] = ((src1.ssi[t] + src1.ssi[t + 1]) + (src1.ssi[t + 2] \n+\t\t       + src1.ssi[t + 3])) + ((src1.ssi[t + 4] + src1.ssi[t +5])\n+\t               + (src1.ssi[t + 6] + src1.ssi[t + 7])); \n+\t  if (res.lli[s] != dst.lli[s]) \n+\t    check_fails++;\n+\t}\n+    }\n+  return check_fails++;\n+}\n+\n+static int\n+check_sword2dword ()\n+{\n+  int i, j, s, t, check_fails = 0;\n+  for (i = 0; i < (NUM * 8); i = i + 8)\n+    {\n+      for (j = 0; j < 4; j++)\n+\t{\n+\t  t = i + (2 * j);\n+\t  s = (i / 2) + j;\n+\t  res.li[s] = src1.si[t] + src1.si[t + 1] ;\n+\t  if (res.li[s] != dst.li[s]) \n+\t    check_fails++;\t\n+\t}\n+    }\n+}\n+\n+static int \n+check_sword2qword ()\n+{\n+  int i, j, s, t, check_fails = 0;\n+  for (i = 0; i < NUM * 8; i = i + 8)\n+    {\n+      for (j = 0; j < 2; j++)\n+\t{\n+\t  t = i + (4 * j);\n+\t  s = (i / 4) + j;\n+\t  res.lli[s] = (src1.si[t] + src1.si[t + 1]) + (src1.si[t + 2]\n+\t               + src1.si[t + 3]); \n+\t  if (res.lli[s] != dst.lli[s]) \n+\t    check_fails++;\n+\t}\n+    }\n+  return check_fails++;\n+}\n+\n+static int\n+check_dword2qword ()\n+{\n+  int i, j, s, t, check_fails = 0;\n+  for (i = 0; i < (NUM * 4); i = i + 4)\n+    {\n+      for (j = 0; j < 2; j++)\n+\t{\n+\t  t = i + (2 * j);\n+\t  s = (i / 2) + j;\n+\t  res.lli[s] = src1.li[t] + src1.li[t + 1] ;\n+\t  if (res.lli[s] != dst.lli[s]) \n+\t    check_fails++;\t\n+\t}\n+    }\n+}\n+\n+static void\n+xop_test (void)\n+{\n+  int i;\n+\n+  init_sbyte ();\n+  \n+  for (i = 0; i < NUM; i++)\n+    dst.x[i] = _mm_haddw_epi8 (src1.x[i]);\n+  \n+  if (check_sbyte2word())\n+  abort ();\n+  \n+\n+  for (i = 0; i < (NUM ); i++)\n+    dst.x[i] = _mm_haddd_epi8 (src1.x[i]);\n+  \n+  if (check_sbyte2dword())\n+    abort (); \n+  \n+\n+  for (i = 0; i < NUM; i++)\n+    dst.x[i] = _mm_haddq_epi8 (src1.x[i]);\n+  \n+  if (check_sbyte2qword())\n+    abort ();\n+\n+\n+  init_sword ();\n+\n+  for (i = 0; i < (NUM ); i++)\n+    dst.x[i] = _mm_haddd_epi16 (src1.x[i]);\n+  \n+  if (check_sword2dword())\n+    abort (); \n+\n+  for (i = 0; i < NUM; i++)\n+    dst.x[i] = _mm_haddq_epi16 (src1.x[i]);\n+  \n+  if (check_sword2qword())\n+    abort ();\n+ \n+\n+  init_sdword ();\n+\n+    for (i = 0; i < NUM; i++)\n+    dst.x[i] = _mm_haddq_epi32 (src1.x[i]);\n+  \n+  if (check_dword2qword())\n+    abort ();\n+\n+}"}, {"sha": "9c7ea9a2a6017f84ca221c345b8f986e3136dec3", "filename": "gcc/testsuite/gcc.target/i386/xop-hadduX.c", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-hadduX.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-hadduX.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-hadduX.c?ref=43a8b705906034ecb3edfb54558a34bd362a7213", "patch": "@@ -0,0 +1,207 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target xop } */\n+/* { dg-options \"-O2 -mxop\" } */\n+\n+#include \"xop-check.h\"\n+\n+#include <x86intrin.h>\n+#include <string.h>\n+\n+#define NUM 10\n+\n+union\n+{\n+  __m128i x[NUM];\n+  unsigned char  ssi[NUM * 16];\n+  unsigned short si[NUM * 8];\n+  unsigned int li[NUM * 4];\n+  unsigned long long  lli[NUM * 2];\n+} dst, res, src1;\n+\n+static void\n+init_byte ()\n+{\n+  int i;\n+  for (i=0; i < NUM * 16; i++)\n+    src1.ssi[i] = i;\n+}\n+\n+static void\n+init_word ()\n+{\n+  int i;\n+  for (i=0; i < NUM * 8; i++)\n+    src1.si[i] = i;\n+}\n+\n+\n+static void\n+init_dword ()\n+{\n+  int i;\n+  for (i=0; i < NUM * 4; i++)\n+    src1.li[i] = i;\n+}\n+\n+static int \n+check_byte2word ()\n+{\n+  int i, j, s, t, check_fails = 0;\n+  for (i = 0; i < NUM * 16; i = i + 16)\n+    {\n+      for (j = 0; j < 8; j++)\n+\t{\n+\t  t = i + (2 * j);\n+\t  s = (i / 2) + j;\n+\t  res.si[s] = src1.ssi[t] + src1.ssi[t + 1] ;\n+\t  if (res.si[s] != dst.si[s]) \n+\t    check_fails++;\t\n+\t}\n+    }\n+}\n+\n+static int \n+check_byte2dword ()\n+{\n+  int i, j, s, t, check_fails = 0;\n+  for (i = 0; i < NUM * 16; i = i + 16)\n+    {\n+      for (j = 0; j < 4; j++)\n+\t{\n+\t  t = i + (4 * j);\n+\t  s = (i / 4) + j;\n+\t  res.li[s] = (src1.ssi[t] + src1.ssi[t + 1]) + (src1.ssi[t + 2]\n+\t              + src1.ssi[t + 3]); \n+\t  if (res.li[s] != dst.li[s]) \n+\t    check_fails++;\n+\t}\n+    }\n+  return check_fails++;\n+}\n+\n+static int\n+check_byte2qword ()\n+{\n+  int i, j, s, t, check_fails = 0;\n+  for (i = 0; i < NUM * 16; i = i + 16)\n+    {\n+      for (j = 0; j < 2; j++)\n+\t{\n+\t  t = i + (8 * j);\n+\t  s = (i / 8) + j;\n+\t  res.lli[s] = ((src1.ssi[t] + src1.ssi[t + 1]) + (src1.ssi[t + 2] \n+\t\t       + src1.ssi[t + 3])) + ((src1.ssi[t + 4] + src1.ssi[t +5])\n+\t               + (src1.ssi[t + 6] + src1.ssi[t + 7])); \n+\t  if (res.lli[s] != dst.lli[s]) \n+\t    check_fails++;\n+\t}\n+    }\n+  return check_fails++;\n+}\n+\n+static int\n+check_word2dword ()\n+{\n+  int i, j, s, t, check_fails = 0;\n+  for (i = 0; i < (NUM * 8); i = i + 8)\n+    {\n+      for (j = 0; j < 4; j++)\n+\t{\n+\t  t = i + (2 * j);\n+\t  s = (i / 2) + j;\n+\t  res.li[s] = src1.si[t] + src1.si[t + 1] ;\n+\t  if (res.li[s] != dst.li[s]) \n+\t    check_fails++;\t\n+\t}\n+    }\n+}\n+\n+static int \n+check_word2qword ()\n+{\n+  int i, j, s, t, check_fails = 0;\n+  for (i = 0; i < NUM * 8; i = i + 8)\n+    {\n+      for (j = 0; j < 2; j++)\n+\t{\n+\t  t = i + (4 * j);\n+\t  s = (i / 4) + j;\n+\t  res.lli[s] = (src1.si[t] + src1.si[t + 1]) + (src1.si[t + 2]\n+\t               + src1.si[t + 3]); \n+\t  if (res.lli[s] != dst.lli[s]) \n+\t    check_fails++;\n+\t}\n+    }\n+  return check_fails++;\n+}\n+\n+static int\n+check_dword2qword ()\n+{\n+  int i, j, s, t, check_fails = 0;\n+  for (i = 0; i < (NUM * 4); i = i + 4)\n+    {\n+      for (j = 0; j < 2; j++)\n+\t{\n+\t  t = i + (2 * j);\n+\t  s = (i / 2) + j;\n+\t  res.lli[s] = src1.li[t] + src1.li[t + 1] ;\n+\t  if (res.lli[s] != dst.lli[s]) \n+\t    check_fails++;\t\n+\t}\n+    }\n+}\n+\n+static void\n+xop_test (void)\n+{\n+  int i;\n+  \n+  /* Check haddubw */\n+  init_byte ();\n+  \n+  for (i = 0; i < NUM; i++)\n+    dst.x[i] = _mm_haddw_epu8 (src1.x[i]);\n+  \n+  if (check_byte2word())\n+  abort ();\n+  \n+  /* Check haddubd */\n+  for (i = 0; i < (NUM ); i++)\n+    dst.x[i] = _mm_haddd_epu8 (src1.x[i]);\n+  \n+  if (check_byte2dword())\n+    abort (); \n+  \n+  /* Check haddubq */\n+  for (i = 0; i < NUM; i++)\n+    dst.x[i] = _mm_haddq_epu8 (src1.x[i]);\n+  \n+  if (check_byte2qword())\n+    abort ();\n+\n+  /* Check hadduwd */\n+  init_word ();\n+\n+  for (i = 0; i < (NUM ); i++)\n+    dst.x[i] = _mm_haddd_epu16 (src1.x[i]);\n+  \n+  if (check_word2dword())\n+    abort (); \n+   \n+  /* Check haddbuwq */\n+ \n+  for (i = 0; i < NUM; i++)\n+    dst.x[i] = _mm_haddq_epu16 (src1.x[i]);\n+  \n+  if (check_word2qword())\n+    abort ();\n+ \n+  /* Check hadudq */\n+  init_dword ();\n+    for (i = 0; i < NUM; i++)\n+    dst.x[i] = _mm_haddq_epu32 (src1.x[i]);\n+  \n+  if (check_dword2qword())\n+    abort ();\n+}"}, {"sha": "f0fa9b312f24c9c3a37024a72a961001c531f4e8", "filename": "gcc/testsuite/gcc.target/i386/xop-hsubX.c", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-hsubX.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-hsubX.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-hsubX.c?ref=43a8b705906034ecb3edfb54558a34bd362a7213", "patch": "@@ -0,0 +1,128 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target xop } */\n+/* { dg-options \"-O2 -mxop\" } */\n+\n+#include \"xop-check.h\"\n+\n+#include <x86intrin.h>\n+#include <string.h>\n+\n+#define NUM 10\n+\n+union\n+{\n+  __m128i x[NUM];\n+  signed char ssi[NUM * 16];\n+  short si[NUM * 8];\n+  int li[NUM * 4];\n+  long long lli[NUM * 2];\n+} dst, res, src1;\n+\n+static void\n+init_sbyte ()\n+{\n+  int i;\n+  for (i=0; i < NUM * 16; i++)\n+    src1.ssi[i] = i;\n+}\n+\n+static void\n+init_sword ()\n+{\n+  int i;\n+  for (i=0; i < NUM * 8; i++)\n+    src1.si[i] = i;\n+}\n+\n+\n+static void\n+init_sdword ()\n+{\n+  int i;\n+  for (i=0; i < NUM * 4; i++)\n+    src1.li[i] = i;\n+}\n+\n+static int \n+check_sbyte2word ()\n+{\n+  int i, j, s, t, check_fails = 0;\n+  for (i = 0; i < NUM * 16; i = i + 16)\n+    {\n+      for (j = 0; j < 8; j++)\n+\t{\n+\t  t = i + (2 * j);\n+\t  s = (i / 2) + j;\n+\t  res.si[s] = src1.ssi[t] - src1.ssi[t + 1] ;\n+\t  if (res.si[s] != dst.si[s]) \n+\t    check_fails++;\t\n+\t}\n+    }\n+}\n+\n+static int\n+check_sword2dword ()\n+{\n+  int i, j, s, t, check_fails = 0;\n+  for (i = 0; i < (NUM * 8); i = i + 8)\n+    {\n+      for (j = 0; j < 4; j++)\n+\t{\n+\t  t = i + (2 * j);\n+\t  s = (i / 2) + j;\n+\t  res.li[s] = src1.si[t] - src1.si[t + 1] ;\n+\t  if (res.li[s] != dst.li[s]) \n+\t    check_fails++;\t\n+\t}\n+    }\n+}\n+\n+static int\n+check_dword2qword ()\n+{\n+  int i, j, s, t, check_fails = 0;\n+  for (i = 0; i < (NUM * 4); i = i + 4)\n+    {\n+      for (j = 0; j < 2; j++)\n+\t{\n+\t  t = i + (2 * j);\n+\t  s = (i / 2) + j;\n+\t  res.lli[s] = src1.li[t] - src1.li[t + 1] ;\n+\t  if (res.lli[s] != dst.lli[s]) \n+\t    check_fails++;\t\n+\t}\n+    }\n+}\n+\n+static void\n+xop_test (void)\n+{\n+  int i;\n+  \n+  /* Check hsubbw */\n+  init_sbyte ();\n+  \n+  for (i = 0; i < NUM; i++)\n+    dst.x[i] = _mm_hsubw_epi8 (src1.x[i]);\n+  \n+  if (check_sbyte2word())\n+  abort ();\n+  \n+\n+  /* Check hsubwd */\n+  init_sword ();\n+\n+  for (i = 0; i < (NUM ); i++)\n+    dst.x[i] = _mm_hsubd_epi16 (src1.x[i]);\n+  \n+  if (check_sword2dword())\n+    abort (); \n+   \n+   /* Check hsubdq */\n+  init_sdword ();\n+    for (i = 0; i < NUM; i++)\n+    dst.x[i] = _mm_hsubq_epi32 (src1.x[i]);\n+  \n+  if (check_dword2qword())\n+    abort ();\n+}"}, {"sha": "0406d023df55d426c45476ef68b3dd3748f852ec", "filename": "gcc/testsuite/gcc.target/i386/xop-imul32widen-vector.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-imul32widen-vector.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-imul32widen-vector.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-imul32widen-vector.c?ref=43a8b705906034ecb3edfb54558a34bd362a7213", "patch": "@@ -0,0 +1,36 @@\n+/* Test that the compiler properly optimizes floating point multiply and add\n+   instructions vector into pmacsdd/etc. on XOP systems.  */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-O2 -mxop -ftree-vectorize\" } */\n+\n+extern void exit (int);\n+\n+typedef long __m128i  __attribute__ ((__vector_size__ (16), __may_alias__));\n+\n+#define SIZE 10240\n+\n+union {\n+  __m128i i_align;\n+  int i32[SIZE];\n+  long i64[SIZE];\n+} a, b, c, d;\n+\n+void\n+imul32_to_64 (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    a.i64[i] = ((long)b.i32[i]) * ((long)c.i32[i]);\n+}\n+\n+int main ()\n+{\n+  imul32_to_64 ();\n+  exit (0);\n+}\n+\n+/* { dg-final { scan-assembler \"vpmacsdql\" } } */\n+/* { dg-final { scan-assembler \"vpmacsdqh\" } } */"}, {"sha": "738cac04105a359c831a6db48e646f65cbd712cf", "filename": "gcc/testsuite/gcc.target/i386/xop-imul64-vector.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-imul64-vector.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-imul64-vector.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-imul64-vector.c?ref=43a8b705906034ecb3edfb54558a34bd362a7213", "patch": "@@ -0,0 +1,36 @@\n+/* Test that the compiler properly optimizes floating point multiply and add\n+   instructions vector into pmacsdd/etc. on XOP systems.  */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-O2 -mxop -ftree-vectorize\" } */\n+\n+extern void exit (int);\n+\n+typedef long __m128i  __attribute__ ((__vector_size__ (16), __may_alias__));\n+\n+#define SIZE 10240\n+\n+union {\n+  __m128i i_align;\n+  long i64[SIZE];\n+} a, b, c, d;\n+\n+void\n+imul64 (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    a.i64[i] = b.i64[i] * c.i64[i];\n+}\n+\n+int main ()\n+{\n+  imul64 ();\n+  exit (0);\n+}\n+\n+/* { dg-final { scan-assembler \"vpmacsdd\" } } */\n+/* { dg-final { scan-assembler \"vphadddq\" } } */\n+/* { dg-final { scan-assembler \"vpmacsdql\" } } */"}, {"sha": "d6375b1fd50fd4e2ae511ca5b5014f82b9b909e2", "filename": "gcc/testsuite/gcc.target/i386/xop-pcmov.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-pcmov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-pcmov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-pcmov.c?ref=43a8b705906034ecb3edfb54558a34bd362a7213", "patch": "@@ -0,0 +1,23 @@\n+/* Test that the compiler properly optimizes conditional floating point moves\n+   into the pcmov instruction on XOP systems.  */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-O2 -mxop\" } */\n+\n+extern void exit (int);\n+\n+double dbl_test (double a, double b, double c, double d)\n+{\n+  return (a > b) ? c : d;\n+}\n+\n+double dbl_a = 1, dbl_b = 2, dbl_c = 3, dbl_d = 4, dbl_e;\n+\n+int main()\n+{\n+  dbl_e = dbl_test (dbl_a, dbl_b, dbl_c, dbl_d);\n+  exit (0);\n+}\n+\n+/* { dg-final { scan-assembler \"vpcmov\" } } */"}, {"sha": "617da39da9821438450ded4905f705e1ef5b0f33", "filename": "gcc/testsuite/gcc.target/i386/xop-pcmov2.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-pcmov2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-pcmov2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-pcmov2.c?ref=43a8b705906034ecb3edfb54558a34bd362a7213", "patch": "@@ -0,0 +1,23 @@\n+/* Test that the compiler properly optimizes conditional floating point moves\n+   into the pcmov instruction on XOP systems.  */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-O2 -mxop\" } */\n+\n+extern void exit (int);\n+\n+float flt_test (float a, float b, float c, float d)\n+{\n+  return (a > b) ? c : d;\n+}\n+\n+float flt_a = 1, flt_b = 2, flt_c = 3, flt_d = 4, flt_e;\n+\n+int main()\n+{\n+  flt_e = flt_test (flt_a, flt_b, flt_c, flt_d);\n+  exit (0);\n+}\n+\n+/* { dg-final { scan-assembler \"vpcmov\" } } */"}, {"sha": "e3ae644d0b51dd1b308659b229f0ee48d60d9c1d", "filename": "gcc/testsuite/gcc.target/i386/xop-rotate1-vector.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-rotate1-vector.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-rotate1-vector.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-rotate1-vector.c?ref=43a8b705906034ecb3edfb54558a34bd362a7213", "patch": "@@ -0,0 +1,35 @@\n+/* Test that the compiler properly optimizes vector rotate instructions vector\n+   into prot on XOP systems.  */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-O2 -mxop -ftree-vectorize\" } */\n+\n+extern void exit (int);\n+\n+typedef long __m128i  __attribute__ ((__vector_size__ (16), __may_alias__));\n+\n+#define SIZE 10240\n+\n+union {\n+  __m128i i_align;\n+  unsigned u32[SIZE];\n+} a, b, c;\n+\n+void\n+left_rotate32 (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    a.u32[i] = (b.u32[i] << ((sizeof (int) * 8) - 4)) | (b.u32[i] >> 4);\n+}\n+\n+int\n+main ()\n+{\n+  left_rotate32 ();\n+  exit (0);\n+}\n+\n+/* { dg-final { scan-assembler \"vprotd\" } } */"}, {"sha": "9996279bc0f74fc466617955fdb686093621cd5f", "filename": "gcc/testsuite/gcc.target/i386/xop-rotate2-vector.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-rotate2-vector.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-rotate2-vector.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-rotate2-vector.c?ref=43a8b705906034ecb3edfb54558a34bd362a7213", "patch": "@@ -0,0 +1,35 @@\n+/* Test that the compiler properly optimizes vector rotate instructions vector\n+   into prot on XOP systems.  */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-O2 -mxop -ftree-vectorize\" } */\n+\n+extern void exit (int);\n+\n+typedef long __m128i  __attribute__ ((__vector_size__ (16), __may_alias__));\n+\n+#define SIZE 10240\n+\n+union {\n+  __m128i i_align;\n+  unsigned u32[SIZE];\n+} a, b, c;\n+\n+void\n+right_rotate32_b (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    a.u32[i] = (b.u32[i] >> ((sizeof (int) * 8) - 4)) | (b.u32[i] << 4);\n+}\n+\n+int\n+main ()\n+{\n+  right_rotate ();\n+  exit (0);\n+}\n+\n+/* { dg-final { scan-assembler \"vprot\" } } */"}, {"sha": "73d52f5f3f0c0229b04b72bf2a09c7c8acba0962", "filename": "gcc/testsuite/gcc.target/i386/xop-rotate3-vector.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-rotate3-vector.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-rotate3-vector.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-rotate3-vector.c?ref=43a8b705906034ecb3edfb54558a34bd362a7213", "patch": "@@ -0,0 +1,34 @@\n+/* Test that the compiler properly optimizes vector rotate instructions vector\n+   into prot on XOP systems.  */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-O2 -mxop -ftree-vectorize\" } */\n+\n+extern void exit (int);\n+\n+typedef long __m128i  __attribute__ ((__vector_size__ (16), __may_alias__));\n+\n+#define SIZE 10240\n+\n+union {\n+  __m128i i_align;\n+  unsigned u32[SIZE];\n+} a, b, c;\n+\n+void\n+vector_rotate32 (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    a.u32[i] = (b.u32[i] >> ((sizeof (int) * 8) - c.u32[i])) | (b.u32[i] << c.u32[i]);\n+}\n+\n+int main ()\n+{\n+  vector_rotate32 ();\n+  exit (0);\n+}\n+\n+/* { dg-final { scan-assembler \"vprotd\" } } */"}, {"sha": "eb84439c4969028a4d1d621e8c669fe75550e345", "filename": "gcc/testsuite/gcc.target/i386/xop-shift1-vector.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-shift1-vector.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-shift1-vector.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-shift1-vector.c?ref=43a8b705906034ecb3edfb54558a34bd362a7213", "patch": "@@ -0,0 +1,35 @@\n+/* Test that the compiler properly optimizes vector shift instructions into\n+   psha/pshl on XOP systems.  */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-O2 -mxop -ftree-vectorize\" } */\n+\n+extern void exit (int);\n+\n+typedef long __m128i  __attribute__ ((__vector_size__ (16), __may_alias__));\n+\n+#define SIZE 10240\n+\n+union {\n+  __m128i i_align;\n+  int i32[SIZE];\n+  unsigned u32[SIZE];\n+} a, b, c;\n+\n+void\n+left_shift32 (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    a.i32[i] = b.i32[i] << c.i32[i];\n+}\n+\n+int main ()\n+{\n+  left_shfit32 ();\n+  exit (0);\n+}\n+\n+/* { dg-final { scan-assembler \"vpshad\" } } */"}, {"sha": "e59c30d021b31335d3f61b517e9fc628c93d6933", "filename": "gcc/testsuite/gcc.target/i386/xop-shift2-vector.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-shift2-vector.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-shift2-vector.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-shift2-vector.c?ref=43a8b705906034ecb3edfb54558a34bd362a7213", "patch": "@@ -0,0 +1,35 @@\n+/* Test that the compiler properly optimizes vector shift instructions into\n+   psha/pshl on XOP systems.  */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-O2 -mxop -ftree-vectorize\" } */\n+\n+extern void exit (int);\n+\n+typedef long __m128i  __attribute__ ((__vector_size__ (16), __may_alias__));\n+\n+#define SIZE 10240\n+\n+union {\n+  __m128i i_align;\n+  int i32[SIZE];\n+  unsigned u32[SIZE];\n+} a, b, c;\n+\n+void\n+right_sign_shift32 (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    a.i32[i] = b.i32[i] >> c.i32[i];\n+}\n+\n+int main ()\n+{\n+  right_sign_shfit32 ();\n+  exit (0);\n+}\n+\n+/* { dg-final { scan-assembler \"vpshad\" } } */"}, {"sha": "2b9302db52d0a8f2ea7ed9f20f434ba14fcf914f", "filename": "gcc/testsuite/gcc.target/i386/xop-shift3-vector.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-shift3-vector.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a8b705906034ecb3edfb54558a34bd362a7213/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-shift3-vector.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-shift3-vector.c?ref=43a8b705906034ecb3edfb54558a34bd362a7213", "patch": "@@ -0,0 +1,35 @@\n+/* Test that the compiler properly optimizes vector shift instructions into\n+   psha/pshl on XOP systems.  */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-O2 -mxop -ftree-vectorize\" } */\n+\n+extern void exit (int);\n+\n+typedef long __m128i  __attribute__ ((__vector_size__ (16), __may_alias__));\n+\n+#define SIZE 10240\n+\n+union {\n+  __m128i i_align;\n+  int i32[SIZE];\n+  unsigned u32[SIZE];\n+} a, b, c;\n+\n+void\n+right_uns_shift32 (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    a.u32[i] = b.u32[i] >> c.i32[i];\n+}\n+\n+int main ()\n+{\n+  right_uns_shfit32 ();\n+  exit (0);\n+}\n+\n+/* { dg-final { scan-assembler \"vpshld\" } } */"}]}