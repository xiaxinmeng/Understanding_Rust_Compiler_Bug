{"sha": "7d76717db858244602657e6db4920115dae77e3e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Q3NjcxN2RiODU4MjQ0NjAyNjU3ZTZkYjQ5MjAxMTVkYWU3N2UzZQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2011-09-26T08:50:16Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-09-26T08:50:16Z"}, "message": "gigi.h (create_subprog_decl): Replace TREE_CHAIN with DECL_CHAIN in comment.\n\n\t* gcc-interface/gigi.h (create_subprog_decl): Replace TREE_CHAIN with\n\tDECL_CHAIN in comment.\n\t* gcc-interface/trans.c (gigi): Likewise.\n\t(Attribute_to_gnu): Likewise.\n\t(build_function_stub): Likewise.\n\t(gnat_to_gnu): Likewise.\n\t* gcc-interface/utils.c (create_subprog_decl): Likewise.\n\t(convert_vms_descriptor64): Likewise.\n\t(convert_vms_descriptor32): Likewise.\n\nFrom-SVN: r179185", "tree": {"sha": "692b0cdcd46705bd088e9c37ce0567309de053f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/692b0cdcd46705bd088e9c37ce0567309de053f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d76717db858244602657e6db4920115dae77e3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d76717db858244602657e6db4920115dae77e3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d76717db858244602657e6db4920115dae77e3e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d76717db858244602657e6db4920115dae77e3e/comments", "author": null, "committer": null, "parents": [{"sha": "42acad07c083eb1a0de24a8050febac46e3ae0fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42acad07c083eb1a0de24a8050febac46e3ae0fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42acad07c083eb1a0de24a8050febac46e3ae0fa"}], "stats": {"total": 50, "additions": 31, "deletions": 19}, "files": [{"sha": "b9b305191090b872a359fc8799e36d7b9b77112f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d76717db858244602657e6db4920115dae77e3e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d76717db858244602657e6db4920115dae77e3e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7d76717db858244602657e6db4920115dae77e3e", "patch": "@@ -1,3 +1,15 @@\n+2011-09-26  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/gigi.h (create_subprog_decl): Replace TREE_CHAIN with\n+\tDECL_CHAIN in comment.\n+\t* gcc-interface/trans.c (gigi): Likewise.\n+\t(Attribute_to_gnu): Likewise.\n+\t(build_function_stub): Likewise.\n+\t(gnat_to_gnu): Likewise.\n+\t* gcc-interface/utils.c (create_subprog_decl): Likewise.\n+\t(convert_vms_descriptor64): Likewise.\n+\t(convert_vms_descriptor32): Likewise.\n+\n 2011-09-26  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/trans.c (assoc_to_constructor): Minor tweaks."}, {"sha": "30fa99e96d57232c7ac9896df63308da385f407c", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d76717db858244602657e6db4920115dae77e3e/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d76717db858244602657e6db4920115dae77e3e/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=7d76717db858244602657e6db4920115dae77e3e", "patch": "@@ -671,7 +671,7 @@ extern tree create_label_decl (tree label_name);\n /* Return a FUNCTION_DECL node.  SUBPROG_NAME is the name of the subprogram,\n    ASM_NAME is its assembler name, SUBPROG_TYPE is its type (a FUNCTION_TYPE\n    node), PARAM_DECL_LIST is the list of the subprogram arguments (a list of\n-   PARM_DECL nodes chained through the TREE_CHAIN field).\n+   PARM_DECL nodes chained through the DECL_CHAIN field).\n \n    INLINE_FLAG, PUBLIC_FLAG, EXTERN_FLAG, ARTIFICIAL_FLAG and ATTR_LIST are\n    used to set the appropriate fields in the FUNCTION_DECL.  GNAT_NODE is"}, {"sha": "71e659e265fbde5a16150483187df91f2e7c495b", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d76717db858244602657e6db4920115dae77e3e/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d76717db858244602657e6db4920115dae77e3e/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=7d76717db858244602657e6db4920115dae77e3e", "patch": "@@ -540,7 +540,7 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n \t  tree field\n \t    = create_field_decl (NULL_TREE, ptr_void_ftype, fdesc_type_node,\n \t\t\t\t NULL_TREE, NULL_TREE, 0, 1);\n-\t  TREE_CHAIN (field) = field_list;\n+\t  DECL_CHAIN (field) = field_list;\n \t  field_list = field;\n \t  elt->index = field;\n \t  elt->value = null_node;\n@@ -1286,7 +1286,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t\t + TARGET_VTABLE_USES_DESCRIPTORS - 1);\n \t  for (gnu_field = TYPE_FIELDS (gnu_result_type), i = 0;\n \t       i < TARGET_VTABLE_USES_DESCRIPTORS;\n-\t       gnu_field = TREE_CHAIN (gnu_field), i++)\n+\t       gnu_field = DECL_CHAIN (gnu_field), i++)\n \t    {\n \t      if (build_descriptor)\n \t\t{\n@@ -1420,7 +1420,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t{\n \t  gnu_type = TYPE_OBJECT_RECORD_TYPE (gnu_type);\n \t  if (attribute != Attr_Max_Size_In_Storage_Elements)\n-\t    gnu_type = TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (gnu_type)));\n+\t    gnu_type = TREE_TYPE (DECL_CHAIN (TYPE_FIELDS (gnu_type)));\n \t}\n \n       /* If we're looking for the size of a field, return the field size.\n@@ -2567,8 +2567,8 @@ build_function_stub (tree gnu_subprog, Entity_Id gnat_subprog)\n   for (gnu_stub_param = DECL_ARGUMENTS (gnu_stub_decl),\n        gnu_subprog_param = DECL_ARGUMENTS (gnu_subprog);\n        gnu_stub_param;\n-       gnu_stub_param = TREE_CHAIN (gnu_stub_param),\n-       gnu_subprog_param = TREE_CHAIN (gnu_subprog_param))\n+       gnu_stub_param = DECL_CHAIN (gnu_stub_param),\n+       gnu_subprog_param = DECL_CHAIN (gnu_subprog_param))\n     {\n       if (DECL_BY_DESCRIPTOR_P (gnu_stub_param))\n \t{\n@@ -4695,7 +4695,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \tif (TREE_CODE (gnu_result_type) == RECORD_TYPE\n \t    && TYPE_CONTAINS_TEMPLATE_P (gnu_result_type))\n \t  gnu_aggr_type\n-\t    = TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (gnu_result_type)));\n+\t    = TREE_TYPE (DECL_CHAIN (TYPE_FIELDS (gnu_result_type)));\n \telse if (TREE_CODE (gnu_result_type) == VECTOR_TYPE)\n \t  gnu_aggr_type = TYPE_REPRESENTATIVE_ARRAY (gnu_result_type);\n "}, {"sha": "553ca3f2acd9f41ae05fb91f74e47d96c6eb8379", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d76717db858244602657e6db4920115dae77e3e/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d76717db858244602657e6db4920115dae77e3e/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=7d76717db858244602657e6db4920115dae77e3e", "patch": "@@ -1861,7 +1861,7 @@ create_label_decl (tree label_name)\n /* Return a FUNCTION_DECL node.  SUBPROG_NAME is the name of the subprogram,\n    ASM_NAME is its assembler name, SUBPROG_TYPE is its type (a FUNCTION_TYPE\n    node), PARAM_DECL_LIST is the list of the subprogram arguments (a list of\n-   PARM_DECL nodes chained through the TREE_CHAIN field).\n+   PARM_DECL nodes chained through the DECL_CHAIN field).\n \n    INLINE_FLAG, PUBLIC_FLAG, EXTERN_FLAG, ARTIFICIAL_FLAG and ATTR_LIST are\n    used to set the appropriate fields in the FUNCTION_DECL.  GNAT_NODE is\n@@ -3039,10 +3039,10 @@ convert_vms_descriptor64 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n   else if (TYPE_IS_FAT_POINTER_P (gnu_type))\n     {\n       tree p_array_type = TREE_TYPE (TYPE_FIELDS (gnu_type));\n-      tree p_bounds_type = TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (gnu_type)));\n+      tree p_bounds_type = TREE_TYPE (DECL_CHAIN (TYPE_FIELDS (gnu_type)));\n       tree template_type = TREE_TYPE (p_bounds_type);\n       tree min_field = TYPE_FIELDS (template_type);\n-      tree max_field = TREE_CHAIN (TYPE_FIELDS (template_type));\n+      tree max_field = DECL_CHAIN (TYPE_FIELDS (template_type));\n       tree template_tree, template_addr, aflags, dimct, t, u;\n       /* See the head comment of build_vms_descriptor.  */\n       int iklass = TREE_INT_CST_LOW (DECL_INITIAL (klass));\n@@ -3079,19 +3079,19 @@ convert_vms_descriptor64 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n \t  /* If so, there is already a template in the descriptor and\n \t     it is located right after the POINTER field.  The fields are\n              64bits so they must be repacked. */\n-\t  t = TREE_CHAIN (pointer);\n+\t  t = DECL_CHAIN (pointer);\n           lfield = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n           lfield = convert (TREE_TYPE (TYPE_FIELDS (template_type)), lfield);\n \n-\t  t = TREE_CHAIN (t);\n+\t  t = DECL_CHAIN (t);\n           ufield = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n           ufield = convert\n            (TREE_TYPE (DECL_CHAIN (TYPE_FIELDS (template_type))), ufield);\n \n \t  /* Build the template in the form of a constructor. */\n \t  v = VEC_alloc (constructor_elt, gc, 2);\n \t  CONSTRUCTOR_APPEND_ELT (v, TYPE_FIELDS (template_type), lfield);\n-\t  CONSTRUCTOR_APPEND_ELT (v, TREE_CHAIN (TYPE_FIELDS (template_type)),\n+\t  CONSTRUCTOR_APPEND_ELT (v, DECL_CHAIN (TYPE_FIELDS (template_type)),\n \t\t\t\t  ufield);\n \t  template_tree = gnat_build_constructor (template_type, v);\n \n@@ -3109,7 +3109,7 @@ convert_vms_descriptor64 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n \t  aflags = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n \t  /* The DIMCT field is the next field in the descriptor after\n              aflags.  */\n-\t  t = TREE_CHAIN (t);\n+\t  t = DECL_CHAIN (t);\n \t  dimct = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n \t  /* Raise CONSTRAINT_ERROR if either more than 1 dimension\n \t     or FL_COEFF or FL_BOUNDS not set.  */\n@@ -3131,7 +3131,7 @@ convert_vms_descriptor64 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n           lfield = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n           lfield = convert (TREE_TYPE (TYPE_FIELDS (template_type)), lfield);\n \n-\t  t = TREE_CHAIN (t);\n+\t  t = DECL_CHAIN (t);\n           ufield = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n           ufield = convert\n            (TREE_TYPE (DECL_CHAIN (TYPE_FIELDS (template_type))), ufield);\n@@ -3193,10 +3193,10 @@ convert_vms_descriptor32 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n   else if (TYPE_IS_FAT_POINTER_P (gnu_type))\n     {\n       tree p_array_type = TREE_TYPE (TYPE_FIELDS (gnu_type));\n-      tree p_bounds_type = TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (gnu_type)));\n+      tree p_bounds_type = TREE_TYPE (DECL_CHAIN (TYPE_FIELDS (gnu_type)));\n       tree template_type = TREE_TYPE (p_bounds_type);\n       tree min_field = TYPE_FIELDS (template_type);\n-      tree max_field = TREE_CHAIN (TYPE_FIELDS (template_type));\n+      tree max_field = DECL_CHAIN (TYPE_FIELDS (template_type));\n       tree template_tree, template_addr, aflags, dimct, t, u;\n       /* See the head comment of build_vms_descriptor.  */\n       int iklass = TREE_INT_CST_LOW (DECL_INITIAL (klass));\n@@ -3231,7 +3231,7 @@ convert_vms_descriptor32 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n \t  u = build_binary_op (EQ_EXPR, boolean_type_node, t, u);\n \t  /* If so, there is already a template in the descriptor and\n \t     it is located right after the POINTER field.  */\n-\t  t = TREE_CHAIN (pointer);\n+\t  t = DECL_CHAIN (pointer);\n \t  template_tree\n \t    = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n \t  /* Otherwise use the {1, LENGTH} template we build above.  */\n@@ -3246,7 +3246,7 @@ convert_vms_descriptor32 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n \t  t = DECL_CHAIN (DECL_CHAIN (DECL_CHAIN (pointer)));\n \t  aflags = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n \t  /* The DIMCT field is the 8th field in the descriptor.  */\n-\t  t = TREE_CHAIN (t);\n+\t  t = DECL_CHAIN (t);\n \t  dimct = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n \t  /* Raise CONSTRAINT_ERROR if either more than 1 dimension\n \t     or FL_COEFF or FL_BOUNDS not set.  */"}]}