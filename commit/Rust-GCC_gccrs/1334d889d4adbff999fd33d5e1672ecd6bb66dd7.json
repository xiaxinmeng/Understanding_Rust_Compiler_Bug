{"sha": "1334d889d4adbff999fd33d5e1672ecd6bb66dd7", "node_id": "C_kwDOANBUbNoAKDEzMzRkODg5ZDRhZGJmZjk5OWZkMzNkNWUxNjcyZWNkNmJiNjZkZDc", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-12-06T16:33:32Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-12-09T16:51:48Z"}, "message": "Refactor compute_objsize_r into helpers.\n\ngcc/ChangeLog:\n\n\t* pointer-query.cc (compute_objsize_r): Add an argument.\n\t(gimple_call_return_array): Pass a new argument to compute_objsize_r.\n\t(access_ref::merge_ref): Same.\n\t(access_ref::inform_access): Add an argument and use it.\n\t(access_data::access_data): Initialize new member.\n\t(handle_min_max_size): Pass a new argument to compute_objsize_r.\n\t(handle_decl): New function.\n\t(handle_array_ref): Pass a new argument to compute_objsize_r.\n\tAvoid incrementing deref.\n\t(set_component_ref_size): New function.\n\t(handle_component_ref): New function.\n\t(handle_mem_ref): Pass a new argument to compute_objsize_r.\n\tOnly increment deref after successfully computing object size.\n\t(handle_ssa_name): New function.\n\t(compute_objsize_r): Move code into helpers and call them.\n\t(compute_objsize): Pass a new argument to compute_objsize_r.\n\t* pointer-query.h (access_ref::inform_access): Add an argument.\n\t(access_data::ostype): New member.", "tree": {"sha": "ef670830f4e7b41174e060cfbcbace9f78bccd98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef670830f4e7b41174e060cfbcbace9f78bccd98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1334d889d4adbff999fd33d5e1672ecd6bb66dd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1334d889d4adbff999fd33d5e1672ecd6bb66dd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1334d889d4adbff999fd33d5e1672ecd6bb66dd7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1334d889d4adbff999fd33d5e1672ecd6bb66dd7/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10d185b9845ad96edf45d55ca066a0258d3c3f9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10d185b9845ad96edf45d55ca066a0258d3c3f9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10d185b9845ad96edf45d55ca066a0258d3c3f9a"}], "stats": {"total": 778, "additions": 423, "deletions": 355}, "files": [{"sha": "3f583110c71df2aba6037d18707319f102f0897c", "filename": "gcc/pointer-query.cc", "status": "modified", "additions": 420, "deletions": 354, "changes": 774, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1334d889d4adbff999fd33d5e1672ecd6bb66dd7/gcc%2Fpointer-query.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1334d889d4adbff999fd33d5e1672ecd6bb66dd7/gcc%2Fpointer-query.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpointer-query.cc?ref=1334d889d4adbff999fd33d5e1672ecd6bb66dd7", "patch": "@@ -43,7 +43,7 @@\n #include \"tree-ssanames.h\"\n #include \"target.h\"\n \n-static bool compute_objsize_r (tree, gimple *, int, access_ref *,\n+static bool compute_objsize_r (tree, gimple *, bool, int, access_ref *,\n \t\t\t       ssa_name_limit_t &, pointer_query *);\n \n /* Wrapper around the wide_int overload of get_range that accepts\n@@ -199,7 +199,7 @@ gimple_call_return_array (gimple *stmt, offset_int offrng[2], bool *past_end,\n \t       of the source object.  */\n \t    access_ref aref;\n \t    tree src = gimple_call_arg (stmt, 1);\n-\t    if (compute_objsize_r (src, stmt, 1, &aref, snlim, qry)\n+\t    if (compute_objsize_r (src, stmt, false, 1, &aref, snlim, qry)\n \t\t&& aref.sizrng[1] < offrng[1])\n \t      offrng[1] = aref.sizrng[1];\n \t  }\n@@ -233,7 +233,7 @@ gimple_call_return_array (gimple *stmt, offset_int offrng[2], bool *past_end,\n       {\n \taccess_ref aref;\n \ttree src = gimple_call_arg (stmt, 1);\n-\tif (compute_objsize_r (src, stmt, 1, &aref, snlim, qry))\n+\tif (compute_objsize_r (src, stmt, false, 1, &aref, snlim, qry))\n \t  offrng[1] = aref.sizrng[1] - 1;\n \telse\n \t  offrng[1] = HOST_WIDE_INT_M1U;\n@@ -258,7 +258,7 @@ gimple_call_return_array (gimple *stmt, offset_int offrng[2], bool *past_end,\n \t       of the source object.  */\n \t    access_ref aref;\n \t    tree src = gimple_call_arg (stmt, 1);\n-\t    if (compute_objsize_r (src, stmt, 1, &aref, snlim, qry)\n+\t    if (compute_objsize_r (src, stmt, false, 1, &aref, snlim, qry)\n \t\t&& aref.sizrng[1] < offrng[1])\n \t      offrng[1] = aref.sizrng[1];\n \t  }\n@@ -635,7 +635,7 @@ access_ref::merge_ref (vec<access_ref> *all_refs, tree arg, gimple *stmt,\n \t\t       ssa_name_limit_t &snlim, pointer_query &qry)\n {\n   access_ref aref;\n-  if (!compute_objsize_r (arg, stmt, ostype, &aref, snlim, &qry)\n+  if (!compute_objsize_r (arg, stmt, false, ostype, &aref, snlim, &qry)\n       || aref.sizrng[0] < 0)\n     /* This may be a PHI with all null pointer arguments.  */\n     return false;\n@@ -997,42 +997,45 @@ void access_ref::add_offset (const offset_int &min, const offset_int &max)\n    WRITE is set for a write access and clear for a read access.  */\n \n void\n-access_ref::inform_access (access_mode mode) const\n+access_ref::inform_access (access_mode mode, int ostype /* = 1 */) const\n {\n   const access_ref &aref = *this;\n   if (!aref.ref)\n     return;\n \n-  if (aref.phi ())\n+  if (phi ())\n     {\n       /* Set MAXREF to refer to the largest object and fill ALL_REFS\n \t with data for all objects referenced by the PHI arguments.  */\n       access_ref maxref;\n       auto_vec<access_ref> all_refs;\n-      if (!get_ref (&all_refs, &maxref))\n+      if (!get_ref (&all_refs, &maxref, ostype))\n \treturn;\n \n-      /* Except for MAXREF, the rest of the arguments' offsets need not\n-\t reflect one added to the PHI itself.  Determine the latter from\n-\t MAXREF on which the result is based.  */\n-      const offset_int orng[] =\n+      if (all_refs.length ())\n \t{\n-\t  offrng[0] - maxref.offrng[0],\n-\t  wi::smax (offrng[1] - maxref.offrng[1], offrng[0]),\n-\t};\n+\t  /* Except for MAXREF, the rest of the arguments' offsets need not\n+\t     reflect one added to the PHI itself.  Determine the latter from\n+\t     MAXREF on which the result is based.  */\n+\t  const offset_int orng[] =\n+\t    {\n+\t     offrng[0] - maxref.offrng[0],\n+\t     wi::smax (offrng[1] - maxref.offrng[1], offrng[0]),\n+\t    };\n \n-      /* Add the final PHI's offset to that of each of the arguments\n-\t and recurse to issue an inform message for it.  */\n-      for (unsigned i = 0; i != all_refs.length (); ++i)\n-\t{\n-\t  /* Skip any PHIs; those could lead to infinite recursion.  */\n-\t  if (all_refs[i].phi ())\n-\t    continue;\n+\t  /* Add the final PHI's offset to that of each of the arguments\n+\t     and recurse to issue an inform message for it.  */\n+\t  for (unsigned i = 0; i != all_refs.length (); ++i)\n+\t    {\n+\t      /* Skip any PHIs; those could lead to infinite recursion.  */\n+\t      if (all_refs[i].phi ())\n+\t\tcontinue;\n \n-\t  all_refs[i].add_offset (orng[0], orng[1]);\n-\t  all_refs[i].inform_access (mode);\n+\t      all_refs[i].add_offset (orng[0], orng[1]);\n+\t      all_refs[i].inform_access (mode, ostype);\n+\t    }\n+\t  return;\n \t}\n-      return;\n     }\n \n   /* Convert offset range and avoid including a zero range since it\n@@ -1244,7 +1247,7 @@ access_data::access_data (range_query *query, gimple *stmt, access_mode mode,\n \t\t\t  bool minwrite /* = false */,\n \t\t\t  tree maxread /* = NULL_TREE */,\n \t\t\t  bool minread /* = false */)\n-  : stmt (stmt), call (), dst (), src (), mode (mode)\n+  : stmt (stmt), call (), dst (), src (), mode (mode), ostype ()\n {\n   set_bound (dst_bndrng, maxwrite, minwrite, query, stmt);\n   set_bound (src_bndrng, maxread, minread, query, stmt);\n@@ -1257,7 +1260,7 @@ access_data::access_data (range_query *query, tree expr, access_mode mode,\n \t\t\t  bool minwrite /* = false */,\n \t\t\t  tree maxread /* = NULL_TREE */,\n \t\t\t  bool minread /* = false */)\n-  : stmt (), call (expr),  dst (), src (), mode (mode)\n+  : stmt (), call (expr),  dst (), src (), mode (mode), ostype ()\n {\n   set_bound (dst_bndrng, maxwrite, minwrite, query, stmt);\n   set_bound (src_bndrng, maxread, minread, query, stmt);\n@@ -1406,7 +1409,8 @@ pointer_query::get_ref (tree ptr, int ostype /* = 1 */) const\n    there or compute it and insert it into the cache if it's nonnonull.  */\n \n bool\n-pointer_query::get_ref (tree ptr, gimple *stmt, access_ref *pref, int ostype /* = 1 */)\n+pointer_query::get_ref (tree ptr, gimple *stmt, access_ref *pref,\n+\t\t\tint ostype /* = 1 */)\n {\n   const unsigned version\n     = TREE_CODE (ptr) == SSA_NAME ? SSA_NAME_VERSION (ptr) : 0;\n@@ -1606,7 +1610,7 @@ handle_min_max_size (tree ptr, int ostype, access_ref *pref,\n      for the expression.  */\n   access_ref aref[2] = { *pref, *pref };\n   tree arg1 = gimple_assign_rhs1 (stmt);\n-  if (!compute_objsize_r (arg1, stmt, ostype, &aref[0], snlim, qry))\n+  if (!compute_objsize_r (arg1, stmt, false, ostype, &aref[0], snlim, qry))\n     {\n       aref[0].base0 = false;\n       aref[0].offrng[0] = aref[0].offrng[1] = 0;\n@@ -1615,7 +1619,7 @@ handle_min_max_size (tree ptr, int ostype, access_ref *pref,\n     }\n \n   tree arg2 = gimple_assign_rhs2 (stmt);\n-  if (!compute_objsize_r (arg2, stmt, ostype, &aref[1], snlim, qry))\n+  if (!compute_objsize_r (arg2, stmt, false, ostype, &aref[1], snlim, qry))\n     {\n       aref[1].base0 = false;\n       aref[1].offrng[0] = aref[1].offrng[1] = 0;\n@@ -1678,6 +1682,46 @@ handle_min_max_size (tree ptr, int ostype, access_ref *pref,\n   return true;\n }\n \n+/* A helper of compute_objsize_r() to determine the size of a DECL.\n+   Return true on success and (possibly in the future) false on failure.  */\n+\n+static bool\n+handle_decl (tree decl, bool addr, access_ref *pref)\n+{\n+  tree decl_type = TREE_TYPE (decl);\n+\n+  pref->ref = decl;\n+\n+  /* Reset the offset in case it was set by a prior call and not\n+     cleared by the caller.  The offset is only adjusted after\n+     the identity of the object has been determined.  */\n+  pref->offrng[0] = pref->offrng[1] = 0;\n+\n+  if (!addr && POINTER_TYPE_P (decl_type))\n+    {\n+      /* Set the maximum size if the reference is to the pointer\n+\t itself (as opposed to what it points to), and clear\n+\t BASE0 since the offset isn't necessarily zero-based.  */\n+      pref->set_max_size_range ();\n+      pref->base0 = false;\n+      return true;\n+    }\n+\n+  /* Valid offsets into the object are nonnegative.  */\n+  pref->base0 = true;\n+\n+  if (tree size = decl_init_size (decl, false))\n+    if (TREE_CODE (size) == INTEGER_CST)\n+      {\n+\tpref->sizrng[0] = wi::to_offset (size);\n+\tpref->sizrng[1] = pref->sizrng[0];\n+\treturn true;\n+      }\n+\n+  pref->set_max_size_range ();\n+  return true;\n+}\n+\n /* A helper of compute_objsize_r() to determine the size from ARRAY_REF\n    AREF.  ADDR is true if PTR is the operand of ADDR_EXPR.  Return true\n    on success and false on failure.  */\n@@ -1689,16 +1733,14 @@ handle_array_ref (tree aref, gimple *stmt, bool addr, int ostype,\n {\n   gcc_assert (TREE_CODE (aref) == ARRAY_REF);\n \n-  ++pref->deref;\n-\n   tree arefop = TREE_OPERAND (aref, 0);\n   tree reftype = TREE_TYPE (arefop);\n   if (!addr && TREE_CODE (TREE_TYPE (reftype)) == POINTER_TYPE)\n     /* Avoid arrays of pointers.  FIXME: Hande pointers to arrays\n        of known bound.  */\n     return false;\n \n-  if (!compute_objsize_r (arefop, stmt, ostype, pref, snlim, qry))\n+  if (!compute_objsize_r (arefop, stmt, addr, ostype, pref, snlim, qry))\n     return false;\n \n   offset_int orng[2];\n@@ -1759,6 +1801,96 @@ handle_array_ref (tree aref, gimple *stmt, bool addr, int ostype,\n   return true;\n }\n \n+/* Given a COMPONENT_REF CREF, set *PREF size to the size of the referenced\n+   member.  */\n+\n+static void\n+set_component_ref_size (tree cref, access_ref *pref)\n+{\n+  const tree base = TREE_OPERAND (cref, 0);\n+  const tree base_type = TREE_TYPE (base);\n+\n+  /* SAM is set for array members that might need special treatment.  */\n+  special_array_member sam;\n+  tree size = component_ref_size (cref, &sam);\n+  if (sam == special_array_member::int_0)\n+    pref->sizrng[0] = pref->sizrng[1] = 0;\n+  else if (!pref->trail1special && sam == special_array_member::trail_1)\n+    pref->sizrng[0] = pref->sizrng[1] = 1;\n+  else if (size && TREE_CODE (size) == INTEGER_CST)\n+    pref->sizrng[0] = pref->sizrng[1] = wi::to_offset (size);\n+  else\n+    {\n+      /* When the size of the member is unknown it's either a flexible\n+\t array member or a trailing special array member (either zero\n+\t length or one-element).  Set the size to the maximum minus\n+\t the constant size of the base object's type.  */\n+      pref->sizrng[0] = 0;\n+      pref->sizrng[1] = wi::to_offset (TYPE_MAX_VALUE (ptrdiff_type_node));\n+      if (tree base_size = TYPE_SIZE_UNIT (base_type))\n+\tif (TREE_CODE (base_size) == INTEGER_CST)\n+\t  pref->sizrng[1] -= wi::to_offset (base_size);\n+    }\n+}\n+\n+/* A helper of compute_objsize_r() to determine the size from COMPONENT_REF\n+   CREF.  Return true on success and false on failure.  */\n+\n+static bool\n+handle_component_ref (tree cref, gimple *stmt, bool addr, int ostype,\n+\t\t      access_ref *pref, ssa_name_limit_t &snlim,\n+\t\t      pointer_query *qry)\n+{\n+  gcc_assert (TREE_CODE (cref) == COMPONENT_REF);\n+\n+  const tree base = TREE_OPERAND (cref, 0);\n+  const tree base_type = TREE_TYPE (base);\n+  if (TREE_CODE (base_type) == UNION_TYPE)\n+    /* In accesses through union types consider the entire unions\n+       rather than just their members.  */\n+    ostype = 0;\n+\n+  tree field = TREE_OPERAND (cref, 1);\n+\n+  if (ostype == 0)\n+    {\n+      /* In OSTYPE zero (for raw memory functions like memcpy), use\n+\t the maximum size instead if the identity of the enclosing\n+\t object cannot be determined.  */\n+      if (!compute_objsize_r (base, stmt, addr, ostype, pref, snlim, qry))\n+\treturn false;\n+\n+      /* Otherwise, use the size of the enclosing object and add\n+\t the offset of the member to the offset computed so far.  */\n+      tree offset = byte_position (field);\n+      if (TREE_CODE (offset) == INTEGER_CST)\n+\tpref->add_offset (wi::to_offset (offset));\n+      else\n+\tpref->add_max_offset ();\n+\n+      if (!pref->ref)\n+\t/* PREF->REF may have been already set to an SSA_NAME earlier\n+\t   to provide better context for diagnostics.  In that case,\n+\t   leave it unchanged.  */\n+\tpref->ref = base;\n+\n+      return true;\n+    }\n+\n+  pref->ref = field;\n+\n+  if (!addr && POINTER_TYPE_P (TREE_TYPE (field)))\n+    {\n+      /* Set maximum size if the reference is to the pointer member\n+\t itself (as opposed to what it points to).  */\n+      pref->set_max_size_range ();\n+      return true;\n+    }\n+\n+  set_component_ref_size (cref, pref);\n+  return true;\n+}\n+\n /* A helper of compute_objsize_r() to determine the size from MEM_REF\n    MREF.  Return true on success and false on failure.  */\n \n@@ -1768,10 +1900,9 @@ handle_mem_ref (tree mref, gimple *stmt, int ostype, access_ref *pref,\n {\n   gcc_assert (TREE_CODE (mref) == MEM_REF);\n \n-  ++pref->deref;\n-\n-  if (VECTOR_TYPE_P (TREE_TYPE (mref)))\n-    {\n+  tree mreftype = TYPE_MAIN_VARIANT (TREE_TYPE (mref));\n+  if (VECTOR_TYPE_P (mreftype))\n+      {\n       /* Hack: Handle MEM_REFs of vector types as those to complete\n \t objects; those may be synthesized from multiple assignments\n \t to consecutive data members (see PR 93200 and 96963).\n@@ -1785,9 +1916,11 @@ handle_mem_ref (tree mref, gimple *stmt, int ostype, access_ref *pref,\n     }\n \n   tree mrefop = TREE_OPERAND (mref, 0);\n-  if (!compute_objsize_r (mrefop, stmt, ostype, pref, snlim, qry))\n+  if (!compute_objsize_r (mrefop, stmt, false, ostype, pref, snlim, qry))\n     return false;\n \n+  ++pref->deref;\n+\n   offset_int orng[2];\n   tree off = pref->eval (TREE_OPERAND (mref, 1));\n   range_query *const rvals = qry ? qry->rvals : NULL;\n@@ -1802,168 +1935,283 @@ handle_mem_ref (tree mref, gimple *stmt, int ostype, access_ref *pref,\n   return true;\n }\n \n-/* Helper to compute the size of the object referenced by the PTR\n-   expression which must have pointer type, using Object Size type\n-   OSTYPE (only the least significant 2 bits are used).\n-   On success, sets PREF->REF to the DECL of the referenced object\n-   if it's unique, otherwise to null, PREF->OFFRNG to the range of\n-   offsets into it, and PREF->SIZRNG to the range of sizes of\n-   the object(s).\n-   SNLIM is used to avoid visiting the same PHI operand multiple\n-   times, and, when nonnull, RVALS to determine range information.\n-   Returns true on success, false when a meaningful size (or range)\n-   cannot be determined.\n-\n-   The function is intended for diagnostics and should not be used\n-   to influence code generation or optimization.  */\n+/* A helper of compute_objsize_r() to determine the size from SSA_NAME\n+   PTR.  Return true on success and false on failure.  */\n \n static bool\n-compute_objsize_r (tree ptr, gimple *stmt, int ostype, access_ref *pref,\n-\t\t   ssa_name_limit_t &snlim, pointer_query *qry)\n+handle_ssa_name (tree ptr, bool addr, int ostype,\n+\t\t access_ref *pref, ssa_name_limit_t &snlim,\n+\t\t pointer_query *qry)\n {\n-  STRIP_NOPS (ptr);\n+  if (!snlim.next ())\n+    return false;\n \n-  const bool addr = TREE_CODE (ptr) == ADDR_EXPR;\n-  if (addr)\n+  /* Only process an SSA_NAME if the recursion limit has not yet\n+     been reached.  */\n+  if (qry)\n     {\n-      --pref->deref;\n-      ptr = TREE_OPERAND (ptr, 0);\n+      if (++qry->depth > qry->max_depth)\n+\tqry->max_depth = qry->depth;\n+      if (const access_ref *cache_ref = qry->get_ref (ptr, ostype))\n+\t{\n+\t  /* Add the number of DEREFerences accummulated so far.  */\n+\t  const int deref = pref->deref;\n+\t  *pref = *cache_ref;\n+\t  pref->deref += deref;\n+\t  return true;\n+\t}\n     }\n \n-  if (DECL_P (ptr))\n-    {\n-      pref->ref = ptr;\n-\n-      /* Reset the offset in case it was set by a prior call and not\n-\t cleared by the caller.  The offset is only adjusted after\n-\t the identity of the object has been determined.  */\n-      pref->offrng[0] = pref->offrng[1] = 0;\n+  gimple *stmt = SSA_NAME_DEF_STMT (ptr);\n+  if (is_gimple_call (stmt))\n+    {\n+      /* If STMT is a call to an allocation function get the size\n+\t from its argument(s).  If successful, also set *PREF->REF\n+\t to PTR for the caller to include in diagnostics.  */\n+      wide_int wr[2];\n+      range_query *const rvals = qry ? qry->rvals : NULL;\n+      if (gimple_call_alloc_size (stmt, wr, rvals))\n+\t{\n+\t  pref->ref = ptr;\n+\t  pref->sizrng[0] = offset_int::from (wr[0], UNSIGNED);\n+\t  pref->sizrng[1] = offset_int::from (wr[1], UNSIGNED);\n+\t  /* Constrain both bounds to a valid size.  */\n+\t  offset_int maxsize = wi::to_offset (max_object_size ());\n+\t  if (pref->sizrng[0] > maxsize)\n+\t    pref->sizrng[0] = maxsize;\n+\t  if (pref->sizrng[1] > maxsize)\n+\t    pref->sizrng[1] = maxsize;\n+\t}\n+      else\n+\t{\n+\t  /* For functions known to return one of their pointer arguments\n+\t     try to determine what the returned pointer points to, and on\n+\t     success add OFFRNG which was set to the offset added by\n+\t     the function (e.g., memchr) to the overall offset.  */\n+\t  bool past_end;\n+\t  offset_int offrng[2];\n+\t  if (tree ret = gimple_call_return_array (stmt, offrng, &past_end,\n+\t\t\t\t\t\t   snlim, qry))\n+\t    {\n+\t      if (!compute_objsize_r (ret, stmt, addr, ostype, pref, snlim, qry))\n+\t\treturn false;\n+\n+\t      /* Cap OFFRNG[1] to at most the remaining size of\n+\t\t the object.  */\n+\t      offset_int remrng[2];\n+\t      remrng[1] = pref->size_remaining (remrng);\n+\t      if (remrng[1] != 0 && !past_end)\n+\t\t/* Decrement the size for functions that never return\n+\t\t   a past-the-end pointer.  */\n+\t\tremrng[1] -= 1;\n+\n+\t      if (remrng[1] < offrng[1])\n+\t\toffrng[1] = remrng[1];\n+\t      pref->add_offset (offrng[0], offrng[1]);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* For other calls that might return arbitrary pointers\n+\t\t including into the middle of objects set the size\n+\t\t range to maximum, clear PREF->BASE0, and also set\n+\t\t PREF->REF to include in diagnostics.  */\n+\t      pref->set_max_size_range ();\n+\t      pref->base0 = false;\n+\t      pref->ref = ptr;\n+\t    }\n+\t}\n+      qry->put_ref (ptr, *pref, ostype);\n+      return true;\n+    }\n \n-      if (!addr && POINTER_TYPE_P (TREE_TYPE (ptr)))\n+  if (gimple_nop_p (stmt))\n+    {\n+      /* For a function argument try to determine the byte size\n+\t of the array from the current function declaratation\n+\t (e.g., attribute access or related).  */\n+      wide_int wr[2];\n+      bool static_array = false;\n+      if (tree ref = gimple_parm_array_size (ptr, wr, &static_array))\n \t{\n-\t  /* Set the maximum size if the reference is to the pointer\n-\t     itself (as opposed to what it points to), and clear\n-\t     BASE0 since the offset isn't necessarily zero-based.  */\n-\t  pref->set_max_size_range ();\n-\t  pref->base0 = false;\n+\t  pref->parmarray = !static_array;\n+\t  pref->sizrng[0] = offset_int::from (wr[0], UNSIGNED);\n+\t  pref->sizrng[1] = offset_int::from (wr[1], UNSIGNED);\n+\t  pref->ref = ref;\n+\t  qry->put_ref (ptr, *pref, ostype);\n \t  return true;\n \t}\n \n-      /* Valid offsets into the object are nonnegative.  */\n-      pref->base0 = true;\n-\n-      if (tree size = decl_init_size (ptr, false))\n-\tif (TREE_CODE (size) == INTEGER_CST)\n-\t  {\n-\t    pref->sizrng[0] = pref->sizrng[1] = wi::to_offset (size);\n-\t    return true;\n-\t  }\n-\n       pref->set_max_size_range ();\n+      pref->base0 = false;\n+      pref->ref = ptr;\n+      qry->put_ref (ptr, *pref, ostype);\n       return true;\n     }\n \n-  const tree_code code = TREE_CODE (ptr);\n-  range_query *const rvals = qry ? qry->rvals : NULL;\n-\n-  if (code == BIT_FIELD_REF)\n+  if (gimple_code (stmt) == GIMPLE_PHI)\n     {\n-      tree ref = TREE_OPERAND (ptr, 0);\n-      if (!compute_objsize_r (ref, stmt, ostype, pref, snlim, qry))\n+      /* Pass PTR to get_ref() via PREF.  If all PHI arguments refer\n+\t to the same object the function will replace it with it.  */\n+      pref->ref = ptr;\n+      access_ref phi_ref = *pref;\n+      if (!pref->get_ref (NULL, &phi_ref, ostype, &snlim, qry))\n \treturn false;\n+      *pref = phi_ref;\n+      qry->put_ref (ptr, *pref, ostype);\n+      return true;\n+    }\n \n-      offset_int off = wi::to_offset (pref->eval (TREE_OPERAND (ptr, 2)));\n-      pref->add_offset (off / BITS_PER_UNIT);\n+  if (!is_gimple_assign (stmt))\n+    {\n+      /* Clear BASE0 since the assigned pointer might point into\n+\t the middle of the object, set the maximum size range and,\n+\t if the SSA_NAME refers to a function argumnent, set\n+\t PREF->REF to it.  */\n+      pref->base0 = false;\n+      pref->set_max_size_range ();\n+      pref->ref = ptr;\n       return true;\n     }\n \n-  if (code == COMPONENT_REF)\n+  tree_code code = gimple_assign_rhs_code (stmt);\n+\n+  if (code == MAX_EXPR || code == MIN_EXPR)\n     {\n-      tree ref = TREE_OPERAND (ptr, 0);\n-      if (TREE_CODE (TREE_TYPE (ref)) == UNION_TYPE)\n-\t/* In accesses through union types consider the entire unions\n-\t   rather than just their members.  */\n-\tostype = 0;\n-      tree field = TREE_OPERAND (ptr, 1);\n+      if (!handle_min_max_size (ptr, ostype, pref, snlim, qry))\n+\treturn false;\n \n-      if (ostype == 0)\n-\t{\n-\t  /* In OSTYPE zero (for raw memory functions like memcpy), use\n-\t     the maximum size instead if the identity of the enclosing\n-\t     object cannot be determined.  */\n-\t  if (!compute_objsize_r (ref, stmt, ostype, pref, snlim, qry))\n-\t    return false;\n-\n-\t  /* Otherwise, use the size of the enclosing object and add\n-\t     the offset of the member to the offset computed so far.  */\n-\t  tree offset = byte_position (field);\n-\t  if (TREE_CODE (offset) == INTEGER_CST)\n-\t    pref->add_offset (wi::to_offset (offset));\n-\t  else\n-\t    pref->add_max_offset ();\n+      qry->put_ref (ptr, *pref, ostype);\n+      return true;\n+    }\n \n-\t  if (!pref->ref)\n-\t    /* REF may have been already set to an SSA_NAME earlier\n-\t       to provide better context for diagnostics.  In that case,\n-\t       leave it unchanged.  */\n-\t    pref->ref = ref;\n-\t  return true;\n-\t}\n+  tree rhs = gimple_assign_rhs1 (stmt);\n \n-      pref->ref = field;\n+  if (code == ASSERT_EXPR)\n+    {\n+      rhs = TREE_OPERAND (rhs, 0);\n+      return compute_objsize_r (rhs, stmt, addr, ostype, pref, snlim, qry);\n+    }\n \n-      if (!addr && POINTER_TYPE_P (TREE_TYPE (field)))\n-\t{\n-\t  /* Set maximum size if the reference is to the pointer member\n-\t     itself (as opposed to what it points to).  */\n-\t  pref->set_max_size_range ();\n-\t  return true;\n-\t}\n+  if (code == POINTER_PLUS_EXPR\n+      && TREE_CODE (TREE_TYPE (rhs)) == POINTER_TYPE)\n+    {\n+      /* Compute the size of the object first. */\n+      if (!compute_objsize_r (rhs, stmt, addr, ostype, pref, snlim, qry))\n+\treturn false;\n \n-      /* SAM is set for array members that might need special treatment.  */\n-      special_array_member sam;\n-      tree size = component_ref_size (ptr, &sam);\n-      if (sam == special_array_member::int_0)\n-\tpref->sizrng[0] = pref->sizrng[1] = 0;\n-      else if (!pref->trail1special && sam == special_array_member::trail_1)\n-\tpref->sizrng[0] = pref->sizrng[1] = 1;\n-      else if (size && TREE_CODE (size) == INTEGER_CST)\n-\tpref->sizrng[0] = pref->sizrng[1] = wi::to_offset (size);\n+      offset_int orng[2];\n+      tree off = gimple_assign_rhs2 (stmt);\n+      range_query *const rvals = qry ? qry->rvals : NULL;\n+      if (get_offset_range (off, stmt, orng, rvals))\n+\tpref->add_offset (orng[0], orng[1]);\n       else\n-\t{\n-\t  /* When the size of the member is unknown it's either a flexible\n-\t     array member or a trailing special array member (either zero\n-\t     length or one-element).  Set the size to the maximum minus\n-\t     the constant size of the type.  */\n-\t  pref->sizrng[0] = 0;\n-\t  pref->sizrng[1] = wi::to_offset (TYPE_MAX_VALUE (ptrdiff_type_node));\n-\t  if (tree recsize = TYPE_SIZE_UNIT (TREE_TYPE (ref)))\n-\t    if (TREE_CODE (recsize) == INTEGER_CST)\n-\t      pref->sizrng[1] -= wi::to_offset (recsize);\n-\t}\n+\tpref->add_max_offset ();\n+\n+      qry->put_ref (ptr, *pref, ostype);\n       return true;\n     }\n \n-  if (code == ARRAY_REF)\n-    return handle_array_ref (ptr, stmt, addr, ostype, pref, snlim, qry);\n-\n-  if (code == MEM_REF)\n-    return handle_mem_ref (ptr, stmt, ostype, pref, snlim, qry);\n+  if (code == ADDR_EXPR || code == SSA_NAME)\n+    {\n+      if (!compute_objsize_r (rhs, stmt, addr, ostype, pref, snlim, qry))\n+\treturn false;\n+      qry->put_ref (ptr, *pref, ostype);\n+      return true;\n+    }\n \n-  if (code == TARGET_MEM_REF)\n+  if (ostype > 1 && POINTER_TYPE_P (TREE_TYPE (rhs)))\n     {\n-      tree ref = TREE_OPERAND (ptr, 0);\n-      if (!compute_objsize_r (ref, stmt, ostype, pref, snlim, qry))\n+      /* When determining the qualifiers follow the pointer but\n+\t avoid caching the result.  As the pointer is added to\n+\t and/or dereferenced the computed size and offset need\n+\t not be meaningful for other queries involving the same\n+\t pointer.  */\n+      if (!compute_objsize_r (rhs, stmt, addr, ostype, pref, snlim, qry))\n \treturn false;\n \n-      /* TODO: Handle remaining operands.  Until then, add maximum offset.  */\n-      pref->ref = ptr;\n-      pref->add_max_offset ();\n-      return true;\n+      rhs = pref->ref;\n     }\n \n-  if (code == INTEGER_CST)\n+  /* (This could also be an assignment from a nonlocal pointer.)  Save\n+     PTR to mention in diagnostics but otherwise treat it as a pointer\n+     to an unknown object.  */\n+  pref->ref = rhs;\n+  pref->base0 = false;\n+  pref->set_max_size_range ();\n+  return true;\n+}\n+\n+/* Helper to compute the size of the object referenced by the PTR\n+   expression which must have pointer type, using Object Size type\n+   OSTYPE (only the least significant 2 bits are used).\n+   On success, sets PREF->REF to the DECL of the referenced object\n+   if it's unique, otherwise to null, PREF->OFFRNG to the range of\n+   offsets into it, and PREF->SIZRNG to the range of sizes of\n+   the object(s).\n+   ADDR is true for an enclosing ADDR_EXPR.\n+   SNLIM is used to avoid visiting the same PHI operand multiple\n+   times, and, when nonnull, RVALS to determine range information.\n+   Returns true on success, false when a meaningful size (or range)\n+   cannot be determined.\n+\n+   The function is intended for diagnostics and should not be used\n+   to influence code generation or optimization.  */\n+\n+static bool\n+compute_objsize_r (tree ptr, gimple *stmt, bool addr, int ostype,\n+\t\t   access_ref *pref, ssa_name_limit_t &snlim,\n+\t\t   pointer_query *qry)\n+{\n+  STRIP_NOPS (ptr);\n+\n+  if (DECL_P (ptr))\n+    return handle_decl (ptr, addr, pref);\n+\n+  switch (TREE_CODE (ptr))\n     {\n+    case ADDR_EXPR:\n+      {\n+\ttree ref = TREE_OPERAND (ptr, 0);\n+\tif (!compute_objsize_r (ref, stmt, true, ostype, pref, snlim, qry))\n+\t  return false;\n+\n+\t--pref->deref;\n+\treturn true;\n+      }\n+\n+    case BIT_FIELD_REF:\n+      {\n+\ttree ref = TREE_OPERAND (ptr, 0);\n+\tif (!compute_objsize_r (ref, stmt, addr, ostype, pref, snlim, qry))\n+\t  return false;\n+\n+\toffset_int off = wi::to_offset (pref->eval (TREE_OPERAND (ptr, 2)));\n+\tpref->add_offset (off / BITS_PER_UNIT);\n+\treturn true;\n+      }\n+\n+    case ARRAY_REF:\n+\treturn handle_array_ref (ptr, stmt, addr, ostype, pref, snlim, qry);\n+\n+    case COMPONENT_REF:\n+      return handle_component_ref (ptr, stmt, addr, ostype, pref, snlim, qry);\n+\n+    case MEM_REF:\n+      return handle_mem_ref (ptr, stmt, ostype, pref, snlim, qry);\n+\n+    case TARGET_MEM_REF:\n+      {\n+\ttree ref = TREE_OPERAND (ptr, 0);\n+\tif (!compute_objsize_r (ref, stmt, addr, ostype, pref, snlim, qry))\n+\t  return false;\n+\n+\t/* TODO: Handle remaining operands.  Until then, add maximum offset.  */\n+\tpref->ref = ptr;\n+\tpref->add_max_offset ();\n+\treturn true;\n+      }\n+\n+    case INTEGER_CST:\n       /* Pointer constants other than null are most likely the result\n \t of erroneous null pointer addition/subtraction.  Unless zero\n \t is a valid address set size to zero.  For null pointers, set\n@@ -1984,21 +2232,17 @@ compute_objsize_r (tree ptr, gimple *stmt, int ostype, access_ref *pref,\n \tpref->sizrng[0] = pref->sizrng[1] = 0;\n \n       pref->ref = ptr;\n-\n       return true;\n-    }\n \n-  if (code == STRING_CST)\n-    {\n+    case STRING_CST:\n       pref->sizrng[0] = pref->sizrng[1] = TREE_STRING_LENGTH (ptr);\n       pref->ref = ptr;\n       return true;\n-    }\n \n-  if (code == POINTER_PLUS_EXPR)\n+    case POINTER_PLUS_EXPR:\n     {\n       tree ref = TREE_OPERAND (ptr, 0);\n-      if (!compute_objsize_r (ref, stmt, ostype, pref, snlim, qry))\n+      if (!compute_objsize_r (ref, stmt, addr, ostype, pref, snlim, qry))\n \treturn false;\n \n       /* Clear DEREF since the offset is being applied to the target\n@@ -2007,200 +2251,22 @@ compute_objsize_r (tree ptr, gimple *stmt, int ostype, access_ref *pref,\n \n       offset_int orng[2];\n       tree off = pref->eval (TREE_OPERAND (ptr, 1));\n-      if (get_offset_range (off, stmt, orng, rvals))\n+      if (get_offset_range (off, stmt, orng, qry->rvals))\n \tpref->add_offset (orng[0], orng[1]);\n       else\n \tpref->add_max_offset ();\n       return true;\n     }\n \n-  if (code == VIEW_CONVERT_EXPR)\n-    {\n+    case VIEW_CONVERT_EXPR:\n       ptr = TREE_OPERAND (ptr, 0);\n-      return compute_objsize_r (ptr, stmt, ostype, pref, snlim, qry);\n-    }\n+      return compute_objsize_r (ptr, stmt, addr, ostype, pref, snlim, qry);\n \n-  if (code == SSA_NAME)\n-    {\n-      if (!snlim.next ())\n-\treturn false;\n+    case SSA_NAME:\n+      return handle_ssa_name (ptr, addr, ostype, pref, snlim, qry);\n \n-      /* Only process an SSA_NAME if the recursion limit has not yet\n-\t been reached.  */\n-      if (qry)\n-\t{\n-\t  if (++qry->depth)\n-\t    qry->max_depth = qry->depth;\n-\t  if (const access_ref *cache_ref = qry->get_ref (ptr))\n-\t    {\n-\t      /* If the pointer is in the cache set *PREF to what it refers\n-\t\t to and return success.  */\n-\t      *pref = *cache_ref;\n-\t      return true;\n-\t    }\n-\t}\n-\n-      stmt = SSA_NAME_DEF_STMT (ptr);\n-      if (is_gimple_call (stmt))\n-\t{\n-\t  /* If STMT is a call to an allocation function get the size\n-\t     from its argument(s).  If successful, also set *PREF->REF\n-\t     to PTR for the caller to include in diagnostics.  */\n-\t  wide_int wr[2];\n-\t  if (gimple_call_alloc_size (stmt, wr, rvals))\n-\t    {\n-\t      pref->ref = ptr;\n-\t      pref->sizrng[0] = offset_int::from (wr[0], UNSIGNED);\n-\t      pref->sizrng[1] = offset_int::from (wr[1], UNSIGNED);\n-\t      /* Constrain both bounds to a valid size.  */\n-\t      offset_int maxsize = wi::to_offset (max_object_size ());\n-\t      if (pref->sizrng[0] > maxsize)\n-\t\tpref->sizrng[0] = maxsize;\n-\t      if (pref->sizrng[1] > maxsize)\n-\t\tpref->sizrng[1] = maxsize;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* For functions known to return one of their pointer arguments\n-\t\t try to determine what the returned pointer points to, and on\n-\t\t success add OFFRNG which was set to the offset added by\n-\t\t the function (e.g., memchr) to the overall offset.  */\n-\t      bool past_end;\n-\t      offset_int offrng[2];\n-\t      if (tree ret = gimple_call_return_array (stmt, offrng,\n-\t\t\t\t\t\t       &past_end, snlim, qry))\n-\t\t{\n-\t\t  if (!compute_objsize_r (ret, stmt, ostype, pref, snlim, qry))\n-\t\t    return false;\n-\n-\t\t  /* Cap OFFRNG[1] to at most the remaining size of\n-\t\t     the object.  */\n-\t\t  offset_int remrng[2];\n-\t\t  remrng[1] = pref->size_remaining (remrng);\n-\t\t  if (remrng[1] != 0 && !past_end)\n-\t\t    /* Decrement the size for functions that never return\n-\t\t       a past-the-end pointer.  */\n-\t\t    remrng[1] -= 1;\n-\n-\t\t  if (remrng[1] < offrng[1])\n-\t\t    offrng[1] = remrng[1];\n-\t\t  pref->add_offset (offrng[0], offrng[1]);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  /* For other calls that might return arbitrary pointers\n-\t\t     including into the middle of objects set the size\n-\t\t     range to maximum, clear PREF->BASE0, and also set\n-\t\t     PREF->REF to include in diagnostics.  */\n-\t\t  pref->set_max_size_range ();\n-\t\t  pref->base0 = false;\n-\t\t  pref->ref = ptr;\n-\t\t}\n-\t    }\n-\t  qry->put_ref (ptr, *pref);\n-\t  return true;\n-\t}\n-\n-      if (gimple_nop_p (stmt))\n-\t{\n-\t  /* For a function argument try to determine the byte size\n-\t     of the array from the current function declaratation\n-\t     (e.g., attribute access or related).  */\n-\t  wide_int wr[2];\n-\t  bool static_array = false;\n-\t  if (tree ref = gimple_parm_array_size (ptr, wr, &static_array))\n-\t    {\n-\t      pref->parmarray = !static_array;\n-\t      pref->sizrng[0] = offset_int::from (wr[0], UNSIGNED);\n-\t      pref->sizrng[1] = offset_int::from (wr[1], UNSIGNED);\n-\t      pref->ref = ref;\n-\t      qry->put_ref (ptr, *pref);\n-\t      return true;\n-\t    }\n-\n-\t  pref->set_max_size_range ();\n-\t  pref->base0 = false;\n-\t  pref->ref = ptr;\n-\t  qry->put_ref (ptr, *pref);\n-\t  return true;\n-\t}\n-\n-      if (gimple_code (stmt) == GIMPLE_PHI)\n-\t{\n-\t  pref->ref = ptr;\n-\t  access_ref phi_ref = *pref;\n-\t  if (!pref->get_ref (NULL, &phi_ref, ostype, &snlim, qry))\n-\t    return false;\n-\t  *pref = phi_ref;\n-\t  pref->ref = ptr;\n-\t  qry->put_ref (ptr, *pref);\n-\t  return true;\n-\t}\n-\n-      if (!is_gimple_assign (stmt))\n-\t{\n-\t  /* Clear BASE0 since the assigned pointer might point into\n-\t     the middle of the object, set the maximum size range and,\n-\t     if the SSA_NAME refers to a function argumnent, set\n-\t     PREF->REF to it.  */\n-\t  pref->base0 = false;\n-\t  pref->set_max_size_range ();\n-\t  pref->ref = ptr;\n-\t  return true;\n-\t}\n-\n-      tree_code code = gimple_assign_rhs_code (stmt);\n-\n-      if (code == MAX_EXPR || code == MIN_EXPR)\n-\t{\n-\t  if (!handle_min_max_size (ptr, ostype, pref, snlim, qry))\n-\t    return false;\n-\n-\t  qry->put_ref (ptr, *pref);\n-\t  return true;\n-\t}\n-\n-      tree rhs = gimple_assign_rhs1 (stmt);\n-\n-      if (code == ASSERT_EXPR)\n-\t{\n-\t  rhs = TREE_OPERAND (rhs, 0);\n-\t  return compute_objsize_r (rhs, stmt, ostype, pref, snlim, qry);\n-\t}\n-\n-      if (code == POINTER_PLUS_EXPR\n-\t  && TREE_CODE (TREE_TYPE (rhs)) == POINTER_TYPE)\n-\t{\n-\t  /* Compute the size of the object first. */\n-\t  if (!compute_objsize_r (rhs, stmt, ostype, pref, snlim, qry))\n-\t    return false;\n-\n-\t  offset_int orng[2];\n-\t  tree off = gimple_assign_rhs2 (stmt);\n-\t  if (get_offset_range (off, stmt, orng, rvals))\n-\t    pref->add_offset (orng[0], orng[1]);\n-\t  else\n-\t    pref->add_max_offset ();\n-\n-\t  qry->put_ref (ptr, *pref);\n-\t  return true;\n-\t}\n-\n-      if (code == ADDR_EXPR || code == SSA_NAME)\n-\t{\n-\t  if (!compute_objsize_r (rhs, stmt, ostype, pref, snlim, qry))\n-\t    return false;\n-\t  qry->put_ref (ptr, *pref);\n-\t  return true;\n-\t}\n-\n-      /* (This could also be an assignment from a nonlocal pointer.)  Save\n-\t PTR to mention in diagnostics but otherwise treat it as a pointer\n-\t to an unknown object.  */\n-      pref->ref = rhs;\n-      pref->base0 = false;\n-      pref->set_max_size_range ();\n-      return true;\n+    default:\n+      break;\n     }\n \n   /* Assume all other expressions point into an unknown object\n@@ -2231,7 +2297,7 @@ compute_objsize (tree ptr, gimple *stmt, int ostype, access_ref *pref,\n   pref->sizrng[0] = pref->sizrng[1] = -1;\n \n   ssa_name_limit_t snlim;\n-  if (!compute_objsize_r (ptr, stmt, ostype, pref, snlim, ptr_qry))\n+  if (!compute_objsize_r (ptr, stmt, false, ostype, pref, snlim, ptr_qry))\n     return NULL_TREE;\n \n   offset_int maxsize = pref->size_remaining ();"}, {"sha": "a7ac7d34370c4d7e0d0dfc48e49a38f0d7a89eea", "filename": "gcc/pointer-query.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1334d889d4adbff999fd33d5e1672ecd6bb66dd7/gcc%2Fpointer-query.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1334d889d4adbff999fd33d5e1672ecd6bb66dd7/gcc%2Fpointer-query.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpointer-query.h?ref=1334d889d4adbff999fd33d5e1672ecd6bb66dd7", "patch": "@@ -122,7 +122,7 @@ struct access_ref\n \n   /* Issue an informational message describing the target of an access\n      with the given mode.  */\n-  void inform_access (access_mode) const;\n+  void inform_access (access_mode, int = 1) const;\n \n   /* Reference to the accessed object(s).  */\n   tree ref;\n@@ -234,6 +234,8 @@ struct access_data\n   /* Read-only for functions like memcmp or strlen, write-only\n      for memset, read-write for memcpy or strcat.  */\n   access_mode mode;\n+  /* The object size type.  */\n+  int ostype;\n };\n \n enum size_range_flags"}]}