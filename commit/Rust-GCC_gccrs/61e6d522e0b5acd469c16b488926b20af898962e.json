{"sha": "61e6d522e0b5acd469c16b488926b20af898962e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjFlNmQ1MjJlMGI1YWNkNDY5YzE2YjQ4ODkyNmIyMGFmODk4OTYyZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2009-07-22T23:03:22Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2009-07-22T23:03:22Z"}, "message": "mangle.c (mangle_type_string_for_rtti): Rename to be clearer.\n\n\t* mangle.c (mangle_type_string_for_rtti): Rename to be clearer.\n\t(needs_fake_anon): New.\n\t(write_name): Check it.\n\t(write_nested_name): Add a fake anonymous namespace scope if true.\n\t* name-lookup.c (get_anonymous_namespace_name): No longer static.\n\t* rtti.c, cp-tree.h: Adjust.\n\n\t* libsupc++/typeinfo (__GXX_MERGED_TYPEINFO_NAMES): Default to 0.\n\nFrom-SVN: r149964", "tree": {"sha": "488c9415969a58d88af4c8fa181992ff70515d95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/488c9415969a58d88af4c8fa181992ff70515d95"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61e6d522e0b5acd469c16b488926b20af898962e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61e6d522e0b5acd469c16b488926b20af898962e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61e6d522e0b5acd469c16b488926b20af898962e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61e6d522e0b5acd469c16b488926b20af898962e/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "db1a8d988963af9d6891316fc565b5aa38e334be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db1a8d988963af9d6891316fc565b5aa38e334be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db1a8d988963af9d6891316fc565b5aa38e334be"}], "stats": {"total": 139, "additions": 93, "deletions": 46}, "files": [{"sha": "85178863136be2886f170bf204ef0539b28e0203", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61e6d522e0b5acd469c16b488926b20af898962e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61e6d522e0b5acd469c16b488926b20af898962e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=61e6d522e0b5acd469c16b488926b20af898962e", "patch": "@@ -1,3 +1,12 @@\n+2009-07-22  Jason Merrill  <jason@redhat.com>\n+\n+\t* mangle.c (mangle_type_string_for_rtti): Rename to be clearer.\n+\t(needs_fake_anon): New.\n+\t(write_name): Check it.\n+\t(write_nested_name): Add a fake anonymous namespace scope if true.\n+\t* name-lookup.c (get_anonymous_namespace_name): No longer static.\n+\t* rtti.c, cp-tree.h: Adjust.\n+\n 2009-07-22  Richard Guenther  <rguenther@suse.de>\n \n \tPR c++/40799"}, {"sha": "2bc2d6214e48b19e00c38c8a4e178182a8bb7ed2", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61e6d522e0b5acd469c16b488926b20af898962e/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61e6d522e0b5acd469c16b488926b20af898962e/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=61e6d522e0b5acd469c16b488926b20af898962e", "patch": "@@ -4345,6 +4345,7 @@ extern tree type_promotes_to\t\t\t(tree);\n extern tree perform_qualification_conversions\t(tree, tree);\n \n /* in name-lookup.c */\n+extern tree get_anonymous_namespace_name\t(void);\n extern tree pushdecl\t\t\t\t(tree);\n extern tree pushdecl_maybe_friend\t\t(tree, bool);\n extern void maybe_push_cleanup_level\t\t(tree);\n@@ -5095,7 +5096,7 @@ extern tree merge_exception_specifiers\t\t(tree, tree);\n /* in mangle.c */\n extern void init_mangle\t\t\t\t(void);\n extern void mangle_decl\t\t\t\t(tree);\n-extern const char *mangle_type_string\t\t(tree);\n+extern const char *mangle_type_string_for_rtti\t(tree);\n extern tree mangle_typeinfo_for_type\t\t(tree);\n extern tree mangle_typeinfo_string_for_type\t(tree);\n extern tree mangle_vtbl_for_type\t\t(tree);"}, {"sha": "bb046d23d5a4c946d332cdd2e50cc09170db8f25", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 40, "deletions": 9, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61e6d522e0b5acd469c16b488926b20af898962e/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61e6d522e0b5acd469c16b488926b20af898962e/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=61e6d522e0b5acd469c16b488926b20af898962e", "patch": "@@ -105,6 +105,10 @@ typedef struct GTY(()) globals {\n \n static GTY (()) globals G;\n \n+/* Whether or not to pretend that a static function is in an anonymous\n+   namespace.  */\n+static bool fake_anon_scope;\n+\n /* The obstack on which we build mangled names.  */\n static struct obstack *mangle_obstack;\n \n@@ -726,6 +730,20 @@ write_encoding (const tree decl)\n     }\n }\n \n+/* Since we now use strcmp to compare typeinfos on all targets because of\n+   the RTLD_LOCAL problem, we need to munge the typeinfo name used for\n+   local classes of static functions to fix g++.dg/abi/local1.C.  We do\n+   that by pretending that the function is in an anonymous namespace.  */\n+\n+static bool\n+needs_fake_anon (const_tree decl)\n+{\n+  /* Pretend there's an anonymous namespace right around a static\n+     function if we're mangling for RTTI.  */\n+  return (fake_anon_scope && !TREE_PUBLIC (decl)\n+\t  && TREE_CODE (decl) == FUNCTION_DECL);\n+}\n+\n /* <name> ::= <unscoped-name>\n \t  ::= <unscoped-template-name> <template-args>\n \t  ::= <nested-name>\n@@ -749,18 +767,23 @@ write_name (tree decl, const int ignore_local_scope)\n       /* In case this is a typedef, fish out the corresponding\n \t TYPE_DECL for the main variant.  */\n       decl = TYPE_NAME (TYPE_MAIN_VARIANT (TREE_TYPE (decl)));\n-      context = TYPE_CONTEXT (TYPE_MAIN_VARIANT (TREE_TYPE (decl)));\n+      context = CP_TYPE_CONTEXT (TYPE_MAIN_VARIANT (TREE_TYPE (decl)));\n     }\n   else\n-    context = (DECL_CONTEXT (decl) == NULL) ? NULL : CP_DECL_CONTEXT (decl);\n+    context = CP_DECL_CONTEXT (decl);\n+\n+  gcc_assert (context != NULL_TREE);\n+\n+  /* If we need a fake anonymous namespace, force the nested name path.  */\n+  if (needs_fake_anon (decl) && context == global_namespace)\n+    context = error_mark_node;\n \n   /* A decl in :: or ::std scope is treated specially.  The former is\n      mangled using <unscoped-name> or <unscoped-template-name>, the\n      latter with a special substitution.  Also, a name that is\n      directly in a local function scope is also mangled with\n      <unscoped-name> rather than a full <nested-name>.  */\n-  if (context == NULL\n-      || context == global_namespace\n+  if (context == global_namespace\n       || DECL_NAMESPACE_STD_P (context)\n       || (ignore_local_scope && TREE_CODE (context) == FUNCTION_DECL))\n     {\n@@ -778,6 +801,9 @@ write_name (tree decl, const int ignore_local_scope)\n     }\n   else\n     {\n+      if (context == error_mark_node)\n+\tcontext = global_namespace;\n+\n       /* Handle local names, unless we asked not to (that is, invoked\n \t under <local-name>, to handle only the part of the name under\n \t the local scope).  */\n@@ -790,10 +816,10 @@ write_name (tree decl, const int ignore_local_scope)\n \t     directly in that function's scope, either decl or one of\n \t     its enclosing scopes.  */\n \t  tree local_entity = decl;\n-\t  while (context != NULL && context != global_namespace)\n+\t  while (context != global_namespace)\n \t    {\n \t      /* Make sure we're always dealing with decls.  */\n-\t      if (context != NULL && TYPE_P (context))\n+\t      if (TYPE_P (context))\n \t\tcontext = TYPE_NAME (context);\n \t      /* Is this a function?  */\n \t      if (TREE_CODE (context) == FUNCTION_DECL)\n@@ -837,7 +863,6 @@ write_unscoped_name (const tree decl)\n       /* If not, it should be either in the global namespace, or directly\n \t in a local function scope.  */\n       gcc_assert (context == global_namespace\n-\t\t  || context == NULL\n \t\t  || TREE_CODE (context) == FUNCTION_DECL);\n \n       write_unqualified_name (decl);\n@@ -909,6 +934,9 @@ write_nested_name (const tree decl)\n     {\n       /* No, just use <prefix>  */\n       write_prefix (DECL_CONTEXT (decl));\n+      if (needs_fake_anon (decl))\n+\t/* Pretend this static function is in an anonymous namespace.  */\n+\twrite_source_name (get_anonymous_namespace_name ());\n       write_unqualified_name (decl);\n     }\n   write_char ('E');\n@@ -2817,15 +2845,18 @@ mangle_decl (const tree decl)\n   SET_DECL_ASSEMBLER_NAME (decl, id);\n }\n \n-/* Generate the mangled representation of TYPE.  */\n+/* Generate the mangled representation of TYPE for the typeinfo name.  */\n \n const char *\n-mangle_type_string (const tree type)\n+mangle_type_string_for_rtti (const tree type)\n {\n   const char *result;\n \n   start_mangling (type);\n+  /* Mangle in a fake anonymous namespace if necessary.  */\n+  fake_anon_scope = true;\n   write_type (type);\n+  fake_anon_scope = false;\n   result = finish_mangling (/*warn=*/false);\n   if (DEBUG_MANGLE)\n     fprintf (stderr, \"mangle_type_string = '%s'\\n\\n\", result);"}, {"sha": "c2d877907bcff525233e09d94fd41042c4b9680c", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61e6d522e0b5acd469c16b488926b20af898962e/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61e6d522e0b5acd469c16b488926b20af898962e/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=61e6d522e0b5acd469c16b488926b20af898962e", "patch": "@@ -62,19 +62,14 @@ static GTY(()) tree anonymous_namespace_name;\n \n /* Initialize anonymous_namespace_name if necessary, and return it.  */\n \n-static tree\n-get_anonymous_namespace_name(void)\n+tree\n+get_anonymous_namespace_name (void)\n {\n   if (!anonymous_namespace_name)\n     {\n       /* The anonymous namespace has to have a unique name\n \t if typeinfo objects are being compared by name.  */\n-      if (! flag_weak || ! SUPPORTS_ONE_ONLY)\n-\tanonymous_namespace_name = get_file_function_name (\"N\");\n-      else\n-\t/* The demangler expects anonymous namespaces to be called\n-\t   something starting with '_GLOBAL__N_'.  */\n-\tanonymous_namespace_name = get_identifier (\"_GLOBAL__N_1\");\n+      anonymous_namespace_name = get_file_function_name (\"N\");\n     }\n   return anonymous_namespace_name;\n }"}, {"sha": "8dde479a6c485e3627c83789509921ad08c9568a", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61e6d522e0b5acd469c16b488926b20af898962e/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61e6d522e0b5acd469c16b488926b20af898962e/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=61e6d522e0b5acd469c16b488926b20af898962e", "patch": "@@ -356,7 +356,7 @@ tinfo_name (tree type)\n   const char *name;\n   tree name_string;\n \n-  name = mangle_type_string (type);\n+  name = mangle_type_string_for_rtti (type);\n   name_string = fix_string_type (build_string (strlen (name) + 1, name));\n   return name_string;\n }"}, {"sha": "ad521da44eb2869f9b3a0ca80f6deaad1b1c5e79", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61e6d522e0b5acd469c16b488926b20af898962e/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61e6d522e0b5acd469c16b488926b20af898962e/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=61e6d522e0b5acd469c16b488926b20af898962e", "patch": "@@ -1,3 +1,7 @@\n+2009-07-22  Jason Merrill  <jason@redhat.com>\n+\n+\t* libsupc++/typeinfo (__GXX_MERGED_TYPEINFO_NAMES): Default to 0.\n+\n 2009-07-22  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* include/std/valarray (valarray<>::operator=(const valarray<>&),"}, {"sha": "4c470430deff29f162e11792579d98acfbdab1c4", "filename": "libstdc++-v3/libsupc++/typeinfo", "status": "modified", "additions": 34, "deletions": 27, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61e6d522e0b5acd469c16b488926b20af898962e/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftypeinfo", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61e6d522e0b5acd469c16b488926b20af898962e/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftypeinfo", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftypeinfo?ref=61e6d522e0b5acd469c16b488926b20af898962e", "patch": "@@ -43,32 +43,29 @@ namespace __cxxabiv1\n } // namespace __cxxabiv1\n \n // Determine whether typeinfo names for the same type are merged (in which\n-// case comparison can just compare pointers) or not (in which case\n-// strings must be compared and g++.dg/abi/local1.C will fail), and\n-// whether comparison is to be implemented inline or not.  By default we\n-// use inline pointer comparison if weak symbols are available, and\n-// out-of-line strcmp if not.  Out-of-line pointer comparison is used\n-// where the object files are to be portable to multiple systems, some of\n-// which may not be able to use pointer comparison, but the particular\n-// system for which libstdc++ is being built can use pointer comparison;\n-// in particular for most ARM EABI systems, where the ABI specifies\n-// out-of-line comparison.  Inline strcmp is not currently supported.  The\n-// compiler's target configuration can override the defaults by defining\n-// __GXX_TYPEINFO_EQUALITY_INLINE to 1 or 0 to indicate whether or not\n-// comparison is inline, and __GXX_MERGED_TYPEINFO_NAMES to 1 or 0 to\n-// indicate whether or not pointer comparison can be used.\n+// case comparison can just compare pointers) or not (in which case strings\n+// must be compared), and whether comparison is to be implemented inline or\n+// not.  We used to do inline pointer comparison by default if weak symbols\n+// are available, but even with weak symbols sometimes names are not merged\n+// when objects are loaded with RTLD_LOCAL, so now we always use strcmp by\n+// default.  For ABI compatibility, we do the strcmp inline if weak symbols\n+// are available, and out-of-line if not.  Out-of-line pointer comparison\n+// is used where the object files are to be portable to multiple systems,\n+// some of which may not be able to use pointer comparison, but the\n+// particular system for which libstdc++ is being built can use pointer\n+// comparison; in particular for most ARM EABI systems, where the ABI\n+// specifies out-of-line comparison.  The compiler's target configuration\n+// can override the defaults by defining __GXX_TYPEINFO_EQUALITY_INLINE to\n+// 1 or 0 to indicate whether or not comparison is inline, and\n+// __GXX_MERGED_TYPEINFO_NAMES to 1 or 0 to indicate whether or not pointer\n+// comparison can be used.\n \n #ifndef __GXX_MERGED_TYPEINFO_NAMES\n-  #if !__GXX_WEAK__\n-    // If weak symbols are not supported, typeinfo names are not merged.\n-    #define __GXX_MERGED_TYPEINFO_NAMES 0\n-  #else\n-    // On platforms that support weak symbols, typeinfo names are merged.\n-    #define __GXX_MERGED_TYPEINFO_NAMES 1\n-  #endif\n+// By default, typeinfo names are not merged.\n+#define __GXX_MERGED_TYPEINFO_NAMES 0\n #endif\n \n-// By default follow the same rules as for __GXX_MERGED_TYPEINFO_NAMES.\n+// By default follow the old inline rules to avoid ABI changes.\n #ifndef __GXX_TYPEINFO_EQUALITY_INLINE\n   #if !__GXX_WEAK__\n     #define __GXX_TYPEINFO_EQUALITY_INLINE 0\n@@ -100,25 +97,35 @@ namespace std\n     { return __name; }\n \n #if !__GXX_TYPEINFO_EQUALITY_INLINE\n-    bool before(const type_info& __arg) const;\n-\n     // In old abi, or when weak symbols are not supported, there can\n     // be multiple instances of a type_info object for one\n     // type. Uniqueness must use the _name value, not object address.\n+    bool before(const type_info& __arg) const;\n     bool operator==(const type_info& __arg) const;\n #else\n   #if !__GXX_MERGED_TYPEINFO_NAMES\n-    #error \"Inline implementation of type_info comparision requires merging of type_info objects\"\n-  #endif\n     /** Returns true if @c *this precedes @c __arg in the implementation's\n      *  collation order.  */\n-    // In new abi we can rely on type_info's NTBS being unique,\n+    // Even with the new abi, on systems that support dlopen\n+    // we can run into cases where type_info names aren't merged,\n+    // so we still need to do string comparison.\n+    bool before(const type_info& __arg) const\n+    { return __builtin_strcmp (__name, __arg.__name) < 0; }\n+\n+    bool operator==(const type_info& __arg) const\n+    {\n+      return ((__name == __arg.__name)\n+\t      || __builtin_strcmp (__name, __arg.__name) == 0);\n+    }\n+  #else\n+    // On some targets we can rely on type_info's NTBS being unique,\n     // and therefore address comparisons are sufficient.\n     bool before(const type_info& __arg) const\n     { return __name < __arg.__name; }\n \n     bool operator==(const type_info& __arg) const\n     { return __name == __arg.__name; }\n+  #endif\n #endif\n     bool operator!=(const type_info& __arg) const\n     { return !operator==(__arg); }"}]}