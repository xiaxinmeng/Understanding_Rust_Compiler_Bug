{"sha": "df7965e4144004831703ce7ed1d7ea67509c1028", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGY3OTY1ZTQxNDQwMDQ4MzE3MDNjZTdlZDFkN2VhNjc1MDljMTAyOA==", "commit": {"author": {"name": "Ulrich Weigand", "email": "ulrich.weigand@linaro.org", "date": "2012-03-15T16:43:08Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2012-03-15T16:43:08Z"}, "message": "* combine.c (apply_distributive_law): Do not distribute SUBREG.\n\nFrom-SVN: r185438", "tree": {"sha": "347e3e164edc0c8e666e713b78409184ce31fecc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/347e3e164edc0c8e666e713b78409184ce31fecc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df7965e4144004831703ce7ed1d7ea67509c1028", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df7965e4144004831703ce7ed1d7ea67509c1028", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df7965e4144004831703ce7ed1d7ea67509c1028", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df7965e4144004831703ce7ed1d7ea67509c1028/comments", "author": null, "committer": null, "parents": [{"sha": "bc4fb35543b0e2b6bf1f0b0d4d234a16e8005813", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc4fb35543b0e2b6bf1f0b0d4d234a16e8005813", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc4fb35543b0e2b6bf1f0b0d4d234a16e8005813"}], "stats": {"total": 50, "additions": 20, "deletions": 30}, "files": [{"sha": "32ba91225b51e5566dbf32825dcbf80528924928", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df7965e4144004831703ce7ed1d7ea67509c1028/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df7965e4144004831703ce7ed1d7ea67509c1028/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=df7965e4144004831703ce7ed1d7ea67509c1028", "patch": "@@ -1,3 +1,7 @@\n+2012-03-15  Ulrich Weigand  <ulrich.weigand@linaro.org>\n+\n+\t* combine.c (apply_distributive_law): Do not distribute SUBREG.\n+\n 2012-03-15  Ira Rosen  <irar@il.ibm.com>\n \t    Ulrich Weigand  <ulrich.weigand@linaro.org>\n "}, {"sha": "e3c8209a1530b6d2954fb17afa7d9a11f37a02ab", "filename": "gcc/combine.c", "status": "modified", "additions": 16, "deletions": 30, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df7965e4144004831703ce7ed1d7ea67509c1028/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df7965e4144004831703ce7ed1d7ea67509c1028/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=df7965e4144004831703ce7ed1d7ea67509c1028", "patch": "@@ -9290,36 +9290,22 @@ apply_distributive_law (rtx x)\n       /* This is also a multiply, so it distributes over everything.  */\n       break;\n \n-    case SUBREG:\n-      /* Non-paradoxical SUBREGs distributes over all operations,\n-\t provided the inner modes and byte offsets are the same, this\n-\t is an extraction of a low-order part, we don't convert an fp\n-\t operation to int or vice versa, this is not a vector mode,\n-\t and we would not be converting a single-word operation into a\n-\t multi-word operation.  The latter test is not required, but\n-\t it prevents generating unneeded multi-word operations.  Some\n-\t of the previous tests are redundant given the latter test,\n-\t but are retained because they are required for correctness.\n-\n-\t We produce the result slightly differently in this case.  */\n-\n-      if (GET_MODE (SUBREG_REG (lhs)) != GET_MODE (SUBREG_REG (rhs))\n-\t  || SUBREG_BYTE (lhs) != SUBREG_BYTE (rhs)\n-\t  || ! subreg_lowpart_p (lhs)\n-\t  || (GET_MODE_CLASS (GET_MODE (lhs))\n-\t      != GET_MODE_CLASS (GET_MODE (SUBREG_REG (lhs))))\n-\t  || paradoxical_subreg_p (lhs)\n-\t  || VECTOR_MODE_P (GET_MODE (lhs))\n-\t  || GET_MODE_SIZE (GET_MODE (SUBREG_REG (lhs))) > UNITS_PER_WORD\n-\t  /* Result might need to be truncated.  Don't change mode if\n-\t     explicit truncation is needed.  */\n-\t  || !TRULY_NOOP_TRUNCATION_MODES_P (GET_MODE (x),\n-\t\t\t\t\t     GET_MODE (SUBREG_REG (lhs))))\n-\treturn x;\n-\n-      tem = simplify_gen_binary (code, GET_MODE (SUBREG_REG (lhs)),\n-\t\t\t\t SUBREG_REG (lhs), SUBREG_REG (rhs));\n-      return gen_lowpart (GET_MODE (x), tem);\n+    /* This used to handle SUBREG, but this turned out to be counter-\n+       productive, since (subreg (op ...)) usually is not handled by\n+       insn patterns, and this \"optimization\" therefore transformed\n+       recognizable patterns into unrecognizable ones.  Therefore the\n+       SUBREG case was removed from here.\n+\n+       It is possible that distributing SUBREG over arithmetic operations\n+       leads to an intermediate result than can then be optimized further,\n+       e.g. by moving the outer SUBREG to the other side of a SET as done\n+       in simplify_set.  This seems to have been the original intent of\n+       handling SUBREGs here.\n+\n+       However, with current GCC this does not appear to actually happen,\n+       at least on major platforms.  If some case is found where removing\n+       the SUBREG case here prevents follow-on optimizations, distributing\n+       SUBREGs ought to be re-added at that place, e.g. in simplify_set.  */\n \n     default:\n       return x;"}]}