{"sha": "068feaa95538472dfdb0244ef4899a86e73db86e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDY4ZmVhYTk1NTM4NDcyZGZkYjAyNDRlZjQ4OTlhODZlNzNkYjg2ZQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2000-03-30T12:08:26Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2000-03-30T12:08:26Z"}, "message": "rtti.c (class_hint_flags): Rename flags.\n\n\t* rtti.c (class_hint_flags): Rename flags.\n\t(class_initializer): Remove flags.\n\t(synthesize_tinfo_var): Combine offset and flags. Add flags\n\tfor __vmi_class_type_info.\n\t(create_tinfo_types): Remove flags from __class_type_info and\n\t__si_class_type_info. Merge flags and offset from\n\tbase_class_type_info.\n\t* inc/cxxabi.h (__base_class_info): Merge offset and vmi_flags.\n\t(__base_class_info::is_virtual_p): Adjust.\n\t(__base_class_info::is_public_p): Adjust.\n\t(__base_class_info::offset): New accessor.\n\t(__class_type_info::details): Remove member.\n\t(__class_type_info::__class_type_info): Lose details.\n\t(__class_type_info::detail_masks): Remove.\n\t(__si_class_type_info::__si_class_type_info): Lose details.\n\t(__vmi_class_type_info::details): New member.\n\t(__vmi_class_type_info::__vmi_class_type_info): Adjust.\n\t(__vmi_class_type_info::detail_masks): New member.\n\t* tinfo.cc (__class_type_info::do_upcast): Initialize result\n\twith unknown_details_mask.\n\t(__vmi_class_type_info::do_find_public_src): Adjust\n\t(__vmi_class_type_info::do_dyncast): Adjust.\n\t(__vmi_class_type_info::do_upcast): Set result details, if\n\tneeded. Adjust.\n\t(__dynamic_cast): Temporarily #if out optimization.\n\nFrom-SVN: r32828", "tree": {"sha": "215e7cef70275acfb861ad0b6003848dbc7a54ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/215e7cef70275acfb861ad0b6003848dbc7a54ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/068feaa95538472dfdb0244ef4899a86e73db86e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/068feaa95538472dfdb0244ef4899a86e73db86e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/068feaa95538472dfdb0244ef4899a86e73db86e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/068feaa95538472dfdb0244ef4899a86e73db86e/comments", "author": null, "committer": null, "parents": [{"sha": "19caa751a84a1ff3a90a5dc64e3f4c5cac6ce97f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19caa751a84a1ff3a90a5dc64e3f4c5cac6ce97f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19caa751a84a1ff3a90a5dc64e3f4c5cac6ce97f"}], "stats": {"total": 136, "additions": 86, "deletions": 50}, "files": [{"sha": "da0b96f90ab749d2760b39a5773dd4f66e2f47d8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068feaa95538472dfdb0244ef4899a86e73db86e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068feaa95538472dfdb0244ef4899a86e73db86e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=068feaa95538472dfdb0244ef4899a86e73db86e", "patch": "@@ -1,3 +1,31 @@\n+2000-03-30  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* rtti.c (class_hint_flags): Rename flags.\n+\t(class_initializer): Remove flags.\n+\t(synthesize_tinfo_var): Combine offset and flags. Add flags\n+\tfor __vmi_class_type_info.\n+\t(create_tinfo_types): Remove flags from __class_type_info and\n+\t__si_class_type_info. Merge flags and offset from\n+\tbase_class_type_info.\n+\t* inc/cxxabi.h (__base_class_info): Merge offset and vmi_flags.\n+\t(__base_class_info::is_virtual_p): Adjust.\n+\t(__base_class_info::is_public_p): Adjust.\n+\t(__base_class_info::offset): New accessor.\n+\t(__class_type_info::details): Remove member.\n+\t(__class_type_info::__class_type_info): Lose details.\n+\t(__class_type_info::detail_masks): Remove.\n+\t(__si_class_type_info::__si_class_type_info): Lose details.\n+\t(__vmi_class_type_info::details): New member.\n+\t(__vmi_class_type_info::__vmi_class_type_info): Adjust.\n+\t(__vmi_class_type_info::detail_masks): New member.\n+\t* tinfo.cc (__class_type_info::do_upcast): Initialize result\n+\twith unknown_details_mask.\n+\t(__vmi_class_type_info::do_find_public_src): Adjust\n+\t(__vmi_class_type_info::do_dyncast): Adjust.\n+\t(__vmi_class_type_info::do_upcast): Set result details, if\n+\tneeded. Adjust.\n+\t(__dynamic_cast): Temporarily #if out optimization.\n+\n 2000-03-29  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* rtti.c (get_tinfo_decl): Mark used."}, {"sha": "26cec3fae0a6840add39275a64b0c7cd8e8ec5ad", "filename": "gcc/cp/inc/cxxabi.h", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068feaa95538472dfdb0244ef4899a86e73db86e/gcc%2Fcp%2Finc%2Fcxxabi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068feaa95538472dfdb0244ef4899a86e73db86e/gcc%2Fcp%2Finc%2Fcxxabi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finc%2Fcxxabi.h?ref=068feaa95538472dfdb0244ef4899a86e73db86e", "patch": "@@ -160,51 +160,40 @@ class __base_class_info\n /* abi defined member variables */\n public:\n   const __class_type_info *base;    /* base class type */\n-  std::ptrdiff_t offset;            /* offset to the sub object */\n-  int vmi_flags;                    /* about the base */\n+  long vmi_offset_flags;            /* offset and info */\n \n /* implementation defined types */\n public:\n   enum vmi_masks {\n     virtual_mask = 0x1,\n     public_mask = 0x2,\n-    hwm_bit = 2\n+    hwm_bit = 2,\n+    offset_shift = 8          /* bits to shift offset by */\n   };\n   \n /* implementation defined member functions */\n public:\n   bool is_virtual_p () const\n-    { return vmi_flags & virtual_mask; }\n+    { return vmi_offset_flags & virtual_mask; }\n   bool is_public_p () const\n-    { return vmi_flags & public_mask; }\n+    { return vmi_offset_flags & public_mask; }\n+  std::ptrdiff_t offset () const\n+    { return std::ptrdiff_t (vmi_offset_flags) >> offset_shift; }\n };\n \n /* type information for a class */\n class __class_type_info\n   : public std::type_info\n {\n-/* abi defined member variables */\n-public:\n-  int details;      /* details about the class heirarchy */\n-\n /* abi defined member functions */\n public:\n   virtual ~__class_type_info ();\n public:\n-  explicit __class_type_info (const char *n_,\n-                              int details_)\n-    : type_info (n_), details (details_)\n+  explicit __class_type_info (const char *n_)\n+    : type_info (n_)\n     { }\n \n /* implementation defined types */\n-public:\n-  enum detail_masks {\n-    multiple_base_mask = 0x1,   /* multiple inheritance of the same base type */\n-    polymorphic_mask = 0x2,     /* is a polymorphic type */\n-    virtual_base_mask = 0x4,    /* has virtual bases (direct or indirect) */\n-    private_base_mask = 0x8     /* has private bases (direct or indirect) */\n-  };\n-\n public:\n   /* sub_kind tells us about how a base object is contained within a derived\n      object. We often do this lazily, hence the UNKNOWN value. At other times\n@@ -230,7 +219,7 @@ class __class_type_info\n   {\n     const void *dst_ptr;        /* pointer to caught object */\n     sub_kind whole2dst;         /* path from most derived object to target */\n-    int src_details;            /* hints about the source type */\n+    int src_details;            /* hints about the source type heirarchy */\n     const __class_type_info *base_type; /* where we found the target, */\n                                 /* if in vbase the __class_type_info of vbase */\n                                 /* if a non-virtual base then 1 */\n@@ -320,9 +309,8 @@ class __si_class_type_info\n   virtual ~__si_class_type_info ();\n public:\n   explicit __si_class_type_info (const char *n_,\n-                                 int details_,\n                                  const __class_type_info *base_)\n-    : __class_type_info (n_, details_), base (base_)\n+    : __class_type_info (n_), base (base_)\n     { }\n \n /* implementation defined member functions */\n@@ -342,7 +330,8 @@ class __si_class_type_info\n /* type information for a class with multiple and/or virtual bases */\n class __vmi_class_type_info : public __class_type_info {\n /* abi defined member variables */\n-protected:\n+public:\n+  int details;      /* details about the class heirarchy */\n   int n_bases;      /* number of direct bases */\n   __base_class_info base_list[1]; /* array of bases */\n   /* The array of bases uses the trailing array struct hack\n@@ -355,9 +344,20 @@ class __vmi_class_type_info : public __class_type_info {\n public:\n   explicit __vmi_class_type_info (const char *n_,\n                                   int details_)\n-    : __class_type_info (n_, details_), n_bases (0)\n+    : __class_type_info (n_), details (details_), n_bases (0)\n     { }\n \n+/* implementation defined types */\n+public:\n+  enum detail_masks {\n+    non_diamond_repeat_mask = 0x1,   /* distinct instance of repeated base */\n+    diamond_shaped_mask = 0x2,       /* diamond shaped multiple inheritance */\n+    non_public_base_mask = 0x4,      /* has non-public direct or indirect base */\n+    public_base_mask = 0x8,          /* has public base (direct) */\n+    \n+    details_unknown_mask = 0x10\n+  };\n+\n /* implementation defined member functions */\n protected:\n   virtual bool do_dyncast (std::ptrdiff_t src2dst, sub_kind access_path,"}, {"sha": "a91bef857b49b9ebfadc335aebe40bf23897252d", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068feaa95538472dfdb0244ef4899a86e73db86e/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068feaa95538472dfdb0244ef4899a86e73db86e/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=068feaa95538472dfdb0244ef4899a86e73db86e", "patch": "@@ -1392,12 +1392,12 @@ class_hint_flags (type)\n      tree type;\n {\n   int hint_flags = 0;\n-  hint_flags |= 0x1;  /* contains multiply inherited sub object */\n-  hint_flags |= 0x4;  /* has virtual bases */\n-  hint_flags |= 0x8;  /* has private base */\n-  if (TYPE_POLYMORPHIC_P (type))\n-    hint_flags |= 0x2;\n   \n+  hint_flags |= 0x1;  /* non-diamond shaped repeated base */\n+  hint_flags |= 0x2;  /* diamond shaped */\n+  hint_flags |= 0x4;  /* non-public base */\n+  hint_flags |= 0x8;  /* public base */\n+  type = 0; /* FIXME: Use it! */\n   return hint_flags;\n }\n         \n@@ -1412,9 +1412,7 @@ class_initializer (desc, target, trail)\n      tree trail;\n {\n   tree init = tinfo_base_init (desc, target);\n-  int flags = class_hint_flags (target);\n   \n-  trail = tree_cons (NULL_TREE, build_int_2 (flags, 0), trail);\n   TREE_CHAIN (init) = trail;\n   init = build (CONSTRUCTOR, NULL_TREE, NULL_TREE, init);\n   TREE_HAS_CONSTRUCTOR (init) = TREE_CONSTANT (init) = TREE_STATIC (init) = 1;\n@@ -1520,8 +1518,11 @@ synthesize_tinfo_var (target_type, real_name)\n                 }\n               is_simple = 0;\n               \n-              base_init = tree_cons\n-                  (NULL_TREE, build_int_2 (flags, 0), base_init);\n+              /* combine offset and flags into one field */\n+              offset = build_binary_op (LSHIFT_EXPR, offset,\n+                                        build_int_2 (8, 0));\n+              offset = build_binary_op (BIT_IOR_EXPR, offset,\n+                                        build_int_2 (flags, 0));\n               base_init = tree_cons (NULL_TREE, offset, base_init);\n               base_init = tree_cons (NULL_TREE, tinfo, base_init);\n               base_init = build (CONSTRUCTOR, NULL_TREE, NULL_TREE, base_init);\n@@ -1532,12 +1533,16 @@ synthesize_tinfo_var (target_type, real_name)\n             var_type = si_class_desc_type_node;\n           else\n             {\n-              /* Prepend the number of bases.  */\n+              int hint = class_hint_flags (target_type);\n+              \n               base_inits = build (CONSTRUCTOR, NULL_TREE, NULL_TREE, base_inits);\n               base_inits = tree_cons (NULL_TREE, base_inits, NULL_TREE);\n+              /* Prepend the number of bases.  */\n               base_inits = tree_cons (NULL_TREE,\n                                       build_int_2 (nbases, 0), base_inits);\n-          \n+              /* Prepend the hint flags. */\n+              base_inits = tree_cons (NULL_TREE,\n+                                      build_int_2 (hint, 0), base_inits);\n               var_type = get_vmi_pseudo_type_info (nbases);\n             }\n           var_init = class_initializer (var_type, target_type, base_inits);\n@@ -1761,27 +1766,24 @@ create_tinfo_types ()\n   /* Class type_info. Add a flags field.  */\n   class_desc_type_node = create_pseudo_type_info\n         (\"__class_type_info\", 0,\n-         build_lang_decl (FIELD_DECL, NULL_TREE, integer_type_node),\n          NULL);\n   \n   /* Single public non-virtual base class. Add pointer to base class.  */\n   si_class_desc_type_node = create_pseudo_type_info\n            (\"__si_class_type_info\", 0,\n-            build_lang_decl (FIELD_DECL, NULL_TREE, integer_type_node),\n             build_lang_decl (FIELD_DECL, NULL_TREE, ptr_type_info),\n             NULL);\n   \n   /* Base class internal helper. Pointer to base type, offset to base,\n      flags. */\n   {\n-    tree fields[3];\n+    tree fields[2];\n     \n-    fields[0] = build_lang_decl (FIELD_DECL, NULL_TREE, ptr_type_info),\n-    fields[1] = build_lang_decl (FIELD_DECL, NULL_TREE, ptrdiff_type_node),\n-    fields[2] = build_lang_decl (FIELD_DECL, NULL_TREE, integer_type_node),\n+    fields[0] = build_lang_decl (FIELD_DECL, NULL_TREE, ptr_type_info);\n+    fields[1] = build_lang_decl (FIELD_DECL, NULL_TREE, integer_types[itk_long]);\n     base_desc_type_node = make_aggr_type (RECORD_TYPE);\n     finish_builtin_type (base_desc_type_node, \"__base_class_type_info_pseudo\",\n-                         fields, 2, ptr_type_node);\n+                         fields, 1, ptr_type_node);\n     TYPE_HAS_CONSTRUCTOR (base_desc_type_node) = 1;\n   }\n   "}, {"sha": "71e5c2847c4e9a24f521b3e95b8fc01447d1633b", "filename": "gcc/cp/tinfo.cc", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068feaa95538472dfdb0244ef4899a86e73db86e/gcc%2Fcp%2Ftinfo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068feaa95538472dfdb0244ef4899a86e73db86e/gcc%2Fcp%2Ftinfo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftinfo.cc?ref=068feaa95538472dfdb0244ef4899a86e73db86e", "patch": "@@ -652,7 +652,7 @@ do_catch (const type_info *thr_type, void **thr_obj,\n bool __class_type_info::\n do_upcast (const __class_type_info *dst_type, void **obj_ptr) const\n {\n-  upcast_result result (details);\n+  upcast_result result (__vmi_class_type_info::details_unknown_mask);\n   \n   if (do_upcast (contained_public, dst_type, *obj_ptr, result))\n     return false;\n@@ -712,7 +712,7 @@ do_find_public_src (ptrdiff_t src2dst,\n         continue; // Not public, can't be here.\n       \n       const void *base = obj_ptr;\n-      ptrdiff_t offset = base_list[i].offset;\n+      ptrdiff_t offset = base_list[i].offset ();\n       \n       if (base_list[i].is_virtual_p ())\n         {\n@@ -836,7 +836,7 @@ do_dyncast (ptrdiff_t src2dst,\n       dyncast_result result2;\n       void const *base = obj_ptr;\n       sub_kind base_access = access_path;\n-      ptrdiff_t offset = base_list[i].offset;\n+      ptrdiff_t offset = base_list[i].offset ();\n       \n       if (base_list[i].is_virtual_p ())\n         {\n@@ -1018,16 +1018,20 @@ do_upcast (sub_kind access_path,\n       return contained_nonpublic_p (access_path);\n     }\n   \n+  int src_details = result.src_details;\n+  if (src_details & details_unknown_mask)\n+    src_details = details;\n+  \n   for (size_t i = n_bases; i--;)\n     {\n-      upcast_result result2 (result.src_details);\n+      upcast_result result2 (src_details);\n       const void *base = obj_ptr;\n       sub_kind sub_access = access_path;\n-      ptrdiff_t offset = base_list[i].offset;\n+      ptrdiff_t offset = base_list[i].offset ();\n       \n       if (!base_list[i].is_public_p ())\n         {\n-          if (!(result.src_details & multiple_base_mask))\n+          if (!(src_details & non_diamond_repeat_mask))\n             // original cannot have an ambiguous base\n             continue;\n           sub_access = sub_kind (sub_access & ~contained_public_mask);\n@@ -1055,7 +1059,7 @@ do_upcast (sub_kind access_path,\n           if (!result.base_type)\n             {\n               result = result2;\n-              if (!(details & multiple_base_mask))\n+              if (!(details & non_diamond_repeat_mask))\n                 // cannot have an ambiguous other base\n                 return false;\n             }\n@@ -1119,9 +1123,11 @@ __dynamic_cast (const void *src_ptr,    // object started from\n   if (contained_nonvirtual_p (result.whole2src))\n     // Found an invalid cross cast, which cannot also be a down cast\n     return NULL;\n+  #if 0 // FIXME: we need to discover this lazily\n   if (!(whole_type->details & __class_type_info::private_base_mask))\n     // whole type has no private bases\n     return const_cast <void *> (result.dst_ptr);\n+  #endif\n   if (result.dst2src == __class_type_info::unknown)\n     result.dst2src = dst_type->find_public_src (src2dst, result.dst_ptr,\n                                                 src_type, src_ptr);"}]}