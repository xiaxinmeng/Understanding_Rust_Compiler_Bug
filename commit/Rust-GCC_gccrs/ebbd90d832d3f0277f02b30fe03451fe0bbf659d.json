{"sha": "ebbd90d832d3f0277f02b30fe03451fe0bbf659d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWJiZDkwZDgzMmQzZjAyNzdmMDJiMzBmZTAzNDUxZmUwYmJmNjU5ZA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2013-04-29T12:52:17Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2013-04-29T12:52:17Z"}, "message": "tree-vrp.c (range_fits_type_p): Move to earlier point in file.\n\n\t* tree-vrp.c (range_fits_type_p): Move to earlier point in file.\n        (simplify_cond_using_ranges): Generalize code to simplify\n        COND_EXPRs where one argument is a constant and the other\n        is an SSA_NAME created by an integral type conversion.\n\n\t* gcc.dg/tree-ssa/vrp88.c: New test.\n\nFrom-SVN: r198413", "tree": {"sha": "8eeffe6533adbdfe8771db8a2c7e92e1b6381bcd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8eeffe6533adbdfe8771db8a2c7e92e1b6381bcd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ebbd90d832d3f0277f02b30fe03451fe0bbf659d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebbd90d832d3f0277f02b30fe03451fe0bbf659d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebbd90d832d3f0277f02b30fe03451fe0bbf659d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebbd90d832d3f0277f02b30fe03451fe0bbf659d/comments", "author": null, "committer": null, "parents": [{"sha": "8b9b57ebca94b7c16daaed85d3020c06f2412dce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b9b57ebca94b7c16daaed85d3020c06f2412dce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b9b57ebca94b7c16daaed85d3020c06f2412dce"}], "stats": {"total": 174, "additions": 111, "deletions": 63}, "files": [{"sha": "05f2841ad3e3c67e6fcb26fd9b53e1889e9e6a6a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebbd90d832d3f0277f02b30fe03451fe0bbf659d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebbd90d832d3f0277f02b30fe03451fe0bbf659d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ebbd90d832d3f0277f02b30fe03451fe0bbf659d", "patch": "@@ -1,3 +1,10 @@\n+2013-04-26  Jeff Law  <law@redhat.com>\n+\n+\t* tree-vrp.c (range_fits_type_p): Move to earlier point in file.\n+\t(simplify_cond_using_ranges): Generalize code to simplify\n+\tCOND_EXPRs where one argument is a constant and the other\n+\tis an SSA_NAME created by an integral type conversion.\n+\n 2013-04-29  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/arm/arm.md (store_minmaxsi): Use only when"}, {"sha": "d7afacb71e003a3de7760010a53b7334ca67682e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebbd90d832d3f0277f02b30fe03451fe0bbf659d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebbd90d832d3f0277f02b30fe03451fe0bbf659d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ebbd90d832d3f0277f02b30fe03451fe0bbf659d", "patch": "@@ -1,3 +1,7 @@\n+2013-04-26  Jeff Law  <law@redhat.com>\n+\n+\t* gcc.dg/tree-ssa/vrp88.c: New test.\n+\n 2013-04-29  Christian Bruel  <christian.bruel@st.com>\n \n \tPR target/57108"}, {"sha": "e43bdffbba130f31deb49997007f60c49257a38f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp88.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebbd90d832d3f0277f02b30fe03451fe0bbf659d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp88.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebbd90d832d3f0277f02b30fe03451fe0bbf659d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp88.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp88.c?ref=ebbd90d832d3f0277f02b30fe03451fe0bbf659d", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do compile } */\n+\n+/* { dg-options \"-O2 -fdump-tree-vrp1-details\" } */\n+\n+\n+typedef const struct bitmap_head_def *const_bitmap;\n+typedef unsigned long BITMAP_WORD;\n+typedef struct bitmap_element_def {\n+  struct bitmap_element_def *next;\n+  BITMAP_WORD bits[((128 + (8 * 8 * 1u) - 1) / (8 * 8 * 1u))];\n+} bitmap_element;\n+typedef struct bitmap_head_def {\n+  bitmap_element *first;\n+} bitmap_head;\n+unsigned char\n+bitmap_single_bit_set_p (const_bitmap a)\n+{\n+  unsigned long count = 0;\n+  const bitmap_element *elt;\n+  unsigned ix;\n+  if ((!(a)->first))\n+    return 0;\n+  elt = a->first;\n+  if (elt->next != ((void *)0))\n+    return 0;\n+  for (ix = 0; ix != ((128 + (8 * 8 * 1u) - 1) / (8 * 8 * 1u)); ix++)\n+    {\n+      count += __builtin_popcountl (elt->bits[ix]);\n+      if (count > 1)\n+ return 0;\n+    }\n+  return count == 1;\n+}\n+\n+/* Verify that VRP simplified an \"if\" statement.  */\n+/* { dg-final { scan-tree-dump \"Folded into: if.*\" \"vrp1\"} } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */\n+\n+"}, {"sha": "6ed353f07de7f7ea586ab2290fe5c687809f4f01", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 61, "deletions": 63, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebbd90d832d3f0277f02b30fe03451fe0bbf659d/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebbd90d832d3f0277f02b30fe03451fe0bbf659d/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=ebbd90d832d3f0277f02b30fe03451fe0bbf659d", "patch": "@@ -8509,6 +8509,57 @@ test_for_singularity (enum tree_code cond_code, tree op0,\n   return NULL;\n }\n \n+/* Return whether the value range *VR fits in an integer type specified\n+   by PRECISION and UNSIGNED_P.  */\n+\n+static bool\n+range_fits_type_p (value_range_t *vr, unsigned precision, bool unsigned_p)\n+{\n+  tree src_type;\n+  unsigned src_precision;\n+  double_int tem;\n+\n+  /* We can only handle integral and pointer types.  */\n+  src_type = TREE_TYPE (vr->min);\n+  if (!INTEGRAL_TYPE_P (src_type)\n+      && !POINTER_TYPE_P (src_type))\n+    return false;\n+\n+  /* An extension is fine unless VR is signed and unsigned_p,\n+     and so is an identity transform.  */\n+  src_precision = TYPE_PRECISION (TREE_TYPE (vr->min));\n+  if ((src_precision < precision\n+       && !(unsigned_p && !TYPE_UNSIGNED (src_type)))\n+      || (src_precision == precision\n+\t  && TYPE_UNSIGNED (src_type) == unsigned_p))\n+    return true;\n+\n+  /* Now we can only handle ranges with constant bounds.  */\n+  if (vr->type != VR_RANGE\n+      || TREE_CODE (vr->min) != INTEGER_CST\n+      || TREE_CODE (vr->max) != INTEGER_CST)\n+    return false;\n+\n+  /* For sign changes, the MSB of the double_int has to be clear.\n+     An unsigned value with its MSB set cannot be represented by\n+     a signed double_int, while a negative value cannot be represented\n+     by an unsigned double_int.  */\n+  if (TYPE_UNSIGNED (src_type) != unsigned_p\n+      && (TREE_INT_CST_HIGH (vr->min) | TREE_INT_CST_HIGH (vr->max)) < 0)\n+    return false;\n+\n+  /* Then we can perform the conversion on both ends and compare\n+     the result for equality.  */\n+  tem = tree_to_double_int (vr->min).ext (precision, unsigned_p);\n+  if (tree_to_double_int (vr->min) != tem)\n+    return false;\n+  tem = tree_to_double_int (vr->max).ext (precision, unsigned_p);\n+  if (tree_to_double_int (vr->max) != tem)\n+    return false;\n+\n+  return true;\n+}\n+\n /* Simplify a conditional using a relational operator to an equality\n    test if the range information indicates only one value can satisfy\n    the original conditional.  */\n@@ -8590,18 +8641,15 @@ simplify_cond_using_ranges (gimple stmt)\n \t}\n     }\n \n-  /* If we have a comparison of a SSA_NAME boolean against\n-     a constant (which obviously must be [0..1]), see if the\n-     SSA_NAME was set by a type conversion where the source\n-     of the conversion is another SSA_NAME with a range [0..1].\n+  /* If we have a comparison of an SSA_NAME (OP0) against a constant,\n+     see if OP0 was set by a type conversion where the source of\n+     the conversion is another SSA_NAME with a range that fits\n+     into the range of OP0's type.\n \n-     If so, we can replace the SSA_NAME in the comparison with\n-     the RHS of the conversion.  This will often make the type\n-     conversion dead code which DCE will clean up.  */\n+     If so, the conversion is redundant as the earlier SSA_NAME can be\n+     used for the comparison directly if we just massage the constant in the\n+     comparison.  */\n   if (TREE_CODE (op0) == SSA_NAME\n-      && (TREE_CODE (TREE_TYPE (op0)) == BOOLEAN_TYPE\n-\t  || (INTEGRAL_TYPE_P (TREE_TYPE (op0))\n-\t      && TYPE_PRECISION (TREE_TYPE (op0)) == 1))\n       && TREE_CODE (op1) == INTEGER_CST)\n     {\n       gimple def_stmt = SSA_NAME_DEF_STMT (op0);\n@@ -8618,8 +8666,9 @@ simplify_cond_using_ranges (gimple stmt)\n \t  value_range_t *vr = get_value_range (innerop);\n \n \t  if (range_int_cst_p (vr)\n-\t      && operand_equal_p (vr->min, integer_zero_node, 0)\n-\t      && operand_equal_p (vr->max, integer_one_node, 0))\n+\t      && range_fits_type_p (vr,\n+\t\t\t\t    TYPE_PRECISION (TREE_TYPE (op0)),\n+\t\t\t\t    TYPE_UNSIGNED (TREE_TYPE (op0))))\n \t    {\n \t      tree newconst = fold_convert (TREE_TYPE (innerop), op1);\n \t      gimple_cond_set_lhs (stmt, innerop);\n@@ -8809,57 +8858,6 @@ simplify_conversion_using_ranges (gimple stmt)\n   return true;\n }\n \n-/* Return whether the value range *VR fits in an integer type specified\n-   by PRECISION and UNSIGNED_P.  */\n-\n-static bool\n-range_fits_type_p (value_range_t *vr, unsigned precision, bool unsigned_p)\n-{\n-  tree src_type;\n-  unsigned src_precision;\n-  double_int tem;\n-\n-  /* We can only handle integral and pointer types.  */\n-  src_type = TREE_TYPE (vr->min);\n-  if (!INTEGRAL_TYPE_P (src_type)\n-      && !POINTER_TYPE_P (src_type))\n-    return false;\n-\n-  /* An extension is fine unless VR is signed and unsigned_p,\n-     and so is an identity transform.  */\n-  src_precision = TYPE_PRECISION (TREE_TYPE (vr->min));\n-  if ((src_precision < precision\n-       && !(unsigned_p && !TYPE_UNSIGNED (src_type)))\n-      || (src_precision == precision\n-\t  && TYPE_UNSIGNED (src_type) == unsigned_p))\n-    return true;\n-\n-  /* Now we can only handle ranges with constant bounds.  */\n-  if (vr->type != VR_RANGE\n-      || TREE_CODE (vr->min) != INTEGER_CST\n-      || TREE_CODE (vr->max) != INTEGER_CST)\n-    return false;\n-\n-  /* For sign changes, the MSB of the double_int has to be clear.\n-     An unsigned value with its MSB set cannot be represented by\n-     a signed double_int, while a negative value cannot be represented\n-     by an unsigned double_int.  */\n-  if (TYPE_UNSIGNED (src_type) != unsigned_p\n-      && (TREE_INT_CST_HIGH (vr->min) | TREE_INT_CST_HIGH (vr->max)) < 0)\n-    return false;\n-\n-  /* Then we can perform the conversion on both ends and compare\n-     the result for equality.  */\n-  tem = tree_to_double_int (vr->min).ext (precision, unsigned_p);\n-  if (tree_to_double_int (vr->min) != tem)\n-    return false;\n-  tem = tree_to_double_int (vr->max).ext (precision, unsigned_p);\n-  if (tree_to_double_int (vr->max) != tem)\n-    return false;\n-\n-  return true;\n-}\n-\n /* Simplify a conversion from integral SSA name to float in STMT.  */\n \n static bool"}]}