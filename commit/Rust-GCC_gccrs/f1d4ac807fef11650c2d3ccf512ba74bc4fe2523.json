{"sha": "f1d4ac807fef11650c2d3ccf512ba74bc4fe2523", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjFkNGFjODA3ZmVmMTE2NTBjMmQzY2NmNTEyYmE3NGJjNGZlMjUyMw==", "commit": {"author": {"name": "Michael Hayes", "email": "mhayes@redhat.com", "date": "2001-01-05T03:25:58Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "2001-01-05T03:25:58Z"}, "message": "loop.h (struct loop_reg): New.\n\n\t* loop.h (struct loop_reg): New.\n\t(struct loop_regs): Change to use array of `struct loop_reg'.\n\t* loop.c: Replace assortment of varrays with single regs array.\n\t(count_one_set): Delete may_not_move array argument\n\tand use regs array instead.  All caller's changed.\n\t(count_loop_regs_set): Delete may_not_move and single_usage\n\targuments and use regs array instead.  All caller's changed.\n\t(find_single_use_in_loop): Replace usage array argument with pointer\n\tto regs structure.  All caller's changed.\n\t(loop_optimize): Delete `moved_once' array.\n\nFrom-SVN: r38700", "tree": {"sha": "2894c78ef237e3fda3cd660020611673b41b3420", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2894c78ef237e3fda3cd660020611673b41b3420"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1d4ac807fef11650c2d3ccf512ba74bc4fe2523", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1d4ac807fef11650c2d3ccf512ba74bc4fe2523", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1d4ac807fef11650c2d3ccf512ba74bc4fe2523", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1d4ac807fef11650c2d3ccf512ba74bc4fe2523/comments", "author": null, "committer": null, "parents": [{"sha": "576d0b547dce3fbe4072cc41101b11faa7f47176", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/576d0b547dce3fbe4072cc41101b11faa7f47176", "html_url": "https://github.com/Rust-GCC/gccrs/commit/576d0b547dce3fbe4072cc41101b11faa7f47176"}], "stats": {"total": 376, "additions": 186, "deletions": 190}, "files": [{"sha": "2c117f2f446a0f754ec2c44eef5eab5882512044", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1d4ac807fef11650c2d3ccf512ba74bc4fe2523/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1d4ac807fef11650c2d3ccf512ba74bc4fe2523/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f1d4ac807fef11650c2d3ccf512ba74bc4fe2523", "patch": "@@ -1,5 +1,18 @@\n 2001-01-05  Michael Hayes  <mhayes@redhat.com>\n \n+\t* loop.h (struct loop_reg): New.\n+\t(struct loop_regs): Change to use array of `struct loop_reg'.\n+\t* loop.c: Replace assortment of varrays with single regs array.\n+\t(count_one_set): Delete may_not_move array argument\n+\tand use regs array instead.  All caller's changed.\n+\t(count_loop_regs_set): Delete may_not_move and single_usage\n+\targuments and use regs array instead.  All caller's changed.\n+\t(find_single_use_in_loop): Replace usage array argument with pointer\n+\tto regs structure.  All caller's changed.\n+\t(loop_optimize): Delete `moved_once' array.\n+\n+2001-01-05  Michael Hayes  <mhayes@redhat.com>\n+\t\n \t* loop.c (prescan_loop): Set loop_info->has_nonconst_call.\n \tUse it instead of loop_info->has_call for scanning loop mems.\n \t(check_dbra_loop): Replace loop_info->has_call test with"}, {"sha": "212f14e298e1b0cf578c16b1e086eba286895d1a", "filename": "gcc/loop.c", "status": "modified", "additions": 147, "deletions": 169, "changes": 316, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1d4ac807fef11650c2d3ccf512ba74bc4fe2523/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1d4ac807fef11650c2d3ccf512ba74bc4fe2523/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=f1d4ac807fef11650c2d3ccf512ba74bc4fe2523", "patch": "@@ -152,12 +152,9 @@ static int reg_in_basic_block_p PARAMS ((rtx, rtx));\n static int consec_sets_invariant_p PARAMS ((const struct loop *,\n \t\t\t\t\t    rtx, int, rtx));\n static int labels_in_range_p PARAMS ((rtx, int));\n-static void count_one_set PARAMS ((struct loop_regs *, rtx, rtx,\n-\t\t\t\t   varray_type, rtx *));\n+static void count_one_set PARAMS ((struct loop_regs *, rtx, rtx, rtx *));\n \n-static void count_loop_regs_set PARAMS ((const struct loop*,\n-\t\t\t\t\t varray_type, varray_type,\n-\t\t\t\t\t int *, int));\n+static void count_loop_regs_set PARAMS ((const struct loop *, int *));\n static void note_addr_stored PARAMS ((rtx, rtx, void *));\n static void note_set_pseudo_multiple_uses PARAMS ((rtx, rtx, void *));\n static int loop_reg_used_before_p PARAMS ((const struct loop *, rtx, rtx));\n@@ -196,7 +193,7 @@ static void loop_givs_rescan PARAMS((struct loop *, struct iv_class *,\n \t\t\t\t     rtx *, rtx));\n static void loop_ivs_free PARAMS((struct loop *));\n static void strength_reduce PARAMS ((struct loop *, int, int));\n-static void find_single_use_in_loop PARAMS ((rtx, rtx, varray_type));\n+static void find_single_use_in_loop PARAMS ((struct loop_regs *, rtx, rtx));\n static int valid_initial_value_p PARAMS ((rtx, rtx, int, rtx));\n static void find_mem_givs PARAMS ((const struct loop *, rtx, rtx, int, int));\n static void record_biv PARAMS ((struct loop *, struct induction *,\n@@ -346,7 +343,6 @@ loop_optimize (f, dumpfile, flags)\n   struct loops loops_data;\n   struct loops *loops = &loops_data;\n   struct loop_info *loops_info;\n-  static char *moved_once;\n \n   loop_dump_stream = dumpfile;\n \n@@ -373,8 +369,6 @@ loop_optimize (f, dumpfile, flags)\n \n   loops->num = max_loop_num;\n \n-  moved_once = (char *) xcalloc (max_reg_before_loop, sizeof (char));\n-\n   /* Get size to use for tables indexed by uids.\n      Leave some space for labels allocated by find_and_verify_loops.  */\n   max_uid_for_loop = get_max_uid () + 1 + max_loop_num * 32;\n@@ -444,9 +438,6 @@ loop_optimize (f, dumpfile, flags)\n   for (i = max_loop_num - 1; i >= 0; i--)\n     {\n       struct loop *loop = &loops->array[i];\n-      struct loop_regs *regs = LOOP_REGS (loop);\n-\n-      regs->moved_once = moved_once;\n \n       if (! loop->invalid && loop->end)\n \tscan_loop (loop, flags);\n@@ -462,7 +453,6 @@ loop_optimize (f, dumpfile, flags)\n   end_alias_analysis ();\n \n   /* Clean up.  */\n-  free (moved_once);\n   free (uid_luid);\n   free (uid_loop);\n   free (loops_info);\n@@ -540,7 +530,6 @@ scan_loop (loop, flags)\n   int threshold;\n   /* Nonzero if we are scanning instructions in a sub-loop.  */\n   int loop_depth = 0;\n-  int nregs;\n \n   loop->top = 0;\n \n@@ -622,42 +611,45 @@ scan_loop (loop, flags)\n     }\n \n   /* Count number of times each reg is set during this loop.  Set\n-     VARRAY_CHAR (regs->may_not_optimize, I) if it is not safe to move\n-     out the setting of register I.  Set VARRAY_RTX\n-     (regs->single_usage, I).  */\n+     regs->array[I].may_not_optimize if it is not safe to move out the\n+     setting of register I.  Set regs->array[I].single_usage.  */\n+\n+  regs->num = max_reg_num ();\n \n-  /* Allocate extra space for REGS that might be created by\n+  /* Allocate extra space for REGs that might be created by\n      load_mems.  We allocate a little extra slop as well, in the hopes\n      that even after the moving of movables creates some new registers\n      we won't have to reallocate these arrays.  However, we do grow\n      the arrays, if necessary, in load_mems_recount_loop_regs_set.  */\n-  nregs = max_reg_num () + loop_info->mems_idx + 16;\n-  VARRAY_INT_INIT (regs->set_in_loop, nregs, \"set_in_loop\");\n-  VARRAY_INT_INIT (regs->n_times_set, nregs, \"n_times_set\");\n-  VARRAY_CHAR_INIT (regs->may_not_optimize, nregs, \"may_not_optimize\");\n-  VARRAY_RTX_INIT (regs->single_usage, nregs, \"single_usage\");\n+  regs->size = regs->num + loop_info->mems_idx + 16;\n+  regs->array = (struct loop_reg *) \n+    xmalloc (regs->size * sizeof (*regs->array));\n \n-  regs->num = nregs;\n+  for (i = 0; i < regs->num; i++)\n+    {\n+      regs->array[i].set_in_loop = 0;\n+      regs->array[i].may_not_optimize = 0;\n+      regs->array[i].single_usage = NULL_RTX;\n+    }\n \n-  count_loop_regs_set (loop, regs->may_not_optimize, regs->single_usage,\n-\t\t       &insn_count, nregs);\n+  count_loop_regs_set (loop, &insn_count);\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {\n-      VARRAY_CHAR (regs->may_not_optimize, i) = 1;\n-      VARRAY_INT (regs->set_in_loop, i) = 1;\n+      regs->array[i].may_not_optimize = 1;\n+      regs->array[i].set_in_loop = 1;\n     }\n \n #ifdef AVOID_CCMODE_COPIES\n   /* Don't try to move insns which set CC registers if we should not\n      create CCmode register copies.  */\n-  for (i = max_reg_num () - 1; i >= FIRST_PSEUDO_REGISTER; i--)\n+  for (i = regs->num - 1; i >= FIRST_PSEUDO_REGISTER; i--)\n     if (GET_MODE_CLASS (GET_MODE (regno_reg_rtx[i])) == MODE_CC)\n-      VARRAY_CHAR (regs->may_not_optimize, i) = 1;\n+      regs->array[i].may_not_optimize = 1;\n #endif\n \n-  bcopy ((char *) &regs->set_in_loop->data,\n-\t (char *) &regs->n_times_set->data, nregs * sizeof (int));\n+  for (i = 0; i < regs->num; i++)\n+    regs->array[i].n_times_set = regs->array[i].set_in_loop;\n \n   if (loop_dump_stream)\n     {\n@@ -669,7 +661,7 @@ scan_loop (loop, flags)\n     }\n \n   /* Scan through the loop finding insns that are safe to move.\n-     Set regs->set_in_loop negative for the reg being set, so that\n+     Set REGS->ARRAY[I].SET_IN_LOOP negative for the reg I being set, so that\n      this reg will be considered invariant for subsequent insns.\n      We consider whether subsequent insns use the reg\n      in deciding whether it is worth actually moving.\n@@ -688,7 +680,7 @@ scan_loop (loop, flags)\n       if (GET_CODE (p) == INSN\n \t  && (set = single_set (p))\n \t  && GET_CODE (SET_DEST (set)) == REG\n-\t  && ! VARRAY_CHAR (regs->may_not_optimize, REGNO (SET_DEST (set))))\n+\t  && ! regs->array[REGNO (SET_DEST (set))].may_not_optimize)\n \t{\n \t  int tem1 = 0;\n \t  int tem2 = 0;\n@@ -752,13 +744,11 @@ scan_loop (loop, flags)\n \t  else if ((tem = loop_invariant_p (loop, src))\n \t\t   && (dependencies == 0\n \t\t       || (tem2 = loop_invariant_p (loop, dependencies)) != 0)\n-\t\t   && (VARRAY_INT (regs->set_in_loop,\n-\t\t\t\t   REGNO (SET_DEST (set))) == 1\n+\t\t   && (regs->array[REGNO (SET_DEST (set))].set_in_loop == 1\n \t\t       || (tem1\n \t\t\t   = consec_sets_invariant_p\n \t\t\t   (loop, SET_DEST (set),\n-\t\t\t    VARRAY_INT (regs->set_in_loop,\n-\t\t\t\t\tREGNO (SET_DEST (set))),\n+\t\t\t    regs->array[REGNO (SET_DEST (set))].set_in_loop,\n \t\t\t    p)))\n \t\t   /* If the insn can cause a trap (such as divide by zero),\n \t\t      can't move it unless it's guaranteed to be executed\n@@ -786,12 +776,12 @@ scan_loop (loop, flags)\n \t\t SMALL_REGISTER_CLASSES and SET_SRC is a hard register.  */\n \n \t      if (loop_info->has_call\n-\t\t  && VARRAY_RTX (regs->single_usage, regno) != 0\n-\t\t  && VARRAY_RTX (regs->single_usage, regno) != const0_rtx\n+\t\t  && regs->array[regno].single_usage != 0\n+\t\t  && regs->array[regno].single_usage != const0_rtx\n \t\t  && REGNO_FIRST_UID (regno) == INSN_UID (p)\n \t\t  && (REGNO_LAST_UID (regno)\n-\t\t      == INSN_UID (VARRAY_RTX (regs->single_usage, regno)))\n-\t\t  && VARRAY_INT (regs->set_in_loop, regno) == 1\n+\t\t      == INSN_UID (regs->array[regno].single_usage))\n+\t\t  && regs->array[regno].set_in_loop == 1\n \t\t  && ! side_effects_p (SET_SRC (set))\n \t\t  && ! find_reg_note (p, REG_RETVAL, NULL_RTX)\n \t\t  && (! SMALL_REGISTER_CLASSES\n@@ -801,26 +791,22 @@ scan_loop (loop, flags)\n \t\t     a call-clobbered register and the life of REGNO\n \t\t     might span a call.  */\n \t\t  && ! modified_between_p (SET_SRC (set), p,\n-\t\t\t\t\t   VARRAY_RTX\n-\t\t\t\t\t   (regs->single_usage, regno))\n-\t\t  && no_labels_between_p (p, VARRAY_RTX (regs->single_usage,\n-\t\t\t\t\t\t\t regno))\n+\t\t\t\t\t   regs->array[regno].single_usage)\n+\t\t  && no_labels_between_p (p, regs->array[regno].single_usage)\n \t\t  && validate_replace_rtx (SET_DEST (set), SET_SRC (set),\n-\t\t\t\t\t   VARRAY_RTX\n-\t\t\t\t\t   (regs->single_usage, regno)))\n+\t\t\t\t\t   regs->array[regno].single_usage))\n \t\t{\n \t\t  /* Replace any usage in a REG_EQUAL note.  Must copy the\n \t\t     new source, so that we don't get rtx sharing between the\n \t\t     SET_SOURCE and REG_NOTES of insn p.  */\n-\t\t  REG_NOTES (VARRAY_RTX (regs->single_usage, regno))\n-\t\t    = replace_rtx (REG_NOTES (VARRAY_RTX\n-\t\t\t\t\t      (regs->single_usage, regno)),\n+\t\t  REG_NOTES (regs->array[regno].single_usage)\n+\t\t    = replace_rtx (REG_NOTES (regs->array[regno].single_usage),\n \t\t\t\t   SET_DEST (set), copy_rtx (SET_SRC (set)));\n \n \t\t  PUT_CODE (p, NOTE);\n \t\t  NOTE_LINE_NUMBER (p) = NOTE_INSN_DELETED;\n \t\t  NOTE_SOURCE_FILE (p) = 0;\n-\t\t  VARRAY_INT (regs->set_in_loop, regno) = 0;\n+\t\t  regs->array[regno].set_in_loop = 0;\n \t\t  continue;\n \t\t}\n \n@@ -831,8 +817,7 @@ scan_loop (loop, flags)\n \t      m->dependencies = dependencies;\n \t      m->set_dest = SET_DEST (set);\n \t      m->force = 0;\n-\t      m->consec = VARRAY_INT (regs->set_in_loop,\n-\t\t\t\t      REGNO (SET_DEST (set))) - 1;\n+\t      m->consec = regs->array[REGNO (SET_DEST (set))].set_in_loop - 1;\n \t      m->done = 0;\n \t      m->forces = 0;\n \t      m->partial = 0;\n@@ -848,10 +833,10 @@ scan_loop (loop, flags)\n \t      m->global =  LOOP_REG_GLOBAL_P (loop, regno);\n \t      m->match = 0;\n \t      m->lifetime = LOOP_REG_LIFETIME (loop, regno);\n-\t      m->savings = VARRAY_INT (regs->n_times_set, regno);\n+\t      m->savings = regs->array[regno].n_times_set;\n \t      if (find_reg_note (p, REG_RETVAL, NULL_RTX))\n \t\tm->savings += libcall_benefit (p);\n-\t      VARRAY_INT (regs->set_in_loop, regno) = move_insn ? -2 : -1;\n+\t      regs->array[regno].set_in_loop = move_insn ? -2 : -1;\n \t      /* Add M to the end of the chain MOVABLES.  */\n \t      loop_movables_add (movables, m);\n \n@@ -906,7 +891,7 @@ scan_loop (loop, flags)\n \t\t   && !reg_mentioned_p (SET_DEST (set), SET_SRC (set1)))\n \t    {\n \t      register int regno = REGNO (SET_DEST (set));\n-\t      if (VARRAY_INT (regs->set_in_loop, regno) == 2)\n+\t      if (regs->array[regno].set_in_loop == 2)\n \t\t{\n \t\t  register struct movable *m;\n \t\t  m = (struct movable *) xmalloc (sizeof (struct movable));\n@@ -952,7 +937,7 @@ scan_loop (loop, flags)\n \t\t  m->match = 0;\n \t\t  m->lifetime = LOOP_REG_LIFETIME (loop, regno);\n \t\t  m->savings = 1;\n-\t\t  VARRAY_INT (regs->set_in_loop, regno) = -1;\n+\t\t  regs->array[regno].set_in_loop = -1;\n \t\t  /* Add M to the end of the chain MOVABLES.  */\n \t\t  loop_movables_add (movables, m);\n \t\t}\n@@ -1012,7 +997,7 @@ scan_loop (loop, flags)\n   combine_movables (movables, regs);\n \n   /* Now consider each movable insn to decide whether it is worth moving.\n-     Store 0 in regs->set_in_loop for each reg that is moved.\n+     Store 0 in regs->array[I].set_in_loop for each reg I that is moved.\n \n      Generally this increases code size, so do not move moveables when\n      optimizing for code size.  */\n@@ -1021,11 +1006,11 @@ scan_loop (loop, flags)\n     move_movables (loop, movables, threshold, insn_count);\n \n   /* Now candidates that still are negative are those not moved.\n-     Change regs->set_in_loop to indicate that those are not actually\n+     Change regs->array[I].set_in_loop to indicate that those are not actually\n      invariant.  */\n-  for (i = 0; i < nregs; i++)\n-    if (VARRAY_INT (regs->set_in_loop, i) < 0)\n-      VARRAY_INT (regs->set_in_loop, i) = VARRAY_INT (regs->n_times_set, i);\n+  for (i = 0; i < regs->num; i++)\n+    if (regs->array[i].set_in_loop < 0)\n+      regs->array[i].set_in_loop = regs->array[i].n_times_set;\n \n   /* Now that we've moved some things out of the loop, we might be able to\n      hoist even more memory references.  */\n@@ -1061,10 +1046,9 @@ scan_loop (loop, flags)\n   /* The movable information is required for strength reduction.  */\n   loop_movables_free (movables);\n \n-  VARRAY_FREE (regs->single_usage);\n-  VARRAY_FREE (regs->set_in_loop);\n-  VARRAY_FREE (regs->n_times_set);\n-  VARRAY_FREE (regs->may_not_optimize);\n+  free (regs->array);\n+  regs->array = 0;\n+  regs->num = 0;\n }\n \f\n /* Add elements to *OUTPUT to record all the pseudo-regs\n@@ -1343,7 +1327,7 @@ combine_movables (movables, regs)\n   /* Perhaps testing m->consec_sets would be more appropriate here?  */\n \n   for (m = movables->head; m; m = m->next)\n-    if (m->match == 0 && VARRAY_INT (regs->n_times_set, m->regno) == 1\n+    if (m->match == 0 && regs->array[m->regno].n_times_set == 1\n \t&& !m->partial)\n       {\n \tregister struct movable *m1;\n@@ -1355,8 +1339,8 @@ combine_movables (movables, regs)\n \t/* We want later insns to match the first one.  Don't make the first\n \t   one match any later ones.  So start this loop at m->next.  */\n \tfor (m1 = m->next; m1; m1 = m1->next)\n-\t  if (m != m1 && m1->match == 0 && VARRAY_INT (regs->n_times_set,\n-\t\t\t\t\t\t       m1->regno) == 1\n+\t  if (m != m1 && m1->match == 0 \n+\t      && regs->array[m1->regno].n_times_set == 1\n \t      /* A reg used outside the loop mustn't be eliminated.  */\n \t      && !m1->global\n \t      /* A reg used for zero-extending mustn't be eliminated.  */\n@@ -1498,16 +1482,15 @@ rtx_equal_for_loop_p (x, y, movables, regs)\n \n   /* If we have a register and a constant, they may sometimes be\n      equal.  */\n-  if (GET_CODE (x) == REG && VARRAY_INT (regs->set_in_loop, REGNO (x)) == -2\n+  if (GET_CODE (x) == REG && regs->array[REGNO (x)].set_in_loop == -2\n       && CONSTANT_P (y))\n     {\n       for (m = movables->head; m; m = m->next)\n \tif (m->move_insn && m->regno == REGNO (x)\n \t    && rtx_equal_p (m->set_src, y))\n \t  return 1;\n     }\n-  else if (GET_CODE (y) == REG && VARRAY_INT (regs->set_in_loop,\n-\t\t\t\t\t      REGNO (y)) == -2\n+  else if (GET_CODE (y) == REG && regs->array[REGNO (y)].set_in_loop == -2\n \t   && CONSTANT_P (x))\n     {\n       for (m = movables->head; m; m = m->next)\n@@ -1719,7 +1702,7 @@ move_movables (loop, movables, threshold, insn_count)\n \t  if (loop_dump_stream)\n \t    fprintf (loop_dump_stream, \"savings %d \", savings);\n \n-\t  if (regs->moved_once[regno] && loop_dump_stream)\n+\t  if (regs->array[regno].moved_once && loop_dump_stream)\n \t    fprintf (loop_dump_stream, \"halved since already moved \");\n \n \t  /* An insn MUST be moved if we already moved something else\n@@ -1738,9 +1721,9 @@ move_movables (loop, movables, threshold, insn_count)\n \t  if (already_moved[regno]\n \t      || flag_move_all_movables\n \t      || (threshold * savings * m->lifetime) >=\n-\t\t (regs->moved_once[regno] ? insn_count * 2 : insn_count)\n+\t\t (regs->array[regno].moved_once ? insn_count * 2 : insn_count)\n \t      || (m->forces && m->forces->done\n-\t\t  && VARRAY_INT (regs->n_times_set, m->forces->regno) == 1))\n+\t\t  && regs->array[m->forces->regno].n_times_set == 1))\n \t    {\n \t      int count;\n \t      register struct movable *m1;\n@@ -2046,11 +2029,11 @@ move_movables (loop, movables, threshold, insn_count)\n \t      already_moved[regno] = 1;\n \n \t      /* This reg has been moved out of one loop.  */\n-\t      regs->moved_once[regno] = 1;\n+\t      regs->array[regno].moved_once = 1;\n \n \t      /* The reg set here is now invariant.  */\n \t      if (! m->partial)\n-\t\tVARRAY_INT (regs->set_in_loop, regno) = 0;\n+\t\tregs->array[regno].set_in_loop = 0;\n \n \t      m->done = 1;\n \n@@ -2114,7 +2097,7 @@ move_movables (loop, movables, threshold, insn_count)\n \t\t      /* The reg merged here is now invariant,\n \t\t\t if the reg it matches is invariant.  */\n \t\t      if (! m->partial)\n-\t\t\tVARRAY_INT (regs->set_in_loop, m1->regno) = 0;\n+\t\t\tregs->array[m1->regno].set_in_loop = 0;\n \t\t    }\n \t    }\n \t  else if (loop_dump_stream)\n@@ -3031,8 +3014,8 @@ note_set_pseudo_multiple_uses (x, y, data)\n   /* If we do not have usage information, or if we know the register\n      is used more than once, note that fact for check_dbra_loop.  */\n   if (REGNO (x) >= max_reg_before_loop\n-      || ! VARRAY_RTX (regs->single_usage, REGNO (x))\n-      || VARRAY_RTX (regs->single_usage, REGNO (x)) == const0_rtx)\n+      || ! regs->array[REGNO (x)].single_usage\n+      || regs->array[REGNO (x)].single_usage == const0_rtx)\n     regs->multiple_uses = 1;\n }\n \f\n@@ -3100,10 +3083,10 @@ loop_invariant_p (loop, x)\n \t  && REGNO (x) < FIRST_PSEUDO_REGISTER && call_used_regs[REGNO (x)])\n \treturn 0;\n \n-      if (VARRAY_INT (regs->set_in_loop, REGNO (x)) < 0)\n+      if (regs->array[REGNO (x)].set_in_loop < 0)\n \treturn 2;\n \n-      return VARRAY_INT (regs->set_in_loop, REGNO (x)) == 0;\n+      return regs->array[REGNO (x)].set_in_loop == 0;\n \n     case MEM:\n       /* Volatile memory references must be rejected.  Do this before\n@@ -3188,15 +3171,15 @@ consec_sets_invariant_p (loop, reg, n_sets, insn)\n   rtx temp;\n   /* Number of sets we have to insist on finding after INSN.  */\n   int count = n_sets - 1;\n-  int old = VARRAY_INT (regs->set_in_loop, regno);\n+  int old = regs->array[regno].set_in_loop;\n   int value = 0;\n   int this;\n \n   /* If N_SETS hit the limit, we can't rely on its value.  */\n   if (n_sets == 127)\n     return 0;\n \n-  VARRAY_INT (regs->set_in_loop, regno) = 0;\n+  regs->array[regno].set_in_loop = 0;\n \n   while (count > 0)\n     {\n@@ -3235,12 +3218,12 @@ consec_sets_invariant_p (loop, reg, n_sets, insn)\n \tcount--;\n       else if (code != NOTE)\n \t{\n-\t  VARRAY_INT (regs->set_in_loop, regno) = old;\n+\t  regs->array[regno].set_in_loop = old;\n \t  return 0;\n \t}\n     }\n \n-  VARRAY_INT (regs->set_in_loop, regno) = old;\n+  regs->array[regno].set_in_loop = old;\n   /* If loop_invariant_p ever returned 2, we return 2.  */\n   return 1 + (value & 2);\n }\n@@ -3283,19 +3266,19 @@ all_sets_invariant_p (reg, insn, table)\n    a different insn, set USAGE[REGNO] to const0_rtx.  */\n \n static void\n-find_single_use_in_loop (insn, x, usage)\n+find_single_use_in_loop (regs, insn, x)\n+     struct loop_regs *regs;\n      rtx insn;\n      rtx x;\n-     varray_type usage;\n {\n   enum rtx_code code = GET_CODE (x);\n   const char *fmt = GET_RTX_FORMAT (code);\n   int i, j;\n \n   if (code == REG)\n-    VARRAY_RTX (usage, REGNO (x))\n-      = (VARRAY_RTX (usage, REGNO (x)) != 0\n-\t && VARRAY_RTX (usage, REGNO (x)) != insn)\n+    regs->array[REGNO (x)].single_usage\n+      = (regs->array[REGNO (x)].single_usage != 0\n+\t && regs->array[REGNO (x)].single_usage != insn)\n \t? const0_rtx : insn;\n \n   else if (code == SET)\n@@ -3305,34 +3288,34 @@ find_single_use_in_loop (insn, x, usage)\n \t show up as a potential movable so we don't care how USAGE is set\n \t for it.  */\n       if (GET_CODE (SET_DEST (x)) != REG)\n-\tfind_single_use_in_loop (insn, SET_DEST (x), usage);\n-      find_single_use_in_loop (insn, SET_SRC (x), usage);\n+\tfind_single_use_in_loop (regs, insn, SET_DEST (x));\n+      find_single_use_in_loop (regs, insn, SET_SRC (x));\n     }\n   else\n     for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n       {\n \tif (fmt[i] == 'e' && XEXP (x, i) != 0)\n-\t  find_single_use_in_loop (insn, XEXP (x, i), usage);\n+\t  find_single_use_in_loop (regs, insn, XEXP (x, i));\n \telse if (fmt[i] == 'E')\n \t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t    find_single_use_in_loop (insn, XVECEXP (x, i, j), usage);\n+\t    find_single_use_in_loop (regs, insn, XVECEXP (x, i, j));\n       }\n }\n \f\n /* Count and record any set in X which is contained in INSN.  Update\n-   MAY_NOT_MOVE and LAST_SET for any register set in X.  */\n+   REGS->array[I].MAY_NOT_OPTIMIZE and LAST_SET for any register I set\n+   in X.  */\n \n static void\n-count_one_set (regs, insn, x, may_not_move, last_set)\n+count_one_set (regs, insn, x, last_set)\n      struct loop_regs *regs;\n      rtx insn, x;\n-     varray_type may_not_move;\n      rtx *last_set;\n {\n   if (GET_CODE (x) == CLOBBER && GET_CODE (XEXP (x, 0)) == REG)\n     /* Don't move a reg that has an explicit clobber.\n        It's not worth the pain to try to do it correctly.  */\n-    VARRAY_CHAR (may_not_move, REGNO (XEXP (x, 0))) = 1;\n+    regs->array[REGNO (XEXP (x, 0))].may_not_optimize = 1;\n \n   if (GET_CODE (x) == SET || GET_CODE (x) == CLOBBER)\n     {\n@@ -3349,31 +3332,31 @@ count_one_set (regs, insn, x, may_not_move, last_set)\n \t     in current basic block, and it was set before,\n \t     it must be set in two basic blocks, so it cannot\n \t     be moved out of the loop.  */\n-\t  if (VARRAY_INT (regs->set_in_loop, regno) > 0\n-\t      && last_set[regno] == 0)\n-\t    VARRAY_CHAR (may_not_move, regno) = 1;\n+\t  if (regs->array[regno].set_in_loop > 0\n+\t      && last_set == 0)\n+\t    regs->array[regno].may_not_optimize = 1;\n \t  /* If this is not first setting in current basic block,\n \t     see if reg was used in between previous one and this.\n \t     If so, neither one can be moved.  */\n \t  if (last_set[regno] != 0\n \t      && reg_used_between_p (dest, last_set[regno], insn))\n-\t    VARRAY_CHAR (may_not_move, regno) = 1;\n-\t  if (VARRAY_INT (regs->set_in_loop, regno) < 127)\n-\t    ++VARRAY_INT (regs->set_in_loop, regno);\n+\t    regs->array[regno].may_not_optimize = 1;\n+\t  if (regs->array[regno].set_in_loop < 127)\n+\t    ++regs->array[regno].set_in_loop;\n \t  last_set[regno] = insn;\n \t}\n     }\n }\n \n-/* Increment REGS->SET_IN_LOOP at the index of each register\n-   that is modified by an insn between FROM and TO.\n-   If the value of an element of REGS->SET_IN_LOOP becomes 127 or more,\n-   stop incrementing it, to avoid overflow.\n+/* Increment REGS->array[I].SET_IN_LOOP at the index I of each\n+   register that is modified by an insn between FROM and TO.  If the\n+   value of an element of REGS->array[I].SET_IN_LOOP becomes 127 or\n+   more, stop incrementing it, to avoid overflow.\n \n-   Store in SINGLE_USAGE[I] the single insn in which register I is\n-   used, if it is only used once.  Otherwise, it is set to 0 (for no\n-   uses) or const0_rtx for more than one use.  This parameter may be zero,\n-   in which case this processing is not done.\n+   Store in REGS->array[I].SINGLE_USAGE[I] the single insn in which\n+   register I is used, if it is only used once.  Otherwise, it is set\n+   to 0 (for no uses) or const0_rtx for more than one use.  This\n+   parameter may be zero, in which case this processing is not done.\n \n    Store in *COUNT_PTR the number of actual instruction\n    in the loop.  We use this to decide what is worth moving out.  */\n@@ -3382,15 +3365,12 @@ count_one_set (regs, insn, x, may_not_move, last_set)\n    In that case, it is the insn that last set reg n.  */\n \n static void\n-count_loop_regs_set (loop, may_not_move, single_usage, count_ptr, nregs)\n+count_loop_regs_set (loop, count_ptr)\n      const struct loop *loop;\n-     varray_type may_not_move;\n-     varray_type single_usage;\n      int *count_ptr;\n-     int nregs;\n {\n   struct loop_regs *regs = LOOP_REGS (loop);\n-  register rtx *last_set = (rtx *) xcalloc (nregs, sizeof (rtx));\n+  register rtx *last_set = (rtx *) xcalloc (regs->num, sizeof (rtx));\n   register rtx insn;\n   register int count = 0;\n \n@@ -3402,26 +3382,26 @@ count_loop_regs_set (loop, may_not_move, single_usage, count_ptr, nregs)\n \t  ++count;\n \n \t  /* Record registers that have exactly one use.  */\n-\t  find_single_use_in_loop (insn, PATTERN (insn), single_usage);\n+\t  find_single_use_in_loop (regs, insn, PATTERN (insn));\n \n \t  /* Include uses in REG_EQUAL notes.  */\n \t  if (REG_NOTES (insn))\n-\t    find_single_use_in_loop (insn, REG_NOTES (insn), single_usage);\n+\t    find_single_use_in_loop (regs, insn, REG_NOTES (insn));\n \n \t  if (GET_CODE (PATTERN (insn)) == SET\n \t      || GET_CODE (PATTERN (insn)) == CLOBBER)\n-\t    count_one_set (regs, insn, PATTERN (insn), may_not_move, last_set);\n+\t    count_one_set (regs, insn, PATTERN (insn), last_set);\n \t  else if (GET_CODE (PATTERN (insn)) == PARALLEL)\n \t    {\n \t      register int i;\n \t      for (i = XVECLEN (PATTERN (insn), 0) - 1; i >= 0; i--)\n \t\tcount_one_set (regs, insn, XVECEXP (PATTERN (insn), 0, i),\n-\t\t\t       may_not_move, last_set);\n+\t\t\t       last_set);\n \t    }\n \t}\n \n       if (GET_CODE (insn) == CODE_LABEL || GET_CODE (insn) == JUMP_INSN)\n-\tmemset ((char *) last_set, 0, nregs * sizeof (rtx));\n+\tmemset ((char *) last_set, 0, regs->num * sizeof (rtx));\n     }\n   *count_ptr = count;\n \n@@ -3676,7 +3656,7 @@ loop_bivs_find (loop)\n       if (REG_IV_TYPE (ivs, bl->regno) != BASIC_INDUCT\n \t  /* Above happens if register modified by subreg, etc.  */\n \t  /* Make sure it is not recognized as a basic induction var: */\n-\t  || VARRAY_INT (regs->n_times_set, bl->regno) != bl->biv_count\n+\t  || regs->array[bl->regno].n_times_set != bl->biv_count\n \t  /* If never incremented, it is invariant that we decided not to\n \t     move.  So leave it alone.  */\n \t  || ! bl->incremented)\n@@ -4297,11 +4277,11 @@ loop_ivs_free (loop)\n /* Perform strength reduction and induction variable elimination.\n \n    Pseudo registers created during this function will be beyond the\n-   last valid index in several tables including regs->n_times_set and\n-   regno_last_uid.  This does not cause a problem here, because the\n-   added registers cannot be givs outside of their loop, and hence\n-   will never be reconsidered.  But scan_loop must check regnos to\n-   make sure they are in bounds.  */\n+   last valid index in several tables including\n+   REGS->ARRAY[I].N_TIMES_SET and REGNO_LAST_UID.  This does not cause a\n+   problem here, because the added registers cannot be givs outside of\n+   their loop, and hence will never be reconsidered.  But scan_loop\n+   must check regnos to make sure they are in bounds.  */\n \n static void\n strength_reduce (loop, insn_count, flags)\n@@ -4684,7 +4664,7 @@ check_insn_for_givs (loop, p, not_every_iteration, maybe_multiple)\n   if (GET_CODE (p) == INSN\n       && (set = single_set (p))\n       && GET_CODE (SET_DEST (set)) == REG\n-      && ! VARRAY_CHAR (regs->may_not_optimize, REGNO (SET_DEST (set))))\n+      && ! regs->array[REGNO (SET_DEST (set))].may_not_optimize)\n     {\n       rtx src_reg;\n       rtx dest_reg;\n@@ -4713,7 +4693,7 @@ check_insn_for_givs (loop, p, not_every_iteration, maybe_multiple)\n \t  /* Don't recognize a BASIC_INDUCT_VAR here.  */\n \t  && dest_reg != src_reg\n \t  /* This must be the only place where the register is set.  */\n-\t  && (VARRAY_INT (regs->n_times_set, REGNO (dest_reg)) == 1\n+\t  && (regs->array[REGNO (dest_reg)].n_times_set == 1\n \t      /* or all sets must be consecutive and make a giv.  */\n \t      || (benefit = consec_sets_giv (loop, benefit, p,\n \t\t\t\t\t     src_reg, dest_reg,\n@@ -4728,7 +4708,7 @@ check_insn_for_givs (loop, p, not_every_iteration, maybe_multiple)\n \t    benefit += libcall_benefit (p);\n \n \t  /* Skip the consecutive insns, if there are any.  */\n-\t  if (VARRAY_INT (regs->n_times_set, REGNO (dest_reg)) != 1)\n+\t  if (regs->array[REGNO (dest_reg)].n_times_set != 1)\n \t    p = last_consec_insn;\n \n \t  record_giv (loop, v, p, src_reg, dest_reg, mult_val, add_val,\n@@ -6136,7 +6116,7 @@ simplify_giv_expr (loop, x, ext_val, benefit)\n \t       less harmful than reducing many givs that are not really\n \t       beneficial.  */\n \t    {\n-\t      rtx single_use = VARRAY_RTX (regs->single_usage, REGNO (x));\n+\t      rtx single_use = regs->array[REGNO (x)].single_usage;\n \t      if (single_use && single_use != const0_rtx)\n \t\t*benefit += v->benefit;\n \t    }\n@@ -6380,7 +6360,7 @@ consec_sets_giv (loop, first_benefit, p, src_reg, dest_reg,\n   REG_IV_TYPE (ivs, REGNO (dest_reg)) = GENERAL_INDUCT;\n   REG_IV_INFO (ivs, REGNO (dest_reg)) = v;\n \n-  count = VARRAY_INT (regs->n_times_set, REGNO (dest_reg)) - 1;\n+  count = regs->array[REGNO (dest_reg)].n_times_set - 1;\n \n   while (count > 0)\n     {\n@@ -6938,8 +6918,7 @@ combine_givs (regs, bl)\n \t DEST_ADDR targets on hosts with reg+reg addressing, though it can\n \t be seen elsewhere as well.  */\n       if (g1->giv_type == DEST_REG\n-\t  && (single_use = VARRAY_RTX (regs->single_usage,\n-\t\t\t\t       REGNO (g1->dest_reg)))\n+\t  && (single_use = regs->array[REGNO (g1->dest_reg)].single_usage)\n \t  && single_use != const0_rtx)\n \tcontinue;\n \n@@ -8798,64 +8777,64 @@ insert_loop_mem (mem, data)\n   return 0;\n }\n \n-/* Like load_mems, but also ensures that REGS->SET_IN_LOOP,\n-   REGS->MAY_NOT_OPTIMIZE, REGS->SINGLE_USAGE, and INSN_COUNT have the correct\n-   values after load_mems.  */\n+/* Like load_mems, but also ensures that REGS->array[I].SET_IN_LOOP,\n+   REGS->array[I].MAY_NOT_OPTIMIZE, REGS->array[I].SINGLE_USAGE, and\n+   INSN_COUNT have the correct values after load_mems.  */\n \n static void\n load_mems_and_recount_loop_regs_set (loop, insn_count)\n      const struct loop *loop;\n      int *insn_count;\n {\n   struct loop_regs *regs = LOOP_REGS (loop);\n-  int nregs = max_reg_num ();\n \n   load_mems (loop);\n \n-  /* Recalculate regs->set_in_loop and friends since load_mems may have\n-     created new registers.  */\n-  if (max_reg_num () > nregs)\n+  /* Recalculate regs->array since load_mems may have created new\n+     registers.  */\n+  if (max_reg_num () > regs->num)\n     {\n       int i;\n       int old_nregs;\n \n-      old_nregs = nregs;\n-      nregs = max_reg_num ();\n+      old_nregs = regs->num;\n+      regs->num = max_reg_num ();\n+\n+      if (regs->num >= regs->size)\n+\t{\n+\t  regs->size = regs->num;\n+\n+\t  /* Grow the array.  */\n+\t  regs->array = (struct loop_reg *)\n+\t    xrealloc (regs->array, regs->size * sizeof (*regs->array));\n+\t}\n \n-      if ((unsigned) nregs > regs->set_in_loop->num_elements)\n+      for (i = 0; i < regs->num; i++)\n \t{\n-\t  /* Grow all the arrays.  */\n-\t  VARRAY_GROW (regs->set_in_loop, nregs);\n-\t  VARRAY_GROW (regs->n_times_set, nregs);\n-\t  VARRAY_GROW (regs->may_not_optimize, nregs);\n-\t  VARRAY_GROW (regs->single_usage, nregs);\n+\t  regs->array[i].set_in_loop = 0;\n+\t  regs->array[i].may_not_optimize = 0;\n+\t  regs->array[i].single_usage = NULL_RTX;\n \t}\n-      /* Clear the arrays */\n-      memset ((char *) &regs->set_in_loop->data, 0, nregs * sizeof (int));\n-      memset ((char *) &regs->may_not_optimize->data, 0, nregs * sizeof (char));\n-      memset ((char *) &regs->single_usage->data, 0, nregs * sizeof (rtx));\n \n-      count_loop_regs_set (loop, regs->may_not_optimize, regs->single_usage,\n-\t\t\t   insn_count, nregs);\n+      count_loop_regs_set (loop, insn_count);\n \n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \t{\n-\t  VARRAY_CHAR (regs->may_not_optimize, i) = 1;\n-\t  VARRAY_INT (regs->set_in_loop, i) = 1;\n+\t  regs->array[i].may_not_optimize = 1;\n+\t  regs->array[i].set_in_loop = 1;\n \t}\n \n #ifdef AVOID_CCMODE_COPIES\n       /* Don't try to move insns which set CC registers if we should not\n \t create CCmode register copies.  */\n-      for (i = max_reg_num () - 1; i >= FIRST_PSEUDO_REGISTER; i--)\n+      for (i = regs->num - 1; i >= FIRST_PSEUDO_REGISTER; i--)\n \tif (GET_MODE_CLASS (GET_MODE (regno_reg_rtx[i])) == MODE_CC)\n-\t  VARRAY_CHAR (regs->may_not_optimize, i) = 1;\n+\t  regs->array[i].may_not_optimize = 1;\n #endif\n \n-      /* Set regs->n_times_set for the new registers.  */\n-      bcopy ((char *) (&regs->set_in_loop->data.i[0] + old_nregs),\n-\t     (char *) (&regs->n_times_set->data.i[0] + old_nregs),\n-\t     (nregs - old_nregs) * sizeof (int));\n+      /* Set regs->array[I].n_times_set for the new registers.  */\n+      for (i = old_nregs; i < regs->num; i++)\n+\tregs->array[i].n_times_set = regs->array[i].set_in_loop;\n     }\n }\n \n@@ -9042,8 +9021,7 @@ load_mems (loop)\n \t\t  && GET_CODE (SET_DEST (set)) == REG\n \t\t  && REGNO (SET_DEST (set)) >= FIRST_PSEUDO_REGISTER\n \t\t  && REGNO (SET_DEST (set)) < last_max_reg\n-\t\t  && VARRAY_INT (regs->n_times_set,\n-\t\t\t\t REGNO (SET_DEST (set))) == 1\n+\t\t  && regs->array[REGNO (SET_DEST (set))].n_times_set == 1\n \t\t  && rtx_equal_p (SET_SRC (set), mem))\n \t\tSET_REGNO_REG_SET (&load_copies, REGNO (SET_DEST (set)));\n \n@@ -9057,7 +9035,7 @@ load_mems (loop)\n \t\t  && GET_CODE (SET_SRC (set)) == REG\n \t\t  && REGNO (SET_SRC (set)) >= FIRST_PSEUDO_REGISTER\n \t\t  && REGNO (SET_SRC (set)) < last_max_reg\n-\t\t  && VARRAY_INT (regs->n_times_set, REGNO (SET_SRC (set))) == 1\n+\t\t  && regs->array[REGNO (SET_SRC (set))].n_times_set == 1\n \t\t  && rtx_equal_p (SET_DEST (set), mem))\n \t\tSET_REGNO_REG_SET (&store_copies, REGNO (SET_SRC (set)));\n "}, {"sha": "1bdae73d9e713f0aa30ecc1d6594d7ab0094de3c", "filename": "gcc/loop.h", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1d4ac807fef11650c2d3ccf512ba74bc4fe2523/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1d4ac807fef11650c2d3ccf512ba74bc4fe2523/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=f1d4ac807fef11650c2d3ccf512ba74bc4fe2523", "patch": "@@ -18,7 +18,6 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-#include \"varray.h\"\n #include \"bitmap.h\"\n \n /* Flags passed to loop_optimize.  */\n@@ -236,44 +235,50 @@ typedef struct loop_mem_info\n } loop_mem_info;\n \n \n-struct loop_regs\n-{\n-  int num;\n \n-  /* Indexed by register number, contains the number of times the reg\n-     is set during the loop being scanned.\n-     During code motion, a negative value indicates a reg that has been\n-     made a candidate; in particular -2 means that it is an candidate that\n-     we know is equal to a constant and -1 means that it is an candidate\n-     not known equal to a constant.\n-     After code motion, regs moved have 0 (which is accurate now)\n-     while the failed candidates have the original number of times set.\n+struct loop_reg\n+{\n+  /* Number of times the reg is set during the loop being scanned.\n+     During code motion, a negative value indicates a reg that has\n+     been made a candidate; in particular -2 means that it is an\n+     candidate that we know is equal to a constant and -1 means that\n+     it is an candidate not known equal to a constant.  After code\n+     motion, regs moved have 0 (which is accurate now) while the\n+     failed candidates have the original number of times set.\n \n      Therefore, at all times, == 0 indicates an invariant register;\n      < 0 a conditionally invariant one.  */\n-  varray_type set_in_loop;\n+  int set_in_loop;\n \n   /* Original value of set_in_loop; same except that this value\n      is not set negative for a reg whose sets have been made candidates\n      and not set to 0 for a reg that is moved.  */\n-  varray_type n_times_set;\n-\n-  /* Index by register number, 1 indicates that the register\n-     cannot be moved or strength reduced.  */\n-  varray_type may_not_optimize;\n+  int n_times_set;\n \n   /* Contains the insn in which a register was used if it was used\n      exactly once; contains const0_rtx if it was used more than once.  */\n-  varray_type single_usage;\n+  rtx single_usage;\n+\n+  /* Nonzero indicates that the register cannot be moved or strength\n+     reduced.  */\n+  char may_not_optimize;\n \n   /* Nonzero means reg N has already been moved out of one loop.\n      This reduces the desire to move it out of another.  */\n-  char *moved_once;\n+  char moved_once;\n+};\n+\n \n-  int multiple_uses;\n+struct loop_regs\n+{\n+  int num;\t\t\t/* Number of regs used in table.  */\n+  int size;\t\t\t/* Size of table.  */\n+  struct loop_reg *array;\t/* Register usage info. array.  */\n+  int multiple_uses;\t\t/* Nonzero if a reg has multiple uses.  */\n };\n \n \n+\n struct loop_movables\n {\n   /* Head of movable chain.  */"}]}