{"sha": "4fc026cde962981346b29d5040d3012d5292f811", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGZjMDI2Y2RlOTYyOTgxMzQ2YjI5ZDUwNDBkMzAxMmQ1MjkyZjgxMQ==", "commit": {"author": {"name": "Catherine Moore", "email": "clm@cygnus.com", "date": "1999-10-29T15:23:41Z"}, "committer": {"name": "Catherine Moore", "email": "clm@gcc.gnu.org", "date": "1999-10-29T15:23:41Z"}, "message": "expr.c (emit_push_insn): New argument alignment_pad.\n\n        * expr.c (emit_push_insn): New argument alignment_pad.\n        Update all callers.  Adjust stack pointer based on alignment pad.\n        * function.c (pad_to_arg_alignment):  New argument alignment_pad.\n        Update all callers.  Track alignment_pad if boundary > PARM_BOUNDARY.\n        (locate_and_pad_parm): New argument alignment_pad.  Update all\n        callers.\n        * expr.h (emit_push_insn): Update prototype.\n        (locate_and_pad_parm): Update prototype.\n        * calls.c (arg_data):  Add new field alignment_pad.\n        (initialize_argument_information): Initialize alignment_pad.\n\nFrom-SVN: r30257", "tree": {"sha": "2c9f9156ff6a888e6ebe7a498f91f18465ee6e1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c9f9156ff6a888e6ebe7a498f91f18465ee6e1a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4fc026cde962981346b29d5040d3012d5292f811", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fc026cde962981346b29d5040d3012d5292f811", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fc026cde962981346b29d5040d3012d5292f811", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fc026cde962981346b29d5040d3012d5292f811/comments", "author": null, "committer": null, "parents": [{"sha": "5faf03ae77a43db0e5a685a01eb5b4023b09638f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5faf03ae77a43db0e5a685a01eb5b4023b09638f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5faf03ae77a43db0e5a685a01eb5b4023b09638f"}], "stats": {"total": 88, "additions": 70, "deletions": 18}, "files": [{"sha": "68090e2a931a6790ee177f2ab891f4fd4aafe2fd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fc026cde962981346b29d5040d3012d5292f811/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fc026cde962981346b29d5040d3012d5292f811/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4fc026cde962981346b29d5040d3012d5292f811", "patch": "@@ -1,3 +1,16 @@\n+Fri Oct 29 08:03:57 1999  Catherine Moore  <clm@cygnus.com>\n+\n+\t* expr.c (emit_push_insn): New argument alignment_pad.\n+\tUpdate all callers.  Adjust stack pointer based on alignment pad.\n+\t* function.c (pad_to_arg_alignment):  New argument alignment_pad.\n+\tUpdate all callers.  Track alignment_pad if boundary > PARM_BOUNDARY.\n+\t(locate_and_pad_parm): New argument alignment_pad.  Update all\n+\tcallers.\n+\t* expr.h (emit_push_insn): Update prototype.\n+\t(locate_and_pad_parm): Update prototype.\n+\t* calls.c (arg_data):  Add new field alignment_pad.\n+\t(initialize_argument_information): Initialize alignment_pad.\n+\n Fri Oct 29 02:51:35 1999  Mark Mitchell  <mark@codesourcery.com>\n \n \t* except.c (free_eh_nesting_info): Free the info itself."}, {"sha": "b17d1971fdf55bfd21d80002731c4abbf10648a6", "filename": "gcc/calls.c", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fc026cde962981346b29d5040d3012d5292f811/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fc026cde962981346b29d5040d3012d5292f811/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=4fc026cde962981346b29d5040d3012d5292f811", "patch": "@@ -106,6 +106,9 @@ struct arg_data\n      word-sized pseudos we made.  */\n   rtx *aligned_regs;\n   int n_aligned_regs;\n+  /* The amount that the stack pointer needs to be adjusted to\n+     force alignment for the next argument.  */\n+  struct args_size alignment_pad;\n };\n \n #ifdef ACCUMULATE_OUTGOING_ARGS\n@@ -898,6 +901,7 @@ initialize_argument_information (num_actuals, args, args_size, n_named_args,\n   /* Count arg position in order args appear.  */\n   int argpos;\n \n+  struct args_size alignment_pad;\n   int i;\n   tree p;\n   \n@@ -1093,12 +1097,14 @@ initialize_argument_information (num_actuals, args, args_size, n_named_args,\n \t\t\t     args[i].reg != 0,\n #endif\n \t\t\t     fndecl, args_size, &args[i].offset,\n-\t\t\t     &args[i].size);\n+\t\t\t     &args[i].size, &alignment_pad);\n \n #ifndef ARGS_GROW_DOWNWARD\n       args[i].slot_offset = *args_size;\n #endif\n \n+      args[i].alignment_pad = alignment_pad;\n+\n       /* If a part of the arg was put into registers,\n \t don't include that part in the amount pushed.  */\n       if (reg_parm_stack_space == 0 && ! args[i].pass_on_stack)\n@@ -2688,7 +2694,7 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n       locate_and_pad_parm (mode, NULL_TREE,\n \t\t\t   argvec[count].reg && argvec[count].partial == 0,\n \t\t\t   NULL_TREE, &args_size, &argvec[count].offset,\n-\t\t\t   &argvec[count].size);\n+\t\t\t   &argvec[count].size, &alignment_pad);\n \n       if (argvec[count].size.var)\n \tabort ();\n@@ -2917,7 +2923,7 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n #endif\n \t  emit_push_insn (val, mode, NULL_TREE, NULL_RTX, 0, partial, reg, 0,\n \t\t\t  argblock, GEN_INT (argvec[argnum].offset.constant),\n-\t\t\t  reg_parm_stack_space);\n+\t\t\t  reg_parm_stack_space, ARGS_SIZE_RTX (alignment_pad));\n \n #ifdef ACCUMULATE_OUTGOING_ARGS\n \t  /* Now mark the segment we just used.  */\n@@ -3072,6 +3078,7 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n   rtx fun;\n   int inc;\n   int count;\n+  struct args_size alignment_pad;\n   rtx argblock = 0;\n   CUMULATIVE_ARGS args_so_far;\n   struct arg { rtx value; enum machine_mode mode; rtx reg; int partial;\n@@ -3192,7 +3199,7 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n       locate_and_pad_parm (Pmode, NULL_TREE,\n \t\t\t   argvec[count].reg && argvec[count].partial == 0,\n \t\t\t   NULL_TREE, &args_size, &argvec[count].offset,\n-\t\t\t   &argvec[count].size);\n+\t\t\t   &argvec[count].size, &alignment_pad);\n \n \n       if (argvec[count].reg == 0 || argvec[count].partial != 0\n@@ -3258,7 +3265,7 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n       locate_and_pad_parm (mode, NULL_TREE,\n \t\t\t   argvec[count].reg && argvec[count].partial == 0,\n \t\t\t   NULL_TREE, &args_size, &argvec[count].offset,\n-\t\t\t   &argvec[count].size);\n+\t\t\t   &argvec[count].size, &alignment_pad);\n \n       if (argvec[count].size.var)\n \tabort ();\n@@ -3486,7 +3493,7 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n #endif\n \t  emit_push_insn (val, mode, NULL_TREE, NULL_RTX, 0, partial, reg, 0,\n \t\t\t  argblock, GEN_INT (argvec[argnum].offset.constant),\n-\t\t\t  reg_parm_stack_space);\n+\t\t\t  reg_parm_stack_space, ARGS_SIZE_RTX (alignment_pad));\n \n #ifdef ACCUMULATE_OUTGOING_ARGS\n \t  /* Now mark the segment we just used.  */\n@@ -3636,6 +3643,7 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n   highest_outgoing_arg_in_use = initial_highest_arg_in_use;\n   stack_usage_map = initial_stack_usage_map;\n #endif\n+  struct args_size alignment_pad;\n \n   return value;\n }\n@@ -3899,7 +3907,9 @@ store_one_arg (arg, argblock, may_be_alloca, variable_size,\n \t This can either be done with push or copy insns.  */\n       emit_push_insn (arg->value, arg->mode, TREE_TYPE (pval), NULL_RTX, 0,\n \t\t      partial, reg, used - size, argblock,\n-\t\t      ARGS_SIZE_RTX (arg->offset), reg_parm_stack_space);\n+\t\t      ARGS_SIZE_RTX (arg->offset), reg_parm_stack_space,\n+\t\t      ARGS_SIZE_RTX (arg->alignment_pad));\n+\n     }\n   else\n     {\n@@ -3932,7 +3942,8 @@ store_one_arg (arg, argblock, may_be_alloca, variable_size,\n       emit_push_insn (arg->value, arg->mode, TREE_TYPE (pval), size_rtx,\n \t\t      TYPE_ALIGN (TREE_TYPE (pval)) / BITS_PER_UNIT, partial,\n \t\t      reg, excess, argblock, ARGS_SIZE_RTX (arg->offset),\n-\t\t      reg_parm_stack_space);\n+\t\t      reg_parm_stack_space,\n+\t\t      ARGS_SIZE_RTX (arg->alignment_pad));\n     }\n \n "}, {"sha": "36559608720f7326b3592932b0a9d4af23889b1b", "filename": "gcc/expr.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fc026cde962981346b29d5040d3012d5292f811/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fc026cde962981346b29d5040d3012d5292f811/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=4fc026cde962981346b29d5040d3012d5292f811", "patch": "@@ -2870,7 +2870,8 @@ get_push_address (size)\n \n void\n emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n-\t\targs_addr, args_so_far, reg_parm_stack_space)\n+\t\targs_addr, args_so_far, reg_parm_stack_space,\n+                alignment_pad)\n      register rtx x;\n      enum machine_mode mode;\n      tree type;\n@@ -2882,6 +2883,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n      rtx args_addr;\n      rtx args_so_far;\n      int reg_parm_stack_space;\n+     rtx alignment_pad;\n {\n   rtx xinner;\n   enum direction stack_direction\n@@ -3176,7 +3178,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t\t\t  0, args_addr,\n \t\t\t  GEN_INT (args_offset + ((i - not_stack + skip)\n \t\t\t\t\t\t  * UNITS_PER_WORD)),\n-\t\t\t  reg_parm_stack_space);\n+\t\t\t  reg_parm_stack_space, alignment_pad);\n     }\n   else\n     {\n@@ -3248,6 +3250,9 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \n   if (extra && args_addr == 0 && where_pad == stack_direction)\n     anti_adjust_stack (GEN_INT (extra));\n+ \n+  if (alignment_pad)\n+    anti_adjust_stack (alignment_pad);\n }\n \f\n /* Expand an assignment that stores the value of FROM into TO."}, {"sha": "816b86dcef5ad1ce6a3fcc30630b7b8489e27c57", "filename": "gcc/expr.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fc026cde962981346b29d5040d3012d5292f811/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fc026cde962981346b29d5040d3012d5292f811/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=4fc026cde962981346b29d5040d3012d5292f811", "patch": "@@ -983,7 +983,7 @@ extern rtx gen_push_operand PROTO((void));\n #ifdef TREE_CODE\n /* Generate code to push something onto the stack, given its mode and type.  */\n extern void emit_push_insn PROTO((rtx, enum machine_mode, tree, rtx, int,\n-\t\t\t\t  int, rtx, int, rtx, rtx, int));\n+\t\t\t\t  int, rtx, int, rtx, rtx, int, rtx));\n \n /* Emit library call.  */\n extern void emit_library_call PVPROTO((rtx orgfun, int no_queue,\n@@ -1075,7 +1075,7 @@ extern rtx expand_call PROTO((tree, rtx, int));\n \n extern rtx expand_shift PROTO((enum tree_code, enum machine_mode, rtx, tree, rtx, int));\n extern rtx expand_divmod PROTO((int, enum tree_code, enum machine_mode, rtx, rtx, rtx, int));\n-extern void locate_and_pad_parm PROTO((enum machine_mode, tree, int, tree, struct args_size *, struct args_size *, struct args_size *));\n+extern void locate_and_pad_parm PROTO((enum machine_mode, tree, int, tree, struct args_size *, struct args_size *, struct args_size *, struct args_size *));\n extern rtx expand_inline_function PROTO((tree, tree, rtx, int, tree, rtx));\n /* Return the CODE_LABEL rtx for a LABEL_DECL, creating it if necessary.  */\n extern rtx label_rtx PROTO((tree));"}, {"sha": "847dcdf0f87d854d7e98b15f8133297b2aabdfb4", "filename": "gcc/function.c", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fc026cde962981346b29d5040d3012d5292f811/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fc026cde962981346b29d5040d3012d5292f811/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=4fc026cde962981346b29d5040d3012d5292f811", "patch": "@@ -252,7 +252,7 @@ static void instantiate_decls_1\tPROTO((tree, int));\n static void instantiate_decl\tPROTO((rtx, int, int));\n static int instantiate_virtual_regs_1 PROTO((rtx *, rtx, int));\n static void delete_handlers\tPROTO((void));\n-static void pad_to_arg_alignment PROTO((struct args_size *, int));\n+static void pad_to_arg_alignment PROTO((struct args_size *, int, struct args_size *));\n #ifndef ARGS_GROW_DOWNWARD\n static void pad_below\t\tPROTO((struct args_size *, enum  machine_mode,\n \t\t\t\t       tree));\n@@ -3957,6 +3957,7 @@ assign_parms (fndecl)\n   int varargs_setup = 0;\n #endif\n   rtx conversion_insns = 0;\n+  struct args_size alignment_pad;\n \n   /* Nonzero if the last arg is named `__builtin_va_alist',\n      which is used on some machines for old-fashioned non-ANSI varargs.h;\n@@ -4169,7 +4170,8 @@ assign_parms (fndecl)\n \t\t\t\t\t pretend_named) != 0,\n #endif\n #endif\n-\t\t\t   fndecl, &stack_args_size, &stack_offset, &arg_size);\n+\t\t\t   fndecl, &stack_args_size, &stack_offset, &arg_size,\n+                           &alignment_pad);\n \n       {\n \trtx offset_rtx = ARGS_SIZE_RTX (stack_offset);\n@@ -4861,14 +4863,17 @@ promoted_input_arg (regno, pmode, punsignedp)\n \n void\n locate_and_pad_parm (passed_mode, type, in_regs, fndecl,\n-\t\t     initial_offset_ptr, offset_ptr, arg_size_ptr)\n+\t\t     initial_offset_ptr, offset_ptr, arg_size_ptr,\n+                     alignment_pad)\n      enum machine_mode passed_mode;\n      tree type;\n      int in_regs;\n      tree fndecl ATTRIBUTE_UNUSED;\n      struct args_size *initial_offset_ptr;\n      struct args_size *offset_ptr;\n      struct args_size *arg_size_ptr;\n+     struct args_size *alignment_pad;\n+\n {\n   tree sizetree\n     = type ? size_in_bytes (type) : size_int (GET_MODE_SIZE (passed_mode));\n@@ -4923,7 +4928,7 @@ locate_and_pad_parm (passed_mode, type, in_regs, fndecl,\n     sizetree = round_up (sizetree, PARM_BOUNDARY / BITS_PER_UNIT);\n   SUB_PARM_SIZE (*offset_ptr, sizetree);\n   if (where_pad != downward)\n-    pad_to_arg_alignment (offset_ptr, boundary);\n+    pad_to_arg_alignment (offset_ptr, boundary, alignment_pad);\n   if (initial_offset_ptr->var)\n     {\n       arg_size_ptr->var = size_binop (MINUS_EXPR,\n@@ -4938,7 +4943,7 @@ locate_and_pad_parm (passed_mode, type, in_regs, fndecl,\n \t\t\t\t- offset_ptr->constant); \n     }\n #else /* !ARGS_GROW_DOWNWARD */\n-  pad_to_arg_alignment (initial_offset_ptr, boundary);\n+  pad_to_arg_alignment (initial_offset_ptr, boundary, alignment_pad);\n   *offset_ptr = *initial_offset_ptr;\n \n #ifdef PUSH_ROUNDING\n@@ -4967,12 +4972,26 @@ locate_and_pad_parm (passed_mode, type, in_regs, fndecl,\n    BOUNDARY is measured in bits, but must be a multiple of a storage unit.  */\n \n static void\n-pad_to_arg_alignment (offset_ptr, boundary)\n+pad_to_arg_alignment (offset_ptr, boundary, alignment_pad)\n      struct args_size *offset_ptr;\n      int boundary;\n+     struct args_size *alignment_pad;\n {\n+  tree save_var;\n+  HOST_WIDE_INT save_constant;\n+\n   int boundary_in_bytes = boundary / BITS_PER_UNIT;\n   \n+  if (boundary > PARM_BOUNDARY)\n+    {\n+      save_var = offset_ptr->var;\n+      save_constant = offset_ptr->constant;\n+    }\n+\n+  alignment_pad->var = NULL_TREE;\n+  alignment_pad->constant = 0;\n+  /* END CYGNUS LOCAL */\n+\n   if (boundary > BITS_PER_UNIT)\n     {\n       if (offset_ptr->var)\n@@ -4986,6 +5005,8 @@ pad_to_arg_alignment (offset_ptr, boundary)\n \t      (ARGS_SIZE_TREE (*offset_ptr),\n \t       boundary / BITS_PER_UNIT);\n \t  offset_ptr->constant = 0; /*?*/\n+          if (boundary > PARM_BOUNDARY)\n+            alignment_pad->var = size_binop (MINUS_EXPR, offset_ptr->var, save_var);\n \t}\n       else\n \toffset_ptr->constant =\n@@ -4994,6 +5015,8 @@ pad_to_arg_alignment (offset_ptr, boundary)\n #else\n \t  CEIL_ROUND (offset_ptr->constant, boundary_in_bytes);\n #endif\n+        if (boundary > PARM_BOUNDARY)\n+          alignment_pad->constant = offset_ptr->constant - save_constant;\n     }\n }\n "}]}