{"sha": "50e9ff8378be0c7353d3f3fb6fa4e4dc3c3367e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTBlOWZmODM3OGJlMGM3MzUzZDNmM2ZiNmZhNGU0ZGMzYzMzNjdlNg==", "commit": {"author": {"name": "James Greenhalgh", "email": "james.greenhalgh@arm.com", "date": "2014-12-06T19:19:37Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2014-12-06T19:19:37Z"}, "message": "extend jump thread for finite state automata\n\n\tPR tree-optimization/54742\n\t* params.def (max-fsm-thread-path-insns, max-fsm-thread-length,\n\tmax-fsm-thread-paths): New.\n\n\t* doc/invoke.texi (max-fsm-thread-path-insns, max-fsm-thread-length,\n\tmax-fsm-thread-paths): Documented.\n\n\t* tree-cfg.c (split_edge_bb_loc): Export.\n\t* tree-cfg.h (split_edge_bb_loc): Declared extern.\n\n\t* tree-ssa-threadedge.c (simplify_control_stmt_condition): Restore the\n\toriginal value of cond when simplification fails.\n\t(fsm_find_thread_path): New.\n\t(fsm_find_control_statement_thread_paths): New.\n\t(thread_through_normal_block): Call find_control_statement_thread_paths.\n\n\t* tree-ssa-threadupdate.c (dump_jump_thread_path): Pretty print\n\tEDGE_FSM_THREAD.\n\t(verify_seme): New.\n\t(duplicate_seme_region): New.\n\t(thread_through_all_blocks): Generate code for EDGE_FSM_THREAD edges\n\tcalling duplicate_seme_region.\n\n\t* tree-ssa-threadupdate.h (jump_thread_edge_type): Add EDGE_FSM_THREAD.\n\n\t* testsuite/gcc.dg/tree-ssa/ssa-dom-thread-6.c: New test.\n\t* testsuite/gcc.dg/tree-ssa/ssa-dom-thread-7.c: New test.\n\nCo-Authored-By: Brian Rzycki <b.rzycki@samsung.com>\nCo-Authored-By: Sebastian Pop <s.pop@samsung.com>\n\nFrom-SVN: r218451", "tree": {"sha": "be99cdc2f4eabd845c85ec93cd7cf3a54a99d5e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be99cdc2f4eabd845c85ec93cd7cf3a54a99d5e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50e9ff8378be0c7353d3f3fb6fa4e4dc3c3367e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50e9ff8378be0c7353d3f3fb6fa4e4dc3c3367e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50e9ff8378be0c7353d3f3fb6fa4e4dc3c3367e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50e9ff8378be0c7353d3f3fb6fa4e4dc3c3367e6/comments", "author": {"login": "jgreenhalgh-arm", "id": 6104025, "node_id": "MDQ6VXNlcjYxMDQwMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6104025?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jgreenhalgh-arm", "html_url": "https://github.com/jgreenhalgh-arm", "followers_url": "https://api.github.com/users/jgreenhalgh-arm/followers", "following_url": "https://api.github.com/users/jgreenhalgh-arm/following{/other_user}", "gists_url": "https://api.github.com/users/jgreenhalgh-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jgreenhalgh-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jgreenhalgh-arm/subscriptions", "organizations_url": "https://api.github.com/users/jgreenhalgh-arm/orgs", "repos_url": "https://api.github.com/users/jgreenhalgh-arm/repos", "events_url": "https://api.github.com/users/jgreenhalgh-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/jgreenhalgh-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5a9fd3e94138512e2f999316baff7790e971174", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5a9fd3e94138512e2f999316baff7790e971174", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5a9fd3e94138512e2f999316baff7790e971174"}], "stats": {"total": 719, "additions": 716, "deletions": 3}, "files": [{"sha": "6cfd339db89a8c905424743377900e6060c35758", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e9ff8378be0c7353d3f3fb6fa4e4dc3c3367e6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e9ff8378be0c7353d3f3fb6fa4e4dc3c3367e6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=50e9ff8378be0c7353d3f3fb6fa4e4dc3c3367e6", "patch": "@@ -1,3 +1,32 @@\n+2014-12-06  James Greenhalgh  <james.greenhalgh@arm.com>\n+\t    Sebastian Pop  <s.pop@samsung.com>\n+\t    Brian Rzycki  <b.rzycki@samsung.com>\n+\n+\tPR tree-optimization/54742\n+\t* params.def (max-fsm-thread-path-insns, max-fsm-thread-length,\n+\tmax-fsm-thread-paths): New.\n+\n+\t* doc/invoke.texi (max-fsm-thread-path-insns, max-fsm-thread-length,\n+\tmax-fsm-thread-paths): Documented.\n+\n+\t* tree-cfg.c (split_edge_bb_loc): Export.\n+\t* tree-cfg.h (split_edge_bb_loc): Declared extern.\n+\n+\t* tree-ssa-threadedge.c (simplify_control_stmt_condition): Restore the\n+\toriginal value of cond when simplification fails.\n+\t(fsm_find_thread_path): New.\n+\t(fsm_find_control_statement_thread_paths): New.\n+\t(thread_through_normal_block): Call find_control_statement_thread_paths.\n+\n+\t* tree-ssa-threadupdate.c (dump_jump_thread_path): Pretty print\n+\tEDGE_FSM_THREAD.\n+\t(verify_seme): New.\n+\t(duplicate_seme_region): New.\n+\t(thread_through_all_blocks): Generate code for EDGE_FSM_THREAD edges\n+\tcalling duplicate_seme_region.\n+\n+\t* tree-ssa-threadupdate.h (jump_thread_edge_type): Add EDGE_FSM_THREAD.\n+\n 2014-12-06  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/64200"}, {"sha": "70d1336b6acd1a332f1a5cc71caf055064f87707", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e9ff8378be0c7353d3f3fb6fa4e4dc3c3367e6/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e9ff8378be0c7353d3f3fb6fa4e4dc3c3367e6/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=50e9ff8378be0c7353d3f3fb6fa4e4dc3c3367e6", "patch": "@@ -10623,6 +10623,18 @@ large and significantly increase compile time at optimization level\n @option{-O1} and higher.  This parameter is a maximum nubmer of statements\n in a single generated constructor.  Default value is 5000.\n \n+@item max-fsm-thread-path-insns\n+Maximum number of instructions to copy when duplicating blocks on a\n+finite state automaton jump thread path.  The default is 100.\n+\n+@item max-fsm-thread-length\n+Maximum number of basic blocks on a finite state automaton jump thread\n+path.  The default is 10.\n+\n+@item max-fsm-thread-paths\n+Maximum number of new jump thread paths to create for a finite state\n+automaton.  The default is 50.\n+\n @end table\n @end table\n "}, {"sha": "edf3f53e60534710275a8a9740d59887bd73811c", "filename": "gcc/params.def", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e9ff8378be0c7353d3f3fb6fa4e4dc3c3367e6/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e9ff8378be0c7353d3f3fb6fa4e4dc3c3367e6/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=50e9ff8378be0c7353d3f3fb6fa4e4dc3c3367e6", "patch": "@@ -1140,6 +1140,21 @@ DEFPARAM (PARAM_CHKP_MAX_CTOR_SIZE,\n \t  \"Maximum number of statements to be included into a single static \"\n \t  \"constructor generated by Pointer Bounds Checker\",\n \t  5000, 100, 0)\n+\n+DEFPARAM (PARAM_MAX_FSM_THREAD_PATH_INSNS,\n+\t  \"max-fsm-thread-path-insns\",\n+\t  \"Maximum number of instructions to copy when duplicating blocks on a finite state automaton jump thread path\",\n+\t  100, 1, 999999)\n+\n+DEFPARAM (PARAM_MAX_FSM_THREAD_LENGTH,\n+\t  \"max-fsm-thread-length\",\n+\t  \"Maximum number of basic blocks on a finite state automaton jump thread path\",\n+\t  10, 1, 999999)\n+\n+DEFPARAM (PARAM_MAX_FSM_THREAD_PATHS,\n+\t  \"max-fsm-thread-paths\",\n+\t  \"Maximum number of new jump thread paths to create for a finite state automaton\",\n+\t  50, 1, 999999)\n /*\n \n Local variables:"}, {"sha": "4c8939757be28cc11dfefed7f7238643177c7a21", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e9ff8378be0c7353d3f3fb6fa4e4dc3c3367e6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e9ff8378be0c7353d3f3fb6fa4e4dc3c3367e6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=50e9ff8378be0c7353d3f3fb6fa4e4dc3c3367e6", "patch": "@@ -1,3 +1,11 @@\n+2014-12-06  James Greenhalgh  <james.greenhalgh@arm.com>\n+\t    Sebastian Pop  <s.pop@samsung.com>\n+\t    Brian Rzycki  <b.rzycki@samsung.com>\n+\n+\tPR tree-optimization/54742\n+\t* gcc.dg/tree-ssa/ssa-dom-thread-6.c: New test.\n+\t* gcc.dg/tree-ssa/ssa-dom-thread-7.c: New test.\n+\n 2014-12-06  Marek Polacek  <polacek@redhat.com>\n \n \tPR tree-optimization/64183"}, {"sha": "bb34a7432e18869d83d2831decd0977bf027ce3f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-6.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e9ff8378be0c7353d3f3fb6fa4e4dc3c3367e6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e9ff8378be0c7353d3f3fb6fa4e4dc3c3367e6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-6.c?ref=50e9ff8378be0c7353d3f3fb6fa4e4dc3c3367e6", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-dom1-details\" } */\n+/* { dg-final { scan-tree-dump-times \"FSM\" 6 \"dom1\" } } */\n+/* { dg-final { cleanup-tree-dump \"dom1\" } } */\n+\n+int sum0, sum1, sum2, sum3;\n+int foo (char *s, char **ret)\n+{\n+  int state=0;\n+  char c;\n+\n+  for (; *s && state != 4; s++)\n+    {\n+      c = *s;\n+      if (c == '*')\n+\t{\n+\t  s++;\n+\t  break;\n+\t}\n+      switch (state)\n+\t{\n+\tcase 0:\n+\t  if (c == '+')\n+\t    state = 1;\n+\t  else if (c != '-')\n+\t    sum0+=c;\n+\t  break;\n+\tcase 1:\n+\t  if (c == '+')\n+\t    state = 2;\n+\t  else if (c == '-')\n+\t    state = 0;\n+\t  else\n+\t    sum1+=c;\n+\t  break;\n+\tdefault:\n+\t  break;\n+\t}\n+\n+    }\n+  *ret = s;\n+  return state;\n+}"}, {"sha": "21474f0b4965efc03f35bbe952c33a51a2cd68e9", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-7.c", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e9ff8378be0c7353d3f3fb6fa4e4dc3c3367e6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e9ff8378be0c7353d3f3fb6fa4e4dc3c3367e6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-7.c?ref=50e9ff8378be0c7353d3f3fb6fa4e4dc3c3367e6", "patch": "@@ -0,0 +1,127 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-dom1-details\" } */\n+/* { dg-final { scan-tree-dump-times \"FSM\" 19 \"dom1\" } } */\n+/* { dg-final { cleanup-tree-dump \"dom1\" } } */\n+\n+enum STATE {\n+  S0=0,\n+  SI,\n+  S1,\n+  S2,\n+  S3,\n+  S4,\n+  S5,\n+  S6\n+};\n+\n+int bar (enum STATE s);\n+\n+enum STATE foo (unsigned char **y, unsigned *c)\n+{\n+  unsigned char *x = *y;\n+  unsigned char n;\n+  enum STATE s = S0;\n+\n+  for( ; *x && s != SI; x++ )\n+    {\n+      n = *x;\n+      if (n == 'x')\n+\t{\n+\t  x++;\n+\t  break;\n+\t}\n+      switch(s)\n+\t{\n+\tcase S0:\n+\t  if(bar(n))\n+\t    s = S3;\n+\t  else if( n == 'a' || n == 'b' )\n+\t    s = S1;\n+\t  else if( n == 'c' )\n+\t    s = S4;\n+\t  else\n+\t    {\n+\t      s = SI;\n+\t      c[SI]++;\n+\t    }\n+\t  c[S0]++;\n+\t  break;\n+\tcase S1:\n+\t  if(bar(n))\n+\t    {\n+\t      s = S3;\n+\t      c[S1]++;\n+\t    }\n+\t  else if( n == 'c' )\n+\t    {\n+\t      s = S4;\n+\t      c[S1]++;\n+\t    }\n+\t  else\n+\t    {\n+\t      s = SI;\n+\t      c[S1]++;\n+\t    }\n+\t  break;\n+\tcase S3:\n+\t  if( n == 'c' )\n+\t    {\n+\t      s = S4;\n+\t      c[S3]++;\n+\t    }\n+\t  else if(!bar(n))\n+\t    {\n+\t      s = SI;\n+\t      c[S3]++;\n+\t    }\n+\t  break;\n+\tcase S4:\n+\t  if( n == 'E' || n == 'e' )\n+\t    {\n+\t      s = S2;\n+\t      c[S4]++;\n+\t    }\n+\t  else if(!bar(n))\n+\t    {\n+\t      s = SI;\n+\t      c[S4]++;\n+\t    }\n+\t  break;\n+\tcase S2:\n+\t  if( n == 'a' || n == 'b' )\n+\t    {\n+\t      s = S5;\n+\t      c[S2]++;\n+\t    }\n+\t  else\n+\t    {\n+\t      s = SI;\n+\t      c[S2]++;\n+\t    }\n+\t  break;\n+\tcase S5:\n+\t  if(bar(n))\n+\t    {\n+\t      s = S6;\n+\t      c[S5]++;\n+\t    }\n+\t  else\n+\t    {\n+\t      s = SI;\n+\t      c[S5]++;\n+\t    }\n+\t  break;\n+\tcase S6:\n+\t  if(!bar(n))\n+\t    {\n+\t      s = SI;\n+\t      c[SI]++;\n+\t    }\n+\t  break;\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+  *y=x;\n+  return s;\n+}"}, {"sha": "6aca58d27d69fdd7aaf5643c6dc52259a0930b52", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e9ff8378be0c7353d3f3fb6fa4e4dc3c3367e6/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e9ff8378be0c7353d3f3fb6fa4e4dc3c3367e6/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=50e9ff8378be0c7353d3f3fb6fa4e4dc3c3367e6", "patch": "@@ -2666,7 +2666,7 @@ reinstall_phi_args (edge new_edge, edge old_edge)\n    near its \"logical\" location.  This is of most help to humans looking\n    at debugging dumps.  */\n \n-static basic_block\n+basic_block\n split_edge_bb_loc (edge edge_in)\n {\n   basic_block dest = edge_in->dest;"}, {"sha": "834fa719250fe36e0c8558043bceb13845c0fd9e", "filename": "gcc/tree-cfg.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e9ff8378be0c7353d3f3fb6fa4e4dc3c3367e6/gcc%2Ftree-cfg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e9ff8378be0c7353d3f3fb6fa4e4dc3c3367e6/gcc%2Ftree-cfg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.h?ref=50e9ff8378be0c7353d3f3fb6fa4e4dc3c3367e6", "patch": "@@ -67,6 +67,7 @@ extern void verify_gimple_in_cfg (struct function *, bool);\n extern tree gimple_block_label (basic_block);\n extern void add_phi_args_after_copy_bb (basic_block);\n extern void add_phi_args_after_copy (basic_block *, unsigned, edge);\n+extern basic_block split_edge_bb_loc (edge);\n extern bool gimple_duplicate_sese_region (edge, edge, basic_block *, unsigned,\n \t\t\t\t\tbasic_block *, bool);\n extern bool gimple_duplicate_sese_tail (edge, edge, basic_block *, unsigned,"}, {"sha": "ce7031112a4c04f54f9153c925b7ed9986942416", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 277, "deletions": 1, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e9ff8378be0c7353d3f3fb6fa4e4dc3c3367e6/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e9ff8378be0c7353d3f3fb6fa4e4dc3c3367e6/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=50e9ff8378be0c7353d3f3fb6fa4e4dc3c3367e6", "patch": "@@ -56,6 +56,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"params.h\"\n #include \"tree-ssa-threadedge.h\"\n #include \"builtins.h\"\n+#include \"cfg.h\"\n+#include \"cfganal.h\"\n \n /* To avoid code explosion due to jump threading, we limit the\n    number of statements we are going to copy.  This variable\n@@ -661,6 +663,7 @@ simplify_control_stmt_condition (edge e,\n      rather than use a relational operator.  These are simpler to handle.  */\n   if (TREE_CODE (cond) == SSA_NAME)\n     {\n+      tree original_lhs = cond;\n       cached_lhs = cond;\n \n       /* Get the variable's current value from the equivalence chains.\n@@ -689,6 +692,12 @@ simplify_control_stmt_condition (edge e,\n \t pass specific callback to try and simplify it further.  */\n       if (cached_lhs && ! is_gimple_min_invariant (cached_lhs))\n         cached_lhs = (*simplify) (stmt, stmt);\n+\n+      /* We couldn't find an invariant.  But, callers of this\n+\t function may be able to do something useful with the\n+\t unmodified destination.  */\n+      if (!cached_lhs)\n+\tcached_lhs = original_lhs;\n     }\n   else\n     cached_lhs = NULL;\n@@ -948,6 +957,249 @@ thread_around_empty_blocks (edge taken_edge,\n   return false;\n }\n \n+/* Return true if the CFG contains at least one path from START_BB to END_BB.\n+   When a path is found, record in PATH the blocks from END_BB to START_BB.\n+   VISITED_BBS is used to make sure we don't fall into an infinite loop.  Bound\n+   the recursion to basic blocks belonging to LOOP.  */\n+\n+static bool\n+fsm_find_thread_path (basic_block start_bb, basic_block end_bb,\n+\t\t      vec<basic_block, va_gc> *&path,\n+\t\t      hash_set<basic_block> *visited_bbs, loop_p loop)\n+{\n+  if (loop != start_bb->loop_father)\n+    return false;\n+\n+  if (start_bb == end_bb)\n+    {\n+      vec_safe_push (path, start_bb);\n+      return true;\n+    }\n+\n+  if (!visited_bbs->add (start_bb))\n+    {\n+      edge e;\n+      edge_iterator ei;\n+      FOR_EACH_EDGE (e, ei, start_bb->succs)\n+\tif (fsm_find_thread_path (e->dest, end_bb, path, visited_bbs, loop))\n+\t  {\n+\t    vec_safe_push (path, start_bb);\n+\t    return true;\n+\t  }\n+    }\n+\n+  return false;\n+}\n+\n+static int max_threaded_paths;\n+\n+/* We trace the value of the variable EXPR back through any phi nodes looking\n+   for places where it gets a constant value and save the path.  Stop after\n+   having recorded MAX_PATHS jump threading paths.  */\n+\n+static void\n+fsm_find_control_statement_thread_paths (tree expr,\n+\t\t\t\t\t hash_set<gimple> *visited_phis,\n+\t\t\t\t\t vec<basic_block, va_gc> *&path)\n+{\n+  tree var = SSA_NAME_VAR (expr);\n+  gimple def_stmt = SSA_NAME_DEF_STMT (expr);\n+  basic_block var_bb = gimple_bb (def_stmt);\n+\n+  if (var == NULL || var_bb == NULL)\n+    return;\n+\n+  /* For the moment we assume that an SSA chain only contains phi nodes, and\n+     eventually one of the phi arguments will be an integer constant.  In the\n+     future, this could be extended to also handle simple assignments of\n+     arithmetic operations.  */\n+  if (gimple_code (def_stmt) != GIMPLE_PHI)\n+    return;\n+\n+  /* Avoid infinite recursion.  */\n+  if (visited_phis->add (def_stmt))\n+    return;\n+\n+  gphi *phi = as_a <gphi *> (def_stmt);\n+  int next_path_length = 0;\n+  basic_block last_bb_in_path = path->last ();\n+\n+  /* Following the chain of SSA_NAME definitions, we jumped from a definition in\n+     LAST_BB_IN_PATH to a definition in VAR_BB.  When these basic blocks are\n+     different, append to PATH the blocks from LAST_BB_IN_PATH to VAR_BB.  */\n+  if (var_bb != last_bb_in_path)\n+    {\n+      edge e;\n+      int e_count = 0;\n+      edge_iterator ei;\n+      vec<basic_block, va_gc> *next_path;\n+      vec_alloc (next_path, n_basic_blocks_for_fn (cfun));\n+\n+      FOR_EACH_EDGE (e, ei, last_bb_in_path->preds)\n+\t{\n+\t  hash_set<basic_block> *visited_bbs = new hash_set<basic_block>;\n+\n+\t  if (fsm_find_thread_path (var_bb, e->src, next_path, visited_bbs,\n+\t\t\t\t    e->src->loop_father))\n+\t    ++e_count;\n+\n+\t  delete visited_bbs;\n+\n+\t  /* If there is more than one path, stop.  */\n+\t  if (e_count > 1)\n+\t    {\n+\t      vec_free (next_path);\n+\t      return;\n+\t    }\n+\t}\n+\n+      /* Stop if we have not found a path: this could occur when the recursion\n+\t is stopped by one of the bounds.  */\n+      if (e_count == 0)\n+\t{\n+\t  vec_free (next_path);\n+\t  return;\n+\t}\n+\n+      /* Append all the nodes from NEXT_PATH to PATH.  */\n+      vec_safe_splice (path, next_path);\n+      next_path_length = next_path->length ();\n+      vec_free (next_path);\n+    }\n+\n+  gcc_assert (path->last () == var_bb);\n+\n+  /* Iterate over the arguments of PHI.  */\n+  unsigned int i;\n+  for (i = 0; i < gimple_phi_num_args (phi); i++)\n+    {\n+      tree arg = gimple_phi_arg_def (phi, i);\n+      basic_block bbi = gimple_phi_arg_edge (phi, i)->src;\n+\n+      /* Skip edges pointing outside the current loop.  */\n+      if (!arg || var_bb->loop_father != bbi->loop_father)\n+\tcontinue;\n+\n+      if (TREE_CODE (arg) == SSA_NAME)\n+\t{\n+\t  vec_safe_push (path, bbi);\n+\t  /* Recursively follow SSA_NAMEs looking for a constant definition.  */\n+\t  fsm_find_control_statement_thread_paths (arg, visited_phis, path);\n+\t  path->pop ();\n+\t  continue;\n+\t}\n+\n+      if (TREE_CODE (arg) != INTEGER_CST)\n+\tcontinue;\n+\n+      int path_length = path->length ();\n+      /* A path with less than 2 basic blocks should not be jump-threaded.  */\n+      if (path_length < 2)\n+\tcontinue;\n+\n+      if (path_length > PARAM_VALUE (PARAM_MAX_FSM_THREAD_LENGTH))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"FSM jump-thread path not considered: \"\n+\t\t     \"the number of basic blocks on the path \"\n+\t\t     \"exceeds PARAM_MAX_FSM_THREAD_LENGTH.\\n\");\n+\t  continue;\n+\t}\n+\n+      if (max_threaded_paths <= 0)\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"FSM jump-thread path not considered: \"\n+\t\t     \"the number of previously recorded FSM paths to thread \"\n+\t\t     \"exceeds PARAM_MAX_FSM_THREAD_PATHS.\\n\");\n+\t  continue;\n+\t}\n+\n+      /* Add BBI to the path.  */\n+      vec_safe_push (path, bbi);\n+      ++path_length;\n+\n+      int n_insns = 0;\n+      gimple_stmt_iterator gsi;\n+      int j;\n+      loop_p loop = (*path)[0]->loop_father;\n+      bool path_crosses_loops = false;\n+\n+      /* Count the number of instructions on the path: as these instructions\n+\t will have to be duplicated, we will not record the path if there are\n+\t too many instructions on the path.  Also check that all the blocks in\n+\t the path belong to a single loop.  */\n+      for (j = 1; j < path_length - 1; j++)\n+\t{\n+\t  basic_block bb = (*path)[j];\n+\n+\t  if (bb->loop_father != loop)\n+\t    {\n+\t      path_crosses_loops = true;\n+\t      break;\n+\t    }\n+\n+\t  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t    {\n+\t      gimple stmt = gsi_stmt (gsi);\n+\t      /* Do not count empty statements and labels.  */\n+\t      if (gimple_code (stmt) != GIMPLE_NOP\n+\t\t  && gimple_code (stmt) != GIMPLE_LABEL\n+\t\t  && !is_gimple_debug (stmt))\n+\t\t++n_insns;\n+\t    }\n+\t}\n+\n+      if (path_crosses_loops)\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"FSM jump-thread path not considered: \"\n+\t\t     \"the path crosses loops.\\n\");\n+\t  path->pop ();\n+\t  continue;\n+\t}\n+\n+      if (n_insns >= PARAM_VALUE (PARAM_MAX_FSM_THREAD_PATH_INSNS))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"FSM jump-thread path not considered: \"\n+\t\t     \"the number of instructions on the path \"\n+\t\t     \"exceeds PARAM_MAX_FSM_THREAD_PATH_INSNS.\\n\");\n+\t  path->pop ();\n+\t  continue;\n+\t}\n+\n+      vec<jump_thread_edge *> *jump_thread_path\n+\t= new vec<jump_thread_edge *> ();\n+\n+      /* Record the edges between the blocks in PATH.  */\n+      for (j = 0; j < path_length - 1; j++)\n+\t{\n+\t  edge e = find_edge ((*path)[path_length - j - 1],\n+\t\t\t      (*path)[path_length - j - 2]);\n+\t  gcc_assert (e);\n+\t  jump_thread_edge *x = new jump_thread_edge (e, EDGE_FSM_THREAD);\n+\t  jump_thread_path->safe_push (x);\n+\t}\n+\n+      /* Add the edge taken when the control variable has value ARG.  */\n+      edge taken_edge = find_taken_edge ((*path)[0], arg);\n+      jump_thread_edge *x\n+\t= new jump_thread_edge (taken_edge, EDGE_NO_COPY_SRC_BLOCK);\n+      jump_thread_path->safe_push (x);\n+\n+      register_jump_thread (jump_thread_path);\n+      --max_threaded_paths;\n+\n+      /* Remove BBI from the path.  */\n+      path->pop ();\n+    }\n+\n+  /* Remove all the nodes that we added from NEXT_PATH.  */\n+  if (next_path_length)\n+    vec_safe_truncate (path, (path->length () - next_path_length));\n+}\n+\n /* We are exiting E->src, see if E->dest ends with a conditional\n    jump which has a known value when reached via E.\n \n@@ -1033,7 +1285,10 @@ thread_through_normal_block (edge e,\n       cond = simplify_control_stmt_condition (e, stmt, dummy_cond, simplify,\n \t\t\t\t\t      handle_dominating_asserts);\n \n-      if (cond && is_gimple_min_invariant (cond))\n+      if (!cond)\n+\treturn 0;\n+\n+      if (is_gimple_min_invariant (cond))\n \t{\n \t  edge taken_edge = find_taken_edge (e->dest, cond);\n \t  basic_block dest = (taken_edge ? taken_edge->dest : NULL);\n@@ -1079,6 +1334,27 @@ thread_through_normal_block (edge e,\n \t\t\t\t      backedge_seen_p);\n \t  return 1;\n \t}\n+\n+      if (!flag_expensive_optimizations\n+\t  || optimize_function_for_size_p (cfun)\n+\t  || TREE_CODE (cond) != SSA_NAME\n+\t  || e->dest->loop_father != e->src->loop_father\n+\t  || loop_depth (e->dest->loop_father) == 0)\n+\treturn 0;\n+\n+      /* When COND cannot be simplified, try to find paths from a control\n+\t statement back through the PHI nodes which would affect that control\n+\t statement.  */\n+      vec<basic_block, va_gc> *bb_path;\n+      vec_alloc (bb_path, n_basic_blocks_for_fn (cfun));\n+      vec_safe_push (bb_path, e->dest);\n+      hash_set<gimple> *visited_phis = new hash_set<gimple>;\n+\n+      max_threaded_paths = PARAM_VALUE (PARAM_MAX_FSM_THREAD_PATHS);\n+      fsm_find_control_statement_thread_paths (cond, visited_phis, bb_path);\n+\n+      delete visited_phis;\n+      vec_free (bb_path);\n     }\n   return 0;\n }"}, {"sha": "12f83ba64af2c6679d29aedc91c1fc2514d7864e", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 202, "deletions": 1, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e9ff8378be0c7353d3f3fb6fa4e4dc3c3367e6/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e9ff8378be0c7353d3f3fb6fa4e4dc3c3367e6/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=50e9ff8378be0c7353d3f3fb6fa4e4dc3c3367e6", "patch": "@@ -167,8 +167,9 @@ dump_jump_thread_path (FILE *dump_file, vec<jump_thread_edge *> path,\n \t\t       bool registering)\n {\n   fprintf (dump_file,\n-\t   \"  %s jump thread: (%d, %d) incoming edge; \",\n+\t   \"  %s%s jump thread: (%d, %d) incoming edge; \",\n \t   (registering ? \"Registering\" : \"Cancelling\"),\n+\t   (path[0]->type == EDGE_FSM_THREAD ? \" FSM\": \"\"),\n \t   path[0]->e->src->index, path[0]->e->dest->index);\n \n   for (unsigned int i = 1; i < path.length (); i++)\n@@ -2317,6 +2318,155 @@ bb_ends_with_multiway_branch (basic_block bb ATTRIBUTE_UNUSED)\n   return false;\n }\n \n+/* Verify that the REGION is a Single Entry Multiple Exits region: make sure no\n+   edge other than ENTRY is entering the REGION.  */\n+\n+DEBUG_FUNCTION void\n+verify_seme (edge entry, basic_block *region, unsigned n_region)\n+{\n+  bitmap bbs = BITMAP_ALLOC (NULL);\n+\n+  for (unsigned i = 0; i < n_region; i++)\n+    bitmap_set_bit (bbs, region[i]->index);\n+\n+  for (unsigned i = 0; i < n_region; i++)\n+    {\n+      edge e;\n+      edge_iterator ei;\n+      basic_block bb = region[i];\n+\n+      /* All predecessors other than ENTRY->src should be in the region.  */\n+      for (ei = ei_start (bb->preds); (e = ei_safe_edge (ei)); ei_next (&ei))\n+\tif (e != entry)\n+\t  gcc_assert (bitmap_bit_p (bbs, e->src->index));\n+    }\n+\n+  BITMAP_FREE (bbs);\n+}\n+\n+/* Duplicates a Single Entry Multiple Exit REGION (set of N_REGION basic\n+   blocks).  The ENTRY edge is redirected to the duplicate of the region.  If\n+   REGION is not a Single Entry region, ignore any incoming edges other than\n+   ENTRY: this makes the copied region a Single Entry region.\n+\n+   Remove the last conditional statement in the last basic block in the REGION,\n+   and create a single fallthru edge pointing to the same destination as the\n+   EXIT edge.\n+\n+   The new basic blocks are stored to REGION_COPY in the same order as they had\n+   in REGION, provided that REGION_COPY is not NULL.\n+\n+   Returns false if it is unable to copy the region, true otherwise.  */\n+\n+static bool\n+duplicate_seme_region (edge entry, edge exit,\n+\t\t       basic_block *region, unsigned n_region,\n+\t\t       basic_block *region_copy)\n+{\n+  unsigned i;\n+  bool free_region_copy = false, copying_header = false;\n+  struct loop *loop = entry->dest->loop_father;\n+  edge exit_copy;\n+  edge redirected;\n+  int total_freq = 0, entry_freq = 0;\n+  gcov_type total_count = 0, entry_count = 0;\n+\n+  if (!can_copy_bbs_p (region, n_region))\n+    return false;\n+\n+  /* Some sanity checking.  Note that we do not check for all possible\n+     missuses of the functions.  I.e. if you ask to copy something weird,\n+     it will work, but the state of structures probably will not be\n+     correct.  */\n+  for (i = 0; i < n_region; i++)\n+    {\n+      /* We do not handle subloops, i.e. all the blocks must belong to the\n+\t same loop.  */\n+      if (region[i]->loop_father != loop)\n+\treturn false;\n+    }\n+\n+  initialize_original_copy_tables ();\n+\n+  if (copying_header)\n+    set_loop_copy (loop, loop_outer (loop));\n+  else\n+    set_loop_copy (loop, loop);\n+\n+  if (!region_copy)\n+    {\n+      region_copy = XNEWVEC (basic_block, n_region);\n+      free_region_copy = true;\n+    }\n+\n+  if (entry->dest->count)\n+    {\n+      total_count = entry->dest->count;\n+      entry_count = entry->count;\n+      /* Fix up corner cases, to avoid division by zero or creation of negative\n+\t frequencies.  */\n+      if (entry_count > total_count)\n+\tentry_count = total_count;\n+    }\n+  else\n+    {\n+      total_freq = entry->dest->frequency;\n+      entry_freq = EDGE_FREQUENCY (entry);\n+      /* Fix up corner cases, to avoid division by zero or creation of negative\n+\t frequencies.  */\n+      if (total_freq == 0)\n+\ttotal_freq = 1;\n+      else if (entry_freq > total_freq)\n+\tentry_freq = total_freq;\n+    }\n+\n+  copy_bbs (region, n_region, region_copy, &exit, 1, &exit_copy, loop,\n+\t    split_edge_bb_loc (entry), 0);\n+  if (total_count)\n+    {\n+      scale_bbs_frequencies_gcov_type (region, n_region,\n+\t\t\t\t       total_count - entry_count,\n+\t\t\t\t       total_count);\n+      scale_bbs_frequencies_gcov_type (region_copy, n_region, entry_count,\n+\t\t\t\t       total_count);\n+    }\n+  else\n+    {\n+      scale_bbs_frequencies_int (region, n_region, total_freq - entry_freq,\n+\t\t\t\t total_freq);\n+      scale_bbs_frequencies_int (region_copy, n_region, entry_freq, total_freq);\n+    }\n+\n+#ifdef ENABLE_CHECKING\n+  /* Make sure no edge other than ENTRY is entering the copied region.  */\n+  verify_seme (entry, region_copy, n_region);\n+#endif\n+\n+  /* Remove the last branch in the jump thread path.  */\n+  remove_ctrl_stmt_and_useless_edges (region_copy[n_region - 1], exit->dest);\n+  edge e = make_edge (region_copy[n_region - 1], exit->dest, EDGE_FALLTHRU);\n+\n+  if (e) {\n+    rescan_loop_exit (e, true, false);\n+    e->probability = REG_BR_PROB_BASE;\n+    e->count = region_copy[n_region - 1]->count;\n+  }\n+\n+  /* Redirect the entry and add the phi node arguments.  */\n+  redirected = redirect_edge_and_branch (entry, get_bb_copy (entry->dest));\n+  gcc_assert (redirected != NULL);\n+  flush_pending_stmts (entry);\n+\n+  /* Add the other PHI node arguments.  */\n+  add_phi_args_after_copy (region_copy, n_region, NULL);\n+\n+  if (free_region_copy)\n+    free (region_copy);\n+\n+  free_original_copy_tables ();\n+  return true;\n+}\n+\n /* Walk through all blocks and thread incoming edges to the appropriate\n    outgoing edge for each edge pair recorded in THREADED_EDGES.\n \n@@ -2343,6 +2493,57 @@ thread_through_all_blocks (bool may_peel_loop_headers)\n   threaded_blocks = BITMAP_ALLOC (NULL);\n   memset (&thread_stats, 0, sizeof (thread_stats));\n \n+  /* Jump-thread all FSM threads before other jump-threads.  */\n+  for (i = 0; i < paths.length ();)\n+    {\n+      vec<jump_thread_edge *> *path = paths[i];\n+      edge entry = (*path)[0]->e;\n+\n+      if ((*path)[0]->type != EDGE_FSM_THREAD\n+\t  /* Do not jump-thread twice from the same block.  */\n+\t  || bitmap_bit_p (threaded_blocks, entry->src->index)) {\n+\ti++;\n+\tcontinue;\n+      }\n+\n+      unsigned len = path->length ();\n+      edge exit = (*path)[len - 1]->e;\n+      basic_block *region = XNEWVEC (basic_block, len - 1);\n+\n+      for (unsigned int j = 0; j < len - 1; j++)\n+\tregion[j] = (*path)[j]->e->dest;\n+\n+      if (duplicate_seme_region (entry, exit, region, len - 1, NULL))\n+\t{\n+\t  /* We do not update dominance info.  */\n+\t  free_dominance_info (CDI_DOMINATORS);\n+\t  bitmap_set_bit (threaded_blocks, entry->src->index);\n+\t  retval = true;\n+\t}\n+\n+      delete_jump_thread_path (path);\n+      paths.unordered_remove (i);\n+    }\n+\n+  /* Remove from PATHS all the jump-threads starting with an edge already\n+     jump-threaded.  */\n+  for (i = 0; i < paths.length ();)\n+    {\n+      vec<jump_thread_edge *> *path = paths[i];\n+      edge entry = (*path)[0]->e;\n+\n+      /* Do not jump-thread twice from the same block.  */\n+      if (bitmap_bit_p (threaded_blocks, entry->src->index))\n+\t{\n+\t  delete_jump_thread_path (path);\n+\t  paths.unordered_remove (i);\n+\t}\n+      else\n+\ti++;\n+    }\n+\n+  bitmap_clear (threaded_blocks);\n+\n   mark_threaded_blocks (threaded_blocks);\n \n   initialize_original_copy_tables ();"}, {"sha": "22c5bceb90f3dd2eb5ec34490d12f160e33ac20d", "filename": "gcc/tree-ssa-threadupdate.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e9ff8378be0c7353d3f3fb6fa4e4dc3c3367e6/gcc%2Ftree-ssa-threadupdate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e9ff8378be0c7353d3f3fb6fa4e4dc3c3367e6/gcc%2Ftree-ssa-threadupdate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.h?ref=50e9ff8378be0c7353d3f3fb6fa4e4dc3c3367e6", "patch": "@@ -26,6 +26,7 @@ extern bool thread_through_all_blocks (bool);\n enum jump_thread_edge_type\n {\n   EDGE_START_JUMP_THREAD,\n+  EDGE_FSM_THREAD,\n   EDGE_COPY_SRC_BLOCK,\n   EDGE_COPY_SRC_JOINER_BLOCK,\n   EDGE_NO_COPY_SRC_BLOCK"}]}