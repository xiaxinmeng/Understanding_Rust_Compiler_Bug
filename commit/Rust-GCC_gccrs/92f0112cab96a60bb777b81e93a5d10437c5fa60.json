{"sha": "92f0112cab96a60bb777b81e93a5d10437c5fa60", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTJmMDExMmNhYjk2YTYwYmI3NzdiODFlOTNhNWQxMDQzN2M1ZmE2MA==", "commit": {"author": {"name": "Than McIntosh", "email": "thanm@google.com", "date": "2017-12-01T23:12:13Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-12-01T23:12:13Z"}, "message": "compiler: introduce size threshold for nil checks\n    \n    Add a new control variable to the Gogo class that stores the size\n    threshold for nil checks. This value can be used to control the\n    policy for deciding when a given deference operation needs a check and\n    when it does not. A size threshold of -1 means that every potentially\n    faulting dereference needs an explicit check (and branch to error\n    call). A size threshold of K (where K > 0) means that if the size of\n    the object being dereferenced is >= K, then we need a check.\n    \n    Reviewed-on: https://go-review.googlesource.com/80996\n\n\t* go-c.h (go_create_gogo_args): Add nil_check_size_threshold\n\tfield.\n\t* go-lang.c (go_langhook_init): Set nil_check_size_threshold.\n\nFrom-SVN: r255340", "tree": {"sha": "90ebd983c790cf1c3455070065240bae31afec39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/90ebd983c790cf1c3455070065240bae31afec39"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92f0112cab96a60bb777b81e93a5d10437c5fa60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92f0112cab96a60bb777b81e93a5d10437c5fa60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92f0112cab96a60bb777b81e93a5d10437c5fa60", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92f0112cab96a60bb777b81e93a5d10437c5fa60/comments", "author": {"login": "thanm", "id": 12280172, "node_id": "MDQ6VXNlcjEyMjgwMTcy", "avatar_url": "https://avatars.githubusercontent.com/u/12280172?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thanm", "html_url": "https://github.com/thanm", "followers_url": "https://api.github.com/users/thanm/followers", "following_url": "https://api.github.com/users/thanm/following{/other_user}", "gists_url": "https://api.github.com/users/thanm/gists{/gist_id}", "starred_url": "https://api.github.com/users/thanm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thanm/subscriptions", "organizations_url": "https://api.github.com/users/thanm/orgs", "repos_url": "https://api.github.com/users/thanm/repos", "events_url": "https://api.github.com/users/thanm/events{/privacy}", "received_events_url": "https://api.github.com/users/thanm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "19041dad9b7f03b32775864c41649a81ebca8092", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19041dad9b7f03b32775864c41649a81ebca8092", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19041dad9b7f03b32775864c41649a81ebca8092"}], "stats": {"total": 301, "additions": 220, "deletions": 81}, "files": [{"sha": "26f823e0442d0522ba800cb6abc4da2dc8d333fb", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92f0112cab96a60bb777b81e93a5d10437c5fa60/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92f0112cab96a60bb777b81e93a5d10437c5fa60/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=92f0112cab96a60bb777b81e93a5d10437c5fa60", "patch": "@@ -1,3 +1,9 @@\n+2017-12-01  Than McIntosh  <thanm@google.com>\n+\n+\t* go-c.h (go_create_gogo_args): Add nil_check_size_threshold\n+\tfield.\n+\t* go-lang.c (go_langhook_init): Set nil_check_size_threshold.\n+\n 2017-11-28  Jakub Jelinek  <jakub@redhat.com>\n \n \t* go-gcc.cc (Gcc_backend::switch_statement): Build SWITCH_EXPR using"}, {"sha": "f5a1bde51b26b856ce5d7eb371bd1dcd56200f7b", "filename": "gcc/go/go-c.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92f0112cab96a60bb777b81e93a5d10437c5fa60/gcc%2Fgo%2Fgo-c.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92f0112cab96a60bb777b81e93a5d10437c5fa60/gcc%2Fgo%2Fgo-c.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-c.h?ref=92f0112cab96a60bb777b81e93a5d10437c5fa60", "patch": "@@ -47,6 +47,7 @@ struct go_create_gogo_args\n   bool check_divide_overflow;\n   bool compiling_runtime;\n   int debug_escape_level;\n+  int64_t nil_check_size_threshold;\n };\n \n extern void go_create_gogo (const struct go_create_gogo_args*);"}, {"sha": "fda069aee6dbe0f823e33d8b590531339a11fa03", "filename": "gcc/go/go-lang.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92f0112cab96a60bb777b81e93a5d10437c5fa60/gcc%2Fgo%2Fgo-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92f0112cab96a60bb777b81e93a5d10437c5fa60/gcc%2Fgo%2Fgo-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-lang.c?ref=92f0112cab96a60bb777b81e93a5d10437c5fa60", "patch": "@@ -112,6 +112,7 @@ go_langhook_init (void)\n   args.check_divide_overflow = go_check_divide_overflow;\n   args.compiling_runtime = go_compiling_runtime;\n   args.debug_escape_level = go_debug_escape_level;\n+  args.nil_check_size_threshold = 4096;\n   args.linemap = go_get_linemap();\n   args.backend = go_get_backend();\n   go_create_gogo (&args);"}, {"sha": "ca329c2de32be8da9bdb6dde81a77e64cb1c5279", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92f0112cab96a60bb777b81e93a5d10437c5fa60/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92f0112cab96a60bb777b81e93a5d10437c5fa60/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=92f0112cab96a60bb777b81e93a5d10437c5fa60", "patch": "@@ -1,4 +1,4 @@\n-0d6b3abcbfe04949db947081651a503ceb12fe6e\n+8cd42a3e9e0e618bb09e67be73f7d2f2477a0faa\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "e9b86831dc9a8db5edb2a4b829cd2df3334b3384", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 105, "deletions": 53, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92f0112cab96a60bb777b81e93a5d10437c5fa60/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92f0112cab96a60bb777b81e93a5d10437c5fa60/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=92f0112cab96a60bb777b81e93a5d10437c5fa60", "patch": "@@ -290,7 +290,7 @@ Expression::get_interface_type_descriptor(Expression* rhs)\n       Expression::make_interface_info(rhs, INTERFACE_INFO_METHODS, location);\n \n   Expression* descriptor =\n-      Expression::make_unary(OPERATOR_MULT, mtable, location);\n+      Expression::make_dereference(mtable, NIL_CHECK_NOT_NEEDED, location);\n   descriptor = Expression::make_field_reference(descriptor, 0, location);\n   Expression* nil = Expression::make_nil(location);\n \n@@ -393,7 +393,8 @@ Expression::convert_interface_to_type(Type *lhs_type, Expression* rhs,\n     {\n       obj = Expression::make_unsafe_cast(Type::make_pointer_type(lhs_type), obj,\n                                          location);\n-      obj = Expression::make_unary(OPERATOR_MULT, obj, location);\n+      obj = Expression::make_dereference(obj, NIL_CHECK_NOT_NEEDED,\n+                                         location);\n     }\n   return Expression::make_compound(check_iface, obj, location);\n }\n@@ -3842,24 +3843,20 @@ Unary_expression::do_flatten(Gogo* gogo, Named_object*,\n       && !this->expr_->is_variable())\n     {\n       go_assert(this->expr_->type()->points_to() != NULL);\n-      Type* ptype = this->expr_->type()->points_to();\n-      if (!ptype->is_void_type())\n+      switch (this->requires_nil_check(gogo))\n         {\n-          int64_t s;\n-          bool ok = ptype->backend_type_size(gogo, &s);\n-          if (!ok)\n+          case NIL_CHECK_ERROR_ENCOUNTERED:\n             {\n               go_assert(saw_errors());\n               return Expression::make_error(this->location());\n             }\n-          if (s >= 4096 || this->issue_nil_check_)\n-            {\n-              Temporary_statement* temp =\n-                  Statement::make_temporary(NULL, this->expr_, location);\n-              inserter->insert(temp);\n-              this->expr_ =\n-                  Expression::make_temporary_reference(temp, location);\n-            }\n+          case NIL_CHECK_NOT_NEEDED:\n+            break;\n+          case NIL_CHECK_NEEDED:\n+            this->create_temp_ = true;\n+            break;\n+          case NIL_CHECK_DEFAULT:\n+            go_unreachable();\n         }\n     }\n \n@@ -3960,6 +3957,41 @@ Unary_expression::base_is_static_initializer(Expression* expr)\n   return false;\n }\n \n+// Return whether this dereference expression requires an explicit nil\n+// check. If we are dereferencing the pointer to a large struct\n+// (greater than the specified size threshold), we need to check for\n+// nil. We don't bother to check for small structs because we expect\n+// the system to crash on a nil pointer dereference. However, if we\n+// know the address of this expression is being taken, we must always\n+// check for nil.\n+Unary_expression::Nil_check_classification\n+Unary_expression::requires_nil_check(Gogo* gogo) \n+{\n+  go_assert(this->op_ == OPERATOR_MULT);\n+  go_assert(this->expr_->type()->points_to() != NULL);\n+\n+  if (this->issue_nil_check_ == NIL_CHECK_NEEDED)\n+    return NIL_CHECK_NEEDED;\n+  else if (this->issue_nil_check_ == NIL_CHECK_NOT_NEEDED)\n+    return NIL_CHECK_NOT_NEEDED;\n+\n+  Type* ptype = this->expr_->type()->points_to();\n+  int64_t type_size = -1;\n+  if (!ptype->is_void_type())\n+    {\n+      bool ok = ptype->backend_type_size(gogo, &type_size);\n+      if (!ok)\n+        return NIL_CHECK_ERROR_ENCOUNTERED;\n+    }\n+\n+  int64_t size_cutoff = gogo->nil_check_size_threshold();\n+  if (size_cutoff == -1 || (type_size != -1 && type_size >= size_cutoff))\n+    this->issue_nil_check_ = NIL_CHECK_NEEDED;\n+  else\n+    this->issue_nil_check_ = NIL_CHECK_NOT_NEEDED;\n+  return this->issue_nil_check_;\n+}\n+\n // Apply unary opcode OP to UNC, setting NC.  Return true if this\n // could be done, false if not.  On overflow, issues an error and sets\n // *ISSUED_ERROR.\n@@ -4408,43 +4440,42 @@ Unary_expression::do_get_backend(Translate_context* context)\n       {\n         go_assert(this->expr_->type()->points_to() != NULL);\n \n-\t// If we are dereferencing the pointer to a large struct, we\n-\t// need to check for nil.  We don't bother to check for small\n-\t// structs because we expect the system to crash on a nil\n-\t// pointer dereference.\t However, if we know the address of this\n-\t// expression is being taken, we must always check for nil.\n-\n+        bool known_valid = false;\n         Type* ptype = this->expr_->type()->points_to();\n         Btype* pbtype = ptype->get_backend(gogo);\n-        if (!ptype->is_void_type())\n-\t  {\n-            int64_t s;\n-            bool ok = ptype->backend_type_size(gogo, &s);\n-            if (!ok)\n+        switch (this->requires_nil_check(gogo))\n+          {\n+            case NIL_CHECK_NOT_NEEDED:\n+              break;\n+            case NIL_CHECK_ERROR_ENCOUNTERED:\n               {\n                 go_assert(saw_errors());\n                 return gogo->backend()->error_expression();\n               }\n-\t    if (s >= 4096 || this->issue_nil_check_)\n-\t      {\n+            case NIL_CHECK_NEEDED:\n+              {\n                 go_assert(this->expr_->is_variable());\n                 Bexpression* nil =\n-\t\t  Expression::make_nil(loc)->get_backend(context);\n+                    Expression::make_nil(loc)->get_backend(context);\n                 Bexpression* compare =\n                     gogo->backend()->binary_expression(OPERATOR_EQEQ, bexpr,\n                                                        nil, loc);\n                 Bexpression* crash =\n-\t\t  gogo->runtime_error(RUNTIME_ERROR_NIL_DEREFERENCE,\n-\t\t\t\t      loc)->get_backend(context);\n+                    gogo->runtime_error(RUNTIME_ERROR_NIL_DEREFERENCE,\n+                                        loc)->get_backend(context);\n                 Bfunction* bfn = context->function()->func_value()->get_decl();\n                 bexpr = gogo->backend()->conditional_expression(bfn, btype,\n                                                                 compare,\n                                                                 crash, bexpr,\n                                                                 loc);\n-\n-\t      }\n-\t  }\n-        ret = gogo->backend()->indirect_expression(pbtype, bexpr, false, loc);\n+                known_valid = true;\n+                break;\n+              }\n+            case NIL_CHECK_DEFAULT:\n+              go_unreachable();\n+          }\n+        ret = gogo->backend()->indirect_expression(pbtype, bexpr,\n+                                                   known_valid, loc);\n       }\n       break;\n \n@@ -4529,6 +4560,19 @@ Expression::make_unary(Operator op, Expression* expr, Location location)\n   return new Unary_expression(op, expr, location);\n }\n \n+Expression*\n+Expression::make_dereference(Expression* ptr,\n+                             Nil_check_classification docheck,\n+                             Location location)\n+{\n+  Expression* deref = Expression::make_unary(OPERATOR_MULT, ptr, location);\n+  if (docheck == NIL_CHECK_NEEDED)\n+    deref->unary_expression()->set_requires_nil_check(true);\n+  else if (docheck == NIL_CHECK_NOT_NEEDED)\n+    deref->unary_expression()->set_requires_nil_check(false);\n+  return deref;\n+}\n+\n // If this is an indirection through a pointer, return the expression\n // being pointed through.  Otherwise return this.\n \n@@ -6829,7 +6873,7 @@ Bound_method_expression::create_thunk(Gogo* gogo, const Method* method,\n   // Field 0 of the closure is the function code pointer, field 1 is\n   // the value on which to invoke the method.\n   Expression* arg = Expression::make_var_reference(cp, loc);\n-  arg = Expression::make_unary(OPERATOR_MULT, arg, loc);\n+  arg = Expression::make_dereference(arg, NIL_CHECK_NOT_NEEDED, loc);\n   arg = Expression::make_field_reference(arg, 1, loc);\n \n   Expression* bme = Expression::make_bound_method(arg, method, fn, loc);\n@@ -6893,7 +6937,8 @@ bme_check_nil(const Method::Field_indexes* field_indexes, Location loc,\n \t\t\t\t\t      Expression::make_nil(loc),\n \t\t\t\t\t      loc);\n       cond = Expression::make_binary(OPERATOR_OROR, cond, n, loc);\n-      *ref = Expression::make_unary(OPERATOR_MULT, *ref, loc);\n+      *ref = Expression::make_dereference(*ref, Expression::NIL_CHECK_DEFAULT,\n+                                          loc);\n       go_assert((*ref)->type()->struct_type() == stype);\n     }\n   *ref = Expression::make_field_reference(*ref, field_indexes->field_index,\n@@ -6948,7 +6993,7 @@ Bound_method_expression::do_flatten(Gogo* gogo, Named_object*,\n   Expression* val = expr;\n   if (fntype->receiver()->type()->points_to() == NULL\n       && val->type()->points_to() != NULL)\n-    val = Expression::make_unary(OPERATOR_MULT, val, loc);\n+    val = Expression::make_dereference(val, NIL_CHECK_DEFAULT, loc);\n \n   // Note that we are ignoring this->expr_type_ here.  The thunk will\n   // expect a closure whose second field has type this->expr_type_ (if\n@@ -8919,7 +8964,8 @@ Builtin_call_expression::do_get_backend(Translate_context* context)\n \t    arg_type = arg_type->points_to();\n \t    go_assert(arg_type->array_type() != NULL\n \t\t       && !arg_type->is_slice_type());\n-            arg = Expression::make_unary(OPERATOR_MULT, arg, location);\n+            arg = Expression::make_dereference(arg, NIL_CHECK_DEFAULT,\n+                                               location);\n \t  }\n \n \tType* int_type = Type::lookup_integer_type(\"int\");\n@@ -8953,8 +8999,9 @@ Builtin_call_expression::do_get_backend(Translate_context* context)\n \t\t\t\t\t\t\t  arg, nil, location);\n \t\tExpression* zero = Expression::make_integer_ul(0, int_type,\n \t\t\t\t\t\t\t       location);\n-\t\tExpression* indir = Expression::make_unary(OPERATOR_MULT,\n-\t\t\t\t\t\t\t   arg, location);\n+                Expression* indir =\n+                    Expression::make_dereference(arg, NIL_CHECK_NOT_NEEDED,\n+                                                 location);\n \t\tval = Expression::make_conditional(cmp, zero, indir, location);\n \t      }\n \t    else\n@@ -8995,8 +9042,9 @@ Builtin_call_expression::do_get_backend(Translate_context* context)\n \t\t\t\t\t\t\t  arg, nil, location);\n \t\tExpression* zero = Expression::make_integer_ul(0, int_type,\n \t\t\t\t\t\t\t       location);\n-\t\tExpression* indir = Expression::make_unary(OPERATOR_MULT,\n-\t\t\t\t\t\t\t   parg, location);\n+                Expression* indir =\n+                    Expression::make_dereference(parg, NIL_CHECK_NOT_NEEDED,\n+                                                 location);\n \t\tval = Expression::make_conditional(cmp, zero, indir, location);\n \t      }\n \t    else\n@@ -10274,7 +10322,7 @@ Call_expression::do_get_backend(Translate_context* context)\n           Type::make_pointer_type(\n               Type::make_pointer_type(Type::make_void_type()));\n       fn = Expression::make_unsafe_cast(pfntype, this->fn_, location);\n-      fn = Expression::make_unary(OPERATOR_MULT, fn, location);\n+      fn = Expression::make_dereference(fn, NIL_CHECK_NOT_NEEDED, location);\n     }\n   else\n     {\n@@ -10532,8 +10580,8 @@ Index_expression::do_lower(Gogo*, Named_object*, Statement_inserter*, int)\n \t   && type->points_to()->array_type() != NULL\n \t   && !type->points_to()->is_slice_type())\n     {\n-      Expression* deref = Expression::make_unary(OPERATOR_MULT, left,\n-\t\t\t\t\t\t location);\n+      Expression* deref =\n+          Expression::make_dereference(left, NIL_CHECK_DEFAULT, location);\n \n       // For an ordinary index into the array, the pointer will be\n       // dereferenced.  For a slice it will not--the resulting slice\n@@ -11297,7 +11345,8 @@ String_index_expression::do_get_backend(Translate_context* context)\n   Location loc = this->location();\n   Expression* string_arg = this->string_;\n   if (this->string_->type()->points_to() != NULL)\n-    string_arg = Expression::make_unary(OPERATOR_MULT, this->string_, loc);\n+    string_arg = Expression::make_dereference(this->string_,\n+                                              NIL_CHECK_NOT_NEEDED, loc);\n \n   Expression* bad_index = Expression::check_bounds(this->start_, loc);\n \n@@ -11531,8 +11580,9 @@ Map_index_expression::do_get_backend(Translate_context* context)\n   go_assert(this->value_pointer_ != NULL\n             && this->value_pointer_->is_variable());\n \n-  Expression* val = Expression::make_unary(OPERATOR_MULT, this->value_pointer_,\n-\t\t\t\t\t   this->location());\n+  Expression* val = Expression::make_dereference(this->value_pointer_,\n+                                                 NIL_CHECK_NOT_NEEDED,\n+                                                 this->location());\n   return val->get_backend(context);\n }\n \n@@ -11768,7 +11818,7 @@ Interface_field_reference_expression::get_function()\n   Expression* ref = this->expr_;\n   Location loc = this->location();\n   if (ref->type()->points_to() != NULL)\n-    ref = Expression::make_unary(OPERATOR_MULT, ref, loc);\n+    ref = Expression::make_dereference(ref, NIL_CHECK_DEFAULT, loc);\n \n   Expression* mtable =\n       Expression::make_interface_info(ref, INTERFACE_INFO_METHODS, loc);\n@@ -11778,7 +11828,8 @@ Interface_field_reference_expression::get_function()\n   unsigned int index;\n   const Struct_field* field = mtable_type->find_local_field(name, &index);\n   go_assert(field != NULL);\n-  mtable = Expression::make_unary(OPERATOR_MULT, mtable, loc);\n+\n+  mtable = Expression::make_dereference(mtable, NIL_CHECK_NOT_NEEDED, loc);\n   return Expression::make_field_reference(mtable, index, loc);\n }\n \n@@ -11790,7 +11841,8 @@ Interface_field_reference_expression::get_underlying_object()\n {\n   Expression* expr = this->expr_;\n   if (expr->type()->points_to() != NULL)\n-    expr = Expression::make_unary(OPERATOR_MULT, expr, this->location());\n+    expr = Expression::make_dereference(expr, NIL_CHECK_DEFAULT,\n+                                        this->location());\n   return Expression::make_interface_info(expr, INTERFACE_INFO_OBJECT,\n                                          this->location());\n }\n@@ -11963,7 +12015,7 @@ Interface_field_reference_expression::create_thunk(Gogo* gogo,\n   // Field 0 of the closure is the function code pointer, field 1 is\n   // the value on which to invoke the method.\n   Expression* arg = Expression::make_var_reference(cp, loc);\n-  arg = Expression::make_unary(OPERATOR_MULT, arg, loc);\n+  arg = Expression::make_dereference(arg, NIL_CHECK_NOT_NEEDED, loc);\n   arg = Expression::make_field_reference(arg, 1, loc);\n \n   Expression *ifre = Expression::make_interface_field_reference(arg, name,"}, {"sha": "9de734e636f342fba3d4c9606f5364dffe5a6598", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 40, "deletions": 3, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92f0112cab96a60bb777b81e93a5d10437c5fa60/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92f0112cab96a60bb777b81e93a5d10437c5fa60/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=92f0112cab96a60bb777b81e93a5d10437c5fa60", "patch": "@@ -506,6 +506,23 @@ class Expression\n   static Expression*\n   make_backend(Bexpression*, Type*, Location);\n \n+  enum Nil_check_classification\n+    {\n+      // Use the default policy for deciding if this deref needs a check.\n+      NIL_CHECK_DEFAULT,\n+      // An explicit check is required for this dereference operation.\n+      NIL_CHECK_NEEDED,\n+      // No check needed for this dereference operation.\n+      NIL_CHECK_NOT_NEEDED,\n+      // A type error or error construct was encountered when determining\n+      // whether this deref needs an explicit check.\n+      NIL_CHECK_ERROR_ENCOUNTERED\n+    };\n+\n+  // Make a dereference expression.\n+  static Expression*\n+  make_dereference(Expression*, Nil_check_classification, Location);\n+\n   // Return the expression classification.\n   Expression_classification\n   classification() const\n@@ -1730,7 +1747,8 @@ class Unary_expression : public Expression\n   Unary_expression(Operator op, Expression* expr, Location location)\n     : Expression(EXPRESSION_UNARY, location),\n       op_(op), escapes_(true), create_temp_(false), is_gc_root_(false),\n-      is_slice_init_(false), expr_(expr), issue_nil_check_(false)\n+      is_slice_init_(false), expr_(expr),\n+      issue_nil_check_(NIL_CHECK_DEFAULT)\n   { }\n \n   // Return the operator.\n@@ -1792,6 +1810,17 @@ class Unary_expression : public Expression\n   static Expression*\n   do_import(Import*);\n \n+  // Declare that this deref does or does not require an explicit nil check.\n+  void\n+  set_requires_nil_check(bool needed)\n+  {\n+    go_assert(this->op_ == OPERATOR_MULT);\n+    if (needed)\n+      this->issue_nil_check_ = NIL_CHECK_NEEDED;\n+    else\n+      this->issue_nil_check_ = NIL_CHECK_NOT_NEEDED;\n+  }\n+\n  protected:\n   int\n   do_traverse(Traverse* traverse)\n@@ -1847,12 +1876,20 @@ class Unary_expression : public Expression\n \n   void\n   do_issue_nil_check()\n-  { this->issue_nil_check_ = (this->op_ == OPERATOR_MULT); }\n+  {\n+    if (this->op_ == OPERATOR_MULT)\n+      this->set_requires_nil_check(true);\n+  }\n \n  private:\n   static bool\n   base_is_static_initializer(Expression*);\n \n+  // Return a determination as to whether this dereference expression\n+  // requires a nil check.\n+  Nil_check_classification\n+  requires_nil_check(Gogo*);\n+\n   // The unary operator to apply.\n   Operator op_;\n   // Normally true.  False if this is an address expression which does\n@@ -1874,7 +1911,7 @@ class Unary_expression : public Expression\n   Expression* expr_;\n   // Whether or not to issue a nil check for this expression if its address\n   // is being taken.\n-  bool issue_nil_check_;\n+  Nil_check_classification issue_nil_check_;\n };\n \n // A binary expression."}, {"sha": "a2b8cecb3fe9eab2b54c99ea74249c0d5098dbe3", "filename": "gcc/go/gofrontend/go.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92f0112cab96a60bb777b81e93a5d10437c5fa60/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92f0112cab96a60bb777b81e93a5d10437c5fa60/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgo.cc?ref=92f0112cab96a60bb777b81e93a5d10437c5fa60", "patch": "@@ -41,6 +41,7 @@ go_create_gogo(const struct go_create_gogo_args* args)\n   if (args->c_header != NULL)\n     ::gogo->set_c_header(args->c_header);\n   ::gogo->set_debug_escape_level(args->debug_escape_level);\n+  ::gogo->set_nil_check_size_threshold(args->nil_check_size_threshold);\n }\n \n // Parse the input files."}, {"sha": "74b45958f619fe0a42379de7868e045569aaef7f", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92f0112cab96a60bb777b81e93a5d10437c5fa60/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92f0112cab96a60bb777b81e93a5d10437c5fa60/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=92f0112cab96a60bb777b81e93a5d10437c5fa60", "patch": "@@ -55,6 +55,7 @@ Gogo::Gogo(Backend* backend, Linemap* linemap, int, int pointer_size)\n     check_divide_overflow_(true),\n     compiling_runtime_(false),\n     debug_escape_level_(0),\n+    nil_check_size_threshold_(4096),\n     verify_types_(),\n     interface_types_(),\n     specific_type_functions_(),\n@@ -5567,7 +5568,10 @@ Function::build(Gogo* gogo, Named_object* named_function)\n               vars.push_back(bvar);\n \t      Expression* parm_ref =\n                   Expression::make_var_reference(parm_no, loc);\n-\t      parm_ref = Expression::make_unary(OPERATOR_MULT, parm_ref, loc);\n+              parm_ref =\n+                  Expression::make_dereference(parm_ref,\n+                                               Expression::NIL_CHECK_DEFAULT,\n+                                               loc);\n \t      if ((*p)->var_value()->is_in_heap())\n \t\tparm_ref = Expression::make_heap_expression(parm_ref, loc);\n               var_inits.push_back(parm_ref->get_backend(&context));"}, {"sha": "e48a89926c888e6f8f7564e5acccba59d0fa08f9", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92f0112cab96a60bb777b81e93a5d10437c5fa60/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92f0112cab96a60bb777b81e93a5d10437c5fa60/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=92f0112cab96a60bb777b81e93a5d10437c5fa60", "patch": "@@ -318,6 +318,20 @@ class Gogo\n   set_debug_escape_level(int level)\n   { this->debug_escape_level_ = level; }\n \n+  // Return the size threshold used to determine whether to issue\n+  // a nil-check for a given pointer dereference. A threshold of -1\n+  // implies that all potentially faulting dereference ops should\n+  // be nil-checked. A positive threshold of N implies that a deref\n+  // of *P where P has size less than N doesn't need a nil check.\n+  int64_t\n+  nil_check_size_threshold() const\n+  { return this->nil_check_size_threshold_; }\n+\n+  // Set the nil-check size threshold, as described above.\n+  void\n+  set_nil_check_size_threshold(int64_t bytes)\n+  { this->nil_check_size_threshold_ = bytes; }\n+\n   // Import a package.  FILENAME is the file name argument, LOCAL_NAME\n   // is the local name to give to the package.  If LOCAL_NAME is empty\n   // the declarations are added to the global scope.\n@@ -1025,6 +1039,8 @@ class Gogo\n   // The level of escape analysis debug information to emit, from the\n   // -fgo-debug-escape option.\n   int debug_escape_level_;\n+  // Nil-check size threshhold.\n+  int64_t nil_check_size_threshold_;\n   // A list of types to verify.\n   std::vector<Type*> verify_types_;\n   // A list of interface types defined while parsing."}, {"sha": "be6f3f163391911e33fe5df998e504acbabe1f5d", "filename": "gcc/go/gofrontend/parse.cc", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92f0112cab96a60bb777b81e93a5d10437c5fa60/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92f0112cab96a60bb777b81e93a5d10437c5fa60/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.cc?ref=92f0112cab96a60bb777b81e93a5d10437c5fa60", "patch": "@@ -2745,14 +2745,17 @@ Parse::enclosing_var_reference(Named_object* in_function, Named_object* var,\n \n   Expression* closure_ref = Expression::make_var_reference(closure,\n \t\t\t\t\t\t\t   location);\n-  closure_ref = Expression::make_unary(OPERATOR_MULT, closure_ref, location);\n+  closure_ref =\n+      Expression::make_dereference(closure_ref,\n+                                   Expression::NIL_CHECK_DEFAULT,\n+                                   location);\n \n   // The closure structure holds pointers to the variables, so we need\n   // to introduce an indirection.\n   Expression* e = Expression::make_field_reference(closure_ref,\n \t\t\t\t\t\t   ins.first->index(),\n \t\t\t\t\t\t   location);\n-  e = Expression::make_unary(OPERATOR_MULT, e, location);\n+  e = Expression::make_dereference(e, Expression::NIL_CHECK_DEFAULT, location);\n   return Expression::make_enclosing_var_reference(e, var, location);\n }\n "}, {"sha": "d3878a6ba0561c4e41ae7bdcb85b5786b5e65d5e", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92f0112cab96a60bb777b81e93a5d10437c5fa60/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92f0112cab96a60bb777b81e93a5d10437c5fa60/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=92f0112cab96a60bb777b81e93a5d10437c5fa60", "patch": "@@ -315,7 +315,8 @@ Variable_declaration_statement::do_get_backend(Translate_context* context)\n   if (binit != NULL)\n     {\n       Expression* e = Expression::make_temporary_reference(temp, loc);\n-      e = Expression::make_unary(OPERATOR_MULT, e, loc);\n+      e = Expression::make_dereference(e, Expression::NIL_CHECK_NOT_NEEDED,\n+                                       loc);\n       Bexpression* be = e->get_backend(context);\n       set = context->backend()->assignment_statement(bfunction, be, binit, loc);\n     }\n@@ -740,7 +741,9 @@ Assignment_statement::do_lower(Gogo*, Named_object*, Block* enclosing,\n \t\t\t\t\t    a1, a2, a3);\n       Type* ptrval_type = Type::make_pointer_type(mt->val_type());\n       call = Expression::make_cast(ptrval_type, call, loc);\n-      Expression* indir = Expression::make_unary(OPERATOR_MULT, call, loc);\n+      Expression* indir =\n+          Expression::make_dereference(call, Expression::NIL_CHECK_NOT_NEEDED,\n+                                       loc);\n       ref = Expression::make_temporary_reference(val_temp, loc);\n       b->add_statement(Statement::make_assignment(indir, ref, loc));\n \n@@ -1292,7 +1295,8 @@ Tuple_map_assignment_statement::do_lower(Gogo* gogo, Named_object*,\n \n   // val = *val__ptr_temp\n   ref = Expression::make_temporary_reference(val_ptr_temp, loc);\n-  Expression* ind = Expression::make_unary(OPERATOR_MULT, ref, loc);\n+  Expression* ind =\n+      Expression::make_dereference(ref, Expression::NIL_CHECK_NOT_NEEDED, loc);\n   s = Statement::make_assignment(this->val_, ind, loc);\n   b->add_statement(s);\n \n@@ -2367,8 +2371,10 @@ Thunk_statement::build_thunk(Gogo* gogo, const std::string& thunk_name)\n   // ones used in build_struct.\n   Expression* thunk_parameter = Expression::make_var_reference(named_parameter,\n \t\t\t\t\t\t\t       location);\n-  thunk_parameter = Expression::make_unary(OPERATOR_MULT, thunk_parameter,\n-\t\t\t\t\t   location);\n+  thunk_parameter =\n+      Expression::make_dereference(thunk_parameter,\n+                                   Expression::NIL_CHECK_NOT_NEEDED,\n+                                   location);\n \n   Interface_field_reference_expression* interface_method =\n     ce->fn()->interface_field_reference_expression();\n@@ -2421,8 +2427,10 @@ Thunk_statement::build_thunk(Gogo* gogo, const std::string& thunk_name)\n \t    {\n \t      Expression* thunk_param =\n \t\tExpression::make_var_reference(named_parameter, location);\n-\t      thunk_param =\n-\t\tExpression::make_unary(OPERATOR_MULT, thunk_param, location);\n+             thunk_param =\n+                 Expression::make_dereference(thunk_param,\n+                                              Expression::NIL_CHECK_NOT_NEEDED,\n+                                              location);\n \t      param = Expression::make_field_reference(thunk_param,\n \t\t\t\t\t\t       next_index,\n \t\t\t\t\t\t       location);\n@@ -5837,7 +5845,8 @@ For_range_statement::lower_range_map(Gogo* gogo,\n   Expression* lhs = Expression::make_temporary_reference(index_temp, loc);\n   Expression* rhs = Expression::make_temporary_reference(hiter, loc);\n   rhs = Expression::make_field_reference(ref, 0, loc);\n-  rhs = Expression::make_unary(OPERATOR_MULT, ref, loc);\n+  rhs = Expression::make_dereference(ref, Expression::NIL_CHECK_NOT_NEEDED,\n+                                     loc);\n   Statement* set = Statement::make_assignment(lhs, rhs, loc);\n   iter_init->add_statement(set);\n \n@@ -5846,7 +5855,8 @@ For_range_statement::lower_range_map(Gogo* gogo,\n       lhs = Expression::make_temporary_reference(value_temp, loc);\n       rhs = Expression::make_temporary_reference(hiter, loc);\n       rhs = Expression::make_field_reference(rhs, 1, loc);\n-      rhs = Expression::make_unary(OPERATOR_MULT, rhs, loc);\n+      rhs = Expression::make_dereference(rhs, Expression::NIL_CHECK_NOT_NEEDED,\n+                                         loc);\n       set = Statement::make_assignment(lhs, rhs, loc);\n       iter_init->add_statement(set);\n     }"}, {"sha": "2274c3134678d0c6112795fbd21b2374e8a4f0ec", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92f0112cab96a60bb777b81e93a5d10437c5fa60/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92f0112cab96a60bb777b81e93a5d10437c5fa60/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=92f0112cab96a60bb777b81e93a5d10437c5fa60", "patch": "@@ -2215,10 +2215,10 @@ Type::write_named_equal(Gogo* gogo, Named_type* name)\n \n   // Compare the values for equality.\n   Expression* t1 = Expression::make_temporary_reference(p1, bloc);\n-  t1 = Expression::make_unary(OPERATOR_MULT, t1, bloc);\n+  t1 = Expression::make_dereference(t1, Expression::NIL_CHECK_NOT_NEEDED, bloc);\n \n   Expression* t2 = Expression::make_temporary_reference(p2, bloc);\n-  t2 = Expression::make_unary(OPERATOR_MULT, t2, bloc);\n+  t2 = Expression::make_dereference(t2, Expression::NIL_CHECK_NOT_NEEDED, bloc);\n \n   Expression* cond = Expression::make_binary(OPERATOR_EQEQ, t1, t2, bloc);\n \n@@ -5911,7 +5911,9 @@ Struct_type::field_reference_depth(Expression* struct_expr,\n \t  Expression* here = Expression::make_field_reference(struct_expr, i,\n \t\t\t\t\t\t\t      location);\n \t  if (pf->type()->points_to() != NULL)\n-\t    here = Expression::make_unary(OPERATOR_MULT, here, location);\n+            here = Expression::make_dereference(here,\n+                                                Expression::NIL_CHECK_DEFAULT,\n+                                                location);\n \t  while (sub->expr() != NULL)\n \t    {\n \t      sub = sub->expr()->deref()->field_reference_expression();\n@@ -6342,11 +6344,13 @@ Struct_type::write_equal_function(Gogo* gogo, Named_type* name)\n \n       // Compare one field in both P1 and P2.\n       Expression* f1 = Expression::make_temporary_reference(p1, bloc);\n-      f1 = Expression::make_unary(OPERATOR_MULT, f1, bloc);\n+      f1 = Expression::make_dereference(f1, Expression::NIL_CHECK_DEFAULT,\n+                                        bloc);\n       f1 = Expression::make_field_reference(f1, field_index, bloc);\n \n       Expression* f2 = Expression::make_temporary_reference(p2, bloc);\n-      f2 = Expression::make_unary(OPERATOR_MULT, f2, bloc);\n+      f2 = Expression::make_dereference(f2, Expression::NIL_CHECK_DEFAULT,\n+                                        bloc);\n       f2 = Expression::make_field_reference(f2, field_index, bloc);\n \n       Expression* cond = Expression::make_binary(OPERATOR_NOTEQ, f1, f2, bloc);\n@@ -7193,12 +7197,12 @@ Array_type::write_equal_function(Gogo* gogo, Named_type* name)\n \n   // Compare element in P1 and P2.\n   Expression* e1 = Expression::make_temporary_reference(p1, bloc);\n-  e1 = Expression::make_unary(OPERATOR_MULT, e1, bloc);\n+  e1 = Expression::make_dereference(e1, Expression::NIL_CHECK_DEFAULT, bloc);\n   ref = Expression::make_temporary_reference(index, bloc);\n   e1 = Expression::make_array_index(e1, ref, NULL, NULL, bloc);\n \n   Expression* e2 = Expression::make_temporary_reference(p2, bloc);\n-  e2 = Expression::make_unary(OPERATOR_MULT, e2, bloc);\n+  e2 = Expression::make_dereference(e2, Expression::NIL_CHECK_DEFAULT, bloc);\n   ref = Expression::make_temporary_reference(index, bloc);\n   e2 = Expression::make_array_index(e2, ref, NULL, NULL, bloc);\n \n@@ -11219,7 +11223,8 @@ Type::apply_field_indexes(Expression* expr,\n   if (expr->type()->struct_type() == NULL)\n     {\n       go_assert(expr->type()->points_to() != NULL);\n-      expr = Expression::make_unary(OPERATOR_MULT, expr, location);\n+      expr = Expression::make_dereference(expr, Expression::NIL_CHECK_DEFAULT,\n+                                          location);\n       go_assert(expr->type()->struct_type() == stype);\n     }\n   return Expression::make_field_reference(expr, field_indexes->field_index,\n@@ -11323,7 +11328,8 @@ Type::bind_field_or_method(Gogo* gogo, const Type* type, Expression* expr,\n       && type->points_to() != NULL\n       && type->points_to()->points_to() != NULL)\n     {\n-      expr = Expression::make_unary(OPERATOR_MULT, expr, location);\n+      expr = Expression::make_dereference(expr, Expression::NIL_CHECK_DEFAULT,\n+                                          location);\n       type = type->points_to();\n       if (type->deref()->is_error_type())\n \treturn Expression::make_error(location);\n@@ -11356,8 +11362,9 @@ Type::bind_field_or_method(Gogo* gogo, const Type* type, Expression* expr,\n                   return Expression::make_error(location);\n                 }\n \t      go_assert(type->points_to() != NULL);\n-\t      expr = Expression::make_unary(OPERATOR_MULT, expr,\n-\t\t\t\t\t    location);\n+              expr = Expression::make_dereference(expr,\n+                                                  Expression::NIL_CHECK_DEFAULT,\n+                                                  location);\n \t      go_assert(expr->type()->struct_type() == st);\n \t    }\n \t  ret = st->field_reference(expr, name, location);"}, {"sha": "0085667ee046068490fbf25fb094f279e89b6609", "filename": "gcc/go/gofrontend/wb.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92f0112cab96a60bb777b81e93a5d10437c5fa60/gcc%2Fgo%2Fgofrontend%2Fwb.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92f0112cab96a60bb777b81e93a5d10437c5fa60/gcc%2Fgo%2Fgofrontend%2Fwb.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fwb.cc?ref=92f0112cab96a60bb777b81e93a5d10437c5fa60", "patch": "@@ -417,7 +417,8 @@ Gogo::assign_with_write_barrier(Function* function, Block* enclosing,\n       rhs = Expression::make_temporary_reference(rhs_temp, loc);\n     }\n \n-  Expression* indir = Expression::make_unary(OPERATOR_MULT, lhs, loc);\n+  Expression* indir =\n+      Expression::make_dereference(lhs, Expression::NIL_CHECK_DEFAULT, loc);\n   Statement* assign = Statement::make_assignment(indir, rhs, loc);\n \n   lhs = Expression::make_temporary_reference(lhs_temp, loc);"}]}