{"sha": "f35bcbc5d0803d2e92b8f725a1b2165d144ab156", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjM1YmNiYzVkMDgwM2QyZTkyYjhmNzI1YTFiMjE2NWQxNDRhYjE1Ng==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1997-11-14T14:51:00Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-11-14T14:51:00Z"}, "message": "expr.c (expand_builtin_setjmp): Set current_function_has_nonlocal_label.\n\n        * expr.c (expand_builtin_setjmp): Set\n        current_function_has_nonlocal_label.\n        * stupid.c (stupid_life_analysis): If has_nonlocal_label, kill\n        call-saved registers across calls.\n\n        * alpha.md (exception_receiver): Remove.\n        (nonlocal_goto_receiver_osf): New\n        (nonlocal_goto_receiver_vms): Renamed from nonlocal_goto_receiver.\n        (nonlocal_goto_receiver): New, select _osf or _vms.\n\nFrom-SVN: r16492", "tree": {"sha": "35e19146329addf80bfbc10fa38f7d78bfef3bf6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35e19146329addf80bfbc10fa38f7d78bfef3bf6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f35bcbc5d0803d2e92b8f725a1b2165d144ab156", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f35bcbc5d0803d2e92b8f725a1b2165d144ab156", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f35bcbc5d0803d2e92b8f725a1b2165d144ab156", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f35bcbc5d0803d2e92b8f725a1b2165d144ab156/comments", "author": null, "committer": null, "parents": [{"sha": "531ea24eef795133abdbfd4bb49e69196ea3668f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/531ea24eef795133abdbfd4bb49e69196ea3668f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/531ea24eef795133abdbfd4bb49e69196ea3668f"}], "stats": {"total": 76, "additions": 56, "deletions": 20}, "files": [{"sha": "c7d4a414319b66e9e5ffca12075d0cc093d8e618", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35bcbc5d0803d2e92b8f725a1b2165d144ab156/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35bcbc5d0803d2e92b8f725a1b2165d144ab156/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f35bcbc5d0803d2e92b8f725a1b2165d144ab156", "patch": "@@ -1,5 +1,15 @@\n Fri Nov 14 07:24:20 1997  Richard Henderson  <rth@cygnus.com>\n \n+\t* expr.c (expand_builtin_setjmp): Set\n+\tcurrent_function_has_nonlocal_label.\n+\t* stupid.c (stupid_life_analysis): If has_nonlocal_label, kill\n+\tcall-saved registers across calls.\n+\n+\t* alpha.md (exception_receiver): Remove.\n+\t(nonlocal_goto_receiver_osf): New\n+\t(nonlocal_goto_receiver_vms): Renamed from nonlocal_goto_receiver.\n+\t(nonlocal_goto_receiver): New, select _osf or _vms.\n+\n \t* alpha.c (output_prolog [*]): Prefix entry labels with '$' to\n \tkeep them from being propogated to the object file.\n \t(alpha_write_linkage): Likewise."}, {"sha": "5a7218dbd4e840b9623cc6b3cce61c44a9d634b7", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35bcbc5d0803d2e92b8f725a1b2165d144ab156/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35bcbc5d0803d2e92b8f725a1b2165d144ab156/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=f35bcbc5d0803d2e92b8f725a1b2165d144ab156", "patch": "@@ -4683,19 +4683,34 @@\n     }\n }\")\n \n-(define_insn \"exception_receiver\"\n+;; Ideally we should be able to define nonlocal_goto and arrange\n+;; for the pc to be in a known place.  Or perhaps branch back via\n+;; br instead of jmp.\n+(define_insn \"nonlocal_goto_receiver_osf\"\n   [(unspec_volatile [(const_int 0)] 2)]\n   \"! TARGET_OPEN_VMS && ! TARGET_WINDOWS_NT\"\n-  \".long 0xc3a00000\\;ldgp $29,0($29)\")\n+  \"br $29,$LGOTO%=\\\\n$LGOTO%=:\\;ldgp $29,0($29)\")\n \n-(define_expand \"nonlocal_goto_receiver\"\n+(define_expand \"nonlocal_goto_receiver_vms\"\n   [(unspec_volatile [(const_int 0)] 1)\n    (set (reg:DI 27) (mem:DI (reg:DI 29)))\n    (unspec_volatile [(const_int 0)] 1)\n    (use (reg:DI 27))]\n   \"TARGET_OPEN_VMS\"\n   \"\")\n \n+(define_expand \"nonlocal_goto_receiver\"\n+  [(unspec_volatile [(const_int 0)] 2)]\n+  \"\"\n+  \"\n+{\n+  if (TARGET_OPEN_VMS)\n+    emit_insn(gen_nonlocal_goto_receiver_vms ());\n+  else if (!TARGET_WINDOWS_NT)\n+    emit_insn(gen_nonlocal_goto_receiver_osf ());\n+  DONE;\n+}\")\n+\n (define_insn \"arg_home\"\n   [(unspec [(const_int 0)] 0)\n    (use (reg:DI 1))"}, {"sha": "7545c43ea8d7c16bbdd695cc099e61e804fc8474", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35bcbc5d0803d2e92b8f725a1b2165d144ab156/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35bcbc5d0803d2e92b8f725a1b2165d144ab156/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=f35bcbc5d0803d2e92b8f725a1b2165d144ab156", "patch": "@@ -8213,12 +8213,7 @@ expand_builtin_setjmp (buf_addr, target)\n #endif\n     emit_move_insn (virtual_stack_vars_rtx, hard_frame_pointer_rtx);\n \n-  /* Do we need to do something like:\n-     \n-     current_function_has_nonlocal_label = 1;\n-\n-     here?  It seems like we might have to, or some subset of that\n-     functionality, but I am unsure.  (mrs) */\n+  current_function_has_nonlocal_label = 1;\n \n #if ARG_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n   if (fixed_regs[ARG_POINTER_REGNUM])"}, {"sha": "028539aa1936cc58e19032e18895dedc54a31a48", "filename": "gcc/stupid.c", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35bcbc5d0803d2e92b8f725a1b2165d144ab156/gcc%2Fstupid.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35bcbc5d0803d2e92b8f725a1b2165d144ab156/gcc%2Fstupid.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstupid.c?ref=f35bcbc5d0803d2e92b8f725a1b2165d144ab156", "patch": "@@ -42,8 +42,8 @@ Boston, MA 02111-1307, USA.  */\n    pseudo reg is computed.  Then the pseudo regs are ordered by priority\n    and assigned hard regs in priority order.  */\n \n-#include <stdio.h>\n #include \"config.h\"\n+#include <stdio.h>\n #include \"rtl.h\"\n #include \"hard-reg-set.h\"\n #include \"regs.h\"\n@@ -230,21 +230,34 @@ stupid_life_analysis (f, nregs, file)\n \t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_SETJMP)\n \tlast_setjmp_suid = INSN_SUID (insn);\n \n-      /* Mark all call-clobbered regs as live after each call insn\n-\t so that a pseudo whose life span includes this insn\n-\t will not go in one of them.\n+      /* Mark all call-clobbered regs as dead after each call insn so that\n+\t a pseudo whose life span includes this insn will not go in one of\n+\t them.  If the function contains a non-local goto, mark all hard\n+\t registers dead (except for stack related bits).\n+\n \t Then mark those regs as all dead for the continuing scan\n \t of the insns before the call.  */\n \n       if (GET_CODE (insn) == CALL_INSN)\n \t{\n \t  last_call_suid = INSN_SUID (insn);\n-\t  IOR_HARD_REG_SET (after_insn_hard_regs[last_call_suid],\n-\t\t\t    call_used_reg_set);\n \n-\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t    if (call_used_regs[i])\n-\t      regs_live[i] = 0;\n+\t  if (current_function_has_nonlocal_label)\n+\t    {\n+\t      IOR_COMPL_HARD_REG_SET (after_insn_hard_regs[last_call_suid],\n+\t\t\t\t      fixed_reg_set);\n+\t      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t\tif (! fixed_regs[i])\n+\t          regs_live[i] = 0;\n+\t    }\n+\t  else\n+\t    {\n+\t      IOR_HARD_REG_SET (after_insn_hard_regs[last_call_suid],\n+\t\t\t\tcall_used_reg_set);\n+\t      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t        if (call_used_regs[i])\n+\t          regs_live[i] = 0;\n+\t    }\n \n \t  /* It is important that this be done after processing the insn's\n \t     pattern because we want the function result register to still\n@@ -269,8 +282,11 @@ stupid_life_analysis (f, nregs, file)\n       register int r = reg_order[i];\n \n       /* Some regnos disappear from the rtl.  Ignore them to avoid crash. \n-\t Also don't allocate registers that cross a setjmp.  */\n-      if (regno_reg_rtx[r] == 0 || regs_crosses_setjmp[r])\n+\t Also don't allocate registers that cross a setjmp, or live across\n+\t a call if this function receives a nonlocal goto.  */\n+      if (regno_reg_rtx[r] == 0 || regs_crosses_setjmp[r]\n+\t  || (REG_N_CALLS_CROSSED (r) > 0 \n+\t      && current_function_has_nonlocal_label))\n \tcontinue;\n \n       /* Now find the best hard-register class for this pseudo register */"}]}