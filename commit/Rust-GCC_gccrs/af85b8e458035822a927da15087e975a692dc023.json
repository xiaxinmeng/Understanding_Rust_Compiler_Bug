{"sha": "af85b8e458035822a927da15087e975a692dc023", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWY4NWI4ZTQ1ODAzNTgyMmE5MjdkYTE1MDg3ZTk3NWE2OTJkYzAyMw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-03-03T17:27:54Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-03-03T17:27:54Z"}, "message": "* fold-const.c (fold): Remove handling of unary expressions.\n\nFrom-SVN: r95836", "tree": {"sha": "c658c8f604a66c24f516c9e892ab568cc70c7f9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c658c8f604a66c24f516c9e892ab568cc70c7f9c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af85b8e458035822a927da15087e975a692dc023", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af85b8e458035822a927da15087e975a692dc023", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af85b8e458035822a927da15087e975a692dc023", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af85b8e458035822a927da15087e975a692dc023/comments", "author": null, "committer": null, "parents": [{"sha": "4430da7ffcfade5aab8ffc561202e810f2ef5ae6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4430da7ffcfade5aab8ffc561202e810f2ef5ae6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4430da7ffcfade5aab8ffc561202e810f2ef5ae6"}], "stats": {"total": 402, "additions": 4, "deletions": 398}, "files": [{"sha": "0196b4eede97cddee2269e1160cae38c18675df3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af85b8e458035822a927da15087e975a692dc023/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af85b8e458035822a927da15087e975a692dc023/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=af85b8e458035822a927da15087e975a692dc023", "patch": "@@ -9,6 +9,8 @@\n \t* tree-phinodes.c (remove_phi_node): Clean up by factoring out\n \tcalls to release_ssa_name and release_phi_node.\n \n+\t* fold-const.c (fold): Remove handling of unary expressions.\n+\n 2005-03-03  Roger Sayle  <roger@eyesopen.com>\n \t    Andrew Pinski  <pinskia@physics.uc.edu>\n "}, {"sha": "470035994ce84a8915756ae049ec5d3f707fa4be", "filename": "gcc/fold-const.c", "status": "modified", "additions": 2, "deletions": 398, "changes": 400, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af85b8e458035822a927da15087e975a692dc023/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af85b8e458035822a927da15087e975a692dc023/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=af85b8e458035822a927da15087e975a692dc023", "patch": "@@ -7063,30 +7063,7 @@ fold (tree expr)\n \t}\n     }\n \n-  if (code == NOP_EXPR || code == FLOAT_EXPR || code == CONVERT_EXPR)\n-    {\n-      tree subop;\n-\n-      /* Special case for conversion ops that can have fixed point args.  */\n-      arg0 = TREE_OPERAND (t, 0);\n-\n-      /* Don't use STRIP_NOPS, because signedness of argument type matters.  */\n-      if (arg0 != 0)\n-\tSTRIP_SIGN_NOPS (arg0);\n-\n-      if (arg0 != 0 && TREE_CODE (arg0) == COMPLEX_CST)\n-\tsubop = TREE_REALPART (arg0);\n-      else\n-\tsubop = arg0;\n-\n-      if (subop != 0 && TREE_CODE (subop) != INTEGER_CST\n-\t  && TREE_CODE (subop) != REAL_CST)\n-\t/* Note that TREE_CONSTANT isn't enough:\n-\t   static var addresses are constant but we can't\n-\t   do arithmetic on them.  */\n-\twins = 0;\n-    }\n-  else if (IS_EXPR_CODE_CLASS (kind))\n+  if (IS_EXPR_CODE_CLASS (kind))\n     {\n       int len = TREE_CODE_LENGTH (code);\n       int i;\n@@ -7181,71 +7158,7 @@ fold (tree expr)\n       return tem;\n     }\n \n-  if (TREE_CODE_CLASS (code) == tcc_unary)\n-    {\n-      if (TREE_CODE (arg0) == COMPOUND_EXPR)\n-\treturn build2 (COMPOUND_EXPR, type, TREE_OPERAND (arg0, 0),\n-\t\t       fold (build1 (code, type, TREE_OPERAND (arg0, 1))));\n-      else if (TREE_CODE (arg0) == COND_EXPR)\n-\t{\n-\t  tree arg01 = TREE_OPERAND (arg0, 1);\n-\t  tree arg02 = TREE_OPERAND (arg0, 2);\n-\t  if (! VOID_TYPE_P (TREE_TYPE (arg01)))\n-\t    arg01 = fold (build1 (code, type, arg01));\n-\t  if (! VOID_TYPE_P (TREE_TYPE (arg02)))\n-\t    arg02 = fold (build1 (code, type, arg02));\n-\t  tem = fold (build3 (COND_EXPR, type, TREE_OPERAND (arg0, 0),\n-\t\t\t      arg01, arg02));\n-\n-\t  /* If this was a conversion, and all we did was to move into\n-\t     inside the COND_EXPR, bring it back out.  But leave it if\n-\t     it is a conversion from integer to integer and the\n-\t     result precision is no wider than a word since such a\n-\t     conversion is cheap and may be optimized away by combine,\n-\t     while it couldn't if it were outside the COND_EXPR.  Then return\n-\t     so we don't get into an infinite recursion loop taking the\n-\t     conversion out and then back in.  */\n-\n-\t  if ((code == NOP_EXPR || code == CONVERT_EXPR\n-\t       || code == NON_LVALUE_EXPR)\n-\t      && TREE_CODE (tem) == COND_EXPR\n-\t      && TREE_CODE (TREE_OPERAND (tem, 1)) == code\n-\t      && TREE_CODE (TREE_OPERAND (tem, 2)) == code\n-\t      && ! VOID_TYPE_P (TREE_OPERAND (tem, 1))\n-\t      && ! VOID_TYPE_P (TREE_OPERAND (tem, 2))\n-\t      && (TREE_TYPE (TREE_OPERAND (TREE_OPERAND (tem, 1), 0))\n-\t\t  == TREE_TYPE (TREE_OPERAND (TREE_OPERAND (tem, 2), 0)))\n-\t      && (! (INTEGRAL_TYPE_P (TREE_TYPE (tem))\n-\t\t     && (INTEGRAL_TYPE_P\n-\t\t\t (TREE_TYPE (TREE_OPERAND (TREE_OPERAND (tem, 1), 0))))\n-\t\t     && TYPE_PRECISION (TREE_TYPE (tem)) <= BITS_PER_WORD)\n-\t\t  || flag_syntax_only))\n-\t    tem = build1 (code, type,\n-\t\t\t  build3 (COND_EXPR,\n-\t\t\t\t  TREE_TYPE (TREE_OPERAND\n-\t\t\t\t\t     (TREE_OPERAND (tem, 1), 0)),\n-\t\t\t\t  TREE_OPERAND (tem, 0),\n-\t\t\t\t  TREE_OPERAND (TREE_OPERAND (tem, 1), 0),\n-\t\t\t\t  TREE_OPERAND (TREE_OPERAND (tem, 2), 0)));\n-\t  return tem;\n-\t}\n-      else if (COMPARISON_CLASS_P (arg0))\n-\t{\n-\t  if (TREE_CODE (type) == BOOLEAN_TYPE)\n-\t    {\n-\t      arg0 = copy_node (arg0);\n-\t      TREE_TYPE (arg0) = type;\n-\t      return arg0;\n-\t    }\n-\t  else if (TREE_CODE (type) != INTEGER_TYPE)\n-\t    return fold (build3 (COND_EXPR, type, arg0,\n-\t\t\t\t fold (build1 (code, type,\n-\t\t\t\t\t       integer_one_node)),\n-\t\t\t\t fold (build1 (code, type,\n-\t\t\t\t\t       integer_zero_node))));\n-\t}\n-   }\n-  else if (TREE_CODE_CLASS (code) == tcc_comparison\n+  if (TREE_CODE_CLASS (code) == tcc_comparison\n \t   && TREE_CODE (arg0) == COMPOUND_EXPR)\n     return build2 (COMPOUND_EXPR, type, TREE_OPERAND (arg0, 0),\n \t\t   fold (build2 (code, type, TREE_OPERAND (arg0, 1), arg1)));\n@@ -7288,194 +7201,6 @@ fold (tree expr)\n     case CONST_DECL:\n       return fold (DECL_INITIAL (t));\n \n-    case NOP_EXPR:\n-    case FLOAT_EXPR:\n-    case CONVERT_EXPR:\n-    case FIX_TRUNC_EXPR:\n-    case FIX_CEIL_EXPR:\n-    case FIX_FLOOR_EXPR:\n-    case FIX_ROUND_EXPR:\n-      if (TREE_TYPE (TREE_OPERAND (t, 0)) == type)\n-\treturn TREE_OPERAND (t, 0);\n-\n-      /* Handle cases of two conversions in a row.  */\n-      if (TREE_CODE (TREE_OPERAND (t, 0)) == NOP_EXPR\n-\t  || TREE_CODE (TREE_OPERAND (t, 0)) == CONVERT_EXPR)\n-\t{\n-\t  tree inside_type = TREE_TYPE (TREE_OPERAND (TREE_OPERAND (t, 0), 0));\n-\t  tree inter_type = TREE_TYPE (TREE_OPERAND (t, 0));\n-\t  int inside_int = INTEGRAL_TYPE_P (inside_type);\n-\t  int inside_ptr = POINTER_TYPE_P (inside_type);\n-\t  int inside_float = FLOAT_TYPE_P (inside_type);\n-\t  unsigned int inside_prec = TYPE_PRECISION (inside_type);\n-\t  int inside_unsignedp = TYPE_UNSIGNED (inside_type);\n-\t  int inter_int = INTEGRAL_TYPE_P (inter_type);\n-\t  int inter_ptr = POINTER_TYPE_P (inter_type);\n-\t  int inter_float = FLOAT_TYPE_P (inter_type);\n-\t  unsigned int inter_prec = TYPE_PRECISION (inter_type);\n-\t  int inter_unsignedp = TYPE_UNSIGNED (inter_type);\n-\t  int final_int = INTEGRAL_TYPE_P (type);\n-\t  int final_ptr = POINTER_TYPE_P (type);\n-\t  int final_float = FLOAT_TYPE_P (type);\n-\t  unsigned int final_prec = TYPE_PRECISION (type);\n-\t  int final_unsignedp = TYPE_UNSIGNED (type);\n-\n-\t  /* In addition to the cases of two conversions in a row\n-\t     handled below, if we are converting something to its own\n-\t     type via an object of identical or wider precision, neither\n-\t     conversion is needed.  */\n-\t  if (TYPE_MAIN_VARIANT (inside_type) == TYPE_MAIN_VARIANT (type)\n-\t      && ((inter_int && final_int) || (inter_float && final_float))\n-\t      && inter_prec >= final_prec)\n-\t    return fold (build1 (code, type,\n-\t\t\t\t TREE_OPERAND (TREE_OPERAND (t, 0), 0)));\n-\n-\t  /* Likewise, if the intermediate and final types are either both\n-\t     float or both integer, we don't need the middle conversion if\n-\t     it is wider than the final type and doesn't change the signedness\n-\t     (for integers).  Avoid this if the final type is a pointer\n-\t     since then we sometimes need the inner conversion.  Likewise if\n-\t     the outer has a precision not equal to the size of its mode.  */\n-\t  if ((((inter_int || inter_ptr) && (inside_int || inside_ptr))\n-\t       || (inter_float && inside_float))\n-\t      && inter_prec >= inside_prec\n-\t      && (inter_float || inter_unsignedp == inside_unsignedp)\n-\t      && ! (final_prec != GET_MODE_BITSIZE (TYPE_MODE (type))\n-\t\t    && TYPE_MODE (type) == TYPE_MODE (inter_type))\n-\t      && ! final_ptr)\n-\t    return fold (build1 (code, type,\n-\t\t\t\t TREE_OPERAND (TREE_OPERAND (t, 0), 0)));\n-\n-\t  /* If we have a sign-extension of a zero-extended value, we can\n-\t     replace that by a single zero-extension.  */\n-\t  if (inside_int && inter_int && final_int\n-\t      && inside_prec < inter_prec && inter_prec < final_prec\n-\t      && inside_unsignedp && !inter_unsignedp)\n-\t    return fold (build1 (code, type,\n-\t\t\t\t TREE_OPERAND (TREE_OPERAND (t, 0), 0)));\n-\n-\t  /* Two conversions in a row are not needed unless:\n-\t     - some conversion is floating-point (overstrict for now), or\n-\t     - the intermediate type is narrower than both initial and\n-\t       final, or\n-\t     - the intermediate type and innermost type differ in signedness,\n-\t       and the outermost type is wider than the intermediate, or\n-\t     - the initial type is a pointer type and the precisions of the\n-\t       intermediate and final types differ, or\n-\t     - the final type is a pointer type and the precisions of the\n-\t       initial and intermediate types differ.  */\n-\t  if (! inside_float && ! inter_float && ! final_float\n-\t      && (inter_prec > inside_prec || inter_prec > final_prec)\n-\t      && ! (inside_int && inter_int\n-\t\t    && inter_unsignedp != inside_unsignedp\n-\t\t    && inter_prec < final_prec)\n-\t      && ((inter_unsignedp && inter_prec > inside_prec)\n-\t\t  == (final_unsignedp && final_prec > inter_prec))\n-\t      && ! (inside_ptr && inter_prec != final_prec)\n-\t      && ! (final_ptr && inside_prec != inter_prec)\n-\t      && ! (final_prec != GET_MODE_BITSIZE (TYPE_MODE (type))\n-\t\t    && TYPE_MODE (type) == TYPE_MODE (inter_type))\n-\t      && ! final_ptr)\n-\t    return fold (build1 (code, type,\n-\t\t\t\t TREE_OPERAND (TREE_OPERAND (t, 0), 0)));\n-\t}\n-\n-      if (TREE_CODE (TREE_OPERAND (t, 0)) == MODIFY_EXPR\n-\t  && TREE_CONSTANT (TREE_OPERAND (TREE_OPERAND (t, 0), 1))\n-\t  /* Detect assigning a bitfield.  */\n-\t  && !(TREE_CODE (TREE_OPERAND (TREE_OPERAND (t, 0), 0)) == COMPONENT_REF\n-\t       && DECL_BIT_FIELD (TREE_OPERAND (TREE_OPERAND (TREE_OPERAND (t, 0), 0), 1))))\n-\t{\n-\t  /* Don't leave an assignment inside a conversion\n-\t     unless assigning a bitfield.  */\n-\t  tree prev = TREE_OPERAND (t, 0);\n-\t  tem = copy_node (t);\n-\t  TREE_OPERAND (tem, 0) = TREE_OPERAND (prev, 1);\n-\t  /* First do the assignment, then return converted constant.  */\n-\t  tem = build2 (COMPOUND_EXPR, TREE_TYPE (tem), prev, fold (tem));\n-\t  TREE_NO_WARNING (tem) = 1;\n-\t  TREE_USED (tem) = 1;\n-\t  return tem;\n-\t}\n-\n-      /* Convert (T)(x & c) into (T)x & (T)c, if c is an integer\n-\t constants (if x has signed type, the sign bit cannot be set\n-\t in c).  This folds extension into the BIT_AND_EXPR.  */\n-      if (INTEGRAL_TYPE_P (type)\n-\t  && TREE_CODE (type) != BOOLEAN_TYPE\n-\t  && TREE_CODE (TREE_OPERAND (t, 0)) == BIT_AND_EXPR\n-\t  && TREE_CODE (TREE_OPERAND (TREE_OPERAND (t, 0), 1)) == INTEGER_CST)\n-\t{\n-\t  tree and = TREE_OPERAND (t, 0);\n-\t  tree and0 = TREE_OPERAND (and, 0), and1 = TREE_OPERAND (and, 1);\n-\t  int change = 0;\n-\n-\t  if (TYPE_UNSIGNED (TREE_TYPE (and))\n-\t      || (TYPE_PRECISION (type)\n-\t\t  <= TYPE_PRECISION (TREE_TYPE (and))))\n-\t    change = 1;\n-\t  else if (TYPE_PRECISION (TREE_TYPE (and1))\n-\t\t   <= HOST_BITS_PER_WIDE_INT\n-\t\t   && host_integerp (and1, 1))\n-\t    {\n-\t      unsigned HOST_WIDE_INT cst;\n-\n-\t      cst = tree_low_cst (and1, 1);\n-\t      cst &= (HOST_WIDE_INT) -1\n-\t\t     << (TYPE_PRECISION (TREE_TYPE (and1)) - 1);\n-\t      change = (cst == 0);\n-#ifdef LOAD_EXTEND_OP\n-\t      if (change\n-\t\t  && !flag_syntax_only\n-\t\t  && (LOAD_EXTEND_OP (TYPE_MODE (TREE_TYPE (and0)))\n-\t\t      == ZERO_EXTEND))\n-\t\t{\n-\t\t  tree uns = lang_hooks.types.unsigned_type (TREE_TYPE (and0));\n-\t\t  and0 = fold_convert (uns, and0);\n-\t\t  and1 = fold_convert (uns, and1);\n-\t\t}\n-#endif\n-\t    }\n-\t  if (change)\n-\t    {\n-\t      tem = build_int_cst_wide (type, TREE_INT_CST_LOW (and1),\n-\t\t\t\t\tTREE_INT_CST_HIGH (and1));\n-\t      tem = force_fit_type (tem, 0, TREE_OVERFLOW (and1),\n-\t\t\t\t    TREE_CONSTANT_OVERFLOW (and1));\n-\t      return fold (build2 (BIT_AND_EXPR, type,\n-\t\t\t\t   fold_convert (type, and0), tem));\n-\t    }\n-\t}\n-\n-      /* Convert (T1)((T2)X op Y) into (T1)X op Y, for pointer types T1 and\n-\t T2 being pointers to types of the same size.  */\n-      if (POINTER_TYPE_P (TREE_TYPE (t))\n-\t  && BINARY_CLASS_P (arg0)\n-\t  && TREE_CODE (TREE_OPERAND (arg0, 0)) == NOP_EXPR\n-\t  && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (arg0, 0))))\n-\t{\n-\t  tree arg00 = TREE_OPERAND (arg0, 0);\n-\t  tree t0 = TREE_TYPE (t);\n-\t  tree t1 = TREE_TYPE (arg00);\n-\t  tree tt0 = TREE_TYPE (t0);\n-\t  tree tt1 = TREE_TYPE (t1);\n-\t  tree s0 = TYPE_SIZE (tt0);\n-\t  tree s1 = TYPE_SIZE (tt1);\n-\n-\t  if (s0 && s1 && operand_equal_p (s0, s1, OEP_ONLY_CONST))\n-\t    return build2 (TREE_CODE (arg0), t0, fold_convert (t0, arg00),\n-\t\t\t   TREE_OPERAND (arg0, 1));\n-\t}\n-\n-      tem = fold_convert_const (code, type, arg0);\n-      return tem ? tem : t;\n-\n-    case VIEW_CONVERT_EXPR:\n-      if (TREE_CODE (TREE_OPERAND (t, 0)) == VIEW_CONVERT_EXPR)\n-\treturn build1 (VIEW_CONVERT_EXPR, type,\n-\t\t       TREE_OPERAND (TREE_OPERAND (t, 0), 0));\n-      return t;\n-\n     case COMPONENT_REF:\n       if (TREE_CODE (arg0) == CONSTRUCTOR\n \t  && ! type_contains_placeholder_p (TREE_TYPE (arg0)))\n@@ -7496,80 +7221,6 @@ fold (tree expr)\n \t}\n       return t;\n \n-    case NEGATE_EXPR:\n-      if (negate_expr_p (arg0))\n-\treturn fold_convert (type, negate_expr (arg0));\n-      /* Convert - (~A) to A + 1.  */\n-      if (INTEGRAL_TYPE_P (type) && TREE_CODE (arg0) == BIT_NOT_EXPR)\n-\treturn fold (build2 (PLUS_EXPR, type, TREE_OPERAND (arg0, 0),\n-\t\t\t     build_int_cst (type, 1)));\n-      return t;\n-\n-    case ABS_EXPR:\n-      if (TREE_CODE (arg0) == INTEGER_CST || TREE_CODE (arg0) == REAL_CST)\n-\treturn fold_abs_const (arg0, type);\n-      else if (TREE_CODE (arg0) == NEGATE_EXPR)\n-\treturn fold (build1 (ABS_EXPR, type, TREE_OPERAND (arg0, 0)));\n-      /* Convert fabs((double)float) into (double)fabsf(float).  */\n-      else if (TREE_CODE (arg0) == NOP_EXPR\n-\t       && TREE_CODE (type) == REAL_TYPE)\n-\t{\n-\t  tree targ0 = strip_float_extensions (arg0);\n-\t  if (targ0 != arg0)\n-\t    return fold_convert (type, fold (build1 (ABS_EXPR,\n-\t\t\t\t\t\t     TREE_TYPE (targ0),\n-\t\t\t\t\t\t     targ0)));\n-\t}\n-      else if (tree_expr_nonnegative_p (arg0))\n-\treturn arg0;\n-\n-      /* Strip sign ops from argument.  */\n-      if (TREE_CODE (type) == REAL_TYPE)\n-\t{\n-\t  tem = fold_strip_sign_ops (arg0);\n-\t  if (tem)\n-\t    return fold (build1 (ABS_EXPR, type, fold_convert (type, tem)));\n-\t}\n-      return t;\n-\n-    case CONJ_EXPR:\n-      if (TREE_CODE (TREE_TYPE (arg0)) != COMPLEX_TYPE)\n-\treturn fold_convert (type, arg0);\n-      else if (TREE_CODE (arg0) == COMPLEX_EXPR)\n-\treturn build2 (COMPLEX_EXPR, type,\n-\t\t       TREE_OPERAND (arg0, 0),\n-\t\t       negate_expr (TREE_OPERAND (arg0, 1)));\n-      else if (TREE_CODE (arg0) == COMPLEX_CST)\n-\treturn build_complex (type, TREE_REALPART (arg0),\n-\t\t\t      negate_expr (TREE_IMAGPART (arg0)));\n-      else if (TREE_CODE (arg0) == PLUS_EXPR || TREE_CODE (arg0) == MINUS_EXPR)\n-\treturn fold (build2 (TREE_CODE (arg0), type,\n-\t\t\t     fold (build1 (CONJ_EXPR, type,\n-\t\t\t\t\t   TREE_OPERAND (arg0, 0))),\n-\t\t\t     fold (build1 (CONJ_EXPR, type,\n-\t\t\t\t\t   TREE_OPERAND (arg0, 1)))));\n-      else if (TREE_CODE (arg0) == CONJ_EXPR)\n-\treturn TREE_OPERAND (arg0, 0);\n-      return t;\n-\n-    case BIT_NOT_EXPR:\n-      if (TREE_CODE (arg0) == INTEGER_CST)\n-        return fold_not_const (arg0, type);\n-      else if (TREE_CODE (arg0) == BIT_NOT_EXPR)\n-\treturn TREE_OPERAND (arg0, 0);\n-      /* Convert ~ (-A) to A - 1.  */\n-      else if (INTEGRAL_TYPE_P (type) && TREE_CODE (arg0) == NEGATE_EXPR)\n-\treturn fold (build2 (MINUS_EXPR, type, TREE_OPERAND (arg0, 0),\n-\t\t\t     build_int_cst (type, 1)));\n-      /* Convert ~ (A - 1) or ~ (A + -1) to -A.  */\n-      else if (INTEGRAL_TYPE_P (type)\n-\t       && ((TREE_CODE (arg0) == MINUS_EXPR\n-\t\t    && integer_onep (TREE_OPERAND (arg0, 1)))\n-\t\t   || (TREE_CODE (arg0) == PLUS_EXPR\n-\t\t       && integer_all_onesp (TREE_OPERAND (arg0, 1)))))\n-\treturn fold (build1 (NEGATE_EXPR, type, TREE_OPERAND (arg0, 0)));\n-      return t;\n-\n     case PLUS_EXPR:\n       /* A + (-B) -> A - B */\n       if (TREE_CODE (arg1) == NEGATE_EXPR)\n@@ -8907,21 +8558,6 @@ fold (tree expr)\n \treturn omit_one_operand (type, arg1, arg0);\n       goto associate;\n \n-    case TRUTH_NOT_EXPR:\n-      /* The argument to invert_truthvalue must have Boolean type.  */\n-      if (TREE_CODE (TREE_TYPE (arg0)) != BOOLEAN_TYPE)\n-          arg0 = fold_convert (boolean_type_node, arg0);\n-\n-      /* Note that the operand of this must be an int\n-\t and its values must be 0 or 1.\n-\t (\"true\" is a fixed value perhaps depending on the language,\n-\t but we don't handle values other than 1 correctly yet.)  */\n-      tem = invert_truthvalue (arg0);\n-      /* Avoid infinite recursion.  */\n-      if (TREE_CODE (tem) == TRUTH_NOT_EXPR)\n-\treturn t;\n-      return fold_convert (type, tem);\n-\n     case TRUTH_ANDIF_EXPR:\n       /* Note that the operands of this must be ints\n \t and their values must be 0 or 1.\n@@ -10194,38 +9830,6 @@ fold (tree expr)\n \treturn build_complex (type, arg0, arg1);\n       return t;\n \n-    case REALPART_EXPR:\n-      if (TREE_CODE (TREE_TYPE (arg0)) != COMPLEX_TYPE)\n-\treturn t;\n-      else if (TREE_CODE (arg0) == COMPLEX_EXPR)\n-\treturn omit_one_operand (type, TREE_OPERAND (arg0, 0),\n-\t\t\t\t TREE_OPERAND (arg0, 1));\n-      else if (TREE_CODE (arg0) == COMPLEX_CST)\n-\treturn TREE_REALPART (arg0);\n-      else if (TREE_CODE (arg0) == PLUS_EXPR || TREE_CODE (arg0) == MINUS_EXPR)\n-\treturn fold (build2 (TREE_CODE (arg0), type,\n-\t\t\t     fold (build1 (REALPART_EXPR, type,\n-\t\t\t\t\t   TREE_OPERAND (arg0, 0))),\n-\t\t\t     fold (build1 (REALPART_EXPR, type,\n-\t\t\t\t\t   TREE_OPERAND (arg0, 1)))));\n-      return t;\n-\n-    case IMAGPART_EXPR:\n-      if (TREE_CODE (TREE_TYPE (arg0)) != COMPLEX_TYPE)\n-\treturn fold_convert (type, integer_zero_node);\n-      else if (TREE_CODE (arg0) == COMPLEX_EXPR)\n-\treturn omit_one_operand (type, TREE_OPERAND (arg0, 1),\n-\t\t\t\t TREE_OPERAND (arg0, 0));\n-      else if (TREE_CODE (arg0) == COMPLEX_CST)\n-\treturn TREE_IMAGPART (arg0);\n-      else if (TREE_CODE (arg0) == PLUS_EXPR || TREE_CODE (arg0) == MINUS_EXPR)\n-\treturn fold (build2 (TREE_CODE (arg0), type,\n-\t\t\t     fold (build1 (IMAGPART_EXPR, type,\n-\t\t\t\t\t   TREE_OPERAND (arg0, 0))),\n-\t\t\t     fold (build1 (IMAGPART_EXPR, type,\n-\t\t\t\t\t   TREE_OPERAND (arg0, 1)))));\n-      return t;\n-\n     case CALL_EXPR:\n       /* Check for a built-in function.  */\n       if (TREE_CODE (TREE_OPERAND (t, 0)) == ADDR_EXPR"}]}