{"sha": "c75ebe76ae12ac4020f20a24f34606a594a40d15", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzc1ZWJlNzZhZTEyYWM0MDIwZjIwYTI0ZjM0NjA2YTU5NGE0MGQxNQ==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-05-22T14:28:19Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-05-29T22:18:29Z"}, "message": "c++: P0848R3 and member function templates [PR95181]\n\nWhen comparing two special member function templates to see if one hides\nthe other (as per P0848R3), we need to check satisfaction which we can't\ndo on templates.  So this patch makes add_method skip the eligibility\ntest on member function templates and just lets them coexist.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/95181\n\t* class.c (add_method): Let special member function templates\n\tcoexist if they are not equivalently constrained, or in a class\n\ttemplate.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/95181\n\t* g++.dg/concepts/pr95181.C: New test.\n\t* g++.dg/concepts/pr95181-2.C: New test.\n\nCo-authored-by: Jason Merrill <jason@redhat.com>", "tree": {"sha": "dc384665b2d840345b339c600b84a27994d98fc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc384665b2d840345b339c600b84a27994d98fc0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c75ebe76ae12ac4020f20a24f34606a594a40d15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c75ebe76ae12ac4020f20a24f34606a594a40d15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c75ebe76ae12ac4020f20a24f34606a594a40d15", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c75ebe76ae12ac4020f20a24f34606a594a40d15/comments", "author": null, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2fb595f8348e164d2f06536ba98322616eeaeeb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fb595f8348e164d2f06536ba98322616eeaeeb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fb595f8348e164d2f06536ba98322616eeaeeb6"}], "stats": {"total": 32, "additions": 28, "deletions": 4}, "files": [{"sha": "c818826a1081b7a93298705a775ca0c35efcd609", "filename": "gcc/cp/class.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c75ebe76ae12ac4020f20a24f34606a594a40d15/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c75ebe76ae12ac4020f20a24f34606a594a40d15/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=c75ebe76ae12ac4020f20a24f34606a594a40d15", "patch": "@@ -1081,12 +1081,19 @@ add_method (tree type, tree method, bool via_using)\n \t{\n           if (!equivalently_constrained (fn, method))\n \t    {\n+\t      if (processing_template_decl)\n+\t\t/* We can't check satisfaction in dependent context, wait until\n+\t\t   the class is instantiated.  */\n+\t\tcontinue;\n+\n \t      special_function_kind sfk = special_memfn_p (method);\n \n-\t      if (sfk == sfk_none || DECL_INHERITED_CTOR (fn))\n-\t\t/* Non-special member functions coexist if they are not\n-\t\t   equivalently constrained.  A member function is not hidden\n-\t\t   by an inherited constructor.  */\n+\t      if (sfk == sfk_none\n+\t\t  || DECL_INHERITED_CTOR (fn)\n+\t\t  || TREE_CODE (fn) == TEMPLATE_DECL)\n+\t\t/* Member function templates and non-special member functions\n+\t\t   coexist if they are not equivalently constrained.  A member\n+\t\t   function is not hidden by an inherited constructor.  */\n \t\tcontinue;\n \n \t      /* P0848: For special member functions, deleted, unsatisfied, or"}, {"sha": "6d67350e58f547093ecae8139453892c36e4eed8", "filename": "gcc/testsuite/g++.dg/concepts/pr95181-2.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c75ebe76ae12ac4020f20a24f34606a594a40d15/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr95181-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c75ebe76ae12ac4020f20a24f34606a594a40d15/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr95181-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr95181-2.C?ref=c75ebe76ae12ac4020f20a24f34606a594a40d15", "patch": "@@ -0,0 +1,8 @@\n+// { dg-do compile { target concepts } }\n+\n+template<bool B> struct g {\n+  g() requires B && false;\n+  g() requires B;\n+};\n+\n+g<true> b; // error"}, {"sha": "0185c86b4382907ab8256d3c4ba4be78ac2c2217", "filename": "gcc/testsuite/g++.dg/concepts/pr95181.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c75ebe76ae12ac4020f20a24f34606a594a40d15/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr95181.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c75ebe76ae12ac4020f20a24f34606a594a40d15/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr95181.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr95181.C?ref=c75ebe76ae12ac4020f20a24f34606a594a40d15", "patch": "@@ -0,0 +1,9 @@\n+// PR c++/95181\n+// { dg-do compile { target concepts } }\n+\n+template <typename> struct f {\n+  template <typename T=int> f();\n+  template <typename T=int> requires false f();\n+};\n+\n+f<int> a;"}]}