{"sha": "b724567ea68234e4fa748b4373824cf30b3f6845", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjcyNDU2N2VhNjgyMzRlNGZhNzQ4YjQzNzM4MjRjZjMwYjNmNjg0NQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2011-12-04T18:27:19Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2011-12-04T18:27:19Z"}, "message": "gcov-io.h (struct gcov_info): Replace trailing array with pointer to array.\n\n\t* gcov-io.h (struct gcov_info): Replace trailing array with\n\tpointer to array.\n\t* profile.c (branch_prob): Only call renamed\n\tcoverage_begin_function once.\n\t* coverage.h (coverage_begin_output): Rename to ...\n\t(coverage_begin_function): ... here.\n\t* coverage.c (struct function_list): Rename to ...\n\t(struct coverage_data): ... this.  Update all uses.\n\t(gcov_info_var, gcov_fn_info_type, gcov_fn_info_ptr_type): New\n\tglobals.\n\t(bbg_file_opened, bbg_function_announced): Remove.\n\t(get_coverage_counts): Adjust message.\n\t(coverage_begin_ouput): Rename to ...\n\t(coverage_begin_function): ... here.  Move file opening to\n\tcoverage_init.  Adjust for being called only once.\n\t(coverage_end_function): Remove bbg file and inhibit further\n\toutput here on error.\n\t(build_info_type): Adjust for change to pointer to array.\n\t(build_info): Receive array of function pointers and adjust.\n\t(create_coverage): Break into ...\n\t(coverage_obj_init, coverage_obj_fn, coverage_obj_finish):\n\t... these, and adjust.\n\t(coverage_init): Open the notes file here.  Tidy.\n\t(coverage_finish): Call coverage_obj_init etc.\n\nFrom-SVN: r181994", "tree": {"sha": "48d2612cbd2d4812c63435c60a1a9865090aa906", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48d2612cbd2d4812c63435c60a1a9865090aa906"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b724567ea68234e4fa748b4373824cf30b3f6845", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b724567ea68234e4fa748b4373824cf30b3f6845", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b724567ea68234e4fa748b4373824cf30b3f6845", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b724567ea68234e4fa748b4373824cf30b3f6845/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "13901e4b28c4618bbb8cdde78896dee6a4940fa1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13901e4b28c4618bbb8cdde78896dee6a4940fa1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13901e4b28c4618bbb8cdde78896dee6a4940fa1"}], "stats": {"total": 459, "additions": 256, "deletions": 203}, "files": [{"sha": "10718fc6888387e961d55a5040a4cb760967bffa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b724567ea68234e4fa748b4373824cf30b3f6845/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b724567ea68234e4fa748b4373824cf30b3f6845/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b724567ea68234e4fa748b4373824cf30b3f6845", "patch": "@@ -1,3 +1,30 @@\n+2011-12-04  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* gcov-io.h (struct gcov_info): Replace trailing array with\n+\tpointer to array.\n+\t* profile.c (branch_prob): Only call renamed\n+\tcoverage_begin_function once.\n+\t* coverage.h (coverage_begin_output): Rename to ...\n+\t(coverage_begin_function): ... here.\n+\t* coverage.c (struct function_list): Rename to ...\n+\t(struct coverage_data): ... this.  Update all uses.\n+\t(gcov_info_var, gcov_fn_info_type, gcov_fn_info_ptr_type): New\n+\tglobals.\n+\t(bbg_file_opened, bbg_function_announced): Remove.\n+\t(get_coverage_counts): Adjust message.\n+\t(coverage_begin_ouput): Rename to ...\n+\t(coverage_begin_function): ... here.  Move file opening to\n+\tcoverage_init.  Adjust for being called only once.\n+\t(coverage_end_function): Remove bbg file and inhibit further\n+\toutput here on error.\n+\t(build_info_type): Adjust for change to pointer to array.\n+\t(build_info): Receive array of function pointers and adjust.\n+\t(create_coverage): Break into ...\n+\t(coverage_obj_init, coverage_obj_fn, coverage_obj_finish):\n+\t... these, and adjust.\n+\t(coverage_init): Open the notes file here.  Tidy.\n+\t(coverage_finish): Call coverage_obj_init etc.\n+\n 2011-12-04  Ira Rosen  <ira.rosen@linaro.org>\n \n \tPR middle-end/51285"}, {"sha": "656db92beb1aebf383d5eac5d49b5fc8519eff8b", "filename": "gcc/coverage.c", "status": "modified", "additions": 209, "deletions": 175, "changes": 384, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b724567ea68234e4fa748b4373824cf30b3f6845/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b724567ea68234e4fa748b4373824cf30b3f6845/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=b724567ea68234e4fa748b4373824cf30b3f6845", "patch": "@@ -54,9 +54,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gcov-io.h\"\n #include \"gcov-io.c\"\n \n-struct GTY((chain_next (\"%h.next\"))) function_list\n+struct GTY((chain_next (\"%h.next\"))) coverage_data\n {\n-  struct function_list *next;\t /* next function */\n+  struct coverage_data *next;\t /* next function */\n   unsigned ident;\t\t /* function ident */\n   unsigned lineno_checksum;\t /* function lineno checksum */\n   unsigned cfg_checksum;\t /* function cfg checksum */\n@@ -78,8 +78,8 @@ typedef struct counts_entry\n   struct gcov_ctr_summary summary;\n } counts_entry_t;\n \n-static GTY(()) struct function_list *functions_head = 0;\n-static struct function_list **functions_tail = &functions_head;\n+static GTY(()) struct coverage_data *functions_head = 0;\n+static struct coverage_data **functions_tail = &functions_head;\n static unsigned no_coverage = 0;\n \n /* Cumulative counter information for whole program.  */\n@@ -91,10 +91,14 @@ static GTY(()) tree fn_v_ctrs[GCOV_COUNTERS];   /* counter variables.  */\n static unsigned fn_n_ctrs[GCOV_COUNTERS]; /* Counters allocated.  */\n static unsigned fn_b_ctrs[GCOV_COUNTERS]; /* Allocation base.  */\n \n-/* Name of the output file for coverage output file.  */\n+/* Coverage info VAR_DECL and function info type nodes.  */\n+static GTY(()) tree gcov_info_var;\n+static GTY(()) tree gcov_fn_info_type;\n+static GTY(()) tree gcov_fn_info_ptr_type;\n+\n+/* Name of the output file for coverage output file.  If this is NULL\n+   we're not writing to the notes file.  */\n static char *bbg_file_name;\n-static unsigned bbg_file_opened;\n-static int bbg_function_announced;\n \n /* Name of the count data file.  */\n static char *da_file_name;\n@@ -113,10 +117,13 @@ static void htab_counts_entry_del (void *);\n static void read_counts_file (void);\n static tree build_var (tree, tree, int);\n static void build_fn_info_type (tree, unsigned, tree);\n-static tree build_fn_info (const struct function_list *, tree, tree);\n-static void build_info_type (tree, unsigned, tree);\n-static tree build_info (tree, tree, tree, unsigned);\n-static void create_coverage (void);\n+static void build_info_type (tree, tree);\n+static tree build_fn_info (const struct coverage_data *, tree, tree);\n+static tree build_info (tree, tree);\n+static bool coverage_obj_init (void);\n+static VEC(constructor_elt,gc) *coverage_obj_fn\n+(VEC(constructor_elt,gc) *, tree, struct coverage_data const *);\n+static void coverage_obj_finish (VEC(constructor_elt,gc) *);\n \f\n /* Return the type node for gcov_type.  */\n \n@@ -374,7 +381,7 @@ get_coverage_counts (unsigned counter, unsigned expected,\n     }\n   else if (entry->lineno_checksum != lineno_checksum)\n     {\n-      warning (0, \"source location for function %qE have changed,\"\n+      warning (0, \"source locations for function %qE have changed,\"\n \t       \" the profile data may be out of date\",\n \t       DECL_ASSEMBLER_NAME (current_function_decl));\n     }\n@@ -553,51 +560,32 @@ coverage_compute_cfg_checksum (void)\n }\n \f\n /* Begin output to the graph file for the current function.\n-   Opens the output file, if not already done. Writes the\n-   function header, if not already done. Returns nonzero if data\n-   should be output.  */\n+   Writes the function header. Returns nonzero if data should be output.  */\n \n int\n-coverage_begin_output (unsigned lineno_checksum, unsigned cfg_checksum)\n+coverage_begin_function (unsigned lineno_checksum, unsigned cfg_checksum)\n {\n+  expanded_location xloc;\n+  unsigned long offset;\n+\n   /* We don't need to output .gcno file unless we're under -ftest-coverage\n      (e.g. -fprofile-arcs/generate/use don't need .gcno to work). */\n-  if (no_coverage || !flag_test_coverage || flag_compare_debug)\n+  if (no_coverage || !bbg_file_name)\n     return 0;\n \n-  if (!bbg_function_announced)\n-    {\n-      expanded_location xloc\n-\t= expand_location (DECL_SOURCE_LOCATION (current_function_decl));\n-      unsigned long offset;\n-\n-      if (!bbg_file_opened)\n-\t{\n-\t  if (!gcov_open (bbg_file_name, -1))\n-\t    error (\"cannot open %s\", bbg_file_name);\n-\t  else\n-\t    {\n-\t      gcov_write_unsigned (GCOV_NOTE_MAGIC);\n-\t      gcov_write_unsigned (GCOV_VERSION);\n-\t      gcov_write_unsigned (local_tick);\n-\t    }\n-\t  bbg_file_opened = 1;\n-\t}\n-\n+  xloc = expand_location (DECL_SOURCE_LOCATION (current_function_decl));\n \n-      /* Announce function */\n-      offset = gcov_write_tag (GCOV_TAG_FUNCTION);\n-      gcov_write_unsigned (current_function_funcdef_no + 1);\n-      gcov_write_unsigned (lineno_checksum);\n-      gcov_write_unsigned (cfg_checksum);\n-      gcov_write_string (IDENTIFIER_POINTER\n-                         (DECL_ASSEMBLER_NAME (current_function_decl)));\n-      gcov_write_string (xloc.file);\n-      gcov_write_unsigned (xloc.line);\n-      gcov_write_length (offset);\n+  /* Announce function */\n+  offset = gcov_write_tag (GCOV_TAG_FUNCTION);\n+  gcov_write_unsigned (current_function_funcdef_no + 1);\n+  gcov_write_unsigned (lineno_checksum);\n+  gcov_write_unsigned (cfg_checksum);\n+  gcov_write_string (IDENTIFIER_POINTER\n+\t\t     (DECL_ASSEMBLER_NAME (current_function_decl)));\n+  gcov_write_string (xloc.file);\n+  gcov_write_unsigned (xloc.line);\n+  gcov_write_length (offset);\n \n-      bbg_function_announced = 1;\n-    }\n   return !gcov_is_error ();\n }\n \n@@ -609,23 +597,22 @@ coverage_end_function (unsigned lineno_checksum, unsigned cfg_checksum)\n {\n   unsigned i;\n \n-  if (bbg_file_opened > 1 && gcov_is_error ())\n+  if (bbg_file_name && gcov_is_error ())\n     {\n       warning (0, \"error writing %qs\", bbg_file_name);\n-      bbg_file_opened = -1;\n+      unlink (bbg_file_name);\n+      bbg_file_name = NULL;\n     }\n \n-  if (fn_ctr_mask)\n+  /* If the function is extern (i.e. extern inline), then we won't be\n+     outputting it, so don't chain it onto the function list.  */\n+  if (fn_ctr_mask && !DECL_EXTERNAL (current_function_decl))\n     {\n-      struct function_list *item;\n-\n-      item = ggc_alloc_function_list ();\n+      struct coverage_data *item = ggc_alloc_coverage_data ();\n \n-      item->next = 0;\n       item->ident = current_function_funcdef_no + 1;\n       item->lineno_checksum = lineno_checksum;\n       item->cfg_checksum = cfg_checksum;\n-      item->fn_decl = current_function_decl;\n       for (i = 0; i != GCOV_COUNTERS; i++)\n \t{\n \t  tree var = fn_v_ctrs[i];\n@@ -640,20 +627,23 @@ coverage_end_function (unsigned lineno_checksum, unsigned cfg_checksum)\n \t      DECL_SIZE_UNIT (var) = TYPE_SIZE_UNIT (array_type);\n \t      varpool_finalize_decl (var);\n \t    }\n+\t}\n+      item->fn_decl = current_function_decl;\n+      item->next = 0;\n+      *functions_tail = item;\n+      functions_tail = &item->next;\n+    }\n+  \n+  if (fn_ctr_mask)\n+    {\n+      for (i = 0; i != GCOV_COUNTERS; i++)\n+\t{\n \t  fn_b_ctrs[i] = fn_n_ctrs[i] = 0;\n \t  fn_v_ctrs[i] = NULL_TREE;\n \t}\n       prg_ctr_mask |= fn_ctr_mask;\n       fn_ctr_mask = 0;\n-      /* If the function is extern (i.e. extern inline), then we won't\n-\t be outputting it, so don't chain it onto the function list.  */\n-      if (!DECL_EXTERNAL (item->fn_decl))\n-\t{\n-\t  *functions_tail = item;\n-\t  functions_tail = &item->next;\n-\t}\n     }\n-  bbg_function_announced = 0;\n }\n \n /* Build a coverage variable of TYPE for function FN_DECL.  If COUNTER\n@@ -737,12 +727,12 @@ build_fn_info_type (tree type, unsigned counters, tree gcov_info_type)\n   finish_builtin_struct (type, \"__gcov_fn_info\", fields, NULL_TREE);\n }\n \n-/* Creates a CONSTRUCTOR for a gcov_fn_info. FUNCTION is\n-   the function being processed and TYPE is the gcov_fn_info\n-   RECORD_TYPE.  KEY is the object file key. */\n+/* Returns a CONSTRUCTOR for a gcov_fn_info.  DATA is\n+   the coverage data for the function and TYPE is the gcov_fn_info\n+   RECORD_TYPE.  KEY is the object file key.  */\n \n static tree\n-build_fn_info (const struct function_list *function, tree type, tree key)\n+build_fn_info (const struct coverage_data *data, tree type, tree key)\n {\n   tree fields = TYPE_FIELDS (type);\n   tree ctr_type;\n@@ -758,19 +748,19 @@ build_fn_info (const struct function_list *function, tree type, tree key)\n   /* ident */\n   CONSTRUCTOR_APPEND_ELT (v1, fields,\n \t\t\t  build_int_cstu (get_gcov_unsigned_t (),\n-\t\t\t\t\t  function->ident));\n+\t\t\t\t\t  data->ident));\n   fields = DECL_CHAIN (fields);\n \n   /* lineno_checksum */\n   CONSTRUCTOR_APPEND_ELT (v1, fields,\n \t\t\t  build_int_cstu (get_gcov_unsigned_t (),\n-\t\t\t\t\t  function->lineno_checksum));\n+\t\t\t\t\t  data->lineno_checksum));\n   fields = DECL_CHAIN (fields);\n \n   /* cfg_checksum */\n   CONSTRUCTOR_APPEND_ELT (v1, fields,\n \t\t\t  build_int_cstu (get_gcov_unsigned_t (),\n-\t\t\t\t\t  function->cfg_checksum));\n+\t\t\t\t\t  data->cfg_checksum));\n   fields = DECL_CHAIN (fields);\n \n   /* counters */\n@@ -779,7 +769,7 @@ build_fn_info (const struct function_list *function, tree type, tree key)\n     if (prg_ctr_mask & (1 << ix))\n       {\n \tVEC(constructor_elt,gc) *ctr = NULL;\n-\ttree var = function->ctr_vars[ix];\n+\ttree var = data->ctr_vars[ix];\n \tunsigned count = 0;\n \n \tif (var)\n@@ -804,17 +794,15 @@ build_fn_info (const struct function_list *function, tree type, tree key)\n   return build_constructor (type, v1);\n }\n \n-/* Creaste gcov_info_struct.  N_FUNCS is the number of functions in\n-   the trailing array.  */\n+/* Create gcov_info struct.  TYPE is the incomplete RECORD_TYPE to be\n+   completed, and FN_INFO_PTR_TYPE is a pointer to the function info type.  */\n \n static void\n-build_info_type (tree type, unsigned n_funcs, tree fn_info_type)\n+build_info_type (tree type, tree fn_info_ptr_type)\n {\n   tree field, fields = NULL_TREE;\n-  tree merge_fn_type, fn_info_array;\n+  tree merge_fn_type;\n \n-  gcc_assert (n_funcs);\n-  \n   /* Version ident */\n   field = build_decl (BUILTINS_LOCATION, FIELD_DECL, NULL_TREE,\n \t\t      get_gcov_unsigned_t ());\n@@ -860,33 +848,31 @@ build_info_type (tree type, unsigned n_funcs, tree fn_info_type)\n   DECL_CHAIN (field) = fields;\n   fields = field;\n   \n-  /* function_info pointer array */\n-  fn_info_type = build_pointer_type\n-    (build_qualified_type (fn_info_type, TYPE_QUAL_CONST));\n-  fn_info_array = build_index_type (size_int (n_funcs));\n-  fn_info_array = build_array_type (fn_info_type, fn_info_array);\n+  /* function_info pointer pointer */\n+  fn_info_ptr_type = build_pointer_type\n+    (build_qualified_type (fn_info_ptr_type, TYPE_QUAL_CONST));\n   field = build_decl (BUILTINS_LOCATION, FIELD_DECL, NULL_TREE,\n-\t\t      fn_info_array);\n+\t\t      fn_info_ptr_type);\n   DECL_CHAIN (field) = fields;\n   fields = field;\n \n   finish_builtin_struct (type, \"__gcov_info\", fields, NULL_TREE);\n }\n \n-/* Creates the gcov_info initializer. Returns a CONSTRUCTOR.  */\n+/* Returns a CONSTRUCTOR for the gcov_info object.  INFO_TYPE is the\n+   gcov_info structure type, FN_ARY is the array of pointers to\n+   function info objects.  */\n \n static tree\n-build_info (tree info_type, tree fn_type, tree key_var, unsigned n_funcs)\n+build_info (tree info_type, tree fn_ary)\n {\n   tree info_fields = TYPE_FIELDS (info_type);\n-  tree merge_fn_type, fn_info_ptr_type;\n+  tree merge_fn_type, n_funcs;\n   unsigned ix;\n   tree filename_string;\n   int da_file_name_len;\n-  const struct function_list *fn;\n   VEC(constructor_elt,gc) *v1 = NULL;\n   VEC(constructor_elt,gc) *v2 = NULL;\n-  VEC(constructor_elt,gc) *v3 = NULL;\n \n   /* Version ident */\n   CONSTRUCTOR_APPEND_ELT (v1, info_fields,\n@@ -941,138 +927,181 @@ build_info (tree info_type, tree fn_type, tree key_var, unsigned n_funcs)\n   info_fields = DECL_CHAIN (info_fields);\n \n   /* n_functions */\n-  CONSTRUCTOR_APPEND_ELT (v1, info_fields,\n-\t\t\t  build_int_cstu (TREE_TYPE (info_fields), n_funcs));\n+  n_funcs = TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (fn_ary)));\n+  n_funcs = fold_build2 (PLUS_EXPR, TREE_TYPE (info_fields),\n+\t\t\t n_funcs, size_one_node);\n+  CONSTRUCTOR_APPEND_ELT (v1, info_fields, n_funcs);\n   info_fields = DECL_CHAIN (info_fields);\n-  \n-  /* Build the fn_info type and initializer.  */\n-  fn_info_ptr_type = TREE_TYPE (TREE_TYPE (info_fields));\n-  \n-  for (fn = functions_head; fn; fn = fn->next)\n-    {\n-      tree init = build_fn_info (fn, fn_type, key_var);\n-      tree var = build_var (fn->fn_decl, fn_type, -1);\n \n-      DECL_INITIAL (var) = init;\n-      varpool_finalize_decl (var);\n-      \n-      CONSTRUCTOR_APPEND_ELT (v3, NULL,\n-\t\t\t      build1 (ADDR_EXPR, fn_info_ptr_type, var));\n-    }\n+  /* functions */\n   CONSTRUCTOR_APPEND_ELT (v1, info_fields,\n-\t\t\t  build_constructor (TREE_TYPE (info_fields), v3));\n+\t\t\t  build1 (ADDR_EXPR, TREE_TYPE (info_fields), fn_ary));\n+  info_fields = DECL_CHAIN (info_fields);\n+\n+  gcc_assert (!info_fields);\n   return build_constructor (info_type, v1);\n }\n \n-/* Write out the structure which libgcov uses to locate all the\n-   counters.  The structures used here must match those defined in\n-   gcov-io.h.  Write out the constructor to call __gcov_init.  */\n+/* Create the gcov_info types and object.  Generate the constructor\n+   function to call __gcov_init.  Does not generate the initializer\n+   for the object.  Returns TRUE if coverage data is being emitted.  */\n \n-static void\n-create_coverage (void)\n+static bool\n+coverage_obj_init (void)\n {\n-  tree gcov_info, gcov_init, body, t;\n-  tree gcov_info_type, gcov_fn_type;\n-  unsigned n_counters = 0, n_functions  = 0;\n-  struct function_list *fn;\n-  struct function_list **fn_prev;\n+  tree gcov_info_type, ctor, stmt, init_fn;\n+  unsigned n_counters = 0;\n   unsigned ix;\n+  struct coverage_data *fn;\n+  struct coverage_data **fn_prev;\n   char name_buf[32];\n \n   no_coverage = 1; /* Disable any further coverage.  */\n \n   if (!prg_ctr_mask)\n-    return;\n+    return false;\n \n   if (cgraph_dump_file)\n     fprintf (cgraph_dump_file, \"Using data file %s\\n\", da_file_name);\n \n-  for (ix = 0; ix != GCOV_COUNTERS; ix++)\n-    if ((1u << ix) & prg_ctr_mask)\n-      n_counters++;\n+  /* Prune functions.  */\n   for (fn_prev = &functions_head; (fn = *fn_prev);)\n     if (DECL_STRUCT_FUNCTION (fn->fn_decl))\n-      {\n-\tn_functions++;\n-\tfn_prev = &fn->next;\n-      }\n+      fn_prev = &fn->next;\n     else\n       /* The function is not being emitted, remove from list.  */\n       *fn_prev = fn->next;\n+\n+  for (ix = 0; ix != GCOV_COUNTERS; ix++)\n+    if ((1u << ix) & prg_ctr_mask)\n+      n_counters++;\n   \n   /* Build the info and fn_info types.  These are mutually recursive.  */\n   gcov_info_type = lang_hooks.types.make_type (RECORD_TYPE);\n-  gcov_fn_type = lang_hooks.types.make_type (RECORD_TYPE);\n-  build_fn_info_type (gcov_fn_type, n_counters, gcov_info_type);\n-  build_info_type (gcov_info_type, n_functions, gcov_fn_type);\n+  gcov_fn_info_type = lang_hooks.types.make_type (RECORD_TYPE);\n+  gcov_fn_info_ptr_type = build_pointer_type\n+    (build_qualified_type (gcov_fn_info_type, TYPE_QUAL_CONST));\n+  build_fn_info_type (gcov_fn_info_type, n_counters, gcov_info_type);\n+  build_info_type (gcov_info_type, gcov_fn_info_ptr_type);\n   \n   /* Build the gcov info var, this is referred to in its own\n      initializer.  */\n-  gcov_info = build_decl (BUILTINS_LOCATION,\n-\t\t\t  VAR_DECL, NULL_TREE, gcov_info_type);\n-  TREE_STATIC (gcov_info) = 1;\n+  gcov_info_var = build_decl (BUILTINS_LOCATION,\n+\t\t\t      VAR_DECL, NULL_TREE, gcov_info_type);\n+  TREE_STATIC (gcov_info_var) = 1;\n   ASM_GENERATE_INTERNAL_LABEL (name_buf, \"LPBX\", 0);\n-  DECL_NAME (gcov_info) = get_identifier (name_buf);\n-  DECL_INITIAL (gcov_info) = build_info (gcov_info_type, gcov_fn_type,\n-\t\t\t\t\t gcov_info, n_functions);\n-\n-  /* Build structure.  */\n-  varpool_finalize_decl (gcov_info);\n+  DECL_NAME (gcov_info_var) = get_identifier (name_buf);\n \n   /* Build a decl for __gcov_init.  */\n-  t = build_pointer_type (TREE_TYPE (gcov_info));\n-  t = build_function_type_list (void_type_node, t, NULL);\n-  t = build_decl (BUILTINS_LOCATION,\n-\t\t  FUNCTION_DECL, get_identifier (\"__gcov_init\"), t);\n-  TREE_PUBLIC (t) = 1;\n-  DECL_EXTERNAL (t) = 1;\n-  DECL_ASSEMBLER_NAME (t);  /* Initialize assembler name so we can stream out. */\n-  gcov_init = t;\n+  init_fn = build_pointer_type (gcov_info_type);\n+  init_fn = build_function_type_list (void_type_node, init_fn, NULL);\n+  init_fn = build_decl (BUILTINS_LOCATION, FUNCTION_DECL,\n+\t\t\tget_identifier (\"__gcov_init\"), init_fn);\n+  TREE_PUBLIC (init_fn) = 1;\n+  DECL_EXTERNAL (init_fn) = 1;\n+  DECL_ASSEMBLER_NAME (init_fn);\n \n   /* Generate a call to __gcov_init(&gcov_info).  */\n-  body = NULL;\n-  t = build_fold_addr_expr (gcov_info);\n-  t = build_call_expr (gcov_init, 1, t);\n-  append_to_statement_list (t, &body);\n+  ctor = NULL;\n+  stmt = build_fold_addr_expr (gcov_info_var);\n+  stmt = build_call_expr (init_fn, 1, stmt);\n+  append_to_statement_list (stmt, &ctor);\n \n   /* Generate a constructor to run it.  */\n-  cgraph_build_static_cdtor ('I', body, DEFAULT_INIT_PRIORITY);\n+  cgraph_build_static_cdtor ('I', ctor, DEFAULT_INIT_PRIORITY);\n+\n+  return true;\n }\n-\f\n+\n+/* Generate the coverage function info for FN and DATA.  Append a\n+   pointer to that object to CTOR and return the appended CTOR.  */\n+\n+static VEC(constructor_elt,gc) *\n+coverage_obj_fn (VEC(constructor_elt,gc) *ctor, tree fn,\n+\t\t struct coverage_data const *data)\n+{\n+  tree init = build_fn_info (data, gcov_fn_info_type, gcov_info_var);\n+  tree var = build_var (fn, gcov_fn_info_type, -1);\n+  \n+  DECL_INITIAL (var) = init;\n+  varpool_finalize_decl (var);\n+      \n+  CONSTRUCTOR_APPEND_ELT (ctor, NULL,\n+\t\t\t  build1 (ADDR_EXPR, gcov_fn_info_ptr_type, var));\n+  return ctor;\n+}\n+\n+/* Finalize the coverage data.  Generates the array of pointers to\n+   function objects from CTOR.  Generate the gcov_info initializer.  */\n+\n+static void\n+coverage_obj_finish (VEC(constructor_elt,gc) *ctor)\n+{\n+  unsigned n_functions = VEC_length(constructor_elt, ctor);\n+  tree fn_info_ary_type = build_array_type\n+    (build_qualified_type (gcov_fn_info_ptr_type, TYPE_QUAL_CONST),\n+     build_index_type (size_int (n_functions - 1)));\n+  tree fn_info_ary = build_decl (BUILTINS_LOCATION, VAR_DECL, NULL_TREE,\n+\t\t\t\t fn_info_ary_type);\n+  char name_buf[32];\n+\n+  TREE_STATIC (fn_info_ary) = 1;\n+  ASM_GENERATE_INTERNAL_LABEL (name_buf, \"LPBX\", 1);\n+  DECL_NAME (fn_info_ary) = get_identifier (name_buf);\n+  DECL_INITIAL (fn_info_ary) = build_constructor (fn_info_ary_type, ctor);\n+  varpool_finalize_decl (fn_info_ary);\n+  \n+  DECL_INITIAL (gcov_info_var)\n+    = build_info (TREE_TYPE (gcov_info_var), fn_info_ary);\n+  varpool_finalize_decl (gcov_info_var);\n+}\n+\n /* Perform file-level initialization. Read in data file, generate name\n    of graph file.  */\n \n void\n coverage_init (const char *filename)\n {\n   int len = strlen (filename);\n-  /* + 1 for extra '/', in case prefix doesn't end with /.  */\n-  int prefix_len;\n+  int prefix_len = 0;\n \n-  if (profile_data_prefix == 0 && !IS_ABSOLUTE_PATH(&filename[0]))\n+  if (!profile_data_prefix && !IS_ABSOLUTE_PATH (filename))\n     profile_data_prefix = getpwd ();\n \n-  prefix_len = (profile_data_prefix) ? strlen (profile_data_prefix) + 1 : 0;\n+  if (profile_data_prefix)\n+    prefix_len = strlen (profile_data_prefix);\n \n   /* Name of da file.  */\n   da_file_name = XNEWVEC (char, len + strlen (GCOV_DATA_SUFFIX)\n-\t\t\t  + prefix_len + 1);\n+\t\t\t  + prefix_len + 2);\n \n   if (profile_data_prefix)\n     {\n-      strcpy (da_file_name, profile_data_prefix);\n-      da_file_name[prefix_len - 1] = '/';\n-      da_file_name[prefix_len] = 0;\n+      memcpy (da_file_name, profile_data_prefix, prefix_len);\n+      da_file_name[prefix_len++] = '/';\n     }\n-  else\n-    da_file_name[0] = 0;\n-  strcat (da_file_name, filename);\n-  strcat (da_file_name, GCOV_DATA_SUFFIX);\n+  memcpy (da_file_name + prefix_len, filename, len);\n+  strcpy (da_file_name + prefix_len + len, GCOV_DATA_SUFFIX);\n \n   /* Name of bbg file.  */\n-  bbg_file_name = XNEWVEC (char, len + strlen (GCOV_NOTE_SUFFIX) + 1);\n-  strcpy (bbg_file_name, filename);\n-  strcat (bbg_file_name, GCOV_NOTE_SUFFIX);\n+  if (flag_test_coverage && !flag_compare_debug)\n+    {\n+      bbg_file_name = XNEWVEC (char, len + strlen (GCOV_NOTE_SUFFIX) + 1);\n+      memcpy (bbg_file_name, filename, len);\n+      strcpy (bbg_file_name + len, GCOV_NOTE_SUFFIX);\n+\n+      if (!gcov_open (bbg_file_name, -1))\n+\t{\n+\t  error (\"cannot open %s\", bbg_file_name);\n+\t  bbg_file_name = NULL;\n+\t}\n+      else\n+\t{\n+\t  gcov_write_unsigned (GCOV_NOTE_MAGIC);\n+\t  gcov_write_unsigned (GCOV_VERSION);\n+\t  gcov_write_unsigned (local_tick);\n+\t}\n+    }\n \n   if (flag_branch_probabilities)\n     read_counts_file ();\n@@ -1084,17 +1113,22 @@ coverage_init (const char *filename)\n void\n coverage_finish (void)\n {\n-  create_coverage ();\n-  if (bbg_file_opened)\n+  if (bbg_file_name && gcov_close ())\n+    unlink (bbg_file_name);\n+  \n+  if (!local_tick)\n+    /* Only remove the da file, if we cannot stamp it.  If we can\n+       stamp it, libgcov will DTRT.  */\n+    unlink (da_file_name);\n+\n+  if (coverage_obj_init ())\n     {\n-      int error = gcov_close ();\n-\n-      if (error)\n-\tunlink (bbg_file_name);\n-      if (!local_tick)\n-\t/* Only remove the da file, if we cannot stamp it. If we can\n-\t   stamp it, libgcov will DTRT.  */\n-\tunlink (da_file_name);\n+      VEC(constructor_elt,gc) *fn_ctor = NULL;\n+      struct coverage_data *fn;\n+      \n+      for (fn = functions_head; fn; fn = fn->next)\n+\tfn_ctor = coverage_obj_fn (fn_ctor, fn->fn_decl, fn);\n+      coverage_obj_finish (fn_ctor);\n     }\n }\n "}, {"sha": "1f3662b7455628692d00192af2d8333455c36b3b", "filename": "gcc/coverage.h", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b724567ea68234e4fa748b4373824cf30b3f6845/gcc%2Fcoverage.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b724567ea68234e4fa748b4373824cf30b3f6845/gcc%2Fcoverage.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.h?ref=b724567ea68234e4fa748b4373824cf30b3f6845", "patch": "@@ -26,13 +26,12 @@ along with GCC; see the file COPYING3.  If not see\n extern void coverage_init (const char *);\n extern void coverage_finish (void);\n \n-/* Complete the coverage information for the current function. Once\n-   per function.  */\n-extern void coverage_end_function (unsigned, unsigned);\n-\n /* Start outputting coverage information for the current\n-   function. Repeatable per function.  */\n-extern int coverage_begin_output (unsigned, unsigned);\n+   function.  */\n+extern int coverage_begin_function (unsigned, unsigned);\n+\n+/* Complete the coverage information for the current function.  */\n+extern void coverage_end_function (unsigned, unsigned);\n \n /* Compute the control flow checksum for the current function.  */\n extern unsigned coverage_compute_cfg_checksum (void);"}, {"sha": "b80f70696207ead8ccb42050103088bdb0ed2ab7", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b724567ea68234e4fa748b4373824cf30b3f6845/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b724567ea68234e4fa748b4373824cf30b3f6845/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=b724567ea68234e4fa748b4373824cf30b3f6845", "patch": "@@ -448,8 +448,8 @@ struct gcov_info\n \t\t\t\t\t  unused) */\n   \n   unsigned n_functions;\t\t/* number of functions */\n-  const struct gcov_fn_info *functions[0]; /* pointers to function\n-\t\t\t\t\t      information  */\n+  const struct gcov_fn_info *const *functions; /* pointer to pointers\n+\t\t\t\t\t          to function information  */\n };\n \n /* Register a new object file module.  */"}, {"sha": "201f6cd3c324a04546710865059de2e747bf2113", "filename": "gcc/profile.c", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b724567ea68234e4fa748b4373824cf30b3f6845/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b724567ea68234e4fa748b4373824cf30b3f6845/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=b724567ea68234e4fa748b4373824cf30b3f6845", "patch": "@@ -1110,30 +1110,25 @@ branch_prob (void)\n   lineno_checksum = coverage_compute_lineno_checksum ();\n \n   /* Write the data from which gcov can reconstruct the basic block\n-     graph.  */\n+     graph and function line numbers  */\n \n-  /* Basic block flags */\n-  if (coverage_begin_output (lineno_checksum, cfg_checksum))\n+  if (coverage_begin_function (lineno_checksum, cfg_checksum))\n     {\n       gcov_position_t offset;\n \n+      /* Basic block flags */\n       offset = gcov_write_tag (GCOV_TAG_BLOCKS);\n       for (i = 0; i != (unsigned) (n_basic_blocks); i++)\n \tgcov_write_unsigned (0);\n       gcov_write_length (offset);\n-    }\n-\n-   /* Keep all basic block indexes nonnegative in the gcov output.\n-      Index 0 is used for entry block, last index is for exit block.\n-      */\n-  ENTRY_BLOCK_PTR->index = 1;\n-  EXIT_BLOCK_PTR->index = last_basic_block;\n \n-  /* Arcs */\n-  if (coverage_begin_output (lineno_checksum, cfg_checksum))\n-    {\n-      gcov_position_t offset;\n+      /* Keep all basic block indexes nonnegative in the gcov output.\n+\t Index 0 is used for entry block, last index is for exit\n+\t block.    */\n+      ENTRY_BLOCK_PTR->index = 1;\n+      EXIT_BLOCK_PTR->index = last_basic_block;\n \n+      /* Arcs */\n       FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n \t{\n \t  edge e;\n@@ -1168,11 +1163,11 @@ branch_prob (void)\n \n \t  gcov_write_length (offset);\n \t}\n-    }\n \n-  /* Line numbers.  */\n-  if (coverage_begin_output (lineno_checksum, cfg_checksum))\n-    {\n+      ENTRY_BLOCK_PTR->index = ENTRY_BLOCK;\n+      EXIT_BLOCK_PTR->index = EXIT_BLOCK;\n+\n+      /* Line numbers.  */\n       /* Initialize the output.  */\n       output_location (NULL, 0, NULL, NULL);\n \n@@ -1217,8 +1212,6 @@ branch_prob (void)\n \t}\n     }\n \n-  ENTRY_BLOCK_PTR->index = ENTRY_BLOCK;\n-  EXIT_BLOCK_PTR->index = EXIT_BLOCK;\n #undef BB_TO_GCOV_INDEX\n \n   if (flag_profile_values)"}]}