{"sha": "97236777ce70b03149dfbf501969bf72840eda9d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTcyMzY3NzdjZTcwYjAzMTQ5ZGZiZjUwMTk2OWJmNzI4NDBlZGE5ZA==", "commit": {"author": {"name": "Greg McGary", "email": "greg@mcgary.org", "date": "2005-01-02T22:20:02Z"}, "committer": {"name": "Greg McGary", "email": "gkm@gcc.gnu.org", "date": "2005-01-02T22:20:02Z"}, "message": "tree-mudflap.c (mf_varname_tree): decl_printable_name handles anonymous decls.\n\n\t* tree-mudflap.c (mf_varname_tree): decl_printable_name handles\n\tanonymous decls.\n\t(mf_xform_derefs_1) [RESULT_DECL, STRING_CST]: Handle as innermost\n\tobject.  [ptr_type]: Remove unused variable.\n\tRemember nearest addressable array-element or record-component\n\twhen checking bitfield components.  Tolerate empty BIND_EXPR.\n\nFrom-SVN: r92814", "tree": {"sha": "ad5717f75c024ddb9fb555e2a4b1e18d7739a6b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad5717f75c024ddb9fb555e2a4b1e18d7739a6b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/97236777ce70b03149dfbf501969bf72840eda9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97236777ce70b03149dfbf501969bf72840eda9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97236777ce70b03149dfbf501969bf72840eda9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97236777ce70b03149dfbf501969bf72840eda9d/comments", "author": null, "committer": null, "parents": [{"sha": "9469f0aa72c8a3a3c0346981a94ec07faff6d692", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9469f0aa72c8a3a3c0346981a94ec07faff6d692", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9469f0aa72c8a3a3c0346981a94ec07faff6d692"}], "stats": {"total": 94, "additions": 55, "deletions": 39}, "files": [{"sha": "3d3408ca380f7aac0bd699671eec9c083bc7b70b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97236777ce70b03149dfbf501969bf72840eda9d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97236777ce70b03149dfbf501969bf72840eda9d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=97236777ce70b03149dfbf501969bf72840eda9d", "patch": "@@ -1,3 +1,12 @@\n+2005-01-02  Greg McGary  <greg@mcgary.org>\n+\n+\t* tree-mudflap.c (mf_varname_tree): decl_printable_name handles\n+\tanonymous decls.\n+\t(mf_xform_derefs_1) [RESULT_DECL, STRING_CST]: Handle as innermost\n+\tobject.  [ptr_type]: Remove unused variable.\n+\tRemember nearest addressable array-element or record-component\n+\twhen checking bitfield components.  Tolerate empty BIND_EXPR.\n+\n 2005-01-01  Richard Henderson  <rth@redhat.com>\n \n \t* tree-vectorizer.c (vect_analyze_offset_expr): Strip conversions"}, {"sha": "9672c20daf01d7418fd1eb8a622b55ab1c2bb786", "filename": "gcc/tree-mudflap.c", "status": "modified", "additions": 46, "deletions": 39, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97236777ce70b03149dfbf501969bf72840eda9d/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97236777ce70b03149dfbf501969bf72840eda9d/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=97236777ce70b03149dfbf501969bf72840eda9d", "patch": "@@ -161,23 +161,21 @@ mf_varname_tree (tree decl)\n \n   /* Add <variable-declaration>, possibly demangled.  */\n   {\n-    const char *declname = NULL;\n+    const char *declname = \"<unnamed variable>\";\n \n-    if (strcmp (\"GNU C++\", lang_hooks.name) == 0 &&\n-        DECL_NAME (decl) != NULL)\n+    if (DECL_NAME (decl) != NULL)\n       {\n-        /* The gcc/cp decl_printable_name hook doesn't do as good a job as\n-           the libiberty demangler.  */\n-        declname = cplus_demangle (IDENTIFIER_POINTER (DECL_NAME (decl)),\n-                                   DMGL_AUTO | DMGL_VERBOSE);\n+\tif (strcmp (\"GNU C++\", lang_hooks.name) == 0)\n+\t  {\n+\t    /* The gcc/cp decl_printable_name hook doesn't do as good a job as\n+\t       the libiberty demangler.  */\n+\t    declname = cplus_demangle (IDENTIFIER_POINTER (DECL_NAME (decl)),\n+\t\t\t\t       DMGL_AUTO | DMGL_VERBOSE);\n+\t  }\n+\tif (declname == NULL)\n+\t  declname = lang_hooks.decl_printable_name (decl, 3);\n       }\n \n-    if (declname == NULL)\n-      declname = lang_hooks.decl_printable_name (decl, 3);\n-\n-    if (declname == NULL)\n-      declname = \"<unnamed variable>\";\n-\n     pp_string (buf, declname);\n   }\n \n@@ -733,7 +731,7 @@ static void\n mf_xform_derefs_1 (block_stmt_iterator *iter, tree *tp,\n                    location_t *locus, tree dirflag)\n {\n-  tree type, ptr_type, base, limit, addr, size, t;\n+  tree type, base, limit, addr, size, t;\n \n   /* Don't instrument read operations.  */\n   if (dirflag == integer_zero_node && flag_mudflap_ignore_reads)\n@@ -762,13 +760,23 @@ mf_xform_derefs_1 (block_stmt_iterator *iter, tree *tp,\n            recurse all the way down the nesting structure to figure it\n            out: looking just at the outer node is not enough.  */          \n         tree var;\n-        int component_ref_only = TREE_CODE (t) == COMPONENT_REF;\n+        int component_ref_only = (TREE_CODE (t) == COMPONENT_REF);\n+\t/* If we have a bitfield component reference, we must note the\n+\t   innermost addressable object in ELT, from which we will\n+\t   construct the byte-addressable bounds of the bitfield.  */\n+\ttree elt = NULL_TREE;\n+\tint bitfield_ref_p = (TREE_CODE (t) == COMPONENT_REF\n+\t\t\t      && DECL_BIT_FIELD_TYPE (TREE_OPERAND (t, 1)));\n \n         /* Iterate to the top of the ARRAY_REF/COMPONENT_REF\n            containment hierarchy to find the outermost VAR_DECL.  */\n         var = TREE_OPERAND (t, 0);\n         while (1)\n           {\n+\t    if (bitfield_ref_p && elt == NULL_TREE\n+\t\t&& (TREE_CODE (var) == ARRAY_REF || TREE_CODE (var) == COMPONENT_REF))\n+\t      elt = var;\n+\t\n             if (TREE_CODE (var) == ARRAY_REF)\n               {\n                 component_ref_only = 0;\n@@ -778,21 +786,26 @@ mf_xform_derefs_1 (block_stmt_iterator *iter, tree *tp,\n               var = TREE_OPERAND (var, 0);\n             else if (INDIRECT_REF_P (var))\n               {\n-                component_ref_only = 0;\n+\t\tbase = TREE_OPERAND (var, 0);\n                 break;\n               }\n             else \n               {\n                 gcc_assert (TREE_CODE (var) == VAR_DECL \n-                            || TREE_CODE (var) == PARM_DECL);\n+                            || TREE_CODE (var) == PARM_DECL\n+                            || TREE_CODE (var) == RESULT_DECL\n+                            || TREE_CODE (var) == STRING_CST);\n                 /* Don't instrument this access if the underlying\n                    variable is not \"eligible\".  This test matches\n                    those arrays that have only known-valid indexes,\n                    and thus are not labeled TREE_ADDRESSABLE.  */\n-                if (! mf_decl_eligible_p (var))\n+                if (! mf_decl_eligible_p (var) || component_ref_only)\n                   return;\n                 else\n-                  break;\n+\t\t  {\n+\t\t    base = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (var)), var);\n+\t\t    break;\n+\t\t  }\n               }\n           }\n \n@@ -802,34 +815,26 @@ mf_xform_derefs_1 (block_stmt_iterator *iter, tree *tp,\n            Note that it's possible for such a struct variable to match\n            the eligible_p test because someone else might take its\n            address sometime.  */\n-        if (component_ref_only)\n-          return;\n-\n-        ptr_type = build_pointer_type (type);\n \n         /* We need special processing for bitfield components, because\n            their addresses cannot be taken.  */\n-        if (TREE_CODE (t) == COMPONENT_REF\n-            && DECL_BIT_FIELD_TYPE (TREE_OPERAND (t, 1)))\n+        if (bitfield_ref_p)\n           {\n             tree field = TREE_OPERAND (t, 1);\n \n             if (TREE_CODE (DECL_SIZE_UNIT (field)) == INTEGER_CST)\n               size = DECL_SIZE_UNIT (field);\n             \n-            addr = TREE_OPERAND (TREE_OPERAND (t, 0), 0);\n-            addr = fold_convert (ptr_type_node, addr);\n+\t    if (elt)\n+\t      elt = build1 (ADDR_EXPR, build_pointer_type TREE_TYPE (elt), elt);\n+            addr = fold_convert (ptr_type_node, elt ? elt : base);\n             addr = fold (build (PLUS_EXPR, ptr_type_node,\n                                 addr, fold_convert (ptr_type_node,\n                                                     byte_position (field))));           \n           }\n         else\n           addr = build1 (ADDR_EXPR, build_pointer_type (type), t);\n \n-        if (INDIRECT_REF_P (var))\n-          base = TREE_OPERAND (var, 0);\n-        else\n-          base = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (var)), var);\n         limit = fold (build (MINUS_EXPR, mf_uintptr_type,\n                              fold (build2 (PLUS_EXPR, mf_uintptr_type, \n                                            convert (mf_uintptr_type, addr), \n@@ -840,7 +845,6 @@ mf_xform_derefs_1 (block_stmt_iterator *iter, tree *tp,\n \n     case INDIRECT_REF:\n       addr = TREE_OPERAND (t, 0);\n-      ptr_type = TREE_TYPE (addr);\n       base = addr;\n       limit = fold (build (MINUS_EXPR, ptr_type_node,\n                            fold (build (PLUS_EXPR, ptr_type_node, base, size)),\n@@ -1039,12 +1043,15 @@ mx_register_decls (tree decl, tree *stmt_list)\n \n           /* Add the __mf_register call at the current appending point.  */\n           if (tsi_end_p (initially_stmts))\n-            internal_error (\"mudflap ran off end of BIND_EXPR body\");\n-          tsi_link_before (&initially_stmts, register_fncall, TSI_SAME_STMT);\n-\n-          /* Accumulate the FINALLY piece.  */\n-          append_to_statement_list (unregister_fncall, &finally_stmts);\n-\n+\t    warning (\"mudflap cannot track %qs in stub function\",\n+\t\t     IDENTIFIER_POINTER (DECL_NAME (decl)));\n+\t  else\n+\t    {\n+\t      tsi_link_before (&initially_stmts, register_fncall, TSI_SAME_STMT);\n+\n+\t      /* Accumulate the FINALLY piece.  */\n+\t      append_to_statement_list (unregister_fncall, &finally_stmts);\n+\t    }\n           mf_mark (decl);\n         }\n \n@@ -1092,7 +1099,7 @@ mx_xfn_xform_decls (tree *t, int *continue_p, void *data)\n       break;\n     }\n \n-  return NULL;\n+  return NULL_TREE;\n }\n \n /* Perform the object lifetime tracking mudflap transform on the given function"}]}