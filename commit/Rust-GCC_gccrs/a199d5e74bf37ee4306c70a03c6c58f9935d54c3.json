{"sha": "a199d5e74bf37ee4306c70a03c6c58f9935d54c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTE5OWQ1ZTc0YmYzN2VlNDMwNmM3MGEwM2M2YzU4Zjk5MzVkNTRjMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-03-24T10:52:34Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-03-24T10:52:34Z"}, "message": "Use SCEV information when aligning for vectorisation (PR 84005)\n\nThis PR is another regression caused by the removal of the simple_iv\ncheck in dr_analyze_innermost for BB analysis.  Without splitting out\nthe step, we weren't able to find an underlying object whose alignment\ncould be increased.\n\nAs with PR81635, I think the simple_iv was only handling one special\ncase of something that ought to be more general.  The more general\nthing here is that if the address can be analysed as a scalar\nevolution, and if all updates preserve alignment N, it's possible\nto align the address to N by increasing the alignment of the base\nobject to N.  That applies also to outer loops, and to both loop\nand BB analysis.\n\nI wasn't sure where the new functions ought to live, but tree-data-ref.c\nseemed OK since (a) that already does scev analysis on addresses and\n(b) you'd want to use dr_analyze_innermost first if you were analysing\na reference.\n\n2018-03-24  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\tPR tree-optimization/84005\n\t* tree-data-ref.h (get_base_for_alignment): Declare.\n\t* tree-data-ref.c (get_base_for_alignment_1): New function.\n\t(get_base_for_alignment): Likewise.\n\t* tree-vect-data-refs.c (vect_compute_data_ref_alignment): Use\n\tget_base_for_alignment to find a suitable base object, instead\n\tof always using drb->base_address.\n\ngcc/testsuite/\n\tPR tree-optimization/84005\n\t* gcc.dg/vect/bb-slp-1.c: Make sure there is no message about\n\tfailing to force the alignment.\n\nFrom-SVN: r258833", "tree": {"sha": "18226202d3160ebeb2ae161ed993f2ad1dc5e749", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18226202d3160ebeb2ae161ed993f2ad1dc5e749"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a199d5e74bf37ee4306c70a03c6c58f9935d54c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a199d5e74bf37ee4306c70a03c6c58f9935d54c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a199d5e74bf37ee4306c70a03c6c58f9935d54c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a199d5e74bf37ee4306c70a03c6c58f9935d54c3/comments", "author": null, "committer": null, "parents": [{"sha": "19efbf0f53762e41be3b5fbdbc46e5b4e2c0c958", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19efbf0f53762e41be3b5fbdbc46e5b4e2c0c958", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19efbf0f53762e41be3b5fbdbc46e5b4e2c0c958"}], "stats": {"total": 104, "additions": 98, "deletions": 6}, "files": [{"sha": "9526547b4d8c29a184ab327f58a55fbffaa6f405", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a199d5e74bf37ee4306c70a03c6c58f9935d54c3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a199d5e74bf37ee4306c70a03c6c58f9935d54c3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a199d5e74bf37ee4306c70a03c6c58f9935d54c3", "patch": "@@ -1,3 +1,13 @@\n+2018-03-24  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\tPR tree-optimization/84005\n+\t* tree-data-ref.h (get_base_for_alignment): Declare.\n+\t* tree-data-ref.c (get_base_for_alignment_1): New function.\n+\t(get_base_for_alignment): Likewise.\n+\t* tree-vect-data-refs.c (vect_compute_data_ref_alignment): Use\n+\tget_base_for_alignment to find a suitable base object, instead\n+\tof always using drb->base_address.\n+\n 2018-03-23  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR inline-asm/85022"}, {"sha": "1ea5f0cba47220ed9a1e89bfbeecafcc713b866c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a199d5e74bf37ee4306c70a03c6c58f9935d54c3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a199d5e74bf37ee4306c70a03c6c58f9935d54c3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a199d5e74bf37ee4306c70a03c6c58f9935d54c3", "patch": "@@ -1,3 +1,9 @@\n+2018-03-24  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\tPR tree-optimization/84005\n+\t* gcc.dg/vect/bb-slp-1.c: Make sure there is no message about\n+\tfailing to force the alignment.\n+\n 2018-03-23  Peter Bergner  <bergner@vnet.ibm.com>\n \n \t* gcc.target/powerpc/builtins-1-le.c <vclzb>: Rename duplicate test"}, {"sha": "e6818cb8d8fb3bf84bba03e3b4a78700f2f3a068", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a199d5e74bf37ee4306c70a03c6c58f9935d54c3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a199d5e74bf37ee4306c70a03c6c58f9935d54c3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-1.c?ref=a199d5e74bf37ee4306c70a03c6c58f9935d54c3", "patch": "@@ -54,5 +54,5 @@ int main (void)\n   return 0;\n }\n \n+/* { dg-final { scan-tree-dump-not \"can't force alignment\" \"slp1\" } } */\n /* { dg-final { scan-tree-dump-times \"basic block vectorized\" 1 \"slp1\" } } */\n-  "}, {"sha": "e2107feb22a35197ed6f5674f4a56f7e3f3db0c1", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a199d5e74bf37ee4306c70a03c6c58f9935d54c3/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a199d5e74bf37ee4306c70a03c6c58f9935d54c3/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=a199d5e74bf37ee4306c70a03c6c58f9935d54c3", "patch": "@@ -5202,6 +5202,81 @@ dr_alignment (innermost_loop_behavior *drb)\n   return alignment;\n }\n \n+/* If BASE is a pointer-typed SSA name, try to find the object that it\n+   is based on.  Return this object X on success and store the alignment\n+   in bytes of BASE - &X in *ALIGNMENT_OUT.  */\n+\n+static tree\n+get_base_for_alignment_1 (tree base, unsigned int *alignment_out)\n+{\n+  if (TREE_CODE (base) != SSA_NAME || !POINTER_TYPE_P (TREE_TYPE (base)))\n+    return NULL_TREE;\n+\n+  gimple *def = SSA_NAME_DEF_STMT (base);\n+  base = analyze_scalar_evolution (loop_containing_stmt (def), base);\n+\n+  /* Peel chrecs and record the minimum alignment preserved by\n+     all steps.  */\n+  unsigned int alignment = MAX_OFILE_ALIGNMENT / BITS_PER_UNIT;\n+  while (TREE_CODE (base) == POLYNOMIAL_CHREC)\n+    {\n+      unsigned int step_alignment = highest_pow2_factor (CHREC_RIGHT (base));\n+      alignment = MIN (alignment, step_alignment);\n+      base = CHREC_LEFT (base);\n+    }\n+\n+  /* Punt if the expression is too complicated to handle.  */\n+  if (tree_contains_chrecs (base, NULL) || !POINTER_TYPE_P (TREE_TYPE (base)))\n+    return NULL_TREE;\n+\n+  /* The only useful cases are those for which a dereference folds to something\n+     other than an INDIRECT_REF.  */\n+  tree ref_type = TREE_TYPE (TREE_TYPE (base));\n+  tree ref = fold_indirect_ref_1 (UNKNOWN_LOCATION, ref_type, base);\n+  if (!ref)\n+    return NULL_TREE;\n+\n+  /* Analyze the base to which the steps we peeled were applied.  */\n+  poly_int64 bitsize, bitpos, bytepos;\n+  machine_mode mode;\n+  int unsignedp, reversep, volatilep;\n+  tree offset;\n+  base = get_inner_reference (ref, &bitsize, &bitpos, &offset, &mode,\n+\t\t\t      &unsignedp, &reversep, &volatilep);\n+  if (!base || !multiple_p (bitpos, BITS_PER_UNIT, &bytepos))\n+    return NULL_TREE;\n+\n+  /* Restrict the alignment to that guaranteed by the offsets.  */\n+  unsigned int bytepos_alignment = known_alignment (bytepos);\n+  if (bytepos_alignment != 0)\n+    alignment = MIN (alignment, bytepos_alignment);\n+  if (offset)\n+    {\n+      unsigned int offset_alignment = highest_pow2_factor (offset);\n+      alignment = MIN (alignment, offset_alignment);\n+    }\n+\n+  *alignment_out = alignment;\n+  return base;\n+}\n+\n+/* Return the object whose alignment would need to be changed in order\n+   to increase the alignment of ADDR.  Store the maximum achievable\n+   alignment in *MAX_ALIGNMENT.  */\n+\n+tree\n+get_base_for_alignment (tree addr, unsigned int *max_alignment)\n+{\n+  tree base = get_base_for_alignment_1 (addr, max_alignment);\n+  if (base)\n+    return base;\n+\n+  if (TREE_CODE (addr) == ADDR_EXPR)\n+    addr = TREE_OPERAND (addr, 0);\n+  *max_alignment = MAX_OFILE_ALIGNMENT / BITS_PER_UNIT;\n+  return addr;\n+}\n+\n /* Recursive helper function.  */\n \n static bool"}, {"sha": "8739853336abbd899958373b8a6a3300dfb30d6d", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a199d5e74bf37ee4306c70a03c6c58f9935d54c3/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a199d5e74bf37ee4306c70a03c6c58f9935d54c3/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=a199d5e74bf37ee4306c70a03c6c58f9935d54c3", "patch": "@@ -463,6 +463,7 @@ extern bool compute_all_dependences (vec<data_reference_p> ,\n extern tree find_data_references_in_bb (struct loop *, basic_block,\n                                         vec<data_reference_p> *);\n extern unsigned int dr_alignment (innermost_loop_behavior *);\n+extern tree get_base_for_alignment (tree, unsigned int *);\n \n /* Return the alignment in bytes that DR is guaranteed to have at all\n    times.  */"}, {"sha": "ce2438799b85283f932ec1e51d089eb8c45ce6c5", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a199d5e74bf37ee4306c70a03c6c58f9935d54c3/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a199d5e74bf37ee4306c70a03c6c58f9935d54c3/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=a199d5e74bf37ee4306c70a03c6c58f9935d54c3", "patch": "@@ -957,11 +957,11 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n \n   if (base_alignment < vector_alignment)\n     {\n-      tree base = drb->base_address;\n-      if (TREE_CODE (base) == ADDR_EXPR)\n-\tbase = TREE_OPERAND (base, 0);\n-      if (!vect_can_force_dr_alignment_p (base,\n-\t\t\t\t\t  vector_alignment * BITS_PER_UNIT))\n+      unsigned int max_alignment;\n+      tree base = get_base_for_alignment (drb->base_address, &max_alignment);\n+      if (max_alignment < vector_alignment\n+\t  || !vect_can_force_dr_alignment_p (base,\n+\t\t\t\t\t     vector_alignment * BITS_PER_UNIT))\n \t{\n \t  if (dump_enabled_p ())\n \t    {"}]}