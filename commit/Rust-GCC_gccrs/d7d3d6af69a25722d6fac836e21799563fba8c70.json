{"sha": "d7d3d6af69a25722d6fac836e21799563fba8c70", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDdkM2Q2YWY2OWEyNTcyMmQ2ZmFjODM2ZTIxNzk5NTYzZmJhOGM3MA==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2011-01-25T06:46:07Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2011-01-25T06:46:07Z"}, "message": "Minimize the number of expensive calls to ppl_powerset_is_empty.\n\n2011-01-25  Sebastian Pop  <sebastian.pop@amd.com>\n\n\t* graphite-dependences.c: Include graphite-cloog-util.h.\n\t(new_poly_ddr): Inlined into dependence_polyhedron.\n\t(free_poly_ddr): Moved close by new_poly_ddr.\n\t(dependence_polyhedron_1): Renamed dependence_polyhedron.\n\tEarly return NULL when ppl_powerset_is_empty returns true.\n\t(dependence_polyhedron): Renamed new_poly_ddr.  Call only once\n\tpoly_drs_may_alias_p.  Avoid one call to ppl_powerset_is_empty.\n\t(graphite_legal_transform_dr): Call new_poly_ddr.\n\t(graphite_carried_dependence_level_k): Same.\n\t(dot_original_deps_stmt_1): Renamed dot_deps_stmt_2.  Use new_poly_ddr.\n\t(dot_transformed_deps_stmt_1): Removed.\n\t(dot_deps_stmt_1): Call dot_deps_stmt_2.\n\t(dot_original_deps): Renamed dot_deps_2.  Call new_poly_ddr.\n\t(dot_deps_1): Call dot_deps_2.\n\t* Makefile.in (graphite-dependences.o): Add missing dependence on\n\tgraphite-cloog-util.h.\n\nFrom-SVN: r169206", "tree": {"sha": "8cd48eb9a7e2b73a18175f3e96db4aa6701557ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8cd48eb9a7e2b73a18175f3e96db4aa6701557ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7d3d6af69a25722d6fac836e21799563fba8c70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7d3d6af69a25722d6fac836e21799563fba8c70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7d3d6af69a25722d6fac836e21799563fba8c70", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7d3d6af69a25722d6fac836e21799563fba8c70/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28c5db5784e89103e979fa1ec165494ff82e53c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28c5db5784e89103e979fa1ec165494ff82e53c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28c5db5784e89103e979fa1ec165494ff82e53c0"}], "stats": {"total": 230, "additions": 105, "deletions": 125}, "files": [{"sha": "ff43b8ee0b592f28896cdfec53ea52b1c8d40ae2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7d3d6af69a25722d6fac836e21799563fba8c70/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7d3d6af69a25722d6fac836e21799563fba8c70/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d7d3d6af69a25722d6fac836e21799563fba8c70", "patch": "@@ -1,3 +1,22 @@\n+2011-01-25  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* graphite-dependences.c: Include graphite-cloog-util.h.\n+\t(new_poly_ddr): Inlined into dependence_polyhedron.\n+\t(free_poly_ddr): Moved close by new_poly_ddr.\n+\t(dependence_polyhedron_1): Renamed dependence_polyhedron.\n+\tEarly return NULL when ppl_powerset_is_empty returns true.\n+\t(dependence_polyhedron): Renamed new_poly_ddr.  Call only once\n+\tpoly_drs_may_alias_p.  Avoid one call to ppl_powerset_is_empty.\n+\t(graphite_legal_transform_dr): Call new_poly_ddr.\n+\t(graphite_carried_dependence_level_k): Same.\n+\t(dot_original_deps_stmt_1): Renamed dot_deps_stmt_2.  Use new_poly_ddr.\n+\t(dot_transformed_deps_stmt_1): Removed.\n+\t(dot_deps_stmt_1): Call dot_deps_stmt_2.\n+\t(dot_original_deps): Renamed dot_deps_2.  Call new_poly_ddr.\n+\t(dot_deps_1): Call dot_deps_2.\n+\t* Makefile.in (graphite-dependences.o): Add missing dependence on\n+\tgraphite-cloog-util.h.\n+\n 2011-01-25  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* graphite-dependences.c (new_poly_dr): Call ppl_powerset_is_empty."}, {"sha": "93c4c4ee38e93e1e68841baf04ae1ef63318f5aa", "filename": "gcc/ChangeLog.graphite", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7d3d6af69a25722d6fac836e21799563fba8c70/gcc%2FChangeLog.graphite", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7d3d6af69a25722d6fac836e21799563fba8c70/gcc%2FChangeLog.graphite", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.graphite?ref=d7d3d6af69a25722d6fac836e21799563fba8c70", "patch": "@@ -1,3 +1,20 @@\n+2011-01-15  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* graphite-dependences.c (new_poly_ddr): Inlined into\n+\tdependence_polyhedron.\n+\t(free_poly_ddr): Moved close by new_poly_ddr.\n+\t(dependence_polyhedron_1): Renamed dependence_polyhedron.\n+\tEarly return NULL when ppl_powerset_is_empty returns true.\n+\t(dependence_polyhedron): Renamed new_poly_ddr.  Call only once\n+\tpoly_drs_may_alias_p.  Avoid one call to ppl_powerset_is_empty.\n+\t(graphite_legal_transform_dr): Call new_poly_ddr.\n+\t(graphite_carried_dependence_level_k): Same.\n+\t(dot_original_deps_stmt_1): Renamed dot_deps_stmt_2.  Use new_poly_ddr.\n+\t(dot_transformed_deps_stmt_1): Removed.\n+\t(dot_deps_stmt_1): Call dot_deps_stmt_2.\n+\t(dot_original_deps): Renamed dot_deps_2.  Call new_poly_ddr.\n+\t(dot_deps_1): Call dot_deps_2.\n+\n 2011-01-15  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* graphite-dependences.c (new_poly_dr): Call ppl_powerset_is_empty."}, {"sha": "eeb77e476ad42515ba43f218671c73b2c1efc32f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7d3d6af69a25722d6fac836e21799563fba8c70/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7d3d6af69a25722d6fac836e21799563fba8c70/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=d7d3d6af69a25722d6fac836e21799563fba8c70", "patch": "@@ -2686,7 +2686,8 @@ graphite-cloog-util.o : graphite-cloog-util.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h graphite-cloog-util.h graphite-cloog-compat.h\n graphite-dependences.o : graphite-dependences.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TREE_FLOW_H) $(TREE_DUMP_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) \\\n-   sese.h graphite-ppl.h graphite-poly.h graphite-dependences.h\n+   sese.h graphite-ppl.h graphite-poly.h graphite-dependences.h \\\n+   graphite-cloog-util.h\n graphite-flattening.o : graphite-flattening.c $(CONFIG_H) $(SYSTEM_H)\t\\\n    coretypes.h $(TREE_FLOW_H) $(TREE_DUMP_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) \\\n    sese.h graphite-ppl.h graphite-poly.h"}, {"sha": "81846438c17a627f62cfaf9179b241aae6654489", "filename": "gcc/graphite-dependences.c", "status": "modified", "additions": 67, "deletions": 124, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7d3d6af69a25722d6fac836e21799563fba8c70/gcc%2Fgraphite-dependences.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7d3d6af69a25722d6fac836e21799563fba8c70/gcc%2Fgraphite-dependences.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-dependences.c?ref=d7d3d6af69a25722d6fac836e21799563fba8c70", "patch": "@@ -35,43 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"graphite-ppl.h\"\n #include \"graphite-poly.h\"\n #include \"graphite-dependences.h\"\n-\n-/* Returns a new polyhedral Data Dependence Relation (DDR).  SOURCE is\n-   the source data reference, SINK is the sink data reference.  When\n-   the Data Dependence Polyhedron DDP is not NULL or not empty, SOURCE\n-   and SINK are in dependence as described by DDP.  */\n-\n-static poly_ddr_p\n-new_poly_ddr (poly_dr_p source, poly_dr_p sink,\n-\t      ppl_Pointset_Powerset_C_Polyhedron_t ddp,\n-\t      bool original_scattering_p)\n-{\n-  poly_ddr_p pddr = XNEW (struct poly_ddr);\n-\n-  PDDR_SOURCE (pddr) = source;\n-  PDDR_SINK (pddr) = sink;\n-  PDDR_DDP (pddr) = ddp;\n-  PDDR_ORIGINAL_SCATTERING_P (pddr) = original_scattering_p;\n-\n-  if (!ddp\n-      || ppl_powerset_is_empty (ddp,\n-\t\t\t\tscop_nb_params (PBB_SCOP (PDR_PBB (source)))))\n-    PDDR_KIND (pddr) = no_dependence;\n-  else\n-    PDDR_KIND (pddr) = has_dependence;\n-\n-  return pddr;\n-}\n-\n-/* Free the poly_ddr_p P.  */\n-\n-void\n-free_poly_ddr (void *p)\n-{\n-  poly_ddr_p pddr = (poly_ddr_p) p;\n-  ppl_delete_Pointset_Powerset_C_Polyhedron (PDDR_DDP (pddr));\n-  free (pddr);\n-}\n+#include \"graphite-cloog-util.h\"\n \n /* Comparison function for poly_ddr hash table.  */\n \n@@ -458,8 +422,8 @@ build_lexicographical_constraint (ppl_Pointset_Powerset_C_Polyhedron_t bag,\n    relation, from PDR2 to PDR1.  */\n \n static ppl_Pointset_Powerset_C_Polyhedron_t\n-dependence_polyhedron_1 (poly_dr_p pdr1, poly_dr_p pdr2,\n-\t\t         int direction, bool original_scattering_p)\n+dependence_polyhedron (poly_dr_p pdr1, poly_dr_p pdr2,\n+\t\t       int direction, bool original_scattering_p)\n {\n   poly_bb_p pbb1 = PDR_PBB (pdr1);\n   poly_bb_p pbb2 = PDR_PBB (pdr2);\n@@ -479,6 +443,7 @@ dependence_polyhedron_1 (poly_dr_p pdr1, poly_dr_p pdr2,\n   ppl_Pointset_Powerset_C_Polyhedron_t res;\n   ppl_Pointset_Powerset_C_Polyhedron_t idr1, idr2;\n   ppl_Pointset_Powerset_C_Polyhedron_t sc1, sc2, dreq;\n+  ppl_Pointset_Powerset_C_Polyhedron_t lex;\n \n   gcc_assert (PBB_SCOP (pbb1) == PBB_SCOP (pbb2));\n \n@@ -512,16 +477,14 @@ dependence_polyhedron_1 (poly_dr_p pdr1, poly_dr_p pdr2,\n   ppl_delete_Pointset_Powerset_C_Polyhedron (idr2);\n   ppl_delete_Pointset_Powerset_C_Polyhedron (dreq);\n \n-  if (!ppl_powerset_is_empty (res, gdim))\n-    {\n-      ppl_Pointset_Powerset_C_Polyhedron_t lex =\n-\tbuild_lexicographical_constraint (res, dim, MIN (tdim1, tdim2),\n+  if (ppl_powerset_is_empty (res, gdim))\n+    return NULL;\n+\n+  lex = build_lexicographical_constraint (res, dim, MIN (tdim1, tdim2),\n \t\t\t\t\t  tdim1 + ddim1, gdim, direction);\n-      ppl_delete_Pointset_Powerset_C_Polyhedron (res);\n-      res = lex;\n-    }\n+  ppl_delete_Pointset_Powerset_C_Polyhedron (res);\n \n-  return res;\n+  return lex;\n }\n \n /* Build the dependence polyhedron for data references PDR1 and PDR2.\n@@ -532,12 +495,12 @@ dependence_polyhedron_1 (poly_dr_p pdr1, poly_dr_p pdr2,\n    relation, from PDR2 to PDR1.  */\n \n static poly_ddr_p\n-dependence_polyhedron (poly_dr_p pdr1, poly_dr_p pdr2,\n-\t\t       int direction, bool original_scattering_p)\n+new_poly_ddr (poly_dr_p pdr1, poly_dr_p pdr2,\n+\t      int direction, bool original_scattering_p)\n {\n   PTR *x = NULL;\n   poly_ddr_p res;\n-  ppl_Pointset_Powerset_C_Polyhedron_t ddp;\n+  bool may_alias;\n \n   /* Return the PDDR from the cache if it already has been computed.  */\n   if (original_scattering_p)\n@@ -554,28 +517,51 @@ dependence_polyhedron (poly_dr_p pdr1, poly_dr_p pdr2,\n \treturn (poly_ddr_p) *x;\n     }\n \n-  if ((pdr_read_p (pdr1) && pdr_read_p (pdr2))\n-      || PDR_BASE_OBJECT_SET (pdr1) != PDR_BASE_OBJECT_SET (pdr2)\n-      || PDR_NB_SUBSCRIPTS (pdr1) != PDR_NB_SUBSCRIPTS (pdr2)\n-      || !poly_drs_may_alias_p (pdr1, pdr2))\n-    ddp = NULL;\n-  else\n-    ddp = dependence_polyhedron_1 (pdr1, pdr2, direction,\n-\t\t\t\t   original_scattering_p);\n+  res = XNEW (struct poly_ddr);\n+  PDDR_SOURCE (res) = pdr1;\n+  PDDR_SINK (res) = pdr2;\n+  PDDR_DDP (res) = NULL;\n+  PDDR_ORIGINAL_SCATTERING_P (res) = original_scattering_p;\n+  PDDR_KIND (res) = unknown_dependence;\n \n-  res = new_poly_ddr (pdr1, pdr2, ddp, original_scattering_p);\n+  may_alias = poly_drs_may_alias_p (pdr1, pdr2);\n \n   if (!(pdr_read_p (pdr1) && pdr_read_p (pdr2))\n       && PDR_BASE_OBJECT_SET (pdr1) != PDR_BASE_OBJECT_SET (pdr2)\n-      && poly_drs_may_alias_p (pdr1, pdr2))\n+      && may_alias)\n     PDDR_KIND (res) = unknown_dependence;\n \n+  else if (!(pdr_read_p (pdr1) && pdr_read_p (pdr2))\n+\t   && PDR_BASE_OBJECT_SET (pdr1) == PDR_BASE_OBJECT_SET (pdr2)\n+\t   && PDR_NB_SUBSCRIPTS (pdr1) == PDR_NB_SUBSCRIPTS (pdr2)\n+\t   && may_alias)\n+    {\n+      PDDR_DDP (res) = dependence_polyhedron (pdr1, pdr2, direction,\n+\t\t\t\t\t      original_scattering_p);\n+      if (PDDR_DDP (res))\n+\tPDDR_KIND (res) = has_dependence;\n+      else\n+\tPDDR_KIND (res) = no_dependence;\n+    }\n+  else\n+    PDDR_KIND (res) = no_dependence;\n+\n   if (original_scattering_p)\n     *x = res;\n \n   return res;\n }\n \n+/* Free the data dependence relation poly_ddr_p P.  */\n+\n+void\n+free_poly_ddr (void *p)\n+{\n+  poly_ddr_p pddr = (poly_ddr_p) p;\n+  ppl_delete_Pointset_Powerset_C_Polyhedron (PDDR_DDP (pddr));\n+  free (pddr);\n+}\n+\n /* Return true when the data dependence relation between the data\n    references PDR1 belonging to PBB1 and PDR2 is part of a\n    reduction.  */\n@@ -635,7 +621,7 @@ graphite_legal_transform_dr (poly_dr_p pdr1, poly_dr_p pdr2)\n      we get an empty intersection when the transform is legal:\n      i.e. the transform should reverse no dependences, and so PT, the\n      reversed transformed PDDR, should have no constraint from PO.  */\n-  opddr = dependence_polyhedron (pdr1, pdr2, 1, true);\n+  opddr = new_poly_ddr (pdr1, pdr2, 1, true);\n \n   if (PDDR_KIND (opddr) == unknown_dependence)\n     return false;\n@@ -646,7 +632,7 @@ graphite_legal_transform_dr (poly_dr_p pdr1, poly_dr_p pdr2)\n   if (pddr_is_empty (opddr))\n     return true;\n \n-  tpddr = dependence_polyhedron (pdr1, pdr2, -1, false);\n+  tpddr = new_poly_ddr (pdr1, pdr2, -1, false);\n \n   if (PDDR_KIND (tpddr) == unknown_dependence)\n     {\n@@ -768,7 +754,7 @@ graphite_carried_dependence_level_k (poly_dr_p pdr1, poly_dr_p pdr2,\n   graphite_dim_t ddim1 = pbb_dim_iter_domain (PDR_PBB (pdr1));\n   ppl_dimension_type dim;\n   bool empty_p;\n-  poly_ddr_p pddr = dependence_polyhedron (pdr1, pdr2, 1, false);\n+  poly_ddr_p pddr = new_poly_ddr (pdr1, pdr2, 1, false);\n \n   if (PDDR_KIND (pddr) == unknown_dependence)\n     {\n@@ -818,36 +804,12 @@ dependency_between_pbbs_p (poly_bb_p pbb1, poly_bb_p pbb2, int level)\n   return false;\n }\n \n-/* Pretty print to FILE all the original data dependences of SCoP in\n-   DOT format.  */\n+/* When ORIG is true, pretty print to FILE all the original data\n+   dependences of SCoP in DOT format, otherwise print the transformed\n+   data deps.  */\n \n static void\n-dot_original_deps_stmt_1 (FILE *file, scop_p scop)\n-{\n-  int i, j, k, l;\n-  poly_bb_p pbb1, pbb2;\n-  poly_dr_p pdr1, pdr2;\n-\n-  FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), i, pbb1)\n-    FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), j, pbb2)\n-      {\n-\tFOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb1), k, pdr1)\n-\t  FOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb2), l, pdr2)\n-\t    if (!pddr_is_empty (dependence_polyhedron (pdr1, pdr2, 1, true)))\n-\t      {\n-\t\tfprintf (file, \"OS%d -> OS%d\\n\",\n-\t\t\t pbb_index (pbb1), pbb_index (pbb2));\n-\t\tgoto done;\n-\t      }\n-      done:;\n-      }\n-}\n-\n-/* Pretty print to FILE all the transformed data dependences of SCoP in\n-   DOT format.  */\n-\n-static void\n-dot_transformed_deps_stmt_1 (FILE *file, scop_p scop)\n+dot_deps_stmt_2 (FILE *file, scop_p scop, bool orig)\n {\n   int i, j, k, l;\n   poly_bb_p pbb1, pbb2;\n@@ -859,11 +821,11 @@ dot_transformed_deps_stmt_1 (FILE *file, scop_p scop)\n \tFOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb1), k, pdr1)\n \t  FOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb2), l, pdr2)\n \t    {\n-\t      poly_ddr_p pddr = dependence_polyhedron (pdr1, pdr2, 1, false);\n+\t      poly_ddr_p pddr = new_poly_ddr (pdr1, pdr2, 1, orig);\n \n \t      if (!pddr_is_empty (pddr))\n \t\t{\n-\t\t  fprintf (file, \"TS%d -> TS%d\\n\",\n+\t\t  fprintf (file, orig ? \"OS%d -> OS%d\\n\" : \"TS%d -> TS%d\\n\",\n \t\t\t   pbb_index (pbb1), pbb_index (pbb2));\n \n \t\t  free_poly_ddr (pddr);\n@@ -876,7 +838,6 @@ dot_transformed_deps_stmt_1 (FILE *file, scop_p scop)\n       }\n }\n \n-\n /* Pretty print to FILE all the data dependences of SCoP in DOT\n    format.  */\n \n@@ -885,37 +846,18 @@ dot_deps_stmt_1 (FILE *file, scop_p scop)\n {\n   fputs (\"digraph all {\\n\", file);\n \n-  dot_original_deps_stmt_1 (file, scop);\n-  dot_transformed_deps_stmt_1 (file, scop);\n+  dot_deps_stmt_2 (file, scop, true);\n+  dot_deps_stmt_2 (file, scop, false);\n \n   fputs (\"}\\n\\n\", file);\n }\n \n-/* Pretty print to FILE all the original data dependences of SCoP in\n-   DOT format.  */\n-\n-static void\n-dot_original_deps (FILE *file, scop_p scop)\n-{\n-  int i, j, k, l;\n-  poly_bb_p pbb1, pbb2;\n-  poly_dr_p pdr1, pdr2;\n-\n-  FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), i, pbb1)\n-    FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), j, pbb2)\n-      FOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb1), k, pdr1)\n-\tFOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb2), l, pdr2)\n-\t  if (!pddr_is_empty (dependence_polyhedron (pdr1, pdr2, 1, true)))\n-\t    fprintf (file, \"OS%d_D%d -> OS%d_D%d\\n\",\n-\t\t     pbb_index (pbb1), PDR_ID (pdr1),\n-\t\t     pbb_index (pbb2), PDR_ID (pdr2));\n-}\n-\n-/* Pretty print to FILE all the transformed data dependences of SCoP in\n-   DOT format.  */\n+/* When ORIG is true, pretty print to FILE all the original data\n+   dependences of SCoP in DOT format, otherwise print the transformed\n+   data deps.  */\n \n static void\n-dot_transformed_deps (FILE *file, scop_p scop)\n+dot_deps_2 (FILE *file, scop_p scop, bool orig)\n {\n   int i, j, k, l;\n   poly_bb_p pbb1, pbb2;\n@@ -925,11 +867,12 @@ dot_transformed_deps (FILE *file, scop_p scop)\n     FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), j, pbb2)\n       FOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb1), k, pdr1)\n \tFOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb2), l, pdr2)\n-\t  {\n-\t    poly_ddr_p pddr = dependence_polyhedron (pdr1, pdr2, 1, false);\n+          {\n+\t    poly_ddr_p pddr = new_poly_ddr (pdr1, pdr2, 1, orig);\n \n \t    if (!pddr_is_empty (pddr))\n-\t      fprintf (file, \"TS%d_D%d -> TS%d_D%d\\n\",\n+\t      fprintf (file, orig\n+\t\t       ? \"OS%d_D%d -> OS%d_D%d\\n\" : \"TS%d_D%d -> TS%d_D%d\\n\",\n \t\t       pbb_index (pbb1), PDR_ID (pdr1),\n \t\t       pbb_index (pbb2), PDR_ID (pdr2));\n \n@@ -945,8 +888,8 @@ dot_deps_1 (FILE *file, scop_p scop)\n {\n   fputs (\"digraph all {\\n\", file);\n \n-  dot_original_deps (file, scop);\n-  dot_transformed_deps (file, scop);\n+  dot_deps_2 (file, scop, true);\n+  dot_deps_2 (file, scop, false);\n \n   fputs (\"}\\n\\n\", file);\n }"}]}