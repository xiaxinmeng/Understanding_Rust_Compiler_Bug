{"sha": "ae56e2da05e823e63972aff3118a659d7ca7a8b9", "node_id": "C_kwDOANBUbNoAKGFlNTZlMmRhMDVlODIzZTYzOTcyYWZmMzExOGE2NTlkN2NhN2E4Yjk", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-04-21T13:25:26Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-04-21T19:03:08Z"}, "message": "d: Merge upstream dmd eb7bee331, druntime 27834edb, phobos ac296f80c.\n\nD front-end changes:\n\n    - Import dmd v2.100.0-beta.1.\n    - Print deprecation messages for scope violations unless\n      `-frevert=dip1000' is used.\n    - Fixed a missed case of switch case fallthrough not being caught by\n      the compiler.\n\nD runtime changes:\n\n    - Import druntime v2.100.0-beta.1.\n\nPhobos changes:\n\n    - Import phobos v2.100.0-beta.1.\n\ngcc/d/ChangeLog:\n\n\t* dmd/MERGE: Merge upstream dmd eb7bee331.\n\t* dmd/VERSION: Update version to v2.100.0-beta.1.\n\t* d-lang.cc (d_handle_option): Handle OPT_frevert_dip1000.\n\t* lang.opt (frevert=dip1000): New option.\n\nlibphobos/ChangeLog:\n\n\t* libdruntime/MERGE: Merge upstream druntime 27834edb.\n\t* src/MERGE: Merge upstream phobos ac296f80c.\n\t* src/Makefile.am (PHOBOS_DSOURCES): Add std/int128.d.\n\t* src/Makefile.in: Regenerate.", "tree": {"sha": "13932a03f44d3892b2ea8accebe7e55fed6142e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/13932a03f44d3892b2ea8accebe7e55fed6142e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae56e2da05e823e63972aff3118a659d7ca7a8b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae56e2da05e823e63972aff3118a659d7ca7a8b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae56e2da05e823e63972aff3118a659d7ca7a8b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae56e2da05e823e63972aff3118a659d7ca7a8b9/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93dd7f36f2066ec52137178ee52052f293e5e743", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93dd7f36f2066ec52137178ee52052f293e5e743", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93dd7f36f2066ec52137178ee52052f293e5e743"}], "stats": {"total": 1304, "additions": 1002, "deletions": 302}, "files": [{"sha": "9adcabdf7cfafff597b35301cd32adc21bedbcdd", "filename": "gcc/d/d-lang.cc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fd-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fd-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-lang.cc?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -637,12 +637,17 @@ d_handle_option (size_t scode, const char *arg, HOST_WIDE_INT value,\n       break;\n \n     case OPT_frevert_all:\n+      global.params.useDIP1000 = FeatureState::disabled;\n       global.params.useDIP25 = FeatureState::disabled;\n       global.params.dtorFields = FeatureState::disabled;\n       global.params.fix16997 = !value;\n       global.params.markdown = !value;\n       break;\n \n+    case OPT_frevert_dip1000:\n+      global.params.useDIP1000 = FeatureState::disabled;\n+      break;\n+\n     case OPT_frevert_dip25:\n       global.params.useDIP25 = FeatureState::disabled;\n       break;"}, {"sha": "2bc9b95b5e2df6e202e7416ca8261b266655bca1", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -1,4 +1,4 @@\n-4d1bfcf142928cf1c097b0a2689485c1b14f4f53\n+eb7bee331a13026eeb4dcbf9d43d5d4e744a4d26\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "2450fd55ef8be70d7ae4b3d6b040dfd58b89bca4", "filename": "gcc/d/dmd/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FVERSION?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -1 +1 @@\n-v2.099.1\n+v2.100.0-beta.1"}, {"sha": "f4b5e8af7ff52fe90a59f3c9c1d817809da6eb35", "filename": "gcc/d/dmd/aggregate.d", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Faggregate.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Faggregate.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Faggregate.d?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -57,6 +57,28 @@ enum ClassKind : ubyte\n     c,\n }\n \n+/**\n+ * Give a nice string for a class kind for error messages\n+ * Params:\n+ *     c = class kind\n+ * Returns:\n+ *     0-terminated string for `c`\n+ */\n+const(char)* toChars(ClassKind c)\n+{\n+    final switch (c)\n+    {\n+        case ClassKind.d:\n+            return \"D\";\n+        case ClassKind.cpp:\n+            return \"C++\";\n+        case ClassKind.objc:\n+            return \"Objective-C\";\n+        case ClassKind.c:\n+            return \"C\";\n+    }\n+}\n+\n /**\n  * If an aggregate has a pargma(mangle, ...) this holds the information\n  * to mangle."}, {"sha": "bf196934aeda18b56bcfedcb8ee889e6fa9d9f93", "filename": "gcc/d/dmd/astenums.d", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Fastenums.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Fastenums.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fastenums.d?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -28,6 +28,7 @@ enum Baseok : ubyte\n \n enum MODFlags : int\n {\n+    none         = 0,    // default (mutable)\n     const_       = 1,    // type is const\n     immutable_   = 4,    // type is immutable\n     shared_      = 2,    // type is shared"}, {"sha": "22c9dde5f7e3b5a74a5e91c9ed22ca5cd975ea83", "filename": "gcc/d/dmd/blockexit.d", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Fblockexit.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Fblockexit.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fblockexit.d?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -139,16 +139,21 @@ int blockExit(Statement s, FuncDeclaration func, bool mustNotThrow)\n                             // Allow if last case/default was empty\n                             CaseStatement sc = slast.isCaseStatement();\n                             DefaultStatement sd = slast.isDefaultStatement();\n-                            if (sc && (!sc.statement.hasCode() || sc.statement.isCaseStatement() || sc.statement.isErrorStatement()))\n-                            {\n-                            }\n-                            else if (sd && (!sd.statement.hasCode() || sd.statement.isCaseStatement() || sd.statement.isErrorStatement()))\n+                            auto sl = (sc ? sc.statement : (sd ? sd.statement : null));\n+\n+                            if (sl && (!sl.hasCode() || sl.isErrorStatement()))\n                             {\n                             }\n                             else if (func.getModule().filetype != FileType.c)\n                             {\n                                 const(char)* gototype = s.isCaseStatement() ? \"case\" : \"default\";\n-                                s.error(\"switch case fallthrough - use 'goto %s;' if intended\", gototype);\n+                                // @@@DEPRECATED_2.110@@@ https://issues.dlang.org/show_bug.cgi?id=22999\n+                                // Deprecated in 2.100\n+                                // Make an error in 2.110\n+                                if (sl && sl.isCaseStatement())\n+                                    s.deprecation(\"switch case fallthrough - use 'goto %s;' if intended\", gototype);\n+                                else\n+                                    s.error(\"switch case fallthrough - use 'goto %s;' if intended\", gototype);\n                             }\n                         }\n                     }"}, {"sha": "9c8c1c316bff7f2c09f04c4d8271dd3506117338", "filename": "gcc/d/dmd/clone.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Fclone.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Fclone.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fclone.d?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -912,8 +912,8 @@ void buildDtors(AggregateDeclaration ad, Scope* sc)\n                 ex = new DotVarExp(loc, ex, v);\n \n                 // This is a hack so we can call destructors on const/immutable objects.\n-                // Do it as a type 'paint'.\n-                ex = new CastExp(loc, ex, v.type.mutableOf());\n+                // Do it as a type 'paint', `cast()`\n+                ex = new CastExp(loc, ex, MODFlags.none);\n                 if (stc & STC.safe)\n                     stc = (stc & ~STC.safe) | STC.trusted;\n \n@@ -1588,7 +1588,7 @@ private bool needCopyCtor(StructDeclaration sd, out bool hasCpCtor)\n \n         auto tf = ctorDecl.type.toTypeFunction();\n         const dim = tf.parameterList.length;\n-        if (dim == 1)\n+        if (dim == 1 || (dim > 1 && tf.parameterList[1].defaultArg))\n         {\n             auto param = tf.parameterList[0];\n             if (param.type.mutableOf().unSharedOf() == sd.type.mutableOf().unSharedOf())"}, {"sha": "53bf26ec927919816c68dce55308182ce8bd5279", "filename": "gcc/d/dmd/cparse.d", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Fcparse.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Fcparse.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcparse.d?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -259,6 +259,7 @@ final class CParser(AST) : Parser!AST\n         case TOK.plusPlus:\n         case TOK.minusMinus:\n         case TOK.sizeof_:\n+        case TOK._Generic:\n         Lexp:\n             auto exp = cparseExpression();\n             if (token.value == TOK.identifier && exp.op == EXP.identifier)\n@@ -2399,15 +2400,13 @@ final class CParser(AST) : Parser!AST\n                 if (idx.length > 2 && idx[0] == '_' && idx[1] == '_')  // leading double underscore\n                     importBuiltins = true;  // probably one of those compiler extensions\n                 t = null;\n-                if (scw & SCW.xtypedef)\n-                {\n-                    /* Punch through to what the typedef is, to support things like:\n-                     *  typedef T* T;\n-                     */\n-                    auto pt = lookupTypedef(previd);\n-                    if (pt && *pt)      // if previd is a known typedef\n-                        t = *pt;\n-                }\n+\n+                /* Punch through to what the typedef is, to support things like:\n+                 *  typedef T* T;\n+                 */\n+                auto pt = lookupTypedef(previd);\n+                if (pt && *pt)      // if previd is a known typedef\n+                    t = *pt;\n \n                 if (!t)\n                     t = new AST.TypeIdentifier(loc, previd);\n@@ -2745,6 +2744,11 @@ final class CParser(AST) : Parser!AST\n         Specifier specifier;\n         specifier.packalign.setDefault();\n         auto tspec = cparseSpecifierQualifierList(LVL.global, specifier);\n+        if (tspec && specifier.mod & MOD.xconst)\n+        {\n+            tspec = toConst(tspec);\n+            specifier.mod = MOD.xnone;      // 'used' it\n+        }\n         Identifier id;\n         return cparseDeclarator(DTR.xabstract, tspec, id, specifier);\n     }"}, {"sha": "a533d30ca808353f93dc78a8184a7d6e5ef77b02", "filename": "gcc/d/dmd/declaration.d", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Fdeclaration.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Fdeclaration.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdeclaration.d?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -379,7 +379,7 @@ extern (C++) abstract class Declaration : Dsymbol\n \n         if (e1 && e1.op == EXP.this_ && isField())\n         {\n-            VarDeclaration vthis = (cast(ThisExp)e1).var;\n+            VarDeclaration vthis = e1.isThisExp().var;\n             for (Scope* scx = sc; scx; scx = scx.enclosing)\n             {\n                 if (scx.func == vthis.parent && (scx.flags & SCOPE.contract))\n@@ -656,9 +656,8 @@ extern (C++) final class TupleDeclaration : Declaration\n             if (o.dyncast() == DYNCAST.expression)\n             {\n                 Expression e = cast(Expression)o;\n-                if (e.op == EXP.dSymbol)\n+                if (DsymbolExp ve = e.isDsymbolExp())\n                 {\n-                    DsymbolExp ve = cast(DsymbolExp)e;\n                     Declaration d = ve.s.isDeclaration();\n                     if (d && d.needThis())\n                     {\n@@ -1143,7 +1142,7 @@ extern (C++) class VarDeclaration : Declaration\n                 assert(o.dyncast() == DYNCAST.expression);\n                 Expression e = cast(Expression)o;\n                 assert(e.op == EXP.dSymbol);\n-                DsymbolExp se = cast(DsymbolExp)e;\n+                DsymbolExp se = e.isDsymbolExp();\n                 se.s.setFieldOffset(ad, fieldState, isunion);\n             }\n             return;\n@@ -1441,16 +1440,17 @@ extern (C++) class VarDeclaration : Declaration\n                 const sdsz = sd.type.size();\n                 assert(sdsz != SIZE_INVALID && sdsz != 0);\n                 const n = sz / sdsz;\n-                e = new SliceExp(loc, e, new IntegerExp(loc, 0, Type.tsize_t), new IntegerExp(loc, n, Type.tsize_t));\n+                SliceExp se = new SliceExp(loc, e, new IntegerExp(loc, 0, Type.tsize_t),\n+                    new IntegerExp(loc, n, Type.tsize_t));\n \n                 // Prevent redundant bounds check\n-                (cast(SliceExp)e).upperIsInBounds = true;\n-                (cast(SliceExp)e).lowerIsLessThanUpper = true;\n+                se.upperIsInBounds = true;\n+                se.lowerIsLessThanUpper = true;\n \n                 // This is a hack so we can call destructors on const/immutable objects.\n-                e.type = sd.type.arrayOf();\n+                se.type = sd.type.arrayOf();\n \n-                e = new CallExp(loc, new IdentifierExp(loc, Id.__ArrayDtor), e);\n+                e = new CallExp(loc, new IdentifierExp(loc, Id.__ArrayDtor), se);\n             }\n             return e;\n         }"}, {"sha": "2d9f6510ba5624e34f253522bfe7f528cbe68e7f", "filename": "gcc/d/dmd/dmodule.d", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Fdmodule.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Fdmodule.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmodule.d?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -1133,8 +1133,10 @@ extern (C++) final class Module : Package\n         // If it isn't there, some compiler rewrites, like\n         //    classinst == classinst -> .object.opEquals(classinst, classinst)\n         // would fail inside object.d.\n-        if (members.dim == 0 || (*members)[0].ident != Id.object ||\n-            (*members)[0].isImport() is null)\n+        if (filetype != FileType.c &&\n+            (members.dim == 0 ||\n+             (*members)[0].ident != Id.object ||\n+             (*members)[0].isImport() is null))\n         {\n             auto im = new Import(Loc.initial, null, Id.object, null, 0);\n             members.shift(im);"}, {"sha": "74eaa1d8d7ab78c84128c93eca94b22b9d69b8f8", "filename": "gcc/d/dmd/dsymbol.d", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Fdsymbol.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Fdsymbol.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbol.d?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -838,7 +838,8 @@ extern (C++) class Dsymbol : ASTNode\n         }\n         if (sds.isAggregateDeclaration() || sds.isEnumDeclaration())\n         {\n-            if (ident == Id.__sizeof || ident == Id.__xalignof || ident == Id._mangleof)\n+            if (ident == Id.__sizeof ||\n+                !(sc && sc.flags & SCOPE.Cfile) && (ident == Id.__xalignof || ident == Id._mangleof))\n             {\n                 error(\"`.%s` property cannot be redefined\", ident.toChars());\n                 errors = true;\n@@ -2523,6 +2524,7 @@ Dsymbol handleSymbolRedeclarations(ref Scope sc, Dsymbol s, Dsymbol s2, ScopeDsy\n \n         if (i1)                         // vd is the definition\n         {\n+            vd2.storage_class |= STC.extern_;  // so toObjFile() won't emit it\n             sds.symtab.update(vd);      // replace vd2 with the definition\n             return vd;\n         }"}, {"sha": "5415401e0e4db22b072fd3bfe5a2f1b8546a7fa3", "filename": "gcc/d/dmd/dsymbolsem.d", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Fdsymbolsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Fdsymbolsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbolsem.d?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -2874,7 +2874,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             sc = sc.endCTFE();\n             resolved = resolved.ctfeInterpret();\n             StringExp name = resolved.toStringExp();\n-            TupleExp tup = name ? null : resolved.toTupleExp();\n+            TupleExp tup = name ? null : resolved.isTupleExp();\n             if (!tup && !name)\n             {\n                 error(ns.loc, \"expected string expression for namespace name, got `%s`\", ns.identExp.toChars());\n@@ -4621,7 +4621,8 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         buildOpAssign(sd, sc2);\n         buildOpEquals(sd, sc2);\n \n-        if (global.params.useTypeInfo && Type.dtypeinfo)  // these functions are used for TypeInfo\n+        if (!(sc2.flags & SCOPE.Cfile) &&\n+            global.params.useTypeInfo && Type.dtypeinfo)  // these functions are used for TypeInfo\n         {\n             sd.xeq = buildXopEquals(sd, sc2);\n             sd.xcmp = buildXopCmp(sd, sc2);\n@@ -5023,6 +5024,10 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                     cldec.com = true;\n                 if (cldec.baseClass.isCPPclass())\n                     cldec.classKind = ClassKind.cpp;\n+                if (cldec.classKind != cldec.baseClass.classKind)\n+                    cldec.error(\"with %s linkage cannot inherit from class `%s` with %s linkage\",\n+                        cldec.classKind.toChars(), cldec.baseClass.toChars(), cldec.baseClass.classKind.toChars());\n+\n                 if (cldec.baseClass.stack)\n                     cldec.stack = true;\n                 cldec.enclosing = cldec.baseClass.enclosing;"}, {"sha": "62e86a1163c68d67ce804d40a440f0047df9cfb7", "filename": "gcc/d/dmd/errors.d", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Ferrors.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Ferrors.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ferrors.d?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -434,8 +434,20 @@ else\n     pragma(printf) extern (C++) void vdeprecationSupplemental(const ref Loc loc, const(char)* format, va_list ap);\n \n /**\n- * Call this after printing out fatal error messages to clean up and exit\n- * the compiler.\n+ * The type of the fatal error handler\n+ * Returns: true if error handling is done, false to do exit(EXIT_FAILURE)\n+ */\n+alias FatalErrorHandler = bool delegate();\n+\n+/**\n+ * The fatal error handler.\n+ * If non-null it will be called for every fatal() call issued by the compiler.\n+ */\n+__gshared FatalErrorHandler fatalErrorHandler;\n+\n+/**\n+ * Call this after printing out fatal error messages to clean up and exit the\n+ * compiler. You can also set a fatalErrorHandler to override this behaviour.\n  */\n extern (C++) void fatal();\n "}, {"sha": "44c3757248bedf97cf696b135e573d91a44b6c93", "filename": "gcc/d/dmd/escape.d", "status": "modified", "additions": 41, "deletions": 20, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Fescape.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Fescape.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fescape.d?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -316,24 +316,27 @@ bool checkParamArgumentEscape(Scope* sc, FuncDeclaration fdc, Parameter par, Exp\n      */\n     void unsafeAssign(VarDeclaration v, const char* desc)\n     {\n-        if (global.params.useDIP1000 == FeatureState.enabled && sc.func.setUnsafe())\n+        if (setUnsafeDIP1000(sc.func))\n         {\n             if (!gag)\n             {\n                 if (assertmsg)\n                 {\n-                    error(arg.loc, \"%s `%s` assigned to non-scope parameter calling `assert()`\",\n+                    previewErrorFunc(sc.isDeprecated(), global.params.useDIP1000)\n+                                    (arg.loc, \"%s `%s` assigned to non-scope parameter calling `assert()`\",\n                         desc, v.toChars());\n                 }\n                 else\n                 {\n-                    error(arg.loc, \"%s `%s` assigned to non-scope parameter `%s` calling %s\",\n+                    previewErrorFunc(sc.isDeprecated(), global.params.useDIP1000)\n+                                    (arg.loc, \"%s `%s` assigned to non-scope parameter `%s` calling %s\",\n                         desc, v.toChars(),\n                         par ? par.toChars() : \"this\",\n                         fdc ? fdc.toPrettyChars() : \"indirectly\");\n                 }\n             }\n-            result = true;\n+            if (global.params.useDIP1000 == FeatureState.enabled)\n+                result = true;\n         }\n     }\n \n@@ -774,20 +777,26 @@ bool checkAssignEscape(Scope* sc, Expression e, bool gag, bool byRef)\n         if (v.isDataseg())\n             continue;\n \n-        if (global.params.useDIP1000 == FeatureState.enabled)\n+        if (global.params.useDIP1000 != FeatureState.disabled)\n         {\n             if (va && va.isScope() && !v.isReference())\n             {\n                 if (!(va.storage_class & STC.return_))\n                 {\n                     va.doNotInferReturn = true;\n                 }\n-                else if (fd.setUnsafe())\n+                else if (setUnsafeDIP1000(fd))\n                 {\n                     if (!gag)\n-                        error(ae.loc, \"address of local variable `%s` assigned to return scope `%s`\", v.toChars(), va.toChars());\n-                    result = true;\n-                    continue;\n+                        previewErrorFunc(sc.isDeprecated(), global.params.useDIP1000)\n+                            (ae.loc, \"address of local variable `%s` assigned to return scope `%s`\", v.toChars(), va.toChars());\n+\n+\n+                    if (global.params.useDIP1000 == FeatureState.enabled)\n+                    {\n+                        result = true;\n+                        continue;\n+                    }\n                 }\n             }\n         }\n@@ -976,12 +985,11 @@ bool checkThrowEscape(Scope* sc, Expression e, bool gag)\n         if (v.isScope() && !v.iscatchvar)       // special case: allow catch var to be rethrown\n                                                 // despite being `scope`\n         {\n+            if (!gag)\n+                previewErrorFunc(sc.isDeprecated(), global.params.useDIP1000)\n+                                (e.loc, \"scope variable `%s` may not be thrown\", v.toChars());\n             if (global.params.useDIP1000 == FeatureState.enabled) // https://issues.dlang.org/show_bug.cgi?id=17029\n-            {\n-                if (!gag)\n-                    error(e.loc, \"scope variable `%s` may not be thrown\", v.toChars());\n                 result = true;\n-            }\n             continue;\n         }\n         else\n@@ -1042,13 +1050,16 @@ bool checkNewEscape(Scope* sc, Expression e, bool gag)\n                  */\n                 !(p.parent == sc.func))\n             {\n-                if (global.params.useDIP1000 == FeatureState.enabled   // https://issues.dlang.org/show_bug.cgi?id=17029\n-                    && sc.func.setUnsafe())     // https://issues.dlang.org/show_bug.cgi?id=20868\n+                if (setUnsafeDIP1000(sc.func))     // https://issues.dlang.org/show_bug.cgi?id=20868\n                 {\n+                    // Only look for errors if in module listed on command line\n                     if (!gag)\n-                        error(e.loc, \"scope variable `%s` may not be copied into allocated memory\", v.toChars());\n-                    result = true;\n+                        previewErrorFunc(sc.isDeprecated(), global.params.useDIP1000)\n+                                        (e.loc, \"scope variable `%s` may not be copied into allocated memory\", v.toChars());\n+                    if (global.params.useDIP1000 == FeatureState.enabled)\n+                        result = true;\n                 }\n+\n                 continue;\n             }\n         }\n@@ -1258,11 +1269,13 @@ private bool checkReturnEscapeImpl(Scope* sc, Expression e, bool refs, bool gag)\n                )\n             {\n                 // https://issues.dlang.org/show_bug.cgi?id=17029\n-                if (global.params.useDIP1000 == FeatureState.enabled && sc.func.setUnsafe())\n+                if (setUnsafeDIP1000(sc.func))\n                 {\n                     if (!gag)\n-                        error(e.loc, \"scope variable `%s` may not be returned\", v.toChars());\n-                    result = true;\n+                        previewErrorFunc(sc.isDeprecated(), global.params.useDIP1000)\n+                                        (e.loc, \"scope variable `%s` may not be returned\", v.toChars());\n+                    if (global.params.useDIP1000 == FeatureState.enabled)\n+                        result = true;\n                 }\n                 continue;\n             }\n@@ -2341,3 +2354,11 @@ private void addMaybe(VarDeclaration va, VarDeclaration v)\n         va.maybes = new VarDeclarations();\n     va.maybes.push(v);\n }\n+\n+\n+private bool setUnsafeDIP1000(FuncDeclaration f)\n+{\n+    return global.params.useDIP1000 == FeatureState.enabled\n+        ? f.setUnsafe()\n+        : f.isSafeBypassingInference();\n+}"}, {"sha": "107e85b07935d5b1a18a37ce6a95bb8505152426", "filename": "gcc/d/dmd/expression.d", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Fexpression.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Fexpression.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.d?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -967,11 +967,6 @@ extern (C++) abstract class Expression : ASTNode\n         return null;\n     }\n \n-    TupleExp toTupleExp()\n-    {\n-        return null;\n-    }\n-\n     /***************************************\n      * Return !=0 if expression is an lvalue.\n      */\n@@ -1746,6 +1741,7 @@ extern (C++) abstract class Expression : ASTNode\n         inout(ModuleInitExp)     isModuleInitExp() { return op == EXP.moduleString ? cast(typeof(return))this : null; }\n         inout(FuncInitExp)       isFuncInitExp() { return op == EXP.functionString ? cast(typeof(return))this : null; }\n         inout(PrettyFuncInitExp) isPrettyFuncInitExp() { return op == EXP.prettyFunction ? cast(typeof(return))this : null; }\n+        inout(ObjcClassReferenceExp) isObjcClassReferenceExp() { return op == EXP.objcClassReference ? cast(typeof(return))this : null; }\n         inout(ClassReferenceExp) isClassReferenceExp() { return op == EXP.classReference ? cast(typeof(return))this : null; }\n         inout(ThrownExceptionExp) isThrownExceptionExp() { return op == EXP.thrownException ? cast(typeof(return))this : null; }\n \n@@ -2888,11 +2884,6 @@ extern (C++) final class TupleExp : Expression\n         return new TupleExp(loc, exps);\n     }\n \n-    override TupleExp toTupleExp()\n-    {\n-        return this;\n-    }\n-\n     override TupleExp syntaxCopy()\n     {\n         return new TupleExp(loc, e0 ? e0.syntaxCopy() : null, arraySyntaxCopy(exps));"}, {"sha": "a0d63e0023d3a3c7ead4cb512dd2d525ff207838", "filename": "gcc/d/dmd/expression.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Fexpression.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Fexpression.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.h?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -103,7 +103,6 @@ class Expression : public ASTNode\n     virtual real_t toImaginary();\n     virtual complex_t toComplex();\n     virtual StringExp *toStringExp();\n-    virtual TupleExp *toTupleExp();\n     virtual bool isLvalue();\n     virtual Expression *toLvalue(Scope *sc, Expression *e);\n     virtual Expression *modifiableLvalue(Scope *sc, Expression *e);\n@@ -406,7 +405,6 @@ class TupleExp : public Expression\n     Expressions *exps;\n \n     static TupleExp *create(const Loc &loc, Expressions *exps);\n-    TupleExp *toTupleExp();\n     TupleExp *syntaxCopy();\n     bool equals(const RootObject *o) const;\n "}, {"sha": "22a1f45f4e8bb736acd1d6aa1d3a2dc139034fb4", "filename": "gcc/d/dmd/expressionsem.d", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpressionsem.d?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -2028,23 +2028,27 @@ private bool functionParameters(const ref Loc loc, Scope* sc,\n             //printf(\"type: %s\\n\", arg.type.toChars());\n             //printf(\"param: %s\\n\", p.toChars());\n \n-            if (firstArg && p.storageClass & STC.return_)\n+            const pStc = tf.parameterStorageClass(tthis, p);\n+\n+            if (firstArg && (pStc & STC.return_))\n             {\n                 /* Argument value can be assigned to firstArg.\n                  * Check arg to see if it matters.\n                  */\n                 if (global.params.useDIP1000 == FeatureState.enabled)\n                     err |= checkParamArgumentReturn(sc, firstArg, arg, p, false);\n             }\n-            else if (tf.parameterEscapes(tthis, p))\n+            // Allow 'lazy' to imply 'scope' - lazy parameters can be passed along\n+            // as lazy parameters to the next function, but that isn't escaping.\n+            else if (!(pStc & (STC.scope_ | STC.lazy_)))\n             {\n                 /* Argument value can escape from the called function.\n                  * Check arg to see if it matters.\n                  */\n                 if (global.params.useDIP1000 == FeatureState.enabled)\n                     err |= checkParamArgumentEscape(sc, fd, p, arg, false, false);\n             }\n-            else if (!(p.storageClass & STC.return_))\n+            else if (!(pStc & STC.return_))\n             {\n                 /* Argument value cannot escape from the called function.\n                  */\n@@ -3229,7 +3233,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         }\n         Type t = cle.type.typeSemantic(cle.loc, sc);\n         auto init = initializerSemantic(cle.initializer, sc, t, INITnointerpret);\n-        auto e = initializerToExpression(init, t);\n+        auto e = initializerToExpression(init, t, (sc.flags & SCOPE.Cfile) != 0);\n         if (!e)\n         {\n             error(cle.loc, \"cannot convert initializer `%s` to expression\", init.toChars());\n@@ -12195,7 +12199,7 @@ Expression semanticX(DotIdExp exp, Scope* sc)\n     if (Expression ex = unaSemantic(exp, sc))\n         return ex;\n \n-    if (exp.ident == Id._mangleof)\n+    if (!(sc.flags & SCOPE.Cfile) && exp.ident == Id._mangleof)\n     {\n         // symbol.mangleof\n \n@@ -12304,6 +12308,8 @@ Expression semanticY(DotIdExp exp, Scope* sc, int flag)\n \n     //{ static int z; fflush(stdout); if (++z == 10) *(char*)0=0; }\n \n+    const cfile = (sc.flags & SCOPE.Cfile) != 0;\n+\n     /* Special case: rewrite this.id and super.id\n      * to be classtype.id and baseclasstype.id\n      * if we have no this pointer.\n@@ -12555,7 +12561,16 @@ Expression semanticY(DotIdExp exp, Scope* sc, int flag)\n             exp.error(\"undefined identifier `%s` in %s `%s`\", exp.ident.toChars(), ie.sds.kind(), ie.sds.toPrettyChars());\n         return ErrorExp.get();\n     }\n-    else if (t1b.ty == Tpointer && exp.e1.type.ty != Tenum && exp.ident != Id._init && exp.ident != Id.__sizeof && exp.ident != Id.__xalignof && exp.ident != Id.offsetof && exp.ident != Id._mangleof && exp.ident != Id.stringof)\n+    else if (t1b.ty == Tpointer && exp.e1.type.ty != Tenum &&\n+             !(\n+               exp.ident == Id.__sizeof ||\n+               exp.ident == Id.__xalignof ||\n+               !cfile &&\n+                (exp.ident == Id._mangleof ||\n+                 exp.ident == Id.offsetof ||\n+                 exp.ident == Id._init ||\n+                 exp.ident == Id.stringof)\n+              ))\n     {\n         Type t1bn = t1b.nextOf();\n         if (flag)\n@@ -12590,7 +12605,7 @@ Expression semanticY(DotIdExp exp, Scope* sc, int flag)\n         Expression e = new IntegerExp(exp.loc, actualAlignment, Type.tsize_t);\n         return e;\n     }\n-    else if (sc.flags & SCOPE.Cfile && exp.ident == Id.__sizeof && exp.e1.isStringExp())\n+    else if (cfile && exp.ident == Id.__sizeof && exp.e1.isStringExp())\n     {\n         // Sizeof string literal includes the terminating 0\n         auto se = exp.e1.isStringExp();"}, {"sha": "c84a9f69ffa4615e779bd4a9e0b5dc24df6977f3", "filename": "gcc/d/dmd/initsem.d", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Finitsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Finitsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Finitsem.d?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -695,7 +695,7 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n                 assert(sc);\n                 auto tm = vd.type.addMod(ts.mod);\n                 auto iz = di.initializer.initializerSemantic(sc, tm, needInterpret);\n-                auto ex = iz.initializerToExpression();\n+                auto ex = iz.initializerToExpression(null, true);\n                 if (ex.op == EXP.error)\n                 {\n                     errors = true;\n@@ -1100,6 +1100,8 @@ Initializer inferType(Initializer init, Scope* sc)\n  */\n extern (C++) Expression initializerToExpression(Initializer init, Type itype = null, const bool isCfile = false)\n {\n+    //printf(\"initializerToExpression() isCfile: %d\\n\", isCfile);\n+\n     Expression visitVoid(VoidInitializer)\n     {\n         return null;\n@@ -1197,7 +1199,7 @@ extern (C++) Expression initializerToExpression(Initializer init, Type itype = n\n             assert(j < edim);\n             if (Initializer iz = init.value[i])\n             {\n-                if (Expression ex = iz.initializerToExpression())\n+                if (Expression ex = iz.initializerToExpression(null, isCfile))\n                 {\n                     (*elements)[j] = ex;\n                     ++j;\n@@ -1285,7 +1287,7 @@ extern (C++) Expression initializerToExpression(Initializer init, Type itype = n\n \n     Expression visitC(CInitializer i)\n     {\n-        //printf(\"CInitializer.initializerToExpression()\\n\");\n+        //printf(\"CInitializer.initializerToExpression(null, true)\\n\");\n         return null;\n     }\n "}, {"sha": "5945da32259dfdc3715eaa8da0411eb18c97edb7", "filename": "gcc/d/dmd/lexer.d", "status": "modified", "additions": 37, "deletions": 18, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Flexer.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Flexer.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Flexer.d?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -1236,28 +1236,47 @@ class Lexer\n             {\n                 uint v = 0;\n                 int n = 0;\n-                while (1)\n+                if (Ccompile && ndigits == 2)\n                 {\n-                    if (isdigit(cast(char)c))\n-                        c -= '0';\n-                    else if (islower(c))\n-                        c -= 'a' - 10;\n-                    else\n-                        c -= 'A' - 10;\n-                    v = v * 16 + c;\n-                    c = *++p;\n-                    if (++n == ndigits)\n-                        break;\n-                    if (!ishex(cast(char)c))\n+                    /* C11 6.4.4.4-7 one to infinity hex digits\n+                     */\n+                    do\n                     {\n-                        .error(loc, \"escape hex sequence has %d hex digits instead of %d\", n, ndigits);\n-                        break;\n-                    }\n+                        if (isdigit(cast(char)c))\n+                            c -= '0';\n+                        else if (islower(c))\n+                            c -= 'a' - 10;\n+                        else\n+                            c -= 'A' - 10;\n+                        v = v * 16 + c;\n+                        c = *++p;\n+                    } while (ishex(cast(char)c));\n                 }\n-                if (ndigits != 2 && !utf_isValidDchar(v))\n+                else\n                 {\n-                    .error(loc, \"invalid UTF character \\\\U%08x\", v);\n-                    v = '?'; // recover with valid UTF character\n+                    while (1)\n+                    {\n+                        if (isdigit(cast(char)c))\n+                            c -= '0';\n+                        else if (islower(c))\n+                            c -= 'a' - 10;\n+                        else\n+                            c -= 'A' - 10;\n+                        v = v * 16 + c;\n+                        c = *++p;\n+                        if (++n == ndigits)\n+                            break;\n+                        if (!ishex(cast(char)c))\n+                        {\n+                            .error(loc, \"escape hex sequence has %d hex digits instead of %d\", n, ndigits);\n+                            break;\n+                        }\n+                    }\n+                    if (ndigits != 2 && !utf_isValidDchar(v))\n+                    {\n+                        .error(loc, \"invalid UTF character \\\\U%08x\", v);\n+                        v = '?'; // recover with valid UTF character\n+                    }\n                 }\n                 c = v;\n             }"}, {"sha": "13df0d71f3f9ce7ce0f74e26789fa745f72df107", "filename": "gcc/d/dmd/mtype.d", "status": "modified", "additions": 35, "deletions": 57, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Fmtype.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Fmtype.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.d?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -4360,29 +4360,6 @@ extern (C++) final class TypeFunction : TypeNext\n         return linkage == LINK.d && parameterList.varargs == VarArg.variadic;\n     }\n \n-    /***************************\n-     * Examine function signature for parameter p and see if\n-     * the value of p can 'escape' the scope of the function.\n-     * This is useful to minimize the needed annotations for the parameters.\n-     * Params:\n-     *  tthis = type of `this` parameter, null if none\n-     *  p = parameter to this function\n-     * Returns:\n-     *  true if escapes via assignment to global or through a parameter\n-     */\n-    bool parameterEscapes(Type tthis, Parameter p)\n-    {\n-        /* Scope parameters do not escape.\n-         * Allow 'lazy' to imply 'scope' -\n-         * lazy parameters can be passed along\n-         * as lazy parameters to the next function, but that isn't\n-         * escaping.\n-         */\n-        if (parameterStorageClass(tthis, p) & (STC.scope_ | STC.lazy_))\n-            return false;\n-        return true;\n-    }\n-\n     /************************************\n      * Take the specified storage class for p,\n      * and use the function signature to infer whether\n@@ -4410,7 +4387,7 @@ extern (C++) final class TypeFunction : TypeNext\n \n         /* If haven't inferred the return type yet, can't infer storage classes\n          */\n-        if (!nextOf())\n+        if (!nextOf() || !isnothrow())\n             return stc;\n \n         purityLevel();\n@@ -4461,37 +4438,12 @@ extern (C++) final class TypeFunction : TypeNext\n             }\n         }\n \n-        /* Inferring STC.return_ here has false positives\n-         * for pure functions, producing spurious error messages\n-         * about escaping references.\n-         * Give up on it for now.\n-         */\n-        version (none)\n-        {\n-            stc |= STC.scope_;\n-\n-            Type tret = nextOf().toBasetype();\n-            if (isref || tret.hasPointers())\n-            {\n-                /* The result has references, so p could be escaping\n-                 * that way.\n-                 */\n-                stc |= STC.return_;\n-            }\n-        }\n+        // Check escaping through return value\n+        Type tret = nextOf().toBasetype();\n+        if (isref || tret.hasPointers())\n+            return stc | STC.scope_ | STC.return_ | STC.returnScope;\n         else\n-        {\n-            // Check escaping through return value\n-            Type tret = nextOf().toBasetype();\n-            if (isref || tret.hasPointers() || !isnothrow())\n-            {\n-                return stc;\n-            }\n-\n-            stc |= STC.scope_;\n-        }\n-\n-        return stc;\n+            return stc | STC.scope_;\n     }\n \n     override Type addStorageClass(StorageClass stc)\n@@ -4791,14 +4743,40 @@ extern (C++) final class TypeFunction : TypeNext\n                                 m = MATCH.exact;\n                             else\n                             {\n-                                m = MATCH.nomatch;\n                                 if (pMessage)\n                                 {\n+                                    /* https://issues.dlang.org/show_bug.cgi?id=22202\n+                                     *\n+                                     * If a function was deduced by semantic on the CallExp,\n+                                     * it means that resolveFuncCall completed succesfully.\n+                                     * Therefore, there exists a callable copy constructor,\n+                                     * however, it cannot be called because scope constraints\n+                                     * such as purity, safety or nogc.\n+                                     */\n                                     OutBuffer buf;\n-                                    buf.printf(\"`struct %s` does not define a copy constructor for `%s` to `%s` copies\",\n-                                           argStruct.toChars(), targ.toChars(), tprm.toChars());\n+                                    auto callExp = e.isCallExp();\n+                                    if (auto f = callExp.f)\n+                                    {\n+                                        char[] s;\n+                                        if (!f.isPure && sc.func.setImpure())\n+                                            s ~= \"pure \";\n+                                        if (!f.isSafe() && !f.isTrusted() && sc.func.setUnsafe())\n+                                            s ~= \"@safe \";\n+                                        if (!f.isNogc && sc.func.setGC())\n+                                            s ~= \"nogc \";\n+                                        s[$-1] = '\\0';\n+                                        buf.printf(\"`%s` copy constructor cannot be called from a `%s` context\", f.type.toChars(), s.ptr);\n+\n+                                    }\n+                                    else\n+                                    {\n+                                        buf.printf(\"`struct %s` does not define a copy constructor for `%s` to `%s` copies\",\n+                                               argStruct.toChars(), targ.toChars(), tprm.toChars());\n+                                    }\n+\n                                     *pMessage = buf.extractChars();\n                                 }\n+                                m = MATCH.nomatch;\n                                 goto Nomatch;\n                             }\n                         }"}, {"sha": "6ba47dfa34e9a2f9b2a137166470a5620a5f271c", "filename": "gcc/d/dmd/mtype.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Fmtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Fmtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.h?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -109,6 +109,7 @@ enum class TY : uint8_t\n  */\n enum MODFlags\n {\n+    MODnone      = 0, // default (mutable)\n     MODconst     = 1, // type is const\n     MODimmutable = 4, // type is immutable\n     MODshared    = 2, // type is shared\n@@ -608,7 +609,6 @@ class TypeFunction : public TypeNext\n     void purityLevel();\n     bool hasLazyParameters();\n     bool isDstyleVariadic() const;\n-    bool parameterEscapes(Parameter *p);\n     StorageClass parameterStorageClass(Parameter *p);\n     Type *addStorageClass(StorageClass stc);\n "}, {"sha": "3cc36b49e0194cf5f10754f889fe33adcf98cb42", "filename": "gcc/d/dmd/optimize.d", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Foptimize.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Foptimize.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Foptimize.d?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -593,7 +593,7 @@ Expression Expression_optimize(Expression e, int result, bool keepLvalue)\n                     return;\n                 }\n             }\n-            // Convert &((a.b)[n]) to (&a.b)+n\n+            // Convert &((a.b)[index]) to (&a.b)+index*elementsize\n             else if (ae.e2.isIntegerExp() && ae.e1.isDotVarExp())\n             {\n                 sinteger_t index = ae.e2.toInteger();\n@@ -614,9 +614,18 @@ Expression Expression_optimize(Expression e, int result, bool keepLvalue)\n                         }\n                     }\n \n+                    import core.checkedint : mulu;\n+                    bool overflow;\n+                    const offset = mulu(index, ts.nextOf().size(e.loc), overflow); // index*elementsize\n+                    if (overflow)\n+                    {\n+                        e.error(\"array offset overflow\");\n+                        return error();\n+                    }\n+\n                     auto pe = new AddrExp(e.loc, ve);\n                     pe.type = e.type;\n-                    ret = new AddExp(e.loc, pe, ae.e2);\n+                    ret = new AddExp(e.loc, pe, new IntegerExp(e.loc, offset, Type.tsize_t));\n                     ret.type = e.type;\n                     return;\n                 }"}, {"sha": "4b9c0f2119f5b6e90f7b9b3a1fc89ab2d086c7bf", "filename": "gcc/d/dmd/parse.d", "status": "modified", "additions": 61, "deletions": 37, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Fparse.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Fparse.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fparse.d?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -987,23 +987,9 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n                 nextToken();\n                 if (token.value == TOK.assign)\n                 {\n-                    nextToken();\n-                    if (token.value == TOK.identifier)\n-                        s = new AST.DebugSymbol(token.loc, token.ident);\n-                    else if (token.value == TOK.int32Literal || token.value == TOK.int64Literal)\n-                        s = new AST.DebugSymbol(token.loc, cast(uint)token.unsvalue);\n-                    else\n-                    {\n-                        error(\"identifier or integer expected, not `%s`\", token.toChars());\n-                        s = null;\n-                    }\n-                    nextToken();\n-                    if (token.value != TOK.semicolon)\n-                        error(\"semicolon expected\");\n-                    nextToken();\n+                    s = parseDebugSpecification();\n                     break;\n                 }\n-\n                 condition = parseDebugCondition();\n                 goto Lcondition;\n \n@@ -1012,20 +998,7 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n                 nextToken();\n                 if (token.value == TOK.assign)\n                 {\n-                    nextToken();\n-                    if (token.value == TOK.identifier)\n-                        s = new AST.VersionSymbol(token.loc, token.ident);\n-                    else if (token.value == TOK.int32Literal || token.value == TOK.int64Literal)\n-                        s = new AST.VersionSymbol(token.loc, cast(uint)token.unsvalue);\n-                    else\n-                    {\n-                        error(\"identifier or integer expected, not `%s`\", token.toChars());\n-                        s = null;\n-                    }\n-                    nextToken();\n-                    if (token.value != TOK.semicolon)\n-                        error(\"semicolon expected\");\n-                    nextToken();\n+                    s = parseVersionSpecification();\n                     break;\n                 }\n                 condition = parseVersionCondition();\n@@ -2197,6 +2170,26 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n         return qualified;\n     }\n \n+    private AST.DebugSymbol parseDebugSpecification()\n+    {\n+        AST.DebugSymbol s;\n+        nextToken();\n+        if (token.value == TOK.identifier)\n+            s = new AST.DebugSymbol(token.loc, token.ident);\n+        else if (token.value == TOK.int32Literal || token.value == TOK.int64Literal)\n+            s = new AST.DebugSymbol(token.loc, cast(uint)token.unsvalue);\n+        else\n+        {\n+            error(\"identifier or integer expected, not `%s`\", token.toChars());\n+            s = null;\n+        }\n+        nextToken();\n+        if (token.value != TOK.semicolon)\n+            error(\"semicolon expected\");\n+        nextToken();\n+        return s;\n+    }\n+\n     /**************************************\n      * Parse a debug conditional\n      */\n@@ -2223,6 +2216,29 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n         return new AST.DebugCondition(loc, mod, level, id);\n     }\n \n+    /**************************************\n+     * Parse a version specification\n+     */\n+    private AST.VersionSymbol parseVersionSpecification()\n+    {\n+        AST.VersionSymbol s;\n+        nextToken();\n+        if (token.value == TOK.identifier)\n+            s = new AST.VersionSymbol(token.loc, token.ident);\n+        else if (token.value == TOK.int32Literal || token.value == TOK.int64Literal)\n+            s = new AST.VersionSymbol(token.loc, cast(uint)token.unsvalue);\n+        else\n+        {\n+            error(\"identifier or integer expected, not `%s`\", token.toChars());\n+            s = null;\n+        }\n+        nextToken();\n+        if (token.value != TOK.semicolon)\n+            error(\"semicolon expected\");\n+        nextToken();\n+        return s;\n+    }\n+\n     /**************************************\n      * Parse a version conditional\n      */\n@@ -6053,10 +6069,14 @@ LagainStc:\n             nextToken();\n             if (token.value == TOK.assign)\n             {\n-                error(\"debug conditions can only be declared at module scope\");\n-                nextToken();\n-                nextToken();\n-                goto Lerror;\n+                if (auto ds = parseDebugSpecification())\n+                {\n+                    if (ds.ident)\n+                        ds.error(\"declaration must be at module level\");\n+                    else\n+                        ds.error(\"level declaration must be at module level\");\n+                }\n+                break;\n             }\n             cond = parseDebugCondition();\n             goto Lcondition;\n@@ -6065,10 +6085,14 @@ LagainStc:\n             nextToken();\n             if (token.value == TOK.assign)\n             {\n-                error(\"version conditions can only be declared at module scope\");\n-                nextToken();\n-                nextToken();\n-                goto Lerror;\n+                if (auto vs = parseVersionSpecification())\n+                {\n+                    if (vs.ident)\n+                        vs.error(\"declaration must be at module level\");\n+                    else\n+                        vs.error(\"level declaration must be at module level\");\n+                }\n+                break;\n             }\n             cond = parseVersionCondition();\n             goto Lcondition;"}, {"sha": "7171324900906836ceaaac7c399426938c8307e1", "filename": "gcc/d/dmd/statement.d", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Fstatement.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Fstatement.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatement.d?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -315,6 +315,14 @@ extern (C++) abstract class Statement : ASTNode\n             override void visit(ImportStatement s)\n             {\n             }\n+\n+            override void visit(CaseStatement s)\n+            {\n+            }\n+\n+            override void visit(DefaultStatement s)\n+            {\n+            }\n         }\n \n         scope HasCode hc = new HasCode();"}, {"sha": "0acad6ae14a57f4652a649a3fcf1d560e7ad234c", "filename": "gcc/d/dmd/transitivevisitor.d", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Ftransitivevisitor.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Ftransitivevisitor.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftransitivevisitor.d?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -17,7 +17,9 @@ import core.stdc.stdio;\n extern(C++) class ParseTimeTransitiveVisitor(AST) : PermissiveVisitor!AST\n {\n     alias visit = PermissiveVisitor!AST.visit;\n-    mixin ParseVisitMethods!AST;\n+\n+    mixin ParseVisitMethods!AST __methods;\n+    alias visit = __methods.visit;\n }\n \n /* This mixin implements the AST traversal logic for parse time AST nodes. The same code"}, {"sha": "f63b17752edd932ebdc0e2fcb19116a6ff639acc", "filename": "gcc/d/dmd/typesem.d", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Ftypesem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Ftypesem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftypesem.d?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -1843,7 +1843,7 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n                 mtype.sym = e.isScopeExp().sds;\n                 break;\n             case EXP.tuple:\n-                TupleExp te = e.toTupleExp();\n+                TupleExp te = e.isTupleExp();\n                 Objects* elems = new Objects(te.exps.dim);\n                 foreach (i; 0 .. elems.dim)\n                 {\n@@ -2306,7 +2306,8 @@ extern (C++) Type merge(Type type)\n         case Tident:\n         case Tinstance:\n         case Tmixin:\n-            return type;\n+        case Ttag:\n+            return type;        // don't merge placeholder types\n \n         case Tsarray:\n             // prevents generating the mangle if the array dim is not yet known\n@@ -3904,7 +3905,7 @@ Expression dotExp(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n         assert(e.op != EXP.dot);\n \n         // https://issues.dlang.org/show_bug.cgi?id=14010\n-        if (ident == Id._mangleof)\n+        if (!(sc.flags & SCOPE.Cfile) && ident == Id._mangleof)\n         {\n             return mt.getProperty(sc, e.loc, ident, flag & 1);\n         }\n@@ -4656,7 +4657,7 @@ extern (C++) Expression defaultInit(Type mt, const ref Loc loc, const bool isCfi\n     {\n         static if (LOGDEFAULTINIT)\n         {\n-            printf(\"TypeBasic::defaultInit() '%s'\\n\", mt.toChars());\n+            printf(\"TypeBasic::defaultInit() '%s' isCfile: %d\\n\", mt.toChars(), isCfile);\n         }\n         dinteger_t value = 0;\n \n@@ -4714,7 +4715,7 @@ extern (C++) Expression defaultInit(Type mt, const ref Loc loc, const bool isCfi\n     {\n         static if (LOGDEFAULTINIT)\n         {\n-            printf(\"TypeSArray::defaultInit() '%s'\\n\", mt.toChars());\n+            printf(\"TypeSArray::defaultInit() '%s' isCfile %d\\n\", mt.toChars(), isCfile);\n         }\n         if (mt.next.ty == Tvoid)\n             return mt.tuns8.defaultInit(loc, isCfile);"}, {"sha": "7f3fb64842d634f0bc6f96d4b472287845a345b7", "filename": "gcc/d/dmd/utils.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Futils.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Fdmd%2Futils.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Futils.d?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -84,7 +84,7 @@ extern (D) void writeFile(Loc loc, const(char)[] filename, const void[] data)\n     ensurePathToNameExists(Loc.initial, filename);\n     if (!File.update(filename, data))\n     {\n-        error(loc, \"Error writing file '%*.s'\", cast(int) filename.length, filename.ptr);\n+        error(loc, \"Error writing file '%.*s'\", cast(int) filename.length, filename.ptr);\n         fatal();\n     }\n }"}, {"sha": "b4b81523c14f3856daf16fa3db195a9433b83355", "filename": "gcc/d/lang.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Fd%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Flang.opt?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -396,6 +396,10 @@ frevert=all\n D RejectNegative\n Turn off all revertable D language features.\n \n+frevert=dip1000\n+D RejectNegative\n+Revert DIP1000: Scoped pointers.\n+\n frevert=dip25\n D RejectNegative\n Revert DIP25: Sealed references."}, {"sha": "72dcc6b5ee328dd2afbfa1ef36d3711e7e521a68", "filename": "gcc/testsuite/gdc.test/compilable/betterCarray.d", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2FbetterCarray.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2FbetterCarray.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2FbetterCarray.d?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -26,3 +26,10 @@ void issue19234()\n     A[10] b;\n     b[] = a[];\n }\n+\n+/**********************************************/\n+// https://issues.dlang.org/show_bug.cgi?id=22922\n+void issue22922()\n+{\n+    int[] x = [];\n+}"}, {"sha": "43f5629a3c7d9e26f2b5d719198aa5ff905f63d5", "filename": "gcc/testsuite/gdc.test/compilable/test18216.d", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest18216.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest18216.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest18216.d?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -0,0 +1,40 @@\n+// https://issues.dlang.org/show_bug.cgi?id=18216\n+\n+struct Node\n+{\n+    mixin Type!();\n+    Pointer left;\n+}\n+\n+mixin template Type()\n+{\n+    alias Base = typeof(this);\n+\n+    static struct Proxy\n+    {\n+        struct Node\n+        {\n+            Base m_payload;\n+        }\n+        static immutable default_value = Base.init; // just remove this will work\n+    }\n+\n+    alias pNode = shared(Proxy.Node)*;\n+\n+    static struct Pointer\n+    {\n+        Base*   _ptr;\n+        auto ptr()\n+        {\n+            return cast(pNode) _ptr;\n+        }\n+\n+        void opAssign(ref Pointer other) {} // just remove this will work\n+\n+        alias getThis this; // just remove this will work\n+        ref auto getThis() return\n+        {\n+            return ptr.m_payload;\n+        }\n+    }\n+}"}, {"sha": "c2abc8379563faeb36813e3efb88edbc0fecdf7e", "filename": "gcc/testsuite/gdc.test/compilable/test22635.d", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22635.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22635.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22635.d?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -0,0 +1,13 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22635\n+// opCast prevent calling destructor for const this\n+\n+struct Foo\n+{\n+    bool opCast(T : bool)() const { assert(0); }\n+    ~this() {}\n+}\n+\n+struct Bar\n+{\n+    const Foo foo;\n+}"}, {"sha": "279d62a54968fba1c528fe613df2450634ab3d34", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag11198.d", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag11198.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag11198.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag11198.d?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -1,13 +1,21 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/diag11198.d(11): Error: version conditions can only be declared at module scope\n-fail_compilation/diag11198.d(12): Error: debug conditions can only be declared at module scope\n+fail_compilation/diag11198.d(15): Error: version `blah` declaration must be at module level\n+fail_compilation/diag11198.d(16): Error: debug `blah` declaration must be at module level\n+fail_compilation/diag11198.d(17): Error: version `1` level declaration must be at module level\n+fail_compilation/diag11198.d(18): Error: debug `2` level declaration must be at module level\n+fail_compilation/diag11198.d(19): Error: identifier or integer expected, not `\"\"`\n+fail_compilation/diag11198.d(20): Error: identifier or integer expected, not `\"\"`\n ---\n */\n \n void main()\n {\n     version = blah;\n     debug = blah;\n+    version = 1;\n+    debug = 2;\n+    version = \"\";\n+    debug = \"\";\n }"}, {"sha": "167d362487936b7a5116de7e3ec47eefaf099d77", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail22202.d", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22202.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22202.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22202.d?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -0,0 +1,22 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22202\n+\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/fail22202.d(21): Error: function `fail22202.fun(SystemCopy _param_0)` is not callable using argument types `(SystemCopy)`\n+fail_compilation/fail22202.d(21):        `inout ref inout(SystemCopy)(ref inout(SystemCopy) other)` copy constructor cannot be called from a `pure @safe nogc` context\n+---\n+*/\n+\n+struct SystemCopy\n+{\n+    this(ref inout SystemCopy other) inout {}\n+}\n+\n+void fun(SystemCopy) @safe pure @nogc {}\n+\n+void main() @safe pure @nogc\n+{\n+    SystemCopy s;\n+    fun(s);\n+}"}, {"sha": "8920586c67a8a4ff0ce1def51727d0288d30c7f3", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail23036.d", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail23036.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail23036.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail23036.d?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -0,0 +1,22 @@\n+// https://issues.dlang.org/show_bug.cgi?id=23036\n+\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/fail23036.d(12): Error: `struct S` may not define both a rvalue constructor and a copy constructor\n+fail_compilation/fail23036.d(15):        rvalue constructor defined here\n+fail_compilation/fail23036.d(14):        copy constructor defined here\n+---\n+*/\n+\n+struct S\n+{\n+    this(ref S) {}\n+    this(S, int a = 2) {}\n+}\n+\n+void main()\n+{\n+    S a;\n+    S b = a;\n+}"}, {"sha": "07c3766d4904cfa1d2c0cc12c308ca0c77fb2ca2", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail_scope.d", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail_scope.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail_scope.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail_scope.d?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -2,6 +2,13 @@\n REQUIRED_ARGS:\n TEST_OUTPUT:\n ---\n+fail_compilation/fail_scope.d(29): Deprecation: scope variable `da` may not be returned\n+fail_compilation/fail_scope.d(31): Deprecation: scope variable `o` may not be returned\n+fail_compilation/fail_scope.d(32): Deprecation: scope variable `dg` may not be returned\n+fail_compilation/fail_scope.d(34): Deprecation: scope variable `da` may not be returned\n+fail_compilation/fail_scope.d(36): Deprecation: scope variable `o` may not be returned\n+fail_compilation/fail_scope.d(37): Deprecation: scope variable `dg` may not be returned\n+fail_compilation/fail_scope.d(39): Deprecation: scope variable `p` may not be returned\n fail_compilation/fail_scope.d(44): Error: returning `cast(char[])string` escapes a reference to local variable `string`\n fail_compilation/fail_scope.d(62): Error: returning `s.bar()` escapes a reference to local variable `s`\n fail_compilation/fail_scope.d(73): Error: `fail_scope.foo8` called with argument types `(int)` matches both:\n@@ -15,26 +22,19 @@ fail_compilation/fail_scope.d(107): Deprecation: escaping reference to outer loc\n fail_compilation/fail_scope.d(126): Error: returning `s.bar()` escapes a reference to local variable `s`\n fail_compilation/fail_scope.d(136): Error: returning `foo16226(i)` escapes a reference to local variable `i`\n ---\n-//fail_compilation/fail_scope.d(30): Error: scope variable `da` may not be returned\n-//fail_compilation/fail_scope.d(32): Error: scope variable `o` may not be returned\n-//fail_compilation/fail_scope.d(33): Error: scope variable `dg` may not be returned\n-//fail_compilation/fail_scope.d(35): Error: scope variable `da` may not be returned\n-//fail_compilation/fail_scope.d(37): Error: scope variable `o` may not be returned\n-//fail_compilation/fail_scope.d(38): Error: scope variable `dg` may not be returned\n-//fail_compilation/fail_scope.d(40): Error: scope variable `p` may not be returned\n */\n \n alias int delegate() dg_t;\n \n-int[]  checkEscapeScope1(scope int[]  da) { return da; }\n-int[3] checkEscapeScope2(scope int[3] sa) { return sa; }\n-Object checkEscapeScope3(scope Object o)  { return o;  }\n-dg_t   checkEscapeScope4(scope dg_t   dg) { return dg; }\n+int[]  checkEscapeScope1(scope int[]  da) @safe { return da; }\n+int[3] checkEscapeScope2(scope int[3] sa) @safe { return sa; }\n+Object checkEscapeScope3(scope Object o)  @safe { return o;  }\n+dg_t   checkEscapeScope4(scope dg_t   dg) @safe { return dg; }\n \n-int[]  checkEscapeScope1() { scope int[]  da = [];           return da; }\n-int[3] checkEscapeScope2() { scope int[3] sa = [1,2,3];      return sa; }\n-Object checkEscapeScope3() { scope Object  o = new Object;   return o;  }   // same with fail7294.d\n-dg_t   checkEscapeScope4() { scope dg_t   dg = () => 1;      return dg; }\n+int[]  checkEscapeScope1() @safe { scope int[]  da = [];           return da; }\n+int[3] checkEscapeScope2() @safe { scope int[3] sa = [1,2,3];      return sa; }\n+Object checkEscapeScope3() @safe { scope Object  o = new Object;   return o;  }   // same with fail7294.d\n+dg_t   checkEscapeScope4() @safe { scope dg_t   dg = () => 1;      return dg; }\n \n int* test(scope int* p) @safe { return p; }\n "}, {"sha": "6d5807b641a27ba06e460c74b237d611b814f917", "filename": "gcc/testsuite/gdc.test/fail_compilation/retscope6.d", "status": "modified", "additions": 42, "deletions": 6, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fretscope6.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fretscope6.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fretscope6.d?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -201,32 +201,32 @@ void hmac(scope ubyte[] secret)\n \n /* TEST_OUTPUT:\n ---\n-fail_compilation/retscope6.d(12011): Error: reference to local variable `x` assigned to non-scope parameter `r` calling retscope6.escape_m_20150\n-fail_compilation/retscope6.d(12022): Error: reference to local variable `x` assigned to non-scope parameter `r` calling retscope6.escape_c_20150\n+fail_compilation/retscope6.d(12011): Error: returning `escape_m_20150(& x)` escapes a reference to local variable `x`\n+fail_compilation/retscope6.d(12022): Error: returning `escape_c_20150(& x)` escapes a reference to local variable `x`\n ---\n */\n \n #line 12000\n \n // https://issues.dlang.org/show_bug.cgi?id=20150\n \n-int* escape_m_20150(int* r) @safe pure\n+int* escape_m_20150(int* r) @safe pure nothrow\n {\n     return r;\n }\n \n-int* f_m_20150() @safe\n+int* f_m_20150() @safe nothrow\n {\n     int x = 42;\n     return escape_m_20150(&x);\n }\n \n-const(int)* escape_c_20150(const int* r) @safe pure\n+const(int)* escape_c_20150(const int* r) @safe pure nothrow\n {\n     return r;\n }\n \n-const(int)* f_c_20150() @safe\n+const(int)* f_c_20150() @safe nothrow\n {\n     int x = 42;\n     return escape_c_20150(&x);\n@@ -251,3 +251,39 @@ void escape_throw_20150() @safe\n     immutable(char)[4] str;\n     f_throw(str[]);\n }\n+\n+/* TEST_OUTPUT:\n+---\n+fail_compilation/retscope6.d(14019): Error: scope variable `scopePtr` assigned to non-scope parameter `x` calling retscope6.noInfer23021\n+fail_compilation/retscope6.d(14022): Error: scope variable `scopePtr` may not be returned\n+---\n+*/\n+\n+#line 14000\n+// https://issues.dlang.org/show_bug.cgi?id=23021\n+\n+ref int infer23021(ref int* x) @safe pure nothrow\n+{\n+    return *x;\n+}\n+\n+ref int noInfer23021(ref int* x, const(int)** escapeHole = null) @safe pure nothrow\n+{\n+    *escapeHole = x;\n+    return *x;\n+}\n+\n+ref int escape23021() @safe\n+{\n+    scope int* scopePtr;\n+    int* nonScopePtr = null;\n+\n+    // don't infer scope\n+    cast(void) noInfer23021(scopePtr); // error\n+\n+    // ensure we infer return scope\n+    return infer23021(scopePtr); // error\n+\n+    // ensure we do not infer return ref\n+    return infer23021(nonScopePtr); // no error\n+}"}, {"sha": "99dfe70378b99f07640145973ecb54a011f68013", "filename": "gcc/testsuite/gdc.test/fail_compilation/test22999.d", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest22999.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest22999.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest22999.d?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -0,0 +1,27 @@\n+/*\n+REQUIRED_ARGS: -de\n+TEST_OUTPUT:\n+---\n+fail_compilation/test22999.d(18): Deprecation: switch case fallthrough - use 'goto default;' if intended\n+fail_compilation/test22999.d(25): Deprecation: switch case fallthrough - use 'goto case;' if intended\n+---\n+*/\n+\n+// no switch fallthrough error with multi-valued case\n+// https://issues.dlang.org/show_bug.cgi?id=22999\n+void main()\n+{\n+    int i;\n+    switch (0)\n+    {\n+        case 0, 1: i = 20;\n+        default: assert(0);\n+    }\n+\n+    switch (0)\n+    {\n+        default:\n+        case 0, 1: i = 20;\n+        case 2, 3: i = 30;\n+    }\n+}"}, {"sha": "743789a6b52251331dc88b0e09a1c83c56aeb71d", "filename": "gcc/testsuite/gdc.test/fail_compilation/test23017.d", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest23017.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest23017.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest23017.d?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -0,0 +1,20 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/test23017.d(16): Error: class `test23017.CppChildA` with C++ linkage cannot inherit from class `DClass` with D linkage\n+---\n+*/\n+\n+// https://issues.dlang.org/show_bug.cgi?id=23017\n+// C++ class may not derive from D class\n+extern(D) class DClass {}\n+extern(C++) class CppClass\n+{\n+    void foo();\n+}\n+\n+extern(C++) class CppChildA : DClass {} // error\n+extern(C++) class CppChildB : CppClass {}\n+\n+extern(D) class DChildA : DClass {}\n+extern(D) class DChildB : CppClass {} // automatically made extern(C++)"}, {"sha": "0ca04df188dea2e780b311a1b4f64814719abfe3", "filename": "gcc/testsuite/gdc.test/runnable/testscope.d", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestscope.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestscope.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestscope.d?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -242,22 +242,6 @@ void test7435() {\n \n /********************************************/\n \n-char[] dup12()(char[] a) // although inferred pure, don't infer a is 'return'\n-{\n-    char[] res;\n-    foreach (ref e; a)\n-    {}\n-    return res;\n-}\n-\n-char[] foo12()\n-{\n-    char[10] buf;\n-    return dup12(buf);\n-}\n-\n-/********************************************/\n-\n void test7049() @safe\n {\n     int count = 0;"}, {"sha": "e08d9cdc0fdf6b08920c6bee6d73ad0d44d966bb", "filename": "libphobos/libdruntime/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/libphobos%2Flibdruntime%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/libphobos%2Flibdruntime%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMERGE?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -1,4 +1,4 @@\n-9ba9a6ae2b8f6811cb85107cb56701df04f36ac6\n+27834edb5e1613e3abd43e09880c36d9fc961938\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/druntime repository."}, {"sha": "81aa43b27d0a8991da96bcfd914afdea22d96f5f", "filename": "libphobos/libdruntime/core/exception.d", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/libphobos%2Flibdruntime%2Fcore%2Fexception.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/libphobos%2Flibdruntime%2Fcore%2Fexception.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fexception.d?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -19,29 +19,6 @@ void __switch_errorT()(string file = __FILE__, size_t line = __LINE__) @trusted\n         assert(0, \"No appropriate switch clause found\");\n }\n \n-version (D_BetterC)\n-{\n-    // When compiling with -betterC we use template functions so if they are\n-    // used the bodies are copied into the user's program so there is no need\n-    // for the D runtime during linking.\n-\n-    // In the future we might want to convert all functions in this module to\n-    // templates even for ordinary builds instead of providing them as an\n-    // extern(C) library.\n-\n-    void onOutOfMemoryError()(void* pretend_sideffect = null) @nogc nothrow pure @trusted\n-    {\n-        assert(0, \"Memory allocation failed\");\n-    }\n-    alias onOutOfMemoryErrorNoGC = onOutOfMemoryError;\n-\n-    void onInvalidMemoryOperationError()(void* pretend_sideffect = null) @nogc nothrow pure @trusted\n-    {\n-        assert(0, \"Invalid memory operation\");\n-    }\n-}\n-else:\n-\n /**\n  * Thrown on a range error.\n  */\n@@ -218,17 +195,17 @@ private void rangeMsgPut(ref char[] r, scope const(char)[] e) @nogc nothrow pure\n  */\n class AssertError : Error\n {\n-    @safe pure nothrow this( string file, size_t line )\n+    @safe pure nothrow @nogc this( string file, size_t line )\n     {\n         this(cast(Throwable)null, file, line);\n     }\n \n-    @safe pure nothrow this( Throwable next, string file = __FILE__, size_t line = __LINE__ )\n+    @safe pure nothrow @nogc this( Throwable next, string file = __FILE__, size_t line = __LINE__ )\n     {\n         this( \"Assertion failure\", file, line, next);\n     }\n \n-    @safe pure nothrow this( string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null )\n+    @safe pure nothrow @nogc this( string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null )\n     {\n         super( msg, file, line, next );\n     }\n@@ -692,26 +669,49 @@ extern (C) void onFinalizeError( TypeInfo info, Throwable e, string file = __FIL\n     throw staticError!FinalizeError(info, e, file, line);\n }\n \n-/**\n- * A callback for out of memory errors in D.  An $(LREF OutOfMemoryError) will be\n- * thrown.\n- *\n- * Throws:\n- *  $(LREF OutOfMemoryError).\n- */\n-extern (C) void onOutOfMemoryError(void* pretend_sideffect = null) @trusted pure nothrow @nogc /* dmd @@@BUG11461@@@ */\n+version (D_BetterC)\n {\n-    // NOTE: Since an out of memory condition exists, no allocation must occur\n-    //       while generating this object.\n-    throw staticError!OutOfMemoryError();\n-}\n+    // When compiling with -betterC we use template functions so if they are\n+    // used the bodies are copied into the user's program so there is no need\n+    // for the D runtime during linking.\n \n-extern (C) void onOutOfMemoryErrorNoGC() @trusted nothrow @nogc\n-{\n-    // suppress stacktrace until they are @nogc\n-    throw staticError!OutOfMemoryError(false);\n+    // In the future we might want to convert all functions in this module to\n+    // templates even for ordinary builds instead of providing them as an\n+    // extern(C) library.\n+\n+    void onOutOfMemoryError()(void* pretend_sideffect = null) @nogc nothrow pure @trusted\n+    {\n+        assert(0, \"Memory allocation failed\");\n+    }\n+    alias onOutOfMemoryErrorNoGC = onOutOfMemoryError;\n+\n+    void onInvalidMemoryOperationError()(void* pretend_sideffect = null) @nogc nothrow pure @trusted\n+    {\n+        assert(0, \"Invalid memory operation\");\n+    }\n }\n+else\n+{\n+    /**\n+     * A callback for out of memory errors in D.  An $(LREF OutOfMemoryError) will be\n+     * thrown.\n+     *\n+     * Throws:\n+     *  $(LREF OutOfMemoryError).\n+     */\n+    extern (C) void onOutOfMemoryError(void* pretend_sideffect = null) @trusted pure nothrow @nogc /* dmd @@@BUG11461@@@ */\n+    {\n+        // NOTE: Since an out of memory condition exists, no allocation must occur\n+        //       while generating this object.\n+        throw staticError!OutOfMemoryError();\n+    }\n \n+    extern (C) void onOutOfMemoryErrorNoGC() @trusted nothrow @nogc\n+    {\n+        // suppress stacktrace until they are @nogc\n+        throw staticError!OutOfMemoryError(false);\n+    }\n+}\n \n /**\n  * A callback for invalid memory operations in D.  An"}, {"sha": "e58afa2f985b785ee99fbe862e8f60d6a6f1af15", "filename": "libphobos/libdruntime/object.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/libphobos%2Flibdruntime%2Fobject.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/libphobos%2Flibdruntime%2Fobject.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fobject.d?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -2830,8 +2830,8 @@ extern (C)\n \n     private struct AA { void* impl; }\n     // size_t _aaLen(in AA aa) pure nothrow @nogc;\n-    private void* _aaGetY(AA* paa, const TypeInfo_AssociativeArray ti, const size_t valsz, const scope void* pkey) pure nothrow;\n-    private void* _aaGetX(AA* paa, const TypeInfo_AssociativeArray ti, const size_t valsz, const scope void* pkey, out bool found) pure nothrow;\n+    private void* _aaGetY(scope AA* paa, const TypeInfo_AssociativeArray ti, const size_t valsz, const scope void* pkey) pure nothrow;\n+    private void* _aaGetX(scope AA* paa, const TypeInfo_AssociativeArray ti, const size_t valsz, const scope void* pkey, out bool found) pure nothrow;\n     // inout(void)* _aaGetRvalueX(inout AA aa, in TypeInfo keyti, in size_t valsz, in void* pkey);\n     inout(void[]) _aaValues(inout AA aa, const size_t keysz, const size_t valsz, const TypeInfo tiValueArray) pure nothrow;\n     inout(void[]) _aaKeys(inout AA aa, const size_t keysz, const TypeInfo tiKeyArray) pure nothrow;"}, {"sha": "ab93f191634586e6eb2376535fa22ed09d32dde1", "filename": "libphobos/libdruntime/rt/aaA.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/libphobos%2Flibdruntime%2Frt%2FaaA.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/libphobos%2Flibdruntime%2Frt%2FaaA.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2FaaA.d?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -504,7 +504,7 @@ extern (C) size_t _aaLen(scope const AA aa) pure nothrow @nogc\n  *      If key was not in the aa, a mutable pointer to newly inserted value which\n  *      is set to all zeros\n  */\n-extern (C) void* _aaGetY(AA* paa, const TypeInfo_AssociativeArray ti,\n+extern (C) void* _aaGetY(scope AA* paa, const TypeInfo_AssociativeArray ti,\n     const size_t valsz, scope const void* pkey)\n {\n     bool found;\n@@ -525,7 +525,7 @@ extern (C) void* _aaGetY(AA* paa, const TypeInfo_AssociativeArray ti,\n  *      If key was not in the aa, a mutable pointer to newly inserted value which\n  *      is set to all zeros\n  */\n-extern (C) void* _aaGetX(AA* paa, const TypeInfo_AssociativeArray ti,\n+extern (C) void* _aaGetX(scope AA* paa, const TypeInfo_AssociativeArray ti,\n     const size_t valsz, scope const void* pkey, out bool found)\n {\n     // lazily alloc implementation"}, {"sha": "3218ace50a0d1e9d57aa77284b8418727d1912bd", "filename": "libphobos/src/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/libphobos%2Fsrc%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/libphobos%2Fsrc%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2FMERGE?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -1,4 +1,4 @@\n-c0cc5e917db105301dd1199b4b3c854626526407\n+ac296f80cda437483b743f953dc69cb1271c82df\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/phobos repository."}, {"sha": "da7a2004ff8731ec7aa215a811b091453d9943cf", "filename": "libphobos/src/Makefile.am", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/libphobos%2Fsrc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/libphobos%2Fsrc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2FMakefile.am?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -130,7 +130,7 @@ PHOBOS_DSOURCES = etc/c/curl.d etc/c/zlib.d std/algorithm/comparison.d \\\n \tstd/experimental/typecons.d std/file.d std/format/internal/floats.d \\\n \tstd/format/internal/read.d std/format/internal/write.d \\\n \tstd/format/package.d std/format/read.d std/format/spec.d \\\n-\tstd/format/write.d std/functional.d std/getopt.d \\\n+\tstd/format/write.d std/functional.d std/getopt.d std/int128.d \\\n \tstd/internal/attributes.d std/internal/cstring.d \\\n \tstd/internal/math/biguintcore.d std/internal/math/biguintnoasm.d \\\n \tstd/internal/math/errorfunction.d std/internal/math/gammafunction.d \\"}, {"sha": "6f58fee01acacb6f0d551ed8c1b2b0d5fe38c0e9", "filename": "libphobos/src/Makefile.in", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/libphobos%2Fsrc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/libphobos%2Fsrc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2FMakefile.in?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -228,6 +228,7 @@ am__dirstamp = $(am__leading_dot)dirstamp\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/format/spec.lo \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/format/write.lo \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/functional.lo std/getopt.lo \\\n+@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/int128.lo \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/internal/attributes.lo \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/internal/cstring.lo \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/internal/math/biguintcore.lo \\\n@@ -591,7 +592,7 @@ libgphobos_la_LINK = $(LIBTOOL) --tag=D $(libgphobos_la_LIBTOOLFLAGS) \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/experimental/typecons.d std/file.d std/format/internal/floats.d \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/format/internal/read.d std/format/internal/write.d \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/format/package.d std/format/read.d std/format/spec.d \\\n-@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/format/write.d std/functional.d std/getopt.d \\\n+@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/format/write.d std/functional.d std/getopt.d std/int128.d \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/internal/attributes.d std/internal/cstring.d \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/internal/math/biguintcore.d std/internal/math/biguintnoasm.d \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/internal/math/errorfunction.d std/internal/math/gammafunction.d \\\n@@ -846,6 +847,7 @@ std/format/spec.lo: std/format/$(am__dirstamp)\n std/format/write.lo: std/format/$(am__dirstamp)\n std/functional.lo: std/$(am__dirstamp)\n std/getopt.lo: std/$(am__dirstamp)\n+std/int128.lo: std/$(am__dirstamp)\n std/internal/$(am__dirstamp):\n \t@$(MKDIR_P) std/internal\n \t@: > std/internal/$(am__dirstamp)"}, {"sha": "d971dba1c7132b06199df14e2fbb3a8596633d5b", "filename": "libphobos/src/std/base64.d", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/libphobos%2Fsrc%2Fstd%2Fbase64.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/libphobos%2Fsrc%2Fstd%2Fbase64.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fbase64.d?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -63,7 +63,7 @@ import std.range.primitives : empty, front, isInputRange, isOutputRange,\n import std.traits : isArray;\n \n // Make sure module header code examples work correctly.\n-@safe unittest\n+pure @safe unittest\n {\n     ubyte[] data = [0x14, 0xfb, 0x9c, 0x03, 0xd9, 0x7e];\n \n@@ -82,7 +82,7 @@ import std.traits : isArray;\n alias Base64 = Base64Impl!('+', '/');\n \n ///\n-@safe unittest\n+pure @safe unittest\n {\n     ubyte[] data = [0x83, 0xd7, 0x30, 0x7a, 0x01, 0x3f];\n     assert(Base64.encode(data) == \"g9cwegE/\");\n@@ -98,7 +98,7 @@ alias Base64 = Base64Impl!('+', '/');\n alias Base64URL = Base64Impl!('-', '_');\n \n ///\n-@safe unittest\n+pure @safe unittest\n {\n     ubyte[] data = [0x83, 0xd7, 0x30, 0x7a, 0x01, 0x3f];\n     assert(Base64URL.encode(data) == \"g9cwegE_\");\n@@ -114,7 +114,7 @@ alias Base64URL = Base64Impl!('-', '_');\n alias Base64URLNoPadding = Base64Impl!('-', '_', Base64.NoPadding);\n \n ///\n-@safe unittest\n+pure @safe unittest\n {\n     ubyte[] data = [0x83, 0xd7, 0x30, 0x7b, 0xef];\n     assert(Base64URLNoPadding.encode(data) == \"g9cwe-8\");\n@@ -180,7 +180,7 @@ template Base64Impl(char Map62th, char Map63th, char Padding = '=')\n      * Returns:\n      *  The length of a Base64 encoding of an array of the given length.\n      */\n-    @safe\n+    @safe @nogc\n     pure nothrow size_t encodeLength(in size_t sourceLength)\n     {\n         static if (Padding == NoPadding)\n@@ -218,8 +218,8 @@ template Base64Impl(char Map62th, char Map63th, char Padding = '=')\n      *  The slice of $(D_PARAM buffer) that contains the encoded string.\n      */\n     @trusted\n-    pure char[] encode(R1, R2)(in R1 source, return scope R2 buffer) if (isArray!R1 && is(ElementType!R1 : ubyte) &&\n-                                                            is(R2 == char[]))\n+    pure char[] encode(R1, R2)(const scope R1 source, return scope R2 buffer)\n+    if (isArray!R1 && is(ElementType!R1 : ubyte) && is(R2 == char[]))\n     in\n     {\n         assert(buffer.length >= encodeLength(source.length), \"Insufficient buffer for encoding\");\n@@ -277,17 +277,17 @@ template Base64Impl(char Map62th, char Map63th, char Padding = '=')\n     }\n \n     ///\n-    @safe unittest\n+    @nogc nothrow @safe unittest\n     {\n-        ubyte[] data = [0x83, 0xd7, 0x30, 0x7a, 0x01, 0x3f];\n+        ubyte[6] data = [0x83, 0xd7, 0x30, 0x7a, 0x01, 0x3f];\n         char[32] buffer;    // much bigger than necessary\n \n         // Just to be sure...\n         auto encodedLength = Base64.encodeLength(data.length);\n         assert(buffer.length >= encodedLength);\n \n         // encode() returns a slice to the provided buffer.\n-        auto encoded = Base64.encode(data, buffer[]);\n+        auto encoded = Base64.encode(data[], buffer[]);\n         assert(encoded is buffer[0 .. encodedLength]);\n         assert(encoded == \"g9cwegE/\");\n     }"}, {"sha": "fc992f824224099e9c0d830dba2e1b652a84d1ef", "filename": "libphobos/src/std/int128.d", "status": "added", "additions": 374, "deletions": 0, "changes": 374, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/libphobos%2Fsrc%2Fstd%2Fint128.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/libphobos%2Fsrc%2Fstd%2Fint128.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fint128.d?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -0,0 +1,374 @@\n+// Written in the D programming language\n+/**\n+ * Implements a signed 128 bit integer type.\n+ *\n+    Author:     Walter Bright\n+    Copyright:  Copyright (c) 2022, D Language Foundation\n+    License:    $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0)\n+    Source:     $(PHOBOSSRC std/int128.d)\n+ */\n+module std.int128;\n+\n+private import core.int128;\n+\n+\n+/***********************************\n+ * 128 bit signed integer type.\n+ */\n+\n+public struct Int128\n+{\n+  @safe pure nothrow @nogc:\n+\n+    Cent data;          /// core.int128.Cent\n+\n+    /****************\n+     * Construct an `Int128` from a `long` value.\n+     * The upper 64 bits are formed by sign extension.\n+     * Params:\n+     *  lo = signed lower 64 bits\n+     */\n+    this(long lo)\n+    {\n+        data.lo = lo;\n+        data.hi = lo < 0 ? ~0L : 0;\n+    }\n+\n+    /****************\n+     * Construct an `Int128` from a `ulong` value.\n+     * The upper 64 bits are set to zero.\n+     * Params:\n+     *  lo = unsigned lower 64 bits\n+     */\n+    this(ulong lo)\n+    {\n+        data.lo = lo;\n+        data.hi = 0;\n+    }\n+\n+    /****************\n+     * Construct an `Int128` from a `long` value.\n+     * Params:\n+     *  hi = upper 64 bits\n+     *  lo = lower 64 bits\n+     */\n+    this(long hi, long lo)\n+    {\n+        data.hi = hi;\n+        data.lo = lo;\n+    }\n+\n+    /********************\n+     * Construct an `Int128` from a `Cent`.\n+     * Params:\n+     *  data = Cent data\n+     */\n+    this(Cent data)\n+    {\n+        this.data = data;\n+    }\n+\n+    /********************\n+     * Returns: hash value for Int128\n+     */\n+    size_t toHash() const\n+    {\n+        return cast(size_t)((data.lo & 0xFFFF_FFFF) + (data.hi & 0xFFFF_FFFF) + (data.lo >> 32) + (data.hi >> 32));\n+    }\n+\n+    /************************\n+     * Compare for equality\n+     * Params: lo = signed value to compare with\n+     * Returns: true if Int128 equals value\n+     */\n+    bool opEquals(long lo) const\n+    {\n+        return data.lo == lo && data.hi == (lo >> 63);\n+    }\n+\n+    /************************\n+     * Compare for equality\n+     * Params: lo = unsigned value to compare with\n+     * Returns: true if Int128 equals value\n+     */\n+    bool opEquals(ulong lo) const\n+    {\n+        return data.hi == 0 && data.lo == lo;\n+    }\n+\n+    /************************\n+     * Compare for equality\n+     * Params: op2 = value to compare with\n+     * Returns: true if Int128 equals value\n+     */\n+    bool opEquals(Int128 op2) const\n+    {\n+        return data.hi == op2.data.hi && data.lo == op2.data.lo;\n+    }\n+\n+    /** Support unary arithmentic operator +\n+     * Params: op = \"+\"\n+     * Returns: lvalue of result\n+     */\n+    Int128 opUnary(string op)() const\n+        if (op == \"+\")\n+    {\n+        return this;\n+    }\n+\n+    /** Support unary arithmentic operator - ~\n+     * Params: op = \"-\", \"~\"\n+     * Returns: lvalue of result\n+     */\n+    Int128 opUnary(string op)() const\n+        if (op == \"-\" || op == \"~\")\n+    {\n+        static if (op == \"-\")\n+            return Int128(neg(this.data));\n+        else static if (op == \"~\")\n+            return Int128(com(this.data));\n+    }\n+\n+    /** Support unary arithmentic operator ++ --\n+     * Params: op = \"++\", \"--\"\n+     * Returns: lvalue of result\n+     */\n+    Int128 opUnary(string op)()\n+        if (op == \"++\" || op == \"--\")\n+    {\n+        static if (op == \"++\")\n+            this.data = inc(this.data);\n+        else static if (op == \"--\")\n+            this.data = dec(this.data);\n+        else\n+            static assert(0, op);\n+        return this;\n+    }\n+\n+    /** Support casting to a bool\n+     * Params: T = bool\n+     * Returns: boolean result\n+     */\n+    bool opCast(T : bool)() const\n+    {\n+        return tst(this.data);\n+    }\n+\n+    /** Support binary arithmetic operators + - * / % & | ^ << >> >>>\n+     * Params:\n+     *   op = one of the arithmetic binary operators\n+     *   op2 = second operand\n+     * Returns: value after the operation is applied\n+     */\n+    Int128 opBinary(string op)(Int128 op2) const\n+        if (op == \"+\" || op == \"-\" ||\n+            op == \"*\" || op == \"/\" || op == \"%\" ||\n+            op == \"&\" || op == \"|\" || op == \"^\")\n+    {\n+        static if (op == \"+\")\n+            return Int128(add(this.data, op2.data));\n+        else static if (op == \"-\")\n+            return Int128(sub(this.data, op2.data));\n+        else static if (op == \"*\")\n+            return Int128(mul(this.data, op2.data));\n+        else static if (op == \"/\")\n+            return Int128(div(this.data, op2.data));\n+        else static if (op == \"%\")\n+        {\n+            Cent modulus;\n+            divmod(this.data, op2.data, modulus);\n+            return Int128(modulus);\n+        }\n+        else static if (op == \"&\")\n+            return Int128(and(this.data, op2.data));\n+        else static if (op == \"|\")\n+            return Int128(or(this.data, op2.data));\n+        else static if (op == \"^\")\n+            return Int128(xor(this.data, op2.data));\n+        else\n+            static assert(0, \"wrong op value\");\n+    }\n+\n+    /// ditto\n+    Int128 opBinary(string op)(long op2) const\n+        if (op == \"+\" || op == \"-\" ||\n+            op == \"*\" || op == \"/\" || op == \"%\" ||\n+            op == \"&\" || op == \"|\" || op == \"^\")\n+    {\n+        return mixin(\"this \" ~ op ~ \" Int128(0, op2)\");\n+    }\n+\n+    /// ditto\n+    Int128 opBinaryRight(string op)(long op2) const\n+        if (op == \"+\" || op == \"-\" ||\n+            op == \"*\" || op == \"/\" || op == \"%\" ||\n+            op == \"&\" || op == \"|\" || op == \"^\")\n+    {\n+        mixin(\"return Int128(0, op2) \" ~ op ~ \" this;\");\n+    }\n+\n+    /// ditto\n+    Int128 opBinary(string op)(long op2) const\n+        if (op == \"<<\")\n+    {\n+        return Int128(shl(this.data, cast(uint) op2));\n+    }\n+\n+    /// ditto\n+    Int128 opBinary(string op)(long op2) const\n+        if (op == \">>\")\n+    {\n+        return Int128(sar(this.data, cast(uint) op2));\n+    }\n+\n+    /// ditto\n+    Int128 opBinary(string op)(long op2) const\n+        if (op == \">>>\")\n+    {\n+        return Int128(shr(this.data, cast(uint) op2));\n+    }\n+\n+    /** arithmetic assignment operators += -= *= /= %= &= |= ^= <<= >>= >>>=\n+     * Params: op = one of +, -, etc.\n+     *   op2 = second operand\n+     * Returns: lvalue of updated left operand\n+     */\n+    ref Int128 opOpAssign(string op)(Int128 op2)\n+        if (op == \"+\" || op == \"-\" ||\n+            op == \"*\" || op == \"/\" || op == \"%\" ||\n+            op == \"&\" || op == \"|\" || op == \"^\" ||\n+            op == \"<<\" || op == \">>\" || op == \">>>\")\n+    {\n+        mixin(\"this = this \" ~ op ~ \" op2;\");\n+        return this;\n+    }\n+\n+    /// ditto\n+    ref Int128 opOpAssign(string op)(long op2)\n+        if (op == \"+\" || op == \"-\" ||\n+            op == \"*\" || op == \"/\" || op == \"%\" ||\n+            op == \"&\" || op == \"|\" || op == \"^\" ||\n+            op == \"<<\" || op == \">>\" || op == \">>>\")\n+    {\n+        mixin(\"this = this \" ~ op ~ \" op2;\");\n+        return this;\n+    }\n+\n+    /** support signed arithmentic comparison operators < <= > >=\n+     * Params: op2 = right hand operand\n+     * Returns: -1 for less than, 0 for equals, 1 for greater than\n+     */\n+    int opCmp(Int128 op2) const\n+    {\n+        return this == op2 ? 0 : gt(this.data, op2.data) * 2 - 1;\n+    }\n+\n+    /** support signed arithmentic comparison operators < <= > >=\n+     * Params: op2 = right hand operand\n+     * Returns: -1 for less than, 0 for equals, 1 for greater than\n+     */\n+    int opCmp(long op2) const\n+    {\n+        return opCmp(Int128(0, op2));\n+    }\n+\n+    enum min = Int128(long.min, 0);             /// minimum value\n+    enum max = Int128(long.max, ulong.max);     /// maximum value\n+}\n+\n+/********************************************* Tests ************************************/\n+\n+version (unittest)\n+{\n+import core.stdc.stdio;\n+\n+@trusted void print(Int128 c)\n+{\n+    printf(\"%lld, %lld\\n\", c.data.hi, c.data.lo);\n+}\n+\n+@trusted void printx(Int128 c)\n+{\n+    printf(\"%llx, %llx\\n\", c.data.hi, c.data.lo);\n+}\n+}\n+\n+/// Int128 tests\n+@safe pure nothrow @nogc\n+unittest\n+{\n+    Int128 c = Int128(5, 6);\n+    assert(c == c);\n+    assert(c == +c);\n+    assert(c == - -c);\n+    assert(~c == Int128(~5, ~6));\n+    ++c;\n+    assert(c == Int128(5, 7));\n+    assert(--c == Int128(5, 6));\n+    assert(!!c);\n+    assert(!Int128());\n+\n+    assert(c + Int128(10, 20) == Int128(15, 26));\n+    assert(c - Int128(1, 2)   == Int128(4, 4));\n+    assert(c * Int128(100, 2) == Int128(610, 12));\n+    assert(c / Int128(3, 2)   == Int128(0, 1));\n+    assert(c % Int128(3, 2)   == Int128(2, 4));\n+    assert((c & Int128(3, 2)) == Int128(1, 2));\n+    assert((c | Int128(3, 2)) == Int128(7, 6));\n+    assert((c ^ Int128(3, 2)) == Int128(6, 4));\n+\n+    assert(c + 15   == Int128(5, 21));\n+    assert(c - 15   == Int128(4, -9));\n+    assert(c * 15   == Int128(75, 90));\n+    assert(c / 15   == Int128(0, 6148914691236517205));\n+    assert(c % 15   == Int128(0, 11));\n+    assert((c & 15) == Int128(0, 6));\n+    assert((c | 15) == Int128(5, 15));\n+    assert((c ^ 15) == Int128(5, 9));\n+\n+    assert(15 + c   == Int128(5, 21));\n+    assert(15 - c   == Int128(-5, 9));\n+    assert(15 * c   == Int128(75, 90));\n+    assert(15 / c   == Int128(0, 0));\n+    assert(15 % c   == Int128(0, 15));\n+    assert((15 & c) == Int128(0, 6));\n+    assert((15 | c) == Int128(5, 15));\n+    assert((15 ^ c) == Int128(5, 9));\n+\n+    assert(c << 1 == Int128(10, 12));\n+    assert(-c >> 1 == Int128(-3, 9223372036854775805));\n+    assert(-c >>> 1 == Int128(9223372036854775805, 9223372036854775805));\n+\n+    assert((c += 1) == Int128(5, 7));\n+    assert((c -= 1) == Int128(5, 6));\n+    assert((c += Int128(0, 1)) == Int128(5, 7));\n+    assert((c -= Int128(0, 1)) == Int128(5, 6));\n+    assert((c *= 2) == Int128(10, 12));\n+    assert((c /= 2) == Int128(5, 6));\n+    assert((c %= 2) == Int128());\n+    c += Int128(5, 6);\n+    assert((c *= Int128(10, 20)) == Int128(160, 120));\n+    assert((c /= Int128(10, 20)) == Int128(0, 15));\n+    c += Int128(72, 0);\n+    assert((c %= Int128(10, 20)) == Int128(1, -125));\n+    assert((c &= Int128(3, 20)) == Int128(1, 0));\n+    assert((c |= Int128(8, 2)) == Int128(9, 2));\n+    assert((c ^= Int128(8, 2)) == Int128(1, 0));\n+    c |= Int128(10, 5);\n+    assert((c <<= 1) == Int128(11 * 2, 5 * 2));\n+    assert((c >>>= 1) == Int128(11, 5));\n+    c = Int128(long.min, long.min);\n+    assert((c >>= 1) == Int128(long.min >> 1, cast(ulong) long.min >> 1));\n+\n+    assert(-Int128.min == Int128.min);\n+    assert(Int128.max + 1 == Int128.min);\n+\n+    c = Int128(5, 6);\n+    assert(c < Int128(6, 5));\n+    assert(c > 10);\n+\n+    c = Int128(-1UL);\n+    assert(c == -1UL);\n+    c = Int128(-1L);\n+    assert(c == -1L);\n+}"}, {"sha": "de180fcc548d4375751b022374ffba7eaa3cf2c3", "filename": "libphobos/src/std/path.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/libphobos%2Fsrc%2Fstd%2Fpath.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/libphobos%2Fsrc%2Fstd%2Fpath.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fpath.d?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -1519,7 +1519,7 @@ if (isSomeChar!C)\n     import std.range;\n     // ir() wraps an array in a plain (i.e. non-forward) input range, so that\n     // we can test both code paths\n-    InputRange!(C[]) ir(C)(C[][] p...) { return inputRangeObject(p); }\n+    InputRange!(C[]) ir(C)(C[][] p...) { return inputRangeObject(p.dup); }\n     version (Posix)\n     {\n         assert(buildPath(\"foo\") == \"foo\");"}, {"sha": "18400e3e859823b643be0d85c17a71b39c2f86b4", "filename": "libphobos/src/std/traits.d", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae56e2da05e823e63972aff3118a659d7ca7a8b9/libphobos%2Fsrc%2Fstd%2Ftraits.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae56e2da05e823e63972aff3118a659d7ca7a8b9/libphobos%2Fsrc%2Fstd%2Ftraits.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Ftraits.d?ref=ae56e2da05e823e63972aff3118a659d7ca7a8b9", "patch": "@@ -1422,6 +1422,11 @@ if (isCallable!func)\n             enum val = \"val\" ~ (name == \"val\" ? \"_\" : \"\");\n             enum ptr = \"ptr\" ~ (name == \"ptr\" ? \"_\" : \"\");\n             mixin(\"\n+                enum hasDefaultArg = (PT[i .. i+1] \" ~ args ~ \") { return true; };\n+            \");\n+            static if (is(typeof(hasDefaultArg())))\n+            {\n+                mixin(\"\n                 // workaround scope escape check, see\n                 // https://issues.dlang.org/show_bug.cgi?id=16582\n                 // should use return scope once available\n@@ -1432,10 +1437,9 @@ if (isCallable!func)\n                     auto \" ~ val ~ \" = \" ~ args ~ \"[0];\n                     auto \" ~ ptr ~ \" = &\" ~ val ~ \";\n                     return *\" ~ ptr ~ \";\n-                };\n-            \");\n-            static if (is(typeof(get())))\n+                };\");\n                 enum Get = get();\n+            }\n             else\n                 alias Get = void;\n                 // If default arg doesn't exist, returns void instead.\n@@ -1483,6 +1487,17 @@ if (isCallable!func)\n     static foreach (V; Voids) static assert(is(V == void));\n }\n \n+// https://issues.dlang.org/show_bug.cgi?id=20182\n+@safe pure nothrow @nogc unittest\n+{\n+    struct S\n+    {\n+        this(ref S) {}\n+    }\n+\n+    static assert(__traits(compiles, ParameterDefaults!(S.__ctor)));\n+}\n+\n /**\n  * Alternate name for $(LREF ParameterDefaults), kept for legacy compatibility.\n  */"}]}