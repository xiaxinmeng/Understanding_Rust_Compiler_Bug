{"sha": "7ffb5e78794b6d8f8094d7c928e6f0e94b62cad6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2ZmYjVlNzg3OTRiNmQ4ZjgwOTRkN2M5MjhlNmYwZTk0YjYyY2FkNg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard@codesourcery.com", "date": "2007-03-01T09:58:12Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-03-01T09:58:12Z"}, "message": "Makefile.in (rtlanal.o): Depend on tree.h.\n\ngcc/\n\t* Makefile.in (rtlanal.o): Depend on tree.h.\n\t* rtl.h (offset_within_section_p, split_const): Declare.\n\t* rtlanal.c: Include tree.h.\n\t(offset_within_block_p): New function, taken from\n\tmips_offset_within_object_p.\n\t(split_const): New function, taken from mips_split_const.\n\t* config/m68k/m68k-protos.h (m68k_illegitimate_symbolic_constant_p):\n\tDeclare.\n\t* config/m68k/m68k.h (M68K_OFFSETS_MUST_BE_WITHIN_SECTIONS_P): Define.\n\t(CONSTANT_ADDRESS_P): Only accept legitimate constants.\n\t(LEGITIMATE_CONSTANT_P): Check m68k_illegitimate_symbolic_constant_p.\n\t* config/m68k/m68k.c (TARGET_CANNOT_FORCE_CONST_MEM): Define.\n\t(m68k_illegitimate_symbolic_constant_p): New function.\n\t* config/m68k/m68k.md (movsi): Remove misleading predicates.\n\tIf M68K_OFFSETS_MUST_BE_WITHIN_SECTIONS_P and the source is a\n\tsymbolic constant that might be outside the symbol's section,\n\tmove the symbol first and then add the offset.\n\t* config/m68k/uclinux.h (M68K_OFFSETS_MUST_BE_WITHIN_SECTIONS_P):\n\tOverride.\n\t* config/mips/mips.c (mips_split_const): Delete.\n\t(mips_offset_within_object_p): Delete.\n\t(mips_symbolic_constant_p): Use offset_within_section_p and\n\tsplit_const instead of mips_offset_within_object_p and\n\tmips_split_const.\n\t(mips_cannot_force_const_mem, mips_const_insns, mips_unspec_address)\n\t(mips_legitimize_const_move, print_operand_reloc)\n\t(mips_dangerous_for_la25_p): Use split_const instead of\n\tmips_split_const.\n\nFrom-SVN: r122428", "tree": {"sha": "81be2b5d29cc958cea52c2a7ebbe3c30b5b450ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81be2b5d29cc958cea52c2a7ebbe3c30b5b450ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ffb5e78794b6d8f8094d7c928e6f0e94b62cad6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ffb5e78794b6d8f8094d7c928e6f0e94b62cad6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ffb5e78794b6d8f8094d7c928e6f0e94b62cad6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ffb5e78794b6d8f8094d7c928e6f0e94b62cad6/comments", "author": null, "committer": null, "parents": [{"sha": "96e7e5ad47a3d455eeb64991e44b23f24c69719e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96e7e5ad47a3d455eeb64991e44b23f24c69719e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96e7e5ad47a3d455eeb64991e44b23f24c69719e"}], "stats": {"total": 268, "additions": 175, "deletions": 93}, "files": [{"sha": "120d963081d351376cadc1a4885461c53c5c3ae6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ffb5e78794b6d8f8094d7c928e6f0e94b62cad6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ffb5e78794b6d8f8094d7c928e6f0e94b62cad6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7ffb5e78794b6d8f8094d7c928e6f0e94b62cad6", "patch": "@@ -1,3 +1,34 @@\n+2007-03-01  Richard Sandiford  <richard@codesourcery.com>\n+\n+\t* Makefile.in (rtlanal.o): Depend on tree.h.\n+\t* rtl.h (offset_within_section_p, split_const): Declare.\n+\t* rtlanal.c: Include tree.h.\n+\t(offset_within_block_p): New function, taken from\n+\tmips_offset_within_object_p.\n+\t(split_const): New function, taken from mips_split_const.\n+\t* config/m68k/m68k-protos.h (m68k_illegitimate_symbolic_constant_p):\n+\tDeclare.\n+\t* config/m68k/m68k.h (M68K_OFFSETS_MUST_BE_WITHIN_SECTIONS_P): Define.\n+\t(CONSTANT_ADDRESS_P): Only accept legitimate constants.\n+\t(LEGITIMATE_CONSTANT_P): Check m68k_illegitimate_symbolic_constant_p.\n+\t* config/m68k/m68k.c (TARGET_CANNOT_FORCE_CONST_MEM): Define.\n+\t(m68k_illegitimate_symbolic_constant_p): New function.\n+\t* config/m68k/m68k.md (movsi): Remove misleading predicates.\n+\tIf M68K_OFFSETS_MUST_BE_WITHIN_SECTIONS_P and the source is a\n+\tsymbolic constant that might be outside the symbol's section,\n+\tmove the symbol first and then add the offset.\n+\t* config/m68k/uclinux.h (M68K_OFFSETS_MUST_BE_WITHIN_SECTIONS_P):\n+\tOverride.\n+\t* config/mips/mips.c (mips_split_const): Delete.\n+\t(mips_offset_within_object_p): Delete.\n+\t(mips_symbolic_constant_p): Use offset_within_section_p and\n+\tsplit_const instead of mips_offset_within_object_p and\n+\tmips_split_const.\n+\t(mips_cannot_force_const_mem, mips_const_insns, mips_unspec_address)\n+\t(mips_legitimize_const_move, print_operand_reloc)\n+\t(mips_dangerous_for_la25_p): Use split_const instead of\n+\tmips_split_const.\n+\n 2007-02-28  Eric Christopher  <echristo@apple.com>\n \n \t* Makefile.in (install-include-dir): Don't rm -rf include."}, {"sha": "974f6b4ba3714943e8f30e3686b3500393d084ff", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ffb5e78794b6d8f8094d7c928e6f0e94b62cad6/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ffb5e78794b6d8f8094d7c928e6f0e94b62cad6/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=7ffb5e78794b6d8f8094d7c928e6f0e94b62cad6", "patch": "@@ -2314,7 +2314,7 @@ print-rtl.o : print-rtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n     $(BCONFIG_H) $(REAL_H)\n rtlanal.o : rtlanal.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) toplev.h \\\n    $(RTL_H) hard-reg-set.h $(TM_P_H) insn-config.h $(RECOG_H) $(REAL_H) \\\n-   $(FLAGS_H) $(REGS_H) output.h $(TARGET_H) $(FUNCTION_H)\n+   $(FLAGS_H) $(REGS_H) output.h $(TARGET_H) $(FUNCTION_H) $(TREE_H)\n \n varasm.o : varasm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(RTL_H) $(FLAGS_H) $(FUNCTION_H) $(EXPR_H) hard-reg-set.h $(REGS_H) \\"}, {"sha": "d0ff670639bffc6bb716cb9b8d9e2c7efee7f7da", "filename": "gcc/config/m68k/m68k-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ffb5e78794b6d8f8094d7c928e6f0e94b62cad6/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ffb5e78794b6d8f8094d7c928e6f0e94b62cad6/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h?ref=7ffb5e78794b6d8f8094d7c928e6f0e94b62cad6", "patch": "@@ -50,6 +50,7 @@ extern int standard_68881_constant_p (rtx);\n extern void print_operand_address (FILE *, rtx);\n extern void print_operand (FILE *, rtx, int);\n extern void notice_update_cc (rtx, rtx);\n+extern bool m68k_illegitimate_symbolic_constant_p (rtx);\n extern rtx legitimize_pic_address (rtx, enum machine_mode, rtx);\n extern int valid_dbcc_comparison_p_2 (rtx, enum machine_mode);\n extern rtx m68k_libcall_value (enum machine_mode);"}, {"sha": "90e2491fb73a488368173873aa5cc312cd929a55", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ffb5e78794b6d8f8094d7c928e6f0e94b62cad6/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ffb5e78794b6d8f8094d7c928e6f0e94b62cad6/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=7ffb5e78794b6d8f8094d7c928e6f0e94b62cad6", "patch": "@@ -191,6 +191,9 @@ int m68k_last_compare_had_fp_operands;\n #undef TARGET_STRUCT_VALUE_RTX\n #define TARGET_STRUCT_VALUE_RTX m68k_struct_value_rtx\n \n+#undef TARGET_CANNOT_FORCE_CONST_MEM\n+#define TARGET_CANNOT_FORCE_CONST_MEM m68k_illegitimate_symbolic_constant_p\n+\n static const struct attribute_spec m68k_attribute_table[] =\n {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n@@ -1663,6 +1666,23 @@ output_btst (rtx *operands, rtx countop, rtx dataop, rtx insn, int signpos)\n   return \"btst %0,%1\";\n }\n \f\n+/* Return true if X is an illegitimate symbolic constant.  */\n+\n+bool\n+m68k_illegitimate_symbolic_constant_p (rtx x)\n+{\n+  rtx base, offset;\n+\n+  if (M68K_OFFSETS_MUST_BE_WITHIN_SECTIONS_P)\n+    {\n+      split_const (x, &base, &offset);\n+      if (GET_CODE (base) == SYMBOL_REF\n+\t  && !offset_within_block_p (base, INTVAL (offset)))\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n /* Legitimize PIC addresses.  If the address is already\n    position-independent, we return ORIG.  Newly generated\n    position-independent addresses go to REG.  If we need more"}, {"sha": "f960f3b4773f76e293fa446bda24f5ff1ffab1ca", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ffb5e78794b6d8f8094d7c928e6f0e94b62cad6/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ffb5e78794b6d8f8094d7c928e6f0e94b62cad6/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=7ffb5e78794b6d8f8094d7c928e6f0e94b62cad6", "patch": "@@ -786,17 +786,25 @@ __transfer_from_trampoline ()\t\t\t\t\t\\\n /* 1 if X is an address register  */\n #define ADDRESS_REG_P(X) (REG_P (X) && REGNO_OK_FOR_BASE_P (REGNO (X)))\n \f\n+/* True if SYMBOL + OFFSET constants must refer to something within\n+   SYMBOL's section.  */\n+#ifndef M68K_OFFSETS_MUST_BE_WITHIN_SECTIONS_P\n+#define M68K_OFFSETS_MUST_BE_WITHIN_SECTIONS_P 0\n+#endif\n \n #define MAX_REGS_PER_ADDRESS 2\n \n-#define CONSTANT_ADDRESS_P(X)   \\\n-  (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n-   || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST\t\t\\\n-   || GET_CODE (X) == HIGH)\n+#define CONSTANT_ADDRESS_P(X)\t\t\t\t\t\t\\\n+  ((GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n+    || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST\t\t\\\n+    || GET_CODE (X) == HIGH)\t\t\t\t\t\t\\\n+   && LEGITIMATE_CONSTANT_P (X))\n \n /* Nonzero if the constant value X is a legitimate general operand.\n    It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n-#define LEGITIMATE_CONSTANT_P(X) (GET_MODE (X) != XFmode)\n+#define LEGITIMATE_CONSTANT_P(X)\t\t\t\t\\\n+  (GET_MODE (X) != XFmode\t\t\t\t\t\\\n+   && !m68k_illegitimate_symbolic_constant_p (X))\n \n #ifndef REG_OK_STRICT\n #define PCREL_GENERAL_OPERAND_OK 0"}, {"sha": "a2f0cfd7044fabc3439920bd9ecb9c85d92d12d0", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ffb5e78794b6d8f8094d7c928e6f0e94b62cad6/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ffb5e78794b6d8f8094d7c928e6f0e94b62cad6/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=7ffb5e78794b6d8f8094d7c928e6f0e94b62cad6", "patch": "@@ -627,10 +627,12 @@\n ;; In both the PIC and non-PIC cases the patterns generated will\n ;; matched by the next define_insn.\n (define_expand \"movsi\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n-\t(match_operand:SI 1 \"general_operand\" \"\"))]\n+  [(set (match_operand:SI 0 \"\" \"\")\n+\t(match_operand:SI 1 \"\" \"\"))]\n   \"\"\n {\n+  rtx tmp, base, offset;\n+\n   if (flag_pic && !TARGET_PCREL && symbolic_operand (operands[1], SImode))\n     {\n       /* The source is an address which requires PIC relocation.\n@@ -651,6 +653,18 @@\n \toperands[0] = gen_rtx_MEM (SImode,\n \t\t\t       force_reg (SImode, XEXP (operands[0], 0)));\n     }\n+  if (M68K_OFFSETS_MUST_BE_WITHIN_SECTIONS_P)\n+    {\n+      split_const (operands[1], &base, &offset);\n+      if (GET_CODE (base) == SYMBOL_REF\n+\t  && !offset_within_block_p (base, INTVAL (offset)))\n+\t{\n+\t  tmp = no_new_pseudos ? operands[0] : gen_reg_rtx (SImode);\n+\t  emit_move_insn (tmp, base);\n+\t  emit_insn (gen_addsi3 (operands[0], tmp, offset));\n+\t  DONE;\n+\t}\n+    }\n })\n \n ;; General case of fullword move.  The register constraints"}, {"sha": "93a9d829187a16142337c526cb63bf7497fac793", "filename": "gcc/config/m68k/uclinux.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ffb5e78794b6d8f8094d7c928e6f0e94b62cad6/gcc%2Fconfig%2Fm68k%2Fuclinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ffb5e78794b6d8f8094d7c928e6f0e94b62cad6/gcc%2Fconfig%2Fm68k%2Fuclinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fuclinux.h?ref=7ffb5e78794b6d8f8094d7c928e6f0e94b62cad6", "patch": "@@ -65,3 +65,9 @@ Boston, MA 02110-1301, USA.  */\n /* -msep-data is the default PIC mode on this target.  */\n #define DRIVER_SELF_SPECS \\\n   \"%{fpie|fPIE|fpic|fPIC:%{!msep-data:%{!mid-shared-library: -msep-data}}}\"\n+\n+/* The uclinux binary format relies on relocations against a segment being\n+   within that segment.  Conservatively apply this rule to individual\n+   sections.  */\n+#undef M68K_OFFSETS_MUST_BE_WITHIN_SECTIONS_P\n+#define M68K_OFFSETS_MUST_BE_WITHIN_SECTIONS_P 1"}, {"sha": "82b38a795ec115098ff1ef947a48a6715abb4d98", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 29, "deletions": 85, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ffb5e78794b6d8f8094d7c928e6f0e94b62cad6/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ffb5e78794b6d8f8094d7c928e6f0e94b62cad6/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=7ffb5e78794b6d8f8094d7c928e6f0e94b62cad6", "patch": "@@ -267,8 +267,6 @@ struct mips_integer_op;\n struct mips_sim;\n \n static enum mips_symbol_type mips_classify_symbol (rtx);\n-static void mips_split_const (rtx, rtx *, HOST_WIDE_INT *);\n-static bool mips_offset_within_object_p (rtx, HOST_WIDE_INT);\n static bool mips_valid_base_register_p (rtx, enum machine_mode, int);\n static bool mips_symbolic_address_p (enum mips_symbol_type, enum machine_mode);\n static bool mips_classify_address (struct mips_address_info *, rtx,\n@@ -1292,68 +1290,16 @@ mips_classify_symbol (rtx x)\n   return SYMBOL_GENERAL;\n }\n \n-\n-/* Split X into a base and a constant offset, storing them in *BASE\n-   and *OFFSET respectively.  */\n-\n-static void\n-mips_split_const (rtx x, rtx *base, HOST_WIDE_INT *offset)\n-{\n-  *offset = 0;\n-\n-  if (GET_CODE (x) == CONST)\n-    {\n-      x = XEXP (x, 0);\n-      if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == CONST_INT)\n-\t{\n-\t  *offset += INTVAL (XEXP (x, 1));\n-\t  x = XEXP (x, 0);\n-\t}\n-    }\n-  *base = x;\n-}\n-\n-\n-/* Return true if SYMBOL is a SYMBOL_REF and OFFSET + SYMBOL points\n-   to the same object as SYMBOL, or to the same object_block.  */\n-\n-static bool\n-mips_offset_within_object_p (rtx symbol, HOST_WIDE_INT offset)\n-{\n-  if (GET_CODE (symbol) != SYMBOL_REF)\n-    return false;\n-\n-  if (CONSTANT_POOL_ADDRESS_P (symbol)\n-      && offset >= 0\n-      && offset < (int) GET_MODE_SIZE (get_pool_mode (symbol)))\n-    return true;\n-\n-  if (SYMBOL_REF_DECL (symbol) != 0\n-      && offset >= 0\n-      && offset < int_size_in_bytes (TREE_TYPE (SYMBOL_REF_DECL (symbol))))\n-    return true;\n-\n-  if (SYMBOL_REF_HAS_BLOCK_INFO_P (symbol)\n-      && SYMBOL_REF_BLOCK (symbol)\n-      && SYMBOL_REF_BLOCK_OFFSET (symbol) >= 0\n-      && ((unsigned HOST_WIDE_INT) offset + SYMBOL_REF_BLOCK_OFFSET (symbol)\n-\t  < (unsigned HOST_WIDE_INT) SYMBOL_REF_BLOCK (symbol)->size))\n-    return true;\n-\n-  return false;\n-}\n-\n-\n /* Return true if X is a symbolic constant that can be calculated in\n    the same way as a bare symbol.  If it is, store the type of the\n    symbol in *SYMBOL_TYPE.  */\n \n bool\n mips_symbolic_constant_p (rtx x, enum mips_symbol_type *symbol_type)\n {\n-  HOST_WIDE_INT offset;\n+  rtx offset;\n \n-  mips_split_const (x, &x, &offset);\n+  split_const (x, &x, &offset);\n   if (UNSPEC_ADDRESS_P (x))\n     *symbol_type = UNSPEC_ADDRESS_TYPE (x);\n   else if (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == LABEL_REF)\n@@ -1365,7 +1311,7 @@ mips_symbolic_constant_p (rtx x, enum mips_symbol_type *symbol_type)\n   else\n     return false;\n \n-  if (offset == 0)\n+  if (offset == const0_rtx)\n     return true;\n \n   /* Check whether a nonzero offset is valid for the underlying\n@@ -1381,7 +1327,7 @@ mips_symbolic_constant_p (rtx x, enum mips_symbol_type *symbol_type)\n \t sign-extended.  In this case we can't allow an arbitrary offset\n \t in case the 32-bit value X + OFFSET has a different sign from X.  */\n       if (Pmode == DImode && !ABI_HAS_64BIT_SYMBOLS)\n-\treturn mips_offset_within_object_p (x, offset);\n+\treturn offset_within_block_p (x, INTVAL (offset));\n \n       /* In other cases the relocations can handle any offset.  */\n       return true;\n@@ -1397,15 +1343,15 @@ mips_symbolic_constant_p (rtx x, enum mips_symbol_type *symbol_type)\n \n     case SYMBOL_SMALL_DATA:\n       /* Make sure that the offset refers to something within the\n-\t underlying object.  This should guarantee that the final\n+\t same object block.  This should guarantee that the final\n \t PC- or GP-relative offset is within the 16-bit limit.  */\n-      return mips_offset_within_object_p (x, offset);\n+      return offset_within_block_p (x, INTVAL (offset));\n \n     case SYMBOL_GOT_LOCAL:\n     case SYMBOL_GOTOFF_PAGE:\n       /* The linker should provide enough local GOT entries for a\n \t 16-bit offset.  Larger offsets may lead to GOT overflow.  */\n-      return SMALL_OPERAND (offset);\n+      return SMALL_INT (offset);\n \n     case SYMBOL_GOT_GLOBAL:\n     case SYMBOL_GOTOFF_GLOBAL:\n@@ -1595,8 +1541,7 @@ mips_tls_symbol_ref_1 (rtx *x, void *data ATTRIBUTE_UNUSED)\n static bool\n mips_cannot_force_const_mem (rtx x)\n {\n-  rtx base;\n-  HOST_WIDE_INT offset;\n+  rtx base, offset;\n \n   if (!TARGET_MIPS16)\n     {\n@@ -1612,8 +1557,8 @@ mips_cannot_force_const_mem (rtx x)\n       if (GET_CODE (x) == CONST_INT)\n \treturn true;\n \n-      mips_split_const (x, &base, &offset);\n-      if (symbolic_operand (base, VOIDmode) && SMALL_OPERAND (offset))\n+      split_const (x, &base, &offset);\n+      if (symbolic_operand (base, VOIDmode) && SMALL_INT (offset))\n \treturn true;\n     }\n \n@@ -1800,7 +1745,7 @@ mips_const_insns (rtx x)\n {\n   struct mips_integer_op codes[MIPS_MAX_INTEGER_OPS];\n   enum mips_symbol_type symbol_type;\n-  HOST_WIDE_INT offset;\n+  rtx offset;\n \n   switch (GET_CODE (x))\n     {\n@@ -1841,16 +1786,16 @@ mips_const_insns (rtx x)\n       /* Otherwise try splitting the constant into a base and offset.\n \t 16-bit offsets can be added using an extra addiu.  Larger offsets\n \t must be calculated separately and then added to the base.  */\n-      mips_split_const (x, &x, &offset);\n+      split_const (x, &x, &offset);\n       if (offset != 0)\n \t{\n \t  int n = mips_const_insns (x);\n \t  if (n != 0)\n \t    {\n-\t      if (SMALL_OPERAND (offset))\n+\t      if (SMALL_INT (offset))\n \t\treturn n + 1;\n \t      else\n-\t\treturn n + 1 + mips_build_integer (codes, offset);\n+\t\treturn n + 1 + mips_build_integer (codes, INTVAL (offset));\n \t    }\n \t}\n       return 0;\n@@ -1949,13 +1894,14 @@ mips_split_symbol (rtx temp, rtx addr)\n rtx\n mips_unspec_address (rtx address, enum mips_symbol_type symbol_type)\n {\n-  rtx base;\n-  HOST_WIDE_INT offset;\n+  rtx base, offset;\n \n-  mips_split_const (address, &base, &offset);\n+  split_const (address, &base, &offset);\n   base = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, base),\n \t\t\t UNSPEC_ADDRESS_FIRST + symbol_type);\n-  return plus_constant (gen_rtx_CONST (Pmode, base), offset);\n+  if (offset != const0_rtx)\n+    base = gen_rtx_PLUS (Pmode, base, offset);\n+  return gen_rtx_CONST (Pmode, base);\n }\n \n \n@@ -2303,8 +2249,7 @@ mips_move_integer (rtx dest, rtx temp, unsigned HOST_WIDE_INT value)\n static void\n mips_legitimize_const_move (enum machine_mode mode, rtx dest, rtx src)\n {\n-  rtx base;\n-  HOST_WIDE_INT offset;\n+  rtx base, offset;\n \n   /* Split moves of big integers into smaller pieces.  */\n   if (splittable_const_int_operand (src, mode))\n@@ -2329,13 +2274,13 @@ mips_legitimize_const_move (enum machine_mode mode, rtx dest, rtx src)\n   /* If we have (const (plus symbol offset)), load the symbol first\n      and then add in the offset.  This is usually better than forcing\n      the constant into memory, at least in non-mips16 code.  */\n-  mips_split_const (src, &base, &offset);\n+  split_const (src, &base, &offset);\n   if (!TARGET_MIPS16\n-      && offset != 0\n-      && (!no_new_pseudos || SMALL_OPERAND (offset)))\n+      && offset != const0_rtx\n+      && (!no_new_pseudos || SMALL_INT (offset)))\n     {\n       base = mips_force_temporary (dest, base);\n-      emit_move_insn (dest, mips_add_offset (0, base, offset));\n+      emit_move_insn (dest, mips_add_offset (0, base, INTVAL (offset)));\n       return;\n     }\n \n@@ -5709,16 +5654,15 @@ print_operand_reloc (FILE *file, rtx op, const char **relocs)\n {\n   enum mips_symbol_type symbol_type;\n   const char *p;\n-  rtx base;\n-  HOST_WIDE_INT offset;\n+  rtx base, offset;\n \n   if (!mips_symbolic_constant_p (op, &symbol_type) || relocs[symbol_type] == 0)\n     fatal_insn (\"PRINT_OPERAND, invalid operand for relocation\", op);\n \n   /* If OP uses an UNSPEC address, we want to print the inner symbol.  */\n-  mips_split_const (op, &base, &offset);\n+  split_const (op, &base, &offset);\n   if (UNSPEC_ADDRESS_P (base))\n-    op = plus_constant (UNSPEC_ADDRESS (base), offset);\n+    op = plus_constant (UNSPEC_ADDRESS (base), INTVAL (offset));\n \n   fputs (relocs[symbol_type], file);\n   output_addr_const (file, op);\n@@ -7640,12 +7584,12 @@ mips_cannot_change_mode_class (enum machine_mode from,\n bool\n mips_dangerous_for_la25_p (rtx x)\n {\n-  HOST_WIDE_INT offset;\n+  rtx offset;\n \n   if (TARGET_EXPLICIT_RELOCS)\n     return false;\n \n-  mips_split_const (x, &x, &offset);\n+  split_const (x, &x, &offset);\n   return global_got_operand (x, VOIDmode);\n }\n "}, {"sha": "41d50d4755fbb20374eded947ef1a6bc6d120187", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ffb5e78794b6d8f8094d7c928e6f0e94b62cad6/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ffb5e78794b6d8f8094d7c928e6f0e94b62cad6/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=7ffb5e78794b6d8f8094d7c928e6f0e94b62cad6", "patch": "@@ -1672,6 +1672,8 @@ extern int rtx_varies_p (rtx, int);\n extern int rtx_addr_varies_p (rtx, int);\n extern HOST_WIDE_INT get_integer_term (rtx);\n extern rtx get_related_value (rtx);\n+extern bool offset_within_block_p (rtx, HOST_WIDE_INT);\n+extern void split_const (rtx, rtx *, rtx *);\n extern int reg_mentioned_p (rtx, rtx);\n extern int count_occurrences (rtx, rtx, int);\n extern int reg_referenced_p (rtx, rtx);"}, {"sha": "cf9fd1d65af381f1fec829011ca11c0256a6842b", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ffb5e78794b6d8f8094d7c928e6f0e94b62cad6/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ffb5e78794b6d8f8094d7c928e6f0e94b62cad6/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=7ffb5e78794b6d8f8094d7c928e6f0e94b62cad6", "patch": "@@ -37,6 +37,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"real.h\"\n #include \"regs.h\"\n #include \"function.h\"\n+#include \"tree.h\"\n \n /* Information about a subreg of a hard register.  */\n struct subreg_info\n@@ -496,6 +497,61 @@ get_related_value (rtx x)\n   return 0;\n }\n \f\n+/* Return true if SYMBOL is a SYMBOL_REF and OFFSET + SYMBOL points\n+   to somewhere in the same object or object_block as SYMBOL.  */\n+\n+bool\n+offset_within_block_p (rtx symbol, HOST_WIDE_INT offset)\n+{\n+  tree decl;\n+\n+  if (GET_CODE (symbol) != SYMBOL_REF)\n+    return false;\n+\n+  if (offset == 0)\n+    return true;\n+\n+  if (offset > 0)\n+    {\n+      if (CONSTANT_POOL_ADDRESS_P (symbol)\n+\t  && offset < (int) GET_MODE_SIZE (get_pool_mode (symbol)))\n+\treturn true;\n+\n+      decl = SYMBOL_REF_DECL (symbol);\n+      if (decl && offset < int_size_in_bytes (TREE_TYPE (decl)))\n+\treturn true;\n+    }\n+\n+  if (SYMBOL_REF_HAS_BLOCK_INFO_P (symbol)\n+      && SYMBOL_REF_BLOCK (symbol)\n+      && SYMBOL_REF_BLOCK_OFFSET (symbol) >= 0\n+      && ((unsigned HOST_WIDE_INT) offset + SYMBOL_REF_BLOCK_OFFSET (symbol)\n+\t  < (unsigned HOST_WIDE_INT) SYMBOL_REF_BLOCK (symbol)->size))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Split X into a base and a constant offset, storing them in *BASE_OUT\n+   and *OFFSET_OUT respectively.  */\n+\n+void\n+split_const (rtx x, rtx *base_out, rtx *offset_out)\n+{\n+  if (GET_CODE (x) == CONST)\n+    {\n+      x = XEXP (x, 0);\n+      if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\t{\n+\t  *base_out = XEXP (x, 0);\n+\t  *offset_out = XEXP (x, 1);\n+\t  return;\n+\t}\n+    }\n+  *base_out = x;\n+  *offset_out = const0_rtx;\n+}\n+\f\n /* Return the number of places FIND appears within X.  If COUNT_DEST is\n    zero, we do not count occurrences inside the destination of a SET.  */\n "}]}