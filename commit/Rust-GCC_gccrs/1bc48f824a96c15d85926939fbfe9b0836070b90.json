{"sha": "1bc48f824a96c15d85926939fbfe9b0836070b90", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWJjNDhmODI0YTk2YzE1ZDg1OTI2OTM5ZmJmZTliMDgzNjA3MGI5MA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2000-05-26T10:30:47Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2000-05-26T10:30:47Z"}, "message": "flow.c (find_label_refs): New function.\n\n* flow.c (find_label_refs): New function.\n(find_basic_blocks_1): Call it for each alternative of a call\nplaceholder.\n\nFrom-SVN: r34193", "tree": {"sha": "2a041398e350859fb8caf0c0392c9805758552eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a041398e350859fb8caf0c0392c9805758552eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1bc48f824a96c15d85926939fbfe9b0836070b90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bc48f824a96c15d85926939fbfe9b0836070b90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bc48f824a96c15d85926939fbfe9b0836070b90", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bc48f824a96c15d85926939fbfe9b0836070b90/comments", "author": null, "committer": null, "parents": [{"sha": "5f361012f7f68251ef52223accb743e64320fa1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f361012f7f68251ef52223accb743e64320fa1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f361012f7f68251ef52223accb743e64320fa1c"}], "stats": {"total": 66, "additions": 61, "deletions": 5}, "files": [{"sha": "17953969a8304eb0a5a4fc642a8e2eb6fb8f54ca", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bc48f824a96c15d85926939fbfe9b0836070b90/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bc48f824a96c15d85926939fbfe9b0836070b90/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1bc48f824a96c15d85926939fbfe9b0836070b90", "patch": "@@ -1,3 +1,9 @@\n+2000-05-26  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* flow.c (find_label_refs): New function.\n+\t(find_basic_blocks_1): Call it for each alternative of a call \n+\tplaceholder.\n+\n 2000-05-26  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* ifcvt.c (cond_exec_get_condition): Set test_if to the SET_SRC"}, {"sha": "936240d79ce94b4684378f7bce2cfa60ec6a6a8f", "filename": "gcc/flow.c", "status": "modified", "additions": 55, "deletions": 5, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bc48f824a96c15d85926939fbfe9b0836070b90/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bc48f824a96c15d85926939fbfe9b0836070b90/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=1bc48f824a96c15d85926939fbfe9b0836070b90", "patch": "@@ -311,6 +311,7 @@ struct propagate_block_info\n /* Forward declarations */\n static int count_basic_blocks\t\tPARAMS ((rtx));\n static void find_basic_blocks_1\t\tPARAMS ((rtx));\n+static rtx find_label_refs\t\tPARAMS ((rtx, rtx));\n static void clear_edges\t\t\tPARAMS ((void));\n static void make_edges\t\t\tPARAMS ((rtx));\n static void make_label_edge\t\tPARAMS ((sbitmap *, basic_block,\n@@ -534,6 +535,50 @@ count_basic_blocks (f)\n   return count;\n }\n \n+/* Scan a list of insns for labels referrred to other than by jumps.\n+   This is used to scan the alternatives of a call placeholder.  */\n+static rtx find_label_refs (f, lvl)\n+     rtx f;\n+     rtx lvl;\n+{\n+  rtx insn;\n+\n+  for (insn = f; insn; insn = NEXT_INSN (insn))\n+    if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n+      {\n+\trtx note;\n+\n+\t/* Make a list of all labels referred to other than by jumps\n+\t   (which just don't have the REG_LABEL notes). \n+\n+\t   Make a special exception for labels followed by an ADDR*VEC,\n+\t   as this would be a part of the tablejump setup code. \n+\n+\t   Make a special exception for the eh_return_stub_label, which\n+\t   we know isn't part of any otherwise visible control flow.  */\n+\t     \n+\tfor (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n+\t  if (REG_NOTE_KIND (note) == REG_LABEL)\n+\t    {\n+\t      rtx lab = XEXP (note, 0), next;\n+\n+\t      if (lab == eh_return_stub_label)\n+\t\t;\n+\t      else if ((next = next_nonnote_insn (lab)) != NULL\n+\t\t       && GET_CODE (next) == JUMP_INSN\n+\t\t       && (GET_CODE (PATTERN (next)) == ADDR_VEC\n+\t\t\t   || GET_CODE (PATTERN (next)) == ADDR_DIFF_VEC))\n+\t\t;\n+\t      else if (GET_CODE (lab) == NOTE)\n+\t\t;\n+\t      else\n+\t\tlvl = alloc_EXPR_LIST (0, XEXP (note, 0), lvl);\n+\t    }\n+      }\n+\n+  return lvl;\n+}\n+\n /* Find all basic blocks of the function whose first insn is F.\n \n    Collect and return a list of labels whose addresses are taken.  This\n@@ -672,11 +717,16 @@ find_basic_blocks_1 (f)\n \t    int region = (note ? INTVAL (XEXP (note, 0)) : 1);\n \t    int call_has_abnormal_edge = 0;\n \n-\t    /* If this is a call placeholder, record its tail recursion\n-\t       label, if any.  */\n-\t    if (GET_CODE (PATTERN (insn)) == CALL_PLACEHOLDER\n-\t\t&& XEXP (PATTERN (insn), 3) != NULL_RTX)\n-\t      trll = alloc_EXPR_LIST (0, XEXP (PATTERN (insn), 3), trll);\n+\t    if (GET_CODE (PATTERN (insn)) == CALL_PLACEHOLDER)\n+\t      {\n+\t\t/* Scan each of the alternatives for label refs.  */\n+\t\tlvl = find_label_refs (XEXP (PATTERN (insn), 0), lvl);\n+\t\tlvl = find_label_refs (XEXP (PATTERN (insn), 1), lvl);\n+\t\tlvl = find_label_refs (XEXP (PATTERN (insn), 2), lvl);\n+\t\t/* Record its tail recursion label, if any.  */\n+\t\tif (XEXP (PATTERN (insn), 3) != NULL_RTX)\n+\t\t  trll = alloc_EXPR_LIST (0, XEXP (PATTERN (insn), 3), trll);\n+\t      }\n \n \t    /* If there is an EH region or rethrow, we have an edge.  */\n \t    if ((eh_list && region > 0)"}]}