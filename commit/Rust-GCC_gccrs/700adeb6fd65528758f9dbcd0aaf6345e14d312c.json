{"sha": "700adeb6fd65528758f9dbcd0aaf6345e14d312c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzAwYWRlYjZmZDY1NTI4NzU4ZjlkYmNkMGFhZjYzNDVlMTRkMzEyYw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2018-10-05T11:46:12Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2018-10-05T11:46:12Z"}, "message": "tree-core.h (tree_block::abstract_flag): Remove.\n\n2018-10-05  Richard Biener  <rguenther@suse.de>\n\n\t* tree-core.h (tree_block::abstract_flag): Remove.\n\t(tree_block::block_num): Make full 32bits.\n\t* tree.def (BLOCK): Remove docs about BLOCK_ABSTRACT.\n\t* tree.h (BLOCK_ABSTRACT): Remove.\n\t* dwarf2out.c (gen_lexical_block_die): Remove dead code\n\tresulting from BLOCK_ABSTRACT being always false.\n\t(gen_inlined_subroutine_die): Likewise.\n\t(gen_block_die): Likewise.\n\t* tree.c (block_ultimate_origin): Likewise.\n\t* tree-pretty-print.c (dump_block_node): Remove code dealing\n\twith BLOCK_ABSTRACT.\n\t* tree-ssa-live.c (dump_scope_block): Likewise.\n\t* tree-streamer-in.c (unpack_ts_block_value_fields): Likewise.\n\t* tree-streamer-out.c (pack_ts_block_value_fields): Likewise.\n\nFrom-SVN: r264868", "tree": {"sha": "ffeaac89fc3ae883b123142faa29975953613ddd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ffeaac89fc3ae883b123142faa29975953613ddd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/700adeb6fd65528758f9dbcd0aaf6345e14d312c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/700adeb6fd65528758f9dbcd0aaf6345e14d312c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/700adeb6fd65528758f9dbcd0aaf6345e14d312c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/700adeb6fd65528758f9dbcd0aaf6345e14d312c/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3f41c986d23a13c978c92ee253f6fd014ae8eca8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f41c986d23a13c978c92ee253f6fd014ae8eca8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f41c986d23a13c978c92ee253f6fd014ae8eca8"}], "stats": {"total": 144, "additions": 50, "deletions": 94}, "files": [{"sha": "087a37dd5620e48fb53bc5064397613e9e0c23a3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/700adeb6fd65528758f9dbcd0aaf6345e14d312c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/700adeb6fd65528758f9dbcd0aaf6345e14d312c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=700adeb6fd65528758f9dbcd0aaf6345e14d312c", "patch": "@@ -1,3 +1,20 @@\n+2018-10-05  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-core.h (tree_block::abstract_flag): Remove.\n+\t(tree_block::block_num): Make full 32bits.\n+\t* tree.def (BLOCK): Remove docs about BLOCK_ABSTRACT.\n+\t* tree.h (BLOCK_ABSTRACT): Remove.\n+\t* dwarf2out.c (gen_lexical_block_die): Remove dead code\n+\tresulting from BLOCK_ABSTRACT being always false.\n+\t(gen_inlined_subroutine_die): Likewise.\n+\t(gen_block_die): Likewise.\n+\t* tree.c (block_ultimate_origin): Likewise.\n+\t* tree-pretty-print.c (dump_block_node): Remove code dealing\n+\twith BLOCK_ABSTRACT.\n+\t* tree-ssa-live.c (dump_scope_block): Likewise.\n+\t* tree-streamer-in.c (unpack_ts_block_value_fields): Likewise.\n+\t* tree-streamer-out.c (pack_ts_block_value_fields): Likewise.\n+\n 2018-10-05   Richard Biener  <rguenther@suse.de>\n \n \t* config/i386/i386.c (ix86_add_stmt_cost): When scalar cost"}, {"sha": "0772b364919454428075c560851744e7214f43da", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 30, "deletions": 75, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/700adeb6fd65528758f9dbcd0aaf6345e14d312c/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/700adeb6fd65528758f9dbcd0aaf6345e14d312c/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=700adeb6fd65528758f9dbcd0aaf6345e14d312c", "patch": "@@ -24009,7 +24009,7 @@ add_high_low_attributes (tree stmt, dw_die_ref die)\n \t}\n       if (attr != NULL\n \t  && ((*ranges_table)[attr->dw_attr_val.v.val_offset].num\n-\t      == BLOCK_NUMBER (superblock))\n+\t      == (int)BLOCK_NUMBER (superblock))\n \t  && BLOCK_FRAGMENT_CHAIN (superblock))\n \t{\n \t  unsigned long off = attr->dw_attr_val.v.val_offset;\n@@ -24019,7 +24019,7 @@ add_high_low_attributes (tree stmt, dw_die_ref die)\n \t    {\n \t      ++supercnt;\n \t      gcc_checking_assert ((*ranges_table)[off + supercnt].num\n-\t\t\t\t   == BLOCK_NUMBER (chain));\n+\t\t\t\t   == (int)BLOCK_NUMBER (chain));\n \t    }\n \t  gcc_checking_assert ((*ranges_table)[off + supercnt + 1].num == 0);\n \t  for (chain = BLOCK_FRAGMENT_CHAIN (stmt);\n@@ -24071,25 +24071,7 @@ gen_lexical_block_die (tree stmt, dw_die_ref context_die)\n       equate_block_to_die (stmt, stmt_die);\n     }\n \n-  if (BLOCK_ABSTRACT (stmt))\n-    {\n-      if (old_die)\n-\t{\n-\t  /* This must have been generated early and it won't even\n-\t     need location information since it's a DW_AT_inline\n-\t     function.  */\n-\t  if (flag_checking)\n-\t    for (dw_die_ref c = context_die; c; c = c->die_parent)\n-\t      if (c->die_tag == DW_TAG_inlined_subroutine\n-\t\t  || c->die_tag == DW_TAG_subprogram)\n-\t\t{\n-\t\t  gcc_assert (get_AT (c, DW_AT_inline));\n-\t\t  break;\n-\t\t}\n-\t  return;\n-\t}\n-    }\n-  else if (BLOCK_ABSTRACT_ORIGIN (stmt))\n+  if (BLOCK_ABSTRACT_ORIGIN (stmt))\n     {\n       /* If this is an inlined or conrecte instance, create a new lexical\n \t die for anything below to attach DW_AT_abstract_origin to.  */\n@@ -24109,7 +24091,7 @@ gen_lexical_block_die (tree stmt, dw_die_ref context_die)\n   /* A non abstract block whose blocks have already been reordered\n      should have the instruction range for this block.  If so, set the\n      high/low attributes.  */\n-  if (!early_dwarf && !BLOCK_ABSTRACT (stmt) && TREE_ASM_WRITTEN (stmt))\n+  if (!early_dwarf && TREE_ASM_WRITTEN (stmt))\n     {\n       gcc_assert (stmt_die);\n       add_high_low_attributes (stmt, stmt_die);\n@@ -24123,48 +24105,38 @@ gen_lexical_block_die (tree stmt, dw_die_ref context_die)\n static void\n gen_inlined_subroutine_die (tree stmt, dw_die_ref context_die)\n {\n-  tree decl;\n-\n-  /* The instance of function that is effectively being inlined shall not\n-     be abstract.  */\n-  gcc_assert (! BLOCK_ABSTRACT (stmt));\n-\n-  decl = block_ultimate_origin (stmt);\n+  tree decl = block_ultimate_origin (stmt);\n \n   /* Make sure any inlined functions are known to be inlineable.  */\n   gcc_checking_assert (DECL_ABSTRACT_P (decl)\n \t\t       || cgraph_function_possibly_inlined_p (decl));\n \n-  if (! BLOCK_ABSTRACT (stmt))\n-    {\n-      dw_die_ref subr_die\n-\t= new_die (DW_TAG_inlined_subroutine, context_die, stmt);\n+  dw_die_ref subr_die = new_die (DW_TAG_inlined_subroutine, context_die, stmt);\n \n-      if (call_arg_locations || debug_inline_points)\n-\tequate_block_to_die (stmt, subr_die);\n-      add_abstract_origin_attribute (subr_die, decl);\n-      if (TREE_ASM_WRITTEN (stmt))\n-        add_high_low_attributes (stmt, subr_die);\n-      add_call_src_coords_attributes (stmt, subr_die);\n+  if (call_arg_locations || debug_inline_points)\n+    equate_block_to_die (stmt, subr_die);\n+  add_abstract_origin_attribute (subr_die, decl);\n+  if (TREE_ASM_WRITTEN (stmt))\n+    add_high_low_attributes (stmt, subr_die);\n+  add_call_src_coords_attributes (stmt, subr_die);\n \n-      /* The inliner creates an extra BLOCK for the parameter setup,\n-         we want to merge that with the actual outermost BLOCK of the\n-\t inlined function to avoid duplicate locals in consumers.\n-\t Do that by doing the recursion to subblocks on the single subblock\n-\t of STMT.  */\n-      bool unwrap_one = false;\n-      if (BLOCK_SUBBLOCKS (stmt) && !BLOCK_CHAIN (BLOCK_SUBBLOCKS (stmt)))\n-\t{\n-\t  tree origin = block_ultimate_origin (BLOCK_SUBBLOCKS (stmt));\n-\t  if (origin\n-\t      && TREE_CODE (origin) == BLOCK\n-\t      && BLOCK_SUPERCONTEXT (origin) == decl)\n-\t    unwrap_one = true;\n-\t}\n-      decls_for_scope (stmt, subr_die, !unwrap_one);\n-      if (unwrap_one)\n-\tdecls_for_scope (BLOCK_SUBBLOCKS (stmt), subr_die);\n+  /* The inliner creates an extra BLOCK for the parameter setup,\n+     we want to merge that with the actual outermost BLOCK of the\n+     inlined function to avoid duplicate locals in consumers.\n+     Do that by doing the recursion to subblocks on the single subblock\n+     of STMT.  */\n+  bool unwrap_one = false;\n+  if (BLOCK_SUBBLOCKS (stmt) && !BLOCK_CHAIN (BLOCK_SUBBLOCKS (stmt)))\n+    {\n+      tree origin = block_ultimate_origin (BLOCK_SUBBLOCKS (stmt));\n+      if (origin\n+\t  && TREE_CODE (origin) == BLOCK\n+\t  && BLOCK_SUPERCONTEXT (origin) == decl)\n+\tunwrap_one = true;\n     }\n+  decls_for_scope (stmt, subr_die, !unwrap_one);\n+  if (unwrap_one)\n+    decls_for_scope (BLOCK_SUBBLOCKS (stmt), subr_die);\n }\n \n /* Generate a DIE for a field in a record, or structure.  CTX is required: see\n@@ -25663,8 +25635,7 @@ gen_block_die (tree stmt, dw_die_ref context_die)\n        still want to generate high/low PC attributes so output it.  */\n     must_output_die = 1;\n   else if (TREE_USED (stmt)\n-\t   || TREE_ASM_WRITTEN (stmt)\n-\t   || BLOCK_ABSTRACT (stmt))\n+\t   || TREE_ASM_WRITTEN (stmt))\n     {\n       /* Determine if this block directly contains any \"significant\"\n \t local declarations which we will need to output DIEs for.  */\n@@ -25697,23 +25668,7 @@ gen_block_die (tree stmt, dw_die_ref context_die)\n   if (must_output_die)\n     {\n       if (inlined_func)\n-\t{\n-\t  /* If STMT block is abstract, that means we have been called\n-\t     indirectly from dwarf2out_abstract_function.\n-\t     That function rightfully marks the descendent blocks (of\n-\t     the abstract function it is dealing with) as being abstract,\n-\t     precisely to prevent us from emitting any\n-\t     DW_TAG_inlined_subroutine DIE as a descendent\n-\t     of an abstract function instance. So in that case, we should\n-\t     not call gen_inlined_subroutine_die.\n-\n-\t     Later though, when cgraph asks dwarf2out to emit info\n-\t     for the concrete instance of the function decl into which\n-\t     the concrete instance of STMT got inlined, the later will lead\n-\t     to the generation of a DW_TAG_inlined_subroutine DIE.  */\n-\t  if (! BLOCK_ABSTRACT (stmt))\n-\t    gen_inlined_subroutine_die (stmt, context_die);\n-\t}\n+\tgen_inlined_subroutine_die (stmt, context_die);\n       else\n \tgen_lexical_block_die (stmt, context_die);\n     }"}, {"sha": "7df5c40a3a4e28b13e3fdff6497f2ee961411e0c", "filename": "gcc/tree-core.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/700adeb6fd65528758f9dbcd0aaf6345e14d312c/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/700adeb6fd65528758f9dbcd0aaf6345e14d312c/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=700adeb6fd65528758f9dbcd0aaf6345e14d312c", "patch": "@@ -1481,8 +1481,7 @@ struct GTY(()) tree_block {\n   struct tree_base base;\n   tree chain;\n \n-  unsigned abstract_flag : 1;\n-  unsigned block_num : 31;\n+  unsigned block_num;\n \n   location_t locus;\n   location_t end_locus;"}, {"sha": "81414d117e154bd393c2b96a03ebe1ff8213739e", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/700adeb6fd65528758f9dbcd0aaf6345e14d312c/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/700adeb6fd65528758f9dbcd0aaf6345e14d312c/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=700adeb6fd65528758f9dbcd0aaf6345e14d312c", "patch": "@@ -1124,9 +1124,6 @@ dump_block_node (pretty_printer *pp, tree block, int spc, dump_flags_t flags)\n   if (flags & TDF_ADDRESS)\n     pp_printf (pp, \"[%p] \", (void *) block);\n \n-  if (BLOCK_ABSTRACT (block))\n-    pp_string (pp, \"[abstract] \");\n-\n   if (TREE_ASM_WRITTEN (block))\n     pp_string (pp, \"[written] \");\n "}, {"sha": "3febde886d02543728ef604a2e89be787b629af8", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/700adeb6fd65528758f9dbcd0aaf6345e14d312c/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/700adeb6fd65528758f9dbcd0aaf6345e14d312c/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=700adeb6fd65528758f9dbcd0aaf6345e14d312c", "patch": "@@ -643,9 +643,8 @@ dump_scope_block (FILE *file, int indent, tree scope, dump_flags_t flags)\n   tree var, t;\n   unsigned int i;\n \n-  fprintf (file, \"\\n%*s{ Scope block #%i%s%s\",indent, \"\" , BLOCK_NUMBER (scope),\n-  \t   TREE_USED (scope) ? \"\" : \" (unused)\",\n-\t   BLOCK_ABSTRACT (scope) ? \" (abstract)\": \"\");\n+  fprintf (file, \"\\n%*s{ Scope block #%i%s\",indent, \"\" , BLOCK_NUMBER (scope),\n+  \t   TREE_USED (scope) ? \"\" : \" (unused)\");\n   if (LOCATION_LOCUS (BLOCK_SOURCE_LOCATION (scope)) != UNKNOWN_LOCATION)\n     {\n       expanded_location s = expand_location (BLOCK_SOURCE_LOCATION (scope));"}, {"sha": "bd98ed0b128f27dc7a94bb61b10dd2a36f25f405", "filename": "gcc/tree-streamer-in.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/700adeb6fd65528758f9dbcd0aaf6345e14d312c/gcc%2Ftree-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/700adeb6fd65528758f9dbcd0aaf6345e14d312c/gcc%2Ftree-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-in.c?ref=700adeb6fd65528758f9dbcd0aaf6345e14d312c", "patch": "@@ -398,7 +398,6 @@ static void\n unpack_ts_block_value_fields (struct data_in *data_in,\n \t\t\t      struct bitpack_d *bp, tree expr)\n {\n-  BLOCK_ABSTRACT (expr) = (unsigned) bp_unpack_value (bp, 1);\n   /* BLOCK_NUMBER is recomputed.  */\n   stream_input_location (&BLOCK_SOURCE_LOCATION (expr), bp, data_in);\n }"}, {"sha": "7f97c40277aaade545494216895aa529ad079ce9", "filename": "gcc/tree-streamer-out.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/700adeb6fd65528758f9dbcd0aaf6345e14d312c/gcc%2Ftree-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/700adeb6fd65528758f9dbcd0aaf6345e14d312c/gcc%2Ftree-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-out.c?ref=700adeb6fd65528758f9dbcd0aaf6345e14d312c", "patch": "@@ -344,7 +344,6 @@ static void\n pack_ts_block_value_fields (struct output_block *ob,\n \t\t\t    struct bitpack_d *bp, tree expr)\n {\n-  bp_pack_value (bp, BLOCK_ABSTRACT (expr), 1);\n   /* BLOCK_NUMBER is recomputed.  */\n   /* Stream BLOCK_SOURCE_LOCATION for the limited cases we can handle - those\n      that represent inlined function scopes."}, {"sha": "f87bc373f566224e8ff7a7619c8b9922a21588d2", "filename": "gcc/tree.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/700adeb6fd65528758f9dbcd0aaf6345e14d312c/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/700adeb6fd65528758f9dbcd0aaf6345e14d312c/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=700adeb6fd65528758f9dbcd0aaf6345e14d312c", "patch": "@@ -12142,11 +12142,6 @@ block_ultimate_origin (const_tree block)\n {\n   tree origin = BLOCK_ABSTRACT_ORIGIN (block);\n \n-  /* BLOCK_ABSTRACT_ORIGIN can point to itself; ignore that if\n-     we're trying to output the abstract instance of this function.  */\n-  if (BLOCK_ABSTRACT (block) && origin == block)\n-    return NULL_TREE;\n-\n   if (origin == NULL_TREE)\n     return NULL_TREE;\n   else"}, {"sha": "78b499a1d21268e2ef33e2b9b1aab53f49712995", "filename": "gcc/tree.def", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/700adeb6fd65528758f9dbcd0aaf6345e14d312c/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/700adeb6fd65528758f9dbcd0aaf6345e14d312c/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=700adeb6fd65528758f9dbcd0aaf6345e14d312c", "patch": "@@ -70,9 +70,6 @@ DEFTREECODE (TREE_VEC, \"tree_vec\", tcc_exceptional, 0)\n    could either point to another BLOCK node or it could point to a\n    FUNCTION_DECL node (e.g. in the case of a block representing the\n    outermost scope of a particular inlining of a function).\n-   BLOCK_ABSTRACT is nonzero if the block represents an abstract\n-   instance of a block (i.e. one which is nested within an abstract\n-   instance of an inline function).\n    TREE_ASM_WRITTEN is nonzero if the block was actually referenced\n    in the generated assembly.  */\n DEFTREECODE (BLOCK, \"block\", tcc_exceptional, 0)"}, {"sha": "2e45f9db2e34ddccbef87a57a335d03bdcb0f5a2", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/700adeb6fd65528758f9dbcd0aaf6345e14d312c/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/700adeb6fd65528758f9dbcd0aaf6345e14d312c/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=700adeb6fd65528758f9dbcd0aaf6345e14d312c", "patch": "@@ -1791,7 +1791,6 @@ extern tree maybe_wrap_with_location (tree, location_t);\n #define BLOCK_ABSTRACT_ORIGIN(NODE) (BLOCK_CHECK (NODE)->block.abstract_origin)\n #define BLOCK_ORIGIN(NODE) \\\n   (BLOCK_ABSTRACT_ORIGIN(NODE) ? BLOCK_ABSTRACT_ORIGIN(NODE) : (NODE))\n-#define BLOCK_ABSTRACT(NODE) (BLOCK_CHECK (NODE)->block.abstract_flag)\n #define BLOCK_DIE(NODE) (BLOCK_CHECK (NODE)->block.die)\n \n /* True if BLOCK has the same ranges as its BLOCK_SUPERCONTEXT.  */"}]}