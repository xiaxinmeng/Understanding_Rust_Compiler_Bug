{"sha": "134d3a2eaa33145cc91a8f9a8b9ad01c399923bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTM0ZDNhMmVhYTMzMTQ1Y2M5MWE4ZjlhOGI5YWQwMWMzOTk5MjNiYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-07-28T21:37:35Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-07-28T21:37:35Z"}, "message": "basic-block.h (EDGE_FREQUENCY): New macro.\n\n\t* basic-block.h (EDGE_FREQUENCY): New macro.\n\t* bb-reorder (fixup_reorder_chain): Set counts and frequencies\n\tfor new BB/edges.\n\t* flow.c (find_sub_basic_blocks): Likewise.\n\t(try_crossjump_to_edge): Likewise; use EDGE_FREQUENCY\n\t(redirect_edge_and_branch): Use EDGE_FREQUENCY.\n\n\t* predict.c (DEF_PREDICTOR): New argument FLAGS.\n\t(HITRATE): New macro.\n\t(PRED_FLAG_FIRST_MATCH): New constant.\n\t(predictor_info): New field flgags.\n\t(combine_predictions_for_insn): Use DS theory to combine\n\tprobabilities; set the edge probabilities when finished.\n\t(estimate_probability): Avoid duplicated matches\n\tof LOOP_BRANCH heuristics for nested loops; update comment.\n\t* predict.def: Add flags for each prediction, set probabilities\n\taccording to B&L paper.\n\t* predict.h (DEF_PREDICTOR): New argument FLAGS.\n\n\t* profile.c (compute_branch_probabilities):  Cleanup way the edge\n\tprobabilities are computed and REG_BR_PROB notes are dropped; if\n\tvalues does not match, emit error.\n\t(init_branch_prob): Do error instead of warning when profile driven\n\tfeedback is missing or corrupt.\n\nFrom-SVN: r44439", "tree": {"sha": "9dcbd6f10eb7084accad68aa621c0f3eb6a081d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9dcbd6f10eb7084accad68aa621c0f3eb6a081d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/134d3a2eaa33145cc91a8f9a8b9ad01c399923bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/134d3a2eaa33145cc91a8f9a8b9ad01c399923bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/134d3a2eaa33145cc91a8f9a8b9ad01c399923bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/134d3a2eaa33145cc91a8f9a8b9ad01c399923bb/comments", "author": null, "committer": null, "parents": [{"sha": "ffd1553440265622ceef4a5fa31d7fa706adb7ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffd1553440265622ceef4a5fa31d7fa706adb7ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffd1553440265622ceef4a5fa31d7fa706adb7ca"}], "stats": {"total": 292, "additions": 190, "deletions": 102}, "files": [{"sha": "6ed56dfa20d24d6540551ebd7db5113014517ce7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/134d3a2eaa33145cc91a8f9a8b9ad01c399923bb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/134d3a2eaa33145cc91a8f9a8b9ad01c399923bb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=134d3a2eaa33145cc91a8f9a8b9ad01c399923bb", "patch": "@@ -1,3 +1,30 @@\n+Sat Jul 28 23:35:22 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* basic-block.h (EDGE_FREQUENCY): New macro.\n+\t* bb-reorder (fixup_reorder_chain): Set counts and frequencies\n+\tfor new BB/edges.\n+\t* flow.c (find_sub_basic_blocks): Likewise.\n+\t(try_crossjump_to_edge): Likewise; use EDGE_FREQUENCY\n+\t(redirect_edge_and_branch): Use EDGE_FREQUENCY.\n+\n+\t* predict.c (DEF_PREDICTOR): New argument FLAGS.\n+\t(HITRATE): New macro.\n+\t(PRED_FLAG_FIRST_MATCH): New constant.\n+\t(predictor_info): New field flgags.\n+\t(combine_predictions_for_insn): Use DS theory to combine\n+\tprobabilities; set the edge probabilities when finished.\n+\t(estimate_probability): Avoid duplicated matches\n+\tof LOOP_BRANCH heuristics for nested loops; update comment.\n+\t* predict.def: Add flags for each prediction, set probabilities\n+\taccording to B&L paper.\n+\t* predict.h (DEF_PREDICTOR): New argument FLAGS.\n+\n+\t* profile.c (compute_branch_probabilities):  Cleanup way the edge\n+\tprobabilities are computed and REG_BR_PROB notes are dropped; if\n+\tvalues does not match, emit error.\n+\t(init_branch_prob): Do error instead of warning when profile driven\n+\tfeedback is missing or corrupt.\n+\n 2001-07-27  DJ Delorie  <dj@redhat.com>\n \n \t* ifcvt.c (noce_get_alt_condition): If the condition is a compare"}, {"sha": "bddba84b7e1150addbd77f36653a7e53a0cf6f8c", "filename": "gcc/basic-block.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/134d3a2eaa33145cc91a8f9a8b9ad01c399923bb/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/134d3a2eaa33145cc91a8f9a8b9ad01c399923bb/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=134d3a2eaa33145cc91a8f9a8b9ad01c399923bb", "patch": "@@ -511,6 +511,12 @@ struct edge_list\n #define BRANCH_EDGE(bb)\t\t\t((bb)->succ->flags & EDGE_FALLTHRU \\\n \t\t\t\t\t ? (bb)->succ->succ_next : (bb)->succ)\n \n+/* Return expected execution frequency of the edge E.  */\n+#define EDGE_FREQUENCY(e)\t\t(((e)->src->frequency \\\n+\t\t\t\t\t  * (e)->probability \\\n+\t\t\t\t\t  + REG_BR_PROB_BASE / 2) \\\n+\t\t\t\t\t / REG_BR_PROB_BASE)\n+\n struct edge_list * create_edge_list\tPARAMS ((void));\n void free_edge_list\t\t\tPARAMS ((struct edge_list *));\n void print_edge_list\t\t\tPARAMS ((FILE *, struct edge_list *));"}, {"sha": "ffbc45067644165543621c606b1506c545d3cb96", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/134d3a2eaa33145cc91a8f9a8b9ad01c399923bb/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/134d3a2eaa33145cc91a8f9a8b9ad01c399923bb/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=134d3a2eaa33145cc91a8f9a8b9ad01c399923bb", "patch": "@@ -719,6 +719,8 @@ fixup_reorder_chain ()\n       nb->global_live_at_start = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n       nb->global_live_at_end = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n       nb->local_set = 0;\n+      nb->count = e_fall->count;\n+      nb->frequency = EDGE_FREQUENCY (e_fall);\n \n       COPY_REG_SET (nb->global_live_at_start, bb->global_live_at_start);\n       COPY_REG_SET (nb->global_live_at_end, bb->global_live_at_start);\n@@ -735,6 +737,8 @@ fixup_reorder_chain ()\n       /* Link to new block.  */\n       make_edge (NULL, nb, e_fall->dest, 0);\n       redirect_edge_succ (e_fall, nb);\n+      nb->succ->count = e_fall->count;\n+      nb->succ->probability = REG_BR_PROB_BASE;\n \n       /* Don't process this new block.  */\n       bb = nb;"}, {"sha": "04b1b2d03426ea36c03bab3caef88a7cb9dd80c3", "filename": "gcc/flow.c", "status": "modified", "additions": 50, "deletions": 10, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/134d3a2eaa33145cc91a8f9a8b9ad01c399923bb/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/134d3a2eaa33145cc91a8f9a8b9ad01c399923bb/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=134d3a2eaa33145cc91a8f9a8b9ad01c399923bb", "patch": "@@ -713,6 +713,7 @@ find_sub_basic_blocks (bb)\n   rtx jump_insn = NULL_RTX;\n   edge falltru = 0;\n   basic_block first_bb = bb;\n+  int i;\n \n   if (insn == bb->end)\n     return;\n@@ -784,6 +785,48 @@ find_sub_basic_blocks (bb)\n   /* Now re-scan and wire in all edges.  This expect simple (conditional)\n      jumps at the end of each new basic blocks.  */\n   make_edges (NULL, first_bb->index, bb->index, 1);\n+\n+  /* Update branch probabilities.  Expect only (un)conditional jumps\n+     to be created with only the forward edges.  */\n+  for (i = first_bb->index; i <= bb->index; i++)\n+    {\n+      edge e,f;\n+      basic_block b = BASIC_BLOCK (i);\n+      if (b != first_bb)\n+\t{\n+\t  b->count = 0;\n+\t  b->frequency = 0;\n+\t  for (e = b->pred; e; e=e->pred_next)\n+\t    {\n+\t      b->count += e->count;\n+\t      b->frequency += EDGE_FREQUENCY (e);\n+\t    }\n+\t}\n+      if (b->succ && b->succ->succ_next && !b->succ->succ_next->succ_next)\n+\t{\n+\t  rtx note = find_reg_note (b->end, REG_BR_PROB, NULL);\n+\t  int probability;\n+\n+\t  if (!note)\n+\t    continue;\n+\t  probability = INTVAL (XEXP (find_reg_note (b->end,\n+\t\t\t\t\t\t     REG_BR_PROB,\n+\t\t\t\t\t\t     NULL), 0));\n+\t  e = BRANCH_EDGE (b);\n+\t  e->probability = probability;\n+\t  e->count = ((b->count * probability + REG_BR_PROB_BASE / 2)\n+\t\t      / REG_BR_PROB_BASE);\n+\t  f = FALLTHRU_EDGE (b);\n+\t  f->probability = REG_BR_PROB_BASE - probability;\n+\t  f->count = b->count - e->count;\n+\t}\n+      if (b->succ && !b->succ->succ_next)\n+\t{\n+\t  e = b->succ;\n+\t  e->probability = REG_BR_PROB_BASE;\n+\t  e->count = b->count;\n+\t}\n+    }\n }\n \n /* Find all basic blocks of the function whose first insn is F.\n@@ -1935,7 +1978,7 @@ redirect_edge_and_branch_force (e, target)\n   new_bb->succ = NULL;\n   new_bb->pred = new_edge;\n   new_bb->count = e->count;\n-  new_bb->frequency = e->probability * e->src->frequency / REG_BR_PROB_BASE;\n+  new_bb->frequency = EDGE_FREQUENCY (e);\n   new_bb->loop_depth = e->dest->loop_depth;\n \n   new_edge->flags = EDGE_FALLTHRU;\n@@ -2060,8 +2103,7 @@ split_edge (edge_in)\n   /* Wire them up.  */\n   bb->succ = edge_out;\n   bb->count = edge_in->count;\n-  bb->frequency = (edge_in->probability * edge_in->src->frequency\n-\t\t   / REG_BR_PROB_BASE);\n+  bb->frequency = EDGE_FREQUENCY (edge_in);\n \n   edge_in->flags &= ~EDGE_CRITICAL;\n \n@@ -3542,6 +3584,7 @@ try_crossjump_to_edge (mode, e1, e2)\n   edge s;\n   rtx last;\n   rtx label;\n+  rtx note;\n \n   /* Search backward through forwarder blocks.  We don't need to worry\n      about multiple entry or chained forwarders, as they will be optimized\n@@ -3640,15 +3683,13 @@ try_crossjump_to_edge (mode, e1, e2)\n \t{\n \t  s->dest->succ->count += s2->count;\n \t  s->dest->count += s2->count;\n-\t  s->dest->frequency += ((s->probability * s->src->frequency)\n-\t\t\t\t / REG_BR_PROB_BASE);\n+\t  s->dest->frequency += EDGE_FREQUENCY (s);\n \t}\n       if (forwarder_block_p (s2->dest))\n \t{\n \t  s2->dest->succ->count -= s2->count;\n \t  s2->dest->count -= s2->count;\n-\t  s2->dest->frequency -= ((s->probability * s->src->frequency)\n-\t\t\t\t  / REG_BR_PROB_BASE);\n+\t  s2->dest->frequency -= EDGE_FREQUENCY (s);\n \t}\n       if (!redirect_to->frequency && !src1->frequency)\n \ts->probability = (s->probability + s2->probability) / 2;\n@@ -3659,12 +3700,9 @@ try_crossjump_to_edge (mode, e1, e2)\n \t   / (redirect_to->frequency + src1->frequency));\n     }\n \n-  /* FIXME: enable once probabilities are fetched properly at CFG build.  */\n-#if 0\n   note = find_reg_note (redirect_to->end, REG_BR_PROB, 0);\n   if (note)\n     XEXP (note, 0) = GEN_INT (BRANCH_EDGE (redirect_to)->probability);\n-#endif\n \n   /* Edit SRC1 to go to REDIRECT_TO at NEWPOS1.  */\n \n@@ -3695,6 +3733,8 @@ try_crossjump_to_edge (mode, e1, e2)\n   while (src1->succ)\n     remove_edge (src1->succ);\n   make_edge (NULL, src1, redirect_to, 0);\n+  src1->succ->probability = REG_BR_PROB_BASE;\n+  src1->succ->count = src1->count;\n \n   return true;\n }"}, {"sha": "38b9a5b69285cd3b3bda9a22df7b880ea20e2e5f", "filename": "gcc/predict.c", "status": "modified", "additions": 35, "deletions": 9, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/134d3a2eaa33145cc91a8f9a8b9ad01c399923bb/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/134d3a2eaa33145cc91a8f9a8b9ad01c399923bb/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=134d3a2eaa33145cc91a8f9a8b9ad01c399923bb", "patch": "@@ -72,14 +72,23 @@ struct predictor_info\n   const char *name;\t/* Name used in the debugging dumps.  */\n   int hitrate;\t\t/* Expected hitrate used by\n \t\t\t   predict_insn_def call.  */\n+  int flags;\n };\n \n-#define DEF_PREDICTOR(ENUM, NAME, HITRATE) {NAME, HITRATE},\n+/* Use given predictor without Dempster-Shaffer theory if it matches\n+   using first_match heuristics.  */\n+#define PRED_FLAG_FIRST_MATCH 1\n+\n+/* Recompute hitrate in percent to our representation.  */\n+\n+#define HITRATE(VAL) ((int)((VAL) * REG_BR_PROB_BASE + 50) / 100)\n+\n+#define DEF_PREDICTOR(ENUM, NAME, HITRATE, FLAGS) {NAME, HITRATE, FLAGS},\n struct predictor_info predictor_info[] = {\n #include \"predict.def\"\n \n-  /* Upper bound on non-language-specific builtins. */\n-  {NULL, 0}\n+  /* Upper bound on predictors. */\n+  {NULL, 0, 0}\n };\n #undef DEF_PREDICTOR\n \n@@ -211,6 +220,8 @@ combine_predictions_for_insn (insn, bb)\n   rtx *pnote = &REG_NOTES (insn);\n   int best_probability = PROB_EVEN;\n   int best_predictor = END_PREDICTORS;\n+  int combined_probability = REG_BR_PROB_BASE / 2;\n+  int d;\n \n   if (rtl_dump_file)\n     fprintf (rtl_dump_file, \"Predictions for insn %i bb %i\\n\", INSN_UID (insn),\n@@ -230,16 +241,33 @@ combine_predictions_for_insn (insn, bb)\n \t  if (best_predictor > predictor)\n \t    best_probability = probability, best_predictor = predictor;\n \t  *pnote = XEXP (*pnote, 1);\n+\n+\t  d = (combined_probability * probability\n+\t       + (REG_BR_PROB_BASE - combined_probability)\n+\t       * (REG_BR_PROB_BASE - probability));\n+\t  /* An FP math to avoid overflows of 32bit integers.  */\n+\t  combined_probability = (((double)combined_probability) * probability\n+\t\t\t\t  * REG_BR_PROB_BASE / d + 0.5);\n \t}\n       else\n         pnote = &XEXP (*pnote, 1);\n     }\n+  if (predictor_info [best_predictor].flags & PRED_FLAG_FIRST_MATCH)\n+    combined_probability = best_probability;\n   dump_prediction (PRED_FIRST_MATCH, best_probability, bb);\n+  dump_prediction (PRED_COMBINED, combined_probability, bb);\n   if (!prob_note)\n     {\n       REG_NOTES (insn)\n \t= gen_rtx_EXPR_LIST (REG_BR_PROB,\n-\t\t\t     GEN_INT (best_probability), REG_NOTES (insn));\n+\t\t\t     GEN_INT (combined_probability), REG_NOTES (insn));\n+      /* Save the prediction into CFG in case we are seeing non-degenerated\n+\t conditional jump.  */\n+      if (bb->succ->succ_next)\n+\t{\n+\t  BRANCH_EDGE (bb)->probability = combined_probability;\n+\t  FALLTHRU_EDGE (bb)->probability = REG_BR_PROB_BASE - combined_probability;\n+\t}\n     }\n }\n \n@@ -280,7 +308,8 @@ estimate_probability (loops_info)\n \t      /* Loop branch heruistics - predict as taken an edge back to\n \t         a loop's head.  */\n \t      for (e = BASIC_BLOCK(j)->succ; e; e = e->succ_next)\n-\t\tif (e->dest == loops_info->array[i].header)\n+\t\tif (e->dest == loops_info->array[i].header\n+\t\t    && e->src == loops_info->array[i].latch)\n \t\t  {\n \t\t    header_found = 1;\n \t\t    predict_edge_def (e, PRED_LOOP_BRANCH, TAKEN);\n@@ -296,10 +325,7 @@ estimate_probability (loops_info)\n \t}\n     }\n \n-  /* Attempt to predict conditional jumps using a number of heuristics.\n-     For each conditional jump, we try each heuristic in a fixed order.\n-     If more than one heuristic applies to a particular branch, the first\n-     is used as the prediction for the branch.  */\n+  /* Attempt to predict conditional jumps using a number of heuristics.  */\n   for (i = 0; i < n_basic_blocks; i++)\n     {\n       basic_block bb = BASIC_BLOCK (i);"}, {"sha": "577f035e97ed985629a241f3b9d59734f27ecbac", "filename": "gcc/predict.def", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/134d3a2eaa33145cc91a8f9a8b9ad01c399923bb/gcc%2Fpredict.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/134d3a2eaa33145cc91a8f9a8b9ad01c399923bb/gcc%2Fpredict.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.def?ref=134d3a2eaa33145cc91a8f9a8b9ad01c399923bb", "patch": "@@ -36,47 +36,54 @@ Boston, MA 02111-1307, USA.  */\n    REG_BR_PROB_BASE / 2).  */\n    \n \n+/* An combined heuristics using Dempster-Shaffer theory.  */\n+DEF_PREDICTOR (PRED_COMBINED, \"combined\", PROB_ALWAYS, 0)\n+\n /* An combined heuristics using probability determined by first\n    matching heuristics from this list.  */\n-DEF_PREDICTOR (PRED_FIRST_MATCH, \"first match\", PROB_ALWAYS)\n+DEF_PREDICTOR (PRED_FIRST_MATCH, \"first match\", PROB_ALWAYS, 0)\n \n /* Mark unconditional jump as taken.  */\n-DEF_PREDICTOR (PRED_UNCONDITIONAL, \"unconditional jump\", PROB_ALWAYS)\n+DEF_PREDICTOR (PRED_UNCONDITIONAL, \"unconditional jump\", PROB_ALWAYS,\n+\t       PRED_FLAG_FIRST_MATCH)\n \n /* Use number of loop iterations determined by loop unroller to set\n-   probability.  */\n-DEF_PREDICTOR (PRED_LOOP_ITERATIONS, \"loop iterations\", PROB_ALWAYS)\n+   probability.  We don't want to use Dempster-Shaffer theory here,\n+   as the predictions is exact.  */\n+DEF_PREDICTOR (PRED_LOOP_ITERATIONS, \"loop iterations\", PROB_ALWAYS,\n+\t       PRED_FLAG_FIRST_MATCH)\n \n /* Hints dropped by user via __builtin_expect feature.  */\n-DEF_PREDICTOR (PRED_BUILTIN_EXPECT, \"__builtin_expect\", PROB_VERY_LIKELY)\n+DEF_PREDICTOR (PRED_BUILTIN_EXPECT, \"__builtin_expect\", PROB_VERY_LIKELY,\n+\t       PRED_FLAG_FIRST_MATCH)\n \n /* Branch to basic block containing call marked by noreturn attribute.  */\n-DEF_PREDICTOR (PRED_NORETURN, \"noreturn call\", PROB_ALWAYS)\n+DEF_PREDICTOR (PRED_NORETURN, \"noreturn call\", PROB_ALWAYS, 0)\n \n /* Loopback edge is taken.  */\n-DEF_PREDICTOR (PRED_LOOP_BRANCH, \"loop branch\", PROB_VERY_LIKELY)\n+DEF_PREDICTOR (PRED_LOOP_BRANCH, \"loop branch\", HITRATE (88), 0)\n \n /* Edge causing loop to terminate is probably not taken. */\n-DEF_PREDICTOR (PRED_LOOP_EXIT, \"loop exit\", PROB_LIKELY)\n+DEF_PREDICTOR (PRED_LOOP_EXIT, \"loop exit\", HITRATE (80), 0)\n \n /* Condition emitted by preconditiong code to ensure that variable\n    setting number of iterations is greater than initial value of iterator.  */\n-DEF_PREDICTOR (PRED_LOOP_CONDITION, \"loop condition\", PROB_VERY_LIKELY)\n+DEF_PREDICTOR (PRED_LOOP_CONDITION, \"loop condition\", PROB_VERY_LIKELY, 0)\n \n /* Preconditioning makes linear list of branches.  */\n-DEF_PREDICTOR (PRED_LOOP_PRECONDITIONING, \"loop preconditioning\", PROB_VERY_LIKELY)\n+DEF_PREDICTOR (PRED_LOOP_PRECONDITIONING, \"loop preconditioning\", PROB_VERY_LIKELY, 0)\n \n /* Copied condition for the first iteration of loop is probably true.  */\n-DEF_PREDICTOR (PRED_LOOP_HEADER, \"loop header\", PROB_LIKELY)\n+DEF_PREDICTOR (PRED_LOOP_HEADER, \"loop header\", HITRATE (75), 0)\n \n /* Pointers are usually not NULL.  */\n-DEF_PREDICTOR (PRED_POINTER, \"pointer\", PROB_LIKELY)\n+DEF_PREDICTOR (PRED_POINTER, \"pointer\", HITRATE (60), 0)\n \n /* NE is probable, EQ not etc...  */\n-DEF_PREDICTOR (PRED_OPCODE, \"opcode\", PROB_LIKELY)\n+DEF_PREDICTOR (PRED_OPCODE, \"opcode\", HITRATE (84), 0)\n \n /* Branch guarding call is probably taken.  */\n-DEF_PREDICTOR (PRED_CALL, \"call\", PROB_LIKELY)\n+DEF_PREDICTOR (PRED_CALL, \"call\", HITRATE (78), 0)\n \n /* Branch causing function to terminate is probably not taken.  */\n-DEF_PREDICTOR (PRED_ERROR_RETURN, \"error return\", PROB_LIKELY)\n+DEF_PREDICTOR (PRED_ERROR_RETURN, \"error return\", PROB_LIKELY, 0)"}, {"sha": "217021838846c278ebbcf8d6d4443d446a92e194", "filename": "gcc/predict.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/134d3a2eaa33145cc91a8f9a8b9ad01c399923bb/gcc%2Fpredict.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/134d3a2eaa33145cc91a8f9a8b9ad01c399923bb/gcc%2Fpredict.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.h?ref=134d3a2eaa33145cc91a8f9a8b9ad01c399923bb", "patch": "@@ -19,7 +19,7 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-#define DEF_PREDICTOR(ENUM, NAME, HITRATE) ENUM,\n+#define DEF_PREDICTOR(ENUM, NAME, HITRATE, FLAGS) ENUM,\n enum br_predictor\n {\n #include \"predict.def\""}, {"sha": "ddb621a6d19129db7c9372014dd018b45bf6d5ab", "filename": "gcc/profile.c", "status": "modified", "additions": 45, "deletions": 67, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/134d3a2eaa33145cc91a8f9a8b9ad01c399923bb/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/134d3a2eaa33145cc91a8f9a8b9ad01c399923bb/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=134d3a2eaa33145cc91a8f9a8b9ad01c399923bb", "patch": "@@ -216,7 +216,6 @@ compute_branch_probabilities ()\n   int hist_br_prob[20];\n   int num_never_executed;\n   int num_branches;\n-  int bad_counts = 0;\n   struct bb_info *bb_infos;\n \n   /* Attach extra info block to each bb.  */\n@@ -418,84 +417,63 @@ compute_branch_probabilities ()\n     {\n       basic_block bb = BASIC_BLOCK (i);\n       edge e;\n-      rtx insn;\n       gcov_type total;\n       rtx note;\n \n       total = bb->count;\n-      if (!total)\n-\tcontinue;\n-      for (e = bb->succ; e; e = e->succ_next)\n-\t{\n-\t  if (any_condjump_p (e->src->end)\n-\t      && !EDGE_INFO (e)->ignore\n-\t      && !(e->flags & (EDGE_ABNORMAL | EDGE_ABNORMAL_CALL | EDGE_FAKE)))\n-\t    {\n-\t      int prob;\n-\t      /* This calculates the branch probability as an integer between\n-\t\t 0 and REG_BR_PROB_BASE, properly rounded to the nearest\n-\t\t integer.  Perform the arithmetic in double to avoid\n-\t\t overflowing the range of ints.  */\n-\t      if (total == 0)\n-\t\tprob = -1;\n-\t      else\n-\t\t{\n-\t\t  prob = (((double)e->count * REG_BR_PROB_BASE)\n-\t\t\t  + (total >> 1)) / total;\n-\t\t  if (prob < 0 || prob > REG_BR_PROB_BASE)\n-\t\t    {\n-\t\t      if (rtl_dump_file)\n-\t\t\tfprintf (rtl_dump_file, \"bad count: prob for %d-%d thought to be %d (forcibly normalized)\\n\",\n-\t\t\t\t e->src->index, e->dest->index, prob);\n-\n-\t\t      bad_counts = 1;\n-\t\t      prob = REG_BR_PROB_BASE / 2;\n-\t\t    }\n-\t\t  \n-\t\t  /* Match up probability with JUMP pattern.  */\n-\t\t  if (e->flags & EDGE_FALLTHRU)\n-\t\t    prob = REG_BR_PROB_BASE - prob;\n-\t\t}\n-\t      \n-\t      if (prob == -1)\n-\t\tnum_never_executed++;\n-\t      else\n+      if (total)\n+\tfor (e = bb->succ; e; e = e->succ_next)\n+\t  {\n+\t      e->probability = (e->count * REG_BR_PROB_BASE + total / 2) / total;\n+\t      if (e->probability < 0 || e->probability > REG_BR_PROB_BASE)\n \t\t{\n-\t\t  int index = prob * 20 / REG_BR_PROB_BASE;\n-\t\t  if (index == 20)\n-\t\t    index = 19;\n-\t\t  hist_br_prob[index]++;\n+\t\t  error (\"Corrupted profile info: prob for %d-%d thought to be %d\\n\",\n+\t\t\t e->src->index, e->dest->index, e->probability);\n+\t\t  e->probability = REG_BR_PROB_BASE / 2;\n \t\t}\n-\t      num_branches++;\n-\t      \n-\t      note = find_reg_note (e->src->end, REG_BR_PROB, 0);\n+\t  }\n+      if (any_condjump_p (bb->end)\n+\t  && bb->succ->succ_next)\n+\t{\n+\t  int prob;\n+\t  edge e;\n+\n+\t  if (total == 0)\n+\t    prob = -1;\n+\t  else\n+\t  if (total == -1)\n+\t    num_never_executed++;\n+\t  else\n+\t    {\n+\t      int index;\n+\n+\t      /* Find the branch edge.  It is possible that we do have fake\n+\t\t edges here.  */\n+\t      for (e = bb->succ; e->flags & (EDGE_FAKE | EDGE_FALLTHRU);\n+\t\t   e = e->succ_next)\n+\t\tcontinue; /* Loop body has been intentionally left blank.  */\n+\n+\t      prob = e->probability;\n+\t      index = prob * 20 / REG_BR_PROB_BASE;\n+\t  \n+\t      if (index == 20)\n+\t\tindex = 19;\n+\t      hist_br_prob[index]++;\n+\n+\t      note = find_reg_note (bb->end, REG_BR_PROB, 0);\n \t      /* There may be already note put by some other pass, such\n-\t         as builtin_expect expander.  */\n+\t\t as builtin_expect expander.  */\n \t      if (note)\n \t\tXEXP (note, 0) = GEN_INT (prob);\n \t      else\n-\t\tREG_NOTES (e->src->end)\n+\t\tREG_NOTES (bb->end)\n \t\t  = gen_rtx_EXPR_LIST (REG_BR_PROB, GEN_INT (prob),\n-\t\t\t\t       REG_NOTES (e->src->end));\n+\t\t\t\t       REG_NOTES (bb->end));\n \t    }\n+\t  num_branches++;\n+\t  \n \t}\n-\n-      /* Add a REG_EXEC_COUNT note to the first instruction of this block.  */\n-      insn = next_nonnote_insn (bb->head);\n-\n-      if (GET_CODE (bb->head) == CODE_LABEL)\n-\tinsn = next_nonnote_insn (insn);\n-\n-      /* Avoid crash on empty basic blocks.  */\n-      if (insn && INSN_P (insn))\n-\tREG_NOTES (insn)\n-\t  = gen_rtx_EXPR_LIST (REG_EXEC_COUNT, GEN_INT (total),\n-\t\t\t       REG_NOTES (insn));\n     }\n-  \n-  /* This should never happen.  */\n-  if (bad_counts)\n-    warning (\"Arc profiling: some edge counts were bad.\");\n \n   if (rtl_dump_file)\n     {\n@@ -1004,10 +982,10 @@ end_branch_prob ()\n \t     flag will not be set until an attempt is made to read\n \t     past the end of the file. */\n \t  if (feof (da_file))\n-\t    warning (\".da file contents exhausted too early\\n\");\n+\t    error (\".da file contents exhausted too early\");\n \t  /* Should be at end of file now.  */\n \t  if (__read_long (&temp, da_file, 8) == 0)\n-\t    warning (\".da file contents not exhausted\\n\");\n+\t    error (\".da file contents not exhausted\");\n \t  fclose (da_file);\n \t}\n     }"}]}