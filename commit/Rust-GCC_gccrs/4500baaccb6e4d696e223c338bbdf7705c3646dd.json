{"sha": "4500baaccb6e4d696e223c338bbdf7705c3646dd", "node_id": "C_kwDOANBUbNoAKDQ1MDBiYWFjY2I2ZTRkNjk2ZTIyM2MzMzhiYmRmNzcwNWMzNjQ2ZGQ", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-12-05T10:17:42Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-12-05T10:17:42Z"}, "message": "range-op-float: Fix up multiplication and division reverse operation [PR107879]\n\nWhile for the normal cases it seems to be correct to implement\nreverse multiplication (op1_range/op2_range) through division\nwith float_binary_op_range_finish, reverse division (op1_range)\nthrough multiplication with float_binary_op_range_finish or\n(op2_range) through division with float_binary_op_range_finish,\nas e.g. following testcase shows for the corner cases it is\nincorrect.\nSay on the testcase we are doing reverse multiplication, we\nhave [-0., 0.] range (no NAN) on lhs and VARYING on op1 (or op2).\nWe implement that through division, because x from\nlhs = x * op2\nis\nx = lhs / op2\nFor the division, [-0., 0.] / VARYING is computed (IMHO correctly)\nas [-0., 0.] +-NAN, because 0 / anything but 0 or NAN is still\n0 and 0 / 0 is NAN and ditto 0 / NAN.  And then we just\nfloat_binary_op_range_finish, which figures out that because lhs\ncan't be NAN, neither operand can be NAN.  So, the end range is\n[-0., 0.].  But that is not correct for the reverse multiplication.\nWhen the result is 0, if op2 can be zero, then x can be anything\n(VARYING), to be precise anything but INF (unless result can be NAN),\nbecause anything * 0 is 0 (or NAN for INF).  While if op2 must be\nnon-zero, then x must be 0.  Of course the sign logic\n(signbit(x) = signbit(lhs) ^ signbit(op2)) still holds, so it actually\nisn't full VARYING if both lhs and op2 have known sign bits.\nAnd going through other corner cases one by one shows other differences\nbetween what we compute for the corresponding forward operation and\nwhat we should compute for the reverse operations.\nThe following patch is slightly conservative and includes INF\n(in case of result including 0 and not NAN) in the ranges or\n0 in the ranges (in case of result including INF and not NAN).\nThe latter is what happens anyway because we flush denormals to 0,\nand the former just not to deal with all the corner cases.\nSo, the end test is that for reverse multiplication and division\nop2_range the cases we need to adjust to VARYING or VARYING positive\nor VARYING negative are if lhs and op? ranges both contain 0,\nor both contain some infinity, while for division op1_range the\ncorner case is if lhs range contains 0 and op2 range contains INF or vice\nversa.  Otherwise I believe ranges from the corresponding operation\nare ok, or could be slightly more conservative (e.g. for\nreverse multiplication, if op? range is singleton INF and lhs\nrange doesn't include any INF, then x's range should be UNDEFINED or\nknown NAN (depending on if lhs can be NAN), while the division computes\n[-0., 0.] +-NAN; or similarly if op? range is only 0 and lhs range\ndoesn't include 0, division would compute +INF +-NAN, or -INF +-NAN,\nor (for lack of multipart franges -INF +INF +-NAN just VARYING +-NAN),\nwhile again it is UNDEFINED or known NAN.\n\nOh, and I found by code inspection wrong condition for the division's\nknown NAN result, due to thinko it would trigger not just when\nboth operands are known to be 0 or both are known to be INF, but\nwhen either both are known to be 0, or at least one is known to be INF.\n\n2022-12-05  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/107879\n\t* range-op-float.cc (foperator_mult::op1_range): If both\n\tlhs and op2 ranges contain zero or both ranges contain\n\tsome infinity, set r range to zero_to_inf_range depending on\n\tsignbit_known_p.\n\t(foperator_div::op2_range): Similarly for lhs and op1 ranges.\n\t(foperator_div::op1_range): If lhs range contains zero and op2\n\trange contains some infinity or vice versa, set r range to\n\tzero_to_inf_range depending on signbit_known_p.\n\t(foperator_div::rv_fold): Fix up condition for returning known NAN.", "tree": {"sha": "ece92673487c84aad120f4cde8cac6b0ae07a3c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ece92673487c84aad120f4cde8cac6b0ae07a3c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4500baaccb6e4d696e223c338bbdf7705c3646dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4500baaccb6e4d696e223c338bbdf7705c3646dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4500baaccb6e4d696e223c338bbdf7705c3646dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4500baaccb6e4d696e223c338bbdf7705c3646dd/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44c8402d35160515b3c09fd2bc239587e0c32a2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44c8402d35160515b3c09fd2bc239587e0c32a2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44c8402d35160515b3c09fd2bc239587e0c32a2b"}], "stats": {"total": 99, "additions": 91, "deletions": 8}, "files": [{"sha": "e9455a929ae7a4b2267d55a4792f013e44596bf0", "filename": "gcc/range-op-float.cc", "status": "modified", "additions": 66, "deletions": 8, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4500baaccb6e4d696e223c338bbdf7705c3646dd/gcc%2Frange-op-float.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4500baaccb6e4d696e223c338bbdf7705c3646dd/gcc%2Frange-op-float.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op-float.cc?ref=4500baaccb6e4d696e223c338bbdf7705c3646dd", "patch": "@@ -2143,8 +2143,30 @@ class foperator_mult : public foperator_mult_div_base\n     range_op_handler rdiv (RDIV_EXPR, type);\n     if (!rdiv)\n       return false;\n-    return float_binary_op_range_finish (rdiv.fold_range (r, type, lhs, op2),\n-\t\t\t\t\t r, type, lhs);\n+    bool ret = rdiv.fold_range (r, type, lhs, op2);\n+    if (ret == false)\n+      return false;\n+    const REAL_VALUE_TYPE &lhs_lb = lhs.lower_bound ();\n+    const REAL_VALUE_TYPE &lhs_ub = lhs.upper_bound ();\n+    const REAL_VALUE_TYPE &op2_lb = op2.lower_bound ();\n+    const REAL_VALUE_TYPE &op2_ub = op2.upper_bound ();\n+    if ((contains_zero_p (lhs_lb, lhs_ub) && contains_zero_p (op2_lb, op2_ub))\n+\t|| ((real_isinf (&lhs_lb) || real_isinf (&lhs_ub))\n+\t    && (real_isinf (&op2_lb) || real_isinf (&op2_ub))))\n+      {\n+\t// If both lhs and op2 could be zeros or both could be infinities,\n+\t// we don't know anything about op1 except maybe for the sign\n+\t// and perhaps if it can be NAN or not.\n+\tREAL_VALUE_TYPE lb, ub;\n+\tint signbit_known = signbit_known_p (lhs_lb, lhs_ub, op2_lb, op2_ub);\n+\tzero_to_inf_range (lb, ub, signbit_known);\n+\tr.set (type, lb, ub);\n+      }\n+    // Otherwise, if op2 is a singleton INF and lhs doesn't include INF,\n+    // or if lhs must be zero and op2 doesn't include zero, it would be\n+    // UNDEFINED, while rdiv.fold_range computes a zero or singleton INF\n+    // range.  Those are supersets of UNDEFINED, so let's keep that way.\n+    return float_binary_op_range_finish (ret, r, type, lhs);\n   }\n   virtual bool op2_range (frange &r, tree type,\n \t\t\t  const frange &lhs,\n@@ -2271,9 +2293,27 @@ class foperator_div : public foperator_mult_div_base\n   {\n     if (lhs.undefined_p ())\n       return false;\n-    return float_binary_op_range_finish (fop_mult.fold_range (r, type, lhs,\n-\t\t\t\t\t\t\t      op2),\n-\t\t\t\t\t r, type, lhs);\n+    bool ret = fop_mult.fold_range (r, type, lhs, op2);\n+    if (!ret)\n+      return ret;\n+    const REAL_VALUE_TYPE &lhs_lb = lhs.lower_bound ();\n+    const REAL_VALUE_TYPE &lhs_ub = lhs.upper_bound ();\n+    const REAL_VALUE_TYPE &op2_lb = op2.lower_bound ();\n+    const REAL_VALUE_TYPE &op2_ub = op2.upper_bound ();\n+    if ((contains_zero_p (lhs_lb, lhs_ub)\n+\t && (real_isinf (&op2_lb) || real_isinf (&op2_ub)))\n+\t|| ((contains_zero_p (op2_lb, op2_ub))\n+\t    && (real_isinf (&lhs_lb) || real_isinf (&lhs_ub))))\n+      {\n+\t// If both lhs could be zero and op2 infinity or vice versa,\n+\t// we don't know anything about op1 except maybe for the sign\n+\t// and perhaps if it can be NAN or not.\n+\tREAL_VALUE_TYPE lb, ub;\n+\tint signbit_known = signbit_known_p (lhs_lb, lhs_ub, op2_lb, op2_ub);\n+\tzero_to_inf_range (lb, ub, signbit_known);\n+\tr.set (type, lb, ub);\n+      }\n+    return float_binary_op_range_finish (ret, r, type, lhs);\n   }\n   virtual bool op2_range (frange &r, tree type,\n \t\t\t  const frange &lhs,\n@@ -2282,8 +2322,26 @@ class foperator_div : public foperator_mult_div_base\n   {\n     if (lhs.undefined_p ())\n       return false;\n-    return float_binary_op_range_finish (fold_range (r, type, op1, lhs),\n-\t\t\t\t\t r, type, lhs);\n+    bool ret = fold_range (r, type, op1, lhs);\n+    if (!ret)\n+      return ret;\n+    const REAL_VALUE_TYPE &lhs_lb = lhs.lower_bound ();\n+    const REAL_VALUE_TYPE &lhs_ub = lhs.upper_bound ();\n+    const REAL_VALUE_TYPE &op1_lb = op1.lower_bound ();\n+    const REAL_VALUE_TYPE &op1_ub = op1.upper_bound ();\n+    if ((contains_zero_p (lhs_lb, lhs_ub) && contains_zero_p (op1_lb, op1_ub))\n+\t|| ((real_isinf (&lhs_lb) || real_isinf (&lhs_ub))\n+\t    && (real_isinf (&op1_lb) || real_isinf (&op1_ub))))\n+      {\n+\t// If both lhs and op1 could be zeros or both could be infinities,\n+\t// we don't know anything about op2 except maybe for the sign\n+\t// and perhaps if it can be NAN or not.\n+\tREAL_VALUE_TYPE lb, ub;\n+\tint signbit_known = signbit_known_p (lhs_lb, lhs_ub, op1_lb, op1_ub);\n+\tzero_to_inf_range (lb, ub, signbit_known);\n+\tr.set (type, lb, ub);\n+      }\n+    return float_binary_op_range_finish (ret, r, type, lhs);\n   }\n private:\n   void rv_fold (REAL_VALUE_TYPE &lb, REAL_VALUE_TYPE &ub, bool &maybe_nan,\n@@ -2296,7 +2354,7 @@ class foperator_div : public foperator_mult_div_base\n   {\n     // +-0.0 / +-0.0 or +-INF / +-INF is a known NAN.\n     if ((zero_p (lh_lb, lh_ub) && zero_p (rh_lb, rh_ub))\n-\t|| (singleton_inf_p (lh_lb, lh_ub) || singleton_inf_p (rh_lb, rh_ub)))\n+\t|| (singleton_inf_p (lh_lb, lh_ub) && singleton_inf_p (rh_lb, rh_ub)))\n       {\n \treal_nan (&lb, \"\", 0, TYPE_MODE (type));\n \tub = lb;"}, {"sha": "2aabe8e3a0cfda4c47431d61ab6fb2299494ab6a", "filename": "gcc/testsuite/gcc.c-torture/execute/pr107879.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4500baaccb6e4d696e223c338bbdf7705c3646dd/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr107879.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4500baaccb6e4d696e223c338bbdf7705c3646dd/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr107879.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr107879.c?ref=4500baaccb6e4d696e223c338bbdf7705c3646dd", "patch": "@@ -0,0 +1,25 @@\n+/* PR tree-optimization/107879 */\n+\n+__attribute__((noipa)) static double\n+foo (double *y)\n+{\n+  volatile int ph = 0;\n+  volatile double vf = 1.0;\n+  double factor = vf;\n+  double x = - (double) ph * factor;\n+  if (x == 0)\n+    *y = 1.0;\n+  else\n+    *y = 1.0 / x;\n+  double w = 2.0 * x / factor;\n+  double omww = 1 - w;\n+  return omww > 0.0 ? omww : 0.0;\n+}\n+\n+int\n+main ()\n+{\n+  double y = 42.0;\n+  if (foo (&y) != 1.0)\n+    __builtin_abort ();\n+}"}]}