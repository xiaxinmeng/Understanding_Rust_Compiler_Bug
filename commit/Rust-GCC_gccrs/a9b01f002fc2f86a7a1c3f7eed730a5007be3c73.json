{"sha": "a9b01f002fc2f86a7a1c3f7eed730a5007be3c73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTliMDFmMDAyZmMyZjg2YTdhMWMzZjdlZWQ3MzBhNTAwN2JlM2M3Mw==", "commit": {"author": {"name": "David Edelsohn", "email": "dje.gcc@gmail.com", "date": "2013-01-02T02:04:42Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2013-01-02T02:04:42Z"}, "message": "simple-object-xcoff.c: New file.\n\n        * simple-object-xcoff.c: New file.\n        * Makefile.in: Add it to build machinery.\n        * simple-object-common.h (simple_object_xcoff_functions): Declare.\n        * simple-object.c (format_functions): Add\n        simple_object_xcoff_functions.\n\nFrom-SVN: r194774", "tree": {"sha": "5d68e288641c21b158dc93c04378fc96b59bd30b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d68e288641c21b158dc93c04378fc96b59bd30b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9b01f002fc2f86a7a1c3f7eed730a5007be3c73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9b01f002fc2f86a7a1c3f7eed730a5007be3c73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9b01f002fc2f86a7a1c3f7eed730a5007be3c73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9b01f002fc2f86a7a1c3f7eed730a5007be3c73/comments", "author": {"login": "edelsohn", "id": 667700, "node_id": "MDQ6VXNlcjY2NzcwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/667700?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edelsohn", "html_url": "https://github.com/edelsohn", "followers_url": "https://api.github.com/users/edelsohn/followers", "following_url": "https://api.github.com/users/edelsohn/following{/other_user}", "gists_url": "https://api.github.com/users/edelsohn/gists{/gist_id}", "starred_url": "https://api.github.com/users/edelsohn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edelsohn/subscriptions", "organizations_url": "https://api.github.com/users/edelsohn/orgs", "repos_url": "https://api.github.com/users/edelsohn/repos", "events_url": "https://api.github.com/users/edelsohn/events{/privacy}", "received_events_url": "https://api.github.com/users/edelsohn/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0331d94dae2ed9a837acb9abcd51aafc7d2dd7fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0331d94dae2ed9a837acb9abcd51aafc7d2dd7fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0331d94dae2ed9a837acb9abcd51aafc7d2dd7fb"}], "stats": {"total": 921, "additions": 919, "deletions": 2}, "files": [{"sha": "0875603bc75113b3e013075a43992300dc6d6178", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9b01f002fc2f86a7a1c3f7eed730a5007be3c73/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9b01f002fc2f86a7a1c3f7eed730a5007be3c73/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=a9b01f002fc2f86a7a1c3f7eed730a5007be3c73", "patch": "@@ -1,3 +1,11 @@\n+2013-01-01  David Edelsohn  <dje.gcc@gmail.com>\n+\n+\t* simple-object-xcoff.c: New file.\n+\t* Makefile.in: Add it to build machinery.\n+\t* simple-object-common.h (simple_object_xcoff_functions): Declare.\n+\t* simple-object.c (format_functions): Add\n+\tsimple_object_xcoff_functions.\n+\n 2012-11-10  Jason Merrill  <jason@redhat.com>\n \n \t* cp-demangle.c (d_unqualified_name): Handle abi tags here."}, {"sha": "f6a3ebd6d3d6ecec8516bc27f23bcc07f44250d1", "filename": "libiberty/Makefile.in", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9b01f002fc2f86a7a1c3f7eed730a5007be3c73/libiberty%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9b01f002fc2f86a7a1c3f7eed730a5007be3c73/libiberty%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FMakefile.in?ref=a9b01f002fc2f86a7a1c3f7eed730a5007be3c73", "patch": "@@ -146,7 +146,7 @@ CFILES = alloca.c argv.c asprintf.c atexit.c\t\t\t\t\\\n \trandom.c regex.c rename.c rindex.c\t\t\t\t\\\n \tsafe-ctype.c setenv.c setproctitle.c sha1.c sigsetmask.c        \\\n \t simple-object.c simple-object-coff.c simple-object-elf.c\t\\\n-\t simple-object-mach-o.c\t\t\t\t\t\t\\\n+\t simple-object-mach-o.c simple-object-xcoff.c\t\t\t\\\n          snprintf.c sort.c\t\t\t\t\t\t\\\n \t spaces.c splay-tree.c stack-limit.c stpcpy.c stpncpy.c\t\t\\\n \t strcasecmp.c strchr.c strdup.c strerror.c strncasecmp.c\t\\\n@@ -183,6 +183,7 @@ REQUIRED_OFILES =\t\t\t\t\t\t\t\\\n \t./safe-ctype.$(objext)\t\t\t\t\t\t\\\n \t./simple-object.$(objext) ./simple-object-coff.$(objext)\t\\\n \t./simple-object-elf.$(objext) ./simple-object-mach-o.$(objext)\t\\\n+\t./simple-object-xcoff.$(objext)\t\t\t\t\t\\\n \t./sort.$(objext) ./spaces.$(objext)\t\t\t\t\\\n \t./splay-tree.$(objext) ./stack-limit.$(objext)\t\t\t\\\n \t./strerror.$(objext) ./strsignal.$(objext)\t\t\t\\\n@@ -1009,6 +1010,14 @@ $(CONFIGURED_OFILES): stamp-picdir\n \telse true; fi\n \t$(COMPILE.c) $(srcdir)/simple-object-mach-o.c $(OUTPUT_OPTION)\n \n+./simple-object-xcoff.$(objext): $(srcdir)/simple-object-xcoff.c config.h \\\n+\t$(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h \\\n+\t$(srcdir)/simple-object-common.h $(INCDIR)/simple-object.h\n+\tif [ x\"$(PICFLAG)\" != x ]; then \\\n+\t  $(COMPILE.c) $(PICFLAG) $(srcdir)/simple-object-xcoff.c -o pic/$@; \\\n+\telse true; fi\n+\t$(COMPILE.c) $(srcdir)/simple-object-xcoff.c $(OUTPUT_OPTION)\n+\n ./simple-object.$(objext): $(srcdir)/simple-object.c config.h \\\n \t$(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h \\\n \t$(srcdir)/simple-object-common.h $(INCDIR)/simple-object.h"}, {"sha": "bef9b08cef852e16612c1e92cac34c059175e116", "filename": "libiberty/simple-object-common.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9b01f002fc2f86a7a1c3f7eed730a5007be3c73/libiberty%2Fsimple-object-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9b01f002fc2f86a7a1c3f7eed730a5007be3c73/libiberty%2Fsimple-object-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsimple-object-common.h?ref=a9b01f002fc2f86a7a1c3f7eed730a5007be3c73", "patch": "@@ -148,6 +148,7 @@ struct simple_object_functions\n extern const struct simple_object_functions simple_object_coff_functions;\n extern const struct simple_object_functions simple_object_elf_functions;\n extern const struct simple_object_functions simple_object_mach_o_functions;\n+extern const struct simple_object_functions simple_object_xcoff_functions;\n \n /* Read SIZE bytes from DESCRIPTOR at file offset OFFSET into BUFFER.\n    Return non-zero on success.  On failure return 0 and set *ERRMSG"}, {"sha": "ff1dc18079eb3a510362d494cf590a55d9262997", "filename": "libiberty/simple-object-xcoff.c", "status": "added", "additions": 898, "deletions": 0, "changes": 898, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9b01f002fc2f86a7a1c3f7eed730a5007be3c73/libiberty%2Fsimple-object-xcoff.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9b01f002fc2f86a7a1c3f7eed730a5007be3c73/libiberty%2Fsimple-object-xcoff.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsimple-object-xcoff.c?ref=a9b01f002fc2f86a7a1c3f7eed730a5007be3c73", "patch": "@@ -0,0 +1,898 @@\n+/* simple-object-coff.c -- routines to manipulate XCOFF object files.\n+   Copyright 2013 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google and David Edelsohn, IBM.\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 51 Franklin Street - Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include \"libiberty.h\"\n+#include \"simple-object.h\"\n+\n+#include <errno.h>\n+#include <stddef.h>\n+\n+#ifdef HAVE_STDLIB_H\n+#include <stdlib.h>\n+#endif\n+\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n+#ifdef HAVE_STRING_H\n+#include <string.h>\n+#endif\n+\n+#ifdef HAVE_INTTYPES_H\n+#include <inttypes.h>\n+#endif\n+\n+#include \"simple-object-common.h\"\n+\n+/* XCOFF structures and constants.  */\n+\n+/* XCOFF file header.  */\n+\n+struct external_filehdr\n+{\n+  unsigned char f_magic[2];\t/* magic number\t\t\t*/\n+  unsigned char f_nscns[2];\t/* number of sections\t\t*/\n+  unsigned char f_timdat[4];\t/* time & date stamp\t\t*/\n+  union\n+  {\n+    struct\n+    {\n+      unsigned char f_symptr[4];\t/* file pointer to symtab\t*/\n+      unsigned char f_nsyms[4];\t/* number of symtab entries\t*/\n+      unsigned char f_opthdr[2];\t/* sizeof(optional hdr)\t\t*/\n+      unsigned char f_flags[2];\t/* flags\t\t\t*/\n+    } xcoff32;\n+    struct\n+    {\n+      unsigned char f_symptr[8];\t/* file pointer to symtab\t*/\n+      unsigned char f_opthdr[2];\t/* sizeof(optional hdr)\t\t*/\n+      unsigned char f_flags[2];\t/* flags\t\t\t*/\n+      unsigned char f_nsyms[4];\t/* number of symtab entries\t*/\n+    } xcoff64;\n+  } u;\n+};\n+\n+/* Bits for filehdr f_flags field.  */\n+\n+#define F_EXEC\t\t\t(0x0002)\n+\n+/* The known values of f_magic in an XCOFF file header.  */\n+\n+#define U802WRMAGIC 0730        /* Writeable text segments.  */\n+#define U802ROMAGIC 0735        /* Readonly sharable text segments.  */\n+#define U802TOCMAGIC 0737       /* Readonly text segments and TOC.  */\n+#define U803XTOCMAGIC 0757      /* Aix 4.3 64-bit XCOFF.  */\n+#define U64_TOCMAGIC 0767       /* AIX 5+ 64-bit XCOFF.  */\n+\n+/* XCOFF section header.  */\n+\n+struct external_scnhdr\n+{\n+  unsigned char s_name[8];\t/* section name\t\t\t\t*/\n+  union\n+  {\n+    struct\n+    {\n+      unsigned char s_paddr[4];\t/* physical address, aliased s_nlib \t*/\n+      unsigned char s_vaddr[4];\t/* virtual address\t\t\t*/\n+      unsigned char s_size[4];\t/* section size\t\t\t\t*/\n+      unsigned char s_scnptr[4];\t/* file ptr to raw data for section */\n+      unsigned char s_relptr[4];\t/* file ptr to relocation\t*/\n+      unsigned char s_lnnoptr[4];\t/* file ptr to line numbers\t*/\n+      unsigned char s_nreloc[2];\t/* number of relocation entries\t*/\n+      unsigned char s_nlnno[2];\t/* number of line number entries\t*/\n+      unsigned char s_flags[4];\t/* flags\t\t\t\t*/\n+    } xcoff32;\n+    struct\n+    {\n+      unsigned char s_paddr[8];\t/* physical address, aliased s_nlib \t*/\n+      unsigned char s_vaddr[8];\t/* virtual address\t\t\t*/\n+      unsigned char s_size[8];\t/* section size\t\t\t\t*/\n+      unsigned char s_scnptr[8];\t/* file ptr to raw data for section */\n+      unsigned char s_relptr[8];\t/* file ptr to relocation\t*/\n+      unsigned char s_lnnoptr[8];\t/* file ptr to line numbers\t*/\n+      unsigned char s_nreloc[4];\t/* number of relocation entries\t*/\n+      unsigned char s_nlnno[4];\t/* number of line number entries\t*/\n+      unsigned char s_flags[4];\t/* flags\t\t\t\t*/\n+    } xcoff64;\n+  } u;\n+};\n+\n+#define SCNHSZ32\t(40)\n+#define SCNHSZ64\t(68)\n+\n+/* The length of the s_name field in struct external_scnhdr.  */\n+\n+#define SCNNMLEN\t(8)\n+\n+/* Bits for scnhdr s_flags field.  */\n+\n+#define STYP_DATA\t\t\t0x40\n+\n+/* XCOFF symbol table entry.  */\n+\n+\n+#define N_SYMNMLEN\t(8)\t/* # characters in a symbol name\t*/\n+\n+/* The format of an XCOFF symbol-table entry.  */\n+struct external_syment\n+{\n+  union {\n+    struct {\n+      union {\n+        /* The name of the symbol.  There is an implicit null character\n+           after the end of the array.  */\n+        char n_name[N_SYMNMLEN];\n+        struct {\n+          /* If n_zeroes is zero, n_offset is the offset the name from\n+             the start of the string table.  */\n+          unsigned char n_zeroes[4];\n+          unsigned char n_offset[4];\n+        } n;\n+      } n;\n+\n+      /* The symbol's value.  */\n+      unsigned char n_value[4];\n+    } xcoff32;\n+    struct {\n+      /* The symbol's value.  */\n+      unsigned char n_value[8];\n+\n+      /* The offset of the symbol from the start of the string table.  */\n+      unsigned char n_offset[4];\n+    } xcoff64;\n+  } u;\n+\n+  /* The number of the section to which this symbol belongs.  */\n+  unsigned char n_scnum[2];\n+\n+  /* The type of symbol.  (It can be interpreted as an n_lang\n+     and an n_cpu byte, but we don't care about that here.)  */\n+  unsigned char n_type[2];\n+\n+  /* The class of symbol (a C_* value).  */\n+  unsigned char n_sclass[1];\n+\n+  /* The number of auxiliary symbols attached to this entry.  */\n+  unsigned char n_numaux[1];\n+};\n+\n+#define SYMESZ\t\t(18)\n+\n+/* Length allowed for filename in aux sym format 4.  */\n+\n+#define FILNMLEN\t(14)\n+\n+/* Omits x_sym and other unused variants.  */\n+\n+union external_auxent\n+{\n+  /* Aux sym format 4: file.  */\n+  union\n+  {\n+    char x_fname[FILNMLEN];\n+    struct\n+    {\n+      unsigned char x_zeroes[4];\n+      unsigned char x_offset[4];\n+      unsigned char x_pad[FILNMLEN-8];\n+      unsigned char x_ftype;\n+    } _x;\n+  } x_file;\n+  /* Aux sym format 5: section.  */\n+  struct\n+  {\n+    unsigned char x_scnlen[4];\t\t/* section length\t\t*/\n+    unsigned char x_nreloc[2];\t\t/* # relocation entries\t\t*/\n+    unsigned char x_nlinno[2];\t\t/* # line numbers\t\t*/\n+  } x_scn;\n+  /* CSECT auxiliary entry.  */\n+  union\n+  {\n+    struct\n+    {\n+      struct\n+      {\n+\tunsigned char x_scnlen[4];\t/* csect length */\n+\tunsigned char x_parmhash[4];\t/* parm type hash index */\n+\tunsigned char x_snhash[2];\t/* sect num with parm hash */\n+\tunsigned char x_smtyp;\t\t/* symbol align and type */\n+\tunsigned char x_smclas;\t\t/* storage mapping class */\n+\tunsigned char x_stab;\t\t/* dbx stab info index */\n+\tunsigned char x_snstab[2];\t/* sect num with dbx stab */\n+      } x_csect;\n+    } xcoff32;\n+    struct\n+    {\n+      struct\n+      {\n+\tunsigned char x_scnlen_lo[4];\t/* csect length */\n+\tunsigned char x_parmhash[4];\t/* parm type hash index */\n+\tunsigned char x_snhash[2];\t/* sect num with parm hash */\n+\tunsigned char x_smtyp;\t\t/* symbol align and type */\n+\tunsigned char x_smclas;\t\t/* storage mapping class */\n+\tunsigned char x_scnlen_hi[4];\n+\tunsigned char pad;\n+\tunsigned char x_auxtype;\n+      } x_csect;\n+    } xcoff64;\n+  } u;\n+  /* SECTION/DWARF auxiliary entry.  */\n+  struct\n+  {\n+    unsigned char x_scnlen[4];\t\t/* section length */\n+    unsigned char pad1[4];\n+    unsigned char x_nreloc[4];\t\t/* number RLDs */\n+  } x_sect;\n+};\n+\n+/* Symbol-related constants.  */\n+\n+#define N_DEBUG\t\t(-2)\n+#define IMAGE_SYM_TYPE_NULL\t(0)\n+#define IMAGE_SYM_DTYPE_NULL\t(0)\n+#define IMAGE_SYM_CLASS_STATIC\t(3)\n+#define IMAGE_SYM_CLASS_FILE\t(103)\n+\n+#define IMAGE_SYM_TYPE \\\n+  ((IMAGE_SYM_DTYPE_NULL << 4) | IMAGE_SYM_TYPE_NULL)\n+\n+#define C_STAT\t\t(3)\n+#define C_FILE\t\t(103)\n+\n+/* Private data for an simple_object_read.  */\n+\n+struct simple_object_xcoff_read\n+{\n+  /* Magic number.  */\n+  unsigned short magic;\n+  /* Number of sections.  */\n+  unsigned short nscns;\n+  /* File offset of symbol table.  */\n+  off_t symptr;\n+  /* Number of symbol table entries.  */\n+  unsigned int nsyms;\n+  /* Flags.  */\n+  unsigned short flags;\n+  /* Offset of section headers in file.  */\n+  off_t scnhdr_offset;\n+};\n+\n+/* Private data for an simple_object_attributes.  */\n+\n+struct simple_object_xcoff_attributes\n+{\n+  /* Magic number.  */\n+  unsigned short magic;\n+  /* Flags.  */\n+  unsigned short flags;\n+};\n+\n+/* See if we have a XCOFF file.  */\n+\n+static void *\n+simple_object_xcoff_match (unsigned char header[SIMPLE_OBJECT_MATCH_HEADER_LEN],\n+\t\t\t   int descriptor, off_t offset,\n+\t\t\t   const char *segment_name ATTRIBUTE_UNUSED,\n+\t\t\t   const char **errmsg, int *err)\n+{\n+  unsigned short magic;\n+  unsigned short (*fetch_16) (const unsigned char *);\n+  unsigned int (*fetch_32) (const unsigned char *);\n+  ulong_type (*fetch_64) (const unsigned char *);\n+  unsigned char hdrbuf[sizeof (struct external_filehdr)];\n+  struct simple_object_xcoff_read *ocr;\n+  int u64;\n+\n+  magic = simple_object_fetch_big_16 (header);\n+\n+  if (magic != U802TOCMAGIC && magic != U64_TOCMAGIC)\n+    {\n+      *errmsg = NULL;\n+      *err = 0;\n+      return NULL;\n+    }\n+\n+  fetch_16 = simple_object_fetch_big_16;\n+  fetch_32 = simple_object_fetch_big_32;\n+  fetch_64 = simple_object_fetch_big_64;\n+\n+  if (!simple_object_internal_read (descriptor, offset, hdrbuf, sizeof hdrbuf,\n+\t\t\t\t    errmsg, err))\n+    return NULL;\n+\n+  u64 = magic == U64_TOCMAGIC;\n+\n+  ocr = XNEW (struct simple_object_xcoff_read);\n+  ocr->magic = magic;\n+  ocr->nscns = fetch_16 (hdrbuf + offsetof (struct external_filehdr, f_nscns));\n+  if (u64)\n+    {\n+      ocr->symptr = fetch_64 (hdrbuf\n+\t\t\t      + offsetof (struct external_filehdr,\n+\t\t\t\t\t  u.xcoff64.f_symptr));\n+      ocr->nsyms = fetch_32 (hdrbuf + offsetof (struct external_filehdr,\n+\t\t\t\t\t\tu.xcoff64.f_nsyms));\n+      ocr->scnhdr_offset = (sizeof (struct external_filehdr)\n+\t\t\t    + fetch_16 (hdrbuf + offsetof (struct external_filehdr,\n+\t\t\t\t\t\t\t   u.xcoff64.f_opthdr)));\n+\n+    }\n+  else\n+    {\n+      ocr->symptr = fetch_32 (hdrbuf\n+\t\t\t      + offsetof (struct external_filehdr,\n+\t\t\t\t\t  u.xcoff32.f_symptr));\n+      ocr->nsyms = fetch_32 (hdrbuf + offsetof (struct external_filehdr,\n+\t\t\t\t\t\tu.xcoff32.f_nsyms));\n+      ocr->scnhdr_offset = (sizeof (struct external_filehdr) - 4\n+\t\t\t    + fetch_16 (hdrbuf + offsetof (struct external_filehdr,\n+\t\t\t\t\t\t\t   u.xcoff32.f_opthdr)));\n+\n+    }\n+\n+  return (void *) ocr;\n+}\n+\n+/* Read the string table in a XCOFF file.  */\n+\n+static char *\n+simple_object_xcoff_read_strtab (simple_object_read *sobj, size_t *strtab_size,\n+\t\t\t\t const char **errmsg, int *err)\n+{\n+  struct simple_object_xcoff_read *ocr =\n+    (struct simple_object_xcoff_read *) sobj->data;\n+  off_t strtab_offset;\n+  unsigned char strsizebuf[4];\n+  size_t strsize;\n+  char *strtab;\n+\n+  strtab_offset = sobj->offset + ocr->symptr\n+    + ocr->nsyms * SYMESZ;\n+  if (!simple_object_internal_read (sobj->descriptor, strtab_offset,\n+\t\t\t\t    strsizebuf, 4, errmsg, err))\n+    return NULL;\n+  strsize = simple_object_fetch_big_32 (strsizebuf);\n+  strtab = XNEWVEC (char, strsize);\n+  if (!simple_object_internal_read (sobj->descriptor, strtab_offset,\n+\t\t\t\t    (unsigned char *) strtab, strsize, errmsg,\n+\t\t\t\t    err))\n+    {\n+      XDELETEVEC (strtab);\n+      return NULL;\n+    }\n+  *strtab_size = strsize;\n+  return strtab;\n+}\n+\n+/* Find all sections in a XCOFF file.  */\n+\n+static const char *\n+simple_object_xcoff_find_sections (simple_object_read *sobj,\n+\t\t\t\t  int (*pfn) (void *, const char *,\n+\t\t\t\t\t      off_t offset, off_t length),\n+\t\t\t\t  void *data,\n+\t\t\t\t  int *err)\n+{\n+  struct simple_object_xcoff_read *ocr =\n+    (struct simple_object_xcoff_read *) sobj->data;\n+  int u64 = ocr->magic == U64_TOCMAGIC;\n+  size_t scnhdr_size;\n+  unsigned char *scnbuf;\n+  const char *errmsg;\n+  unsigned int (*fetch_32) (const unsigned char *);\n+  ulong_type (*fetch_64) (const unsigned char *);\n+  unsigned int nscns;\n+  char *strtab;\n+  size_t strtab_size;\n+  unsigned int i;\n+\n+  scnhdr_size = u64 ? SCNHSZ64 : SCNHSZ32;\n+  scnbuf = XNEWVEC (unsigned char, scnhdr_size * ocr->nscns);\n+  if (!simple_object_internal_read (sobj->descriptor,\n+\t\t\t\t    sobj->offset + ocr->scnhdr_offset,\n+\t\t\t\t    scnbuf, scnhdr_size * ocr->nscns, &errmsg,\n+\t\t\t\t    err))\n+    {\n+      XDELETEVEC (scnbuf);\n+      return errmsg;\n+    }\n+\n+  fetch_32 = simple_object_fetch_big_32;\n+  fetch_64 = simple_object_fetch_big_64;\n+\n+  nscns = ocr->nscns;\n+  strtab = NULL;\n+  strtab_size = 0;\n+  for (i = 0; i < nscns; ++i)\n+    {\n+      unsigned char *scnhdr;\n+      unsigned char *scnname;\n+      char namebuf[SCNNMLEN + 1];\n+      char *name;\n+      off_t scnptr;\n+      unsigned int size;\n+\n+      scnhdr = scnbuf + i * scnhdr_size;\n+      scnname = scnhdr + offsetof (struct external_scnhdr, s_name);\n+      memcpy (namebuf, scnname, SCNNMLEN);\n+      namebuf[SCNNMLEN] = '\\0';\n+      name = &namebuf[0];\n+      if (namebuf[0] == '/')\n+\t{\n+\t  size_t strindex;\n+\t  char *end;\n+\n+\t  strindex = strtol (namebuf + 1, &end, 10);\n+\t  if (*end == '\\0')\n+\t    {\n+\t      /* The real section name is found in the string\n+\t\t table.  */\n+\t      if (strtab == NULL)\n+\t\t{\n+\t\t  strtab = simple_object_xcoff_read_strtab (sobj,\n+\t\t\t\t\t\t\t   &strtab_size,\n+\t\t\t\t\t\t\t   &errmsg, err);\n+\t\t  if (strtab == NULL)\n+\t\t    {\n+\t\t      XDELETEVEC (scnbuf);\n+\t\t      return errmsg;\n+\t\t    }\n+\t\t}\n+\n+\t      if (strindex < 4 || strindex >= strtab_size)\n+\t\t{\n+\t\t  XDELETEVEC (strtab);\n+\t\t  XDELETEVEC (scnbuf);\n+\t\t  *err = 0;\n+\t\t  return \"section string index out of range\";\n+\t\t}\n+\n+\t      name = strtab + strindex;\n+\t    }\n+\t}\n+\n+      if (u64)\n+\t{\n+\t  scnptr = fetch_64 (scnhdr + offsetof (struct external_scnhdr,\n+\t\t\t\t\t\tu.xcoff64.s_scnptr));\n+\t  size = fetch_64 (scnhdr + offsetof (struct external_scnhdr,\n+\t\t\t\t\t      u.xcoff64.s_size));\n+\t}\n+      else\n+\t{\n+\t  scnptr = fetch_32 (scnhdr + offsetof (struct external_scnhdr,\n+\t\t\t\t\t\tu.xcoff32.s_scnptr));\n+\t  size = fetch_32 (scnhdr + offsetof (struct external_scnhdr,\n+\t\t\t\t\t      u.xcoff32.s_size));\n+\t}\n+\n+      if (!(*pfn) (data, name, scnptr, size))\n+\tbreak;\n+    }\n+\n+  if (strtab != NULL)\n+    XDELETEVEC (strtab);\n+  XDELETEVEC (scnbuf);\n+\n+  return NULL;\n+}\n+\n+/* Fetch the attributes for an simple_object_read.  */\n+\n+static void *\n+simple_object_xcoff_fetch_attributes (simple_object_read *sobj,\n+\t\t\t\t     const char **errmsg ATTRIBUTE_UNUSED,\n+\t\t\t\t     int *err ATTRIBUTE_UNUSED)\n+{\n+  struct simple_object_xcoff_read *ocr =\n+    (struct simple_object_xcoff_read *) sobj->data;\n+  struct simple_object_xcoff_attributes *ret;\n+\n+  ret = XNEW (struct simple_object_xcoff_attributes);\n+  ret->magic = ocr->magic;\n+  ret->flags = ocr->flags;\n+  return ret;\n+}\n+\n+/* Release the private data for an simple_object_read.  */\n+\n+static void\n+simple_object_xcoff_release_read (void *data)\n+{\n+  XDELETE (data);\n+}\n+\n+/* Compare two attributes structures.  */\n+\n+static const char *\n+simple_object_xcoff_attributes_merge (void *todata, void *fromdata, int *err)\n+{\n+  struct simple_object_xcoff_attributes *to =\n+    (struct simple_object_xcoff_attributes *) todata;\n+  struct simple_object_xcoff_attributes *from =\n+    (struct simple_object_xcoff_attributes *) fromdata;\n+\n+  if (to->magic != from->magic)\n+    {\n+      *err = 0;\n+      return \"XCOFF object format mismatch\";\n+    }\n+  return NULL;\n+}\n+\n+/* Release the private data for an attributes structure.  */\n+\n+static void\n+simple_object_xcoff_release_attributes (void *data)\n+{\n+  XDELETE (data);\n+}\n+\n+/* Prepare to write out a file.  */\n+\n+static void *\n+simple_object_xcoff_start_write (void *attributes_data,\n+\t\t\t\tconst char **errmsg ATTRIBUTE_UNUSED,\n+\t\t\t\tint *err ATTRIBUTE_UNUSED)\n+{\n+  struct simple_object_xcoff_attributes *attrs =\n+    (struct simple_object_xcoff_attributes *) attributes_data;\n+  struct simple_object_xcoff_attributes *ret;\n+\n+  /* We're just going to record the attributes, but we need to make a\n+     copy because the user may delete them.  */\n+  ret = XNEW (struct simple_object_xcoff_attributes);\n+  *ret = *attrs;\n+  return ret;\n+}\n+\n+/* Write out a XCOFF filehdr.  */\n+\n+static int\n+simple_object_xcoff_write_filehdr (simple_object_write *sobj, int descriptor,\n+\t\t\t\t  unsigned int nscns, size_t symtab_offset,\n+\t\t\t\t  unsigned int nsyms, const char **errmsg,\n+\t\t\t\t  int *err)\n+{\n+  struct simple_object_xcoff_attributes *attrs =\n+    (struct simple_object_xcoff_attributes *) sobj->data;\n+  int u64 = attrs->magic == U64_TOCMAGIC;\n+  unsigned char hdrbuf[sizeof (struct external_filehdr)];\n+  unsigned char *hdr;\n+  void (*set_16) (unsigned char *, unsigned short);\n+  void (*set_32) (unsigned char *, unsigned int);\n+  void (*set_64) (unsigned char *, ulong_type);\n+\n+  hdr = &hdrbuf[0];\n+\n+  set_16 = simple_object_set_big_16;\n+  set_32 = simple_object_set_big_32;\n+  set_64 = simple_object_set_big_64;\n+\n+  memset (hdr, 0, sizeof (struct external_filehdr));\n+\n+  set_16 (hdr + offsetof (struct external_filehdr, f_magic), attrs->magic);\n+  set_16 (hdr + offsetof (struct external_filehdr, f_nscns), nscns);\n+  /* f_timdat left as zero.  */\n+  if (u64)\n+    {\n+      set_64 (hdr + offsetof (struct external_filehdr, u.xcoff64.f_symptr),\n+\t      symtab_offset);\n+      set_32 (hdr + offsetof (struct external_filehdr, u.xcoff64.f_nsyms),\n+\t      nsyms);\n+      /* f_opthdr left as zero.  */\n+      set_16 (hdr + offsetof (struct external_filehdr, u.xcoff64.f_flags),\n+\t      attrs->flags);\n+    }\n+  else\n+    {\n+      set_32 (hdr + offsetof (struct external_filehdr, u.xcoff64.f_symptr),\n+\t      symtab_offset);\n+      set_32 (hdr + offsetof (struct external_filehdr, u.xcoff64.f_nsyms),\n+\t      nsyms);\n+      /* f_opthdr left as zero.  */\n+      set_16 (hdr + offsetof (struct external_filehdr, u.xcoff64.f_flags),\n+\t      attrs->flags);\n+    }\n+\n+  return simple_object_internal_write (descriptor, 0, hdrbuf,\n+\t\t\t\t       sizeof (struct external_filehdr),\n+\t\t\t\t       errmsg, err);\n+}\n+\n+/* Write out a XCOFF section header.  */\n+\n+static int\n+simple_object_xcoff_write_scnhdr (simple_object_write *sobj,\n+\t\t\t\t  int descriptor,\n+\t\t\t\t  const char *name, size_t *name_offset,\n+\t\t\t\t  off_t scnhdr_offset, size_t scnsize,\n+\t\t\t\t  off_t offset, unsigned int align,\n+\t\t\t\t  const char **errmsg, int *err)\n+{\n+  struct simple_object_xcoff_read *ocr =\n+    (struct simple_object_xcoff_read *) sobj->data;\n+  int u64 = ocr->magic == U64_TOCMAGIC;\n+  void (*set_32) (unsigned char *, unsigned int);\n+  void (*set_64) (unsigned char *, unsigned int);\n+  unsigned char hdrbuf[sizeof (struct external_scnhdr)];\n+  unsigned char *hdr;\n+  size_t namelen;\n+  unsigned int flags;\n+\n+  set_32 = simple_object_set_big_32;\n+  set_64 = simple_object_set_big_32;\n+\n+  memset (hdrbuf, 0, sizeof hdrbuf);\n+  hdr = &hdrbuf[0];\n+\n+  namelen = strlen (name);\n+  if (namelen <= SCNNMLEN)\n+    strncpy ((char *) hdr + offsetof (struct external_scnhdr, s_name),\n+\t     name, SCNNMLEN);\n+  else\n+    {\n+      snprintf ((char *) hdr + offsetof (struct external_scnhdr, s_name),\n+\t\tSCNNMLEN, \"/%lu\", (unsigned long) *name_offset);\n+      *name_offset += namelen + 1;\n+    }\n+\n+  /* s_paddr left as zero.  */\n+  /* s_vaddr left as zero.  */\n+  if (u64)\n+    {\n+      set_64 (hdr + offsetof (struct external_scnhdr, u.xcoff64.s_size),\n+\t      scnsize);\n+      set_64 (hdr + offsetof (struct external_scnhdr, u.xcoff64.s_scnptr),\n+\t      offset);\n+    }\n+  else\n+    {\n+      set_32 (hdr + offsetof (struct external_scnhdr, u.xcoff32.s_size),\n+\t      scnsize);\n+      set_32 (hdr + offsetof (struct external_scnhdr, u.xcoff32.s_scnptr),\n+\t      offset);\n+    }\n+  /* s_relptr left as zero.  */\n+  /* s_lnnoptr left as zero.  */\n+  /* s_nreloc left as zero.  */\n+  /* s_nlnno left as zero.  */\n+  flags = STYP_DATA;\n+  if (align > 13)\n+    align = 13;\n+  if (u64)\n+    set_32 (hdr + offsetof (struct external_scnhdr, u.xcoff64.s_flags), flags);\n+  else\n+    set_32 (hdr + offsetof (struct external_scnhdr, u.xcoff32.s_flags), flags);\n+\n+  return simple_object_internal_write (descriptor, scnhdr_offset, hdrbuf,\n+\t\t\t\t       u64 ? SCNHSZ64 : SCNHSZ32,\n+\t\t\t\t       errmsg, err);\n+}\n+\n+/* Write out a complete XCOFF file.  */\n+\n+static const char *\n+simple_object_xcoff_write_to_file (simple_object_write *sobj, int descriptor,\n+\t\t\t\t  int *err)\n+{\n+  struct simple_object_xcoff_read *ocr =\n+    (struct simple_object_xcoff_read *) sobj->data;\n+  int u64 = ocr->magic == U64_TOCMAGIC;\n+  unsigned int nscns, secnum;\n+  simple_object_write_section *section;\n+  off_t scnhdr_offset;\n+  size_t symtab_offset;\n+  off_t secsym_offset;\n+  unsigned int nsyms;\n+  size_t offset;\n+  size_t name_offset;\n+  const char *errmsg;\n+  unsigned char strsizebuf[4];\n+  /* The interface doesn't give us access to the name of the input file\n+     yet.  We want to use its basename for the FILE symbol.  This is\n+     what 'gas' uses when told to assemble from stdin.  */\n+  const char *source_filename = \"fake\";\n+  size_t sflen;\n+  union\n+  {\n+    struct external_syment sym;\n+    union external_auxent aux;\n+  } syms[2];\n+  void (*set_16) (unsigned char *, unsigned short);\n+  void (*set_32) (unsigned char *, unsigned int);\n+\n+  set_16 = simple_object_set_big_16;\n+  set_32 = simple_object_set_big_32;\n+\n+  nscns = 0;\n+  for (section = sobj->sections; section != NULL; section = section->next)\n+    ++nscns;\n+\n+  scnhdr_offset = sizeof (struct external_filehdr) - (u64 ? 4 : 0);\n+  offset = scnhdr_offset + nscns * (u64 ? SCNHSZ64 : SCNHSZ32);\n+  name_offset = 4;\n+  for (section = sobj->sections; section != NULL; section = section->next)\n+    {\n+      size_t mask;\n+      size_t new_offset;\n+      size_t scnsize;\n+      struct simple_object_write_section_buffer *buffer;\n+\n+      mask = (1U << section->align) - 1;\n+      new_offset = offset & mask;\n+      new_offset &= ~ mask;\n+      while (new_offset > offset)\n+\t{\n+\t  unsigned char zeroes[16];\n+\t  size_t write;\n+\n+\t  memset (zeroes, 0, sizeof zeroes);\n+\t  write = new_offset - offset;\n+\t  if (write > sizeof zeroes)\n+\t    write = sizeof zeroes;\n+\t  if (!simple_object_internal_write (descriptor, offset, zeroes, write,\n+\t\t\t\t\t     &errmsg, err))\n+\t    return errmsg;\n+\t}\n+\n+      scnsize = 0;\n+      for (buffer = section->buffers; buffer != NULL; buffer = buffer->next)\n+\t{\n+\t  if (!simple_object_internal_write (descriptor, offset + scnsize,\n+\t\t\t\t\t     ((const unsigned char *)\n+\t\t\t\t\t      buffer->buffer),\n+\t\t\t\t\t     buffer->size, &errmsg, err))\n+\t    return errmsg;\n+\t  scnsize += buffer->size;\n+\t}\n+\n+      if (!simple_object_xcoff_write_scnhdr (sobj, descriptor, section->name,\n+\t\t\t\t\t    &name_offset, scnhdr_offset,\n+\t\t\t\t\t    scnsize, offset, section->align,\n+\t\t\t\t\t    &errmsg, err))\n+\treturn errmsg;\n+\n+      scnhdr_offset += u64 ? SCNHSZ64 : SCNHSZ32;\n+      offset += scnsize;\n+    }\n+\n+  /* Symbol table is always half-word aligned.  */\n+  offset += (offset & 1);\n+  /* There is a file symbol and a section symbol per section,\n+     and each of these has a single auxiliary symbol following.  */\n+  nsyms = 2 * (nscns + 1);\n+  symtab_offset = offset;\n+  /* Advance across space reserved for symbol table to locate\n+     start of string table.  */\n+  offset += nsyms * SYMESZ;\n+\n+  /* Write out file symbol.  */\n+  memset (&syms[0], 0, sizeof (syms));\n+  if (!u64)\n+    strcpy ((char *)&syms[0].sym.u.xcoff32.n.n_name[0], \".file\");\n+  set_16 (&syms[0].sym.n_scnum[0], N_DEBUG);\n+  set_16 (&syms[0].sym.n_type[0], IMAGE_SYM_TYPE);\n+  syms[0].sym.n_sclass[0] = C_FILE;\n+  syms[0].sym.n_numaux[0] = 1;\n+  /* The name need not be nul-terminated if it fits into the x_fname field\n+     directly, but must be if it has to be placed into the string table.  */\n+  sflen = strlen (source_filename);\n+  if (sflen <= FILNMLEN)\n+    memcpy (&syms[1].aux.x_file.x_fname[0], source_filename, sflen);\n+  else\n+    {\n+      set_32 (&syms[1].aux.x_file._x.x_offset[0], name_offset);\n+      if (!simple_object_internal_write (descriptor, offset + name_offset,\n+\t\t\t\t\t ((const unsigned char *)\n+\t\t\t\t\t  source_filename),\n+\t\t\t\t\t sflen + 1, &errmsg, err))\n+\treturn errmsg;\n+      name_offset += strlen (source_filename) + 1;\n+    }\n+  if (!simple_object_internal_write (descriptor, symtab_offset,\n+\t\t\t\t     (const unsigned char *) &syms[0],\n+\t\t\t\t     sizeof (syms), &errmsg, err))\n+    return errmsg;\n+\n+  /* Write the string table length, followed by the strings and section\n+     symbols in step with each other.  */\n+  set_32 (strsizebuf, name_offset);\n+  if (!simple_object_internal_write (descriptor, offset, strsizebuf, 4,\n+\t\t\t\t     &errmsg, err))\n+    return errmsg;\n+\n+  name_offset = 4;\n+  secsym_offset = symtab_offset + sizeof (syms);\n+  memset (&syms[0], 0, sizeof (syms));\n+  set_16 (&syms[0].sym.n_type[0], IMAGE_SYM_TYPE);\n+  syms[0].sym.n_sclass[0] = C_STAT;\n+  syms[0].sym.n_numaux[0] = 1;\n+  secnum = 1;\n+\n+  for (section = sobj->sections; section != NULL; section = section->next)\n+    {\n+      size_t namelen;\n+      size_t scnsize;\n+      struct simple_object_write_section_buffer *buffer;\n+\n+      namelen = strlen (section->name);\n+      set_16 (&syms[0].sym.n_scnum[0], secnum++);\n+      scnsize = 0;\n+      for (buffer = section->buffers; buffer != NULL; buffer = buffer->next)\n+\tscnsize += buffer->size;\n+      set_32 (&syms[1].aux.x_scn.x_scnlen[0], scnsize);\n+      if (namelen > SCNNMLEN)\n+\t{\n+\t  set_32 (&syms[0].sym.u.xcoff32.n.n.n_zeroes[0], 0);\n+\t  set_32 (&syms[0].sym.u.xcoff32.n.n.n_offset[0], name_offset);\n+\t  if (!simple_object_internal_write (descriptor, offset + name_offset,\n+\t\t\t\t\t     ((const unsigned char *)\n+\t\t\t\t\t      section->name),\n+\t\t\t\t\t     namelen + 1, &errmsg, err))\n+\t    return errmsg;\n+\t  name_offset += namelen + 1;\n+\t}\n+      else\n+\t{\n+\t  memcpy (&syms[0].sym.u.xcoff32.n.n_name[0], section->name,\n+\t\t  strlen (section->name));\n+\t  memset (&syms[0].sym.u.xcoff32.n.n_name[strlen (section->name)], 0,\n+\t\t  N_SYMNMLEN - strlen (section->name));\n+\t}\n+\n+      if (!simple_object_internal_write (descriptor, secsym_offset,\n+\t\t\t\t\t (const unsigned char *) &syms[0],\n+\t\t\t\t\t sizeof (syms), &errmsg, err))\n+\treturn errmsg;\n+      secsym_offset += sizeof (syms);\n+    }\n+\n+  if (!simple_object_xcoff_write_filehdr (sobj, descriptor, nscns,\n+\t\t\t\t\t symtab_offset, nsyms, &errmsg, err))\n+    return errmsg;\n+\n+  return NULL;\n+}\n+\n+/* Release the private data for an simple_object_write structure.  */\n+\n+static void\n+simple_object_xcoff_release_write (void *data)\n+{\n+  XDELETE (data);\n+}\n+\n+/* The XCOFF functions.  */\n+\n+const struct simple_object_functions simple_object_xcoff_functions =\n+{\n+  simple_object_xcoff_match,\n+  simple_object_xcoff_find_sections,\n+  simple_object_xcoff_fetch_attributes,\n+  simple_object_xcoff_release_read,\n+  simple_object_xcoff_attributes_merge,\n+  simple_object_xcoff_release_attributes,\n+  simple_object_xcoff_start_write,\n+  simple_object_xcoff_write_to_file,\n+  simple_object_xcoff_release_write\n+};"}, {"sha": "fde3454dd42c8df1e6ba65663ceed796850093e2", "filename": "libiberty/simple-object.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9b01f002fc2f86a7a1c3f7eed730a5007be3c73/libiberty%2Fsimple-object.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9b01f002fc2f86a7a1c3f7eed730a5007be3c73/libiberty%2Fsimple-object.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsimple-object.c?ref=a9b01f002fc2f86a7a1c3f7eed730a5007be3c73", "patch": "@@ -51,7 +51,8 @@ static const struct simple_object_functions * const format_functions[] =\n {\n   &simple_object_elf_functions,\n   &simple_object_mach_o_functions,\n-  &simple_object_coff_functions\n+  &simple_object_coff_functions,\n+  &simple_object_xcoff_functions\n };\n \n /* Read data from a file using the simple_object error reporting"}]}