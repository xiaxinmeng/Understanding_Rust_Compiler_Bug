{"sha": "9d0eb0ae948f0fbee208cfb9a86133abea650f81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWQwZWIwYWU5NDhmMGZiZWUyMDhjZmI5YTg2MTMzYWJlYTY1MGY4MQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-12-07T15:02:58Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-12-07T16:49:33Z"}, "message": "c++: check alias match for specializations [PR98116]\n\nThis fixes the underlying problem my recent (backedout) changes to\narray type creation uncovered.  We had paths through\nstructural_comptypes that ignored alias templates, even when\nsignificant.  This adds the necessary checks.\n\n\tPR c++/98116\n\tgcc/cp/\n\t* typeck.c (structural_comptypes): Move early outs to comptype.\n\tAlways check template-alias match when comparing_specializations.\n\t(comptypes): Do early out checking here.\n\tgcc/testsuite/\n\t* g++.dg/template/pr98116.C: Remove dg-ice.\n\t* g++.dg/template/pr98116-2.C: New.", "tree": {"sha": "5d307f9a0ab43a547195ce1d7f76516e402cfefd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d307f9a0ab43a547195ce1d7f76516e402cfefd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d0eb0ae948f0fbee208cfb9a86133abea650f81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d0eb0ae948f0fbee208cfb9a86133abea650f81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d0eb0ae948f0fbee208cfb9a86133abea650f81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d0eb0ae948f0fbee208cfb9a86133abea650f81/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92e563d91b012f09da8fd152e934f6b964ae49cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92e563d91b012f09da8fd152e934f6b964ae49cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92e563d91b012f09da8fd152e934f6b964ae49cb"}], "stats": {"total": 100, "additions": 68, "deletions": 32}, "files": [{"sha": "4d499af5ccb91cae326207d946125830f654b020", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d0eb0ae948f0fbee208cfb9a86133abea650f81/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d0eb0ae948f0fbee208cfb9a86133abea650f81/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=9d0eb0ae948f0fbee208cfb9a86133abea650f81", "patch": "@@ -1247,14 +1247,8 @@ cxx_safe_function_type_cast_p (tree t1, tree t2)\n static bool\n structural_comptypes (tree t1, tree t2, int strict)\n {\n-  if (t1 == t2)\n-    return true;\n-\n-  /* Suppress errors caused by previously reported errors.  */\n-  if (t1 == error_mark_node || t2 == error_mark_node)\n-    return false;\n-\n-  gcc_assert (TYPE_P (t1) && TYPE_P (t2));\n+  /* Both should be types that are not obviously the same.  */\n+  gcc_checking_assert (t1 != t2 && TYPE_P (t1) && TYPE_P (t2));\n \n   if (!comparing_specializations)\n     {\n@@ -1300,13 +1294,13 @@ structural_comptypes (tree t1, tree t2, int strict)\n   /* Allow for two different type nodes which have essentially the same\n      definition.  Note that we already checked for equality of the type\n      qualifiers (just above).  */\n-\n   if (TREE_CODE (t1) != ARRAY_TYPE\n       && TYPE_MAIN_VARIANT (t1) == TYPE_MAIN_VARIANT (t2))\n-    return true;\n-\n+    goto check_alias;\n \n-  /* Compare the types.  Break out if they could be the same.  */\n+  /* Compare the types.  Return false on known not-same. Break on not\n+     known.   Never return true from this switch -- you'll break\n+     specialization comparison.    */\n   switch (TREE_CODE (t1))\n     {\n     case VOID_TYPE:\n@@ -1332,7 +1326,11 @@ structural_comptypes (tree t1, tree t2, int strict)\n \t have identical properties, different TYPE_MAIN_VARIANTs, but\n \t represent the same type.  The canonical type system keeps\n \t track of equivalence in this case, so we fall back on it.  */\n-      return TYPE_CANONICAL (t1) == TYPE_CANONICAL (t2);\n+      if (TYPE_CANONICAL (t1) != TYPE_CANONICAL (t2))\n+\treturn false;\n+\n+      /* We don't need or want the attribute comparison.  */\n+      goto check_alias;\n \n     case TEMPLATE_TEMPLATE_PARM:\n     case BOUND_TEMPLATE_TEMPLATE_PARM:\n@@ -1477,24 +1475,28 @@ structural_comptypes (tree t1, tree t2, int strict)\n       return false;\n     }\n \n-  /* Don't treat an alias template specialization with dependent\n-     arguments as equivalent to its underlying type when used as a\n-     template argument; we need them to be distinct so that we\n-     substitute into the specialization arguments at instantiation\n-     time.  And aliases can't be equivalent without being ==, so\n-     we don't need to look any deeper.  */\n+  /* If we get here, we know that from a target independent POV the\n+     types are the same.  Make sure the target attributes are also\n+     the same.  */\n+  if (!comp_type_attributes (t1, t2))\n+    return false;\n+\n+ check_alias:\n   if (comparing_specializations)\n     {\n+      /* Don't treat an alias template specialization with dependent\n+\t arguments as equivalent to its underlying type when used as a\n+\t template argument; we need them to be distinct so that we\n+\t substitute into the specialization arguments at instantiation\n+\t time.  And aliases can't be equivalent without being ==, so\n+\t we don't need to look any deeper.  */\n       tree dep1 = dependent_alias_template_spec_p (t1, nt_transparent);\n       tree dep2 = dependent_alias_template_spec_p (t2, nt_transparent);\n       if ((dep1 || dep2) && dep1 != dep2)\n \treturn false;\n     }\n \n-  /* If we get here, we know that from a target independent POV the\n-     types are the same.  Make sure the target attributes are also\n-     the same.  */\n-  return comp_type_attributes (t1, t2);\n+  return true;\n }\n \n /* Return true if T1 and T2 are related as allowed by STRICT.  STRICT\n@@ -1509,19 +1511,20 @@ comptypes (tree t1, tree t2, int strict)\n   gcc_checking_assert (TREE_CODE (t1) != TYPE_ARGUMENT_PACK\n \t\t       && TREE_CODE (t2) != TYPE_ARGUMENT_PACK);\n \n+  if (t1 == t2)\n+    return true;\n+\n+  /* Suppress errors caused by previously reported errors.  */\n+  if (t1 == error_mark_node || t2 == error_mark_node)\n+    return false;\n+\n   if (strict == COMPARE_STRICT && comparing_specializations\n       && (t1 != TYPE_CANONICAL (t1) || t2 != TYPE_CANONICAL (t2)))\n     /* If comparing_specializations, treat dependent aliases as distinct.  */\n     strict = COMPARE_STRUCTURAL;\n \n   if (strict == COMPARE_STRICT)\n     {\n-      if (t1 == t2)\n-\treturn true;\n-\n-      if (t1 == error_mark_node || t2 == error_mark_node)\n-\treturn false;\n-\n       if (TYPE_STRUCTURAL_EQUALITY_P (t1) || TYPE_STRUCTURAL_EQUALITY_P (t2))\n \t/* At least one of the types requires structural equality, so\n \t   perform a deep check. */"}, {"sha": "fd12bb19be062a867050b300df8c9d46f158eeea", "filename": "gcc/testsuite/g++.dg/template/pr98116-2.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d0eb0ae948f0fbee208cfb9a86133abea650f81/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpr98116-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d0eb0ae948f0fbee208cfb9a86133abea650f81/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpr98116-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpr98116-2.C?ref=9d0eb0ae948f0fbee208cfb9a86133abea650f81", "patch": "@@ -0,0 +1,34 @@\n+// PR 98116, ICE with stripping typedef array type\n+// { dg-do compile { target c++11 } }\n+// { dg-additional-options {--param=hash-table-verification-limit=10000000 -fchecking=2} }\n+\n+// We got confused by alias templates that alias the same type.  Their\n+// hashes were different (good), but they compared equal (bad)\n+\n+namespace std {\n+typedef int is_convertible;\n+template <typename _Tp> using remove_pointer_t = typename _Tp ::type;\n+template <bool> struct enable_if;\n+template <typename> void declval();\n+template <bool _Cond> using enable_if_t = typename enable_if<_Cond>::type;\n+template <typename, typename> class Trans_NS___cxx11_basic_string {\n+  long _M_string_length;\n+};\n+} // namespace std\n+struct string16_char_traits;\n+template class std::Trans_NS___cxx11_basic_string<unsigned short,\n+                                                  string16_char_traits>;\n+template <typename, typename> using IsLegalDataConversion = std::is_convertible;\n+template <typename Container, typename T>\n+using ContainerHasConvertibleData = IsLegalDataConversion<\n+    std::remove_pointer_t<decltype(std::declval<Container>)>, T>;\n+template <typename Array, typename T, long>\n+using EnableIfSpanCompatibleArray =\n+  std::enable_if_t<!!sizeof (ContainerHasConvertibleData<Array, T>)>;\n+template <int Extent> class span {\n+  template <long N, EnableIfSpanCompatibleArray<\n+                        const std::Trans_NS___cxx11_basic_string<\n+                            unsigned short, string16_char_traits>[N],\n+                        std::Trans_NS___cxx11_basic_string<short, int>, Extent>>\n+  span();\n+};"}, {"sha": "7d54314b26b36dc2281b1b0be54c4e4ac939d357", "filename": "gcc/testsuite/g++.dg/template/pr98116.C", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d0eb0ae948f0fbee208cfb9a86133abea650f81/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpr98116.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d0eb0ae948f0fbee208cfb9a86133abea650f81/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpr98116.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpr98116.C?ref=9d0eb0ae948f0fbee208cfb9a86133abea650f81", "patch": "@@ -1,10 +1,9 @@\n // PR 98116, ICE with stripping typedef array type\n // { dg-do compile { target c++11 } }\n // { dg-additional-options {--param=hash-table-verification-limit=10000000 -fchecking=2} }\n-// { dg-ice \"spec_hasher::equal\" }\n \n-// We get confused by alias templates that alias the same type.\n-// { dg-prune-output \"hash table checking failed\" }\n+// We got confused by alias templates that alias the same type.  Their\n+// hashes were different (good), but they compared equal (bad)\n \n namespace std {\n struct is_convertible;"}]}