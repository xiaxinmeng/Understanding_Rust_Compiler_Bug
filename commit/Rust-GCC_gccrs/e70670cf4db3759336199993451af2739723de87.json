{"sha": "e70670cf4db3759336199993451af2739723de87", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTcwNjcwY2Y0ZGIzNzU5MzM2MTk5OTkzNDUxYWYyNzM5NzIzZGU4Nw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-05-29T20:42:50Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-05-29T20:42:50Z"}, "message": "cgraph.h (symtab_node_base): Add definition, alias and analyzed flags...\n\n\n\t* cgraph.h (symtab_node_base): Add definition, alias and analyzed\n\tflags; reorder rest of fields in more consistent way.\n\t(varpool_node): Remove analyzed, finalized and alias.\n\t(cgraph_ndoe): Likewise.\n\t(symtab_alias_ultimate_target): New function.\n\t(cgraph_function_node): Move offline.\n\t(cgraph_reset_node): Declare.\n\t(cgraph_comdat_can_be_unshared_p): Remove.\n\t(varpool_remove_initializer): Declare.\n\t(varpool_first_defined_variable, varpool_next_defined_variable\n\tcgraph_first_defined_function, cgraph_next_defined_function): Update.\n\t(cgraph_function_with_gimple_body_p): Update.\n\t(varpool_all_refs_explicit_p): Update.\n\t(symtab_alias_target): New function.\n\t(cgraph_alias_aliased_node, varpool_alias_aliased_node): Rename to ...\n\t(cgraph_alias_target, varpool_alias_target): .. this one; simplify.\n\t(cgraph_function_or_thunk_node): Simplify using symtab_alias_ultimate_target.\n\t(varpool_variable_node): Likewise.\n\t* cgraph.c (cgraph_create_function_alias): Update.\n\t(cgraph_add_thunk): Update.\n\t(cgraph_remove_node): Update.\n\t(dump_cgraph_node): Do not dump removed flags.\n\t(cgraph_function_body_availability): Update.\n\t(cgraph_propagate_frequency): Update.\n\t(verify_cgraph_node): Check sanity of local flag.\n\t(cgraph_function_node): Move here from cgraph.h; revamp for\n\tcgraph_function_or_thunk_node.\n\t* lto-symtab.c (lto_varpool_replace_node): Update.\n\t(lto_symtab_resolve_can_prevail_p): Update.\n\t(lto_symtab_merge_cgraph_nodes): Update.\n\t* ipa-cp.c (determine_versionability, initialize_node_lattices,\n\tpropagate_constants_accross_call, devirtualization_time_bonus,\n\tipcp_propagate_stage): Update.\n\t* tree-emutls.c (create_emultls_var, ipa_lower_emutls): Update.\n\t* ipa-inline-transform.c (clone_inlined_nodes, preserve_function_body_p): Update.\n\t* ipa-reference.c (propagate): Update.\n\t(write_node_summary_p): Update.\n\t* toplev.c (wrapup_global_declaration_2): Update.\n\t* cgraphunit.c (cgraph_analyze_function): Rename to ...\n\t(analyze_function) ... this one.\n\t(cgraph_process_new_functions): Update.\n\t(cgraph_reset_node): Export.\n\t(cgraph_finalize_function): Update.\n\t(cgraph_add_new_function): Update.\n\t(process_function_and_variable_attributes): Update.\n\t(varpool_finalize_decl): Update.\n\t(symbol_finalized): Remove.\n\t(symbol_finalized_and_needed): Rename to ...\n\t(symbol_defined_and_needed): ... update.\n\t(cgraph_analyze_functions): Update.\n\t(handle_alias_pairs): Update.\n\t(mark_functions_to_output): Update.\n\t(assemble_thunk): Update.\n\t(output_in_order): Update.\n\t(output_weakrefs): Update.\n\t(finalize_compilation_unit): Update.\n\t* lto-cgraph.c (reachable_from_other_partition_p, lto_output_node,\n\tlto_output_varpool_node, compute_ltrans_boundary, input_overwrite_node,\n\tinput_node, input_varpool_node): Update.\n\t* dbxout.c (dbxout_expand_expr): Update.\n\t* cgraphclones.c (cgraph_clone_node): Update.\n\t(cgraph_copy_node_for_versioning): Update.\n\t(cgraph_materialize_clone): Update.\n\t(cgraph_materialize_all_clones): Update.\n\t* ipa-pure-const.c (analyze_function, pure_const_write_summary,\n\tpropagate_pure_const, propagate_nothrow): Update.\n\t* lto-streamer-out.c (lto_output, write_symbol): Update.\n\t* ipa-utils.c (ipa_reverse_postorder): Update.\n\t* ipa-inline.c (can_inline_edge_p): Update.\n\t(update_caller_keys, ipa_inline): Update.\n\t* dwarf2out.c (reference_to_unused,\n\tpremark_types_used_by_global_vars_helper): Update.\n\t* tree-eh.c (tree_could_trap_p): Update.\n\t* ipa-split.c (consider_split, execute_split_functions): Update.\n\t* ipa.c (cgraph_non_local_node_p_1, cgraph_local_node_p,\n\t has_addr_references_p): Update;\n\tmove ahead in file for better readability.\n\t(process_references): Simplify.\n\t(symtab_remove_unreachable_nodes): Update; cleanup way function/var\n\tbodies are removed.\n\t(cgraph_comdat_can_be_unshared_p): Make static.\n\t(cgraph_externally_visible_p): Update.\n\t(varpool_externally_visible_p): Update.\n\t(function_and_variable_visibility): Update.\n\t* trans-mem.c (get_cg_data, ipa_tm_mayenterirr_function,\n\tipa_tm_mark_force_output_node): Update.\n\t* ipa-inline-analysis.c (dump_inline_summary, initialize_inline_failed,\n\testimate_edge_devirt_benefit, inline_generate_summary,\n\tinline_write_summary): Update.\n\t* gimple-fold.c (can_refer_decl_in_current_unit_p): Update.\n\t* ipa-prop.c (ipa_compute_jump_functions): Update.\n\t(ipa_print_node_params, ipa_prop_read_section, ipa_update_after_lto_read,\n\tread_replacements_section): Update.\n\t* varasm.c (mark_decl_referenced): Update.\n\t(assemble_alias, dump_tm_clone_pairs): Update.\n\t* tree-inline.c (copy_bb): Update.\n\t(estimate_num_insns, optimize_inline_calls, tree_function_versioning):\n\tUpdate.\n\t* symtab.c (dump_symtab_base): Print new flags.\n\t(verify_symtab_base): Verify new flags.\n\t(symtab_alias_ultimate_target): New function.\n\t* tree-ssa-structalias.c (get_constraint_for_ssa_var,\n\tcreate_variable_info_for, associate_varinfo_to_alias, ipa_pta_execute):\n\tUpdate.\n\t* passes.c (ipa_write_summaries, ipa_write_optimization_summaries): Update.\n\t* i386.c (ix86_get_function_versions_dispatcher,\n\tix86_generate_version_dispatcher_body): Update.\n\t(fold_builtin_cpu): Use varpool_add_new_variable.\n\t* varpool.c (varpool_remove_initializer): Break out from ...\n\t(varpool_remove_node): ... this one.\n\t(dump_varpool_node, varpool_node_for_asm,\n\tcgraph_variable_initializer_availability, varpool_analyze_node,\n\tvarpool_assemble_decl, varpool_remove_unreferenced_decls,\n\tvarpool_finalize_named_section_flags, varpool_create_variable_alias): Update\n\n\t* decl.c (java_mark_decl_local): Update for new symtab flags.\n\n\t* tree.c (cp_fix_function_decl_p): Update for new symtab flags.\n\t* decl2.c )var_finalized_p, cp_write_global_declarations): Likewise.\n\n\t* lto.c (has_analyzed_clone_p, lto_materialize_function): Update for new symtab\n\tflags.\n\t* lto-partition.c (get_symbol_class, lto_balanced_map): Likewise.\n\nFrom-SVN: r199422", "tree": {"sha": "3c8fecbc03b258758055280236d0a5da8994b8cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c8fecbc03b258758055280236d0a5da8994b8cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e70670cf4db3759336199993451af2739723de87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e70670cf4db3759336199993451af2739723de87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e70670cf4db3759336199993451af2739723de87", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e70670cf4db3759336199993451af2739723de87/comments", "author": null, "committer": null, "parents": [{"sha": "182802adcc315bbbc5a4e468d9a6817be6be5c08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/182802adcc315bbbc5a4e468d9a6817be6be5c08", "html_url": "https://github.com/Rust-GCC/gccrs/commit/182802adcc315bbbc5a4e468d9a6817be6be5c08"}], "stats": {"total": 1162, "additions": 676, "deletions": 486}, "files": [{"sha": "54f944a50ec2aa987be46515503389765fcc5dad", "filename": "gcc/ChangeLog", "status": "modified", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70670cf4db3759336199993451af2739723de87/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70670cf4db3759336199993451af2739723de87/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e70670cf4db3759336199993451af2739723de87", "patch": "@@ -1,3 +1,120 @@\n+2013-05-29  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.h (symtab_node_base): Add definition, alias and analyzed\n+\tflags; reorder rest of fields in more consistent way.\n+\t(varpool_node): Remove analyzed, finalized and alias.\n+\t(cgraph_ndoe): Likewise.\n+\t(symtab_alias_ultimate_target): New function.\n+\t(cgraph_function_node): Move offline.\n+\t(cgraph_reset_node): Declare.\n+\t(cgraph_comdat_can_be_unshared_p): Remove.\n+\t(varpool_remove_initializer): Declare.\n+\t(varpool_first_defined_variable, varpool_next_defined_variable\n+\tcgraph_first_defined_function, cgraph_next_defined_function): Update.\n+\t(cgraph_function_with_gimple_body_p): Update.\n+\t(varpool_all_refs_explicit_p): Update.\n+\t(symtab_alias_target): New function.\n+\t(cgraph_alias_aliased_node, varpool_alias_aliased_node): Rename to ...\n+\t(cgraph_alias_target, varpool_alias_target): .. this one; simplify.\n+\t(cgraph_function_or_thunk_node): Simplify using symtab_alias_ultimate_target.\n+\t(varpool_variable_node): Likewise.\n+\t* cgraph.c (cgraph_create_function_alias): Update.\n+\t(cgraph_add_thunk): Update.\n+\t(cgraph_remove_node): Update.\n+\t(dump_cgraph_node): Do not dump removed flags.\n+\t(cgraph_function_body_availability): Update.\n+\t(cgraph_propagate_frequency): Update.\n+\t(verify_cgraph_node): Check sanity of local flag.\n+\t(cgraph_function_node): Move here from cgraph.h; revamp for\n+\tcgraph_function_or_thunk_node.\n+\t* lto-symtab.c (lto_varpool_replace_node): Update.\n+\t(lto_symtab_resolve_can_prevail_p): Update.\n+\t(lto_symtab_merge_cgraph_nodes): Update.\n+\t* ipa-cp.c (determine_versionability, initialize_node_lattices,\n+\tpropagate_constants_accross_call, devirtualization_time_bonus,\n+\tipcp_propagate_stage): Update.\n+\t* tree-emutls.c (create_emultls_var, ipa_lower_emutls): Update.\n+\t* ipa-inline-transform.c (clone_inlined_nodes, preserve_function_body_p): Update.\n+\t* ipa-reference.c (propagate): Update.\n+\t(write_node_summary_p): Update.\n+\t* toplev.c (wrapup_global_declaration_2): Update.\n+\t* cgraphunit.c (cgraph_analyze_function): Rename to ...\n+\t(analyze_function) ... this one.\n+\t(cgraph_process_new_functions): Update.\n+\t(cgraph_reset_node): Export.\n+\t(cgraph_finalize_function): Update.\n+\t(cgraph_add_new_function): Update.\n+\t(process_function_and_variable_attributes): Update.\n+\t(varpool_finalize_decl): Update.\n+\t(symbol_finalized): Remove.\n+\t(symbol_finalized_and_needed): Rename to ...\n+\t(symbol_defined_and_needed): ... update.\n+\t(cgraph_analyze_functions): Update.\n+\t(handle_alias_pairs): Update.\n+\t(mark_functions_to_output): Update.\n+\t(assemble_thunk): Update.\n+\t(output_in_order): Update.\n+\t(output_weakrefs): Update.\n+\t(finalize_compilation_unit): Update.\n+\t* lto-cgraph.c (reachable_from_other_partition_p, lto_output_node,\n+\tlto_output_varpool_node, compute_ltrans_boundary, input_overwrite_node,\n+\tinput_node, input_varpool_node): Update.\n+\t* dbxout.c (dbxout_expand_expr): Update.\n+\t* cgraphclones.c (cgraph_clone_node): Update.\n+\t(cgraph_copy_node_for_versioning): Update.\n+\t(cgraph_materialize_clone): Update.\n+\t(cgraph_materialize_all_clones): Update.\n+\t* ipa-pure-const.c (analyze_function, pure_const_write_summary,\n+\tpropagate_pure_const, propagate_nothrow): Update.\n+\t* lto-streamer-out.c (lto_output, write_symbol): Update.\n+\t* ipa-utils.c (ipa_reverse_postorder): Update.\n+\t* ipa-inline.c (can_inline_edge_p): Update.\n+\t(update_caller_keys, ipa_inline): Update.\n+\t* dwarf2out.c (reference_to_unused,\n+\tpremark_types_used_by_global_vars_helper): Update.\n+\t* tree-eh.c (tree_could_trap_p): Update.\n+\t* ipa-split.c (consider_split, execute_split_functions): Update.\n+\t* ipa.c (cgraph_non_local_node_p_1, cgraph_local_node_p,\n+\t has_addr_references_p): Update;\n+\tmove ahead in file for better readability.\n+\t(process_references): Simplify.\n+\t(symtab_remove_unreachable_nodes): Update; cleanup way function/var\n+\tbodies are removed.\n+\t(cgraph_comdat_can_be_unshared_p): Make static.\n+\t(cgraph_externally_visible_p): Update.\n+\t(varpool_externally_visible_p): Update.\n+\t(function_and_variable_visibility): Update.\n+\t* trans-mem.c (get_cg_data, ipa_tm_mayenterirr_function,\n+\tipa_tm_mark_force_output_node): Update.\n+\t* ipa-inline-analysis.c (dump_inline_summary, initialize_inline_failed,\n+\testimate_edge_devirt_benefit, inline_generate_summary,\n+\tinline_write_summary): Update.\n+\t* gimple-fold.c (can_refer_decl_in_current_unit_p): Update.\n+\t* ipa-prop.c (ipa_compute_jump_functions): Update.\n+\t(ipa_print_node_params, ipa_prop_read_section, ipa_update_after_lto_read,\n+\tread_replacements_section): Update.\n+\t* varasm.c (mark_decl_referenced): Update.\n+\t(assemble_alias, dump_tm_clone_pairs): Update.\n+\t* tree-inline.c (copy_bb): Update.\n+\t(estimate_num_insns, optimize_inline_calls, tree_function_versioning):\n+\tUpdate.\n+\t* symtab.c (dump_symtab_base): Print new flags.\n+\t(verify_symtab_base): Verify new flags.\n+\t(symtab_alias_ultimate_target): New function.\n+\t* tree-ssa-structalias.c (get_constraint_for_ssa_var,\n+\tcreate_variable_info_for, associate_varinfo_to_alias, ipa_pta_execute):\n+\tUpdate.\n+\t* passes.c (ipa_write_summaries, ipa_write_optimization_summaries): Update.\n+\t* i386.c (ix86_get_function_versions_dispatcher,\n+\tix86_generate_version_dispatcher_body): Update.\n+\t(fold_builtin_cpu): Use varpool_add_new_variable.\n+\t* varpool.c (varpool_remove_initializer): Break out from ...\n+\t(varpool_remove_node): ... this one.\n+\t(dump_varpool_node, varpool_node_for_asm,\n+\tcgraph_variable_initializer_availability, varpool_analyze_node,\n+\tvarpool_assemble_decl, varpool_remove_unreferenced_decls,\n+\tvarpool_finalize_named_section_flags, varpool_create_variable_alias): Update\n+\n 2013-05-29  Jan Hubicka  <jh@suse.cz>\n \n \t* passes.c (init_optimization_passes): Move OMP expansion into lowering."}, {"sha": "735f48a88910a3cb4daf39066c17f8713e378b44", "filename": "gcc/cgraph.c", "status": "modified", "additions": 47, "deletions": 19, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70670cf4db3759336199993451af2739723de87/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70670cf4db3759336199993451af2739723de87/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=e70670cf4db3759336199993451af2739723de87", "patch": "@@ -563,10 +563,10 @@ cgraph_create_function_alias (tree alias, tree decl)\n   gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n   gcc_assert (TREE_CODE (alias) == FUNCTION_DECL);\n   alias_node = cgraph_get_create_node (alias);\n-  gcc_assert (!alias_node->local.finalized);\n+  gcc_assert (!alias_node->symbol.definition);\n   alias_node->thunk.alias = decl;\n-  alias_node->local.finalized = true;\n-  alias_node->alias = 1;\n+  alias_node->symbol.definition = true;\n+  alias_node->symbol.alias = true;\n   return alias_node;\n }\n \n@@ -613,8 +613,8 @@ cgraph_add_thunk (struct cgraph_node *decl_node ATTRIBUTE_UNUSED,\n   node = cgraph_get_node (alias);\n   if (node)\n     {\n-      gcc_assert (node->local.finalized);\n-      gcc_assert (!node->alias);\n+      gcc_assert (node->symbol.definition);\n+      gcc_assert (!node->symbol.alias);\n       gcc_assert (!node->thunk.thunk_p);\n       cgraph_remove_node (node);\n     }\n@@ -629,7 +629,7 @@ cgraph_add_thunk (struct cgraph_node *decl_node ATTRIBUTE_UNUSED,\n   node->thunk.virtual_offset_p = virtual_offset != NULL;\n   node->thunk.alias = real_alias;\n   node->thunk.thunk_p = true;\n-  node->local.finalized = true;\n+  node->symbol.definition = true;\n \n   return node;\n }\n@@ -1384,7 +1384,7 @@ cgraph_remove_node (struct cgraph_node *node)\n \t  && (cgraph_global_info_ready\n \t      && (TREE_ASM_WRITTEN (n->symbol.decl)\n \t\t  || DECL_EXTERNAL (n->symbol.decl)\n-\t\t  || !n->analyzed\n+\t\t  || !n->symbol.analyzed\n \t\t  || n->symbol.in_other_partition))))\n     cgraph_release_function_body (node);\n \n@@ -1521,8 +1521,6 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n \t     cgraph_availability_names [cgraph_function_body_availability (node)]);\n \n   fprintf (f, \"  Function flags:\");\n-  if (node->analyzed)\n-    fprintf (f, \" analyzed\");\n   if (node->count)\n     fprintf (f, \" executed \"HOST_WIDEST_INT_PRINT_DEC\"x\",\n \t     (HOST_WIDEST_INT)node->count);\n@@ -1534,16 +1532,12 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n     fprintf (f, \" process\");\n   if (node->local.local)\n     fprintf (f, \" local\");\n-  if (node->local.finalized)\n-    fprintf (f, \" finalized\");\n   if (node->local.redefined_extern_inline)\n     fprintf (f, \" redefined_extern_inline\");\n   if (node->only_called_at_startup)\n     fprintf (f, \" only_called_at_startup\");\n   if (node->only_called_at_exit)\n     fprintf (f, \" only_called_at_exit\");\n-  else if (node->alias)\n-    fprintf (f, \" alias\");\n   if (node->tm_clone)\n     fprintf (f, \" tm_clone\");\n \n@@ -1559,7 +1553,8 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n \t       (int)node->thunk.virtual_value,\n \t       (int)node->thunk.virtual_offset_p);\n     }\n-  if (node->alias && node->thunk.alias && DECL_P (node->thunk.alias))\n+  if (node->symbol.alias && node->thunk.alias\n+      && DECL_P (node->thunk.alias))\n     {\n       fprintf (f, \"  Alias of %s\",\n \t       lang_hooks.decl_printable_name (node->thunk.alias, 2));\n@@ -1676,7 +1671,7 @@ cgraph_function_body_availability (struct cgraph_node *node)\n {\n   enum availability avail;\n   gcc_assert (cgraph_function_flags_ready);\n-  if (!node->analyzed)\n+  if (!node->symbol.analyzed)\n     avail = AVAIL_NOT_AVAILABLE;\n   else if (node->local.local)\n     avail = AVAIL_LOCAL;\n@@ -1983,7 +1978,7 @@ cgraph_propagate_frequency (struct cgraph_node *node)\n \n   if (!node->local.local)\n     return false;\n-  gcc_assert (node->analyzed);\n+  gcc_assert (node->symbol.analyzed);\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"Processing frequency %s\\n\", cgraph_node_name (node));\n \n@@ -2342,6 +2337,11 @@ verify_cgraph_node (struct cgraph_node *node)\n       error (\"inline clone in same comdat group list\");\n       error_found = true;\n     }\n+  if (!node->symbol.definition && node->local.local)\n+    {\n+      error (\"local symbols must be defined\");\n+      error_found = true;\n+    }\n   if (node->global.inlined_to && node->symbol.externally_visible)\n     {\n       error (\"externally visible inline clone\");\n@@ -2455,7 +2455,7 @@ verify_cgraph_node (struct cgraph_node *node)\n       error_found = true;\n     }\n \n-  if (node->analyzed && node->alias)\n+  if (node->symbol.analyzed && node->symbol.alias)\n     {\n       bool ref_found = false;\n       int i;\n@@ -2486,7 +2486,7 @@ verify_cgraph_node (struct cgraph_node *node)\n \t    error_found = true;\n \t  }\n     }\n-  if (node->analyzed && node->thunk.thunk_p)\n+  if (node->symbol.analyzed && node->thunk.thunk_p)\n     {\n       if (!node->callees)\n \t{\n@@ -2504,7 +2504,7 @@ verify_cgraph_node (struct cgraph_node *node)\n           error_found = true;\n         }\n     }\n-  else if (node->analyzed && gimple_has_body_p (node->symbol.decl)\n+  else if (node->symbol.analyzed && gimple_has_body_p (node->symbol.decl)\n            && !TREE_ASM_WRITTEN (node->symbol.decl)\n            && (!DECL_EXTERNAL (node->symbol.decl) || node->global.inlined_to)\n            && !flag_wpa)\n@@ -2653,4 +2653,32 @@ cgraph_get_create_real_symbol_node (tree decl)\n \t     node->symbol.order);\n   return node;\n }\n+\n+\n+/* Given NODE, walk the alias chain to return the function NODE is alias of.\n+   Walk through thunk, too.\n+   When AVAILABILITY is non-NULL, get minimal availability in the chain.  */\n+\n+struct cgraph_node *\n+cgraph_function_node (struct cgraph_node *node, enum availability *availability)\n+{\n+  do\n+    {\n+      node = cgraph_function_or_thunk_node (node, availability);\n+      if (node->thunk.thunk_p)\n+\t{\n+\t  node = node->callees->callee;\n+\t  if (availability)\n+\t    {\n+\t      enum availability a;\n+\t      a = cgraph_function_body_availability (node);\n+\t      if (a < *availability)\n+\t\t*availability = a;\n+\t    }\n+\t  node = cgraph_function_or_thunk_node (node, availability);\n+\t}\n+    } while (node && node->thunk.thunk_p);\n+  return node;\n+}\n+\n #include \"gt-cgraph.h\""}, {"sha": "0dcc1a691df644011e31a380e2d9e6004e70ccd9", "filename": "gcc/cgraph.h", "status": "modified", "additions": 87, "deletions": 128, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70670cf4db3759336199993451af2739723de87/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70670cf4db3759336199993451af2739723de87/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=e70670cf4db3759336199993451af2739723de87", "patch": "@@ -30,7 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-ref.h\"\n \n /* Symbol table consists of functions and variables.\n-   TODO: add labels, constant pool and aliases.  */\n+   TODO: add labels and CONST_DECLs.  */\n enum symtab_type\n {\n   SYMTAB_SYMBOL,\n@@ -48,15 +48,21 @@ struct GTY(()) symtab_node_base\n   /* The symbols resolution.  */\n   ENUM_BITFIELD (ld_plugin_symbol_resolution) resolution : 8;\n \n-  /* Set when function has address taken.\n-     In current implementation it imply needed flag. */\n-  unsigned address_taken : 1;\n-  /* Set when variable is used from other LTRANS partition.  */\n-  unsigned used_from_other_partition : 1;\n-  /* Set when function is available in the other LTRANS partition.  \n-     During WPA output it is used to mark nodes that are present in\n-     multiple partitions.  */\n-  unsigned in_other_partition : 1;\n+  /*** Flags representing the symbol type.  ***/\n+\n+  /* True when symbol corresponds to a definition in current unit.\n+     set via cgraph_finalize_function or varpool_finalize_decl  */\n+  unsigned definition : 1;\n+  /* True when symbol is an alias.  \n+     Set by assemble_alias.  */\n+  unsigned alias : 1;\n+  /* Set once the definition was analyzed.  The list of references and\n+     other properties are built during analysis.  */\n+  unsigned analyzed : 1;\n+\n+\n+  /*** Visibility and linkage flags.  ***/\n+\n   /* Set when function is visible by other units.  */\n   unsigned externally_visible : 1;\n   /* Needed variables might become dead by optimization.  This flag\n@@ -65,30 +71,57 @@ struct GTY(()) symtab_node_base\n   /* True when the name is known to be unique and thus it does not need mangling.  */\n   unsigned unique_name : 1;\n \n-  /* Ordering of all symtab entries.  */\n-  int order;\n \n-  tree decl;\n+  /*** WHOPR Partitioning flags.\n+       These flags are used at ltrans stage when only part of the callgraph is\n+       available. ***/\n \n-  /* Vectors of referring and referenced entities.  */\n-  struct ipa_ref_list ref_list;\n+  /* Set when variable is used from other LTRANS partition.  */\n+  unsigned used_from_other_partition : 1;\n+  /* Set when function is available in the other LTRANS partition.  \n+     During WPA output it is used to mark nodes that are present in\n+     multiple partitions.  */\n+  unsigned in_other_partition : 1;\n \n-  /* Circular list of nodes in the same comdat group if non-NULL.  */\n-  symtab_node same_comdat_group;\n \n-  /* File stream where this node is being written to.  */\n-  struct lto_file_decl_data * lto_file_data;\n+\n+  /*** other flags.  ***/\n+\n+  /* Set when symbol has address taken. */\n+  unsigned address_taken : 1;\n+\n+\n+  /* Ordering of all symtab entries.  */\n+  int order;\n+\n+  /* Declaration representing the symbol.  */\n+  tree decl;\n \n   /* Linked list of symbol table entries starting with symtab_nodes.  */\n   symtab_node next;\n   symtab_node previous;\n+\n   /* Linked list of symbols with the same asm name.  There may be multiple\n-     entries for single symbol name in the case of LTO resolutions,\n-     existence of inline clones, or duplicated declaration. The last case\n-     is a long standing bug frontends and builtin handling. */\n+     entries for single symbol name during LTO, because symbols are renamed\n+     only after partitioning.\n+\n+     Because inline clones are kept in the assembler name has, they also produce\n+     duplicate entries.\n+\n+     There are also several long standing bugs where frontends and builtin\n+     code produce duplicated decls.  */\n   symtab_node next_sharing_asm_name;\n   symtab_node previous_sharing_asm_name;\n \n+  /* Circular list of nodes in the same comdat group if non-NULL.  */\n+  symtab_node same_comdat_group;\n+\n+  /* Vectors of referring and referenced entities.  */\n+  struct ipa_ref_list ref_list;\n+\n+  /* File stream where this node is being written to.  */\n+  struct lto_file_decl_data * lto_file_data;\n+\n   PTR GTY ((skip)) aux;\n };\n \n@@ -142,9 +175,6 @@ struct GTY(()) cgraph_local_info {\n      and its address is never taken.  */\n   unsigned local : 1;\n \n-  /* Set once it has been finalized so we consider it to be output.  */\n-  unsigned finalized : 1;\n-\n   /* False when there is something makes versioning impossible.  */\n   unsigned versionable : 1;\n \n@@ -260,11 +290,7 @@ struct GTY(()) cgraph_node {\n   unsigned lowered : 1;\n   /* Set once the function has been instantiated and its callee\n      lists created.  */\n-  unsigned analyzed : 1;\n-  /* Set when function is scheduled to be processed by local passes.  */\n   unsigned process : 1;\n-  /* Set for aliases once they got through assemble_alias.  */\n-  unsigned alias : 1;\n   /* Set for aliases created as C++ same body aliases.  */\n   unsigned same_body_alias : 1;\n   /* How commonly executed the node is.  Initialized during branch\n@@ -455,16 +481,8 @@ struct GTY(()) varpool_node {\n   /* For aliases points to declaration DECL is alias of.  */\n   tree alias_of;\n \n-  /* Set once the variable has been instantiated and its callee\n-     lists created.  */\n-  unsigned analyzed : 1;\n-  /* Set once it has been finalized so we consider it to be output.  */\n-  unsigned finalized : 1;\n   /* Set when variable is scheduled to be assembled.  */\n   unsigned output : 1;\n-  /* Set for aliases once they got through assemble_alias.  Also set for\n-     extra name aliases in varpool_extra_name_alias.  */\n-  unsigned alias : 1;\n   unsigned extra_name_alias : 1;\n };\n \n@@ -558,6 +576,7 @@ void verify_symtab_node (symtab_node);\n bool verify_symtab_base (symtab_node);\n bool symtab_used_from_object_file_p (symtab_node);\n void symtab_make_decl_local (tree);\n+symtab_node symtab_alias_ultimate_target (symtab_node, enum availability *);\n \n /* In cgraph.c  */\n void dump_cgraph (FILE *);\n@@ -653,6 +672,7 @@ struct cgraph_2node_hook_list *cgraph_add_node_duplication_hook (cgraph_2node_ho\n void cgraph_remove_node_duplication_hook (struct cgraph_2node_hook_list *);\n gimple cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *);\n bool cgraph_propagate_frequency (struct cgraph_node *node);\n+struct cgraph_node * cgraph_function_node (struct cgraph_node *, enum availability *);\n \n /* In cgraphunit.c  */\n struct asm_node *add_asm_node (tree);\n@@ -663,10 +683,11 @@ void compile (void);\n void init_cgraph (void);\n bool cgraph_process_new_functions (void);\n void cgraph_process_same_body_aliases (void);\n-void fixup_same_cpp_alias_visibility (symtab_node node, symtab_node target, tree alias);\n+void fixup_same_cpp_alias_visibility (symtab_node, symtab_node target, tree);\n /*  Initialize datastructures so DECL is a function in lowered gimple form.\n     IN_SSA is true if the gimple is in SSA.  */\n-basic_block init_lowered_empty_function (tree decl, bool in_ssa);\n+basic_block init_lowered_empty_function (tree, bool);\n+void cgraph_reset_node (struct cgraph_node *);\n \n /* In cgraphclones.c  */\n \n@@ -728,7 +749,6 @@ void dump_varpool_node_set (FILE *, varpool_node_set);\n void debug_varpool_node_set (varpool_node_set);\n void free_varpool_node_set (varpool_node_set);\n void ipa_discover_readonly_nonaddressable_vars (void);\n-bool cgraph_comdat_can_be_unshared_p (struct cgraph_node *);\n bool varpool_externally_visible_p (struct varpool_node *);\n \n /* In predict.c  */\n@@ -765,6 +785,7 @@ bool varpool_for_node_and_aliases (struct varpool_node *,\n void varpool_add_new_variable (tree);\n void symtab_initialize_asm_name_hash (void);\n void symtab_prevail_in_asm_name_hash (symtab_node node);\n+void varpool_remove_initializer (struct varpool_node *);\n \n \n /* Return callgraph node for given symbol and check it is a function. */\n@@ -900,7 +921,7 @@ varpool_first_defined_variable (void)\n   for (node = symtab_nodes; node; node = node->symbol.next)\n     {\n       varpool_node *vnode = dyn_cast <varpool_node> (node);\n-      if (vnode && vnode->analyzed)\n+      if (vnode && vnode->symbol.definition)\n \treturn vnode;\n     }\n   return NULL;\n@@ -914,7 +935,7 @@ varpool_next_defined_variable (struct varpool_node *node)\n   for (; node1; node1 = node1->symbol.next)\n     {\n       varpool_node *vnode1 = dyn_cast <varpool_node> (node1);\n-      if (vnode1 && vnode1->analyzed)\n+      if (vnode1 && vnode1->symbol.definition)\n \treturn vnode1;\n     }\n   return NULL;\n@@ -932,7 +953,7 @@ cgraph_first_defined_function (void)\n   for (node = symtab_nodes; node; node = node->symbol.next)\n     {\n       cgraph_node *cn = dyn_cast <cgraph_node> (node);\n-      if (cn && cn->analyzed)\n+      if (cn && cn->symbol.definition)\n \treturn cn;\n     }\n   return NULL;\n@@ -946,7 +967,7 @@ cgraph_next_defined_function (struct cgraph_node *node)\n   for (; node1; node1 = node1->symbol.next)\n     {\n       cgraph_node *cn1 = dyn_cast <cgraph_node> (node1);\n-      if (cn1 && cn1->analyzed)\n+      if (cn1 && cn1->symbol.definition)\n \treturn cn1;\n     }\n   return NULL;\n@@ -992,7 +1013,7 @@ cgraph_next_function (struct cgraph_node *node)\n static inline bool\n cgraph_function_with_gimple_body_p (struct cgraph_node *node)\n {\n-  return node->analyzed && !node->thunk.thunk_p && !node->alias;\n+  return node->symbol.definition && !node->thunk.thunk_p && !node->symbol.alias;\n }\n \n /* Return first function with body defined.  */\n@@ -1197,7 +1218,7 @@ varpool_can_remove_if_no_refs (struct varpool_node *node)\n static inline bool\n varpool_all_refs_explicit_p (struct varpool_node *vnode)\n {\n-  return (vnode->analyzed\n+  return (vnode->symbol.definition\n \t  && !vnode->symbol.externally_visible\n \t  && !vnode->symbol.used_from_other_partition\n \t  && !vnode->symbol.force_output);\n@@ -1211,60 +1232,25 @@ htab_t constant_pool_htab (void);\n \n /* Return node that alias N is aliasing.  */\n \n-static inline struct cgraph_node *\n-cgraph_alias_aliased_node (struct cgraph_node *n)\n+static inline symtab_node\n+symtab_alias_target (symtab_node n)\n {\n   struct ipa_ref *ref;\n-\n   ipa_ref_list_reference_iterate (&n->symbol.ref_list, 0, ref);\n   gcc_checking_assert (ref->use == IPA_REF_ALIAS);\n-  if (is_a <cgraph_node> (ref->referred))\n-    return ipa_ref_node (ref);\n-  return NULL;\n+  return ref->referred;\n }\n \n-/* Return node that alias N is aliasing.  */\n-\n-static inline struct varpool_node *\n-varpool_alias_aliased_node (struct varpool_node *n)\n+static inline struct cgraph_node *\n+cgraph_alias_target (struct cgraph_node *n)\n {\n-  struct ipa_ref *ref;\n-\n-  ipa_ref_list_reference_iterate (&n->symbol.ref_list, 0, ref);\n-  gcc_checking_assert (ref->use == IPA_REF_ALIAS);\n-  if (is_a <varpool_node> (ref->referred))\n-    return ipa_ref_varpool_node (ref);\n-  return NULL;\n+  return dyn_cast <cgraph_node> (symtab_alias_target ((symtab_node) n));\n }\n \n-/* Given NODE, walk the alias chain to return the function NODE is alias of.\n-   Walk through thunk, too.\n-   When AVAILABILITY is non-NULL, get minimal availability in the chain.  */\n-\n-static inline struct cgraph_node *\n-cgraph_function_node (struct cgraph_node *node, enum availability *availability)\n+static inline struct varpool_node *\n+varpool_alias_target (struct varpool_node *n)\n {\n-  if (availability)\n-    *availability = cgraph_function_body_availability (node);\n-  while (node)\n-    {\n-      if (node->alias && node->analyzed)\n-\tnode = cgraph_alias_aliased_node (node);\n-      else if (node->thunk.thunk_p)\n-\tnode = node->callees->callee;\n-      else\n-\treturn node;\n-      if (node && availability)\n-\t{\n-\t  enum availability a;\n-\t  a = cgraph_function_body_availability (node);\n-\t  if (a < *availability)\n-\t    *availability = a;\n-\t}\n-    }\n-  if (availability)\n-    *availability = AVAIL_NOT_AVAILABLE;\n-  return NULL;\n+  return dyn_cast <varpool_node> (symtab_alias_target ((symtab_node) n));\n }\n \n /* Given NODE, walk the alias chain to return the function NODE is alias of.\n@@ -1274,53 +1260,26 @@ cgraph_function_node (struct cgraph_node *node, enum availability *availability)\n static inline struct cgraph_node *\n cgraph_function_or_thunk_node (struct cgraph_node *node, enum availability *availability)\n {\n-  if (availability)\n-    *availability = cgraph_function_body_availability (node);\n-  while (node)\n-    {\n-      if (node->alias && node->analyzed)\n-\tnode = cgraph_alias_aliased_node (node);\n-      else\n-\treturn node;\n-      if (node && availability)\n-\t{\n-\t  enum availability a;\n-\t  a = cgraph_function_body_availability (node);\n-\t  if (a < *availability)\n-\t    *availability = a;\n-\t}\n-    }\n-  if (availability)\n+  struct cgraph_node *n;\n+\n+  n = dyn_cast <cgraph_node> (symtab_alias_ultimate_target ((symtab_node)node, availability));\n+  if (!n)\n     *availability = AVAIL_NOT_AVAILABLE;\n-  return NULL;\n+  return n;\n }\n-\n /* Given NODE, walk the alias chain to return the function NODE is alias of.\n    Do not walk through thunks.\n    When AVAILABILITY is non-NULL, get minimal availability in the chain.  */\n \n static inline struct varpool_node *\n varpool_variable_node (struct varpool_node *node, enum availability *availability)\n {\n-  if (availability)\n-    *availability = cgraph_variable_initializer_availability (node);\n-  while (node)\n-    {\n-      if (node->alias && node->analyzed)\n-\tnode = varpool_alias_aliased_node (node);\n-      else\n-\treturn node;\n-      if (node && availability)\n-\t{\n-\t  enum availability a;\n-\t  a = cgraph_variable_initializer_availability (node);\n-\t  if (a < *availability)\n-\t    *availability = a;\n-\t}\n-    }\n-  if (availability)\n+  struct varpool_node *n;\n+\n+  n = dyn_cast <varpool_node> (symtab_alias_ultimate_target ((symtab_node)node, availability));\n+  if (!n)\n     *availability = AVAIL_NOT_AVAILABLE;\n-  return NULL;\n+  return n;\n }\n \n /* Return true when the edge E represents a direct recursion.  */\n@@ -1355,7 +1314,7 @@ cgraph_mark_force_output_node (struct cgraph_node *node)\n }\n \n /* Return true when the symbol is real symbol, i.e. it is not inline clone\n-   or extern function kept around just for inlining.  */\n+   or abstract function kept for debug info purposes only.  */\n \n static inline bool\n symtab_real_symbol_p (symtab_node node)"}, {"sha": "d82eb371798c4e7a333268b2362b2de34e209a60", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70670cf4db3759336199993451af2739723de87/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70670cf4db3759336199993451af2739723de87/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=e70670cf4db3759336199993451af2739723de87", "patch": "@@ -189,7 +189,8 @@ cgraph_clone_node (struct cgraph_node *n, tree decl, gcov_type count, int freq,\n       new_node->next_nested = new_node->origin->nested;\n       new_node->origin->nested = new_node;\n     }\n-  new_node->analyzed = n->analyzed;\n+  new_node->symbol.analyzed = n->symbol.analyzed;\n+  new_node->symbol.definition = n->symbol.definition;\n   new_node->local = n->local;\n   new_node->symbol.externally_visible = false;\n   new_node->local.local = true;\n@@ -638,10 +639,11 @@ cgraph_copy_node_for_versioning (struct cgraph_node *old_version,\n \n    new_version = cgraph_create_node (new_decl);\n \n-   new_version->analyzed = old_version->analyzed;\n+   new_version->symbol.analyzed = old_version->symbol.analyzed;\n+   new_version->symbol.definition = old_version->symbol.definition;\n    new_version->local = old_version->local;\n    new_version->symbol.externally_visible = false;\n-   new_version->local.local = old_version->analyzed;\n+   new_version->local.local = new_version->symbol.definition;\n    new_version->global = old_version->global;\n    new_version->rtl = old_version->rtl;\n    new_version->count = old_version->count;\n@@ -791,7 +793,7 @@ cgraph_materialize_clone (struct cgraph_node *node)\n     node->clone_of->clones = node->next_sibling_clone;\n   node->next_sibling_clone = NULL;\n   node->prev_sibling_clone = NULL;\n-  if (!node->clone_of->analyzed && !node->clone_of->clones)\n+  if (!node->clone_of->symbol.analyzed && !node->clone_of->clones)\n     {\n       cgraph_release_function_body (node->clone_of);\n       cgraph_node_remove_callees (node->clone_of);\n@@ -874,7 +876,7 @@ cgraph_materialize_all_clones (void)\n \t}\n     }\n   FOR_EACH_FUNCTION (node)\n-    if (!node->analyzed && node->callees)\n+    if (!node->symbol.analyzed && node->callees)\n       cgraph_node_remove_callees (node);\n   if (cgraph_dump_file)\n     fprintf (cgraph_dump_file, \"Materialization Call site updates done.\\n\");"}, {"sha": "ca314a684763b8951f9fa46d1aa2f1b02f3e92e6", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 53, "deletions": 64, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70670cf4db3759336199993451af2739723de87/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70670cf4db3759336199993451af2739723de87/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=e70670cf4db3759336199993451af2739723de87", "patch": "@@ -202,7 +202,7 @@ cgraph_node_set cgraph_new_nodes;\n static void expand_all_functions (void);\n static void mark_functions_to_output (void);\n static void expand_function (struct cgraph_node *);\n-static void cgraph_analyze_function (struct cgraph_node *);\n+static void analyze_function (struct cgraph_node *);\n static void handle_alias_pairs (void);\n \n FILE *cgraph_dump_file;\n@@ -309,8 +309,8 @@ cgraph_process_new_functions (void)\n \t     cgraph but not on this function.  */\n \n \t  gimple_register_cfg_hooks ();\n-\t  if (!node->analyzed)\n-\t    cgraph_analyze_function (node);\n+\t  if (!node->symbol.analyzed)\n+\t    analyze_function (node);\n \t  push_cfun (DECL_STRUCT_FUNCTION (fndecl));\n \t  if ((cgraph_state == CGRAPH_STATE_IPA_SSA\n \t      && !gimple_in_ssa_p (DECL_STRUCT_FUNCTION (fndecl)))\n@@ -354,7 +354,7 @@ cgraph_process_new_functions (void)\n    ??? It may make more sense to use one body for inlining and other\n    body for expanding the function but this is difficult to do.  */\n \n-static void\n+void\n cgraph_reset_node (struct cgraph_node *node)\n {\n   /* If node->process is set, then we have already begun whole-unit analysis.\n@@ -368,10 +368,11 @@ cgraph_reset_node (struct cgraph_node *node)\n   memset (&node->local, 0, sizeof (node->local));\n   memset (&node->global, 0, sizeof (node->global));\n   memset (&node->rtl, 0, sizeof (node->rtl));\n-  node->analyzed = false;\n-  node->local.finalized = false;\n+  node->symbol.analyzed = false;\n+  node->symbol.definition = false;\n \n   cgraph_node_remove_callees (node);\n+  ipa_remove_all_references (&node->symbol.ref_list);\n }\n \n /* Return true when there are references to NODE.  */\n@@ -401,14 +402,14 @@ cgraph_finalize_function (tree decl, bool nested)\n {\n   struct cgraph_node *node = cgraph_get_create_node (decl);\n \n-  if (node->local.finalized)\n+  if (node->symbol.definition)\n     {\n       cgraph_reset_node (node);\n       node->local.redefined_extern_inline = true;\n     }\n \n   notice_global_symbol (decl);\n-  node->local.finalized = true;\n+  node->symbol.definition = true;\n   node->lowered = DECL_STRUCT_FUNCTION (decl)->cfg != NULL;\n \n   /* With -fkeep-inline-functions we are keeping all inline functions except\n@@ -488,7 +489,7 @@ cgraph_add_new_function (tree fndecl, bool lowered)\n \t   analyzing and compilation.  */\n \tnode = cgraph_get_create_node (fndecl);\n \tnode->local.local = false;\n-\tnode->local.finalized = true;\n+\tnode->symbol.definition = true;\n \tnode->symbol.force_output = true;\n \tif (!lowered && cgraph_state == CGRAPH_STATE_EXPANSION)\n \t  {\n@@ -515,7 +516,8 @@ cgraph_add_new_function (tree fndecl, bool lowered)\n \tnode = cgraph_create_node (fndecl);\n \tif (lowered)\n \t  node->lowered = true;\n-\tcgraph_analyze_function (node);\n+\tnode->symbol.definition = true;\n+\tanalyze_function (node);\n \tpush_cfun (DECL_STRUCT_FUNCTION (fndecl));\n \tgimple_register_cfg_hooks ();\n \tbitmap_obstack_initialize (NULL);\n@@ -589,23 +591,23 @@ fixup_same_cpp_alias_visibility (symtab_node node, symtab_node target, tree alia\n \n /* Analyze the function scheduled to be output.  */\n static void\n-cgraph_analyze_function (struct cgraph_node *node)\n+analyze_function (struct cgraph_node *node)\n {\n   tree decl = node->symbol.decl;\n   location_t saved_loc = input_location;\n   input_location = DECL_SOURCE_LOCATION (decl);\n \n-  if (node->alias && node->thunk.alias)\n+  if (node->symbol.alias && node->thunk.alias)\n     {\n       struct cgraph_node *tgt = cgraph_get_node (node->thunk.alias);\n       struct cgraph_node *n;\n \n-      for (n = tgt; n && n->alias;\n-\t   n = n->analyzed ? cgraph_alias_aliased_node (n) : NULL)\n+      for (n = tgt; n && n->symbol.alias;\n+\t   n = n->symbol.analyzed ? cgraph_alias_target (n) : NULL)\n \tif (n == node)\n \t  {\n \t    error (\"function %q+D part of alias cycle\", node->symbol.decl);\n-\t    node->alias = false;\n+\t    node->symbol.alias = false;\n \t    input_location = saved_loc;\n \t    return;\n \t  }\n@@ -622,7 +624,7 @@ cgraph_analyze_function (struct cgraph_node *node)\n \t}\n \n       if (node->symbol.address_taken)\n-\tcgraph_mark_address_taken_node (cgraph_alias_aliased_node (node));\n+\tcgraph_mark_address_taken_node (cgraph_alias_target (node));\n     }\n   else if (node->thunk.thunk_p)\n     {\n@@ -677,7 +679,7 @@ cgraph_analyze_function (struct cgraph_node *node)\n \n       pop_cfun ();\n     }\n-  node->analyzed = true;\n+  node->symbol.analyzed = true;\n \n   input_location = saved_loc;\n }\n@@ -766,7 +768,7 @@ process_function_and_variable_attributes (struct cgraph_node *first,\n \t\t\t\" attribute have effect only on public objects\");\n \t}\n       if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (decl))\n-\t  && (node->local.finalized && !node->alias))\n+\t  && (node->symbol.definition && !node->symbol.alias))\n \t{\n \t  warning_at (DECL_SOURCE_LOCATION (node->symbol.decl), OPT_Wattributes,\n \t\t      \"%<weakref%> attribute ignored\"\n@@ -803,7 +805,7 @@ process_function_and_variable_attributes (struct cgraph_node *first,\n \t\t\t\" attribute have effect only on public objects\");\n \t}\n       if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (decl))\n-\t  && vnode->finalized\n+\t  && vnode->symbol.definition\n \t  && DECL_INITIAL (decl))\n \t{\n \t  warning_at (DECL_SOURCE_LOCATION (vnode->symbol.decl), OPT_Wattributes,\n@@ -828,10 +830,10 @@ varpool_finalize_decl (tree decl)\n \n   gcc_assert (TREE_STATIC (decl) || DECL_EXTERNAL (decl));\n \n-  if (node->finalized)\n+  if (node->symbol.definition)\n     return;\n   notice_global_symbol (decl);\n-  node->finalized = true;\n+  node->symbol.definition = true;\n   if (TREE_THIS_VOLATILE (decl) || DECL_PRESERVE_P (decl)\n       /* Traditionally we do not eliminate static variables when not\n \t optimizing and when not doing toplevel reoder.  */\n@@ -855,36 +857,23 @@ varpool_finalize_decl (tree decl)\n /* Determine if a symbol NODE is finalized and needed.  */\n \n inline static bool\n-symbol_finalized_and_needed (symtab_node node)\n+symbol_defined_and_needed (symtab_node node)\n {\n   if (cgraph_node *cnode = dyn_cast <cgraph_node> (node))\n-    return cnode->local.finalized\n+    return cnode->symbol.definition\n \t   && cgraph_decide_is_function_needed (cnode, cnode->symbol.decl);\n   if (varpool_node *vnode = dyn_cast <varpool_node> (node))\n-    return vnode->finalized\n+    return vnode->symbol.definition\n \t   && !DECL_EXTERNAL (vnode->symbol.decl)\n \t   && decide_is_variable_needed (vnode, vnode->symbol.decl);\n   return false;\n }\n \n-/* Determine if a symbol NODE is finalized.  */\n-\n-inline static bool\n-symbol_finalized (symtab_node node)\n-{\n-  if (cgraph_node *cnode= dyn_cast <cgraph_node> (node))\n-    return cnode->local.finalized;\n-  if (varpool_node *vnode = dyn_cast <varpool_node> (node))\n-    return vnode->finalized;\n-  return false;\n-}\n-\n-\n /* Discover all functions and variables that are trivially needed, analyze\n    them as well as all functions and variables referred by them  */\n \n static void\n-cgraph_analyze_functions (void)\n+analyze_functions (void)\n {\n   /* Keep track of already processed nodes when called multiple times for\n      intermodule optimization.  */\n@@ -914,7 +903,7 @@ cgraph_analyze_functions (void)\n \t   node != (symtab_node)first_analyzed\n \t   && node != (symtab_node)first_analyzed_var; node = node->symbol.next)\n \t{\n-\t  if (symbol_finalized_and_needed (node))\n+\t  if (symbol_defined_and_needed (node))\n \t    {\n \t      enqueue_node (node);\n \t      if (!changed && cgraph_dump_file)\n@@ -942,7 +931,7 @@ cgraph_analyze_functions (void)\n \t  node = first;\n \t  first = (symtab_node)first->symbol.aux;\n \t  cgraph_node *cnode = dyn_cast <cgraph_node> (node);\n-\t  if (cnode && cnode->local.finalized)\n+\t  if (cnode && cnode->symbol.definition)\n \t    {\n \t      struct cgraph_edge *edge;\n \t      tree decl = cnode->symbol.decl;\n@@ -951,7 +940,7 @@ cgraph_analyze_functions (void)\n \t      and later using weak alias attribute to kill its body.\n \t      See gcc.c-torture/compile/20011119-1.c  */\n \t      if (!DECL_STRUCT_FUNCTION (decl)\n-\t\t  && (!cnode->alias || !cnode->thunk.alias)\n+\t\t  && (!cnode->symbol.alias || !cnode->thunk.alias)\n \t\t  && !cnode->thunk.thunk_p\n \t\t  && !cnode->dispatcher_function)\n \t\t{\n@@ -960,11 +949,11 @@ cgraph_analyze_functions (void)\n \t\t  continue;\n \t\t}\n \n-\t      if (!cnode->analyzed)\n-\t\tcgraph_analyze_function (cnode);\n+\t      if (!cnode->symbol.analyzed)\n+\t\tanalyze_function (cnode);\n \n \t      for (edge = cnode->callees; edge; edge = edge->next_callee)\n-\t\tif (edge->callee->local.finalized)\n+\t\tif (edge->callee->symbol.definition)\n \t\t   enqueue_node ((symtab_node)edge->callee);\n \n \t      /* If decl is a clone of an abstract function,\n@@ -981,7 +970,7 @@ cgraph_analyze_functions (void)\n \t  else\n \t    {\n \t      varpool_node *vnode = dyn_cast <varpool_node> (node);\n-\t      if (vnode && vnode->finalized)\n+\t      if (vnode && vnode->symbol.definition)\n \t\tvarpool_analyze_node (vnode);\n \t    }\n \n@@ -994,7 +983,7 @@ cgraph_analyze_functions (void)\n \t\tenqueue_node (next);\n \t    }\n \t  for (i = 0; ipa_ref_list_reference_iterate (&node->symbol.ref_list, i, ref); i++)\n-\t    if (symbol_finalized (ref->referred))\n+\t    if (ref->referred->symbol.definition)\n \t      enqueue_node (ref->referred);\n           cgraph_process_new_functions ();\n \t}\n@@ -1026,15 +1015,15 @@ cgraph_analyze_functions (void)\n \t{\n \t  tree decl = node->symbol.decl;\n \n-\t  if (cnode->local.finalized && !gimple_has_body_p (decl)\n-\t      && (!cnode->alias || !cnode->thunk.alias)\n+\t  if (cnode->symbol.definition && !gimple_has_body_p (decl)\n+\t      && (!cnode->symbol.alias || !cnode->thunk.alias)\n \t      && !cnode->thunk.thunk_p)\n \t    cgraph_reset_node (cnode);\n \n-\t  gcc_assert (!cnode->local.finalized || cnode->thunk.thunk_p\n-\t\t      || cnode->alias\n+\t  gcc_assert (!cnode->symbol.definition || cnode->thunk.thunk_p\n+\t\t      || cnode->symbol.alias\n \t\t      || gimple_has_body_p (decl));\n-\t  gcc_assert (cnode->analyzed == cnode->local.finalized);\n+\t  gcc_assert (cnode->symbol.analyzed == cnode->symbol.definition);\n \t}\n       node->symbol.aux = NULL;\n     }\n@@ -1071,13 +1060,13 @@ handle_alias_pairs (void)\n \t  if (TREE_CODE (p->decl) == FUNCTION_DECL)\n \t    {\n \t      struct cgraph_node *anode = cgraph_get_create_node (p->decl);\n-\t      anode->alias = true;\n+\t      anode->symbol.alias = true;\n \t      anode->thunk.alias = p->target;\n \t    }\n \t  else\n \t    {\n \t      struct varpool_node *anode = varpool_get_node (p->decl);\n-\t      anode->alias = true;\n+\t      anode->symbol.alias = true;\n \t      anode->alias_of = p->target;\n \t    }\n \t  DECL_EXTERNAL (p->decl) = 1;\n@@ -1117,7 +1106,7 @@ handle_alias_pairs (void)\n           && target_node && is_a <cgraph_node> (target_node))\n \t{\n \t  struct cgraph_node *src_node = cgraph_get_node (p->decl);\n-\t  if (src_node && src_node->local.finalized)\n+\t  if (src_node && src_node->symbol.definition)\n             cgraph_reset_node (src_node);\n \t  cgraph_create_function_alias (p->decl, target_node->symbol.decl);\n \t  alias_pairs->unordered_remove (i);\n@@ -1165,9 +1154,9 @@ mark_functions_to_output (void)\n       /* We need to output all local functions that are used and not\n \t always inlined, as well as those that are reachable from\n \t outside the current compilation unit.  */\n-      if (node->analyzed\n+      if (node->symbol.analyzed\n \t  && !node->thunk.thunk_p\n-\t  && !node->alias\n+\t  && !node->symbol.alias\n \t  && !node->global.inlined_to\n \t  && !TREE_ASM_WRITTEN (decl)\n \t  && !DECL_EXTERNAL (decl))\n@@ -1179,7 +1168,7 @@ mark_functions_to_output (void)\n \t      for (next = cgraph (node->symbol.same_comdat_group);\n \t\t   next != node;\n \t\t   next = cgraph (next->symbol.same_comdat_group))\n-\t\tif (!next->thunk.thunk_p && !next->alias)\n+\t\tif (!next->thunk.thunk_p && !next->symbol.alias)\n \t\t  next->process = 1;\n \t    }\n \t}\n@@ -1199,7 +1188,7 @@ mark_functions_to_output (void)\n \t\t are inside partition, we can end up not removing the body since we no longer\n \t\t have analyzed node pointing to it.  */\n \t      && !node->symbol.in_other_partition\n-\t      && !node->alias\n+\t      && !node->symbol.alias\n \t      && !node->clones\n \t      && !DECL_EXTERNAL (decl))\n \t    {\n@@ -1435,7 +1424,7 @@ assemble_thunk (struct cgraph_node *node)\n       set_cfun (NULL);\n       TREE_ASM_WRITTEN (thunk_fndecl) = 1;\n       node->thunk.thunk_p = false;\n-      node->analyzed = false;\n+      node->symbol.analyzed = false;\n     }\n   else\n     {\n@@ -1800,7 +1789,7 @@ output_in_order (void)\n \n   FOR_EACH_DEFINED_FUNCTION (pf)\n     {\n-      if (pf->process && !pf->thunk.thunk_p && !pf->alias)\n+      if (pf->process && !pf->thunk.thunk_p && !pf->symbol.alias)\n \t{\n \t  i = pf->symbol.order;\n \t  gcc_assert (nodes[i].kind == ORDER_UNDEFINED);\n@@ -1943,14 +1932,14 @@ output_weakrefs (void)\n   struct cgraph_node *node;\n   struct varpool_node *vnode;\n   FOR_EACH_FUNCTION (node)\n-    if (node->alias && DECL_EXTERNAL (node->symbol.decl)\n+    if (node->symbol.alias && DECL_EXTERNAL (node->symbol.decl)\n         && !TREE_ASM_WRITTEN (node->symbol.decl)\n \t&& lookup_attribute (\"weakref\", DECL_ATTRIBUTES (node->symbol.decl)))\n       do_assemble_alias (node->symbol.decl,\n \t\t         node->thunk.alias && DECL_P (node->thunk.alias) ? DECL_ASSEMBLER_NAME (node->thunk.alias)\n \t\t         : get_alias_symbol (node->symbol.decl));\n   FOR_EACH_VARIABLE (vnode)\n-    if (vnode->alias && DECL_EXTERNAL (vnode->symbol.decl)\n+    if (vnode->symbol.alias && DECL_EXTERNAL (vnode->symbol.decl)\n         && !TREE_ASM_WRITTEN (vnode->symbol.decl)\n \t&& lookup_attribute (\"weakref\", DECL_ATTRIBUTES (vnode->symbol.decl)))\n       do_assemble_alias (vnode->symbol.decl,\n@@ -2115,13 +2104,13 @@ finalize_compilation_unit (void)\n \n   /* Gimplify and lower all functions, compute reachability and\n      remove unreachable nodes.  */\n-  cgraph_analyze_functions ();\n+  analyze_functions ();\n \n   /* Mark alias targets necessary and emit diagnostics.  */\n   handle_alias_pairs ();\n \n   /* Gimplify and lower thunks.  */\n-  cgraph_analyze_functions ();\n+  analyze_functions ();\n \n   /* Finally drive the pass manager.  */\n   compile ();"}, {"sha": "9d05a7b4cbdcfd61c192ecc8324ea4cd9c015fbc", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70670cf4db3759336199993451af2739723de87/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70670cf4db3759336199993451af2739723de87/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=e70670cf4db3759336199993451af2739723de87", "patch": "@@ -29468,7 +29468,7 @@ ix86_get_function_versions_dispatcher (void *decl)\n       dispatcher_version_info\n \t= insert_new_cgraph_node_version (dispatcher_node);\n       dispatcher_version_info->next = default_version_info;\n-      dispatcher_node->local.finalized = 1;\n+      dispatcher_node->symbol.definition = 1;\n \n       /* Set the dispatcher for all the versions.  */\n       it_v = default_version_info;\n@@ -29623,7 +29623,7 @@ ix86_generate_version_dispatcher_body (void *node_p)\n   default_ver_decl = node_version_info->next->this_node->symbol.decl;\n \n   /* node is going to be an alias, so remove the finalized bit.  */\n-  node->local.finalized = false;\n+  node->symbol.definition = false;\n \n   resolver_decl = make_resolver_func (default_ver_decl,\n \t\t\t\t      node->symbol.decl, &empty_bb);\n@@ -29817,6 +29817,9 @@ fold_builtin_cpu (tree fndecl, tree *args)\n   tree __cpu_model_var = make_var_decl (__processor_model_type,\n \t\t\t\t\t\"__cpu_model\");\n \n+\n+  varpool_add_new_variable (__cpu_model_var);\n+\n   gcc_assert ((args != NULL) && (*args != NULL));\n \n   param_string_cst = *args;"}, {"sha": "ed26fa0de231a9201dc8eb80788d9c68b83a92c6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70670cf4db3759336199993451af2739723de87/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70670cf4db3759336199993451af2739723de87/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e70670cf4db3759336199993451af2739723de87", "patch": "@@ -1,3 +1,8 @@\n+2013-05-29  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree.c (cp_fix_function_decl_p): Update for new symtab flags.\n+\t* decl2.c )var_finalized_p, cp_write_global_declarations): Likewise.\n+\n 2013-05-25  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/25666"}, {"sha": "409a7436dca74a95b55399e136333a275fd14242", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70670cf4db3759336199993451af2739723de87/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70670cf4db3759336199993451af2739723de87/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=e70670cf4db3759336199993451af2739723de87", "patch": "@@ -1803,7 +1803,7 @@ import_export_class (tree ctype)\n static bool\n var_finalized_p (tree var)\n {\n-  return varpool_node_for_decl (var)->finalized;\n+  return varpool_node_for_decl (var)->symbol.definition;\n }\n \n /* DECL is a VAR_DECL or FUNCTION_DECL which, for whatever reason,\n@@ -4202,7 +4202,7 @@ cp_write_global_declarations (void)\n \n \t      node = cgraph_get_node (decl);\n \t      if (node->same_body_alias)\n-\t\tnode = cgraph_alias_aliased_node (node);\n+\t\tnode = cgraph_alias_target (node);\n \n \t      cgraph_for_node_and_aliases (node, clear_decl_external,\n \t\t\t\t\t   NULL, true);\n@@ -4224,7 +4224,7 @@ cp_write_global_declarations (void)\n \t  if (!DECL_EXTERNAL (decl)\n \t      && decl_needed_p (decl)\n \t      && !TREE_ASM_WRITTEN (decl)\n-\t      && !cgraph_get_node (decl)->local.finalized)\n+\t      && !cgraph_get_node (decl)->symbol.definition)\n \t    {\n \t      /* We will output the function; no longer consider it in this\n \t\t loop.  */"}, {"sha": "8524f6cff913451610ae2457f7643c42802ecefa", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70670cf4db3759336199993451af2739723de87/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70670cf4db3759336199993451af2739723de87/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=e70670cf4db3759336199993451af2739723de87", "patch": "@@ -3980,7 +3980,7 @@ cp_fix_function_decl_p (tree decl)\n \n       /* Don't fix same_body aliases.  Although they don't have their own\n \t CFG, they share it with what they alias to.  */\n-      if (!node || !node->alias\n+      if (!node || !node->symbol.alias\n \t  || !vec_safe_length (node->symbol.ref_list.references))\n \treturn true;\n     }"}, {"sha": "1cc5d5242057167030f33cb362d944baad2fdae0", "filename": "gcc/dbxout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70670cf4db3759336199993451af2739723de87/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70670cf4db3759336199993451af2739723de87/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=e70670cf4db3759336199993451af2739723de87", "patch": "@@ -2480,7 +2480,7 @@ dbxout_expand_expr (tree expr)\n \t     return NULL, otherwise stabs might reference an undefined\n \t     symbol.  */\n \t  struct varpool_node *node = varpool_get_node (expr);\n-\t  if (!node || !node->analyzed)\n+\t  if (!node || !node->symbol.definition)\n \t    return NULL;\n \t}\n       /* FALLTHRU */"}, {"sha": "b615b181a3b4da56807d01367cd958fa2616c8a4", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70670cf4db3759336199993451af2739723de87/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70670cf4db3759336199993451af2739723de87/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=e70670cf4db3759336199993451af2739723de87", "patch": "@@ -14919,7 +14919,7 @@ reference_to_unused (tree * tp, int * walk_subtrees,\n   else if (TREE_CODE (*tp) == VAR_DECL)\n     {\n       struct varpool_node *node = varpool_get_node (*tp);\n-      if (!node || !node->analyzed)\n+      if (!node || !node->symbol.definition)\n \treturn *tp;\n     }\n   else if (TREE_CODE (*tp) == FUNCTION_DECL\n@@ -17597,7 +17597,7 @@ premark_types_used_by_global_vars_helper (void **slot,\n       /* Ask cgraph if the global variable really is to be emitted.\n          If yes, then we'll keep the DIE of ENTRY->TYPE.  */\n       struct varpool_node *node = varpool_get_node (entry->var_decl);\n-      if (node && node->analyzed)\n+      if (node && node->symbol.definition)\n \t{\n \t  die->die_perennial_p = 1;\n \t  /* Keep the parent DIEs as well.  */"}, {"sha": "181d28d1b617d969476044e48615a6deb3566f0a", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70670cf4db3759336199993451af2739723de87/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70670cf4db3759336199993451af2739723de87/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=e70670cf4db3759336199993451af2739723de87", "patch": "@@ -114,7 +114,7 @@ can_refer_decl_in_current_unit_p (tree decl, tree from_decl)\n          The second is important when devirtualization happens during final\n          compilation stage when making a new reference no longer makes callee\n          to be compiled.  */\n-      if (!node || !node->analyzed || node->global.inlined_to)\n+      if (!node || !node->symbol.definition || node->global.inlined_to)\n \t{\n \t  gcc_checking_assert (!TREE_ASM_WRITTEN (decl));\n \t  return false;\n@@ -123,7 +123,7 @@ can_refer_decl_in_current_unit_p (tree decl, tree from_decl)\n   else if (TREE_CODE (decl) == VAR_DECL)\n     {\n       vnode = varpool_get_node (decl);\n-      if (!vnode || !vnode->analyzed)\n+      if (!vnode || !vnode->symbol.definition)\n \t{\n \t  gcc_checking_assert (!TREE_ASM_WRITTEN (decl));\n \t  return false;"}, {"sha": "af4e94862d3acefa72a6723f281aa08d83b2033c", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70670cf4db3759336199993451af2739723de87/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70670cf4db3759336199993451af2739723de87/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=e70670cf4db3759336199993451af2739723de87", "patch": "@@ -440,14 +440,14 @@ determine_versionability (struct cgraph_node *node)\n   /* There are a number of generic reasons functions cannot be versioned.  We\n      also cannot remove parameters if there are type attributes such as fnspec\n      present.  */\n-  if (node->alias || node->thunk.thunk_p)\n+  if (node->symbol.alias || node->thunk.thunk_p)\n     reason = \"alias or thunk\";\n   else if (!node->local.versionable)\n     reason = \"not a tree_versionable_function\";\n   else if (cgraph_function_body_availability (node) <= AVAIL_OVERWRITABLE)\n     reason = \"insufficient body availability\";\n \n-  if (reason && dump_file && !node->alias && !node->thunk.thunk_p)\n+  if (reason && dump_file && !node->symbol.alias && !node->thunk.thunk_p)\n     fprintf (dump_file, \"Function %s/%i is not versionable, reason: %s.\\n\",\n \t     cgraph_node_name (node), node->symbol.order, reason);\n \n@@ -727,7 +727,7 @@ initialize_node_lattices (struct cgraph_node *node)\n \t    set_all_contains_variable (plats);\n \t}\n       if (dump_file && (dump_flags & TDF_DETAILS)\n-\t  && !node->alias && !node->thunk.thunk_p)\n+\t  && !node->symbol.alias && !node->thunk.thunk_p)\n \tfprintf (dump_file, \"Marking all lattices of %s/%i as %s\\n\",\n \t\t cgraph_node_name (node), node->symbol.order,\n \t\t disable ? \"BOTTOM\" : \"VARIABLE\");\n@@ -1418,7 +1418,7 @@ propagate_constants_accross_call (struct cgraph_edge *cs)\n   int i, args_count, parms_count;\n \n   callee = cgraph_function_node (cs->callee, &availability);\n-  if (!callee->analyzed)\n+  if (!callee->symbol.definition)\n     return false;\n   gcc_checking_assert (cgraph_function_with_gimple_body_p (callee));\n   callee_info = IPA_NODE_REF (callee);\n@@ -1431,8 +1431,8 @@ propagate_constants_accross_call (struct cgraph_edge *cs)\n      parameter.  However, we might need to uncover a thunk from below a series\n      of aliases first.  */\n   alias_or_thunk = cs->callee;\n-  while (alias_or_thunk->alias)\n-    alias_or_thunk = cgraph_alias_aliased_node (alias_or_thunk);\n+  while (alias_or_thunk->symbol.alias)\n+    alias_or_thunk = cgraph_alias_target (alias_or_thunk);\n   if (alias_or_thunk->thunk.thunk_p)\n     {\n       ret |= set_all_contains_variable (ipa_get_parm_lattices (callee_info,\n@@ -1601,7 +1601,7 @@ devirtualization_time_bonus (struct cgraph_node *node,\n       /* Only bare minimum benefit for clearly un-inlineable targets.  */\n       res += 1;\n       callee = cgraph_get_node (target);\n-      if (!callee || !callee->analyzed)\n+      if (!callee || !callee->symbol.definition)\n \tcontinue;\n       isummary = inline_summary (callee);\n       if (!isummary->inlinable)\n@@ -2231,9 +2231,10 @@ ipcp_propagate_stage (struct topo_info *topo)\n \t\t\t\t   ipa_get_param_count (info));\n \tinitialize_node_lattices (node);\n       }\n+    if (node->symbol.definition && !node->symbol.alias)\n+      overall_size += inline_summary (node)->self_size;\n     if (node->count > max_count)\n       max_count = node->count;\n-    overall_size += inline_summary (node)->self_size;\n   }\n \n   max_new_size = overall_size;"}, {"sha": "a25f51755e3b0b46d3d4f2a955e9c761ce98e1a7", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70670cf4db3759336199993451af2739723de87/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70670cf4db3759336199993451af2739723de87/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=e70670cf4db3759336199993451af2739723de87", "patch": "@@ -1351,7 +1351,7 @@ dump_inline_edge_summary (FILE *f, int indent, struct cgraph_node *node,\n void\n dump_inline_summary (FILE *f, struct cgraph_node *node)\n {\n-  if (node->analyzed)\n+  if (node->symbol.definition)\n     {\n       struct inline_summary *s = inline_summary (node);\n       size_time_entry *e;\n@@ -1427,7 +1427,7 @@ initialize_inline_failed (struct cgraph_edge *e)\n \n   if (e->indirect_unknown_callee)\n     e->inline_failed = CIF_INDIRECT_UNKNOWN_CALL;\n-  else if (!callee->analyzed)\n+  else if (!callee->symbol.definition)\n     e->inline_failed = CIF_BODY_NOT_AVAILABLE;\n   else if (callee->local.redefined_extern_inline)\n     e->inline_failed = CIF_REDEFINED_EXTERN_INLINE;\n@@ -2765,7 +2765,7 @@ estimate_edge_devirt_benefit (struct cgraph_edge *ie,\n   gcc_checking_assert (*size >= 0);\n \n   callee = cgraph_get_node (target);\n-  if (!callee || !callee->analyzed)\n+  if (!callee || !callee->symbol.definition)\n     return false;\n   isummary = inline_summary (callee);\n   return isummary->inlinable;\n@@ -3683,7 +3683,7 @@ inline_generate_summary (void)\n   inline_free_summary ();\n \n   FOR_EACH_DEFINED_FUNCTION (node)\n-    if (!node->alias)\n+    if (!node->symbol.alias)\n       inline_analyze_function (node);\n }\n \n@@ -3917,7 +3917,7 @@ inline_write_summary (void)\n     {\n       symtab_node snode = lto_symtab_encoder_deref (encoder, i);\n       cgraph_node *cnode = dyn_cast <cgraph_node> (snode);\n-      if (cnode && cnode->analyzed)\n+      if (cnode && cnode->symbol.definition && !cnode->symbol.alias)\n \tcount++;\n     }\n   streamer_write_uhwi (ob, count);\n@@ -3926,7 +3926,7 @@ inline_write_summary (void)\n     {\n       symtab_node snode = lto_symtab_encoder_deref (encoder, i);\n       cgraph_node *cnode = dyn_cast <cgraph_node> (snode);\n-      if (cnode && (node = cnode)->analyzed)\n+      if (cnode && (node = cnode)->symbol.definition && !node->symbol.alias)\n \t{\n \t  struct inline_summary *info = inline_summary (node);\n \t  struct bitpack_d bp;"}, {"sha": "9e131a4aa0e78c9ea428004196fbc4763c0ed711", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70670cf4db3759336199993451af2739723de87/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70670cf4db3759336199993451af2739723de87/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=e70670cf4db3759336199993451af2739723de87", "patch": "@@ -153,7 +153,7 @@ clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n \t     cgraph_remove_unreachable_functions gets rid of them.  */\n \t  gcc_assert (!e->callee->global.inlined_to);\n           symtab_dissolve_same_comdat_group_list ((symtab_node) e->callee);\n-\t  if (e->callee->analyzed && !DECL_EXTERNAL (e->callee->symbol.decl))\n+\t  if (e->callee->symbol.definition && !DECL_EXTERNAL (e->callee->symbol.decl))\n \t    {\n \t      if (overall_size)\n \t        *overall_size -= inline_summary (e->callee)->size;\n@@ -236,7 +236,7 @@ inline_call (struct cgraph_edge *e, bool update_original,\n \t  if (!alias->callers\n \t      && can_remove_node_now_p (alias, e))\n \t    {\n-\t      next_alias = cgraph_alias_aliased_node (alias);\n+\t      next_alias = cgraph_alias_target (alias);\n \t      cgraph_remove_node (alias);\n \t      alias = next_alias;\n \t    }\n@@ -381,7 +381,7 @@ static bool\n preserve_function_body_p (struct cgraph_node *node)\n {\n   gcc_assert (cgraph_global_info_ready);\n-  gcc_assert (!node->alias && !node->thunk.thunk_p);\n+  gcc_assert (!node->symbol.alias && !node->thunk.thunk_p);\n \n   /* Look if there is any clone around.  */\n   if (node->clones)"}, {"sha": "a378c08f42f7ab538377633bb97a3164cdea85f9", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70670cf4db3759336199993451af2739723de87/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70670cf4db3759336199993451af2739723de87/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=e70670cf4db3759336199993451af2739723de87", "patch": "@@ -253,7 +253,7 @@ can_inline_edge_p (struct cgraph_edge *e, bool report)\n \n   gcc_assert (e->inline_failed);\n \n-  if (!callee || !callee->analyzed)\n+  if (!callee || !callee->symbol.definition)\n     {\n       e->inline_failed = CIF_BODY_NOT_AVAILABLE;\n       inlinable = false;\n@@ -1100,7 +1100,7 @@ update_caller_keys (fibheap_t heap, struct cgraph_node *node,\n   int i;\n   struct ipa_ref *ref;\n \n-  if ((!node->alias && !inline_summary (node)->inlinable)\n+  if ((!node->symbol.alias && !inline_summary (node)->inlinable)\n       || cgraph_function_body_availability (node) <= AVAIL_OVERWRITABLE\n       || node->global.inlined_to)\n     return;\n@@ -1795,6 +1795,9 @@ ipa_inline (void)\n     }\n \n   inline_small_functions ();\n+\n+  /* Do first after-inlining removal.  We want to remove all \"stale\" extern inline\n+     functions and virtual functions so we really know what is called once.  */\n   symtab_remove_unreachable_nodes (false, dump_file);\n   free (order);\n "}, {"sha": "8918c5b3bf5b6159376c71f3d4a9531eaf7a18e1", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70670cf4db3759336199993451af2739723de87/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70670cf4db3759336199993451af2739723de87/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=e70670cf4db3759336199993451af2739723de87", "patch": "@@ -1521,7 +1521,7 @@ ipa_compute_jump_functions (struct cgraph_node *node,\n \t\t\t\t\t\t\t\t  NULL);\n       /* We do not need to bother analyzing calls to unknown\n \t functions unless they may become known during lto/whopr.  */\n-      if (!callee->analyzed && !flag_lto)\n+      if (!callee->symbol.definition && !flag_lto)\n \tcontinue;\n       ipa_compute_jump_functions_for_edge (parms_ainfo, cs);\n     }\n@@ -2978,7 +2978,7 @@ ipa_print_node_params (FILE *f, struct cgraph_node *node)\n   tree temp;\n   struct ipa_node_params *info;\n \n-  if (!node->analyzed)\n+  if (!node->symbol.definition)\n     return;\n   info = IPA_NODE_REF (node);\n   fprintf (f, \"  function  %s/%i parameter descriptors:\\n\",\n@@ -3972,7 +3972,7 @@ ipa_prop_read_section (struct lto_file_decl_data *file_data, const char *data,\n       index = streamer_read_uhwi (&ib_main);\n       encoder = file_data->symtab_node_encoder;\n       node = cgraph (lto_symtab_encoder_deref (encoder, index));\n-      gcc_assert (node->analyzed);\n+      gcc_assert (node->symbol.definition);\n       ipa_read_node_info (&ib_main, node, data_in);\n     }\n   lto_free_section_data (file_data, LTO_section_jump_functions, NULL, data,\n@@ -4016,8 +4016,7 @@ ipa_update_after_lto_read (void)\n   ipa_check_create_edge_args ();\n \n   FOR_EACH_DEFINED_FUNCTION (node)\n-    if (node->analyzed)\n-      ipa_initialize_node_params (node);\n+    ipa_initialize_node_params (node);\n }\n \n void\n@@ -4154,7 +4153,7 @@ read_replacements_section (struct lto_file_decl_data *file_data,\n       index = streamer_read_uhwi (&ib_main);\n       encoder = file_data->symtab_node_encoder;\n       node = cgraph (lto_symtab_encoder_deref (encoder, index));\n-      gcc_assert (node->analyzed);\n+      gcc_assert (node->symbol.definition);\n       read_agg_replacement_chain (&ib_main, node, data_in);\n     }\n   lto_free_section_data (file_data, LTO_section_jump_functions, NULL, data,"}, {"sha": "c6c41c6657aec18f77d9c0131071bc3da7c065b0", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70670cf4db3759336199993451af2739723de87/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70670cf4db3759336199993451af2739723de87/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=e70670cf4db3759336199993451af2739723de87", "patch": "@@ -738,7 +738,7 @@ analyze_function (struct cgraph_node *fn, bool ipa)\n \t\t    flags_from_decl_or_type (fn->symbol.decl),\n \t\t    cgraph_node_cannot_return (fn));\n \n-  if (fn->thunk.thunk_p || fn->alias)\n+  if (fn->thunk.thunk_p || fn->symbol.alias)\n     {\n       /* Thunk gets propagated through, so nothing interesting happens.  */\n       gcc_assert (ipa);\n@@ -951,7 +951,7 @@ pure_const_write_summary (void)\n        lsei_next_function_in_partition (&lsei))\n     {\n       node = lsei_cgraph_node (lsei);\n-      if (node->analyzed && has_function_state (node))\n+      if (node->symbol.definition && has_function_state (node))\n \tcount++;\n     }\n \n@@ -962,7 +962,7 @@ pure_const_write_summary (void)\n        lsei_next_function_in_partition (&lsei))\n     {\n       node = lsei_cgraph_node (lsei);\n-      if (node->analyzed && has_function_state (node))\n+      if (node->symbol.definition && has_function_state (node))\n \t{\n \t  struct bitpack_d bp;\n \t  funct_state fs;\n@@ -1124,7 +1124,7 @@ propagate_pure_const (void)\n       int count = 0;\n       node = order[i];\n \n-      if (node->alias)\n+      if (node->symbol.alias)\n \tcontinue;\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -1394,7 +1394,7 @@ propagate_nothrow (void)\n       bool can_throw = false;\n       node = order[i];\n \n-      if (node->alias)\n+      if (node->symbol.alias)\n \tcontinue;\n \n       /* Find the worst state for any node in the cycle.  */"}, {"sha": "9c56b7f55180a531622f91e28b23ac3a3866478c", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70670cf4db3759336199993451af2739723de87/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70670cf4db3759336199993451af2739723de87/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=e70670cf4db3759336199993451af2739723de87", "patch": "@@ -684,7 +684,7 @@ propagate (void)\n \t|| TREE_ADDRESSABLE (vnode->symbol.decl)\n \t|| TREE_READONLY (vnode->symbol.decl)\n \t|| !is_proper_for_analysis (vnode->symbol.decl)\n-\t|| !vnode->analyzed)\n+\t|| !vnode->symbol.definition)\n       bitmap_clear_bit (all_module_statics, DECL_UID (vnode->symbol.decl));\n \n   /* Forget info we collected \"just for fun\" on variables that turned out to be\n@@ -716,7 +716,7 @@ propagate (void)\n       bool write_all = false;\n \n       node = order[i];\n-      if (node->alias)\n+      if (node->symbol.alias)\n \tcontinue;\n \n       node_info = get_reference_vars_info (node);\n@@ -794,7 +794,7 @@ propagate (void)\n \t  struct cgraph_node *w;\n \n \t  node = order[i];\n-\t  if (node->alias)\n+\t  if (node->symbol.alias)\n \t    continue;\n \n \t  fprintf (dump_file,\n@@ -835,7 +835,7 @@ propagate (void)\n       ipa_reference_optimization_summary_t opt;\n \n       node_info = get_reference_vars_info (node);\n-      if (!node->alias\n+      if (!node->symbol.alias\n \t  && (cgraph_function_body_availability (node) > AVAIL_OVERWRITABLE\n \t      || (flags_from_decl_or_type (node->symbol.decl) & ECF_LEAF)))\n \t{\n@@ -894,7 +894,7 @@ write_node_summary_p (struct cgraph_node *node,\n   ipa_reference_optimization_summary_t info;\n \n   /* See if we have (non-empty) info.  */\n-  if (!node->analyzed || node->global.inlined_to)\n+  if (!node->symbol.definition || node->global.inlined_to)\n     return false;\n   info = get_reference_optimization_summary (node);\n   if (!info || (bitmap_empty_p (info->statics_not_read)"}, {"sha": "e786478981e43731ed4489a00870b3e94dbefae5", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70670cf4db3759336199993451af2739723de87/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70670cf4db3759336199993451af2739723de87/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=e70670cf4db3759336199993451af2739723de87", "patch": "@@ -367,23 +367,46 @@ consider_split (struct split_point *current, bitmap non_ssa_vars,\n   unsigned int i;\n   int incoming_freq = 0;\n   tree retval;\n+  bool back_edge = false;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     dump_split_point (dump_file, current);\n \n   FOR_EACH_EDGE (e, ei, current->entry_bb->preds)\n-    if (!bitmap_bit_p (current->split_bbs, e->src->index))\n-      incoming_freq += EDGE_FREQUENCY (e);\n+    {\n+      if (e->flags & EDGE_DFS_BACK)\n+\tback_edge = true;\n+      if (!bitmap_bit_p (current->split_bbs, e->src->index))\n+        incoming_freq += EDGE_FREQUENCY (e);\n+    }\n \n   /* Do not split when we would end up calling function anyway.  */\n   if (incoming_freq\n       >= (ENTRY_BLOCK_PTR->frequency\n \t  * PARAM_VALUE (PARAM_PARTIAL_INLINING_ENTRY_PROBABILITY) / 100))\n     {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file,\n-\t\t \"  Refused: incoming frequency is too large.\\n\");\n-      return;\n+      /* When profile is guessed, we can not expect it to give us\n+\t realistic estimate on likelyness of function taking the\n+\t complex path.  As a special case, when tail of the function is\n+\t a loop, enable splitting since inlining code skipping the loop\n+\t is likely noticeable win.  */\n+      if (back_edge\n+\t  && profile_status != PROFILE_READ\n+\t  && incoming_freq < ENTRY_BLOCK_PTR->frequency)\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file,\n+\t\t     \"  Split before loop, accepting despite low frequencies %i %i.\\n\",\n+\t\t     incoming_freq,\n+\t\t     ENTRY_BLOCK_PTR->frequency);\n+\t}\n+      else\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file,\n+\t\t     \"  Refused: incoming frequency is too large.\\n\");\n+\t  return;\n+\t}\n     }\n \n   if (!current->header_size)\n@@ -1533,6 +1556,11 @@ execute_split_functions (void)\n       return 0;\n     }\n \n+  /* We enforce splitting after loop headers when profile info is not\n+     available.  */\n+  if (profile_status != PROFILE_READ)\n+    mark_dfs_back_edges ();\n+\n   /* Initialize bitmap to track forbidden calls.  */\n   forbidden_dominators = BITMAP_ALLOC (NULL);\n   calculate_dominance_info (CDI_DOMINATORS);"}, {"sha": "00e65285c54cf10273bc414b793eec6f5cc93c27", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70670cf4db3759336199993451af2739723de87/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70670cf4db3759336199993451af2739723de87/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=e70670cf4db3759336199993451af2739723de87", "patch": "@@ -287,7 +287,7 @@ ipa_reverse_postorder (struct cgraph_node **order)\n \t  && (pass\n \t      || (!node->symbol.address_taken\n \t\t  && !node->global.inlined_to\n-\t\t  && !node->alias && !node->thunk.thunk_p\n+\t\t  && !node->symbol.alias && !node->thunk.thunk_p\n \t\t  && !cgraph_only_called_directly_p (node))))\n \t{\n \t  stack_size = 0;"}, {"sha": "254c09fa4fb60d30e9be99b234b559714dc909f9", "filename": "gcc/ipa.c", "status": "modified", "additions": 89, "deletions": 92, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70670cf4db3759336199993451af2739723de87/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70670cf4db3759336199993451af2739723de87/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=e70670cf4db3759336199993451af2739723de87", "patch": "@@ -39,6 +39,53 @@ along with GCC; see the file COPYING3.  If not see\n #include \"lto-streamer.h\"\n #include \"data-streamer.h\"\n \n+/* Return true when NODE can not be local. Worker for cgraph_local_node_p.  */\n+\n+static bool\n+cgraph_non_local_node_p_1 (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n+{\n+   /* FIXME: Aliases can be local, but i386 gets thunks wrong then.  */\n+   return !(cgraph_only_called_directly_or_aliased_p (node)\n+\t    && !ipa_ref_has_aliases_p (&node->symbol.ref_list)\n+\t    && node->symbol.definition\n+\t    && !DECL_EXTERNAL (node->symbol.decl)\n+\t    && !node->symbol.externally_visible\n+\t    && !node->symbol.used_from_other_partition\n+\t    && !node->symbol.in_other_partition);\n+}\n+\n+/* Return true when function can be marked local.  */\n+\n+static bool\n+cgraph_local_node_p (struct cgraph_node *node)\n+{\n+   struct cgraph_node *n = cgraph_function_or_thunk_node (node, NULL);\n+\n+   /* FIXME: thunks can be considered local, but we need prevent i386\n+      from attempting to change calling convention of them.  */\n+   if (n->thunk.thunk_p)\n+     return false;\n+   return !cgraph_for_node_and_aliases (n,\n+\t\t\t\t\tcgraph_non_local_node_p_1, NULL, true);\n+\t\t\t\t\t\n+}\n+\n+/* Return true when NODE has ADDR reference.  */\n+\n+static bool\n+has_addr_references_p (struct cgraph_node *node,\n+\t\t       void *data ATTRIBUTE_UNUSED)\n+{\n+  int i;\n+  struct ipa_ref *ref;\n+\n+  for (i = 0; ipa_ref_list_referring_iterate (&node->symbol.ref_list,\n+\t\t\t\t\t      i, ref); i++)\n+    if (ref->use == IPA_REF_ADDR)\n+      return true;\n+  return false;\n+}\n+\n /* Look for all functions inlined to NODE and update their inlined_to pointers\n    to INLINED_TO.  */\n \n@@ -89,79 +136,23 @@ process_references (struct ipa_ref_list *list,\n   struct ipa_ref *ref;\n   for (i = 0; ipa_ref_list_reference_iterate (list, i, ref); i++)\n     {\n-      if (is_a <cgraph_node> (ref->referred))\n-\t{\n-\t  struct cgraph_node *node = ipa_ref_node (ref);\n-\n-\t  if (node->analyzed\n-\t      && (!DECL_EXTERNAL (node->symbol.decl)\n-\t\t  || node->alias\n-\t          || before_inlining_p))\n-\t    pointer_set_insert (reachable, node);\n-\t  enqueue_node ((symtab_node) node, first, reachable);\n-\t}\n-      else\n-\t{\n-\t  struct varpool_node *node = ipa_ref_varpool_node (ref);\n-\n-\t  if (node->analyzed\n-\t      && (!DECL_EXTERNAL (node->symbol.decl)\n-\t\t  || node->alias\n-\t\t  || before_inlining_p))\n-\t    pointer_set_insert (reachable, node);\n-\t  enqueue_node ((symtab_node) node, first, reachable);\n-\t}\n+      symtab_node node = ref->referred;\n+\n+      if (node->symbol.definition\n+\t  && (!DECL_EXTERNAL (node->symbol.decl)\n+\t      || node->symbol.alias\n+\t      || (before_inlining_p\n+\t\t  /* We use variable constructors during late complation for\n+\t\t     constant folding.  Keep references alive so partitioning\n+\t\t     knows about potential references.  */\n+\t\t  || (TREE_CODE (node->symbol.decl) == VAR_DECL\n+\t\t      && flag_wpa && const_value_known_p (node->symbol.decl)))))\n+\tpointer_set_insert (reachable, node);\n+      enqueue_node ((symtab_node) node, first, reachable);\n     }\n }\n \n \n-/* Return true when NODE can not be local. Worker for cgraph_local_node_p.  */\n-\n-static bool\n-cgraph_non_local_node_p_1 (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n-{\n-   /* FIXME: Aliases can be local, but i386 gets thunks wrong then.  */\n-   return !(cgraph_only_called_directly_or_aliased_p (node)\n-\t    && !ipa_ref_has_aliases_p (&node->symbol.ref_list)\n-\t    && node->analyzed\n-\t    && !DECL_EXTERNAL (node->symbol.decl)\n-\t    && !node->symbol.externally_visible\n-\t    && !node->symbol.used_from_other_partition\n-\t    && !node->symbol.in_other_partition);\n-}\n-\n-/* Return true when function can be marked local.  */\n-\n-static bool\n-cgraph_local_node_p (struct cgraph_node *node)\n-{\n-   struct cgraph_node *n = cgraph_function_or_thunk_node (node, NULL);\n-\n-   /* FIXME: thunks can be considered local, but we need prevent i386\n-      from attempting to change calling convention of them.  */\n-   if (n->thunk.thunk_p)\n-     return false;\n-   return !cgraph_for_node_and_aliases (n,\n-\t\t\t\t\tcgraph_non_local_node_p_1, NULL, true);\n-\t\t\t\t\t\n-}\n-\n-/* Return true when NODE has ADDR reference.  */\n-\n-static bool\n-has_addr_references_p (struct cgraph_node *node,\n-\t\t       void *data ATTRIBUTE_UNUSED)\n-{\n-  int i;\n-  struct ipa_ref *ref;\n-\n-  for (i = 0; ipa_ref_list_referring_iterate (&node->symbol.ref_list,\n-\t\t\t\t\t     i, ref); i++)\n-    if (ref->use == IPA_REF_ADDR)\n-      return true;\n-  return false;\n-}\n-\n /* Perform reachability analysis and reclaim all unreachable nodes.\n \n    The algorithm is basically mark&sweep but with some extra refinements:\n@@ -303,18 +294,18 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t      struct cgraph_edge *e;\n \t      for (e = cnode->callees; e; e = e->next_callee)\n \t\t{\n-\t\t  if (e->callee->analyzed\n+\t\t  if (e->callee->symbol.definition\n \t\t      && (!e->inline_failed\n \t\t\t  || !DECL_EXTERNAL (e->callee->symbol.decl)\n-\t\t\t  || cnode->alias\n+\t\t\t  || cnode->symbol.alias\n \t\t\t  || before_inlining_p))\n \t\t    pointer_set_insert (reachable, e->callee);\n \t\t  enqueue_node ((symtab_node) e->callee, &first, reachable);\n \t\t}\n \n \t      /* When inline clone exists, mark body to be preserved so when removing\n \t\t offline copy of the function we don't kill it.  */\n-\t      if (!cnode->alias && cnode->global.inlined_to)\n+\t      if (!cnode->symbol.alias && cnode->global.inlined_to)\n \t        pointer_set_insert (body_needed_for_clonning, cnode->symbol.decl);\n \t    }\n \n@@ -339,7 +330,7 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n       varpool_node *vnode = dyn_cast <varpool_node> (node);\n       if (vnode\n \t  && DECL_EXTERNAL (node->symbol.decl)\n-\t  && !vnode->alias\n+\t  && !vnode->symbol.alias\n \t  && in_boundary_p)\n \t{\n \t  struct ipa_ref *ref;\n@@ -352,27 +343,27 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n   for (node = cgraph_first_function (); node; node = next)\n     {\n       next = cgraph_next_function (node);\n+\n+      /* If node is not needed at all, remove it.  */\n       if (!node->symbol.aux)\n \t{\n \t  if (file)\n \t    fprintf (file, \" %s\", cgraph_node_name (node));\n \t  cgraph_remove_node (node);\n \t  changed = true;\n \t}\n+      /* If node is unreachable, remove its body.  */\n       else if (!pointer_set_contains (reachable, node))\n         {\n-\t  if (node->analyzed)\n+\t  if (!pointer_set_contains (body_needed_for_clonning, node->symbol.decl))\n+\t    cgraph_release_function_body (node);\n+\t  if (node->symbol.definition)\n \t    {\n \t      if (file)\n \t\tfprintf (file, \" %s\", cgraph_node_name (node));\n-\t      cgraph_node_remove_callees (node);\n-\t      ipa_remove_all_references (&node->symbol.ref_list);\n+\t      cgraph_reset_node (node);\n \t      changed = true;\n \t    }\n-\t  if (!pointer_set_contains (body_needed_for_clonning, node->symbol.decl)\n-\t      && (node->local.finalized || !DECL_ARTIFICIAL (node->symbol.decl)))\n-\t    cgraph_release_function_body (node);\n-\t  node->analyzed = false;\n \t}\n     }\n \n@@ -406,14 +397,20 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t}\n       else if (!pointer_set_contains (reachable, vnode))\n         {\n-\t  if (vnode->analyzed)\n+\t  if (vnode->symbol.definition)\n \t    {\n \t      if (file)\n \t\tfprintf (file, \" %s\", varpool_node_name (vnode));\n \t      changed = true;\n \t    }\n-\t  vnode->analyzed = false;\n+\t  vnode->symbol.definition = false;\n+\t  vnode->symbol.analyzed = false;\n \t  vnode->symbol.aux = NULL;\n+\n+\t  /* Keep body if it may be useful for constant folding.  */\n+\t  if (!const_value_known_p (vnode->symbol.decl))\n+\t    varpool_remove_initializer (vnode);\n+\t  ipa_remove_all_references (&vnode->symbol.ref_list);\n \t}\n       else\n \tvnode->symbol.aux = NULL;\n@@ -474,7 +471,7 @@ ipa_discover_readonly_nonaddressable_vars (void)\n   if (dump_file)\n     fprintf (dump_file, \"Clearing variable flags:\");\n   FOR_EACH_VARIABLE (vnode)\n-    if (vnode->finalized && varpool_all_refs_explicit_p (vnode)\n+    if (vnode->symbol.definition && varpool_all_refs_explicit_p (vnode)\n \t&& (TREE_ADDRESSABLE (vnode->symbol.decl)\n \t    || !TREE_READONLY (vnode->symbol.decl)))\n       {\n@@ -546,12 +543,12 @@ cgraph_address_taken_from_non_vtable_p (struct cgraph_node *node)\n    Virtual functions do have their addresses taken from the vtables,\n    but in C++ there is no way to compare their addresses for equality.  */\n \n-bool\n+static bool\n cgraph_comdat_can_be_unshared_p (struct cgraph_node *node)\n {\n   if ((cgraph_address_taken_from_non_vtable_p (node)\n        && !DECL_VIRTUAL_P (node->symbol.decl))\n-      || !node->analyzed)\n+      || !node->symbol.definition)\n     return false;\n   if (node->symbol.same_comdat_group)\n     {\n@@ -575,7 +572,7 @@ static bool\n cgraph_externally_visible_p (struct cgraph_node *node,\n \t\t\t     bool whole_program)\n {\n-  if (!node->local.finalized)\n+  if (!node->symbol.definition)\n     return false;\n   if (!DECL_COMDAT (node->symbol.decl)\n       && (!TREE_PUBLIC (node->symbol.decl)\n@@ -619,7 +616,7 @@ cgraph_externally_visible_p (struct cgraph_node *node,\n \t  || DECL_VISIBILITY (node->symbol.decl) == VISIBILITY_INTERNAL)\n       /* Be sure that node is defined in IR file, not in other object\n \t file.  In that case we don't set used_from_other_object_file.  */\n-      && node->analyzed)\n+      && node->symbol.definition)\n     ;\n   else if (!whole_program)\n     return true;\n@@ -638,7 +635,7 @@ varpool_externally_visible_p (struct varpool_node *vnode)\n   /* Do not touch weakrefs; while they are not externally visible,\n      dropping their DECL_EXTERNAL flags confuse most\n      of code handling them.  */\n-  if (vnode->alias && DECL_EXTERNAL (vnode->symbol.decl))\n+  if (vnode->symbol.alias && DECL_EXTERNAL (vnode->symbol.decl))\n     return true;\n \n   if (DECL_EXTERNAL (vnode->symbol.decl))\n@@ -690,7 +687,7 @@ varpool_externally_visible_p (struct varpool_node *vnode)\n \t  || DECL_VISIBILITY (vnode->symbol.decl) == VISIBILITY_INTERNAL)\n       /* Be sure that node is defined in IR file, not in other object\n \t file.  In that case we don't set used_from_other_object_file.  */\n-      && vnode->finalized)\n+      && vnode->symbol.definition)\n     ;\n   else if (!flag_whole_program)\n     return true;\n@@ -744,7 +741,7 @@ function_and_variable_visibility (bool whole_program)\n \t We may end up marking as node external nodes where this flag is meaningless\n \t strip it.  */\n       if (node->symbol.force_output\n-\t  && (DECL_EXTERNAL (node->symbol.decl) || !node->analyzed))\n+\t  && (DECL_EXTERNAL (node->symbol.decl) || !node->symbol.definition))\n \tnode->symbol.force_output = 0;\n \n       /* C++ FE on lack of COMDAT support create local COMDAT functions\n@@ -781,7 +778,7 @@ function_and_variable_visibility (bool whole_program)\n \t}\n       else\n \tnode->symbol.externally_visible = false;\n-      if (!node->symbol.externally_visible && node->analyzed\n+      if (!node->symbol.externally_visible && node->symbol.definition\n \t  && !DECL_EXTERNAL (node->symbol.decl))\n \t{\n \t  gcc_assert (whole_program || in_lto_p\n@@ -854,7 +851,7 @@ function_and_variable_visibility (bool whole_program)\n     }\n   FOR_EACH_DEFINED_VARIABLE (vnode)\n     {\n-      if (!vnode->finalized)\n+      if (!vnode->symbol.definition)\n         continue;\n       if (varpool_externally_visible_p (vnode))\n \tvnode->symbol.externally_visible = true;"}, {"sha": "82cc49f2e4219b04a72e45082d94862f94b14689", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70670cf4db3759336199993451af2739723de87/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70670cf4db3759336199993451af2739723de87/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=e70670cf4db3759336199993451af2739723de87", "patch": "@@ -1,3 +1,7 @@\n+2013-05-29  Jan Hubicka  <jh@suse.cz>\n+\n+\t* decl.c (java_mark_decl_local): Update for new symtab flags.\n+\n 2013-05-22  Matthias Klose  <doko@ubuntu.com>\n \n \t* jvspec.c (jvgenmain_spec): Add %I to cc1 call."}, {"sha": "c5a654d1c61e0b3a6644460cd1397e18dadf3fde", "filename": "gcc/java/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70670cf4db3759336199993451af2739723de87/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70670cf4db3759336199993451af2739723de87/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=e70670cf4db3759336199993451af2739723de87", "patch": "@@ -1904,7 +1904,7 @@ java_mark_decl_local (tree decl)\n   if (TREE_CODE (decl) == FUNCTION_DECL)\n     {\n       struct cgraph_node *node = cgraph_get_node (decl);\n-      gcc_assert (!node || !node->local.finalized);\n+      gcc_assert (!node || !node->symbol.definition);\n     }\n #endif\n   gcc_assert (!DECL_RTL_SET_P (decl));"}, {"sha": "2268f240804c7e734fe02fe22d97d669c5d83a62", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70670cf4db3759336199993451af2739723de87/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70670cf4db3759336199993451af2739723de87/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=e70670cf4db3759336199993451af2739723de87", "patch": "@@ -320,7 +320,7 @@ bool\n reachable_from_other_partition_p (struct cgraph_node *node, lto_symtab_encoder_t encoder)\n {\n   struct cgraph_edge *e;\n-  if (!node->analyzed)\n+  if (!node->symbol.definition)\n     return false;\n   if (node->global.inlined_to)\n     return false;\n@@ -380,7 +380,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n \n   boundary_p = !lto_symtab_encoder_in_partition_p (encoder, (symtab_node)node);\n \n-  if (node->analyzed && !boundary_p)\n+  if (node->symbol.analyzed && !boundary_p)\n     tag = LTO_symtab_analyzed_node;\n   else\n     tag = LTO_symtab_unavail_node;\n@@ -399,7 +399,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n      Cherry-picked nodes:  These are nodes we pulled from other\n      translation units into SET during IPA-inlining.  We make them as\n      local static nodes to prevent clashes with other local statics.  */\n-  if (boundary_p && node->analyzed && !DECL_EXTERNAL (node->symbol.decl))\n+  if (boundary_p && node->symbol.analyzed && !DECL_EXTERNAL (node->symbol.decl))\n     {\n       /* Inline clones can not be part of boundary.  \n          gcc_assert (!node->global.inlined_to);  \n@@ -463,7 +463,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   bp = bitpack_create (ob->main_stream);\n   bp_pack_value (&bp, node->local.local, 1);\n   bp_pack_value (&bp, node->symbol.externally_visible, 1);\n-  bp_pack_value (&bp, node->local.finalized, 1);\n+  bp_pack_value (&bp, node->symbol.definition, 1);\n   bp_pack_value (&bp, node->local.versionable, 1);\n   bp_pack_value (&bp, node->local.can_change_signature, 1);\n   bp_pack_value (&bp, node->local.redefined_extern_inline, 1);\n@@ -485,7 +485,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n      defined in other unit, we may use the info on aliases to resolve \n      symbol1 != symbol2 type tests that we can do only for locally defined objects\n      otherwise.  */\n-  bp_pack_value (&bp, node->alias && (!boundary_p || DECL_EXTERNAL (node->symbol.decl)), 1);\n+  bp_pack_value (&bp, node->symbol.alias && (!boundary_p || DECL_EXTERNAL (node->symbol.decl)), 1);\n   bp_pack_value (&bp, node->frequency, 2);\n   bp_pack_value (&bp, node->only_called_at_startup, 1);\n   bp_pack_value (&bp, node->only_called_at_exit, 1);\n@@ -504,8 +504,8 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n       streamer_write_uhwi_stream (ob->main_stream, node->thunk.fixed_offset);\n       streamer_write_uhwi_stream (ob->main_stream, node->thunk.virtual_value);\n     }\n-  if ((node->alias || node->thunk.thunk_p)\n-      && (!boundary_p || (node->alias && DECL_EXTERNAL (node->symbol.decl))))\n+  if ((node->symbol.alias || node->thunk.thunk_p)\n+      && (!boundary_p || (node->symbol.alias && DECL_EXTERNAL (node->symbol.decl))))\n     {\n       streamer_write_hwi_in_range (ob->main_stream, 0, 1,\n \t\t\t\t\tnode->thunk.alias != NULL);\n@@ -522,7 +522,7 @@ static void\n lto_output_varpool_node (struct lto_simple_output_block *ob, struct varpool_node *node,\n \t\t\t lto_symtab_encoder_t encoder)\n {\n-  bool boundary_p = (node->analyzed\n+  bool boundary_p = (node->symbol.definition\n \t\t     && !lto_symtab_encoder_in_partition_p (encoder, (symtab_node)node));\n   struct bitpack_d bp;\n   int ref;\n@@ -535,10 +535,10 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, struct varpool_node\n   bp_pack_value (&bp, node->symbol.externally_visible, 1);\n   bp_pack_value (&bp, node->symbol.force_output, 1);\n   bp_pack_value (&bp, node->symbol.unique_name, 1);\n-  bp_pack_value (&bp, node->finalized, 1);\n-  bp_pack_value (&bp, node->alias, 1);\n+  bp_pack_value (&bp, node->symbol.definition, 1);\n+  bp_pack_value (&bp, node->symbol.alias, 1);\n   bp_pack_value (&bp, node->alias_of != NULL, 1);\n-  gcc_assert (node->finalized || !node->analyzed);\n+  gcc_assert (node->symbol.definition || !node->symbol.analyzed);\n   /* Constant pool initializers can be de-unified into individual ltrans units.\n      FIXME: Alternatively at -Os we may want to avoid generating for them the local\n      labels and share them across LTRANS partitions.  */\n@@ -551,7 +551,7 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, struct varpool_node\n     }\n   else\n     {\n-      bp_pack_value (&bp, node->analyzed\n+      bp_pack_value (&bp, node->symbol.definition\n \t\t     && referenced_from_other_partition_p (&node->symbol.ref_list,\n \t\t\t\t\t\t\t   encoder), 1);\n       bp_pack_value (&bp, boundary_p && !DECL_EXTERNAL (node->symbol.decl), 1);\n@@ -756,7 +756,7 @@ compute_ltrans_boundary (lto_symtab_encoder_t in_encoder)\n        !lsei_end_p (lsei); lsei_next_variable_in_partition (&lsei))\n     {\n       struct varpool_node *vnode = lsei_varpool_node (lsei);\n-      gcc_assert (!vnode->alias || vnode->alias_of);\n+      gcc_assert (!vnode->symbol.alias || vnode->alias_of);\n       lto_set_symtab_encoder_in_partition (encoder, (symtab_node)vnode);\n       lto_set_symtab_encoder_encode_initializer (encoder, vnode);\n       add_references (encoder, &vnode->symbol.ref_list);\n@@ -883,7 +883,7 @@ input_overwrite_node (struct lto_file_decl_data *file_data,\n \n   node->local.local = bp_unpack_value (bp, 1);\n   node->symbol.externally_visible = bp_unpack_value (bp, 1);\n-  node->local.finalized = bp_unpack_value (bp, 1);\n+  node->symbol.definition = bp_unpack_value (bp, 1);\n   node->local.versionable = bp_unpack_value (bp, 1);\n   node->local.can_change_signature = bp_unpack_value (bp, 1);\n   node->local.redefined_extern_inline = bp_unpack_value (bp, 1);\n@@ -893,7 +893,7 @@ input_overwrite_node (struct lto_file_decl_data *file_data,\n   node->abstract_and_needed = bp_unpack_value (bp, 1);\n   node->symbol.used_from_other_partition = bp_unpack_value (bp, 1);\n   node->lowered = bp_unpack_value (bp, 1);\n-  node->analyzed = tag == LTO_symtab_analyzed_node;\n+  node->symbol.analyzed = tag == LTO_symtab_analyzed_node;\n   node->symbol.in_other_partition = bp_unpack_value (bp, 1);\n   if (node->symbol.in_other_partition\n       /* Avoid updating decl when we are seeing just inline clone.\n@@ -909,7 +909,7 @@ input_overwrite_node (struct lto_file_decl_data *file_data,\n       DECL_EXTERNAL (node->symbol.decl) = 1;\n       TREE_STATIC (node->symbol.decl) = 0;\n     }\n-  node->alias = bp_unpack_value (bp, 1);\n+  node->symbol.alias = bp_unpack_value (bp, 1);\n   node->frequency = (enum node_frequency)bp_unpack_value (bp, 2);\n   node->only_called_at_startup = bp_unpack_value (bp, 1);\n   node->only_called_at_exit = bp_unpack_value (bp, 1);\n@@ -1004,7 +1004,7 @@ input_node (struct lto_file_decl_data *file_data,\n       node->thunk.virtual_value = virtual_value;\n       node->thunk.virtual_offset_p = (type & 4);\n     }\n-  if (node->thunk.thunk_p || node->alias)\n+  if (node->thunk.thunk_p || node->symbol.alias)\n     {\n       if (streamer_read_hwi_in_range (ib, \"alias nonzero flag\", 0, 1))\n \t{\n@@ -1044,12 +1044,12 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n   node->symbol.externally_visible = bp_unpack_value (&bp, 1);\n   node->symbol.force_output = bp_unpack_value (&bp, 1);\n   node->symbol.unique_name = bp_unpack_value (&bp, 1);\n-  node->finalized = bp_unpack_value (&bp, 1);\n-  node->alias = bp_unpack_value (&bp, 1);\n+  node->symbol.definition = bp_unpack_value (&bp, 1);\n+  node->symbol.alias = bp_unpack_value (&bp, 1);\n   non_null_aliasof = bp_unpack_value (&bp, 1);\n   node->symbol.used_from_other_partition = bp_unpack_value (&bp, 1);\n   node->symbol.in_other_partition = bp_unpack_value (&bp, 1);\n-  node->analyzed = (node->finalized && (!node->alias || !node->symbol.in_other_partition)); \n+  node->symbol.analyzed = (node->symbol.definition && (!node->symbol.alias || !node->symbol.in_other_partition)); \n   if (node->symbol.in_other_partition)\n     {\n       DECL_EXTERNAL (node->symbol.decl) = 1;"}, {"sha": "5e1a332952cc0c3756977d8b3c54e22abdf57a27", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70670cf4db3759336199993451af2739723de87/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70670cf4db3759336199993451af2739723de87/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=e70670cf4db3759336199993451af2739723de87", "patch": "@@ -1013,7 +1013,7 @@ lto_output (void)\n       cgraph_node *node = dyn_cast <cgraph_node> (snode);\n       if (node\n \t  && lto_symtab_encoder_encode_body_p (encoder, node)\n-\t  && !node->alias\n+\t  && !node->symbol.alias\n \t  && !node->thunk.thunk_p)\n \t{\n #ifdef ENABLE_CHECKING\n@@ -1243,10 +1243,10 @@ write_symbol (struct streamer_tree_cache_d *cache,\n \n       /* When something is defined, it should have node attached.  */\n       gcc_assert (alias || TREE_CODE (t) != VAR_DECL\n-\t\t  || varpool_get_node (t)->finalized);\n+\t\t  || varpool_get_node (t)->symbol.definition);\n       gcc_assert (alias || TREE_CODE (t) != FUNCTION_DECL\n \t\t  || (cgraph_get_node (t)\n-\t\t      && cgraph_get_node (t)->analyzed));\n+\t\t      && cgraph_get_node (t)->symbol.definition));\n     }\n \n   /* Imitate what default_elf_asm_output_external do."}, {"sha": "6c433f427315dfdd677a46f4781cbef6b908c431", "filename": "gcc/lto-symtab.c", "status": "modified", "additions": 17, "deletions": 24, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70670cf4db3759336199993451af2739723de87/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70670cf4db3759336199993451af2739723de87/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=e70670cf4db3759336199993451af2739723de87", "patch": "@@ -91,8 +91,8 @@ static void\n lto_varpool_replace_node (struct varpool_node *vnode,\n \t\t\t  struct varpool_node *prevailing_node)\n {\n-  gcc_assert (!vnode->finalized || prevailing_node->finalized);\n-  gcc_assert (!vnode->analyzed || prevailing_node->analyzed);\n+  gcc_assert (!vnode->symbol.definition || prevailing_node->symbol.definition);\n+  gcc_assert (!vnode->symbol.analyzed || prevailing_node->symbol.analyzed);\n \n   ipa_clone_referring ((symtab_node)prevailing_node, &vnode->symbol.ref_list);\n \n@@ -255,14 +255,7 @@ lto_symtab_resolve_can_prevail_p (symtab_node e)\n   if (DECL_EXTERNAL (e->symbol.decl))\n     return false;\n \n-  /* For functions we need a non-discarded body.  */\n-  if (TREE_CODE (e->symbol.decl) == FUNCTION_DECL)\n-    return (cgraph (e)->analyzed);\n-\n-  else if (TREE_CODE (e->symbol.decl) == VAR_DECL)\n-    return varpool (e)->finalized;\n-\n-  gcc_unreachable ();\n+  return e->symbol.definition;\n }\n \n /* Resolve the symbol with the candidates in the chain *SLOT and store\n@@ -594,67 +587,67 @@ lto_symtab_merge_cgraph_nodes (void)\n   FOR_EACH_FUNCTION (cnode)\n     {\n       /* Resolve weakrefs to symbol defined in other unit.  */\n-      if (!cnode->analyzed && cnode->thunk.alias && !DECL_P (cnode->thunk.alias))\n+      if (!cnode->symbol.analyzed && cnode->thunk.alias && !DECL_P (cnode->thunk.alias))\n \t{\n \t  symtab_node node = symtab_node_for_asm (cnode->thunk.alias);\n \t  if (node && is_a <cgraph_node> (node))\n \t    {\n \t      struct cgraph_node *n;\n \n-\t      for (n = cgraph (node); n && n->alias;\n-\t\t   n = n->analyzed ? cgraph_alias_aliased_node (n) : NULL)\n+\t      for (n = cgraph (node); n && n->symbol.alias;\n+\t\t   n = n->symbol.analyzed ? cgraph_alias_target (n) : NULL)\n \t\tif (n == cnode)\n \t\t  {\n \t\t    error (\"function %q+D part of alias cycle\", cnode->symbol.decl);\n-\t\t    cnode->alias = false;\n+\t\t    cnode->symbol.alias = false;\n \t\t    break;\n \t\t  }\n-\t      if (cnode->alias)\n+\t      if (cnode->symbol.alias)\n \t\t{\n \t\t  cgraph_create_function_alias (cnode->symbol.decl, node->symbol.decl);\n \t\t  ipa_record_reference ((symtab_node)cnode, (symtab_node)node,\n \t\t\t\t\tIPA_REF_ALIAS, NULL);\n-\t\t  cnode->analyzed = true;\n+\t\t  cnode->symbol.analyzed = true;\n \t\t}\n \t    }\n \t  else if (node)\n \t    error (\"%q+D alias in between function and variable is not supported\", cnode->symbol.decl);\n \t}\n-      if ((cnode->thunk.thunk_p || cnode->alias)\n+      if ((cnode->thunk.thunk_p || cnode->symbol.alias)\n \t  && cnode->thunk.alias && DECL_P (cnode->thunk.alias))\n         cnode->thunk.alias = lto_symtab_prevailing_decl (cnode->thunk.alias);\n       cnode->symbol.aux = NULL;\n     }\n   FOR_EACH_VARIABLE (vnode)\n     {\n       /* Resolve weakrefs to symbol defined in other unit.  */\n-      if (!vnode->analyzed && vnode->alias_of && !DECL_P (vnode->alias_of))\n+      if (!vnode->symbol.analyzed && vnode->alias_of && !DECL_P (vnode->alias_of))\n \t{\n \t  symtab_node node = symtab_node_for_asm (vnode->alias_of);\n \t  if (node && is_a <cgraph_node> (node))\n \t    {\n \t      struct varpool_node *n;\n \n-\t      for (n = varpool (node); n && n->alias;\n-\t\t   n = n->analyzed ? varpool_alias_aliased_node (n) : NULL)\n+\t      for (n = varpool (node); n && n->symbol.alias;\n+\t\t   n = n->symbol.analyzed ? varpool_alias_target (n) : NULL)\n \t\tif (n == vnode)\n \t\t  {\n \t\t    error (\"function %q+D part of alias cycle\", vnode->symbol.decl);\n-\t\t    vnode->alias = false;\n+\t\t    vnode->symbol.alias = false;\n \t\t    break;\n \t\t  }\n-\t      if (vnode->alias)\n+\t      if (vnode->symbol.alias)\n \t\t{\n \t\t  varpool_create_variable_alias (vnode->symbol.decl, node->symbol.decl);\n \t\t  ipa_record_reference ((symtab_node)vnode, (symtab_node)node,\n \t\t\t\t\tIPA_REF_ALIAS, NULL);\n-\t\t  vnode->analyzed = true;\n+\t\t  vnode->symbol.analyzed = true;\n \t\t}\n \t    }\n \t  else if (node)\n \t    error (\"%q+D alias in between function and variable is not supported\", vnode->symbol.decl);\n \t}\n-      if (vnode->alias_of)\n+      if (vnode->symbol.alias && DECL_P (vnode->alias_of))\n         vnode->alias_of = lto_symtab_prevailing_decl (vnode->alias_of);\n       vnode->symbol.aux = NULL;\n     }"}, {"sha": "ded10566313c6318ae558fa064e683dc0b68b998", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70670cf4db3759336199993451af2739723de87/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70670cf4db3759336199993451af2739723de87/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=e70670cf4db3759336199993451af2739723de87", "patch": "@@ -1,3 +1,9 @@\n+2013-05-29  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto.c (has_analyzed_clone_p, lto_materialize_function): Update for new symtab\n+\tflags.\n+\t* lto-partition.c (get_symbol_class, lto_balanced_map): Likewise.\n+\n 2013-05-15  Jan Hubicka  <jh@suse.cz>\n \n \t* lto-partition.c (privatize_symbol_name): Return true when"}, {"sha": "921b4e26e311f4acf189d7d43f87fb9c7a8f882f", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70670cf4db3759336199993451af2739723de87/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70670cf4db3759336199993451af2739723de87/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=e70670cf4db3759336199993451af2739723de87", "patch": "@@ -74,13 +74,13 @@ get_symbol_class (symtab_node node)\n          objects that can not be duplicated across partitions.  */\n       if (DECL_IN_CONSTANT_POOL (node->symbol.decl))\n \treturn SYMBOL_DUPLICATE;\n-      gcc_checking_assert (vnode->analyzed);\n+      gcc_checking_assert (vnode->symbol.definition);\n     }\n   /* Functions that are cloned may stay in callgraph even if they are unused.\n      Handle them as external; compute_ltrans_boundary take care to make\n      proper things to happen (i.e. to make them appear in the boundary but\n      with body streamed, so clone can me materialized).  */\n-  else if (!cgraph (node)->analyzed)\n+  else if (!cgraph (node)->symbol.definition)\n     return SYMBOL_EXTERNAL;\n \n   /* Comdats are duplicated to every use unless they are keyed.\n@@ -561,12 +561,12 @@ lto_balanced_map (void)\n \n \t      last_visited_node++;\n \n-\t      gcc_assert (node->analyzed\n+\t      gcc_assert (node->symbol.definition\n \t\t\t  || lookup_attribute (\"weakref\", DECL_ATTRIBUTES (node->symbol.decl)));\n \n \t      /* Compute boundary cost of callgraph edges.  */\n \t      for (edge = node->callees; edge; edge = edge->next_callee)\n-\t\tif (edge->callee->analyzed)\n+\t\tif (edge->callee->symbol.definition)\n \t\t  {\n \t\t    int edge_cost = edge->frequency;\n \t\t    int index;\n@@ -587,7 +587,7 @@ lto_balanced_map (void)\n \t\t  int edge_cost = edge->frequency;\n \t\t  int index;\n \n-\t\t  gcc_assert (edge->caller->analyzed);\n+\t\t  gcc_assert (edge->caller->symbol.definition);\n \t\t  if (!edge_cost)\n \t\t    edge_cost = 1;\n \t\t  gcc_assert (edge_cost > 0);\n@@ -614,7 +614,7 @@ lto_balanced_map (void)\n \t\tint index;\n \n \t\tvnode = ipa_ref_varpool_node (ref);\n-\t\tif (!vnode->finalized)\n+\t\tif (!vnode->symbol.definition)\n \t\t  continue;\n \t\tif (!symbol_partitioned_p ((symtab_node) vnode) && flag_toplevel_reorder\n \t\t    && get_symbol_class ((symtab_node) vnode) == SYMBOL_PARTITION)\n@@ -632,7 +632,7 @@ lto_balanced_map (void)\n \t\tint index;\n \n \t\tnode = ipa_ref_node (ref);\n-\t\tif (!node->analyzed)\n+\t\tif (!node->symbol.definition)\n \t\t  continue;\n \t\tindex = lto_symtab_encoder_lookup (partition->encoder,\n \t\t\t\t\t\t   (symtab_node)node);\n@@ -648,7 +648,7 @@ lto_balanced_map (void)\n \t\tint index;\n \n \t\tvnode = ipa_ref_referring_varpool_node (ref);\n-\t\tgcc_assert (vnode->finalized);\n+\t\tgcc_assert (vnode->symbol.definition);\n \t\tif (!symbol_partitioned_p ((symtab_node) vnode) && flag_toplevel_reorder\n \t\t    && get_symbol_class ((symtab_node) vnode) == SYMBOL_PARTITION)\n \t\t  add_symbol_to_partition (partition, (symtab_node) vnode);\n@@ -665,7 +665,7 @@ lto_balanced_map (void)\n \t\tint index;\n \n \t\tnode = ipa_ref_referring_node (ref);\n-\t\tgcc_assert (node->analyzed);\n+\t\tgcc_assert (node->symbol.definition);\n \t\tindex = lto_symtab_encoder_lookup (partition->encoder,\n \t\t\t\t\t\t   (symtab_node)node);\n \t\tif (index != LCC_NOT_FOUND"}, {"sha": "f2a59d3bf743c67addb1e4b6c97764d5159c2a87", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70670cf4db3759336199993451af2739723de87/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70670cf4db3759336199993451af2739723de87/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=e70670cf4db3759336199993451af2739723de87", "patch": "@@ -166,7 +166,7 @@ has_analyzed_clone_p (struct cgraph_node *node)\n   if (node)\n     while (node != orig)\n       {\n-\tif (node->analyzed)\n+\tif (node->symbol.analyzed)\n \t  return true;\n \tif (node->clones)\n \t  node = node->clones;\n@@ -196,7 +196,8 @@ lto_materialize_function (struct cgraph_node *node)\n   decl = node->symbol.decl;\n   /* Read in functions with body (analyzed nodes)\n      and also functions that are needed to produce virtual clones.  */\n-  if (cgraph_function_with_gimple_body_p (node) || has_analyzed_clone_p (node))\n+  if ((cgraph_function_with_gimple_body_p (node) && node->symbol.analyzed)\n+      || has_analyzed_clone_p (node))\n     {\n       /* Clones don't need to be read.  */\n       if (node->clone_of)"}, {"sha": "656cf716b6c1784e1769599c820924f5ffe0891a", "filename": "gcc/passes.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70670cf4db3759336199993451af2739723de87/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70670cf4db3759336199993451af2739723de87/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=e70670cf4db3759336199993451af2739723de87", "patch": "@@ -2492,12 +2492,12 @@ ipa_write_summaries (void)\n \t  renumber_gimple_stmt_uids ();\n \t  pop_cfun ();\n \t}\n-      if (node->analyzed)\n+      if (node->symbol.definition)\n         lto_set_symtab_encoder_in_partition (encoder, (symtab_node)node);\n     }\n \n   FOR_EACH_DEFINED_VARIABLE (vnode)\n-    if ((!vnode->alias || vnode->alias_of))\n+    if ((!vnode->symbol.alias || vnode->alias_of))\n       lto_set_symtab_encoder_in_partition (encoder, (symtab_node)vnode);\n \n   ipa_write_summaries_1 (compute_ltrans_boundary (encoder));\n@@ -2564,7 +2564,7 @@ ipa_write_optimization_summaries (lto_symtab_encoder_t encoder)\n \n \t For functions newly born at WPA stage we need to initialize\n \t the uids here.  */\n-      if (node->analyzed\n+      if (node->symbol.definition\n \t  && gimple_has_body_p (node->symbol.decl))\n \t{\n \t  push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));"}, {"sha": "1a7f8262add4df90da8be7a47c7e016cfb9a569c", "filename": "gcc/symtab.c", "status": "modified", "additions": 51, "deletions": 3, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70670cf4db3759336199993451af2739723de87/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70670cf4db3759336199993451af2739723de87/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=e70670cf4db3759336199993451af2739723de87", "patch": "@@ -473,9 +473,15 @@ dump_symtab_base (FILE *f, symtab_node node)\n \t   node->symbol.order,\n \t   symtab_node_name (node));\n   dump_addr (f, \" @\", (void *)node);\n-  fprintf (f, \"\\n  Type: %s\\n\", symtab_type_names[node->symbol.type]);\n-  fprintf (f, \"  Visibility:\");\n-\n+  fprintf (f, \"\\n  Type: %s\", symtab_type_names[node->symbol.type]);\n+\n+  if (node->symbol.definition)\n+    fprintf (f, \" definition\");\n+  if (node->symbol.analyzed)\n+    fprintf (f, \" analyzed\");\n+  if (node->symbol.alias)\n+    fprintf (f, \" alias\");\n+  fprintf (f, \"\\n  Visibility:\");\n   if (node->symbol.in_other_partition)\n     fprintf (f, \" in_other_partition\");\n   if (node->symbol.used_from_other_partition)\n@@ -653,6 +659,12 @@ verify_symtab_base (symtab_node node)\n       && node->symbol.previous_sharing_asm_name->symbol.next_sharing_asm_name != node)\n     {\n       error (\"double linked list of assembler names corrupted\");\n+      error_found = true;\n+    }\n+  if (node->symbol.analyzed && !node->symbol.definition)\n+    {\n+      error (\"node is analyzed byt it is not a definition\");\n+      error_found = true;\n     }\n   if (node->symbol.same_comdat_group)\n     {\n@@ -783,4 +795,40 @@ symtab_make_decl_local (tree decl)\n \n   SYMBOL_REF_WEAK (symbol) = DECL_WEAK (decl);\n }\n+\n+/* Given NODE, walk the alias chain to return the symbol NODE is alias of.\n+   If NODE is not an alias, return NODE.\n+   When AVAILABILITY is non-NULL, get minimal availability in the chain.  */\n+\n+symtab_node\n+symtab_alias_ultimate_target (symtab_node node, enum availability *availability)\n+{\n+  if (availability)\n+    {\n+      if (is_a <cgraph_node> (node))\n+        *availability = cgraph_function_body_availability (cgraph (node));\n+      else\n+        *availability = cgraph_variable_initializer_availability (varpool (node));\n+    }\n+  while (node)\n+    {\n+      if (node->symbol.alias && node->symbol.analyzed)\n+\tnode = symtab_alias_target (node);\n+      else\n+\treturn node;\n+      if (node && availability)\n+\t{\n+\t  enum availability a;\n+\t  if (is_a <cgraph_node> (node))\n+\t    a = cgraph_function_body_availability (cgraph (node));\n+\t  else\n+\t    a = cgraph_variable_initializer_availability (varpool (node));\n+\t  if (a < *availability)\n+\t    *availability = a;\n+\t}\n+    }\n+  if (availability)\n+    *availability = AVAIL_NOT_AVAILABLE;\n+  return NULL;\n+}\n #include \"gt-symtab.h\""}, {"sha": "a2ee491309060dd9f0cd66fe69baeff4c2f232d2", "filename": "gcc/toplev.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70670cf4db3759336199993451af2739723de87/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70670cf4db3759336199993451af2739723de87/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=e70670cf4db3759336199993451af2739723de87", "patch": "@@ -393,15 +393,15 @@ wrapup_global_declaration_2 (tree decl)\n \n       if (!node && flag_ltrans)\n \tneeded = false;\n-      else if (node && node->finalized)\n+      else if (node && node->symbol.definition)\n \tneeded = false;\n-      else if (node && node->alias)\n+      else if (node && node->symbol.alias)\n \tneeded = false;\n       else if (!cgraph_global_info_ready\n \t       && (TREE_USED (decl)\n \t\t   || TREE_USED (DECL_ASSEMBLER_NAME (decl))))\n \t/* needed */;\n-      else if (node && node->analyzed)\n+      else if (node && node->symbol.analyzed)\n \t/* needed */;\n       else if (DECL_COMDAT (decl))\n \tneeded = false;"}, {"sha": "d7e5a40106f6d4f93296069651d00bfb1fd86bb8", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70670cf4db3759336199993451af2739723de87/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70670cf4db3759336199993451af2739723de87/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=e70670cf4db3759336199993451af2739723de87", "patch": "@@ -3932,7 +3932,7 @@ get_cg_data (struct cgraph_node **node, bool traverse_aliases)\n {\n   struct tm_ipa_cg_data *d;\n \n-  if (traverse_aliases && (*node)->alias)\n+  if (traverse_aliases && (*node)->symbol.alias)\n     *node = cgraph_get_node ((*node)->thunk.alias);\n \n   d = (struct tm_ipa_cg_data *) (*node)->symbol.aux;\n@@ -4518,7 +4518,7 @@ ipa_tm_mayenterirr_function (struct cgraph_node *node)\n   /* Recurse on the main body for aliases.  In general, this will\n      result in one of the bits above being set so that we will not\n      have to recurse next time.  */\n-  if (node->alias)\n+  if (node->symbol.alias)\n     return ipa_tm_mayenterirr_function (cgraph_get_node (node->thunk.alias));\n \n   /* What remains is unmarked local functions without items that force\n@@ -4678,9 +4678,7 @@ static inline void\n ipa_tm_mark_force_output_node (struct cgraph_node *node)\n {\n   cgraph_mark_force_output_node (node);\n-  /* ??? function_and_variable_visibility will reset\n-     the needed bit, without actually checking.  */\n-  node->analyzed = 1;\n+  node->symbol.analyzed = true;\n }\n \n /* Callback data for ipa_tm_create_version_alias.  */\n@@ -5250,7 +5248,7 @@ ipa_tm_execute (void)\n \t    {\n \t      /* If this is an alias, make sure its base is queued as well.\n \t\t we need not scan the callees now, as the base will do.  */\n-\t      if (node->alias)\n+\t      if (node->symbol.alias)\n \t\t{\n \t\t  node = cgraph_get_node (node->thunk.alias);\n \t\t  d = get_cg_data (&node, true);\n@@ -5393,7 +5391,7 @@ ipa_tm_execute (void)\n   for (i = 0; i < tm_callees.length (); ++i)\n     {\n       node = tm_callees[i];\n-      if (node->analyzed)\n+      if (node->symbol.analyzed)\n \t{\n \t  d = get_cg_data (&node, true);\n \t  if (d->clone)"}, {"sha": "fb80b30a44cb9cb37cd760adf0a6bf408bc91e8c", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70670cf4db3759336199993451af2739723de87/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70670cf4db3759336199993451af2739723de87/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=e70670cf4db3759336199993451af2739723de87", "patch": "@@ -2580,7 +2580,7 @@ tree_could_trap_p (tree expr)\n       /* Assume that accesses to weak functions may trap, unless we know\n \t they are certainly defined in current TU or in some other\n \t LTO partition.  */\n-      if (DECL_WEAK (expr))\n+      if (DECL_WEAK (expr) && !DECL_COMDAT (expr))\n \t{\n \t  struct cgraph_node *node;\n \t  if (!DECL_EXTERNAL (expr))\n@@ -2596,7 +2596,7 @@ tree_could_trap_p (tree expr)\n       /* Assume that accesses to weak vars may trap, unless we know\n \t they are certainly defined in current TU or in some other\n \t LTO partition.  */\n-      if (DECL_WEAK (expr))\n+      if (DECL_WEAK (expr) && !DECL_COMDAT (expr))\n \t{\n \t  struct varpool_node *node;\n \t  if (!DECL_EXTERNAL (expr))"}, {"sha": "9fecb6cb6634e84a325cf69417dc63b2cf773d33", "filename": "gcc/tree-emutls.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70670cf4db3759336199993451af2739723de87/gcc%2Ftree-emutls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70670cf4db3759336199993451af2739723de87/gcc%2Ftree-emutls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-emutls.c?ref=e70670cf4db3759336199993451af2739723de87", "patch": "@@ -704,15 +704,15 @@ create_emultls_var (struct varpool_node *var, void *data)\n   cvar = varpool_get_node (cdecl);\n   control_vars.quick_push (cvar);\n \n-  if (!var->alias)\n+  if (!var->symbol.alias)\n     {\n       /* Make sure the COMMON block control variable gets initialized.\n \t Note that there's no point in doing this for aliases; we only\n \t need to do this once for the main variable.  */\n       emutls_common_1 (var->symbol.decl, cdecl, (tree *)data);\n     }\n-  if (var->alias && !var->alias_of)\n-    cvar->alias = true;\n+  if (var->symbol.alias && !var->alias_of)\n+    cvar->symbol.alias = true;\n \n   /* Indicate that the value of the TLS variable may be found elsewhere,\n      preventing the variable from re-appearing in the GIMPLE.  We cheat\n@@ -743,7 +743,7 @@ ipa_lower_emutls (void)\n \tgcc_checking_assert (TREE_STATIC (var->symbol.decl)\n \t\t\t     || DECL_EXTERNAL (var->symbol.decl));\n \tvarpool_node_set_add (tls_vars, var);\n-\tif (var->alias && var->analyzed)\n+\tif (var->symbol.alias && var->symbol.definition)\n \t  varpool_node_set_add (tls_vars, varpool_variable_node (var, NULL));\n       }\n \n@@ -767,9 +767,9 @@ ipa_lower_emutls (void)\n     {\n       var = tls_vars->nodes[i];\n \n-      if (var->alias && !var->alias_of)\n+      if (var->symbol.alias && !var->alias_of)\n \tany_aliases = true;\n-      else if (!var->alias)\n+      else if (!var->symbol.alias)\n \tvarpool_for_node_and_aliases (var, create_emultls_var, &ctor_body, true);\n     }\n "}, {"sha": "bee77666497fd68d0ec249b92fd1678b8ee195f3", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70670cf4db3759336199993451af2739723de87/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70670cf4db3759336199993451af2739723de87/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=e70670cf4db3759336199993451af2739723de87", "patch": "@@ -1726,7 +1726,7 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t      if ((!edge\n \t\t   || (edge->indirect_inlining_edge\n \t\t       && id->transform_call_graph_edges == CB_CGE_MOVE_CLONES))\n-\t\t  && id->dst_node->analyzed\n+\t\t  && id->dst_node->symbol.definition\n \t\t  && (fn = gimple_call_fndecl (stmt)) != NULL)\n \t\t{\n \t\t  struct cgraph_node *dest = cgraph_get_node (fn);\n@@ -1737,10 +1737,10 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t\t     producing dead clone (for further cloning).  In all\n \t\t     other cases we hit a bug (incorrect node sharing is the\n \t\t     most common reason for missing edges).  */\n-\t\t  gcc_assert (!dest->analyzed\n+\t\t  gcc_assert (!dest->symbol.definition\n \t\t\t      || dest->symbol.address_taken\n-\t\t  \t      || !id->src_node->analyzed\n-\t\t\t      || !id->dst_node->analyzed);\n+\t\t  \t      || !id->src_node->symbol.definition\n+\t\t\t      || !id->dst_node->symbol.definition);\n \t\t  if (id->transform_call_graph_edges == CB_CGE_MOVE_CLONES)\n \t\t    cgraph_create_edge_including_clones\n \t\t      (id->dst_node, dest, orig_stmt, stmt, bb->count,\n@@ -3611,7 +3611,7 @@ estimate_num_insns (gimple stmt, eni_weights *weights)\n \n \t/* Do not special case builtins where we see the body.\n \t   This just confuse inliner.  */\n-\tif (!decl || !(node = cgraph_get_node (decl)) || node->analyzed)\n+\tif (!decl || !(node = cgraph_get_node (decl)) || node->symbol.definition)\n \t  ;\n \t/* For buitins that are likely expanded to nothing or\n \t   inlined do not account operand costs.  */\n@@ -4344,7 +4344,7 @@ optimize_inline_calls (tree fn)\n   memset (&id, 0, sizeof (id));\n \n   id.src_node = id.dst_node = cgraph_get_node (fn);\n-  gcc_assert (id.dst_node->analyzed);\n+  gcc_assert (id.dst_node->symbol.definition);\n   id.dst_fn = fn;\n   /* Or any functions that aren't finished yet.  */\n   if (current_function_decl)\n@@ -5238,7 +5238,7 @@ tree_function_versioning (tree old_decl, tree new_decl,\n   pointer_set_destroy (id.statements_to_fold);\n   fold_cond_expr_cond ();\n   delete_unreachable_blocks_update_callgraph (&id);\n-  if (id.dst_node->analyzed)\n+  if (id.dst_node->symbol.definition)\n     cgraph_rebuild_references ();\n   update_ssa (TODO_update_ssa);\n "}, {"sha": "1bfe2b2476fbeaa45ea6689ef0dfc37b88ae10ad", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70670cf4db3759336199993451af2739723de87/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70670cf4db3759336199993451af2739723de87/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=e70670cf4db3759336199993451af2739723de87", "patch": "@@ -2874,7 +2874,7 @@ get_constraint_for_ssa_var (tree t, vec<ce_s> *results, bool address_p)\n       && (TREE_STATIC (t) || DECL_EXTERNAL (t)))\n     {\n       struct varpool_node *node = varpool_get_node (t);\n-      if (node && node->alias)\n+      if (node && node->symbol.alias && node->symbol.analyzed)\n \t{\n \t  node = varpool_variable_node (node, NULL);\n \t  t = node->symbol.decl;\n@@ -5751,7 +5751,7 @@ create_variable_info_for (tree decl, const char *name)\n \t  /* If this is a global variable with an initializer and we are in\n \t     IPA mode generate constraints for it.  */\n \t  if (DECL_INITIAL (decl)\n-\t      && vnode->analyzed)\n+\t      && vnode->symbol.definition)\n \t    {\n \t      vec<ce_s> rhsc = vNULL;\n \t      struct constraint_expr lhs, *rhsp;\n@@ -7023,7 +7023,8 @@ struct pt_solution ipa_escaped_pt\n static bool\n associate_varinfo_to_alias (struct cgraph_node *node, void *data)\n {\n-  if (node->alias || node->thunk.thunk_p)\n+  if ((node->symbol.alias || node->thunk.thunk_p)\n+      && node->symbol.analyzed)\n     insert_vi_for_tree (node->symbol.decl, (varinfo_t)data);\n   return false;\n }\n@@ -7066,7 +7067,7 @@ ipa_pta_execute (void)\n   /* Create constraints for global variables and their initializers.  */\n   FOR_EACH_VARIABLE (var)\n     {\n-      if (var->alias)\n+      if (var->symbol.alias && var->symbol.analyzed)\n \tcontinue;\n \n       get_vi_for_tree (var->symbol.decl);"}, {"sha": "72bff5a8b9a583527773dd4b7668aeb010a56526", "filename": "gcc/varasm.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70670cf4db3759336199993451af2739723de87/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70670cf4db3759336199993451af2739723de87/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=e70670cf4db3759336199993451af2739723de87", "patch": "@@ -2256,7 +2256,7 @@ mark_decl_referenced (tree decl)\n \t definition.  */\n       struct cgraph_node *node = cgraph_get_create_node (decl);\n       if (!DECL_EXTERNAL (decl)\n-\t  && !node->local.finalized)\n+\t  && !node->symbol.definition)\n \tcgraph_mark_force_output_node (node);\n     }\n   else if (TREE_CODE (decl) == VAR_DECL)\n@@ -5595,9 +5595,9 @@ assemble_alias (tree decl, tree target)\n \n   /* Allow aliases to aliases.  */\n   if (TREE_CODE (decl) == FUNCTION_DECL)\n-    cgraph_get_create_node (decl)->alias = true;\n+    cgraph_get_create_node (decl)->symbol.alias = true;\n   else\n-    varpool_node_for_decl (decl)->alias = true;\n+    varpool_node_for_decl (decl)->symbol.alias = true;\n \n   /* If the target has already been emitted, we don't have to queue the\n      alias.  This saves a tad of memory.  */\n@@ -5700,12 +5700,12 @@ dump_tm_clone_pairs (vec<tm_alias_pair> tm_alias_pairs)\n \t TM_GETTMCLONE.  If neither of these are true, we didn't generate\n \t a clone, and we didn't call it indirectly... no sense keeping it\n \t in the clone table.  */\n-      if (!dst_n || !dst_n->analyzed)\n+      if (!dst_n || !dst_n->symbol.definition)\n \tcontinue;\n \n       /* This covers the case where we have optimized the original\n \t function away, and only access the transactional clone.  */\n-      if (!src_n || !src_n->analyzed)\n+      if (!src_n || !src_n->symbol.definition)\n \tcontinue;\n \n       if (!switched)"}, {"sha": "1916b76d96031d536ba1dc7557f63f9a096140ba", "filename": "gcc/varpool.c", "status": "modified", "additions": 34, "deletions": 26, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e70670cf4db3759336199993451af2739723de87/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e70670cf4db3759336199993451af2739723de87/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=e70670cf4db3759336199993451af2739723de87", "patch": "@@ -58,14 +58,26 @@ void\n varpool_remove_node (struct varpool_node *node)\n {\n   symtab_unregister_node ((symtab_node)node);\n+\n+  /* Because we remove references from external functions before final compilation,\n+     we may end up removing useful constructors.\n+     FIXME: We probably want to trace boundaries better.  */\n+  if (!const_value_known_p (node->symbol.decl))\n+    varpool_remove_initializer (node);\n+  ggc_free (node);\n+}\n+\n+/* Renove node initializer when it is no longer needed.  */\n+void\n+varpool_remove_initializer (struct varpool_node *node)\n+{\n   if (DECL_INITIAL (node->symbol.decl)\n       && !DECL_IN_CONSTANT_POOL (node->symbol.decl)\n       /* Keep vtables for BINFO folding.  */\n       && !DECL_VIRTUAL_P (node->symbol.decl)\n       /* FIXME: http://gcc.gnu.org/PR55395 */\n       && debug_info_level == DINFO_LEVEL_NONE)\n     DECL_INITIAL (node->symbol.decl) = error_mark_node;\n-  ggc_free (node);\n }\n \n /* Dump given cgraph node.  */\n@@ -80,10 +92,6 @@ dump_varpool_node (FILE *f, struct varpool_node *node)\n   fprintf (f, \"  Varpool flags:\");\n   if (DECL_INITIAL (node->symbol.decl))\n     fprintf (f, \" initialized\");\n-  if (node->analyzed)\n-    fprintf (f, \" analyzed\");\n-  if (node->finalized)\n-    fprintf (f, \" finalized\");\n   if (node->output)\n     fprintf (f, \" output\");\n   if (TREE_READONLY (node->symbol.decl))\n@@ -117,9 +125,9 @@ struct varpool_node *\n varpool_node_for_asm (tree asmname)\n {\n   if (symtab_node node = symtab_node_for_asm (asmname))\n-    if (varpool_node *vnode = dyn_cast <varpool_node> (node))\n-      return vnode;\n-  return NULL;\n+    return dyn_cast <varpool_node> (node);\n+  else\n+    return NULL;\n }\n \n /* Determine if variable DECL is needed.  That is, visible to something\n@@ -205,12 +213,12 @@ enum availability\n cgraph_variable_initializer_availability (struct varpool_node *node)\n {\n   gcc_assert (cgraph_function_flags_ready);\n-  if (!node->finalized)\n+  if (!node->symbol.definition)\n     return AVAIL_NOT_AVAILABLE;\n   if (!TREE_PUBLIC (node->symbol.decl))\n     return AVAIL_AVAILABLE;\n   /* If the variable can be overwritten, return OVERWRITABLE.  Takes\n-     care of at least two notable extensions - the COMDAT variables\n+     care of at least one notable extension - the COMDAT variables\n      used to share template instantiations in C++.  */\n   if (!decl_replaceable_p (node->symbol.decl))\n     return AVAIL_OVERWRITABLE;\n@@ -225,24 +233,24 @@ varpool_analyze_node (struct varpool_node *node)\n   /* When reading back varpool at LTO time, we re-construct the queue in order\n      to have \"needed\" list right by inserting all needed nodes into varpool.\n      We however don't want to re-analyze already analyzed nodes.  */\n-  if (!node->analyzed)\n+  if (!node->symbol.analyzed)\n     {\n       gcc_assert (!in_lto_p || cgraph_function_flags_ready);\n       /* Compute the alignment early so function body expanders are\n \t already informed about increased alignment.  */\n       align_variable (decl, 0);\n     }\n-  if (node->alias && node->alias_of)\n+  if (node->symbol.alias && node->alias_of)\n     {\n       struct varpool_node *tgt = varpool_node_for_decl (node->alias_of);\n       struct varpool_node *n;\n \n-      for (n = tgt; n && n->alias;\n-\t   n = n->analyzed ? varpool_alias_aliased_node (n) : NULL)\n+      for (n = tgt; n && n->symbol.alias;\n+\t   n = n->symbol.analyzed ? varpool_alias_target (n) : NULL)\n \tif (n == node)\n \t  {\n \t    error (\"variable %q+D part of alias cycle\", node->symbol.decl);\n-\t    node->alias = false;\n+\t    node->symbol.alias = false;\n \t    continue;\n \t  }\n       if (!vec_safe_length (node->symbol.ref_list.references))\n@@ -257,8 +265,8 @@ varpool_analyze_node (struct varpool_node *node)\n \t}\n     }\n   else if (DECL_INITIAL (decl))\n-    record_references_in_initializer (decl, node->analyzed);\n-  node->analyzed = true;\n+    record_references_in_initializer (decl, node->symbol.analyzed);\n+  node->symbol.analyzed = true;\n }\n \n /* Assemble thunks and aliases associated to NODE.  */\n@@ -287,7 +295,7 @@ varpool_assemble_decl (struct varpool_node *node)\n \n   /* Aliases are outout when their target is produced or by\n      output_weakrefs.  */\n-  if (node->alias)\n+  if (node->symbol.alias)\n     return false;\n \n   /* Constant pool is output from RTL land when the reference\n@@ -316,7 +324,7 @@ varpool_assemble_decl (struct varpool_node *node)\n     {\n       assemble_variable (decl, 0, 1, 0);\n       gcc_assert (TREE_ASM_WRITTEN (decl));\n-      node->finalized = 1;\n+      node->symbol.definition = true;\n       assemble_aliases (node);\n       return true;\n     }\n@@ -357,7 +365,7 @@ varpool_remove_unreferenced_decls (void)\n     fprintf (cgraph_dump_file, \"Trivially needed variables:\");\n   FOR_EACH_DEFINED_VARIABLE (node)\n     {\n-      if (node->analyzed\n+      if (node->symbol.analyzed\n \t  && (!varpool_can_remove_if_no_refs (node)\n \t      /* We just expanded all function bodies.  See if any of\n \t\t them needed the variable.  */\n@@ -381,7 +389,7 @@ varpool_remove_unreferenced_decls (void)\n \t       next = next->symbol.same_comdat_group)\n \t    {\n \t      varpool_node *vnext = dyn_cast <varpool_node> (next);\n-\t      if (vnext && vnext->analyzed)\n+\t      if (vnext && vnext->symbol.analyzed)\n \t\tenqueue_node (vnext, &first);\n \t    }\n \t}\n@@ -390,8 +398,8 @@ varpool_remove_unreferenced_decls (void)\n \t  varpool_node *vnode = dyn_cast <varpool_node> (ref->referred);\n \t  if (vnode\n \t      && (!DECL_EXTERNAL (ref->referred->symbol.decl)\n-\t\t  || vnode->alias)\n-\t      && vnode->analyzed)\n+\t\t  || vnode->symbol.alias)\n+\t      && vnode->symbol.analyzed)\n \t    enqueue_node (vnode, &first);\n \t}\n     }\n@@ -419,7 +427,7 @@ void\n varpool_finalize_named_section_flags (struct varpool_node *node)\n {\n   if (!TREE_ASM_WRITTEN (node->symbol.decl)\n-      && !node->alias\n+      && !node->symbol.alias\n       && !node->symbol.in_other_partition\n       && !DECL_EXTERNAL (node->symbol.decl)\n       && TREE_CODE (node->symbol.decl) == VAR_DECL\n@@ -484,8 +492,8 @@ varpool_create_variable_alias (tree alias, tree decl)\n   gcc_assert (TREE_CODE (decl) == VAR_DECL);\n   gcc_assert (TREE_CODE (alias) == VAR_DECL);\n   alias_node = varpool_node_for_decl (alias);\n-  alias_node->alias = 1;\n-  alias_node->finalized = 1;\n+  alias_node->symbol.alias = true;\n+  alias_node->symbol.definition = true;\n   alias_node->alias_of = decl;\n \n   /* Extra name alias mechanizm creates aliases really late"}]}