{"sha": "60fb6df968b2ed5ee054874052371f08b59cb712", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjBmYjZkZjk2OGIyZWQ1ZWUwNTQ4NzQwNTIzNzFmMDhiNTljYjcxMg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-12-08T03:22:33Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-12-08T03:22:33Z"}, "message": "loop.h (struct induction): Add multi_insn_incr.\n\n        * loop.h (struct induction): Add multi_insn_incr.\n        * loop.c (basic_induction_var): New multi_insn_incr argument.\n        Set it if we search back through previous insns for the biv.\n        (record_biv): New multi_insn_incr argument; fill in struct induction.\n        (strength_reduce): Discard an iv with multiple bivs, any of\n        which require multiple insns to increment.\n\nFrom-SVN: r30820", "tree": {"sha": "9c8c66c576241096238da778fd7a4457cc1fb503", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c8c66c576241096238da778fd7a4457cc1fb503"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/60fb6df968b2ed5ee054874052371f08b59cb712", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60fb6df968b2ed5ee054874052371f08b59cb712", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60fb6df968b2ed5ee054874052371f08b59cb712", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60fb6df968b2ed5ee054874052371f08b59cb712/comments", "author": null, "committer": null, "parents": [{"sha": "3043b30ec807350898618ba9ea7d7fe1787f866f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3043b30ec807350898618ba9ea7d7fe1787f866f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3043b30ec807350898618ba9ea7d7fe1787f866f"}], "stats": {"total": 76, "additions": 60, "deletions": 16}, "files": [{"sha": "9861e064c1ead52c80be4d7d7a05ccfc2ff053fe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60fb6df968b2ed5ee054874052371f08b59cb712/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60fb6df968b2ed5ee054874052371f08b59cb712/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=60fb6df968b2ed5ee054874052371f08b59cb712", "patch": "@@ -1,3 +1,12 @@\n+Tue Dec  7 19:22:06 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* loop.h (struct induction): Add multi_insn_incr.\n+\t* loop.c (basic_induction_var): New multi_insn_incr argument.\n+\tSet it if we search back through previous insns for the biv.\n+\t(record_biv): New multi_insn_incr argument; fill in struct induction.\n+\t(strength_reduce): Discard an iv with multiple bivs, any of\n+\twhich require multiple insns to increment.\n+\n 1999-12-07  Martin v. L\ufffdwis  <loewis@informatik.hu-berlin.de>\n \n \t* invoke.texi (C Dialect Options): Remove -flang-c9x, add -std"}, {"sha": "90e6c44f5ea827c4be01f6609745c788151858d8", "filename": "gcc/loop.c", "status": "modified", "additions": 50, "deletions": 16, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60fb6df968b2ed5ee054874052371f08b59cb712/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60fb6df968b2ed5ee054874052371f08b59cb712/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=60fb6df968b2ed5ee054874052371f08b59cb712", "patch": "@@ -310,12 +310,12 @@ static void strength_reduce PROTO((rtx, rtx, rtx, int, rtx, rtx,\n static void find_single_use_in_loop PROTO((rtx, rtx, varray_type));\n static int valid_initial_value_p PROTO((rtx, rtx, int, rtx));\n static void find_mem_givs PROTO((rtx, rtx, int, int, rtx, rtx));\n-static void record_biv PROTO((struct induction *, rtx, rtx, rtx, rtx, rtx *, int, int));\n+static void record_biv PROTO((struct induction *, rtx, rtx, rtx, rtx, rtx *, int, int, int));\n static void check_final_value PROTO((struct induction *, rtx, rtx, \n \t\t\t\t     unsigned HOST_WIDE_INT));\n static void record_giv PROTO((struct induction *, rtx, rtx, rtx, rtx, rtx, int, enum g_types, int, int, rtx *, rtx, rtx));\n static void update_giv_derive PROTO((rtx));\n-static int basic_induction_var PROTO((rtx, enum machine_mode, rtx, rtx, rtx *, rtx *, rtx **));\n+static int basic_induction_var PROTO((rtx, enum machine_mode, rtx, rtx, rtx *, rtx *, rtx **, int *));\n static rtx simplify_giv_expr PROTO((rtx, int *));\n static int general_induction_var PROTO((rtx, rtx *, rtx *, rtx *, int, int *));\n static int consec_sets_giv PROTO((int, rtx, rtx, rtx, rtx *, rtx *, rtx *));\n@@ -3837,9 +3837,11 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t      && REGNO (dest_reg) >= FIRST_PSEUDO_REGISTER\n \t      && REG_IV_TYPE (REGNO (dest_reg)) != NOT_BASIC_INDUCT)\n \t    {\n+\t      int multi_insn_incr = 0;\n+\n \t      if (basic_induction_var (SET_SRC (set), GET_MODE (SET_SRC (set)),\n \t\t\t\t       dest_reg, p, &inc_val, &mult_val,\n-\t\t\t\t       &location))\n+\t\t\t\t       &location, &multi_insn_incr))\n \t\t{\n \t\t  /* It is a possible basic induction variable.\n \t\t     Create and initialize an induction structure for it.  */\n@@ -3848,7 +3850,8 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t\t    = (struct induction *) alloca (sizeof (struct induction));\n \n \t\t  record_biv (v, p, dest_reg, inc_val, mult_val, location,\n-\t\t\t      not_every_iteration, maybe_multiple);\n+\t\t\t      not_every_iteration, maybe_multiple, \n+\t\t\t      multi_insn_incr);\n \t\t  REG_IV_TYPE (REGNO (dest_reg)) = BASIC_INDUCT;\n \t\t}\n \t      else if (REGNO (dest_reg) < max_reg_before_loop)\n@@ -3976,13 +3979,30 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n      Make a sanity check against n_times_set.  */\n   for (backbl = &loop_iv_list, bl = *backbl; bl; bl = bl->next)\n     {\n+      int fail = 0;\n+\n       if (REG_IV_TYPE (bl->regno) != BASIC_INDUCT\n \t  /* Above happens if register modified by subreg, etc.  */\n \t  /* Make sure it is not recognized as a basic induction var: */\n \t  || VARRAY_INT (n_times_set, bl->regno) != bl->biv_count\n \t  /* If never incremented, it is invariant that we decided not to\n \t     move.  So leave it alone.  */\n \t  || ! bl->incremented)\n+\tfail = 1;\n+      else if (bl->biv_count > 1)\n+\t{\n+\t  /* ??? If we have multiple increments for this BIV, and any of\n+\t     them take multiple insns to perform the increment, drop the\n+\t     BIV, since the bit below that converts the extra increments\n+\t     into GIVs can't handle the multiple insn increment.  */\n+\t  \n+\t  struct induction *v;\n+\t  for (v = bl->biv; v ; v = v->next_iv)\n+\t    if (v->multi_insn_incr)\n+\t      fail = 1;\n+\t}\n+\n+      if (fail)\n \t{\n \t  if (loop_dump_stream)\n \t    fprintf (loop_dump_stream, \"Reg %d: biv discarded, %s\\n\",\n@@ -4453,7 +4473,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \n \t      if (loop_dump_stream)\n \t\tfprintf (loop_dump_stream,\n-\t\t\t \"Increment %d of biv %d converted to giv %d.\\n\\n\",\n+\t\t\t \"Increment %d of biv %d converted to giv %d.\\n\",\n \t\t\t INSN_UID (v->insn), old_regno, new_regno);\n \t    }\n \t}\n@@ -5460,7 +5480,7 @@ find_mem_givs (x, insn, not_every_iteration, maybe_multiple, loop_start,\n \n static void\n record_biv (v, insn, dest_reg, inc_val, mult_val, location,\n-\t    not_every_iteration, maybe_multiple)\n+\t    not_every_iteration, maybe_multiple, multi_insn_incr)\n      struct induction *v;\n      rtx insn;\n      rtx dest_reg;\n@@ -5482,6 +5502,7 @@ record_biv (v, insn, dest_reg, inc_val, mult_val, location,\n   v->always_computable = ! not_every_iteration;\n   v->always_executed = ! not_every_iteration;\n   v->maybe_multiple = maybe_multiple;\n+  v->multi_insn_incr = multi_insn_incr;\n \n   /* Add this to the reg's iv_class, creating a class\n      if this is the first incrementation of the reg.  */\n@@ -5589,6 +5610,7 @@ record_giv (v, insn, src_reg, dest_reg, mult_val, add_val, benefit,\n   v->cant_derive = 0;\n   v->combined_with = 0;\n   v->maybe_multiple = maybe_multiple;\n+  v->multi_insn_incr = 0;\n   v->maybe_dead = 0;\n   v->derive_adjustment = 0;\n   v->same = 0;\n@@ -6077,14 +6099,16 @@ update_giv_derive (p)\n    If we cannot find a biv, we return 0.  */\n \n static int\n-basic_induction_var (x, mode, dest_reg, p, inc_val, mult_val, location)\n+basic_induction_var (x, mode, dest_reg, p, inc_val, mult_val, location,\n+\t\t     multi_insn_incr)\n      register rtx x;\n      enum machine_mode mode;\n      rtx p;\n      rtx dest_reg;\n      rtx *inc_val;\n      rtx *mult_val;\n      rtx **location;\n+     int *multi_insn_incr;\n {\n   register enum rtx_code code;\n   rtx *argp, arg;\n@@ -6126,7 +6150,8 @@ basic_induction_var (x, mode, dest_reg, p, inc_val, mult_val, location)\n \t value.  */\n       if (SUBREG_PROMOTED_VAR_P (x))\n \treturn basic_induction_var (SUBREG_REG (x), GET_MODE (SUBREG_REG (x)),\n-\t\t\t\t    dest_reg, p, inc_val, mult_val, location);\n+\t\t\t\t    dest_reg, p, inc_val, mult_val, location,\n+\t\t\t\t    multi_insn_incr);\n       return 0;\n \n     case REG:\n@@ -6159,8 +6184,12 @@ basic_induction_var (x, mode, dest_reg, p, inc_val, mult_val, location)\n \t\t\t\t       ? GET_MODE (x)\n \t\t\t\t       : GET_MODE (SET_SRC (set))),\n \t\t\t\t      dest_reg, insn,\n-\t\t\t\t      inc_val, mult_val, location))\n-\t    return 1;\n+\t\t\t\t      inc_val, mult_val, location,\n+\t\t\t\t      multi_insn_incr))\n+\t    {\n+\t      *multi_insn_incr = 1;\n+\t      return 1;\n+\t    }\n \t}\n       /* ... fall through ...  */\n \n@@ -6191,7 +6220,8 @@ basic_induction_var (x, mode, dest_reg, p, inc_val, mult_val, location)\n \n     case SIGN_EXTEND:\n       return basic_induction_var (XEXP (x, 0), GET_MODE (XEXP (x, 0)),\n-\t\t\t\t  dest_reg, p, inc_val, mult_val, location);\n+\t\t\t\t  dest_reg, p, inc_val, mult_val, location,\n+\t\t\t\t  multi_insn_incr);\n \n     case ASHIFTRT:\n       /* Similar, since this can be a sign extension.  */\n@@ -6208,11 +6238,15 @@ basic_induction_var (x, mode, dest_reg, p, inc_val, mult_val, location)\n \t  && GET_CODE (XEXP (x, 1)) == CONST_INT\n \t  && INTVAL (XEXP (x, 1)) >= 0\n \t  && GET_CODE (SET_SRC (set)) == ASHIFT\n-\t  && XEXP (x, 1) == XEXP (SET_SRC (set), 1))\n-\treturn basic_induction_var (XEXP (SET_SRC (set), 0),\n-\t\t\t\t    GET_MODE (XEXP (x, 0)),\n-\t\t\t\t    dest_reg, insn, inc_val, mult_val,\n-\t\t\t\t    location);\n+\t  && XEXP (x, 1) == XEXP (SET_SRC (set), 1)\n+\t  && basic_induction_var (XEXP (SET_SRC (set), 0),\n+\t\t\t\t  GET_MODE (XEXP (x, 0)),\n+\t\t\t\t  dest_reg, insn, inc_val, mult_val,\n+\t\t\t\t  location, multi_insn_incr))\n+\t{\n+\t  *multi_insn_incr = 1;\n+\t  return 1;\n+\t}\n       return 0;\n \n     default:"}, {"sha": "14735810fd52e4e1fff5a7defbcc00dc5a6893ae", "filename": "gcc/loop.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60fb6df968b2ed5ee054874052371f08b59cb712/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60fb6df968b2ed5ee054874052371f08b59cb712/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=60fb6df968b2ed5ee054874052371f08b59cb712", "patch": "@@ -101,6 +101,7 @@ struct induction\n \t\t\t\t   initialized in unrolled loop.  */\n   unsigned shared : 1;\n   unsigned no_const_addval : 1; /* 1 if add_val does not contain a const. */\n+  unsigned multi_insn_incr : 1;\t/* 1 if multiple insns updated the biv.  */\n   int lifetime;\t\t\t/* Length of life of this giv */\n   rtx derive_adjustment;\t/* If nonzero, is an adjustment to be\n \t\t\t\t   subtracted from add_val when this giv"}]}