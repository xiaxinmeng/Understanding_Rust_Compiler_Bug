{"sha": "5c35539b1ab41da8800ebb1fdc983237a7d9cdd7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWMzNTUzOWIxYWI0MWRhODgwMGViYjFmZGM5ODMyMzdhN2Q5Y2RkNw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1998-10-08T01:26:18Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-10-08T01:26:18Z"}, "message": "flow.c (find_basic_blocks): Calc upper bound for extra nops in max_uids_for_flow.\n\n        * flow.c (find_basic_blocks): Calc upper bound for extra nops in\n        max_uids_for_flow.\n        (find_basic_blocks_1): Add a nop to the end of a basic block when\n        a trailing call insn does not have abnormal control flow.\n        * gcse.c (pre_transpout): New variable.\n        (alloc_pre_mem, free_pre_mem, dump_pre_data): Bookkeeping for it.\n        (compute_pre_transpout): Calculate it.\n        (compute_pre_ppinout): Use it to eliminate impossible placements\n        due to abnormal control flow through calls.\n        (compute_pre_data): Call compute_pre_transpout.\n\nFrom-SVN: r22907", "tree": {"sha": "89dcc7e1ae801c171115e2585b049fc5366cbe4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89dcc7e1ae801c171115e2585b049fc5366cbe4d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c35539b1ab41da8800ebb1fdc983237a7d9cdd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c35539b1ab41da8800ebb1fdc983237a7d9cdd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c35539b1ab41da8800ebb1fdc983237a7d9cdd7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c35539b1ab41da8800ebb1fdc983237a7d9cdd7/comments", "author": null, "committer": null, "parents": [{"sha": "58d9f9d9f2e32f6b1d15e1e9f30a8aadc1d31d92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58d9f9d9f2e32f6b1d15e1e9f30a8aadc1d31d92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58d9f9d9f2e32f6b1d15e1e9f30a8aadc1d31d92"}], "stats": {"total": 163, "additions": 138, "deletions": 25}, "files": [{"sha": "d7d849048b268231675f80aec0e598265a9e779b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c35539b1ab41da8800ebb1fdc983237a7d9cdd7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c35539b1ab41da8800ebb1fdc983237a7d9cdd7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5c35539b1ab41da8800ebb1fdc983237a7d9cdd7", "patch": "@@ -1,3 +1,16 @@\n+Thu Oct  8 01:25:22 1998  Richard Henderson  <rth@cygnus.com>\n+\n+\t* flow.c (find_basic_blocks): Calc upper bound for extra nops in\n+\tmax_uids_for_flow.\n+\t(find_basic_blocks_1): Add a nop to the end of a basic block when\n+\ta trailing call insn does not have abnormal control flow.\n+\t* gcse.c (pre_transpout): New variable.\n+\t(alloc_pre_mem, free_pre_mem, dump_pre_data): Bookkeeping for it.\n+\t(compute_pre_transpout): Calculate it.\n+\t(compute_pre_ppinout): Use it to eliminate impossible placements\n+\tdue to abnormal control flow through calls.\n+\t(compute_pre_data): Call compute_pre_transpout.\n+\n Wed Oct  7 21:40:24 1998  David S. Miller  <davem@pierdol.cobaltmicro.com>\n \n \t* config/sparc/sol2-sld-64.h (ASM_CPU_SPEC): Fix typo."}, {"sha": "773aaf2be969d269b3f9c4dc9caef046d2f86a18", "filename": "gcc/flow.c", "status": "modified", "additions": 54, "deletions": 15, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c35539b1ab41da8800ebb1fdc983237a7d9cdd7/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c35539b1ab41da8800ebb1fdc983237a7d9cdd7/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=5c35539b1ab41da8800ebb1fdc983237a7d9cdd7", "patch": "@@ -306,6 +306,7 @@ find_basic_blocks (f, nregs, file, live_reachable_p)\n   register int i;\n   rtx nonlocal_label_list = nonlocal_label_rtx_list ();\n   int in_libcall_block = 0;\n+  int extra_uids_for_flow = 0;\n \n   /* Count the basic blocks.  Also find maximum insn uid value used.  */\n \n@@ -318,7 +319,6 @@ find_basic_blocks (f, nregs, file, live_reachable_p)\n \n     for (insn = f, i = 0; insn; insn = NEXT_INSN (insn))\n       {\n-\n \t/* Track when we are inside in LIBCALL block.  */\n \tif (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n \t    && find_reg_note (insn, REG_LIBCALL, NULL_RTX))\n@@ -327,13 +327,33 @@ find_basic_blocks (f, nregs, file, live_reachable_p)\n \tcode = GET_CODE (insn);\n \tif (INSN_UID (insn) > max_uid_for_flow)\n \t  max_uid_for_flow = INSN_UID (insn);\n-\tif (code == CODE_LABEL\n-\t    || (GET_RTX_CLASS (code) == 'i'\n-\t\t&& (prev_code == JUMP_INSN\n-\t\t    || (prev_code == CALL_INSN\n-\t\t\t&& (nonlocal_label_list != 0 || eh_region))\n-\t\t    || prev_code == BARRIER)))\n+\tif (code == CODE_LABEL)\n \t  i++;\n+\telse if (GET_RTX_CLASS (code) == 'i')\n+\t  {\n+\t    if (prev_code == JUMP_INSN || prev_code == BARRIER)\n+\t      i++;\n+\t    else if (prev_code == CALL_INSN)\n+\t      {\n+\t\tif (nonlocal_label_list != 0 || eh_region)\n+\t\t  i++;\n+\t\telse\n+\t\t  {\n+\t\t    /* Else this call does not force a new block to be\n+\t\t       created.  However, it may still be the end of a basic\n+\t\t       block if it is followed by a CODE_LABEL or a BARRIER.\n+\n+\t\t       To disambiguate calls which force new blocks to be\n+\t\t       created from those which just happen to be at the end\n+\t\t       of a block we insert nops during find_basic_blocks_1\n+\t\t       after calls which are the last insn in a block by\n+\t\t       chance.  We must account for such insns in\n+\t\t       max_uid_for_flow.  */\n+\n+\t\t    extra_uids_for_flow++;\n+\t\t  }\n+\t      }\n+\t  }\n \n \t/* We change the code of the CALL_INSN, so that it won't start a\n \t   new block.  */\n@@ -360,6 +380,7 @@ find_basic_blocks (f, nregs, file, live_reachable_p)\n      These cases are rare, so we don't need too much space.  */\n   max_uid_for_flow += max_uid_for_flow / 10;\n #endif\n+  max_uid_for_flow += extra_uids_for_flow;\n \n   /* Allocate some tables that last till end of compiling this function\n      and some needed only in find_basic_blocks and life_analysis.  */\n@@ -410,6 +431,7 @@ find_basic_blocks_1 (f, nonlocal_label_list, live_reachable_p)\n   int depth, pass;\n   int in_libcall_block = 0;\n   int deleted_handler = 0;\n+  int call_had_abnormal_edge = 0;\n \n   pass = 1;\n   active_eh_region = (int *) alloca ((max_uid_for_flow + 1) * sizeof (int));\n@@ -456,8 +478,7 @@ find_basic_blocks_1 (f, nonlocal_label_list, live_reachable_p)\n       else if (code == CODE_LABEL\n \t       || (GET_RTX_CLASS (code) == 'i'\n \t\t   && (prev_code == JUMP_INSN\n-\t\t       || (prev_code == CALL_INSN\n-\t\t\t   && (nonlocal_label_list != 0 || eh_note))\n+\t\t       || (prev_code == CALL_INSN && call_had_abnormal_edge)\n \t\t       || prev_code == BARRIER)))\n \t{\n \t  basic_block_head[++i] = insn;\n@@ -466,12 +487,26 @@ find_basic_blocks_1 (f, nonlocal_label_list, live_reachable_p)\n \n \t  if (code == CODE_LABEL)\n \t    {\n-\t\tLABEL_REFS (insn) = insn;\n-\t\t/* Any label that cannot be deleted\n-\t\t   is considered to start a reachable block.  */\n-\t\tif (LABEL_PRESERVE_P (insn))\n-\t\t  block_live[i] = 1;\n-\t      }\n+\t      LABEL_REFS (insn) = insn;\n+\t      /* Any label that cannot be deleted\n+\t\t is considered to start a reachable block.  */\n+\t      if (LABEL_PRESERVE_P (insn))\n+\t\tblock_live[i] = 1;\n+\t    }\n+\n+\t  /* If the previous insn was a call that did not create an\n+\t     abnormal edge, we want to add a nop so that the CALL_INSN\n+\t     itself is not at basic_block_end.  This allows us to easily\n+\t     distinguish between normal calls and those which create\n+\t     abnormal edges in the flow graph.  */\n+\n+\t  if (i > 0 && !call_had_abnormal_edge\n+\t      && GET_CODE (basic_block_end[i-1]) == CALL_INSN)\n+\t    {\n+\t      rtx nop = gen_rtx_USE (VOIDmode, const0_rtx);\n+\t      nop = emit_insn_after (nop, basic_block_end[i-1]);\n+\t      basic_block_end[i-1] = nop;\n+\t    }\n \t}\n \n       else if (GET_RTX_CLASS (code) == 'i')\n@@ -524,6 +559,10 @@ find_basic_blocks_1 (f, nonlocal_label_list, live_reachable_p)\n       if (code == CALL_INSN && in_libcall_block)\n \tcode = INSN;\n \n+      /* Record whether this call created an edge.  */\n+      if (code == CALL_INSN)\n+\tcall_had_abnormal_edge = (nonlocal_label_list != 0 || eh_note);\n+\n       if (code != NOTE)\n \tprev_code = code;\n "}, {"sha": "0732cb4cadd3915c03675e4e07298c12b2681175", "filename": "gcc/gcse.c", "status": "modified", "additions": 71, "deletions": 10, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c35539b1ab41da8800ebb1fdc983237a7d9cdd7/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c35539b1ab41da8800ebb1fdc983237a7d9cdd7/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=5c35539b1ab41da8800ebb1fdc983237a7d9cdd7", "patch": "@@ -3888,6 +3888,11 @@ static sbitmap *pre_pavout;\n static sbitmap *pre_ppin;\n static sbitmap *pre_ppout;\n \n+/* Nonzero for expressions that are transparent at the end of the block.\n+   This is only zero for expressions killed by abnormal critical edge\n+   created by a calls.  */\n+static sbitmap *pre_transpout;\n+\n /* Used while performing PRE to denote which insns are redundant.  */\n static sbitmap pre_redundant;\n \n@@ -3910,6 +3915,8 @@ alloc_pre_mem (n_blocks, n_exprs)\n   pre_pavout = sbitmap_vector_alloc (n_blocks, n_exprs);\n   pre_ppin = sbitmap_vector_alloc (n_blocks, n_exprs);\n   pre_ppout = sbitmap_vector_alloc (n_blocks, n_exprs);\n+\n+  pre_transpout = sbitmap_vector_alloc (n_blocks, n_exprs);\n }\n \n /* Free vars used for PRE analysis.  */\n@@ -3920,7 +3927,6 @@ free_pre_mem ()\n   free (pre_transp);\n   free (pre_comp);\n   free (pre_antloc);\n-\n   free (pre_avin);\n   free (pre_avout);\n   free (pre_antin);\n@@ -3930,6 +3936,7 @@ free_pre_mem ()\n   free (pre_pavout);\n   free (pre_ppin);\n   free (pre_ppout);\n+  free (pre_transpout);\n }\n \n /* Dump PRE data.  */\n@@ -3962,6 +3969,9 @@ dump_pre_data (file)\n \t\t       pre_ppin, n_basic_blocks);\n   dump_sbitmap_vector (file, \"PRE placement possible on outgoing\", \"BB\",\n \t\t       pre_ppout, n_basic_blocks);\n+\n+  dump_sbitmap_vector (file, \"PRE transparent on outgoing\", \"BB\",\n+\t\t       pre_transpout, n_basic_blocks);\n }\n \n /* Compute the local properties of each recorded expression.\n@@ -4129,6 +4139,57 @@ compute_pre_pavinout ()\n     fprintf (gcse_file, \"partially avail expr computation: %d passes\\n\", passes);\n }\n \n+/* Compute transparent outgoing information for each block.\n+\n+   An expression is transparent to an edge unless it is killed by\n+   the edge itself.  This can only happen with abnormal control flow,\n+   when the edge is traversed through a call.  This happens with\n+   non-local labels and exceptions.\n+\n+   This would not be necessary if we split the edge.  While this is\n+   normally impossible for abnormal critical edges, with some effort\n+   it should be possible with exception handling, since we still have\n+   control over which handler should be invoked.  But due to increased\n+   EH table sizes, this may not be worthwhile.  */\n+\n+static void\n+compute_pre_transpout ()\n+{\n+  int bb;\n+\n+  sbitmap_vector_ones (pre_transpout, n_basic_blocks);\n+\n+  for (bb = 0; bb < n_basic_blocks; ++bb)\n+    {\n+      int i;\n+\n+      /* Note that flow inserted a nop a the end of basic blocks that\n+\t end in call instructions for reasons other than abnormal\n+\t control flow.  */\n+      if (GET_CODE (BLOCK_END (bb)) != CALL_INSN)\n+\tcontinue;\n+\n+      for (i = 0; i < expr_hash_table_size; i++)\n+\t{\n+\t  struct expr *expr;\n+\t  for (expr = expr_hash_table[i]; expr ; expr = expr->next_same_hash)\n+\t    if (GET_CODE (expr->expr) == MEM)\n+\t      {\n+\t\trtx addr = XEXP (expr->expr, 0);\n+\n+\t\tif (GET_CODE (addr) == SYMBOL_REF\n+\t\t    && CONSTANT_POOL_ADDRESS_P (addr))\n+\t\t  continue;\n+\t\t\n+\t\t/* ??? Optimally, we would use interprocedural alias\n+\t\t   analysis to determine if this mem is actually killed\n+\t\t   by this call.  */\n+\t\tRESET_BIT (pre_transpout[bb], expr->bitmap_index);\n+\t      }\n+\t}\n+    }\n+}   \n+\n /* Compute \"placement possible\" information on entrance and exit of\n    each block.\n \n@@ -4209,11 +4270,12 @@ compute_pre_ppinout ()\n       for (bb = 0; bb < n_basic_blocks - 1; bb++)\n \t{\n \t  sbitmap_ptr ppout = pre_ppout[bb]->elms;\n+\t  sbitmap_ptr transpout = pre_transpout[bb]->elms;\n \n \t  for (i = 0; i < size; i++)\n \t    {\n \t      int_list_ptr succ;\n-\t      SBITMAP_ELT_TYPE tmp = -1L;\n+\t      SBITMAP_ELT_TYPE tmp = *transpout;\n \n \t      for (succ = s_succs[bb]; succ != NULL; succ = succ->next)\n \t\t{\n@@ -4226,13 +4288,14 @@ compute_pre_ppinout ()\n \t\t  ppin = pre_ppin[succ_bb]->elms + i;\n \t\t  tmp &= *ppin;\n \t\t}\n+\n \t      if (*ppout != tmp)\n \t\t{\n \t\t  changed = 1;\n-\t\t  *ppout++ = tmp;\n+\t\t  *ppout = tmp;\n \t\t}\n-\t      else\n-\t\tppout++;\n+\n+\t      ppout++; transpout++;\n \t    }\n \t}\n \n@@ -4252,6 +4315,7 @@ compute_pre_data ()\n   compute_pre_avinout ();\n   compute_pre_antinout ();\n   compute_pre_pavinout ();\n+  compute_pre_transpout ();\n   compute_pre_ppinout ();\n   if (gcse_file)\n     fprintf (gcse_file, \"\\n\");\n@@ -4376,10 +4440,7 @@ pre_insert_insn (expr, bb)\n     }\n   /* Likewise if the last insn is a call, as will happen in the presence\n      of exception handling.  */\n-  /* ??? The flag_exceptions test is not exact.  We don't know if we are\n-     actually in an eh region.  Fix flow to tell us this.  */\n-  else if (GET_CODE (insn) == CALL_INSN\n-\t   && (current_function_has_nonlocal_label || flag_exceptions))\n+  else if (GET_CODE (insn) == CALL_INSN)\n     {\n       HARD_REG_SET parm_regs;\n       int nparm_regs;\n@@ -4409,7 +4470,7 @@ pre_insert_insn (expr, bb)\n \t  {\n \t    int regno = REGNO (XEXP (XEXP (p, 0), 0));\n \t    if (regno >= FIRST_PSEUDO_REGISTER)\n-\t      abort();\n+\t      abort ();\n \t    SET_HARD_REG_BIT (parm_regs, regno);\n \t    nparm_regs++;\n \t  }"}]}