{"sha": "26630a99dafdef4cd1bba28af0b37bc47d8aed13", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjY2MzBhOTlkYWZkZWY0Y2QxYmJhMjhhZjBiMzdiYzQ3ZDhhZWQxMw==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2004-10-22T10:31:23Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2004-10-22T10:31:23Z"}, "message": "tree-ssa-loop-niter.c (inverse): Count in HOST_WIDE_INT if possible.\n\n\t* tree-ssa-loop-niter.c (inverse): Count in HOST_WIDE_INT if possible.\n\tUse integer for loop counter.\n\t(num_ending_zeros): New function.\n\t(number_of_iterations_cond): Use num_ending_zeros.\n\nFrom-SVN: r89438", "tree": {"sha": "13ee966281459722eb863a1e0d4e46cfdfd72642", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/13ee966281459722eb863a1e0d4e46cfdfd72642"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/26630a99dafdef4cd1bba28af0b37bc47d8aed13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26630a99dafdef4cd1bba28af0b37bc47d8aed13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26630a99dafdef4cd1bba28af0b37bc47d8aed13", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26630a99dafdef4cd1bba28af0b37bc47d8aed13/comments", "author": null, "committer": null, "parents": [{"sha": "aed305a929bbaff9bed857638b90899e1ec37622", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aed305a929bbaff9bed857638b90899e1ec37622", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aed305a929bbaff9bed857638b90899e1ec37622"}], "stats": {"total": 109, "additions": 84, "deletions": 25}, "files": [{"sha": "dccead94fd0161dac99f6dc8602d56ca302c615b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26630a99dafdef4cd1bba28af0b37bc47d8aed13/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26630a99dafdef4cd1bba28af0b37bc47d8aed13/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=26630a99dafdef4cd1bba28af0b37bc47d8aed13", "patch": "@@ -1,3 +1,10 @@\n+2004-10-22  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* tree-ssa-loop-niter.c (inverse): Count in HOST_WIDE_INT if possible.\n+\tUse integer for loop counter.\n+\t(num_ending_zeros): New function.\n+\t(number_of_iterations_cond): Use num_ending_zeros.\n+\n 2004-10-21  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* config.gcc: Add support for --enable-e500_double."}, {"sha": "5e9f4fa3b6000a72da5defd67fe1725cb75ec988", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 77, "deletions": 25, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26630a99dafdef4cd1bba28af0b37bc47d8aed13/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26630a99dafdef4cd1bba28af0b37bc47d8aed13/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=26630a99dafdef4cd1bba28af0b37bc47d8aed13", "patch": "@@ -83,22 +83,83 @@ nonzero_p (tree arg)\n   return (TREE_INT_CST_LOW (arg) != 0 || TREE_INT_CST_HIGH (arg) != 0);\n }\n \n+/* Returns number of zeros at the end of binary representation of X.\n+   \n+   ??? Use ffs if available?  */\n+\n+static tree\n+num_ending_zeros (tree x)\n+{\n+  unsigned HOST_WIDE_INT fr, nfr;\n+  unsigned num, abits;\n+  tree type = TREE_TYPE (x);\n+\n+  if (TREE_INT_CST_LOW (x) == 0)\n+    {\n+      num = HOST_BITS_PER_WIDE_INT;\n+      fr = TREE_INT_CST_HIGH (x);\n+    }\n+  else\n+    {\n+      num = 0;\n+      fr = TREE_INT_CST_LOW (x);\n+    }\n+\n+  for (abits = HOST_BITS_PER_WIDE_INT / 2; abits; abits /= 2)\n+    {\n+      nfr = fr >> abits;\n+      if (nfr << abits == fr)\n+\t{\n+\t  num += abits;\n+\t  fr = nfr;\n+\t}\n+    }\n+\n+  if (num > TYPE_PRECISION (type))\n+    num = TYPE_PRECISION (type);\n+\n+  return build_int_cst_type (type, num);\n+}\n+\n /* Returns inverse of X modulo 2^s, where MASK = 2^s-1.  */\n \n static tree\n inverse (tree x, tree mask)\n {\n   tree type = TREE_TYPE (x);\n-  tree ctr = EXEC_BINARY (RSHIFT_EXPR, type, mask, integer_one_node);\n-  tree rslt = build_int_cst_type (type, 1);\n+  tree rslt;\n+  unsigned ctr = tree_floor_log2 (mask);\n+\n+  if (TYPE_PRECISION (type) <= HOST_BITS_PER_WIDE_INT)\n+    {\n+      unsigned HOST_WIDE_INT ix;\n+      unsigned HOST_WIDE_INT imask;\n+      unsigned HOST_WIDE_INT irslt = 1;\n+\n+      gcc_assert (cst_and_fits_in_hwi (x));\n+      gcc_assert (cst_and_fits_in_hwi (mask));\n+\n+      ix = int_cst_value (x);\n+      imask = int_cst_value (mask);\n+\n+      for (; ctr; ctr--)\n+\t{\n+\t  irslt *= ix;\n+\t  ix *= ix;\n+\t}\n+      irslt &= imask;\n \n-  while (nonzero_p (ctr))\n+      rslt = build_int_cst_type (type, irslt);\n+    }\n+  else\n     {\n-      rslt = EXEC_BINARY (MULT_EXPR, type, rslt, x);\n+      rslt = build_int_cst_type (type, 1);\n+      for (; ctr; ctr--)\n+\t{\n+\t  rslt = EXEC_BINARY (MULT_EXPR, type, rslt, x);\n+\t  x = EXEC_BINARY (MULT_EXPR, type, x, x);\n+\t}\n       rslt = EXEC_BINARY (BIT_AND_EXPR, type, rslt, mask);\n-      x = EXEC_BINARY (MULT_EXPR, type, x, x);\n-      x = EXEC_BINARY (BIT_AND_EXPR, type, x, mask);\n-      ctr = EXEC_BINARY (RSHIFT_EXPR, type, ctr, integer_one_node);\n     }\n \n   return rslt;\n@@ -129,6 +190,7 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n   tree assumptions = boolean_true_node;\n   tree noloop_assumptions = boolean_false_node;\n   tree niter_type, signed_niter_type;\n+  tree bits;\n \n   /* The meaning of these assumptions is this:\n      if !assumptions\n@@ -350,26 +412,16 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n       base1 = fold_convert (niter_type, base1);\n       step0 = fold_convert (niter_type, step0);\n \n-      /* Let nsd (s, size of mode) = d.  If d does not divide c, the loop\n+      /* Let nsd (step, size of mode) = d.  If d does not divide c, the loop\n \t is infinite.  Otherwise, the number of iterations is\n \t (inverse(s/d) * (c/d)) mod (size of mode/d).  */\n-      s = step0;\n-      d = integer_one_node;\n-      bound = build_int_cst (niter_type, -1);\n-      while (1)\n-\t{\n-\t  tmp = EXEC_BINARY (BIT_AND_EXPR, niter_type, s,\n-\t\t\t     build_int_cst (niter_type, 1));\n-\t  if (nonzero_p (tmp))\n-\t    break;\n-\t  \n-\t  s = EXEC_BINARY (RSHIFT_EXPR, niter_type, s,\n-\t\t\t   build_int_cst (niter_type, 1));\n-\t  d = EXEC_BINARY (LSHIFT_EXPR, niter_type, d,\n-\t\t\t   build_int_cst (niter_type, 1));\n-\t  bound = EXEC_BINARY (RSHIFT_EXPR, niter_type, bound,\n-\t\t\t       build_int_cst (niter_type, 1));\n-\t}\n+      bits = num_ending_zeros (step0);\n+      d = EXEC_BINARY (LSHIFT_EXPR, niter_type,\n+\t\t       build_int_cst_type (niter_type, 1), bits);\n+      s = EXEC_BINARY (RSHIFT_EXPR, niter_type, step0, bits);\n+      bound = EXEC_BINARY (RSHIFT_EXPR, niter_type,\n+\t\t\t   build_int_cst (niter_type, -1),\n+\t\t\t   bits);\n \n       assumption = fold (build2 (FLOOR_MOD_EXPR, niter_type, base1, d));\n       assumption = fold (build2 (EQ_EXPR, boolean_type_node,"}]}