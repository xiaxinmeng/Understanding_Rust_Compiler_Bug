{"sha": "2e1eedd6bb7d1e6358847d0ab912f13aa69ef403", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmUxZWVkZDZiYjdkMWU2MzU4ODQ3ZDBhYjkxMmYxM2FhNjllZjQwMw==", "commit": {"author": {"name": "Andreas Jaeger", "email": "aj@suse.de", "date": "2003-07-06T16:53:24Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2003-07-06T16:53:24Z"}, "message": "unroll.c: Convert prototypes to ISO C90.\n\n\t* unroll.c: Convert prototypes to ISO C90.\n\t* varasm.c: Likewise.\n\t* varray.c: Likewise.\n\t* varray.h: Likewise.\n\t* vmsdbgout.c: Likewise.\n\t* xcoffout.c: Likewise.\n\t* xcoffout.h: Likewise.\n\nFrom-SVN: r69007", "tree": {"sha": "2b8d50a4862c8d39950245978962da1214554a62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b8d50a4862c8d39950245978962da1214554a62"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e1eedd6bb7d1e6358847d0ab912f13aa69ef403", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e1eedd6bb7d1e6358847d0ab912f13aa69ef403", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e1eedd6bb7d1e6358847d0ab912f13aa69ef403", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e1eedd6bb7d1e6358847d0ab912f13aa69ef403/comments", "author": {"login": "ajaeger", "id": 16867, "node_id": "MDQ6VXNlcjE2ODY3", "avatar_url": "https://avatars.githubusercontent.com/u/16867?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ajaeger", "html_url": "https://github.com/ajaeger", "followers_url": "https://api.github.com/users/ajaeger/followers", "following_url": "https://api.github.com/users/ajaeger/following{/other_user}", "gists_url": "https://api.github.com/users/ajaeger/gists{/gist_id}", "starred_url": "https://api.github.com/users/ajaeger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ajaeger/subscriptions", "organizations_url": "https://api.github.com/users/ajaeger/orgs", "repos_url": "https://api.github.com/users/ajaeger/repos", "events_url": "https://api.github.com/users/ajaeger/events{/privacy}", "received_events_url": "https://api.github.com/users/ajaeger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dd486eb27ce3fc75e02311d3e36d9e10a9f56eee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd486eb27ce3fc75e02311d3e36d9e10a9f56eee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd486eb27ce3fc75e02311d3e36d9e10a9f56eee"}], "stats": {"total": 1125, "additions": 397, "deletions": 728}, "files": [{"sha": "80e4c2f58ccd6aeec847eb383db8a0d8e709b113", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e1eedd6bb7d1e6358847d0ab912f13aa69ef403/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e1eedd6bb7d1e6358847d0ab912f13aa69ef403/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2e1eedd6bb7d1e6358847d0ab912f13aa69ef403", "patch": "@@ -1,3 +1,13 @@\n+2003-07-06  Andreas Jaeger  <aj@suse.de>\n+\n+\t* unroll.c: Likewise.\n+\t* varasm.c: Likewise.\n+\t* varray.c: Likewise.\n+\t* varray.h: Likewise.\n+\t* vmsdbgout.c: Likewise.\n+\t* xcoffout.c: Likewise.\n+\t* xcoffout.h: Likewise.\n+\n 2003-07-06  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* gcov-io.h: Add a local time stamp."}, {"sha": "955136e0b03b02b01e420932332688b535c845fb", "filename": "gcc/unroll.c", "status": "modified", "additions": 58, "deletions": 108, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e1eedd6bb7d1e6358847d0ab912f13aa69ef403/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e1eedd6bb7d1e6358847d0ab912f13aa69ef403/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=2e1eedd6bb7d1e6358847d0ab912f13aa69ef403", "patch": "@@ -1,5 +1,6 @@\n /* Try to unroll loops, and split induction variables.\n-   Copyright (C) 1992, 1993, 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2002\n+   Copyright (C) 1992, 1993, 1994, 1995, 1997, 1998, 1999, 2000, 2001,\n+   2002, 2003\n    Free Software Foundation, Inc.\n    Contributed by James E. Wilson, Cygnus Support/UC Berkeley.\n \n@@ -196,28 +197,26 @@ static int *splittable_regs_updates;\n \n /* Forward declarations.  */\n \n-static rtx simplify_cmp_and_jump_insns PARAMS ((enum rtx_code,\n-\t\t\t\t\t\tenum machine_mode,\n-\t\t\t\t\t\trtx, rtx, rtx));\n-static void init_reg_map PARAMS ((struct inline_remap *, int));\n-static rtx calculate_giv_inc PARAMS ((rtx, rtx, unsigned int));\n-static rtx initial_reg_note_copy PARAMS ((rtx, struct inline_remap *));\n-static void final_reg_note_copy PARAMS ((rtx *, struct inline_remap *));\n-static void copy_loop_body PARAMS ((struct loop *, rtx, rtx,\n-\t\t\t\t    struct inline_remap *, rtx, int,\n-\t\t\t\t    enum unroll_types, rtx, rtx, rtx, rtx));\n-static int find_splittable_regs PARAMS ((const struct loop *,\n-\t\t\t\t\t enum unroll_types, int));\n-static int find_splittable_givs PARAMS ((const struct loop *,\n-\t\t\t\t\t struct iv_class *, enum unroll_types,\n-\t\t\t\t\t rtx, int));\n-static int reg_dead_after_loop PARAMS ((const struct loop *, rtx));\n-static rtx fold_rtx_mult_add PARAMS ((rtx, rtx, rtx, enum machine_mode));\n-static rtx remap_split_bivs PARAMS ((struct loop *, rtx));\n-static rtx find_common_reg_term PARAMS ((rtx, rtx));\n-static rtx subtract_reg_term PARAMS ((rtx, rtx));\n-static rtx loop_find_equiv_value PARAMS ((const struct loop *, rtx));\n-static rtx ujump_to_loop_cont PARAMS ((rtx, rtx));\n+static rtx simplify_cmp_and_jump_insns (enum rtx_code, enum machine_mode,\n+\t\t\t\t\trtx, rtx, rtx);\n+static void init_reg_map (struct inline_remap *, int);\n+static rtx calculate_giv_inc (rtx, rtx, unsigned int);\n+static rtx initial_reg_note_copy (rtx, struct inline_remap *);\n+static void final_reg_note_copy (rtx *, struct inline_remap *);\n+static void copy_loop_body (struct loop *, rtx, rtx,\n+\t\t\t    struct inline_remap *, rtx, int,\n+\t\t\t    enum unroll_types, rtx, rtx, rtx, rtx);\n+static int find_splittable_regs (const struct loop *, enum unroll_types,\n+\t\t\t\t int);\n+static int find_splittable_givs (const struct loop *, struct iv_class *,\n+\t\t\t\t enum unroll_types, rtx, int);\n+static int reg_dead_after_loop (const struct loop *, rtx);\n+static rtx fold_rtx_mult_add (rtx, rtx, rtx, enum machine_mode);\n+static rtx remap_split_bivs (struct loop *, rtx);\n+static rtx find_common_reg_term (rtx, rtx);\n+static rtx subtract_reg_term (rtx, rtx);\n+static rtx loop_find_equiv_value (const struct loop *, rtx);\n+static rtx ujump_to_loop_cont (rtx, rtx);\n \n /* Try to unroll one loop and split induction variables in the loop.\n \n@@ -229,10 +228,7 @@ static rtx ujump_to_loop_cont PARAMS ((rtx, rtx));\n    in loop.c.  */\n \n void\n-unroll_loop (loop, insn_count, strength_reduce_p)\n-     struct loop *loop;\n-     int insn_count;\n-     int strength_reduce_p;\n+unroll_loop (struct loop *loop, int insn_count, int strength_reduce_p)\n {\n   struct loop_info *loop_info = LOOP_INFO (loop);\n   struct loop_ivs *ivs = LOOP_IVS (loop);\n@@ -1332,16 +1328,14 @@ unroll_loop (loop, insn_count, strength_reduce_p)\n   free (map);\n }\n \n-/* A helper function for unroll_loop.  Emit a compare and branch to \n+/* A helper function for unroll_loop.  Emit a compare and branch to\n    satisfy (CMP OP1 OP2), but pass this through the simplifier first.\n    If the branch turned out to be conditional, return it, otherwise\n    return NULL.  */\n \n static rtx\n-simplify_cmp_and_jump_insns (code, mode, op0, op1, label)\n-     enum rtx_code code;\n-     enum machine_mode mode;\n-     rtx op0, op1, label;\n+simplify_cmp_and_jump_insns (enum rtx_code code, enum machine_mode mode,\n+\t\t\t     rtx op0, rtx op1, rtx label)\n {\n   rtx t, insn;\n \n@@ -1387,10 +1381,9 @@ simplify_cmp_and_jump_insns (code, mode, op0, op1, label)\n    reflected in RTX_COST.  */\n \n int\n-precondition_loop_p (loop, initial_value, final_value, increment, mode)\n-     const struct loop *loop;\n-     rtx *initial_value, *final_value, *increment;\n-     enum machine_mode *mode;\n+precondition_loop_p (const struct loop *loop, rtx *initial_value,\n+\t\t     rtx *final_value, rtx *increment,\n+\t\t     enum machine_mode *mode)\n {\n   rtx loop_start = loop->start;\n   struct loop_info *loop_info = LOOP_INFO (loop);\n@@ -1547,9 +1540,7 @@ precondition_loop_p (loop, initial_value, final_value, increment, mode)\n    modes.  */\n \n static void\n-init_reg_map (map, maxregnum)\n-     struct inline_remap *map;\n-     int maxregnum;\n+init_reg_map (struct inline_remap *map, int maxregnum)\n {\n   int i;\n \n@@ -1574,9 +1565,7 @@ init_reg_map (map, maxregnum)\n    The return value is the amount that the giv is incremented by.  */\n \n static rtx\n-calculate_giv_inc (pattern, src_insn, regno)\n-     rtx pattern, src_insn;\n-     unsigned int regno;\n+calculate_giv_inc (rtx pattern, rtx src_insn, unsigned int regno)\n {\n   rtx increment;\n   rtx increment_total = 0;\n@@ -1697,9 +1686,7 @@ calculate_giv_inc (pattern, src_insn, regno)\n    the reg_map entries can change during copying.  */\n \n static rtx\n-initial_reg_note_copy (notes, map)\n-     rtx notes;\n-     struct inline_remap *map;\n+initial_reg_note_copy (rtx notes, struct inline_remap *map)\n {\n   rtx copy;\n \n@@ -1725,9 +1712,7 @@ initial_reg_note_copy (notes, map)\n /* Fixup insn references in copied REG_NOTES.  */\n \n static void\n-final_reg_note_copy (notesp, map)\n-     rtx *notesp;\n-     struct inline_remap *map;\n+final_reg_note_copy (rtx *notesp, struct inline_remap *map)\n {\n   while (*notesp)\n     {\n@@ -1757,16 +1742,11 @@ final_reg_note_copy (notesp, map)\n    This is very similar to a loop in expand_inline_function.  */\n \n static void\n-copy_loop_body (loop, copy_start, copy_end, map, exit_label, last_iteration,\n-\t\tunroll_type, start_label, loop_end, insert_before,\n-\t\tcopy_notes_from)\n-     struct loop *loop;\n-     rtx copy_start, copy_end;\n-     struct inline_remap *map;\n-     rtx exit_label;\n-     int last_iteration;\n-     enum unroll_types unroll_type;\n-     rtx start_label, loop_end, insert_before, copy_notes_from;\n+copy_loop_body (struct loop *loop, rtx copy_start, rtx copy_end,\n+\t\tstruct inline_remap *map, rtx exit_label,\n+\t\tint last_iteration, enum unroll_types unroll_type,\n+\t\trtx start_label, rtx loop_end, rtx insert_before,\n+\t\trtx copy_notes_from)\n {\n   struct loop_ivs *ivs = LOOP_IVS (loop);\n   rtx insn, pattern;\n@@ -2326,8 +2306,7 @@ copy_loop_body (loop, copy_start, copy_end, map, exit_label, last_iteration,\n    won't fit in the immediate field of a PLUS insns.  */\n \n void\n-emit_unrolled_add (dest_reg, src_reg, increment)\n-     rtx dest_reg, src_reg, increment;\n+emit_unrolled_add (rtx dest_reg, rtx src_reg, rtx increment)\n {\n   rtx result;\n \n@@ -2347,9 +2326,7 @@ emit_unrolled_add (dest_reg, src_reg, increment)\n    and uses a negligible amount of CPU time on average.  */\n \n int\n-back_branch_in_range_p (loop, insn)\n-     const struct loop *loop;\n-     rtx insn;\n+back_branch_in_range_p (const struct loop *loop, rtx insn)\n {\n   rtx p, q, target_insn;\n   rtx loop_start = loop->start;\n@@ -2395,9 +2372,7 @@ back_branch_in_range_p (loop, insn)\n    value of giv's.  */\n \n static rtx\n-fold_rtx_mult_add (mult1, mult2, add1, mode)\n-     rtx mult1, mult2, add1;\n-     enum machine_mode mode;\n+fold_rtx_mult_add (rtx mult1, rtx mult2, rtx add1, enum machine_mode mode)\n {\n   rtx temp, mult_res;\n   rtx result;\n@@ -2444,8 +2419,7 @@ fold_rtx_mult_add (mult1, mult2, add1, mode)\n    if it can be calculated.  Otherwise, returns 0.  */\n \n rtx\n-biv_total_increment (bl)\n-     const struct iv_class *bl;\n+biv_total_increment (const struct iv_class *bl)\n {\n   struct induction *v;\n   rtx result;\n@@ -2496,10 +2470,8 @@ biv_total_increment (bl)\n    times, since multiplies by small integers (1,2,3,4) are very cheap.  */\n \n static int\n-find_splittable_regs (loop, unroll_type, unroll_number)\n-     const struct loop *loop;\n-     enum unroll_types unroll_type;\n-     int unroll_number;\n+find_splittable_regs (const struct loop *loop,\n+\t\t      enum unroll_types unroll_type, int unroll_number)\n {\n   struct loop_ivs *ivs = LOOP_IVS (loop);\n   struct iv_class *bl;\n@@ -2655,12 +2627,9 @@ find_splittable_regs (loop, unroll_type, unroll_number)\n    Return the number of instructions that set splittable registers.  */\n \n static int\n-find_splittable_givs (loop, bl, unroll_type, increment, unroll_number)\n-     const struct loop *loop;\n-     struct iv_class *bl;\n-     enum unroll_types unroll_type;\n-     rtx increment;\n-     int unroll_number ATTRIBUTE_UNUSED;\n+find_splittable_givs (const struct loop *loop, struct iv_class *bl,\n+\t\t      enum unroll_types unroll_type, rtx increment,\n+\t\t      int unroll_number ATTRIBUTE_UNUSED)\n {\n   struct loop_ivs *ivs = LOOP_IVS (loop);\n   struct induction *v, *v2;\n@@ -2894,9 +2863,7 @@ find_splittable_givs (loop, bl, unroll_type, increment, unroll_number)\n    it can search past if statements and other similar structures.  */\n \n static int\n-reg_dead_after_loop (loop, reg)\n-     const struct loop *loop;\n-     rtx reg;\n+reg_dead_after_loop (const struct loop *loop, rtx reg)\n {\n   rtx insn, label;\n   enum rtx_code code;\n@@ -2966,9 +2933,7 @@ reg_dead_after_loop (loop, reg)\n    the end of the loop.  If we can do it, return that value.  */\n \n rtx\n-final_biv_value (loop, bl)\n-     const struct loop *loop;\n-     struct iv_class *bl;\n+final_biv_value (const struct loop *loop, struct iv_class *bl)\n {\n   unsigned HOST_WIDE_INT n_iterations = LOOP_INFO (loop)->n_iterations;\n   rtx increment, tem;\n@@ -3040,9 +3005,7 @@ final_biv_value (loop, bl)\n    the end of the loop.  If we can do it, return that value.  */\n \n rtx\n-final_giv_value (loop, v)\n-     const struct loop *loop;\n-     struct induction *v;\n+final_giv_value (const struct loop *loop, struct induction *v)\n {\n   struct loop_ivs *ivs = LOOP_IVS (loop);\n   struct iv_class *bl;\n@@ -3169,9 +3132,7 @@ final_giv_value (loop, v)\n    the SET_SRC of REG.  */\n \n static rtx\n-loop_find_equiv_value (loop, reg)\n-     const struct loop *loop;\n-     rtx reg;\n+loop_find_equiv_value (const struct loop *loop, rtx reg)\n {\n   rtx loop_start = loop->start;\n   rtx insn, set;\n@@ -3224,8 +3185,7 @@ loop_find_equiv_value (loop, reg)\n    the proper form.  */\n \n static rtx\n-subtract_reg_term (op, reg)\n-     rtx op, reg;\n+subtract_reg_term (rtx op, rtx reg)\n {\n   if (op == reg)\n     return const0_rtx;\n@@ -3245,8 +3205,7 @@ subtract_reg_term (op, reg)\n    REG or a PLUS of a REG.  */\n \n static rtx\n-find_common_reg_term (op0, op1)\n-     rtx op0, op1;\n+find_common_reg_term (rtx op0, rtx op1)\n {\n   if ((GET_CODE (op0) == REG || GET_CODE (op0) == PLUS)\n       && (GET_CODE (op1) == REG || GET_CODE (op1) == PLUS))\n@@ -3282,8 +3241,7 @@ find_common_reg_term (op0, op1)\n    be calculated, otherwise returns zero.  */\n \n unsigned HOST_WIDE_INT\n-loop_iterations (loop)\n-     struct loop *loop;\n+loop_iterations (struct loop *loop)\n {\n   struct loop_info *loop_info = LOOP_INFO (loop);\n   struct loop_ivs *ivs = LOOP_IVS (loop);\n@@ -3911,9 +3869,7 @@ loop_iterations (loop)\n    copying.  */\n \n static rtx\n-remap_split_bivs (loop, x)\n-     struct loop *loop;\n-     rtx x;\n+remap_split_bivs (struct loop *loop, rtx x)\n {\n   struct loop_ivs *ivs = LOOP_IVS (loop);\n   enum rtx_code code;\n@@ -3981,12 +3937,8 @@ remap_split_bivs (loop, x)\n    must dominate LAST_UID.  */\n \n int\n-set_dominates_use (regno, first_uid, last_uid, copy_start, copy_end)\n-     int regno;\n-     int first_uid;\n-     int last_uid;\n-     rtx copy_start;\n-     rtx copy_end;\n+set_dominates_use (int regno, int first_uid, int last_uid, rtx copy_start,\n+\t\t   rtx copy_end)\n {\n   int passed_jump = 0;\n   rtx p = NEXT_INSN (copy_start);\n@@ -4033,9 +3985,7 @@ set_dominates_use (regno, first_uid, last_uid, copy_start, copy_end)\n    deleted so that we execute the single iteration.  */\n \n static rtx\n-ujump_to_loop_cont (loop_start, loop_cont)\n-     rtx loop_start;\n-     rtx loop_cont;\n+ujump_to_loop_cont (rtx loop_start, rtx loop_cont)\n {\n   rtx x, label, label_ref;\n "}, {"sha": "5769dc87c81651d93a4fee7c3d18db7d1086cb41", "filename": "gcc/varasm.c", "status": "modified", "additions": 200, "deletions": 392, "changes": 592, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e1eedd6bb7d1e6358847d0ab912f13aa69ef403/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e1eedd6bb7d1e6358847d0ab912f13aa69ef403/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=2e1eedd6bb7d1e6358847d0ab912f13aa69ef403", "patch": "@@ -140,51 +140,48 @@ tree last_assemble_variable_decl;\n \n static HOST_WIDE_INT const_alias_set;\n \n-static const char *strip_reg_name\tPARAMS ((const char *));\n-static int contains_pointers_p\t\tPARAMS ((tree));\n-static void decode_addr_const\t\tPARAMS ((tree, struct addr_const *));\n-static hashval_t const_desc_hash\tPARAMS ((const void *));\n-static int const_desc_eq\t\tPARAMS ((const void *, const void *));\n-static hashval_t const_hash_1\t\tPARAMS ((const tree));\n-static int compare_constant\t\tPARAMS ((const tree, const tree));\n-static tree copy_constant\t\tPARAMS ((tree));\n-static void output_constant_def_contents  PARAMS ((rtx));\n-static void decode_rtx_const\t\tPARAMS ((enum machine_mode, rtx,\n-\t\t\t\t\t       struct rtx_const *));\n-static unsigned int const_hash_rtx\tPARAMS ((enum machine_mode, rtx));\n-static int compare_constant_rtx\n-  PARAMS ((enum machine_mode, rtx, struct constant_descriptor_rtx *));\n+static const char *strip_reg_name (const char *);\n+static int contains_pointers_p (tree);\n+static void decode_addr_const (tree, struct addr_const *);\n+static hashval_t const_desc_hash (const void *);\n+static int const_desc_eq (const void *, const void *);\n+static hashval_t const_hash_1 (const tree);\n+static int compare_constant (const tree, const tree);\n+static tree copy_constant (tree);\n+static void output_constant_def_contents (rtx);\n+static void decode_rtx_const (enum machine_mode, rtx, struct rtx_const *);\n+static unsigned int const_hash_rtx (enum machine_mode, rtx);\n+static int compare_constant_rtx (enum machine_mode, rtx,\n+\t\t\t\t struct constant_descriptor_rtx *);\n static struct constant_descriptor_rtx * record_constant_rtx\n-  PARAMS ((enum machine_mode, rtx));\n-static struct pool_constant *find_pool_constant PARAMS ((struct function *, rtx));\n-static void mark_constant_pool\t\tPARAMS ((void));\n-static void mark_constants\t\tPARAMS ((rtx));\n-static int mark_constant\t\tPARAMS ((rtx *current_rtx, void *data));\n-static int output_addressed_constants\tPARAMS ((tree));\n-static unsigned HOST_WIDE_INT array_size_for_constructor PARAMS ((tree));\n-static unsigned min_align\t\tPARAMS ((unsigned, unsigned));\n-static void output_constructor\t\tPARAMS ((tree, unsigned HOST_WIDE_INT,\n-\t\t\t\t\t\t unsigned int));\n-static void globalize_decl\t\tPARAMS ((tree));\n-static void maybe_assemble_visibility\tPARAMS ((tree));\n-static int in_named_entry_eq\t\tPARAMS ((const void *, const void *));\n-static hashval_t in_named_entry_hash\tPARAMS ((const void *));\n+  (enum machine_mode, rtx);\n+static struct pool_constant *find_pool_constant (struct function *, rtx);\n+static void mark_constant_pool (void);\n+static void mark_constants (rtx);\n+static int mark_constant (rtx *current_rtx, void *data);\n+static int output_addressed_constants (tree);\n+static unsigned HOST_WIDE_INT array_size_for_constructor (tree);\n+static unsigned min_align (unsigned, unsigned);\n+static void output_constructor (tree, unsigned HOST_WIDE_INT, unsigned int);\n+static void globalize_decl (tree);\n+static void maybe_assemble_visibility (tree);\n+static int in_named_entry_eq (const void *, const void *);\n+static hashval_t in_named_entry_hash (const void *);\n #ifdef ASM_OUTPUT_BSS\n-static void asm_output_bss\t\tPARAMS ((FILE *, tree, const char *,\n-\t\t\t\t\t\tunsigned HOST_WIDE_INT,\n-\t\t\t\t\t\tunsigned HOST_WIDE_INT));\n+static void asm_output_bss (FILE *, tree, const char *,\n+\t\t\t    unsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT);\n #endif\n #ifdef BSS_SECTION_ASM_OP\n #ifdef ASM_OUTPUT_ALIGNED_BSS\n-static void asm_output_aligned_bss\n-  PARAMS ((FILE *, tree, const char *,\n-\t   unsigned HOST_WIDE_INT, int)) ATTRIBUTE_UNUSED;\n+static void asm_output_aligned_bss (FILE *, tree, const char *,\n+\t\t\t\t    unsigned HOST_WIDE_INT, int)\n+     ATTRIBUTE_UNUSED;\n #endif\n #endif /* BSS_SECTION_ASM_OP */\n-static bool asm_emit_uninitialised\tPARAMS ((tree, const char*,\n-\t\t\t\t\t\t unsigned HOST_WIDE_INT,\n-\t\t\t\t\t\t unsigned HOST_WIDE_INT));\n-static void mark_weak                   PARAMS ((tree));\n+static bool asm_emit_uninitialised (tree, const char*,\n+\t\t\t\t    unsigned HOST_WIDE_INT,\n+\t\t\t\t    unsigned HOST_WIDE_INT);\n+static void mark_weak (tree);\n \f\n enum in_section { no_section, in_text, in_data, in_named\n #ifdef BSS_SECTION_ASM_OP\n@@ -234,7 +231,7 @@ EXTRA_SECTION_FUNCTIONS\n /* Tell assembler to switch to text section.  */\n \n void\n-text_section ()\n+text_section (void)\n {\n   if (in_section != in_text)\n     {\n@@ -250,7 +247,7 @@ text_section ()\n /* Tell assembler to switch to data section.  */\n \n void\n-data_section ()\n+data_section (void)\n {\n   if (in_section != in_data)\n     {\n@@ -272,7 +269,7 @@ data_section ()\n    the text section.  */\n \n void\n-readonly_data_section ()\n+readonly_data_section (void)\n {\n #ifdef READONLY_DATA_SECTION\n   READONLY_DATA_SECTION ();  /* Note this can call data_section.  */\n@@ -293,25 +290,23 @@ readonly_data_section ()\n /* Determine if we're in the text section.  */\n \n int\n-in_text_section ()\n+in_text_section (void)\n {\n   return in_section == in_text;\n }\n \n /* Determine if we're in the data section.  */\n \n int\n-in_data_section ()\n+in_data_section (void)\n {\n   return in_section == in_data;\n }\n \n /* Helper routines for maintaining in_named_htab.  */\n \n static int\n-in_named_entry_eq (p1, p2)\n-     const void *p1;\n-     const void *p2;\n+in_named_entry_eq (const void *p1, const void *p2)\n {\n   const struct in_named_entry *old = p1;\n   const char *new = p2;\n@@ -320,8 +315,7 @@ in_named_entry_eq (p1, p2)\n }\n \n static hashval_t\n-in_named_entry_hash (p)\n-     const void *p;\n+in_named_entry_hash (const void *p)\n {\n   const struct in_named_entry *old = p;\n   return htab_hash_string (old->name);\n@@ -333,8 +327,7 @@ in_named_entry_hash (p)\n    has not been seen.  */\n \n unsigned int\n-get_named_section_flags (section)\n-     const char *section;\n+get_named_section_flags (const char *section)\n {\n   struct in_named_entry **slot;\n \n@@ -350,8 +343,7 @@ get_named_section_flags (section)\n    section will return false.  */\n \n bool\n-named_section_first_declaration (name)\n-     const char *name;\n+named_section_first_declaration (const char *name)\n {\n   struct in_named_entry **slot;\n \n@@ -374,9 +366,7 @@ named_section_first_declaration (name)\n    different set of flags, return false.  */\n \n bool\n-set_named_section_flags (section, flags)\n-     const char *section;\n-     unsigned int flags;\n+set_named_section_flags (const char *section, unsigned int flags)\n {\n   struct in_named_entry **slot, *entry;\n \n@@ -402,9 +392,7 @@ set_named_section_flags (section, flags)\n /* Tell assembler to change to section NAME with attributes FLAGS.  */\n \n void\n-named_section_flags (name, flags)\n-     const char *name;\n-     unsigned int flags;\n+named_section_flags (const char *name, unsigned int flags)\n {\n   if (in_section != in_named || strcmp (name, in_named_name) != 0)\n     {\n@@ -429,10 +417,7 @@ named_section_flags (name, flags)\n    If RELOC is 1, the initializer for DECL contains relocs.  */\n \n void\n-named_section (decl, name, reloc)\n-     tree decl;\n-     const char *name;\n-     int reloc;\n+named_section (tree decl, const char *name, int reloc)\n {\n   unsigned int flags;\n \n@@ -461,10 +446,8 @@ named_section (decl, name, reloc)\n /* If required, set DECL_SECTION_NAME to a unique name.  */\n \n void\n-resolve_unique_section (decl, reloc, flag_function_or_data_sections)\n-     tree decl;\n-     int reloc ATTRIBUTE_UNUSED;\n-     int flag_function_or_data_sections;\n+resolve_unique_section (tree decl, int reloc ATTRIBUTE_UNUSED,\n+\t\t\tint flag_function_or_data_sections)\n {\n   if (DECL_SECTION_NAME (decl) == NULL_TREE\n       && targetm.have_named_sections\n@@ -478,7 +461,7 @@ resolve_unique_section (decl, reloc, flag_function_or_data_sections)\n /* Tell the assembler to switch to the bss section.  */\n \n void\n-bss_section ()\n+bss_section (void)\n {\n   if (in_section != in_bss)\n     {\n@@ -501,11 +484,10 @@ bss_section ()\n    support is localized here.  */\n \n static void\n-asm_output_bss (file, decl, name, size, rounded)\n-     FILE *file;\n-     tree decl ATTRIBUTE_UNUSED;\n-     const char *name;\n-     unsigned HOST_WIDE_INT size ATTRIBUTE_UNUSED, rounded;\n+asm_output_bss (FILE *file, tree decl ATTRIBUTE_UNUSED,\n+\t\tconst char *name,\n+\t\tunsigned HOST_WIDE_INT size ATTRIBUTE_UNUSED,\n+\t\tunsigned HOST_WIDE_INT rounded)\n {\n   (*targetm.asm_out.globalize_label) (file, name);\n   bss_section ();\n@@ -529,12 +511,9 @@ asm_output_bss (file, decl, name, size, rounded)\n    support is localized here.  */\n \n static void\n-asm_output_aligned_bss (file, decl, name, size, align)\n-     FILE *file;\n-     tree decl ATTRIBUTE_UNUSED;\n-     const char *name;\n-     unsigned HOST_WIDE_INT size;\n-     int align;\n+asm_output_aligned_bss (FILE *file, tree decl ATTRIBUTE_UNUSED,\n+\t\t\tconst char *name, unsigned HOST_WIDE_INT size,\n+\t\t\tint align)\n {\n   bss_section ();\n   ASM_OUTPUT_ALIGN (file, floor_log2 (align / BITS_PER_UNIT));\n@@ -559,8 +538,7 @@ asm_output_aligned_bss (file, decl, name, size, align)\n    safer to handle it.  */\n \n void\n-function_section (decl)\n-     tree decl;\n+function_section (tree decl)\n {\n   if (decl != NULL_TREE\n       && DECL_SECTION_NAME (decl) != NULL_TREE)\n@@ -573,9 +551,7 @@ function_section (decl)\n    argument to SELECT_SECTION.  */\n \n void\n-variable_section (decl, reloc)\n-     tree decl;\n-     int reloc;\n+variable_section (tree decl, int reloc)\n {\n   if (IN_NAMED_SECTION (decl))\n     named_section (decl, NULL, reloc);\n@@ -586,10 +562,9 @@ variable_section (decl, reloc)\n /* Tell assembler to switch to the section for string merging.  */\n \n void\n-mergeable_string_section (decl, align, flags)\n-     tree decl ATTRIBUTE_UNUSED;\n-     unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED;\n-     unsigned int flags ATTRIBUTE_UNUSED;\n+mergeable_string_section (tree decl ATTRIBUTE_UNUSED,\n+\t\t\t  unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED,\n+\t\t\t  unsigned int flags ATTRIBUTE_UNUSED)\n {\n #ifdef HAVE_GAS_SHF_MERGE\n   if (flag_merge_constants\n@@ -661,10 +636,9 @@ mergeable_string_section (decl, align, flags)\n /* Tell assembler to switch to the section for constant merging.  */\n \n void\n-mergeable_constant_section (mode, align, flags)\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED;\n-     unsigned int flags ATTRIBUTE_UNUSED;\n+mergeable_constant_section (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t    unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED,\n+\t\t\t    unsigned int flags ATTRIBUTE_UNUSED)\n {\n #ifdef HAVE_GAS_SHF_MERGE\n   unsigned int modesize = GET_MODE_BITSIZE (mode);\n@@ -691,8 +665,7 @@ mergeable_constant_section (mode, align, flags)\n /* Given NAME, a putative register name, discard any customary prefixes.  */\n \n static const char *\n-strip_reg_name (name)\n-     const char *name;\n+strip_reg_name (const char *name)\n {\n #ifdef REGISTER_PREFIX\n   if (!strncmp (name, REGISTER_PREFIX, strlen (REGISTER_PREFIX)))\n@@ -712,8 +685,7 @@ strip_reg_name (name)\n    Prefixes such as % are optional.  */\n \n int\n-decode_reg_name (asmspec)\n-     const char *asmspec;\n+decode_reg_name (const char *asmspec)\n {\n   if (asmspec != 0)\n     {\n@@ -776,9 +748,7 @@ decode_reg_name (asmspec)\n    This is never called for PARM_DECL nodes.  */\n \n void\n-make_decl_rtl (decl, asmspec)\n-     tree decl;\n-     const char *asmspec;\n+make_decl_rtl (tree decl, const char *asmspec)\n {\n   int top_level = (DECL_CONTEXT (decl) == NULL_TREE);\n   const char *name = 0;\n@@ -931,7 +901,7 @@ make_decl_rtl (decl, asmspec)\n   x = gen_rtx_SYMBOL_REF (Pmode, name);\n   SYMBOL_REF_WEAK (x) = DECL_WEAK (decl);\n   SYMBOL_REF_DECL (x) = decl;\n-  \n+\n   x = gen_rtx_MEM (DECL_MODE (decl), x);\n   if (TREE_CODE (decl) != FUNCTION_DECL)\n     set_mem_attributes (x, decl, 1);\n@@ -948,8 +918,7 @@ make_decl_rtl (decl, asmspec)\n    Use this only for static variables.  */\n \n void\n-make_var_volatile (var)\n-     tree var;\n+make_var_volatile (tree var)\n {\n   if (GET_CODE (DECL_RTL (var)) != MEM)\n     abort ();\n@@ -961,8 +930,7 @@ make_var_volatile (var)\n    for an `asm' keyword used between functions.  */\n \n void\n-assemble_asm (string)\n-     tree string;\n+assemble_asm (tree string)\n {\n   app_enable ();\n \n@@ -977,9 +945,7 @@ assemble_asm (string)\n    between 0 and MAX_INIT_PRIORITY.  */\n \n void\n-default_stabs_asm_out_destructor (symbol, priority)\n-     rtx symbol;\n-     int priority ATTRIBUTE_UNUSED;\n+default_stabs_asm_out_destructor (rtx symbol, int priority ATTRIBUTE_UNUSED)\n {\n   /* Tell GNU LD that this is part of the static destructor set.\n      This will work for any system that uses stabs, most usefully\n@@ -990,9 +956,7 @@ default_stabs_asm_out_destructor (symbol, priority)\n }\n \n void\n-default_named_section_asm_out_destructor (symbol, priority)\n-     rtx symbol;\n-     int priority;\n+default_named_section_asm_out_destructor (rtx symbol, int priority)\n {\n   const char *section = \".dtors\";\n   char buf[16];\n@@ -1015,7 +979,7 @@ default_named_section_asm_out_destructor (symbol, priority)\n \n #ifdef DTORS_SECTION_ASM_OP\n void\n-dtors_section ()\n+dtors_section (void)\n {\n   if (in_section != in_dtors)\n     {\n@@ -1026,9 +990,8 @@ dtors_section ()\n }\n \n void\n-default_dtor_section_asm_out_destructor (symbol, priority)\n-     rtx symbol;\n-     int priority ATTRIBUTE_UNUSED;\n+default_dtor_section_asm_out_destructor (rtx symbol,\n+\t\t\t\t\t int priority ATTRIBUTE_UNUSED)\n {\n   dtors_section ();\n   assemble_align (POINTER_SIZE);\n@@ -1039,9 +1002,7 @@ default_dtor_section_asm_out_destructor (symbol, priority)\n /* Likewise for global constructors.  */\n \n void\n-default_stabs_asm_out_constructor (symbol, priority)\n-     rtx symbol;\n-     int priority ATTRIBUTE_UNUSED;\n+default_stabs_asm_out_constructor (rtx symbol, int priority ATTRIBUTE_UNUSED)\n {\n   /* Tell GNU LD that this is part of the static destructor set.\n      This will work for any system that uses stabs, most usefully\n@@ -1052,9 +1013,7 @@ default_stabs_asm_out_constructor (symbol, priority)\n }\n \n void\n-default_named_section_asm_out_constructor (symbol, priority)\n-     rtx symbol;\n-     int priority;\n+default_named_section_asm_out_constructor (rtx symbol, int priority)\n {\n   const char *section = \".ctors\";\n   char buf[16];\n@@ -1077,7 +1036,7 @@ default_named_section_asm_out_constructor (symbol, priority)\n \n #ifdef CTORS_SECTION_ASM_OP\n void\n-ctors_section ()\n+ctors_section (void)\n {\n   if (in_section != in_ctors)\n     {\n@@ -1088,9 +1047,8 @@ ctors_section ()\n }\n \n void\n-default_ctor_section_asm_out_constructor (symbol, priority)\n-     rtx symbol;\n-     int priority ATTRIBUTE_UNUSED;\n+default_ctor_section_asm_out_constructor (rtx symbol,\n+\t\t\t\t\t  int priority ATTRIBUTE_UNUSED)\n {\n   ctors_section ();\n   assemble_align (POINTER_SIZE);\n@@ -1114,9 +1072,7 @@ default_ctor_section_asm_out_constructor (symbol, priority)\n    constant pool data.  */\n \n void\n-assemble_start_function (decl, fnname)\n-     tree decl;\n-     const char *fnname;\n+assemble_start_function (tree decl, const char *fnname)\n {\n   int align;\n \n@@ -1195,9 +1151,7 @@ assemble_start_function (decl, fnname)\n    function.  DECL describes the function.  NAME is the function's name.  */\n \n void\n-assemble_end_function (decl, fnname)\n-     tree decl;\n-     const char *fnname;\n+assemble_end_function (tree decl, const char *fnname)\n {\n #ifdef ASM_DECLARE_FUNCTION_SIZE\n   ASM_DECLARE_FUNCTION_SIZE (asm_out_file, fnname, decl);\n@@ -1212,8 +1166,7 @@ assemble_end_function (decl, fnname)\n /* Assemble code to leave SIZE bytes of zeros.  */\n \n void\n-assemble_zeros (size)\n-     unsigned HOST_WIDE_INT size;\n+assemble_zeros (unsigned HOST_WIDE_INT size)\n {\n   /* Do no output if -fsyntax-only.  */\n   if (flag_syntax_only)\n@@ -1237,8 +1190,7 @@ assemble_zeros (size)\n /* Assemble an alignment pseudo op for an ALIGN-bit boundary.  */\n \n void\n-assemble_align (align)\n-     int align;\n+assemble_align (int align)\n {\n   if (align > BITS_PER_UNIT)\n     {\n@@ -1249,9 +1201,7 @@ assemble_align (align)\n /* Assemble a string constant with the specified C string as contents.  */\n \n void\n-assemble_string (p, size)\n-     const char *p;\n-     int size;\n+assemble_string (const char *p, int size)\n {\n   int pos = 0;\n   int maximum = 2000;\n@@ -1311,11 +1261,9 @@ assemble_string (p, size)\n #endif\n \n static bool\n-asm_emit_uninitialised (decl, name, size, rounded)\n-     tree decl;\n-     const char *name;\n-     unsigned HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n-     unsigned HOST_WIDE_INT rounded ATTRIBUTE_UNUSED;\n+asm_emit_uninitialised (tree decl, const char *name,\n+\t\t\tunsigned HOST_WIDE_INT size ATTRIBUTE_UNUSED,\n+\t\t\tunsigned HOST_WIDE_INT rounded ATTRIBUTE_UNUSED)\n {\n   enum\n   {\n@@ -1398,11 +1346,8 @@ asm_emit_uninitialised (decl, name, size, rounded)\n    initial value (that will be done by the caller).  */\n \n void\n-assemble_variable (decl, top_level, at_end, dont_output_data)\n-     tree decl;\n-     int top_level ATTRIBUTE_UNUSED;\n-     int at_end ATTRIBUTE_UNUSED;\n-     int dont_output_data;\n+assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n+\t\t   int at_end ATTRIBUTE_UNUSED, int dont_output_data)\n {\n   const char *name;\n   unsigned int align;\n@@ -1638,8 +1583,7 @@ assemble_variable (decl, top_level, at_end, dont_output_data)\n /* Return 1 if type TYPE contains any pointers.  */\n \n static int\n-contains_pointers_p (type)\n-     tree type;\n+contains_pointers_p (tree type)\n {\n   switch (TREE_CODE (type))\n     {\n@@ -1677,8 +1621,7 @@ contains_pointers_p (type)\n    Do nothing if DECL is not external.  */\n \n void\n-assemble_external (decl)\n-     tree decl ATTRIBUTE_UNUSED;\n+assemble_external (tree decl ATTRIBUTE_UNUSED)\n {\n   /* Because most platforms do not define ASM_OUTPUT_EXTERNAL, the\n      main body of this code is only rarely exercised.  To provide some\n@@ -1706,8 +1649,7 @@ assemble_external (decl)\n /* Similar, for calling a library function FUN.  */\n \n void\n-assemble_external_libcall (fun)\n-     rtx fun ATTRIBUTE_UNUSED;\n+assemble_external_libcall (rtx fun ATTRIBUTE_UNUSED)\n {\n #ifdef ASM_OUTPUT_EXTERNAL_LIBCALL\n   /* Declare library function name external when first used, if nec.  */\n@@ -1722,16 +1664,14 @@ assemble_external_libcall (fun)\n /* Assemble a label named NAME.  */\n \n void\n-assemble_label (name)\n-     const char *name;\n+assemble_label (const char *name)\n {\n   ASM_OUTPUT_LABEL (asm_out_file, name);\n }\n \n /* Set the symbol_referenced flag for ID and notify callgraph code.  */\n void\n-mark_referenced (id)\n-     tree id;\n+mark_referenced (tree id)\n {\n   if (!TREE_SYMBOL_REFERENCED (id))\n     {\n@@ -1759,9 +1699,7 @@ mark_referenced (id)\n    Many macros in the tm file are defined to call this function.  */\n \n void\n-assemble_name (file, name)\n-     FILE *file;\n-     const char *name;\n+assemble_name (FILE *file, const char *name)\n {\n   const char *real_name;\n   tree id;\n@@ -1782,8 +1720,7 @@ assemble_name (file, name)\n    and return an RTX to refer to its address.  */\n \n rtx\n-assemble_static_space (size)\n-     unsigned HOST_WIDE_INT size;\n+assemble_static_space (unsigned HOST_WIDE_INT size)\n {\n   char name[12];\n   const char *namestring;\n@@ -1829,7 +1766,7 @@ assemble_static_space (size)\n \n #ifdef TRAMPOLINE_TEMPLATE\n rtx\n-assemble_trampoline_template ()\n+assemble_trampoline_template (void)\n {\n   char label[256];\n   const char *name;\n@@ -1868,8 +1805,7 @@ assemble_trampoline_template ()\n    that may be assumed after adding the two together.  */\n \n static inline unsigned\n-min_align (a, b)\n-     unsigned int a, b;\n+min_align (unsigned int a, unsigned int b)\n {\n   return (a | b) & -(a | b);\n }\n@@ -1883,9 +1819,7 @@ min_align (a, b)\n    be followed immediately by the object's initial value.  */\n \n const char *\n-integer_asm_op (size, aligned_p)\n-     int size;\n-     int aligned_p;\n+integer_asm_op (int size, int aligned_p)\n {\n   struct asm_int_op *ops;\n \n@@ -1915,9 +1849,7 @@ integer_asm_op (size, aligned_p)\n    start of the line, followed immediately by the value of X.  */\n \n void\n-assemble_integer_with_op (op, x)\n-     const char *op;\n-     rtx x;\n+assemble_integer_with_op (const char *op, rtx x)\n {\n   fputs (op, asm_out_file);\n   output_addr_const (asm_out_file, x);\n@@ -1927,10 +1859,9 @@ assemble_integer_with_op (op, x)\n /* The default implementation of the asm_out.integer target hook.  */\n \n bool\n-default_assemble_integer (x, size, aligned_p)\n-     rtx x ATTRIBUTE_UNUSED;\n-     unsigned int size ATTRIBUTE_UNUSED;\n-     int aligned_p ATTRIBUTE_UNUSED;\n+default_assemble_integer (rtx x ATTRIBUTE_UNUSED,\n+\t\t\t  unsigned int size ATTRIBUTE_UNUSED,\n+\t\t\t  int aligned_p ATTRIBUTE_UNUSED)\n {\n   const char *op = integer_asm_op (size, aligned_p);\n   return op && (assemble_integer_with_op (op, x), true);\n@@ -1942,11 +1873,7 @@ default_assemble_integer (x, size, aligned_p)\n    the constant.  */\n \n bool\n-assemble_integer (x, size, align, force)\n-     rtx x;\n-     unsigned int size;\n-     unsigned int align;\n-     int force;\n+assemble_integer (rtx x, unsigned int size, unsigned int align, int force)\n {\n   int aligned_p;\n \n@@ -1991,10 +1918,7 @@ assemble_integer (x, size, align, force)\n }\n \f\n void\n-assemble_real (d, mode, align)\n-     REAL_VALUE_TYPE d;\n-     enum machine_mode mode;\n-     unsigned int align;\n+assemble_real (REAL_VALUE_TYPE d, enum machine_mode mode, unsigned int align)\n {\n   long data[4];\n   long l;\n@@ -2083,9 +2007,7 @@ struct addr_const GTY(())\n };\n \n static void\n-decode_addr_const (exp, value)\n-     tree exp;\n-     struct addr_const *value;\n+decode_addr_const (tree exp, struct addr_const *value)\n {\n   tree target = TREE_OPERAND (exp, 0);\n   int offset = 0;\n@@ -2189,22 +2111,19 @@ struct constant_descriptor_tree GTY(())\n static GTY((param_is (struct constant_descriptor_tree)))\n      htab_t const_desc_htab;\n \n-static struct constant_descriptor_tree * build_constant_desc PARAMS ((tree));\n-static void maybe_output_constant_def_contents\n-    PARAMS ((struct constant_descriptor_tree *, int));\n+static struct constant_descriptor_tree * build_constant_desc (tree);\n+static void maybe_output_constant_def_contents (struct constant_descriptor_tree *, int);\n \n /* Compute a hash code for a constant expression.  */\n \n static hashval_t\n-const_desc_hash (ptr)\n-     const void *ptr;\n+const_desc_hash (const void *ptr)\n {\n   return const_hash_1 (((struct constant_descriptor_tree *)ptr)->value);\n }\n \n static hashval_t\n-const_hash_1 (exp)\n-     const tree exp;\n+const_hash_1 (const tree exp)\n {\n   const char *p;\n   hashval_t hi;\n@@ -2303,9 +2222,7 @@ const_hash_1 (exp)\n \n /* Wrapper of compare_constant, for the htab interface.  */\n static int\n-const_desc_eq (p1, p2)\n-     const void *p1;\n-     const void *p2;\n+const_desc_eq (const void *p1, const void *p2)\n {\n   return compare_constant (((struct constant_descriptor_tree *)p1)->value,\n \t\t\t   ((struct constant_descriptor_tree *)p2)->value);\n@@ -2315,9 +2232,7 @@ const_desc_eq (p1, p2)\n    the same bit pattern on output.  */\n \n static int\n-compare_constant (t1, t2)\n-     const tree t1;\n-     const tree t2;\n+compare_constant (const tree t1, const tree t2)\n {\n   enum tree_code typecode;\n \n@@ -2469,8 +2384,7 @@ compare_constant (t1, t2)\n    handles the same types of nodes that compare_constant handles.  */\n \n static tree\n-copy_constant (exp)\n-     tree exp;\n+copy_constant (tree exp)\n {\n   switch (TREE_CODE (exp))\n     {\n@@ -2542,8 +2456,7 @@ copy_constant (exp)\n    Caller is responsible for updating the hash table.  */\n \n static struct constant_descriptor_tree *\n-build_constant_desc (exp)\n-     tree exp;\n+build_constant_desc (tree exp)\n {\n   rtx symbol;\n   rtx rtl;\n@@ -2596,9 +2509,7 @@ build_constant_desc (exp)\n    The const_hash_table records which constants already have label strings.  */\n \n rtx\n-output_constant_def (exp, defer)\n-     tree exp;\n-     int defer;\n+output_constant_def (tree exp, int defer)\n {\n   struct constant_descriptor_tree *desc;\n   struct constant_descriptor_tree key;\n@@ -2623,9 +2534,8 @@ output_constant_def (exp, defer)\n /* Subroutine of output_constant_def: Decide whether or not we need to\n    output the constant DESC now, and if so, do it.  */\n static void\n-maybe_output_constant_def_contents (desc, defer)\n-     struct constant_descriptor_tree *desc;\n-     int defer;\n+maybe_output_constant_def_contents (struct constant_descriptor_tree *desc,\n+\t\t\t\t    int defer)\n {\n   rtx symbol = XEXP (desc->rtl, 0);\n   tree exp = desc->value;\n@@ -2657,8 +2567,7 @@ maybe_output_constant_def_contents (desc, defer)\n /* We must output the constant data referred to by SYMBOL; do so.  */\n \n static void\n-output_constant_def_contents (symbol)\n-     rtx symbol;\n+output_constant_def_contents (rtx symbol)\n {\n   tree exp = SYMBOL_REF_DECL (symbol);\n   const char *label = XSTR (symbol, 0);\n@@ -2703,7 +2612,7 @@ output_constant_def_contents (symbol)\n    inserted by the RTL inliner into a different function.  The\n    current function's deferred constant count must be incremented.  */\n void\n-notice_rtl_inlining_of_deferred_constant ()\n+notice_rtl_inlining_of_deferred_constant (void)\n {\n   n_deferred_constants++;\n }\n@@ -2751,8 +2660,7 @@ struct pool_constant GTY(())\n /* Initialize constant pool hashing for a new function.  */\n \n void\n-init_varasm_status (f)\n-     struct function *f;\n+init_varasm_status (struct function *f)\n {\n   struct varasm_status *p;\n   p = (struct varasm_status *) ggc_alloc (sizeof (struct varasm_status));\n@@ -2777,10 +2685,7 @@ init_varasm_status (f)\n    They are stored into VALUE.  */\n \n static void\n-decode_rtx_const (mode, x, value)\n-     enum machine_mode mode;\n-     rtx x;\n-     struct rtx_const *value;\n+decode_rtx_const (enum machine_mode mode, rtx x, struct rtx_const *value)\n {\n   /* Clear the whole structure, including any gaps.  */\n   memset (value, 0, sizeof (struct rtx_const));\n@@ -2958,8 +2863,7 @@ decode_rtx_const (mode, x, value)\n    include the same symbol.  */\n \n rtx\n-simplify_subtraction (x)\n-     rtx x;\n+simplify_subtraction (rtx x)\n {\n   struct rtx_const val0, val1;\n \n@@ -2978,9 +2882,7 @@ simplify_subtraction (x)\n /* Compute a hash code for a constant RTL expression.  */\n \n static unsigned int\n-const_hash_rtx (mode, x)\n-     enum machine_mode mode;\n-     rtx x;\n+const_hash_rtx (enum machine_mode mode, rtx x)\n {\n   union {\n     struct rtx_const value;\n@@ -3004,10 +2906,8 @@ const_hash_rtx (mode, x)\n    Return 1 if DESC describes a constant with the same value as X.  */\n \n static int\n-compare_constant_rtx (mode, x, desc)\n-     enum machine_mode mode;\n-     rtx x;\n-     struct constant_descriptor_rtx *desc;\n+compare_constant_rtx (enum machine_mode mode, rtx x,\n+\t\t      struct constant_descriptor_rtx *desc)\n {\n   struct rtx_const value;\n \n@@ -3021,9 +2921,7 @@ compare_constant_rtx (mode, x, desc)\n    It is up to the caller to enter the descriptor in the hash table.  */\n \n static struct constant_descriptor_rtx *\n-record_constant_rtx (mode, x)\n-     enum machine_mode mode;\n-     rtx x;\n+record_constant_rtx (enum machine_mode mode, rtx x)\n {\n   struct constant_descriptor_rtx *ptr;\n \n@@ -3037,8 +2935,7 @@ record_constant_rtx (mode, x)\n    this constant has been placed.  Return 0 if it not has been placed yet.  */\n \n rtx\n-mem_for_const_double (x)\n-     rtx x;\n+mem_for_const_double (rtx x)\n {\n   enum machine_mode mode = GET_MODE (x);\n   struct constant_descriptor_rtx *desc;\n@@ -3055,9 +2952,7 @@ mem_for_const_double (x)\n    and return a MEM rtx to refer to it in memory.  */\n \n rtx\n-force_const_mem (mode, x)\n-     enum machine_mode mode;\n-     rtx x;\n+force_const_mem (enum machine_mode mode, rtx x)\n {\n   int hash;\n   struct constant_descriptor_rtx *desc;\n@@ -3150,9 +3045,7 @@ force_const_mem (mode, x)\n    the corresponding pool_constant structure.  */\n \n static struct pool_constant *\n-find_pool_constant (f, addr)\n-     struct function *f;\n-     rtx addr;\n+find_pool_constant (struct function *f, rtx addr)\n {\n   struct pool_constant *pool;\n   const char *label = XSTR (addr, 0);\n@@ -3168,8 +3061,7 @@ find_pool_constant (f, addr)\n /* Given a constant pool SYMBOL_REF, return the corresponding constant.  */\n \n rtx\n-get_pool_constant (addr)\n-     rtx addr;\n+get_pool_constant (rtx addr)\n {\n   return (find_pool_constant (cfun, addr))->constant;\n }\n@@ -3178,9 +3070,7 @@ get_pool_constant (addr)\n    and whether it has been output or not.  */\n \n rtx\n-get_pool_constant_mark (addr, pmarked)\n-     rtx addr;\n-     bool *pmarked;\n+get_pool_constant_mark (rtx addr, bool *pmarked)\n {\n   struct pool_constant *pool = find_pool_constant (cfun, addr);\n   *pmarked = (pool->mark != 0);\n@@ -3190,53 +3080,46 @@ get_pool_constant_mark (addr, pmarked)\n /* Likewise, but for the constant pool of a specific function.  */\n \n rtx\n-get_pool_constant_for_function (f, addr)\n-     struct function *f;\n-     rtx addr;\n+get_pool_constant_for_function (struct function *f, rtx addr)\n {\n   return (find_pool_constant (f, addr))->constant;\n }\n \n /* Similar, return the mode.  */\n \n enum machine_mode\n-get_pool_mode (addr)\n-     rtx addr;\n+get_pool_mode (rtx addr)\n {\n   return (find_pool_constant (cfun, addr))->mode;\n }\n \n enum machine_mode\n-get_pool_mode_for_function (f, addr)\n-     struct function *f;\n-     rtx addr;\n+get_pool_mode_for_function (struct function *f, rtx addr)\n {\n   return (find_pool_constant (f, addr))->mode;\n }\n \n /* Similar, return the offset in the constant pool.  */\n \n int\n-get_pool_offset (addr)\n-     rtx addr;\n+get_pool_offset (rtx addr)\n {\n   return (find_pool_constant (cfun, addr))->offset;\n }\n \n /* Return the size of the constant pool.  */\n \n int\n-get_pool_size ()\n+get_pool_size (void)\n {\n   return pool_offset;\n }\n \f\n /* Write all the constants in the constant pool.  */\n \n void\n-output_constant_pool (fnname, fndecl)\n-     const char *fnname ATTRIBUTE_UNUSED;\n-     tree fndecl ATTRIBUTE_UNUSED;\n+output_constant_pool (const char *fnname ATTRIBUTE_UNUSED,\n+\t\t      tree fndecl ATTRIBUTE_UNUSED)\n {\n   struct pool_constant *pool;\n   rtx x;\n@@ -3390,7 +3273,7 @@ output_constant_pool (fnname, fndecl)\n    deferred constants which have indeed been used.  */\n \n static void\n-mark_constant_pool ()\n+mark_constant_pool (void)\n {\n   rtx insn;\n   rtx link;\n@@ -3423,8 +3306,7 @@ mark_constant_pool ()\n    deferred strings that are used.  */\n \n static void\n-mark_constants (x)\n-     rtx x;\n+mark_constants (rtx x)\n {\n   int i;\n   const char *format_ptr;\n@@ -3488,9 +3370,7 @@ mark_constants (x)\n    be used with for_each_rtx to mark all SYMBOL_REFs in an rtx.  */\n \n static int\n-mark_constant (current_rtx, data)\n-     rtx *current_rtx;\n-     void *data ATTRIBUTE_UNUSED;\n+mark_constant (rtx *current_rtx, void *data ATTRIBUTE_UNUSED)\n {\n   rtx x = *current_rtx;\n \n@@ -3528,8 +3408,7 @@ mark_constant (current_rtx, data)\n    Indicate whether an ADDR_EXPR has been encountered.  */\n \n static int\n-output_addressed_constants (exp)\n-     tree exp;\n+output_addressed_constants (tree exp)\n {\n   int reloc = 0, reloc2;\n   tree tem;\n@@ -3604,9 +3483,7 @@ output_addressed_constants (exp)\n    arithmetic-combinations of integers.  */\n \n tree\n-initializer_constant_valid_p (value, endtype)\n-     tree value;\n-     tree endtype;\n+initializer_constant_valid_p (tree value, tree endtype)\n {\n   /* Give the front-end a chance to convert VALUE to something that\n      looks more like a constant to the back-end.  */\n@@ -3813,10 +3690,7 @@ initializer_constant_valid_p (value, endtype)\n    ALIGN is the alignment of the data in bits.  */\n \n void\n-output_constant (exp, size, align)\n-     tree exp;\n-     unsigned HOST_WIDE_INT size;\n-     unsigned int align;\n+output_constant (tree exp, unsigned HOST_WIDE_INT size, unsigned int align)\n {\n   enum tree_code code;\n   unsigned HOST_WIDE_INT thissize;\n@@ -3965,8 +3839,7 @@ output_constant (exp, size, align)\n    type with an unspecified upper bound.  */\n \n static unsigned HOST_WIDE_INT\n-array_size_for_constructor (val)\n-     tree val;\n+array_size_for_constructor (tree val)\n {\n   tree max_index, i;\n \n@@ -4006,10 +3879,8 @@ array_size_for_constructor (val)\n    Generate at least SIZE bytes, padding if necessary.  */\n \n static void\n-output_constructor (exp, size, align)\n-     tree exp;\n-     unsigned HOST_WIDE_INT size;\n-     unsigned int align;\n+output_constructor (tree exp, unsigned HOST_WIDE_INT size,\n+\t\t    unsigned int align)\n {\n   tree type = TREE_TYPE (exp);\n   tree link, field = 0;\n@@ -4315,8 +4186,7 @@ static GTY(()) tree weak_decls;\n /* Mark DECL as weak.  */\n \n static void\n-mark_weak (decl)\n-     tree decl;\n+mark_weak (tree decl)\n {\n   DECL_WEAK (decl) = 1;\n \n@@ -4330,9 +4200,7 @@ mark_weak (decl)\n /* Merge weak status between NEWDECL and OLDDECL.  */\n \n void\n-merge_weak (newdecl, olddecl)\n-     tree newdecl;\n-     tree olddecl;\n+merge_weak (tree newdecl, tree olddecl)\n {\n   if (DECL_WEAK (newdecl) == DECL_WEAK (olddecl))\n     return;\n@@ -4386,8 +4254,7 @@ merge_weak (newdecl, olddecl)\n /* Declare DECL to be a weak symbol.  */\n \n void\n-declare_weak (decl)\n-     tree decl;\n+declare_weak (tree decl)\n {\n   if (! TREE_PUBLIC (decl))\n     error_with_decl (decl, \"weak declaration of `%s' must be public\");\n@@ -4407,7 +4274,7 @@ declare_weak (decl)\n /* Emit any pending weak declarations.  */\n \n void\n-weak_finish ()\n+weak_finish (void)\n {\n   tree t;\n \n@@ -4439,8 +4306,7 @@ weak_finish ()\n /* Emit the assembly bits to indicate that DECL is globally visible.  */\n \n static void\n-globalize_decl (decl)\n-     tree decl;\n+globalize_decl (tree decl)\n {\n   const char *name = XSTR (XEXP (DECL_RTL (decl), 0), 0);\n \n@@ -4475,8 +4341,7 @@ globalize_decl (decl)\n    the symbol for TARGET.  */\n \n void\n-assemble_alias (decl, target)\n-     tree decl, target ATTRIBUTE_UNUSED;\n+assemble_alias (tree decl, tree target ATTRIBUTE_UNUSED)\n {\n   const char *name;\n \n@@ -4524,9 +4389,7 @@ assemble_alias (decl, target)\n    the visibility type VIS, which must not be VISIBILITY_DEFAULT.  */\n \n void\n-default_assemble_visibility (decl, vis)\n-     tree decl;\n-     int vis;\n+default_assemble_visibility (tree decl, int vis)\n {\n   static const char * const visibility_types[] = {\n     NULL, \"internal\", \"hidden\", \"protected\"\n@@ -4549,8 +4412,7 @@ default_assemble_visibility (decl, vis)\n /* A helper function to call assemble_visibility when needed for a decl.  */\n \n static void\n-maybe_assemble_visibility (decl)\n-     tree decl;\n+maybe_assemble_visibility (tree decl)\n {\n   enum symbol_visibility vis = decl_visibility (decl);\n \n@@ -4564,7 +4426,7 @@ maybe_assemble_visibility (decl)\n    a target-specific mechanism for having duplicates discarded.  */\n \n int\n-supports_one_only ()\n+supports_one_only (void)\n {\n   if (SUPPORTS_ONE_ONLY)\n     return 1;\n@@ -4575,8 +4437,7 @@ supports_one_only ()\n    translation units without generating a linker error.  */\n \n void\n-make_decl_one_only (decl)\n-     tree decl;\n+make_decl_one_only (tree decl)\n {\n   if (TREE_CODE (decl) != VAR_DECL && TREE_CODE (decl) != FUNCTION_DECL)\n     abort ();\n@@ -4600,7 +4461,7 @@ make_decl_one_only (decl)\n }\n \n void\n-init_varasm_once ()\n+init_varasm_once (void)\n {\n   in_named_htab = htab_create_ggc (31, in_named_entry_hash,\n \t\t\t\t   in_named_entry_eq, NULL);\n@@ -4611,8 +4472,7 @@ init_varasm_once ()\n }\n \n enum tls_model\n-decl_tls_model (decl)\n-     tree decl;\n+decl_tls_model (tree decl)\n {\n   enum tls_model kind;\n   tree attr = lookup_attribute (\"tls_model\", DECL_ATTRIBUTES (decl));\n@@ -4657,8 +4517,7 @@ decl_tls_model (decl)\n }\n \n enum symbol_visibility\n-decl_visibility (decl)\n-     tree decl;\n+decl_visibility (tree decl)\n {\n   tree attr = lookup_attribute (\"visibility\", DECL_ATTRIBUTES (decl));\n \n@@ -4689,20 +4548,14 @@ decl_visibility (decl)\n    read-only for a const data decl, and writable for a non-const data decl.  */\n \n unsigned int\n-default_section_type_flags (decl, name, reloc)\n-     tree decl;\n-     const char *name;\n-     int reloc;\n+default_section_type_flags (tree decl, const char *name, int reloc)\n {\n   return default_section_type_flags_1 (decl, name, reloc, flag_pic);\n }\n \n unsigned int\n-default_section_type_flags_1 (decl, name, reloc, shlib)\n-     tree decl;\n-     const char *name;\n-     int reloc;\n-     int shlib;\n+default_section_type_flags_1 (tree decl, const char *name, int reloc,\n+\t\t\t      int shlib)\n {\n   unsigned int flags;\n \n@@ -4753,19 +4606,16 @@ default_section_type_flags_1 (decl, name, reloc, shlib)\n    Four variants for common object file formats.  */\n \n void\n-default_no_named_section (name, flags)\n-     const char *name ATTRIBUTE_UNUSED;\n-     unsigned int flags ATTRIBUTE_UNUSED;\n+default_no_named_section (const char *name ATTRIBUTE_UNUSED,\n+\t\t\t  unsigned int flags ATTRIBUTE_UNUSED)\n {\n   /* Some object formats don't support named sections at all.  The\n      front-end should already have flagged this as an error.  */\n   abort ();\n }\n \n void\n-default_elf_asm_named_section (name, flags)\n-     const char *name;\n-     unsigned int flags;\n+default_elf_asm_named_section (const char *name, unsigned int flags)\n {\n   char flagchars[10], *f = flagchars;\n \n@@ -4812,9 +4662,7 @@ default_elf_asm_named_section (name, flags)\n }\n \n void\n-default_coff_asm_named_section (name, flags)\n-     const char *name;\n-     unsigned int flags;\n+default_coff_asm_named_section (const char *name, unsigned int flags)\n {\n   char flagchars[8], *f = flagchars;\n \n@@ -4828,9 +4676,7 @@ default_coff_asm_named_section (name, flags)\n }\n \n void\n-default_pe_asm_named_section (name, flags)\n-     const char *name;\n-     unsigned int flags;\n+default_pe_asm_named_section (const char *name, unsigned int flags)\n {\n   default_coff_asm_named_section (name, flags);\n \n@@ -4848,9 +4694,7 @@ default_pe_asm_named_section (name, flags)\n    from SYMBOL is used in all classes derived from SYMBOL.  */\n \n void\n-assemble_vtable_entry (symbol, offset)\n-     rtx symbol;\n-     HOST_WIDE_INT offset;\n+assemble_vtable_entry (rtx symbol, HOST_WIDE_INT offset)\n {\n   fputs (\"\\t.vtable_entry \", asm_out_file);\n   output_addr_const (asm_out_file, symbol);\n@@ -4861,8 +4705,7 @@ assemble_vtable_entry (symbol, offset)\n    that the vtable symbol CHILD is derived from the vtable symbol PARENT.  */\n \n void\n-assemble_vtable_inherit (child, parent)\n-     rtx child, parent;\n+assemble_vtable_inherit (rtx child, rtx parent)\n {\n   fputs (\"\\t.vtable_inherit \", asm_out_file);\n   output_addr_const (asm_out_file, child);\n@@ -4874,10 +4717,8 @@ assemble_vtable_inherit (child, parent)\n /* The lame default section selector.  */\n \n void\n-default_select_section (decl, reloc, align)\n-     tree decl;\n-     int reloc;\n-     unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED;\n+default_select_section (tree decl, int reloc,\n+\t\t\tunsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED)\n {\n   bool readonly = false;\n \n@@ -4943,13 +4784,10 @@ enum section_category\n };\n \n static enum section_category\n-categorize_decl_for_section PARAMS ((tree, int, int));\n+categorize_decl_for_section (tree, int, int);\n \n static enum section_category\n-categorize_decl_for_section (decl, reloc, shlib)\n-     tree decl;\n-     int reloc;\n-     int shlib;\n+categorize_decl_for_section (tree decl, int reloc, int shlib)\n {\n   enum section_category ret;\n \n@@ -5028,18 +4866,13 @@ categorize_decl_for_section (decl, reloc, shlib)\n }\n \n bool\n-decl_readonly_section (decl, reloc)\n-     tree decl;\n-     int reloc;\n+decl_readonly_section (tree decl, int reloc)\n {\n   return decl_readonly_section_1 (decl, reloc, flag_pic);\n }\n \n bool\n-decl_readonly_section_1 (decl, reloc, shlib)\n-     tree decl;\n-     int reloc;\n-     int shlib;\n+decl_readonly_section_1 (tree decl, int reloc, int shlib)\n {\n   switch (categorize_decl_for_section (decl, reloc, shlib))\n     {\n@@ -5059,20 +4892,15 @@ decl_readonly_section_1 (decl, reloc, shlib)\n /* Select a section based on the above categorization.  */\n \n void\n-default_elf_select_section (decl, reloc, align)\n-     tree decl;\n-     int reloc;\n-     unsigned HOST_WIDE_INT align;\n+default_elf_select_section (tree decl, int reloc,\n+\t\t\t    unsigned HOST_WIDE_INT align)\n {\n   default_elf_select_section_1 (decl, reloc, align, flag_pic);\n }\n \n void\n-default_elf_select_section_1 (decl, reloc, align, shlib)\n-     tree decl;\n-     int reloc;\n-     unsigned HOST_WIDE_INT align;\n-     int shlib;\n+default_elf_select_section_1 (tree decl, int reloc,\n+\t\t\t      unsigned HOST_WIDE_INT align, int shlib)\n {\n   switch (categorize_decl_for_section (decl, reloc, shlib))\n     {\n@@ -5137,18 +4965,13 @@ default_elf_select_section_1 (decl, reloc, align, shlib)\n    categorization performed above.  */\n \n void\n-default_unique_section (decl, reloc)\n-     tree decl;\n-     int reloc;\n+default_unique_section (tree decl, int reloc)\n {\n   default_unique_section_1 (decl, reloc, flag_pic);\n }\n \n void\n-default_unique_section_1 (decl, reloc, shlib)\n-     tree decl;\n-     int reloc;\n-     int shlib;\n+default_unique_section_1 (tree decl, int reloc, int shlib)\n {\n   bool one_only = DECL_ONE_ONLY (decl);\n   const char *prefix, *name;\n@@ -5208,10 +5031,9 @@ default_unique_section_1 (decl, reloc, shlib)\n }\n \n void\n-default_select_rtx_section (mode, x, align)\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     rtx x;\n-     unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED;\n+default_select_rtx_section (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t    rtx x,\n+\t\t\t    unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED)\n {\n   if (flag_pic)\n     switch (GET_CODE (x))\n@@ -5230,10 +5052,8 @@ default_select_rtx_section (mode, x, align)\n }\n \n void\n-default_elf_select_rtx_section (mode, x, align)\n-     enum machine_mode mode;\n-     rtx x;\n-     unsigned HOST_WIDE_INT align;\n+default_elf_select_rtx_section (enum machine_mode mode, rtx x,\n+\t\t\t\tunsigned HOST_WIDE_INT align)\n {\n   /* ??? Handle small data here somehow.  */\n \n@@ -5259,10 +5079,7 @@ default_elf_select_rtx_section (mode, x, align)\n /* Set the generally applicable flags on the SYMBOL_REF for EXP.  */\n \n void\n-default_encode_section_info (decl, rtl, first)\n-     tree decl;\n-     rtx rtl;\n-     int first ATTRIBUTE_UNUSED;\n+default_encode_section_info (tree decl, rtx rtl, int first ATTRIBUTE_UNUSED)\n {\n   rtx symbol;\n   int flags;\n@@ -5296,8 +5113,7 @@ default_encode_section_info (decl, rtl, first)\n    do anything but discard the '*' marker.  */\n \n const char *\n-default_strip_name_encoding (str)\n-     const char *str;\n+default_strip_name_encoding (const char *str)\n {\n   return str + (*str == '*');\n }\n@@ -5306,16 +5122,13 @@ default_strip_name_encoding (str)\n    wrt cross-module name binding.  */\n \n bool\n-default_binds_local_p (exp)\n-     tree exp;\n+default_binds_local_p (tree exp)\n {\n   return default_binds_local_p_1 (exp, flag_shlib);\n }\n \n bool\n-default_binds_local_p_1 (exp, shlib)\n-     tree exp;\n-     int shlib;\n+default_binds_local_p_1 (tree exp, int shlib)\n {\n   bool local_p;\n \n@@ -5355,8 +5168,7 @@ default_binds_local_p_1 (exp, shlib)\n /* Determine whether or not a pointer mode is valid. Assume defaults\n    of ptr_mode or Pmode - can be overridden.  */\n bool\n-default_valid_pointer_mode (mode)\n-     enum machine_mode mode;\n+default_valid_pointer_mode (enum machine_mode mode)\n {\n   return (mode == ptr_mode || mode == Pmode);\n }\n@@ -5366,24 +5178,20 @@ default_valid_pointer_mode (mode)\n    globalize a label.  */\n #ifdef GLOBAL_ASM_OP\n void\n-default_globalize_label (stream, name)\n-     FILE * stream;\n-     const char *name;\n+default_globalize_label (FILE * stream, const char *name)\n {\n   fputs (GLOBAL_ASM_OP, stream);\n   assemble_name (stream, name);\n   putc ('\\n', stream);\n }\n #endif /* GLOBAL_ASM_OP */\n-  \n+\n /* This is how to output an internal numbered label where PREFIX is\n    the class of label and LABELNO is the number within the class.  */\n \n void\n-default_internal_label (stream, prefix, labelno)\n-     FILE *stream;\n-     const char *prefix;\n-     unsigned long labelno;\n+default_internal_label (FILE *stream, const char *prefix,\n+\t\t\tunsigned long labelno)\n {\n   char *const buf = alloca (40 + strlen (prefix));\n   ASM_GENERATE_INTERNAL_LABEL (buf, prefix, labelno);\n@@ -5393,7 +5201,7 @@ default_internal_label (stream, prefix, labelno)\n /* This is the default behavior at the beginning of a file.  It's\n    controlled by two other target-hook toggles.  */\n void\n-default_file_start ()\n+default_file_start (void)\n {\n   if (targetm.file_start_app_off && !flag_verbose_asm)\n     fputs (ASM_APP_OFF, asm_out_file);\n@@ -5407,7 +5215,7 @@ default_file_start ()\n    not this object file needs an executable stack.  This is primarily\n    a GNU extension to ELF but could be used on other targets.  */\n void\n-file_end_indicate_exec_stack ()\n+file_end_indicate_exec_stack (void)\n {\n   unsigned int flags = SECTION_DEBUG;\n   if (trampolines_created)"}, {"sha": "849d60be95c6810d969bbfafae2f04d78c6f2ffe", "filename": "gcc/varray.c", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e1eedd6bb7d1e6358847d0ab912f13aa69ef403/gcc%2Fvarray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e1eedd6bb7d1e6358847d0ab912f13aa69ef403/gcc%2Fvarray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarray.c?ref=2e1eedd6bb7d1e6358847d0ab912f13aa69ef403", "patch": "@@ -1,5 +1,6 @@\n /* Virtual array support.\n-   Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003\n+   Free Software Foundation, Inc.\n    Contributed by Cygnus Solutions.\n \n    This file is part of GCC.\n@@ -61,10 +62,8 @@ static const struct {\n /* Allocate a virtual array with NUM_ELEMENT elements, each of which is\n    ELEMENT_SIZE bytes long, named NAME.  Array elements are zeroed.  */\n varray_type\n-varray_init (num_elements, element_kind, name)\n-     size_t num_elements;\n-     enum varray_data_enum element_kind;\n-     const char *name;\n+varray_init (size_t num_elements, enum varray_data_enum element_kind,\n+\t     const char *name)\n {\n   size_t data_size = num_elements * element[element_kind].size;\n   varray_type ptr;\n@@ -83,9 +82,7 @@ varray_init (num_elements, element_kind, name)\n /* Grow/shrink the virtual array VA to N elements.  Zero any new elements\n    allocated.  */\n varray_type\n-varray_grow (va, n)\n-     varray_type va;\n-     size_t n;\n+varray_grow (varray_type va, size_t n)\n {\n   size_t old_elements = va->num_elements;\n \n@@ -109,8 +106,7 @@ varray_grow (va, n)\n \n /* Reset a varray to its original state.  */\n void\n-varray_clear (va)\n-     varray_type va;\n+varray_clear (varray_type va)\n {\n   size_t data_size = element[va->type].size * va->num_elements;\n \n@@ -122,19 +118,15 @@ varray_clear (va)\n \n #if defined ENABLE_CHECKING && (GCC_VERSION >= 2007)\n \n-extern void error PARAMS ((const char *, ...))\tATTRIBUTE_PRINTF_1;\n+extern void error (const char *, ...)\tATTRIBUTE_PRINTF_1;\n \n void\n-varray_check_failed (va, n, file, line, function)\n-     varray_type va;\n-     size_t n;\n-     const char *file;\n-     int line;\n-     const char *function;\n+varray_check_failed (varray_type va, size_t n, const char *file, int line,\n+\t\t     const char *function)\n {\n   internal_error (\"virtual array %s[%lu]: element %lu out of bounds in %s, at %s:%d\",\n \t\t  va->name, (unsigned long) va->num_elements, (unsigned long) n,\n-\t\t  function, trim_filename (file), line);\n+\t\t  function, trim_filename (file), line;\n }\n \n #endif"}, {"sha": "ef5c6eef032f938c8fbe9f1173a4e9f143b62d5d", "filename": "gcc/varray.h", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e1eedd6bb7d1e6358847d0ab912f13aa69ef403/gcc%2Fvarray.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e1eedd6bb7d1e6358847d0ab912f13aa69ef403/gcc%2Fvarray.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarray.h?ref=2e1eedd6bb7d1e6358847d0ab912f13aa69ef403", "patch": "@@ -1,5 +1,6 @@\n /* Virtual array support.\n-   Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2002, 2003\n+   Free Software Foundation, Inc.\n    Contributed by Cygnus Solutions.\n \n    This file is part of GCC.\n@@ -56,7 +57,7 @@ struct const_equiv_data GTY(()) {\n   unsigned age;\n };\n \n-/* Enum indicating what the varray contains.  \n+/* Enum indicating what the varray contains.\n    If this is changed, `element' in varray.c needs to be updated.  */\n \n enum varray_data_enum {\n@@ -120,7 +121,7 @@ typedef union varray_data_tag GTY (()) {\n   struct reg_info_def\t *GTY ((length (\"%0.num_elements\"), skip (\"\"),\n \t\t\t\ttag (\"VARRAY_DATA_REG\")))\treg[1];\n   struct const_equiv_data GTY ((length (\"%0.num_elements\"),\n-\t\t\ttag (\"VARRAY_DATA_CONST_EQUIV\"))) \tconst_equiv[1];\n+\t\t\ttag (\"VARRAY_DATA_CONST_EQUIV\")))\tconst_equiv[1];\n   struct basic_block_def *GTY ((length (\"%0.num_elements\"), skip (\"\"),\n \t\t\t\ttag (\"VARRAY_DATA_BB\")))\tbb[1];\n   struct elt_list\t *GTY ((length (\"%0.num_elements\"),\n@@ -134,15 +135,14 @@ struct varray_head_tag GTY(()) {\n \t\t\t\t   using VARRAY_PUSH/VARRAY_POP.  */\n   enum varray_data_enum type;\t/* The kind of elements in the varray.  */\n   const char   *name;\t\t/* name of the varray for reporting errors */\n-  varray_data\tGTY ((desc (\"%0.type\"))) data;\t/* The data elements follow, \n+  varray_data\tGTY ((desc (\"%0.type\"))) data;\t/* The data elements follow,\n \t\t\t\t\t\t   must be last.  */\n };\n typedef struct varray_head_tag *varray_type;\n \n /* Allocate a virtual array with NUM elements, each of which is SIZE bytes\n    long, named NAME.  Array elements are zeroed.  */\n-extern varray_type varray_init\tPARAMS ((size_t, enum varray_data_enum, \n-\t\t\t\t\t const char *));\n+extern varray_type varray_init (size_t, enum varray_data_enum, const char *);\n \n #define VARRAY_CHAR_INIT(va, num, name) \\\n   va = varray_init (num, VARRAY_DATA_C, name)\n@@ -210,7 +210,7 @@ extern varray_type varray_init\tPARAMS ((size_t, enum varray_data_enum,\n   do { if (vp) { free (vp); vp = (varray_type) 0; } } while (0)\n \n /* Grow/shrink the virtual array VA to N elements.  */\n-extern varray_type varray_grow\tPARAMS ((varray_type, size_t));\n+extern varray_type varray_grow (varray_type, size_t);\n \n #define VARRAY_GROW(VA, N) ((VA) = varray_grow (VA, N))\n \n@@ -221,16 +221,15 @@ extern varray_type varray_grow\tPARAMS ((varray_type, size_t));\n \n #define VARRAY_CLEAR(VA) varray_clear(VA)\n \n-extern void varray_clear\tPARAMS ((varray_type));\n+extern void varray_clear (varray_type);\n \n /* Check for VARRAY_xxx macros being in bound.  */\n #if defined ENABLE_CHECKING && (GCC_VERSION >= 2007)\n-extern void varray_check_failed PARAMS ((varray_type, size_t,\n-\t\t\t\t\tconst char *, int,\n-\t\t\t\t\tconst char *)) ATTRIBUTE_NORETURN;\n+extern void varray_check_failed (varray_type, size_t, const char *, int,\n+\t\t\t\t const char *) ATTRIBUTE_NORETURN;\n #define VARRAY_CHECK(VA, N, T) __extension__\t\t\t\\\n (*({ varray_type const _va = (VA);\t\t\t\t\\\n-     const size_t _n = (N); \t\t\t\t\t\\\n+     const size_t _n = (N);\t\t\t\t\t\\\n      if (_n >= _va->num_elements)\t\t\t\t\\\n        varray_check_failed (_va, _n, __FILE__, __LINE__, __FUNCTION__);\t\\\n      &_va->data.T[_n]; }))"}, {"sha": "ac148c2ce997c35cacebe357e936a3b5170d3249", "filename": "gcc/vmsdbgout.c", "status": "modified", "additions": 78, "deletions": 143, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e1eedd6bb7d1e6358847d0ab912f13aa69ef403/gcc%2Fvmsdbgout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e1eedd6bb7d1e6358847d0ab912f13aa69ef403/gcc%2Fvmsdbgout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvmsdbgout.c?ref=2e1eedd6bb7d1e6358847d0ab912f13aa69ef403", "patch": "@@ -1,6 +1,6 @@\n /* Output VMS debug format symbol table information from GCC.\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n    Contributed by Douglas B. Rupp (rupp@gnat.com).\n \n This file is part of GCC.\n@@ -128,44 +128,43 @@ static unsigned int line_info_table_in_use;\n #define LINE_INFO_TABLE_INCREMENT 1024\n \n /* Forward declarations for functions defined in this file.  */\n-static char *full_name \t\tPARAMS ((const char *));\n-static unsigned int lookup_filename PARAMS ((const char *));\n-static void addr_const_to_string PARAMS ((char *, rtx));\n-static int write_debug_header\tPARAMS ((DST_HEADER *, const char *, int));\n-static int write_debug_addr\tPARAMS ((char *, const char *, int));\n-static int write_debug_data1\tPARAMS ((unsigned int, const char *, int));\n-static int write_debug_data2\tPARAMS ((unsigned int, const char *, int));\n-static int write_debug_data4\tPARAMS ((unsigned long, const char *, int));\n-static int write_debug_data8\tPARAMS ((unsigned long long, const char *,\n-\t\t\t\t\t int));\n-static int write_debug_delta4\tPARAMS ((char *, char *, const char *, int));\n-static int write_debug_string\tPARAMS ((char *, const char *, int));\n-static int write_modbeg\t\tPARAMS ((int));\n-static int write_modend\t\tPARAMS ((int));\n-static int write_rtnbeg\t\tPARAMS ((int, int));\n-static int write_rtnend\t\tPARAMS ((int, int));\n-static int write_pclines\tPARAMS ((int));\n-static int write_srccorr\tPARAMS ((int, dst_file_info_entry, int));\n-static int write_srccorrs\tPARAMS ((int));\n-\n-static void vmsdbgout_init\t\tPARAMS ((const char *));\n-static void vmsdbgout_finish\t\tPARAMS ((const char *));\n-static void vmsdbgout_define\t\tPARAMS ((unsigned int, const char *));\n-static void vmsdbgout_undef\t\tPARAMS ((unsigned int, const char *));\n-static void vmsdbgout_start_source_file PARAMS ((unsigned int, const char *));\n-static void vmsdbgout_end_source_file\tPARAMS ((unsigned int));\n-static void vmsdbgout_begin_block\tPARAMS ((unsigned int, unsigned int));\n-static void vmsdbgout_end_block\t\tPARAMS ((unsigned int, unsigned int));\n-static bool vmsdbgout_ignore_block\tPARAMS ((tree));\n-static void vmsdbgout_source_line\tPARAMS ((unsigned int, const char *));\n-static void vmsdbgout_begin_prologue\tPARAMS ((unsigned int, const char *));\n-static void vmsdbgout_end_prologue\tPARAMS ((unsigned int, const char *));\n-static void vmsdbgout_end_function\tPARAMS ((unsigned int));\n-static void vmsdbgout_end_epilogue\tPARAMS ((unsigned int, const char *));\n-static void vmsdbgout_begin_function\tPARAMS ((tree));\n-static void vmsdbgout_decl\t\tPARAMS ((tree));\n-static void vmsdbgout_global_decl\tPARAMS ((tree));\n-static void vmsdbgout_abstract_function PARAMS ((tree));\n+static char *full_name (const char *);\n+static unsigned int lookup_filename (const char *);\n+static void addr_const_to_string (char *, rtx);\n+static int write_debug_header (DST_HEADER *, const char *, int);\n+static int write_debug_addr (char *, const char *, int);\n+static int write_debug_data1 (unsigned int, const char *, int);\n+static int write_debug_data2 (unsigned int, const char *, int);\n+static int write_debug_data4 (unsigned long, const char *, int);\n+static int write_debug_data8 (unsigned long long, const char *, int);\n+static int write_debug_delta4 (char *, char *, const char *, int);\n+static int write_debug_string (char *, const char *, int);\n+static int write_modbeg (int);\n+static int write_modend (int);\n+static int write_rtnbeg (int, int);\n+static int write_rtnend (int, int);\n+static int write_pclines (int);\n+static int write_srccorr (int, dst_file_info_entry, int);\n+static int write_srccorrs (int);\n+\n+static void vmsdbgout_init (const char *);\n+static void vmsdbgout_finish (const char *);\n+static void vmsdbgout_define (unsigned int, const char *);\n+static void vmsdbgout_undef (unsigned int, const char *);\n+static void vmsdbgout_start_source_file (unsigned int, const char *);\n+static void vmsdbgout_end_source_file (unsigned int);\n+static void vmsdbgout_begin_block (unsigned int, unsigned int);\n+static void vmsdbgout_end_block (unsigned int, unsigned int);\n+static bool vmsdbgout_ignore_block (tree);\n+static void vmsdbgout_source_line (unsigned int, const char *);\n+static void vmsdbgout_begin_prologue (unsigned int, const char *);\n+static void vmsdbgout_end_prologue (unsigned int, const char *);\n+static void vmsdbgout_end_function (unsigned int);\n+static void vmsdbgout_end_epilogue (unsigned int, const char *);\n+static void vmsdbgout_begin_function (tree);\n+static void vmsdbgout_decl (tree);\n+static void vmsdbgout_global_decl (tree);\n+static void vmsdbgout_abstract_function (tree);\n \n /* The debug hooks structure.  */\n \n@@ -382,7 +381,7 @@ static char text_end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n    macro has the same effect as ASM_OUTPUT_LABELREF, but copies to\n    a string rather than writing to a file.  */\n #ifndef ASM_NAME_TO_STRING\n-#define ASM_NAME_TO_STRING(STR, NAME) \t\t\\\n+#define ASM_NAME_TO_STRING(STR, NAME)\t\t\\\n   do\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\\\n       if ((NAME)[0] == '*')\t\t\t\\\n@@ -403,9 +402,7 @@ static char text_end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n    directly, because it writes to a file.  */\n \n static void\n-addr_const_to_string (str, x)\n-     char *str;\n-     rtx x;\n+addr_const_to_string (char *str, rtx x)\n {\n   char buf1[256];\n   char buf2[256];\n@@ -533,10 +530,7 @@ addr_const_to_string (str, x)\n    nonzero.  */\n \n static int\n-write_debug_header (header, comment, dosizeonly)\n-     DST_HEADER *header;\n-     const char *comment;\n-     int dosizeonly;\n+write_debug_header (DST_HEADER *header, const char *comment, int dosizeonly)\n {\n   if (!dosizeonly)\n     {\n@@ -565,10 +559,7 @@ write_debug_header (header, comment, dosizeonly)\n    nonzero.  */\n \n static int\n-write_debug_addr (symbol, comment, dosizeonly)\n-     char *symbol;\n-     const char *comment;\n-     int dosizeonly;\n+write_debug_addr (char *symbol, const char *comment, int dosizeonly)\n {\n   if (!dosizeonly)\n     {\n@@ -586,10 +577,7 @@ write_debug_addr (symbol, comment, dosizeonly)\n    nonzero.  */\n \n static int\n-write_debug_data1 (data1, comment, dosizeonly)\n-     unsigned int data1;\n-     const char *comment;\n-     int dosizeonly;\n+write_debug_data1 (unsigned int data1, const char *comment, int dosizeonly)\n {\n   if (!dosizeonly)\n     {\n@@ -607,10 +595,7 @@ write_debug_data1 (data1, comment, dosizeonly)\n    nonzero.  */\n \n static int\n-write_debug_data2 (data2, comment, dosizeonly)\n-     unsigned int data2;\n-     const char *comment;\n-     int dosizeonly;\n+write_debug_data2 (unsigned int data2, const char *comment, int dosizeonly)\n {\n   if (!dosizeonly)\n     {\n@@ -627,10 +612,7 @@ write_debug_data2 (data2, comment, dosizeonly)\n    Return the data size.  Just return the size if DOSIZEONLY is nonzero.  */\n \n static int\n-write_debug_data4 (data4, comment, dosizeonly)\n-     unsigned long data4;\n-     const char *comment;\n-     int dosizeonly;\n+write_debug_data4 (unsigned long data4, const char *comment, int dosizeonly)\n {\n   if (!dosizeonly)\n     {\n@@ -647,10 +629,8 @@ write_debug_data4 (data4, comment, dosizeonly)\n    Return the data size.  Just return the size if DOSIZEONLY is nonzero.  */\n \n static int\n-write_debug_data8 (data8, comment, dosizeonly)\n-     unsigned long long data8;\n-     const char *comment;\n-     int dosizeonly;\n+write_debug_data8 (unsigned long long data8, const char *comment,\n+\t\t   int dosizeonly)\n {\n   if (!dosizeonly)\n     {\n@@ -668,11 +648,8 @@ write_debug_data8 (data8, comment, dosizeonly)\n    DOSIZEONLY is nonzero.  */\n \n static int\n-write_debug_delta4 (label1, label2, comment, dosizeonly)\n-     char *label1;\n-     char *label2;\n-     const char *comment;\n-     int dosizeonly;\n+write_debug_delta4 (char *label1, char *label2, const char *comment,\n+\t\t    int dosizeonly)\n {\n   if (!dosizeonly)\n     {\n@@ -690,10 +667,7 @@ write_debug_delta4 (label1, label2, comment, dosizeonly)\n    nonzero.  */\n \n static int\n-write_debug_string (string, comment, dosizeonly)\n-     char *string;\n-     const char *comment;\n-     int dosizeonly;\n+write_debug_string (char *string, const char *comment, int dosizeonly)\n {\n   if (!dosizeonly)\n     {\n@@ -710,8 +684,7 @@ write_debug_string (string, comment, dosizeonly)\n    size if DOSIZEONLY is nonzero.  */\n \n static int\n-write_modbeg (dosizeonly)\n-     int dosizeonly;\n+write_modbeg (int dosizeonly)\n {\n   DST_MODULE_BEGIN modbeg;\n   DST_MB_TRLR mb_trlr;\n@@ -774,8 +747,7 @@ write_modbeg (dosizeonly)\n    the size if DOSIZEONLY is nonzero.  */\n \n static int\n-write_modend (dosizeonly)\n-     int dosizeonly;\n+write_modend (int dosizeonly)\n {\n   DST_MODULE_END modend;\n   int totsize = 0;\n@@ -794,9 +766,7 @@ write_modend (dosizeonly)\n    Just return the size if DOSIZEONLY is nonzero.  */\n \n static int\n-write_rtnbeg (rtnnum, dosizeonly)\n-     int rtnnum;\n-     int dosizeonly;\n+write_rtnbeg (int rtnnum, int dosizeonly)\n {\n   char *rtnname;\n   int rtnnamelen;\n@@ -889,9 +859,7 @@ write_rtnbeg (rtnnum, dosizeonly)\n    Just return the size if DOSIZEONLY is nonzero.  */\n \n static int\n-write_rtnend (rtnnum, dosizeonly)\n-     int rtnnum;\n-     int dosizeonly;\n+write_rtnend (int rtnnum, int dosizeonly)\n {\n   DST_ROUTINE_END rtnend;\n   char label1[MAX_ARTIFICIAL_LABEL_BYTES];\n@@ -933,8 +901,7 @@ write_rtnend (rtnnum, dosizeonly)\n    the size if DOSIZEONLY is nonzero */\n \n static int\n-write_pclines (dosizeonly)\n-     int dosizeonly;\n+write_pclines (int dosizeonly)\n {\n   unsigned i;\n   int fn;\n@@ -1064,10 +1031,8 @@ write_pclines (dosizeonly)\n    nonzero.  */\n \n static int\n-write_srccorr (fileid, file_info_entry, dosizeonly)\n-     int fileid;\n-     dst_file_info_entry file_info_entry;\n-     int dosizeonly;\n+write_srccorr (int fileid, dst_file_info_entry file_info_entry,\n+\t       int dosizeonly)\n {\n   int src_command_size;\n   int linesleft = file_info_entry.max_line;\n@@ -1259,8 +1224,7 @@ write_srccorr (fileid, file_info_entry, dosizeonly)\n    the size if DOSIZEONLY is nonzero.  */\n \n static int\n-write_srccorrs (dosizeonly)\n-     int dosizeonly;\n+write_srccorrs (int dosizeonly)\n {\n   unsigned int i;\n   int totsize = 0;\n@@ -1275,9 +1239,7 @@ write_srccorrs (dosizeonly)\n    the prologue.  */\n \n static void\n-vmsdbgout_begin_prologue (line, file)\n-     unsigned int line;\n-     const char *file;\n+vmsdbgout_begin_prologue (unsigned int line, const char *file)\n {\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n@@ -1296,9 +1258,7 @@ vmsdbgout_begin_prologue (line, file)\n    the prologue.  */\n \n static void\n-vmsdbgout_end_prologue (line, file)\n-     unsigned int line;\n-     const char *file;\n+vmsdbgout_end_prologue (unsigned int line, const char *file)\n {\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n@@ -1319,8 +1279,7 @@ vmsdbgout_end_prologue (line, file)\n /* No output for VMS debug, but make obligatory call to Dwarf2 debug */\n \n static void\n-vmsdbgout_end_function (line)\n-     unsigned int line;\n+vmsdbgout_end_function (unsigned int line)\n {\n   if (write_symbols == VMS_AND_DWARF2_DEBUG)\n     (*dwarf2_debug_hooks.end_function) (line);\n@@ -1331,9 +1290,7 @@ vmsdbgout_end_function (line)\n    been generated.  */\n \n static void\n-vmsdbgout_end_epilogue (line, file)\n-     unsigned int line;\n-     const char *file;\n+vmsdbgout_end_epilogue (unsigned int line, const char *file)\n {\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n@@ -1357,9 +1314,7 @@ vmsdbgout_end_epilogue (line, file)\n    a lexical block.  */\n \n static void\n-vmsdbgout_begin_block (line, blocknum)\n-     register unsigned line;\n-     register unsigned blocknum;\n+vmsdbgout_begin_block (register unsigned line, register unsigned blocknum)\n {\n   if (write_symbols == VMS_AND_DWARF2_DEBUG)\n     (*dwarf2_debug_hooks.begin_block) (line, blocknum);\n@@ -1372,9 +1327,7 @@ vmsdbgout_begin_block (line, blocknum)\n    lexical block.  */\n \n static void\n-vmsdbgout_end_block (line, blocknum)\n-     register unsigned line;\n-     register unsigned blocknum;\n+vmsdbgout_end_block (register unsigned line, register unsigned blocknum)\n {\n   if (write_symbols == VMS_AND_DWARF2_DEBUG)\n     (*dwarf2_debug_hooks.end_block) (line, blocknum);\n@@ -1386,8 +1339,7 @@ vmsdbgout_end_block (line, blocknum)\n /* Not implemented in VMS Debug.  */\n \n static bool\n-vmsdbgout_ignore_block (block)\n-     tree block;\n+vmsdbgout_ignore_block (tree block)\n {\n   bool retval = 0;\n \n@@ -1400,8 +1352,7 @@ vmsdbgout_ignore_block (block)\n /* Add an entry for function DECL into the func_table.  */\n \n static void\n-vmsdbgout_begin_function (decl)\n-     tree decl;\n+vmsdbgout_begin_function (tree decl)\n {\n   const char *name = XSTR (XEXP (DECL_RTL (decl), 0), 0);\n \n@@ -1425,8 +1376,7 @@ static char fullname_buff [4096];\n    in VMS syntax in order to be processed by VMS Debug.  */\n \n static char *\n-full_name (filename)\n-     const char *filename;\n+full_name (const char *filename)\n {\n #ifdef VMS\n   FILE *fp = fopen (filename, \"r\");\n@@ -1457,8 +1407,7 @@ full_name (filename)\n    all searches.  */\n \n static unsigned int\n-lookup_filename (file_name)\n-     const char *file_name;\n+lookup_filename (const char *file_name)\n {\n   static unsigned int last_file_lookup_index = 0;\n   register char *fn;\n@@ -1556,9 +1505,7 @@ lookup_filename (file_name)\n    'line_info_table' for later output of the .debug_line section.  */\n \n static void\n-vmsdbgout_source_line (line, filename)\n-     register unsigned line;\n-     register const char *filename;\n+vmsdbgout_source_line (register unsigned line, register const char *filename)\n {\n   if (write_symbols == VMS_AND_DWARF2_DEBUG)\n     (*dwarf2_debug_hooks.source_line) (line, filename);\n@@ -1593,9 +1540,7 @@ vmsdbgout_source_line (line, filename)\n    At present, unimplemented.  */\n \n static void\n-vmsdbgout_start_source_file (lineno, filename)\n-     unsigned int lineno;\n-     const char *filename;\n+vmsdbgout_start_source_file (unsigned int lineno, const char *filename)\n {\n   if (write_symbols == VMS_AND_DWARF2_DEBUG)\n     (*dwarf2_debug_hooks.start_source_file) (lineno, filename);\n@@ -1605,8 +1550,7 @@ vmsdbgout_start_source_file (lineno, filename)\n    At present, unimplemented.  */\n \n static void\n-vmsdbgout_end_source_file (lineno)\n-     unsigned int lineno ATTRIBUTE_UNUSED;\n+vmsdbgout_end_source_file (unsigned int lineno ATTRIBUTE_UNUSED)\n {\n   if (write_symbols == VMS_AND_DWARF2_DEBUG)\n     (*dwarf2_debug_hooks.end_source_file) (lineno);\n@@ -1615,8 +1559,7 @@ vmsdbgout_end_source_file (lineno)\n /* Set up for Debug output at the start of compilation.  */\n \n static void\n-vmsdbgout_init (main_input_filename)\n-     const char *main_input_filename;\n+vmsdbgout_init (const char *main_input_filename)\n {\n   const char *language_string = lang_hooks.name;\n \n@@ -1672,9 +1615,7 @@ vmsdbgout_init (main_input_filename)\n /* Not implemented in VMS Debug.  */\n \n static void\n-vmsdbgout_define (lineno, buffer)\n-     unsigned int lineno;\n-     const char *buffer;\n+vmsdbgout_define (unsigned int lineno, const char *buffer)\n {\n   if (write_symbols == VMS_AND_DWARF2_DEBUG)\n     (*dwarf2_debug_hooks.define) (lineno, buffer);\n@@ -1683,9 +1624,7 @@ vmsdbgout_define (lineno, buffer)\n /* Not implemented in VMS Debug.  */\n \n static void\n-vmsdbgout_undef (lineno, buffer)\n-     unsigned int lineno;\n-     const char *buffer;\n+vmsdbgout_undef (unsigned int lineno, const char *buffer)\n {\n   if (write_symbols == VMS_AND_DWARF2_DEBUG)\n     (*dwarf2_debug_hooks.undef) (lineno, buffer);\n@@ -1694,8 +1633,7 @@ vmsdbgout_undef (lineno, buffer)\n /* Not implemented in VMS Debug.  */\n \n static void\n-vmsdbgout_decl (decl)\n-     tree decl;\n+vmsdbgout_decl (tree decl)\n {\n   if (write_symbols == VMS_AND_DWARF2_DEBUG)\n     (*dwarf2_debug_hooks.function_decl) (decl);\n@@ -1704,8 +1642,7 @@ vmsdbgout_decl (decl)\n /* Not implemented in VMS Debug.  */\n \n static void\n-vmsdbgout_global_decl (decl)\n-     tree decl;\n+vmsdbgout_global_decl (tree decl)\n {\n   if (write_symbols == VMS_AND_DWARF2_DEBUG)\n     (*dwarf2_debug_hooks.global_decl) (decl);\n@@ -1714,8 +1651,7 @@ vmsdbgout_global_decl (decl)\n /* Not implemented in VMS Debug.  */\n \n static void\n-vmsdbgout_abstract_function (decl)\n-     tree decl;\n+vmsdbgout_abstract_function (tree decl)\n {\n   if (write_symbols == VMS_AND_DWARF2_DEBUG)\n     (*dwarf2_debug_hooks.outlining_inline_function) (decl);\n@@ -1725,8 +1661,7 @@ vmsdbgout_abstract_function (decl)\n    VMS Debug debugging info.  */\n \n static void\n-vmsdbgout_finish (main_input_filename)\n-     const char *main_input_filename ATTRIBUTE_UNUSED;\n+vmsdbgout_finish (const char *main_input_filename ATTRIBUTE_UNUSED)\n {\n   unsigned int i;\n   int totsize;"}, {"sha": "ee6e3ada34e0bbeaca0f02e658b14e2aaa46683d", "filename": "gcc/xcoffout.c", "status": "modified", "additions": 19, "deletions": 42, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e1eedd6bb7d1e6358847d0ab912f13aa69ef403/gcc%2Fxcoffout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e1eedd6bb7d1e6358847d0ab912f13aa69ef403/gcc%2Fxcoffout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fxcoffout.c?ref=2e1eedd6bb7d1e6358847d0ab912f13aa69ef403", "patch": "@@ -1,5 +1,5 @@\n /* Output xcoff-format symbol table information from GNU compiler.\n-   Copyright (C) 1992, 1994, 1995, 1997, 1998, 1999, 2000, 2002\n+   Copyright (C) 1992, 1994, 1995, 1997, 1998, 1999, 2000, 2002, 2003\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -98,7 +98,7 @@ const char *xcoff_lastfile;\n        ? xcoff_current_include_file : main_input_filename); \\\n }\n \n-#define ASM_OUTPUT_LFE(FILE,LINENUM) \t\t\\\n+#define ASM_OUTPUT_LFE(FILE,LINENUM)\t\t\\\n   do\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\\\n       fprintf (FILE, \"\\t.ef\\t%d\\n\", (LINENUM));\t\\\n@@ -112,20 +112,17 @@ const char *xcoff_lastfile;\n #define ASM_OUTPUT_LBE(FILE,LINENUM,BLOCKNUM) \\\n   fprintf (FILE, \"\\t.eb\\t%d\\n\", ABS_OR_RELATIVE_LINENO (LINENUM))\n \n-static void assign_type_number\t\tPARAMS ((tree, const char *, int));\n-static void xcoffout_block\t\tPARAMS ((tree, int, tree));\n-static void xcoffout_source_file\tPARAMS ((FILE *, const char *, int));\n+static void assign_type_number (tree, const char *, int);\n+static void xcoffout_block (tree, int, tree);\n+static void xcoffout_source_file (FILE *, const char *, int);\n \f\n /* Support routines for XCOFF debugging info.  */\n \n /* Assign NUMBER as the stabx type number for the type described by NAME.\n    Search all decls in the list SYMS to find the type NAME.  */\n \n static void\n-assign_type_number (syms, name, number)\n-     tree syms;\n-     const char *name;\n-     int number;\n+assign_type_number (tree syms, const char *name, int number)\n {\n   tree decl;\n \n@@ -142,8 +139,7 @@ assign_type_number (syms, name, number)\n    possible.  */\n \n void\n-xcoff_output_standard_types (syms)\n-     tree syms;\n+xcoff_output_standard_types (tree syms)\n {\n   /* Handle built-in C types here.  */\n \n@@ -179,8 +175,7 @@ xcoff_output_standard_types (syms)\n /* Conversion routine from BSD stabs to AIX storage classes.  */\n \n int\n-stab_to_sclass (stab)\n-     int stab;\n+stab_to_sclass (int stab)\n {\n   switch (stab)\n     {\n@@ -282,10 +277,7 @@ stab_to_sclass (stab)\n    INLINE_P is true if this is from an inlined function.  */\n \n static void\n-xcoffout_source_file (file, filename, inline_p)\n-     FILE *file;\n-     const char *filename;\n-     int inline_p;\n+xcoffout_source_file (FILE *file, const char *filename, int inline_p)\n {\n   if (filename\n       && (xcoff_lastfile == 0 || strcmp (filename, xcoff_lastfile)\n@@ -314,9 +306,7 @@ xcoffout_source_file (file, filename, inline_p)\n /* Output a line number symbol entry for location (FILENAME, LINE).  */\n \n void\n-xcoffout_source_line (line, filename)\n-     unsigned int line;\n-     const char *filename;\n+xcoffout_source_line (unsigned int line, const char *filename)\n {\n   bool inline_p = (strcmp (xcoff_current_function_file, filename) != 0\n \t\t   || (int) line < xcoff_begin_function_line);\n@@ -334,10 +324,7 @@ xcoffout_source_line (line, filename)\n static int do_block = 0;\n \n static void\n-xcoffout_block (block, depth, args)\n-     tree block;\n-     int depth;\n-     tree args;\n+xcoffout_block (tree block, int depth, tree args)\n {\n   while (block)\n     {\n@@ -376,9 +363,7 @@ xcoffout_block (block, depth, args)\n    if the count starts at 0 for the outermost one.  */\n \n void\n-xcoffout_begin_block (line, n)\n-     unsigned int line;\n-     unsigned int n;\n+xcoffout_begin_block (unsigned int line, unsigned int n)\n {\n   tree decl = current_function_decl;\n \n@@ -394,9 +379,7 @@ xcoffout_begin_block (line, n)\n /* Describe the end line-number of an internal block within a function.  */\n \n void\n-xcoffout_end_block (line, n)\n-     unsigned int line;\n-     unsigned int n;\n+xcoffout_end_block (unsigned int line, unsigned int n)\n {\n   if (n != 1)\n     ASM_OUTPUT_LBE (asm_out_file, line, n);\n@@ -406,10 +389,7 @@ xcoffout_end_block (line, n)\n    Declare function as needed for debugging.  */\n \n void\n-xcoffout_declare_function (file, decl, name)\n-     FILE *file;\n-     tree decl;\n-     const char *name;\n+xcoffout_declare_function (FILE *file, tree decl, const char *name)\n {\n   int i;\n \n@@ -446,9 +426,8 @@ xcoffout_declare_function (file, decl, name)\n    Record the file name that this function is contained in.  */\n \n void\n-xcoffout_begin_prologue (line, file)\n-     unsigned int line;\n-     const char *file ATTRIBUTE_UNUSED;\n+xcoffout_begin_prologue (unsigned int line,\n+\t\t\t const char *file ATTRIBUTE_UNUSED)\n {\n   ASM_OUTPUT_LFB (asm_out_file, line);\n   dbxout_parms (DECL_ARGUMENTS (current_function_decl));\n@@ -468,8 +447,7 @@ xcoffout_begin_prologue (line, file)\n    Describe end of outermost block.  */\n \n void\n-xcoffout_end_function (last_linenum)\n-     unsigned int last_linenum;\n+xcoffout_end_function (unsigned int last_linenum)\n {\n   ASM_OUTPUT_LFE (asm_out_file, last_linenum);\n }\n@@ -478,9 +456,8 @@ xcoffout_end_function (last_linenum)\n    Called after the epilogue is output.  */\n \n void\n-xcoffout_end_epilogue (line, file)\n-     unsigned int line ATTRIBUTE_UNUSED;\n-     const char *file ATTRIBUTE_UNUSED;\n+xcoffout_end_epilogue (unsigned int line ATTRIBUTE_UNUSED,\n+\t\t       const char *file ATTRIBUTE_UNUSED)\n {\n   /* We need to pass the correct function size to .function, otherwise,\n      the xas assembler can't figure out the correct size for the function"}, {"sha": "2b830484febfe96eb4f86fd454bbb85b8df1a8c9", "filename": "gcc/xcoffout.h", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e1eedd6bb7d1e6358847d0ab912f13aa69ef403/gcc%2Fxcoffout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e1eedd6bb7d1e6358847d0ab912f13aa69ef403/gcc%2Fxcoffout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fxcoffout.h?ref=2e1eedd6bb7d1e6358847d0ab912f13aa69ef403", "patch": "@@ -1,6 +1,7 @@\n /* XCOFF definitions.  These are needed in dbxout.c, final.c,\n    and xcoffout.h.\n-   Copyright (C) 1998, 2000, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 2000, 2002, 2003\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -181,27 +182,24 @@ extern const char *xcoff_lastfile;\n \n /* Prototype functions in xcoffout.c.  */\n \n-extern int stab_to_sclass\t\t\tPARAMS ((int));\n+extern int stab_to_sclass (int);\n #ifdef BUFSIZ\n-extern void xcoffout_begin_prologue\t\tPARAMS ((unsigned int,\n-\t\t\t\t\t\t\t const char *));\n-extern void xcoffout_begin_block\t\tPARAMS ((unsigned, unsigned));\n-extern void xcoffout_end_epilogue\t\tPARAMS ((unsigned int,\n-\t\t\t\t\t\t\t const char *));\n-extern void xcoffout_end_function\t\tPARAMS ((unsigned int));\n-extern void xcoffout_end_block\t\t\tPARAMS ((unsigned, unsigned));\n+extern void xcoffout_begin_prologue (unsigned int, const char *);\n+extern void xcoffout_begin_block (unsigned, unsigned);\n+extern void xcoffout_end_epilogue (unsigned int, const char *);\n+extern void xcoffout_end_function (unsigned int);\n+extern void xcoffout_end_block (unsigned, unsigned);\n #endif /* BUFSIZ */\n \n #ifdef TREE_CODE\n-extern void xcoff_output_standard_types\t\tPARAMS ((tree));\n+extern void xcoff_output_standard_types (tree);\n #ifdef BUFSIZ\n-extern void xcoffout_declare_function\t\tPARAMS ((FILE *, tree, const char *));\n+extern void xcoffout_declare_function (FILE *, tree, const char *);\n #endif /* BUFSIZ */\n #endif /* TREE_CODE */\n \n #ifdef RTX_CODE\n #ifdef BUFSIZ\n-extern void xcoffout_source_line\t\tPARAMS ((unsigned int,\n-\t\t\t\t\t\t\t const char *));\n+extern void xcoffout_source_line (unsigned int, const char *);\n #endif /* BUFSIZ */\n #endif /* RTX_CODE */"}]}