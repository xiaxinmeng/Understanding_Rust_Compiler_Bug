{"sha": "32aa622ca800f92d7250e1ab4be08d3e174ef953", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzJhYTYyMmNhODAwZjkyZDcyNTBlMWFiNGJlMDhkM2UxNzRlZjk1Mw==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2010-12-22T12:56:54Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2010-12-22T12:56:54Z"}, "message": "re PR tree-optimization/45934 (g++.old-deja/g++.other/dtor5.C FAILs with -finline-small-functions)\n\n2010-12-22  Martin Jambor  <mjambor@suse.cz>\n\n\tPR tree-optimization/45934\n\tPR tree-optimization/46302\n\tPR tree-optimization/46987\n\t* gimple-fold.c (get_base_binfo_for_type): Removed.\n\t(gimple_get_relevant_ref_binfo): Likewise.\n\t(gimple_fold_obj_type_ref_call): Dumb down to 4.5 functionality,\n\tremoved parameter inplace, updated the caller.\n\t* gimple.h (gimple_get_relevant_ref_binfo): Remove declaration.\n\t* ipa-cp.c (ipcp_propagate_types): Do not derive types from constants.\n\t(ipcp_discover_new_direct_edges): Do not do devirtualization based on\n\tconstants.\n\t* ipa-prop.c (compute_known_type_jump_func): Use\n\tget_ref_base_and_extent and get_binfo_at_offset instead of\n\tgimple_get_relevant_ref_binfo.\n\t(compute_known_type_jump_func): Likewise.\n\t(update_jump_functions_after_inlining): Do not derive types from\n\tconstants.\n\t(try_make_edge_direct_virtual_call): Likewise.\n\t* tree.c (get_binfo_at_offset): Get type from non-artificial fields.\n\n\t* testsuite/g++.dg/ipa/ipcp-ivi-1.C: Removed.\n\t* testsuite/g++.dg/ipa/ivinline-6.C: Likewise.\n\t* testsuite/g++.dg/otr-fold-1.C: Likewise.\n\t* testsuite/g++.dg/otr-fold-2.C: Likewise.\n\t* testsuite/g++.dg/tree-ssa/pr43411.C: Xfail dump scan.\n\t* testsuite/g++.dg/tree-ssa/pr45605.C: Likewise.\n\t* testsuite/g++.dg/tree-ssa/pr46987.C: New test.\n\nFrom-SVN: r168168", "tree": {"sha": "a1cfc1bdd186a3e0990698cbae0cf216e7ac85d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a1cfc1bdd186a3e0990698cbae0cf216e7ac85d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/32aa622ca800f92d7250e1ab4be08d3e174ef953", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32aa622ca800f92d7250e1ab4be08d3e174ef953", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32aa622ca800f92d7250e1ab4be08d3e174ef953", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32aa622ca800f92d7250e1ab4be08d3e174ef953/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5eeac8330cbea6aa8d170473b7eab105734fb1d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5eeac8330cbea6aa8d170473b7eab105734fb1d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5eeac8330cbea6aa8d170473b7eab105734fb1d8"}], "stats": {"total": 568, "additions": 108, "deletions": 460}, "files": [{"sha": "cbbd5aece33422597f34297fb962673eba890157", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32aa622ca800f92d7250e1ab4be08d3e174ef953/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32aa622ca800f92d7250e1ab4be08d3e174ef953/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=32aa622ca800f92d7250e1ab4be08d3e174ef953", "patch": "@@ -1,3 +1,25 @@\n+2010-12-22  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR tree-optimization/45934\n+\tPR tree-optimization/46302\n+\tPR tree-optimization/46987\n+\t* gimple-fold.c (get_base_binfo_for_type): Removed.\n+\t(gimple_get_relevant_ref_binfo): Likewise.\n+\t(gimple_fold_obj_type_ref_call): Dumb down to 4.5 functionality,\n+\tremoved parameter inplace, updated the caller.\n+\t* gimple.h (gimple_get_relevant_ref_binfo): Remove declaration.\n+\t* ipa-cp.c (ipcp_propagate_types): Do not derive types from constants.\n+\t(ipcp_discover_new_direct_edges): Do not do devirtualization based on\n+\tconstants.\n+\t* ipa-prop.c (compute_known_type_jump_func): Use\n+\tget_ref_base_and_extent and get_binfo_at_offset instead of\n+\tgimple_get_relevant_ref_binfo.\n+\t(compute_known_type_jump_func): Likewise.\n+\t(update_jump_functions_after_inlining): Do not derive types from\n+\tconstants.\n+\t(try_make_edge_direct_virtual_call): Likewise.\n+\t* tree.c (get_binfo_at_offset): Get type from non-artificial fields.\n+\n 2010-12-22  Joseph Myers  <joseph@codesourcery.com>\n \n \t* config/svr4.h: Remove."}, {"sha": "16a2092f043ff35ad727020b774c9657616bc097", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 11, "deletions": 99, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32aa622ca800f92d7250e1ab4be08d3e174ef953/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32aa622ca800f92d7250e1ab4be08d3e174ef953/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=32aa622ca800f92d7250e1ab4be08d3e174ef953", "patch": "@@ -1364,88 +1364,6 @@ gimple_fold_builtin (gimple stmt)\n   return result;\n }\n \n-/* Search for a base binfo of BINFO that corresponds to TYPE and return it if\n-   it is found or NULL_TREE if it is not.  */\n-\n-static tree\n-get_base_binfo_for_type (tree binfo, tree type)\n-{\n-  int i;\n-  tree base_binfo;\n-  tree res = NULL_TREE;\n-\n-  for (i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n-    if (TREE_TYPE (base_binfo) == type)\n-      {\n-\tgcc_assert (!res);\n-\tres = base_binfo;\n-      }\n-\n-  return res;\n-}\n-\n-/* Return a binfo describing the part of object referenced by expression REF.\n-   Return NULL_TREE if it cannot be determined.  REF can consist of a series of\n-   COMPONENT_REFs of a declaration or of an INDIRECT_REF or it can also be just\n-   a simple declaration, indirect reference or an SSA_NAME.  If the function\n-   discovers an INDIRECT_REF or an SSA_NAME, it will assume that the\n-   encapsulating type is described by KNOWN_BINFO, if it is not NULL_TREE.\n-   Otherwise the first non-artificial field declaration or the base declaration\n-   will be examined to get the encapsulating type. */\n-\n-tree\n-gimple_get_relevant_ref_binfo (tree ref, tree known_binfo)\n-{\n-  while (true)\n-    {\n-      if (TREE_CODE (ref) == COMPONENT_REF)\n-\t{\n-\t  tree par_type;\n-\t  tree binfo;\n-\t  tree field = TREE_OPERAND (ref, 1);\n-\n-\t  if (!DECL_ARTIFICIAL (field))\n-\t    {\n-\t      tree type = TREE_TYPE (field);\n-\t      if (TREE_CODE (type) == RECORD_TYPE)\n-\t\treturn TYPE_BINFO (type);\n-\t      else\n-\t\treturn NULL_TREE;\n-\t    }\n-\n-\t  par_type = TREE_TYPE (TREE_OPERAND (ref, 0));\n-\t  binfo = TYPE_BINFO (par_type);\n-\t  if (!binfo\n-\t      || BINFO_N_BASE_BINFOS (binfo) == 0)\n-\t    return NULL_TREE;\n-\n-\t  /* Offset 0 indicates the primary base, whose vtable contents are\n-\t     represented in the binfo for the derived class.  */\n-\t  if (int_bit_position (field) != 0)\n-\t    {\n-\t      tree d_binfo;\n-\n-\t      /* Get descendant binfo. */\n-\t      d_binfo = gimple_get_relevant_ref_binfo (TREE_OPERAND (ref, 0),\n-\t\t\t\t\t\t       known_binfo);\n-\t      if (!d_binfo)\n-\t\treturn NULL_TREE;\n-\t      return get_base_binfo_for_type (d_binfo, TREE_TYPE (field));\n-\t    }\n-\n-\t  ref = TREE_OPERAND (ref, 0);\n-\t}\n-      else if (DECL_P (ref) && TREE_CODE (TREE_TYPE (ref)) == RECORD_TYPE)\n-\treturn TYPE_BINFO (TREE_TYPE (ref));\n-      else if (known_binfo\n-\t       && (TREE_CODE (ref) == SSA_NAME\n-\t\t   || TREE_CODE (ref) == MEM_REF))\n-\treturn known_binfo;\n-      else\n-\treturn NULL_TREE;\n-    }\n-}\n-\n /* Return a declaration of a function which an OBJ_TYPE_REF references. TOKEN\n    is integer form of OBJ_TYPE_REF_TOKEN of the reference expression.\n    KNOWN_BINFO carries the binfo describing the true type of\n@@ -1529,35 +1447,29 @@ gimple_adjust_this_by_delta (gimple_stmt_iterator *gsi, tree delta)\n    INPLACE is false.  Return true iff the statement was changed.  */\n \n static bool\n-gimple_fold_obj_type_ref_call (gimple_stmt_iterator *gsi, bool inplace)\n+gimple_fold_obj_type_ref_call (gimple_stmt_iterator *gsi)\n {\n   gimple stmt = gsi_stmt (*gsi);\n   tree ref = gimple_call_fn (stmt);\n   tree obj = OBJ_TYPE_REF_OBJECT (ref);\n   tree binfo, fndecl, delta;\n   HOST_WIDE_INT token;\n \n-  if (TREE_CODE (obj) == ADDR_EXPR)\n-    obj = TREE_OPERAND (obj, 0);\n-  else\n+  if (TREE_CODE (obj) != ADDR_EXPR)\n     return false;\n-\n-  binfo = gimple_get_relevant_ref_binfo (obj, NULL_TREE);\n+  obj = TREE_OPERAND (obj, 0);\n+  if (!DECL_P (obj)\n+      || TREE_CODE (TREE_TYPE (obj)) != RECORD_TYPE)\n+    return false;\n+  binfo = TYPE_BINFO (TREE_TYPE (obj));\n   if (!binfo)\n     return false;\n+\n   token = tree_low_cst (OBJ_TYPE_REF_TOKEN (ref), 1);\n-  fndecl = gimple_get_virt_mehtod_for_binfo (token, binfo, &delta,\n-\t\t\t\t\t     !DECL_P (obj));\n+  fndecl = gimple_get_virt_mehtod_for_binfo (token, binfo, &delta, false);\n   if (!fndecl)\n     return false;\n-\n-  if (integer_nonzerop (delta))\n-    {\n-      if (inplace)\n-        return false;\n-      gimple_adjust_this_by_delta (gsi, delta);\n-    }\n-\n+  gcc_assert (integer_zerop (delta));\n   gimple_call_set_fndecl (stmt, fndecl);\n   return true;\n }\n@@ -1595,7 +1507,7 @@ gimple_fold_call (gimple_stmt_iterator *gsi, bool inplace)\n          here where we can just smash the call operand.  */\n       callee = gimple_call_fn (stmt);\n       if (TREE_CODE (callee) == OBJ_TYPE_REF)\n-\treturn gimple_fold_obj_type_ref_call (gsi, inplace);\n+\treturn gimple_fold_obj_type_ref_call (gsi);\n     }\n \n   return false;"}, {"sha": "cc35b6099b01bb0da05194c1ebe7d0b6b9b391ad", "filename": "gcc/gimple.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32aa622ca800f92d7250e1ab4be08d3e174ef953/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32aa622ca800f92d7250e1ab4be08d3e174ef953/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=32aa622ca800f92d7250e1ab4be08d3e174ef953", "patch": "@@ -892,7 +892,6 @@ unsigned get_gimple_rhs_num_ops (enum tree_code);\n gimple gimple_alloc_stat (enum gimple_code, unsigned MEM_STAT_DECL);\n const char *gimple_decl_printable_name (tree, int);\n bool gimple_fold_call (gimple_stmt_iterator *gsi, bool inplace);\n-tree gimple_get_relevant_ref_binfo (tree ref, tree known_binfo);\n tree gimple_get_virt_mehtod_for_binfo (HOST_WIDE_INT, tree, tree *, bool);\n void gimple_adjust_this_by_delta (gimple_stmt_iterator *, tree);\n /* Returns true iff T is a valid GIMPLE statement.  */"}, {"sha": "ce6fd598715b7e94404c941fd8b924d7680385e4", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 4, "deletions": 36, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32aa622ca800f92d7250e1ab4be08d3e174ef953/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32aa622ca800f92d7250e1ab4be08d3e174ef953/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=32aa622ca800f92d7250e1ab4be08d3e174ef953", "patch": "@@ -781,26 +781,16 @@ ipcp_propagate_types (struct ipa_node_params *caller_info,\n \t\t      struct ipa_node_params *callee_info,\n \t\t      struct ipa_jump_func *jf, int i)\n {\n-  tree cst, binfo;\n-\n   switch (jf->type)\n     {\n     case IPA_JF_UNKNOWN:\n     case IPA_JF_CONST_MEMBER_PTR:\n+    case IPA_JF_CONST:\n       break;\n \n     case IPA_JF_KNOWN_TYPE:\n       return ipcp_add_param_type (callee_info, i, jf->value.base_binfo);\n \n-    case IPA_JF_CONST:\n-      cst = jf->value.constant;\n-      if (TREE_CODE (cst) != ADDR_EXPR)\n-\tbreak;\n-      binfo = gimple_get_relevant_ref_binfo (TREE_OPERAND (cst, 0), NULL_TREE);\n-      if (!binfo)\n-\tbreak;\n-      return ipcp_add_param_type (callee_info, i, binfo);\n-\n     case IPA_JF_PASS_THROUGH:\n     case IPA_JF_ANCESTOR:\n       return ipcp_copy_types (caller_info, callee_info, i, jf);\n@@ -1292,35 +1282,13 @@ ipcp_discover_new_direct_edges (struct cgraph_node *node, int index, tree cst)\n   for (ie = node->indirect_calls; ie; ie = next_ie)\n     {\n       struct cgraph_indirect_call_info *ici = ie->indirect_info;\n-      tree target, delta = NULL_TREE;\n \n       next_ie = ie->next_callee;\n-      if (ici->param_index != index)\n+      if (ici->param_index != index\n+\t  || ici->polymorphic)\n \tcontinue;\n \n-      if (ici->polymorphic)\n-\t{\n-\t  tree binfo;\n-\t  HOST_WIDE_INT token;\n-\n-\t  if (TREE_CODE (cst) != ADDR_EXPR)\n-\t    continue;\n-\n-\t  binfo = gimple_get_relevant_ref_binfo (TREE_OPERAND (cst, 0),\n-\t\t\t\t\t\t NULL_TREE);\n-\t  if (!binfo)\n-\t    continue;\n-\t  gcc_assert (ie->indirect_info->anc_offset == 0);\n-\t  token = ie->indirect_info->otr_token;\n-\t  target = gimple_get_virt_mehtod_for_binfo (token, binfo, &delta,\n-\t\t\t\t\t\t     true);\n-\t  if (!target)\n-\t    continue;\n-\t}\n-      else\n-\ttarget = cst;\n-\n-      ipa_make_edge_direct_to_target (ie, target, delta);\n+      ipa_make_edge_direct_to_target (ie, cst, NULL_TREE);\n     }\n }\n "}, {"sha": "b6e3f37c6786664f65780d613144485b8104c35b", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 25, "deletions": 31, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32aa622ca800f92d7250e1ab4be08d3e174ef953/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32aa622ca800f92d7250e1ab4be08d3e174ef953/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=32aa622ca800f92d7250e1ab4be08d3e174ef953", "patch": "@@ -362,7 +362,7 @@ compute_complex_assign_jump_func (struct ipa_node_params *info,\n \t\t\t\t  gimple stmt, tree name)\n {\n   HOST_WIDE_INT offset, size, max_size;\n-  tree op1, op2, type;\n+  tree op1, op2, base, type;\n   int index;\n \n   op1 = gimple_assign_rhs1 (stmt);\n@@ -404,20 +404,21 @@ compute_complex_assign_jump_func (struct ipa_node_params *info,\n   type = TREE_TYPE (op1);\n   if (TREE_CODE (type) != RECORD_TYPE)\n     return;\n-  op1 = get_ref_base_and_extent (op1, &offset, &size, &max_size);\n-  if (TREE_CODE (op1) != MEM_REF\n+  base = get_ref_base_and_extent (op1, &offset, &size, &max_size);\n+  if (TREE_CODE (base) != MEM_REF\n       /* If this is a varying address, punt.  */\n       || max_size == -1\n       || max_size != size)\n     return;\n-  offset += mem_ref_offset (op1).low * BITS_PER_UNIT;\n-  op1 = TREE_OPERAND (op1, 0);\n-  if (TREE_CODE (op1) != SSA_NAME\n-      || !SSA_NAME_IS_DEFAULT_DEF (op1)\n+  offset += mem_ref_offset (base).low * BITS_PER_UNIT;\n+  base = TREE_OPERAND (base, 0);\n+  if (TREE_CODE (base) != SSA_NAME\n+      || !SSA_NAME_IS_DEFAULT_DEF (base)\n       || offset < 0)\n     return;\n \n-  index = ipa_get_param_decl_index (info, SSA_NAME_VAR (op1));\n+  /* Dynamic types are changed only in constructors and destructors and  */\n+  index = ipa_get_param_decl_index (info, SSA_NAME_VAR (base));\n   if (index >= 0)\n     {\n       jfunc->type = IPA_JF_ANCESTOR;\n@@ -534,13 +535,26 @@ compute_complex_ancestor_jump_func (struct ipa_node_params *info,\n static void\n compute_known_type_jump_func (tree op, struct ipa_jump_func *jfunc)\n {\n-  tree binfo;\n+  HOST_WIDE_INT offset, size, max_size;\n+  tree base, binfo;\n \n-  if (TREE_CODE (op) != ADDR_EXPR)\n+  if (TREE_CODE (op) != ADDR_EXPR\n+      || TREE_CODE (TREE_TYPE (TREE_TYPE (op))) != RECORD_TYPE)\n     return;\n \n   op = TREE_OPERAND (op, 0);\n-  binfo = gimple_get_relevant_ref_binfo (op, NULL_TREE);\n+  base = get_ref_base_and_extent (op, &offset, &size, &max_size);\n+  if (!DECL_P (base)\n+      || max_size == -1\n+      || max_size != size\n+      || TREE_CODE (TREE_TYPE (base)) != RECORD_TYPE\n+      || is_global_var (base))\n+    return;\n+\n+  binfo = TYPE_BINFO (TREE_TYPE (base));\n+  if (!binfo)\n+    return;\n+  binfo = get_binfo_at_offset (binfo, offset, TREE_TYPE (op));\n   if (binfo)\n     {\n       jfunc->type = IPA_JF_KNOWN_TYPE;\n@@ -1420,17 +1434,6 @@ update_jump_functions_after_inlining (struct cgraph_edge *cs,\n \t  src = ipa_get_ith_jump_func (top, dst->value.ancestor.formal_id);\n \t  if (src->type == IPA_JF_KNOWN_TYPE)\n \t    combine_known_type_and_ancestor_jfs (src, dst);\n-\t  else if (src->type == IPA_JF_CONST)\n-\t    {\n-\t      struct ipa_jump_func kt_func;\n-\n-\t      kt_func.type = IPA_JF_UNKNOWN;\n-\t      compute_known_type_jump_func (src->value.constant, &kt_func);\n-\t      if (kt_func.type == IPA_JF_KNOWN_TYPE)\n-\t\tcombine_known_type_and_ancestor_jfs (&kt_func, dst);\n-\t      else\n-\t\tdst->type = IPA_JF_UNKNOWN;\n-\t    }\n \t  else if (src->type == IPA_JF_PASS_THROUGH\n \t\t   && src->value.pass_through.operation == NOP_EXPR)\n \t    dst->value.ancestor.formal_id = src->value.pass_through.formal_id;\n@@ -1543,15 +1546,6 @@ try_make_edge_direct_virtual_call (struct cgraph_edge *ie,\n \n   if (jfunc->type == IPA_JF_KNOWN_TYPE)\n     binfo = jfunc->value.base_binfo;\n-  else if (jfunc->type == IPA_JF_CONST)\n-    {\n-      tree cst = jfunc->value.constant;\n-      if (TREE_CODE (cst) == ADDR_EXPR)\n-\tbinfo = gimple_get_relevant_ref_binfo (TREE_OPERAND (cst, 0),\n-\t\t\t\t\t       NULL_TREE);\n-      else\n-  \treturn NULL;\n-    }\n   else\n     return NULL;\n "}, {"sha": "dd58aa54524a667d6928fb33eef5525fefcec0f1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32aa622ca800f92d7250e1ab4be08d3e174ef953/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32aa622ca800f92d7250e1ab4be08d3e174ef953/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=32aa622ca800f92d7250e1ab4be08d3e174ef953", "patch": "@@ -1,3 +1,16 @@\n+2010-12-22  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR tree-optimization/45934\n+\tPR tree-optimization/46302\n+\tPR tree-optimization/46987\n+\t* g++.dg/ipa/ipcp-ivi-1.C: Removed.\n+\t* g++.dg/ipa/ivinline-6.C: Likewise.\n+\t* g++.dg/otr-fold-1.C: Likewise.\n+\t* g++.dg/otr-fold-2.C: Likewise.\n+\t* g++.dg/tree-ssa/pr43411.C: Xfail dump scan.\n+\t* g++.dg/tree-ssa/pr45605.C: Likewise.\n+\t* g++.dg/tree-ssa/pr46987.C: New test.\n+\n 2010-12-22  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* gfortran.dg/pr46755.f: Fix test case."}, {"sha": "5b12a15c086931826e6bfea5529eea3ec0642056", "filename": "gcc/testsuite/g++.dg/ipa/ipcp-ivi-1.C", "status": "removed", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5eeac8330cbea6aa8d170473b7eab105734fb1d8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fipcp-ivi-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5eeac8330cbea6aa8d170473b7eab105734fb1d8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fipcp-ivi-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fipcp-ivi-1.C?ref=5eeac8330cbea6aa8d170473b7eab105734fb1d8", "patch": "@@ -1,65 +0,0 @@\n-/* Verify that simple virtual calls are inlined even without early\n-   inlining.  */\n-/* { dg-do run } */\n-/* { dg-options \"-O3 -fdump-ipa-inline -fno-early-inlining\"  } */\n-\n-extern \"C\" void abort (void);\n-\n-class A\n-{\n-public:\n-  int data;\n-  virtual int foo (int i);\n-};\n-\n-class B : public A\n-{\n-public:\n-  virtual int foo (int i);\n-};\n-\n-class C : public A\n-{\n-public:\n-  virtual int foo (int i);\n-};\n-\n-int A::foo (int i)\n-{\n-  return i + 1;\n-}\n-\n-int B::foo (int i)\n-{\n-  return i + 2;\n-}\n-\n-int C::foo (int i)\n-{\n-  return i + 3;\n-}\n-\n-int __attribute__ ((noinline)) middleman (class A *obj, int i)\n-{\n-  return obj->foo (i);\n-}\n-\n-int __attribute__ ((noinline,noclone)) get_input(void)\n-{\n-  return 1;\n-}\n-\n-class B b;\n-\n-int main (int argc, char *argv[])\n-{\n-  int i;\n-\n-  for (i = 0; i < get_input (); i++)\n-    if (middleman (&b, get_input ()) != 3)\n-      abort ();\n-  return 0;\n-}\n-\n-/* { dg-final { scan-ipa-dump \"B::foo\\[^\\\\n\\]*inline copy in int.*middleman\"  \"inline\"  } } */\n-/* { dg-final { cleanup-ipa-dump \"inline\" } } */"}, {"sha": "202e9e187694fa52857da851159a392503582a5e", "filename": "gcc/testsuite/g++.dg/ipa/ivinline-6.C", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5eeac8330cbea6aa8d170473b7eab105734fb1d8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fivinline-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5eeac8330cbea6aa8d170473b7eab105734fb1d8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fivinline-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fivinline-6.C?ref=5eeac8330cbea6aa8d170473b7eab105734fb1d8", "patch": "@@ -1,58 +0,0 @@\n-/* Verify that virtual call inlining works also when it has to get the\n-   type from an ipa invariant and that even in this case it does not\n-   pick a wrong method when there is a user defined ancestor in an\n-   object.  */\n-/* { dg-do run } */\n-/* { dg-options \"-O3 -fdump-ipa-inline -fno-early-inlining -fno-ipa-cp\"  } */\n-\n-extern \"C\" void abort (void);\n-\n-class A\n-{\n-public:\n-  int data;\n-  virtual int foo (int i);\n-};\n-\n-class B : public A\n-{\n-public:\n-  class A confusion;\n-  virtual int foo (int i);\n-};\n-\n-int A::foo (int i)\n-{\n-  return i + 1;\n-}\n-\n-int B::foo (int i)\n-{\n-  return i + 2;\n-}\n-\n-int middleman (class A *obj, int i)\n-{\n-  return obj->foo (i);\n-}\n-\n-int __attribute__ ((noinline,noclone)) get_input(void)\n-{\n-  return 1;\n-}\n-\n-class B b;\n-\n-int main (int argc, char *argv[])\n-{\n-  int i, j = get_input ();\n-\n-  for (i = 0; i < j; i++)\n-    if ((middleman (&b, j) + 100 * middleman (&b.confusion, j)) != 203)\n-      abort ();\n-  return 0;\n-}\n-\n-/* { dg-final { scan-ipa-dump \"A::foo\\[^\\\\n\\]*inline copy in int main\"  \"inline\"  } } */\n-/* { dg-final { scan-ipa-dump \"B::foo\\[^\\\\n\\]*inline copy in int main\"  \"inline\"  } } */\n-/* { dg-final { cleanup-ipa-dump \"inline\" } } */"}, {"sha": "2364730487e6109068c871e45fc195c163e8c8c1", "filename": "gcc/testsuite/g++.dg/otr-fold-1.C", "status": "removed", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5eeac8330cbea6aa8d170473b7eab105734fb1d8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fotr-fold-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5eeac8330cbea6aa8d170473b7eab105734fb1d8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fotr-fold-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fotr-fold-1.C?ref=5eeac8330cbea6aa8d170473b7eab105734fb1d8", "patch": "@@ -1,76 +0,0 @@\n-/* Verify that virtual calls are folded even when a typecast to an\n-   ancestor is involved along the way.  */\n-/* { dg-do run } */\n-/* { dg-options \"-O -fdump-tree-optimized-slim\"  } */\n-\n-extern \"C\" void abort (void);\n-\n-class Distraction\n-{\n-public:\n-  float f;\n-  double d;\n-  Distraction ()\n-  {\n-    f = 8.3;\n-    d = 10.2;\n-  }\n-  virtual float bar (float z);\n-};\n-\n-class A\n-{\n-public:\n-  int data;\n-  virtual int foo (int i);\n-};\n-\n-\n-class B : public Distraction, public A\n-{\n-public:\n-  virtual int foo (int i);\n-};\n-\n-float Distraction::bar (float z)\n-{\n-  f += z;\n-  return f/2;\n-}\n-\n-int A::foo (int i)\n-{\n-  return i + 1;\n-}\n-\n-int B::foo (int i)\n-{\n-  return i + 2;\n-}\n-\n-int __attribute__ ((noinline,noclone)) get_input(void)\n-{\n-  return 1;\n-}\n-\n-static inline int middleman_1 (class A *obj, int i)\n-{\n-  return obj->foo (i);\n-}\n-\n-static inline int middleman_2 (class B *obj, int i)\n-{\n-  return middleman_1 (obj, i);\n-}\n-\n-int main (int argc, char *argv[])\n-{\n-  class B b;\n-\n-  if (middleman_2 (&b, get_input ()) != 3)\n-    abort ();\n-  return 0;\n-}\n-\n-/* { dg-final { scan-tree-dump \"= B::.*foo\"  \"optimized\"  } } */\n-/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "a3cd1b5e66f2cef708dfcdd52ad51186e149da34", "filename": "gcc/testsuite/g++.dg/otr-fold-2.C", "status": "removed", "additions": 0, "deletions": 88, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5eeac8330cbea6aa8d170473b7eab105734fb1d8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fotr-fold-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5eeac8330cbea6aa8d170473b7eab105734fb1d8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fotr-fold-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fotr-fold-2.C?ref=5eeac8330cbea6aa8d170473b7eab105734fb1d8", "patch": "@@ -1,88 +0,0 @@\n-/* Verify that virtual calls are folded even when a typecast to an\n-   ancestor is involved along the way.  */\n-/* { dg-do run } */\n-/* { dg-options \"-O -fdump-tree-optimized-slim\"  } */\n-\n-extern \"C\" void abort (void);\n-\n-class Distraction\n-{\n-public:\n-  float f;\n-  double d;\n-  Distraction ()\n-  {\n-    f = 8.3;\n-    d = 10.2;\n-  }\n-  virtual float bar (float z);\n-};\n-\n-class A\n-{\n-public:\n-  int data;\n-  virtual int foo (int i);\n-};\n-\n-class A_2 : public A\n-{\n-public:\n-  int data_2;\n-  virtual int baz (int i);\n-};\n-\n-\n-class B : public Distraction, public A_2\n-{\n-public:\n-  virtual int foo (int i);\n-};\n-\n-float Distraction::bar (float z)\n-{\n-  f += z;\n-  return f/2;\n-}\n-\n-int A::foo (int i)\n-{\n-  return i + 1;\n-}\n-\n-int A_2::baz (int i)\n-{\n-  return i * 15;\n-}\n-\n-int B::foo (int i)\n-{\n-  return i + 2;\n-}\n-\n-int __attribute__ ((noinline,noclone)) get_input(void)\n-{\n-  return 1;\n-}\n-\n-static inline int middleman_1 (class A *obj, int i)\n-{\n-  return obj->foo (i);\n-}\n-\n-static inline int middleman_2 (class A *obj, int i)\n-{\n-  return middleman_1 (obj, i);\n-}\n-\n-int main (int argc, char *argv[])\n-{\n-  class B b;\n-\n-  if (middleman_2 (&b, get_input ()) != 3)\n-    abort ();\n-  return 0;\n-}\n-\n-/* { dg-final { scan-tree-dump \"= B::.*foo\"  \"optimized\"  } } */\n-/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "476e16ad2367f54e4eba8da4bed8117d2f907d04", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr43411.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32aa622ca800f92d7250e1ab4be08d3e174ef953/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr43411.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32aa622ca800f92d7250e1ab4be08d3e174ef953/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr43411.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr43411.C?ref=32aa622ca800f92d7250e1ab4be08d3e174ef953", "patch": "@@ -25,5 +25,5 @@ void testInlinePsub() {\n     sink1 = v(p);\n }\n \n-// { dg-final { scan-tree-dump-not \"OBJ_TYPE_REF\" \"optimized\" } }\n+// { dg-final { scan-tree-dump-not \"OBJ_TYPE_REF\" \"optimized\" { xfail *-*-* } } }\n // { dg-final { cleanup-tree-dump \"optimized\" } }"}, {"sha": "861b122e56f874e6a95c42cf53a6e622775b5a94", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr45605.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32aa622ca800f92d7250e1ab4be08d3e174ef953/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr45605.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32aa622ca800f92d7250e1ab4be08d3e174ef953/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr45605.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr45605.C?ref=32aa622ca800f92d7250e1ab4be08d3e174ef953", "patch": "@@ -33,5 +33,5 @@ int main() {\n \n \n /* We should devirtualize call to D::Run */\n-/* { dg-final { scan-tree-dump-times \"D::Run \\\\(\" 1 \"ssa\"} } */\n+/* { dg-final { scan-tree-dump-times \"D::Run \\\\(\" 1 \"ssa\" { xfail *-*-* } } } */\n /* { dg-final { cleanup-tree-dump \"ssa\" } } */"}, {"sha": "7163915a29856fd83f233663b562db4fc1eba45d", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr46987.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32aa622ca800f92d7250e1ab4be08d3e174ef953/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr46987.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32aa622ca800f92d7250e1ab4be08d3e174ef953/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr46987.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr46987.C?ref=32aa622ca800f92d7250e1ab4be08d3e174ef953", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O\" } */\n+\n+struct A {\n+  virtual A *getThis();\n+};\n+\n+struct B {\n+  virtual B *getThis();\n+};\n+\n+struct AB : public A, public B {\n+  virtual AB *getThis() { return 0; }\n+};\n+\n+void foo ()\n+{\n+  AB ab;\n+  B *b = &ab;\n+  b->getThis();\n+}\n+"}, {"sha": "26622789bf611b7e716f544c00bd6a8234f0ced7", "filename": "gcc/tree.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32aa622ca800f92d7250e1ab4be08d3e174ef953/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32aa622ca800f92d7250e1ab4be08d3e174ef953/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=32aa622ca800f92d7250e1ab4be08d3e174ef953", "patch": "@@ -10949,8 +10949,7 @@ get_binfo_at_offset (tree binfo, HOST_WIDE_INT offset, tree expected_type)\n \n       if (type == expected_type)\n \t  return binfo;\n-      if (TREE_CODE (type) != RECORD_TYPE\n-\t  || offset < 0)\n+      if (offset < 0)\n \treturn NULL_TREE;\n \n       for (fld = TYPE_FIELDS (type); fld; fld = DECL_CHAIN (fld))\n@@ -10963,12 +10962,18 @@ get_binfo_at_offset (tree binfo, HOST_WIDE_INT offset, tree expected_type)\n \t  if (pos <= offset && (pos + size) > offset)\n \t    break;\n \t}\n-      if (!fld || !DECL_ARTIFICIAL (fld))\n+      if (!fld || TREE_CODE (TREE_TYPE (fld)) != RECORD_TYPE)\n \treturn NULL_TREE;\n \n+      if (!DECL_ARTIFICIAL (fld))\n+\t{\n+\t  binfo = TYPE_BINFO (TREE_TYPE (fld));\n+\t  if (!binfo)\n+\t    return NULL_TREE;\n+\t}\n       /* Offset 0 indicates the primary base, whose vtable contents are\n \t represented in the binfo for the derived class.  */\n-      if (offset != 0)\n+      else if (offset != 0)\n \t{\n \t  tree base_binfo, found_binfo = NULL_TREE;\n \t  for (i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)"}]}