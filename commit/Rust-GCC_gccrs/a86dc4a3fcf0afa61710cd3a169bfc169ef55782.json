{"sha": "a86dc4a3fcf0afa61710cd3a169bfc169ef55782", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTg2ZGM0YTNmY2YwYWZhNjE3MTBjZDNhMTY5YmZjMTY5ZWY1NTc4Mg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2000-09-12T14:43:25Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-09-12T14:43:25Z"}, "message": "* unroll.c: Fix formatting.\n\nFrom-SVN: r36361", "tree": {"sha": "cbacfc109692cd91f9164a6f223d58fef301467d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cbacfc109692cd91f9164a6f223d58fef301467d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a86dc4a3fcf0afa61710cd3a169bfc169ef55782", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a86dc4a3fcf0afa61710cd3a169bfc169ef55782", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a86dc4a3fcf0afa61710cd3a169bfc169ef55782", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a86dc4a3fcf0afa61710cd3a169bfc169ef55782/comments", "author": null, "committer": null, "parents": [{"sha": "57939159aa9c2799048f2655366c0182fe8f713e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57939159aa9c2799048f2655366c0182fe8f713e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57939159aa9c2799048f2655366c0182fe8f713e"}], "stats": {"total": 123, "additions": 59, "deletions": 64}, "files": [{"sha": "69c4c329e8643eba63bd08e1ffb44c09c3a6cec3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a86dc4a3fcf0afa61710cd3a169bfc169ef55782/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a86dc4a3fcf0afa61710cd3a169bfc169ef55782/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a86dc4a3fcf0afa61710cd3a169bfc169ef55782", "patch": "@@ -1,3 +1,7 @@\n+2000-09-12  Kazu Hirata  <kazu@hxi.com>\n+\n+\t* unroll.c: Fix formatting.\n+\n 2000-09-12  Bruce Korb  <bkorb@gnu.org>\n \n \t* fixinc/fixfixes.c: make a type for the fix procedure & use it,"}, {"sha": "255e1039336fbf85df18408fb897ecf7d7889cf3", "filename": "gcc/unroll.c", "status": "modified", "additions": 55, "deletions": 64, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a86dc4a3fcf0afa61710cd3a169bfc169ef55782/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a86dc4a3fcf0afa61710cd3a169bfc169ef55782/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=a86dc4a3fcf0afa61710cd3a169bfc169ef55782", "patch": "@@ -1,6 +1,6 @@\n /* Try to unroll loops, and split induction variables.\n-   Copyright (C) 1992, 1993, 1994, 1995, 1997, 1998,\n-   1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 1993, 1994, 1995, 1997, 1998, 1999, 2000\n+   Free Software Foundation, Inc.\n    Contributed by James E. Wilson, Cygnus Support/UC Berkeley.\n \n This file is part of GNU CC.\n@@ -140,12 +140,17 @@ Boston, MA 02111-1307, USA.  */\n \n #define NUM_FACTORS 4\n \n-struct _factor { int factor, count; } factors[NUM_FACTORS]\n-  = { {2, 0}, {3, 0}, {5, 0}, {7, 0}};\n+struct _factor { int factor, count; }\n+factors[NUM_FACTORS] = { {2, 0}, {3, 0}, {5, 0}, {7, 0}};\n \n /* Describes the different types of loop unrolling performed.  */\n \n-enum unroll_types { UNROLL_COMPLETELY, UNROLL_MODULO, UNROLL_NAIVE };\n+enum unroll_types\n+{\n+  UNROLL_COMPLETELY,\n+  UNROLL_MODULO,\n+  UNROLL_NAIVE\n+};\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -206,7 +211,7 @@ static void copy_loop_body PARAMS ((struct loop *, rtx, rtx,\n \t\t\t\t    enum unroll_types, rtx, rtx, rtx, rtx));\n static int find_splittable_regs PARAMS ((const struct loop *,\n \t\t\t\t\t enum unroll_types, rtx, int));\n-static int find_splittable_givs PARAMS ((const struct loop *, \n+static int find_splittable_givs PARAMS ((const struct loop *,\n \t\t\t\t\t struct iv_class *, enum unroll_types,\n \t\t\t\t\t rtx, int));\n static int reg_dead_after_loop PARAMS ((const struct loop *, rtx));\n@@ -357,7 +362,7 @@ unroll_loop (loop, insn_count, end_insert_before, strength_reduce_p)\n       rtx ujump = ujump_to_loop_cont (loop->start, loop->cont);\n       if (ujump)\n \tdelete_insn (ujump);\n-\t\n+\n       /* If number of iterations is exactly 1, then eliminate the compare and\n \t branch at the end of the loop since they will never be taken.\n \t Then return, since no other action is needed here.  */\n@@ -443,14 +448,12 @@ unroll_loop (loop, insn_count, end_insert_before, strength_reduce_p)\n       if (unroll_number == 1)\n \t{\n \t  if (loop_dump_stream)\n-\t    fprintf (loop_dump_stream,\n-\t\t     \"Loop unrolling: No factors found.\\n\");\n+\t    fprintf (loop_dump_stream, \"Loop unrolling: No factors found.\\n\");\n \t}\n       else\n \tunroll_type = UNROLL_MODULO;\n     }\n \n-\n   /* Default case, calculate number of times to unroll loop based on its\n      size.  */\n   if (unroll_type == UNROLL_NAIVE)\n@@ -466,9 +469,7 @@ unroll_loop (loop, insn_count, end_insert_before, strength_reduce_p)\n   /* Now we know how many times to unroll the loop.  */\n \n   if (loop_dump_stream)\n-    fprintf (loop_dump_stream,\n-\t     \"Unrolling loop %d times.\\n\", unroll_number);\n-\n+    fprintf (loop_dump_stream, \"Unrolling loop %d times.\\n\", unroll_number);\n \n   if (unroll_type == UNROLL_COMPLETELY || unroll_type == UNROLL_MODULO)\n     {\n@@ -767,9 +768,7 @@ unroll_loop (loop, insn_count, end_insert_before, strength_reduce_p)\n \t      for (i = 0; i < len; i++)\n \t\t{\n \t\t  label = XEXP (XVECEXP (pat, diff_vec_p, i), 0);\n-\t\t  set_label_in_map (map,\n-\t\t\t\t    CODE_LABEL_NUMBER (label),\n-\t\t\t\t    label);\n+\t\t  set_label_in_map (map, CODE_LABEL_NUMBER (label), label);\n \t\t}\n \t    }\n \t}\n@@ -828,7 +827,8 @@ unroll_loop (loop, insn_count, end_insert_before, strength_reduce_p)\n       /* If we have a target that uses cc0, then we also must not duplicate\n \t the insn that sets cc0 before the jump insn, if one is present.  */\n #ifdef HAVE_cc0\n-      if (GET_CODE (copy_end) == JUMP_INSN && sets_cc0_p (PREV_INSN (copy_end)))\n+      if (GET_CODE (copy_end) == JUMP_INSN\n+\t  && sets_cc0_p (PREV_INSN (copy_end)))\n \tcopy_end_luid--;\n #endif\n \n@@ -913,7 +913,7 @@ unroll_loop (loop, insn_count, end_insert_before, strength_reduce_p)\n \t\t\t       &initial_value, &final_value, &increment,\n \t\t\t       &mode))\n \t{\n-\t  register rtx diff ;\n+\t  register rtx diff;\n \t  rtx *labels;\n \t  int abs_inc, neg_inc;\n \n@@ -936,7 +936,7 @@ unroll_loop (loop, insn_count, end_insert_before, strength_reduce_p)\n \t  abs_inc = INTVAL (increment);\n \t  if (abs_inc < 0)\n \t    {\n-\t      abs_inc = - abs_inc;\n+\t      abs_inc = -abs_inc;\n \t      neg_inc = 1;\n \t    }\n \n@@ -1071,8 +1071,8 @@ unroll_loop (loop, insn_count, end_insert_before, strength_reduce_p)\n \t    {\n \t      copy_end = PREV_INSN (last_loop_insn);\n #ifdef HAVE_cc0\n-\t      /* The immediately preceding insn may be a compare which we do not\n-\t\t want to copy.  */\n+\t      /* The immediately preceding insn may be a compare which\n+\t\t we do not want to copy.  */\n \t      if (sets_cc0_p (PREV_INSN (copy_end)))\n \t\tcopy_end = PREV_INSN (copy_end);\n #endif\n@@ -1132,8 +1132,9 @@ unroll_loop (loop, insn_count, end_insert_before, strength_reduce_p)\n \t    {\n \t      insert_before = last_loop_insn;\n #ifdef HAVE_cc0\n-\t      /* The instruction immediately before the JUMP_INSN may be a compare\n-\t\t instruction which we do not want to copy or delete.  */\n+\t      /* The instruction immediately before the JUMP_INSN may\n+\t\t be a compare instruction which we do not want to copy\n+\t\t or delete.  */\n \t      if (sets_cc0_p (PREV_INSN (insert_before)))\n \t\tinsert_before = PREV_INSN (insert_before);\n #endif\n@@ -1154,7 +1155,8 @@ unroll_loop (loop, insn_count, end_insert_before, strength_reduce_p)\n   if (unroll_type == UNROLL_NAIVE && ! flag_unroll_all_loops)\n     {\n       if (loop_dump_stream)\n-\tfprintf (loop_dump_stream, \"Unrolling failure: Naive unrolling not being done.\\n\");\n+\tfprintf (loop_dump_stream,\n+\t\t \"Unrolling failure: Naive unrolling not being done.\\n\");\n       goto egress;\n     }\n \n@@ -1419,7 +1421,7 @@ precondition_loop_p (loop, initial_value, final_value, increment, mode)\n       return 0;\n     }\n   else if ((exact_log2 (INTVAL (loop_info->increment)) < 0)\n-\t   && (exact_log2 (- INTVAL (loop_info->increment)) < 0))\n+\t   && (exact_log2 (-INTVAL (loop_info->increment)) < 0))\n     {\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream,\n@@ -1510,7 +1512,6 @@ precondition_loop_p (loop, initial_value, final_value, increment, mode)\n   return 1;\n }\n \n-\n /* All pseudo-registers must be mapped to themselves.  Two hard registers\n    must be mapped, VIRTUAL_STACK_VARS_REGNUM and VIRTUAL_INCOMING_ARGS_\n    REGNUM, to avoid function-inlining specific conversions of these\n@@ -1739,8 +1740,7 @@ copy_loop_body (loop, copy_start, copy_end, map, exit_label, last_iteration,\n   if (! last_iteration)\n     {\n       final_label = gen_label_rtx ();\n-      set_label_in_map (map, CODE_LABEL_NUMBER (start_label),\n-\t\t\tfinal_label);\n+      set_label_in_map (map, CODE_LABEL_NUMBER (start_label), final_label);\n     }\n   else\n     set_label_in_map (map, CODE_LABEL_NUMBER (start_label), start_label);\n@@ -1857,7 +1857,7 @@ copy_loop_body (loop, copy_start, copy_end, map, exit_label, last_iteration,\n \t\t\t   We must subtract the const_adjust factor added in\n \t\t\t   above.  */\n \t\t\ttv->dest_reg = plus_constant (dest_reg,\n-\t\t\t\t\t\t      - tv->const_adjust);\n+\t\t\t\t\t\t      -tv->const_adjust);\n \t\t\t*tv->location = tv->dest_reg;\n \t\t      }\n \t\t  }\n@@ -2073,7 +2073,7 @@ copy_loop_body (loop, copy_start, copy_end, map, exit_label, last_iteration,\n \t\t  emit_label_after (lab, jmp);\n \t\t  LABEL_NUSES (lab) = 0;\n \t\t  if (!redirect_jump (copy, lab, 0))\n-\t\t    abort();\n+\t\t    abort ();\n \t\t}\n \t    }\n \n@@ -2209,7 +2209,7 @@ copy_loop_body (loop, copy_start, copy_end, map, exit_label, last_iteration,\n \t  /* VTOP and CONT notes are valid only before the loop exit test.\n \t     If placed anywhere else, loop may generate bad code.  */\n \t  /* BASIC_BLOCK notes exist to stabilize basic block structures with\n-\t     the associated rtl.  We do not want to share the structure in \n+\t     the associated rtl.  We do not want to share the structure in\n \t     this new block.  */\n \n \t  if (NOTE_LINE_NUMBER (insn) != NOTE_INSN_DELETED\n@@ -2430,7 +2430,6 @@ biv_total_increment (bl)\n   return result;\n }\n \n-\n /* For each biv and giv, determine whether it can be safely split into\n    a different variable for each unrolled copy of the loop body.  If it\n    is safe to split, then indicate that by saving some useful info\n@@ -2541,7 +2540,8 @@ find_splittable_regs (loop, unroll_type, end_insert_before, unroll_number)\n \t\t\t\t    loop_start);\n \n \t\t  if (loop_dump_stream)\n-\t\t    fprintf (loop_dump_stream, \"Biv %d initial value remapped to %d.\\n\",\n+\t\t    fprintf (loop_dump_stream,\n+\t\t\t     \"Biv %d initial value remapped to %d.\\n\",\n \t\t\t     bl->regno, REGNO (tem));\n \n \t\t  splittable_regs[bl->regno] = tem;\n@@ -2568,7 +2568,7 @@ find_splittable_regs (loop, unroll_type, end_insert_before, unroll_number)\n \t depend on it may be splittable if the biv is live outside the\n \t loop, and the givs aren't.  */\n \n-      result += find_splittable_givs (loop, bl, unroll_type, increment, \n+      result += find_splittable_givs (loop, bl, unroll_type, increment,\n \t\t\t\t      unroll_number);\n \n       /* If final value is non-zero, then must emit an instruction which sets\n@@ -2927,7 +2927,7 @@ find_splittable_givs (loop, bl, unroll_type, increment, unroll_number)\n \t\t\t  /* Save the negative of the eliminated const, so\n \t\t\t     that we can calculate the dest_reg's increment\n \t\t\t     value later.  */\n-\t\t\t  v->const_adjust = - INTVAL (XEXP (new_reg, 1));\n+\t\t\t  v->const_adjust = -INTVAL (XEXP (new_reg, 1));\n \n \t\t\t  new_reg = XEXP (new_reg, 0);\n \t\t\t  if (loop_dump_stream)\n@@ -3155,7 +3155,7 @@ reg_dead_after_loop (loop, reg)\n   label = gen_rtx_LABEL_REF (VOIDmode, loop->end);\n   LABEL_NEXTREF (label) = loop->exit_labels;\n \n-  for ( ; label; label = LABEL_NEXTREF (label))\n+  for (; label; label = LABEL_NEXTREF (label))\n     {\n       /* Succeed if find an insn which sets the biv or if reach end of\n \t function.  Fail if find an insn that uses the biv, or if come to\n@@ -3215,7 +3215,7 @@ final_biv_value (loop, bl)\n     return 0;\n \n   /* The final value for reversed bivs must be calculated differently than\n-      for ordinary bivs.  In this case, there is already an insn after the\n+     for ordinary bivs.  In this case, there is already an insn after the\n      loop which sets this biv's final value (if necessary), and there are\n      no other loop exits, so we can return any value.  */\n   if (bl->reversed)\n@@ -3373,8 +3373,7 @@ final_giv_value (loop, v)\n \t    }\n \n \t  /* Now calculate the giv's final value.  */\n-\t  emit_iv_add_mult (tem, v->mult_val, v->add_val, tem,\n-\t\t\t    insert_before);\n+\t  emit_iv_add_mult (tem, v->mult_val, v->add_val, tem, insert_before);\n \n \t  if (loop_dump_stream)\n \t    fprintf (loop_dump_stream,\n@@ -3403,7 +3402,6 @@ final_giv_value (loop, v)\n   return 0;\n }\n \n-\n /* Look back before LOOP->START for then insn that sets REG and return\n    the equivalent constant if there is a REG_EQUAL note otherwise just\n    the SET_SRC of REG.  */\n@@ -3418,7 +3416,7 @@ loop_find_equiv_value (loop, reg)\n   rtx ret;\n \n   ret = reg;\n-  for (insn = PREV_INSN (loop_start); insn ; insn = PREV_INSN (insn))\n+  for (insn = PREV_INSN (loop_start); insn; insn = PREV_INSN (insn))\n     {\n       if (GET_CODE (insn) == CODE_LABEL)\n \tbreak;\n@@ -3429,7 +3427,7 @@ loop_find_equiv_value (loop, reg)\n \t     If it sets the entire register, and has a REG_EQUAL note,\n \t     then use the value of the REG_EQUAL note.  */\n \t  if ((set = single_set (insn))\n-\t\t  && (SET_DEST (set) == reg))\n+\t      && (SET_DEST (set) == reg))\n \t    {\n \t      rtx note = find_reg_note (insn, REG_EQUAL, NULL_RTX);\n \n@@ -3480,7 +3478,6 @@ subtract_reg_term (op, reg)\n   abort ();\n }\n \n-\n /* Find and return register term common to both expressions OP0 and\n    OP1 or NULL_RTX if no such term exists.  Each expression must be a\n    REG or a PLUS of a REG.  */\n@@ -3518,7 +3515,6 @@ find_common_reg_term (op0, op1)\n   return NULL_RTX;\n }\n \n-\n /* Determine the loop iterator and calculate the number of loop\n    iterations.  Returns the exact number of loop iterations if it can\n    be calculated, otherwise returns zero.  */\n@@ -3768,7 +3764,7 @@ loop_iterations (loop)\n      its value from the insns before the start of the loop.  */\n \n   final_value = comparison_value;\n-  if (GET_CODE (comparison_value) == REG \n+  if (GET_CODE (comparison_value) == REG\n       && loop_invariant_p (loop, comparison_value))\n     {\n       final_value = loop_find_equiv_value (loop, comparison_value);\n@@ -3855,12 +3851,12 @@ loop_iterations (loop)\n \t{\n \t  rtx temp;\n \n-\t  /*  When running the loop optimizer twice, check_dbra_loop\n-\t      further obfuscates reversible loops of the form:\n-\t      for (i = init; i < init + const; i++).  We often end up with\n-\t      final_value = 0, initial_value = temp, temp = temp2 - init,\n-\t      where temp2 = init + const.  If the loop has a vtop we\n-\t      can replace initial_value with const.  */\n+\t  /* When running the loop optimizer twice, check_dbra_loop\n+\t     further obfuscates reversible loops of the form:\n+\t     for (i = init; i < init + const; i++).  We often end up with\n+\t     final_value = 0, initial_value = temp, temp = temp2 - init,\n+\t     where temp2 = init + const.  If the loop has a vtop we\n+\t     can replace initial_value with const.  */\n \n \t  temp = loop_find_equiv_value (loop, reg1);\n \n@@ -3898,7 +3894,7 @@ loop_iterations (loop)\n      Check this now so that we won't leave an invalid value if we\n      return early for any other reason.  */\n   if (comparison_code == EQ)\n-      loop_info->final_equiv_value = loop_info->final_value = 0;\n+    loop_info->final_equiv_value = loop_info->final_value = 0;\n \n   if (increment == 0)\n     {\n@@ -3944,8 +3940,7 @@ loop_iterations (loop)\n   else if (comparison_code == EQ)\n     {\n       if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n-\t\t \"Loop iterations: EQ comparison loop.\\n\");\n+\tfprintf (loop_dump_stream, \"Loop iterations: EQ comparison loop.\\n\");\n       return 0;\n     }\n   else if (GET_CODE (final_value) != CONST_INT)\n@@ -4012,8 +4007,7 @@ loop_iterations (loop)\n   else\n     {\n       if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n-\t\t \"Loop iterations: Not normal loop.\\n\");\n+\tfprintf (loop_dump_stream, \"Loop iterations: Not normal loop.\\n\");\n       return 0;\n     }\n \n@@ -4046,7 +4040,6 @@ loop_iterations (loop)\n   return loop_info->n_iterations;\n }\n \n-\n /* Replace uses of split bivs with their split pseudo register.  This is\n    for original instructions which remain after loop unrolling without\n    copying.  */\n@@ -4135,7 +4128,7 @@ set_dominates_use (regno, first_uid, last_uid, copy_start, copy_end)\n   while (INSN_UID (p) != first_uid)\n     {\n       if (GET_CODE (p) == JUMP_INSN)\n-\tpassed_jump= 1;\n+\tpassed_jump = 1;\n       /* Could not find FIRST_UID.  */\n       if (p == copy_end)\n \treturn 0;\n@@ -4172,10 +4165,11 @@ set_dominates_use (regno, first_uid, last_uid, copy_start, copy_end)\n    unconditional branch to the loop continuation note (or a label just after).\n    In this case, the unconditional branch that starts the loop needs to be\n    deleted so that we execute the single iteration.  */\n+\n static rtx\n ujump_to_loop_cont (loop_start, loop_cont)\n-      rtx loop_start;\n-      rtx loop_cont;\n+     rtx loop_start;\n+     rtx loop_cont;\n {\n   rtx x, label, label_ref;\n \n@@ -4196,11 +4190,8 @@ ujump_to_loop_cont (loop_start, loop_cont)\n     return NULL_RTX;\n \n   /* Return the loop start if the branch label matches the code label.  */\n-  if (CODE_LABEL_NUMBER (label) == CODE_LABEL_NUMBER (XEXP (label_ref,0)))\n+  if (CODE_LABEL_NUMBER (label) == CODE_LABEL_NUMBER (XEXP (label_ref, 0)))\n     return loop_start;\n   else\n     return NULL_RTX;\n-\n }\n-\n-"}]}