{"sha": "679debeea3913242cd756be013e329ed8ab92af4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njc5ZGViZWVhMzkxMzI0MmNkNzU2YmUwMTNlMzI5ZWQ4YWI5MmFmNA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2011-07-22T09:21:49Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2011-07-22T09:21:49Z"}, "message": "re PR c++/49756 (g++ ICE)\n\n\tPR c++/49756\n\t* libiberty.h (stack_limit_increase): New prototype.\n\n\t* stack-limit.c: New file.\n\t* Makefile.in: Regenerate deps.\n\t(CFILES): Add stack-limit.c.\n\t(REQUIRED_OFILES): Add ./stack-limit.$(objext).\n\t* configure.ac (checkfuncs): Add getrlimit and setrlimit.\n\t(AC_CHECK_FUNCS): Likewise.\n\t* configure: Regenerated.\n\t* config.in: Regenerated.\n\n\t* gcc.c (main): Call stack_limit_increase (64MB).\n\t* toplev.c (toplev_main): Likewise.\n\nFrom-SVN: r176622", "tree": {"sha": "f7e71ba3ab802ea17dc5cf71aa00ee0e6f8acc76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f7e71ba3ab802ea17dc5cf71aa00ee0e6f8acc76"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/679debeea3913242cd756be013e329ed8ab92af4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/679debeea3913242cd756be013e329ed8ab92af4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/679debeea3913242cd756be013e329ed8ab92af4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/679debeea3913242cd756be013e329ed8ab92af4/comments", "author": null, "committer": null, "parents": [{"sha": "50823f95fd725137d863850e8d5e765ad8c2df67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50823f95fd725137d863850e8d5e765ad8c2df67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50823f95fd725137d863850e8d5e765ad8c2df67"}], "stats": {"total": 59, "additions": 59, "deletions": 0}, "files": [{"sha": "28541b1d423beb13c1b7bcb1bad0139e3333ccc4", "filename": "libiberty/stack-limit.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/679debeea3913242cd756be013e329ed8ab92af4/libiberty%2Fstack-limit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/679debeea3913242cd756be013e329ed8ab92af4/libiberty%2Fstack-limit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fstack-limit.c?ref=679debeea3913242cd756be013e329ed8ab92af4", "patch": "@@ -0,0 +1,59 @@\n+/* Increase stack size limit if possible.\n+   Copyright (C) 2011 Free Software Foundation, Inc.\n+\n+This file is part of the libiberty library.  This library is free\n+software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+This library is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 51 Franklin Street - Fifth Floor,\n+Boston, MA 02110-1301, USA.\n+\n+As a special exception, if you link this library with files\n+compiled with a GNU compiler to produce an executable, this does not cause\n+the resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why\n+the executable file might be covered by the GNU General Public License. */\n+\n+/*\n+\n+@deftypefn Extension void stack_limit_increase (unsigned long @var{pref})\n+\n+Attempt to increase stack size limit to @var{pref} bytes if possible.\n+\n+@end deftypefn\n+\n+*/\n+\n+#include \"config.h\"\n+\n+#ifdef HAVE_SYS_RESOURCE_H\n+#include <sys/resource.h>\n+#endif\n+\n+void\n+stack_limit_increase (unsigned long pref)\n+{\n+#if defined(HAVE_SETRLIMIT) && defined(HAVE_GETRLIMIT) \\\n+    && defined(RLIMIT_STACK) && defined(RLIM_INFINITY)\n+  struct rlimit rlim;\n+  if (getrlimit (RLIMIT_STACK, &rlim) == 0\n+      && rlim.rlim_cur != RLIM_INFINITY\n+      && rlim.rlim_cur < pref\n+      && (rlim.rlim_max == RLIM_INFINITY || rlim.rlim_cur < rlim.rlim_max))\n+    {\n+      rlim.rlim_cur = pref;\n+      if (rlim.rlim_max != RLIM_INFINITY && rlim.rlim_cur > rlim.rlim_max)\n+\trlim.rlim_cur = rlim.rlim_max;\n+      setrlimit (RLIMIT_STACK, &rlim);\n+    }\n+#endif\n+}"}]}