{"sha": "7193d1dc3d0359e9f3257d3b75d5050fa73187b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzE5M2QxZGMzZDAzNTllOWYzMjU3ZDNiNzVkNTA1MGZhNzMxODdiMw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-01-19T18:28:58Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-01-19T18:28:58Z"}, "message": "rtl.texi (SET, CLOBBER): Document PARALLEL as SET_DEST possibility.\n\n\t* rtl.texi (SET, CLOBBER): Document PARALLEL as SET_DEST possibility.\n\t* flow.c (mark_set_1, case PARALLEL): Don't require BLKmode, allow\n\telement to be null, and always expect an EXPR_LIST.\n\t* rtlanal.c (reg_overlap_mentioned_p, note_stores): Likewise.\n\t* sched-deps.c (sched_analyze_1): Likewise.\n\t* sched-rgn.c (check_live_1, update_live_1): Likewise.\n\nFrom-SVN: r39141", "tree": {"sha": "086e54d82c89c2d5ce11a4c14e8e7c5454d17972", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/086e54d82c89c2d5ce11a4c14e8e7c5454d17972"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7193d1dc3d0359e9f3257d3b75d5050fa73187b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7193d1dc3d0359e9f3257d3b75d5050fa73187b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7193d1dc3d0359e9f3257d3b75d5050fa73187b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7193d1dc3d0359e9f3257d3b75d5050fa73187b3/comments", "author": null, "committer": null, "parents": [{"sha": "79b9ec0ddb066613d4bf6a64b12eb45ea8fdcd95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79b9ec0ddb066613d4bf6a64b12eb45ea8fdcd95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79b9ec0ddb066613d4bf6a64b12eb45ea8fdcd95"}], "stats": {"total": 121, "additions": 53, "deletions": 68}, "files": [{"sha": "10023e080b699ef0f6c0d014326c4a5f9788fbba", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7193d1dc3d0359e9f3257d3b75d5050fa73187b3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7193d1dc3d0359e9f3257d3b75d5050fa73187b3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7193d1dc3d0359e9f3257d3b75d5050fa73187b3", "patch": "@@ -1,5 +1,12 @@\n Fri Jan 19 13:02:56 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* rtl.texi (SET, CLOBBER): Document PARALLEL as SET_DEST possibility.\n+\t* flow.c (mark_set_1, case PARALLEL): Don't require BLKmode, allow\n+\telement to be null, and always expect an EXPR_LIST.\n+\t* rtlanal.c (reg_overlap_mentioned_p, note_stores): Likewise.\n+\t* sched-deps.c (sched_analyze_1): Likewise.\n+\t* sched-rgn.c (check_live_1, update_live_1): Likewise.\n+\n \t* regclass.c (max_set_parallel): New variable.\n \t(reg_scan): Take it into account in computation of max_parallel.\n \t(reg_scan_mark_refs, case SET): Compute it."}, {"sha": "2e76e3d398fa7c49861d69e1528eb20e93f9ebfe", "filename": "gcc/flow.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7193d1dc3d0359e9f3257d3b75d5050fa73187b3/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7193d1dc3d0359e9f3257d3b75d5050fa73187b3/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=7193d1dc3d0359e9f3257d3b75d5050fa73187b3", "patch": "@@ -4660,19 +4660,11 @@ mark_set_1 (pbi, code, reg, cond, insn, flags)\n     case PARALLEL:\n       /* Some targets place small structures in registers for return values of\n \t functions.  We have to detect this case specially here to get correct\n-\t flow information.  Note that each element might be either a REG\n-\t or an EXPR_LIST whose first operand is a REG.  */\n-      if (GET_MODE (reg) != BLKmode)\n-\tabort ();\n-\n+\t flow information.  */\n       for (i = XVECLEN (reg, 0) - 1; i >= 0; i--)\n-\t{\n-\t  rtx elmt = XVECEXP (reg, 0, i);\n-\n-\t  mark_set_1 (pbi, code,\n-\t\t      GET_CODE (elmt) == EXPR_LIST ? XEXP (elmt, 0) : elmt,\n-\t\t      cond, insn, flags);\n-\t}\n+\tif (XEXP (XVECEXP (reg, 0, i), 0) != 0)\n+\t  mark_set_1 (pbi, code, XEXP (XVECEXP (reg, 0, i), 0), cond, insn,\n+\t\t      flags);\n       return;\n \n     case ZERO_EXTRACT:"}, {"sha": "4cb0eb7014b354fe310f505c8de2af064e0d0c88", "filename": "gcc/rtl.texi", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7193d1dc3d0359e9f3257d3b75d5050fa73187b3/gcc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7193d1dc3d0359e9f3257d3b75d5050fa73187b3/gcc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.texi?ref=7193d1dc3d0359e9f3257d3b75d5050fa73187b3", "patch": "@@ -1923,8 +1923,8 @@ the operands of these.\n @item (set @var{lval} @var{x})\n Represents the action of storing the value of @var{x} into the place\n represented by @var{lval}.  @var{lval} must be an expression\n-representing a place that can be stored in: @code{reg} (or\n-@code{subreg} or @code{strict_low_part}), @code{mem}, @code{pc} or\n+representing a place that can be stored in: @code{reg} (or @code{subreg}\n+or @code{strict_low_part}), @code{mem}, @code{pc}, @code{parallel}, or\n @code{cc0}.@refill\n \n If @var{lval} is a @code{reg}, @code{subreg} or @code{mem}, it has a\n@@ -1950,6 +1950,14 @@ The latter case represents a ``test'' instruction.  The expression\n @code{(set (cc0) (compare (reg:@var{m} @var{n}) (const_int 0)))}.\n Use the former expression to save space during the compilation.\n \n+If @var{lval} is a @code{parallel}, it is used to represent the case of\n+a function returning a structure in multiple registers.  Each element\n+of the @code{paralllel} is an @code{expr_list} whose first operand is a\n+@code{reg} and whose second operand is a @code{const_int} representing the\n+offset (in bytes) into the structure at which the data in that register\n+corresponds.  The first element may be null to indicate that the structure\n+is also passed partly in memory.\n+\n @cindex jump instructions and @code{set}\n @cindex @code{if_then_else} usage\n If @var{lval} is @code{(pc)}, we have a jump instruction, and the\n@@ -2006,7 +2014,7 @@ addressed.\n @item (clobber @var{x})\n Represents the storing or possible storing of an unpredictable,\n undescribed value into @var{x}, which must be a @code{reg},\n-@code{scratch} or @code{mem} expression.\n+@code{scratch}, @code{parallel} or @code{mem} expression.\n \n One place this is used is in string instructions that store standard\n values into particular hard registers.  It may not be worth the\n@@ -2015,7 +2023,8 @@ inform the compiler that the registers will be altered, lest it\n attempt to keep data in them across the string instruction.\n \n If @var{x} is @code{(mem:BLK (const_int 0))}, it means that all memory\n-locations must be presumed clobbered.\n+locations must be presumed clobbered.  If @var{x} is a @code{parallel},\n+it has the same meaning as a @code{parallel} in a @code{set} expression.\n \n Note that the machine description classifies certain hard registers as\n ``call-clobbered''.  All function call instructions are assumed by"}, {"sha": "ff75d5c58326ae93004dfa8da36846203d39c1c1", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 17, "deletions": 25, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7193d1dc3d0359e9f3257d3b75d5050fa73187b3/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7193d1dc3d0359e9f3257d3b75d5050fa73187b3/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=7193d1dc3d0359e9f3257d3b75d5050fa73187b3", "patch": "@@ -1185,18 +1185,11 @@ reg_overlap_mentioned_p (x, in)\n \tint i;\n \n \t/* If any register in here refers to it we return true.  */\n-\tfor (i = XVECLEN (x, 0); i >= 0; i--)\n-\t  {\n-\t    rtx reg = XVECEXP (x, 0, i);\n-\n-\t    if (GET_CODE (reg) == EXPR_LIST)\n-\t      reg = XEXP (reg, 0);\n-\n-\t    if (reg_overlap_mentioned_p (reg, in))\n+\tfor (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n+\t  if (XEXP (XVECEXP (x, 0, i), 0) != 0\n+\t      && reg_overlap_mentioned_p (XEXP (XVECEXP (x, 0, i), 0), in))\n \t      return 1;\n-\t    return 0;\n-\t  \n-\t  }\n+\treturn 0;\n       }\n \n     default:\n@@ -1288,20 +1281,19 @@ note_stores (x, fun, data)\n \t     || GET_CODE (dest) == STRICT_LOW_PART)\n \tdest = XEXP (dest, 0);\n \n-      /* If we have a PARALLEL, SET_DEST is a list of registers or\n-\t EXPR_LIST expressions, each of whose first operand is a register.\n-\t We can't know what precisely is being set in these cases, so\n-\t make up a CLOBBER to pass to the function.  */\n-      if (GET_CODE (dest) == PARALLEL && GET_MODE (dest) == BLKmode)\n-\tfor (i = XVECLEN (dest, 0) - 1; i >= 0; i--)\n-\t  {\n-\t    rtx reg = XVECEXP (dest, 0, i);\n-\n-\t    if (GET_CODE (reg) == EXPR_LIST)\n-\t      reg = XEXP (reg, 0);\n-\n-\t    (*fun) (reg, gen_rtx_CLOBBER (VOIDmode, reg), data);\n-\t  }\n+      /* If we have a PARALLEL, SET_DEST is a list of EXPR_LIST expressions,\n+\t each of whose first operand is a register.  We can't know what\n+\t precisely is being set in these cases, so make up a CLOBBER to pass\n+\t to the function.  */\n+      if (GET_CODE (dest) == PARALLEL)\n+\t{\n+\t  for (i = XVECLEN (dest, 0) - 1; i >= 0; i--)\n+\t    if (XEXP (XVECEXP (dest, 0, i), 0) != 0)\n+\t      (*fun) (XEXP (XVECEXP (dest, 0, i), 0),\n+\t\t      gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t       XEXP (XVECEXP (dest, 0, i), 0)),\n+\t\t      data);\n+\t}\n       else\n \t(*fun) (dest, x, data);\n     }"}, {"sha": "904b37e1d4cf5ec1b2f66937299283de992a7ab4", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7193d1dc3d0359e9f3257d3b75d5050fa73187b3/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7193d1dc3d0359e9f3257d3b75d5050fa73187b3/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=7193d1dc3d0359e9f3257d3b75d5050fa73187b3", "patch": "@@ -551,19 +551,16 @@ sched_analyze_1 (deps, x, insn)\n   if (dest == 0)\n     return;\n \n-  if (GET_CODE (dest) == PARALLEL && GET_MODE (dest) == BLKmode)\n+  if (GET_CODE (dest) == PARALLEL)\n     {\n       register int i;\n \n       for (i = XVECLEN (dest, 0) - 1; i >= 0; i--)\n-\t{\n-\t  rtx reg = XVECEXP (dest, 0, i);\n-\n-\t  if (GET_CODE (reg) == EXPR_LIST)\n-\t    reg = XEXP (reg, 0);\n-\n-\t  sched_analyze_1 (deps, reg, insn);\n-\t}\n+\tif (XEXP (XVECEXP (dest, 0, i), 0) != 0)\n+\t  sched_analyze_1 (deps,\n+\t\t\t   gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t\t    XEXP (XVECEXP (dest, 0, i), 0)),\n+\t\t\t   insn);\n \n       if (GET_CODE (x) == SET)\n \tsched_analyze_2 (deps, SET_SRC (x), insn);"}, {"sha": "41989cc0cd659f11db8650c906d64645370113fa", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7193d1dc3d0359e9f3257d3b75d5050fa73187b3/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7193d1dc3d0359e9f3257d3b75d5050fa73187b3/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=7193d1dc3d0359e9f3257d3b75d5050fa73187b3", "patch": "@@ -1396,20 +1396,14 @@ check_live_1 (src, x)\n \t || GET_CODE (reg) == STRICT_LOW_PART)\n     reg = XEXP (reg, 0);\n \n-  if (GET_CODE (reg) == PARALLEL && GET_MODE (reg) == BLKmode)\n+  if (GET_CODE (reg) == PARALLEL)\n     {\n       register int i;\n \n       for (i = XVECLEN (reg, 0) - 1; i >= 0; i--)\n-\t{\n-\t  rtx dest = XVECEXP (reg, 0, i);\n-\n-\t  if (GET_CODE (dest) == EXPR_LIST)\n-\t    dest = XEXP (dest, 0);\n-\n-\t  if (check_live_1 (src, dest))\n+\tif (XEXP (XVECEXP (reg, 0, i), 0) != 0)\n+\t  if (check_live_1 (src, XEXP (XVECEXP (reg, 0, i), 0)))\n \t    return 1;\n-\t}\n \n       return 0;\n     }\n@@ -1482,19 +1476,13 @@ update_live_1 (src, x)\n \t || GET_CODE (reg) == STRICT_LOW_PART)\n     reg = XEXP (reg, 0);\n \n-  if (GET_CODE (reg) == PARALLEL && GET_MODE (reg) == BLKmode)\n+  if (GET_CODE (reg) == PARALLEL)\n     {\n       register int i;\n \n       for (i = XVECLEN (reg, 0) - 1; i >= 0; i--)\n-\t{\n-\t  rtx dest = XVECEXP (reg, 0, i);\n-\n-\t  if (GET_CODE (dest) == EXPR_LIST)\n-\t    dest = XEXP (dest, 0);\n-\n-\t  update_live_1 (src, dest);\n-\t}\n+\tif (XEXP (XVECEXP (reg, 0, i), 0) != 0)\n+\t  update_live_1 (src, XEXP (XVECEXP (reg, 0, i), 0));\n \n       return;\n     }"}]}