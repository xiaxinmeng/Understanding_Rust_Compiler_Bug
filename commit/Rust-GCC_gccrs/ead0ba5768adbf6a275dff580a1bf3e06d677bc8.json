{"sha": "ead0ba5768adbf6a275dff580a1bf3e06d677bc8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFkMGJhNTc2OGFkYmY2YTI3NWRmZjU4MGExYmYzZTA2ZDY3N2JjOA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-02-08T21:04:41Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-02-08T21:04:41Z"}, "message": "re PR ipa/63566 (i686 bootstrap fails: ICE RTL flag check: INSN_UID used with unexpected rtx code 'set' in INSN_UID, at rtl.h:1326)\n\n\tPR ipa/63566 \n\t* i386.c (ix86_function_regparm): Look through aliases to see if callee\n\tis local and optimized.\n\t(ix86_function_sseregparm): Likewise; also use target's SSE math\n\tsettings; error out instead of silently generating wrong code\n\ton mismatches.\n\t(init_cumulative_args): Look through aliases.\n\nFrom-SVN: r220520", "tree": {"sha": "beb502ec43c74edeb22c7d98d6bfc42f95238842", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/beb502ec43c74edeb22c7d98d6bfc42f95238842"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ead0ba5768adbf6a275dff580a1bf3e06d677bc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ead0ba5768adbf6a275dff580a1bf3e06d677bc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ead0ba5768adbf6a275dff580a1bf3e06d677bc8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ead0ba5768adbf6a275dff580a1bf3e06d677bc8/comments", "author": null, "committer": null, "parents": [{"sha": "42685f72ca64d15f0d4ae46efa1297cefdbbc846", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42685f72ca64d15f0d4ae46efa1297cefdbbc846", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42685f72ca64d15f0d4ae46efa1297cefdbbc846"}], "stats": {"total": 129, "additions": 86, "deletions": 43}, "files": [{"sha": "83019f916986e18d574f4f5c60314d246d852b5c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead0ba5768adbf6a275dff580a1bf3e06d677bc8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead0ba5768adbf6a275dff580a1bf3e06d677bc8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ead0ba5768adbf6a275dff580a1bf3e06d677bc8", "patch": "@@ -1,3 +1,13 @@\n+2015-02-08  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/63566 \n+\t* i386.c (ix86_function_regparm): Look through aliases to see if callee\n+\tis local and optimized.\n+\t(ix86_function_sseregparm): Likewise; also use target's SSE math\n+\tsettings; error out instead of silently generating wrong code\n+\ton mismatches.\n+\t(init_cumulative_args): Look through aliases.\n+\n 2015-02-08  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR ipa/63566 "}, {"sha": "b39e5077ae15122a3166b8e4c918eae0a56f1ed7", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 76, "deletions": 43, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead0ba5768adbf6a275dff580a1bf3e06d677bc8/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead0ba5768adbf6a275dff580a1bf3e06d677bc8/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=ead0ba5768adbf6a275dff580a1bf3e06d677bc8", "patch": "@@ -5767,49 +5767,55 @@ ix86_function_regparm (const_tree type, const_tree decl)\n \n   /* Use register calling convention for local functions when possible.  */\n   if (decl\n-      && TREE_CODE (decl) == FUNCTION_DECL\n+      && TREE_CODE (decl) == FUNCTION_DECL)\n+    {\n+      cgraph_node *target = cgraph_node::get (decl);\n+      if (target)\n+\ttarget = target->function_symbol ();\n+\n       /* Caller and callee must agree on the calling convention, so\n \t checking here just optimize means that with\n \t __attribute__((optimize (...))) caller could use regparm convention\n \t and callee not, or vice versa.  Instead look at whether the callee\n \t is optimized or not.  */\n-      && opt_for_fn (decl, optimize)\n-      && !(profile_flag && !flag_fentry))\n-    {\n-      /* FIXME: remove this CONST_CAST when cgraph.[ch] is constified.  */\n-      cgraph_local_info *i = cgraph_node::local_info (CONST_CAST_TREE (decl));\n-      if (i && i->local && i->can_change_signature)\n+      if (target && opt_for_fn (target->decl, optimize)\n+\t  && !(profile_flag && !flag_fentry))\n \t{\n-\t  int local_regparm, globals = 0, regno;\n+\t  cgraph_local_info *i = &target->local;\n+\t  if (i && i->local && i->can_change_signature)\n+\t    {\n+\t      int local_regparm, globals = 0, regno;\n \n-\t  /* Make sure no regparm register is taken by a\n-\t     fixed register variable.  */\n-\t  for (local_regparm = 0; local_regparm < REGPARM_MAX; local_regparm++)\n-\t    if (fixed_regs[local_regparm])\n-\t      break;\n+\t      /* Make sure no regparm register is taken by a\n+\t\t fixed register variable.  */\n+\t      for (local_regparm = 0; local_regparm < REGPARM_MAX;\n+\t\t   local_regparm++)\n+\t\tif (fixed_regs[local_regparm])\n+\t\t  break;\n \n-\t  /* We don't want to use regparm(3) for nested functions as\n-\t     these use a static chain pointer in the third argument.  */\n-\t  if (local_regparm == 3 && DECL_STATIC_CHAIN (decl))\n-\t    local_regparm = 2;\n+\t      /* We don't want to use regparm(3) for nested functions as\n+\t\t these use a static chain pointer in the third argument.  */\n+\t      if (local_regparm == 3 && DECL_STATIC_CHAIN (target->decl))\n+\t\tlocal_regparm = 2;\n \n-\t  /* In 32-bit mode save a register for the split stack.  */\n-\t  if (!TARGET_64BIT && local_regparm == 3 && flag_split_stack)\n-\t    local_regparm = 2;\n+\t      /* Save a register for the split stack.  */\n+\t      if (local_regparm == 3 && flag_split_stack)\n+\t\tlocal_regparm = 2;\n \n-\t  /* Each fixed register usage increases register pressure,\n-\t     so less registers should be used for argument passing.\n-\t     This functionality can be overriden by an explicit\n-\t     regparm value.  */\n-\t  for (regno = AX_REG; regno <= DI_REG; regno++)\n-\t    if (fixed_regs[regno])\n-\t      globals++;\n+\t      /* Each fixed register usage increases register pressure,\n+\t\t so less registers should be used for argument passing.\n+\t\t This functionality can be overriden by an explicit\n+\t\t regparm value.  */\n+\t      for (regno = AX_REG; regno <= DI_REG; regno++)\n+\t\tif (fixed_regs[regno])\n+\t\t  globals++;\n \n-\t  local_regparm\n-\t    = globals < local_regparm ? local_regparm - globals : 0;\n+\t      local_regparm\n+\t\t= globals < local_regparm ? local_regparm - globals : 0;\n \n-\t  if (local_regparm > regparm)\n-\t    regparm = local_regparm;\n+\t      if (local_regparm > regparm)\n+\t\tregparm = local_regparm;\n+\t    }\n \t}\n     }\n \n@@ -5848,15 +5854,37 @@ ix86_function_sseregparm (const_tree type, const_tree decl, bool warn)\n       return 2;\n     }\n \n+  if (!decl)\n+    return 0;\n+\n+  cgraph_node *target = cgraph_node::get (decl);\n+  if (target)\n+    target = target->function_symbol ();\n+\n   /* For local functions, pass up to SSE_REGPARM_MAX SFmode\n      (and DFmode for SSE2) arguments in SSE registers.  */\n-  if (decl && TARGET_SSE_MATH && optimize\n+  if (target\n+      /* TARGET_SSE_MATH */\n+      && (target_opts_for_fn (target->decl)->x_ix86_fpmath & FPMATH_SSE)\n+      && opt_for_fn (target->decl, optimize)\n       && !(profile_flag && !flag_fentry))\n     {\n-      /* FIXME: remove this CONST_CAST when cgraph.[ch] is constified.  */\n-      cgraph_local_info *i = cgraph_node::local_info (CONST_CAST_TREE(decl));\n+      cgraph_local_info *i = &target->local;\n       if (i && i->local && i->can_change_signature)\n-\treturn TARGET_SSE2 ? 2 : 1;\n+\t{\n+\t  /* Refuse to produce wrong code when local function with SSE enabled\n+\t     is called from SSE disabled function.\n+\t     We may work hard to work out these scenarios but hopefully\n+\t     it doesnot matter in practice.  */\n+\t  if (!TARGET_SSE && warn)\n+\t    {\n+\t      error (\"calling %qD with SSE caling convention without \"\n+\t\t     \"SSE/SSE2 enabled\", decl);\n+\t      return 0;\n+\t    }\n+\t  return TARGET_SSE2_P (target_opts_for_fn (target->decl)\n+\t\t\t\t->x_ix86_isa_flags) ? 2 : 1;\n+\t}\n     }\n \n   return 0;\n@@ -6343,20 +6371,25 @@ init_cumulative_args (CUMULATIVE_ARGS *cum,  /* Argument info to initialize */\n \t\t      tree fndecl,\n \t\t      int caller)\n {\n-  struct cgraph_local_info *i;\n+  struct cgraph_local_info *i = NULL;\n+  struct cgraph_node *target = NULL;\n \n   memset (cum, 0, sizeof (*cum));\n \n   if (fndecl)\n     {\n-      i = cgraph_node::local_info (fndecl);\n-      cum->call_abi = ix86_function_abi (fndecl);\n+      target = cgraph_node::get (fndecl);\n+      if (target)\n+\t{\n+\t  target = target->function_symbol ();\n+\t  i = cgraph_node::local_info (target->decl);\n+\t  cum->call_abi = ix86_function_abi (target->decl);\n+\t}\n+      else\n+\tcum->call_abi = ix86_function_abi (fndecl);\n     }\n   else\n-    {\n-      i = NULL;\n-      cum->call_abi = ix86_function_type_abi (fntype);\n-    }\n+    cum->call_abi = ix86_function_type_abi (fntype);\n \n   cum->caller = caller;\n \n@@ -6392,7 +6425,7 @@ init_cumulative_args (CUMULATIVE_ARGS *cum,  /* Argument info to initialize */\n      helping K&R code.\n      FIXME: once typesytem is fixed, we won't need this code anymore.  */\n   if (i && i->local && i->can_change_signature)\n-    fntype = TREE_TYPE (fndecl);\n+    fntype = TREE_TYPE (target->decl);\n   cum->stdarg = stdarg_p (fntype);\n   cum->maybe_vaarg = (fntype\n \t\t      ? (!prototype_p (fntype) || stdarg_p (fntype))"}]}