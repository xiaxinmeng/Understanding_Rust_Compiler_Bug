{"sha": "974c43f1e345d10b7dc1c202dbe62caf88b25255", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTc0YzQzZjFlMzQ1ZDEwYjdkYzFjMjAyZGJlNjJjYWY4OGIyNTI1NQ==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2002-06-13T06:25:28Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-06-13T06:25:28Z"}, "message": "cpplib.c (end_directive): Handle line skipping.\n\n\t* cpplib.c (end_directive): Handle line skipping.  Only remove\n\tthe rest of the line if the directive was valid.\n\t* cppmacro.c (_cpp_push_text_context): Set NODE_DISABLED when\n\texpanding a traditional macro.\n\t* cpptrad.c (recursive_macro): New.\n\t(read_logical_line_trad): Handle skipping.\n\t(scan_out_logical_line): Continue after a successful directive.\n\tDon't expand macros whilst skipping, or if recursing.\n\t(_cpp_create_trad_definition): scan_out_logical_line now sets\n\tthe output current position.\n\nFrom-SVN: r54573", "tree": {"sha": "3e71956fa3f7d26102a5ef76e903e7afc02c749c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e71956fa3f7d26102a5ef76e903e7afc02c749c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/974c43f1e345d10b7dc1c202dbe62caf88b25255", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/974c43f1e345d10b7dc1c202dbe62caf88b25255", "html_url": "https://github.com/Rust-GCC/gccrs/commit/974c43f1e345d10b7dc1c202dbe62caf88b25255", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/974c43f1e345d10b7dc1c202dbe62caf88b25255/comments", "author": null, "committer": null, "parents": [{"sha": "e4dadd2ad0d2008b1838083846157ca527ec8170", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4dadd2ad0d2008b1838083846157ca527ec8170", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4dadd2ad0d2008b1838083846157ca527ec8170"}], "stats": {"total": 113, "additions": 88, "deletions": 25}, "files": [{"sha": "626b0cbdda25b0fd46fbd7b2eeccf2be2c8f0980", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/974c43f1e345d10b7dc1c202dbe62caf88b25255/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/974c43f1e345d10b7dc1c202dbe62caf88b25255/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=974c43f1e345d10b7dc1c202dbe62caf88b25255", "patch": "@@ -1,3 +1,16 @@\n+2002-06-13  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cpplib.c (end_directive): Handle line skipping.  Only remove\n+\tthe rest of the line if the directive was valid.\n+\t* cppmacro.c (_cpp_push_text_context): Set NODE_DISABLED when\n+\texpanding a traditional macro.\n+\t* cpptrad.c (recursive_macro): New.\n+\t(read_logical_line_trad): Handle skipping.\n+\t(scan_out_logical_line): Continue after a successful directive.\n+\tDon't expand macros whilst skipping, or if recursing.\n+\t(_cpp_create_trad_definition): scan_out_logical_line now sets\n+\tthe output current position.\n+\n 2002-06-12  Eric Christopher  <echristo@redhat.com>\n \n \tFrom Chris Demetriou  <cgd@broadcom.com>"}, {"sha": "acc71e7120a6ae208336ead67ae146b74a60a1a0", "filename": "gcc/cpplib.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/974c43f1e345d10b7dc1c202dbe62caf88b25255/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/974c43f1e345d10b7dc1c202dbe62caf88b25255/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=974c43f1e345d10b7dc1c202dbe62caf88b25255", "patch": "@@ -256,7 +256,7 @@ end_directive (pfile, skip_line)\n {\n   if (CPP_OPTION (pfile, traditional))\n     {\n-      if (pfile->directive == &dtable[T_DEFINE])\n+      if (!pfile->directive || pfile->directive == &dtable[T_DEFINE])\n \tskip_line = false;\n       else\n \t_cpp_remove_overlay (pfile);\n@@ -290,12 +290,15 @@ prepare_directive_trad (pfile)\n   else\n     {\n       bool no_expand = ! (pfile->directive->flags & EXPAND);\n+      bool was_skipping = pfile->state.skipping;\n \n+      pfile->state.skipping = false;\n       if (no_expand)\n \tpfile->state.prevent_expansion++;\n       _cpp_read_logical_line_trad (pfile);\n       if (no_expand)\n \tpfile->state.prevent_expansion--;\n+      pfile->state.skipping = was_skipping;\n       _cpp_overlay_buffer (pfile, pfile->out.base,\n \t\t\t   pfile->out.cur - pfile->out.base);\n     }"}, {"sha": "20149ec9b33bb0e512b6da0a91cf7a151081e627", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/974c43f1e345d10b7dc1c202dbe62caf88b25255/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/974c43f1e345d10b7dc1c202dbe62caf88b25255/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=974c43f1e345d10b7dc1c202dbe62caf88b25255", "patch": "@@ -947,6 +947,7 @@ _cpp_push_text_context (pfile, macro, start, len)\n   context->buff = NULL;\n   CUR (context) = start;\n   RLIMIT (context) = start + len;\n+  macro->flags |= NODE_DISABLED;\n }\n \n /* Expand an argument ARG before replacing parameters in a"}, {"sha": "03ee0e893a68a384e74acf5e8eec5b944521ff3f", "filename": "gcc/cpptrad.c", "status": "modified", "additions": 70, "deletions": 24, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/974c43f1e345d10b7dc1c202dbe62caf88b25255/gcc%2Fcpptrad.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/974c43f1e345d10b7dc1c202dbe62caf88b25255/gcc%2Fcpptrad.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpptrad.c?ref=974c43f1e345d10b7dc1c202dbe62caf88b25255", "patch": "@@ -82,6 +82,7 @@ static void scan_out_logical_line PARAMS ((cpp_reader *pfile, cpp_macro *));\n static void check_output_buffer PARAMS ((cpp_reader *, size_t));\n static void push_replacement_text PARAMS ((cpp_reader *, cpp_hashnode *));\n static bool scan_parameters PARAMS ((cpp_reader *, cpp_macro *));\n+static bool recursive_macro PARAMS ((cpp_reader *, cpp_hashnode *));\n static void save_replacement_text PARAMS ((cpp_reader *, cpp_macro *,\n \t\t\t\t\t   unsigned int));\n static void maybe_start_funlike PARAMS ((cpp_reader *, cpp_hashnode *,\n@@ -304,30 +305,31 @@ bool\n _cpp_read_logical_line_trad (pfile)\n      cpp_reader *pfile;\n {\n-  cpp_buffer *buffer;\n+  cpp_buffer *buffer = pfile->buffer;\n \n-  buffer = pfile->buffer;\n-  if (buffer->cur == buffer->rlimit)\n+  do\n     {\n-      bool stop = true;\n-\n-      /* Don't pop the last buffer.  */\n-      if (buffer->prev)\n+      if (buffer->cur == buffer->rlimit)\n \t{\n-\t  stop = buffer->return_at_eof;\n-\t  _cpp_pop_buffer (pfile);\n+\t  bool stop = true;\n+\n+\t  /* Don't pop the last buffer.  */\n+\t  if (buffer->prev)\n+\t    {\n+\t      stop = buffer->return_at_eof;\n+\t      _cpp_pop_buffer (pfile);\n+\t    }\n+\n+\t  if (stop)\n+\t    return false;\n \t}\n \n-      if (stop)\n-\treturn false;\n+      CUR (pfile->context) = buffer->cur;\n+      RLIMIT (pfile->context) = buffer->rlimit;\n+      scan_out_logical_line (pfile, NULL);\n+      buffer->cur = CUR (pfile->context);\n     }\n-\n-  CUR (pfile->context) = buffer->cur;\n-  RLIMIT (pfile->context) = buffer->rlimit;\n-  pfile->out.cur = pfile->out.base;\n-  pfile->out.first_line = pfile->line;\n-  scan_out_logical_line (pfile, NULL);\n-  buffer->cur = CUR (pfile->context);\n+  while (pfile->state.skipping);\n \n   return true;\n }\n@@ -384,6 +386,10 @@ scan_out_logical_line (pfile, macro)\n   struct fun_macro fmacro;\n \n   fmacro.buff = NULL;\n+\n+ start_logical_line:\n+  pfile->out.cur = pfile->out.base;\n+  pfile->out.first_line = pfile->line;\n  new_context:\n   context = pfile->context;\n   cur = CUR (context);\n@@ -483,8 +489,10 @@ scan_out_logical_line (pfile, macro)\n \t      node = lex_identifier (pfile, cur - 1);\n \n \t      if (node->type == NT_MACRO\n+\t\t  && !pfile->state.skipping\n \t\t  && pfile->state.parsing_args != 2\n-\t\t  && !pfile->state.prevent_expansion)\n+\t\t  && !pfile->state.prevent_expansion\n+\t\t  && !recursive_macro (pfile, node))\n \t\t{\n \t\t  if (node->value.macro->fun_like)\n \t\t    maybe_start_funlike (pfile, node, out, &fmacro);\n@@ -582,10 +590,7 @@ scan_out_logical_line (pfile, macro)\n \t\t preprocessor lex the next token.  */\n \t      pfile->buffer->cur = cur;\n \t      if (_cpp_handle_directive (pfile, false /* indented */))\n-\t\t{\n-\t\t  cur = CUR (context);\n-\t\t  goto done;\n-\t\t}\n+\t\tgoto start_logical_line;\n \t    }\n \t  break;\n \n@@ -615,6 +620,48 @@ push_replacement_text (pfile, node)\n   _cpp_push_text_context (pfile, node, macro->exp.text, macro->count);\n }\n \n+/* Returns TRUE if traditional macro recursion is detected.  */\n+static bool\n+recursive_macro (pfile, node)\n+     cpp_reader *pfile;\n+     cpp_hashnode *node;\n+{\n+  bool recursing = node->flags & NODE_DISABLED;\n+\n+  /* Object-like macros that are already expanding are necessarily\n+     recursive.\n+\n+     However, it is possible to have traditional function-like macros\n+     that are not infinitely recursive but recurse to any given depth.\n+     Further, it is easy to construct examples that get ever longer\n+     until the point they stop recursing.  So there is no easy way to\n+     detect true recursion; instead we assume any expansion more than\n+     20 deep since the first invocation of this macro must be\n+     recursing.  */\n+  if (recursing && node->value.macro->fun_like)\n+    {\n+      size_t depth = 0;\n+      cpp_context *context = pfile->context;\n+\n+      do\n+\t{\n+\t  depth++;\n+\t  if (context->macro == node && depth > 20)\n+\t    break;\n+\t  context = context->prev;\n+\t}\n+      while (context);\n+      recursing = context != NULL;\n+    }\n+\n+  if (recursing)\n+    cpp_error (pfile, DL_ERROR,\n+\t       \"detected recursion whilst expanding macro \\\"%s\\\"\",\n+\t       NODE_NAME (node));\n+\n+  return recursing;\n+}\n+\n /* Push a context holding the replacement text of the macro NODE on\n    the context stack.  NODE is either object-like, or a function-like\n    macro with no arguments.  */\n@@ -804,7 +851,6 @@ _cpp_create_trad_definition (pfile, macro)\n   /* Skip leading whitespace in the replacement text.  */\n   CUR (pfile->context) = skip_whitespace (pfile, CUR (pfile->context));\n \n-  pfile->out.cur = pfile->out.base;\n   pfile->state.prevent_expansion++;\n   scan_out_logical_line (pfile, macro);\n   pfile->state.prevent_expansion--;"}]}