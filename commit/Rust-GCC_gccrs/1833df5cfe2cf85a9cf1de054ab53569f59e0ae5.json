{"sha": "1833df5cfe2cf85a9cf1de054ab53569f59e0ae5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTgzM2RmNWNmZTJjZjg1YTljZjFkZTA1NGFiNTM1NjlmNTllMGFlNQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2004-05-18T16:23:25Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2004-05-18T16:23:25Z"}, "message": "tree-ssa-phiopt.c (replace_phi_with_stmt): New function extracted from conditional_replacement.\n\n        * tree-ssa-phiopt.c (replace_phi_with_stmt): New function extracted\n        from conditional_replacement.\n        (candidate_bb_for_phi_optimization): Similarly.\n        (conditional_replacement): Use replace_phi_with_stmt and\n        candidate_bb_for_phi_optimization.\n\nFrom-SVN: r81996", "tree": {"sha": "d21c996bd036ca79f3793a6a7b16e665a3a1f2dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d21c996bd036ca79f3793a6a7b16e665a3a1f2dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1833df5cfe2cf85a9cf1de054ab53569f59e0ae5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1833df5cfe2cf85a9cf1de054ab53569f59e0ae5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1833df5cfe2cf85a9cf1de054ab53569f59e0ae5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1833df5cfe2cf85a9cf1de054ab53569f59e0ae5/comments", "author": null, "committer": null, "parents": [{"sha": "14886ab7b706a6b19c262d4c3b9684afb0e879c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14886ab7b706a6b19c262d4c3b9684afb0e879c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14886ab7b706a6b19c262d4c3b9684afb0e879c1"}], "stats": {"total": 173, "additions": 113, "deletions": 60}, "files": [{"sha": "a294e940cfe7c8c6e97297dab4b7d30e78ee655e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1833df5cfe2cf85a9cf1de054ab53569f59e0ae5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1833df5cfe2cf85a9cf1de054ab53569f59e0ae5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1833df5cfe2cf85a9cf1de054ab53569f59e0ae5", "patch": "@@ -1,5 +1,11 @@\n 2004-05-18  Jeff Law  <law@redhat.com>\n \n+\t* tree-ssa-phiopt.c (replace_phi_with_stmt): New function extracted\n+\tfrom conditional_replacement.\n+\t(candidate_bb_for_phi_optimization): Similarly.\n+\t(conditional_replacement): Use replace_phi_with_stmt and\n+\tcandidate_bb_for_phi_optimization.\n+\n \t* tree-ssa-phiopt.c: Fix various formatting issues.\n \n 2004-05-18  Steven Bosscher  <stevenb@suse.de>"}, {"sha": "a29b8f71a9498bc5832d4a2015669eda72f25b6c", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 107, "deletions": 60, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1833df5cfe2cf85a9cf1de054ab53569f59e0ae5/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1833df5cfe2cf85a9cf1de054ab53569f59e0ae5/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=1833df5cfe2cf85a9cf1de054ab53569f59e0ae5", "patch": "@@ -38,6 +38,12 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n static void tree_ssa_phiopt (void);\n static bool conditional_replacement (basic_block bb, tree phi, tree arg0,\n \t\t\t\t     tree arg1);\t\t\t    \n+static void replace_phi_with_stmt (block_stmt_iterator, basic_block,\n+\t\t\t\t   basic_block, tree, tree);\n+static bool candidate_bb_for_phi_optimization (basic_block,\n+\t\t\t\t\t       basic_block *,\n+\t\t\t\t\t       basic_block *);\n+\n \t\t\t\t  \n /* This pass eliminates PHI nodes which can be trivially implemented as\n    an assignment from a conditional expression.  ie if we have something\n@@ -97,32 +103,26 @@ tree_ssa_phiopt (void)\n     cleanup_tree_cfg ();\n }\n \n-/*  The function conditional_replacement does the main work of doing the\n-    conditional replacement.  Return true if the replacement is done.\n-    Otherwise return false.\n-    BB is the basic block where the replacement is going to be done on.  ARG0\n-    is argument 0 from PHI.  Likewise for ARG1.   */\n+/* BB is a basic block which has only one PHI node with precisely two\n+   arguments.\n+\n+   Examine both of BB's predecessors to see if one ends with a \n+   COND_EXPR and the other is an empty block.  If so, then we may\n+   be able to optimize PHI nodes at the start of BB. \n+\n+   If so, mark store the block with the COND_EXPR into COND_BLOCK_P\n+   and the other block into OTHER_BLOCK_P and return true, otherwise\n+   return false.  */\n \n static bool\n-conditional_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n+candidate_bb_for_phi_optimization (basic_block bb,\n+\t\t\t\t   basic_block *cond_block_p,\n+\t\t\t\t   basic_block *other_block_p)\n {\n-  tree result;\n-  tree old_result = NULL;\n-  basic_block other_block = NULL;\n-  basic_block cond_block = NULL;\n-  tree last0, last1, new, cond;\n+  tree last0, last1;\n   block_stmt_iterator bsi;\n-  edge true_edge, false_edge;\n-  tree new_var = NULL;\n+  basic_block cond_block, other_block;\n \n-  /* The PHI arguments have the constants 0 and 1, then convert\n-     it to the conditional.  */\n-  if ((integer_zerop (arg0) && integer_onep (arg1))\n-      || (integer_zerop (arg1) && integer_onep (arg0)))\n-    ;\n-  else\n-    return false;\n-  \n   /* One of the alternatives must come from a block ending with\n      a COND_EXPR.  The other block must be entirely empty, except\n      for labels.  */\n@@ -171,7 +171,91 @@ conditional_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n   \n   if (!bsi_end_p (bsi))\n     return false;\n+\n+  *cond_block_p = cond_block;\n+  *other_block_p = other_block;\n+  /* Everything looks OK.  */\n+  return true;\n+}\n+\n+/* Replace PHI in block BB with statement NEW.  NEW is inserted after\n+   BSI.  Remove the edge from COND_BLOCK which does not lead to BB (COND_BLOCK\n+   is known to have two edges, one of which must reach BB).  */\n+\n+static void\n+replace_phi_with_stmt (block_stmt_iterator bsi, basic_block bb,\n+\t\t       basic_block cond_block, tree phi, tree new)\n+{\n+  /* Insert our new statement at the head of our block.  */\n+  bsi_insert_after (&bsi, new, BSI_NEW_STMT);\n+  \n+  /* Register our new statement as the defining statement for\n+     the result.  */\n+  SSA_NAME_DEF_STMT (PHI_RESULT (phi)) = new;\n+  \n+  /* Remove the now useless PHI node. \n+  \n+     We do not want to use remove_phi_node since that releases the\n+     SSA_NAME as well and the SSA_NAME is still being used.  */\n+  release_phi_node (phi);\n+  bb_ann (bb)->phi_nodes = NULL;\n+  \n+  /* Disconnect the edge leading into the empty block.  That will\n+     make the empty block unreachable and it will be removed later.  */\n+  if (cond_block->succ->dest == bb)\n+    {\n+      cond_block->succ->flags |= EDGE_FALLTHRU;\n+      cond_block->succ->flags &= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n+      ssa_remove_edge (cond_block->succ->succ_next);\n+    }\n+  else\n+    {\n+      cond_block->succ->succ_next->flags |= EDGE_FALLTHRU;\n+      cond_block->succ->succ_next->flags\n+\t&= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n+      ssa_remove_edge (cond_block->succ);\n+    }\n+  \n+  /* Eliminate the COND_EXPR at the end of COND_BLOCK.  */\n+  bsi = bsi_last (cond_block);\n+  bsi_remove (&bsi);\n+  \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file,\n+\t      \"COND_EXPR in block %d and PHI in block %d converted to straightline code.\\n\",\n+\t      cond_block->index,\n+\t      bb->index);\n+}\n+\n+/*  The function conditional_replacement does the main work of doing the\n+    conditional replacement.  Return true if the replacement is done.\n+    Otherwise return false.\n+    BB is the basic block where the replacement is going to be done on.  ARG0\n+    is argument 0 from PHI.  Likewise for ARG1.   */\n+\n+static bool\n+conditional_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n+{\n+  tree result;\n+  tree old_result = NULL;\n+  basic_block other_block = NULL;\n+  basic_block cond_block = NULL;\n+  tree new, cond;\n+  block_stmt_iterator bsi;\n+  edge true_edge, false_edge;\n+  tree new_var = NULL;\n+\n+  /* The PHI arguments have the constants 0 and 1, then convert\n+     it to the conditional.  */\n+  if ((integer_zerop (arg0) && integer_onep (arg1))\n+      || (integer_zerop (arg1) && integer_onep (arg0)))\n+    ;\n+  else\n+    return false;\n   \n+  if (!candidate_bb_for_phi_optimization (bb, &cond_block, &other_block))\n+    return false;\n+\t\t\t\t\t\t\t\t\t\t\n   /* If the condition is not a naked SSA_NAME and its type does not\n      match the type of the result, then we have to create a new\n      variable to optimize this case as it would likely create\n@@ -270,45 +354,8 @@ conditional_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n \t\t    PHI_RESULT (phi), cond);\n     }\n   \n-  bsi_insert_after (&bsi, new, BSI_NEW_STMT);\n-  \n-  /* Register our new statement as the defining statement for\n-     the result.  */\n-  SSA_NAME_DEF_STMT (PHI_RESULT (phi)) = new;\n-  \n-  /* Remove the now useless PHI node. \n-  \n-     We do not want to use remove_phi_node since that releases the\n-     SSA_NAME as well and the SSA_NAME is still being used.  */\n-  release_phi_node (phi);\n-  bb_ann (bb)->phi_nodes = NULL;\n-  \n-  /* Disconnect the edge leading into the empty block.  That will\n-     make the empty block unreachable and it will be removed later.  */\n-  if (cond_block->succ->dest == bb)\n-    {\n-      cond_block->succ->flags |= EDGE_FALLTHRU;\n-      cond_block->succ->flags &= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n-      ssa_remove_edge (cond_block->succ->succ_next);\n-    }\n-  else\n-    {\n-      cond_block->succ->succ_next->flags |= EDGE_FALLTHRU;\n-      cond_block->succ->succ_next->flags\n-\t&= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n-      ssa_remove_edge (cond_block->succ);\n-    }\n-  \n-  /* Eliminate the COND_EXPR at the end of COND_BLOCK.  */\n-  bsi = bsi_last (cond_block);\n-  bsi_remove (&bsi);\n-  \n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file,\n-\t      \"COND_EXPR in block %d and PHI in block %d converted to straightline code.\\n\",\n-\t      cond_block->index,\n-\t      bb->index);\n-\t    \n+  replace_phi_with_stmt (bsi, bb, cond_block, phi, new);\n+\n   /* Note that we optimized this PHI.  */\n   return true;\n }"}]}