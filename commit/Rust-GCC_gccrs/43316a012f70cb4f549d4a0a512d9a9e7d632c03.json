{"sha": "43316a012f70cb4f549d4a0a512d9a9e7d632c03", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDMzMTZhMDEyZjcwY2I0ZjU0OWQ0YTBhNTEyZDlhOWU3ZDYzMmMwMw==", "commit": {"author": {"name": "Olivier Hainque", "email": "hainque@adacore.com", "date": "2007-08-14T08:43:46Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-08-14T08:43:46Z"}, "message": "system-solaris-x86.ads (ZCX_By_Default): Switch to True.\n\n2007-08-14  Olivier Hainque  <hainque@adacore.com>\n\n\t* system-solaris-x86.ads (ZCX_By_Default): Switch to True.\n\t(GCC_ZCX_Support): Switch to True.\n\t\n\t* s-intman-solaris.adb (Notify_Exception): Call\n\tAdjust_Context_For_Raise before raising, as expected for signal\n\thandlers in general.\n\t\n\t* s-intman-posix.adb (Notify_Exception): Remove declaration of\n\tAdjust_Context_For_Raise, moved to the spec of this unit to be visible\n\tto other implementation bodies.\n\t\n\t* s-intman.ads (Adjust_Context_For_Raise): Declare and import here, to\n\tbe visible by multiple implementation bodies.\n\t\n\t* init.c [VMS section] (__gnat_handle_vms_condition): Adjust context\n\tonly for conditions coming from hardware.\n\t[alpha-tru64 section] (__gnat_adjust_context_for_raise): Implement,\n\tadjustments to signal context prior to exception raise from signal\n\thandler.\n\t(__gnat_map_signal for VxWorks): Map SIGSEGV to Storage_Error in RTP\n\tmode.\n\tSolaris section: (__gnat_adjust_context_for_raise): New function.\n\tImplementation of the machine context adjustments to perform prior to\n\traise from a signal handler. Version for both sparc and x86.\n\t(HAVE_GNAT_ADJUST_CONTEXT_FOR_RAISE): Define.\n\t(__gnat_error_handler): Expect a third argument, ucontext_t *. Adjust it\n\tprior to raising as expected for any handler, before possible nested\n\tfaults to make sure all the contexts in a chain have been adjusted by\n\tthe time we propagate.\n\nFrom-SVN: r127433", "tree": {"sha": "e16196828a28026759286dfe4f709fc46d3c6c9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e16196828a28026759286dfe4f709fc46d3c6c9f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43316a012f70cb4f549d4a0a512d9a9e7d632c03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43316a012f70cb4f549d4a0a512d9a9e7d632c03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43316a012f70cb4f549d4a0a512d9a9e7d632c03", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43316a012f70cb4f549d4a0a512d9a9e7d632c03/comments", "author": {"login": "hainque", "id": 18735142, "node_id": "MDQ6VXNlcjE4NzM1MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/18735142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hainque", "html_url": "https://github.com/hainque", "followers_url": "https://api.github.com/users/hainque/followers", "following_url": "https://api.github.com/users/hainque/following{/other_user}", "gists_url": "https://api.github.com/users/hainque/gists{/gist_id}", "starred_url": "https://api.github.com/users/hainque/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hainque/subscriptions", "organizations_url": "https://api.github.com/users/hainque/orgs", "repos_url": "https://api.github.com/users/hainque/repos", "events_url": "https://api.github.com/users/hainque/events{/privacy}", "received_events_url": "https://api.github.com/users/hainque/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2cd44f5a448ad1e160edae120cc7b945ca1a5db3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cd44f5a448ad1e160edae120cc7b945ca1a5db3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2cd44f5a448ad1e160edae120cc7b945ca1a5db3"}], "stats": {"total": 283, "additions": 169, "deletions": 114}, "files": [{"sha": "068fca547cf5aeaf8836d235fe747d6e4f540eda", "filename": "gcc/ada/init.c", "status": "modified", "additions": 127, "deletions": 70, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43316a012f70cb4f549d4a0a512d9a9e7d632c03/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43316a012f70cb4f549d4a0a512d9a9e7d632c03/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=43316a012f70cb4f549d4a0a512d9a9e7d632c03", "patch": "@@ -183,47 +183,6 @@ __gnat_set_globals ()\n \n #endif\n \n-/* Notes on the Zero Cost Exceptions scheme and its impact on the signal\n-   handlers implemented below :\n-\n-   What we call Zero Cost Exceptions is implemented using the GCC eh\n-   circuitry, even if the underlying implementation is setjmp/longjmp\n-   based. In any case ...\n-\n-   The GCC unwinder expects to be dealing with call return addresses, since\n-   this is the \"nominal\" case of what we retrieve while unwinding a regular\n-   call chain. To evaluate if a handler applies at some point in this chain,\n-   the propagation engine needs to determine what region the corresponding\n-   call instruction pertains to. The return address may not be attached to the\n-   same region as the call, so the unwinder unconditionally subtracts \"some\"\n-   amount to the return addresses it gets to search the region tables. The\n-   exact amount is computed to ensure that the resulting address is inside the\n-   call instruction, and is thus target dependent (think about delay slots for\n-   instance).\n-\n-   When we raise an exception from a signal handler, e.g. to transform a\n-   SIGSEGV into Storage_Error, things need to appear as if the signal handler\n-   had been \"called\" by the instruction which triggered the signal, so that\n-   exception handlers that apply there are considered. What the unwinder will\n-   retrieve as the return address from the signal handler is what it will find\n-   as the faulting instruction address in the corresponding signal context\n-   pushed by the kernel. Leaving this address untouched may loose, because if\n-   the triggering instruction happens to be the very first of a region, the\n-   later adjustments performed by the unwinder would yield an address outside\n-   that region. We need to compensate for those adjustments at some point,\n-   which we used to do in the GCC unwinding fallback macro.\n-\n-   The thread at http://gcc.gnu.org/ml/gcc-patches/2004-05/msg00343.html\n-   describes a couple of issues with the fallback based compensation approach.\n-   First, on some targets the adjustment to apply depends on the triggering\n-   signal, which is not easily accessible from the macro.  Besides, other\n-   languages, e.g. Java, deal with this by performing the adjustment in the\n-   signal handler before the raise, so fallback adjustments just break those\n-   front-ends.\n-\n-   We now follow the Java way for most targets, via adjust_context_for_raise\n-   below.  */\n-\n /***************/\n /* AIX Section */\n /***************/\n@@ -347,14 +306,42 @@ extern char *__gnat_get_code_loc (struct sigcontext *);\n extern void __gnat_set_code_loc (struct sigcontext *, char *);\n extern size_t __gnat_machine_state_length (void);\n \n+/* __gnat_adjust_context_for_raise - see comments along with the default\n+   version later in this file.  */\n+\n+#define HAVE_GNAT_ADJUST_CONTEXT_FOR_RAISE\n+\n+void\n+__gnat_adjust_context_for_raise (int signo, void *context)\n+{\n+  struct sigcontext * sigcontext = (struct sigcontext *) context;\n+\n+  /* The fallback code fetches the faulting insn address from sc_pc, so\n+     adjust that when need be.  For SIGFPE, the required adjustment depends\n+     on the trap shadow situation (see man ieee).  */\n+  if (signo == SIGFPE)\n+    {\n+      /* ??? We never adjust here, considering that sc_pc always\n+\t designates the instruction following the one which trapped.\n+\t This is not necessarily true but corresponds to what we have\n+\t always observed.  */\n+    }\n+  else\n+    sigcontext->sc_pc ++;\n+}\n+\n static void\n __gnat_error_handler\n-  (int sig, siginfo_t *sip, struct sigcontext *context ATTRIBUTE_UNUSED)\n+  (int sig, siginfo_t *sip, struct sigcontext *context)\n {\n   struct Exception_Data *exception;\n   static int recurse = 0;\n   const char *msg;\n \n+  /* Adjusting is required for every fault context, so adjust for this one\n+     now, before we possibly trigger a recursive fault below.  */\n+  __gnat_adjust_context_for_raise (sig, context);\n+\n   /* If this was an explicit signal from a \"kill\", just resignal it.  */\n   if (SI_FROMUSER (sip))\n     {\n@@ -973,16 +960,52 @@ __gnat_install_handler (void)\n \n #include <signal.h>\n #include <siginfo.h>\n+#include <sys/ucontext.h>\n+#include <sys/regset.h>\n+\n+/* The code below is common to sparc and x86.  Beware of the delay slot\n+   differences for signal context adjustments.  */\n+\n+#if defined (__sparc)\n+#define RETURN_ADDR_OFFSET 8\n+#else\n+#define RETURN_ADDR_OFFSET 0\n+#endif\n+\n+/* Likewise regarding how the \"instruction pointer\" register slot can\n+   be identified in signal machine contexts.  We have either \"REG_PC\"\n+   or \"PC\" at hand, depending on the target CPU and solaris version.  */\n+\n+#if !defined (REG_PC)\n+#define REG_PC PC\n+#endif\n+\n+static void __gnat_error_handler (int, siginfo_t *, ucontext_t *);\n+\n+/* __gnat_adjust_context_for_raise - see comments along with the default\n+   version later in this file.  */\n \n-static void __gnat_error_handler (int, siginfo_t *);\n+#define HAVE_GNAT_ADJUST_CONTEXT_FOR_RAISE\n+\n+void\n+__gnat_adjust_context_for_raise (int signo ATTRIBUTE_UNUSED,\n+\t\t\t\t void * ucontext)\n+{\n+  mcontext_t *mcontext = & ((ucontext_t *)ucontext)->uc_mcontext;\n+  mcontext->gregs[REG_PC] += (1 - RETURN_ADDR_OFFSET);\n+}\n \n static void\n-__gnat_error_handler (int sig, siginfo_t *sip)\n+__gnat_error_handler (int sig, siginfo_t *sip, ucontext_t *uctx)\n {\n   struct Exception_Data *exception;\n   static int recurse = 0;\n   const char *msg;\n \n+  /* Adjusting is required for every fault context, so adjust for this one\n+     now, before we possibly trigger a recursive fault below.  */\n+  __gnat_adjust_context_for_raise (sig, (void *)uctx);\n+\n   /* If this was an explicit signal from a \"kill\", just resignal it.  */\n   if (SI_FROMUSER (sip))\n     {\n@@ -1424,21 +1447,22 @@ __gnat_handle_vms_condition (int *sigargs, void *mechargs)\n \t    exception = &storage_error;\n \t    msg = \"stack overflow (or erroneous memory access)\";\n \t  }\n+\t__gnat_adjust_context_for_raise (0, (void *)mechargs);\n \tbreak;\n \n       case SS$_STKOVF:\n \texception = &storage_error;\n \tmsg = \"stack overflow\";\n+\t__gnat_adjust_context_for_raise (0, (void *)mechargs);\n \tbreak;\n \n       case SS$_HPARITH:\n #ifndef IN_RTS\n \treturn SS$_RESIGNAL; /* toplev.c handles for compiler */\n #else\n-\t{\n-\t  exception = &constraint_error;\n-\t  msg = \"arithmetic error\";\n-\t}\n+\texception = &constraint_error;\n+\tmsg = \"arithmetic error\";\n+\t__gnat_adjust_context_for_raise (0, (void *)mechargs);\n #endif\n \tbreak;\n \n@@ -1465,7 +1489,8 @@ __gnat_handle_vms_condition (int *sigargs, void *mechargs)\n \t\t   cond_except_table [i].cond &&\n \t\t   !LIB$MATCH_COND (&sigargs [1], &cond_except_table [i].cond);\n \t\t   i++);\n-\t      exception =(struct Exception_Data *) cond_except_table [i].except;\n+\t      exception = (struct Exception_Data *)\n+\t\tcond_except_table [i].except;\n \n \t      if (!exception)\n \t\t/* User programs expect Non_Ada_Error to be raised, reference\n@@ -1485,7 +1510,6 @@ __gnat_handle_vms_condition (int *sigargs, void *mechargs)\n \tbreak;\n       }\n \n- __gnat_adjust_context_for_raise (0, (void *)mechargs);\n  Raise_From_Signal_Handler (exception, msg);\n }\n \n@@ -1760,10 +1784,20 @@ __gnat_map_signal (int sig)\n       exception = &constraint_error;\n       msg = \"SIGILL\";\n       break;\n+/* In RTP mode a SIGSEGV is most likely due to a stack overflow. This is not\n+   the case in kernel mode where stack overflow detection uses a comparison\n+   method instead of memory probes. */\n+#ifdef __RTP__\n+    case SIGSEGV:\n+      exception = &storage_error;\n+      msg = \"SIGSEGV: possible stack overflow\";\n+      break;\n+#else\n     case SIGSEGV:\n       exception = &program_error;\n       msg = \"SIGSEGV\";\n       break;\n+#endif\n     case SIGBUS:\n       exception = &program_error;\n       msg = \"SIGBUS\";\n@@ -1982,34 +2016,57 @@ __gnat_init_float (void)\n \n /* All targets without a specific version will use an empty one */\n \n-/* UCONTEXT is a pointer to a context structure received by a signal handler\n-   about to propagate an exception. Adjust it to compensate the fact that the\n-   generic unwinder thinks the corresponding PC is a call return address.  */\n+/* Given UCONTEXT a pointer to a context structure received by a signal\n+   handler for SIGNO, perform the necessary adjustments to let the handler\n+   raise an exception.  Calls to this routine are not conditioned by the\n+   propagation scheme in use.  */\n \n void\n __gnat_adjust_context_for_raise (int signo ATTRIBUTE_UNUSED,\n \t\t\t\t void *ucontext ATTRIBUTE_UNUSED)\n {\n-  /* The point is that the interrupted context PC typically is the address\n-     that we should search an EH region for, which is different from the call\n-     return address case. The target independent part of the GCC unwinder\n-     don't differentiate the two situations, so we compensate here for the\n-     adjustments it will blindly make.\n+  /* Adjustments are currently required for the GCC ZCX propagation scheme\n+     only.  These adjustments (described below) are harmless for the other\n+     schemes, so may be applied unconditionally.  */\n+\n+  /* Adjustments required for a GCC ZCX propagation scheme:\n+     ------------------------------------------------------\n+\n+     The GCC unwinder expects to be dealing with call return addresses, since\n+     this is the \"nominal\" case of what we retrieve while unwinding a regular\n+     call chain.\n+\n+     To evaluate if a handler applies at some point identified by a return\n+     address, the propagation engine needs to determine what region the\n+     corresponding call instruction pertains to.  Because the return address\n+     may not be attached to the same region as the call, the unwinder always\n+     subtracts \"some\" amount from a return address to search the region\n+     tables, amount chosen to ensure that the resulting address is inside the\n+     call instruction.\n+\n+     When we raise an exception from a signal handler, e.g. to transform a\n+     SIGSEGV into Storage_Error, things need to appear as if the signal\n+     handler had been \"called\" by the instruction which triggered the signal,\n+     so that exception handlers that apply there are considered.  What the\n+     unwinder will retrieve as the return address from the signal handler is\n+     what it will find as the faulting instruction address in the signal\n+     context pushed by the kernel.  Leaving this address untouched looses, if\n+     the triggering instruction happens to be the very first of a region, as\n+     the later adjustments performed by the unwinder would yield an address\n+     outside that region.  We need to compensate for the unwinder adjustments\n+     at some point, and this is what this routine is expected to do.\n \n      signo is passed because on some targets for some signals the PC in\n      context points to the instruction after the faulting one, in which case\n-     the unwinder adjustment is still desired.  */\n-\n-  /* On a number of targets, we have arranged for the adjustment to be\n-     performed by the MD_FALLBACK_FRAME_STATE circuitry, so we don't provide a\n-     specific instance of this routine.  The MD_FALLBACK doesn't have access\n-     to the signal number, though, so the compensation is systematic there and\n-     might be wrong in some cases.  */\n-\n-  /* Having the compensation wrong leads to potential failures.  A very\n-     typical case is what happens when there is no compensation and a signal\n-     triggers for the first instruction in a region : the unwinder adjustment\n-     has it search in the wrong EH region.  */\n+     the unwinder adjustment is still desired.\n+\n+     We used to perform the compensation in the GCC unwinding fallback macro.\n+     The thread at http://gcc.gnu.org/ml/gcc-patches/2004-05/msg00343.html\n+     describes a couple of issues with this approach.  First, on some targets\n+     the adjustment to apply depends on the triggering signal, which is not\n+     easily accessible from the macro.  Besides, other languages, e.g. Java,\n+     deal with this by performing the adjustment in the signal handler before\n+     the raise, so fallback adjustments just break those front-ends.  */\n }\n \n #endif"}, {"sha": "38379dd1ecb9e37baa5273b941c28cce00740ff2", "filename": "gcc/ada/s-intman-posix.adb", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43316a012f70cb4f549d4a0a512d9a9e7d632c03/gcc%2Fada%2Fs-intman-posix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43316a012f70cb4f549d4a0a512d9a9e7d632c03/gcc%2Fada%2Fs-intman-posix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-intman-posix.adb?ref=43316a012f70cb4f549d4a0a512d9a9e7d632c03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -113,17 +113,6 @@ package body System.Interrupt_Management is\n    is\n       pragma Unreferenced (siginfo);\n \n-      --  The GCC unwinder requires adjustments to the signal's machine context\n-      --  to be able to properly unwind through the signal handler. This is\n-      --  achieved by the target specific subprogram below, provided by init.c\n-      --  to be usable by the non-tasking handler also.\n-\n-      procedure Adjust_Context_For_Raise\n-        (signo    : Signal;\n-         ucontext : System.Address);\n-      pragma Import\n-        (C, Adjust_Context_For_Raise, \"__gnat_adjust_context_for_raise\");\n-\n       Result : Interfaces.C.int;\n \n    begin\n@@ -133,8 +122,8 @@ package body System.Interrupt_Management is\n       Result := pthread_sigmask (SIG_UNBLOCK, Signal_Mask'Access, null);\n       pragma Assert (Result = 0);\n \n-      --  Perform the necessary context adjustments required by the GCC/ZCX\n-      --  unwinder, harmless in the SJLJ case.\n+      --  Perform the necessary context adjustments prior to a raise\n+      --  from a signal handler.\n \n       Adjust_Context_For_Raise (signo, ucontext);\n "}, {"sha": "626a14c39ea01ec95ef25bc1e010584f7d49d191", "filename": "gcc/ada/s-intman-solaris.adb", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43316a012f70cb4f549d4a0a512d9a9e7d632c03/gcc%2Fada%2Fs-intman-solaris.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43316a012f70cb4f549d4a0a512d9a9e7d632c03/gcc%2Fada%2Fs-intman-solaris.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-intman-solaris.adb?ref=43316a012f70cb4f549d4a0a512d9a9e7d632c03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---          Copyright (C) 1992-2006 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,14 +31,13 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This is a Solaris version of this package.\n+--  This is a Solaris version of this package\n \n---  Make a careful study of all signals available under the OS,\n---  to see which need to be reserved, kept always unmasked,\n---  or kept always unmasked.\n+--  Make a careful study of all signals available under the OS, to see which\n+--  need to be reserved, kept always unmasked, or kept always unmasked.\n \n---  Be on the lookout for special signals that\n---  may be used by the thread library.\n+--  Be on the lookout for special signals that may be used by the thread\n+--  library.\n \n package body System.Interrupt_Management is\n \n@@ -73,10 +72,10 @@ package body System.Interrupt_Management is\n    -- Notify_Exception --\n    ----------------------\n \n-   --  This function identifies the Ada exception to be raised using\n-   --  the information when the system received a synchronous signal.\n-   --  Since this function is machine and OS dependent, different code\n-   --  has to be provided for different target.\n+   --  This function identifies the Ada exception to be raised using the\n+   --  information when the system received a synchronous signal. Since this\n+   --  function is machine and OS dependent, different code has to be provided\n+   --  for different target.\n \n    procedure Notify_Exception\n      (signo   : Signal;\n@@ -92,8 +91,12 @@ package body System.Interrupt_Management is\n       info    : access siginfo_t;\n       context : access ucontext_t)\n    is\n-      pragma Unreferenced (context);\n    begin\n+      --  Perform the necessary context adjustments prior to a raise\n+      --  from a signal handler.\n+\n+      Adjust_Context_For_Raise (signo, context.all'Address);\n+\n       --  Check that treatment of exception propagation here\n       --  is consistent with treatment of the abort signal in\n       --  System.Task_Primitives.Operations.\n@@ -171,9 +174,8 @@ package body System.Interrupt_Management is\n       Result := sigemptyset (mask'Access);\n       pragma Assert (Result = 0);\n \n-      --  ??? For the same reason explained above, we can't mask these\n-      --  signals because otherwise we won't be able to catch more than\n-      --  one signal.\n+      --  ??? For the same reason explained above, we can't mask these signals\n+      --  because otherwise we won't be able to catch more than one signal.\n \n       act.sa_mask := mask;\n \n@@ -239,10 +241,10 @@ package body System.Interrupt_Management is\n          Reserve (SIGINT) := False;\n       end if;\n \n-      --  We do not have Signal 0 in reality. We just use this value\n-      --  to identify not existing signals (see s-intnam.ads). Therefore,\n-      --  Signal 0 should not be used in all signal related operations hence\n-      --  mark it as reserved.\n+      --  We do not have Signal 0 in reality. We just use this value to\n+      --  identify not existing signals (see s-intnam.ads). Therefore, Signal 0\n+      --  should not be used in all signal related operations hence mark it as\n+      --  reserved.\n \n       Reserve (0) := True;\n    end Initialize;"}, {"sha": "528fbf450907e485db9724f168beff682fa4ab50", "filename": "gcc/ada/s-intman.ads", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43316a012f70cb4f549d4a0a512d9a9e7d632c03/gcc%2Fada%2Fs-intman.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43316a012f70cb4f549d4a0a512d9a9e7d632c03/gcc%2Fada%2Fs-intman.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-intman.ads?ref=43316a012f70cb4f549d4a0a512d9a9e7d632c03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -70,10 +70,8 @@ package System.Interrupt_Management is\n    --  systems, but is always reserved when it is defined. If we have the\n    --  convention that ID zero is not used for any \"real\" signals, and SIGRARE\n    --  = 0 when SIGRARE is not one of the locally supported signals, we can\n-   --  write\n-\n+   --  write:\n    --     Reserved (SIGRARE) := True;\n-\n    --  and the initialization code will be portable.\n \n    Abort_Task_Interrupt : Interrupt_ID;\n@@ -96,13 +94,22 @@ package System.Interrupt_Management is\n    --  or used to implement time delays.\n \n    procedure Initialize;\n-   --  Initialize the various variables defined in this package.\n-   --  This procedure must be called before accessing any object from this\n-   --  package, and can be called multiple times.\n+   --  Initialize the various variables defined in this package. This procedure\n+   --  must be called before accessing any object from this package, and can be\n+   --  called multiple times.\n \n private\n    type Interrupt_Mask is new System.OS_Interface.sigset_t;\n-   --  In some implementations Interrupt_Mask can be represented as a linked\n-   --  list.\n+   --  In some implementations Interrupt_Mask is represented as a linked list\n+\n+   procedure Adjust_Context_For_Raise\n+     (Signo    : System.OS_Interface.Signal;\n+      Ucontext : System.Address);\n+   pragma Import\n+     (C, Adjust_Context_For_Raise, \"__gnat_adjust_context_for_raise\");\n+   --  Target specific hook performing adjustments to the signal's machine\n+   --  context, to be called before an exception may be raised from a signal\n+   --  handler. This service is provided by init.c, together with the\n+   --  non-tasking signal handler.\n \n end System.Interrupt_Management;"}, {"sha": "763141f66e282f986c8fe020b9911b6a4b9fa341", "filename": "gcc/ada/system-solaris-x86.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43316a012f70cb4f549d4a0a512d9a9e7d632c03/gcc%2Fada%2Fsystem-solaris-x86.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43316a012f70cb4f549d4a0a512d9a9e7d632c03/gcc%2Fada%2Fsystem-solaris-x86.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsystem-solaris-x86.ads?ref=43316a012f70cb4f549d4a0a512d9a9e7d632c03", "patch": "@@ -139,7 +139,7 @@ private\n    Support_Long_Shifts       : constant Boolean := True;\n    Suppress_Standard_Library : constant Boolean := False;\n    Use_Ada_Main_Program_Name : constant Boolean := False;\n-   ZCX_By_Default            : constant Boolean := False;\n-   GCC_ZCX_Support           : constant Boolean := False;\n+   ZCX_By_Default            : constant Boolean := True;\n+   GCC_ZCX_Support           : constant Boolean := True;\n \n end System;"}]}