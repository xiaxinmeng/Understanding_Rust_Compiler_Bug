{"sha": "ba9728b0349aa6dbfae020b283ed8ca9f073bf1f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmE5NzI4YjAzNDlhYTZkYmZhZTAyMGIyODNlZDhjYTlmMDczYmYxZg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2018-07-03T10:04:09Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-07-03T10:04:09Z"}, "message": "Clean up interface to vector pattern recognisers\n\nThe PR85694 series removed the only cases in which a pattern recogniser\ncould attach patterns to more than one statement.  I think it would be\nbetter to avoid adding any new instances of that, since it interferes\nwith the normal matching order.\n\nThis patch therefore switches the interface back to passing a single\nstatement instead of a vector.  It also gets rid of the clearing of\nSTMT_VINFO_RELATED_STMT on failure, since no recognisers use it now.\n\n2018-07-03  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vect-patterns.c (vect_recog_dot_prod_pattern):\n\t(vect_recog_sad_pattern, vect_recog_widen_op_pattern)\n\t(vect_recog_widen_mult_pattern, vect_recog_pow_pattern):\n\t(vect_recog_widen_sum_pattern, vect_recog_over_widening_pattern)\n\t(vect_recog_average_pattern, vect_recog_cast_forwprop_pattern)\n\t(vect_recog_widen_shift_pattern, vect_recog_rotate_pattern)\n\t(vect_recog_vector_vector_shift_pattern, vect_synth_mult_by_constant)\n\t(vect_recog_mult_pattern, vect_recog_divmod_pattern)\n\t(vect_recog_mixed_size_cond_pattern, vect_recog_bool_pattern)\n\t(vect_recog_mask_conversion_pattern): Replace vec<gimple *>\n\tparameter with a single stmt_vec_info.\n\t(vect_recog_func_ptr): Likewise.\n\t(vect_recog_gather_scatter_pattern): Likewise, folding in...\n\t(vect_try_gather_scatter_pattern): ...this.\n\t(vect_pattern_recog_1): Remove stmts_to_replace and just pass\n\tthe stmt_vec_info of the statement to be matched.  Don't clear\n\tSTMT_VINFO_RELATED_STMT.\n\t(vect_pattern_recog): Update call accordingly.\n\nFrom-SVN: r262336", "tree": {"sha": "61d29f7ab17df598c102d18b2b96179fea95da5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61d29f7ab17df598c102d18b2b96179fea95da5f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba9728b0349aa6dbfae020b283ed8ca9f073bf1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba9728b0349aa6dbfae020b283ed8ca9f073bf1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba9728b0349aa6dbfae020b283ed8ca9f073bf1f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba9728b0349aa6dbfae020b283ed8ca9f073bf1f/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0267732baeb06ec100c1d610197bb88aae1c5123", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0267732baeb06ec100c1d610197bb88aae1c5123", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0267732baeb06ec100c1d610197bb88aae1c5123"}], "stats": {"total": 229, "additions": 81, "deletions": 148}, "files": [{"sha": "d7918cd798f31d8e13f28668985d4c4e361c3b28", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba9728b0349aa6dbfae020b283ed8ca9f073bf1f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba9728b0349aa6dbfae020b283ed8ca9f073bf1f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ba9728b0349aa6dbfae020b283ed8ca9f073bf1f", "patch": "@@ -1,3 +1,24 @@\n+2018-07-03  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vect-patterns.c (vect_recog_dot_prod_pattern):\n+\t(vect_recog_sad_pattern, vect_recog_widen_op_pattern)\n+\t(vect_recog_widen_mult_pattern, vect_recog_pow_pattern):\n+\t(vect_recog_widen_sum_pattern, vect_recog_over_widening_pattern)\n+\t(vect_recog_average_pattern, vect_recog_cast_forwprop_pattern)\n+\t(vect_recog_widen_shift_pattern, vect_recog_rotate_pattern)\n+\t(vect_recog_vector_vector_shift_pattern, vect_synth_mult_by_constant)\n+\t(vect_recog_mult_pattern, vect_recog_divmod_pattern)\n+\t(vect_recog_mixed_size_cond_pattern, vect_recog_bool_pattern)\n+\t(vect_recog_mask_conversion_pattern): Replace vec<gimple *>\n+\tparameter with a single stmt_vec_info.\n+\t(vect_recog_func_ptr): Likewise.\n+\t(vect_recog_gather_scatter_pattern): Likewise, folding in...\n+\t(vect_try_gather_scatter_pattern): ...this.\n+\t(vect_pattern_recog_1): Remove stmts_to_replace and just pass\n+\tthe stmt_vec_info of the statement to be matched.  Don't clear\n+\tSTMT_VINFO_RELATED_STMT.\n+\t(vect_pattern_recog): Update call accordingly.\n+\n 2018-07-03  Richard Sandiford  <richard.sandiford@arm.com>\n \n \tPR tree-optimization/85694"}, {"sha": "5fdd30f537528f33171877e745bea941b1356cf5", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 60, "deletions": 148, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba9728b0349aa6dbfae020b283ed8ca9f073bf1f/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba9728b0349aa6dbfae020b283ed8ca9f073bf1f/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=ba9728b0349aa6dbfae020b283ed8ca9f073bf1f", "patch": "@@ -888,7 +888,7 @@ vect_reassociating_reduction_p (stmt_vec_info stmt_info, tree_code code,\n \n    Input:\n \n-   * STMTS: Contains a stmt from which the pattern search begins.  In the\n+   * STMT_VINFO: The stmt from which the pattern search begins.  In the\n    example, when this function is called with S7, the pattern {S3,S4,S5,S6,S7}\n    will be detected.\n \n@@ -909,11 +909,10 @@ vect_reassociating_reduction_p (stmt_vec_info stmt_info, tree_code code,\n          inner-loop nested in an outer-loop that us being vectorized).  */\n \n static gimple *\n-vect_recog_dot_prod_pattern (vec<gimple *> *stmts, tree *type_out)\n+vect_recog_dot_prod_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n {\n-  gimple *last_stmt = (*stmts)[0];\n   tree oprnd0, oprnd1;\n-  stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n+  gimple *last_stmt = stmt_vinfo->stmt;\n   vec_info *vinfo = stmt_vinfo->vinfo;\n   tree type, half_type;\n   gimple *pattern_stmt;\n@@ -1021,7 +1020,7 @@ vect_recog_dot_prod_pattern (vec<gimple *> *stmts, tree *type_out)\n \n    Input:\n \n-   * STMTS: Contains a stmt from which the pattern search begins.  In the\n+   * STMT_VINFO: The stmt from which the pattern search begins.  In the\n    example, when this function is called with S8, the pattern\n    {S3,S4,S5,S6,S7,S8} will be detected.\n \n@@ -1035,10 +1034,9 @@ vect_recog_dot_prod_pattern (vec<gimple *> *stmts, tree *type_out)\n   */\n \n static gimple *\n-vect_recog_sad_pattern (vec<gimple *> *stmts, tree *type_out)\n+vect_recog_sad_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n {\n-  gimple *last_stmt = (*stmts)[0];\n-  stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n+  gimple *last_stmt = stmt_vinfo->stmt;\n   vec_info *vinfo = stmt_vinfo->vinfo;\n   tree half_type;\n \n@@ -1182,12 +1180,11 @@ vect_recog_sad_pattern (vec<gimple *> *stmts, tree *type_out)\n    name of the pattern being matched, for dump purposes.  */\n \n static gimple *\n-vect_recog_widen_op_pattern (vec<gimple *> *stmts, tree *type_out,\n+vect_recog_widen_op_pattern (stmt_vec_info last_stmt_info, tree *type_out,\n \t\t\t     tree_code orig_code, tree_code wide_code,\n \t\t\t     bool shift_p, const char *name)\n {\n-  gimple *last_stmt = stmts->pop ();\n-  stmt_vec_info last_stmt_info = vinfo_for_stmt (last_stmt);\n+  gimple *last_stmt = last_stmt_info->stmt;\n \n   vect_unpromoted_value unprom[2];\n   tree half_type;\n@@ -1231,17 +1228,16 @@ vect_recog_widen_op_pattern (vec<gimple *> *stmts, tree *type_out,\n   gimple *pattern_stmt = gimple_build_assign (var, wide_code,\n \t\t\t\t\t      oprnd[0], oprnd[1]);\n \n-  stmts->safe_push (last_stmt);\n   return vect_convert_output (last_stmt_info, type, pattern_stmt, vecitype);\n }\n \n /* Try to detect multiplication on widened inputs, converting MULT_EXPR\n    to WIDEN_MULT_EXPR.  See vect_recog_widen_op_pattern for details.  */\n \n static gimple *\n-vect_recog_widen_mult_pattern (vec<gimple *> *stmts, tree *type_out)\n+vect_recog_widen_mult_pattern (stmt_vec_info last_stmt_info, tree *type_out)\n {\n-  return vect_recog_widen_op_pattern (stmts, type_out, MULT_EXPR,\n+  return vect_recog_widen_op_pattern (last_stmt_info, type_out, MULT_EXPR,\n \t\t\t\t      WIDEN_MULT_EXPR, false,\n \t\t\t\t      \"vect_recog_widen_mult_pattern\");\n }\n@@ -1257,7 +1253,7 @@ vect_recog_widen_mult_pattern (vec<gimple *> *stmts, tree *type_out)\n \n    Input:\n \n-   * LAST_STMT: A stmt from which the pattern search begins.\n+   * STMT_VINFO: The stmt from which the pattern search begins.\n \n    Output:\n \n@@ -1271,9 +1267,9 @@ vect_recog_widen_mult_pattern (vec<gimple *> *stmts, tree *type_out)\n */\n \n static gimple *\n-vect_recog_pow_pattern (vec<gimple *> *stmts, tree *type_out)\n+vect_recog_pow_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n {\n-  gimple *last_stmt = (*stmts)[0];\n+  gimple *last_stmt = stmt_vinfo->stmt;\n   tree base, exp;\n   gimple *stmt;\n   tree var;\n@@ -1344,7 +1340,6 @@ vect_recog_pow_pattern (vec<gimple *> *stmts, tree *type_out)\n \t      *type_out = get_vectype_for_scalar_type (TREE_TYPE (base));\n \t      if (!*type_out)\n \t\treturn NULL;\n-\t      stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n \t      tree def = vect_recog_temp_ssa_var (TREE_TYPE (base), NULL);\n \t      gimple *g = gimple_build_assign (def, MULT_EXPR, exp, logc);\n \t      new_pattern_def_seq (stmt_vinfo, g);\n@@ -1415,7 +1410,7 @@ vect_recog_pow_pattern (vec<gimple *> *stmts, tree *type_out)\n \n    Input:\n \n-   * LAST_STMT: A stmt from which the pattern search begins. In the example,\n+   * STMT_VINFO: The stmt from which the pattern search begins. In the example,\n    when this function is called with S3, the pattern {S2,S3} will be detected.\n \n    Output:\n@@ -1435,11 +1430,10 @@ vect_recog_pow_pattern (vec<gimple *> *stmts, tree *type_out)\n \t inner-loop nested in an outer-loop that us being vectorized).  */\n \n static gimple *\n-vect_recog_widen_sum_pattern (vec<gimple *> *stmts, tree *type_out)\n+vect_recog_widen_sum_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n {\n-  gimple *last_stmt = (*stmts)[0];\n+  gimple *last_stmt = stmt_vinfo->stmt;\n   tree oprnd0, oprnd1;\n-  stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n   vec_info *vinfo = stmt_vinfo->vinfo;\n   tree type;\n   gimple *pattern_stmt;\n@@ -1524,15 +1518,14 @@ vect_recog_widen_sum_pattern (vec<gimple *> *stmts, tree *type_out)\n    by users of the result.  */\n \n static gimple *\n-vect_recog_over_widening_pattern (vec<gimple *> *stmts, tree *type_out)\n+vect_recog_over_widening_pattern (stmt_vec_info last_stmt_info, tree *type_out)\n {\n-  gassign *last_stmt = dyn_cast <gassign *> (stmts->pop ());\n+  gassign *last_stmt = dyn_cast <gassign *> (last_stmt_info->stmt);\n   if (!last_stmt)\n     return NULL;\n \n   /* See whether we have found that this operation can be done on a\n      narrower type without changing its semantics.  */\n-  stmt_vec_info last_stmt_info = vinfo_for_stmt (last_stmt);\n   unsigned int new_precision = last_stmt_info->operation_precision;\n   if (!new_precision)\n     return NULL;\n@@ -1717,7 +1710,6 @@ vect_recog_over_widening_pattern (vec<gimple *> *stmts, tree *type_out)\n   pattern_stmt = vect_convert_output (last_stmt_info, type,\n \t\t\t\t      pattern_stmt, new_vectype);\n \n-  stmts->safe_push (last_stmt);\n   return pattern_stmt;\n }\n \n@@ -1741,18 +1733,16 @@ vect_recog_over_widening_pattern (vec<gimple *> *stmts, tree *type_out)\n   of avg is used, all or part of the cast of avg' should become redundant.  */\n \n static gimple *\n-vect_recog_average_pattern (vec<gimple *> *stmts, tree *type_out)\n+vect_recog_average_pattern (stmt_vec_info last_stmt_info, tree *type_out)\n {\n   /* Check for a shift right by one bit.  */\n-  gassign *last_stmt = dyn_cast <gassign *> (stmts->pop ());\n+  gassign *last_stmt = dyn_cast <gassign *> (last_stmt_info->stmt);\n+  vec_info *vinfo = last_stmt_info->vinfo;\n   if (!last_stmt\n       || gimple_assign_rhs_code (last_stmt) != RSHIFT_EXPR\n       || !integer_onep (gimple_assign_rhs2 (last_stmt)))\n     return NULL;\n \n-  stmt_vec_info last_stmt_info = vinfo_for_stmt (last_stmt);\n-  vec_info *vinfo = last_stmt_info->vinfo;\n-\n   /* Check that the shift result is wider than the users of the\n      result need (i.e. that narrowing would be a natural choice).  */\n   tree lhs = gimple_assign_lhs (last_stmt);\n@@ -1864,7 +1854,6 @@ vect_recog_average_pattern (vec<gimple *> *stmts, tree *type_out)\n       dump_gimple_stmt (MSG_NOTE, TDF_SLIM, average_stmt, 0);\n     }\n \n-  stmts->safe_push (last_stmt);\n   return vect_convert_output (last_stmt_info, type, average_stmt, new_vectype);\n }\n \n@@ -1888,10 +1877,10 @@ vect_recog_average_pattern (vec<gimple *> *stmts, tree *type_out)\n    input doesn't.  */\n \n static gimple *\n-vect_recog_cast_forwprop_pattern (vec<gimple *> *stmts, tree *type_out)\n+vect_recog_cast_forwprop_pattern (stmt_vec_info last_stmt_info, tree *type_out)\n {\n   /* Check for a cast, including an integer-to-float conversion.  */\n-  gassign *last_stmt = dyn_cast <gassign *> (stmts->pop ());\n+  gassign *last_stmt = dyn_cast <gassign *> (last_stmt_info->stmt);\n   if (!last_stmt)\n     return NULL;\n   tree_code code = gimple_assign_rhs_code (last_stmt);\n@@ -1917,7 +1906,6 @@ vect_recog_cast_forwprop_pattern (vec<gimple *> *stmts, tree *type_out)\n     return NULL;\n \n   /* Try to find an unpromoted input.  */\n-  stmt_vec_info last_stmt_info = vinfo_for_stmt (last_stmt);\n   vec_info *vinfo = last_stmt_info->vinfo;\n   vect_unpromoted_value unprom;\n   if (!vect_look_through_possible_promotion (vinfo, rhs, &unprom)\n@@ -1942,17 +1930,16 @@ vect_recog_cast_forwprop_pattern (vec<gimple *> *stmts, tree *type_out)\n   gimple *pattern_stmt = gimple_build_assign (new_var, code, unprom.op);\n   gimple_set_location (pattern_stmt, gimple_location (last_stmt));\n \n-  stmts->safe_push (last_stmt);\n   return pattern_stmt;\n }\n \n /* Try to detect a shift left of a widened input, converting LSHIFT_EXPR\n    to WIDEN_LSHIFT_EXPR.  See vect_recog_widen_op_pattern for details.  */\n \n static gimple *\n-vect_recog_widen_shift_pattern (vec<gimple *> *stmts, tree *type_out)\n+vect_recog_widen_shift_pattern (stmt_vec_info last_stmt_info, tree *type_out)\n {\n-  return vect_recog_widen_op_pattern (stmts, type_out, LSHIFT_EXPR,\n+  return vect_recog_widen_op_pattern (last_stmt_info, type_out, LSHIFT_EXPR,\n \t\t\t\t      WIDEN_LSHIFT_EXPR, true,\n \t\t\t\t      \"vect_recog_widen_shift_pattern\");\n }\n@@ -1965,7 +1952,7 @@ vect_recog_widen_shift_pattern (vec<gimple *> *stmts, tree *type_out)\n \n   Input/Output:\n \n-  * STMTS: Contains a stmt from which the pattern search begins,\n+  * STMT_VINFO: The stmt from which the pattern search begins,\n     i.e. the shift/rotate stmt.  The original stmt (S0) is replaced\n     with a sequence:\n \n@@ -1985,13 +1972,12 @@ vect_recog_widen_shift_pattern (vec<gimple *> *stmts, tree *type_out)\n     S0 stmt.  */\n \n static gimple *\n-vect_recog_rotate_pattern (vec<gimple *> *stmts, tree *type_out)\n+vect_recog_rotate_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n {\n-  gimple *last_stmt = stmts->pop ();\n+  gimple *last_stmt = stmt_vinfo->stmt;\n   tree oprnd0, oprnd1, lhs, var, var1, var2, vectype, type, stype, def, def2;\n   gimple *pattern_stmt, *def_stmt;\n   enum tree_code rhs_code;\n-  stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n   vec_info *vinfo = stmt_vinfo->vinfo;\n   enum vect_def_type dt;\n   optab optab1, optab2;\n@@ -2174,7 +2160,6 @@ vect_recog_rotate_pattern (vec<gimple *> *stmts, tree *type_out)\n   var = vect_recog_temp_ssa_var (type, NULL);\n   pattern_stmt = gimple_build_assign (var, BIT_IOR_EXPR, var1, var2);\n \n-  stmts->safe_push (last_stmt);\n   return pattern_stmt;\n }\n \n@@ -2203,7 +2188,7 @@ vect_recog_rotate_pattern (vec<gimple *> *stmts, tree *type_out)\n \n   Input/Output:\n \n-  * STMTS: Contains a stmt from which the pattern search begins,\n+  * STMT_VINFO: The stmt from which the pattern search begins,\n     i.e. the shift/rotate stmt.  The original stmt (S3) is replaced\n     with a shift/rotate which has same type on both operands, in the\n     second case just b_T op c_T, in the first case with added cast\n@@ -2217,13 +2202,13 @@ vect_recog_rotate_pattern (vec<gimple *> *stmts, tree *type_out)\n     S3 stmt.  */\n \n static gimple *\n-vect_recog_vector_vector_shift_pattern (vec<gimple *> *stmts, tree *type_out)\n+vect_recog_vector_vector_shift_pattern (stmt_vec_info stmt_vinfo,\n+\t\t\t\t\ttree *type_out)\n {\n-  gimple *last_stmt = stmts->pop ();\n+  gimple *last_stmt = stmt_vinfo->stmt;\n   tree oprnd0, oprnd1, lhs, var;\n   gimple *pattern_stmt;\n   enum tree_code rhs_code;\n-  stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n   vec_info *vinfo = stmt_vinfo->vinfo;\n \n   if (!is_gimple_assign (last_stmt))\n@@ -2303,7 +2288,6 @@ vect_recog_vector_vector_shift_pattern (vec<gimple *> *stmts, tree *type_out)\n   var = vect_recog_temp_ssa_var (TREE_TYPE (oprnd0), NULL);\n   pattern_stmt = gimple_build_assign (var, rhs_code, oprnd0, def);\n \n-  stmts->safe_push (last_stmt);\n   return pattern_stmt;\n }\n \n@@ -2612,7 +2596,7 @@ vect_synth_mult_by_constant (tree op, tree val,\n \n    Input/Output:\n \n-   STMTS: Contains a stmt from which the pattern search begins,\n+   STMT_VINFO: The stmt from which the pattern search begins,\n    i.e. the mult stmt.\n \n  Output:\n@@ -2623,12 +2607,11 @@ vect_synth_mult_by_constant (tree op, tree val,\n     the multiplication.  */\n \n static gimple *\n-vect_recog_mult_pattern (vec<gimple *> *stmts, tree *type_out)\n+vect_recog_mult_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n {\n-  gimple *last_stmt = stmts->pop ();\n+  gimple *last_stmt = stmt_vinfo->stmt;\n   tree oprnd0, oprnd1, vectype, itype;\n   gimple *pattern_stmt;\n-  stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n \n   if (!is_gimple_assign (last_stmt))\n     return NULL;\n@@ -2668,7 +2651,6 @@ vect_recog_mult_pattern (vec<gimple *> *stmts, tree *type_out)\n   /* Pattern detected.  */\n   vect_pattern_detected (\"vect_recog_mult_pattern\", last_stmt);\n \n-  stmts->safe_push (last_stmt);\n   *type_out = vectype;\n \n   return pattern_stmt;\n@@ -2689,7 +2671,7 @@ vect_recog_mult_pattern (vec<gimple *> *stmts, tree *type_out)\n \n   Input/Output:\n \n-  * STMTS: Contains a stmt from which the pattern search begins,\n+  * STMT_VINFO: The stmt from which the pattern search begins,\n     i.e. the division stmt.  S1 is replaced by if N is a power\n     of two constant and type is signed:\n   S3  y_t = b_t < 0 ? N - 1 : 0;\n@@ -2713,13 +2695,12 @@ vect_recog_mult_pattern (vec<gimple *> *stmts, tree *type_out)\n     S1 or modulo S4 stmt.  */\n \n static gimple *\n-vect_recog_divmod_pattern (vec<gimple *> *stmts, tree *type_out)\n+vect_recog_divmod_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n {\n-  gimple *last_stmt = stmts->pop ();\n+  gimple *last_stmt = stmt_vinfo->stmt;\n   tree oprnd0, oprnd1, vectype, itype, cond;\n   gimple *pattern_stmt, *def_stmt;\n   enum tree_code rhs_code;\n-  stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n   vec_info *vinfo = stmt_vinfo->vinfo;\n   optab optab;\n   tree q;\n@@ -2859,8 +2840,6 @@ vect_recog_divmod_pattern (vec<gimple *> *stmts, tree *type_out)\n \t\t\t\t   signmask);\n \t}\n \n-      stmts->safe_push (last_stmt);\n-\n       *type_out = vectype;\n       return pattern_stmt;\n     }\n@@ -3110,8 +3089,6 @@ vect_recog_divmod_pattern (vec<gimple *> *stmts, tree *type_out)\n   /* Pattern detected.  */\n   vect_pattern_detected (\"vect_recog_divmod_pattern\", last_stmt);\n \n-  stmts->safe_push (last_stmt);\n-\n   *type_out = vectype;\n   return pattern_stmt;\n }\n@@ -3132,7 +3109,7 @@ vect_recog_divmod_pattern (vec<gimple *> *stmts, tree *type_out)\n \n    Input:\n \n-   * LAST_STMT: A stmt from which the pattern search begins.\n+   * STMT_VINFO: The stmt from which the pattern search begins.\n \n    Output:\n \n@@ -3145,11 +3122,11 @@ vect_recog_divmod_pattern (vec<gimple *> *stmts, tree *type_out)\n \ta_T = (TYPE) a_it;  */\n \n static gimple *\n-vect_recog_mixed_size_cond_pattern (vec<gimple *> *stmts, tree *type_out)\n+vect_recog_mixed_size_cond_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n {\n-  gimple *last_stmt = (*stmts)[0];\n+  gimple *last_stmt = stmt_vinfo->stmt;\n   tree cond_expr, then_clause, else_clause;\n-  stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt), def_stmt_info;\n+  stmt_vec_info def_stmt_info;\n   tree type, vectype, comp_vectype, itype = NULL_TREE, vecitype;\n   gimple *pattern_stmt, *def_stmt;\n   vec_info *vinfo = stmt_vinfo->vinfo;\n@@ -3727,9 +3704,9 @@ search_type_for_mask (tree var, vec_info *vinfo)\n \n    Input:\n \n-   * LAST_STMT: A stmt at the end from which the pattern\n-\t\tsearch begins, i.e. cast of a bool to\n-\t\tan integer type.\n+   * STMT_VINFO: The stmt at the end from which the pattern\n+\t\t search begins, i.e. cast of a bool to\n+\t\t an integer type.\n \n    Output:\n \n@@ -3752,12 +3729,11 @@ search_type_for_mask (tree var, vec_info *vinfo)\n \tbut the above is more efficient.  */\n \n static gimple *\n-vect_recog_bool_pattern (vec<gimple *> *stmts, tree *type_out)\n+vect_recog_bool_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n {\n-  gimple *last_stmt = stmts->pop ();\n+  gimple *last_stmt = stmt_vinfo->stmt;\n   enum tree_code rhs_code;\n   tree var, lhs, rhs, vectype;\n-  stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n   stmt_vec_info new_stmt_info;\n   vec_info *vinfo = stmt_vinfo->vinfo;\n   gimple *pattern_stmt;\n@@ -3828,7 +3804,6 @@ vect_recog_bool_pattern (vec<gimple *> *stmts, tree *type_out)\n \t}\n \n       *type_out = vectype;\n-      stmts->safe_push (last_stmt);\n       vect_pattern_detected (\"vect_recog_bool_pattern\", last_stmt);\n \n       return pattern_stmt;\n@@ -3866,7 +3841,6 @@ vect_recog_bool_pattern (vec<gimple *> *stmts, tree *type_out)\n \t\t\t\t gimple_assign_rhs2 (last_stmt),\n \t\t\t\t gimple_assign_rhs3 (last_stmt));\n       *type_out = vectype;\n-      stmts->safe_push (last_stmt);\n       vect_pattern_detected (\"vect_recog_bool_pattern\", last_stmt);\n \n       return pattern_stmt;\n@@ -3922,7 +3896,6 @@ vect_recog_bool_pattern (vec<gimple *> *stmts, tree *type_out)\n       STMT_VINFO_DR_WRT_VEC_LOOP (pattern_stmt_info)\n \t= STMT_VINFO_DR_WRT_VEC_LOOP (stmt_vinfo);\n       *type_out = vectype;\n-      stmts->safe_push (last_stmt);\n       vect_pattern_detected (\"vect_recog_bool_pattern\", last_stmt);\n \n       return pattern_stmt;\n@@ -3985,13 +3958,12 @@ build_mask_conversion (tree mask, tree vectype, stmt_vec_info stmt_vinfo,\n    S4'  c_1' = m_3'' ? c_2 : c_3;  */\n \n static gimple *\n-vect_recog_mask_conversion_pattern (vec<gimple *> *stmts, tree *type_out)\n+vect_recog_mask_conversion_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n {\n-  gimple *last_stmt = stmts->pop ();\n+  gimple *last_stmt = stmt_vinfo->stmt;\n   enum tree_code rhs_code;\n   tree lhs = NULL_TREE, rhs1, rhs2, tmp, rhs1_type, rhs2_type;\n   tree vectype1, vectype2;\n-  stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n   stmt_vec_info pattern_stmt_info;\n   vec_info *vinfo = stmt_vinfo->vinfo;\n \n@@ -4058,7 +4030,6 @@ vect_recog_mask_conversion_pattern (vec<gimple *> *stmts, tree *type_out)\n \t= STMT_VINFO_GATHER_SCATTER_P (stmt_vinfo);\n \n       *type_out = vectype1;\n-      stmts->safe_push (last_stmt);\n       vect_pattern_detected (\"vect_recog_mask_conversion_pattern\", last_stmt);\n \n       return pattern_stmt;\n@@ -4173,7 +4144,6 @@ vect_recog_mask_conversion_pattern (vec<gimple *> *stmts, tree *type_out)\n \t\t\t\t\t  gimple_assign_rhs3 (last_stmt));\n \n       *type_out = vectype1;\n-      stmts->safe_push (last_stmt);\n       vect_pattern_detected (\"vect_recog_mask_conversion_pattern\", last_stmt);\n \n       return pattern_stmt;\n@@ -4218,7 +4188,6 @@ vect_recog_mask_conversion_pattern (vec<gimple *> *stmts, tree *type_out)\n   pattern_stmt = gimple_build_assign (lhs, rhs_code, rhs1, rhs2);\n \n   *type_out = vectype1;\n-  stmts->safe_push (last_stmt);\n   vect_pattern_detected (\"vect_recog_mask_conversion_pattern\", last_stmt);\n \n   return pattern_stmt;\n@@ -4314,19 +4283,17 @@ vect_add_conversion_to_patterm (tree type, tree value,\n   return new_value;\n }\n \n-/* Try to convert STMT into a call to a gather load or scatter store\n+/* Try to convert STMT_INFO into a call to a gather load or scatter store\n    internal function.  Return the final statement on success and set\n    *TYPE_OUT to the vector type being loaded or stored.\n \n    This function only handles gathers and scatters that were recognized\n    as such from the outset (indicated by STMT_VINFO_GATHER_SCATTER_P).  */\n \n static gimple *\n-vect_try_gather_scatter_pattern (gimple *stmt, stmt_vec_info last_stmt_info,\n-\t\t\t\t tree *type_out)\n+vect_recog_gather_scatter_pattern (stmt_vec_info stmt_info, tree *type_out)\n {\n   /* Currently we only support this for loop vectorization.  */\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = dyn_cast <loop_vec_info> (stmt_info->vinfo);\n   if (!loop_vinfo)\n     return NULL;\n@@ -4338,6 +4305,7 @@ vect_try_gather_scatter_pattern (gimple *stmt, stmt_vec_info last_stmt_info,\n \n   /* Get the boolean that controls whether the load or store happens.\n      This is null if the operation is unconditional.  */\n+  gimple *stmt = stmt_info->stmt;\n   tree mask = vect_get_load_store_mask (stmt);\n \n   /* Make sure that the target supports an appropriate internal\n@@ -4350,15 +4318,15 @@ vect_try_gather_scatter_pattern (gimple *stmt, stmt_vec_info last_stmt_info,\n   /* Convert the mask to the right form.  */\n   tree gs_vectype = get_vectype_for_scalar_type (gs_info.element_type);\n   if (mask)\n-    mask = vect_convert_mask_for_vectype (mask, gs_vectype, last_stmt_info,\n+    mask = vect_convert_mask_for_vectype (mask, gs_vectype, stmt_info,\n \t\t\t\t\t  loop_vinfo);\n \n   /* Get the invariant base and non-invariant offset, converting the\n      latter to the same width as the vector elements.  */\n   tree base = gs_info.base;\n   tree offset_type = vect_get_gather_scatter_offset_type (&gs_info);\n   tree offset = vect_add_conversion_to_patterm (offset_type, gs_info.offset,\n-\t\t\t\t\t\tlast_stmt_info, loop_vinfo);\n+\t\t\t\t\t\tstmt_info, loop_vinfo);\n \n   /* Build the new pattern statement.  */\n   tree scale = size_int (gs_info.scale);\n@@ -4405,21 +4373,6 @@ vect_try_gather_scatter_pattern (gimple *stmt, stmt_vec_info last_stmt_info,\n   return pattern_stmt;\n }\n \n-/* Pattern wrapper around vect_try_gather_scatter_pattern.  */\n-\n-static gimple *\n-vect_recog_gather_scatter_pattern (vec<gimple *> *stmts, tree *type_out)\n-{\n-  gimple *last_stmt = stmts->pop ();\n-  stmt_vec_info last_stmt_info = vinfo_for_stmt (last_stmt);\n-  gimple *pattern_stmt = vect_try_gather_scatter_pattern (last_stmt,\n-\t\t\t\t\t\t\t  last_stmt_info,\n-\t\t\t\t\t\t\t  type_out);\n-  if (pattern_stmt)\n-    stmts->safe_push (last_stmt);\n-  return pattern_stmt;\n-}\n-\n /* Return true if TYPE is a non-boolean integer type.  These are the types\n    that we want to consider for narrowing.  */\n \n@@ -4804,7 +4757,7 @@ vect_determine_precisions (vec_info *vinfo)\n     }\n }\n \n-typedef gimple *(*vect_recog_func_ptr) (vec<gimple *> *, tree *);\n+typedef gimple *(*vect_recog_func_ptr) (stmt_vec_info, tree *);\n \n struct vect_recog_func\n {\n@@ -4925,15 +4878,12 @@ vect_mark_pattern_stmts (gimple *orig_stmt, gimple *pattern_stmt,\n    for vect_recog_pattern.  */\n \n static void\n-vect_pattern_recog_1 (vect_recog_func *recog_func,\n-\t\t      gimple_stmt_iterator si,\n-\t\t      vec<gimple *> *stmts_to_replace)\n+vect_pattern_recog_1 (vect_recog_func *recog_func, gimple_stmt_iterator si)\n {\n   gimple *stmt = gsi_stmt (si), *pattern_stmt;\n   stmt_vec_info stmt_info;\n   loop_vec_info loop_vinfo;\n   tree pattern_vectype;\n-  int i;\n \n   /* If this statement has already been replaced with pattern statements,\n      leave the original statement alone, since the first match wins.\n@@ -4945,32 +4895,18 @@ vect_pattern_recog_1 (vect_recog_func *recog_func,\n       gimple_stmt_iterator gsi;\n       for (gsi = gsi_start (STMT_VINFO_PATTERN_DEF_SEQ (stmt_info));\n \t   !gsi_end_p (gsi); gsi_next (&gsi))\n-\tvect_pattern_recog_1 (recog_func, gsi, stmts_to_replace);\n+\tvect_pattern_recog_1 (recog_func, gsi);\n       return;\n     }\n \n-  stmts_to_replace->truncate (0);\n-  stmts_to_replace->quick_push (stmt);\n-  pattern_stmt = recog_func->fn (stmts_to_replace, &pattern_vectype);\n+  pattern_stmt = recog_func->fn (stmt_info, &pattern_vectype);\n   if (!pattern_stmt)\n     {\n-      /* Clear related stmt info that analysis might have noted for\n-         to be replaced stmts.  */\n-      for (i = 0; stmts_to_replace->iterate (i, &stmt)\n-\t   && (unsigned) i < stmts_to_replace->length ();\n-\t   i++)\n-\t{\n-\t  stmt_info = vinfo_for_stmt (stmt);\n-\t  if (!is_pattern_stmt_p (stmt_info))\n-\t    STMT_VINFO_RELATED_STMT (stmt_info) = NULL;\n-\t}\n       /* Clear any half-formed pattern definition sequence.  */\n       STMT_VINFO_PATTERN_DEF_SEQ (stmt_info) = NULL;\n       return;\n     }\n \n-  stmt = stmts_to_replace->last ();\n-  stmt_info = vinfo_for_stmt (stmt);\n   loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   gcc_assert (pattern_vectype);\n  \n@@ -4994,27 +4930,6 @@ vect_pattern_recog_1 (vect_recog_func *recog_func,\n       VEC_ORDERED_REMOVE_IF (LOOP_VINFO_REDUCTIONS (loop_vinfo), ix, ix2,\n \t\t\t     elem_ptr, *elem_ptr == stmt);\n     }\n-\n-  /* It is possible that additional pattern stmts are created and inserted in\n-     STMTS_TO_REPLACE.  We create a stmt_info for each of them, and mark the\n-     relevant statements.  */\n-  for (i = 0; stmts_to_replace->iterate (i, &stmt)\n-\t      && (unsigned) i < (stmts_to_replace->length () - 1);\n-       i++)\n-    {\n-      stmt_info = vinfo_for_stmt (stmt);\n-      pattern_stmt = STMT_VINFO_RELATED_STMT (stmt_info);\n-      if (dump_enabled_p ())\n-        {\n-          dump_printf_loc (MSG_NOTE, vect_location,\n-                           \"additional pattern stmt: \");\n-          dump_gimple_stmt (MSG_NOTE, TDF_SLIM, pattern_stmt, 0);\n-        }\n-\n-      vect_mark_pattern_stmts (stmt, pattern_stmt, NULL_TREE);\n-    }\n-\n-  return;\n }\n \n \n@@ -5103,7 +5018,6 @@ vect_pattern_recog (vec_info *vinfo)\n   unsigned int nbbs;\n   gimple_stmt_iterator si;\n   unsigned int i, j;\n-  auto_vec<gimple *, 1> stmts_to_replace;\n \n   vect_determine_precisions (vinfo);\n \n@@ -5123,8 +5037,7 @@ vect_pattern_recog (vec_info *vinfo)\n \t  for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n \t    /* Scan over all generic vect_recog_xxx_pattern functions.  */\n \t    for (j = 0; j < NUM_PATTERNS; j++)\n-\t      vect_pattern_recog_1 (&vect_vect_recog_func_ptrs[j], si,\n-\t\t\t\t    &stmts_to_replace);\n+\t      vect_pattern_recog_1 (&vect_vect_recog_func_ptrs[j], si);\n \t}\n     }\n   else\n@@ -5140,8 +5053,7 @@ vect_pattern_recog (vec_info *vinfo)\n \n \t  /* Scan over all generic vect_recog_xxx_pattern functions.  */\n \t  for (j = 0; j < NUM_PATTERNS; j++)\n-\t    vect_pattern_recog_1 (&vect_vect_recog_func_ptrs[j], si,\n-\t\t\t\t  &stmts_to_replace);\n+\t    vect_pattern_recog_1 (&vect_vect_recog_func_ptrs[j], si);\n \t}\n     }\n }"}]}