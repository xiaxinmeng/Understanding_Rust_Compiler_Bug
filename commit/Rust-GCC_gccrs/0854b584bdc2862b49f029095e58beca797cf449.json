{"sha": "0854b584bdc2862b49f029095e58beca797cf449", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDg1NGI1ODRiZGMyODYyYjQ5ZjAyOTA5NWU1OGJlY2E3OTdjZjQ0OQ==", "commit": {"author": {"name": "Matthew Malcomson", "email": "matthew.malcomson@arm.com", "date": "2020-11-25T16:31:45Z"}, "committer": {"name": "Matthew Malcomson", "email": "matthew.malcomson@arm.com", "date": "2020-11-25T16:38:06Z"}, "message": "libsanitizer: mid-end:  Introduce stack variable handling for HWASAN\n\nHandling stack variables has three features.\n\n1) Ensure HWASAN required alignment for stack variables\n\nWhen tagging shadow memory, we need to ensure that each tag granule is\nonly used by one variable at a time.\n\nThis is done by ensuring that each tagged variable is aligned to the tag\ngranule representation size and also ensure that the end of each\nobject is aligned to ensure the start of any other data stored on the\nstack is in a different granule.\n\nThis patch ensures the above by forcing the stack pointer to be aligned\nbefore and after allocating any stack objects. Since we are forcing\nalignment we also use `align_local_variable` to ensure this new alignment\nis advertised properly through SET_DECL_ALIGN.\n\n2) Put tags into each stack variable pointer\n\nMake sure that every pointer to a stack variable includes a tag of some\nsort on it.\n\nThe way tagging works is:\n  1) For every new stack frame, a random tag is generated.\n  2) A base register is formed from the stack pointer value and this\n     random tag.\n  3) References to stack variables are now formed with RTL describing an\n     offset from this base in both tag and value.\n\nThe random tag generation is handled by a backend hook.  This hook\ndecides whether to introduce a random tag or use the stack background\nbased on the parameter hwasan-random-frame-tag.  Using the stack\nbackground is necessary for testing and bootstrap.  It is necessary\nduring bootstrap to avoid breaking the `configure` test program for\ndetermining stack direction.\n\nUsing the stack background means that every stack frame has the initial\ntag of zero and variables are tagged with incrementing tags from 1,\nwhich also makes debugging a bit easier.\n\nBackend hooks define the size of a tag, the layout of the HWASAN shadow\nmemory, and handle emitting the code that inserts and extracts tags from a\npointer.\n\n3) For each stack variable, tag and untag the shadow stack on function\n   prologue and epilogue.\n\nOn entry to each function we tag the relevant shadow stack region for\neach stack variable. This stack region is tagged to match the tag added to\neach pointer to that variable.\n\nThis is the first patch where we use the HWASAN shadow space, so we need\nto add in the libhwasan initialisation code that creates this shadow\nmemory region into the binary we produce.  This instrumentation is done\nin `compile_file`.\n\nWhen exiting a function we need to ensure the shadow stack for this\nfunction has no remaining tags.  Without clearing the shadow stack area\nfor this stack frame, later function calls could get false positives\nwhen those later function calls check untagged areas (such as parameters\npassed on the stack) against a shadow stack area with left-over tag.\n\nHence we ensure that the entire stack frame is cleared on function exit.\n\nconfig/ChangeLog:\n\n\t* bootstrap-hwasan.mk: Disable random frame tags for stack-tagging\n\tduring bootstrap.\n\ngcc/ChangeLog:\n\n\t* asan.c (struct hwasan_stack_var): New.\n\t(hwasan_sanitize_p): New.\n\t(hwasan_sanitize_stack_p): New.\n\t(hwasan_sanitize_allocas_p): New.\n\t(initialize_sanitizer_builtins): Define new builtins.\n\t(ATTR_NOTHROW_LIST): New macro.\n\t(hwasan_current_frame_tag): New.\n\t(hwasan_frame_base): New.\n\t(stack_vars_base_reg_p): New.\n\t(hwasan_maybe_init_frame_base_init): New.\n\t(hwasan_record_stack_var): New.\n\t(hwasan_get_frame_extent): New.\n\t(hwasan_increment_frame_tag): New.\n\t(hwasan_record_frame_init): New.\n\t(hwasan_emit_prologue): New.\n\t(hwasan_emit_untag_frame): New.\n\t(hwasan_finish_file): New.\n\t(hwasan_truncate_to_tag_size): New.\n\t* asan.h (hwasan_record_frame_init): New declaration.\n\t(hwasan_record_stack_var): New declaration.\n\t(hwasan_emit_prologue): New declaration.\n\t(hwasan_emit_untag_frame): New declaration.\n\t(hwasan_get_frame_extent): New declaration.\n\t(hwasan_maybe_enit_frame_base_init): New declaration.\n\t(hwasan_frame_base): New declaration.\n\t(stack_vars_base_reg_p): New declaration.\n\t(hwasan_current_frame_tag): New declaration.\n\t(hwasan_increment_frame_tag): New declaration.\n\t(hwasan_truncate_to_tag_size): New declaration.\n\t(hwasan_finish_file): New declaration.\n\t(hwasan_sanitize_p): New declaration.\n\t(hwasan_sanitize_stack_p): New declaration.\n\t(hwasan_sanitize_allocas_p): New declaration.\n\t(HWASAN_TAG_SIZE): New macro.\n\t(HWASAN_TAG_GRANULE_SIZE): New macro.\n\t(HWASAN_STACK_BACKGROUND): New macro.\n\t* builtin-types.def (BT_FN_VOID_PTR_UINT8_PTRMODE): New.\n\t* builtins.def (DEF_SANITIZER_BUILTIN): Enable for HWASAN.\n\t* cfgexpand.c (align_local_variable): When using hwasan ensure\n\talignment to tag granule.\n\t(align_frame_offset): New.\n\t(expand_one_stack_var_at): For hwasan use tag offset.\n\t(expand_stack_vars): Record stack objects for hwasan.\n\t(expand_one_stack_var_1): Record stack objects for hwasan.\n\t(init_vars_expansion): Initialise hwasan state.\n\t(expand_used_vars): Emit hwasan prologue and generate hwasan epilogue.\n\t(pass_expand::execute): Emit hwasan base initialization if needed.\n\t* doc/tm.texi (TARGET_MEMTAG_TAG_SIZE,TARGET_MEMTAG_GRANULE_SIZE,\n\tTARGET_MEMTAG_INSERT_RANDOM_TAG,TARGET_MEMTAG_ADD_TAG,\n\tTARGET_MEMTAG_SET_TAG,TARGET_MEMTAG_EXTRACT_TAG,\n\tTARGET_MEMTAG_UNTAGGED_POINTER): Document new hooks.\n\t* doc/tm.texi.in (TARGET_MEMTAG_TAG_SIZE,TARGET_MEMTAG_GRANULE_SIZE,\n\tTARGET_MEMTAG_INSERT_RANDOM_TAG,TARGET_MEMTAG_ADD_TAG,\n\tTARGET_MEMTAG_SET_TAG,TARGET_MEMTAG_EXTRACT_TAG,\n\tTARGET_MEMTAG_UNTAGGED_POINTER): Document new hooks.\n\t* explow.c (get_dynamic_stack_base): Take new `base` argument.\n\t* explow.h (get_dynamic_stack_base): Take new `base` argument.\n\t* sanitizer.def (BUILT_IN_HWASAN_INIT): New.\n\t(BUILT_IN_HWASAN_TAG_MEM): New.\n\t* target.def (target_memtag_tag_size,target_memtag_granule_size,\n\ttarget_memtag_insert_random_tag,target_memtag_add_tag,\n\ttarget_memtag_set_tag,target_memtag_extract_tag,\n\ttarget_memtag_untagged_pointer): New hooks.\n\t* targhooks.c (HWASAN_SHIFT): New.\n\t(HWASAN_SHIFT_RTX): New.\n\t(default_memtag_tag_size): New default hook.\n\t(default_memtag_granule_size): New default hook.\n\t(default_memtag_insert_random_tag): New default hook.\n\t(default_memtag_add_tag): New default hook.\n\t(default_memtag_set_tag): New default hook.\n\t(default_memtag_extract_tag): New default hook.\n\t(default_memtag_untagged_pointer): New default hook.\n\t* targhooks.h (default_memtag_tag_size): New default hook.\n\t(default_memtag_granule_size): New default hook.\n\t(default_memtag_insert_random_tag): New default hook.\n\t(default_memtag_add_tag): New default hook.\n\t(default_memtag_set_tag): New default hook.\n\t(default_memtag_extract_tag): New default hook.\n\t(default_memtag_untagged_pointer): New default hook.\n\t* toplev.c (compile_file): Call hwasan_finish_file when finished.", "tree": {"sha": "e94eeff162ddb12990760dd50c50754a56d1b957", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e94eeff162ddb12990760dd50c50754a56d1b957"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0854b584bdc2862b49f029095e58beca797cf449", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0854b584bdc2862b49f029095e58beca797cf449", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0854b584bdc2862b49f029095e58beca797cf449", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0854b584bdc2862b49f029095e58beca797cf449/comments", "author": {"login": "mmalcomson", "id": 57484298, "node_id": "MDQ6VXNlcjU3NDg0Mjk4", "avatar_url": "https://avatars.githubusercontent.com/u/57484298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mmalcomson", "html_url": "https://github.com/mmalcomson", "followers_url": "https://api.github.com/users/mmalcomson/followers", "following_url": "https://api.github.com/users/mmalcomson/following{/other_user}", "gists_url": "https://api.github.com/users/mmalcomson/gists{/gist_id}", "starred_url": "https://api.github.com/users/mmalcomson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mmalcomson/subscriptions", "organizations_url": "https://api.github.com/users/mmalcomson/orgs", "repos_url": "https://api.github.com/users/mmalcomson/repos", "events_url": "https://api.github.com/users/mmalcomson/events{/privacy}", "received_events_url": "https://api.github.com/users/mmalcomson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mmalcomson", "id": 57484298, "node_id": "MDQ6VXNlcjU3NDg0Mjk4", "avatar_url": "https://avatars.githubusercontent.com/u/57484298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mmalcomson", "html_url": "https://github.com/mmalcomson", "followers_url": "https://api.github.com/users/mmalcomson/followers", "following_url": "https://api.github.com/users/mmalcomson/following{/other_user}", "gists_url": "https://api.github.com/users/mmalcomson/gists{/gist_id}", "starred_url": "https://api.github.com/users/mmalcomson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mmalcomson/subscriptions", "organizations_url": "https://api.github.com/users/mmalcomson/orgs", "repos_url": "https://api.github.com/users/mmalcomson/repos", "events_url": "https://api.github.com/users/mmalcomson/events{/privacy}", "received_events_url": "https://api.github.com/users/mmalcomson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bd8783207760cc805d8a4e64e5ac92ca508a711", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bd8783207760cc805d8a4e64e5ac92ca508a711", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bd8783207760cc805d8a4e64e5ac92ca508a711"}], "stats": {"total": 912, "additions": 885, "deletions": 27}, "files": [{"sha": "91989f4bb1db6ccff564383777757b896645e541", "filename": "config/bootstrap-hwasan.mk", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0854b584bdc2862b49f029095e58beca797cf449/config%2Fbootstrap-hwasan.mk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0854b584bdc2862b49f029095e58beca797cf449/config%2Fbootstrap-hwasan.mk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fbootstrap-hwasan.mk?ref=0854b584bdc2862b49f029095e58beca797cf449", "patch": "@@ -1,7 +1,11 @@\n # This option enables -fsanitize=hwaddress for stage2 and stage3.\n+# We need to disable random frame tags for bootstrap since the autoconf check\n+# for which direction the stack is growing has UB that a random frame tag\n+# breaks.  Running with a random frame tag gives approx. 50% chance of\n+# bootstrap comparison diff in libiberty/alloca.c.\n \n-STAGE2_CFLAGS += -fsanitize=hwaddress\n-STAGE3_CFLAGS += -fsanitize=hwaddress\n+STAGE2_CFLAGS += -fsanitize=hwaddress --param hwasan-random-frame-tag=0\n+STAGE3_CFLAGS += -fsanitize=hwaddress --param hwasan-random-frame-tag=0\n POSTSTAGE1_LDFLAGS += -fsanitize=hwaddress -static-libhwasan \\\n \t\t      -B$$r/prev-$(TARGET_SUBDIR)/libsanitizer/ \\\n \t\t      -B$$r/prev-$(TARGET_SUBDIR)/libsanitizer/hwasan/ \\"}, {"sha": "d1ede3b62291eba698948e06208c482b6f197be5", "filename": "gcc/asan.c", "status": "modified", "additions": 424, "deletions": 0, "changes": 424, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0854b584bdc2862b49f029095e58beca797cf449/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0854b584bdc2862b49f029095e58beca797cf449/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=0854b584bdc2862b49f029095e58beca797cf449", "patch": "@@ -257,6 +257,58 @@ hash_set<tree> *asan_handled_variables = NULL;\n \n hash_set <tree> *asan_used_labels = NULL;\n \n+/* Global variables for HWASAN stack tagging.  */\n+/* hwasan_frame_tag_offset records the offset from the frame base tag that the\n+   next object should have.  */\n+static uint8_t hwasan_frame_tag_offset = 0;\n+/* hwasan_frame_base_ptr is a pointer with the same address as\n+   `virtual_stack_vars_rtx` for the current frame, and with the frame base tag\n+   stored in it.  N.b. this global RTX does not need to be marked GTY, but is\n+   done so anyway.  The need is not there since all uses are in just one pass\n+   (cfgexpand) and there are no calls to ggc_collect between the uses.  We mark\n+   it GTY(()) anyway to allow the use of the variable later on if needed by\n+   future features.  */\n+static GTY(()) rtx hwasan_frame_base_ptr = NULL_RTX;\n+/* hwasan_frame_base_init_seq is the sequence of RTL insns that will initialize\n+   the hwasan_frame_base_ptr.  When the hwasan_frame_base_ptr is requested, we\n+   generate this sequence but do not emit it.  If the sequence was created it\n+   is emitted once the function body has been expanded.\n+\n+   This delay is because the frame base pointer may be needed anywhere in the\n+   function body, or needed by the expand_used_vars function.  Emitting once in\n+   a known place is simpler than requiring the emission of the instructions to\n+   be know where it should go depending on the first place the hwasan frame\n+   base is needed.  */\n+static GTY(()) rtx_insn *hwasan_frame_base_init_seq = NULL;\n+\n+/* Structure defining the extent of one object on the stack that HWASAN needs\n+   to tag in the corresponding shadow stack space.\n+\n+   The range this object spans on the stack is between `untagged_base +\n+   nearest_offset` and `untagged_base + farthest_offset`.\n+   `tagged_base` is an rtx containing the same value as `untagged_base` but\n+   with a random tag stored in the top byte.  We record both `untagged_base`\n+   and `tagged_base` so that `hwasan_emit_prologue` can use both without having\n+   to emit RTL into the instruction stream to re-calculate one from the other.\n+   (`hwasan_emit_prologue` needs to use both bases since the\n+   __hwasan_tag_memory call it emits uses an untagged value, and it calculates\n+   the tag to store in shadow memory based on the tag_offset plus the tag in\n+   tagged_base).  */\n+struct hwasan_stack_var\n+{\n+  rtx untagged_base;\n+  rtx tagged_base;\n+  poly_int64 nearest_offset;\n+  poly_int64 farthest_offset;\n+  uint8_t tag_offset;\n+};\n+\n+/* Variable recording all stack variables that HWASAN needs to tag.\n+   Does not need to be marked as GTY(()) since every use is in the cfgexpand\n+   pass and gcc_collect is not called in the middle of that pass.  */\n+static vec<hwasan_stack_var> hwasan_tagged_stack_vars;\n+\n+\n /* Sets shadow offset to value in string VAL.  */\n \n bool\n@@ -1359,6 +1411,28 @@ asan_redzone_buffer::flush_if_full (void)\n     flush_redzone_payload ();\n }\n \n+/* Returns whether we are tagging pointers and checking those tags on memory\n+   access.  */\n+bool\n+hwasan_sanitize_p ()\n+{\n+  return sanitize_flags_p (SANITIZE_HWADDRESS);\n+}\n+\n+/* Are we tagging the stack?  */\n+bool\n+hwasan_sanitize_stack_p ()\n+{\n+  return (hwasan_sanitize_p () && param_hwasan_instrument_stack);\n+}\n+\n+/* Are we tagging alloca objects?  */\n+bool\n+hwasan_sanitize_allocas_p (void)\n+{\n+  return (hwasan_sanitize_stack_p () && param_hwasan_instrument_allocas);\n+}\n+\n /* Insert code to protect stack vars.  The prologue sequence should be emitted\n    directly, epilogue sequence returned.  BASE is the register holding the\n    stack base, against which OFFSETS array offsets are relative to, OFFSETS\n@@ -2908,6 +2982,11 @@ initialize_sanitizer_builtins (void)\n     = build_function_type_list (void_type_node, uint64_type_node,\n \t\t\t\tptr_type_node, NULL_TREE);\n \n+  tree BT_FN_VOID_PTR_UINT8_PTRMODE\n+    = build_function_type_list (void_type_node, ptr_type_node,\n+\t\t\t\tunsigned_char_type_node,\n+\t\t\t\tpointer_sized_int_node, NULL_TREE);\n+\n   tree BT_FN_BOOL_VPTR_PTR_IX_INT_INT[5];\n   tree BT_FN_IX_CONST_VPTR_INT[5];\n   tree BT_FN_IX_VPTR_IX_INT[5];\n@@ -2958,6 +3037,8 @@ initialize_sanitizer_builtins (void)\n #define BT_FN_I16_CONST_VPTR_INT BT_FN_IX_CONST_VPTR_INT[4]\n #define BT_FN_I16_VPTR_I16_INT BT_FN_IX_VPTR_IX_INT[4]\n #define BT_FN_VOID_VPTR_I16_INT BT_FN_VOID_VPTR_IX_INT[4]\n+#undef ATTR_NOTHROW_LIST\n+#define ATTR_NOTHROW_LIST ECF_NOTHROW\n #undef ATTR_NOTHROW_LEAF_LIST\n #define ATTR_NOTHROW_LEAF_LIST ECF_NOTHROW | ECF_LEAF\n #undef ATTR_TMPURE_NOTHROW_LEAF_LIST\n@@ -3709,4 +3790,347 @@ make_pass_asan_O0 (gcc::context *ctxt)\n   return new pass_asan_O0 (ctxt);\n }\n \n+/* For stack tagging:\n+\n+   Return the offset from the frame base tag that the \"next\" expanded object\n+   should have.  */\n+uint8_t\n+hwasan_current_frame_tag ()\n+{\n+  return hwasan_frame_tag_offset;\n+}\n+\n+/* For stack tagging:\n+\n+   Return the 'base pointer' for this function.  If that base pointer has not\n+   yet been created then we create a register to hold it and record the insns\n+   to initialize the register in `hwasan_frame_base_init_seq` for later\n+   emission.  */\n+rtx\n+hwasan_frame_base ()\n+{\n+  if (! hwasan_frame_base_ptr)\n+    {\n+      start_sequence ();\n+      hwasan_frame_base_ptr\n+\t= force_reg (Pmode,\n+\t\t     targetm.memtag.insert_random_tag (virtual_stack_vars_rtx,\n+\t\t\t\t\t\t       NULL_RTX));\n+      hwasan_frame_base_init_seq = get_insns ();\n+      end_sequence ();\n+    }\n+\n+  return hwasan_frame_base_ptr;\n+}\n+\n+/* For stack tagging:\n+\n+   Check whether this RTX is a standard pointer addressing the base of the\n+   stack variables for this frame.  Returns true if the RTX is either\n+   virtual_stack_vars_rtx or hwasan_frame_base_ptr.  */\n+bool\n+stack_vars_base_reg_p (rtx base)\n+{\n+  return base == virtual_stack_vars_rtx || base == hwasan_frame_base_ptr;\n+}\n+\n+/* For stack tagging:\n+\n+   Emit frame base initialisation.\n+   If hwasan_frame_base has been used before here then\n+   hwasan_frame_base_init_seq contains the sequence of instructions to\n+   initialize it.  This must be put just before the hwasan prologue, so we emit\n+   the insns before parm_birth_insn (which will point to the first instruction\n+   of the hwasan prologue if it exists).\n+\n+   We update `parm_birth_insn` to point to the start of this initialisation\n+   since that represents the end of the initialisation done by\n+   expand_function_{start,end} functions and we want to maintain that.  */\n+void\n+hwasan_maybe_emit_frame_base_init ()\n+{\n+  if (! hwasan_frame_base_init_seq)\n+    return;\n+  emit_insn_before (hwasan_frame_base_init_seq, parm_birth_insn);\n+  parm_birth_insn = hwasan_frame_base_init_seq;\n+}\n+\n+/* Record a compile-time constant size stack variable that HWASAN will need to\n+   tag.  This record of the range of a stack variable will be used by\n+   `hwasan_emit_prologue` to emit the RTL at the start of each frame which will\n+   set tags in the shadow memory according to the assigned tag for each object.\n+\n+   The range that the object spans in stack space should be described by the\n+   bounds `untagged_base + nearest_offset` and\n+   `untagged_base + farthest_offset`.\n+   `tagged_base` is the base address which contains the \"base frame tag\" for\n+   this frame, and from which the value to address this object with will be\n+   calculated.\n+\n+   We record the `untagged_base` since the functions in the hwasan library we\n+   use to tag memory take pointers without a tag.  */\n+void\n+hwasan_record_stack_var (rtx untagged_base, rtx tagged_base,\n+\t\t\t poly_int64 nearest_offset, poly_int64 farthest_offset)\n+{\n+  hwasan_stack_var cur_var;\n+  cur_var.untagged_base = untagged_base;\n+  cur_var.tagged_base = tagged_base;\n+  cur_var.nearest_offset = nearest_offset;\n+  cur_var.farthest_offset = farthest_offset;\n+  cur_var.tag_offset = hwasan_current_frame_tag ();\n+\n+  hwasan_tagged_stack_vars.safe_push (cur_var);\n+}\n+\n+/* Return the RTX representing the farthest extent of the statically allocated\n+   stack objects for this frame.  If hwasan_frame_base_ptr has not been\n+   initialized then we are not storing any static variables on the stack in\n+   this frame.  In this case we return NULL_RTX to represent that.\n+\n+   Otherwise simply return virtual_stack_vars_rtx + frame_offset.  */\n+rtx\n+hwasan_get_frame_extent ()\n+{\n+  return (hwasan_frame_base_ptr\n+\t  ? plus_constant (Pmode, virtual_stack_vars_rtx, frame_offset)\n+\t  : NULL_RTX);\n+}\n+\n+/* For stack tagging:\n+\n+   Increment the frame tag offset modulo the size a tag can represent.  */\n+void\n+hwasan_increment_frame_tag ()\n+{\n+  uint8_t tag_bits = HWASAN_TAG_SIZE;\n+  gcc_assert (HWASAN_TAG_SIZE\n+\t      <= sizeof (hwasan_frame_tag_offset) * CHAR_BIT);\n+  hwasan_frame_tag_offset = (hwasan_frame_tag_offset + 1) % (1 << tag_bits);\n+  /* The \"background tag\" of the stack is zero by definition.\n+     This is the tag that objects like parameters passed on the stack and\n+     spilled registers are given.  It is handy to avoid this tag for objects\n+     whose tags we decide ourselves, partly to ensure that buffer overruns\n+     can't affect these important variables (e.g. saved link register, saved\n+     stack pointer etc) and partly to make debugging easier (everything with a\n+     tag of zero is space allocated automatically by the compiler).\n+\n+     This is not feasible when using random frame tags (the default\n+     configuration for hwasan) since the tag for the given frame is randomly\n+     chosen at runtime.  In order to avoid any tags matching the stack\n+     background we would need to decide tag offsets at runtime instead of\n+     compile time (and pay the resulting performance cost).\n+\n+     When not using random base tags for each frame (i.e. when compiled with\n+     `--param hwasan-random-frame-tag=0`) the base tag for each frame is zero.\n+     This means the tag that each object gets is equal to the\n+     hwasan_frame_tag_offset used in determining it.\n+     When this is the case we *can* ensure no object gets the tag of zero by\n+     simply ensuring no object has the hwasan_frame_tag_offset of zero.\n+\n+     There is the extra complication that we only record the\n+     hwasan_frame_tag_offset here (which is the offset from the tag stored in\n+     the stack pointer).  In the kernel, the tag in the stack pointer is 0xff\n+     rather than zero.  This does not cause problems since tags of 0xff are\n+     never checked in the kernel.  As mentioned at the beginning of this\n+     comment the background tag of the stack is zero by definition, which means\n+     that for the kernel we should skip offsets of both 0 and 1 from the stack\n+     pointer.  Avoiding the offset of 0 ensures we use a tag which will be\n+     checked, avoiding the offset of 1 ensures we use a tag that is not the\n+     same as the background.  */\n+  if (hwasan_frame_tag_offset == 0 && ! param_hwasan_random_frame_tag)\n+    hwasan_frame_tag_offset += 1;\n+  if (hwasan_frame_tag_offset == 1 && ! param_hwasan_random_frame_tag\n+      && sanitize_flags_p (SANITIZE_KERNEL_HWADDRESS))\n+    hwasan_frame_tag_offset += 1;\n+}\n+\n+/* Clear internal state for the next function.\n+   This function is called before variables on the stack get expanded, in\n+   `init_vars_expansion`.  */\n+void\n+hwasan_record_frame_init ()\n+{\n+  delete asan_used_labels;\n+  asan_used_labels = NULL;\n+\n+  /* If this isn't the case then some stack variable was recorded *before*\n+     hwasan_record_frame_init is called, yet *after* the hwasan prologue for\n+     the previous frame was emitted.  Such stack variables would not have\n+     their shadow stack filled in.  */\n+  gcc_assert (hwasan_tagged_stack_vars.is_empty ());\n+  hwasan_frame_base_ptr = NULL_RTX;\n+  hwasan_frame_base_init_seq = NULL;\n+\n+  /* When not using a random frame tag we can avoid the background stack\n+     color which gives the user a little better debug output upon a crash.\n+     Meanwhile, when using a random frame tag it will be nice to avoid adding\n+     tags for the first object since that is unnecessary extra work.\n+     Hence set the initial hwasan_frame_tag_offset to be 0 if using a random\n+     frame tag and 1 otherwise.\n+\n+     As described in hwasan_increment_frame_tag, in the kernel the stack\n+     pointer has the tag 0xff.  That means that to avoid 0xff and 0 (the tag\n+     which the kernel does not check and the background tag respectively) we\n+     start with a tag offset of 2.  */\n+  hwasan_frame_tag_offset = param_hwasan_random_frame_tag\n+    ? 0\n+    : sanitize_flags_p (SANITIZE_KERNEL_HWADDRESS) ? 2 : 1;\n+}\n+\n+/* For stack tagging:\n+   (Emits HWASAN equivalent of what is emitted by\n+   `asan_emit_stack_protection`).\n+\n+   Emits the extra prologue code to set the shadow stack as required for HWASAN\n+   stack instrumentation.\n+\n+   Uses the vector of recorded stack variables hwasan_tagged_stack_vars.  When\n+   this function has completed hwasan_tagged_stack_vars is empty and all\n+   objects it had pointed to are deallocated.  */\n+void\n+hwasan_emit_prologue ()\n+{\n+  /* We need untagged base pointers since libhwasan only accepts untagged\n+    pointers in __hwasan_tag_memory.  We need the tagged base pointer to obtain\n+    the base tag for an offset.  */\n+\n+  if (hwasan_tagged_stack_vars.is_empty ())\n+    return;\n+\n+  poly_int64 bot = 0, top = 0;\n+  for (hwasan_stack_var &cur : hwasan_tagged_stack_vars)\n+    {\n+      poly_int64 nearest = cur.nearest_offset;\n+      poly_int64 farthest = cur.farthest_offset;\n+\n+      if (known_ge (nearest, farthest))\n+\t{\n+\t  top = nearest;\n+\t  bot = farthest;\n+\t}\n+      else\n+\t{\n+\t  /* Given how these values are calculated, one must be known greater\n+\t     than the other.  */\n+\t  gcc_assert (known_le (nearest, farthest));\n+\t  top = farthest;\n+\t  bot = nearest;\n+\t}\n+      poly_int64 size = (top - bot);\n+\n+      /* Assert the edge of each variable is aligned to the HWASAN tag granule\n+\t size.  */\n+      gcc_assert (multiple_p (top, HWASAN_TAG_GRANULE_SIZE));\n+      gcc_assert (multiple_p (bot, HWASAN_TAG_GRANULE_SIZE));\n+      gcc_assert (multiple_p (size, HWASAN_TAG_GRANULE_SIZE));\n+\n+      rtx fn = init_one_libfunc (\"__hwasan_tag_memory\");\n+      rtx base_tag = targetm.memtag.extract_tag (cur.tagged_base, NULL_RTX);\n+      rtx tag = plus_constant (QImode, base_tag, cur.tag_offset);\n+      tag = hwasan_truncate_to_tag_size (tag, NULL_RTX);\n+\n+      rtx bottom = convert_memory_address (ptr_mode,\n+\t\t\t\t\t   plus_constant (Pmode,\n+\t\t\t\t\t\t\t  cur.untagged_base,\n+\t\t\t\t\t\t\t  bot));\n+      emit_library_call (fn, LCT_NORMAL, VOIDmode,\n+\t\t\t bottom, ptr_mode,\n+\t\t\t tag, QImode,\n+\t\t\t gen_int_mode (size, ptr_mode), ptr_mode);\n+    }\n+  /* Clear the stack vars, we've emitted the prologue for them all now.  */\n+  hwasan_tagged_stack_vars.truncate (0);\n+}\n+\n+/* For stack tagging:\n+\n+   Return RTL insns to clear the tags between DYNAMIC and VARS pointers\n+   into the stack.  These instructions should be emitted at the end of\n+   every function.\n+\n+   If `dynamic` is NULL_RTX then no insns are returned.  */\n+rtx_insn *\n+hwasan_emit_untag_frame (rtx dynamic, rtx vars)\n+{\n+  if (! dynamic)\n+    return NULL;\n+\n+  start_sequence ();\n+\n+  dynamic = convert_memory_address (ptr_mode, dynamic);\n+  vars = convert_memory_address (ptr_mode, vars);\n+\n+  rtx top_rtx;\n+  rtx bot_rtx;\n+  if (FRAME_GROWS_DOWNWARD)\n+    {\n+      top_rtx = vars;\n+      bot_rtx = dynamic;\n+    }\n+  else\n+    {\n+      top_rtx = dynamic;\n+      bot_rtx = vars;\n+    }\n+\n+  rtx size_rtx = expand_simple_binop (ptr_mode, MINUS, top_rtx, bot_rtx,\n+\t\t\t\t      NULL_RTX, /* unsignedp = */0,\n+\t\t\t\t      OPTAB_DIRECT);\n+\n+  rtx fn = init_one_libfunc (\"__hwasan_tag_memory\");\n+  emit_library_call (fn, LCT_NORMAL, VOIDmode,\n+\t\t     bot_rtx, ptr_mode,\n+\t\t     HWASAN_STACK_BACKGROUND, QImode,\n+\t\t     size_rtx, ptr_mode);\n+\n+  do_pending_stack_adjust ();\n+  rtx_insn *insns = get_insns ();\n+  end_sequence ();\n+  return insns;\n+}\n+\n+/* Needs to be GTY(()), because cgraph_build_static_cdtor may\n+   invoke ggc_collect.  */\n+static GTY(()) tree hwasan_ctor_statements;\n+\n+/* Insert module initialization into this TU.  This initialization calls the\n+   initialization code for libhwasan.  */\n+void\n+hwasan_finish_file (void)\n+{\n+  /* Do not emit constructor initialization for the kernel.\n+     (the kernel has its own initialization already).  */\n+  if (flag_sanitize & SANITIZE_KERNEL_HWADDRESS)\n+    return;\n+\n+  /* Avoid instrumenting code in the hwasan constructors/destructors.  */\n+  flag_sanitize &= ~SANITIZE_HWADDRESS;\n+  int priority = MAX_RESERVED_INIT_PRIORITY - 1;\n+  tree fn = builtin_decl_implicit (BUILT_IN_HWASAN_INIT);\n+  append_to_statement_list (build_call_expr (fn, 0), &hwasan_ctor_statements);\n+  cgraph_build_static_cdtor ('I', hwasan_ctor_statements, priority);\n+  flag_sanitize |= SANITIZE_HWADDRESS;\n+}\n+\n+/* For stack tagging:\n+\n+   Truncate `tag` to the number of bits that a tag uses (i.e. to\n+   HWASAN_TAG_SIZE).  Store the result in `target` if it's convenient.  */\n+rtx\n+hwasan_truncate_to_tag_size (rtx tag, rtx target)\n+{\n+  gcc_assert (GET_MODE (tag) == QImode);\n+  if (HWASAN_TAG_SIZE != GET_MODE_PRECISION (QImode))\n+    {\n+      gcc_assert (GET_MODE_PRECISION (QImode) > HWASAN_TAG_SIZE);\n+      rtx mask = gen_int_mode ((HOST_WIDE_INT_1U << HWASAN_TAG_SIZE) - 1,\n+\t\t\t       QImode);\n+      tag = expand_simple_binop (QImode, AND, tag, mask, target,\n+\t\t\t\t /* unsignedp = */1, OPTAB_WIDEN);\n+      gcc_assert (tag);\n+    }\n+  return tag;\n+}\n+\n #include \"gt-asan.h\""}, {"sha": "8d5271e6b575d74da277420798557f3274e966ce", "filename": "gcc/asan.h", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0854b584bdc2862b49f029095e58beca797cf449/gcc%2Fasan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0854b584bdc2862b49f029095e58beca797cf449/gcc%2Fasan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.h?ref=0854b584bdc2862b49f029095e58beca797cf449", "patch": "@@ -34,6 +34,22 @@ extern bool asan_expand_mark_ifn (gimple_stmt_iterator *);\n extern bool asan_expand_poison_ifn (gimple_stmt_iterator *, bool *,\n \t\t\t\t    hash_map<tree, tree> &);\n \n+extern void hwasan_record_frame_init ();\n+extern void hwasan_record_stack_var (rtx, rtx, poly_int64, poly_int64);\n+extern void hwasan_emit_prologue ();\n+extern rtx_insn *hwasan_emit_untag_frame (rtx, rtx);\n+extern rtx hwasan_get_frame_extent ();\n+extern rtx hwasan_frame_base ();\n+extern void hwasan_maybe_emit_frame_base_init (void);\n+extern bool stack_vars_base_reg_p (rtx);\n+extern uint8_t hwasan_current_frame_tag ();\n+extern void hwasan_increment_frame_tag ();\n+extern rtx hwasan_truncate_to_tag_size (rtx, rtx);\n+extern void hwasan_finish_file (void);\n+extern bool hwasan_sanitize_p (void);\n+extern bool hwasan_sanitize_stack_p (void);\n+extern bool hwasan_sanitize_allocas_p (void);\n+\n extern gimple_stmt_iterator create_cond_insert_point\n      (gimple_stmt_iterator *, bool, bool, bool, basic_block *, basic_block *);\n \n@@ -75,6 +91,26 @@ extern hash_set <tree> *asan_used_labels;\n \n #define ASAN_USE_AFTER_SCOPE_ATTRIBUTE\t\"use after scope memory\"\n \n+/* NOTE: The values below and the hooks under targetm.memtag define an ABI and\n+   are hard-coded to these values in libhwasan, hence they can't be changed\n+   independently here.  */\n+/* How many bits are used to store a tag in a pointer.\n+   The default version uses the entire top byte of a pointer (i.e. 8 bits).  */\n+#define HWASAN_TAG_SIZE targetm.memtag.tag_size ()\n+/* Tag Granule of HWASAN shadow stack.\n+   This is the size in real memory that each byte in the shadow memory refers\n+   to.  I.e. if a variable is X bytes long in memory then its tag in shadow\n+   memory will span X / HWASAN_TAG_GRANULE_SIZE bytes.\n+   Most variables will need to be aligned to this amount since two variables\n+   that are neighbors in memory and share a tag granule would need to share the\n+   same tag (the shared tag granule can only store one tag).  */\n+#define HWASAN_TAG_GRANULE_SIZE targetm.memtag.granule_size ()\n+/* Define the tag for the stack background.\n+   This defines what tag the stack pointer will be and hence what tag all\n+   variables that are not given special tags are (e.g. spilled registers,\n+   and parameters passed on the stack).  */\n+#define HWASAN_STACK_BACKGROUND gen_int_mode (0, QImode)\n+\n /* Various flags for Asan builtins.  */\n enum asan_check_flags\n {"}, {"sha": "1ad6657da45cc4976532e1b8bc233f67d8da9ccf", "filename": "gcc/builtin-types.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0854b584bdc2862b49f029095e58beca797cf449/gcc%2Fbuiltin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0854b584bdc2862b49f029095e58beca797cf449/gcc%2Fbuiltin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-types.def?ref=0854b584bdc2862b49f029095e58beca797cf449", "patch": "@@ -639,6 +639,8 @@ DEF_FUNCTION_TYPE_3 (BT_FN_PTR_PTR_CONST_SIZE_BOOL,\n \t\t     BT_PTR, BT_PTR, BT_CONST_SIZE, BT_BOOL)\n DEF_FUNCTION_TYPE_3 (BT_FN_PTR_SIZE_SIZE_PTRMODE,\n \t\t     BT_PTR, BT_SIZE, BT_SIZE, BT_PTRMODE)\n+DEF_FUNCTION_TYPE_3 (BT_FN_VOID_PTR_UINT8_PTRMODE, BT_VOID, BT_PTR, BT_UINT8,\n+\t\t     BT_PTRMODE)\n \n DEF_FUNCTION_TYPE_4 (BT_FN_SIZE_CONST_PTR_SIZE_SIZE_FILEPTR,\n \t\t     BT_SIZE, BT_CONST_PTR, BT_SIZE, BT_SIZE, BT_FILEPTR)"}, {"sha": "aec43caec4945605f90e9477fb05faa0b9b24ca8", "filename": "gcc/builtins.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0854b584bdc2862b49f029095e58beca797cf449/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0854b584bdc2862b49f029095e58beca797cf449/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=0854b584bdc2862b49f029095e58beca797cf449", "patch": "@@ -245,6 +245,7 @@ along with GCC; see the file COPYING3.  If not see\n   DEF_BUILTIN (ENUM, \"__builtin_\" NAME, BUILT_IN_NORMAL, TYPE, TYPE,    \\\n \t       true, true, true, ATTRS, true, \\\n \t      (flag_sanitize & (SANITIZE_ADDRESS | SANITIZE_THREAD \\\n+\t\t\t\t| SANITIZE_HWADDRESS \\\n \t\t\t\t| SANITIZE_UNDEFINED \\\n \t\t\t\t| SANITIZE_UNDEFINED_NONDEFAULT) \\\n \t       || flag_sanitize_coverage))"}, {"sha": "7e0bdd58e85f9f8c686b62e07e0d4f831fda3750", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 146, "deletions": 21, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0854b584bdc2862b49f029095e58beca797cf449/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0854b584bdc2862b49f029095e58beca797cf449/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=0854b584bdc2862b49f029095e58beca797cf449", "patch": "@@ -376,15 +376,18 @@ align_local_variable (tree decl, bool really_expand)\n \talign = GET_MODE_ALIGNMENT (mode);\n     }\n   else\n-    {\n-      align = LOCAL_DECL_ALIGNMENT (decl);\n-      /* Don't change DECL_ALIGN when called from estimated_stack_frame_size.\n-\t That is done before IPA and could bump alignment based on host\n-\t backend even for offloaded code which wants different\n-\t LOCAL_DECL_ALIGNMENT.  */\n-      if (really_expand)\n-\tSET_DECL_ALIGN (decl, align);\n-    }\n+    align = LOCAL_DECL_ALIGNMENT (decl);\n+\n+  if (hwasan_sanitize_stack_p ())\n+    align = MAX (align, (unsigned) HWASAN_TAG_GRANULE_SIZE * BITS_PER_UNIT);\n+\n+  if (TREE_CODE (decl) != SSA_NAME && really_expand)\n+    /* Don't change DECL_ALIGN when called from estimated_stack_frame_size.\n+       That is done before IPA and could bump alignment based on host\n+       backend even for offloaded code which wants different\n+       LOCAL_DECL_ALIGNMENT.  */\n+    SET_DECL_ALIGN (decl, align);\n+\n   return align / BITS_PER_UNIT;\n }\n \n@@ -428,6 +431,14 @@ alloc_stack_frame_space (poly_int64 size, unsigned HOST_WIDE_INT align)\n   return offset;\n }\n \n+/* Ensure that the stack is aligned to ALIGN bytes.\n+   Return the new frame offset.  */\n+static poly_int64\n+align_frame_offset (unsigned HOST_WIDE_INT align)\n+{\n+  return alloc_stack_frame_space (0, align);\n+}\n+\n /* Accumulate DECL into STACK_VARS.  */\n \n static void\n@@ -1004,7 +1015,12 @@ expand_one_stack_var_at (tree decl, rtx base, unsigned base_align,\n   /* If this fails, we've overflowed the stack frame.  Error nicely?  */\n   gcc_assert (known_eq (offset, trunc_int_for_mode (offset, Pmode)));\n \n-  x = plus_constant (Pmode, base, offset);\n+  if (hwasan_sanitize_stack_p ())\n+    x = targetm.memtag.add_tag (base, offset,\n+\t\t\t\thwasan_current_frame_tag ());\n+  else\n+    x = plus_constant (Pmode, base, offset);\n+\n   x = gen_rtx_MEM (TREE_CODE (decl) == SSA_NAME\n \t\t   ? TYPE_MODE (TREE_TYPE (decl))\n \t\t   : DECL_MODE (decl), x);\n@@ -1013,7 +1029,7 @@ expand_one_stack_var_at (tree decl, rtx base, unsigned base_align,\n      If it is we generate stack slots only accidentally so it isn't as\n      important, we'll simply set the alignment directly on the MEM.  */\n \n-  if (base == virtual_stack_vars_rtx)\n+  if (stack_vars_base_reg_p (base))\n     offset -= frame_phase;\n   align = known_alignment (offset);\n   align *= BITS_PER_UNIT;\n@@ -1056,13 +1072,13 @@ class stack_vars_data\n /* A subroutine of expand_used_vars.  Give each partition representative\n    a unique location within the stack frame.  Update each partition member\n    with that location.  */\n-\n static void\n expand_stack_vars (bool (*pred) (size_t), class stack_vars_data *data)\n {\n   size_t si, i, j, n = stack_vars_num;\n   poly_uint64 large_size = 0, large_alloc = 0;\n   rtx large_base = NULL;\n+  rtx large_untagged_base = NULL;\n   unsigned large_align = 0;\n   bool large_allocation_done = false;\n   tree decl;\n@@ -1113,7 +1129,7 @@ expand_stack_vars (bool (*pred) (size_t), class stack_vars_data *data)\n     {\n       rtx base;\n       unsigned base_align, alignb;\n-      poly_int64 offset;\n+      poly_int64 offset = 0;\n \n       i = stack_vars_sorted[si];\n \n@@ -1134,10 +1150,33 @@ expand_stack_vars (bool (*pred) (size_t), class stack_vars_data *data)\n       if (pred && !pred (i))\n \tcontinue;\n \n+      base = (hwasan_sanitize_stack_p ()\n+\t      ? hwasan_frame_base ()\n+\t      : virtual_stack_vars_rtx);\n       alignb = stack_vars[i].alignb;\n       if (alignb * BITS_PER_UNIT <= MAX_SUPPORTED_STACK_ALIGNMENT)\n \t{\n-\t  base = virtual_stack_vars_rtx;\n+\t  poly_int64 hwasan_orig_offset;\n+\t  if (hwasan_sanitize_stack_p ())\n+\t    {\n+\t      /* There must be no tag granule \"shared\" between different\n+\t\t objects.  This means that no HWASAN_TAG_GRANULE_SIZE byte\n+\t\t chunk can have more than one object in it.\n+\n+\t\t We ensure this by forcing the end of the last bit of data to\n+\t\t be aligned to HWASAN_TAG_GRANULE_SIZE bytes here, and setting\n+\t\t the start of each variable to be aligned to\n+\t\t HWASAN_TAG_GRANULE_SIZE bytes in `align_local_variable`.\n+\n+\t\t We can't align just one of the start or end, since there are\n+\t\t untagged things stored on the stack which we do not align to\n+\t\t HWASAN_TAG_GRANULE_SIZE bytes.  If we only aligned the start\n+\t\t or the end of tagged objects then untagged objects could end\n+\t\t up sharing the first granule of a tagged object or sharing the\n+\t\t last granule of a tagged object respectively.  */\n+\t      hwasan_orig_offset = align_frame_offset (HWASAN_TAG_GRANULE_SIZE);\n+\t      gcc_assert (stack_vars[i].alignb >= HWASAN_TAG_GRANULE_SIZE);\n+\t    }\n \t  /* ASAN description strings don't yet have a syntax for expressing\n \t     polynomial offsets.  */\n \t  HOST_WIDE_INT prev_offset;\n@@ -1148,7 +1187,7 @@ expand_stack_vars (bool (*pred) (size_t), class stack_vars_data *data)\n \t    {\n \t      if (data->asan_vec.is_empty ())\n \t\t{\n-\t\t  alloc_stack_frame_space (0, ASAN_RED_ZONE_SIZE);\n+\t\t  align_frame_offset (ASAN_RED_ZONE_SIZE);\n \t\t  prev_offset = frame_offset.to_constant ();\n \t\t}\n \t      prev_offset = align_base (prev_offset,\n@@ -1216,6 +1255,24 @@ expand_stack_vars (bool (*pred) (size_t), class stack_vars_data *data)\n \t    {\n \t      offset = alloc_stack_frame_space (stack_vars[i].size, alignb);\n \t      base_align = crtl->max_used_stack_slot_alignment;\n+\n+\t      if (hwasan_sanitize_stack_p ())\n+\t\t{\n+\t\t  /* Align again since the point of this alignment is to handle\n+\t\t     the \"end\" of the object (i.e. smallest address after the\n+\t\t     stack object).  For FRAME_GROWS_DOWNWARD that requires\n+\t\t     aligning the stack before allocating, but for a frame that\n+\t\t     grows upwards that requires aligning the stack after\n+\t\t     allocation.\n+\n+\t\t     Use `frame_offset` to record the offset value rather than\n+\t\t     `offset` since the `frame_offset` describes the extent\n+\t\t     allocated for this particular variable while `offset`\n+\t\t     describes the address that this variable starts at.  */\n+\t\t  align_frame_offset (HWASAN_TAG_GRANULE_SIZE);\n+\t\t  hwasan_record_stack_var (virtual_stack_vars_rtx, base,\n+\t\t\t\t\t   hwasan_orig_offset, frame_offset);\n+\t\t}\n \t    }\n \t}\n       else\n@@ -1236,14 +1293,33 @@ expand_stack_vars (bool (*pred) (size_t), class stack_vars_data *data)\n \t      loffset = alloc_stack_frame_space\n \t\t(rtx_to_poly_int64 (large_allocsize),\n \t\t PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT);\n-\t      large_base = get_dynamic_stack_base (loffset, large_align);\n+\t      large_base = get_dynamic_stack_base (loffset, large_align, base);\n \t      large_allocation_done = true;\n \t    }\n-\t  gcc_assert (large_base != NULL);\n \n+\t  gcc_assert (large_base != NULL);\n \t  large_alloc = aligned_upper_bound (large_alloc, alignb);\n \t  offset = large_alloc;\n \t  large_alloc += stack_vars[i].size;\n+\t  if (hwasan_sanitize_stack_p ())\n+\t    {\n+\t      /* An object with a large alignment requirement means that the\n+\t\t alignment requirement is greater than the required alignment\n+\t\t for tags.  */\n+\t      if (!large_untagged_base)\n+\t\tlarge_untagged_base\n+\t\t  = targetm.memtag.untagged_pointer (large_base, NULL_RTX);\n+\t      /* Ensure the end of the variable is also aligned correctly.  */\n+\t      poly_int64 align_again\n+\t\t= aligned_upper_bound (large_alloc, HWASAN_TAG_GRANULE_SIZE);\n+\t      /* For large allocations we always allocate a chunk of space\n+\t\t (which is addressed by large_untagged_base/large_base) and\n+\t\t then use positive offsets from that.  Hence the farthest\n+\t\t offset is `align_again` and the nearest offset from the base\n+\t\t is `offset`.  */\n+\t      hwasan_record_stack_var (large_untagged_base, large_base,\n+\t\t\t\t       offset, align_again);\n+\t    }\n \n \t  base = large_base;\n \t  base_align = large_align;\n@@ -1254,9 +1330,10 @@ expand_stack_vars (bool (*pred) (size_t), class stack_vars_data *data)\n       for (j = i; j != EOC; j = stack_vars[j].next)\n \t{\n \t  expand_one_stack_var_at (stack_vars[j].decl,\n-\t\t\t\t   base, base_align,\n-\t\t\t\t   offset);\n+\t\t\t\t   base, base_align, offset);\n \t}\n+      if (hwasan_sanitize_stack_p ())\n+\thwasan_increment_frame_tag ();\n     }\n \n   gcc_assert (known_eq (large_alloc, large_size));\n@@ -1347,10 +1424,37 @@ expand_one_stack_var_1 (tree var)\n   /* We handle highly aligned variables in expand_stack_vars.  */\n   gcc_assert (byte_align * BITS_PER_UNIT <= MAX_SUPPORTED_STACK_ALIGNMENT);\n \n-  offset = alloc_stack_frame_space (size, byte_align);\n+  rtx base;\n+  if (hwasan_sanitize_stack_p ())\n+    {\n+      /* Allocate zero bytes to align the stack.  */\n+      poly_int64 hwasan_orig_offset\n+\t= align_frame_offset (HWASAN_TAG_GRANULE_SIZE);\n+      offset = alloc_stack_frame_space (size, byte_align);\n+      align_frame_offset (HWASAN_TAG_GRANULE_SIZE);\n+      base = hwasan_frame_base ();\n+      /* Use `frame_offset` to automatically account for machines where the\n+\t frame grows upwards.\n+\n+\t `offset` will always point to the \"start\" of the stack object, which\n+\t will be the smallest address, for ! FRAME_GROWS_DOWNWARD this is *not*\n+\t the \"furthest\" offset from the base delimiting the current stack\n+\t object.  `frame_offset` will always delimit the extent that the frame.\n+\t */\n+      hwasan_record_stack_var (virtual_stack_vars_rtx, base,\n+\t\t\t       hwasan_orig_offset, frame_offset);\n+    }\n+  else\n+    {\n+      offset = alloc_stack_frame_space (size, byte_align);\n+      base = virtual_stack_vars_rtx;\n+    }\n \n-  expand_one_stack_var_at (var, virtual_stack_vars_rtx,\n+  expand_one_stack_var_at (var, base,\n \t\t\t   crtl->max_used_stack_slot_alignment, offset);\n+\n+  if (hwasan_sanitize_stack_p ())\n+    hwasan_increment_frame_tag ();\n }\n \n /* Wrapper for expand_one_stack_var_1 that checks SSA_NAMEs are\n@@ -1950,6 +2054,8 @@ init_vars_expansion (void)\n   /* Initialize local stack smashing state.  */\n   has_protected_decls = false;\n   has_short_buffer = false;\n+  if (hwasan_sanitize_stack_p ())\n+    hwasan_record_frame_init ();\n }\n \n /* Free up stack variable graph data.  */\n@@ -2277,10 +2383,26 @@ expand_used_vars (void)\n       expand_stack_vars (NULL, &data);\n     }\n \n+  if (hwasan_sanitize_stack_p ())\n+    hwasan_emit_prologue ();\n   if (asan_sanitize_allocas_p () && cfun->calls_alloca)\n     var_end_seq = asan_emit_allocas_unpoison (virtual_stack_dynamic_rtx,\n \t\t\t\t\t      virtual_stack_vars_rtx,\n \t\t\t\t\t      var_end_seq);\n+  else if (hwasan_sanitize_allocas_p () && cfun->calls_alloca)\n+    /* When using out-of-line instrumentation we only want to emit one function\n+       call for clearing the tags in a region of shadow stack.  When there are\n+       alloca calls in this frame we want to emit a call using the\n+       virtual_stack_dynamic_rtx, but when not we use the hwasan_frame_extent\n+       rtx we created in expand_stack_vars.  */\n+    var_end_seq = hwasan_emit_untag_frame (virtual_stack_dynamic_rtx,\n+\t\t\t\t\t   virtual_stack_vars_rtx);\n+  else if (hwasan_sanitize_stack_p ())\n+    /* If no variables were stored on the stack, `hwasan_get_frame_extent`\n+       will return NULL_RTX and hence `hwasan_emit_untag_frame` will return\n+       NULL (i.e. an empty sequence).  */\n+    var_end_seq = hwasan_emit_untag_frame (hwasan_get_frame_extent (),\n+\t\t\t\t\t   virtual_stack_vars_rtx);\n \n   fini_vars_expansion ();\n \n@@ -6641,6 +6763,9 @@ pass_expand::execute (function *fun)\n       emit_insn_after (var_ret_seq, after);\n     }\n \n+  if (hwasan_sanitize_stack_p ())\n+    hwasan_maybe_emit_frame_base_init ();\n+\n   /* Zap the tree EH table.  */\n   set_eh_throw_stmt_table (fun, NULL);\n "}, {"sha": "d9502c2c607d44dd376a109a513b8c923e1027dc", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0854b584bdc2862b49f029095e58beca797cf449/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0854b584bdc2862b49f029095e58beca797cf449/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=0854b584bdc2862b49f029095e58beca797cf449", "patch": "@@ -12231,3 +12231,60 @@ work.\n At preset, this feature does not support address spaces.  It also requires\n @code{Pmode} to be the same as @code{ptr_mode}.\n @end deftypefn\n+\n+@deftypefn {Target Hook} uint8_t TARGET_MEMTAG_TAG_SIZE ()\n+Return the size of a tag (in bits) for this platform.\n+\n+The default returns 8.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} uint8_t TARGET_MEMTAG_GRANULE_SIZE ()\n+Return the size in real memory that each byte in shadow memory refers to.\n+I.e. if a variable is @var{X} bytes long in memory, then this hook should\n+return the value @var{Y} such that the tag in shadow memory spans\n+@var{X}/@var{Y} bytes.\n+\n+Most variables will need to be aligned to this amount since two variables\n+that are neighbors in memory and share a tag granule would need to share\n+the same tag.\n+\n+The default returns 16.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} rtx TARGET_MEMTAG_INSERT_RANDOM_TAG (rtx @var{untagged}, rtx @var{target})\n+Return an RTX representing the value of @var{untagged} but with a\n+(possibly) random tag in it.\n+Put that value into @var{target} if it is convenient to do so.\n+This function is used to generate a tagged base for the current stack frame.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} rtx TARGET_MEMTAG_ADD_TAG (rtx @var{base}, poly_int64 @var{addr_offset}, uint8_t @var{tag_offset})\n+Return an RTX that represents the result of adding @var{addr_offset} to\n+the address in pointer @var{base} and @var{tag_offset} to the tag in pointer\n+@var{base}.\n+The resulting RTX must either be a valid memory address or be able to get\n+put into an operand with @code{force_operand}.\n+\n+Unlike other memtag hooks, this must return an expression and not emit any\n+RTL.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} rtx TARGET_MEMTAG_SET_TAG (rtx @var{untagged_base}, rtx @var{tag}, rtx @var{target})\n+Return an RTX representing @var{untagged_base} but with the tag @var{tag}.\n+Try and store this in @var{target} if convenient.\n+@var{untagged_base} is required to have a zero tag when this hook is called.\n+The default of this hook is to set the top byte of @var{untagged_base} to\n+@var{tag}.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} rtx TARGET_MEMTAG_EXTRACT_TAG (rtx @var{tagged_pointer}, rtx @var{target})\n+Return an RTX representing the tag stored in @var{tagged_pointer}.\n+Store the result in @var{target} if it is convenient.\n+The default represents the top byte of the original pointer.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} rtx TARGET_MEMTAG_UNTAGGED_POINTER (rtx @var{tagged_pointer}, rtx @var{target})\n+Return an RTX representing @var{tagged_pointer} with its tag set to zero.\n+Store the result in @var{target} if convenient.\n+The default clears the top byte of the original pointer.\n+@end deftypefn"}, {"sha": "b08923c8f28455fe77e061625e78ed1bf538e792", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0854b584bdc2862b49f029095e58beca797cf449/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0854b584bdc2862b49f029095e58beca797cf449/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=0854b584bdc2862b49f029095e58beca797cf449", "patch": "@@ -8186,3 +8186,17 @@ maintainer is familiar with.\n @hook TARGET_RUN_TARGET_SELFTESTS\n \n @hook TARGET_MEMTAG_CAN_TAG_ADDRESSES\n+\n+@hook TARGET_MEMTAG_TAG_SIZE\n+\n+@hook TARGET_MEMTAG_GRANULE_SIZE\n+\n+@hook TARGET_MEMTAG_INSERT_RANDOM_TAG\n+\n+@hook TARGET_MEMTAG_ADD_TAG\n+\n+@hook TARGET_MEMTAG_SET_TAG\n+\n+@hook TARGET_MEMTAG_EXTRACT_TAG\n+\n+@hook TARGET_MEMTAG_UNTAGGED_POINTER"}, {"sha": "41c3f6ace49c0e55c080e10b917842b1b21d49eb", "filename": "gcc/explow.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0854b584bdc2862b49f029095e58beca797cf449/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0854b584bdc2862b49f029095e58beca797cf449/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=0854b584bdc2862b49f029095e58beca797cf449", "patch": "@@ -1583,18 +1583,22 @@ allocate_dynamic_stack_space (rtx size, unsigned size_align,\n    OFFSET is the offset of the area into the virtual stack vars area.\n \n    REQUIRED_ALIGN is the alignment (in bits) required for the region\n-   of memory.  */\n+   of memory.\n+\n+   BASE is the rtx of the base of this virtual stack vars area.\n+   The only time this is not `virtual_stack_vars_rtx` is when tagging pointers\n+   on the stack.  */\n \n rtx\n-get_dynamic_stack_base (poly_int64 offset, unsigned required_align)\n+get_dynamic_stack_base (poly_int64 offset, unsigned required_align, rtx base)\n {\n   rtx target;\n \n   if (crtl->preferred_stack_boundary < PREFERRED_STACK_BOUNDARY)\n     crtl->preferred_stack_boundary = PREFERRED_STACK_BOUNDARY;\n \n   target = gen_reg_rtx (Pmode);\n-  emit_move_insn (target, virtual_stack_vars_rtx);\n+  emit_move_insn (target, base);\n   target = expand_binop (Pmode, add_optab, target,\n \t\t\t gen_int_mode (offset, Pmode),\n \t\t\t NULL_RTX, 1, OPTAB_LIB_WIDEN);"}, {"sha": "581831cb19fdf9e8fd969bb30139e1358279a34d", "filename": "gcc/explow.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0854b584bdc2862b49f029095e58beca797cf449/gcc%2Fexplow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0854b584bdc2862b49f029095e58beca797cf449/gcc%2Fexplow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.h?ref=0854b584bdc2862b49f029095e58beca797cf449", "patch": "@@ -106,7 +106,7 @@ extern rtx allocate_dynamic_stack_space (rtx, unsigned, unsigned,\n extern void get_dynamic_stack_size (rtx *, unsigned, unsigned, HOST_WIDE_INT *);\n \n /* Returns the address of the dynamic stack space without allocating it.  */\n-extern rtx get_dynamic_stack_base (poly_int64, unsigned);\n+extern rtx get_dynamic_stack_base (poly_int64, unsigned, rtx);\n \n /* Return an rtx doing runtime alignment to REQUIRED_ALIGN on TARGET.  */\n extern rtx align_dynamic_address (rtx, unsigned);"}, {"sha": "4f854fb994229fd4ed91d3b5cff7c7acff9a55bc", "filename": "gcc/sanitizer.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0854b584bdc2862b49f029095e58beca797cf449/gcc%2Fsanitizer.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0854b584bdc2862b49f029095e58beca797cf449/gcc%2Fsanitizer.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsanitizer.def?ref=0854b584bdc2862b49f029095e58beca797cf449", "patch": "@@ -180,6 +180,12 @@ DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_POINTER_COMPARE, \"__sanitizer_ptr_cmp\",\n DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_POINTER_SUBTRACT, \"__sanitizer_ptr_sub\",\n \t\t      BT_FN_VOID_PTR_PTRMODE, ATTR_NOTHROW_LEAF_LIST)\n \n+/* Hardware Address Sanitizer.  */\n+DEF_SANITIZER_BUILTIN(BUILT_IN_HWASAN_INIT, \"__hwasan_init\",\n+\t\t      BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_HWASAN_TAG_MEM, \"__hwasan_tag_memory\",\n+\t\t      BT_FN_VOID_PTR_UINT8_PTRMODE, ATTR_NOTHROW_LIST)\n+\n /* Thread Sanitizer */\n DEF_SANITIZER_BUILTIN(BUILT_IN_TSAN_INIT, \"__tsan_init\", \n \t\t      BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)"}, {"sha": "14f06b6d4f91938da484a2374b625ba0cb421529", "filename": "gcc/target.def", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0854b584bdc2862b49f029095e58beca797cf449/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0854b584bdc2862b49f029095e58beca797cf449/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=0854b584bdc2862b49f029095e58beca797cf449", "patch": "@@ -6876,6 +6876,71 @@ At preset, this feature does not support address spaces.  It also requires\\n\\\n @code{Pmode} to be the same as @code{ptr_mode}.\",\n  bool, (), default_memtag_can_tag_addresses)\n \n+DEFHOOK\n+(tag_size,\n+ \"Return the size of a tag (in bits) for this platform.\\n\\\n+\\n\\\n+The default returns 8.\",\n+  uint8_t, (), default_memtag_tag_size)\n+\n+DEFHOOK\n+(granule_size,\n+ \"Return the size in real memory that each byte in shadow memory refers to.\\n\\\n+I.e. if a variable is @var{X} bytes long in memory, then this hook should\\n\\\n+return the value @var{Y} such that the tag in shadow memory spans\\n\\\n+@var{X}/@var{Y} bytes.\\n\\\n+\\n\\\n+Most variables will need to be aligned to this amount since two variables\\n\\\n+that are neighbors in memory and share a tag granule would need to share\\n\\\n+the same tag.\\n\\\n+\\n\\\n+The default returns 16.\",\n+  uint8_t, (), default_memtag_granule_size)\n+\n+DEFHOOK\n+(insert_random_tag,\n+ \"Return an RTX representing the value of @var{untagged} but with a\\n\\\n+(possibly) random tag in it.\\n\\\n+Put that value into @var{target} if it is convenient to do so.\\n\\\n+This function is used to generate a tagged base for the current stack frame.\",\n+  rtx, (rtx untagged, rtx target), default_memtag_insert_random_tag)\n+\n+DEFHOOK\n+(add_tag,\n+ \"Return an RTX that represents the result of adding @var{addr_offset} to\\n\\\n+the address in pointer @var{base} and @var{tag_offset} to the tag in pointer\\n\\\n+@var{base}.\\n\\\n+The resulting RTX must either be a valid memory address or be able to get\\n\\\n+put into an operand with @code{force_operand}.\\n\\\n+\\n\\\n+Unlike other memtag hooks, this must return an expression and not emit any\\n\\\n+RTL.\",\n+  rtx, (rtx base, poly_int64 addr_offset, uint8_t tag_offset),\n+  default_memtag_add_tag)\n+\n+DEFHOOK\n+(set_tag,\n+ \"Return an RTX representing @var{untagged_base} but with the tag @var{tag}.\\n\\\n+Try and store this in @var{target} if convenient.\\n\\\n+@var{untagged_base} is required to have a zero tag when this hook is called.\\n\\\n+The default of this hook is to set the top byte of @var{untagged_base} to\\n\\\n+@var{tag}.\",\n+  rtx, (rtx untagged_base, rtx tag, rtx target), default_memtag_set_tag)\n+\n+DEFHOOK\n+(extract_tag,\n+ \"Return an RTX representing the tag stored in @var{tagged_pointer}.\\n\\\n+Store the result in @var{target} if it is convenient.\\n\\\n+The default represents the top byte of the original pointer.\",\n+  rtx, (rtx tagged_pointer, rtx target), default_memtag_extract_tag)\n+\n+DEFHOOK\n+(untagged_pointer,\n+ \"Return an RTX representing @var{tagged_pointer} with its tag set to zero.\\n\\\n+Store the result in @var{target} if convenient.\\n\\\n+The default clears the top byte of the original pointer.\",\n+  rtx, (rtx tagged_pointer, rtx target), default_memtag_untagged_pointer)\n+\n HOOK_VECTOR_END (memtag)\n #undef HOOK_PREFIX\n #define HOOK_PREFIX \"TARGET_\""}, {"sha": "e634df3f6c6837e422246a7736c0de4471ce1e77", "filename": "gcc/targhooks.c", "status": "modified", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0854b584bdc2862b49f029095e58beca797cf449/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0854b584bdc2862b49f029095e58beca797cf449/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=0854b584bdc2862b49f029095e58beca797cf449", "patch": "@@ -73,6 +73,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"varasm.h\"\n #include \"flags.h\"\n #include \"explow.h\"\n+#include \"expmed.h\"\n #include \"calls.h\"\n #include \"expr.h\"\n #include \"output.h\"\n@@ -86,6 +87,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"langhooks.h\"\n #include \"sbitmap.h\"\n #include \"function-abi.h\"\n+#include \"attribs.h\"\n+#include \"asan.h\"\n+#include \"emit-rtl.h\"\n \n bool\n default_legitimate_address_p (machine_mode mode ATTRIBUTE_UNUSED,\n@@ -2415,10 +2419,115 @@ default_speculation_safe_value (machine_mode mode ATTRIBUTE_UNUSED,\n   return result;\n }\n \n+/* How many bits to shift in order to access the tag bits.\n+   The default is to store the tag in the top 8 bits of a 64 bit pointer, hence\n+   shifting 56 bits will leave just the tag.  */\n+#define HWASAN_SHIFT (GET_MODE_PRECISION (Pmode) - 8)\n+#define HWASAN_SHIFT_RTX GEN_INT (HWASAN_SHIFT)\n+\n bool\n default_memtag_can_tag_addresses ()\n {\n   return false;\n }\n \n+uint8_t\n+default_memtag_tag_size ()\n+{\n+  return 8;\n+}\n+\n+uint8_t\n+default_memtag_granule_size ()\n+{\n+  return 16;\n+}\n+\n+/* The default implementation of TARGET_MEMTAG_INSERT_RANDOM_TAG.  */\n+rtx\n+default_memtag_insert_random_tag (rtx untagged, rtx target)\n+{\n+  gcc_assert (param_hwasan_instrument_stack);\n+  if (param_hwasan_random_frame_tag)\n+    {\n+      rtx fn = init_one_libfunc (\"__hwasan_generate_tag\");\n+      rtx new_tag = emit_library_call_value (fn, NULL_RTX, LCT_NORMAL, QImode);\n+      return targetm.memtag.set_tag (untagged, new_tag, target);\n+    }\n+  else\n+    {\n+      /* NOTE: The kernel API does not have __hwasan_generate_tag exposed.\n+\t In the future we may add the option emit random tags with inline\n+\t instrumentation instead of function calls.  This would be the same\n+\t between the kernel and userland.  */\n+      return untagged;\n+    }\n+}\n+\n+/* The default implementation of TARGET_MEMTAG_ADD_TAG.  */\n+rtx\n+default_memtag_add_tag (rtx base, poly_int64 offset, uint8_t tag_offset)\n+{\n+  /* Need to look into what the most efficient code sequence is.\n+     This is a code sequence that would be emitted *many* times, so we\n+     want it as small as possible.\n+\n+     There are two places where tag overflow is a question:\n+       - Tagging the shadow stack.\n+\t  (both tagging and untagging).\n+       - Tagging addressable pointers.\n+\n+     We need to ensure both behaviors are the same (i.e. that the tag that\n+     ends up in a pointer after \"overflowing\" the tag bits with a tag addition\n+     is the same that ends up in the shadow space).\n+\n+     The aim is that the behavior of tag addition should follow modulo\n+     wrapping in both instances.\n+\n+     The libhwasan code doesn't have any path that increments a pointer's tag,\n+     which means it has no opinion on what happens when a tag increment\n+     overflows (and hence we can choose our own behavior).  */\n+\n+  offset += ((uint64_t)tag_offset << HWASAN_SHIFT);\n+  return plus_constant (Pmode, base, offset);\n+}\n+\n+/* The default implementation of TARGET_MEMTAG_SET_TAG.  */\n+rtx\n+default_memtag_set_tag (rtx untagged, rtx tag, rtx target)\n+{\n+  gcc_assert (GET_MODE (untagged) == Pmode && GET_MODE (tag) == QImode);\n+  tag = expand_simple_binop (Pmode, ASHIFT, tag, HWASAN_SHIFT_RTX, NULL_RTX,\n+\t\t\t     /* unsignedp = */1, OPTAB_WIDEN);\n+  rtx ret = expand_simple_binop (Pmode, IOR, untagged, tag, target,\n+\t\t\t\t /* unsignedp = */1, OPTAB_DIRECT);\n+  gcc_assert (ret);\n+  return ret;\n+}\n+\n+/* The default implementation of TARGET_MEMTAG_EXTRACT_TAG.  */\n+rtx\n+default_memtag_extract_tag (rtx tagged_pointer, rtx target)\n+{\n+  rtx tag = expand_simple_binop (Pmode, LSHIFTRT, tagged_pointer,\n+\t\t\t\t HWASAN_SHIFT_RTX, target,\n+\t\t\t\t /* unsignedp = */0,\n+\t\t\t\t OPTAB_DIRECT);\n+  rtx ret = gen_lowpart (QImode, tag);\n+  gcc_assert (ret);\n+  return ret;\n+}\n+\n+/* The default implementation of TARGET_MEMTAG_UNTAGGED_POINTER.  */\n+rtx\n+default_memtag_untagged_pointer (rtx tagged_pointer, rtx target)\n+{\n+  rtx tag_mask = gen_int_mode ((HOST_WIDE_INT_1U << HWASAN_SHIFT) - 1, Pmode);\n+  rtx untagged_base = expand_simple_binop (Pmode, AND, tagged_pointer,\n+\t\t\t\t\t   tag_mask, target, true,\n+\t\t\t\t\t   OPTAB_DIRECT);\n+  gcc_assert (untagged_base);\n+  return untagged_base;\n+}\n+\n #include \"gt-targhooks.h\""}, {"sha": "68e8688a32f18481ee61f06879aacff20163105b", "filename": "gcc/targhooks.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0854b584bdc2862b49f029095e58beca797cf449/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0854b584bdc2862b49f029095e58beca797cf449/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=0854b584bdc2862b49f029095e58beca797cf449", "patch": "@@ -287,4 +287,12 @@ extern bool speculation_safe_value_not_needed (bool);\n extern rtx default_speculation_safe_value (machine_mode, rtx, rtx, rtx);\n \n extern bool default_memtag_can_tag_addresses ();\n+extern uint8_t default_memtag_tag_size ();\n+extern uint8_t default_memtag_granule_size ();\n+extern rtx default_memtag_insert_random_tag (rtx, rtx);\n+extern rtx default_memtag_add_tag (rtx, poly_int64, uint8_t);\n+extern rtx default_memtag_set_tag (rtx, rtx, rtx);\n+extern rtx default_memtag_extract_tag (rtx, rtx);\n+extern rtx default_memtag_untagged_pointer (rtx, rtx);\n+\n #endif /* GCC_TARGHOOKS_H */"}, {"sha": "9938b6afbd4fa22898dbc3c29b92061a71810b08", "filename": "gcc/toplev.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0854b584bdc2862b49f029095e58beca797cf449/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0854b584bdc2862b49f029095e58beca797cf449/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=0854b584bdc2862b49f029095e58beca797cf449", "patch": "@@ -512,6 +512,9 @@ compile_file (void)\n       if (flag_sanitize & SANITIZE_THREAD)\n \ttsan_finish_file ();\n \n+      if (flag_sanitize & SANITIZE_HWADDRESS)\n+\thwasan_finish_file ();\n+\n       omp_finish_file ();\n \n       output_shared_constant_pool ();"}]}