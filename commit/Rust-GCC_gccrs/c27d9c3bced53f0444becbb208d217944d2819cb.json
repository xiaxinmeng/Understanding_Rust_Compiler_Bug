{"sha": "c27d9c3bced53f0444becbb208d217944d2819cb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzI3ZDljM2JjZWQ1M2YwNDQ0YmVjYmIyMDhkMjE3OTQ0ZDI4MTljYg==", "commit": {"author": {"name": "Stan Cox", "email": "coxs@gnu.org", "date": "1997-07-31T20:37:46Z"}, "committer": {"name": "Stan Cox", "email": "coxs@gnu.org", "date": "1997-07-31T20:37:46Z"}, "message": "(output_to_reg, output_fix_trunc): Use scratch memory\n\nFrom-SVN: r14568", "tree": {"sha": "95b64ee1bd43209d1214c1db7bbfb874431c22cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95b64ee1bd43209d1214c1db7bbfb874431c22cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c27d9c3bced53f0444becbb208d217944d2819cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c27d9c3bced53f0444becbb208d217944d2819cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c27d9c3bced53f0444becbb208d217944d2819cb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c27d9c3bced53f0444becbb208d217944d2819cb/comments", "author": null, "committer": null, "parents": [{"sha": "4bc679adb2ec5b8eed6e48ade29f6dcb86af25ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bc679adb2ec5b8eed6e48ade29f6dcb86af25ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bc679adb2ec5b8eed6e48ade29f6dcb86af25ff"}], "stats": {"total": 75, "additions": 51, "deletions": 24}, "files": [{"sha": "129727f9ea0e7c4a2b9e8d0951b5c5c48cd9d59a", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 51, "deletions": 24, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c27d9c3bced53f0444becbb208d217944d2819cb/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c27d9c3bced53f0444becbb208d217944d2819cb/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=c27d9c3bced53f0444becbb208d217944d2819cb", "patch": "@@ -827,19 +827,24 @@ output_op_from_reg (src, template)\n    otherwise a `fst' float store is done. */\n \n void\n-output_to_reg (dest, dies)\n+output_to_reg (dest, dies, scratch_mem)\n      rtx dest;\n      int dies;\n+     rtx scratch_mem;\n {\n   rtx xops[4];\n   int size = GET_MODE_SIZE (GET_MODE (dest));\n \n-  xops[0] = AT_SP (Pmode);\n+  if (! scratch_mem)\n+    xops[0] = AT_SP (Pmode);\n+  else\n+    xops[0] = scratch_mem;\n   xops[1] = stack_pointer_rtx;\n   xops[2] = GEN_INT (size);\n   xops[3] = dest;\n \n-  output_asm_insn (AS2 (sub%L1,%2,%1), xops);\n+  if (! scratch_mem)\n+    output_asm_insn (AS2 (sub%L1,%2,%1), xops);\n \n   if (GET_MODE_CLASS (GET_MODE (dest)) == MODE_INT)\n     {\n@@ -866,16 +871,33 @@ output_to_reg (dest, dies)\n   else\n     abort ();\n \n-  output_asm_insn (AS1 (pop%L0,%0), &dest);\n+  if (! scratch_mem)\n+    output_asm_insn (AS1 (pop%L0,%0), &dest);\n+  else\n+    output_asm_insn (AS2 (mov%L0,%0,%3), xops);\n+\n \n   if (size > UNITS_PER_WORD)\n     {\n       dest = gen_rtx (REG, SImode, REGNO (dest) + 1);\n-      output_asm_insn (AS1 (pop%L0,%0), &dest);\n+      if (! scratch_mem)\n+\toutput_asm_insn (AS1 (pop%L0,%0), &dest);\n+      else\n+\t{\n+\t  xops[0] = adj_offsettable_operand (xops[0], 4);\t      \n+\t  xops[3] = dest;\n+\t  output_asm_insn (AS2 (mov%L0,%0,%3), xops);\n+\t}\n       if (size > 2 * UNITS_PER_WORD)\n \t{\n \t  dest = gen_rtx (REG, SImode, REGNO (dest) + 1);\n-\t  output_asm_insn (AS1 (pop%L0,%0), &dest);\n+\t  if (! scratch_mem)\n+\t    output_asm_insn (AS1 (pop%L0,%0), &dest);\n+\t  else\n+\t    {\n+\t      xops[0] = adj_offsettable_operand (xops[0], 4);\t      \n+\t      output_asm_insn (AS2 (mov%L0,%0,%3), xops);\n+\t    }\n \t}\n     }\n }\n@@ -2846,11 +2868,18 @@ output_pic_addr_const (file, x, code)\n /* Append the correct conditional move suffix which corresponds to CODE */\n \n static void\n-put_condition_code (code, mode, file)\n+put_condition_code (code, reverse_cc, mode, file)\n      enum rtx_code code;\n+     int  reverse_cc;\n      enum mode_class mode;\n      FILE * file;\n {\n+  int ieee;\n+  ieee = (TARGET_IEEE_FP && (cc_prev_status.flags & CC_IN_80387)\n+\t  && ! (cc_prev_status.flags & CC_FCOMI));\n+  if (reverse_cc && ! ieee)\n+    code = reverse_condition (code);\n+\n   if (mode == MODE_INT)\n   switch (code)\n     {\n@@ -2888,25 +2917,25 @@ put_condition_code (code, mode, file)\n   switch (code)\n     {\n       case NE: \n-          fputs (\"ne\", file); return;\n+          fputs (ieee ? (reverse_cc ? \"ne\" : \"e\") : \"ne\", file); return;\n       case EQ: \n-\t  fputs (\"e\", file); return;\n+\t  fputs (ieee ? (reverse_cc ? \"ne\" : \"e\") : \"e\", file); return;\n       case GE: \n-\t  fputs (\"nb\", file); return;\n+\t  fputs (ieee ? (reverse_cc ? \"ne\" : \"e\") : \"nb\", file); return;\n       case GT: \n-\t  fputs (\"nbe\", file); return;\n+\t  fputs (ieee ? (reverse_cc ? \"ne\" : \"e\") : \"nbe\", file); return;\n       case LE: \n-\t  fputs (\"be\", file); return;\n+\t  fputs (ieee ? (reverse_cc ? \"nb\" : \"b\") : \"be\", file); return;\n       case LT: \n-\t  fputs (\"b\", file); return;\n+\t  fputs (ieee ? (reverse_cc ? \"ne\" : \"e\") : \"b\", file); return;\n       case GEU: \n-\t  fputs (\"nb\", file); return;\n+\t  fputs (ieee ? (reverse_cc ? \"ne\" : \"e\") : \"nb\", file); return;\n       case GTU: \n-\t  fputs (\"nbe\", file); return;\n+\t  fputs (ieee ? (reverse_cc ? \"ne\" : \"e\") : \"nbe\", file); return;\n       case LEU: \n-\t  fputs (\"be\", file); return;\n+\t  fputs (ieee ? (reverse_cc ? \"nb\" : \"b\") : \"be\", file); return;\n       case LTU: \n-\t  fputs (\"b\", file); return;\n+\t  fputs (ieee ? (reverse_cc ? \"ne\" : \"e\") : \"b\", file); return;\n       default: output_operand_lossage (\"Invalid %%C operand\");\n     }\n }\n@@ -3058,22 +3087,20 @@ print_operand (file, x, code)\n \n \t  /* This is used by the conditional move instructions.  */\n \tcase 'C':\n-\t  put_condition_code (GET_CODE (x), MODE_INT, file);\n+\t  put_condition_code (GET_CODE (x), 0, MODE_INT, file);\n \t  return;\n \n \t  /* like above, but reverse condition */\n \tcase 'c':\n-\t  put_condition_code (reverse_condition (GET_CODE (x)), MODE_INT, file);\n-\t  return;\n+\t  put_condition_code (GET_CODE (x), 1, MODE_INT, file); return;\n \n \tcase 'F':\n-\t  put_condition_code (GET_CODE (x), MODE_FLOAT, file);\n+\t  put_condition_code (GET_CODE (x), 0, MODE_FLOAT, file);\n \t  return;\n \n \t  /* like above, but reverse condition */\n \tcase 'f':\n-\t  put_condition_code (reverse_condition (GET_CODE (x)),\n-\t\t\t      MODE_FLOAT, file);\n+\t  put_condition_code (GET_CODE (x), 1, MODE_FLOAT, file);\n \t  return;\n \n \tdefault:\n@@ -3684,7 +3711,7 @@ output_fix_trunc (insn, operands)\n   output_asm_insn (AS1 (fldc%W3,%3), operands);\n \n   if (NON_STACK_REG_P (operands[0]))\n-    output_to_reg (operands[0], stack_top_dies);\n+    output_to_reg (operands[0], stack_top_dies, operands[3]);\n   else if (GET_CODE (operands[0]) == MEM)\n     {\n       if (stack_top_dies)"}]}