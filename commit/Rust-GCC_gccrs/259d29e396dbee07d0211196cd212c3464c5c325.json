{"sha": "259d29e396dbee07d0211196cd212c3464c5c325", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjU5ZDI5ZTM5NmRiZWUwN2QwMjExMTk2Y2QyMTJjMzQ2NGM1YzMyNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-05-16T23:18:29Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-05-16T23:18:29Z"}, "message": "ipa-utils.h (warn_types_mismatch, [...]): Declare.\n\n\n\t* ipa-utils.h (warn_types_mismatch, odr_or_derived_type_p,\n\todr_types_equivalent_p): Declare.\n\t(odr_type_p): Use gcc_checking_assert.\n\t(type_in_anonymous_namespace_p) Declare.\n\t(type_with_linkage_p): Declare.\n\t* common.opt (Wlto-type-mismatch): New warning.\n\t* ipa-devirt.c (compound_type_base): New function.\n\t(odr_or_derived_type_p): New function.\n\t(odr_types_equivalent_p): New function.\n\t(add_type_duplicate): Simplify.\n\t(type_with_linkage_p): Add hack to prevent false positives on C types\n\t(type_in_anonymous_namespace_p): Likewise.\n\t* tree.c (need_assembler_name_p): Use type_with_linkage.\n\t* tree.h (type_in_anonymous_namespace_p): Remove.\n\t* doc/invoke.texi (-Wlto-type-mismatch): Document\n\n\t* lto-symtab.c (warn_type_compatibility_p): Break out from ...;\n\tcompare ODR types (if available) and function types.\n\t(lto_symtab_merge): ... here; output ODR violation warnings\n\tand call warn_types_mismatch.\n\n\t* gfortran.dg/lto/20091028-2_1.c: Fix return value.\n\t* gfortran.dg/lto/pr41576_1.f90: Add interface.\n\t* gfortran.dg/lto/pr41521_0.f90: Disable lto-type-mismatch\n\t* gfortran.dg/lto/pr60635_0.f90: Disable lto-type-mismatch.\n\t* gfortran.dg/lto/20091028-1_1.c: Fix return type.\n\t* gcc.dg/lto/20120723_0.c: Disbale lto-type-mismatch.\n\nFrom-SVN: r223258", "tree": {"sha": "50d7960821ec80bd6136c7a2e9106406f64e8633", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50d7960821ec80bd6136c7a2e9106406f64e8633"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/259d29e396dbee07d0211196cd212c3464c5c325", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/259d29e396dbee07d0211196cd212c3464c5c325", "html_url": "https://github.com/Rust-GCC/gccrs/commit/259d29e396dbee07d0211196cd212c3464c5c325", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/259d29e396dbee07d0211196cd212c3464c5c325/comments", "author": null, "committer": null, "parents": [{"sha": "4d259d334e0a55382654f511a64d43089eccf569", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d259d334e0a55382654f511a64d43089eccf569", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d259d334e0a55382654f511a64d43089eccf569"}], "stats": {"total": 347, "additions": 269, "deletions": 78}, "files": [{"sha": "562d34a05ae632c690f079ef2f6bc046345f6c09", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/259d29e396dbee07d0211196cd212c3464c5c325/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/259d29e396dbee07d0211196cd212c3464c5c325/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=259d29e396dbee07d0211196cd212c3464c5c325", "patch": "@@ -607,6 +607,10 @@ Woverflow\n Common Var(warn_overflow) Init(1) Warning\n Warn about overflow in arithmetic expressions\n \n+Wlto-type-mismatch\n+Common Var(warn_lto_type_mismatch) Init(1) Warning\n+During link time optimization warn about mismatched types of global declarations\n+\n Wpacked\n Common Var(warn_packed) Warning\n Warn when the packed attribute has no effect on struct layout"}, {"sha": "1e484232b2bb7bbf9a51b990242f48e9d61328c7", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/259d29e396dbee07d0211196cd212c3464c5c325/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/259d29e396dbee07d0211196cd212c3464c5c325/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=259d29e396dbee07d0211196cd212c3464c5c325", "patch": "@@ -2698,6 +2698,14 @@ In this case, @code{PRId64} is treated as a separate preprocessing token.\n \n This warning is enabled by default.\n \n+@item -Wlto-type-mismatch\n+@opindex Wlto-type-mismatch\n+@opindex Wno-lto-type-mistmach\n+\n+During the link-time optimization warn about type mismatches in between\n+global declarations from different compilation units.\n+Requires @option{-flto} to be enabled.  Enabled by default.\n+\n @item -Wnarrowing @r{(C++ and Objective-C++ only)}\n @opindex Wnarrowing\n @opindex Wno-narrowing"}, {"sha": "bf43859f47e7a22716567ad783c6c8a69ffe241c", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 100, "deletions": 13, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/259d29e396dbee07d0211196cd212c3464c5c325/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/259d29e396dbee07d0211196cd212c3464c5c325/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=259d29e396dbee07d0211196cd212c3464c5c325", "patch": "@@ -247,9 +247,14 @@ struct GTY(()) odr_type_d\n \n /* Return true if T is a type with linkage defined.  */\n \n-static bool\n+bool\n type_with_linkage_p (const_tree t)\n {\n+  /* Builtin types do not define linkage, their TYPE_CONTEXT is NULL.  */\n+  if (!TYPE_CONTEXT (t)\n+      || !TYPE_NAME (t) || TREE_CODE (TYPE_NAME (t)) != TYPE_DECL)\n+    return false;\n+\n   return (RECORD_OR_UNION_TYPE_P (t)\n \t  || TREE_CODE (t) == ENUMERAL_TYPE);\n }\n@@ -261,12 +266,21 @@ bool\n type_in_anonymous_namespace_p (const_tree t)\n {\n   gcc_assert (type_with_linkage_p (t));\n-  /* TREE_PUBLIC of TYPE_STUB_DECL may not be properly set for\n-     backend produced types (such as va_arg_type); those have CONTEXT NULL\n-     and never are considered anonymoius.  */\n-  if (!TYPE_CONTEXT (t))\n-    return false;\n-  return (TYPE_STUB_DECL (t) && !TREE_PUBLIC (TYPE_STUB_DECL (t)));\n+\n+  if (TYPE_STUB_DECL (t) && !TREE_PUBLIC (TYPE_STUB_DECL (t)))\n+    {\n+      tree ctx = DECL_CONTEXT (TYPE_NAME (t));\n+      while (ctx)\n+\t{\n+\t  if (TREE_CODE (ctx) == NAMESPACE_DECL)\n+\t    return !TREE_PUBLIC (ctx);\n+\t  if (TREE_CODE (ctx) == BLOCK)\n+\t    ctx = BLOCK_SUPERCONTEXT (ctx);\n+\t  else\n+\t    ctx = get_containing_scope (ctx);\n+\t}\n+    }\n+  return false;\n }\n \n /* Return true of T is type with One Definition Rule info attached. \n@@ -589,6 +603,59 @@ types_must_be_same_for_odr (tree t1, tree t2)\n     return TYPE_MAIN_VARIANT (t1) == TYPE_MAIN_VARIANT (t2);\n }\n \n+/* If T is compound type, return type it is based on.  */\n+\n+static tree\n+compound_type_base (const_tree t)\n+{\n+  if (TREE_CODE (t) == ARRAY_TYPE\n+      || POINTER_TYPE_P (t)\n+      || TREE_CODE (t) == COMPLEX_TYPE\n+      || VECTOR_TYPE_P (t))\n+    return TREE_TYPE (t);\n+  if (TREE_CODE (t) == METHOD_TYPE)\n+    return TYPE_METHOD_BASETYPE (t);\n+  if (TREE_CODE (t) == OFFSET_TYPE)\n+    return TYPE_OFFSET_BASETYPE (t);\n+  return NULL_TREE;\n+}\n+\n+/* Return true if T is either ODR type or compound type based from it.\n+   If the function return true, we know that T is a type originating from C++\n+   source even at link-time.  */\n+\n+bool\n+odr_or_derived_type_p (const_tree t)\n+{\n+  do\n+    {\n+      if (odr_type_p (t))\n+\treturn true;\n+      /* Function type is a tricky one. Basically we can consider it\n+\t ODR derived if return type or any of the parameters is.\n+\t We need to check all parameters because LTO streaming merges\n+\t common types (such as void) and they are not considered ODR then.  */\n+      if (TREE_CODE (t) == FUNCTION_TYPE)\n+\t{\n+\t  if (TYPE_METHOD_BASETYPE (t))\n+\t    t = TYPE_METHOD_BASETYPE (t);\n+\t  else\n+\t   {\n+\t     if (TREE_TYPE (t) && odr_or_derived_type_p (TREE_TYPE (t)))\n+\t       return true;\n+\t     for (t = TYPE_ARG_TYPES (t); t; t = TREE_CHAIN (t))\n+\t       if (odr_or_derived_type_p (TREE_VALUE (t)))\n+\t\t return true;\n+\t     return false;\n+\t   }\n+\t}\n+      else\n+\tt = compound_type_base (t);\n+    }\n+  while (t);\n+  return t;\n+}\n+\n /* Compare types T1 and T2 and return true if they are\n    equivalent.  */\n \n@@ -1223,6 +1290,16 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n       return false;\n     }\n \n+  if ((type_with_linkage_p (t1) && type_in_anonymous_namespace_p (t1))\n+      || (type_with_linkage_p (t2) && type_in_anonymous_namespace_p (t2)))\n+    {\n+      /* We can not trip this when comparing ODR types, only when trying to\n+\t match different ODR derivations from different declarations.\n+\t So WARN should be always false.  */\n+      gcc_assert (!warn);\n+      return false;\n+    }\n+\n   if (comp_type_attributes (t1, t2) != 1)\n     {\n       warn_odr (t1, t2, NULL, NULL, warn, warned,\n@@ -1625,6 +1702,20 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n   return true;\n }\n \n+/* Return true if TYPE1 and TYPE2 are equivalent for One Definition Rule.  */\n+\n+bool\n+odr_types_equivalent_p (tree type1, tree type2)\n+{\n+  hash_set<type_pair,pair_traits> visited;\n+\n+#ifdef ENABLE_CHECKING\n+  gcc_assert (odr_or_derived_type_p (type1) && odr_or_derived_type_p (type2));\n+#endif\n+  return odr_types_equivalent_p (type1, type2, false, NULL,\n+\t\t\t         &visited);\n+}\n+\n /* TYPE is equivalent to VAL by ODR, but its tree representation differs\n    from VAL->type.  This may happen in LTO where tree merging did not merge\n    all variants of the same type or due to ODR violation.\n@@ -1749,12 +1840,8 @@ add_type_duplicate (odr_type val, tree type)\n \t\t  base_mismatch = true;\n \t      }\n \t    else\n-\t      {\n-\t\thash_set<type_pair,pair_traits> visited;\n-\t\tif (!odr_types_equivalent_p (type1, type2, false, NULL,\n-\t\t\t\t\t     &visited))\n-\t\t  base_mismatch = true;\n-\t      }\n+\t      if (!odr_types_equivalent_p (type1, type2))\n+\t\tbase_mismatch = true;\n \t    if (base_mismatch)\n \t      {\n \t\tif (!warned && !val->odr_violated)"}, {"sha": "3378f6946f946206d3aaf203d6d6cb300718a1c2", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/259d29e396dbee07d0211196cd212c3464c5c325/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/259d29e396dbee07d0211196cd212c3464c5c325/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=259d29e396dbee07d0211196cd212c3464c5c325", "patch": "@@ -63,7 +63,9 @@ possible_polymorphic_call_targets (tree, HOST_WIDE_INT,\n \t\t\t\t   void **cache_token = NULL,\n \t\t\t\t   bool speuclative = false);\n odr_type get_odr_type (tree, bool insert = false);\n-bool odr_type_p (const_tree t);\n+bool type_in_anonymous_namespace_p (const_tree);\n+bool type_with_linkage_p (const_tree);\n+bool odr_type_p (const_tree);\n bool possible_polymorphic_call_target_p (tree ref, gimple stmt, struct cgraph_node *n);\n void dump_possible_polymorphic_call_targets (FILE *, tree, HOST_WIDE_INT,\n \t\t\t\t\t     const ipa_polymorphic_call_context &);\n@@ -85,6 +87,9 @@ bool types_must_be_same_for_odr (tree, tree);\n bool types_odr_comparable (tree, tree, bool strict = false);\n cgraph_node *try_speculative_devirtualization (tree, HOST_WIDE_INT,\n \t\t\t\t\t       ipa_polymorphic_call_context);\n+void warn_types_mismatch (tree t1, tree t2);\n+bool odr_or_derived_type_p (const_tree t);\n+bool odr_types_equivalent_p (tree type1, tree type2);\n \n /* Return vector containing possible targets of polymorphic call E.\n    If COMPLETEP is non-NULL, store true if the list is complete. "}, {"sha": "3725d1a25eba2e8d7eae876af00ff6775498024b", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/259d29e396dbee07d0211196cd212c3464c5c325/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/259d29e396dbee07d0211196cd212c3464c5c325/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=259d29e396dbee07d0211196cd212c3464c5c325", "patch": "@@ -1,3 +1,10 @@\n+2015-05-17  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* lto-symtab.c (warn_type_compatibility_p): Break out from ...;\n+\tcompare ODR types (if available) and function types.\n+\t(lto_symtab_merge): ... here; output ODR violation warnings\n+\tand call warn_types_mismatch.\n+\n 2015-04-29  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* lto.c (lto_fixup_state): Call verify_type."}, {"sha": "995c7c98c75ecebc4c31ea6b7a4171c7caf0ef14", "filename": "gcc/lto/lto-symtab.c", "status": "modified", "additions": 110, "deletions": 50, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/259d29e396dbee07d0211196cd212c3464c5c325/gcc%2Flto%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/259d29e396dbee07d0211196cd212c3464c5c325/gcc%2Flto%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-symtab.c?ref=259d29e396dbee07d0211196cd212c3464c5c325", "patch": "@@ -56,6 +56,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-prop.h\"\n #include \"ipa-inline.h\"\n #include \"builtins.h\"\n+#include \"print-tree.h\"\n \n /* Replace the cgraph node NODE with PREVAILING_NODE in the cgraph, merging\n    all edges and removing the old node.  */\n@@ -203,45 +204,49 @@ lto_varpool_replace_node (varpool_node *vnode,\n   vnode->remove ();\n }\n \n-/* Merge two variable or function symbol table entries PREVAILING and ENTRY.\n-   Return false if the symbols are not fully compatible and a diagnostic\n-   should be emitted.  */\n+/* Return non-zero if we want to output waring about T1 and T2.\n+   Return value is a bitmask of reasons of violation:\n+   Bit 0 indicates that types are not compatible of memory layout.\n+   Bot 1 indicates that types are not compatible because of C++ ODR rule.  */\n \n-static bool\n-lto_symtab_merge (symtab_node *prevailing, symtab_node *entry)\n+static int\n+warn_type_compatibility_p (tree prevailing_type, tree type)\n {\n-  tree prevailing_decl = prevailing->decl;\n-  tree decl = entry->decl;\n-  tree prevailing_type, type;\n-\n-  if (prevailing_decl == decl)\n-    return true;\n-\n-  /* Merge decl state in both directions, we may still end up using\n-     the new decl.  */\n-  TREE_ADDRESSABLE (prevailing_decl) |= TREE_ADDRESSABLE (decl);\n-  TREE_ADDRESSABLE (decl) |= TREE_ADDRESSABLE (prevailing_decl);\n-\n-  /* The linker may ask us to combine two incompatible symbols.\n-     Detect this case and notify the caller of required diagnostics.  */\n-\n-  if (TREE_CODE (decl) == FUNCTION_DECL)\n+  int lev = 0;\n+  /* C++ provide a robust way to check for type compatibility via the ODR\n+     rule.  */\n+  if (odr_or_derived_type_p (prevailing_type) && odr_type_p (type)\n+      && !odr_types_equivalent_p (prevailing_type, type))\n+    lev = 2;\n+\n+  /* Function types needs special care, because types_compatible_p never\n+     thinks prototype is compatible to non-prototype.  */\n+  if ((TREE_CODE (type) == FUNCTION_TYPE || TREE_CODE (type) == METHOD_TYPE)\n+      && TREE_CODE (type) == TREE_CODE (prevailing_type))\n     {\n-      if (!types_compatible_p (TREE_TYPE (prevailing_decl),\n-\t\t\t       TREE_TYPE (decl)))\n-\t/* If we don't have a merged type yet...sigh.  The linker\n-\t   wouldn't complain if the types were mismatched, so we\n-\t   probably shouldn't either.  Just use the type from\n-\t   whichever decl appears to be associated with the\n-\t   definition.  If for some odd reason neither decl is, the\n-\t   older one wins.  */\n-\t(void) 0;\n-\n-      return true;\n+      lev |= warn_type_compatibility_p (TREE_TYPE (prevailing_type),\n+\t\t\t\t        TREE_TYPE (type));\n+      if (TREE_CODE (type) == METHOD_TYPE)\n+\tlev |= warn_type_compatibility_p (TYPE_METHOD_BASETYPE (prevailing_type),\n+\t\t\t\t\t  TYPE_METHOD_BASETYPE (type));\n+      if (prototype_p (prevailing_type) && prototype_p (type)\n+\t  && TYPE_ARG_TYPES (prevailing_type) != TYPE_ARG_TYPES (type))\n+\t{\n+\t  tree parm1, parm2;\n+\t  for (parm1 = TYPE_ARG_TYPES (prevailing_type),\n+\t       parm2 = TYPE_ARG_TYPES (type);\n+\t       parm1 && parm2;\n+\t       parm1 = TREE_CHAIN (prevailing_type),\n+\t       parm2 = TREE_CHAIN (type))\n+\t    lev |= warn_type_compatibility_p (TREE_VALUE (parm1),\n+\t\t\t\t\t      TREE_VALUE (parm2));\n+\t  if (parm1 || parm2)\n+\t    lev = 3;\n+\t}\n+      if (comp_type_attributes (prevailing_type, type) == 0)\n+\tlev = 3;\n+      return lev;\n     }\n-\n-  /* Now we exclusively deal with VAR_DECLs.  */\n-\n   /* Sharing a global symbol is a strong hint that two types are\n      compatible.  We could use this information to complete\n      incomplete pointed-to types more aggressively here, ignoring\n@@ -254,19 +259,22 @@ lto_symtab_merge (symtab_node *prevailing, symtab_node *entry)\n      ???  In principle we might want to only warn for structurally\n      incompatible types here, but unless we have protective measures\n      for TBAA in place that would hide useful information.  */\n-  prevailing_type = TYPE_MAIN_VARIANT (TREE_TYPE (prevailing_decl));\n-  type = TYPE_MAIN_VARIANT (TREE_TYPE (decl));\n+  prevailing_type = TYPE_MAIN_VARIANT (prevailing_type);\n+  type = TYPE_MAIN_VARIANT (type);\n \n   if (!types_compatible_p (prevailing_type, type))\n     {\n-      if (COMPLETE_TYPE_P (type))\n-\treturn false;\n+      if (TREE_CODE (prevailing_type) == FUNCTION_TYPE\n+\t  || TREE_CODE (type) == METHOD_TYPE)\n+\treturn 1 | lev;\n+      if (COMPLETE_TYPE_P (type) && COMPLETE_TYPE_P (prevailing_type))\n+\treturn 1 | lev;\n \n       /* If type is incomplete then avoid warnings in the cases\n \t that TBAA handles just fine.  */\n \n       if (TREE_CODE (prevailing_type) != TREE_CODE (type))\n-\treturn false;\n+\treturn 1 | lev;\n \n       if (TREE_CODE (prevailing_type) == ARRAY_TYPE)\n \t{\n@@ -280,10 +288,10 @@ lto_symtab_merge (symtab_node *prevailing, symtab_node *entry)\n \t    }\n \n \t  if (TREE_CODE (tem1) != TREE_CODE (tem2))\n-\t    return false;\n+\t    return 1 | lev;\n \n \t  if (!types_compatible_p (tem1, tem2))\n-\t    return false;\n+\t    return 1 | lev;\n \t}\n \n       /* Fallthru.  Compatible enough.  */\n@@ -292,6 +300,43 @@ lto_symtab_merge (symtab_node *prevailing, symtab_node *entry)\n   /* ???  We might want to emit a warning here if type qualification\n      differences were spotted.  Do not do this unconditionally though.  */\n \n+  return lev;\n+}\n+\n+/* Merge two variable or function symbol table entries PREVAILING and ENTRY.\n+   Return false if the symbols are not fully compatible and a diagnostic\n+   should be emitted.  */\n+\n+static bool\n+lto_symtab_merge (symtab_node *prevailing, symtab_node *entry)\n+{\n+  tree prevailing_decl = prevailing->decl;\n+  tree decl = entry->decl;\n+\n+  if (prevailing_decl == decl)\n+    return true;\n+\n+  /* Merge decl state in both directions, we may still end up using\n+     the new decl.  */\n+  TREE_ADDRESSABLE (prevailing_decl) |= TREE_ADDRESSABLE (decl);\n+  TREE_ADDRESSABLE (decl) |= TREE_ADDRESSABLE (prevailing_decl);\n+\n+  /* The linker may ask us to combine two incompatible symbols.\n+     Detect this case and notify the caller of required diagnostics.  */\n+\n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n+    {\n+      if (warn_type_compatibility_p (TREE_TYPE (prevailing_decl),\n+\t\t\t             TREE_TYPE (decl)))\n+\treturn false;\n+\n+      return true;\n+    }\n+\n+  if (warn_type_compatibility_p (TREE_TYPE (prevailing_decl),\n+\t\t\t\t TREE_TYPE (decl)))\n+    return false;\n+\n   /* There is no point in comparing too many details of the decls here.\n      The type compatibility checks or the completing of types has properly\n      dealt with most issues.  */\n@@ -483,24 +528,39 @@ lto_symtab_merge_decls_2 (symtab_node *first, bool diagnosed_p)\n   /* Diagnose all mismatched re-declarations.  */\n   FOR_EACH_VEC_ELT (mismatches, i, decl)\n     {\n-      if (!types_compatible_p (TREE_TYPE (prevailing->decl),\n-\t\t\t       TREE_TYPE (decl)))\n-\tdiagnosed_p |= warning_at (DECL_SOURCE_LOCATION (decl), 0,\n-\t\t\t\t   \"type of %qD does not match original \"\n-\t\t\t\t   \"declaration\", decl);\n-\n+      int level = warn_type_compatibility_p (TREE_TYPE (prevailing->decl),\n+\t\t\t\t\t     TREE_TYPE (decl));\n+      if (level)\n+\t{\n+\t  bool diag = false;\n+\t  if (level > 1)\n+\t    diag = warning_at (DECL_SOURCE_LOCATION (decl),\n+\t\t\t       OPT_Wodr,\n+\t\t\t       \"%qD violates the C++ One Definition Rule \",\n+\t\t\t       decl);\n+\t  if (!diag && (level & 1))\n+\t    diag = warning_at (DECL_SOURCE_LOCATION (decl),\n+\t\t\t       OPT_Wlto_type_mismatch,\n+\t\t\t       \"type of %qD does not match original \"\n+\t\t\t       \"declaration\", decl);\n+\t  if (diag)\n+\t    warn_types_mismatch (TREE_TYPE (prevailing->decl),\n+\t\t\t\t TREE_TYPE (decl));\n+\t  diagnosed_p |= diag;\n+\t}\n       else if ((DECL_USER_ALIGN (prevailing->decl)\n \t        && DECL_USER_ALIGN (decl))\n \t       && DECL_ALIGN (prevailing->decl) < DECL_ALIGN (decl))\n \t{\n-\t  diagnosed_p |= warning_at (DECL_SOURCE_LOCATION (decl), 0,\n+\t  diagnosed_p |= warning_at (DECL_SOURCE_LOCATION (decl),\n+\t\t\t\t     OPT_Wlto_type_mismatch,\n \t\t\t\t     \"alignment of %qD is bigger than \"\n \t\t\t\t     \"original declaration\", decl);\n \t}\n     }\n   if (diagnosed_p)\n     inform (DECL_SOURCE_LOCATION (prevailing->decl),\n-\t    \"previously declared here\");\n+\t    \"%qD was previously declared here\", prevailing->decl);\n \n   mismatches.release ();\n }"}, {"sha": "5133549afed0f749164e8425c6f17f14b39bf7e5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/259d29e396dbee07d0211196cd212c3464c5c325/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/259d29e396dbee07d0211196cd212c3464c5c325/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=259d29e396dbee07d0211196cd212c3464c5c325", "patch": "@@ -1,3 +1,12 @@\n+2015-05-16  Jan Hubica  <hubicka@ucw.cz>\n+\n+\t* gfortran.dg/lto/20091028-2_1.c: Fix return value.\n+\t* gfortran.dg/lto/pr41576_1.f90: Add interface.\n+\t* gfortran.dg/lto/pr41521_0.f90: Disable lto-type-mismatch\n+\t* gfortran.dg/lto/pr60635_0.f90: Disable lto-type-mismatch.\n+\t* gfortran.dg/lto/20091028-1_1.c: Fix return type.\n+\t* gcc.dg/lto/20120723_0.c: Disbale lto-type-mismatch.\n+\n 2015-05-16  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/65903"}, {"sha": "77694d8503ac93c06c4d287cea83f76ad0be4792", "filename": "gcc/testsuite/gcc.dg/lto/20120723_0.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/259d29e396dbee07d0211196cd212c3464c5c325/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20120723_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/259d29e396dbee07d0211196cd212c3464c5c325/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20120723_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20120723_0.c?ref=259d29e396dbee07d0211196cd212c3464c5c325", "patch": "@@ -3,7 +3,7 @@\n    ??? This testcase is invalid C and can only pass on specific platforms.  */\n /* { dg-lto-do run } */\n /* { dg-skip-if \"\" { { sparc*-*-* } && ilp32 } { \"*\" } { \"\" } } */\n-/* { dg-lto-options { {-O3 -fno-early-inlining -flto}} } */\n+/* { dg-lto-options { {-O3 -fno-early-inlining -flto -Wno-lto-type-mismatch}} } */\n \n extern void abort (void);\n "}, {"sha": "2db8438bc49575b50edf4d6389f481afb75be087", "filename": "gcc/testsuite/gfortran.dg/lto/20091028-1_1.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/259d29e396dbee07d0211196cd212c3464c5c325/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2F20091028-1_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/259d29e396dbee07d0211196cd212c3464c5c325/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2F20091028-1_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2F20091028-1_1.c?ref=259d29e396dbee07d0211196cd212c3464c5c325", "patch": "@@ -1,9 +1,9 @@\n extern void bcopy(const void *, void *, __SIZE_TYPE__ n);\n char *p;\n-int int_gen_ti_header_c_ (char * hdrbuf, int * hdrbufsize,\n-                          int * itypesize, int * typesize,\n-                          int * DataHandle, char * Data,\n-                          int * Count, int * code)\n+void int_gen_ti_header_c_ (char * hdrbuf, int * hdrbufsize,\n+                           int * itypesize, int * typesize,\n+                           int * DataHandle, char * Data,\n+                           int * Count, int * code)\n {\n   bcopy (typesize, p, sizeof(int)) ;\n   bcopy (Data, p, *Count * *typesize) ;"}, {"sha": "e4718c214e035640b6e3f53b62b56bdb1ece69d2", "filename": "gcc/testsuite/gfortran.dg/lto/20091028-2_1.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/259d29e396dbee07d0211196cd212c3464c5c325/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2F20091028-2_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/259d29e396dbee07d0211196cd212c3464c5c325/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2F20091028-2_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2F20091028-2_1.c?ref=259d29e396dbee07d0211196cd212c3464c5c325", "patch": "@@ -1,9 +1,9 @@\n extern void *memcpy(void *dest, const void *src, __SIZE_TYPE__ n);\n char *p;\n-int int_gen_ti_header_c_ (char * hdrbuf, int * hdrbufsize,\n-                          int * itypesize, int * typesize,\n-                          int * DataHandle, char * Data,\n-                          int * Count, int * code)\n+void int_gen_ti_header_c_ (char * hdrbuf, int * hdrbufsize,\n+                           int * itypesize, int * typesize,\n+                           int * DataHandle, char * Data,\n+                           int * Count, int * code)\n {\n   memcpy (typesize, p, sizeof(int)) ;\n   memcpy (Data, p, *Count * *typesize) ;"}, {"sha": "9ec8d370561a86a41f79be632749b3616e71f41d", "filename": "gcc/testsuite/gfortran.dg/lto/pr41521_0.f90", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/259d29e396dbee07d0211196cd212c3464c5c325/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fpr41521_0.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/259d29e396dbee07d0211196cd212c3464c5c325/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fpr41521_0.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fpr41521_0.f90?ref=259d29e396dbee07d0211196cd212c3464c5c325", "patch": "@@ -1,9 +1,16 @@\n ! { dg-lto-do link }\n-! { dg-lto-options {{-g -flto} {-g -O -flto}} }\n+! { dg-lto-options {{-g -flto -Wno-lto-type-mismatch} {-g -O -flto -Wno-lto-type-mismatch}} }\n program species\n integer spk(2)\n real eval(2)\n spk = 2\n call atom(1.1,spk,eval)\n end program\n+interface\n+  subroutine atom(sol,k,eval)\n+    real, intent(in) :: sol\n+    integer, intent(in) :: k(2)\n+    real, intent(out) :: eval(2)\n+  end subroutine\n+end interface\n "}, {"sha": "609c17ed20a5e4900dc78c394ad9d1c70abcf419", "filename": "gcc/testsuite/gfortran.dg/lto/pr41576_0.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/259d29e396dbee07d0211196cd212c3464c5c325/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fpr41576_0.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/259d29e396dbee07d0211196cd212c3464c5c325/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fpr41576_0.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fpr41576_0.f90?ref=259d29e396dbee07d0211196cd212c3464c5c325", "patch": "@@ -1,5 +1,5 @@\n ! { dg-lto-do run }\n-! { dg-lto-options { { -O2 -flto -Werror } } }\n+! { dg-lto-options { { -O2 -flto -Werror -Wno-lto-type-mismatch } } }\n \n subroutine foo\n   common /bar/ a, b"}, {"sha": "877e044af1aaeac5b9e80f169be4792307dc22e7", "filename": "gcc/testsuite/gfortran.dg/lto/pr41576_1.f90", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/259d29e396dbee07d0211196cd212c3464c5c325/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fpr41576_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/259d29e396dbee07d0211196cd212c3464c5c325/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fpr41576_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fpr41576_1.f90?ref=259d29e396dbee07d0211196cd212c3464c5c325", "patch": "@@ -5,3 +5,8 @@ program test\n   if (c/=1 .or. d/=2) call abort\n end program test\n \n+interface\n+  subroutine foo()\n+  end subroutine\n+end interface\n+"}, {"sha": "37d084d802a57d78a55a3d8a184e248f01ff7b16", "filename": "gcc/testsuite/gfortran.dg/lto/pr60635_0.f90", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/259d29e396dbee07d0211196cd212c3464c5c325/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fpr60635_0.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/259d29e396dbee07d0211196cd212c3464c5c325/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fpr60635_0.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fpr60635_0.f90?ref=259d29e396dbee07d0211196cd212c3464c5c325", "patch": "@@ -1,4 +1,5 @@\n ! { dg-lto-do link }\n+! { dg-lto-options {{ -Wno-lto-type-mismatch }} }\n program test\n   use iso_fortran_env\n "}, {"sha": "6297f04865ca1e3eca6bf67ff0f5a003a14b1142", "filename": "gcc/tree.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/259d29e396dbee07d0211196cd212c3464c5c325/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/259d29e396dbee07d0211196cd212c3464c5c325/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=259d29e396dbee07d0211196cd212c3464c5c325", "patch": "@@ -5182,8 +5182,7 @@ need_assembler_name_p (tree decl)\n       && DECL_NAME (decl)\n       && decl == TYPE_NAME (TREE_TYPE (decl))\n       && !TYPE_ARTIFICIAL (TREE_TYPE (decl))\n-      && (((RECORD_OR_UNION_TYPE_P (TREE_TYPE (decl))\n-\t   || TREE_CODE (TREE_TYPE (decl)) == ENUMERAL_TYPE)\n+      && ((type_with_linkage_p (TREE_TYPE (decl))\n \t   && !type_in_anonymous_namespace_p (TREE_TYPE (decl)))\n \t  || TREE_CODE (TREE_TYPE (decl)) == INTEGER_TYPE)\n       && !variably_modified_type_p (TREE_TYPE (decl), NULL_TREE))"}, {"sha": "912b05405d81c2e84a82c563b171b5fa79fbdc45", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/259d29e396dbee07d0211196cd212c3464c5c325/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/259d29e396dbee07d0211196cd212c3464c5c325/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=259d29e396dbee07d0211196cd212c3464c5c325", "patch": "@@ -4544,7 +4544,6 @@ extern tree obj_type_ref_class (tree ref);\n extern bool types_same_for_odr (const_tree type1, const_tree type2,\n \t\t\t\tbool strict=false);\n extern bool contains_bitfld_component_ref_p (const_tree);\n-extern bool type_in_anonymous_namespace_p (const_tree);\n extern bool block_may_fallthru (const_tree);\n extern void using_eh_for_cleanups (void);\n extern bool using_eh_for_cleanups_p (void);"}]}