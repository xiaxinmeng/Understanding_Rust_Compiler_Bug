{"sha": "ab40695a46c6649bac40f4251e37993d73fa7a13", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWI0MDY5NWE0NmM2NjQ5YmFjNDBmNDI1MWUzNzk5M2Q3M2ZhN2ExMw==", "commit": {"author": {"name": "Mike Crowe", "email": "mac@mcrowe.com", "date": "2019-12-02T16:23:10Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-12-02T16:23:10Z"}, "message": "libstdc++: Add full steady_clock support to shared_timed_mutex\n\nThe pthread_rwlock_clockrdlock and pthread_rwlock_clockwrlock functions\nwere added to glibc in v2.30. They have also been added to Android\nBionic. If these functions are available in the C library then they can\nbe used to implement shared_timed_mutex::try_lock_until,\nshared_timed_mutex::try_lock_for,\nshared_timed_mutex::try_lock_shared_until and\nshared_timed_mutex::try_lock_shared_for so that they are no longer\nunaffected by the system clock being warped. (This is the shared_mutex\nequivalent of PR libstdc++/78237 for mutex.)\n\nIf the new functions are available then steady_clock is deemed to be the\n\"best\" clock available which means that it is used for the relative\ntry_lock_for calls and absolute try_lock_until calls using steady_clock\nand user-defined clocks. It's not possible to have\n_GLIBCXX_USE_PTHREAD_RWLOCK_CLOCKLOCK defined without\n_GLIBCXX_USE_PTHREAD_RWLOCK_T, so the requirement that the clock be the\nsame as condition_variable is maintained. Calls explicitly using\nsystem_clock (aka high_resolution_clock) continue to use CLOCK_REALTIME\nvia the old pthread_rwlock_timedrdlock and pthread_rwlock_timedwrlock\nfunctions.\n\nIf the new functions are not available then system_clock is deemed to be\nthe \"best\" clock available which means that the previous suboptimal\nbehaviour remains.\n\nAdditionally, the user-defined clock used with\nshared_timed_mutex::try_lock_for and shared_mutex::try_lock_shared_for\nmay have higher precision than __clock_t. We may need to round the\nduration up to ensure that the timeout is long enough. (See\n__timed_mutex_impl::_M_try_lock_for)\n\n2019-12-02  Mike Crowe  <mac@mcrowe.com>\n\n\tAdd full steady_clock support to shared_timed_mutex\n\t* acinclude.m4 (GLIBCXX_CHECK_PTHREAD_RWLOCK_CLOCKLOCK): Define\n\tto check for the presence of both pthread_rwlock_clockrdlock and\n\tpthread_rwlock_clockwrlock.\n\t* config.h.in: Regenerate.\n\t* configure.ac: Call GLIBCXX_USE_PTHREAD_RWLOCK_CLOCKLOCK.\n\t* configure: Regenerate.\n\t* include/std/shared_mutex (shared_timed_mutex): Define __clock_t as\n\tthe best clock to use for relative waits.\n\t(shared_timed_mutex::try_lock_for) Round up wait duration if necessary.\n\t(shared_timed_mutex::try_lock_shared_for): Likewise.\n\t(shared_timed_mutex::try_lock_until): Use existing try_lock_until\n\timplementation for system_clock (which matches __clock_t when\n\t_GLIBCCXX_USE_PTHREAD_RWLOCK_CLOCKLOCK is not defined). Add new\n\toverload for steady_clock that uses pthread_rwlock_clockwrlock if it\n\tis available. Simplify overload for non-standard clock to just call\n\ttry_lock_for with a relative timeout.\n\t(shared_timed_mutex::try_lock_shared_until): Likewise.\n\nFrom-SVN: r278903", "tree": {"sha": "1bdab64d9d7ca9afe4f3b1d7c4affbcb4be178f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1bdab64d9d7ca9afe4f3b1d7c4affbcb4be178f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab40695a46c6649bac40f4251e37993d73fa7a13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab40695a46c6649bac40f4251e37993d73fa7a13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab40695a46c6649bac40f4251e37993d73fa7a13", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab40695a46c6649bac40f4251e37993d73fa7a13/comments", "author": {"login": "mikecrowe", "id": 93615, "node_id": "MDQ6VXNlcjkzNjE1", "avatar_url": "https://avatars.githubusercontent.com/u/93615?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikecrowe", "html_url": "https://github.com/mikecrowe", "followers_url": "https://api.github.com/users/mikecrowe/followers", "following_url": "https://api.github.com/users/mikecrowe/following{/other_user}", "gists_url": "https://api.github.com/users/mikecrowe/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikecrowe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikecrowe/subscriptions", "organizations_url": "https://api.github.com/users/mikecrowe/orgs", "repos_url": "https://api.github.com/users/mikecrowe/repos", "events_url": "https://api.github.com/users/mikecrowe/events{/privacy}", "received_events_url": "https://api.github.com/users/mikecrowe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7334019b11798a9e791edef62a690b521e78a5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7334019b11798a9e791edef62a690b521e78a5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7334019b11798a9e791edef62a690b521e78a5b"}], "stats": {"total": 247, "additions": 226, "deletions": 21}, "files": [{"sha": "93331fb529a054fe65ff845887f050f6bb70ca7a", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab40695a46c6649bac40f4251e37993d73fa7a13/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab40695a46c6649bac40f4251e37993d73fa7a13/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=ab40695a46c6649bac40f4251e37993d73fa7a13", "patch": "@@ -1,5 +1,24 @@\n 2019-12-02  Mike Crowe  <mac@mcrowe.com>\n \n+\tAdd full steady_clock support to shared_timed_mutex\n+\t* acinclude.m4 (GLIBCXX_CHECK_PTHREAD_RWLOCK_CLOCKLOCK): Define\n+\tto check for the presence of both pthread_rwlock_clockrdlock and\n+\tpthread_rwlock_clockwrlock.\n+\t* config.h.in: Regenerate.\n+\t* configure.ac: Call GLIBCXX_USE_PTHREAD_RWLOCK_CLOCKLOCK.\n+\t* configure: Regenerate.\n+\t* include/std/shared_mutex (shared_timed_mutex): Define __clock_t as\n+\tthe best clock to use for relative waits.\n+\t(shared_timed_mutex::try_lock_for) Round up wait duration if necessary.\n+\t(shared_timed_mutex::try_lock_shared_for): Likewise.\n+\t(shared_timed_mutex::try_lock_until): Use existing try_lock_until\n+\timplementation for system_clock (which matches __clock_t when\n+\t_GLIBCCXX_USE_PTHREAD_RWLOCK_CLOCKLOCK is not defined). Add new\n+\toverload for steady_clock that uses pthread_rwlock_clockwrlock if it\n+\tis available. Simplify overload for non-standard clock to just call\n+\ttry_lock_for with a relative timeout.\n+\t(shared_timed_mutex::try_lock_shared_until): Likewise.\n+\n \tPR libstdc++/91906 Fix timed_mutex::try_lock_until on arbitrary clock\n \t* include/std/mutex (__timed_mutex_impl::_M_try_lock_until): Loop\n \tuntil the absolute timeout time is reached as measured against the"}, {"sha": "016b0c583d050804af5d7192ef9f81dac57b0522", "filename": "libstdc++-v3/acinclude.m4", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab40695a46c6649bac40f4251e37993d73fa7a13/libstdc%2B%2B-v3%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab40695a46c6649bac40f4251e37993d73fa7a13/libstdc%2B%2B-v3%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Facinclude.m4?ref=ab40695a46c6649bac40f4251e37993d73fa7a13", "patch": "@@ -4258,6 +4258,39 @@ AC_DEFUN([GLIBCXX_CHECK_PTHREAD_MUTEX_CLOCKLOCK], [\n   AC_LANG_RESTORE\n ])\n \n+dnl\n+dnl Check whether pthread_mutex_clocklock is available in <pthread.h> for std::timed_mutex to use,\n+dnl and define _GLIBCXX_USE_PTHREAD_MUTEX_CLOCKLOCK.\n+dnl\n+AC_DEFUN([GLIBCXX_CHECK_PTHREAD_RWLOCK_CLOCKLOCK], [\n+\n+  AC_LANG_SAVE\n+  AC_LANG_CPLUSPLUS\n+  ac_save_CXXFLAGS=\"$CXXFLAGS\"\n+  CXXFLAGS=\"$CXXFLAGS -fno-exceptions\"\n+  ac_save_LIBS=\"$LIBS\"\n+  LIBS=\"$LIBS -lpthread\"\n+\n+  AC_MSG_CHECKING([for pthread_rwlock_clockrdlock, pthread_wlock_clockwrlock])\n+  AC_CACHE_VAL(glibcxx_cv_PTHREAD_RWLOCK_CLOCKLOCK, [\n+    GCC_TRY_COMPILE_OR_LINK(\n+      [#include <pthread.h>],\n+      [pthread_rwlock_t rwl; struct timespec ts;]\n+      [int n = pthread_rwlock_clockrdlock(&rwl, CLOCK_REALTIME, &ts);]\n+      [int m = pthread_rwlock_clockwrlock(&rwl, CLOCK_REALTIME, &ts);],\n+      [glibcxx_cv_PTHREAD_RWLOCK_CLOCKLOCK=yes],\n+      [glibcxx_cv_PTHREAD_RWLOCK_CLOCKLOCK=no])\n+  ])\n+  if test $glibcxx_cv_PTHREAD_RWLOCK_CLOCKLOCK = yes; then\n+    AC_DEFINE(_GLIBCXX_USE_PTHREAD_RWLOCK_CLOCKLOCK, 1, [Define if pthread_rwlock_clockrdlock and pthread_rwlock_clockwrlock are available in <pthread.h>.])\n+  fi\n+  AC_MSG_RESULT($glibcxx_cv_PTHREAD_RWLOCK_CLOCKLOCK)\n+\n+  CXXFLAGS=\"$ac_save_CXXFLAGS\"\n+  LIBS=\"$ac_save_LIBS\"\n+  AC_LANG_RESTORE\n+])\n+\n dnl\n dnl Check whether sysctl is available in <pthread.h>, and define _GLIBCXX_USE_SYSCTL_HW_NCPU.\n dnl"}, {"sha": "8940e0c7acd1b9aea7bf1ea40727899c69d322fb", "filename": "libstdc++-v3/config.h.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab40695a46c6649bac40f4251e37993d73fa7a13/libstdc%2B%2B-v3%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab40695a46c6649bac40f4251e37993d73fa7a13/libstdc%2B%2B-v3%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig.h.in?ref=ab40695a46c6649bac40f4251e37993d73fa7a13", "patch": "@@ -1005,6 +1005,10 @@\n /* Define if pthread_mutex_clocklock is available in <pthread.h>. */\n #undef _GLIBCXX_USE_PTHREAD_MUTEX_CLOCKLOCK\n \n+/* Define if pthread_rwlock_clockrdlock and pthread_rwlock_clockwrlock are\n+   available in <pthread.h>. */\n+#undef _GLIBCXX_USE_PTHREAD_RWLOCK_CLOCKLOCK\n+\n /* Define if POSIX read/write locks are available in <gthr.h>. */\n #undef _GLIBCXX_USE_PTHREAD_RWLOCK_T\n "}, {"sha": "b7242157107f8009de213960b168f8b20c2ba0ef", "filename": "libstdc++-v3/configure", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab40695a46c6649bac40f4251e37993d73fa7a13/libstdc%2B%2B-v3%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab40695a46c6649bac40f4251e37993d73fa7a13/libstdc%2B%2B-v3%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure?ref=ab40695a46c6649bac40f4251e37993d73fa7a13", "patch": "@@ -21963,6 +21963,93 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu\n \n \n \n+# For pthread_rwlock_clockrdlock and pthread_rwlock_clockwrlock\n+\n+\n+\n+  ac_ext=cpp\n+ac_cpp='$CXXCPP $CPPFLAGS'\n+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'\n+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\n+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu\n+\n+  ac_save_CXXFLAGS=\"$CXXFLAGS\"\n+  CXXFLAGS=\"$CXXFLAGS -fno-exceptions\"\n+  ac_save_LIBS=\"$LIBS\"\n+  LIBS=\"$LIBS -lpthread\"\n+\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for pthread_rwlock_clockrdlock, pthread_wlock_clockwrlock\" >&5\n+$as_echo_n \"checking for pthread_rwlock_clockrdlock, pthread_wlock_clockwrlock... \" >&6; }\n+  if ${glibcxx_cv_PTHREAD_RWLOCK_CLOCKLOCK+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+\n+    if test x$gcc_no_link = xyes; then\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#include <pthread.h>\n+int\n+main ()\n+{\n+pthread_rwlock_t rwl; struct timespec ts;\n+      int n = pthread_rwlock_clockrdlock(&rwl, CLOCK_REALTIME, &ts);\n+      int m = pthread_rwlock_clockwrlock(&rwl, CLOCK_REALTIME, &ts);\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_cxx_try_compile \"$LINENO\"; then :\n+  glibcxx_cv_PTHREAD_RWLOCK_CLOCKLOCK=yes\n+else\n+  glibcxx_cv_PTHREAD_RWLOCK_CLOCKLOCK=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+else\n+  if test x$gcc_no_link = xyes; then\n+  as_fn_error $? \"Link tests are not allowed after GCC_NO_EXECUTABLES.\" \"$LINENO\" 5\n+fi\n+cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#include <pthread.h>\n+int\n+main ()\n+{\n+pthread_rwlock_t rwl; struct timespec ts;\n+      int n = pthread_rwlock_clockrdlock(&rwl, CLOCK_REALTIME, &ts);\n+      int m = pthread_rwlock_clockwrlock(&rwl, CLOCK_REALTIME, &ts);\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_cxx_try_link \"$LINENO\"; then :\n+  glibcxx_cv_PTHREAD_RWLOCK_CLOCKLOCK=yes\n+else\n+  glibcxx_cv_PTHREAD_RWLOCK_CLOCKLOCK=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext \\\n+    conftest$ac_exeext conftest.$ac_ext\n+fi\n+\n+fi\n+\n+  if test $glibcxx_cv_PTHREAD_RWLOCK_CLOCKLOCK = yes; then\n+\n+$as_echo \"#define _GLIBCXX_USE_PTHREAD_RWLOCK_CLOCKLOCK 1\" >>confdefs.h\n+\n+  fi\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_PTHREAD_RWLOCK_CLOCKLOCK\" >&5\n+$as_echo \"$glibcxx_cv_PTHREAD_RWLOCK_CLOCKLOCK\" >&6; }\n+\n+  CXXFLAGS=\"$ac_save_CXXFLAGS\"\n+  LIBS=\"$ac_save_LIBS\"\n+  ac_ext=c\n+ac_cpp='$CPP $CPPFLAGS'\n+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'\n+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\n+ac_compiler_gnu=$ac_cv_c_compiler_gnu\n+\n+\n+\n \n   ac_fn_c_check_header_mongrel \"$LINENO\" \"locale.h\" \"ac_cv_header_locale_h\" \"$ac_includes_default\"\n if test \"x$ac_cv_header_locale_h\" = xyes; then :"}, {"sha": "699e55fd829d40b464bf62e920418eec5da6356d", "filename": "libstdc++-v3/configure.ac", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab40695a46c6649bac40f4251e37993d73fa7a13/libstdc%2B%2B-v3%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab40695a46c6649bac40f4251e37993d73fa7a13/libstdc%2B%2B-v3%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure.ac?ref=ab40695a46c6649bac40f4251e37993d73fa7a13", "patch": "@@ -228,6 +228,9 @@ GLIBCXX_CHECK_PTHREAD_COND_CLOCKWAIT\n # For pthread_mutex_clocklock\n GLIBCXX_CHECK_PTHREAD_MUTEX_CLOCKLOCK\n \n+# For pthread_rwlock_clockrdlock and pthread_rwlock_clockwrlock\n+GLIBCXX_CHECK_PTHREAD_RWLOCK_CLOCKLOCK\n+\n AC_LC_MESSAGES\n \n # For hardware_concurrency"}, {"sha": "cfe2ec078e1d1527b7a8b603c68a48d86664d0d8", "filename": "libstdc++-v3/include/std/shared_mutex", "status": "modified", "additions": 80, "deletions": 21, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab40695a46c6649bac40f4251e37993d73fa7a13/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fshared_mutex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab40695a46c6649bac40f4251e37993d73fa7a13/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fshared_mutex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fshared_mutex?ref=ab40695a46c6649bac40f4251e37993d73fa7a13", "patch": "@@ -450,7 +450,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     using _Base = __shared_timed_mutex_base;\n \n     // Must use the same clock as condition_variable for __shared_mutex_cv.\n-    typedef chrono::system_clock\t__clock_t;\n+#ifdef _GLIBCXX_USE_PTHREAD_RWLOCK_CLOCKLOCK\n+    using __clock_t = chrono::steady_clock;\n+#else\n+    using __clock_t = chrono::system_clock;\n+#endif\n \n   public:\n     shared_timed_mutex() = default;\n@@ -467,9 +471,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n     template<typename _Rep, typename _Period>\n       bool\n-      try_lock_for(const chrono::duration<_Rep, _Period>& __rel_time)\n+      try_lock_for(const chrono::duration<_Rep, _Period>& __rtime)\n       {\n-\treturn try_lock_until(__clock_t::now() + __rel_time);\n+\tauto __rt = chrono::duration_cast<__clock_t::duration>(__rtime);\n+\tif (ratio_greater<__clock_t::period, _Period>())\n+\t  ++__rt;\n+\treturn try_lock_until(__clock_t::now() + __rt);\n       }\n \n     // Shared ownership\n@@ -480,9 +487,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n     template<typename _Rep, typename _Period>\n       bool\n-      try_lock_shared_for(const chrono::duration<_Rep, _Period>& __rel_time)\n+      try_lock_shared_for(const chrono::duration<_Rep, _Period>& __rtime)\n       {\n-\treturn try_lock_shared_until(__clock_t::now() + __rel_time);\n+\tauto __rt = chrono::duration_cast<__clock_t::duration>(__rtime);\n+\tif (ratio_greater<__clock_t::period, _Period>())\n+\t  ++__rt;\n+\treturn try_lock_shared_until(__clock_t::now() + __rt);\n       }\n \n #if _GLIBCXX_USE_PTHREAD_RWLOCK_T && _GTHREAD_USE_MUTEX_TIMEDLOCK\n@@ -491,7 +501,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n     template<typename _Duration>\n       bool\n-      try_lock_until(const chrono::time_point<__clock_t, _Duration>& __atime)\n+      try_lock_until(const chrono::time_point<chrono::system_clock,\n+\t\t     _Duration>& __atime)\n       {\n \tauto __s = chrono::time_point_cast<chrono::seconds>(__atime);\n \tauto __ns = chrono::duration_cast<chrono::nanoseconds>(__atime - __s);\n@@ -512,23 +523,47 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \treturn true;\n       }\n \n+#ifdef _GLIBCXX_USE_PTHREAD_RWLOCK_CLOCKLOCK\n+    template<typename _Duration>\n+      bool\n+      try_lock_until(const chrono::time_point<chrono::steady_clock,\n+\t\t   _Duration>& __atime)\n+      {\n+\tauto __s = chrono::time_point_cast<chrono::seconds>(__atime);\n+\tauto __ns = chrono::duration_cast<chrono::nanoseconds>(__atime - __s);\n+\n+\t__gthread_time_t __ts =\n+\t  {\n+\t    static_cast<std::time_t>(__s.time_since_epoch().count()),\n+\t    static_cast<long>(__ns.count())\n+\t  };\n+\n+\tint __ret = pthread_rwlock_clockwrlock(&_M_rwlock, CLOCK_MONOTONIC,\n+\t\t\t\t\t       &__ts);\n+\t// On self-deadlock, we just fail to acquire the lock.  Technically,\n+\t// the program violated the precondition.\n+\tif (__ret == ETIMEDOUT || __ret == EDEADLK)\n+\t  return false;\n+\t// Errors not handled: EINVAL\n+\t__glibcxx_assert(__ret == 0);\n+\treturn true;\n+      }\n+#endif\n+\n     template<typename _Clock, typename _Duration>\n       bool\n-      try_lock_until(const chrono::time_point<_Clock, _Duration>& __abs_time)\n+      try_lock_until(const chrono::time_point<_Clock, _Duration>& __atime)\n       {\n-\t// DR 887 - Sync unknown clock to known clock.\n-\tconst typename _Clock::time_point __c_entry = _Clock::now();\n-\tconst __clock_t::time_point __s_entry = __clock_t::now();\n-\tconst auto __delta = __abs_time - __c_entry;\n-\tconst auto __s_atime = __s_entry + __delta;\n-\treturn try_lock_until(__s_atime);\n+\ttypename _Clock::time_point __now = _Clock::now();\n+\tauto __rtime = __atime - __now;\n+\treturn try_lock_for(__rtime);\n       }\n \n     // Shared ownership\n \n     template<typename _Duration>\n       bool\n-      try_lock_shared_until(const chrono::time_point<__clock_t,\n+      try_lock_shared_until(const chrono::time_point<chrono::system_clock,\n \t\t\t    _Duration>& __atime)\n       {\n \tauto __s = chrono::time_point_cast<chrono::seconds>(__atime);\n@@ -564,17 +599,41 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \treturn true;\n       }\n \n+#ifdef _GLIBCXX_USE_PTHREAD_RWLOCK_CLOCKLOCK\n+    template<typename _Duration>\n+      bool\n+      try_lock_shared_until(const chrono::time_point<chrono::steady_clock,\n+\t\t\t    _Duration>& __atime)\n+      {\n+\tauto __s = chrono::time_point_cast<chrono::seconds>(__atime);\n+\tauto __ns = chrono::duration_cast<chrono::nanoseconds>(__atime - __s);\n+\n+\t__gthread_time_t __ts =\n+\t  {\n+\t    static_cast<std::time_t>(__s.time_since_epoch().count()),\n+\t    static_cast<long>(__ns.count())\n+\t  };\n+\n+\tint __ret = pthread_rwlock_clockrdlock(&_M_rwlock, CLOCK_MONOTONIC,\n+\t\t\t\t\t       &__ts);\n+\t// On self-deadlock, we just fail to acquire the lock.  Technically,\n+\t// the program violated the precondition.\n+\tif (__ret == ETIMEDOUT || __ret == EDEADLK)\n+\t  return false;\n+\t// Errors not handled: EINVAL\n+\t__glibcxx_assert(__ret == 0);\n+\treturn true;\n+      }\n+#endif\n+\n     template<typename _Clock, typename _Duration>\n       bool\n       try_lock_shared_until(const chrono::time_point<_Clock,\n-\t\t\t\t\t\t     _Duration>& __abs_time)\n+\t\t\t\t\t\t     _Duration>& __atime)\n       {\n-\t// DR 887 - Sync unknown clock to known clock.\n-\tconst typename _Clock::time_point __c_entry = _Clock::now();\n-\tconst __clock_t::time_point __s_entry = __clock_t::now();\n-\tconst auto __delta = __abs_time - __c_entry;\n-\tconst auto __s_atime = __s_entry + __delta;\n-\treturn try_lock_shared_until(__s_atime);\n+\ttypename _Clock::time_point __now = _Clock::now();\n+\tauto __rtime = __atime - __now;\n+\treturn try_lock_shared_for(__rtime);\n       }\n \n #else // ! (_GLIBCXX_USE_PTHREAD_RWLOCK_T && _GTHREAD_USE_MUTEX_TIMEDLOCK)"}]}