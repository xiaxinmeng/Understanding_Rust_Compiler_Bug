{"sha": "e6a054481d2586056b845639c8e26158169c027f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTZhMDU0NDgxZDI1ODYwNTZiODQ1NjM5YzhlMjYxNTgxNjljMDI3Zg==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2010-11-10T19:08:49Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2010-11-10T19:08:49Z"}, "message": "PR libstdc++/44436 (partial)\n\n2010-11-10  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR libstdc++/44436 (partial)\n\tPR libstdc++/46148\n        * include/bits/stl_tree.h (_Rb_tree<>::_M_insert_, _M_insert_lower,\n\t_M_insert_equal_lower, _M_insert_unique, _M_insert_equal,\n\t_M_insert_unique_, _M_insert_equal_): Templatize in C++0x mode,\n\tuse _GLIBCXX_FORWARD throughout.\n        * include/bits/stl_map.h (map<>::insert(_Pair&&),\n\tinsert(const_iterator, _Pair&&), operator[](key_type&&): Add.\n        * include/bits/stl_set.h (set<>::insert(value_type&&),\n\tinsert(const_iterator, value_type&&)): Likewise.\n        * include/bits/stl_multimap.h (multimap<>::insert(_Pair&&),\n\tinsert(const_iterator, _Pair&&)): Likewise.\n        * include/bits/stl_multiset.h (multiset<>::insert(value_type&&),\n\tinsert(const_iterator, value_type&&)): Likewise.\n\t* include/debug/set.h: Adjust.\n        * include/debug/multiset.h: Likewise.\n        * include/debug/map.h: Likewise.\n        * include/debug/multimap.h: Likewise.\n        * include/profile/set.h: Likewise.\n        * include/profile/multiset.h: Likewise.\n        * include/profile/map.h: Likewise.\n        * include/profile/multimap.h: Likewise.\n        * testsuite/23_containers/multimap/modifiers/insert/1.cc: New.\n        * testsuite/23_containers/multimap/modifiers/insert/2.cc: Likewise.\n        * testsuite/23_containers/multimap/modifiers/insert/3.cc: Likewise.\n        * testsuite/23_containers/multimap/modifiers/insert/4.cc: Likewise.\n        * testsuite/23_containers/set/modifiers/insert/2.cc: Likewise.\n        * testsuite/23_containers/set/modifiers/insert/3.cc: Likewise.\n        * testsuite/23_containers/multiset/modifiers/insert/3.cc: Likewise.\n        * testsuite/23_containers/multiset/modifiers/insert/4.cc: Likewise.\n        * testsuite/23_containers/map/modifiers/insert/2.cc: Likewise.\n        * testsuite/23_containers/map/modifiers/insert/3.cc: Likewise.\n        * testsuite/23_containers/map/modifiers/insert/4.cc: Likewise.\n        * testsuite/23_containers/map/modifiers/insert/5.cc: Likewise.\n        * testsuite/23_containers/map/element_access/2.cc: Likewise.\n        * testsuite/23_containers/map/element_access/46148.cc: Likewise.\n\n        * include/bits/hashtable.h: Trivial naming changes.\n\nFrom-SVN: r166551", "tree": {"sha": "30d2272196c6805674140a544854a6c75e9e0076", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/30d2272196c6805674140a544854a6c75e9e0076"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6a054481d2586056b845639c8e26158169c027f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6a054481d2586056b845639c8e26158169c027f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6a054481d2586056b845639c8e26158169c027f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6a054481d2586056b845639c8e26158169c027f/comments", "author": null, "committer": null, "parents": [{"sha": "1d3a84ce0338d5002672a643ca506224cd944298", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d3a84ce0338d5002672a643ca506224cd944298", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d3a84ce0338d5002672a643ca506224cd944298"}], "stats": {"total": 1448, "additions": 1405, "deletions": 43}, "files": [{"sha": "d5a5a967a4bc50c8444a24e2757c62c537ed6ac3", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=e6a054481d2586056b845639c8e26158169c027f", "patch": "@@ -1,3 +1,44 @@\n+2010-11-10  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR libstdc++/44436 (partial)\n+\tPR libstdc++/46148\n+        * include/bits/stl_tree.h (_Rb_tree<>::_M_insert_, _M_insert_lower,\n+\t_M_insert_equal_lower, _M_insert_unique, _M_insert_equal,\n+\t_M_insert_unique_, _M_insert_equal_): Templatize in C++0x mode,\n+\tuse _GLIBCXX_FORWARD throughout.\n+        * include/bits/stl_map.h (map<>::insert(_Pair&&),\n+\tinsert(const_iterator, _Pair&&), operator[](key_type&&): Add.\n+        * include/bits/stl_set.h (set<>::insert(value_type&&),\n+\tinsert(const_iterator, value_type&&)): Likewise.\n+        * include/bits/stl_multimap.h (multimap<>::insert(_Pair&&),\n+\tinsert(const_iterator, _Pair&&)): Likewise.\n+        * include/bits/stl_multiset.h (multiset<>::insert(value_type&&),\n+\tinsert(const_iterator, value_type&&)): Likewise.\n+\t* include/debug/set.h: Adjust.\n+        * include/debug/multiset.h: Likewise.\n+        * include/debug/map.h: Likewise.\n+        * include/debug/multimap.h: Likewise.\n+        * include/profile/set.h: Likewise.\n+        * include/profile/multiset.h: Likewise.\n+        * include/profile/map.h: Likewise.\n+        * include/profile/multimap.h: Likewise.\n+        * testsuite/23_containers/multimap/modifiers/insert/1.cc: New.\n+        * testsuite/23_containers/multimap/modifiers/insert/2.cc: Likewise.\n+        * testsuite/23_containers/multimap/modifiers/insert/3.cc: Likewise.\n+        * testsuite/23_containers/multimap/modifiers/insert/4.cc: Likewise.\n+        * testsuite/23_containers/set/modifiers/insert/2.cc: Likewise.\n+        * testsuite/23_containers/set/modifiers/insert/3.cc: Likewise.\n+        * testsuite/23_containers/multiset/modifiers/insert/3.cc: Likewise.\n+        * testsuite/23_containers/multiset/modifiers/insert/4.cc: Likewise.\n+        * testsuite/23_containers/map/modifiers/insert/2.cc: Likewise.\n+        * testsuite/23_containers/map/modifiers/insert/3.cc: Likewise.\n+        * testsuite/23_containers/map/modifiers/insert/4.cc: Likewise.\n+        * testsuite/23_containers/map/modifiers/insert/5.cc: Likewise.\n+        * testsuite/23_containers/map/element_access/2.cc: Likewise.\n+        * testsuite/23_containers/map/element_access/46148.cc: Likewise.\n+\n+        * include/bits/hashtable.h: Trivial naming changes.\n+\n 2010-11-10  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* include/bits/hashtable.h (_Hashtable<>::_Insert_Conv_Type,"}, {"sha": "1f959d9d1c8dd944e8c5f9a892ec912cfac8664c", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=e6a054481d2586056b845639c8e26158169c027f", "patch": "@@ -367,18 +367,18 @@ namespace std\n       _M_find_node(_Node*, const key_type&,\n \t\t   typename _Hashtable::_Hash_code_type) const;\n \n-      template<typename _Pair>\n+      template<typename _Arg>\n         iterator\n-        _M_insert_bucket(_Pair&&, size_type,\n+        _M_insert_bucket(_Arg&&, size_type,\n \t\t\t typename _Hashtable::_Hash_code_type);\n \n-      template<typename _Pair>\n+      template<typename _Arg>\n         std::pair<iterator, bool>\n-        _M_insert(_Pair&&, std::true_type);\n+        _M_insert(_Arg&&, std::true_type);\n \n-      template<typename _Pair>\n+      template<typename _Arg>\n         iterator\n-        _M_insert(_Pair&&, std::false_type);\n+        _M_insert(_Arg&&, std::false_type);\n \n       typedef typename std::conditional<__unique_keys,\n \t\t\t\t\tstd::pair<iterator, bool>,\n@@ -898,13 +898,13 @@ namespace std\n \t   typename _Allocator, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n \t   bool __chc, bool __cit, bool __uk>\n-    template<typename _Pair>\n+    template<typename _Arg>\n       typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n \t\t\t  _H1, _H2, _Hash, _RehashPolicy,\n \t\t\t  __chc, __cit, __uk>::iterator\n       _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n \t\t _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-      _M_insert_bucket(_Pair&& __v, size_type __n,\n+      _M_insert_bucket(_Arg&& __v, size_type __n,\n \t\t       typename _Hashtable::_Hash_code_type __code)\n       {\n \tstd::pair<bool, std::size_t> __do_rehash\n@@ -919,7 +919,7 @@ namespace std\n \n \t// Allocate the new node before doing the rehash so that we don't\n \t// do a rehash if the allocation throws.\n-\t_Node* __new_node = _M_allocate_node(std::forward<_Pair>(__v));\n+\t_Node* __new_node = _M_allocate_node(std::forward<_Arg>(__v));\n \n \t__try\n \t  {\n@@ -946,22 +946,22 @@ namespace std\n \t   typename _Allocator, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n \t   bool __chc, bool __cit, bool __uk>\n-    template<typename _Pair>\n+    template<typename _Arg>\n       std::pair<typename _Hashtable<_Key, _Value, _Allocator,\n \t\t\t\t    _ExtractKey, _Equal, _H1,\n \t\t\t\t    _H2, _Hash, _RehashPolicy,\n \t\t\t\t    __chc, __cit, __uk>::iterator, bool>\n       _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n \t\t _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-      _M_insert(_Pair&& __v, std::true_type)\n+      _M_insert(_Arg&& __v, std::true_type)\n       {\n \tconst key_type& __k = this->_M_extract(__v);\n \ttypename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n \tsize_type __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n \n \tif (_Node* __p = _M_find_node(_M_buckets[__n], __k, __code))\n \t  return std::make_pair(iterator(__p, _M_buckets + __n), false);\n-\treturn std::make_pair(_M_insert_bucket(std::forward<_Pair>(__v),\n+\treturn std::make_pair(_M_insert_bucket(std::forward<_Arg>(__v),\n \t\t\t      __n, __code), true);\n       }\n \n@@ -970,13 +970,13 @@ namespace std\n \t   typename _Allocator, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n \t   bool __chc, bool __cit, bool __uk>\n-    template<typename _Pair>\n+    template<typename _Arg>\n       typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n \t\t\t  _H1, _H2, _Hash, _RehashPolicy,\n \t\t\t  __chc, __cit, __uk>::iterator\n       _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n \t\t _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-      _M_insert(_Pair&& __v, std::false_type)\n+      _M_insert(_Arg&& __v, std::false_type)\n       {\n \tstd::pair<bool, std::size_t> __do_rehash\n \t  = _M_rehash_policy._M_need_rehash(_M_bucket_count,\n@@ -990,7 +990,7 @@ namespace std\n \n \t// First find the node, avoid leaking new_node if compare throws.\n \t_Node* __prev = _M_find_node(_M_buckets[__n], __k, __code);\n-\t_Node* __new_node = _M_allocate_node(std::forward<_Pair>(__v));\n+\t_Node* __new_node = _M_allocate_node(std::forward<_Arg>(__v));\n \n         if (__prev)\n \t  {"}, {"sha": "8add2a452b4cd90880f4ffd6bb3da2359b5365c2", "filename": "libstdc++-v3/include/bits/stl_map.h", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h?ref=e6a054481d2586056b845639c8e26158169c027f", "patch": "@@ -452,6 +452,21 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n \treturn (*__i).second;\n       }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      mapped_type&\n+      operator[](key_type&& __k)\n+      {\n+\t// concept requirements\n+\t__glibcxx_function_requires(_DefaultConstructibleConcept<mapped_type>)\n+\n+\titerator __i = lower_bound(__k);\n+\t// __i->first is greater than or equivalent to __k.\n+\tif (__i == end() || key_comp()(__k, (*__i).first))\n+          __i = insert(__i, std::make_pair(std::move(__k), mapped_type()));\n+\treturn (*__i).second;\n+      }\n+#endif\n+\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // DR 464. Suggestion for new member functions in standard containers.\n       /**\n@@ -500,6 +515,15 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       insert(const value_type& __x)\n       { return _M_t._M_insert_unique(__x); }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      template<typename _Pair, typename = typename\n+\t       std::enable_if<std::is_convertible<_Pair,\n+\t\t\t\t\t\t  value_type>::value>::type>\n+        std::pair<iterator, bool>\n+        insert(_Pair&& __x)\n+        { return _M_t._M_insert_unique(std::forward<_Pair>(__x)); }\n+#endif\n+\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n       /**\n        *  @brief Attempts to insert a list of std::pairs into the %map.\n@@ -544,6 +568,16 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n #endif\n       { return _M_t._M_insert_unique_(__position, __x); }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      template<typename _Pair, typename = typename\n+\t       std::enable_if<std::is_convertible<_Pair,\n+\t\t\t\t\t\t  value_type>::value>::type>\n+        iterator\n+        insert(const_iterator __position, _Pair&& __x)\n+        { return _M_t._M_insert_unique_(__position,\n+\t\t\t\t\tstd::forward<_Pair>(__x)); }\n+#endif\n+\n       /**\n        *  @brief Template function that attempts to insert a range of elements.\n        *  @param  first  Iterator pointing to the start of the range to be"}, {"sha": "ec0c9a080d62cb216ffccbdbc67e894ef68ceb5f", "filename": "libstdc++-v3/include/bits/stl_multimap.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h?ref=e6a054481d2586056b845639c8e26158169c027f", "patch": "@@ -438,6 +438,15 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       insert(const value_type& __x)\n       { return _M_t._M_insert_equal(__x); }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      template<typename _Pair, typename = typename\n+\t       std::enable_if<std::is_convertible<_Pair,\n+\t\t\t\t\t\t  value_type>::value>::type>\n+        iterator\n+        insert(_Pair&& __x)\n+        { return _M_t._M_insert_equal(std::forward<_Pair>(__x)); }\n+#endif\n+\n       /**\n        *  @brief Inserts a std::pair into the %multimap.\n        *  @param  position  An iterator that serves as a hint as to where the\n@@ -466,6 +475,16 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n #endif\n       { return _M_t._M_insert_equal_(__position, __x); }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      template<typename _Pair, typename = typename\n+\t       std::enable_if<std::is_convertible<_Pair,\n+\t\t\t\t\t\t  value_type>::value>::type>\n+        iterator\n+        insert(const_iterator __position, _Pair&& __x)\n+        { return _M_t._M_insert_equal_(__position,\n+\t\t\t\t       std::forward<_Pair>(__x)); }\n+#endif\n+\n       /**\n        *  @brief A template function that attempts to insert a range\n        *  of elements."}, {"sha": "629da6b1ec66a4e097b15c8741c94d8f0e3fb9b6", "filename": "libstdc++-v3/include/bits/stl_multiset.h", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h?ref=e6a054481d2586056b845639c8e26158169c027f", "patch": "@@ -118,7 +118,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       typedef typename _Rep_type::const_iterator            iterator;\n       typedef typename _Rep_type::const_iterator            const_iterator;\n       typedef typename _Rep_type::const_reverse_iterator    reverse_iterator;\n-      typedef typename _Rep_type::const_reverse_iterator    const_reverse_iterator;\n+      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;\n       typedef typename _Rep_type::size_type                 size_type;\n       typedef typename _Rep_type::difference_type           difference_type;\n \n@@ -396,6 +396,12 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       insert(const value_type& __x)\n       { return _M_t._M_insert_equal(__x); }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      iterator\n+      insert(value_type&& __x)\n+      { return _M_t._M_insert_equal(std::move(__x)); }\n+#endif\n+\n       /**\n        *  @brief Inserts an element into the %multiset.\n        *  @param  position  An iterator that serves as a hint as to where the\n@@ -424,6 +430,12 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n #endif\n       { return _M_t._M_insert_equal_(__position, __x); }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      iterator\n+      insert(const_iterator __position, value_type&& __x)\n+      { return _M_t._M_insert_equal_(__position, std::move(__x)); }\n+#endif\n+\n       /**\n        *  @brief A template function that tries to insert a range of elements.\n        *  @param  first  Iterator pointing to the start of the range to be"}, {"sha": "c44b303fa99d8f20cb0058cbba9ad28632384bf4", "filename": "libstdc++-v3/include/bits/stl_set.h", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h?ref=e6a054481d2586056b845639c8e26158169c027f", "patch": "@@ -124,7 +124,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       typedef typename _Rep_type::const_iterator            iterator;\n       typedef typename _Rep_type::const_iterator            const_iterator;\n       typedef typename _Rep_type::const_reverse_iterator    reverse_iterator;\n-      typedef typename _Rep_type::const_reverse_iterator    const_reverse_iterator;\n+      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;\n       typedef typename _Rep_type::size_type                 size_type;\n       typedef typename _Rep_type::difference_type           difference_type;\n       //@}\n@@ -409,6 +409,16 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n \treturn std::pair<iterator, bool>(__p.first, __p.second);\n       }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      std::pair<iterator, bool>\n+      insert(value_type&& __x)\n+      {\n+\tstd::pair<typename _Rep_type::iterator, bool> __p =\n+\t  _M_t._M_insert_unique(std::move(__x));\n+\treturn std::pair<iterator, bool>(__p.first, __p.second);\n+      }\n+#endif\n+\n       /**\n        *  @brief Attempts to insert an element into the %set.\n        *  @param  position  An iterator that serves as a hint as to where the\n@@ -436,6 +446,12 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n #endif\n       { return _M_t._M_insert_unique_(__position, __x); }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      iterator\n+      insert(const_iterator __position, value_type&& __x)\n+      { return _M_t._M_insert_unique_(__position, std::move(__x)); }\n+#endif\n+\n       /**\n        *  @brief A template function that attempts to insert a range\n        *  of elements."}, {"sha": "0974f9173d3785f832d79f0f8e3db4c66289ee0a", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 122, "deletions": 26, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=e6a054481d2586056b845639c8e26158169c027f", "patch": "@@ -561,6 +561,19 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       { return iterator(static_cast<_Link_type>\n \t\t\t(const_cast<_Base_ptr>(__cit._M_node))); }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      template<typename _Arg>\n+        iterator\n+        _M_insert_(_Const_Base_ptr __x, _Const_Base_ptr __y, _Arg&& __v);\n+\n+      template<typename _Arg>\n+        iterator\n+        _M_insert_lower(_Base_ptr __x, _Base_ptr __y, _Arg&& __v);\n+\n+      template<typename _Arg>\n+        iterator\n+        _M_insert_equal_lower(_Arg&& __x);\n+#else\n       iterator\n       _M_insert_(_Const_Base_ptr __x, _Const_Base_ptr __y,\n \t\t const value_type& __v);\n@@ -572,6 +585,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \n       iterator\n       _M_insert_equal_lower(const value_type& __x);\n+#endif\n \n       _Link_type\n       _M_copy(_Const_Link_type __x, _Link_type __p);\n@@ -687,6 +701,23 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       swap(_Rb_tree& __t);      \n \n       // Insert/erase.\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      template<typename _Arg>\n+        pair<iterator, bool>\n+        _M_insert_unique(_Arg&& __x);\n+\n+      template<typename _Arg>\n+        iterator\n+        _M_insert_equal(_Arg&& __x);\n+\n+      template<typename _Arg>\n+        iterator\n+        _M_insert_unique_(const_iterator __position, _Arg&& __x);\n+\n+      template<typename _Arg>\n+        iterator\n+        _M_insert_equal_(const_iterator __position, _Arg&& __x);\n+#else\n       pair<iterator, bool>\n       _M_insert_unique(const value_type& __x);\n \n@@ -698,6 +729,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \n       iterator\n       _M_insert_equal_(const_iterator __position, const value_type& __x);\n+#endif\n \n       template<typename _InputIterator>\n         void\n@@ -901,15 +933,22 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+    template<typename _Arg>\n+#endif\n     typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+    _M_insert_(_Const_Base_ptr __x, _Const_Base_ptr __p, _Arg&& __v)\n+#else\n     _M_insert_(_Const_Base_ptr __x, _Const_Base_ptr __p, const _Val& __v)\n+#endif\n     {\n       bool __insert_left = (__x != 0 || __p == _M_end()\n \t\t\t    || _M_impl._M_key_compare(_KeyOfValue()(__v), \n \t\t\t\t\t\t      _S_key(__p)));\n \n-      _Link_type __z = _M_create_node(__v);\n+      _Link_type __z = _M_create_node(_GLIBCXX_FORWARD(_Arg, __v));\n \n       _Rb_tree_insert_and_rebalance(__insert_left, __z,\n \t\t\t\t    const_cast<_Base_ptr>(__p),  \n@@ -920,15 +959,22 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+    template<typename _Arg>\n+#endif\n     typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+    _M_insert_lower(_Base_ptr __x, _Base_ptr __p, _Arg&& __v)\n+#else\n     _M_insert_lower(_Base_ptr __x, _Base_ptr __p, const _Val& __v)\n+#endif\n     {\n       bool __insert_left = (__x != 0 || __p == _M_end()\n \t\t\t    || !_M_impl._M_key_compare(_S_key(__p),\n \t\t\t\t\t\t       _KeyOfValue()(__v)));\n \n-      _Link_type __z = _M_create_node(__v);\n+      _Link_type __z = _M_create_node(_GLIBCXX_FORWARD(_Arg, __v));\n \n       _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,  \n \t\t\t\t    this->_M_impl._M_header);\n@@ -938,9 +984,16 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+    template<typename _Arg>\n+#endif\n     typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+    _M_insert_equal_lower(_Arg&& __v)\n+#else\n     _M_insert_equal_lower(const _Val& __v)\n+#endif\n     {\n       _Link_type __x = _M_begin();\n       _Link_type __y = _M_end();\n@@ -950,7 +1003,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t  __x = !_M_impl._M_key_compare(_S_key(__x), _KeyOfValue()(__v)) ?\n \t        _S_left(__x) : _S_right(__x);\n \t}\n-      return _M_insert_lower(__x, __y, __v);\n+      return _M_insert_lower(__x, __y, _GLIBCXX_FORWARD(_Arg, __v));\n     }\n \n   template<typename _Key, typename _Val, typename _KoV,\n@@ -1183,10 +1236,17 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+    template<typename _Arg>\n+#endif\n     pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,\n \t\t\t   _Compare, _Alloc>::iterator, bool>\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+    _M_insert_unique(_Arg&& __v)\n+#else\n     _M_insert_unique(const _Val& __v)\n+#endif\n     {\n       _Link_type __x = _M_begin();\n       _Link_type __y = _M_end();\n@@ -1201,20 +1261,29 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       if (__comp)\n \t{\n \t  if (__j == begin())\n-\t    return pair<iterator, bool>(_M_insert_(__x, __y, __v), true);\n+\t    return pair<iterator, bool>\n+\t      (_M_insert_(__x, __y, _GLIBCXX_FORWARD(_Arg, __v)), true);\n \t  else\n \t    --__j;\n \t}\n       if (_M_impl._M_key_compare(_S_key(__j._M_node), _KeyOfValue()(__v)))\n-\treturn pair<iterator, bool>(_M_insert_(__x, __y, __v), true);\n+\treturn pair<iterator, bool>\n+\t  (_M_insert_(__x, __y, _GLIBCXX_FORWARD(_Arg, __v)), true);\n       return pair<iterator, bool>(__j, false);\n     }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+    template<typename _Arg>\n+#endif\n     typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+    _M_insert_equal(_Arg&& __v)\n+#else\n     _M_insert_equal(const _Val& __v)\n+#endif\n     {\n       _Link_type __x = _M_begin();\n       _Link_type __y = _M_end();\n@@ -1224,61 +1293,74 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t  __x = _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__x)) ?\n \t        _S_left(__x) : _S_right(__x);\n \t}\n-      return _M_insert_(__x, __y, __v);\n+      return _M_insert_(__x, __y, _GLIBCXX_FORWARD(_Arg, __v));\n     }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+    template<typename _Arg>\n+#endif\n     typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+    _M_insert_unique_(const_iterator __position, _Arg&& __v)\n+#else\n     _M_insert_unique_(const_iterator __position, const _Val& __v)\n+#endif\n     {\n       // end()\n       if (__position._M_node == _M_end())\n \t{\n \t  if (size() > 0\n \t      && _M_impl._M_key_compare(_S_key(_M_rightmost()), \n \t\t\t\t\t_KeyOfValue()(__v)))\n-\t    return _M_insert_(0, _M_rightmost(), __v);\n+\t    return _M_insert_(0, _M_rightmost(), _GLIBCXX_FORWARD(_Arg, __v));\n \t  else\n-\t    return _M_insert_unique(__v).first;\n+\t    return _M_insert_unique(_GLIBCXX_FORWARD(_Arg, __v)).first;\n \t}\n       else if (_M_impl._M_key_compare(_KeyOfValue()(__v),\n \t\t\t\t      _S_key(__position._M_node)))\n \t{\n \t  // First, try before...\n \t  const_iterator __before = __position;\n \t  if (__position._M_node == _M_leftmost()) // begin()\n-\t    return _M_insert_(_M_leftmost(), _M_leftmost(), __v);\n+\t    return _M_insert_(_M_leftmost(), _M_leftmost(),\n+\t\t\t      _GLIBCXX_FORWARD(_Arg, __v));\n \t  else if (_M_impl._M_key_compare(_S_key((--__before)._M_node), \n \t\t\t\t\t  _KeyOfValue()(__v)))\n \t    {\n \t      if (_S_right(__before._M_node) == 0)\n-\t\treturn _M_insert_(0, __before._M_node, __v);\n+\t\treturn _M_insert_(0, __before._M_node,\n+\t\t\t\t  _GLIBCXX_FORWARD(_Arg, __v));\n \t      else\n \t\treturn _M_insert_(__position._M_node,\n-\t\t\t\t  __position._M_node, __v);\n+\t\t\t\t  __position._M_node,\n+\t\t\t\t  _GLIBCXX_FORWARD(_Arg, __v));\n \t    }\n \t  else\n-\t    return _M_insert_unique(__v).first;\n+\t    return _M_insert_unique(_GLIBCXX_FORWARD(_Arg, __v)).first;\n \t}\n       else if (_M_impl._M_key_compare(_S_key(__position._M_node),\n \t\t\t\t      _KeyOfValue()(__v)))\n \t{\n \t  // ... then try after.\n \t  const_iterator __after = __position;\n \t  if (__position._M_node == _M_rightmost())\n-\t    return _M_insert_(0, _M_rightmost(), __v);\n+\t    return _M_insert_(0, _M_rightmost(),\n+\t\t\t      _GLIBCXX_FORWARD(_Arg, __v));\n \t  else if (_M_impl._M_key_compare(_KeyOfValue()(__v),\n \t\t\t\t\t  _S_key((++__after)._M_node)))\n \t    {\n \t      if (_S_right(__position._M_node) == 0)\n-\t\treturn _M_insert_(0, __position._M_node, __v);\n+\t\treturn _M_insert_(0, __position._M_node,\n+\t\t\t\t  _GLIBCXX_FORWARD(_Arg, __v));\n \t      else\n-\t\treturn _M_insert_(__after._M_node, __after._M_node, __v);\n+\t\treturn _M_insert_(__after._M_node, __after._M_node,\n+\t\t\t\t  _GLIBCXX_FORWARD(_Arg, __v));\n \t    }\n \t  else\n-\t    return _M_insert_unique(__v).first;\n+\t    return _M_insert_unique(_GLIBCXX_FORWARD(_Arg, __v)).first;\n \t}\n       else\n \t// Equivalent keys.\n@@ -1287,55 +1369,69 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+    template<typename _Arg>\n+#endif\n     typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+    _M_insert_equal_(const_iterator __position, _Arg&& __v)\n+#else\n     _M_insert_equal_(const_iterator __position, const _Val& __v)\n+#endif\n     {\n       // end()\n       if (__position._M_node == _M_end())\n \t{\n \t  if (size() > 0\n \t      && !_M_impl._M_key_compare(_KeyOfValue()(__v),\n \t\t\t\t\t _S_key(_M_rightmost())))\n-\t    return _M_insert_(0, _M_rightmost(), __v);\n+\t    return _M_insert_(0, _M_rightmost(),\n+\t\t\t      _GLIBCXX_FORWARD(_Arg, __v));\n \t  else\n-\t    return _M_insert_equal(__v);\n+\t    return _M_insert_equal(_GLIBCXX_FORWARD(_Arg, __v));\n \t}\n       else if (!_M_impl._M_key_compare(_S_key(__position._M_node),\n \t\t\t\t       _KeyOfValue()(__v)))\n \t{\n \t  // First, try before...\n \t  const_iterator __before = __position;\n \t  if (__position._M_node == _M_leftmost()) // begin()\n-\t    return _M_insert_(_M_leftmost(), _M_leftmost(), __v);\n+\t    return _M_insert_(_M_leftmost(), _M_leftmost(),\n+\t\t\t      _GLIBCXX_FORWARD(_Arg, __v));\n \t  else if (!_M_impl._M_key_compare(_KeyOfValue()(__v),\n \t\t\t\t\t   _S_key((--__before)._M_node)))\n \t    {\n \t      if (_S_right(__before._M_node) == 0)\n-\t\treturn _M_insert_(0, __before._M_node, __v);\n+\t\treturn _M_insert_(0, __before._M_node,\n+\t\t\t\t  _GLIBCXX_FORWARD(_Arg, __v));\n \t      else\n \t\treturn _M_insert_(__position._M_node,\n-\t\t\t\t  __position._M_node, __v);\n+\t\t\t\t  __position._M_node,\n+\t\t\t\t  _GLIBCXX_FORWARD(_Arg, __v));\n \t    }\n \t  else\n-\t    return _M_insert_equal(__v);\n+\t    return _M_insert_equal(_GLIBCXX_FORWARD(_Arg, __v));\n \t}\n       else\n \t{\n \t  // ... then try after.  \n \t  const_iterator __after = __position;\n \t  if (__position._M_node == _M_rightmost())\n-\t    return _M_insert_(0, _M_rightmost(), __v);\n+\t    return _M_insert_(0, _M_rightmost(),\n+\t\t\t      _GLIBCXX_FORWARD(_Arg, __v));\n \t  else if (!_M_impl._M_key_compare(_S_key((++__after)._M_node),\n \t\t\t\t\t   _KeyOfValue()(__v)))\n \t    {\n \t      if (_S_right(__position._M_node) == 0)\n-\t\treturn _M_insert_(0, __position._M_node, __v);\n+\t\treturn _M_insert_(0, __position._M_node,\n+\t\t\t\t  _GLIBCXX_FORWARD(_Arg, __v));\n \t      else\n-\t\treturn _M_insert_(__after._M_node, __after._M_node, __v);\n+\t\treturn _M_insert_(__after._M_node, __after._M_node,\n+\t\t\t\t  _GLIBCXX_FORWARD(_Arg, __v));\n \t    }\n \t  else\n-\t    return _M_insert_equal_lower(__v);\n+\t    return _M_insert_equal_lower(_GLIBCXX_FORWARD(_Arg, __v));\n \t}\n     }\n "}, {"sha": "aa5f6121468802ff8654e3ae3e81abbcf06c2b60", "filename": "libstdc++-v3/include/debug/map.h", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmap.h?ref=e6a054481d2586056b845639c8e26158169c027f", "patch": "@@ -210,6 +210,21 @@ namespace __debug\n \t\t\t\t\t __res.second);\n       }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      template<typename _Pair, typename = typename\n+\t       std::enable_if<std::is_convertible<_Pair,\n+\t\t\t\t\t\t  value_type>::value>::type>\n+        std::pair<iterator, bool>\n+        insert(_Pair&& __x)\n+        {\n+\t  typedef typename _Base::iterator _Base_iterator;\n+\t  std::pair<_Base_iterator, bool> __res\n+\t    = _Base::insert(std::forward<_Pair>(__x));\n+\t  return std::pair<iterator, bool>(iterator(__res.first, this),\n+\t\t\t\t\t   __res.second);\n+\t}\n+#endif\n+\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n       void\n       insert(std::initializer_list<value_type> __list)\n@@ -223,6 +238,19 @@ namespace __debug\n \treturn iterator(_Base::insert(__position.base(), __x), this);\n       }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      template<typename _Pair, typename = typename\n+\t       std::enable_if<std::is_convertible<_Pair,\n+\t\t\t\t\t\t  value_type>::value>::type>\n+        iterator\n+        insert(const_iterator __position, _Pair&& __x)\n+        {\n+\t  __glibcxx_check_insert(__position);\n+\t  return iterator(_Base::insert(__position.base(),\n+\t\t\t\t\tstd::forward<_Pair>(__x)), this);\n+\t}\n+#endif\n+\n       template<typename _InputIterator>\n         void\n         insert(_InputIterator __first, _InputIterator __last)"}, {"sha": "c3363b89f474dfa304fee761aa6dbbf3d0303344", "filename": "libstdc++-v3/include/debug/multimap.h", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultimap.h?ref=e6a054481d2586056b845639c8e26158169c027f", "patch": "@@ -197,6 +197,15 @@ namespace __debug\n       insert(const value_type& __x)\n       { return iterator(_Base::insert(__x), this); }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      template<typename _Pair, typename = typename\n+\t       std::enable_if<std::is_convertible<_Pair,\n+\t\t\t\t\t\t  value_type>::value>::type>\n+        iterator\n+        insert(_Pair&& __x)\n+        { return iterator(_Base::insert(std::forward<_Pair>(__x)), this); }\n+#endif\n+\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n       void\n       insert(std::initializer_list<value_type> __list)\n@@ -210,6 +219,19 @@ namespace __debug\n \treturn iterator(_Base::insert(__position.base(), __x), this);\n       }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      template<typename _Pair, typename = typename\n+\t       std::enable_if<std::is_convertible<_Pair,\n+\t\t\t\t\t\t  value_type>::value>::type>\n+        iterator\n+        insert(const_iterator __position, _Pair&& __x)\n+        {\n+\t  __glibcxx_check_insert(__position);\n+\t  return iterator(_Base::insert(__position.base(),\n+\t\t\t\t\tstd::forward<_Pair>(__x)), this);\n+\t}\n+#endif\n+\n       template<typename _InputIterator>\n         void\n         insert(_InputIterator __first, _InputIterator __last)"}, {"sha": "76300cd8829b262a05d7f93a8e80d16005e6f621", "filename": "libstdc++-v3/include/debug/multiset.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultiset.h?ref=e6a054481d2586056b845639c8e26158169c027f", "patch": "@@ -194,13 +194,29 @@ namespace __debug\n       insert(const value_type& __x)\n       { return iterator(_Base::insert(__x), this); }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      iterator\n+      insert(value_type&& __x)\n+      { return iterator(_Base::insert(std::move(__x)), this); }\n+#endif\n+\n       iterator\n       insert(iterator __position, const value_type& __x)\n       {\n \t__glibcxx_check_insert(__position);\n \treturn iterator(_Base::insert(__position.base(), __x), this);\n       }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      iterator\n+      insert(const_iterator __position, value_type&& __x)\n+      {\n+\t__glibcxx_check_insert(__position);\n+\treturn iterator(_Base::insert(__position.base(), std::move(__x)),\n+\t\t\tthis);\n+      }\n+#endif\n+\n       template<typename _InputIterator>\n \tvoid\n \tinsert(_InputIterator __first, _InputIterator __last)"}, {"sha": "6b4dd6ce0eb3f2250dc6dfc63bac7402be78a57e", "filename": "libstdc++-v3/include/debug/set.h", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fset.h?ref=e6a054481d2586056b845639c8e26158169c027f", "patch": "@@ -199,13 +199,35 @@ namespace __debug\n \t\t\t\t\t __res.second);\n       }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      std::pair<iterator, bool>\n+      insert(value_type&& __x)\n+      {\n+\ttypedef typename _Base::iterator _Base_iterator;\n+\tstd::pair<_Base_iterator, bool> __res\n+\t  = _Base::insert(std::move(__x));\n+\treturn std::pair<iterator, bool>(iterator(__res.first, this),\n+\t\t\t\t\t __res.second);\n+      }\n+#endif\n+\n       iterator\n       insert(iterator __position, const value_type& __x)\n       {\n \t__glibcxx_check_insert(__position);\n \treturn iterator(_Base::insert(__position.base(), __x), this);\n       }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      iterator\n+      insert(const_iterator __position, value_type&& __x)\n+      {\n+\t__glibcxx_check_insert(__position);\n+\treturn iterator(_Base::insert(__position.base(), std::move(__x)),\n+\t\t\tthis);\n+      }\n+#endif\n+\n       template <typename _InputIterator>\n         void\n         insert(_InputIterator __first, _InputIterator __last)"}, {"sha": "555f43863498ba4b11f20e40e40a0ba4beb0f1c4", "filename": "libstdc++-v3/include/profile/map.h", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fmap.h?ref=e6a054481d2586056b845639c8e26158169c027f", "patch": "@@ -219,6 +219,15 @@ namespace __profile\n         return _Base::operator[](__k);\n       }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      mapped_type&\n+      operator[](key_type&& __k)\n+      {\n+        __profcxx_map_to_unordered_map_find(this, size());\n+        return _Base::operator[](std::move(__k));\n+      }\n+#endif\n+\n       mapped_type&\n       at(const key_type& __k)\n       {\n@@ -244,6 +253,22 @@ namespace __profile\n \t\t\t\t\t __res.second);\n       }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      template<typename _Pair, typename = typename\n+\t       std::enable_if<std::is_convertible<_Pair,\n+\t\t\t\t\t\t  value_type>::value>::type>\n+        std::pair<iterator, bool>\n+        insert(_Pair&& __x)\n+        {\n+\t  __profcxx_map_to_unordered_map_insert(this, size(), 1);\n+\t  typedef typename _Base::iterator _Base_iterator;\n+\t  std::pair<_Base_iterator, bool> __res\n+\t    = _Base::insert(std::forward<_Pair>(__x));\n+\t  return std::pair<iterator, bool>(iterator(__res.first),\n+\t\t\t\t\t   __res.second);\n+\t}\n+#endif\n+\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n       void\n       insert(std::initializer_list<value_type> __list)\n@@ -269,6 +294,22 @@ namespace __profile\n \treturn __i;\n       }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      template<typename _Pair, typename = typename\n+\t       std::enable_if<std::is_convertible<_Pair,\n+\t\t\t\t\t\t  value_type>::value>::type>\n+        iterator\n+        insert(const_iterator __position, _Pair&& __x)\n+        {\n+\t  size_type size_before = size();\n+\t  iterator __i\n+\t    = iterator(_Base::insert(__position, std::forward<_Pair>(__x)));\n+\t  __profcxx_map_to_unordered_map_insert(this, size_before, \n+\t\t\t\t\t\tsize() - size_before);\n+\t  return __i;\n+      }\n+#endif\n+\n       template<typename _InputIterator>\n         void\n         insert(_InputIterator __first, _InputIterator __last)"}, {"sha": "7f1db940b89aca9cd7d223980702b10c913dfa8a", "filename": "libstdc++-v3/include/profile/multimap.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fmultimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fmultimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fmultimap.h?ref=e6a054481d2586056b845639c8e26158169c027f", "patch": "@@ -185,6 +185,15 @@ namespace __profile\n       insert(const value_type& __x)\n       { return iterator(_Base::insert(__x)); }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      template<typename _Pair, typename = typename\n+\t       std::enable_if<std::is_convertible<_Pair,\n+\t\t\t\t\t\t  value_type>::value>::type>\n+        iterator\n+        insert(_Pair&& __x)\n+        { return iterator(_Base::insert(std::forward<_Pair>(__x))); }\n+#endif\n+\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n       void\n       insert(std::initializer_list<value_type> __list)\n@@ -199,6 +208,16 @@ namespace __profile\n #endif\n       { return iterator(_Base::insert(__position, __x)); }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      template<typename _Pair, typename = typename\n+\t       std::enable_if<std::is_convertible<_Pair,\n+\t\t\t\t\t\t  value_type>::value>::type>\n+        iterator\n+        insert(const_iterator __position, _Pair&& __x)\n+        { return iterator(_Base::insert(__position,\n+\t\t\t\t\tstd::forward<_Pair>(__x))); }\n+#endif\n+\n       template<typename _InputIterator>\n         void\n         insert(_InputIterator __first, _InputIterator __last)"}, {"sha": "d42a75530334d2835b37cbeddd63504aea1afbdd", "filename": "libstdc++-v3/include/profile/multiset.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fmultiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fmultiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fmultiset.h?ref=e6a054481d2586056b845639c8e26158169c027f", "patch": "@@ -183,6 +183,12 @@ namespace __profile\n       insert(const value_type& __x)\n       { return iterator(_Base::insert(__x)); }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      iterator\n+      insert(value_type&& __x)\n+      { return iterator(_Base::insert(std::move(__x))); }\n+#endif\n+\n       iterator\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n       insert(const_iterator __position, const value_type& __x)\n@@ -191,6 +197,12 @@ namespace __profile\n #endif\n       { return iterator(_Base::insert(__position, __x)); }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      iterator\n+      insert(const_iterator __position, value_type&& __x)\n+      { return iterator(_Base::insert(__position, std::move(__x))); }\n+#endif\n+\n       template<typename _InputIterator>\n         void\n         insert(_InputIterator __first, _InputIterator __last)"}, {"sha": "8fb489619742e300c09ea340f9405ed5fa6e5699", "filename": "libstdc++-v3/include/profile/set.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fset.h?ref=e6a054481d2586056b845639c8e26158169c027f", "patch": "@@ -188,6 +188,18 @@ namespace __profile\n \t\t\t\t\t __res.second);\n       }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      std::pair<iterator, bool>\n+      insert(value_type&& __x)\n+      {\n+\ttypedef typename _Base::iterator _Base_iterator;\n+\tstd::pair<_Base_iterator, bool> __res\n+\t  = _Base::insert(std::move(__x));\n+\treturn std::pair<iterator, bool>(iterator(__res.first),\n+\t\t\t\t\t __res.second);\n+      }\n+#endif\n+\n       iterator\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n       insert(const_iterator __position, const value_type& __x)\n@@ -196,6 +208,12 @@ namespace __profile\n #endif\n       { return iterator(_Base::insert(__position, __x)); }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      iterator\n+      insert(const_iterator __position, value_type&& __x)\n+      { return iterator(_Base::insert(__position, std::move(__x))); }\n+#endif\n+\n       template <typename _InputIterator>\n         void\n         insert(_InputIterator __first, _InputIterator __last)"}, {"sha": "8f42066d02cff31b7d10155ff6a46bac14896c5d", "filename": "libstdc++-v3/testsuite/23_containers/map/element_access/2.cc", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Felement_access%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Felement_access%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Felement_access%2F2.cc?ref=e6a054481d2586056b845639c8e26158169c027f", "patch": "@@ -0,0 +1,57 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2010-11-10  Paolo Carlini  <paolo.carlini@oracle.com> \n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <iterator>\n+#include <map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_rvalref.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using __gnu_test::rvalstruct;\n+\n+  typedef std::map<rvalstruct, rvalstruct> Map;\n+\n+  Map m;\n+  VERIFY( m.empty() );\n+\n+  m[rvalstruct(1)] = rvalstruct(17);\n+  VERIFY( m.size() == 1 );\n+  VERIFY( (m.begin()->first).val == 1 );\n+  VERIFY( (m.begin()->second).val == 17 );\n+  VERIFY( m[rvalstruct(1)].val == 17 );\n+\n+  m[rvalstruct(2)] = rvalstruct(9);\n+  VERIFY( m.size() == 2 );\n+  VERIFY( m[rvalstruct(2)].val == 9 );\n+\n+  m[rvalstruct(1)] = rvalstruct(5);\n+  VERIFY( m.size() == 2 );\n+  VERIFY( m[rvalstruct(1)].val == 5 );\n+  VERIFY( m[rvalstruct(2)].val == 9 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "d63f08b85c612b27856acdf76c2311c9c62843c2", "filename": "libstdc++-v3/testsuite/23_containers/map/element_access/46148.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Felement_access%2F46148.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Felement_access%2F46148.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Felement_access%2F46148.cc?ref=e6a054481d2586056b845639c8e26158169c027f", "patch": "@@ -0,0 +1,37 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <map>\n+\n+class moveable\n+{\n+public:\n+  moveable(moveable&&) { }\n+  moveable() { }\n+\n+  operator int()\n+  { return 0; }\n+};    \n+\n+// libstdc++/46148\n+int main()\n+{\n+  std::map<bool,moveable> the_map;\n+  return the_map[true];\n+}"}, {"sha": "5de89de54ab99269a3195d62b7bd36b4ea97b86e", "filename": "libstdc++-v3/testsuite/23_containers/map/modifiers/insert/2.cc", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fmodifiers%2Finsert%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fmodifiers%2Finsert%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fmodifiers%2Finsert%2F2.cc?ref=e6a054481d2586056b845639c8e26158169c027f", "patch": "@@ -0,0 +1,74 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2010-11-10  Paolo Carlini  <paolo.carlini@oracle.com> \n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <iterator>\n+#include <map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_rvalref.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using __gnu_test::rvalstruct;\n+\n+  typedef std::map<int, rvalstruct> Map;\n+  typedef std::pair<const int, rvalstruct> Pair;\n+\n+  Map m;\n+  VERIFY( m.empty());\n+\n+  std::pair<Map::iterator, bool> p = m.insert(Pair(1, rvalstruct(3)));\n+  VERIFY( p.second );\n+  VERIFY( m.size() == 1 );\n+  VERIFY( std::distance(m.begin(), m.end()) == 1 );\n+  VERIFY( p.first == m.begin() );\n+  VERIFY( p.first->first == 1 );\n+  VERIFY( (p.first->second).val == 3 );\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using __gnu_test::rvalstruct;\n+\n+  typedef std::map<int, rvalstruct> Map;\n+  typedef std::pair<const int, rvalstruct> Pair;\n+\n+  Map m;\n+  VERIFY( m.empty() );\n+\n+  std::pair<Map::iterator, bool> p1 = m.insert(Pair(2, rvalstruct(3)));\n+  std::pair<Map::iterator, bool> p2 = m.insert(Pair(2, rvalstruct(7)));\n+\n+  VERIFY( p1.second );\n+  VERIFY( !p2.second );\n+  VERIFY( m.size() == 1 );\n+  VERIFY( p1.first == p2.first );\n+  VERIFY( p1.first->first == 2 );\n+  VERIFY( (p2.first->second).val == 3 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "e5827bfb3b7da54323e1365bf3d43b6fdaf3058a", "filename": "libstdc++-v3/testsuite/23_containers/map/modifiers/insert/3.cc", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fmodifiers%2Finsert%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fmodifiers%2Finsert%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fmodifiers%2Finsert%2F3.cc?ref=e6a054481d2586056b845639c8e26158169c027f", "patch": "@@ -0,0 +1,77 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2010-11-10  Paolo Carlini  <paolo.carlini@oracle.com> \n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <iterator>\n+#include <map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_rvalref.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using __gnu_test::rvalstruct;\n+\n+  typedef std::map<rvalstruct, rvalstruct> Map;\n+  typedef std::pair<rvalstruct, rvalstruct> Pair;\n+\n+  Map m;\n+  VERIFY( m.empty());\n+\n+  std::pair<Map::iterator, bool> p = m.insert(Pair(rvalstruct(1),\n+\t\t\t\t\t\t   rvalstruct(3)));\n+  VERIFY( p.second );\n+  VERIFY( m.size() == 1 );\n+  VERIFY( std::distance(m.begin(), m.end()) == 1 );\n+  VERIFY( p.first == m.begin() );\n+  VERIFY( (p.first->first).val == 1 );\n+  VERIFY( (p.first->second).val == 3 );\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using __gnu_test::rvalstruct;\n+\n+  typedef std::map<rvalstruct, rvalstruct> Map;\n+  typedef std::pair<rvalstruct, rvalstruct> Pair;\n+\n+  Map m;\n+  VERIFY( m.empty() );\n+\n+  std::pair<Map::iterator, bool> p1 = m.insert(Pair(rvalstruct(2),\n+\t\t\t\t\t\t    rvalstruct(3)));\n+  std::pair<Map::iterator, bool> p2 = m.insert(Pair(rvalstruct(2),\n+\t\t\t\t\t\t    rvalstruct(7)));\n+\n+  VERIFY( p1.second );\n+  VERIFY( !p2.second );\n+  VERIFY( m.size() == 1 );\n+  VERIFY( p1.first == p2.first );\n+  VERIFY( (p1.first->first).val == 2 );\n+  VERIFY( (p2.first->second).val == 3 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "28eba647244756efd4e07e986d2208638060c57a", "filename": "libstdc++-v3/testsuite/23_containers/map/modifiers/insert/4.cc", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fmodifiers%2Finsert%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fmodifiers%2Finsert%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fmodifiers%2Finsert%2F4.cc?ref=e6a054481d2586056b845639c8e26158169c027f", "patch": "@@ -0,0 +1,70 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2010-11-10  Paolo Carlini  <paolo.carlini@oracle.com> \n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <iterator>\n+#include <map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_rvalref.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using __gnu_test::rvalstruct;\n+\n+  typedef std::map<int, rvalstruct> Map;\n+  typedef std::pair<const int, rvalstruct> Pair;\n+\n+  Map m;\n+  VERIFY( m.empty());\n+\n+  Map::iterator p = m.insert(m.begin(), Pair(1, rvalstruct(3)));\n+  VERIFY( m.size() == 1 );\n+  VERIFY( std::distance(m.begin(), m.end()) == 1 );\n+  VERIFY( p == m.begin() );\n+  VERIFY( p->first == 1 );\n+  VERIFY( (p->second).val == 3 );\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using __gnu_test::rvalstruct;\n+\n+  typedef std::map<int, rvalstruct> Map;\n+  typedef std::pair<const int, rvalstruct> Pair;\n+\n+  Map m;\n+  VERIFY( m.empty() );\n+\n+  Map::iterator p1 = m.insert(m.begin(), Pair(2, rvalstruct(3)));\n+  Map::iterator p2 = m.insert(p1, Pair(2, rvalstruct(7)));\n+  VERIFY( m.size() == 1 );\n+  VERIFY( p1 == p2 );\n+  VERIFY( p1->first == 2 );\n+  VERIFY( (p2->second).val == 3 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "3dc153b851a05f6e930213fb90908f4e83b30978", "filename": "libstdc++-v3/testsuite/23_containers/map/modifiers/insert/5.cc", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fmodifiers%2Finsert%2F5.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fmodifiers%2Finsert%2F5.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fmodifiers%2Finsert%2F5.cc?ref=e6a054481d2586056b845639c8e26158169c027f", "patch": "@@ -0,0 +1,73 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2010-11-10  Paolo Carlini  <paolo.carlini@oracle.com> \n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <iterator>\n+#include <map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_rvalref.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using __gnu_test::rvalstruct;\n+\n+  typedef std::map<rvalstruct, rvalstruct> Map;\n+  typedef std::pair<rvalstruct, rvalstruct> Pair;\n+\n+  Map m;\n+  VERIFY( m.empty());\n+\n+  Map::iterator p = m.insert(m.begin(), Pair(rvalstruct(1),\n+\t\t\t\t\t     rvalstruct(3)));\n+  VERIFY( m.size() == 1 );\n+  VERIFY( std::distance(m.begin(), m.end()) == 1 );\n+  VERIFY( p == m.begin() );\n+  VERIFY( (p->first).val == 1 );\n+  VERIFY( (p->second).val == 3 );\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using __gnu_test::rvalstruct;\n+\n+  typedef std::map<rvalstruct, rvalstruct> Map;\n+  typedef std::pair<rvalstruct, rvalstruct> Pair;\n+\n+  Map m;\n+  VERIFY( m.empty() );\n+\n+  Map::iterator p1 = m.insert(m.begin(), Pair(rvalstruct(2),\n+\t\t\t\t\t      rvalstruct(3)));\n+  Map::iterator p2 = m.insert(p1, Pair(rvalstruct(2),\n+\t\t\t\t       rvalstruct(7)));\n+  VERIFY( m.size() == 1 );\n+  VERIFY( p1 == p2 );\n+  VERIFY( (p1->first).val == 2 );\n+  VERIFY( (p2->second).val == 3 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "f07e97d7deb0bd86b3d4f55b164e67f532d6d2f5", "filename": "libstdc++-v3/testsuite/23_containers/multimap/modifiers/insert/1.cc", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fmodifiers%2Finsert%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fmodifiers%2Finsert%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fmodifiers%2Finsert%2F1.cc?ref=e6a054481d2586056b845639c8e26158169c027f", "patch": "@@ -0,0 +1,77 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2010-11-10  Paolo Carlini  <paolo.carlini@oracle.com> \n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <iterator>\n+#include <map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_rvalref.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using __gnu_test::rvalstruct;\n+\n+  typedef std::multimap<int, rvalstruct> Map;\n+  typedef std::pair<const int, rvalstruct> Pair;\n+\n+  Map m;\n+  VERIFY( m.empty() );\n+\n+  Map::iterator i = m.insert(Pair(1, rvalstruct(3)));\n+  VERIFY( m.size() == 1 );\n+  VERIFY( std::distance(m.begin(), m.end()) == 1 );\n+  VERIFY( i == m.begin() );\n+  VERIFY( i->first == 1 );\n+  VERIFY( (i->second).val == 3 );\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using __gnu_test::rvalstruct;\n+\n+  typedef std::multimap<int, rvalstruct> Map;\n+  typedef std::pair<const int, rvalstruct> Pair;\n+\n+  Map m;\n+  VERIFY( m.empty() );\n+\n+  m.insert(Pair(2, rvalstruct(3)));\n+  m.insert(Pair(2, rvalstruct(7)));\n+\n+  VERIFY( m.size() == 2 );\n+  VERIFY( std::distance(m.begin(), m.end()) == 2 );\n+\n+  Map::iterator i1 = m.begin();\n+  Map::iterator i2 = i1;\n+  ++i2;\n+\n+  VERIFY( i1->first == 2 );\n+  VERIFY( i2->first == 2 );\n+  VERIFY( (i1->second).val == 3 && (i2->second).val == 7 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "56453cadeefb88237938f97845af95d52be5f611", "filename": "libstdc++-v3/testsuite/23_containers/multimap/modifiers/insert/2.cc", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fmodifiers%2Finsert%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fmodifiers%2Finsert%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fmodifiers%2Finsert%2F2.cc?ref=e6a054481d2586056b845639c8e26158169c027f", "patch": "@@ -0,0 +1,77 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2010-11-10  Paolo Carlini  <paolo.carlini@oracle.com>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <iterator>\n+#include <map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_rvalref.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using __gnu_test::rvalstruct;\n+\n+  typedef std::multimap<rvalstruct, rvalstruct> Map;\n+  typedef std::pair<rvalstruct, rvalstruct> Pair;\n+\n+  Map m;\n+  VERIFY( m.empty() );\n+\n+  Map::iterator i = m.insert(Pair(rvalstruct(1), rvalstruct(3)));\n+  VERIFY( m.size() == 1 );\n+  VERIFY( std::distance(m.begin(), m.end()) == 1 );\n+  VERIFY( i == m.begin() );\n+  VERIFY( (i->first).val == 1 );\n+  VERIFY( (i->second).val == 3 );\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using __gnu_test::rvalstruct;\n+\n+  typedef std::multimap<rvalstruct, rvalstruct> Map;\n+  typedef std::pair<rvalstruct, rvalstruct> Pair;\n+\n+  Map m;\n+  VERIFY( m.empty() );\n+\n+  m.insert(Pair(rvalstruct(2), rvalstruct(3)));\n+  m.insert(Pair(rvalstruct(2), rvalstruct(7)));\n+\n+  VERIFY( m.size() == 2 );\n+  VERIFY( std::distance(m.begin(), m.end()) == 2 );\n+\n+  Map::iterator i1 = m.begin();\n+  Map::iterator i2 = i1;\n+  ++i2;\n+\n+  VERIFY( (i1->first).val == 2 );\n+  VERIFY( (i2->first).val == 2 );\n+  VERIFY( (i1->second).val == 3 && (i2->second).val == 7 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "dddd8c8855f0bea30937b6abc3127dafe4ef7d58", "filename": "libstdc++-v3/testsuite/23_containers/multimap/modifiers/insert/3.cc", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fmodifiers%2Finsert%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fmodifiers%2Finsert%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fmodifiers%2Finsert%2F3.cc?ref=e6a054481d2586056b845639c8e26158169c027f", "patch": "@@ -0,0 +1,77 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2010-11-10  Paolo Carlini  <paolo.carlini@oracle.com> \n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <iterator>\n+#include <map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_rvalref.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using __gnu_test::rvalstruct;\n+\n+  typedef std::multimap<int, rvalstruct> Map;\n+  typedef std::pair<const int, rvalstruct> Pair;\n+\n+  Map m;\n+  VERIFY( m.empty() );\n+\n+  Map::iterator i = m.insert(m.begin(), Pair(1, rvalstruct(3)));\n+  VERIFY( m.size() == 1 );\n+  VERIFY( std::distance(m.begin(), m.end()) == 1 );\n+  VERIFY( i == m.begin() );\n+  VERIFY( i->first == 1 );\n+  VERIFY( (i->second).val == 3 );\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using __gnu_test::rvalstruct;\n+\n+  typedef std::multimap<int, rvalstruct> Map;\n+  typedef std::pair<const int, rvalstruct> Pair;\n+\n+  Map m;\n+  VERIFY( m.empty() );\n+\n+  Map::iterator i0 = m.insert(m.begin(), Pair(2, rvalstruct(3)));\n+  m.insert(i0, Pair(2, rvalstruct(7)));\n+\n+  VERIFY( m.size() == 2 );\n+  VERIFY( std::distance(m.begin(), m.end()) == 2 );\n+\n+  Map::iterator i1 = m.begin();\n+  Map::iterator i2 = i1;\n+  ++i2;\n+\n+  VERIFY( i1->first == 2 );\n+  VERIFY( i2->first == 2 );\n+  VERIFY( (i1->second).val == 7 && (i2->second).val == 3 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "a53852cc17f5e8bdb34ab9a7cdd3e61694496cc1", "filename": "libstdc++-v3/testsuite/23_containers/multimap/modifiers/insert/4.cc", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fmodifiers%2Finsert%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fmodifiers%2Finsert%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fmodifiers%2Finsert%2F4.cc?ref=e6a054481d2586056b845639c8e26158169c027f", "patch": "@@ -0,0 +1,78 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2010-11-10  Paolo Carlini  <paolo.carlini@oracle.com>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <iterator>\n+#include <map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_rvalref.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using __gnu_test::rvalstruct;\n+\n+  typedef std::multimap<rvalstruct, rvalstruct> Map;\n+  typedef std::pair<rvalstruct, rvalstruct> Pair;\n+\n+  Map m;\n+  VERIFY( m.empty() );\n+\n+  Map::iterator i = m.insert(m.begin(),\n+\t\t\t     Pair(rvalstruct(1), rvalstruct(3)));\n+  VERIFY( m.size() == 1 );\n+  VERIFY( std::distance(m.begin(), m.end()) == 1 );\n+  VERIFY( i == m.begin() );\n+  VERIFY( (i->first).val == 1 );\n+  VERIFY( (i->second).val == 3 );\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using __gnu_test::rvalstruct;\n+\n+  typedef std::multimap<rvalstruct, rvalstruct> Map;\n+  typedef std::pair<rvalstruct, rvalstruct> Pair;\n+\n+  Map m;\n+  VERIFY( m.empty() );\n+\n+  Map::iterator i0 = m.insert(Pair(rvalstruct(2), rvalstruct(3)));\n+  m.insert(i0, Pair(rvalstruct(2), rvalstruct(7)));\n+\n+  VERIFY( m.size() == 2 );\n+  VERIFY( std::distance(m.begin(), m.end()) == 2 );\n+\n+  Map::iterator i1 = m.begin();\n+  Map::iterator i2 = i1;\n+  ++i2;\n+\n+  VERIFY( (i1->first).val == 2 );\n+  VERIFY( (i2->first).val == 2 );\n+  VERIFY( (i1->second).val == 7 && (i2->second).val == 3 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "202d2eec0750e6108f437f74724d920ce9adcd99", "filename": "libstdc++-v3/testsuite/23_containers/multiset/modifiers/insert/3.cc", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fmodifiers%2Finsert%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fmodifiers%2Finsert%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fmodifiers%2Finsert%2F3.cc?ref=e6a054481d2586056b845639c8e26158169c027f", "patch": "@@ -0,0 +1,69 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2010-11-10  Paolo Carlini  <paolo.carlini@oracle.com> \n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <iterator>\n+#include <set>\n+#include <testsuite_hooks.h>\n+#include <testsuite_rvalref.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using __gnu_test::rvalstruct;\n+\n+  typedef std::multiset<rvalstruct> Set;\n+  Set s;\n+  VERIFY( s.empty() );\n+\n+  Set::iterator i = s.insert(rvalstruct(1));\n+  VERIFY( s.size() == 1 );\n+  VERIFY( std::distance(s.begin(), s.end()) == 1 );\n+  VERIFY( i == s.begin() );\n+  VERIFY( (*i).val == 1 );\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using __gnu_test::rvalstruct;\n+\n+  typedef std::multiset<rvalstruct> Set;\n+  Set s;\n+  VERIFY( s.empty() );\n+\n+  s.insert(rvalstruct(2));\n+  Set::iterator i = s.insert(rvalstruct(2));\n+  VERIFY( s.size() == 2 );\n+  VERIFY( std::distance(s.begin(), s.end()) == 2 );\n+  VERIFY( (*i).val == 2 );\n+  \n+  Set::iterator i2 = s.begin();\n+  ++i2;\n+  VERIFY( i == s.begin() || i == i2 );\n+  VERIFY( (*(s.begin())).val == 2 && (*i2).val == 2 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "eccf18f474cc6e3462200c92ba37408b13907df3", "filename": "libstdc++-v3/testsuite/23_containers/multiset/modifiers/insert/4.cc", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fmodifiers%2Finsert%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fmodifiers%2Finsert%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fmodifiers%2Finsert%2F4.cc?ref=e6a054481d2586056b845639c8e26158169c027f", "patch": "@@ -0,0 +1,69 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2010-11-10  Paolo Carlini  <paolo.carlini@oracle.com> \n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <iterator>\n+#include <set>\n+#include <testsuite_hooks.h>\n+#include <testsuite_rvalref.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using __gnu_test::rvalstruct;\n+\n+  typedef std::multiset<rvalstruct> Set;\n+  Set s;\n+  VERIFY( s.empty() );\n+\n+  Set::iterator i = s.insert(s.begin(), rvalstruct(1));\n+  VERIFY( s.size() == 1 );\n+  VERIFY( std::distance(s.begin(), s.end()) == 1 );\n+  VERIFY( i == s.begin() );\n+  VERIFY( (*i).val == 1 );\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using __gnu_test::rvalstruct;\n+\n+  typedef std::multiset<rvalstruct> Set;\n+  Set s;\n+  VERIFY( s.empty() );\n+\n+  Set::iterator i0 = s.insert(s.begin(), rvalstruct(2));\n+  Set::iterator i1 = s.insert(i0, rvalstruct(2));\n+  VERIFY( s.size() == 2 );\n+  VERIFY( std::distance(s.begin(), s.end()) == 2 );\n+  VERIFY( (*i1).val == 2 );\n+  \n+  Set::iterator i2 = s.begin();\n+  ++i2;\n+  VERIFY( i1 == s.begin() );\n+  VERIFY( (*(s.begin())).val == 2 && (*i2).val == 2 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "31159262bda4e8ce575b9cdc007d74eaa5e5b431", "filename": "libstdc++-v3/testsuite/23_containers/set/modifiers/insert/2.cc", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fmodifiers%2Finsert%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fmodifiers%2Finsert%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fmodifiers%2Finsert%2F2.cc?ref=e6a054481d2586056b845639c8e26158169c027f", "patch": "@@ -0,0 +1,67 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2010-11-10  Paolo Carlini  <paolo.carlini@oracle.com> \n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <iterator>\n+#include <set>\n+#include <testsuite_hooks.h>\n+#include <testsuite_rvalref.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using __gnu_test::rvalstruct;\n+\n+  typedef std::set<rvalstruct> Set;\n+  Set s;\n+  VERIFY( s.empty() );\n+\n+  std::pair<Set::iterator, bool> p = s.insert(rvalstruct(1));\n+  VERIFY( p.second );\n+  VERIFY( s.size() == 1 );\n+  VERIFY( std::distance(s.begin(), s.end()) == 1 );\n+  VERIFY( p.first == s.begin() );\n+  VERIFY( (*p.first).val == 1 );\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using __gnu_test::rvalstruct;\n+\n+  typedef std::set<rvalstruct> Set;\n+  Set s;\n+  VERIFY( s.empty() );\n+\n+  std::pair<Set::iterator, bool> p1 = s.insert(rvalstruct(2));\n+  std::pair<Set::iterator, bool> p2 = s.insert(rvalstruct(2));  \n+  VERIFY( p1.second );\n+  VERIFY( !p2.second );\n+  VERIFY( s.size() == 1 );\n+  VERIFY( p1.first == p2.first );\n+  VERIFY( (*p1.first).val == 2 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "03e0d9d6c84dd74bbdb57ad4d1f6e9e2066c375f", "filename": "libstdc++-v3/testsuite/23_containers/set/modifiers/insert/3.cc", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fmodifiers%2Finsert%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a054481d2586056b845639c8e26158169c027f/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fmodifiers%2Finsert%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fmodifiers%2Finsert%2F3.cc?ref=e6a054481d2586056b845639c8e26158169c027f", "patch": "@@ -0,0 +1,64 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2010-11-10  Paolo Carlini  <paolo.carlini@oracle.com> \n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <iterator>\n+#include <set>\n+#include <testsuite_hooks.h>\n+#include <testsuite_rvalref.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using __gnu_test::rvalstruct;\n+\n+  typedef std::set<rvalstruct> Set;\n+  Set s;\n+  VERIFY( s.empty() );\n+\n+  Set::iterator p = s.insert(s.begin(), rvalstruct(1));\n+  VERIFY( s.size() == 1 );\n+  VERIFY( std::distance(s.begin(), s.end()) == 1 );\n+  VERIFY( p == s.begin() );\n+  VERIFY( (*p).val == 1 );\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using __gnu_test::rvalstruct;\n+\n+  typedef std::set<rvalstruct> Set;\n+  Set s;\n+  VERIFY( s.empty() );\n+\n+  Set::iterator p1 = s.insert(s.begin(), rvalstruct(2));\n+  Set::iterator p2 = s.insert(p1, rvalstruct(2));  \n+  VERIFY( s.size() == 1 );\n+  VERIFY( p1 == p2 );\n+  VERIFY( (*p1).val == 2 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}]}