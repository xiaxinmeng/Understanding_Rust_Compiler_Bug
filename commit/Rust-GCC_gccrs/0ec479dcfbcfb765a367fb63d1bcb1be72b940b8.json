{"sha": "0ec479dcfbcfb765a367fb63d1bcb1be72b940b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGVjNDc5ZGNmYmNmYjc2NWEzNjdmYjYzZDFiY2IxYmU3MmI5NDBiOA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2007-12-05T17:00:07Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2007-12-05T17:00:07Z"}, "message": "trans.c (lvalue_required_p): Take base node directly instead of its parent.\n\n\t* trans.c (lvalue_required_p): Take base node directly instead\n\tof its parent.  Rename second parameter to 'gnu_type'.\n\t<N_Indexed_Component>: Return 0 if the node isn't the prefix.\n\t<N_Slice>: Likewise.\n\t(Identifier_to_gnu): Rename parent_requires_lvalue to require_lvalue.\n\tAdjust calls to lvalue_required_p.\n\nFrom-SVN: r130626", "tree": {"sha": "74d79ba8b79742cd36ee30061cfff616cf02c445", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74d79ba8b79742cd36ee30061cfff616cf02c445"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ec479dcfbcfb765a367fb63d1bcb1be72b940b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ec479dcfbcfb765a367fb63d1bcb1be72b940b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ec479dcfbcfb765a367fb63d1bcb1be72b940b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ec479dcfbcfb765a367fb63d1bcb1be72b940b8/comments", "author": null, "committer": null, "parents": [{"sha": "e37ab97325aa1b4d5d3799d3bdf05fa157e8fa68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e37ab97325aa1b4d5d3799d3bdf05fa157e8fa68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e37ab97325aa1b4d5d3799d3bdf05fa157e8fa68"}], "stats": {"total": 145, "additions": 94, "deletions": 51}, "files": [{"sha": "e3dc3bdbc07c8fe014c7d8955069f7f1735e718a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ec479dcfbcfb765a367fb63d1bcb1be72b940b8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ec479dcfbcfb765a367fb63d1bcb1be72b940b8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0ec479dcfbcfb765a367fb63d1bcb1be72b940b8", "patch": "@@ -1,3 +1,12 @@\n+2007-12-05  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* trans.c (lvalue_required_p): Take base node directly instead\n+\tof its parent.  Rename second parameter to 'gnu_type'.\n+\t<N_Indexed_Component>: Return 0 if the node isn't the prefix.\n+\t<N_Slice>: Likewise.\n+\t(Identifier_to_gnu): Rename parent_requires_lvalue to require_lvalue.\n+\tAdjust calls to lvalue_required_p.\n+\n 2007-12-05  Samuel Tardieu  <sam@rfc1149.net>\n \n \tPR ada/21489"}, {"sha": "119d9e8fde1afc2cb8a5c5734477f7b0e5a1b8a0", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 60, "deletions": 51, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ec479dcfbcfb765a367fb63d1bcb1be72b940b8/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ec479dcfbcfb765a367fb63d1bcb1be72b940b8/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=0ec479dcfbcfb765a367fb63d1bcb1be72b940b8", "patch": "@@ -379,22 +379,29 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name,\n   error_gnat_node = Empty;\n }\n \f\n-/* Returns a positive value if GNAT_NODE requires an lvalue for an\n-   operand of OPERAND_TYPE, whose aliasing is specified by ALIASED,\n-   zero otherwise.  This is int instead of bool to facilitate usage\n-   in non purely binary logic contexts.  */\n+/* Return a positive value if an lvalue is required for GNAT_NODE.\n+   GNU_TYPE is the type that will be used for GNAT_NODE in the\n+   translated GNU tree.  ALIASED indicates whether the underlying\n+   object represented by GNAT_NODE is aliased in the Ada sense.\n+\n+   The function climbs up the GNAT tree starting from the node and\n+   returns 1 upon encountering a node that effectively requires an\n+   lvalue downstream.  It returns int instead of bool to facilitate\n+   usage in non purely binary logic contexts.  */\n \n static int\n-lvalue_required_p (Node_Id gnat_node, tree operand_type, int aliased)\n+lvalue_required_p (Node_Id gnat_node, tree gnu_type, int aliased)\n {\n-  switch (Nkind (gnat_node))\n+  Node_Id gnat_parent = Parent (gnat_node), gnat_temp;\n+\n+  switch (Nkind (gnat_parent))\n     {\n     case N_Reference:\n       return 1;\n \n     case N_Attribute_Reference:\n       {\n-\tunsigned char id = Get_Attribute_Id (Attribute_Name (gnat_node));\n+\tunsigned char id = Get_Attribute_Id (Attribute_Name (gnat_parent));\n \treturn id == Attr_Address\n \t       || id == Attr_Access\n \t       || id == Attr_Unchecked_Access\n@@ -404,32 +411,36 @@ lvalue_required_p (Node_Id gnat_node, tree operand_type, int aliased)\n     case N_Parameter_Association:\n     case N_Function_Call:\n     case N_Procedure_Call_Statement:\n-      return must_pass_by_ref (operand_type)\n-\t     || default_pass_by_ref (operand_type);\n+      return (must_pass_by_ref (gnu_type) || default_pass_by_ref (gnu_type));\n \n     case N_Indexed_Component:\n-      {\n-\tNode_Id gnat_temp;\n-\t/* ??? Consider that referencing an indexed component with a\n-\t   non-constant index forces the whole aggregate to memory.\n-\t   Note that N_Integer_Literal is conservative, any static\n-\t   expression in the RM sense could probably be accepted.  */\n-\tfor (gnat_temp = First (Expressions (gnat_node));\n-\t     Present (gnat_temp);\n-\t     gnat_temp = Next (gnat_temp))\n-\t  if (Nkind (gnat_temp) != N_Integer_Literal)\n-\t    return 1;\n-      }\n+      /* Only the array expression can require an lvalue.  */\n+      if (Prefix (gnat_parent) != gnat_node)\n+\treturn 0;\n+\n+      /* ??? Consider that referencing an indexed component with a\n+\t non-constant index forces the whole aggregate to memory.\n+\t Note that N_Integer_Literal is conservative, any static\n+\t expression in the RM sense could probably be accepted.  */\n+      for (gnat_temp = First (Expressions (gnat_parent));\n+\t   Present (gnat_temp);\n+\t   gnat_temp = Next (gnat_temp))\n+\tif (Nkind (gnat_temp) != N_Integer_Literal)\n+\t  return 1;\n \n       /* ... fall through ... */\n \n     case N_Slice:\n-      aliased |= Has_Aliased_Components (Etype (Prefix (gnat_node)));\n-      return lvalue_required_p (Parent (gnat_node), operand_type, aliased);\n+      /* Only the array expression can require an lvalue.  */\n+      if (Prefix (gnat_parent) != gnat_node)\n+\treturn 0;\n+\n+      aliased |= Has_Aliased_Components (Etype (gnat_node));\n+      return lvalue_required_p (gnat_parent, gnu_type, aliased);\n \n     case N_Selected_Component:\n-      aliased |= Is_Aliased (Entity (Selector_Name (gnat_node)));\n-      return lvalue_required_p (Parent (gnat_node), operand_type, aliased);\n+      aliased |= Is_Aliased (Entity (Selector_Name (gnat_parent)));\n+      return lvalue_required_p (gnat_parent, gnu_type, aliased);\n \n     case N_Object_Renaming_Declaration:\n       /* We need to make a real renaming only if the constant object is\n@@ -439,8 +450,8 @@ lvalue_required_p (Node_Id gnat_node, tree operand_type, int aliased)\n \t attached to the CONST_DECL.  */\n       return (aliased != 0\n \t      /* This should match the constant case of the renaming code.  */\n-\t      || Is_Composite_Type (Etype (Name (gnat_node)))\n-\t      || Nkind (Name (gnat_node)) == N_Identifier);\n+\t      || Is_Composite_Type (Etype (Name (gnat_parent)))\n+\t      || Nkind (Name (gnat_parent)) == N_Identifier);\n \n     default:\n       return 0;\n@@ -450,20 +461,19 @@ lvalue_required_p (Node_Id gnat_node, tree operand_type, int aliased)\n }\n \n /* Subroutine of gnat_to_gnu to translate gnat_node, an N_Identifier,\n-   to a GCC tree, which is returned.  GNU_RESULT_TYPE_P is a pointer to\n-   where we should place the result type.  */\n+   to a GCC tree, which is returned.  GNU_RESULT_TYPE_P is a pointer\n+   to where we should place the result type.  */\n \n static tree\n Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n {\n-  tree gnu_result_type;\n-  tree gnu_result;\n   Node_Id gnat_temp, gnat_temp_type;\n+  tree gnu_result, gnu_result_type;\n \n-  /* Whether the parent of gnat_node requires an lvalue.  Needed in\n-     specific circumstances only, so evaluated lazily.  < 0 means unknown,\n-     > 0 means known true, 0 means known false.  */\n-  int parent_requires_lvalue = -1;\n+  /* Whether we should require an lvalue for GNAT_NODE.  Needed in\n+     specific circumstances only, so evaluated lazily.  < 0 means\n+     unknown, > 0 means known true, 0 means known false.  */\n+  int require_lvalue = -1;\n \n   /* If GNAT_NODE is a constant, whether we should use the initialization\n      value instead of the constant entity, typically for scalars with an\n@@ -539,9 +549,9 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n   gnu_result_type = get_unpadded_type (gnat_temp_type);\n \n   /* If this is a non-imported scalar constant with an address clause,\n-     retrieve the value instead of a pointer to be dereferenced unless the\n-     parent requires an lvalue.  This is generally more efficient and\n-     actually required if this is a static expression because it might be used\n+     retrieve the value instead of a pointer to be dereferenced unless\n+     an lvalue is required.  This is generally more efficient and actually\n+     required if this is a static expression because it might be used\n      in a context where a dereference is inappropriate, such as a case\n      statement alternative or a record discriminant.  There is no possible\n      volatile-ness shortciruit here since Volatile constants must be imported\n@@ -550,10 +560,9 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n       && !Is_Imported (gnat_temp)\n       && Present (Address_Clause (gnat_temp)))\n     {\n-      parent_requires_lvalue\n-\t= lvalue_required_p (Parent (gnat_node), gnu_result_type,\n-\t\t\t     Is_Aliased (gnat_temp));\n-      use_constant_initializer = !parent_requires_lvalue;\n+      require_lvalue = lvalue_required_p (gnat_node, gnu_result_type,\n+\t\t\t\t\t  Is_Aliased (gnat_temp));\n+      use_constant_initializer = !require_lvalue;\n     }\n \n   if (use_constant_initializer)\n@@ -646,21 +655,21 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n      of places and the need of elaboration code if this Id is used as\n      an initializer itself.  */\n   if (TREE_CONSTANT (gnu_result)\n-      && DECL_P (gnu_result) && DECL_INITIAL (gnu_result))\n+      && DECL_P (gnu_result)\n+      && DECL_INITIAL (gnu_result))\n     {\n       tree object\n \t= (TREE_CODE (gnu_result) == CONST_DECL\n \t   ? DECL_CONST_CORRESPONDING_VAR (gnu_result) : gnu_result);\n \n-      /* If there is a corresponding variable, we only want to return the CST\n-\t value if the parent doesn't require an lvalue.  Evaluate this now if\n-\t we have not already done so.  */\n-      if (object && parent_requires_lvalue < 0)\n-\tparent_requires_lvalue\n-\t  = lvalue_required_p (Parent (gnat_node), gnu_result_type,\n-\t\t\t       Is_Aliased (gnat_temp));\n+      /* If there is a corresponding variable, we only want to return\n+\t the CST value if an lvalue is not required.  Evaluate this\n+\t now if we have not already done so.  */\n+      if (object && require_lvalue < 0)\n+\trequire_lvalue = lvalue_required_p (gnat_node, gnu_result_type,\n+\t\t\t\t\t    Is_Aliased (gnat_temp));\n \n-      if (!object || !parent_requires_lvalue)\n+      if (!object || !require_lvalue)\n \tgnu_result = unshare_expr (DECL_INITIAL (gnu_result));\n     }\n "}, {"sha": "04c8ebf0bdd3dd9e27b47f5d44bd5312472311ea", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ec479dcfbcfb765a367fb63d1bcb1be72b940b8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ec479dcfbcfb765a367fb63d1bcb1be72b940b8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0ec479dcfbcfb765a367fb63d1bcb1be72b940b8", "patch": "@@ -1,3 +1,7 @@\n+2007-12-05  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/specs/elab1.ads: New test.\n+\n 2007-12-05  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/34312"}, {"sha": "ac435d76a269b466996b5fd643d3e91a7aee708c", "filename": "gcc/testsuite/gnat.dg/specs/elab1.ads", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ec479dcfbcfb765a367fb63d1bcb1be72b940b8/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Felab1.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ec479dcfbcfb765a367fb63d1bcb1be72b940b8/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Felab1.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Felab1.ads?ref=0ec479dcfbcfb765a367fb63d1bcb1be72b940b8", "patch": "@@ -0,0 +1,21 @@\n+-- { dg-do compile }\n+\n+pragma Restrictions(No_Elaboration_Code);\n+\n+with System;\n+\n+package Elab1 is\n+\n+   type Ptrs_Type is array (Integer range 1 .. 2) of System.Address;\n+   type Vars_Array is array (Integer range 1 .. 2) of Integer;\n+\n+   Vars : Vars_Array;\n+\n+   Val1 : constant Integer := 1;\n+   Val2 : constant Integer := 2;\n+\n+   Ptrs : constant Ptrs_Type :=\n+     (1  => Vars (Val1)'Address,\n+      2  => Vars (Val2)'Address);\n+\n+end Elab1;"}]}