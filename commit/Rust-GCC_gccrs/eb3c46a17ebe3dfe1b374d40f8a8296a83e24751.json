{"sha": "eb3c46a17ebe3dfe1b374d40f8a8296a83e24751", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWIzYzQ2YTE3ZWJlM2RmZTFiMzc0ZDQwZjhhODI5NmE4M2UyNDc1MQ==", "commit": {"author": {"name": "Ranjit Mathew", "email": "rmathew@hotmail.com", "date": "2002-12-06T01:16:45Z"}, "committer": {"name": "Anthony Green", "email": "green@gcc.gnu.org", "date": "2002-12-06T01:16:45Z"}, "message": "ffi.h.in: Added FFI_STDCALL ffi_type enumeration for X86_WIN32.\n\n2002-11-10  Ranjit Mathew <rmathew@hotmail.com>\n\n\t* include/ffi.h.in: Added FFI_STDCALL ffi_type\n\t  enumeration for X86_WIN32.\n\t* src/x86/win32.S: Added ffi_call_STDCALL function\n\t  definition.\n\t* src/x86/ffi.c (ffi_call/ffi_raw_call): Added\n\t  switch cases for recognising FFI_STDCALL and\n\t  calling ffi_call_STDCALL if target is X86_WIN32.\n\t* src/ffitest.c (my_stdcall_strlen/stdcall_many):\n\t  stdcall versions of the \"my_strlen\" and \"many\"\n\t  test functions (for X86_WIN32).\n\t  Added test cases to test stdcall invocation using\n\t  these functions.\n\nFrom-SVN: r59878", "tree": {"sha": "42b4b6f3ce932aab0dbf81a4fb15247efd28b464", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42b4b6f3ce932aab0dbf81a4fb15247efd28b464"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb3c46a17ebe3dfe1b374d40f8a8296a83e24751", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb3c46a17ebe3dfe1b374d40f8a8296a83e24751", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb3c46a17ebe3dfe1b374d40f8a8296a83e24751", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb3c46a17ebe3dfe1b374d40f8a8296a83e24751/comments", "author": null, "committer": null, "parents": [{"sha": "1fcfaf375c135079ebea8aa17e726c51c938cc61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fcfaf375c135079ebea8aa17e726c51c938cc61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fcfaf375c135079ebea8aa17e726c51c938cc61"}], "stats": {"total": 255, "additions": 250, "deletions": 5}, "files": [{"sha": "8ed3398ea1e5a538e13323043911ce603ee84c20", "filename": "libffi/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb3c46a17ebe3dfe1b374d40f8a8296a83e24751/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb3c46a17ebe3dfe1b374d40f8a8296a83e24751/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=eb3c46a17ebe3dfe1b374d40f8a8296a83e24751", "patch": "@@ -1,3 +1,18 @@\n+2002-11-10  Ranjit Mathew <rmathew@hotmail.com>\n+\n+\t* include/ffi.h.in: Added FFI_STDCALL ffi_type\n+\t  enumeration for X86_WIN32.\n+\t* src/x86/win32.S: Added ffi_call_STDCALL function\n+\t  definition.\n+\t* src/x86/ffi.c (ffi_call/ffi_raw_call): Added\n+\t  switch cases for recognising FFI_STDCALL and\n+\t  calling ffi_call_STDCALL if target is X86_WIN32.\n+\t* src/ffitest.c (my_stdcall_strlen/stdcall_many):\n+\t  stdcall versions of the \"my_strlen\" and \"many\"\n+\t  test functions (for X86_WIN32).\n+\t  Added test cases to test stdcall invocation using\n+\t  these functions.\n+\n 2002-11-27  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* src/s390/sysv.S (.eh_frame section): Make section read-only."}, {"sha": "c660ede75af767a406163387bfab461c269ff30b", "filename": "libffi/include/ffi.h.in", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb3c46a17ebe3dfe1b374d40f8a8296a83e24751/libffi%2Finclude%2Fffi.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb3c46a17ebe3dfe1b374d40f8a8296a83e24751/libffi%2Finclude%2Fffi.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Finclude%2Fffi.h.in?ref=eb3c46a17ebe3dfe1b374d40f8a8296a83e24751", "patch": "@@ -198,6 +198,8 @@ typedef enum ffi_abi {\n   /* ---- Intel x86 Win32 ---------- */\n #ifdef X86_WIN32\n   FFI_SYSV,\n+  FFI_STDCALL,\n+  /* TODO: Add fastcall support for the sake of completeness */\n   FFI_DEFAULT_ABI = FFI_SYSV,\n #endif\n \n@@ -287,7 +289,7 @@ typedef struct _ffi_type\n   /*@null@*/ struct _ffi_type **elements;\n } ffi_type;\n \n-/* These are defined in ffi.c */\n+/* These are defined in types.c */\n extern ffi_type ffi_type_void;\n extern ffi_type ffi_type_uint8;\n extern ffi_type ffi_type_sint8;"}, {"sha": "da528317bb3727483ac1ce64f28d67ebf8218aff", "filename": "libffi/src/ffitest.c", "status": "modified", "additions": 88, "deletions": 1, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb3c46a17ebe3dfe1b374d40f8a8296a83e24751/libffi%2Fsrc%2Fffitest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb3c46a17ebe3dfe1b374d40f8a8296a83e24751/libffi%2Fsrc%2Fffitest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fffitest.c?ref=eb3c46a17ebe3dfe1b374d40f8a8296a83e24751", "patch": "@@ -1,5 +1,5 @@\n /* -----------------------------------------------------------------------\n-   ffitest.c - Copyright (c) 1996, 1997, 1998  Cygnus Solutions\n+   ffitest.c - Copyright (c) 1996, 1997, 1998, 2002  Red Hat, Inc.\n \n    Permission is hereby granted, free of charge, to any person obtaining\n    a copy of this software and associated documentation files (the\n@@ -49,6 +49,13 @@ static size_t my_strlen(char *s)\n   return (strlen(s));\n }\n \n+#ifdef X86_WIN32\n+static size_t __attribute__((stdcall)) my_stdcall_strlen(char *s)\n+{\n+  return (strlen(s));\n+}\n+#endif /* X86_WIN32 */\n+\n static int promotion(signed char sc, signed short ss, \n \t\t     unsigned char uc, unsigned short us)\n {\n@@ -112,6 +119,25 @@ static float many(float f1,\n   return ((f1/f2+f3/f4+f5/f6+f7/f8+f9/f10+f11/f12) * f13);\n }\n \n+#ifdef X86_WIN32\n+static float __attribute__((stdcall)) stdcall_many(float f1,\n+\t\t\t\t\t\t   float f2,\n+\t\t\t\t\t\t   float f3,\n+\t\t\t\t\t\t   float f4,\n+\t\t\t\t\t\t   float f5,\n+\t\t\t\t\t\t   float f6,\n+\t\t\t\t\t\t   float f7,\n+\t\t\t\t\t\t   float f8,\n+\t\t\t\t\t\t   float f9,\n+\t\t\t\t\t\t   float f10,\n+\t\t\t\t\t\t   float f11,\n+\t\t\t\t\t\t   float f12,\n+\t\t\t\t\t\t   float f13)\n+{\n+  return ((f1/f2+f3/f4+f5/f6+f7/f8+f9/f10+f11/f12) * f13);\n+}\n+#endif /* X86_WIN32 */\n+\n static double dblit(float f)\n {\n   return f/3.0;\n@@ -954,6 +980,67 @@ int main(/*@unused@*/ int argc, /*@unused@*/ char *argv[])\n   printf(\"Structure passing doesn't work on Win32.\\n\");\n #endif /* X86_WIN32 */\n \n+#ifdef X86_WIN32\n+  /* stdcall strlen tests */\n+  {\n+    args[0] = &ffi_type_pointer;\n+    values[0] = (void*) &s;\n+\n+    /* Initialize the cif */\n+    CHECK(ffi_prep_cif(&cif, FFI_STDCALL, 1,\n+\t\t       &ffi_type_sint, args) == FFI_OK);\n+\n+    s = \"a\";\n+    ffi_call(&cif, FFI_FN(my_stdcall_strlen), &rint, values);\n+    CHECK(rint == 1);\n+\n+    s = \"1234567\";\n+    ffi_call(&cif, FFI_FN(my_stdcall_strlen), &rint, values);\n+    CHECK(rint == 7);\n+\n+    s = \"1234567890123456789012345\";\n+    ffi_call(&cif, FFI_FN(my_stdcall_strlen), &rint, values);\n+    CHECK(rint == 25);\n+\n+    printf(\"stdcall strlen tests passed\\n\");\n+  }\n+\n+  /* stdcall many arg tests */\n+  {\n+    float ff;\n+    float fa[13];\n+\n+    for (ul = 0; ul < 13; ul++)\n+      {\n+\targs[ul] = &ffi_type_float;\n+\tvalues[ul] = &fa[ul];\n+\tfa[ul] = (float) ul;\n+      }\n+\n+    /* Initialize the cif */\n+    CHECK(ffi_prep_cif(&cif, FFI_STDCALL, 13,\n+\t\t       &ffi_type_float, args) == FFI_OK);\n+\n+    /*@-usedef@*/\n+    ff =  stdcall_many(fa[0], fa[1],\n+\t       fa[2], fa[3],\n+\t       fa[4], fa[5],\n+\t       fa[6], fa[7],\n+\t       fa[8], fa[9],\n+\t       fa[10],fa[11],fa[12]);\n+    /*@=usedef@*/\n+\n+    ffi_call(&cif, FFI_FN(stdcall_many), &f, values);\n+\n+    /*@-realcompare@*/\n+    if (f - ff < FLT_EPSILON)\n+    /*@=realcompare@*/\n+\tprintf(\"stdcall many arg tests ok!\\n\");\n+    else\n+        CHECK(0);\n+  }\n+#endif /* X86_WIN32 */\n+\n # if FFI_CLOSURES\n   /* A simple closure test */\n     {"}, {"sha": "68135f97c3596e9509ed4068a8d639d5d540899c", "filename": "libffi/src/x86/ffi.c", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb3c46a17ebe3dfe1b374d40f8a8296a83e24751/libffi%2Fsrc%2Fx86%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb3c46a17ebe3dfe1b374d40f8a8296a83e24751/libffi%2Fsrc%2Fx86%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fffi.c?ref=eb3c46a17ebe3dfe1b374d40f8a8296a83e24751", "patch": "@@ -1,5 +1,8 @@\n /* -----------------------------------------------------------------------\n-   ffi.c - Copyright (c) 1996, 1998, 1999  Cygnus Solutions\n+   ffi.c - Copyright (c) 1996, 1998, 1999, 2001  Red Hat, Inc.\n+           Copyright (c) 2002  Ranjit Mathew\n+           Copyright (c) 2002  Bo Thorsen\n+           Copyright (c) 2002  Roger Sayle\n    \n    x86 Foreign Function Interface \n \n@@ -148,6 +151,18 @@ extern void ffi_call_SYSV(void (*)(char *, extended_cif *),\n /*@=declundef@*/\n /*@=exportheader@*/\n \n+#ifdef X86_WIN32\n+/*@-declundef@*/\n+/*@-exportheader@*/\n+extern void ffi_call_STDCALL(void (*)(char *, extended_cif *),\n+\t\t\t  /*@out@*/ extended_cif *,\n+\t\t\t  unsigned, unsigned,\n+\t\t\t  /*@out@*/ unsigned *,\n+\t\t\t  void (*fn)());\n+/*@=declundef@*/\n+/*@=exportheader@*/\n+#endif /* X86_WIN32 */\n+\n void ffi_call(/*@dependent@*/ ffi_cif *cif, \n \t      void (*fn)(), \n \t      /*@out@*/ void *rvalue, \n@@ -180,6 +195,14 @@ void ffi_call(/*@dependent@*/ ffi_cif *cif,\n \t\t    cif->flags, ecif.rvalue, fn);\n       /*@=usedef@*/\n       break;\n+#ifdef X86_WIN32\n+    case FFI_STDCALL:\n+      /*@-usedef@*/\n+      ffi_call_STDCALL(ffi_prep_args, &ecif, cif->bytes,\n+\t\t    cif->flags, ecif.rvalue, fn);\n+      /*@=usedef@*/\n+      break;\n+#endif /* X86_WIN32 */\n     default:\n       FFI_ASSERT(0);\n       break;\n@@ -448,6 +471,15 @@ ffi_call_SYSV(void (*)(char *, extended_cif *),\n \t      /*@out@*/ unsigned *, \n \t      void (*fn)());\n \n+#ifdef X86_WIN32\n+extern void\n+ffi_call_STDCALL(void (*)(char *, extended_cif *),\n+\t      /*@out@*/ extended_cif *,\n+\t      unsigned, unsigned,\n+\t      /*@out@*/ unsigned *,\n+\t      void (*fn)());\n+#endif /* X86_WIN32 */\n+\n void\n ffi_raw_call(/*@dependent@*/ ffi_cif *cif, \n \t     void (*fn)(), \n@@ -482,6 +514,14 @@ ffi_raw_call(/*@dependent@*/ ffi_cif *cif,\n \t\t    cif->flags, ecif.rvalue, fn);\n       /*@=usedef@*/\n       break;\n+#ifdef X86_WIN32\n+    case FFI_STDCALL:\n+      /*@-usedef@*/\n+      ffi_call_STDCALL(ffi_prep_args_raw, &ecif, cif->bytes,\n+\t\t    cif->flags, ecif.rvalue, fn);\n+      /*@=usedef@*/\n+      break;\n+#endif /* X86_WIN32 */\n     default:\n       FFI_ASSERT(0);\n       break;"}, {"sha": "796af18754bf446030be624fa2af0d7d08ef6c29", "filename": "libffi/src/x86/win32.S", "status": "modified", "additions": 103, "deletions": 2, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb3c46a17ebe3dfe1b374d40f8a8296a83e24751/libffi%2Fsrc%2Fx86%2Fwin32.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb3c46a17ebe3dfe1b374d40f8a8296a83e24751/libffi%2Fsrc%2Fx86%2Fwin32.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fwin32.S?ref=eb3c46a17ebe3dfe1b374d40f8a8296a83e24751", "patch": "@@ -1,5 +1,8 @@\n /* -----------------------------------------------------------------------\n-   win32.S - Copyright (c) 1996, 1998, 2001  Cygnus Solutions\n+   win32.S - Copyright (c) 1996, 1998, 2001, 2002  Red Hat, Inc.\n+\t     Copyright (c) 2001  John Beniton\n+\t     Copyright (c) 2002  Ranjit Mathew\n+\t\t\t\n  \n    X86 Foreign Function Interface\n  \n@@ -52,7 +55,10 @@ _ffi_call_SYSV:\n         # Return stack to previous state and call the function\n         addl  $8,%esp\n  \n-        call  *28(%ebp)\n+        # FIXME: Align the stack to a 128-bit boundary to avoid\n+        # potential performance hits.\n+\n+\tcall  *28(%ebp)\n  \n         # Remove the space we pushed for the args\n         movl  16(%ebp),%ecx\n@@ -123,3 +129,98 @@ epilogue:\n         ret\n  \n .ffi_call_SYSV_end:\n+\n+        # This assumes we are using gas.\n+        .balign 16\n+.globl _ffi_call_STDCALL\n+\n+_ffi_call_STDCALL:\n+        pushl %ebp\n+        movl  %esp,%ebp\n+\n+        # Make room for all of the new args.\n+        movl  16(%ebp),%ecx \n+        subl  %ecx,%esp\n+\n+        movl  %esp,%eax\n+\n+        # Place all of the ffi_prep_args in position\n+        pushl 12(%ebp)\n+        pushl %eax\n+        call  *8(%ebp)\n+\n+        # Return stack to previous state and call the function\n+        addl  $8,%esp\n+\n+        # FIXME: Align the stack to a 128-bit boundary to avoid\n+        # potential performance hits.\n+\n+        call  *28(%ebp)\n+\n+        # stdcall functions pop arguments off the stack themselves\n+\n+        # Load %ecx with the return type code\n+        movl  20(%ebp),%ecx\n+\n+        # If the return value pointer is NULL, assume no return value.\n+        cmpl  $0,24(%ebp)\n+        jne   sc_retint\n+\n+        # Even if there is no space for the return value, we are\n+        # obliged to handle floating-point values.\n+        cmpl  $FFI_TYPE_FLOAT,%ecx\n+        jne   sc_noretval\n+        fstp  %st(0)\n+\n+        jmp   sc_epilogue\n+\n+sc_retint:\n+        cmpl  $FFI_TYPE_INT,%ecx\n+        jne   sc_retfloat\n+        # Load %ecx with the pointer to storage for the return value\n+        movl  24(%ebp),%ecx\n+        movl  %eax,0(%ecx)\n+        jmp   sc_epilogue\n+\n+sc_retfloat:\n+        cmpl  $FFI_TYPE_FLOAT,%ecx\n+        jne   sc_retdouble\n+         # Load %ecx with the pointer to storage for the return value\n+        movl  24(%ebp),%ecx\n+        fstps (%ecx)\n+        jmp   sc_epilogue\n+\n+sc_retdouble:\n+        cmpl  $FFI_TYPE_DOUBLE,%ecx\n+        jne   sc_retlongdouble\n+        # Load %ecx with the pointer to storage for the return value\n+        movl  24(%ebp),%ecx\n+        fstpl (%ecx)\n+        jmp   sc_epilogue\n+\n+sc_retlongdouble:\n+        cmpl  $FFI_TYPE_LONGDOUBLE,%ecx\n+        jne   sc_retint64\n+        # Load %ecx with the pointer to storage for the return value\n+        movl  24(%ebp),%ecx\n+        fstpt (%ecx)\n+        jmp   sc_epilogue\n+\n+sc_retint64:\n+        cmpl  $FFI_TYPE_SINT64,%ecx\n+        jne   sc_retstruct\n+        # Load %ecx with the pointer to storage for the return value\n+        movl  24(%ebp),%ecx\n+        movl  %eax,0(%ecx)\n+        movl  %edx,4(%ecx)\n+\n+sc_retstruct:\n+        # Nothing to do!\n+\n+sc_noretval:\n+sc_epilogue:\n+        movl %ebp,%esp\n+        popl %ebp\n+        ret\n+\n+.ffi_call_STDCALL_end:"}]}