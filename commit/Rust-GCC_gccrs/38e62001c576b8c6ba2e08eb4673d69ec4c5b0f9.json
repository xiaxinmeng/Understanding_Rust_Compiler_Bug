{"sha": "38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzhlNjIwMDFjNTc2YjhjNmJhMmUwOGViNDY3M2Q2OWVjNGM1YjBmOQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-03-07T11:52:33Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-04-09T16:11:12Z"}, "message": "aarch64: Add support for arm_sve_vector_bits\n\nThis patch implements the \"arm_sve_vector_bits\" attribute, which can be\nused to create fixed-length versions of an SVE type while maintaining\ntheir \"SVEness\".  For example, when __ARM_FEATURE_SVE_BITS==256:\n\ntypedef svint32_t vec __attribute__((arm_sve_vector_bits(256)));\n\ncreates a 256-bit version of svint32_t.\n\nThe attribute itself is quite simple.  However, it means that we now\nneed to implement the full PCS rules for scalable types, whereas\npreviously we only needed to handle scalable types that were built\ndirectly into the compiler.  See:\n\n  https://github.com/ARM-software/abi-aa/blob/master/aapcs64/aapcs64.rst\n\nfor more information about these rules.\n\n2020-04-09  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* doc/sourcebuild.texi (aarch64_sve_hw, aarch64_sve128_hw)\n\t(aarch64_sve256_hw, aarch64_sve512_hw, aarch64_sve1024_hw)\n\t(aarch64_sve2048_hw): Document.\n\t* config/aarch64/aarch64-protos.h\n\t(aarch64_sve::handle_arm_sve_vector_bits_attribute): Declare.\n\t* config/aarch64/aarch64-c.c (aarch64_update_cpp_builtins): Define\n\t__ARM_FEATURE_SVE_VECTOR_OPERATIONS when SVE is enabled.\n\t* config/aarch64/aarch64-sve-builtins.cc (matches_type_p): New\n\tfunction.\n\t(find_type_suffix_for_scalar_type): Use it instead of comparing\n\tTYPE_MAIN_VARIANTs.\n\t(function_resolver::infer_vector_or_tuple_type): Likewise.\n\t(function_resolver::require_vector_type): Likewise.\n\t(handle_arm_sve_vector_bits_attribute): New function.\n\t* config/aarch64/aarch64.c (pure_scalable_type_info): New class.\n\t(aarch64_attribute_table): Add arm_sve_vector_bits.\n\t(aarch64_return_in_memory_1):\n\t(pure_scalable_type_info::piece::get_rtx): New function.\n\t(pure_scalable_type_info::num_zr): Likewise.\n\t(pure_scalable_type_info::num_pr): Likewise.\n\t(pure_scalable_type_info::get_rtx): Likewise.\n\t(pure_scalable_type_info::analyze): Likewise.\n\t(pure_scalable_type_info::analyze_registers): Likewise.\n\t(pure_scalable_type_info::analyze_array): Likewise.\n\t(pure_scalable_type_info::analyze_record): Likewise.\n\t(pure_scalable_type_info::add_piece): Likewise.\n\t(aarch64_some_values_include_pst_objects_p): Likewise.\n\t(aarch64_returns_value_in_sve_regs_p): Use pure_scalable_type_info\n\tto analyze whether the type is returned in SVE registers.\n\t(aarch64_takes_arguments_in_sve_regs_p): Likwise whether the type\n\tis passed in SVE registers.\n\t(aarch64_pass_by_reference_1): New function, extracted from...\n\t(aarch64_pass_by_reference): ...here.  Use pure_scalable_type_info\n\tto analyze whether the type is a pure scalable type and, if so,\n\twhether it should be passed by reference.\n\t(aarch64_return_in_msb): Return false for pure scalable types.\n\t(aarch64_function_value_1): Fold back into...\n\t(aarch64_function_value): ...this function.  Use\n\tpure_scalable_type_info to analyze whether the type is a pure\n\tscalable type and, if so, which registers it should use.  Handle\n\ttypes that include pure scalable types but are not themselves\n\tpure scalable types.\n\t(aarch64_return_in_memory_1): New function, split out from...\n\t(aarch64_return_in_memory): ...here.  Use pure_scalable_type_info\n\tto analyze whether the type is a pure scalable type and, if so,\n\twhether it should be returned by reference.\n\t(aarch64_layout_arg): Remove orig_mode argument.  Use\n\tpure_scalable_type_info to analyze whether the type is a pure\n\tscalable type and, if so, which registers it should use.  Handle\n\ttypes that include pure scalable types but are not themselves\n\tpure scalable types.\n\t(aarch64_function_arg): Update call accordingly.\n\t(aarch64_function_arg_advance): Likewise.\n\t(aarch64_pad_reg_upward): On big-endian targets, return false for\n\tpure scalable types that are smaller than 16 bytes.\n\t(aarch64_member_type_forces_blk): New function.\n\t(aapcs_vfp_sub_candidate): Exit early for built-in SVE types.\n\t(aarch64_short_vector_p): Return false for VECTOR_TYPEs that\n\tcorrespond to built-in SVE types.  Do not rely on a vector mode\n\tif the type includes an pure scalable type.  When returning true,\n\tassert that the mode is not an SVE mode.\n\t(aarch64_vfp_is_call_or_return_candidate): Do not check for SVE\n\tbuilt-in types here.  When returning true, assert that the type\n\tdoes not have an SVE mode.\n\t(aarch64_can_change_mode_class): Don't allow anything to change\n\tbetween a predicate mode and a non-predicate mode.  Also don't\n\tallow changes between SVE vector modes and other modes that\n\tmight be bigger than 128 bits.\n\t(aarch64_invalid_binary_op): Reject binary operations that mix\n\tSVE and GNU vector types.\n\t(TARGET_MEMBER_TYPE_FORCES_BLK): Define.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/sve/acle/general/attributes_1.c: New test.\n\t* gcc.target/aarch64/sve/acle/general/attributes_2.c: Likewise.\n\t* gcc.target/aarch64/sve/acle/general/attributes_3.c: Likewise.\n\t* gcc.target/aarch64/sve/acle/general/attributes_4.c: Likewise.\n\t* gcc.target/aarch64/sve/acle/general/attributes_5.c: Likewise.\n\t* gcc.target/aarch64/sve/acle/general/attributes_6.c: Likewise.\n\t* gcc.target/aarch64/sve/acle/general/attributes_7.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/struct.h: New file.\n\t* gcc.target/aarch64/sve/pcs/struct_1_128.c: New test.\n\t* gcc.target/aarch64/sve/pcs/struct_1_256.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/struct_1_512.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/struct_1_1024.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/struct_1_2048.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/struct_2_128.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/struct_2_256.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/struct_2_512.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/struct_2_1024.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/struct_2_2048.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/struct_3_128.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/struct_3_256.c: Likewise.\n\t* gcc.target/aarch64/sve/pcs/struct_3_512.c: Likewise.\n\t* lib/target-supports.exp (check_effective_target_aarch64_sve128_hw)\n\t(check_effective_target_aarch64_sve512_hw)\n\t(check_effective_target_aarch64_sve1024_hw)\n\t(check_effective_target_aarch64_sve2048_hw): New procedures.", "tree": {"sha": "7b36d2c0fefd03d51f2fdf53e1a2503f9b7374e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b36d2c0fefd03d51f2fdf53e1a2503f9b7374e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5002dae3df4efa7a2db1869ae6f8edd329df8486", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5002dae3df4efa7a2db1869ae6f8edd329df8486", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5002dae3df4efa7a2db1869ae6f8edd329df8486"}], "stats": {"total": 6268, "additions": 6093, "deletions": 175}, "files": [{"sha": "1066146b2e53010d7e3ff1b154ebc210e7fe6698", "filename": "gcc/ChangeLog", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9", "patch": "@@ -1,3 +1,77 @@\n+2020-04-09  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* doc/sourcebuild.texi (aarch64_sve_hw, aarch64_sve128_hw)\n+\t(aarch64_sve256_hw, aarch64_sve512_hw, aarch64_sve1024_hw)\n+\t(aarch64_sve2048_hw): Document.\n+\t* config/aarch64/aarch64-protos.h\n+\t(aarch64_sve::handle_arm_sve_vector_bits_attribute): Declare.\n+\t* config/aarch64/aarch64-c.c (aarch64_update_cpp_builtins): Define\n+\t__ARM_FEATURE_SVE_VECTOR_OPERATIONS when SVE is enabled.\n+\t* config/aarch64/aarch64-sve-builtins.cc (matches_type_p): New\n+\tfunction.\n+\t(find_type_suffix_for_scalar_type): Use it instead of comparing\n+\tTYPE_MAIN_VARIANTs.\n+\t(function_resolver::infer_vector_or_tuple_type): Likewise.\n+\t(function_resolver::require_vector_type): Likewise.\n+\t(handle_arm_sve_vector_bits_attribute): New function.\n+\t* config/aarch64/aarch64.c (pure_scalable_type_info): New class.\n+\t(aarch64_attribute_table): Add arm_sve_vector_bits.\n+\t(aarch64_return_in_memory_1):\n+\t(pure_scalable_type_info::piece::get_rtx): New function.\n+\t(pure_scalable_type_info::num_zr): Likewise.\n+\t(pure_scalable_type_info::num_pr): Likewise.\n+\t(pure_scalable_type_info::get_rtx): Likewise.\n+\t(pure_scalable_type_info::analyze): Likewise.\n+\t(pure_scalable_type_info::analyze_registers): Likewise.\n+\t(pure_scalable_type_info::analyze_array): Likewise.\n+\t(pure_scalable_type_info::analyze_record): Likewise.\n+\t(pure_scalable_type_info::add_piece): Likewise.\n+\t(aarch64_some_values_include_pst_objects_p): Likewise.\n+\t(aarch64_returns_value_in_sve_regs_p): Use pure_scalable_type_info\n+\tto analyze whether the type is returned in SVE registers.\n+\t(aarch64_takes_arguments_in_sve_regs_p): Likwise whether the type\n+\tis passed in SVE registers.\n+\t(aarch64_pass_by_reference_1): New function, extracted from...\n+\t(aarch64_pass_by_reference): ...here.  Use pure_scalable_type_info\n+\tto analyze whether the type is a pure scalable type and, if so,\n+\twhether it should be passed by reference.\n+\t(aarch64_return_in_msb): Return false for pure scalable types.\n+\t(aarch64_function_value_1): Fold back into...\n+\t(aarch64_function_value): ...this function.  Use\n+\tpure_scalable_type_info to analyze whether the type is a pure\n+\tscalable type and, if so, which registers it should use.  Handle\n+\ttypes that include pure scalable types but are not themselves\n+\tpure scalable types.\n+\t(aarch64_return_in_memory_1): New function, split out from...\n+\t(aarch64_return_in_memory): ...here.  Use pure_scalable_type_info\n+\tto analyze whether the type is a pure scalable type and, if so,\n+\twhether it should be returned by reference.\n+\t(aarch64_layout_arg): Remove orig_mode argument.  Use\n+\tpure_scalable_type_info to analyze whether the type is a pure\n+\tscalable type and, if so, which registers it should use.  Handle\n+\ttypes that include pure scalable types but are not themselves\n+\tpure scalable types.\n+\t(aarch64_function_arg): Update call accordingly.\n+\t(aarch64_function_arg_advance): Likewise.\n+\t(aarch64_pad_reg_upward): On big-endian targets, return false for\n+\tpure scalable types that are smaller than 16 bytes.\n+\t(aarch64_member_type_forces_blk): New function.\n+\t(aapcs_vfp_sub_candidate): Exit early for built-in SVE types.\n+\t(aarch64_short_vector_p): Return false for VECTOR_TYPEs that\n+\tcorrespond to built-in SVE types.  Do not rely on a vector mode\n+\tif the type includes an pure scalable type.  When returning true,\n+\tassert that the mode is not an SVE mode.\n+\t(aarch64_vfp_is_call_or_return_candidate): Do not check for SVE\n+\tbuilt-in types here.  When returning true, assert that the type\n+\tdoes not have an SVE mode.\n+\t(aarch64_can_change_mode_class): Don't allow anything to change\n+\tbetween a predicate mode and a non-predicate mode.  Also don't\n+\tallow changes between SVE vector modes and other modes that\n+\tmight be bigger than 128 bits.\n+\t(aarch64_invalid_binary_op): Reject binary operations that mix\n+\tSVE and GNU vector types.\n+\t(TARGET_MEMBER_TYPE_FORCES_BLK): Define.\n+\n 2020-04-09  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* config/aarch64/aarch64.c (aarch64_attribute_table): Add"}, {"sha": "e1c1cd415dcb66f5a5d2ccbbdab8021ed520fa5e", "filename": "gcc/config/aarch64/aarch64-c.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Fconfig%2Faarch64%2Faarch64-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Fconfig%2Faarch64%2Faarch64-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-c.c?ref=38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9", "patch": "@@ -149,6 +149,8 @@ aarch64_update_cpp_builtins (cpp_reader *pfile)\n \tbits = 0;\n       builtin_define_with_int_value (\"__ARM_FEATURE_SVE_BITS\", bits);\n     }\n+  aarch64_def_or_undef (TARGET_SVE, \"__ARM_FEATURE_SVE_VECTOR_OPERATIONS\",\n+\t\t\tpfile);\n   aarch64_def_or_undef (TARGET_SVE_I8MM,\n \t\t\t\"__ARM_FEATURE_SVE_MATMUL_INT8\", pfile);\n   aarch64_def_or_undef (TARGET_SVE_F32MM,"}, {"sha": "9e43adb7db0373df6cc5ef1d2b22f217aca2aad2", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9", "patch": "@@ -716,6 +716,7 @@ namespace aarch64_sve {\n \t\t\t   tree, unsigned int, tree *);\n   gimple *gimple_fold_builtin (unsigned int, gimple_stmt_iterator *, gcall *);\n   rtx expand_builtin (unsigned int, tree, rtx);\n+  tree handle_arm_sve_vector_bits_attribute (tree *, tree, tree, int, bool *);\n #ifdef GCC_TARGET_H\n   bool verify_type_context (location_t, type_context_kind, const_tree, bool);\n #endif"}, {"sha": "ca4a0ebdd0c044971b961f8c7abe5bbbf35e501f", "filename": "gcc/config/aarch64/aarch64-sve-builtins.cc", "status": "modified", "additions": 78, "deletions": 5, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.cc?ref=38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9", "patch": "@@ -602,19 +602,38 @@ sizeless_type_p (const_tree type)\n   return lookup_attribute (\"SVE sizeless type\", TYPE_ATTRIBUTES (type));\n }\n \n+/* Return true if CANDIDATE is equivalent to MODEL_TYPE for overloading\n+   purposes.  */\n+static bool\n+matches_type_p (const_tree model_type, const_tree candidate)\n+{\n+  if (VECTOR_TYPE_P (model_type))\n+    {\n+      if (!VECTOR_TYPE_P (candidate)\n+\t  || maybe_ne (TYPE_VECTOR_SUBPARTS (model_type),\n+\t\t       TYPE_VECTOR_SUBPARTS (candidate))\n+\t  || TYPE_MODE (model_type) != TYPE_MODE (candidate))\n+\treturn false;\n+\n+      model_type = TREE_TYPE (model_type);\n+      candidate = TREE_TYPE (candidate);\n+    }\n+  return (candidate != error_mark_node\n+\t  && TYPE_MAIN_VARIANT (model_type) == TYPE_MAIN_VARIANT (candidate));\n+}\n+\n /* If TYPE is a valid SVE element type, return the corresponding type\n    suffix, otherwise return NUM_TYPE_SUFFIXES.  */\n static type_suffix_index\n find_type_suffix_for_scalar_type (const_tree type)\n {\n   /* A linear search should be OK here, since the code isn't hot and\n      the number of types is only small.  */\n-  type = TYPE_MAIN_VARIANT (type);\n   for (unsigned int suffix_i = 0; suffix_i < NUM_TYPE_SUFFIXES; ++suffix_i)\n     if (!type_suffixes[suffix_i].bool_p)\n       {\n \tvector_type_index vector_i = type_suffixes[suffix_i].vector_type;\n-\tif (type == TYPE_MAIN_VARIANT (scalar_types[vector_i]))\n+\tif (matches_type_p (scalar_types[vector_i], type))\n \t  return type_suffix_index (suffix_i);\n       }\n   return NUM_TYPE_SUFFIXES;\n@@ -1273,7 +1292,7 @@ function_resolver::infer_vector_or_tuple_type (unsigned int argno,\n       {\n \tvector_type_index type_i = type_suffixes[suffix_i].vector_type;\n \ttree type = acle_vector_types[size_i][type_i];\n-\tif (type && TYPE_MAIN_VARIANT (actual) == TYPE_MAIN_VARIANT (type))\n+\tif (type && matches_type_p (type, actual))\n \t  {\n \t    if (size_i + 1 == num_vectors)\n \t      return type_suffix_index (suffix_i);\n@@ -1411,8 +1430,7 @@ function_resolver::require_vector_type (unsigned int argno,\n {\n   tree expected = acle_vector_types[0][type];\n   tree actual = get_argument_type (argno);\n-  if (actual != error_mark_node\n-      && TYPE_MAIN_VARIANT (expected) != TYPE_MAIN_VARIANT (actual))\n+  if (!matches_type_p (expected, actual))\n     {\n       error_at (location, \"passing %qT to argument %d of %qE, which\"\n \t\t\" expects %qT\", actual, argno + 1, fndecl, expected);\n@@ -3592,6 +3610,61 @@ builtin_type_p (const_tree type, unsigned int *num_zr, unsigned int *num_pr)\n   return false;\n }\n \n+/* An attribute callback for the \"arm_sve_vector_bits\" attribute.  */\n+tree\n+handle_arm_sve_vector_bits_attribute (tree *node, tree, tree args, int,\n+\t\t\t\t      bool *no_add_attrs)\n+{\n+  *no_add_attrs = true;\n+\n+  tree type = *node;\n+  if (!VECTOR_TYPE_P (type) || !builtin_type_p (type))\n+    {\n+      error (\"%qs applied to non-SVE type %qT\", \"arm_sve_vector_bits\", type);\n+      return NULL_TREE;\n+    }\n+\n+  tree size = TREE_VALUE (args);\n+  if (TREE_CODE (size) != INTEGER_CST)\n+    {\n+      error (\"%qs requires an integer constant expression\",\n+\t     \"arm_sve_vector_bits\");\n+      return NULL_TREE;\n+    }\n+\n+  unsigned HOST_WIDE_INT value = tree_to_uhwi (size);\n+  if (maybe_ne (value, BITS_PER_SVE_VECTOR))\n+    {\n+      warning (OPT_Wattributes, \"unsupported SVE vector size\");\n+      return NULL_TREE;\n+    }\n+\n+  /* FIXME: The type ought to be a distinct copy in all cases, but\n+     currently that makes the C frontend reject conversions between\n+     svbool_t and its fixed-length variants.  Using a type variant\n+     avoids that but means that we treat some ambiguous combinations\n+     as valid.  */\n+  if (lang_GNU_C () && VECTOR_BOOLEAN_TYPE_P (type))\n+    type = build_variant_type_copy (type);\n+  else\n+    type = build_distinct_type_copy (type);\n+\n+  /* The new type is a normal sized type; it doesn't have the same\n+     restrictions as sizeless types.  */\n+  TYPE_ATTRIBUTES (type)\n+    = remove_attribute (\"SVE sizeless type\",\n+\t\t\tcopy_list (TYPE_ATTRIBUTES (type)));\n+\n+  /* Allow the GNU vector extensions to be applied to vectors.\n+     The extensions aren't yet defined for packed predicates,\n+     so continue to treat them as abstract entities for now.  */\n+  if (!VECTOR_BOOLEAN_TYPE_P (type))\n+    TYPE_INDIVISIBLE_P (type) = 0;\n+\n+  *node = type;\n+  return NULL_TREE;\n+}\n+\n /* Implement TARGET_VERIFY_TYPE_CONTEXT for SVE types.  */\n bool\n verify_type_context (location_t loc, type_context_kind context,"}, {"sha": "4af562a81ea760891fac3cf7101b8bf887fe7a0d", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 661, "deletions": 168, "changes": 829, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9", "patch": "@@ -174,6 +174,102 @@ ::simd_immediate_info (scalar_int_mode elt_mode_in,\n   u.pattern = pattern_in;\n }\n \n+namespace {\n+\n+/* Describes types that map to Pure Scalable Types (PSTs) in the AAPCS64.  */\n+class pure_scalable_type_info\n+{\n+public:\n+  /* Represents the result of analyzing a type.  All values are nonzero,\n+     in the possibly forlorn hope that accidental conversions to bool\n+     trigger a warning.  */\n+  enum analysis_result\n+  {\n+    /* The type does not have an ABI identity; i.e. it doesn't contain\n+       at least one object whose type is a Fundamental Data Type.  */\n+    NO_ABI_IDENTITY = 1,\n+\n+    /* The type is definitely a Pure Scalable Type.  */\n+    IS_PST,\n+\n+    /* The type is definitely not a Pure Scalable Type.  */\n+    ISNT_PST,\n+\n+    /* It doesn't matter for PCS purposes whether the type is a Pure\n+       Scalable Type or not, since the type will be handled the same\n+       way regardless.\n+\n+       Specifically, this means that if the type is a Pure Scalable Type,\n+       there aren't enough argument registers to hold it, and so it will\n+       need to be passed or returned in memory.  If the type isn't a\n+       Pure Scalable Type, it's too big to be passed or returned in core\n+       or SIMD&FP registers, and so again will need to go in memory.  */\n+    DOESNT_MATTER\n+  };\n+\n+  /* Aggregates of 17 bytes or more are normally passed and returned\n+     in memory, so aggregates of that size can safely be analyzed as\n+     DOESNT_MATTER.  We need to be able to collect enough pieces to\n+     represent a PST that is smaller than that.  Since predicates are\n+     2 bytes in size for -msve-vector-bits=128, that means we need to be\n+     able to store at least 8 pieces.\n+\n+     We also need to be able to store enough pieces to represent\n+     a single vector in each vector argument register and a single\n+     predicate in each predicate argument register.  This means that\n+     we need at least 12 pieces.  */\n+  static const unsigned int MAX_PIECES = NUM_FP_ARG_REGS + NUM_PR_ARG_REGS;\n+#if __cplusplus >= 201103L\n+  static_assert (MAX_PIECES >= 8, \"Need to store at least 8 predicates\");\n+#endif\n+\n+  /* Describes one piece of a PST.  Each piece is one of:\n+\n+     - a single Scalable Vector Type (SVT)\n+     - a single Scalable Predicate Type (SPT)\n+     - a PST containing 2, 3 or 4 SVTs, with no padding\n+\n+     It either represents a single built-in type or a PST formed from\n+     multiple homogeneous built-in types.  */\n+  struct piece\n+  {\n+    rtx get_rtx (unsigned int, unsigned int) const;\n+\n+    /* The number of vector and predicate registers that the piece\n+       occupies.  One of the two is always zero.  */\n+    unsigned int num_zr;\n+    unsigned int num_pr;\n+\n+    /* The mode of the registers described above.  */\n+    machine_mode mode;\n+\n+    /* If this piece is formed from multiple homogeneous built-in types,\n+       this is the mode of the built-in types, otherwise it is MODE.  */\n+    machine_mode orig_mode;\n+\n+    /* The offset in bytes of the piece from the start of the type.  */\n+    poly_uint64_pod offset;\n+  };\n+\n+  /* Divides types analyzed as IS_PST into individual pieces.  The pieces\n+     are in memory order.  */\n+  auto_vec<piece, MAX_PIECES> pieces;\n+\n+  unsigned int num_zr () const;\n+  unsigned int num_pr () const;\n+\n+  rtx get_rtx (machine_mode mode, unsigned int, unsigned int) const;\n+\n+  analysis_result analyze (const_tree);\n+  bool analyze_registers (const_tree);\n+\n+private:\n+  analysis_result analyze_array (const_tree);\n+  analysis_result analyze_record (const_tree);\n+  void add_piece (const piece &);\n+};\n+}\n+\n /* The current code model.  */\n enum aarch64_code_model aarch64_cmodel;\n \n@@ -186,6 +282,7 @@ poly_uint16 aarch64_sve_vg;\n #endif\n \n static bool aarch64_composite_type_p (const_tree, machine_mode);\n+static bool aarch64_return_in_memory_1 (const_tree);\n static bool aarch64_vfp_is_call_or_return_candidate (machine_mode,\n \t\t\t\t\t\t     const_tree,\n \t\t\t\t\t\t     machine_mode *, int *,\n@@ -1246,6 +1343,9 @@ static const struct attribute_spec aarch64_attribute_table[] =\n        affects_type_identity, handler, exclude } */\n   { \"aarch64_vector_pcs\", 0, 0, false, true,  true,  true,\n \t\t\t  handle_aarch64_vector_pcs_attribute, NULL },\n+  { \"arm_sve_vector_bits\", 1, 1, false, true,  false, true,\n+\t\t\t  aarch64_sve::handle_arm_sve_vector_bits_attribute,\n+\t\t\t  NULL },\n   { \"SVE type\",\t\t  3, 3, false, true,  false, true,  NULL, NULL },\n   { \"SVE sizeless type\",  0, 0, false, true,  false, true,  NULL, NULL },\n   { NULL,                 0, 0, false, false, false, false, NULL, NULL }\n@@ -1396,6 +1496,287 @@ svpattern_token (enum aarch64_svpattern pattern)\n   gcc_unreachable ();\n }\n \n+/* Return the location of a piece that is known to be passed or returned\n+   in registers.  FIRST_ZR is the first unused vector argument register\n+   and FIRST_PR is the first unused predicate argument register.  */\n+\n+rtx\n+pure_scalable_type_info::piece::get_rtx (unsigned int first_zr,\n+\t\t\t\t\t unsigned int first_pr) const\n+{\n+  gcc_assert (VECTOR_MODE_P (mode)\n+\t      && first_zr + num_zr <= V0_REGNUM + NUM_FP_ARG_REGS\n+\t      && first_pr + num_pr <= P0_REGNUM + NUM_PR_ARG_REGS);\n+\n+  if (num_zr > 0 && num_pr == 0)\n+    return gen_rtx_REG (mode, first_zr);\n+\n+  if (num_zr == 0 && num_pr == 1)\n+    return gen_rtx_REG (mode, first_pr);\n+\n+  gcc_unreachable ();\n+}\n+\n+/* Return the total number of vector registers required by the PST.  */\n+\n+unsigned int\n+pure_scalable_type_info::num_zr () const\n+{\n+  unsigned int res = 0;\n+  for (unsigned int i = 0; i < pieces.length (); ++i)\n+    res += pieces[i].num_zr;\n+  return res;\n+}\n+\n+/* Return the total number of predicate registers required by the PST.  */\n+\n+unsigned int\n+pure_scalable_type_info::num_pr () const\n+{\n+  unsigned int res = 0;\n+  for (unsigned int i = 0; i < pieces.length (); ++i)\n+    res += pieces[i].num_pr;\n+  return res;\n+}\n+\n+/* Return the location of a PST that is known to be passed or returned\n+   in registers.  FIRST_ZR is the first unused vector argument register\n+   and FIRST_PR is the first unused predicate argument register.  */\n+\n+rtx\n+pure_scalable_type_info::get_rtx (machine_mode mode,\n+\t\t\t\t  unsigned int first_zr,\n+\t\t\t\t  unsigned int first_pr) const\n+{\n+  /* Try to return a single REG if possible.  This leads to better\n+     code generation; it isn't required for correctness.  */\n+  if (mode == pieces[0].mode)\n+    {\n+      gcc_assert (pieces.length () == 1);\n+      return pieces[0].get_rtx (first_zr, first_pr);\n+    }\n+\n+  /* Build up a PARALLEL that contains the individual pieces.  */\n+  rtvec rtxes = rtvec_alloc (pieces.length ());\n+  for (unsigned int i = 0; i < pieces.length (); ++i)\n+    {\n+      rtx reg = pieces[i].get_rtx (first_zr, first_pr);\n+      rtx offset = gen_int_mode (pieces[i].offset, Pmode);\n+      RTVEC_ELT (rtxes, i) = gen_rtx_EXPR_LIST (VOIDmode, reg, offset);\n+      first_zr += pieces[i].num_zr;\n+      first_pr += pieces[i].num_pr;\n+    }\n+  return gen_rtx_PARALLEL (mode, rtxes);\n+}\n+\n+/* Analyze whether TYPE is a Pure Scalable Type according to the rules\n+   in the AAPCS64.  */\n+\n+pure_scalable_type_info::analysis_result\n+pure_scalable_type_info::analyze (const_tree type)\n+{\n+  /* Prevent accidental reuse.  */\n+  gcc_assert (pieces.is_empty ());\n+\n+  /* No code will be generated for erroneous types, so we won't establish\n+     an ABI mapping.  */\n+  if (type == error_mark_node)\n+    return NO_ABI_IDENTITY;\n+\n+  /* Zero-sized types disappear in the language->ABI mapping.  */\n+  if (TYPE_SIZE (type) && integer_zerop (TYPE_SIZE (type)))\n+    return NO_ABI_IDENTITY;\n+\n+  /* Check for SVTs, SPTs, and built-in tuple types that map to PSTs.  */\n+  piece p = {};\n+  if (aarch64_sve::builtin_type_p (type, &p.num_zr, &p.num_pr))\n+    {\n+      machine_mode mode = TYPE_MODE_RAW (type);\n+      gcc_assert (VECTOR_MODE_P (mode)\n+\t\t  && (!TARGET_SVE || aarch64_sve_mode_p (mode)));\n+\n+      p.mode = p.orig_mode = mode;\n+      add_piece (p);\n+      return IS_PST;\n+    }\n+\n+  /* Check for user-defined PSTs.  */\n+  if (TREE_CODE (type) == ARRAY_TYPE)\n+    return analyze_array (type);\n+  if (TREE_CODE (type) == RECORD_TYPE)\n+    return analyze_record (type);\n+\n+  return ISNT_PST;\n+}\n+\n+/* Analyze a type that is known not to be passed or returned in memory.\n+   Return true if it has an ABI identity and is a Pure Scalable Type.  */\n+\n+bool\n+pure_scalable_type_info::analyze_registers (const_tree type)\n+{\n+  analysis_result result = analyze (type);\n+  gcc_assert (result != DOESNT_MATTER);\n+  return result == IS_PST;\n+}\n+\n+/* Subroutine of analyze for handling ARRAY_TYPEs.  */\n+\n+pure_scalable_type_info::analysis_result\n+pure_scalable_type_info::analyze_array (const_tree type)\n+{\n+  /* Analyze the element type.  */\n+  pure_scalable_type_info element_info;\n+  analysis_result result = element_info.analyze (TREE_TYPE (type));\n+  if (result != IS_PST)\n+    return result;\n+\n+  /* An array of unknown, flexible or variable length will be passed and\n+     returned by reference whatever we do.  */\n+  tree nelts_minus_one = array_type_nelts (type);\n+  if (!tree_fits_uhwi_p (nelts_minus_one))\n+    return DOESNT_MATTER;\n+\n+  /* Likewise if the array is constant-sized but too big to be interesting.\n+     The double checks against MAX_PIECES are to protect against overflow.  */\n+  unsigned HOST_WIDE_INT count = tree_to_uhwi (nelts_minus_one);\n+  if (count > MAX_PIECES)\n+    return DOESNT_MATTER;\n+  count += 1;\n+  if (count * element_info.pieces.length () > MAX_PIECES)\n+    return DOESNT_MATTER;\n+\n+  /* The above checks should have weeded out elements of unknown size.  */\n+  poly_uint64 element_bytes;\n+  if (!poly_int_tree_p (TYPE_SIZE_UNIT (TREE_TYPE (type)), &element_bytes))\n+    gcc_unreachable ();\n+\n+  /* Build up the list of individual vectors and predicates.  */\n+  gcc_assert (!element_info.pieces.is_empty ());\n+  for (unsigned int i = 0; i < count; ++i)\n+    for (unsigned int j = 0; j < element_info.pieces.length (); ++j)\n+      {\n+\tpiece p = element_info.pieces[j];\n+\tp.offset += i * element_bytes;\n+\tadd_piece (p);\n+      }\n+  return IS_PST;\n+}\n+\n+/* Subroutine of analyze for handling RECORD_TYPEs.  */\n+\n+pure_scalable_type_info::analysis_result\n+pure_scalable_type_info::analyze_record (const_tree type)\n+{\n+  for (tree field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+    {\n+      if (TREE_CODE (field) != FIELD_DECL)\n+\tcontinue;\n+\n+      /* Zero-sized fields disappear in the language->ABI mapping.  */\n+      if (DECL_SIZE (field) && integer_zerop (DECL_SIZE (field)))\n+\tcontinue;\n+\n+      /* All fields with an ABI identity must be PSTs for the record as\n+\t a whole to be a PST.  If any individual field is too big to be\n+\t interesting then the record is too.  */\n+      pure_scalable_type_info field_info;\n+      analysis_result subresult = field_info.analyze (TREE_TYPE (field));\n+      if (subresult == NO_ABI_IDENTITY)\n+\tcontinue;\n+      if (subresult != IS_PST)\n+\treturn subresult;\n+\n+      /* Since all previous fields are PSTs, we ought to be able to track\n+\t the field offset using poly_ints.  */\n+      tree bitpos = bit_position (field);\n+      gcc_assert (poly_int_tree_p (bitpos));\n+\n+      /* For the same reason, it shouldn't be possible to create a PST field\n+\t whose offset isn't byte-aligned.  */\n+      poly_widest_int wide_bytepos = exact_div (wi::to_poly_widest (bitpos),\n+\t\t\t\t\t\tBITS_PER_UNIT);\n+\n+      /* Punt if the record is too big to be interesting.  */\n+      poly_uint64 bytepos;\n+      if (!wide_bytepos.to_uhwi (&bytepos)\n+\t  || pieces.length () + field_info.pieces.length () > MAX_PIECES)\n+\treturn DOESNT_MATTER;\n+\n+      /* Add the individual vectors and predicates in the field to the\n+\t record's list.  */\n+      gcc_assert (!field_info.pieces.is_empty ());\n+      for (unsigned int i = 0; i < field_info.pieces.length (); ++i)\n+\t{\n+\t  piece p = field_info.pieces[i];\n+\t  p.offset += bytepos;\n+\t  add_piece (p);\n+\t}\n+    }\n+  /* Empty structures disappear in the language->ABI mapping.  */\n+  return pieces.is_empty () ? NO_ABI_IDENTITY : IS_PST;\n+}\n+\n+/* Add P to the list of pieces in the type.  */\n+\n+void\n+pure_scalable_type_info::add_piece (const piece &p)\n+{\n+  /* Try to fold the new piece into the previous one to form a\n+     single-mode PST.  For example, if we see three consecutive vectors\n+     of the same mode, we can represent them using the corresponding\n+     3-tuple mode.\n+\n+     This is purely an optimization.  */\n+  if (!pieces.is_empty ())\n+    {\n+      piece &prev = pieces.last ();\n+      gcc_assert (VECTOR_MODE_P (p.mode) && VECTOR_MODE_P (prev.mode));\n+      unsigned int nelems1, nelems2;\n+      if (prev.orig_mode == p.orig_mode\n+\t  && known_eq (prev.offset + GET_MODE_SIZE (prev.mode), p.offset)\n+\t  && constant_multiple_p (GET_MODE_NUNITS (prev.mode),\n+\t\t\t\t  GET_MODE_NUNITS (p.orig_mode), &nelems1)\n+\t  && constant_multiple_p (GET_MODE_NUNITS (p.mode),\n+\t\t\t\t  GET_MODE_NUNITS (p.orig_mode), &nelems2)\n+\t  && targetm.array_mode (p.orig_mode,\n+\t\t\t\t nelems1 + nelems2).exists (&prev.mode))\n+\t{\n+\t  prev.num_zr += p.num_zr;\n+\t  prev.num_pr += p.num_pr;\n+\t  return;\n+\t}\n+    }\n+  pieces.quick_push (p);\n+}\n+\n+/* Return true if at least one possible value of type TYPE includes at\n+   least one object of Pure Scalable Type, in the sense of the AAPCS64.\n+\n+   This is a relatively expensive test for some types, so it should\n+   generally be made as late as possible.  */\n+\n+static bool\n+aarch64_some_values_include_pst_objects_p (const_tree type)\n+{\n+  if (TYPE_SIZE (type) && integer_zerop (TYPE_SIZE (type)))\n+    return false;\n+\n+  if (aarch64_sve::builtin_type_p (type))\n+    return true;\n+\n+  if (TREE_CODE (type) == ARRAY_TYPE || TREE_CODE (type) == COMPLEX_TYPE)\n+    return aarch64_some_values_include_pst_objects_p (TREE_TYPE (type));\n+\n+  if (RECORD_OR_UNION_TYPE_P (type))\n+    for (tree field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+      if (TREE_CODE (field) == FIELD_DECL\n+\t  && aarch64_some_values_include_pst_objects_p (TREE_TYPE (field)))\n+\treturn true;\n+\n+  return false;\n+}\n+\n /* Return the descriptor of the SIMD ABI.  */\n \n static const predefined_function_abi &\n@@ -2045,20 +2426,30 @@ aarch64_hard_regno_mode_ok (unsigned regno, machine_mode mode)\n   return false;\n }\n \n-/* Return true if TYPE is a type that should be passed or returned in\n-   SVE registers, assuming enough registers are available.  When returning\n-   true, set *NUM_ZR and *NUM_PR to the number of required Z and P registers\n-   respectively.  */\n-\n /* Return true if a function with type FNTYPE returns its value in\n    SVE vector or predicate registers.  */\n \n static bool\n aarch64_returns_value_in_sve_regs_p (const_tree fntype)\n {\n   tree return_type = TREE_TYPE (fntype);\n-  return (return_type != error_mark_node\n-\t  && aarch64_sve::builtin_type_p (return_type));\n+\n+  pure_scalable_type_info pst_info;\n+  switch (pst_info.analyze (return_type))\n+    {\n+    case pure_scalable_type_info::IS_PST:\n+      return (pst_info.num_zr () <= NUM_FP_ARG_REGS\n+\t      && pst_info.num_pr () <= NUM_PR_ARG_REGS);\n+\n+    case pure_scalable_type_info::DOESNT_MATTER:\n+      gcc_assert (aarch64_return_in_memory_1 (return_type));\n+      return false;\n+\n+    case pure_scalable_type_info::NO_ABI_IDENTITY:\n+    case pure_scalable_type_info::ISNT_PST:\n+      return false;\n+    }\n+  gcc_unreachable ();\n }\n \n /* Return true if a function with type FNTYPE takes arguments in\n@@ -2082,8 +2473,14 @@ aarch64_takes_arguments_in_sve_regs_p (const_tree fntype)\n \n       function_arg_info arg (arg_type, /*named=*/true);\n       apply_pass_by_reference_rules (&args_so_far_v, arg);\n-      if (aarch64_sve::builtin_type_p (arg.type))\n-\treturn true;\n+      pure_scalable_type_info pst_info;\n+      if (pst_info.analyze_registers (arg.type))\n+\t{\n+\t  unsigned int end_zr = args_so_far_v.aapcs_nvrn + pst_info.num_zr ();\n+\t  unsigned int end_pr = args_so_far_v.aapcs_nprn + pst_info.num_pr ();\n+\t  gcc_assert (end_zr <= NUM_FP_ARG_REGS && end_pr <= NUM_PR_ARG_REGS);\n+\t  return true;\n+\t}\n \n       targetm.calls.function_arg_advance (args_so_far, arg);\n     }\n@@ -4884,33 +5281,16 @@ aarch64_function_ok_for_sibcall (tree, tree exp)\n   return true;\n }\n \n-/* Implement TARGET_PASS_BY_REFERENCE.  */\n+/* Subroutine of aarch64_pass_by_reference for arguments that are not\n+   passed in SVE registers.  */\n \n static bool\n-aarch64_pass_by_reference (cumulative_args_t pcum_v,\n-\t\t\t   const function_arg_info &arg)\n+aarch64_pass_by_reference_1 (const function_arg_info &arg)\n {\n-  CUMULATIVE_ARGS *pcum = get_cumulative_args (pcum_v);\n   HOST_WIDE_INT size;\n   machine_mode dummymode;\n   int nregs;\n \n-  unsigned int num_zr, num_pr;\n-  if (arg.type && aarch64_sve::builtin_type_p (arg.type, &num_zr, &num_pr))\n-    {\n-      if (pcum && !pcum->silent_p && !TARGET_SVE)\n-\t/* We can't gracefully recover at this point, so make this a\n-\t   fatal error.  */\n-\tfatal_error (input_location, \"arguments of type %qT require\"\n-\t\t     \" the SVE ISA extension\", arg.type);\n-\n-      /* Variadic SVE types are passed by reference.  Normal non-variadic\n-\t arguments are too if we've run out of registers.  */\n-      return (!arg.named\n-\t      || pcum->aapcs_nvrn + num_zr > NUM_FP_ARG_REGS\n-\t      || pcum->aapcs_nprn + num_pr > NUM_PR_ARG_REGS);\n-    }\n-\n   /* GET_MODE_SIZE (BLKmode) is useless since it is 0.  */\n   if (arg.mode == BLKmode && arg.type)\n     size = int_size_in_bytes (arg.type);\n@@ -4939,6 +5319,44 @@ aarch64_pass_by_reference (cumulative_args_t pcum_v,\n   return size > 2 * UNITS_PER_WORD;\n }\n \n+/* Implement TARGET_PASS_BY_REFERENCE.  */\n+\n+static bool\n+aarch64_pass_by_reference (cumulative_args_t pcum_v,\n+\t\t\t   const function_arg_info &arg)\n+{\n+  CUMULATIVE_ARGS *pcum = get_cumulative_args (pcum_v);\n+\n+  if (!arg.type)\n+    return aarch64_pass_by_reference_1 (arg);\n+\n+  pure_scalable_type_info pst_info;\n+  switch (pst_info.analyze (arg.type))\n+    {\n+    case pure_scalable_type_info::IS_PST:\n+      if (pcum && !pcum->silent_p && !TARGET_SVE)\n+\t/* We can't gracefully recover at this point, so make this a\n+\t   fatal error.  */\n+\tfatal_error (input_location, \"arguments of type %qT require\"\n+\t\t     \" the SVE ISA extension\", arg.type);\n+\n+      /* Variadic SVE types are passed by reference.  Normal non-variadic\n+\t arguments are too if we've run out of registers.  */\n+      return (!arg.named\n+\t      || pcum->aapcs_nvrn + pst_info.num_zr () > NUM_FP_ARG_REGS\n+\t      || pcum->aapcs_nprn + pst_info.num_pr () > NUM_PR_ARG_REGS);\n+\n+    case pure_scalable_type_info::DOESNT_MATTER:\n+      gcc_assert (aarch64_pass_by_reference_1 (arg));\n+      return true;\n+\n+    case pure_scalable_type_info::NO_ABI_IDENTITY:\n+    case pure_scalable_type_info::ISNT_PST:\n+      return aarch64_pass_by_reference_1 (arg);\n+    }\n+  gcc_unreachable ();\n+}\n+\n /* Return TRUE if VALTYPE is padded to its least significant bits.  */\n static bool\n aarch64_return_in_msb (const_tree valtype)\n@@ -4965,37 +5383,36 @@ aarch64_return_in_msb (const_tree valtype)\n \t\t\t\t\t       &dummy_mode, &dummy_int, NULL))\n     return false;\n \n+  /* Likewise pure scalable types for SVE vector and predicate registers.  */\n+  pure_scalable_type_info pst_info;\n+  if (pst_info.analyze_registers (valtype))\n+    return false;\n+\n   return true;\n }\n \n-/* Subroutine of aarch64_function_value.  MODE is the mode of the argument\n-   after promotion, and after partial SVE types have been replaced by\n-   their integer equivalents.  */\n+/* Implement TARGET_FUNCTION_VALUE.\n+   Define how to find the value returned by a function.  */\n+\n static rtx\n-aarch64_function_value_1 (const_tree type, machine_mode mode)\n+aarch64_function_value (const_tree type, const_tree func,\n+\t\t\tbool outgoing ATTRIBUTE_UNUSED)\n {\n-  unsigned int num_zr, num_pr;\n-  if (type && aarch64_sve::builtin_type_p (type, &num_zr, &num_pr))\n-    {\n-      /* Don't raise an error here if we're called when SVE is disabled,\n-\t since this is really just a query function.  Other code must\n-\t do that where appropriate.  */\n-      mode = TYPE_MODE_RAW (type);\n-      gcc_assert (VECTOR_MODE_P (mode)\n-\t\t  && (!TARGET_SVE || aarch64_sve_mode_p (mode)));\n-\n-      if (num_zr > 0 && num_pr == 0)\n-\treturn gen_rtx_REG (mode, V0_REGNUM);\n+  machine_mode mode;\n+  int unsignedp;\n \n-      if (num_zr == 0 && num_pr == 1)\n-\treturn gen_rtx_REG (mode, P0_REGNUM);\n+  mode = TYPE_MODE (type);\n+  if (INTEGRAL_TYPE_P (type))\n+    mode = promote_function_mode (type, mode, &unsignedp, func, 1);\n \n-      gcc_unreachable ();\n-    }\n+  pure_scalable_type_info pst_info;\n+  if (type && pst_info.analyze_registers (type))\n+    return pst_info.get_rtx (mode, V0_REGNUM, P0_REGNUM);\n \n-  /* Generic vectors that map to SVE modes with -msve-vector-bits=N are\n-     returned in memory, not by value.  */\n-  gcc_assert (!aarch64_sve_mode_p (mode));\n+  /* Generic vectors that map to full SVE modes with -msve-vector-bits=N\n+     are returned in memory, not by value.  */\n+  unsigned int vec_flags = aarch64_classify_vector_mode (mode);\n+  bool sve_p = (vec_flags & VEC_ANY_SVE);\n \n   if (aarch64_return_in_msb (type))\n     {\n@@ -5013,6 +5430,7 @@ aarch64_function_value_1 (const_tree type, machine_mode mode)\n   if (aarch64_vfp_is_call_or_return_candidate (mode, type,\n \t\t\t\t\t       &ag_mode, &count, NULL))\n     {\n+      gcc_assert (!sve_p);\n       if (!aarch64_composite_type_p (type, mode))\n \t{\n \t  gcc_assert (count == 1 && mode == ag_mode);\n@@ -5035,43 +5453,29 @@ aarch64_function_value_1 (const_tree type, machine_mode mode)\n \t}\n     }\n   else\n-    return gen_rtx_REG (mode, R0_REGNUM);\n-}\n-\n-/* Implement TARGET_FUNCTION_VALUE.\n-   Define how to find the value returned by a function.  */\n-\n-static rtx\n-aarch64_function_value (const_tree type, const_tree func,\n-\t\t\tbool outgoing ATTRIBUTE_UNUSED)\n-{\n-  machine_mode mode;\n-  int unsignedp;\n-\n-  mode = TYPE_MODE (type);\n-  if (INTEGRAL_TYPE_P (type))\n-    mode = promote_function_mode (type, mode, &unsignedp, func, 1);\n-\n-  /* Vector types can acquire a partial SVE mode using things like\n-     __attribute__((vector_size(N))), and this is potentially useful.\n-     However, the choice of mode doesn't affect the type's ABI identity,\n-     so we should treat the types as though they had the associated\n-     integer mode, just like they did before SVE was introduced.\n-\n-     We know that the vector must be 128 bits or smaller, otherwise we'd\n-     have returned it in memory instead.  */\n-  unsigned int vec_flags = aarch64_classify_vector_mode (mode);\n-  if ((vec_flags & VEC_ANY_SVE) && (vec_flags & VEC_PARTIAL))\n     {\n-      scalar_int_mode int_mode = int_mode_for_mode (mode).require ();\n-      rtx reg = aarch64_function_value_1 (type, int_mode);\n-      /* Vector types are never returned in the MSB and are never split.  */\n-      gcc_assert (REG_P (reg) && GET_MODE (reg) == int_mode);\n-      rtx pair = gen_rtx_EXPR_LIST (VOIDmode, reg, const0_rtx);\n-      return gen_rtx_PARALLEL (VOIDmode, gen_rtvec (1, pair));\n+      if (sve_p)\n+\t{\n+\t  /* Vector types can acquire a partial SVE mode using things like\n+\t     __attribute__((vector_size(N))), and this is potentially useful.\n+\t     However, the choice of mode doesn't affect the type's ABI\n+\t     identity, so we should treat the types as though they had\n+\t     the associated integer mode, just like they did before SVE\n+\t     was introduced.\n+\n+\t     We know that the vector must be 128 bits or smaller,\n+\t     otherwise we'd have returned it in memory instead.  */\n+\t  gcc_assert (type\n+\t\t      && (aarch64_some_values_include_pst_objects_p (type)\n+\t\t\t  || (vec_flags & VEC_PARTIAL)));\n+\n+\t  scalar_int_mode int_mode = int_mode_for_mode (mode).require ();\n+\t  rtx reg = gen_rtx_REG (int_mode, R0_REGNUM);\n+\t  rtx pair = gen_rtx_EXPR_LIST (VOIDmode, reg, const0_rtx);\n+\t  return gen_rtx_PARALLEL (mode, gen_rtvec (1, pair));\n+\t}\n+      return gen_rtx_REG (mode, R0_REGNUM);\n     }\n-\n-  return aarch64_function_value_1 (type, mode);\n }\n \n /* Implements TARGET_FUNCTION_VALUE_REGNO_P.\n@@ -5095,17 +5499,11 @@ aarch64_function_value_regno_p (const unsigned int regno)\n   return false;\n }\n \n-/* Implement TARGET_RETURN_IN_MEMORY.\n-\n-   If the type T of the result of a function is such that\n-     void func (T arg)\n-   would require that arg be passed as a value in a register (or set of\n-   registers) according to the parameter passing rules, then the result\n-   is returned in the same registers as would be used for such an\n-   argument.  */\n+/* Subroutine for aarch64_return_in_memory for types that are not returned\n+   in SVE registers.  */\n \n static bool\n-aarch64_return_in_memory (const_tree type, const_tree fndecl ATTRIBUTE_UNUSED)\n+aarch64_return_in_memory_1 (const_tree type)\n {\n   HOST_WIDE_INT size;\n   machine_mode ag_mode;\n@@ -5117,16 +5515,6 @@ aarch64_return_in_memory (const_tree type, const_tree fndecl ATTRIBUTE_UNUSED)\n     /* Simple scalar types always returned in registers.  */\n     return false;\n \n-  unsigned int num_zr, num_pr;\n-  if (type && aarch64_sve::builtin_type_p (type, &num_zr, &num_pr))\n-    {\n-      /* All SVE types we support fit in registers.  For example, it isn't\n-\t yet possible to define an aggregate of 9+ SVE vectors or 5+ SVE\n-\t predicates.  */\n-      gcc_assert (num_zr <= NUM_FP_ARG_REGS && num_pr <= NUM_PR_ARG_REGS);\n-      return false;\n-    }\n-\n   if (aarch64_vfp_is_call_or_return_candidate (TYPE_MODE (type),\n \t\t\t\t\t       type,\n \t\t\t\t\t       &ag_mode,\n@@ -5139,6 +5527,36 @@ aarch64_return_in_memory (const_tree type, const_tree fndecl ATTRIBUTE_UNUSED)\n   return (size < 0 || size > 2 * UNITS_PER_WORD);\n }\n \n+/* Implement TARGET_RETURN_IN_MEMORY.\n+\n+   If the type T of the result of a function is such that\n+     void func (T arg)\n+   would require that arg be passed as a value in a register (or set of\n+   registers) according to the parameter passing rules, then the result\n+   is returned in the same registers as would be used for such an\n+   argument.  */\n+\n+static bool\n+aarch64_return_in_memory (const_tree type, const_tree fndecl ATTRIBUTE_UNUSED)\n+{\n+  pure_scalable_type_info pst_info;\n+  switch (pst_info.analyze (type))\n+    {\n+    case pure_scalable_type_info::IS_PST:\n+      return (pst_info.num_zr () > NUM_FP_ARG_REGS\n+\t      || pst_info.num_pr () > NUM_PR_ARG_REGS);\n+\n+    case pure_scalable_type_info::DOESNT_MATTER:\n+      gcc_assert (aarch64_return_in_memory_1 (type));\n+      return true;\n+\n+    case pure_scalable_type_info::NO_ABI_IDENTITY:\n+    case pure_scalable_type_info::ISNT_PST:\n+      return aarch64_return_in_memory_1 (type);\n+    }\n+  gcc_unreachable ();\n+}\n+\n static bool\n aarch64_vfp_is_call_candidate (cumulative_args_t pcum_v, machine_mode mode,\n \t\t\t       const_tree type, int *nregs)\n@@ -5205,8 +5623,7 @@ aarch64_function_arg_alignment (machine_mode mode, const_tree type,\n    the equivalent integer mode.  */\n \n static void\n-aarch64_layout_arg (cumulative_args_t pcum_v, const function_arg_info &arg,\n-\t\t    machine_mode orig_mode)\n+aarch64_layout_arg (cumulative_args_t pcum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *pcum = get_cumulative_args (pcum_v);\n   tree type = arg.type;\n@@ -5220,33 +5637,10 @@ aarch64_layout_arg (cumulative_args_t pcum_v, const function_arg_info &arg,\n   if (pcum->aapcs_arg_processed)\n     return;\n \n-  /* Vector types can acquire a partial SVE mode using things like\n-     __attribute__((vector_size(N))), and this is potentially useful.\n-     However, the choice of mode doesn't affect the type's ABI identity,\n-     so we should treat the types as though they had the associated\n-     integer mode, just like they did before SVE was introduced.\n-\n-     We know that the vector must be 128 bits or smaller, otherwise we'd\n-     have passed it by reference instead.  */\n-  unsigned int vec_flags = aarch64_classify_vector_mode (mode);\n-  if ((vec_flags & VEC_ANY_SVE) && (vec_flags & VEC_PARTIAL))\n-    {\n-      function_arg_info tmp_arg = arg;\n-      tmp_arg.mode = int_mode_for_mode (mode).require ();\n-      aarch64_layout_arg (pcum_v, tmp_arg, orig_mode);\n-      if (rtx reg = pcum->aapcs_reg)\n-\t{\n-\t  gcc_assert (REG_P (reg) && GET_MODE (reg) == tmp_arg.mode);\n-\t  rtx pair = gen_rtx_EXPR_LIST (VOIDmode, reg, const0_rtx);\n-\t  pcum->aapcs_reg = gen_rtx_PARALLEL (mode, gen_rtvec (1, pair));\n-\t}\n-      return;\n-    }\n-\n   pcum->aapcs_arg_processed = true;\n \n-  unsigned int num_zr, num_pr;\n-  if (type && aarch64_sve::builtin_type_p (type, &num_zr, &num_pr))\n+  pure_scalable_type_info pst_info;\n+  if (type && pst_info.analyze_registers (type))\n     {\n       /* The PCS says that it is invalid to pass an SVE value to an\n \t unprototyped function.  There is no ABI-defined location we\n@@ -5264,26 +5658,34 @@ aarch64_layout_arg (cumulative_args_t pcum_v, const function_arg_info &arg,\n \n       /* We would have converted the argument into pass-by-reference\n \t form if it didn't fit in registers.  */\n-      pcum->aapcs_nextnvrn = pcum->aapcs_nvrn + num_zr;\n-      pcum->aapcs_nextnprn = pcum->aapcs_nprn + num_pr;\n+      pcum->aapcs_nextnvrn = pcum->aapcs_nvrn + pst_info.num_zr ();\n+      pcum->aapcs_nextnprn = pcum->aapcs_nprn + pst_info.num_pr ();\n       gcc_assert (arg.named\n \t\t  && pcum->pcs_variant == ARM_PCS_SVE\n-\t\t  && aarch64_sve_mode_p (mode)\n \t\t  && pcum->aapcs_nextnvrn <= NUM_FP_ARG_REGS\n \t\t  && pcum->aapcs_nextnprn <= NUM_PR_ARG_REGS);\n-\n-      if (num_zr > 0 && num_pr == 0)\n-\tpcum->aapcs_reg = gen_rtx_REG (mode, V0_REGNUM + pcum->aapcs_nvrn);\n-      else if (num_zr == 0 && num_pr == 1)\n-\tpcum->aapcs_reg = gen_rtx_REG (mode, P0_REGNUM + pcum->aapcs_nprn);\n-      else\n-\tgcc_unreachable ();\n+      pcum->aapcs_reg = pst_info.get_rtx (mode, V0_REGNUM + pcum->aapcs_nvrn,\n+\t\t\t\t\t  P0_REGNUM + pcum->aapcs_nprn);\n       return;\n     }\n \n-  /* Generic vectors that map to SVE modes with -msve-vector-bits=N are\n-     passed by reference, not by value.  */\n-  gcc_assert (!aarch64_sve_mode_p (mode));\n+  /* Generic vectors that map to full SVE modes with -msve-vector-bits=N\n+     are passed by reference, not by value.  */\n+  unsigned int vec_flags = aarch64_classify_vector_mode (mode);\n+  bool sve_p = (vec_flags & VEC_ANY_SVE);\n+  if (sve_p)\n+    /* Vector types can acquire a partial SVE mode using things like\n+       __attribute__((vector_size(N))), and this is potentially useful.\n+       However, the choice of mode doesn't affect the type's ABI\n+       identity, so we should treat the types as though they had\n+       the associated integer mode, just like they did before SVE\n+       was introduced.\n+\n+       We know that the vector must be 128 bits or smaller,\n+       otherwise we'd have passed it in memory instead.  */\n+    gcc_assert (type\n+\t\t&& (aarch64_some_values_include_pst_objects_p (type)\n+\t\t    || (vec_flags & VEC_PARTIAL)));\n \n   /* Size in bytes, rounded to the nearest multiple of 8 bytes.  */\n   if (type)\n@@ -5299,6 +5701,7 @@ aarch64_layout_arg (cumulative_args_t pcum_v, const function_arg_info &arg,\n \t\t\t\t\t\t mode,\n \t\t\t\t\t\t type,\n \t\t\t\t\t\t &nregs);\n+  gcc_assert (!sve_p || !allocate_nvrn);\n \n   /* allocate_ncrn may be false-positive, but allocate_nvrn is quite reliable.\n      The following code thus handles passing by SIMD/FP registers first.  */\n@@ -5364,7 +5767,7 @@ aarch64_layout_arg (cumulative_args_t pcum_v, const function_arg_info &arg,\n \t     comparison is there because for > 16 * BITS_PER_UNIT\n \t     alignment nregs should be > 2 and therefore it should be\n \t     passed by reference rather than value.  */\n-\t  && (aarch64_function_arg_alignment (orig_mode, type, &abi_break)\n+\t  && (aarch64_function_arg_alignment (mode, type, &abi_break)\n \t      == 16 * BITS_PER_UNIT))\n \t{\n \t  if (abi_break && warn_psabi && currently_expanding_gimple_stmt)\n@@ -5374,10 +5777,24 @@ aarch64_layout_arg (cumulative_args_t pcum_v, const function_arg_info &arg,\n \t  gcc_assert (ncrn + nregs <= NUM_ARG_REGS);\n \t}\n \n+      /* If an argument with an SVE mode needs to be shifted up to the\n+\t high part of the register, treat it as though it had an integer mode.\n+\t Using the normal (parallel [...]) would suppress the shifting.  */\n+      if (sve_p\n+\t  && BYTES_BIG_ENDIAN\n+\t  && maybe_ne (GET_MODE_SIZE (mode), nregs * UNITS_PER_WORD)\n+\t  && aarch64_pad_reg_upward (mode, type, false))\n+\t{\n+\t  mode = int_mode_for_mode (mode).require ();\n+\t  sve_p = false;\n+\t}\n+\n       /* NREGS can be 0 when e.g. an empty structure is to be passed.\n \t A reg is still generated for it, but the caller should be smart\n \t enough not to use it.  */\n-      if (nregs == 0 || nregs == 1 || GET_MODE_CLASS (mode) == MODE_INT)\n+      if (nregs == 0\n+\t  || (nregs == 1 && !sve_p)\n+\t  || GET_MODE_CLASS (mode) == MODE_INT)\n \tpcum->aapcs_reg = gen_rtx_REG (mode, R0_REGNUM + ncrn);\n       else\n \t{\n@@ -5387,7 +5804,10 @@ aarch64_layout_arg (cumulative_args_t pcum_v, const function_arg_info &arg,\n \t  par = gen_rtx_PARALLEL (mode, rtvec_alloc (nregs));\n \t  for (i = 0; i < nregs; i++)\n \t    {\n-\t      rtx tmp = gen_rtx_REG (word_mode, R0_REGNUM + ncrn + i);\n+\t      scalar_int_mode reg_mode = word_mode;\n+\t      if (nregs == 1)\n+\t\treg_mode = int_mode_for_mode (mode).require ();\n+\t      rtx tmp = gen_rtx_REG (reg_mode, R0_REGNUM + ncrn + i);\n \t      tmp = gen_rtx_EXPR_LIST (VOIDmode, tmp,\n \t\t\t\t       GEN_INT (i * UNITS_PER_WORD));\n \t      XVECEXP (par, 0, i) = tmp;\n@@ -5407,7 +5827,7 @@ aarch64_layout_arg (cumulative_args_t pcum_v, const function_arg_info &arg,\n on_stack:\n   pcum->aapcs_stack_words = size / UNITS_PER_WORD;\n \n-  if (aarch64_function_arg_alignment (orig_mode, type, &abi_break)\n+  if (aarch64_function_arg_alignment (mode, type, &abi_break)\n       == 16 * BITS_PER_UNIT)\n     {\n       int new_size = ROUND_UP (pcum->aapcs_stack_size, 16 / UNITS_PER_WORD);\n@@ -5435,7 +5855,7 @@ aarch64_function_arg (cumulative_args_t pcum_v, const function_arg_info &arg)\n   if (arg.end_marker_p ())\n     return gen_int_mode (pcum->pcs_variant, DImode);\n \n-  aarch64_layout_arg (pcum_v, arg, arg.mode);\n+  aarch64_layout_arg (pcum_v, arg);\n   return pcum->aapcs_reg;\n }\n \n@@ -5500,7 +5920,7 @@ aarch64_function_arg_advance (cumulative_args_t pcum_v,\n       || pcum->pcs_variant == ARM_PCS_SIMD\n       || pcum->pcs_variant == ARM_PCS_SVE)\n     {\n-      aarch64_layout_arg (pcum_v, arg, arg.mode);\n+      aarch64_layout_arg (pcum_v, arg);\n       gcc_assert ((pcum->aapcs_reg != NULL_RTX)\n \t\t  != (pcum->aapcs_stack_words != 0));\n       pcum->aapcs_arg_processed = false;\n@@ -5609,7 +6029,8 @@ aarch64_pad_reg_upward (machine_mode mode, const_tree type,\n \t\t     bool first ATTRIBUTE_UNUSED)\n {\n \n-  /* Small composite types are always padded upward.  */\n+  /* Aside from pure scalable types, small composite types are always\n+     padded upward.  */\n   if (BYTES_BIG_ENDIAN && aarch64_composite_type_p (type, mode))\n     {\n       HOST_WIDE_INT size;\n@@ -5620,7 +6041,12 @@ aarch64_pad_reg_upward (machine_mode mode, const_tree type,\n \t   shouldn't be asked to pass or return them.  */\n \tsize = GET_MODE_SIZE (mode).to_constant ();\n       if (size < 2 * UNITS_PER_WORD)\n-\treturn true;\n+\t{\n+\t  pure_scalable_type_info pst_info;\n+\t  if (pst_info.analyze_registers (type))\n+\t    return false;\n+\t  return true;\n+\t}\n     }\n \n   /* Otherwise, use the default padding.  */\n@@ -15913,6 +16339,30 @@ aarch64_conditional_register_usage (void)\n     }\n }\n \n+/* Implement TARGET_MEMBER_TYPE_FORCES_BLK.  */\n+\n+bool\n+aarch64_member_type_forces_blk (const_tree field_or_array, machine_mode mode)\n+{\n+  /* For records we're passed a FIELD_DECL, for arrays we're passed\n+     an ARRAY_TYPE.  In both cases we're interested in the TREE_TYPE.  */\n+  const_tree type = TREE_TYPE (field_or_array);\n+\n+  /* Assign BLKmode to anything that contains multiple SVE predicates.\n+     For structures, the \"multiple\" case is indicated by MODE being\n+     VOIDmode.  */\n+  unsigned int num_zr, num_pr;\n+  if (aarch64_sve::builtin_type_p (type, &num_zr, &num_pr) && num_pr != 0)\n+    {\n+      if (TREE_CODE (field_or_array) == ARRAY_TYPE)\n+\treturn !simple_cst_equal (TYPE_SIZE (field_or_array),\n+\t\t\t\t  TYPE_SIZE (type));\n+      return mode == VOIDmode;\n+    }\n+\n+  return default_member_type_forces_blk (field_or_array, mode);\n+}\n+\n /* Walk down the type tree of TYPE counting consecutive base elements.\n    If *MODEP is VOIDmode, then set it to the first valid floating point\n    type.  If a non-floating point type is found, or if a floating point\n@@ -15924,9 +16374,8 @@ aapcs_vfp_sub_candidate (const_tree type, machine_mode *modep)\n   machine_mode mode;\n   HOST_WIDE_INT size;\n \n-  /* SVE types (and types containing SVE types) must be handled\n-     before calling this function.  */\n-  gcc_assert (!aarch64_sve::builtin_type_p (type));\n+  if (aarch64_sve::builtin_type_p (type))\n+    return -1;\n \n   switch (TREE_CODE (type))\n     {\n@@ -16099,16 +16548,29 @@ aarch64_short_vector_p (const_tree type,\n {\n   poly_int64 size = -1;\n \n-  if (type && aarch64_sve::builtin_type_p (type))\n-    return false;\n-\n   if (type && TREE_CODE (type) == VECTOR_TYPE)\n-    size = int_size_in_bytes (type);\n+    {\n+      if (aarch64_sve::builtin_type_p (type))\n+\treturn false;\n+      size = int_size_in_bytes (type);\n+    }\n   else if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT\n-\t    || GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT)\n-    size = GET_MODE_SIZE (mode);\n-\n-  return known_eq (size, 8) || known_eq (size, 16);\n+\t   || GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT)\n+    {\n+      /* Rely only on the type, not the mode, when processing SVE types.  */\n+      if (type && aarch64_some_values_include_pst_objects_p (type))\n+\tgcc_assert (aarch64_sve_mode_p (mode));\n+      else\n+\tsize = GET_MODE_SIZE (mode);\n+    }\n+  if (known_eq (size, 8) || known_eq (size, 16))\n+    {\n+      /* 64-bit and 128-bit vectors should only acquire an SVE mode if\n+\t they are being treated as scalable AAPCS64 types.  */\n+      gcc_assert (!aarch64_sve_mode_p (mode));\n+      return true;\n+    }\n+  return false;\n }\n \n /* Return TRUE if the type, as described by TYPE and MODE, is a composite\n@@ -16164,9 +16626,6 @@ aarch64_vfp_is_call_or_return_candidate (machine_mode mode,\n {\n   if (is_ha != NULL) *is_ha = false;\n \n-  if (type && aarch64_sve::builtin_type_p (type))\n-    return false;\n-\n   machine_mode new_mode = VOIDmode;\n   bool composite_p = aarch64_composite_type_p (type, mode);\n \n@@ -16197,6 +16656,7 @@ aarch64_vfp_is_call_or_return_candidate (machine_mode mode,\n   else\n     return false;\n \n+  gcc_assert (!aarch64_sve_mode_p (new_mode));\n   *base_mode = new_mode;\n   return true;\n }\n@@ -21695,6 +22155,16 @@ aarch64_can_change_mode_class (machine_mode from,\n   bool from_partial_sve_p = from_sve_p && (from_flags & VEC_PARTIAL);\n   bool to_partial_sve_p = to_sve_p && (to_flags & VEC_PARTIAL);\n \n+  bool from_pred_p = (from_flags & VEC_SVE_PRED);\n+  bool to_pred_p = (to_flags & VEC_SVE_PRED);\n+\n+  /* Don't allow changes between predicate modes and other modes.\n+     Only predicate registers can hold predicate modes and only\n+     non-predicate registers can hold non-predicate modes, so any\n+     attempt to mix them would require a round trip through memory.  */\n+  if (from_pred_p != to_pred_p)\n+    return false;\n+\n   /* Don't allow changes between partial SVE modes and other modes.\n      The contents of partial SVE modes are distributed evenly across\n      the register, whereas GCC expects them to be clustered together.  */\n@@ -21708,6 +22178,18 @@ aarch64_can_change_mode_class (machine_mode from,\n \t  || GET_MODE_UNIT_SIZE (from) != GET_MODE_UNIT_SIZE (to)))\n     return false;\n \n+  if (maybe_ne (BITS_PER_SVE_VECTOR, 128u))\n+    {\n+      /* Don't allow changes between SVE modes and other modes that might\n+\t be bigger than 128 bits.  In particular, OImode, CImode and XImode\n+\t divide into 128-bit quantities while SVE modes divide into\n+\t BITS_PER_SVE_VECTOR quantities.  */\n+      if (from_sve_p && !to_sve_p && maybe_gt (GET_MODE_BITSIZE (to), 128))\n+\treturn false;\n+      if (to_sve_p && !from_sve_p && maybe_gt (GET_MODE_BITSIZE (from), 128))\n+\treturn false;\n+    }\n+\n   if (BYTES_BIG_ENDIAN)\n     {\n       /* Don't allow changes between SVE data modes and non-SVE modes.\n@@ -22003,6 +22485,14 @@ aarch64_invalid_binary_op (int op ATTRIBUTE_UNUSED, const_tree type1,\n       || element_mode (type2) == BFmode)\n     return N_(\"operation not permitted on type %<bfloat16_t%>\");\n \n+  if (VECTOR_TYPE_P (type1)\n+      && VECTOR_TYPE_P (type2)\n+      && !TYPE_INDIVISIBLE_P (type1)\n+      && !TYPE_INDIVISIBLE_P (type2)\n+      && (aarch64_sve::builtin_type_p (type1)\n+\t  != aarch64_sve::builtin_type_p (type2)))\n+    return N_(\"cannot combine GNU and SVE vectors in a binary operation\");\n+\n   /* Operation allowed.  */\n   return NULL;\n }\n@@ -22167,6 +22657,9 @@ aarch64_run_selftests (void)\n #undef TARGET_CONDITIONAL_REGISTER_USAGE\n #define TARGET_CONDITIONAL_REGISTER_USAGE aarch64_conditional_register_usage\n \n+#undef TARGET_MEMBER_TYPE_FORCES_BLK\n+#define TARGET_MEMBER_TYPE_FORCES_BLK aarch64_member_type_forces_blk\n+\n /* Only the least significant bit is used for initialization guard\n    variables.  */\n #undef TARGET_CXX_GUARD_MASK_BIT"}, {"sha": "de28227236ad64b5be615c1b55ad31be68dccd73", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9", "patch": "@@ -1992,6 +1992,15 @@ AArch64 target which generates instruction sequences for big endian.\n @item aarch64_small_fpic\n Binutils installed on test system supports relocation types required by -fpic\n for AArch64 small memory model.\n+@item aarch64_sve_hw\n+AArch64 target that is able to generate and execute SVE code (regardless of\n+whether it does so by default).\n+@item aarch64_sve128_hw\n+@itemx aarch64_sve256_hw\n+@itemx aarch64_sve512_hw\n+@itemx aarch64_sve1024_hw\n+@itemx aarch64_sve2048_hw\n+Like @code{aarch64_sve_hw}, but also test for an exact hardware vector length.\n \n @end table\n "}, {"sha": "8c4425338b30aade835e282f80fd527335730010", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9", "patch": "@@ -1,3 +1,31 @@\n+2020-04-09  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gcc.target/aarch64/sve/acle/general/attributes_1.c: New test.\n+\t* gcc.target/aarch64/sve/acle/general/attributes_2.c: Likewise.\n+\t* gcc.target/aarch64/sve/acle/general/attributes_3.c: Likewise.\n+\t* gcc.target/aarch64/sve/acle/general/attributes_4.c: Likewise.\n+\t* gcc.target/aarch64/sve/acle/general/attributes_5.c: Likewise.\n+\t* gcc.target/aarch64/sve/acle/general/attributes_6.c: Likewise.\n+\t* gcc.target/aarch64/sve/acle/general/attributes_7.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/struct.h: New file.\n+\t* gcc.target/aarch64/sve/pcs/struct_1_128.c: New test.\n+\t* gcc.target/aarch64/sve/pcs/struct_1_256.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/struct_1_512.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/struct_1_1024.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/struct_1_2048.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/struct_2_128.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/struct_2_256.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/struct_2_512.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/struct_2_1024.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/struct_2_2048.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/struct_3_128.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/struct_3_256.c: Likewise.\n+\t* gcc.target/aarch64/sve/pcs/struct_3_512.c: Likewise.\n+\t* lib/target-supports.exp (check_effective_target_aarch64_sve128_hw)\n+\t(check_effective_target_aarch64_sve512_hw)\n+\t(check_effective_target_aarch64_sve1024_hw)\n+\t(check_effective_target_aarch64_sve2048_hw): New procedures.\n+\n 2020-04-09  Matthew Malcomson  <matthew.malcomson@arm.com>\n \n \t* g++.target/arm/cde_mve.C: New test."}, {"sha": "6cd4f99911e27127836f45c1438ad0e039b74e23", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/attributes_1.c", "status": "added", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fattributes_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fattributes_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fattributes_1.c?ref=38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9", "patch": "@@ -0,0 +1,205 @@\n+/* { dg-options \"-msve-vector-bits=256\" } */\n+\n+#include <arm_sve.h>\n+\n+#ifndef __ARM_FEATURE_SVE_BITS\n+#error \"__ARM_FEATURE_SVE_BITS is not defined but should be\"\n+#endif\n+\n+#if __ARM_FEATURE_SVE_VECTOR_OPERATIONS != 1\n+#error \"__ARM_FEATURE_SVE_VECTOR_OPERATIONS should be equal to 1\"\n+#endif\n+\n+#ifndef __cplusplus\n+#define alignof _Alignof\n+#endif\n+\n+#define N __ARM_FEATURE_SVE_BITS\n+#define FIXED_ATTR __attribute__ ((arm_sve_vector_bits (N)))\n+#define GNU_ATTR __attribute__ ((vector_size (N / 8)))\n+\n+typedef svint8_t fixed_int8_t FIXED_ATTR;\n+typedef svint16_t fixed_int16_t FIXED_ATTR;\n+typedef svint32_t fixed_int32_t FIXED_ATTR;\n+typedef svint64_t fixed_int64_t FIXED_ATTR;\n+\n+typedef svuint8_t fixed_uint8_t FIXED_ATTR;\n+typedef svuint16_t fixed_uint16_t FIXED_ATTR;\n+typedef svuint32_t fixed_uint32_t FIXED_ATTR;\n+typedef svuint64_t fixed_uint64_t FIXED_ATTR;\n+\n+typedef svbfloat16_t fixed_bfloat16_t FIXED_ATTR;\n+typedef svfloat16_t fixed_float16_t FIXED_ATTR;\n+typedef svfloat32_t fixed_float32_t FIXED_ATTR;\n+typedef svfloat64_t fixed_float64_t FIXED_ATTR;\n+\n+typedef svbool_t fixed_bool_t FIXED_ATTR;\n+\n+typedef int8_t gnu_int8_t GNU_ATTR;\n+typedef int16_t gnu_int16_t GNU_ATTR;\n+typedef int32_t gnu_int32_t GNU_ATTR;\n+typedef int64_t gnu_int64_t GNU_ATTR;\n+\n+typedef uint8_t gnu_uint8_t GNU_ATTR;\n+typedef uint16_t gnu_uint16_t GNU_ATTR;\n+typedef uint32_t gnu_uint32_t GNU_ATTR;\n+typedef uint64_t gnu_uint64_t GNU_ATTR;\n+\n+typedef bfloat16_t gnu_bfloat16_t GNU_ATTR;\n+typedef float16_t gnu_float16_t GNU_ATTR;\n+typedef float32_t gnu_float32_t GNU_ATTR;\n+typedef float64_t gnu_float64_t GNU_ATTR;\n+\n+void f() {\n+#define TEST_VECTOR(TYPE) \\\n+  do \\\n+    { \\\n+      int assert_sizeof[sizeof (TYPE) == N / 8 ? 1 : -1]; \\\n+      int assert_alignof[alignof (TYPE) == 16 ? 1 : -1]; \\\n+    } \\\n+  while (0)\n+\n+  TEST_VECTOR (fixed_int8_t);\n+  TEST_VECTOR (fixed_int16_t);\n+  TEST_VECTOR (fixed_int32_t);\n+  TEST_VECTOR (fixed_int64_t);\n+\n+  TEST_VECTOR (fixed_uint8_t);\n+  TEST_VECTOR (fixed_uint16_t);\n+  TEST_VECTOR (fixed_uint32_t);\n+  TEST_VECTOR (fixed_uint64_t);\n+\n+  TEST_VECTOR (fixed_bfloat16_t);\n+  TEST_VECTOR (fixed_float16_t);\n+  TEST_VECTOR (fixed_float32_t);\n+  TEST_VECTOR (fixed_float64_t);\n+\n+#undef TEST_VECTOR\n+\n+  {\n+    int assert_sizeof[sizeof(fixed_bool_t) == N / 64 ? 1 : -1];\n+    int assert_alignof[alignof(fixed_bool_t) == 2 ? 1 : -1];\n+  }\n+}\n+\n+#define TEST_GLOBAL(TYPE)\t\t\t\\\n+  extern fixed_##TYPE extern_##TYPE;\t\t\\\n+  fixed_##TYPE global_##TYPE;\n+\n+#define TEST_STRUCT(TYPE)\t\t\t\\\n+  struct struct_##TYPE\t\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    fixed_##TYPE a, b, c[3];\t\t\t\\\n+  };\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+  union union_##TYPE\t\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    fixed_##TYPE a, b, c[3];\t\t\t\\\n+  };\n+\n+#define TEST_CONVERT(TYPE, PREFIX)\t\t\\\n+  PREFIX##TYPE\t\t\t\t\t\\\n+  to_##PREFIX##TYPE (fixed_##TYPE x)\t\t\\\n+  {\t\t\t\t\t\t\\\n+    return x;\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+  fixed_##TYPE\t\t\t\t\t\\\n+  from_##PREFIX##TYPE (PREFIX##TYPE x)\t\t\\\n+  {\t\t\t\t\t\t\\\n+    return x;\t\t\t\t\t\\\n+  }\n+\n+#define TEST_UNARY(TYPE, NAME, OP)\t\t\\\n+  fixed_##TYPE\t\t\t\t\t\\\n+  NAME##_##TYPE (fixed_##TYPE x)\t\t\\\n+  {\t\t\t\t\t\t\\\n+    return OP x;\t\t\t\t\\\n+  }\n+\n+#define TEST_BINARY(TYPE, NAME, OP)\t\t\t\\\n+  fixed_##TYPE\t\t\t\t\t\t\\\n+  NAME##_##TYPE (fixed_##TYPE x, fixed_##TYPE y)\t\\\n+  {\t\t\t\t\t\t\t\\\n+    return x OP y;\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+  fixed_##TYPE\t\t\t\t\t\t\\\n+  NAME##_##TYPE##_eq (fixed_##TYPE x, fixed_##TYPE y)\t\\\n+  {\t\t\t\t\t\t\t\\\n+    x OP##= y; return x;\t\t\t\t\\\n+  }\n+\n+#define TEST_COMPARISON(TYPE, NAME, OP)\t\t\t\\\n+  fixed_##TYPE\t\t\t\t\t\t\\\n+  NAME##_##TYPE (fixed_##TYPE x, fixed_##TYPE y)\t\\\n+  {\t\t\t\t\t\t\t\\\n+    return x OP y;\t\t\t\t\t\\\n+  }\n+\n+#define TEST_CALL(TYPE)\t\t\t\t\t\t\t\\\n+  fixed_##TYPE\t\t\t\t\t\t\t\t\\\n+  call_##TYPE##_ff (svbool_t pg, fixed_##TYPE x, fixed_##TYPE y)\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    return svsel (pg, x, y);\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  fixed_##TYPE\t\t\t\t\t\t\t\t\\\n+  call_##TYPE##_sf (svbool_t pg, sv##TYPE x, fixed_##TYPE y)\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    return svsel (pg, x, y);\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  fixed_##TYPE\t\t\t\t\t\t\t\t\\\n+  call_##TYPE##_fs (svbool_t pg, fixed_##TYPE x, sv##TYPE y)\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    return svsel (pg, x, y);\t\t\t\t\t\t\\\n+  }\n+\n+#define TEST_COMMON(TYPE)\t\t\t\\\n+  TEST_GLOBAL (TYPE)\t\t\t\t\\\n+  TEST_STRUCT (TYPE)\t\t\t\t\\\n+  TEST_CONVERT (TYPE, sv)\t\t\t\\\n+  TEST_CALL (TYPE)\n+\n+#define TEST_VECTOR(TYPE)\t\t\t\\\n+  TEST_COMMON (TYPE)\t\t\t\t\\\n+  TEST_CONVERT (TYPE, gnu_)\t\t\t\\\n+  TEST_UNARY (TYPE, nop, +)\t\t\t\\\n+  TEST_UNARY (TYPE, neg, -)\t\t\t\\\n+  TEST_BINARY (TYPE, add, +)\t\t\t\\\n+  TEST_BINARY (TYPE, sub, -)\t\t\t\\\n+  TEST_BINARY (TYPE, mul, *)\t\t\t\\\n+  TEST_BINARY (TYPE, div, /)\t\t\t\\\n+\n+#define TEST_INT_VECTOR(TYPE)\t\t\t\\\n+  TEST_VECTOR (TYPE)\t\t\t\t\\\n+  TEST_UNARY (TYPE, inv, ~)\t\t\t\\\n+  TEST_BINARY (TYPE, mod, %)\t\t\t\\\n+  TEST_BINARY (TYPE, shl, <<)\t\t\t\\\n+  TEST_BINARY (TYPE, shr, >>)\t\t\t\\\n+  TEST_BINARY (TYPE, and, &)\t\t\t\\\n+  TEST_BINARY (TYPE, ior, |)\t\t\t\\\n+  TEST_BINARY (TYPE, xor, ^)\t\t\t\\\n+  TEST_COMPARISON (TYPE, eq, =)\t\t\t\\\n+  TEST_COMPARISON (TYPE, ne, !=)\t\t\\\n+  TEST_COMPARISON (TYPE, lt, <)\t\t\t\\\n+  TEST_COMPARISON (TYPE, le, <=)\t\t\\\n+  TEST_COMPARISON (TYPE, ge, >=)\t\t\\\n+  TEST_COMPARISON (TYPE, gt, >)\n+\n+TEST_INT_VECTOR (int8_t);\n+TEST_INT_VECTOR (int16_t);\n+TEST_INT_VECTOR (int32_t);\n+TEST_INT_VECTOR (int64_t);\n+\n+TEST_INT_VECTOR (uint8_t);\n+TEST_INT_VECTOR (uint16_t);\n+TEST_INT_VECTOR (uint32_t);\n+TEST_INT_VECTOR (uint64_t);\n+\n+TEST_VECTOR (float16_t);\n+TEST_VECTOR (float32_t);\n+TEST_VECTOR (float64_t);\n+\n+TEST_COMMON (bool_t)"}, {"sha": "798491b2128e0a226cefab6e7a594dc4c504ff3a", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/attributes_2.c", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fattributes_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fattributes_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fattributes_2.c?ref=38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9", "patch": "@@ -0,0 +1,3 @@\n+/* { dg-options \"-msve-vector-bits=512\" } */\n+\n+#include \"attributes_1.c\""}, {"sha": "c3ba5628ceb796c34ab5d16dfeecc8fa36d2ae01", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/attributes_3.c", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fattributes_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fattributes_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fattributes_3.c?ref=38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9", "patch": "@@ -0,0 +1,3 @@\n+/* { dg-options \"-msve-vector-bits=1024\" } */\n+\n+#include \"attributes_1.c\""}, {"sha": "487dba6f7481187424843a5fa60956276053c975", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/attributes_4.c", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fattributes_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fattributes_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fattributes_4.c?ref=38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9", "patch": "@@ -0,0 +1,3 @@\n+/* { dg-options \"-msve-vector-bits=2048\" } */\n+\n+#include \"attributes_1.c\""}, {"sha": "c7951c92848370c41bd62b607e052ed763b2e821", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/attributes_5.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fattributes_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fattributes_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fattributes_5.c?ref=38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-options \"-msve-vector-bits=128\" } */\n+\n+#if __ARM_BIG_ENDIAN && !__ARM_FEATURE_SVE_BITS\n+int pass = 1;\n+#else\n+#include \"attributes_1.c\"\n+#endif"}, {"sha": "907637f06f9caa53ceaf4d0e509a607104a5c1eb", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/attributes_6.c", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fattributes_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fattributes_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fattributes_6.c?ref=38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9", "patch": "@@ -0,0 +1,97 @@\n+/* { dg-options \"-O2 -msve-vector-bits=256\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_sve.h>\n+\n+#define N __ARM_FEATURE_SVE_BITS\n+#define FIXED_ATTR __attribute__ ((arm_sve_vector_bits (N)))\n+#define GNU_ATTR __attribute__ ((vector_size (N / 8)))\n+\n+typedef svint8_t fixed_int8_t FIXED_ATTR;\n+\n+typedef svbool_t fixed_bool_t FIXED_ATTR;\n+\n+typedef int8_t gnu_int8_t GNU_ATTR;\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/*\n+** test_add:\n+**\tadd\tz0\\.b, (?:z0\\.b, z1\\.b|z1\\.b, z0\\.b)\n+**\tret\n+*/\n+fixed_int8_t\n+test_add (fixed_int8_t x, fixed_int8_t y)\n+{\n+  return x + y;\n+}\n+\n+/*\n+** test_add_gnu:\n+** (\n+**\tadd\t(z[0-9]+\\.b), (?:z0\\.b, z1\\.b|z1\\.b, z0\\.b)\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tst1b\t\\1, \\2, \\[x8\\]\n+** |\n+**\tptrue\t(p[0-7]\\.b), vl32\n+**\tadd\t(z[0-9]+)\\.b, (?:z0\\.b, z1\\.b|z1\\.b, z0\\.b)\n+**\tst1b\t\\4, \\3, \\[x8\\]\n+** )\n+**\tret\n+*/\n+gnu_int8_t\n+test_add_gnu (fixed_int8_t x, fixed_int8_t y)\n+{\n+  return x + y;\n+}\n+\n+/*\n+** test_load: { target lp64 }\n+**\tld1b\tz0\\.b, p0/z, \\[x0\\]\n+**\tret\n+*/\n+/*\n+** test_load: { target ilp32 }\n+**\tuxtw\tx0, w0\n+**\tld1b\tz0\\.b, p0/z, \\[x0\\]\n+**\tret\n+*/\n+fixed_int8_t\n+test_load (fixed_bool_t pg, int8_t *ptr)\n+{\n+  return svld1 (pg, ptr);\n+}\n+\n+/*\n+** test_store: { target lp64 }\n+**\tst1b\tz0\\.b, p0, \\[x0\\]\n+**\tret\n+*/\n+/*\n+** test_store: { target ilp32 }\n+**\tuxtw\tx0, w0\n+**\tst1b\tz0\\.b, p0, \\[x0\\]\n+**\tret\n+*/\n+void\n+test_store (fixed_bool_t pg, int8_t *ptr, fixed_int8_t data)\n+{\n+  svst1 (pg, ptr, data);\n+}\n+\n+/*\n+** test_and_z:\n+**\tand\tp0\\.b, p0/z, p1\\.b, p2\\.b\n+**\tret\n+*/\n+fixed_bool_t\n+test_and_z (fixed_bool_t pg, svbool_t p1, fixed_bool_t p2)\n+{\n+  return svand_z (pg, p1, p2);\n+}\n+\n+#ifdef __cplusplus\n+}\n+#endif"}, {"sha": "55d9deace0c3581ec5397b71343432fd3b74a7fa", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/attributes_7.c", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fattributes_7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fattributes_7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fattributes_7.c?ref=38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9", "patch": "@@ -0,0 +1,181 @@\n+/* { dg-options \"-msve-vector-bits=256 -W -Wall\" } */\n+\n+#include <arm_sve.h>\n+\n+#define N __ARM_FEATURE_SVE_BITS\n+#define FIXED_ATTR __attribute__ ((arm_sve_vector_bits (N)))\n+#define GNU_ATTR __attribute__ ((vector_size (N / 8)))\n+\n+typedef svint8_t fixed_int8_t FIXED_ATTR;\n+typedef svint16_t fixed_int16_t FIXED_ATTR;\n+\n+typedef svuint8_t fixed_uint8_t FIXED_ATTR;\n+\n+typedef svbool_t fixed_bool_t FIXED_ATTR;\n+\n+typedef int8_t gnu_int8_t GNU_ATTR;\n+typedef int16_t gnu_int16_t GNU_ATTR;\n+\n+typedef uint8_t gnu_uint8_t GNU_ATTR;\n+\n+typedef int bad_type_1 __attribute__ ((arm_sve_vector_bits (N))); // { dg-error {'arm_sve_vector_bits' applied to non-SVE type 'int'} }\n+typedef svbool_t bad_type_2 __attribute__ ((arm_sve_vector_bits)); // { dg-error {wrong number of arguments specified for 'arm_sve_vector_bits' attribute} }\n+typedef svbool_t bad_type_3 __attribute__ ((arm_sve_vector_bits (N, N))); // { dg-error {wrong number of arguments specified for 'arm_sve_vector_bits' attribute} }\n+typedef svbool_t bad_type_4 __attribute__ ((arm_sve_vector_bits (\"256\"))); // { dg-error {'arm_sve_vector_bits' requires an integer constant expression} }\n+typedef svbool_t bad_type_5 __attribute__ ((arm_sve_vector_bits (100))); // { dg-warning {unsupported SVE vector size} }\n+\n+void\n+f (int c)\n+{\n+  svint8_t ss8;\n+  fixed_int8_t fs8;\n+  gnu_int8_t gs8;\n+\n+  svuint8_t su8;\n+  fixed_uint8_t fu8;\n+  gnu_uint8_t gu8;\n+\n+  svint16_t ss16;\n+  fixed_int16_t fs16;\n+  gnu_int16_t gs16;\n+\n+  svbool_t sb;\n+  fixed_bool_t fb;\n+\n+  ss8 = ss8 + ss8; // { dg-error {invalid operands [^\\n]* binary[^\\n]*\\+} }\n+  ss8 = ss8 + fs8; // { dg-error {invalid operands [^\\n]* binary[^\\n]*\\+} }\n+  ss8 = ss8 + gs8; // { dg-error {invalid operands [^\\n]* binary[^\\n]*\\+} }\n+  ss8 += ss8; // { dg-error {invalid operands [^\\n]* binary[^\\n]*\\+} }\n+  ss8 += fs8; // { dg-error {invalid operands [^\\n]* binary[^\\n]*\\+} }\n+  ss8 += gs8; // { dg-error {invalid operands [^\\n]* binary[^\\n]*\\+} }\n+\n+  fs8 = fs8 + ss8; // { dg-error {invalid operands [^\\n]* binary[^\\n]*\\+} }\n+  fs8 = fs8 + fs8;\n+  fs8 = fs8 + gs8; // { dg-error {cannot combine GNU and SVE vectors in a binary operation} }\n+  fs8 += ss8; // { dg-error {invalid operands [^\\n]* binary[^\\n]*\\+} }\n+  fs8 += fs8;\n+  fs8 += gs8; // { dg-error {cannot combine GNU and SVE vectors in a binary operation} }\n+\n+  gs8 = gs8 + ss8; // { dg-error {invalid operands [^\\n]* binary[^\\n]*\\+} }\n+  gs8 = gs8 + fs8; // { dg-error {cannot combine GNU and SVE vectors in a binary operation} }\n+  gs8 = gs8 + gs8;\n+  gs8 += ss8; // { dg-error {invalid operands [^\\n]* binary[^\\n]*\\+} }\n+  gs8 += fs8; // { dg-error {cannot combine GNU and SVE vectors in a binary operation} }\n+  gs8 += gs8;\n+\n+  fs8 = ss8;\n+  fs8 = fs8;\n+  fs8 = gs8;\n+\n+  fs8 = su8; // { dg-error {cannot convert|incompatible types} }\n+  fs8 = fu8; // { dg-error {cannot convert|incompatible types} }\n+  fs8 = gu8; // { dg-error {cannot convert|incompatible types} }\n+\n+  fs8 = ss16; // { dg-error {cannot convert|incompatible types} }\n+  fs8 = fs16; // { dg-error {cannot convert|incompatible types} }\n+  fs8 = gs16; // { dg-error {cannot convert|incompatible types} }\n+\n+  (void) (c ? ss8 : ss8);\n+  (void) (c ? ss8 : fs8); // { dg-error {type mismatch|different types} }\n+  (void) (c ? ss8 : gs8); // { dg-error {type mismatch|different types} }\n+\n+  (void) (c ? fs8 : ss8); // { dg-error {type mismatch|different types} }\n+  (void) (c ? fs8 : fs8);\n+  (void) (c ? fs8 : gs8); // { dg-error {type mismatch|different types} \"\" { xfail c++ } }\n+\n+  (void) (c ? gs8 : ss8); // { dg-error {type mismatch|different types} }\n+  (void) (c ? gs8 : fs8); // { dg-error {type mismatch|different types} \"\" { xfail c++ } }\n+  (void) (c ? gs8 : gs8);\n+\n+  sb = fb;\n+  fb = sb;\n+\n+  (void) (c ? sb : sb);\n+  (void) (c ? sb : fb); // { dg-error {type mismatch|different types} \"\" { xfail *-*-* } }\n+\n+  (void) (c ? fb : sb); // { dg-error {type mismatch|different types} \"\" { xfail *-*-* } }\n+  (void) (c ? fb : fb);\n+}\n+\n+void\n+g (int c)\n+{\n+  svint8_t *ss8;\n+  fixed_int8_t *fs8;\n+  gnu_int8_t *gs8;\n+\n+  svuint8_t *su8;\n+  fixed_uint8_t *fu8;\n+  gnu_uint8_t *gu8;\n+\n+  svint16_t *ss16;\n+  fixed_int16_t *fs16;\n+  gnu_int16_t *gs16;\n+\n+  svbool_t *sb;\n+  fixed_bool_t *fb;\n+\n+  __PTRDIFF_TYPE__ diff __attribute__((unused));\n+  void *select __attribute__((unused));\n+\n+  diff = ss8 - ss8; // { dg-error {arithmetic on pointer to SVE type 'svint8_t'} }\n+  diff = ss8 - fs8; // { dg-error {invalid operands [^\\n]* binary[^\\n]*\\-} \"\" { xfail c } }\n+\t\t    // { dg-error {arithmetic on pointer to SVE type 'svint8_t'} \"bogus\" { target c } .-1 }\n+  diff = ss8 - gs8; // { dg-error {invalid operands [^\\n]* binary[^\\n]*\\-} \"\" { xfail c } }\n+\t\t    // { dg-error {arithmetic on pointer to SVE type 'svint8_t'} \"bogus\" { target c } .-1 }\n+\n+  diff = fs8 - ss8; // { dg-error {invalid operands [^\\n]* binary[^\\n]*\\-} \"\" { xfail c } }\n+\t\t    // { dg-error {arithmetic on pointer to SVE type 'svint8_t'} \"bogus\" { target c } .-1 }\n+  diff = fs8 - fs8;\n+  diff = fs8 - gs8;\n+\n+  diff = gs8 - ss8; // { dg-error {invalid operands [^\\n]* binary[^\\n]*\\-} \"\" { xfail c } }\n+\t\t    // { dg-error {arithmetic on pointer to SVE type 'svint8_t'} \"bogus\" { target c } .-1 }\n+  diff = gs8 - fs8;\n+  diff = gs8 - gs8;\n+\n+  fs8 = ss8; // { dg-error {invalid conversion} \"\" { xfail c } }\n+  fs8 = fs8;\n+  fs8 = gs8;\n+\n+  fs8 = su8; // { dg-error {cannot convert} \"c++\" { target c++ } }\n+\t     // { dg-warning {incompatible pointer type} \"c\" { target c } .-1 }\n+  fs8 = fu8; // { dg-error {cannot convert} \"c++\" { target c++ } }\n+\t     // { dg-warning {incompatible pointer type} \"c\" { target c } .-1 }\n+  fs8 = gu8; // { dg-error {cannot convert} \"c++\" { target c++ } }\n+\t     // { dg-warning {incompatible pointer type} \"c\" { target c } .-1 }\n+\n+  fs8 = ss16; // { dg-error {cannot convert} \"c++\" { target c++ } }\n+              // { dg-warning {incompatible pointer type} \"c\" { target c } .-1 }\n+  fs8 = fs16; // { dg-error {cannot convert} \"c++\" { target c++ } }\n+              // { dg-warning {incompatible pointer type} \"c\" { target c } .-1 }\n+  fs8 = gs16; // { dg-error {cannot convert} \"c++\" { target c++ } }\n+              // { dg-warning {incompatible pointer type} \"c\" { target c } .-1 }\n+\n+  select = c ? ss8 : ss8;\n+  select = c ? ss8 : fs8; // { dg-error {distinct pointer types} \"\" { xfail c } }\n+  select = c ? ss8 : gs8; // { dg-error {distinct pointer types} \"\" { xfail c } }\n+\n+  select = c ? fs8 : ss8; // { dg-error {distinct pointer types} \"\" { xfail c } }\n+  select = c ? fs8 : fs8;\n+  select = c ? fs8 : gs8; // { dg-error {distinct pointer types} \"\" { xfail *-*-* } }\n+\n+  select = c ? gs8 : ss8; // { dg-error {distinct pointer types} \"\" { xfail c } }\n+  select = c ? gs8 : fs8; // { dg-error {distinct pointer types} \"\" { xfail *-*-* } }\n+  select = c ? gs8 : gs8;\n+\n+  diff = sb - sb; // { dg-error {arithmetic on pointer to SVE type 'svbool_t'} }\n+  diff = sb - fb; // { dg-error {arithmetic on pointer to SVE type 'svbool_t'} }\n+\n+  diff = fb - sb; // { dg-error {arithmetic on pointer to SVE type 'svbool_t'} }\n+  diff = fb - fb;\n+\n+  sb = fb;\n+  fb = sb;\n+\n+  select = c ? sb : sb;\n+  select = c ? sb : fb; // { dg-error {type mismatch|different types} \"\" { xfail *-*-* } }\n+\n+  select = c ? fb : sb; // { dg-error {type mismatch|different types} \"\" { xfail *-*-* } }\n+  select = c ? fb : fb;\n+}"}, {"sha": "45fa3306beba31658c1cda082695e34ed9b4d854", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/struct.h", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct.h?ref=38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9", "patch": "@@ -0,0 +1,77 @@\n+#ifndef STRUCT_H\n+#define STRUCT_H 1\n+\n+#include <arm_sve.h>\n+\n+#ifndef __ARM_FEATURE_SVE_BITS\n+#error \"__ARM_FEATURE_SVE_BITS should be defined\"\n+#endif\n+\n+#define FIXED_ATTR \\\n+  __attribute__ ((arm_sve_vector_bits (__ARM_FEATURE_SVE_BITS)))\n+\n+#define SVE_BYTES (__ARM_FEATURE_SVE_BITS / 8)\n+\n+typedef __SVInt8_t fixed_int8_t FIXED_ATTR;\n+typedef __SVInt16_t fixed_int16_t FIXED_ATTR;\n+typedef __SVInt32_t fixed_int32_t FIXED_ATTR;\n+typedef __SVInt64_t fixed_int64_t FIXED_ATTR;\n+\n+typedef __SVUint8_t fixed_uint8_t FIXED_ATTR;\n+typedef __SVUint16_t fixed_uint16_t FIXED_ATTR;\n+typedef __SVUint32_t fixed_uint32_t FIXED_ATTR;\n+typedef __SVUint64_t fixed_uint64_t FIXED_ATTR;\n+\n+typedef __SVBfloat16_t fixed_bfloat16_t FIXED_ATTR;\n+typedef __SVFloat16_t fixed_float16_t FIXED_ATTR;\n+typedef __SVFloat32_t fixed_float32_t FIXED_ATTR;\n+typedef __SVFloat64_t fixed_float64_t FIXED_ATTR;\n+\n+typedef __SVBool_t fixed_bool_t FIXED_ATTR;\n+\n+/* Define an asm function called NAME with return type RET_TYPE and\n+   argument list ARG_TYPES.  INSNS contains the body of the function,\n+   except for the final \"ret\".\n+\n+   Conservatively mark the function as a variant PCS function,\n+   since many uses are.  */\n+#define ASM_FUNCTION(NAME, RET_TYPE, ARG_TYPES, INSNS) \\\n+extern RET_TYPE NAME ARG_TYPES;\t\t\t\\\n+  asm(\t\t\t\t\t\t\\\n+\"\t.type\t\" #NAME \", %function\\n\"\t\t\\\n+#NAME \":\\n\"\t\t\t\t\t\\\n+\"\t\" INSNS \"\\n\"\t\t\t\t\\\n+\"\tret\\n\"\t\t\t\t\t\\\n+\"\t.size\t\" #NAME \", .-\" #NAME \"\\n\"\t\\\n+\"\t.variant_pcs \" #NAME \"\\n\"\t\t\\\n+)\n+\n+/* Set the argument registers to fixed values.  */\n+#define CLEANSE\t\t\t\t\t\t\t\t\\\n+  asm volatile (\"mov\\tx0, #-1\\n\\t\"\t\t\t\t\t\\\n+\t\t\"mov\\tx1, #-1\\n\\t\"\t\t\t\t\t\\\n+\t\t\"mov\\tx2, #-1\\n\\t\"\t\t\t\t\t\\\n+\t\t\"mov\\tx3, #-1\\n\\t\"\t\t\t\t\t\\\n+\t\t\"mov\\tx4, #-1\\n\\t\"\t\t\t\t\t\\\n+\t\t\"mov\\tx5, #-1\\n\\t\"\t\t\t\t\t\\\n+\t\t\"mov\\tx6, #-1\\n\\t\"\t\t\t\t\t\\\n+\t\t\"mov\\tx7, #-1\\n\\t\"\t\t\t\t\t\\\n+\t\t\"mov\\tx8, #-1\\n\\t\"\t\t\t\t\t\\\n+\t\t\"mov\\tz0.b, #0xaf\\n\\t\"\t\t\t\t\t\\\n+\t\t\"mov\\tz1.b, #0xaf\\n\\t\"\t\t\t\t\t\\\n+\t\t\"mov\\tz2.b, #0xaf\\n\\t\"\t\t\t\t\t\\\n+\t\t\"mov\\tz3.b, #0xaf\\n\\t\"\t\t\t\t\t\\\n+\t\t\"mov\\tz4.b, #0xaf\\n\\t\"\t\t\t\t\t\\\n+\t\t\"mov\\tz5.b, #0xaf\\n\\t\"\t\t\t\t\t\\\n+\t\t\"mov\\tz6.b, #0xaf\\n\\t\"\t\t\t\t\t\\\n+\t\t\"mov\\tz7.b, #0xaf\\n\\t\"\t\t\t\t\t\\\n+\t\t\"pfalse\\tp0.b\\n\\t\"\t\t\t\t\t\\\n+\t\t\"pfalse\\tp1.b\\n\\t\"\t\t\t\t\t\\\n+\t\t\"pfalse\\tp2.b\\n\\t\"\t\t\t\t\t\\\n+\t\t\"pfalse\\tp3.b\"\t\t\t\t\t\t\\\n+\t\t:::\t\t\t\t\t\t\t\\\n+\t\t\"x0\", \"x1\", \"x2\", \"x3\", \"x4\", \"x5\", \"x6\", \"x7\", \"x8\",\t\\\n+\t\t\"z0\", \"z1\", \"z2\", \"z3\", \"z4\", \"z5\", \"z6\", \"z7\",\t\t\\\n+\t\t\"p0\", \"p1\", \"p2\", \"p3\")\n+\n+#endif"}, {"sha": "3a4b1b2fdaf725723d6911d16f934cc5e18f2474", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/struct_1_1024.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct_1_1024.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct_1_1024.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct_1_1024.c?ref=38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9", "patch": "@@ -0,0 +1,4 @@\n+/* { dg-do run { target { aarch64_sve1024_hw } } } */\n+/* { dg-options \"-msve-vector-bits=1024\" } */\n+\n+#include \"struct_1_128.c\""}, {"sha": "a7e470047f6da42c752137f675793f0187cdf178", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/struct_1_128.c", "status": "added", "additions": 405, "deletions": 0, "changes": 405, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct_1_128.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct_1_128.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct_1_128.c?ref=38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9", "patch": "@@ -0,0 +1,405 @@\n+/* { dg-do run { target { aarch64_sve128_hw } } } */\n+/* { dg-require-effective-target aarch64_little_endian } */\n+/* { dg-options \"-msve-vector-bits=128\" } */\n+\n+#include \"struct.h\"\n+\n+struct pst1\n+{\n+  fixed_int8_t v[8];\n+  fixed_bool_t p[4];\n+};\n+\n+ASM_FUNCTION (make_pst1_asm, struct pst1, (),\n+\t      \"mov z0.b, #1\\n\\t\"\n+\t      \"mov z1.b, #4\\n\\t\"\n+\t      \"mov z2.b, #5\\n\\t\"\n+\t      \"mov z3.b, #9\\n\\t\"\n+\t      \"mov z4.b, #14\\n\\t\"\n+\t      \"mov z5.b, #23\\n\\t\"\n+\t      \"mov z6.b, #37\\n\\t\"\n+\t      \"mov z7.b, #60\\n\\t\"\n+\t      \"ptrue p0.b, vl1\\n\\t\"\n+\t      \"ptrue p1.b, vl2\\n\\t\"\n+\t      \"ptrue p2.b, vl3\\n\\t\"\n+\t      \"ptrue p3.b, vl4\");\n+\n+#define LOAD_PST1(PTR) \\\n+  \"ld1b z0.b, p0/z, [\" PTR \", #0, mul vl]\\n\\t\" \\\n+  \"ld1b z1.b, p0/z, [\" PTR \", #1, mul vl]\\n\\t\" \\\n+  \"ld1b z2.b, p0/z, [\" PTR \", #2, mul vl]\\n\\t\" \\\n+  \"ld1b z3.b, p0/z, [\" PTR \", #3, mul vl]\\n\\t\" \\\n+  \"ld1b z4.b, p0/z, [\" PTR \", #4, mul vl]\\n\\t\" \\\n+  \"ld1b z5.b, p0/z, [\" PTR \", #5, mul vl]\\n\\t\" \\\n+  \"ld1b z6.b, p0/z, [\" PTR \", #6, mul vl]\\n\\t\" \\\n+  \"ld1b z7.b, p0/z, [\" PTR \", #7, mul vl]\\n\\t\" \\\n+  \"incb \" PTR \", all, mul #8\\n\\t\" \\\n+  \"ldr p0, [\" PTR \", #0, mul vl]\\n\\t\" \\\n+  \"ldr p1, [\" PTR \", #1, mul vl]\\n\\t\" \\\n+  \"ldr p2, [\" PTR \", #2, mul vl]\\n\\t\" \\\n+  \"ldr p3, [\" PTR \", #3, mul vl]\"\n+\n+ASM_FUNCTION (passthru_pst1_x0_a,\n+\t      struct pst1, (svbool_t, struct pst1),\n+\t      \"incp x0, p0.b\\n\\t\"\n+\t      \"sub x0, x0, #11\\n\\t\"\n+\t      \"ptrue p0.b\\n\\t\"\n+\t      LOAD_PST1 (\"x0\"));\n+\n+ASM_FUNCTION (passthru_pst1_x0_b,\n+\t      struct pst1, (svbool_t, struct pst1, uint64_t),\n+\t      \"incp x0, p0.b\\n\\t\"\n+\t      \"add x0, x0, x1\\n\\t\"\n+\t      \"sub x0, x0, #52\\n\\t\"\n+\t      \"ptrue p0.b\\n\\t\"\n+\t      LOAD_PST1 (\"x0\"));\n+\n+ASM_FUNCTION (passthru_pst1_x0_c,\n+\t      struct pst1, (svbool_t, struct pst1, svbool_t,\n+\t\t\t    svbool_t, svbool_t, svbool_t),\n+\t      \"incp x0, p0.b\\n\\t\"\n+\t      \"ldr p0, [x1]\\n\\t\"\n+\t      \"incp x0, p1.b\\n\\t\"\n+\t      \"incp x0, p2.b\\n\\t\"\n+\t      \"incp x0, p3.b\\n\\t\"\n+\t      \"incp x0, p0.b\\n\\t\"\n+\t      \"sub x0, x0, #27\\n\\t\"\n+\t      \"ptrue p0.b\\n\\t\"\n+\t      LOAD_PST1 (\"x0\"));\n+\n+ASM_FUNCTION (passthru_pst1_x0_d,\n+\t      struct pst1, (svfloat32_t, struct pst1),\n+\t      \"ptrue p0.b\\n\\t\"\n+\t      \"fmov z1.s, #1.0\\n\\t\"\n+\t      \"fcmeq p0.s, p0/z, z0.s, z1.s\\n\\t\"\n+\t      \"uzp1 p0.b, p0.b, p0.b\\n\\t\"\n+\t      \"uzp1 p0.b, p0.b, p0.b\\n\\t\"\n+\t      LOAD_PST1 (\"x0\"));\n+\n+ASM_FUNCTION (passthru_pst1_x0_e,\n+\t      struct pst1, (svfloat32_t, struct pst1, svint32_t,\n+\t\t\t    svint32_t, svint32_t, svint32_t,\n+\t\t\t    svint32_t, svint32_t, svint32_t),\n+\t      \"ptrue p0.b\\n\\t\"\n+\t      \"fmov z24.s, #4.0\\n\\t\"\n+\t      \"fcmeq p0.s, p0/z, z0.s, z24.s\\n\\t\"\n+\t      \"cmpeq p0.s, p0/z, z1.s, #-4\\n\\t\"\n+\t      \"cmpeq p0.s, p0/z, z2.s, #-9\\n\\t\"\n+\t      \"cmpeq p0.s, p0/z, z3.s, #-14\\n\\t\"\n+\t      \"cmpeq p0.s, p0/z, z4.s, #11\\n\\t\"\n+\t      \"cmpeq p0.s, p0/z, z5.s, #10\\n\\t\"\n+\t      \"cmpeq p0.s, p0/z, z6.s, #8\\n\\t\"\n+\t      \"cmpeq p0.s, p0/z, z7.s, #-1\\n\\t\"\n+\t      \"uzp1 p0.b, p0.b, p0.b\\n\\t\"\n+\t      \"uzp1 p0.b, p0.b, p0.b\\n\\t\"\n+\t      LOAD_PST1 (\"x0\"));\n+\n+ASM_FUNCTION (passthru_pst1_x7_a,\n+\t      struct pst1, (svbool_t,\n+\t\t\t    uint64_t, uint64_t, uint64_t, uint64_t,\n+\t\t\t    uint64_t, uint64_t, uint64_t, struct pst1),\n+\t      \"add x0, x0, x1\\n\\t\"\n+\t      \"add x2, x2, x3\\n\\t\"\n+\t      \"add x4, x4, x5\\n\\t\"\n+\t      \"add x0, x0, x2\\n\\t\"\n+\t      \"add x4, x4, x6\\n\\t\"\n+\t      \"add x0, x0, x4\\n\\t\"\n+\t      \"add x7, x7, x0\\n\\t\"\n+\t      \"sub x7, x7, #127\\n\\t\"\n+\t      \"ptrue p0.b\\n\\t\"\n+\t      LOAD_PST1 (\"x7\"));\n+\n+ASM_FUNCTION (passthru_pst1_x7_b,\n+\t      struct pst1, (svbool_t, svbool_t, svbool_t, svbool_t,\n+\t\t\t    svbool_t, svbool_t, svbool_t, svbool_t,\n+\t\t\t    svbool_t, svbool_t, svbool_t,\n+\t\t\t    struct pst1),\n+\t      \"and p0.b, p1/z, p0.b, p2.b\\n\\t\"\n+\t      \"ldr p2, [x0]\\n\\t\"\n+\t      \"and p0.b, p2/z, p0.b, p3.b\\n\\t\"\n+\t      \"ldr p2, [x1]\\n\\t\"\n+\t      \"ldr p3, [x2]\\n\\t\"\n+\t      \"and p0.b, p2/z, p0.b, p3.b\\n\\t\"\n+\t      \"ldr p2, [x3]\\n\\t\"\n+\t      \"ldr p3, [x4]\\n\\t\"\n+\t      \"and p0.b, p2/z, p0.b, p3.b\\n\\t\"\n+\t      \"ldr p2, [x5]\\n\\t\"\n+\t      \"ldr p3, [x6]\\n\\t\"\n+\t      \"and p0.b, p2/z, p0.b, p3.b\\n\\t\"\n+\t      LOAD_PST1 (\"x7\"));\n+\n+ASM_FUNCTION (passthru_pst1_sp_a,\n+\t      struct pst1, (svbool_t, svbool_t, svbool_t, svbool_t,\n+\t\t\t    svbool_t, svbool_t, svbool_t, svbool_t,\n+\t\t\t    svbool_t, svbool_t, svbool_t, svbool_t,\n+\t\t\t    struct pst1),\n+\t      \"and p0.b, p1/z, p0.b, p2.b\\n\\t\"\n+\t      \"ldr p2, [x0]\\n\\t\"\n+\t      \"and p0.b, p2/z, p0.b, p3.b\\n\\t\"\n+\t      \"ldr p2, [x1]\\n\\t\"\n+\t      \"ldr p3, [x2]\\n\\t\"\n+\t      \"and p0.b, p2/z, p0.b, p3.b\\n\\t\"\n+\t      \"ldr p2, [x3]\\n\\t\"\n+\t      \"ldr p3, [x4]\\n\\t\"\n+\t      \"and p0.b, p2/z, p0.b, p3.b\\n\\t\"\n+\t      \"ldr p2, [x5]\\n\\t\"\n+\t      \"ldr p3, [x6]\\n\\t\"\n+\t      \"and p0.b, p2/z, p0.b, p3.b\\n\\t\"\n+\t      \"ldr p2, [x7]\\n\\t\"\n+\t      \"and p0.b, p2/z, p0.b, p0.b\\n\\t\"\n+\t      \"ldr x5, [sp]\\n\\t\"\n+#if __ILP32__\n+\t      \"uxtw x5, w5\\n\\t\"\n+#endif\n+\t      LOAD_PST1 (\"x5\"));\n+\n+void\n+test_vl (svbool_t p0, unsigned int vl)\n+{\n+  svbool_t pg = svptrue_b8 ();\n+  if (svptest_any (pg, sveor_z (pg, p0, svwhilelt_b8 (0U, vl))))\n+    __builtin_abort ();\n+}\n+\n+void\n+test_pst1 (struct pst1 *x)\n+{\n+  svbool_t pg = svptrue_b8 ();\n+  if (svptest_any (pg, svcmpne (pg, x->v[0], 1))\n+      || svptest_any (pg, svcmpne (pg, x->v[1], 4))\n+      || svptest_any (pg, svcmpne (pg, x->v[2], 5))\n+      || svptest_any (pg, svcmpne (pg, x->v[3], 9))\n+      || svptest_any (pg, svcmpne (pg, x->v[4], 14))\n+      || svptest_any (pg, svcmpne (pg, x->v[5], 23))\n+      || svptest_any (pg, svcmpne (pg, x->v[6], 37))\n+      || svptest_any (pg, svcmpne (pg, x->v[7], 60))\n+      || svptest_any (pg, sveor_z (pg, x->p[0], svptrue_pat_b8 (SV_VL1)))\n+      || svptest_any (pg, sveor_z (pg, x->p[1], svptrue_pat_b8 (SV_VL2)))\n+      || svptest_any (pg, sveor_z (pg, x->p[2], svptrue_pat_b8 (SV_VL3)))\n+      || svptest_any (pg, sveor_z (pg, x->p[3], svptrue_pat_b8 (SV_VL4))))\n+    __builtin_abort ();\n+}\n+\n+struct pst1\n+make_pst1 (void)\n+{\n+  struct pst1 res;\n+  res.v[0] = svdup_s8 (1);\n+  res.v[1] = svdup_s8 (4);\n+  res.v[2] = svdup_s8 (5);\n+  res.v[3] = svdup_s8 (9);\n+  res.v[4] = svdup_s8 (14);\n+  res.v[5] = svdup_s8 (23);\n+  res.v[6] = svdup_s8 (37);\n+  res.v[7] = svdup_s8 (60);\n+  res.p[0] = svptrue_pat_b8 (SV_VL1);\n+  res.p[1] = svptrue_pat_b8 (SV_VL2);\n+  res.p[2] = svptrue_pat_b8 (SV_VL3);\n+  res.p[3] = svptrue_pat_b8 (SV_VL4);\n+  return res;\n+}\n+\n+struct pst1\n+deref_pst1 (struct pst1 *ptr)\n+{\n+  return *ptr;\n+}\n+\n+void\n+consume_pst1 (struct pst1 x)\n+{\n+  test_pst1 (&x);\n+}\n+\n+void\n+consume_pst1_x0_a (svbool_t p0, struct pst1 x0)\n+{\n+  test_vl (p0, 11);\n+  test_pst1 (&x0);\n+}\n+\n+void\n+consume_pst1_x0_b (svbool_t p0, struct pst1 x0, uint64_t x1)\n+{\n+  test_vl (p0, 10);\n+  test_pst1 (&x0);\n+  if (x1 != 42)\n+    __builtin_abort ();\n+}\n+\n+void\n+consume_pst1_x0_c (svbool_t p0, struct pst1 x0, svbool_t p1,\n+\t\t   svbool_t p2, svbool_t p3, svbool_t x1)\n+{\n+  test_vl (p0, 9);\n+  test_pst1 (&x0);\n+  test_vl (p1, 7);\n+  test_vl (p2, 6);\n+  test_vl (p3, 3);\n+  test_vl (x1, 2);\n+}\n+\n+void\n+consume_pst1_x0_d (svfloat32_t z0, struct pst1 x0)\n+{\n+  svbool_t pg = svptrue_b8 ();\n+  if (svptest_any (pg, svcmpne (pg, z0, 1.0)))\n+    __builtin_abort ();\n+  test_pst1 (&x0);\n+}\n+\n+void\n+consume_pst1_x0_e (svfloat32_t z0, struct pst1 x0,\n+\t\t   svint32_t z1, svint32_t z2, svint32_t z3, svint32_t z4,\n+\t\t   svint32_t z5, svint32_t z6, svint32_t z7)\n+{\n+  svbool_t pg = svptrue_b8 ();\n+  if (svptest_any (pg, svcmpne (pg, z0, 4.0))\n+      || svptest_any (pg, svcmpne (pg, z1, -4))\n+      || svptest_any (pg, svcmpne (pg, z2, -9))\n+      || svptest_any (pg, svcmpne (pg, z3, -14))\n+      || svptest_any (pg, svcmpne (pg, z4, 11))\n+      || svptest_any (pg, svcmpne (pg, z5, 10))\n+      || svptest_any (pg, svcmpne (pg, z6, 8))\n+      || svptest_any (pg, svcmpne (pg, z7, -1)))\n+    __builtin_abort ();\n+  test_pst1 (&x0);\n+}\n+\n+void\n+consume_pst1_x7_a (svbool_t p0, uint64_t x0, uint64_t x1, uint64_t x2,\n+\t\t   uint64_t x3, uint64_t x4, uint64_t x5, uint64_t x6,\n+\t\t   struct pst1 x7)\n+{\n+  test_vl (p0, __ARM_FEATURE_SVE_BITS);\n+  if (x0 != 1\n+      || x1 != 2\n+      || x2 != 4\n+      || x3 != 8\n+      || x4 != 16\n+      || x5 != 32\n+      || x6 != 64)\n+    __builtin_abort ();\n+  test_pst1 (&x7);\n+}\n+\n+void\n+consume_pst1_x7_b (svbool_t p0, svbool_t p1, svbool_t p2, svbool_t p3,\n+\t\t   svbool_t x0, svbool_t x1, svbool_t x2, svbool_t x3,\n+\t\t   svbool_t x4, svbool_t x5, svbool_t x6, struct pst1 x7)\n+{\n+  test_vl (p0, __ARM_FEATURE_SVE_BITS);\n+  test_vl (p1, __ARM_FEATURE_SVE_BITS);\n+  test_vl (p2, __ARM_FEATURE_SVE_BITS);\n+  test_vl (p3, __ARM_FEATURE_SVE_BITS);\n+  test_vl (x0, __ARM_FEATURE_SVE_BITS);\n+  test_vl (x1, __ARM_FEATURE_SVE_BITS);\n+  test_vl (x2, __ARM_FEATURE_SVE_BITS);\n+  test_vl (x3, __ARM_FEATURE_SVE_BITS);\n+  test_vl (x4, __ARM_FEATURE_SVE_BITS);\n+  test_vl (x5, __ARM_FEATURE_SVE_BITS);\n+  test_vl (x6, __ARM_FEATURE_SVE_BITS);\n+  test_pst1 (&x7);\n+}\n+\n+void\n+consume_pst1_sp_a (svbool_t p0, svbool_t p1, svbool_t p2, svbool_t p3,\n+\t\t   svbool_t x0, svbool_t x1, svbool_t x2, svbool_t x3,\n+\t\t   svbool_t x4, svbool_t x5, svbool_t x6, svbool_t x7,\n+\t\t   struct pst1 sp)\n+{\n+  test_vl (p0, __ARM_FEATURE_SVE_BITS);\n+  test_vl (p1, __ARM_FEATURE_SVE_BITS);\n+  test_vl (p2, __ARM_FEATURE_SVE_BITS);\n+  test_vl (p3, __ARM_FEATURE_SVE_BITS);\n+  test_vl (x0, __ARM_FEATURE_SVE_BITS);\n+  test_vl (x1, __ARM_FEATURE_SVE_BITS);\n+  test_vl (x2, __ARM_FEATURE_SVE_BITS);\n+  test_vl (x3, __ARM_FEATURE_SVE_BITS);\n+  test_vl (x4, __ARM_FEATURE_SVE_BITS);\n+  test_vl (x5, __ARM_FEATURE_SVE_BITS);\n+  test_vl (x6, __ARM_FEATURE_SVE_BITS);\n+  test_vl (x7, __ARM_FEATURE_SVE_BITS);\n+  test_pst1 (&sp);\n+}\n+\n+int\n+main (void)\n+{\n+  svbool_t pg = svptrue_b8 ();\n+  svbool_t vl2 = svptrue_pat_b8 (SV_VL2);\n+  svbool_t vl3 = svptrue_pat_b8 (SV_VL3);\n+  svbool_t vl6 = svptrue_pat_b8 (SV_VL6);\n+  svbool_t vl7 = svptrue_pat_b8 (SV_VL7);\n+  svbool_t vl9 = svwhilelt_b8 (0, 9);\n+  svbool_t vl10 = svwhilelt_b8 (0, 10);\n+  svbool_t vl11 = svwhilelt_b8 (0, 11);\n+\n+  CLEANSE; struct pst1 res1 = make_pst1_asm ();\n+  CLEANSE; test_pst1 (&res1);\n+  CLEANSE; consume_pst1 (make_pst1 ());\n+\n+  CLEANSE; struct pst1 res2 = deref_pst1 (&res1);\n+  CLEANSE; test_pst1 (&res2);\n+  CLEANSE; consume_pst1 (res2);\n+\n+  CLEANSE; struct pst1 res3 = passthru_pst1_x0_a (vl11, res1);\n+  CLEANSE; test_pst1 (&res3);\n+  CLEANSE; consume_pst1_x0_a (vl11, res3);\n+\n+  CLEANSE; struct pst1 res4 = passthru_pst1_x0_b (vl10, res1, 42);\n+  CLEANSE; test_pst1 (&res4);\n+  CLEANSE; consume_pst1_x0_b (vl10, res4, 42);\n+\n+  CLEANSE; struct pst1 res5 = passthru_pst1_x0_c (vl9, res1, vl7,\n+\t\t\t\t\t\t  vl6, vl3, vl2);\n+  CLEANSE; test_pst1 (&res5);\n+  CLEANSE; consume_pst1_x0_c (vl9, res5, vl7,\n+\t\t\t      vl6, vl3, vl2);\n+\n+  CLEANSE; struct pst1 res6 = passthru_pst1_x0_d (svdup_f32 (1.0), res1);\n+  CLEANSE; test_pst1 (&res6);\n+  CLEANSE; consume_pst1_x0_d (svdup_f32 (1.0), res6);\n+\n+  CLEANSE; struct pst1 res7 = passthru_pst1_x0_e (svdup_f32 (4.0), res1,\n+\t\t\t\t\t\t  svdup_s32 (-4),\n+\t\t\t\t\t\t  svdup_s32 (-9),\n+\t\t\t\t\t\t  svdup_s32 (-14),\n+\t\t\t\t\t\t  svdup_s32 (11),\n+\t\t\t\t\t\t  svdup_s32 (10),\n+\t\t\t\t\t\t  svdup_s32 (8),\n+\t\t\t\t\t\t  svdup_s32 (-1));\n+  CLEANSE; test_pst1 (&res7);\n+  CLEANSE; consume_pst1_x0_e (svdup_f32 (4.0), res1,\n+\t\t\t      svdup_s32 (-4),\n+\t\t\t      svdup_s32 (-9),\n+\t\t\t      svdup_s32 (-14),\n+\t\t\t      svdup_s32 (11),\n+\t\t\t      svdup_s32 (10),\n+\t\t\t      svdup_s32 (8),\n+\t\t\t      svdup_s32 (-1));\n+\n+  CLEANSE; struct pst1 res8 = passthru_pst1_x7_a (pg, 1, 2, 4, 8,\n+\t\t\t\t\t\t  16, 32, 64, res1);\n+  CLEANSE; test_pst1 (&res8);\n+  CLEANSE; consume_pst1_x7_a (pg, 1, 2, 4, 8,\n+\t\t\t      16, 32, 64, res8);\n+\n+  CLEANSE; struct pst1 res9 = passthru_pst1_x7_b (pg, pg, pg, pg,\n+\t\t\t\t\t\t  pg, pg, pg, pg,\n+\t\t\t\t\t\t  pg, pg, pg, res1);\n+  CLEANSE; test_pst1 (&res9);\n+  CLEANSE; consume_pst1_x7_b (pg, pg, pg, pg,\n+\t\t\t      pg, pg, pg, pg,\n+\t\t\t      pg, pg, pg, res9);\n+\n+  CLEANSE; struct pst1 res10 = passthru_pst1_sp_a (pg, pg, pg, pg,\n+\t\t\t\t\t\t   pg, pg, pg, pg,\n+\t\t\t\t\t\t   pg, pg, pg, pg, res1);\n+  CLEANSE; test_pst1 (&res10);\n+  CLEANSE; consume_pst1_sp_a (pg, pg, pg, pg,\n+\t\t\t      pg, pg, pg, pg,\n+\t\t\t      pg, pg, pg, pg, res10);\n+\n+  return 0;\n+}"}, {"sha": "b7721dbb4a82ef46ef48208802c0acf6bb02bed6", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/struct_1_2048.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct_1_2048.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct_1_2048.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct_1_2048.c?ref=38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9", "patch": "@@ -0,0 +1,4 @@\n+/* { dg-do run { target { aarch64_sve2048_hw } } } */\n+/* { dg-options \"-msve-vector-bits=2048\" } */\n+\n+#include \"struct_1_128.c\""}, {"sha": "4cdc62840e7a3150f071ada8a682cc3e115eb8c0", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/struct_1_256.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct_1_256.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct_1_256.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct_1_256.c?ref=38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9", "patch": "@@ -0,0 +1,4 @@\n+/* { dg-do run { target { aarch64_sve256_hw } } } */\n+/* { dg-options \"-msve-vector-bits=256\" } */\n+\n+#include \"struct_1_128.c\""}, {"sha": "07be8c9d434de641af0bedc35a70dcc6b842e396", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/struct_1_512.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct_1_512.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct_1_512.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct_1_512.c?ref=38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9", "patch": "@@ -0,0 +1,4 @@\n+/* { dg-do run { target { aarch64_sve512_hw } } } */\n+/* { dg-options \"-msve-vector-bits=512\" } */\n+\n+#include \"struct_1_128.c\""}, {"sha": "9899c4e81c3b6f984013c08a11841566ec1ff637", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/struct_2_1024.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct_2_1024.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct_2_1024.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct_2_1024.c?ref=38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9", "patch": "@@ -0,0 +1,4 @@\n+/* { dg-do run { target { aarch64_sve1024_hw } } } */\n+/* { dg-options \"-msve-vector-bits=1024\" } */\n+\n+#include \"struct_2_128.c\""}, {"sha": "4a608b969ff6143ad4da3987110689eef23de222", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/struct_2_128.c", "status": "added", "additions": 701, "deletions": 0, "changes": 701, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct_2_128.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct_2_128.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct_2_128.c?ref=38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9", "patch": "@@ -0,0 +1,701 @@\n+/* { dg-do run { target { aarch64_sve128_hw } } } */\n+/* { dg-require-effective-target aarch64_little_endian } */\n+/* { dg-options \"-msve-vector-bits=128\" } */\n+\n+#include \"struct.h\"\n+\n+struct pst1\n+{\n+  fixed_uint32_t u32;\n+  fixed_uint64_t u64;\n+};\n+\n+ASM_FUNCTION (make_pst1_asm, struct pst1, (),\n+\t      \"mov z0.s, #0x1ffffe00\\n\\t\"\n+\t      \"mov z1.d, #0x7f80\");\n+\n+ASM_FUNCTION (passthru_pst1_asm, struct pst1, (struct pst1), \"\");\n+\n+ASM_FUNCTION (passthru_pst1_z6_asm,\n+\t      struct pst1, (svint32_t, svint32_t, svint32_t, svint32_t,\n+\t\t\t    svint32_t, svint32_t, struct pst1),\n+\t      \"mov z0.d, z6.d\\n\\t\"\n+\t      \"mov z1.d, z7.d\");\n+\n+ASM_FUNCTION (passthru_pst1_x0_asm,\n+\t      struct pst1, (svint32_t, svint32_t, svint32_t, svint32_t,\n+\t\t\t    svint32_t, svint32_t, svint32_t, struct pst1),\n+\t      \"ptrue p0.b\\n\\t\"\n+\t      \"ld1w z0.s, p0/z, [x0]\\n\\t\"\n+\t      \"ld1d z1.d, p0/z, [x0, #1, mul vl]\");\n+\n+void\n+test_pst1 (struct pst1 *x)\n+{\n+  svbool_t pg = svptrue_b8 ();\n+  if (svptest_any (pg, svcmpne (pg, x->u32, 0x1ffffe00))\n+      || svptest_any (pg, svcmpne (pg, x->u64, 0x7f80)))\n+    __builtin_abort ();\n+}\n+\n+struct pst1 deref_pst1 (struct pst1 *ptr) { return *ptr; }\n+struct pst1 passthru_pst1 (struct pst1 x) { return x; }\n+\n+struct pst1\n+passthru_pst1_z6 (svint32_t z0, svint32_t z1, svint32_t z2, svint32_t z3,\n+\t\t  svint32_t z4, svint32_t z5, struct pst1 z6)\n+{\n+  return z6;\n+}\n+\n+struct pst1\n+passthru_pst1_x0 (svint32_t z0, svint32_t z1, svint32_t z2, svint32_t z3,\n+\t\t  svint32_t z4, svint32_t z5, svint32_t z6, struct pst1 x0)\n+{\n+  return x0;\n+}\n+\n+void consume_pst1 (struct pst1 x) { test_pst1 (&x); }\n+\n+static void\n+run_pst1_tests (void)\n+{\n+  svint32_t s32 = svdup_s32 (0);\n+  svbool_t pg = svptrue_b8 ();\n+\n+  CLEANSE; struct pst1 res = make_pst1_asm ();\n+  CLEANSE; test_pst1 (&res);\n+  CLEANSE; consume_pst1 (deref_pst1 (&res));\n+  CLEANSE; consume_pst1 (passthru_pst1_asm (res));\n+  CLEANSE; consume_pst1 (passthru_pst1 (res));\n+  CLEANSE; consume_pst1 (passthru_pst1_z6_asm (s32, s32, s32, s32,\n+\t\t\t\t\t       s32, s32, res));\n+  CLEANSE; consume_pst1 (passthru_pst1_z6 (s32, s32, s32, s32,\n+\t\t\t\t\t   s32, s32, res));\n+  CLEANSE; consume_pst1 (passthru_pst1_x0_asm (s32, s32, s32, s32,\n+\t\t\t\t\t       s32, s32, s32, res));\n+  CLEANSE; consume_pst1 (passthru_pst1_x0 (s32, s32, s32, s32,\n+\t\t\t\t\t   s32, s32, s32, res));\n+}\n+\n+//--------------------------------------------------------------------------\n+\n+struct pst2\n+{\n+  fixed_uint8_t u8;\n+  fixed_uint16_t u16;\n+  struct {\n+    fixed_float64_t f64;\n+    fixed_bool_t pg;\n+  } a[4];\n+  struct pst1 sub;\n+};\n+\n+ASM_FUNCTION (make_pst2_asm, struct pst2, (),\n+\t      \"mov z0.b, #100\\n\\t\"\n+\t      \"mov z1.h, #99\\n\\t\"\n+\t      \"fmov z2.d, #1.0\\n\\t\"\n+\t      \"fmov z3.d, #2.0\\n\\t\"\n+\t      \"fmov z4.d, #3.0\\n\\t\"\n+\t      \"fmov z5.d, #4.0\\n\\t\"\n+\t      \"mov z6.s, #98\\n\\t\"\n+\t      \"mov z7.d, #97\\n\\t\"\n+\t      \"ptrue p0.b, vl5\\n\\t\"\n+\t      \"ptrue p1.b, vl6\\n\\t\"\n+\t      \"ptrue p2.b, vl7\\n\\t\"\n+\t      \"ptrue p3.b, vl8\");\n+\n+ASM_FUNCTION (passthru_pst2_asm, struct pst2, (struct pst2), \"\");\n+\n+ASM_FUNCTION (passthru_pst2_x0_asm, struct pst2, (svbool_t, struct pst2),\n+\t      \"cntd x2, all, mul #9\\n\\t\"\n+\t      \"add x2, x2, #15\\n\\t\"\n+\t      \"and x2, x2, #-16\\n\\t\"\n+\t      \"ptrue p0.b\\n\\t\"\n+\t      \"ld1b z0.b, p0/z, [x0, #0, mul vl]\\n\\t\"\n+\t      \"ld1h z1.h, p0/z, [x0, #1, mul vl]\\n\\t\"\n+\t      \"ld1d z2.d, p0/z, [x0, #2, mul vl]\\n\\t\"\n+\t      \"add x1, x0, x2\\n\\t\"\n+\t      \"ld1d z3.d, p0/z, [x1, #2, mul vl]\\n\\t\"\n+\t      \"ldr p1, [x1, #24, mul vl]\\n\\t\"\n+\t      \"add x1, x1, x2\\n\\t\"\n+\t      \"ld1d z4.d, p0/z, [x1, #2, mul vl]\\n\\t\"\n+\t      \"ldr p2, [x1, #24, mul vl]\\n\\t\"\n+\t      \"add x1, x1, x2\\n\\t\"\n+\t      \"ld1d z5.d, p0/z, [x1, #2, mul vl]\\n\\t\"\n+\t      \"ldr p3, [x1, #24, mul vl]\\n\\t\"\n+\t      \"add x1, x1, x2\\n\\t\"\n+\t      \"ld1w z6.s, p0/z, [x1, #2, mul vl]\\n\\t\"\n+\t      \"ld1d z7.d, p0/z, [x1, #3, mul vl]\\n\\t\"\n+\t      \"ldr p0, [x0, #24, mul vl]\");\n+\n+void\n+test_pst2 (struct pst2 *x)\n+{\n+  svbool_t pg = svptrue_b8 ();\n+  if (svptest_any (pg, svcmpne (pg, x->u8, 100))\n+      || svptest_any (pg, svcmpne (pg, x->u16, 99))\n+      || svptest_any (pg, svcmpne (pg, x->a[0].f64, 1.0))\n+      || svptest_any (pg, sveor_z (pg, x->a[0].pg, svptrue_pat_b8 (SV_VL5)))\n+      || svptest_any (pg, svcmpne (pg, x->a[1].f64, 2.0))\n+      || svptest_any (pg, sveor_z (pg, x->a[1].pg, svptrue_pat_b8 (SV_VL6)))\n+      || svptest_any (pg, svcmpne (pg, x->a[2].f64, 3.0))\n+      || svptest_any (pg, sveor_z (pg, x->a[2].pg, svptrue_pat_b8 (SV_VL7)))\n+      || svptest_any (pg, svcmpne (pg, x->a[3].f64, 4.0))\n+      || svptest_any (pg, sveor_z (pg, x->a[3].pg, svptrue_pat_b8 (SV_VL8)))\n+      || svptest_any (pg, svcmpne (pg, x->sub.u32, 98))\n+      || svptest_any (pg, svcmpne (pg, x->sub.u64, 97)))\n+    __builtin_abort ();\n+}\n+\n+struct pst2 deref_pst2 (struct pst2 *ptr) { return *ptr; }\n+struct pst2 passthru_pst2 (struct pst2 x) { return x; }\n+\n+struct pst2\n+passthru_pst2_x0 (svbool_t pg, struct pst2 x0)\n+{\n+  return x0;\n+}\n+\n+void\n+consume_pst2 (struct pst2 x)\n+{\n+  test_pst2 (&x);\n+}\n+\n+static void\n+run_pst2_tests (void)\n+{\n+  CLEANSE; struct pst2 res = make_pst2_asm ();\n+  CLEANSE; test_pst2 (&res);\n+  CLEANSE; consume_pst2 (deref_pst2 (&res));\n+  CLEANSE; consume_pst2 (passthru_pst2_asm (res));\n+  CLEANSE; consume_pst2 (passthru_pst2 (res));\n+  CLEANSE; consume_pst2 (passthru_pst2_x0_asm (svptrue_b8 (), res));\n+  CLEANSE; consume_pst2 (passthru_pst2_x0 (svptrue_b8 (), res));\n+}\n+\n+//--------------------------------------------------------------------------\n+\n+struct __attribute__((packed, aligned (2))) pst3\n+{\n+  fixed_bool_t p;\n+  fixed_float16_t v;\n+};\n+\n+ASM_FUNCTION (make_pst3_asm, struct pst3, (),\n+\t      \"ptrue p0.h, vl3\\n\\t\"\n+\t      \"fmov z0.h, #5.0\");\n+\n+ASM_FUNCTION (passthru_pst3_asm, struct pst3, (struct pst3), \"\");\n+\n+ASM_FUNCTION (passthru_pst3_p3_z7_asm,\n+\t      struct pst3, (svbool_t, svbool_t, svbool_t,\n+\t\t\t    svint32_t, svint32_t, svint32_t, svint32_t,\n+\t\t\t    svint32_t, svint32_t, svint32_t, struct pst3),\n+\t      \"mov z0.d, z7.d\\n\\t\"\n+\t      \"mov p0.b, p3.b\");\n+\n+ASM_FUNCTION (passthru_pst3_x0_asm,\n+\t      struct pst3, (svbool_t, svbool_t, svbool_t, svbool_t,\n+\t\t\t    struct pst3),\n+\t      \"addpl x1, x0, #1\\n\\t\"\n+\t      \"ld1h z0.h, p1/z, [x1]\\n\\t\"\n+\t      \"ldr p0, [x0]\");\n+\n+void\n+test_pst3 (struct pst3 *x)\n+{\n+  svbool_t pg = svptrue_b8 ();\n+  if (svptest_any (pg, sveor_z (pg, x->p, svptrue_pat_b16 (SV_VL3)))\n+      || svptest_any (pg, svcmpne (pg, x->v, 5.0)))\n+    __builtin_abort ();\n+}\n+\n+struct pst3 deref_pst3 (struct pst3 *ptr) { return *ptr; }\n+struct pst3 passthru_pst3 (struct pst3 x) { return x; }\n+\n+struct pst3\n+passthru_pst3_p3_z7 (svbool_t p0, svbool_t p1, svbool_t p2,\n+\t\t     svint32_t z0, svint32_t z1, svint32_t z2, svint32_t z3,\n+\t\t     svint32_t z4, svint32_t z5, svint32_t z6,\n+\t\t     struct pst3 p3_z7)\n+{\n+  return p3_z7;\n+}\n+\n+struct pst3\n+passthru_pst3_x0 (svbool_t p0, svbool_t p1, svbool_t p2, svbool_t p3,\n+\t\t  struct pst3 x0)\n+{\n+  return x0;\n+}\n+\n+void consume_pst3 (struct pst3 x) { test_pst3 (&x); }\n+\n+static void\n+run_pst3_tests (void)\n+{\n+  svint32_t s32 = svdup_s32 (0);\n+  svbool_t pg = svptrue_b8 ();\n+\n+  CLEANSE; struct pst3 res = make_pst3_asm ();\n+  CLEANSE; test_pst3 (&res);\n+  CLEANSE; consume_pst3 (deref_pst3 (&res));\n+  CLEANSE; consume_pst3 (passthru_pst3_asm (res));\n+  CLEANSE; consume_pst3 (passthru_pst3 (res));\n+  CLEANSE; consume_pst3 (passthru_pst3_p3_z7_asm (pg, pg, pg,\n+\t\t\t\t\t\t  s32, s32, s32, s32,\n+\t\t\t\t\t\t  s32, s32, s32, res));\n+  CLEANSE; consume_pst3 (passthru_pst3_p3_z7 (pg, pg, pg,\n+\t\t\t\t\t      s32, s32, s32, s32,\n+\t\t\t\t\t      s32, s32, s32, res));\n+  CLEANSE; consume_pst3 (passthru_pst3_x0_asm (pg, pg, pg, pg, res));\n+  CLEANSE; consume_pst3 (passthru_pst3_x0 (pg, pg, pg, pg, res));\n+}\n+\n+//--------------------------------------------------------------------------\n+\n+struct pst4\n+{\n+  fixed_bool_t p1;\n+  fixed_bool_t p2 __attribute__((aligned (256)));\n+  fixed_bool_t p3 __attribute__((aligned (2048)));\n+};\n+\n+ASM_FUNCTION (make_pst4_asm, struct pst4, (),\n+\t      \"ptrue p0.h, vl7\\n\\t\"\n+\t      \"ptrue p1.h, mul3\\n\\t\"\n+\t      \"ptrue p2.h, vl5\");\n+\n+ASM_FUNCTION (passthru_pst4_asm, struct pst4, (struct pst4), \"\");\n+\n+ASM_FUNCTION (passthru_pst4_p1_asm,\n+\t      struct pst4, (svbool_t, struct pst4),\n+\t      \"mov p0.b, p1.b\\n\\t\"\n+\t      \"mov p1.b, p2.b\\n\\t\"\n+\t      \"mov p2.b, p3.b\");\n+\n+ASM_FUNCTION (passthru_pst4_x0_asm,\n+\t      struct pst4, (svbool_t, svbool_t, struct pst4),\n+\t      \"ldr p0, [x0]\\n\\t\"\n+\t      \"add x0, x0, #256\\n\\t\"\n+\t      \"ldr p1, [x0]\\n\\t\"\n+\t      \"add x0, x0, #2048 - 256\\n\\t\"\n+\t      \"ldr p2, [x0]\");\n+\n+void\n+test_pst4 (struct pst4 *x)\n+{\n+  svbool_t pg = svptrue_b8 ();\n+  if (svptest_any (pg, sveor_z (pg, x->p1, svptrue_pat_b16 (SV_VL7)))\n+      || svptest_any (pg, sveor_z (pg, x->p2, svptrue_pat_b16 (SV_MUL3)))\n+      || svptest_any (pg, sveor_z (pg, x->p3, svptrue_pat_b16 (SV_VL5))))\n+    __builtin_abort ();\n+}\n+\n+struct pst4 deref_pst4 (struct pst4 *ptr) { return *ptr; }\n+struct pst4 passthru_pst4 (struct pst4 x) { return x; }\n+\n+struct pst4\n+passthru_pst4_p1 (svbool_t p0, struct pst4 p1)\n+{\n+  return p1;\n+}\n+\n+struct pst4\n+passthru_pst4_x0 (svbool_t p0, svbool_t p1, struct pst4 x0)\n+{\n+  return x0;\n+}\n+\n+void consume_pst4 (struct pst4 x) { test_pst4 (&x); }\n+\n+static void\n+run_pst4_tests (void)\n+{\n+  svbool_t pg = svptrue_b8 ();\n+\n+  CLEANSE; struct pst4 res = make_pst4_asm ();\n+  CLEANSE; test_pst4 (&res);\n+  CLEANSE; consume_pst4 (deref_pst4 (&res));\n+  CLEANSE; consume_pst4 (passthru_pst4_asm (res));\n+  CLEANSE; consume_pst4 (passthru_pst4 (res));\n+  CLEANSE; consume_pst4 (passthru_pst4_p1_asm (pg, res));\n+  CLEANSE; consume_pst4 (passthru_pst4_p1 (pg, res));\n+  CLEANSE; consume_pst4 (passthru_pst4_x0_asm (pg, pg, res));\n+  CLEANSE; consume_pst4 (passthru_pst4_x0 (pg, pg, res));\n+}\n+\n+//--------------------------------------------------------------------------\n+\n+struct pst5\n+{\n+  fixed_uint16_t v[8];\n+};\n+\n+ASM_FUNCTION (make_pst5_asm, struct pst5, (),\n+\t      \"index z0.h, #0, #-1\\n\\t\"\n+\t      \"index z1.h, #0, #-2\\n\\t\"\n+\t      \"index z2.h, #0, #-3\\n\\t\"\n+\t      \"index z3.h, #0, #-4\\n\\t\"\n+\t      \"index z4.h, #0, #-5\\n\\t\"\n+\t      \"index z5.h, #0, #-6\\n\\t\"\n+\t      \"index z6.h, #0, #-7\\n\\t\"\n+\t      \"index z7.h, #0, #-8\");\n+\n+ASM_FUNCTION (passthru_pst5_asm, struct pst5, (struct pst5), \"\");\n+\n+void\n+test_pst5 (struct pst5 *x)\n+{\n+  svbool_t pg = svptrue_b8 ();\n+  for (int i = 0; i < 8; ++i)\n+    if (svptest_any (pg, svcmpne (pg, x->v[i], svindex_u16 (0, -1 - i))))\n+      __builtin_abort ();\n+}\n+\n+struct pst5 deref_pst5 (struct pst5 *ptr) { return *ptr; }\n+struct pst5 passthru_pst5 (struct pst5 x) { return x; }\n+\n+void consume_pst5 (struct pst5 x) { test_pst5 (&x); }\n+\n+static void\n+run_pst5_tests (void)\n+{\n+  CLEANSE; struct pst5 res = make_pst5_asm ();\n+  CLEANSE; test_pst5 (&res);\n+  CLEANSE; consume_pst5 (deref_pst5 (&res));\n+  CLEANSE; consume_pst5 (passthru_pst5_asm (res));\n+  CLEANSE; consume_pst5 (passthru_pst5 (res));\n+}\n+\n+//--------------------------------------------------------------------------\n+\n+struct pst6\n+{\n+  fixed_uint16_t v[9];\n+};\n+\n+ASM_FUNCTION (make_pst6_asm, struct pst6, (),\n+\t      \"mov x0, #10\\n\\t\"\n+\t      \"ptrue p0.b\\n\"\n+\t      \"1:\\n\\t\"\n+\t      \"index z0.h, #0, w0\\n\\t\"\n+\t      \"st1h z0.h, p0, [x8]\\n\\t\"\n+\t      \"add x0, x0, #1\\n\\t\"\n+\t      \"incb x8\\n\\t\"\n+\t      \"cmp x0, #19\\n\\t\"\n+\t      \"bne 1b\");\n+\n+ASM_FUNCTION (passthru_pst6_asm, struct pst6, (struct pst6),\n+\t      \"mov x1, x0\\n\\t\"\n+\t      \"mov x0, x8\\n\\t\"\n+\t      \"cntb x2, all, mul #9\\n\\t\"\n+\t      \"b memcpy\");\n+\n+void\n+test_pst6 (struct pst6 *x)\n+{\n+  svbool_t pg = svptrue_b8 ();\n+  for (int i = 0; i < 9; ++i)\n+    if (svptest_any (pg, svcmpne (pg, x->v[i], svindex_u16 (0, i + 10))))\n+      __builtin_abort ();\n+}\n+\n+struct pst6 deref_pst6 (struct pst6 *ptr) { return *ptr; }\n+struct pst6 passthru_pst6 (struct pst6 x) { return x; }\n+\n+void consume_pst6 (struct pst6 x) { test_pst6 (&x); }\n+\n+static void\n+run_pst6_tests (void)\n+{\n+  CLEANSE; struct pst6 res = make_pst6_asm ();\n+  CLEANSE; test_pst6 (&res);\n+  CLEANSE; consume_pst6 (deref_pst6 (&res));\n+  CLEANSE; consume_pst6 (passthru_pst6_asm (res));\n+  CLEANSE; consume_pst6 (passthru_pst6 (res));\n+}\n+\n+//--------------------------------------------------------------------------\n+\n+struct pst7\n+{\n+  fixed_bool_t p[2][2];\n+};\n+\n+ASM_FUNCTION (make_pst7_asm, struct pst7, (),\n+\t      \"ptrue p0.b, vl6\\n\\t\"\n+\t      \"ptrue p1.b, vl7\\n\\t\"\n+\t      \"ptrue p2.h, vl3\\n\\t\"\n+\t      \"ptrue p3.h, vl2\");\n+\n+ASM_FUNCTION (passthru_pst7_asm, struct pst7, (struct pst7), \"\");\n+\n+void\n+test_pst7 (struct pst7 *x)\n+{\n+  svbool_t pg = svptrue_b8 ();\n+  if (svptest_any (pg, sveor_z (pg, x->p[0][0], svptrue_pat_b8 (SV_VL6)))\n+      || svptest_any (pg, sveor_z (pg, x->p[0][1], svptrue_pat_b8 (SV_VL7)))\n+      || svptest_any (pg, sveor_z (pg, x->p[1][0], svptrue_pat_b16 (SV_VL3)))\n+      || svptest_any (pg, sveor_z (pg, x->p[1][1], svptrue_pat_b16 (SV_VL2))))\n+    __builtin_abort ();\n+}\n+\n+struct pst7 deref_pst7 (struct pst7 *ptr) { return *ptr; }\n+struct pst7 passthru_pst7 (struct pst7 x) { return x; }\n+\n+void consume_pst7 (struct pst7 x) { test_pst7 (&x); }\n+\n+static void\n+run_pst7_tests (void)\n+{\n+  CLEANSE; struct pst7 res = make_pst7_asm ();\n+  CLEANSE; test_pst7 (&res);\n+  CLEANSE; consume_pst7 (deref_pst7 (&res));\n+  CLEANSE; consume_pst7 (passthru_pst7_asm (res));\n+  CLEANSE; consume_pst7 (passthru_pst7 (res));\n+}\n+\n+//--------------------------------------------------------------------------\n+\n+struct pst8\n+{\n+  fixed_bool_t p[2][3];\n+};\n+\n+ASM_FUNCTION (make_pst8_asm, struct pst8, (),\n+\t      \"ptrue p3.h, vl2\\n\\t\"\n+\t      \"str p3, [x8]\\n\\t\"\n+\t      \"ptrue p3.h, vl3\\n\\t\"\n+\t      \"str p3, [x8, #1, mul vl]\\n\\t\"\n+\t      \"ptrue p3.h, vl4\\n\\t\"\n+\t      \"str p3, [x8, #2, mul vl]\\n\\t\"\n+\t      \"ptrue p3.s, vl2\\n\\t\"\n+\t      \"str p3, [x8, #3, mul vl]\\n\\t\"\n+\t      \"ptrue p3.s, vl3\\n\\t\"\n+\t      \"str p3, [x8, #4, mul vl]\\n\\t\"\n+\t      \"ptrue p3.s, vl4\\n\\t\"\n+\t      \"str p3, [x8, #5, mul vl]\");\n+\n+ASM_FUNCTION (passthru_pst8_asm, struct pst8, (struct pst8),\n+\t      \"cntw x1, all, mul #3\\n\\t\"\n+\t      \"whilelo p0.b, xzr, x1\\n\\t\"\n+\t      \"ld1b z0.b, p0/z, [x0]\\n\\t\"\n+\t      \"st1b z0.b, p0, [x8]\");\n+\n+void\n+test_pst8 (struct pst8 *x)\n+{\n+  svbool_t pg = svptrue_b8 ();\n+  if (svptest_any (pg, sveor_z (pg, x->p[0][0], svptrue_pat_b16 (SV_VL2)))\n+      || svptest_any (pg, sveor_z (pg, x->p[0][1], svptrue_pat_b16 (SV_VL3)))\n+      || svptest_any (pg, sveor_z (pg, x->p[0][2], svptrue_pat_b16 (SV_VL4)))\n+      || svptest_any (pg, sveor_z (pg, x->p[1][0], svptrue_pat_b32 (SV_VL2)))\n+      || svptest_any (pg, sveor_z (pg, x->p[1][1], svptrue_pat_b32 (SV_VL3)))\n+      || svptest_any (pg, sveor_z (pg, x->p[1][2], svptrue_pat_b32 (SV_VL4))))\n+    __builtin_abort ();\n+}\n+\n+struct pst8 deref_pst8 (struct pst8 *ptr) { return *ptr; }\n+struct pst8 passthru_pst8 (struct pst8 x) { return x; }\n+\n+void consume_pst8 (struct pst8 x) { test_pst8 (&x); }\n+\n+static void\n+run_pst8_tests (void)\n+{\n+  CLEANSE; struct pst8 res = make_pst8_asm ();\n+  CLEANSE; test_pst8 (&res);\n+  CLEANSE; consume_pst8 (deref_pst8 (&res));\n+  CLEANSE; consume_pst8 (passthru_pst8_asm (res));\n+  CLEANSE; consume_pst8 (passthru_pst8 (res));\n+}\n+\n+//--------------------------------------------------------------------------\n+\n+struct nonpst1\n+{\n+  int x;\n+  fixed_uint8_t v;\n+  fixed_bool_t p;\n+};\n+\n+ASM_FUNCTION (make_nonpst1_asm, struct nonpst1, (),\n+\t      \"mov w0, #42\\n\\t\"\n+\t      \"str w0, [x8]\\n\\t\"\n+\t      \"add x0, x8, #16\\n\\t\"\n+\t      \"ptrue p0.b\\n\\t\"\n+\t      \"index z0.b, #0, #3\\n\\t\"\n+\t      \"st1b z0.b, p0, [x0]\\n\\t\"\n+\t      \"ptrue p3.b, vl5\\n\\t\"\n+\t      \"str p3, [x0, #8, mul vl]\");\n+\n+ASM_FUNCTION (passthru_nonpst1_asm, struct nonpst1, (struct nonpst1),\n+\t      \"mov x1, x0\\n\\t\"\n+\t      \"mov x0, x8\\n\\t\"\n+\t      \"cntd x2, all, mul #9\\n\\t\"\n+\t      \"add x2, x2, #16\\n\\t\"\n+\t      \"b memcpy\");\n+\n+void\n+test_nonpst1 (struct nonpst1 *x)\n+{\n+  svbool_t pg = svptrue_b8 ();\n+  if (x->x != 42\n+      || svptest_any (pg, svcmpne (pg, x->v, svindex_u8 (0, 3)))\n+      || svptest_any (pg, sveor_z (pg, x->p, svptrue_pat_b8 (SV_VL5))))\n+    __builtin_abort ();\n+}\n+\n+struct nonpst1 deref_nonpst1 (struct nonpst1 *ptr) { return *ptr; }\n+struct nonpst1 passthru_nonpst1 (struct nonpst1 x) { return x; }\n+\n+void consume_nonpst1 (struct nonpst1 x) { test_nonpst1 (&x); }\n+\n+static void\n+run_nonpst1_tests (void)\n+{\n+  CLEANSE; struct nonpst1 res = make_nonpst1_asm ();\n+  CLEANSE; test_nonpst1 (&res);\n+  CLEANSE; consume_nonpst1 (deref_nonpst1 (&res));\n+  CLEANSE; consume_nonpst1 (passthru_nonpst1_asm (res));\n+  CLEANSE; consume_nonpst1 (passthru_nonpst1 (res));\n+}\n+\n+//--------------------------------------------------------------------------\n+\n+struct nonpst2\n+{\n+  union { struct { fixed_bool_t p; }; };\n+};\n+\n+ASM_FUNCTION (make_nonpst2_asm, struct nonpst2, (),\n+\t      \"ptrue p3.h, mul3\\n\\t\"\n+\t      \"cntd x2\\n\\t\"\n+\t      \"cmp x2, #16\\n\\t\"\n+\t      \"b.ls 1f\\n\\t\"\n+\t      \"str p3, [x8]\\n\\t\"\n+\t      \"ret\\n\"\n+\t      \"1:\\n\\t\"\n+\t      \"addvl sp, sp, #-1\\n\\t\"\n+\t      \"str p3, [sp]\\n\\t\"\n+\t      \"ldp x0, x1, [sp]\\n\\t\"\n+\t      \"addvl sp, sp, #1\");\n+\n+ASM_FUNCTION (passthru_nonpst2_asm, struct nonpst2, (struct nonpst2),\n+\t      \"cntb x2\\n\\t\"\n+\t      \"cmp x2, #128\\n\\t\"\n+\t      \"b.eq 1f\\n\\t\"\n+\t      \"b.lo 2f\\n\\t\"\n+\t      \"ldr p3, [x0]\\n\\t\"\n+\t      \"str p3, [x8]\\n\"\n+\t      \"1:\\n\\t\"\n+\t      \"ret\\n\"\n+\t      \"2:\\n\\t\"\n+\t      \"mov x3, #-1\\n\\t\"\n+#if __ARM_BIG_ENDIAN\n+\t      \"lsr x3, x3, x2\\n\\t\"\n+#else\n+\t      \"lsl x3, x3, x2\\n\\t\"\n+#endif\n+\t      \"bic x1, x0, x3\\n\\t\"\n+\t      \"cmp x2, #64\\n\\t\"\n+\t      \"csel x0, x0, x1, eq\");\n+\n+void\n+test_nonpst2 (struct nonpst2 *x)\n+{\n+  svbool_t pg = svptrue_b8 ();\n+  if (svptest_any (pg, sveor_z (pg, x->p, svptrue_pat_b16 (SV_MUL3))))\n+    __builtin_abort ();\n+}\n+\n+struct nonpst2 deref_nonpst2 (struct nonpst2 *ptr) { return *ptr; }\n+struct nonpst2 passthru_nonpst2 (struct nonpst2 x) { return x; }\n+\n+void consume_nonpst2 (struct nonpst2 x) { test_nonpst2 (&x); }\n+\n+static void\n+run_nonpst2_tests (void)\n+{\n+  CLEANSE; struct nonpst2 res = make_nonpst2_asm ();\n+  CLEANSE; test_nonpst2 (&res);\n+  CLEANSE; consume_nonpst2 (deref_nonpst2 (&res));\n+  CLEANSE; consume_nonpst2 (passthru_nonpst2_asm (res));\n+  CLEANSE; consume_nonpst2 (passthru_nonpst2 (res));\n+}\n+\n+//--------------------------------------------------------------------------\n+\n+struct nonpst3\n+{\n+  union { struct { fixed_int32_t v; }; };\n+};\n+\n+ASM_FUNCTION (make_nonpst3_asm, struct nonpst3, (),\n+\t      \"ptrue p0.b\\n\\t\"\n+\t      \"index z1.s, #15, #-9\\n\\t\"\n+\t      \"cntb x2\\n\\t\"\n+\t      \"cmp x2, #16\\n\\t\"\n+\t      \"b.ls 1f\\n\\t\"\n+\t      \"st1w z1.s, p0, [x8]\\n\\t\"\n+\t      \"ret\\n\"\n+\t      \"1:\\n\\t\"\n+\t      \"addvl sp, sp, #-1\\n\\t\"\n+\t      \"st1w z1.s, p0, [sp]\\n\\t\"\n+\t      \"ldp x0, x1, [sp]\\n\\t\"\n+\t      \"addvl sp, sp, #1\");\n+\n+ASM_FUNCTION (passthru_nonpst3_asm, struct nonpst3, (struct nonpst3),\n+\t      \"cntb x2\\n\\t\"\n+\t      \"cmp x2, #16\\n\\t\"\n+\t      \"b.ls 1f\\n\\t\"\n+\t      \"ptrue p0.b\\n\\t\"\n+\t      \"ld1w z1.s, p0/z, [x0]\\n\\t\"\n+\t      \"st1w z1.s, p0, [x8]\\n\"\n+\t      \"1:\");\n+\n+void\n+test_nonpst3 (struct nonpst3 *x)\n+{\n+  svbool_t pg = svptrue_b8 ();\n+  if (svptest_any (pg, svcmpne (pg, x->v, svindex_s32 (15, -9))))\n+    __builtin_abort ();\n+}\n+\n+struct nonpst3 deref_nonpst3 (struct nonpst3 *ptr) { return *ptr; }\n+struct nonpst3 passthru_nonpst3 (struct nonpst3 x) { return x; }\n+\n+void consume_nonpst3 (struct nonpst3 x) { test_nonpst3 (&x); }\n+\n+static void\n+run_nonpst3_tests (void)\n+{\n+  CLEANSE; struct nonpst3 res = make_nonpst3_asm ();\n+  CLEANSE; test_nonpst3 (&res);\n+  CLEANSE; consume_nonpst3 (deref_nonpst3 (&res));\n+  CLEANSE; consume_nonpst3 (passthru_nonpst3_asm (res));\n+  CLEANSE; consume_nonpst3 (passthru_nonpst3 (res));\n+}\n+\n+//--------------------------------------------------------------------------\n+\n+int\n+main (void)\n+{\n+  run_pst1_tests ();\n+  run_pst2_tests ();\n+  run_pst3_tests ();\n+  run_pst4_tests ();\n+  run_pst5_tests ();\n+  run_pst6_tests ();\n+  run_pst7_tests ();\n+  run_pst8_tests ();\n+  run_nonpst1_tests ();\n+  run_nonpst2_tests ();\n+  run_nonpst3_tests ();\n+  return 0;\n+}"}, {"sha": "6df410d47133515494caa5c656f969b8f0b8da72", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/struct_2_2048.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct_2_2048.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct_2_2048.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct_2_2048.c?ref=38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9", "patch": "@@ -0,0 +1,4 @@\n+/* { dg-do run { target { aarch64_sve2048_hw } } } */\n+/* { dg-options \"-msve-vector-bits=2048\" } */\n+\n+#include \"struct_2_128.c\""}, {"sha": "230fa8c9664e10e26dc07adad9afa4fb39e2fe96", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/struct_2_256.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct_2_256.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct_2_256.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct_2_256.c?ref=38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9", "patch": "@@ -0,0 +1,4 @@\n+/* { dg-do run { target { aarch64_sve256_hw } } } */\n+/* { dg-options \"-msve-vector-bits=256\" } */\n+\n+#include \"struct_2_128.c\""}, {"sha": "e6d0512c3cd1a0a346c94f98fe4efc47d0bab05c", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/struct_2_512.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct_2_512.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct_2_512.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct_2_512.c?ref=38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9", "patch": "@@ -0,0 +1,4 @@\n+/* { dg-do run { target { aarch64_sve512_hw } } } */\n+/* { dg-options \"-msve-vector-bits=512\" } */\n+\n+#include \"struct_2_128.c\""}, {"sha": "443ce4cca6ed0bbfa1a7e1dcc9a8fc90eb75116e", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/struct_3_128.c", "status": "added", "additions": 1092, "deletions": 0, "changes": 1092, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct_3_128.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct_3_128.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct_3_128.c?ref=38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9", "patch": "@@ -0,0 +1,1092 @@\n+/* { dg-options \"-O -msve-vector-bits=128\" } */\n+/* { dg-require-effective-target aarch64_little_endian }\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include \"struct.h\"\n+\n+#define CONSUME(VAR)\t\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    register void *ptr_ asm (\"x7\") = &(VAR);\t\\\n+    asm volatile (\"\" :: \"r\" (ptr_) : \"memory\");\t\\\n+  }\n+\n+#define SEL2(TAG, TYPE)\t\t\t\t\\\n+  TAG TYPE\t\t\t\t\t\\\n+  sel2_##TYPE (TAG TYPE x, TAG TYPE y)\t\t\\\n+  {\t\t\t\t\t\t\\\n+    return y;\t\t\t\t\t\\\n+  }\n+\n+#define WRAP(TYPE)\t\t\t\t\\\n+  struct wrap_##TYPE\t\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    TYPE data;\t\t\t\t\t\\\n+  };\t\t\t\t\t\t\\\n+  SEL2 (struct, wrap_##TYPE)\n+\n+/*\n+** sel2_wrap_fixed_int8_t:\n+**\tmov\tz0\\.d, z1\\.d\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_wrap_fixed_int8_t\\n} } } */\n+WRAP (fixed_int8_t);\n+\n+/*\n+** sel2_wrap_fixed_int16_t:\n+**\tmov\tz0\\.d, z1\\.d\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_wrap_fixed_int16_t\\n} } } */\n+WRAP (fixed_int16_t);\n+\n+/*\n+** sel2_wrap_fixed_int32_t:\n+**\tmov\tz0\\.d, z1\\.d\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_wrap_fixed_int32_t\\n} } } */\n+WRAP (fixed_int32_t);\n+\n+/*\n+** sel2_wrap_fixed_int64_t:\n+**\tmov\tz0\\.d, z1\\.d\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_wrap_fixed_int64_t\\n} } } */\n+WRAP (fixed_int64_t);\n+\n+/*\n+** sel2_wrap_fixed_uint8_t:\n+**\tmov\tz0\\.d, z1\\.d\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_wrap_fixed_uint8_t\\n} } } */\n+WRAP (fixed_uint8_t);\n+\n+/*\n+** sel2_wrap_fixed_uint16_t:\n+**\tmov\tz0\\.d, z1\\.d\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_wrap_fixed_uint16_t\\n} } } */\n+WRAP (fixed_uint16_t);\n+\n+/*\n+** sel2_wrap_fixed_uint32_t:\n+**\tmov\tz0\\.d, z1\\.d\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_wrap_fixed_uint32_t\\n} } } */\n+WRAP (fixed_uint32_t);\n+\n+/*\n+** sel2_wrap_fixed_uint64_t:\n+**\tmov\tz0\\.d, z1\\.d\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_wrap_fixed_uint64_t\\n} } } */\n+WRAP (fixed_uint64_t);\n+\n+/*\n+** sel2_wrap_fixed_bfloat16_t:\n+**\tmov\tz0\\.d, z1\\.d\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_wrap_fixed_bfloat16_t\\n} } } */\n+WRAP (fixed_bfloat16_t);\n+\n+/*\n+** sel2_wrap_fixed_float16_t:\n+**\tmov\tz0\\.d, z1\\.d\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_wrap_fixed_float16_t\\n} } } */\n+WRAP (fixed_float16_t);\n+\n+/*\n+** sel2_wrap_fixed_float32_t:\n+**\tmov\tz0\\.d, z1\\.d\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_wrap_fixed_float32_t\\n} } } */\n+WRAP (fixed_float32_t);\n+\n+/*\n+** sel2_wrap_fixed_float64_t:\n+**\tmov\tz0\\.d, z1\\.d\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_wrap_fixed_float64_t\\n} } } */\n+WRAP (fixed_float64_t);\n+\n+/*\n+** sel2_wrap_fixed_bool_t:\n+**\tmov\tp0\\.b, p1\\.b\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_wrap_fixed_bool_t\\n} } } */\n+WRAP (fixed_bool_t);\n+\n+struct pst_arr1\n+{\n+  fixed_uint8_t u8[1];\n+};\n+\n+/*\n+** sel2_pst_arr1:\n+**\tmov\tz0\\.d, z1\\.d\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_arr1\\n} } } */\n+SEL2 (struct, pst_arr1)\n+\n+/*\n+** test_pst_arr1:\n+**\teor\tz0\\.b, z0\\.b, #(?:0x)?1\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_arr1\\n} } } */\n+svuint8_t\n+test_pst_arr1 (struct pst_arr1 x)\n+{\n+  return sveor_x (svptrue_b8 (), x.u8[0], 1);\n+}\n+\n+struct pst_arr2\n+{\n+  fixed_uint8_t u8[2];\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_arr2\\n} } } */\n+SEL2 (struct, pst_arr2)\n+\n+/*\n+** test_pst_arr2:\n+**\tsub\tz0\\.b, z0\\.b, z1\\.b\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_arr2\\n} } } */\n+svuint8_t\n+test_pst_arr2 (struct pst_arr2 x)\n+{\n+  return svsub_x (svptrue_b8 (), x.u8[0], x.u8[1]);\n+}\n+\n+struct pst_arr3\n+{\n+  fixed_uint16_t u16[3];\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_arr3\\n} } } */\n+SEL2 (struct, pst_arr3)\n+\n+/*\n+** test_pst_arr3:\n+**\tsub\tz0\\.h, z0\\.h, z2\\.h\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_arr3\\n} } } */\n+svuint16_t\n+test_pst_arr3 (struct pst_arr3 x)\n+{\n+  return svsub_x (svptrue_b8 (), x.u16[0], x.u16[2]);\n+}\n+\n+struct pst_arr4\n+{\n+  fixed_uint32_t u32[4];\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_arr4\\n} } } */\n+SEL2 (struct, pst_arr4)\n+\n+/*\n+** test_pst_arr4:\n+**\tsub\tz0\\.s, z0\\.s, z3\\.s\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_arr4\\n} } } */\n+svuint32_t\n+test_pst_arr4 (struct pst_arr4 x)\n+{\n+  return svsub_x (svptrue_b8 (), x.u32[0], x.u32[3]);\n+}\n+\n+struct pst_arr5\n+{\n+  fixed_uint64_t u64[2][2][2];\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_arr5\\n} } } */\n+SEL2 (struct, pst_arr5)\n+\n+/*\n+** test_pst_arr5:\n+**\tsub\tsp, sp, #128\n+**\tstr\tz0, \\[sp\\]\n+**\tstr\tz1, \\[sp, #1, mul vl\\]\n+**\tstr\tz2, \\[sp, #2, mul vl\\]\n+**\tstr\tz3, \\[sp, #3, mul vl\\]\n+**\tstr\tz4, \\[sp, #4, mul vl\\]\n+**\tstr\tz5, \\[sp, #5, mul vl\\]\n+**\tstr\tz6, \\[sp, #6, mul vl\\]\n+**\tstr\tz7, \\[sp, #7, mul vl\\]\n+**\tmov\t(x7, sp|w7, wsp)\n+**\tadd\tsp, sp, #?128\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_arr5\\n} } } */\n+void\n+test_pst_arr5 (struct pst_arr5 x)\n+{\n+  CONSUME (x);\n+}\n+\n+/*\n+** test_pst_arr5_x0:\n+** (\n+**\tmov\tz0\\.d, z7\\.d\n+**\tmov\t(x7, x0|w7, w0)\n+** |\n+**\tmov\t(x7, x0|w7, w0)\n+**\tmov\tz0\\.d, z7\\.d\n+** )\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_arr5_x0\\n} } } */\n+svint32_t\n+test_pst_arr5_x0 (svint32_t z0, struct pst_arr5 x,\n+\t\t  svint32_t z1, svint32_t z2, svint32_t z3, svint32_t z4,\n+\t\t  svint32_t z5, svint32_t z6, svint32_t z7)\n+{\n+  CONSUME (x);\n+  return z7;\n+}\n+\n+/*\n+** test_pst_arr5_x7:\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_arr5_x7\\n} } } */\n+svint32_t\n+test_pst_arr5_x7 (svint32_t z0, int x0, int x1, int x2, int x3, int x4,\n+\t\t  int x5, int x6, struct pst_arr5 x)\n+{\n+  CONSUME (x);\n+  return z0;\n+}\n+\n+/*\n+** test_pst_arr5_sp: { target lp64 }\n+**\tldr\tx7, \\[sp\\]\n+**\tret\n+*/\n+/*\n+** test_pst_arr5_sp: { target ilp32 }\n+**\tldr\tw7, \\[sp\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_arr5_sp\\n} } } */\n+svint32_t\n+test_pst_arr5_sp (svint32_t z0, int x0, int x1, int x2, int x3, int x4,\n+\t\t  int x5, int x6, int x7, struct pst_arr5 x)\n+{\n+  CONSUME (x);\n+  return z0;\n+}\n+\n+struct pst_arr6\n+{\n+  fixed_bool_t b[2][2];\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_arr6\\n} } } */\n+SEL2 (struct, pst_arr6)\n+\n+/*\n+** test_pst_arr6:\n+**\t...\n+**\tbrkpa\tp0\\.b, p0/z, p2\\.b, p3\\.b\n+**\t...\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_arr6\\n} } } */\n+fixed_bool_t\n+test_pst_arr6 (struct pst_arr6 x)\n+{\n+  return svbrkpa_z (x.b[0][0], x.b[1][0], x.b[1][1]);\n+}\n+\n+/*\n+** test_pst_arr6_x0:\n+** (\n+**\tmov\tp0\\.b, p3\\.b\n+**\tmov\t(x7, x0|w7, w0)\n+** |\n+**\tmov\t(x7, x0|w7, w0)\n+**\tmov\tp0\\.b, p3\\.b\n+** )\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_arr6_x0\\n} } } */\n+fixed_bool_t\n+test_pst_arr6_x0 (svbool_t p0, struct pst_arr6 x, svbool_t p1, svbool_t p2,\n+\t\t  svbool_t p3)\n+{\n+  CONSUME (x);\n+  return p3;\n+}\n+\n+/*\n+** test_pst_arr6_x7:\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_arr6_x7\\n} } } */\n+fixed_bool_t\n+test_pst_arr6_x7 (svbool_t p0, int x0, int x1, int x2, int x3, int x4,\n+\t\t  int x5, int x6, struct pst_arr6 x)\n+{\n+  CONSUME (x);\n+  return p0;\n+}\n+\n+/*\n+** test_pst_arr6_sp: { target lp64 }\n+**\tldr\tx7, \\[sp\\]\n+**\tret\n+*/\n+/*\n+** test_pst_arr6_sp: { target ilp32 }\n+**\tldr\tw7, \\[sp\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_arr6_sp\\n} } } */\n+fixed_bool_t\n+test_pst_arr6_sp (svbool_t p0, int x0, int x1, int x2, int x3, int x4,\n+\t\t  int x5, int x6, int x7, struct pst_arr6 x)\n+{\n+  CONSUME (x);\n+  return p0;\n+}\n+\n+struct pst_uniform1\n+{\n+  fixed_int8_t a, b;\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_uniform1\\n} } } */\n+SEL2 (struct, pst_uniform1)\n+\n+/*\n+** test_pst_uniform1:\n+**\tsub\tsp, sp, #32\n+**\tstr\tz0, \\[sp\\]\n+**\tstr\tz1, \\[sp, #1, mul vl\\]\n+**\tmov\t(x7, sp|w7, wsp)\n+**\tadd\tsp, sp, #?32\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_uniform1\\n} } } */\n+void\n+test_pst_uniform1 (struct pst_uniform1 x)\n+{\n+  CONSUME (x);\n+}\n+\n+struct pst_uniform2\n+{\n+  fixed_int16_t a;\n+  fixed_int16_t b[2];\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_uniform2\\n} } } */\n+SEL2 (struct, pst_uniform2)\n+\n+/*\n+** test_pst_uniform2:\n+**\tsub\tsp, sp, #48\n+**\tstr\tz0, \\[sp\\]\n+**\tstr\tz1, \\[sp, #1, mul vl\\]\n+**\tstr\tz2, \\[sp, #2, mul vl\\]\n+**\tmov\t(x7, sp|w7, wsp)\n+**\tadd\tsp, sp, #?48\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_uniform2\\n} } } */\n+void\n+test_pst_uniform2 (struct pst_uniform2 x)\n+{\n+  CONSUME (x);\n+}\n+\n+struct pst_uniform3\n+{\n+  fixed_int32_t a;\n+  fixed_int32_t b[2];\n+  fixed_int32_t c;\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_uniform3\\n} } } */\n+SEL2 (struct, pst_uniform3)\n+\n+/*\n+** test_pst_uniform3:\n+**\tsub\tsp, sp, #64\n+**\tstr\tz0, \\[sp\\]\n+**\tstr\tz1, \\[sp, #1, mul vl\\]\n+**\tstr\tz2, \\[sp, #2, mul vl\\]\n+**\tstr\tz3, \\[sp, #3, mul vl\\]\n+**\tmov\t(x7, sp|w7, wsp)\n+**\tadd\tsp, sp, #?64\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_uniform3\\n} } } */\n+void\n+test_pst_uniform3 (struct pst_uniform3 x)\n+{\n+  CONSUME (x);\n+}\n+\n+struct pst_uniform4\n+{\n+  fixed_int32_t a __attribute__((aligned(SVE_BYTES * 2)));\n+  fixed_int32_t b[3] __attribute__((aligned(SVE_BYTES * 2)));\n+  fixed_int32_t c __attribute__((aligned(SVE_BYTES * 2)));\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_uniform4\\n} } } */\n+SEL2 (struct, pst_uniform4)\n+\n+/*\n+** test_pst_uniform4:\n+**\tsub\tsp, sp, #144\n+**\tadd\t(x[0-9]+), sp, #?31\n+**\tand\tx7, \\1, #?(?:-32|4294967264)\n+**\tptrue\t(p[0-7])\\.b, vl16\n+**\tst1w\tz0\\.s, \\2, \\[x7\\]\n+**\tadd\t(x[0-9]+), x7, #?32\n+**\tstr\tz1, \\[\\3\\]\n+**\tstr\tz2, \\[\\3, #1, mul vl\\]\n+**\tstr\tz3, \\[\\3, #2, mul vl\\]\n+**\tst1w\tz4\\.s, \\2, \\[x7, #6, mul vl\\]\n+**\tadd\tsp, sp, #?144\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_uniform4\\n} } } */\n+void\n+test_pst_uniform4 (struct pst_uniform4 x)\n+{\n+  CONSUME (x);\n+}\n+\n+struct pst_mixed1\n+{\n+  fixed_bool_t p0;\n+  fixed_bfloat16_t z0;\n+  fixed_float16_t z1;\n+  fixed_float32_t z2;\n+  fixed_float64_t z3;\n+  fixed_bool_t p1;\n+  fixed_bool_t p2;\n+  fixed_int8_t z4;\n+  fixed_int16_t z5;\n+  fixed_int32_t z6;\n+  fixed_int64_t z7;\n+  fixed_bool_t p3;\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_mixed1\\n} } } */\n+SEL2 (struct, pst_mixed1)\n+\n+/*\n+** test_pst_mixed1:\n+**\tsub\tsp, sp, #176\n+**\tstr\tp0, \\[sp\\]\n+**\tptrue\tp0\\.b, vl16\n+**\tst1h\tz0\\.h, p0, \\[sp, #1, mul vl\\]\n+**\tst1h\tz1\\.h, p0, \\[sp, #2, mul vl\\]\n+**\tst1w\tz2\\.s, p0, \\[sp, #3, mul vl\\]\n+**\tst1d\tz3\\.d, p0, \\[sp, #4, mul vl\\]\n+**\tstr\tp1, \\[sp, #40, mul vl\\]\n+**\tstr\tp2, \\[sp, #41, mul vl\\]\n+**\tst1b\tz4\\.b, p0, \\[sp, #6, mul vl\\]\n+**\tst1h\tz5\\.h, p0, \\[sp, #7, mul vl\\]\n+**\t...\n+**\tst1w\tz6\\.s, p0, [^\\n]*\n+**\t...\n+**\tst1d\tz7\\.d, p0, [^\\n]*\n+**\t...\n+**\tstr\tp3, \\[sp, #80, mul vl\\]\n+**\tmov\t(x7, sp|w7, wsp)\n+**\tadd\tsp, sp, #?176\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_mixed1\\n} } } */\n+void\n+test_pst_mixed1 (struct pst_mixed1 x)\n+{\n+  CONSUME (x);\n+}\n+\n+struct pst_mixed2\n+{\n+  struct __attribute__ ((packed)) {\n+    fixed_bool_t p;\n+    fixed_int8_t z;\n+  } a[3];\n+  fixed_int16_t b[1][1][1][4];\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_mixed2\\n} } } */\n+SEL2 (struct, pst_mixed2)\n+\n+/*\n+** test_pst_mixed2:\n+**\tsub\tsp, sp, #128\n+**\tstr\tp0, \\[sp\\]\n+**\tptrue\t(p[03])\\.b, vl16\n+**\tadd\t(x[0-9]+), sp, #?2\n+**\tst1b\tz0\\.b, \\1, \\[\\2\\]\n+**\tstr\tp1, \\[sp, #9, mul vl\\]\n+**\tadd\t(x[0-9]+), sp, #?20\n+**\tst1b\tz1\\.b, \\1, \\[\\3\\]\n+**\tstr\tp2, \\[sp, #18, mul vl\\]\n+**\tadd\t(x[0-9]+), sp, #?38\n+**\tst1b\tz2\\.b, \\1, \\[\\4\\]\n+**\tstr\tz3, \\[sp, #4, mul vl\\]\n+**\tstr\tz4, \\[sp, #5, mul vl\\]\n+**\tstr\tz5, \\[sp, #6, mul vl\\]\n+**\tstr\tz6, \\[sp, #7, mul vl\\]\n+**\tmov\t(x7, sp|w7, wsp)\n+**\tadd\tsp, sp, #?128\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_mixed2\\n} } } */\n+void\n+test_pst_mixed2 (struct pst_mixed2 x)\n+{\n+  CONSUME (x);\n+}\n+\n+struct pst_big1\n+{\n+  fixed_int8_t a[9];\n+};\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tsel2_pst_big1\\n} } } */\n+SEL2 (struct, pst_big1)\n+\n+/*\n+** test_pst_big1_a: { target lp64 }\n+**\tptrue\t(p[0-7])\\.b, vl16\n+**\tld1b\tz0\\.b, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+/*\n+** test_pst_big1_a: { target ilp32 }\n+**\tuxtw\tx0, w0\n+**\tptrue\t(p[0-7])\\.b, vl16\n+**\tld1b\tz0\\.b, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_big1_a\\n} } } */\n+svint8_t\n+test_pst_big1_a (struct pst_big1 x)\n+{\n+  return x.a[0];\n+}\n+\n+/*\n+** test_pst_big1_b: { target lp64 }\n+**\tadd\tx7, x0, #?128\n+**\tret\n+*/\n+/*\n+** test_pst_big1_b: { target ilp32 }\n+**\tadd\tw7, w0, #?128\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_big1_b\\n} } } */\n+svint8_t\n+test_pst_big1_b (struct pst_big1 x)\n+{\n+  CONSUME (x.a[8]);\n+}\n+\n+struct pst_big2\n+{\n+  fixed_bool_t a[5];\n+};\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tsel2_pst_big2\\n} } } */\n+SEL2 (struct, pst_big2)\n+\n+/*\n+** test_pst_big2_a: { target lp64 }\n+**\tldr\tp0, \\[x0\\]\n+**\tret\n+*/\n+/*\n+** test_pst_big2_a: { target ilp32 }\n+**\tuxtw\tx0, w0\n+**\tldr\tp0, \\[x0\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_big2_a\\n} } } */\n+svbool_t\n+test_pst_big2_a (struct pst_big2 x)\n+{\n+  return x.a[0];\n+}\n+\n+/*\n+** test_pst_big2_b: { target lp64 }\n+**\tldr\tp0, \\[x0, #4, mul vl\\]\n+**\tret\n+*/\n+/*\n+** test_pst_big2_b: { target ilp32 }\n+**\tuxtw\tx0, w0\n+**\tldr\tp0, \\[x0, #4, mul vl\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_big2_b\\n} } } */\n+svbool_t\n+test_pst_big2_b (struct pst_big2 x)\n+{\n+  return x.a[4];\n+}\n+\n+struct pst_big3\n+{\n+  fixed_bool_t p0;\n+  fixed_int8_t a[2];\n+  fixed_bool_t p1;\n+  fixed_bool_t p2;\n+  fixed_bool_t p3;\n+  fixed_int8_t b[6];\n+  fixed_bool_t p4;\n+};\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tsel2_pst_big3\\n} } } */\n+SEL2 (struct, pst_big3)\n+\n+/*\n+** test_pst_big3_a: { target lp64 }\n+**\tldr\tp0, \\[x0\\]\n+**\tret\n+*/\n+/*\n+** test_pst_big3_a: { target ilp32 }\n+**\tuxtw\tx0, w0\n+**\tldr\tp0, \\[x0\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_big3_a\\n} } } */\n+svbool_t\n+test_pst_big3_a (struct pst_big3 x)\n+{\n+  return x.p0;\n+}\n+\n+/*\n+** test_pst_big3_b: { target lp64 }\n+**\tldr\tp0, \\[x0, #24, mul vl\\]\n+**\tret\n+*/\n+/*\n+** test_pst_big3_b: { target ilp32 }\n+**\tuxtw\tx0, w0\n+**\tldr\tp0, \\[x0, #24, mul vl\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_big3_b\\n} } } */\n+svbool_t\n+test_pst_big3_b (struct pst_big3 x)\n+{\n+  return x.p1;\n+}\n+\n+/*\n+** test_pst_big3_c: { target lp64 }\n+**\tldr\tp0, \\[x0, #25, mul vl\\]\n+**\tret\n+*/\n+/*\n+** test_pst_big3_c: { target ilp32 }\n+**\tuxtw\tx0, w0\n+**\tldr\tp0, \\[x0, #25, mul vl\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_big3_c\\n} } } */\n+svbool_t\n+test_pst_big3_c (struct pst_big3 x)\n+{\n+  return x.p2;\n+}\n+\n+/*\n+** test_pst_big3_d: { target lp64 }\n+**\tldr\tp0, \\[x0, #80, mul vl\\]\n+**\tret\n+*/\n+/*\n+** test_pst_big3_d: { target ilp32 }\n+**\tuxtw\tx0, w0\n+**\tldr\tp0, \\[x0, #80, mul vl\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_big3_d\\n} } } */\n+svbool_t\n+test_pst_big3_d (struct pst_big3 x)\n+{\n+  return x.p4;\n+}\n+\n+/*\n+** test_pst_big3_e: { target lp64 }\n+**\tptrue\t(p[0-7])\\.b, vl16\n+**\tld1b\tz0\\.b, \\1/z, \\[x0, #1, mul vl\\]\n+**\tret\n+*/\n+/*\n+** test_pst_big3_e: { target ilp32 }\n+**\tuxtw\tx0, w0\n+**\tptrue\t(p[0-7])\\.b, vl16\n+**\tld1b\tz0\\.b, \\1/z, \\[x0, #1, mul vl\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_big3_e\\n} } } */\n+svint8_t\n+test_pst_big3_e (struct pst_big3 x)\n+{\n+  return x.a[0];\n+}\n+\n+/*\n+** test_pst_big3_f: { target lp64 }\n+**\tptrue\t(p[0-7])\\.b, vl16\n+**\tld1b\tz0\\.b, \\1/z, \\[x0, #5, mul vl\\]\n+**\tret\n+*/\n+/*\n+** test_pst_big3_f: { target ilp32 }\n+**\tuxtw\tx0, w0\n+**\tptrue\t(p[0-7])\\.b, vl16\n+**\tld1b\tz0\\.b, \\1/z, \\[x0, #5, mul vl\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_big3_f\\n} } } */\n+svint8_t\n+test_pst_big3_f (struct pst_big3 x)\n+{\n+  return x.b[1];\n+}\n+\n+struct pst_zero1\n+{\n+  fixed_bool_t a[0];\n+  fixed_int32_t b;\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_zero1\\n} } } */\n+SEL2 (struct, pst_zero1)\n+\n+/*\n+** test_pst_zero1:\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_zero1\\n} } } */\n+svint32_t\n+test_pst_zero1 (struct pst_zero1 x)\n+{\n+  return x.b;\n+}\n+\n+struct pst_zero2\n+{\n+  unsigned int : 0;\n+  fixed_bool_t b;\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_zero2\\n} } } */\n+SEL2 (struct, pst_zero2)\n+\n+/*\n+** test_pst_zero2:\n+** (\n+**\tsub\tsp, sp, #16\n+**\tadd\tsp, sp, #?16\n+** |\n+** )\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_zero2\\n} } } */\n+svbool_t\n+test_pst_zero2 (struct pst_zero2 x)\n+{\n+  return x.b;\n+}\n+\n+struct pst_zero3\n+{\n+  struct {} empty;\n+  fixed_uint64_t b;\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_zero3\\n} } } */\n+SEL2 (struct, pst_zero3)\n+\n+/*\n+** test_pst_zero3:\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_zero3\\n} } } */\n+svuint64_t\n+test_pst_zero3 (struct pst_zero3 x)\n+{\n+  return x.b;\n+}\n+\n+typedef unsigned char small_vec __attribute__((vector_size(SVE_BYTES / 4)));\n+\n+struct nonpst1\n+{\n+  small_vec a[4];\n+};\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tsel2_pst_nonpst1\\n} } } */\n+SEL2 (struct, nonpst1)\n+\n+/*\n+** test_nonpst1:\n+**\t...\n+**\tlsr\tx0, x1, #?32\n+**\t...\n+**\tret\n+*/\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\ttest_nonpst1\\n} } } */\n+small_vec\n+test_nonpst1 (struct nonpst1 x)\n+{\n+  return x.a[3];\n+}\n+\n+union nonpst2\n+{\n+  struct {\n+    fixed_bool_t a[0];\n+    fixed_int32_t b;\n+  };\n+};\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tsel2_pst_nonpst2\\n} } } */\n+SEL2 (union, nonpst2)\n+\n+/*\n+** test_nonpst2:\n+**\tsub\tsp, sp, #16\n+**\tstp\tx0, x1, \\[sp\\]\n+**\t...\n+**\tldr\tz0, \\[sp\\]\n+**\tadd\tsp, sp, #?16\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_nonpst2\\n} } } */\n+svint32_t\n+test_nonpst2 (union nonpst2 x)\n+{\n+  return x.b;\n+}\n+\n+/*\n+** ret_nonpst2:\n+**\tmov\tx0, #?1\n+**\tmovk\tx0, #?0x3, lsl #?32\n+**\tmov\tx1, #?5\n+**\tmovk\tx1, #?0x7, lsl #?32\n+**\tret\n+*/\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tret_nonpst2\\n} } } */\n+union nonpst2\n+ret_nonpst2 (void)\n+{\n+  return (union nonpst2) { { {}, 1, 3, 5, 7 } };\n+}\n+\n+union nonpst3\n+{\n+  struct {\n+    unsigned int : 0;\n+    fixed_bool_t b;\n+  };\n+};\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tsel2_pst_nonpst3\\n} } } */\n+SEL2 (union, nonpst3)\n+\n+/*\n+** test_nonpst3:\n+**\tsub\tsp, sp, #16\n+**\tstrh\tw0, \\[sp, #?6\\]\n+**\tldr\tp0, \\[sp, #3, mul vl\\]\n+**\tadd\tsp, sp, #?16\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_nonpst3\\n} } } */\n+svbool_t\n+test_nonpst3 (union nonpst3 x)\n+{\n+  return x.b;\n+}\n+\n+/*\n+** ret_nonpst3: { xfail *-*-* }\n+**\tmov\tw0, #?(?:0xffff|65535)\n+**\tret\n+*/\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tret_nonpst3\\n} } } */\n+union nonpst3\n+ret_nonpst3 (void)\n+{\n+  return (union nonpst3) { { svptrue_b8 () } };\n+}\n+\n+union nonpst4\n+{\n+  struct {\n+    struct {} empty;\n+    fixed_uint64_t b;\n+  };\n+};\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tsel2_pst_nonpst4\\n} } } */\n+SEL2 (union, nonpst4)\n+\n+/*\n+** test_nonpst4:\n+**\tsub\tsp, sp, #16\n+**\tstp\tx0, x1, \\[sp\\]\n+**\t...\n+**\tldr\tz0, \\[sp\\]\n+**\tadd\tsp, sp, #?16\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_nonpst4\\n} } } */\n+svuint64_t\n+test_nonpst4 (union nonpst4 x)\n+{\n+  return x.b;\n+}\n+\n+/*\n+** ret_nonpst4:\n+**\tmov\tx0, 1\n+**\tmov\tx1, 2\n+**\tret\n+*/\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tret_nonpst4\\n} } } */\n+union nonpst4\n+ret_nonpst4 (void)\n+{\n+  return (union nonpst4) { { {}, 1, 2 } };\n+}\n+\n+struct nonpst5\n+{\n+  union {\n+    fixed_uint16_t b;\n+  };\n+};\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tsel2_pst_nonpst5\\n} } } */\n+SEL2 (struct, nonpst5)\n+\n+/*\n+** test_nonpst5:\n+**\tsub\tsp, sp, #16\n+**\tstp\tx0, x1, \\[sp\\]\n+**\t...\n+**\tldr\tz0, \\[sp\\]\n+**\tadd\tsp, sp, #?16\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_nonpst5\\n} } } */\n+svuint16_t\n+test_nonpst5 (struct nonpst5 x)\n+{\n+  return x.b;\n+}\n+\n+struct nonpst6\n+{\n+  fixed_uint64_t b;\n+  fixed_uint64_t *ptr;\n+};\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tsel2_pst_nonpst6\\n} } } */\n+SEL2 (struct, nonpst6)\n+\n+/*\n+** test_nonpst6: { target lp64 }\n+**\tptrue\t(p[0-3])\\.b, vl16\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+/*\n+** test_nonpst6: { target ilp32 }\n+**\tuxtw\tx0, w0\n+**\tptrue\t(p[0-3])\\.b, vl16\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_nonpst6\\n} } } */\n+svuint64_t\n+test_nonpst6 (struct nonpst6 x)\n+{\n+  return x.b;\n+}\n+\n+struct nonpst7\n+{\n+  fixed_uint64_t b;\n+  uint32_t foo __attribute__((vector_size(SVE_BYTES)));\n+};\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tsel2_pst_nonpst7\\n} } } */\n+SEL2 (struct, nonpst7)\n+\n+/*\n+** test_nonpst7: { target lp64 }\n+**\tptrue\t(p[0-3])\\.b, vl16\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+/*\n+** test_nonpst7: { target ilp32 }\n+**\tuxtw\tx0, w0\n+**\tptrue\t(p[0-3])\\.b, vl16\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_nonpst7\\n} } } */\n+svuint64_t\n+test_nonpst7 (struct nonpst7 x)\n+{\n+  return x.b;\n+}\n+\n+typedef unsigned char tiny_vec __attribute__((vector_size(SVE_BYTES / 8)));\n+\n+struct nonpst8\n+{\n+  tiny_vec a;\n+};\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tsel2_pst_nonpst8\\n} } } */\n+SEL2 (struct, nonpst8)\n+\n+/*\n+** test_nonpst8:\n+**\tubfx\tx0, x0, 8, 8\n+**\tret\n+*/\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\ttest_nonpst8\\n} } } */\n+unsigned int\n+test_nonpst8 (struct nonpst8 x)\n+{\n+  return x.a[1];\n+}\n+\n+/*\n+** ret_nonpst8:\n+** (\n+**\tsub\tsp, sp, #16\n+**\tmov\tw0, #?513\n+**\tadd\tsp, sp, #?16\n+** |\n+**\tmov\tw0, #?513\n+** )\n+**\tret\n+*/\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tret_nonpst8\\n} } } */\n+struct nonpst8\n+ret_nonpst8 (void)\n+{\n+  return (struct nonpst8) { { 1, 2 } };\n+}"}, {"sha": "fdfbec51bf86b8ea5ebccc97f8784c55a8443728", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/struct_3_256.c", "status": "added", "additions": 1231, "deletions": 0, "changes": 1231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct_3_256.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct_3_256.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct_3_256.c?ref=38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9", "patch": "@@ -0,0 +1,1231 @@\n+/* { dg-options \"-O -msve-vector-bits=256\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include \"struct.h\"\n+\n+#define CONSUME(VAR)\t\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    register void *ptr_ asm (\"x7\") = &(VAR);\t\\\n+    asm volatile (\"\" :: \"r\" (ptr_) : \"memory\");\t\\\n+  }\n+\n+#define SEL2(TAG, TYPE)\t\t\t\t\\\n+  TAG TYPE\t\t\t\t\t\\\n+  sel2_##TYPE (TAG TYPE x, TAG TYPE y)\t\t\\\n+  {\t\t\t\t\t\t\\\n+    return y;\t\t\t\t\t\\\n+  }\n+\n+#define WRAP(TYPE)\t\t\t\t\\\n+  struct wrap_##TYPE\t\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    TYPE data;\t\t\t\t\t\\\n+  };\t\t\t\t\t\t\\\n+  SEL2 (struct, wrap_##TYPE)\n+\n+/*\n+** sel2_wrap_fixed_int8_t:\n+**\tmov\tz0\\.d, z1\\.d\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_wrap_fixed_int8_t\\n} } } */\n+WRAP (fixed_int8_t);\n+\n+/*\n+** sel2_wrap_fixed_int16_t:\n+**\tmov\tz0\\.d, z1\\.d\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_wrap_fixed_int16_t\\n} } } */\n+WRAP (fixed_int16_t);\n+\n+/*\n+** sel2_wrap_fixed_int32_t:\n+**\tmov\tz0\\.d, z1\\.d\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_wrap_fixed_int32_t\\n} } } */\n+WRAP (fixed_int32_t);\n+\n+/*\n+** sel2_wrap_fixed_int64_t:\n+**\tmov\tz0\\.d, z1\\.d\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_wrap_fixed_int64_t\\n} } } */\n+WRAP (fixed_int64_t);\n+\n+/*\n+** sel2_wrap_fixed_uint8_t:\n+**\tmov\tz0\\.d, z1\\.d\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_wrap_fixed_uint8_t\\n} } } */\n+WRAP (fixed_uint8_t);\n+\n+/*\n+** sel2_wrap_fixed_uint16_t:\n+**\tmov\tz0\\.d, z1\\.d\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_wrap_fixed_uint16_t\\n} } } */\n+WRAP (fixed_uint16_t);\n+\n+/*\n+** sel2_wrap_fixed_uint32_t:\n+**\tmov\tz0\\.d, z1\\.d\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_wrap_fixed_uint32_t\\n} } } */\n+WRAP (fixed_uint32_t);\n+\n+/*\n+** sel2_wrap_fixed_uint64_t:\n+**\tmov\tz0\\.d, z1\\.d\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_wrap_fixed_uint64_t\\n} } } */\n+WRAP (fixed_uint64_t);\n+\n+/*\n+** sel2_wrap_fixed_bfloat16_t:\n+**\tmov\tz0\\.d, z1\\.d\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_wrap_fixed_bfloat16_t\\n} } } */\n+WRAP (fixed_bfloat16_t);\n+\n+/*\n+** sel2_wrap_fixed_float16_t:\n+**\tmov\tz0\\.d, z1\\.d\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_wrap_fixed_float16_t\\n} } } */\n+WRAP (fixed_float16_t);\n+\n+/*\n+** sel2_wrap_fixed_float32_t:\n+**\tmov\tz0\\.d, z1\\.d\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_wrap_fixed_float32_t\\n} } } */\n+WRAP (fixed_float32_t);\n+\n+/*\n+** sel2_wrap_fixed_float64_t:\n+**\tmov\tz0\\.d, z1\\.d\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_wrap_fixed_float64_t\\n} } } */\n+WRAP (fixed_float64_t);\n+\n+/*\n+** sel2_wrap_fixed_bool_t:\n+**\tmov\tp0\\.b, p1\\.b\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_wrap_fixed_bool_t\\n} } } */\n+WRAP (fixed_bool_t);\n+\n+struct pst_arr1\n+{\n+  fixed_uint8_t u8[1];\n+};\n+\n+/*\n+** sel2_pst_arr1:\n+**\tmov\tz0\\.d, z1\\.d\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_arr1\\n} } } */\n+SEL2 (struct, pst_arr1)\n+\n+/*\n+** test_pst_arr1:\n+**\teor\tz0\\.b, z0\\.b, #(?:0x)?1\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_arr1\\n} } } */\n+svuint8_t\n+test_pst_arr1 (struct pst_arr1 x)\n+{\n+  return sveor_x (svptrue_b8 (), x.u8[0], 1);\n+}\n+\n+struct pst_arr2\n+{\n+  fixed_uint8_t u8[2];\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_arr2\\n} } } */\n+SEL2 (struct, pst_arr2)\n+\n+/*\n+** test_pst_arr2:\n+**\tsub\tz0\\.b, z0\\.b, z1\\.b\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_arr2\\n} } } */\n+svuint8_t\n+test_pst_arr2 (struct pst_arr2 x)\n+{\n+  return svsub_x (svptrue_b8 (), x.u8[0], x.u8[1]);\n+}\n+\n+struct pst_arr3\n+{\n+  fixed_uint16_t u16[3];\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_arr3\\n} } } */\n+SEL2 (struct, pst_arr3)\n+\n+/*\n+** test_pst_arr3:\n+**\tsub\tz0\\.h, z0\\.h, z2\\.h\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_arr3\\n} } } */\n+svuint16_t\n+test_pst_arr3 (struct pst_arr3 x)\n+{\n+  return svsub_x (svptrue_b8 (), x.u16[0], x.u16[2]);\n+}\n+\n+struct pst_arr4\n+{\n+  fixed_uint32_t u32[4];\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_arr4\\n} } } */\n+SEL2 (struct, pst_arr4)\n+\n+/*\n+** test_pst_arr4:\n+**\tsub\tz0\\.s, z0\\.s, z3\\.s\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_arr4\\n} } } */\n+svuint32_t\n+test_pst_arr4 (struct pst_arr4 x)\n+{\n+  return svsub_x (svptrue_b8 (), x.u32[0], x.u32[3]);\n+}\n+\n+struct pst_arr5\n+{\n+  fixed_uint64_t u64[2][2][2];\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_arr5\\n} } } */\n+SEL2 (struct, pst_arr5)\n+\n+/*\n+** test_pst_arr5: { target aarch64_little_endian }\n+**\tsub\tsp, sp, #256\n+**\tstr\tz0, \\[sp\\]\n+**\tstr\tz1, \\[sp, #1, mul vl\\]\n+**\tstr\tz2, \\[sp, #2, mul vl\\]\n+**\tstr\tz3, \\[sp, #3, mul vl\\]\n+**\tstr\tz4, \\[sp, #4, mul vl\\]\n+**\tstr\tz5, \\[sp, #5, mul vl\\]\n+**\tstr\tz6, \\[sp, #6, mul vl\\]\n+**\tstr\tz7, \\[sp, #7, mul vl\\]\n+**\tmov\t(x7, sp|w7, wsp)\n+**\tadd\tsp, sp, #?256\n+**\tret\n+*/\n+/*\n+** test_pst_arr5: { target aarch64_big_endian }\n+**\tsub\tsp, sp, #256\n+**\tptrue\t(p[0-3])\\.b, vl32\n+**\tst1d\tz0\\.d, \\1, \\[sp\\]\n+**\tst1d\tz1\\.d, \\1, \\[sp, #1, mul vl\\]\n+**\tst1d\tz2\\.d, \\1, \\[sp, #2, mul vl\\]\n+**\tst1d\tz3\\.d, \\1, \\[sp, #3, mul vl\\]\n+**\tst1d\tz4\\.d, \\1, \\[sp, #4, mul vl\\]\n+**\tst1d\tz5\\.d, \\1, \\[sp, #5, mul vl\\]\n+**\tst1d\tz6\\.d, \\1, \\[sp, #6, mul vl\\]\n+**\tst1d\tz7\\.d, \\1, \\[sp, #7, mul vl\\]\n+**\tmov\t((x7, sp|w7, wsp)|w7, wsp)\n+**\tadd\tsp, sp, #?256\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_arr5\\n} } } */\n+void\n+test_pst_arr5 (struct pst_arr5 x)\n+{\n+  CONSUME (x);\n+}\n+\n+/*\n+** test_pst_arr5_x0:\n+** (\n+**\tmov\tz0\\.d, z7\\.d\n+**\tmov\t(x7, x0|w7, w0)\n+** |\n+**\tmov\t(x7, x0|w7, w0)\n+**\tmov\tz0\\.d, z7\\.d\n+** )\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_arr5_x0\\n} } } */\n+svint32_t\n+test_pst_arr5_x0 (svint32_t z0, struct pst_arr5 x,\n+\t\t  svint32_t z1, svint32_t z2, svint32_t z3, svint32_t z4,\n+\t\t  svint32_t z5, svint32_t z6, svint32_t z7)\n+{\n+  CONSUME (x);\n+  return z7;\n+}\n+\n+/*\n+** test_pst_arr5_x7:\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_arr5_x7\\n} } } */\n+svint32_t\n+test_pst_arr5_x7 (svint32_t z0, int x0, int x1, int x2, int x3, int x4,\n+\t\t  int x5, int x6, struct pst_arr5 x)\n+{\n+  CONSUME (x);\n+  return z0;\n+}\n+\n+/*\n+** test_pst_arr5_sp: { target lp64 }\n+**\tldr\tx7, \\[sp\\]\n+**\tret\n+*/\n+/*\n+** test_pst_arr5_sp: { target ilp32 }\n+**\tldr\tw7, \\[sp(, 4)?\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_arr5_sp\\n} } } */\n+svint32_t\n+test_pst_arr5_sp (svint32_t z0, int x0, int x1, int x2, int x3, int x4,\n+\t\t  int x5, int x6, int x7, struct pst_arr5 x)\n+{\n+  CONSUME (x);\n+  return z0;\n+}\n+\n+struct pst_arr6\n+{\n+  fixed_bool_t b[2][2];\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_arr6\\n} } } */\n+SEL2 (struct, pst_arr6)\n+\n+/*\n+** test_pst_arr6:\n+**\t...\n+**\tbrkpa\tp0\\.b, p0/z, p2\\.b, p3\\.b\n+**\t...\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_arr6\\n} } } */\n+fixed_bool_t\n+test_pst_arr6 (struct pst_arr6 x)\n+{\n+  return svbrkpa_z (x.b[0][0], x.b[1][0], x.b[1][1]);\n+}\n+\n+/*\n+** test_pst_arr6_x0:\n+** (\n+**\tmov\tp0\\.b, p3\\.b\n+**\tmov\t(x7, x0|w7, w0)\n+** |\n+**\tmov\t(x7, x0|w7, w0)\n+**\tmov\tp0\\.b, p3\\.b\n+** )\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_arr6_x0\\n} } } */\n+fixed_bool_t\n+test_pst_arr6_x0 (svbool_t p0, struct pst_arr6 x, svbool_t p1, svbool_t p2,\n+\t\t  svbool_t p3)\n+{\n+  CONSUME (x);\n+  return p3;\n+}\n+\n+/*\n+** test_pst_arr6_x7:\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_arr6_x7\\n} } } */\n+fixed_bool_t\n+test_pst_arr6_x7 (svbool_t p0, int x0, int x1, int x2, int x3, int x4,\n+\t\t  int x5, int x6, struct pst_arr6 x)\n+{\n+  CONSUME (x);\n+  return p0;\n+}\n+\n+/*\n+** test_pst_arr6_sp: { target lp64 }\n+**\tldr\tx7, \\[sp\\]\n+**\tret\n+*/\n+/*\n+** test_pst_arr6_sp: { target ilp32 }\n+**\tldr\tw7, \\[sp(, 4)?\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_arr6_sp\\n} } } */\n+fixed_bool_t\n+test_pst_arr6_sp (svbool_t p0, int x0, int x1, int x2, int x3, int x4,\n+\t\t  int x5, int x6, int x7, struct pst_arr6 x)\n+{\n+  CONSUME (x);\n+  return p0;\n+}\n+\n+struct pst_uniform1\n+{\n+  fixed_int8_t a, b;\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_uniform1\\n} } } */\n+SEL2 (struct, pst_uniform1)\n+\n+/*\n+** test_pst_uniform1: { target aarch64_little_endian }\n+**\tsub\tsp, sp, #64\n+**\tstr\tz0, \\[sp\\]\n+**\tstr\tz1, \\[sp, #1, mul vl\\]\n+**\tmov\t(x7, sp|w7, wsp)\n+**\tadd\tsp, sp, #?64\n+**\tret\n+*/\n+/*\n+** test_pst_uniform1: { target aarch64_big_endian }\n+**\tsub\tsp, sp, #64\n+**\tptrue\t(p[0-3])\\.b, vl32\n+**\tst1b\tz0\\.b, \\1, \\[sp\\]\n+**\tst1b\tz1\\.b, \\1, \\[sp, #1, mul vl\\]\n+**\tmov\t(x7, sp|w7, wsp)\n+**\tadd\tsp, sp, #?64\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_uniform1\\n} } } */\n+void\n+test_pst_uniform1 (struct pst_uniform1 x)\n+{\n+  CONSUME (x);\n+}\n+\n+struct pst_uniform2\n+{\n+  fixed_int16_t a;\n+  fixed_int16_t b[2];\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_uniform2\\n} } } */\n+SEL2 (struct, pst_uniform2)\n+\n+/*\n+** test_pst_uniform2: { target aarch64_little_endian }\n+**\tsub\tsp, sp, #96\n+**\tstr\tz0, \\[sp\\]\n+**\tstr\tz1, \\[sp, #1, mul vl\\]\n+**\tstr\tz2, \\[sp, #2, mul vl\\]\n+**\tmov\t(x7, sp|w7, wsp)\n+**\tadd\tsp, sp, #?96\n+**\tret\n+*/\n+/*\n+** test_pst_uniform2: { target aarch64_big_endian }\n+**\tsub\tsp, sp, #96\n+**\tptrue\t(p[0-3])\\.b, vl32\n+**\tst1h\tz0\\.h, \\1, \\[sp\\]\n+**\tst1h\tz1\\.h, \\1, \\[sp, #1, mul vl\\]\n+**\tst1h\tz2\\.h, \\1, \\[sp, #2, mul vl\\]\n+**\tmov\t(x7, sp|w7, wsp)\n+**\tadd\tsp, sp, #?96\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_uniform2\\n} } } */\n+void\n+test_pst_uniform2 (struct pst_uniform2 x)\n+{\n+  CONSUME (x);\n+}\n+\n+struct pst_uniform3\n+{\n+  fixed_int32_t a;\n+  fixed_int32_t b[2];\n+  fixed_int32_t c;\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_uniform3\\n} } } */\n+SEL2 (struct, pst_uniform3)\n+\n+/*\n+** test_pst_uniform3: { target aarch64_little_endian }\n+**\tsub\tsp, sp, #128\n+**\tstr\tz0, \\[sp\\]\n+**\tstr\tz1, \\[sp, #1, mul vl\\]\n+**\tstr\tz2, \\[sp, #2, mul vl\\]\n+**\tstr\tz3, \\[sp, #3, mul vl\\]\n+**\tmov\t(x7, sp|w7, wsp)\n+**\tadd\tsp, sp, #?128\n+**\tret\n+*/\n+/*\n+** test_pst_uniform3: { target aarch64_big_endian }\n+**\tsub\tsp, sp, #128\n+**\tptrue\t(p[0-3])\\.b, vl32\n+**\tst1w\tz0\\.s, \\1, \\[sp\\]\n+**\tst1w\tz1\\.s, \\1, \\[sp, #1, mul vl\\]\n+**\tst1w\tz2\\.s, \\1, \\[sp, #2, mul vl\\]\n+**\tst1w\tz3\\.s, \\1, \\[sp, #3, mul vl\\]\n+**\tmov\t(x7, sp|w7, wsp)\n+**\tadd\tsp, sp, #?128\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_uniform3\\n} } } */\n+void\n+test_pst_uniform3 (struct pst_uniform3 x)\n+{\n+  CONSUME (x);\n+}\n+\n+struct pst_uniform4\n+{\n+  fixed_int32_t a __attribute__((aligned(SVE_BYTES * 2)));\n+  fixed_int32_t b[3] __attribute__((aligned(SVE_BYTES * 2)));\n+  fixed_int32_t c __attribute__((aligned(SVE_BYTES * 2)));\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_uniform4\\n} } } */\n+SEL2 (struct, pst_uniform4)\n+\n+/*\n+** test_pst_uniform4: { target aarch64_little_endian }\n+**\tsub\tsp, sp, #304\n+**\tadd\t(x[0-9]+), sp, #?63\n+**\tand\tx7, \\1, #?(?:-64|4294967232)\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tst1w\tz0\\.s, \\2, \\[x7\\]\n+**\tadd\t(x[0-9]+), x7, #?64\n+**\tstr\tz1, \\[\\3\\]\n+**\tstr\tz2, \\[\\3, #1, mul vl\\]\n+**\tstr\tz3, \\[\\3, #2, mul vl\\]\n+**\tst1w\tz4\\.s, \\2, \\[x7, #6, mul vl\\]\n+**\tadd\tsp, sp, #?304\n+**\tret\n+*/\n+/*\n+** test_pst_uniform4: { target aarch64_big_endian }\n+**\tsub\tsp, sp, #304\n+**\tadd\t(x[0-9]+), sp, #?63\n+**\tand\tx7, \\1, #?(?:-64|4294967232)\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tst1w\tz0\\.s, \\2, \\[x7\\]\n+**\tadd\t(x[0-9]+), x7, #?64\n+**\tst1w\tz1\\.s, \\2, \\[\\3\\]\n+**\tst1w\tz2\\.s, \\2, \\[\\3, #1, mul vl\\]\n+**\tst1w\tz3\\.s, \\2, \\[\\3, #2, mul vl\\]\n+**\tst1w\tz4\\.s, \\2, \\[x7, #6, mul vl\\]\n+**\tadd\tsp, sp, #?304\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_uniform4\\n} } } */\n+void\n+test_pst_uniform4 (struct pst_uniform4 x)\n+{\n+  CONSUME (x);\n+}\n+\n+struct pst_mixed1\n+{\n+  fixed_bool_t p0;\n+  fixed_bfloat16_t z0;\n+  fixed_float16_t z1;\n+  fixed_float32_t z2;\n+  fixed_float64_t z3;\n+  fixed_bool_t p1;\n+  fixed_bool_t p2;\n+  fixed_int8_t z4;\n+  fixed_int16_t z5;\n+  fixed_int32_t z6;\n+  fixed_int64_t z7;\n+  fixed_bool_t p3;\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_mixed1\\n} } } */\n+SEL2 (struct, pst_mixed1)\n+\n+/*\n+** test_pst_mixed1:\n+**\tsub\tsp, sp, #304\n+**\tstr\tp0, \\[sp\\]\n+**\tptrue\tp0\\.b, vl32\n+**\tadd\t(x[0-9+]), sp, #?16\n+**\tst1h\tz0\\.h, p0, \\[\\1\\]\n+**\tadd\t(x[0-9+]), sp, #?48\n+**\tst1h\tz1\\.h, p0, \\[\\2\\]\n+**\tadd\t(x[0-9+]), sp, #?80\n+**\tst1w\tz2\\.s, p0, \\[\\3\\]\n+**\tadd\t(x[0-9+]), sp, #?112\n+**\tst1d\tz3\\.d, p0, \\[\\4\\]\n+**\tstr\tp1, \\[sp, #36, mul vl\\]\n+**\tstr\tp2, \\[sp, #37, mul vl\\]\n+**\tst1b\tz4\\.b, p0, \\[sp, #5, mul vl\\]\n+**\tst1h\tz5\\.h, p0, \\[sp, #6, mul vl\\]\n+**\tst1w\tz6\\.s, p0, \\[sp, #7, mul vl\\]\n+**\t...\n+**\tst1d\tz7\\.d, p0, [^\\n]*\n+**\t...\n+**\tstr\tp3, \\[sp, #72, mul vl\\]\n+**\tmov\t(x7, sp|w7, wsp)\n+**\tadd\tsp, sp, #?304\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_mixed1\\n} } } */\n+void\n+test_pst_mixed1 (struct pst_mixed1 x)\n+{\n+  CONSUME (x);\n+}\n+\n+struct pst_mixed2\n+{\n+  struct __attribute__ ((packed)) {\n+    fixed_bool_t p;\n+    fixed_int8_t z;\n+  } a[3];\n+  fixed_int16_t b[1][1][1][4];\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_mixed2\\n} } } */\n+SEL2 (struct, pst_mixed2)\n+\n+/*\n+** test_pst_mixed2: { target aarch64_little_endian }\n+**\tsub\tsp, sp, #240\n+**\tstr\tp0, \\[sp\\]\n+**\tptrue\t(p[03])\\.b, vl32\n+**\tadd\t(x[0-9]+), sp, #?4\n+**\tst1b\tz0\\.b, \\1, \\[\\2\\]\n+**\tstr\tp1, \\[sp, #9, mul vl\\]\n+**\tadd\t(x[0-9]+), sp, #?40\n+**\tst1b\tz1\\.b, \\1, \\[\\3\\]\n+**\tstr\tp2, \\[sp, #18, mul vl\\]\n+**\tadd\t(x[0-9]+), sp, #?76\n+**\tst1b\tz2\\.b, \\1, \\[\\4\\]\n+**\tadd\t(x[0-9]+), sp, #?112\n+**\tstr\tz3, \\[\\5\\]\n+**\tstr\tz4, \\[\\5, #1, mul vl\\]\n+**\tstr\tz5, \\[\\5, #2, mul vl\\]\n+**\tstr\tz6, \\[\\5, #3, mul vl\\]\n+**\tmov\t(x7, sp|w7, wsp)\n+**\tadd\tsp, sp, #?240\n+**\tret\n+*/\n+/*\n+** test_pst_mixed2: { target aarch64_big_endian }\n+**\tsub\tsp, sp, #240\n+**\tstr\tp0, \\[sp\\]\n+**\tptrue\t(p[03])\\.b, vl32\n+**\tadd\t(x[0-9]+), sp, #?4\n+**\tst1b\tz0\\.b, \\1, \\[\\2\\]\n+**\tstr\tp1, \\[sp, #9, mul vl\\]\n+**\tadd\t(x[0-9]+), sp, #?40\n+**\tst1b\tz1\\.b, \\1, \\[\\3\\]\n+**\tstr\tp2, \\[sp, #18, mul vl\\]\n+**\tadd\t(x[0-9]+), sp, #?76\n+**\tst1b\tz2\\.b, \\1, \\[\\4\\]\n+**\tadd\t(x[0-9]+), sp, #?112\n+**\tst1h\tz3\\.h, \\1, \\[\\5\\]\n+**\tst1h\tz4\\.h, \\1, \\[\\5, #1, mul vl\\]\n+**\tst1h\tz5\\.h, \\1, \\[\\5, #2, mul vl\\]\n+**\tst1h\tz6\\.h, \\1, \\[\\5, #3, mul vl\\]\n+**\tmov\t(x7, sp|w7, wsp)\n+**\tadd\tsp, sp, #?240\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_mixed2\\n} } } */\n+void\n+test_pst_mixed2 (struct pst_mixed2 x)\n+{\n+  CONSUME (x);\n+}\n+\n+struct pst_big1\n+{\n+  fixed_int8_t a[9];\n+};\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tsel2_pst_big1\\n} } } */\n+SEL2 (struct, pst_big1)\n+\n+/*\n+** test_pst_big1_a: { target lp64 }\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1b\tz0\\.b, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+/*\n+** test_pst_big1_a: { target ilp32 }\n+**\tuxtw\tx0, w0\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1b\tz0\\.b, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_big1_a\\n} } } */\n+svint8_t\n+test_pst_big1_a (struct pst_big1 x)\n+{\n+  return x.a[0];\n+}\n+\n+/*\n+** test_pst_big1_b: { target lp64 }\n+**\tadd\tx7, x0, #?256\n+**\tret\n+*/\n+/*\n+** test_pst_big1_b: { target ilp32 }\n+**\tadd\tw7, w0, #?256\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_big1_b\\n} } } */\n+svint8_t\n+test_pst_big1_b (struct pst_big1 x)\n+{\n+  CONSUME (x.a[8]);\n+}\n+\n+struct pst_big2\n+{\n+  fixed_bool_t a[5];\n+};\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tsel2_pst_big2\\n} } } */\n+SEL2 (struct, pst_big2)\n+\n+/*\n+** test_pst_big2_a: { target lp64 }\n+**\tldr\tp0, \\[x0\\]\n+**\tret\n+*/\n+/*\n+** test_pst_big2_a: { target ilp32 }\n+**\tuxtw\tx0, w0\n+**\tldr\tp0, \\[x0\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_big2_a\\n} } } */\n+svbool_t\n+test_pst_big2_a (struct pst_big2 x)\n+{\n+  return x.a[0];\n+}\n+\n+/*\n+** test_pst_big2_b: { target lp64 }\n+**\tldr\tp0, \\[x0, #4, mul vl\\]\n+**\tret\n+*/\n+/*\n+** test_pst_big2_b: { target ilp32 }\n+**\tuxtw\tx0, w0\n+**\tldr\tp0, \\[x0, #4, mul vl\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_big2_b\\n} } } */\n+svbool_t\n+test_pst_big2_b (struct pst_big2 x)\n+{\n+  return x.a[4];\n+}\n+\n+struct pst_big3\n+{\n+  fixed_bool_t p0;\n+  fixed_int8_t a[2];\n+  fixed_bool_t p1;\n+  fixed_bool_t p2;\n+  fixed_bool_t p3;\n+  fixed_int8_t b[6];\n+  fixed_bool_t p4;\n+};\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tsel2_pst_big3\\n} } } */\n+SEL2 (struct, pst_big3)\n+\n+/*\n+** test_pst_big3_a: { target lp64 }\n+**\tldr\tp0, \\[x0\\]\n+**\tret\n+*/\n+/*\n+** test_pst_big3_a: { target ilp32 }\n+**\tuxtw\tx0, w0\n+**\tldr\tp0, \\[x0\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_big3_a\\n} } } */\n+svbool_t\n+test_pst_big3_a (struct pst_big3 x)\n+{\n+  return x.p0;\n+}\n+\n+/*\n+** test_pst_big3_b: { target lp64 }\n+**\tldr\tp0, \\[x0, #20, mul vl\\]\n+**\tret\n+*/\n+/*\n+** test_pst_big3_b: { target ilp32 }\n+**\tuxtw\tx0, w0\n+**\tldr\tp0, \\[x0, #20, mul vl\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_big3_b\\n} } } */\n+svbool_t\n+test_pst_big3_b (struct pst_big3 x)\n+{\n+  return x.p1;\n+}\n+\n+/*\n+** test_pst_big3_c: { target lp64 }\n+**\tldr\tp0, \\[x0, #21, mul vl\\]\n+**\tret\n+*/\n+/*\n+** test_pst_big3_c: { target ilp32 }\n+**\tuxtw\tx0, w0\n+**\tldr\tp0, \\[x0, #21, mul vl\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_big3_c\\n} } } */\n+svbool_t\n+test_pst_big3_c (struct pst_big3 x)\n+{\n+  return x.p2;\n+}\n+\n+/*\n+** test_pst_big3_d: { target lp64 }\n+**\tldr\tp0, \\[x0, #72, mul vl\\]\n+**\tret\n+*/\n+/*\n+** test_pst_big3_d: { target ilp32 }\n+**\tuxtw\tx0, w0\n+**\tldr\tp0, \\[x0, #72, mul vl\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_big3_d\\n} } } */\n+svbool_t\n+test_pst_big3_d (struct pst_big3 x)\n+{\n+  return x.p4;\n+}\n+\n+/*\n+** test_pst_big3_e: { target lp64 }\n+**\tadd\t(x[0-9]+), x0, #?16\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1b\tz0\\.b, \\2/z, \\[\\1\\]\n+**\tret\n+*/\n+/*\n+** test_pst_big3_e: { target ilp32 }\n+**\tuxtw\tx0, w0\n+**\tadd\t(x[0-9]+), x0, #?16\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1b\tz0\\.b, \\2/z, \\[\\1\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_big3_e\\n} } } */\n+svint8_t\n+test_pst_big3_e (struct pst_big3 x)\n+{\n+  return x.a[0];\n+}\n+\n+/*\n+** test_pst_big3_f: { target lp64 }\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1b\tz0\\.b, \\1/z, \\[x0, #4, mul vl\\]\n+**\tret\n+*/\n+/*\n+** test_pst_big3_f: { target ilp32 }\n+**\tuxtw\tx0, w0\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1b\tz0\\.b, \\1/z, \\[x0, #4, mul vl\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_big3_f\\n} } } */\n+svint8_t\n+test_pst_big3_f (struct pst_big3 x)\n+{\n+  return x.b[1];\n+}\n+\n+struct pst_zero1\n+{\n+  fixed_bool_t a[0];\n+  fixed_int32_t b;\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_zero1\\n} } } */\n+SEL2 (struct, pst_zero1)\n+\n+/*\n+** test_pst_zero1:\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_zero1\\n} } } */\n+svint32_t\n+test_pst_zero1 (struct pst_zero1 x)\n+{\n+  return x.b;\n+}\n+\n+struct pst_zero2\n+{\n+  unsigned int : 0;\n+  fixed_bool_t b;\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_zero2\\n} } } */\n+SEL2 (struct, pst_zero2)\n+\n+/*\n+** test_pst_zero2:\n+** (\n+**\tsub\tsp, sp, #16\n+**\tadd\tsp, sp, #?16\n+** |\n+** )\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_zero2\\n} } } */\n+svbool_t\n+test_pst_zero2 (struct pst_zero2 x)\n+{\n+  return x.b;\n+}\n+\n+struct pst_zero3\n+{\n+  struct {} empty;\n+  fixed_uint64_t b;\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_zero3\\n} } } */\n+SEL2 (struct, pst_zero3)\n+\n+/*\n+** test_pst_zero3:\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_zero3\\n} } } */\n+svuint64_t\n+test_pst_zero3 (struct pst_zero3 x)\n+{\n+  return x.b;\n+}\n+\n+typedef unsigned char small_vec __attribute__((vector_size(SVE_BYTES / 4)));\n+\n+struct nonpst1\n+{\n+  small_vec a[4];\n+};\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tsel2_pst_nonpst1\\n} } } */\n+SEL2 (struct, nonpst1)\n+\n+/*\n+** test_nonpst1:\n+**\tmov\tv0\\.8b, v3\\.8b\n+**\tret\n+*/\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\ttest_nonpst1\\n} } } */\n+small_vec\n+test_nonpst1 (struct nonpst1 x)\n+{\n+  return x.a[3];\n+}\n+\n+union nonpst2\n+{\n+  struct {\n+    fixed_bool_t a[0];\n+    fixed_int32_t b;\n+  };\n+};\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tsel2_pst_nonpst2\\n} } } */\n+SEL2 (union, nonpst2)\n+\n+/*\n+** test_nonpst2: { target lp64 }\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+/*\n+** test_nonpst2: { target ilp32 }\n+**\tuxtw\tx0, w0\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_nonpst2\\n} } } */\n+svint32_t\n+test_nonpst2 (union nonpst2 x)\n+{\n+  return x.b;\n+}\n+\n+/*\n+** ret_nonpst2:\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tindex\t(z[0-9]+\\.s), #1, #2\n+**\tst1w\t\\2, \\1, \\[x8\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tret_nonpst2\\n} } } */\n+union nonpst2\n+ret_nonpst2 (void)\n+{\n+  return (union nonpst2) { { {}, 1, 3, 5, 7, 9, 11, 13, 15 } };\n+}\n+\n+union nonpst3\n+{\n+  struct {\n+    unsigned int : 0;\n+    fixed_bool_t b;\n+  };\n+};\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tsel2_pst_nonpst3\\n} } } */\n+SEL2 (union, nonpst3)\n+\n+/*\n+** test_nonpst3: { target aarch64_little_endian }\n+**\tsub\tsp, sp, #16\n+**\tstr\tw0, \\[sp, #?12\\]\n+**\tldr\tp0, \\[sp, #3, mul vl\\]\n+**\tadd\tsp, sp, #?16\n+**\tret\n+*/\n+/*\n+** test_nonpst3: { target aarch64_big_endian }\n+**\tsub\tsp, sp, #16\n+** (\n+**\tlsr\t(x[0-9]+), x0, #?32\n+**\tstr\t\\1, \\[sp\\]\n+**\tldr\tp0, \\[sp, #1, mul vl\\]\n+** |\n+**\tstr\tx0, \\[sp\\]\n+**\tldr\tp0, \\[sp\\]\n+** )\n+**\tadd\tsp, sp, #?16\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_nonpst3\\n} } } */\n+svbool_t\n+test_nonpst3 (union nonpst3 x)\n+{\n+  return x.b;\n+}\n+\n+/*\n+** ret_nonpst3: { target aarch64_little_endian }\n+**\tmov\tw0, -1\n+**\tret\n+*/\n+/*\n+** ret_nonpst3: { target aarch64_big_endian }\n+**\tmov\tx0, -4294967296\n+**\tret\n+*/\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tret_nonpst3\\n} } } */\n+union nonpst3\n+ret_nonpst3 (void)\n+{\n+  return (union nonpst3) { { svptrue_b8 () } };\n+}\n+\n+union nonpst4\n+{\n+  struct {\n+    struct {} empty;\n+    fixed_uint64_t b;\n+  };\n+};\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tsel2_pst_nonpst4\\n} } } */\n+SEL2 (union, nonpst4)\n+\n+/*\n+** test_nonpst4: { target lp64 }\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+/*\n+** test_nonpst4: { target ilp32 }\n+**\tuxtw\tx0, w0\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_nonpst4\\n} } } */\n+svuint64_t\n+test_nonpst4 (union nonpst4 x)\n+{\n+  return x.b;\n+}\n+\n+/*\n+** ret_nonpst4:\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tindex\t(z[0-9]+\\.d), #1, #1\n+**\tst1d\t\\2, \\1, \\[x8\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tret_nonpst4\\n} } } */\n+union nonpst4\n+ret_nonpst4 (void)\n+{\n+  return (union nonpst4) { { {}, 1, 2, 3, 4 } };\n+}\n+\n+struct nonpst5\n+{\n+  union {\n+    fixed_uint16_t b;\n+  };\n+};\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tsel2_pst_nonpst5\\n} } } */\n+SEL2 (struct, nonpst5)\n+\n+/*\n+** test_nonpst5: { target lp64 }\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+/*\n+** test_nonpst5: { target ilp32 }\n+**\tuxtw\tx0, w0\n+**\tptrue\t(p[0-7])\\.b, vl32\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_nonpst5\\n} } } */\n+svuint16_t\n+test_nonpst5 (struct nonpst5 x)\n+{\n+  return x.b;\n+}\n+\n+struct nonpst6\n+{\n+  fixed_uint64_t b;\n+  fixed_uint64_t *ptr;\n+};\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tsel2_pst_nonpst6\\n} } } */\n+SEL2 (struct, nonpst6)\n+\n+/*\n+** test_nonpst6: { target lp64 }\n+**\tptrue\t(p[0-3])\\.b, vl32\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+/*\n+** test_nonpst6: { target ilp32 }\n+**\tuxtw\tx0, w0\n+**\tptrue\t(p[0-3])\\.b, vl32\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_nonpst6\\n} } } */\n+svuint64_t\n+test_nonpst6 (struct nonpst6 x)\n+{\n+  return x.b;\n+}\n+\n+struct nonpst7\n+{\n+  fixed_uint64_t b;\n+  uint32_t foo __attribute__((vector_size(SVE_BYTES)));\n+};\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tsel2_pst_nonpst7\\n} } } */\n+SEL2 (struct, nonpst7)\n+\n+/*\n+** test_nonpst7: { target lp64 }\n+**\tptrue\t(p[0-3])\\.b, vl32\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+/*\n+** test_nonpst7: { target ilp32 }\n+**\tuxtw\tx0, w0\n+**\tptrue\t(p[0-3])\\.b, vl32\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_nonpst7\\n} } } */\n+svuint64_t\n+test_nonpst7 (struct nonpst7 x)\n+{\n+  return x.b;\n+}\n+\n+typedef unsigned char tiny_vec __attribute__((vector_size(SVE_BYTES / 8)));\n+\n+struct nonpst8\n+{\n+  tiny_vec a;\n+};\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tsel2_pst_nonpst8\\n} } } */\n+SEL2 (struct, nonpst8)\n+\n+/*\n+** test_nonpst8: { target aarch64_little_endian }\n+**\tubfx\tx0, x0, 8, 8\n+**\tret\n+*/\n+/*\n+** test_nonpst8: { target aarch64_big_endian }\n+** (\n+**\tsub\tsp, sp, #16\n+**\tubfx\tx0, x0, 48, 8\n+**\tadd\tsp, sp, #?16\n+** |\n+**\tubfx\tx0, x0, 48, 8\n+** )\n+**\tret\n+*/\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\ttest_nonpst8\\n} } } */\n+unsigned int\n+test_nonpst8 (struct nonpst8 x)\n+{\n+  return x.a[1];\n+}\n+\n+/*\n+** ret_nonpst8: { target aarch64_little_endian }\n+** (\n+**\tsub\tsp, sp, #16\n+**\tmov\tw0, #?513\n+**\tmovk\tw0, #?0x403, lsl #?16\n+**\tadd\tsp, sp, #?16\n+** |\n+**\tmov\tw0, #?513\n+**\tmovk\tw0, #?0x403, lsl #?16\n+** )\n+**\tret\n+*/\n+/*\n+** ret_nonpst8: { target aarch64_big_endian }\n+**\tmov\tx0, #?3315714752512\n+**\tmovk\tx0, #?0x102, lsl #?48\n+**\tret\n+*/\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tret_nonpst8\\n} } } */\n+struct nonpst8\n+ret_nonpst8 (void)\n+{\n+  return (struct nonpst8) { { 1, 2, 3, 4 } };\n+}"}, {"sha": "e03fd73f80c7c8a13db710bd4809e132f3e1ad20", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/struct_3_512.c", "status": "added", "additions": 1197, "deletions": 0, "changes": 1197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct_3_512.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct_3_512.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fstruct_3_512.c?ref=38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9", "patch": "@@ -0,0 +1,1197 @@\n+/* { dg-options \"-O -msve-vector-bits=512\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include \"struct.h\"\n+\n+#define CONSUME(VAR)\t\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    register void *ptr_ asm (\"x7\") = &(VAR);\t\\\n+    asm volatile (\"\" :: \"r\" (ptr_) : \"memory\");\t\\\n+  }\n+\n+#define SEL2(TAG, TYPE)\t\t\t\t\\\n+  TAG TYPE\t\t\t\t\t\\\n+  sel2_##TYPE (TAG TYPE x, TAG TYPE y)\t\t\\\n+  {\t\t\t\t\t\t\\\n+    return y;\t\t\t\t\t\\\n+  }\n+\n+#define WRAP(TYPE)\t\t\t\t\\\n+  struct wrap_##TYPE\t\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    TYPE data;\t\t\t\t\t\\\n+  };\t\t\t\t\t\t\\\n+  SEL2 (struct, wrap_##TYPE)\n+\n+/*\n+** sel2_wrap_fixed_int8_t:\n+**\tmov\tz0\\.d, z1\\.d\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_wrap_fixed_int8_t\\n} } } */\n+WRAP (fixed_int8_t);\n+\n+/*\n+** sel2_wrap_fixed_int16_t:\n+**\tmov\tz0\\.d, z1\\.d\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_wrap_fixed_int16_t\\n} } } */\n+WRAP (fixed_int16_t);\n+\n+/*\n+** sel2_wrap_fixed_int32_t:\n+**\tmov\tz0\\.d, z1\\.d\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_wrap_fixed_int32_t\\n} } } */\n+WRAP (fixed_int32_t);\n+\n+/*\n+** sel2_wrap_fixed_int64_t:\n+**\tmov\tz0\\.d, z1\\.d\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_wrap_fixed_int64_t\\n} } } */\n+WRAP (fixed_int64_t);\n+\n+/*\n+** sel2_wrap_fixed_uint8_t:\n+**\tmov\tz0\\.d, z1\\.d\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_wrap_fixed_uint8_t\\n} } } */\n+WRAP (fixed_uint8_t);\n+\n+/*\n+** sel2_wrap_fixed_uint16_t:\n+**\tmov\tz0\\.d, z1\\.d\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_wrap_fixed_uint16_t\\n} } } */\n+WRAP (fixed_uint16_t);\n+\n+/*\n+** sel2_wrap_fixed_uint32_t:\n+**\tmov\tz0\\.d, z1\\.d\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_wrap_fixed_uint32_t\\n} } } */\n+WRAP (fixed_uint32_t);\n+\n+/*\n+** sel2_wrap_fixed_uint64_t:\n+**\tmov\tz0\\.d, z1\\.d\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_wrap_fixed_uint64_t\\n} } } */\n+WRAP (fixed_uint64_t);\n+\n+/*\n+** sel2_wrap_fixed_bfloat16_t:\n+**\tmov\tz0\\.d, z1\\.d\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_wrap_fixed_bfloat16_t\\n} } } */\n+WRAP (fixed_bfloat16_t);\n+\n+/*\n+** sel2_wrap_fixed_float16_t:\n+**\tmov\tz0\\.d, z1\\.d\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_wrap_fixed_float16_t\\n} } } */\n+WRAP (fixed_float16_t);\n+\n+/*\n+** sel2_wrap_fixed_float32_t:\n+**\tmov\tz0\\.d, z1\\.d\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_wrap_fixed_float32_t\\n} } } */\n+WRAP (fixed_float32_t);\n+\n+/*\n+** sel2_wrap_fixed_float64_t:\n+**\tmov\tz0\\.d, z1\\.d\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_wrap_fixed_float64_t\\n} } } */\n+WRAP (fixed_float64_t);\n+\n+/*\n+** sel2_wrap_fixed_bool_t:\n+**\tmov\tp0\\.b, p1\\.b\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_wrap_fixed_bool_t\\n} } } */\n+WRAP (fixed_bool_t);\n+\n+struct pst_arr1\n+{\n+  fixed_uint8_t u8[1];\n+};\n+\n+/*\n+** sel2_pst_arr1:\n+**\tmov\tz0\\.d, z1\\.d\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_arr1\\n} } } */\n+SEL2 (struct, pst_arr1)\n+\n+/*\n+** test_pst_arr1:\n+**\teor\tz0\\.b, z0\\.b, #(?:0x)?1\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_arr1\\n} } } */\n+svuint8_t\n+test_pst_arr1 (struct pst_arr1 x)\n+{\n+  return sveor_x (svptrue_b8 (), x.u8[0], 1);\n+}\n+\n+struct pst_arr2\n+{\n+  fixed_uint8_t u8[2];\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_arr2\\n} } } */\n+SEL2 (struct, pst_arr2)\n+\n+/*\n+** test_pst_arr2:\n+**\tsub\tz0\\.b, z0\\.b, z1\\.b\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_arr2\\n} } } */\n+svuint8_t\n+test_pst_arr2 (struct pst_arr2 x)\n+{\n+  return svsub_x (svptrue_b8 (), x.u8[0], x.u8[1]);\n+}\n+\n+struct pst_arr3\n+{\n+  fixed_uint16_t u16[3];\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_arr3\\n} } } */\n+SEL2 (struct, pst_arr3)\n+\n+/*\n+** test_pst_arr3:\n+**\tsub\tz0\\.h, z0\\.h, z2\\.h\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_arr3\\n} } } */\n+svuint16_t\n+test_pst_arr3 (struct pst_arr3 x)\n+{\n+  return svsub_x (svptrue_b8 (), x.u16[0], x.u16[2]);\n+}\n+\n+struct pst_arr4\n+{\n+  fixed_uint32_t u32[4];\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_arr4\\n} } } */\n+SEL2 (struct, pst_arr4)\n+\n+/*\n+** test_pst_arr4:\n+**\tsub\tz0\\.s, z0\\.s, z3\\.s\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_arr4\\n} } } */\n+svuint32_t\n+test_pst_arr4 (struct pst_arr4 x)\n+{\n+  return svsub_x (svptrue_b8 (), x.u32[0], x.u32[3]);\n+}\n+\n+struct pst_arr5\n+{\n+  fixed_uint64_t u64[2][2][2];\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_arr5\\n} } } */\n+SEL2 (struct, pst_arr5)\n+\n+/*\n+** test_pst_arr5: { target aarch64_little_endian }\n+**\tsub\tsp, sp, #512\n+**\tstr\tz0, \\[sp\\]\n+**\tstr\tz1, \\[sp, #1, mul vl\\]\n+**\tstr\tz2, \\[sp, #2, mul vl\\]\n+**\tstr\tz3, \\[sp, #3, mul vl\\]\n+**\tstr\tz4, \\[sp, #4, mul vl\\]\n+**\tstr\tz5, \\[sp, #5, mul vl\\]\n+**\tstr\tz6, \\[sp, #6, mul vl\\]\n+**\tstr\tz7, \\[sp, #7, mul vl\\]\n+**\tmov\t(x7, sp|w7, wsp)\n+**\tadd\tsp, sp, #?512\n+**\tret\n+*/\n+/*\n+** test_pst_arr5: { target aarch64_big_endian }\n+**\tsub\tsp, sp, #512\n+**\tptrue\t(p[0-3])\\.b, vl64\n+**\tst1d\tz0\\.d, \\1, \\[sp\\]\n+**\tst1d\tz1\\.d, \\1, \\[sp, #1, mul vl\\]\n+**\tst1d\tz2\\.d, \\1, \\[sp, #2, mul vl\\]\n+**\tst1d\tz3\\.d, \\1, \\[sp, #3, mul vl\\]\n+**\tst1d\tz4\\.d, \\1, \\[sp, #4, mul vl\\]\n+**\tst1d\tz5\\.d, \\1, \\[sp, #5, mul vl\\]\n+**\tst1d\tz6\\.d, \\1, \\[sp, #6, mul vl\\]\n+**\tst1d\tz7\\.d, \\1, \\[sp, #7, mul vl\\]\n+**\tmov\t((x7, sp|w7, wsp)|w7, wsp)\n+**\tadd\tsp, sp, #?512\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_arr5\\n} } } */\n+void\n+test_pst_arr5 (struct pst_arr5 x)\n+{\n+  CONSUME (x);\n+}\n+\n+/*\n+** test_pst_arr5_x0:\n+** (\n+**\tmov\tz0\\.d, z7\\.d\n+**\tmov\t(x7, x0|w7, w0)\n+** |\n+**\tmov\t(x7, x0|w7, w0)\n+**\tmov\tz0\\.d, z7\\.d\n+** )\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_arr5_x0\\n} } } */\n+svint32_t\n+test_pst_arr5_x0 (svint32_t z0, struct pst_arr5 x,\n+\t\t  svint32_t z1, svint32_t z2, svint32_t z3, svint32_t z4,\n+\t\t  svint32_t z5, svint32_t z6, svint32_t z7)\n+{\n+  CONSUME (x);\n+  return z7;\n+}\n+\n+/*\n+** test_pst_arr5_x7:\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_arr5_x7\\n} } } */\n+svint32_t\n+test_pst_arr5_x7 (svint32_t z0, int x0, int x1, int x2, int x3, int x4,\n+\t\t  int x5, int x6, struct pst_arr5 x)\n+{\n+  CONSUME (x);\n+  return z0;\n+}\n+\n+/*\n+** test_pst_arr5_sp: { target lp64 }\n+**\tldr\tx7, \\[sp\\]\n+**\tret\n+*/\n+/*\n+** test_pst_arr5_sp: { target ilp32 }\n+**\tldr\tw7, \\[sp(, 4)?\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_arr5_sp\\n} } } */\n+svint32_t\n+test_pst_arr5_sp (svint32_t z0, int x0, int x1, int x2, int x3, int x4,\n+\t\t  int x5, int x6, int x7, struct pst_arr5 x)\n+{\n+  CONSUME (x);\n+  return z0;\n+}\n+\n+struct pst_arr6\n+{\n+  fixed_bool_t b[2][2];\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_arr6\\n} } } */\n+SEL2 (struct, pst_arr6)\n+\n+/*\n+** test_pst_arr6:\n+**\t...\n+**\tbrkpa\tp0\\.b, p0/z, p2\\.b, p3\\.b\n+**\t...\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_arr6\\n} } } */\n+fixed_bool_t\n+test_pst_arr6 (struct pst_arr6 x)\n+{\n+  return svbrkpa_z (x.b[0][0], x.b[1][0], x.b[1][1]);\n+}\n+\n+/*\n+** test_pst_arr6_x0:\n+** (\n+**\tmov\tp0\\.b, p3\\.b\n+**\tmov\t(x7, x0|w7, w0)\n+** |\n+**\tmov\t(x7, x0|w7, w0)\n+**\tmov\tp0\\.b, p3\\.b\n+** )\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_arr6_x0\\n} } } */\n+fixed_bool_t\n+test_pst_arr6_x0 (svbool_t p0, struct pst_arr6 x, svbool_t p1, svbool_t p2,\n+\t\t  svbool_t p3)\n+{\n+  CONSUME (x);\n+  return p3;\n+}\n+\n+/*\n+** test_pst_arr6_x7:\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_arr6_x7\\n} } } */\n+fixed_bool_t\n+test_pst_arr6_x7 (svbool_t p0, int x0, int x1, int x2, int x3, int x4,\n+\t\t  int x5, int x6, struct pst_arr6 x)\n+{\n+  CONSUME (x);\n+  return p0;\n+}\n+\n+/*\n+** test_pst_arr6_sp: { target lp64 }\n+**\tldr\tx7, \\[sp\\]\n+**\tret\n+*/\n+/*\n+** test_pst_arr6_sp: { target ilp32 }\n+**\tldr\tw7, \\[sp(, 4)?\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_arr6_sp\\n} } } */\n+fixed_bool_t\n+test_pst_arr6_sp (svbool_t p0, int x0, int x1, int x2, int x3, int x4,\n+\t\t  int x5, int x6, int x7, struct pst_arr6 x)\n+{\n+  CONSUME (x);\n+  return p0;\n+}\n+\n+struct pst_uniform1\n+{\n+  fixed_int8_t a, b;\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_uniform1\\n} } } */\n+SEL2 (struct, pst_uniform1)\n+\n+/*\n+** test_pst_uniform1: { target aarch64_little_endian }\n+**\tsub\tsp, sp, #128\n+**\tstr\tz0, \\[sp\\]\n+**\tstr\tz1, \\[sp, #1, mul vl\\]\n+**\tmov\t(x7, sp|w7, wsp)\n+**\tadd\tsp, sp, #?128\n+**\tret\n+*/\n+/*\n+** test_pst_uniform1: { target aarch64_big_endian }\n+**\tsub\tsp, sp, #128\n+**\tptrue\t(p[0-3])\\.b, vl64\n+**\tst1b\tz0\\.b, \\1, \\[sp\\]\n+**\tst1b\tz1\\.b, \\1, \\[sp, #1, mul vl\\]\n+**\tmov\t(x7, sp|w7, wsp)\n+**\tadd\tsp, sp, #?128\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_uniform1\\n} } } */\n+void\n+test_pst_uniform1 (struct pst_uniform1 x)\n+{\n+  CONSUME (x);\n+}\n+\n+struct pst_uniform2\n+{\n+  fixed_int16_t a;\n+  fixed_int16_t b[2];\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_uniform2\\n} } } */\n+SEL2 (struct, pst_uniform2)\n+\n+/*\n+** test_pst_uniform2: { target aarch64_little_endian }\n+**\tsub\tsp, sp, #192\n+**\tstr\tz0, \\[sp\\]\n+**\tstr\tz1, \\[sp, #1, mul vl\\]\n+**\tstr\tz2, \\[sp, #2, mul vl\\]\n+**\tmov\t(x7, sp|w7, wsp)\n+**\tadd\tsp, sp, #?192\n+**\tret\n+*/\n+/*\n+** test_pst_uniform2: { target aarch64_big_endian }\n+**\tsub\tsp, sp, #192\n+**\tptrue\t(p[0-3])\\.b, vl64\n+**\tst1h\tz0\\.h, \\1, \\[sp\\]\n+**\tst1h\tz1\\.h, \\1, \\[sp, #1, mul vl\\]\n+**\tst1h\tz2\\.h, \\1, \\[sp, #2, mul vl\\]\n+**\tmov\t(x7, sp|w7, wsp)\n+**\tadd\tsp, sp, #?192\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_uniform2\\n} } } */\n+void\n+test_pst_uniform2 (struct pst_uniform2 x)\n+{\n+  CONSUME (x);\n+}\n+\n+struct pst_uniform3\n+{\n+  fixed_int32_t a;\n+  fixed_int32_t b[2];\n+  fixed_int32_t c;\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_uniform3\\n} } } */\n+SEL2 (struct, pst_uniform3)\n+\n+/*\n+** test_pst_uniform3: { target aarch64_little_endian }\n+**\tsub\tsp, sp, #256\n+**\tstr\tz0, \\[sp\\]\n+**\tstr\tz1, \\[sp, #1, mul vl\\]\n+**\tstr\tz2, \\[sp, #2, mul vl\\]\n+**\tstr\tz3, \\[sp, #3, mul vl\\]\n+**\tmov\t(x7, sp|w7, wsp)\n+**\tadd\tsp, sp, #?256\n+**\tret\n+*/\n+/*\n+** test_pst_uniform3: { target aarch64_big_endian }\n+**\tsub\tsp, sp, #256\n+**\tptrue\t(p[0-3])\\.b, vl64\n+**\tst1w\tz0\\.s, \\1, \\[sp\\]\n+**\tst1w\tz1\\.s, \\1, \\[sp, #1, mul vl\\]\n+**\tst1w\tz2\\.s, \\1, \\[sp, #2, mul vl\\]\n+**\tst1w\tz3\\.s, \\1, \\[sp, #3, mul vl\\]\n+**\tmov\t(x7, sp|w7, wsp)\n+**\tadd\tsp, sp, #?256\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_uniform3\\n} } } */\n+void\n+test_pst_uniform3 (struct pst_uniform3 x)\n+{\n+  CONSUME (x);\n+}\n+\n+struct pst_uniform4\n+{\n+  fixed_int32_t a __attribute__((aligned(SVE_BYTES * 2)));\n+  fixed_int32_t b[3] __attribute__((aligned(SVE_BYTES * 2)));\n+  fixed_int32_t c __attribute__((aligned(SVE_BYTES * 2)));\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_uniform4\\n} } } */\n+SEL2 (struct, pst_uniform4)\n+\n+/*\n+** test_pst_uniform4: { target aarch64_little_endian }\n+**\tsub\tsp, sp, #624\n+**\tadd\t(x[0-9]+), sp, #?127\n+**\tand\tx7, \\1, #?(?:-128|4294967168)\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tst1w\tz0\\.s, \\2, \\[x7\\]\n+**\tadd\t(x[0-9]+), x7, #?128\n+**\tstr\tz1, \\[\\3\\]\n+**\tstr\tz2, \\[\\3, #1, mul vl\\]\n+**\tstr\tz3, \\[\\3, #2, mul vl\\]\n+**\tst1w\tz4\\.s, \\2, \\[x7, #6, mul vl\\]\n+**\tadd\tsp, sp, #?624\n+**\tret\n+*/\n+/*\n+** test_pst_uniform4: { target aarch64_big_endian }\n+**\tsub\tsp, sp, #624\n+**\tadd\t(x[0-9]+), sp, #?127\n+**\tand\tx7, \\1, #?(?:-128|4294967168)\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tst1w\tz0\\.s, \\2, \\[x7\\]\n+**\tadd\t(x[0-9]+), x7, #?128\n+**\tst1w\tz1\\.s, \\2, \\[\\3\\]\n+**\tst1w\tz2\\.s, \\2, \\[\\3, #1, mul vl\\]\n+**\tst1w\tz3\\.s, \\2, \\[\\3, #2, mul vl\\]\n+**\tst1w\tz4\\.s, \\2, \\[x7, #6, mul vl\\]\n+**\tadd\tsp, sp, #?624\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_uniform4\\n} } } */\n+void\n+test_pst_uniform4 (struct pst_uniform4 x)\n+{\n+  CONSUME (x);\n+}\n+\n+struct pst_mixed1\n+{\n+  fixed_bool_t p0;\n+  fixed_bfloat16_t z0;\n+  fixed_float16_t z1;\n+  fixed_float32_t z2;\n+  fixed_float64_t z3;\n+  fixed_bool_t p1;\n+  fixed_bool_t p2;\n+  fixed_int8_t z4;\n+  fixed_int16_t z5;\n+  fixed_int32_t z6;\n+  fixed_int64_t z7;\n+  fixed_bool_t p3;\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_mixed1\\n} } } */\n+SEL2 (struct, pst_mixed1)\n+\n+/*\n+** test_pst_mixed1:\n+**\tsub\tsp, sp, #560\n+**\tstr\tp0, \\[sp\\]\n+**\tptrue\tp0\\.b, vl64\n+**\tadd\t(x[0-9+]), sp, #?16\n+**\tst1h\tz0\\.h, p0, \\[\\1\\]\n+**\tadd\t(x[0-9+]), sp, #?80\n+**\tst1h\tz1\\.h, p0, \\[\\2\\]\n+**\tadd\t(x[0-9+]), sp, #?144\n+**\tst1w\tz2\\.s, p0, \\[\\3\\]\n+**\tadd\t(x[0-9+]), sp, #?208\n+**\tst1d\tz3\\.d, p0, \\[\\4\\]\n+**\tstr\tp1, \\[sp, #34, mul vl\\]\n+**\tstr\tp2, \\[sp, #35, mul vl\\]\n+**\tadd\t(x[0-9+]), sp, #?288\n+**\tst1b\tz4\\.b, p0, \\[\\5\\]\n+**\tadd\t(x[0-9+]), sp, #?352\n+**\tst1h\tz5\\.h, p0, \\[\\6\\]\n+**\tadd\t(x[0-9+]), sp, #?416\n+**\tst1w\tz6\\.s, p0, \\[\\7\\]\n+**\tadd\t(x[0-9+]), sp, #?480\n+**\tst1d\tz7\\.d, p0, \\[\\8\\]\n+**\tstr\tp3, \\[sp, #68, mul vl\\]\n+**\tmov\t(x7, sp|w7, wsp)\n+**\tadd\tsp, sp, #?560\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_mixed1\\n} } } */\n+void\n+test_pst_mixed1 (struct pst_mixed1 x)\n+{\n+  CONSUME (x);\n+}\n+\n+struct pst_mixed2\n+{\n+  struct __attribute__ ((packed)) {\n+    fixed_bool_t p;\n+    fixed_int8_t z;\n+  } a[3];\n+  fixed_int16_t b[1][1][1][4];\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_mixed2\\n} } } */\n+SEL2 (struct, pst_mixed2)\n+\n+/*\n+** test_pst_mixed2: { target aarch64_little_endian }\n+**\tsub\tsp, sp, #480\n+**\tstr\tp0, \\[sp\\]\n+**\tptrue\t(p[03])\\.b, vl64\n+**\tadd\t(x[0-9]+), sp, #?8\n+**\tst1b\tz0\\.b, \\1, \\[\\2\\]\n+**\tstr\tp1, \\[sp, #9, mul vl\\]\n+**\tadd\t(x[0-9]+), sp, #?80\n+**\tst1b\tz1\\.b, \\1, \\[\\3\\]\n+**\tstr\tp2, \\[sp, #18, mul vl\\]\n+**\tadd\t(x[0-9]+), sp, #?152\n+**\tst1b\tz2\\.b, \\1, \\[\\4\\]\n+**\tadd\t(x[0-9]+), sp, #?224\n+**\tstr\tz3, \\[\\5\\]\n+**\tstr\tz4, \\[\\5, #1, mul vl\\]\n+**\tstr\tz5, \\[\\5, #2, mul vl\\]\n+**\tstr\tz6, \\[\\5, #3, mul vl\\]\n+**\tmov\t(x7, sp|w7, wsp)\n+**\tadd\tsp, sp, #?480\n+**\tret\n+*/\n+/*\n+** test_pst_mixed2: { target aarch64_big_endian }\n+**\tsub\tsp, sp, #480\n+**\tstr\tp0, \\[sp\\]\n+**\tptrue\t(p[03])\\.b, vl64\n+**\tadd\t(x[0-9]+), sp, #?8\n+**\tst1b\tz0\\.b, \\1, \\[\\2\\]\n+**\tstr\tp1, \\[sp, #9, mul vl\\]\n+**\tadd\t(x[0-9]+), sp, #?80\n+**\tst1b\tz1\\.b, \\1, \\[\\3\\]\n+**\tstr\tp2, \\[sp, #18, mul vl\\]\n+**\tadd\t(x[0-9]+), sp, #?152\n+**\tst1b\tz2\\.b, \\1, \\[\\4\\]\n+**\tadd\t(x[0-9]+), sp, #?224\n+**\tst1h\tz3\\.h, \\1, \\[\\5\\]\n+**\tst1h\tz4\\.h, \\1, \\[\\5, #1, mul vl\\]\n+**\tst1h\tz5\\.h, \\1, \\[\\5, #2, mul vl\\]\n+**\tst1h\tz6\\.h, \\1, \\[\\5, #3, mul vl\\]\n+**\tmov\t(x7, sp|w7, wsp)\n+**\tadd\tsp, sp, #?480\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_mixed2\\n} } } */\n+void\n+test_pst_mixed2 (struct pst_mixed2 x)\n+{\n+  CONSUME (x);\n+}\n+\n+struct pst_big1\n+{\n+  fixed_int8_t a[9];\n+};\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tsel2_pst_big1\\n} } } */\n+SEL2 (struct, pst_big1)\n+\n+/*\n+** test_pst_big1_a: { target lp64 }\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1b\tz0\\.b, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+/*\n+** test_pst_big1_a: { target ilp32 }\n+**\tuxtw\tx0, w0\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1b\tz0\\.b, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_big1_a\\n} } } */\n+svint8_t\n+test_pst_big1_a (struct pst_big1 x)\n+{\n+  return x.a[0];\n+}\n+\n+/*\n+** test_pst_big1_b: { target lp64 }\n+**\tadd\tx7, x0, #?512\n+**\tret\n+*/\n+/*\n+** test_pst_big1_b: { target ilp32 }\n+**\tadd\tw7, w0, #?512\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_big1_b\\n} } } */\n+svint8_t\n+test_pst_big1_b (struct pst_big1 x)\n+{\n+  CONSUME (x.a[8]);\n+}\n+\n+struct pst_big2\n+{\n+  fixed_bool_t a[5];\n+};\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tsel2_pst_big2\\n} } } */\n+SEL2 (struct, pst_big2)\n+\n+/*\n+** test_pst_big2_a: { target lp64 }\n+**\tldr\tp0, \\[x0\\]\n+**\tret\n+*/\n+/*\n+** test_pst_big2_a: { target ilp32 }\n+**\tuxtw\tx0, w0\n+**\tldr\tp0, \\[x0\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_big2_a\\n} } } */\n+svbool_t\n+test_pst_big2_a (struct pst_big2 x)\n+{\n+  return x.a[0];\n+}\n+\n+/*\n+** test_pst_big2_b: { target lp64 }\n+**\tldr\tp0, \\[x0, #4, mul vl\\]\n+**\tret\n+*/\n+/*\n+** test_pst_big2_b: { target ilp32 }\n+**\tuxtw\tx0, w0\n+**\tldr\tp0, \\[x0, #4, mul vl\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_big2_b\\n} } } */\n+svbool_t\n+test_pst_big2_b (struct pst_big2 x)\n+{\n+  return x.a[4];\n+}\n+\n+struct pst_big3\n+{\n+  fixed_bool_t p0;\n+  fixed_int8_t a[2];\n+  fixed_bool_t p1;\n+  fixed_bool_t p2;\n+  fixed_bool_t p3;\n+  fixed_int8_t b[6];\n+  fixed_bool_t p4;\n+};\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tsel2_pst_big3\\n} } } */\n+SEL2 (struct, pst_big3)\n+\n+/*\n+** test_pst_big3_a: { target lp64 }\n+**\tldr\tp0, \\[x0\\]\n+**\tret\n+*/\n+/*\n+** test_pst_big3_a: { target ilp32 }\n+**\tuxtw\tx0, w0\n+**\tldr\tp0, \\[x0\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_big3_a\\n} } } */\n+svbool_t\n+test_pst_big3_a (struct pst_big3 x)\n+{\n+  return x.p0;\n+}\n+\n+/*\n+** test_pst_big3_b: { target lp64 }\n+**\tldr\tp0, \\[x0, #18, mul vl\\]\n+**\tret\n+*/\n+/*\n+** test_pst_big3_b: { target ilp32 }\n+**\tuxtw\tx0, w0\n+**\tldr\tp0, \\[x0, #18, mul vl\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_big3_b\\n} } } */\n+svbool_t\n+test_pst_big3_b (struct pst_big3 x)\n+{\n+  return x.p1;\n+}\n+\n+/*\n+** test_pst_big3_c: { target lp64 }\n+**\tldr\tp0, \\[x0, #19, mul vl\\]\n+**\tret\n+*/\n+/*\n+** test_pst_big3_c: { target ilp32 }\n+**\tuxtw\tx0, w0\n+**\tldr\tp0, \\[x0, #19, mul vl\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_big3_c\\n} } } */\n+svbool_t\n+test_pst_big3_c (struct pst_big3 x)\n+{\n+  return x.p2;\n+}\n+\n+/*\n+** test_pst_big3_d: { target lp64 }\n+**\tldr\tp0, \\[x0, #70, mul vl\\]\n+**\tret\n+*/\n+/*\n+** test_pst_big3_d: { target ilp32 }\n+**\tuxtw\tx0, w0\n+**\tldr\tp0, \\[x0, #70, mul vl\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_big3_d\\n} } } */\n+svbool_t\n+test_pst_big3_d (struct pst_big3 x)\n+{\n+  return x.p4;\n+}\n+\n+/*\n+** test_pst_big3_e: { target lp64 }\n+**\tadd\t(x[0-9]+), x0, #?16\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1b\tz0\\.b, \\2/z, \\[\\1\\]\n+**\tret\n+*/\n+/*\n+** test_pst_big3_e: { target ilp32 }\n+**\tuxtw\tx0, w0\n+**\tadd\t(x[0-9]+), x0, #?16\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1b\tz0\\.b, \\2/z, \\[\\1\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_big3_e\\n} } } */\n+svint8_t\n+test_pst_big3_e (struct pst_big3 x)\n+{\n+  return x.a[0];\n+}\n+\n+/*\n+** test_pst_big3_f: { target lp64 }\n+**\tadd\t(x[0-9]+), x0, #?240\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1b\tz0\\.b, \\2/z, \\[\\1\\]\n+**\tret\n+*/\n+/*\n+** test_pst_big3_f: { target ilp32 }\n+**\tuxtw\tx0, w0\n+**\tadd\t(x[0-9]+), x0, #?240\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1b\tz0\\.b, \\2/z, \\[\\1\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_big3_f\\n} } } */\n+svint8_t\n+test_pst_big3_f (struct pst_big3 x)\n+{\n+  return x.b[1];\n+}\n+\n+struct pst_zero1\n+{\n+  fixed_bool_t a[0];\n+  fixed_int32_t b;\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_zero1\\n} } } */\n+SEL2 (struct, pst_zero1)\n+\n+/*\n+** test_pst_zero1:\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_zero1\\n} } } */\n+svint32_t\n+test_pst_zero1 (struct pst_zero1 x)\n+{\n+  return x.b;\n+}\n+\n+struct pst_zero2\n+{\n+  unsigned int : 0;\n+  fixed_bool_t b;\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_zero2\\n} } } */\n+SEL2 (struct, pst_zero2)\n+\n+/*\n+** test_pst_zero2:\n+** (\n+**\tsub\tsp, sp, #16\n+**\tadd\tsp, sp, #?16\n+** |\n+** )\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_zero2\\n} } } */\n+svbool_t\n+test_pst_zero2 (struct pst_zero2 x)\n+{\n+  return x.b;\n+}\n+\n+struct pst_zero3\n+{\n+  struct {} empty;\n+  fixed_uint64_t b;\n+};\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\tsel2_pst_zero3\\n} } } */\n+SEL2 (struct, pst_zero3)\n+\n+/*\n+** test_pst_zero3:\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_pst_zero3\\n} } } */\n+svuint64_t\n+test_pst_zero3 (struct pst_zero3 x)\n+{\n+  return x.b;\n+}\n+\n+typedef unsigned char small_vec __attribute__((vector_size(SVE_BYTES / 4)));\n+\n+struct nonpst1\n+{\n+  small_vec a[4];\n+};\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tsel2_pst_nonpst1\\n} } } */\n+SEL2 (struct, nonpst1)\n+\n+/*\n+** test_nonpst1:\n+**\tmov\tv0\\.16b, v3\\.16b\n+**\tret\n+*/\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\ttest_nonpst1\\n} } } */\n+small_vec\n+test_nonpst1 (struct nonpst1 x)\n+{\n+  return x.a[3];\n+}\n+\n+union nonpst2\n+{\n+  struct {\n+    fixed_bool_t a[0];\n+    fixed_int32_t b;\n+  };\n+};\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tsel2_pst_nonpst2\\n} } } */\n+SEL2 (union, nonpst2)\n+\n+/*\n+** test_nonpst2: { target lp64 }\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+/*\n+** test_nonpst2: { target ilp32 }\n+**\tuxtw\tx0, w0\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1w\tz0\\.s, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_nonpst2\\n} } } */\n+svint32_t\n+test_nonpst2 (union nonpst2 x)\n+{\n+  return x.b;\n+}\n+\n+/*\n+** ret_nonpst2:\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tindex\t(z[0-9]+\\.s), #1, #2\n+**\tst1w\t\\2, \\1, \\[x8\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tret_nonpst2\\n} } } */\n+union nonpst2\n+ret_nonpst2 (void)\n+{\n+  return (union nonpst2) { { {}, 1, 3, 5, 7, 9, 11, 13, 15,\n+\t\t\t         17, 19, 21, 23, 25, 27, 29, 31 } };\n+}\n+\n+union nonpst3\n+{\n+  struct {\n+    unsigned int : 0;\n+    fixed_bool_t b;\n+  };\n+};\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tsel2_pst_nonpst3\\n} } } */\n+SEL2 (union, nonpst3)\n+\n+/*\n+** test_nonpst3:\n+**\tsub\tsp, sp, #16\n+**\tstr\tx0, \\[sp, #?8\\]\n+**\tldr\tp0, \\[sp, #1, mul vl\\]\n+**\tadd\tsp, sp, #?16\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_nonpst3\\n} } } */\n+svbool_t\n+test_nonpst3 (union nonpst3 x)\n+{\n+  return x.b;\n+}\n+\n+/*\n+** ret_nonpst3:\n+**\tmov\tx0, -1\n+**\tret\n+*/\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tret_nonpst3\\n} } } */\n+union nonpst3\n+ret_nonpst3 (void)\n+{\n+  return (union nonpst3) { { svptrue_b8 () } };\n+}\n+\n+union nonpst4\n+{\n+  struct {\n+    struct {} empty;\n+    fixed_uint64_t b;\n+  };\n+};\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tsel2_pst_nonpst4\\n} } } */\n+SEL2 (union, nonpst4)\n+\n+/*\n+** test_nonpst4: { target lp64 }\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+/*\n+** test_nonpst4: { target ilp32 }\n+**\tuxtw\tx0, w0\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_nonpst4\\n} } } */\n+svuint64_t\n+test_nonpst4 (union nonpst4 x)\n+{\n+  return x.b;\n+}\n+\n+/*\n+** ret_nonpst4:\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tindex\t(z[0-9]+\\.d), #1, #1\n+**\tst1d\t\\2, \\1, \\[x8\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tret_nonpst4\\n} } } */\n+union nonpst4\n+ret_nonpst4 (void)\n+{\n+  return (union nonpst4) { { {}, 1, 2, 3, 4, 5, 6, 7, 8 } };\n+}\n+\n+struct nonpst5\n+{\n+  union {\n+    fixed_uint16_t b;\n+  };\n+};\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tsel2_pst_nonpst5\\n} } } */\n+SEL2 (struct, nonpst5)\n+\n+/*\n+** test_nonpst5: { target lp64 }\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+/*\n+** test_nonpst5: { target ilp32 }\n+**\tuxtw\tx0, w0\n+**\tptrue\t(p[0-7])\\.b, vl64\n+**\tld1h\tz0\\.h, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_nonpst5\\n} } } */\n+svuint16_t\n+test_nonpst5 (struct nonpst5 x)\n+{\n+  return x.b;\n+}\n+\n+struct nonpst6\n+{\n+  fixed_uint64_t b;\n+  fixed_uint64_t *ptr;\n+};\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tsel2_pst_nonpst6\\n} } } */\n+SEL2 (struct, nonpst6)\n+\n+/*\n+** test_nonpst6: { target lp64 }\n+**\tptrue\t(p[0-3])\\.b, vl64\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+/*\n+** test_nonpst6: { target ilp32 }\n+**\tuxtw\tx0, w0\n+**\tptrue\t(p[0-3])\\.b, vl64\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_nonpst6\\n} } } */\n+svuint64_t\n+test_nonpst6 (struct nonpst6 x)\n+{\n+  return x.b;\n+}\n+\n+struct nonpst7\n+{\n+  fixed_uint64_t b;\n+  uint32_t foo __attribute__((vector_size(SVE_BYTES)));\n+};\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tsel2_pst_nonpst7\\n} } } */\n+SEL2 (struct, nonpst7)\n+\n+/*\n+** test_nonpst7: { target lp64 }\n+**\tptrue\t(p[0-3])\\.b, vl64\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+/*\n+** test_nonpst7: { target ilp32 }\n+**\tuxtw\tx0, w0\n+**\tptrue\t(p[0-3])\\.b, vl64\n+**\tld1d\tz0\\.d, \\1/z, \\[x0\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler {\\t\\.variant_pcs\\ttest_nonpst7\\n} } } */\n+svuint64_t\n+test_nonpst7 (struct nonpst7 x)\n+{\n+  return x.b;\n+}\n+\n+typedef unsigned char tiny_vec __attribute__((vector_size(SVE_BYTES / 8)));\n+\n+struct nonpst8\n+{\n+  tiny_vec a;\n+};\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tsel2_pst_nonpst8\\n} } } */\n+SEL2 (struct, nonpst8)\n+\n+/*\n+** test_nonpst8: { target aarch64_little_endian }\n+**\tumov\tw0, v0\\.b\\[1\\]\n+**\tret\n+*/\n+/*\n+** test_nonpst8: { target aarch64_big_endian }\n+**\tumov\tw0, v0\\.b\\[6\\]\n+**\tret\n+*/\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\ttest_nonpst8\\n} } } */\n+unsigned int\n+test_nonpst8 (struct nonpst8 x)\n+{\n+  return x.a[1];\n+}\n+\n+/*\n+** ret_nonpst8:\n+**\tmovi\tv0\\.8b, 0x1\n+**\tret\n+*/\n+/* { dg-final { scan-assembler-not {\\t\\.variant_pcs\\tret_nonpst8\\n} } } */\n+struct nonpst8\n+ret_nonpst8 (void)\n+{\n+  return (struct nonpst8) { { 1, 1, 1, 1, 1, 1, 1, 1 } };\n+}"}, {"sha": "3758bb3a91d52ea1787599627f9c8f5d5602c78f", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=38e62001c576b8c6ba2e08eb4673d69ec4c5b0f9", "patch": "@@ -4695,8 +4695,12 @@ proc aarch64_sve_hw_bits { bits } {\n # Return true if this is an AArch64 target that can run SVE code and\n # if its SVE vectors have exactly 256 bits.\n \n-proc check_effective_target_aarch64_sve256_hw { } {\n-    return [aarch64_sve_hw_bits 256]\n+foreach N { 128 256 512 1024 2048 } {\n+    eval [string map [list N $N] {\n+\tproc check_effective_target_aarch64_sveN_hw { } {\n+\t    return [aarch64_sve_hw_bits N]\n+\t}\n+    }]\n }\n \n proc check_effective_target_arm_neonv2_hw { } {"}]}