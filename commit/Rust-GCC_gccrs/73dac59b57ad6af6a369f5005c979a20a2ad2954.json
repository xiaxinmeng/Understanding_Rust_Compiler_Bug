{"sha": "73dac59b57ad6af6a369f5005c979a20a2ad2954", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzNkYWM1OWI1N2FkNmFmNmEzNjlmNTAwNWM5NzlhMjBhMmFkMjk1NA==", "commit": {"author": {"name": "Claudiu Zissulescu", "email": "claziss@synopsys.com", "date": "2018-11-14T09:45:39Z"}, "committer": {"name": "Claudiu Zissulescu", "email": "claziss@gcc.gnu.org", "date": "2018-11-14T09:45:39Z"}, "message": "[ARC] Cleanup, fix and set LRA default.\n\nLP_COUNT register cannot be freely allocated by the compiler as it\nsize, and/or content may change depending on the ARC hardware\nconfiguration. Thus, make this register fixed.\n\nRemove register classes and unused constraint letters.\n\nCleanup the implementation of conditional_register_usage hook by using\nmacros instead of magic constants and removing all references to\nreg_class_contents which are bringing so much grief when lra is enabled.\n\ngcc/\nxxxx-xx-xx  Claudiu Zissulescu  <claziss@synopsys.com>\n\n\t* config/arc/arc.h (reg_class): Reorder registers classes, remove\n\tunused register classes.\n\t(REG_CLASS_NAMES): Likewise.\n\t(REG_CLASS_CONTENTS): Likewise.\n\t(FIXED_REGISTERS): Make lp_count fixed.\n\t(BASE_REG_CLASS): Remove ACC16_BASE_REGS reference.\n\t(PROGRAM_COUNTER_REGNO): Remove.\n\t* config/arc/arc.c (arc_conditional_register_usage): Remove unused\n\tregister classes, use constants for register numbers, remove\n\treg_class_contents references.\n\t(arc_process_double_reg_moves): Add asserts.\n\t(arc_secondary_reload): Remove LPCOUNT_REG reference, use\n\tlra_in_progress predicate.\n\t(arc_init_reg_tables): Remove unused register classes.\n\t(arc_register_move_cost): Likewise.\n\t(arc_preferred_reload_class): Likewise.\n\t(hwloop_optimize): Update rtx patterns involving lp_count\n\tregister.\n\t(arc_return_address_register): Rename ILINK1, INLINK2 regnums\n\tmacros.\n\t* config/arc/constraints.md (\"c\"): Choose between GENERAL_REGS and\n\tCHEAP_CORE_REGS.  Former one will be used for LRA.\n\t(\"Rac\"): Choose between GENERAL_REGS and ALL_CORE_REGS.  Former\n\tone will be used for LRA.\n\t(\"w\"): Choose between GENERAL_REGS and WRITABLE_CORE_REGS.  Former\n\tone will be used for LRA.\n\t(\"W\"): Choose between GENERAL_REGS and MPY_WRITABLE_CORE_REGS.\n\tFormer one will be used for LRA.\n\t(\"f\"): Delete constraint.\n\t(\"k\"): Likewise.\n\t(\"e\"): Likewise.\n\t(\"l\"): Change it from register constraint to constraint.\n\t* config/arc/arc.md (movqi_insn): Remove unsed lp_count constraints.\n\t(movhi_insn): Likewise.\n\t(movsi_insn): Update pattern.\n\t(arc_lp): Likewise.\n\t(dbnz): Likewise.\n\t(stack_tie): Remove 'b' constraint letter.\n\t(R4_REG): Define.\n\t(R9_REG, R15_REG, R16_REG, R25_REG): Likewise.\n\t(R32_REG, R40_REG, R41_REG, R42_REG, R43_REG, R44_REG): Likewise.\n\t(R57_REG, R59_REG, PCL_REG): Likewise.\n\t(ILINK1_REGNUM): Renamed to ILINK1_REG.\n\t(ILINK2_REGNUM): Renamed to ILINK2_REG.\n\t(Rgp): Remove.\n\t(SP_REGS): Likewise.\n\t(Rcw): Remove unused reg classes.\n\t* config/arc/predicates.md (dest_reg_operand): Just default on\n\tregister_operand predicate.\n\t(mpy_dest_reg_operand): Likewise.\n\t(move_dest_operand): Use macros instead of constants.\n\nFrom-SVN: r266100", "tree": {"sha": "ff77dc94be6a2fdc615f58972801946866293c45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff77dc94be6a2fdc615f58972801946866293c45"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73dac59b57ad6af6a369f5005c979a20a2ad2954", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73dac59b57ad6af6a369f5005c979a20a2ad2954", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73dac59b57ad6af6a369f5005c979a20a2ad2954", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73dac59b57ad6af6a369f5005c979a20a2ad2954/comments", "author": {"login": "claziss", "id": 2761368, "node_id": "MDQ6VXNlcjI3NjEzNjg=", "avatar_url": "https://avatars.githubusercontent.com/u/2761368?v=4", "gravatar_id": "", "url": "https://api.github.com/users/claziss", "html_url": "https://github.com/claziss", "followers_url": "https://api.github.com/users/claziss/followers", "following_url": "https://api.github.com/users/claziss/following{/other_user}", "gists_url": "https://api.github.com/users/claziss/gists{/gist_id}", "starred_url": "https://api.github.com/users/claziss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/claziss/subscriptions", "organizations_url": "https://api.github.com/users/claziss/orgs", "repos_url": "https://api.github.com/users/claziss/repos", "events_url": "https://api.github.com/users/claziss/events{/privacy}", "received_events_url": "https://api.github.com/users/claziss/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f711908bf61e39432965db84ed12424cc6f251e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f711908bf61e39432965db84ed12424cc6f251e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f711908bf61e39432965db84ed12424cc6f251e1"}], "stats": {"total": 628, "additions": 277, "deletions": 351}, "files": [{"sha": "ab9e0010a9cca33b226d0f147cc73be27ece3cab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73dac59b57ad6af6a369f5005c979a20a2ad2954/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73dac59b57ad6af6a369f5005c979a20a2ad2954/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=73dac59b57ad6af6a369f5005c979a20a2ad2954", "patch": "@@ -1,3 +1,58 @@\n+2018-11-14  Claudiu Zissulescu  <claziss@synopsys.com>\n+\n+\t* config/arc/arc.h (reg_class): Reorder registers classes, remove\n+\tunused register classes.\n+\t(REG_CLASS_NAMES): Likewise.\n+\t(REG_CLASS_CONTENTS): Likewise.\n+\t(FIXED_REGISTERS): Make lp_count fixed.\n+\t(BASE_REG_CLASS): Remove ACC16_BASE_REGS reference.\n+\t(PROGRAM_COUNTER_REGNO): Remove.\n+\t* config/arc/arc.c (arc_conditional_register_usage): Remove unused\n+\tregister classes, use constants for register numbers, remove\n+\treg_class_contents references.\n+\t(arc_process_double_reg_moves): Add asserts.\n+\t(arc_secondary_reload): Remove LPCOUNT_REG reference, use\n+\tlra_in_progress predicate.\n+\t(arc_init_reg_tables): Remove unused register classes.\n+\t(arc_register_move_cost): Likewise.\n+\t(arc_preferred_reload_class): Likewise.\n+\t(hwloop_optimize): Update rtx patterns involving lp_count\n+\tregister.\n+\t(arc_return_address_register): Rename ILINK1, INLINK2 regnums\n+\tmacros.\n+\t* config/arc/constraints.md (\"c\"): Choose between GENERAL_REGS and\n+\tCHEAP_CORE_REGS.  Former one will be used for LRA.\n+\t(\"Rac\"): Choose between GENERAL_REGS and ALL_CORE_REGS.  Former\n+\tone will be used for LRA.\n+\t(\"w\"): Choose between GENERAL_REGS and WRITABLE_CORE_REGS.  Former\n+\tone will be used for LRA.\n+\t(\"W\"): Choose between GENERAL_REGS and MPY_WRITABLE_CORE_REGS.\n+\tFormer one will be used for LRA.\n+\t(\"f\"): Delete constraint.\n+\t(\"k\"): Likewise.\n+\t(\"e\"): Likewise.\n+\t(\"l\"): Change it from register constraint to constraint.\n+\t* config/arc/arc.md (movqi_insn): Remove unsed lp_count constraints.\n+\t(movhi_insn): Likewise.\n+\t(movsi_insn): Update pattern.\n+\t(arc_lp): Likewise.\n+\t(dbnz): Likewise.\n+\t(stack_tie): Remove 'b' constraint letter.\n+\t(R4_REG): Define.\n+\t(R9_REG, R15_REG, R16_REG, R25_REG): Likewise.\n+\t(R32_REG, R40_REG, R41_REG, R42_REG, R43_REG, R44_REG): Likewise.\n+\t(R57_REG, R59_REG, PCL_REG): Likewise.\n+\t(ILINK1_REGNUM): Renamed to ILINK1_REG.\n+\t(ILINK2_REGNUM): Renamed to ILINK2_REG.\n+\t(Rgp): Remove.\n+\t(SP_REGS): Likewise.\n+\t(Rcw): Remove unused reg classes.\n+\t* config/arc/predicates.md (dest_reg_operand): Just default on\n+\tregister_operand predicate.\n+\t(mpy_dest_reg_operand): Likewise.\n+\t(move_dest_operand): Use macros instead of constants.\n+\t* config/arc/arc.opt (mlra): Switch to lra as default.\n+\n 2018-11-14  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/87974"}, {"sha": "55175215bfed6e166a92ae046b36487662c36dd0", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 127, "deletions": 202, "changes": 329, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73dac59b57ad6af6a369f5005c979a20a2ad2954/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73dac59b57ad6af6a369f5005c979a20a2ad2954/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=73dac59b57ad6af6a369f5005c979a20a2ad2954", "patch": "@@ -734,11 +734,6 @@ arc_secondary_reload (bool in_p,\n   if (cl == DOUBLE_REGS)\n     return GENERAL_REGS;\n \n-  /* The loop counter register can be stored, but not loaded directly.  */\n-  if ((cl == LPCOUNT_REG || cl == WRITABLE_CORE_REGS)\n-      && in_p && MEM_P (x))\n-    return GENERAL_REGS;\n-\n  /* If we have a subreg (reg), where reg is a pseudo (that will end in\n     a memory location), then we may need a scratch register to handle\n     the fp/sp+largeoffset address.  */\n@@ -756,8 +751,9 @@ arc_secondary_reload (bool in_p,\n \t  if (regno != -1)\n \t    return NO_REGS;\n \n-\t  /* It is a pseudo that ends in a stack location.  */\n-\t  if (reg_equiv_mem (REGNO (x)))\n+\t  /* It is a pseudo that ends in a stack location.  This\n+\t     procedure only works with the old reload step.  */\n+\t  if (reg_equiv_mem (REGNO (x)) && !lra_in_progress)\n \t    {\n \t      /* Get the equivalent address and check the range of the\n \t\t offset.  */\n@@ -1659,8 +1655,6 @@ enum reg_class arc_regno_reg_class[FIRST_PSEUDO_REGISTER];\n enum reg_class\n arc_preferred_reload_class (rtx, enum reg_class cl)\n {\n-  if ((cl) == CHEAP_CORE_REGS  || (cl) == WRITABLE_CORE_REGS)\n-    return GENERAL_REGS;\n   return cl;\n }\n \n@@ -1758,25 +1752,21 @@ arc_conditional_register_usage (void)\n       strcpy (rname29, \"ilink\");\n       strcpy (rname30, \"r30\");\n \n-      if (!TEST_HARD_REG_BIT (overrideregs, 30))\n+      if (!TEST_HARD_REG_BIT (overrideregs, R30_REG))\n \t{\n \t  /* No user interference.  Set the r30 to be used by the\n \t     compiler.  */\n-\t  call_used_regs[30] = 1;\n-\t  fixed_regs[30] = 0;\n+\t  call_used_regs[R30_REG] = 1;\n+\t  fixed_regs[R30_REG] = 0;\n \n-\t  arc_regno_reg_class[30] = WRITABLE_CORE_REGS;\n-\t  SET_HARD_REG_BIT (reg_class_contents[WRITABLE_CORE_REGS], 30);\n-\t  SET_HARD_REG_BIT (reg_class_contents[CHEAP_CORE_REGS], 30);\n-\t  SET_HARD_REG_BIT (reg_class_contents[GENERAL_REGS], 30);\n-\t  SET_HARD_REG_BIT (reg_class_contents[MPY_WRITABLE_CORE_REGS], 30);\n+\t  arc_regno_reg_class[R30_REG] = GENERAL_REGS;\n \t}\n    }\n \n   if (TARGET_MUL64_SET)\n     {\n-      fix_start = 57;\n-      fix_end = 59;\n+      fix_start = R57_REG;\n+      fix_end = R59_REG;\n \n       /* We don't provide a name for mmed.  In rtl / assembly resource lists,\n \t you are supposed to refer to it as mlo & mhi, e.g\n@@ -1799,8 +1789,8 @@ arc_conditional_register_usage (void)\n \n   if (TARGET_MULMAC_32BY16_SET)\n     {\n-      fix_start = 56;\n-      fix_end = fix_end > 57 ? fix_end : 57;\n+      fix_start = MUL32x16_REG;\n+      fix_end = fix_end > R57_REG ? fix_end : R57_REG;\n       strcpy (rname56, TARGET_BIG_ENDIAN ? \"acc1\" : \"acc2\");\n       strcpy (rname57, TARGET_BIG_ENDIAN ? \"acc2\" : \"acc1\");\n     }\n@@ -1862,130 +1852,59 @@ arc_conditional_register_usage (void)\n   /* Reduced configuration: don't use r4-r9, r16-r25.  */\n   if (TARGET_RF16)\n     {\n-      for (i = 4; i <= 9; i++)\n-\t{\n-\t  fixed_regs[i] = call_used_regs[i] = 1;\n-\t}\n-      for (i = 16; i <= 25; i++)\n-\t{\n-\t  fixed_regs[i] = call_used_regs[i] = 1;\n-\t}\n-    }\n-\n-  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-    if (!call_used_regs[regno])\n-      CLEAR_HARD_REG_BIT (reg_class_contents[SIBCALL_REGS], regno);\n-  for (regno = 32; regno < 60; regno++)\n-    if (!fixed_regs[regno])\n-      SET_HARD_REG_BIT (reg_class_contents[WRITABLE_CORE_REGS], regno);\n-  if (!TARGET_ARC600_FAMILY)\n-    {\n-      for (regno = 32; regno <= 60; regno++)\n-\tCLEAR_HARD_REG_BIT (reg_class_contents[CHEAP_CORE_REGS], regno);\n-\n-      /* If they have used -ffixed-lp_count, make sure it takes\n-\t effect.  */\n-      if (fixed_regs[LP_COUNT])\n-\t{\n-\t  CLEAR_HARD_REG_BIT (reg_class_contents[LPCOUNT_REG], LP_COUNT);\n-\t  CLEAR_HARD_REG_BIT (reg_class_contents[SIBCALL_REGS], LP_COUNT);\n-\t  CLEAR_HARD_REG_BIT (reg_class_contents[WRITABLE_CORE_REGS], LP_COUNT);\n-\n-\t  /* Instead of taking out SF_MODE like below, forbid it outright.  */\n-\t  arc_hard_regno_modes[60] = 0;\n-\t}\n-      else\n-\tarc_hard_regno_modes[60] = 1 << (int) S_MODE;\n+      for (i = R4_REG; i <= R9_REG; i++)\n+\tfixed_regs[i] = call_used_regs[i] = 1;\n+      for (i = R16_REG; i <= R25_REG; i++)\n+\tfixed_regs[i] = call_used_regs[i] = 1;\n     }\n \n   /* ARCHS has 64-bit data-path which makes use of the even-odd paired\n      registers.  */\n   if (TARGET_HS)\n-    {\n-      for (regno = 1; regno < 32; regno +=2)\n-\t{\n-\t  arc_hard_regno_modes[regno] = S_MODES;\n-\t}\n-    }\n+    for (regno = R1_REG; regno < R32_REG; regno +=2)\n+      arc_hard_regno_modes[regno] = S_MODES;\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    {\n-      if (i < 29)\n-\t{\n-\t  if ((TARGET_Q_CLASS || TARGET_RRQ_CLASS)\n-\t      && ((i <= 3) || ((i >= 12) && (i <= 15))))\n-\t    arc_regno_reg_class[i] = ARCOMPACT16_REGS;\n-\t  else\n-\t    arc_regno_reg_class[i] = GENERAL_REGS;\n-\t}\n-      else if (i < 60)\n-\tarc_regno_reg_class[i]\n-\t  = (fixed_regs[i]\n-\t     ? (TEST_HARD_REG_BIT (reg_class_contents[CHEAP_CORE_REGS], i)\n-\t\t? CHEAP_CORE_REGS : ALL_CORE_REGS)\n-\t     : (((!TARGET_ARC600_FAMILY)\n-\t\t && TEST_HARD_REG_BIT (reg_class_contents[CHEAP_CORE_REGS], i))\n-\t\t? CHEAP_CORE_REGS : WRITABLE_CORE_REGS));\n-      else\n-\tarc_regno_reg_class[i] = NO_REGS;\n-    }\n-\n-  /* ARCOMPACT16_REGS is empty, if TARGET_Q_CLASS / TARGET_RRQ_CLASS\n-     has not been activated.  */\n-  if (!TARGET_Q_CLASS && !TARGET_RRQ_CLASS)\n-    CLEAR_HARD_REG_SET(reg_class_contents [ARCOMPACT16_REGS]);\n-  if (!TARGET_Q_CLASS)\n-    CLEAR_HARD_REG_SET(reg_class_contents [AC16_BASE_REGS]);\n-\n-  gcc_assert (FIRST_PSEUDO_REGISTER >= 144);\n+    if (i < ILINK1_REG)\n+      {\n+\tif ((TARGET_Q_CLASS || TARGET_RRQ_CLASS)\n+\t    && ((i <= R3_REG) || ((i >= R12_REG) && (i <= R15_REG))))\n+\t  arc_regno_reg_class[i] = ARCOMPACT16_REGS;\n+\telse\n+\t  arc_regno_reg_class[i] = GENERAL_REGS;\n+      }\n+    else if (i < LP_COUNT)\n+      arc_regno_reg_class[i] = GENERAL_REGS;\n+    else\n+      arc_regno_reg_class[i] = NO_REGS;\n \n   /* Handle Special Registers.  */\n-  arc_regno_reg_class[29] = LINK_REGS; /* ilink1 register.  */\n-  if (!TARGET_V2)\n-    arc_regno_reg_class[30] = LINK_REGS; /* ilink2 register.  */\n-  arc_regno_reg_class[31] = LINK_REGS; /* blink register.  */\n-  arc_regno_reg_class[60] = LPCOUNT_REG;\n-  arc_regno_reg_class[61] = NO_REGS;      /* CC_REG: must be NO_REGS.  */\n+  arc_regno_reg_class[CC_REG] = NO_REGS;      /* CC_REG: must be NO_REGS.  */\n   arc_regno_reg_class[62] = GENERAL_REGS;\n \n   if (TARGET_DPFP)\n-    {\n-      for (i = 40; i < 44; ++i)\n-\t{\n-\t  arc_regno_reg_class[i] = DOUBLE_REGS;\n-\n-\t  /* Unless they want us to do 'mov d1, 0x00000000' make sure\n-\t     no attempt is made to use such a register as a destination\n-\t     operand in *movdf_insn.  */\n-\t  if (!TARGET_ARGONAUT_SET)\n-\t    {\n-\t    /* Make sure no 'c', 'w', 'W', or 'Rac' constraint is\n-\t       interpreted to mean they can use D1 or D2 in their insn.  */\n-\t    CLEAR_HARD_REG_BIT(reg_class_contents[CHEAP_CORE_REGS       ], i);\n-\t    CLEAR_HARD_REG_BIT(reg_class_contents[ALL_CORE_REGS         ], i);\n-\t    CLEAR_HARD_REG_BIT(reg_class_contents[WRITABLE_CORE_REGS    ], i);\n-\t    CLEAR_HARD_REG_BIT(reg_class_contents[MPY_WRITABLE_CORE_REGS], i);\n-\t    }\n-\t}\n-    }\n+    for (i = R40_REG; i < R44_REG; ++i)\n+      {\n+\tarc_regno_reg_class[i] = DOUBLE_REGS;\n+\tif (!TARGET_ARGONAUT_SET)\n+\t  CLEAR_HARD_REG_BIT (reg_class_contents[GENERAL_REGS], i);\n+      }\n   else\n     {\n-      /* Disable all DOUBLE_REGISTER settings,\n-\t if not generating DPFP code.  */\n-      arc_regno_reg_class[40] = ALL_REGS;\n-      arc_regno_reg_class[41] = ALL_REGS;\n-      arc_regno_reg_class[42] = ALL_REGS;\n-      arc_regno_reg_class[43] = ALL_REGS;\n+      /* Disable all DOUBLE_REGISTER settings, if not generating DPFP\n+\t code.  */\n+      arc_regno_reg_class[R40_REG] = ALL_REGS;\n+      arc_regno_reg_class[R41_REG] = ALL_REGS;\n+      arc_regno_reg_class[R42_REG] = ALL_REGS;\n+      arc_regno_reg_class[R43_REG] = ALL_REGS;\n \n-      fixed_regs[40] = 1;\n-      fixed_regs[41] = 1;\n-      fixed_regs[42] = 1;\n-      fixed_regs[43] = 1;\n+      fixed_regs[R40_REG] = 1;\n+      fixed_regs[R41_REG] = 1;\n+      fixed_regs[R42_REG] = 1;\n+      fixed_regs[R43_REG] = 1;\n \n-      arc_hard_regno_modes[40] = 0;\n-      arc_hard_regno_modes[42] = 0;\n-\n-      CLEAR_HARD_REG_SET(reg_class_contents [DOUBLE_REGS]);\n+      arc_hard_regno_modes[R40_REG] = 0;\n+      arc_hard_regno_modes[R42_REG] = 0;\n     }\n \n   if (TARGET_SIMD_SET)\n@@ -2007,23 +1926,15 @@ arc_conditional_register_usage (void)\n     }\n \n   /* pc : r63 */\n-  arc_regno_reg_class[PROGRAM_COUNTER_REGNO] = GENERAL_REGS;\n+  arc_regno_reg_class[PCL_REG] = NO_REGS;\n \n   /*ARCV2 Accumulator.  */\n   if ((TARGET_V2\n        && (TARGET_FP_DP_FUSED || TARGET_FP_SP_FUSED))\n       || TARGET_PLUS_DMPY)\n   {\n-    arc_regno_reg_class[ACCL_REGNO] = WRITABLE_CORE_REGS;\n-    arc_regno_reg_class[ACCH_REGNO] = WRITABLE_CORE_REGS;\n-    SET_HARD_REG_BIT (reg_class_contents[WRITABLE_CORE_REGS], ACCL_REGNO);\n-    SET_HARD_REG_BIT (reg_class_contents[WRITABLE_CORE_REGS], ACCH_REGNO);\n-    SET_HARD_REG_BIT (reg_class_contents[CHEAP_CORE_REGS], ACCL_REGNO);\n-    SET_HARD_REG_BIT (reg_class_contents[CHEAP_CORE_REGS], ACCH_REGNO);\n-    SET_HARD_REG_BIT (reg_class_contents[GENERAL_REGS], ACCL_REGNO);\n-    SET_HARD_REG_BIT (reg_class_contents[GENERAL_REGS], ACCH_REGNO);\n-    SET_HARD_REG_BIT (reg_class_contents[MPY_WRITABLE_CORE_REGS], ACCL_REGNO);\n-    SET_HARD_REG_BIT (reg_class_contents[MPY_WRITABLE_CORE_REGS], ACCH_REGNO);\n+    arc_regno_reg_class[ACCL_REGNO] = GENERAL_REGS;\n+    arc_regno_reg_class[ACCH_REGNO] = GENERAL_REGS;\n \n     /* Allow the compiler to freely use them.  */\n     if (!TEST_HARD_REG_BIT (overrideregs, ACCL_REGNO))\n@@ -7801,6 +7712,25 @@ hwloop_fail (hwloop_info loop)\n   delete_insn (loop->loop_end);\n }\n \n+/* Return the next insn after INSN that is not a NOTE, but stop the\n+   search before we enter another basic block.  This routine does not\n+   look inside SEQUENCEs.  */\n+\n+static rtx_insn *\n+next_nonnote_insn_bb (rtx_insn *insn)\n+{\n+  while (insn)\n+    {\n+      insn = NEXT_INSN (insn);\n+      if (insn == 0 || !NOTE_P (insn))\n+\tbreak;\n+      if (NOTE_INSN_BASIC_BLOCK_P (insn))\n+\treturn NULL;\n+    }\n+\n+  return insn;\n+}\n+\n /* Optimize LOOP.  */\n \n static bool\n@@ -7818,41 +7748,41 @@ hwloop_optimize (hwloop_info loop)\n   if (loop->depth > 1)\n     {\n       if (dump_file)\n-        fprintf (dump_file, \";; loop %d is not innermost\\n\",\n-                 loop->loop_no);\n+\tfprintf (dump_file, \";; loop %d is not innermost\\n\",\n+\t\t loop->loop_no);\n       return false;\n     }\n \n   if (!loop->incoming_dest)\n     {\n       if (dump_file)\n-        fprintf (dump_file, \";; loop %d has more than one entry\\n\",\n-                 loop->loop_no);\n+\tfprintf (dump_file, \";; loop %d has more than one entry\\n\",\n+\t\t loop->loop_no);\n       return false;\n     }\n \n   if (loop->incoming_dest != loop->head)\n     {\n       if (dump_file)\n-        fprintf (dump_file, \";; loop %d is not entered from head\\n\",\n-                 loop->loop_no);\n+\tfprintf (dump_file, \";; loop %d is not entered from head\\n\",\n+\t\t loop->loop_no);\n       return false;\n     }\n \n   if (loop->has_call || loop->has_asm)\n     {\n       if (dump_file)\n-        fprintf (dump_file, \";; loop %d has invalid insn\\n\",\n-                 loop->loop_no);\n+\tfprintf (dump_file, \";; loop %d has invalid insn\\n\",\n+\t\t loop->loop_no);\n       return false;\n     }\n \n   /* Scan all the blocks to make sure they don't use iter_reg.  */\n   if (loop->iter_reg_used || loop->iter_reg_used_outside)\n     {\n       if (dump_file)\n-        fprintf (dump_file, \";; loop %d uses iterator\\n\",\n-                 loop->loop_no);\n+\tfprintf (dump_file, \";; loop %d uses iterator\\n\",\n+\t\t loop->loop_no);\n       return false;\n     }\n \n@@ -7876,8 +7806,8 @@ hwloop_optimize (hwloop_info loop)\n   if (!insn)\n     {\n       if (dump_file)\n-        fprintf (dump_file, \";; loop %d start_label not before loop_end\\n\",\n-                 loop->loop_no);\n+\tfprintf (dump_file, \";; loop %d start_label not before loop_end\\n\",\n+\t\t loop->loop_no);\n       return false;\n     }\n \n@@ -7895,12 +7825,21 @@ hwloop_optimize (hwloop_info loop)\n       return false;\n     }\n \n-  /* Check if we use a register or not.  */\n+  /* Check if we use a register or not.\t */\n   if (!REG_P (loop->iter_reg))\n     {\n       if (dump_file)\n-        fprintf (dump_file, \";; loop %d iterator is MEM\\n\",\n-                 loop->loop_no);\n+\tfprintf (dump_file, \";; loop %d iterator is MEM\\n\",\n+\t\t loop->loop_no);\n+      return false;\n+    }\n+\n+  /* Check if we use a register or not.\t */\n+  if (!REG_P (loop->iter_reg))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \";; loop %d iterator is MEM\\n\",\n+\t\t loop->loop_no);\n       return false;\n     }\n \n@@ -7918,7 +7857,11 @@ hwloop_optimize (hwloop_info loop)\n \t  || (loop->incoming_src\n \t      && REGNO_REG_SET_P (df_get_live_out (loop->incoming_src),\n \t\t\t\t  LP_COUNT)))\n-\treturn false;\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \";; loop %d, lp_count is alive\", loop->loop_no);\n+\t  return false;\n+\t}\n       else\n \tneed_fix = true;\n     }\n@@ -8033,7 +7976,7 @@ hwloop_optimize (hwloop_info loop)\n     {\n       /* The loop uses a R-register, but the lp_count is free, thus\n \t use lp_count.  */\n-      emit_insn (gen_movsi (lp_reg, iter_reg));\n+      emit_insn (gen_rtx_SET (lp_reg, iter_reg));\n       SET_HARD_REG_BIT (loop->regs_set_in_loop, LP_COUNT);\n       iter_reg = lp_reg;\n       if (dump_file)\n@@ -8043,8 +7986,7 @@ hwloop_optimize (hwloop_info loop)\n \t}\n     }\n \n-  insn = emit_insn (gen_arc_lp (iter_reg,\n-\t\t\t\tloop->start_label,\n+  insn = emit_insn (gen_arc_lp (loop->start_label,\n \t\t\t\tloop->end_label));\n \n   seq = get_insns ();\n@@ -8062,30 +8004,32 @@ hwloop_optimize (hwloop_info loop)\n       seq = emit_label_before (gen_label_rtx (), seq);\n       new_bb = create_basic_block (seq, insn, entry_bb);\n       FOR_EACH_EDGE (e, ei, loop->incoming)\n-        {\n-          if (!(e->flags & EDGE_FALLTHRU))\n-            redirect_edge_and_branch_force (e, new_bb);\n-          else\n-            redirect_edge_succ (e, new_bb);\n-        }\n+\t{\n+\t  if (!(e->flags & EDGE_FALLTHRU))\n+\t    redirect_edge_and_branch_force (e, new_bb);\n+\t  else\n+\t    redirect_edge_succ (e, new_bb);\n+\t}\n \n       make_edge (new_bb, loop->head, 0);\n     }\n   else\n     {\n #if 0\n       while (DEBUG_INSN_P (entry_after)\n-             || (NOTE_P (entry_after)\n-\t\t && NOTE_KIND (entry_after) != NOTE_INSN_BASIC_BLOCK))\n+\t     || (NOTE_P (entry_after)\n+\t\t && NOTE_KIND (entry_after) != NOTE_INSN_BASIC_BLOCK\n+\t\t /* Make sure we don't split a call and its corresponding\n+\t\t    CALL_ARG_LOCATION note.  */\n+\t\t && NOTE_KIND (entry_after) != NOTE_INSN_CALL_ARG_LOCATION))\n         entry_after = NEXT_INSN (entry_after);\n #endif\n-      entry_after = next_nonnote_nondebug_insn_bb (entry_after);\n+      entry_after = next_nonnote_insn_bb (entry_after);\n \n       gcc_assert (entry_after);\n       emit_insn_before (seq, entry_after);\n     }\n \n-  delete_insn (loop->loop_end);\n   /* Insert the loop end label before the last instruction of the\n      loop.  */\n   emit_label_after (end_label, loop->last_insn);\n@@ -8737,26 +8681,6 @@ int\n arc_register_move_cost (machine_mode,\n \t\t\tenum reg_class from_class, enum reg_class to_class)\n {\n-  /* The ARC600 has no bypass for extension registers, hence a nop might be\n-     needed to be inserted after a write so that reads are safe.  */\n-  if (TARGET_ARC600)\n-    {\n-      if (to_class == MPY_WRITABLE_CORE_REGS)\n-\treturn 3;\n-     /* Instructions modifying LP_COUNT need 4 additional cycles before\n-\tthe register will actually contain the value.  */\n-      else if (to_class == LPCOUNT_REG)\n-\treturn 6;\n-      else if (to_class == WRITABLE_CORE_REGS)\n-\treturn 6;\n-    }\n-\n-  /* Using lp_count as scratch reg is a VERY bad idea.  */\n-  if (from_class == LPCOUNT_REG)\n-    return 1000;\n-  if (to_class == LPCOUNT_REG)\n-    return 6;\n-\n   /* Force an attempt to 'mov Dy,Dx' to spill.  */\n   if ((TARGET_ARC700 || TARGET_EM) && TARGET_DPFP\n       && from_class == DOUBLE_REGS && to_class == DOUBLE_REGS)\n@@ -9975,17 +9899,20 @@ split_subsi (rtx *operands)\n static bool\n arc_process_double_reg_moves (rtx *operands)\n {\n-  rtx dest = operands[0];\n-  rtx src  = operands[1];\n-\n   enum usesDxState { none, srcDx, destDx, maxDx };\n   enum usesDxState state = none;\n+  rtx dest = operands[0];\n+  rtx src  = operands[1];\n \n   if (refers_to_regno_p (40, 44, src, 0))\n-    state = srcDx;\n+    {\n+      state = srcDx;\n+      gcc_assert (REG_P (dest));\n+    }\n   if (refers_to_regno_p (40, 44, dest, 0))\n     {\n       /* Via arc_register_move_cost, we should never see D,D moves.  */\n+      gcc_assert (REG_P (src));\n       gcc_assert (state == none);\n       state = destDx;\n     }\n@@ -10337,11 +10264,11 @@ arc_return_address_register (unsigned int fn_type)\n   if (ARC_INTERRUPT_P (fn_type))\n     {\n       if ((fn_type & (ARC_FUNCTION_ILINK1 | ARC_FUNCTION_FIRQ)) != 0)\n-        regno = ILINK1_REGNUM;\n+\tregno = ILINK1_REG;\n       else if ((fn_type & ARC_FUNCTION_ILINK2) != 0)\n-        regno = ILINK2_REGNUM;\n+\tregno = ILINK2_REG;\n       else\n-        gcc_unreachable ();\n+\tgcc_unreachable ();\n     }\n   else if (ARC_NORMAL_P (fn_type) || ARC_NAKED_P (fn_type))\n     regno = RETURN_ADDR_REGNUM;\n@@ -10392,14 +10319,12 @@ arc_eh_uses (int regno)\n   return false;\n }\n \n-#ifndef TARGET_NO_LRA\n-#define TARGET_NO_LRA !TARGET_LRA\n-#endif\n+/* Return true if we use LRA instead of reload pass.  */\n \n-static bool\n+bool\n arc_lra_p (void)\n {\n-  return !TARGET_NO_LRA;\n+  return arc_lra_flag;\n }\n \n /* ??? Should we define TARGET_REGISTER_PRIORITY?  We might perfer to use\n@@ -11338,7 +11263,7 @@ operands_ok_ldd_std (rtx rt, rtx rt2, HOST_WIDE_INT offset)\n   t = REGNO (rt);\n   t2 = REGNO (rt2);\n \n-  if ((t2 == PROGRAM_COUNTER_REGNO)\n+  if ((t2 == PCL_REG)\n       || (t % 2 != 0)\t/* First destination register is not even.  */\n       || (t2 != t + 1))\n       return false;"}, {"sha": "4d01c99a540ecd6c851145045483e615fb3b64cb", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 36, "deletions": 69, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73dac59b57ad6af6a369f5005c979a20a2ad2954/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73dac59b57ad6af6a369f5005c979a20a2ad2954/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=73dac59b57ad6af6a369f5005c979a20a2ad2954", "patch": "@@ -312,8 +312,6 @@ if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n #undef WCHAR_TYPE_SIZE\n #define WCHAR_TYPE_SIZE 32\n \n-#define PROGRAM_COUNTER_REGNO 63\n-\n /* Standard register usage.  */\n \n /* Number of actual hardware registers.\n@@ -373,7 +371,7 @@ if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n   1, 1, 1, 1, 1, 1, 1, 1,\t\\\n   0, 0, 0, 0, 1, 1, 1, 1,\t\\\n   1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-  1, 1, 1, 1, 0, 1, 1, 1,       \\\n+  1, 1, 1, 1, 1, 1, 1, 1,       \\\n \t\t\t\t\\\n   0, 0, 0, 0, 0, 0, 0, 0,       \\\n   0, 0, 0, 0, 0, 0, 0, 0,       \\\n@@ -470,25 +468,15 @@ enum reg_class\n {\n    NO_REGS,\n    R0_REGS,\t\t\t/* 'x' */\n-   GP_REG,\t\t\t/* 'Rgp' */\n-   FP_REG,\t\t\t/* 'f' */\n-   SP_REGS,\t\t\t/* 'b' */\n-   LPCOUNT_REG, \t\t/* 'l' */\n-   LINK_REGS,\t \t\t/* 'k' */\n-   DOUBLE_REGS,\t\t\t/* D0, D1 */\n-   SIMD_VR_REGS,\t\t/* VR00-VR63 */\n-   SIMD_DMA_CONFIG_REGS,\t/* DI0-DI7,DO0-DO7 */\n+   R0R1_CD_REGS,\t\t/* 'Rsd' */\n+   R0R3_CD_REGS,\t\t/* 'Rcd' */\n    ARCOMPACT16_REGS,\t\t/* 'q' */\n-   AC16_BASE_REGS,  \t\t/* 'e' */\n    SIBCALL_REGS,\t\t/* \"Rsc\" */\n-   GENERAL_REGS,\t\t/* 'r' */\n-   MPY_WRITABLE_CORE_REGS,\t/* 'W' */\n-   WRITABLE_CORE_REGS,\t\t/* 'w' */\n-   CHEAP_CORE_REGS,\t\t/* 'c' */\n-   ALL_CORE_REGS,\t\t/* 'Rac' */\n-   R0R3_CD_REGS,\t\t/* 'Rcd' */\n-   R0R1_CD_REGS,\t\t/* 'Rsd' */\n    AC16_H_REGS,\t\t\t/* 'h' */\n+   DOUBLE_REGS,\t\t\t/* 'D' */\n+   GENERAL_REGS,\t\t/* 'r' */\n+   SIMD_VR_REGS,\t\t/* 'v' */\n+   SIMD_DMA_CONFIG_REGS,\t/* 'd' */\n    ALL_REGS,\n    LIM_REG_CLASSES\n };\n@@ -497,63 +485,38 @@ enum reg_class\n \n /* Give names of register classes as strings for dump file.   */\n #define REG_CLASS_NAMES\t  \\\n-{                         \\\n-  \"NO_REGS\",           \t  \\\n-  \"R0_REGS\",            \t  \\\n-  \"GP_REG\",            \t  \\\n-  \"FP_REG\",            \t  \\\n-  \"SP_REGS\",\t\t  \\\n-  \"LPCOUNT_REG\",\t  \\\n-  \"LINK_REGS\",         \t  \\\n-  \"DOUBLE_REGS\",          \\\n-  \"SIMD_VR_REGS\",         \\\n+{\t\t\t  \\\n+  \"NO_REGS\",\t\t  \\\n+  \"R0_REGS\",\t\t  \\\n+  \"R0R1_CD_REGS\",\t  \\\n+  \"R0R3_CD_REGS\",\t  \\\n+  \"ARCOMPACT16_REGS\",\t  \\\n+  \"AC16_H_REGS\",\t  \\\n+  \"DOUBLE_REGS\",\t  \\\n+  \"GENERAL_REGS\",\t  \\\n+  \"SIMD_VR_REGS\",\t  \\\n   \"SIMD_DMA_CONFIG_REGS\", \\\n-  \"ARCOMPACT16_REGS\",  \t  \\\n-  \"AC16_BASE_REGS\",       \\\n-  \"SIBCALL_REGS\",\t  \\\n-  \"GENERAL_REGS\",      \t  \\\n-  \"MPY_WRITABLE_CORE_REGS\",   \\\n-  \"WRITABLE_CORE_REGS\",   \\\n-  \"CHEAP_CORE_REGS\",\t  \\\n-  \"R0R3_CD_REGS\", \\\n-  \"R0R1_CD_REGS\", \\\n-  \"AC16_H_REGS\",\t    \\\n-  \"ALL_CORE_REGS\",\t  \\\n-  \"ALL_REGS\"          \t  \\\n+  \"ALL_REGS\"\t\t  \\\n }\n \n /* Define which registers fit in which classes.\n    This is an initializer for a vector of HARD_REG_SET\n    of length N_REG_CLASSES.  */\n \n #define REG_CLASS_CONTENTS \\\n-{\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n-  {0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},\t     /* No Registers */\t\t\t\\\n-  {0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000},      /* 'x', r0 register , r0 */\t\\\n-  {0x04000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},      /* 'Rgp', Global Pointer, r26 */\t\\\n-  {0x08000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},      /* 'f', Frame Pointer, r27 */\t\\\n-  {0x10000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},      /* 'b', Stack Pointer, r28 */\t\\\n-  {0x00000000, 0x10000000, 0x00000000, 0x00000000, 0x00000000},      /* 'l', LPCOUNT Register, r60 */\t\\\n-  {0xe0000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},      /* 'k', LINK Registers, r29-r31 */\t\\\n-  {0x00000000, 0x00000f00, 0x00000000, 0x00000000, 0x00000000},      /* 'D', D1, D2 Registers */\t\\\n-  {0x00000000, 0x00000000, 0xffffffff, 0xffffffff, 0x00000000},      /* 'V', VR00-VR63 Registers */\t\\\n-  {0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0000ffff},      /* 'V', DI0-7,DO0-7 Registers */\t\\\n-  {0x0000f00f, 0x00000000, 0x00000000, 0x00000000, 0x00000000},\t     /* 'q', r0-r3, r12-r15 */\t\t\\\n-  {0x1000f00f, 0x00000000, 0x00000000, 0x00000000, 0x00000000},\t     /* 'e', r0-r3, r12-r15, sp */\t\\\n-  {0x1c001fff, 0x00000000, 0x00000000, 0x00000000, 0x00000000},    /* \"Rsc\", r0-r12 */ \\\n-  {0x9fffffff, 0x80000000, 0x00000000, 0x00000000, 0x00000000},      /* 'r', r0-r28, blink, ap and pcl */\t\\\n-  {0xffffffff, 0x00000000, 0x00000000, 0x00000000, 0x00000000},      /* 'W',  r0-r31 */ \\\n-  /* Include ap / pcl in WRITABLE_CORE_REGS for sake of symmetry.  As these \\\n-     registers are fixed, it does not affect the literal meaning of the \\\n-     constraints, but it makes it a superset of GENERAL_REGS, thus \\\n-     enabling some operations that would otherwise not be possible.  */ \\\n-  {0xffffffff, 0x00000000, 0x00000000, 0x00000000, 0x00000000},      /* 'w', r0-r31, r60 */ \\\n-  {0xffffffff, 0x9fffffff, 0x00000000, 0x00000000, 0x00000000},      /* 'c', r0-r60, ap, pcl */ \\\n-  {0xffffffff, 0x9fffffff, 0x00000000, 0x00000000, 0x00000000},      /* 'Rac', r0-r60, ap, pcl */ \\\n-  {0x0000000f, 0x00000000, 0x00000000, 0x00000000, 0x00000000},      /* 'Rcd', r0-r3 */ \\\n-  {0x00000003, 0x00000000, 0x00000000, 0x00000000, 0x00000000},      /* 'Rsd', r0-r1 */ \\\n-  {0x9fffffff, 0x00000000, 0x00000000, 0x00000000, 0x00000000},      /* 'h',  r0-28, r30 */ \\\n-  {0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x0003ffff}       /* All Registers */\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  {0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000}, /* NO_REGS.  */\\\n+  {0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000}, /* 'x'.  */ \\\n+  {0x00000003, 0x00000000, 0x00000000, 0x00000000, 0x00000000}, /* 'Rsd'.  */ \\\n+  {0x0000000f, 0x00000000, 0x00000000, 0x00000000, 0x00000000}, /* 'Rcd'.  */ \\\n+  {0x0000f00f, 0x00000000, 0x00000000, 0x00000000, 0x00000000}, /* 'q'.  */ \\\n+  {0x1c001fff, 0x00000000, 0x00000000, 0x00000000, 0x00000000}, /* 'Rsc'.  */ \\\n+  {0x9fffffff, 0x00000000, 0x00000000, 0x00000000, 0x00000000}, /* 'h'.  */ \\\n+  {0x00000000, 0x00000f00, 0x00000000, 0x00000000, 0x00000000}, /* 'D'.  */ \\\n+  {0xffffffff, 0x8fffffff, 0x00000000, 0x00000000, 0x00000000}, /* 'r'.  */ \\\n+  {0x00000000, 0x00000000, 0xffffffff, 0xffffffff, 0x00000000}, /* 'v'.  */ \\\n+  {0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0000ffff}, /* 'd'.  */ \\\n+  {0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x0003ffff} /* ALL_REGS.  */\\\n }\n \n /* Local macros to mark the first and last regs of different classes.  */\n@@ -590,7 +553,7 @@ extern enum reg_class arc_regno_reg_class[];\n /* The class value for valid base registers. A base register is one used in\n    an address which is the register value plus a displacement.  */\n \n-#define BASE_REG_CLASS (TARGET_MIXED_CODE ? AC16_BASE_REGS : GENERAL_REGS)\n+#define BASE_REG_CLASS GENERAL_REGS\n \n /* These assume that REGNO is a hard or pseudo reg number.\n    They give nonzero only if REGNO is a hard reg of the suitable class\n@@ -1650,4 +1613,8 @@ enum\n /* The default option for BI/BIH instructions.  */\n #define DEFAULT_BRANCH_INDEX 0\n \n+#ifndef TARGET_LRA\n+#define TARGET_LRA arc_lra_p()\n+#endif\n+\n #endif /* GCC_ARC_H */"}, {"sha": "f9958b72c6af998a210dea19259381978505883b", "filename": "gcc/config/arc/arc.md", "status": "modified", "additions": 38, "deletions": 19, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73dac59b57ad6af6a369f5005c979a20a2ad2954/gcc%2Fconfig%2Farc%2Farc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73dac59b57ad6af6a369f5005c979a20a2ad2954/gcc%2Fconfig%2Farc%2Farc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.md?ref=73dac59b57ad6af6a369f5005c979a20a2ad2954", "patch": "@@ -171,18 +171,37 @@\n    (R1_REG 1)\n    (R2_REG 2)\n    (R3_REG 3)\n+   (R4_REG 4)\n+\n+   (R9_REG 9)\n    (R10_REG 10)\n+\n    (R12_REG 12)\n+\n+   (R15_REG 15)\n+   (R16_REG 16)\n+\n+   (R25_REG 25)\n    (SP_REG 28)\n-   (ILINK1_REGNUM 29)\n-   (ILINK2_REGNUM 30)\n+   (ILINK1_REG 29)\n+   (ILINK2_REG 30)\n+   (R30_REG 30)\n    (RETURN_ADDR_REGNUM 31)\n+   (R32_REG 32)\n+   (R40_REG 40)\n+   (R41_REG 41)\n+   (R42_REG 42)\n+   (R43_REG 43)\n+   (R44_REG 44)\n+   (R57_REG 57)\n    (MUL64_OUT_REG 58)\n    (MUL32x16_REG 56)\n    (ARCV2_ACC 58)\n+   (R59_REG 59)\n \n    (LP_COUNT 60)\n    (CC_REG 61)\n+   (PCL_REG 63)\n    (LP_START 144)\n    (LP_END 145)\n   ]\n@@ -652,8 +671,8 @@ core_3, archs4x, archs4xd, archs4xd_slow\"\n ; The iscompact attribute allows the epilogue expander to know for which\n ; insns it should lengthen the return insn.\n (define_insn \"*movqi_insn\"\n-  [(set (match_operand:QI 0 \"move_dest_operand\" \"=Rcq,Rcq#q,    w,Rcq#q,   h,w*l,w*l,???w,h,w*l,Rcq,  S,!*x,  r,r, Ucm,m,???m,  m,Usc\")\n-\t(match_operand:QI 1 \"move_src_operand\"  \"  cL,   cP,Rcq#q,    P,hCm1, cL,  I,?Rac,i, ?i,  T,Rcq,Usd,Ucm,m,?Rac,c,?Rac,Cm3,i\"))]\n+  [(set (match_operand:QI 0 \"move_dest_operand\" \"=Rcq,Rcq#q,    w,Rcq#q,   h, w, w,???w,h, w,Rcq,  S,!*x,  r,r, Ucm,m,???m,  m,Usc\")\n+\t(match_operand:QI 1 \"move_src_operand\"  \"  cL,   cP,Rcq#q,    P,hCm1,cL, I,?Rac,i,?i,  T,Rcq,Usd,Ucm,m,?Rac,c,?Rac,Cm3,i\"))]\n   \"register_operand (operands[0], QImode)\n    || register_operand (operands[1], QImode)\"\n   \"@\n@@ -689,8 +708,8 @@ core_3, archs4x, archs4xd, archs4xd_slow\"\n   \"if (prepare_move_operands (operands, HImode)) DONE;\")\n \n (define_insn \"*movhi_insn\"\n-  [(set (match_operand:HI 0 \"move_dest_operand\" \"=Rcq,Rcq#q,    w,Rcq#q,   h,w*l,w*l,???w,Rcq#q,h,w*l,Rcq,  S,  r,r, Ucm,m,???m,  m,VUsc\")\n-\t(match_operand:HI 1 \"move_src_operand\" \"   cL,   cP,Rcq#q,    P,hCm1, cL,  I,?Rac,    i,i, ?i,  T,Rcq,Ucm,m,?Rac,c,?Rac,Cm3,i\"))]\n+  [(set (match_operand:HI 0 \"move_dest_operand\" \"=Rcq,Rcq#q,    w,Rcq#q,   h, w, w,???w,Rcq#q,h, w,Rcq,  S,  r,r, Ucm,m,???m,  m,VUsc\")\n+\t(match_operand:HI 1 \"move_src_operand\" \"   cL,   cP,Rcq#q,    P,hCm1,cL, I,?Rac,    i,i,?i,  T,Rcq,Ucm,m,?Rac,c,?Rac,Cm3,i\"))]\n   \"register_operand (operands[0], HImode)\n    || register_operand (operands[1], HImode)\n    || (CONSTANT_P (operands[1])\n@@ -740,9 +759,9 @@ core_3, archs4x, archs4xd, archs4xd_slow\"\n ; the iscompact attribute allows the epilogue expander to know for which\n ; insns it should lengthen the return insn.\n ; N.B. operand 1 of alternative 7 expands into pcl,symbol@gotpc .\n-(define_insn \"*movsi_insn\"                      ;   0     1     2     3    4  5    6   7   8   9   10    11  12  13    14  15   16  17  18     19     20  21  22    23    24 25 26    27 28  29  30   31\n-  [(set (match_operand:SI 0 \"move_dest_operand\" \"=Rcq,Rcq#q,    w,Rcq#q,   h,w*l,w*l,  w,  w,  w,  w,  ???w, ?w,  w,Rcq#q,  h, w*l,Rcq,  S,   Us<,RcqRck,!*x,  r,!*Rsd,!*Rcd,r,Ucm,  Usd,m,???m,  m,VUsc\")\n-\t(match_operand:SI 1 \"move_src_operand\"  \"  cL,   cP,Rcq#q,    P,hCm1, cL,  I,Crr,Clo,Chi,Cbi,?Rac*l,Cpc,Clb, ?Cal,Cal,?Cal,Uts,Rcq,RcqRck,   Us>,Usd,Ucm,  Usd,  Ucd,m,  w,!*Rzd,c,?Rac,Cm3, C32\"))]\n+(define_insn \"*movsi_insn\"\t\t\t;   0     1     2     3    4  5  6   7   8   9   10  11  12  13    14  15   16  17  18     19     20  21  22    23    24 25 26    27 28  29  30   31\n+  [(set (match_operand:SI 0 \"move_dest_operand\" \"=Rcq,Rcq#q,    w,Rcq#q,   h,wl, w,  w,  w,  w,  w,???w, ?w,  w,Rcq#q,  h,  wl,Rcq,  S,   Us<,RcqRck,!*x,  r,!*Rsd,!*Rcd,r,Ucm,  Usd,m,???m,  m,VUsc\")\n+\t(match_operand:SI 1 \"move_src_operand\"  \"  cL,   cP,Rcq#q,    P,hCm1,cL, I,Crr,Clo,Chi,Cbi,?Rac,Cpc,Clb, ?Cal,Cal,?Cal,Uts,Rcq,RcqRck,   Us>,Usd,Ucm,  Usd,  Ucd,m,  w,!*Rzd,c,?Rac,Cm3, C32\"))]\n   \"register_operand (operands[0], SImode)\n    || register_operand (operands[1], SImode)\n    || (CONSTANT_P (operands[1])\n@@ -5002,29 +5021,29 @@ core_3, archs4x, archs4xd, archs4xd_slow\"\n })\n \n (define_insn \"arc_lp\"\n-  [(unspec:SI [(match_operand:SI 0 \"register_operand\" \"l\")]\n+  [(unspec:SI [(reg:SI LP_COUNT)]\n \t      UNSPEC_ARC_LP)\n-   (use (label_ref (match_operand 1 \"\" \"\")))\n-   (use (label_ref (match_operand 2 \"\" \"\")))]\n+   (use (label_ref (match_operand 0 \"\" \"\")))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n   \"\"\n-  \"lp\\\\t@%l2\\\\t; %0:@%l1->@%l2\"\n+  \"lp\\\\t@%l1\\\\t; lp_count:@%l0->@%l1\"\n   [(set_attr \"type\" \"loop_setup\")\n    (set_attr \"length\" \"4\")])\n \n ;; if by any chance the lp_count is not used, then use an 'r'\n ;; register, instead of going to memory.\n (define_insn \"loop_end\"\n   [(set (pc)\n-\t(if_then_else (ne (match_operand:SI 2 \"nonimmediate_operand\" \"0,0\")\n+\t(if_then_else (ne (match_operand:SI 2 \"nonimmediate_operand\" \"0,m\")\n \t\t\t  (const_int 1))\n \t\t      (label_ref (match_operand 1 \"\" \"\"))\n \t\t      (pc)))\n-   (set (match_operand:SI 0 \"nonimmediate_operand\" \"=l!r,m\")\n+   (set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,m\")\n \t(plus (match_dup 2) (const_int -1)))\n    (unspec [(const_int 0)] UNSPEC_ARC_LP)\n    (clobber (match_scratch:SI 3 \"=X,&r\"))]\n   \"\"\n-  \"\\\\t;%0 %1 %2\"\n+  \"; ZOL_END, begins @%l1\"\n   [(set_attr \"length\" \"0\")\n    (set_attr \"predicable\" \"no\")\n    (set_attr \"type\" \"loop_end\")])\n@@ -5069,7 +5088,7 @@ core_3, archs4x, archs4xd, archs4xd_slow\"\n (define_insn_and_split \"dbnz\"\n   [(set (pc)\n \t(if_then_else\n-\t (ne (plus:SI (match_operand:SI 0 \"nonimmediate_operand\" \"+r!l,m\")\n+\t (ne (plus:SI (match_operand:SI 0 \"nonimmediate_operand\" \"+rl,m\")\n \t\t      (const_int -1))\n \t     (const_int 0))\n \t (label_ref (match_operand 1 \"\" \"\"))\n@@ -6283,8 +6302,8 @@ core_3, archs4x, archs4xd, archs4xd_slow\"\n \n (define_insn \"stack_tie\"\n   [(set (mem:BLK (scratch))\n-\t(unspec:BLK [(match_operand:SI 0 \"register_operand\" \"rb\")\n-\t\t     (match_operand:SI 1 \"register_operand\" \"rb\")]\n+\t(unspec:BLK [(match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t     (match_operand:SI 1 \"register_operand\" \"r\")]\n \t\t    UNSPEC_ARC_STKTIE))]\n   \"\"\n   \"\""}, {"sha": "af9e2d16ca0131d1f906cfeaf154507d49b49e45", "filename": "gcc/config/arc/arc.opt", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73dac59b57ad6af6a369f5005c979a20a2ad2954/gcc%2Fconfig%2Farc%2Farc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73dac59b57ad6af6a369f5005c979a20a2ad2954/gcc%2Fconfig%2Farc%2Farc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.opt?ref=73dac59b57ad6af6a369f5005c979a20a2ad2954", "patch": "@@ -401,12 +401,9 @@ Target\n Pass -marclinux_prof option through to linker.\n \n ;; lra is still unproven for ARC, so allow to fall back to reload with -mno-lra.\n-;Target InverseMask(NO_LRA)\n-; lra still won't allow to configure libgcc; see PR rtl-optimization/55464.\n-; so don't enable by default.\n mlra\n-Target Mask(LRA)\n-Enable lra.\n+Target Report Var(arc_lra_flag) Init(1) Save\n+Use LRA instead of reload.\n \n mlra-priority-none\n Target RejectNegative Var(arc_lra_priority_tag, ARC_LRA_PRIORITY_NONE)"}, {"sha": "64e43325cfdf0c36ba28a35a116953c24e17a37a", "filename": "gcc/config/arc/constraints.md", "status": "modified", "additions": 15, "deletions": 32, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73dac59b57ad6af6a369f5005c979a20a2ad2954/gcc%2Fconfig%2Farc%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73dac59b57ad6af6a369f5005c979a20a2ad2954/gcc%2Fconfig%2Farc%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Fconstraints.md?ref=73dac59b57ad6af6a369f5005c979a20a2ad2954", "patch": "@@ -24,48 +24,35 @@\n ; result registers of ARC600.\n ; First, define a class for core registers that can be read cheaply.  This\n ; is most or all core registers for ARC600, but only r0-r31 for ARC700\n-(define_register_constraint \"c\" \"CHEAP_CORE_REGS\"\n-  \"core register @code{r0}-@code{r31}, @code{ap},@code{pcl}\")\n+(define_register_constraint \"c\" \"GENERAL_REGS\"\n+  \"Legacy, core register @code{r0}-@code{r31}, @code{ap},@code{pcl}\")\n \n ; All core regs - e.g. for when we must have a way to reload a register.\n-(define_register_constraint \"Rac\" \"ALL_CORE_REGS\"\n-  \"core register @code{r0}-@code{r60}, @code{ap},@code{pcl}\")\n+(define_register_constraint \"Rac\" \"GENERAL_REGS\"\n+  \"Legacy, core register @code{r0}-@code{r60}, @code{ap},@code{pcl}\")\n \n ; Some core registers (.e.g lp_count) aren't general registers because they\n ; can't be used as the destination of a multi-cycle operation like\n ; load and/or multiply, yet they are still writable in the sense that\n ; register-register moves and single-cycle arithmetic (e.g \"add\", \"and\",\n ; but not \"mpy\") can write to them.\n-(define_register_constraint \"w\" \"WRITABLE_CORE_REGS\"\n-  \"writable core register: @code{r0}-@code{r31}, @code{r60}, nonfixed core register\")\n+(define_register_constraint \"w\" \"GENERAL_REGS\"\n+  \"Legacy, writable core register: @code{r0}-@code{r31}, @code{r60},\n+   nonfixed core register\")\n \n-(define_register_constraint \"W\" \"MPY_WRITABLE_CORE_REGS\"\n-  \"writable core register except @code{LP_COUNT} (@code{r60}): @code{r0}-@code{r31}, nonfixed core register\")\n+(define_register_constraint \"W\" \"GENERAL_REGS\"\n+  \"Legacy, writable core register except @code{LP_COUNT} (@code{r60}):\n+   @code{r0}-@code{r31}, nonfixed core register\")\n \n-(define_register_constraint \"l\" \"LPCOUNT_REG\"\n+(define_constraint \"l\"\n   \"@internal\n-   Loop count register @code{r60}\")\n+   Loop count register @code{r60}\"\n+  (and (match_code \"reg\")\n+       (match_test \"REGNO (op) == LP_COUNT\")))\n \n (define_register_constraint \"x\" \"R0_REGS\"\n   \"@code{R0} register.\")\n \n-(define_register_constraint \"Rgp\" \"GP_REG\"\n-  \"@internal\n-   Global Pointer register @code{r26}\")\n-\n-(define_register_constraint \"f\" \"FP_REG\"\n-  \"@internal\n-   Frame Pointer register @code{r27}\")\n-\n-(define_register_constraint \"b\" \"SP_REGS\"\n-  \"@internal\n-   Stack Pointer register @code{r28}\")\n-\n-(define_register_constraint \"k\" \"LINK_REGS\"\n-  \"@internal\n-   Link Registers @code{ilink1}:@code{r29}, @code{ilink2}:@code{r30},\n-   @code{blink}:@code{r31},\")\n-\n (define_register_constraint \"q\" \"TARGET_Q_CLASS ? ARCOMPACT16_REGS : NO_REGS\"\n   \"Registers usable in ARCompact 16-bit instructions: @code{r0}-@code{r3},\n    @code{r12}-@code{r15}\")\n@@ -78,10 +65,6 @@\n   \"Registers usable in NPS400 bitfield instructions: @code{r0}-@code{r3},\n    @code{r12}-@code{r15}\")\n \n-(define_register_constraint \"e\" \"AC16_BASE_REGS\"\n-  \"Registers usable as base-regs of memory addresses in ARCompact 16-bit memory\n-   instructions: @code{r0}-@code{r3}, @code{r12}-@code{r15}, @code{sp}\")\n-\n (define_register_constraint \"D\" \"DOUBLE_REGS\"\n   \"ARC FPX (dpfp) 64-bit registers. @code{D0}, @code{D1}\")\n \n@@ -472,7 +455,7 @@\n        (match_test\n \t\"TARGET_Rcw\n \t && REGNO (op) < FIRST_PSEUDO_REGISTER\n-\t && TEST_HARD_REG_BIT (reg_class_contents[WRITABLE_CORE_REGS],\n+\t && TEST_HARD_REG_BIT (reg_class_contents[GENERAL_REGS],\n \t\t\t       REGNO (op))\")))\n \n (define_constraint \"Rcr\""}, {"sha": "c4be56f766e3a368f04240d7c95cda0a5fa53e5b", "filename": "gcc/config/arc/predicates.md", "status": "modified", "additions": 4, "deletions": 24, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73dac59b57ad6af6a369f5005c979a20a2ad2954/gcc%2Fconfig%2Farc%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73dac59b57ad6af6a369f5005c979a20a2ad2954/gcc%2Fconfig%2Farc%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Fpredicates.md?ref=73dac59b57ad6af6a369f5005c979a20a2ad2954", "patch": "@@ -20,33 +20,12 @@\n (define_predicate \"dest_reg_operand\"\n   (match_code \"reg,subreg\")\n {\n-  rtx op0 = op;\n-\n-  if (GET_CODE (op0) == SUBREG)\n-    op0 = SUBREG_REG (op0);\n-  if (REG_P (op0) && REGNO (op0) < FIRST_PSEUDO_REGISTER\n-      && TEST_HARD_REG_BIT (reg_class_contents[ALL_CORE_REGS],\n-\t\t\t    REGNO (op0))\n-      && !TEST_HARD_REG_BIT (reg_class_contents[WRITABLE_CORE_REGS],\n-\t\t\t    REGNO (op0)))\n-    return 0;\n   return register_operand (op, mode);\n })\n \n (define_predicate \"mpy_dest_reg_operand\"\n   (match_code \"reg,subreg\")\n {\n-  rtx op0 = op;\n-\n-  if (GET_CODE (op0) == SUBREG)\n-    op0 = SUBREG_REG (op0);\n-  if (REG_P (op0) && REGNO (op0) < FIRST_PSEUDO_REGISTER\n-      && TEST_HARD_REG_BIT (reg_class_contents[ALL_CORE_REGS],\n-\t\t\t    REGNO (op0))\n-      /* Make sure the destination register is not LP_COUNT.  */\n-      && !TEST_HARD_REG_BIT (reg_class_contents[MPY_WRITABLE_CORE_REGS],\n-\t\t\t    REGNO (op0)))\n-    return 0;\n   return register_operand (op, mode);\n })\n \n@@ -358,13 +337,14 @@\n     case REG :\n      /* Program Counter register cannot be the target of a move.  It is\n \t a readonly register.  */\n-      if (REGNO (op) == PROGRAM_COUNTER_REGNO)\n+      if (REGNO (op) == PCL_REG)\n \treturn 0;\n       else if (TARGET_MULMAC_32BY16_SET\n-\t       && (REGNO (op) == 56 || REGNO(op) == 57))\n+\t       && (REGNO (op) == MUL32x16_REG || REGNO (op) == R57_REG))\n \treturn 0;\n       else if (TARGET_MUL64_SET\n-\t       && (REGNO (op) == 57 || REGNO(op) == 58 || REGNO(op) == 59 ))\n+\t       && (REGNO (op) == R57_REG || REGNO (op) == MUL64_OUT_REG\n+\t\t   || REGNO (op) == R59_REG))\n \treturn 0;\n       else if (REGNO (op) == LP_COUNT)\n         return 1;"}]}