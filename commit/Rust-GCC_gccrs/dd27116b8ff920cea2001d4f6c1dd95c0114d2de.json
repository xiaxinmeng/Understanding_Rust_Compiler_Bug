{"sha": "dd27116b8ff920cea2001d4f6c1dd95c0114d2de", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGQyNzExNmI4ZmY5MjBjZWEyMDAxZDRmNmMxZGQ5NWMwMTE0ZDJkZQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-06-23T11:50:02Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-06-23T11:50:02Z"}, "message": "(expand_expr): Set IGNORE if target is const0_rtx or result type is VOID.\n\nMove most IGNORE processing to one place to avoid expanding things that don't\nneed to be expanded.\n(expand_expr, case CONSTRUCTOR, case COND_EXPR): If IGNORE, don't expand\nanything we don't have to.\n(expand_expr, case CONVERT_EXPR): Don't deal with IGNORE here.\n\nFrom-SVN: r4714", "tree": {"sha": "4739d013e36308b447cabb045ce387fa812ac9b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4739d013e36308b447cabb045ce387fa812ac9b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dd27116b8ff920cea2001d4f6c1dd95c0114d2de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd27116b8ff920cea2001d4f6c1dd95c0114d2de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd27116b8ff920cea2001d4f6c1dd95c0114d2de", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd27116b8ff920cea2001d4f6c1dd95c0114d2de/comments", "author": null, "committer": null, "parents": [{"sha": "bd5f197aa10b21fee7b8ca995481e1b9a15b196a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd5f197aa10b21fee7b8ca995481e1b9a15b196a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd5f197aa10b21fee7b8ca995481e1b9a15b196a"}], "stats": {"total": 103, "additions": 69, "deletions": 34}, "files": [{"sha": "ae65e7da5136c91a68cd2be4949881b521626e2d", "filename": "gcc/expr.c", "status": "modified", "additions": 69, "deletions": 34, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd27116b8ff920cea2001d4f6c1dd95c0114d2de/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd27116b8ff920cea2001d4f6c1dd95c0114d2de/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=dd27116b8ff920cea2001d4f6c1dd95c0114d2de", "patch": "@@ -3263,7 +3263,10 @@ expand_expr (exp, target, tmode, modifier)\n   /* Use subtarget as the target for operand 0 of a binary operation.  */\n   rtx subtarget = (target != 0 && GET_CODE (target) == REG ? target : 0);\n   rtx original_target = target;\n-  int ignore = target == const0_rtx;\n+  int ignore = (target == const0_rtx\n+\t\t|| ((code == NON_LVALUE_EXPR || code == NOP_EXPR\n+\t\t     || code == CONVERT_EXPR || code == REFERENCE_EXPR)\n+\t\t    && TREE_CODE (type) == VOID_TYPE));\n   tree context;\n \n   /* Don't use hard regs as subtargets, because the combiner\n@@ -3275,29 +3278,54 @@ expand_expr (exp, target, tmode, modifier)\n   if (preserve_subexpressions_p ())\n     subtarget = 0;\n \n-  if (ignore) target = 0, original_target = 0;\n+  /* If we are going to ignore this result, we need only do something\n+     if there is a side-effect somewhere in the expression.  If there\n+     is, short-circuit the most common cases here.  */\n \n-  /* If will do cse, generate all results into pseudo registers\n-     since 1) that allows cse to find more things\n-     and 2) otherwise cse could produce an insn the machine\n-     cannot support.  */\n+  if (ignore)\n+    {\n+      if (! TREE_SIDE_EFFECTS (exp))\n+\treturn const0_rtx;\n+\n+      /* Ensure we reference a volatile object even if value is ignored.  */\n+      if (TREE_THIS_VOLATILE (exp)\n+\t  && TREE_CODE (exp) != FUNCTION_DECL\n+\t  && mode != VOIDmode && mode != BLKmode)\n+\t{\n+\t  temp = expand_expr (exp, NULL_RTX, VOIDmode, modifier);\n+\t  if (GET_CODE (temp) == MEM)\n+\t    temp = copy_to_reg (temp);\n+\t  return const0_rtx;\n+\t}\n+\n+      if (TREE_CODE_CLASS (code) == '1')\n+\treturn expand_expr (TREE_OPERAND (exp, 0), const0_rtx,\n+\t\t\t    VOIDmode, modifier);\n+      else if (TREE_CODE_CLASS (code) == '2'\n+\t       || TREE_CODE_CLASS (code) == '<')\n+\t{\n+\t  expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode, modifier);\n+\t  expand_expr (TREE_OPERAND (exp, 1), const0_rtx, VOIDmode, modifier);\n+\t  return const0_rtx;\n+\t}\n+      else if ((code == TRUTH_ANDIF_EXPR || code == TRUTH_ORIF_EXPR)\n+\t       && ! TREE_SIDE_EFFECTS (TREE_OPERAND (exp, 1)))\n+\t/* If the second operand has no side effects, just evaluate\n+\t   the first. */\n+\treturn expand_expr (TREE_OPERAND (exp, 0), const0_rtx,\n+\t\t\t    VOIDmode, modifier);\n+      /* If will do cse, generate all results into pseudo registers\n+\t since 1) that allows cse to find more things\n+\t and 2) otherwise cse could produce an insn the machine\n+\t cannot support.  */\n+\n+      target = 0, original_target = 0;\n+    }\n \n   if (! cse_not_expected && mode != BLKmode && target\n       && (GET_CODE (target) != REG || REGNO (target) < FIRST_PSEUDO_REGISTER))\n     target = subtarget;\n \n-  /* Ensure we reference a volatile object even if value is ignored.  */\n-  if (ignore && TREE_THIS_VOLATILE (exp)\n-      && TREE_CODE (exp) != FUNCTION_DECL\n-      && mode != VOIDmode && mode != BLKmode)\n-    {\n-      target = gen_reg_rtx (mode);\n-      temp = expand_expr (exp, target, VOIDmode, modifier);\n-      if (temp != target)\n-\temit_move_insn (target, temp);\n-      return target;\n-    }\n-\n   switch (code)\n     {\n     case LABEL_DECL:\n@@ -3596,11 +3624,23 @@ expand_expr (exp, target, tmode, modifier)\n       return RTL_EXPR_RTL (exp);\n \n     case CONSTRUCTOR:\n+      /* If we don't need the result, just ensure we evaluate any\n+\t subexpressions.  */\n+      if (ignore)\n+\t{\n+\t  tree elt;\n+\t  for (elt = CONSTRUCTOR_ELTS (exp); elt; elt = TREE_CHAIN (elt))\n+\t    expand_expr (TREE_VALUE (elt), const0_rtx, VOIDmode, 0);\n+\t  return const0_rtx;\n+\t}\n       /* All elts simple constants => refer to a constant in memory.  But\n \t if this is a non-BLKmode mode, let it store a field at a time\n \t since that should make a CONST_INT or CONST_DOUBLE when we\n-\t fold.  */\n-      if (TREE_STATIC (exp) && (mode == BLKmode || TREE_ADDRESSABLE (exp)))\n+\t fold.  If we are making an initializer and all operands are\n+\t constant, put it in memory as well.  */\n+      else if ((TREE_STATIC (exp)\n+\t\t&& (mode == BLKmode || TREE_ADDRESSABLE (exp)))\n+\t       || (modifier == EXPAND_INITIALIZER && TREE_CONSTANT (exp)))\n \t{\n \t  rtx constructor = output_constant_def (exp);\n \t  if (modifier != EXPAND_CONST_ADDRESS\n@@ -3613,13 +3653,6 @@ expand_expr (exp, target, tmode, modifier)\n \t  return constructor;\n \t}\n \n-      if (ignore)\n-\t{\n-\t  tree elt;\n-\t  for (elt = CONSTRUCTOR_ELTS (exp); elt; elt = TREE_CHAIN (elt))\n-\t    expand_expr (TREE_VALUE (elt), const0_rtx, VOIDmode, 0);\n-\t  return const0_rtx;\n-\t}\n       else\n \t{\n \t  if (target == 0 || ! safe_from_p (target, exp))\n@@ -4121,11 +4154,6 @@ expand_expr (exp, target, tmode, modifier)\n     case NOP_EXPR:\n     case CONVERT_EXPR:\n     case REFERENCE_EXPR:\n-      if (TREE_CODE (type) == VOID_TYPE || ignore)\n-\t{\n-\t  expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode, modifier);\n-\t  return const0_rtx;\n-\t}\n       if (mode == TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0))))\n \treturn expand_expr (TREE_OPERAND (exp, 0), target, VOIDmode, modifier);\n       if (TREE_CODE (type) == UNION_TYPE)\n@@ -4781,6 +4809,13 @@ expand_expr (exp, target, tmode, modifier)\n \t    && integer_zerop (TREE_OPERAND (exp, 2))\n \t    && TREE_CODE_CLASS (TREE_CODE (TREE_OPERAND (exp, 0))) == '<')\n \t  {\n+\t    if (ignore)\n+\t      {\n+\t\texpand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode,\n+\t\t\t     modifier);\n+\t\treturn const0_rtx;\n+\t      }\n+\n \t    op0 = expand_expr (TREE_OPERAND (exp, 0), target, mode, modifier);\n \t    if (GET_MODE (op0) == mode)\n \t      return op0;\n@@ -4795,7 +4830,7 @@ expand_expr (exp, target, tmode, modifier)\n \t   intermediate target unless it is safe.  If no target, use a \n \t   temporary.  */\n \n-\tif (mode == VOIDmode || ignore)\n+\tif (ignore)\n \t  temp = 0;\n \telse if (original_target\n \t\t && safe_from_p (original_target, TREE_OPERAND (exp, 0)))\n@@ -4839,7 +4874,7 @@ expand_expr (exp, target, tmode, modifier)\n \t/* If we had X ? A + 1 : A and we can do the test of X as a store-flag\n \t   operation, do this as A + (X != 0).  Similarly for other simple\n \t   binary operators.  */\n-\tif (singleton && binary_op\n+\tif (temp && singleton && binary_op\n \t    && ! TREE_SIDE_EFFECTS (TREE_OPERAND (exp, 0))\n \t    && (TREE_CODE (binary_op) == PLUS_EXPR\n \t\t|| TREE_CODE (binary_op) == MINUS_EXPR"}]}