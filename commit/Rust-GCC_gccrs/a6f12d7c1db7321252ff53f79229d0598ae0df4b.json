{"sha": "a6f12d7c1db7321252ff53f79229d0598ae0df4b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZmMTJkN2MxZGI3MzIxMjUyZmY1M2Y3OTIyOWQwNTk4YWUwZGY0Yg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-10-26T21:01:33Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-10-26T21:01:33Z"}, "message": "Initial revision\n\nFrom-SVN: r2615", "tree": {"sha": "f4c23a3a739ec2e2e83b56d3c53b538da1f55d69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f4c23a3a739ec2e2e83b56d3c53b538da1f55d69"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6f12d7c1db7321252ff53f79229d0598ae0df4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6f12d7c1db7321252ff53f79229d0598ae0df4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6f12d7c1db7321252ff53f79229d0598ae0df4b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6f12d7c1db7321252ff53f79229d0598ae0df4b/comments", "author": null, "committer": null, "parents": [{"sha": "66bcbe195420cade8f0e00b1ae6e7fc4b15c750c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66bcbe195420cade8f0e00b1ae6e7fc4b15c750c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66bcbe195420cade8f0e00b1ae6e7fc4b15c750c"}], "stats": {"total": 1521, "additions": 1521, "deletions": 0}, "files": [{"sha": "4ec88cc581b9b74115dd39eb6a6cffc8393acf28", "filename": "gcc/config/alpha/alpha.c", "status": "added", "additions": 1521, "deletions": 0, "changes": 1521, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6f12d7c1db7321252ff53f79229d0598ae0df4b/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6f12d7c1db7321252ff53f79229d0598ae0df4b/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=a6f12d7c1db7321252ff53f79229d0598ae0df4b", "patch": "@@ -0,0 +1,1521 @@\n+/* Subroutines used for code generation on the DEC Alpha.\n+   Copyright (C) 1992 Free Software Foundation, Inc.\n+   Contributed by Richard Kenner (kenner@nyu.edu)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-flags.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+#include \"flags.h\"\n+#include \"recog.h\"\n+#include \"reload.h\"\n+#include \"expr.h\"\n+#include \"obstack.h\"\n+#include \"tree.h\"\n+\n+/* Save information from a \"cmpxx\" operation until the branch or scc is\n+   emitted.  */\n+\n+rtx alpha_compare_op0, alpha_compare_op1;\n+int alpha_compare_fp_p;\n+\n+/* Save the name of the current function as used by the assembler.  This\n+   is used by the epilogue.  */\n+\n+char *alpha_function_name;\n+\n+/* Nonzero if the current function needs gp.  */\n+\n+int alpha_function_needs_gp;\n+\f\n+/* Returns 1 if VALUE is a mask that contains full bytes of zero or ones.  */\n+\n+int\n+zap_mask (value)\n+     HOST_WIDE_INT value;\n+{\n+  int i;\n+\n+  for (i = 0; i < HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR;\n+       i++, value >>= 8)\n+    if ((value & 0xff) != 0 && (value & 0xff) != 0xff)\n+      return 0;\n+\n+  return 1;\n+}\n+\n+/* Returns 1 if OP is either the constant zero or a register.  If a\n+   register, it must be in the proper mode unless MODE is VOIDmode.  */\n+\n+int\n+reg_or_0_operand (op, mode)\n+      register rtx op;\n+      enum machine_mode mode;\n+{\n+  return op == const0_rtx || register_operand (op, mode);\n+}\n+\n+/* Return 1 if OP is an 8-bit constant or any register.  */\n+\n+int\n+reg_or_8bit_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  return ((GET_CODE (op) == CONST_INT\n+\t   && (unsigned HOST_WIDE_INT) INTVAL (op) < 0x100)\n+\t  || register_operand (op, mode));\n+}\n+\n+/* Return 1 if the operand is a valid second operand to an add insn.  */\n+\n+int\n+add_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == CONST_INT)\n+    return ((unsigned HOST_WIDE_INT) (INTVAL (op) + 0x8000) < 0x10000\n+\t    || ((INTVAL (op) & 0xffff) == 0\n+\t\t&& (INTVAL (op) >> 31 == -1\n+\t\t    || INTVAL (op) >> 31 == 0)));\n+\n+  return register_operand (op, mode);\n+}\n+\n+/* Return 1 if the operand is a valid second operand to a sign-extending\n+   add insn.  */\n+\n+int\n+sext_add_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == CONST_INT)\n+    return ((unsigned HOST_WIDE_INT) INTVAL (op) < 255\n+\t    || (unsigned HOST_WIDE_INT) (- INTVAL (op)) < 255);\n+\n+  return register_operand (op, mode);\n+}\n+\n+/* Return 1 if OP is the constant 4 or 8.  */\n+\n+int\n+const48_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == CONST_INT\n+\t  && (INTVAL (op) == 4 || INTVAL (op) == 8));\n+}\n+\n+/* Return 1 if OP is a valid first operand to an AND insn.  */\n+\n+int\n+and_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == CONST_DOUBLE && GET_MODE (op) == VOIDmode)\n+    return (zap_mask (CONST_DOUBLE_LOW (op))\n+\t    && zap_mask (CONST_DOUBLE_HIGH (op)));\n+\n+  if (GET_CODE (op) == CONST_INT)\n+    return ((unsigned HOST_WIDE_INT) INTVAL (op) < 0x100\n+\t    || (unsigned HOST_WIDE_INT) ~ INTVAL (op) < 0x100\n+\t    || zap_mask (INTVAL (op)));\n+\n+  return register_operand (op, mode);\n+}\n+\n+/* Return 1 if OP is a constant that is the width, in bits, of an integral\n+   mode smaller than DImode.  */\n+\n+int\n+mode_width_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == CONST_INT\n+\t  && (INTVAL (op) == 8 || INTVAL (op) == 16 || INTVAL (op) == 32));\n+}\n+\n+/* Return 1 if OP is a constant that is the width of an integral machine mode\n+   smaller than an integer.  */\n+\n+int\n+mode_mask_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+#if HOST_BITS_PER_WIDE_INT == 32\n+  if (GET_CODE (op) == CONST_DOUBLE)\n+    return CONST_DOUBLE_HIGH (op) == 0 && CONST_DOUBLE_LOW (op) == -1;\n+#endif\n+\n+  if (GET_CODE (op) == CONST_INT)\n+    return (INTVAL (op) == 0xff\n+\t    || INTVAL (op) == 0xffff\n+#if HOST_BITS_PER_WIDE_INT == 64\n+\t    || INTVAL (op) == 0xffffffff\n+#endif\n+\t    );\n+}\n+\n+/* Return 1 if OP is a multiple of 8 less than 64.  */\n+\n+int\n+mul8_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == CONST_INT\n+\t  && (unsigned HOST_WIDE_INT) INTVAL (op) < 64\n+\t  && (INTVAL (op) & 7) == 0);\n+}\n+\n+/* Return 1 if OP is the constant zero in floating-point.  */\n+\n+int\n+fp0_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_MODE (op) == mode\n+\t  && GET_MODE_CLASS (mode) == MODE_FLOAT && op == CONST0_RTX (mode));\n+}\n+\n+/* Return 1 if OP is the floating-point constant zero or a register.  */\n+\n+int\n+reg_or_fp0_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  return fp0_operand (op, mode) || register_operand (op, mode);\n+}\n+\n+/* Return 1 if OP is a register or a constant integer.  */\n+\n+\n+int\n+reg_or_cint_operand (op, mode)\n+    register rtx op;\n+    enum machine_mode mode;\n+{\n+     return GET_CODE (op) == CONST_INT || register_operand (op, mode);\n+}\n+\n+/* Return 1 if OP is a valid operand for the source of a move insn.  */\n+\n+int\n+input_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))\n+    return 0;\n+\n+  if (GET_MODE_CLASS (mode) == MODE_FLOAT && GET_MODE (op) != mode)\n+    return 0;\n+\n+  switch (GET_CODE (op))\n+    {\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+    case CONST:\n+      return mode == DImode;\n+\n+    case REG:\n+      return 1;\n+\n+    case SUBREG:\n+      if (register_operand (op, mode))\n+\treturn 1;\n+      /* ... fall through ... */\n+    case MEM:\n+      return mode != HImode && mode != QImode && general_operand (op, mode);\n+\n+    case CONST_DOUBLE:\n+      return GET_MODE_CLASS (mode) == MODE_FLOAT && op == CONST0_RTX (mode);\n+\n+    case CONST_INT:\n+      return mode == QImode || mode == HImode || add_operand (op, mode);\n+    }\n+\n+  return 0;\n+}\n+\n+/* Return 1 if OP is a SYMBOL_REF for the current function.  */\n+\n+int\n+current_function_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == SYMBOL_REF\n+\t  && ! strcmp (XSTR (op, 0), current_function_name));\n+}\n+\n+/* Return 1 if OP is a valid Alpha comparison operator.  Here we know which\n+   comparisons are valid in which insn.  */\n+\n+int\n+alpha_comparison_operator (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  enum rtx_code code = GET_CODE (op);\n+\n+  if (mode != GET_MODE (op) || GET_RTX_CLASS (code) != '<')\n+    return 0;\n+\n+  return (code == EQ || code == LE || code == LT\n+\t  || (mode == DImode && (code == LEU || code == LTU)));\n+}\n+\n+/* Return 1 if OP is a signed comparison operation.  */\n+\n+int\n+signed_comparison_operator (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case EQ:  case NE:  case LE:  case LT:  case GE:   case GT:\n+      return 1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Return 1 if this is a divide or modulus operator.  */\n+\n+int\n+divmod_operator (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case DIV:  case MOD:  case UDIV:  case UMOD:\n+      return 1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Return 1 if this memory address is a known aligned register plus\n+   a constant.  It must be a valid address.  This means that we can do\n+   this as an aligned reference plus some offset.\n+\n+   Take into account what reload will do.\n+\n+   We could say that out-of-range stack slots are alignable, but that would\n+   complicate get_aligned_mem and it isn't worth the trouble since few\n+   functions have large stack space.  */\n+\n+int\n+aligned_memory_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == SUBREG)\n+    {\n+      if (GET_MODE (op) != mode)\n+\treturn 0;\n+      op = SUBREG_REG (op);\n+      mode = GET_MODE (op);\n+    }\n+\n+  if (reload_in_progress && GET_CODE (op) == REG\n+      && REGNO (op) >= FIRST_PSEUDO_REGISTER)\n+    op = reg_equiv_mem[REGNO (op)];\n+\n+  if (GET_CODE (op) != MEM || GET_MODE (op) != mode\n+      || ! memory_address_p (mode, XEXP (op, 0)))\n+    return 0;\n+\n+  op = XEXP (op, 0);\n+\n+  if (GET_CODE (op) == PLUS)\n+    op = XEXP (op, 0);\n+\n+  return (GET_CODE (op) == REG\n+\t  && (REGNO (op) == STACK_POINTER_REGNUM || op == frame_pointer_rtx\n+\t      || (REGNO (op) >= FIRST_VIRTUAL_REGISTER\n+\t\t  && REGNO (op) <= LAST_VIRTUAL_REGISTER)));\n+}\n+\n+/* Similar, but return 1 if OP is a MEM which is not alignable.  */\n+\n+int\n+unaligned_memory_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == SUBREG)\n+    {\n+      if (GET_MODE (op) != mode)\n+\treturn 0;\n+      op = SUBREG_REG (op);\n+      mode = GET_MODE (op);\n+    }\n+\n+  if (reload_in_progress && GET_CODE (op) == REG\n+      && REGNO (op) >= FIRST_PSEUDO_REGISTER)\n+    op = reg_equiv_mem[REGNO (op)];\n+\n+  if (GET_CODE (op) != MEM || GET_MODE (op) != mode)\n+    return 0;\n+\n+  op = XEXP (op, 0);\n+\n+  if (! memory_address_p (mode, op))\n+    return 1;\n+\n+  if (GET_CODE (op) == PLUS)\n+    op = XEXP (op, 0);\n+\n+  return (GET_CODE (op) != REG\n+\t  || (REGNO (op) != STACK_POINTER_REGNUM && op != frame_pointer_rtx\n+\t      && (REGNO (op) < FIRST_VIRTUAL_REGISTER\n+\t\t  || REGNO (op) > LAST_VIRTUAL_REGISTER)));\n+}\n+\n+/* Return 1 if OP is any memory location.  During reload a pseudo matches.  */\n+\n+int\n+any_memory_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == MEM\n+\t  || (GET_CODE (op) == SUBREG && GET_CODE (SUBREG_REG (op)) == REG)\n+\t  || (reload_in_progress && GET_CODE (op) == REG\n+\t      && REGNO (op) >= FIRST_PSEUDO_REGISTER)\n+\t  || (reload_in_progress && GET_CODE (op) == SUBREG\n+\t      && GET_CODE (SUBREG_REG (op)) == REG\n+\t      && REGNO (SUBREG_REG (op)) >= FIRST_PSEUDO_REGISTER));\n+}\n+\n+/* REF is an alignable memory location.  Place an aligned SImode\n+   reference into *PALIGNED_MEM and the number of bits to shift into\n+   *PBITNUM.  */\n+\n+void\n+get_aligned_mem (ref, paligned_mem, pbitnum)\n+     rtx ref;\n+     rtx *paligned_mem, *pbitnum;\n+{\n+  rtx base;\n+  HOST_WIDE_INT offset = 0;\n+\n+  if (GET_CODE (ref) == SUBREG)\n+    {\n+      offset = SUBREG_WORD (ref) * UNITS_PER_WORD;\n+      if (BYTES_BIG_ENDIAN)\n+\toffset -= (MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (ref)))\n+\t\t   - MIN (UNITS_PER_WORD,\n+\t\t\t  GET_MODE_SIZE (GET_MODE (SUBREG_REG (ref)))));\n+      ref = SUBREG_REG (ref);\n+    }\n+\n+  if (GET_CODE (ref) == REG)\n+    ref = reg_equiv_mem[REGNO (ref)];\n+\n+  if (reload_in_progress)\n+    base = find_replacement (&XEXP (ref, 0));\n+  else\n+    base = XEXP (ref, 0);\n+\n+  if (GET_CODE (base) == PLUS)\n+    offset += INTVAL (XEXP (base, 1)), base = XEXP (base, 0);\n+\n+  *paligned_mem = gen_rtx (MEM, SImode,\n+\t\t\t   plus_constant (base, offset & ~3));\n+  MEM_IN_STRUCT_P (*paligned_mem) = MEM_IN_STRUCT_P (ref);\n+  MEM_VOLATILE_P (*paligned_mem) = MEM_VOLATILE_P (ref);\n+  RTX_UNCHANGING_P (*paligned_mem) = RTX_UNCHANGING_P (ref);\n+\n+  *pbitnum = GEN_INT ((offset & 3) * 8);\n+}\n+\n+/* Similar, but just get the address.  Handle the two reload cases.  */\n+\n+rtx\n+get_unaligned_address (ref)\n+     rtx ref;\n+{\n+  rtx base;\n+  HOST_WIDE_INT offset = 0;\n+\n+  if (GET_CODE (ref) == SUBREG)\n+    {\n+      offset = SUBREG_WORD (ref) * UNITS_PER_WORD;\n+      if (BYTES_BIG_ENDIAN)\n+\toffset -= (MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (ref)))\n+\t\t   - MIN (UNITS_PER_WORD,\n+\t\t\t  GET_MODE_SIZE (GET_MODE (SUBREG_REG (ref)))));\n+      ref = SUBREG_REG (ref);\n+    }\n+\n+  if (GET_CODE (ref) == REG)\n+    ref = reg_equiv_mem[REGNO (ref)];\n+\n+  if (reload_in_progress)\n+    base = find_replacement (&XEXP (ref, 0));\n+  else\n+    base = XEXP (ref, 0);\n+\n+  if (GET_CODE (base) == PLUS)\n+    offset += INTVAL (XEXP (base, 1)), base = XEXP (base, 0);\n+\n+  return plus_constant (base, offset);\n+}\n+\f\n+/* Subfunction of the following function.  Update the flags of any MEM\n+   found in part of X.  */\n+\n+static void\n+alpha_set_memflags_1 (x, in_struct_p, volatile_p, unchanging_p)\n+     rtx x;\n+     int in_struct_p, volatile_p, unchanging_p;\n+{\n+  int i;\n+\n+  switch (GET_CODE (x))\n+    {\n+    case SEQUENCE:\n+    case PARALLEL:\n+      for (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n+\talpha_set_memflags_1 (XVECEXP (x, 0, i), in_struct_p, volatile_p,\n+\t\t\t      unchanging_p);\n+      break;\n+\n+    case INSN:\n+      alpha_set_memflags_1 (PATTERN (x), in_struct_p, volatile_p,\n+\t\t\t    unchanging_p);\n+      break;\n+\n+    case SET:\n+      alpha_set_memflags_1 (SET_DEST (x), in_struct_p, volatile_p,\n+\t\t\t    unchanging_p);\n+      alpha_set_memflags_1 (SET_SRC (x), in_struct_p, volatile_p,\n+\t\t\t    unchanging_p);\n+      break;\n+\n+    case MEM:\n+      MEM_IN_STRUCT_P (x) = in_struct_p;\n+      MEM_VOLATILE_P (x) = volatile_p;\n+      RTX_UNCHANGING_P (x) = unchanging_p;\n+      break;\n+    }\n+}\n+\n+/* Given INSN, which is either an INSN or a SEQUENCE generated to\n+   perform a memory operation, look for any MEMs in either a SET_DEST or\n+   a SET_SRC and copy the in-struct, unchanging, and volatile flags from\n+   REF into each of the MEMs found.  If REF is not a MEM, don't do\n+   anything.  */\n+\n+void\n+alpha_set_memflags (insn, ref)\n+     rtx insn;\n+     rtx ref;\n+{\n+  /* Note that it is always safe to get these flags, though they won't\n+     be what we think if REF is not a MEM.  */\n+  int in_struct_p = MEM_IN_STRUCT_P (ref);\n+  int volatile_p = MEM_VOLATILE_P (ref);\n+  int unchanging_p = RTX_UNCHANGING_P (ref);\n+\n+  if (GET_CODE (ref) != MEM\n+      || (! in_struct_p && ! volatile_p && ! unchanging_p))\n+    return;\n+\n+  alpha_set_memflags_1 (insn, in_struct_p, volatile_p, unchanging_p);\n+}\n+\f\n+/* Try to output insns to set TARGET equal to the constant C if it can be\n+   done in less than N insns.  Returns 1 if it can be done and the\n+   insns have been emitted.  If it would take more than N insns, zero is\n+   returned and no insns and emitted.  */\n+\n+int\n+alpha_emit_set_const (target, c, n)\n+     rtx target;\n+     HOST_WIDE_INT c;\n+     int n;\n+{\n+  HOST_WIDE_INT new = c;\n+  int i, bits;\n+\n+#if HOST_BITS_PER_WIDE_INT == 64\n+  /* We are only called for SImode and DImode.  If this is SImode, ensure that\n+     we are sign extended to a full word.  This does not make any sense when\n+     cross-compiling on a narrow machine.  */\n+\n+  if (GET_MODE (target) == SImode)\n+    c = (c & 0xffffffff) - 2 * (c & 0x80000000);\n+#endif\n+\n+  /* If this is a sign-extended 32-bit constant, we can do this in at most\n+     three insns, so do it if we have enough insns left.  We always have\n+     a sign-extended 32-bit constant when compiling on a narrow machine.  */\n+\n+  if (HOST_BITS_PER_WIDE_INT != 64\n+      || c >> 31 == -1 || c >> 31 == 0)\n+    {\n+      HOST_WIDE_INT low = (c & 0xffff) - 2 * (c & 0x8000);\n+      HOST_WIDE_INT tmp1 = c - low;\n+      HOST_WIDE_INT high\n+\t= ((tmp1 >> 16) & 0xffff) - 2 * ((tmp1 >> 16) & 0x8000);\n+      HOST_WIDE_INT tmp2 = c - (high << 16) - low;\n+      HOST_WIDE_INT extra = 0;\n+\n+      if (tmp2)\n+\t{\n+\t  extra = 0x4000;\n+\t  tmp1 -= 0x40000000;\n+\t  high = ((tmp1 >> 16) & 0xffff) - 2 * ((tmp1 >> 16) & 0x8000);\n+\t}\n+\n+      if (c == low || (low == 0 && extra == 0))\n+\t{\n+\t  emit_move_insn (target, GEN_INT (c));\n+\t  return 1;\n+\t}\n+      else if (n >= 2 + (extra != 0))\n+\t{\n+\t  emit_move_insn (target, GEN_INT (low));\n+\t  if (extra != 0)\n+\t    emit_insn (gen_add2_insn (target, GEN_INT (extra << 16)));\n+\n+\t  emit_insn (gen_add2_insn (target, GEN_INT (high << 16)));\n+\t  return 1;\n+\t}\n+    }\n+\n+  /* If we couldn't do it that way, try some other methods (that depend on\n+     being able to compute in the target's word size).  But if we have no\n+     instructions left, don't bother.  Also, don't even try if this is \n+     SImode (in which case we should have already done something, but\n+     do a sanity check here).  */\n+\n+  if (n == 1 || HOST_BITS_PER_WIDE_INT < 64 || GET_MODE (target) != DImode)\n+    return 0;\n+\n+  /* First, see if can load a value into the target that is the same as the\n+     constant except that all bytes that are 0 are changed to be 0xff.  If we\n+     can, then we can do a ZAPNOT to obtain the desired constant.  */\n+\n+  for (i = 0; i < 64; i += 8)\n+    if ((new & ((HOST_WIDE_INT) 0xff << i)) == 0)\n+      new |= (HOST_WIDE_INT) 0xff << i;\n+\n+  if (alpha_emit_set_const (target, new, n - 1))\n+    {\n+      emit_insn (gen_anddi3 (target, target, GEN_INT (c | ~ new)));\n+      return 1;\n+    }\n+\n+  /* Find, see if we can load a related constant and then shift and possibly\n+     negate it to get the constant we want.  Try this once each increasing\n+     numbers of insns.  */\n+\n+  for (i = 1; i < n; i++)\n+    {\n+      /* First try complementing.  */\n+      if (alpha_emit_set_const (target, ~ c, i))\n+\t{\n+\t  emit_insn (gen_one_cmpldi2 (target, target));\n+\t  return 1;\n+\t}\n+\n+      /* First try to form a constant and do a left shift.  We can do this\n+\t if some low-order bits are zero; the exact_log2 call below tells\n+\t us that information.  The bits we are shifting out could be any\n+\t value, but here we'll just try the 0- and sign-extended forms of\n+\t the constant.  To try to increase the chance of having the same\n+\t constant in more than one insn, start at the highest number of\n+\t bits to shift, but try all possibilities in case a ZAPNOT will\n+\t be useful.  */\n+\n+      if ((bits = exact_log2 (c & - c)) > 0)\n+\tfor (; bits > 0; bits--)\n+\t  if (alpha_emit_set_const (target, c >> bits, i)\n+\t      || alpha_emit_set_const (target,\n+\t\t\t\t       ((unsigned HOST_WIDE_INT) c) >> bits,\n+\t\t\t\t       i))\n+\t    {\n+\t      emit_insn (gen_ashldi3 (target, target, GEN_INT (bits)));\n+\t      return 1;\n+\t    }\n+\n+      /* Now try high-order zero bits.  Here we try the shifted-in bits as\n+\t all zero and all ones.  */\n+\n+      if ((bits = HOST_BITS_PER_WIDE_INT - floor_log2 (c) - 1) > 0)\n+\tfor (; bits > 0; bits--)\n+\t  if (alpha_emit_set_const (target, c << bits, i)\n+\t      || alpha_emit_set_const (target,\n+\t\t\t\t       ((c << bits)\n+\t\t\t\t\t| (((HOST_WIDE_INT) 1 << bits) - 1)),\n+\t\t\t\t       i))\n+\t    {\n+\t      emit_insn (gen_lshrdi3 (target, target, GEN_INT (bits)));\n+\t      return 1;\n+\t    }\n+\n+      /* Now try high-order 1 bits.  We get that with a sign-extension.\n+\t But one bit isn't enough here.  */\n+      \n+      if ((bits = HOST_BITS_PER_WIDE_INT - floor_log2 (~ c) - 2) > 0)\n+\tfor (; bits > 0; bits--)\n+\t  if (alpha_emit_set_const (target, c << bits, i)\n+\t      || alpha_emit_set_const (target,\n+\t\t\t\t       ((c << bits)\n+\t\t\t\t\t| (((HOST_WIDE_INT) 1 << bits) - 1)),\n+\t\t\t\t       i))\n+\t    {\n+\t      emit_insn (gen_ashrdi3 (target, target, GEN_INT (bits)));\n+\t      return 1;\n+\t    }\n+    }\n+\n+  return 0;\n+}\n+\f\n+/* Adjust the cost of a scheduling dependency.  Return the new cost of\n+   a dependency LINK or INSN on DEP_INSN.  COST is the current cost.  */\n+\n+int\n+alpha_adjust_cost (insn, link, dep_insn, cost)\n+     rtx insn;\n+     rtx link;\n+     rtx dep_insn;\n+     int cost;\n+{\n+  rtx set;\n+\n+  /* If the dependence is an anti-dependence, there is no cost.  For an\n+     output dependence, there is sometimes a cost, but it doesn't seem\n+     worth handling those few cases.  */\n+\n+  if (REG_NOTE_KIND (link) != 0)\n+    return 0;\n+\n+  /* If INSN is a store insn and DEP_INSN is setting the data being stored,\n+     we can sometimes lower the cost.  */\n+\n+  if (recog_memoized (insn) >= 0 && get_attr_type (insn) == TYPE_ST\n+      && (set = single_set (dep_insn)) != 0\n+      && GET_CODE (PATTERN (insn)) == SET\n+      && rtx_equal_p (SET_DEST (set), SET_SRC (PATTERN (insn))))\n+    switch (get_attr_type (dep_insn))\n+      {\n+      case TYPE_LD:\n+\t/* No savings here.  */\n+\treturn cost;\n+\n+      case TYPE_IMULL:\n+      case TYPE_IMULQ:\n+\t/* In these cases, we save one cycle.  */\n+\treturn cost - 2;\n+\n+      default:\n+\t/* In all other cases, we save two cycles.  */\n+\treturn MAX (0, cost - 4);\n+      }\n+\n+  /* Another case that needs adjustment is an arithmetic or logical\n+     operation.  It's cost is usually one cycle, but we default it to\n+     two in the MD file.  The only case that it is actually two is\n+     for the address in loads and stores.  */\n+\n+  if (recog_memoized (dep_insn) >= 0\n+      && get_attr_type (dep_insn) == TYPE_IADDLOG)\n+    switch (get_attr_type (insn))\n+      {\n+      case TYPE_LD:\n+      case TYPE_ST:\n+\treturn cost;\n+\n+      default:\n+\treturn 2;\n+      }\n+\n+  /* The final case is when a compare feeds into an integer branch.  The cost\n+     is only one cycle in that case.  */\n+\n+  if (recog_memoized (dep_insn) >= 0\n+      && get_attr_type (dep_insn) == TYPE_ICMP\n+      && recog_memoized (insn) >= 0\n+      && get_attr_type (insn) == TYPE_IBR)\n+    return 2;\n+\n+  /* Otherwise, return the default cost. */\n+\n+  return cost;\n+}\n+\f\n+/* Print an operand.  Recognize special options, documented below.  */\n+\n+void\n+print_operand (file, x, code)\n+    FILE *file;\n+    rtx x;\n+    char code;\n+{\n+  int i;\n+\n+  switch (code)\n+    {\n+    case 'r':\n+      /* If this operand is the constant zero, write it as \"$31\".  */\n+      if (GET_CODE (x) == REG)\n+\tfprintf (file, \"%s\", reg_names[REGNO (x)]);\n+      else if (x == CONST0_RTX (GET_MODE (x)))\n+\tfprintf (file, \"$31\");\n+      else\n+\toutput_operand_lossage (\"invalid %%r value\");\n+\n+      break;\n+\n+    case 'R':\n+      /* Similar, but for floating-point.  */\n+      if (GET_CODE (x) == REG)\n+\tfprintf (file, \"%s\", reg_names[REGNO (x)]);\n+      else if (x == CONST0_RTX (GET_MODE (x)))\n+\tfprintf (file, \"$f31\");\n+      else\n+\toutput_operand_lossage (\"invalid %%R value\");\n+\n+      break;\n+\n+    case 'N':\n+      /* Write the 1's complement of a constant.  */\n+      if (GET_CODE (x) != CONST_INT)\n+\toutput_operand_lossage (\"invalid %%N value\");\n+\n+      fprintf (file, \"%ld\", ~ INTVAL (x));\n+      break;\n+\n+    case 'P':\n+      /* Write 1 << C, for a constant C.  */\n+      if (GET_CODE (x) != CONST_INT)\n+\toutput_operand_lossage (\"invalid %%P value\");\n+\n+      fprintf (file, \"%ld\", (HOST_WIDE_INT) 1 << INTVAL (x));\n+      break;\n+\n+    case 'h':\n+      /* Write the high-order 16 bits of a constant, sign-extended.  */\n+      if (GET_CODE (x) != CONST_INT)\n+\toutput_operand_lossage (\"invalid %%h value\");\n+\n+      fprintf (file, \"%ld\", INTVAL (x) >> 16);\n+      break;\n+\n+    case 'L':\n+      /* Write the low-order 16 bits of a constant, sign-extended.  */\n+      if (GET_CODE (x) != CONST_INT)\n+\toutput_operand_lossage (\"invalid %%L value\");\n+\n+      fprintf (file, \"%ld\", (INTVAL (x) & 0xffff) - 2 * (INTVAL (x) & 0x8000));\n+      break;\n+\n+    case 'm':\n+      /* Write mask for ZAP insn.  */\n+      if (GET_CODE (x) == CONST_DOUBLE)\n+\t{\n+\t  HOST_WIDE_INT mask = 0;\n+\t  HOST_WIDE_INT value;\n+\n+\t  value = CONST_DOUBLE_LOW (x);\n+\t  for (i = 0; i < HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR;\n+\t       i++, value >>= 8)\n+\t    if (value & 0xff)\n+\t      mask |= (1 << i);\n+\n+\t  value = CONST_DOUBLE_HIGH (x);\n+\t  for (i = 0; i < HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR;\n+\t       i++, value >>= 8)\n+\t    if (value & 0xff)\n+\t      mask |= (1 << (i + sizeof (int)));\n+\n+\t  fprintf (file, \"%ld\", mask & 0xff);\n+\t}\n+\n+      else if (GET_CODE (x) == CONST_INT)\n+\t{\n+\t  HOST_WIDE_INT mask = 0, value = INTVAL (x);\n+\n+\t  for (i = 0; i < 8; i++, value >>= 8)\n+\t    if (value & 0xff)\n+\t      mask |= (1 << i);\n+\n+\t  fprintf (file, \"%ld\", mask);\n+\t}\n+      else\n+\toutput_operand_lossage (\"invalid %%m value\");\n+      break;\n+\n+    case 'M':\n+      /* 'b', 'w', or 'l' as the value of the constant.  */\n+      if (GET_CODE (x) != CONST_INT\n+\t  || (INTVAL (x) != 8 && INTVAL (x) != 16 && INTVAL (x) != 32))\n+\toutput_operand_lossage (\"invalid %%M value\");\n+\n+      fprintf (file, \"%s\",\n+\t       INTVAL (x) == 8 ? \"b\" : INTVAL (x) == 16 ? \"w\" : \"l\");\n+      break;\n+\n+    case 'U':\n+      /* Similar, except do it from the mask.  */\n+      if (GET_CODE (x) == CONST_INT && INTVAL (x) == 0xff)\n+\tfprintf (file, \"b\");\n+      else if (GET_CODE (x) == CONST_INT && INTVAL (x) == 0xffff)\n+\tfprintf (file, \"w\");\n+#if HOST_BITS_PER_WIDE_INT == 32\n+      else if (GET_CODE (x) == CONST_DOUBLE\n+\t       && CONST_DOUBLE_HIGH (x) == 0\n+\t       && CONST_DOUBLE_LOW (x) == -1)\n+\tfprintf (file, \"l\");\n+#else\n+      else if (GET_CODE (x) == CONST_INT && INTVAL (x) == 0xffffffff)\n+\tfprintf (file, \"l\");\n+#endif\n+      else\n+\toutput_operand_lossage (\"invalid %%U value\");\n+      break;\n+\n+    case 's':\n+      /* Write the constant value divided by 8.  */\n+      if (GET_CODE (x) != CONST_INT\n+\t  && (unsigned HOST_WIDE_INT) INTVAL (x) >= 64\n+\t  && (INTVAL (x) & 7) != 8)\n+\toutput_operand_lossage (\"invalid %%s value\");\n+\n+      fprintf (file, \"%ld\", INTVAL (x) / 8);\n+      break;\n+\n+    case 'S':\n+      /* Same, except compute (64 - c) / 8 */\n+\n+      if (GET_CODE (x) != CONST_INT\n+\t  && (unsigned HOST_WIDE_INT) INTVAL (x) >= 64\n+\t  && (INTVAL (x) & 7) != 8)\n+\toutput_operand_lossage (\"invalid %%s value\");\n+\n+      fprintf (file, \"%ld\", (64 - INTVAL (x)) / 8);\n+      break;\n+\n+    case 'C':\n+      /* Write out comparison name.  */\n+      if (GET_RTX_CLASS (GET_CODE (x)) != '<')\n+\toutput_operand_lossage (\"invalid %%C value\");\n+\n+      if (GET_CODE (x) == LEU)\n+\tfprintf (file, \"ule\");\n+      else if (GET_CODE (x) == LTU)\n+\tfprintf (file, \"ult\");\n+      else\n+\tfprintf (file, \"%s\", GET_RTX_NAME (GET_CODE (x)));\n+      break;\n+\n+    case 'D':\n+      /* Similar, but write reversed code.  We can't get an unsigned code\n+\t here.  */\n+      if (GET_RTX_CLASS (GET_CODE (x)) != '<')\n+\toutput_operand_lossage (\"invalid %%D value\");\n+\n+      fprintf (file, \"%s\", GET_RTX_NAME (reverse_condition (GET_CODE (x))));\n+      break;\n+\n+    case 'E':\n+      /* Write the divide or modulus operator.  */\n+      switch (GET_CODE (x))\n+\t{\n+\tcase DIV:\n+\t  fprintf (file, \"div%s\", GET_MODE (x) == SImode ? \"l\" : \"q\");\n+\t  break;\n+\tcase UDIV:\n+\t  fprintf (file, \"div%su\", GET_MODE (x) == SImode ? \"l\" : \"q\");\n+\t  break;\n+\tcase MOD:\n+\t  fprintf (file, \"rem%s\", GET_MODE (x) == SImode ? \"l\" : \"q\");\n+\t  break;\n+\tcase UMOD:\n+\t  fprintf (file, \"rem%su\", GET_MODE (x) == SImode ? \"l\" : \"q\");\n+\t  break;\n+\tdefault:\n+\t  output_operand_lossage (\"invalid %%E value\");\n+\t  break;\n+\t}\n+      break;\n+\n+    case 'F':\n+      /* Write the symbol; if the current function uses GP, write a\n+\t modified version.  */\n+      if (GET_CODE (x) != SYMBOL_REF)\n+\toutput_operand_lossage (\"invalid %%F value\");\n+\n+      output_addr_const (file, x);\n+      if (alpha_function_needs_gp)\n+\tfprintf (file, \"..ng\");\n+      break;\n+\n+    case 'A':\n+      /* Write \"_u\" for unaligned access.  */\n+      if (GET_CODE (x) == MEM && GET_CODE (XEXP (x, 0)) == AND)\n+\tfprintf (file, \"_u\");\n+      break;\n+\n+    case 0:\n+      if (GET_CODE (x) == REG)\n+\tfprintf (file, \"%s\", reg_names[REGNO (x)]);\n+      else if (GET_CODE (x) == MEM)\n+\toutput_address (XEXP (x, 0));\n+      else\n+\toutput_addr_const (file, x);\n+      break;\n+\n+    default:\n+      output_operand_lossage (\"invalid %%xn code\");\n+    }\n+}\n+\f\n+/* Do what is necessary for `va_start'.  The argument is ignored;\n+   We look at the current function to determine if stdargs or varargs\n+   is used and fill in an initial va_list.  A pointer to this constructor\n+   is returned.  */\n+\n+struct rtx_def *\n+alpha_builtin_saveregs (arglist)\n+     tree arglist;\n+{\n+  rtx block, addr, argsize;\n+  tree fntype = TREE_TYPE (current_function_decl);\n+  int stdargs = (TYPE_ARG_TYPES (fntype) != 0\n+\t\t && (TREE_VALUE (tree_last (TYPE_ARG_TYPES (fntype)))\n+\t\t     != void_type_node));\n+  int nregs = current_function_args_info;\n+\n+  /* If we have a variable-sized argument already, we will have used all\n+     the registers, so set up to indicate that.  */\n+\n+  if (GET_CODE (current_function_arg_offset_rtx) != CONST_INT)\n+    {\n+      argsize = plus_constant (current_function_arg_offset_rtx,\n+\t\t\t       ((6 - stdargs) * UNITS_PER_WORD\n+\t\t\t\t+ UNITS_PER_WORD - 1));\n+      argsize = expand_shift (RSHIFT_EXPR, Pmode, argsize,\n+\t\t\t      build_int_2 (3, 0), argsize, 0);\n+    }\n+  else\n+    {\n+      /* If we are using memory, deduct the stdarg adjustment from it,\n+\t otherwise from the number of registers.  Then compute the current\n+\t argument number.  */\n+\n+      int memargs = ((INTVAL (current_function_arg_offset_rtx)\n+\t\t      + UNITS_PER_WORD - 1)\n+\t\t     / UNITS_PER_WORD);\n+\n+      if (memargs)\n+\tmemargs -= stdargs;\n+      else\n+\tnregs -= stdargs;\n+\n+      argsize = GEN_INT (MIN (nregs, 6) + memargs);\n+    }\n+\n+  /* Allocate the va_list constructor */\n+  block = assign_stack_local (BLKmode, 4 * UNITS_PER_WORD, BITS_PER_WORD);\n+  RTX_UNCHANGING_P (block) = 1;\n+  RTX_UNCHANGING_P (XEXP (block, 0)) = 1;\n+\n+  /* Store the argsize as the __va_arg member.  */\n+  emit_move_insn (change_address (block, DImode, XEXP (block, 0)),\n+\t\t  argsize);\n+\n+  /* Store the arg pointer in the __va_stack member.  */\n+  emit_move_insn (change_address (block, Pmode,\n+\t\t\t\t  plus_constant (XEXP (block, 0),\n+\t\t\t\t\t\t UNITS_PER_WORD)),\n+\t\t  virtual_incoming_args_rtx);\n+\n+  /* Allocate the integer register space, and store it as the\n+     __va_ireg member.  */\n+  addr = assign_stack_local (BLKmode, 6 * UNITS_PER_WORD, -1);\n+  MEM_IN_STRUCT_P (addr) = 1;\n+  RTX_UNCHANGING_P (addr) = 1;\n+  RTX_UNCHANGING_P (XEXP (addr, 0)) = 1;\n+\n+  emit_move_insn (change_address (block, Pmode,\n+\t\t\t\t  plus_constant (XEXP (block, 0),\n+\t\t\t\t\t\t 2 * UNITS_PER_WORD)),\n+\t\t  copy_to_reg (XEXP (addr, 0)));\n+\n+  /* Now store the incoming integer registers.  */\n+  if (nregs < 6)\n+      move_block_from_reg\n+\t(16 + nregs,\n+\t change_address (addr, Pmode,\n+\t\t\t plus_constant (XEXP (addr, 0),\n+\t\t\t\t\tnregs * UNITS_PER_WORD)),\n+\t 6 - nregs);\n+\n+  /* Allocate the FP register space, and store it as the\n+     __va_freg member.  */\n+  addr = assign_stack_local (BLKmode, 6 * UNITS_PER_WORD, -1);\n+  MEM_IN_STRUCT_P (addr) = 1;\n+  RTX_UNCHANGING_P (addr) = 1;\n+  RTX_UNCHANGING_P (XEXP (addr, 0)) = 1;\n+\n+  emit_move_insn (change_address (block, Pmode,\n+\t\t\t\t  plus_constant (XEXP (block, 0),\n+\t\t\t\t\t\t 3 * UNITS_PER_WORD)),\n+\t\t  copy_to_reg (XEXP (addr, 0)));\n+\n+  /* Now store the incoming floating-point registers.   If we are not\n+     to use the floating-point registers, store the integer registers\n+     in those locations too.  */\n+  if (nregs < 6)\n+      move_block_from_reg\n+\t(16 + 32 * (TARGET_FPREGS != 0) + nregs,\n+\t change_address (addr, Pmode,\n+\t\t\t plus_constant (XEXP (addr, 0),\n+\t\t\t\t\tnregs * UNITS_PER_WORD)),\n+\t 6 - nregs);\n+\n+  /* Return the address of the va_list constructor, but don't put it in a\n+     register.  This fails when not optimizing and produces worse code when\n+     optimizing.  */\n+  return XEXP (block, 0);\n+}\n+\f\n+/* This page contains routines that are used to determine what the function\n+   prologue and epilogue code will do and write them out.  */\n+\n+/* Compute the size of the save area in the stack.  */\n+\n+int\n+alpha_sa_size ()\n+{\n+  int size = 0;\n+  int i;\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    if (! fixed_regs[i] && ! call_used_regs[i] && regs_ever_live[i])\n+      size++;\n+\n+  return size * 8;\n+}\n+\n+/* Return non-zero if this function needs gp.  It does if it has\n+   an LDSYM insn.  */\n+\n+int\n+alpha_need_gp ()\n+{\n+  rtx insn;\n+\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n+\t&& GET_CODE (PATTERN (insn)) != USE\n+\t&& GET_CODE (PATTERN (insn)) != CLOBBER\n+\t&& get_attr_type (insn) == TYPE_LDSYM)\n+      return 1;\n+\n+  return 0;\n+}\n+\n+/* Return 1 if GP is dead at after INSN.  */\n+\n+int\n+alpha_gp_dead_after (insn)\n+     rtx insn;\n+{\n+  int jump_count = 0;\n+  int found = 0;\n+  rtx p;\n+\n+  /* If we aren't optimizing, don't do this optimization.  More importantly,\n+     JUMP_LABEL isn't properly set when not optimizing.  */\n+\n+  if (optimize == 0)\n+    return 0;\n+\n+  /* If we are followed by a BARRIER, we don't return.  */\n+  if (NEXT_INSN (insn) && GET_CODE (NEXT_INSN (insn)) == BARRIER)\n+    return 1;\n+\n+  /* Otherwise search for a use of GP before a return.  */\n+\n+  for (p = next_active_insn (insn); p; p = next_active_insn (p))\n+    {\n+      if (get_attr_type (p) == TYPE_LDSYM\n+\t  || get_attr_type (p) == TYPE_JSR)\n+\t{\n+\t  found = 1;\n+\t  break;\n+\t}\n+\n+      if (GET_CODE (p) == JUMP_INSN)\n+\t{\n+\t  if (GET_CODE (PATTERN (p)) == RETURN)\n+\t    break;\n+\n+\t  if (! simplejump_p (p) || jump_count++ > 10)\n+\t    {\n+\t      found = 1;\n+\t      break;\n+\t    }\n+\n+\t  p = JUMP_LABEL (p);\n+\t}\n+    }\n+\n+  /* Restore any operands destroyed by the attribute calls above.  */\n+  insn_extract (insn);\n+\n+  return ! found;\n+}\n+\n+/* Return 1 if this function can directly return via $26.  */\n+\n+int\n+direct_return ()\n+{\n+  return (reload_completed && alpha_sa_size () == 0\n+\t  && get_frame_size () == 0\n+\t  && current_function_pretend_args_size == 0);\n+}\n+\n+/* Write function prologue.  */\n+\n+void\n+output_prolog (file, size)\n+     FILE *file;\n+     int size;\n+{\n+  HOST_WIDE_INT frame_size = ((size + current_function_outgoing_args_size\n+\t\t\t       + current_function_pretend_args_size\n+\t\t\t       + alpha_sa_size () + 15) & ~15);\n+  int reg_offset = current_function_outgoing_args_size;\n+  int start_reg_offset = reg_offset;\n+  unsigned reg_mask = 0;\n+  int i;\n+\n+  /* If we need a GP, load it first.  */\n+  alpha_function_needs_gp = alpha_need_gp ();\n+\n+  if (alpha_function_needs_gp)\n+    {\n+      rtx insn;\n+\n+      fprintf (file, \"\\tldgp $29,0($27)\\n\");\n+\n+      /* If we have a recursive call, put a special label here.  */\n+      for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+\tif (GET_CODE (insn) == CALL_INSN\n+\t    && get_attr_type (insn) != TYPE_JSR)\n+\t  {\n+\t    fprintf (file, \"%s..ng:\\n\", current_function_name);\n+\t    break;\n+\t  }\n+    }\n+\n+  /* Adjust the stack by the frame size.  If the frame size is > 32768\n+     bytes, we have to load it into a register first and then subtract\n+     from sp.  Note that we are only allowed to adjust sp once in the\n+     prologue.  */\n+\n+  if (frame_size > 32768)\n+    {\n+      HOST_WIDE_INT low = (frame_size & 0xffff) - 2 * (frame_size & 0x8000);\n+      HOST_WIDE_INT tmp1 = frame_size - low;\n+      HOST_WIDE_INT high\n+\t= ((tmp1 >> 16) & 0xfff) - 2 * ((tmp1 >> 16) & 0x8000);\n+      HOST_WIDE_INT tmp2 = frame_size - (high << 16) - low;\n+      HOST_WIDE_INT extra = 0;\n+      int in_reg = 31;\n+\n+      /* We haven't written code to handle frames > 4GB.  */\n+#if HOST_BITS_PER_LONG_INT == 64\n+      if ((unsigned HOST_WIDE_INT) frame_size >> 32 != 0)\n+\tabort ();\n+#endif\n+\n+      if (tmp2)\n+\t{\n+\t  extra = 0x4000;\n+\t  tmp1 -= 0x40000000;\n+\t  high = ((tmp1 >> 16) & 0xffff) - 2 * ((tmp1 >> 16) & 0x8000);\n+\t}\n+\n+      if (low != 0)\n+\t{\n+\t  fprintf (file, \"\\tlda $28,%d($%d)\\n\", low, in_reg);\n+\t  in_reg = 28;\n+\t}\n+\n+      if (extra)\n+\t{\n+\t  fprintf (file, \"\\tldah $28,%d($%d)\\n\", extra, in_reg);\n+\t  in_reg = 28;\n+\t}\n+\n+      fprintf (file, \"\\tldah $28,%d($%d)\\n\", high, in_reg);\n+\n+      fprintf (file, \"\\tsubq $30,$28,$30\\n\");\n+    }\n+  else if (frame_size)\n+    fprintf (file, \"\\tlda $30,-%d($30)\\n\", frame_size);\n+\n+  /* Write out the .frame line.  If we need a frame pointer, we use\n+     an offset of zero.  */\n+\n+  if (frame_pointer_needed)\n+    fprintf (file, \"\\t.frame $15,0,$26\\n\");\n+  else\n+    fprintf (file, \"\\t.frame $30,%d,$26\\n\", frame_size);\n+\n+    \n+  /* Save register 26 if it is used.  */\n+  if (regs_ever_live[26])\n+    {\n+      reg_mask |= 1 << 26;\n+      fprintf (file, \"\\tstq $26,%d($30)\\n\", reg_offset);\n+      reg_offset += 8;\n+    }\n+\n+  /* Now save any other used register that are required to be saved.  */\n+  for (i = 0; i < 32; i++)\n+    if (! fixed_regs[i] && ! call_used_regs[i] && regs_ever_live[i] && i != 26)\n+      {\n+\treg_mask |= 1 << i;\n+\tfprintf (file, \"\\tstq $%d,%d($30)\\n\", i, reg_offset);\n+\treg_offset += 8;\n+      }\n+\n+  /* Print the register mask and do floating-point saves.  */\n+  if (reg_mask)\n+    fprintf (file, \"\\t.mask 0x%x,%d\\n\", reg_mask,\n+\t     start_reg_offset - frame_size);\n+\n+  start_reg_offset = reg_offset;\n+  reg_mask = 0;\n+\n+  for (i = 0; i < 32; i++)\n+    if (! fixed_regs[i + 32] && ! call_used_regs[i + 32]\n+\t&& regs_ever_live[i + 32])\n+      {\n+\treg_mask |= 1 << i;\n+\tfprintf (file, \"\\tstt $f%d,%d($30)\\n\", i, reg_offset);\n+\treg_offset += 8;\n+      }\n+\n+  /* Print the floating-point mask, if we've saved any fp register.  */\n+  if (reg_mask)\n+    fprintf (file, \"\\t.fmask 0x%x,%d\\n\", reg_mask, start_reg_offset);\n+\n+  /* If we need a frame pointer, set it to the value of incoming stack\n+     which we compute by adding back the frame size pointer.  Because we\n+     can subtract one more than we can add, we have to special-case\n+     frame sizes of 32K.  Note that there is no restriction that the frame\n+     pointer be updated in one instruction.  */\n+\n+  if (frame_pointer_needed)\n+    {\n+      if (frame_size == 32768)\n+\tfprintf (file, \"\\tlda $15,16384($30)\\n\\tlda $15,16384($15)\\n\");\n+      else if (frame_size > 32768)\n+\tfprintf (file, \"\\tadd $30,$28,$15\\n\");\n+      else\n+\tfprintf (file, \"\\tlda $15,%d($30)\\n\", frame_size);\n+    }\n+}\n+\n+/* Write function epilogue.  */\n+\n+void\n+output_epilog (file, size)\n+     FILE *file;\n+     int size;\n+{\n+  rtx insn = get_last_insn ();\n+  HOST_WIDE_INT frame_size = ((size + current_function_outgoing_args_size\n+\t\t\t       + current_function_pretend_args_size\n+\t\t\t       + alpha_sa_size () + 15) & ~15);\n+  int reg_offset = current_function_outgoing_args_size;\n+  int reg_offset_from = STACK_POINTER_REGNUM;\n+  int i;\n+\n+  /* If the last insn was a BARRIER, we don't have to write anything except\n+     the .end pseudo-op.  */\n+  if (GET_CODE (insn) == NOTE)\n+    insn = prev_nonnote_insn (insn);\n+  if (insn == 0 || GET_CODE (insn) != BARRIER)\n+    {\n+      /* If we have a frame pointer, we restore the registers from an\n+\t offset from it, assuming that we can reach the offset.  If not,\n+\t we have to compute the address using a scratch register.  This is\n+\t messy, but should not be common.  We have to copy the frame\n+\t pointer elsewhere here since we will be restoring it before we can\n+\t use it to restore the stack pointer.  We use $25.  */\n+\n+      if (frame_pointer_needed)\n+\t{\n+\t  fprintf (file, \"\\tbis $15,$15,$25\\n\");\n+\n+\t  if (frame_size < 32768)\n+\t    reg_offset -= frame_size, reg_offset_from = 25;\n+\t  else\n+\t    {\n+\t      HOST_WIDE_INT low\n+\t\t= (frame_size & 0xffff) - 2 * (frame_size & 0x8000);\n+\t      HOST_WIDE_INT tmp1 = frame_size - low;\n+\t      HOST_WIDE_INT high\n+\t\t= ((tmp1 >> 16) & 0xffff) - 2 * ((tmp1 >> 16) & 0x8000);\n+\t      HOST_WIDE_INT tmp2 = frame_size - (high << 16) - low;\n+\t      int extra = 0xe;\n+\t      int in_reg = 31;\n+\n+\t      if (tmp2)\n+\t\t{\n+\t\t  extra = 0x4000;\n+\t\t  tmp1 -= 0x40000000;\t\n+\t\t  high = ((tmp1 >> 16) & 0xffff) - 2 * ((tmp1 >> 16) & 0x8000);\n+\t\t}\n+\n+\t      if (low != 0)\n+\t\t{\n+\t\t  fprintf (file, \"\\tlda $28,%d($%d)\\n\", low, in_reg);\n+\t\t  in_reg = 28;\n+\t\t}\n+\n+\t      if (extra)\n+\t\t{\n+\t\t  fprintf (file, \"\\tldah $28,%d($%d)\\n\", extra, in_reg);\n+\t\t  in_reg = 28;\n+\t\t}\n+\n+\t      fprintf (file, \"\\tldah $28,%d($%d)\\n\", high, in_reg);\n+\n+\t      fprintf (file, \"\\taddq $25,$28,$28\\n\");\n+\n+\t      reg_offset_from = 28;\n+\t    }\n+\t}\n+\n+      /* Restore all the registers, starting with the return address\n+\t register.  */\n+      if (regs_ever_live[26])\n+\t{\n+\t  fprintf (file, \"\\tldq $26,%d($%d)\\n\", reg_offset, reg_offset_from);\n+\t  reg_offset += 8;\n+\t}\n+\n+      /* Now restore any other used register that that we saved.  */\n+      for (i = 0; i < 32; i++)\n+\tif (! fixed_regs[i] && ! call_used_regs[i] && regs_ever_live[i]\n+\t    && i != 26)\n+\t  {\n+\t    fprintf (file, \"\\tldq $%d,%d($%d)\\n\",\n+\t\t     i, reg_offset, reg_offset_from);\n+\t    reg_offset += 8;\n+\t  }\n+\n+      for (i = 0; i < 32; i++)\n+\tif (! fixed_regs[i + 32] && ! call_used_regs[i + 32]\n+\t    && regs_ever_live[i + 32])\n+\t  {\n+\t    fprintf (file, \"\\tldt $f%d,%d($%d)\\n\",\n+\t\t     i, reg_offset, reg_offset_from);\n+\t    reg_offset += 8;\n+\t  }\n+\n+      /* Restore the stack.  If we have a frame pointer, use it.  Otherwise,\n+\t add the size back into the stack, handling the large frame size.  */\n+\n+      if (frame_pointer_needed)\n+\tfprintf (file, \"\\tbis $25,$25,$30\\n\");\n+      else if (frame_size > 32767)\n+\t{\n+\t  HOST_WIDE_INT low\n+\t    = (frame_size & 0xffff) - 2 * (frame_size & 0x8000);\n+\t  HOST_WIDE_INT tmp1 = frame_size - low;\n+\t  HOST_WIDE_INT high\n+\t    = ((tmp1 >> 16) & 0xffff) - 2 * ((tmp1 >> 16) & 0x8000);\n+\t  HOST_WIDE_INT tmp2 = frame_size - (high << 16) - low;\n+\t  HOST_WIDE_INT extra = 0;\n+\t  int in_reg = 31;\n+\n+\t  /* We haven't written code to handle frames > 4GB.  */\n+#if HOST_BITS_PER_LONG_INT == 64\n+\t  if ((unsigned HOST_WIDE_INT) frame_size >> 32 != 0)\n+\t    abort ();\n+#endif\n+\n+\t  if (tmp2)\n+\t    {\n+\t      extra = 0x4000;\n+\t      tmp1 -= 0x40000000;\n+\t      high = ((tmp1 >> 16) & 0xffff) - 2 * ((tmp1 >> 16) & 0x8000);\n+\t    }\n+\n+\t  if (low != 0)\n+\t    {\n+\t      fprintf (file, \"\\tlda $28,%d($%d)\\n\", low, in_reg);\n+\t      in_reg = 28;\n+\t    }\n+\n+\t  if (extra)\n+\t    {\n+\t      fprintf (file, \"\\tldah $28,%d($%d)\\n\", extra, in_reg);\n+\t      in_reg = 28;\n+\t    }\n+\n+\t  fprintf (file, \"\\tldah $28,%d($%d)\\n\", high, in_reg);\n+\n+\t  fprintf (file, \"\\taddq $30,$28,$30\\n\");\n+\t}\n+      else if (frame_size)\n+\tfprintf (file, \"\\tlda $30,%d($30)\\n\", frame_size);\n+\n+      /* Now return to the caller.  */\n+      fprintf (file, \"\\tret $31,($26),1\\n\");\n+    }\n+\n+  /* End the function.  */\n+  fprintf (file, \"\\t.end %s\\n\", alpha_function_name);\n+}"}]}