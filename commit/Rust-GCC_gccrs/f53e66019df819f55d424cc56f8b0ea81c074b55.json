{"sha": "f53e66019df819f55d424cc56f8b0ea81c074b55", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjUzZTY2MDE5ZGY4MTlmNTVkNDI0Y2M1NmY4YjBlYTgxYzA3NGI1NQ==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-07-09T14:20:22Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-07-09T14:20:22Z"}, "message": "c++: find_template_parameters and TEMPLATE_DECLs [PR101247]\n\nr12-1989 fixed the testcase in the PR, but unfortunately the fix is\nbuggy: it breaks the case where the common template between the\nTEMPLATE_DECL t and ctx_parms is the innermost template (as in\nconcepts-memtmpl5.C below).  This can be fixed by instead passing the\nTREE_TYPE of ctmpl to common_enclosing_class when ctmpl is a class\ntemplate.\n\nBut even after that's fixed, the analogous case where the innermost\ntemplate is a partial specialization is still broken (as in\nconcepts-memtmpl5a.C below), because ctmpl is always a primary template.\n\nSo this patch instead takes a diferent approach that doesn't rely on\nctx_parms at all: when looking for the template parameters of a\nTEMPLATE_DECL that are shared with the current template context, just\nwalk its DECL_CONTEXT.  As long as the template is not overly general\n(e.g. we didn't pass it through most_general_template), this should give\nus exactly what we want, since if a TEMPLATE_DECL can be referred to\nfrom some template context then the template parameters it uses must all\nbe in-scope and contained in its DECL_CONTEXT.  This effectively makes\nus treat TEMPLATE_DECLs more similarly to other _DECLs (whose DECL_CONTEXT\nwe also walk).\n\n\tPR c++/101247\n\ngcc/cp/ChangeLog:\n\n\t* pt.c (any_template_parm_r) <case TEMPLATE_DECL>: Just walk the\n\tDECL_CONTEXT.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp2a/concepts-memtmpl4.C: Uncomment the commented out\n\texample, which we now handle correctly.\n\t* g++.dg/cpp2a/concepts-memtmpl5.C: New test.\n\t* g++.dg/cpp2a/concepts-memtmpl5a.C: New test.", "tree": {"sha": "b8618b7c104b03a9a02f6702bc4b3d39bc0b8289", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8618b7c104b03a9a02f6702bc4b3d39bc0b8289"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f53e66019df819f55d424cc56f8b0ea81c074b55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f53e66019df819f55d424cc56f8b0ea81c074b55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f53e66019df819f55d424cc56f8b0ea81c074b55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f53e66019df819f55d424cc56f8b0ea81c074b55/comments", "author": null, "committer": null, "parents": [{"sha": "2e345e4ad6bb6595a9e3b182aa349d4f306b0921", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e345e4ad6bb6595a9e3b182aa349d4f306b0921", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e345e4ad6bb6595a9e3b182aa349d4f306b0921"}], "stats": {"total": 42, "additions": 32, "deletions": 10}, "files": [{"sha": "dc0f0b7b58ef4b129c11dd782e1ceec9c8b2577c", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f53e66019df819f55d424cc56f8b0ea81c074b55/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f53e66019df819f55d424cc56f8b0ea81c074b55/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=f53e66019df819f55d424cc56f8b0ea81c074b55", "patch": "@@ -10728,15 +10728,11 @@ any_template_parm_r (tree t, void *data)\n       break;\n \n     case TEMPLATE_DECL:\n-      {\n-\t/* If T is a member template that shares template parameters with\n-\t   ctx_parms, we need to mark all those parameters for mapping.  */\n-\tif (tree ctmpl = TREE_TYPE (INNERMOST_TEMPLATE_PARMS (ftpi->ctx_parms)))\n-\t  if (tree com = common_enclosing_class (DECL_CONTEXT (t),\n-\t\t\t\t\t\t DECL_CONTEXT (ctmpl)))\n-\t    if (tree ti = CLASSTYPE_TEMPLATE_INFO (com))\n-\t      WALK_SUBTREE (TI_ARGS (ti));\n-      }\n+      /* If T is a member template that shares template parameters with\n+\t ctx_parms, we need to mark all those parameters for mapping.\n+\t To that end, it should suffice to just walk the DECL_CONTEXT of\n+\t the template (assuming the template is not overly general).  */\n+      WALK_SUBTREE (DECL_CONTEXT (t));\n       break;\n \n     case LAMBDA_EXPR:"}, {"sha": "f990ae17859a53e67e7f4fd07c16ba05e64e9bc9", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-memtmpl4.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f53e66019df819f55d424cc56f8b0ea81c074b55/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-memtmpl4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f53e66019df819f55d424cc56f8b0ea81c074b55/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-memtmpl4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-memtmpl4.C?ref=f53e66019df819f55d424cc56f8b0ea81c074b55", "patch": "@@ -24,5 +24,5 @@ int main()\n {\n   A<void>::B::f(0);\n   A<void>::C<int>::f(0);\n-  // A<void>::C<int>::g();\n+  A<void>::C<int>::g();\n }"}, {"sha": "3c83bb884859f7122e1631838ec1fdf131024664", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-memtmpl5.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f53e66019df819f55d424cc56f8b0ea81c074b55/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-memtmpl5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f53e66019df819f55d424cc56f8b0ea81c074b55/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-memtmpl5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-memtmpl5.C?ref=f53e66019df819f55d424cc56f8b0ea81c074b55", "patch": "@@ -0,0 +1,11 @@\n+// PR c++/101247\n+// { dg-do compile { target concepts } }\n+\n+template<class T, class U> struct A {\n+  template<class> static constexpr bool d = true;\n+  static void g() requires d<U>;\n+};\n+\n+int main() {\n+  A<int, char>::g();\n+}"}, {"sha": "458f1cdf8562394d67a3a8e62254c968304f5944", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-memtmpl5a.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f53e66019df819f55d424cc56f8b0ea81c074b55/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-memtmpl5a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f53e66019df819f55d424cc56f8b0ea81c074b55/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-memtmpl5a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-memtmpl5a.C?ref=f53e66019df819f55d424cc56f8b0ea81c074b55", "patch": "@@ -0,0 +1,15 @@\n+// PR c++/101247\n+// { dg-do compile { target concepts } }\n+// A variant of concepts-memtmpl5.C that uses a partial specialization\n+// of A instead of the primary template.\n+\n+template<class, class> struct A;\n+\n+template<class T, class U> requires true struct A<T, U> {\n+  template<class V> static constexpr bool d = true;\n+  static void g() requires d<U>;\n+};\n+\n+int main() {\n+  A<int, char>::g();\n+}"}]}