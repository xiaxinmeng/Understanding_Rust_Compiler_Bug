{"sha": "0ac785173d96fc8d058ed817cf9286ddaf6d831a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGFjNzg1MTczZDk2ZmM4ZDA1OGVkODE3Y2Y5Mjg2ZGRhZjZkODMxYQ==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@superh.com", "date": "2002-07-17T15:15:04Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2002-07-17T15:15:04Z"}, "message": "sh-protos.h (binary_float_operator): Remove declaration.\n\n\t* sh-protos.h (binary_float_operator): Remove declaration.\n\t(sh_expand_unop_v2sf, sh_expand_binop_v2sf): Declare.\n\t* sh.c (print_operand, case 'N'): Check against CONST0_RTX.\n\t(unary_float_operator, sh_expand_unop_v2sf): New functions.\n\t(sh_expand_binop_v2sf): Likewise.\n\t(zero_vec_operand): Delete.\n\t(SH_BLTIN_UDI): New builtin shared signature define.  Renumbered\n\tall non-shared ones.\n\t(bdesc): Change all the mextr builtins to use SH_BLTIN_UDI.\n\tEnable nsb and byterev.\n\t* sh.h (CONDITIONAL_REGISTER_USAGE): Initialize DF_HI_REGS.\n\t(HARD_REGNO_MODE_OK): Allow TImode in fp regs.  Allow V2SFmode\n\tin general regs.\n\t(enum reg_class, REG_CLASS_NAMES, REG_CLASS_CONTENTS): Add DF_HI_REGS.\n\t(SECONDARY_OUTPUT_RELOAD_CLASS): Likewise.  Remove clause for\n\timmediate operands.\n\t(SECONDARY_INPUT_RELOAD_CLASS): Add clause for immediate operands.\n\tAdd DF_HI_REGS.\n\t(CLASS_CANNOT_CHANGE_MODE, CLASS_CANNOT_CHANGE_MODE_P): Allow\n\tlowpart fp regs - only for big endian for now.\n\t(LEGITIMATE_CONSTANT_P): Don't allow non-zero float vectors\n\twhen FPU is in use.\n\t(EXTRA_CONTRAINT_U): Check against CONST0_RTX.\n\t(LOAD_EXTEND_OP): NIL for SImode.\n\t(REGISTER_MOVE_COST): Add DF_HI_REGS.  Const for moves between\n\tgeneral and fp registers is 4.\n\tPREDICATE_CODES: Amend binary_float_operator entry.\n\tRemove zero_vec_operand.  Add unary_float_operator.\n\t* sh.md (udivsi3_i4_media): Use truncate instead of paradoxical\n\tsubreg SET_DEST.\n\t(truncdisi2, truncdihi2, movv2sf): Allow memory destinations.\n\t(truncdiqi2): Do sign extension.\n\t(movsi_media, movdi_media): Allow to use r63 to an fp register.\n\t(movdf_media, movsf_media): Likewise.\n\t(movv2sf_i, movv2sf_i+1): Don't use f{ld,st}.p or SUBREGS.\n\tCollapse to one define_insn_and_split.  Allow immediate sources.\n\t(addv2sf3, subv2sf3, mulv2sf3, divv2sf3): New patterns.\n\t(movv4sf_i): Allow immediate sources.  Use simplify_gen_subreg.\n\t(movv4sf): Allow immediate sources.\n\t(movsf_media_nofpu+1): Don't split moves to FP registers.\n\t(unary_sf_op, binary_sf_op, mshflo_w_x, concat_v2sf): New patterns.\n\t(movv8qi_i+3): Check against CONST0_RTX.\n\t(mextr1, mextr2. mextr3. mextr4, mextr5, mextr6, mextr7): Use DImode\n\tfor input and output operands.  Fix argument 3 to gen_mextr_rl.\n\t(mmul23_wl, mmul01_wl, mmulsum_wq_i): s/const_vector/parallel/\n\t(msad_ubq_i, mshf4_b, mshf0_b, mshf4_l, mshf0_l, mshf4_w): Likewise.\n\t(mshf0_w, fipr, ftrv): Likewise.\n\t(mshfhi_l_di): Now insn_and_split.  Can handle FP regs.\n\nFrom-SVN: r55528", "tree": {"sha": "db9bf553918d31a90a5fa97d75bef6b5cb9d0e87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db9bf553918d31a90a5fa97d75bef6b5cb9d0e87"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ac785173d96fc8d058ed817cf9286ddaf6d831a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ac785173d96fc8d058ed817cf9286ddaf6d831a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ac785173d96fc8d058ed817cf9286ddaf6d831a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ac785173d96fc8d058ed817cf9286ddaf6d831a/comments", "author": null, "committer": null, "parents": [{"sha": "d955f6ea6f555019be4227cb1f48b691483cf275", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d955f6ea6f555019be4227cb1f48b691483cf275", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d955f6ea6f555019be4227cb1f48b691483cf275"}], "stats": {"total": 625, "additions": 447, "deletions": 178}, "files": [{"sha": "68e89f2ad503bd1ac1990f83a2ffc93611effc7f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac785173d96fc8d058ed817cf9286ddaf6d831a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac785173d96fc8d058ed817cf9286ddaf6d831a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0ac785173d96fc8d058ed817cf9286ddaf6d831a", "patch": "@@ -1,3 +1,54 @@\n+Wed Jul 17 14:04:10 2002  J\"orn Rennecke <joern.rennecke@superh.com>\n+\n+\t* sh-protos.h (binary_float_operator): Remove declaration.\n+\t(sh_expand_unop_v2sf, sh_expand_binop_v2sf): Declare.\n+\t* sh.c (print_operand, case 'N'): Check against CONST0_RTX.\n+\t(unary_float_operator, sh_expand_unop_v2sf): New functions.\n+\t(sh_expand_binop_v2sf): Likewise.\n+\t(zero_vec_operand): Delete.\n+\t(SH_BLTIN_UDI): New builtin shared signature define.  Renumbered\n+\tall non-shared ones.\n+\t(bdesc): Change all the mextr builtins to use SH_BLTIN_UDI.\n+\tEnable nsb and byterev.\n+\t* sh.h (CONDITIONAL_REGISTER_USAGE): Initialize DF_HI_REGS.\n+\t(HARD_REGNO_MODE_OK): Allow TImode in fp regs.  Allow V2SFmode\n+\tin general regs.\n+\t(enum reg_class, REG_CLASS_NAMES, REG_CLASS_CONTENTS): Add DF_HI_REGS.\n+\t(SECONDARY_OUTPUT_RELOAD_CLASS): Likewise.  Remove clause for\n+\timmediate operands.\n+\t(SECONDARY_INPUT_RELOAD_CLASS): Add clause for immediate operands.\n+\tAdd DF_HI_REGS.\n+\t(CLASS_CANNOT_CHANGE_MODE, CLASS_CANNOT_CHANGE_MODE_P): Allow\n+\tlowpart fp regs - only for big endian for now.\n+\t(LEGITIMATE_CONSTANT_P): Don't allow non-zero float vectors\n+\twhen FPU is in use.\n+\t(EXTRA_CONTRAINT_U): Check against CONST0_RTX.\n+\t(LOAD_EXTEND_OP): NIL for SImode.\n+\t(REGISTER_MOVE_COST): Add DF_HI_REGS.  Const for moves between\n+\tgeneral and fp registers is 4.\n+\tPREDICATE_CODES: Amend binary_float_operator entry.\n+\tRemove zero_vec_operand.  Add unary_float_operator.\n+\t* sh.md (udivsi3_i4_media): Use truncate instead of paradoxical\n+\tsubreg SET_DEST.\n+\t(truncdisi2, truncdihi2, movv2sf): Allow memory destinations.\n+\t(truncdiqi2): Do sign extension.\n+\t(movsi_media, movdi_media): Allow to use r63 to an fp register.\n+\t(movdf_media, movsf_media): Likewise.\n+\t(movv2sf_i, movv2sf_i+1): Don't use f{ld,st}.p or SUBREGS.\n+\tCollapse to one define_insn_and_split.  Allow immediate sources.\n+\t(addv2sf3, subv2sf3, mulv2sf3, divv2sf3): New patterns.\n+\t(movv4sf_i): Allow immediate sources.  Use simplify_gen_subreg.\n+\t(movv4sf): Allow immediate sources.\n+\t(movsf_media_nofpu+1): Don't split moves to FP registers.\n+\t(unary_sf_op, binary_sf_op, mshflo_w_x, concat_v2sf): New patterns.\n+\t(movv8qi_i+3): Check against CONST0_RTX.\n+\t(mextr1, mextr2. mextr3. mextr4, mextr5, mextr6, mextr7): Use DImode\n+\tfor input and output operands.  Fix argument 3 to gen_mextr_rl.\n+\t(mmul23_wl, mmul01_wl, mmulsum_wq_i): s/const_vector/parallel/\n+\t(msad_ubq_i, mshf4_b, mshf0_b, mshf4_l, mshf0_l, mshf4_w): Likewise.\n+\t(mshf0_w, fipr, ftrv): Likewise.\n+\t(mshfhi_l_di): Now insn_and_split.  Can handle FP regs.\n+\n 2002-07-17  Jeroen Dobbelaere  <jeroen.dobbelaere@acunia.com>\n \n \t* arm.h (ARM_NUM_INTS, ARM_NUM_REGS, ARM_NUM_REGS2): Renamed from"}, {"sha": "432ab63367e0457d657fe9749edc4d18c505f548", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac785173d96fc8d058ed817cf9286ddaf6d831a/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac785173d96fc8d058ed817cf9286ddaf6d831a/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=0ac785173d96fc8d058ed817cf9286ddaf6d831a", "patch": "@@ -92,7 +92,6 @@ extern int fpscr_operand PARAMS ((rtx, enum machine_mode));\n extern int fpul_operand PARAMS ((rtx, enum machine_mode));\n extern int commutative_float_operator PARAMS ((rtx, enum machine_mode));\n extern int noncommutative_float_operator PARAMS ((rtx, enum machine_mode));\n-extern int binary_float_operator PARAMS ((rtx, enum machine_mode));\n extern int reg_unused_after PARAMS ((rtx, rtx));\n extern void expand_sf_unop PARAMS ((rtx (*)(rtx, rtx, rtx), rtx *));\n extern void expand_sf_binop PARAMS ((rtx (*)(rtx, rtx, rtx, rtx), rtx *));\n@@ -118,6 +117,8 @@ extern void output_file_start PARAMS ((FILE *));\n extern int sh_media_register_for_return PARAMS ((void));\n extern void sh_expand_prologue PARAMS ((void));\n extern void sh_expand_epilogue PARAMS ((void));\n+extern void sh_expand_unop_v2sf (enum rtx_code, rtx, rtx);\n+extern void sh_expand_binop_v2sf (enum rtx_code, rtx, rtx, rtx);\n extern int sh_need_epilogue PARAMS ((void));\n extern int initial_elimination_offset PARAMS ((int, int));\n extern int fldi_ok PARAMS ((void));"}, {"sha": "315cdec5484d2b888aaf8ffbb08249f3bf09791a", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 69, "deletions": 35, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac785173d96fc8d058ed817cf9286ddaf6d831a/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac785173d96fc8d058ed817cf9286ddaf6d831a/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=0ac785173d96fc8d058ed817cf9286ddaf6d831a", "patch": "@@ -449,8 +449,7 @@ print_operand (stream, x, code)\n       break;\n \n     case 'N':\n-      if (x == const0_rtx\n-\t  || (GET_CODE (x) == CONST_VECTOR && zero_vec_operand (x, VOIDmode)))\n+      if (x == CONST0_RTX (GET_MODE (x)))\n \t{\n \t  fprintf ((stream), \"r63\");\n \t  break;\n@@ -6121,6 +6120,25 @@ noncommutative_float_operator (op, mode)\n   return 0;\n }\n \n+int\n+unary_float_operator (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_MODE (op) != mode)\n+    return 0;\n+  switch (GET_CODE (op))\n+    {\n+    case ABS:\n+    case NEG:\n+    case SQRT:\n+      return 1;\n+    default:\n+      break;\n+    }\n+  return 0;\n+}\n+\n int\n binary_float_operator (op, mode)\n      rtx op;\n@@ -6285,23 +6303,6 @@ inqhi_operand (op, mode)\n   return GET_CODE (op) == REG && FP_REGISTER_P (REGNO (op));\n }\n \n-/* Return nonzero if V is a zero vector matching MODE.  */\n-int\n-zero_vec_operand (v, mode)\n-     rtx v;\n-     enum machine_mode mode;\n-{\n-  int i;\n-\n-  if (GET_CODE (v) != CONST_VECTOR\n-      || (GET_MODE (v) != mode && mode != VOIDmode))\n-    return 0;\n-  for (i = XVECLEN (v, 0) - 1; i >= 0; i--)\n-    if (XVECEXP (v, 0, i) != const0_rtx)\n-      return 0;\n-  return 1;\n-}\n-\n int\n sh_rep_vec (v, mode)\n      rtx v;\n@@ -7156,19 +7157,21 @@ static const char signature_args[][4] =\n   { 0, 8, 2 },\n #define SH_BLTIN_STUA_Q 14\n   { 0, 8, 1 },\n-#define SH_BLTIN_NUM_SHARED_SIGNATURES 15\n-#define SH_BLTIN_2 15\n-#define SH_BLTIN_SU 15\n+#define SH_BLTIN_UDI 15\n+  { 0, 8, 1 },\n+#define SH_BLTIN_NUM_SHARED_SIGNATURES 16\n+#define SH_BLTIN_2 16\n+#define SH_BLTIN_SU 16\n   { 1, 2 },\n-#define SH_BLTIN_3 16\n-#define SH_BLTIN_SUS 16\n+#define SH_BLTIN_3 17\n+#define SH_BLTIN_SUS 17\n   { 2, 2, 1 },\n-#define SH_BLTIN_PSSV 17\n+#define SH_BLTIN_PSSV 18\n   { 0, 8, 2, 2 },\n-#define SH_BLTIN_XXUU 18\n-#define SH_BLTIN_UUUU 18\n+#define SH_BLTIN_XXUU 19\n+#define SH_BLTIN_UUUU 19\n   { 1, 1, 1, 1 },\n-#define SH_BLTIN_PV 19\n+#define SH_BLTIN_PV 20\n   { 0, 8 },\n };\n /* mcmv: operands considered unsigned. */\n@@ -7200,13 +7203,13 @@ static const struct builtin_description bdesc[] =\n   { CODE_FOR_mcnvs_lw,\t\"__builtin_sh_media_MCNVS_LW\", SH_BLTIN_3 },\n   { CODE_FOR_mcnvs_wb,\t\"__builtin_sh_media_MCNVS_WB\", SH_BLTIN_V4HI2V8QI },\n   { CODE_FOR_mcnvs_wub,\t\"__builtin_sh_media_MCNVS_WUB\", SH_BLTIN_V4HI2V8QI },\n-  { CODE_FOR_mextr1,\t\"__builtin_sh_media_MEXTR1\", SH_BLTIN_V8QI3 },\n-  { CODE_FOR_mextr2,\t\"__builtin_sh_media_MEXTR2\", SH_BLTIN_V8QI3 },\n-  { CODE_FOR_mextr3,\t\"__builtin_sh_media_MEXTR3\", SH_BLTIN_V8QI3 },\n-  { CODE_FOR_mextr4,\t\"__builtin_sh_media_MEXTR4\", SH_BLTIN_V8QI3 },\n-  { CODE_FOR_mextr5,\t\"__builtin_sh_media_MEXTR5\", SH_BLTIN_V8QI3 },\n-  { CODE_FOR_mextr6,\t\"__builtin_sh_media_MEXTR6\", SH_BLTIN_V8QI3 },\n-  { CODE_FOR_mextr7,\t\"__builtin_sh_media_MEXTR7\", SH_BLTIN_V8QI3 },\n+  { CODE_FOR_mextr1,\t\"__builtin_sh_media_MEXTR1\", SH_BLTIN_UDI },\n+  { CODE_FOR_mextr2,\t\"__builtin_sh_media_MEXTR2\", SH_BLTIN_UDI },\n+  { CODE_FOR_mextr3,\t\"__builtin_sh_media_MEXTR3\", SH_BLTIN_UDI },\n+  { CODE_FOR_mextr4,\t\"__builtin_sh_media_MEXTR4\", SH_BLTIN_UDI },\n+  { CODE_FOR_mextr5,\t\"__builtin_sh_media_MEXTR5\", SH_BLTIN_UDI },\n+  { CODE_FOR_mextr6,\t\"__builtin_sh_media_MEXTR6\", SH_BLTIN_UDI },\n+  { CODE_FOR_mextr7,\t\"__builtin_sh_media_MEXTR7\", SH_BLTIN_UDI },\n   { CODE_FOR_mmacfx_wl,\t\"__builtin_sh_media_MMACFX_WL\", SH_BLTIN_MAC_HISI },\n   { CODE_FOR_mmacnfx_wl,\"__builtin_sh_media_MMACNFX_WL\", SH_BLTIN_MAC_HISI },\n   { CODE_FOR_mulv2si3,\t\"__builtin_mulv2si3\", SH_BLTIN_V2SI3, },\n@@ -7261,8 +7264,10 @@ static const struct builtin_description bdesc[] =\n   { CODE_FOR_sthi_q64,\t\"__builtin_sh_media_STHI_Q\", SH_BLTIN_STUA_Q },\n   { CODE_FOR_stlo_l64,\t\"__builtin_sh_media_STLO_L\", SH_BLTIN_STUA_L },\n   { CODE_FOR_stlo_q64,\t\"__builtin_sh_media_STLO_Q\", SH_BLTIN_STUA_Q },\n+#endif\n   { CODE_FOR_nsb,\t\"__builtin_sh_media_NSB\", SH_BLTIN_SU },\n   { CODE_FOR_byterev,\t\"__builtin_sh_media_BYTEREV\", SH_BLTIN_2 },\n+#if 0\n   { CODE_FOR_prefetch32,\"__builtin_sh_media_PREFO\", SH_BLTIN_PSSV },\n   { CODE_FOR_prefetch64,\"__builtin_sh_media_PREFO\", SH_BLTIN_PSSV }\n #endif\n@@ -7408,4 +7413,33 @@ sh_expand_builtin (exp, target, subtarget, mode, ignore)\n   emit_insn (pat);\n   return target;\n }\n+\n+void\n+sh_expand_unop_v2sf (code, op0, op1)\n+     enum rtx_code code;\n+     rtx op0, op1;\n+{\n+  rtx sel0 = const0_rtx;\n+  rtx sel1 = const1_rtx;\n+  rtx (*fn) (rtx, rtx, rtx, rtx, rtx) = gen_unary_sf_op;\n+  rtx op = gen_rtx_fmt_e (code, SFmode, op1);\n+\n+  emit_insn ((*fn) (op0, op1, op, sel0, sel0));\n+  emit_insn ((*fn) (op0, op1, op, sel1, sel1));\n+}\n+\n+void\n+sh_expand_binop_v2sf (code, op0, op1, op2)\n+     enum rtx_code code;\n+     rtx op0, op1, op2;\n+{\n+  rtx sel0 = const0_rtx;\n+  rtx sel1 = const1_rtx;\n+  rtx (*fn) (rtx, rtx, rtx, rtx, rtx, rtx, rtx) = gen_binary_sf_op;\n+  rtx op = gen_rtx_fmt_ee (code, SFmode, op1, op2);\n+\n+  emit_insn ((*fn) (op0, op1, op2, op, sel0, sel0, sel0));\n+  emit_insn ((*fn) (op0, op1, op2, op, sel1, sel1, sel1));\n+}\n+\n #include \"gt-sh.h\""}, {"sha": "c37b10c207e3da0ff3638e6b22cbb9a0a378f3f4", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 42, "deletions": 20, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac785173d96fc8d058ed817cf9286ddaf6d831a/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac785173d96fc8d058ed817cf9286ddaf6d831a/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=0ac785173d96fc8d058ed817cf9286ddaf6d831a", "patch": "@@ -106,6 +106,9 @@ do { \\\n       call_used_regs[MACH_REG] = 0;\t\t\t\t\t\\\n       call_used_regs[MACL_REG] = 0;\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n+  for (regno = FIRST_FP_REG + (TARGET_LITTLE_ENDIAN != 0);\t\t\\\n+       regno <= LAST_FP_REG; regno += 2)\t\t\t\t\\\n+    SET_HARD_REG_BIT (reg_class_contents[DF_HI_REGS], regno);\t\t\\\n   if (TARGET_SHMEDIA)\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       for (regno = FIRST_TARGET_REG; regno <= LAST_TARGET_REG; regno ++)\\\n@@ -893,13 +896,16 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n    would require a tertiary reload when reloading from / to memory,\n    and a secondary reload to reload from / to general regs; that\n    seems to be a loosing proposition.  */\n+/* We want to allow TImode FP regs so that when V4SFmode is loaded as TImode,\n+   it won't be ferried through GP registers first.  */\n #define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\\\n   (SPECIAL_REGISTER_P (REGNO) ? (MODE) == SImode \\\n    : (REGNO) == FPUL_REG ? (MODE) == SImode || (MODE) == SFmode\t\\\n    : FP_REGISTER_P (REGNO) && (MODE) == SFmode \\\n    ? 1 \\\n    : (MODE) == V2SFmode \\\n-   ? (FP_REGISTER_P (REGNO) && ((REGNO) - FIRST_FP_REG) % 2 == 0) \\\n+   ? ((FP_REGISTER_P (REGNO) && ((REGNO) - FIRST_FP_REG) % 2 == 0) \\\n+      || (TARGET_SHMEDIA && GENERAL_REGISTER_P (REGNO))) \\\n    : (MODE) == V4SFmode \\\n    ? (FP_REGISTER_P (REGNO) && ((REGNO) - FIRST_FP_REG) % 4 == 0) \\\n    : (MODE) == V16SFmode \\\n@@ -912,7 +918,7 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n       || ((TARGET_SH3E || TARGET_SHMEDIA) && (MODE) == SCmode) \\\n       || (((TARGET_SH4 && (MODE) == DFmode) || (MODE) == DCmode \\\n \t   || (TARGET_SHMEDIA && ((MODE) == DFmode || (MODE) == DImode \\\n-\t\t\t\t  || (MODE) == V2SFmode))) \\\n+\t\t\t\t  || (MODE) == V2SFmode || (MODE) == TImode))) \\\n \t  && (((REGNO) - FIRST_FP_REG) & 1) == 0)) \\\n    : XD_REGISTER_P (REGNO) \\\n    ? (MODE) == DFmode \\\n@@ -1106,6 +1112,7 @@ enum reg_class\n   GENERAL_REGS,\n   FP0_REGS,\n   FP_REGS,\n+  DF_HI_REGS,\n   DF_REGS,\n   FPSCR_REGS,\n   GENERAL_FP_REGS,\n@@ -1129,6 +1136,7 @@ enum reg_class\n   \"GENERAL_REGS\",\t\\\n   \"FP0_REGS\",\t\t\\\n   \"FP_REGS\",\t\t\\\n+  \"DF_HI_REGS\",\t\t\\\n   \"DF_REGS\",\t\t\\\n   \"FPSCR_REGS\",\t\t\\\n   \"GENERAL_FP_REGS\",\t\\\n@@ -1162,6 +1170,8 @@ enum reg_class\n   { 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000000 },\t\\\n /* FP_REGS:  */\t\t\t\t\t\t\t\t\\\n   { 0x00000000, 0x00000000, 0xffffffff, 0xffffffff, 0x00000000 },\t\\\n+/* DF_HI_REGS:  Initialized in CONDITIONAL_REGISTER_USAGE.  */\t\t\\\n+  { 0x00000000, 0x00000000, 0xffffffff, 0xffffffff, 0x0000ff00 },\t\\\n /* DF_REGS:  */\t\t\t\t\t\t\t\t\\\n   { 0x00000000, 0x00000000, 0xffffffff, 0xffffffff, 0x0000ff00 },\t\\\n /* FPSCR_REGS:  */\t\t\t\t\t\t\t\\\n@@ -1286,7 +1296,7 @@ extern const enum reg_class reg_class_from_letter[];\n \n #define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS,MODE,X) \\\n   ((((((CLASS) == FP_REGS || (CLASS) == FP0_REGS\t\t\t\\\n-\t|| (CLASS) == DF_REGS)\t\t\t\t\t\t\\\n+\t|| (CLASS) == DF_REGS || (CLASS) == DF_HI_REGS)\t\t\t\\\n       && (GET_CODE (X) == REG && GENERAL_OR_AP_REGISTER_P (REGNO (X))))\t\\\n      || (((CLASS) == GENERAL_REGS || (CLASS) == R0_REGS)\t\t\\\n \t && GET_CODE (X) == REG\t\t\t\t\t\t\\\n@@ -1301,9 +1311,6 @@ extern const enum reg_class reg_class_from_letter[];\n \t\t  || REGNO (X) == T_REG\t\t\t\t\t\\\n \t\t  || system_reg_operand (X, VOIDmode)))))\t\t\\\n    ? GENERAL_REGS\t\t\t\t\t\t\t\\\n-   : (((CLASS) == FP_REGS || (CLASS) == DF_REGS) && TARGET_SHMEDIA\t\\\n-      && immediate_operand ((X), (MODE)))\t\t\t\t\\\n-   ? GENERAL_REGS\t\t\t\t\t\t\t\\\n    : ((CLASS) == TARGET_REGS\t\t\t\t\t\t\\\n       || (TARGET_SHMEDIA && (CLASS) == SIBCALL_REGS))\t\t\t\\\n    ? ((target_operand ((X), (MODE))\t\t\t\t\t\\\n@@ -1312,10 +1319,14 @@ extern const enum reg_class reg_class_from_letter[];\n    : (((CLASS) == MAC_REGS || (CLASS) == PR_REGS)\t\t\t\\\n       && GET_CODE (X) == REG && ! GENERAL_REGISTER_P (REGNO (X))\t\\\n       && (CLASS) != REGNO_REG_CLASS (REGNO (X)))\t\t\t\\\n+   ? GENERAL_REGS\t\t\t\t\t\t\t\\\n+   : ((CLASS) != GENERAL_REGS && GET_CODE (X) == REG\t\t\t\\\n+      && TARGET_REGISTER_P (REGNO (X)))\t\t\t\t\t\\\n    ? GENERAL_REGS : NO_REGS)\n \n #define SECONDARY_INPUT_RELOAD_CLASS(CLASS,MODE,X)  \\\n-  ((((CLASS) == FP_REGS || (CLASS) == FP0_REGS || (CLASS) == DF_REGS)\t\\\n+  ((((CLASS) == FP_REGS || (CLASS) == FP0_REGS || (CLASS) == DF_REGS\t\\\n+     || (CLASS) == DF_HI_REGS)\t\t\t\t\t\t\\\n     && ! TARGET_SHMEDIA\t\t\t\t\t\t\t\\\n     && immediate_operand ((X), (MODE))\t\t\t\t\t\\\n     && ! ((fp_zero_operand (X) || fp_one_operand (X))\t\t\t\\\n@@ -1334,6 +1345,12 @@ extern const enum reg_class reg_class_from_letter[];\n       && ((GET_CODE (X) == REG && REGNO (X) >= FIRST_PSEUDO_REGISTER)\t\\\n \t  || (GET_CODE (X) == MEM && GET_CODE (XEXP ((X), 0)) == PLUS)))\\\n    ? GENERAL_REGS\t\t\t\t\t\t\t\\\n+   : (((CLASS) == FP_REGS || (CLASS) == DF_REGS || (CLASS) == DF_HI_REGS)\\\n+      && TARGET_SHMEDIA\t\t\t\t\t\t\t\\\n+      && immediate_operand ((X), (MODE))\t\t\t\t\\\n+      && (X) != CONST0_RTX (GET_MODE (X))\t\t\t\t\\\n+      && GET_MODE (X) != V4SFmode)\t\t\t\t\t\\\n+   ? GENERAL_REGS\t\t\t\t\t\t\t\\\n    : SECONDARY_OUTPUT_RELOAD_CLASS((CLASS),(MODE),(X)))\n \n /* Return the maximum number of consecutive registers\n@@ -1345,13 +1362,17 @@ extern const enum reg_class reg_class_from_letter[];\n \n /* If defined, gives a class of registers that cannot be used as the\n    operand of a SUBREG that changes the mode of the object illegally.  */\n+/* ??? We need to renumber the internal numbers for the frnn registers\n+   when in little endian in order to allow mode size changes.  */\n \n-#define CLASS_CANNOT_CHANGE_MODE        DF_REGS\n+#define CLASS_CANNOT_CHANGE_MODE (TARGET_LITTLE_ENDIAN ? DF_REGS : DF_HI_REGS)\n \n /* Defines illegal mode changes for CLASS_CANNOT_CHANGE_MODE.  */\n \n #define CLASS_CANNOT_CHANGE_MODE_P(FROM,TO) \\\n-  (GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO))\n+  (GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO) \\\n+   && ((TARGET_LITTLE_ENDIAN  && GET_MODE_SIZE (TO) < 8) \\\n+       || GET_MODE_SIZE (FROM) < 8))\n \f\n /* Stack layout; function entry, exit and calling.  */\n \n@@ -2192,7 +2213,8 @@ while (0)\n \n #define LEGITIMATE_CONSTANT_P(X) \\\n   (TARGET_SHMEDIA\t\t\t\t\t\t\t\\\n-   ? (GET_MODE (X) != DFmode\t\t\t\t\t\t\\\n+   ? ((GET_MODE (X) != DFmode\t\t\t\t\t\t\\\n+       && GET_MODE_CLASS (GET_MODE (X)) != MODE_VECTOR_FLOAT)\t\t\\\n       || (X) == CONST0_RTX (GET_MODE (X))\t\t\t\t\\\n       || ! TARGET_SHMEDIA_FPU\t\t\t\t\t\t\\\n       || TARGET_SHMEDIA64)\t\t\t\t\t\t\\\n@@ -2316,10 +2338,7 @@ while (0)\n \n /* A zero in any shape or form.  */\n #define EXTRA_CONSTRAINT_U(OP) \\\n-  ((OP) == const0_rtx \\\n-   || (GET_CODE (OP) == SUBREG && VECTOR_MODE_SUPPORTED_P(GET_MODE (OP)) \\\n-       && SUBREG_REG (OP) == const0_rtx && SUBREG_BYTE (OP) == 0) \\\n-   || GET_CODE (OP) == CONST_VECTOR && zero_vec_operand ((OP), VOIDmode))\n+  ((OP) == CONST0_RTX (GET_MODE (OP)))\n \n /* Any vector constant we can handle.  */\n #define EXTRA_CONSTRAINT_W(OP) \\\n@@ -2642,7 +2661,9 @@ while (0)\n    will either zero-extend or sign-extend.  The value of this macro should\n    be the code that says which one of the two operations is implicitly\n    done, NIL if none.  */\n-#define LOAD_EXTEND_OP(MODE) SIGN_EXTEND\n+/* FP registers can load SImode values, but don't implicitly sign-extend\n+   them to DImode.  */\n+#define LOAD_EXTEND_OP(MODE) ((MODE) != SImode ? SIGN_EXTEND : NIL)\n \n /* Define if loading short immediate values into registers sign extends.  */\n #define SHORT_IMMEDIATES_SIGN_EXTEND\n@@ -2821,12 +2842,13 @@ while (0)\n    register information here is not used for SFmode.  */\n #define REGISTER_MOVE_COST(MODE, SRCCLASS, DSTCLASS) \\\n  (((((DSTCLASS) == T_REGS) || ((DSTCLASS) == PR_REGS)) ? 10\t\t\\\n-   : ((((DSTCLASS) == FP0_REGS || (DSTCLASS) == FP_REGS || (DSTCLASS) == DF_REGS) \\\n+   : ((((DSTCLASS) == FP0_REGS || (DSTCLASS) == FP_REGS\t\t\t\\\n+\t|| (DSTCLASS) == DF_REGS || (DSTCLASS) == DF_HI_REGS)\t\t\\\n        && ((SRCCLASS) == GENERAL_REGS || (SRCCLASS) == R0_REGS))\t\\\n       || (((DSTCLASS) == GENERAL_REGS || (DSTCLASS) == R0_REGS)\t\t\\\n \t  && ((SRCCLASS) == FP0_REGS || (SRCCLASS) == FP_REGS\t\t\\\n-\t      || (SRCCLASS) == DF_REGS)))\t\t\t\t\\\n-   ? (TARGET_SHMEDIA ? 2\t\t\t\t\t\t\\\n+\t      || (SRCCLASS) == DF_REGS || (SRCCLASS) == DF_HI_REGS)))\t\\\n+   ? (TARGET_SHMEDIA ? 4\t\t\t\t\t\t\\\n       : TARGET_FMOVD ? 8 : 12)\t\t\t\t\t\t\\\n    : (((DSTCLASS) == FPUL_REGS\t\t\t\t\t\t\\\n        && ((SRCCLASS) == GENERAL_REGS || (SRCCLASS) == R0_REGS))\t\\\n@@ -3231,7 +3253,7 @@ extern int rtx_equal_function_value_matters;\n   {\"arith_reg_dest\", {SUBREG, REG}},\t\t\t\t\t\\\n   {\"arith_reg_operand\", {SUBREG, REG}},\t\t\t\t\t\\\n   {\"arith_reg_or_0_operand\", {SUBREG, REG, CONST_INT, CONST_VECTOR}},\t\\\n-  {\"binary_float_operator\", {PLUS, MULT}},\t\t\t\t\\\n+  {\"binary_float_operator\", {PLUS, MINUS, MULT, DIV}},\t\t\t\\\n   {\"commutative_float_operator\", {PLUS, MULT}},\t\t\t\t\\\n   {\"equality_comparison_operator\", {EQ,NE}},\t\t\t\t\\\n   {\"extend_reg_operand\", {SUBREG, REG, TRUNCATE}},\t\t\t\\\n@@ -3256,7 +3278,7 @@ extern int rtx_equal_function_value_matters;\n   {\"sh_1el_vec\", {CONST_VECTOR, PARALLEL}},\t\t\t\t\\\n   {\"sh_rep_vec\", {CONST_VECTOR, PARALLEL}},\t\t\t\t\\\n   {\"symbol_ref_operand\", {SYMBOL_REF}},\t\t\t\t\t\\\n-  {\"zero_vec_operand\", {CONST_VECTOR}},\n+  {\"unary_float_operator\", {ABS, NEG, SQRT}},\t\t\t\t\\\n \n /* Define this macro if it is advisable to hold scalars in registers\n    in a wider mode than that declared by the program.  In such cases, "}, {"sha": "c3ac6e1b41484f1f20413492026e4ec88b2ab045", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 283, "deletions": 122, "changes": 405, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac785173d96fc8d058ed817cf9286ddaf6d831a/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac785173d96fc8d058ed817cf9286ddaf6d831a/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=0ac785173d96fc8d058ed817cf9286ddaf6d831a", "patch": "@@ -1413,8 +1413,8 @@\n    (set (match_dup 6) (float:DF (match_dup 4)))\n    (set (match_dup 7) (div:DF (match_dup 5) (match_dup 6)))\n    (set (match_dup 8) (fix:DI (match_dup 7)))\n-   (set (subreg:DI (match_operand:SI 0 \"register_operand\" \"=r\") 0)\n-\t(sign_extend:DI (match_dup 9)))]\n+   (set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(truncate:SI (match_dup 8)))]\n   \"TARGET_SHMEDIA_FPU\"\n   \"\n {\n@@ -1424,7 +1424,6 @@\n   operands[6] = gen_reg_rtx (DFmode);\n   operands[7] = gen_reg_rtx (DFmode);\n   operands[8] = gen_reg_rtx (DImode);\n-  operands[9] = gen_lowpart_common (SImode, operands[8]);\n }\")\n \n (define_insn \"udivsi3_i4\"\n@@ -3361,7 +3360,7 @@\n    patterns, but unary operators are ignored when matching constraints,\n    so we need separate patterns.  */\n (define_insn \"truncdisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,m,m,f,r,f\")\n+  [(set (match_operand:SI 0 \"general_movdst_operand\" \"=r,m,m,f,r,f\")\n \t(truncate:SI (match_operand:DI 1 \"register_operand\" \"r,r,f,r,f,f\")))]\n   \"TARGET_SHMEDIA\"\n   \"@\n@@ -3375,7 +3374,7 @@\n \n \n (define_insn \"truncdihi2\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=?r,m\")\n+  [(set (match_operand:HI 0 \"general_movdst_operand\" \"=?r,m\")\n \t(truncate:HI (match_operand:DI 1 \"register_operand\" \"r,r\")))]\n   \"TARGET_SHMEDIA\"\n   \"@\n@@ -3384,12 +3383,17 @@\n   [(set_attr \"type\"   \"arith_media,store_media\")\n    (set_attr \"length\" \"8,4\")])\n \n+; N.B. we want sign-extension here because\n+; - we need to be consistent with LOAD_EXTEND_OP and movqi\n+; - only sign extension allows us to do signed compares transparently.\n+;  unsigned compares don't care about the kind of extension as long as\n+;   it's consistent.\n (define_insn \"truncdiqi2\"\n   [(set (match_operand:QI 0 \"general_movdst_operand\" \"=r,m\")\n \t(truncate:QI (match_operand:DI 1 \"register_operand\" \"r,r\")))]\n   \"TARGET_SHMEDIA\"\n   \"@\n-\tandi\t%1, 255, %0\n+\tori\t%1, -256, %0\n \tst%M0.b\t%m0, %1\"\n   [(set_attr \"type\"   \"arith_media,store\")])\n \n@@ -3558,7 +3562,7 @@\n \n (define_insn \"*movsi_media\"\n   [(set (match_operand:SI 0 \"general_movdst_operand\" \"=r,r,r,r,m,f,m,f,r,f,*b,r,b\")\n-\t(match_operand:SI 1 \"general_movsrc_operand\" \"r,JS,ns,m,r,m,f,r,f,f,r,*b,T\"))]\n+\t(match_operand:SI 1 \"general_movsrc_operand\" \"r,JS,ns,m,r,m,f,rU,f,f,r,*b,T\"))]\n   \"TARGET_SHMEDIA_FPU\n    && (register_operand (operands[0], SImode)\n        || register_operand (operands[1], SImode))\"\n@@ -3570,7 +3574,7 @@\n \tst%M0.l\t%m0, %1\n \tfld%M1.s\t%m1, %0\n \tfst%M0.s\t%m0, %1\n-\tfmov.ls\t%1, %0\n+\tfmov.ls\t%N1, %0\n \tfmov.sl\t%1, %0\n \tfmov.s\t%1, %0\n \tptabs\t%1, %0\n@@ -3856,7 +3860,7 @@\n \n (define_insn \"*movdi_media\"\n   [(set (match_operand:DI 0 \"general_movdst_operand\" \"=r,r,r,rl,m,f,m,f,r,f,*b,r,b\")\n-\t(match_operand:DI 1 \"general_movsrc_operand\" \"r,JS,iF,m,rl,m,f,r,f,f,r,*b,T\"))]\n+\t(match_operand:DI 1 \"general_movsrc_operand\" \"r,JS,iF,m,rl,m,f,rU,f,f,r,*b,T\"))]\n   \"TARGET_SHMEDIA_FPU\n    && (register_operand (operands[0], DImode)\n        || register_operand (operands[1], DImode))\"\n@@ -3868,7 +3872,7 @@\n \tst%M0.q\t%m0, %1\n \tfld%M1.d\t%m1, %0\n \tfst%M0.d\t%m0, %1\n-\tfmov.qd\t%1, %0\n+\tfmov.qd\t%N1, %0\n \tfmov.dq\t%1, %0\n \tfmov.d\t%1, %0\n \tptabs\t%1, %0\n@@ -4162,13 +4166,13 @@\n \n (define_insn \"movdf_media\"\n   [(set (match_operand:DF 0 \"general_movdst_operand\" \"=f,f,r,r,r,f,m,r,m\")\n-\t(match_operand:DF 1 \"general_movsrc_operand\" \"f,r,f,r,F,m,f,m,r\"))]\n+\t(match_operand:DF 1 \"general_movsrc_operand\" \"f,rU,f,r,F,m,f,m,r\"))]\n   \"TARGET_SHMEDIA_FPU\n    && (register_operand (operands[0], DFmode)\n        || register_operand (operands[1], DFmode))\"\n   \"@\n \tfmov.d\t%1, %0\n-\tfmov.qd\t%1, %0\n+\tfmov.qd\t%N1, %0\n \tfmov.dq\t%1, %0\n \tadd\t%1, r63, %0\n \t#\n@@ -4689,39 +4693,89 @@\n     }\n }\")\n \n-(define_insn \"movv2sf_i\"\n-  [(set (match_operand:V2SF 0 \"nonimmediate_operand\" \"=f,f,m\")\n-\t(match_operand:V2SF 1 \"nonimmediate_operand\" \"f,m,f\"))]\n-  \"TARGET_SHMEDIA_FPU\n-   && (fp_arith_reg_operand (operands[0], V2SFmode)\n-       || fp_arith_reg_operand (operands[1], V2SFmode))\"\n-  \"@\n-\t#\n-\tfld%M1.p\t%m1, %0\n-\tfst%M0.p\t%m0, %1\"\n-  [(set_attr \"type\" \"*,fload_media,fstore_media\")])\n-\n-(define_split\n-  [(set (match_operand:V2SF 0 \"nonimmediate_operand\" \"=f\")\n-\t(match_operand:V2SF 1 \"nonimmediate_operand\" \"f\"))]\n-  \"TARGET_SHMEDIA_FPU && reload_completed\n-   && fp_arith_reg_operand (operands[0], V2SFmode)\n-   && fp_arith_reg_operand (operands[1], V2SFmode)\"\n-  [(set (subreg:DF (match_dup 0) 0) (subreg:DF (match_dup 1) 0))])\n+;;This is incompatible with the way gcc uses subregs.\n+;;(define_insn \"movv2sf_i\"\n+;;  [(set (match_operand:V2SF 0 \"nonimmediate_operand\" \"=f,f,m\")\n+;;\t(match_operand:V2SF 1 \"nonimmediate_operand\" \"f,m,f\"))]\n+;;  \"TARGET_SHMEDIA_FPU\n+;;   && (fp_arith_reg_operand (operands[0], V2SFmode)\n+;;       || fp_arith_reg_operand (operands[1], V2SFmode))\"\n+;;  \"@\n+;;\t#\n+;;\tfld%M1.p\t%m1, %0\n+;;\tfst%M0.p\t%m0, %1\"\n+;;  [(set_attr \"type\" \"*,fload_media,fstore_media\")])\n+\n+(define_insn_and_split \"movv2sf_i\"\n+  [(set (match_operand:V2SF 0 \"general_movdst_operand\" \"=f,rf,r,m,mf\")\n+\t(match_operand:V2SF 1 \"general_operand\" \"fm,rfm?,F?,f,rfU?\"))]\n+  \"TARGET_SHMEDIA_FPU\"\n+  \"#\"\n+  \"TARGET_SHMEDIA_FPU && reload_completed\"\n+  [(set (match_dup 0) (match_dup 1))]\n+  \"\n+{\n+  operands[0] = simplify_gen_subreg (DFmode, operands[0], V2SFmode, 0);\n+  operands[1] = simplify_gen_subreg (DFmode, operands[1], V2SFmode, 0);\n+}\")\n \n (define_expand \"movv2sf\"\n-  [(set (match_operand:V2SF 0 \"nonimmediate_operand\" \"=f,f,m\")\n-\t(match_operand:V2SF 1 \"nonimmediate_operand\" \"f,m,f\"))]\n+  [(set (match_operand:V2SF 0 \"general_movdst_operand\" \"\")\n+\t(match_operand:V2SF 1 \"nonimmediate_operand\" \"\"))]\n   \"TARGET_SHMEDIA_FPU\"\n   \"\n {\n   if (prepare_move_operands (operands, V2SFmode))\n     DONE;\n }\")\n \n+(define_expand \"addv2sf3\"\n+  [(match_operand:V2SF 0 \"fp_arith_reg_operand\" \"\")\n+   (match_operand:V2SF 1 \"fp_arith_reg_operand\" \"\")\n+   (match_operand:V2SF 2 \"fp_arith_reg_operand\" \"\")]\n+  \"TARGET_SHMEDIA_FPU\"\n+  \"\n+{\n+  sh_expand_binop_v2sf (PLUS, operands[0], operands[1], operands[2]);\n+  DONE;\n+}\")\n+\n+(define_expand \"subv2sf3\"\n+  [(match_operand:V2SF 0 \"fp_arith_reg_operand\" \"\")\n+   (match_operand:V2SF 1 \"fp_arith_reg_operand\" \"\")\n+   (match_operand:V2SF 2 \"fp_arith_reg_operand\" \"\")]\n+  \"TARGET_SHMEDIA_FPU\"\n+  \"\n+{\n+  sh_expand_binop_v2sf (MINUS, operands[0], operands[1], operands[2]);\n+  DONE;\n+}\")\n+\n+(define_expand \"mulv2sf3\"\n+  [(match_operand:V2SF 0 \"fp_arith_reg_operand\" \"\")\n+   (match_operand:V2SF 1 \"fp_arith_reg_operand\" \"\")\n+   (match_operand:V2SF 2 \"fp_arith_reg_operand\" \"\")]\n+  \"TARGET_SHMEDIA_FPU\"\n+  \"\n+{\n+  sh_expand_binop_v2sf (MULT, operands[0], operands[1], operands[2]);\n+  DONE;\n+}\")\n+\n+(define_expand \"divv2sf3\"\n+  [(match_operand:V2SF 0 \"fp_arith_reg_operand\" \"\")\n+   (match_operand:V2SF 1 \"fp_arith_reg_operand\" \"\")\n+   (match_operand:V2SF 2 \"fp_arith_reg_operand\" \"\")]\n+  \"TARGET_SHMEDIA_FPU\"\n+  \"\n+{\n+  sh_expand_binop_v2sf (DIV, operands[0], operands[1], operands[2]);\n+  DONE;\n+}\")\n+\n (define_insn_and_split \"*movv4sf_i\"\n   [(set (match_operand:V4SF 0 \"nonimmediate_operand\" \"=f,f,m\")\n-\t(match_operand:V4SF 1 \"nonimmediate_operand\" \"f,m,f\"))]\n+\t(match_operand:V4SF 1 \"general_operand\" \"fU,m,f\"))]\n   \"TARGET_SHMEDIA_FPU\"\n   \"#\"\n   \"&& reload_completed\"\n@@ -4739,20 +4793,14 @@\n \t\t\t plus_constant (XEXP (operands[0], 0),\n \t\t\t\t\ti * GET_MODE_SIZE (V2SFmode)));\n       else\n-\t{\n-\t  x = gen_rtx_SUBREG (V2SFmode, operands[0], i * 2);\n-\t  alter_subreg (&x);\n-\t}\n+\tx = simplify_gen_subreg (V2SFmode, operands[0], V4SFmode, i * 8);\n \n       if (GET_CODE (operands[1]) == MEM)\n \ty = gen_rtx_MEM (V2SFmode,\n \t\t\t plus_constant (XEXP (operands[1], 0),\n \t\t\t\t\ti * GET_MODE_SIZE (V2SFmode)));\n       else\n-\t{\n-\t  y = gen_rtx_SUBREG (V2SFmode, operands[1], i * 2);\n-\t  alter_subreg (&y);\n-\t}\n+\ty = simplify_gen_subreg (V2SFmode, operands[1], V4SFmode, i * 8);\n \n       emit_insn (gen_movv2sf_i (x, y));\n     }\n@@ -4762,8 +4810,8 @@\n   [(set_attr \"length\" \"8\")])\n \n (define_expand \"movv4sf\"\n-  [(set (match_operand:V4SF 0 \"nonimmediate_operand\" \"=f,f,m\")\n-\t(match_operand:V4SF 1 \"nonimmediate_operand\" \"f,m,f\"))]\n+  [(set (match_operand:V4SF 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:V4SF 1 \"general_operand\" \"\"))]\n   \"TARGET_SHMEDIA_FPU\"\n   \"\n {\n@@ -4825,13 +4873,13 @@\n \n (define_insn \"movsf_media\"\n   [(set (match_operand:SF 0 \"general_movdst_operand\" \"=f,f,r,r,r,f,m,r,m\")\n-\t(match_operand:SF 1 \"general_movsrc_operand\" \"f,r,f,r,F,m,f,m,r\"))]\n+\t(match_operand:SF 1 \"general_movsrc_operand\" \"f,rU,f,r,F,m,f,m,r\"))]\n   \"TARGET_SHMEDIA_FPU\n    && (register_operand (operands[0], SFmode)\n        || register_operand (operands[1], SFmode))\"\n   \"@\n \tfmov.s\t%1, %0\n-\tfmov.ls\t%1, %0\n+\tfmov.ls\t%N1, %0\n \tfmov.sl\t%1, %0\n \tadd.l\t%1, r63, %0\n \t#\n@@ -4857,7 +4905,8 @@\n (define_split\n   [(set (match_operand:SF 0 \"arith_reg_operand\" \"\")\n \t(match_operand:SF 1 \"immediate_operand\" \"\"))]\n-  \"TARGET_SHMEDIA && reload_completed\"\n+  \"TARGET_SHMEDIA && reload_completed\n+   && ! FP_REGISTER_P (true_regnum (operands[0]))\"\n   [(set (match_dup 3) (match_dup 2))]\n   \"\n {\n@@ -8041,6 +8090,72 @@\n   \"fadd.s\t%1, %2, %0\"\n   [(set_attr \"type\" \"fparith_media\")])\n \n+(define_insn_and_split \"unary_sf_op\"\n+  [(set (match_operand:V2SF 0 \"fp_arith_reg_operand\" \"=f\")\n+\t(vec_select:V2SF\n+\t (vec_concat:V2SF\n+\t  (vec_select:SF\n+\t   (match_dup 0)\n+\t   (parallel [(not:BI (match_operand 3 \"const_int_operand\" \"n\"))]))\n+\t  (match_operator:SF 2 \"unary_float_operator\"\n+\t    [(vec_select:SF (match_operand:V2SF 1 \"fp_arith_reg_operand\" \"f\")\n+\t\t\t    (parallel [(match_operand 4\n+\t\t\t\t\t\"const_int_operand\" \"n\")]))]))\n+\t (parallel [(not:BI (match_dup 3)) (match_dup 3)])))]\n+  \"TARGET_SHMEDIA_FPU\"\n+  \"#\"\n+  \"TARGET_SHMEDIA_FPU && reload_completed\"\n+  [(set (match_dup 5) (match_dup 6))]\n+  \"\n+{\n+  int endian = TARGET_LITTLE_ENDIAN ? 0 : 1;\n+  rtx op1 = gen_rtx_REG (SFmode,\n+\t\t\t (true_regnum (operands[1])\n+\t\t\t  + (INTVAL (operands[4]) ^ endian)));\n+\n+  operands[7] = gen_rtx_REG (SFmode,\n+\t\t\t     (true_regnum (operands[0])\n+\t\t\t      + (INTVAL (operands[3]) ^ endian)));\n+  operands[6] = gen_rtx (GET_CODE (operands[2]), SFmode, op1);\n+}\"\n+  [(set_attr \"type\" \"fparith_media\")])\n+\n+(define_insn_and_split \"binary_sf_op\"\n+  [(set (match_operand:V2SF 0 \"fp_arith_reg_operand\" \"=f\")\n+\t(vec_select:V2SF\n+\t (vec_concat:V2SF\n+\t  (vec_select:SF\n+\t   (match_dup 0)\n+\t   (parallel [(not:BI (match_operand 4 \"const_int_operand\" \"n\"))]))\n+\t  (match_operator:SF 3 \"binary_float_operator\"\n+\t    [(vec_select:SF (match_operand:V2SF 1 \"fp_arith_reg_operand\" \"f\")\n+\t\t\t    (parallel [(match_operand 5\n+\t\t\t\t\t\"const_int_operand\" \"n\")]))\n+\t     (vec_select:SF (match_operand:V2SF 2 \"fp_arith_reg_operand\" \"f\")\n+\t\t\t    (parallel [(match_operand 6\n+\t\t\t\t\t\"const_int_operand\" \"n\")]))]))\n+\t (parallel [(not:BI (match_dup 4)) (match_dup 4)])))]\n+  \"TARGET_SHMEDIA_FPU\"\n+  \"#\"\n+  \"TARGET_SHMEDIA_FPU && reload_completed\"\n+  [(set (match_dup 7) (match_dup 8))]\n+  \"\n+{\n+  int endian = TARGET_LITTLE_ENDIAN ? 0 : 1;\n+  rtx op1 = gen_rtx_REG (SFmode,\n+\t\t\t (true_regnum (operands[1])\n+\t\t\t  + (INTVAL (operands[5]) ^ endian)));\n+  rtx op2 = gen_rtx_REG (SFmode,\n+\t\t\t (true_regnum (operands[2])\n+\t\t\t  + (INTVAL (operands[6]) ^ endian)));\n+\n+  operands[7] = gen_rtx_REG (SFmode,\n+\t\t\t     (true_regnum (operands[0])\n+\t\t\t      + (INTVAL (operands[4]) ^ endian)));\n+  operands[8] = gen_rtx (GET_CODE (operands[3]), SFmode, op1, op2);\n+}\"\n+  [(set_attr \"type\" \"fparith_media\")])\n+\n (define_insn \"addsf3_i\"\n   [(set (match_operand:SF 0 \"arith_reg_operand\" \"=f\")\n \t(plus:SF (match_operand:SF 1 \"arith_reg_operand\" \"%0\")\n@@ -9228,7 +9343,7 @@\n   \"TARGET_SHMEDIA && reload_completed\n    && GET_MODE (operands[0]) == GET_MODE (operands[1])\n    && VECTOR_MODE_SUPPORTED_P (GET_MODE (operands[0]))\n-   && ! zero_vec_operand (operands[1], VOIDmode)\"\n+   && operands[1] != CONST0_RTX (GET_MODE (operands[1]))\"\n   [(set (match_dup 0) (match_dup 1))]\n   \"\n {\n@@ -9482,85 +9597,85 @@\n ; mextrN can be modelled with vec_select / vec_concat, but the selection\n ; vector then varies depending on endianness.\n (define_expand \"mextr1\"\n-  [(match_operand:V8QI 0 \"arith_reg_dest\" \"\")\n-   (match_operand:V8QI 1 \"arith_reg_or_0_operand\" \"rU\")\n-   (match_operand:V8QI 2 \"arith_reg_or_0_operand\" \"rU\")]\n+  [(match_operand:DI 0 \"arith_reg_dest\" \"\")\n+   (match_operand:DI 1 \"arith_reg_or_0_operand\" \"rU\")\n+   (match_operand:DI 2 \"arith_reg_or_0_operand\" \"rU\")]\n   \"TARGET_SHMEDIA\"\n   \"\n {\n-  emit_insn (gen_mextr_rl (operands[0], operands[1], operands[3],\n+  emit_insn (gen_mextr_rl (operands[0], operands[1], operands[2],\n \t\t\t   GEN_INT (1 * 8), GEN_INT (7 * 8)));\n   DONE;\n }\")\n \n (define_expand \"mextr2\"\n-  [(match_operand:V8QI 0 \"arith_reg_dest\" \"\")\n-   (match_operand:V8QI 1 \"arith_reg_or_0_operand\" \"rU\")\n-   (match_operand:V8QI 2 \"arith_reg_or_0_operand\" \"rU\")]\n+  [(match_operand:DI 0 \"arith_reg_dest\" \"\")\n+   (match_operand:DI 1 \"arith_reg_or_0_operand\" \"rU\")\n+   (match_operand:DI 2 \"arith_reg_or_0_operand\" \"rU\")]\n   \"TARGET_SHMEDIA\"\n   \"\n {\n-  emit_insn (gen_mextr_rl (operands[0], operands[1], operands[3],\n+  emit_insn (gen_mextr_rl (operands[0], operands[1], operands[2],\n \t\t\t   GEN_INT (2 * 8), GEN_INT (6 * 8)));\n   DONE;\n }\")\n \n (define_expand \"mextr3\"\n-  [(match_operand:V8QI 0 \"arith_reg_dest\" \"\")\n-   (match_operand:V8QI 1 \"arith_reg_or_0_operand\" \"rU\")\n-   (match_operand:V8QI 2 \"arith_reg_or_0_operand\" \"rU\")]\n+  [(match_operand:DI 0 \"arith_reg_dest\" \"\")\n+   (match_operand:DI 1 \"arith_reg_or_0_operand\" \"rU\")\n+   (match_operand:DI 2 \"arith_reg_or_0_operand\" \"rU\")]\n   \"TARGET_SHMEDIA\"\n   \"\n {\n-  emit_insn (gen_mextr_rl (operands[0], operands[1], operands[3],\n+  emit_insn (gen_mextr_rl (operands[0], operands[1], operands[2],\n \t\t\t   GEN_INT (3 * 8), GEN_INT (5 * 8)));\n   DONE;\n }\")\n \n (define_expand \"mextr4\"\n-  [(match_operand:V8QI 0 \"arith_reg_dest\" \"\")\n-   (match_operand:V8QI 1 \"arith_reg_or_0_operand\" \"rU\")\n-   (match_operand:V8QI 2 \"arith_reg_or_0_operand\" \"rU\")]\n+  [(match_operand:DI 0 \"arith_reg_dest\" \"\")\n+   (match_operand:DI 1 \"arith_reg_or_0_operand\" \"rU\")\n+   (match_operand:DI 2 \"arith_reg_or_0_operand\" \"rU\")]\n   \"TARGET_SHMEDIA\"\n   \"\n {\n-  emit_insn (gen_mextr_rl (operands[0], operands[1], operands[3],\n+  emit_insn (gen_mextr_rl (operands[0], operands[1], operands[2],\n \t\t\t   GEN_INT (4 * 8), GEN_INT (4 * 8)));\n   DONE;\n }\")\n \n (define_expand \"mextr5\"\n-  [(match_operand:V8QI 0 \"arith_reg_dest\" \"\")\n-   (match_operand:V8QI 1 \"arith_reg_or_0_operand\" \"rU\")\n-   (match_operand:V8QI 2 \"arith_reg_or_0_operand\" \"rU\")]\n+  [(match_operand:DI 0 \"arith_reg_dest\" \"\")\n+   (match_operand:DI 1 \"arith_reg_or_0_operand\" \"rU\")\n+   (match_operand:DI 2 \"arith_reg_or_0_operand\" \"rU\")]\n   \"TARGET_SHMEDIA\"\n   \"\n {\n-  emit_insn (gen_mextr_rl (operands[0], operands[1], operands[3],\n+  emit_insn (gen_mextr_rl (operands[0], operands[1], operands[2],\n \t\t\t   GEN_INT (5 * 8), GEN_INT (3 * 8)));\n   DONE;\n }\")\n \n (define_expand \"mextr6\"\n-  [(match_operand:V8QI 0 \"arith_reg_dest\" \"\")\n-   (match_operand:V8QI 1 \"arith_reg_or_0_operand\" \"rU\")\n-   (match_operand:V8QI 2 \"arith_reg_or_0_operand\" \"rU\")]\n+  [(match_operand:DI 0 \"arith_reg_dest\" \"\")\n+   (match_operand:DI 1 \"arith_reg_or_0_operand\" \"rU\")\n+   (match_operand:DI 2 \"arith_reg_or_0_operand\" \"rU\")]\n   \"TARGET_SHMEDIA\"\n   \"\n {\n-  emit_insn (gen_mextr_rl (operands[0], operands[1], operands[3],\n+  emit_insn (gen_mextr_rl (operands[0], operands[1], operands[2],\n \t\t\t   GEN_INT (6 * 8), GEN_INT (2 * 8)));\n   DONE;\n }\")\n \n (define_expand \"mextr7\"\n-  [(match_operand:V8QI 0 \"arith_reg_dest\" \"\")\n-   (match_operand:V8QI 1 \"arith_reg_or_0_operand\" \"rU\")\n-   (match_operand:V8QI 2 \"arith_reg_or_0_operand\" \"rU\")]\n+  [(match_operand:DI 0 \"arith_reg_dest\" \"\")\n+   (match_operand:DI 1 \"arith_reg_or_0_operand\" \"rU\")\n+   (match_operand:DI 2 \"arith_reg_or_0_operand\" \"rU\")]\n   \"TARGET_SHMEDIA\"\n   \"\n {\n-  emit_insn (gen_mextr_rl (operands[0], operands[1], operands[3],\n+  emit_insn (gen_mextr_rl (operands[0], operands[1], operands[2],\n \t\t\t   GEN_INT (7 * 8), GEN_INT (1 * 8)));\n   DONE;\n }\")\n@@ -9705,7 +9820,7 @@\n \t (mult:V4SI\n \t  (sign_extend:V4SI (match_operand:V4HI 1 \"arith_reg_operand\" \"r\"))\n \t  (sign_extend:V4SI (match_operand:V4HI 2 \"arith_reg_operand\" \"r\")))\n-\t (const_vector [(const_int 2) (const_int 3)])))]\n+\t (parallel [(const_int 2) (const_int 3)])))]\n   \"TARGET_SHMEDIA\"\n   \"* return (TARGET_LITTLE_ENDIAN\n \t     ? \\\"mmulhi.wl\t%1, %2, %0\\\"\n@@ -9718,7 +9833,7 @@\n \t (mult:V4SI\n \t  (sign_extend:V4SI (match_operand:V4HI 1 \"arith_reg_operand\" \"r\"))\n \t  (sign_extend:V4SI (match_operand:V4HI 2 \"arith_reg_operand\" \"r\")))\n-\t (const_vector [(const_int 0) (const_int 1)])))]\n+\t (parallel [(const_int 0) (const_int 1)])))]\n   \"TARGET_SHMEDIA\"\n   \"* return (TARGET_LITTLE_ENDIAN\n \t     ? \\\"mmullo.wl\t%1, %2, %0\\\"\n@@ -9747,17 +9862,17 @@\n \t    (mult:V4DI\n \t     (sign_extend:V4DI (match_operand:V4HI 2 \"arith_reg_operand\" \"r\"))\n \t     (sign_extend:V4DI (match_operand:V4HI 3 \"arith_reg_operand\" \"r\")))\n-\t    (const_vector [(const_int 0)]))\n+\t    (parallel [(const_int 0)]))\n \t   (vec_select:DI (mult:V4DI (sign_extend:V4DI (match_dup 2))\n \t\t\t\t     (sign_extend:V4DI (match_dup 3)))\n-\t\t\t  (const_vector [(const_int 1)])))\n+\t\t\t  (parallel [(const_int 1)])))\n \t  (plus:DI\n \t   (vec_select:DI (mult:V4DI (sign_extend:V4DI (match_dup 2))\n \t\t\t\t     (sign_extend:V4DI (match_dup 3)))\n-\t\t\t  (const_vector [(const_int 2)]))\n+\t\t\t  (parallel [(const_int 2)]))\n \t   (vec_select:DI (mult:V4DI (sign_extend:V4DI (match_dup 2))\n \t\t\t\t     (sign_extend:V4DI (match_dup 3)))\n-\t\t\t  (const_vector [(const_int 3)]))))))]\n+\t\t\t  (parallel [(const_int 3)]))))))]\n   \"TARGET_SHMEDIA\"\n   \"mmulsum.wq\t%2, %3, %0\"\n   [(set_attr \"type\" \"mac_media\")])\n@@ -9838,32 +9953,32 @@\n \t\t       (match_operand:V8QI 2 \"arith_reg_or_0_operand\" \"r\"))\n \t\t      (zero_extend:V8DI\n \t\t       (match_operand:V8QI 3 \"arith_reg_or_0_operand\" \"r\")))\n-\t\t     (const_vector [(const_int 0)]))))\n+\t\t     (parallel [(const_int 0)]))))\n \t   (abs:DI (vec_select:DI (minus:V8DI (zero_extend:V8DI (match_dup 2))\n \t\t\t\t\t      (zero_extend:V8DI (match_dup 3)))\n-\t\t\t\t  (const_vector [(const_int 1)]))))\n+\t\t\t\t  (parallel [(const_int 1)]))))\n \t  (plus:DI\n \t   (abs:DI (vec_select:DI (minus:V8DI (zero_extend:V8DI (match_dup 2))\n \t\t\t\t\t      (zero_extend:V8DI (match_dup 3)))\n-\t\t\t\t  (const_vector [(const_int 2)])))\n+\t\t\t\t  (parallel [(const_int 2)])))\n \t   (abs:DI (vec_select:DI (minus:V8DI (zero_extend:V8DI (match_dup 2))\n \t\t\t\t\t      (zero_extend:V8DI (match_dup 3)))\n-\t\t\t\t  (const_vector [(const_int 3)])))))\n+\t\t\t\t  (parallel [(const_int 3)])))))\n \t (plus:DI\n \t  (plus:DI\n \t   (abs:DI (vec_select:DI (minus:V8DI (zero_extend:V8DI (match_dup 2))\n \t\t\t\t\t      (zero_extend:V8DI (match_dup 3)))\n-\t\t\t\t  (const_vector [(const_int 4)])))\n+\t\t\t\t  (parallel [(const_int 4)])))\n \t   (abs:DI (vec_select:DI (minus:V8DI (zero_extend:V8DI (match_dup 2))\n \t\t\t\t\t      (zero_extend:V8DI (match_dup 3)))\n-\t\t\t\t  (const_vector [(const_int 5)]))))\n+\t\t\t\t  (parallel [(const_int 5)]))))\n \t  (plus:DI\n \t   (abs:DI (vec_select:DI (minus:V8DI (zero_extend:V8DI (match_dup 2))\n \t\t\t\t\t      (zero_extend:V8DI (match_dup 3)))\n-\t\t\t\t  (const_vector [(const_int 6)])))\n+\t\t\t\t  (parallel [(const_int 6)])))\n \t   (abs:DI (vec_select:DI (minus:V8DI (zero_extend:V8DI (match_dup 2))\n \t\t\t\t\t      (zero_extend:V8DI (match_dup 3)))\n-\t\t\t\t  (const_vector [(const_int 7)])))))))]\n+\t\t\t\t  (parallel [(const_int 7)])))))))]\n   \"TARGET_SHMEDIA\"\n   \"msad.ubq\t%N2, %N3, %0\"\n   [(set_attr \"type\" \"mac_media\")])\n@@ -9945,8 +10060,8 @@\n     (vec_select:V8QI\n      (vec_concat:V16QI (match_operand:V8QI 1 \"arith_reg_or_0_operand\" \"rU\")\n \t\t       (match_operand:V8QI 2 \"arith_reg_or_0_operand\" \"rU\"))\n-     (const_vector [(const_int 4) (const_int 12) (const_int 5) (const_int 13)\n-\t\t    (const_int 6) (const_int 14) (const_int 7) (const_int 15)])))]\n+     (parallel [(const_int 4) (const_int 12) (const_int 5) (const_int 13)\n+\t\t(const_int 6) (const_int 14) (const_int 7) (const_int 15)])))]\n   \"TARGET_SHMEDIA\"\n   \"* return (TARGET_LITTLE_ENDIAN\n \t     ? \\\"mshfhi.b\t%N1, %N2, %0\\\"\n@@ -9959,8 +10074,8 @@\n     (vec_select:V8QI\n      (vec_concat:V16QI (match_operand:V8QI 1 \"arith_reg_or_0_operand\" \"rU\")\n \t\t       (match_operand:V8QI 2 \"arith_reg_or_0_operand\" \"rU\"))\n-     (const_vector [(const_int 0) (const_int 8) (const_int 1) (const_int 9)\n-\t\t    (const_int 2) (const_int 10) (const_int 3) (const_int 11)])))]\n+     (parallel [(const_int 0) (const_int 8) (const_int 1) (const_int 9)\n+\t\t(const_int 2) (const_int 10) (const_int 3) (const_int 11)])))]\n   \"TARGET_SHMEDIA\"\n   \"* return (TARGET_LITTLE_ENDIAN\n \t     ? \\\"mshflo.b\t%N1, %N2, %0\\\"\n@@ -9996,7 +10111,7 @@\n \t(vec_select:V2SI\n \t (vec_concat:V4SI (match_operand:V2SI 1 \"arith_reg_or_0_operand\" \"rU\")\n \t\t\t  (match_operand:V2SI 2 \"arith_reg_or_0_operand\" \"rU\"))\n-\t (const_vector [(const_int 1) (const_int 3)])))]\n+\t (parallel [(const_int 1) (const_int 3)])))]\n   \"TARGET_SHMEDIA\"\n   \"* return (TARGET_LITTLE_ENDIAN\n \t     ? \\\"mshfhi.l\t%N1, %N2, %0\\\"\n@@ -10008,7 +10123,7 @@\n \t(vec_select:V2SI\n \t (vec_concat:V4SI (match_operand:V2SI 1 \"arith_reg_or_0_operand\" \"rU\")\n \t\t\t  (match_operand:V2SI 2 \"arith_reg_or_0_operand\" \"rU\"))\n-\t (const_vector [(const_int 0) (const_int 2)])))]\n+\t (parallel [(const_int 0) (const_int 2)])))]\n   \"TARGET_SHMEDIA\"\n   \"* return (TARGET_LITTLE_ENDIAN\n \t     ? \\\"mshflo.l\t%N1, %N2, %0\\\"\n@@ -10044,7 +10159,7 @@\n \t(vec_select:V4HI\n \t (vec_concat:V8HI (match_operand:V4HI 1 \"arith_reg_or_0_operand\" \"rU\")\n \t\t\t  (match_operand:V4HI 2 \"arith_reg_or_0_operand\" \"rU\"))\n-\t (const_vector [(const_int 2) (const_int 6) (const_int 3) (const_int 7)])))]\n+\t (parallel [(const_int 2) (const_int 6) (const_int 3) (const_int 7)])))]\n   \"TARGET_SHMEDIA\"\n   \"* return (TARGET_LITTLE_ENDIAN\n \t     ? \\\"mshfhi.w\t%N1, %N2, %0\\\"\n@@ -10056,22 +10171,45 @@\n \t(vec_select:V4HI\n \t (vec_concat:V8HI (match_operand:V4HI 1 \"arith_reg_or_0_operand\" \"rU\")\n \t\t\t  (match_operand:V4HI 2 \"arith_reg_or_0_operand\" \"rU\"))\n-\t (const_vector [(const_int 0) (const_int 4) (const_int 1) (const_int 5)])))]\n+\t (parallel [(const_int 0) (const_int 4) (const_int 1) (const_int 5)])))]\n   \"TARGET_SHMEDIA\"\n   \"* return (TARGET_LITTLE_ENDIAN\n \t     ? \\\"mshflo.w\t%N1, %N2, %0\\\"\n \t     : \\\"mshfhi.w\t%N1, %N2, %0\\\");\"\n   [(set_attr \"type\" \"arith_media\")])\n \n+(define_insn \"mshflo_w_x\"\n+  [(set (match_operand:V4HI 0 \"arith_reg_dest\" \"=r\")\n+\t(vec_select:V4HI\n+\t (vec_concat:V4HI (match_operand:V2HI 1 \"extend_reg_or_0_operand\" \"rU\")\n+\t\t\t  (match_operand:V2HI 2 \"extend_reg_or_0_operand\" \"rU\"))\n+\t (parallel [(const_int 0) (const_int 2) (const_int 1) (const_int 3)])))]\n+  \"TARGET_SHMEDIA\"\n+  \"mshflo.w\t%N1, %N2, %0\"\n+  [(set_attr \"type\" \"arith_media\")])\n+\n /* These are useful to expand ANDs and as combiner patterns.  */\n-(define_insn \"mshfhi_l_di\"\n-  [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n-\t(ior:DI (lshiftrt:DI (match_operand:DI 1 \"arith_reg_or_0_operand\" \"rU\")\n+(define_insn_and_split \"mshfhi_l_di\"\n+  [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r,f\")\n+\t(ior:DI (lshiftrt:DI (match_operand:DI 1 \"arith_reg_or_0_operand\" \"rU,f\")\n                              (const_int 32))\n-\t\t(and:DI (match_operand:DI 2 \"arith_reg_or_0_operand\" \"rU\")\n+\t\t(and:DI (match_operand:DI 2 \"arith_reg_or_0_operand\" \"rU,?f\")\n \t\t\t(const_int -4294967296))))]\n   \"TARGET_SHMEDIA\"\n-  \"mshfhi.l\t%N1, %N2, %0\"\n+  \"@\n+\tmshfhi.l\t%N1, %N2, %0\n+\t#\"\n+  \"TARGET_SHMEDIA && reload_completed\n+   && ! GENERAL_REGISTER_P (true_regnum (operands[0]))\"\n+  [(set (match_dup 3) (match_dup 4))\n+   (set (match_dup 5) (match_dup 6))]\n+  \"\n+{\n+  operands[3] = gen_lowpart (SImode, operands[0]);\n+  operands[4] = gen_highpart (SImode, operands[1]);\n+  operands[5] = gen_highpart (SImode, operands[0]);\n+  operands[6] = gen_highpart (SImode, operands[2]);\n+}\"\n   [(set_attr \"type\" \"arith_media\")])\n \n (define_insn \"*mshfhi_l_di_rev\"\n@@ -10127,14 +10265,37 @@\n \n (define_insn \"*mshflo_l_di_x\"\n   [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n-\t(ior:DI (zero_extend:DI (match_operand:SI 1 \"extend_reg_or_0_operand\" \"rU\"))\n+\t(ior:DI (zero_extend:DI (match_operand:SI 1 \"extend_reg_or_0_operand\"\n+\t\t\t\t \"rU\"))\n \t\t(ashift:DI (match_operand:DI 2 \"arith_reg_or_0_operand\" \"rU\")\n                            (const_int 32))))]\n \t\t\t\t\n   \"TARGET_SHMEDIA\"\n   \"mshflo.l\t%N1, %N2, %0\"\n   [(set_attr \"type\" \"arith_media\")])\n \n+(define_insn_and_split \"concat_v2sf\"\n+  [(set (match_operand:V2SF 0 \"register_operand\" \"=r,f,f?\")\n+;;\t(vec_concat:V2SF (match_operand:SF 1 \"register_operand\" \"rU,0,f\")\n+\t(vec_concat:V2SF (match_operand:SF 1 \"register_operand\" \"rU,f,f\")\n+\t\t\t (match_operand:SF 2 \"register_operand\" \"rU,f,f\")))]\n+\t\t\t\t\n+  \"TARGET_SHMEDIA\"\n+  \"@\n+\tmshflo.l\t%N1, %N2, %0\n+\t#\n+\t#\"\n+  \"TARGET_SHMEDIA && reload_completed\n+   && ! GENERAL_REGISTER_P (true_regnum (operands[0]))\"\n+  [(set (match_dup 3) (match_dup 1))\n+   (set (match_dup 4) (match_dup 2))]\n+  \"\n+{\n+  operands[3] = simplify_gen_subreg (SFmode, operands[0], V2SFmode, 0);\n+  operands[4] = simplify_gen_subreg (SFmode, operands[0], V2SFmode, 4);\n+}\"\n+  [(set_attr \"type\" \"arith_media\")])\n+\n (define_insn \"*mshflo_l_di_x_rev\"\n   [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n \t(ior:DI (ashift:DI (match_operand:DI 1 \"arith_reg_or_0_operand\" \"rU\")\n@@ -10241,13 +10402,13 @@\n \t\t\t\t\t\t    \"fp_arith_reg_operand\" \"f\")\n \t\t\t\t\t\t   (match_operand:V4SF 2\n \t\t\t\t\t\t    \"fp_arith_reg_operand\" \"f\"))\n-\t\t\t\t\t (const_vector [(const_int 0)]))\n+\t\t\t\t\t (parallel [(const_int 0)]))\n \t\t\t  (vec_select:SF (mult:V4SF (match_dup 1) (match_dup 2))\n-\t\t\t\t\t (const_vector [(const_int 1)])))\n+\t\t\t\t\t (parallel [(const_int 1)])))\n \t\t (plus:SF (vec_select:SF (mult:V4SF (match_dup 1) (match_dup 2))\n-\t\t\t\t\t (const_vector [(const_int 2)]))\n+\t\t\t\t\t (parallel [(const_int 2)]))\n \t\t\t  (vec_select:SF (mult:V4SF (match_dup 1) (match_dup 2))\n-\t\t\t\t\t (const_vector [(const_int 3)])))))]\n+\t\t\t\t\t (parallel [(const_int 3)])))))]\n   \"TARGET_SHMEDIA\"\n   \"fipr\t%1, %2, %0\"\n   [(set_attr \"type\" \"fparith_media\")])\n@@ -10266,31 +10427,31 @@\n \t (plus:V4SF\n \t  (mult:V4SF\n \t   (vec_select:V4SF (match_operand:V16SF 1 \"fp_arith_reg_operand\" \"f\")\n-\t\t\t    (const_vector [(const_int 0) (const_int 5)\n-\t\t\t\t\t   (const_int 10) (const_int 15)]))\n+\t\t\t    (parallel [(const_int 0) (const_int 5)\n+\t\t\t\t       (const_int 10) (const_int 15)]))\n \t   (match_operand:V4SF 2 \"fp_arith_reg_operand\" \"f\"))\n \t  (mult:V4SF\n \t   (vec_select:V4SF (match_dup 1)\n-\t\t\t    (const_vector [(const_int 4) (const_int 9)\n-\t\t\t\t\t   (const_int 14) (const_int 3)]))\n+\t\t\t    (parallel [(const_int 4) (const_int 9)\n+\t\t\t\t       (const_int 14) (const_int 3)]))\n \t   (vec_select:V4SF (match_dup 2)\n-\t\t\t    (const_vector [(const_int 1) (const_int 2)\n-\t\t\t\t\t   (const_int 3) (const_int 0)]))))\n+\t\t\t    (parallel [(const_int 1) (const_int 2)\n+\t\t\t\t      (const_int 3) (const_int 0)]))))\n \t (plus:V4SF\n \t  (mult:V4SF\n \t   (vec_select:V4SF (match_dup 1)\n-\t\t\t    (const_vector [(const_int 8) (const_int 13)\n-\t\t\t\t\t   (const_int 2) (const_int 7)]))\n+\t\t\t    (parallel [(const_int 8) (const_int 13)\n+\t\t\t\t       (const_int 2) (const_int 7)]))\n \t   (vec_select:V4SF (match_dup 2)\n-\t\t\t    (const_vector [(const_int 2) (const_int 3)\n-\t\t\t\t\t   (const_int 0) (const_int 1)])))\n+\t\t\t    (parallel [(const_int 2) (const_int 3)\n+\t\t\t\t       (const_int 0) (const_int 1)])))\n \t  (mult:V4SF\n \t   (vec_select:V4SF (match_dup 1)\n-\t\t\t    (const_vector [(const_int 12) (const_int 1)\n-\t\t\t\t\t   (const_int 6) (const_int 11)]))\n+\t\t\t    (parallel [(const_int 12) (const_int 1)\n+\t\t\t\t       (const_int 6) (const_int 11)]))\n \t   (vec_select:V4SF (match_dup 2)\n-\t\t\t    (const_vector [(const_int 3) (const_int 0)\n-\t\t\t\t\t   (const_int 1) (const_int 2)]))))))]\n+\t\t\t    (parallel [(const_int 3) (const_int 0)\n+\t\t\t\t       (const_int 1) (const_int 2)]))))))]\n   \"TARGET_SHMEDIA\"\n   \"ftrv %1, %2, %0\"\n   [(set_attr \"type\" \"fparith_media\")])"}]}