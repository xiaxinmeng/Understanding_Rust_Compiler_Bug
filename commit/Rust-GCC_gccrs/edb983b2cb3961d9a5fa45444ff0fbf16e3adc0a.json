{"sha": "edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWRiOTgzYjJjYjM5NjFkOWE1ZmE0NTQ0NGZmMGZiZjE2ZTNhZGMwYQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-06-05T14:15:31Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-06-05T14:15:31Z"}, "message": "class.c (emit_register_classes_in_jcr_section): Use DECL_PRESERVE_P instead of mark_decl_referenced.\n\n\n\t* class.c (emit_register_classes_in_jcr_section): Use DECL_PRESERVE_P\n\tinstead of mark_decl_referenced.\n\n\t* decl2.c (maybe_make_one_only): Use forced_by_abi instad of\n\tmark_decl_referenced.\n\t(mark_needed): Likewise.\n\n\t* cgraph.c (cgraph_remove_node): Clear forced_by_abi.\n\t(cgraph_node_cannot_be_local_p_1): Honnor symbol.forced_by_abi\n\tand symtab_used_from_object_file_p.\n\t(cgraph_make_node_local_1): Clear forced_by_abi.\n\t(cgraph_can_remove_if_no_direct_calls_and): Use forced_by_abi\n\t* cgraph.h (symtab_node_base): Add forced_by_abi.\n\t(decide_is_variable_needed): Remove.\n\t(varpool_can_remove_if_no_refs): Honnor symbol.forced_by_abi.\n\t* cgraphunit.c (cgraph_decide_is_function_needed): Rename to ..\n\t(decide_is_symbol_needed): ... this one; handle symbols in general;\n\talways analyze virtuals; honnor forced_by_abi.\n\t(cgraph_finalize_function): Update.\n\t(varpool_finalize_decl): Update.\n\t(symbol_defined_and_needed): Remove.\n\t(analyze_functions): Update.\n\t* lto-cgraph.c (lto_output_node, lto_output_varpool_node,\n\toutput_refs, input_overwrite_node): Handle forced_by_abi.\n\t* ipa.c (cgraph_address_taken_from_non_vtable_p): Rename to ...\n\t(address_taken_from_non_vtable_p): ... this one.\n\t(comdat_can_be_unshared_p_1): New function.\n\t(cgraph_comdat_can_be_unshared_p): Rename to ...\n\t(comdat_can_be_unshared_p): ... this one; handle symbols in general.\n\t(varpool_externally_visible_p): Use comdat_can_be_unshared_p.\n\t(function_and_variable_visibility): Clear forced_by_abi as needed.\n\t* trans-mem.c (ipa_tm_mark_forced_by_abi_node): New functoin.\n\t(ipa_tm_create_version_alias, ipa_tm_create_version): Update.\n\t* varasm.c (mark_decl_referenced): Remove.\n\t* symtab.c (dump_symtab_base): Dump forced_by_abi.\n\t* varpool.c (decide_is_variable_needed): Remove.\n\nFrom-SVN: r199695", "tree": {"sha": "a3982caf99872c7045fe2746bb44f9b7a2a178ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3982caf99872c7045fe2746bb44f9b7a2a178ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a/comments", "author": null, "committer": null, "parents": [{"sha": "9912dbe5c7d8c715d6506380ef62a3377297f4b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9912dbe5c7d8c715d6506380ef62a3377297f4b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9912dbe5c7d8c715d6506380ef62a3377297f4b4"}], "stats": {"total": 293, "additions": 180, "deletions": 113}, "files": [{"sha": "154f0f07625ec1ebc63abe81cf38fdfab4113993", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a", "patch": "@@ -1,3 +1,35 @@\n+2013-06-05  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (cgraph_remove_node): Clear forced_by_abi.\n+\t(cgraph_node_cannot_be_local_p_1): Honnor symbol.forced_by_abi\n+\tand symtab_used_from_object_file_p.\n+\t(cgraph_make_node_local_1): Clear forced_by_abi.\n+\t(cgraph_can_remove_if_no_direct_calls_and): Use forced_by_abi\n+\t* cgraph.h (symtab_node_base): Add forced_by_abi.\n+\t(decide_is_variable_needed): Remove.\n+\t(varpool_can_remove_if_no_refs): Honnor symbol.forced_by_abi.\n+\t* cgraphunit.c (cgraph_decide_is_function_needed): Rename to ..\n+\t(decide_is_symbol_needed): ... this one; handle symbols in general;\n+\talways analyze virtuals; honnor forced_by_abi.\n+\t(cgraph_finalize_function): Update.\n+\t(varpool_finalize_decl): Update.\n+\t(symbol_defined_and_needed): Remove.\n+\t(analyze_functions): Update.\n+\t* lto-cgraph.c (lto_output_node, lto_output_varpool_node,\n+\toutput_refs, input_overwrite_node): Handle forced_by_abi.\n+\t* ipa.c (cgraph_address_taken_from_non_vtable_p): Rename to ...\n+\t(address_taken_from_non_vtable_p): ... this one.\n+\t(comdat_can_be_unshared_p_1): New function.\n+\t(cgraph_comdat_can_be_unshared_p): Rename to ...\n+\t(comdat_can_be_unshared_p): ... this one; handle symbols in general.\n+\t(varpool_externally_visible_p): Use comdat_can_be_unshared_p.\n+\t(function_and_variable_visibility): Clear forced_by_abi as needed.\n+\t* trans-mem.c (ipa_tm_mark_forced_by_abi_node): New functoin.\n+\t(ipa_tm_create_version_alias, ipa_tm_create_version): Update.\n+\t* varasm.c (mark_decl_referenced): Remove.\n+\t* symtab.c (dump_symtab_base): Dump forced_by_abi.\n+\t* varpool.c (decide_is_variable_needed): Remove.\n+\n 2013-06-05  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/arm/arm.c (MAX_INSN_PER_IT_BLOCK): New macro."}, {"sha": "7bcff2033796373aef239c37cdb2d761d18c0adb", "filename": "gcc/cgraph.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a", "patch": "@@ -1326,6 +1326,7 @@ cgraph_remove_node (struct cgraph_node *node)\n   /* Incremental inlining access removed nodes stored in the postorder list.\n      */\n   node->symbol.force_output = false;\n+  node->symbol.forced_by_abi = false;\n   for (n = node->nested; n; n = n->next_nested)\n     n->origin = NULL;\n   node->nested = NULL;\n@@ -1712,6 +1713,8 @@ cgraph_node_cannot_be_local_p_1 (struct cgraph_node *node,\n {\n   return !(!node->symbol.force_output\n \t   && ((DECL_COMDAT (node->symbol.decl)\n+\t\t&& !node->symbol.forced_by_abi\n+\t        && !symtab_used_from_object_file_p ((symtab_node) node)\n \t\t&& !node->symbol.same_comdat_group)\n \t       || !node->symbol.externally_visible));\n }\n@@ -1804,6 +1807,7 @@ cgraph_make_node_local_1 (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n       symtab_make_decl_local (node->symbol.decl);\n \n       node->symbol.externally_visible = false;\n+      node->symbol.forced_by_abi = false;\n       node->local.local = true;\n       node->symbol.unique_name = (node->symbol.resolution == LDPR_PREVAILING_DEF_IRONLY\n \t\t\t\t  || node->symbol.resolution == LDPR_PREVAILING_DEF_IRONLY_EXP);\n@@ -2085,6 +2089,7 @@ cgraph_can_remove_if_no_direct_calls_and_refs_p (struct cgraph_node *node)\n   /* Only COMDAT functions can be removed if externally visible.  */\n   if (node->symbol.externally_visible\n       && (!DECL_COMDAT (node->symbol.decl)\n+\t  || node->symbol.forced_by_abi\n \t  || symtab_used_from_object_file_p ((symtab_node) node)))\n     return false;\n   return true;"}, {"sha": "dda4402e07715fad5b9fbaa63f3200e0b3a0d6d4", "filename": "gcc/cgraph.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a", "patch": "@@ -72,9 +72,13 @@ struct GTY(()) symtab_node_base\n \n   /* Set when function is visible by other units.  */\n   unsigned externally_visible : 1;\n-  /* Needed variables might become dead by optimization.  This flag\n-     forces the variable to be output even if it appears dead otherwise.  */\n+  /* The symbol will be assumed to be used in an invisiable way (like \n+     by an toplevel asm statement).  */\n   unsigned force_output : 1;\n+  /* Like FORCE_OUTPUT, but in the case it is ABI requiring the symbol to be\n+     exported.  Unlike FORCE_OUTPUT this flag gets cleared to symbols promoted\n+     to static and it does not inhibit optimization.  */\n+  unsigned forced_by_abi : 1;\n   /* True when the name is known to be unique and thus it does not need mangling.  */\n   unsigned unique_name : 1;\n \n@@ -775,7 +779,6 @@ void dump_varpool (FILE *);\n void dump_varpool_node (FILE *, struct varpool_node *);\n \n void varpool_finalize_decl (tree);\n-bool decide_is_variable_needed (struct varpool_node *, tree);\n enum availability cgraph_variable_initializer_availability (struct varpool_node *);\n void cgraph_make_node_local (struct cgraph_node *);\n bool cgraph_node_can_be_local_p (struct cgraph_node *);\n@@ -1216,6 +1219,7 @@ varpool_can_remove_if_no_refs (struct varpool_node *node)\n     return true;\n   return (!node->symbol.force_output && !node->symbol.used_from_other_partition\n   \t  && ((DECL_COMDAT (node->symbol.decl)\n+\t       && !node->symbol.forced_by_abi\n \t       && !symtab_used_from_object_file_p ((symtab_node) node))\n \t      || !node->symbol.externally_visible\n \t      || DECL_HAS_VALUE_EXPR_P (node->symbol.decl)));"}, {"sha": "044bdf7b02ba4517d4077acbbdc36966c614491e", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 32, "deletions": 38, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a", "patch": "@@ -216,36 +216,45 @@ static GTY(()) struct asm_node *asm_last_node;\n /* Used for vtable lookup in thunk adjusting.  */\n static GTY (()) tree vtable_entry_type;\n \n-/* Determine if function DECL is trivially needed and should stay in the\n-   compilation unit.  This is used at the symbol table construction time\n-   and differs from later logic removing unnecessary functions that can\n-   take into account results of analysis, whole program info etc.  */\n-\n-static bool\n-cgraph_decide_is_function_needed (struct cgraph_node *node, tree decl)\n+/* Determine if symbol DECL is needed.  That is, visible to something\n+   either outside this translation unit, something magic in the system\n+   configury */\n+bool\n+decide_is_symbol_needed (symtab_node node)\n {\n-  /* If the user told us it is used, then it must be so.  */\n-  if (node->symbol.force_output)\n-    return true;\n+  tree decl = node->symbol.decl;\n \n   /* Double check that no one output the function into assembly file\n      early.  */\n   gcc_checking_assert (!DECL_ASSEMBLER_NAME_SET_P (decl)\n \t               || !TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)));\n \n+  if (!node->symbol.definition)\n+    return false;\n \n-  /* Keep constructors, destructors and virtual functions.  */\n-  if (DECL_STATIC_CONSTRUCTOR (decl)\n-      || DECL_STATIC_DESTRUCTOR (decl)\n-      || (DECL_VIRTUAL_P (decl)\n-\t  && optimize && (DECL_COMDAT (decl) || DECL_EXTERNAL (decl))))\n-     return true;\n+  /* Devirtualization may access these.  */\n+  if (DECL_VIRTUAL_P (decl) && optimize)\n+    return true;\n \n-  /* Externally visible functions must be output.  The exception is\n-     COMDAT functions that must be output only when they are needed.  */\n+  if (DECL_EXTERNAL (decl))\n+    return false;\n \n-  if (TREE_PUBLIC (decl)\n-      && !DECL_COMDAT (decl) && !DECL_EXTERNAL (decl))\n+  /* If the user told us it is used, then it must be so.  */\n+  if (node->symbol.force_output)\n+    return true;\n+\n+  /* ABI forced symbols are needed when they are external.  */\n+  if (node->symbol.forced_by_abi && TREE_PUBLIC (decl))\n+    return true;\n+\n+ /* Keep constructors, destructors and virtual functions.  */\n+   if (TREE_CODE (decl) == FUNCTION_DECL\n+       && (DECL_STATIC_CONSTRUCTOR (decl) || DECL_STATIC_DESTRUCTOR (decl)))\n+    return true;\n+\n+  /* Externally visible variables must be output.  The exception is\n+     COMDAT variables that must be output only when they are needed.  */\n+  if (TREE_PUBLIC (decl) && !DECL_COMDAT (decl))\n     return true;\n \n   return false;\n@@ -447,7 +456,7 @@ cgraph_finalize_function (tree decl, bool nested)\n     ggc_collect ();\n \n   if (cgraph_state == CGRAPH_STATE_CONSTRUCTION\n-      && (cgraph_decide_is_function_needed (node, decl)\n+      && (decide_is_symbol_needed ((symtab_node) node)\n \t  || referred_to_p ((symtab_node)node)))\n     enqueue_node ((symtab_node)node);\n }\n@@ -801,7 +810,7 @@ varpool_finalize_decl (tree decl)\n     node->symbol.force_output = true;\n \n   if (cgraph_state == CGRAPH_STATE_CONSTRUCTION\n-      && (decide_is_variable_needed (node, decl)\n+      && (decide_is_symbol_needed ((symtab_node) node)\n \t  || referred_to_p ((symtab_node)node)))\n     enqueue_node ((symtab_node)node);\n   if (cgraph_state >= CGRAPH_STATE_IPA_SSA)\n@@ -813,21 +822,6 @@ varpool_finalize_decl (tree decl)\n }\n \n \n-/* Determine if a symbol NODE is finalized and needed.  */\n-\n-inline static bool\n-symbol_defined_and_needed (symtab_node node)\n-{\n-  if (cgraph_node *cnode = dyn_cast <cgraph_node> (node))\n-    return cnode->symbol.definition\n-\t   && cgraph_decide_is_function_needed (cnode, cnode->symbol.decl);\n-  if (varpool_node *vnode = dyn_cast <varpool_node> (node))\n-    return vnode->symbol.definition\n-\t   && !DECL_EXTERNAL (vnode->symbol.decl)\n-\t   && decide_is_variable_needed (vnode, vnode->symbol.decl);\n-  return false;\n-}\n-\n /* Discover all functions and variables that are trivially needed, analyze\n    them as well as all functions and variables referred by them  */\n \n@@ -869,7 +863,7 @@ analyze_functions (void)\n \t   node != (symtab_node)first_analyzed\n \t   && node != (symtab_node)first_analyzed_var; node = node->symbol.next)\n \t{\n-\t  if (symbol_defined_and_needed (node))\n+\t  if (decide_is_symbol_needed (node))\n \t    {\n \t      enqueue_node (node);\n \t      if (!changed && cgraph_dump_file)"}, {"sha": "4698a183448004f2e68ca5d97f5313912d479edb", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a", "patch": "@@ -1,3 +1,9 @@\n+2013-06-03  Jan Hubicka  <jh@suse.cz>\n+\n+\t* decl2.c (maybe_make_one_only): Use forced_by_abi instad of\n+\tmark_decl_referenced.\n+\t(mark_needed): Likewise.\n+\n 2013-06-03  Jason Merrill  <jason@redhat.com>\n \n \t* class.c (mark_type_abi_tags): New."}, {"sha": "373f883117315963fd64dce3a80c9ed88bef09c2", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a", "patch": "@@ -1703,9 +1703,10 @@ maybe_make_one_only (tree decl)\n \n       if (VAR_P (decl))\n \t{\n+          struct varpool_node *node = varpool_node_for_decl (decl);\n \t  DECL_COMDAT (decl) = 1;\n \t  /* Mark it needed so we don't forget to emit it.  */\n-\t  mark_decl_referenced (decl);\n+          node->symbol.forced_by_abi = true;\n \t  TREE_USED (decl) = 1;\n \t}\n     }\n@@ -1813,7 +1814,22 @@ void\n mark_needed (tree decl)\n {\n   TREE_USED (decl) = 1;\n-  mark_decl_referenced (decl);\n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n+    {\n+      /* Extern inline functions don't become needed when referenced.\n+\t If we know a method will be emitted in other TU and no new\n+\t functions can be marked reachable, just use the external\n+\t definition.  */\n+      struct cgraph_node *node = cgraph_get_create_node (decl);\n+      node->symbol.forced_by_abi = true;\n+    }\n+  else if (TREE_CODE (decl) == VAR_DECL)\n+    {\n+      struct varpool_node *node = varpool_node_for_decl (decl);\n+      /* C++ frontend use mark_decl_references to force COMDAT variables\n+         to be output that might appear dead otherwise.  */\n+      node->symbol.forced_by_abi = true;\n+    }\n }\n \n /* DECL is either a FUNCTION_DECL or a VAR_DECL.  This function"}, {"sha": "a73cbb1c08962f5bc2a574774d6ccc788a67c1e0", "filename": "gcc/ipa.c", "status": "modified", "additions": 56, "deletions": 19, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a", "patch": "@@ -519,7 +519,7 @@ ipa_discover_readonly_nonaddressable_vars (void)\n \n /* Return true when there is a reference to node and it is not vtable.  */\n static bool\n-cgraph_address_taken_from_non_vtable_p (struct cgraph_node *node)\n+address_taken_from_non_vtable_p (symtab_node node)\n {\n   int i;\n   struct ipa_ref *ref;\n@@ -537,6 +537,38 @@ cgraph_address_taken_from_non_vtable_p (struct cgraph_node *node)\n   return false;\n }\n \n+/* A helper for comdat_can_be_unshared_p.  */\n+\n+static bool\n+comdat_can_be_unshared_p_1 (symtab_node node)\n+{\n+  /* When address is taken, we don't know if equality comparison won't\n+     break eventaully. Exception are virutal functions and vtables, where\n+     this is not possible by language standard.  */\n+  if (!DECL_VIRTUAL_P (node->symbol.decl)\n+      && address_taken_from_non_vtable_p (node))\n+    return false;\n+\n+  /* If the symbol is used in some weird way, better to not touch it.  */\n+  if (node->symbol.force_output)\n+    return false;\n+\n+  /* Explicit instantiations needs to be output when possibly\n+     used externally.  */\n+  if (node->symbol.forced_by_abi\n+      && TREE_PUBLIC (node->symbol.decl)\n+      && (node->symbol.resolution != LDPR_PREVAILING_DEF_IRONLY\n+          && !flag_whole_program))\n+    return false;\n+\n+  /* Non-readonly and volatile variables can not be duplicated.  */\n+  if (is_a <varpool_node> (node)\n+      && (!TREE_READONLY (node->symbol.decl)\n+\t  || TREE_THIS_VOLATILE (node->symbol.decl)))\n+    return false;\n+  return true;\n+}\n+\n /* COMDAT functions must be shared only if they have address taken,\n    otherwise we can produce our own private implementation with\n    -fwhole-program.  \n@@ -547,24 +579,21 @@ cgraph_address_taken_from_non_vtable_p (struct cgraph_node *node)\n    but in C++ there is no way to compare their addresses for equality.  */\n \n static bool\n-cgraph_comdat_can_be_unshared_p (struct cgraph_node *node)\n+comdat_can_be_unshared_p (symtab_node node)\n {\n-  if ((cgraph_address_taken_from_non_vtable_p (node)\n-       && !DECL_VIRTUAL_P (node->symbol.decl))\n-      || !node->symbol.definition)\n+  if (!comdat_can_be_unshared_p_1 (node))\n     return false;\n   if (node->symbol.same_comdat_group)\n     {\n-      struct cgraph_node *next;\n+      symtab_node next;\n \n       /* If more than one function is in the same COMDAT group, it must\n          be shared even if just one function in the comdat group has\n          address taken.  */\n-      for (next = cgraph (node->symbol.same_comdat_group);\n-\t   next != node; next = cgraph (next->symbol.same_comdat_group))\n-\tif (cgraph_address_taken_from_non_vtable_p (next)\n-\t    && !DECL_VIRTUAL_P (next->symbol.decl))\n-\t  return false;\n+      for (next = node->symbol.same_comdat_group;\n+\t   next != node; next = next->symbol.same_comdat_group)\n+        if (!comdat_can_be_unshared_p_1 (next))\n+          return false;\n     }\n   return true;\n }\n@@ -610,7 +639,7 @@ cgraph_externally_visible_p (struct cgraph_node *node,\n       implementing same COMDAT)  */\n   if ((in_lto_p || whole_program)\n       && DECL_COMDAT (node->symbol.decl)\n-      && cgraph_comdat_can_be_unshared_p (node))\n+      && comdat_can_be_unshared_p ((symtab_node) node))\n     return false;\n \n   /* When doing link time optimizations, hidden symbols become local.  */\n@@ -680,8 +709,8 @@ varpool_externally_visible_p (struct varpool_node *vnode)\n      is faster for dynamic linking.  Also this match logic hidding vtables\n      from LTO symbol tables.  */\n   if ((in_lto_p || flag_whole_program)\n-      && !vnode->symbol.force_output\n-      && DECL_COMDAT (vnode->symbol.decl) && DECL_VIRTUAL_P (vnode->symbol.decl))\n+      && DECL_COMDAT (vnode->symbol.decl)\n+      && comdat_can_be_unshared_p ((symtab_node) vnode))\n     return false;\n \n   /* When doing link time optimizations, hidden symbols become local.  */\n@@ -743,9 +772,11 @@ function_and_variable_visibility (bool whole_program)\n       /* Frontends and alias code marks nodes as needed before parsing is finished.\n \t We may end up marking as node external nodes where this flag is meaningless\n \t strip it.  */\n-      if (node->symbol.force_output\n-\t  && (DECL_EXTERNAL (node->symbol.decl) || !node->symbol.definition))\n-\tnode->symbol.force_output = 0;\n+      if (DECL_EXTERNAL (node->symbol.decl) || !node->symbol.definition)\n+\t{\n+\t  node->symbol.force_output = 0;\n+\t  node->symbol.forced_by_abi = 0;\n+\t}\n \n       /* C++ FE on lack of COMDAT support create local COMDAT functions\n \t (that ought to be shared but can not due to object format\n@@ -780,7 +811,10 @@ function_and_variable_visibility (bool whole_program)\n \t  node->symbol.externally_visible = true;\n \t}\n       else\n-\tnode->symbol.externally_visible = false;\n+\t{\n+\t  node->symbol.externally_visible = false;\n+\t  node->symbol.forced_by_abi = false;\n+\t}\n       if (!node->symbol.externally_visible && node->symbol.definition\n \t  && !DECL_EXTERNAL (node->symbol.decl))\n \t{\n@@ -859,7 +893,10 @@ function_and_variable_visibility (bool whole_program)\n       if (varpool_externally_visible_p (vnode))\n \tvnode->symbol.externally_visible = true;\n       else\n-        vnode->symbol.externally_visible = false;\n+\t{\n+          vnode->symbol.externally_visible = false;\n+\t  vnode->symbol.forced_by_abi = false;\n+\t}\n       if (!vnode->symbol.externally_visible)\n \t{\n \t  gcc_assert (in_lto_p || whole_program || !TREE_PUBLIC (vnode->symbol.decl));"}, {"sha": "9cc34c51a5a4a3f31cb11658323e73099d4f6d4e", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a", "patch": "@@ -1,3 +1,8 @@\n+2013-06-05  Jan Hubicka  <jh@suse.cz>\n+\n+\t* class.c (emit_register_classes_in_jcr_section): Use DECL_PRESERVE_P\n+\tinstead of mark_decl_referenced.\n+\n 2013-05-29  Jan Hubicka  <jh@suse.cz>\n \n \t* decl.c (java_mark_decl_local): Update for new symtab flags."}, {"sha": "cb6789643d3e8c3934480ee316d842b53649d1b7", "filename": "gcc/java/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a", "patch": "@@ -2814,10 +2814,10 @@ emit_register_classes_in_jcr_section (void)\n   TREE_CONSTANT (cdecl) = 1;\n   DECL_ARTIFICIAL (cdecl) = 1;\n   DECL_IGNORED_P (cdecl) = 1;\n+  DECL_PRESERVE_P (cdecl) = 1;\n   pushdecl_top_level (cdecl);\n   relayout_decl (cdecl);\n   rest_of_decl_compilation (cdecl, 1, 0);\n-  mark_decl_referenced (cdecl);\n #else\n   /* A target has defined TARGET_USE_JCR_SECTION,\n      but doesn't have a JCR_SECTION_NAME.  */"}, {"sha": "bc9e5cdbf75ec865814dedd64dbb0907ec034744", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a", "patch": "@@ -469,6 +469,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   bp_pack_value (&bp, node->local.can_change_signature, 1);\n   bp_pack_value (&bp, node->local.redefined_extern_inline, 1);\n   bp_pack_value (&bp, node->symbol.force_output, 1);\n+  bp_pack_value (&bp, node->symbol.forced_by_abi, 1);\n   bp_pack_value (&bp, node->symbol.unique_name, 1);\n   bp_pack_value (&bp, node->symbol.address_taken, 1);\n   bp_pack_value (&bp, node->abstract_and_needed, 1);\n@@ -527,6 +528,7 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, struct varpool_node\n   bp = bitpack_create (ob->main_stream);\n   bp_pack_value (&bp, node->symbol.externally_visible, 1);\n   bp_pack_value (&bp, node->symbol.force_output, 1);\n+  bp_pack_value (&bp, node->symbol.forced_by_abi, 1);\n   bp_pack_value (&bp, node->symbol.unique_name, 1);\n   bp_pack_value (&bp, node->symbol.definition, 1);\n   alias_p = node->symbol.alias && (!boundary_p || DECL_EXTERNAL (node->symbol.decl));\n@@ -672,7 +674,7 @@ output_refs (lto_symtab_encoder_t encoder)\n       count = ipa_ref_list_nreferences (&node->symbol.ref_list);\n       if (count)\n \t{\n-\t  streamer_write_uhwi_stream (ob->main_stream, count);\n+\t  streamer_write_gcov_count_stream (ob->main_stream, count);\n \t  streamer_write_uhwi_stream (ob->main_stream,\n \t\t\t\t     lto_symtab_encoder_lookup (encoder, node));\n \t  for (i = 0; ipa_ref_list_reference_iterate (&node->symbol.ref_list,\n@@ -881,6 +883,7 @@ input_overwrite_node (struct lto_file_decl_data *file_data,\n   node->local.can_change_signature = bp_unpack_value (bp, 1);\n   node->local.redefined_extern_inline = bp_unpack_value (bp, 1);\n   node->symbol.force_output = bp_unpack_value (bp, 1);\n+  node->symbol.forced_by_abi = bp_unpack_value (bp, 1);\n   node->symbol.unique_name = bp_unpack_value (bp, 1);\n   node->symbol.address_taken = bp_unpack_value (bp, 1);\n   node->abstract_and_needed = bp_unpack_value (bp, 1);\n@@ -1039,6 +1042,7 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n   bp = streamer_read_bitpack (ib);\n   node->symbol.externally_visible = bp_unpack_value (&bp, 1);\n   node->symbol.force_output = bp_unpack_value (&bp, 1);\n+  node->symbol.forced_by_abi = bp_unpack_value (&bp, 1);\n   node->symbol.unique_name = bp_unpack_value (&bp, 1);\n   node->symbol.definition = bp_unpack_value (&bp, 1);\n   node->symbol.alias = bp_unpack_value (&bp, 1);"}, {"sha": "f0355412e06cc8aeb2a573de2a6e43dafec911af", "filename": "gcc/symtab.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a", "patch": "@@ -496,6 +496,8 @@ dump_symtab_base (FILE *f, symtab_node node)\n     fprintf (f, \" used_from_other_partition\");\n   if (node->symbol.force_output)\n     fprintf (f, \" force_output\");\n+  if (node->symbol.forced_by_abi)\n+    fprintf (f, \" forced_by_abi\");\n   if (node->symbol.resolution != LDPR_UNKNOWN)\n     fprintf (f, \" %s\",\n  \t     ld_plugin_symbol_resolution_names[(int)node->symbol.resolution]);"}, {"sha": "6289ea46a89f3049bad7ee4316db9186a80c1b60", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a", "patch": "@@ -4681,6 +4681,13 @@ ipa_tm_mark_force_output_node (struct cgraph_node *node)\n   node->symbol.analyzed = true;\n }\n \n+static inline void\n+ipa_tm_mark_forced_by_abi_node (struct cgraph_node *node)\n+{\n+  node->symbol.forced_by_abi = true;\n+  node->symbol.analyzed = true;\n+}\n+\n /* Callback data for ipa_tm_create_version_alias.  */\n struct create_version_alias_info\n {\n@@ -4737,6 +4744,8 @@ ipa_tm_create_version_alias (struct cgraph_node *node, void *data)\n   if (info->old_node->symbol.force_output\n       || ipa_ref_list_first_referring (&info->old_node->symbol.ref_list))\n     ipa_tm_mark_force_output_node (new_node);\n+  if (info->old_node->symbol.forced_by_abi)\n+    ipa_tm_mark_forced_by_abi_node (new_node);\n   return false;\n }\n \n@@ -4792,6 +4801,8 @@ ipa_tm_create_version (struct cgraph_node *old_node)\n   if (old_node->symbol.force_output\n       || ipa_ref_list_first_referring (&old_node->symbol.ref_list))\n     ipa_tm_mark_force_output_node (new_node);\n+  if (old_node->symbol.forced_by_abi)\n+    ipa_tm_mark_forced_by_abi_node (new_node);\n \n   /* Do the same thing, but for any aliases of the original node.  */\n   {"}, {"sha": "4c4178f61996fcfedb94b96bab9b8c386ffa7907", "filename": "gcc/varasm.c", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a", "patch": "@@ -2244,33 +2244,6 @@ mark_referenced (tree id)\n   TREE_SYMBOL_REFERENCED (id) = 1;\n }\n \n-/* Set the symbol_referenced flag for DECL and notify callgraph.  */\n-void\n-mark_decl_referenced (tree decl)\n-{\n-  if (TREE_CODE (decl) == FUNCTION_DECL)\n-    {\n-      /* Extern inline functions don't become needed when referenced.\n-\t If we know a method will be emitted in other TU and no new\n-\t functions can be marked reachable, just use the external\n-\t definition.  */\n-      struct cgraph_node *node = cgraph_get_create_node (decl);\n-      if (!DECL_EXTERNAL (decl)\n-\t  && !node->symbol.definition)\n-\tcgraph_mark_force_output_node (node);\n-    }\n-  else if (TREE_CODE (decl) == VAR_DECL)\n-    {\n-      struct varpool_node *node = varpool_node_for_decl (decl);\n-      /* C++ frontend use mark_decl_references to force COMDAT variables\n-         to be output that might appear dead otherwise.  */\n-      node->symbol.force_output = true;\n-    }\n-  /* else do nothing - we can get various sorts of CST nodes here,\n-     which do not need to be marked.  */\n-}\n-\n-\n /* Follow the IDENTIFIER_TRANSPARENT_ALIAS chain starting at *ALIAS\n    until we find an identifier that is not itself a transparent alias.\n    Modify the alias passed to it by reference (and all aliases on the"}, {"sha": "a3e9325a2ce4548a90b8a291e57c9da427c3f389", "filename": "gcc/varpool.c", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=edb983b2cb3961d9a5fa45444ff0fbf16e3adc0a", "patch": "@@ -130,28 +130,6 @@ varpool_node_for_asm (tree asmname)\n     return NULL;\n }\n \n-/* Determine if variable DECL is needed.  That is, visible to something\n-   either outside this translation unit, something magic in the system\n-   configury */\n-bool\n-decide_is_variable_needed (struct varpool_node *node, tree decl)\n-{\n-  if (DECL_EXTERNAL (decl))\n-    return false;\n-\n-  /* If the user told us it is used, then it must be so.  */\n-  if (node->symbol.force_output)\n-    return true;\n-\n-  /* Externally visible variables must be output.  The exception is\n-     COMDAT variables that must be output only when they are needed.  */\n-  if (TREE_PUBLIC (decl)\n-      && !DECL_COMDAT (decl))\n-    return true;\n-\n-  return false;\n-}\n-\n /* Return if DECL is constant and its initial value is known (so we can do\n    constant folding using DECL_INITIAL (decl)).  */\n "}]}