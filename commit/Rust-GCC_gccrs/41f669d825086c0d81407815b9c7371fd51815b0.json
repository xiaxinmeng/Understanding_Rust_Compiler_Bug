{"sha": "41f669d825086c0d81407815b9c7371fd51815b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDFmNjY5ZDgyNTA4NmMwZDgxNDA3ODE1YjljNzM3MWZkNTE4MTViMA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-04-01T07:41:17Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-04-01T07:41:17Z"}, "message": "lto-cgraph.c (lto_output_node, [...]): Stream split_part.\n\n\n\t* lto-cgraph.c (lto_output_node, input_overwrite_node): Stream\n\tsplit_part.\n\t* ipa-inline.c (edge_badness): Add wrapper penalty.\n\t(sum_callers): Move up.\n\t(inline_small_functions): Set single_caller.\n\t* ipa-inline.h (inline_summary): Add single_caller.\n\t* ipa-split.c (split_function): Set split_part.\n\t(cgraph_node::create_clone): Do not shadow decl; copy split_part.\n\t* cgraph.h (cgraph_node): Add split_part.\n\n\t* gcc.dg/ipa/inlinehint-4.c: New testcase.\n\nFrom-SVN: r221806", "tree": {"sha": "eac1696d54046990c5a2e48ab0b4ac01dab188be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eac1696d54046990c5a2e48ab0b4ac01dab188be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41f669d825086c0d81407815b9c7371fd51815b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41f669d825086c0d81407815b9c7371fd51815b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41f669d825086c0d81407815b9c7371fd51815b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41f669d825086c0d81407815b9c7371fd51815b0/comments", "author": null, "committer": null, "parents": [{"sha": "9fd542c6b5af0e3e8aa464aabca88b5e812be4de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fd542c6b5af0e3e8aa464aabca88b5e812be4de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fd542c6b5af0e3e8aa464aabca88b5e812be4de"}], "stats": {"total": 182, "additions": 161, "deletions": 21}, "files": [{"sha": "9c39d764e0173521033a4790f11f0914610c5757", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41f669d825086c0d81407815b9c7371fd51815b0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41f669d825086c0d81407815b9c7371fd51815b0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=41f669d825086c0d81407815b9c7371fd51815b0", "patch": "@@ -1,3 +1,15 @@\n+2015-03-31  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* lto-cgraph.c (lto_output_node, input_overwrite_node): Stream\n+\tsplit_part.\n+\t* ipa-inline.c (edge_badness): Add wrapper penalty.\n+\t(sum_callers): Move up.\n+\t(inline_small_functions): Set single_caller.\n+\t* ipa-inline.h (inline_summary): Add single_caller.\n+\t* ipa-split.c (split_function): Set split_part.\n+\t(cgraph_node::create_clone): Do not shadow decl; copy split_part.\n+\t* cgraph.h (cgraph_node): Add split_part.\n+\n 2015-03-31  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/58945"}, {"sha": "cf8c7b64b9b3b28eac243ba03609364201d1a996", "filename": "gcc/cgraph.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41f669d825086c0d81407815b9c7371fd51815b0/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41f669d825086c0d81407815b9c7371fd51815b0/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=41f669d825086c0d81407815b9c7371fd51815b0", "patch": "@@ -1319,6 +1319,8 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n   unsigned merged : 1;\n   /* True if function was created to be executed in parallel.  */\n   unsigned parallelized_function : 1;\n+  /* True if function is part split out by ipa-split.  */\n+  unsigned split_part : 1;\n \n private:\n   /* Worker for call_for_symbol_and_aliases.  */"}, {"sha": "77d6d85025aada221073bb195288259e5dbe9315", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 96, "deletions": 21, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41f669d825086c0d81407815b9c7371fd51815b0/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41f669d825086c0d81407815b9c7371fd51815b0/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=41f669d825086c0d81407815b9c7371fd51815b0", "patch": "@@ -1088,6 +1088,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n   else if (opt_for_fn (caller->decl, flag_guess_branch_prob) || caller->count)\n     {\n       sreal numerator, denominator;\n+      int overall_growth;\n \n       numerator = (compute_uninlined_call_time (callee_info, edge)\n \t\t   - compute_inlined_call_time (edge, edge_time));\n@@ -1098,8 +1099,74 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n       else if (opt_for_fn (caller->decl, flag_branch_probabilities))\n \tnumerator = numerator >> 11;\n       denominator = growth;\n-      if (callee_info->growth > 0)\n-\tdenominator *= callee_info->growth * callee_info->growth;\n+\n+      overall_growth = callee_info->growth;\n+\n+      /* Look for inliner wrappers of the form:\n+\n+\t inline_caller ()\n+\t   {\n+\t     do_fast_job...\n+\t     if (need_more_work)\n+\t       noninline_callee ();\n+\t   }\n+\t Withhout panilizing this case, we usually inline noninline_callee\n+\t into the inline_caller because overall_growth is small preventing\n+\t further inlining of inline_caller.\n+\n+\t Penalize only callgraph edges to functions with small overall\n+\t growth ...\n+\t*/\n+      if (growth > overall_growth\n+\t  /* ... and having only one caller which is not inlined ... */\n+\t  && callee_info->single_caller\n+\t  && !edge->caller->global.inlined_to\n+\t  /* ... and edges executed only conditionally ... */\n+\t  && edge->frequency < CGRAPH_FREQ_BASE\n+\t  /* ... consider case where callee is not inline but caller is ... */\n+\t  && ((!DECL_DECLARED_INLINE_P (edge->callee->decl)\n+\t       && DECL_DECLARED_INLINE_P (caller->decl))\n+\t      /* ... or when early optimizers decided to split and edge\n+\t\t frequency still indicates splitting is a win ... */\n+\t      || (callee->split_part && !caller->split_part\n+\t\t  && edge->frequency\n+\t\t     < CGRAPH_FREQ_BASE\n+\t\t       * PARAM_VALUE\n+\t\t\t  (PARAM_PARTIAL_INLINING_ENTRY_PROBABILITY) / 100\n+\t\t  /* ... and do not overwrite user specified hints.   */\n+\t\t  && (!DECL_DECLARED_INLINE_P (edge->callee->decl)\n+\t\t      || DECL_DECLARED_INLINE_P (caller->decl)))))\n+\t{\n+\t  struct inline_summary *caller_info = inline_summaries->get (caller);\n+\t  int caller_growth = caller_info->growth;\n+\n+\t  /* Only apply the penalty when caller looks like inline candidate,\n+\t     and it is not called once and.  */\n+\t  if (!caller_info->single_caller && overall_growth < caller_growth\n+\t      && caller_info->inlinable\n+\t      && caller_info->size\n+\t\t < (DECL_DECLARED_INLINE_P (caller->decl)\n+\t\t    ? MAX_INLINE_INSNS_SINGLE : MAX_INLINE_INSNS_AUTO))\n+\t    {\n+\t      if (dump)\n+\t\tfprintf (dump_file,\n+\t\t\t \"     Wrapper penalty. Increasing growth %i to %i\\n\",\n+\t\t\t overall_growth, caller_growth);\n+\t      overall_growth = caller_growth;\n+\t    }\n+\t}\n+      if (overall_growth > 0)\n+        {\n+\t  /* Strongly preffer functions with few callers that can be inlined\n+\t     fully.  The square root here leads to smaller binaries at average.\n+\t     Watch however for extreme cases and return to linear function\n+\t     when growth is large.  */\n+\t  if (overall_growth < 256)\n+\t    overall_growth *= overall_growth;\n+\t  else\n+\t    overall_growth += 256 * 256 - 256;\n+\t  denominator *= overall_growth;\n+        }\n \n       badness = - numerator / denominator;\n \n@@ -1109,13 +1176,15 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t\t   \"      %f: guessed profile. frequency %f, count %\"PRId64\n \t\t   \" caller count %\"PRId64\n \t\t   \" time w/o inlining %f, time w inlining %f\"\n-\t\t   \" overall growth %i (current) %i (original)\\n\",\n-\t\t   badness.to_double (), (double)edge->frequency / CGRAPH_FREQ_BASE,\n+\t\t   \" overall growth %i (current) %i (original)\"\n+\t\t   \" %i (compensated)\\n\",\n+\t\t   badness.to_double (),\n+\t\t  (double)edge->frequency / CGRAPH_FREQ_BASE,\n \t\t   edge->count, caller->count,\n \t\t   compute_uninlined_call_time (callee_info, edge).to_double (),\n \t\t   compute_inlined_call_time (edge, edge_time).to_double (),\n \t\t   estimate_growth (callee),\n-\t\t   callee_info->growth);\n+\t\t   callee_info->growth, overall_growth);\n \t}\n     }\n   /* When function local profile is not available or it does not give\n@@ -1133,8 +1202,8 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n       else\n \tbadness = badness << nest;\n       if (dump)\n-\tfprintf (dump_file, \"      %f: no profile. nest %i\\n\", badness.to_double (),\n-\t\t nest);\n+\tfprintf (dump_file, \"      %f: no profile. nest %i\\n\",\n+\t\t badness.to_double (), nest);\n     }\n   gcc_checking_assert (badness != 0);\n \n@@ -1649,6 +1718,20 @@ inline_account_function_p (struct cgraph_node *node)\n \t   && node->frequency != NODE_FREQUENCY_UNLIKELY_EXECUTED);\n }\n \n+/* Count number of callers of NODE and store it into DATA (that\n+   points to int.  Worker for cgraph_for_node_and_aliases.  */\n+\n+static bool\n+sum_callers (struct cgraph_node *node, void *data)\n+{\n+  struct cgraph_edge *e;\n+  int *num_calls = (int *)data;\n+\n+  for (e = node->callers; e; e = e->next_caller)\n+    (*num_calls)++;\n+  return false;\n+}\n+\n /* We use greedy algorithm for inlining of small functions:\n    All inline candidates are put into prioritized heap ordered in\n    increasing badness.\n@@ -1693,6 +1776,12 @@ inline_small_functions (void)\n \t    if (inline_account_function_p (node))\n \t      initial_size += info->size;\n \t    info->growth = estimate_growth (node);\n+\n+\t    int num_calls = 0;\n+\t    node->call_for_symbol_and_aliases (sum_callers, &num_calls,\n+\t\t\t\t\t       true);\n+\t    if (num_calls == 1)\n+\t      info->single_caller = true;\n \t    if (dfs && dfs->next_cycle)\n \t      {\n \t\tstruct cgraph_node *n2;\n@@ -2085,20 +2174,6 @@ flatten_function (struct cgraph_node *node, bool early)\n     inline_update_overall_summary (node);\n }\n \n-/* Count number of callers of NODE and store it into DATA (that\n-   points to int.  Worker for cgraph_for_node_and_aliases.  */\n-\n-static bool\n-sum_callers (struct cgraph_node *node, void *data)\n-{\n-  struct cgraph_edge *e;\n-  int *num_calls = (int *)data;\n-\n-  for (e = node->callers; e; e = e->next_caller)\n-    (*num_calls)++;\n-  return false;\n-}\n-\n /* Inline NODE to all callers.  Worker for cgraph_for_node_and_aliases.\n    DATA points to number of calls originally found so we avoid infinite\n    recursion.  */"}, {"sha": "85041f67dd74a1a0a8bd6b9468578b817e38e540", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41f669d825086c0d81407815b9c7371fd51815b0/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41f669d825086c0d81407815b9c7371fd51815b0/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=41f669d825086c0d81407815b9c7371fd51815b0", "patch": "@@ -129,6 +129,9 @@ struct GTY(()) inline_summary\n   /* True when function contains cilk spawn (and thus we can not inline\n      into it).  */\n   unsigned contains_cilk_spawn : 1;\n+  /* True wen there is only one caller of the function before small function\n+     inlining.  */\n+  unsigned int single_caller : 1;\n \n   /* Information about function that will result after applying all the\n      inline decisions present in the callgraph.  Generally kept up to"}, {"sha": "a28f3a1ad921d4a356f5f78e5d586ff712469def", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41f669d825086c0d81407815b9c7371fd51815b0/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41f669d825086c0d81407815b9c7371fd51815b0/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=41f669d825086c0d81407815b9c7371fd51815b0", "patch": "@@ -1402,6 +1402,8 @@ split_function (basic_block return_bb, struct split_point *split_point,\n     (vNULL, NULL, args_to_skip, !split_part_return_p, split_point->split_bbs,\n      split_point->entry_bb, \"part\");\n \n+  node->split_part = true;\n+\n   /* Let's take a time profile for splitted function.  */\n   node->tp_first_run = cur_node->tp_first_run + 1;\n "}, {"sha": "fa18d363b202f9aa44d8bf28c0400304e5c6b961", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41f669d825086c0d81407815b9c7371fd51815b0/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41f669d825086c0d81407815b9c7371fd51815b0/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=41f669d825086c0d81407815b9c7371fd51815b0", "patch": "@@ -578,6 +578,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   bp_pack_enum (&bp, ld_plugin_symbol_resolution,\n \t        LDPR_NUM_KNOWN, node->resolution);\n   bp_pack_value (&bp, node->instrumentation_clone, 1);\n+  bp_pack_value (&bp, node->split_part, 1);\n   streamer_write_bitpack (&bp);\n   streamer_write_data_stream (ob->main_stream, section, strlen (section) + 1);\n \n@@ -1214,6 +1215,7 @@ input_overwrite_node (struct lto_file_decl_data *file_data,\n   node->resolution = bp_unpack_enum (bp, ld_plugin_symbol_resolution,\n \t\t\t\t     LDPR_NUM_KNOWN);\n   node->instrumentation_clone = bp_unpack_value (bp, 1);\n+  node->split_part = bp_unpack_value (bp, 1);\n   gcc_assert (flag_ltrans\n \t      || (!node->in_other_partition\n \t\t  && !node->used_from_other_partition));"}, {"sha": "0dd0421fce7814e80cfe45a11ea0901acd804b43", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41f669d825086c0d81407815b9c7371fd51815b0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41f669d825086c0d81407815b9c7371fd51815b0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=41f669d825086c0d81407815b9c7371fd51815b0", "patch": "@@ -1,3 +1,7 @@\n+2015-03-31  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* gcc.dg/ipa/inlinehint-4.c: New testcase.\n+\n 2015-03-31  Alex Velenko  <Alex.Velenko@arm.com>\n \n \t* gcc.target/arm/pr45701-1.c (history_expand_line_internal): Add an"}, {"sha": "52d2f1a67638cad548e5716ed82f5b7659e5fad3", "filename": "gcc/testsuite/gcc.dg/ipa/inlinehint-4.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41f669d825086c0d81407815b9c7371fd51815b0/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finlinehint-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41f669d825086c0d81407815b9c7371fd51815b0/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finlinehint-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finlinehint-4.c?ref=41f669d825086c0d81407815b9c7371fd51815b0", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-options \"-O3 -fdump-ipa-inline-details -fno-early-inlining --param large-unit-insns=1\"  } */\n+/* { dg-add-options bind_pic_locally } */\n+int *hashval;\n+int *hash;\n+int hash_size;\n+\n+static int\n+lookup_slow (int val)\n+{\n+  int i = val % hash_size;\n+  while (hashval[i] && hashval[i] != val)\n+    i++;\n+  return hash[i];\n+}\n+\n+static inline int\n+lookup (int val)\n+{\n+  static int cache, cache_val;\n+  if (val == cache_val)\n+    return cache;\n+  else\n+    {\n+      cache_val = val;\n+      cache = lookup_slow (val);\n+      return cache;\n+    }\n+}\n+\n+int\n+test (int i)\n+{\n+  return lookup (i) + lookup (2 * i) + lookup (3 * i) + lookup (4 * i) +\n+    lookup (5 * i) + lookup (6 * i) + lookup (7 * i) + lookup (8 * i) +\n+    lookup (9 * i);\n+}\n+/* { dg-final { scan-ipa-dump \"Wrapper penalty\"  \"inline\"  } } */\n+/* { dg-final { scan-ipa-dump-not \"Inlining lookup_slow to lookup\"  \"inline\"  } } */\n+/* { dg-final { scan-ipa-dump \"Inlining lookup to test\"  \"inline\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"inline\" } } */"}]}