{"sha": "4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGJhOWZiMGEzZTY1MjU0Y2I1ZDhjYjBhM2JjNjdiYmVmOGVkMmZjZg==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-07-30T09:30:18Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-08-03T06:39:29Z"}, "message": "Multi-range implementation for value_range (irange).\n\nImplement class irange, a generic multi-range implementation for\nvalue ranges.  This class is API compatible with value_range, and is meant\nto seamlessly coexist with it.\n\ngcc/ChangeLog:\n\n\t* Makefile.in (GTFILES): Move value-range.h up.\n\t* gengtype-lex.l: Set yylval to handle GTY markers on templates.\n\t* ipa-cp.c (initialize_node_lattices): Call value_range\n\tconstructor.\n\t(ipcp_propagate_stage): Use in-place new so value_range construct\n\tis called.\n\t* ipa-fnsummary.c (evaluate_conditions_for_known_args): Use std\n\tvec instead of GCC's vec<>.\n\t(evaluate_properties_for_edge): Adjust for std vec.\n\t(ipa_fn_summary_t::duplicate): Same.\n\t(estimate_ipcp_clone_size_and_time): Same.\n\t* ipa-prop.c (ipa_get_value_range): Use in-place new for\n\tvalue_range.\n\t* ipa-prop.h (struct GTY): Remove class keyword for m_vr.\n\t* range-op.cc (empty_range_check): Rename to...\n\t(empty_range_varying): ...this and adjust for varying.\n\t(undefined_shift_range_check): Adjust for irange.\n\t(range_operator::wi_fold): Same.\n\t(range_operator::fold_range): Adjust for irange.  Special case\n\tsingle pairs for performance.\n\t(range_operator::op1_range): Adjust for irange.\n\t(range_operator::op2_range): Same.\n\t(value_range_from_overflowed_bounds): Same.\n\t(value_range_with_overflow): Same.\n\t(create_possibly_reversed_range): Same.\n\t(range_true): Same.\n\t(range_false): Same.\n\t(range_true_and_false): Same.\n\t(get_bool_state):  Adjust for irange and tweak for performance.\n\t(operator_equal::fold_range): Adjust for irange.\n\t(operator_equal::op1_range): Same.\n\t(operator_equal::op2_range): Same.\n\t(operator_not_equal::fold_range): Same.\n\t(operator_not_equal::op1_range): Same.\n\t(operator_not_equal::op2_range): Same.\n\t(build_lt): Same.\n\t(build_le): Same.\n\t(build_gt): Same.\n\t(build_ge): Same.\n\t(operator_lt::fold_range): Same.\n\t(operator_lt::op1_range): Same.\n\t(operator_lt::op2_range): Same.\n\t(operator_le::fold_range): Same.\n\t(operator_le::op1_range): Same.\n\t(operator_le::op2_range): Same.\n\t(operator_gt::fold_range): Same.\n\t(operator_gt::op1_range): Same.\n\t(operator_gt::op2_range): Same.\n\t(operator_ge::fold_range): Same.\n\t(operator_ge::op1_range): Same.\n\t(operator_ge::op2_range): Same.\n\t(operator_plus::wi_fold): Same.\n\t(operator_plus::op1_range): Same.\n\t(operator_plus::op2_range): Same.\n\t(operator_minus::wi_fold): Same.\n\t(operator_minus::op1_range): Same.\n\t(operator_minus::op2_range): Same.\n\t(operator_min::wi_fold): Same.\n\t(operator_max::wi_fold): Same.\n\t(cross_product_operator::wi_cross_product): Same.\n\t(operator_mult::op1_range): New.\n\t(operator_mult::op2_range): New.\n\t(operator_mult::wi_fold): Adjust for irange.\n\t(operator_div::wi_fold): Same.\n\t(operator_exact_divide::op1_range): Same.\n\t(operator_lshift::fold_range): Same.\n\t(operator_lshift::wi_fold): Same.\n\t(operator_lshift::op1_range): New.\n\t(operator_rshift::op1_range): New.\n\t(operator_rshift::fold_range): Adjust for irange.\n\t(operator_rshift::wi_fold): Same.\n\t(operator_cast::truncating_cast_p): Abstract out from\n\toperator_cast::fold_range.\n\t(operator_cast::fold_range): Adjust for irange and tweak for\n\tperformance.\n\t(operator_cast::inside_domain_p): Abstract out from fold_range.\n\t(operator_cast::fold_pair): Same.\n\t(operator_cast::op1_range): Use abstracted methods above.  Adjust\n\tfor irange and tweak for performance.\n\t(operator_logical_and::fold_range): Adjust for irange.\n\t(operator_logical_and::op1_range): Same.\n\t(operator_logical_and::op2_range): Same.\n\t(unsigned_singleton_p): New.\n\t(operator_bitwise_and::remove_impossible_ranges): New.\n\t(operator_bitwise_and::fold_range): New.\n\t(wi_optimize_and_or):  Adjust for irange.\n\t(operator_bitwise_and::wi_fold): Same.\n\t(set_nonzero_range_from_mask): New.\n\t(operator_bitwise_and::simple_op1_range_solver): New.\n\t(operator_bitwise_and::op1_range): Adjust for irange.\n\t(operator_bitwise_and::op2_range): Same.\n\t(operator_logical_or::fold_range): Same.\n\t(operator_logical_or::op1_range): Same.\n\t(operator_logical_or::op2_range): Same.\n\t(operator_bitwise_or::wi_fold): Same.\n\t(operator_bitwise_or::op1_range): Same.\n\t(operator_bitwise_or::op2_range): Same.\n\t(operator_bitwise_xor::wi_fold): Same.\n\t(operator_bitwise_xor::op1_range): New.\n\t(operator_bitwise_xor::op2_range): New.\n\t(operator_trunc_mod::wi_fold):  Adjust for irange.\n\t(operator_logical_not::fold_range): Same.\n\t(operator_logical_not::op1_range): Same.\n\t(operator_bitwise_not::fold_range): Same.\n\t(operator_bitwise_not::op1_range): Same.\n\t(operator_cst::fold_range): Same.\n\t(operator_identity::fold_range): Same.\n\t(operator_identity::op1_range): Same.\n\t(class operator_unknown): New.\n\t(operator_unknown::fold_range): New.\n\t(class operator_abs): Adjust for irange.\n\t(operator_abs::wi_fold): Same.\n\t(operator_abs::op1_range): Same.\n\t(operator_absu::wi_fold): Same.\n\t(class operator_negate): Same.\n\t(operator_negate::fold_range): Same.\n\t(operator_negate::op1_range): Same.\n\t(operator_addr_expr::fold_range): Same.\n\t(operator_addr_expr::op1_range): Same.\n\t(pointer_plus_operator::wi_fold): Same.\n\t(pointer_min_max_operator::wi_fold): Same.\n\t(pointer_and_operator::wi_fold): Same.\n\t(pointer_or_operator::op1_range): New.\n\t(pointer_or_operator::op2_range): New.\n\t(pointer_or_operator::wi_fold):  Adjust for irange.\n\t(integral_table::integral_table): Add entries for IMAGPART_EXPR\n\tand POINTER_DIFF_EXPR.\n\t(range_cast):  Adjust for irange.\n\t(build_range3): New.\n\t(range3_tests): New.\n\t(widest_irange_tests): New.\n\t(multi_precision_range_tests): New.\n\t(operator_tests): New.\n\t(range_tests): New.\n\t* range-op.h (class range_operator): Adjust for irange.\n\t(range_cast): Same.\n\t* tree-vrp.c (range_fold_binary_symbolics_p): Adjust for irange and\n\ttweak for performance.\n\t(range_fold_binary_expr): Same.\n\t(masked_increment): Change to extern.\n\t* tree-vrp.h (masked_increment): New.\n\t* tree.c (cache_wide_int_in_type_cache): New function abstracted\n\tout from wide_int_to_tree_1.\n\t(wide_int_to_tree_1): Cache 0, 1, and MAX for pointers.\n\t* value-range-equiv.cc (value_range_equiv::deep_copy): Use kind\n\tmethod.\n\t(value_range_equiv::move): Same.\n\t(value_range_equiv::check): Adjust for irange.\n\t(value_range_equiv::intersect): Same.\n\t(value_range_equiv::union_): Same.\n\t(value_range_equiv::dump): Same.\n\t* value-range.cc (irange::operator=): Same.\n\t(irange::maybe_anti_range): New.\n\t(irange::copy_legacy_range): New.\n\t(irange::set_undefined): Adjust for irange.\n\t(irange::swap_out_of_order_endpoints): Abstract out from set().\n\t(irange::set_varying): Adjust for irange.\n\t(irange::irange_set): New.\n\t(irange::irange_set_anti_range): New.\n\t(irange::set): Adjust for irange.\n\t(value_range::set_nonzero): Move to header file.\n\t(value_range::set_zero): Move to header file.\n\t(value_range::check): Rename to...\n\t(irange::verify_range): ...this.\n\t(value_range::num_pairs): Rename to...\n\t(irange::legacy_num_pairs): ...this, and adjust for irange.\n\t(value_range::lower_bound): Rename to...\n\t(irange::legacy_lower_bound): ...this, and adjust for irange.\n\t(value_range::upper_bound): Rename to...\n\t(irange::legacy_upper_bound): ...this, and adjust for irange.\n\t(value_range::equal_p): Rename to...\n\t(irange::legacy_equal_p): ...this.\n\t(value_range::operator==): Move to header file.\n\t(irange::equal_p): New.\n\t(irange::symbolic_p): Adjust for irange.\n\t(irange::constant_p): Same.\n\t(irange::singleton_p): Same.\n\t(irange::value_inside_range): Same.\n\t(irange::may_contain_p): Same.\n\t(irange::contains_p): Same.\n\t(irange::normalize_addresses): Same.\n\t(irange::normalize_symbolics): Same.\n\t(irange::legacy_intersect): Same.\n\t(irange::legacy_union): Same.\n\t(irange::union_): Same.\n\t(irange::intersect): Same.\n\t(irange::irange_union): New.\n\t(irange::irange_intersect): New.\n\t(subtract_one): New.\n\t(irange::invert): Adjust for irange.\n\t(dump_bound_with_infinite_markers): New.\n\t(irange::dump): Adjust for irange.\n\t(debug): Add irange versions.\n\t(range_has_numeric_bounds_p): Adjust for irange.\n\t(vrp_val_max): Move to header file.\n\t(vrp_val_min): Move to header file.\n\t(DEFINE_INT_RANGE_GC_STUBS): New.\n\t(DEFINE_INT_RANGE_INSTANCE): New.\n\t* value-range.h (class irange): New.\n\t(class int_range): New.\n\t(class value_range): Rename to a instantiation of int_range.\n\t(irange::legacy_mode_p): New.\n\t(value_range::value_range): Remove.\n\t(irange::kind): New.\n\t(irange::num_pairs): Adjust for irange.\n\t(irange::type): Adjust for irange.\n\t(irange::tree_lower_bound): New.\n\t(irange::tree_upper_bound): New.\n\t(irange::type): Adjust for irange.\n\t(irange::min): Same.\n\t(irange::max): Same.\n\t(irange::varying_p): Same.\n\t(irange::undefined_p): Same.\n\t(irange::zero_p): Same.\n\t(irange::nonzero_p): Same.\n\t(irange::supports_type_p): Same.\n\t(range_includes_zero_p): Same.\n\t(gt_ggc_mx): New.\n\t(gt_pch_nx): New.\n\t(irange::irange): New.\n\t(int_range::int_range): New.\n\t(int_range::operator=): New.\n\t(irange::set): Moved from value-range.cc and adjusted for irange.\n\t(irange::set_undefined): Same.\n\t(irange::set_varying): Same.\n\t(irange::operator==): Same.\n\t(irange::lower_bound): Same.\n\t(irange::upper_bound): Same.\n\t(irange::union_): Same.\n\t(irange::intersect): Same.\n\t(irange::set_nonzero): Same.\n\t(irange::set_zero): Same.\n\t(irange::normalize_min_max): New.\n\t(vrp_val_max): Move from value-range.cc.\n\t(vrp_val_min): Same.\n\t* vr-values.c (vr_values::get_lattice_entry): Call value_range\n\tconstructor.", "tree": {"sha": "ab86507757a78cd9ced10ff9416830e5e3fd0414", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab86507757a78cd9ced10ff9416830e5e3fd0414"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "442b5a661e312b27fc87f769834a2b58412a847a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/442b5a661e312b27fc87f769834a2b58412a847a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/442b5a661e312b27fc87f769834a2b58412a847a"}], "stats": {"total": 4043, "additions": 2868, "deletions": 1175}, "files": [{"sha": "7251c007907e1e0093152a4c025cb909ff1c6b12", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf", "patch": "@@ -2628,13 +2628,13 @@ GTFILES = $(CPPLIB_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/tree-ssa-alias.h \\\n   $(srcdir)/tree-ssanames.h \\\n   $(srcdir)/tree-vrp.h \\\n+  $(srcdir)/value-range.h \\\n   $(srcdir)/ipa-prop.h \\\n   $(srcdir)/trans-mem.c \\\n   $(srcdir)/lto-streamer.h \\\n   $(srcdir)/target-globals.h \\\n   $(srcdir)/ipa-predicate.h \\\n   $(srcdir)/ipa-fnsummary.h \\\n-  $(srcdir)/value-range.h \\\n   $(srcdir)/vtable-verify.c \\\n   $(srcdir)/asan.c \\\n   $(srcdir)/ubsan.c \\"}, {"sha": "9bf6ffa73c4d1641686a0824f0583e79a616b6da", "filename": "gcc/gengtype-lex.l", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf/gcc%2Fgengtype-lex.l", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf/gcc%2Fgengtype-lex.l", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-lex.l?ref=4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf", "patch": "@@ -125,7 +125,10 @@ CXX_KEYWORD inline|public:|private:|protected:|template|operator|friend|static|m\n \"ptr_alias\"/{EOID}\t  \t{ return PTR_ALIAS; }\n \"nested_ptr\"/{EOID}\t\t{ return NESTED_PTR; }\n \"user\"/{EOID}\t\t\t{ return USER_GTY; }\n-[0-9]+\t\t\t\t{ return NUM; }\n+[0-9]+\t\t\t\t{\n+  *yylval = XDUPVAR (const char, yytext, yyleng, yyleng+1);\n+  return NUM;\n+}\n \n {IWORD}({WS}{IWORD})*/{EOID}\t\t|\n \"ENUM_BITFIELD\"{WS}?\"(\"{WS}?{ID}{WS}?\")\"\t{"}, {"sha": "10cc59509d5bd814133fb700e58a4f1f0162ca86", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf", "patch": "@@ -1270,6 +1270,7 @@ initialize_node_lattices (struct cgraph_node *node)\n \t  plats->ctxlat.set_to_bottom ();\n \t  set_agg_lats_to_bottom (plats);\n \t  plats->bits_lattice.set_to_bottom ();\n+\t  plats->m_value_range.m_vr = value_range ();\n \t  plats->m_value_range.set_to_bottom ();\n \t}\n       else\n@@ -3898,8 +3899,10 @@ ipcp_propagate_stage (class ipa_topo_info *topo)\n       {\n         class ipa_node_params *info = IPA_NODE_REF (node);\n         determine_versionability (node, info);\n-\tinfo->lattices = XCNEWVEC (class ipcp_param_lattices,\n-\t\t\t\t   ipa_get_param_count (info));\n+\n+\tunsigned nlattices = ipa_get_param_count (info);\n+\tvoid *chunk = XCNEWVEC (class ipcp_param_lattices, nlattices);\n+\tinfo->lattices = new (chunk) ipcp_param_lattices[nlattices];\n \tinitialize_node_lattices (node);\n       }\n     ipa_size_summary *s = ipa_size_summaries->get (node);"}, {"sha": "49bab04524b48d2664ef09b22619a9e9e220e0d0", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf", "patch": "@@ -82,6 +82,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimplify.h\"\n #include \"stringpool.h\"\n #include \"attribs.h\"\n+#include <vector>\n #include \"tree-into-ssa.h\"\n \n /* Summaries.  */\n@@ -330,7 +331,7 @@ static void\n evaluate_conditions_for_known_args (struct cgraph_node *node,\n \t\t\t\t    bool inline_p,\n \t\t\t\t    vec<tree> known_vals,\n-\t\t\t\t    vec<value_range> known_value_ranges,\n+\t\t\t\t    const std::vector<value_range> &known_value_ranges,\n \t\t\t\t    vec<ipa_agg_value_set> known_aggs,\n \t\t\t\t    clause_t *ret_clause,\n \t\t\t\t    clause_t *ret_nonspec_clause)\n@@ -445,7 +446,7 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n \t      continue;\n \t    }\n \t}\n-      if (c->operand_num < (int) known_value_ranges.length ()\n+      if (c->operand_num < (int) known_value_ranges.size ()\n \t  && !c->agg_contents\n \t  && !known_value_ranges[c->operand_num].undefined_p ()\n \t  && !known_value_ranges[c->operand_num].varying_p ()\n@@ -554,7 +555,7 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n {\n   struct cgraph_node *callee = e->callee->ultimate_alias_target ();\n   class ipa_fn_summary *info = ipa_fn_summaries->get (callee);\n-  auto_vec<value_range, 32> known_value_ranges;\n+  std::vector<value_range> known_value_ranges (32);\n   class ipa_edge_args *args;\n \n   if (clause_ptr)\n@@ -629,8 +630,12 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n \t\t\t\t\t\t\t\t   i));\n \t\t    if (!vr.undefined_p () && !vr.varying_p ())\n \t\t      {\n-\t\t\tif (!known_value_ranges.length ())\n-\t\t\t  known_value_ranges.safe_grow_cleared (count);\n+\t\t\tif (!known_value_ranges.size ())\n+\t\t\t  {\n+\t\t\t    known_value_ranges.resize (count);\n+\t\t\t    for (int i = 0; i < count; ++i)\n+\t\t\t      known_value_ranges[i].set_undefined ();\n+\t\t\t  }\n \t\t\tknown_value_ranges[i] = vr;\n \t\t      }\n \t\t  }\n@@ -803,7 +808,7 @@ ipa_fn_summary_t::duplicate (cgraph_node *src,\n \t}\n       evaluate_conditions_for_known_args (dst, false,\n \t\t\t\t\t  known_vals,\n-\t\t\t\t\t  vNULL,\n+\t\t\t\t\t  std::vector<value_range> (),\n \t\t\t\t\t  vNULL,\n \t\t\t\t\t  &possible_truths,\n \t\t\t\t\t  /* We are going to specialize,\n@@ -3687,7 +3692,8 @@ estimate_ipcp_clone_size_and_time (struct cgraph_node *node,\n   clause_t clause, nonspec_clause;\n \n   /* TODO: Also pass known value ranges.  */\n-  evaluate_conditions_for_known_args (node, false, known_vals, vNULL,\n+  evaluate_conditions_for_known_args (node, false, known_vals,\n+\t\t\t\t      std::vector<value_range> (),\n \t\t\t\t      known_aggs, &clause, &nonspec_clause);\n   ipa_call_context ctx (node, clause, nonspec_clause,\n \t\t        known_vals, known_contexts,"}, {"sha": "da50f0837fd73c7df3e729a34767280928e0ba1c", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf", "patch": "@@ -2059,7 +2059,7 @@ ipa_get_value_range (value_range *tmp)\n   if (*slot)\n     return *slot;\n \n-  value_range *vr = ggc_alloc<value_range> ();\n+  value_range *vr = new (ggc_alloc<value_range> ()) value_range;\n   *vr = *tmp;\n   *slot = vr;\n "}, {"sha": "23fcf905ef353e8ec6003c8cd32c6f9fa4f7f013", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf", "patch": "@@ -318,7 +318,7 @@ struct GTY (()) ipa_jump_func\n   /* Information about value range, containing valid data only when vr_known is\n      true.  The pointed to structure is shared betweed different jump\n      functions.  Use ipa_set_jfunc_vr to set this field.  */\n-  class value_range *m_vr;\n+  value_range *m_vr;\n \n   enum jump_func_type type;\n   /* Represents a value of a jump function.  pass_through is used only in jump"}, {"sha": "c62e3977ce535e2acdae7a68058e773130170b5d", "filename": "gcc/range-op.cc", "status": "modified", "additions": 1335, "deletions": 617, "changes": 1952, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf/gcc%2Frange-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf/gcc%2Frange-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.cc?ref=4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf"}, {"sha": "08f6bf9f73f84eaeb901ea5bd3edc6cf1c2329de", "filename": "gcc/range-op.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf/gcc%2Frange-op.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf/gcc%2Frange-op.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.h?ref=4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf", "patch": "@@ -50,9 +50,9 @@ class range_operator\n {\n public:\n   // Perform an operation between 2 ranges and return it.\n-  virtual bool fold_range (value_range &r, tree type,\n-\t\t\t   const value_range &lh,\n-\t\t\t   const value_range &rh) const;\n+  virtual bool fold_range (irange &r, tree type,\n+\t\t\t   const irange &lh,\n+\t\t\t   const irange &rh) const;\n \n   // Return the range for op[12] in the general case.  LHS is the range for\n   // the LHS of the expression, OP[12]is the range for the other\n@@ -65,24 +65,24 @@ class range_operator\n   //\n   // i.e.  [LHS] = ??? + OP2\n   // is re-formed as R = [LHS] - OP2.\n-  virtual bool op1_range (value_range &r, tree type,\n-\t\t\t  const value_range &lhs,\n-\t\t\t  const value_range &op2) const;\n-  virtual bool op2_range (value_range &r, tree type,\n-\t\t\t  const value_range &lhs,\n-\t\t\t  const value_range &op1) const;\n+  virtual bool op1_range (irange &r, tree type,\n+\t\t\t  const irange &lhs,\n+\t\t\t  const irange &op2) const;\n+  virtual bool op2_range (irange &r, tree type,\n+\t\t\t  const irange &lhs,\n+\t\t\t  const irange &op1) const;\n \n protected:\n   // Perform an integral operation between 2 sub-ranges and return it.\n-  virtual void wi_fold (value_range &r, tree type,\n+  virtual void wi_fold (irange &r, tree type,\n \t\t        const wide_int &lh_lb,\n \t\t        const wide_int &lh_ub,\n \t\t        const wide_int &rh_lb,\n \t\t        const wide_int &rh_ub) const;\n };\n \n extern range_operator *range_op_handler (enum tree_code code, tree type);\n-extern void range_cast (value_range &, tree type);\n+extern void range_cast (irange &, tree type);\n extern void wi_set_zero_nonzero_bits (tree type,\n \t\t\t\t      const wide_int &, const wide_int &,\n \t\t\t\t      wide_int &maybe_nonzero,"}, {"sha": "de84c1d505de2084995b3c878fa84fbc5c6a2fc1", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf", "patch": "@@ -1151,25 +1151,29 @@ static bool\n range_fold_binary_symbolics_p (value_range *vr,\n \t\t\t       tree_code code,\n \t\t\t       tree expr_type,\n-\t\t\t       const value_range *vr0, const value_range *vr1)\n+\t\t\t       const value_range *vr0_,\n+\t\t\t       const value_range *vr1_)\n {\n-  if (vr0->symbolic_p () || vr1->symbolic_p ())\n+  if (vr0_->symbolic_p () || vr1_->symbolic_p ())\n     {\n+      value_range vr0 = drop_undefines_to_varying (vr0_, expr_type);\n+      value_range vr1 = drop_undefines_to_varying (vr1_, expr_type);\n       if ((code == PLUS_EXPR || code == MINUS_EXPR))\n \t{\n-\t  extract_range_from_plus_minus_expr (vr, code, expr_type, vr0, vr1);\n+\t  extract_range_from_plus_minus_expr (vr, code, expr_type,\n+\t\t\t\t\t      &vr0, &vr1);\n \t  return true;\n \t}\n       if (POINTER_TYPE_P (expr_type) && code == POINTER_PLUS_EXPR)\n \t{\n-\t  extract_range_from_pointer_plus_expr (vr, code, expr_type, vr0, vr1);\n+\t  extract_range_from_pointer_plus_expr (vr, code, expr_type,\n+\t\t\t\t\t\t&vr0, &vr1);\n \t  return true;\n \t}\n       const range_operator *op = get_range_op_handler (vr, code, expr_type);\n-      value_range vr0_cst (*vr0), vr1_cst (*vr1);\n-      vr0_cst.normalize_symbolics ();\n-      vr1_cst.normalize_symbolics ();\n-      return op->fold_range (*vr, expr_type, vr0_cst, vr1_cst);\n+      vr0.normalize_symbolics ();\n+      vr1.normalize_symbolics ();\n+      return op->fold_range (*vr, expr_type, vr0, vr1);\n     }\n   return false;\n }\n@@ -1225,11 +1229,15 @@ range_fold_binary_expr (value_range *vr,\n   if (!op)\n     return;\n \n-  value_range vr0 = drop_undefines_to_varying (vr0_, expr_type);\n-  value_range vr1 = drop_undefines_to_varying (vr1_, expr_type);\n-  if (range_fold_binary_symbolics_p (vr, code, expr_type, &vr0, &vr1))\n+  if (range_fold_binary_symbolics_p (vr, code, expr_type, vr0_, vr1_))\n     return;\n \n+  value_range vr0 (*vr0_);\n+  value_range vr1 (*vr1_);\n+  if (vr0.undefined_p ())\n+    vr0.set_varying (expr_type);\n+  if (vr1.undefined_p ())\n+    vr1.set_varying (expr_type);\n   vr0.normalize_addresses ();\n   vr1.normalize_addresses ();\n   op->fold_range (*vr, expr_type, vr0, vr1);\n@@ -1637,7 +1645,7 @@ extract_code_and_val_from_cond_with_ops (tree name, enum tree_code cond_code,\n    (to transform signed values into unsigned) and at the end xor\n    SGNBIT back.  */\n \n-static wide_int\n+wide_int\n masked_increment (const wide_int &val_in, const wide_int &mask,\n \t\t  const wide_int &sgnbit, unsigned int prec)\n {"}, {"sha": "371e58aa0ea13b9eaf5dd0e29452a6d692610014", "filename": "gcc/tree-vrp.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf/gcc%2Ftree-vrp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf/gcc%2Ftree-vrp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.h?ref=4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf", "patch": "@@ -62,5 +62,7 @@ extern bool overflow_comparison_p (tree_code, tree, tree, bool, tree *);\n extern tree get_single_symbol (tree, bool *, tree *);\n extern void maybe_set_nonzero_bits (edge, tree);\n extern value_range_kind determine_value_range (tree, wide_int *, wide_int *);\n+extern wide_int masked_increment (const wide_int &val_in, const wide_int &mask,\n+\t\t\t\t  const wide_int &sgnbit, unsigned int prec);\n \n #endif /* GCC_TREE_VRP_H */"}, {"sha": "01a342c5b9235e1e21a63bf47879de65659e6bc2", "filename": "gcc/tree.c", "status": "modified", "additions": 57, "deletions": 28, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf", "patch": "@@ -1483,6 +1483,31 @@ int_cst_hasher::equal (tree x, tree y)\n   return true;\n }\n \n+/* Cache wide_int CST into the TYPE_CACHED_VALUES cache for TYPE.\n+   SLOT is the slot entry to store it in, and MAX_SLOTS is the maximum\n+   number of slots that can be cached for the type.  */\n+\n+static inline tree\n+cache_wide_int_in_type_cache (tree type, const wide_int &cst,\n+\t\t\t      int slot, int max_slots)\n+{\n+  gcc_checking_assert (slot >= 0);\n+  /* Initialize cache.  */\n+  if (!TYPE_CACHED_VALUES_P (type))\n+    {\n+      TYPE_CACHED_VALUES_P (type) = 1;\n+      TYPE_CACHED_VALUES (type) = make_tree_vec (max_slots);\n+    }\n+  tree t = TREE_VEC_ELT (TYPE_CACHED_VALUES (type), slot);\n+  if (!t)\n+    {\n+      /* Create a new shared int.  */\n+      t = build_new_int_cst (type, cst);\n+      TREE_VEC_ELT (TYPE_CACHED_VALUES (type), slot) = t;\n+    }\n+  return t;\n+}\n+\n /* Create an INT_CST node of TYPE and value CST.\n    The returned node is always shared.  For small integers we use a\n    per-type vector cache, for larger ones we use a single hash table.\n@@ -1515,6 +1540,28 @@ wide_int_to_tree_1 (tree type, const wide_int_ref &pcst)\n   wide_int cst = wide_int::from (pcst, prec, sgn);\n   unsigned int ext_len = get_int_cst_ext_nunits (type, cst);\n \n+  enum tree_code code = TREE_CODE (type);\n+  if (code == POINTER_TYPE || code == REFERENCE_TYPE)\n+    {\n+      /* Cache NULL pointer and zero bounds.  */\n+      if (cst == 0)\n+\tix = 0;\n+      /* Cache upper bounds of pointers.  */\n+      else if (cst == wi::max_value (prec, sgn))\n+\tix = 1;\n+      /* Cache 1 which is used for a non-zero range.  */\n+      else if (cst == 1)\n+\tix = 2;\n+\n+      if (ix >= 0)\n+\t{\n+\t  t = cache_wide_int_in_type_cache (type, cst, ix, 3);\n+\t  /* Make sure no one is clobbering the shared constant.  */\n+\t  gcc_checking_assert (TREE_TYPE (t) == type\n+\t\t\t       && cst == wi::to_wide (t));\n+\t  return t;\n+\t}\n+    }\n   if (ext_len == 1)\n     {\n       /* We just need to store a single HOST_WIDE_INT.  */\n@@ -1524,20 +1571,15 @@ wide_int_to_tree_1 (tree type, const wide_int_ref &pcst)\n       else\n \thwi = cst.to_shwi ();\n \n-      switch (TREE_CODE (type))\n+      switch (code)\n \t{\n \tcase NULLPTR_TYPE:\n \t  gcc_assert (hwi == 0);\n \t  /* Fallthru.  */\n \n \tcase POINTER_TYPE:\n \tcase REFERENCE_TYPE:\n-\t  /* Cache NULL pointer and zero bounds.  */\n-\t  if (hwi == 0)\n-\t    {\n-\t      limit = 1;\n-\t      ix = 0;\n-\t    }\n+\t  /* Ignore pointers, as they were already handled above.  */\n \t  break;\n \n \tcase BOOLEAN_TYPE:\n@@ -1574,27 +1616,14 @@ wide_int_to_tree_1 (tree type, const wide_int_ref &pcst)\n \n       if (ix >= 0)\n \t{\n-\t  /* Look for it in the type's vector of small shared ints.  */\n-\t  if (!TYPE_CACHED_VALUES_P (type))\n-\t    {\n-\t      TYPE_CACHED_VALUES_P (type) = 1;\n-\t      TYPE_CACHED_VALUES (type) = make_tree_vec (limit);\n-\t    }\n-\n-\t  t = TREE_VEC_ELT (TYPE_CACHED_VALUES (type), ix);\n-\t  if (t)\n-\t    /* Make sure no one is clobbering the shared constant.  */\n-\t    gcc_checking_assert (TREE_TYPE (t) == type\n-\t\t\t\t && TREE_INT_CST_NUNITS (t) == 1\n-\t\t\t\t && TREE_INT_CST_OFFSET_NUNITS (t) == 1\n-\t\t\t\t && TREE_INT_CST_EXT_NUNITS (t) == 1\n-\t\t\t\t && TREE_INT_CST_ELT (t, 0) == hwi);\n-\t  else\n-\t    {\n-\t      /* Create a new shared int.  */\n-\t      t = build_new_int_cst (type, cst);\n-\t      TREE_VEC_ELT (TYPE_CACHED_VALUES (type), ix) = t;\n-\t    }\n+\t  t = cache_wide_int_in_type_cache (type, cst, ix, limit);\n+\t  /* Make sure no one is clobbering the shared constant.  */\n+\t  gcc_checking_assert (TREE_TYPE (t) == type\n+\t\t\t       && TREE_INT_CST_NUNITS (t) == 1\n+\t\t\t       && TREE_INT_CST_OFFSET_NUNITS (t) == 1\n+\t\t\t       && TREE_INT_CST_EXT_NUNITS (t) == 1\n+\t\t\t       && TREE_INT_CST_ELT (t, 0) == hwi);\n+\t  return t;\n \t}\n       else\n \t{"}, {"sha": "7dc10b876e02318a0c425d7d020dd16e2666b70f", "filename": "gcc/value-range-equiv.cc", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf/gcc%2Fvalue-range-equiv.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf/gcc%2Fvalue-range-equiv.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range-equiv.cc?ref=4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf", "patch": "@@ -90,13 +90,13 @@ value_range_equiv::update (tree min, tree max, value_range_kind kind)\n void\n value_range_equiv::deep_copy (const value_range_equiv *from)\n {\n-  set (from->min (), from->max (), from->m_equiv, from->m_kind);\n+  set (from->min (), from->max (), from->m_equiv, from->kind ());\n }\n \n void\n value_range_equiv::move (value_range_equiv *from)\n {\n-  set (from->min (), from->max (), NULL, from->m_kind);\n+  set (from->min (), from->max (), NULL, from->kind ());\n   m_equiv = from->m_equiv;\n   from->m_equiv = NULL;\n }\n@@ -127,8 +127,8 @@ value_range_equiv::set_equiv (bitmap equiv)\n void\n value_range_equiv::check ()\n {\n-  value_range::check ();\n-  switch (m_kind)\n+  value_range::verify_range ();\n+  switch (kind ())\n     {\n     case VR_UNDEFINED:\n     case VR_VARYING:\n@@ -206,8 +206,9 @@ value_range_equiv::intersect (const value_range_equiv *other)\n     this->deep_copy (other);\n   else\n     {\n-      value_range tem = intersect_helper (this, other);\n-      this->update (tem.min (), tem.max (), tem.kind ());\n+      legacy_intersect (this, other);\n+      if (varying_p () || undefined_p ())\n+\tequiv_clear ();\n \n       /* If the result is VR_UNDEFINED there is no need to mess with\n \t equivalencies.  */\n@@ -254,8 +255,9 @@ value_range_equiv::union_ (const value_range_equiv *other)\n     this->deep_copy (other);\n   else\n     {\n-      value_range tem = union_helper (this, other);\n-      this->update (tem.min (), tem.max (), tem.kind ());\n+      legacy_union (this, other);\n+      if (varying_p () || undefined_p ())\n+\tequiv_clear ();\n \n       /* The resulting set of equivalences is always the intersection of\n \t the two sets.  */\n@@ -277,7 +279,7 @@ void\n value_range_equiv::dump (FILE *file) const\n {\n   value_range::dump (file);\n-  if ((m_kind == VR_RANGE || m_kind == VR_ANTI_RANGE)\n+  if ((kind () == VR_RANGE || kind () == VR_ANTI_RANGE)\n       && m_equiv)\n     {\n       bitmap_iterator bi;"}, {"sha": "93164b7e2e213895a294d9a806806c326caefbe2", "filename": "gcc/value-range.cc", "status": "modified", "additions": 903, "deletions": 389, "changes": 1292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf/gcc%2Fvalue-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf/gcc%2Fvalue-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.cc?ref=4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf", "patch": "@@ -1,5 +1,7 @@\n /* Support routines for value ranges.\n    Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Major hacks by Aldy Hernandez <aldyh@redhat.com> and\n+   Andrew MacLeod <amacleod@redhat.com>.\n \n This file is part of GCC.\n \n@@ -27,45 +29,168 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pretty-print.h\"\n #include \"fold-const.h\"\n \n-value_range::value_range (tree min, tree max, value_range_kind kind)\n+// Here we copy between any two irange's.  The ranges can be legacy or\n+// multi-ranges, and copying between any combination works correctly.\n+\n+irange &\n+irange::operator= (const irange &src)\n+{\n+  if (legacy_mode_p () != src.legacy_mode_p ())\n+    {\n+      copy_legacy_range (src);\n+      return *this;\n+    }\n+  if (legacy_mode_p ())\n+    {\n+      gcc_checking_assert (src.legacy_mode_p ());\n+      m_num_ranges = src.m_num_ranges;\n+      m_base[0] = src.m_base[0];\n+      m_base[1] = src.m_base[1];\n+      m_kind = src.m_kind;\n+      return *this;\n+    }\n+\n+  unsigned x;\n+  unsigned lim = src.m_num_ranges;\n+  if (lim > m_max_ranges)\n+    lim = m_max_ranges;\n+\n+  for (x = 0; x < lim * 2; ++x)\n+    m_base[x] = src.m_base[x];\n+\n+  // If the range didn't fit, the last range should cover the rest.\n+  if (lim != src.m_num_ranges)\n+    m_base[x - 1] = src.m_base[src.m_num_ranges * 2 - 1];\n+\n+  m_num_ranges = lim;\n+  return *this;\n+}\n+\n+// Return TRUE if range is a multi-range that can be represented as a\n+// VR_ANTI_RANGE.\n+\n+bool\n+irange::maybe_anti_range () const\n {\n-  set (min, max, kind);\n+  tree ttype = type ();\n+  unsigned int precision = TYPE_PRECISION (ttype);\n+  signop sign = TYPE_SIGN (ttype);\n+  return (num_pairs () > 1\n+\t  && precision > 1\n+\t  && lower_bound () == wi::min_value (precision, sign)\n+\t  && upper_bound () == wi::max_value (precision, sign));\n }\n \n-value_range::value_range (tree type)\n+// Copy between a legacy and a multi-range, or vice-versa.\n+\n+void\n+irange::copy_legacy_range (const irange &src)\n {\n-  set_varying (type);\n+  gcc_checking_assert (src.legacy_mode_p () != legacy_mode_p ());\n+  if (src.undefined_p ())\n+    set_undefined ();\n+  else if (src.varying_p ())\n+    set_varying (src.type ());\n+  else if (src.kind () == VR_ANTI_RANGE)\n+    set (src.min (), src.max (), VR_ANTI_RANGE);\n+  else if (legacy_mode_p () && src.maybe_anti_range ())\n+    {\n+      int_range<3> tmp (src);\n+      tmp.invert ();\n+      set (tmp.min (), wide_int_to_tree (src.type (), tmp.upper_bound (0)),\n+\t   VR_ANTI_RANGE);\n+    }\n+  else\n+    set (src.min (), src.max (), VR_RANGE);\n }\n \n-value_range::value_range (tree type,\n-\t\t\t  const wide_int &wmin, const wide_int &wmax,\n-\t\t\t  enum value_range_kind kind)\n+// Swap min/max if they are out of order.  Return TRUE if further\n+// processing of the range is necessary, FALSE otherwise.\n+\n+bool\n+irange::swap_out_of_order_endpoints (tree &min, tree &max,\n+\t\t\t\t\t  value_range_kind &kind)\n {\n-  tree min = wide_int_to_tree (type, wmin);\n-  tree max = wide_int_to_tree (type, wmax);\n-  gcc_checking_assert (kind == VR_RANGE || kind == VR_ANTI_RANGE);\n-  set (min, max, kind);\n+  /* Wrong order for min and max, to swap them and the VR type we need\n+     to adjust them.  */\n+  if (tree_int_cst_lt (max, min))\n+    {\n+      tree one, tmp;\n+\n+      /* For one bit precision if max < min, then the swapped\n+\t range covers all values, so for VR_RANGE it is varying and\n+\t for VR_ANTI_RANGE empty range, so drop to varying as well.  */\n+      if (TYPE_PRECISION (TREE_TYPE (min)) == 1)\n+\t{\n+\t  set_varying (TREE_TYPE (min));\n+\t  return false;\n+\t}\n+\n+      one = build_int_cst (TREE_TYPE (min), 1);\n+      tmp = int_const_binop (PLUS_EXPR, max, one);\n+      max = int_const_binop (MINUS_EXPR, min, one);\n+      min = tmp;\n+\n+      /* There's one corner case, if we had [C+1, C] before we now have\n+\t that again.  But this represents an empty value range, so drop\n+\t to varying in this case.  */\n+      if (tree_int_cst_lt (max, min))\n+\t{\n+\t  set_varying (TREE_TYPE (min));\n+\t  return false;\n+\t}\n+      kind = kind == VR_RANGE ? VR_ANTI_RANGE : VR_RANGE;\n+    }\n+  return true;\n }\n \n void\n-value_range::set_undefined ()\n+irange::irange_set (tree min, tree max)\n {\n-  m_kind = VR_UNDEFINED;\n-  m_min = m_max = NULL;\n+  gcc_checking_assert (!POLY_INT_CST_P (min));\n+  gcc_checking_assert (!POLY_INT_CST_P (max));\n+\n+  m_base[0] = min;\n+  m_base[1] = max;\n+  m_num_ranges = 1;\n+  if (flag_checking)\n+    verify_range ();\n }\n \n void\n-value_range::set_varying (tree type)\n+irange::irange_set_anti_range (tree min, tree max)\n {\n-  m_kind = VR_VARYING;\n-  if (supports_type_p (type))\n+  gcc_checking_assert (!POLY_INT_CST_P (min));\n+  gcc_checking_assert (!POLY_INT_CST_P (max));\n+\n+  // set an anti-range\n+  tree type = TREE_TYPE (min);\n+  signop sign = TYPE_SIGN (type);\n+  int_range<2> type_range (type);\n+  // Calculate INVERSE([I,J]) as [-MIN, I-1][J+1, +MAX].\n+  m_num_ranges = 0;\n+  wi::overflow_type ovf;\n+\n+  wide_int w_min = wi::to_wide (min);\n+  if (wi::ne_p (w_min, type_range.lower_bound ()))\n     {\n-      m_min = vrp_val_min (type);\n-      m_max = vrp_val_max (type);\n+      wide_int lim1 = wi::sub (w_min, 1, sign, &ovf);\n+      gcc_checking_assert (ovf != wi::OVF_OVERFLOW);\n+      m_base[0] = type_range.tree_lower_bound (0);\n+      m_base[1] = wide_int_to_tree (type, lim1);\n+      m_num_ranges = 1;\n     }\n-  else\n-    /* We can't do anything range-wise with these types.  */\n-    m_min = m_max = error_mark_node;\n+  wide_int w_max = wi::to_wide (max);\n+  if (wi::ne_p (w_max, type_range.upper_bound ()))\n+    {\n+      wide_int lim2 = wi::add (w_max, 1, sign, &ovf);\n+      gcc_checking_assert (ovf != wi::OVF_OVERFLOW);\n+      m_base[m_num_ranges * 2] = wide_int_to_tree (type, lim2);\n+      m_base[m_num_ranges * 2 + 1] = type_range.tree_upper_bound (0);\n+      ++m_num_ranges;\n+    }\n+  if (flag_checking)\n+    verify_range ();\n }\n \n /* Set value range to the canonical form of {VRTYPE, MIN, MAX, EQUIV}.\n@@ -78,15 +203,24 @@ value_range::set_varying (tree type)\n    extract ranges from var + CST op limit.  */\n \n void\n-value_range::set (tree min, tree max, value_range_kind kind)\n+irange::set (tree min, tree max, value_range_kind kind)\n {\n-  /* Use the canonical setters for VR_UNDEFINED and VR_VARYING.  */\n+  if (!legacy_mode_p ())\n+    {\n+      if (kind == VR_RANGE)\n+\tirange_set (min, max);\n+      else\n+\t{\n+\t  gcc_checking_assert (kind == VR_ANTI_RANGE);\n+\t  irange_set_anti_range (min, max);\n+\t}\n+      return;\n+    }\n   if (kind == VR_UNDEFINED)\n     {\n       set_undefined ();\n       return;\n     }\n-\n   if (kind == VR_RANGE)\n     {\n       /* Convert POLY_INT_CST bounds into worst-case INTEGER_CST bounds.  */\n@@ -109,68 +243,30 @@ value_range::set (tree min, tree max, value_range_kind kind)\n     }\n   else if (kind != VR_VARYING)\n     {\n-      if (POLY_INT_CST_P (min) || POLY_INT_CST_P (max))\n-\tkind = VR_VARYING;\n+     if (POLY_INT_CST_P (min) || POLY_INT_CST_P (max))\n+       kind = VR_VARYING;\n     }\n-\n   if (kind == VR_VARYING)\n     {\n-      gcc_assert (TREE_TYPE (min) == TREE_TYPE (max));\n-      tree typ = TREE_TYPE (min);\n-      if (supports_type_p (typ))\n-\t{\n-\t  gcc_assert (vrp_val_min (typ));\n-\t  gcc_assert (vrp_val_max (typ));\n-\t}\n-      set_varying (typ);\n+      set_varying (TREE_TYPE (min));\n       return;\n     }\n \n-  /* Nothing to canonicalize for symbolic ranges.  */\n+  tree type = TREE_TYPE (min);\n+  // Nothing to canonicalize for symbolic ranges.\n   if (TREE_CODE (min) != INTEGER_CST\n       || TREE_CODE (max) != INTEGER_CST)\n     {\n       m_kind = kind;\n-      m_min = min;\n-      m_max = max;\n+      m_base[0] = min;\n+      m_base[1] = max;\n+      m_num_ranges = 1;\n       return;\n     }\n+  if (!swap_out_of_order_endpoints (min, max, kind))\n+    goto cleanup_set;\n \n-  /* Wrong order for min and max, to swap them and the VR type we need\n-     to adjust them.  */\n-  if (tree_int_cst_lt (max, min))\n-    {\n-      tree one, tmp;\n-\n-      /* For one bit precision if max < min, then the swapped\n-\t range covers all values, so for VR_RANGE it is varying and\n-\t for VR_ANTI_RANGE empty range, so drop to varying as well.  */\n-      if (TYPE_PRECISION (TREE_TYPE (min)) == 1)\n-\t{\n-\t  set_varying (TREE_TYPE (min));\n-\t  return;\n-\t}\n-\n-      one = build_int_cst (TREE_TYPE (min), 1);\n-      tmp = int_const_binop (PLUS_EXPR, max, one);\n-      max = int_const_binop (MINUS_EXPR, min, one);\n-      min = tmp;\n-\n-      /* There's one corner case, if we had [C+1, C] before we now have\n-\t that again.  But this represents an empty value range, so drop\n-\t to varying in this case.  */\n-      if (tree_int_cst_lt (max, min))\n-\t{\n-\t  set_varying (TREE_TYPE (min));\n-\t  return;\n-\t}\n-\n-      kind = kind == VR_RANGE ? VR_ANTI_RANGE : VR_RANGE;\n-    }\n-\n-  tree type = TREE_TYPE (min);\n-\n-  /* Anti-ranges that can be represented as ranges should be so.  */\n+  // Anti-ranges that can be represented as ranges should be so.\n   if (kind == VR_ANTI_RANGE)\n     {\n       /* For -fstrict-enums we may receive out-of-range ranges so consider\n@@ -211,109 +307,90 @@ value_range::set (tree min, tree max, value_range_kind kind)\n \t  kind = VR_RANGE;\n         }\n     }\n+  else if (!swap_out_of_order_endpoints (min, max, kind))\n+    goto cleanup_set;\n \n-  /* Normalize [MIN, MAX] into VARYING and ~[MIN, MAX] into UNDEFINED.\n+  /* Do not drop [-INF(OVF), +INF(OVF)] to varying.  (OVF) has to be sticky\n+     to make sure VRP iteration terminates, otherwise we can get into\n+     oscillations.  */\n+  if (!normalize_min_max (type, min, max, kind))\n+    {\n+      m_kind = kind;\n+      m_base[0] = min;\n+      m_base[1] = max;\n+      m_num_ranges = 1;\n+      if (flag_checking)\n+\tverify_range ();\n+    }\n \n-     Avoid using TYPE_{MIN,MAX}_VALUE because -fstrict-enums can\n-     restrict those to a subset of what actually fits in the type.\n-     Instead use the extremes of the type precision which will allow\n-     compare_range_with_value() to check if a value is inside a range,\n-     whereas if we used TYPE_*_VAL, said function would just punt\n-     upon seeing a VARYING.  */\n+ cleanup_set:\n+  // Avoid using TYPE_{MIN,MAX}_VALUE because -fstrict-enums can\n+  // restrict those to a subset of what actually fits in the type.\n+  // Instead use the extremes of the type precision\n   unsigned prec = TYPE_PRECISION (type);\n   signop sign = TYPE_SIGN (type);\n   if (wi::eq_p (wi::to_wide (min), wi::min_value (prec, sign))\n       && wi::eq_p (wi::to_wide (max), wi::max_value (prec, sign)))\n-    {\n-      if (kind == VR_RANGE)\n-\tset_varying (type);\n-      else if (kind == VR_ANTI_RANGE)\n-\tset_undefined ();\n-      else\n-\tgcc_unreachable ();\n-      return;\n-    }\n-\n-  /* Do not drop [-INF(OVF), +INF(OVF)] to varying.  (OVF) has to be sticky\n-     to make sure VRP iteration terminates, otherwise we can get into\n-     oscillations.  */\n-\n-  m_kind = kind;\n-  m_min = min;\n-  m_max = max;\n+    m_kind = VR_VARYING;\n+  else if (undefined_p ())\n+    m_kind = VR_UNDEFINED;\n   if (flag_checking)\n-    check ();\n-}\n-\n-void\n-value_range::set (tree val)\n-{\n-  gcc_assert (TREE_CODE (val) == SSA_NAME || is_gimple_min_invariant (val));\n-  if (TREE_OVERFLOW_P (val))\n-    val = drop_tree_overflow (val);\n-  set (val, val);\n-}\n-\n-/* Set value range VR to a nonzero range of type TYPE.  */\n-\n-void\n-value_range::set_nonzero (tree type)\n-{\n-  tree zero = build_int_cst (type, 0);\n-  set (zero, zero, VR_ANTI_RANGE);\n-}\n-\n-/* Set value range VR to a ZERO range of type TYPE.  */\n-\n-void\n-value_range::set_zero (tree type)\n-{\n-  set (build_int_cst (type, 0));\n+    verify_range ();\n }\n \n /* Check the validity of the range.  */\n \n void\n-value_range::check ()\n+irange::verify_range ()\n {\n-  switch (m_kind)\n+  if (!legacy_mode_p ())\n     {\n-    case VR_RANGE:\n-    case VR_ANTI_RANGE:\n-      {\n-\tgcc_assert (m_min && m_max);\n-\tgcc_assert (!TREE_OVERFLOW_P (m_min) && !TREE_OVERFLOW_P (m_max));\n-\n-\t/* Creating ~[-MIN, +MAX] is stupid because that would be\n-\t   the empty set.  */\n-\tif (INTEGRAL_TYPE_P (TREE_TYPE (m_min)) && m_kind == VR_ANTI_RANGE)\n-\t  gcc_assert (!vrp_val_is_min (m_min) || !vrp_val_is_max (m_max));\n+      gcc_checking_assert (m_kind == VR_RANGE);\n+      for (unsigned i = 0; i < m_num_ranges; ++i)\n+\t{\n+\t  tree lb = tree_lower_bound (i);\n+\t  tree ub = tree_upper_bound (i);\n+\t  int c = compare_values (lb, ub);\n+\t  gcc_assert (c == 0 || c == -1);\n+\t}\n+      return;\n+    }\n \n-\tint cmp = compare_values (m_min, m_max);\n-\tgcc_assert (cmp == 0 || cmp == -1 || cmp == -2);\n-\tbreak;\n-      }\n+  switch (m_kind)\n+    {\n     case VR_UNDEFINED:\n-      gcc_assert (!min () && !max ());\n+      gcc_assert (m_num_ranges == 0);\n       break;\n+\n     case VR_VARYING:\n-      gcc_assert (m_min && m_max);\n+      gcc_assert (m_num_ranges == 1);\n       break;\n+\n+    case VR_ANTI_RANGE:\n+    case VR_RANGE:\n+      {\n+\tgcc_assert (m_num_ranges == 1);\n+\tint cmp = compare_values (tree_lower_bound (0), tree_upper_bound (0));\n+\tgcc_assert (cmp == 0 || cmp == -1 || cmp == -2);\n+\treturn;\n+      }\n+\n     default:\n       gcc_unreachable ();\n     }\n }\n \n-/* Return the number of sub-ranges in a range.  */\n-\n unsigned\n-value_range::num_pairs () const\n+irange::legacy_num_pairs () const\n {\n+  gcc_checking_assert (legacy_mode_p ());\n+\n   if (undefined_p ())\n     return 0;\n   if (varying_p ())\n     return 1;\n-  if (symbolic_p ())\n+  // Inlined symbolic_p for performance:\n+  if (!is_gimple_min_invariant (min ()) || !is_gimple_min_invariant (max ()))\n     {\n       value_range numeric_range (*this);\n       numeric_range.normalize_symbolics ();\n@@ -323,111 +400,124 @@ value_range::num_pairs () const\n     {\n       // ~[MIN, X] has one sub-range of [X+1, MAX], and\n       // ~[X, MAX] has one sub-range of [MIN, X-1].\n-      if (vrp_val_is_min (m_min) || vrp_val_is_max (m_max))\n+      if (vrp_val_is_min (min ()) || vrp_val_is_max (max ()))\n \treturn 1;\n       return 2;\n     }\n+  gcc_checking_assert (m_num_ranges == 1);\n   return 1;\n }\n \n-/* Return the lower bound for a sub-range.  PAIR is the sub-range in\n-   question.  */\n+// Return the lower bound for a sub-range.  PAIR is the sub-range in\n+// question.\n \n wide_int\n-value_range::lower_bound (unsigned pair) const\n+irange::legacy_lower_bound (unsigned pair) const\n {\n+  gcc_checking_assert (legacy_mode_p ());\n   if (symbolic_p ())\n     {\n       value_range numeric_range (*this);\n       numeric_range.normalize_symbolics ();\n-      return numeric_range.lower_bound (pair);\n+      return numeric_range.legacy_lower_bound (pair);\n     }\n-\n   gcc_checking_assert (!undefined_p ());\n   gcc_checking_assert (pair + 1 <= num_pairs ());\n-  tree t = NULL;\n   if (m_kind == VR_ANTI_RANGE)\n     {\n-      tree typ = type ();\n-      if (pair == 1 || vrp_val_is_min (m_min))\n-\tt = wide_int_to_tree (typ, wi::to_wide (m_max) + 1);\n+      tree typ = type (), t;\n+      if (pair == 1 || vrp_val_is_min (min ()))\n+\tt = wide_int_to_tree (typ, wi::to_wide (max ()) + 1);\n       else\n \tt = vrp_val_min (typ);\n+      return wi::to_wide (t);\n     }\n-  else\n-    t = m_min;\n-  return wi::to_wide (t);\n+ return wi::to_wide (tree_lower_bound (pair));\n }\n \n-/* Return the upper bound for a sub-range.  PAIR is the sub-range in\n-   question.  */\n+// Return the upper bound for a sub-range.  PAIR is the sub-range in\n+// question.\n \n wide_int\n-value_range::upper_bound (unsigned pair) const\n+irange::legacy_upper_bound (unsigned pair) const\n {\n+  gcc_checking_assert (legacy_mode_p ());\n   if (symbolic_p ())\n     {\n       value_range numeric_range (*this);\n       numeric_range.normalize_symbolics ();\n-      return numeric_range.upper_bound (pair);\n+      return numeric_range.legacy_upper_bound (pair);\n     }\n-\n   gcc_checking_assert (!undefined_p ());\n   gcc_checking_assert (pair + 1 <= num_pairs ());\n-  tree t = NULL;\n   if (m_kind == VR_ANTI_RANGE)\n     {\n-      tree typ = type ();\n-      if (pair == 1 || vrp_val_is_min (m_min))\n+      tree typ = type (), t;\n+      if (pair == 1 || vrp_val_is_min (min ()))\n \tt = vrp_val_max (typ);\n       else\n-\tt = wide_int_to_tree (typ, wi::to_wide (m_min) - 1);\n+\tt = wide_int_to_tree (typ, wi::to_wide (min ()) - 1);\n+      return wi::to_wide (t);\n     }\n-  else\n-    t = m_max;\n-  return wi::to_wide (t);\n-}\n-\n-/* Return the highest bound in a range.  */\n-\n-wide_int\n-value_range::upper_bound () const\n-{\n-  unsigned pairs = num_pairs ();\n-  gcc_checking_assert (pairs > 0);\n-  return upper_bound (pairs - 1);\n+  return wi::to_wide (tree_upper_bound (pair));\n }\n \n bool\n-value_range::equal_p (const value_range &other) const\n+irange::legacy_equal_p (const irange &other) const\n {\n-  /* Ignore types for undefined.  All undefines are equal.  */\n-  if (undefined_p ())\n-    return m_kind == other.m_kind;\n+  gcc_checking_assert (legacy_mode_p () && other.legacy_mode_p ());\n \n-  return (m_kind == other.m_kind\n-\t  && vrp_operand_equal_p (m_min, other.m_min)\n-\t  && vrp_operand_equal_p (m_max, other.m_max));\n+  if (m_kind != other.m_kind)\n+   return false;\n+  if (m_kind == VR_UNDEFINED || m_kind == VR_VARYING)\n+    return true;\n+  return (vrp_operand_equal_p (tree_lower_bound (0),\n+\t\t\t       other.tree_lower_bound (0))\n+\t  && vrp_operand_equal_p (tree_upper_bound (0),\n+\t\t\t\t  other.tree_upper_bound (0)));\n }\n \n bool\n-value_range::operator== (const value_range &r) const\n+irange::equal_p (const irange &other) const\n {\n-  return equal_p (r);\n+  if (legacy_mode_p ())\n+    {\n+      if (other.legacy_mode_p ())\n+\treturn legacy_equal_p (other);\n+      value_range tmp (other);\n+      return legacy_equal_p (tmp);\n+    }\n+  if (other.legacy_mode_p ())\n+    {\n+      value_range tmp2 (*this);\n+      return tmp2.legacy_equal_p (other);\n+    }\n+\n+  if (m_num_ranges != other.m_num_ranges)\n+    return false;\n+\n+  for (unsigned i = 0; i < m_num_ranges; ++i)\n+    {\n+      tree lb = tree_lower_bound (i);\n+      tree ub = tree_upper_bound (i);\n+      tree lb_other = other.tree_lower_bound (i);\n+      tree ub_other = other.tree_upper_bound (i);\n+      if (!operand_equal_p (lb, lb_other, 0)\n+\t  || !operand_equal_p (ub, ub_other, 0))\n+\treturn false;\n+    }\n+  return true;\n }\n \n-/* If range is a singleton, place it in RESULT and return TRUE.\n-   Note: A singleton can be any gimple invariant, not just constants.\n-   So, [&x, &x] counts as a singleton.  */\n /* Return TRUE if this is a symbolic range.  */\n \n bool\n-value_range::symbolic_p () const\n+irange::symbolic_p () const\n {\n   return (!varying_p ()\n \t  && !undefined_p ()\n-\t  && (!is_gimple_min_invariant (m_min)\n-\t      || !is_gimple_min_invariant (m_max)));\n+\t  && (!is_gimple_min_invariant (min ())\n+\t      || !is_gimple_min_invariant (max ())));\n }\n \n /* NOTE: This is not the inverse of symbolic_p because the range\n@@ -436,36 +526,52 @@ value_range::symbolic_p () const\n    constants would be represented as [-MIN, +MAX].  */\n \n bool\n-value_range::constant_p () const\n+irange::constant_p () const\n {\n   return (!varying_p ()\n \t  && !undefined_p ()\n-\t  && TREE_CODE (m_min) == INTEGER_CST\n-\t  && TREE_CODE (m_max) == INTEGER_CST);\n+\t  && TREE_CODE (min ()) == INTEGER_CST\n+\t  && TREE_CODE (max ()) == INTEGER_CST);\n }\n \n+/* If range is a singleton, place it in RESULT and return TRUE.\n+   Note: A singleton can be any gimple invariant, not just constants.\n+   So, [&x, &x] counts as a singleton.  */\n+\n bool\n-value_range::singleton_p (tree *result) const\n+irange::singleton_p (tree *result) const\n {\n+  if (!legacy_mode_p ())\n+    {\n+      if (num_pairs () == 1 && (wi::to_wide (tree_lower_bound ())\n+\t\t\t\t== wi::to_wide (tree_upper_bound ())))\n+\t{\n+\t  if (result)\n+\t    *result = tree_lower_bound ();\n+\t  return true;\n+\t}\n+      return false;\n+    }\n   if (m_kind == VR_ANTI_RANGE)\n     {\n       if (nonzero_p ())\n \t{\n \t  if (TYPE_PRECISION (type ()) == 1)\n \t    {\n \t      if (result)\n-\t\t*result = m_max;\n+\t\t*result = max ();\n \t      return true;\n \t    }\n \t  return false;\n \t}\n       if (num_pairs () == 1)\n \t{\n \t  value_range vr0, vr1;\n-\t  ranges_from_anti_range (this, &vr0, &vr1);\n+\t  ranges_from_anti_range ((const value_range *) this, &vr0, &vr1);\n \t  return vr0.singleton_p (result);\n \t}\n     }\n+  // Catches non-numeric extremes as well.\n   if (m_kind == VR_RANGE\n       && vrp_operand_equal_p (min (), max ())\n       && is_gimple_min_invariant (min ()))\n@@ -478,30 +584,31 @@ value_range::singleton_p (tree *result) const\n }\n \n /* Return 1 if VAL is inside value range.\n-          0 if VAL is not inside value range.\n+\t  0 if VAL is not inside value range.\n \t -2 if we cannot tell either way.\n \n    Benchmark compile/20001226-1.c compilation time after changing this\n    function.  */\n \n int\n-value_range::value_inside_range (tree val) const\n+irange::value_inside_range (tree val) const\n {\n-  int cmp1, cmp2;\n-\n   if (varying_p ())\n     return 1;\n \n   if (undefined_p ())\n     return 0;\n \n-  cmp1 = operand_less_p (val, m_min);\n+  if (!legacy_mode_p () && TREE_CODE (val) == INTEGER_CST)\n+    return contains_p (val);\n+\n+  int cmp1 = operand_less_p (val, min ());\n   if (cmp1 == -2)\n     return -2;\n   if (cmp1 == 1)\n     return m_kind != VR_RANGE;\n \n-  cmp2 = operand_less_p (m_max, val);\n+  int cmp2 = operand_less_p (max (), val);\n   if (cmp2 == -2)\n     return -2;\n \n@@ -514,30 +621,56 @@ value_range::value_inside_range (tree val) const\n /* Return TRUE if it is possible that range contains VAL.  */\n \n bool\n-value_range::may_contain_p (tree val) const\n+irange::may_contain_p (tree val) const\n {\n   return value_inside_range (val) != 0;\n }\n \n /* Return TRUE if range contains INTEGER_CST.  */\n+/* Return 1 if VAL is inside value range.\n+\t  0 if VAL is not inside value range.\n+\n+   Benchmark compile/20001226-1.c compilation time after changing this\n+   function.  */\n+\n \n bool\n-value_range::contains_p (tree cst) const\n+irange::contains_p (tree cst) const\n {\n+  if (undefined_p ())\n+    return false;\n+\n+  if (legacy_mode_p ())\n+    {\n+      gcc_checking_assert (TREE_CODE (cst) == INTEGER_CST);\n+      if (symbolic_p ())\n+\t{\n+\t  value_range numeric_range (*this);\n+\t  numeric_range.normalize_symbolics ();\n+\t  return numeric_range.contains_p (cst);\n+\t}\n+      return value_inside_range (cst) == 1;\n+    }\n+\n   gcc_checking_assert (TREE_CODE (cst) == INTEGER_CST);\n-  if (symbolic_p ())\n+  signop sign = TYPE_SIGN (TREE_TYPE (cst));\n+  wide_int v = wi::to_wide (cst);\n+  for (unsigned r = 0; r < m_num_ranges; ++r)\n     {\n-      value_range numeric_range (*this);\n-      numeric_range.normalize_symbolics ();\n-      return numeric_range.contains_p (cst);\n+      if (wi::lt_p (v, lower_bound (r), sign))\n+\treturn false;\n+      if (wi::le_p (v, upper_bound (r), sign))\n+\treturn true;\n     }\n-  return value_inside_range (cst) == 1;\n+\n+  return false;\n }\n \n+\n /* Normalize addresses into constants.  */\n \n void\n-value_range::normalize_addresses ()\n+irange::normalize_addresses ()\n {\n   if (undefined_p ())\n     return;\n@@ -547,8 +680,8 @@ value_range::normalize_addresses ()\n \n   if (!range_includes_zero_p (this))\n     {\n-      gcc_checking_assert (TREE_CODE (m_min) == ADDR_EXPR\n-\t\t\t   || TREE_CODE (m_max) == ADDR_EXPR);\n+      gcc_checking_assert (TREE_CODE (min ()) == ADDR_EXPR\n+\t\t\t   || TREE_CODE (max ()) == ADDR_EXPR);\n       set_nonzero (type ());\n       return;\n     }\n@@ -558,7 +691,7 @@ value_range::normalize_addresses ()\n /* Normalize symbolics and addresses into constants.  */\n \n void\n-value_range::normalize_symbolics ()\n+irange::normalize_symbolics ()\n {\n   if (varying_p () || undefined_p ())\n     return;\n@@ -939,45 +1072,64 @@ intersect_ranges (enum value_range_kind *vr0type,\n }\n \n /* Helper for the intersection operation for value ranges.  Given two\n-   value ranges VR0 and VR1, return the intersection of the two\n-   ranges.  This may not be the smallest possible such range.  */\n+   ranges VR0 and VR1, set VR0 to the intersection of both ranges.\n+   This may not be the smallest possible such range.  */\n \n-value_range\n-value_range::intersect_helper (const value_range *vr0, const value_range *vr1)\n+void\n+irange::legacy_intersect (irange *vr0, const irange *vr1)\n {\n   /* If either range is VR_VARYING the other one wins.  */\n   if (vr1->varying_p ())\n-    return *vr0;\n+    return;\n   if (vr0->varying_p ())\n-    return *vr1;\n+    {\n+      /* Avoid the full copy if we already know both sides are simple\n+\t and can be trivially copied.  */\n+      if (vr1->legacy_mode_p ())\n+\t{\n+\t  vr0->set (vr1->min (), vr1->max (), vr1->kind ());\n+\t  return;\n+\t}\n+      *vr0 = *vr1;\n+      return;\n+    }\n \n   /* When either range is VR_UNDEFINED the resulting range is\n      VR_UNDEFINED, too.  */\n   if (vr0->undefined_p ())\n-    return *vr0;\n+    return;\n   if (vr1->undefined_p ())\n-    return *vr1;\n+    {\n+      vr0->set_undefined ();\n+      return;\n+    }\n \n   value_range_kind vr0kind = vr0->kind ();\n   tree vr0min = vr0->min ();\n   tree vr0max = vr0->max ();\n-  intersect_ranges (&vr0kind, &vr0min, &vr0max,\n-\t\t    vr1->kind (), vr1->min (), vr1->max ());\n+  /* Handle multi-ranges that can be represented as anti-ranges.  */\n+  if (!vr1->legacy_mode_p () && vr1->maybe_anti_range ())\n+    {\n+      int_range<3> tmp (*vr1);\n+      tmp.invert ();\n+      intersect_ranges (&vr0kind, &vr0min, &vr0max,\n+\t\t\tVR_ANTI_RANGE, tmp.min (), tmp.max ());\n+    }\n+  else\n+    intersect_ranges (&vr0kind, &vr0min, &vr0max,\n+\t\t      vr1->kind (), vr1->min (), vr1->max ());\n+\n   /* Make sure to canonicalize the result though as the inversion of a\n-     VR_RANGE can still be a VR_RANGE.  Work on a temporary so we can\n-     fall back to vr0 when this turns things to varying.  */\n-  value_range tem;\n+     VR_RANGE can still be a VR_RANGE.  */\n   if (vr0kind == VR_UNDEFINED)\n-    tem.set_undefined ();\n+    vr0->set_undefined ();\n   else if (vr0kind == VR_VARYING)\n-    tem.set_varying (vr0->type ());\n+    {\n+      /* If we failed, use the original VR0.  */\n+      return;\n+    }\n   else\n-    tem.set (vr0min, vr0max, vr0kind);\n-  /* If that failed, use the saved original VR0.  */\n-  if (tem.varying_p ())\n-    return *vr0;\n-\n-  return tem;\n+    vr0->set (vr0min, vr0max, vr0kind);\n }\n \n /* Union the two value-ranges { *VR0TYPE, *VR0MIN, *VR0MAX } and\n@@ -1253,212 +1405,563 @@ union_ranges (enum value_range_kind *vr0type,\n   *vr0max = NULL_TREE;\n }\n \n-/* Helper for meet operation for value ranges.  Given two value ranges VR0 and\n-   VR1, return a range that contains both VR0 and VR1.  This may not be the\n+/* Helper for meet operation for value ranges.  Given two ranges VR0\n+   and VR1, set VR0 to the union of both ranges.  This may not be the\n    smallest possible such range.  */\n \n-value_range\n-value_range::union_helper (const value_range *vr0, const value_range *vr1)\n+void\n+irange::legacy_union (irange *vr0, const irange *vr1)\n {\n   /* VR0 has the resulting range if VR1 is undefined or VR0 is varying.  */\n   if (vr1->undefined_p ()\n       || vr0->varying_p ())\n-    return *vr0;\n+    return;\n \n   /* VR1 has the resulting range if VR0 is undefined or VR1 is varying.  */\n-  if (vr0->undefined_p ()\n-      || vr1->varying_p ())\n-    return *vr1;\n+  if (vr0->undefined_p ())\n+    {\n+      /* Avoid the full copy if we already know both sides are simple\n+\t and can be trivially copied.  */\n+      if (vr1->legacy_mode_p ())\n+\t{\n+\t  vr0->set (vr1->min (), vr1->max (), vr1->kind ());\n+\t  return;\n+\t}\n+      *vr0 = *vr1;\n+      return;\n+    }\n+  if (vr1->varying_p ())\n+    {\n+      vr0->set_varying (vr1->type ());\n+      return;\n+    }\n \n   value_range_kind vr0kind = vr0->kind ();\n   tree vr0min = vr0->min ();\n   tree vr0max = vr0->max ();\n-  union_ranges (&vr0kind, &vr0min, &vr0max,\n-\t\tvr1->kind (), vr1->min (), vr1->max ());\n+  /* Handle multi-ranges that can be represented as anti-ranges.  */\n+  if (!vr1->legacy_mode_p () && vr1->maybe_anti_range ())\n+    {\n+      int_range<3> tmp (*vr1);\n+      tmp.invert ();\n+      union_ranges (&vr0kind, &vr0min, &vr0max,\n+\t\t    VR_ANTI_RANGE, tmp.min (), tmp.max ());\n+    }\n+  else\n+    union_ranges (&vr0kind, &vr0min, &vr0max,\n+\t\t  vr1->kind (), vr1->min (), vr1->max ());\n \n-  /* Work on a temporary so we can still use vr0 when union returns varying.  */\n-  value_range tem;\n   if (vr0kind == VR_UNDEFINED)\n-    tem.set_undefined ();\n+    vr0->set_undefined ();\n   else if (vr0kind == VR_VARYING)\n-    tem.set_varying (vr0->type ());\n-  else\n-    tem.set (vr0min, vr0max, vr0kind);\n-\n-  /* Failed to find an efficient meet.  Before giving up and setting\n-     the result to VARYING, see if we can at least derive a useful\n-     anti-range.  */\n-  if (tem.varying_p ()\n-      && range_includes_zero_p (vr0) == 0\n-      && range_includes_zero_p (vr1) == 0)\n     {\n-      tem.set_nonzero (vr0->type ());\n-      return tem;\n+      /* Failed to find an efficient meet.  Before giving up and\n+\t setting the result to VARYING, see if we can at least derive\n+\t a non-zero range.  */\n+      if (range_includes_zero_p (vr0) == 0\n+\t  && range_includes_zero_p (vr1) == 0)\n+\tvr0->set_nonzero (vr0->type ());\n+      else\n+\tvr0->set_varying (vr0->type ());\n     }\n-\n-  return tem;\n+  else\n+    vr0->set (vr0min, vr0max, vr0kind);\n }\n \n /* Meet operation for value ranges.  Given two value ranges VR0 and\n    VR1, store in VR0 a range that contains both VR0 and VR1.  This\n    may not be the smallest possible such range.  */\n \n void\n-value_range::union_ (const value_range *other)\n+irange::union_ (const irange *other)\n {\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n+  if (legacy_mode_p ())\n     {\n-      fprintf (dump_file, \"Meeting\\n  \");\n-      dump_value_range (dump_file, this);\n-      fprintf (dump_file, \"\\nand\\n  \");\n-      dump_value_range (dump_file, other);\n-      fprintf (dump_file, \"\\n\");\n-    }\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Meeting\\n  \");\n+\t  dump_value_range (dump_file, this);\n+\t  fprintf (dump_file, \"\\nand\\n  \");\n+\t  dump_value_range (dump_file, other);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n \n-  *this = union_helper (this, other);\n+      legacy_union (this, other);\n \n-  if (dump_file && (dump_flags & TDF_DETAILS))\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"to\\n  \");\n+\t  dump_value_range (dump_file, this);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+      return;\n+    }\n+\n+  if (other->legacy_mode_p ())\n     {\n-      fprintf (dump_file, \"to\\n  \");\n-      dump_value_range (dump_file, this);\n-      fprintf (dump_file, \"\\n\");\n+      int_range<2> wider;\n+      wider = *other;\n+      irange_union (wider);\n     }\n+  else\n+    irange_union (*other);\n }\n \n-/* Range union, but for references.  */\n-\n void\n-value_range::union_ (const value_range &r)\n+irange::intersect (const irange *other)\n {\n-  /* Disable details for now, because it makes the ranger dump\n-     unnecessarily verbose.  */\n-  bool details = dump_flags & TDF_DETAILS;\n-  if (details)\n-    dump_flags &= ~TDF_DETAILS;\n-  union_ (&r);\n-  if (details)\n-    dump_flags |= TDF_DETAILS;\n+  if (legacy_mode_p ())\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Intersecting\\n  \");\n+\t  dump_value_range (dump_file, this);\n+\t  fprintf (dump_file, \"\\nand\\n  \");\n+\t  dump_value_range (dump_file, other);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+\n+      legacy_intersect (this, other);\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"to\\n  \");\n+\t  dump_value_range (dump_file, this);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+      return;\n+    }\n+\n+  if (other->legacy_mode_p ())\n+    {\n+      int_range<2> wider;\n+      wider = *other;\n+      irange_intersect (wider);\n+    }\n+  else\n+    irange_intersect (*other);\n }\n \n+// union_ for multi-ranges.\n+\n void\n-value_range::intersect (const value_range *other)\n+irange::irange_union (const irange &r)\n {\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n+  gcc_checking_assert (!legacy_mode_p () && !r.legacy_mode_p ());\n+\n+  if (r.undefined_p () || varying_p ())\n+    return;\n+\n+  if (undefined_p () || r.varying_p ())\n     {\n-      fprintf (dump_file, \"Intersecting\\n  \");\n-      dump_value_range (dump_file, this);\n-      fprintf (dump_file, \"\\nand\\n  \");\n-      dump_value_range (dump_file, other);\n-      fprintf (dump_file, \"\\n\");\n+      operator= (r);\n+      return;\n     }\n \n-  *this = intersect_helper (this, other);\n+  // Do not worry about merging and such by reserving twice as many\n+  // pairs as needed, and then simply sort the 2 ranges into this\n+  // intermediate form.\n+  //\n+  // The intermediate result will have the property that the beginning\n+  // of each range is <= the beginning of the next range.  There may\n+  // be overlapping ranges at this point.  I.e. this would be valid\n+  // [-20, 10], [-10, 0], [0, 20], [40, 90] as it satisfies this\n+  // contraint : -20 < -10 < 0 < 40.  When the range is rebuilt into r,\n+  // the merge is performed.\n+  //\n+  // [Xi,Yi]..[Xn,Yn]  U  [Xj,Yj]..[Xm,Ym]   -->  [Xk,Yk]..[Xp,Yp]\n+  tree ttype = r.type ();\n+  signop sign = TYPE_SIGN (ttype);\n+\n+  auto_vec<tree, 20> res;\n+  wide_int u1 ;\n+  wi::overflow_type ovf;\n+  unsigned i = 0, j = 0, k = 0;\n+\n+  while (i < m_num_ranges * 2 && j < r.m_num_ranges * 2)\n+    {\n+      // lower of Xi and Xj is the lowest point.\n+      if (wi::le_p (wi::to_wide (m_base[i]), wi::to_wide (r.m_base[j]), sign))\n+\t{\n+\t  res.safe_push (m_base[i]);\n+\t  res.safe_push (m_base[i + 1]);\n+\t  k += 2;\n+\t  i += 2;\n+\t}\n+      else\n+\t{\n+\t  res.safe_push (r.m_base[j]);\n+\t  res.safe_push (r.m_base[j + 1]);\n+\t  k += 2;\n+\t  j += 2;\n+\t}\n+    }\n+  for ( ; i < m_num_ranges * 2; i += 2)\n+    {\n+      res.safe_push (m_base[i]);\n+      res.safe_push (m_base[i + 1]);\n+      k += 2;\n+    }\n+  for ( ; j < r.m_num_ranges * 2; j += 2)\n+    {\n+      res.safe_push (r.m_base[j]);\n+      res.safe_push (r.m_base[j + 1]);\n+      k += 2;\n+    }\n \n-  if (dump_file && (dump_flags & TDF_DETAILS))\n+  // Now normalize the vector removing any overlaps.\n+  i = 2;\n+  int prec = TYPE_PRECISION (ttype);\n+  wide_int max_val = wi::max_value (prec, sign);\n+  for (j = 2; j < k ; j += 2)\n     {\n-      fprintf (dump_file, \"to\\n  \");\n-      dump_value_range (dump_file, this);\n-      fprintf (dump_file, \"\\n\");\n+      wide_int val_im1 = wi::to_wide (res[i - 1]);\n+      if (val_im1 == max_val)\n+\tbreak;\n+      u1 = wi::add (val_im1, 1, sign, &ovf);\n+\n+      // Overflow indicates we are at MAX already.\n+      // A wide int bug requires the previous max_val check\n+      // trigger: gcc.c-torture/compile/pr80443.c  with -O3\n+      if (ovf == wi::OVF_OVERFLOW)\n+\tbreak;\n+\n+      wide_int val_j = wi::to_wide (res[j]);\n+      wide_int val_jp1 = wi::to_wide (res[j+1]);\n+      // Current upper+1 is >= lower bound next pair, then we merge ranges.\n+      if (wi::ge_p (u1, val_j, sign))\n+\t{\n+\t  // New upper bounds is greater of current or the next one.\n+\t  if (wi::gt_p (val_jp1, val_im1, sign))\n+\t    res [i - 1] = res[j + 1];\n+\t}\n+      else\n+\t{\n+\t  // This is a new distinct range, but no point in copying it\n+\t  // if it is already in the right place.\n+\t  if (i != j)\n+\t    {\n+\t      res[i++] = res[j];\n+\t      res[i++] = res[j + 1];\n+\t    }\n+\t  else\n+\t    i += 2;\n+\t}\n     }\n+\n+  // At this point, the vector should have i ranges, none overlapping.\n+  // Now it simply needs to be copied, and if there are too many\n+  // ranges, merge some.  We wont do any analysis as to what the\n+  // \"best\" merges are, simply combine the final ranges into one.\n+  if (i > m_max_ranges * 2)\n+    {\n+      res[m_max_ranges * 2 - 1] = res[i - 1];\n+      i = m_max_ranges * 2;\n+    }\n+\n+  for (j = 0; j < i ; j++)\n+    m_base[j] = res [j];\n+  m_num_ranges = i / 2;\n+\n+  if (flag_checking)\n+    verify_range ();\n }\n \n-/* Range intersect, but for references.  */\n+// intersect for multi-ranges.\n \n void\n-value_range::intersect (const value_range &r)\n+irange::irange_intersect (const irange &r)\n+{\n+  gcc_checking_assert (!legacy_mode_p () && !r.legacy_mode_p ());\n+\n+  if (undefined_p () || r.varying_p ())\n+    return;\n+  if (r.undefined_p ())\n+    {\n+      set_undefined ();\n+      return;\n+    }\n+  if (varying_p ())\n+    {\n+      operator= (r);\n+      return;\n+    }\n+\n+  signop sign = TYPE_SIGN (TREE_TYPE(m_base[0]));\n+  unsigned bld_pair = 0;\n+  unsigned bld_lim = m_max_ranges;\n+  widest_irange r2 (*this);\n+  unsigned r2_lim = r2.num_pairs ();\n+  unsigned i2 = 0;\n+  for (unsigned i = 0; i < r.num_pairs (); )\n+    {\n+      // If r1's upper is < r2's lower, we can skip r1's pair.\n+      tree ru = r.m_base[i * 2 + 1];\n+      tree r2l = r2.m_base[i2 * 2];\n+      if (wi::lt_p (wi::to_wide (ru), wi::to_wide (r2l), sign))\n+\t{\n+\t  i++;\n+\t  continue;\n+\t}\n+      // Likewise, skip r2's pair if its excluded.\n+      tree r2u = r2.m_base[i2 * 2 + 1];\n+      tree rl = r.m_base[i * 2];\n+      if (wi::lt_p (wi::to_wide (r2u), wi::to_wide (rl), sign))\n+\t{\n+\t  i2++;\n+\t  if (i2 < r2_lim)\n+\t    continue;\n+\t  // No more r2, break.\n+\t  break;\n+\t}\n+\n+      // Must be some overlap.  Find the highest of the lower bounds,\n+      // and set it, unless the build limits lower bounds is already\n+      // set.\n+      if (bld_pair < bld_lim)\n+\t{\n+\t  if (wi::ge_p (wi::to_wide (rl), wi::to_wide (r2l), sign))\n+\t    m_base[bld_pair * 2] = rl;\n+\t  else\n+\t    m_base[bld_pair * 2] = r2l;\n+\t}\n+      else\n+\t// Decrease and set a new upper.\n+\tbld_pair--;\n+\n+      // ...and choose the lower of the upper bounds.\n+      if (wi::le_p (wi::to_wide (ru), wi::to_wide (r2u), sign))\n+\t{\n+\t  m_base[bld_pair * 2 + 1] = ru;\n+\t  bld_pair++;\n+\t  // Move past the r1 pair and keep trying.\n+\t  i++;\n+\t  continue;\n+\t}\n+      else\n+\t{\n+\t  m_base[bld_pair * 2 + 1] = r2u;\n+\t  bld_pair++;\n+\t  i2++;\n+\t  if (i2 < r2_lim)\n+\t    continue;\n+\t  // No more r2, break.\n+\t  break;\n+\t}\n+      // r2 has the higher lower bound.\n+    }\n+\n+  // At the exit of this loop, it is one of 2 things:\n+  // ran out of r1, or r2, but either means we are done.\n+  m_num_ranges = bld_pair;\n+  if (flag_checking)\n+    verify_range ();\n+}\n+\n+static wide_int inline\n+subtract_one (const wide_int &x, tree type, wi::overflow_type &overflow)\n {\n-  /* Disable details for now, because it makes the ranger dump\n-     unnecessarily verbose.  */\n-  bool details = dump_flags & TDF_DETAILS;\n-  if (details)\n-    dump_flags &= ~TDF_DETAILS;\n-  intersect (&r);\n-  if (details)\n-    dump_flags |= TDF_DETAILS;\n+  // A signed 1-bit bit-field, has a range of [-1,0] so subtracting +1\n+  // overflows, since +1 is unrepresentable.  This is why we have an\n+  // addition of -1 here.\n+  if (TYPE_SIGN (type) == SIGNED)\n+    return wi::add (x, -1 , SIGNED, &overflow);\n+  else\n+    return wi::sub (x, 1, UNSIGNED, &overflow);\n }\n \n /* Return the inverse of a range.  */\n \n void\n-value_range::invert ()\n+irange::invert ()\n {\n-  /* We can't just invert VR_RANGE and VR_ANTI_RANGE because we may\n-     create non-canonical ranges.  Use the constructors instead.  */\n-  if (m_kind == VR_RANGE)\n-    *this = value_range (m_min, m_max, VR_ANTI_RANGE);\n-  else if (m_kind == VR_ANTI_RANGE)\n-    *this = value_range (m_min, m_max);\n+  if (legacy_mode_p ())\n+    {\n+      // We can't just invert VR_RANGE and VR_ANTI_RANGE because we may\n+      // create non-canonical ranges.  Use the constructors instead.\n+      if (m_kind == VR_RANGE)\n+\t*this = value_range (min (), max (), VR_ANTI_RANGE);\n+      else if (m_kind == VR_ANTI_RANGE)\n+\t*this = value_range (min (), max ());\n+      else\n+\tgcc_unreachable ();\n+      return;\n+    }\n+\n+  gcc_assert (!undefined_p () && !varying_p ());\n+\n+  // We always need one more set of bounds to represent an inverse, so\n+  // if we're at the limit, we can't properly represent things.\n+  //\n+  // For instance, to represent the inverse of a 2 sub-range set\n+  // [5, 10][20, 30], we would need a 3 sub-range set\n+  // [-MIN, 4][11, 19][31, MAX].\n+  //\n+  // In this case, return the most conservative thing.\n+  //\n+  // However, if any of the extremes of the range are -MIN/+MAX, we\n+  // know we will not need an extra bound.  For example:\n+  //\n+  // \tINVERT([-MIN,20][30,40]) => [21,29][41,+MAX]\n+  // \tINVERT([-MIN,20][30,MAX]) => [21,29]\n+  tree ttype = type ();\n+  unsigned prec = TYPE_PRECISION (ttype);\n+  signop sign = TYPE_SIGN (ttype);\n+  wide_int type_min = wi::min_value (prec, sign);\n+  wide_int type_max = wi::max_value (prec, sign);\n+  if (m_num_ranges == m_max_ranges\n+      && lower_bound () != type_min\n+      && upper_bound () != type_max)\n+    {\n+      m_base[1] = wide_int_to_tree (ttype, type_max);\n+      m_num_ranges = 1;\n+      return;\n+    }\n+  // The algorithm is as follows.  To calculate INVERT ([a,b][c,d]), we\n+  // generate [-MIN, a-1][b+1, c-1][d+1, MAX].\n+  //\n+  // If there is an over/underflow in the calculation for any\n+  // sub-range, we eliminate that subrange.  This allows us to easily\n+  // calculate INVERT([-MIN, 5]) with: [-MIN, -MIN-1][6, MAX].  And since\n+  // we eliminate the underflow, only [6, MAX] remains.\n+  unsigned i = 0;\n+  wi::overflow_type ovf;\n+  // Construct leftmost range.\n+  widest_irange orig_range (*this);\n+  unsigned nitems = 0;\n+  wide_int tmp;\n+  // If this is going to underflow on the MINUS 1, don't even bother\n+  // checking.  This also handles subtracting one from an unsigned 0,\n+  // which doesn't set the underflow bit.\n+  if (type_min != orig_range.lower_bound ())\n+    {\n+      m_base[nitems++] = wide_int_to_tree (ttype, type_min);\n+      tmp = subtract_one (orig_range.lower_bound (), ttype, ovf);\n+      m_base[nitems++] = wide_int_to_tree (ttype, tmp);\n+      if (ovf)\n+\tnitems = 0;\n+    }\n+  i++;\n+  // Construct middle ranges if applicable.\n+  if (orig_range.num_pairs () > 1)\n+    {\n+      unsigned j = i;\n+      for (; j < (orig_range.num_pairs () * 2) - 1; j += 2)\n+\t{\n+\t  // The middle ranges cannot have MAX/MIN, so there's no need\n+\t  // to check for unsigned overflow on the +1 and -1 here.\n+\t  tmp = wi::add (wi::to_wide (orig_range.m_base[j]), 1, sign, &ovf);\n+\t  m_base[nitems++] = wide_int_to_tree (ttype, tmp);\n+\t  tmp = subtract_one (wi::to_wide (orig_range.m_base[j + 1]),\n+\t\t\t      ttype, ovf);\n+\t  m_base[nitems++] = wide_int_to_tree (ttype, tmp);\n+\t  if (ovf)\n+\t    nitems -= 2;\n+\t}\n+      i = j;\n+    }\n+  // Construct rightmost range.\n+  //\n+  // However, if this will overflow on the PLUS 1, don't even bother.\n+  // This also handles adding one to an unsigned MAX, which doesn't\n+  // set the overflow bit.\n+  if (type_max != wi::to_wide (orig_range.m_base[i]))\n+    {\n+      tmp = wi::add (wi::to_wide (orig_range.m_base[i]), 1, sign, &ovf);\n+      m_base[nitems++] = wide_int_to_tree (ttype, tmp);\n+      m_base[nitems++] = wide_int_to_tree (ttype, type_max);\n+      if (ovf)\n+\tnitems -= 2;\n+    }\n+  m_num_ranges = nitems / 2;\n+\n+  if (flag_checking)\n+    verify_range ();\n+}\n+\n+static void\n+dump_bound_with_infinite_markers (FILE *file, tree bound)\n+{\n+  tree type = TREE_TYPE (bound);\n+  if (INTEGRAL_TYPE_P (type)\n+      && !TYPE_UNSIGNED (type)\n+      && vrp_val_is_min (bound)\n+      && TYPE_PRECISION (type) != 1)\n+    fprintf (file, \"-INF\");\n+  else if (vrp_val_is_max (bound)\n+\t   && TYPE_PRECISION (type) != 1)\n+    fprintf (file, \"+INF\");\n   else\n-    gcc_unreachable ();\n+    print_generic_expr (file, bound);\n }\n \n void\n-value_range::dump (FILE *file) const\n+irange::dump (FILE *file) const\n {\n   if (undefined_p ())\n-    fprintf (file, \"UNDEFINED\");\n-  else if (m_kind == VR_RANGE || m_kind == VR_ANTI_RANGE)\n     {\n-      tree ttype = type ();\n-\n-      print_generic_expr (file, ttype);\n-      fprintf (file, \" \");\n-\n+      fprintf (file, \"UNDEFINED\");\n+      return;\n+    }\n+  print_generic_expr (file, type ());\n+  fprintf (file, \" \");\n+  if (varying_p ())\n+    {\n+      fprintf (file, \"VARYING\");\n+      return;\n+    }\n+ if (legacy_mode_p ())\n+    {\n       fprintf (file, \"%s[\", (m_kind == VR_ANTI_RANGE) ? \"~\" : \"\");\n-\n-      if (INTEGRAL_TYPE_P (ttype)\n-\t  && !TYPE_UNSIGNED (ttype)\n-\t  && vrp_val_is_min (min ())\n-\t  && TYPE_PRECISION (ttype) != 1)\n-\tfprintf (file, \"-INF\");\n-      else\n-\tprint_generic_expr (file, min ());\n-\n+      dump_bound_with_infinite_markers (file, min ());\n       fprintf (file, \", \");\n-\n-      if (supports_type_p (ttype)\n-\t  && vrp_val_is_max (max ())\n-\t  && TYPE_PRECISION (ttype) != 1)\n-\tfprintf (file, \"+INF\");\n-      else\n-\tprint_generic_expr (file, max ());\n-\n+      dump_bound_with_infinite_markers (file, max ());\n       fprintf (file, \"]\");\n+      return;\n     }\n-  else if (varying_p ())\n+  for (unsigned i = 0; i < m_num_ranges; ++i)\n     {\n-      print_generic_expr (file, type ());\n-      fprintf (file, \" VARYING\");\n+      tree lb = m_base[i * 2];\n+      tree ub = m_base[i * 2 + 1];\n+      fprintf (file, \"[\");\n+      dump_bound_with_infinite_markers (file, lb);\n+      fprintf (file, \", \");\n+      dump_bound_with_infinite_markers (file, ub);\n+      fprintf (file, \"]\");\n     }\n-  else\n-    gcc_unreachable ();\n }\n \n void\n-value_range::dump () const\n+dump_value_range (FILE *file, const irange *vr)\n {\n-  dump (stderr);\n+  vr->dump (file);\n }\n \n-void\n-dump_value_range (FILE *file, const value_range *vr)\n+DEBUG_FUNCTION void\n+debug (const irange *vr)\n {\n-  if (!vr)\n-    fprintf (file, \"[]\");\n-  else\n-    vr->dump (file);\n+  dump_value_range (stderr, vr);\n+  fprintf (stderr, \"\\n\");\n+}\n+\n+DEBUG_FUNCTION void\n+debug (const irange &vr)\n+{\n+  debug (&vr);\n }\n \n DEBUG_FUNCTION void\n debug (const value_range *vr)\n {\n   dump_value_range (stderr, vr);\n+  fprintf (stderr, \"\\n\");\n }\n \n DEBUG_FUNCTION void\n debug (const value_range &vr)\n {\n   dump_value_range (stderr, &vr);\n+  fprintf (stderr, \"\\n\");\n }\n \n /* Create two value-ranges in *VR0 and *VR1 from the anti-range *AR\n@@ -1501,40 +2004,13 @@ ranges_from_anti_range (const value_range *ar,\n }\n \n bool\n-range_has_numeric_bounds_p (const value_range *vr)\n+range_has_numeric_bounds_p (const irange *vr)\n {\n-  return (vr->min ()\n+  return (!vr->undefined_p ()\n \t  && TREE_CODE (vr->min ()) == INTEGER_CST\n \t  && TREE_CODE (vr->max ()) == INTEGER_CST);\n }\n \n-/* Return the maximum value for TYPE.  */\n-\n-tree\n-vrp_val_max (const_tree type)\n-{\n-  if (INTEGRAL_TYPE_P (type))\n-    return TYPE_MAX_VALUE (type);\n-  if (POINTER_TYPE_P (type))\n-    {\n-      wide_int max = wi::max_value (TYPE_PRECISION (type), TYPE_SIGN (type));\n-      return wide_int_to_tree (const_cast<tree> (type), max);\n-    }\n-  return NULL_TREE;\n-}\n-\n-/* Return the minimum value for TYPE.  */\n-\n-tree\n-vrp_val_min (const_tree type)\n-{\n-  if (INTEGRAL_TYPE_P (type))\n-    return TYPE_MIN_VALUE (type);\n-  if (POINTER_TYPE_P (type))\n-    return build_zero_cst (const_cast<tree> (type));\n-  return NULL_TREE;\n-}\n-\n /* Return whether VAL is equal to the maximum value of its type.\n    We can't do a simple equality comparison with TYPE_MAX_VALUE because\n    C typedefs and Ada subtypes can produce types whose TYPE_MAX_VALUE\n@@ -1571,3 +2047,41 @@ vrp_operand_equal_p (const_tree val1, const_tree val2)\n     return false;\n   return true;\n }\n+\n+#define DEFINE_INT_RANGE_GC_STUBS(N)\t\t\\\n+  void\t\t\t\t\t\t\\\n+  gt_pch_nx (int_range<N> *&x)\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    for (unsigned i = 0; i < N; ++i)\t\t\\\n+      {\t\t\t\t\t\t\\\n+\tgt_pch_nx (x->m_ranges[i * 2]);\t\t\\\n+\tgt_pch_nx (x->m_ranges[i * 2 + 1]);\t\\\n+      }\t\t  \t\t       \t\t\\\n+  }\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+  void\t\t\t\t\t\t\\\n+  gt_ggc_mx (int_range<N> *&x)\t\t\t\\\n+  {\t    \t       \t\t\t\t\\\n+    for (unsigned i = 0; i < N; ++i)\t\t\\\n+      {\t\t\t\t\t\t\\\n+\t  gt_ggc_mx (x->m_ranges[i * 2]);\t\\\n+\t  gt_ggc_mx (x->m_ranges[i * 2 + 1]);\t\\\n+      }\t\t\t\t\t\t\\\n+  }\n+\n+#define DEFINE_INT_RANGE_INSTANCE(N)\t\t\t\t\t\\\n+  template int_range<N>::int_range(tree, tree, value_range_kind);\t\\\n+  template int_range<N>::int_range(tree_node *,\t\t\t\t\\\n+\t\t\t\t   const wide_int &,\t\t\t\\\n+\t\t\t\t   const wide_int &,\t\t\t\\\n+\t\t\t\t   value_range_kind);\t\t\t\\\n+  template int_range<N>::int_range(tree);\t\t\t\t\\\n+  template int_range<N>::int_range(const irange &);\t\t\\\n+  template int_range<N>::int_range(const int_range &);\t\t\t\\\n+  template int_range<N>& int_range<N>::operator= (const int_range &);\n+\n+DEFINE_INT_RANGE_INSTANCE(1)\n+DEFINE_INT_RANGE_INSTANCE(2)\n+DEFINE_INT_RANGE_INSTANCE(3)\n+DEFINE_INT_RANGE_INSTANCE(255)\n+DEFINE_INT_RANGE_GC_STUBS(1)"}, {"sha": "e3282c4ad03a22db557feabf818e5502fb4b39dd", "filename": "gcc/value-range.h", "status": "modified", "additions": 502, "deletions": 95, "changes": 597, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf/gcc%2Fvalue-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf/gcc%2Fvalue-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.h?ref=4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf", "patch": "@@ -1,5 +1,7 @@\n /* Support routines for value ranges.\n    Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by Aldy Hernandez <aldyh@redhat.com> and\n+   Andrew Macleod <amacleod@redhat.com>.\n \n This file is part of GCC.\n \n@@ -20,7 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_VALUE_RANGE_H\n #define GCC_VALUE_RANGE_H\n \n-/* Types of value ranges.  */\n+// Types of value ranges.\n enum value_range_kind\n {\n   /* Empty range.  */\n@@ -36,172 +38,300 @@ enum value_range_kind\n };\n \n // Range of values that can be associated with an SSA_NAME.\n+//\n+// This is the base class without any storage.\n \n-class GTY((for_user)) value_range\n+class irange\n {\n public:\n-  value_range ();\n-  value_range (tree, tree, value_range_kind = VR_RANGE);\n-  value_range (tree type, const wide_int &, const wide_int &,\n-\t       value_range_kind = VR_RANGE);\n-  value_range (tree type);\n-\n+  // In-place setters.\n   void set (tree, tree, value_range_kind = VR_RANGE);\n-  void set (tree);\n   void set_nonzero (tree);\n   void set_zero (tree);\n-\n-  enum value_range_kind kind () const;\n-  tree min () const;\n-  tree max () const;\n-\n-  /* Types of value ranges.  */\n-  bool symbolic_p () const;\n-  bool constant_p () const;\n-  bool undefined_p () const;\n-  bool varying_p () const;\n   void set_varying (tree type);\n   void set_undefined ();\n \n-  void union_ (const value_range *);\n-  void intersect (const value_range *);\n-  void union_ (const value_range &);\n-  void intersect (const value_range &);\n-\n-  bool operator== (const value_range &) const;\n-  bool operator!= (const value_range &) const /* = delete */;\n-  bool equal_p (const value_range &) const;\n-\n-  /* Misc methods.  */\n-  tree type () const;\n-  bool may_contain_p (tree) const;\n-  bool zero_p () const;\n-  bool nonzero_p () const;\n-  bool singleton_p (tree *result = NULL) const;\n-  void dump (FILE *) const;\n-  void dump () const;\n-\n+  // Range types.\n   static bool supports_type_p (tree);\n-  void normalize_symbolics ();\n-  void normalize_addresses ();\n+  tree type () const;\n \n-  static const unsigned int m_max_pairs = 2;\n-  bool contains_p (tree) const;\n+  // Iteration over sub-ranges.\n   unsigned num_pairs () const;\n   wide_int lower_bound (unsigned = 0) const;\n   wide_int upper_bound (unsigned) const;\n   wide_int upper_bound () const;\n+\n+  // Predicates.\n+  bool zero_p () const;\n+  bool nonzero_p () const;\n+  bool undefined_p () const;\n+  bool varying_p () const;\n+  bool singleton_p (tree *result = NULL) const;\n+  bool contains_p (tree) const;\n+\n+  // In-place operators.\n+  void union_ (const irange &);\n+  void intersect (const irange &);\n   void invert ();\n \n+  // Operator overloads.\n+  irange& operator= (const irange &);\n+  bool operator== (const irange &) const;\n+  bool operator!= (const irange &r) const { return !(*this == r); }\n+\n+  // Misc methods.\n+  void dump (FILE * = stderr) const;\n+\n+  // Deprecated legacy public methods.\n+  enum value_range_kind kind () const;\t\t// DEPRECATED\n+  tree min () const;\t\t\t\t// DEPRECATED\n+  tree max () const;\t\t\t\t// DEPRECATED\n+  bool symbolic_p () const;\t\t\t// DEPRECATED\n+  bool constant_p () const;\t\t\t// DEPRECATED\n+  void normalize_symbolics ();\t\t\t// DEPRECATED\n+  void normalize_addresses ();\t\t\t// DEPRECATED\n+  bool may_contain_p (tree) const;\t\t// DEPRECATED\n+  void set (tree);\t\t\t\t// DEPRECATED\n+  bool equal_p (const irange &) const;\t\t// DEPRECATED\n+  void union_ (const class irange *);\t\t// DEPRECATED\n+  void intersect (const irange *);\t\t// DEPRECATED\n+\n protected:\n-  void check ();\n-  static value_range union_helper (const value_range *, const value_range *);\n-  static value_range intersect_helper (const value_range *,\n-\t\t\t\t       const value_range *);\n-\n-  friend void gt_ggc_mx_value_range (void *);\n-  friend void gt_pch_p_11value_range (void *, void *,\n-\t\t\t\t      gt_pointer_operator, void *);\n-  friend void gt_pch_nx_value_range (void *);\n-  friend void gt_ggc_mx (value_range &);\n-  friend void gt_ggc_mx (value_range *&);\n-  friend void gt_pch_nx (value_range &);\n-  friend void gt_pch_nx (value_range *, gt_pointer_operator, void *);\n-\n-  enum value_range_kind m_kind;\n-  tree m_min;\n-  tree m_max;\n+  irange (tree *, unsigned);\n+  // potential promotion to public?\n+  tree tree_lower_bound (unsigned = 0) const;\n+  tree tree_upper_bound (unsigned) const;\n+  tree tree_upper_bound () const;\n+\n+   // In-place operators.\n+  void irange_union (const irange &);\n+  void irange_intersect (const irange &);\n+  void irange_set (tree, tree);\n+  void irange_set_anti_range (tree, tree);\n+\n+  bool swap_out_of_order_endpoints (tree &min, tree &max, value_range_kind &);\n+  bool normalize_min_max (tree type, tree min, tree max, value_range_kind);\n+\n+  bool legacy_mode_p () const;\n+  bool legacy_equal_p (const irange &) const;\n+  void legacy_union (irange *, const irange *);\n+  void legacy_intersect (irange *, const irange *);\n+  void verify_range ();\n+  unsigned legacy_num_pairs () const;\n+  wide_int legacy_lower_bound (unsigned = 0) const;\n+  wide_int legacy_upper_bound (unsigned) const;\n+  int value_inside_range (tree) const;\n+  bool maybe_anti_range () const;\n+  void copy_legacy_range (const irange &);\n \n private:\n-  int value_inside_range (tree) const;\n+  unsigned char m_num_ranges;\n+  unsigned char m_max_ranges;\n+  ENUM_BITFIELD(value_range_kind) m_kind : 8;\n+  tree *m_base;\n };\n \n-extern bool range_has_numeric_bounds_p (const value_range *);\n+// Here we describe an irange with N pairs of ranges.  The storage for\n+// the pairs is embedded in the class as an array.\n+\n+template<unsigned N>\n+class GTY((user)) int_range : public irange\n+{\n+public:\n+  int_range ();\n+  int_range (tree, tree, value_range_kind = VR_RANGE);\n+  int_range (tree type, const wide_int &, const wide_int &,\n+\t     value_range_kind = VR_RANGE);\n+  int_range (tree type);\n+  int_range (const int_range &);\n+  int_range (const irange &);\n+  int_range& operator= (const int_range &);\n+private:\n+  template <unsigned X> friend void gt_ggc_mx (int_range<X> *);\n+  template <unsigned X> friend void gt_pch_nx (int_range<X> *);\n+  template <unsigned X> friend void gt_pch_nx (int_range<X> *,\n+\t\t\t\t\t       gt_pointer_operator, void *);\n+  // ?? hash-traits.h has its own extern for these, which is causing\n+  // them to never be picked up by the templates.  For now, define\n+  // elsewhere.\n+  //template<unsigned X> friend void gt_ggc_mx (int_range<X> *&);\n+  //template<unsigned X> friend void gt_pch_nx (int_range<X> *&);\n+  friend void gt_ggc_mx (int_range<1> *&);\n+  friend void gt_pch_nx (int_range<1> *&);\n+\n+  tree m_ranges[N*2];\n+};\n+\n+// This is a special int_range<1> with only one pair, plus\n+// VR_ANTI_RANGE magic to describe slightly more than can be described\n+// in one pair.  It is described in the code as a \"legacy range\" (as\n+// opposed to multi-ranges which have multiple sub-ranges).  It is\n+// provided for backward compatibility with code that has not been\n+// converted to multi-range irange's.\n+//\n+// There are copy operators to seamlessly copy to/fro multi-ranges.\n+typedef int_range<1> value_range;\n+\n+// This is an \"infinite\" precision irange for use in temporary\n+// calculations.\n+typedef int_range<255> widest_irange;\n+\n+// Returns true for an old-school value_range as described above.\n+inline bool\n+irange::legacy_mode_p () const\n+{\n+  return m_max_ranges == 1;\n+}\n+\n+extern bool range_has_numeric_bounds_p (const irange *);\n extern bool ranges_from_anti_range (const value_range *,\n \t\t\t\t    value_range *, value_range *);\n-extern void dump_value_range (FILE *, const value_range *);\n+extern void dump_value_range (FILE *, const irange *);\n extern bool vrp_val_is_min (const_tree);\n extern bool vrp_val_is_max (const_tree);\n-extern tree vrp_val_min (const_tree);\n-extern tree vrp_val_max (const_tree);\n extern bool vrp_operand_equal_p (const_tree, const_tree);\n \n-inline\n-value_range::value_range ()\n+inline value_range_kind\n+irange::kind () const\n+{\n+  if (legacy_mode_p ())\n+    return m_kind;\n+\n+  if (undefined_p ())\n+    return VR_UNDEFINED;\n+\n+  if (varying_p ())\n+    return VR_VARYING;\n+\n+  return VR_RANGE;\n+}\n+\n+// Number of sub-ranges in a range.\n+\n+inline unsigned\n+irange::num_pairs () const\n {\n-  m_kind = VR_UNDEFINED;\n-  m_min = m_max = NULL;\n+  if (!legacy_mode_p ())\n+    return m_num_ranges;\n+  else\n+    return legacy_num_pairs ();\n }\n \n-inline value_range_kind\n-value_range::kind () const\n+inline tree\n+irange::type () const\n+{\n+  gcc_checking_assert (!undefined_p ());\n+  return TREE_TYPE (m_base[0]);\n+}\n+\n+// Return the lower bound of a sub-range expressed as a tree.  PAIR is\n+// the sub-range in question.\n+\n+inline tree\n+irange::tree_lower_bound (unsigned pair) const\n+{\n+  return m_base[pair * 2];\n+}\n+\n+// Return the upper bound of a sub-range expressed as a tree.  PAIR is\n+// the sub-range in question.\n+\n+inline tree\n+irange::tree_upper_bound (unsigned pair) const\n {\n-  return m_kind;\n+  return m_base[pair * 2 + 1];\n }\n \n+// Return the highest bound of a range expressed as a tree.\n+\n inline tree\n-value_range::type () const\n+irange::tree_upper_bound () const\n {\n-  return TREE_TYPE (min ());\n+  gcc_checking_assert (m_num_ranges);\n+  return tree_upper_bound (m_num_ranges - 1);\n }\n \n inline tree\n-value_range::min () const\n+irange::min () const\n {\n-  return m_min;\n+  return tree_lower_bound (0);\n }\n \n inline tree\n-value_range::max () const\n+irange::max () const\n {\n-  return m_max;\n+  if (m_num_ranges)\n+    return tree_upper_bound ();\n+  else\n+    return NULL;\n }\n \n inline bool\n-value_range::varying_p () const\n+irange::varying_p () const\n {\n-  return m_kind == VR_VARYING;\n+  if (legacy_mode_p ())\n+    return m_kind == VR_VARYING;\n+\n+  if (m_num_ranges != 1)\n+    return false;\n+\n+  tree l = m_base[0];\n+  tree u = m_base[1];\n+  tree t = TREE_TYPE (l);\n+  if (INTEGRAL_TYPE_P (t))\n+    return l == TYPE_MIN_VALUE (t) && u == TYPE_MAX_VALUE (t);\n+  if (POINTER_TYPE_P (t))\n+    return wi::to_wide (l) == 0\n+\t   && wi::to_wide (u) == wi::max_value (TYPE_PRECISION (t),\n+\t\t\t\t\t\tTYPE_SIGN (t));\n+  return true;\n+\n }\n \n inline bool\n-value_range::undefined_p () const\n+irange::undefined_p () const\n {\n+  if (!legacy_mode_p ())\n+    return m_num_ranges == 0;\n+\n+  if (CHECKING_P && legacy_mode_p ())\n+    {\n+      if (m_kind == VR_UNDEFINED)\n+\tgcc_checking_assert (m_num_ranges == 0);\n+      else\n+\tgcc_checking_assert (m_num_ranges != 0);\n+    }\n   return m_kind == VR_UNDEFINED;\n }\n \n inline bool\n-value_range::zero_p () const\n+irange::zero_p () const\n {\n-  return (m_kind == VR_RANGE\n-\t  && integer_zerop (m_min)\n-\t  && integer_zerop (m_max));\n+  return (m_kind == VR_RANGE && m_num_ranges == 1\n+\t  && integer_zerop (tree_lower_bound (0))\n+\t  && integer_zerop (tree_upper_bound (0)));\n }\n \n inline bool\n-value_range::nonzero_p () const\n+irange::nonzero_p () const\n {\n-  if (m_kind == VR_ANTI_RANGE\n-      && !TYPE_UNSIGNED (type ())\n-      && integer_zerop (m_min)\n-      && integer_zerop (m_max))\n-    return true;\n+  if (undefined_p ())\n+    return false;\n \n-  return (m_kind == VR_RANGE\n-\t  && TYPE_UNSIGNED (type ())\n-\t  && integer_onep (m_min)\n-\t  && vrp_val_is_max (m_max));\n+  tree zero = build_zero_cst (type ());\n+  return *this == int_range<1> (zero, zero, VR_ANTI_RANGE);\n }\n \n inline bool\n-value_range::supports_type_p (tree type)\n+irange::supports_type_p (tree type)\n {\n   if (type && (INTEGRAL_TYPE_P (type) || POINTER_TYPE_P (type)))\n     return type;\n   return false;\n }\n \n inline bool\n-range_includes_zero_p (const value_range *vr)\n+range_includes_zero_p (const irange *vr)\n {\n   if (vr->undefined_p ())\n     return false;\n@@ -212,4 +342,281 @@ range_includes_zero_p (const value_range *vr)\n   return vr->may_contain_p (build_zero_cst (vr->type ()));\n }\n \n+template<unsigned N>\n+static inline void\n+gt_ggc_mx (int_range<N> *x)\n+{\n+  for (unsigned i = 0; i < N; ++i)\n+    {\n+      gt_ggc_mx (x->m_ranges[i * 2]);\n+      gt_ggc_mx (x->m_ranges[i * 2 + 1]);\n+    }\n+}\n+\n+template<unsigned N>\n+static inline void\n+gt_pch_nx (int_range<N> *x)\n+{\n+  for (unsigned i = 0; i < N; ++i)\n+    {\n+      gt_pch_nx (x->m_ranges[i * 2]);\n+      gt_pch_nx (x->m_ranges[i * 2 + 1]);\n+    }\n+}\n+\n+template<unsigned N>\n+static inline void\n+gt_pch_nx (int_range<N> *x, gt_pointer_operator op, void *cookie)\n+{\n+  for (unsigned i = 0; i < N; ++i)\n+    {\n+      op (&x->m_ranges[i * 2], cookie);\n+      op (&x->m_ranges[i * 2 + 1], cookie);\n+    }\n+}\n+\n+// Constructors for irange\n+\n+inline\n+irange::irange (tree *base, unsigned nranges)\n+{\n+  m_base = base;\n+  m_num_ranges = 0;\n+  m_max_ranges = nranges;\n+  if (legacy_mode_p ())\n+    m_kind = VR_UNDEFINED;\n+  else\n+    m_kind = VR_RANGE;\n+}\n+\n+// Constructors for int_range<>.\n+\n+template<unsigned N>\n+inline\n+int_range<N>::int_range ()\n+  : irange (m_ranges, N)\n+{\n+}\n+\n+template<unsigned N>\n+int_range<N>::int_range (const int_range &other)\n+  : irange (m_ranges, N)\n+{\n+  irange::operator= (other);\n+}\n+\n+template<unsigned N>\n+int_range<N>::int_range (tree min, tree max, value_range_kind kind)\n+  : irange (m_ranges, N)\n+{\n+  irange::set (min, max, kind);\n+}\n+\n+template<unsigned N>\n+int_range<N>::int_range (tree type)\n+  : irange (m_ranges, N)\n+{\n+  set_varying (type);\n+}\n+\n+template<unsigned N>\n+int_range<N>::int_range (tree type, const wide_int &wmin, const wide_int &wmax,\n+\t\t\t value_range_kind kind)\n+  : irange (m_ranges, N)\n+{\n+  tree min = wide_int_to_tree (type, wmin);\n+  tree max = wide_int_to_tree (type, wmax);\n+  set (min, max, kind);\n+}\n+\n+template<unsigned N>\n+int_range<N>::int_range (const irange &other)\n+  : irange (m_ranges, N)\n+{\n+  irange::operator= (other);\n+}\n+\n+template<unsigned N>\n+int_range<N>&\n+int_range<N>::operator= (const int_range &src)\n+{\n+  irange::operator= (src);\n+  return *this;\n+}\n+\n+inline void\n+irange::set (tree val)\n+{\n+  set (val, val);\n+}\n+\n+inline void\n+irange::set_undefined ()\n+{\n+  m_num_ranges = 0;\n+  if (legacy_mode_p ())\n+    m_kind = VR_UNDEFINED;\n+}\n+\n+inline void\n+irange::set_varying (tree type)\n+{\n+  if (legacy_mode_p ())\n+    m_kind = VR_VARYING;\n+\n+  m_num_ranges = 1;\n+  if (INTEGRAL_TYPE_P (type))\n+    {\n+      m_base[0] = TYPE_MIN_VALUE (type);\n+      m_base[1] = TYPE_MAX_VALUE (type);\n+    }\n+  else if (POINTER_TYPE_P (type))\n+    {\n+      m_base[0] = build_int_cst (type, 0);\n+      m_base[1] = build_int_cst (type, -1);\n+    }\n+  else\n+    m_base[0] = m_base[1] = error_mark_node;\n+}\n+\n+inline bool\n+irange::operator== (const irange &r) const\n+{\n+  return equal_p (r);\n+}\n+\n+// Return the lower bound of a sub-range.  PAIR is the sub-range in\n+// question.\n+\n+inline wide_int\n+irange::lower_bound (unsigned pair) const\n+{\n+  if (legacy_mode_p ())\n+    return legacy_lower_bound (pair);\n+  gcc_checking_assert (!undefined_p ());\n+  gcc_checking_assert (pair + 1 <= num_pairs ());\n+  return wi::to_wide (tree_lower_bound (pair));\n+}\n+\n+// Return the upper bound of a sub-range.  PAIR is the sub-range in\n+// question.\n+\n+inline wide_int\n+irange::upper_bound (unsigned pair) const\n+{\n+  if (legacy_mode_p ())\n+    return legacy_upper_bound (pair);\n+  gcc_checking_assert (!undefined_p ());\n+  gcc_checking_assert (pair + 1 <= num_pairs ());\n+  return wi::to_wide (tree_upper_bound (pair));\n+}\n+\n+// Return the highest bound of a range.\n+\n+inline wide_int\n+irange::upper_bound () const\n+{\n+  unsigned pairs = num_pairs ();\n+  gcc_checking_assert (pairs > 0);\n+  return upper_bound (pairs - 1);\n+}\n+\n+inline void\n+irange::union_ (const irange &r)\n+{\n+  dump_flags_t m_flags = dump_flags;\n+  dump_flags &= ~TDF_DETAILS;\n+  irange::union_ (&r);\n+  dump_flags = m_flags;\n+}\n+\n+inline void\n+irange::intersect (const irange &r)\n+{\n+  dump_flags_t m_flags = dump_flags;\n+  dump_flags &= ~TDF_DETAILS;\n+  irange::intersect (&r);\n+  dump_flags = m_flags;\n+}\n+\n+// Set value range VR to a nonzero range of type TYPE.\n+\n+inline void\n+irange::set_nonzero (tree type)\n+{\n+  tree zero = build_int_cst (type, 0);\n+  if (legacy_mode_p ())\n+    set (zero, zero, VR_ANTI_RANGE);\n+  else\n+    irange_set_anti_range (zero, zero);\n+}\n+\n+// Set value range VR to a ZERO range of type TYPE.\n+\n+inline void\n+irange::set_zero (tree type)\n+{\n+  tree z = build_int_cst (type, 0);\n+  if (legacy_mode_p ())\n+    set (z);\n+  else\n+    irange_set (z, z);\n+}\n+\n+// Normalize [MIN, MAX] into VARYING and ~[MIN, MAX] into UNDEFINED.\n+//\n+// Avoid using TYPE_{MIN,MAX}_VALUE because -fstrict-enums can\n+// restrict those to a subset of what actually fits in the type.\n+// Instead use the extremes of the type precision which will allow\n+// compare_range_with_value() to check if a value is inside a range,\n+// whereas if we used TYPE_*_VAL, said function would just punt upon\n+// seeing a VARYING.\n+\n+inline bool\n+irange::normalize_min_max (tree type, tree min, tree max,\n+\t\t\t   value_range_kind kind)\n+{\n+  unsigned prec = TYPE_PRECISION (type);\n+  signop sign = TYPE_SIGN (type);\n+  if (wi::eq_p (wi::to_wide (min), wi::min_value (prec, sign))\n+      && wi::eq_p (wi::to_wide (max), wi::max_value (prec, sign)))\n+    {\n+      if (kind == VR_RANGE)\n+\tset_varying (type);\n+      else if (kind == VR_ANTI_RANGE)\n+\tset_undefined ();\n+      else\n+\tgcc_unreachable ();\n+      return true;\n+    }\n+  return false;\n+}\n+\n+// Return the maximum value for TYPE.\n+\n+inline tree\n+vrp_val_max (const_tree type)\n+{\n+  if (INTEGRAL_TYPE_P (type))\n+    return TYPE_MAX_VALUE (type);\n+  if (POINTER_TYPE_P (type))\n+    {\n+      wide_int max = wi::max_value (TYPE_PRECISION (type), TYPE_SIGN (type));\n+      return wide_int_to_tree (const_cast<tree> (type), max);\n+    }\n+  return NULL_TREE;\n+}\n+\n+// Return the minimum value for TYPE.\n+\n+inline tree\n+vrp_val_min (const_tree type)\n+{\n+  if (INTEGRAL_TYPE_P (type))\n+    return TYPE_MIN_VALUE (type);\n+  if (POINTER_TYPE_P (type))\n+    return build_zero_cst (const_cast<tree> (type));\n+  return NULL_TREE;\n+}\n+\n #endif // GCC_VALUE_RANGE_H"}, {"sha": "609375c072eaa0ca18d0d9ef252b02e6ad36af23", "filename": "gcc/vr-values.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf/gcc%2Fvr-values.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf/gcc%2Fvr-values.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.c?ref=4ba9fb0a3e65254cb5d8cb0a3bc67bbef8ed2fcf", "patch": "@@ -92,7 +92,8 @@ vr_values::get_lattice_entry (const_tree var)\n     return vr;\n \n   /* Create a default value range.  */\n-  vr_value[ver] = vr = vrp_value_range_pool.allocate ();\n+  vr = new (vrp_value_range_pool.allocate ()) value_range_equiv;\n+  vr_value[ver] = vr;\n \n   /* After propagation finished return varying.  */\n   if (values_propagated)"}]}