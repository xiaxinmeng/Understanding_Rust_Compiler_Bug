{"sha": "f749a7fa0b411b6d71e81ff5a95c3bad54eca09b", "node_id": "C_kwDOANBUbNoAKGY3NDlhN2ZhMGI0MTFiNmQ3MWU4MWZmNWE5NWMzYmFkNTRlY2EwOWI", "commit": {"author": {"name": "Pierre-Emmanuel Patry", "email": "pierre-emmanuel.patry@embecosm.com", "date": "2023-04-03T18:44:45Z"}, "committer": {"name": "CohenArthur", "email": "arthur.cohen@embecosm.com", "date": "2023-04-04T12:05:02Z"}, "message": "ast: Move pattern implementation out of rust-ast\n\nMove rust-pattern implementation out of rust-ast.cc in their own file.\n\ngcc/rust/ChangeLog:\n\n\t* Make-lang.in: Add two new files to the list of sources.\n\t* ast/rust-ast-full.h: Add new ast formatting header.\n\t* ast/rust-ast.cc (enum indent_mode): Move formatting function\n\tto it's own file.\n\t(indent_spaces): Likewise.\n\t(get_string_in_delims): Likewise.\n\t(enum AttrMode): Likewise.\n\t(get_mode_dump_desc): Likewise.\n\t(append_attributes): Likewise.\n\t(unquote_string): Likewise.\n\t(GroupedExpr::as_string): Move pattern implementation to it's\n\town file.\n\t(RangePattern::as_string): Likewise.\n\t(RangePatternBoundLiteral::as_string): Likewise.\n\t(SlicePattern::as_string): Likewise.\n\t(AltPattern::as_string): Likewise.\n\t(TuplePatternItemsMultiple::as_string): Likewise.\n\t(TuplePatternItemsRanged::as_string): Likewise.\n\t(TuplePattern::as_string): Likewise.\n\t(StructPatternField::as_string): Likewise.\n\t(StructPatternFieldIdent::as_string): Likewise.\n\t(StructPatternFieldTuplePat::as_string): Likewise.\n\t(StructPatternFieldIdentPat::as_string): Likewise.\n\t(StructPatternElements::as_string): Likewise.\n\t(StructPattern::as_string): Likewise.\n\t(LiteralPattern::as_string): Likewise.\n\t(ReferencePattern::as_string): Likewise.\n\t(IdentifierPattern::as_string): Likewise.\n\t(TupleStructItemsNoRange::as_string): Likewise.\n\t(TupleStructItemsRange::as_string): Likewise.\n\t(TupleStructPattern::as_string): Likewise.\n\t(GroupedExpr::accept_vis): Likewise.\n\t(LiteralPattern::accept_vis): Likewise.\n\t(IdentifierPattern::accept_vis): Likewise.\n\t(WildcardPattern::accept_vis): Likewise.\n\t(RestPattern::accept_vis): Likewise.\n\t(RangePatternBoundLiteral::accept_vis): Likewise.\n\t(RangePatternBoundPath::accept_vis): Likewise.\n\t(RangePatternBoundQualPath::accept_vis): Likewise.\n\t(RangePattern::accept_vis): Likewise.\n\t(ReferencePattern::accept_vis): Likewise.\n\t(StructPatternFieldTuplePat::accept_vis): Likewise.\n\t(StructPatternFieldIdentPat::accept_vis): Likewise.\n\t(StructPatternFieldIdent::accept_vis): Likewise.\n\t(StructPattern::accept_vis): Likewise.\n\t(TupleStructItemsNoRange::accept_vis): Likewise.\n\t(TupleStructItemsRange::accept_vis): Likewise.\n\t(TupleStructPattern::accept_vis): Likewise.\n\t(TuplePatternItemsMultiple::accept_vis): Likewise.\n\t(TuplePatternItemsRanged::accept_vis): Likewise.\n\t(TuplePattern::accept_vis): Likewise.\n\t(GroupedPattern::accept_vis): Likewise.\n\t(SlicePattern::accept_vis): Likewise.\n\t(AltPattern::accept_vis): Likewise.\n\t* ast/rust-ast-formatting.cc: New file.\n\t* ast/rust-ast-formatting.h: New file.\n\t* ast/rust-pattern.cc: New file.\n\nSigned-off-by: Pierre-Emmanuel Patry <pierre-emmanuel.patry@embecosm.com>", "tree": {"sha": "07ae4863f7d54704c87a18a36686cc5d303daaa0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/07ae4863f7d54704c87a18a36686cc5d303daaa0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f749a7fa0b411b6d71e81ff5a95c3bad54eca09b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f749a7fa0b411b6d71e81ff5a95c3bad54eca09b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f749a7fa0b411b6d71e81ff5a95c3bad54eca09b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f749a7fa0b411b6d71e81ff5a95c3bad54eca09b/comments", "author": {"login": "P-E-P", "id": 32375388, "node_id": "MDQ6VXNlcjMyMzc1Mzg4", "avatar_url": "https://avatars.githubusercontent.com/u/32375388?v=4", "gravatar_id": "", "url": "https://api.github.com/users/P-E-P", "html_url": "https://github.com/P-E-P", "followers_url": "https://api.github.com/users/P-E-P/followers", "following_url": "https://api.github.com/users/P-E-P/following{/other_user}", "gists_url": "https://api.github.com/users/P-E-P/gists{/gist_id}", "starred_url": "https://api.github.com/users/P-E-P/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/P-E-P/subscriptions", "organizations_url": "https://api.github.com/users/P-E-P/orgs", "repos_url": "https://api.github.com/users/P-E-P/repos", "events_url": "https://api.github.com/users/P-E-P/events{/privacy}", "received_events_url": "https://api.github.com/users/P-E-P/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b017829f1d22ea6ef0cd9cb05c29e04b5776de0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b017829f1d22ea6ef0cd9cb05c29e04b5776de0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b017829f1d22ea6ef0cd9cb05c29e04b5776de0"}], "stats": {"total": 1166, "additions": 636, "deletions": 530}, "files": [{"sha": "f02536e8b6204f60f44cc151c57b9b20c7f515d7", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f749a7fa0b411b6d71e81ff5a95c3bad54eca09b/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f749a7fa0b411b6d71e81ff5a95c3bad54eca09b/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=f749a7fa0b411b6d71e81ff5a95c3bad54eca09b", "patch": "@@ -73,7 +73,9 @@ GRS_OBJS = \\\n     rust/rust-cfg-parser.o \\\n     rust/rust-parse.o \\\n     rust/rust-ast.o \\\n+    rust/rust-ast-formatting.o \\\n     rust/rust-path.o \\\n+    rust/rust-pattern.o \\\n     rust/rust-ast-fragment.o \\\n     rust/rust-ast-dump.o \\\n     rust/rust-ast-tokenstream.o \\"}, {"sha": "4c13ef05dc6d2da165ff022c628aa41b72d5cd7e", "filename": "gcc/rust/ast/rust-ast-formatting.cc", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f749a7fa0b411b6d71e81ff5a95c3bad54eca09b/gcc%2Frust%2Fast%2Frust-ast-formatting.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f749a7fa0b411b6d71e81ff5a95c3bad54eca09b/gcc%2Frust%2Fast%2Frust-ast-formatting.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-formatting.cc?ref=f749a7fa0b411b6d71e81ff5a95c3bad54eca09b", "patch": "@@ -0,0 +1,106 @@\n+/* General AST-related method implementations for Rust frontend.\n+   Copyright (C) 2009-2023 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"rust-ast-full.h\"\n+\n+namespace Rust {\n+namespace AST {\n+\n+std::string\n+indent_spaces (enum indent_mode mode)\n+{\n+  static int indent = 0;\n+  std::string str = \"\";\n+  if (out == mode)\n+    indent--;\n+  for (int i = 0; i < indent; i++)\n+    str += \" \";\n+  if (enter == mode)\n+    indent++;\n+\n+  return str;\n+}\n+\n+std::string\n+get_string_in_delims (std::string str_input, DelimType delim_type)\n+{\n+  switch (delim_type)\n+    {\n+    case PARENS:\n+      return \"(\" + str_input + \")\";\n+    case SQUARE:\n+      return \"[\" + str_input + \"]\";\n+    case CURLY:\n+      return \"{\" + str_input + \"}\";\n+    default:\n+      return \"ERROR-MARK-STRING (delims)\";\n+    }\n+  gcc_unreachable ();\n+}\n+\n+std::string\n+get_mode_dump_desc (AttrMode mode)\n+{\n+  switch (mode)\n+    {\n+    case OUTER:\n+      return \"outer attributes\";\n+    case INNER:\n+      return \"inner attributes\";\n+    default:\n+      gcc_unreachable ();\n+      return \"\";\n+    }\n+}\n+\n+std::string\n+append_attributes (std::vector<Attribute> attrs, AttrMode mode)\n+{\n+  indent_spaces (enter);\n+\n+  std::string str\n+    = \"\\n\" + indent_spaces (stay) + get_mode_dump_desc (mode) + \": \";\n+  // str += \"\\n\" + indent_spaces (stay) + \"inner attributes: \";\n+  if (attrs.empty ())\n+    {\n+      str += \"none\";\n+    }\n+  else\n+    {\n+      /* note that this does not print them with outer or \"inner attribute\"\n+       * syntax - just prints the body */\n+      for (const auto &attr : attrs)\n+\tstr += \"\\n\" + indent_spaces (stay) + attr.as_string ();\n+    }\n+\n+  indent_spaces (out);\n+\n+  return str;\n+}\n+\n+std::string\n+unquote_string (std::string input)\n+{\n+  rust_assert (input.front () == '\"');\n+  rust_assert (input.back () == '\"');\n+  return input.substr (1, input.length () - 2);\n+}\n+\n+} // namespace AST\n+} // namespace Rust"}, {"sha": "04e20cc3114405d181d32d7589142e446c3b3acb", "filename": "gcc/rust/ast/rust-ast-formatting.h", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f749a7fa0b411b6d71e81ff5a95c3bad54eca09b/gcc%2Frust%2Fast%2Frust-ast-formatting.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f749a7fa0b411b6d71e81ff5a95c3bad54eca09b/gcc%2Frust%2Fast%2Frust-ast-formatting.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-formatting.h?ref=f749a7fa0b411b6d71e81ff5a95c3bad54eca09b", "patch": "@@ -0,0 +1,59 @@\n+// Copyright (C) 2020-2023 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_FORMATTING_H\n+#define RUST_AST_FORMATTING_H\n+\n+namespace Rust {\n+namespace AST {\n+\n+enum indent_mode\n+{\n+  enter,\n+  out,\n+  stay\n+};\n+\n+enum AttrMode\n+{\n+  OUTER,\n+  INNER\n+};\n+\n+std::string\n+indent_spaces (enum indent_mode mode);\n+\n+// Gets a string in a certain delim type.\n+std::string\n+get_string_in_delims (std::string str_input, DelimType delim_type);\n+\n+std::string\n+get_mode_dump_desc (AttrMode mode);\n+\n+// Adds lines below adding attributes\n+std::string\n+append_attributes (std::vector<Attribute> attrs, AttrMode mode);\n+\n+// Removes the beginning and end quotes of a quoted string.\n+std::string\n+unquote_string (std::string input);\n+\n+} // namespace AST\n+} // namespace Rust\n+\n+#endif /* ! RUST_AST_FORMATTING_H */"}, {"sha": "557b71ea7ee497426ae200e1ab691a75695b7aeb", "filename": "gcc/rust/ast/rust-ast-full.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f749a7fa0b411b6d71e81ff5a95c3bad54eca09b/gcc%2Frust%2Fast%2Frust-ast-full.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f749a7fa0b411b6d71e81ff5a95c3bad54eca09b/gcc%2Frust%2Fast%2Frust-ast-full.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full.h?ref=f749a7fa0b411b6d71e81ff5a95c3bad54eca09b", "patch": "@@ -20,6 +20,7 @@\n #define RUST_AST_FULL_H\n // Use as a fast way of including all aspects of the AST (i.e. all headers)\n #include \"rust-ast.h\"\n+#include \"rust-ast-formatting.h\"\n #include \"rust-expr.h\"\n #include \"rust-item.h\"\n #include \"rust-path.h\""}, {"sha": "7ba9be137ccc4b9feee96afc72387a70177fc6e0", "filename": "gcc/rust/ast/rust-ast.cc", "status": "modified", "additions": 0, "deletions": 530, "changes": 530, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f749a7fa0b411b6d71e81ff5a95c3bad54eca09b/gcc%2Frust%2Fast%2Frust-ast.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f749a7fa0b411b6d71e81ff5a95c3bad54eca09b/gcc%2Frust%2Fast%2Frust-ast.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.cc?ref=f749a7fa0b411b6d71e81ff5a95c3bad54eca09b", "patch": "@@ -35,102 +35,6 @@ along with GCC; see the file COPYING3.  If not see\n namespace Rust {\n namespace AST {\n \n-enum indent_mode\n-{\n-  enter,\n-  out,\n-  stay\n-};\n-\n-std::string\n-indent_spaces (enum indent_mode mode)\n-{\n-  static int indent = 0;\n-  std::string str = \"\";\n-  if (out == mode)\n-    indent--;\n-  for (int i = 0; i < indent; i++)\n-    str += \" \";\n-  if (enter == mode)\n-    indent++;\n-\n-  return str;\n-}\n-\n-// Gets a string in a certain delim type.\n-std::string\n-get_string_in_delims (std::string str_input, DelimType delim_type)\n-{\n-  switch (delim_type)\n-    {\n-    case PARENS:\n-      return \"(\" + str_input + \")\";\n-    case SQUARE:\n-      return \"[\" + str_input + \"]\";\n-    case CURLY:\n-      return \"{\" + str_input + \"}\";\n-    default:\n-      return \"ERROR-MARK-STRING (delims)\";\n-    }\n-  gcc_unreachable ();\n-}\n-\n-enum AttrMode\n-{\n-  OUTER,\n-  INNER\n-};\n-\n-std::string\n-get_mode_dump_desc (AttrMode mode)\n-{\n-  switch (mode)\n-    {\n-    case OUTER:\n-      return \"outer attributes\";\n-    case INNER:\n-      return \"inner attributes\";\n-    default:\n-      gcc_unreachable ();\n-      return \"\";\n-    }\n-}\n-\n-// Adds lines below adding attributes\n-std::string\n-append_attributes (std::vector<Attribute> attrs, AttrMode mode)\n-{\n-  indent_spaces (enter);\n-\n-  std::string str\n-    = \"\\n\" + indent_spaces (stay) + get_mode_dump_desc (mode) + \": \";\n-  // str += \"\\n\" + indent_spaces (stay) + \"inner attributes: \";\n-  if (attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with outer or \"inner attribute\"\n-       * syntax - just prints the body */\n-      for (const auto &attr : attrs)\n-\tstr += \"\\n\" + indent_spaces (stay) + attr.as_string ();\n-    }\n-\n-  indent_spaces (out);\n-\n-  return str;\n-}\n-\n-// Removes the beginning and end quotes of a quoted string.\n-std::string\n-unquote_string (std::string input)\n-{\n-  rust_assert (input.front () == '\"');\n-  rust_assert (input.back () == '\"');\n-  return input.substr (1, input.length () - 2);\n-}\n-\n std::string\n Crate::as_string () const\n {\n@@ -1471,22 +1375,6 @@ ReturnExpr::as_string () const\n   return str;\n }\n \n-std::string\n-GroupedExpr::as_string () const\n-{\n-  std::string str (\"Grouped expr:\");\n-\n-  // outer attrs\n-  str += append_attributes (outer_attrs, OUTER);\n-\n-  // inner attributes\n-  str += append_attributes (inner_attrs, INNER);\n-\n-  str += \"\\n Expr in parens: \" + expr_in_parens->as_string ();\n-\n-  return str;\n-}\n-\n std::string\n RangeToExpr::as_string () const\n {\n@@ -2465,286 +2353,6 @@ ForLoopExpr::as_string () const\n   return str;\n }\n \n-std::string\n-RangePattern::as_string () const\n-{\n-  // TODO: maybe rewrite to work with non-linearisable bounds\n-  if (has_ellipsis_syntax)\n-    return lower->as_string () + \"...\" + upper->as_string ();\n-  else\n-    return lower->as_string () + \"..=\" + upper->as_string ();\n-}\n-\n-std::string\n-RangePatternBoundLiteral::as_string () const\n-{\n-  std::string str;\n-\n-  if (has_minus)\n-    str += \"-\";\n-\n-  str += literal.as_string ();\n-\n-  return str;\n-}\n-\n-std::string\n-SlicePattern::as_string () const\n-{\n-  std::string str (\"SlicePattern: \");\n-\n-  for (const auto &pattern : items)\n-    str += \"\\n \" + pattern->as_string ();\n-\n-  return str;\n-}\n-\n-std::string\n-AltPattern::as_string () const\n-{\n-  std::string str (\"AltPattern: \");\n-\n-  for (const auto &pattern : alts)\n-    str += \"\\n \" + pattern->as_string ();\n-\n-  return str;\n-}\n-\n-std::string\n-TuplePatternItemsMultiple::as_string () const\n-{\n-  std::string str;\n-\n-  for (const auto &pattern : patterns)\n-    str += \"\\n \" + pattern->as_string ();\n-\n-  return str;\n-}\n-\n-std::string\n-TuplePatternItemsRanged::as_string () const\n-{\n-  std::string str;\n-\n-  str += \"\\n Lower patterns: \";\n-  if (lower_patterns.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      for (const auto &lower : lower_patterns)\n-\tstr += \"\\n  \" + lower->as_string ();\n-    }\n-\n-  str += \"\\n Upper patterns: \";\n-  if (upper_patterns.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      for (const auto &upper : upper_patterns)\n-\tstr += \"\\n  \" + upper->as_string ();\n-    }\n-\n-  return str;\n-}\n-\n-std::string\n-TuplePattern::as_string () const\n-{\n-  return \"TuplePattern: \" + items->as_string ();\n-}\n-\n-std::string\n-StructPatternField::as_string () const\n-{\n-  // outer attributes\n-  std::string str = append_attributes (outer_attrs, OUTER);\n-\n-  return str;\n-}\n-\n-std::string\n-StructPatternFieldIdent::as_string () const\n-{\n-  std::string str = StructPatternField::as_string ();\n-\n-  str += \"\\n\";\n-\n-  if (has_ref)\n-    str += \"ref \";\n-\n-  if (has_mut)\n-    str += \"mut \";\n-\n-  str += ident;\n-\n-  return str;\n-}\n-\n-std::string\n-StructPatternFieldTuplePat::as_string () const\n-{\n-  // TODO: maybe rewrite to work with non-linearisable patterns\n-  std::string str = StructPatternField::as_string ();\n-\n-  str += \"\\n\";\n-\n-  str += std::to_string (index) + \" : \" + tuple_pattern->as_string ();\n-\n-  return str;\n-}\n-\n-std::string\n-StructPatternFieldIdentPat::as_string () const\n-{\n-  // TODO: maybe rewrite to work with non-linearisable patterns\n-  std::string str = StructPatternField::as_string ();\n-\n-  str += \"\\n\";\n-\n-  str += ident + \" : \" + ident_pattern->as_string ();\n-\n-  return str;\n-}\n-\n-std::string\n-StructPatternElements::as_string () const\n-{\n-  std::string str (\"\\n  Fields: \");\n-\n-  if (!has_struct_pattern_fields ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      for (const auto &field : fields)\n-\tstr += \"\\n   \" + field->as_string ();\n-    }\n-\n-  str += \"\\n  Etc: \";\n-  if (has_struct_pattern_etc)\n-    str += \"true\";\n-  else\n-    str += \"false\";\n-\n-  return str;\n-}\n-\n-std::string\n-StructPattern::as_string () const\n-{\n-  std::string str (\"StructPattern: \\n Path: \");\n-\n-  str += path.as_string ();\n-\n-  str += \"\\n Struct pattern elems: \";\n-  if (!has_struct_pattern_elems ())\n-    str += \"none\";\n-  else\n-    str += elems.as_string ();\n-\n-  return str;\n-}\n-\n-std::string\n-LiteralPattern::as_string () const\n-{\n-  return lit.as_string ();\n-}\n-\n-std::string\n-ReferencePattern::as_string () const\n-{\n-  // TODO: maybe rewrite to work with non-linearisable patterns\n-  std::string str (\"&\");\n-\n-  if (has_two_amps)\n-    str += \"&\";\n-\n-  if (is_mut)\n-    str += \"mut \";\n-\n-  str += pattern->as_string ();\n-\n-  return str;\n-}\n-\n-std::string\n-IdentifierPattern::as_string () const\n-{\n-  // TODO: maybe rewrite to work with non-linearisable patterns\n-  std::string str;\n-\n-  if (is_ref)\n-    str += \"ref \";\n-\n-  if (is_mut)\n-    str += \"mut \";\n-\n-  str += variable_ident;\n-\n-  if (has_pattern_to_bind ())\n-    str += \" @ \" + to_bind->as_string ();\n-\n-  return str;\n-}\n-\n-std::string\n-TupleStructItemsNoRange::as_string () const\n-{\n-  std::string str;\n-\n-  for (const auto &pattern : patterns)\n-    str += \"\\n  \" + pattern->as_string ();\n-\n-  return str;\n-}\n-\n-std::string\n-TupleStructItemsRange::as_string () const\n-{\n-  std::string str (\"\\n  Lower patterns: \");\n-\n-  if (lower_patterns.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      for (const auto &lower : lower_patterns)\n-\tstr += \"\\n   \" + lower->as_string ();\n-    }\n-\n-  str += \"\\n  Upper patterns: \";\n-  if (upper_patterns.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      for (const auto &upper : upper_patterns)\n-\tstr += \"\\n   \" + upper->as_string ();\n-    }\n-\n-  return str;\n-}\n-\n-std::string\n-TupleStructPattern::as_string () const\n-{\n-  std::string str (\"TupleStructPattern: \\n Path: \");\n-\n-  str += path.as_string ();\n-\n-  str += \"\\n Tuple struct items: \" + items->as_string ();\n-\n-  return str;\n-}\n-\n std::string\n LetStmt::as_string () const\n {\n@@ -4763,12 +4371,6 @@ CompoundAssignmentExpr::accept_vis (ASTVisitor &vis)\n   vis.visit (*this);\n }\n \n-void\n-GroupedExpr::accept_vis (ASTVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n void\n ArrayElemsValues::accept_vis (ASTVisitor &vis)\n {\n@@ -5255,138 +4857,6 @@ MacroInvocation::accept_vis (ASTVisitor &vis)\n   vis.visit (*this);\n }\n \n-void\n-LiteralPattern::accept_vis (ASTVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-IdentifierPattern::accept_vis (ASTVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-WildcardPattern::accept_vis (ASTVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-RestPattern::accept_vis (ASTVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-RangePatternBoundLiteral::accept_vis (ASTVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-RangePatternBoundPath::accept_vis (ASTVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-RangePatternBoundQualPath::accept_vis (ASTVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-RangePattern::accept_vis (ASTVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-ReferencePattern::accept_vis (ASTVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-StructPatternFieldTuplePat::accept_vis (ASTVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-StructPatternFieldIdentPat::accept_vis (ASTVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-StructPatternFieldIdent::accept_vis (ASTVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-StructPattern::accept_vis (ASTVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-TupleStructItemsNoRange::accept_vis (ASTVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-TupleStructItemsRange::accept_vis (ASTVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-TupleStructPattern::accept_vis (ASTVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-TuplePatternItemsMultiple::accept_vis (ASTVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-TuplePatternItemsRanged::accept_vis (ASTVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-TuplePattern::accept_vis (ASTVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-GroupedPattern::accept_vis (ASTVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-SlicePattern::accept_vis (ASTVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-AltPattern::accept_vis (ASTVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n void\n EmptyStmt::accept_vis (ASTVisitor &vis)\n {"}, {"sha": "14179ca102742521426940b92069117a2678cdc9", "filename": "gcc/rust/ast/rust-pattern.cc", "status": "added", "additions": 468, "deletions": 0, "changes": 468, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f749a7fa0b411b6d71e81ff5a95c3bad54eca09b/gcc%2Frust%2Fast%2Frust-pattern.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f749a7fa0b411b6d71e81ff5a95c3bad54eca09b/gcc%2Frust%2Fast%2Frust-pattern.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-pattern.cc?ref=f749a7fa0b411b6d71e81ff5a95c3bad54eca09b", "patch": "@@ -0,0 +1,468 @@\n+/* General AST-related method implementations for Rust frontend.\n+   Copyright (C) 2009-2023 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"rust-system.h\"\n+#include \"rust-ast-full.h\"\n+#include \"rust-diagnostics.h\"\n+#include \"rust-ast-visitor.h\"\n+#include \"rust-macro.h\"\n+#include \"rust-session-manager.h\"\n+#include \"rust-lex.h\"\n+#include \"rust-parse.h\"\n+#include \"rust-operators.h\"\n+\n+namespace Rust {\n+namespace AST {\n+\n+std::string\n+LiteralPattern::as_string () const\n+{\n+  return lit.as_string ();\n+}\n+\n+std::string\n+IdentifierPattern::as_string () const\n+{\n+  // TODO: maybe rewrite to work with non-linearisable patterns\n+  std::string str;\n+\n+  if (is_ref)\n+    str += \"ref \";\n+\n+  if (is_mut)\n+    str += \"mut \";\n+\n+  str += variable_ident;\n+\n+  if (has_pattern_to_bind ())\n+    str += \" @ \" + to_bind->as_string ();\n+\n+  return str;\n+}\n+\n+std::string\n+RangePatternBoundLiteral::as_string () const\n+{\n+  std::string str;\n+\n+  if (has_minus)\n+    str += \"-\";\n+\n+  str += literal.as_string ();\n+\n+  return str;\n+}\n+\n+std::string\n+RangePattern::as_string () const\n+{\n+  // TODO: maybe rewrite to work with non-linearisable bounds\n+  if (has_ellipsis_syntax)\n+    return lower->as_string () + \"...\" + upper->as_string ();\n+  else\n+    return lower->as_string () + \"..=\" + upper->as_string ();\n+}\n+\n+std::string\n+ReferencePattern::as_string () const\n+{\n+  // TODO: maybe rewrite to work with non-linearisable patterns\n+  std::string str (\"&\");\n+\n+  if (has_two_amps)\n+    str += \"&\";\n+\n+  if (is_mut)\n+    str += \"mut \";\n+\n+  str += pattern->as_string ();\n+\n+  return str;\n+}\n+\n+std::string\n+StructPatternField::as_string () const\n+{\n+  // outer attributes\n+  std::string str = append_attributes (outer_attrs, OUTER);\n+\n+  return str;\n+}\n+\n+std::string\n+StructPatternFieldTuplePat::as_string () const\n+{\n+  // TODO: maybe rewrite to work with non-linearisable patterns\n+  std::string str = StructPatternField::as_string ();\n+\n+  str += \"\\n\";\n+\n+  str += std::to_string (index) + \" : \" + tuple_pattern->as_string ();\n+\n+  return str;\n+}\n+\n+std::string\n+StructPatternFieldIdentPat::as_string () const\n+{\n+  // TODO: maybe rewrite to work with non-linearisable patterns\n+  std::string str = StructPatternField::as_string ();\n+\n+  str += \"\\n\";\n+\n+  str += ident + \" : \" + ident_pattern->as_string ();\n+\n+  return str;\n+}\n+\n+std::string\n+StructPatternFieldIdent::as_string () const\n+{\n+  std::string str = StructPatternField::as_string ();\n+\n+  str += \"\\n\";\n+\n+  if (has_ref)\n+    str += \"ref \";\n+\n+  if (has_mut)\n+    str += \"mut \";\n+\n+  str += ident;\n+\n+  return str;\n+}\n+\n+std::string\n+StructPatternElements::as_string () const\n+{\n+  std::string str (\"\\n  Fields: \");\n+\n+  if (!has_struct_pattern_fields ())\n+    {\n+      str += \"none\";\n+    }\n+  else\n+    {\n+      for (const auto &field : fields)\n+\tstr += \"\\n   \" + field->as_string ();\n+    }\n+\n+  str += \"\\n  Etc: \";\n+  if (has_struct_pattern_etc)\n+    str += \"true\";\n+  else\n+    str += \"false\";\n+\n+  return str;\n+}\n+\n+std::string\n+StructPattern::as_string () const\n+{\n+  std::string str (\"StructPattern: \\n Path: \");\n+\n+  str += path.as_string ();\n+\n+  str += \"\\n Struct pattern elems: \";\n+  if (!has_struct_pattern_elems ())\n+    str += \"none\";\n+  else\n+    str += elems.as_string ();\n+\n+  return str;\n+}\n+\n+std::string\n+TupleStructItemsNoRange::as_string () const\n+{\n+  std::string str;\n+\n+  for (const auto &pattern : patterns)\n+    str += \"\\n  \" + pattern->as_string ();\n+\n+  return str;\n+}\n+\n+std::string\n+TupleStructItemsRange::as_string () const\n+{\n+  std::string str (\"\\n  Lower patterns: \");\n+\n+  if (lower_patterns.empty ())\n+    {\n+      str += \"none\";\n+    }\n+  else\n+    {\n+      for (const auto &lower : lower_patterns)\n+\tstr += \"\\n   \" + lower->as_string ();\n+    }\n+\n+  str += \"\\n  Upper patterns: \";\n+  if (upper_patterns.empty ())\n+    {\n+      str += \"none\";\n+    }\n+  else\n+    {\n+      for (const auto &upper : upper_patterns)\n+\tstr += \"\\n   \" + upper->as_string ();\n+    }\n+\n+  return str;\n+}\n+\n+std::string\n+TupleStructPattern::as_string () const\n+{\n+  std::string str (\"TupleStructPattern: \\n Path: \");\n+\n+  str += path.as_string ();\n+\n+  str += \"\\n Tuple struct items: \" + items->as_string ();\n+\n+  return str;\n+}\n+\n+std::string\n+TuplePatternItemsMultiple::as_string () const\n+{\n+  std::string str;\n+\n+  for (const auto &pattern : patterns)\n+    str += \"\\n \" + pattern->as_string ();\n+\n+  return str;\n+}\n+\n+std::string\n+TuplePatternItemsRanged::as_string () const\n+{\n+  std::string str;\n+\n+  str += \"\\n Lower patterns: \";\n+  if (lower_patterns.empty ())\n+    {\n+      str += \"none\";\n+    }\n+  else\n+    {\n+      for (const auto &lower : lower_patterns)\n+\tstr += \"\\n  \" + lower->as_string ();\n+    }\n+\n+  str += \"\\n Upper patterns: \";\n+  if (upper_patterns.empty ())\n+    {\n+      str += \"none\";\n+    }\n+  else\n+    {\n+      for (const auto &upper : upper_patterns)\n+\tstr += \"\\n  \" + upper->as_string ();\n+    }\n+\n+  return str;\n+}\n+\n+std::string\n+TuplePattern::as_string () const\n+{\n+  return \"TuplePattern: \" + items->as_string ();\n+}\n+\n+std::string\n+GroupedExpr::as_string () const\n+{\n+  std::string str (\"Grouped expr:\");\n+\n+  // outer attrs\n+  str += append_attributes (outer_attrs, OUTER);\n+\n+  // inner attributes\n+  str += append_attributes (inner_attrs, INNER);\n+\n+  str += \"\\n Expr in parens: \" + expr_in_parens->as_string ();\n+\n+  return str;\n+}\n+\n+std::string\n+SlicePattern::as_string () const\n+{\n+  std::string str (\"SlicePattern: \");\n+\n+  for (const auto &pattern : items)\n+    str += \"\\n \" + pattern->as_string ();\n+\n+  return str;\n+}\n+\n+std::string\n+AltPattern::as_string () const\n+{\n+  std::string str (\"AltPattern: \");\n+\n+  for (const auto &pattern : alts)\n+    str += \"\\n \" + pattern->as_string ();\n+\n+  return str;\n+}\n+\n+void\n+AltPattern::accept_vis (ASTVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+GroupedPattern::accept_vis (ASTVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+GroupedExpr::accept_vis (ASTVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+SlicePattern::accept_vis (ASTVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+TuplePatternItemsRanged::accept_vis (ASTVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+TuplePattern::accept_vis (ASTVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+TuplePatternItemsMultiple::accept_vis (ASTVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+LiteralPattern::accept_vis (ASTVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+IdentifierPattern::accept_vis (ASTVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+WildcardPattern::accept_vis (ASTVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+RestPattern::accept_vis (ASTVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+RangePatternBoundLiteral::accept_vis (ASTVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+RangePatternBoundPath::accept_vis (ASTVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+RangePatternBoundQualPath::accept_vis (ASTVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+RangePattern::accept_vis (ASTVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+ReferencePattern::accept_vis (ASTVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+StructPatternFieldTuplePat::accept_vis (ASTVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+StructPatternFieldIdentPat::accept_vis (ASTVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+StructPatternFieldIdent::accept_vis (ASTVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+StructPattern::accept_vis (ASTVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+TupleStructItemsNoRange::accept_vis (ASTVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+TupleStructItemsRange::accept_vis (ASTVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+void\n+TupleStructPattern::accept_vis (ASTVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+} // namespace AST\n+} // namespace Rust"}]}