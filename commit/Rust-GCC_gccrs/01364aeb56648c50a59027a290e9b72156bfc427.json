{"sha": "01364aeb56648c50a59027a290e9b72156bfc427", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDEzNjRhZWI1NjY0OGM1MGE1OTAyN2EyOTBlOWI3MjE1NmJmYzQyNw==", "commit": {"author": {"name": "Justin Squirek", "email": "squirek@adacore.com", "date": "2020-08-24T18:17:36Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-10-23T08:24:42Z"}, "message": "[Ada] Iterative patch for accessibility cleanup\n\ngcc/ada/\n\n\t* sem_util.adb (Accessibility_Call_Helper): In the selected\n\tcomponent case, test if a prefix is a function call and whether\n\tthe subprogram call is not being used in its entirety and use\n\tthe Innermost_Master_Scope_Depth in that case.\n\t(Innermost_Master_Scope_Depth): Test against the node_par\n\tinstead of its identifier to avoid misattributing unnamed blocks\n\tas not being from source.\n\t(Function_Call_Level): Add calculation for whether a subprogram\n\tcall is initializing an object in its entirety.\n\t(Subprogram_Call_Level): Renamed to Function_Call_Level.", "tree": {"sha": "af425070a70128dd360bc0d03bf6a99990a25a02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af425070a70128dd360bc0d03bf6a99990a25a02"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01364aeb56648c50a59027a290e9b72156bfc427", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01364aeb56648c50a59027a290e9b72156bfc427", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01364aeb56648c50a59027a290e9b72156bfc427", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01364aeb56648c50a59027a290e9b72156bfc427/comments", "author": {"login": "AdaDoom3", "id": 3445599, "node_id": "MDQ6VXNlcjM0NDU1OTk=", "avatar_url": "https://avatars.githubusercontent.com/u/3445599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AdaDoom3", "html_url": "https://github.com/AdaDoom3", "followers_url": "https://api.github.com/users/AdaDoom3/followers", "following_url": "https://api.github.com/users/AdaDoom3/following{/other_user}", "gists_url": "https://api.github.com/users/AdaDoom3/gists{/gist_id}", "starred_url": "https://api.github.com/users/AdaDoom3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AdaDoom3/subscriptions", "organizations_url": "https://api.github.com/users/AdaDoom3/orgs", "repos_url": "https://api.github.com/users/AdaDoom3/repos", "events_url": "https://api.github.com/users/AdaDoom3/events{/privacy}", "received_events_url": "https://api.github.com/users/AdaDoom3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d4ba374a73b226dc16af7190c688728f3e5d2c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d4ba374a73b226dc16af7190c688728f3e5d2c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d4ba374a73b226dc16af7190c688728f3e5d2c5"}], "stats": {"total": 105, "additions": 85, "deletions": 20}, "files": [{"sha": "d4a259f2a1db46fc0007331971e805e7ed22554f", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 85, "deletions": 20, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01364aeb56648c50a59027a290e9b72156bfc427/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01364aeb56648c50a59027a290e9b72156bfc427/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=01364aeb56648c50a59027a290e9b72156bfc427", "patch": "@@ -295,8 +295,8 @@ package body Sem_Util is\n       --  enclosing dynamic scope (effectively the accessibility\n       --  level of the innermost enclosing master).\n \n-      function Subprogram_Call_Level (Call_Ent : Entity_Id) return Node_Id;\n-      --  Centeralized processing of subprogram calls which may appear in\n+      function Function_Call_Level (Call_Ent : Entity_Id) return Node_Id;\n+      --  Centralized processing of subprogram calls which may appear in\n       --  prefix notation.\n \n       ----------------------------------\n@@ -314,7 +314,7 @@ package body Sem_Util is\n          --  that Defining_Entity can be applied to, and return the\n          --  depth of that entity's nearest enclosing dynamic scope.\n \n-         --  The rules which define what a master are are defined in\n+         --  The rules that define what a master are defined in\n          --  RM 7.6.1 (3), and include statements and conditions for loops\n          --  among other things. These cases are detected properly ???\n \n@@ -327,7 +327,7 @@ package body Sem_Util is\n \n                --  Ignore transient scopes made during expansion\n \n-               if Comes_From_Source (Encl_Scop) then\n+               if Comes_From_Source (Node_Par) then\n                   return Scope_Depth (Encl_Scop);\n                end if;\n \n@@ -366,15 +366,16 @@ package body Sem_Util is\n          return Result;\n       end Make_Level_Literal;\n \n-      ---------------------------\n-      -- Subprogram_Call_Level --\n-      ---------------------------\n+      -------------------------\n+      -- Function_Call_Level --\n+      -------------------------\n \n-      function Subprogram_Call_Level (Call_Ent : Entity_Id) return Node_Id is\n+      function Function_Call_Level (Call_Ent : Entity_Id) return Node_Id is\n+         Par : Node_Id;\n       begin\n          --  Results of functions are objects, so we either get the\n          --  accessibility of the function or, in case of a call which is\n-         --  indirect, the level of the access to subprogram type.\n+         --  indirect, the level of the access-to-subprogram type.\n \n          --  This code looks wrong ???\n \n@@ -393,17 +394,62 @@ package body Sem_Util is\n          if Is_Named_Access_Type (Etype (Call_Ent)) then\n             return Make_Level_Literal (Type_Access_Level (Etype (Call_Ent)));\n \n-         --  Otherwise, the level is that of the innermost master of the call,\n-         --  according to RM 3.10.2 (10.6/2).\n-\n-         --  Note: Expr is used here instead of Call_Ent since expansion may\n-         --  have taken place, and we need to ensure we can climb the parent\n-         --  chain.\n+         --  Otherwise, the level is dictated by RM 3.10.2 (10.7/3)\n \n          else\n-            return Make_Level_Literal (Innermost_Master_Scope_Depth (Expr));\n+            --  Find any relevant enclosing parent nodes that designate an\n+            --  object being initialized.\n+\n+            --  Note: The above is only relevant if the result is used \"in its\n+            --  entirety\" as RM 3.10.2 (10.2/3) states. However, this is\n+            --  accounted for in the case statement in the main body of\n+            --  Accessibility_Level_Helper for N_Selected_Component.\n+\n+            --  How are we sure, for example, that we are not coming up from,\n+            --  say, the left hand part of an assignment. More verification\n+            --  needed ???\n+\n+            Par := Parent (Expr);\n+            while Present (Par) loop\n+               exit when Nkind (Par) in N_Assignment_Statement\n+                                      | N_Object_Declaration\n+                                      | N_Function_Call;\n+               Par := Parent (Par);\n+            end loop;\n+\n+            --  If no object is being initialized then the level is that of the\n+            --  innermost master of the call, according to RM 3.10.2 (10.6/3).\n+\n+            if No (Par) or else Nkind (Par) = N_Function_Call then\n+               return Make_Level_Literal (Innermost_Master_Scope_Depth (Expr));\n+            end if;\n+\n+            --  The function call was used to initialize the entire object, so\n+            --  the master is \"that of the object.\"\n+\n+            --  Assignment statements are handled in a similar way in\n+            --  accordance to the left-hand part. However, strictly speaking,\n+            --  this is illegal according to the RM, but this change is needed\n+            --  to pass an ACATS C-test and is useful in general ???\n+\n+            case Nkind (Par) is\n+               when N_Object_Declaration =>\n+                  return Make_Level_Literal\n+                           (Scope_Depth\n+                             (Scope (Defining_Identifier (Par))));\n+\n+               when N_Assignment_Statement =>\n+                  --  Return the accessiblity level of the left-hand part\n+\n+                  return Accessibility_Level_Helper (Name (Par), Static);\n+\n+               --  Should never get here\n+\n+               when others =>\n+                  raise Program_Error;\n+            end case;\n          end if;\n-      end Subprogram_Call_Level;\n+      end Function_Call_Level;\n \n       --  Local variables\n \n@@ -471,15 +517,15 @@ package body Sem_Util is\n                   when N_Object_Declaration =>\n                      return Make_Level_Literal\n                               (Scope_Depth\n-                                (Scope (Defining_Identifier (Parent (Expr)))));\n+                                (Scope (Defining_Identifier (Par))));\n \n                   --  In an assignment statement the level is that of the\n                   --  object at the left-hand side.\n \n                   when N_Assignment_Statement =>\n                      return Make_Level_Literal\n                               (Scope_Depth\n-                                (Scope (Entity (Name (Parent (Expr))))));\n+                                (Scope (Entity (Name (Par)))));\n \n                   --  Subprogram calls have a level one deeper than the\n                   --  nearest enclosing scope.\n@@ -702,6 +748,25 @@ package body Sem_Util is\n                return Make_Level_Literal\n                         (Type_Access_Level (Etype (Prefix (E))));\n \n+            --  The accessibility calculation routine that handles function\n+            --  calls (Function_Call_Level) assumes, in the case the\n+            --  result is of an anonymous access type, that the result will be\n+            --  used \"in its entirety\" when the call is present within an\n+            --  assignment or object declaration.\n+\n+            --  To properly handle cases where the result is not used in its\n+            --  entirety, we test if the prefix of the component in question is\n+            --  a function call, which tells us that one of its components has\n+            --  been identified and is being accessed. Therefore we can\n+            --  conclude that the result is not used \"in its entirety\"\n+            --  according to RM 3.10.2 (10.2/3).\n+\n+            elsif Nkind (Pre) = N_Function_Call\n+              and then not Is_Named_Access_Type (Etype (Pre))\n+            then\n+               return Make_Level_Literal\n+                        (Innermost_Master_Scope_Depth (Expr));\n+\n             --  Otherwise, continue recursing over the expression prefixes\n \n             else\n@@ -721,7 +786,7 @@ package body Sem_Util is\n          --  Handle function calls\n \n          when N_Function_Call =>\n-            return Subprogram_Call_Level (E);\n+            return Function_Call_Level (E);\n \n          --  Explicit dereference accessibility level calculation\n "}]}