{"sha": "c2732da3bbdf6c723f562783fe383649f3f133e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzI3MzJkYTNiYmRmNmM3MjNmNTYyNzgzZmUzODM2NDlmM2YxMzNlOQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@casey.cygnus.com", "date": "2000-03-02T23:50:11Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2000-03-02T23:50:11Z"}, "message": "function.h (struct expr_status): Add x_arg_space_so_far.\n\n        * function.h (struct expr_status): Add x_arg_space_so_far.\n        (arg_space_so_far): New macro.\n        * expr.c (init_expr): Initialize it.\n        * calls.c (emit_call_1): Reset it.\n        (compute_argument_block_size, expand_call): Use it.\n        (expand_call, store_one_arg): Increment it.\n\nFrom-SVN: r32296", "tree": {"sha": "f69a6f6136385e1d2c8f5c79cf8274209b73b798", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f69a6f6136385e1d2c8f5c79cf8274209b73b798"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2732da3bbdf6c723f562783fe383649f3f133e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2732da3bbdf6c723f562783fe383649f3f133e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2732da3bbdf6c723f562783fe383649f3f133e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2732da3bbdf6c723f562783fe383649f3f133e9/comments", "author": null, "committer": null, "parents": [{"sha": "16214ee327ce67a984cb98816fb1230ccca232ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16214ee327ce67a984cb98816fb1230ccca232ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16214ee327ce67a984cb98816fb1230ccca232ac"}], "stats": {"total": 36, "additions": 33, "deletions": 3}, "files": [{"sha": "d8b64b40b9e85f727ba785ba8712fc24b3edcbf2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2732da3bbdf6c723f562783fe383649f3f133e9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2732da3bbdf6c723f562783fe383649f3f133e9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c2732da3bbdf6c723f562783fe383649f3f133e9", "patch": "@@ -1,3 +1,12 @@\n+2000-03-02  Jason Merrill  <jason@casey.cygnus.com>\n+\n+\t* function.h (struct expr_status): Add x_arg_space_so_far.\n+\t(arg_space_so_far): New macro.\n+\t* expr.c (init_expr): Initialize it.\n+\t* calls.c (emit_call_1): Reset it.\n+\t(compute_argument_block_size, expand_call): Use it.\n+\t(expand_call, store_one_arg): Increment it.\n+\n Thu Mar  2 17:27:13 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* varasm.c (output_constant): Strip off a CONVERT_EXPR to"}, {"sha": "4ff988a7c778898ebcca3d72ed4a9f4f6b99ebac", "filename": "gcc/calls.c", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2732da3bbdf6c723f562783fe383649f3f133e9/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2732da3bbdf6c723f562783fe383649f3f133e9/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=c2732da3bbdf6c723f562783fe383649f3f133e9", "patch": "@@ -352,9 +352,10 @@ prepare_call_address (funexp, fndecl, call_fusage, reg_parm_seen)\n    says that the pointer to this aggregate is to be popped by the callee.\n \n    STACK_SIZE is the number of bytes of arguments on the stack,\n-   rounded up to PREFERRED_STACK_BOUNDARY; zero if the size is variable.\n-   This is both to put into the call insn and\n-   to generate explicit popping code if necessary.\n+   ROUNDED_STACK_SIZE is that number rounded up to\n+   PREFERRED_STACK_BOUNDARY; zero if the size is variable.  This is\n+   both to put into the call insn and to generate explicit popping\n+   code if necessary.\n \n    STRUCT_VALUE_SIZE is the number of bytes wanted in a structure value.\n    It is zero if this call doesn't want a structure value.\n@@ -502,6 +503,10 @@ emit_call_1 (funexp, fndecl, funtype, stack_size, rounded_stack_size,\n      If returning from the subroutine does pop the args, indicate that the\n      stack pointer will be changed.  */\n \n+  /* The space for the args is no longer waiting for the call; either it\n+     was popped by the call, or it'll be popped below.  */\n+  arg_space_so_far -= rounded_stack_size;\n+\n   if (n_popped > 0)\n     {\n       if (!already_popped)\n@@ -1219,10 +1224,12 @@ compute_argument_block_size (reg_parm_stack_space, args_size,\n #ifdef PREFERRED_STACK_BOUNDARY\n       preferred_stack_boundary /= BITS_PER_UNIT;\n       args_size->constant = (((args_size->constant\n+\t\t\t       + arg_space_so_far\n \t\t\t       + pending_stack_adjust\n \t\t\t       + preferred_stack_boundary - 1)\n \t\t\t      / preferred_stack_boundary\n \t\t\t      * preferred_stack_boundary)\n+\t\t\t     - arg_space_so_far\n \t\t\t     - pending_stack_adjust);\n #endif\n \n@@ -2285,13 +2292,19 @@ expand_call (exp, target, ignore)\n \t{\n \t  args_size.constant = (unadjusted_args_size\n \t\t\t        + ((pending_stack_adjust + args_size.constant\n+\t\t\t\t    + arg_space_so_far\n \t\t\t\t    - unadjusted_args_size)\n \t\t\t           % (preferred_stack_boundary / BITS_PER_UNIT)));\n \t  pending_stack_adjust -= args_size.constant - unadjusted_args_size;\n \t  do_pending_stack_adjust ();\n \t}\n       else if (argblock == 0)\n \tanti_adjust_stack (GEN_INT (args_size.constant - unadjusted_args_size));\n+      arg_space_so_far += args_size.constant - unadjusted_args_size;\n+\n+      /* Now that the stack is properly aligned, pops can't safely\n+\t be deferred during the evaluation of the arguments.  */\n+      NO_DEFER_POP;\n     }\n #endif\n #endif\n@@ -4061,6 +4074,7 @@ store_one_arg (arg, argblock, may_be_alloca, variable_size,\n \t\t      ARGS_SIZE_RTX (arg->offset), reg_parm_stack_space,\n \t\t      ARGS_SIZE_RTX (arg->alignment_pad));\n \n+      arg_space_so_far += used;\n     }\n   else\n     {\n@@ -4088,6 +4102,7 @@ store_one_arg (arg, argblock, may_be_alloca, variable_size,\n \t  excess = (arg->size.constant - int_size_in_bytes (TREE_TYPE (pval))\n \t\t    + partial * UNITS_PER_WORD);\n \t  size_rtx = expr_size (pval);\n+\t  arg_space_so_far += excess + INTVAL (size_rtx);\n \t}\n \n       emit_push_insn (arg->value, arg->mode, TREE_TYPE (pval), size_rtx,"}, {"sha": "b0d1e078d5e50e5e4142a14dcbcf172ba8370c1f", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2732da3bbdf6c723f562783fe383649f3f133e9/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2732da3bbdf6c723f562783fe383649f3f133e9/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=c2732da3bbdf6c723f562783fe383649f3f133e9", "patch": "@@ -288,6 +288,7 @@ init_expr ()\n \n   pending_chain = 0;\n   pending_stack_adjust = 0;\n+  arg_space_so_far = 0;\n   inhibit_defer_pop = 0;\n   saveregs_value = 0;\n   apply_args_value = 0;"}, {"sha": "9ede7a73d08ff6c8959be1cb1923d325b808f541", "filename": "gcc/function.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2732da3bbdf6c723f562783fe383649f3f133e9/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2732da3bbdf6c723f562783fe383649f3f133e9/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=c2732da3bbdf6c723f562783fe383649f3f133e9", "patch": "@@ -130,6 +130,10 @@ struct expr_status\n      These are the arguments to function calls that have already returned.  */\n   int x_pending_stack_adjust;\n \n+  /* Number of units that we should eventually pop off the stack.\n+     These are the arguments to function calls that have not happened yet.  */\n+  int x_arg_space_so_far;\n+\n   /* Under some ABIs, it is the caller's responsibility to pop arguments\n      pushed for function calls.  A naive implementation would simply pop\n      the arguments immediately after each call.  However, if several\n@@ -163,6 +167,7 @@ struct expr_status\n };\n \n #define pending_stack_adjust (cfun->expr->x_pending_stack_adjust)\n+#define arg_space_so_far (cfun->expr->x_arg_space_so_far)\n #define inhibit_defer_pop (cfun->expr->x_inhibit_defer_pop)\n #define saveregs_value (cfun->expr->x_saveregs_value)\n #define apply_args_value (cfun->expr->x_apply_args_value)"}]}