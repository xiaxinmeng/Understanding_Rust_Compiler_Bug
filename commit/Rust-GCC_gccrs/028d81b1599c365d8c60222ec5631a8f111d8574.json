{"sha": "028d81b1599c365d8c60222ec5631a8f111d8574", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDI4ZDgxYjE1OTljMzY1ZDhjNjAyMjJlYzU2MzFhOGYxMTFkODU3NA==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2019-11-05T15:39:11Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2019-11-05T15:39:11Z"}, "message": "The base class for ranges is currently value_range_base, which is rather long and cumbersome.\n\nThe base class for ranges is currently value_range_base, which is\nrather long and cumbersome.  It also occurs more often than the derived\nclass of value_range.  To avoid confusion, and save typing, this\npatch does a global rename from value_range to value_range_equiv,\nand from value_range_base to value_range.\n\nThis way, the base class is simply value_range, and the derived\nclass is value_range_equiv which explicitly states what it does.\n\nFrom-SVN: r277847", "tree": {"sha": "2593124dc042ecb237d2105645807c03717b03b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2593124dc042ecb237d2105645807c03717b03b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/028d81b1599c365d8c60222ec5631a8f111d8574", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/028d81b1599c365d8c60222ec5631a8f111d8574", "html_url": "https://github.com/Rust-GCC/gccrs/commit/028d81b1599c365d8c60222ec5631a8f111d8574", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/028d81b1599c365d8c60222ec5631a8f111d8574/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3619076a631eac18c0484acf6dff3e5e94b8e251", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3619076a631eac18c0484acf6dff3e5e94b8e251", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3619076a631eac18c0484acf6dff3e5e94b8e251"}], "stats": {"total": 2292, "additions": 1140, "deletions": 1152}, "files": [{"sha": "d5e0f6135e5f37ada9edc3ed44de274f5b82be74", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=028d81b1599c365d8c60222ec5631a8f111d8574", "patch": "@@ -1,3 +1,13 @@\n+2019-11-05  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* gimple-fold.c, gimple-loop-versioning.cc,\n+\tgimple-ssa-evrp-analyze.[ch], gimple-ssa-evrp.c,\n+\tgimple-ssa-sprintf.c, ipa-cp.c, ipa-prop.c, ipa-prop.h,\n+\trange-op.[hc]*, range.[hc]*, selftest.h, tree-ssa-dom.c,\n+\ttree-ssa-strlen.c, tree-ssa-threadedge.c, tree-ssanames.[hc],\n+\ttree-vrp.[hc], vr-values.[hc]: Global rename of value_range to\n+\tvalue_range_equiv, and value_range_base to value_range.\n+\n 2019-11-05  Matthew Malcomson  <matthew.malcomson@arm.com>\n \n \t* expr.c (build_personality_function): Fix generated type to"}, {"sha": "1dfb23875330ccb579fedece6f8eb7cca0d7273a", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=028d81b1599c365d8c60222ec5631a8f111d8574", "patch": "@@ -677,10 +677,10 @@ size_must_be_zero_p (tree size)\n   /* Compute the value of SSIZE_MAX, the largest positive value that\n      can be stored in ssize_t, the signed counterpart of size_t.  */\n   wide_int ssize_max = wi::lshift (wi::one (prec), prec - 1) - 1;\n-  value_range_base valid_range (VR_RANGE,\n-\t\t\t\tbuild_int_cst (type, 0),\n-\t\t\t\twide_int_to_tree (type, ssize_max));\n-  value_range_base vr;\n+  value_range valid_range (VR_RANGE,\n+\t\t\t   build_int_cst (type, 0),\n+\t\t\t   wide_int_to_tree (type, ssize_max));\n+  value_range vr;\n   get_range_info (size, vr);\n   vr.intersect (&valid_range);\n   return vr.zero_p ();"}, {"sha": "1664d875e80004475ba91612b22b365050168fd6", "filename": "gcc/gimple-loop-versioning.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Fgimple-loop-versioning.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Fgimple-loop-versioning.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-loop-versioning.cc?ref=028d81b1599c365d8c60222ec5631a8f111d8574", "patch": "@@ -1495,7 +1495,7 @@ loop_versioning::prune_loop_conditions (class loop *loop, vr_values *vrs)\n   EXECUTE_IF_SET_IN_BITMAP (&li.unity_names, 0, i, bi)\n     {\n       tree name = ssa_name (i);\n-      const value_range *vr = vrs->get_value_range (name);\n+      const value_range_equiv *vr = vrs->get_value_range (name);\n       if (vr && !vr->may_contain_p (build_one_cst (TREE_TYPE (name))))\n \t{\n \t  if (dump_enabled_p ())"}, {"sha": "3a9fa75a678277e01ce5d44240b93249734a9069", "filename": "gcc/gimple-ssa-evrp-analyze.c", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Fgimple-ssa-evrp-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Fgimple-ssa-evrp-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp-analyze.c?ref=028d81b1599c365d8c60222ec5631a8f111d8574", "patch": "@@ -62,7 +62,7 @@ evrp_range_analyzer::evrp_range_analyzer (bool update_global_ranges)\n void\n evrp_range_analyzer::push_marker ()\n {\n-  stack.safe_push (std::make_pair (NULL_TREE, (value_range *)NULL));\n+  stack.safe_push (std::make_pair (NULL_TREE, (value_range_equiv *)NULL));\n }\n \n /* Analyze ranges as we enter basic block BB.  */\n@@ -79,12 +79,12 @@ evrp_range_analyzer::enter (basic_block bb)\n }\n \n /* Find new range for NAME such that (OP CODE LIMIT) is true.  */\n-value_range *\n+value_range_equiv *\n evrp_range_analyzer::try_find_new_range (tree name,\n-\t\t\t\t    tree op, tree_code code, tree limit)\n+\t\t\t\t\t tree op, tree_code code, tree limit)\n {\n-  value_range vr;\n-  const value_range *old_vr = get_value_range (name);\n+  value_range_equiv vr;\n+  const value_range_equiv *old_vr = get_value_range (name);\n \n   /* Discover VR when condition is true.  */\n   vr_values->extract_range_for_var_from_comparison_expr (name, code, op,\n@@ -93,11 +93,9 @@ evrp_range_analyzer::try_find_new_range (tree name,\n      PUSH old value in the stack with the old VR.  */\n   if (!vr.undefined_p () && !vr.varying_p ())\n     {\n-      if (old_vr->kind () == vr.kind ()\n-\t  && vrp_operand_equal_p (old_vr->min (), vr.min ())\n-\t  && vrp_operand_equal_p (old_vr->max (), vr.max ()))\n+      if (old_vr->equal_p (vr, /*ignore_equivs=*/true))\n \treturn NULL;\n-      value_range *new_vr = vr_values->allocate_value_range ();\n+      value_range_equiv *new_vr = vr_values->allocate_value_range_equiv ();\n       new_vr->move (&vr);\n       return new_vr;\n     }\n@@ -106,7 +104,7 @@ evrp_range_analyzer::try_find_new_range (tree name,\n \n /* For LHS record VR in the SSA info.  */\n void\n-evrp_range_analyzer::set_ssa_range_info (tree lhs, value_range *vr)\n+evrp_range_analyzer::set_ssa_range_info (tree lhs, value_range_equiv *vr)\n {\n   gcc_assert (m_update_global_ranges);\n \n@@ -187,13 +185,14 @@ evrp_range_analyzer::record_ranges_from_incoming_edge (basic_block bb)\n \t  if (TREE_CODE (op1) == SSA_NAME)\n \t    register_edge_assert_for (op1, pred_e, code, op0, op1, asserts);\n \n-\t  auto_vec<std::pair<tree, value_range *>, 8> vrs;\n+\t  auto_vec<std::pair<tree, value_range_equiv *>, 8> vrs;\n \t  for (unsigned i = 0; i < asserts.length (); ++i)\n \t    {\n-\t      value_range *vr = try_find_new_range (asserts[i].name,\n-\t\t\t\t\t\t    asserts[i].expr,\n-\t\t\t\t\t\t    asserts[i].comp_code,\n-\t\t\t\t\t\t    asserts[i].val);\n+\t      value_range_equiv *vr\n+\t\t= try_find_new_range (asserts[i].name,\n+\t\t\t\t      asserts[i].expr,\n+\t\t\t\t      asserts[i].comp_code,\n+\t\t\t\t      asserts[i].val);\n \t      if (vr)\n \t\tvrs.safe_push (std::make_pair (asserts[i].name, vr));\n \t    }\n@@ -209,9 +208,9 @@ evrp_range_analyzer::record_ranges_from_incoming_edge (basic_block bb)\n \t      /* But make sure we do not weaken ranges like when\n \t         getting first [64, +INF] and then ~[0, 0] from\n \t\t conditions like (s & 0x3cc0) == 0).  */\n-\t      const value_range *old_vr = get_value_range (vrs[i].first);\n-\t      value_range_base tem (old_vr->kind (), old_vr->min (),\n-\t\t\t\t    old_vr->max ());\n+\t      const value_range_equiv *old_vr\n+\t\t= get_value_range (vrs[i].first);\n+\t      value_range tem (*old_vr);\n \t      tem.intersect (vrs[i].second);\n \t      if (tem.equal_p (*old_vr))\n \t\t{\n@@ -256,10 +255,10 @@ evrp_range_analyzer::record_ranges_from_phis (basic_block bb)\n \n       /* Skips floats and other things we can't represent in a\n \t range.  */\n-      if (!value_range_base::supports_type_p (TREE_TYPE (lhs)))\n+      if (!value_range::supports_type_p (TREE_TYPE (lhs)))\n \tcontinue;\n \n-      value_range vr_result;\n+      value_range_equiv vr_result;\n       bool interesting = stmt_interesting_for_vrp (phi);\n       if (!has_unvisited_preds && interesting)\n \tvr_values->extract_range_from_phi_node (phi, &vr_result);\n@@ -303,7 +302,7 @@ evrp_range_analyzer::record_ranges_from_stmt (gimple *stmt, bool temporary)\n   else if (stmt_interesting_for_vrp (stmt))\n     {\n       edge taken_edge;\n-      value_range vr;\n+      value_range_equiv vr;\n       vr_values->extract_range_from_stmt (stmt, &taken_edge, &output, &vr);\n       if (output)\n \t{\n@@ -333,7 +332,8 @@ evrp_range_analyzer::record_ranges_from_stmt (gimple *stmt, bool temporary)\n \t\t a new range and push the old range onto the stack.  We\n \t\t also have to be very careful about sharing the underlying\n \t\t bitmaps.  Ugh.  */\n-\t      value_range *new_vr = vr_values->allocate_value_range ();\n+\t      value_range_equiv *new_vr\n+\t\t= vr_values->allocate_value_range_equiv ();\n \t      new_vr->set (vr.kind (), vr.min (), vr.max ());\n \t      vr.equiv_clear ();\n \t      push_value_range (output, new_vr);\n@@ -379,15 +379,15 @@ evrp_range_analyzer::record_ranges_from_stmt (gimple *stmt, bool temporary)\n \n \t\t  /* Add VR when (T COMP_CODE value) condition is\n \t\t     true.  */\n-\t\t  value_range *op_range\n+\t\t  value_range_equiv *op_range\n \t\t    = try_find_new_range (t, t, comp_code, value);\n \t\t  if (op_range)\n \t\t    push_value_range (t, op_range);\n \t\t}\n \t    }\n \t  /* Add VR when (OP COMP_CODE value) condition is true.  */\n-\t  value_range *op_range = try_find_new_range (op, op,\n-\t\t\t\t\t\t      comp_code, value);\n+\t  value_range_equiv *op_range = try_find_new_range (op, op,\n+\t\t\t\t\t\t\t    comp_code, value);\n \t  if (op_range)\n \t    push_value_range (op, op_range);\n \t}\n@@ -419,7 +419,7 @@ evrp_range_analyzer::leave (basic_block bb ATTRIBUTE_UNUSED)\n /* Push the Value Range of VAR to the stack and update it with new VR.  */\n \n void\n-evrp_range_analyzer::push_value_range (tree var, value_range *vr)\n+evrp_range_analyzer::push_value_range (tree var, value_range_equiv *vr)\n {\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -429,7 +429,7 @@ evrp_range_analyzer::push_value_range (tree var, value_range *vr)\n       dump_value_range (dump_file, vr);\n       fprintf (dump_file, \"\\n\");\n     }\n-  value_range *old_vr = vr_values->swap_vr_value (var, vr);\n+  value_range_equiv *old_vr = vr_values->swap_vr_value (var, vr);\n   stack.safe_push (std::make_pair (var, old_vr));\n }\n \n@@ -438,9 +438,9 @@ evrp_range_analyzer::push_value_range (tree var, value_range *vr)\n void\n evrp_range_analyzer::pop_value_range ()\n {\n-  std::pair<tree, value_range *> e = stack.pop ();\n+  std::pair<tree, value_range_equiv *> e = stack.pop ();\n   tree var = e.first;\n-  value_range *vr = e.second;\n+  value_range_equiv *vr = e.second;\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"popping range for \");\n@@ -451,7 +451,7 @@ evrp_range_analyzer::pop_value_range ()\n     }\n   /* We saved off a lattice entry, now give it back and release\n      the one we popped.  */\n-  value_range *popped_vr = vr_values->swap_vr_value (var, vr);\n+  value_range_equiv *popped_vr = vr_values->swap_vr_value (var, vr);\n   if (popped_vr)\n     vr_values->free_value_range (popped_vr);\n }"}, {"sha": "f6512a3450b211482bd240a2fc4640e521dd9a7d", "filename": "gcc/gimple-ssa-evrp-analyze.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Fgimple-ssa-evrp-analyze.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Fgimple-ssa-evrp-analyze.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp-analyze.h?ref=028d81b1599c365d8c60222ec5631a8f111d8574", "patch": "@@ -37,11 +37,11 @@ class evrp_range_analyzer\n   void record_ranges_from_stmt (gimple *, bool);\n \n   /* Main interface to retrieve range information.  */\n-  const value_range *get_value_range (const_tree op)\n+  const value_range_equiv *get_value_range (const_tree op)\n     { return vr_values->get_value_range (op); }\n \n   /* Record a new unwindable range.  */\n-  void push_value_range (tree var, value_range *vr);\n+  void push_value_range (tree var, value_range_equiv *vr);\n \n   /* Dump all the current value ranges.  This is primarily\n      a debugging interface.  */\n@@ -63,13 +63,14 @@ class evrp_range_analyzer\n   class vr_values *vr_values;\n \n   void pop_value_range ();\n-  value_range *try_find_new_range (tree, tree op, tree_code code, tree limit);\n+  value_range_equiv *try_find_new_range (tree, tree op, tree_code code,\n+\t\t\t\t\t tree limit);\n   void record_ranges_from_incoming_edge (basic_block);\n   void record_ranges_from_phis (basic_block);\n-  void set_ssa_range_info (tree, value_range *);\n+  void set_ssa_range_info (tree, value_range_equiv *);\n \n   /* STACK holds the old VR.  */\n-  auto_vec<std::pair <tree, value_range *> > stack;\n+  auto_vec<std::pair <tree, value_range_equiv *> > stack;\n \n   /* True if we are updating global ranges, false otherwise.  */\n   bool m_update_global_ranges;"}, {"sha": "a704cd5ffaf3fc70c31b8f075ab94e93e8e3d0f2", "filename": "gcc/gimple-ssa-evrp.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Fgimple-ssa-evrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Fgimple-ssa-evrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp.c?ref=028d81b1599c365d8c60222ec5631a8f111d8574", "patch": "@@ -109,7 +109,7 @@ evrp_dom_walker::before_dom_children (basic_block bb)\n       if (virtual_operand_p (lhs))\n \tcontinue;\n \n-      const value_range *vr = evrp_range_analyzer.get_value_range (lhs);\n+      const value_range_equiv *vr = evrp_range_analyzer.get_value_range (lhs);\n       /* Mark PHIs whose lhs we fully propagate for removal.  */\n       tree val;\n       if (vr->singleton_p (&val) && may_propagate_copy (lhs, val))\n@@ -158,11 +158,11 @@ evrp_dom_walker::before_dom_children (basic_block bb)\n \t  output = get_output_for_vrp (stmt);\n \t  if (output)\n \t    {\n-\t      tree val;\n-\t      const value_range *vr\n+\t      const value_range_equiv *vr\n \t\t= evrp_range_analyzer.get_value_range (output);\n \n \t      /* Mark stmts whose output we fully propagate for removal.  */\n+\t      tree val;\n \t      if (vr->singleton_p (&val)\n \t\t  && may_propagate_copy (output, val)\n \t\t  && !stmt_could_throw_p (cfun, stmt)\n@@ -244,7 +244,8 @@ evrp_dom_walker::before_dom_children (basic_block bb)\n \t  if (TREE_CODE (arg) != SSA_NAME\n \t      || virtual_operand_p (arg))\n \t    continue;\n-\t  const value_range *vr = evrp_range_analyzer.get_value_range (arg);\n+\t  const value_range_equiv\n+\t    *vr = evrp_range_analyzer.get_value_range (arg);\n \t  tree val;\n \t  if (vr->singleton_p (&val) && may_propagate_copy (arg, val))\n \t    propagate_value (use_p, val);"}, {"sha": "ef04b2a59384dc056450b3610ee0215a0607f4b9", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=028d81b1599c365d8c60222ec5631a8f111d8574", "patch": "@@ -1021,7 +1021,7 @@ get_int_range (tree arg, HOST_WIDE_INT *pmin, HOST_WIDE_INT *pmax,\n \t  && TYPE_PRECISION (argtype) <= TYPE_PRECISION (type))\n \t{\n \t  /* Try to determine the range of values of the integer argument.  */\n-\t  const value_range *vr\n+\t  const value_range_equiv *vr\n \t    = CONST_CAST (class vr_values *, vr_values)->get_value_range (arg);\n \n \t  if (range_int_cst_p (vr))\n@@ -1323,7 +1323,7 @@ format_integer (const directive &dir, tree arg, const vr_values *vr_values)\n     {\n       /* Try to determine the range of values of the integer argument\n \t (range information is not available for pointers).  */\n-      const value_range *vr\n+      const value_range_equiv *vr\n \t= CONST_CAST (class vr_values *, vr_values)->get_value_range (arg);\n \n       if (range_int_cst_p (vr))\n@@ -4087,7 +4087,7 @@ handle_printf_call (gimple_stmt_iterator *gsi, const vr_values *vr_values)\n \t  /* Try to determine the range of values of the argument\n \t     and use the greater of the two at level 1 and the smaller\n \t     of them at level 2.  */\n-\t  const value_range *vr\n+\t  const value_range_equiv *vr\n \t    = CONST_CAST (class vr_values *, vr_values)->get_value_range (size);\n \n \t  if (range_int_cst_p (vr))"}, {"sha": "c6bd265f5933fe49adaedff45a0effc141790fc4", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=028d81b1599c365d8c60222ec5631a8f111d8574", "patch": "@@ -307,18 +307,18 @@ class ipcp_bits_lattice\n class ipcp_vr_lattice\n {\n public:\n-  value_range_base m_vr;\n+  value_range m_vr;\n \n   inline bool bottom_p () const;\n   inline bool top_p () const;\n   inline bool set_to_bottom ();\n-  bool meet_with (const value_range_base *p_vr);\n+  bool meet_with (const value_range *p_vr);\n   bool meet_with (const ipcp_vr_lattice &other);\n   void init () { gcc_assert (m_vr.undefined_p ()); }\n   void print (FILE * f);\n \n private:\n-  bool meet_with_1 (const value_range_base *other_vr);\n+  bool meet_with_1 (const value_range *other_vr);\n };\n \n /* Structure containing lattices for a parameter itself and for pieces of\n@@ -930,7 +930,7 @@ ipcp_vr_lattice::meet_with (const ipcp_vr_lattice &other)\n    lattice.  */\n \n bool\n-ipcp_vr_lattice::meet_with (const value_range_base *p_vr)\n+ipcp_vr_lattice::meet_with (const value_range *p_vr)\n {\n   return meet_with_1 (p_vr);\n }\n@@ -939,15 +939,15 @@ ipcp_vr_lattice::meet_with (const value_range_base *p_vr)\n    OTHER_VR lattice.  Return TRUE if anything changed.  */\n \n bool\n-ipcp_vr_lattice::meet_with_1 (const value_range_base *other_vr)\n+ipcp_vr_lattice::meet_with_1 (const value_range *other_vr)\n {\n   if (bottom_p ())\n     return false;\n \n   if (other_vr->varying_p ())\n     return set_to_bottom ();\n \n-  value_range_base save (m_vr);\n+  value_range save (m_vr);\n   m_vr.union_ (other_vr);\n   return !m_vr.equal_p (save);\n }\n@@ -1939,8 +1939,8 @@ propagate_bits_across_jump_function (cgraph_edge *cs, int idx,\n    the result is a range or an anti-range.  */\n \n static bool\n-ipa_vr_operation_and_type_effects (value_range_base *dst_vr,\n-\t\t\t\t   value_range_base *src_vr,\n+ipa_vr_operation_and_type_effects (value_range *dst_vr,\n+\t\t\t\t   value_range *src_vr,\n \t\t\t\t   enum tree_code operation,\n \t\t\t\t   tree dst_type, tree src_type)\n {\n@@ -1983,7 +1983,7 @@ propagate_vr_across_jump_function (cgraph_edge *cs, ipa_jump_func *jfunc,\n \n \t  if (src_lats->m_value_range.bottom_p ())\n \t    return dest_lat->set_to_bottom ();\n-\t  value_range_base vr;\n+\t  value_range vr;\n \t  if (ipa_vr_operation_and_type_effects (&vr,\n \t\t\t\t\t\t &src_lats->m_value_range.m_vr,\n \t\t\t\t\t\t operation, param_type,\n@@ -2000,12 +2000,12 @@ propagate_vr_across_jump_function (cgraph_edge *cs, ipa_jump_func *jfunc,\n \t  if (TREE_OVERFLOW_P (val))\n \t    val = drop_tree_overflow (val);\n \n-\t  value_range_base tmpvr (VR_RANGE, val, val);\n+\t  value_range tmpvr (VR_RANGE, val, val);\n \t  return dest_lat->meet_with (&tmpvr);\n \t}\n     }\n \n-  value_range_base vr;\n+  value_range vr;\n   if (jfunc->m_vr\n       && ipa_vr_operation_and_type_effects (&vr, jfunc->m_vr, NOP_EXPR,\n \t\t\t\t\t    param_type,"}, {"sha": "094e68178ec85b31f7e1012683b031235367f522", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=028d81b1599c365d8c60222ec5631a8f111d8574", "patch": "@@ -107,42 +107,42 @@ static GTY ((cache)) hash_table<ipa_bit_ggc_hash_traits> *ipa_bits_hash_table;\n /* Traits for a hash table for reusing value_ranges used for IPA.  Note that\n    the equiv bitmap is not hashed and is expected to be NULL.  */\n \n-struct ipa_vr_ggc_hash_traits : public ggc_cache_remove <value_range_base *>\n+struct ipa_vr_ggc_hash_traits : public ggc_cache_remove <value_range *>\n {\n-  typedef value_range_base *value_type;\n-  typedef value_range_base *compare_type;\n+  typedef value_range *value_type;\n+  typedef value_range *compare_type;\n   static hashval_t\n-  hash (const value_range_base *p)\n+  hash (const value_range *p)\n     {\n       inchash::hash hstate (p->kind ());\n       inchash::add_expr (p->min (), hstate);\n       inchash::add_expr (p->max (), hstate);\n       return hstate.end ();\n     }\n   static bool\n-  equal (const value_range_base *a, const value_range_base *b)\n+  equal (const value_range *a, const value_range *b)\n     {\n       return a->equal_p (*b);\n     }\n   static void\n-  mark_empty (value_range_base *&p)\n+  mark_empty (value_range *&p)\n     {\n       p = NULL;\n     }\n   static bool\n-  is_empty (const value_range_base *p)\n+  is_empty (const value_range *p)\n     {\n       return p == NULL;\n     }\n   static bool\n-  is_deleted (const value_range_base *p)\n+  is_deleted (const value_range *p)\n     {\n-      return p == reinterpret_cast<const value_range_base *> (1);\n+      return p == reinterpret_cast<const value_range *> (1);\n     }\n   static void\n-  mark_deleted (value_range_base *&p)\n+  mark_deleted (value_range *&p)\n     {\n-      p = reinterpret_cast<value_range_base *> (1);\n+      p = reinterpret_cast<value_range *> (1);\n     }\n };\n \n@@ -1802,14 +1802,14 @@ ipa_set_jfunc_bits (ipa_jump_func *jf, const widest_int &value,\n /* Return a pointer to a value_range just like *TMP, but either find it in\n    ipa_vr_hash_table or allocate it in GC memory.  TMP->equiv must be NULL.  */\n \n-static value_range_base *\n-ipa_get_value_range (value_range_base *tmp)\n+static value_range *\n+ipa_get_value_range (value_range *tmp)\n {\n-  value_range_base **slot = ipa_vr_hash_table->find_slot (tmp, INSERT);\n+  value_range **slot = ipa_vr_hash_table->find_slot (tmp, INSERT);\n   if (*slot)\n     return *slot;\n \n-  value_range_base *vr = ggc_alloc<value_range_base> ();\n+  value_range *vr = ggc_alloc<value_range> ();\n   *vr = *tmp;\n   *slot = vr;\n \n@@ -1820,10 +1820,10 @@ ipa_get_value_range (value_range_base *tmp)\n    equiv set. Use hash table in order to avoid creating multiple same copies of\n    value_ranges.  */\n \n-static value_range_base *\n+static value_range *\n ipa_get_value_range (enum value_range_kind type, tree min, tree max)\n {\n-  value_range_base tmp (type, min, max);\n+  value_range tmp (type, min, max);\n   return ipa_get_value_range (&tmp);\n }\n \n@@ -1842,7 +1842,7 @@ ipa_set_jfunc_vr (ipa_jump_func *jf, enum value_range_kind type,\n    copy from ipa_vr_hash_table or allocate a new on in GC memory.  */\n \n static void\n-ipa_set_jfunc_vr (ipa_jump_func *jf, value_range_base *tmp)\n+ipa_set_jfunc_vr (ipa_jump_func *jf, value_range *tmp)\n {\n   jf->m_vr = ipa_get_value_range (tmp);\n }\n@@ -1919,8 +1919,8 @@ ipa_compute_jump_functions_for_edge (struct ipa_func_body_info *fbi,\n \t      && (type = get_range_info (arg, &min, &max))\n \t      && (type == VR_RANGE || type == VR_ANTI_RANGE))\n \t    {\n-\t      value_range_base resvr;\n-\t      value_range_base tmpvr (type,\n+\t      value_range resvr;\n+\t      value_range tmpvr (type,\n \t\t\t\t      wide_int_to_tree (TREE_TYPE (arg), min),\n \t\t\t\t      wide_int_to_tree (TREE_TYPE (arg), max));\n \t      range_fold_unary_expr (&resvr, NOP_EXPR, param_type,"}, {"sha": "7a9e4bc591601e7235c61a53fd9f64a025ac53a6", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=028d81b1599c365d8c60222ec5631a8f111d8574", "patch": "@@ -205,7 +205,7 @@ struct GTY (()) ipa_jump_func\n   /* Information about value range, containing valid data only when vr_known is\n      true.  The pointed to structure is shared betweed different jump\n      functions.  Use ipa_set_jfunc_vr to set this field.  */\n-  class value_range_base *m_vr;\n+  class value_range *m_vr;\n \n   enum jump_func_type type;\n   /* Represents a value of a jump function.  pass_through is used only in jump"}, {"sha": "8ec8392df576e7f8b0979f99a1bdb2b73ed8f297", "filename": "gcc/range-op.cc", "status": "modified", "additions": 633, "deletions": 645, "changes": 1278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Frange-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Frange-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.cc?ref=028d81b1599c365d8c60222ec5631a8f111d8574", "patch": "@@ -66,9 +66,8 @@ min_limit (const_tree type)\n // undefined and return TRUE.\n \n inline bool\n-empty_range_check (value_range_base &r,\n-\t\t   const value_range_base &op1,\n-\t\t   const value_range_base & op2)\n+empty_range_check (value_range &r,\n+\t\t   const value_range &op1, const value_range & op2)\n {\n   if (op1.undefined_p () || op2.undefined_p ())\n     {\n@@ -83,12 +82,11 @@ empty_range_check (value_range_base &r,\n // the appropriate range.\n \n static inline bool\n-undefined_shift_range_check (value_range_base &r, tree type,\n-\t\t\t     value_range_base op)\n+undefined_shift_range_check (value_range &r, tree type, const value_range op)\n {\n   if (op.undefined_p ())\n     {\n-      r = value_range_base ();\n+      r = value_range ();\n       return true;\n     }\n \n@@ -100,7 +98,7 @@ undefined_shift_range_check (value_range_base &r, tree type,\n       || wi::ge_p (op.upper_bound (),\n \t\t   TYPE_PRECISION (type), TYPE_SIGN (op.type ())))\n     {\n-      r = value_range_base (type);\n+      r = value_range (type);\n       return true;\n     }\n   return false;\n@@ -126,25 +124,25 @@ wi_zero_p (tree type, const wide_int &wmin, const wide_int &wmax)\n \n // Default wide_int fold operation returns [MIN, MAX].\n \n-value_range_base\n+value_range\n range_operator::wi_fold (tree type,\n \t\t\t const wide_int &lh_lb ATTRIBUTE_UNUSED,\n \t\t\t const wide_int &lh_ub ATTRIBUTE_UNUSED,\n \t\t\t const wide_int &rh_lb ATTRIBUTE_UNUSED,\n \t\t\t const wide_int &rh_ub ATTRIBUTE_UNUSED) const\n {\n-  return value_range_base (type);\n+  return value_range (type);\n }\n \n // The default for fold is to break all ranges into sub-ranges and\n // invoke the wi_fold method on each sub-range pair.\n \n-value_range_base\n+value_range\n range_operator::fold_range (tree type,\n-\t\t\t    const value_range_base &lh,\n-\t\t\t    const value_range_base &rh) const\n+\t\t\t    const value_range &lh,\n+\t\t\t    const value_range &rh) const\n {\n-  value_range_base r;\n+  value_range r;\n   if (empty_range_check (r, lh, rh))\n     return r;\n \n@@ -165,21 +163,21 @@ range_operator::fold_range (tree type,\n // The default for op1_range is to return false.\n \n bool\n-range_operator::op1_range (value_range_base &r ATTRIBUTE_UNUSED,\n+range_operator::op1_range (value_range &r ATTRIBUTE_UNUSED,\n \t\t\t   tree type ATTRIBUTE_UNUSED,\n-\t\t\t   const value_range_base &lhs ATTRIBUTE_UNUSED,\n-\t\t\t   const value_range_base &op2 ATTRIBUTE_UNUSED) const\n+\t\t\t   const value_range &lhs ATTRIBUTE_UNUSED,\n+\t\t\t   const value_range &op2 ATTRIBUTE_UNUSED) const\n {\n   return false;\n }\n \n // The default for op2_range is to return false.\n \n bool\n-range_operator::op2_range (value_range_base &r ATTRIBUTE_UNUSED,\n+range_operator::op2_range (value_range &r ATTRIBUTE_UNUSED,\n \t\t\t   tree type ATTRIBUTE_UNUSED,\n-\t\t\t   const value_range_base &lhs ATTRIBUTE_UNUSED,\n-\t\t\t   const value_range_base &op1 ATTRIBUTE_UNUSED) const\n+\t\t\t   const value_range &lhs ATTRIBUTE_UNUSED,\n+\t\t\t   const value_range &op1 ATTRIBUTE_UNUSED) const\n {\n   return false;\n }\n@@ -188,7 +186,7 @@ range_operator::op2_range (value_range_base &r ATTRIBUTE_UNUSED,\n // Create and return a range from a pair of wide-ints that are known\n // to have overflowed (or underflowed).\n \n-static value_range_base\n+static value_range\n value_range_from_overflowed_bounds (tree type,\n \t\t\t\t    const wide_int &wmin,\n \t\t\t\t    const wide_int &wmax)\n@@ -212,16 +210,16 @@ value_range_from_overflowed_bounds (tree type,\n   // Likewise if the anti-range bounds are outside of the types\n   // values.\n   if (covers || wi::cmp (tmin, tmax, sgn) > 0)\n-    return value_range_base (type);\n+    return value_range (type);\n \n-  return value_range_base (VR_ANTI_RANGE, type, tmin, tmax);\n+  return value_range (VR_ANTI_RANGE, type, tmin, tmax);\n }\n \n // Create and return a range from a pair of wide-ints.  MIN_OVF and\n // MAX_OVF describe any overflow that might have occurred while\n // calculating WMIN and WMAX respectively.\n \n-static value_range_base\n+static value_range\n value_range_with_overflow (tree type,\n \t\t\t   const wide_int &wmin, const wide_int &wmax,\n \t\t\t   wi::overflow_type min_ovf = wi::OVF_NONE,\n@@ -234,7 +232,7 @@ value_range_with_overflow (tree type,\n   // For one bit precision if max != min, then the range covers all\n   // values.\n   if (prec == 1 && wi::ne_p (wmax, wmin))\n-    return value_range_base (type);\n+    return value_range (type);\n \n   if (overflow_wraps)\n     {\n@@ -247,19 +245,19 @@ value_range_with_overflow (tree type,\n \t  // If the limits are swapped, we wrapped around and cover\n \t  // the entire range.\n \t  if (wi::gt_p (tmin, tmax, sgn))\n-\t    return value_range_base (type);\n+\t    return value_range (type);\n \n \t  // No overflow or both overflow or underflow.  The range\n \t  // kind stays normal.\n-\t  return value_range_base (type, tmin, tmax);\n+\t  return value_range (type, tmin, tmax);\n \t}\n \n       if ((min_ovf == wi::OVF_UNDERFLOW && max_ovf == wi::OVF_NONE)\n \t  || (max_ovf == wi::OVF_OVERFLOW && min_ovf == wi::OVF_NONE))\n \treturn value_range_from_overflowed_bounds (type, wmin, wmax);\n \n       // Other underflow and/or overflow, drop to VR_VARYING.\n-      return value_range_base (type);\n+      return value_range (type);\n     }\n   else\n     {\n@@ -279,15 +277,15 @@ value_range_with_overflow (tree type,\n       else\n         new_ub = wmax;\n \n-      return value_range_base (type, new_lb, new_ub);\n+      return value_range (type, new_lb, new_ub);\n     }\n }\n \n // Create and return a range from a pair of wide-ints.  Canonicalize\n // the case where the bounds are swapped.  In which case, we transform\n // [10,5] into [MIN,5][10,MAX].\n \n-static inline value_range_base\n+static inline value_range\n create_possibly_reversed_range (tree type,\n \t\t\t\tconst wide_int &new_lb, const wide_int &new_ub)\n {\n@@ -297,34 +295,34 @@ create_possibly_reversed_range (tree type,\n     return value_range_from_overflowed_bounds (type, new_lb, new_ub);\n \n   // Otherwise its just a normal range.\n-  return value_range_base (type, new_lb, new_ub);\n+  return value_range (type, new_lb, new_ub);\n }\n \n-// Return a value_range_base instance that is a boolean TRUE.\n+// Return a value_range instance that is a boolean TRUE.\n \n-static inline value_range_base\n+static inline value_range\n range_true (tree type)\n {\n   unsigned prec = TYPE_PRECISION (type);\n-  return value_range_base (type, wi::one (prec), wi::one (prec));\n+  return value_range (type, wi::one (prec), wi::one (prec));\n }\n \n-// Return a value_range_base instance that is a boolean FALSE.\n+// Return a value_range instance that is a boolean FALSE.\n \n-static inline value_range_base\n+static inline value_range\n range_false (tree type)\n {\n   unsigned prec = TYPE_PRECISION (type);\n-  return value_range_base (type, wi::zero (prec), wi::zero (prec));\n+  return value_range (type, wi::zero (prec), wi::zero (prec));\n }\n \n-// Return a value_range_base that covers both true and false.\n+// Return a value_range that covers both true and false.\n \n-static inline value_range_base\n+static inline value_range\n range_true_and_false (tree type)\n {\n   unsigned prec = TYPE_PRECISION (type);\n-  return value_range_base (type, wi::zero (prec), wi::one (prec));\n+  return value_range (type, wi::zero (prec), wi::one (prec));\n }\n \n enum bool_range_state { BRS_FALSE, BRS_TRUE, BRS_EMPTY, BRS_FULL };\n@@ -335,8 +333,7 @@ enum bool_range_state { BRS_FALSE, BRS_TRUE, BRS_EMPTY, BRS_FULL };\n // the bool range.\n \n static bool_range_state\n-get_bool_state (value_range_base &r,\n-\t\tconst value_range_base &lhs, tree val_type)\n+get_bool_state (value_range &r, const value_range &lhs, tree val_type)\n {\n   // If there is no result, then this is unexecutable.\n   if (lhs.undefined_p ())\n@@ -362,23 +359,23 @@ get_bool_state (value_range_base &r,\n class operator_equal : public range_operator\n {\n public:\n-  virtual value_range_base fold_range (tree type,\n-\t\t\t\t       const value_range_base &op1,\n-\t\t\t\t       const value_range_base &op2) const;\n-  virtual bool op1_range (value_range_base &r, tree type,\n-\t\t\t  const value_range_base &lhs,\n-\t\t\t  const value_range_base &val) const;\n-  virtual bool op2_range (value_range_base &r, tree type,\n-\t\t\t  const value_range_base &lhs,\n-\t\t\t  const value_range_base &val) const;\n+  virtual value_range fold_range (tree type,\n+\t\t\t\t  const value_range &op1,\n+\t\t\t\t  const value_range &op2) const;\n+  virtual bool op1_range (value_range &r, tree type,\n+\t\t\t  const value_range &lhs,\n+\t\t\t  const value_range &val) const;\n+  virtual bool op2_range (value_range &r, tree type,\n+\t\t\t  const value_range &lhs,\n+\t\t\t  const value_range &val) const;\n } op_equal;\n \n-value_range_base\n+value_range\n operator_equal::fold_range (tree type,\n-\t\t\t    const value_range_base &op1,\n-\t\t\t    const value_range_base &op2) const\n+\t\t\t    const value_range &op1,\n+\t\t\t    const value_range &op2) const\n {\n-  value_range_base r;\n+  value_range r;\n   if (empty_range_check (r, op1, op2))\n     return r;\n \n@@ -407,9 +404,9 @@ operator_equal::fold_range (tree type,\n }\n \n bool\n-operator_equal::op1_range (value_range_base &r, tree type,\n-\t\t\t   const value_range_base &lhs,\n-\t\t\t   const value_range_base &op2) const\n+operator_equal::op1_range (value_range &r, tree type,\n+\t\t\t   const value_range &lhs,\n+\t\t\t   const value_range &op2) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -434,9 +431,9 @@ operator_equal::op1_range (value_range_base &r, tree type,\n }\n \n bool\n-operator_equal::op2_range (value_range_base &r, tree type,\n-\t\t\t   const value_range_base &lhs,\n-\t\t\t   const value_range_base &op1) const\n+operator_equal::op2_range (value_range &r, tree type,\n+\t\t\t   const value_range &lhs,\n+\t\t\t   const value_range &op1) const\n {\n   return operator_equal::op1_range (r, type, lhs, op1);\n }\n@@ -445,23 +442,23 @@ operator_equal::op2_range (value_range_base &r, tree type,\n class operator_not_equal : public range_operator\n {\n public:\n-  virtual value_range_base fold_range (tree type,\n-\t\t\t\t       const value_range_base &op1,\n-\t\t\t\t       const value_range_base &op2) const;\n-  virtual bool op1_range (value_range_base &r, tree type,\n-\t\t\t  const value_range_base &lhs,\n-\t\t\t  const value_range_base &op2) const;\n-  virtual bool op2_range (value_range_base &r, tree type,\n-\t\t\t  const value_range_base &lhs,\n-\t\t\t  const value_range_base &op1) const;\n+  virtual value_range fold_range (tree type,\n+\t\t\t\t  const value_range &op1,\n+\t\t\t\t  const value_range &op2) const;\n+  virtual bool op1_range (value_range &r, tree type,\n+\t\t\t  const value_range &lhs,\n+\t\t\t  const value_range &op2) const;\n+  virtual bool op2_range (value_range &r, tree type,\n+\t\t\t  const value_range &lhs,\n+\t\t\t  const value_range &op1) const;\n } op_not_equal;\n \n-value_range_base\n+value_range\n operator_not_equal::fold_range (tree type,\n-\t\t\t\tconst value_range_base &op1,\n-\t\t\t\tconst value_range_base &op2) const\n+\t\t\t\tconst value_range &op1,\n+\t\t\t\tconst value_range &op2) const\n {\n-  value_range_base r;\n+  value_range r;\n   if (empty_range_check (r, op1, op2))\n     return r;\n \n@@ -490,9 +487,9 @@ operator_not_equal::fold_range (tree type,\n }\n \n bool\n-operator_not_equal::op1_range (value_range_base &r, tree type,\n-\t\t\t       const value_range_base &lhs,\n-\t\t\t       const value_range_base &op2) const\n+operator_not_equal::op1_range (value_range &r, tree type,\n+\t\t\t       const value_range &lhs,\n+\t\t\t       const value_range &op2) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -518,17 +515,17 @@ operator_not_equal::op1_range (value_range_base &r, tree type,\n \n \n bool\n-operator_not_equal::op2_range (value_range_base &r, tree type,\n-\t\t\t       const value_range_base &lhs,\n-\t\t\t       const value_range_base &op1) const\n+operator_not_equal::op2_range (value_range &r, tree type,\n+\t\t\t       const value_range &lhs,\n+\t\t\t       const value_range &op1) const\n {\n   return operator_not_equal::op1_range (r, type, lhs, op1);\n }\n \n // (X < VAL) produces the range of [MIN, VAL - 1].\n \n static void\n-build_lt (value_range_base &r, tree type, const wide_int &val)\n+build_lt (value_range &r, tree type, const wide_int &val)\n {\n   wi::overflow_type ov;\n   wide_int lim = wi::sub (val, 1, TYPE_SIGN (type), &ov);\n@@ -537,60 +534,60 @@ build_lt (value_range_base &r, tree type, const wide_int &val)\n   if (ov)\n     r.set_undefined ();\n   else\n-    r = value_range_base (type, min_limit (type), lim);\n+    r = value_range (type, min_limit (type), lim);\n }\n \n // (X <= VAL) produces the range of [MIN, VAL].\n \n static void\n-build_le (value_range_base &r, tree type, const wide_int &val)\n+build_le (value_range &r, tree type, const wide_int &val)\n {\n-  r = value_range_base (type, min_limit (type), val);\n+  r = value_range (type, min_limit (type), val);\n }\n \n // (X > VAL) produces the range of [VAL + 1, MAX].\n \n static void\n-build_gt (value_range_base &r, tree type, const wide_int &val)\n+build_gt (value_range &r, tree type, const wide_int &val)\n {\n   wi::overflow_type ov;\n   wide_int lim = wi::add (val, 1, TYPE_SIGN (type), &ov);\n   // If val + 1 overflows, check is for X > MAX, which is an empty range.\n   if (ov)\n     r.set_undefined ();\n   else\n-    r = value_range_base (type, lim, max_limit (type));\n+    r = value_range (type, lim, max_limit (type));\n }\n \n // (X >= val) produces the range of [VAL, MAX].\n \n static void\n-build_ge (value_range_base &r, tree type, const wide_int &val)\n+build_ge (value_range &r, tree type, const wide_int &val)\n {\n-  r = value_range_base (type, val, max_limit (type));\n+  r = value_range (type, val, max_limit (type));\n }\n \n \n class operator_lt :  public range_operator\n {\n public:\n-  virtual value_range_base fold_range (tree type,\n-\t\t\t\t       const value_range_base &op1,\n-\t\t\t\t       const value_range_base &op2) const;\n-  virtual bool op1_range (value_range_base &r, tree type,\n-\t\t\t  const value_range_base &lhs,\n-\t\t\t  const value_range_base &op2) const;\n-  virtual bool op2_range (value_range_base &r, tree type,\n-\t\t\t  const value_range_base &lhs,\n-\t\t\t  const value_range_base &op1) const;\n+  virtual value_range fold_range (tree type,\n+\t\t\t\t  const value_range &op1,\n+\t\t\t\t  const value_range &op2) const;\n+  virtual bool op1_range (value_range &r, tree type,\n+\t\t\t  const value_range &lhs,\n+\t\t\t  const value_range &op2) const;\n+  virtual bool op2_range (value_range &r, tree type,\n+\t\t\t  const value_range &lhs,\n+\t\t\t  const value_range &op1) const;\n } op_lt;\n \n-value_range_base\n+value_range\n operator_lt::fold_range (tree type,\n-\t\t\t const value_range_base &op1,\n-\t\t\t const value_range_base &op2) const\n+\t\t\t const value_range &op1,\n+\t\t\t const value_range &op2) const\n {\n-  value_range_base r;\n+  value_range r;\n   if (empty_range_check (r, op1, op2))\n     return r;\n \n@@ -607,9 +604,9 @@ operator_lt::fold_range (tree type,\n }\n \n bool\n-operator_lt::op1_range (value_range_base &r, tree type,\n-\t\t\tconst value_range_base &lhs,\n-\t\t\tconst value_range_base &op2) const\n+operator_lt::op1_range (value_range &r, tree type,\n+\t\t\tconst value_range &lhs,\n+\t\t\tconst value_range &op2) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -628,9 +625,9 @@ operator_lt::op1_range (value_range_base &r, tree type,\n }\n \n bool\n-operator_lt::op2_range (value_range_base &r, tree type,\n-\t\t\tconst value_range_base &lhs,\n-\t\t\tconst value_range_base &op1) const\n+operator_lt::op2_range (value_range &r, tree type,\n+\t\t\tconst value_range &lhs,\n+\t\t\tconst value_range &op1) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -652,23 +649,23 @@ operator_lt::op2_range (value_range_base &r, tree type,\n class operator_le :  public range_operator\n {\n public:\n-  virtual value_range_base fold_range (tree type,\n-\t\t\t\t       const value_range_base &op1,\n-\t\t\t\t       const value_range_base &op2) const;\n-  virtual bool op1_range (value_range_base &r, tree type,\n-\t\t\t  const value_range_base &lhs,\n-\t\t\t  const value_range_base &op2) const;\n-  virtual bool op2_range (value_range_base &r, tree type,\n-\t\t\t  const value_range_base &lhs,\n-\t\t\t  const value_range_base &op1) const;\n+  virtual value_range fold_range (tree type,\n+\t\t\t\t  const value_range &op1,\n+\t\t\t\t  const value_range &op2) const;\n+  virtual bool op1_range (value_range &r, tree type,\n+\t\t\t  const value_range &lhs,\n+\t\t\t  const value_range &op2) const;\n+  virtual bool op2_range (value_range &r, tree type,\n+\t\t\t  const value_range &lhs,\n+\t\t\t  const value_range &op1) const;\n } op_le;\n \n-value_range_base\n+value_range\n operator_le::fold_range (tree type,\n-\t\t\t const value_range_base &op1,\n-\t\t\t const value_range_base &op2) const\n+\t\t\t const value_range &op1,\n+\t\t\t const value_range &op2) const\n {\n-  value_range_base r;\n+  value_range r;\n   if (empty_range_check (r, op1, op2))\n     return r;\n \n@@ -685,9 +682,9 @@ operator_le::fold_range (tree type,\n }\n \n bool\n-operator_le::op1_range (value_range_base &r, tree type,\n-\t\t\tconst value_range_base &lhs,\n-\t\t\tconst value_range_base &op2) const\n+operator_le::op1_range (value_range &r, tree type,\n+\t\t\tconst value_range &lhs,\n+\t\t\tconst value_range &op2) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -706,9 +703,9 @@ operator_le::op1_range (value_range_base &r, tree type,\n }\n \n bool\n-operator_le::op2_range (value_range_base &r, tree type,\n-\t\t\tconst value_range_base &lhs,\n-\t\t\tconst value_range_base &op1) const\n+operator_le::op2_range (value_range &r, tree type,\n+\t\t\tconst value_range &lhs,\n+\t\t\tconst value_range &op1) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -730,23 +727,22 @@ operator_le::op2_range (value_range_base &r, tree type,\n class operator_gt :  public range_operator\n {\n public:\n-  virtual value_range_base fold_range (tree type,\n-\t\t\t\t       const value_range_base &op1,\n-\t\t\t\t       const value_range_base &op2) const;\n-  virtual bool op1_range (value_range_base &r, tree type,\n-\t\t\t  const value_range_base &lhs,\n-\t\t\t  const value_range_base &op2) const;\n-  virtual bool op2_range (value_range_base &r, tree type,\n-\t\t\t  const value_range_base &lhs,\n-\t\t\t  const value_range_base &op1) const;\n+  virtual value_range fold_range (tree type,\n+\t\t\t\t  const value_range &op1,\n+\t\t\t\t  const value_range &op2) const;\n+  virtual bool op1_range (value_range &r, tree type,\n+\t\t\t  const value_range &lhs,\n+\t\t\t  const value_range &op2) const;\n+  virtual bool op2_range (value_range &r, tree type,\n+\t\t\t  const value_range &lhs,\n+\t\t\t  const value_range &op1) const;\n } op_gt;\n \n-value_range_base\n+value_range\n operator_gt::fold_range (tree type,\n-\t\t\t const value_range_base &op1,\n-\t\t\t const value_range_base &op2) const\n+\t\t\t const value_range &op1, const value_range &op2) const\n {\n-  value_range_base r;\n+  value_range r;\n   if (empty_range_check (r, op1, op2))\n     return r;\n \n@@ -763,9 +759,8 @@ operator_gt::fold_range (tree type,\n }\n \n bool\n-operator_gt::op1_range (value_range_base &r, tree type,\n-\t\t\tconst value_range_base &lhs,\n-\t\t\tconst value_range_base &op2) const\n+operator_gt::op1_range (value_range &r, tree type,\n+\t\t\tconst value_range &lhs, const value_range &op2) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -784,9 +779,9 @@ operator_gt::op1_range (value_range_base &r, tree type,\n }\n \n bool\n-operator_gt::op2_range (value_range_base &r, tree type,\n-\t\t\tconst value_range_base &lhs,\n-\t\t\tconst value_range_base &op1) const\n+operator_gt::op2_range (value_range &r, tree type,\n+\t\t\tconst value_range &lhs,\n+\t\t\tconst value_range &op1) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -808,23 +803,23 @@ operator_gt::op2_range (value_range_base &r, tree type,\n class operator_ge :  public range_operator\n {\n public:\n-  virtual value_range_base fold_range (tree type,\n-\t\t\t\t       const value_range_base &op1,\n-\t\t\t\t       const value_range_base &op2) const;\n-  virtual bool op1_range (value_range_base &r, tree type,\n-\t\t\t  const value_range_base &lhs,\n-\t\t\t  const value_range_base &op2) const;\n-  virtual bool op2_range (value_range_base &r, tree type,\n-\t\t\t  const value_range_base &lhs,\n-\t\t\t  const value_range_base &op1) const;\n+  virtual value_range fold_range (tree type,\n+\t\t\t\t  const value_range &op1,\n+\t\t\t\t  const value_range &op2) const;\n+  virtual bool op1_range (value_range &r, tree type,\n+\t\t\t  const value_range &lhs,\n+\t\t\t  const value_range &op2) const;\n+  virtual bool op2_range (value_range &r, tree type,\n+\t\t\t  const value_range &lhs,\n+\t\t\t  const value_range &op1) const;\n } op_ge;\n \n-value_range_base\n+value_range\n operator_ge::fold_range (tree type,\n-\t\t\t const value_range_base &op1,\n-\t\t\t const value_range_base &op2) const\n+\t\t\t const value_range &op1,\n+\t\t\t const value_range &op2) const\n {\n-  value_range_base r;\n+  value_range r;\n   if (empty_range_check (r, op1, op2))\n     return r;\n \n@@ -841,9 +836,9 @@ operator_ge::fold_range (tree type,\n }\n \n bool\n-operator_ge::op1_range (value_range_base &r, tree type,\n-\t\t\tconst value_range_base &lhs,\n-\t\t\tconst value_range_base &op2) const\n+operator_ge::op1_range (value_range &r, tree type,\n+\t\t\tconst value_range &lhs,\n+\t\t\tconst value_range &op2) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -862,9 +857,9 @@ operator_ge::op1_range (value_range_base &r, tree type,\n }\n \n bool\n-operator_ge::op2_range (value_range_base &r, tree type,\n-\t\t\tconst value_range_base &lhs,\n-\t\t\tconst value_range_base &op1) const\n+operator_ge::op2_range (value_range &r, tree type,\n+\t\t\tconst value_range &lhs,\n+\t\t\tconst value_range &op1) const\n {\n   switch (get_bool_state (r, lhs, type))\n     {\n@@ -886,20 +881,20 @@ operator_ge::op2_range (value_range_base &r, tree type,\n class operator_plus : public range_operator\n {\n public:\n-  virtual bool op1_range (value_range_base &r, tree type,\n-\t\t\t  const value_range_base &lhs,\n-\t\t\t  const value_range_base &op2) const;\n-  virtual bool op2_range (value_range_base &r, tree type,\n-\t\t\t  const value_range_base &lhs,\n-\t\t\t  const value_range_base &op1) const;\n-  virtual value_range_base wi_fold (tree type,\n-\t\t\t\t    const wide_int &lh_lb,\n-\t\t\t\t    const wide_int &lh_ub,\n-\t\t\t\t    const wide_int &rh_lb,\n-\t\t\t\t    const wide_int &rh_ub) const;\n+  virtual bool op1_range (value_range &r, tree type,\n+\t\t\t  const value_range &lhs,\n+\t\t\t  const value_range &op2) const;\n+  virtual bool op2_range (value_range &r, tree type,\n+\t\t\t  const value_range &lhs,\n+\t\t\t  const value_range &op1) const;\n+  virtual value_range wi_fold (tree type,\n+\t\t\t       const wide_int &lh_lb,\n+\t\t\t       const wide_int &lh_ub,\n+\t\t\t       const wide_int &rh_lb,\n+\t\t\t       const wide_int &rh_ub) const;\n } op_plus;\n \n-value_range_base\n+value_range\n operator_plus::wi_fold (tree type,\n \t\t\tconst wide_int &lh_lb, const wide_int &lh_ub,\n \t\t\tconst wide_int &rh_lb, const wide_int &rh_ub) const\n@@ -912,18 +907,18 @@ operator_plus::wi_fold (tree type,\n }\n \n bool\n-operator_plus::op1_range (value_range_base &r, tree type,\n-\t\t\t  const value_range_base &lhs,\n-\t\t\t  const value_range_base &op2) const\n+operator_plus::op1_range (value_range &r, tree type,\n+\t\t\t  const value_range &lhs,\n+\t\t\t  const value_range &op2) const\n {\n   r = range_op_handler (MINUS_EXPR, type)->fold_range (type, lhs, op2);\n   return true;\n }\n \n bool\n-operator_plus::op2_range (value_range_base &r, tree type,\n-\t\t\t  const value_range_base &lhs,\n-\t\t\t  const value_range_base &op1) const\n+operator_plus::op2_range (value_range &r, tree type,\n+\t\t\t  const value_range &lhs,\n+\t\t\t  const value_range &op1) const\n {\n   r = range_op_handler (MINUS_EXPR, type)->fold_range (type, lhs, op1);\n   return true;\n@@ -933,20 +928,20 @@ operator_plus::op2_range (value_range_base &r, tree type,\n class operator_minus : public range_operator\n {\n public:\n-  virtual bool op1_range (value_range_base &r, tree type,\n-\t\t\t  const value_range_base &lhs,\n-\t\t\t  const value_range_base &op2) const;\n-  virtual bool op2_range (value_range_base &r, tree type,\n-\t\t\t  const value_range_base &lhs,\n-\t\t\t  const value_range_base &op1) const;\n-  virtual value_range_base wi_fold (tree type,\n-\t\t\t\t    const wide_int &lh_lb,\n-\t\t\t\t    const wide_int &lh_ub,\n-\t\t\t\t    const wide_int &rh_lb,\n-\t\t\t\t    const wide_int &rh_ub) const;\n+  virtual bool op1_range (value_range &r, tree type,\n+\t\t\t  const value_range &lhs,\n+\t\t\t  const value_range &op2) const;\n+  virtual bool op2_range (value_range &r, tree type,\n+\t\t\t  const value_range &lhs,\n+\t\t\t  const value_range &op1) const;\n+  virtual value_range wi_fold (tree type,\n+\t\t\t       const wide_int &lh_lb,\n+\t\t\t       const wide_int &lh_ub,\n+\t\t\t       const wide_int &rh_lb,\n+\t\t\t       const wide_int &rh_ub) const;\n } op_minus;\n \n-value_range_base\n+value_range\n operator_minus::wi_fold (tree type,\n \t\t\t const wide_int &lh_lb, const wide_int &lh_ub,\n \t\t\t const wide_int &rh_lb, const wide_int &rh_ub) const\n@@ -959,18 +954,18 @@ operator_minus::wi_fold (tree type,\n }\n \n bool\n-operator_minus::op1_range (value_range_base &r, tree type,\n-\t\t\t   const value_range_base &lhs,\n-\t\t\t   const value_range_base &op2) const\n+operator_minus::op1_range (value_range &r, tree type,\n+\t\t\t   const value_range &lhs,\n+\t\t\t   const value_range &op2) const\n {\n   r = range_op_handler (PLUS_EXPR, type)->fold_range (type, lhs, op2);\n   return true;\n }\n \n bool\n-operator_minus::op2_range (value_range_base &r, tree type,\n-\t\t\t   const value_range_base &lhs,\n-\t\t\t   const value_range_base &op1) const\n+operator_minus::op2_range (value_range &r, tree type,\n+\t\t\t   const value_range &lhs,\n+\t\t\t   const value_range &op1) const\n {\n   r = fold_range (type, op1, lhs);\n   return true;\n@@ -980,14 +975,14 @@ operator_minus::op2_range (value_range_base &r, tree type,\n class operator_min : public range_operator\n {\n public:\n-  virtual value_range_base wi_fold (tree type,\n-\t\t\t\t    const wide_int &lh_lb,\n-\t\t\t\t    const wide_int &lh_ub,\n-\t\t\t\t    const wide_int &rh_lb,\n-\t\t\t\t    const wide_int &rh_ub) const;\n+  virtual value_range wi_fold (tree type,\n+\t\t\t       const wide_int &lh_lb,\n+\t\t\t       const wide_int &lh_ub,\n+\t\t\t       const wide_int &rh_lb,\n+\t\t\t       const wide_int &rh_ub) const;\n } op_min;\n \n-value_range_base\n+value_range\n operator_min::wi_fold (tree type,\n \t\t       const wide_int &lh_lb, const wide_int &lh_ub,\n \t\t       const wide_int &rh_lb, const wide_int &rh_ub) const\n@@ -1002,14 +997,14 @@ operator_min::wi_fold (tree type,\n class operator_max : public range_operator\n {\n public:\n-  virtual value_range_base wi_fold (tree type,\n-\t\t\t\t    const wide_int &lh_lb,\n-\t\t\t\t    const wide_int &lh_ub,\n-\t\t\t\t    const wide_int &rh_lb,\n-\t\t\t\t    const wide_int &rh_ub) const;\n+  virtual value_range wi_fold (tree type,\n+\t\t\t       const wide_int &lh_lb,\n+\t\t\t       const wide_int &lh_ub,\n+\t\t\t       const wide_int &rh_lb,\n+\t\t\t       const wide_int &rh_ub) const;\n } op_max;\n \n-value_range_base\n+value_range\n operator_max::wi_fold (tree type,\n \t\t       const wide_int &lh_lb, const wide_int &lh_ub,\n \t\t       const wide_int &rh_lb, const wide_int &rh_ub) const\n@@ -1032,7 +1027,7 @@ class cross_product_operator : public range_operator\n \t\t\t\tconst wide_int &) const = 0;\n \n   // Calculate the cross product of two sets of sub-ranges and return it.\n-  value_range_base wi_cross_product (tree type,\n+  value_range wi_cross_product (tree type,\n \t\t\t\t     const wide_int &lh_lb,\n \t\t\t\t     const wide_int &lh_ub,\n \t\t\t\t     const wide_int &rh_lb,\n@@ -1052,7 +1047,7 @@ class cross_product_operator : public range_operator\n // MIN1, MIN0 OP MAX1, MAX0 OP MIN1 and MAX0 OP MAX0 OP MAX1) and then\n // figure the smallest and largest values to form the new range.\n \n-value_range_base\n+value_range\n cross_product_operator::wi_cross_product (tree type,\n \t\t\t\t\t  const wide_int &lh_lb,\n \t\t\t\t\t  const wide_int &lh_ub,\n@@ -1064,19 +1059,19 @@ cross_product_operator::wi_cross_product (tree type,\n   // Compute the 4 cross operations, bailing if we get an overflow we\n   // can't handle.\n   if (wi_op_overflows (cp1, type, lh_lb, rh_lb))\n-    return value_range_base (type);\n+    return value_range (type);\n   if (wi::eq_p (lh_lb, lh_ub))\n     cp3 = cp1;\n   else if (wi_op_overflows (cp3, type, lh_ub, rh_lb))\n-    return value_range_base (type);\n+    return value_range (type);\n   if (wi::eq_p (rh_lb, rh_ub))\n     cp2 = cp1;\n   else if (wi_op_overflows (cp2, type, lh_lb, rh_ub))\n-    return value_range_base (type);\n+    return value_range (type);\n   if (wi::eq_p (lh_lb, lh_ub))\n     cp4 = cp2;\n   else if (wi_op_overflows (cp4, type, lh_ub, rh_ub))\n-    return value_range_base (type);\n+    return value_range (type);\n \n   // Order pairs.\n   signop sign = TYPE_SIGN (type);\n@@ -1095,22 +1090,18 @@ cross_product_operator::wi_cross_product (tree type,\n class operator_mult : public cross_product_operator\n {\n public:\n-  virtual value_range_base wi_fold (tree type,\n-\t\t\t\t    const wide_int &lh_lb,\n-\t\t\t\t    const wide_int &lh_ub,\n-\t\t\t\t    const wide_int &rh_lb,\n-\t\t\t\t    const wide_int &rh_ub) const;\n-  virtual bool wi_op_overflows (wide_int &res,\n-\t\t\t\ttree type,\n-\t\t\t\tconst wide_int &w0,\n-\t\t\t\tconst wide_int &w1) const;\n+  virtual value_range wi_fold (tree type,\n+\t\t\t       const wide_int &lh_lb,\n+\t\t\t       const wide_int &lh_ub,\n+\t\t\t       const wide_int &rh_lb,\n+\t\t\t       const wide_int &rh_ub) const;\n+  virtual bool wi_op_overflows (wide_int &res, tree type,\n+\t\t\t\tconst wide_int &w0, const wide_int &w1) const;\n } op_mult;\n \n bool\n-operator_mult::wi_op_overflows (wide_int &res,\n-\t\t\t\ttree type,\n-\t\t\t\tconst wide_int &w0,\n-\t\t\t\tconst wide_int &w1) const\n+operator_mult::wi_op_overflows (wide_int &res, tree type,\n+\t\t\t\tconst wide_int &w0, const wide_int &w1) const\n {\n   wi::overflow_type overflow = wi::OVF_NONE;\n   signop sign = TYPE_SIGN (type);\n@@ -1128,7 +1119,7 @@ operator_mult::wi_op_overflows (wide_int &res,\n    return overflow;\n }\n \n-value_range_base\n+value_range\n operator_mult::wi_fold (tree type,\n \t\t\tconst wide_int &lh_lb, const wide_int &lh_ub,\n \t\t\tconst wide_int &rh_lb, const wide_int &rh_ub) const\n@@ -1195,7 +1186,7 @@ operator_mult::wi_fold (tree type,\n   prod2 = prod3 - prod0;\n   if (wi::geu_p (prod2, sizem1))\n     // The range covers all values.\n-    return value_range_base (type);\n+    return value_range (type);\n \n   wide_int new_lb = wide_int::from (prod0, prec, sign);\n   wide_int new_ub = wide_int::from (prod3, prec, sign);\n@@ -1207,24 +1198,20 @@ class operator_div : public cross_product_operator\n {\n public:\n   operator_div (enum tree_code c)  { code = c; }\n-  virtual value_range_base wi_fold (tree type,\n-\t\t\t\t    const wide_int &lh_lb,\n-\t\t\t\t    const wide_int &lh_ub,\n-\t\t\t\t    const wide_int &rh_lb,\n-\t\t\t\t    const wide_int &rh_ub) const;\n-  virtual bool wi_op_overflows (wide_int &res,\n-\t\t\t\ttree type,\n-\t\t\t\tconst wide_int &,\n-\t\t\t\tconst wide_int &) const;\n+  virtual value_range wi_fold (tree type,\n+\t\t\t       const wide_int &lh_lb,\n+\t\t\t       const wide_int &lh_ub,\n+\t\t\t       const wide_int &rh_lb,\n+\t\t\t       const wide_int &rh_ub) const;\n+  virtual bool wi_op_overflows (wide_int &res, tree type,\n+\t\t\t\tconst wide_int &, const wide_int &) const;\n private:\n   enum tree_code code;\n };\n \n bool\n-operator_div::wi_op_overflows (wide_int &res,\n-\t\t\t       tree type,\n-\t\t\t       const wide_int &w0,\n-\t\t\t       const wide_int &w1) const\n+operator_div::wi_op_overflows (wide_int &res, tree type,\n+\t\t\t       const wide_int &w0, const wide_int &w1) const\n {\n   if (w1 == 0)\n     return true;\n@@ -1264,14 +1251,14 @@ operator_div::wi_op_overflows (wide_int &res,\n   return overflow;\n }\n \n-value_range_base\n+value_range\n operator_div::wi_fold (tree type,\n \t\t       const wide_int &lh_lb, const wide_int &lh_ub,\n \t\t       const wide_int &rh_lb, const wide_int &rh_ub) const\n {\n   // If we know we will divide by zero, return undefined.\n   if (rh_lb == 0 && rh_ub == 0)\n-    return value_range_base ();\n+    return value_range ();\n \n   const wide_int dividend_min = lh_lb;\n   const wide_int dividend_max = lh_ub;\n@@ -1288,24 +1275,24 @@ operator_div::wi_fold (tree type,\n \n   // If flag_non_call_exceptions, we must not eliminate a division by zero.\n   if (cfun->can_throw_non_call_exceptions)\n-    return value_range_base (type);\n+    return value_range (type);\n \n   // If we're definitely dividing by zero, there's nothing to do.\n   if (wi_zero_p (type, divisor_min, divisor_max))\n-    return value_range_base ();\n+    return value_range ();\n \n   // Perform the division in 2 parts, [LB, -1] and [1, UB], which will\n   // skip any division by zero.\n \n   // First divide by the negative numbers, if any.\n-  value_range_base r;\n+  value_range r;\n   if (wi::neg_p (divisor_min, sign))\n     r = wi_cross_product (type, dividend_min, dividend_max,\n \t\t\t  divisor_min, wi::minus_one (prec));\n   // Then divide by the non-zero positive numbers, if any.\n   if (wi::gt_p (divisor_max, wi::zero (prec), sign))\n     {\n-      value_range_base tmp;\n+      value_range tmp;\n       tmp = wi_cross_product (type, dividend_min, dividend_max,\n \t\t\t      wi::one (prec), divisor_max);\n       r.union_ (tmp);\n@@ -1323,16 +1310,16 @@ class operator_exact_divide : public operator_div\n {\n public:\n   operator_exact_divide () : operator_div (TRUNC_DIV_EXPR) { }\n-  virtual bool op1_range (value_range_base &r, tree type,\n-\t\t\t  const value_range_base &lhs,\n-\t\t\t  const value_range_base &op2) const;\n+  virtual bool op1_range (value_range &r, tree type,\n+\t\t\t  const value_range &lhs,\n+\t\t\t  const value_range &op2) const;\n \n } op_exact_div;\n \n bool\n-operator_exact_divide::op1_range (value_range_base &r, tree type,\n-\t\t\t\t  const value_range_base &lhs,\n-\t\t\t\t  const value_range_base &op2) const\n+operator_exact_divide::op1_range (value_range &r, tree type,\n+\t\t\t\t  const value_range &lhs,\n+\t\t\t\t  const value_range &op2) const\n {\n   tree offset;\n   // [2, 4] = op1 / [3,3]   since its exact divide, no need to worry about\n@@ -1354,11 +1341,11 @@ operator_exact_divide::op1_range (value_range_base &r, tree type,\n class operator_lshift : public cross_product_operator\n {\n public:\n-  virtual value_range_base fold_range (tree type,\n-\t\t\t\t       const value_range_base &op1,\n-\t\t\t\t       const value_range_base &op2) const;\n+  virtual value_range fold_range (tree type,\n+\t\t\t\t  const value_range &op1,\n+\t\t\t\t  const value_range &op2) const;\n \n-  virtual value_range_base wi_fold (tree type,\n+  virtual value_range wi_fold (tree type,\n \t\t\t  const wide_int &lh_lb, const wide_int &lh_ub,\n \t\t\t  const wide_int &rh_lb, const wide_int &rh_ub) const;\n   virtual bool wi_op_overflows (wide_int &res,\n@@ -1367,12 +1354,12 @@ class operator_lshift : public cross_product_operator\n \t\t\t\tconst wide_int &) const;\n } op_lshift;\n \n-value_range_base\n+value_range\n operator_lshift::fold_range (tree type,\n-\t\t\t     const value_range_base &op1,\n-\t\t\t     const value_range_base &op2) const\n+\t\t\t     const value_range &op1,\n+\t\t\t     const value_range &op2) const\n {\n-  value_range_base r;\n+  value_range r;\n   if (undefined_shift_range_check (r, type, op2))\n     return r;\n \n@@ -1381,7 +1368,7 @@ operator_lshift::fold_range (tree type,\n     {\n       unsigned shift = op2.lower_bound ().to_uhwi ();\n       wide_int tmp = wi::set_bit_in_zero (shift, TYPE_PRECISION (type));\n-      value_range_base mult (type, tmp, tmp);\n+      value_range mult (type, tmp, tmp);\n \n       // Force wrapping multiplication.\n       bool saved_flag_wrapv = flag_wrapv;\n@@ -1398,7 +1385,7 @@ operator_lshift::fold_range (tree type,\n   return range_operator::fold_range (type, op1, op2);\n }\n \n-value_range_base\n+value_range\n operator_lshift::wi_fold (tree type,\n \t\t\t  const wide_int &lh_lb, const wide_int &lh_ub,\n \t\t\t  const wide_int &rh_lb, const wide_int &rh_ub) const\n@@ -1455,14 +1442,12 @@ operator_lshift::wi_fold (tree type,\n   if (in_bounds)\n     return wi_cross_product (type, lh_lb, lh_ub, rh_lb, rh_ub);\n \n-  return value_range_base (type);\n+  return value_range (type);\n }\n \n bool\n-operator_lshift::wi_op_overflows (wide_int &res,\n-\t\t\t\t  tree type,\n-\t\t\t\t  const wide_int &w0,\n-\t\t\t\t  const wide_int &w1) const\n+operator_lshift::wi_op_overflows (wide_int &res, tree type,\n+\t\t\t\t  const wide_int &w0, const wide_int &w1) const\n {\n   signop sign = TYPE_SIGN (type);\n   if (wi::neg_p (w1))\n@@ -1481,12 +1466,14 @@ operator_lshift::wi_op_overflows (wide_int &res,\n class operator_rshift : public cross_product_operator\n {\n public:\n-  virtual value_range_base fold_range (tree type,\n-\t\t\t\t       const value_range_base &op1,\n-\t\t\t\t       const value_range_base &op2) const;\n-  virtual value_range_base wi_fold (tree type,\n-\t\t\t  const wide_int &lh_lb, const wide_int &lh_ub,\n-\t\t\t  const wide_int &rh_lb, const wide_int &rh_ub) const;\n+  virtual value_range fold_range (tree type,\n+\t\t\t\t  const value_range &op1,\n+\t\t\t\t  const value_range &op2) const;\n+  virtual value_range wi_fold (tree type,\n+\t\t\t       const wide_int &lh_lb,\n+\t\t\t       const wide_int &lh_ub,\n+\t\t\t       const wide_int &rh_lb,\n+\t\t\t       const wide_int &rh_ub) const;\n   virtual bool wi_op_overflows (wide_int &res,\n \t\t\t\ttree type,\n \t\t\t\tconst wide_int &w0,\n@@ -1512,20 +1499,20 @@ operator_rshift::wi_op_overflows (wide_int &res,\n   return false;\n }\n \n-value_range_base\n+value_range\n operator_rshift::fold_range (tree type,\n-\t\t\t     const value_range_base &op1,\n-\t\t\t     const value_range_base &op2) const\n+\t\t\t     const value_range &op1,\n+\t\t\t     const value_range &op2) const\n {\n-  value_range_base r;\n+  value_range r;\n   if (undefined_shift_range_check (r, type, op2))\n     return r;\n \n   // Otherwise, invoke the generic fold routine.\n   return range_operator::fold_range (type, op1, op2);\n }\n \n-value_range_base\n+value_range\n operator_rshift::wi_fold (tree type,\n \t\t\t  const wide_int &lh_lb, const wide_int &lh_ub,\n \t\t\t  const wide_int &rh_lb, const wide_int &rh_ub) const\n@@ -1537,21 +1524,21 @@ operator_rshift::wi_fold (tree type,\n class operator_cast: public range_operator\n {\n public:\n-  virtual value_range_base fold_range (tree type,\n-\t\t\t\t       const value_range_base &op1,\n-\t\t\t\t       const value_range_base &op2) const;\n-  virtual bool op1_range (value_range_base &r, tree type,\n-\t\t\t  const value_range_base &lhs,\n-\t\t\t  const value_range_base &op2) const;\n+  virtual value_range fold_range (tree type,\n+\t\t\t\t  const value_range &op1,\n+\t\t\t\t  const value_range &op2) const;\n+  virtual bool op1_range (value_range &r, tree type,\n+\t\t\t  const value_range &lhs,\n+\t\t\t  const value_range &op2) const;\n \n } op_convert;\n \n-value_range_base\n+value_range\n operator_cast::fold_range (tree type ATTRIBUTE_UNUSED,\n-\t\t\t   const value_range_base &lh,\n-\t\t\t   const value_range_base &rh) const\n+\t\t\t   const value_range &lh,\n+\t\t\t   const value_range &rh) const\n {\n-  value_range_base r;\n+  value_range r;\n   if (empty_range_check (r, lh, rh))\n     return r;\n \n@@ -1584,21 +1571,21 @@ operator_cast::fold_range (tree type ATTRIBUTE_UNUSED,\n \t  if (!wi::eq_p (min, wi::min_value (outer_prec, outer_sign))\n \t      || !wi::eq_p (max, wi::max_value (outer_prec, outer_sign)))\n \t    {\n-\t      value_range_base tmp;\n+\t      value_range tmp;\n \t      tmp = create_possibly_reversed_range (type, min, max);\n \t      r.union_ (tmp);\n \t      continue;\n \t    }\n \t}\n-      return value_range_base (type);\n+      return value_range (type);\n     }\n   return r;\n }\n \n bool\n-operator_cast::op1_range (value_range_base &r, tree type,\n-\t\t\t  const value_range_base &lhs,\n-\t\t\t  const value_range_base &op2) const\n+operator_cast::op1_range (value_range &r, tree type,\n+\t\t\t  const value_range &lhs,\n+\t\t\t  const value_range &op2) const\n {\n   tree lhs_type = lhs.type ();\n   gcc_checking_assert (types_compatible_p (op2.type(), type));\n@@ -1612,14 +1599,14 @@ operator_cast::op1_range (value_range_base &r, tree type,\n       // the type, see if it fits the LHS, and if so, then we can allow\n       // it.\n       r = op2;\n-      r = fold_range (lhs_type, r, value_range_base (lhs_type));\n-      r = fold_range (type, r, value_range_base (type));\n+      r = fold_range (lhs_type, r, value_range (lhs_type));\n+      r = fold_range (type, r, value_range (type));\n       if (r == op2)\n         {\n \t  // We know the value of the RHS fits in the LHS type, so\n \t  // convert the LHS and remove any values that arent in OP2.\n \t  r = lhs;\n-\t  r = fold_range (type, r, value_range_base (type));\n+\t  r = fold_range (type, r, value_range (type));\n \t  r.intersect (op2);\n \t  return true;\n \t}\n@@ -1639,11 +1626,11 @@ operator_cast::op1_range (value_range_base &r, tree type,\n \t  // *not* in the RHS is 0 or -1.\n \t  unsigned prec = TYPE_PRECISION (type);\n \t  if (lhs.zero_p ())\n-\t    r = value_range_base (VR_ANTI_RANGE, type,\n-\t\t\twi::minus_one (prec), wi::minus_one (prec));\n+\t    r = value_range (VR_ANTI_RANGE, type,\n+\t\t\t     wi::minus_one (prec), wi::minus_one (prec));\n \t  else\n-\t    r = value_range_base (VR_ANTI_RANGE, type,\n-\t\t\twi::zero (prec), wi::zero (prec));\n+\t    r = value_range (VR_ANTI_RANGE, type,\n+\t\t\t     wi::zero (prec), wi::zero (prec));\n \t  // And intersect it with what we know about op2.\n \t  r.intersect (op2);\n \t}\n@@ -1659,8 +1646,8 @@ operator_cast::op1_range (value_range_base &r, tree type,\n   if (TYPE_PRECISION (lhs_type) > TYPE_PRECISION (type))\n     {\n       // Cast the range of the RHS to the type of the LHS.\n-      value_range_base op_type (type);\n-      op_type = fold_range (lhs_type, op_type, value_range_base (lhs_type));\n+      value_range op_type (type);\n+      op_type = fold_range (lhs_type, op_type, value_range (lhs_type));\n \n       // Intersect this with the LHS range will produce the RHS range.\n       r = range_intersect (lhs, op_type);\n@@ -1669,32 +1656,32 @@ operator_cast::op1_range (value_range_base &r, tree type,\n     r = lhs;\n \n   // Cast the calculated range to the type of the RHS.\n-  r = fold_range (type, r, value_range_base (type));\n+  r = fold_range (type, r, value_range (type));\n   return true;\n }\n \n \n class operator_logical_and : public range_operator\n {\n public:\n-  virtual value_range_base fold_range (tree type,\n-\t\t\t\t       const value_range_base &lh,\n-\t\t\t\t       const value_range_base &rh) const;\n-  virtual bool op1_range (value_range_base &r, tree type,\n-\t\t\t  const value_range_base &lhs,\n-\t\t\t  const value_range_base &op2) const;\n-  virtual bool op2_range (value_range_base &r, tree type,\n-\t\t\t  const value_range_base &lhs,\n-\t\t\t  const value_range_base &op1) const;\n+  virtual value_range fold_range (tree type,\n+\t\t\t\t  const value_range &lh,\n+\t\t\t\t  const value_range &rh) const;\n+  virtual bool op1_range (value_range &r, tree type,\n+\t\t\t  const value_range &lhs,\n+\t\t\t  const value_range &op2) const;\n+  virtual bool op2_range (value_range &r, tree type,\n+\t\t\t  const value_range &lhs,\n+\t\t\t  const value_range &op1) const;\n } op_logical_and;\n \n \n-value_range_base\n+value_range\n operator_logical_and::fold_range (tree type,\n-\t\t\t\t  const value_range_base &lh,\n-\t\t\t\t  const value_range_base &rh) const\n+\t\t\t\t  const value_range &lh,\n+\t\t\t\t  const value_range &rh) const\n {\n-  value_range_base r;\n+  value_range r;\n   if (empty_range_check (r, lh, rh))\n     return r;\n \n@@ -1713,9 +1700,9 @@ operator_logical_and::fold_range (tree type,\n }\n \n bool\n-operator_logical_and::op1_range (value_range_base &r, tree type,\n-\t\t\t\t const value_range_base &lhs,\n-\t\t\t\t const value_range_base &op2 ATTRIBUTE_UNUSED) const\n+operator_logical_and::op1_range (value_range &r, tree type,\n+\t\t\t\t const value_range &lhs,\n+\t\t\t\t const value_range &op2 ATTRIBUTE_UNUSED) const\n {\n    switch (get_bool_state (r, lhs, type))\n      {\n@@ -1734,9 +1721,9 @@ operator_logical_and::op1_range (value_range_base &r, tree type,\n }\n \n bool\n-operator_logical_and::op2_range (value_range_base &r, tree type,\n-\t\t\t\t const value_range_base &lhs,\n-\t\t\t\t const value_range_base &op1) const\n+operator_logical_and::op2_range (value_range &r, tree type,\n+\t\t\t\t const value_range &lhs,\n+\t\t\t\t const value_range &op1) const\n {\n   return operator_logical_and::op1_range (r, type, lhs, op1);\n }\n@@ -1745,17 +1732,17 @@ operator_logical_and::op2_range (value_range_base &r, tree type,\n class operator_bitwise_and : public range_operator\n {\n public:\n-  virtual bool op1_range (value_range_base &r, tree type,\n-\t\t\t  const value_range_base &lhs,\n-\t\t\t  const value_range_base &op2) const;\n-  virtual bool op2_range (value_range_base &r, tree type,\n-\t\t\t  const value_range_base &lhs,\n-\t\t\t  const value_range_base &op1) const;\n-  virtual value_range_base wi_fold (tree type,\n-\t\t\t\t    const wide_int &lh_lb,\n-\t\t\t\t    const wide_int &lh_ub,\n-\t\t\t\t    const wide_int &rh_lb,\n-\t\t\t\t    const wide_int &rh_ub) const;\n+  virtual bool op1_range (value_range &r, tree type,\n+\t\t\t  const value_range &lhs,\n+\t\t\t  const value_range &op2) const;\n+  virtual bool op2_range (value_range &r, tree type,\n+\t\t\t  const value_range &lhs,\n+\t\t\t  const value_range &op1) const;\n+  virtual value_range wi_fold (tree type,\n+\t\t\t       const wide_int &lh_lb,\n+\t\t\t       const wide_int &lh_ub,\n+\t\t\t       const wide_int &rh_lb,\n+\t\t\t       const wide_int &rh_ub) const;\n } op_bitwise_and;\n \n // Optimize BIT_AND_EXPR and BIT_IOR_EXPR in terms of a mask if\n@@ -1769,7 +1756,7 @@ class operator_bitwise_and : public range_operator\n // return TRUE.\n \n static bool\n-wi_optimize_and_or (value_range_base &r,\n+wi_optimize_and_or (value_range &r,\n \t\t    enum tree_code code,\n \t\t    tree type,\n \t\t    const wide_int &lh_lb, const wide_int &lh_ub,\n@@ -1877,14 +1864,14 @@ wi_set_zero_nonzero_bits (tree type,\n     }\n }\n \n-value_range_base\n+value_range\n operator_bitwise_and::wi_fold (tree type,\n \t\t\t       const wide_int &lh_lb,\n \t\t\t       const wide_int &lh_ub,\n \t\t\t       const wide_int &rh_lb,\n \t\t\t       const wide_int &rh_ub) const\n {\n-  value_range_base r;\n+  value_range r;\n   if (wi_optimize_and_or (r, BIT_AND_EXPR, type, lh_lb, lh_ub, rh_lb, rh_ub))\n     return r;\n \n@@ -1931,15 +1918,15 @@ operator_bitwise_and::wi_fold (tree type,\n     }\n   // If the limits got swapped around, return varying.\n   if (wi::gt_p (new_lb, new_ub,sign))\n-    return value_range_base (type);\n+    return value_range (type);\n \n   return value_range_with_overflow (type, new_lb, new_ub);\n }\n \n bool\n-operator_bitwise_and::op1_range (value_range_base &r, tree type,\n-\t\t\t\t const value_range_base &lhs,\n-\t\t\t\t const value_range_base &op2) const\n+operator_bitwise_and::op1_range (value_range &r, tree type,\n+\t\t\t\t const value_range &lhs,\n+\t\t\t\t const value_range &op2) const\n {\n   // If this is really a logical wi_fold, call that.\n   if (types_compatible_p (type, boolean_type_node))\n@@ -1951,9 +1938,9 @@ operator_bitwise_and::op1_range (value_range_base &r, tree type,\n }\n \n bool\n-operator_bitwise_and::op2_range (value_range_base &r, tree type,\n-\t\t\t\t const value_range_base &lhs,\n-\t\t\t\t const value_range_base &op1) const\n+operator_bitwise_and::op2_range (value_range &r, tree type,\n+\t\t\t\t const value_range &lhs,\n+\t\t\t\t const value_range &op1) const\n {\n   return operator_bitwise_and::op1_range (r, type, lhs, op1);\n }\n@@ -1962,33 +1949,33 @@ operator_bitwise_and::op2_range (value_range_base &r, tree type,\n class operator_logical_or : public range_operator\n {\n public:\n-  virtual value_range_base fold_range (tree type,\n-\t\t\t\t       const value_range_base &lh,\n-\t\t\t\t       const value_range_base &rh) const;\n-  virtual bool op1_range (value_range_base &r, tree type,\n-\t\t\t  const value_range_base &lhs,\n-\t\t\t  const value_range_base &op2) const;\n-  virtual bool op2_range (value_range_base &r, tree type,\n-\t\t\t  const value_range_base &lhs,\n-\t\t\t  const value_range_base &op1) const;\n+  virtual value_range fold_range (tree type,\n+\t\t\t\t  const value_range &lh,\n+\t\t\t\t  const value_range &rh) const;\n+  virtual bool op1_range (value_range &r, tree type,\n+\t\t\t  const value_range &lhs,\n+\t\t\t  const value_range &op2) const;\n+  virtual bool op2_range (value_range &r, tree type,\n+\t\t\t  const value_range &lhs,\n+\t\t\t  const value_range &op1) const;\n } op_logical_or;\n \n-value_range_base\n+value_range\n operator_logical_or::fold_range (tree type ATTRIBUTE_UNUSED,\n-\t\t\t\t const value_range_base &lh,\n-\t\t\t\t const value_range_base &rh) const\n+\t\t\t\t const value_range &lh,\n+\t\t\t\t const value_range &rh) const\n {\n-  value_range_base r;\n+  value_range r;\n   if (empty_range_check (r, lh, rh))\n     return r;\n \n   return range_union (lh, rh);\n }\n \n bool\n-operator_logical_or::op1_range (value_range_base &r, tree type,\n-\t\t\t\tconst value_range_base &lhs,\n-\t\t\t\tconst value_range_base &op2 ATTRIBUTE_UNUSED) const\n+operator_logical_or::op1_range (value_range &r, tree type,\n+\t\t\t\tconst value_range &lhs,\n+\t\t\t\tconst value_range &op2 ATTRIBUTE_UNUSED) const\n {\n    switch (get_bool_state (r, lhs, type))\n      {\n@@ -2007,9 +1994,9 @@ operator_logical_or::op1_range (value_range_base &r, tree type,\n }\n \n bool\n-operator_logical_or::op2_range (value_range_base &r, tree type,\n-\t\t\t\tconst value_range_base &lhs,\n-\t\t\t\tconst value_range_base &op1) const\n+operator_logical_or::op2_range (value_range &r, tree type,\n+\t\t\t\tconst value_range &lhs,\n+\t\t\t\tconst value_range &op1) const\n {\n   return operator_logical_or::op1_range (r, type, lhs, op1);\n }\n@@ -2018,27 +2005,27 @@ operator_logical_or::op2_range (value_range_base &r, tree type,\n class operator_bitwise_or : public range_operator\n {\n public:\n-  virtual bool op1_range (value_range_base &r, tree type,\n-\t\t\t  const value_range_base &lhs,\n-\t\t\t  const value_range_base &op2) const;\n-  virtual bool op2_range (value_range_base &r, tree type,\n-\t\t\t  const value_range_base &lhs,\n-\t\t\t  const value_range_base &op1) const;\n-  virtual value_range_base wi_fold (tree type,\n-\t\t\t\t    const wide_int &lh_lb,\n-\t\t\t\t    const wide_int &lh_ub,\n-\t\t\t\t    const wide_int &rh_lb,\n-\t\t\t\t    const wide_int &rh_ub) const;\n+  virtual bool op1_range (value_range &r, tree type,\n+\t\t\t  const value_range &lhs,\n+\t\t\t  const value_range &op2) const;\n+  virtual bool op2_range (value_range &r, tree type,\n+\t\t\t  const value_range &lhs,\n+\t\t\t  const value_range &op1) const;\n+  virtual value_range wi_fold (tree type,\n+\t\t\t       const wide_int &lh_lb,\n+\t\t\t       const wide_int &lh_ub,\n+\t\t\t       const wide_int &rh_lb,\n+\t\t\t       const wide_int &rh_ub) const;\n } op_bitwise_or;\n \n-value_range_base\n+value_range\n operator_bitwise_or::wi_fold (tree type,\n \t\t\t      const wide_int &lh_lb,\n \t\t\t      const wide_int &lh_ub,\n \t\t\t      const wide_int &rh_lb,\n \t\t\t      const wide_int &rh_ub) const\n {\n-  value_range_base r;\n+  value_range r;\n   if (wi_optimize_and_or (r, BIT_IOR_EXPR, type, lh_lb, lh_ub, rh_lb, rh_ub))\n     return r;\n \n@@ -2069,15 +2056,15 @@ operator_bitwise_or::wi_fold (tree type,\n     new_lb = wi::max (new_lb, rh_lb, sign);\n   // If the limits got swapped around, return varying.\n   if (wi::gt_p (new_lb, new_ub,sign))\n-    return value_range_base (type);\n+    return value_range (type);\n \n   return value_range_with_overflow (type, new_lb, new_ub);\n }\n \n bool\n-operator_bitwise_or::op1_range (value_range_base &r, tree type,\n-\t\t\t\tconst value_range_base &lhs,\n-\t\t\t\tconst value_range_base &op2) const\n+operator_bitwise_or::op1_range (value_range &r, tree type,\n+\t\t\t\tconst value_range &lhs,\n+\t\t\t\tconst value_range &op2) const\n {\n   // If this is really a logical wi_fold, call that.\n   if (types_compatible_p (type, boolean_type_node))\n@@ -2089,9 +2076,9 @@ operator_bitwise_or::op1_range (value_range_base &r, tree type,\n }\n \n bool\n-operator_bitwise_or::op2_range (value_range_base &r, tree type,\n-\t\t\t\tconst value_range_base &lhs,\n-\t\t\t\tconst value_range_base &op1) const\n+operator_bitwise_or::op2_range (value_range &r, tree type,\n+\t\t\t\tconst value_range &lhs,\n+\t\t\t\tconst value_range &op1) const\n {\n   return operator_bitwise_or::op1_range (r, type, lhs, op1);\n }\n@@ -2100,14 +2087,14 @@ operator_bitwise_or::op2_range (value_range_base &r, tree type,\n class operator_bitwise_xor : public range_operator\n {\n public:\n-  virtual value_range_base wi_fold (tree type,\n-\t\t\t\t    const wide_int &lh_lb,\n-\t\t\t\t    const wide_int &lh_ub,\n-\t\t\t\t    const wide_int &rh_lb,\n-\t\t\t\t    const wide_int &rh_ub) const;\n+  virtual value_range wi_fold (tree type,\n+\t\t\t       const wide_int &lh_lb,\n+\t\t\t       const wide_int &lh_ub,\n+\t\t\t       const wide_int &rh_lb,\n+\t\t\t       const wide_int &rh_ub) const;\n } op_bitwise_xor;\n \n-value_range_base\n+value_range\n operator_bitwise_xor::wi_fold (tree type,\n \t\t\t       const wide_int &lh_lb,\n \t\t\t       const wide_int &lh_ub,\n@@ -2135,21 +2122,21 @@ operator_bitwise_xor::wi_fold (tree type,\n   if (wi::lt_p (new_lb, 0, sign) || wi::ge_p (new_ub, 0, sign))\n     return value_range_with_overflow (type, new_lb, new_ub);\n \n-  return value_range_base (type);\n+  return value_range (type);\n }\n \n \n class operator_trunc_mod : public range_operator\n {\n public:\n-  virtual value_range_base wi_fold (tree type,\n-\t\t\t\t    const wide_int &lh_lb,\n-\t\t\t\t    const wide_int &lh_ub,\n-\t\t\t\t    const wide_int &rh_lb,\n-\t\t\t\t    const wide_int &rh_ub) const;\n+  virtual value_range wi_fold (tree type,\n+\t\t\t       const wide_int &lh_lb,\n+\t\t\t       const wide_int &lh_ub,\n+\t\t\t       const wide_int &rh_lb,\n+\t\t\t       const wide_int &rh_ub) const;\n } op_trunc_mod;\n \n-value_range_base\n+value_range\n operator_trunc_mod::wi_fold (tree type,\n \t\t\t     const wide_int &lh_lb,\n \t\t\t     const wide_int &lh_ub,\n@@ -2162,7 +2149,7 @@ operator_trunc_mod::wi_fold (tree type,\n \n   // Mod 0 is undefined.  Return undefined.\n   if (wi_zero_p (type, rh_lb, rh_ub))\n-    return value_range_base ();\n+    return value_range ();\n \n   // ABS (A % B) < ABS (B) and either 0 <= A % B <= A or A <= A % B <= 0.\n   new_ub = rh_ub - 1;\n@@ -2194,12 +2181,12 @@ operator_trunc_mod::wi_fold (tree type,\n class operator_logical_not : public range_operator\n {\n public:\n-  virtual value_range_base fold_range (tree type,\n-\t\t\t\t       const value_range_base &lh,\n-\t\t\t\t       const value_range_base &rh) const;\n-  virtual bool op1_range (value_range_base &r, tree type,\n-\t\t\t  const value_range_base &lhs,\n-\t\t\t  const value_range_base &op2) const;\n+  virtual value_range fold_range (tree type,\n+\t\t\t\t  const value_range &lh,\n+\t\t\t\t  const value_range &rh) const;\n+  virtual bool op1_range (value_range &r, tree type,\n+\t\t\t  const value_range &lhs,\n+\t\t\t  const value_range &op2) const;\n } op_logical_not;\n \n // Folding a logical NOT, oddly enough, involves doing nothing on the\n@@ -2216,12 +2203,12 @@ class operator_logical_not : public range_operator\n // \t b_2 = x_1 < 20\t\t[0,0] = x_1 < 20,   false, so x_1 == [20, 255]\n //   which is the result we are looking for.. so.. pass it through.\n \n-value_range_base\n+value_range\n operator_logical_not::fold_range (tree type,\n-\t\t\t\t  const value_range_base &lh,\n-\t\t\t\t  const value_range_base &rh ATTRIBUTE_UNUSED) const\n+\t\t\t\t  const value_range &lh,\n+\t\t\t\t  const value_range &rh ATTRIBUTE_UNUSED) const\n {\n-  value_range_base r;\n+  value_range r;\n   if (empty_range_check (r, lh, rh))\n     return r;\n \n@@ -2234,10 +2221,10 @@ operator_logical_not::fold_range (tree type,\n }\n \n bool\n-operator_logical_not::op1_range (value_range_base &r,\n+operator_logical_not::op1_range (value_range &r,\n \t\t\t\t tree type ATTRIBUTE_UNUSED,\n-\t\t\t\t const value_range_base &lhs,\n-\t\t\t\t const value_range_base &op2 ATTRIBUTE_UNUSED) const\n+\t\t\t\t const value_range &lhs,\n+\t\t\t\t const value_range &op2 ATTRIBUTE_UNUSED) const\n {\n   if (lhs.varying_p () || lhs.undefined_p ())\n     r = lhs;\n@@ -2250,35 +2237,34 @@ operator_logical_not::op1_range (value_range_base &r,\n class operator_bitwise_not : public range_operator\n {\n public:\n-  virtual value_range_base fold_range (tree type,\n-\t\t\t\t       const value_range_base &lh,\n-\t\t\t\t       const value_range_base &rh) const;\n-  virtual bool op1_range (value_range_base &r, tree type,\n-\t\t\t  const value_range_base &lhs,\n-\t\t\t  const value_range_base &op2) const;\n+  virtual value_range fold_range (tree type,\n+\t\t\t\t  const value_range &lh,\n+\t\t\t\t  const value_range &rh) const;\n+  virtual bool op1_range (value_range &r, tree type,\n+\t\t\t  const value_range &lhs,\n+\t\t\t  const value_range &op2) const;\n } op_bitwise_not;\n \n-value_range_base\n+value_range\n operator_bitwise_not::fold_range (tree type,\n-\t\t\t\t  const value_range_base &lh,\n-\t\t\t\t  const value_range_base &rh) const\n+\t\t\t\t  const value_range &lh,\n+\t\t\t\t  const value_range &rh) const\n {\n-  value_range_base r;\n+  value_range r;\n   if (empty_range_check (r, lh, rh))\n     return r;\n \n   // ~X is simply -1 - X.\n-  value_range_base minusone (type,\n-\t\t   wi::minus_one (TYPE_PRECISION (type)),\n-\t\t   wi::minus_one (TYPE_PRECISION (type)));\n+  value_range minusone (type, wi::minus_one (TYPE_PRECISION (type)),\n+\t\t\twi::minus_one (TYPE_PRECISION (type)));\n   r = range_op_handler (MINUS_EXPR, type)->fold_range (type, minusone, lh);\n   return r;\n }\n \n bool\n-operator_bitwise_not::op1_range (value_range_base &r, tree type,\n-\t\t\t\t const value_range_base &lhs,\n-\t\t\t\t const value_range_base &op2) const\n+operator_bitwise_not::op1_range (value_range &r, tree type,\n+\t\t\t\t const value_range &lhs,\n+\t\t\t\t const value_range &op2) const\n {\n   // ~X is -1 - X and since bitwise NOT is involutary...do it again.\n   r = fold_range (type, lhs, op2);\n@@ -2289,15 +2275,15 @@ operator_bitwise_not::op1_range (value_range_base &r, tree type,\n class operator_cst : public range_operator\n {\n public:\n-  virtual value_range_base fold_range (tree type,\n-\t\t\t\t       const value_range_base &op1,\n-\t\t\t\t       const value_range_base &op2) const;\n+  virtual value_range fold_range (tree type,\n+\t\t\t\t  const value_range &op1,\n+\t\t\t\t  const value_range &op2) const;\n } op_integer_cst;\n \n-value_range_base\n+value_range\n operator_cst::fold_range (tree type ATTRIBUTE_UNUSED,\n-\t\t\t  const value_range_base &lh,\n-\t\t\t  const value_range_base &rh ATTRIBUTE_UNUSED) const\n+\t\t\t  const value_range &lh,\n+\t\t\t  const value_range &rh ATTRIBUTE_UNUSED) const\n {\n   return lh;\n }\n@@ -2306,26 +2292,26 @@ operator_cst::fold_range (tree type ATTRIBUTE_UNUSED,\n class operator_identity : public range_operator\n {\n public:\n-  virtual value_range_base fold_range (tree type,\n-\t\t\t\t       const value_range_base &op1,\n-\t\t\t\t       const value_range_base &op2) const;\n-  virtual bool op1_range (value_range_base &r, tree type,\n-\t\t\t  const value_range_base &lhs,\n-\t\t\t  const value_range_base &op2) const;\n+  virtual value_range fold_range (tree type,\n+\t\t\t\t  const value_range &op1,\n+\t\t\t\t  const value_range &op2) const;\n+  virtual bool op1_range (value_range &r, tree type,\n+\t\t\t  const value_range &lhs,\n+\t\t\t  const value_range &op2) const;\n } op_identity;\n \n-value_range_base\n+value_range\n operator_identity::fold_range (tree type ATTRIBUTE_UNUSED,\n-\t\t\t       const value_range_base &lh,\n-\t\t\t       const value_range_base &rh ATTRIBUTE_UNUSED) const\n+\t\t\t       const value_range &lh,\n+\t\t\t       const value_range &rh ATTRIBUTE_UNUSED) const\n {\n   return lh;\n }\n \n bool\n-operator_identity::op1_range (value_range_base &r, tree type ATTRIBUTE_UNUSED,\n-\t\t\t      const value_range_base &lhs,\n-\t\t\t      const value_range_base &op2 ATTRIBUTE_UNUSED) const\n+operator_identity::op1_range (value_range &r, tree type ATTRIBUTE_UNUSED,\n+\t\t\t      const value_range &lhs,\n+\t\t\t      const value_range &op2 ATTRIBUTE_UNUSED) const\n {\n   r = lhs;\n   return true;\n@@ -2335,17 +2321,17 @@ operator_identity::op1_range (value_range_base &r, tree type ATTRIBUTE_UNUSED,\n class operator_abs : public range_operator\n {\n  public:\n-  virtual value_range_base wi_fold (tree type,\n-\t\t\t\t    const wide_int &lh_lb,\n-\t\t\t\t    const wide_int &lh_ub,\n-\t\t\t\t    const wide_int &rh_lb,\n-\t\t\t\t    const wide_int &rh_ub) const;\n-  virtual bool op1_range (value_range_base &r, tree type,\n-\t\t\t  const value_range_base &lhs,\n-\t\t\t  const value_range_base &op2) const;\n+  virtual value_range wi_fold (tree type,\n+\t\t\t       const wide_int &lh_lb,\n+\t\t\t       const wide_int &lh_ub,\n+\t\t\t       const wide_int &rh_lb,\n+\t\t\t       const wide_int &rh_ub) const;\n+  virtual bool op1_range (value_range &r, tree type,\n+\t\t\t  const value_range &lhs,\n+\t\t\t  const value_range &op2) const;\n } op_abs;\n \n-value_range_base\n+value_range\n operator_abs::wi_fold (tree type,\n \t\t       const wide_int &lh_lb, const wide_int &lh_ub,\n \t\t       const wide_int &rh_lb ATTRIBUTE_UNUSED,\n@@ -2357,14 +2343,14 @@ operator_abs::wi_fold (tree type,\n \n   // Pass through LH for the easy cases.\n   if (sign == UNSIGNED || wi::ge_p (lh_lb, 0, sign))\n-    return value_range_base (type, lh_lb, lh_ub);\n+    return value_range (type, lh_lb, lh_ub);\n \n   // -TYPE_MIN_VALUE = TYPE_MIN_VALUE with flag_wrapv so we can't get\n   // a useful range.\n   wide_int min_value = wi::min_value (prec, sign);\n   wide_int max_value = wi::max_value (prec, sign);\n   if (!TYPE_OVERFLOW_UNDEFINED (type) && wi::eq_p (lh_lb, min_value))\n-    return value_range_base (type);\n+    return value_range (type);\n \n   // ABS_EXPR may flip the range around, if the original range\n   // included negative values.\n@@ -2400,13 +2386,13 @@ operator_abs::wi_fold (tree type,\n       min = wi::zero (prec);\n       max = max_value;\n     }\n-  return value_range_base (type, min, max);\n+  return value_range (type, min, max);\n }\n \n bool\n-operator_abs::op1_range (value_range_base &r, tree type,\n-\t\t\t const value_range_base &lhs,\n-\t\t\t const value_range_base &op2) const\n+operator_abs::op1_range (value_range &r, tree type,\n+\t\t\t const value_range &lhs,\n+\t\t\t const value_range &op2) const\n {\n   if (empty_range_check (r, lhs, op2))\n     return true;\n@@ -2416,28 +2402,28 @@ operator_abs::op1_range (value_range_base &r, tree type,\n       return true;\n     }\n   // Start with the positives because negatives are an impossible result.\n-  value_range_base positives = range_positives (type);\n+  value_range positives = range_positives (type);\n   positives.intersect (lhs);\n   r = positives;\n   // Then add the negative of each pair:\n   // ABS(op1) = [5,20] would yield op1 => [-20,-5][5,20].\n   for (unsigned i = 0; i < positives.num_pairs (); ++i)\n-    r.union_ (value_range_base (type,\n-\t\t      -positives.upper_bound (i),\n-\t\t      -positives.lower_bound (i)));\n+    r.union_ (value_range (type,\n+\t\t\t   -positives.upper_bound (i),\n+\t\t\t   -positives.lower_bound (i)));\n   return true;\n }\n \n \n class operator_absu : public range_operator\n {\n  public:\n-  virtual value_range_base wi_fold (tree type,\n+  virtual value_range wi_fold (tree type,\n \t\t\t  const wide_int &lh_lb, const wide_int &lh_ub,\n \t\t\t  const wide_int &rh_lb, const wide_int &rh_ub) const;\n } op_absu;\n \n-value_range_base\n+value_range\n operator_absu::wi_fold (tree type,\n \t\t\tconst wide_int &lh_lb, const wide_int &lh_ub,\n \t\t\tconst wide_int &rh_lb ATTRIBUTE_UNUSED,\n@@ -2469,27 +2455,27 @@ operator_absu::wi_fold (tree type,\n     }\n \n   gcc_checking_assert (TYPE_UNSIGNED (type));\n-  return value_range_base (type, new_lb, new_ub);\n+  return value_range (type, new_lb, new_ub);\n }\n \n \n class operator_negate : public range_operator\n {\n  public:\n-  virtual value_range_base fold_range (tree type,\n-\t\t\t\t       const value_range_base &op1,\n-\t\t\t\t       const value_range_base &op2) const;\n-  virtual bool op1_range (value_range_base &r, tree type,\n-\t\t\t  const value_range_base &lhs,\n-\t\t\t  const value_range_base &op2) const;\n+  virtual value_range fold_range (tree type,\n+\t\t\t\t  const value_range &op1,\n+\t\t\t\t  const value_range &op2) const;\n+  virtual bool op1_range (value_range &r, tree type,\n+\t\t\t  const value_range &lhs,\n+\t\t\t  const value_range &op2) const;\n } op_negate;\n \n-value_range_base\n+value_range\n operator_negate::fold_range (tree type,\n-\t\t\t     const value_range_base &lh,\n-\t\t\t     const value_range_base &rh) const\n+\t\t\t     const value_range &lh,\n+\t\t\t     const value_range &rh) const\n {\n-  value_range_base r;\n+  value_range r;\n   if (empty_range_check (r, lh, rh))\n     return r;\n   // -X is simply 0 - X.\n@@ -2499,9 +2485,9 @@ operator_negate::fold_range (tree type,\n }\n \n bool\n-operator_negate::op1_range (value_range_base &r, tree type,\n-\t\t\t    const value_range_base &lhs,\n-\t\t\t    const value_range_base &op2) const\n+operator_negate::op1_range (value_range &r, tree type,\n+\t\t\t    const value_range &lhs,\n+\t\t\t    const value_range &op2) const\n {\n   // NEGATE is involutory.\n   r = fold_range (type, lhs, op2);\n@@ -2512,20 +2498,20 @@ operator_negate::op1_range (value_range_base &r, tree type,\n class operator_addr_expr : public range_operator\n {\n public:\n-  virtual value_range_base fold_range (tree type,\n-\t\t\t\t       const value_range_base &op1,\n-\t\t\t\t       const value_range_base &op2) const;\n-  virtual bool op1_range (value_range_base &r, tree type,\n-\t\t\t  const value_range_base &lhs,\n-\t\t\t  const value_range_base &op2) const;\n+  virtual value_range fold_range (tree type,\n+\t\t\t\t  const value_range &op1,\n+\t\t\t\t  const value_range &op2) const;\n+  virtual bool op1_range (value_range &r, tree type,\n+\t\t\t  const value_range &lhs,\n+\t\t\t  const value_range &op2) const;\n } op_addr;\n \n-value_range_base\n+value_range\n operator_addr_expr::fold_range (tree type,\n-\t\t\t\tconst value_range_base &lh,\n-\t\t\t\tconst value_range_base &rh) const\n+\t\t\t\tconst value_range &lh,\n+\t\t\t\tconst value_range &rh) const\n {\n-  value_range_base r;\n+  value_range r;\n   if (empty_range_check (r, lh, rh))\n     return r;\n \n@@ -2534,13 +2520,13 @@ operator_addr_expr::fold_range (tree type,\n     return range_zero (type);\n   if (!lh.contains_p (build_zero_cst (lh.type ())))\n     return range_nonzero (type);\n-  return value_range_base (type);\n+  return value_range (type);\n }\n \n bool\n-operator_addr_expr::op1_range (value_range_base &r, tree type,\n-\t\t\t       const value_range_base &lhs,\n-\t\t\t       const value_range_base &op2) const\n+operator_addr_expr::op1_range (value_range &r, tree type,\n+\t\t\t       const value_range &lhs,\n+\t\t\t       const value_range &op2) const\n {\n   r = operator_addr_expr::fold_range (type, lhs, op2);\n   return true;\n@@ -2550,12 +2536,14 @@ operator_addr_expr::op1_range (value_range_base &r, tree type,\n class pointer_plus_operator : public range_operator\n {\n public:\n-  virtual value_range_base wi_fold (tree type,\n-                          const wide_int &lh_lb, const wide_int &lh_ub,\n-                          const wide_int &rh_lb, const wide_int &rh_ub) const;\n+  virtual value_range wi_fold (tree type,\n+\t\t\t       const wide_int &lh_lb,\n+\t\t\t       const wide_int &lh_ub,\n+\t\t\t       const wide_int &rh_lb,\n+\t\t\t       const wide_int &rh_ub) const;\n } op_pointer_plus;\n \n-value_range_base\n+value_range\n pointer_plus_operator::wi_fold (tree type,\n \t\t\t\tconst wide_int &lh_lb,\n \t\t\t\tconst wide_int &lh_ub,\n@@ -2587,19 +2575,19 @@ pointer_plus_operator::wi_fold (tree type,\n   if (lh_lb == lh_ub && lh_lb == 0\n       && rh_lb == rh_ub && rh_lb == 0)\n     return range_zero (type);\n-  return value_range_base (type);\n+  return value_range (type);\n }\n \n \n class pointer_min_max_operator : public range_operator\n {\n public:\n-  virtual value_range_base wi_fold (tree type,\n+  virtual value_range wi_fold (tree type,\n                           const wide_int &lh_lb, const wide_int &lh_ub,\n                           const wide_int &rh_lb, const wide_int &rh_ub) const;\n } op_ptr_min_max;\n \n-value_range_base\n+value_range\n pointer_min_max_operator::wi_fold (tree type,\n \t\t\t\t   const wide_int &lh_lb,\n \t\t\t\t   const wide_int &lh_ub,\n@@ -2615,19 +2603,19 @@ pointer_min_max_operator::wi_fold (tree type,\n     return range_nonzero (type);\n   if (wi_zero_p (type, lh_lb, lh_ub) && wi_zero_p (type, rh_lb, rh_ub))\n     return range_zero (type);\n-  return value_range_base (type);\n+  return value_range (type);\n }\n \n \n class pointer_and_operator : public range_operator\n {\n public:\n-  virtual value_range_base wi_fold (tree type,\n+  virtual value_range wi_fold (tree type,\n \t\t\t  const wide_int &lh_lb, const wide_int &lh_ub,\n \t\t\t  const wide_int &rh_lb, const wide_int &rh_ub) const;\n } op_pointer_and;\n \n-value_range_base\n+value_range\n pointer_and_operator::wi_fold (tree type,\n \t\t\t       const wide_int &lh_lb,\n \t\t\t       const wide_int &lh_ub,\n@@ -2639,19 +2627,19 @@ pointer_and_operator::wi_fold (tree type,\n   if (wi_zero_p (type, lh_lb, lh_ub) || wi_zero_p (type, lh_lb, lh_ub))\n     return range_zero (type);\n \n-  return value_range_base (type);\n+  return value_range (type);\n }\n \n \n class pointer_or_operator : public range_operator\n {\n public:\n-  virtual value_range_base wi_fold (tree type,\n+  virtual value_range wi_fold (tree type,\n \t\t\t  const wide_int &lh_lb, const wide_int &lh_ub,\n \t\t\t  const wide_int &rh_lb, const wide_int &rh_ub) const;\n } op_pointer_or;\n \n-value_range_base\n+value_range\n pointer_or_operator::wi_fold (tree type,\n \t\t\t      const wide_int &lh_lb,\n \t\t\t      const wide_int &lh_ub,\n@@ -2665,7 +2653,7 @@ pointer_or_operator::wi_fold (tree type,\n     return range_nonzero (type);\n   if (wi_zero_p (type, lh_lb, lh_ub) && wi_zero_p (type, rh_lb, rh_ub))\n     return range_zero (type);\n-  return value_range_base (type);\n+  return value_range (type);\n }\n \f\n // This implements the range operator tables as local objects in this file.\n@@ -2792,19 +2780,19 @@ range_op_handler (enum tree_code code, tree type)\n // Cast the range in R to TYPE.\n \n void\n-range_cast (value_range_base &r, tree type)\n+range_cast (value_range &r, tree type)\n {\n   range_operator *op = range_op_handler (CONVERT_EXPR, type);\n-  r = op->fold_range (type, r, value_range_base (type));\n+  r = op->fold_range (type, r, value_range (type));\n }\n \n #if CHECKING_P\n #include \"selftest.h\"\n #include \"stor-layout.h\"\n \n // Ideally this should go in namespace selftest, but range_tests\n-// needs to be a friend of class value_range_base so it can access\n-// value_range_base::m_max_pairs.\n+// needs to be a friend of class value_range so it can access\n+// value_range::m_max_pairs.\n \n #define INT(N) build_int_cst (integer_type_node, (N))\n #define UINT(N) build_int_cstu (unsigned_type_node, (N))\n@@ -2817,9 +2805,9 @@ range_cast (value_range_base &r, tree type)\n #define SCHAR(N) build_int_cst (signed_char_type_node, (N))\n \n #define RANGE3(A,B,C,D,E,F)\t\t\\\n-( i1 = value_range_base (INT (A), INT (B)),\t\\\n-  i2 = value_range_base (INT (C), INT (D)),\t\\\n-  i3 = value_range_base (INT (E), INT (F)),\t\\\n+( i1 = value_range (INT (A), INT (B)),\t\\\n+  i2 = value_range (INT (C), INT (D)),\t\\\n+  i3 = value_range (INT (E), INT (F)),\t\\\n   i1.union_ (i2),\t\t\t\\\n   i1.union_ (i3),\t\t\t\\\n   i1 )\n@@ -2830,28 +2818,28 @@ void\n range_tests ()\n {\n   tree u128_type = build_nonstandard_integer_type (128, /*unsigned=*/1);\n-  value_range_base i1, i2, i3;\n-  value_range_base r0, r1, rold;\n+  value_range i1, i2, i3;\n+  value_range r0, r1, rold;\n \n   // Test that NOT(255) is [0..254] in 8-bit land.\n-  value_range_base not_255 (VR_ANTI_RANGE, UCHAR (255), UCHAR (255));\n-  ASSERT_TRUE (not_255 == value_range_base (UCHAR (0), UCHAR (254)));\n+  value_range not_255 (VR_ANTI_RANGE, UCHAR (255), UCHAR (255));\n+  ASSERT_TRUE (not_255 == value_range (UCHAR (0), UCHAR (254)));\n \n   // Test that NOT(0) is [1..255] in 8-bit land.\n-  value_range_base not_zero = range_nonzero (unsigned_char_type_node);\n-  ASSERT_TRUE (not_zero == value_range_base (UCHAR (1), UCHAR (255)));\n+  value_range not_zero = range_nonzero (unsigned_char_type_node);\n+  ASSERT_TRUE (not_zero == value_range (UCHAR (1), UCHAR (255)));\n \n   // Check that [0,127][0x..ffffff80,0x..ffffff]\n   //  => ~[128, 0x..ffffff7f].\n-  r0 = value_range_base (UINT128 (0), UINT128 (127));\n+  r0 = value_range (UINT128 (0), UINT128 (127));\n   tree high = build_minus_one_cst (u128_type);\n   // low = -1 - 127 => 0x..ffffff80.\n   tree low = fold_build2 (MINUS_EXPR, u128_type, high, UINT128(127));\n-  r1 = value_range_base (low, high); // [0x..ffffff80, 0x..ffffffff]\n+  r1 = value_range (low, high); // [0x..ffffff80, 0x..ffffffff]\n   // r0 = [0,127][0x..ffffff80,0x..fffffff].\n   r0.union_ (r1);\n   // r1 = [128, 0x..ffffff7f].\n-  r1 = value_range_base (UINT128(128),\n+  r1 = value_range (UINT128(128),\n \t\t\t fold_build2 (MINUS_EXPR, u128_type,\n \t\t\t\t      build_minus_one_cst (u128_type),\n \t\t\t\t      UINT128(128)));\n@@ -2870,41 +2858,41 @@ range_tests ()\n   tree maxuint = wide_int_to_tree (unsigned_type_node, r0.upper_bound ());\n \n   // Check that ~[0,5] => [6,MAX] for unsigned int.\n-  r0 = value_range_base (UINT (0), UINT (5));\n+  r0 = value_range (UINT (0), UINT (5));\n   r0.invert ();\n-  ASSERT_TRUE (r0 == value_range_base (UINT(6), maxuint));\n+  ASSERT_TRUE (r0 == value_range (UINT(6), maxuint));\n \n   // Check that ~[10,MAX] => [0,9] for unsigned int.\n-  r0 = value_range_base (VR_RANGE, UINT(10), maxuint);\n+  r0 = value_range (VR_RANGE, UINT(10), maxuint);\n   r0.invert ();\n-  ASSERT_TRUE (r0 == value_range_base (UINT (0), UINT (9)));\n+  ASSERT_TRUE (r0 == value_range (UINT (0), UINT (9)));\n \n   // Check that ~[0,5] => [6,MAX] for unsigned 128-bit numbers.\n-  r0 = value_range_base (VR_ANTI_RANGE, UINT128 (0), UINT128 (5));\n-  r1 = value_range_base (UINT128(6), build_minus_one_cst (u128_type));\n+  r0 = value_range (VR_ANTI_RANGE, UINT128 (0), UINT128 (5));\n+  r1 = value_range (UINT128(6), build_minus_one_cst (u128_type));\n   ASSERT_TRUE (r0 == r1);\n \n   // Check that [~5] is really [-MIN,4][6,MAX].\n-  r0 = value_range_base (VR_ANTI_RANGE, INT (5), INT (5));\n-  r1 = value_range_base (minint, INT (4));\n-  r1.union_ (value_range_base (INT (6), maxint));\n+  r0 = value_range (VR_ANTI_RANGE, INT (5), INT (5));\n+  r1 = value_range (minint, INT (4));\n+  r1.union_ (value_range (INT (6), maxint));\n   ASSERT_FALSE (r1.undefined_p ());\n   ASSERT_TRUE (r0 == r1);\n \n-  r1 = value_range_base (INT (5), INT (5));\n+  r1 = value_range (INT (5), INT (5));\n   r1.check ();\n-  value_range_base r2 (r1);\n+  value_range r2 (r1);\n   ASSERT_TRUE (r1 == r2);\n \n-  r1 = value_range_base (INT (5), INT (10));\n+  r1 = value_range (INT (5), INT (10));\n   r1.check ();\n \n-  r1 = value_range_base (integer_type_node,\n+  r1 = value_range (integer_type_node,\n \t       wi::to_wide (INT (5)), wi::to_wide (INT (10)));\n   r1.check ();\n   ASSERT_TRUE (r1.contains_p (INT (7)));\n \n-  r1 = value_range_base (SCHAR (0), SCHAR (20));\n+  r1 = value_range (SCHAR (0), SCHAR (20));\n   ASSERT_TRUE (r1.contains_p (SCHAR(15)));\n   ASSERT_FALSE (r1.contains_p (SCHAR(300)));\n \n@@ -2913,96 +2901,96 @@ range_tests ()\n   if (TYPE_PRECISION (TREE_TYPE (maxint))\n       > TYPE_PRECISION (short_integer_type_node))\n     {\n-      r1 = value_range_base (integer_zero_node, maxint);\n+      r1 = value_range (integer_zero_node, maxint);\n       range_cast (r1, short_integer_type_node);\n       ASSERT_TRUE (r1.lower_bound () == wi::to_wide (minshort)\n \t\t   && r1.upper_bound() == wi::to_wide (maxshort));\n     }\n \n   // (unsigned char)[-5,-1] => [251,255].\n-  r0 = rold = value_range_base (SCHAR (-5), SCHAR (-1));\n+  r0 = rold = value_range (SCHAR (-5), SCHAR (-1));\n   range_cast (r0, unsigned_char_type_node);\n-  ASSERT_TRUE (r0 == value_range_base (UCHAR (251), UCHAR (255)));\n+  ASSERT_TRUE (r0 == value_range (UCHAR (251), UCHAR (255)));\n   range_cast (r0, signed_char_type_node);\n   ASSERT_TRUE (r0 == rold);\n \n   // (signed char)[15, 150] => [-128,-106][15,127].\n-  r0 = rold = value_range_base (UCHAR (15), UCHAR (150));\n+  r0 = rold = value_range (UCHAR (15), UCHAR (150));\n   range_cast (r0, signed_char_type_node);\n-  r1 = value_range_base (SCHAR (15), SCHAR (127));\n-  r2 = value_range_base (SCHAR (-128), SCHAR (-106));\n+  r1 = value_range (SCHAR (15), SCHAR (127));\n+  r2 = value_range (SCHAR (-128), SCHAR (-106));\n   r1.union_ (r2);\n   ASSERT_TRUE (r1 == r0);\n   range_cast (r0, unsigned_char_type_node);\n   ASSERT_TRUE (r0 == rold);\n \n   // (unsigned char)[-5, 5] => [0,5][251,255].\n-  r0 = rold = value_range_base (SCHAR (-5), SCHAR (5));\n+  r0 = rold = value_range (SCHAR (-5), SCHAR (5));\n   range_cast (r0, unsigned_char_type_node);\n-  r1 = value_range_base (UCHAR (251), UCHAR (255));\n-  r2 = value_range_base (UCHAR (0), UCHAR (5));\n+  r1 = value_range (UCHAR (251), UCHAR (255));\n+  r2 = value_range (UCHAR (0), UCHAR (5));\n   r1.union_ (r2);\n   ASSERT_TRUE (r0 == r1);\n   range_cast (r0, signed_char_type_node);\n   ASSERT_TRUE (r0 == rold);\n \n   // (unsigned char)[-5,5] => [0,5][251,255].\n-  r0 = value_range_base (INT (-5), INT (5));\n+  r0 = value_range (INT (-5), INT (5));\n   range_cast (r0, unsigned_char_type_node);\n-  r1 = value_range_base (UCHAR (0), UCHAR (5));\n-  r1.union_ (value_range_base (UCHAR (251), UCHAR (255)));\n+  r1 = value_range (UCHAR (0), UCHAR (5));\n+  r1.union_ (value_range (UCHAR (251), UCHAR (255)));\n   ASSERT_TRUE (r0 == r1);\n \n   // (unsigned char)[5U,1974U] => [0,255].\n-  r0 = value_range_base (UINT (5), UINT (1974));\n+  r0 = value_range (UINT (5), UINT (1974));\n   range_cast (r0, unsigned_char_type_node);\n-  ASSERT_TRUE (r0 == value_range_base (UCHAR (0), UCHAR (255)));\n+  ASSERT_TRUE (r0 == value_range (UCHAR (0), UCHAR (255)));\n   range_cast (r0, integer_type_node);\n   // Going to a wider range should not sign extend.\n-  ASSERT_TRUE (r0 == value_range_base (INT (0), INT (255)));\n+  ASSERT_TRUE (r0 == value_range (INT (0), INT (255)));\n \n   // (unsigned char)[-350,15] => [0,255].\n-  r0 = value_range_base (INT (-350), INT (15));\n+  r0 = value_range (INT (-350), INT (15));\n   range_cast (r0, unsigned_char_type_node);\n-  ASSERT_TRUE (r0 == (value_range_base\n+  ASSERT_TRUE (r0 == (value_range\n \t\t      (TYPE_MIN_VALUE (unsigned_char_type_node),\n \t\t       TYPE_MAX_VALUE (unsigned_char_type_node))));\n \n   // Casting [-120,20] from signed char to unsigned short.\n   // => [0, 20][0xff88, 0xffff].\n-  r0 = value_range_base (SCHAR (-120), SCHAR (20));\n+  r0 = value_range (SCHAR (-120), SCHAR (20));\n   range_cast (r0, short_unsigned_type_node);\n-  r1 = value_range_base (UINT16 (0), UINT16 (20));\n-  r2 = value_range_base (UINT16 (0xff88), UINT16 (0xffff));\n+  r1 = value_range (UINT16 (0), UINT16 (20));\n+  r2 = value_range (UINT16 (0xff88), UINT16 (0xffff));\n   r1.union_ (r2);\n   ASSERT_TRUE (r0 == r1);\n   // A truncating cast back to signed char will work because [-120, 20]\n   // is representable in signed char.\n   range_cast (r0, signed_char_type_node);\n-  ASSERT_TRUE (r0 == value_range_base (SCHAR (-120), SCHAR (20)));\n+  ASSERT_TRUE (r0 == value_range (SCHAR (-120), SCHAR (20)));\n \n   // unsigned char -> signed short\n   //\t(signed short)[(unsigned char)25, (unsigned char)250]\n   // => [(signed short)25, (signed short)250]\n-  r0 = rold = value_range_base (UCHAR (25), UCHAR (250));\n+  r0 = rold = value_range (UCHAR (25), UCHAR (250));\n   range_cast (r0, short_integer_type_node);\n-  r1 = value_range_base (INT16 (25), INT16 (250));\n+  r1 = value_range (INT16 (25), INT16 (250));\n   ASSERT_TRUE (r0 == r1);\n   range_cast (r0, unsigned_char_type_node);\n   ASSERT_TRUE (r0 == rold);\n \n   // Test casting a wider signed [-MIN,MAX] to a nar`rower unsigned.\n-  r0 = value_range_base (TYPE_MIN_VALUE (long_long_integer_type_node),\n+  r0 = value_range (TYPE_MIN_VALUE (long_long_integer_type_node),\n \t       TYPE_MAX_VALUE (long_long_integer_type_node));\n   range_cast (r0, short_unsigned_type_node);\n-  r1 = value_range_base (TYPE_MIN_VALUE (short_unsigned_type_node),\n+  r1 = value_range (TYPE_MIN_VALUE (short_unsigned_type_node),\n \t       TYPE_MAX_VALUE (short_unsigned_type_node));\n   ASSERT_TRUE (r0 == r1);\n \n   // NOT([10,20]) ==> [-MIN,9][21,MAX].\n-  r0 = r1 = value_range_base (INT (10), INT (20));\n-  r2 = value_range_base (minint, INT(9));\n-  r2.union_ (value_range_base (INT(21), maxint));\n+  r0 = r1 = value_range (INT (10), INT (20));\n+  r2 = value_range (minint, INT(9));\n+  r2.union_ (value_range (INT(21), maxint));\n   ASSERT_FALSE (r2.undefined_p ());\n   r1.invert ();\n   ASSERT_TRUE (r1 == r2);\n@@ -3012,10 +3000,10 @@ range_tests ()\n \n   // Test that booleans and their inverse work as expected.\n   r0 = range_zero (boolean_type_node);\n-  ASSERT_TRUE (r0 == value_range_base (build_zero_cst (boolean_type_node),\n+  ASSERT_TRUE (r0 == value_range (build_zero_cst (boolean_type_node),\n \t\t\t\t       build_zero_cst (boolean_type_node)));\n   r0.invert ();\n-  ASSERT_TRUE (r0 == value_range_base (build_one_cst (boolean_type_node),\n+  ASSERT_TRUE (r0 == value_range (build_one_cst (boolean_type_node),\n \t\t\t\t       build_one_cst (boolean_type_node)));\n \n   // Casting NONZERO to a narrower type will wrap/overflow so\n@@ -3029,7 +3017,7 @@ range_tests ()\n     {\n       r0 = range_nonzero (integer_type_node);\n       range_cast (r0, short_integer_type_node);\n-      r1 = value_range_base (TYPE_MIN_VALUE (short_integer_type_node),\n+      r1 = value_range (TYPE_MIN_VALUE (short_integer_type_node),\n \t\t\t     TYPE_MAX_VALUE (short_integer_type_node));\n       ASSERT_TRUE (r0 == r1);\n     }\n@@ -3040,45 +3028,45 @@ range_tests ()\n   // Converting this to 32-bits signed is [-MIN_16,-1][1, +MAX_16].\n   r0 = range_nonzero (short_integer_type_node);\n   range_cast (r0, integer_type_node);\n-  r1 = value_range_base (INT (-32768), INT (-1));\n-  r2 = value_range_base (INT (1), INT (32767));\n+  r1 = value_range (INT (-32768), INT (-1));\n+  r2 = value_range (INT (1), INT (32767));\n   r1.union_ (r2);\n   ASSERT_TRUE (r0 == r1);\n \n-  if (value_range_base::m_max_pairs > 2)\n+  if (value_range::m_max_pairs > 2)\n     {\n       // ([10,20] U [5,8]) U [1,3] ==> [1,3][5,8][10,20].\n-      r0 = value_range_base (INT (10), INT (20));\n-      r1 = value_range_base (INT (5), INT (8));\n+      r0 = value_range (INT (10), INT (20));\n+      r1 = value_range (INT (5), INT (8));\n       r0.union_ (r1);\n-      r1 = value_range_base (INT (1), INT (3));\n+      r1 = value_range (INT (1), INT (3));\n       r0.union_ (r1);\n       ASSERT_TRUE (r0 == RANGE3 (1, 3, 5, 8, 10, 20));\n \n       // [1,3][5,8][10,20] U [-5,0] => [-5,3][5,8][10,20].\n-      r1 = value_range_base (INT (-5), INT (0));\n+      r1 = value_range (INT (-5), INT (0));\n       r0.union_ (r1);\n       ASSERT_TRUE (r0 == RANGE3 (-5, 3, 5, 8, 10, 20));\n     }\n \n   // [10,20] U [30,40] ==> [10,20][30,40].\n-  r0 = value_range_base (INT (10), INT (20));\n-  r1 = value_range_base (INT (30), INT (40));\n+  r0 = value_range (INT (10), INT (20));\n+  r1 = value_range (INT (30), INT (40));\n   r0.union_ (r1);\n-  ASSERT_TRUE (r0 == range_union (value_range_base (INT (10), INT (20)),\n-\t\t\t\t  value_range_base (INT (30), INT (40))));\n-  if (value_range_base::m_max_pairs > 2)\n+  ASSERT_TRUE (r0 == range_union (value_range (INT (10), INT (20)),\n+\t\t\t\t  value_range (INT (30), INT (40))));\n+  if (value_range::m_max_pairs > 2)\n     {\n       // [10,20][30,40] U [50,60] ==> [10,20][30,40][50,60].\n-      r1 = value_range_base (INT (50), INT (60));\n+      r1 = value_range (INT (50), INT (60));\n       r0.union_ (r1);\n       ASSERT_TRUE (r0 == RANGE3 (10, 20, 30, 40, 50, 60));\n       // [10,20][30,40][50,60] U [70, 80] ==> [10,20][30,40][50,60][70,80].\n-      r1 = value_range_base (INT (70), INT (80));\n+      r1 = value_range (INT (70), INT (80));\n       r0.union_ (r1);\n \n       r2 = RANGE3 (10, 20, 30, 40, 50, 60);\n-      r2.union_ (value_range_base (INT (70), INT (80)));\n+      r2.union_ (value_range (INT (70), INT (80)));\n       ASSERT_TRUE (r0 == r2);\n     }\n \n@@ -3091,107 +3079,107 @@ range_tests ()\n   r0.invert ();\n   ASSERT_TRUE (r0 == r1);\n \n-  if (value_range_base::m_max_pairs > 2)\n+  if (value_range::m_max_pairs > 2)\n     {\n       // [10,20][30,40][50,60] U [6,35] => [6,40][50,60].\n       r0 = RANGE3 (10, 20, 30, 40, 50, 60);\n-      r1 = value_range_base (INT (6), INT (35));\n+      r1 = value_range (INT (6), INT (35));\n       r0.union_ (r1);\n-      ASSERT_TRUE (r0 == range_union (value_range_base (INT (6), INT (40)),\n-\t\t\t\t      value_range_base (INT (50), INT (60))));\n+      ASSERT_TRUE (r0 == range_union (value_range (INT (6), INT (40)),\n+\t\t\t\t      value_range (INT (50), INT (60))));\n \n       // [10,20][30,40][50,60] U [6,60] => [6,60].\n       r0 = RANGE3 (10, 20, 30, 40, 50, 60);\n-      r1 = value_range_base (INT (6), INT (60));\n+      r1 = value_range (INT (6), INT (60));\n       r0.union_ (r1);\n-      ASSERT_TRUE (r0 == value_range_base (INT (6), INT (60)));\n+      ASSERT_TRUE (r0 == value_range (INT (6), INT (60)));\n \n       // [10,20][30,40][50,60] U [6,70] => [6,70].\n       r0 = RANGE3 (10, 20, 30, 40, 50, 60);\n-      r1 = value_range_base (INT (6), INT (70));\n+      r1 = value_range (INT (6), INT (70));\n       r0.union_ (r1);\n-      ASSERT_TRUE (r0 == value_range_base (INT (6), INT (70)));\n+      ASSERT_TRUE (r0 == value_range (INT (6), INT (70)));\n \n       // [10,20][30,40][50,60] U [35,70] => [10,20][30,70].\n       r0 = RANGE3 (10, 20, 30, 40, 50, 60);\n-      r1 = value_range_base (INT (35), INT (70));\n+      r1 = value_range (INT (35), INT (70));\n       r0.union_ (r1);\n-      ASSERT_TRUE (r0 == range_union (value_range_base (INT (10), INT (20)),\n-\t\t\t\t      value_range_base (INT (30), INT (70))));\n+      ASSERT_TRUE (r0 == range_union (value_range (INT (10), INT (20)),\n+\t\t\t\t      value_range (INT (30), INT (70))));\n     }\n \n   // [10,20][30,40] U [25,70] => [10,70].\n-  r0 = range_union (value_range_base (INT (10), INT (20)),\n-\t\t     value_range_base (INT (30), INT (40)));\n-  r1 = value_range_base (INT (25), INT (70));\n+  r0 = range_union (value_range (INT (10), INT (20)),\n+\t\t     value_range (INT (30), INT (40)));\n+  r1 = value_range (INT (25), INT (70));\n   r0.union_ (r1);\n-  ASSERT_TRUE (r0 == range_union (value_range_base (INT (10), INT (20)),\n-\t\t\t\t  value_range_base (INT (25), INT (70))));\n+  ASSERT_TRUE (r0 == range_union (value_range (INT (10), INT (20)),\n+\t\t\t\t  value_range (INT (25), INT (70))));\n \n-  if (value_range_base::m_max_pairs > 2)\n+  if (value_range::m_max_pairs > 2)\n     {\n       // [10,20][30,40][50,60] U [15,35] => [10,40][50,60].\n       r0 = RANGE3 (10, 20, 30, 40, 50, 60);\n-      r1 = value_range_base (INT (15), INT (35));\n+      r1 = value_range (INT (15), INT (35));\n       r0.union_ (r1);\n-      ASSERT_TRUE (r0 == range_union (value_range_base (INT (10), INT (40)),\n-\t\t\t\t      value_range_base (INT (50), INT (60))));\n+      ASSERT_TRUE (r0 == range_union (value_range (INT (10), INT (40)),\n+\t\t\t\t      value_range (INT (50), INT (60))));\n     }\n \n   // [10,20] U [15, 30] => [10, 30].\n-  r0 = value_range_base (INT (10), INT (20));\n-  r1 = value_range_base (INT (15), INT (30));\n+  r0 = value_range (INT (10), INT (20));\n+  r1 = value_range (INT (15), INT (30));\n   r0.union_ (r1);\n-  ASSERT_TRUE (r0 == value_range_base (INT (10), INT (30)));\n+  ASSERT_TRUE (r0 == value_range (INT (10), INT (30)));\n \n   // [10,20] U [25,25] => [10,20][25,25].\n-  r0 = value_range_base (INT (10), INT (20));\n-  r1 = value_range_base (INT (25), INT (25));\n+  r0 = value_range (INT (10), INT (20));\n+  r1 = value_range (INT (25), INT (25));\n   r0.union_ (r1);\n-  ASSERT_TRUE (r0 == range_union (value_range_base (INT (10), INT (20)),\n-\t\t\t\t  value_range_base (INT (25), INT (25))));\n+  ASSERT_TRUE (r0 == range_union (value_range (INT (10), INT (20)),\n+\t\t\t\t  value_range (INT (25), INT (25))));\n \n-  if (value_range_base::m_max_pairs > 2)\n+  if (value_range::m_max_pairs > 2)\n     {\n       // [10,20][30,40][50,60] U [35,35] => [10,20][30,40][50,60].\n       r0 = RANGE3 (10, 20, 30, 40, 50, 60);\n-      r1 = value_range_base (INT (35), INT (35));\n+      r1 = value_range (INT (35), INT (35));\n       r0.union_ (r1);\n       ASSERT_TRUE (r0 == RANGE3 (10, 20, 30, 40, 50, 60));\n     }\n \n   // [15,40] U [] => [15,40].\n-  r0 = value_range_base (INT (15), INT (40));\n+  r0 = value_range (INT (15), INT (40));\n   r1.set_undefined ();\n   r0.union_ (r1);\n-  ASSERT_TRUE (r0 == value_range_base (INT (15), INT (40)));\n+  ASSERT_TRUE (r0 == value_range (INT (15), INT (40)));\n \n   // [10,20] U [10,10] => [10,20].\n-  r0 = value_range_base (INT (10), INT (20));\n-  r1 = value_range_base (INT (10), INT (10));\n+  r0 = value_range (INT (10), INT (20));\n+  r1 = value_range (INT (10), INT (10));\n   r0.union_ (r1);\n-  ASSERT_TRUE (r0 == value_range_base (INT (10), INT (20)));\n+  ASSERT_TRUE (r0 == value_range (INT (10), INT (20)));\n \n   // [10,20] U [9,9] => [9,20].\n-  r0 = value_range_base (INT (10), INT (20));\n-  r1 = value_range_base (INT (9), INT (9));\n+  r0 = value_range (INT (10), INT (20));\n+  r1 = value_range (INT (9), INT (9));\n   r0.union_ (r1);\n-  ASSERT_TRUE (r0 == value_range_base (INT (9), INT (20)));\n+  ASSERT_TRUE (r0 == value_range (INT (9), INT (20)));\n \n-  if (value_range_base::m_max_pairs > 2)\n+  if (value_range::m_max_pairs > 2)\n     {\n       // [10,10][12,12][20,100] ^ [15,200].\n       r0 = RANGE3 (10, 10, 12, 12, 20, 100);\n-      r1 = value_range_base (INT (15), INT (200));\n+      r1 = value_range (INT (15), INT (200));\n       r0.intersect (r1);\n-      ASSERT_TRUE (r0 == value_range_base (INT (20), INT (100)));\n+      ASSERT_TRUE (r0 == value_range (INT (20), INT (100)));\n \n       // [10,20][30,40][50,60] ^ [15,25][38,51][55,70]\n       // => [15,20][38,40][50,51][55,60]\n       r0 = RANGE3 (10, 20, 30, 40, 50, 60);\n       r1 = RANGE3 (15, 25, 38, 51, 55, 70);\n       r0.intersect (r1);\n-      if (value_range_base::m_max_pairs == 3)\n+      if (value_range::m_max_pairs == 3)\n \t{\n \t  // When pairs==3, we don't have enough space, so\n \t  //  conservatively handle things.  Thus, the ...[50,60].\n@@ -3200,7 +3188,7 @@ range_tests ()\n       else\n \t{\n \t  r2 = RANGE3 (15, 20, 38, 40, 50, 51);\n-\t  r2.union_ (value_range_base (INT (55), INT (60)));\n+\t  r2.union_ (value_range (INT (55), INT (60)));\n \t  ASSERT_TRUE (r0 == r2);\n \t}\n \n@@ -3209,7 +3197,7 @@ range_tests ()\n       r0 = RANGE3 (15, 20, 30, 40, 50, 60);\n       r1 = RANGE3 (15, 35, 40, 90, 100, 200);\n       r0.intersect (r1);\n-      if (value_range_base::m_max_pairs == 3)\n+      if (value_range::m_max_pairs == 3)\n \t{\n \t  // When pairs==3, we don't have enough space, so\n \t  // conservatively handle things.\n@@ -3218,37 +3206,37 @@ range_tests ()\n       else\n \t{\n \t  r2 = RANGE3 (15, 20, 30, 35, 40, 40);\n-\t  r2.union_ (value_range_base (INT (50), INT (60)));\n+\t  r2.union_ (value_range (INT (50), INT (60)));\n \t  ASSERT_TRUE (r0 == r2);\n \t}\n \n       // Test cases where a union inserts a sub-range inside a larger\n       // range.\n       //\n       // [8,10][135,255] U [14,14] => [8,10][14,14][135,255]\n-      r0 = range_union (value_range_base (INT (8), INT (10)),\n-\t\t\t value_range_base (INT (135), INT (255)));\n-      r1 = value_range_base (INT (14), INT (14));\n+      r0 = range_union (value_range (INT (8), INT (10)),\n+\t\t\t value_range (INT (135), INT (255)));\n+      r1 = value_range (INT (14), INT (14));\n       r0.union_ (r1);\n       ASSERT_TRUE (r0 == RANGE3 (8, 10, 14, 14, 135, 255));\n     }\n \n   // [10,20] ^ [15,30] => [15,20].\n-  r0 = value_range_base (INT (10), INT (20));\n-  r1 = value_range_base (INT (15), INT (30));\n+  r0 = value_range (INT (10), INT (20));\n+  r1 = value_range (INT (15), INT (30));\n   r0.intersect (r1);\n-  ASSERT_TRUE (r0 == value_range_base (INT (15), INT (20)));\n+  ASSERT_TRUE (r0 == value_range (INT (15), INT (20)));\n \n   // [10,20][30,40] ^ [40,50] => [40,40].\n-  r0 = range_union (value_range_base (INT (10), INT (20)),\n-\t\t     value_range_base (INT (30), INT (40)));\n-  r1 = value_range_base (INT (40), INT (50));\n+  r0 = range_union (value_range (INT (10), INT (20)),\n+\t\t     value_range (INT (30), INT (40)));\n+  r1 = value_range (INT (40), INT (50));\n   r0.intersect (r1);\n-  ASSERT_TRUE (r0 == value_range_base (INT (40), INT (40)));\n+  ASSERT_TRUE (r0 == value_range (INT (40), INT (40)));\n \n   // Test non-destructive intersection.\n-  r0 = rold = value_range_base (INT (10), INT (20));\n-  ASSERT_FALSE (range_intersect (r0, value_range_base (INT (15),\n+  r0 = rold = value_range (INT (10), INT (20));\n+  ASSERT_FALSE (range_intersect (r0, value_range (INT (15),\n \t\t\t\t\t     INT (30))).undefined_p ());\n   ASSERT_TRUE (r0 == rold);\n \n@@ -3258,11 +3246,11 @@ range_tests ()\n \t       == wi::uhwi (1, TYPE_PRECISION (boolean_type_node)));\n \n   // Test zero_p().\n-  r0 = value_range_base (INT (0), INT (0));\n+  r0 = value_range (INT (0), INT (0));\n   ASSERT_TRUE (r0.zero_p ());\n \n   // Test nonzero_p().\n-  r0 = value_range_base (INT (0), INT (0));\n+  r0 = value_range (INT (0), INT (0));\n   r0.invert ();\n   ASSERT_TRUE (r0.nonzero_p ());\n }"}, {"sha": "3df9f1d917ad8e859dce00224771a9fcd4583070", "filename": "gcc/range-op.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Frange-op.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Frange-op.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.h?ref=028d81b1599c365d8c60222ec5631a8f111d8574", "patch": "@@ -50,9 +50,9 @@ class range_operator\n {\n public:\n   // Perform an operation between 2 ranges and return it.\n-  virtual value_range_base fold_range (tree type,\n-\t\t\t\t       const value_range_base &lh,\n-\t\t\t\t       const value_range_base &rh) const;\n+  virtual value_range fold_range (tree type,\n+\t\t\t\t  const value_range &lh,\n+\t\t\t\t  const value_range &rh) const;\n \n   // Return the range for op[12] in the general case.  LHS is the range for\n   // the LHS of the expression, OP[12]is the range for the other\n@@ -65,24 +65,24 @@ class range_operator\n   //\n   // i.e.  [LHS] = ??? + OP2\n   // is re-formed as R = [LHS] - OP2.\n-  virtual bool op1_range (value_range_base &r, tree type,\n-\t\t\t  const value_range_base &lhs,\n-\t\t\t  const value_range_base &op2) const;\n-  virtual bool op2_range (value_range_base &r, tree type,\n-\t\t\t  const value_range_base &lhs,\n-\t\t\t  const value_range_base &op1) const;\n+  virtual bool op1_range (value_range &r, tree type,\n+\t\t\t  const value_range &lhs,\n+\t\t\t  const value_range &op2) const;\n+  virtual bool op2_range (value_range &r, tree type,\n+\t\t\t  const value_range &lhs,\n+\t\t\t  const value_range &op1) const;\n \n protected:\n   // Perform an operation between 2 sub-ranges and return it.\n-  virtual value_range_base wi_fold (tree type,\n+  virtual value_range wi_fold (tree type,\n \t\t\t\t    const wide_int &lh_lb,\n \t\t\t\t    const wide_int &lh_ub,\n \t\t\t\t    const wide_int &rh_lb,\n \t\t\t\t    const wide_int &rh_ub) const;\n };\n \n extern range_operator *range_op_handler (enum tree_code code, tree type);\n-extern void range_cast (value_range_base &, tree type);\n+extern void range_cast (value_range &, tree type);\n extern void wi_set_zero_nonzero_bits (tree type,\n \t\t\t\t      const wide_int &, const wide_int &,\n \t\t\t\t      wide_int &maybe_nonzero,"}, {"sha": "8e5c979cf1e2ec7f13e912276d277a9e20909d57", "filename": "gcc/range.cc", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Frange.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Frange.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange.cc?ref=028d81b1599c365d8c60222ec5631a8f111d8574", "patch": "@@ -29,61 +29,60 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ssa.h\"\n #include \"range.h\"\n \n-value_range_base\n-range_intersect (const value_range_base &r1, const value_range_base &r2)\n+value_range\n+range_intersect (const value_range &r1, const value_range &r2)\n {\n-  value_range_base tmp (r1);\n+  value_range tmp (r1);\n   tmp.intersect (r2);\n   return tmp;\n }\n \n-value_range_base\n-range_invert (const value_range_base &r1)\n+value_range\n+range_invert (const value_range &r1)\n {\n-  value_range_base tmp (r1);\n+  value_range tmp (r1);\n   tmp.invert ();\n   return tmp;\n }\n \n-value_range_base\n-range_union (const value_range_base &r1, const value_range_base &r2)\n+value_range\n+range_union (const value_range &r1, const value_range &r2)\n {\n-  value_range_base tmp (r1);\n+  value_range tmp (r1);\n   tmp.union_ (r2);\n   return tmp;\n }\n \n-value_range_base\n+value_range\n range_zero (tree type)\n {\n-  return value_range_base (build_zero_cst (type), build_zero_cst (type));\n+  return value_range (build_zero_cst (type), build_zero_cst (type));\n }\n \n-value_range_base\n+value_range\n range_nonzero (tree type)\n {\n-  return value_range_base (VR_ANTI_RANGE,\n+  return value_range (VR_ANTI_RANGE,\n \t\t\t   build_zero_cst (type), build_zero_cst (type));\n }\n \n-value_range_base\n+value_range\n range_positives (tree type)\n {\n   unsigned prec = TYPE_PRECISION (type);\n   signop sign = TYPE_SIGN (type);\n-  return value_range_base (type, wi::zero (prec), wi::max_value (prec, sign));\n+  return value_range (type, wi::zero (prec), wi::max_value (prec, sign));\n }\n \n-value_range_base\n+value_range\n range_negatives (tree type)\n {\n   unsigned prec = TYPE_PRECISION (type);\n   signop sign = TYPE_SIGN (type);\n-  value_range_base r;\n+  value_range r;\n   if (sign == UNSIGNED)\n     r.set_undefined ();\n   else\n-    r = value_range_base (type, wi::min_value (prec, sign),\n-\t\t\t  wi::minus_one (prec));\n+    r = value_range (type, wi::min_value (prec, sign), wi::minus_one (prec));\n   return r;\n }"}, {"sha": "b4806e64bbb1a764d071291806d59e40c9d821b9", "filename": "gcc/range.h", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Frange.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Frange.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange.h?ref=028d81b1599c365d8c60222ec5631a8f111d8574", "patch": "@@ -21,13 +21,11 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_RANGE_H\n #define GCC_RANGE_H\n \n-value_range_base range_zero (tree type);\n-value_range_base range_nonzero (tree type);\n-value_range_base range_intersect (const value_range_base &,\n-\t\t\t\t  const value_range_base &);\n-value_range_base range_union (const value_range_base &,\n-\t\t\t      const value_range_base &);\n-value_range_base range_invert (const value_range_base &);\n-value_range_base range_positives (tree type);\n-value_range_base range_negatives (tree type);\n+value_range range_zero (tree type);\n+value_range range_nonzero (tree type);\n+value_range range_intersect (const value_range &, const value_range &);\n+value_range range_union (const value_range &, const value_range &);\n+value_range range_invert (const value_range &);\n+value_range range_positives (tree type);\n+value_range range_negatives (tree type);\n #endif // GCC_RANGE_H"}, {"sha": "933c0aab539e4987009435fd91d3e6bddc971b14", "filename": "gcc/selftest.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Fselftest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Fselftest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest.h?ref=028d81b1599c365d8c60222ec5631a8f111d8574", "patch": "@@ -260,7 +260,7 @@ extern int num_passes;\n } /* end of namespace selftest.  */\n \n /* This is outside of the selftest namespace because it's a friend of\n-   value_range_base.  */\n+   value_range.  */\n extern void range_tests ();\n \n /* Macros for writing tests.  */"}, {"sha": "44a4289aa381e98bbed7db589912469bc8b7af3a", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=028d81b1599c365d8c60222ec5631a8f111d8574", "patch": "@@ -901,7 +901,7 @@ simplify_stmt_for_jump_threading (gimple *stmt,\n       if (TREE_CODE (op) != SSA_NAME)\n \treturn NULL_TREE;\n \n-      const value_range *vr = x_vr_values->get_value_range (op);\n+      const value_range_equiv *vr = x_vr_values->get_value_range (op);\n       if (vr->undefined_p ()\n \t  || vr->varying_p ()\n \t  || vr->symbolic_p ())\n@@ -963,9 +963,9 @@ simplify_stmt_for_jump_threading (gimple *stmt,\n \t{\n \t  edge dummy_e;\n \t  tree dummy_tree;\n-\t  value_range new_vr;\n+\t  value_range_equiv new_vr;\n \t  x_vr_values->extract_range_from_stmt (stmt, &dummy_e,\n-\t\t\t\t\t      &dummy_tree, &new_vr);\n+\t\t\t\t\t\t&dummy_tree, &new_vr);\n \t  tree singleton;\n \t  if (new_vr.singleton_p (&singleton))\n \t    return singleton;"}, {"sha": "163be2d67f698a24f4c301c1902b55214071e8d5", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=028d81b1599c365d8c60222ec5631a8f111d8574", "patch": "@@ -225,7 +225,7 @@ compare_nonzero_chars (strinfo *si, unsigned HOST_WIDE_INT off,\n   if (!rvals || TREE_CODE (si->nonzero_chars) != SSA_NAME)\n     return -1;\n \n-  const value_range *vr\n+  const value_range_equiv *vr\n     = (CONST_CAST (class vr_values *, rvals)\n        ->get_value_range (si->nonzero_chars));\n \n@@ -799,7 +799,7 @@ dump_strlen_info (FILE *fp, gimple *stmt, const vr_values *rvals)\n \t\t  wide_int min, max;\n \t\t  if (rvals)\n \t\t    {\n-\t\t      const value_range *vr\n+\t\t      const value_range_equiv *vr\n \t\t\t= CONST_CAST (class vr_values *, rvals)\n \t\t\t->get_value_range (si->nonzero_chars);\n \t\t      rng = vr->kind ();\n@@ -991,7 +991,7 @@ get_range_strlen_dynamic (tree src, c_strlen_data *pdata, bitmap *visited,\n \t    pdata->minlen = si->nonzero_chars;\n \t  else if (TREE_CODE (si->nonzero_chars) == SSA_NAME)\n \t    {\n-\t      const value_range *vr\n+\t      const value_range_equiv *vr\n \t\t= CONST_CAST (class vr_values *, rvals)\n \t\t->get_value_range (si->nonzero_chars);\n \t      if (vr->kind () == VR_RANGE\n@@ -1031,7 +1031,7 @@ get_range_strlen_dynamic (tree src, c_strlen_data *pdata, bitmap *visited,\n \t}\n       else if (pdata->minlen && TREE_CODE (pdata->minlen) == SSA_NAME)\n \t{\n-\t  const value_range *vr\n+\t  const value_range_equiv *vr\n \t    = CONST_CAST (class vr_values *, rvals)\n \t    ->get_value_range (si->nonzero_chars);\n \t  if (vr->kind () == VR_RANGE\n@@ -4040,7 +4040,7 @@ count_nonzero_bytes (tree exp, unsigned HOST_WIDE_INT offset,\n \t       && si->nonzero_chars\n \t       && TREE_CODE (si->nonzero_chars) == SSA_NAME)\n \t{\n-\t  const value_range *vr\n+\t  const value_range_equiv *vr\n \t    = CONST_CAST (class vr_values *, rvals)\n \t    ->get_value_range (si->nonzero_chars);\n \t  if (vr->kind () != VR_RANGE"}, {"sha": "a5d87662159cad946587f80477ba62dead47cd0f", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=028d81b1599c365d8c60222ec5631a8f111d8574", "patch": "@@ -165,8 +165,8 @@ record_temporary_equivalences_from_phis (edge e,\n \t  /* Get an empty new VR we can pass to update_value_range and save\n \t     away in the VR stack.  */\n \t  vr_values *vr_values = evrp_range_analyzer->get_vr_values ();\n-\t  value_range *new_vr = vr_values->allocate_value_range ();\n-\t  new (new_vr) value_range ();\n+\t  value_range_equiv *new_vr = vr_values->allocate_value_range_equiv ();\n+\t  new (new_vr) value_range_equiv ();\n \n \t  /* There are three cases to consider:\n "}, {"sha": "ac92ae4e0e3dfe735a473f57c42e7139339ccf16", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=028d81b1599c365d8c60222ec5631a8f111d8574", "patch": "@@ -408,7 +408,7 @@ set_range_info (tree name, enum value_range_kind range_type,\n /* Store range information for NAME from a value_range.  */\n \n void\n-set_range_info (tree name, const value_range_base &vr)\n+set_range_info (tree name, const value_range &vr)\n {\n   wide_int min = wi::to_wide (vr.min ());\n   wide_int max = wi::to_wide (vr.max ());\n@@ -441,7 +441,7 @@ get_range_info (const_tree name, wide_int *min, wide_int *max)\n    in a value_range VR.  Returns the value_range_kind.  */\n \n enum value_range_kind\n-get_range_info (const_tree name, value_range_base &vr)\n+get_range_info (const_tree name, value_range &vr)\n {\n   tree min, max;\n   wide_int wmin, wmax;"}, {"sha": "04c07c2ae12831bc190b1a9df320125464647eaf", "filename": "gcc/tree-ssanames.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Ftree-ssanames.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Ftree-ssanames.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.h?ref=028d81b1599c365d8c60222ec5631a8f111d8574", "patch": "@@ -69,11 +69,11 @@ struct GTY ((variable_size)) range_info_def {\n /* Sets the value range to SSA.  */\n extern void set_range_info (tree, enum value_range_kind, const wide_int_ref &,\n \t\t\t    const wide_int_ref &);\n-extern void set_range_info (tree, const value_range_base &);\n+extern void set_range_info (tree, const value_range &);\n /* Gets the value range from SSA.  */\n extern enum value_range_kind get_range_info (const_tree, wide_int *,\n \t\t\t\t\t     wide_int *);\n-extern enum value_range_kind get_range_info (const_tree, value_range_base &);\n+extern enum value_range_kind get_range_info (const_tree, value_range &);\n extern void set_nonzero_bits (tree, const wide_int_ref &);\n extern wide_int get_nonzero_bits (const_tree);\n extern bool ssa_name_has_boolean_range (tree);"}, {"sha": "1328707a1549db5ed835aadba76c985c20f2f3e4", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 151, "deletions": 150, "changes": 301, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=028d81b1599c365d8c60222ec5631a8f111d8574", "patch": "@@ -70,15 +70,15 @@ along with GCC; see the file COPYING3.  If not see\n #include \"range-op.h\"\n \n static bool\n-ranges_from_anti_range (const value_range_base *ar,\n-\t\t\tvalue_range_base *vr0, value_range_base *vr1);\n+ranges_from_anti_range (const value_range *ar,\n+\t\t\tvalue_range *vr0, value_range *vr1);\n \n /* Set of SSA names found live during the RPO traversal of the function\n    for still active basic-blocks.  */\n static sbitmap *live;\n \n void\n-value_range::set_equiv (bitmap equiv)\n+value_range_equiv::set_equiv (bitmap equiv)\n {\n   if (undefined_p () || varying_p ())\n     equiv = NULL;\n@@ -103,39 +103,39 @@ value_range::set_equiv (bitmap equiv)\n /* Initialize value_range.  */\n \n void\n-value_range::set (enum value_range_kind kind, tree min, tree max,\n-\t\t  bitmap equiv)\n+value_range_equiv::set (enum value_range_kind kind, tree min, tree max,\n+\t\t\tbitmap equiv)\n {\n-  value_range_base::set (kind, min, max);\n+  value_range::set (kind, min, max);\n   set_equiv (equiv);\n   if (flag_checking)\n     check ();\n }\n \n-value_range_base::value_range_base (value_range_kind kind, tree min, tree max)\n+value_range::value_range (value_range_kind kind, tree min, tree max)\n {\n   set (kind, min, max);\n }\n \n-value_range::value_range (value_range_kind kind, tree min, tree max,\n-\t\t\t  bitmap equiv)\n+value_range_equiv::value_range_equiv (value_range_kind kind,\n+\t\t\t\t      tree min, tree max, bitmap equiv)\n {\n   m_equiv = NULL;\n   set (kind, min, max, equiv);\n }\n \n-value_range::value_range (const value_range_base &other)\n+value_range_equiv::value_range_equiv (const value_range &other)\n {\n   m_equiv = NULL;\n   set (other.kind (), other.min(), other.max (), NULL);\n }\n \n-value_range_base::value_range_base (tree type)\n+value_range::value_range (tree type)\n {\n   set_varying (type);\n }\n \n-value_range_base::value_range_base (enum value_range_kind kind,\n+value_range::value_range (enum value_range_kind kind,\n \t\t\t\t    tree type,\n \t\t\t\t    const wide_int &wmin,\n \t\t\t\t    const wide_int &wmax)\n@@ -146,7 +146,7 @@ value_range_base::value_range_base (enum value_range_kind kind,\n   set (kind, min, max);\n }\n \n-value_range_base::value_range_base (tree type,\n+value_range::value_range (tree type,\n \t\t\t\t    const wide_int &wmin,\n \t\t\t\t    const wide_int &wmax)\n {\n@@ -155,15 +155,15 @@ value_range_base::value_range_base (tree type,\n   set (VR_RANGE, min, max);\n }\n \n-value_range_base::value_range_base (tree min, tree max)\n+value_range::value_range (tree min, tree max)\n {\n   set (VR_RANGE, min, max);\n }\n \n /* Like set, but keep the equivalences in place.  */\n \n void\n-value_range::update (value_range_kind kind, tree min, tree max)\n+value_range_equiv::update (value_range_kind kind, tree min, tree max)\n {\n   set (kind, min, max,\n        (kind != VR_UNDEFINED && kind != VR_VARYING) ? m_equiv : NULL);\n@@ -176,13 +176,13 @@ value_range::update (value_range_kind kind, tree min, tree max)\n    object.  Use the constructors for initialization.  */\n \n void\n-value_range::deep_copy (const value_range *from)\n+value_range_equiv::deep_copy (const value_range_equiv *from)\n {\n   set (from->m_kind, from->min (), from->max (), from->m_equiv);\n }\n \n void\n-value_range::move (value_range *from)\n+value_range_equiv::move (value_range_equiv *from)\n {\n   set (from->m_kind, from->min (), from->max ());\n   m_equiv = from->m_equiv;\n@@ -192,7 +192,7 @@ value_range::move (value_range *from)\n /* Check the validity of the range.  */\n \n void\n-value_range_base::check ()\n+value_range::check ()\n {\n   switch (m_kind)\n     {\n@@ -226,9 +226,9 @@ value_range_base::check ()\n }\n \n void\n-value_range::check ()\n+value_range_equiv::check ()\n {\n-  value_range_base::check ();\n+  value_range::check ();\n   switch (m_kind)\n     {\n     case VR_UNDEFINED:\n@@ -243,7 +243,7 @@ value_range::check ()\n    class.  */\n \n bool\n-value_range_base::equal_p (const value_range_base &other) const\n+value_range::equal_p (const value_range &other) const\n {\n   /* Ignore types for undefined.  All undefines are equal.  */\n   if (undefined_p ())\n@@ -270,17 +270,18 @@ vrp_bitmap_equal_p (const_bitmap b1, const_bitmap b2)\n    IGNORE_EQUIVS is TRUE.  */\n \n bool\n-value_range::equal_p (const value_range &other, bool ignore_equivs) const\n+value_range_equiv::equal_p (const value_range_equiv &other,\n+\t\t\t    bool ignore_equivs) const\n {\n-  return (value_range_base::equal_p (other)\n+  return (value_range::equal_p (other)\n \t  && (ignore_equivs\n \t      || vrp_bitmap_equal_p (m_equiv, other.m_equiv)));\n }\n \n /* Return TRUE if this is a symbolic range.  */\n \n bool\n-value_range_base::symbolic_p () const\n+value_range::symbolic_p () const\n {\n   return (!varying_p ()\n \t  && !undefined_p ()\n@@ -294,7 +295,7 @@ value_range_base::symbolic_p () const\n    constants would be represented as [-MIN, +MAX].  */\n \n bool\n-value_range_base::constant_p () const\n+value_range::constant_p () const\n {\n   return (!varying_p ()\n \t  && !undefined_p ()\n@@ -303,20 +304,20 @@ value_range_base::constant_p () const\n }\n \n void\n-value_range_base::set_undefined ()\n+value_range::set_undefined ()\n {\n   m_kind = VR_UNDEFINED;\n   m_min = m_max = NULL;\n }\n \n void\n-value_range::set_undefined ()\n+value_range_equiv::set_undefined ()\n {\n   set (VR_UNDEFINED, NULL, NULL, NULL);\n }\n \n void\n-value_range_base::set_varying (tree type)\n+value_range::set_varying (tree type)\n {\n   m_kind = VR_VARYING;\n   if (supports_type_p (type))\n@@ -330,22 +331,22 @@ value_range_base::set_varying (tree type)\n }\n \n void\n-value_range::set_varying (tree type)\n+value_range_equiv::set_varying (tree type)\n {\n-  value_range_base::set_varying (type);\n+  value_range::set_varying (type);\n   equiv_clear ();\n }\n \n /* Return TRUE if it is possible that range contains VAL.  */\n \n bool\n-value_range_base::may_contain_p (tree val) const\n+value_range::may_contain_p (tree val) const\n {\n   return value_inside_range (val) != 0;\n }\n \n void\n-value_range::equiv_clear ()\n+value_range_equiv::equiv_clear ()\n {\n   if (m_equiv)\n     bitmap_clear (m_equiv);\n@@ -359,9 +360,9 @@ value_range::equiv_clear ()\n    turned on/off.  */\n \n void\n-value_range::equiv_add (const_tree var,\n-\t\t\tconst value_range *var_vr,\n-\t\t\tbitmap_obstack *obstack)\n+value_range_equiv::equiv_add (const_tree var,\n+\t\t\t      const value_range_equiv *var_vr,\n+\t\t\t      bitmap_obstack *obstack)\n {\n   if (!m_equiv)\n     m_equiv = BITMAP_ALLOC (obstack);\n@@ -376,7 +377,7 @@ value_range::equiv_add (const_tree var,\n    So, [&x, &x] counts as a singleton.  */\n \n bool\n-value_range_base::singleton_p (tree *result) const\n+value_range::singleton_p (tree *result) const\n {\n   if (m_kind == VR_ANTI_RANGE)\n     {\n@@ -392,7 +393,7 @@ value_range_base::singleton_p (tree *result) const\n \t}\n       if (num_pairs () == 1)\n \t{\n-\t  value_range_base vr0, vr1;\n+\t  value_range vr0, vr1;\n \t  ranges_from_anti_range (this, &vr0, &vr1);\n \t  return vr0.singleton_p (result);\n \t}\n@@ -409,14 +410,14 @@ value_range_base::singleton_p (tree *result) const\n }\n \n tree\n-value_range_base::type () const\n+value_range::type () const\n {\n   gcc_checking_assert (m_min);\n   return TREE_TYPE (min ());\n }\n \n void\n-value_range_base::dump (FILE *file) const\n+value_range::dump (FILE *file) const\n {\n   if (undefined_p ())\n     fprintf (file, \"UNDEFINED\");\n@@ -458,15 +459,15 @@ value_range_base::dump (FILE *file) const\n }\n \n void\n-value_range_base::dump () const\n+value_range::dump () const\n {\n   dump (stderr);\n }\n \n void\n-value_range::dump (FILE *file) const\n+value_range_equiv::dump (FILE *file) const\n {\n-  value_range_base::dump (file);\n+  value_range::dump (file);\n   if ((m_kind == VR_RANGE || m_kind == VR_ANTI_RANGE)\n       && m_equiv)\n     {\n@@ -487,13 +488,13 @@ value_range::dump (FILE *file) const\n }\n \n void\n-value_range::dump () const\n+value_range_equiv::dump () const\n {\n   dump (stderr);\n }\n \n void\n-dump_value_range (FILE *file, const value_range *vr)\n+dump_value_range (FILE *file, const value_range_equiv *vr)\n {\n   if (!vr)\n     fprintf (file, \"[]\");\n@@ -502,7 +503,7 @@ dump_value_range (FILE *file, const value_range *vr)\n }\n \n void\n-dump_value_range (FILE *file, const value_range_base *vr)\n+dump_value_range (FILE *file, const value_range *vr)\n {\n   if (!vr)\n     fprintf (file, \"[]\");\n@@ -511,25 +512,25 @@ dump_value_range (FILE *file, const value_range_base *vr)\n }\n \n DEBUG_FUNCTION void\n-debug (const value_range_base *vr)\n+debug (const value_range *vr)\n {\n   dump_value_range (stderr, vr);\n }\n \n DEBUG_FUNCTION void\n-debug (const value_range_base &vr)\n+debug (const value_range &vr)\n {\n   dump_value_range (stderr, &vr);\n }\n \n DEBUG_FUNCTION void\n-debug (const value_range *vr)\n+debug (const value_range_equiv *vr)\n {\n   dump_value_range (stderr, vr);\n }\n \n DEBUG_FUNCTION void\n-debug (const value_range &vr)\n+debug (const value_range_equiv &vr)\n {\n   dump_value_range (stderr, &vr);\n }\n@@ -717,7 +718,7 @@ intersect_range_with_nonzero_bits (enum value_range_kind vr_type,\n    extract ranges from var + CST op limit.  */\n \n void\n-value_range_base::set (enum value_range_kind kind, tree min, tree max)\n+value_range::set (enum value_range_kind kind, tree min, tree max)\n {\n   /* Use the canonical setters for VR_UNDEFINED and VR_VARYING.  */\n   if (kind == VR_UNDEFINED)\n@@ -876,7 +877,7 @@ value_range_base::set (enum value_range_kind kind, tree min, tree max)\n }\n \n void\n-value_range_base::set (tree val)\n+value_range::set (tree val)\n {\n   gcc_assert (TREE_CODE (val) == SSA_NAME || is_gimple_min_invariant (val));\n   if (TREE_OVERFLOW_P (val))\n@@ -885,7 +886,7 @@ value_range_base::set (tree val)\n }\n \n void\n-value_range::set (tree val)\n+value_range_equiv::set (tree val)\n {\n   gcc_assert (TREE_CODE (val) == SSA_NAME || is_gimple_min_invariant (val));\n   if (TREE_OVERFLOW_P (val))\n@@ -896,7 +897,7 @@ value_range::set (tree val)\n /* Set value range VR to a nonzero range of type TYPE.  */\n \n void\n-value_range_base::set_nonzero (tree type)\n+value_range::set_nonzero (tree type)\n {\n   tree zero = build_int_cst (type, 0);\n   set (VR_ANTI_RANGE, zero, zero);\n@@ -905,7 +906,7 @@ value_range_base::set_nonzero (tree type)\n /* Set value range VR to a ZERO range of type TYPE.  */\n \n void\n-value_range_base::set_zero (tree type)\n+value_range::set_zero (tree type)\n {\n   set (build_int_cst (type, 0));\n }\n@@ -923,7 +924,7 @@ vrp_operand_equal_p (const_tree val1, const_tree val2)\n }\n \n static bool\n-range_has_numeric_bounds_p (const value_range_base *vr)\n+range_has_numeric_bounds_p (const value_range *vr)\n {\n   return (vr->min ()\n \t  && TREE_CODE (vr->min ()) == INTEGER_CST\n@@ -934,7 +935,7 @@ range_has_numeric_bounds_p (const value_range_base *vr)\n    a singleton.  */\n \n bool\n-range_int_cst_p (const value_range_base *vr)\n+range_int_cst_p (const value_range *vr)\n {\n   return (vr->kind () == VR_RANGE && range_has_numeric_bounds_p (vr));\n }\n@@ -1234,7 +1235,7 @@ compare_values (tree val1, tree val2)\n    function.  */\n \n int\n-value_range_base::value_inside_range (tree val) const\n+value_range::value_inside_range (tree val) const\n {\n   int cmp1, cmp2;\n \n@@ -1266,8 +1267,8 @@ value_range_base::value_inside_range (tree val) const\n    *VR1 will be VR_UNDEFINED.  */\n \n static bool\n-ranges_from_anti_range (const value_range_base *ar,\n-\t\t\tvalue_range_base *vr0, value_range_base *vr1)\n+ranges_from_anti_range (const value_range *ar,\n+\t\t\tvalue_range *vr0, value_range *vr1)\n {\n   tree type = ar->type ();\n \n@@ -1488,11 +1489,11 @@ set_value_range_with_overflow (value_range_kind &kind, tree &min, tree &max,\n /* Fold two value range's of a POINTER_PLUS_EXPR into VR.  */\n \n static void\n-extract_range_from_pointer_plus_expr (value_range_base *vr,\n+extract_range_from_pointer_plus_expr (value_range *vr,\n \t\t\t\t      enum tree_code code,\n \t\t\t\t      tree expr_type,\n-\t\t\t\t      const value_range_base *vr0,\n-\t\t\t\t      const value_range_base *vr1)\n+\t\t\t\t      const value_range *vr0,\n+\t\t\t\t      const value_range *vr1)\n {\n   gcc_checking_assert (POINTER_TYPE_P (expr_type)\n \t\t       && code == POINTER_PLUS_EXPR);\n@@ -1528,16 +1529,16 @@ extract_range_from_pointer_plus_expr (value_range_base *vr,\n    result in *VR.  */\n \n static void\n-extract_range_from_plus_minus_expr (value_range_base *vr,\n+extract_range_from_plus_minus_expr (value_range *vr,\n \t\t\t\t    enum tree_code code,\n \t\t\t\t    tree expr_type,\n-\t\t\t\t    const value_range_base *vr0_,\n-\t\t\t\t    const value_range_base *vr1_)\n+\t\t\t\t    const value_range *vr0_,\n+\t\t\t\t    const value_range *vr1_)\n {\n   gcc_checking_assert (code == PLUS_EXPR || code == MINUS_EXPR);\n \n-  value_range_base vr0 = *vr0_, vr1 = *vr1_;\n-  value_range_base vrtem0, vrtem1;\n+  value_range vr0 = *vr0_, vr1 = *vr1_;\n+  value_range vrtem0, vrtem1;\n \n   /* Now canonicalize anti-ranges to ranges when they are not symbolic\n      and express ~[] op X as ([]' op X) U ([]'' op X).  */\n@@ -1547,7 +1548,7 @@ extract_range_from_plus_minus_expr (value_range_base *vr,\n       extract_range_from_plus_minus_expr (vr, code, expr_type, &vrtem0, vr1_);\n       if (!vrtem1.undefined_p ())\n \t{\n-\t  value_range_base vrres;\n+\t  value_range vrres;\n \t  extract_range_from_plus_minus_expr (&vrres, code, expr_type,\n \t\t\t\t\t      &vrtem1, vr1_);\n \t  vr->union_ (&vrres);\n@@ -1561,7 +1562,7 @@ extract_range_from_plus_minus_expr (value_range_base *vr,\n       extract_range_from_plus_minus_expr (vr, code, expr_type, vr0_, &vrtem0);\n       if (!vrtem1.undefined_p ())\n \t{\n-\t  value_range_base vrres;\n+\t  value_range vrres;\n \t  extract_range_from_plus_minus_expr (&vrres, code, expr_type,\n \t\t\t\t\t      vr0_, &vrtem1);\n \t  vr->union_ (&vrres);\n@@ -1710,7 +1711,7 @@ extract_range_from_plus_minus_expr (value_range_base *vr,\n    suitable operator is found, return NULL and set VR to VARYING.  */\n \n static const range_operator *\n-get_range_op_handler (value_range_base *vr,\n+get_range_op_handler (value_range *vr,\n \t\t      enum tree_code code,\n \t\t      tree expr_type)\n {\n@@ -1724,12 +1725,12 @@ get_range_op_handler (value_range_base *vr,\n    VARYING and return FALSE.  */\n \n static bool\n-supported_types_p (value_range_base *vr,\n+supported_types_p (value_range *vr,\n \t\t   tree type0,\n \t\t   tree type1 = NULL)\n {\n-  if (!value_range_base::supports_type_p (type0)\n-      || (type1 && !value_range_base::supports_type_p (type1)))\n+  if (!value_range::supports_type_p (type0)\n+      || (type1 && !value_range::supports_type_p (type1)))\n     {\n       vr->set_varying (type0);\n       return false;\n@@ -1741,9 +1742,9 @@ supported_types_p (value_range_base *vr,\n    VR to UNDEFINED and return FALSE.  */\n \n static bool\n-defined_ranges_p (value_range_base *vr,\n-\t\t  const value_range_base *vr0,\n-\t\t  const value_range_base *vr1 = NULL)\n+defined_ranges_p (value_range *vr,\n+\t\t  const value_range *vr0,\n+\t\t  const value_range *vr1 = NULL)\n {\n   if (vr0->undefined_p () && (!vr1 || vr1->undefined_p ()))\n     {\n@@ -1753,11 +1754,11 @@ defined_ranges_p (value_range_base *vr,\n   return true;\n }\n \n-static value_range_base\n-drop_undefines_to_varying (const value_range_base *vr, tree expr_type)\n+static value_range\n+drop_undefines_to_varying (const value_range *vr, tree expr_type)\n {\n   if (vr->undefined_p ())\n-    return value_range_base (expr_type);\n+    return value_range (expr_type);\n   else\n     return *vr;\n }\n@@ -1766,11 +1767,11 @@ drop_undefines_to_varying (const value_range_base *vr, tree expr_type)\n    return TRUE, otherwise return FALSE.  */\n \n static bool\n-range_fold_binary_symbolics_p (value_range_base *vr,\n+range_fold_binary_symbolics_p (value_range *vr,\n \t\t\t       tree_code code,\n \t\t\t       tree expr_type,\n-\t\t\t       const value_range_base *vr0,\n-\t\t\t       const value_range_base *vr1)\n+\t\t\t       const value_range *vr0,\n+\t\t\t       const value_range *vr1)\n {\n   if (vr0->symbolic_p () || vr1->symbolic_p ())\n     {\n@@ -1797,33 +1798,33 @@ range_fold_binary_symbolics_p (value_range_base *vr,\n    TRUE, otherwise return FALSE.  */\n \n static bool\n-range_fold_unary_symbolics_p (value_range_base *vr,\n+range_fold_unary_symbolics_p (value_range *vr,\n \t\t\t      tree_code code,\n \t\t\t      tree expr_type,\n-\t\t\t      const value_range_base *vr0)\n+\t\t\t      const value_range *vr0)\n {\n   if (vr0->symbolic_p ())\n     {\n       if (code == NEGATE_EXPR)\n \t{\n \t  /* -X is simply 0 - X.  */\n-\t  value_range_base zero;\n+\t  value_range zero;\n \t  zero.set_zero (vr0->type ());\n \t  range_fold_binary_expr (vr, MINUS_EXPR, expr_type, &zero, vr0);\n \t  return true;\n \t}\n       if (code == BIT_NOT_EXPR)\n \t{\n \t  /* ~X is simply -1 - X.  */\n-\t  value_range_base minusone;\n+\t  value_range minusone;\n \t  minusone.set (build_int_cst (vr0->type (), -1));\n \t  range_fold_binary_expr (vr, MINUS_EXPR, expr_type, &minusone, vr0);\n \t  return true;\n \t}\n       const range_operator *op = get_range_op_handler (vr, code, expr_type);\n       *vr = op->fold_range (expr_type,\n \t\t\t    vr0->normalize_symbolics (),\n-\t\t\t    value_range_base (expr_type));\n+\t\t\t    value_range (expr_type));\n       return true;\n     }\n   return false;\n@@ -1832,11 +1833,11 @@ range_fold_unary_symbolics_p (value_range_base *vr,\n /* Perform a binary operation on a pair of ranges.  */\n \n void\n-range_fold_binary_expr (value_range_base *vr,\n+range_fold_binary_expr (value_range *vr,\n \t\t\tenum tree_code code,\n \t\t\ttree expr_type,\n-\t\t\tconst value_range_base *vr0_,\n-\t\t\tconst value_range_base *vr1_)\n+\t\t\tconst value_range *vr0_,\n+\t\t\tconst value_range *vr1_)\n {\n   if (!supported_types_p (vr, expr_type)\n       || !defined_ranges_p (vr, vr0_, vr1_))\n@@ -1845,8 +1846,8 @@ range_fold_binary_expr (value_range_base *vr,\n   if (!op)\n     return;\n \n-  value_range_base vr0 = drop_undefines_to_varying (vr0_, expr_type);\n-  value_range_base vr1 = drop_undefines_to_varying (vr1_, expr_type);\n+  value_range vr0 = drop_undefines_to_varying (vr0_, expr_type);\n+  value_range vr1 = drop_undefines_to_varying (vr1_, expr_type);\n   if (range_fold_binary_symbolics_p (vr, code, expr_type, &vr0, &vr1))\n     return;\n \n@@ -1858,9 +1859,9 @@ range_fold_binary_expr (value_range_base *vr,\n /* Perform a unary operation on a range.  */\n \n void\n-range_fold_unary_expr (value_range_base *vr,\n+range_fold_unary_expr (value_range *vr,\n \t\t       enum tree_code code, tree expr_type,\n-\t\t       const value_range_base *vr0,\n+\t\t       const value_range *vr0,\n \t\t       tree vr0_type)\n {\n   if (!supported_types_p (vr, expr_type, vr0_type)\n@@ -1875,7 +1876,7 @@ range_fold_unary_expr (value_range_base *vr,\n \n   *vr = op->fold_range (expr_type,\n \t\t\tvr0->normalize_addresses (),\n-\t\t\tvalue_range_base (expr_type));\n+\t\t\tvalue_range (expr_type));\n }\n \n /* Given a COND_EXPR COND of the form 'V OP W', and an SSA name V,\n@@ -4054,20 +4055,20 @@ class vrp_prop : public ssa_propagation_engine\n \n   class vr_values vr_values;\n   /* Temporary delegator to minimize code churn.  */\n-  const value_range *get_value_range (const_tree op)\n+  const value_range_equiv *get_value_range (const_tree op)\n     { return vr_values.get_value_range (op); }\n   void set_def_to_varying (const_tree def)\n     { vr_values.set_def_to_varying (def); }\n   void set_defs_to_varying (gimple *stmt)\n     { vr_values.set_defs_to_varying (stmt); }\n   void extract_range_from_stmt (gimple *stmt, edge *taken_edge_p,\n-\t\t\t\ttree *output_p, value_range *vr)\n+\t\t\t\ttree *output_p, value_range_equiv *vr)\n     { vr_values.extract_range_from_stmt (stmt, taken_edge_p, output_p, vr); }\n-  bool update_value_range (const_tree op, value_range *vr)\n+  bool update_value_range (const_tree op, value_range_equiv *vr)\n     { return vr_values.update_value_range (op, vr); }\n-  void extract_range_basic (value_range *vr, gimple *stmt)\n+  void extract_range_basic (value_range_equiv *vr, gimple *stmt)\n     { vr_values.extract_range_basic (vr, stmt); }\n-  void extract_range_from_phi_node (gphi *phi, value_range *vr)\n+  void extract_range_from_phi_node (gphi *phi, value_range_equiv *vr)\n     { vr_values.extract_range_from_phi_node (phi, vr); }\n };\n /* Checks one ARRAY_REF in REF, located at LOCUS. Ignores flexible arrays\n@@ -4159,7 +4160,7 @@ vrp_prop::check_array_ref (location_t location, tree ref,\n \t\t\t \"array subscript %E is above array bounds of %qT\",\n \t\t\t low_bound, artype);\n \n-  const value_range *vr = NULL;\n+  const value_range_equiv *vr = NULL;\n   if (TREE_CODE (low_sub) == SSA_NAME)\n     {\n       vr = get_value_range (low_sub);\n@@ -4285,7 +4286,7 @@ vrp_prop::check_mem_ref (location_t location, tree ref,\n   /* The range of the byte offset into the reference.  */\n   offset_int offrange[2] = { 0, 0 };\n \n-  const value_range *vr = NULL;\n+  const value_range_equiv *vr = NULL;\n \n   /* Determine the offsets and increment OFFRANGE for the bounds of each.\n      The loop computes the range of the final offset for expressions such\n@@ -5124,7 +5125,7 @@ enum ssa_prop_result\n vrp_prop::visit_stmt (gimple *stmt, edge *taken_edge_p, tree *output_p)\n {\n   tree lhs = gimple_get_lhs (stmt);\n-  value_range vr;\n+  value_range_equiv vr;\n   extract_range_from_stmt (stmt, taken_edge_p, output_p, &vr);\n \n   if (*output_p)\n@@ -5193,9 +5194,9 @@ vrp_prop::visit_stmt (gimple *stmt, edge *taken_edge_p, tree *output_p)\n \t\t   SSA_PROP_NOT_INTERESTING.  If there are no\n \t\t   {REAL,IMAG}PART_EXPR uses at all,\n \t\t   return SSA_PROP_VARYING.  */\n-\t\tvalue_range new_vr;\n+\t\tvalue_range_equiv new_vr;\n \t\textract_range_basic (&new_vr, use_stmt);\n-\t\tconst value_range *old_vr = get_value_range (use_lhs);\n+\t\tconst value_range_equiv *old_vr = get_value_range (use_lhs);\n \t\tif (!old_vr->equal_p (new_vr, /*ignore_equivs=*/false))\n \t\t  res = SSA_PROP_INTERESTING;\n \t\telse\n@@ -5825,9 +5826,9 @@ intersect_ranges (enum value_range_kind *vr0type,\n    value ranges VR0 and VR1, return the intersection of the two\n    ranges.  This may not be the smallest possible such range.  */\n \n-value_range_base\n-value_range_base::intersect_helper (const value_range_base *vr0,\n-\t\t\t\t    const value_range_base *vr1)\n+value_range\n+value_range::intersect_helper (const value_range *vr0,\n+\t\t\t\t    const value_range *vr1)\n {\n   /* If either range is VR_VARYING the other one wins.  */\n   if (vr1->varying_p ())\n@@ -5850,7 +5851,7 @@ value_range_base::intersect_helper (const value_range_base *vr0,\n   /* Make sure to canonicalize the result though as the inversion of a\n      VR_RANGE can still be a VR_RANGE.  Work on a temporary so we can\n      fall back to vr0 when this turns things to varying.  */\n-  value_range_base tem;\n+  value_range tem;\n   if (vr0type == VR_UNDEFINED)\n     tem.set_undefined ();\n   else if (vr0type == VR_VARYING)\n@@ -5865,7 +5866,7 @@ value_range_base::intersect_helper (const value_range_base *vr0,\n }\n \n void\n-value_range_base::intersect (const value_range_base *other)\n+value_range::intersect (const value_range *other)\n {\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -5887,7 +5888,7 @@ value_range_base::intersect (const value_range_base *other)\n }\n \n void\n-value_range::intersect (const value_range *other)\n+value_range_equiv::intersect (const value_range_equiv *other)\n {\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -5905,7 +5906,7 @@ value_range::intersect (const value_range *other)\n     this->deep_copy (other);\n   else\n     {\n-      value_range_base tem = intersect_helper (this, other);\n+      value_range tem = intersect_helper (this, other);\n       this->update (tem.kind (), tem.min (), tem.max ());\n \n       /* If the result is VR_UNDEFINED there is no need to mess with\n@@ -5939,9 +5940,9 @@ value_range::intersect (const value_range *other)\n    VR1, return a range that contains both VR0 and VR1.  This may not be the\n    smallest possible such range.  */\n \n-value_range_base\n-value_range_base::union_helper (const value_range_base *vr0,\n-\t\t\t\tconst value_range_base *vr1)\n+value_range\n+value_range::union_helper (const value_range *vr0,\n+\t\t\t\tconst value_range *vr1)\n {\n   /* VR0 has the resulting range if VR1 is undefined or VR0 is varying.  */\n   if (vr1->undefined_p ()\n@@ -5960,7 +5961,7 @@ value_range_base::union_helper (const value_range_base *vr0,\n \t\tvr1->kind (), vr1->min (), vr1->max ());\n \n   /* Work on a temporary so we can still use vr0 when union returns varying.  */\n-  value_range_base tem;\n+  value_range tem;\n   if (vr0type == VR_UNDEFINED)\n     tem.set_undefined ();\n   else if (vr0type == VR_VARYING)\n@@ -5988,7 +5989,7 @@ value_range_base::union_helper (const value_range_base *vr0,\n    may not be the smallest possible such range.  */\n \n void\n-value_range_base::union_ (const value_range_base *other)\n+value_range::union_ (const value_range *other)\n {\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -6010,7 +6011,7 @@ value_range_base::union_ (const value_range_base *other)\n }\n \n void\n-value_range::union_ (const value_range *other)\n+value_range_equiv::union_ (const value_range_equiv *other)\n {\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -6027,7 +6028,7 @@ value_range::union_ (const value_range *other)\n     this->deep_copy (other);\n   else\n     {\n-      value_range_base tem = union_helper (this, other);\n+      value_range tem = union_helper (this, other);\n       this->update (tem.kind (), tem.min (), tem.max ());\n \n       /* The resulting set of equivalences is always the intersection of\n@@ -6048,8 +6049,8 @@ value_range::union_ (const value_range *other)\n \n /* Normalize addresses into constants.  */\n \n-value_range_base\n-value_range_base::normalize_addresses () const\n+value_range\n+value_range::normalize_addresses () const\n {\n   if (undefined_p ())\n     return *this;\n@@ -6063,13 +6064,13 @@ value_range_base::normalize_addresses () const\n \t\t\t   || TREE_CODE (m_max) == ADDR_EXPR);\n       return range_nonzero (type ());\n     }\n-  return value_range_base (type ());\n+  return value_range (type ());\n }\n \n /* Normalize symbolics and addresses into constants.  */\n \n-value_range_base\n-value_range_base::normalize_symbolics () const\n+value_range\n+value_range::normalize_symbolics () const\n {\n   if (varying_p () || undefined_p ())\n     return *this;\n@@ -6082,17 +6083,17 @@ value_range_base::normalize_symbolics () const\n   // [SYM, SYM] -> VARYING\n   if (min_symbolic && max_symbolic)\n     {\n-      value_range_base var;\n+      value_range var;\n       var.set_varying (ttype);\n       return var;\n     }\n   if (kind () == VR_RANGE)\n     {\n       // [SYM, NUM] -> [-MIN, NUM]\n       if (min_symbolic)\n-\treturn value_range_base (VR_RANGE, vrp_val_min (ttype), max ());\n+\treturn value_range (VR_RANGE, vrp_val_min (ttype), max ());\n       // [NUM, SYM] -> [NUM, +MAX]\n-      return value_range_base (VR_RANGE, min (), vrp_val_max (ttype));\n+      return value_range (VR_RANGE, min (), vrp_val_max (ttype));\n     }\n   gcc_checking_assert (kind () == VR_ANTI_RANGE);\n   // ~[SYM, NUM] -> [NUM + 1, +MAX]\n@@ -6101,27 +6102,27 @@ value_range_base::normalize_symbolics () const\n       if (!vrp_val_is_max (max ()))\n \t{\n \t  tree n = wide_int_to_tree (ttype, wi::to_wide (max ()) + 1);\n-\t  return value_range_base (VR_RANGE, n, vrp_val_max (ttype));\n+\t  return value_range (VR_RANGE, n, vrp_val_max (ttype));\n \t}\n-      value_range_base var;\n+      value_range var;\n       var.set_varying (ttype);\n       return var;\n     }\n   // ~[NUM, SYM] -> [-MIN, NUM - 1]\n   if (!vrp_val_is_min (min ()))\n     {\n       tree n = wide_int_to_tree (ttype, wi::to_wide (min ()) - 1);\n-      return value_range_base (VR_RANGE, vrp_val_min (ttype), n);\n+      return value_range (VR_RANGE, vrp_val_min (ttype), n);\n     }\n-  value_range_base var;\n+  value_range var;\n   var.set_varying (ttype);\n   return var;\n }\n \n /* Return the number of sub-ranges in a range.  */\n \n unsigned\n-value_range_base::num_pairs () const\n+value_range::num_pairs () const\n {\n   if (undefined_p ())\n     return 0;\n@@ -6144,7 +6145,7 @@ value_range_base::num_pairs () const\n    question.  */\n \n wide_int\n-value_range_base::lower_bound (unsigned pair) const\n+value_range::lower_bound (unsigned pair) const\n {\n   if (symbolic_p ())\n     return normalize_symbolics ().lower_bound (pair);\n@@ -6169,7 +6170,7 @@ value_range_base::lower_bound (unsigned pair) const\n    question.  */\n \n wide_int\n-value_range_base::upper_bound (unsigned pair) const\n+value_range::upper_bound (unsigned pair) const\n {\n   if (symbolic_p ())\n     return normalize_symbolics ().upper_bound (pair);\n@@ -6193,7 +6194,7 @@ value_range_base::upper_bound (unsigned pair) const\n /* Return the highest bound in a range.  */\n \n wide_int\n-value_range_base::upper_bound () const\n+value_range::upper_bound () const\n {\n   unsigned pairs = num_pairs ();\n   gcc_checking_assert (pairs > 0);\n@@ -6203,7 +6204,7 @@ value_range_base::upper_bound () const\n /* Return TRUE if range contains INTEGER_CST.  */\n \n bool\n-value_range_base::contains_p (tree cst) const\n+value_range::contains_p (tree cst) const\n {\n   gcc_checking_assert (TREE_CODE (cst) == INTEGER_CST);\n   if (symbolic_p ())\n@@ -6214,22 +6215,22 @@ value_range_base::contains_p (tree cst) const\n /* Return the inverse of a range.  */\n \n void\n-value_range_base::invert ()\n+value_range::invert ()\n {\n   /* We can't just invert VR_RANGE and VR_ANTI_RANGE because we may\n      create non-canonical ranges.  Use the constructors instead.  */\n   if (m_kind == VR_RANGE)\n-    *this = value_range_base (VR_ANTI_RANGE, m_min, m_max);\n+    *this = value_range (VR_ANTI_RANGE, m_min, m_max);\n   else if (m_kind == VR_ANTI_RANGE)\n-    *this = value_range_base (VR_RANGE, m_min, m_max);\n+    *this = value_range (VR_RANGE, m_min, m_max);\n   else\n     gcc_unreachable ();\n }\n \n /* Range union, but for references.  */\n \n void\n-value_range_base::union_ (const value_range_base &r)\n+value_range::union_ (const value_range &r)\n {\n   /* Disable details for now, because it makes the ranger dump\n      unnecessarily verbose.  */\n@@ -6244,7 +6245,7 @@ value_range_base::union_ (const value_range_base &r)\n /* Range intersect, but for references.  */\n \n void\n-value_range_base::intersect (const value_range_base &r)\n+value_range::intersect (const value_range &r)\n {\n   /* Disable details for now, because it makes the ranger dump\n      unnecessarily verbose.  */\n@@ -6257,7 +6258,7 @@ value_range_base::intersect (const value_range_base &r)\n }\n \n bool\n-value_range_base::operator== (const value_range_base &r) const\n+value_range::operator== (const value_range &r) const\n {\n   return equal_p (r);\n }\n@@ -6270,7 +6271,7 @@ enum ssa_prop_result\n vrp_prop::visit_phi (gphi *phi)\n {\n   tree lhs = PHI_RESULT (phi);\n-  value_range vr_result;\n+  value_range_equiv vr_result;\n   extract_range_from_phi_node (phi, &vr_result);\n   if (update_value_range (lhs, &vr_result))\n     {\n@@ -6467,7 +6468,7 @@ simplify_stmt_for_jump_threading (gimple *stmt, gimple *within_stmt,\n \n       op = lhs_of_dominating_assert (op, bb, stmt);\n \n-      const value_range *vr = vr_values->get_value_range (op);\n+      const value_range_equiv *vr = vr_values->get_value_range (op);\n       if (vr->undefined_p ()\n \t  || vr->varying_p ()\n \t  || vr->symbolic_p ())\n@@ -6533,7 +6534,7 @@ simplify_stmt_for_jump_threading (gimple *stmt, gimple *within_stmt,\n \t{\n \t  edge dummy_e;\n \t  tree dummy_tree;\n-\t  value_range new_vr;\n+\t  value_range_equiv new_vr;\n \t  vr_values->extract_range_from_stmt (stmt, &dummy_e,\n \t\t\t\t\t      &dummy_tree, &new_vr);\n \t  tree singleton;\n@@ -6709,7 +6710,7 @@ vrp_prop::vrp_finalize (bool warn_array_bounds_p)\n       if (!name)\n \tcontinue;\n \n-      const value_range *vr = get_value_range (name);\n+      const value_range_equiv *vr = get_value_range (name);\n       if (!name || !vr->constant_p ())\n \tcontinue;\n \n@@ -6905,19 +6906,19 @@ make_pass_vrp (gcc::context *ctxt)\n /* Worker for determine_value_range.  */\n \n static void\n-determine_value_range_1 (value_range_base *vr, tree expr)\n+determine_value_range_1 (value_range *vr, tree expr)\n {\n   if (BINARY_CLASS_P (expr))\n     {\n-      value_range_base vr0, vr1;\n+      value_range vr0, vr1;\n       determine_value_range_1 (&vr0, TREE_OPERAND (expr, 0));\n       determine_value_range_1 (&vr1, TREE_OPERAND (expr, 1));\n       range_fold_binary_expr (vr, TREE_CODE (expr), TREE_TYPE (expr),\n \t\t\t      &vr0, &vr1);\n     }\n   else if (UNARY_CLASS_P (expr))\n     {\n-      value_range_base vr0;\n+      value_range vr0;\n       determine_value_range_1 (&vr0, TREE_OPERAND (expr, 0));\n       range_fold_unary_expr (vr, TREE_CODE (expr), TREE_TYPE (expr),\n \t\t\t     &vr0, TREE_TYPE (TREE_OPERAND (expr, 0)));\n@@ -6946,7 +6947,7 @@ determine_value_range_1 (value_range_base *vr, tree expr)\n value_range_kind\n determine_value_range (tree expr, wide_int *min, wide_int *max)\n {\n-  value_range_base vr;\n+  value_range vr;\n   determine_value_range_1 (&vr, expr);\n   if (vr.constant_p ())\n     {"}, {"sha": "ff01c2abd50c59b2824c7b18775aea9f7ca65077", "filename": "gcc/tree-vrp.h", "status": "modified", "additions": 65, "deletions": 65, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Ftree-vrp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Ftree-vrp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.h?ref=028d81b1599c365d8c60222ec5631a8f111d8574", "patch": "@@ -37,17 +37,17 @@ enum value_range_kind\n \n /* Range of values that can be associated with an SSA_NAME after VRP\n    has executed.  */\n-class GTY((for_user)) value_range_base\n+class GTY((for_user)) value_range\n {\n   friend void range_tests ();\n public:\n-  value_range_base ();\n-  value_range_base (value_range_kind, tree, tree);\n-  value_range_base (tree, tree);\n-  value_range_base (value_range_kind,\n-\t\t    tree type, const wide_int &, const wide_int &);\n-  value_range_base (tree type, const wide_int &, const wide_int &);\n-  value_range_base (tree type);\n+  value_range ();\n+  value_range (value_range_kind, tree, tree);\n+  value_range (tree, tree);\n+  value_range (value_range_kind,\n+\t       tree type, const wide_int &, const wide_int &);\n+  value_range (tree type, const wide_int &, const wide_int &);\n+  value_range (tree type);\n \n   void set (value_range_kind, tree, tree);\n   void set (tree);\n@@ -66,14 +66,14 @@ class GTY((for_user)) value_range_base\n   void set_varying (tree type);\n   void set_undefined ();\n \n-  void union_ (const value_range_base *);\n-  void intersect (const value_range_base *);\n-  void union_ (const value_range_base &);\n-  void intersect (const value_range_base &);\n+  void union_ (const value_range *);\n+  void intersect (const value_range *);\n+  void union_ (const value_range &);\n+  void intersect (const value_range &);\n \n-  bool operator== (const value_range_base &) const;\n-  bool operator!= (const value_range_base &) const /* = delete */;\n-  bool equal_p (const value_range_base &) const;\n+  bool operator== (const value_range &) const;\n+  bool operator!= (const value_range &) const /* = delete */;\n+  bool equal_p (const value_range &) const;\n \n   /* Misc methods.  */\n   tree type () const;\n@@ -85,8 +85,8 @@ class GTY((for_user)) value_range_base\n   void dump () const;\n \n   static bool supports_type_p (tree);\n-  value_range_base normalize_symbolics () const;\n-  value_range_base normalize_addresses () const;\n+  value_range normalize_symbolics () const;\n+  value_range normalize_addresses () const;\n \n   static const unsigned int m_max_pairs = 2;\n   bool contains_p (tree) const;\n@@ -98,58 +98,57 @@ class GTY((for_user)) value_range_base\n \n protected:\n   void check ();\n-  static value_range_base union_helper (const value_range_base *,\n-\t\t\t\t\tconst value_range_base *);\n-  static value_range_base intersect_helper (const value_range_base *,\n-\t\t\t\t\t    const value_range_base *);\n+  static value_range union_helper (const value_range *, const value_range *);\n+  static value_range intersect_helper (const value_range *,\n+\t\t\t\t       const value_range *);\n \n   enum value_range_kind m_kind;\n \n   tree m_min;\n   tree m_max;\n \n-  friend void gt_ggc_mx_value_range_base (void *);\n-  friend void gt_pch_p_16value_range_base (void *, void *,\n-\t\t\t\t\t   gt_pointer_operator, void *);\n-  friend void gt_pch_nx_value_range_base (void *);\n-  friend void gt_ggc_mx (value_range_base &);\n-  friend void gt_ggc_mx (value_range_base *&);\n-  friend void gt_pch_nx (value_range_base &);\n-  friend void gt_pch_nx (value_range_base *, gt_pointer_operator, void *);\n+  friend void gt_ggc_mx_value_range (void *);\n+  friend void gt_pch_p_11value_range (void *, void *,\n+\t\t\t\t      gt_pointer_operator, void *);\n+  friend void gt_pch_nx_value_range (void *);\n+  friend void gt_ggc_mx (value_range &);\n+  friend void gt_ggc_mx (value_range *&);\n+  friend void gt_pch_nx (value_range &);\n+  friend void gt_pch_nx (value_range *, gt_pointer_operator, void *);\n \n private:\n   int value_inside_range (tree) const;\n };\n \n-/* Note value_range cannot currently be used with GC memory, only\n-   value_range_base is fully set up for this.  */\n-class GTY((user)) value_range : public value_range_base\n+/* Note value_range_equiv cannot currently be used with GC memory,\n+   only value_range is fully set up for this.  */\n+class GTY((user)) value_range_equiv : public value_range\n {\n  public:\n-  value_range ();\n-  value_range (const value_range_base &);\n+  value_range_equiv ();\n+  value_range_equiv (const value_range &);\n   /* Deep-copies equiv bitmap argument.  */\n-  value_range (value_range_kind, tree, tree, bitmap = NULL);\n+  value_range_equiv (value_range_kind, tree, tree, bitmap = NULL);\n \n   /* Shallow-copies equiv bitmap.  */\n-  value_range (const value_range &) /* = delete */;\n+  value_range_equiv (const value_range_equiv &) /* = delete */;\n   /* Shallow-copies equiv bitmap.  */\n-  value_range& operator=(const value_range&) /* = delete */;\n+  value_range_equiv& operator=(const value_range_equiv &) /* = delete */;\n \n   /* Move equiv bitmap from source range.  */\n-  void move (value_range *);\n+  void move (value_range_equiv *);\n \n   /* Leaves equiv bitmap alone.  */\n   void update (value_range_kind, tree, tree);\n   /* Deep-copies equiv bitmap argument.  */\n   void set (value_range_kind, tree, tree, bitmap = NULL);\n   void set (tree);\n \n-  bool operator== (const value_range &) const /* = delete */;\n-  bool operator!= (const value_range &) const /* = delete */;\n-  void intersect (const value_range *);\n-  void union_ (const value_range *);\n-  bool equal_p (const value_range &, bool ignore_equivs) const;\n+  bool operator== (const value_range_equiv &) const /* = delete */;\n+  bool operator!= (const value_range_equiv &) const /* = delete */;\n+  void intersect (const value_range_equiv *);\n+  void union_ (const value_range_equiv *);\n+  bool equal_p (const value_range_equiv &, bool ignore_equivs) const;\n \n   /* Types of value ranges.  */\n   void set_undefined ();\n@@ -158,10 +157,11 @@ class GTY((user)) value_range : public value_range_base\n   /* Equivalence bitmap methods.  */\n   bitmap equiv () const;\n   void equiv_clear ();\n-  void equiv_add (const_tree, const value_range *, bitmap_obstack * = NULL);\n+  void equiv_add (const_tree, const value_range_equiv *,\n+\t\t  bitmap_obstack * = NULL);\n \n   /* Misc methods.  */\n-  void deep_copy (const value_range *);\n+  void deep_copy (const value_range_equiv *);\n   void dump (FILE *) const;\n   void dump () const;\n \n@@ -176,77 +176,77 @@ class GTY((user)) value_range : public value_range_base\n };\n \n inline\n-value_range_base::value_range_base ()\n+value_range::value_range ()\n {\n   m_kind = VR_UNDEFINED;\n   m_min = m_max = NULL;\n }\n \n inline\n-value_range::value_range ()\n-  : value_range_base ()\n+value_range_equiv::value_range_equiv ()\n+  : value_range ()\n {\n   m_equiv = NULL;\n }\n \n /* Return the kind of this range.  */\n \n inline value_range_kind\n-value_range_base::kind () const\n+value_range::kind () const\n {\n   return m_kind;\n }\n \n inline bitmap\n-value_range::equiv () const\n+value_range_equiv::equiv () const\n {\n   return m_equiv;\n }\n \n /* Return the lower bound.  */\n \n inline tree\n-value_range_base::min () const\n+value_range::min () const\n {\n   return m_min;\n }\n \n /* Return the upper bound.  */\n \n inline tree\n-value_range_base::max () const\n+value_range::max () const\n {\n   return m_max;\n }\n \n /* Return TRUE if range spans the entire possible domain.  */\n \n inline bool\n-value_range_base::varying_p () const\n+value_range::varying_p () const\n {\n   return m_kind == VR_VARYING;\n }\n \n /* Return TRUE if range is undefined (essentially the empty set).  */\n \n inline bool\n-value_range_base::undefined_p () const\n+value_range::undefined_p () const\n {\n   return m_kind == VR_UNDEFINED;\n }\n \n /* Return TRUE if range is the constant zero.  */\n \n inline bool\n-value_range_base::zero_p () const\n+value_range::zero_p () const\n {\n   return (m_kind == VR_RANGE\n \t  && integer_zerop (m_min)\n \t  && integer_zerop (m_max));\n }\n \n+extern void dump_value_range (FILE *, const value_range_equiv *);\n extern void dump_value_range (FILE *, const value_range *);\n-extern void dump_value_range (FILE *, const value_range_base *);\n \n struct assert_info\n {\n@@ -267,7 +267,7 @@ struct assert_info\n // Otherwise return FALSE.\n \n inline bool\n-value_range_base::supports_type_p (tree type)\n+value_range::supports_type_p (tree type)\n {\n   if (type && (INTEGRAL_TYPE_P (type) || POINTER_TYPE_P (type)))\n     return type;\n@@ -279,7 +279,7 @@ extern void register_edge_assert_for (tree, edge, enum tree_code,\n extern bool stmt_interesting_for_vrp (gimple *);\n extern bool infer_value_range (gimple *, tree, tree_code *, tree *);\n \n-extern bool range_int_cst_p (const value_range_base *);\n+extern bool range_int_cst_p (const value_range *);\n \n extern int compare_values (tree, tree);\n extern int compare_values_warnv (tree, tree, bool *);\n@@ -290,11 +290,11 @@ extern bool vrp_val_is_max (const_tree);\n extern tree vrp_val_min (const_tree);\n extern tree vrp_val_max (const_tree);\n \n-void range_fold_unary_expr (value_range_base *, enum tree_code, tree type,\n-\t\t\t    const value_range_base *, tree op0_type);\n-void range_fold_binary_expr (value_range_base *, enum tree_code, tree type,\n-\t\t\t     const value_range_base *,\n-\t\t\t     const value_range_base *);\n+void range_fold_unary_expr (value_range *, enum tree_code, tree type,\n+\t\t\t    const value_range *, tree op0_type);\n+void range_fold_binary_expr (value_range *, enum tree_code, tree type,\n+\t\t\t     const value_range *,\n+\t\t\t     const value_range *);\n \n extern bool vrp_operand_equal_p (const_tree, const_tree);\n extern enum value_range_kind intersect_range_with_nonzero_bits\n@@ -310,7 +310,7 @@ extern value_range_kind determine_value_range (tree, wide_int *, wide_int *);\n /* Return TRUE if range is nonzero.  */\n \n inline bool\n-value_range_base::nonzero_p () const\n+value_range::nonzero_p () const\n {\n   if (m_kind == VR_ANTI_RANGE\n       && !TYPE_UNSIGNED (type ())\n@@ -327,7 +327,7 @@ value_range_base::nonzero_p () const\n /* Return TRUE if *VR includes the value zero.  */\n \n inline bool\n-range_includes_zero_p (const value_range_base *vr)\n+range_includes_zero_p (const value_range *vr)\n {\n   if (vr->undefined_p ())\n     return false;"}, {"sha": "b970339d0e076dc579df00b8bedabde2dd0b3ad3", "filename": "gcc/vr-values.c", "status": "modified", "additions": 124, "deletions": 136, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Fvr-values.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Fvr-values.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.c?ref=028d81b1599c365d8c60222ec5631a8f111d8574", "patch": "@@ -54,7 +54,7 @@ along with GCC; see the file COPYING3.  If not see\n /* Set value range VR to a non-negative range of type TYPE.  */\n \n static inline void\n-set_value_range_to_nonnegative (value_range *vr, tree type)\n+set_value_range_to_nonnegative (value_range_equiv *vr, tree type)\n {\n   tree zero = build_int_cst (type, 0);\n   vr->update (VR_RANGE, zero, vrp_val_max (type));\n@@ -63,7 +63,7 @@ set_value_range_to_nonnegative (value_range *vr, tree type)\n /* Set value range VR to a range of a truthvalue of type TYPE.  */\n \n static inline void\n-set_value_range_to_truthvalue (value_range *vr, tree type)\n+set_value_range_to_truthvalue (value_range_equiv *vr, tree type)\n {\n   if (TYPE_PRECISION (type) == 1)\n     vr->set_varying (type);\n@@ -74,10 +74,10 @@ set_value_range_to_truthvalue (value_range *vr, tree type)\n /* Return the lattice entry for VAR or NULL if it doesn't exist or cannot\n    be initialized.  */\n \n-value_range *\n+value_range_equiv *\n vr_values::get_lattice_entry (const_tree var)\n {\n-  value_range *vr;\n+  value_range_equiv *vr;\n   tree sym;\n   unsigned ver = SSA_NAME_VERSION (var);\n \n@@ -145,21 +145,21 @@ vr_values::get_lattice_entry (const_tree var)\n    If we have no values ranges recorded (ie, VRP is not running), then\n    return NULL.  Otherwise create an empty range if none existed for VAR.  */\n \n-const value_range *\n+const value_range_equiv *\n vr_values::get_value_range (const_tree var)\n {\n   /* If we have no recorded ranges, then return NULL.  */\n   if (!vr_value)\n     return NULL;\n \n-  value_range *vr = get_lattice_entry (var);\n+  value_range_equiv *vr = get_lattice_entry (var);\n \n   /* Reallocate the lattice if needed.  */\n   if (!vr)\n     {\n       unsigned int old_sz = num_vr_values;\n       num_vr_values = num_ssa_names + num_ssa_names / 10;\n-      vr_value = XRESIZEVEC (value_range *, vr_value, num_vr_values);\n+      vr_value = XRESIZEVEC (value_range_equiv *, vr_value, num_vr_values);\n       for ( ; old_sz < num_vr_values; old_sz++)\n         vr_value [old_sz] = NULL;\n \n@@ -176,7 +176,7 @@ vr_values::get_value_range (const_tree var)\n void\n vr_values::set_def_to_varying (const_tree def)\n {\n-  value_range *vr = get_lattice_entry (def);\n+  value_range_equiv *vr = get_lattice_entry (def);\n   if (vr)\n     vr->set_varying (TREE_TYPE (def));\n }\n@@ -203,18 +203,18 @@ vr_values::set_defs_to_varying (gimple *stmt)\n    is the range object associated with another SSA name.  */\n \n bool\n-vr_values::update_value_range (const_tree var, value_range *new_vr)\n+vr_values::update_value_range (const_tree var, value_range_equiv *new_vr)\n {\n-  value_range *old_vr;\n+  value_range_equiv *old_vr;\n   bool is_new;\n \n   /* If there is a value-range on the SSA name from earlier analysis\n      factor that in.  */\n   if (INTEGRAL_TYPE_P (TREE_TYPE (var)))\n     {\n-      value_range nr;\n-      value_range_kind rtype = get_range_info (var, nr);\n-      if (rtype == VR_RANGE || rtype == VR_ANTI_RANGE)\n+      value_range_equiv nr;\n+      get_range_info (var, nr);\n+      if (!nr.undefined_p ())\n \tnew_vr->intersect (&nr);\n     }\n \n@@ -258,7 +258,7 @@ vr_values::update_value_range (const_tree var, value_range *new_vr)\n /* Return true if value range VR involves exactly one symbol SYM.  */\n \n static bool\n-symbolic_range_based_on_p (value_range_base *vr, const_tree sym)\n+symbolic_range_based_on_p (value_range *vr, const_tree sym)\n {\n   bool neg, min_has_symbol, max_has_symbol;\n   tree inv;\n@@ -377,7 +377,8 @@ vr_values::vrp_stmt_computes_nonzero (gimple *stmt)\n \t      || (flag_delete_null_pointer_checks\n \t\t  && !TYPE_OVERFLOW_WRAPS (TREE_TYPE (expr))))\n \t    {\n-\t      const value_range *vr = get_value_range (TREE_OPERAND (base, 0));\n+\t      const value_range_equiv *vr\n+\t\t= get_value_range (TREE_OPERAND (base, 0));\n \t      if (!range_includes_zero_p (vr))\n \t\treturn true;\n \t    }\n@@ -436,7 +437,7 @@ vr_values::op_with_constant_singleton_value_range (tree op)\n bool\n vr_values::op_with_boolean_value_range_p (tree op)\n {\n-  const value_range *vr;\n+  const value_range_equiv *vr;\n \n   if (TYPE_PRECISION (TREE_TYPE (op)) == 1)\n     return true;\n@@ -461,10 +462,10 @@ void\n vr_values::extract_range_for_var_from_comparison_expr (tree var,\n \t\t\t\t\t\t       enum tree_code cond_code,\n \t\t\t\t\t\t       tree op, tree limit,\n-\t\t\t\t\t\t       value_range *vr_p)\n+\t\t\t\t\t\t       value_range_equiv *vr_p)\n {\n   tree  min, max, type;\n-  const value_range *limit_vr;\n+  const value_range_equiv *limit_vr;\n   type = TREE_TYPE (var);\n \n   /* For pointer arithmetic, we only keep track of pointer equality\n@@ -538,7 +539,7 @@ vr_values::extract_range_for_var_from_comparison_expr (tree var,\n          vice-versa.  Use set_and_canonicalize which does this for\n          us.  */\n       if (cond_code == LE_EXPR)\n-        vr_p->set (VR_RANGE, min, max, vr_p->equiv ());\n+\tvr_p->set (VR_RANGE, min, max, vr_p->equiv ());\n       else if (cond_code == GT_EXPR)\n         vr_p->set (VR_ANTI_RANGE, min, max, vr_p->equiv ());\n       else\n@@ -705,7 +706,7 @@ vr_values::extract_range_for_var_from_comparison_expr (tree var,\n    it in *VR_P.  */\n \n void\n-vr_values::extract_range_from_assert (value_range *vr_p, tree expr)\n+vr_values::extract_range_from_assert (value_range_equiv *vr_p, tree expr)\n {\n   tree var = ASSERT_EXPR_VAR (expr);\n   tree cond = ASSERT_EXPR_COND (expr);\n@@ -751,9 +752,9 @@ vr_values::extract_range_from_assert (value_range *vr_p, tree expr)\n     always false.  */\n \n void\n-vr_values::extract_range_from_ssa_name (value_range *vr, tree var)\n+vr_values::extract_range_from_ssa_name (value_range_equiv *vr, tree var)\n {\n-  const value_range *var_vr = get_value_range (var);\n+  const value_range_equiv *var_vr = get_value_range (var);\n \n   if (!var_vr->varying_p ())\n     vr->deep_copy (var_vr);\n@@ -769,13 +770,13 @@ vr_values::extract_range_from_ssa_name (value_range *vr, tree var)\n    The resulting range is stored in *VR.  */\n \n void\n-vr_values::extract_range_from_binary_expr (value_range *vr,\n+vr_values::extract_range_from_binary_expr (value_range_equiv *vr,\n \t\t\t\t\t   enum tree_code code,\n \t\t\t\t\t   tree expr_type, tree op0, tree op1)\n {\n   /* Get value ranges for each operand.  For constant operands, create\n      a new value range with the operand to simplify processing.  */\n-  value_range_base vr0, vr1;\n+  value_range vr0, vr1;\n   if (TREE_CODE (op0) == SSA_NAME)\n     vr0 = *(get_value_range (op0));\n   else if (is_gimple_min_invariant (op0))\n@@ -796,13 +797,9 @@ vr_values::extract_range_from_binary_expr (value_range *vr,\n       && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (op0)))\n     {\n       if (vr0.varying_p () && !vr1.varying_p ())\n-\tvr0 = value_range (VR_RANGE,\n-\t\t\t   vrp_val_min (expr_type),\n-\t\t\t   vrp_val_max (expr_type));\n+\tvr0 = value_range (vrp_val_min (expr_type), vrp_val_max (expr_type));\n       else if (vr1.varying_p () && !vr0.varying_p ())\n-\tvr1 = value_range (VR_RANGE,\n-\t\t\t   vrp_val_min (expr_type),\n-\t\t\t   vrp_val_max (expr_type));\n+\tvr1 = value_range (vrp_val_min (expr_type), vrp_val_max (expr_type));\n     }\n \n   range_fold_binary_expr (vr, code, expr_type, &vr0, &vr1);\n@@ -917,10 +914,11 @@ vr_values::extract_range_from_binary_expr (value_range *vr,\n    The resulting range is stored in *VR.  */\n \n void\n-vr_values::extract_range_from_unary_expr (value_range *vr, enum tree_code code,\n+vr_values::extract_range_from_unary_expr (value_range_equiv *vr,\n+\t\t\t\t\t  enum tree_code code,\n \t\t\t\t\t  tree type, tree op0)\n {\n-  value_range_base vr0;\n+  value_range vr0;\n \n   /* Get value ranges for the operand.  For constant operands, create\n      a new value range with the operand to simplify processing.  */\n@@ -939,13 +937,13 @@ vr_values::extract_range_from_unary_expr (value_range *vr, enum tree_code code,\n    the ranges of each of its operands and the expression code.  */\n \n void\n-vr_values::extract_range_from_cond_expr (value_range *vr, gassign *stmt)\n+vr_values::extract_range_from_cond_expr (value_range_equiv *vr, gassign *stmt)\n {\n   /* Get value ranges for each operand.  For constant operands, create\n      a new value range with the operand to simplify processing.  */\n   tree op0 = gimple_assign_rhs2 (stmt);\n-  value_range tem0;\n-  const value_range *vr0 = &tem0;\n+  value_range_equiv tem0;\n+  const value_range_equiv *vr0 = &tem0;\n   if (TREE_CODE (op0) == SSA_NAME)\n     vr0 = get_value_range (op0);\n   else if (is_gimple_min_invariant (op0))\n@@ -954,8 +952,8 @@ vr_values::extract_range_from_cond_expr (value_range *vr, gassign *stmt)\n     tem0.set_varying (TREE_TYPE (op0));\n \n   tree op1 = gimple_assign_rhs3 (stmt);\n-  value_range tem1;\n-  const value_range *vr1 = &tem1;\n+  value_range_equiv tem1;\n+  const value_range_equiv *vr1 = &tem1;\n   if (TREE_CODE (op1) == SSA_NAME)\n     vr1 = get_value_range (op1);\n   else if (is_gimple_min_invariant (op1))\n@@ -973,7 +971,8 @@ vr_values::extract_range_from_cond_expr (value_range *vr, gassign *stmt)\n    on the range of its operand and the expression code.  */\n \n void\n-vr_values::extract_range_from_comparison (value_range *vr, enum tree_code code,\n+vr_values::extract_range_from_comparison (value_range_equiv *vr,\n+\t\t\t\t\t  enum tree_code code,\n \t\t\t\t\t  tree type, tree op0, tree op1)\n {\n   bool sop;\n@@ -1007,7 +1006,7 @@ bool\n vr_values::check_for_binary_op_overflow (enum tree_code subcode, tree type,\n \t\t\t\t\t tree op0, tree op1, bool *ovf)\n {\n-  value_range_base vr0, vr1;\n+  value_range vr0, vr1;\n   if (TREE_CODE (op0) == SSA_NAME)\n     vr0 = *get_value_range (op0);\n   else if (TREE_CODE (op0) == INTEGER_CST)\n@@ -1110,7 +1109,7 @@ vr_values::check_for_binary_op_overflow (enum tree_code subcode, tree type,\n    Store the result in *VR */\n \n void\n-vr_values::extract_range_basic (value_range *vr, gimple *stmt)\n+vr_values::extract_range_basic (value_range_equiv *vr, gimple *stmt)\n {\n   bool sop;\n   tree type = gimple_expr_type (stmt);\n@@ -1144,7 +1143,7 @@ vr_values::extract_range_basic (value_range *vr, gimple *stmt)\n \t  maxi = prec;\n \t  if (TREE_CODE (arg) == SSA_NAME)\n \t    {\n-\t      const value_range *vr0 = get_value_range (arg);\n+\t      const value_range_equiv *vr0 = get_value_range (arg);\n \t      /* If arg is non-zero, then ffs or popcount are non-zero.  */\n \t      if (range_includes_zero_p (vr0) == 0)\n \t\tmini = 1;\n@@ -1182,7 +1181,7 @@ vr_values::extract_range_basic (value_range *vr, gimple *stmt)\n \t    mini = -2;\n \t  if (TREE_CODE (arg) == SSA_NAME)\n \t    {\n-\t      const value_range *vr0 = get_value_range (arg);\n+\t      const value_range_equiv *vr0 = get_value_range (arg);\n \t      /* From clz of VR_RANGE minimum we can compute\n \t\t result maximum.  */\n \t      if (vr0->kind () == VR_RANGE\n@@ -1239,7 +1238,7 @@ vr_values::extract_range_basic (value_range *vr, gimple *stmt)\n \t    }\n \t  if (TREE_CODE (arg) == SSA_NAME)\n \t    {\n-\t      const value_range *vr0 = get_value_range (arg);\n+\t      const value_range_equiv *vr0 = get_value_range (arg);\n \t      /* If arg is non-zero, then use [0, prec - 1].  */\n \t      if ((vr0->kind () == VR_RANGE\n \t\t   && integer_nonzerop (vr0->min ()))\n@@ -1420,7 +1419,7 @@ vr_values::extract_range_basic (value_range *vr, gimple *stmt)\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      value_range vr0, vr1;\n+\t\t      value_range_equiv vr0, vr1;\n \t\t      bool saved_flag_wrapv = flag_wrapv;\n \t\t      /* Pretend the arithmetics is wrapping.  If there is\n \t\t\t any overflow, IMAGPART_EXPR will be set.  */\n@@ -1454,7 +1453,7 @@ vr_values::extract_range_basic (value_range *vr, gimple *stmt)\n    in *VR.  */\n \n void\n-vr_values::extract_range_from_assignment (value_range *vr, gassign *stmt)\n+vr_values::extract_range_from_assignment (value_range_equiv *vr, gassign *stmt)\n {\n   enum tree_code code = gimple_assign_rhs_code (stmt);\n \n@@ -1503,8 +1502,8 @@ vr_values::extract_range_from_assignment (value_range *vr, gassign *stmt)\n \n \n static tree\n-compare_ranges (enum tree_code comp, const value_range *vr0,\n-\t\tconst value_range *vr1, bool *strict_overflow_p)\n+compare_ranges (enum tree_code comp, const value_range_equiv *vr0,\n+\t\tconst value_range_equiv *vr1, bool *strict_overflow_p)\n {\n   /* VARYING or UNDEFINED ranges cannot be compared.  */\n   if (vr0->varying_p ()\n@@ -1638,8 +1637,8 @@ compare_ranges (enum tree_code comp, const value_range *vr0,\n    assumed signed overflow is undefined.  */\n \n static tree\n-compare_range_with_value (enum tree_code comp, const value_range *vr, tree val,\n-\t\t\t  bool *strict_overflow_p)\n+compare_range_with_value (enum tree_code comp, const value_range_equiv *vr,\n+\t\t\t  tree val, bool *strict_overflow_p)\n {\n   if (vr->varying_p () || vr->undefined_p ())\n     return NULL_TREE;\n@@ -1742,7 +1741,7 @@ compare_range_with_value (enum tree_code comp, const value_range *vr, tree val,\n    for VAR.  If so, update VR with the new limits.  */\n \n void\n-vr_values::adjust_range_with_scev (value_range *vr, class loop *loop,\n+vr_values::adjust_range_with_scev (value_range_equiv *vr, class loop *loop,\n \t\t\t\t   gimple *stmt, tree var)\n {\n   tree init, step, chrec, tmin, tmax, min, max, type, tem;\n@@ -1815,7 +1814,6 @@ vr_values::adjust_range_with_scev (value_range *vr, class loop *loop,\n \t the number of latch executions is the correct thing to use.  */\n       if (max_loop_iterations (loop, &nit))\n \t{\n-\t  value_range maxvr;\n \t  signop sgn = TYPE_SIGN (TREE_TYPE (step));\n \t  wi::overflow_type overflow;\n \n@@ -1831,13 +1829,14 @@ vr_values::adjust_range_with_scev (value_range *vr, class loop *loop,\n \t      && (sgn == UNSIGNED\n \t\t  || wi::gts_p (wtmp, 0) == wi::gts_p (wi::to_wide (step), 0)))\n \t    {\n+\t      value_range_equiv maxvr;\n \t      tem = wide_int_to_tree (TREE_TYPE (init), wtmp);\n \t      extract_range_from_binary_expr (&maxvr, PLUS_EXPR,\n \t\t\t\t\t      TREE_TYPE (init), init, tem);\n \t      /* Likewise if the addition did.  */\n \t      if (maxvr.kind () == VR_RANGE)\n \t\t{\n-\t\t  value_range_base initvr;\n+\t\t  value_range initvr;\n \n \t\t  if (TREE_CODE (init) == SSA_NAME)\n \t\t    initvr = *(get_value_range (init));\n@@ -1952,7 +1951,7 @@ vr_values::vr_values () : vrp_value_range_pool (\"Tree VRP value ranges\")\n {\n   values_propagated = false;\n   num_vr_values = num_ssa_names * 2;\n-  vr_value = XCNEWVEC (value_range *, num_vr_values);\n+  vr_value = XCNEWVEC (value_range_equiv *, num_vr_values);\n   vr_phi_edge_counts = XCNEWVEC (int, num_ssa_names);\n   bitmap_obstack_initialize (&vrp_equiv_obstack);\n   to_remove_edges = vNULL;\n@@ -1992,7 +1991,7 @@ vrp_valueize (tree name)\n {\n   if (TREE_CODE (name) == SSA_NAME)\n     {\n-      const value_range *vr = x_vr_values->get_value_range (name);\n+      const value_range_equiv *vr = x_vr_values->get_value_range (name);\n       if (vr->kind () == VR_RANGE\n \t  && (TREE_CODE (vr->min ()) == SSA_NAME\n \t      || is_gimple_min_invariant (vr->min ()))\n@@ -2017,7 +2016,7 @@ vrp_valueize_1 (tree name)\n       if (!gimple_nop_p (def_stmt)\n \t  && prop_simulate_again_p (def_stmt))\n \treturn NULL_TREE;\n-      const value_range *vr = x_vr_values->get_value_range (name);\n+      const value_range_equiv *vr = x_vr_values->get_value_range (name);\n       tree singleton;\n       if (vr->singleton_p (&singleton))\n \treturn singleton;\n@@ -2053,7 +2052,7 @@ get_output_for_vrp (gimple *stmt)\n \n void\n vr_values::vrp_visit_assignment_or_call (gimple *stmt, tree *output_p,\n-\t\t\t\t\t value_range *vr)\n+\t\t\t\t\t value_range_equiv *vr)\n {\n   tree lhs = get_output_for_vrp (stmt);\n   *output_p = lhs;\n@@ -2095,11 +2094,11 @@ vr_values::vrp_visit_assignment_or_call (gimple *stmt, tree *output_p,\n    or a symbolic range containing the SSA_NAME only if the value range\n    is varying or undefined.  Uses TEM as storage for the alternate range.  */\n \n-const value_range *\n-vr_values::get_vr_for_comparison (int i, value_range *tem)\n+const value_range_equiv *\n+vr_values::get_vr_for_comparison (int i, value_range_equiv *tem)\n {\n   /* Shallow-copy equiv bitmap.  */\n-  const value_range *vr = get_value_range (ssa_name (i));\n+  const value_range_equiv *vr = get_value_range (ssa_name (i));\n \n   /* If name N_i does not have a valid range, use N_i as its own\n      range.  This allows us to compare against names that may\n@@ -2122,52 +2121,46 @@ tree\n vr_values::compare_name_with_value (enum tree_code comp, tree var, tree val,\n \t\t\t\t    bool *strict_overflow_p, bool use_equiv_p)\n {\n-  bitmap_iterator bi;\n-  unsigned i;\n-  bitmap e;\n-  tree retval, t;\n-  int used_strict_overflow;\n-  bool sop;\n-  const value_range *equiv_vr;\n-  value_range tem_vr;\n-\n   /* Get the set of equivalences for VAR.  */\n-  e = get_value_range (var)->equiv ();\n+  bitmap e = get_value_range (var)->equiv ();\n \n   /* Start at -1.  Set it to 0 if we do a comparison without relying\n      on overflow, or 1 if all comparisons rely on overflow.  */\n-  used_strict_overflow = -1;\n+  int used_strict_overflow = -1;\n \n   /* Compare vars' value range with val.  */\n-  equiv_vr = get_vr_for_comparison (SSA_NAME_VERSION (var), &tem_vr);\n-  sop = false;\n-  retval = compare_range_with_value (comp, equiv_vr, val, &sop);\n+  value_range_equiv tem_vr;\n+  const value_range_equiv *equiv_vr\n+    = get_vr_for_comparison (SSA_NAME_VERSION (var), &tem_vr);\n+  bool sop = false;\n+  tree retval = compare_range_with_value (comp, equiv_vr, val, &sop);\n   if (retval)\n     used_strict_overflow = sop ? 1 : 0;\n \n   /* If the equiv set is empty we have done all work we need to do.  */\n   if (e == NULL)\n     {\n-      if (retval\n-\t  && used_strict_overflow > 0)\n+      if (retval && used_strict_overflow > 0)\n \t*strict_overflow_p = true;\n       return retval;\n     }\n \n+  unsigned i;\n+  bitmap_iterator bi;\n   EXECUTE_IF_SET_IN_BITMAP (e, 0, i, bi)\n     {\n       tree name = ssa_name (i);\n-      if (! name)\n+      if (!name)\n \tcontinue;\n \n-      if (! use_equiv_p\n-\t  && ! SSA_NAME_IS_DEFAULT_DEF (name)\n+      if (!use_equiv_p\n+\t  && !SSA_NAME_IS_DEFAULT_DEF (name)\n \t  && prop_simulate_again_p (SSA_NAME_DEF_STMT (name)))\n \tcontinue;\n \n       equiv_vr = get_vr_for_comparison (i, &tem_vr);\n       sop = false;\n-      t = compare_range_with_value (comp, equiv_vr, val, &sop);\n+      tree t = compare_range_with_value (comp, equiv_vr, val, &sop);\n       if (t)\n \t{\n \t  /* If we get different answers from different members\n@@ -2189,8 +2182,7 @@ vr_values::compare_name_with_value (enum tree_code comp, tree var, tree val,\n \t}\n     }\n \n-  if (retval\n-      && used_strict_overflow > 0)\n+  if (retval && used_strict_overflow > 0)\n     *strict_overflow_p = true;\n \n   return retval;\n@@ -2208,20 +2200,14 @@ tree\n vr_values::compare_names (enum tree_code comp, tree n1, tree n2,\n \t\t\t  bool *strict_overflow_p)\n {\n-  tree t, retval;\n-  bitmap e1, e2;\n-  bitmap_iterator bi1, bi2;\n-  unsigned i1, i2;\n-  int used_strict_overflow;\n-  static bitmap_obstack *s_obstack = NULL;\n-  static bitmap s_e1 = NULL, s_e2 = NULL;\n-\n   /* Compare the ranges of every name equivalent to N1 against the\n      ranges of every name equivalent to N2.  */\n-  e1 = get_value_range (n1)->equiv ();\n-  e2 = get_value_range (n2)->equiv ();\n+  bitmap e1 = get_value_range (n1)->equiv ();\n+  bitmap e2 = get_value_range (n2)->equiv ();\n \n   /* Use the fake bitmaps if e1 or e2 are not available.  */\n+  static bitmap s_e1 = NULL, s_e2 = NULL;\n+  static bitmap_obstack *s_obstack = NULL;\n   if (s_obstack == NULL)\n     {\n       s_obstack = XNEW (bitmap_obstack);\n@@ -2254,29 +2240,33 @@ vr_values::compare_names (enum tree_code comp, tree n1, tree n2,\n \n   /* Start at -1.  Set it to 0 if we do a comparison without relying\n      on overflow, or 1 if all comparisons rely on overflow.  */\n-  used_strict_overflow = -1;\n+  int used_strict_overflow = -1;\n \n   /* Otherwise, compare all the equivalent ranges.  First, add N1 and\n      N2 to their own set of equivalences to avoid duplicating the body\n      of the loop just to check N1 and N2 ranges.  */\n+  bitmap_iterator bi1;\n+  unsigned i1;\n   EXECUTE_IF_SET_IN_BITMAP (e1, 0, i1, bi1)\n     {\n-      if (! ssa_name (i1))\n+      if (!ssa_name (i1))\n \tcontinue;\n \n-      value_range tem_vr1;\n-      const value_range *vr1 = get_vr_for_comparison (i1, &tem_vr1);\n+      value_range_equiv tem_vr1;\n+      const value_range_equiv *vr1 = get_vr_for_comparison (i1, &tem_vr1);\n \n-      t = retval = NULL_TREE;\n+      tree t = NULL_TREE, retval = NULL_TREE;\n+      bitmap_iterator bi2;\n+      unsigned i2;\n       EXECUTE_IF_SET_IN_BITMAP (e2, 0, i2, bi2)\n \t{\n-\t  if (! ssa_name (i2))\n+\t  if (!ssa_name (i2))\n \t    continue;\n \n \t  bool sop = false;\n \n-\t  value_range tem_vr2;\n-\t  const value_range *vr2 = get_vr_for_comparison (i2, &tem_vr2);\n+\t  value_range_equiv tem_vr2;\n+\t  const value_range_equiv *vr2 = get_vr_for_comparison (i2, &tem_vr2);\n \n \t  t = compare_ranges (comp, vr1, vr2, &sop);\n \t  if (t)\n@@ -2285,8 +2275,7 @@ vr_values::compare_names (enum tree_code comp, tree n1, tree n2,\n \t\t of the equivalence set this check must be in a dead\n \t\t code region.  Folding it to a trap representation\n \t\t would be correct here.  For now just return don't-know.  */\n-\t      if (retval != NULL\n-\t\t  && t != retval)\n+\t      if (retval != NULL && t != retval)\n \t\t{\n \t\t  bitmap_clear_bit (e1, SSA_NAME_VERSION (n1));\n \t\t  bitmap_clear_bit (e2, SSA_NAME_VERSION (n2));\n@@ -2325,8 +2314,7 @@ tree\n vr_values::vrp_evaluate_conditional_warnv_with_ops_using_ranges\n     (enum tree_code code, tree op0, tree op1, bool * strict_overflow_p)\n {\n-  const value_range *vr0, *vr1;\n-\n+  const value_range_equiv *vr0, *vr1;\n   vr0 = (TREE_CODE (op0) == SSA_NAME) ? get_value_range (op0) : NULL;\n   vr1 = (TREE_CODE (op1) == SSA_NAME) ? get_value_range (op1) : NULL;\n \n@@ -2392,7 +2380,7 @@ vr_values::vrp_evaluate_conditional_warnv_with_ops (enum tree_code code,\n \t}\n       else\n \t{\n-\t  value_range_base vro, vri;\n+\t  value_range vro, vri;\n \t  if (code == GT_EXPR || code == GE_EXPR)\n \t    {\n \t      vro.set (VR_ANTI_RANGE, TYPE_MIN_VALUE (TREE_TYPE (op0)), x);\n@@ -2405,7 +2393,7 @@ vr_values::vrp_evaluate_conditional_warnv_with_ops (enum tree_code code,\n \t    }\n \t  else\n \t    gcc_unreachable ();\n-\t  const value_range *vr0 = get_value_range (op0);\n+\t  const value_range_equiv *vr0 = get_value_range (op0);\n \t  /* If vro, the range for OP0 to pass the overflow test, has\n \t     no intersection with *vr0, OP0's known range, then the\n \t     overflow test can't pass, so return the node for false.\n@@ -2511,7 +2499,7 @@ vr_values::vrp_evaluate_conditional (tree_code code, tree op0,\n \t always fold regardless of the value of OP0.  If -Wtype-limits\n \t was specified, emit a warning.  */\n       tree type = TREE_TYPE (op0);\n-      const value_range *vr0 = get_value_range (op0);\n+      const value_range_equiv *vr0 = get_value_range (op0);\n \n       if (vr0->kind () == VR_RANGE\n \t  && INTEGRAL_TYPE_P (type)\n@@ -2637,9 +2625,9 @@ vr_values::vrp_visit_cond_stmt (gcond *stmt, edge *taken_edge_p)\n    Returns true if the default label is not needed.  */\n \n static bool\n-find_case_label_ranges (gswitch *stmt, const value_range *vr, size_t *min_idx1,\n-\t\t\tsize_t *max_idx1, size_t *min_idx2,\n-\t\t\tsize_t *max_idx2)\n+find_case_label_ranges (gswitch *stmt, const value_range_equiv *vr,\n+\t\t\tsize_t *min_idx1, size_t *max_idx1,\n+\t\t\tsize_t *min_idx2, size_t *max_idx2)\n {\n   size_t i, j, k, l;\n   unsigned int n = gimple_switch_num_labels (stmt);\n@@ -2717,7 +2705,7 @@ void\n vr_values::vrp_visit_switch_stmt (gswitch *stmt, edge *taken_edge_p)\n {\n   tree op, val;\n-  const value_range *vr;\n+  const value_range_equiv *vr;\n   size_t i = 0, j = 0, k, l;\n   bool take_default;\n \n@@ -2807,7 +2795,7 @@ vr_values::vrp_visit_switch_stmt (gswitch *stmt, edge *taken_edge_p)\n \n void\n vr_values::extract_range_from_stmt (gimple *stmt, edge *taken_edge_p,\n-\t\t\t\t    tree *output_p, value_range *vr)\n+\t\t\t\t    tree *output_p, value_range_equiv *vr)\n {\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -2831,13 +2819,13 @@ vr_values::extract_range_from_stmt (gimple *stmt, edge *taken_edge_p,\n    value ranges, set a new range in VR_RESULT.  */\n \n void\n-vr_values::extract_range_from_phi_node (gphi *phi, value_range *vr_result)\n+vr_values::extract_range_from_phi_node (gphi *phi,\n+\t\t\t\t\tvalue_range_equiv *vr_result)\n {\n-  size_t i;\n   tree lhs = PHI_RESULT (phi);\n-  const value_range *lhs_vr = get_value_range (lhs);\n+  const value_range_equiv *lhs_vr = get_value_range (lhs);\n   bool first = true;\n-  int edges, old_edges;\n+  int old_edges;\n   class loop *l;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -2847,8 +2835,8 @@ vr_values::extract_range_from_phi_node (gphi *phi, value_range *vr_result)\n     }\n \n   bool may_simulate_backedge_again = false;\n-  edges = 0;\n-  for (i = 0; i < gimple_phi_num_args (phi); i++)\n+  int edges = 0;\n+  for (size_t i = 0; i < gimple_phi_num_args (phi); i++)\n     {\n       edge e = gimple_phi_arg_edge (phi, i);\n \n@@ -2862,12 +2850,12 @@ vr_values::extract_range_from_phi_node (gphi *phi, value_range *vr_result)\n \n       if (e->flags & EDGE_EXECUTABLE)\n \t{\n-\t  tree arg = PHI_ARG_DEF (phi, i);\n-\t  value_range vr_arg_tem;\n-\t  const value_range *vr_arg = &vr_arg_tem;\n+\t  value_range_equiv vr_arg_tem;\n+\t  const value_range_equiv *vr_arg = &vr_arg_tem;\n \n \t  ++edges;\n \n+\t  tree arg = PHI_ARG_DEF (phi, i);\n \t  if (TREE_CODE (arg) == SSA_NAME)\n \t    {\n \t      /* See if we are eventually going to change one of the args.  */\n@@ -2877,7 +2865,7 @@ vr_values::extract_range_from_phi_node (gphi *phi, value_range *vr_result)\n \t\t  && e->flags & EDGE_DFS_BACK)\n \t\tmay_simulate_backedge_again = true;\n \n-\t      const value_range *vr_arg_ = get_value_range (arg);\n+\t      const value_range_equiv *vr_arg_ = get_value_range (arg);\n \t      /* Do not allow equivalences or symbolic ranges to leak in from\n \t\t backedges.  That creates invalid equivalencies.\n \t\t See PR53465 and PR54767.  */\n@@ -3128,7 +3116,7 @@ vr_values::simplify_div_or_mod_using_ranges (gimple_stmt_iterator *gsi,\n   tree op1 = gimple_assign_rhs2 (stmt);\n   tree op0min = NULL_TREE, op0max = NULL_TREE;\n   tree op1min = op1;\n-  const value_range *vr = NULL;\n+  const value_range_equiv *vr = NULL;\n \n   if (TREE_CODE (op0) == INTEGER_CST)\n     {\n@@ -3148,7 +3136,7 @@ vr_values::simplify_div_or_mod_using_ranges (gimple_stmt_iterator *gsi,\n   if (rhs_code == TRUNC_MOD_EXPR\n       && TREE_CODE (op1) == SSA_NAME)\n     {\n-      const value_range *vr1 = get_value_range (op1);\n+      const value_range_equiv *vr1 = get_value_range (op1);\n       if (range_int_cst_p (vr1))\n \top1min = vr1->min ();\n     }\n@@ -3295,7 +3283,7 @@ bool\n vr_values::simplify_abs_using_ranges (gimple_stmt_iterator *gsi, gimple *stmt)\n {\n   tree op = gimple_assign_rhs1 (stmt);\n-  const value_range *vr = get_value_range (op);\n+  const value_range_equiv *vr = get_value_range (op);\n \n   if (vr)\n     {\n@@ -3348,7 +3336,7 @@ vr_values::simplify_abs_using_ranges (gimple_stmt_iterator *gsi, gimple *stmt)\n \n static bool\n vr_set_zero_nonzero_bits (const tree expr_type,\n-\t\t\t  const value_range_base *vr,\n+\t\t\t  const value_range *vr,\n \t\t\t  wide_int *may_be_nonzero,\n \t\t\t  wide_int *must_be_nonzero)\n {\n@@ -3378,7 +3366,7 @@ vr_values::simplify_bit_ops_using_ranges (gimple_stmt_iterator *gsi,\n   tree op0 = gimple_assign_rhs1 (stmt);\n   tree op1 = gimple_assign_rhs2 (stmt);\n   tree op = NULL_TREE;\n-  value_range_base vr0, vr1;\n+  value_range vr0, vr1;\n   wide_int may_be_nonzero0, may_be_nonzero1;\n   wide_int must_be_nonzero0, must_be_nonzero1;\n   wide_int mask;\n@@ -3457,7 +3445,7 @@ vr_values::simplify_bit_ops_using_ranges (gimple_stmt_iterator *gsi,\n \n static tree\n test_for_singularity (enum tree_code cond_code, tree op0,\n-\t\t      tree op1, const value_range *vr)\n+\t\t      tree op1, const value_range_equiv *vr)\n {\n   tree min = NULL;\n   tree max = NULL;\n@@ -3515,7 +3503,7 @@ test_for_singularity (enum tree_code cond_code, tree op0,\n    by PRECISION and UNSIGNED_P.  */\n \n static bool\n-range_fits_type_p (const value_range *vr,\n+range_fits_type_p (const value_range_equiv *vr,\n \t\t   unsigned dest_precision, signop dest_sgn)\n {\n   tree src_type;\n@@ -3580,7 +3568,7 @@ vr_values::simplify_cond_using_ranges_1 (gcond *stmt)\n       && INTEGRAL_TYPE_P (TREE_TYPE (op0))\n       && is_gimple_min_invariant (op1))\n     {\n-      const value_range *vr = get_value_range (op0);\n+      const value_range_equiv *vr = get_value_range (op0);\n \n       /* If we have range information for OP0, then we might be\n \t able to simplify this conditional. */\n@@ -3683,7 +3671,7 @@ vr_values::simplify_cond_using_ranges_2 (gcond *stmt)\n \t  && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (innerop)\n \t  && desired_pro_or_demotion_p (TREE_TYPE (innerop), TREE_TYPE (op0)))\n \t{\n-\t  const value_range *vr = get_value_range (innerop);\n+\t  const value_range_equiv *vr = get_value_range (innerop);\n \n \t  if (range_int_cst_p (vr)\n \t      && range_fits_type_p (vr,\n@@ -3713,7 +3701,7 @@ bool\n vr_values::simplify_switch_using_ranges (gswitch *stmt)\n {\n   tree op = gimple_switch_index (stmt);\n-  const value_range *vr = NULL;\n+  const value_range_equiv *vr = NULL;\n   bool take_default;\n   edge e;\n   edge_iterator ei;\n@@ -4013,7 +4001,7 @@ vr_values::simplify_float_conversion_using_ranges (gimple_stmt_iterator *gsi,\n \t\t\t\t\t\t   gimple *stmt)\n {\n   tree rhs1 = gimple_assign_rhs1 (stmt);\n-  const value_range *vr = get_value_range (rhs1);\n+  const value_range_equiv *vr = get_value_range (rhs1);\n   scalar_float_mode fltmode\n     = SCALAR_FLOAT_TYPE_MODE (TREE_TYPE (gimple_assign_lhs (stmt)));\n   scalar_int_mode mode;\n@@ -4176,7 +4164,7 @@ vr_values::simplify_internal_call_using_ranges (gimple_stmt_iterator *gsi,\n bool\n vr_values::two_valued_val_range_p (tree var, tree *a, tree *b)\n {\n-  const value_range *vr = get_value_range (var);\n+  const value_range_equiv *vr = get_value_range (var);\n   if (vr->varying_p ()\n       || vr->undefined_p ()\n       || TREE_CODE (vr->min ()) != INTEGER_CST\n@@ -4355,7 +4343,7 @@ vr_values::simplify_stmt_using_ranges (gimple_stmt_iterator *gsi)\n /* Set the lattice entry for VAR to VR.  */\n \n void\n-vr_values::set_vr_value (tree var, value_range *vr)\n+vr_values::set_vr_value (tree var, value_range_equiv *vr)\n {\n   if (SSA_NAME_VERSION (var) >= num_vr_values)\n     return;\n@@ -4364,8 +4352,8 @@ vr_values::set_vr_value (tree var, value_range *vr)\n \n /* Swap the lattice entry for VAR with VR and return the old entry.  */\n \n-value_range *\n-vr_values::swap_vr_value (tree var, value_range *vr)\n+value_range_equiv *\n+vr_values::swap_vr_value (tree var, value_range_equiv *vr)\n {\n   if (SSA_NAME_VERSION (var) >= num_vr_values)\n     return NULL;"}, {"sha": "0bba47756c12b627de00d6a12e99cc44c03c68e1", "filename": "gcc/vr-values.h", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Fvr-values.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d81b1599c365d8c60222ec5631a8f111d8574/gcc%2Fvr-values.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.h?ref=028d81b1599c365d8c60222ec5631a8f111d8574", "patch": "@@ -40,23 +40,25 @@ class vr_values\n   vr_values (void);\n   ~vr_values (void);\n \n-  const value_range *get_value_range (const_tree);\n-  void set_vr_value (tree, value_range *);\n-  value_range *swap_vr_value (tree, value_range *);\n+  const value_range_equiv *get_value_range (const_tree);\n+  void set_vr_value (tree, value_range_equiv *);\n+  value_range_equiv *swap_vr_value (tree, value_range_equiv *);\n \n   void set_def_to_varying (const_tree);\n   void set_defs_to_varying (gimple *);\n-  bool update_value_range (const_tree, value_range *);\n+  bool update_value_range (const_tree, value_range_equiv *);\n   tree op_with_constant_singleton_value_range (tree);\n-  void adjust_range_with_scev (value_range *, class loop *, gimple *, tree);\n+  void adjust_range_with_scev (value_range_equiv *, class loop *,\n+\t\t\t       gimple *, tree);\n   tree vrp_evaluate_conditional (tree_code, tree, tree, gimple *);\n   void dump_all_value_ranges (FILE *);\n \n   void extract_range_for_var_from_comparison_expr (tree, enum tree_code,\n-\t\t\t\t\t\t   tree, tree, value_range *);\n-  void extract_range_from_phi_node (gphi *, value_range *);\n-  void extract_range_basic (value_range *, gimple *);\n-  void extract_range_from_stmt (gimple *, edge *, tree *, value_range *);\n+\t\t\t\t\t\t   tree, tree,\n+\t\t\t\t\t\t   value_range_equiv *);\n+  void extract_range_from_phi_node (gphi *, value_range_equiv *);\n+  void extract_range_basic (value_range_equiv *, gimple *);\n+  void extract_range_from_stmt (gimple *, edge *, tree *, value_range_equiv *);\n \n   void vrp_visit_cond_stmt (gcond *, edge *);\n \n@@ -67,20 +69,20 @@ class vr_values\n   void set_lattice_propagation_complete (void) { values_propagated = true; }\n \n   /* Allocate a new value_range object.  */\n-  value_range *allocate_value_range (void)\n+  value_range_equiv *allocate_value_range_equiv (void)\n     { return vrp_value_range_pool.allocate (); }\n-  void free_value_range (value_range *vr)\n+  void free_value_range (value_range_equiv *vr)\n     { vrp_value_range_pool.remove (vr); }\n \n   /* */\n   void cleanup_edges_and_switches (void);\n \n  private:\n-  value_range *get_lattice_entry (const_tree);\n+  value_range_equiv *get_lattice_entry (const_tree);\n   bool vrp_stmt_computes_nonzero (gimple *);\n   bool op_with_boolean_value_range_p (tree);\n   bool check_for_binary_op_overflow (enum tree_code, tree, tree, tree, bool *);\n-  const value_range *get_vr_for_comparison (int, value_range *);\n+  const value_range_equiv *get_vr_for_comparison (int, value_range_equiv *);\n   tree compare_name_with_value (enum tree_code, tree, tree, bool *, bool);\n   tree compare_names (enum tree_code, tree, tree, bool *);\n   bool two_valued_val_range_p (tree, tree *, tree *);\n@@ -90,17 +92,17 @@ class vr_values\n   tree vrp_evaluate_conditional_warnv_with_ops (enum tree_code,\n \t\t\t\t\t\ttree, tree, bool,\n \t\t\t\t\t\tbool *, bool *);\n-  void extract_range_from_assignment (value_range *, gassign *);\n-  void extract_range_from_assert (value_range *, tree);\n-  void extract_range_from_ssa_name (value_range *, tree);\n-  void extract_range_from_binary_expr (value_range *, enum tree_code,\n+  void extract_range_from_assignment (value_range_equiv *, gassign *);\n+  void extract_range_from_assert (value_range_equiv *, tree);\n+  void extract_range_from_ssa_name (value_range_equiv *, tree);\n+  void extract_range_from_binary_expr (value_range_equiv *, enum tree_code,\n \t\t\t\t       tree, tree, tree);\n-  void extract_range_from_unary_expr (value_range *, enum tree_code,\n+  void extract_range_from_unary_expr (value_range_equiv *, enum tree_code,\n \t\t\t\t      tree, tree);\n-  void extract_range_from_cond_expr (value_range *, gassign *);\n-  void extract_range_from_comparison (value_range *, enum tree_code,\n+  void extract_range_from_cond_expr (value_range_equiv *, gassign *);\n+  void extract_range_from_comparison (value_range_equiv *, enum tree_code,\n \t\t\t\t      tree, tree, tree);\n-  void vrp_visit_assignment_or_call (gimple*, tree *, value_range *);\n+  void vrp_visit_assignment_or_call (gimple*, tree *, value_range_equiv *);\n   void vrp_visit_switch_stmt (gswitch *, edge *);\n   bool simplify_truth_ops_using_ranges (gimple_stmt_iterator *, gimple *);\n   bool simplify_div_or_mod_using_ranges (gimple_stmt_iterator *, gimple *);\n@@ -114,7 +116,7 @@ class vr_values\n   bool simplify_internal_call_using_ranges (gimple_stmt_iterator *, gimple *);\n \n   /* Allocation pools for value_range objects.  */\n-  object_allocator<value_range> vrp_value_range_pool;\n+  object_allocator<value_range_equiv> vrp_value_range_pool;\n \n   /* This probably belongs in the lattice rather than in here.  */\n   bool values_propagated;\n@@ -125,7 +127,7 @@ class vr_values\n   /* Value range array.  After propagation, VR_VALUE[I] holds the range\n      of values that SSA name N_I may take.  */\n   unsigned int num_vr_values;\n-  value_range **vr_value;\n+  value_range_equiv **vr_value;\n \n   /* For a PHI node which sets SSA name N_I, VR_COUNTS[I] holds the\n      number of executable edges we saw the last time we visited the"}]}