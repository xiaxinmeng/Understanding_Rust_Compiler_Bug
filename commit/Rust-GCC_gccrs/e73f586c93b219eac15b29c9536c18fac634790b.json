{"sha": "e73f586c93b219eac15b29c9536c18fac634790b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTczZjU4NmM5M2IyMTllYWMxNWIyOWM5NTM2YzE4ZmFjNjM0NzkwYg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2020-09-11T22:10:14Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2020-09-11T22:10:14Z"}, "message": "PowerPC: rename some functions.\n\ngcc/\n2020-09-11  Michael Meissner  <meissner@linux.ibm.com>\n\n\t* config/rs6000/rs6000.c (rs6000_maybe_emit_maxc_minc): Rename\n\tfrom rs6000_emit_p9_fp_minmax.  Change return type to bool.  Add\n\tcomments to document NaN/signed zero behavior.\n\t(rs6000_maybe_emit_fp_cmove): Rename from rs6000_emit_p9_fp_cmove.\n\t(have_compare_and_set_mask): New helper function.\n\t(rs6000_emit_cmove): Update calls to new names and the new helper\n\tfunction.", "tree": {"sha": "2bddec90903478c2ed5363d2934463cc4a2831b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2bddec90903478c2ed5363d2934463cc4a2831b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e73f586c93b219eac15b29c9536c18fac634790b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e73f586c93b219eac15b29c9536c18fac634790b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e73f586c93b219eac15b29c9536c18fac634790b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e73f586c93b219eac15b29c9536c18fac634790b/comments", "author": null, "committer": null, "parents": [{"sha": "9d377c280c96df8234eab81d5e2253ee36aa3826", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d377c280c96df8234eab81d5e2253ee36aa3826", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d377c280c96df8234eab81d5e2253ee36aa3826"}], "stats": {"total": 93, "additions": 69, "deletions": 24}, "files": [{"sha": "20a4ba382bc04ccbdf85d8a35235a27f84bb319b", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 69, "deletions": 24, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73f586c93b219eac15b29c9536c18fac634790b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73f586c93b219eac15b29c9536c18fac634790b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=e73f586c93b219eac15b29c9536c18fac634790b", "patch": "@@ -15057,13 +15057,33 @@ rs6000_emit_vector_cond_expr (rtx dest, rtx op_true, rtx op_false,\n   return 1;\n }\n \n-/* ISA 3.0 (power9) minmax subcase to emit a XSMAXCDP or XSMINCDP instruction\n-   for SF/DF scalars.  Move TRUE_COND to DEST if OP of the operands of the last\n-   comparison is nonzero/true, FALSE_COND if it is zero/false.  Return 0 if the\n-   hardware has no such operation.  */\n+/* Possibly emit the xsmaxcdp and xsmincdp instructions to emit a maximum or\n+   minimum with \"C\" semantics.\n \n-static int\n-rs6000_emit_p9_fp_minmax (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n+   Unless you use -ffast-math, you can't use these instructions to replace\n+   conditions that implicitly reverse the condition because the comparison\n+   might generate a NaN or signed zer0.\n+\n+   I.e. the following can be replaced all of the time\n+\tret = (op1 >  op2) ? op1 : op2\t; generate xsmaxcdp\n+\tret = (op1 >= op2) ? op1 : op2\t; generate xsmaxcdp\n+\tret = (op1 <  op2) ? op1 : op2;\t; generate xsmincdp\n+\tret = (op1 <= op2) ? op1 : op2;\t; generate xsmincdp\n+\n+   The following can be replaced only if -ffast-math is used:\n+\tret = (op1 <  op2) ? op2 : op1\t; generate xsmaxcdp\n+\tret = (op1 <= op2) ? op2 : op1\t; generate xsmaxcdp\n+\tret = (op1 >  op2) ? op2 : op1;\t; generate xsmincdp\n+\tret = (op1 >= op2) ? op2 : op1;\t; generate xsmincdp\n+\n+   Move TRUE_COND to DEST if OP of the operands of the last comparison is\n+   nonzero/true, FALSE_COND if it is zero/false.\n+\n+   Return false if we can't generate the appropriate minimum or maximum, and\n+   true if we can did the minimum or maximum.  */\n+\n+static bool\n+rs6000_maybe_emit_maxc_minc (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n {\n   enum rtx_code code = GET_CODE (op);\n   rtx op0 = XEXP (op, 0);\n@@ -15073,14 +15093,14 @@ rs6000_emit_p9_fp_minmax (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n   bool max_p = false;\n \n   if (result_mode != compare_mode)\n-    return 0;\n+    return false;\n \n   if (code == GE || code == GT)\n     max_p = true;\n   else if (code == LE || code == LT)\n     max_p = false;\n   else\n-    return 0;\n+    return false;\n \n   if (rtx_equal_p (op0, true_cond) && rtx_equal_p (op1, false_cond))\n     ;\n@@ -15093,19 +15113,23 @@ rs6000_emit_p9_fp_minmax (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n     max_p = !max_p;\n \n   else\n-    return 0;\n+    return false;\n \n   rs6000_emit_minmax (dest, max_p ? SMAX : SMIN, op0, op1);\n-  return 1;\n+  return true;\n }\n \n-/* ISA 3.0 (power9) conditional move subcase to emit XSCMP{EQ,GE,GT,NE}DP and\n-   XXSEL instructions for SF/DF scalars.  Move TRUE_COND to DEST if OP of the\n-   operands of the last comparison is nonzero/true, FALSE_COND if it is\n-   zero/false.  Return 0 if the hardware has no such operation.  */\n+/* Possibly emit a floating point conditional move by generating a compare that\n+   sets a mask instruction and a XXSEL select instruction.\n \n-static int\n-rs6000_emit_p9_fp_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n+   Move TRUE_COND to DEST if OP of the operands of the last comparison is\n+   nonzero/true, FALSE_COND if it is zero/false.\n+\n+   Return false if the operation cannot be generated, and true if we could\n+   generate the instruction.  */\n+\n+static bool\n+rs6000_maybe_emit_fp_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n {\n   enum rtx_code code = GET_CODE (op);\n   rtx op0 = XEXP (op, 0);\n@@ -15133,7 +15157,7 @@ rs6000_emit_p9_fp_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n       break;\n \n     default:\n-      return 0;\n+      return false;\n     }\n \n   /* Generate:\t[(parallel [(set (dest)\n@@ -15153,7 +15177,28 @@ rs6000_emit_p9_fp_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n   emit_insn (gen_rtx_PARALLEL (VOIDmode,\n \t\t\t       gen_rtvec (2, cmove_rtx, clobber_rtx)));\n \n-  return 1;\n+  return true;\n+}\n+\n+/* Helper function to return true if the target has instructions to do a\n+   compare and set mask instruction that can be used with XXSEL to implement a\n+   conditional move.  It is also assumed that such a target also supports the\n+   \"C\" minimum and maximum instructions. */\n+\n+static bool\n+have_compare_and_set_mask (machine_mode mode)\n+{\n+  switch (mode)\n+    {\n+    case SFmode:\n+    case DFmode:\n+      return TARGET_P9_MINMAX;\n+\n+    default:\n+      break;\n+    }\n+\n+  return false;\n }\n \n /* Emit a conditional move: move TRUE_COND to DEST if OP of the\n@@ -15182,15 +15227,15 @@ rs6000_emit_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n   if (GET_MODE (false_cond) != result_mode)\n     return false;\n \n-  /* See if we can use the ISA 3.0 (power9) min/max/compare functions.  */\n-  if (TARGET_P9_MINMAX\n-      && (compare_mode == SFmode || compare_mode == DFmode)\n-      && (result_mode == SFmode || result_mode == DFmode))\n+  /* See if we can use the \"C\" minimum, \"C\" maximum, and compare and set mask\n+     instructions.  */\n+  if (have_compare_and_set_mask (compare_mode)\n+      && have_compare_and_set_mask (result_mode))\n     {\n-      if (rs6000_emit_p9_fp_minmax (dest, op, true_cond, false_cond))\n+      if (rs6000_maybe_emit_maxc_minc (dest, op, true_cond, false_cond))\n \treturn true;\n \n-      if (rs6000_emit_p9_fp_cmove (dest, op, true_cond, false_cond))\n+      if (rs6000_maybe_emit_fp_cmove (dest, op, true_cond, false_cond))\n \treturn true;\n     }\n "}]}