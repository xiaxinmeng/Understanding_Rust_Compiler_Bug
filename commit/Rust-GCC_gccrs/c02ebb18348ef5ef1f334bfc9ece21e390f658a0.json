{"sha": "c02ebb18348ef5ef1f334bfc9ece21e390f658a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzAyZWJiMTgzNDhlZjVlZjFmMzM0YmZjOWVjZTIxZTM5MGY2NThhMA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2002-06-04T20:32:08Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2002-06-04T20:32:08Z"}, "message": "java-tree.h, [...]: Remove all #if JAVA_USE_HANDLES blocks...\n\n\t* java-tree.h, class.c, expr.c, jcf-parse.c, parse.y,\n\ttypeck.c, verify.c: Remove all #if JAVA_USE_HANDLES blocks,\n\tall mention of CLASS_TO_HANDLE_TYPE or HANDLE_TO_CLASS_TYPE,\n\tand all now-pointless local variables.  Rename other local\n\tvariables to reflect their not being handles.\n\n\t* java-tree.h, jcf-dump.c, jcf-io.c: Remove all\n\t#if JCF_USE_STDIO blocks.\n\n\t* parse.y: Add missing semicolon at end of rule.\n\nFrom-SVN: r54261", "tree": {"sha": "a6275d033b57d7601b83e9717938acf4b721796c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a6275d033b57d7601b83e9717938acf4b721796c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c02ebb18348ef5ef1f334bfc9ece21e390f658a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c02ebb18348ef5ef1f334bfc9ece21e390f658a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c02ebb18348ef5ef1f334bfc9ece21e390f658a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c02ebb18348ef5ef1f334bfc9ece21e390f658a0/comments", "author": null, "committer": null, "parents": [{"sha": "d6ee617dd7edc5cb721ad5cd320c47acd18e7ea8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6ee617dd7edc5cb721ad5cd320c47acd18e7ea8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6ee617dd7edc5cb721ad5cd320c47acd18e7ea8"}], "stats": {"total": 232, "additions": 51, "deletions": 181}, "files": [{"sha": "9241ec80d5c21903478ff63a9870027e6595c1cb", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02ebb18348ef5ef1f334bfc9ece21e390f658a0/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02ebb18348ef5ef1f334bfc9ece21e390f658a0/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=c02ebb18348ef5ef1f334bfc9ece21e390f658a0", "patch": "@@ -1,3 +1,16 @@\n+2002-06-04  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* java-tree.h, class.c, expr.c, jcf-parse.c, parse.y,\n+\ttypeck.c, verify.c: Remove all #if JAVA_USE_HANDLES blocks,\n+\tall mention of CLASS_TO_HANDLE_TYPE or HANDLE_TO_CLASS_TYPE,\n+\tand all now-pointless local variables.  Rename other local\n+\tvariables to reflect their not being handles.\n+\n+\t* java-tree.h, jcf-dump.c, jcf-io.c: Remove all\n+\t#if JCF_USE_STDIO blocks.\n+\n+\t* parse.y: Add missing semicolon at end of rule.\n+\n 2002-06-03  Geoffrey Keating  <geoffk@redhat.com>\n \n \t* check-init.c (attach_initialized_static_class): Delete, unused.\n@@ -7,7 +20,7 @@\n \t(struct lang_decl_func): Use htab_t, set up for gengtype.\n \t(struct init_test_hash_entry): Delete.\n \t(struct treetreehash_entry): New.\n-\t(java_treetreehash_find): New \n+\t(java_treetreehash_find): New\n \t(java_treetreehash_new): New prototype.\n \t(java_treetreehash_create): New prototype.\n \t(java_mark_tree): Delete prototype.\n@@ -128,7 +141,7 @@\n \t* jcf.h (JCF_USE_SCANDIR): Define.\n \t* parse.y (java_expand_classes): Write the class files in reverse\n \torder.\n-\t\n+\n 2002-05-16  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n \n \t* Make-lang.in: Allow for PWDCMD to override hardcoded pwd.\n@@ -141,7 +154,7 @@\n \n 2002-05-08  Mark Mitchell  <mark@codesourcery.com>\n \n-\t* jcf-write.c (write_classfile): Write the file to a \n+\t* jcf-write.c (write_classfile): Write the file to a\n \ttemporary file and then rename it.\n \n 2002-05-07  Tom Tromey  <tromey@redhat.com>\n@@ -157,7 +170,7 @@\n \n 2002-05-07  Andreas Jaeger  <aj@suse.de>\n \n-        * parse.y (finish_for_loop): Fix if statement.\n+\t* parse.y (finish_for_loop): Fix if statement.\n \n 2002-05-06  Tom Tromey  <tromey@redhat.com>\n \n@@ -216,13 +229,13 @@\n \n 2002-04-19  Andrew Haley  <aph@redhat.com>\n \n-        * jcf-write.c (push_long_const): lo, hi: New variables.\n-        Use rshift_double to extract the high part of a 64-bit long.\n-        Use WORD_TO_INT to extract the low part.\n+\t* jcf-write.c (push_long_const): lo, hi: New variables.\n+\tUse rshift_double to extract the high part of a 64-bit long.\n+\tUse WORD_TO_INT to extract the low part.\n \n-        * jcf-parse.c (get_constant): CONSTANT_Integer: Use an unsigned\n-        HOST_WIDE_INT for num.  Use JPOOL_UINT to get it.\n-        CONSTANT_Double: Use JPOOL_UINT to get both halve of a double.\n+\t* jcf-parse.c (get_constant): CONSTANT_Integer: Use an unsigned\n+\tHOST_WIDE_INT for num.  Use JPOOL_UINT to get it.\n+\tCONSTANT_Double: Use JPOOL_UINT to get both halve of a double.\n \n 2002-04-18  Neil Booth  <neil@daikokuya.demon.co.uk>\n "}, {"sha": "f5c55979cd8237850e3f7deb3335961ac68725b4", "filename": "gcc/java/class.c", "status": "modified", "additions": 14, "deletions": 43, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02ebb18348ef5ef1f334bfc9ece21e390f658a0/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02ebb18348ef5ef1f334bfc9ece21e390f658a0/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=c02ebb18348ef5ef1f334bfc9ece21e390f658a0", "patch": "@@ -282,21 +282,7 @@ make_class ()\n {\n   tree type;\n   type = make_node (RECORD_TYPE);\n-#ifdef JAVA_USE_HANDLES\n-  tree field1 = build_decl (FIELD_DECL, get_identifier (\"obj\"),\n-\t\t\t    build_pointer_type (type));\n-  tree field2 = build_decl (FIELD_DECL, get_identifier (\"methods\"),\n-\t\t\t    methodtable_ptr_type);\n-  tree handle_type = make_node (RECORD_TYPE);\n-  TREE_CHAIN (field1) = field2;\n-  TYPE_FIELDS (handle_type) = field1;\n-  TYPE_BINFO (type) = make_tree_vec (7);\n-  TYPE_BINFO (handle_type) = make_tree_vec (7);\n-  BINFO_HANDLE (TYPE_BINFO (handle_type)) = type;\n-  BINFO_HANDLE (TYPE_BINFO (type)) = handle_type;\n-#else\n   TYPE_BINFO (type) = make_tree_vec (6);\n-#endif\n   MAYBE_CREATE_TYPE_TYPE_LANG_SPECIFIC (type);\n \n   return type;\n@@ -353,15 +339,6 @@ push_class (class_type, class_name)\n   DECL_ARTIFICIAL (decl) = 1;\n \n   pushdecl_top_level (decl);\n-#ifdef JAVA_USE_HANDLES\n-  {\n-    tree handle_name = identifier_subst (class_name,\n-\t\t\t\t\t \"Handle$\", '.', '.', \"\");\n-    tree handle_decl = build_decl (TYPE_DECL, handle_name,\n-\t\t\t\t   CLASS_TO_HANDLE_TYPE (class_type));\n-    pushdecl (handle_decl);\n-  }\n-#endif\n \n   return decl;\n }\n@@ -618,23 +595,23 @@ build_java_method_type (fntype, this_class, access_flags)\n {\n   if (access_flags & ACC_STATIC)\n     return fntype;\n-  return build_method_type (CLASS_TO_HANDLE_TYPE (this_class), fntype);\n+  return build_method_type (this_class, fntype);\n }\n \n tree\n-add_method_1 (handle_class, access_flags, name, function_type)\n-     tree handle_class;\n+add_method_1 (this_class, access_flags, name, function_type)\n+     tree this_class;\n      int access_flags;\n      tree name;\n      tree function_type;\n {\n   tree method_type, fndecl;\n \n   method_type = build_java_method_type (function_type,\n-\t\t\t\t\thandle_class, access_flags);\n+\t\t\t\t\tthis_class, access_flags);\n \n   fndecl = build_decl (FUNCTION_DECL, name, method_type);\n-  DECL_CONTEXT (fndecl) = handle_class;\n+  DECL_CONTEXT (fndecl) = this_class;\n \n   DECL_LANG_SPECIFIC (fndecl)\n     = (struct lang_decl *) ggc_alloc_cleared (sizeof (struct lang_decl));\n@@ -653,15 +630,15 @@ add_method_1 (handle_class, access_flags, name, function_type)\n   /* Initialize the static method invocation compound list */\n   DECL_FUNCTION_STATIC_METHOD_INVOCATION_COMPOUND (fndecl) = NULL_TREE;\n \n-  TREE_CHAIN (fndecl) = TYPE_METHODS (handle_class);\n-  TYPE_METHODS (handle_class) = fndecl;\n+  TREE_CHAIN (fndecl) = TYPE_METHODS (this_class);\n+  TYPE_METHODS (this_class) = fndecl;\n \n   /* Notice that this is a finalizer and update the class type\n      accordingly. This is used to optimize instance allocation. */\n   if (name == finalize_identifier_node\n       && TREE_TYPE (function_type) == void_type_node\n       && TREE_VALUE (TYPE_ARG_TYPES (function_type)) == void_type_node)\n-    HAS_FINALIZER_P (handle_class) = 1;\n+    HAS_FINALIZER_P (this_class) = 1;\n \n   if (access_flags & ACC_PUBLIC) METHOD_PUBLIC (fndecl) = 1;\n   if (access_flags & ACC_PROTECTED) METHOD_PROTECTED (fndecl) = 1;\n@@ -694,7 +671,6 @@ add_method (this_class, access_flags, name, method_sig)\n      tree name;\n      tree method_sig;\n {\n-  tree handle_class = CLASS_TO_HANDLE_TYPE (this_class);\n   tree function_type, fndecl;\n   const unsigned char *sig\n     = (const unsigned char *) IDENTIFIER_POINTER (method_sig);\n@@ -703,7 +679,7 @@ add_method (this_class, access_flags, name, method_sig)\n     fatal_error (\"bad method signature\");\n \n   function_type = get_type_from_signature (method_sig);\n-  fndecl = add_method_1 (handle_class, access_flags, name, function_type);\n+  fndecl = add_method_1 (this_class, access_flags, name, function_type);\n   set_java_signature (TREE_TYPE (fndecl), method_sig);\n   return fndecl;\n }\n@@ -1525,7 +1501,7 @@ make_class_data (type)\n     fields_decl = NULL_TREE;\n \n   /* Build Method array. */\n-  for (method = TYPE_METHODS (CLASS_TO_HANDLE_TYPE (type));\n+  for (method = TYPE_METHODS (type);\n        method != NULL_TREE; method = TREE_CHAIN (method))\n     {\n       tree init;\n@@ -1707,7 +1683,7 @@ void\n finish_class ()\n {\n   tree method;\n-  tree type_methods = TYPE_METHODS (CLASS_TO_HANDLE_TYPE (current_class));\n+  tree type_methods = TYPE_METHODS (current_class);\n   int saw_native_method = 0;\n \n   /* Find out if we have any native methods.  We use this information\n@@ -2013,13 +1989,12 @@ layout_class_methods (this_class)\n      tree this_class;\n {\n   tree method_decl, dtable_count;\n-  tree super_class, handle_type;\n+  tree super_class;\n \n   if (TYPE_NVIRTUALS (this_class))\n     return;\n \n   super_class = CLASSTYPE_SUPER (this_class);\n-  handle_type = CLASS_TO_HANDLE_TYPE (this_class);\n \n   if (super_class)\n     {\n@@ -2031,18 +2006,14 @@ layout_class_methods (this_class)\n   else\n     dtable_count = integer_zero_node;\n \n-  TYPE_METHODS (handle_type) = nreverse (TYPE_METHODS (handle_type));\n+  TYPE_METHODS (this_class) = nreverse (TYPE_METHODS (this_class));\n \n-  for (method_decl = TYPE_METHODS (handle_type);\n+  for (method_decl = TYPE_METHODS (this_class);\n        method_decl; method_decl = TREE_CHAIN (method_decl))\n     dtable_count = layout_class_method (this_class, super_class, \n \t\t\t\t\tmethod_decl, dtable_count);\n \n   TYPE_NVIRTUALS (this_class) = dtable_count;\n-\n-#ifdef JAVA_USE_HANDLES\n-  layout_type (handle_type);\n-#endif\n }\n \n /* Return 0 if NAME is equal to STR, -1 if STR is \"less\" than NAME,"}, {"sha": "08525beb90b5bbb6b5ea1acb545f3a16f9349498", "filename": "gcc/java/expr.c", "status": "modified", "additions": 6, "deletions": 29, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02ebb18348ef5ef1f334bfc9ece21e390f658a0/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02ebb18348ef5ef1f334bfc9ece21e390f658a0/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=c02ebb18348ef5ef1f334bfc9ece21e390f658a0", "patch": "@@ -198,22 +198,6 @@ java_truthvalue_conversion (expr)\n     }\n }\n \n-#ifdef JAVA_USE_HANDLES\n-/* Given a pointer to a handle, get a pointer to an object. */\n-\n-tree\n-unhand_expr (expr)\n-     tree expr;\n-{\n-  tree field, handle_type;\n-  expr = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (expr)), expr);\n-  handle_type = TREE_TYPE (expr);\n-  field = TYPE_FIELDS (handle_type);\n-  expr = build (COMPONENT_REF, TREE_TYPE (field), expr, field);\n-  return expr;\n-}\n-#endif\n-\n /* Save any stack slots that happen to be in the quick_stack into their\n    home virtual register slots.\n \n@@ -404,8 +388,6 @@ can_widen_reference_to (source_type, target_type)\n     return 1;\n   else\n     {\n-      source_type = HANDLE_TO_CLASS_TYPE (source_type);\n-      target_type = HANDLE_TO_CLASS_TYPE (target_type);\n       if (TYPE_ARRAY_P (source_type) || TYPE_ARRAY_P (target_type))\n \t{\n \t  HOST_WIDE_INT source_length, target_length;\n@@ -1571,12 +1553,9 @@ build_field_ref (self_value, self_class, name)\n \t\t   && ! (DECL_P (self_value)\n \t\t\t && DECL_NAME (self_value) == this_identifier_node));\n \n-      tree base_handle_type = promote_type (base_class);\n-      if (base_handle_type != TREE_TYPE (self_value))\n-\tself_value = fold (build1 (NOP_EXPR, base_handle_type, self_value));\n-#ifdef JAVA_USE_HANDLES\n-      self_value = unhand_expr (self_value);\n-#endif\n+      tree base_type = promote_type (base_class);\n+      if (base_type != TREE_TYPE (self_value))\n+\tself_value = fold (build1 (NOP_EXPR, base_type, self_value));\n       self_value = build_java_indirect_ref (TREE_TYPE (TREE_TYPE (self_value)),\n \t\t\t\t\t    self_value, check);\n       return fold (build (COMPONENT_REF, TREE_TYPE (field_decl),\n@@ -1842,7 +1821,7 @@ build_known_method_ref (method, method_type, self_type,\n \tmethods_ident = get_identifier (\"methods\");\n       ref = build (COMPONENT_REF, method_ptr_type_node, ref,\n \t\t   lookup_field (&class_type_node, methods_ident));\n-      for (meth = TYPE_METHODS (CLASS_TO_HANDLE_TYPE (self_type));\n+      for (meth = TYPE_METHODS (self_type);\n \t   ; meth = TREE_CHAIN (meth))\n \t{\n \t  if (method == meth)\n@@ -2056,11 +2035,9 @@ expand_invoke (opcode, method_ref_index, nargs)\n   layout_class_methods (self_type);\n \n   if (ID_INIT_P (method_name))\n-    method = lookup_java_constructor (CLASS_TO_HANDLE_TYPE (self_type),\n-\t\t\t\t      method_signature);\n+    method = lookup_java_constructor (self_type, method_signature);\n   else\n-    method = lookup_java_method (CLASS_TO_HANDLE_TYPE (self_type),\n-\t\t\t\t method_name, method_signature);\n+    method = lookup_java_method (self_type, method_name, method_signature);\n   if (method == NULL_TREE)\n     {\n       error (\"class '%s' has no method named '%s' matching signature '%s'\","}, {"sha": "9ba52a6b10b01ad69845bb5ff559a3ce5f36ad58", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02ebb18348ef5ef1f334bfc9ece21e390f658a0/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02ebb18348ef5ef1f334bfc9ece21e390f658a0/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=c02ebb18348ef5ef1f334bfc9ece21e390f658a0", "patch": "@@ -1059,22 +1059,6 @@ struct lang_type GTY(())\n   unsigned strictfp:1;\t\t/* `strictfp' class.  */\n };\n \n-#ifdef JAVA_USE_HANDLES\n-/* TYPE_BINFO_HANDLE points from a handle-class to its corresponding\n-   non-handle-class, and vice verse. */\n-\n-#define BINFO_HANDLE(NODE) TREE_VEC_ELT ((NODE), 6)\n-\n-/* Given a RECORD_TYPE for a handle type, return the corresponding class. */\n-#define HANDLE_TO_CLASS_TYPE(HTYPE) BINFO_HANDLE (TYPE_BINFO (HTYPE))\n-\n-/* Given a RECORD_TYPE for a class, return the corresponding handle type. */\n-#define CLASS_TO_HANDLE_TYPE(TYPE) BINFO_HANDLE (TYPE_BINFO (TYPE))\n-#else\n-#define HANDLE_TO_CLASS_TYPE(HTYPE) (HTYPE)\n-#define CLASS_TO_HANDLE_TYPE(TYPE) (TYPE)\n-#endif\n-\n #define JCF_u4 unsigned long\n #define JCF_u2 unsigned short\n \n@@ -1261,13 +1245,8 @@ extern void jcf_print_utf8 PARAMS ((FILE *, const unsigned char *, int));\n extern void jcf_print_char PARAMS ((FILE *, int));\n extern void jcf_print_utf8_replace PARAMS ((FILE *, const unsigned char *,\n \t\t\t\t\t   int, int, int));\n-# if JCF_USE_STDIO\n-extern const char* open_class PARAMS ((const char *, struct JCF *,\n-\t\t\t\t       FILE *, const char *));\n-# else\n extern const char* open_class PARAMS ((const char *, struct JCF *,\n \t\t\t\t       int, const char *));\n-# endif /* JCF_USE_STDIO */\n #endif\n extern void java_debug_context PARAMS ((void));\n extern void safe_layout_class PARAMS ((tree));"}, {"sha": "aa903745f469d6e292b929f9829df1553e16c22b", "filename": "gcc/java/jcf-dump.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02ebb18348ef5ef1f334bfc9ece21e390f658a0/gcc%2Fjava%2Fjcf-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02ebb18348ef5ef1f334bfc9ece21e390f658a0/gcc%2Fjava%2Fjcf-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-dump.c?ref=c02ebb18348ef5ef1f334bfc9ece21e390f658a0", "patch": "@@ -939,11 +939,7 @@ DEFUN(main, (argc, argv),\n   if (optind >= argc)\n     {\n       fprintf (out, \"Reading .class from <standard input>.\\n\");\n-#if JCF_USE_STDIO\n-      open_class (\"<stdio>\", jcf, stdin, NULL);\n-#else\n       open_class (\"<stdio>\", jcf, 0, NULL);\n-#endif\n       process_class (jcf);\n     }\n   else"}, {"sha": "a1af70ad50dfe52de8c0923864bfe0ae0cc9ca8b", "filename": "gcc/java/jcf-io.c", "status": "modified", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02ebb18348ef5ef1f334bfc9ece21e390f658a0/gcc%2Fjava%2Fjcf-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02ebb18348ef5ef1f334bfc9ece21e390f658a0/gcc%2Fjava%2Fjcf-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-io.c?ref=c02ebb18348ef5ef1f334bfc9ece21e390f658a0", "patch": "@@ -231,30 +231,6 @@ DEFUN(read_zip_member, (jcf, zipd, zipf),\n \t  return 0;\n }\n \n-#if JCF_USE_STDIO\n-const char *\n-DEFUN(open_class, (filename, jcf, stream, dep_name),\n-      const char *filename AND JCF *jcf AND FILE* stream\n-      AND const char *dep_name)\n-{\n-  if (jcf)\n-    {\n-      if (dep_name != NULL)\n-\tjcf_dependency_add_file (dep_name, 0);\n-      JCF_ZERO (jcf);\n-      jcf->buffer = NULL;\n-      jcf->buffer_end = NULL;\n-      jcf->read_ptr = NULL;\n-      jcf->read_end = NULL;\n-      jcf->read_state = stream;\n-      jcf->filename = filename;\n-      jcf->filbuf = jcf_filbuf_from_stdio;\n-    }\n-  else\n-    fclose (stream);\n-  return filename;\n-}\n-#else\n const char *\n DEFUN(open_class, (filename, jcf, fd, dep_name),\n       const char *filename AND JCF *jcf AND int fd AND const char *dep_name)\n@@ -289,24 +265,16 @@ DEFUN(open_class, (filename, jcf, fd, dep_name),\n     close (fd);\n   return filename;\n }\n-#endif\n \n \n const char *\n DEFUN(find_classfile, (filename, jcf, dep_name),\n       char *filename AND JCF *jcf AND const char *dep_name)\n {\n-#if JCF_USE_STDIO\n-  FILE *stream = fopen (filename, \"rb\");\n-  if (stream == NULL)\n-    return NULL;\n-  return open_class (arg, jcf, stream, dep_name);\n-#else\n   int fd = open (filename, O_RDONLY | O_BINARY);\n   if (fd < 0)\n     return NULL;\n   return open_class (filename, jcf, fd, dep_name);\n-#endif\n }\n \n #if JCF_USE_SCANDIR\n@@ -461,11 +429,7 @@ DEFUN(find_class, (classname, classname_length, jcf, source_ok),\n       const char *classname AND int classname_length AND JCF *jcf AND int source_ok)\n \n {\n-#if JCF_USE_STDIO\n-  FILE *stream;\n-#else\n   int fd;\n-#endif\n   int i, k, java = -1, class = -1;\n   struct stat java_buf, class_buf;\n   char *dep_file;\n@@ -578,27 +542,6 @@ DEFUN(find_class, (classname, classname_length, jcf, source_ok),\n     dep_file = java_buffer;\n   else\n     dep_file = buffer;\n-#if JCF_USE_STDIO\n-  if (!class)\n-    {\n-      SOURCE_FRONTEND_DEBUG ((\"Trying %s\", buffer));\n-      stream = fopen (buffer, \"rb\");\n-      if (stream)\n-\tgoto found;\n-    }\n-  /* Give .java a try, if necessary */\n-  if (!java)\n-    {\n-      strcpy (buffer, java_buffer);\n-      SOURCE_FRONTEND_DEBUG ((\"Trying %s\", buffer));\n-      stream = fopen (buffer, \"r\");\n-      if (stream)\n-\t{\n-\t  jcf->java_source = 1;\n-\t  goto found;\n-\t}\n-    }\n-#else\n   if (!class)\n     {\n       SOURCE_FRONTEND_DEBUG ((stderr, \"[Class selected: %s]\\n\",\n@@ -624,7 +567,6 @@ DEFUN(find_class, (classname, classname_length, jcf, source_ok),\n \t  goto found;\n \t}\n     }\n-#endif\n \n   free (buffer);\n \n@@ -635,12 +577,6 @@ DEFUN(find_class, (classname, classname_length, jcf, source_ok),\n \n   return NULL;\n  found:\n-#if JCF_USE_STDIO\n-  if (jcf->java_source)\n-    return NULL;\t\t/* FIXME */\n-  else\n-    return open_class (buffer, jcf, stream, dep_file);\n-#else\n   if (jcf->java_source)\n     {\n       JCF_ZERO (jcf);\t\t/* JCF_FINISH relies on this */\n@@ -652,7 +588,6 @@ DEFUN(find_class, (classname, classname_length, jcf, source_ok),\n     buffer = (char *) open_class (buffer, jcf, fd, dep_file);\n   jcf->classname = xstrdup (classname);\n   return buffer;\n-#endif\n }\n \n void"}, {"sha": "3b1f5d6c91c24fb9f7d496f2f384a7e7575a4c3d", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02ebb18348ef5ef1f334bfc9ece21e390f658a0/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02ebb18348ef5ef1f334bfc9ece21e390f658a0/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=c02ebb18348ef5ef1f334bfc9ece21e390f658a0", "patch": "@@ -193,9 +193,7 @@ set_source_filename (jcf, index)\n   DECL_LINENUMBERS_OFFSET (current_method) = 0)\n \n #define HANDLE_END_METHODS() \\\n-{ tree handle_type = CLASS_TO_HANDLE_TYPE (current_class); \\\n-  if (handle_type != current_class) layout_type (handle_type); \\\n-  current_method = NULL_TREE; }\n+{ current_method = NULL_TREE; }\n \n #define HANDLE_CODE_ATTRIBUTE(MAX_STACK, MAX_LOCALS, CODE_LENGTH) \\\n { DECL_MAX_STACK (current_method) = (MAX_STACK); \\\n@@ -745,12 +743,12 @@ parse_class_file ()\n      compiling from class files.  */\n   always_initialize_class_p = 1;\n \n-  for (field = TYPE_FIELDS (CLASS_TO_HANDLE_TYPE (current_class));\n+  for (field = TYPE_FIELDS (current_class);\n        field != NULL_TREE; field = TREE_CHAIN (field))\n     if (FIELD_STATIC (field))\n       DECL_EXTERNAL (field) = 0;\n \n-  for (method = TYPE_METHODS (CLASS_TO_HANDLE_TYPE (current_class));\n+  for (method = TYPE_METHODS (current_class);\n        method != NULL_TREE; method = TREE_CHAIN (method))\n     {\n       JCF *jcf = current_jcf;"}, {"sha": "e00834bf602aa3029ae6f135b45f653b3d25e67d", "filename": "gcc/java/parse.y", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02ebb18348ef5ef1f334bfc9ece21e390f658a0/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02ebb18348ef5ef1f334bfc9ece21e390f658a0/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=c02ebb18348ef5ef1f334bfc9ece21e390f658a0", "patch": "@@ -1896,6 +1896,7 @@ catch_clause:\n \t\t  exit_block ();\n \t\t  $$ = $1;\n \t\t}\n+;\n \n catch_clause_parameter:\n \tCATCH_TK OP_TK formal_parameter CP_TK\n@@ -6303,7 +6304,7 @@ java_check_regular_methods (class_decl)\n {\n   int saw_constructor = ANONYMOUS_CLASS_P (TREE_TYPE (class_decl));\n   tree method;\n-  tree class = CLASS_TO_HANDLE_TYPE (TREE_TYPE (class_decl));\n+  tree class = TREE_TYPE (class_decl);\n   tree found = NULL_TREE;\n   tree mthrows;\n "}, {"sha": "86bc024b4b8e792565786a64d021af39ad11fc03", "filename": "gcc/java/typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02ebb18348ef5ef1f334bfc9ece21e390f658a0/gcc%2Fjava%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02ebb18348ef5ef1f334bfc9ece21e390f658a0/gcc%2Fjava%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Ftypeck.c?ref=c02ebb18348ef5ef1f334bfc9ece21e390f658a0", "patch": "@@ -446,7 +446,7 @@ promote_type (type)\n   switch (TREE_CODE (type))\n     {\n     case RECORD_TYPE:\n-      return build_pointer_type (CLASS_TO_HANDLE_TYPE (type));\n+      return build_pointer_type (type);\n     case BOOLEAN_TYPE:\n       if (type == boolean_type_node)\n \treturn promoted_boolean_type_node;"}, {"sha": "b81927e6913fcbc024c9320d5d026733bb9e545d", "filename": "gcc/java/verify.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02ebb18348ef5ef1f334bfc9ece21e390f658a0/gcc%2Fjava%2Fverify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02ebb18348ef5ef1f334bfc9ece21e390f658a0/gcc%2Fjava%2Fverify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fverify.c?ref=c02ebb18348ef5ef1f334bfc9ece21e390f658a0", "patch": "@@ -145,8 +145,8 @@ merge_types (type1, type2)\n       if (type2 == ptr_type_node || type1 == object_ptr_type_node)\n \treturn type1;\n \n-      tt1 = HANDLE_TO_CLASS_TYPE (TREE_TYPE (type1));\n-      tt2 = HANDLE_TO_CLASS_TYPE (TREE_TYPE (type2));\n+      tt1 = TREE_TYPE (type1);\n+      tt2 = TREE_TYPE (type2);\n \n       /* If tt{1,2} haven't been properly loaded, now is a good time\n          to do it. */"}]}