{"sha": "2872152c39fbc1c91da3fc07e8701fadb6b87f98", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjg3MjE1MmMzOWZiYzFjOTFkYTNmYzA3ZTg3MDFmYWRiNmI4N2Y5OA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2010-05-19T21:01:50Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2010-05-19T21:01:50Z"}, "message": "re PR c++/44193 (function types, cv-quals and typename)\n\n\tPR c++/44193\n\t* typeck.c (type_memfn_quals): New fn.\n\t(apply_memfn_quals): New fn.\n\t(cp_type_quals): Return TYPE_UNQUALIFIED for FUNCTION_TYPE.\n\t(cp_type_readonly): Use cp_type_quals.\n\t* cp-tree.h: Add declarations.\n\t* tree.c (cp_build_qualified_type_real): Don't set, but do\n\tpreserve, quals on FUNCTION_TYPE.\n\t(strip_typedefs): Use apply_memfn_quals and type_memfn_quals.\n\t* decl.c (build_ptrmem_type): Likewise.\n\t(grokdeclarator): Likewise.\n\t(static_fn_type): Likewise.\n\t* decl2.c (change_return_type): Likewise.\n\t(cp_reconstruct_complex_type): Likewise.\n\t* pt.c (tsubst_function_type): Likewise.\n\t(unify): Likewise.\n\t(tsubst): Likewise.  Drop special FUNCTION_TYPE substitution code.\n\nFrom-SVN: r159596", "tree": {"sha": "a224afc9e9939a2cfe3c63c93d01f4adfa3c5a9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a224afc9e9939a2cfe3c63c93d01f4adfa3c5a9d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2872152c39fbc1c91da3fc07e8701fadb6b87f98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2872152c39fbc1c91da3fc07e8701fadb6b87f98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2872152c39fbc1c91da3fc07e8701fadb6b87f98", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2872152c39fbc1c91da3fc07e8701fadb6b87f98/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1961ffb8cd83ccb0f91ce9b3015bb3290f48b04b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1961ffb8cd83ccb0f91ce9b3015bb3290f48b04b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1961ffb8cd83ccb0f91ce9b3015bb3290f48b04b"}], "stats": {"total": 155, "additions": 123, "deletions": 32}, "files": [{"sha": "255ecd3e5c5a550244a8360617bff72a0c6f6db6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2872152c39fbc1c91da3fc07e8701fadb6b87f98/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2872152c39fbc1c91da3fc07e8701fadb6b87f98/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2872152c39fbc1c91da3fc07e8701fadb6b87f98", "patch": "@@ -1,3 +1,23 @@\n+2010-05-19  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/44193\n+\t* typeck.c (type_memfn_quals): New fn.\n+\t(apply_memfn_quals): New fn.\n+\t(cp_type_quals): Return TYPE_UNQUALIFIED for FUNCTION_TYPE.\n+\t(cp_type_readonly): Use cp_type_quals.\n+\t* cp-tree.h: Add declarations.\n+\t* tree.c (cp_build_qualified_type_real): Don't set, but do\n+\tpreserve, quals on FUNCTION_TYPE.\n+\t(strip_typedefs): Use apply_memfn_quals and type_memfn_quals.\n+\t* decl.c (build_ptrmem_type): Likewise.\n+\t(grokdeclarator): Likewise.\n+\t(static_fn_type): Likewise.\n+\t* decl2.c (change_return_type): Likewise.\n+\t(cp_reconstruct_complex_type): Likewise.\n+\t* pt.c (tsubst_function_type): Likewise.\n+\t(unify): Likewise.\n+\t(tsubst): Likewise.  Drop special FUNCTION_TYPE substitution code.\n+\n 2010-05-18  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* tree.c (build_min_non_dep_call_vec): Update comment."}, {"sha": "6a0dd12aa8fd651e229e7444c6ed0621cb920aab", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2872152c39fbc1c91da3fc07e8701fadb6b87f98/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2872152c39fbc1c91da3fc07e8701fadb6b87f98/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=2872152c39fbc1c91da3fc07e8701fadb6b87f98", "patch": "@@ -5413,6 +5413,8 @@ extern bool error_type_p\t\t\t(const_tree);\n extern int ptr_reasonably_similar\t\t(const_tree, const_tree);\n extern tree build_ptrmemfunc\t\t\t(tree, tree, int, bool);\n extern int cp_type_quals\t\t\t(const_tree);\n+extern int type_memfn_quals\t\t\t(const_tree);\n+extern tree apply_memfn_quals\t\t\t(tree, cp_cv_quals);\n extern bool cp_type_readonly\t\t\t(const_tree);\n extern bool cp_has_mutable_p\t\t\t(const_tree);\n extern bool at_least_as_qualified_p\t\t(const_tree, const_tree);"}, {"sha": "e57a753ea361c9c00570f3340bc0c22106bc2359", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2872152c39fbc1c91da3fc07e8701fadb6b87f98/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2872152c39fbc1c91da3fc07e8701fadb6b87f98/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=2872152c39fbc1c91da3fc07e8701fadb6b87f98", "patch": "@@ -7265,8 +7265,7 @@ build_ptrmem_type (tree class_type, tree member_type)\n {\n   if (TREE_CODE (member_type) == METHOD_TYPE)\n     {\n-      tree arg_types = TYPE_ARG_TYPES (member_type);\n-      cp_cv_quals quals = cp_type_quals (TREE_TYPE (TREE_VALUE (arg_types)));\n+      cp_cv_quals quals = type_memfn_quals (member_type);\n       member_type = build_memfn_type (member_type, class_type, quals);\n       return build_ptrmemfunc_type (build_pointer_type (member_type));\n     }\n@@ -8683,15 +8682,15 @@ grokdeclarator (const cp_declarator *declarator,\n \t      && (TREE_CODE (type) == FUNCTION_TYPE\n \t\t  || (memfn_quals && TREE_CODE (type) == METHOD_TYPE)))\n \t    {\n-\t      memfn_quals |= cp_type_quals (type);\n+\t      memfn_quals |= type_memfn_quals (type);\n \t      type = build_memfn_type (type,\n \t\t\t\t       declarator->u.pointer.class_type,\n \t\t\t\t       memfn_quals);\n \t      memfn_quals = TYPE_UNQUALIFIED;\n \t    }\n \n \t  if (TREE_CODE (type) == FUNCTION_TYPE\n-\t      && cp_type_quals (type) != TYPE_UNQUALIFIED)\n+\t      && type_memfn_quals (type) != TYPE_UNQUALIFIED)\n             error (declarator->kind == cdk_reference\n                    ? G_(\"cannot declare reference to qualified function type %qT\")\n                    : G_(\"cannot declare pointer to qualified function type %qT\"),\n@@ -8994,7 +8993,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t function type.  */\n       if (memfn_quals && TREE_CODE (type) == FUNCTION_TYPE)\n         {\n-          type = cp_build_qualified_type (type, memfn_quals);\n+          type = apply_memfn_quals (type, memfn_quals);\n           \n           /* We have now dealt with these qualifiers.  */\n           memfn_quals = TYPE_UNQUALIFIED;\n@@ -9114,7 +9113,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t{\n \t  /* A cv-qualifier-seq shall only be part of the function type\n \t     for a non-static member function. [8.3.5/4 dcl.fct] */\n-\t  if (cp_type_quals (type) != TYPE_UNQUALIFIED\n+\t  if (type_memfn_quals (type) != TYPE_UNQUALIFIED\n \t      && (current_class_type == NULL_TREE || staticp) )\n \t    {\n \t      error (staticp\n@@ -9127,7 +9126,7 @@ grokdeclarator (const cp_declarator *declarator,\n \n \t  /* The qualifiers on the function type become the qualifiers on\n \t     the non-static member function. */\n-\t  memfn_quals |= cp_type_quals (type);\n+\t  memfn_quals |= type_memfn_quals (type);\n \t  type_quals = TYPE_UNQUALIFIED;\n \t}\n     }\n@@ -9195,7 +9194,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t    type = build_memfn_type (type, ctype, memfn_quals);\n \t  /* Core issue #547: need to allow this in template type args.  */\n \t  else if (template_type_arg && TREE_CODE (type) == FUNCTION_TYPE)\n-\t    type = cp_build_qualified_type (type, memfn_quals);\n+\t    type = apply_memfn_quals (type, memfn_quals);\n \t  else\n \t    error (\"invalid qualifiers on non-member function type\");\n \t}\n@@ -12944,7 +12943,6 @@ static_fn_type (tree memfntype)\n {\n   tree fntype;\n   tree args;\n-  int quals;\n \n   if (TYPE_PTRMEMFUNC_P (memfntype))\n     memfntype = TYPE_PTRMEMFUNC_FN_TYPE (memfntype);\n@@ -12956,8 +12954,7 @@ static_fn_type (tree memfntype)\n   gcc_assert (TREE_CODE (memfntype) == METHOD_TYPE);\n   args = TYPE_ARG_TYPES (memfntype);\n   fntype = build_function_type (TREE_TYPE (memfntype), TREE_CHAIN (args));\n-  quals = cp_type_quals (TREE_TYPE (TREE_VALUE (args)));\n-  fntype = build_qualified_type (fntype, quals);\n+  fntype = apply_memfn_quals (fntype, type_memfn_quals (memfntype));\n   fntype = (cp_build_type_attribute_variant\n \t    (fntype, TYPE_ATTRIBUTES (memfntype)));\n   fntype = (build_exception_variant"}, {"sha": "29971cebbf0c2c94016da79e17a5812c51bb90d4", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2872152c39fbc1c91da3fc07e8701fadb6b87f98/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2872152c39fbc1c91da3fc07e8701fadb6b87f98/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=2872152c39fbc1c91da3fc07e8701fadb6b87f98", "patch": "@@ -154,7 +154,10 @@ change_return_type (tree new_ret, tree fntype)\n     return fntype;\n \n   if (TREE_CODE (fntype) == FUNCTION_TYPE)\n-    newtype = build_function_type (new_ret, args);\n+    {\n+      newtype = build_function_type (new_ret, args);\n+      newtype = apply_memfn_quals (newtype, type_memfn_quals (fntype));\n+    }\n   else\n     newtype = build_method_type_directly\n       (TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (fntype))),\n@@ -1246,6 +1249,7 @@ cp_reconstruct_complex_type (tree type, tree bottom)\n     {\n       inner = cp_reconstruct_complex_type (TREE_TYPE (type), bottom);\n       outer = build_function_type (inner, TYPE_ARG_TYPES (type));\n+      outer = apply_memfn_quals (outer, type_memfn_quals (type));\n     }\n   else if (TREE_CODE (type) == METHOD_TYPE)\n     {"}, {"sha": "949734dc22040ceb1d52a9205158cadf194054b2", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2872152c39fbc1c91da3fc07e8701fadb6b87f98/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2872152c39fbc1c91da3fc07e8701fadb6b87f98/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=2872152c39fbc1c91da3fc07e8701fadb6b87f98", "patch": "@@ -9791,7 +9791,10 @@ tsubst_function_type (tree t,\n \n   /* Construct a new type node and return it.  */\n   if (TREE_CODE (t) == FUNCTION_TYPE)\n-    fntype = build_function_type (return_type, arg_types);\n+    {\n+      fntype = build_function_type (return_type, arg_types);\n+      fntype = apply_memfn_quals (fntype, type_memfn_quals (t));\n+    }\n   else\n     {\n       tree r = TREE_TYPE (TREE_VALUE (arg_types));\n@@ -9813,7 +9816,6 @@ tsubst_function_type (tree t,\n       fntype = build_method_type_directly (r, return_type,\n \t\t\t\t\t   TREE_CHAIN (arg_types));\n     }\n-  fntype = cp_build_qualified_type_real (fntype, TYPE_QUALS (t), complain);\n   fntype = cp_build_type_attribute_variant (fntype, TYPE_ATTRIBUTES (t));\n \n   return fntype;\n@@ -10111,14 +10113,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t\tint quals;\n \t\tgcc_assert (TYPE_P (arg));\n \n-\t\t/* cv-quals from the template are discarded when\n-\t\t   substituting in a function or reference type.  */\n-\t\tif (TREE_CODE (arg) == FUNCTION_TYPE\n-\t\t    || TREE_CODE (arg) == METHOD_TYPE\n-\t\t    || TREE_CODE (arg) == REFERENCE_TYPE)\n-\t\t  quals = cp_type_quals (arg);\n-\t\telse\n-\t\t  quals = cp_type_quals (arg) | cp_type_quals (t);\n+\t\tquals = cp_type_quals (arg) | cp_type_quals (t);\n \t\t  \n \t\treturn cp_build_qualified_type_real\n \t\t  (arg, quals, complain | tf_ignore_bad_quals);\n@@ -10378,7 +10373,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t    /* The type of the implicit object parameter gets its\n \t       cv-qualifiers from the FUNCTION_TYPE. */\n \t    tree memptr;\n-\t    tree method_type = build_memfn_type (type, r, cp_type_quals (type));\n+\t    tree method_type = build_memfn_type (type, r, type_memfn_quals (type));\n \t    memptr = build_ptrmemfunc_type (build_pointer_type (method_type));\n \t    return cp_build_qualified_type_real (memptr, cp_type_quals (t),\n \t\t\t\t\t\t complain);\n@@ -15042,7 +15037,6 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \t{\n \t  tree method_type;\n \t  tree fntype;\n-\t  cp_cv_quals cv_quals;\n \n \t  /* Check top-level cv qualifiers */\n \t  if (!check_cv_quals_for_unify (UNIFY_ALLOW_NONE, arg, parm))\n@@ -15061,9 +15055,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \t  /* Extract the cv-qualifiers of the member function from the\n \t     implicit object parameter and place them on the function\n \t     type to be restored later. */\n-\t  cv_quals =\n-\t    cp_type_quals(TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (method_type))));\n-\t  fntype = build_qualified_type (fntype, cv_quals);\n+\t  fntype = apply_memfn_quals (fntype, type_memfn_quals (method_type));\n \t  return unify (tparms, targs, TREE_TYPE (parm), fntype, strict);\n \t}\n "}, {"sha": "04bfae0b1eee0aefd9feb1c547775ff57de2691b", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2872152c39fbc1c91da3fc07e8701fadb6b87f98/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2872152c39fbc1c91da3fc07e8701fadb6b87f98/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=2872152c39fbc1c91da3fc07e8701fadb6b87f98", "patch": "@@ -868,12 +868,17 @@ cp_build_qualified_type_real (tree type,\n      [dcl.ref], [dcl.fct]  */\n   if (type_quals & (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE)\n       && (TREE_CODE (type) == REFERENCE_TYPE\n+\t  || TREE_CODE (type) == FUNCTION_TYPE\n \t  || TREE_CODE (type) == METHOD_TYPE))\n     {\n       bad_quals |= type_quals & (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE);\n       type_quals &= ~(TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE);\n     }\n \n+  /* But preserve any function-cv-quals on a FUNCTION_TYPE.  */\n+  if (TREE_CODE (type) == FUNCTION_TYPE)\n+    type_quals |= type_memfn_quals (type);\n+\n   /* A restrict-qualified type must be a pointer (or reference)\n      to object or incomplete type. */\n   if ((type_quals & TYPE_QUAL_RESTRICT)\n@@ -1038,8 +1043,11 @@ strip_typedefs (tree t)\n \t\t\t\t\t  TREE_CHAIN (arg_types));\n \t  }\n \telse\n+\t  {\n \t    result = build_function_type (type,\n \t\t\t\t\t  arg_types);\n+\t    result = apply_memfn_quals (result, type_memfn_quals (t));\n+\t  }\n \n \tif (TYPE_RAISES_EXCEPTIONS (t))\n \t  result = build_exception_variant (result,"}, {"sha": "a291a9cec306fbc98e9333282703b94886c8cde6", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 42, "deletions": 5, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2872152c39fbc1c91da3fc07e8701fadb6b87f98/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2872152c39fbc1c91da3fc07e8701fadb6b87f98/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=2872152c39fbc1c91da3fc07e8701fadb6b87f98", "patch": "@@ -7851,12 +7851,50 @@ comp_ptr_ttypes_const (tree to, tree from)\n int\n cp_type_quals (const_tree type)\n {\n+  int quals;\n   /* This CONST_CAST is okay because strip_array_types returns its\n      argument unmodified and we assign it to a const_tree.  */\n-  type = strip_array_types (CONST_CAST_TREE(type));\n-  if (type == error_mark_node)\n+  type = strip_array_types (CONST_CAST_TREE (type));\n+  if (type == error_mark_node\n+      /* Quals on a FUNCTION_TYPE are memfn quals.  */\n+      || TREE_CODE (type) == FUNCTION_TYPE)\n     return TYPE_UNQUALIFIED;\n-  return TYPE_QUALS (type);\n+  quals = TYPE_QUALS (type);\n+  /* METHOD and REFERENCE_TYPEs should never have quals.  */\n+  gcc_assert ((TREE_CODE (type) != METHOD_TYPE\n+\t       && TREE_CODE (type) != REFERENCE_TYPE)\n+\t      || ((quals & (TYPE_QUAL_CONST|TYPE_QUAL_VOLATILE))\n+\t\t  == TYPE_UNQUALIFIED));\n+  return quals;\n+}\n+\n+/* Returns the function-cv-quals for TYPE, which must be a FUNCTION_TYPE or\n+   METHOD_TYPE.  */\n+\n+int\n+type_memfn_quals (const_tree type)\n+{\n+  if (TREE_CODE (type) == FUNCTION_TYPE)\n+    return TYPE_QUALS (type);\n+  else if (TREE_CODE (type) == METHOD_TYPE)\n+    return cp_type_quals (TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (type))));\n+  else\n+    gcc_unreachable ();\n+}\n+\n+/* Returns the FUNCTION_TYPE TYPE with its function-cv-quals changed to\n+   MEMFN_QUALS.  */\n+\n+tree\n+apply_memfn_quals (tree type, cp_cv_quals memfn_quals)\n+{\n+  /* Could handle METHOD_TYPE here if necessary.  */\n+  gcc_assert (TREE_CODE (type) == FUNCTION_TYPE);\n+  if (TYPE_QUALS (type) == memfn_quals)\n+    return type;\n+  /* This should really have a different TYPE_MAIN_VARIANT, but that gets\n+     complex.  */\n+  return build_qualified_type (type, memfn_quals);\n }\n \n /* Returns nonzero if the TYPE is const from a C++ perspective: look inside\n@@ -7867,8 +7905,7 @@ cp_type_readonly (const_tree type)\n {\n   /* This CONST_CAST is okay because strip_array_types returns its\n      argument unmodified and we assign it to a const_tree.  */\n-  type = strip_array_types (CONST_CAST_TREE(type));\n-  return TYPE_READONLY (type);\n+  return (cp_type_quals (type) & TYPE_QUAL_CONST) != 0;\n }\n \n /* Returns nonzero if TYPE is const or volatile.  */"}, {"sha": "7339c62227021515d8d59f0ab8f49e7302beea20", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2872152c39fbc1c91da3fc07e8701fadb6b87f98/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2872152c39fbc1c91da3fc07e8701fadb6b87f98/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2872152c39fbc1c91da3fc07e8701fadb6b87f98", "patch": "@@ -1,3 +1,8 @@\n+2010-05-19  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/44193\n+\t* g++.dg/template/fntype1.C: New.\n+\n 2010-05-19  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/discr23.ad[sb]: New test."}, {"sha": "d7be273aa42192ec940738ceac9c81134c17195b", "filename": "gcc/testsuite/g++.dg/template/fntype1.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2872152c39fbc1c91da3fc07e8701fadb6b87f98/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffntype1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2872152c39fbc1c91da3fc07e8701fadb6b87f98/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffntype1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffntype1.C?ref=2872152c39fbc1c91da3fc07e8701fadb6b87f98", "patch": "@@ -0,0 +1,26 @@\n+bool f(int i) { return i != 5; }\n+\n+template <class X, class P = bool(X)>\n+struct Traits\n+{\n+ typedef P type;\n+};\n+\n+template <class X, class P = typename Traits<X>::type>\n+struct S\n+{\n+ const P& p_;\n+ S( const P& p ) : p_(p) {} // const reference\n+};\n+\n+template <class X>\n+S<X> make_s(const typename Traits<X>::type & p) // const reference\n+{\n+ return S<X>(p); // << HERE\n+}\n+\n+\n+int main()\n+{\n+ make_s<int>(f);\n+}"}]}