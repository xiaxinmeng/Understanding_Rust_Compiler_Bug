{"sha": "e18724aa469909d34a3bc795aee7dbfb43234f8c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTE4NzI0YWE0Njk5MDlkMzRhM2JjNzk1YWVlN2RiZmI0MzIzNGY4Yw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2013-01-25T17:55:09Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2013-01-25T17:55:09Z"}, "message": "re PR c++/56104 (Wrong \"dereferencing type-punned pointer\" warning)\n\n\tPR c++/56104\n\t* typeck.c (get_member_function_from_ptrfunc): Optimize if the\n\tdynamic type has no virtual functions.\n\nFrom-SVN: r195470", "tree": {"sha": "5e2df0316d27809d43a8136fcd1dfb5585f1bac9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e2df0316d27809d43a8136fcd1dfb5585f1bac9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e18724aa469909d34a3bc795aee7dbfb43234f8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e18724aa469909d34a3bc795aee7dbfb43234f8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e18724aa469909d34a3bc795aee7dbfb43234f8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e18724aa469909d34a3bc795aee7dbfb43234f8c/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b7d7d917bd3ec775d21abfe4eab582de3cf461c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7d7d917bd3ec775d21abfe4eab582de3cf461c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7d7d917bd3ec775d21abfe4eab582de3cf461c7"}], "stats": {"total": 59, "additions": 49, "deletions": 10}, "files": [{"sha": "3d304917b3c574c29b0fbb225ec542f3cc07772a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e18724aa469909d34a3bc795aee7dbfb43234f8c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e18724aa469909d34a3bc795aee7dbfb43234f8c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e18724aa469909d34a3bc795aee7dbfb43234f8c", "patch": "@@ -1,3 +1,9 @@\n+2013-01-25  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/56104\n+\t* typeck.c (get_member_function_from_ptrfunc): Optimize if the\n+\tdynamic type has no virtual functions.\n+\n 2013-01-22  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/55944"}, {"sha": "bfac39494e2a6c736f3f550ac4f52cdaac0c04d0", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e18724aa469909d34a3bc795aee7dbfb43234f8c/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e18724aa469909d34a3bc795aee7dbfb43234f8c/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=e18724aa469909d34a3bc795aee7dbfb43234f8c", "patch": "@@ -3122,7 +3122,8 @@ build_array_ref (location_t loc, tree array, tree idx)\n    With the final ISO C++ rules, such an optimization is\n    incorrect: A pointer to a derived member can be static_cast\n    to pointer-to-base-member, as long as the dynamic object\n-   later has the right member.  */\n+   later has the right member.  So now we only do this optimization\n+   when we know the dynamic type of the object.  */\n \n tree\n get_member_function_from_ptrfunc (tree *instance_ptrptr, tree function,\n@@ -3133,8 +3134,10 @@ get_member_function_from_ptrfunc (tree *instance_ptrptr, tree function,\n \n   if (TYPE_PTRMEMFUNC_P (TREE_TYPE (function)))\n     {\n-      tree idx, delta, e1, e2, e3, vtbl, basetype;\n+      tree idx, delta, e1, e2, e3, vtbl;\n+      bool nonvirtual;\n       tree fntype = TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (function));\n+      tree basetype = TYPE_METHOD_BASETYPE (TREE_TYPE (fntype));\n \n       tree instance_ptr = *instance_ptrptr;\n       tree instance_save_expr = 0;\n@@ -3157,6 +3160,12 @@ get_member_function_from_ptrfunc (tree *instance_ptrptr, tree function,\n \t    }\n \t}\n \n+      /* True if we know that the dynamic type of the object doesn't have\n+\t virtual functions, so we can assume the PFN field is a pointer.  */\n+      nonvirtual = (COMPLETE_TYPE_P (basetype)\n+\t\t    && !TYPE_POLYMORPHIC_P (basetype)\n+\t\t    && resolves_to_fixed_type_p (instance_ptr, 0));\n+\n       if (TREE_SIDE_EFFECTS (instance_ptr))\n \tinstance_ptr = instance_save_expr = save_expr (instance_ptr);\n \n@@ -3167,7 +3176,9 @@ get_member_function_from_ptrfunc (tree *instance_ptrptr, tree function,\n       e3 = pfn_from_ptrmemfunc (function);\n       delta = delta_from_ptrmemfunc (function);\n       idx = build1 (NOP_EXPR, vtable_index_type, e3);\n-      switch (TARGET_PTRMEMFUNC_VBIT_LOCATION)\n+      if (nonvirtual)\n+\te1 = integer_zero_node;\n+      else switch (TARGET_PTRMEMFUNC_VBIT_LOCATION)\n \t{\n \tcase ptrmemfunc_vbit_in_pfn:\n \t  e1 = cp_build_binary_op (input_location,\n@@ -3204,7 +3215,6 @@ get_member_function_from_ptrfunc (tree *instance_ptrptr, tree function,\n \t a member of C, and no conversion is required.  In fact,\n \t lookup_base will fail in that case, because incomplete\n \t classes do not have BINFOs.  */\n-      basetype = TYPE_METHOD_BASETYPE (TREE_TYPE (fntype));\n       if (!same_type_ignoring_top_level_qualifiers_p\n \t  (basetype, TREE_TYPE (TREE_TYPE (instance_ptr))))\n \t{\n@@ -3221,18 +3231,17 @@ get_member_function_from_ptrfunc (tree *instance_ptrptr, tree function,\n       /* Hand back the adjusted 'this' argument to our caller.  */\n       *instance_ptrptr = instance_ptr;\n \n+      if (nonvirtual)\n+\t/* Now just return the pointer.  */\n+\treturn e3;\n+\n       /* Next extract the vtable pointer from the object.  */\n       vtbl = build1 (NOP_EXPR, build_pointer_type (vtbl_ptr_type_node),\n \t\t     instance_ptr);\n       vtbl = cp_build_indirect_ref (vtbl, RO_NULL, complain);\n       if (vtbl == error_mark_node)\n \treturn error_mark_node;\n \n-      /* If the object is not dynamic the access invokes undefined\n-\t behavior.  As it is not executed in this case silence the\n-\t spurious warnings it may provoke.  */\n-      TREE_NO_WARNING (vtbl) = 1;\n-\n       /* Finally, extract the function pointer from the vtable.  */\n       e2 = fold_build_pointer_plus_loc (input_location, vtbl, idx);\n       e2 = cp_build_indirect_ref (e2, RO_NULL, complain);"}, {"sha": "be138190b0970396ae70917c113af0619f36bf44", "filename": "gcc/testsuite/g++.dg/warn/pmf2.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e18724aa469909d34a3bc795aee7dbfb43234f8c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpmf2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e18724aa469909d34a3bc795aee7dbfb43234f8c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpmf2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpmf2.C?ref=e18724aa469909d34a3bc795aee7dbfb43234f8c", "patch": "@@ -0,0 +1,24 @@\n+// PR c++/56104\n+// { dg-options \"-Wall -O2\" }\n+\n+struct Foo\n+{\n+  Foo();\n+  Foo(const Foo&);\n+    void call()\n+    {}\n+};\n+\n+template<class MEMSIG, MEMSIG MEMFUNC>\n+struct Wrap\n+{\n+    inline static void call( Foo cc )\n+    {\n+      (cc.*MEMFUNC)();     // <- warning here\n+    }\n+};\n+\n+void bar()\n+{\n+  Wrap<void (Foo::*)(), &Foo::call>::call( Foo() );\n+}"}, {"sha": "aa1ea3efaefb543cb4a403cc08ce6028d629af73", "filename": "gcc/testsuite/g++.old-deja/g++.mike/pmf1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e18724aa469909d34a3bc795aee7dbfb43234f8c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fpmf1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e18724aa469909d34a3bc795aee7dbfb43234f8c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fpmf1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fpmf1.C?ref=e18724aa469909d34a3bc795aee7dbfb43234f8c", "patch": "@@ -1,5 +1,5 @@\n // { dg-do run  }\n-// extern \"C\" printf(const char *, ...);\n+// extern \"C\" int printf(const char *, ...);\n \n class X\n {"}]}