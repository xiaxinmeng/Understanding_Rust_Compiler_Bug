{"sha": "a04d9035ec03996fd6f96a1ece21bc8d4c54cd40", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTA0ZDkwMzVlYzAzOTk2ZmQ2Zjk2YTFlY2UyMWJjOGQ0YzU0Y2Q0MA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-05-19T00:58:43Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-05-19T00:58:43Z"}, "message": "tree-pass.h (make_pass_ipa_comdats): New pass.\n\n\n\t* tree-pass.h (make_pass_ipa_comdats): New pass.\n\t* timevar.def (TV_IPA_COMDATS): New timevar.\n\t* passes.def (pass_ipa_comdats): Add.\n\t* Makefile.in (OBJS): Add ipa-comdats.o\n\t* ipa-comdats.c: New file.\n\n\t* g++.dg/ipa/comdat.C: New file.\n\nFrom-SVN: r210597", "tree": {"sha": "353bbd6b2ed6da4c5c83773cb11308dfd538b143", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/353bbd6b2ed6da4c5c83773cb11308dfd538b143"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a04d9035ec03996fd6f96a1ece21bc8d4c54cd40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a04d9035ec03996fd6f96a1ece21bc8d4c54cd40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a04d9035ec03996fd6f96a1ece21bc8d4c54cd40", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a04d9035ec03996fd6f96a1ece21bc8d4c54cd40/comments", "author": null, "committer": null, "parents": [{"sha": "449cdb37f016280cc689190e3c75da618f17493b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/449cdb37f016280cc689190e3c75da618f17493b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/449cdb37f016280cc689190e3c75da618f17493b"}], "stats": {"total": 421, "additions": 421, "deletions": 0}, "files": [{"sha": "759110d21e29f90554e4fd3a2533562d2d7d0298", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04d9035ec03996fd6f96a1ece21bc8d4c54cd40/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04d9035ec03996fd6f96a1ece21bc8d4c54cd40/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a04d9035ec03996fd6f96a1ece21bc8d4c54cd40", "patch": "@@ -1,3 +1,11 @@\n+2014-05-17  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* tree-pass.h (make_pass_ipa_comdats): New pass.\n+\t* timevar.def (TV_IPA_COMDATS): New timevar.\n+\t* passes.def (pass_ipa_comdats): Add.\n+\t* Makefile.in (OBJS): Add ipa-comdats.o\n+\t* ipa-comdats.c: New file.\n+\n 2014-05-17  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa.c (update_visibility_by_resolution_info): New function."}, {"sha": "e74bb67c4da86ed3362e9b7c995c9a0895aba749", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04d9035ec03996fd6f96a1ece21bc8d4c54cd40/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04d9035ec03996fd6f96a1ece21bc8d4c54cd40/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=a04d9035ec03996fd6f96a1ece21bc8d4c54cd40", "patch": "@@ -1269,6 +1269,7 @@ OBJS = \\\n \tipa-devirt.o \\\n \tipa-split.o \\\n \tipa-inline.o \\\n+\tipa-comdats.o \\\n \tipa-inline-analysis.o \\\n \tipa-inline-transform.o \\\n \tipa-profile.o \\"}, {"sha": "d6840648fec5102970e954e8b54271b2985eaf8f", "filename": "gcc/ipa-comdats.c", "status": "added", "additions": 387, "deletions": 0, "changes": 387, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04d9035ec03996fd6f96a1ece21bc8d4c54cd40/gcc%2Fipa-comdats.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04d9035ec03996fd6f96a1ece21bc8d4c54cd40/gcc%2Fipa-comdats.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-comdats.c?ref=a04d9035ec03996fd6f96a1ece21bc8d4c54cd40", "patch": "@@ -0,0 +1,387 @@\n+/* Localize comdats.\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* This is very simple pass that looks for static symbols that are used\n+   exlusively by symbol within one comdat group.  In this case it makes\n+   sense to bring the symbol itself into the group to avoid dead code\n+   that would arrise when the comdat group from current unit is replaced\n+   by a different copy.  Consider for example:\n+\n+    static int q(void)\n+    {\n+      ....\n+    }\n+    inline int t(void)\n+    {\n+      return q();\n+    }\n+\n+   if Q is used only by T, it makes sense to put Q into T's comdat group.\n+\n+   The pass solve simple dataflow across the callgraph trying to prove what\n+   symbols are used exclusively from a given comdat group.\n+\n+   The implementation maintains a queue linked by AUX pointer terminated by\n+   pointer value 1. Lattice values are NULL for TOP, actual comdat group, or\n+   ERROR_MARK_NODE for bottom.\n+\n+   TODO: When symbol is used only by comdat symbols, but from different groups,\n+   it would make sense to produce a new comdat group for it with anonymous name.\n+\n+   TODO2: We can't mix variables and functions within one group.  Currently\n+   we just give up on references of symbols of different types.  We also should\n+   handle this by anonymous comdat group section.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"cgraph.h\"\n+#include \"tree-pass.h\"\n+#include \"pointer-set.h\"\n+\n+/* Main dataflow loop propagating comdat groups across\n+   the symbol table.  All references to SYMBOL are examined\n+   and NEWGROUP is updated accordingly. MAP holds current lattice\n+   values for individual symbols.  */\n+\n+tree\n+propagate_comdat_group (struct symtab_node *symbol,\n+\t\t\ttree newgroup, pointer_map <tree> &map)\n+{\n+  int i;\n+  struct ipa_ref *ref;\n+\n+  /* Walk all references to SYMBOL, recursively dive into aliases.  */\n+\n+  for (i = 0;\n+       ipa_ref_list_referring_iterate (&symbol->ref_list, i, ref)\n+       && newgroup != error_mark_node; i++)\n+    {\n+      struct symtab_node *symbol2 = ref->referring;\n+\n+      if (ref->use == IPA_REF_ALIAS)\n+\t{\n+\t  newgroup = propagate_comdat_group (symbol2, newgroup, map);\n+\t  continue;\n+\t}\n+\n+      /* One COMDAT group can not hold both variables and functions at\n+\t a same time.  For now we just go to BOTTOM, in future we may\n+\t invent special comdat groups for this case.  */\n+\n+      if (symbol->type != symbol2->type)\n+\t{\n+\t  newgroup = error_mark_node;\n+\t  break;\n+\t}\n+\n+      /* If we see inline clone, its comdat group actually\n+\t corresponds to the comdat group of the function it is inlined\n+\t to.  */\n+\n+      if (cgraph_node * cn = dyn_cast <cgraph_node *> (symbol2))\n+\t{\n+\t  if (cn->global.inlined_to)\n+\t    symbol2 = cn->global.inlined_to;\n+\t}\n+\n+      /* The actual merge operation.  */\n+\n+      tree *val2 = map.contains (symbol2);\n+\n+      if (val2 && *val2 != newgroup)\n+\t{\n+\t  if (!newgroup)\n+\t    newgroup = *val2;\n+\t  else\n+\t    newgroup = error_mark_node;\n+\t}\n+    }\n+\n+  /* If we analyze function, walk also callers.  */\n+\n+  cgraph_node *cnode = dyn_cast <cgraph_node *> (symbol);\n+\n+  if (cnode)\n+    for (struct cgraph_edge * edge = cnode->callers;\n+\t edge && newgroup != error_mark_node; edge = edge->next_caller)\n+      {\n+\tstruct symtab_node *symbol2 = edge->caller;\n+\n+\t/* If we see inline clone, its comdat group actually\n+\t   corresponds to the comdat group of the function it is inlined\n+\t   to.  */\n+\n+\tif (cgraph_node * cn = dyn_cast <cgraph_node *> (symbol2))\n+\t  {\n+\t    if (cn->global.inlined_to)\n+\t      symbol2 = cn->global.inlined_to;\n+\t  }\n+\n+        /* The actual merge operation.  */\n+\n+\ttree *val2 = map.contains (symbol2);\n+\n+\tif (val2 && *val2 != newgroup)\n+\t  {\n+\t    if (!newgroup)\n+\t      newgroup = *val2;\n+\t    else\n+\t      newgroup = error_mark_node;\n+\t  }\n+      }\n+  return newgroup;\n+}\n+\n+\n+/* Add all references of SYMBOL that are defined into queue started by FIRST\n+   and linked by AUX pointer (unless they are already enqueued).\n+   Walk recursively inlined functions.  */\n+\n+void\n+enqueue_references (symtab_node **first,\n+\t\t    symtab_node *symbol)\n+{\n+  int i;\n+  struct ipa_ref *ref;\n+\n+  for (i = 0; ipa_ref_list_reference_iterate (&symbol->ref_list, i, ref); i++)\n+    {\n+      symtab_node *node = symtab_alias_ultimate_target (ref->referred, NULL);\n+      if (!node->aux && node->definition)\n+\t{\n+\t   node->aux = *first;\n+\t   *first = node;\n+\t}\n+    }\n+\n+  if (cgraph_node *cnode = dyn_cast <cgraph_node *> (symbol))\n+    {\n+      struct cgraph_edge *edge;\n+\n+      for (edge = cnode->callees; edge; edge = edge->next_callee)\n+\tif (!edge->inline_failed)\n+\t  enqueue_references (first, edge->callee);\n+\telse\n+\t  {\n+\t    symtab_node *node = symtab_alias_ultimate_target (edge->callee,\n+\t\t\t\t\t\t\t      NULL);\n+\t    if (!node->aux && node->definition)\n+\t      {\n+\t\t node->aux = *first;\n+\t\t *first = node;\n+\t      }\n+\t  }\n+    }\n+}\n+\n+/* Set comdat group of SYMBOL to GROUP.\n+   Callback for symtab_for_node_and_aliases.  */\n+\n+bool\n+set_comdat_group (symtab_node *symbol,\n+\t          void *head_p)\n+{\n+  symtab_node *head = (symtab_node *)head_p;\n+\n+  gcc_assert (!DECL_COMDAT_GROUP (symbol->decl));\n+  DECL_COMDAT_GROUP (symbol->decl) = DECL_COMDAT_GROUP (head->decl);\n+  symtab_add_to_same_comdat_group (symbol, head);\n+  return false;\n+}\n+\n+/* The actual pass with the main dataflow loop.  */\n+\n+static unsigned int\n+ipa_comdats (void)\n+{\n+  pointer_map<tree> map;\n+  pointer_map<symtab_node *> comdat_head_map;\n+  symtab_node *symbol;\n+  bool comdat_group_seen = false;\n+  symtab_node *first = (symtab_node *) (void *) 1;\n+\n+  /* Start the dataflow by assigning comdat group to symbols that are in comdat\n+     groups already.  All other externally visible symbols must stay, we use\n+     ERROR_MARK_NODE as bottom for the propagation.  */\n+\n+  FOR_EACH_DEFINED_SYMBOL (symbol)\n+    if (!symtab_real_symbol_p (symbol))\n+      ;\n+    else if (DECL_COMDAT_GROUP (symbol->decl))\n+      {\n+        *map.insert (symbol) = DECL_COMDAT_GROUP (symbol->decl);\n+        *comdat_head_map.insert (DECL_COMDAT_GROUP (symbol->decl)) = symbol;\n+\tcomdat_group_seen = true;\n+\n+\t/* Mark the symbol so we won't waste time visiting it for dataflow.  */\n+\tsymbol->aux = (symtab_node *) (void *) 1;\n+      }\n+    /* See symbols that can not be privatized to comdats; that is externally\n+       visible symbols or otherwise used ones.  We also do not want to mangle\n+       user section names.  */\n+    else if (symbol->externally_visible\n+\t     || symbol->force_output\n+\t     || symbol->used_from_other_partition\n+\t     || TREE_THIS_VOLATILE (symbol->decl)\n+\t     || DECL_SECTION_NAME (symbol->decl)\n+\t     || (TREE_CODE (symbol->decl) == FUNCTION_DECL\n+\t\t && (DECL_STATIC_CONSTRUCTOR (symbol->decl)\n+\t\t     || DECL_STATIC_DESTRUCTOR (symbol->decl))))\n+      {\n+\t*map.insert (symtab_alias_ultimate_target (symbol, NULL)) = error_mark_node;\n+\n+\t/* Mark the symbol so we won't waste time visiting it for dataflow.  */\n+\tsymbol->aux = (symtab_node *) (void *) 1;\n+      }\n+    else\n+      {\n+\t/* Enqueue symbol for dataflow.  */\n+        symbol->aux = first;\n+\tfirst = symbol;\n+      }\n+\n+  if (!comdat_group_seen)\n+    {\n+      FOR_EACH_DEFINED_SYMBOL (symbol)\n+        symbol->aux = NULL;\n+      return 0;\n+    }\n+\n+  /* The actual dataflow.  */\n+\n+  while (first != (void *) 1)\n+    {\n+      tree group = NULL;\n+      tree newgroup, *val;\n+\n+      symbol = first;\n+      first = (symtab_node *)first->aux;\n+\n+      /* Get current lattice value of SYMBOL.  */\n+      val = map.contains (symbol);\n+      if (val)\n+\tgroup = *val;\n+\n+      /* If it is bottom, there is nothing to do; do not clear AUX\n+\t so we won't re-queue the symbol.  */\n+      if (group == error_mark_node)\n+\tcontinue;\n+\n+      newgroup = propagate_comdat_group (symbol, group, map);\n+\n+      /* If nothing changed, proceed to next symbol.  */\n+      if (newgroup == group)\n+\t{\n+\t  symbol->aux = NULL;\n+\t  continue;\n+\t}\n+\n+      /* Update lattice value and enqueue all references for re-visiting.  */\n+      gcc_assert (newgroup);\n+      if (val)\n+\t*val = newgroup;\n+      else\n+\t*map.insert (symbol) = newgroup;\n+      enqueue_references (&first, symbol);\n+\n+      /* We may need to revisit the symbol unless it is BOTTOM.  */\n+      if (newgroup != error_mark_node)\n+        symbol->aux = NULL;\n+    }\n+\n+  /* Finally assign symbols to the sections.  */\n+\n+  FOR_EACH_DEFINED_SYMBOL (symbol)\n+    {\n+      symbol->aux = NULL; \n+      if (!DECL_COMDAT_GROUP (symbol->decl)\n+\t  && !symbol->alias\n+\t  && symtab_real_symbol_p (symbol))\n+\t{\n+\t  tree group = *map.contains (symbol);\n+\n+\t  if (group == error_mark_node)\n+\t    continue;\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"Localizing symbol\\n\");\n+\t      dump_symtab_node (dump_file, symbol);\n+\t      fprintf (dump_file, \"To group: %s\\n\", IDENTIFIER_POINTER (group));\n+\t    }\n+\t  symtab_for_node_and_aliases (symbol, set_comdat_group,\n+\t\t\t\t       *comdat_head_map.contains (group), true);\n+\t}\n+    }\n+  return 0;\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_ipa_comdats =\n+{\n+  IPA_PASS, /* type */\n+  \"comdats\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_execute */\n+  TV_IPA_COMDATS, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_ipa_comdats : public ipa_opt_pass_d\n+{\n+public:\n+  pass_ipa_comdats (gcc::context *ctxt)\n+    : ipa_opt_pass_d (pass_data_ipa_comdats, ctxt,\n+\t\t      NULL, /* generate_summary */\n+\t\t      NULL, /* write_summary */\n+\t\t      NULL, /* read_summary */\n+\t\t      NULL, /* write_optimization_summary */\n+\t\t      NULL, /* read_optimization_summary */\n+\t\t      NULL, /* stmt_fixup */\n+\t\t      0, /* function_transform_todo_flags_start */\n+\t\t      NULL, /* function_transform */\n+\t\t      NULL) /* variable_transform */\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *);\n+  virtual unsigned int execute (function *) { return ipa_comdats (); }\n+\n+}; // class pass_ipa_comdats\n+\n+bool\n+pass_ipa_comdats::gate (function *)\n+{\n+  return optimize;\n+}\n+\n+} // anon namespace\n+\n+ipa_opt_pass_d *\n+make_pass_ipa_comdats (gcc::context *ctxt)\n+{\n+  return new pass_ipa_comdats (ctxt);\n+}"}, {"sha": "2f889e8890511e66196bcecd4b55eee60a37a9d5", "filename": "gcc/passes.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04d9035ec03996fd6f96a1ece21bc8d4c54cd40/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04d9035ec03996fd6f96a1ece21bc8d4c54cd40/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=a04d9035ec03996fd6f96a1ece21bc8d4c54cd40", "patch": "@@ -110,6 +110,10 @@ along with GCC; see the file COPYING3.  If not see\n   NEXT_PASS (pass_ipa_inline);\n   NEXT_PASS (pass_ipa_pure_const);\n   NEXT_PASS (pass_ipa_reference);\n+  /* Comdat privatization come last, as direct references to comdat local\n+     symbols are not allowed outside of the comdat group.  Privatizing early\n+     would result in missed optimizations due to this restriction.  */\n+  NEXT_PASS (pass_ipa_comdats);\n   TERMINATE_PASS_LIST ()\n \n   /* Simple IPA passes executed after the regular passes.  In WHOPR mode the"}, {"sha": "e58cb17ee59fb3e595fac9288366133d68f028e7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04d9035ec03996fd6f96a1ece21bc8d4c54cd40/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04d9035ec03996fd6f96a1ece21bc8d4c54cd40/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a04d9035ec03996fd6f96a1ece21bc8d4c54cd40", "patch": "@@ -1,3 +1,7 @@\n+2014-05-17  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* g++.dg/ipa/comdat.C: New file.\n+\n 2014-05-18  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/volatile12.ad[sb]: New test."}, {"sha": "40a607f9368388a1a008dc82ee0f1158788be0fc", "filename": "gcc/testsuite/g++.dg/ipa/comdat.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04d9035ec03996fd6f96a1ece21bc8d4c54cd40/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fcomdat.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04d9035ec03996fd6f96a1ece21bc8d4c54cd40/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fcomdat.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fcomdat.C?ref=a04d9035ec03996fd6f96a1ece21bc8d4c54cd40", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile { target *-*-linux* *-*-gnu* } } */\n+/* { dg-options \"-O2 -fdump-ipa-comdats\"  } */\n+#include <stdio.h>\n+__attribute__ ((noinline))\n+static int q(void)\n+{\n+  return printf (\"test\");\n+}\n+inline int t(void)\n+{\n+  return q();\n+}\n+int (*f)()=t;\n+/* { dg-final { scan-ipa-dump-times \"Localizing symbol\" 1 \"comdats\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"comdats\" } } */"}, {"sha": "cbb64d5b73f2bdff02b1abcd735617ef853d983e", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04d9035ec03996fd6f96a1ece21bc8d4c54cd40/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04d9035ec03996fd6f96a1ece21bc8d4c54cd40/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=a04d9035ec03996fd6f96a1ece21bc8d4c54cd40", "patch": "@@ -71,6 +71,7 @@ DEFTIMEVAR (TV_IPA_DEVIRT\t     , \"ipa devirtualization\")\n DEFTIMEVAR (TV_IPA_CONSTANT_PROP     , \"ipa cp\")\n DEFTIMEVAR (TV_IPA_INLINING          , \"ipa inlining heuristics\")\n DEFTIMEVAR (TV_IPA_FNSPLIT           , \"ipa function splitting\")\n+DEFTIMEVAR (TV_IPA_COMDATS\t     , \"ipa comdats\")\n DEFTIMEVAR (TV_IPA_OPT\t\t     , \"ipa various optimizations\")\n DEFTIMEVAR (TV_IPA_LTO_GIMPLE_IN     , \"ipa lto gimple in\")\n DEFTIMEVAR (TV_IPA_LTO_GIMPLE_OUT    , \"ipa lto gimple out\")"}, {"sha": "3888bb66189736456ecd787b866293bee337eb27", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04d9035ec03996fd6f96a1ece21bc8d4c54cd40/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04d9035ec03996fd6f96a1ece21bc8d4c54cd40/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=a04d9035ec03996fd6f96a1ece21bc8d4c54cd40", "patch": "@@ -472,6 +472,7 @@ extern simple_ipa_opt_pass *make_pass_ipa_tm (gcc::context *ctxt);\n extern simple_ipa_opt_pass *make_pass_omp_simd_clone (gcc::context *ctxt);\n extern ipa_opt_pass_d *make_pass_ipa_profile (gcc::context *ctxt);\n extern ipa_opt_pass_d *make_pass_ipa_cdtor_merge (gcc::context *ctxt);\n+extern ipa_opt_pass_d *make_pass_ipa_comdats (gcc::context *ctxt);\n \n extern gimple_opt_pass *make_pass_cleanup_cfg_post_optimizing (gcc::context\n \t\t\t\t\t\t\t       *ctxt);"}]}