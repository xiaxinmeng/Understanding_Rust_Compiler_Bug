{"sha": "0abc6a6a4f074142719263a69355b702ac92f79b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGFiYzZhNmE0ZjA3NDE0MjcxOTI2M2E2OTM1NWI3MDJhYzkyZjc5Yg==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-11-27T22:31:34Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-11-27T22:31:34Z"}, "message": "cpphash.c (_cpp_init_hashtable): Update.\n\n\t* cpphash.c (_cpp_init_hashtable): Update.\n\t* cpphash.h (struct spec_nodes): Remove n_L.\n\t* cpplex.c (_cpp_lex_direct): Check for prefix L separately.\n\n\t* Makefile.in: Update, and add c-objc-common.o dependencies.\n\t* c-lang.c: Remove unnecessary includes.\n\t(c_init): Move bulk of code to c_objc_common_init, and call it.\n\t(c_tree_printer, c_missing_noreturn_ok_p, c_disregard_inline_limits,\n\tinline_forbidden_p, c_cannot_inline_tree_fn): Move to\n\tc-objc-common.c.\n\t* c-objc-common.c: New.  Mostly pulled from c-lang.c.\n\t* c-tree.h (c_disregard_inline_limits, c_cannot_inline_fn,\n\tc_objc_common_init, c_missing_noreturn_ok_p): New.\n\t* toplev.c: Update comment.\n\t* doc/passes.texi: Update.\n\t* objc/ojbc-act.c (LANG_HOOKS_TREE_INLINING_CANNOT_INLINE_TREE_FN,\n\tLANG_HOOKS_TREE_INLINING_DISREGARD_INLINE_LIMITS,\n\tLANG_HOOKS_TREE_INLINING_ANON_AGGR_TYPE_P): Override.\n\t(objc_init): Update to use c_objc_common_init.\n\nFrom-SVN: r47388", "tree": {"sha": "3c52b3d011b38afeffe23926fc3afa478dd62aa8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c52b3d011b38afeffe23926fc3afa478dd62aa8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0abc6a6a4f074142719263a69355b702ac92f79b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0abc6a6a4f074142719263a69355b702ac92f79b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0abc6a6a4f074142719263a69355b702ac92f79b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0abc6a6a4f074142719263a69355b702ac92f79b/comments", "author": null, "committer": null, "parents": [{"sha": "9827f778db2e051f0803ef226ee3076fd7ef9d20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9827f778db2e051f0803ef226ee3076fd7ef9d20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9827f778db2e051f0803ef226ee3076fd7ef9d20"}], "stats": {"total": 607, "additions": 340, "deletions": 267}, "files": [{"sha": "f69310c188636d6bebc104655e874b20f44e5e00", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0abc6a6a4f074142719263a69355b702ac92f79b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0abc6a6a4f074142719263a69355b702ac92f79b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0abc6a6a4f074142719263a69355b702ac92f79b", "patch": "@@ -1,3 +1,28 @@\n+2001-11-27  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* Makefile.in: Update, and add c-objc-common.o dependencies.\n+\t* c-lang.c: Remove unnecessary includes.\n+\t(c_init): Move bulk of code to c_objc_common_init, and call it.\n+\t(c_tree_printer, c_missing_noreturn_ok_p, c_disregard_inline_limits,\n+\tinline_forbidden_p, c_cannot_inline_tree_fn): Move to\n+\tc-objc-common.c.\n+\t* c-objc-common.c: New.  Mostly pulled from c-lang.c.\n+\t* c-tree.h (c_disregard_inline_limits, c_cannot_inline_fn,\n+\tc_objc_common_init, c_missing_noreturn_ok_p): New.\n+\t* toplev.c: Update comment.\n+\t* doc/passes.texi: Update.\n+objc:\n+\t* ojbc-act.c (LANG_HOOKS_TREE_INLINING_CANNOT_INLINE_TREE_FN,\n+\tLANG_HOOKS_TREE_INLINING_DISREGARD_INLINE_LIMITS,\n+\tLANG_HOOKS_TREE_INLINING_ANON_AGGR_TYPE_P): Override.\n+\t(objc_init): Update to use c_objc_common_init.\n+\n+2001-11-27  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cpphash.c (_cpp_init_hashtable): Update.\n+\t* cpphash.h (struct spec_nodes): Remove n_L.\n+\t* cpplex.c (_cpp_lex_direct): Check for prefix L separately.\n+\n 2001-11-17  Richard Henderson  <rth@redhat.com>\n \n \t* unroll.c (loop_iterations): Move last change ..."}, {"sha": "dceede52557e7c3be2e2a349d3d80fae032516b5", "filename": "gcc/c-lang.c", "status": "modified", "additions": 5, "deletions": 232, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0abc6a6a4f074142719263a69355b702ac92f79b/gcc%2Fc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0abc6a6a4f074142719263a69355b702ac92f79b/gcc%2Fc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lang.c?ref=0abc6a6a4f074142719263a69355b702ac92f79b", "patch": "@@ -23,33 +23,22 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"config.h\"\n #include \"system.h\"\n #include \"tree.h\"\n-#include \"tree-inline.h\"\n #include \"function.h\"\n-#include \"input.h\"\n #include \"toplev.h\"\n-#include \"diagnostic.h\"\n-#include \"output.h\"\n #include \"flags.h\"\n #include \"ggc.h\"\n #include \"rtl.h\"\n #include \"expr.h\"\n #include \"c-tree.h\"\n-#include \"c-common.h\"\n-#include \"c-lex.h\"\n-#include \"cpplib.h\"\n-#include \"insn-config.h\"\n-#include \"integrate.h\"\n #include \"varray.h\"\n #include \"langhooks.h\"\n #include \"langhooks-def.h\"\n \n-static int c_tree_printer PARAMS ((output_buffer *));\n-static int c_missing_noreturn_ok_p PARAMS ((tree));\n static const char *c_init PARAMS ((const char *));\n static void c_init_options PARAMS ((void));\n static void c_post_options PARAMS ((void));\n-static int c_disregard_inline_limits PARAMS ((tree));\n-static int c_cannot_inline_tree_fn PARAMS ((tree *));\n+\n+/* ### When changing hooks, consider if ObjC needs changing too!! ### */\n \n #undef LANG_HOOKS_NAME\n #define LANG_HOOKS_NAME \"GNU C\"\n@@ -82,6 +71,8 @@ static int c_cannot_inline_tree_fn PARAMS ((tree *));\n #define LANG_HOOKS_TREE_INLINING_ANON_AGGR_TYPE_P \\\n   anon_aggr_type_p\n \n+/* ### When changing hooks, consider if ObjC needs changing too!! ### */\n+\n /* Each front end provides its own.  */\n const struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n \n@@ -104,29 +95,7 @@ static const char *\n c_init (filename)\n      const char *filename;\n {\n-  c_init_decl_processing ();\n-\n-  filename = c_common_init (filename);\n-\n-  add_c_tree_codes ();\n-\n-  /* If still unspecified, make it match -std=c99\n-     (allowing for -pedantic-errors).  */\n-  if (mesg_implicit_function_declaration < 0)\n-    {\n-      if (flag_isoc99)\n-\tmesg_implicit_function_declaration = flag_pedantic_errors ? 2 : 1;\n-      else\n-\tmesg_implicit_function_declaration = 0;\n-    }\n-\n-  save_lang_status = &push_c_function_context;\n-  restore_lang_status = &pop_c_function_context;\n-  mark_lang_status = &mark_c_function_context;\n-  lang_expand_expr = &c_expand_expr;\n-  diagnostic_format_decoder (global_dc) = &c_tree_printer;\n-  lang_expand_decl_stmt = &c_expand_decl_stmt;\n-  lang_missing_noreturn_ok_p = &c_missing_noreturn_ok_p;\n+  filename = c_objc_common_init (filename);\n \n   VARRAY_TREE_INIT (deferred_fns, 32, \"deferred_fns\");\n   ggc_add_tree_varray_root (&deferred_fns, 1);\n@@ -305,199 +274,3 @@ finish_file ()\n       }\n   }\n }\n-\n-/* Called during diagnostic message formatting process to print a\n-   source-level entity onto BUFFER.  The meaning of the format specifiers\n-   is as follows:\n-   %D: a general decl,\n-   %F: a function declaration,\n-   %T: a type.\n-\n-   These format specifiers form a subset of the format specifiers set used\n-   by the C++ front-end.\n-   Please notice when called, the `%' part was already skipped by the\n-   diagnostic machinery.  */\n-static int\n-c_tree_printer (buffer)\n-     output_buffer *buffer;\n-{\n-  tree t = va_arg (output_buffer_format_args (buffer), tree);\n-\n-  switch (*output_buffer_text_cursor (buffer))\n-    {\n-    case 'D':\n-    case 'F':\n-    case 'T':\n-      {\n-        const char *n = DECL_NAME (t)\n-          ? (*decl_printable_name) (t, 2)\n-          : \"({anonymous})\";\n-        output_add_string (buffer, n);\n-      }\n-      return 1;\n-\n-    default:\n-      return 0;\n-    }\n-}\n-\n-static int\n-c_missing_noreturn_ok_p (decl)\n-     tree decl;\n-{\n-  /* A missing noreturn is not ok for freestanding implementations and\n-     ok for the `main' function in hosted implementations.  */\n-  return flag_hosted && MAIN_NAME_P (DECL_ASSEMBLER_NAME (decl));\n-}\n-\n-/* We want to inline `extern inline' functions even if this would\n-   violate inlining limits.  Some glibc and linux constructs depend on\n-   such functions always being inlined when optimizing.  */\n-\n-static int\n-c_disregard_inline_limits (fn)\n-     tree fn;\n-{\n-  return DECL_DECLARED_INLINE_P (fn) && DECL_EXTERNAL (fn);\n-}\n-\n-static tree inline_forbidden_p PARAMS ((tree *, int *, void *));\n-\n-static tree\n-inline_forbidden_p (nodep, walk_subtrees, fn)\n-     tree *nodep;\n-     int *walk_subtrees ATTRIBUTE_UNUSED;\n-     void *fn;\n-{\n-  tree node = *nodep;\n-  tree t;\n-\n-  switch (TREE_CODE (node))\n-    {\n-    case CALL_EXPR:\n-      t = get_callee_fndecl (node);\n-\n-      if (! t)\n-\tbreak;\n-\n-      /* We cannot inline functions that call setjmp.  */\n-      if (setjmp_call_p (t))\n-\treturn node;\n-\n-      switch (DECL_FUNCTION_CODE (t))\n-\t{\n-\t  /* We cannot inline functions that take a variable number of\n-\t     arguments.  */\n-\tcase BUILT_IN_VARARGS_START:\n-\tcase BUILT_IN_STDARG_START:\n-#if 0\n-\t  /* Functions that need information about the address of the\n-             caller can't (shouldn't?) be inlined.  */\n-\tcase BUILT_IN_RETURN_ADDRESS:\n-#endif\n-\t  return node;\n-\n-\tdefault:\n-\t  break;\n-\t}\n-\n-      break;\n-\n-    case DECL_STMT:\n-      /* We cannot inline functions that contain other functions.  */\n-      if (TREE_CODE (TREE_OPERAND (node, 0)) == FUNCTION_DECL\n-\t  && DECL_INITIAL (TREE_OPERAND (node, 0)))\n-\treturn node;\n-      break;\n-\n-    case GOTO_STMT:\n-    case GOTO_EXPR:\n-      t = TREE_OPERAND (node, 0);\n-\n-      /* We will not inline a function which uses computed goto.  The\n-\t addresses of its local labels, which may be tucked into\n-\t global storage, are of course not constant across\n-\t instantiations, which causes unexpected behaviour.  */\n-      if (TREE_CODE (t) != LABEL_DECL)\n-\treturn node;\n-\n-      /* We cannot inline a nested function that jumps to a nonlocal\n-         label.  */\n-      if (TREE_CODE (t) == LABEL_DECL\n-\t  && DECL_CONTEXT (t) && DECL_CONTEXT (t) != fn)\n-\treturn node;\n-\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-static int\n-c_cannot_inline_tree_fn (fnp)\n-     tree *fnp;\n-{\n-  tree fn = *fnp;\n-  tree t;\n-\n-  if (! function_attribute_inlinable_p (fn))\n-    {\n-      DECL_UNINLINABLE (fn) = 1;\n-      return 1;\n-    }\n-\n-  /* If a function has pending sizes, we must not defer its\n-     compilation, and we can't inline it as a tree.  */\n-  if (fn == current_function_decl)\n-    {\n-      t = get_pending_sizes ();\n-      put_pending_sizes (t);\n-\n-      if (t)\n-\t{\n-\t  DECL_UNINLINABLE (fn) = 1;\n-\t  return 1;\n-\t}\n-    }\n-\n-  if (DECL_CONTEXT (fn))\n-    {\n-      /* If a nested function has pending sizes, we may have already\n-         saved them.  */\n-      if (DECL_LANG_SPECIFIC (fn)->pending_sizes)\n-\t{\n-\t  DECL_UNINLINABLE (fn) = 1;\n-\t  return 1;\n-\t}\n-    }\n-  else\n-    {\n-      /* We rely on the fact that this function is called upfront,\n-\t just before we start expanding a function.  If FN is active\n-\t (i.e., it's the current_function_decl or a parent thereof),\n-\t we have to walk FN's saved tree.  Otherwise, we can safely\n-\t assume we have done it before and, if we didn't mark it as\n-\t uninlinable (in which case we wouldn't have been called), it\n-\t is inlinable.  Unfortunately, this strategy doesn't work for\n-\t nested functions, because they're only expanded as part of\n-\t their enclosing functions, so the inlinability test comes in\n-\t late.  */\n-      t = current_function_decl;\n-\n-      while (t && t != fn)\n-\tt = DECL_CONTEXT (t);\n-      if (! t)\n-\treturn 0;\n-    }\n-    \n-  if (walk_tree (&DECL_SAVED_TREE (fn), inline_forbidden_p, fn, NULL))\n-    {\n-      DECL_UNINLINABLE (fn) = 1;\n-      return 1;\n-    }\n-\n-  return 0;\n-}"}, {"sha": "be3b847facd8f9b5164b7b1bc3472a1a80fc77dc", "filename": "gcc/c-objc-common.c", "status": "added", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0abc6a6a4f074142719263a69355b702ac92f79b/gcc%2Fc-objc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0abc6a6a4f074142719263a69355b702ac92f79b/gcc%2Fc-objc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-objc-common.c?ref=0abc6a6a4f074142719263a69355b702ac92f79b", "patch": "@@ -0,0 +1,266 @@\n+/* Some code common to C and ObjC front ends.\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"insn-config.h\"\n+#include \"integrate.h\"\n+#include \"expr.h\"\n+#include \"c-tree.h\"\n+#include \"function.h\"\n+#include \"flags.h\"\n+#include \"toplev.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-inline.h\"\n+\n+static int c_tree_printer PARAMS ((output_buffer *));\n+static tree inline_forbidden_p PARAMS ((tree *, int *, void *));\n+\n+int\n+c_missing_noreturn_ok_p (decl)\n+     tree decl;\n+{\n+  /* A missing noreturn is not ok for freestanding implementations and\n+     ok for the `main' function in hosted implementations.  */\n+  return flag_hosted && MAIN_NAME_P (DECL_ASSEMBLER_NAME (decl));\n+}\n+\n+/* We want to inline `extern inline' functions even if this would\n+   violate inlining limits.  Some glibc and linux constructs depend on\n+   such functions always being inlined when optimizing.  */\n+\n+int\n+c_disregard_inline_limits (fn)\n+     tree fn;\n+{\n+  return DECL_DECLARED_INLINE_P (fn) && DECL_EXTERNAL (fn);\n+}\n+\n+static tree\n+inline_forbidden_p (nodep, walk_subtrees, fn)\n+     tree *nodep;\n+     int *walk_subtrees ATTRIBUTE_UNUSED;\n+     void *fn;\n+{\n+  tree node = *nodep;\n+  tree t;\n+\n+  switch (TREE_CODE (node))\n+    {\n+    case CALL_EXPR:\n+      t = get_callee_fndecl (node);\n+\n+      if (! t)\n+\tbreak;\n+\n+      /* We cannot inline functions that call setjmp.  */\n+      if (setjmp_call_p (t))\n+\treturn node;\n+\n+      switch (DECL_FUNCTION_CODE (t))\n+\t{\n+\t  /* We cannot inline functions that take a variable number of\n+\t     arguments.  */\n+\tcase BUILT_IN_VARARGS_START:\n+\tcase BUILT_IN_STDARG_START:\n+#if 0\n+\t  /* Functions that need information about the address of the\n+             caller can't (shouldn't?) be inlined.  */\n+\tcase BUILT_IN_RETURN_ADDRESS:\n+#endif\n+\t  return node;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+\n+      break;\n+\n+    case DECL_STMT:\n+      /* We cannot inline functions that contain other functions.  */\n+      if (TREE_CODE (TREE_OPERAND (node, 0)) == FUNCTION_DECL\n+\t  && DECL_INITIAL (TREE_OPERAND (node, 0)))\n+\treturn node;\n+      break;\n+\n+    case GOTO_STMT:\n+    case GOTO_EXPR:\n+      t = TREE_OPERAND (node, 0);\n+\n+      /* We will not inline a function which uses computed goto.  The\n+\t addresses of its local labels, which may be tucked into\n+\t global storage, are of course not constant across\n+\t instantiations, which causes unexpected behaviour.  */\n+      if (TREE_CODE (t) != LABEL_DECL)\n+\treturn node;\n+\n+      /* We cannot inline a nested function that jumps to a nonlocal\n+         label.  */\n+      if (TREE_CODE (t) == LABEL_DECL\n+\t  && DECL_CONTEXT (t) && DECL_CONTEXT (t) != fn)\n+\treturn node;\n+\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+int\n+c_cannot_inline_tree_fn (fnp)\n+     tree *fnp;\n+{\n+  tree fn = *fnp;\n+  tree t;\n+\n+  if (! function_attribute_inlinable_p (fn))\n+    {\n+      DECL_UNINLINABLE (fn) = 1;\n+      return 1;\n+    }\n+\n+  /* If a function has pending sizes, we must not defer its\n+     compilation, and we can't inline it as a tree.  */\n+  if (fn == current_function_decl)\n+    {\n+      t = get_pending_sizes ();\n+      put_pending_sizes (t);\n+\n+      if (t)\n+\t{\n+\t  DECL_UNINLINABLE (fn) = 1;\n+\t  return 1;\n+\t}\n+    }\n+\n+  if (DECL_CONTEXT (fn))\n+    {\n+      /* If a nested function has pending sizes, we may have already\n+         saved them.  */\n+      if (DECL_LANG_SPECIFIC (fn)->pending_sizes)\n+\t{\n+\t  DECL_UNINLINABLE (fn) = 1;\n+\t  return 1;\n+\t}\n+    }\n+  else\n+    {\n+      /* We rely on the fact that this function is called upfront,\n+\t just before we start expanding a function.  If FN is active\n+\t (i.e., it's the current_function_decl or a parent thereof),\n+\t we have to walk FN's saved tree.  Otherwise, we can safely\n+\t assume we have done it before and, if we didn't mark it as\n+\t uninlinable (in which case we wouldn't have been called), it\n+\t is inlinable.  Unfortunately, this strategy doesn't work for\n+\t nested functions, because they're only expanded as part of\n+\t their enclosing functions, so the inlinability test comes in\n+\t late.  */\n+      t = current_function_decl;\n+\n+      while (t && t != fn)\n+\tt = DECL_CONTEXT (t);\n+      if (! t)\n+\treturn 0;\n+    }\n+    \n+  if (walk_tree (&DECL_SAVED_TREE (fn), inline_forbidden_p, fn, NULL))\n+    {\n+      DECL_UNINLINABLE (fn) = 1;\n+      return 1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Initialization common to C and Objective-C front ends.  */\n+const char *\n+c_objc_common_init (filename)\n+     const char *filename;\n+{\n+  c_init_decl_processing ();\n+\n+  filename = c_common_init (filename);\n+\n+  add_c_tree_codes ();\n+\n+  save_lang_status = &push_c_function_context;\n+  restore_lang_status = &pop_c_function_context;\n+  mark_lang_status = &mark_c_function_context;\n+  lang_expand_expr = c_expand_expr;\n+  lang_expand_decl_stmt = c_expand_decl_stmt;\n+\n+  /* These were not defined in the Objective-C front end, but I'm\n+     putting them here anyway.  The diagnostic format decoder might\n+     want an enhanced ObjC implementation.  */\n+  diagnostic_format_decoder (global_dc) = &c_tree_printer;\n+  lang_missing_noreturn_ok_p = &c_missing_noreturn_ok_p;\n+\n+  /* If still unspecified, make it match -std=c99\n+     (allowing for -pedantic-errors).  */\n+  if (mesg_implicit_function_declaration < 0)\n+    {\n+      if (flag_isoc99)\n+\tmesg_implicit_function_declaration = flag_pedantic_errors ? 2 : 1;\n+      else\n+\tmesg_implicit_function_declaration = 0;\n+    }\n+\n+  return filename;\n+}\n+\n+/* Called during diagnostic message formatting process to print a\n+   source-level entity onto BUFFER.  The meaning of the format specifiers\n+   is as follows:\n+   %D: a general decl,\n+   %F: a function declaration,\n+   %T: a type.\n+\n+   These format specifiers form a subset of the format specifiers set used\n+   by the C++ front-end.\n+   Please notice when called, the `%' part was already skipped by the\n+   diagnostic machinery.  */\n+static int\n+c_tree_printer (buffer)\n+     output_buffer *buffer;\n+{\n+  tree t = va_arg (output_buffer_format_args (buffer), tree);\n+\n+  switch (*output_buffer_text_cursor (buffer))\n+    {\n+    case 'D':\n+    case 'F':\n+    case 'T':\n+      {\n+        const char *n = DECL_NAME (t)\n+          ? (*decl_printable_name) (t, 2)\n+          : \"({anonymous})\";\n+        output_add_string (buffer, n);\n+      }\n+      return 1;\n+\n+    default:\n+      return 0;\n+    }\n+}"}, {"sha": "e686ed4fd1ba043166d16c5b91be690b4600d8db", "filename": "gcc/c-tree.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0abc6a6a4f074142719263a69355b702ac92f79b/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0abc6a6a4f074142719263a69355b702ac92f79b/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=0abc6a6a4f074142719263a69355b702ac92f79b", "patch": "@@ -152,6 +152,7 @@ extern int maybe_objc_comptypes                 PARAMS ((tree, tree, int));\n extern tree maybe_building_objc_message_expr    PARAMS ((void));\n extern int recognize_objc_keyword\t\tPARAMS ((void));\n extern tree lookup_objc_ivar\t\t\tPARAMS ((tree));\n+\n /* in c-lang.c and objc/objc-act.c */\n extern int defer_fn\t\t\t\tPARAMS ((tree));\n \f\n@@ -169,6 +170,12 @@ extern void c_print_identifier\t\t\tPARAMS ((FILE *, tree, int));\n extern tree build_array_declarator              PARAMS ((tree, tree, int, int));\n extern tree build_enumerator                    PARAMS ((tree, tree));\n \n+/* in c-objc-common.c */\n+extern int c_disregard_inline_limits\t\tPARAMS ((tree));\n+extern int c_cannot_inline_tree_fn\t\tPARAMS ((tree *));\n+extern const char *c_objc_common_init\t\tPARAMS ((const char *));\n+extern int c_missing_noreturn_ok_p\t\tPARAMS ((tree));\n+\n #define c_build_type_variant(TYPE, CONST_P, VOLATILE_P)\t\t  \\\n   c_build_qualified_type (TYPE,\t\t\t\t  \\\n \t\t\t  ((CONST_P) ? TYPE_QUAL_CONST : 0) |\t  \\"}, {"sha": "39a3de77ffaa2c15b1f82fe14bd303f5bc8d953b", "filename": "gcc/cpphash.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0abc6a6a4f074142719263a69355b702ac92f79b/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0abc6a6a4f074142719263a69355b702ac92f79b/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=0abc6a6a4f074142719263a69355b702ac92f79b", "patch": "@@ -71,7 +71,6 @@ _cpp_init_hashtable (pfile, table)\n   _cpp_init_internal_pragmas (pfile);\n \n   s = &pfile->spec_nodes;\n-  s->n_L                = cpp_lookup (pfile, DSC(\"L\"));\n   s->n_defined\t\t= cpp_lookup (pfile, DSC(\"defined\"));\n   s->n_true\t\t= cpp_lookup (pfile, DSC(\"true\"));\n   s->n_false\t\t= cpp_lookup (pfile, DSC(\"false\"));"}, {"sha": "2f558c6f26a7acd8d9d557652afa99011b168b24", "filename": "gcc/cpphash.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0abc6a6a4f074142719263a69355b702ac92f79b/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0abc6a6a4f074142719263a69355b702ac92f79b/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=0abc6a6a4f074142719263a69355b702ac92f79b", "patch": "@@ -159,7 +159,6 @@ struct lexer_state\n /* Special nodes - identifiers with predefined significance.  */\n struct spec_nodes\n {\n-  cpp_hashnode *n_L;\t\t\t/* L\"str\" */\n   cpp_hashnode *n_defined;\t\t/* defined operator */\n   cpp_hashnode *n_true;\t\t\t/* C++ keyword true */\n   cpp_hashnode *n_false;\t\t/* C++ keyword false */"}, {"sha": "dc17f63a99508dde61a95937d4421dca25a945f1", "filename": "gcc/cpplex.c", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0abc6a6a4f074142719263a69355b702ac92f79b/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0abc6a6a4f074142719263a69355b702ac92f79b/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=0abc6a6a4f074142719263a69355b702ac92f79b", "patch": "@@ -978,38 +978,39 @@ _cpp_lex_direct (pfile)\n       parse_number (pfile, &result->val.str, c, 0);\n       break;\n \n-    case '$':\n-      if (!CPP_OPTION (pfile, dollars_in_ident))\n-\tgoto random_char;\n-      /* Fall through...  */\n+    case 'L':\n+      /* 'L' may introduce wide characters or strings.  */\n+\t{\n+\t  const unsigned char *pos = buffer->cur;\n \n+\t  c = get_effective_char (pfile);\n+\t  if (c == '\\'' || c == '\"')\n+\t    {\n+\t      result->type = (c == '\"' ? CPP_WSTRING: CPP_WCHAR);\n+\t      parse_string (pfile, result, c);\n+\t      break;\n+\t    }\n+\t  buffer->cur = pos;\n+\t}\n+\t/* Fall through.  */\n+\n+    start_ident:\n     case '_':\n     case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n     case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n     case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n     case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n     case 'y': case 'z':\n     case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n-    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n+    case 'G': case 'H': case 'I': case 'J': case 'K':\n     case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n     case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n     case 'Y': case 'Z':\n       result->type = CPP_NAME;\n       result->val.node = parse_identifier (pfile);\n \n-      /* 'L' may introduce wide characters or strings.  */\n-      if (result->val.node == pfile->spec_nodes.n_L)\n-\t{\n-\t  c = *buffer->cur;\n-\t  if (c == '\\'' || c == '\"')\n-\t    {\n-\t      buffer->cur++;\n-\t      result->type = (c == '\"' ? CPP_WSTRING: CPP_WCHAR);\n-\t      parse_string (pfile, result, c);\n-\t    }\n-\t}\n       /* Convert named operators to their proper types.  */\n-      else if (result->val.node->flags & NODE_OPERATOR)\n+      if (result->val.node->flags & NODE_OPERATOR)\n \t{\n \t  result->flags |= NAMED_OP;\n \t  result->type = result->val.node->value.operator;\n@@ -1273,6 +1274,11 @@ _cpp_lex_direct (pfile)\n       /* @ is a punctuator in Objective C.  */\n     case '@': result->type = CPP_ATSIGN; break;\n \n+    case '$':\n+      if (CPP_OPTION (pfile, dollars_in_ident))\n+\tgoto start_ident;\n+      /* Fall through...  */\n+\n     random_char:\n     default:\n       result->type = CPP_OTHER;"}, {"sha": "51dab87d06f18da94700c4f2e1ab0368d8af1a41", "filename": "gcc/doc/passes.texi", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0abc6a6a4f074142719263a69355b702ac92f79b/gcc%2Fdoc%2Fpasses.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0abc6a6a4f074142719263a69355b702ac92f79b/gcc%2Fdoc%2Fpasses.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpasses.texi?ref=0abc6a6a4f074142719263a69355b702ac92f79b", "patch": "@@ -83,6 +83,7 @@ The source files to parse C are\n @file{c-decl.c},\n @file{c-errors.c},\n @file{c-lang.c},\n+@file{c-objc-common.c},\n @file{c-parse.in},\n @file{c-aux-info.c},\n and"}, {"sha": "2e02b7c9af1e1e807d71b8fd8b71852eb92a78c7", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0abc6a6a4f074142719263a69355b702ac92f79b/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0abc6a6a4f074142719263a69355b702ac92f79b/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=0abc6a6a4f074142719263a69355b702ac92f79b", "patch": "@@ -468,6 +468,16 @@ static int print_struct_values = 0;\n #define LANG_HOOKS_PRINT_IDENTIFIER c_print_identifier\n #undef LANG_HOOKS_SET_YYDEBUG\n #define LANG_HOOKS_SET_YYDEBUG c_set_yydebug\n+/* Inlining hooks same as the C front end.  */\n+#undef LANG_HOOKS_TREE_INLINING_CANNOT_INLINE_TREE_FN\n+#define LANG_HOOKS_TREE_INLINING_CANNOT_INLINE_TREE_FN \\\n+  c_cannot_inline_tree_fn\n+#undef LANG_HOOKS_TREE_INLINING_DISREGARD_INLINE_LIMITS\n+#define LANG_HOOKS_TREE_INLINING_DISREGARD_INLINE_LIMITS \\\n+  c_disregard_inline_limits\n+#undef LANG_HOOKS_TREE_INLINING_ANON_AGGR_TYPE_P\n+#define LANG_HOOKS_TREE_INLINING_ANON_AGGR_TYPE_P \\\n+  anon_aggr_type_p\n \n /* Each front end provides its own.  */\n const struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n@@ -554,11 +564,9 @@ static const char *\n objc_init (filename)\n      const char *filename;\n {\n-  c_init_decl_processing ();\n+  filename = c_objc_common_init (filename);\n \n-  filename = c_common_init (filename);\n-\n-  add_c_tree_codes ();\n+  decl_printable_name = objc_printable_name;\n \n   /* Force the line number back to 0; check_newline will have\n      raised it to 1, which will make the builtin functions appear\n@@ -8087,14 +8095,6 @@ init_objc ()\n   errbuf = (char *)xmalloc (BUFSIZE);\n   hash_init ();\n   synth_module_prologue ();\n-\n-  /* Change the default error function */\n-  save_lang_status = &push_c_function_context;\n-  restore_lang_status = &pop_c_function_context;\n-  mark_lang_status = &mark_c_function_context;\n-  decl_printable_name = objc_printable_name;\n-  lang_expand_expr = c_expand_expr;\n-  lang_expand_decl_stmt = c_expand_decl_stmt;\n }\n \f\n static void"}, {"sha": "e2c2e25996ceca96041c28d909c279a8a3d7ea37", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0abc6a6a4f074142719263a69355b702ac92f79b/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0abc6a6a4f074142719263a69355b702ac92f79b/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=0abc6a6a4f074142719263a69355b702ac92f79b", "patch": "@@ -4988,10 +4988,7 @@ lang_independent_init ()\n     = ((lang_hooks.identifier_size - sizeof (struct tree_common))\n        / sizeof (tree));\n \n-  /* Initialize the garbage-collector, and string pools.  FIXME: We\n-     should do this later, in independent_init () when we know we\n-     actually want to compile something, but cpplib currently wants to\n-     use the hash table immediately in cpp_create_reader.  */\n+  /* Initialize the garbage-collector, and string pools.  */\n   init_ggc ();\n   ggc_add_rtx_root (&stack_limit_rtx, 1);\n   ggc_add_tree_root (&current_function_decl, 1);"}]}