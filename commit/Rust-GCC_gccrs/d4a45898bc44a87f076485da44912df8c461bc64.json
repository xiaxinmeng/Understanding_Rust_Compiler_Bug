{"sha": "d4a45898bc44a87f076485da44912df8c461bc64", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDRhNDU4OThiYzQ0YTg3ZjA3NjQ4NWRhNDQ5MTJkZjhjNDYxYmM2NA==", "commit": {"author": {"name": "Justin Squirek", "email": "squirek@adacore.com", "date": "2019-12-18T07:16:22Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-12-18T07:16:22Z"}, "message": "[Ada] Missing accessibility check on access discriminants\n\n2019-12-18  Justin Squirek  <squirek@adacore.com>\n\ngcc/ada/\n\n\t* sem_ch6.adb (Analyze_Function_Return): Modify handling of\n\textended return statements to check accessibility of access\n\tdiscriminants.\n\t(Check_Aggregate_Accessibility): Removed.\n\t(Check_Return_Obj_Accessibility): Added to centralize checking\n\tof return aggregates and subtype indications in the case of an\n\textended return statement.\n\nFrom-SVN: r279518", "tree": {"sha": "d4f4e88a4ed9f3dac0d96db6091c624b27ead5a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4f4e88a4ed9f3dac0d96db6091c624b27ead5a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d4a45898bc44a87f076485da44912df8c461bc64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4a45898bc44a87f076485da44912df8c461bc64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4a45898bc44a87f076485da44912df8c461bc64", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4a45898bc44a87f076485da44912df8c461bc64/comments", "author": {"login": "AdaDoom3", "id": 3445599, "node_id": "MDQ6VXNlcjM0NDU1OTk=", "avatar_url": "https://avatars.githubusercontent.com/u/3445599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AdaDoom3", "html_url": "https://github.com/AdaDoom3", "followers_url": "https://api.github.com/users/AdaDoom3/followers", "following_url": "https://api.github.com/users/AdaDoom3/following{/other_user}", "gists_url": "https://api.github.com/users/AdaDoom3/gists{/gist_id}", "starred_url": "https://api.github.com/users/AdaDoom3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AdaDoom3/subscriptions", "organizations_url": "https://api.github.com/users/AdaDoom3/orgs", "repos_url": "https://api.github.com/users/AdaDoom3/repos", "events_url": "https://api.github.com/users/AdaDoom3/events{/privacy}", "received_events_url": "https://api.github.com/users/AdaDoom3/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c7e3d0694bc09e8099542840f1a1f647c23a7222", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7e3d0694bc09e8099542840f1a1f647c23a7222", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7e3d0694bc09e8099542840f1a1f647c23a7222"}], "stats": {"total": 232, "additions": 186, "deletions": 46}, "files": [{"sha": "aa37e62d9ebbcd6b3d777aea7541a46660a32b8e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4a45898bc44a87f076485da44912df8c461bc64/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4a45898bc44a87f076485da44912df8c461bc64/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d4a45898bc44a87f076485da44912df8c461bc64", "patch": "@@ -1,3 +1,13 @@\n+2019-12-18  Justin Squirek  <squirek@adacore.com>\n+\n+\t* sem_ch6.adb (Analyze_Function_Return): Modify handling of\n+\textended return statements to check accessibility of access\n+\tdiscriminants.\n+\t(Check_Aggregate_Accessibility): Removed.\n+\t(Check_Return_Obj_Accessibility): Added to centralize checking\n+\tof return aggregates and subtype indications in the case of an\n+\textended return statement.\n+\n 2019-12-18  Arnaud Charlet  <charlet@adacore.com>\n \n \t* libgnat/s-regpat.adb (Parse_Literal, Parse_Piece): Ensure"}, {"sha": "eca05573321eaa283bf129e75bc2d23cd286273e", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 176, "deletions": 46, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4a45898bc44a87f076485da44912df8c461bc64/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4a45898bc44a87f076485da44912df8c461bc64/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=d4a45898bc44a87f076485da44912df8c461bc64", "patch": "@@ -694,69 +694,199 @@ package body Sem_Ch6 is\n       R_Type : constant Entity_Id := Etype (Scope_Id);\n       --  Function result subtype\n \n-      procedure Check_Aggregate_Accessibility (Aggr : Node_Id);\n-      --  Apply legality rule of 6.5 (5.8) to the access discriminants of an\n+      procedure Check_Return_Obj_Accessibility (Return_Stmt : Node_Id);\n+      --  Apply legality rule of 6.5 (5.9) to the access discriminants of an\n       --  aggregate in a return statement.\n \n       procedure Check_Return_Subtype_Indication (Obj_Decl : Node_Id);\n       --  Check that the return_subtype_indication properly matches the result\n       --  subtype of the function, as required by RM-6.5(5.1/2-5.3/2).\n \n-      -----------------------------------\n-      -- Check_Aggregate_Accessibility --\n-      -----------------------------------\n+      ------------------------------------\n+      -- Check_Return_Obj_Accessibility --\n+      ------------------------------------\n \n-      procedure Check_Aggregate_Accessibility (Aggr : Node_Id) is\n-         Typ   : constant Entity_Id := Etype (Aggr);\n-         Assoc : Node_Id;\n-         Discr : Entity_Id;\n-         Expr  : Node_Id;\n-         Obj   : Node_Id;\n+      procedure Check_Return_Obj_Accessibility (Return_Stmt : Node_Id) is\n+         Assoc         : Node_Id;\n+         Agg           : Node_Id := Empty;\n+         Discr         : Entity_Id;\n+         Expr          : Node_Id;\n+         Obj           : Node_Id;\n+         Process_Exprs : Boolean := False;\n+         Return_Obj    : Node_Id;\n \n       begin\n-         if Is_Record_Type (Typ) and then Has_Discriminants (Typ) then\n-            Discr := First_Discriminant (Typ);\n-            Assoc := First (Component_Associations (Aggr));\n-            while Present (Discr) loop\n-               if Ekind (Etype (Discr)) = E_Anonymous_Access_Type then\n+         --  Only perform checks on record types with access discriminants\n+\n+         if not Is_Record_Type (R_Type)\n+           or else not Has_Discriminants (R_Type)\n+         then\n+            return;\n+         end if;\n+\n+         --  We are only interested in return statements\n+\n+         if not Nkind_In (Return_Stmt, N_Extended_Return_Statement,\n+                                       N_Simple_Return_Statement)\n+         then\n+            return;\n+         end if;\n+\n+         --  Fetch the object from the return statement, in the case of a\n+         --  simple return statement the expression is part of the node.\n+\n+         if Nkind (Return_Stmt) = N_Extended_Return_Statement then\n+            Return_Obj := Last (Return_Object_Declarations (Return_Stmt));\n+\n+            --  We could be looking at something that's been expanded with\n+            --  an initialzation procedure which we can safely ignore.\n+\n+            if Nkind (Return_Obj) /= N_Object_Declaration then\n+               return;\n+            end if;\n+         else\n+            Return_Obj := Return_Stmt;\n+         end if;\n+\n+         --  We may need to check an aggregate or a subtype indication\n+         --  depending on how the discriminants were specified and whether\n+         --  we are looking at an extended return statement.\n+\n+         if Nkind (Return_Obj) = N_Object_Declaration\n+           and then Nkind (Object_Definition (Return_Obj))\n+                      = N_Subtype_Indication\n+         then\n+            Assoc := First (Constraints\n+                             (Constraint (Object_Definition (Return_Obj))));\n+         else\n+            --  Qualified expressions may be nested\n+\n+            Agg := Original_Node (Expression (Return_Obj));\n+            while Nkind (Agg) = N_Qualified_Expression loop\n+               Agg := Original_Node (Expression (Agg));\n+            end loop;\n+\n+            --  If we are looking at an aggregate instead of a function call we\n+            --  can continue checking accessibility for the supplied\n+            --  discriminant associations.\n+\n+            if Nkind (Agg) = N_Aggregate then\n+               if Present (Expressions (Agg)) then\n+                  Assoc         := First (Expressions (Agg));\n+                  Process_Exprs := True;\n+               else\n+                  Assoc := First (Component_Associations (Agg));\n+               end if;\n+\n+            --  Otherwise the expression is not of interest ???\n+\n+            else\n+               return;\n+            end if;\n+         end if;\n+\n+         --  Move through the discriminants checking the accessibility level\n+         --  of each co-extension's associated expression.\n+\n+         Discr := First_Discriminant (R_Type);\n+         while Present (Discr) loop\n+            if Ekind (Etype (Discr)) = E_Anonymous_Access_Type then\n+\n+               if Nkind (Assoc) = N_Attribute_Reference then\n+                  Expr := Assoc;\n+               elsif Nkind_In (Assoc, N_Component_Association,\n+                                      N_Discriminant_Association)\n+               then\n                   Expr := Expression (Assoc);\n+               end if;\n \n-                  if Nkind (Expr) = N_Attribute_Reference\n-                    and then Attribute_Name (Expr) /= Name_Unrestricted_Access\n-                  then\n-                     Obj := Prefix (Expr);\n-                     while Nkind_In (Obj, N_Indexed_Component,\n-                                          N_Selected_Component)\n-                     loop\n+               --  This anonymous access discriminant has an associated\n+               --  expression which needs checking.\n+\n+               if Nkind (Expr) = N_Attribute_Reference\n+                 and then Attribute_Name (Expr) /= Name_Unrestricted_Access\n+               then\n+                  --  Obtain the object to perform static checks on by moving\n+                  --  up the prefixes in the expression taking into account\n+                  --  named access types.\n+\n+                  Obj := Prefix (Expr);\n+                  while Nkind_In (Obj, N_Indexed_Component,\n+                                       N_Selected_Component)\n+                  loop\n+                     --  When we encounter a named access type then we can\n+                     --  ignore accessibility checks on the dereference.\n+\n+                     if Ekind (Etype (Prefix (Obj)))\n+                          in E_Access_Type ..\n+                             E_Access_Protected_Subprogram_Type\n+                     then\n+                        if Nkind (Obj) = N_Selected_Component then\n+                           Obj := Selector_Name (Obj);\n+                        end if;\n+                        exit;\n+                     end if;\n+\n+                     --  Skip over the explicit dereference\n+\n+                     if Nkind (Prefix (Obj)) = N_Explicit_Dereference then\n+                        Obj := Prefix (Prefix (Obj));\n+\n+                     --  Otherwise move up to the next prefix\n+\n+                     else\n                         Obj := Prefix (Obj);\n-                     end loop;\n+                     end if;\n+                  end loop;\n \n-                     --  Do not check aliased formals or function calls. A\n-                     --  run-time check may still be needed ???\n+                  --  Do not check aliased formals or function calls. A\n+                  --  run-time check may still be needed ???\n \n-                     if Is_Entity_Name (Obj)\n-                       and then Comes_From_Source (Obj)\n+                  if Is_Entity_Name (Obj)\n+                    and then Comes_From_Source (Obj)\n+                  then\n+                     --  Explicitly aliased formals are allowed\n+\n+                     if Is_Formal (Entity (Obj))\n+                       and then Is_Aliased (Entity (Obj))\n                      then\n-                        if Is_Formal (Entity (Obj))\n-                           and then Is_Aliased (Entity (Obj))\n-                        then\n-                           null;\n+                        null;\n \n-                        elsif Object_Access_Level (Obj) >\n-                                Scope_Depth (Scope (Scope_Id))\n-                        then\n-                           Error_Msg_N\n-                             (\"access discriminant in return aggregate would \"\n-                              & \"be a dangling reference\", Obj);\n-                        end if;\n+                     elsif Object_Access_Level (Obj) >\n+                             Scope_Depth (Scope (Scope_Id))\n+                     then\n+                        Error_Msg_N\n+                          (\"access discriminant in return aggregate would \"\n+                           & \"be a dangling reference\", Obj);\n                      end if;\n                   end if;\n                end if;\n+            end if;\n \n-               Next_Discriminant (Discr);\n-            end loop;\n-         end if;\n-      end Check_Aggregate_Accessibility;\n+            Next_Discriminant (Discr);\n+\n+            if not Is_List_Member (Assoc) then\n+               Assoc := Empty;\n+            else\n+               Nlists.Next (Assoc);\n+            end if;\n+\n+            --  After aggregate expressions, examine component associations if\n+            --  present.\n+\n+            if No (Assoc) then\n+               if Present (Agg)\n+                 and then Process_Exprs\n+                 and then Present (Component_Associations (Agg))\n+               then\n+                  Assoc         := First (Component_Associations (Agg));\n+                  Process_Exprs := False;\n+               else\n+                  exit;\n+               end if;\n+            end if;\n+         end loop;\n+      end Check_Return_Obj_Accessibility;\n \n       -------------------------------------\n       -- Check_Return_Subtype_Indication --\n@@ -963,9 +1093,7 @@ package body Sem_Ch6 is\n             Resolve (Expr, R_Type);\n             Check_Limited_Return (N, Expr, R_Type);\n \n-            if Present (Expr) and then Nkind (Expr) = N_Aggregate then\n-               Check_Aggregate_Accessibility (Expr);\n-            end if;\n+            Check_Return_Obj_Accessibility (N);\n          end if;\n \n          --  RETURN only allowed in SPARK as the last statement in function\n@@ -1021,6 +1149,8 @@ package body Sem_Ch6 is\n \n             Check_References (Stm_Entity);\n \n+            Check_Return_Obj_Accessibility (N);\n+\n             --  Check RM 6.5 (5.9/3)\n \n             if Has_Aliased then"}]}