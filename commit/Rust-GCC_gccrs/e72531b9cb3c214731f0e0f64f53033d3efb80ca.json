{"sha": "e72531b9cb3c214731f0e0f64f53033d3efb80ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTcyNTMxYjljYjNjMjE0NzMxZjBlMGY2NGY1MzAzM2QzZWZiODBjYQ==", "commit": {"author": {"name": "Prathamesh Kulkarni", "email": "prathamesh.kulkarni@linaro.org", "date": "2016-10-28T19:05:12Z"}, "committer": {"name": "Prathamesh Kulkarni", "email": "prathamesh3492@gcc.gnu.org", "date": "2016-10-28T19:05:12Z"}, "message": "re PR tree-optimization/43721 (Failure to optimise (a/b) and (a%b) into single __aeabi_idivmod call)\n\n2016-10-28  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n\t    Kugan Vivekanandarajah  <kuganv@linaro.org>\n\t    Jim Wilson  <jim.wilson@linaro.org>\n\n\tPR tree-optimization/43721\n\t* target.def: New hook expand_divmod_libfunc.\n\t* doc/tm.texi.in: Add hook for TARGET_EXPAND_DIVMOD_LIBFUNC\n\t* doc/tm.texi: Regenerate.\n\t* internal-fn.def: Add new entry for DIVMOD ifn.\n\t* internal-fn.c (expand_DIVMOD): New.\n\t* tree-ssa-math-opts.c: Include optabs-libfuncs.h, tree-eh.h,\n\ttarghooks.h.\n\t(widen_mul_stats): Add new field divmod_calls_inserted.\n\t(target_supports_divmod_p): New.\n\t(divmod_candidate_p): Likewise.\n\t(convert_to_divmod): Likewise.\n\t(pass_optimize_widening_mul::execute): Call\n\tcalculate_dominance_info(), renumber_gimple_stmt_uids() at\n\tbeginning of function. Call convert_to_divmod()\n\tand record stats for divmod.\n\t* config/arm/arm.c (arm_expand_divmod_libfunc): Override hook\n\tTARGET_EXPAND_DIVMOD_LIBFUNC.\n\t* doc/sourcebuild.texi: Add items for arm_divmod_simode, divmod,\n\tdivmod_simode.\n\ntestsuite/\n\t* lib/target-supports.exp (check_effective_target_divmod): New.\n\t(check_effective_target_divmod_simode): Likewise.\n\t(check_effective_target_arm_divmod_simode): Likewise.\n\t* gcc.dg/divmod-1-simode.c: New test.\n\t* gcc.dg/divmod-1.c: Likewise.\n\t* gcc.dg/divmod-2-simode.c: Likewise.\n\t* gcc.dg/divmod-2.c: Likewise.\n\t* gcc.dg/divmod-3-simode.c: Likewise.\n\t* gcc.dg/divmod-3.c: Likewise.\n\t* gcc.dg/divmod-4-simode.c: Likewise.\n\t* gcc.dg/divmod-4.c: Likewise.\n\t* gcc.dg/divmod-5.c: Likewise.\n\t* gcc.dg/divmod-6-simode.c: Likewise.\n\t* gcc.dg/divmod-6.c: Likewise.\n\t* gcc.dg/divmod-7.c: Likewise.\n\nCo-Authored-By: Jim Wilson <jim.wilson@linaro.org>\nCo-Authored-By: Kugan Vivekanandarajah <kuganv@linaro.org>\n\nFrom-SVN: r241660", "tree": {"sha": "9837b3df122e46bd34e1497c40a603aa1033fab1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9837b3df122e46bd34e1497c40a603aa1033fab1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e72531b9cb3c214731f0e0f64f53033d3efb80ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e72531b9cb3c214731f0e0f64f53033d3efb80ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e72531b9cb3c214731f0e0f64f53033d3efb80ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e72531b9cb3c214731f0e0f64f53033d3efb80ca/comments", "author": null, "committer": null, "parents": [{"sha": "0dfeae289cc3c97f0f61d02c81df393e720badf9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dfeae289cc3c97f0f61d02c81df393e720badf9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0dfeae289cc3c97f0f61d02c81df393e720badf9"}], "stats": {"total": 735, "additions": 735, "deletions": 0}, "files": [{"sha": "4302280b832902aeddd3c1949b498f4cb8d1cd5c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e72531b9cb3c214731f0e0f64f53033d3efb80ca", "patch": "@@ -1,3 +1,28 @@\n+2016-10-28  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n+\t    Kugan Vivekanandarajah  <kuganv@linaro.org>\n+\t    Jim Wilson  <jim.wilson@linaro.org>\n+\n+\tPR tree-optimization/43721\n+\t* target.def: New hook expand_divmod_libfunc.\n+\t* doc/tm.texi.in: Add hook for TARGET_EXPAND_DIVMOD_LIBFUNC\n+\t* doc/tm.texi: Regenerate.\n+\t* internal-fn.def: Add new entry for DIVMOD ifn.\n+\t* internal-fn.c (expand_DIVMOD): New.\n+\t* tree-ssa-math-opts.c: Include optabs-libfuncs.h, tree-eh.h,\n+\ttarghooks.h.\n+\t(widen_mul_stats): Add new field divmod_calls_inserted.\n+\t(target_supports_divmod_p): New.\n+\t(divmod_candidate_p): Likewise.\n+\t(convert_to_divmod): Likewise.\n+\t(pass_optimize_widening_mul::execute): Call\n+\tcalculate_dominance_info(), renumber_gimple_stmt_uids() at\n+\tbeginning of function. Call convert_to_divmod()\n+\tand record stats for divmod.\n+\t* config/arm/arm.c (arm_expand_divmod_libfunc): Override hook\n+\tTARGET_EXPAND_DIVMOD_LIBFUNC.\n+\t* doc/sourcebuild.texi: Add items for arm_divmod_simode, divmod,\n+\tdivmod_simode.\n+\n 2016-10-28  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* dojump.c (do_jump_by_parts_greater_rtx): Invert probability when"}, {"sha": "f47edbab07eb5284e64716ec8e59659e594e46d3", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=e72531b9cb3c214731f0e0f64f53033d3efb80ca", "patch": "@@ -62,6 +62,7 @@\n #include \"builtins.h\"\n #include \"tm-constrs.h\"\n #include \"rtl-iter.h\"\n+#include \"optabs-libfuncs.h\"\n \n /* This file should be included last.  */\n #include \"target-def.h\"\n@@ -304,6 +305,7 @@ static section *arm_function_section (tree, enum node_frequency, bool, bool);\n static bool arm_asm_elf_flags_numeric (unsigned int flags, unsigned int *num);\n static unsigned int arm_elf_section_type_flags (tree decl, const char *name,\n \t\t\t\t\t\tint reloc);\n+static void arm_expand_divmod_libfunc (rtx, machine_mode, rtx, rtx, rtx *, rtx *);\n \f\n /* Table of machine attributes.  */\n static const struct attribute_spec arm_attribute_table[] =\n@@ -739,6 +741,9 @@ static const struct attribute_spec arm_attribute_table[] =\n #undef TARGET_SECTION_TYPE_FLAGS\n #define TARGET_SECTION_TYPE_FLAGS arm_elf_section_type_flags\n \n+#undef TARGET_EXPAND_DIVMOD_LIBFUNC\n+#define TARGET_EXPAND_DIVMOD_LIBFUNC arm_expand_divmod_libfunc\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Obstack for minipool constant handling.  */\n@@ -30845,4 +30850,33 @@ arm_elf_section_type_flags (tree decl, const char *name, int reloc)\n   return flags;\n }\n \n+/* Generate call to __aeabi_[mode]divmod (op0, op1).  */\n+\n+static void\n+arm_expand_divmod_libfunc (rtx libfunc, machine_mode mode,\n+\t\t\t   rtx op0, rtx op1,\n+\t\t\t   rtx *quot_p, rtx *rem_p)\n+{\n+  if (mode == SImode)\n+    gcc_assert (!TARGET_IDIV);\n+\n+  machine_mode libval_mode = smallest_mode_for_size (2 * GET_MODE_BITSIZE (mode),\n+\t\t\t\t\t\t     MODE_INT);\n+\n+  rtx libval = emit_library_call_value (libfunc, NULL_RTX, LCT_CONST,\n+\t\t\t\t\tlibval_mode, 2,\n+\t\t\t\t\top0, GET_MODE (op0),\n+\t\t\t\t\top1, GET_MODE (op1));\n+\n+  rtx quotient = simplify_gen_subreg (mode, libval, libval_mode, 0);\n+  rtx remainder = simplify_gen_subreg (mode, libval, libval_mode,\n+\t\t\t\t       GET_MODE_SIZE (mode));\n+\n+  gcc_assert (quotient);\n+  gcc_assert (remainder);\n+\n+  *quot_p = quotient;\n+  *rem_p = remainder;\n+}\n+\n #include \"gt-arm.h\""}, {"sha": "39de0ffb082e2eb5bc6e4758af0b172be24bf8d6", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=e72531b9cb3c214731f0e0f64f53033d3efb80ca", "patch": "@@ -1675,6 +1675,10 @@ and @code{MOVT} instructions available.\n ARM target generates Thumb-1 code for @code{-mthumb} with\n @code{CBZ} and @code{CBNZ} instructions available.\n \n+@item arm_divmod_simode\n+ARM target for which divmod transform is disabled, if it supports hardware\n+div instruction.\n+\n @end table\n \n @subsubsection AArch64-specific attributes\n@@ -1848,6 +1852,13 @@ Target requires a command line argument to enable a SIMD instruction set.\n \n @item pie_copyreloc\n The x86-64 target linker supports PIE with copy reloc.\n+\n+@item divmod\n+Target supporting hardware divmod insn or divmod libcall.\n+\n+@item divmod_simode\n+Target supporting hardware divmod insn or divmod libcall for SImode.\n+\n @end table\n \n @subsubsection Environment attributes"}, {"sha": "d2bcdca6d8c794f37d41cbe662d959df4dc4202e", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=e72531b9cb3c214731f0e0f64f53033d3efb80ca", "patch": "@@ -7096,6 +7096,11 @@ This is firstly introduced on ARM/AArch64 targets, please refer to\n the hook implementation for how different fusion types are supported.\n @end deftypefn\n \n+@deftypefn {Target Hook} void TARGET_EXPAND_DIVMOD_LIBFUNC (rtx @var{libfunc}, machine_mode @var{mode}, rtx @var{op0}, rtx @var{op1}, rtx *@var{quot}, rtx *@var{rem})\n+Define this hook for enabling divmod transform if the port does not have\n+hardware divmod insn but defines target-specific divmod libfuncs.\n+@end deftypefn\n+\n @node Sections\n @section Dividing the Output into Sections (Texts, Data, @dots{})\n @c the above section title is WAY too long.  maybe cut the part between"}, {"sha": "3399465fa054d3a0c40f46a3a731704a01d6c814", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=e72531b9cb3c214731f0e0f64f53033d3efb80ca", "patch": "@@ -4892,6 +4892,8 @@ them: try the first ones in this list first.\n \n @hook TARGET_SCHED_FUSION_PRIORITY\n \n+@hook TARGET_EXPAND_DIVMOD_LIBFUNC\n+\n @node Sections\n @section Dividing the Output into Sections (Texts, Data, @dots{})\n @c the above section title is WAY too long.  maybe cut the part between"}, {"sha": "1eeb15e4a503d1136fb96ae54dd9b72edc499c61", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=e72531b9cb3c214731f0e0f64f53033d3efb80ca", "patch": "@@ -2232,6 +2232,53 @@ expand_LAUNDER (internal_fn, gcall *call)\n   expand_assignment (lhs, gimple_call_arg (call, 0), false);\n }\n \n+/* Expand DIVMOD() using:\n+ a) optab handler for udivmod/sdivmod if it is available.\n+ b) If optab_handler doesn't exist, generate call to\n+    target-specific divmod libfunc.  */\n+\n+static void\n+expand_DIVMOD (internal_fn, gcall *call_stmt)\n+{\n+  tree lhs = gimple_call_lhs (call_stmt);\n+  tree arg0 = gimple_call_arg (call_stmt, 0);\n+  tree arg1 = gimple_call_arg (call_stmt, 1);\n+\n+  gcc_assert (TREE_CODE (TREE_TYPE (lhs)) == COMPLEX_TYPE);\n+  tree type = TREE_TYPE (TREE_TYPE (lhs));\n+  machine_mode mode = TYPE_MODE (type);\n+  bool unsignedp = TYPE_UNSIGNED (type);\n+  optab tab = (unsignedp) ? udivmod_optab : sdivmod_optab;\n+\n+  rtx op0 = expand_normal (arg0);\n+  rtx op1 = expand_normal (arg1);\n+  rtx target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+\n+  rtx quotient, remainder, libfunc;\n+\n+  /* Check if optab_handler exists for divmod_optab for given mode.  */\n+  if (optab_handler (tab, mode) != CODE_FOR_nothing)\n+    {\n+      quotient = gen_reg_rtx (mode);\n+      remainder = gen_reg_rtx (mode);\n+      expand_twoval_binop (tab, op0, op1, quotient, remainder, unsignedp);\n+    }\n+\n+  /* Generate call to divmod libfunc if it exists.  */\n+  else if ((libfunc = optab_libfunc (tab, mode)) != NULL_RTX)\n+    targetm.expand_divmod_libfunc (libfunc, mode, op0, op1,\n+\t\t\t\t   &quotient, &remainder);\n+\n+  else\n+    gcc_unreachable ();\n+\n+  /* Wrap the return value (quotient, remainder) within COMPLEX_EXPR.  */\n+  expand_expr (build2 (COMPLEX_EXPR, TREE_TYPE (lhs),\n+\t\t       make_tree (TREE_TYPE (arg0), quotient),\n+\t\t       make_tree (TREE_TYPE (arg1), remainder)),\n+\t      target, VOIDmode, EXPAND_NORMAL);\n+}\n+\n /* Expand a call to FN using the operands in STMT.  FN has a single\n    output operand and NARGS input operands.  */\n "}, {"sha": "cf2c402f335e548cccd1c531f38a6b5f6690f9b7", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=e72531b9cb3c214731f0e0f64f53033d3efb80ca", "patch": "@@ -201,6 +201,9 @@ DEF_INTERNAL_FN (FALLTHROUGH, ECF_LEAF | ECF_NOTHROW, NULL)\n /* To implement __builtin_launder.  */\n DEF_INTERNAL_FN (LAUNDER, ECF_LEAF | ECF_NOTHROW | ECF_NOVOPS, NULL)\n \n+/* Divmod function.  */\n+DEF_INTERNAL_FN (DIVMOD, ECF_CONST | ECF_LEAF, NULL)\n+\n #undef DEF_INTERNAL_INT_FN\n #undef DEF_INTERNAL_FLT_FN\n #undef DEF_INTERNAL_OPTAB_FN"}, {"sha": "ae0ea16e57fdd616982738ba9c45341eea97cbf5", "filename": "gcc/target.def", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=e72531b9cb3c214731f0e0f64f53033d3efb80ca", "patch": "@@ -5055,6 +5055,15 @@ Normally, this is not needed.\",\n  bool, (const_tree field, machine_mode mode),\n  default_member_type_forces_blk)\n \n+/* See tree-ssa-math-opts.c:divmod_candidate_p for conditions\n+   that gate the divod transform.  */\n+DEFHOOK\n+(expand_divmod_libfunc,\n+ \"Define this hook for enabling divmod transform if the port does not have\\n\\\n+hardware divmod insn but defines target-specific divmod libfuncs.\", \n+ void, (rtx libfunc, machine_mode mode, rtx op0, rtx op1, rtx *quot, rtx *rem),\n+ NULL)\n+\n /* Return the class for a secondary reload, and fill in extra information.  */\n DEFHOOK\n (secondary_reload,"}, {"sha": "cd2b1eb073cb699566435398940f934cced1ae2d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e72531b9cb3c214731f0e0f64f53033d3efb80ca", "patch": "@@ -1,3 +1,24 @@\n+2016-10-28  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n+\t    Kugan Vivekanandarajah  <kuganv@linaro.org>\n+\t    Jim Wilson  <jim.wilson@linaro.org>\n+\n+\tPR tree-optimization/43721\n+\t* lib/target-supports.exp (check_effective_target_divmod): New.\n+\t(check_effective_target_divmod_simode): Likewise.\n+\t(check_effective_target_arm_divmod_simode): Likewise.\n+\t* gcc.dg/divmod-1-simode.c: New test.\n+\t* gcc.dg/divmod-1.c: Likewise.\n+\t* gcc.dg/divmod-2-simode.c: Likewise.\n+\t* gcc.dg/divmod-2.c: Likewise.\n+\t* gcc.dg/divmod-3-simode.c: Likewise.\n+\t* gcc.dg/divmod-3.c: Likewise.\n+\t* gcc.dg/divmod-4-simode.c: Likewise.\n+\t* gcc.dg/divmod-4.c: Likewise.\n+\t* gcc.dg/divmod-5.c: Likewise.\n+\t* gcc.dg/divmod-6-simode.c: Likewise.\n+\t* gcc.dg/divmod-6.c: Likewise.\n+\t* gcc.dg/divmod-7.c: Likewise.\n+\n 2016-10-28  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n             Jakub Jelinek  <jakub@redhat.com>\n             Andrew Pinski  <pinskia@gmail.com>"}, {"sha": "9e477997bcf57949946bf385b32eb3c85d5d46d4", "filename": "gcc/testsuite/gcc.dg/divmod-1-simode.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Ftestsuite%2Fgcc.dg%2Fdivmod-1-simode.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Ftestsuite%2Fgcc.dg%2Fdivmod-1-simode.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdivmod-1-simode.c?ref=e72531b9cb3c214731f0e0f64f53033d3efb80ca", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-require-effective-target divmod_simode } */\n+/* { dg-options \"-O2 -fdump-tree-widening_mul-details\" } */\n+/* div dominates mod.  */\n+\n+typedef int SImode __attribute__((mode(SI)));\n+typedef unsigned USImode __attribute__((mode(SI)));\n+\n+extern int cond;\n+void foo(void);\n+\n+#define FOO(smalltype, bigtype, no)  \\\n+bigtype f_##no(smalltype x, bigtype y) \\\n+{\t\t\t\t\t \\\n+  bigtype q = x / y;                     \\\n+  if (cond)                              \\\n+    foo ();                              \\\n+  bigtype r = x % y;                     \\\n+  return q + r;                          \\\n+}\n+\n+FOO(SImode, SImode, 1)\n+FOO(SImode, USImode, 2)\n+FOO(USImode, USImode, 3)\n+\n+/* { dg-final { scan-tree-dump-times \"DIVMOD\" 3 \"widening_mul\" } } */"}, {"sha": "edcc2a107dadc68e15ef82b80cf8b84da653dc1e", "filename": "gcc/testsuite/gcc.dg/divmod-1.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Ftestsuite%2Fgcc.dg%2Fdivmod-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Ftestsuite%2Fgcc.dg%2Fdivmod-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdivmod-1.c?ref=e72531b9cb3c214731f0e0f64f53033d3efb80ca", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-require-effective-target divmod } */\n+/* { dg-options \"-O2 -fdump-tree-widening_mul-details\" } */\n+/* div dominates mod.  */\n+\n+typedef int SImode __attribute__((mode(SI)));\n+typedef unsigned USImode __attribute__((mode(SI)));\n+\n+typedef int DImode __attribute__((mode(DI)));\n+typedef unsigned UDImode __attribute__((mode(DI)));\n+\n+extern int cond;\n+void foo(void);\n+\n+#define FOO(smalltype, bigtype, no)\t \\\n+bigtype f_##no(smalltype x, bigtype y)   \\\n+{\t\t\t\t\t \\\n+  bigtype q = x / y;                     \\\n+  if (cond)                              \\\n+    foo ();                              \\\n+  bigtype r = x % y;                     \\\n+  return q + r;                          \\\n+}\n+\n+FOO(SImode, DImode, 1)\n+FOO(SImode, UDImode, 2)\n+FOO(USImode, DImode, 3)\n+FOO(USImode, UDImode, 4)\n+FOO(DImode, DImode, 5)\n+FOO(DImode, UDImode, 6)\n+FOO(UDImode, UDImode, 7)\n+\n+/* { dg-final { scan-tree-dump-times \"DIVMOD\" 7 \"widening_mul\" } } */"}, {"sha": "fa28beb3cef48c99841d0fb2b9157ed2c3ce26c9", "filename": "gcc/testsuite/gcc.dg/divmod-2-simode.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Ftestsuite%2Fgcc.dg%2Fdivmod-2-simode.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Ftestsuite%2Fgcc.dg%2Fdivmod-2-simode.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdivmod-2-simode.c?ref=e72531b9cb3c214731f0e0f64f53033d3efb80ca", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-require-effective-target divmod_simode } */\n+/* { dg-options \"-O2 -fdump-tree-widening_mul-details\" } */\n+/* mod dominates div.  */\n+\n+typedef int SImode __attribute__((mode(SI)));\n+typedef unsigned USImode __attribute__((mode(SI)));\n+\n+extern int cond;\n+void foo(void);\n+\n+#define FOO(smalltype, bigtype, no)  \\\n+bigtype f_##no(smalltype x, bigtype y) \\\n+{\t\t\t\t\t \\\n+  bigtype r = x % y;                     \\\n+  if (cond)                              \\\n+    foo ();                              \\\n+  bigtype q = x / y;                     \\\n+  return q + r;                          \\\n+}\n+\n+FOO(SImode, SImode, 1)\n+FOO(SImode, USImode, 2)\n+FOO(USImode, USImode, 3)\n+\n+/* { dg-final { scan-tree-dump-times \"DIVMOD\" 3 \"widening_mul\" } } */"}, {"sha": "ded732e121d5aeaed6e965ecac4cee18d5bd0a8e", "filename": "gcc/testsuite/gcc.dg/divmod-2.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Ftestsuite%2Fgcc.dg%2Fdivmod-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Ftestsuite%2Fgcc.dg%2Fdivmod-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdivmod-2.c?ref=e72531b9cb3c214731f0e0f64f53033d3efb80ca", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-require-effective-target divmod } */\n+/* { dg-options \"-O2 -fdump-tree-widening_mul-details\" } */\n+/* mod dominates div.  */\n+\n+typedef int SImode __attribute__((mode(SI)));\n+typedef unsigned USImode __attribute__((mode(SI)));\n+\n+typedef int DImode __attribute__((mode(DI)));\n+typedef unsigned UDImode __attribute__((mode(DI)));\n+\n+extern int cond;\n+void foo(void);\n+\n+#define FOO(smalltype, bigtype, no)\t \\\n+bigtype f_##no(smalltype x, bigtype y)   \\\n+{\t\t\t\t\t \\\n+  bigtype r = x % y;                     \\\n+  if (cond)                              \\\n+    foo ();                              \\\n+  bigtype q = x / y;                     \\\n+  return q + r;                          \\\n+}\n+\n+FOO(SImode, DImode, 1)\n+FOO(SImode, UDImode, 2)\n+FOO(USImode, DImode, 3)\n+FOO(USImode, UDImode, 4)\n+FOO(DImode, DImode, 5)\n+FOO(DImode, UDImode, 6)\n+FOO(UDImode, UDImode, 7)\n+\n+/* { dg-final { scan-tree-dump-times \"DIVMOD\" 7 \"widening_mul\" } } */"}, {"sha": "9dee5bf603b37a009d281f85767fe2da4f89abbb", "filename": "gcc/testsuite/gcc.dg/divmod-3-simode.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Ftestsuite%2Fgcc.dg%2Fdivmod-3-simode.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Ftestsuite%2Fgcc.dg%2Fdivmod-3-simode.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdivmod-3-simode.c?ref=e72531b9cb3c214731f0e0f64f53033d3efb80ca", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-require-effective-target divmod_simode } */\n+/* { dg-options \"-O2 -fdump-tree-widening_mul-details\" } */\n+/* div comes before mod in same bb.  */ \n+\n+typedef int SImode __attribute__((mode(SI)));\n+typedef unsigned USImode __attribute__((mode(SI)));\n+\n+extern int cond;\n+void foo(void);\n+\n+#define FOO(smalltype, bigtype, no)  \t \\\n+bigtype f_##no(smalltype x, bigtype y)\t \\\n+{\t\t\t\t\t \\\n+  bigtype q = x / y;                     \\\n+  bigtype r = x % y;                     \\\n+  return q + r;                          \\\n+}\n+\n+FOO(SImode, SImode, 1)\n+FOO(SImode, USImode, 2)\n+FOO(USImode, USImode, 3)\n+\n+/* { dg-final { scan-tree-dump-times \"DIVMOD\" 3 \"widening_mul\" } } */"}, {"sha": "02aa367ac6ef84a7c16f732d43c50cd4b3e050af", "filename": "gcc/testsuite/gcc.dg/divmod-3.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Ftestsuite%2Fgcc.dg%2Fdivmod-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Ftestsuite%2Fgcc.dg%2Fdivmod-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdivmod-3.c?ref=e72531b9cb3c214731f0e0f64f53033d3efb80ca", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-require-effective-target divmod } */\n+/* { dg-options \"-O2 -fdump-tree-widening_mul-details\" } */\n+/* div comes before mod in same bb.  */ \n+\n+typedef int SImode __attribute__((mode(SI)));\n+typedef unsigned USImode __attribute__((mode(SI)));\n+\n+typedef int DImode __attribute__((mode(DI)));\n+typedef unsigned UDImode __attribute__((mode(DI)));\n+\n+extern int cond;\n+void foo(void);\n+\n+#define FOO(smalltype, bigtype, no)      \\\n+bigtype f_##no(smalltype x, bigtype y)   \\\n+{\t\t\t\t\t \\\n+  bigtype q = x / y;                     \\\n+  bigtype r = x % y;                     \\\n+  return q + r;                          \\\n+}\n+\n+FOO(SImode, DImode, 1)\n+FOO(SImode, UDImode, 2)\n+FOO(USImode, DImode, 3)\n+FOO(USImode, UDImode, 4)\n+FOO(DImode, DImode, 5)\n+FOO(DImode, UDImode, 6)\n+FOO(UDImode, UDImode, 7)\n+\n+/* { dg-final { scan-tree-dump-times \"DIVMOD\" 7 \"widening_mul\" } } */"}, {"sha": "dbe29cb761d085e5ace4fdab1f3b87f0caf616fb", "filename": "gcc/testsuite/gcc.dg/divmod-4-simode.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Ftestsuite%2Fgcc.dg%2Fdivmod-4-simode.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Ftestsuite%2Fgcc.dg%2Fdivmod-4-simode.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdivmod-4-simode.c?ref=e72531b9cb3c214731f0e0f64f53033d3efb80ca", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-require-effective-target divmod_simode } */\n+/* { dg-options \"-O2 -fdump-tree-widening_mul-details\" } */\n+/* mod comes before div in same bb.  */ \n+\n+typedef int SImode __attribute__((mode(SI)));\n+typedef unsigned USImode __attribute__((mode(SI)));\n+\n+extern int cond;\n+void foo(void);\n+\n+#define FOO(smalltype, bigtype, no)      \\\n+bigtype f_##no(smalltype x, bigtype y)   \\\n+{\t\t\t\t\t \\\n+  bigtype r = x % y;                     \\\n+  bigtype q = x / y;                     \\\n+  return q + r;                          \\\n+}\n+\n+FOO(SImode, SImode, 1)\n+FOO(SImode, USImode, 2)\n+FOO(USImode, USImode, 3)\n+\n+/* { dg-final { scan-tree-dump-times \"DIVMOD\" 3 \"widening_mul\" } } */"}, {"sha": "861ecbdec4b874c1277bbd54d7ffcc262c87b84b", "filename": "gcc/testsuite/gcc.dg/divmod-4.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Ftestsuite%2Fgcc.dg%2Fdivmod-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Ftestsuite%2Fgcc.dg%2Fdivmod-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdivmod-4.c?ref=e72531b9cb3c214731f0e0f64f53033d3efb80ca", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-require-effective-target divmod } */\n+/* { dg-options \"-O2 -fdump-tree-widening_mul-details\" } */\n+/* mod comes before div in same bb.  */ \n+\n+typedef int SImode __attribute__((mode(SI)));\n+typedef unsigned USImode __attribute__((mode(SI)));\n+\n+typedef int DImode __attribute__((mode(DI)));\n+typedef unsigned UDImode __attribute__((mode(DI)));\n+\n+extern int cond;\n+void foo(void);\n+\n+#define FOO(smalltype, bigtype, no)\t\\\n+bigtype f_##no(smalltype x, bigtype y)  \\\n+{\t\t\t\t\t\\\n+  bigtype r = x % y;                    \\\n+  bigtype q = x / y;                    \\\n+  return q + r;                         \\\n+}\n+\n+FOO(SImode, DImode, 3)\n+FOO(SImode, UDImode, 4)\n+FOO(USImode, DImode, 6)\n+FOO(USImode, UDImode, 7)\n+FOO(DImode, DImode, 8)\n+FOO(DImode, UDImode, 9)\n+FOO(UDImode, UDImode, 10)\n+\n+/* { dg-final { scan-tree-dump-times \"DIVMOD\" 7 \"widening_mul\" } } */"}, {"sha": "8a8cee50ae2d4b05fcd682fd20e2aeca24455cf9", "filename": "gcc/testsuite/gcc.dg/divmod-5.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Ftestsuite%2Fgcc.dg%2Fdivmod-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Ftestsuite%2Fgcc.dg%2Fdivmod-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdivmod-5.c?ref=e72531b9cb3c214731f0e0f64f53033d3efb80ca", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-require-effective-target divmod_simode } */\n+/* { dg-options \"-O2 -fdump-tree-widening_mul-details\" } */\n+/* div and mod are not in same bb and\n+   bb's containing div and mod don't dominate each other.  */\n+\n+int f(int x, int y)\n+{\n+  int q = 0;\n+  int r = 0;\n+  extern int cond;\n+\n+  if (cond)\n+    q = x / y;\n+\n+  r = x % y;\n+  return q + r;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"DIVMOD\" 0 \"widening_mul\" } } */"}, {"sha": "1107f760b429520335cbbec20657a3d19671cbf3", "filename": "gcc/testsuite/gcc.dg/divmod-6-simode.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Ftestsuite%2Fgcc.dg%2Fdivmod-6-simode.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Ftestsuite%2Fgcc.dg%2Fdivmod-6-simode.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdivmod-6-simode.c?ref=e72531b9cb3c214731f0e0f64f53033d3efb80ca", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-require-effective-target divmod_simode } */\n+/* { dg-options \"-O2 -fdump-tree-widening_mul-details\" } */\n+\n+typedef int SImode __attribute__((mode(SI)));\n+typedef unsigned USImode __attribute__((mode(SI)));\n+\n+extern int cond;\n+void foo(void);\n+\n+#define FOO(smalltype, bigtype, no)  \\\n+bigtype f_##no(smalltype x, bigtype y) \\\n+{\t\t\t\t\t \\\n+  bigtype q = x / y;                     \\\n+  bigtype r1 = 0, r2 = 0;                \\\n+  if (cond)                              \\\n+    r1 = x % y;                          \\\n+  else                                   \\\n+    r2 = x % y;                          \\\n+  return q + r1 + r2;                    \\\n+}\n+\n+FOO(SImode, SImode, 1)\n+FOO(SImode, USImode, 2)\n+FOO(USImode, USImode, 3)\n+\n+/* { dg-final { scan-tree-dump-times \"DIVMOD\" 3 \"widening_mul\" } } */"}, {"sha": "495ebaff80514e89a9a7b438a2e659b880c3fc2a", "filename": "gcc/testsuite/gcc.dg/divmod-6.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Ftestsuite%2Fgcc.dg%2Fdivmod-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Ftestsuite%2Fgcc.dg%2Fdivmod-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdivmod-6.c?ref=e72531b9cb3c214731f0e0f64f53033d3efb80ca", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-require-effective-target divmod } */\n+/* { dg-options \"-O2 -fdump-tree-widening_mul-details\" } */\n+\n+typedef int SImode __attribute__((mode(SI)));\n+typedef unsigned USImode __attribute__((mode(SI)));\n+\n+typedef int DImode __attribute__((mode(DI)));\n+typedef unsigned UDImode __attribute__((mode(DI)));\n+\n+extern int cond;\n+void foo(void);\n+\n+#define FOO(smalltype, bigtype, no)\t \\\n+bigtype f_##no(smalltype x, bigtype y)   \\\n+{\t\t\t\t\t \\\n+  bigtype q = x / y;                     \\\n+  bigtype r1 = 0, r2 = 0;                \\\n+  if (cond)                              \\\n+    r1 = x % y;                          \\\n+  else                                   \\\n+    r2 = x % y;                          \\\n+  return q + r1 + r2;                    \\\n+}\n+\n+FOO(SImode, DImode, 3)\n+FOO(SImode, UDImode, 4)\n+FOO(USImode, DImode, 6)\n+FOO(USImode, UDImode, 7)\n+FOO(DImode, DImode, 8)\n+FOO(DImode, UDImode, 9)\n+FOO(UDImode, UDImode, 10)\n+\n+/* { dg-final { scan-tree-dump-times \"DIVMOD\" 7 \"widening_mul\" } } */"}, {"sha": "faa90b3ac8f211a4da2486594d7ccc13f8f5a19c", "filename": "gcc/testsuite/gcc.dg/divmod-7.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Ftestsuite%2Fgcc.dg%2Fdivmod-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Ftestsuite%2Fgcc.dg%2Fdivmod-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdivmod-7.c?ref=e72531b9cb3c214731f0e0f64f53033d3efb80ca", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-require-effective-target divmod_simode } */\n+/* { dg-options \"-O2 -fdump-tree-widening_mul-details\" } */\n+\n+int f(int x, int y)\n+{\n+  int q = 0, r1 = 0, r2 = 0;\n+  extern int cond;\n+\n+  if (cond)\n+    q = x / y;\n+  else\n+    {\n+      r1 = x % y;\n+      return q + r1;\n+    }\n+\n+  r2 = x % y;\n+  return q + r2;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"DIVMOD\" 1 \"widening_mul\" } } */"}, {"sha": "938f2c0a556857109febe43e61c2785c7e0cbb1b", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=e72531b9cb3c214731f0e0f64f53033d3efb80ca", "patch": "@@ -8091,3 +8091,41 @@ proc check_effective_target_profile_update_atomic {} {\n \tint main (void) { return 0; }\n     } \"-fprofile-update=atomic -fprofile-generate\"]\n }\n+\n+#For versions of ARM architectures that have hardware div insn,\n+#disable the divmod transform\n+\n+proc check_effective_target_arm_divmod_simode { } {\n+    return [check_no_compiler_messages arm_divmod assembly {\n+\t#ifdef __ARM_ARCH_EXT_IDIV__\n+\t#error has div insn\n+\t#endif\n+\tint i;\n+    }]\n+}\n+\n+# Return 1 if target supports divmod hardware insn or divmod libcall.\n+\n+proc check_effective_target_divmod { } {\n+    #TODO: Add checks for all targets that have either hardware divmod insn\n+    # or define libfunc for divmod.\n+    if { [istarget arm*-*-*]\n+\t || [istarget x86_64-*-*] } {\n+\treturn 1\n+    }\n+    return 0\n+}\n+\n+# Return 1 if target supports divmod for SImode. The reason for\n+# separating this from check_effective_target_divmod is that\n+# some versions of ARM architecture define div instruction\n+# only for simode, and for these archs, we do not want to enable\n+# divmod transform for simode.\n+\n+proc check_effective_target_divmod_simode { } {\n+    if { [istarget arm*-*-*] } {\n+\treturn [check_effective_target_arm_divmod_simode]\n+    }\n+\n+    return [check_effective_target_divmod]\n+}"}, {"sha": "c315da88ce4feea1196a0416e4ea02e2a75a4377", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 221, "deletions": 0, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e72531b9cb3c214731f0e0f64f53033d3efb80ca/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=e72531b9cb3c214731f0e0f64f53033d3efb80ca", "patch": "@@ -112,6 +112,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"params.h\"\n #include \"internal-fn.h\"\n #include \"case-cfn-macros.h\"\n+#include \"optabs-libfuncs.h\"\n+#include \"tree-eh.h\"\n+#include \"targhooks.h\"\n \n /* This structure represents one basic block that either computes a\n    division, or is a common dominator for basic block that compute a\n@@ -184,6 +187,9 @@ static struct\n \n   /* Number of fp fused multiply-add ops inserted.  */\n   int fmas_inserted;\n+\n+  /* Number of divmod calls inserted.  */\n+  int divmod_calls_inserted;\n } widen_mul_stats;\n \n /* The instance of \"struct occurrence\" representing the highest\n@@ -3793,6 +3799,213 @@ match_uaddsub_overflow (gimple_stmt_iterator *gsi, gimple *stmt,\n   return true;\n }\n \n+/* Return true if target has support for divmod.  */\n+\n+static bool\n+target_supports_divmod_p (optab divmod_optab, optab div_optab, machine_mode mode) \n+{\n+  /* If target supports hardware divmod insn, use it for divmod.  */\n+  if (optab_handler (divmod_optab, mode) != CODE_FOR_nothing)\n+    return true;\n+\n+  /* Check if libfunc for divmod is available.  */\n+  rtx libfunc = optab_libfunc (divmod_optab, mode);\n+  if (libfunc != NULL_RTX)\n+    {\n+      /* If optab_handler exists for div_optab, perhaps in a wider mode,\n+\t we don't want to use the libfunc even if it exists for given mode.  */ \n+      for (machine_mode div_mode = mode;\n+\t   div_mode != VOIDmode;\n+\t   div_mode = GET_MODE_WIDER_MODE (div_mode))\n+\tif (optab_handler (div_optab, div_mode) != CODE_FOR_nothing)\n+\t  return false;\n+\n+      return targetm.expand_divmod_libfunc != NULL;\n+    }\n+  \n+  return false; \n+}\n+\n+/* Check if stmt is candidate for divmod transform.  */\n+\n+static bool\n+divmod_candidate_p (gassign *stmt)\n+{\n+  tree type = TREE_TYPE (gimple_assign_lhs (stmt));\n+  enum machine_mode mode = TYPE_MODE (type);\n+  optab divmod_optab, div_optab;\n+\n+  if (TYPE_UNSIGNED (type))\n+    {\n+      divmod_optab = udivmod_optab;\n+      div_optab = udiv_optab;\n+    }\n+  else\n+    {\n+      divmod_optab = sdivmod_optab;\n+      div_optab = sdiv_optab;\n+    }\n+\n+  tree op1 = gimple_assign_rhs1 (stmt);\n+  tree op2 = gimple_assign_rhs2 (stmt);\n+\n+  /* Disable the transform if either is a constant, since division-by-constant\n+     may have specialized expansion.  */\n+  if (CONSTANT_CLASS_P (op1) || CONSTANT_CLASS_P (op2))\n+    return false;\n+\n+  /* Exclude the case where TYPE_OVERFLOW_TRAPS (type) as that should\n+     expand using the [su]divv optabs.  */\n+  if (TYPE_OVERFLOW_TRAPS (type))\n+    return false;\n+  \n+  if (!target_supports_divmod_p (divmod_optab, div_optab, mode)) \n+    return false;\n+\n+  return true;\n+}\n+\n+/* This function looks for:\n+   t1 = a TRUNC_DIV_EXPR b;\n+   t2 = a TRUNC_MOD_EXPR b;\n+   and transforms it to the following sequence:\n+   complex_tmp = DIVMOD (a, b);\n+   t1 = REALPART_EXPR(a);\n+   t2 = IMAGPART_EXPR(b);\n+   For conditions enabling the transform see divmod_candidate_p().\n+\n+   The pass has three parts:\n+   1) Find top_stmt which is trunc_div or trunc_mod stmt and dominates all\n+      other trunc_div_expr and trunc_mod_expr stmts.\n+   2) Add top_stmt and all trunc_div and trunc_mod stmts dominated by top_stmt\n+      to stmts vector.\n+   3) Insert DIVMOD call just before top_stmt and update entries in\n+      stmts vector to use return value of DIMOVD (REALEXPR_PART for div,\n+      IMAGPART_EXPR for mod).  */\n+\n+static bool\n+convert_to_divmod (gassign *stmt)\n+{\n+  if (stmt_can_throw_internal (stmt)\n+      || !divmod_candidate_p (stmt))\n+    return false;\n+\n+  tree op1 = gimple_assign_rhs1 (stmt);\n+  tree op2 = gimple_assign_rhs2 (stmt);\n+  \n+  imm_use_iterator use_iter;\n+  gimple *use_stmt;\n+  auto_vec<gimple *> stmts; \n+\n+  gimple *top_stmt = stmt; \n+  basic_block top_bb = gimple_bb (stmt);\n+\n+  /* Part 1: Try to set top_stmt to \"topmost\" stmt that dominates\n+     at-least stmt and possibly other trunc_div/trunc_mod stmts\n+     having same operands as stmt.  */\n+\n+  FOR_EACH_IMM_USE_STMT (use_stmt, use_iter, op1)\n+    {\n+      if (is_gimple_assign (use_stmt)\n+\t  && (gimple_assign_rhs_code (use_stmt) == TRUNC_DIV_EXPR\n+\t      || gimple_assign_rhs_code (use_stmt) == TRUNC_MOD_EXPR)\n+\t  && operand_equal_p (op1, gimple_assign_rhs1 (use_stmt), 0)\n+\t  && operand_equal_p (op2, gimple_assign_rhs2 (use_stmt), 0))\n+\t{\n+\t  if (stmt_can_throw_internal (use_stmt))\n+\t    continue;\n+\n+\t  basic_block bb = gimple_bb (use_stmt);\n+\n+\t  if (bb == top_bb)\n+\t    {\n+\t      if (gimple_uid (use_stmt) < gimple_uid (top_stmt))\n+\t\ttop_stmt = use_stmt;\n+\t    }\n+\t  else if (dominated_by_p (CDI_DOMINATORS, top_bb, bb))\n+\t    {\n+\t      top_bb = bb;\n+\t      top_stmt = use_stmt;\n+\t    }\n+\t}\n+    }\n+\n+  tree top_op1 = gimple_assign_rhs1 (top_stmt);\n+  tree top_op2 = gimple_assign_rhs2 (top_stmt);\n+\n+  stmts.safe_push (top_stmt);\n+  bool div_seen = (gimple_assign_rhs_code (top_stmt) == TRUNC_DIV_EXPR);\n+\n+  /* Part 2: Add all trunc_div/trunc_mod statements domianted by top_bb\n+     to stmts vector. The 2nd loop will always add stmt to stmts vector, since\n+     gimple_bb (top_stmt) dominates gimple_bb (stmt), so the\n+     2nd loop ends up adding at-least single trunc_mod_expr stmt.  */  \n+\n+  FOR_EACH_IMM_USE_STMT (use_stmt, use_iter, top_op1)\n+    {\n+      if (is_gimple_assign (use_stmt)\n+\t  && (gimple_assign_rhs_code (use_stmt) == TRUNC_DIV_EXPR\n+\t      || gimple_assign_rhs_code (use_stmt) == TRUNC_MOD_EXPR)\n+\t  && operand_equal_p (top_op1, gimple_assign_rhs1 (use_stmt), 0)\n+\t  && operand_equal_p (top_op2, gimple_assign_rhs2 (use_stmt), 0))\n+\t{\n+\t  if (use_stmt == top_stmt\n+\t      || stmt_can_throw_internal (use_stmt)\n+\t      || !dominated_by_p (CDI_DOMINATORS, gimple_bb (use_stmt), top_bb))\n+\t    continue;\n+\n+\t  stmts.safe_push (use_stmt);\n+\t  if (gimple_assign_rhs_code (use_stmt) == TRUNC_DIV_EXPR)\n+\t    div_seen = true;\n+\t}\n+    }\n+\n+  if (!div_seen)\n+    return false;\n+\n+  /* Part 3: Create libcall to internal fn DIVMOD:\n+     divmod_tmp = DIVMOD (op1, op2).  */\n+\n+  gcall *call_stmt = gimple_build_call_internal (IFN_DIVMOD, 2, op1, op2);\n+  tree res = make_temp_ssa_name (build_complex_type (TREE_TYPE (op1)),\n+\t\t\t\t call_stmt, \"divmod_tmp\");\n+  gimple_call_set_lhs (call_stmt, res);\n+\n+  /* Insert the call before top_stmt.  */\n+  gimple_stmt_iterator top_stmt_gsi = gsi_for_stmt (top_stmt);\n+  gsi_insert_before (&top_stmt_gsi, call_stmt, GSI_SAME_STMT);\n+\n+  widen_mul_stats.divmod_calls_inserted++;\t\t\n+\n+  /* Update all statements in stmts vector:\n+     lhs = op1 TRUNC_DIV_EXPR op2 -> lhs = REALPART_EXPR<divmod_tmp>\n+     lhs = op1 TRUNC_MOD_EXPR op2 -> lhs = IMAGPART_EXPR<divmod_tmp>.  */\n+\n+  for (unsigned i = 0; stmts.iterate (i, &use_stmt); ++i)\n+    {\n+      tree new_rhs;\n+\n+      switch (gimple_assign_rhs_code (use_stmt))\n+\t{\n+\t  case TRUNC_DIV_EXPR:\n+\t    new_rhs = fold_build1 (REALPART_EXPR, TREE_TYPE (op1), res);\n+\t    break;\n+\n+\t  case TRUNC_MOD_EXPR:\n+\t    new_rhs = fold_build1 (IMAGPART_EXPR, TREE_TYPE (op1), res);\n+\t    break;\n+\n+\t  default:\n+\t    gcc_unreachable ();\n+\t}\n+\n+      gimple_stmt_iterator gsi = gsi_for_stmt (use_stmt);\n+      gimple_assign_set_rhs_from_tree (&gsi, new_rhs);\n+      update_stmt (use_stmt);\n+    }\n+\n+  return true; \n+}    \n \n /* Find integer multiplications where the operands are extended from\n    smaller types, and replace the MULT_EXPR with a WIDEN_MULT_EXPR\n@@ -3837,6 +4050,8 @@ pass_optimize_widening_mul::execute (function *fun)\n   bool cfg_changed = false;\n \n   memset (&widen_mul_stats, 0, sizeof (widen_mul_stats));\n+  calculate_dominance_info (CDI_DOMINATORS);\n+  renumber_gimple_stmt_uids ();\n \n   FOR_EACH_BB_FN (bb, fun)\n     {\n@@ -3870,6 +4085,10 @@ pass_optimize_widening_mul::execute (function *fun)\n \t\t    match_uaddsub_overflow (&gsi, stmt, code);\n \t\t  break;\n \n+\t\tcase TRUNC_MOD_EXPR:\n+\t\t  convert_to_divmod (as_a<gassign *> (stmt));\n+\t\t  break;\n+\n \t\tdefault:;\n \t\t}\n \t    }\n@@ -3916,6 +4135,8 @@ pass_optimize_widening_mul::execute (function *fun)\n \t\t\t    widen_mul_stats.maccs_inserted);\n   statistics_counter_event (fun, \"fused multiply-adds inserted\",\n \t\t\t    widen_mul_stats.fmas_inserted);\n+  statistics_counter_event (fun, \"divmod calls inserted\",\n+\t\t\t    widen_mul_stats.divmod_calls_inserted);\n \n   return cfg_changed ? TODO_cleanup_cfg : 0;\n }"}]}