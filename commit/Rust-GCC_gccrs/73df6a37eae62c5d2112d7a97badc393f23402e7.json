{"sha": "73df6a37eae62c5d2112d7a97badc393f23402e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzNkZjZhMzdlYWU2MmM1ZDIxMTJkN2E5N2JhZGMzOTNmMjM0MDJlNw==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2006-10-12T00:16:48Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2006-10-12T00:16:48Z"}, "message": "lwg-active.html, [...]: Import Revision 44.\n\n2006-10-11  Paolo Carlini  <pcarlini@suse.de>\n\n\t* docs/html/ext/lwg-active.html, lwg-defects.html: Import Revision 44.\n\nFrom-SVN: r117651", "tree": {"sha": "ad71d035c1508495766264d2a2e47d3cf311a304", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad71d035c1508495766264d2a2e47d3cf311a304"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73df6a37eae62c5d2112d7a97badc393f23402e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73df6a37eae62c5d2112d7a97badc393f23402e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73df6a37eae62c5d2112d7a97badc393f23402e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73df6a37eae62c5d2112d7a97badc393f23402e7/comments", "author": null, "committer": null, "parents": [{"sha": "c4632147f3c0d8b2373fba1ebcfd69b2b83dc6ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4632147f3c0d8b2373fba1ebcfd69b2b83dc6ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4632147f3c0d8b2373fba1ebcfd69b2b83dc6ce"}], "stats": {"total": 1655, "additions": 1397, "deletions": 258}, "files": [{"sha": "44bf103176336dfc02af2a52d4aacab277946f05", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73df6a37eae62c5d2112d7a97badc393f23402e7/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73df6a37eae62c5d2112d7a97badc393f23402e7/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=73df6a37eae62c5d2112d7a97badc393f23402e7", "patch": "@@ -1,3 +1,7 @@\n+2006-10-11  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* docs/html/ext/lwg-active.html, lwg-defects.html: Import Revision 44.\n+\n 2006-10-11  Benjamin Kosnik  <bkoz@redhat.com>\n \n \tPR libstdc++/29426"}, {"sha": "22bc5916f92069290ca1143da34aea84ebe648f4", "filename": "libstdc++-v3/docs/html/ext/howto.html", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73df6a37eae62c5d2112d7a97badc393f23402e7/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Fhowto.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73df6a37eae62c5d2112d7a97badc393f23402e7/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Fhowto.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Fhowto.html?ref=73df6a37eae62c5d2112d7a97badc393f23402e7", "patch": "@@ -593,6 +593,12 @@ <h2><a name=\"5\">LWG Issues</a></h2>\n     <dd>In case of input_iterator/output_iterator rely on Assignability of\n         input_iterator' value_type.\n     </dd>\n+\n+    <dt><a href=\"lwg-active.html#586\">586</a>:\n+        <em>String inserter not a formatted function</em>\n+    </dt>\n+    <dd>Change it to be a formatted output function (i.e. catch exceptions).\n+    </dd>\n <!--\n     <dt><a href=\"lwg-defects.html#\"></a>:\n         <em></em>"}, {"sha": "7a2b949377f34f01a6b1313ad439391f43c9db2e", "filename": "libstdc++-v3/docs/html/ext/lwg-active.html", "status": "modified", "additions": 1157, "deletions": 38, "changes": 1195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73df6a37eae62c5d2112d7a97badc393f23402e7/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Flwg-active.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73df6a37eae62c5d2112d7a97badc393f23402e7/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Flwg-active.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Flwg-active.html?ref=73df6a37eae62c5d2112d7a97badc393f23402e7", "patch": "@@ -8,11 +8,11 @@\n <table>\n <tbody><tr>\n <td align=\"left\">Doc. no.</td>\n-<td align=\"left\">N2000=06-0070</td>\n+<td align=\"left\">N2091=06-0161</td>\n </tr>\n <tr>\n <td align=\"left\">Date:</td>\n-<td align=\"left\">2006-04-21</td>\n+<td align=\"left\">2006-09-08</td>\n </tr>\n <tr>\n <td align=\"left\">Project:</td>\n@@ -23,7 +23,7 @@\n <td align=\"left\">Howard Hinnant &lt;howard.hinnant@gmail.com&gt;</td>\n </tr>\n </tbody></table>\n-<h1>C++ Standard Library Active Issues List (Revision R42)</h1>\n+<h1>C++ Standard Library Active Issues List (Revision R44)</h1>\n   <p>Reference ISO/IEC IS 14882:1998(E)</p>\n   <p>Also see:</p>\n   <ul>\n@@ -91,6 +91,16 @@ <h1>C++ Standard Library Active Issues List (Revision R42)</h1>\n   directory as the issues list files.  </p>\n <h2>Revision History</h2>\n <ul>\n+<li>R44: \n+2006-09-08 pre-Portland mailing.\n+Added new issues <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#583\">583</a>-<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#592\">592</a>.\n+</li>\n+<li>R43: \n+2006-06-23 mid-term mailing.\n+Added new issues <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#575\">575</a>-<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#582\">582</a>.\n+Reopened <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#255\">255</a>.\n+Moved issues <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#520\">520</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#541\">541</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#544\">544</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#569\">569</a> to Tentatively Ready.\n+</li>\n <li>R42: \n 2006-04-21 post-Berlin mailing.\n Added new issues <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#567\">567</a>-<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#572\">572</a>.\n@@ -537,7 +547,7 @@ <h2>Active Issues</h2>\n   Bill will provide wording.</p>\n \n <hr>\n-<a name=\"96\"><h3>96.&nbsp;Vector&lt;bool&gt; is not a container</h3></a><p><b>Section:</b>&nbsp;23.2.5 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-containers.html#lib.vector.bool\"> [lib.vector.bool]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;AFNOR&nbsp; <b>Date:</b>&nbsp;7 Oct 1998</p>\n+<a name=\"96\"><h3>96.&nbsp;Vector&lt;bool&gt; is not a container</h3></a><p><b>Section:</b>&nbsp;23.2.5 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-containers.html#lib.vector\"> [lib.vector]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;AFNOR&nbsp; <b>Date:</b>&nbsp;7 Oct 1998</p>\n <p><tt>vector&lt;bool&gt;</tt> is not a container as its reference and\n pointer types are not references and pointers. </p>\n \n@@ -613,6 +623,50 @@ <h2>Active Issues</h2>\n   imprecise language. However, none of the proposals for changed\n   wording are clearer.  A redesign of numeric_limits is needed, but this\n   is more a task than an open issue.]</i></p>\n+<hr>\n+<a name=\"206\"><h3>206.&nbsp;operator new(size_t, nothrow) may become unlinked to ordinary operator new if ordinary version replaced</h3></a><p><b>Section:</b>&nbsp;18.5.1.1 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-support.html#lib.new.delete.single\"> [lib.new.delete.single]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Howard Hinnant&nbsp; <b>Date:</b>&nbsp;29 Aug 1999</p>\n+<p>As specified, the implementation of the nothrow version of operator\n+new does not necessarily call the ordinary operator new, but may\n+instead simply call the same underlying allocator and return a null\n+pointer instead of throwing an exception in case of failure.</p>\n+\n+<p>Such an implementation breaks code that replaces the ordinary\n+version of new, but not the nothrow version. If the ordinary version\n+of new/delete is replaced, and if the replaced delete is not\n+compatible with pointers returned from the library versions of new,\n+then when the replaced delete receives a pointer allocated by the\n+library new(nothrow), crash follows.</p>\n+\n+<p>The fix appears to be that the lib version of new(nothrow) must\n+call the ordinary new. Thus when the ordinary new gets replaced, the\n+lib version will call the replaced ordinary new and things will\n+continue to work.</p>\n+\n+<p>An alternative would be to have the ordinary new call\n+new(nothrow). This seems sub-optimal to me as the ordinary version of\n+new is the version most commonly replaced in practice. So one would\n+still need to replace both ordinary and nothrow versions if one wanted\n+to replace the ordinary version.</p>\n+\n+<p>Another alternative is to put in clear text that if one version is\n+replaced, then the other must also be replaced to maintain\n+compatibility. Then the proposed resolution below would just be a\n+quality of implementation issue. There is already such text in\n+paragraph 7 (under the new(nothrow) version). But this nuance is\n+easily missed if one reads only the paragraphs relating to the\n+ordinary new.</p>\n+\n+<p><b>Proposed resolution:</b></p>\n+<p><b>Rationale:</b></p>\n+<p>Yes, they may become unlinked, and that is by design. If a user\n+replaces one, the user should also replace the other.</p>\n+\n+<p><i>[\n+Reopened due to a gcc conversation between Howard, Martin and Gaby.  Forwarding\n+or not is visible behavior to the client and it would be useful for the client\n+to know which behavior it could depend on.\n+]</i></p>\n+\n <hr>\n <a name=\"233\"><h3>233.&nbsp;Insertion hints in associative containers</h3></a><p><b>Section:</b>&nbsp;23.1.2 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-containers.html#lib.associative.reqmts\"> [lib.associative.reqmts]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Andrew Koenig&nbsp; <b>Date:</b>&nbsp;30 Apr 2000</p>\n <p>\n@@ -864,7 +918,72 @@ <h2>Active Issues</h2>\n   compiler-generated constructors might in principle throw anything.]</i></p>\n \n <hr>\n-<a name=\"258\"><h3>258.&nbsp;Missing allocator requirement</h3></a><p><b>Section:</b>&nbsp;20.1.5 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-utilities.html#lib.allocator.requirements\"> [lib.allocator.requirements]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;22 Aug 2000</p>\n+<a name=\"255\"><h3>255.&nbsp;Why do <tt>basic_streambuf&lt;&gt;::pbump()</tt> and <tt>gbump()</tt> take an int?</h3></a><p><b>Section:</b>&nbsp;27.5.2 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.streambuf\"> [lib.streambuf]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;12 Aug 2000</p>\n+<p>\n+The basic_streambuf members gbump() and pbump() are specified to take an\n+int argument. This requirement prevents the functions from effectively\n+manipulating buffers larger than std::numeric_limits&lt;int&gt;::max()\n+characters. It also makes the common use case for these functions\n+somewhat difficult as many compilers will issue a warning when an\n+argument of type larger than int (such as ptrdiff_t on LLP64\n+architectures) is passed to either of the function. Since it's often the\n+result of the subtraction of two pointers that is passed to the\n+functions, a cast is necessary to silence such warnings. Finally, the\n+usage of a native type in the functions signatures is inconsistent with\n+other member functions (such as sgetn() and sputn()) that manipulate the\n+underlying character buffer. Those functions take a streamsize argument.\n+</p>\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+Change the signatures of these functions in the synopsis of template\n+class basic_streambuf (27.5.2) and in their descriptions (27.5.2.3.1, p4\n+and 27.5.2.3.2, p4) to take a streamsize argument.\n+</p>\n+\n+<p>\n+Although this change has the potential of changing the ABI of the\n+library, the change will affect only platforms where int is different\n+than the definition of streamsize. However, since both functions are\n+typically inline (they are on all known implementations), even on such\n+platforms the change will not affect any user code unless it explicitly\n+relies on the existing type of the functions (e.g., by taking their\n+address). Such a possibility is IMO quite remote.\n+</p>\n+\n+<p>\n+Alternate Suggestion from Howard Hinnant, c++std-lib-7780:\n+</p>\n+\n+<p>\n+This is something of a nit, but I'm wondering if streamoff wouldn't be a \n+better choice than streamsize.  The argument to pbump and gbump MUST be \n+signed.  But the standard has this to say about streamsize \n+(27.4.1/2/Footnote):\n+</p>\n+\n+<blockquote>\n+     [Footnote: streamsize is used in most places where ISO C would use\n+     size_t.  Most of the uses of streamsize could use size_t, except for\n+     the strstreambuf constructors, which require negative values. It\n+     should probably be the signed type corresponding to size_t (which is\n+     what Posix.2 calls ssize_t). --- end footnote]\n+</blockquote>\n+\n+<p>\n+This seems a little weak for the argument to pbump and gbump.  Should we \n+ever really get rid of strstream, this footnote might go with it, along \n+with the reason to make streamsize signed.\n+</p>\n+<p><b>Rationale:</b></p>\n+<p>The LWG believes this change is too big for now.  We may wish to\n+reconsider this for a future revision of the standard.  One\n+possibility is overloading pbump, rather than changing the\n+signature.</p>\n+<p><i>[\n+[2006-05-04: Reopened at the request of Chris (Krzysztof ?elechowski)]\n+]</i></p>\n+<hr>\n+<a name=\"258\"><h3>258.&nbsp;Missing allocator requirement</h3></a><p><b>Section:</b>&nbsp;20.1.5 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-utilities.html#lib.default.con.req\"> [lib.default.con.req]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;22 Aug 2000</p>\n <p>\n From lib-7752:\n </p>\n@@ -933,7 +1052,7 @@ <h2>Active Issues</h2>\n desired property.  This issue should be considered in light of\n other issues related to allocator instances.]</i></p>\n <hr>\n-<a name=\"290\"></a><h3><a name=\"290\">290.&nbsp;Requirements to for_each and its function object</a></h3><p><b>Section:</b>&nbsp;25.1.1 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-algorithms.html#lib.alg.foreach\"> [lib.alg.foreach]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Angelika Langer&nbsp; <b>Date:</b>&nbsp;03 Jan 2001</p>\n+<a name=\"290\"><h3>290.&nbsp;Requirements to for_each and its function object</h3></a><p><b>Section:</b>&nbsp;25.1.1 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-algorithms.html#lib.alg.foreach\"> [lib.alg.foreach]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Angelika Langer&nbsp; <b>Date:</b>&nbsp;03 Jan 2001</p>\n <p>The specification of the for_each algorithm does not have a\n \"Requires\" section, which means that there are no\n restrictions imposed on the function object whatsoever. In essence it\n@@ -1411,7 +1530,7 @@ <h2>Active Issues</h2>\n   or <tt>badbit</tt> is set, so using <tt>!fail()</tt>, rather\n   than <tt>good()</tt>, satisfies this goal.</p>\n <hr>\n-<a name=\"382\"><h3>382.&nbsp;codecvt do_in/out result</h3></a><p><b>Section:</b>&nbsp;22.2.1.5 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-locales.html#lib.locale.codecvt\"> [lib.locale.codecvt]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;30 Aug  2002</p>\n+<a name=\"382\"><h3>382.&nbsp;codecvt do_in/out result</h3></a><p><b>Section:</b>&nbsp;22.2.1.5 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-locales.html#lib.locale.codecvt.byname\"> [lib.locale.codecvt.byname]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;30 Aug  2002</p>\n <p>\n It seems that the descriptions of codecvt do_in() and do_out() leave\n sufficient room for interpretation so that two implementations of\n@@ -1436,7 +1555,7 @@ <h2>Active Issues</h2>\n \n <ol>\n <li>\n-   22.2.1.5.2 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-locales.html#lib.locale.codecvt.virtuals\"> [lib.locale.codecvt.virtuals]</a>, p2 says this about the effects of the\n+   <font color=\"red\">22.2.1.5.2</font>, p2 says this about the effects of the\n    function: ...Stops if it encounters a character it cannot\n    convert...  This assumes that there *is* a character to\n    convert. What happens when there is a sequence that doesn't form a\n@@ -1469,7 +1588,7 @@ <h2>Active Issues</h2>\n </li>\n </ol>\n <p>\n-Finally, the conditions described at the end of 22.2.1.5.2 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-locales.html#lib.locale.codecvt.virtuals\"> [lib.locale.codecvt.virtuals]</a>, p4 don't seem to be possible:\n+Finally, the conditions described at the end of <font color=\"red\">22.2.1.5.2</font>, p4 don't seem to be possible:\n </p>\n <blockquote>\n     \"A return value of partial, if (from_next == from_end),\n@@ -1483,7 +1602,7 @@ <h2>Active Issues</h2>\n ==from_end) could ever hold if there isn't enough room\n in the destination buffer. In order for (from_next==from_end) to\n hold, all characters in that range must have been successfully\n-converted (according to 22.2.1.5.2 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-locales.html#lib.locale.codecvt.virtuals\"> [lib.locale.codecvt.virtuals]</a>, p2) and since there are no\n+converted (according to <font color=\"red\">22.2.1.5.2</font>, p2) and since there are no\n further source characters to convert, no more room in the\n destination buffer can be needed.\n </p>\n@@ -1559,7 +1678,7 @@ <h2>Active Issues</h2>\n not be allowed.\n ]</i></p>\n <hr>\n-<a name=\"387\"><h3>387.&nbsp;std::complex over-encapsulated</h3></a><p><b>Section:</b>&nbsp;26.2 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-numerics.html#lib.complex.numbers\"> [lib.complex.numbers]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Gabriel Dos Reis&nbsp; <b>Date:</b>&nbsp;8 Nov 2002</p>\n+<a name=\"387\"><h3>387.&nbsp;std::complex over-encapsulated</h3></a><p><b>Section:</b>&nbsp;26.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-numerics.html#lib.complex.numbers\"> [lib.complex.numbers]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Gabriel Dos Reis&nbsp; <b>Date:</b>&nbsp;8 Nov 2002</p>\n <p>\n The absence of explicit description of std::complex&lt;T&gt; layout\n makes it imposible to reuse existing software developed in traditional\n@@ -1591,7 +1710,7 @@ <h2>Active Issues</h2>\n </p>\n \n <p><b>Proposed resolution:</b></p>\n-<p>Add the following requirements to 26.2 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-numerics.html#lib.complex.numbers\"> [lib.complex.numbers]</a> as 26.2/4:</p>\n+<p>Add the following requirements to 26.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-numerics.html#lib.complex.numbers\"> [lib.complex.numbers]</a> as 26.3/4:</p>\n <blockquote>\n <p>If z is an lvalue expression of type cv std::complex&lt;T&gt; then</p>\n \n@@ -1618,7 +1737,7 @@ <h2>Active Issues</h2>\n </ul>\n </blockquote>\n \n-<p>In the header synopsis in 26.2.1 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-numerics.html#lib.complex.synopsis\"> [lib.complex.synopsis]</a>, replace</p>\n+<p>In the header synopsis in 26.3.1 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-numerics.html#lib.complex.synopsis\"> [lib.complex.synopsis]</a>, replace</p>\n <pre>  template&lt;class T&gt; T real(const complex&lt;T&gt;&amp;);\n   template&lt;class T&gt; T imag(const complex&lt;T&gt;&amp;);\n </pre>\n@@ -1631,7 +1750,7 @@ <h2>Active Issues</h2>\n   template&lt;class T&gt;       T&amp; imag(      complex&lt;T&gt;&amp;);\n </pre>\n \n-<p>In 26.2.7 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-numerics.html#lib.complex.value.ops\"> [lib.complex.value.ops]</a> paragraph 1, change</p>\n+<p>In 26.3.7 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-numerics.html#lib.complex.value.ops\"> [lib.complex.value.ops]</a> paragraph 1, change</p>\n <pre>  template&lt;class T&gt; T real(const complex&lt;T&gt;&amp;);\n </pre>\n <p>to</p>\n@@ -1641,7 +1760,7 @@ <h2>Active Issues</h2>\n <p>and change the <b>Returns</b> clause to \"<b>Returns:</b> The real\n part of <i>x</i></p>.\n \n-<p>In 26.2.7 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-numerics.html#lib.complex.value.ops\"> [lib.complex.value.ops]</a> paragraph 2, change</p>\n+<p>In 26.3.7 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-numerics.html#lib.complex.value.ops\"> [lib.complex.value.ops]</a> paragraph 2, change</p>\n <pre>  template&lt;class T&gt; T imag(const complex&lt;T&gt;&amp;);\n </pre>\n <p>to</p>\n@@ -1994,9 +2113,9 @@ <h2>Active Issues</h2>\n   and changing it on an individual basis wouldn't make things better.\n   Dietmar will do this work.</p>\n <hr>\n-<a name=\"401\"><h3>401.&nbsp; incorrect type casts in table 32 in lib.allocator.requirements</h3></a><p><b>Section:</b>&nbsp;20.1.5 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-utilities.html#lib.allocator.requirements\"> [lib.allocator.requirements]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Markus Mauhart&nbsp; <b>Date:</b>&nbsp;27 Feb 2003</p>\n+<a name=\"401\"><h3>401.&nbsp; incorrect type casts in table 32 in lib.allocator.requirements</h3></a><p><b>Section:</b>&nbsp;20.1.5 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-utilities.html#lib.default.con.req\"> [lib.default.con.req]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Markus Mauhart&nbsp; <b>Date:</b>&nbsp;27 Feb 2003</p>\n <p>\n-I think that in par2 of 20.1.5 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-utilities.html#lib.allocator.requirements\"> [lib.allocator.requirements]</a> the last two\n+I think that in par2 of 20.1.5 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-utilities.html#lib.default.con.req\"> [lib.default.con.req]</a> the last two\n lines of table 32 contain two incorrect type casts. The lines are ...\n </p>\n \n@@ -2561,7 +2680,7 @@ <h2>Active Issues</h2>\n use the right wording.]</i></p>\n \n <hr>\n-<a name=\"423\"></a><h3><a name=\"423\">423.&nbsp;effects of negative streamsize in iostreams</a></h3><p><b>Section:</b>&nbsp;27 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.input.output\"> [lib.input.output]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;18 Sep 2003</p>\n+<a name=\"423\"><h3>423.&nbsp;effects of negative streamsize in iostreams</h3></a><p><b>Section:</b>&nbsp;27 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.input.output\"> [lib.input.output]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;18 Sep 2003</p>\n \n <p>\n A third party test suite tries to exercise istream::ignore(N) with\n@@ -2689,7 +2808,7 @@ <h2>Active Issues</h2>\n use <tt>char_traits&lt;charT&gt;</tt></p>.\n \n <hr>\n-<a name=\"430\"><h3>430.&nbsp;valarray subset operations</h3></a><p><b>Section:</b>&nbsp;26.3.2.4 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-numerics.html#lib.valarray.sub\"> [lib.valarray.sub]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;18 Sep 2003</p>\n+<a name=\"430\"><h3>430.&nbsp;valarray subset operations</h3></a><p><b>Section:</b>&nbsp;26.5.2.4 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-numerics.html#lib.valarray.sub\"> [lib.valarray.sub]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;18 Sep 2003</p>\n <p>\n The standard fails to specify the behavior of valarray::operator[](slice)\n and other valarray subset operations when they are passed an \"invalid\"\n@@ -2703,8 +2822,8 @@ <h2>Active Issues</h2>\n   performance, so we don't want to require specific checking.  We\n   need wording to express this decision.]</i></p>\n <hr>\n-<a name=\"431\"><h3>431.&nbsp;Swapping containers with unequal allocators</h3></a><p><b>Section:</b>&nbsp;20.1.5 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-utilities.html#lib.allocator.requirements\"> [lib.allocator.requirements]</a>, 25 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-algorithms.html#lib.algorithms\"> [lib.algorithms]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;20 Sep 2003</p>\n-<p>Clause 20.1.5 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-utilities.html#lib.allocator.requirements\"> [lib.allocator.requirements]</a> paragraph 4 says that implementations\n+<a name=\"431\"><h3>431.&nbsp;Swapping containers with unequal allocators</h3></a><p><b>Section:</b>&nbsp;20.1.5 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-utilities.html#lib.default.con.req\"> [lib.default.con.req]</a>, 25 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-algorithms.html#lib.algorithms\"> [lib.algorithms]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;20 Sep 2003</p>\n+<p>Clause 20.1.5 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-utilities.html#lib.default.con.req\"> [lib.default.con.req]</a> paragraph 4 says that implementations\n   are permitted to supply containers that are unable to cope with\n   allocator instances and that container implementations may assume\n   that all instances of an allocator type compare equal.  We gave\n@@ -3043,7 +3162,7 @@ <h2>Active Issues</h2>\n       if it the source and destination types are the same</li>\n </ol>\n <hr>\n-<a name=\"462\"><h3>462.&nbsp;Destroying objects with static storage duration</h3></a><p><b>Section:</b>&nbsp;3.6.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/basic.html#basic.start.term\"> [basic.start.term]</a>, 18.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-support.html#lib.support.start.term\"> [lib.support.start.term]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Bill Plauger&nbsp; <b>Date:</b>&nbsp;23 Mar 2004</p>\n+<a name=\"462\"><h3>462.&nbsp;Destroying objects with static storage duration</h3></a><p><b>Section:</b>&nbsp;3.6.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/basic.html#basic.start.term\"> [basic.start.term]</a>, 18.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-support.html#lib.cstdint\"> [lib.cstdint]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Bill Plauger&nbsp; <b>Date:</b>&nbsp;23 Mar 2004</p>\n <p>\n 3.6.3 Termination spells out in detail the interleaving of static\n destructor calls and calls to functions registered with atexit. To\n@@ -3077,7 +3196,7 @@ <h2>Active Issues</h2>\n <p>\n </p>\n <hr>\n-<a name=\"463\"><h3>463.&nbsp;auto_ptr usability issues</h3></a><p><b>Section:</b>&nbsp;20.4.5 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-utilities.html#lib.auto.ptr\"> [lib.auto.ptr]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Rani Sharoni&nbsp; <b>Date:</b>&nbsp;7 Dec 2003</p>\n+<a name=\"463\"><h3>463.&nbsp;auto_ptr usability issues</h3></a><p><b>Section:</b>&nbsp;20.4.5 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-utilities.html#lib.meta.unary\"> [lib.meta.unary]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Rani Sharoni&nbsp; <b>Date:</b>&nbsp;7 Dec 2003</p>\n \n <p>\n TC1 CWG DR #84 effectively made the template&lt;class Y&gt; operator auto_ptr&lt;Y&gt;()\n@@ -3392,7 +3511,7 @@ <h2>Active Issues</h2>\n   \n \n <hr>\n-<a name=\"471\"><h3>471.&nbsp;result of what() implementation-defined</h3></a><p><b>Section:</b>&nbsp;18.6.1 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-support.html#lib.exception\"> [lib.exception]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;28 Jun 2004</p>\n+<a name=\"471\"><h3>471.&nbsp;result of what() implementation-defined</h3></a><p><b>Section:</b>&nbsp;18.6.1 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-support.html#lib.type.info\"> [lib.type.info]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;28 Jun 2004</p>\n \n <p>[lib.exception] specifies the following:</p>\n <pre>    exception (const exception&amp;) throw();\n@@ -4266,7 +4385,7 @@ <h2>Active Issues</h2>\n <p>\n </p>\n <hr>\n-<a name=\"520\"><h3>520.&nbsp;Result_of and pointers to data members</h3></a><p><b>Section:</b>&nbsp;TR1 3.6 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/tr1.html#tr.func.bind\"> [tr.func.bind]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Pete Becker&nbsp; <b>Date:</b>&nbsp;3 Jul 2005</p>\n+<a name=\"520\"><h3>520.&nbsp;Result_of and pointers to data members</h3></a><p><b>Section:</b>&nbsp;TR1 3.6 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/tr1.html#tr.func.bind\"> [tr.func.bind]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Tentatively%20Ready\">Tentatively Ready</a>&nbsp; <b>Submitter:</b>&nbsp;Pete Becker&nbsp; <b>Date:</b>&nbsp;3 Jul 2005</p>\n <p>\n In the original proposal for binders, the return type of bind() when\n called with a pointer to member data as it's callable object was\n@@ -4281,6 +4400,19 @@ <h2>Active Issues</h2>\n <p><i>[\n Pete and Peter will provide wording.\n ]</i></p>\n+\n+<p>\n+In 20.5.4 [lib.func.ret] ([tr.func.ret]) p3 add the following bullet after bullet 2:\n+</p>\n+<ol start=\"3\">\n+<li>If <tt>F</tt> is a member data pointer type <tt>R T::*</tt>, <tt>type</tt>\n+shall be <tt><i>cv</i> R&amp;</tt> when <tt>T1</tt> is <tt><i>cv</i> U1&amp;</tt>,\n+<tt>R</tt> otherwise.</li>\n+</ol>\n+\n+<p><i>[\n+Peter provided wording.\n+]</i></p>\n <hr>\n <a name=\"521\"><h3>521.&nbsp;Garbled requirements for argument_type in reference_wrapper</h3></a><p><b>Section:</b>&nbsp;TR1 2.1.2 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/tr1.html#tr.util.refwrp.refwrp\"> [tr.util.refwrp.refwrp]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Ready\">Ready</a>&nbsp; <b>Submitter:</b>&nbsp;Pete Becker&nbsp; <b>Date:</b>&nbsp;3 Jul 2005</p>\n <p>\n@@ -4674,7 +4806,20 @@ <h2>Active Issues</h2>\n \n <p><b>Proposed resolution:</b></p>\n <p>\n+In 20.5.10.1.3 [lib.func.bind.bind] ([tr.func.bind.bind]), add a new paragraph after p2:\n </p>\n+<blockquote>\n+<i>Throws:</i> Nothing unless one of the copy constructors of <tt>f, t1, t2, ..., tN</tt>\n+throws an exception.\n+</blockquote>\n+\n+<p>\n+Add a new paragraph after p4:\n+</p>\n+<blockquote>\n+<i>Throws:</i> nothing unless one of the copy constructors of <tt>f, t1, t2, ..., tN</tt>\n+throws an exception.\n+</blockquote>\n <hr>\n <a name=\"528\"><h3>528.&nbsp;TR1: issue 6.19 vs 6.3.4.3/2 (and 6.3.4.5/2)</h3></a><p><b>Section:</b>&nbsp;TR1 6.3.4 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/tr1.html#tr.unord.unord\"> [tr.unord.unord]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Paolo Carlini&nbsp; <b>Date:</b>&nbsp;12 Oct 2005</p>\n <p>\n@@ -5236,7 +5381,7 @@ <h2>Active Issues</h2>\n Otherwise CopyConstructible is not required.\n </blockquote>\n <hr>\n-<a name=\"539\"><h3>539.&nbsp;partial_sum and adjacent_difference should mention requirements</h3></a><p><b>Section:</b>&nbsp;26.4 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-numerics.html#lib.numeric.ops\"> [lib.numeric.ops]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Marc Schoolderman&nbsp; <b>Date:</b>&nbsp;6 Feb 2006</p>\n+<a name=\"539\"><h3>539.&nbsp;partial_sum and adjacent_difference should mention requirements</h3></a><p><b>Section:</b>&nbsp;26.4 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-numerics.html#lib.rand\"> [lib.rand]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Open\">Open</a>&nbsp; <b>Submitter:</b>&nbsp;Marc Schoolderman&nbsp; <b>Date:</b>&nbsp;6 Feb 2006</p>\n <p>\n There are some problems in the definition of partial_sum and\n adjacent_difference in 26.4 [lib.numeric.ops]\n@@ -5429,7 +5574,7 @@ <h2>Active Issues</h2>\n </blockquote>\n \n <hr>\n-<a name=\"541\"><h3>541.&nbsp;shared_ptr template assignment and void</h3></a><p><b>Section:</b>&nbsp;TR1 2.2.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/tr1.html#tr.util.smartptr.shared\"> [tr.util.smartptr.shared]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;16 Oct 2005</p>\n+<a name=\"541\"><h3>541.&nbsp;shared_ptr template assignment and void</h3></a><p><b>Section:</b>&nbsp;TR1 2.2.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/tr1.html#tr.util.smartptr.shared\"> [tr.util.smartptr.shared]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Tentatively%20Ready\">Tentatively Ready</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;16 Oct 2005</p>\n <p>\n Is the void specialization of the template assignment operator taking\n a shared_ptr&lt;void&gt; as an argument supposed be well-formed?\n@@ -5479,7 +5624,23 @@ <h2>Active Issues</h2>\n </pre></blockquote>\n <p><b>Proposed resolution:</b></p>\n <p>\n+In [lib.memory] change:\n+</p>\n+<blockquote><pre>template&lt;class X&gt; class auto_ptr;\n+<ins>template&lt;&gt; class auto_ptr&lt;void&gt;;</ins>\n+</pre></blockquote>\n+\n+<p>\n+In [lib.auto.ptr]/2 add the following before the last closing brace:\n </p>\n+\n+<blockquote><pre>template&lt;&gt; class auto_ptr&lt;void&gt;\n+{\n+public:\n+&nbsp; &nbsp; typedef void element_type;\n+};\n+</pre></blockquote>\n+\n <hr>\n <a name=\"542\"><h3>542.&nbsp;shared_ptr observers</h3></a><p><b>Section:</b>&nbsp;TR1 2.2.3.5 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/tr1.html#tr.util.smartptr.shared.obs\"> [tr.util.smartptr.shared.obs]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;18 Oct 2005</p>\n <p>\n@@ -5517,7 +5678,7 @@ <h2>Active Issues</h2>\n <p>\n </p>\n <hr>\n-<a name=\"543\"><h3>543.&nbsp;valarray slice default constructor</h3></a><p><b>Section:</b>&nbsp;26.3.4 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-numerics.html#lib.class.slice\"> [lib.class.slice]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Howard Hinnant&nbsp; <b>Date:</b>&nbsp;3 Nov 2005</p>\n+<a name=\"543\"><h3>543.&nbsp;valarray slice default constructor</h3></a><p><b>Section:</b>&nbsp;26.3.4 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-numerics.html#lib.complex.members\"> [lib.complex.members]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Howard Hinnant&nbsp; <b>Date:</b>&nbsp;3 Nov 2005</p>\n <p>\n If one explicitly constructs a slice or glice with the default\n constructor, does the standard require this slice to have any usable\n@@ -5557,7 +5718,7 @@ <h2>Active Issues</h2>\n <p>\n </p>\n <hr>\n-<a name=\"544\"><h3>544.&nbsp;minor NULL problems in C.2</h3></a><p><b>Section:</b>&nbsp;C.2 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/diff.html#diff.library\"> [diff.library]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;25 Nov 2005</p>\n+<a name=\"544\"><h3>544.&nbsp;minor NULL problems in C.2</h3></a><p><b>Section:</b>&nbsp;C.2 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/diff.html#diff.library\"> [diff.library]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Tentatively%20Ready\">Tentatively Ready</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;25 Nov 2005</p>\n <p>\n According to C.2.2.3, p1, \"the macro NULL, defined in any of &lt;clocale&gt;,\n &lt;cstddef&gt;, &lt;cstdio&gt;, &lt;cstdlib&gt;, &lt;cstring&gt;, &lt;ctime&gt;,\n@@ -5596,7 +5757,19 @@ <h2>Active Issues</h2>\n </p>\n <p><b>Proposed resolution:</b></p>\n <p>\n+Add after the first sentence of [lib.util.smartptr.getdeleter]/1:\n </p>\n+<blockquote>\n+<p>\n+The returned pointer remains valid as long as there exists a <tt>shared_ptr</tt> instance\n+that owns <tt><i>d</i></tt>.\n+</p>\n+<p>\n+[<i>Note:</i> it is unspecified whether the pointer remains valid longer than that.\n+This can happen if the implementation doesn't destroy the deleter until all\n+<tt>weak_ptr</tt> instances in the ownership group are destroyed. <i>-- end note</i>]\n+</p>\n+</blockquote>\n <hr>\n <a name=\"546\"><h3>546.&nbsp;_Longlong and _ULonglong are integer types</h3></a><p><b>Section:</b>&nbsp;TR1 5.1.1 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/tr1.html#tr.rand.req\"> [tr.rand.req]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;10 Jan 2006</p>\n <p>\n@@ -5665,7 +5838,7 @@ <h2>Active Issues</h2>\n Berlin: Typo: \"n\" replaced by \"t\" in N1932: see 26.3.7.2.2/1.\n </p>\n <hr>\n-<a name=\"550\"><h3>550.&nbsp;What should the return type of pow(float,int) be?</h3></a><p><b>Section:</b>&nbsp;26.5 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-numerics.html#lib.c.math\"> [lib.c.math]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Howard Hinnant&nbsp; <b>Date:</b>&nbsp;12 Jan 2006</p>\n+<a name=\"550\"><h3>550.&nbsp;What should the return type of pow(float,int) be?</h3></a><p><b>Section:</b>&nbsp;26.5 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-numerics.html#lib.numarray\"> [lib.numarray]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Howard Hinnant&nbsp; <b>Date:</b>&nbsp;12 Jan 2006</p>\n <p>\n Assuming we adopt the\n <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1836.pdf\">C\n@@ -6005,7 +6178,7 @@ <h2>Active Issues</h2>\n \n         </p>\n <hr>\n-<a name=\"560\"><h3>560.&nbsp;User-defined allocators without default constructor</h3></a><p><b>Section:</b>&nbsp;20.1.5 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-utilities.html#lib.allocator.requirements\"> [lib.allocator.requirements]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Sergey P. Derevyago&nbsp; <b>Date:</b>&nbsp;17 Feb 2006</p>\n+<a name=\"560\"><h3>560.&nbsp;User-defined allocators without default constructor</h3></a><p><b>Section:</b>&nbsp;20.1.5 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-utilities.html#lib.default.con.req\"> [lib.default.con.req]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Sergey P. Derevyago&nbsp; <b>Date:</b>&nbsp;17 Feb 2006</p>\n <h4>1. The essence of the problem.</h4>\n <p>\n User-defined allocators without default constructor are not explicitly\n@@ -6594,7 +6767,7 @@ <h4>4. Code sample.</h4>\n Add <tt>log2</tt> to the list of functions in 8.16.4p1.\n </p>\n <hr>\n-<a name=\"569\"><h3>569.&nbsp;Postcondition for basic_ios::clear(iostate) incorrectly stated</h3></a><p><b>Section:</b>&nbsp;27.4.4.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.iostate.flags\"> [lib.iostate.flags]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Seungbeom Kim&nbsp; <b>Date:</b>&nbsp;10 Mar 2006</p>\n+<a name=\"569\"><h3>569.&nbsp;Postcondition for basic_ios::clear(iostate) incorrectly stated</h3></a><p><b>Section:</b>&nbsp;27.4.4.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.iostate.flags\"> [lib.iostate.flags]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Tentatively%20Ready\">Tentatively Ready</a>&nbsp; <b>Submitter:</b>&nbsp;Seungbeom Kim&nbsp; <b>Date:</b>&nbsp;10 Mar 2006</p>\n <p>\n Section: 27.4.4.3 [lib.iostate.flags]\n </p>\n@@ -6616,13 +6789,10 @@ <h4>4. Code sample.</h4>\n committee meant.\n </p>\n <p><b>Proposed resolution:</b></p>\n+<p><b>Rationale:</b></p>\n <p>\n-Change 27.4.4.3p4:\n+This is a duplicate of issue <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#272\">272</a>.\n </p>\n-<blockquote>\n-<i>Postcondition:</i> If <tt>rdbuf()!=0</tt> then <tt><i>state</i> == rdstate();</tt>\n-otherwise <tt>rdstate()==<ins>(</ins><i>state</i>|ios_base::badbit</tt><ins>)</ins>.\n-</blockquote>\n <hr>\n <a name=\"570\"><h3>570.&nbsp;Request adding additional explicit specializations of char_traits</h3></a><p><b>Section:</b>&nbsp;21.1 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-strings.html#lib.char.traits\"> [lib.char.traits]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Jack Reeves&nbsp; <b>Date:</b>&nbsp;6 Apr 2006</p>\n <p>\n@@ -6672,7 +6842,7 @@ <h4>4. Code sample.</h4>\n Strike the proposed resolution of issue 507.\n </p>\n <hr>\n-<a name=\"573\"><h3>573.&nbsp;C++0x file positioning should handle modern file sizes</h3></a><p><b>Section:</b>&nbsp;27.4.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.fpos\"> [lib.fpos]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Your name&nbsp; <b>Date:</b>&nbsp;29 Feb 1900</p>\n+<a name=\"573\"><h3>573.&nbsp;C++0x file positioning should handle modern file sizes</h3></a><p><b>Section:</b>&nbsp;27.4.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.fpos\"> [lib.fpos]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Beman Dawes&nbsp; <b>Date:</b>&nbsp;12 Apr 2006</p>\n <p>\n There are two deficiencies related to file sizes:\n </p>\n@@ -6723,5 +6893,954 @@ <h4>4. Code sample.</h4>\n <p><b>Proposed resolution:</b></p>\n <p>\n </p>\n+<hr>\n+<a name=\"575\"><h3>575.&nbsp;the specification of ~shared_ptr is MT-unfriendly, makes implementation assumptions</h3></a><p><b>Section:</b>&nbsp;20.6.6.2.2 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-utilities.html#lib.util.smartptr.shared.dest\"> [lib.util.smartptr.shared.dest]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Peter Dimov&nbsp; <b>Date:</b>&nbsp;23 Apr 2006</p>\n+<p>\n+[tr.util.smartptr.shared.dest] says in its second bullet:\n+</p>\n+\n+<p>\n+\"If *this shares ownership with another shared_ptr instance (use_count() &gt; 1),\n+decrements that instance's use count.\"\n+</p>\n+\n+<p>\n+The problem with this formulation is that it presupposes the existence of an\n+\"use count\" variable that can be decremented and that is part of the state of a\n+shared_ptr instance (because of the \"that instance's use count\".)\n+</p>\n+\n+<p>\n+This is contrary to the spirit of the rest of the specification that carefully\n+avoids to require an use count variable. Instead, use_count() is specified to\n+return a value, a number of instances.\n+</p>\n+\n+<p>\n+In multithreaded code, the usual implicit assumption is that a shared variable\n+should not be accessed by more than one thread without explicit synchronization,\n+and by introducing the concept of an \"use count\" variable, the current wording\n+implies that two shared_ptr instances that share ownership cannot be destroyed\n+simultaneously.\n+</p>\n+\n+<p>\n+In addition, if we allow the interpretation that an use count variable is part\n+of shared_ptr's state, this would lead to other undesirable consequences WRT\n+multiple threads. For example,\n+</p>\n+\n+<blockquote><pre>p1 = p2;\n+</pre></blockquote>\n+\n+<p>\n+would now visibly modify the state of p2, a \"write\" operation, requiring a lock.\n+</p>\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+Change the first two bullets of [lib.util.smartptr.shared.dest]/1 to:\n+</p>\n+\n+<blockquote><p>\n+</p><ul>\n+<li>If <tt>*this</tt> is <i>empty</i> <ins>or shares ownership with another\n+<tt>shared_ptr</tt> instance (<tt>use_count() &gt; 1</tt>)</ins>, there are no side effects.</li>\n+<li><del>If <tt>*this</tt> <i>shares ownership</i> with another <tt>shared_ptr</tt> instance\n+(<tt>use_count() &gt; 1</tt>), decrements that instance's use count.</del></li>\n+</ul>\n+<p></p></blockquote>\n+\n+<p>\n+Add the following paragraph after [lib.util.smartptr.shared.dest]/1:\n+</p>\n+\n+<blockquote><p>\n+[<i>Note:</i> since the destruction of <tt>*this</tt> decreases the number of instances in\n+<tt>*this</tt>'s ownership group by one, all <tt>shared_ptr</tt> instances that share ownership\n+with <tt>*this</tt> will report an <tt>use_count()</tt> that is one lower than its previous value\n+after <tt>*this</tt> is destroyed. <i>--end note</i>]\n+</p></blockquote>\n+<hr>\n+<a name=\"576\"><h3>576.&nbsp;find_first_of is overconstrained</h3></a><p><b>Section:</b>&nbsp;25.1.4 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-algorithms.html#lib.alg.find.first.of\"> [lib.alg.find.first.of]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Doug Gregor&nbsp; <b>Date:</b>&nbsp;25 Apr 2006</p>\n+<p>\n+In 25.1.4 Find First [lib.alg.find.first], the two iterator type parameters to\n+find_first_of are specified to require Forward Iterators, as follows:\n+</p>\n+\n+<blockquote><pre>template&lt;class ForwardIterator1, class ForwardIterator2&gt;\n+  ForwardIterator1\n+  find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,\n+                        ForwardIterator2 first2, ForwardIterator2 last2);\n+template&lt;class ForwardIterator1, class ForwardIterator2,\n+                  class BinaryPredicate&gt;\n+ForwardIterator1\n+  find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,\n+                         ForwardIterator2 first2, ForwardIterator2 last2,\n+                        BinaryPredicate pred);\n+</pre></blockquote>\n+\n+<p>\n+However, ForwardIterator1 need not actually be a Forward Iterator; an Input\n+Iterator suffices, because we do not need the multi-pass property of the Forward\n+Iterator or a true reference.\n+</p>\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+Change the declarations of <tt>find_first_of</tt> to:\n+</p>\n+\n+<blockquote><pre>template&lt;class <del>ForwardIterator1</del><ins>InputIterator1</ins>, class ForwardIterator2&gt;\n+  <del>ForwardIterator1</del><ins>InputIterator1</ins>\n+  find_first_of(<del>ForwardIterator1</del><ins>InputIterator1</ins> first1, <del>ForwardIterator1</del><ins>InputIterator1</ins> last1,\n+                        ForwardIterator2 first2, ForwardIterator2 last2);\n+template&lt;class <del>ForwardIterator1</del><ins>InputIterator1</ins>, class ForwardIterator2,\n+                  class BinaryPredicate&gt;\n+<del>ForwardIterator1</del><ins>InputIterator1</ins>\n+  find_first_of(<del>ForwardIterator1</del><ins>InputIterator1</ins> first1, <del>ForwardIterator1</del><ins>InputIterator1</ins> last1,\n+                         ForwardIterator2 first2, ForwardIterator2 last2,\n+                        BinaryPredicate pred);\n+</pre></blockquote>\n+\n+<hr>\n+<a name=\"577\"><h3>577.&nbsp;upper_bound(first, last, ...) cannot return last</h3></a><p><b>Section:</b>&nbsp;25.3.3.2 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-algorithms.html#lib.upper.bound\"> [lib.upper.bound]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Seungbeom Kim&nbsp; <b>Date:</b>&nbsp;3 May 2006</p>\n+<p>\n+ISO/IEC 14882:2003 says:\n+</p>\n+\n+<blockquote>\n+<p>\n+25.3.3.2 upper_bound\n+</p>\n+<p>\n+<i>Returns:</i> The furthermost iterator <tt>i</tt> in the range\n+<tt>[<i>first</i>, <i>last</i>)</tt> such that\n+for any iterator <tt>j</tt> in the range <tt>[<i>first</i>, i)</tt> the following corresponding\n+conditions hold: <tt>!(value &lt; *j)</tt> or <tt><i>comp</i>(<i>value</i>, *j) == false</tt>.\n+</p>\n+</blockquote>\n+\n+<p>\n+From the description above, upper_bound cannot return last, since it's\n+not in the interval [first, last). This seems to be a typo, because if\n+value is greater than or equal to any other values in the range, or if\n+the range is empty, returning last seems to be the intended behaviour.\n+The corresponding interval for lower_bound is also [first, last].\n+</p>\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+Change [lib.upper.bound]:\n+</p>\n+\n+<blockquote>\n+<p>\n+<i>Returns:</i> The furthermost iterator <tt>i</tt> in the range\n+<tt>[<i>first</i>, <i>last</i><del>)</del><ins>]</ins></tt> such that\n+for any iterator <tt>j</tt> in the range <tt>[<i>first</i>, i)</tt> the following corresponding\n+conditions hold: <tt>!(value &lt; *j)</tt> or <tt><i>comp</i>(<i>value</i>, *j) == false</tt>.\n+</p>\n+</blockquote>\n+\n+<hr>\n+<a name=\"578\"><h3>578.&nbsp;purpose of hint to allocator::allocate()</h3></a><p><b>Section:</b>&nbsp;20.6.1.1 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-utilities.html#lib.allocator.members\"> [lib.allocator.members]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;17 May 2006</p>\n+        <p>\n+\n+The     description    of     the     allocator    member     function\n+<code>allocate()</code>  requires  that  the <i>hint</i>  argument  be\n+either 0 or a  value previously returned from <code>allocate()</code>.\n+Footnote 227 further suggests that  containers may pass the address of\n+an adjacent element as this argument.\n+\n+        </p>\n+        <p>\n+\n+I  believe  that  either  the  footnote  is  wrong  or  the  normative\n+requirement that  the argument be  a value previously returned  from a\n+call to  <code>allocate()</code> is wrong. The latter  is supported by\n+the resolution  to issue 20-004 proposed in  c++std-lib-3736 by Nathan\n+Myers. In addition,  the <i>hint</i> is an ordinary  void* and not the\n+<code>pointer</code>  type returned  by  <code>allocate()</code>, with\n+the  two  types potentially  being  incompatible  and the  requirement\n+impossible to satisfy.\n+\n+        </p>\n+        <p>\n+\n+See also c++std-lib-14323 for some  more context on where this came up\n+(again).\n+\n+        </p>\n+    <p><b>Proposed resolution:</b></p>\n+        <p>\n+\n+Remove  the requirement  in  20.6.1.1, p4  that  the hint  be a  value\n+previously returned from <code>allocate()</code>. Specifically, change\n+the paragraph as follows:\n+\n+        </p>\n+        <p>\n+\n+<i>Requires</i>: <i>hint</i> <ins>is </ins>either 0 or <del>previously\n+obtained  from  member <code>allocate</code>  and  not  yet passed  to\n+member  <code>deallocate</code></del><ins> the  address of  a  byte in\n+memory (1.7)</ins>.\n+\n+        </p>\n+    <hr>\n+<a name=\"579\"><h3>579.&nbsp;erase(iterator) for unordered containers should not return an iterator</h3></a><p><b>Section:</b>&nbsp;23.1.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-containers.html#lib.unord.req\"> [lib.unord.req]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Joaqu\ufffdn M L\ufffdpez Mu\ufffdoz&nbsp; <b>Date:</b>&nbsp;13 Jun 2006</p>\n+<p>\n+See\n+<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2023.pdf\">N2023</a>\n+for full discussion.\n+</p>\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+Option 1:\n+</p>\n+\n+<p>\n+The problem can be eliminated by omitting the requirement that <tt>a.erase(q)</tt> return an \n+iterator. This is, however, in contrast with the equivalent requirements for other \n+standard containers.\n+</p>\n+\n+<p>\n+Option 2:\n+</p>\n+\n+<p>\n+<tt>a.erase(q)</tt> can be made to compute the next iterator only when explicitly requested: \n+the technique consists in returning a proxy object implicitly convertible to <tt>iterator</tt>, so \n+that\n+</p>\n+\n+<blockquote><pre>iterator q1=a.erase(q);\n+</pre></blockquote>\n+\n+<p>\n+works as expected, while\n+</p>\n+\n+<blockquote><pre>a.erase(q);\n+</pre></blockquote>\n+\n+<p>\n+does not ever invoke the conversion-to-iterator operator, thus avoiding the associated \n+computation. To allow this technique, some sections of TR1 along the line \"return value \n+is an iterator...\" should be changed to \"return value is an unspecified object implicitly \n+convertible to an iterator...\" Although this trick is expected to work transparently, it can \n+have some collateral effects when the expression <tt>a.erase(q)</tt> is used inside generic \n+code.\n+</p>\n+\n+<hr>\n+<a name=\"580\"><h3>580.&nbsp;unused allocator members</h3></a><p><b>Section:</b>&nbsp;20.1.6 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-utilities.html#lib.allocator.requirements\"> [lib.allocator.requirements]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;14 June 2006</p>\n+        <p>\n+\n+C++ Standard Library  templates that take an allocator  as an argument\n+are    required    to    call    the    <code>allocate()</code>    and\n+<code>deallocate()</code>  members of the  allocator object  to obtain\n+storage.  However, they do not appear to be required to call any other\n+allocator      members      such     as      <code>construct()</code>,\n+<code>destroy()</code>,           <code>address()</code>,          and\n+<code>max_size()</code>.  This makes these allocator members less than\n+useful in portable programs.\n+\n+        </p>\n+    <p><b>Proposed resolution:</b></p>\n+        <p>\n+\n+It's unclear to me whether the absence of the requirement to use these\n+allocator  members  is  an  unintentional  omission  or  a  deliberate\n+choice. However,  since the functions exist in  the standard allocator\n+and  since  they are  required  to  be  provided by  any  user-defined\n+allocator I  believe the standard  ought to be clarified  to explictly\n+specify  whether programs  should or  should not  be able  to  rely on\n+standard containers calling the functions.\n+\n+        </p>\n+        <p>\n+\n+I  propose  that all  containers  be required  to  make  use of  these\n+functions.\n+\n+        </p>\n+    <hr>\n+<a name=\"581\"></a><h3><a name=\"581\">581.&nbsp;<code>flush()</code> not unformatted function</a></h3><p><b>Section:</b>&nbsp;27.6.2.6 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.ostream.unformatted\"> [lib.ostream.unformatted]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;14 June 2006</p>\n+        <p>\n+\n+The resolution of issue 60 changed <code>basic_ostream::flush()</code>\n+so as not  to require it to behave as  an unformatted output function.\n+That has at least two in my opinion problematic consequences:\n+\n+        </p>\n+        <p>\n+\n+First, <code>flush()</code>  now calls <code>rdbuf()-&gt;pubsync()</code>\n+unconditionally, without  regard to the  state of the stream.  I can't\n+think of any reason why <code>flush()</code> should behave differently\n+from the vast majority of stream functions in this respect.\n+\n+        </p>\n+        <p>\n+\n+Second, <code>flush()</code> is not  required to catch exceptions from\n+<code>pubsync()</code> or set  <code>badbit</code> in response to such\n+events. That doesn't seem right either, as most other stream functions\n+do so.\n+\n+        </p>\n+    <p><b>Proposed resolution:</b></p>\n+        <p>\n+\n+I  propose  to revert  the  resolution of  issue  60  with respect  to\n+<code>flush()</code>. Specifically,  I propose to  change 27.6.2.6, p7\n+as follows:\n+\n+        </p>\n+\n+Effects: <ins>Behaves as an  unformatted output function (as described\n+in 27.6.2.6, paragraph 1). </ins>If <code>rdbuf()</code> is not a null\n+pointer,  <ins>constructs a  sentry  object.  If  this object  returns\n+<code>true</code> when converted to a  value of type bool the function\n+</ins>calls <code>rdbuf()-&gt;pubsync()</code>.  If that function returns\n+-1    calls    <code>setstate(badbit)</code>    (which    may    throw\n+<code>ios_base::failure</code>  (27.4.4.3)).   <ins>Otherwise, if  the\n+sentry object returns <code>false</code>, does nothing.</ins><del>Does\n+not  behave  as  an  unformatted  output  function  (as  described  in\n+27.6.2.6, paragraph 1).</del>\n+\n+    <hr>\n+<a name=\"582\"><h3>582.&nbsp;specialized algorithms and volatile storage</h3></a><p><b>Section:</b>&nbsp;20.6.4.1 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-utilities.html#lib.uninitialized.copy\"> [lib.uninitialized.copy]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;14 June 2006</p>\n+        <p>\n+\n+The specialized  algorithms [lib.specialized.algorithms] are specified\n+as having the general effect of invoking the following expression:\n+\n+        </p>\n+        <p>\n+            </p><pre>\n+new (static_cast&lt;void*&gt;(&amp;*i))\n+    typename iterator_traits&lt;ForwardIterator&gt;::value_type (x)\n+\n+            </pre>\n+        <p></p>\n+        <p>\n+\n+This  expression is  ill-formed  when the  type  of the  subexpression\n+<code>&amp;*i</code> is some volatile-qualified <code>T</code>.\n+\n+        </p>\n+    <p><b>Proposed resolution:</b></p>\n+        <p>\n+\n+In order  to allow these algorithms  to operate on  volatile storage I\n+propose to change the expression so as to make it well-formed even for\n+pointers  to volatile  types.  Specifically,  I propose  the following\n+changes to clauses 20 and 24. Change 20.6.4.1, p1 to read:\n+\n+        </p>\n+        <p>\n+            </p><pre>\n+<i>Effects</i>:\n+\n+typedef typename iterator_traits&lt;ForwardIterator&gt;::pointer    pointer;\n+typedef typename iterator_traits&lt;ForwardIterator&gt;::value_type value_type;\n+\n+for (; first != last; ++result, ++first)\n+    new (static_cast&lt;void*&gt;(const_cast&lt;pointer&gt;(&amp;*result))\n+        value_type (*first);\n+\n+            </pre>\n+        <p></p>\n+        <p>\n+\n+change 20.6.4.2, p1 to read\n+\n+        </p>\n+        <p>\n+            </p><pre>\n+<i>Effects</i>:\n+\n+typedef typename iterator_traits&lt;ForwardIterator&gt;::pointer    pointer;\n+typedef typename iterator_traits&lt;ForwardIterator&gt;::value_type value_type;\n+\n+for (; first != last; ++result, ++first)\n+    new (static_cast&lt;void*&gt;(const_cast&lt;pointer&gt;(&amp;*first))\n+        value_type (*x);\n+\n+            </pre>\n+        <p></p>\n+        <p>\n+\n+and change 20.6.4.3, p1 to read\n+\n+        </p>\n+        <p>\n+            </p><pre>\n+<i>Effects</i>:\n+\n+typedef typename iterator_traits&lt;ForwardIterator&gt;::pointer    pointer;\n+typedef typename iterator_traits&lt;ForwardIterator&gt;::value_type value_type;\n+\n+for (; n--; ++first)\n+    new (static_cast&lt;void*&gt;(const_cast&lt;pointer&gt;(&amp;*first))\n+        value_type (*x);\n+\n+            </pre>\n+        <p></p>\n+        <p>\n+\n+In   addition,  since   there   is  no   partial  specialization   for\n+<code>iterator_traits&lt;volatile T*&gt;</code>  I propose to  add one\n+to parallel such specialization  for &lt;const T*&gt;. Specifically, I\n+propose to add the following text to the end of 24.3.1, p3:\n+\n+        </p>\n+        <p>\n+\n+and for pointers to volatile as \n+\n+        </p>\n+        <p>\n+            </p><pre>\n+namespace std {\n+template&lt;class T&gt; struct iterator_traits&lt;volatile T*&gt; {\n+typedef ptrdiff_t difference_type;\n+typedef T value_type;\n+typedef volatile T* pointer;\n+typedef volatile T&amp; reference;\n+typedef random_access_iterator_tag iterator_category;\n+};\n+}\n+\n+            </pre>\n+        <p></p>\n+        <p>\n+\n+Note that  the change to  <code>iterator_traits</code> isn't necessary\n+in order to implement the  specialized algorithms in a way that allows\n+them to operate on volatile  strorage. It is only necesassary in order\n+to specify  their effects in terms  of <code>iterator_traits</code> as\n+is  done here.   Implementations can  (and some  do) achieve  the same\n+effect by means of function template overloading.\n+\n+        </p>\n+    <hr>\n+<a name=\"583\"><h3>583.&nbsp;div() for unsigned integral types</h3></a><p><b>Section:</b>&nbsp;26.7 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-numerics.html#lib.c.math\"> [lib.c.math]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Beman Dawes&nbsp; <b>Date:</b>&nbsp;15 Jun 2006</p>\n+<p>\n+There is no div() function for unsigned integer types.\n+</p>\n+<p>\n+There are several possible resolutions.  The simplest one is noted below.  Other\n+possibilities include a templated solution.\n+</p>\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+Add to 26.7 [lib.c.math] paragraph 8:\n+</p>\n+\n+<blockquote><pre>struct udiv_t div(unsigned, unsigned);\n+struct uldiv_t div(unsigned long, unsigned long);\n+struct ulldiv_t div(unsigned long long, unsigned long long);\n+</pre></blockquote>\n+\n+<hr>\n+<a name=\"584\"><h3>584.&nbsp;missing int pow(int,int) functionality</h3></a><p><b>Section:</b>&nbsp;26.7 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-numerics.html#lib.c.math\"> [lib.c.math]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Beman Dawes&nbsp; <b>Date:</b>&nbsp;15 Jun 2006</p>\n+<p>\n+There is no pow() function for any integral type.\n+</p>\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+Add something like:\n+</p>\n+\n+<blockquote><pre>template&lt; typename T&gt;\n+T power( T x, int n );\n+// requires: n &gt;=0\n+</pre></blockquote>\n+<hr>\n+<a name=\"585\"></a><h3><a name=\"585\">585.&nbsp;facet error reporting</a></h3><p><b>Section:</b>&nbsp;22.2 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-locales.html#lib.locale.categories\"> [lib.locale.categories]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor, Paolo Carlini&nbsp; <b>Date:</b>&nbsp;22 June 2006</p>\n+        <p>\n+\n+Section  22.2, paragraph 2  requires facet  <code>get()</code> members\n+that    take    an    <code>ios_base::iostate&amp;</code>    argument,\n+<code><i>err</i></code>,  to   ignore  the  (initial)   value  of  the\n+argument, but to set it to <code>ios_base::failbit</code> in case of a\n+parse error.\n+\n+        </p>\n+        <p>\n+\n+We  believe  there  are  a   few  minor  problems  with  this  blanket\n+requirement  in   conjunction  with   the  wording  specific   to  each\n+<code>get()</code> member function.\n+\n+        </p>\n+        <p>\n+\n+First,  besides <code>get()</code>  there are  other  member functions\n+with     a      slightly     different     name      (for     example,\n+<code>get_date()</code>). It's not completely clear that the intent of\n+the  paragraph  is  to  include  those  as  well,  and  at  least  one\n+implementation has interpreted the requirement literally.\n+\n+        </p>\n+        <p>\n+\n+Second,    the     requirement    to    \"set     the    argument    to\n+<code>ios_base::failbit</code>  suggests that  the  functions are  not\n+permitted    to   set    it   to    any   other    value    (such   as\n+<code>ios_base::eofbit</code>,   or   even  <code>ios_base::eofbit   |\n+ios_base::failbit</code>).\n+\n+        </p>\n+        <p>\n+\n+However, 22.2.2.1.2, p5 (Stage  3 of <code>num_get</code> parsing) and\n+p6 (<code>bool</code> parsing)  specifies that the <code>do_get</code>\n+functions  perform <code><i>err</i> |=  ios_base::eofbit</code>, which\n+contradicts  the earlier  requirement to  ignore  <i>err</i>'s initial\n+value.\n+\n+        </p>\n+        <p>\n+\n+22.2.6.1.2,  p1  (the  Effects  clause of  the  <code>money_get</code>\n+facet's  <code>do_get</code>  member  functions) also  specifies  that\n+<code><i>err</i></code>'s initial  value be used to  compute the final\n+value  by  ORing  it  with  either  <code>ios_base::failbit</code>  or\n+with<code>ios_base::eofbit | ios_base::failbit</code>.\n+\n+        </p>\n+    <p><b>Proposed resolution:</b></p>\n+        <p>\n+\n+We believe the  intent is for all facet member  functions that take an\n+<code>ios_base::iostate&amp;</code> argument to:\n+\n+        </p>\n+        <p>\n+            </p><ul>\n+                <li>\n+\n+ignore the initial value of the <code><i>err</i></code> argument,\n+\n+                </li>\n+                <li>\n+\n+reset <code><i>err</i></code>  to <code>ios_base::goodbit</code> prior\n+to any further processing,\n+\n+                </li>\n+                <li>\n+\n+and       set      either       <code>ios_base::eofbit</code>,      or\n+<code>ios_base::failbit</code>, or both in <code><i>err</i></code>, as\n+appropriate,  in response  to  reaching the  end-of-file  or on  parse\n+error, or both.\n+\n+                </li>\n+            </ul>\n+        <p></p>\n+        <p>\n+\n+To that effect we propose to change 22.2, p2 as follows:\n+\n+        </p>\n+        <p>\n+\n+The  <i>put</i><del>()</del>  members  make  no  provision  for  error\n+reporting.   (Any  failures of  the  OutputIterator  argument must  be\n+extracted   from  the   returned  iterator.)    <ins>Unless  otherwise\n+specified, </ins>the <i>get</i><del>()</del>  members  <ins>that</ins>\n+take an  <code>ios_base::iostate&amp;</code> argument <del>whose value\n+they  ignore,  but  set  to  ios_base::failbit  in  case  of  a  parse\n+error.</del><ins>,   <code><i>err</i></code>,   start  by   evaluating\n+<code>err  =   ios_base::goodbit</code>,  and  may   subsequently  set\n+<i>err</i>     to     either     <code>ios_base::eofbit</code>,     or\n+<code>ios_base::failbit</code>,     or     <code>ios_base::eofbit    |\n+ios_base::failbit</code> in response to reaching the end-of-file or in\n+case of a parse error, or both, respectively.</ins>\n+\n+        </p>\n+    <hr>\n+<a name=\"586\"><h3>586.&nbsp;string inserter not a formatted function</h3></a><p><b>Section:</b>&nbsp;21.3.7.9 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-strings.html#lib.string.io\"> [lib.string.io]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;22 June 2006</p>\n+        <p>\n+\n+Section  and paragraph  numbers  in  this paper  are  relative to  the\n+working draft document number N2009 from 4/21/2006.\n+\n+        </p>\n+\n+        <p>\n+\n+The  <code>basic_string</code> extractor  in 21.3.7.9,  p1  is clearly\n+required  to  behave  as  a   formatted  input  function,  as  is  the\n+<code>std::getline()</code> overload for string described in p7.\n+\n+        </p>\n+        <p>\n+\n+However, the <code>basic_string</code> inserter described in p5 of the\n+same section has no such requirement. This has implications on how the\n+operator  responds  to  exceptions thrown  from  <code>xsputn()</code>\n+(formatted  output functions are  required to  set <code>badbit</code>\n+and swallow  the exception unless  <code>badbit</code> is also  set in\n+<code>exceptions()</code>; the  string inserter doesn't  have any such\n+requirement).\n+\n+        </p>\n+        <p>\n+\n+I don't  see anything in the  spec for the string  inserter that would\n+justify requiring  it to treat  exceptions differently from  all other\n+similar operators. (If it did, I think it should be made this explicit\n+by saying  that the  operator \"does not  behave as a  formatted output\n+function\" as has been made customary by the adoption of the resolution\n+of issue 60).\n+\n+        </p>\n+    <p><b>Proposed resolution:</b></p>\n+        <p>\n+\n+I propose to change the Effects clause in 21.3.7.9, p5, as follows:\n+\n+        </p>\n+        <p>\n+            </p><blockquote>\n+\n+<i>Effects</i>: <del>Begins by constructing a  sentry object k as if k\n+were    constructed    by    typename    <code>basic_ostream&lt;charT,\n+traits&gt;::sentry   k   (os)</code>.    If  <code>bool(k)</code>   is\n+<code>true</code>, </del><ins>Behaves  as a formatted  output function\n+(27.6.2.5.1).   After constructing  a  <code>sentry</code> object,  if\n+this  object returns <code>true</code>  when converted  to a  value of\n+type   <code>bool</code>,   determines   padding   as   described   in\n+22.2.2.2.2</ins>,  then inserts the  resulting sequence  of characters\n+<code><i>seq</i></code> as if by calling <code>os.rdbuf()-&gt;sputn(seq ,\n+n)</code>,    where   <code><i>n</i></code>    is   the    larger   of\n+<code>os.width()</code>   and   <code>str.size()</code>;  then   calls\n+<code>os.width(0)</code>.  <del>If  the  call  to sputn  fails,  calls\n+<code>os.setstate(ios_base::failbit)</code>.</del>\n+\n+            </blockquote>\n+        <p></p>\n+        <p>\n+\n+This proposed  resilution assumes the  resolution of issue  394 (i.e.,\n+that   all   formatted   output   functions  are   required   to   set\n+<code>ios_base::badbit</code>  in response  to any  kind  of streambuf\n+failure),   and   implicitly   assumes   that  a   return   value   of\n+<code>sputn(seq,  <i>n</i>)</code>  other  than  <code><i>n</i></code>\n+indicates a failure.\n+\n+        </p>\n+    <hr>\n+<a name=\"587\"><h3>587.&nbsp;iststream ctor missing description</h3></a><p><b>Section:</b>&nbsp;D.7.2.1 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/future.html#depr.istrstream.cons\"> [depr.istrstream.cons]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;22 June 2006</p>\n+        <p>\n+\n+The  <code>iststream(char*, streamsize)</code>  ctor is  in  the class\n+synopsis  in D.7.2  but its  signature is  missing in  the description\n+below (in D.7.2.1).\n+\n+        </p>\n+    <p><b>Proposed resolution:</b></p>\n+        <p>\n+\n+This seems like a simple editorial issue and the missing signature can\n+be added to the one for <code>const char*</code> in paragraph 2.\n+\n+        </p>\n+    <hr>\n+<a name=\"588\"><h3>588.&nbsp;requirements on zero sized tr1::arrays and other details</h3></a><p><b>Section:</b>&nbsp;23.2.1 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-containers.html#lib.array\"> [lib.array]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Gennaro Prota&nbsp; <b>Date:</b>&nbsp;18 Jul 2006</p>\n+<p>\n+The wording used for section 23.2.1 [lib.array] seems to be subtly\n+ambiguous about zero sized arrays (N==0). Specifically:\n+</p>\n+<p>\n+* \"An instance of array&lt;T, N&gt; stores N elements of type T, so that\n+[...]\"\n+</p>\n+<p>\n+Does this imply that a zero sized array object stores 0 elements, i.e.\n+that it cannot store any element of type T? The next point clarifies\n+the rationale behind this question, basically how to implement begin()\n+and end():\n+</p>\n+<p>\n+* 23.2.1.5 [lib.array.zero], p2: \"In the case that N == 0, begin() ==\n+end() == unique value.\"\n+</p>\n+<p>\n+What does \"unique\" mean in this context? Let's consider the following\n+possible implementations, all relying on a partial specialization:\n+</p>\n+<blockquote><pre>a)\n+    template&lt; typename T &gt;\n+    class array&lt; T, 0 &gt; {\n+    \n+        ....\n+\n+        iterator begin()\n+        { return iterator( reinterpret_cast&lt; T * &gt;( this ) ); }\n+        ....\n+\n+    };\n+</pre></blockquote>\n+<p>\n+This has been used in boost, probably intending that the return value\n+had to be unique to the specific array object and that array couldn't\n+store any T. Note that, besides relying on a reinterpret_cast, has\n+(more than potential) alignment problems.\n+</p>\n+<blockquote><pre>b)\n+    template&lt; typename T &gt;\n+    class array&lt; T, 0 &gt; {\n+    \n+        T t;\n+\n+        iterator begin()\n+        { return iterator( &amp;t ); }\n+        ....\n+\n+    };\n+</pre></blockquote>\n+<p>\n+This provides a value which is unique to the object and to the type of\n+the array, but requires storing a T. Also, it would allow the user to\n+mistakenly provide an initializer list with one element.\n+</p>\n+<p>\n+A slight variant could be returning *the* null pointer of type T\n+</p>\n+<blockquote><pre>    return static_cast&lt;T*&gt;(0);\n+</pre></blockquote>\n+<p>\n+In this case the value would be unique to the type array&lt;T, 0&gt; but not\n+to the objects (all objects of type array&lt;T, 0&gt; with the same value\n+for T would yield the same pointer value).\n+</p>\n+<p>\n+Furthermore this is inconsistent with what the standard requires from\n+allocation functions (see library issue 9).\n+</p>\n+<p>\n+c) same as above but with t being a static data member; again, the\n+value would be unique to the type, not to the object.\n+</p>\n+<p>\n+d) to avoid storing a T *directly* while disallowing the possibility\n+to use a one-element initializer list a non-aggregate nested class\n+could be defined\n+</p>\n+<blockquote><pre>    struct holder { holder() {} T t; } h;\n+</pre></blockquote>\n+<p>\n+and then begin be defined as\n+</p>\n+<blockquote><pre> iterator begin() { return &amp;h.t; }\n+</pre></blockquote>\n+<p>\n+But then, it's arguable whether the array stores a T or not.\n+Indirectly it does.\n+</p>\n+<p>\n+-----------------------------------------------------\n+</p>\n+<p>\n+Now, on different issues:\n+</p>\n+<p>\n+* what's the effect of calling assign(T&amp;) on a zero-sized array? There\n+seems to be only mention of front() and back(), in 23.2.1 [lib.array]\n+p4 (I would also suggest to move that bullet to section 23.2.1.5\n+[lib.array.zero], for locality of reference)\n+</p>\n+<p>\n+* (minor) the opening paragraph of 23.2.1 [lib.array] wording is a bit\n+inconsistent with that of other sequences: that's not a problem in\n+itself, but compare it for instance with \"A vector is a kind of\n+sequence that supports random access iterators\"; though the intent is\n+obvious one might argue that the wording used for arrays doesn't tell\n+what an array is, and relies on the reader to infer that it is what\n+the &lt;array&gt; header defines.\n+</p>\n+<p>\n+* it would be desiderable to have a static const data member of type\n+std::size_t, with value N, for usage as integral constant expression\n+</p>\n+<p>\n+* section 23.1 [lib.container.requirements] seem not to consider\n+fixed-size containers at all, as it says: \"[containers] control\n+allocation and deallocation of these objects [the contained objects]\n+through constructors, destructors, *insert and erase* operations\"\n+</p>\n+<p>\n+* max_size() isn't specified: the result is obvious but, technically,\n+it relies on table 80: \"size() of the largest possible container\"\n+which, again, doesn't seem to consider fixed size containers\n+</p>\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+</p>\n+<hr>\n+<a name=\"589\"><h3>589.&nbsp;Requirements on iterators of member template functions of containers</h3></a><p><b>Section:</b>&nbsp;23.1 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-containers.html#lib.container.requirements\"> [lib.container.requirements]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Peter Dimov&nbsp; <b>Date:</b>&nbsp;2 Aug 2006</p>\n+<p>\n+There appears to be no requirements on the InputIterators used in sequences in 23.1.1 in\n+terms of their value_type, and the requirements in 23.1.2 appear to be overly strict\n+(requires InputIterator::value_type be the same type as the container's value_type).\n+</p>\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+Change 23.1.1 p3:\n+</p>\n+\n+<blockquote>\n+In Tables 82 and 83, <tt>X</tt> denotes a sequence class, <tt>a</tt> denotes a\n+value of <tt>X</tt>, <tt>i</tt> and <tt>j</tt> denote iterators satisfying input\n+iterator requirements <ins>and refer to elements <ins>implicitly\n+convertible to</ins> <tt>value_type</tt></ins>, <tt>[i, j)</tt> denotes a valid\n+range, <tt>n</tt> denotes a value of <tt>X::size_type</tt>, <tt>p</tt> denotes a\n+valid iterator to <tt>a</tt>, <tt>q</tt> denotes a valid dereferenceable\n+iterator to <tt>a</tt>, <tt>[q1, q2)</tt> denotes a valid range in <tt>a</tt>,\n+and <tt>t</tt> denotes a value of <tt>X::value_type</tt>.\n+</blockquote>\n+\n+<p>\n+Change 23.1.2 p7:\n+</p>\n+\n+<blockquote>\n+In Table 84, <tt>X</tt> is an associative container class, <tt>a</tt> is a value\n+of <tt>X</tt>, <tt>a_uniq</tt> is a value of <tt>X</tt> when <tt>X</tt> supports\n+unique keys, and <tt>a_eq</tt> is a value of <tt>X</tt> when <tt>X</tt> supports\n+multiple keys, <tt>i</tt> and <tt>j</tt> satisfy input iterator requirements and\n+refer to elements <del>of</del> <ins>implicitly convertible to</ins>\n+<tt>value_type</tt>, <tt>[i, j)</tt> is a valid range, <tt>p</tt> is a valid\n+iterator to <tt>a</tt>, <tt>q</tt> is a valid dereferenceable iterator to\n+<tt>a</tt>, <tt>[q1, q2)</tt> is a valid range in <tt>a</tt>, <tt>t</tt> is a\n+value of <tt>X::value_type</tt>, <tt>k</tt> is a value of <tt>X::key_type</tt>\n+and <tt>c</tt> is a value of type <tt>X::key_compare</tt>.\n+</blockquote>\n+\n+<hr>\n+<a name=\"590\"><h3>590.&nbsp;Type traits implementation latitude should be removed for C++0x</h3></a><p><b>Section:</b>&nbsp;<font color=\"red\">20.4.9</font>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Beman Dawes&nbsp; <b>Date:</b>&nbsp;10 Aug 2006</p>\n+<p>\n+20.4.9 [lib.meta.req], Implementation requirements, provides latitude for type\n+traits implementers that is not needed in C++0x. It includes the wording:\n+</p>\n+\n+<blockquote>\n+[<i>Note:</i> the latitude granted to implementers in this clause is temporary,\n+and is expected to be removed in future revisions of this document. -- <i>end note</i>]\n+</blockquote>\n+\n+<p>\n+Note:\n+<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2028.html\">N2028:\n+Minor Modifications to the type traits Wording</a>\n+also has the intent of removing this wording from the WP.\n+</p>\n+\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+Remove 20.4.9 [lib.meta.req] in its entirety from the WP.\n+</p>\n+<hr>\n+<a name=\"591\"><h3>591.&nbsp;Misleading \"built-in</h3></a><p><b>Section:</b>&nbsp;18.2.1.2 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-support.html#lib.numeric.limits.members\"> [lib.numeric.limits.members]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;whyglinux&nbsp; <b>Date:</b>&nbsp;8 Aug 2006</p>\n+<p>\n+18.2.1.2 numeric_limits members [lib.numeric.limits.members]\n+Paragraph 7:\n+</p>\n+<blockquote>\n+\"For built-in integer types, the number of non-sign bits in the\n+representation.\"\n+</blockquote>\n+\n+<p>\n+26.1 Numeric type requirements [lib.numeric.requirements]\n+Footnote:\n+</p>\n+\n+<blockquote>\n+\"In other words, value types. These include built-in arithmetic types,\n+pointers, the library class complex, and instantiations of valarray for\n+value types.\"\n+</blockquote>\n+\n+<p>\n+Integer types (which are bool, char, wchar_t, and the signed and\n+unsigned integer types) and arithmetic types (which are integer and\n+floating types) are all built-in types and thus there are no\n+non-built-in (that is, user-defined) integer or arithmetic types. Since\n+the redundant \"built-in\" in the above 2 sentences can mislead that\n+there may be built-in or user-defined integer and arithmetic types\n+(which is not correct), the \"built-in\" should be removed.\n+</p>\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+</p><p>\n+18.2.1.2 numeric_limits members [lib.numeric.limits.members]\n+Paragraph 7:\n+</p>\n+<blockquote>\n+\"For <del>built-in</del> integer types, the number of non-sign bits in the\n+representation.\"\n+</blockquote>\n+\n+<p>\n+26.1 Numeric type requirements [lib.numeric.requirements]\n+Footnote:\n+</p>\n+\n+<blockquote>\n+\"In other words, value types. These include <del>built-in</del> arithmetic types,\n+pointers, the library class complex, and instantiations of valarray for\n+value types.\"\n+</blockquote>\n+<p></p>\n+<hr>\n+<a name=\"592\"><h3>592.&nbsp;Incorrect treatment of rdbuf()-&gt;close() return type</h3></a><p><b>Section:</b>&nbsp;27.8.1.7 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.ifstream.members\"> [lib.ifstream.members]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#New\">New</a>&nbsp; <b>Submitter:</b>&nbsp;Christopher Kohlhoff&nbsp; <b>Date:</b>&nbsp;17 Aug 2006</p>\n+<p>\n+I just spotted a minor problem in 27.8.1.7\n+[lib.ifstream.members] para 4 and also 27.8.1.13\n+[lib.fstream.members] para 4. In both places it says:\n+</p>\n+<blockquote>\n+<pre>void close();\n+</pre>\n+<p>\n+Effects: Calls rdbuf()-&gt;close() and, if that function returns false, ...\n+</p>\n+</blockquote>\n+<p>\n+However, basic_filebuf::close() (27.8.1.2) returns a pointer to the\n+filebuf on success, null on failure, so I think it is meant to\n+say \"if that function returns a null pointer\". Oddly, it is\n+correct for basic_ofstream.\n+</p>\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+Change 27.8.1.7 [lib.ifstream.members], p5:\n+</p>\n+\n+<blockquote>\n+<i>Effects:</i> Calls <tt>rdbuf()-&gt;close()</tt> and, if that function\n+<ins>fails (</ins>returns <del><tt>false</tt></del> <ins>a null pointer)</ins>,\n+calls <tt>setstate(failbit)</tt> (which may throw <tt>ios_base::failure</tt>\n+(27.4.4.3)).\n+</blockquote>\n+\n+<p>\n+Change 27.8.1.13 [lib.fstream.members], p5:\n+</p>\n+\n+<blockquote>\n+<i>Effects:</i> Calls <tt>rdbuf()-&gt;close()</tt> and, if that function\n+<ins>fails (</ins>returns <del><tt>false</tt></del> <ins>a null pointer)</ins>,\n+calls <tt>setstate(failbit)</tt> (which may throw <tt>ios_base::failure</tt>\n+(27.4.4.3)).\n+</blockquote>\n+\n <p>----- End of document -----</p>\n </body></html>\n\\ No newline at end of file"}, {"sha": "ab3fe6bc622efb7d16cf594612ed7887c4eb6539", "filename": "libstdc++-v3/docs/html/ext/lwg-defects.html", "status": "modified", "additions": 230, "deletions": 220, "changes": 450, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73df6a37eae62c5d2112d7a97badc393f23402e7/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Flwg-defects.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73df6a37eae62c5d2112d7a97badc393f23402e7/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Flwg-defects.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Flwg-defects.html?ref=73df6a37eae62c5d2112d7a97badc393f23402e7"}]}