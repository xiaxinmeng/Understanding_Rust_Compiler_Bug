{"sha": "a5af23fe121ce80395777cd066f04699e56240e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTVhZjIzZmUxMjFjZTgwMzk1Nzc3Y2QwNjZmMDQ2OTllNTYyNDBlMA==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1999-02-04T22:55:55Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "1999-02-04T22:55:55Z"}, "message": "unroll.c (entire file): Remove tabs / spaces at end of lines.\n\n\t* unroll.c (entire file): Remove tabs / spaces at end of lines.\n\tReplace spaces with tabs where appropriate.\n\nFrom-SVN: r25033", "tree": {"sha": "7aba2e54842be0f9c1c2db722e665de6e871d368", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7aba2e54842be0f9c1c2db722e665de6e871d368"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5af23fe121ce80395777cd066f04699e56240e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5af23fe121ce80395777cd066f04699e56240e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5af23fe121ce80395777cd066f04699e56240e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5af23fe121ce80395777cd066f04699e56240e0/comments", "author": null, "committer": null, "parents": [{"sha": "ca077833bc86644749187660098d5897e8396b36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca077833bc86644749187660098d5897e8396b36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca077833bc86644749187660098d5897e8396b36"}], "stats": {"total": 213, "additions": 109, "deletions": 104}, "files": [{"sha": "6c7fa5801be25471fe9cc2d12e49785a14eae0fd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5af23fe121ce80395777cd066f04699e56240e0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5af23fe121ce80395777cd066f04699e56240e0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a5af23fe121ce80395777cd066f04699e56240e0", "patch": "@@ -1,3 +1,8 @@\n+Fri Feb  5 06:55:15 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\t* unroll.c (entire file): Remove tabs / spaces at end of lines.\n+\tReplace spaces with tabs where appropriate.\n+\n Thu Feb  4 15:12:41 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* loop.c (scan_loop): New argument loop_cont.  Changed caller."}, {"sha": "bb5770d44fda4ecfa509e48a775fd7f0e5925fcf", "filename": "gcc/unroll.c", "status": "modified", "additions": 104, "deletions": 104, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5af23fe121ce80395777cd066f04699e56240e0/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5af23fe121ce80395777cd066f04699e56240e0/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=a5af23fe121ce80395777cd066f04699e56240e0", "patch": "@@ -99,11 +99,11 @@ Boston, MA 02111-1307, USA.  */\n        int iterations = (len + 1) >> 1;\n        int i;\n        for (p; p < q; p++, q--;)\n-         {\n-           tmp = *q;\n-           *q = *p;\n-           *p = tmp;\n-         }\n+\t {\n+\t   tmp = *q;\n+\t   *q = *p;\n+\t   *p = tmp;\n+\t }\n      }\n    Note that:\n      start value = p = &buffer + current_iteration\n@@ -141,7 +141,7 @@ Boston, MA 02111-1307, USA.  */\n \n struct _factor { int factor, count; } factors[NUM_FACTORS]\n   = { {2, 0}, {3, 0}, {5, 0}, {7, 0}};\n-      \n+\n /* Describes the different types of loop unrolling performed.  */\n \n enum unroll_types { UNROLL_COMPLETELY, UNROLL_MODULO, UNROLL_NAIVE };\n@@ -309,7 +309,7 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n   if (loop_dump_stream && loop_info->n_iterations > 0)\n     {\n       fputs (\"Loop unrolling: \", loop_dump_stream);\n-      fprintf (loop_dump_stream, HOST_WIDE_INT_PRINT_DEC, \n+      fprintf (loop_dump_stream, HOST_WIDE_INT_PRINT_DEC,\n \t       loop_info->n_iterations);\n       fputs (\" iterations.\\n\", loop_dump_stream);\n     }\n@@ -899,7 +899,7 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \t  /* Calculate the difference between the final and initial values.\n \t     Final value may be a (plus (reg x) (const_int 1)) rtx.\n \t     Let the following cse pass simplify this if initial value is\n-\t     a constant. \n+\t     a constant.\n \n \t     We must copy the final and initial values here to avoid\n \t     improperly shared rtl.  */\n@@ -929,7 +929,7 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \n \t  if (loop_info->comparison_code != NE)\n \t    {\n-\t      emit_cmp_and_jump_insns (initial_value, final_value, \n+\t      emit_cmp_and_jump_insns (initial_value, final_value,\n \t\t\t\t       neg_inc ? LE : GE,\n \t\t\t\t       NULL_RTX, mode, 0, 0, labels[1]);\n \t      JUMP_LABEL (get_last_insn ()) = labels[1];\n@@ -987,7 +987,7 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \t     For the negative increment case, the branch here could easily\n \t     be merged with the `0' case branch above.  For the positive\n \t     increment case, it is not clear how this can be simplified.  */\n-\t     \n+\n \t  if (abs_inc != 1)\n \t    {\n \t      int cmp_const;\n@@ -1013,7 +1013,7 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \t  sequence = gen_sequence ();\n \t  end_sequence ();\n \t  emit_insn_before (sequence, loop_start);\n-\t  \n+\n \t  /* Only the last copy of the loop body here needs the exit\n \t     test, so set copy_end to exclude the compare/branch here,\n \t     and then reset it inside the loop when get to the last\n@@ -1213,7 +1213,7 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \t{\n \t  insn = PREV_INSN (copy_start);\n \t  pattern = PATTERN (insn);\n-\t  \n+\n \t  tem = get_label_from_map (map,\n \t\t\t\t    CODE_LABEL_NUMBER\n \t\t\t\t    (XEXP (SET_SRC (pattern), 0)));\n@@ -1244,7 +1244,7 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n   else\n     safety_label = emit_label_after (gen_label_rtx (), copy_end);\n \n-  /* Delete all of the original loop instructions.  Don't delete the \n+  /* Delete all of the original loop instructions.  Don't delete the\n      LOOP_BEG note, or the first code label in the loop.  */\n \n   insn = NEXT_INSN (copy_start);\n@@ -1404,7 +1404,7 @@ precondition_loop_p (loop_start, loop_info,\n      such as \"while (i-- > 0)\", the initial value will be one too small.\n      In this case, loop_iteration_var could be used to determine\n      the correct initial value, provided the loop has not been reversed.\n-     \n+\n      Also note that the absolute values of initial_value and\n      final_value are unimportant as only their difference is used for\n      calculating the number of loop iterations.  */\n@@ -1488,7 +1488,7 @@ calculate_giv_inc (pattern, src_insn, regno)\n       pattern = PATTERN (src_insn);\n       if (GET_CODE (SET_SRC (pattern)) != PLUS)\n \tabort ();\n-\t\t  \n+\n       /* The last insn emitted is not needed, so delete it to avoid confusing\n \t the second cse pass.  This insn sets the giv unnecessarily.  */\n       delete_insn (get_last_insn ());\n@@ -1512,11 +1512,11 @@ calculate_giv_inc (pattern, src_insn, regno)\n       /* Some ports store large constants in memory and add a REG_EQUAL\n \t note to the store insn.  */\n       else if (GET_CODE (increment) == MEM)\n-        {\n-          rtx note = find_reg_note (src_insn, REG_EQUAL, 0);\n-          if (note)\n-            increment = XEXP (note, 0);\n-        }\n+\t{\n+\t  rtx note = find_reg_note (src_insn, REG_EQUAL, 0);\n+\t  if (note)\n+\t    increment = XEXP (note, 0);\n+\t}\n \n       else if (GET_CODE (increment) == IOR\n \t       || GET_CODE (increment) == ASHIFT\n@@ -1546,7 +1546,7 @@ calculate_giv_inc (pattern, src_insn, regno)\n \n       if (GET_CODE (increment) != CONST_INT)\n \tabort ();\n-\t\t  \n+\n       /* The insn loading the constant into a register is no longer needed,\n \t so delete it.  */\n       delete_insn (get_last_insn ());\n@@ -1630,7 +1630,7 @@ final_reg_note_copy (notes, map)\n \n /* Copy each instruction in the loop, substituting from map as appropriate.\n    This is very similar to a loop in expand_inline_function.  */\n-  \n+\n static void\n copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t\tunroll_type, start_label, loop_end, insert_before,\n@@ -1661,46 +1661,46 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n     {\n       final_label = gen_label_rtx ();\n       set_label_in_map (map, CODE_LABEL_NUMBER (start_label),\n-\t\t\tfinal_label); \n+\t\t\tfinal_label);\n     }\n   else\n     set_label_in_map (map, CODE_LABEL_NUMBER (start_label), start_label);\n \n   start_sequence ();\n-  \n+\n   insn = copy_start;\n   do\n     {\n       insn = NEXT_INSN (insn);\n-      \n+\n       map->orig_asm_operands_vector = 0;\n-      \n+\n       switch (GET_CODE (insn))\n \t{\n \tcase INSN:\n \t  pattern = PATTERN (insn);\n \t  copy = 0;\n \t  giv_inc = 0;\n-\t  \n+\n \t  /* Check to see if this is a giv that has been combined with\n-\t     some split address givs.  (Combined in the sense that \n+\t     some split address givs.  (Combined in the sense that\n \t     `combine_givs' in loop.c has put two givs in the same register.)\n \t     In this case, we must search all givs based on the same biv to\n \t     find the address givs.  Then split the address givs.\n \t     Do this before splitting the giv, since that may map the\n \t     SET_DEST to a new register.  */\n-\t  \n+\n \t  if ((set = single_set (insn))\n \t      && GET_CODE (SET_DEST (set)) == REG\n \t      && addr_combined_regs[REGNO (SET_DEST (set))])\n \t    {\n \t      struct iv_class *bl;\n \t      struct induction *v, *tv;\n \t      int regno = REGNO (SET_DEST (set));\n-\t      \n+\n \t      v = addr_combined_regs[REGNO (SET_DEST (set))];\n \t      bl = reg_biv_class[REGNO (v->src_reg)];\n-\t      \n+\n \t      /* Although the giv_inc amount is not needed here, we must call\n \t\t calculate_giv_inc here since it might try to delete the\n \t\t last insn emitted.  If we wait until later to call it,\n@@ -1727,24 +1727,24 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t\t    if (tv->mult_val != v->mult_val)\n \t\t      this_giv_inc = (this_giv_inc / INTVAL (v->mult_val)\n \t\t\t\t      * INTVAL (tv->mult_val));\n-\t\t       \n+\n \t\t    tv->dest_reg = plus_constant (tv->dest_reg, this_giv_inc);\n \t\t    *tv->location = tv->dest_reg;\n-\t\t    \n+\n \t\t    if (last_iteration && unroll_type != UNROLL_COMPLETELY)\n \t\t      {\n \t\t\t/* Must emit an insn to increment the split address\n \t\t\t   giv.  Add in the const_adjust field in case there\n \t\t\t   was a constant eliminated from the address.  */\n \t\t\trtx value, dest_reg;\n-\t\t\t\n+\n \t\t\t/* tv->dest_reg will be either a bare register,\n \t\t\t   or else a register plus a constant.  */\n \t\t\tif (GET_CODE (tv->dest_reg) == REG)\n \t\t\t  dest_reg = tv->dest_reg;\n \t\t\telse\n \t\t\t  dest_reg = XEXP (tv->dest_reg, 0);\n-\t\t\t\n+\n \t\t\t/* Check for shared address givs, and avoid\n \t\t\t   incrementing the shared pseudo reg more than\n \t\t\t   once.  */\n@@ -1763,7 +1763,7 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t\t\t    emit_unrolled_add (dest_reg, XEXP (value, 0),\n \t\t\t\t\t       XEXP (value, 1));\n \t\t\t  }\n-\t\t\t\n+\n \t\t\t/* Reset the giv to be just the register again, in case\n \t\t\t   it is used after the set we have just emitted.\n \t\t\t   We must subtract the const_adjust factor added in\n@@ -1774,23 +1774,23 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t\t      }\n \t\t  }\n \t    }\n-\t  \n+\n \t  /* If this is a setting of a splittable variable, then determine\n \t     how to split the variable, create a new set based on this split,\n \t     and set up the reg_map so that later uses of the variable will\n \t     use the new split variable.  */\n-\t  \n+\n \t  dest_reg_was_split = 0;\n-\t  \n+\n \t  if ((set = single_set (insn))\n \t      && GET_CODE (SET_DEST (set)) == REG\n \t      && splittable_regs[REGNO (SET_DEST (set))])\n \t    {\n \t      int regno = REGNO (SET_DEST (set));\n \t      int src_regno;\n-\t      \n+\n \t      dest_reg_was_split = 1;\n-\t      \n+\n \t      giv_dest_reg = SET_DEST (set);\n \t      if (derived_regs[regno])\n \t\t{\n@@ -1815,7 +1815,7 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t\t{\n \t\t  /* Completely unrolling the loop.  Set the induction\n \t\t     variable to a known constant value.  */\n-\t\t  \n+\n \t\t  /* The value in splittable_regs may be an invariant\n \t\t     value, so we must use plus_constant here.  */\n \t\t  splittable_regs[regno]\n@@ -1843,7 +1843,7 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t\t     be a constant plus the original register.  Except\n \t\t     on the last iteration, when the result has to\n \t\t     go back into the original iteration var register.  */\n-\t\t  \n+\n \t\t  /* Handle bivs which must be mapped to a new register\n \t\t     when split.  This happens for bivs which need their\n \t\t     final value set before loop entry.  The new register\n@@ -1856,18 +1856,18 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t\t      giv_src_reg = reg_biv_class[regno]->biv->src_reg;\n \t\t      giv_dest_reg = giv_src_reg;\n \t\t    }\n-\t\t  \n+\n #if 0\n \t\t  /* If non-reduced/final-value givs were split, then\n \t\t     this would have to remap those givs also.  See\n \t\t     find_splittable_regs.  */\n #endif\n-\t\t  \n+\n \t\t  splittable_regs[regno]\n \t\t    = GEN_INT (INTVAL (giv_inc)\n \t\t\t       + INTVAL (splittable_regs[src_regno]));\n \t\t  giv_inc = splittable_regs[regno];\n-\t\t  \n+\n \t\t  /* Now split the induction variable by changing the dest\n \t\t     of this insn to a new register, and setting its\n \t\t     reg_map entry to point to this new register.\n@@ -1911,7 +1911,7 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t      copy = emit_insn (pattern);\n \t    }\n \t  REG_NOTES (copy) = initial_reg_note_copy (REG_NOTES (insn), map);\n-\t  \n+\n #ifdef HAVE_cc0\n \t  /* If this insn is setting CC0, it may need to look at\n \t     the insn that uses CC0 to see what type of insn it is.\n@@ -1952,7 +1952,7 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t\tVARRAY_CONST_EQUIV (map->const_equiv_varray, regno).age = -1;\n \t    }\n \t  break;\n-\t  \n+\n \tcase JUMP_INSN:\n \t  pattern = copy_rtx_and_substitute (PATTERN (insn), map);\n \t  copy = emit_jump_insn (pattern);\n@@ -1996,7 +1996,7 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t\t    abort ();\n \t\t}\n \t    }\n-\t  \n+\n #ifdef HAVE_cc0\n \t  if (cc0_insn)\n \t    try_constants (cc0_insn, map);\n@@ -2034,10 +2034,10 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t\t     for a switch statement.  This label must have been mapped,\n \t\t     so just use the label_map to get the new jump label.  */\n \t\t  JUMP_LABEL (copy)\n-\t\t    = get_label_from_map (map, \n-\t\t\t\t\t  CODE_LABEL_NUMBER (JUMP_LABEL (insn))); \n+\t\t    = get_label_from_map (map,\n+\t\t\t\t\t  CODE_LABEL_NUMBER (JUMP_LABEL (insn)));\n \t\t}\n-\t  \n+\n \t      /* If this is a non-local jump, then must increase the label\n \t\t use count so that the label will not be deleted when the\n \t\t original jump is deleted.  */\n@@ -2084,7 +2084,7 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t\temit_barrier ();\n \t    }\n \t  break;\n-\t  \n+\n \tcase CALL_INSN:\n \t  pattern = copy_rtx_and_substitute (PATTERN (insn), map);\n \t  copy = emit_call_insn (pattern);\n@@ -2106,7 +2106,7 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \t    VARRAY_CONST_EQUIV (map->const_equiv_varray, i).rtx = 0;\n \t  break;\n-\t  \n+\n \tcase CODE_LABEL:\n \t  /* If this is the loop start label, then we don't need to emit a\n \t     copy of this label since no one will use it.  */\n@@ -2118,15 +2118,15 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t      map->const_age++;\n \t    }\n \t  break;\n-\t  \n+\n \tcase BARRIER:\n \t  copy = emit_barrier ();\n \t  break;\n-\t  \n+\n \tcase NOTE:\n \t  /* VTOP notes are valid only before the loop exit test.  If placed\n \t     anywhere else, loop may generate bad code.  */\n-\t     \n+\n \t  if (NOTE_LINE_NUMBER (insn) != NOTE_INSN_DELETED\n \t      && (NOTE_LINE_NUMBER (insn) != NOTE_INSN_LOOP_VTOP\n \t\t  || (last_iteration && unroll_type != UNROLL_COMPLETELY)))\n@@ -2135,16 +2135,16 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t  else\n \t    copy = 0;\n \t  break;\n-\t  \n+\n \tdefault:\n \t  abort ();\n \t  break;\n \t}\n-      \n+\n       map->insn_map[INSN_UID (insn)] = copy;\n     }\n   while (insn != copy_end);\n-  \n+\n   /* Now finish coping the REG_NOTES.  */\n   insn = copy_start;\n   do\n@@ -2239,7 +2239,7 @@ back_branch_in_range_p (insn, loop_start, loop_end)\n       if (GET_CODE (p) == JUMP_INSN)\n \t{\n \t  target_insn = JUMP_LABEL (p);\n-\t  \n+\n \t  /* Search from loop_start to insn, to see if one of them is\n \t     the target_insn.  We can't use INSN_LUID comparisons here,\n \t     since insn may not have an LUID entry.  */\n@@ -2305,7 +2305,7 @@ fold_rtx_mult_add (mult1, mult2, add1, mode)\n    Returns the increment value as an rtx, simplified as much as possible,\n    if it can be calculated.  Otherwise, returns 0.  */\n \n-rtx \n+rtx\n biv_total_increment (bl, loop_start, loop_end)\n      struct iv_class *bl;\n      rtx loop_start, loop_end;\n@@ -2416,7 +2416,7 @@ iteration_info (iteration_var, initial_value, increment, loop_start, loop_end)\n       bl = reg_biv_class[REGNO (v->src_reg)];\n       *initial_value = fold_rtx_mult_add (v->mult_val, bl->initial_value,\n \t\t\t\t\t  v->add_val, v->mode);\n-      \n+\n       /* Increment value is mult_val times the increment value of the biv.  */\n \n       *increment = biv_total_increment (bl, loop_start, loop_end);\n@@ -2694,7 +2694,7 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t  && (! v->always_computable\n \t      || back_branch_in_range_p (v->insn, loop_start, loop_end)))\n \tcontinue;\n-      \n+\n       /* The giv increment value must be a constant.  */\n       giv_inc = fold_rtx_mult_add (v->mult_val, increment, const0_rtx,\n \t\t\t\t   v->mode);\n@@ -2706,7 +2706,7 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t the loop, or else the final value of the giv must be known.\n \t Otherwise, it is not safe to split the giv since it may not have the\n \t proper value on loop exit.  */\n-\t  \n+\n       /* The used outside loop test will fail for DEST_ADDR givs.  They are\n \t never used outside the loop anyways, so it is always safe to split a\n \t DEST_ADDR giv.  */\n@@ -2754,11 +2754,11 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t  emit_insn_before (gen_move_insn (tem, v->dest_reg), loop_start);\n \t  emit_insn_before (gen_move_insn (v->dest_reg, final_value),\n \t\t\t    loop_start);\n-\t  \n+\n \t  if (loop_dump_stream)\n \t    fprintf (loop_dump_stream, \"Giv %d mapped to %d for split.\\n\",\n \t\t     REGNO (v->dest_reg), REGNO (tem));\n-\t  \n+\n \t  v->src_reg = tem;\n \t}\n #endif\n@@ -2832,7 +2832,7 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t\t\t\t    v->add_val, tem, loop_start);\n \t\t  value = tem;\n \t\t}\n-\t\t\n+\n \t      splittable_regs[REGNO (v->new_reg)] = value;\n \t      derived_regs[REGNO (v->new_reg)] = v->derived_from != 0;\n \t    }\n@@ -2914,7 +2914,7 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t\t  /* If the address giv has a constant in its new_reg value,\n \t\t     then this constant can be pulled out and put in value,\n \t\t     instead of being part of the initialization code.  */\n-\t\t  \n+\n \t\t  if (GET_CODE (new_reg) == PLUS\n \t\t      && GET_CODE (XEXP (new_reg, 1)) == CONST_INT)\n \t\t    {\n@@ -2943,7 +2943,7 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t\t    }\n \t\t  else\n \t\t    v->dest_reg = tem;\n-\t\t  \n+\n \t\t  /* If the address hasn't been checked for validity yet, do so\n \t\t     now, and fail completely if either the first or the last\n \t\t     unrolled copy of the address is not a valid address\n@@ -2964,7 +2964,7 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \n \t\t  v->new_reg = new_reg;\n \t\t  v->same = same;\n-\t\t  \n+\n \t\t  /* We set this after the address check, to guarantee that\n \t\t     the register will be initialized.  */\n \t\t  v->unrolled = 1;\n@@ -3003,7 +3003,7 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t      else\n \t\t{\n \t\t  v->dest_reg = value;\n-\t\t  \n+\n \t\t  /* Check the resulting address for validity, and fail\n \t\t     if the resulting address would be invalid.  */\n \t\t  if (! verify_addresses (v, giv_inc, unroll_number))\n@@ -3028,29 +3028,29 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t\t    }\n \n \t\t}\n-\t      \n+\n \t      /* Store the value of dest_reg into the insn.  This sharing\n \t\t will not be a problem as this insn will always be copied\n \t\t later.  */\n-\t      \n+\n \t      *v->location = v->dest_reg;\n-\t      \n+\n \t      /* If this address giv is combined with a dest reg giv, then\n \t\t save the base giv's induction pointer so that we will be\n \t\t able to handle this address giv properly.  The base giv\n \t\t itself does not have to be splittable.  */\n-\t      \n+\n \t      if (v->same && v->same->giv_type == DEST_REG)\n \t\taddr_combined_regs[REGNO (v->same->new_reg)] = v->same;\n-\t      \n+\n \t      if (GET_CODE (v->new_reg) == REG)\n \t\t{\n \t\t  /* This giv maybe hasn't been combined with any others.\n \t\t     Make sure that it's giv is marked as splittable here.  */\n-\t\t  \n+\n \t\t  splittable_regs[REGNO (v->new_reg)] = value;\n \t\t  derived_regs[REGNO (v->new_reg)] = v->derived_from != 0;\n-\t\t  \n+\n \t\t  /* Make it appear to depend upon itself, so that the\n \t\t     giv will be properly split in the main loop above.  */\n \t\t  if (! v->same)\n@@ -3073,15 +3073,15 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t     it makes sense to reduce&split givs when possible, as this will\n \t     result in simpler instructions, and will not require that a reg\n \t     be live across loop iterations.  */\n-\t  \n+\n \t  splittable_regs[REGNO (v->dest_reg)] = value;\n \t  fprintf (stderr, \"Giv %d at insn %d not reduced\\n\",\n \t\t   REGNO (v->dest_reg), INSN_UID (v->insn));\n #else\n \t  continue;\n #endif\n \t}\n-      \n+\n       /* Unreduced givs are only updated once by definition.  Reduced givs\n \t are updated as many times as their biv is.  Mark it so if this is\n \t a splittable register.  Don't need to do anything for address givs\n@@ -3102,11 +3102,11 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t}\n \n       result++;\n-      \n+\n       if (loop_dump_stream)\n \t{\n \t  int regnum;\n-\t  \n+\n \t  if (GET_CODE (v->dest_reg) == CONST_INT)\n \t    regnum = -1;\n \t  else if (GET_CODE (v->dest_reg) != REG)\n@@ -3143,7 +3143,7 @@ reg_dead_after_loop (reg, loop_start, loop_end)\n      all exits of inner nested loops that would exit this loop.  We don't\n      have any way to identify those, so we just give up if there are any\n      such inner loop exits.  */\n-     \n+\n   for (label = loop_number_exit_labels[this_loop_num]; label;\n        label = LABEL_NEXTREF (label))\n     label_count++;\n@@ -3201,7 +3201,7 @@ reg_dead_after_loop (reg, loop_start, loop_end)\n \n /* Try to calculate the final value of the biv, the value it will have at\n    the end of the loop.  If we can do it, return that value.  */\n-  \n+\n rtx\n final_biv_value (bl, loop_start, loop_end, n_iterations)\n      struct iv_class *bl;\n@@ -3224,7 +3224,7 @@ final_biv_value (bl, loop_start, loop_end, n_iterations)\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream,\n \t\t \"Final biv value for %d, reversed biv.\\n\", bl->regno);\n-\t\t \n+\n       return const0_rtx;\n     }\n \n@@ -3239,7 +3239,7 @@ final_biv_value (bl, loop_start, loop_end, n_iterations)\n       && invariant_p (bl->initial_value))\n     {\n       increment = biv_total_increment (bl, loop_start, loop_end);\n-      \n+\n       if (increment && invariant_p (increment))\n \t{\n \t  /* Can calculate the loop exit value, emit insns after loop\n@@ -3257,7 +3257,7 @@ final_biv_value (bl, loop_start, loop_end, n_iterations)\n \t  if (loop_dump_stream)\n \t    fprintf (loop_dump_stream,\n \t\t     \"Final biv value for %d, calculated.\\n\", bl->regno);\n-\t  \n+\n \t  return tem;\n \t}\n     }\n@@ -3308,7 +3308,7 @@ final_giv_value (v, loop_start, loop_end, n_iterations)\n   /* Try to calculate the final value as a function of the biv it depends\n      upon.  The only exit from the loop must be the fall through at the bottom\n      (otherwise it may not have its final value when the loop exits).  */\n-      \n+\n   /* ??? Can calculate the final giv value by subtracting off the\n      extra biv increments times the giv's mult_val.  The loop must have\n      only one exit for this to work, but the loop iterations does not need\n@@ -3335,7 +3335,7 @@ final_giv_value (v, loop_start, loop_end, n_iterations)\n \t{\n \t  /* Can calculate the loop exit value of its biv as\n \t     (n_iterations * increment) + initial_value */\n-\t      \n+\n \t  /* The loop exit value of the giv is then\n \t     (final_biv_value - extra increments) * mult_val + add_val.\n \t     The extra increments are any increments to the biv which\n@@ -3369,11 +3369,11 @@ final_giv_value (v, loop_start, loop_end, n_iterations)\n \t\t    emit_insn_before (seq, insert_before);\n \t\t  }\n \t    }\n-\t  \n+\n \t  /* Now calculate the giv's final value.  */\n \t  emit_iv_add_mult (tem, v->mult_val, v->add_val, tem,\n \t\t\t    insert_before);\n-\t  \n+\n \t  if (loop_dump_stream)\n \t    fprintf (loop_dump_stream,\n \t\t     \"Final giv value for %d, calc from biv's value.\\n\",\n@@ -3413,13 +3413,13 @@ loop_find_equiv_value (loop_start, reg)\n {\n   rtx insn, set;\n   rtx ret;\n-  \n+\n   ret = reg;\n   for (insn = PREV_INSN (loop_start); insn ; insn = PREV_INSN (insn))\n     {\n       if (GET_CODE (insn) == CODE_LABEL)\n \tbreak;\n-      \n+\n       else if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n \t       && reg_set_p (reg, insn))\n \t{\n@@ -3430,7 +3430,7 @@ loop_find_equiv_value (loop_start, reg)\n \t\t  && (SET_DEST (set) == reg))\n \t    {\n \t      rtx note = find_reg_note (insn, REG_EQUAL, NULL_RTX);\n-\t      \n+\n \t      /* Only use the REG_EQUAL note if it is a constant.\n \t\t Other things, divide in particular, will cause\n \t\t problems later if we use them.  */\n@@ -3551,7 +3551,7 @@ loop_iterations (loop_start, loop_end, loop_info)\n   last_loop_insn = PREV_INSN (loop_end);\n \n   /* ??? We should probably try harder to find the jump insn\n-     at the end of the loop.  The following code assumes that \n+     at the end of the loop.  The following code assumes that\n      the last loop insn is a jump to the top of the loop.  */\n   if (GET_CODE (last_loop_insn) != JUMP_INSN)\n     {\n@@ -3574,7 +3574,7 @@ loop_iterations (loop_start, loop_end, loop_info)\n   /* Find the iteration variable.  If the last insn is a conditional\n      branch, and the insn before tests a register value, make that the\n      iteration variable.  */\n-  \n+\n   comparison = get_condition_for_loop (last_loop_insn);\n   if (comparison == 0)\n     {\n@@ -3590,7 +3590,7 @@ loop_iterations (loop_start, loop_end, loop_info)\n   comparison_code = GET_CODE (comparison);\n   iteration_var = XEXP (comparison, 0);\n   comparison_value = XEXP (comparison, 1);\n-  \n+\n   /* Check if there is a NOTE_INSN_LOOP_VTOP note.  If there is,\n      that means that this is a for or while style loop, with\n      a loop exit test at the start.  Thus, we can assume that\n@@ -3694,7 +3694,7 @@ loop_iterations (loop_start, loop_end, loop_info)\n   /* Save the calculated values describing this loop's bounds, in case\n      precondition_loop_p will need them later.  These values can not be\n      recalculated inside precondition_loop_p because strength reduction\n-     optimizations may obscure the loop's structure.  \n+     optimizations may obscure the loop's structure.\n \n      These values are only required by precondition_loop_p and insert_bct\n      whenever the number of iterations cannot be computed at compile time.\n@@ -3769,7 +3769,7 @@ loop_iterations (loop_start, loop_end, loop_info)\n \t    }\n \t}\n     }\n-  \n+\n   /* If have initial_value = reg + const1 and final_value = reg +\n      const2, then replace initial_value with const1 and final_value\n      with const2.  This should be safe since we are protected by the\n@@ -3779,7 +3779,7 @@ loop_iterations (loop_start, loop_end, loop_info)\n \n      ??? Without a vtop we could still perform the optimization if we check\n      the initial and final values carefully.  */\n-  if (loop_info->vtop \n+  if (loop_info->vtop\n       && (reg_term = find_common_reg_term (initial_value, final_value)))\n     {\n       initial_value = subtract_reg_term (initial_value, reg_term);\n@@ -3788,7 +3788,7 @@ loop_iterations (loop_start, loop_end, loop_info)\n \n   loop_info->initial_equiv_value = initial_value;\n   loop_info->final_equiv_value = final_value;\n-  \n+\n   if (increment == 0)\n     {\n       if (loop_dump_stream)\n@@ -3869,7 +3869,7 @@ loop_iterations (loop_start, loop_end, loop_info)\n      will overflow before the loop exits), 4 infinite loop cases, and 15\n      immediate exit (0 or 1 iteration depending on loop type) cases.\n      Only try to optimize the normal cases.  */\n-     \n+\n   /* (compare_dir/final_larger/increment_dir)\n      Normal cases: (0/-1/-1), (0/1/1), (-1/-1/-1), (1/1/1)\n      Reverse cases: (0/-1/1), (0/1/-1), (-1/-1/1), (1/1/-1)\n@@ -3969,7 +3969,7 @@ remap_split_bivs (x)\n \t  && REG_IV_TYPE (REGNO (x)) == BASIC_INDUCT)\n \treturn reg_biv_class[REGNO (x)]->biv->src_reg;\n       break;\n-      \n+\n     default:\n       break;\n     }"}]}