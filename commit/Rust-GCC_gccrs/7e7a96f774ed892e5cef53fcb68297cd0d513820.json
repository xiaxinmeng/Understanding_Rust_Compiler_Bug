{"sha": "7e7a96f774ed892e5cef53fcb68297cd0d513820", "node_id": "C_kwDOANBUbNoAKDdlN2E5NmY3NzRlZDg5MmU1Y2VmNTNmY2I2ODI5N2NkMGQ1MTM4MjA", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-04-07T20:09:52Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-04-07T20:09:52Z"}, "message": "c++: use after free during name lookup w/ modules [PR99479]\n\nname_lookup::search_unqualified uses a statically allocated vector\nin order to avoid repeated reallocation, under the assumption that\nthe function can't be called recursively.  With modules however,\nthis assumption turns out to be false, and search_unqualified can\nbe called recursively as demonstrated by the testcase in comment #19\nof PR99479[1] where the recursive call causes the vector to get\nreallocated which invalidates the reference to queue[ix] held by the\nparent call.\n\nThis patch makes search_unqualified instead use an auto_vec with 16\nelements of internal storage.  In turn we can simplify the API of some\nmember functions to take the vector by reference and return void.\n\n[1]: https://gcc.gnu.org/PR99479#c19\n\n\tPR c++/99479\n\ngcc/cp/ChangeLog:\n\n\t* name-lookup.cc (name_lookup::using_queue): Change to an\n\tauto_vec (with 16 elements of internal storage).\n\t(name_lookup::queue_namespace): Change return type to void,\n\ttake queue parameter by reference and adjust function body\n\taccordingly.\n\t(name_lookup::do_queue_usings): Inline into ...\n\t(name_lookup::queue_usings): ... here.  As in queue_namespace.\n\t(name_lookup::search_unqualified): Don't make queue static,\n\tremove length variable, and adjust function body accordingly.", "tree": {"sha": "7eef610c8bfe63d65210d0fa1dbc00bffdc5064f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7eef610c8bfe63d65210d0fa1dbc00bffdc5064f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e7a96f774ed892e5cef53fcb68297cd0d513820", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e7a96f774ed892e5cef53fcb68297cd0d513820", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e7a96f774ed892e5cef53fcb68297cd0d513820", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e7a96f774ed892e5cef53fcb68297cd0d513820/comments", "author": null, "committer": null, "parents": [{"sha": "68163cc2de1d3125ed9dbb8eac3294d1f9118641", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68163cc2de1d3125ed9dbb8eac3294d1f9118641", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68163cc2de1d3125ed9dbb8eac3294d1f9118641"}], "stats": {"total": 62, "additions": 22, "deletions": 40}, "files": [{"sha": "b7fc2781d53af387c0ad91102fffb5cad394525f", "filename": "gcc/cp/name-lookup.cc", "status": "modified", "additions": 22, "deletions": 40, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e7a96f774ed892e5cef53fcb68297cd0d513820/gcc%2Fcp%2Fname-lookup.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e7a96f774ed892e5cef53fcb68297cd0d513820/gcc%2Fcp%2Fname-lookup.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.cc?ref=7e7a96f774ed892e5cef53fcb68297cd0d513820", "patch": "@@ -429,7 +429,7 @@ class name_lookup\n {\n public:\n   typedef std::pair<tree, tree> using_pair;\n-  typedef vec<using_pair, va_heap, vl_embed> using_queue;\n+  typedef auto_vec<using_pair, 16> using_queue;\n \n public:\n   tree name;\t/* The identifier being looked for.  */\n@@ -528,16 +528,8 @@ class name_lookup\n   bool search_usings (tree scope);\n \n private:\n-  using_queue *queue_namespace (using_queue *queue, int depth, tree scope);\n-  using_queue *do_queue_usings (using_queue *queue, int depth,\n-\t\t\t\tvec<tree, va_gc> *usings);\n-  using_queue *queue_usings (using_queue *queue, int depth,\n-\t\t\t     vec<tree, va_gc> *usings)\n-  {\n-    if (usings)\n-      queue = do_queue_usings (queue, depth, usings);\n-    return queue;\n-  }\n+  void queue_namespace (using_queue& queue, int depth, tree scope);\n+  void queue_usings (using_queue& queue, int depth, vec<tree, va_gc> *usings);\n \n private:\n   void add_fns (tree);\n@@ -1084,39 +1076,35 @@ name_lookup::search_qualified (tree scope, bool usings)\n /* Add SCOPE to the unqualified search queue, recursively add its\n    inlines and those via using directives.  */\n \n-name_lookup::using_queue *\n-name_lookup::queue_namespace (using_queue *queue, int depth, tree scope)\n+void\n+name_lookup::queue_namespace (using_queue& queue, int depth, tree scope)\n {\n   if (see_and_mark (scope))\n-    return queue;\n+    return;\n \n   /* Record it.  */\n   tree common = scope;\n   while (SCOPE_DEPTH (common) > depth)\n     common = CP_DECL_CONTEXT (common);\n-  vec_safe_push (queue, using_pair (common, scope));\n+  queue.safe_push (using_pair (common, scope));\n \n   /* Queue its inline children.  */\n   if (vec<tree, va_gc> *inlinees = DECL_NAMESPACE_INLINEES (scope))\n     for (unsigned ix = inlinees->length (); ix--;)\n-      queue = queue_namespace (queue, depth, (*inlinees)[ix]);\n+      queue_namespace (queue, depth, (*inlinees)[ix]);\n \n   /* Queue its using targets.  */\n-  queue = queue_usings (queue, depth, NAMESPACE_LEVEL (scope)->using_directives);\n-\n-  return queue;\n+  queue_usings (queue, depth, NAMESPACE_LEVEL (scope)->using_directives);\n }\n \n /* Add the namespaces in USINGS to the unqualified search queue.  */\n \n-name_lookup::using_queue *\n-name_lookup::do_queue_usings (using_queue *queue, int depth,\n-\t\t\t      vec<tree, va_gc> *usings)\n+void\n+name_lookup::queue_usings (using_queue& queue, int depth, vec<tree, va_gc> *usings)\n {\n-  for (unsigned ix = usings->length (); ix--;)\n-    queue = queue_namespace (queue, depth, (*usings)[ix]);\n-\n-  return queue;\n+  if (usings)\n+    for (unsigned ix = usings->length (); ix--;)\n+      queue_namespace (queue, depth, (*usings)[ix]);\n }\n \n /* Unqualified namespace lookup in SCOPE.\n@@ -1128,43 +1116,40 @@ name_lookup::do_queue_usings (using_queue *queue, int depth,\n bool\n name_lookup::search_unqualified (tree scope, cp_binding_level *level)\n {\n-  /* Make static to avoid continual reallocation.  We're not\n-     recursive.  */\n-  static using_queue *queue = NULL;\n+  using_queue queue;\n   bool found = false;\n-  int length = vec_safe_length (queue);\n \n   /* Queue local using-directives.  */\n   for (; level->kind != sk_namespace; level = level->level_chain)\n-    queue = queue_usings (queue, SCOPE_DEPTH (scope), level->using_directives);\n+    queue_usings (queue, SCOPE_DEPTH (scope), level->using_directives);\n \n   for (; !found; scope = CP_DECL_CONTEXT (scope))\n     {\n       gcc_assert (!DECL_NAMESPACE_ALIAS (scope));\n       int depth = SCOPE_DEPTH (scope);\n \n       /* Queue namespaces reachable from SCOPE. */\n-      queue = queue_namespace (queue, depth, scope);\n+      queue_namespace (queue, depth, scope);\n \n       /* Search every queued namespace where SCOPE is the common\n \t ancestor.  Adjust the others.  */\n-      unsigned ix = length;\n+      unsigned ix = 0;\n       do\n \t{\n-\t  using_pair &pair = (*queue)[ix];\n+\t  using_pair &pair = queue[ix];\n \t  while (pair.first == scope)\n \t    {\n \t      found |= search_namespace_only (pair.second);\n-\t      pair = queue->pop ();\n-\t      if (ix == queue->length ())\n+\t      pair = queue.pop ();\n+\t      if (ix == queue.length ())\n \t\tgoto done;\n \t    }\n \t  /* The depth is the same as SCOPE, find the parent scope.  */\n \t  if (SCOPE_DEPTH (pair.first) == depth)\n \t    pair.first = CP_DECL_CONTEXT (pair.first);\n \t  ix++;\n \t}\n-      while (ix < queue->length ());\n+      while (ix < queue.length ());\n     done:;\n       if (scope == global_namespace)\n \tbreak;\n@@ -1181,9 +1166,6 @@ name_lookup::search_unqualified (tree scope, cp_binding_level *level)\n \n   dedup (false);\n \n-  /* Restore to incoming length.  */\n-  vec_safe_truncate (queue, length);\n-\n   return found;\n }\n "}]}