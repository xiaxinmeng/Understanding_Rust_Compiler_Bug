{"sha": "82f620e2ba4c440c5e89bb1f73d10a11ed0f2eb4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODJmNjIwZTJiYTRjNDQwYzVlODliYjFmNzNkMTBhMTFlZDBmMmViNA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2020-03-13T08:16:29Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2020-03-13T08:21:42Z"}, "message": "Fix unaligned load with small memcpy on the ARM\n\nstore_integral_bit_field is ready to handle BLKmode fields, there is\neven a subtlety with their handling on big-endian targets, see e.g.\nPR middle-end/50325, but not if they are unaligned, so the fix is\nsimply to call extract_bit_field for them in order to generate an\nunaligned load.  As a bonus, this subsumes  the big-endian specific\npath that was added under PR middle-end/50325.\n\n\tPR middle-end/92071\n\t* expmed.c (store_integral_bit_field): For fields larger than a\n\tword, call extract_bit_field on the value if the mode is BLKmode.\n\tRemove specific path for big-endian targets and tidy things up a\n\tlittle bit.", "tree": {"sha": "7aebe15ddd0a4439c4897b7cabb05a32fe6e796a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7aebe15ddd0a4439c4897b7cabb05a32fe6e796a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82f620e2ba4c440c5e89bb1f73d10a11ed0f2eb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82f620e2ba4c440c5e89bb1f73d10a11ed0f2eb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82f620e2ba4c440c5e89bb1f73d10a11ed0f2eb4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82f620e2ba4c440c5e89bb1f73d10a11ed0f2eb4/comments", "author": null, "committer": null, "parents": [{"sha": "54e69cb00da0b50e4fa228a0617e4e8713bbc998", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54e69cb00da0b50e4fa228a0617e4e8713bbc998", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54e69cb00da0b50e4fa228a0617e4e8713bbc998"}], "stats": {"total": 80, "additions": 50, "deletions": 30}, "files": [{"sha": "7b573c07abc38865fcd2c798a34e6ba90b45823b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82f620e2ba4c440c5e89bb1f73d10a11ed0f2eb4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82f620e2ba4c440c5e89bb1f73d10a11ed0f2eb4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=82f620e2ba4c440c5e89bb1f73d10a11ed0f2eb4", "patch": "@@ -1,3 +1,10 @@\n+2019-03-13  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR middle-end/92071\n+\t* expmed.c (store_integral_bit_field): For fields larger than a word,\n+\tcall extract_bit_field on the value if the mode is BLKmode.  Remove\n+\tspecific path for big-endian targets and tidy things up a little bit.\n+\n 2020-03-12  Richard Sandiford  <richard.sandiford@arm.com>\n \n \tPR rtl-optimization/90275"}, {"sha": "e7c03fbf92c04b46d7697aad96ad2fa14be4e8e1", "filename": "gcc/expmed.c", "status": "modified", "additions": 25, "deletions": 30, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82f620e2ba4c440c5e89bb1f73d10a11ed0f2eb4/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82f620e2ba4c440c5e89bb1f73d10a11ed0f2eb4/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=82f620e2ba4c440c5e89bb1f73d10a11ed0f2eb4", "patch": "@@ -933,8 +933,7 @@ store_integral_bit_field (rtx op0, opt_scalar_int_mode op0_mode,\n \t However, only do that if the value is not BLKmode.  */\n \n       const bool backwards = WORDS_BIG_ENDIAN && fieldmode != BLKmode;\n-      unsigned int nwords = (bitsize + (BITS_PER_WORD - 1)) / BITS_PER_WORD;\n-      unsigned int i;\n+      const int nwords = (bitsize + (BITS_PER_WORD - 1)) / BITS_PER_WORD;\n       rtx_insn *last;\n \n       /* This is the mode we must force value to, so that there will be enough\n@@ -950,35 +949,31 @@ store_integral_bit_field (rtx op0, opt_scalar_int_mode op0_mode,\n \tvalue_mode = smallest_int_mode_for_size (nwords * BITS_PER_WORD);\n \n       last = get_last_insn ();\n-      for (i = 0; i < nwords; i++)\n+      for (int i = 0; i < nwords; i++)\n \t{\n-\t  /* If I is 0, use the low-order word in both field and target;\n-\t     if I is 1, use the next to lowest word; and so on.  */\n-\t  unsigned int wordnum = (backwards\n-\t\t\t\t  ? GET_MODE_SIZE (value_mode) / UNITS_PER_WORD\n-\t\t\t\t  - i - 1\n-\t\t\t\t  : i);\n-\t  unsigned int bit_offset = (backwards ^ reverse\n-\t\t\t\t     ? MAX ((int) bitsize - ((int) i + 1)\n-\t\t\t\t\t    * BITS_PER_WORD,\n-\t\t\t\t\t    0)\n-\t\t\t\t     : (int) i * BITS_PER_WORD);\n-\t  rtx value_word = operand_subword_force (value, wordnum, value_mode);\n-\t  unsigned HOST_WIDE_INT new_bitsize =\n-\t    MIN (BITS_PER_WORD, bitsize - i * BITS_PER_WORD);\n-\n-\t  /* If the remaining chunk doesn't have full wordsize we have\n-\t     to make sure that for big-endian machines the higher order\n-\t     bits are used.  */\n-\t  if (new_bitsize < BITS_PER_WORD && BYTES_BIG_ENDIAN && !backwards)\n-\t    {\n-\t      int shift = BITS_PER_WORD - new_bitsize;\n-\t      rtx shift_rtx = gen_int_shift_amount (word_mode, shift);\n-\t      value_word = simplify_expand_binop (word_mode, lshr_optab,\n-\t\t\t\t\t\t  value_word, shift_rtx,\n-\t\t\t\t\t\t  NULL_RTX, true,\n-\t\t\t\t\t\t  OPTAB_LIB_WIDEN);\n-\t    }\n+\t  /* Number of bits to be stored in this iteration, i.e. BITS_PER_WORD\n+\t     except maybe for the last iteration.  */\n+\t  const unsigned HOST_WIDE_INT new_bitsize\n+\t    = MIN (BITS_PER_WORD, bitsize - i * BITS_PER_WORD);\n+\t  /* Bit offset from the starting bit number in the target.  */\n+\t  const unsigned int bit_offset\n+\t    = backwards ^ reverse\n+\t      ? MAX ((int) bitsize - (i + 1) * BITS_PER_WORD, 0)\n+\t      : i * BITS_PER_WORD;\n+\t  /* Starting word number in the value.  */\n+\t  const unsigned int wordnum\n+\t    = backwards\n+\t      ? GET_MODE_SIZE (value_mode) / UNITS_PER_WORD - (i + 1)\n+\t      : i;\n+\t  /* The chunk of the value in word_mode.  We use bit-field extraction\n+\t      in BLKmode to handle unaligned memory references and to shift the\n+\t      last chunk right on big-endian machines if need be.  */\n+\t  rtx value_word\n+\t    = fieldmode == BLKmode\n+\t      ? extract_bit_field (value, new_bitsize, wordnum * BITS_PER_WORD,\n+\t\t\t\t   1, NULL_RTX, word_mode, word_mode, false,\n+\t\t\t\t   NULL)\n+\t      : operand_subword_force (value, wordnum, value_mode);\n \n \t  if (!store_bit_field_1 (op0, new_bitsize,\n \t\t\t\t  bitnum + bit_offset,"}, {"sha": "e695b9bf26f68a936c3c6b5d1032f9079289d617", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82f620e2ba4c440c5e89bb1f73d10a11ed0f2eb4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82f620e2ba4c440c5e89bb1f73d10a11ed0f2eb4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=82f620e2ba4c440c5e89bb1f73d10a11ed0f2eb4", "patch": "@@ -1,3 +1,7 @@\n+2019-03-13  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.c-torture/compile/20200313-1.c: New test.\n+\n 2020-03-12  Jeff Law  <law@redhat.com>\n \n \tPR rtl-optimization/90275"}, {"sha": "4791badff59385d995da46ba0c3c2de2aca18a71", "filename": "gcc/testsuite/gcc.c-torture/compile/20200313-1.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82f620e2ba4c440c5e89bb1f73d10a11ed0f2eb4/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20200313-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82f620e2ba4c440c5e89bb1f73d10a11ed0f2eb4/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20200313-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20200313-1.c?ref=82f620e2ba4c440c5e89bb1f73d10a11ed0f2eb4", "patch": "@@ -0,0 +1,14 @@\n+/* PR middle-end/92071 */\n+/* Testcase by David Binderman <dcb314@hotmail.com> */\n+\n+void *a;\n+union U { double c; char d[8]; };\n+void bar (union U);\n+\n+void\n+foo (void)\n+{\n+  union U b;\n+  __builtin_memcpy (b.d, a, 8);\n+  bar (b);\n+}"}]}