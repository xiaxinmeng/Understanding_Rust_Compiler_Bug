{"sha": "a35de342764f828da54fe6c597d2abff3c927ac3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTM1ZGUzNDI3NjRmODI4ZGE1NGZlNmM1OTdkMmFiZmYzYzkyN2FjMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@nildram.co.uk", "date": "2007-10-24T17:52:16Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-10-24T17:52:16Z"}, "message": "re PR target/33755 (Gcc 4.2.2 broken for mips linux kernel builds)\n\ngcc/\n\tPR target/33755\n\t* config/mips/mips.c (mips_lo_sum_offset): New structure.\n\t(mips_hash_base, mips_lo_sum_offset_hash, mips_lo_sum_offset_eq)\n\t(mips_lo_sum_offset_lookup, mips_record_lo_sum)\n\t(mips_orphaned_high_part_p: New functions.\n\t(mips_avoid_hazard): Don't check INSN_P here.\n\t(mips_avoid_hazards): Rename to...\n\t(mips_reorg_process_insns): ...this.  Cope with\n\t!TARGET_EXPLICIT_RELOCS.  Delete orphaned high-part relocations,\n\tor turn them into nops.\n\t(mips_reorg): Remove TARGET_EXPLICIT_RELOCS check from calls to\n\tdbr_schedule and mips_avoid_hazards/mips_reorg_process_insns.\n\t(mips_set_mips16_mode): Don't set flag_delayed_branch here.\n\t(mips_override_options): Set flag_delayed_branch to 0.\n\ngcc/testsuite/\n\tPR target/33755\n\t* gcc.target/mips/pr33755.c: New test.\n\nFrom-SVN: r129606", "tree": {"sha": "323a27c7b6a88c15b3a90107b547e080723d71ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/323a27c7b6a88c15b3a90107b547e080723d71ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a35de342764f828da54fe6c597d2abff3c927ac3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a35de342764f828da54fe6c597d2abff3c927ac3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a35de342764f828da54fe6c597d2abff3c927ac3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a35de342764f828da54fe6c597d2abff3c927ac3/comments", "author": null, "committer": null, "parents": [{"sha": "a1c6b246b55b9c50aaf5d15e180d13f01b903cf5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1c6b246b55b9c50aaf5d15e180d13f01b903cf5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1c6b246b55b9c50aaf5d15e180d13f01b903cf5"}], "stats": {"total": 274, "additions": 238, "deletions": 36}, "files": [{"sha": "536ada1c8fdded73cb972d548564c5d345b0d63b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a35de342764f828da54fe6c597d2abff3c927ac3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a35de342764f828da54fe6c597d2abff3c927ac3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a35de342764f828da54fe6c597d2abff3c927ac3", "patch": "@@ -1,3 +1,20 @@\n+2007-10-24  Richard Sandiford  <rsandifo@nildram.co.uk>\n+\n+\tPR target/33755\n+\t* config/mips/mips.c (mips_lo_sum_offset): New structure.\n+\t(mips_hash_base, mips_lo_sum_offset_hash, mips_lo_sum_offset_eq)\n+\t(mips_lo_sum_offset_lookup, mips_record_lo_sum)\n+\t(mips_orphaned_high_part_p: New functions.\n+\t(mips_avoid_hazard): Don't check INSN_P here.\n+\t(mips_avoid_hazards): Rename to...\n+\t(mips_reorg_process_insns): ...this.  Cope with\n+\t!TARGET_EXPLICIT_RELOCS.  Delete orphaned high-part relocations,\n+\tor turn them into nops.\n+\t(mips_reorg): Remove TARGET_EXPLICIT_RELOCS check from calls to\n+\tdbr_schedule and mips_avoid_hazards/mips_reorg_process_insns.\n+\t(mips_set_mips16_mode): Don't set flag_delayed_branch here.\n+\t(mips_override_options): Set flag_delayed_branch to 0.\n+\n 2007-10-24  Richard Sandiford  <rsandifo@nildram.co.uk>\n \n \t* config/mips/mips.h (MOVE_MAX): Use UNITS_PER_WORD and describe"}, {"sha": "b2d105b077bc622146fcbecc5f104eafa768b939", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 186, "deletions": 36, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a35de342764f828da54fe6c597d2abff3c927ac3/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a35de342764f828da54fe6c597d2abff3c927ac3/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=a35de342764f828da54fe6c597d2abff3c927ac3", "patch": "@@ -11183,8 +11183,122 @@ vr4130_align_insns (void)\n   dfa_finish ();\n }\n \f\n-/* Subroutine of mips_reorg.  If there is a hazard between INSN\n-   and a previous instruction, avoid it by inserting nops after\n+/* This structure records that the current function has a LO_SUM\n+   involving SYMBOL_REF or LABEL_REF BASE and that MAX_OFFSET is\n+   the largest offset applied to BASE by all such LO_SUMs.  */\n+struct mips_lo_sum_offset {\n+  rtx base;\n+  HOST_WIDE_INT offset;\n+};\n+\n+/* Return a hash value for SYMBOL_REF or LABEL_REF BASE.  */\n+\n+static hashval_t\n+mips_hash_base (rtx base)\n+{\n+  int do_not_record_p;\n+\n+  return hash_rtx (base, GET_MODE (base), &do_not_record_p, NULL, false);\n+}\n+\n+/* Hash-table callbacks for mips_lo_sum_offsets.  */\n+\n+static hashval_t\n+mips_lo_sum_offset_hash (const void *entry)\n+{\n+  return mips_hash_base (((const struct mips_lo_sum_offset *) entry)->base);\n+}\n+\n+static int\n+mips_lo_sum_offset_eq (const void *entry, const void *value)\n+{\n+  return rtx_equal_p (((const struct mips_lo_sum_offset *) entry)->base,\n+\t\t      (const_rtx) value);\n+}\n+\n+/* Look up symbolic constant X in HTAB, which is a hash table of\n+   mips_lo_sum_offsets.  If OPTION is NO_INSERT, return true if X can be\n+   paired with a recorded LO_SUM, otherwise record X in the table.  */\n+\n+static bool\n+mips_lo_sum_offset_lookup (htab_t htab, rtx x, enum insert_option option)\n+{\n+  rtx base, offset;\n+  void **slot;\n+  struct mips_lo_sum_offset *entry;\n+\n+  /* Split X into a base and offset.  */\n+  split_const (x, &base, &offset);\n+  if (UNSPEC_ADDRESS_P (base))\n+    base = UNSPEC_ADDRESS (base);\n+\n+  /* Look up the base in the hash table.  */\n+  slot = htab_find_slot_with_hash (htab, base, mips_hash_base (base), option);\n+  if (slot == NULL)\n+    return false;\n+\n+  entry = (struct mips_lo_sum_offset *) *slot;\n+  if (option == INSERT)\n+    {\n+      if (entry == NULL)\n+\t{\n+\t  entry = XNEW (struct mips_lo_sum_offset);\n+\t  entry->base = base;\n+\t  entry->offset = INTVAL (offset);\n+\t  *slot = entry;\n+\t}\n+      else\n+\t{\n+\t  if (INTVAL (offset) > entry->offset)\n+\t    entry->offset = INTVAL (offset);\n+\t}\n+    }\n+  return INTVAL (offset) <= entry->offset;\n+}\n+\n+/* A for_each_rtx callback for which DATA is a mips_lo_sum_offset hash table.\n+   Record every LO_SUM in *LOC.  */\n+\n+static int\n+mips_record_lo_sum (rtx *loc, void *data)\n+{\n+  if (GET_CODE (*loc) == LO_SUM)\n+    mips_lo_sum_offset_lookup ((htab_t) data, XEXP (*loc, 1), INSERT);\n+  return 0;\n+}\n+\n+/* Return true if INSN is a SET of an orphaned high-part relocation.\n+   HTAB is a hash table of mips_lo_sum_offsets that describes all the\n+   LO_SUMs in the current function.  */\n+\n+static bool\n+mips_orphaned_high_part_p (htab_t htab, rtx insn)\n+{\n+  enum mips_symbol_type type;\n+  rtx x, set;\n+\n+  set = single_set (insn);\n+  if (set)\n+    {\n+      /* Check for %his.  */\n+      x = SET_SRC (set);\n+      if (GET_CODE (x) == HIGH\n+\t  && absolute_symbolic_operand (XEXP (x, 0), VOIDmode))\n+\treturn !mips_lo_sum_offset_lookup (htab, XEXP (x, 0), NO_INSERT);\n+\n+      /* Check for local %gots (and %got_pages, which is redundant but OK).  */\n+      if (GET_CODE (x) == UNSPEC\n+\t  && XINT (x, 1) == UNSPEC_LOAD_GOT\n+\t  && mips_symbolic_constant_p (XVECEXP (x, 0, 1),\n+\t\t\t\t       SYMBOL_CONTEXT_LEA, &type)\n+\t  && type == SYMBOL_GOTOFF_PAGE)\n+\treturn !mips_lo_sum_offset_lookup (htab, XVECEXP (x, 0, 1), NO_INSERT);\n+    }\n+  return false;\n+}\n+\n+/* Subroutine of mips_reorg_process_insns.  If there is a hazard between\n+   INSN and a previous instruction, avoid it by inserting nops after\n    instruction AFTER.\n \n    *DELAYED_REG and *HILO_DELAY describe the hazards that apply at\n@@ -11205,9 +11319,6 @@ mips_avoid_hazard (rtx after, rtx insn, int *hilo_delay,\n   rtx pattern, set;\n   int nops, ninsns, hazard_set;\n \n-  if (!INSN_P (insn))\n-    return;\n-\n   pattern = PATTERN (insn);\n \n   /* Do not put the whole function in .set noreorder if it contains\n@@ -11267,14 +11378,16 @@ mips_avoid_hazard (rtx after, rtx insn, int *hilo_delay,\n }\n \n /* Go through the instruction stream and insert nops where necessary.\n-   See if the whole function can then be put into .set noreorder &\n-   .set nomacro.  */\n+   Also delete any high-part relocations whose partnering low parts\n+   are now all dead.  See if the whole function can then be put into\n+   .set noreorder and .set nomacro.  */\n \n static void\n-mips_avoid_hazards (void)\n+mips_reorg_process_insns (void)\n {\n-  rtx insn, last_insn, lo_reg, delayed_reg;\n-  int hilo_delay, i;\n+  rtx insn, last_insn, subinsn, next_insn, lo_reg, delayed_reg;\n+  int hilo_delay;\n+  htab_t htab;\n \n   /* Force all instructions to be split into their final form.  */\n   split_all_insns_noflow ();\n@@ -11285,6 +11398,10 @@ mips_avoid_hazards (void)\n \n   cfun->machine->all_noreorder_p = true;\n \n+  /* Code that doesn't use explicit relocs can't be \".set nomacro\".  */\n+  if (!TARGET_EXPLICIT_RELOCS)\n+    cfun->machine->all_noreorder_p = false;\n+\n   /* Profiled functions can't be all noreorder because the profiler\n      support uses assembler macros.  */\n   if (current_function_profile)\n@@ -11302,24 +11419,63 @@ mips_avoid_hazards (void)\n   if (TARGET_FIX_VR4130 && !ISA_HAS_MACCHI)\n     cfun->machine->all_noreorder_p = false;\n \n+  htab = htab_create (37, mips_lo_sum_offset_hash,\n+\t\t      mips_lo_sum_offset_eq, free);\n+\n+  /* Make a first pass over the instructions, recording all the LO_SUMs.  */\n+  for (insn = get_insns (); insn != 0; insn = NEXT_INSN (insn))\n+    FOR_EACH_SUBINSN (subinsn, insn)\n+      if (INSN_P (subinsn))\n+\tfor_each_rtx (&PATTERN (subinsn), mips_record_lo_sum, htab);\n+\n   last_insn = 0;\n   hilo_delay = 2;\n   delayed_reg = 0;\n   lo_reg = gen_rtx_REG (SImode, LO_REGNUM);\n \n-  for (insn = get_insns (); insn != 0; insn = NEXT_INSN (insn))\n-    if (INSN_P (insn))\n-      {\n-\tif (GET_CODE (PATTERN (insn)) == SEQUENCE)\n-\t  for (i = 0; i < XVECLEN (PATTERN (insn), 0); i++)\n-\t    mips_avoid_hazard (last_insn, XVECEXP (PATTERN (insn), 0, i),\n-\t\t\t       &hilo_delay, &delayed_reg, lo_reg);\n-\telse\n-\t  mips_avoid_hazard (last_insn, insn, &hilo_delay,\n-\t\t\t     &delayed_reg, lo_reg);\n+  /* Make a second pass over the instructions.  Delete orphaned\n+     high-part relocations or turn them into NOPs.  Avoid hazards\n+     by inserting NOPs.  */\n+  for (insn = get_insns (); insn != 0; insn = next_insn)\n+    {\n+      next_insn = NEXT_INSN (insn);\n+      if (INSN_P (insn))\n+\t{\n+\t  if (GET_CODE (PATTERN (insn)) == SEQUENCE)\n+\t    {\n+\t      /* If we find an orphaned high-part relocation in a delay\n+\t\t slot, it's easier to turn that instruction into a NOP than\n+\t\t to delete it.  The delay slot will be a NOP either way.  */\n+\t      FOR_EACH_SUBINSN (subinsn, insn)\n+\t\tif (INSN_P (subinsn))\n+\t\t  {\n+\t\t    if (mips_orphaned_high_part_p (htab, subinsn))\n+\t\t      {\n+\t\t\tPATTERN (subinsn) = gen_nop ();\n+\t\t\tINSN_CODE (subinsn) = CODE_FOR_nop;\n+\t\t      }\n+\t\t    mips_avoid_hazard (last_insn, subinsn, &hilo_delay,\n+\t\t\t\t       &delayed_reg, lo_reg);\n+\t\t  }\n+\t      last_insn = insn;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* INSN is a single instruction.  Delete it if it's an\n+\t\t orphaned high-part relocation.  */\n+\t      if (mips_orphaned_high_part_p (htab, insn))\n+\t\tdelete_insn (insn);\n+\t      else\n+\t\t{\n+\t\t  mips_avoid_hazard (last_insn, insn, &hilo_delay,\n+\t\t\t\t     &delayed_reg, lo_reg);\n+\t\t  last_insn = insn;\n+\t\t}\n+\t    }\n+\t}\n+    }\n \n-\tlast_insn = insn;\n-      }\n+  htab_delete (htab);\n }\n \n /* Implement TARGET_MACHINE_DEPENDENT_REORG.  */\n@@ -11328,14 +11484,11 @@ static void\n mips_reorg (void)\n {\n   mips16_lay_out_constants ();\n-  if (TARGET_EXPLICIT_RELOCS)\n-    {\n-      if (mips_base_delayed_branch)\n-\tdbr_schedule (get_insns ());\n-      mips_avoid_hazards ();\n-      if (TUNE_MIPS4130 && TARGET_VR4130_ALIGN)\n-\tvr4130_align_insns ();\n-    }\n+  if (mips_base_delayed_branch)\n+    dbr_schedule (get_insns ());\n+  mips_reorg_process_insns ();\n+  if (TARGET_EXPLICIT_RELOCS && TUNE_MIPS4130 && TARGET_VR4130_ALIGN)\n+    vr4130_align_insns ();\n }\n \f\n /* Implement TARGET_ASM_OUTPUT_MI_THUNK.  Generate rtl rather than asm text\n@@ -11481,7 +11634,6 @@ mips_set_mips16_mode (int mips16_p)\n \n   /* Restore base settings of various flags.  */\n   target_flags = mips_base_target_flags;\n-  flag_delayed_branch = mips_base_delayed_branch;\n   flag_schedule_insns = mips_base_schedule_insns;\n   flag_reorder_blocks_and_partition = mips_base_reorder_blocks_and_partition;\n   flag_move_loop_invariants = mips_base_move_loop_invariants;\n@@ -11534,11 +11686,6 @@ mips_set_mips16_mode (int mips16_p)\n       /* Switch to normal (non-MIPS16) mode.  */\n       target_flags &= ~MASK_MIPS16;\n \n-      /* When using explicit relocs, we call dbr_schedule from within\n-\t mips_reorg.  */\n-      if (TARGET_EXPLICIT_RELOCS)\n-\tflag_delayed_branch = 0;\n-\n       /* Provide default values for align_* for 64-bit targets.  */\n       if (TARGET_64BIT)\n \t{\n@@ -12063,6 +12210,9 @@ mips_override_options (void)\n \n   /* Now select the ISA mode.  */\n   mips_set_mips16_mode (mips_base_mips16);\n+\n+  /* We call dbr_schedule from within mips_reorg.  */\n+  flag_delayed_branch = 0;\n }\n \n /* Swap the register information for registers I and I + 1, which"}, {"sha": "2242d120baab9bb10b62d49806bc14badfd2f18a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a35de342764f828da54fe6c597d2abff3c927ac3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a35de342764f828da54fe6c597d2abff3c927ac3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a35de342764f828da54fe6c597d2abff3c927ac3", "patch": "@@ -1,3 +1,8 @@\n+2007-10-24  Richard Sandiford  <rsandifo@nildram.co.uk>\n+\n+\tPR target/33755\n+\t* gcc.target/mips/pr33755.c: New test.\n+\n 2007-10-24  Ira Rosen  <irar@il.ibm.com>\n \n \tPR tree-optimization/33804"}, {"sha": "a550480ddd7eb53ab97cba5b8368e56ad0d0ef21", "filename": "gcc/testsuite/gcc.target/mips/pr33755.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a35de342764f828da54fe6c597d2abff3c927ac3/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fpr33755.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a35de342764f828da54fe6c597d2abff3c927ac3/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fpr33755.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fpr33755.c?ref=a35de342764f828da54fe6c597d2abff3c927ac3", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do link } */\n+/* { dg-mips-options \"-O2\" } */\n+\n+volatile int gv;\n+const char *ptrs[2];\n+\n+void\n+foo (volatile int *v, const char **ptrs)\n+{\n+  switch (*v & 1)\n+    {\n+    case 0:\n+      ptrs[0] = 0;\n+      break;\n+    case 1:\n+      break;\n+    default:\n+      ptrs[1] = \"Some text\";\n+      break;\n+    }\n+  while (*v > 0)\n+    *v -= 1;\n+}\n+\n+int\n+main (void)\n+{\n+  foo (&gv, ptrs);\n+  return 0;\n+}"}]}