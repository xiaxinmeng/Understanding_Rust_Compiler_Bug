{"sha": "00c2f96f892c11adac80dfec452278e637f43f62", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDBjMmY5NmY4OTJjMTFhZGFjODBkZmVjNDUyMjc4ZTYzN2Y0M2Y2Mg==", "commit": {"author": {"name": "Jim Blandy", "email": "jimb@redhat.com", "date": "2002-02-22T17:01:23Z"}, "committer": {"name": "Jim Blandy", "email": "jimb@gcc.gnu.org", "date": "2002-02-22T17:01:23Z"}, "message": "Allow the user to specify functions for allocating memory for splay tree roots and nodes.\n\ninclude:\nAllow the user to specify functions for allocating memory for\nsplay tree roots and nodes.\n* splay-tree.h (splay_tree_allocate_fn, splay_tree_deallocate_fn):\nNew types.\n(splay_tree): New fields: `allocate', `deallocate', and\n`allocate_data'.\n(splay_tree_new_with_allocator): New function declaration.\n\nlibiberty:\n* splay-tree.c (splay_tree_xmalloc_allocate,\nsplay_tree_xmalloc_deallocate): New functions.\n(splay_tree_new): Call splay_tree_new_with_allocator, passing the\nabove functions and a dummy data pointer.\n(splay_tree_new_with_allocator): New function.\n(splay_tree_delete_helper, splay_tree_delete, splay_tree_insert,\nsplay_tree_remove): Use the splay tree's allocation and\ndeallocation functions.\n\nFrom-SVN: r49968", "tree": {"sha": "4759685426e1fe1ad06d6c7ecee1dac0bf9aff27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4759685426e1fe1ad06d6c7ecee1dac0bf9aff27"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00c2f96f892c11adac80dfec452278e637f43f62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00c2f96f892c11adac80dfec452278e637f43f62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00c2f96f892c11adac80dfec452278e637f43f62", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00c2f96f892c11adac80dfec452278e637f43f62/comments", "author": null, "committer": null, "parents": [{"sha": "453c182f826bfda58db799c6dd5b2e2701925c7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/453c182f826bfda58db799c6dd5b2e2701925c7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/453c182f826bfda58db799c6dd5b2e2701925c7d"}], "stats": {"total": 100, "additions": 94, "deletions": 6}, "files": [{"sha": "e6c3d5e49d0f279a733f34ba2e6725a937b38cf6", "filename": "include/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00c2f96f892c11adac80dfec452278e637f43f62/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00c2f96f892c11adac80dfec452278e637f43f62/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=00c2f96f892c11adac80dfec452278e637f43f62", "patch": "@@ -1,3 +1,13 @@\n+2002-02-22  Jim Blandy  <jimb@redhat.com>\n+\n+\tAllow the user to specify functions for allocating memory for\n+\tsplay tree roots and nodes.\n+\t* splay-tree.h (splay_tree_allocate_fn, splay_tree_deallocate_fn):\n+\tNew types.\n+\t(splay_tree): New fields: `allocate', `deallocate', and\n+\t`allocate_data'.\n+\t(splay_tree_new_with_allocator): New function declaration.\n+\n 2002-02-05  Jason Merrill  <jason@redhat.com>\n \n \t* demangle.h (cplus_demangle_v3): Add \"options\" parm."}, {"sha": "4b7a7bf8c2c18d5b4b23af10b9e146f566524848", "filename": "include/splay-tree.h", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00c2f96f892c11adac80dfec452278e637f43f62/include%2Fsplay-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00c2f96f892c11adac80dfec452278e637f43f62/include%2Fsplay-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fsplay-tree.h?ref=00c2f96f892c11adac80dfec452278e637f43f62", "patch": "@@ -61,6 +61,18 @@ typedef void (*splay_tree_delete_value_fn) PARAMS((splay_tree_value));\n /* The type of a function used to iterate over the tree.  */\n typedef int (*splay_tree_foreach_fn) PARAMS((splay_tree_node, void*));\n \n+/* The type of a function used to allocate memory for tree root and\n+   node structures.  The first argument is the number of bytes needed;\n+   the second is a data pointer the splay tree functions pass through\n+   to the allocator.  This function must never return zero.  */\n+typedef void *(*splay_tree_allocate_fn) PARAMS((int, void *));\n+\n+/* The type of a function used to free memory allocated using the\n+   corresponding splay_tree_allocate_fn.  The first argument is the\n+   memory to be freed; the latter is a data pointer the splay tree\n+   functions pass through to the freer.  */\n+typedef void (*splay_tree_deallocate_fn) PARAMS((void *, void *));\n+\n /* The nodes in the splay tree.  */\n struct splay_tree_node_s\n {\n@@ -89,11 +101,24 @@ typedef struct splay_tree_s\n \n   /* The deallocate-value function.  NULL if no cleanup is necessary.  */\n   splay_tree_delete_value_fn delete_value;\n+\n+  /* Allocate/free functions, and a data pointer to pass to them.  */\n+  splay_tree_allocate_fn allocate;\n+  splay_tree_deallocate_fn deallocate;\n+  void *allocate_data;\n+\n } *splay_tree;\n \n extern splay_tree splay_tree_new        PARAMS((splay_tree_compare_fn,\n \t\t\t\t\t        splay_tree_delete_key_fn,\n \t\t\t\t\t        splay_tree_delete_value_fn));\n+extern splay_tree splay_tree_new_with_allocator\n+                                        PARAMS((splay_tree_compare_fn,\n+\t\t\t\t\t        splay_tree_delete_key_fn,\n+\t\t\t\t\t        splay_tree_delete_value_fn,\n+                                                splay_tree_allocate_fn,\n+                                                splay_tree_deallocate_fn,\n+                                                void *));\n extern void splay_tree_delete           PARAMS((splay_tree));\n extern splay_tree_node splay_tree_insert          \n \t\t                        PARAMS((splay_tree,"}, {"sha": "5c9334711cc21bad7f46f47360c4b340ceb5d2fe", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00c2f96f892c11adac80dfec452278e637f43f62/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00c2f96f892c11adac80dfec452278e637f43f62/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=00c2f96f892c11adac80dfec452278e637f43f62", "patch": "@@ -1,3 +1,14 @@\n+2002-02-22  Jim Blandy  <jimb@redhat.com>\n+\n+\t* splay-tree.c (splay_tree_xmalloc_allocate,\n+\tsplay_tree_xmalloc_deallocate): New functions.\n+\t(splay_tree_new): Call splay_tree_new_with_allocator, passing the\n+\tabove functions and a dummy data pointer.\n+\t(splay_tree_new_with_allocator): New function.\n+\t(splay_tree_delete_helper, splay_tree_delete, splay_tree_insert,\n+\tsplay_tree_remove): Use the splay tree's allocation and\n+\tdeallocation functions.\n+\n 2002-02-19  Scott Snyder  <snyder@fnal.gov>\n \n \t* testsuite/demangle-expected: Add test case for infinite loop in"}, {"sha": "f12b4cc5007b782f9c38d273db802c2a0178c8ca", "filename": "libiberty/splay-tree.c", "status": "modified", "additions": 48, "deletions": 6, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00c2f96f892c11adac80dfec452278e637f43f62/libiberty%2Fsplay-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00c2f96f892c11adac80dfec452278e637f43f62/libiberty%2Fsplay-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsplay-tree.c?ref=00c2f96f892c11adac80dfec452278e637f43f62", "patch": "@@ -70,7 +70,7 @@ splay_tree_delete_helper (sp, node)\n   if (sp->delete_value)\n     (*sp->delete_value)(node->value);\n \n-  free ((char*) node);\n+  (*sp->deallocate) ((char*) node, sp->allocate_data);\n }\n \n /* Help splay SP around KEY.  PARENT and GRANDPARENT are the parent\n@@ -227,21 +227,61 @@ splay_tree_foreach_helper (sp, node, fn, data)\n   return splay_tree_foreach_helper (sp, node->right, fn, data);\n }\n \n+\n+/* An allocator and deallocator based on xmalloc.  */\n+static void *\n+splay_tree_xmalloc_allocate (int size, void *data)\n+{\n+  return xmalloc (size);\n+}\n+\n+static void\n+splay_tree_xmalloc_deallocate (void *object, void *data)\n+{\n+  free (object);\n+}\n+\n+\n /* Allocate a new splay tree, using COMPARE_FN to compare nodes,\n    DELETE_KEY_FN to deallocate keys, and DELETE_VALUE_FN to deallocate\n-   values.  */\n+   values.  Use xmalloc to allocate the splay tree structure, and any\n+   nodes added.  */\n \n splay_tree \n splay_tree_new (compare_fn, delete_key_fn, delete_value_fn)\n      splay_tree_compare_fn compare_fn;\n      splay_tree_delete_key_fn delete_key_fn;\n      splay_tree_delete_value_fn delete_value_fn;\n {\n-  splay_tree sp = (splay_tree) xmalloc (sizeof (struct splay_tree_s));\n+  return (splay_tree_new_with_allocator\n+          (compare_fn, delete_key_fn, delete_value_fn,\n+           splay_tree_xmalloc_allocate, splay_tree_xmalloc_deallocate, 0));\n+}\n+\n+\n+/* Allocate a new splay tree, using COMPARE_FN to compare nodes,\n+   DELETE_KEY_FN to deallocate keys, and DELETE_VALUE_FN to deallocate\n+   values.  */\n+\n+splay_tree \n+splay_tree_new_with_allocator (compare_fn, delete_key_fn, delete_value_fn,\n+                               allocate_fn, deallocate_fn, allocate_data)\n+     splay_tree_compare_fn compare_fn;\n+     splay_tree_delete_key_fn delete_key_fn;\n+     splay_tree_delete_value_fn delete_value_fn;\n+     splay_tree_allocate_fn allocate_fn;\n+     splay_tree_deallocate_fn deallocate_fn;\n+     void *allocate_data;\n+{\n+  splay_tree sp = (splay_tree) (*allocate_fn) (sizeof (struct splay_tree_s),\n+                                               allocate_data);\n   sp->root = 0;\n   sp->comp = compare_fn;\n   sp->delete_key = delete_key_fn;\n   sp->delete_value = delete_value_fn;\n+  sp->allocate = allocate_fn;\n+  sp->deallocate = deallocate_fn;\n+  sp->allocate_data = allocate_data;\n \n   return sp;\n }\n@@ -253,7 +293,7 @@ splay_tree_delete (sp)\n      splay_tree sp;\n {\n   splay_tree_delete_helper (sp, sp->root);\n-  free ((char*) sp);\n+  (*sp->deallocate) ((char*) sp, sp->allocate_data);\n }\n \n /* Insert a new node (associating KEY with DATA) into SP.  If a\n@@ -286,7 +326,9 @@ splay_tree_insert (sp, key, value)\n       /* Create a new node, and insert it at the root.  */\n       splay_tree_node node;\n       \n-      node = (splay_tree_node) xmalloc (sizeof (struct splay_tree_node_s));\n+      node = ((splay_tree_node)\n+              (*sp->allocate) (sizeof (struct splay_tree_node_s),\n+                               sp->allocate_data));\n       node->key = key;\n       node->value = value;\n       \n@@ -330,7 +372,7 @@ splay_tree_remove (sp, key)\n       /* Delete the root node itself.  */\n       if (sp->delete_value)\n \t(*sp->delete_value) (sp->root->value);\n-      free (sp->root);\n+      (*sp->deallocate) (sp->root, sp->allocate_data);\n \n       /* One of the children is now the root.  Doesn't matter much\n \t which, so long as we preserve the properties of the tree.  */"}]}