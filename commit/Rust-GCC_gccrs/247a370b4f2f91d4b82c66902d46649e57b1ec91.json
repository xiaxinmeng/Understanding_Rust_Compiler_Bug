{"sha": "247a370b4f2f91d4b82c66902d46649e57b1ec91", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQ3YTM3MGI0ZjJmOTFkNGI4MmM2NjkwMmQ0NjY0OWU1N2IxZWM5MQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-08-19T23:46:10Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-08-19T23:46:10Z"}, "message": "final.c (compute_alignments): New function.\n\n\t* final.c (compute_alignments): New function.\n\t(init_insn_lengths): Do not care label_align.\n\t(LABEL_ALIGN_AFTER_BARRIER): Default to 1.\n\t(LABEL_ALIGN_AFTER_BARRIER_MAX_SKIP): Default to 0.\n\t(JUMP_ALIGN, JUMP_ALIGN_MAX_SKIP): New.\n\t(shorted_branches): Realloc label_align array; do\n\tnot call init_insn_lengths; Do not care about loop alignments.\n\t* output.h (compute_alignments): Declare.\n\t* toplev.c (rest_of_compilation): Call compute_alignments.\n\t* tm.texi (JUMP_ALIGN, JUMP_ALIGN_MAX_SKIP): Document.\n\n\t* predict.c (block_info_def): Add npredecesors, remove nvisited;\n\tchange visited to tovisit.\n\t(propagate_freq): Use faster traversing algorithm.\n\t(estimate_loops_at_level, estimate_bb_frequencies): Change visited\n\tto tovisit; reverse meaning.\n\n\t* predict.c (struct block_info_def): Remove nvisited.\n\t(propagate_freq): Use EDGE_DFS_BACK to detect irreducible regions.\n\t(estimate_bb_frequencies): Call mark_dfs_back_edges.\n\nFrom-SVN: r45042", "tree": {"sha": "41105a8a5becd86725e0db5742de2ed66c51ad55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41105a8a5becd86725e0db5742de2ed66c51ad55"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/247a370b4f2f91d4b82c66902d46649e57b1ec91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/247a370b4f2f91d4b82c66902d46649e57b1ec91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/247a370b4f2f91d4b82c66902d46649e57b1ec91", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/247a370b4f2f91d4b82c66902d46649e57b1ec91/comments", "author": null, "committer": null, "parents": [{"sha": "13fac94a68a4da815faa73d6a457c3d9d3bf94f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13fac94a68a4da815faa73d6a457c3d9d3bf94f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13fac94a68a4da815faa73d6a457c3d9d3bf94f5"}], "stats": {"total": 310, "additions": 214, "deletions": 96}, "files": [{"sha": "d37e8f4d98ddc1ec9d6d0f2c99540102dade48cb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/247a370b4f2f91d4b82c66902d46649e57b1ec91/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/247a370b4f2f91d4b82c66902d46649e57b1ec91/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=247a370b4f2f91d4b82c66902d46649e57b1ec91", "patch": "@@ -1,3 +1,26 @@\n+Mon Aug 20 01:44:50 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* final.c (compute_alignments): New function.\n+\t(init_insn_lengths): Do not care label_align.\n+\t(LABEL_ALIGN_AFTER_BARRIER): Default to 1.\n+\t(LABEL_ALIGN_AFTER_BARRIER_MAX_SKIP): Default to 0.\n+\t(JUMP_ALIGN, JUMP_ALIGN_MAX_SKIP): New.\n+\t(shorted_branches): Realloc label_align array; do\n+\tnot call init_insn_lengths; Do not care about loop alignments.\n+\t* output.h (compute_alignments): Declare.\n+\t* toplev.c (rest_of_compilation): Call compute_alignments.\n+\t* tm.texi (JUMP_ALIGN, JUMP_ALIGN_MAX_SKIP): Document.\n+\n+\t* predict.c (block_info_def): Add npredecesors, remove nvisited;\n+\tchange visited to tovisit.\n+\t(propagate_freq): Use faster traversing algorithm.\n+\t(estimate_loops_at_level, estimate_bb_frequencies): Change visited\n+\tto tovisit; reverse meaning.\n+\n+\t* predict.c (struct block_info_def): Remove nvisited.\n+\t(propagate_freq): Use EDGE_DFS_BACK to detect irreducible regions.\n+\t(estimate_bb_frequencies): Call mark_dfs_back_edges.\n+\n 2001-08-19  Geoffrey Keating  <geoffk@redhat.com>\n \n \t* doc/invoke.texi (MIPS Options): Document -mfused-madd."}, {"sha": "80e8e75209d065b4522b2ed32c4d301ff9e12a8c", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/247a370b4f2f91d4b82c66902d46649e57b1ec91/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/247a370b4f2f91d4b82c66902d46649e57b1ec91/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=247a370b4f2f91d4b82c66902d46649e57b1ec91", "patch": "@@ -7226,10 +7226,10 @@ the target supports DWARF 2 frame unwind information.\n This describes commands for alignment.\n \n @table @code\n-@findex LABEL_ALIGN_AFTER_BARRIER\n-@item LABEL_ALIGN_AFTER_BARRIER (@var{label})\n-The alignment (log base 2) to put in front of @var{label}, which follows\n-a @code{BARRIER}.\n+@findex JUMP_ALIGN\n+@item JUMP_ALIGN (@var{label})\n+The alignment (log base 2) to put in front of @var{label}, which is\n+a common destination of jumps and has no fallthru incomming edge.\n \n This macro need not be defined if you don't want any special alignment\n to be done at such a time.  Most machine descriptions do not currently\n@@ -7238,8 +7238,16 @@ define the macro.\n Unless it's necessary to inspect the @var{label} parameter, it is better\n to set the variable @var{align_jumps} in the target's\n @code{OVERRIDE_OPTIONS}.  Otherwise, you should try to honour the user's\n-selection in @var{align_jumps} in a @code{LABEL_ALIGN_AFTER_BARRIER}\n-implementation.\n+selection in @var{align_jumps} in a @code{JUMP_ALIGN} implementation.\n+\n+@findex LABEL_ALIGN_AFTER_BARRIER\n+@item LABEL_ALIGN_AFTER_BARRIER (@var{label})\n+The alignment (log base 2) to put in front of @var{label}, which follows\n+a @code{BARRIER}.\n+\n+This macro need not be defined if you don't want any special alignment\n+to be done at such a time.  Most machine descriptions do not currently\n+define the macro.\n \n @findex LABEL_ALIGN_AFTER_BARRIER_MAX_SKIP\n @item LABEL_ALIGN_AFTER_BARRIER_MAX_SKIP"}, {"sha": "ed4b6fff3d32e7f1f145e8f0f955798774514b3f", "filename": "gcc/final.c", "status": "modified", "additions": 123, "deletions": 52, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/247a370b4f2f91d4b82c66902d46649e57b1ec91/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/247a370b4f2f91d4b82c66902d46649e57b1ec91/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=247a370b4f2f91d4b82c66902d46649e57b1ec91", "patch": "@@ -643,11 +643,6 @@ static struct label_alignment *label_align;\n void\n init_insn_lengths ()\n {\n-  if (label_align)\n-    {\n-      free (label_align);\n-      label_align = 0;\n-    }\n   if (uid_shuid)\n     {\n       free (uid_shuid);\n@@ -791,11 +786,19 @@ get_attr_length (insn)\n #endif\n \n #ifndef LABEL_ALIGN_AFTER_BARRIER\n-#define LABEL_ALIGN_AFTER_BARRIER(LABEL) align_jumps_log\n+#define LABEL_ALIGN_AFTER_BARRIER(LABEL) 1\n #endif\n \n #ifndef LABEL_ALIGN_AFTER_BARRIER_MAX_SKIP\n-#define LABEL_ALIGN_AFTER_BARRIER_MAX_SKIP (align_jumps-1)\n+#define LABEL_ALIGN_AFTER_BARRIER_MAX_SKIP 0\n+#endif\n+\n+#ifndef JUMP_ALIGN\n+#define JUMP_ALIGN(LABEL) align_jumps_log\n+#endif\n+\n+#ifndef JUMP_ALIGN_MAX_SKIP\n+#define JUMP_ALIGN_MAX_SKIP (align_jumps-1)\n #endif\n \n #ifndef ADDR_VEC_ALIGN\n@@ -946,6 +949,88 @@ insn_current_reference_address (branch)\n }\n #endif /* HAVE_ATTR_length */\n \f\n+void\n+compute_alignments ()\n+{\n+  int i;\n+  int log, max_skip, max_log;\n+\n+  if (label_align)\n+    {\n+      free (label_align);\n+      label_align = 0;\n+    }\n+\n+  max_labelno = max_label_num ();\n+  min_labelno = get_first_label_num ();\n+  label_align = (struct label_alignment *)\n+    xcalloc (max_labelno - min_labelno + 1, sizeof (struct label_alignment));\n+\n+  /* If not optimizing or optimizing for size, don't assign any alignments.  */\n+  if (optimize || optimize_size)\n+    return;\n+\n+  for (i = 0; i < n_basic_blocks; i++)\n+    {\n+      basic_block bb = BASIC_BLOCK (i);\n+      rtx label = bb->head;\n+      int fallthru_frequency = 0, branch_frequency = 0, has_fallthru = 0;\n+      edge e;\n+\n+      if (GET_CODE (label) != CODE_LABEL)\n+\tcontinue;\n+      max_log = LABEL_ALIGN (label);\n+      max_skip = LABEL_ALIGN_MAX_SKIP;\n+\n+      for (e = bb->pred; e; e = e->pred_next)\n+\t{\n+\t  if (e->flags & EDGE_FALLTHRU)\n+\t    has_fallthru = 1, fallthru_frequency += EDGE_FREQUENCY (e);\n+\t  else\n+\t    branch_frequency += EDGE_FREQUENCY (e);\n+\t}\n+\n+      /* There are two purposes to align block with no fallthru incomming edge:\n+\t 1) to avoid fetch stalls when branch destination is near cache boundary\n+\t 2) to improve cache effciency in case the previous block is not executed\n+\t    (so it does not need to be in the cache).\n+\n+\t We to catch first case, we align frequently executed blocks.\n+\t To catch the second, we align blocks that are executed more frequently\n+\t than the predecesor and the predecesor is likely to not be executed\n+\t when function is called.  */\n+\n+      if (!has_fallthru\n+\t  && (branch_frequency > BB_FREQ_MAX / 10\n+\t      || (bb->frequency > BASIC_BLOCK (i - 1)->frequency * 10\n+\t\t  && (BASIC_BLOCK (i - 1)->frequency\n+\t\t      <= ENTRY_BLOCK_PTR->frequency / 2))))\n+\t{\n+\t  log = JUMP_ALIGN (label);\n+\t  if (max_log < log)\n+\t    {\n+\t      max_log = log;\n+\t      max_skip = JUMP_ALIGN_MAX_SKIP;\n+\t    }\n+\t}\n+      /* In case block is frequent and reached mostly by non-fallthru edge,\n+\t align it.  It is most likely an first block of loop.  */\n+      if (has_fallthru\n+\t  && branch_frequency + fallthru_frequency > BB_FREQ_MAX / 10\n+\t  && branch_frequency > fallthru_frequency * 5)\n+\t{\n+\t  log = LOOP_ALIGN (label);\n+\t  if (max_log < log)\n+\t    {\n+\t      max_log = log;\n+\t      max_skip = LOOP_ALIGN_MAX_SKIP;\n+\t    }\n+\t}\n+      LABEL_TO_ALIGNMENT (label) = max_log;\n+      LABEL_TO_MAX_SKIP (label) = max_skip;\n+    }\n+}\n+\f\n /* Make a pass over all insns and compute their actual lengths by shortening\n    any branches of variable length if possible.  */\n \n@@ -983,21 +1068,34 @@ shorten_branches (first)\n \n #endif\n \n-  /* We must do some computations even when not actually shortening, in\n-     order to get the alignment information for the labels.  */\n-\n-  init_insn_lengths ();\n-\n   /* Compute maximum UID and allocate label_align / uid_shuid.  */\n   max_uid = get_max_uid ();\n \n-  max_labelno = max_label_num ();\n-  min_labelno = get_first_label_num ();\n-  label_align = (struct label_alignment *)\n-    xcalloc ((max_labelno - min_labelno + 1), sizeof (struct label_alignment));\n-\n   uid_shuid = (int *) xmalloc (max_uid * sizeof *uid_shuid);\n \n+  if (max_labelno != max_label_num ())\n+    {\n+      int old = max_labelno;\n+      int n_labels;\n+      int n_old_labels;\n+\n+      max_labelno = max_label_num ();\n+\n+      n_labels = max_labelno - min_labelno + 1;\n+      n_old_labels = old - min_labelno + 1;\n+\n+      label_align = (struct label_alignment *) xrealloc\n+\t(label_align, n_labels * sizeof (struct label_alignment));\n+\n+      /* Range of labels grows monotonically in the function.  Abort here\n+         means that the initialization of array got lost.  */\n+      if (n_old_labels > n_labels)\n+\tabort ();\n+\n+      memset (label_align + n_old_labels, 0,\n+\t      (n_labels - n_old_labels) * sizeof (struct label_alignment));\n+    }\n+\n   /* Initialize label_align and set up uid_shuid to be strictly\n      monotonically rising with insn order.  */\n   /* We use max_log here to keep track of the maximum alignment we want to\n@@ -1023,6 +1121,14 @@ shorten_branches (first)\n       else if (GET_CODE (insn) == CODE_LABEL)\n \t{\n \t  rtx next;\n+\t  \n+\t  /* Merge in alignments computed by compute_alignments.  */\n+\t  log = LABEL_TO_ALIGNMENT (insn);\n+\t  if (max_log < log)\n+\t    {\n+\t      max_log = log;\n+\t      max_skip = LABEL_TO_MAX_SKIP (insn);\n+\t    }\n \n \t  log = LABEL_ALIGN (insn);\n \t  if (max_log < log)\n@@ -1074,41 +1180,6 @@ shorten_branches (first)\n \t\tbreak;\n \t      }\n \t}\n-      /* Again, we allow NOTE_INSN_LOOP_BEG - INSN - CODE_LABEL\n-\t sequences in order to handle reorg output efficiently.  */\n-      else if (GET_CODE (insn) == NOTE\n-\t       && NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n-\t{\n-\t  rtx label;\n-\t  int nest = 0;\n-\n-\t  /* Search for the label that starts the loop.\n-\t     Don't skip past the end of the loop, since that could\n-\t     lead to putting an alignment where it does not belong.\n-\t     However, a label after a nested (non-)loop would be OK.  */\n-\t  for (label = insn; label; label = NEXT_INSN (label))\n-\t    {\n-\t      if (GET_CODE (label) == NOTE\n-\t\t  && NOTE_LINE_NUMBER (label) == NOTE_INSN_LOOP_BEG)\n-\t\tnest++;\n-\t      else if (GET_CODE (label) == NOTE\n-\t\t       && NOTE_LINE_NUMBER (label) == NOTE_INSN_LOOP_END\n-\t\t       && --nest == 0)\n-\t\tbreak;\n-\t      else if (GET_CODE (label) == CODE_LABEL)\n-\t\t{\n-\t\t  log = LOOP_ALIGN (label);\n-\t\t  if (max_log < log)\n-\t\t    {\n-\t\t      max_log = log;\n-\t\t      max_skip = LOOP_ALIGN_MAX_SKIP;\n-\t\t    }\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t}\n-      else\n-\tcontinue;\n     }\n #ifdef HAVE_ATTR_length\n "}, {"sha": "f1426ec26ddcdbb901da69c8363f5908b3d4a2c0", "filename": "gcc/output.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/247a370b4f2f91d4b82c66902d46649e57b1ec91/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/247a370b4f2f91d4b82c66902d46649e57b1ec91/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=247a370b4f2f91d4b82c66902d46649e57b1ec91", "patch": "@@ -20,6 +20,9 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+/* Compute branch alignments based on frequency information in the CFG.  */\n+extern void compute_alignments  PARAMS ((void));\n+\n /* Initialize data in final at the beginning of a compilation.  */\n extern void init_final\t\tPARAMS ((const char *));\n "}, {"sha": "14dfc7dc8bf5ad208bf80719e328a88cc248ddea", "filename": "gcc/predict.c", "status": "modified", "additions": 50, "deletions": 38, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/247a370b4f2f91d4b82c66902d46649e57b1ec91/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/247a370b4f2f91d4b82c66902d46649e57b1ec91/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=247a370b4f2f91d4b82c66902d46649e57b1ec91", "patch": "@@ -606,8 +606,11 @@ typedef struct block_info_def\n   /* To keep queue of basic blocks to process.  */\n   basic_block next;\n \n-  /* True if block already converted.  */\n-  int visited:1;\n+  /* True if block needs to be visited in prop_freqency.  */\n+  int tovisit:1;\n+\n+  /* Number of predecesors we need to visit first.  */\n+  int npredecesors;\n } *block_info;\n \n /* Similar information for edges.  */\n@@ -634,6 +637,27 @@ propagate_freq (head)\n   basic_block last = bb;\n   edge e;\n   basic_block nextbb;\n+  int n;\n+\n+  /* For each basic block we need to visit count number of his predecesors\n+     we need to visit first.  */\n+  for (n = 0; n < n_basic_blocks; n++)\n+    {\n+      basic_block bb = BASIC_BLOCK (n);\n+      if (BLOCK_INFO (bb)->tovisit)\n+\t{\n+\t  int count = 0;\n+\t  for (e = bb->pred; e; e = e->pred_next)\n+\t    if (BLOCK_INFO (e->src)->tovisit && !(e->flags & EDGE_DFS_BACK))\n+\t      count++;\n+\t    else if (BLOCK_INFO (e->src)->tovisit\n+\t\t     && rtl_dump_file && !EDGE_INFO (e)->back_edge)\n+\t      fprintf (rtl_dump_file,\n+\t\t       \"Irreducible region hit, ignoring edge to %i->%i\\n\",\n+\t\t       e->src->index, bb->index);\n+\t  BLOCK_INFO (bb)->npredecesors = count;\n+\t}\n+    }\n \n   BLOCK_INFO (head)->frequency = 1;\n   for (; bb; bb = nextbb)\n@@ -646,31 +670,16 @@ propagate_freq (head)\n       /* Compute frequency of basic block.  */\n       if (bb != head)\n \t{\n+#ifdef ENABLE_CHECKING\n \t  for (e = bb->pred; e; e = e->pred_next)\n-\t    if (!BLOCK_INFO (e->src)->visited && !(e->flags & EDGE_DFS_BACK))\n-\t      break;\n-\n-\t  /* We haven't proceeded all predecessors of edge e yet.  */\n-\t  if (e)\n-\t    {\n-\t      if (!nextbb)\n-\t\tnextbb = e->dest;\n-\t      else\n-\t\tBLOCK_INFO (last)->next = e->dest;\n-\t      last = e->dest;\n-\t      continue;\n-\t    }\n-\t  if (rtl_dump_file)\n-\t    for (e = bb->pred; e; e = e->pred_next)\n-\t      if (!BLOCK_INFO (e->src)->visited && !EDGE_INFO (e)->back_edge)\n-\t\tfprintf (rtl_dump_file,\n-\t\t\t \"Irreducible region hit, ignoring edge to %i->%i\\n\",\n-\t\t\t e->src->index, bb->index);\n+\t    if (BLOCK_INFO (e->src)->tovisit && !(e->flags & EDGE_DFS_BACK))\n+\t      abort ();\n+#endif\n \n \t  for (e = bb->pred; e; e = e->pred_next)\n \t    if (EDGE_INFO (e)->back_edge)\n \t      cyclic_probability += EDGE_INFO (e)->back_edge_prob;\n-\t    else if (BLOCK_INFO (e->src)->visited)\n+\t    else if (!(e->flags & EDGE_DFS_BACK))\n \t      frequency += (e->probability\n \t\t\t    * BLOCK_INFO (e->src)->frequency /\n \t\t\t    REG_BR_PROB_BASE);\n@@ -681,7 +690,7 @@ propagate_freq (head)\n \t  BLOCK_INFO (bb)->frequency = frequency / (1 - cyclic_probability);\n \t}\n \n-      BLOCK_INFO (bb)->visited = 1;\n+      BLOCK_INFO (bb)->tovisit = 0;\n \n       /* Compute back edge frequencies.  */\n       for (e = bb->succ; e; e = e->succ_next)\n@@ -692,16 +701,19 @@ propagate_freq (head)\n \n       /* Propagate to successor blocks.  */\n       for (e = bb->succ; e; e = e->succ_next)\n-\tif (!EDGE_INFO (e)->back_edge\n-\t    && !BLOCK_INFO (e->dest)->visited\n-\t    && !BLOCK_INFO (e->dest)->next && e->dest != last)\n+\tif (!(e->flags & EDGE_DFS_BACK)\n+\t    && BLOCK_INFO (e->dest)->npredecesors)\n \t  {\n-\t    if (!nextbb)\n-\t      nextbb = e->dest;\n-\t    else\n-\t      BLOCK_INFO (last)->next = e->dest;\n-\t    last = e->dest;\n-\t  }\n+\t    BLOCK_INFO (e->dest)->npredecesors--;\n+\t    if (!BLOCK_INFO (e->dest)->npredecesors)\n+\t      {\n+\t\tif (!nextbb)\n+\t\t  nextbb = e->dest;\n+\t\telse\n+\t\t  BLOCK_INFO (last)->next = e->dest;\n+\t\tlast = e->dest;\n+\t      }\n+\t   }\n     }\n }\n \n@@ -739,8 +751,8 @@ estimate_loops_at_level (first_loop)\n       for (l = loop->shared ? first_loop : loop; l != loop->next; l = l->next)\n \tif (loop->header == l->header)\n \t  EXECUTE_IF_SET_IN_SBITMAP (l->nodes, 0, n,\n-\t\t\t\t     BLOCK_INFO (BASIC_BLOCK (n))->visited =\n-\t\t\t\t     0);\n+\t\t\t\t     BLOCK_INFO (BASIC_BLOCK (n))->tovisit = 1\n+\t\t\t\t     );\n       propagate_freq (loop->header);\n     }\n }\n@@ -848,7 +860,7 @@ estimate_bb_frequencies (loops)\n       else\n \tbb = BASIC_BLOCK (i);\n       bb->aux = bi + i + 2;\n-      BLOCK_INFO (bb)->visited = 1;\n+      BLOCK_INFO (bb)->tovisit = 0;\n       for (e = bb->succ; e; e = e->succ_next)\n \t{\n \t  e->aux = ei + edgenum, edgenum++;\n@@ -862,9 +874,9 @@ estimate_bb_frequencies (loops)\n \n   /* Now fake loop around whole function to finalize probabilities.  */\n   for (i = 0; i < n_basic_blocks; i++)\n-    BLOCK_INFO (BASIC_BLOCK (i))->visited = 0;\n-  BLOCK_INFO (ENTRY_BLOCK_PTR)->visited = 0;\n-  BLOCK_INFO (EXIT_BLOCK_PTR)->visited = 0;\n+    BLOCK_INFO (BASIC_BLOCK (i))->tovisit = 1;\n+  BLOCK_INFO (ENTRY_BLOCK_PTR)->tovisit = 1;\n+  BLOCK_INFO (EXIT_BLOCK_PTR)->tovisit = 1;\n   propagate_freq (ENTRY_BLOCK_PTR);\n \n   for (i = 0; i < n_basic_blocks; i++)"}, {"sha": "4898926d6f4a1a9151544b08d2e12497fd03c427", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/247a370b4f2f91d4b82c66902d46649e57b1ec91/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/247a370b4f2f91d4b82c66902d46649e57b1ec91/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=247a370b4f2f91d4b82c66902d46649e57b1ec91", "patch": "@@ -3608,6 +3608,7 @@ rest_of_compilation (decl)\n       close_dump_file (DFI_bbro, print_rtl_with_bb, insns);\n       timevar_pop (TV_REORDER_BLOCKS);\n     }\n+  compute_alignments ();\n \n   /* If a machine dependent reorganization is needed, call it.  */\n #ifdef MACHINE_DEPENDENT_REORG"}]}