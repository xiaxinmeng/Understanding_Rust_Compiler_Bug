{"sha": "8a0afbb3bcf9d7eda08a2434e631ca450f14b4bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGEwYWZiYjNiY2Y5ZDdlZGEwOGEyNDM0ZTYzMWNhNDUwZjE0YjRiZA==", "commit": {"author": {"name": "Chris Smith", "email": "cks@gnu.org", "date": "1993-05-18T16:26:02Z"}, "committer": {"name": "Chris Smith", "email": "cks@gnu.org", "date": "1993-05-18T16:26:02Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r4495", "tree": {"sha": "43718569bccbba98d6b51e1b70692900f6280ee0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43718569bccbba98d6b51e1b70692900f6280ee0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a0afbb3bcf9d7eda08a2434e631ca450f14b4bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a0afbb3bcf9d7eda08a2434e631ca450f14b4bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a0afbb3bcf9d7eda08a2434e631ca450f14b4bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a0afbb3bcf9d7eda08a2434e631ca450f14b4bd/comments", "author": null, "committer": null, "parents": [{"sha": "514000b5d45ad4e3de6f60b184a996b58462c9e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/514000b5d45ad4e3de6f60b184a996b58462c9e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/514000b5d45ad4e3de6f60b184a996b58462c9e1"}], "stats": {"total": 374, "additions": 11, "deletions": 363}, "files": [{"sha": "2595e198f20861320eab55fb3f71a19eecba50e8", "filename": "gcc/config/convex/convex.c", "status": "modified", "additions": 11, "deletions": 363, "changes": 374, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a0afbb3bcf9d7eda08a2434e631ca450f14b4bd/gcc%2Fconfig%2Fconvex%2Fconvex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a0afbb3bcf9d7eda08a2434e631ca450f14b4bd/gcc%2Fconfig%2Fconvex%2Fconvex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fconvex%2Fconvex.c?ref=8a0afbb3bcf9d7eda08a2434e631ca450f14b4bd", "patch": "@@ -622,396 +622,44 @@ outfloat (file, value, fmt, pfx, sfx)\n \n replace_arg_pushes ()\n {\n-  end_sequence ();\n-  replace_arg_pushes_1 ();\n-  start_sequence ();\n-}\n-\n-replace_arg_pushes_1 ()\n-{\n-  rtx insn, argblock;\n-  int size;\n-  int n;\n-\n-  /* Look back to see if we are at the return at the end of the function. */\n-  n = 0;\n-  for (insn = get_last_insn (); ; insn = PREV_INSN (insn))\n-    if (! insn || ++n > 5)\n-      return;\n-    else if (GET_CODE (insn) == NOTE\n-\t     && NOTE_LINE_NUMBER (insn) == NOTE_INSN_FUNCTION_END)\n-      break;\n-\n-  /* Yes, we are.  Find the max stack depth used by fixable arg pushes. */\n-  size = replace_pushes (0);\n-\n-  /* Allocate block in frame to hold all arg lists. */\n-  argblock = assign_stack_local (BLKmode, size, STACK_BOUNDARY);\n-  \n-  /* Replace pushes with stores into the block. */\n-  replace_pushes (plus_constant (XEXP (argblock, 0), size));\n-}\n-\n-int\n-replace_pushes (arg_addr)\n-     rtx arg_addr;\n-{\n-  struct slot_info { rtx insn; int offs; int size; };\n-#define MAXSLOTS 1024\n-  struct slot_info slots[MAXSLOTS];\n-  rtx insn, pattern, dest;\n-  enum machine_mode mode;\n-  int offs, minoffs;\n-  int nslot, islot;\n-  int args_size, slots_size;\n-  \n-  nslot = 0;\n-  offs = 0;\n-  minoffs = 0;\n-\n-  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    switch (GET_CODE (insn))\n-      {\n-      case INSN:\n-\tpattern = PATTERN (insn);\n-\tif (GET_CODE (pattern) == SET)\n-\t  {\n-\t    dest = SET_DEST (pattern);\n-\t    mode = GET_MODE (dest);\n-\t    if (push_operand (dest, mode))\n-\t      {\n-\t\toffs -= \n-\t\t  slots[nslot].size = PUSH_ROUNDING (GET_MODE_SIZE (mode));\n-\t\tslots[nslot].offs = offs;\n-\t\tslots[nslot].insn = insn;\n-\t\tnslot++;\n-\t      }\n-\t    else if (dest == stack_pointer_rtx)\n-\t      {\n-\t\trtx src = SET_SRC (pattern);\n-\t\tif (GET_CODE (src) == PLUS\n-\t\t    && XEXP (src, 0) == stack_pointer_rtx\n-\t\t    && GET_CODE (XEXP (src, 1)) == CONST_INT)\n-\t\t  {\n-\t\t    offs -=\n-\t\t      slots[nslot].size = - INTVAL (XEXP (src, 1));\n-\t\t    slots[nslot].offs = 0;\n-\t\t    slots[nslot].insn = insn;\n-\t\t    nslot++;\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    slots[nslot].size = 0;\n-\t\t    slots[nslot].offs = 0;\n-\t\t    slots[nslot].insn = 0;\n-\t\t    nslot++;\n-\t\t  }\n-\t      }\n-\t    else if (reg_mentioned_p (stack_pointer_rtx, pattern))\n-\t      {\n-\t\tslots[nslot].size = 0;\n-\t\tslots[nslot].offs = 0;\n-\t\tslots[nslot].insn = 0;\n-\t\tnslot++;\n-\t      }\n-\t    else if (reg_mentioned_p (virtual_stack_dynamic_rtx, pattern)\n-\t\t     || reg_mentioned_p (virtual_outgoing_args_rtx, pattern))\n-\t      {\n-\t\tslots[nslot].size = 0;\n-\t\tslots[nslot].offs = 0;\n-\t\tslots[nslot].insn = 0;\n-\t\tnslot++;\n-\t      }\n-\t  }\n-\telse\n-\t  if (reg_mentioned_p (stack_pointer_rtx, pattern)\n-\t      || reg_mentioned_p (virtual_stack_dynamic_rtx, pattern)\n-\t      || reg_mentioned_p (virtual_outgoing_args_rtx, pattern)\n-\t      || reg_mentioned_p (frame_pointer_rtx, pattern))\n-\t    abort ();\n-\n-\tbreak;\n-\n-      case CALL_INSN:\n-\t{\n-\t  pattern = PATTERN (insn);\n-\t  if (GET_CODE (pattern) != PARALLEL)\n-\t    abort ();\n-\t  pattern = XVECEXP (pattern, 0, 0);\n-\t  if (GET_CODE (pattern) == SET)\n-\t    pattern = SET_SRC (pattern);\n-\t  if (GET_CODE (pattern) != CALL)\n-\t    abort ();\n-\t  args_size = INTVAL (XEXP (pattern, 1));\n-\n-\t  slots_size = 0;\n-\t  for (islot = nslot; islot > 0; islot--)\n-\t    {\n-\t      if (slots[islot - 1].insn == 0)\n-\t\tbreak;\n-\t      if (slots_size >= args_size)\n-\t\tbreak;\n-\t      slots_size += slots[islot - 1].size;\n-\t    }\n-\n-\t  if (slots_size != args_size)\n-\t    {\n-\t      offs += args_size;\n-\t      if (offs > 0)\n-\t\toffs = 0;\n-\t      slots[nslot].size = 0;\n-\t      slots[nslot].offs = 0;\n-\t      slots[nslot].insn = 0;\n-\t      nslot++;\n-\n-\t      if (arg_addr)\n-\t\t{\n-\t\t  /* add insn to pop arg list if left on stack */\n-\t\t  rtx pop_size = XVECEXP (PATTERN (insn), 0, 2);\n-\t\t  if (pop_size != const0_rtx)\n-\t\t    emit_insn_after (gen_addsi3 (stack_pointer_rtx,\n-\t\t\t\t\t\t stack_pointer_rtx,\n-\t\t\t\t\t\t pop_size),\n-\t\t\t\t     insn);\n-\t\t  insn = NEXT_INSN (insn);\n-\t\t}\n-\t      break;\n-\t    }\n-\n-\t  /* Record size of arg block */\n-\t  if (offs < minoffs)\n-\t    minoffs = offs;\n-\n-\t  /*printf (\"call %d, args\", INSN_UID (insn));*/\n-\t  if (arg_addr)\n-\t    {\n-\t      /* store arg block + offset as arg list address for call */\n-\t      XVECEXP (PATTERN (insn), 0, 3) = plus_constant (arg_addr, offs);\n-\n-\t      /* rewrite arg instructions to use block */\n-\t      while (nslot > islot)\n-\t\t{\n-\t\t  nslot--;\n-\t\t  /*printf (\" insn %d size %d offs %d\",\n-\t\t\t  INSN_UID(slots[nslot].insn),\n-\t\t\t  slots[nslot].size,\n-\t\t\t  slots[nslot].offs);*/\n-\n-\t\t  if (slots[nslot].offs == 0)\n-\t\t    delete_insn (slots[nslot].insn);\n-\t\t  else\n-\t\t    {\n-\t\t      rtx pattern = PATTERN (slots[nslot].insn);\n-\t\t      enum machine_mode mode = GET_MODE (SET_DEST (pattern));\n-\t\t      if (GET_MODE_SIZE (mode) < GET_MODE_SIZE (SImode))\n-\t\t\t{\n-\t\t\t  SET_SRC (pattern) =\n-\t\t\t    gen_lowpart (SImode, SET_SRC (pattern));\n-\t\t\t  SET_DEST (pattern) =\n-\t\t\t    gen_rtx (MEM, SImode,\n-\t\t\t\t     plus_constant (arg_addr,\n-\t\t\t\t\t\t    slots[nslot].offs));\n-\t\t\t}\n-\t\t      else\n-\t\t\tSET_DEST (pattern) = \n-\t\t\t  gen_rtx (MEM, mode,\n-\t\t\t\t   plus_constant (arg_addr,\n-\t\t\t\t\t\t  slots[nslot].offs));\n-\t\t    }\n-\t\t}\n-\t      /*printf (\"\\n\");*/\n-\t    }\n-\n-\t  nslot = islot;\n-\n-\t  offs += args_size;\n-\t  if (offs > 0)\n-\t    abort ();\n-\t}\n-\tbreak;\n-\n-      case CODE_LABEL:\n-      case JUMP_INSN:\n-      case BARRIER:\n-\tnslot = offs = 0;\n-      }\n-\n-  /*printf (\"min offset %d\\n\", minoffs);*/\n-  return -minoffs;\n+  /* Doesn't work yet. */\n }\n \n /* Output the insns needed to do a call.  operands[] are\n      0 - MEM, the place to call\n      1 - CONST_INT, the number of bytes in the arg list\n      2 - CONST_INT, the number of arguments\n-     3 - address of the arg list.  \n+     3 - CONST_INT, the number of bytes to pop\n+     4 - address of the arg list.  \n  */\n \n char *\n output_call (insn, operands)\n      rtx insn, *operands;\n {\n-  /*if (operands[3] == stack_pointer_rtx)\n-    output_asm_insn (\"mov sp,ap\");\n+  if (operands[4] == stack_pointer_rtx)\n+    output_asm_insn (\"mov sp,ap\", operands);\n   else\n-    output_asm_insn (\"ldea %a4,ap\", operands);*/\n+    abort ();\n \n   if (TARGET_ARGCOUNT)\n     output_asm_insn (\"pshea %a2\", operands);\n \n   output_asm_insn (\"calls %0\", operands);\n \n-  /*output_asm_insn (\"ld.w 12(fp),ap\");*/\n+  output_asm_insn (\"ld.w 12(fp),ap\", operands);\n \n-  /*if (operands[3] == stack_pointer_rtx && operands[1] != const0_rtx)\n-    output_asm_insn (\"add.w %1,sp\", operands);*/\n+  if (operands[4] == stack_pointer_rtx && operands[3] != const0_rtx)\n+    output_asm_insn (\"add.w %3,sp\", operands);\n \n   return \"\";\n }\n \n \n-/* Here after reloading, before the second scheduling pass.\n-   Insert explicit AP moves. */\n+/* Here after reloading, before the second scheduling pass. */\n \n emit_ap_optimizations ()\n {\n-  end_sequence ();\n-  insert_ap_loads ();\n-  start_sequence ();\n+  /* Removed for now. */\n }\n \n-#define LABEL_DEAD_AP(INSN) ((INSN)->volatil)\n-\n-insert_ap_loads ()\n-{\n-  rtx insn, pattern, src;\n-  int ap_is_live, doagain;\n-\n-  /* Check that code_label->volatil is not being used for something else */\n-\n-  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    if (GET_CODE (insn) == CODE_LABEL)\n-      if (LABEL_DEAD_AP (insn))\n-\tabort ();\n-\n-  ap_is_live = 0;\n-\n-  do\n-    {\n-      doagain = 0;\n-      for (insn = get_last_insn (); insn; insn = PREV_INSN (insn))\n-\tswitch (GET_CODE (insn))\n-\t  {\n-\t  case INSN:\n-\t    pattern = PATTERN (insn);\n-\t    if (! ap_is_live)\n-\t      {\n-\t\tif (reg_mentioned_p (arg_pointer_rtx, pattern))\n-\t\t  ap_is_live = 1;\n-\t      }\n-\t    break;\n-\n-\t  case CALL_INSN:\n-\t    pattern = PATTERN (insn);\n-\t    if (XVECEXP (pattern, 0, 2) != const0_rtx)\n-\t      ap_is_live = reg_mentioned_p (arg_pointer_rtx, pattern);\n-\t    break;\n-\n-\t  case CODE_LABEL:\n-\t    if (! ap_is_live)\n-\t      {\n-\t\tif (! LABEL_DEAD_AP (insn))\n-\t\t  doagain = 1;\n-\t\tLABEL_DEAD_AP (insn) = 1;\n-\t      }\n-\t    break;\n-\n-\t  case JUMP_INSN:\n-\t    pattern = PATTERN (insn);\n-\t    if (GET_CODE (pattern) == RETURN)\n-\t      ap_is_live = 0;\n-\t    else if (JUMP_LABEL (insn))\n-\t      {\n-\t\tif (simplejump_p (insn))\n-\t\t  ap_is_live = ! LABEL_DEAD_AP (JUMP_LABEL (insn));\n-\t\telse if (! ap_is_live && condjump_p (insn))\n-\t\t  ap_is_live = ! LABEL_DEAD_AP (JUMP_LABEL (insn));\n-\t\telse\n-\t\t  ap_is_live = 1;\n-\t      }\n-\t    else\n-\t      ap_is_live = 1;\n-\t    break;\n-\n-\t  case BARRIER:\n-\t    ap_is_live = 0;\n-\t    break;\n-\t  }\n-    } while (doagain);\n-\n-  ap_is_live = 0;\n-\n-  for (insn = get_last_insn (); insn; insn = PREV_INSN (insn))\n-    switch (GET_CODE (insn))\n-      {\n-      case INSN:\n-\tpattern = PATTERN (insn);\n-\tif (! ap_is_live)\n-\t  {\n-\t    if (reg_mentioned_p (arg_pointer_rtx, pattern))\n-\t      ap_is_live = 1;\n-\t  }\n-\tbreak;\n-\n-      case CALL_INSN:\n-\tpattern = PATTERN (insn);\n-\tif (XVECEXP (pattern, 0, 2) != const0_rtx)\n-\t  {\n-\t    rtx arg_addr = XVECEXP (pattern, 0, 3);\n-\t    emit_insn_before (gen_movsi (arg_pointer_rtx, arg_addr), insn);\n-\t    if (ap_is_live)\n-\t      emit_insn_after (gen_movsi (arg_pointer_rtx,\n-\t\t\t\t\t  gen_rtx (MEM, SImode,\n-\t\t\t\t\t\t   gen_rtx (PLUS, Pmode,\n-\t\t\t\t\t\t\t    frame_pointer_rtx,\n-\t\t\t\t\t\t\t    GEN_INT (12)))),\n-\t\t\t       insn);\n-\t    XVECEXP (pattern, 0, 3) = const0_rtx;\n-\t    insn = PREV_INSN (insn);\n-\t    ap_is_live = 0;\n-\t  }\n-\tbreak;\n-\n-      case CODE_LABEL:\n-\tif (ap_is_live != ! LABEL_DEAD_AP (insn))\n-\t  abort ();\n-\tbreak;\n-\n-      case JUMP_INSN:\n-\tpattern = PATTERN (insn);\n-\tif (GET_CODE (pattern) == RETURN)\n-\t  ap_is_live = 0;\n-\telse if (JUMP_LABEL (insn))\n-\t  {\n-\t    if (simplejump_p (insn))\n-\t      ap_is_live = ! LABEL_DEAD_AP (JUMP_LABEL (insn));\n-\t    else if (! ap_is_live && condjump_p (insn))\n-\t      ap_is_live = ! LABEL_DEAD_AP (JUMP_LABEL (insn));\n-\t    else\n-\t      ap_is_live = 1;\n-\t  }\n-\telse\n-\t  ap_is_live = 1;\n-\tbreak;\n-\n-      case BARRIER:\n-\tap_is_live = 0;\n-\tbreak;\n-      }\n-\n-  /* Clear code-label flag recording dead ap's. */\n-\n-  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    if (GET_CODE (insn) == CODE_LABEL)\n-      LABEL_DEAD_AP (insn) = 0;\n-}"}]}