{"sha": "58fb912c15175f4444144b8a4ab52a4880b84994", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NThmYjkxMmMxNTE3NWY0NDQ0MTQ0YjhhNGFiNTJhNDg4MGI4NDk5NA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-12-21T22:36:25Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-12-22T02:13:41Z"}, "message": "c++: Fix demangling of <unresolved-name>\n\nThe ABI for unresolved scoped names on the RHS of . and -> used to be\n\n  sr <type> <unqualified-id>\n\nThat changed years ago to something more complex, but G++ was never updated.\nThis change was particularly incompatible for simple qualified-ids like\nA::x, which were previously mangled as sr1A1x, and now sr1AE1x.\n\nThis obviously makes life hard for demanglers, which can't know whether to\nconsume that E or not.  To work around this, we now try demangling with the\nnewer ABI, and if that fails and we saw an \"sr\", try again with the older\nABI.\n\nlibiberty/ChangeLog:\n\n\tPR c++/67343\n\t* cp-demangle.h (struct d_info): Add unresolved_name_state.\n\t* cp-demangle.c (d_prefix): Add subst parm.\n\t(d_nested_name): Pass it.\n\t(d_unresolved_name): Split out from...\n\t(d_expression_1): ...here.\n\t(d_demangle_callback): Maybe retry with old sr mangling.\n\t* testsuite/demangle-expected: Add test.", "tree": {"sha": "30eb36cd8436ac5f9d9dc3d0b4f4e56018450252", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/30eb36cd8436ac5f9d9dc3d0b4f4e56018450252"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58fb912c15175f4444144b8a4ab52a4880b84994", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58fb912c15175f4444144b8a4ab52a4880b84994", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58fb912c15175f4444144b8a4ab52a4880b84994", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58fb912c15175f4444144b8a4ab52a4880b84994/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93ac0c05ffc84acba8e73ed5238fc325044378e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93ac0c05ffc84acba8e73ed5238fc325044378e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93ac0c05ffc84acba8e73ed5238fc325044378e0"}], "stats": {"total": 94, "additions": 72, "deletions": 22}, "files": [{"sha": "52427275f449da11271f0e70ba523fd5b4f5b77f", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 65, "deletions": 22, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58fb912c15175f4444144b8a4ab52a4880b84994/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58fb912c15175f4444144b8a4ab52a4880b84994/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=58fb912c15175f4444144b8a4ab52a4880b84994", "patch": "@@ -429,7 +429,7 @@ static struct demangle_component *d_name (struct d_info *);\n \n static struct demangle_component *d_nested_name (struct d_info *);\n \n-static struct demangle_component *d_prefix (struct d_info *);\n+static struct demangle_component *d_prefix (struct d_info *, int);\n \n static struct demangle_component *d_unqualified_name (struct d_info *);\n \n@@ -1510,7 +1510,7 @@ d_nested_name (struct d_info *di)\n      once we have something to attach it to.  */\n   rqual = d_ref_qualifier (di, NULL);\n \n-  *pret = d_prefix (di);\n+  *pret = d_prefix (di, 1);\n   if (*pret == NULL)\n     return NULL;\n \n@@ -1536,10 +1536,12 @@ d_nested_name (struct d_info *di)\n    <template-prefix> ::= <prefix> <(template) unqualified-name>\n                      ::= <template-param>\n                      ::= <substitution>\n-*/\n+\n+   SUBST is true if we should add substitutions (as normal), false\n+   if not (in an unresolved-name).  */\n \n static struct demangle_component *\n-d_prefix (struct d_info *di)\n+d_prefix (struct d_info *di, int subst)\n {\n   struct demangle_component *ret = NULL;\n \n@@ -1605,7 +1607,7 @@ d_prefix (struct d_info *di)\n       else\n \tret = d_make_comp (di, comb_type, ret, dc);\n \n-      if (peek != 'S' && d_peek_char (di) != 'E')\n+      if (peek != 'S' && d_peek_char (di) != 'E' && subst)\n \t{\n \t  if (! d_add_substitution (di, ret))\n \t    return NULL;\n@@ -3291,14 +3293,58 @@ op_is_new_cast (struct demangle_component *op)\n \t      || code[0] == 'c' || code[0] == 'r'));\n }\n \n+/*   <unresolved-name> ::= [gs] <base-unresolved-name> # x or (with \"gs\") ::x\n+       ::= sr <unresolved-type> <base-unresolved-name> # T::x / decltype(p)::x\n+       # T::N::x /decltype(p)::N::x\n+       ::= srN <unresolved-type> <unresolved-qualifier-level>+ E <base-unresolved-name>\n+       # A::x, N::y, A<T>::z; \"gs\" means leading \"::\"\n+       ::= [gs] sr <unresolved-qualifier-level>+ E <base-unresolved-name>\n+\n+     \"gs\" is handled elsewhere, as a unary operator.  */\n+\n+static struct demangle_component *\n+d_unresolved_name (struct d_info *di)\n+{\n+  struct demangle_component *type;\n+  struct demangle_component *name;\n+  char peek;\n+\n+  /* Consume the \"sr\".  */\n+  d_advance (di, 2);\n+\n+  peek = d_peek_char (di);\n+  if (di->unresolved_name_state\n+      && (IS_DIGIT (peek)\n+\t  || IS_LOWER (peek)\n+\t  || peek == 'C'\n+\t  || peek == 'U'\n+\t  || peek == 'L'))\n+    {\n+      /* The third production is ambiguous with the old unresolved-name syntax\n+\t of <type> <base-unresolved-name>; in the old mangling, A::x was mangled\n+\t as sr1A1x, now sr1AE1x.  So we first try to demangle using the new\n+\t mangling, then with the old if that fails.  */\n+      di->unresolved_name_state = -1;\n+      type = d_prefix (di, 0);\n+      if (d_peek_char (di) == 'E')\n+\td_advance (di, 1);\n+    }\n+  else\n+    type = cplus_demangle_type (di);\n+  name = d_unqualified_name (di);\n+  if (d_peek_char (di) == 'I')\n+    name = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, name,\n+\t\t\td_template_args (di));\n+  return d_make_comp (di, DEMANGLE_COMPONENT_QUAL_NAME, type, name);\n+}\n+\n /* <expression> ::= <(unary) operator-name> <expression>\n                 ::= <(binary) operator-name> <expression> <expression>\n                 ::= <(trinary) operator-name> <expression> <expression> <expression>\n \t\t::= cl <expression>+ E\n                 ::= st <type>\n                 ::= <template-param>\n-                ::= sr <type> <unqualified-name>\n-                ::= sr <type> <unqualified-name> <template-args>\n+\t\t::= <unresolved-name>\n                 ::= <expr-primary>\n \n   <braced-expression> ::= <expression>\n@@ -3308,7 +3354,7 @@ op_is_new_cast (struct demangle_component *op)\n \t\t\t\t\t\t\t\t\t# [expr ... expr] = expr\n */\n \n-static inline struct demangle_component *\n+static struct demangle_component *\n d_expression_1 (struct d_info *di)\n {\n   char peek;\n@@ -3319,20 +3365,7 @@ d_expression_1 (struct d_info *di)\n   else if (peek == 'T')\n     return d_template_param (di);\n   else if (peek == 's' && d_peek_next_char (di) == 'r')\n-    {\n-      struct demangle_component *type;\n-      struct demangle_component *name;\n-\n-      d_advance (di, 2);\n-      type = cplus_demangle_type (di);\n-      name = d_unqualified_name (di);\n-      if (d_peek_char (di) != 'I')\n-\treturn d_make_comp (di, DEMANGLE_COMPONENT_QUAL_NAME, type, name);\n-      else\n-\treturn d_make_comp (di, DEMANGLE_COMPONENT_QUAL_NAME, type,\n-\t\t\t    d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, name,\n-\t\t\t\t\t d_template_args (di)));\n-    }\n+    return d_unresolved_name (di);\n   else if (peek == 's' && d_peek_next_char (di) == 'p')\n     {\n       d_advance (di, 2);\n@@ -6397,6 +6430,9 @@ d_demangle_callback (const char *mangled, int options,\n       type = DCT_TYPE;\n     }\n \n+  di.unresolved_name_state = 1;\n+\n+ again:\n   cplus_demangle_init_info (mangled, options, strlen (mangled), &di);\n \n   /* PR 87675 - Check for a mangled string that is so long\n@@ -6455,6 +6491,13 @@ d_demangle_callback (const char *mangled, int options,\n     if (((options & DMGL_PARAMS) != 0) && d_peek_char (&di) != '\\0')\n       dc = NULL;\n \n+    /* See discussion in d_unresolved_name.  */\n+    if (dc == NULL && di.unresolved_name_state == -1)\n+      {\n+\tdi.unresolved_name_state = 0;\n+\tgoto again;\n+      }\n+\n #ifdef CP_DEMANGLE_DEBUG\n     d_dump (dc, 0);\n #endif"}, {"sha": "27014cde25866f199dbd639a032ecbe115110d68", "filename": "libiberty/cp-demangle.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58fb912c15175f4444144b8a4ab52a4880b84994/libiberty%2Fcp-demangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58fb912c15175f4444144b8a4ab52a4880b84994/libiberty%2Fcp-demangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.h?ref=58fb912c15175f4444144b8a4ab52a4880b84994", "patch": "@@ -122,6 +122,10 @@ struct d_info\n   /* Non-zero if we are parsing the type operand of a conversion\n      operator, but not when in an expression.  */\n   int is_conversion;\n+  /*  1: using new unresolved-name grammar.\n+     -1: using new unresolved-name grammar and saw an unresolved-name.\n+      0: using old unresolved-name grammar.  */\n+  int unresolved_name_state;\n   /* If DMGL_NO_RECURSE_LIMIT is not active then this is set to\n      the current recursion level.  */\n   unsigned int recursion_level;"}, {"sha": "e6b5b64b9a9bc31a1cbf75b80e4b25407116dd82", "filename": "libiberty/testsuite/demangle-expected", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58fb912c15175f4444144b8a4ab52a4880b84994/libiberty%2Ftestsuite%2Fdemangle-expected", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58fb912c15175f4444144b8a4ab52a4880b84994/libiberty%2Ftestsuite%2Fdemangle-expected", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ftestsuite%2Fdemangle-expected?ref=58fb912c15175f4444144b8a4ab52a4880b84994", "patch": "@@ -1485,3 +1485,6 @@ decltype (({parm#1}.(operator A*))()) j<A>(A)\n \n _Z1fI1AEDtdtfp_srT_1xES1_\n decltype ({parm#1}.A::x) f<A>(A)\n+\n+_Z2f6IP1AEDtptfp_gssr1A1BE1xET_\n+decltype ({parm#1}->(::A::B::x)) f6<A*>(A*)"}]}