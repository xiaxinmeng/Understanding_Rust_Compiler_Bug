{"sha": "edf6ddf6775b07472f2dbaeb3b9511fd2ab0e902", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWRmNmRkZjY3NzViMDc0NzJmMmRiYWViM2I5NTExZmQyYWIwZTkwMg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-05-26T08:19:02Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-05-26T08:19:02Z"}, "message": "configure.ac: Remove long long and __int64 type checks...\n\n2014-05-26  Richard Biener  <rguenther@suse.de>\n\n\tlibcpp/\n\t* configure.ac: Remove long long and __int64 type checks,\n\tadd check for uint64_t and fail if that wasn't found.\n\t* include/cpplib.h (cpp_num_part): Use uint64_t.\n\t* config.in: Regenerate.\n\t* configure: Likewise.\n\n\tgcc/\n\t* configure.ac: Drop __int64 type check.  Insist that we\n\tfound uint64_t and int64_t.\n\t* hwint.h (HOST_BITS_PER___INT64): Remove.\n\t(HOST_BITS_PER_WIDE_INT): Define to 64 and remove\n\t__int64 case.\n\t(HOST_WIDE_INT_PRINT_*): Remove 32bit case.\n\t(HOST_WIDEST_INT*): Define to HOST_WIDE_INT*.\n\t(HOST_WIDEST_FAST_INT): Remove __int64 case.\n\t* vmsdbg.h (struct _DST_SRC_COMMAND): Use int64_t\n\tfor dst_q_src_df_rms_cdt.\n\t* configure: Regenerate.\n\t* config.in: Likewise.\n\nFrom-SVN: r210928", "tree": {"sha": "e28b8ab33b2de7eaa12479bdb8dfb1291a7f26d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e28b8ab33b2de7eaa12479bdb8dfb1291a7f26d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/edf6ddf6775b07472f2dbaeb3b9511fd2ab0e902", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edf6ddf6775b07472f2dbaeb3b9511fd2ab0e902", "html_url": "https://github.com/Rust-GCC/gccrs/commit/edf6ddf6775b07472f2dbaeb3b9511fd2ab0e902", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edf6ddf6775b07472f2dbaeb3b9511fd2ab0e902/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "49f002b654154f65320b984ac91ebe07d3891da3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49f002b654154f65320b984ac91ebe07d3891da3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49f002b654154f65320b984ac91ebe07d3891da3"}], "stats": {"total": 390, "additions": 138, "deletions": 252}, "files": [{"sha": "d994917ac731bfb804f739e7c6044aa7ac128fe4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edf6ddf6775b07472f2dbaeb3b9511fd2ab0e902/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edf6ddf6775b07472f2dbaeb3b9511fd2ab0e902/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=edf6ddf6775b07472f2dbaeb3b9511fd2ab0e902", "patch": "@@ -1,3 +1,18 @@\n+2014-05-26  Richard Biener  <rguenther@suse.de>\n+\n+\t* configure.ac: Drop __int64 type check.  Insist that we\n+\tfound uint64_t and int64_t.\n+\t* hwint.h (HOST_BITS_PER___INT64): Remove.\n+\t(HOST_BITS_PER_WIDE_INT): Define to 64 and remove\n+\t__int64 case.\n+\t(HOST_WIDE_INT_PRINT_*): Remove 32bit case.\n+\t(HOST_WIDEST_INT*): Define to HOST_WIDE_INT*.\n+\t(HOST_WIDEST_FAST_INT): Remove __int64 case.\n+\t* vmsdbg.h (struct _DST_SRC_COMMAND): Use int64_t\n+\tfor dst_q_src_df_rms_cdt.\n+\t* configure: Regenerate.\n+\t* config.in: Likewise.\n+\n 2014-05-26  Michael Tautschnig  <mt@debian.org>\n \n \tPR target/61249"}, {"sha": "a3d169be1cbc95eed20df5eddf97dd4f040425ed", "filename": "gcc/config.in", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edf6ddf6775b07472f2dbaeb3b9511fd2ab0e902/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edf6ddf6775b07472f2dbaeb3b9511fd2ab0e902/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=edf6ddf6775b07472f2dbaeb3b9511fd2ab0e902", "patch": "@@ -1655,12 +1655,6 @@\n #endif\n \n \n-/* Define to 1 if the system has the type `__int64'. */\n-#ifndef USED_FOR_TARGET\n-#undef HAVE___INT64\n-#endif\n-\n-\n /* Define if cloog is in use. */\n #ifndef USED_FOR_TARGET\n #undef HAVE_cloog\n@@ -1807,12 +1801,6 @@\n #endif\n \n \n-/* The size of `__int64', as computed by sizeof. */\n-#ifndef USED_FOR_TARGET\n-#undef SIZEOF___INT64\n-#endif\n-\n-\n /* Define to 1 if you have the ANSI C header files. */\n #ifndef USED_FOR_TARGET\n #undef STDC_HEADERS\n@@ -1866,8 +1854,8 @@\n #endif\n \n \n-/* Define to 1 if the 'long long' (or '__int64') is wider than 'long' but\n-   still efficiently supported by the host hardware. */\n+/* Define to 1 if the 'long long' type is wider than 'long' but still\n+   efficiently supported by the host hardware. */\n #ifndef USED_FOR_TARGET\n #undef USE_LONG_LONG_FOR_WIDEST_FAST_INT\n #endif"}, {"sha": "fe76232a56db1dd342ffe879b06efa1df0ea6e0c", "filename": "gcc/configure", "status": "modified", "additions": 5, "deletions": 45, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edf6ddf6775b07472f2dbaeb3b9511fd2ab0e902/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edf6ddf6775b07472f2dbaeb3b9511fd2ab0e902/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=edf6ddf6775b07472f2dbaeb3b9511fd2ab0e902", "patch": "@@ -5860,49 +5860,6 @@ cat >>confdefs.h <<_ACEOF\n _ACEOF\n \n \n-fi\n-\n-ac_fn_c_check_type \"$LINENO\" \"__int64\" \"ac_cv_type___int64\" \"$ac_includes_default\"\n-if test \"x$ac_cv_type___int64\" = x\"\"yes; then :\n-\n-cat >>confdefs.h <<_ACEOF\n-#define HAVE___INT64 1\n-_ACEOF\n-\n-# The cast to long int works around a bug in the HP C Compiler\n-# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects\n-# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.\n-# This bug is HP SR number 8606223364.\n-{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking size of __int64\" >&5\n-$as_echo_n \"checking size of __int64... \" >&6; }\n-if test \"${ac_cv_sizeof___int64+set}\" = set; then :\n-  $as_echo_n \"(cached) \" >&6\n-else\n-  if ac_fn_c_compute_int \"$LINENO\" \"(long int) (sizeof (__int64))\" \"ac_cv_sizeof___int64\"        \"$ac_includes_default\"; then :\n-\n-else\n-  if test \"$ac_cv_type___int64\" = yes; then\n-     { { $as_echo \"$as_me:${as_lineno-$LINENO}: error: in \\`$ac_pwd':\" >&5\n-$as_echo \"$as_me: error: in \\`$ac_pwd':\" >&2;}\n-{ as_fn_set_status 77\n-as_fn_error \"cannot compute sizeof (__int64)\n-See \\`config.log' for more details.\" \"$LINENO\" 5; }; }\n-   else\n-     ac_cv_sizeof___int64=0\n-   fi\n-fi\n-\n-fi\n-{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_sizeof___int64\" >&5\n-$as_echo \"$ac_cv_sizeof___int64\" >&6; }\n-\n-\n-\n-cat >>confdefs.h <<_ACEOF\n-#define SIZEOF___INT64 $ac_cv_sizeof___int64\n-_ACEOF\n-\n-\n fi\n \n ac_fn_c_find_intX_t \"$LINENO\" \"8\" \"ac_cv_c_int8_t\"\n@@ -6269,6 +6226,9 @@ fi\n \n \n \n+if test x\"$ac_cv_c_uint64_t\" = x\"no\" -o x\"$ac_cv_c_int64_t\" = x\"no\"; then\n+  as_fn_error \"uint64_t or int64_t not found\" \"$LINENO\" 5\n+fi\n \n # ---------------------\n # Warnings and checking\n@@ -17988,7 +17948,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 17991 \"configure\"\n+#line 17951 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -18094,7 +18054,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 18097 \"configure\"\n+#line 18057 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H"}, {"sha": "0f8566f933631c10a9513c95612a49200f859711", "filename": "gcc/configure.ac", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edf6ddf6775b07472f2dbaeb3b9511fd2ab0e902/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edf6ddf6775b07472f2dbaeb3b9511fd2ab0e902/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=edf6ddf6775b07472f2dbaeb3b9511fd2ab0e902", "patch": "@@ -311,8 +311,10 @@ AC_CHECK_SIZEOF(short)\n AC_CHECK_SIZEOF(int)\n AC_CHECK_SIZEOF(long)\n AC_CHECK_TYPES([long long], [AC_CHECK_SIZEOF(long long)])\n-AC_CHECK_TYPES([__int64], [AC_CHECK_SIZEOF(__int64)])\n GCC_STDINT_TYPES\n+if test x\"$ac_cv_c_uint64_t\" = x\"no\" -o x\"$ac_cv_c_int64_t\" = x\"no\"; then\n+  AC_MSG_ERROR([uint64_t or int64_t not found])\n+fi\n \n # ---------------------\n # Warnings and checking\n@@ -1374,7 +1376,7 @@ fi\n \n if test x$use_long_long_for_widest_fast_int = xyes; then\n \tAC_DEFINE(USE_LONG_LONG_FOR_WIDEST_FAST_INT, 1,\n-[Define to 1 if the 'long long' (or '__int64') is wider than 'long' but still\n+[Define to 1 if the 'long long' type is wider than 'long' but still\n efficiently supported by the host hardware.])\n fi\n "}, {"sha": "6d2df9d6a996b6a975e3178c24170c879646f966", "filename": "gcc/hwint.h", "status": "modified", "additions": 26, "deletions": 75, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edf6ddf6775b07472f2dbaeb3b9511fd2ab0e902/gcc%2Fhwint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edf6ddf6775b07472f2dbaeb3b9511fd2ab0e902/gcc%2Fhwint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhwint.h?ref=edf6ddf6775b07472f2dbaeb3b9511fd2ab0e902", "patch": "@@ -44,40 +44,28 @@ extern char sizeof_long_long_must_be_8[sizeof (long long) == 8 ? 1 : -1];\n #ifdef HAVE_LONG_LONG\n # define HOST_BITS_PER_LONGLONG (CHAR_BIT * SIZEOF_LONG_LONG)\n #endif\n-#ifdef HAVE___INT64\n-# define HOST_BITS_PER___INT64 (CHAR_BIT * SIZEOF___INT64)\n-#endif\n \n-/* Set HOST_WIDE_INT.  This should be the widest efficient host\n-   integer type.  It can be 32 or 64 bits, except that if we are\n-   targeting a machine with 64-bit size_t then it has to be 64 bits.\n+/* Set HOST_WIDE_INT, this should be always 64 bits.\n \n    With a sane ABI, 'long' is the largest efficient host integer type.\n-   Thus, we use that unless we have to use 'long long' or '__int64'\n-   because we're targeting a 64-bit machine from a 32-bit host.  */\n+   Thus, we use that unless we have to use 'long long'\n+   because we're on a 32-bit host.  */\n \n-#if HOST_BITS_PER_LONG >= 64\n-#   define HOST_BITS_PER_WIDE_INT HOST_BITS_PER_LONG\n+#define HOST_BITS_PER_WIDE_INT 64\n+#if HOST_BITS_PER_LONG == 64\n #   define HOST_WIDE_INT long\n #   define HOST_WIDE_INT_C(X) X ## L\n #else\n-# if HOST_BITS_PER_LONGLONG >= 64\n-#   define HOST_BITS_PER_WIDE_INT HOST_BITS_PER_LONGLONG\n+# if HOST_BITS_PER_LONGLONG == 64\n #   define HOST_WIDE_INT long long\n #   define HOST_WIDE_INT_C(X) X ## LL\n # else\n-#  if HOST_BITS_PER___INT64 >= 64\n-#   define HOST_BITS_PER_WIDE_INT HOST_BITS_PER___INT64\n-#   define HOST_WIDE_INT __int64\n-#   define HOST_WIDE_INT_C(X) X ## i64\n-#  else\n-    #error \"Unable to find a suitable type for HOST_WIDE_INT\"\n-#  endif\n+   #error \"Unable to find a suitable type for HOST_WIDE_INT\"\n # endif\n #endif\n \n /* Print support for half a host wide int.  */\n-#define HOST_BITS_PER_HALF_WIDE_INT (HOST_BITS_PER_WIDE_INT / 2)\n+#define HOST_BITS_PER_HALF_WIDE_INT 32\n #if HOST_BITS_PER_HALF_WIDE_INT == HOST_BITS_PER_LONG\n # define HOST_HALF_WIDE_INT long\n # define HOST_HALF_WIDE_INT_PRINT HOST_LONG_FORMAT\n@@ -126,23 +114,15 @@ typedef HOST_WIDE_INT __gcc_host_wide_int__;\n #if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_LONG\n # define HOST_WIDE_INT_PRINT HOST_LONG_FORMAT\n # define HOST_WIDE_INT_PRINT_C \"L\"\n-  /* 'long' might be 32 or 64 bits, and the number of leading zeroes\n-     must be tweaked accordingly.  */\n-# if HOST_BITS_PER_WIDE_INT == 64\n-#  define HOST_WIDE_INT_PRINT_DOUBLE_HEX \\\n-     \"0x%\" HOST_LONG_FORMAT \"x%016\" HOST_LONG_FORMAT \"x\"\n-#  define HOST_WIDE_INT_PRINT_PADDED_HEX \\\n-     \"%016\" HOST_LONG_FORMAT \"x\"\n-# else\n-#  define HOST_WIDE_INT_PRINT_DOUBLE_HEX \\\n-     \"0x%\" HOST_LONG_FORMAT \"x%08\" HOST_LONG_FORMAT \"x\"\n-#  define HOST_WIDE_INT_PRINT_PADDED_HEX \\\n-     \"%08\" HOST_LONG_FORMAT \"x\"\n-# endif\n+  /* HOST_BITS_PER_WIDE_INT is 64 bits.  */\n+# define HOST_WIDE_INT_PRINT_DOUBLE_HEX \\\n+    \"0x%\" HOST_LONG_FORMAT \"x%016\" HOST_LONG_FORMAT \"x\"\n+# define HOST_WIDE_INT_PRINT_PADDED_HEX \\\n+    \"%016\" HOST_LONG_FORMAT \"x\"\n #else\n # define HOST_WIDE_INT_PRINT HOST_LONG_LONG_FORMAT\n # define HOST_WIDE_INT_PRINT_C \"LL\"\n-  /* We can assume that 'long long' is at least 64 bits.  */\n+  /* HOST_BITS_PER_WIDE_INT is 64 bits.  */\n # define HOST_WIDE_INT_PRINT_DOUBLE_HEX \\\n     \"0x%\" HOST_LONG_LONG_FORMAT \"x%016\" HOST_LONG_LONG_FORMAT \"x\"\n # define HOST_WIDE_INT_PRINT_PADDED_HEX \\\n@@ -155,42 +135,17 @@ typedef HOST_WIDE_INT __gcc_host_wide_int__;\n #define HOST_WIDE_INT_PRINT_HEX \"%#\" HOST_WIDE_INT_PRINT \"x\"\n #define HOST_WIDE_INT_PRINT_HEX_PURE \"%\" HOST_WIDE_INT_PRINT \"x\"\n \n-/* Set HOST_WIDEST_INT.  This is a 64-bit type unless the compiler\n-   in use has no 64-bit type at all; in that case it's 32 bits.  */\n-\n-#if HOST_BITS_PER_WIDE_INT >= 64 \\\n-    || (HOST_BITS_PER_LONGLONG < 64 && HOST_BITS_PER___INT64 < 64)\n-# define HOST_WIDEST_INT\t\t      HOST_WIDE_INT\n-# define HOST_BITS_PER_WIDEST_INT\t      HOST_BITS_PER_WIDE_INT\n-# define HOST_WIDEST_INT_PRINT                HOST_WIDE_INT_PRINT\n-# define HOST_WIDEST_INT_PRINT_DEC\t      HOST_WIDE_INT_PRINT_DEC\n-# define HOST_WIDEST_INT_PRINT_DEC_C\t      HOST_WIDE_INT_PRINT_DEC_C\n-# define HOST_WIDEST_INT_PRINT_UNSIGNED\t      HOST_WIDE_INT_PRINT_UNSIGNED\n-# define HOST_WIDEST_INT_PRINT_HEX\t      HOST_WIDE_INT_PRINT_HEX\n-# define HOST_WIDEST_INT_PRINT_DOUBLE_HEX     HOST_WIDE_INT_PRINT_DOUBLE_HEX\n-# define HOST_WIDEST_INT_C(X)\t\t      HOST_WIDE_INT (X)\n-#else\n-# if HOST_BITS_PER_LONGLONG >= 64\n-#  define HOST_BITS_PER_WIDEST_INT\t      HOST_BITS_PER_LONGLONG\n-#  define HOST_WIDEST_INT\t\t      long long\n-#  define HOST_WIDEST_INT_C(X)\t\t      X ## LL\n-# else\n-#  if HOST_BITS_PER___INT64 >= 64\n-#   define HOST_BITS_PER_WIDEST_INT\t      HOST_BITS_PER___INT64\n-#   define HOST_WIDEST_INT\t\t      __int64\n-#   define HOST_WIDEST_INT_C(X)\t\t      X ## i64\n-#  else\n-    #error \"This line should be impossible to reach\"\n-#  endif\n-# endif\n-# define HOST_WIDEST_INT_PRINT                HOST_LONG_LONG_FORMAT\n-# define HOST_WIDEST_INT_PRINT_DEC\t      \"%\" HOST_LONG_LONG_FORMAT \"d\"\n-# define HOST_WIDEST_INT_PRINT_DEC_C\t      \"%\" HOST_LONG_LONG_FORMAT \"dLL\"\n-# define HOST_WIDEST_INT_PRINT_UNSIGNED\t      \"%\" HOST_LONG_LONG_FORMAT \"u\"\n-# define HOST_WIDEST_INT_PRINT_HEX\t      \"%#\" HOST_LONG_LONG_FORMAT \"x\"\n-# define HOST_WIDEST_INT_PRINT_DOUBLE_HEX     \\\n-    \"0x%\" HOST_LONG_LONG_FORMAT \"x%016\" HOST_LONG_LONG_FORMAT \"x\"\n-#endif\n+/* Set HOST_WIDEST_INT.  This is a 64-bit type.  */\n+\n+#define HOST_WIDEST_INT\t\t\t      HOST_WIDE_INT\n+#define HOST_BITS_PER_WIDEST_INT\t      HOST_BITS_PER_WIDE_INT\n+#define HOST_WIDEST_INT_PRINT\t\t      HOST_WIDE_INT_PRINT\n+#define HOST_WIDEST_INT_PRINT_DEC\t      HOST_WIDE_INT_PRINT_DEC\n+#define HOST_WIDEST_INT_PRINT_DEC_C\t      HOST_WIDE_INT_PRINT_DEC_C\n+#define HOST_WIDEST_INT_PRINT_UNSIGNED\t      HOST_WIDE_INT_PRINT_UNSIGNED\n+#define HOST_WIDEST_INT_PRINT_HEX\t      HOST_WIDE_INT_PRINT_HEX\n+#define HOST_WIDEST_INT_PRINT_DOUBLE_HEX      HOST_WIDE_INT_PRINT_DOUBLE_HEX\n+#define HOST_WIDEST_INT_C(X)\t\t      HOST_WIDE_INT (X)\n \n /* Define HOST_WIDEST_FAST_INT to the widest integer type supported\n    efficiently in hardware.  (That is, the widest integer type that fits\n@@ -203,12 +158,8 @@ typedef HOST_WIDE_INT __gcc_host_wide_int__;\n #  ifdef HAVE_LONG_LONG\n #    define HOST_WIDEST_FAST_INT long long\n #    define HOST_BITS_PER_WIDEST_FAST_INT HOST_BITS_PER_LONGLONG\n-#  elif defined (HAVE___INT64)\n-#    define HOST_WIDEST_FAST_INT __int64\n-#    define HOST_BITS_PER_WIDEST_FAST_INT HOST_BITS_PER___INT64\n #  else\n-#    error \"Your host said it wanted to use long long or __int64 but neither\"\n-#    error \"exist\"\n+#    error \"Your host said it wanted to use long long but that does not exist\"\n #  endif\n #else\n #  define HOST_WIDEST_FAST_INT long"}, {"sha": "8e656cee6cd959c04d71a154128b5b286cff8e71", "filename": "gcc/vmsdbg.h", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edf6ddf6775b07472f2dbaeb3b9511fd2ab0e902/gcc%2Fvmsdbg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edf6ddf6775b07472f2dbaeb3b9511fd2ab0e902/gcc%2Fvmsdbg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvmsdbg.h?ref=edf6ddf6775b07472f2dbaeb3b9511fd2ab0e902", "patch": "@@ -216,13 +216,7 @@ typedef struct _DST_SRC_COMMAND\n \t  unsigned char dst_b_src_df_length;\n \t  unsigned char dst_b_src_df_flags;\n \t  unsigned short int dst_w_src_df_fileid;\n-#ifdef HAVE_LONG_LONG\n-\t  long long dst_q_src_df_rms_cdt;\n-#else\n-#ifdef HAVE___INT64\n-\t  __int64 dst_q_src_df_rms_cdt;\n-#endif\n-#endif\n+\t  int64_t dst_q_src_df_rms_cdt;\n \t  unsigned int dst_l_src_df_rms_ebk;\n \t  unsigned short int dst_w_src_df_rms_ffb;\n \t  unsigned char dst_b_src_df_rms_rfo;"}, {"sha": "8288423941dbab8f1f0d3c1412cc5632a28b4b72", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edf6ddf6775b07472f2dbaeb3b9511fd2ab0e902/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edf6ddf6775b07472f2dbaeb3b9511fd2ab0e902/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=edf6ddf6775b07472f2dbaeb3b9511fd2ab0e902", "patch": "@@ -1,3 +1,11 @@\n+2014-05-26  Richard Biener  <rguenther@suse.de>\n+\n+\t* configure.ac: Remove long long and __int64 type checks,\n+\tadd check for uint64_t and fail if that wasn't found.\n+\t* include/cpplib.h (cpp_num_part): Use uint64_t.\n+\t* config.in: Regenerate.\n+\t* configure: Likewise.\n+\n 2014-05-21  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/61212"}, {"sha": "8df00ec2357209a0f0b4af3b02fa19fe48a24f30", "filename": "libcpp/config.in", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edf6ddf6775b07472f2dbaeb3b9511fd2ab0e902/libcpp%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edf6ddf6775b07472f2dbaeb3b9511fd2ab0e902/libcpp%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fconfig.in?ref=edf6ddf6775b07472f2dbaeb3b9511fd2ab0e902", "patch": "@@ -180,9 +180,6 @@\n /* Define to 1 if you have the <locale.h> header file. */\n #undef HAVE_LOCALE_H\n \n-/* Define to 1 if the system has the type `long long'. */\n-#undef HAVE_LONG_LONG\n-\n /* Define to 1 if you have the <memory.h> header file. */\n #undef HAVE_MEMORY_H\n \n@@ -231,9 +228,6 @@\n /* Define to 1 if you have the <unistd.h> header file. */\n #undef HAVE_UNISTD_H\n \n-/* Define to 1 if the system has the type `__int64'. */\n-#undef HAVE___INT64\n-\n /* Define as const if the declaration of iconv() needs const. */\n #undef ICONV_CONST\n \n@@ -264,12 +258,6 @@\n /* The size of `long', as computed by sizeof. */\n #undef SIZEOF_LONG\n \n-/* The size of `long long', as computed by sizeof. */\n-#undef SIZEOF_LONG_LONG\n-\n-/* The size of `__int64', as computed by sizeof. */\n-#undef SIZEOF___INT64\n-\n /* If using the C implementation of alloca, define if you know the\n    direction of stack growth for your system; otherwise it will be\n    automatically deduced at runtime.\n@@ -340,6 +328,11 @@\n /* Define to 1 if you need to in order for `stat' and other things to work. */\n #undef _POSIX_SOURCE\n \n+/* Define for Solaris 2.5.1 so the uint64_t typedef from <sys/synch.h>,\n+   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the\n+   #define below would cause a syntax error. */\n+#undef _UINT64_T\n+\n /* Define to empty if `const' does not conform to ANSI C. */\n #undef const\n \n@@ -361,6 +354,10 @@\n /* Define to `int' if <sys/types.h> does not define. */\n #undef ssize_t\n \n+/* Define to the type of an unsigned integer type of width exactly 64 bits if\n+   such a type exists and the standard includes do not define it. */\n+#undef uint64_t\n+\n /* Define to the type of an unsigned integer type wide enough to hold a\n    pointer, if such a type exists, and if the system does not define it. */\n #undef uintptr_t"}, {"sha": "096ac8b5f2146ca482d9a88f0fd8e7dc78d59e7a", "filename": "libcpp/configure", "status": "modified", "additions": 62, "deletions": 79, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edf6ddf6775b07472f2dbaeb3b9511fd2ab0e902/libcpp%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edf6ddf6775b07472f2dbaeb3b9511fd2ab0e902/libcpp%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fconfigure?ref=edf6ddf6775b07472f2dbaeb3b9511fd2ab0e902", "patch": "@@ -1822,6 +1822,58 @@ $as_echo \"$ac_res\" >&6; }\n \n } # ac_fn_c_check_type\n \n+# ac_fn_c_find_uintX_t LINENO BITS VAR\n+# ------------------------------------\n+# Finds an unsigned integer type with width BITS, setting cache variable VAR\n+# accordingly.\n+ac_fn_c_find_uintX_t ()\n+{\n+  as_lineno=${as_lineno-\"$1\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for uint$2_t\" >&5\n+$as_echo_n \"checking for uint$2_t... \" >&6; }\n+if { as_var=$3; eval \"test \\\"\\${$as_var+set}\\\" = set\"; }; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  eval \"$3=no\"\n+     for ac_type in uint$2_t 'unsigned int' 'unsigned long int' \\\n+\t 'unsigned long long int' 'unsigned short int' 'unsigned char'; do\n+       cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+$ac_includes_default\n+int\n+main ()\n+{\n+static int test_array [1 - 2 * !(($ac_type) -1 >> ($2 - 1) == 1)];\n+test_array [0] = 0\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+  case $ac_type in #(\n+  uint$2_t) :\n+    eval \"$3=yes\" ;; #(\n+  *) :\n+    eval \"$3=\\$ac_type\" ;;\n+esac\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+       eval as_val=\\$$3\n+   if test \"x$as_val\" = x\"\"no; then :\n+\n+else\n+  break\n+fi\n+     done\n+fi\n+eval ac_res=\\$$3\n+\t       { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_res\" >&5\n+$as_echo \"$ac_res\" >&6; }\n+  eval $as_lineno_stack; test \"x$as_lineno_stack\" = x && { as_lineno=; unset as_lineno;}\n+\n+} # ac_fn_c_find_uintX_t\n+\n # ac_fn_c_compute_int LINENO EXPR VAR INCLUDES\n # --------------------------------------------\n # Tries to find the compile-time value of EXPR in a program that includes\n@@ -5566,92 +5618,23 @@ _ACEOF\n \n fi\n \n-ac_fn_c_check_type \"$LINENO\" \"long long\" \"ac_cv_type_long_long\" \"$ac_includes_default\"\n-if test \"x$ac_cv_type_long_long\" = x\"\"yes; then :\n-\n-cat >>confdefs.h <<_ACEOF\n-#define HAVE_LONG_LONG 1\n-_ACEOF\n-\n-# The cast to long int works around a bug in the HP C Compiler\n-# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects\n-# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.\n-# This bug is HP SR number 8606223364.\n-{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking size of long long\" >&5\n-$as_echo_n \"checking size of long long... \" >&6; }\n-if test \"${ac_cv_sizeof_long_long+set}\" = set; then :\n-  $as_echo_n \"(cached) \" >&6\n-else\n-  if ac_fn_c_compute_int \"$LINENO\" \"(long int) (sizeof (long long))\" \"ac_cv_sizeof_long_long\"        \"$ac_includes_default\"; then :\n-\n-else\n-  if test \"$ac_cv_type_long_long\" = yes; then\n-     { { $as_echo \"$as_me:${as_lineno-$LINENO}: error: in \\`$ac_pwd':\" >&5\n-$as_echo \"$as_me: error: in \\`$ac_pwd':\" >&2;}\n-{ as_fn_set_status 77\n-as_fn_error \"cannot compute sizeof (long long)\n-See \\`config.log' for more details.\" \"$LINENO\" 5; }; }\n-   else\n-     ac_cv_sizeof_long_long=0\n-   fi\n-fi\n-\n-fi\n-{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_sizeof_long_long\" >&5\n-$as_echo \"$ac_cv_sizeof_long_long\" >&6; }\n-\n-\n-\n-cat >>confdefs.h <<_ACEOF\n-#define SIZEOF_LONG_LONG $ac_cv_sizeof_long_long\n-_ACEOF\n-\n-\n-fi\n-\n-ac_fn_c_check_type \"$LINENO\" \"__int64\" \"ac_cv_type___int64\" \"$ac_includes_default\"\n-if test \"x$ac_cv_type___int64\" = x\"\"yes; then :\n-\n-cat >>confdefs.h <<_ACEOF\n-#define HAVE___INT64 1\n-_ACEOF\n-\n-# The cast to long int works around a bug in the HP C Compiler\n-# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects\n-# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.\n-# This bug is HP SR number 8606223364.\n-{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking size of __int64\" >&5\n-$as_echo_n \"checking size of __int64... \" >&6; }\n-if test \"${ac_cv_sizeof___int64+set}\" = set; then :\n-  $as_echo_n \"(cached) \" >&6\n-else\n-  if ac_fn_c_compute_int \"$LINENO\" \"(long int) (sizeof (__int64))\" \"ac_cv_sizeof___int64\"        \"$ac_includes_default\"; then :\n-\n-else\n-  if test \"$ac_cv_type___int64\" = yes; then\n-     { { $as_echo \"$as_me:${as_lineno-$LINENO}: error: in \\`$ac_pwd':\" >&5\n-$as_echo \"$as_me: error: in \\`$ac_pwd':\" >&2;}\n-{ as_fn_set_status 77\n-as_fn_error \"cannot compute sizeof (__int64)\n-See \\`config.log' for more details.\" \"$LINENO\" 5; }; }\n-   else\n-     ac_cv_sizeof___int64=0\n-   fi\n-fi\n-\n-fi\n-{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_sizeof___int64\" >&5\n-$as_echo \"$ac_cv_sizeof___int64\" >&6; }\n+ac_fn_c_find_uintX_t \"$LINENO\" \"64\" \"ac_cv_c_uint64_t\"\n+case $ac_cv_c_uint64_t in #(\n+  no|yes) ;; #(\n+  *)\n \n+$as_echo \"#define _UINT64_T 1\" >>confdefs.h\n \n \n cat >>confdefs.h <<_ACEOF\n-#define SIZEOF___INT64 $ac_cv_sizeof___int64\n+#define uint64_t $ac_cv_c_uint64_t\n _ACEOF\n+;;\n+  esac\n \n-\n+if test x\"$ac_cv_c_uint64_t\" = x\"no\"; then\n+  as_fn_error \"uint64_t not found\" \"$LINENO\" 5\n fi\n-\n { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether struct tm is in sys/time.h or time.h\" >&5\n $as_echo_n \"checking whether struct tm is in sys/time.h or time.h... \" >&6; }\n if test \"${ac_cv_struct_tm+set}\" = set; then :"}, {"sha": "5f008a4a67fc8d4aed5b53330efe0bbe34216e27", "filename": "libcpp/configure.ac", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edf6ddf6775b07472f2dbaeb3b9511fd2ab0e902/libcpp%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edf6ddf6775b07472f2dbaeb3b9511fd2ab0e902/libcpp%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fconfigure.ac?ref=edf6ddf6775b07472f2dbaeb3b9511fd2ab0e902", "patch": "@@ -64,8 +64,10 @@ AC_TYPE_SIZE_T\n AC_TYPE_SSIZE_T\n AC_TYPE_UINTPTR_T\n AC_CHECK_TYPE(ptrdiff_t, int)\n-AC_CHECK_TYPES([long long], [AC_CHECK_SIZEOF(long long)])\n-AC_CHECK_TYPES([__int64], [AC_CHECK_SIZEOF(__int64)])\n+AC_TYPE_UINT64_T\n+if test x\"$ac_cv_c_uint64_t\" = x\"no\"; then\n+  AC_MSG_ERROR([uint64_t not found])\n+fi\n AC_STRUCT_TM\n AC_CHECK_SIZEOF(int)\n AC_CHECK_SIZEOF(long)"}, {"sha": "a83452b91453454e573bca147c9f972e8fb7990e", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edf6ddf6775b07472f2dbaeb3b9511fd2ab0e902/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edf6ddf6775b07472f2dbaeb3b9511fd2ab0e902/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=edf6ddf6775b07472f2dbaeb3b9511fd2ab0e902", "patch": "@@ -820,23 +820,9 @@ extern int cpp_defined (cpp_reader *, const unsigned char *, int);\n /* A preprocessing number.  Code assumes that any unused high bits of\n    the double integer are set to zero.  */\n \n-/* Find a type with at least 64bit precision, mimicking hwint.h.\n-   This type has to be equal to unsigned HOST_WIDE_INT, see\n+/* This type has to be equal to unsigned HOST_WIDE_INT, see\n    gcc/c-family/c-lex.c.  */\n-#if SIZEOF_LONG >= 8\n-typedef unsigned long cpp_num_part;\n-#else\n-# if SIZEOF_LONG_LONG >= 8\n-typedef unsigned long long cpp_num_part;\n-# else\n-#  if SIZEOF___INT64 >= 8\n-typedef unsigned __int64 cpp_num_part;\n-#  else\n-    #error \"This line should be impossible to reach\"\n-#  endif\n-# endif\n-#endif\n-\n+typedef uint64_t cpp_num_part;\n typedef struct cpp_num cpp_num;\n struct cpp_num\n {"}]}