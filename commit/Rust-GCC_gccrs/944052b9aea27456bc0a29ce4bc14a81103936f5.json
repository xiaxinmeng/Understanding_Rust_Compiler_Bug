{"sha": "944052b9aea27456bc0a29ce4bc14a81103936f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQ0MDUyYjlhZWEyNzQ1NmJjMGEyOWNlNGJjMTRhODExMDM5MzZmNQ==", "commit": {"author": {"name": "Yuri Rumyantsev", "email": "ysrumyan@gmail.com", "date": "2014-05-01T07:23:06Z"}, "committer": {"name": "Kirill Yukhin", "email": "kyukhin@gcc.gnu.org", "date": "2014-05-01T07:23:06Z"}, "message": "tree-if-conv.c (is_cond_scalar_reduction): New function.\n\ngcc/\n\t* tree-if-conv.c (is_cond_scalar_reduction): New function.\n\t(convert_scalar_cond_reduction): Likewise.\n\t(predicate_scalar_phi): Add recognition and transformation\n\tof simple conditioanl reduction to be vectorizable.\n\ngcc/testsuite/\n\t* gcc.dg/cond-reduc-1.c: New test.\n\t* gcc.dg/cond-reduc-2.c: Likewise.\n\nFrom-SVN: r209972", "tree": {"sha": "67c37b86e2e70f7ffbe8e013e20f143679618830", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67c37b86e2e70f7ffbe8e013e20f143679618830"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/944052b9aea27456bc0a29ce4bc14a81103936f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/944052b9aea27456bc0a29ce4bc14a81103936f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/944052b9aea27456bc0a29ce4bc14a81103936f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/944052b9aea27456bc0a29ce4bc14a81103936f5/comments", "author": {"login": "ysrumyan", "id": 44425612, "node_id": "MDQ6VXNlcjQ0NDI1NjEy", "avatar_url": "https://avatars.githubusercontent.com/u/44425612?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ysrumyan", "html_url": "https://github.com/ysrumyan", "followers_url": "https://api.github.com/users/ysrumyan/followers", "following_url": "https://api.github.com/users/ysrumyan/following{/other_user}", "gists_url": "https://api.github.com/users/ysrumyan/gists{/gist_id}", "starred_url": "https://api.github.com/users/ysrumyan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ysrumyan/subscriptions", "organizations_url": "https://api.github.com/users/ysrumyan/orgs", "repos_url": "https://api.github.com/users/ysrumyan/repos", "events_url": "https://api.github.com/users/ysrumyan/events{/privacy}", "received_events_url": "https://api.github.com/users/ysrumyan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c9379ce2a9a18a45eae9877c3c4e6977a414365e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9379ce2a9a18a45eae9877c3c4e6977a414365e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9379ce2a9a18a45eae9877c3c4e6977a414365e"}], "stats": {"total": 203, "additions": 199, "deletions": 4}, "files": [{"sha": "c34080b4879b736bfe6a6631a423a3857d791fb2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944052b9aea27456bc0a29ce4bc14a81103936f5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944052b9aea27456bc0a29ce4bc14a81103936f5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=944052b9aea27456bc0a29ce4bc14a81103936f5", "patch": "@@ -1,3 +1,10 @@\n+2014-05-01  Yuri Rumyantsev  <ysrumyan@gmail.com>\n+\n+\t* tree-if-conv.c (is_cond_scalar_reduction): New function.\n+\t(convert_scalar_cond_reduction): Likewise.\n+\t(predicate_scalar_phi): Add recognition and transformation\n+\tof simple conditioanl reduction to be vectorizable.\n+\n 2014-05-01  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/43245"}, {"sha": "05e92409df1dc94b65d5fbc1078cf3ea9f7bdd10", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944052b9aea27456bc0a29ce4bc14a81103936f5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944052b9aea27456bc0a29ce4bc14a81103936f5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=944052b9aea27456bc0a29ce4bc14a81103936f5", "patch": "@@ -1,3 +1,8 @@\n+2014-05-01  Yuri Rumyantsev  <ysrumyan@gmail.com>\n+\n+\t* gcc.dg/cond-reduc-1.c: New test.\n+\t* gcc.dg/cond-reduc-2.c: Likewise.\n+\n 2014-05-01  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/29467"}, {"sha": "981f6b0648002d10c09aac8050958a5cc2cff318", "filename": "gcc/testsuite/gcc.dg/vect/cond-reduc-1.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944052b9aea27456bc0a29ce4bc14a81103936f5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcond-reduc-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944052b9aea27456bc0a29ce4bc14a81103936f5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcond-reduc-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcond-reduc-1.c?ref=944052b9aea27456bc0a29ce4bc14a81103936f5", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+\n+#define N 512\n+int a[N];\n+int foo()\n+{\n+  int i, res = 0;\n+  for (i=0; i<N; i++)\n+  {\n+    if (a[i] != 0)\n+      res += 1;\n+  }\n+  return res;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "c329861c63cd0797c23219db4fe06a0a036596aa", "filename": "gcc/testsuite/gcc.dg/vect/cond-reduc-2.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944052b9aea27456bc0a29ce4bc14a81103936f5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcond-reduc-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944052b9aea27456bc0a29ce4bc14a81103936f5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcond-reduc-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcond-reduc-2.c?ref=944052b9aea27456bc0a29ce4bc14a81103936f5", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+\n+#define N 512\n+int a[N], b[N];\n+void foo(int k)\n+{\n+  int i, res = 0;\n+  for (i=0; i<N; i++)\n+  {\n+    if (b[i] != 0)\n+      res += b[i];\n+  }\n+  a[k] = sum;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "5b08669f456d8cd23e5e578e864e4d3e5ff964b2", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 149, "deletions": 4, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944052b9aea27456bc0a29ce4bc14a81103936f5/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944052b9aea27456bc0a29ce4bc14a81103936f5/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=944052b9aea27456bc0a29ce4bc14a81103936f5", "patch": "@@ -1386,6 +1386,144 @@ find_phi_replacement_condition (basic_block bb, tree *cond,\n   return first_edge->src;\n }\n \n+/* Returns true if def-stmt for phi argument ARG is simple increment/decrement\n+   which is in predicated basic block.\n+   In fact, the following PHI pattern is searching:\n+      loop-header:\n+\treduc_1 = PHI <..., reduc_2>\n+      ...\n+\tif (...)\n+\t  reduc_3 = ...\n+\treduc_2 = PHI <reduc_1, reduc_3>\n+\n+   REDUC, OP0 and OP1 contain reduction stmt and its operands.  */\n+\n+static bool\n+is_cond_scalar_reduction (gimple phi, gimple *reduc,\n+\t\t\t  tree *op0, tree *op1)\n+{\n+  tree lhs, r_op1, r_op2;\n+  tree arg_0, arg_1;\n+  gimple stmt;\n+  gimple header_phi = NULL;\n+  enum tree_code reduction_op;\n+  struct loop *loop = gimple_bb (phi)->loop_father;\n+  edge latch_e = loop_latch_edge (loop);\n+\n+  arg_0 = PHI_ARG_DEF (phi, 0);\n+  arg_1 = PHI_ARG_DEF (phi, 1);\n+  if (TREE_CODE (arg_0) != SSA_NAME || TREE_CODE (arg_1) != SSA_NAME)\n+    return false;\n+\n+  if (gimple_code (SSA_NAME_DEF_STMT (arg_0)) == GIMPLE_PHI)\n+    {\n+      lhs = arg_1;\n+      header_phi = SSA_NAME_DEF_STMT (arg_0);\n+      stmt = SSA_NAME_DEF_STMT (arg_1);\n+    }\n+  else if (gimple_code (SSA_NAME_DEF_STMT (arg_1)) == GIMPLE_PHI)\n+    {\n+      lhs = arg_0;\n+      header_phi = SSA_NAME_DEF_STMT (arg_1);\n+      stmt = SSA_NAME_DEF_STMT (arg_0);\n+    }\n+  else\n+    return false;\n+  if (gimple_bb (header_phi) != loop->header)\n+    return false;\n+\n+  if (PHI_ARG_DEF_FROM_EDGE (header_phi, latch_e) != PHI_RESULT (phi))\n+    return false;\n+\n+  if (gimple_code (stmt) != GIMPLE_ASSIGN\n+      || gimple_has_volatile_ops (stmt))\n+    return false;\n+\n+  if (!is_predicated (gimple_bb (stmt)))\n+    return false;\n+\n+  if (!has_single_use (lhs))\n+    return false;\n+\n+  reduction_op = gimple_assign_rhs_code (stmt);\n+  if (reduction_op != PLUS_EXPR && reduction_op != MINUS_EXPR)\n+    return false;\n+  r_op1 = gimple_assign_rhs1 (stmt);\n+  r_op2 = gimple_assign_rhs2 (stmt);\n+\n+  /* Make R_OP1 to hold reduction variable.  */\n+  if (r_op2 == PHI_RESULT (header_phi)\n+      && reduction_op == PLUS_EXPR)\n+    {\n+      tree tmp = r_op1;\n+      r_op1 = r_op2;\n+      r_op2 = tmp;\n+    }\n+  else if (r_op1 != PHI_RESULT (header_phi))\n+    return false;\n+\n+  *op0 = r_op1; *op1 = r_op2;\n+  *reduc = stmt;\n+  return true;\n+}\n+\n+/* Converts conditional scalar reduction into unconditional form, e.g.\n+     bb_4\n+       if (_5 != 0) goto bb_5 else goto bb_6\n+     end_bb_4\n+     bb_5\n+       res_6 = res_13 + 1;\n+     end_bb_5\n+     bb_6\n+       # res_2 = PHI <res_13(4), res_6(5)>\n+     end_bb_6\n+\n+   will be converted into sequence\n+    _ifc__1 = _5 != 0 ? 1 : 0;\n+    res_2 = res_13 + _ifc__1;\n+  Argument SWAP tells that arguments of conditional expression should be\n+  swapped.\n+  Returns rhs of resulting PHI assignment.  */\n+\n+static tree\n+convert_scalar_cond_reduction (gimple reduc, gimple_stmt_iterator *gsi,\n+\t\t\t       tree cond, tree op0, tree op1, bool swap)\n+{\n+  gimple_stmt_iterator stmt_it;\n+  gimple new_assign;\n+  tree rhs;\n+  tree rhs1 = gimple_assign_rhs1 (reduc);\n+  tree tmp = make_temp_ssa_name (TREE_TYPE (rhs1), NULL, \"_ifc_\");\n+  tree c;\n+  tree zero = build_zero_cst (TREE_TYPE (rhs1));\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Found cond scalar reduction.\\n\");\n+      print_gimple_stmt (dump_file, reduc, 0, TDF_SLIM);\n+    }\n+\n+  /* Build cond expression using COND and constant operand\n+     of reduction rhs.  */\n+  c = fold_build_cond_expr (TREE_TYPE (rhs1),\n+\t\t\t    unshare_expr (cond),\n+\t\t\t    swap ? zero : op1,\n+\t\t\t    swap ? op1 : zero);\n+\n+  /* Create assignment stmt and insert it at GSI.  */\n+  new_assign = gimple_build_assign (tmp, c);\n+  gsi_insert_before (gsi, new_assign, GSI_SAME_STMT);\n+  /* Build rhs for unconditional increment/decrement.  */\n+  rhs = fold_build2 (gimple_assign_rhs_code (reduc),\n+\t\t     TREE_TYPE (rhs1), op0, tmp);\n+\n+  /* Delete original reduction stmt.  */\n+  stmt_it = gsi_for_stmt (reduc);\n+  gsi_remove (&stmt_it, true);\n+  release_defs (reduc);\n+  return rhs;\n+}\n+\n /* Replace a scalar PHI node with a COND_EXPR using COND as condition.\n    This routine does not handle PHI nodes with more than two\n    arguments.\n@@ -1428,6 +1566,9 @@ predicate_scalar_phi (gimple phi, tree cond,\n   else\n     {\n       tree arg_0, arg_1;\n+      tree op0, op1;\n+      gimple reduc;\n+\n       /* Use condition that is not TRUTH_NOT_EXPR in conditional modify expr.  */\n       if (EDGE_PRED (bb, 1)->src == true_bb)\n \t{\n@@ -1439,10 +1580,14 @@ predicate_scalar_phi (gimple phi, tree cond,\n \t  arg_0 = gimple_phi_arg_def (phi, 0);\n \t  arg_1 = gimple_phi_arg_def (phi, 1);\n \t}\n-\n-      /* Build new RHS using selected condition and arguments.  */\n-      rhs = fold_build_cond_expr (TREE_TYPE (res), unshare_expr (cond),\n-\t\t\t\t  arg_0, arg_1);\n+      if (is_cond_scalar_reduction (phi, &reduc, &op0, &op1))\n+\t/* Convert reduction stmt into vectorizable form.  */\n+\trhs = convert_scalar_cond_reduction (reduc, gsi, cond, op0, op1,\n+\t\t\t\t\t     true_bb != gimple_bb (reduc));\n+      else\n+\t/* Build new RHS using selected condition and arguments.  */\n+\trhs = fold_build_cond_expr (TREE_TYPE (res), unshare_expr (cond),\n+\t\t\t\t    arg_0, arg_1);\n     }\n \n   new_stmt = gimple_build_assign (res, rhs);"}]}