{"sha": "8521c41417b57bf46fc57efccf3befaf6fc0a712", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODUyMWM0MTQxN2I1N2JmNDZmYzU3ZWZjY2YzYmVmYWY2ZmMwYTcxMg==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2006-12-01T02:25:22Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2006-12-01T02:25:22Z"}, "message": "re PR target/24036 ([e500] ICE in subreg_offset_representable_p, at rtlanal.c:3143)\n\n2006-12-01  Joseph Myers  <joseph@codesourcery.com>\n            David Edelsohn  <edelsohn@gnu.org>\n\n\tPR target/24036\n\t* doc/tm.texi (HARD_REGNO_NREGS_HAS_PADDING,\n\tHARD_REGNO_NREGS_WITH_PADDING): Document new target macros.\n\t* defaults.h (HARD_REGNO_NREGS_HAS_PADDING,\n\tHARD_REGNO_NREGS_WITH_PADDING): Define.\n\t* config/i386/i386.h (HARD_REGNO_NREGS_HAS_PADDING,\n\tHARD_REGNO_NREGS_WITH_PADDING): Define.\n\t* rtlanal.c (subreg_regno_offset, subreg_offset_representable_p):\n\tUse new macros to detect modes with holes; do not look at integer\n\tunits.\n\t(subreg_offset_representable_p): Check for and disallow cases\n\twhere the modes use different numbers of bits from registers.\n\t* config/rs6000/rs6000.c (rs6000_emit_move): Handle TFmode\n\tconstant for soft-float.\n\t(rs6000_hard_regno_nregs): Use UNITS_PER_FP_WORD for e500 GPRs\n\tcontaining doubles.\n\t(rs6000_split_multireg_move): Use DFmode reg_mode for TFmode moves\n\tin E500 double case.\n\t* config/rs6000/rs6000.md (movtf): Allow soft-float.\n\t(movtf_softfloat): New.\n\nCo-Authored-By: David Edelsohn <edelsohn@gnu.org>\n\nFrom-SVN: r119395", "tree": {"sha": "3b6620756f6468172f9d6c83a27617279a0da87c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b6620756f6468172f9d6c83a27617279a0da87c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8521c41417b57bf46fc57efccf3befaf6fc0a712", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8521c41417b57bf46fc57efccf3befaf6fc0a712", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8521c41417b57bf46fc57efccf3befaf6fc0a712", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8521c41417b57bf46fc57efccf3befaf6fc0a712/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "877c1c555fdcc46467c9fe9e9dccb8aaf8efe178", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/877c1c555fdcc46467c9fe9e9dccb8aaf8efe178", "html_url": "https://github.com/Rust-GCC/gccrs/commit/877c1c555fdcc46467c9fe9e9dccb8aaf8efe178"}], "stats": {"total": 183, "additions": 123, "deletions": 60}, "files": [{"sha": "559be89c453718af644e38770f9461a1633d1453", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8521c41417b57bf46fc57efccf3befaf6fc0a712/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8521c41417b57bf46fc57efccf3befaf6fc0a712/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8521c41417b57bf46fc57efccf3befaf6fc0a712", "patch": "@@ -1,3 +1,27 @@\n+2006-12-01  Joseph Myers  <joseph@codesourcery.com>\n+            David Edelsohn  <edelsohn@gnu.org>\n+\n+\tPR target/24036\n+\t* doc/tm.texi (HARD_REGNO_NREGS_HAS_PADDING,\n+\tHARD_REGNO_NREGS_WITH_PADDING): Document new target macros.\n+\t* defaults.h (HARD_REGNO_NREGS_HAS_PADDING,\n+\tHARD_REGNO_NREGS_WITH_PADDING): Define.\n+\t* config/i386/i386.h (HARD_REGNO_NREGS_HAS_PADDING,\n+\tHARD_REGNO_NREGS_WITH_PADDING): Define.\n+\t* rtlanal.c (subreg_regno_offset, subreg_offset_representable_p):\n+\tUse new macros to detect modes with holes; do not look at integer\n+\tunits.\n+\t(subreg_offset_representable_p): Check for and disallow cases\n+\twhere the modes use different numbers of bits from registers.\n+\t* config/rs6000/rs6000.c (rs6000_emit_move): Handle TFmode\n+\tconstant for soft-float.\n+\t(rs6000_hard_regno_nregs): Use UNITS_PER_FP_WORD for e500 GPRs\n+\tcontaining doubles.\n+\t(rs6000_split_multireg_move): Use DFmode reg_mode for TFmode moves\n+\tin E500 double case.\n+\t* config/rs6000/rs6000.md (movtf): Allow soft-float.\n+\t(movtf_softfloat): New.\n+\n 2006-11-30  Richard Sandiford  <richard@codesourcery.com>\n \n \t* simplify-rtx.c (simplify_rtx): Use simplify_subreg rather than"}, {"sha": "e30d6b7bdefa8f951a7a13763d0b48b0f1c730ba", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8521c41417b57bf46fc57efccf3befaf6fc0a712/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8521c41417b57bf46fc57efccf3befaf6fc0a712/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=8521c41417b57bf46fc57efccf3befaf6fc0a712", "patch": "@@ -917,6 +917,15 @@ do {\t\t\t\t\t\t\t\t\t\\\n       ? (TARGET_64BIT ? 4 : 6)\t\t\t\t\t\t\\\n       : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)))\n \n+#define HARD_REGNO_NREGS_HAS_PADDING(REGNO, MODE)\t\t\t\\\n+  ((TARGET_128BIT_LONG_DOUBLE && !TARGET_64BIT)\t\t\t\t\\\n+   ? (FP_REGNO_P (REGNO) || SSE_REGNO_P (REGNO) || MMX_REGNO_P (REGNO)\t\\\n+      ? 0\t\t\t\t\t\t\t\t\\\n+      : ((MODE) == XFmode || (MODE) == XCmode))\t\t\t\t\\\n+   : 0)\n+\n+#define HARD_REGNO_NREGS_WITH_PADDING(REGNO, MODE) ((MODE) == XFmode ? 4 : 8)\n+\n #define VALID_SSE2_REG_MODE(MODE) \\\n     ((MODE) == V16QImode || (MODE) == V8HImode || (MODE) == V2DFmode    \\\n      || (MODE) == V2DImode || (MODE) == DFmode)"}, {"sha": "977a66d265daf4eedfee79f3dbdabda0c2fd36c6", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8521c41417b57bf46fc57efccf3befaf6fc0a712/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8521c41417b57bf46fc57efccf3befaf6fc0a712/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=8521c41417b57bf46fc57efccf3befaf6fc0a712", "patch": "@@ -3822,16 +3822,21 @@ rs6000_hard_regno_nregs (int regno, enum machine_mode mode)\n   if (FP_REGNO_P (regno))\n     return (GET_MODE_SIZE (mode) + UNITS_PER_FP_WORD - 1) / UNITS_PER_FP_WORD;\n \n-  if (TARGET_E500_DOUBLE && mode == DFmode)\n-    return 1;\n-\n   if (SPE_SIMD_REGNO_P (regno) && TARGET_SPE && SPE_VECTOR_MODE (mode))\n     return (GET_MODE_SIZE (mode) + UNITS_PER_SPE_WORD - 1) / UNITS_PER_SPE_WORD;\n \n   if (ALTIVEC_REGNO_P (regno))\n     return\n       (GET_MODE_SIZE (mode) + UNITS_PER_ALTIVEC_WORD - 1) / UNITS_PER_ALTIVEC_WORD;\n \n+  /* The value returned for SCmode in the E500 double case is 2 for\n+     ABI compatibility; storing an SCmode value in a single register\n+     would require function_arg and rs6000_spe_function_arg to handle\n+     SCmode so as to pass the value correctly in a pair of\n+     registers.  */\n+  if (TARGET_E500_DOUBLE && FLOAT_MODE_P (mode) && mode != SCmode)\n+    return (GET_MODE_SIZE (mode) + UNITS_PER_FP_WORD - 1) / UNITS_PER_FP_WORD;\n+\n   return (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n }\n \n@@ -4200,8 +4205,7 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n \n   /* 128-bit constant floating-point values on Darwin should really be\n      loaded as two parts.  */\n-  if (!TARGET_IEEEQUAD\n-      && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_LONG_DOUBLE_128\n+  if (!TARGET_IEEEQUAD && TARGET_LONG_DOUBLE_128\n       && mode == TFmode && GET_CODE (operands[1]) == CONST_DOUBLE)\n     {\n       /* DImode is used, not DFmode, because simplify_gen_subreg doesn't\n@@ -12744,6 +12748,8 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n     reg_mode = DFmode;\n   else if (ALTIVEC_REGNO_P (reg))\n     reg_mode = V16QImode;\n+  else if (TARGET_E500_DOUBLE && mode == TFmode)\n+    reg_mode = DFmode;\n   else\n     reg_mode = word_mode;\n   reg_mode_size = GET_MODE_SIZE (reg_mode);"}, {"sha": "62541df0cccc2482f2a7a98c9c7332758e30ebc2", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8521c41417b57bf46fc57efccf3befaf6fc0a712/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8521c41417b57bf46fc57efccf3befaf6fc0a712/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=8521c41417b57bf46fc57efccf3befaf6fc0a712", "patch": "@@ -8518,8 +8518,7 @@\n (define_expand \"movtf\"\n   [(set (match_operand:TF 0 \"general_operand\" \"\")\n \t(match_operand:TF 1 \"any_operand\" \"\"))]\n-  \"!TARGET_IEEEQUAD\n-   && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_LONG_DOUBLE_128\"\n+  \"!TARGET_IEEEQUAD && TARGET_LONG_DOUBLE_128\"\n   \"{ rs6000_emit_move (operands[0], operands[1], TFmode); DONE; }\")\n \n ; It's important to list the o->f and f->o moves before f->f because\n@@ -8538,6 +8537,19 @@\n { rs6000_split_multireg_move (operands[0], operands[1]); DONE; }\n   [(set_attr \"length\" \"8,8,8,20,20,16\")])\n \n+(define_insn_and_split \"*movtf_softfloat\"\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=r,Y,r\")\n+\t(match_operand:TF 1 \"input_operand\"         \"YGHF,r,r\"))]\n+  \"!TARGET_IEEEQUAD\n+   && (TARGET_SOFT_FLOAT || !TARGET_FPRS) && TARGET_LONG_DOUBLE_128\n+   && (gpc_reg_operand (operands[0], TFmode)\n+       || gpc_reg_operand (operands[1], TFmode))\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(pc)]\n+{ rs6000_split_multireg_move (operands[0], operands[1]); DONE; }\n+  [(set_attr \"length\" \"20,20,16\")])\n+\n (define_expand \"extenddftf2\"\n   [(parallel [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n \t\t   (float_extend:TF (match_operand:DF 1 \"input_operand\" \"\")))"}, {"sha": "6af5f17bd7dd75e6362837a34d1a44deea311156", "filename": "gcc/defaults.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8521c41417b57bf46fc57efccf3befaf6fc0a712/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8521c41417b57bf46fc57efccf3befaf6fc0a712/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=8521c41417b57bf46fc57efccf3befaf6fc0a712", "patch": "@@ -895,4 +895,9 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #define INCOMING_FRAME_SP_OFFSET 0\n #endif\n \n+#ifndef HARD_REGNO_NREGS_HAS_PADDING\n+#define HARD_REGNO_NREGS_HAS_PADDING(REGNO, MODE) 0\n+#define HARD_REGNO_NREGS_WITH_PADDING(REGNO, MODE) -1\n+#endif\n+\n #endif  /* ! GCC_DEFAULTS_H */"}, {"sha": "634f5f170c6703e6c40d6965172c2941841ce479", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8521c41417b57bf46fc57efccf3befaf6fc0a712/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8521c41417b57bf46fc57efccf3befaf6fc0a712/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=8521c41417b57bf46fc57efccf3befaf6fc0a712", "patch": "@@ -1978,6 +1978,33 @@ definition of this macro is\n @end smallexample\n @end defmac\n \n+@defmac HARD_REGNO_NREGS_HAS_PADDING (@var{regno}, @var{mode})\n+A C expression that is nonzero if a value of mode @var{mode}, stored\n+in memory, ends with padding that causes it to take up more space than\n+in registers starting at register number @var{regno} (as determined by\n+multiplying GCC's notion of the size of the register when containing\n+this mode by the number of registers returned by\n+@code{HARD_REGNO_NREGS}).  By default this is zero.\n+\n+For example, if a floating-point value is stored in three 32-bit\n+registers but takes up 128 bits in memory, then this would be\n+nonzero.\n+\n+This macros only needs to be defined if there are cases where\n+@code{subreg_regno_offset} and @code{subreg_offset_representable_p}\n+would otherwise wrongly determine that a @code{subreg} can be\n+represented by an offset to the register number, when in fact such a\n+@code{subreg} would contain some of the padding not stored in\n+registers and so not be representable.\n+@end defmac\n+\n+@defmac HARD_REGNO_NREGS_WITH_PADDING (@var{regno}, @var{mode})\n+For values of @var{regno} and @var{mode} for which\n+@code{HARD_REGNO_NREGS_HAS_PADDING} returns nonzero, a C expression\n+returning the greater number of registers required to hold the value\n+including any padding.  In the example above, the value would be four.\n+@end defmac\n+\n @defmac REGMODE_NATURAL_SIZE (@var{mode})\n Define this macro if the natural size of registers that hold values\n of mode @var{mode} is not the word size.  It is a C expression that"}, {"sha": "fd7fa017eec05a9f8296b0a226d7404c6e833a79", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 33, "deletions": 53, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8521c41417b57bf46fc57efccf3befaf6fc0a712/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8521c41417b57bf46fc57efccf3befaf6fc0a712/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=8521c41417b57bf46fc57efccf3befaf6fc0a712", "patch": "@@ -2925,34 +2925,15 @@ unsigned int\n subreg_regno_offset (unsigned int xregno, enum machine_mode xmode,\n \t\t     unsigned int offset, enum machine_mode ymode)\n {\n-  int nregs_xmode, nregs_ymode, nregs_xmode_unit_int;\n+  int nregs_xmode, nregs_ymode;\n   int mode_multiple, nregs_multiple;\n   int y_offset;\n-  enum machine_mode xmode_unit, xmode_unit_int;\n \n   gcc_assert (xregno < FIRST_PSEUDO_REGISTER);\n \n-  if (GET_MODE_INNER (xmode) == VOIDmode)\n-    xmode_unit = xmode;\n-  else\n-    xmode_unit = GET_MODE_INNER (xmode);\n-  \n-  if (FLOAT_MODE_P (xmode_unit))\n-    {\n-      xmode_unit_int = int_mode_for_mode (xmode_unit);\n-      if (xmode_unit_int == BLKmode)\n-\t/* It's probably bad to be here; a port should have an integer mode\n-\t   that's the same size as anything of which it takes a SUBREG.  */\n-\txmode_unit_int = xmode_unit;\n-    }\n-  else\n-    xmode_unit_int = xmode_unit;\n-\n-  nregs_xmode_unit_int = hard_regno_nregs[xregno][xmode_unit_int];\n-\n   /* Adjust nregs_xmode to allow for 'holes'.  */\n-  if (nregs_xmode_unit_int != hard_regno_nregs[xregno][xmode_unit])\n-    nregs_xmode = nregs_xmode_unit_int * GET_MODE_NUNITS (xmode);\n+  if (HARD_REGNO_NREGS_HAS_PADDING (xregno, xmode))\n+    nregs_xmode = HARD_REGNO_NREGS_WITH_PADDING (xregno, xmode);\n   else\n     nregs_xmode = hard_regno_nregs[xregno][xmode];\n     \n@@ -2990,38 +2971,31 @@ bool\n subreg_offset_representable_p (unsigned int xregno, enum machine_mode xmode,\n \t\t\t       unsigned int offset, enum machine_mode ymode)\n {\n-  int nregs_xmode, nregs_ymode, nregs_xmode_unit, nregs_xmode_unit_int;\n+  int nregs_xmode, nregs_ymode;\n   int mode_multiple, nregs_multiple;\n   int y_offset;\n-  enum machine_mode xmode_unit, xmode_unit_int;\n+  int regsize_xmode, regsize_ymode;\n \n   gcc_assert (xregno < FIRST_PSEUDO_REGISTER);\n \n-  if (GET_MODE_INNER (xmode) == VOIDmode)\n-    xmode_unit = xmode;\n-  else\n-    xmode_unit = GET_MODE_INNER (xmode);\n-  \n-  if (FLOAT_MODE_P (xmode_unit))\n-    {\n-      xmode_unit_int = int_mode_for_mode (xmode_unit);\n-      if (xmode_unit_int == BLKmode)\n-\t/* It's probably bad to be here; a port should have an integer mode\n-\t   that's the same size as anything of which it takes a SUBREG.  */\n-\txmode_unit_int = xmode_unit;\n-    }\n-  else\n-    xmode_unit_int = xmode_unit;\n-\n-  nregs_xmode_unit = hard_regno_nregs[xregno][xmode_unit];\n-  nregs_xmode_unit_int = hard_regno_nregs[xregno][xmode_unit_int];\n-\n   /* If there are holes in a non-scalar mode in registers, we expect\n      that it is made up of its units concatenated together.  */\n-  if (nregs_xmode_unit != nregs_xmode_unit_int)\n+  if (HARD_REGNO_NREGS_HAS_PADDING (xregno, xmode))\n     {\n-      gcc_assert (nregs_xmode_unit * GET_MODE_NUNITS (xmode)\n-\t\t  == hard_regno_nregs[xregno][xmode]);\n+      enum machine_mode xmode_unit;\n+\n+      nregs_xmode = HARD_REGNO_NREGS_WITH_PADDING (xregno, xmode);\n+      if (GET_MODE_INNER (xmode) == VOIDmode)\n+\txmode_unit = xmode;\n+      else\n+\txmode_unit = GET_MODE_INNER (xmode);\n+      gcc_assert (HARD_REGNO_NREGS_HAS_PADDING (xregno, xmode_unit));\n+      gcc_assert (nregs_xmode\n+\t\t  == (GET_MODE_NUNITS (xmode)\n+\t\t      * HARD_REGNO_NREGS_WITH_PADDING (xregno, xmode_unit)));\n+      gcc_assert (hard_regno_nregs[xregno][xmode]\n+\t\t  == (hard_regno_nregs[xregno][xmode_unit]\n+\t\t      * GET_MODE_NUNITS (xmode)));\n \n       /* You can only ask for a SUBREG of a value with holes in the middle\n \t if you don't cross the holes.  (Such a SUBREG should be done by\n@@ -3031,15 +3005,12 @@ subreg_offset_representable_p (unsigned int xregno, enum machine_mode xmode,\n \t 3 for each part, but in memory it's two 128-bit parts.  \n \t Padding is assumed to be at the end (not necessarily the 'high part')\n \t of each unit.  */\n-      if (nregs_xmode_unit != nregs_xmode_unit_int\n-\t  && (offset / GET_MODE_SIZE (xmode_unit_int) + 1 \n-\t      < GET_MODE_NUNITS (xmode))\n-\t  && (offset / GET_MODE_SIZE (xmode_unit_int) \n+      if ((offset / GET_MODE_SIZE (xmode_unit) + 1 \n+\t   < GET_MODE_NUNITS (xmode))\n+\t  && (offset / GET_MODE_SIZE (xmode_unit)\n \t      != ((offset + GET_MODE_SIZE (ymode) - 1)\n-\t\t  / GET_MODE_SIZE (xmode_unit_int))))\n+\t\t  / GET_MODE_SIZE (xmode_unit))))\n \treturn false;\n-\n-      nregs_xmode = nregs_xmode_unit_int * GET_MODE_NUNITS (xmode);\n     }\n   else\n     nregs_xmode = hard_regno_nregs[xregno][xmode];\n@@ -3053,6 +3024,15 @@ subreg_offset_representable_p (unsigned int xregno, enum machine_mode xmode,\n \t  ? WORDS_BIG_ENDIAN : BYTES_BIG_ENDIAN))\n     return true;\n \n+  /* If registers store different numbers of bits in the different\n+     modes, we cannot generally form this subreg.  */\n+  regsize_xmode = GET_MODE_SIZE (xmode) / nregs_xmode;\n+  regsize_ymode = GET_MODE_SIZE (ymode) / nregs_ymode;\n+  if (regsize_xmode > regsize_ymode && nregs_ymode > 1)\n+    return false;\n+  if (regsize_ymode > regsize_xmode && nregs_xmode > 1)\n+    return false;\n+\n   /* Lowpart subregs are otherwise valid.  */\n   if (offset == subreg_lowpart_offset (ymode, xmode))\n     return true;"}]}