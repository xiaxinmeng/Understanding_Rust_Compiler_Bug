{"sha": "fcc42bcad4fac328cb9696186c30012e2454c3e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmNjNDJiY2FkNGZhYzMyOGNiOTY5NjE4NmMzMDAxMmUyNDU0YzNlMg==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel1@de.ibm.com", "date": "2006-09-13T10:59:03Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2006-09-13T10:59:03Z"}, "message": "flow.c (calculate_global_regs_live): Invalidate eh registers on eh edges.\n\n2006-09-13  Andreas Krebbel  <krebbel1@de.ibm.com>\n\n\t* flow.c (calculate_global_regs_live): Invalidate eh registers\n\ton eh edges. Renamed invalidated_by_call to invalidated_by_eh_edge.\n\t(propagate_block): Handle eh registers as if they were set at basic\n\tblock start.\n\t* except.c (dw2_build_landing_pads): Don't emit clobbers for eh\n\tregisters.\n\t* global.c (global_conflicts): Make eh registers to conflict with\n\tpseudos live at basic block begin.\n\t* basic_block.h (bb_has_eh_pred): New function.\n\nFrom-SVN: r116920", "tree": {"sha": "d8fd1e5efab556d1ff0ca0b73b5f295e5373292b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8fd1e5efab556d1ff0ca0b73b5f295e5373292b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fcc42bcad4fac328cb9696186c30012e2454c3e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcc42bcad4fac328cb9696186c30012e2454c3e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcc42bcad4fac328cb9696186c30012e2454c3e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcc42bcad4fac328cb9696186c30012e2454c3e2/comments", "author": null, "committer": null, "parents": [{"sha": "4b7b277aff44cffe643cff9b84d13968b29fa177", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b7b277aff44cffe643cff9b84d13968b29fa177", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b7b277aff44cffe643cff9b84d13968b29fa177"}], "stats": {"total": 110, "additions": 79, "deletions": 31}, "files": [{"sha": "63188b874e3d209269cf10919fc7a3af41fcea33", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcc42bcad4fac328cb9696186c30012e2454c3e2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcc42bcad4fac328cb9696186c30012e2454c3e2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fcc42bcad4fac328cb9696186c30012e2454c3e2", "patch": "@@ -1,3 +1,15 @@\n+2006-09-13  Andreas Krebbel  <krebbel1@de.ibm.com>\n+\n+\t* flow.c (calculate_global_regs_live): Invalidate eh registers\n+\ton eh edges. Renamed invalidated_by_call to invalidated_by_eh_edge.\n+\t(propagate_block): Handle eh registers as if they were set at basic\n+\tblock start.\n+\t* except.c (dw2_build_landing_pads): Don't emit clobbers for eh\n+\tregisters.\n+\t* global.c (global_conflicts): Make eh registers to conflict with\n+\tpseudos live at basic block begin.\n+\t* basic_block.h (bb_has_eh_pred): New function.\n+\n 2006-09-13  Richard Sandiford  <richard@codesourcery.com>\n \n \tPR rtl-optimization/28982"}, {"sha": "a95e5b8781bc9f2b9c0a3415d20e46de293a1607", "filename": "gcc/basic-block.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcc42bcad4fac328cb9696186c30012e2454c3e2/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcc42bcad4fac328cb9696186c30012e2454c3e2/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=fcc42bcad4fac328cb9696186c30012e2454c3e2", "patch": "@@ -1175,4 +1175,18 @@ extern bool rtx_equiv_p (rtx *, rtx, int, struct equiv_info *);\n /* In cfgrtl.c */\n extern bool condjump_equiv_p (struct equiv_info *, bool);\n \n+/* Return true when one of the predecessor edges of BB is marked with FLAGS.  */\n+static inline bool bb_has_eh_pred (basic_block bb)\n+{\n+  edge e;\n+  edge_iterator ei;\n+\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    {\n+      if (e->flags & EDGE_EH)\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n #endif /* GCC_BASIC_BLOCK_H */"}, {"sha": "b344087672b45522f06de084b82faaf1450e08bb", "filename": "gcc/except.c", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcc42bcad4fac328cb9696186c30012e2454c3e2/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcc42bcad4fac328cb9696186c30012e2454c3e2/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=fcc42bcad4fac328cb9696186c30012e2454c3e2", "patch": "@@ -1601,14 +1601,12 @@ static void\n dw2_build_landing_pads (void)\n {\n   int i;\n-  unsigned int j;\n \n   for (i = cfun->eh->last_region_number; i > 0; --i)\n     {\n       struct eh_region *region;\n       rtx seq;\n       basic_block bb;\n-      bool clobbers_hard_regs = false;\n       edge e;\n \n       region = VEC_index (eh_region, cfun->eh->region_array, i);\n@@ -1638,30 +1636,6 @@ dw2_build_landing_pads (void)\n #endif\n \t  { /* Nothing */ }\n \n-      /* If the eh_return data registers are call-saved, then we\n-\t won't have considered them clobbered from the call that\n-\t threw.  Kill them now.  */\n-      for (j = 0; ; ++j)\n-\t{\n-\t  unsigned r = EH_RETURN_DATA_REGNO (j);\n-\t  if (r == INVALID_REGNUM)\n-\t    break;\n-\t  if (! call_used_regs[r])\n-\t    {\n-\t      emit_insn (gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, r)));\n-\t      clobbers_hard_regs = true;\n-\t    }\n-\t}\n-\n-      if (clobbers_hard_regs)\n-\t{\n-\t  /* @@@ This is a kludge.  Not all machine descriptions define a\n-\t     blockage insn, but we must not allow the code we just generated\n-\t     to be reordered by scheduling.  So emit an ASM_INPUT to act as\n-\t     blockage insn.  */\n-\t  emit_insn (gen_rtx_ASM_INPUT (VOIDmode, \"\"));\n-\t}\n-\n       emit_move_insn (cfun->eh->exc_ptr,\n \t\t      gen_rtx_REG (ptr_mode, EH_RETURN_DATA_REGNO (0)));\n       emit_move_insn (cfun->eh->filter,"}, {"sha": "2b5d3032bf754405b01435bc460d3f4eadd682be", "filename": "gcc/flow.c", "status": "modified", "additions": 38, "deletions": 5, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcc42bcad4fac328cb9696186c30012e2454c3e2/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcc42bcad4fac328cb9696186c30012e2454c3e2/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=fcc42bcad4fac328cb9696186c30012e2454c3e2", "patch": "@@ -1040,7 +1040,7 @@ static void\n calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n {\n   basic_block *queue, *qhead, *qtail, *qend, bb;\n-  regset tmp, new_live_at_end, invalidated_by_call;\n+  regset tmp, new_live_at_end, invalidated_by_eh_edge;\n   regset registers_made_dead;\n   bool failure_strategy_required = false;\n   int *block_accesses;\n@@ -1063,13 +1063,24 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n \n   tmp = ALLOC_REG_SET (&reg_obstack);\n   new_live_at_end = ALLOC_REG_SET (&reg_obstack);\n-  invalidated_by_call = ALLOC_REG_SET (&reg_obstack);\n+  invalidated_by_eh_edge = ALLOC_REG_SET (&reg_obstack);\n   registers_made_dead = ALLOC_REG_SET (&reg_obstack);\n \n   /* Inconveniently, this is only readily available in hard reg set form.  */\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; ++i)\n     if (TEST_HARD_REG_BIT (regs_invalidated_by_call, i))\n-      SET_REGNO_REG_SET (invalidated_by_call, i);\n+      SET_REGNO_REG_SET (invalidated_by_eh_edge, i);\n+\n+  /* The exception handling registers die at eh edges.  */\n+#ifdef EH_RETURN_DATA_REGNO\n+  for (i = 0; ; ++i)\n+    {\n+      unsigned regno = EH_RETURN_DATA_REGNO (i);\n+      if (regno == INVALID_REGNUM)\n+\tbreak;\n+      SET_REGNO_REG_SET (invalidated_by_eh_edge, regno);\n+    }\n+#endif\n \n   /* Allocate space for the sets of local properties.  */\n   local_sets = XCNEWVEC (bitmap, last_basic_block);\n@@ -1202,7 +1213,7 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n \t    if (e->flags & EDGE_EH)\n \t      bitmap_ior_and_compl_into (new_live_at_end,\n \t\t\t\t\t sb->il.rtl->global_live_at_start,\n-\t\t\t\t\t invalidated_by_call);\n+\t\t\t\t\t invalidated_by_eh_edge);\n \t    else\n \t      IOR_REG_SET (new_live_at_end, sb->il.rtl->global_live_at_start);\n \n@@ -1422,7 +1433,7 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n \n   FREE_REG_SET (tmp);\n   FREE_REG_SET (new_live_at_end);\n-  FREE_REG_SET (invalidated_by_call);\n+  FREE_REG_SET (invalidated_by_eh_edge);\n   FREE_REG_SET (registers_made_dead);\n \n   if (blocks_out)\n@@ -2214,6 +2225,28 @@ propagate_block (basic_block bb, regset live, regset local_set,\n \tbreak;\n     }\n \n+#ifdef EH_RETURN_DATA_REGNO\n+  if (bb_has_eh_pred (bb))\n+    {\n+      unsigned int i;\n+      for (i = 0; ; ++i)\n+\t{\n+\t  unsigned regno = EH_RETURN_DATA_REGNO (i);\n+\t  if (regno == INVALID_REGNUM)\n+\t    break;\n+\t  if (pbi->local_set)\n+\t    {\n+\t      CLEAR_REGNO_REG_SET (pbi->cond_local_set, regno);\n+\t      SET_REGNO_REG_SET (pbi->local_set, regno);\n+\t    }\n+\t  if (REGNO_REG_SET_P (pbi->reg_live, regno))\n+\t    SET_REGNO_REG_SET (pbi->new_set, regno);\n+\t  \n+\t  regs_ever_live[regno] = 1;\n+\t}\n+    }\n+#endif\n+\n   free_propagate_block_info (pbi);\n \n   return changed;"}, {"sha": "229f862c28cf763d7e71be345abddc68eee472e2", "filename": "gcc/global.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcc42bcad4fac328cb9696186c30012e2454c3e2/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcc42bcad4fac328cb9696186c30012e2454c3e2/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=fcc42bcad4fac328cb9696186c30012e2454c3e2", "patch": "@@ -743,6 +743,21 @@ global_conflicts (void)\n \t    scan the instruction that makes either X or Y become live.  */\n \trecord_conflicts (block_start_allocnos, ax);\n \n+#ifdef EH_RETURN_DATA_REGNO\n+\tif (bb_has_eh_pred (b))\n+\t  {\n+\t    unsigned int i;\n+\t    \n+\t    for (i = 0; ; ++i)\n+\t      {\n+\t\tunsigned int regno = EH_RETURN_DATA_REGNO (i);\n+\t\tif (regno == INVALID_REGNUM)\n+\t\t  break;\n+\t\trecord_one_conflict (regno);\n+\t      }\n+\t  }\n+#endif\n+\n \t/* Pseudos can't go in stack regs at the start of a basic block that\n \t   is reached by an abnormal edge. Likewise for call clobbered regs,\n \t   because caller-save, fixup_abnormal_edges and possibly the table"}]}