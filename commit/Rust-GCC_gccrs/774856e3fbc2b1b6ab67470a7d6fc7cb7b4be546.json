{"sha": "774856e3fbc2b1b6ab67470a7d6fc7cb7b4be546", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzc0ODU2ZTNmYmMyYjFiNmFiNjc0NzBhN2Q2ZmM3Y2I3YjRiZTU0Ng==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2019-03-21T22:04:29Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-03-21T22:04:29Z"}, "message": "re PR lto/89692 (ICE in streamer_write_chain, at tree-streamer-out.c:506)\n\n\tPR lto/89692\n\t* tree.c (fld_type_variant, fld_incomplete_type_of,\n\tfld_process_array_type): Call fld->pset.add and don't call\n\tadd_tree_to_fld_list if it returns true.\n\t(free_lang_data_in_type): Similarly with self-recursive call.  Purge\n\tnon-marked types from TYPE_NEXT_VARIANT list.\n\t(find_decls_types_r): Call fld_worklist_push for TYPE_CANONICAL (t).\n\n\t* g++.dg/other/pr89692.C: New test.\n\nFrom-SVN: r269862", "tree": {"sha": "7061da68fd12dcff4b6b50141a6b8cff428ef595", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7061da68fd12dcff4b6b50141a6b8cff428ef595"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/774856e3fbc2b1b6ab67470a7d6fc7cb7b4be546", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/774856e3fbc2b1b6ab67470a7d6fc7cb7b4be546", "html_url": "https://github.com/Rust-GCC/gccrs/commit/774856e3fbc2b1b6ab67470a7d6fc7cb7b4be546", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/774856e3fbc2b1b6ab67470a7d6fc7cb7b4be546/comments", "author": null, "committer": null, "parents": [{"sha": "8c8b42cf72f677e004909b2ab3b3f12353fb94d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c8b42cf72f677e004909b2ab3b3f12353fb94d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c8b42cf72f677e004909b2ab3b3f12353fb94d5"}], "stats": {"total": 64, "additions": 57, "deletions": 7}, "files": [{"sha": "2f0c540dfea448da1b09e72ed234877ff8ddda10", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/774856e3fbc2b1b6ab67470a7d6fc7cb7b4be546/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/774856e3fbc2b1b6ab67470a7d6fc7cb7b4be546/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=774856e3fbc2b1b6ab67470a7d6fc7cb7b4be546", "patch": "@@ -1,3 +1,14 @@\n+2019-03-21  Jan Hubicka  <hubicka@ucw.cz>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR lto/89692\n+\t* tree.c (fld_type_variant, fld_incomplete_type_of,\n+\tfld_process_array_type): Call fld->pset.add and don't call\n+\tadd_tree_to_fld_list if it returns true.\n+\t(free_lang_data_in_type): Similarly with self-recursive call.  Purge\n+\tnon-marked types from TYPE_NEXT_VARIANT list.\n+\t(find_decls_types_r): Call fld_worklist_push for TYPE_CANONICAL (t).\n+\n 2019-03-21  Jakub Jelinek  <jakub@redhat.com>\n \n \t* hash-table.h (hash_table): Add Lazy template parameter defaulted"}, {"sha": "4edc0ef6fed8c95e10da45cd42b03595c57144af", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/774856e3fbc2b1b6ab67470a7d6fc7cb7b4be546/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/774856e3fbc2b1b6ab67470a7d6fc7cb7b4be546/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=774856e3fbc2b1b6ab67470a7d6fc7cb7b4be546", "patch": "@@ -1,5 +1,8 @@\n 2019-03-21  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR lto/89692\n+\t* g++.dg/other/pr89692.C: New test.\n+\n \tPR c++/89767\n \t* g++.dg/cpp1y/lambda-init18.C: New test.\n \t* g++.dg/cpp1y/lambda-init19.C: New test."}, {"sha": "36adeb52773cf3b939fbf858cd45df81740139a4", "filename": "gcc/testsuite/g++.dg/other/pr89692.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/774856e3fbc2b1b6ab67470a7d6fc7cb7b4be546/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fpr89692.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/774856e3fbc2b1b6ab67470a7d6fc7cb7b4be546/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fpr89692.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fpr89692.C?ref=774856e3fbc2b1b6ab67470a7d6fc7cb7b4be546", "patch": "@@ -0,0 +1,20 @@\n+// PR lto/89692\n+// { dg-do compile }\n+// { dg-require-effective-target lto }\n+// { dg-options \"-flto -O2\" }\n+\n+struct S {\n+  short int a, b;\n+  unsigned char c : 1;\n+};\n+\n+bool\n+foo (void)\n+{\n+  unsigned char d[sizeof (S)] = { 0 };\n+  S e;\n+\n+  __builtin_memcpy (&e, d, sizeof (d));\n+\n+  return e.c == d[0];\n+}"}, {"sha": "65f8cd3a7951f08a1e436f2e409b05909bbdef1d", "filename": "gcc/tree.c", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/774856e3fbc2b1b6ab67470a7d6fc7cb7b4be546/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/774856e3fbc2b1b6ab67470a7d6fc7cb7b4be546/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=774856e3fbc2b1b6ab67470a7d6fc7cb7b4be546", "patch": "@@ -5215,7 +5215,8 @@ fld_type_variant (tree first, tree t, struct free_lang_data_d *fld,\n   if (inner_type)\n     TREE_TYPE (v) = inner_type;\n   gcc_checking_assert (fld_type_variant_equal_p (t,v, inner_type));\n-  add_tree_to_fld_list (v, fld);\n+  if (!fld->pset.add (v))\n+    add_tree_to_fld_list (v, fld);\n   return v;\n }\n \n@@ -5253,7 +5254,8 @@ fld_process_array_type (tree t, tree t2, hash_map<tree, tree> *map,\n       array = build_array_type_1 (t2, TYPE_DOMAIN (t),\n \t\t\t\t  TYPE_TYPELESS_STORAGE (t), false);\n       TYPE_CANONICAL (array) = TYPE_CANONICAL (t);\n-      add_tree_to_fld_list (array, fld);\n+      if (!fld->pset.add (array))\n+\tadd_tree_to_fld_list (array, fld);\n     }\n   return array;\n }\n@@ -5298,7 +5300,8 @@ fld_incomplete_type_of (tree t, struct free_lang_data_d *fld)\n \t\t\t\t\t\tTYPE_REF_CAN_ALIAS_ALL (t));\n \t  gcc_assert (TYPE_CANONICAL (t2) != t2\n \t\t      && TYPE_CANONICAL (t2) == TYPE_CANONICAL (TREE_TYPE (t)));\n-\t  add_tree_to_fld_list (first, fld);\n+\t  if (!fld->pset.add (first))\n+\t    add_tree_to_fld_list (first, fld);\n \t  return fld_type_variant (first, t, fld);\n \t}\n       return t;\n@@ -5321,7 +5324,8 @@ fld_incomplete_type_of (tree t, struct free_lang_data_d *fld)\n \t  copy = build_distinct_type_copy (t);\n \n \t  /* It is possible that type was not seen by free_lang_data yet.  */\n-\t  add_tree_to_fld_list (copy, fld);\n+\t  if (!fld->pset.add (copy))\n+\t    add_tree_to_fld_list (copy, fld);\n \t  TYPE_SIZE (copy) = NULL;\n \t  TYPE_USER_ALIGN (copy) = 0;\n \t  TYPE_SIZE_UNIT (copy) = NULL;\n@@ -5445,6 +5449,18 @@ free_lang_data_in_type (tree type, struct free_lang_data_d *fld)\n \n   TYPE_NEEDS_CONSTRUCTING (type) = 0;\n \n+  /* Purge non-marked variants from the variants chain, so that they\n+     don't reappear in the IL after free_lang_data.  */\n+  while (TYPE_NEXT_VARIANT (type)\n+\t && !fld->pset.contains (TYPE_NEXT_VARIANT (type)))\n+    {\n+      tree t = TYPE_NEXT_VARIANT (type);\n+      TYPE_NEXT_VARIANT (type) = TYPE_NEXT_VARIANT (t);\n+      /* Turn the removed types into distinct types.  */\n+      TYPE_MAIN_VARIANT (t) = t;\n+      TYPE_NEXT_VARIANT (t) = NULL_TREE;\n+    }\n+\n   if (TREE_CODE (type) == FUNCTION_TYPE)\n     {\n       TREE_TYPE (type) = fld_simplified_type (TREE_TYPE (type), fld);\n@@ -5464,7 +5480,8 @@ free_lang_data_in_type (tree type, struct free_lang_data_d *fld)\n \t\t\t  & ~TYPE_QUAL_CONST\n \t\t\t  & ~TYPE_QUAL_VOLATILE;\n \t      TREE_VALUE (p) = build_qualified_type (arg_type, quals);\n-\t      free_lang_data_in_type (TREE_VALUE (p), fld);\n+\t      if (!fld->pset.add (TREE_VALUE (p)))\n+\t\tfree_lang_data_in_type (TREE_VALUE (p), fld);\n \t    }\n \t  /* C++ FE uses TREE_PURPOSE to store initial values.  */\n \t  TREE_PURPOSE (p) = NULL;\n@@ -5886,8 +5903,7 @@ find_decls_types_r (tree *tp, int *ws, void *data)\n \t    ctx = BLOCK_SUPERCONTEXT (ctx);\n \t  fld_worklist_push (ctx, fld);\n \t}\n-      /* Do not walk TYPE_CANONICAL.  We do not stream it and thus do not\n-\t and want not to reach unused types this way.  */\n+      fld_worklist_push (TYPE_CANONICAL (t), fld);\n \n       if (RECORD_OR_UNION_TYPE_P (t) && TYPE_BINFO (t))\n \t{"}]}