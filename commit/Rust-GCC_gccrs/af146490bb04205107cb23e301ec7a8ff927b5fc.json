{"sha": "af146490bb04205107cb23e301ec7a8ff927b5fc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWYxNDY0OTBiYjA0MjA1MTA3Y2IyM2UzMDFlYzdhOGZmOTI3YjVmYw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2015-10-31T00:59:47Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2015-10-31T00:59:47Z"}, "message": "runtime: Remove now unnecessary pad field from ParFor.\n\n    \n    It is not needed due to the removal of the ctx field.\n    \n    Reviewed-on: https://go-review.googlesource.com/16525\n\nFrom-SVN: r229616", "tree": {"sha": "13beeaed3698c61903fe93fb1ce70bd9b18d4e7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/13beeaed3698c61903fe93fb1ce70bd9b18d4e7f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af146490bb04205107cb23e301ec7a8ff927b5fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af146490bb04205107cb23e301ec7a8ff927b5fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af146490bb04205107cb23e301ec7a8ff927b5fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af146490bb04205107cb23e301ec7a8ff927b5fc/comments", "author": null, "committer": null, "parents": [{"sha": "725e1be3406315d9bcc8195d7eef0a7082b3c7cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/725e1be3406315d9bcc8195d7eef0a7082b3c7cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/725e1be3406315d9bcc8195d7eef0a7082b3c7cc"}], "stats": {"total": 116403, "additions": 86206, "deletions": 30197}, "files": [{"sha": "c2307e1167ed0ee6baeca98b0f6d8ee5ece81b5a", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -1,4 +1,4 @@\n-16f69a4007a1903da4055a496882b514e05f45f3\n+4b6b496579225cdd897130f6d6fd18ecb100bf99\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "af7e452a4d1982f73b4968b5915263faf4b168a6", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -1,4 +1,4 @@\n-883bc6ed0ea815293fe6309d66f967ea60630e87\n+bb03defe933c89fee44be675d7aa0fbd893ced30\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "91bd3b80bdf9b8e1274455f09369d0e65984b79d", "filename": "libgo/Makefile.am", "status": "modified", "additions": 400, "deletions": 35, "changes": 435, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -233,12 +233,15 @@ toolexeclibgogodir = $(toolexeclibgodir)/go\n toolexeclibgogo_DATA = \\\n \tgo/ast.gox \\\n \tgo/build.gox \\\n+\tgo/constant.gox \\\n \tgo/doc.gox \\\n \tgo/format.gox \\\n+\tgo/importer.gox \\\n \tgo/parser.gox \\\n \tgo/printer.gox \\\n \tgo/scanner.gox \\\n-\tgo/token.gox\n+\tgo/token.gox \\\n+\tgo/types.gox\n \n toolexeclibgohashdir = $(toolexeclibgodir)/hash\n \n@@ -292,7 +295,8 @@ toolexeclibgomath_DATA = \\\n toolexeclibgomimedir = $(toolexeclibgodir)/mime\n \n toolexeclibgomime_DATA = \\\n-\tmime/multipart.gox\n+\tmime/multipart.gox \\\n+\tmime/quotedprintable.gox\n \n toolexeclibgonetdir = $(toolexeclibgodir)/net\n \n@@ -676,46 +680,74 @@ go_math_files = \\\n \tgo/math/tanh.go \\\n \tgo/math/unsafe.go\n \n+if LIBGO_IS_OPENBSD\n+go_mime_type_file = go/mime/type_openbsd.go\n+else\n+if LIBGO_IS_FREEBSD\n+go_mime_type_file = go/mime/type_freebsd.go\n+else\n+if LIBGO_IS_DRAGONFLY\n+go_mime_type_file = go/mime/type_dragonfly.go\n+else\n+go_mime_type_file =\n+endif\n+endif\n+endif\n+\n go_mime_files = \\\n+\tgo/mime/encodedword.go \\\n \tgo/mime/grammar.go \\\n \tgo/mime/mediatype.go \\\n \tgo/mime/type.go \\\n-\tgo/mime/type_unix.go\n+\tgo/mime/type_unix.go \\\n+\t$(go_mime_type_file)\n \n if LIBGO_IS_LINUX\n go_net_cgo_file = go/net/cgo_linux.go\n go_net_sock_file = go/net/sock_linux.go\n go_net_sockopt_file = go/net/sockopt_linux.go\n go_net_sockoptip_file = go/net/sockoptip_linux.go go/net/sockoptip_posix.go\n+go_net_cgo_sock_file = go/net/cgo_socknew.go\n+go_net_cgo_res_file = go/net/cgo_resnew.go\n else\n if LIBGO_IS_IRIX\n go_net_cgo_file = go/net/cgo_linux.go\n go_net_sock_file = go/net/sock_linux.go\n go_net_sockopt_file = go/net/sockopt_linux.go\n go_net_sockoptip_file = go/net/sockoptip_linux.go go/net/sockoptip_posix.go\n+go_net_cgo_sock_file = go/net/cgo_socknew.go\n+go_net_cgo_res_file = go/net/cgo_resnew.go\n else\n if LIBGO_IS_SOLARIS\n-go_net_cgo_file = go/net/cgo_linux.go\n+go_net_cgo_file = go/net/cgo_solaris.go\n go_net_sock_file = go/net/sock_stub.go\n go_net_sockopt_file = go/net/sockopt_solaris.go\n go_net_sockoptip_file = go/net/sockoptip_stub.go\n+go_net_cgo_sock_file = go/net/cgo_socknew.go\n+go_net_cgo_res_file = go/net/cgo_resnew.go\n else\n if LIBGO_IS_FREEBSD\n go_net_cgo_file = go/net/cgo_bsd.go\n go_net_sock_file = go/net/sock_bsd.go\n go_net_sockopt_file = go/net/sockopt_bsd.go\n go_net_sockoptip_file = go/net/sockoptip_bsd.go go/net/sockoptip_posix.go\n+go_net_cgo_sock_file = go/net/cgo_sockold.go\n+go_net_cgo_res_file = go/net/cgo_resold.go\n else\n if LIBGO_IS_NETBSD\n go_net_cgo_file = go/net/cgo_netbsd.go\n go_net_sock_file = go/net/sock_bsd.go\n go_net_sockopt_file = go/net/sockopt_bsd.go\n go_net_sockoptip_file = go/net/sockoptip_bsd.go go/net/sockoptip_posix.go\n+go_net_cgo_sock_file = go/net/cgo_sockold.go\n+go_net_cgo_res_file = go/net/cgo_resnew.go\n else\n go_net_cgo_file = go/net/cgo_bsd.go\n go_net_sock_file = go/net/sock_bsd.go\n go_net_sockopt_file = go/net/sockopt_bsd.go\n go_net_sockoptip_file = go/net/sockoptip_bsd.go go/net/sockoptip_posix.go\n+go_net_cgo_sock_file = go/net/cgo_sockold.go\n+go_net_cgo_res_file = go/net/cgo_resold.go\n endif\n endif\n endif\n@@ -731,10 +763,14 @@ else\n if LIBGO_IS_DRAGONFLY\n go_net_sendfile_file = go/net/sendfile_dragonfly.go\n else\n+if LIBGO_IS_SOLARIS\n+go_net_sendfile_file = go/net/sendfile_solaris.go\n+else\n go_net_sendfile_file = go/net/sendfile_stub.go\n endif\n endif\n endif\n+endif\n \n if LIBGO_IS_LINUX\n go_net_interface_file = go/net/interface_linux.go\n@@ -775,15 +811,22 @@ endif\n endif\n \n go_net_common_files = \\\n+\tgo/net/addrselect.go \\\n \t$(go_net_cloexec_file) \\\n+\tgo/net/conf.go \\\n \tgo/net/dial.go \\\n \tgo/net/dnsclient.go \\\n \tgo/net/dnsclient_unix.go \\\n \tgo/net/dnsconfig_unix.go \\\n \tgo/net/dnsmsg.go \\\n \tgo/net/fd_mutex.go \\\n+\tgo/net/fd_posix.go \\\n \tgo/net/fd_unix.go \\\n+\tgo/net/file.go \\\n \tgo/net/file_unix.go \\\n+\tgo/net/hook.go \\\n+\tgo/net/hook_cloexec.go \\\n+\tgo/net/hook_unix.go \\\n \tgo/net/hosts.go \\\n \tgo/net/interface.go \\\n \t$(go_net_interface_file) \\\n@@ -796,14 +839,14 @@ go_net_common_files = \\\n \tgo/net/lookup_unix.go \\\n \tgo/net/mac.go \\\n \tgo/net/net.go \\\n+\tgo/net/nss.go \\\n \tgo/net/parse.go \\\n \tgo/net/pipe.go \\\n \tgo/net/fd_poll_runtime.go \\\n \tgo/net/port.go \\\n \tgo/net/port_unix.go \\\n \tgo/net/race0.go \\\n \t$(go_net_sendfile_file) \\\n-\tgo/net/singleflight.go \\\n \tgo/net/sock_posix.go \\\n \t$(go_net_sock_file) \\\n \tgo/net/sockopt_posix.go \\\n@@ -821,6 +864,8 @@ go_net_common_files = \\\n go_net_files = \\\n \tgo/net/cgo_unix.go \\\n \t$(go_net_cgo_file) \\\n+\t$(go_net_cgo_res_file) \\\n+\t$(go_net_cgo_sock_file) \\\n \t$(go_net_common_files)\n \n go_netgo_files = \\\n@@ -919,6 +964,32 @@ else\n go_os_pipe_file = go/os/pipe_bsd.go\n endif\n \n+if LIBGO_IS_DARWIN\n+go_os_sticky_file = go/os/sticky_bsd.go\n+else\n+if LIBGO_IS_DRAGONFLY\n+go_os_sticky_file = go/os/sticky_bsd.go\n+else\n+if LIBGO_IS_FREEBSD\n+go_os_sticky_file = go/os/sticky_bsd.go\n+else\n+if LIBGO_IS_NETBSD\n+go_os_sticky_file = go/os/sticky_bsd.go\n+else\n+if LIBGO_IS_OPENBSD\n+go_os_sticky_file = go/os/sticky_bsd.go\n+else\n+if LIBGO_IS_SOLARIS\n+go_os_sticky_file = go/os/sticky_bsd.go\n+else\n+go_os_sticky_file = go/os/sticky_notbsd.go\n+endif\n+endif\n+endif\n+endif\n+endif\n+endif\n+\n go_os_files = \\\n \t$(go_os_dir_file) \\\n \tgo/os/dir.go \\\n@@ -939,6 +1010,7 @@ go_os_files = \\\n \t$(go_os_pipe_file) \\\n \tgo/os/proc.go \\\n \t$(go_os_stat_file) \\\n+\t$(go_os_sticky_file) \\\n \tgo/os/str.go \\\n \t$(go_os_sys_file) \\\n \t$(go_os_cloexec_file) \\\n@@ -959,6 +1031,7 @@ go_reflect_makefunc_c_file = \\\n \tgo/reflect/makefunc_ffi_c.c\n \n go_regexp_files = \\\n+\tgo/regexp/backtrack.go \\\n \tgo/regexp/exec.go \\\n \tgo/regexp/onepass.go \\\n \tgo/regexp/regexp.go\n@@ -974,7 +1047,6 @@ go_runtime_files = \\\n \tgo/runtime/error.go \\\n \tgo/runtime/extern.go \\\n \tgo/runtime/mem.go \\\n-\tgo/runtime/softfloat64.go \\\n \tversion.go\n \n version.go: s-version; @true\n@@ -1012,13 +1084,15 @@ go_strconv_files = \\\n \tgo/strconv/atof.go \\\n \tgo/strconv/atoi.go \\\n \tgo/strconv/decimal.go \\\n+\tgo/strconv/doc.go \\\n \tgo/strconv/extfloat.go \\\n \tgo/strconv/ftoa.go \\\n \tgo/strconv/isprint.go \\\n \tgo/strconv/itoa.go \\\n \tgo/strconv/quote.go\n \n go_strings_files = \\\n+\tgo/strings/compare.go \\\n \tgo/strings/reader.go \\\n \tgo/strings/replace.go \\\n \tgo/strings/search.go \\\n@@ -1048,6 +1122,7 @@ endif\n endif\n \n go_log_syslog_files = \\\n+\tgo/log/syslog/doc.go \\\n \tgo/log/syslog/syslog.go \\\n \t$(go_syslog_file)\n go_syslog_c_files = \\\n@@ -1186,6 +1261,7 @@ crypto_rand_file =\n endif\n \n go_crypto_rand_files = \\\n+\tgo/crypto/rand/eagain.go \\\n \tgo/crypto/rand/rand.go \\\n \tgo/crypto/rand/rand_unix.go \\\n \t$(crypto_rand_file) \\\n@@ -1222,13 +1298,45 @@ go_crypto_tls_files = \\\n \tgo/crypto/tls/prf.go \\\n \tgo/crypto/tls/ticket.go \\\n \tgo/crypto/tls/tls.go\n+\n+if LIBGO_IS_LINUX\n+go_crypto_x509_root_file = go/crypto/x509/root_linux.go\n+else\n+if LIBGO_IS_SOLARIS\n+go_crypto_x509_root_file = go/crypto/x509/root_solaris.go\n+else\n+if LIBGO_IS_DRAGONFLY\n+go_crypto_x509_root_file = go/crypto/x509/root_bsd.go\n+else\n+if LIBGO_IS_FREEBSD\n+go_crypto_x509_root_file = go/crypto/x509/root_bsd.go\n+else\n+if LIBGO_IS_NETBSD\n+go_crypto_x509_root_file = go/crypto/x509/root_bsd.go\n+else\n+if LIBGO_IS_OPENBSD\n+go_crypto_x509_root_file = go/crypto/x509/root_bsd.go\n+else\n+if LIBGO_IS_DARWIN\n+go_crypto_x509_root_file = go/crypto/x509/root_darwin.go\n+else\n+go_crypto_x509_root_file =\n+endif\n+endif\n+endif\n+endif\n+endif\n+endif\n+endif\n+\n go_crypto_x509_files = \\\n \tgo/crypto/x509/cert_pool.go \\\n \tgo/crypto/x509/pem_decrypt.go \\\n \tgo/crypto/x509/pkcs1.go \\\n \tgo/crypto/x509/pkcs8.go \\\n \tgo/crypto/x509/root.go \\\n \tgo/crypto/x509/root_unix.go \\\n+\t$(go_crypto_x509_root_file) \\\n \tgo/crypto/x509/sec1.go \\\n \tgo/crypto/x509/verify.go \\\n \tgo/crypto/x509/x509.go\n@@ -1246,6 +1354,7 @@ go_database_sql_driver_files = \\\n \n go_debug_dwarf_files = \\\n \tgo/debug/dwarf/buf.go \\\n+\tgo/debug/dwarf/class_string.go \\\n \tgo/debug/dwarf/const.go \\\n \tgo/debug/dwarf/entry.go \\\n \tgo/debug/dwarf/line.go \\\n@@ -1337,6 +1446,9 @@ go_go_build_files = \\\n \tgo/go/build/doc.go \\\n \tgo/go/build/read.go \\\n \tgo/go/build/syslist.go\n+go_go_constant_files = \\\n+\tgo/go/constant/go14.go \\\n+\tgo/go/constant/value.go\n go_go_doc_files = \\\n \tgo/go/doc/comment.go \\\n \tgo/go/doc/doc.go \\\n@@ -1347,6 +1459,8 @@ go_go_doc_files = \\\n \tgo/go/doc/synopsis.go\n go_go_format_files = \\\n \tgo/go/format/format.go\n+go_go_importer_files = \\\n+\tgo/go/importer/importer.go\n go_go_parser_files = \\\n \tgo/go/parser/interface.go \\\n \tgo/go/parser/parser.go\n@@ -1360,6 +1474,47 @@ go_go_token_files = \\\n \tgo/go/token/position.go \\\n \tgo/go/token/serialize.go \\\n \tgo/go/token/token.go\n+go_go_types_files = \\\n+\tgo/go/types/api.go \\\n+\tgo/go/types/assignments.go \\\n+\tgo/go/types/builtins.go \\\n+\tgo/go/types/call.go \\\n+\tgo/go/types/check.go \\\n+\tgo/go/types/conversions.go \\\n+\tgo/go/types/decl.go \\\n+\tgo/go/types/errors.go \\\n+\tgo/go/types/eval.go \\\n+\tgo/go/types/expr.go \\\n+\tgo/go/types/exprstring.go \\\n+\tgo/go/types/go12.go \\\n+\tgo/go/types/initorder.go \\\n+\tgo/go/types/labels.go \\\n+\tgo/go/types/lookup.go \\\n+\tgo/go/types/methodset.go \\\n+\tgo/go/types/object.go \\\n+\tgo/go/types/objset.go \\\n+\tgo/go/types/operand.go \\\n+\tgo/go/types/ordering.go \\\n+\tgo/go/types/package.go \\\n+\tgo/go/types/predicates.go \\\n+\tgo/go/types/resolver.go \\\n+\tgo/go/types/return.go \\\n+\tgo/go/types/scope.go \\\n+\tgo/go/types/selection.go \\\n+\tgo/go/types/stmt.go \\\n+\tgo/go/types/sizes.go \\\n+\tgo/go/types/type.go \\\n+\tgo/go/types/typestring.go \\\n+\tgo/go/types/typexpr.go \\\n+\tgo/go/types/universe.go\n+\n+go_go_internal_gcimporter_files = \\\n+\tgo/go/internal/gcimporter/exportdata.go \\\n+\tgo/go/internal/gcimporter/gcimporter.go\n+go_go_internal_gccgoimporter_files = \\\n+\tgo/go/internal/gccgoimporter/gccgoinstallation.go \\\n+\tgo/go/internal/gccgoimporter/importer.go \\\n+\tgo/go/internal/gccgoimporter/parser.go\n \n go_hash_adler32_files = \\\n \tgo/hash/adler32/adler32.go\n@@ -1399,6 +1554,10 @@ go_image_gif_files = \\\n \tgo/image/gif/reader.go \\\n \tgo/image/gif/writer.go\n \n+go_image_internal_imageutil_files = \\\n+\tgo/image/internal/imageutil/imageutil.go \\\n+\tgo/image/internal/imageutil/impl.go\n+\n go_image_jpeg_files = \\\n \tgo/image/jpeg/fdct.go \\\n \tgo/image/jpeg/huffman.go \\\n@@ -1416,15 +1575,46 @@ go_index_suffixarray_files = \\\n \tgo/index/suffixarray/qsufsort.go \\\n \tgo/index/suffixarray/suffixarray.go\n \n+go_internal_format_files = \\\n+\tgo/internal/format/format.go\n+go_internal_singleflight_files = \\\n+\tgo/internal/singleflight/singleflight.go\n+\n+if LIBGO_IS_LINUX\n+internal_syscall_unix_getrandom_file = go/internal/syscall/unix/getrandom_linux.go\n+else\n+internal_syscall_unix_getrandom_file =\n+endif\n+\n+go_internal_syscall_unix_files = \\\n+\tgo/internal/syscall/unix/dummy.go \\\n+\t$(internal_syscall_unix_getrandom_file)\n+\n+go_internal_testenv_files = \\\n+\tgo/internal/testenv/testenv.go\n+go_internal_trace_files = \\\n+\tgo/internal/trace/goroutines.go \\\n+\tgo/internal/trace/parser.go\n+\n go_io_ioutil_files = \\\n \tgo/io/ioutil/ioutil.go \\\n \tgo/io/ioutil/tempfile.go\n \n go_math_big_files = \\\n+\tgo/math/big/accuracy_string.go \\\n \tgo/math/big/arith.go \\\n+\tgo/math/big/arith_decl_pure.go \\\n+\tgo/math/big/decimal.go \\\n+\tgo/math/big/float.go \\\n+\tgo/math/big/floatconv.go \\\n+\tgo/math/big/ftoa.go \\\n \tgo/math/big/int.go \\\n+\tgo/math/big/intconv.go \\\n \tgo/math/big/nat.go \\\n-\tgo/math/big/rat.go\n+\tgo/math/big/natconv.go \\\n+\tgo/math/big/rat.go \\\n+\tgo/math/big/ratconv.go \\\n+\tgo/math/big/roundingmode_string.go\n go_math_cmplx_files = \\\n \tgo/math/cmplx/abs.go \\\n \tgo/math/cmplx/asin.go \\\n@@ -1450,9 +1640,12 @@ go_math_rand_files = \\\n go_mime_multipart_files = \\\n \tgo/mime/multipart/formdata.go \\\n \tgo/mime/multipart/multipart.go \\\n-\tgo/mime/multipart/quotedprintable.go \\\n \tgo/mime/multipart/writer.go\n \n+go_mime_quotedprintable_files = \\\n+\tgo/mime/quotedprintable/reader.go \\\n+\tgo/mime/quotedprintable/writer.go\n+\n go_net_http_files = \\\n \tgo/net/http/client.go \\\n \tgo/net/http/cookie.go \\\n@@ -1504,6 +1697,23 @@ go_net_http_httputil_files = \\\n go_net_http_internal_files = \\\n \tgo/net/http/internal/chunked.go\n \n+if LIBGO_IS_LINUX\n+go_net_internal_socktest_sys = go/net/internal/socktest/sys_cloexec.go\n+else\n+if LIBGO_IS_FREEBSD\n+go_net_internal_socktest_sys = go/net/internal/socktest/sys_cloexec.go\n+else\n+go_net_internal_socktest_sys =\n+endif\n+endif\n+\n+go_net_internal_socktest_files = \\\n+\tgo/net/internal/socktest/switch.go \\\n+\tgo/net/internal/socktest/switch_posix.go \\\n+\tgo/net/internal/socktest/switch_unix.go \\\n+\tgo/net/internal/socktest/sys_unix.go \\\n+\t$(go_net_internal_socktest_sys)\n+\n go_old_regexp_files = \\\n \tgo/old/regexp/regexp.go\n go_old_template_files = \\\n@@ -1514,6 +1724,7 @@ go_old_template_files = \\\n \n go_os_exec_files = \\\n \tgo/os/exec/exec.go \\\n+\tgo/os/exec/exec_posix.go \\\n \tgo/os/exec/lp_unix.go\n \n go_os_signal_files = \\\n@@ -1565,6 +1776,7 @@ go_text_template_files = \\\n \tgo/text/template/exec.go \\\n \tgo/text/template/funcs.go \\\n \tgo/text/template/helper.go \\\n+\tgo/text/template/option.go \\\n \tgo/text/template/template.go\n go_text_template_parse_files = \\\n \tgo/text/template/parse/lex.go \\\n@@ -1767,6 +1979,12 @@ else\n syscall_creds_test_file =\n endif\n \n+if LIBGO_IS_LINUX\n+syscall_exec_test_file = go/syscall/exec_linux_test.go go/syscall/syscall_linux_test.go\n+else\n+syscall_exec_test_file =\n+endif\n+\n go_base_syscall_files = \\\n \tgo/syscall/env_unix.go \\\n \tgo/syscall/syscall_errno.go \\\n@@ -1810,21 +2028,14 @@ go_syscall_c_files = \\\n \n go_syscall_test_files = \\\n \t$(syscall_creds_test_file) \\\n+\t$(syscall_exec_test_file) \\\n+\tgo/syscall/exec_unix_test.go \\\n \tgo/syscall/export_test.go \\\n+\tgo/syscall/export_unix_test.go \\\n \tgo/syscall/mmap_unix_test.go \\\n \tgo/syscall/syscall_test.go \\\n \tgo/syscall/syscall_unix_test.go\n \n-if LIBGO_IS_LINUX\n-internal_syscall_getrandom_file = go/internal/syscall/getrandom_linux.go\n-else\n-internal_syscall_getrandom_file =\n-endif\n-\n-go_internal_syscall_files = \\\n-\tgo/internal/syscall/dummy.go \\\n-\t$(internal_syscall_getrandom_file)\n-\n libcalls.go: s-libcalls; @true\n s-libcalls: libcalls-list go/syscall/mksyscall.awk $(go_base_syscall_files)\n \trm -f libcalls.go.tmp\n@@ -1978,12 +2189,17 @@ libgo_go_objs = \\\n \thtml/template.lo \\\n \tgo/ast.lo \\\n \tgo/build.lo \\\n+\tgo/constant.lo \\\n \tgo/doc.lo \\\n \tgo/format.lo \\\n+\tgo/importer.lo \\\n+\tgo/internal/gcimporter.lo \\\n+\tgo/internal/gccgoimporter.lo \\\n \tgo/parser.lo \\\n \tgo/printer.lo \\\n \tgo/scanner.lo \\\n \tgo/token.lo \\\n+\tgo/types.lo \\\n \thash/adler32.lo \\\n \thash/crc32.lo \\\n \thash/crc64.lo \\\n@@ -1999,18 +2215,25 @@ libgo_go_objs = \\\n \timage/color/palette.lo \\\n \timage/draw.lo \\\n \timage/gif.lo \\\n+\timage/internal/imageutil.lo \\\n \timage/jpeg.lo \\\n \timage/png.lo \\\n \tindex/suffixarray.lo \\\n-\tinternal/syscall.lo \\\n+\tinternal/format.lo \\\n+\tinternal/singleflight.lo \\\n+\tinternal/syscall/unix.lo \\\n+\tinternal/testenv.lo \\\n+\tinternal/trace.lo \\\n \tio/ioutil.lo \\\n \tlog/syslog.lo \\\n \tlog/syslog/syslog_c.lo \\\n \tmath/big.lo \\\n \tmath/cmplx.lo \\\n \tmath/rand.lo \\\n \tmime/multipart.lo \\\n+\tmime/quotedprintable.lo \\\n \tnet/http.lo \\\n+\tnet/internal/socktest.lo \\\n \tnet/mail.lo \\\n \tnet/rpc.lo \\\n \tnet/smtp.lo \\\n@@ -2121,11 +2344,11 @@ CHECK = \\\n \t$(MKDIR_P) $(@D); \\\n \trm -f $@-testsum $@-testlog; \\\n \tif test \"$(USE_DEJAGNU)\" = \"yes\"; then \\\n-\t  $(SHELL) $(srcdir)/testsuite/gotest --dejagnu=yes --basedir=$(srcdir) --srcdir=$(srcdir)/go/$(@D) --pkgpath=\"$(@D)\" --pkgfiles=\"$(go_$(subst /,_,$(@D))_files)\" --testname=\"$(@D)\" --goarch=\"$(GOARCH)\" $(GOTESTFLAGS) $(go_$(subst /,_,$(@D))_test_files); \\\n+\t  $(SHELL) $(srcdir)/testsuite/gotest --goarch=$(GOARCH) --goos=$(GOOS) --dejagnu=yes --basedir=$(srcdir) --srcdir=$(srcdir)/go/$(@D) --pkgpath=\"$(@D)\" --pkgfiles=\"$(go_$(subst /,_,$(@D))_files)\" --testname=\"$(@D)\" --goarch=\"$(GOARCH)\" $(GOTESTFLAGS) $(go_$(subst /,_,$(@D))_test_files); \\\n \telif test \"$(GOBENCH)\" != \"\"; then \\\n-\t  $(SHELL) $(srcdir)/testsuite/gotest --basedir=$(srcdir) --srcdir=$(srcdir)/go/$(@D) --pkgpath=\"$(@D)\" --pkgfiles=\"$(go_$(subst /,_,$(@D))_files)\" --goarch=\"$(GOARCH)\" --bench=\"$(GOBENCH)\" $(GOTESTFLAGS) $(go_$(subst /,_,$(@D))_test_files); \\\n+\t  $(SHELL) $(srcdir)/testsuite/gotest --goarch=$(GOARCH) --goos=$(GOOS) --basedir=$(srcdir) --srcdir=$(srcdir)/go/$(@D) --pkgpath=\"$(@D)\" --pkgfiles=\"$(go_$(subst /,_,$(@D))_files)\" --goarch=\"$(GOARCH)\" --bench=\"$(GOBENCH)\" $(GOTESTFLAGS) $(go_$(subst /,_,$(@D))_test_files); \\\n \telse \\\n-\t  if $(SHELL) $(srcdir)/testsuite/gotest --basedir=$(srcdir) --srcdir=$(srcdir)/go/$(@D) --pkgpath=\"$(@D)\" --pkgfiles=\"$(go_$(subst /,_,$(@D))_files)\" --goarch=\"$(GOARCH)\" $(GOTESTFLAGS) $(go_$(subst /,_,$(@D))_test_files) >>$@-testlog 2>&1; then \\\n+\t  if $(SHELL) $(srcdir)/testsuite/gotest --goarch=$(GOARCH) --goos=$(GOOS) --basedir=$(srcdir) --srcdir=$(srcdir)/go/$(@D) --pkgpath=\"$(@D)\" --pkgfiles=\"$(go_$(subst /,_,$(@D))_files)\" --goarch=\"$(GOARCH)\" $(GOTESTFLAGS) $(go_$(subst /,_,$(@D))_test_files) >>$@-testlog 2>&1; then \\\n \t    echo \"PASS: $(@D)\" >> $@-testlog; \\\n \t    echo \"PASS: $(@D)\"; \\\n \t    echo \"PASS: $(@D)\" > $@-testsum; \\\n@@ -2910,6 +3133,15 @@ go/build/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: go/build/check\n \n+@go_include@ go/constant.lo.dep\n+go/constant.lo.dep: $(go_go_constant_files)\n+\t$(BUILDDEPS)\n+go/constant.lo: $(go_go_constant_files)\n+\t$(BUILDPACKAGE)\n+go/constant/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: go/constant/check\n+\n @go_include@ go/doc.lo.dep\n go/doc.lo.dep: $(go_go_doc_files)\n \t$(BUILDDEPS)\n@@ -2928,6 +3160,15 @@ go/format/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: go/format/check\n \n+@go_include@ go/importer.lo.dep\n+go/importer.lo.dep: $(go_go_importer_files)\n+\t$(BUILDDEPS)\n+go/importer.lo: $(go_go_importer_files)\n+\t$(BUILDPACKAGE)\n+go/importer/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: go/importer/check\n+\n @go_include@ go/parser.lo.dep\n go/parser.lo.dep: $(go_go_parser_files)\n \t$(BUILDDEPS)\n@@ -2964,6 +3205,33 @@ go/token/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: go/token/check\n \n+@go_include@ go/types.lo.dep\n+go/types.lo.dep: $(go_go_types_files)\n+\t$(BUILDDEPS)\n+go/types.lo: $(go_go_types_files)\n+\t$(BUILDPACKAGE)\n+go/types/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: go/types/check\n+\n+@go_include@ go/internal/gcimporter.lo.dep\n+go/internal/gcimporter.lo.dep: $(go_go_internal_gcimporter_files)\n+\t$(BUILDDEPS)\n+go/internal/gcimporter.lo: $(go_go_internal_gcimporter_files)\n+\t$(BUILDPACKAGE)\n+go/internal/gcimporter/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: go/internal/gcimporter/check\n+\n+@go_include@ go/internal/gccgoimporter.lo.dep\n+go/internal/gccgoimporter.lo.dep: $(go_go_internal_gccgoimporter_files)\n+\t$(BUILDDEPS)\n+go/internal/gccgoimporter.lo: $(go_go_internal_gccgoimporter_files)\n+\t$(BUILDPACKAGE)\n+go/internal/gccgoimporter/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: go/internal/gccgoimporter/check\n+\n @go_include@ hash/adler32.lo.dep\n hash/adler32.lo.dep: $(go_hash_adler32_files)\n \t$(BUILDDEPS)\n@@ -3036,6 +3304,15 @@ image/gif/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: image/gif/check\n \n+@go_include@ image/internal/imageutil.lo.dep\n+image/internal/imageutil.lo.dep: $(go_image_internal_imageutil_files)\n+\t$(BUILDDEPS)\n+image/internal/imageutil.lo: $(go_image_internal_imageutil_files)\n+\t$(BUILDPACKAGE)\n+image/internal/imageutil/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: image/internal/imageutil/check\n+\n @go_include@ image/jpeg.lo.dep\n image/jpeg.lo.dep: $(go_image_jpeg_files)\n \t$(BUILDDEPS)\n@@ -3063,6 +3340,51 @@ index/suffixarray/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: index/suffixarray/check\n \n+@go_include@ internal/format.lo.dep\n+internal/format.lo.dep: $(go_internal_format_files)\n+\t$(BUILDDEPS)\n+internal/format.lo: $(go_internal_format_files)\n+\t$(BUILDPACKAGE)\n+internal/format/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: internal/format/check\n+\n+@go_include@ internal/singleflight.lo.dep\n+internal/singleflight.lo.dep: $(go_internal_singleflight_files)\n+\t$(BUILDDEPS)\n+internal/singleflight.lo: $(go_internal_singleflight_files)\n+\t$(BUILDPACKAGE)\n+internal/singleflight/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: internal/singleflight/check\n+\n+@go_include@ internal/syscall/unix.lo.dep\n+internal/syscall/unix.lo.dep: $(go_internal_syscall_unix_files)\n+\t$(BUILDDEPS)\n+internal/syscall/unix.lo: $(go_internal_syscall_unix_files)\n+\t$(BUILDPACKAGE)\n+internal/syscall/unix/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: internal/syscall/unix/check\n+\n+@go_include@ internal/testenv.lo.dep\n+internal/testenv.lo.dep: $(go_internal_testenv_files)\n+\t$(BUILDDEPS)\n+internal/testenv.lo: $(go_internal_testenv_files)\n+\t$(BUILDPACKAGE)\n+internal/testenv/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: internal/testenv/check\n+\n+@go_include@ internal/trace.lo.dep\n+internal/trace.lo.dep: $(go_internal_trace_files)\n+\t$(BUILDDEPS)\n+internal/trace.lo: $(go_internal_trace_files)\n+\t$(BUILDPACKAGE)\n+internal/trace/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: internal/trace/check\n+\n @go_include@ io/ioutil.lo.dep\n io/ioutil.lo.dep: $(go_io_ioutil_files)\n \t$(BUILDDEPS)\n@@ -3120,6 +3442,15 @@ mime/multipart/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: mime/multipart/check\n \n+@go_include@ mime/quotedprintable.lo.dep\n+mime/quotedprintable.lo.dep: $(go_mime_quotedprintable_files)\n+\t$(BUILDDEPS)\n+mime/quotedprintable.lo: $(go_mime_quotedprintable_files)\n+\t$(BUILDPACKAGE)\n+mime/quotedprintable/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: mime/quotedprintable/check\n+\n @go_include@ net/http.lo.dep\n net/http.lo.dep: $(go_net_http_files)\n \t$(BUILDDEPS)\n@@ -3237,6 +3568,15 @@ net/http/pprof/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: net/http/pprof/check\n \n+@go_include@ net/internal/socktest.lo.dep\n+net/internal/socktest.lo.dep: $(go_net_internal_socktest_files)\n+\t$(BUILDDEPS)\n+net/internal/socktest.lo: $(go_net_internal_socktest_files)\n+\t$(BUILDPACKAGE)\n+net/internal/socktest/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: net/internal/socktest/check\n+\n @go_include@ net/rpc/jsonrpc.lo.dep\n net/rpc/jsonrpc.lo.dep: $(go_net_rpc_jsonrpc_files)\n \t$(BUILDDEPS)\n@@ -3432,15 +3772,6 @@ syscall/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: syscall/check\n \n-@go_include@ internal/syscall.lo.dep\n-internal/syscall.lo.dep: $(go_internal_syscall_files)\n-\t$(BUILDDEPS)\n-internal/syscall.lo: $(go_internal_syscall_files)\n-\t$(BUILDPACKAGE)\n-internal/syscall/check: $(CHECK_DEPS)\n-\t@$(CHECK)\n-.PHONY: internal/syscall/check\n-\n # How to build a .gox file from a .lo file.\n BUILDGOX = \\\n \tf=`echo $< | sed -e 's/.lo$$/.o/'`; \\\n@@ -3620,10 +3951,14 @@ go/ast.gox: go/ast.lo\n \t$(BUILDGOX)\n go/build.gox: go/build.lo\n \t$(BUILDGOX)\n+go/constant.gox: go/constant.lo\n+\t$(BUILDGOX)\n go/doc.gox: go/doc.lo\n \t$(BUILDGOX)\n go/format.gox: go/format.lo\n \t$(BUILDGOX)\n+go/importer.gox: go/importer.lo\n+\t$(BUILDGOX)\n go/parser.gox: go/parser.lo\n \t$(BUILDGOX)\n go/printer.gox: go/printer.lo\n@@ -3632,6 +3967,13 @@ go/scanner.gox: go/scanner.lo\n \t$(BUILDGOX)\n go/token.gox: go/token.lo\n \t$(BUILDGOX)\n+go/types.gox: go/types.lo\n+\t$(BUILDGOX)\n+\n+go/internal/gcimporter.gox: go/internal/gcimporter.lo\n+\t$(BUILDGOX)\n+go/internal/gccgoimporter.gox: go/internal/gccgoimporter.lo\n+\t$(BUILDGOX)\n \n hash/adler32.gox: hash/adler32.lo\n \t$(BUILDGOX)\n@@ -3648,6 +3990,8 @@ image/draw.gox: image/draw.lo\n \t$(BUILDGOX)\n image/gif.gox: image/gif.lo\n \t$(BUILDGOX)\n+image/internal/imageutil.gox: image/internal/imageutil.lo\n+\t$(BUILDGOX)\n image/jpeg.gox: image/jpeg.lo\n \t$(BUILDGOX)\n image/png.gox: image/png.lo\n@@ -3659,6 +4003,17 @@ image/color/palette.gox: image/color/palette.lo\n index/suffixarray.gox: index/suffixarray.lo\n \t$(BUILDGOX)\n \n+internal/format.gox: internal/format.lo\n+\t$(BUILDGOX)\n+internal/singleflight.gox: internal/singleflight.lo\n+\t$(BUILDGOX)\n+internal/syscall/unix.gox: internal/syscall/unix.lo\n+\t$(BUILDGOX)\n+internal/testenv.gox: internal/testenv.lo\n+\t$(BUILDGOX)\n+internal/trace.gox: internal/trace.lo\n+\t$(BUILDGOX)\n+\n io/ioutil.gox: io/ioutil.lo\n \t$(BUILDGOX)\n \n@@ -3674,6 +4029,8 @@ math/rand.gox: math/rand.lo\n \n mime/multipart.gox: mime/multipart.lo\n \t$(BUILDGOX)\n+mime/quotedprintable.gox: mime/quotedprintable.lo\n+\t$(BUILDGOX)\n \n net/http.gox: net/http.lo\n \t$(BUILDGOX)\n@@ -3704,6 +4061,9 @@ net/http/pprof.gox: net/http/pprof.lo\n net/http/internal.gox: net/http/internal.lo\n \t$(BUILDGOX)\n \n+net/internal/socktest.gox: net/internal/socktest.lo\n+\t$(BUILDGOX)\n+\n net/rpc/jsonrpc.gox: net/rpc/jsonrpc.lo\n \t$(BUILDGOX)\n \n@@ -3733,9 +4093,6 @@ runtime/pprof.gox: runtime/pprof.lo\n sync/atomic.gox: sync/atomic.lo\n \t$(BUILDGOX)\n \n-internal/syscall.gox: internal/syscall.lo\n-\t$(BUILDGOX)\n-\n text/scanner.gox: text/scanner.lo\n \t$(BUILDGOX)\n text/tabwriter.gox: text/tabwriter.lo\n@@ -3830,13 +4187,17 @@ TEST_PACKAGES = \\\n \texp/terminal/check \\\n \thtml/template/check \\\n \tgo/ast/check \\\n-\t$(go_build_check_omitted_since_it_calls_6g) \\\n+\tgo/build/check \\\n+\tgo/constant/check \\\n \tgo/doc/check \\\n \tgo/format/check \\\n+\tgo/internal/gcimporter/check \\\n+\tgo/internal/gccgoimporter/check \\\n \tgo/parser/check \\\n \tgo/printer/check \\\n \tgo/scanner/check \\\n \tgo/token/check \\\n+\tgo/types/check \\\n \thash/adler32/check \\\n \thash/crc32/check \\\n \thash/crc64/check \\\n@@ -3846,19 +4207,23 @@ TEST_PACKAGES = \\\n \timage/jpeg/check \\\n \timage/png/check \\\n \tindex/suffixarray/check \\\n+\tinternal/singleflight/check \\\n+\tinternal/trace/check \\\n \tio/ioutil/check \\\n \tlog/syslog/check \\\n \tmath/big/check \\\n \tmath/cmplx/check \\\n \tmath/rand/check \\\n \tmime/multipart/check \\\n+\tmime/quotedprintable/check \\\n \tnet/http/check \\\n \tnet/http/cgi/check \\\n \tnet/http/cookiejar/check \\\n \tnet/http/fcgi/check \\\n \tnet/http/httptest/check \\\n \tnet/http/httputil/check \\\n \tnet/http/internal/check \\\n+\tnet/internal/socktest/check \\\n \tnet/mail/check \\\n \tnet/rpc/check \\\n \tnet/smtp/check \\"}, {"sha": "9e0e98e5b72f9b429ae30595c47658217c2a4004", "filename": "libgo/Makefile.in", "status": "modified", "additions": 348, "deletions": 38, "changes": 386, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -196,16 +196,21 @@ am__DEPENDENCIES_2 = bufio.lo bytes.lo bytes/index.lo crypto.lo \\\n \tencoding/binary.lo encoding/csv.lo encoding/gob.lo \\\n \tencoding/hex.lo encoding/json.lo encoding/pem.lo \\\n \tencoding/xml.lo exp/proxy.lo exp/terminal.lo html/template.lo \\\n-\tgo/ast.lo go/build.lo go/doc.lo go/format.lo go/parser.lo \\\n-\tgo/printer.lo go/scanner.lo go/token.lo hash/adler32.lo \\\n+\tgo/ast.lo go/build.lo go/constant.lo go/doc.lo go/format.lo \\\n+\tgo/importer.lo go/internal/gcimporter.lo \\\n+\tgo/internal/gccgoimporter.lo go/parser.lo go/printer.lo \\\n+\tgo/scanner.lo go/token.lo go/types.lo hash/adler32.lo \\\n \thash/crc32.lo hash/crc64.lo hash/fnv.lo net/http/cgi.lo \\\n \tnet/http/cookiejar.lo net/http/fcgi.lo net/http/httptest.lo \\\n \tnet/http/httputil.lo net/http/internal.lo net/http/pprof.lo \\\n \timage/color.lo image/color/palette.lo image/draw.lo \\\n-\timage/gif.lo image/jpeg.lo image/png.lo index/suffixarray.lo \\\n-\tinternal/syscall.lo io/ioutil.lo log/syslog.lo \\\n-\tlog/syslog/syslog_c.lo math/big.lo math/cmplx.lo math/rand.lo \\\n-\tmime/multipart.lo net/http.lo net/mail.lo net/rpc.lo \\\n+\timage/gif.lo image/internal/imageutil.lo image/jpeg.lo \\\n+\timage/png.lo index/suffixarray.lo internal/format.lo \\\n+\tinternal/singleflight.lo internal/syscall/unix.lo \\\n+\tinternal/testenv.lo internal/trace.lo io/ioutil.lo \\\n+\tlog/syslog.lo log/syslog/syslog_c.lo math/big.lo math/cmplx.lo \\\n+\tmath/rand.lo mime/multipart.lo mime/quotedprintable.lo \\\n+\tnet/http.lo net/internal/socktest.lo net/mail.lo net/rpc.lo \\\n \tnet/smtp.lo net/textproto.lo net/url.lo old/regexp.lo \\\n \told/template.lo os/exec.lo $(am__DEPENDENCIES_1) os/signal.lo \\\n \tos/user.lo path/filepath.lo regexp/syntax.lo \\\n@@ -681,12 +686,15 @@ toolexeclibgogodir = $(toolexeclibgodir)/go\n toolexeclibgogo_DATA = \\\n \tgo/ast.gox \\\n \tgo/build.gox \\\n+\tgo/constant.gox \\\n \tgo/doc.gox \\\n \tgo/format.gox \\\n+\tgo/importer.gox \\\n \tgo/parser.gox \\\n \tgo/printer.gox \\\n \tgo/scanner.gox \\\n-\tgo/token.gox\n+\tgo/token.gox \\\n+\tgo/types.gox\n \n toolexeclibgohashdir = $(toolexeclibgodir)/hash\n toolexeclibgohash_DATA = \\\n@@ -731,7 +739,8 @@ toolexeclibgomath_DATA = \\\n \n toolexeclibgomimedir = $(toolexeclibgodir)/mime\n toolexeclibgomime_DATA = \\\n-\tmime/multipart.gox\n+\tmime/multipart.gox \\\n+\tmime/quotedprintable.gox\n \n toolexeclibgonetdir = $(toolexeclibgodir)/net\n toolexeclibgonet_DATA = \\\n@@ -1023,16 +1032,22 @@ go_math_files = \\\n \tgo/math/tanh.go \\\n \tgo/math/unsafe.go\n \n+@LIBGO_IS_DRAGONFLY_FALSE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_OPENBSD_FALSE@go_mime_type_file = \n+@LIBGO_IS_DRAGONFLY_TRUE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_OPENBSD_FALSE@go_mime_type_file = go/mime/type_dragonfly.go\n+@LIBGO_IS_FREEBSD_TRUE@@LIBGO_IS_OPENBSD_FALSE@go_mime_type_file = go/mime/type_freebsd.go\n+@LIBGO_IS_OPENBSD_TRUE@go_mime_type_file = go/mime/type_openbsd.go\n go_mime_files = \\\n+\tgo/mime/encodedword.go \\\n \tgo/mime/grammar.go \\\n \tgo/mime/mediatype.go \\\n \tgo/mime/type.go \\\n-\tgo/mime/type_unix.go\n+\tgo/mime/type_unix.go \\\n+\t$(go_mime_type_file)\n \n @LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_net_cgo_file = go/net/cgo_bsd.go\n @LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_TRUE@@LIBGO_IS_SOLARIS_FALSE@go_net_cgo_file = go/net/cgo_netbsd.go\n @LIBGO_IS_FREEBSD_TRUE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_net_cgo_file = go/net/cgo_bsd.go\n-@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@go_net_cgo_file = go/net/cgo_linux.go\n+@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@go_net_cgo_file = go/net/cgo_solaris.go\n @LIBGO_IS_IRIX_TRUE@@LIBGO_IS_LINUX_FALSE@go_net_cgo_file = go/net/cgo_linux.go\n @LIBGO_IS_LINUX_TRUE@go_net_cgo_file = go/net/cgo_linux.go\n @LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_net_sock_file = go/net/sock_bsd.go\n@@ -1053,7 +1068,20 @@ go_mime_files = \\\n @LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@go_net_sockoptip_file = go/net/sockoptip_stub.go\n @LIBGO_IS_IRIX_TRUE@@LIBGO_IS_LINUX_FALSE@go_net_sockoptip_file = go/net/sockoptip_linux.go go/net/sockoptip_posix.go\n @LIBGO_IS_LINUX_TRUE@go_net_sockoptip_file = go/net/sockoptip_linux.go go/net/sockoptip_posix.go\n-@LIBGO_IS_DRAGONFLY_FALSE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_LINUX_FALSE@go_net_sendfile_file = go/net/sendfile_stub.go\n+@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_net_cgo_sock_file = go/net/cgo_sockold.go\n+@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_TRUE@@LIBGO_IS_SOLARIS_FALSE@go_net_cgo_sock_file = go/net/cgo_sockold.go\n+@LIBGO_IS_FREEBSD_TRUE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_net_cgo_sock_file = go/net/cgo_sockold.go\n+@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@go_net_cgo_sock_file = go/net/cgo_socknew.go\n+@LIBGO_IS_IRIX_TRUE@@LIBGO_IS_LINUX_FALSE@go_net_cgo_sock_file = go/net/cgo_socknew.go\n+@LIBGO_IS_LINUX_TRUE@go_net_cgo_sock_file = go/net/cgo_socknew.go\n+@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_net_cgo_res_file = go/net/cgo_resold.go\n+@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_TRUE@@LIBGO_IS_SOLARIS_FALSE@go_net_cgo_res_file = go/net/cgo_resnew.go\n+@LIBGO_IS_FREEBSD_TRUE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_net_cgo_res_file = go/net/cgo_resold.go\n+@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@go_net_cgo_res_file = go/net/cgo_resnew.go\n+@LIBGO_IS_IRIX_TRUE@@LIBGO_IS_LINUX_FALSE@go_net_cgo_res_file = go/net/cgo_resnew.go\n+@LIBGO_IS_LINUX_TRUE@go_net_cgo_res_file = go/net/cgo_resnew.go\n+@LIBGO_IS_DRAGONFLY_FALSE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_net_sendfile_file = go/net/sendfile_stub.go\n+@LIBGO_IS_DRAGONFLY_FALSE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@go_net_sendfile_file = go/net/sendfile_solaris.go\n @LIBGO_IS_DRAGONFLY_TRUE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_LINUX_FALSE@go_net_sendfile_file = go/net/sendfile_dragonfly.go\n @LIBGO_IS_FREEBSD_TRUE@@LIBGO_IS_LINUX_FALSE@go_net_sendfile_file = go/net/sendfile_freebsd.go\n @LIBGO_IS_LINUX_TRUE@go_net_sendfile_file = go/net/sendfile_linux.go\n@@ -1069,15 +1097,22 @@ go_mime_files = \\\n @LIBGO_IS_DARWIN_TRUE@@LIBGO_IS_OPENBSD_FALSE@go_net_tcpsockopt_file = go/net/tcpsockopt_darwin.go\n @LIBGO_IS_OPENBSD_TRUE@go_net_tcpsockopt_file = go/net/tcpsockopt_openbsd.go\n go_net_common_files = \\\n+\tgo/net/addrselect.go \\\n \t$(go_net_cloexec_file) \\\n+\tgo/net/conf.go \\\n \tgo/net/dial.go \\\n \tgo/net/dnsclient.go \\\n \tgo/net/dnsclient_unix.go \\\n \tgo/net/dnsconfig_unix.go \\\n \tgo/net/dnsmsg.go \\\n \tgo/net/fd_mutex.go \\\n+\tgo/net/fd_posix.go \\\n \tgo/net/fd_unix.go \\\n+\tgo/net/file.go \\\n \tgo/net/file_unix.go \\\n+\tgo/net/hook.go \\\n+\tgo/net/hook_cloexec.go \\\n+\tgo/net/hook_unix.go \\\n \tgo/net/hosts.go \\\n \tgo/net/interface.go \\\n \t$(go_net_interface_file) \\\n@@ -1090,14 +1125,14 @@ go_net_common_files = \\\n \tgo/net/lookup_unix.go \\\n \tgo/net/mac.go \\\n \tgo/net/net.go \\\n+\tgo/net/nss.go \\\n \tgo/net/parse.go \\\n \tgo/net/pipe.go \\\n \tgo/net/fd_poll_runtime.go \\\n \tgo/net/port.go \\\n \tgo/net/port_unix.go \\\n \tgo/net/race0.go \\\n \t$(go_net_sendfile_file) \\\n-\tgo/net/singleflight.go \\\n \tgo/net/sock_posix.go \\\n \t$(go_net_sock_file) \\\n \tgo/net/sockopt_posix.go \\\n@@ -1115,6 +1150,8 @@ go_net_common_files = \\\n go_net_files = \\\n \tgo/net/cgo_unix.go \\\n \t$(go_net_cgo_file) \\\n+\t$(go_net_cgo_res_file) \\\n+\t$(go_net_cgo_sock_file) \\\n \t$(go_net_common_files)\n \n go_netgo_files = \\\n@@ -1147,6 +1184,13 @@ go_netgo_files = \\\n @LIBGO_IS_LINUX_TRUE@@LIBGO_IS_SOLARIS_FALSE@go_os_stat_file = go/os/stat_atim.go\n @LIBGO_IS_LINUX_FALSE@go_os_pipe_file = go/os/pipe_bsd.go\n @LIBGO_IS_LINUX_TRUE@go_os_pipe_file = go/os/pipe_linux.go\n+@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_DRAGONFLY_FALSE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_OPENBSD_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_os_sticky_file = go/os/sticky_notbsd.go\n+@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_DRAGONFLY_FALSE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_OPENBSD_FALSE@@LIBGO_IS_SOLARIS_TRUE@go_os_sticky_file = go/os/sticky_bsd.go\n+@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_DRAGONFLY_FALSE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_OPENBSD_TRUE@go_os_sticky_file = go/os/sticky_bsd.go\n+@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_DRAGONFLY_FALSE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_NETBSD_TRUE@go_os_sticky_file = go/os/sticky_bsd.go\n+@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_DRAGONFLY_FALSE@@LIBGO_IS_FREEBSD_TRUE@go_os_sticky_file = go/os/sticky_bsd.go\n+@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_DRAGONFLY_TRUE@go_os_sticky_file = go/os/sticky_bsd.go\n+@LIBGO_IS_DARWIN_TRUE@go_os_sticky_file = go/os/sticky_bsd.go\n go_os_files = \\\n \t$(go_os_dir_file) \\\n \tgo/os/dir.go \\\n@@ -1167,6 +1211,7 @@ go_os_files = \\\n \t$(go_os_pipe_file) \\\n \tgo/os/proc.go \\\n \t$(go_os_stat_file) \\\n+\t$(go_os_sticky_file) \\\n \tgo/os/str.go \\\n \t$(go_os_sys_file) \\\n \t$(go_os_cloexec_file) \\\n@@ -1188,6 +1233,7 @@ go_reflect_makefunc_c_file = \\\n \tgo/reflect/makefunc_ffi_c.c\n \n go_regexp_files = \\\n+\tgo/regexp/backtrack.go \\\n \tgo/regexp/exec.go \\\n \tgo/regexp/onepass.go \\\n \tgo/regexp/regexp.go\n@@ -1203,7 +1249,6 @@ go_runtime_files = \\\n \tgo/runtime/error.go \\\n \tgo/runtime/extern.go \\\n \tgo/runtime/mem.go \\\n-\tgo/runtime/softfloat64.go \\\n \tversion.go\n \n noinst_DATA = zstdpkglist.go\n@@ -1216,13 +1261,15 @@ go_strconv_files = \\\n \tgo/strconv/atof.go \\\n \tgo/strconv/atoi.go \\\n \tgo/strconv/decimal.go \\\n+\tgo/strconv/doc.go \\\n \tgo/strconv/extfloat.go \\\n \tgo/strconv/ftoa.go \\\n \tgo/strconv/isprint.go \\\n \tgo/strconv/itoa.go \\\n \tgo/strconv/quote.go\n \n go_strings_files = \\\n+\tgo/strings/compare.go \\\n \tgo/strings/reader.go \\\n \tgo/strings/replace.go \\\n \tgo/strings/search.go \\\n@@ -1246,6 +1293,7 @@ go_sync_files = \\\n @LIBGO_IS_IRIX_TRUE@@LIBGO_IS_SOLARIS_FALSE@go_syslog_file = go/log/syslog/syslog_libc.go\n @LIBGO_IS_SOLARIS_TRUE@go_syslog_file = go/log/syslog/syslog_libc.go\n go_log_syslog_files = \\\n+\tgo/log/syslog/doc.go \\\n \tgo/log/syslog/syslog.go \\\n \t$(go_syslog_file)\n \n@@ -1375,6 +1423,7 @@ go_crypto_md5_files = \\\n @LIBGO_IS_LINUX_FALSE@crypto_rand_file = \n @LIBGO_IS_LINUX_TRUE@crypto_rand_file = go/crypto/rand/rand_linux.go\n go_crypto_rand_files = \\\n+\tgo/crypto/rand/eagain.go \\\n \tgo/crypto/rand/rand.go \\\n \tgo/crypto/rand/rand_unix.go \\\n \t$(crypto_rand_file) \\\n@@ -1418,13 +1467,22 @@ go_crypto_tls_files = \\\n \tgo/crypto/tls/ticket.go \\\n \tgo/crypto/tls/tls.go\n \n+@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_DRAGONFLY_FALSE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_OPENBSD_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_crypto_x509_root_file = \n+@LIBGO_IS_DARWIN_TRUE@@LIBGO_IS_DRAGONFLY_FALSE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_OPENBSD_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_crypto_x509_root_file = go/crypto/x509/root_darwin.go\n+@LIBGO_IS_DRAGONFLY_FALSE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_OPENBSD_TRUE@@LIBGO_IS_SOLARIS_FALSE@go_crypto_x509_root_file = go/crypto/x509/root_bsd.go\n+@LIBGO_IS_DRAGONFLY_FALSE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_TRUE@@LIBGO_IS_SOLARIS_FALSE@go_crypto_x509_root_file = go/crypto/x509/root_bsd.go\n+@LIBGO_IS_DRAGONFLY_FALSE@@LIBGO_IS_FREEBSD_TRUE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_crypto_x509_root_file = go/crypto/x509/root_bsd.go\n+@LIBGO_IS_DRAGONFLY_TRUE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_crypto_x509_root_file = go/crypto/x509/root_bsd.go\n+@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@go_crypto_x509_root_file = go/crypto/x509/root_solaris.go\n+@LIBGO_IS_LINUX_TRUE@go_crypto_x509_root_file = go/crypto/x509/root_linux.go\n go_crypto_x509_files = \\\n \tgo/crypto/x509/cert_pool.go \\\n \tgo/crypto/x509/pem_decrypt.go \\\n \tgo/crypto/x509/pkcs1.go \\\n \tgo/crypto/x509/pkcs8.go \\\n \tgo/crypto/x509/root.go \\\n \tgo/crypto/x509/root_unix.go \\\n+\t$(go_crypto_x509_root_file) \\\n \tgo/crypto/x509/sec1.go \\\n \tgo/crypto/x509/verify.go \\\n \tgo/crypto/x509/x509.go\n@@ -1442,6 +1500,7 @@ go_database_sql_driver_files = \\\n \n go_debug_dwarf_files = \\\n \tgo/debug/dwarf/buf.go \\\n+\tgo/debug/dwarf/class_string.go \\\n \tgo/debug/dwarf/const.go \\\n \tgo/debug/dwarf/entry.go \\\n \tgo/debug/dwarf/line.go \\\n@@ -1551,6 +1610,10 @@ go_go_build_files = \\\n \tgo/go/build/read.go \\\n \tgo/go/build/syslist.go\n \n+go_go_constant_files = \\\n+\tgo/go/constant/go14.go \\\n+\tgo/go/constant/value.go\n+\n go_go_doc_files = \\\n \tgo/go/doc/comment.go \\\n \tgo/go/doc/doc.go \\\n@@ -1563,6 +1626,9 @@ go_go_doc_files = \\\n go_go_format_files = \\\n \tgo/go/format/format.go\n \n+go_go_importer_files = \\\n+\tgo/go/importer/importer.go\n+\n go_go_parser_files = \\\n \tgo/go/parser/interface.go \\\n \tgo/go/parser/parser.go\n@@ -1580,6 +1646,49 @@ go_go_token_files = \\\n \tgo/go/token/serialize.go \\\n \tgo/go/token/token.go\n \n+go_go_types_files = \\\n+\tgo/go/types/api.go \\\n+\tgo/go/types/assignments.go \\\n+\tgo/go/types/builtins.go \\\n+\tgo/go/types/call.go \\\n+\tgo/go/types/check.go \\\n+\tgo/go/types/conversions.go \\\n+\tgo/go/types/decl.go \\\n+\tgo/go/types/errors.go \\\n+\tgo/go/types/eval.go \\\n+\tgo/go/types/expr.go \\\n+\tgo/go/types/exprstring.go \\\n+\tgo/go/types/go12.go \\\n+\tgo/go/types/initorder.go \\\n+\tgo/go/types/labels.go \\\n+\tgo/go/types/lookup.go \\\n+\tgo/go/types/methodset.go \\\n+\tgo/go/types/object.go \\\n+\tgo/go/types/objset.go \\\n+\tgo/go/types/operand.go \\\n+\tgo/go/types/ordering.go \\\n+\tgo/go/types/package.go \\\n+\tgo/go/types/predicates.go \\\n+\tgo/go/types/resolver.go \\\n+\tgo/go/types/return.go \\\n+\tgo/go/types/scope.go \\\n+\tgo/go/types/selection.go \\\n+\tgo/go/types/stmt.go \\\n+\tgo/go/types/sizes.go \\\n+\tgo/go/types/type.go \\\n+\tgo/go/types/typestring.go \\\n+\tgo/go/types/typexpr.go \\\n+\tgo/go/types/universe.go\n+\n+go_go_internal_gcimporter_files = \\\n+\tgo/go/internal/gcimporter/exportdata.go \\\n+\tgo/go/internal/gcimporter/gcimporter.go\n+\n+go_go_internal_gccgoimporter_files = \\\n+\tgo/go/internal/gccgoimporter/gccgoinstallation.go \\\n+\tgo/go/internal/gccgoimporter/importer.go \\\n+\tgo/go/internal/gccgoimporter/parser.go\n+\n go_hash_adler32_files = \\\n \tgo/hash/adler32/adler32.go\n \n@@ -1621,6 +1730,10 @@ go_image_gif_files = \\\n \tgo/image/gif/reader.go \\\n \tgo/image/gif/writer.go\n \n+go_image_internal_imageutil_files = \\\n+\tgo/image/internal/imageutil/imageutil.go \\\n+\tgo/image/internal/imageutil/impl.go\n+\n go_image_jpeg_files = \\\n \tgo/image/jpeg/fdct.go \\\n \tgo/image/jpeg/huffman.go \\\n@@ -1638,15 +1751,44 @@ go_index_suffixarray_files = \\\n \tgo/index/suffixarray/qsufsort.go \\\n \tgo/index/suffixarray/suffixarray.go\n \n+go_internal_format_files = \\\n+\tgo/internal/format/format.go\n+\n+go_internal_singleflight_files = \\\n+\tgo/internal/singleflight/singleflight.go\n+\n+@LIBGO_IS_LINUX_FALSE@internal_syscall_unix_getrandom_file = \n+@LIBGO_IS_LINUX_TRUE@internal_syscall_unix_getrandom_file = go/internal/syscall/unix/getrandom_linux.go\n+go_internal_syscall_unix_files = \\\n+\tgo/internal/syscall/unix/dummy.go \\\n+\t$(internal_syscall_unix_getrandom_file)\n+\n+go_internal_testenv_files = \\\n+\tgo/internal/testenv/testenv.go\n+\n+go_internal_trace_files = \\\n+\tgo/internal/trace/goroutines.go \\\n+\tgo/internal/trace/parser.go\n+\n go_io_ioutil_files = \\\n \tgo/io/ioutil/ioutil.go \\\n \tgo/io/ioutil/tempfile.go\n \n go_math_big_files = \\\n+\tgo/math/big/accuracy_string.go \\\n \tgo/math/big/arith.go \\\n+\tgo/math/big/arith_decl_pure.go \\\n+\tgo/math/big/decimal.go \\\n+\tgo/math/big/float.go \\\n+\tgo/math/big/floatconv.go \\\n+\tgo/math/big/ftoa.go \\\n \tgo/math/big/int.go \\\n+\tgo/math/big/intconv.go \\\n \tgo/math/big/nat.go \\\n-\tgo/math/big/rat.go\n+\tgo/math/big/natconv.go \\\n+\tgo/math/big/rat.go \\\n+\tgo/math/big/ratconv.go \\\n+\tgo/math/big/roundingmode_string.go\n \n go_math_cmplx_files = \\\n \tgo/math/cmplx/abs.go \\\n@@ -1674,9 +1816,12 @@ go_math_rand_files = \\\n go_mime_multipart_files = \\\n \tgo/mime/multipart/formdata.go \\\n \tgo/mime/multipart/multipart.go \\\n-\tgo/mime/multipart/quotedprintable.go \\\n \tgo/mime/multipart/writer.go\n \n+go_mime_quotedprintable_files = \\\n+\tgo/mime/quotedprintable/reader.go \\\n+\tgo/mime/quotedprintable/writer.go\n+\n go_net_http_files = \\\n \tgo/net/http/client.go \\\n \tgo/net/http/cookie.go \\\n@@ -1738,6 +1883,16 @@ go_net_http_httputil_files = \\\n go_net_http_internal_files = \\\n \tgo/net/http/internal/chunked.go\n \n+@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_LINUX_FALSE@go_net_internal_socktest_sys = \n+@LIBGO_IS_FREEBSD_TRUE@@LIBGO_IS_LINUX_FALSE@go_net_internal_socktest_sys = go/net/internal/socktest/sys_cloexec.go\n+@LIBGO_IS_LINUX_TRUE@go_net_internal_socktest_sys = go/net/internal/socktest/sys_cloexec.go\n+go_net_internal_socktest_files = \\\n+\tgo/net/internal/socktest/switch.go \\\n+\tgo/net/internal/socktest/switch_posix.go \\\n+\tgo/net/internal/socktest/switch_unix.go \\\n+\tgo/net/internal/socktest/sys_unix.go \\\n+\t$(go_net_internal_socktest_sys)\n+\n go_old_regexp_files = \\\n \tgo/old/regexp/regexp.go\n \n@@ -1749,6 +1904,7 @@ go_old_template_files = \\\n \n go_os_exec_files = \\\n \tgo/os/exec/exec.go \\\n+\tgo/os/exec/exec_posix.go \\\n \tgo/os/exec/lp_unix.go\n \n go_os_signal_files = \\\n@@ -1798,6 +1954,7 @@ go_text_template_files = \\\n \tgo/text/template/exec.go \\\n \tgo/text/template/funcs.go \\\n \tgo/text/template/helper.go \\\n+\tgo/text/template/option.go \\\n \tgo/text/template/template.go\n \n go_text_template_parse_files = \\\n@@ -1917,6 +2074,8 @@ go_unicode_utf8_files = \\\n \n # Test files.\n @LIBGO_IS_LINUX_TRUE@syscall_creds_test_file = go/syscall/creds_test.go\n+@LIBGO_IS_LINUX_FALSE@syscall_exec_test_file = \n+@LIBGO_IS_LINUX_TRUE@syscall_exec_test_file = go/syscall/exec_linux_test.go go/syscall/syscall_linux_test.go\n go_base_syscall_files = \\\n \tgo/syscall/env_unix.go \\\n \tgo/syscall/syscall_errno.go \\\n@@ -1961,17 +2120,14 @@ go_syscall_c_files = \\\n \n go_syscall_test_files = \\\n \t$(syscall_creds_test_file) \\\n+\t$(syscall_exec_test_file) \\\n+\tgo/syscall/exec_unix_test.go \\\n \tgo/syscall/export_test.go \\\n+\tgo/syscall/export_unix_test.go \\\n \tgo/syscall/mmap_unix_test.go \\\n \tgo/syscall/syscall_test.go \\\n \tgo/syscall/syscall_unix_test.go\n \n-@LIBGO_IS_LINUX_FALSE@internal_syscall_getrandom_file = \n-@LIBGO_IS_LINUX_TRUE@internal_syscall_getrandom_file = go/internal/syscall/getrandom_linux.go\n-go_internal_syscall_files = \\\n-\tgo/internal/syscall/dummy.go \\\n-\t$(internal_syscall_getrandom_file)\n-\n @LIBGO_IS_LINUX_FALSE@os_lib_inotify_lo = \n \n # os_lib_inotify_lo = os/inotify.lo\n@@ -2064,12 +2220,17 @@ libgo_go_objs = \\\n \thtml/template.lo \\\n \tgo/ast.lo \\\n \tgo/build.lo \\\n+\tgo/constant.lo \\\n \tgo/doc.lo \\\n \tgo/format.lo \\\n+\tgo/importer.lo \\\n+\tgo/internal/gcimporter.lo \\\n+\tgo/internal/gccgoimporter.lo \\\n \tgo/parser.lo \\\n \tgo/printer.lo \\\n \tgo/scanner.lo \\\n \tgo/token.lo \\\n+\tgo/types.lo \\\n \thash/adler32.lo \\\n \thash/crc32.lo \\\n \thash/crc64.lo \\\n@@ -2085,18 +2246,25 @@ libgo_go_objs = \\\n \timage/color/palette.lo \\\n \timage/draw.lo \\\n \timage/gif.lo \\\n+\timage/internal/imageutil.lo \\\n \timage/jpeg.lo \\\n \timage/png.lo \\\n \tindex/suffixarray.lo \\\n-\tinternal/syscall.lo \\\n+\tinternal/format.lo \\\n+\tinternal/singleflight.lo \\\n+\tinternal/syscall/unix.lo \\\n+\tinternal/testenv.lo \\\n+\tinternal/trace.lo \\\n \tio/ioutil.lo \\\n \tlog/syslog.lo \\\n \tlog/syslog/syslog_c.lo \\\n \tmath/big.lo \\\n \tmath/cmplx.lo \\\n \tmath/rand.lo \\\n \tmime/multipart.lo \\\n+\tmime/quotedprintable.lo \\\n \tnet/http.lo \\\n+\tnet/internal/socktest.lo \\\n \tnet/mail.lo \\\n \tnet/rpc.lo \\\n \tnet/smtp.lo \\\n@@ -2203,11 +2371,11 @@ CHECK = \\\n \t$(MKDIR_P) $(@D); \\\n \trm -f $@-testsum $@-testlog; \\\n \tif test \"$(USE_DEJAGNU)\" = \"yes\"; then \\\n-\t  $(SHELL) $(srcdir)/testsuite/gotest --dejagnu=yes --basedir=$(srcdir) --srcdir=$(srcdir)/go/$(@D) --pkgpath=\"$(@D)\" --pkgfiles=\"$(go_$(subst /,_,$(@D))_files)\" --testname=\"$(@D)\" --goarch=\"$(GOARCH)\" $(GOTESTFLAGS) $(go_$(subst /,_,$(@D))_test_files); \\\n+\t  $(SHELL) $(srcdir)/testsuite/gotest --goarch=$(GOARCH) --goos=$(GOOS) --dejagnu=yes --basedir=$(srcdir) --srcdir=$(srcdir)/go/$(@D) --pkgpath=\"$(@D)\" --pkgfiles=\"$(go_$(subst /,_,$(@D))_files)\" --testname=\"$(@D)\" --goarch=\"$(GOARCH)\" $(GOTESTFLAGS) $(go_$(subst /,_,$(@D))_test_files); \\\n \telif test \"$(GOBENCH)\" != \"\"; then \\\n-\t  $(SHELL) $(srcdir)/testsuite/gotest --basedir=$(srcdir) --srcdir=$(srcdir)/go/$(@D) --pkgpath=\"$(@D)\" --pkgfiles=\"$(go_$(subst /,_,$(@D))_files)\" --goarch=\"$(GOARCH)\" --bench=\"$(GOBENCH)\" $(GOTESTFLAGS) $(go_$(subst /,_,$(@D))_test_files); \\\n+\t  $(SHELL) $(srcdir)/testsuite/gotest --goarch=$(GOARCH) --goos=$(GOOS) --basedir=$(srcdir) --srcdir=$(srcdir)/go/$(@D) --pkgpath=\"$(@D)\" --pkgfiles=\"$(go_$(subst /,_,$(@D))_files)\" --goarch=\"$(GOARCH)\" --bench=\"$(GOBENCH)\" $(GOTESTFLAGS) $(go_$(subst /,_,$(@D))_test_files); \\\n \telse \\\n-\t  if $(SHELL) $(srcdir)/testsuite/gotest --basedir=$(srcdir) --srcdir=$(srcdir)/go/$(@D) --pkgpath=\"$(@D)\" --pkgfiles=\"$(go_$(subst /,_,$(@D))_files)\" --goarch=\"$(GOARCH)\" $(GOTESTFLAGS) $(go_$(subst /,_,$(@D))_test_files) >>$@-testlog 2>&1; then \\\n+\t  if $(SHELL) $(srcdir)/testsuite/gotest --goarch=$(GOARCH) --goos=$(GOOS) --basedir=$(srcdir) --srcdir=$(srcdir)/go/$(@D) --pkgpath=\"$(@D)\" --pkgfiles=\"$(go_$(subst /,_,$(@D))_files)\" --goarch=\"$(GOARCH)\" $(GOTESTFLAGS) $(go_$(subst /,_,$(@D))_test_files) >>$@-testlog 2>&1; then \\\n \t    echo \"PASS: $(@D)\" >> $@-testlog; \\\n \t    echo \"PASS: $(@D)\"; \\\n \t    echo \"PASS: $(@D)\" > $@-testsum; \\\n@@ -2320,13 +2488,17 @@ TEST_PACKAGES = \\\n \texp/terminal/check \\\n \thtml/template/check \\\n \tgo/ast/check \\\n-\t$(go_build_check_omitted_since_it_calls_6g) \\\n+\tgo/build/check \\\n+\tgo/constant/check \\\n \tgo/doc/check \\\n \tgo/format/check \\\n+\tgo/internal/gcimporter/check \\\n+\tgo/internal/gccgoimporter/check \\\n \tgo/parser/check \\\n \tgo/printer/check \\\n \tgo/scanner/check \\\n \tgo/token/check \\\n+\tgo/types/check \\\n \thash/adler32/check \\\n \thash/crc32/check \\\n \thash/crc64/check \\\n@@ -2336,19 +2508,23 @@ TEST_PACKAGES = \\\n \timage/jpeg/check \\\n \timage/png/check \\\n \tindex/suffixarray/check \\\n+\tinternal/singleflight/check \\\n+\tinternal/trace/check \\\n \tio/ioutil/check \\\n \tlog/syslog/check \\\n \tmath/big/check \\\n \tmath/cmplx/check \\\n \tmath/rand/check \\\n \tmime/multipart/check \\\n+\tmime/quotedprintable/check \\\n \tnet/http/check \\\n \tnet/http/cgi/check \\\n \tnet/http/cookiejar/check \\\n \tnet/http/fcgi/check \\\n \tnet/http/httptest/check \\\n \tnet/http/httputil/check \\\n \tnet/http/internal/check \\\n+\tnet/internal/socktest/check \\\n \tnet/mail/check \\\n \tnet/rpc/check \\\n \tnet/smtp/check \\\n@@ -5357,6 +5533,15 @@ go/build/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: go/build/check\n \n+@go_include@ go/constant.lo.dep\n+go/constant.lo.dep: $(go_go_constant_files)\n+\t$(BUILDDEPS)\n+go/constant.lo: $(go_go_constant_files)\n+\t$(BUILDPACKAGE)\n+go/constant/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: go/constant/check\n+\n @go_include@ go/doc.lo.dep\n go/doc.lo.dep: $(go_go_doc_files)\n \t$(BUILDDEPS)\n@@ -5375,6 +5560,15 @@ go/format/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: go/format/check\n \n+@go_include@ go/importer.lo.dep\n+go/importer.lo.dep: $(go_go_importer_files)\n+\t$(BUILDDEPS)\n+go/importer.lo: $(go_go_importer_files)\n+\t$(BUILDPACKAGE)\n+go/importer/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: go/importer/check\n+\n @go_include@ go/parser.lo.dep\n go/parser.lo.dep: $(go_go_parser_files)\n \t$(BUILDDEPS)\n@@ -5411,6 +5605,33 @@ go/token/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: go/token/check\n \n+@go_include@ go/types.lo.dep\n+go/types.lo.dep: $(go_go_types_files)\n+\t$(BUILDDEPS)\n+go/types.lo: $(go_go_types_files)\n+\t$(BUILDPACKAGE)\n+go/types/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: go/types/check\n+\n+@go_include@ go/internal/gcimporter.lo.dep\n+go/internal/gcimporter.lo.dep: $(go_go_internal_gcimporter_files)\n+\t$(BUILDDEPS)\n+go/internal/gcimporter.lo: $(go_go_internal_gcimporter_files)\n+\t$(BUILDPACKAGE)\n+go/internal/gcimporter/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: go/internal/gcimporter/check\n+\n+@go_include@ go/internal/gccgoimporter.lo.dep\n+go/internal/gccgoimporter.lo.dep: $(go_go_internal_gccgoimporter_files)\n+\t$(BUILDDEPS)\n+go/internal/gccgoimporter.lo: $(go_go_internal_gccgoimporter_files)\n+\t$(BUILDPACKAGE)\n+go/internal/gccgoimporter/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: go/internal/gccgoimporter/check\n+\n @go_include@ hash/adler32.lo.dep\n hash/adler32.lo.dep: $(go_hash_adler32_files)\n \t$(BUILDDEPS)\n@@ -5483,6 +5704,15 @@ image/gif/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: image/gif/check\n \n+@go_include@ image/internal/imageutil.lo.dep\n+image/internal/imageutil.lo.dep: $(go_image_internal_imageutil_files)\n+\t$(BUILDDEPS)\n+image/internal/imageutil.lo: $(go_image_internal_imageutil_files)\n+\t$(BUILDPACKAGE)\n+image/internal/imageutil/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: image/internal/imageutil/check\n+\n @go_include@ image/jpeg.lo.dep\n image/jpeg.lo.dep: $(go_image_jpeg_files)\n \t$(BUILDDEPS)\n@@ -5510,6 +5740,51 @@ index/suffixarray/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: index/suffixarray/check\n \n+@go_include@ internal/format.lo.dep\n+internal/format.lo.dep: $(go_internal_format_files)\n+\t$(BUILDDEPS)\n+internal/format.lo: $(go_internal_format_files)\n+\t$(BUILDPACKAGE)\n+internal/format/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: internal/format/check\n+\n+@go_include@ internal/singleflight.lo.dep\n+internal/singleflight.lo.dep: $(go_internal_singleflight_files)\n+\t$(BUILDDEPS)\n+internal/singleflight.lo: $(go_internal_singleflight_files)\n+\t$(BUILDPACKAGE)\n+internal/singleflight/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: internal/singleflight/check\n+\n+@go_include@ internal/syscall/unix.lo.dep\n+internal/syscall/unix.lo.dep: $(go_internal_syscall_unix_files)\n+\t$(BUILDDEPS)\n+internal/syscall/unix.lo: $(go_internal_syscall_unix_files)\n+\t$(BUILDPACKAGE)\n+internal/syscall/unix/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: internal/syscall/unix/check\n+\n+@go_include@ internal/testenv.lo.dep\n+internal/testenv.lo.dep: $(go_internal_testenv_files)\n+\t$(BUILDDEPS)\n+internal/testenv.lo: $(go_internal_testenv_files)\n+\t$(BUILDPACKAGE)\n+internal/testenv/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: internal/testenv/check\n+\n+@go_include@ internal/trace.lo.dep\n+internal/trace.lo.dep: $(go_internal_trace_files)\n+\t$(BUILDDEPS)\n+internal/trace.lo: $(go_internal_trace_files)\n+\t$(BUILDPACKAGE)\n+internal/trace/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: internal/trace/check\n+\n @go_include@ io/ioutil.lo.dep\n io/ioutil.lo.dep: $(go_io_ioutil_files)\n \t$(BUILDDEPS)\n@@ -5567,6 +5842,15 @@ mime/multipart/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: mime/multipart/check\n \n+@go_include@ mime/quotedprintable.lo.dep\n+mime/quotedprintable.lo.dep: $(go_mime_quotedprintable_files)\n+\t$(BUILDDEPS)\n+mime/quotedprintable.lo: $(go_mime_quotedprintable_files)\n+\t$(BUILDPACKAGE)\n+mime/quotedprintable/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: mime/quotedprintable/check\n+\n @go_include@ net/http.lo.dep\n net/http.lo.dep: $(go_net_http_files)\n \t$(BUILDDEPS)\n@@ -5684,6 +5968,15 @@ net/http/pprof/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: net/http/pprof/check\n \n+@go_include@ net/internal/socktest.lo.dep\n+net/internal/socktest.lo.dep: $(go_net_internal_socktest_files)\n+\t$(BUILDDEPS)\n+net/internal/socktest.lo: $(go_net_internal_socktest_files)\n+\t$(BUILDPACKAGE)\n+net/internal/socktest/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: net/internal/socktest/check\n+\n @go_include@ net/rpc/jsonrpc.lo.dep\n net/rpc/jsonrpc.lo.dep: $(go_net_rpc_jsonrpc_files)\n \t$(BUILDDEPS)\n@@ -5875,15 +6168,6 @@ syscall/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: syscall/check\n \n-@go_include@ internal/syscall.lo.dep\n-internal/syscall.lo.dep: $(go_internal_syscall_files)\n-\t$(BUILDDEPS)\n-internal/syscall.lo: $(go_internal_syscall_files)\n-\t$(BUILDPACKAGE)\n-internal/syscall/check: $(CHECK_DEPS)\n-\t@$(CHECK)\n-.PHONY: internal/syscall/check\n-\n bufio.gox: bufio.lo\n \t$(BUILDGOX)\n bytes.gox: bytes.lo\n@@ -6058,10 +6342,14 @@ go/ast.gox: go/ast.lo\n \t$(BUILDGOX)\n go/build.gox: go/build.lo\n \t$(BUILDGOX)\n+go/constant.gox: go/constant.lo\n+\t$(BUILDGOX)\n go/doc.gox: go/doc.lo\n \t$(BUILDGOX)\n go/format.gox: go/format.lo\n \t$(BUILDGOX)\n+go/importer.gox: go/importer.lo\n+\t$(BUILDGOX)\n go/parser.gox: go/parser.lo\n \t$(BUILDGOX)\n go/printer.gox: go/printer.lo\n@@ -6070,6 +6358,13 @@ go/scanner.gox: go/scanner.lo\n \t$(BUILDGOX)\n go/token.gox: go/token.lo\n \t$(BUILDGOX)\n+go/types.gox: go/types.lo\n+\t$(BUILDGOX)\n+\n+go/internal/gcimporter.gox: go/internal/gcimporter.lo\n+\t$(BUILDGOX)\n+go/internal/gccgoimporter.gox: go/internal/gccgoimporter.lo\n+\t$(BUILDGOX)\n \n hash/adler32.gox: hash/adler32.lo\n \t$(BUILDGOX)\n@@ -6086,6 +6381,8 @@ image/draw.gox: image/draw.lo\n \t$(BUILDGOX)\n image/gif.gox: image/gif.lo\n \t$(BUILDGOX)\n+image/internal/imageutil.gox: image/internal/imageutil.lo\n+\t$(BUILDGOX)\n image/jpeg.gox: image/jpeg.lo\n \t$(BUILDGOX)\n image/png.gox: image/png.lo\n@@ -6097,6 +6394,17 @@ image/color/palette.gox: image/color/palette.lo\n index/suffixarray.gox: index/suffixarray.lo\n \t$(BUILDGOX)\n \n+internal/format.gox: internal/format.lo\n+\t$(BUILDGOX)\n+internal/singleflight.gox: internal/singleflight.lo\n+\t$(BUILDGOX)\n+internal/syscall/unix.gox: internal/syscall/unix.lo\n+\t$(BUILDGOX)\n+internal/testenv.gox: internal/testenv.lo\n+\t$(BUILDGOX)\n+internal/trace.gox: internal/trace.lo\n+\t$(BUILDGOX)\n+\n io/ioutil.gox: io/ioutil.lo\n \t$(BUILDGOX)\n \n@@ -6112,6 +6420,8 @@ math/rand.gox: math/rand.lo\n \n mime/multipart.gox: mime/multipart.lo\n \t$(BUILDGOX)\n+mime/quotedprintable.gox: mime/quotedprintable.lo\n+\t$(BUILDGOX)\n \n net/http.gox: net/http.lo\n \t$(BUILDGOX)\n@@ -6142,6 +6452,9 @@ net/http/pprof.gox: net/http/pprof.lo\n net/http/internal.gox: net/http/internal.lo\n \t$(BUILDGOX)\n \n+net/internal/socktest.gox: net/internal/socktest.lo\n+\t$(BUILDGOX)\n+\n net/rpc/jsonrpc.gox: net/rpc/jsonrpc.lo\n \t$(BUILDGOX)\n \n@@ -6171,9 +6484,6 @@ runtime/pprof.gox: runtime/pprof.lo\n sync/atomic.gox: sync/atomic.lo\n \t$(BUILDGOX)\n \n-internal/syscall.gox: internal/syscall.lo\n-\t$(BUILDGOX)\n-\n text/scanner.gox: text/scanner.lo\n \t$(BUILDGOX)\n text/tabwriter.gox: text/tabwriter.lo"}, {"sha": "661b4f922848d4a0171b0b1ab2e8b0fe2e91fbc5", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -1 +1 @@\n-go1.4.2\n\\ No newline at end of file\n+go1.5\n\\ No newline at end of file"}, {"sha": "c31df062f7ea54577bafe6eb25dfb06ef2a2a55f", "filename": "libgo/go/archive/tar/common.go", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Farchive%2Ftar%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Farchive%2Ftar%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fcommon.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -139,8 +139,8 @@ func (fi headerFileInfo) Mode() (mode os.FileMode) {\n \t}\n \n \tswitch fi.h.Typeflag {\n-\tcase TypeLink, TypeSymlink:\n-\t\t// hard link, symbolic link\n+\tcase TypeSymlink:\n+\t\t// symbolic link\n \t\tmode |= os.ModeSymlink\n \tcase TypeChar:\n \t\t// character device node\n@@ -249,6 +249,30 @@ func FileInfoHeader(fi os.FileInfo, link string) (*Header, error) {\n \tif fm&os.ModeSticky != 0 {\n \t\th.Mode |= c_ISVTX\n \t}\n+\t// If possible, populate additional fields from OS-specific\n+\t// FileInfo fields.\n+\tif sys, ok := fi.Sys().(*Header); ok {\n+\t\t// This FileInfo came from a Header (not the OS). Use the\n+\t\t// original Header to populate all remaining fields.\n+\t\th.Uid = sys.Uid\n+\t\th.Gid = sys.Gid\n+\t\th.Uname = sys.Uname\n+\t\th.Gname = sys.Gname\n+\t\th.AccessTime = sys.AccessTime\n+\t\th.ChangeTime = sys.ChangeTime\n+\t\tif sys.Xattrs != nil {\n+\t\t\th.Xattrs = make(map[string]string)\n+\t\t\tfor k, v := range sys.Xattrs {\n+\t\t\t\th.Xattrs[k] = v\n+\t\t\t}\n+\t\t}\n+\t\tif sys.Typeflag == TypeLink {\n+\t\t\t// hard link\n+\t\t\th.Typeflag = TypeLink\n+\t\t\th.Size = 0\n+\t\t\th.Linkname = sys.Linkname\n+\t\t}\n+\t}\n \tif sysStat != nil {\n \t\treturn h, sysStat(fi, h)\n \t}"}, {"sha": "67daca27a95b4aa9d4968c66bad117165d6e278b", "filename": "libgo/go/archive/tar/reader.go", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Farchive%2Ftar%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Farchive%2Ftar%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Freader.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -85,6 +85,8 @@ const (\n func NewReader(r io.Reader) *Reader { return &Reader{r: r} }\n \n // Next advances to the next entry in the tar archive.\n+//\n+// io.EOF is returned at the end of the input.\n func (tr *Reader) Next() (*Header, error) {\n \tvar hdr *Header\n \tif tr.err == nil {\n@@ -108,7 +110,13 @@ func (tr *Reader) Next() (*Header, error) {\n \t\t// We actually read the whole file,\n \t\t// but this skips alignment padding\n \t\ttr.skipUnread()\n+\t\tif tr.err != nil {\n+\t\t\treturn nil, tr.err\n+\t\t}\n \t\thdr = tr.readHeader()\n+\t\tif hdr == nil {\n+\t\t\treturn nil, tr.err\n+\t\t}\n \t\tmergePAX(hdr, headers)\n \n \t\t// Check for a PAX format sparse file\n@@ -331,7 +339,7 @@ func parsePAX(r io.Reader) (map[string]string, error) {\n \t\t}\n \t\t// Parse the first token as a decimal integer.\n \t\tn, err := strconv.ParseInt(string(buf[:sp]), 10, 0)\n-\t\tif err != nil {\n+\t\tif err != nil || n < 5 || int64(len(buf)) < n {\n \t\t\treturn nil, ErrHeader\n \t\t}\n \t\t// Extract everything between the decimal and the n -1 on the\n@@ -461,6 +469,10 @@ func (tr *Reader) readHeader() *Header {\n \thdr.Uid = int(tr.octal(s.next(8)))\n \thdr.Gid = int(tr.octal(s.next(8)))\n \thdr.Size = tr.octal(s.next(12))\n+\tif hdr.Size < 0 {\n+\t\ttr.err = ErrHeader\n+\t\treturn nil\n+\t}\n \thdr.ModTime = time.Unix(tr.octal(s.next(12)), 0)\n \ts.next(8) // chksum\n \thdr.Typeflag = s.next(1)[0]\n@@ -785,6 +797,9 @@ func (sfr *sparseFileReader) Read(b []byte) (n int, err error) {\n \t\t// Otherwise, we're at the end of the file\n \t\treturn 0, io.EOF\n \t}\n+\tif sfr.tot < sfr.sp[0].offset {\n+\t\treturn 0, io.ErrUnexpectedEOF\n+\t}\n \tif sfr.pos < sfr.sp[0].offset {\n \t\t// We're in a hole\n \t\tn = sfr.readHole(b, sfr.sp[0].offset)"}, {"sha": "da01f265911806985c60c2be78a5fa67301fe875", "filename": "libgo/go/archive/tar/reader_test.go", "status": "modified", "additions": 58, "deletions": 3, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -462,9 +462,14 @@ func TestParsePAXHeader(t *testing.T) {\n \t\t\tt.Error(\"Buffer wasn't consumed\")\n \t\t}\n \t}\n-\tbadHeader := bytes.NewReader([]byte(\"3 somelongkey=\"))\n-\tif _, err := parsePAX(badHeader); err != ErrHeader {\n-\t\tt.Fatal(\"Unexpected success when parsing bad header\")\n+\tbadHeaderTests := [][]byte{\n+\t\t[]byte(\"3 somelongkey=\\n\"),\n+\t\t[]byte(\"50 tooshort=\\n\"),\n+\t}\n+\tfor _, test := range badHeaderTests {\n+\t\tif _, err := parsePAX(bytes.NewReader(test)); err != ErrHeader {\n+\t\t\tt.Fatal(\"Unexpected success when parsing bad header\")\n+\t\t}\n \t}\n }\n \n@@ -741,3 +746,53 @@ func TestUninitializedRead(t *testing.T) {\n \t}\n \n }\n+\n+// Negative header size should not cause panic.\n+// Issues 10959 and 10960.\n+func TestNegativeHdrSize(t *testing.T) {\n+\tf, err := os.Open(\"testdata/neg-size.tar\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer f.Close()\n+\tr := NewReader(f)\n+\t_, err = r.Next()\n+\tif err != ErrHeader {\n+\t\tt.Error(\"want ErrHeader, got\", err)\n+\t}\n+\tio.Copy(ioutil.Discard, r)\n+}\n+\n+// This used to hang in (*sparseFileReader).readHole due to missing\n+// verification of sparse offsets against file size.\n+func TestIssue10968(t *testing.T) {\n+\tf, err := os.Open(\"testdata/issue10968.tar\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer f.Close()\n+\tr := NewReader(f)\n+\t_, err = r.Next()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\t_, err = io.Copy(ioutil.Discard, r)\n+\tif err != io.ErrUnexpectedEOF {\n+\t\tt.Fatalf(\"expected %q, got %q\", io.ErrUnexpectedEOF, err)\n+\t}\n+}\n+\n+// Do not panic if there are errors in header blocks after the pax header.\n+// Issue 11169\n+func TestIssue11169(t *testing.T) {\n+\tf, err := os.Open(\"testdata/issue11169.tar\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer f.Close()\n+\tr := NewReader(f)\n+\t_, err = r.Next()\n+\tif err == nil {\n+\t\tt.Fatal(\"Unexpected success\")\n+\t}\n+}"}, {"sha": "d63c072eb9aaa489c5ec76552db060fa50f2a3ef", "filename": "libgo/go/archive/tar/tar_test.go", "status": "modified", "additions": 52, "deletions": 11, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Farchive%2Ftar%2Ftar_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Farchive%2Ftar%2Ftar_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftar_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -147,17 +147,6 @@ func TestHeaderRoundTrip(t *testing.T) {\n \t\t\t},\n \t\t\tfm: 0644,\n \t\t},\n-\t\t// hard link.\n-\t\t{\n-\t\t\th: &Header{\n-\t\t\t\tName:     \"hard.txt\",\n-\t\t\t\tMode:     0644 | c_ISLNK,\n-\t\t\t\tSize:     0,\n-\t\t\t\tModTime:  time.Unix(1360600916, 0),\n-\t\t\t\tTypeflag: TypeLink,\n-\t\t\t},\n-\t\t\tfm: 0644 | os.ModeSymlink,\n-\t\t},\n \t\t// symbolic link.\n \t\t{\n \t\t\th: &Header{\n@@ -246,6 +235,33 @@ func TestHeaderRoundTrip(t *testing.T) {\n \t\t\t},\n \t\t\tfm: 0600 | os.ModeSticky,\n \t\t},\n+\t\t// hard link.\n+\t\t{\n+\t\t\th: &Header{\n+\t\t\t\tName:     \"hard.txt\",\n+\t\t\t\tMode:     0644 | c_ISREG,\n+\t\t\t\tSize:     0,\n+\t\t\t\tLinkname: \"file.txt\",\n+\t\t\t\tModTime:  time.Unix(1360600916, 0),\n+\t\t\t\tTypeflag: TypeLink,\n+\t\t\t},\n+\t\t\tfm: 0644,\n+\t\t},\n+\t\t// More information.\n+\t\t{\n+\t\t\th: &Header{\n+\t\t\t\tName:     \"info.txt\",\n+\t\t\t\tMode:     0600 | c_ISREG,\n+\t\t\t\tSize:     0,\n+\t\t\t\tUid:      1000,\n+\t\t\t\tGid:      1000,\n+\t\t\t\tModTime:  time.Unix(1360602540, 0),\n+\t\t\t\tUname:    \"slartibartfast\",\n+\t\t\t\tGname:    \"users\",\n+\t\t\t\tTypeflag: TypeReg,\n+\t\t\t},\n+\t\t\tfm: 0600,\n+\t\t},\n \t}\n \n \tfor i, g := range golden {\n@@ -268,12 +284,37 @@ func TestHeaderRoundTrip(t *testing.T) {\n \t\tif got, want := h2.Size, g.h.Size; got != want {\n \t\t\tt.Errorf(\"i=%d: Size: got %v, want %v\", i, got, want)\n \t\t}\n+\t\tif got, want := h2.Uid, g.h.Uid; got != want {\n+\t\t\tt.Errorf(\"i=%d: Uid: got %d, want %d\", i, got, want)\n+\t\t}\n+\t\tif got, want := h2.Gid, g.h.Gid; got != want {\n+\t\t\tt.Errorf(\"i=%d: Gid: got %d, want %d\", i, got, want)\n+\t\t}\n+\t\tif got, want := h2.Uname, g.h.Uname; got != want {\n+\t\t\tt.Errorf(\"i=%d: Uname: got %q, want %q\", i, got, want)\n+\t\t}\n+\t\tif got, want := h2.Gname, g.h.Gname; got != want {\n+\t\t\tt.Errorf(\"i=%d: Gname: got %q, want %q\", i, got, want)\n+\t\t}\n+\t\tif got, want := h2.Linkname, g.h.Linkname; got != want {\n+\t\t\tt.Errorf(\"i=%d: Linkname: got %v, want %v\", i, got, want)\n+\t\t}\n+\t\tif got, want := h2.Typeflag, g.h.Typeflag; got != want {\n+\t\t\tt.Logf(\"%#v %#v\", g.h, fi.Sys())\n+\t\t\tt.Errorf(\"i=%d: Typeflag: got %q, want %q\", i, got, want)\n+\t\t}\n \t\tif got, want := h2.Mode, g.h.Mode; got != want {\n \t\t\tt.Errorf(\"i=%d: Mode: got %o, want %o\", i, got, want)\n \t\t}\n \t\tif got, want := fi.Mode(), g.fm; got != want {\n \t\t\tt.Errorf(\"i=%d: fi.Mode: got %o, want %o\", i, got, want)\n \t\t}\n+\t\tif got, want := h2.AccessTime, g.h.AccessTime; got != want {\n+\t\t\tt.Errorf(\"i=%d: AccessTime: got %v, want %v\", i, got, want)\n+\t\t}\n+\t\tif got, want := h2.ChangeTime, g.h.ChangeTime; got != want {\n+\t\t\tt.Errorf(\"i=%d: ChangeTime: got %v, want %v\", i, got, want)\n+\t\t}\n \t\tif got, want := h2.ModTime, g.h.ModTime; got != want {\n \t\t\tt.Errorf(\"i=%d: ModTime: got %v, want %v\", i, got, want)\n \t\t}"}, {"sha": "9cd1a26572e44150ded8a628fefb28fa089645d1", "filename": "libgo/go/archive/tar/testdata/hardlink.tar", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fhardlink.tar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fhardlink.tar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fhardlink.tar?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "1cc837bcff14cd822a26e43034955c82e852ab29", "filename": "libgo/go/archive/tar/testdata/issue10968.tar", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fissue10968.tar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fissue10968.tar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fissue10968.tar?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "4d71fa15260609ecee0c8c751cfebf49be8763ac", "filename": "libgo/go/archive/tar/testdata/issue11169.tar", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fissue11169.tar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fissue11169.tar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fissue11169.tar?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "5deea3d05c4da5a4ddda34ef7ad781088464e71b", "filename": "libgo/go/archive/tar/testdata/neg-size.tar", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fneg-size.tar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fneg-size.tar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fneg-size.tar?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "9dbc01a2ffbc4b223e0a28cfff3a40dc4817ca19", "filename": "libgo/go/archive/tar/writer.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -355,7 +355,7 @@ func paxHeader(msg string) string {\n // hdr.Size bytes are written after WriteHeader.\n func (tw *Writer) Write(b []byte) (n int, err error) {\n \tif tw.closed {\n-\t\terr = ErrWriteTooLong\n+\t\terr = ErrWriteAfterClose\n \t\treturn\n \t}\n \toverwrite := false"}, {"sha": "fe46a67ce38b1ce4c5943553b146ffb3b2e5e395", "filename": "libgo/go/archive/tar/writer_test.go", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -147,6 +147,44 @@ var writerTests = []*writerTest{\n \t\t\t},\n \t\t},\n \t},\n+\t// This file was produced using gnu tar 1.26\n+\t// echo \"Slartibartfast\" > file.txt\n+\t// ln file.txt hard.txt\n+\t// tar -b 1 --format=ustar -c -f hardlink.tar file.txt hard.txt\n+\t{\n+\t\tfile: \"testdata/hardlink.tar\",\n+\t\tentries: []*writerTestEntry{\n+\t\t\t{\n+\t\t\t\theader: &Header{\n+\t\t\t\t\tName:     \"file.txt\",\n+\t\t\t\t\tMode:     0644,\n+\t\t\t\t\tUid:      1000,\n+\t\t\t\t\tGid:      100,\n+\t\t\t\t\tSize:     15,\n+\t\t\t\t\tModTime:  time.Unix(1425484303, 0),\n+\t\t\t\t\tTypeflag: '0',\n+\t\t\t\t\tUname:    \"vbatts\",\n+\t\t\t\t\tGname:    \"users\",\n+\t\t\t\t},\n+\t\t\t\tcontents: \"Slartibartfast\\n\",\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\theader: &Header{\n+\t\t\t\t\tName:     \"hard.txt\",\n+\t\t\t\t\tMode:     0644,\n+\t\t\t\t\tUid:      1000,\n+\t\t\t\t\tGid:      100,\n+\t\t\t\t\tSize:     0,\n+\t\t\t\t\tModTime:  time.Unix(1425484303, 0),\n+\t\t\t\t\tTypeflag: '1',\n+\t\t\t\t\tLinkname: \"file.txt\",\n+\t\t\t\t\tUname:    \"vbatts\",\n+\t\t\t\t\tGname:    \"users\",\n+\t\t\t\t},\n+\t\t\t\t// no contents\n+\t\t\t},\n+\t\t},\n+\t},\n }\n \n // Render byte array in a two-character hexadecimal string, spaced for easy visual inspection.\n@@ -489,3 +527,20 @@ func TestValidTypeflagWithPAXHeader(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestWriteAfterClose(t *testing.T) {\n+\tvar buffer bytes.Buffer\n+\ttw := NewWriter(&buffer)\n+\n+\thdr := &Header{\n+\t\tName: \"small.txt\",\n+\t\tSize: 5,\n+\t}\n+\tif err := tw.WriteHeader(hdr); err != nil {\n+\t\tt.Fatalf(\"Failed to write header: %s\", err)\n+\t}\n+\ttw.Close()\n+\tif _, err := tw.Write([]byte(\"Kilts\")); err != ErrWriteAfterClose {\n+\t\tt.Fatalf(\"Write: got %v; want ErrWriteAfterClose\", err)\n+\t}\n+}"}, {"sha": "519748bac4006325228819074c7c984b9865063b", "filename": "libgo/go/archive/zip/reader.go", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -8,6 +8,7 @@ import (\n \t\"bufio\"\n \t\"encoding/binary\"\n \t\"errors\"\n+\t\"fmt\"\n \t\"hash\"\n \t\"hash/crc32\"\n \t\"io\"\n@@ -77,6 +78,9 @@ func (z *Reader) init(r io.ReaderAt, size int64) error {\n \tif err != nil {\n \t\treturn err\n \t}\n+\tif end.directoryRecords > uint64(size)/fileHeaderLen {\n+\t\treturn fmt.Errorf(\"archive/zip: TOC declares impossible %d files in %d byte zip\", end.directoryRecords, size)\n+\t}\n \tz.r = r\n \tz.File = make([]*File, 0, end.directoryRecords)\n \tz.Comment = end.comment\n@@ -146,16 +150,22 @@ func (f *File) Open() (rc io.ReadCloser, err error) {\n \tif f.hasDataDescriptor() {\n \t\tdesr = io.NewSectionReader(f.zipr, f.headerOffset+bodyOffset+size, dataDescriptorLen)\n \t}\n-\trc = &checksumReader{rc, crc32.NewIEEE(), f, desr, nil}\n+\trc = &checksumReader{\n+\t\trc:   rc,\n+\t\thash: crc32.NewIEEE(),\n+\t\tf:    f,\n+\t\tdesr: desr,\n+\t}\n \treturn\n }\n \n type checksumReader struct {\n-\trc   io.ReadCloser\n-\thash hash.Hash32\n-\tf    *File\n-\tdesr io.Reader // if non-nil, where to read the data descriptor\n-\terr  error     // sticky error\n+\trc    io.ReadCloser\n+\thash  hash.Hash32\n+\tnread uint64 // number of bytes read so far\n+\tf     *File\n+\tdesr  io.Reader // if non-nil, where to read the data descriptor\n+\terr   error     // sticky error\n }\n \n func (r *checksumReader) Read(b []byte) (n int, err error) {\n@@ -164,13 +174,21 @@ func (r *checksumReader) Read(b []byte) (n int, err error) {\n \t}\n \tn, err = r.rc.Read(b)\n \tr.hash.Write(b[:n])\n+\tr.nread += uint64(n)\n \tif err == nil {\n \t\treturn\n \t}\n \tif err == io.EOF {\n+\t\tif r.nread != r.f.UncompressedSize64 {\n+\t\t\treturn 0, io.ErrUnexpectedEOF\n+\t\t}\n \t\tif r.desr != nil {\n \t\t\tif err1 := readDataDescriptor(r.desr, r.f); err1 != nil {\n-\t\t\t\terr = err1\n+\t\t\t\tif err1 == io.EOF {\n+\t\t\t\t\terr = io.ErrUnexpectedEOF\n+\t\t\t\t} else {\n+\t\t\t\t\terr = err1\n+\t\t\t\t}\n \t\t\t} else if r.hash.Sum32() != r.f.CRC32 {\n \t\t\t\terr = ErrChecksum\n \t\t\t}"}, {"sha": "547dd39048e21749faa6bebb159734bc4caf1599", "filename": "libgo/go/archive/zip/reader_test.go", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -531,3 +531,77 @@ func TestIssue8186(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+// Verify we return ErrUnexpectedEOF when length is short.\n+func TestIssue10957(t *testing.T) {\n+\tdata := []byte(\"PK\\x03\\x040000000PK\\x01\\x0200000\" +\n+\t\t\"0000000000000000000\\x00\" +\n+\t\t\"\\x00\\x00\\x00\\x00\\x00000000000000PK\\x01\" +\n+\t\t\"\\x020000000000000000000\" +\n+\t\t\"00000\\v\\x00\\x00\\x00\\x00\\x00000000000\" +\n+\t\t\"00000000000000PK\\x01\\x0200\" +\n+\t\t\"00000000000000000000\" +\n+\t\t\"00\\v\\x00\\x00\\x00\\x00\\x00000000000000\" +\n+\t\t\"00000000000PK\\x01\\x020000<\" +\n+\t\t\"0\\x00\\x0000000000000000\\v\\x00\\v\" +\n+\t\t\"\\x00\\x00\\x00\\x00\\x0000000000\\x00\\x00\\x00\\x00000\" +\n+\t\t\"00000000PK\\x01\\x0200000000\" +\n+\t\t\"0000000000000000\\v\\x00\\x00\\x00\" +\n+\t\t\"\\x00\\x0000PK\\x05\\x06000000\\x05\\x000000\" +\n+\t\t\"\\v\\x00\\x00\\x00\\x00\\x00\")\n+\tz, err := NewReader(bytes.NewReader(data), int64(len(data)))\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tfor i, f := range z.File {\n+\t\tr, err := f.Open()\n+\t\tif err != nil {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif f.UncompressedSize64 < 1e6 {\n+\t\t\tn, err := io.Copy(ioutil.Discard, r)\n+\t\t\tif i == 3 && err != io.ErrUnexpectedEOF {\n+\t\t\t\tt.Errorf(\"File[3] error = %v; want io.ErrUnexpectedEOF\", err)\n+\t\t\t}\n+\t\t\tif err == nil && uint64(n) != f.UncompressedSize64 {\n+\t\t\t\tt.Errorf(\"file %d: bad size: copied=%d; want=%d\", i, n, f.UncompressedSize64)\n+\t\t\t}\n+\t\t}\n+\t\tr.Close()\n+\t}\n+}\n+\n+// Verify the number of files is sane.\n+func TestIssue10956(t *testing.T) {\n+\tdata := []byte(\"PK\\x06\\x06PK\\x06\\a0000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" +\n+\t\t\"0000PK\\x05\\x06000000000000\" +\n+\t\t\"0000\\v\\x00000\\x00\\x00\\x00\\x00\\x00\\x00\\x000\")\n+\t_, err := NewReader(bytes.NewReader(data), int64(len(data)))\n+\tconst want = \"TOC declares impossible 3472328296227680304 files in 57 byte\"\n+\tif err == nil && !strings.Contains(err.Error(), want) {\n+\t\tt.Errorf(\"error = %v; want %q\", err, want)\n+\t}\n+}\n+\n+// Verify we return ErrUnexpectedEOF when reading truncated data descriptor.\n+func TestIssue11146(t *testing.T) {\n+\tdata := []byte(\"PK\\x03\\x040000000000000000\" +\n+\t\t\"000000\\x01\\x00\\x00\\x000\\x01\\x00\\x00\\xff\\xff0000\" +\n+\t\t\"0000000000000000PK\\x01\\x02\" +\n+\t\t\"0000\\b0\\b\\x00000000000000\" +\n+\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x000000PK\\x05\\x06\\x00\\x00\" +\n+\t\t\"\\x00\\x0000\\x01\\x0000008\\x00\\x00\\x00\\x00\\x00\")\n+\tz, err := NewReader(bytes.NewReader(data), int64(len(data)))\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tr, err := z.File[0].Open()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\t_, err = ioutil.ReadAll(r)\n+\tif err != io.ErrUnexpectedEOF {\n+\t\tt.Errorf(\"File[0] error = %v; want io.ErrUnexpectedEOF\", err)\n+\t}\n+\tr.Close()\n+}"}, {"sha": "137d0495fd993439b32cc151a67be54017cb6270", "filename": "libgo/go/archive/zip/struct.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -81,8 +81,8 @@ type FileHeader struct {\n \tModifiedTime       uint16 // MS-DOS time\n \tModifiedDate       uint16 // MS-DOS date\n \tCRC32              uint32\n-\tCompressedSize     uint32 // deprecated; use CompressedSize64\n-\tUncompressedSize   uint32 // deprecated; use UncompressedSize64\n+\tCompressedSize     uint32 // Deprecated: Use CompressedSize64 instead.\n+\tUncompressedSize   uint32 // Deprecated: Use UncompressedSize64 instead.\n \tCompressedSize64   uint64\n \tUncompressedSize64 uint64\n \tExtra              []byte\n@@ -233,7 +233,7 @@ func (h *FileHeader) SetMode(mode os.FileMode) {\n \t}\n }\n \n-// isZip64 returns true if the file size exceeds the 32 bit limit\n+// isZip64 reports whether the file size exceeds the 32 bit limit\n func (fh *FileHeader) isZip64() bool {\n \treturn fh.CompressedSize64 > uint32max || fh.UncompressedSize64 > uint32max\n }"}, {"sha": "3be2b5fdb2f29417c0e9b384407fc56cad6bdc3e", "filename": "libgo/go/archive/zip/writer.go", "status": "modified", "additions": 27, "deletions": 10, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -34,6 +34,17 @@ func NewWriter(w io.Writer) *Writer {\n \treturn &Writer{cw: &countWriter{w: bufio.NewWriter(w)}}\n }\n \n+// SetOffset sets the offset of the beginning of the zip data within the\n+// underlying writer. It should be used when the zip data is appended to an\n+// existing file, such as a binary executable.\n+// It must be called before any data is written.\n+func (w *Writer) SetOffset(n int64) {\n+\tif w.cw.count != 0 {\n+\t\tpanic(\"zip: SetOffset called after data was written\")\n+\t}\n+\tw.cw.count = n\n+}\n+\n // Flush flushes any buffered data to the underlying writer.\n // Calling Flush is not normally necessary; calling Close is sufficient.\n func (w *Writer) Flush() error {\n@@ -122,15 +133,15 @@ func (w *Writer) Close() error {\n \n \t\t// zip64 end of central directory record\n \t\tb.uint32(directory64EndSignature)\n-\t\tb.uint64(directory64EndLen)\n-\t\tb.uint16(zipVersion45) // version made by\n-\t\tb.uint16(zipVersion45) // version needed to extract\n-\t\tb.uint32(0)            // number of this disk\n-\t\tb.uint32(0)            // number of the disk with the start of the central directory\n-\t\tb.uint64(records)      // total number of entries in the central directory on this disk\n-\t\tb.uint64(records)      // total number of entries in the central directory\n-\t\tb.uint64(size)         // size of the central directory\n-\t\tb.uint64(offset)       // offset of start of central directory with respect to the starting disk number\n+\t\tb.uint64(directory64EndLen - 12) // length minus signature (uint32) and length fields (uint64)\n+\t\tb.uint16(zipVersion45)           // version made by\n+\t\tb.uint16(zipVersion45)           // version needed to extract\n+\t\tb.uint32(0)                      // number of this disk\n+\t\tb.uint32(0)                      // number of the disk with the start of the central directory\n+\t\tb.uint64(records)                // total number of entries in the central directory on this disk\n+\t\tb.uint64(records)                // total number of entries in the central directory\n+\t\tb.uint64(size)                   // size of the central directory\n+\t\tb.uint64(offset)                 // offset of start of central directory with respect to the starting disk number\n \n \t\t// zip64 end of central directory locator\n \t\tb.uint32(directory64LocSignature)\n@@ -184,14 +195,20 @@ func (w *Writer) Create(name string) (io.Writer, error) {\n // CreateHeader adds a file to the zip file using the provided FileHeader\n // for the file metadata.\n // It returns a Writer to which the file contents should be written.\n+//\n // The file's contents must be written to the io.Writer before the next\n-// call to Create, CreateHeader, or Close.\n+// call to Create, CreateHeader, or Close. The provided FileHeader fh\n+// must not be modified after a call to CreateHeader.\n func (w *Writer) CreateHeader(fh *FileHeader) (io.Writer, error) {\n \tif w.last != nil && !w.last.closed {\n \t\tif err := w.last.close(); err != nil {\n \t\t\treturn nil, err\n \t\t}\n \t}\n+\tif len(w.dir) > 0 && w.dir[len(w.dir)-1].FileHeader == fh {\n+\t\t// See https://golang.org/issue/11144 confusion.\n+\t\treturn nil, errors.New(\"archive/zip: invalid duplicate FileHeader\")\n+\t}\n \n \tfh.Flags |= 0x8 // we will write a data descriptor\n "}, {"sha": "01b63f2358d41c258baf08b1f5206b11f41dfcc9", "filename": "libgo/go/archive/zip/writer_test.go", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -87,6 +87,41 @@ func TestWriter(t *testing.T) {\n \t}\n }\n \n+func TestWriterOffset(t *testing.T) {\n+\tlargeData := make([]byte, 1<<17)\n+\tfor i := range largeData {\n+\t\tlargeData[i] = byte(rand.Int())\n+\t}\n+\twriteTests[1].Data = largeData\n+\tdefer func() {\n+\t\twriteTests[1].Data = nil\n+\t}()\n+\n+\t// write a zip file\n+\tbuf := new(bytes.Buffer)\n+\texistingData := []byte{1, 2, 3, 1, 2, 3, 1, 2, 3}\n+\tn, _ := buf.Write(existingData)\n+\tw := NewWriter(buf)\n+\tw.SetOffset(int64(n))\n+\n+\tfor _, wt := range writeTests {\n+\t\ttestCreate(t, w, &wt)\n+\t}\n+\n+\tif err := w.Close(); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\t// read it back\n+\tr, err := NewReader(bytes.NewReader(buf.Bytes()), int64(buf.Len()))\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tfor i, wt := range writeTests {\n+\t\ttestReadFile(t, r.File[i], &wt)\n+\t}\n+}\n+\n func TestWriterFlush(t *testing.T) {\n \tvar buf bytes.Buffer\n \tw := NewWriter(struct{ io.Writer }{&buf})"}, {"sha": "f00ff47d37ecb29d0fa89cb303a6a17f01cdb812", "filename": "libgo/go/archive/zip/zip_test.go", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -229,10 +229,11 @@ func TestZip64(t *testing.T) {\n \t\tt.Skip(\"slow test; skipping\")\n \t}\n \tconst size = 1 << 32 // before the \"END\\n\" part\n-\ttestZip64(t, size)\n+\tbuf := testZip64(t, size)\n+\ttestZip64DirectoryRecordLength(buf, t)\n }\n \n-func testZip64(t testing.TB, size int64) {\n+func testZip64(t testing.TB, size int64) *rleBuffer {\n \tconst chunkSize = 1024\n \tchunks := int(size / chunkSize)\n \t// write 2^32 bytes plus \"END\\n\" to a zip file\n@@ -302,6 +303,37 @@ func testZip64(t testing.TB, size int64) {\n \tif got, want := f0.UncompressedSize64, uint64(size)+uint64(len(end)); got != want {\n \t\tt.Errorf(\"UncompressedSize64 %d, want %d\", got, want)\n \t}\n+\n+\treturn buf\n+}\n+\n+// Issue 9857\n+func testZip64DirectoryRecordLength(buf *rleBuffer, t *testing.T) {\n+\td := make([]byte, 1024)\n+\tif _, err := buf.ReadAt(d, buf.Size()-int64(len(d))); err != nil {\n+\t\tt.Fatal(\"read:\", err)\n+\t}\n+\n+\tsigOff := findSignatureInBlock(d)\n+\tdirOff, err := findDirectory64End(buf, buf.Size()-int64(len(d))+int64(sigOff))\n+\tif err != nil {\n+\t\tt.Fatal(\"findDirectory64End:\", err)\n+\t}\n+\n+\td = make([]byte, directory64EndLen)\n+\tif _, err := buf.ReadAt(d, dirOff); err != nil {\n+\t\tt.Fatal(\"read:\", err)\n+\t}\n+\n+\tb := readBuf(d)\n+\tif sig := b.uint32(); sig != directory64EndSignature {\n+\t\tt.Fatalf(\"Expected directory64EndSignature (%d), got %d\", directory64EndSignature, sig)\n+\t}\n+\n+\tsize := b.uint64()\n+\tif size != directory64EndLen-12 {\n+\t\tt.Fatalf(\"Expected length of %d, got %d\", directory64EndLen-12, size)\n+\t}\n }\n \n func testInvalidHeader(h *FileHeader, t *testing.T) {"}, {"sha": "3bbb933df3569886ade4c370144d08ae63101c86", "filename": "libgo/go/bufio/bufio.go", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fbufio%2Fbufio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fbufio%2Fbufio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -144,6 +144,39 @@ func (b *Reader) Peek(n int) ([]byte, error) {\n \treturn b.buf[b.r : b.r+n], err\n }\n \n+// Discard skips the next n bytes, returning the number of bytes discarded.\n+//\n+// If Discard skips fewer than n bytes, it also returns an error.\n+// If 0 <= n <= b.Buffered(), Discard is guaranteed to succeed without\n+// reading from the underlying io.Reader.\n+func (b *Reader) Discard(n int) (discarded int, err error) {\n+\tif n < 0 {\n+\t\treturn 0, ErrNegativeCount\n+\t}\n+\tif n == 0 {\n+\t\treturn\n+\t}\n+\tremain := n\n+\tfor {\n+\t\tskip := b.Buffered()\n+\t\tif skip == 0 {\n+\t\t\tb.fill()\n+\t\t\tskip = b.Buffered()\n+\t\t}\n+\t\tif skip > remain {\n+\t\t\tskip = remain\n+\t\t}\n+\t\tb.r += skip\n+\t\tremain -= skip\n+\t\tif remain == 0 {\n+\t\t\treturn n, nil\n+\t\t}\n+\t\tif b.err != nil {\n+\t\t\treturn n - remain, b.readErr()\n+\t\t}\n+\t}\n+}\n+\n // Read reads data into p.\n // It returns the number of bytes read into p.\n // It calls Read at most once on the underlying Reader,\n@@ -367,7 +400,6 @@ func (b *Reader) ReadBytes(delim byte) (line []byte, err error) {\n \t// accumulating full buffers.\n \tvar frag []byte\n \tvar full [][]byte\n-\terr = nil\n \n \tfor {\n \t\tvar e error"}, {"sha": "666c44e15a938be90bb2f9095fea82a18e9401e7", "filename": "libgo/go/bufio/bufio_test.go", "status": "modified", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -1268,6 +1268,135 @@ func TestWriterReset(t *testing.T) {\n \t}\n }\n \n+func TestReaderDiscard(t *testing.T) {\n+\ttests := []struct {\n+\t\tname     string\n+\t\tr        io.Reader\n+\t\tbufSize  int // 0 means 16\n+\t\tpeekSize int\n+\n+\t\tn int // input to Discard\n+\n+\t\twant    int   // from Discard\n+\t\twantErr error // from Discard\n+\n+\t\twantBuffered int\n+\t}{\n+\t\t{\n+\t\t\tname:         \"normal case\",\n+\t\t\tr:            strings.NewReader(\"abcdefghijklmnopqrstuvwxyz\"),\n+\t\t\tpeekSize:     16,\n+\t\t\tn:            6,\n+\t\t\twant:         6,\n+\t\t\twantBuffered: 10,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"discard causing read\",\n+\t\t\tr:            strings.NewReader(\"abcdefghijklmnopqrstuvwxyz\"),\n+\t\t\tn:            6,\n+\t\t\twant:         6,\n+\t\t\twantBuffered: 10,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"discard all without peek\",\n+\t\t\tr:            strings.NewReader(\"abcdefghijklmnopqrstuvwxyz\"),\n+\t\t\tn:            26,\n+\t\t\twant:         26,\n+\t\t\twantBuffered: 0,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"discard more than end\",\n+\t\t\tr:            strings.NewReader(\"abcdefghijklmnopqrstuvwxyz\"),\n+\t\t\tn:            27,\n+\t\t\twant:         26,\n+\t\t\twantErr:      io.EOF,\n+\t\t\twantBuffered: 0,\n+\t\t},\n+\t\t// Any error from filling shouldn't show up until we\n+\t\t// get past the valid bytes. Here we return we return 5 valid bytes at the same time\n+\t\t// as an error, but test that we don't see the error from Discard.\n+\t\t{\n+\t\t\tname: \"fill error, discard less\",\n+\t\t\tr: newScriptedReader(func(p []byte) (n int, err error) {\n+\t\t\t\tif len(p) < 5 {\n+\t\t\t\t\tpanic(\"unexpected small read\")\n+\t\t\t\t}\n+\t\t\t\treturn 5, errors.New(\"5-then-error\")\n+\t\t\t}),\n+\t\t\tn:            4,\n+\t\t\twant:         4,\n+\t\t\twantErr:      nil,\n+\t\t\twantBuffered: 1,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"fill error, discard equal\",\n+\t\t\tr: newScriptedReader(func(p []byte) (n int, err error) {\n+\t\t\t\tif len(p) < 5 {\n+\t\t\t\t\tpanic(\"unexpected small read\")\n+\t\t\t\t}\n+\t\t\t\treturn 5, errors.New(\"5-then-error\")\n+\t\t\t}),\n+\t\t\tn:            5,\n+\t\t\twant:         5,\n+\t\t\twantErr:      nil,\n+\t\t\twantBuffered: 0,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"fill error, discard more\",\n+\t\t\tr: newScriptedReader(func(p []byte) (n int, err error) {\n+\t\t\t\tif len(p) < 5 {\n+\t\t\t\t\tpanic(\"unexpected small read\")\n+\t\t\t\t}\n+\t\t\t\treturn 5, errors.New(\"5-then-error\")\n+\t\t\t}),\n+\t\t\tn:            6,\n+\t\t\twant:         5,\n+\t\t\twantErr:      errors.New(\"5-then-error\"),\n+\t\t\twantBuffered: 0,\n+\t\t},\n+\t\t// Discard of 0 shouldn't cause a read:\n+\t\t{\n+\t\t\tname:         \"discard zero\",\n+\t\t\tr:            newScriptedReader(), // will panic on Read\n+\t\t\tn:            0,\n+\t\t\twant:         0,\n+\t\t\twantErr:      nil,\n+\t\t\twantBuffered: 0,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"discard negative\",\n+\t\t\tr:            newScriptedReader(), // will panic on Read\n+\t\t\tn:            -1,\n+\t\t\twant:         0,\n+\t\t\twantErr:      ErrNegativeCount,\n+\t\t\twantBuffered: 0,\n+\t\t},\n+\t}\n+\tfor _, tt := range tests {\n+\t\tbr := NewReaderSize(tt.r, tt.bufSize)\n+\t\tif tt.peekSize > 0 {\n+\t\t\tpeekBuf, err := br.Peek(tt.peekSize)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Errorf(\"%s: Peek(%d): %v\", tt.name, tt.peekSize, err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif len(peekBuf) != tt.peekSize {\n+\t\t\t\tt.Errorf(\"%s: len(Peek(%d)) = %v; want %v\", tt.name, tt.peekSize, len(peekBuf), tt.peekSize)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t}\n+\t\tdiscarded, err := br.Discard(tt.n)\n+\t\tif ge, we := fmt.Sprint(err), fmt.Sprint(tt.wantErr); discarded != tt.want || ge != we {\n+\t\t\tt.Errorf(\"%s: Discard(%d) = (%v, %v); want (%v, %v)\", tt.name, tt.n, discarded, ge, tt.want, we)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif bn := br.Buffered(); bn != tt.wantBuffered {\n+\t\t\tt.Errorf(\"%s: after Discard, Buffered = %d; want %d\", tt.name, bn, tt.wantBuffered)\n+\t\t}\n+\t}\n+\n+}\n+\n // An onlyReader only implements io.Reader, no matter what other methods the underlying implementation may have.\n type onlyReader struct {\n \tio.Reader\n@@ -1278,6 +1407,23 @@ type onlyWriter struct {\n \tio.Writer\n }\n \n+// A scriptedReader is an io.Reader that executes its steps sequentially.\n+type scriptedReader []func(p []byte) (n int, err error)\n+\n+func (sr *scriptedReader) Read(p []byte) (n int, err error) {\n+\tif len(*sr) == 0 {\n+\t\tpanic(\"too many Read calls on scripted Reader. No steps remain.\")\n+\t}\n+\tstep := (*sr)[0]\n+\t*sr = (*sr)[1:]\n+\treturn step(p)\n+}\n+\n+func newScriptedReader(steps ...func(p []byte) (n int, err error)) io.Reader {\n+\tsr := scriptedReader(steps)\n+\treturn &sr\n+}\n+\n func BenchmarkReaderCopyOptimal(b *testing.B) {\n \t// Optimal case is where the underlying reader implements io.WriterTo\n \tsrcBuf := bytes.NewBuffer(make([]byte, 8192))"}, {"sha": "7a349fa8fab7e5d0a7dc37c12af4cb8279b2a612", "filename": "libgo/go/bufio/scan.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fbufio%2Fscan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fbufio%2Fscan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fscan.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -109,7 +109,7 @@ func (s *Scanner) Text() string {\n // After Scan returns false, the Err method will return any error that\n // occurred during scanning, except that if it was io.EOF, Err\n // will return nil.\n-// Split panics if the split function returns 100 empty tokens without\n+// Scan panics if the split function returns 100 empty tokens without\n // advancing the input. This is a common error mode for scanners.\n func (s *Scanner) Scan() bool {\n \t// Loop until we have a token."}, {"sha": "d63ad22c32d46d7fbf68702c7d08113a6830a328", "filename": "libgo/go/builtin/builtin.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fbuiltin%2Fbuiltin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fbuiltin%2Fbuiltin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbuiltin%2Fbuiltin.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -236,14 +236,14 @@ func panic(v interface{})\n // panicking.\n func recover() interface{}\n \n-// The print built-in function formats its arguments in an implementation-\n-// specific way and writes the result to standard error.\n+// The print built-in function formats its arguments in an\n+// implementation-specific way and writes the result to standard error.\n // Print is useful for bootstrapping and debugging; it is not guaranteed\n // to stay in the language.\n func print(args ...Type)\n \n-// The println built-in function formats its arguments in an implementation-\n-// specific way and writes the result to standard error.\n+// The println built-in function formats its arguments in an\n+// implementation-specific way and writes the result to standard error.\n // Spaces are always added between arguments and a newline is appended.\n // Println is useful for bootstrapping and debugging; it is not guaranteed\n // to stay in the language."}, {"sha": "4db93867d9aa890faed03430b8d9116714e4c9ea", "filename": "libgo/go/bytes/buffer.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fbytes%2Fbuffer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fbytes%2Fbuffer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -56,6 +56,10 @@ func (b *Buffer) String() string {\n // b.Len() == len(b.Bytes()).\n func (b *Buffer) Len() int { return len(b.buf) - b.off }\n \n+// Cap returns the capacity of the buffer's underlying byte slice, that is, the\n+// total space allocated for the buffer's data.\n+func (b *Buffer) Cap() int { return cap(b.buf) }\n+\n // Truncate discards all but the first n unread bytes from the buffer.\n // It panics if n is negative or greater than the length of the buffer.\n func (b *Buffer) Truncate(n int) {"}, {"sha": "7de17ae47e28ff00f00dd295637a9917779e9e32", "filename": "libgo/go/bytes/buffer_test.go", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -231,6 +231,23 @@ func TestMixedReadsAndWrites(t *testing.T) {\n \tempty(t, \"TestMixedReadsAndWrites (2)\", &buf, s, make([]byte, buf.Len()))\n }\n \n+func TestCapWithPreallocatedSlice(t *testing.T) {\n+\tbuf := NewBuffer(make([]byte, 10))\n+\tn := buf.Cap()\n+\tif n != 10 {\n+\t\tt.Errorf(\"expected 10, got %d\", n)\n+\t}\n+}\n+\n+func TestCapWithSliceAndWrittenData(t *testing.T) {\n+\tbuf := NewBuffer(make([]byte, 0, 10))\n+\tbuf.Write([]byte(\"test\"))\n+\tn := buf.Cap()\n+\tif n != 10 {\n+\t\tt.Errorf(\"expected 10, got %d\", n)\n+\t}\n+}\n+\n func TestNil(t *testing.T) {\n \tvar b *Buffer\n \tif b.String() != \"<nil>\" {"}, {"sha": "b86824087e5356405855d4581aeb728fa50f8ae1", "filename": "libgo/go/bytes/bytes.go", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fbytes%2Fbytes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fbytes%2Fbytes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -23,7 +23,7 @@ func equalPortable(a, b []byte) bool {\n \treturn true\n }\n \n-// explode splits s into a slice of UTF-8 sequences, one per Unicode character (still slices of bytes),\n+// explode splits s into a slice of UTF-8 sequences, one per Unicode code point (still slices of bytes),\n // up to a maximum of n byte slices. Invalid UTF-8 sequences are chopped into individual bytes.\n func explode(s []byte, n int) [][]byte {\n \tif n <= 0 {\n@@ -47,6 +47,7 @@ func explode(s []byte, n int) [][]byte {\n }\n \n // Count counts the number of non-overlapping instances of sep in s.\n+// If sep is an empty slice, Count returns 1 + the number of Unicode code points in s.\n func Count(s, sep []byte) int {\n \tn := len(sep)\n \tif n == 0 {\n@@ -137,6 +138,16 @@ func LastIndex(s, sep []byte) int {\n \treturn -1\n }\n \n+// LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s.\n+func LastIndexByte(s []byte, c byte) int {\n+\tfor i := len(s) - 1; i >= 0; i-- {\n+\t\tif s[i] == c {\n+\t\t\treturn i\n+\t\t}\n+\t}\n+\treturn -1\n+}\n+\n // IndexRune interprets s as a sequence of UTF-8-encoded Unicode code points.\n // It returns the byte index of the first occurrence in s of the given rune.\n // It returns -1 if rune is not present in s.\n@@ -442,7 +453,7 @@ func isSeparator(r rune) bool {\n // Title returns a copy of s with all Unicode letters that begin words\n // mapped to their title case.\n //\n-// BUG: The rule Title uses for word boundaries does not handle Unicode punctuation properly.\n+// BUG(rsc): The rule Title uses for word boundaries does not handle Unicode punctuation properly.\n func Title(s []byte) []byte {\n \t// Use a closure here to remember state.\n \t// Hackish but effective. Depends on Map scanning in order and calling"}, {"sha": "b453f21aa4352d33e8e32443e221e22fb2fee613", "filename": "libgo/go/bytes/bytes_decl.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fbytes%2Fbytes_decl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fbytes%2Fbytes_decl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_decl.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -21,4 +21,4 @@ func Equal(a, b []byte) bool // ../runtime/asm_$GOARCH.s\n // Compare returns an integer comparing two byte slices lexicographically.\n // The result will be 0 if a==b, -1 if a < b, and +1 if a > b.\n // A nil argument is equivalent to an empty slice.\n-func Compare(a, b []byte) int // ../runtime/noasm_arm.goc or ../runtime/asm_{386,amd64}.s\n+func Compare(a, b []byte) int // ../runtime/noasm.go or ../runtime/asm_{386,amd64}.s"}, {"sha": "6245e481805779e8665965053bde7cae4ce31e78", "filename": "libgo/go/bytes/bytes_test.go", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -265,6 +265,23 @@ func TestIndexByte(t *testing.T) {\n \t}\n }\n \n+func TestLastIndexByte(t *testing.T) {\n+\ttestCases := []BinOpTest{\n+\t\t{\"\", \"q\", -1},\n+\t\t{\"abcdef\", \"q\", -1},\n+\t\t{\"abcdefabcdef\", \"a\", len(\"abcdef\")},      // something in the middle\n+\t\t{\"abcdefabcdef\", \"f\", len(\"abcdefabcde\")}, // last byte\n+\t\t{\"zabcdefabcdef\", \"z\", 0},                 // first byte\n+\t\t{\"a\u263ab\u263bc\u2639d\", \"b\", len(\"a\u263a\")},               // non-ascii\n+\t}\n+\tfor _, test := range testCases {\n+\t\tactual := LastIndexByte([]byte(test.a), test.b[0])\n+\t\tif actual != test.i {\n+\t\t\tt.Errorf(\"LastIndexByte(%q,%c) = %v; want %v\", test.a, test.b[0], actual, test.i)\n+\t\t}\n+\t}\n+}\n+\n // test a larger buffer with different sizes and alignments\n func TestIndexByteBig(t *testing.T) {\n \tvar n = 1024"}, {"sha": "f2d81d5310c0b915eeb304a8bae03f4b60d47d82", "filename": "libgo/go/bytes/compare_test.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fbytes%2Fcompare_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fbytes%2Fcompare_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fcompare_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -17,6 +17,8 @@ var compareTests = []struct {\n \t{[]byte(\"a\"), []byte(\"\"), 1},\n \t{[]byte(\"\"), []byte(\"a\"), -1},\n \t{[]byte(\"abc\"), []byte(\"abc\"), 0},\n+\t{[]byte(\"abd\"), []byte(\"abc\"), 1},\n+\t{[]byte(\"abc\"), []byte(\"abd\"), -1},\n \t{[]byte(\"ab\"), []byte(\"abc\"), -1},\n \t{[]byte(\"abc\"), []byte(\"ab\"), 1},\n \t{[]byte(\"x\"), []byte(\"ab\"), 1},\n@@ -27,6 +29,7 @@ var compareTests = []struct {\n \t{[]byte(\"abcdefgh\"), []byte(\"abcdefgh\"), 0},\n \t{[]byte(\"abcdefghi\"), []byte(\"abcdefghi\"), 0},\n \t{[]byte(\"abcdefghi\"), []byte(\"abcdefghj\"), -1},\n+\t{[]byte(\"abcdefghj\"), []byte(\"abcdefghi\"), 1},\n \t// nil tests\n \t{nil, nil, 0},\n \t{[]byte(\"\"), nil, 0},"}, {"sha": "f61523e60bbb3fd209594912ebcaa76cde9acd20", "filename": "libgo/go/bytes/export_test.go", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fbytes%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fbytes%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fexport_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -7,7 +7,3 @@ package bytes\n // Export func for testing\n var IndexBytePortable = indexBytePortable\n var EqualPortable = equalPortable\n-\n-func (b *Buffer) Cap() int {\n-\treturn cap(b.buf)\n-}"}, {"sha": "b89d1548f1b78ea16e5fa1bdb25e4228a5c684c9", "filename": "libgo/go/bytes/reader.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fbytes%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fbytes%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Freader.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -29,6 +29,12 @@ func (r *Reader) Len() int {\n \treturn int(int64(len(r.s)) - r.i)\n }\n \n+// Size returns the original length of the underlying byte slice.\n+// Size is the number of bytes available for reading via ReadAt.\n+// The returned value is always the same and is not affected by calls\n+// to any other method.\n+func (r *Reader) Size() int64 { return int64(len(r.s)) }\n+\n func (r *Reader) Read(b []byte) (n int, err error) {\n \tif len(b) == 0 {\n \t\treturn 0, nil"}, {"sha": "b929a2826096d501966925b00244c3af79dee42a", "filename": "libgo/go/bytes/reader_test.go", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fbytes%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fbytes%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Freader_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -244,3 +244,15 @@ func TestReaderCopyNothing(t *testing.T) {\n \t\tt.Errorf(\"behavior differs: with = %#v; without: %#v\", with, withOut)\n \t}\n }\n+\n+// tests that Len is affected by reads, but Size is not.\n+func TestReaderLenSize(t *testing.T) {\n+\tr := NewReader([]byte(\"abc\"))\n+\tio.CopyN(ioutil.Discard, r, 1)\n+\tif r.Len() != 2 {\n+\t\tt.Errorf(\"Len = %d; want 2\", r.Len())\n+\t}\n+\tif r.Size() != 3 {\n+\t\tt.Errorf(\"Size = %d; want 3\", r.Size())\n+\t}\n+}"}, {"sha": "8bbd1cc52e66e06edf8ec04665b9da2757d9ac03", "filename": "libgo/go/cmd/cgo/ast.go", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fcgo%2Fast.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fcgo%2Fast.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fast.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -235,9 +235,17 @@ func (f *File) saveExport(x interface{}, context string) {\n \t\t\terror_(c.Pos(), \"export comment has wrong name %q, want %q\", name, n.Name.Name)\n \t\t}\n \n+\t\tdoc := \"\"\n+\t\tfor _, c1 := range n.Doc.List {\n+\t\t\tif c1 != c {\n+\t\t\t\tdoc += c1.Text + \"\\n\"\n+\t\t\t}\n+\t\t}\n+\n \t\tf.ExpFunc = append(f.ExpFunc, &ExpFunc{\n \t\t\tFunc:    n,\n \t\t\tExpName: name,\n+\t\t\tDoc:     doc,\n \t\t})\n \t\tbreak\n \t}"}, {"sha": "b2a5428f3f4dfac7c42356014e3fd0cc7a85fa4a", "filename": "libgo/go/cmd/cgo/doc.go", "status": "modified", "additions": 132, "deletions": 109, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -20,16 +20,23 @@ the C parts of the package.  For example:\n \t// #include <errno.h>\n \timport \"C\"\n \n+The preamble may contain any C code, including function and variable\n+declarations and definitions.  These may then be referred to from Go\n+code as though they were defined in the package \"C\".  All names\n+declared in the preamble may be used, even if they start with a\n+lower-case letter.  Exception: static variables in the preamble may\n+not be referenced from Go code; static functions are permitted.\n+\n See $GOROOT/misc/cgo/stdio and $GOROOT/misc/cgo/gmp for examples.  See\n \"C? Go? Cgo!\" for an introduction to using cgo:\n-http://golang.org/doc/articles/c_go_cgo.html.\n+https://golang.org/doc/articles/c_go_cgo.html.\n \n CFLAGS, CPPFLAGS, CXXFLAGS and LDFLAGS may be defined with pseudo #cgo\n directives within these comments to tweak the behavior of the C or C++\n compiler.  Values defined in multiple directives are concatenated\n together.  The directive can include a list of build constraints limiting its\n effect to systems satisfying one of the constraints\n-(see http://golang.org/pkg/go/build/#hdr-Build_Constraints for details about the constraint syntax).\n+(see https://golang.org/pkg/go/build/#hdr-Build_Constraints for details about the constraint syntax).\n For example:\n \n \t// #cgo CFLAGS: -DPNG_DEBUG=1\n@@ -60,6 +67,18 @@ concatenated and used at link time.  All the pkg-config directives are\n concatenated and sent to pkg-config simultaneously to add to each appropriate\n set of command-line flags.\n \n+When the cgo directives are parsed, any occurrence of the string ${SRCDIR}\n+will be replaced by the absolute path to the directory containing the source\n+file. This allows pre-compiled static libraries to be included in the package\n+directory and linked properly.\n+For example if package foo is in the directory /go/src/foo:\n+\n+       // #cgo LDFLAGS: -L${SRCDIR}/libs -lfoo\n+\n+Will be expanded to:\n+\n+       // #cgo LDFLAGS: -L/go/src/foo/libs -lfoo\n+\n When the Go tool sees that one or more Go files use the special import\n \"C\", it will look for other non-Go files in the directory and compile\n them as part of the Go package.  Any .c, .s, or .S files will be\n@@ -71,17 +90,19 @@ compilers may be changed by the CC and CXX environment variables,\n respectively; those environment variables may include command line\n options.\n \n-To enable cgo during cross compiling builds, set the CGO_ENABLED\n-environment variable to 1 when building the Go tools with make.bash.\n-Also, set CC_FOR_TARGET to the C cross compiler for the target.  CC will\n-be used for compiling for the host.\n-\n-After the Go tools are built, when running the go command, CC_FOR_TARGET is\n-ignored.  The value of CC_FOR_TARGET when running make.bash is the default\n-compiler.  However, you can set the environment variable CC, not CC_FOR_TARGET,\n-to control the compiler when running the go tool.\n+The cgo tool is enabled by default for native builds on systems where\n+it is expected to work.  It is disabled by default when\n+cross-compiling.  You can control this by setting the CGO_ENABLED\n+environment variable when running the go tool: set it to 1 to enable\n+the use of cgo, and to 0 to disable it.  The go tool will set the\n+build constraint \"cgo\" if cgo is enabled.\n \n-CXX_FOR_TARGET works in a similar way for C++ code.\n+When cross-compiling, you must specify a C cross-compiler for cgo to\n+use.  You can do this by setting the CC_FOR_TARGET environment\n+variable when building the toolchain using make.bash, or by setting\n+the CC environment variable any time you run the go tool.  The\n+CXX_FOR_TARGET and CXX environment variables work in a similar way for\n+C++ code.\n \n Go references to C\n \n@@ -195,16 +216,18 @@ Not all Go types can be mapped to C types in a useful way.\n \n Using //export in a file places a restriction on the preamble:\n since it is copied into two different C output files, it must not\n-contain any definitions, only declarations. Definitions must be\n-placed in preambles in other files, or in C source files.\n+contain any definitions, only declarations. If a file contains both\n+definitions and declarations, then the two output files will produce\n+duplicate symbols and the linker will fail. To avoid this, definitions\n+must be placed in preambles in other files, or in C source files.\n \n Using cgo directly\n \n Usage:\n-\tgo tool cgo [cgo options] [-- compiler options] file.go\n+\tgo tool cgo [cgo options] [-- compiler options] gofiles...\n \n-Cgo transforms the input file.go into four output files: two Go source\n-files, a C file for 6c (or 8c or 5c), and a C file for gcc.\n+Cgo transforms the specified input Go source files into several output\n+Go and C source files.\n \n The compiler options are passed through uninterpreted when\n invoking the C compiler to compile the C parts of the package.\n@@ -217,18 +240,23 @@ The following options are available when running cgo directly:\n \t\tbuild when building a cgo package.\n \t-dynout file\n \t\tWrite -dynimport output to file.\n+\t-dynpackage package\n+\t\tSet Go package for -dynimport output.\n \t-dynlinker\n \t\tWrite dynamic linker as part of -dynimport output.\n \t-godefs\n \t\tWrite out input file in Go syntax replacing C package\n \t\tnames with real values. Used to generate files in the\n \t\tsyscall package when bootstrapping a new target.\n-\t-cdefs\n-\t\tLike -godefs, but write file in C syntax.\n-\t\tUsed to generate files in the runtime package when\n-\t\tbootstrapping a new target.\n \t-objdir directory\n \t\tPut all generated files in directory.\n+\t-importpath string\n+\t\tThe import path for the Go package. Optional; used for\n+\t\tnicer comments in the generated files.\n+\t-exportheader file\n+\t\tIf there are any exported functions, write the\n+\t\tgenerated export declarations to file.\n+\t\tC code can #include this to see the declarations.\n \t-gccgo\n \t\tGenerate output for the gccgo compiler rather than the\n \t\tgc compiler.\n@@ -363,54 +391,51 @@ the translation process.\n \n Translating Go\n \n-[The rest of this comment refers to 6g and 6c, the Go and C compilers\n-that are part of the amd64 port of the gc Go toolchain. Everything here\n-applies to another architecture's compilers as well.]\n+[The rest of this comment refers to 6g, the Go compiler that is part\n+of the amd64 port of the gc Go toolchain. Everything here applies to\n+another architecture's compilers as well.]\n \n Given the input Go files x.go and y.go, cgo generates these source\n files:\n \n \tx.cgo1.go       # for 6g\n \ty.cgo1.go       # for 6g\n \t_cgo_gotypes.go # for 6g\n-\t_cgo_defun.c    # for 6c\n+\t_cgo_import.go  # for 6g (if -dynout _cgo_import.go)\n \tx.cgo2.c        # for gcc\n \ty.cgo2.c        # for gcc\n+\t_cgo_defun.c    # for gcc (if -gccgo)\n \t_cgo_export.c   # for gcc\n+\t_cgo_export.h   # for gcc\n \t_cgo_main.c     # for gcc\n+\t_cgo_flags      # for alternative build tools\n \n The file x.cgo1.go is a copy of x.go with the import \"C\" removed and\n references to C.xxx replaced with names like _Cfunc_xxx or _Ctype_xxx.\n The definitions of those identifiers, written as Go functions, types,\n or variables, are provided in _cgo_gotypes.go.\n \n-Here is a _cgo_gotypes.go containing definitions for C.flush (provided\n-in the preamble) and C.puts (from stdio):\n+Here is a _cgo_gotypes.go containing definitions for needed C types:\n \n \ttype _Ctype_char int8\n \ttype _Ctype_int int32\n \ttype _Ctype_void [0]byte\n \n-\tfunc _Cfunc_CString(string) *_Ctype_char\n-\tfunc _Cfunc_flush() _Ctype_void\n-\tfunc _Cfunc_puts(*_Ctype_char) _Ctype_int\n-\n-For functions, cgo only writes an external declaration in the Go\n-output. The implementation is in a combination of C for 6c (meaning\n-any gc-toolchain compiler) and C for gcc.\n-\n-The 6c file contains the definitions of the functions. They all have\n-similar bodies that invoke runtime\u00b7cgocall to make a switch from the\n-Go runtime world to the system C (GCC-based) world.\n+The _cgo_gotypes.go file also contains the definitions of the\n+functions.  They all have similar bodies that invoke runtime\u00b7cgocall\n+to make a switch from the Go runtime world to the system C (GCC-based)\n+world.\n \n For example, here is the definition of _Cfunc_puts:\n \n-\tvoid _cgo_be59f0f25121_Cfunc_puts(void*);\n+\t//go:cgo_import_static _cgo_be59f0f25121_Cfunc_puts\n+\t//go:linkname __cgofn__cgo_be59f0f25121_Cfunc_puts _cgo_be59f0f25121_Cfunc_puts\n+\tvar __cgofn__cgo_be59f0f25121_Cfunc_puts byte\n+\tvar _cgo_be59f0f25121_Cfunc_puts = unsafe.Pointer(&__cgofn__cgo_be59f0f25121_Cfunc_puts)\n \n-\tvoid\n-\t\u00b7_Cfunc_puts(struct{uint8 x[1];}p)\n-\t{\n-\t\truntime\u00b7cgocall(_cgo_be59f0f25121_Cfunc_puts, &p);\n+\tfunc _Cfunc_puts(p0 *_Ctype_char) (r1 _Ctype_int) {\n+\t\t_cgo_runtime_cgocall(_cgo_be59f0f25121_Cfunc_puts, uintptr(unsafe.Pointer(&p0)))\n+\t\treturn\n \t}\n \n The hexadecimal number is a hash of cgo's input, chosen to be\n@@ -421,6 +446,7 @@ file compiled by gcc, the file x.cgo2.c:\n \tvoid\n \t_cgo_be59f0f25121_Cfunc_puts(void *v)\n \t{\n+\t\t_cgo_wait_runtime_init_done();\n \t\tstruct {\n \t\t\tchar* p0;\n \t\t\tint r;\n@@ -429,7 +455,8 @@ file compiled by gcc, the file x.cgo2.c:\n \t\ta->r = puts((void*)a->p0);\n \t}\n \n-It extracts the arguments from the pointer to _Cfunc_puts's argument\n+It waits for Go runtime to be initialized (required for shared libraries),\n+extracts the arguments from the pointer to _Cfunc_puts's argument\n frame, invokes the system C function (in this case, puts), stores the\n result in the frame, and returns.\n \n@@ -448,6 +475,7 @@ _cgo_main.c:\n \n \tint main() { return 0; }\n \tvoid crosscall2(void(*fn)(void*, int), void *a, int c) { }\n+\tvoid _cgo_wait_runtime_init_done() { }\n \tvoid _cgo_allocate(void *a, int c) { }\n \tvoid _cgo_panic(void *a, int c) { }\n \n@@ -456,23 +484,21 @@ code generated for gcc. The build process links this stub, along with\n _cgo_export.c and *.cgo2.c, into a dynamic executable and then lets\n cgo examine the executable. Cgo records the list of shared library\n references and resolved names and writes them into a new file\n-_cgo_import.c, which looks like:\n+_cgo_import.go, which looks like:\n \n-\t#pragma cgo_dynamic_linker \"/lib64/ld-linux-x86-64.so.2\"\n-\t#pragma cgo_import_dynamic puts puts#GLIBC_2.2.5 \"libc.so.6\"\n-\t#pragma cgo_import_dynamic __libc_start_main __libc_start_main#GLIBC_2.2.5 \"libc.so.6\"\n-\t#pragma cgo_import_dynamic stdout stdout#GLIBC_2.2.5 \"libc.so.6\"\n-\t#pragma cgo_import_dynamic fflush fflush#GLIBC_2.2.5 \"libc.so.6\"\n-\t#pragma cgo_import_dynamic _ _ \"libpthread.so.0\"\n-\t#pragma cgo_import_dynamic _ _ \"libc.so.6\"\n+\t//go:cgo_dynamic_linker \"/lib64/ld-linux-x86-64.so.2\"\n+\t//go:cgo_import_dynamic puts puts#GLIBC_2.2.5 \"libc.so.6\"\n+\t//go:cgo_import_dynamic __libc_start_main __libc_start_main#GLIBC_2.2.5 \"libc.so.6\"\n+\t//go:cgo_import_dynamic stdout stdout#GLIBC_2.2.5 \"libc.so.6\"\n+\t//go:cgo_import_dynamic fflush fflush#GLIBC_2.2.5 \"libc.so.6\"\n+\t//go:cgo_import_dynamic _ _ \"libpthread.so.0\"\n+\t//go:cgo_import_dynamic _ _ \"libc.so.6\"\n \n In the end, the compiled Go package, which will eventually be\n presented to 6l as part of a larger program, contains:\n \n-\t_go_.6        # 6g-compiled object for _cgo_gotypes.go *.cgo1.go\n-\t_cgo_defun.6  # 6c-compiled object for _cgo_defun.c\n+\t_go_.6        # 6g-compiled object for _cgo_gotypes.go, _cgo_import.go, *.cgo1.go\n \t_all.o        # gcc-compiled object for _cgo_export.c, *.cgo2.c\n-\t_cgo_import.6 # 6c-compiled object for _cgo_import.c\n \n The final program will be a dynamic executable, so that 6l can avoid\n needing to process arbitrary .o files. It only needs to process the .o\n@@ -496,20 +522,21 @@ Runtime\n \n When using cgo, Go must not assume that it owns all details of the\n process. In particular it needs to coordinate with C in the use of\n-threads and thread-local storage. The runtime package, in its own\n-(6c-compiled) C code, declares a few uninitialized (default bss)\n+threads and thread-local storage. The runtime package declares a few\n variables:\n \n-\tbool\truntime\u00b7iscgo;\n-\tvoid\t(*libcgo_thread_start)(void*);\n-\tvoid\t(*initcgo)(G*);\n+\tvar (\n+\t\tiscgo             bool\n+\t\t_cgo_init         unsafe.Pointer\n+\t\t_cgo_thread_start unsafe.Pointer\n+\t)\n \n Any package using cgo imports \"runtime/cgo\", which provides\n-initializations for these variables. It sets iscgo to 1, initcgo to a\n-gcc-compiled function that can be called early during program startup,\n-and libcgo_thread_start to a gcc-compiled function that can be used to\n-create a new thread, in place of the runtime's usual direct system\n-calls.\n+initializations for these variables. It sets iscgo to true, _cgo_init\n+to a gcc-compiled function that can be called early during program\n+startup, and _cgo_thread_start to a gcc-compiled function that can be\n+used to create a new thread, in place of the runtime's usual direct\n+system calls.\n \n Internal and External Linking\n \n@@ -522,12 +549,12 @@ code can only be used as a dynamic library). On the other hand, when\n using internal linking, 6l can generate Go binaries by itself.\n \n In order to allow linking arbitrary object files without requiring\n-dynamic libraries, cgo will soon support an \"external\" linking mode\n-too. In external linking mode, 6l does not process any host object\n-files. Instead, it collects all the Go code and writes a single go.o\n-object file containing it. Then it invokes the host linker (usually\n-gcc) to combine the go.o object file and any supporting non-Go code\n-into a final executable. External linking avoids the dynamic library\n+dynamic libraries, cgo supports an \"external\" linking mode too. In\n+external linking mode, 6l does not process any host object files.\n+Instead, it collects all the Go code and writes a single go.o object\n+file containing it. Then it invokes the host linker (usually gcc) to\n+combine the go.o object file and any supporting non-Go code into a\n+final executable. External linking avoids the dynamic library\n requirement but introduces a requirement that the host linker be\n present to create such a binary.\n \n@@ -555,13 +582,13 @@ to be made when linking the final binary.\n Linking Directives\n \n In either linking mode, package-specific directives must be passed\n-through to 6l. These are communicated by writing #pragma directives\n-in a C source file compiled by 6c. The directives are copied into the .6 object file\n-and then processed by the linker.\n+through to 6l. These are communicated by writing //go: directives in a\n+Go source file compiled by 6g. The directives are copied into the .6\n+object file and then processed by the linker.\n \n The directives are:\n \n-#pragma cgo_import_dynamic <local> [<remote> [\"<library>\"]]\n+//go:cgo_import_dynamic <local> [<remote> [\"<library>\"]]\n \n \tIn internal linking mode, allow an unresolved reference to\n \t<local>, assuming it will be resolved by a dynamic library\n@@ -572,32 +599,32 @@ The directives are:\n \tIn the <remote>, # or @ can be used to introduce a symbol version.\n \n \tExamples:\n-\t#pragma cgo_import_dynamic puts\n-\t#pragma cgo_import_dynamic puts puts#GLIBC_2.2.5\n-\t#pragma cgo_import_dynamic puts puts#GLIBC_2.2.5 \"libc.so.6\"\n+\t//go:cgo_import_dynamic puts\n+\t//go:cgo_import_dynamic puts puts#GLIBC_2.2.5\n+\t//go:cgo_import_dynamic puts puts#GLIBC_2.2.5 \"libc.so.6\"\n \n \tA side effect of the cgo_import_dynamic directive with a\n \tlibrary is to make the final binary depend on that dynamic\n \tlibrary. To get the dependency without importing any specific\n \tsymbols, use _ for local and remote.\n \n \tExample:\n-\t#pragma cgo_import_dynamic _ _ \"libc.so.6\"\n+\t//go:cgo_import_dynamic _ _ \"libc.so.6\"\n \n \tFor compatibility with current versions of SWIG,\n-\t#pragma dynimport is an alias for #pragma cgo_import_dynamic.\n+\t#pragma dynimport is an alias for //go:cgo_import_dynamic.\n \n-#pragma cgo_dynamic_linker \"<path>\"\n+//go:cgo_dynamic_linker \"<path>\"\n \n \tIn internal linking mode, use \"<path>\" as the dynamic linker\n \tin the final binary. This directive is only needed from one\n \tpackage when constructing a binary; by convention it is\n \tsupplied by runtime/cgo.\n \n \tExample:\n-\t#pragma cgo_dynamic_linker \"/lib/ld-linux.so.2\"\n+\t//go:cgo_dynamic_linker \"/lib/ld-linux.so.2\"\n \n-#pragma cgo_export_dynamic <local> <remote>\n+//go:cgo_export_dynamic <local> <remote>\n \n \tIn internal linking mode, put the Go symbol\n \tnamed <local> into the program's exported symbol table as\n@@ -606,35 +633,35 @@ The directives are:\n \tto share Go's data.\n \n \tFor compatibility with current versions of SWIG,\n-\t#pragma dynexport is an alias for #pragma cgo_export_dynamic.\n+\t#pragma dynexport is an alias for //go:cgo_export_dynamic.\n \n-#pragma cgo_import_static <local>\n+//go:cgo_import_static <local>\n \n \tIn external linking mode, allow unresolved references to\n \t<local> in the go.o object file prepared for the host linker,\n \tunder the assumption that <local> will be supplied by the\n \tother object files that will be linked with go.o.\n \n \tExample:\n-\t#pragma cgo_import_static puts_wrapper\n+\t//go:cgo_import_static puts_wrapper\n \n-#pragma cgo_export_static <local> <remote>\n+//go:cgo_export_static <local> <remote>\n \n \tIn external linking mode, put the Go symbol\n \tnamed <local> into the program's exported symbol table as\n \t<remote>, so that C code can refer to it by that name. This\n \tmechanism makes it possible for C code to call back into Go or\n \tto share Go's data.\n \n-#pragma cgo_ldflag \"<arg>\"\n+//go:cgo_ldflag \"<arg>\"\n \n \tIn external linking mode, invoke the host linker (usually gcc)\n \twith \"<arg>\" as a command-line argument following the .o files.\n \tNote that the arguments are for \"gcc\", not \"ld\".\n \n \tExample:\n-\t#pragma cgo_ldflag \"-lpthread\"\n-\t#pragma cgo_ldflag \"-L/usr/local/sqlite3/lib\"\n+\t//go:cgo_ldflag \"-lpthread\"\n+\t//go:cgo_ldflag \"-L/usr/local/sqlite3/lib\"\n \n A package compiled with cgo will include directives for both\n internal and external linking; the linker will select the appropriate\n@@ -647,22 +674,18 @@ The following code will be generated by cgo:\n \n \t// compiled by 6g\n \n-\ttype _Ctype_double float64\n-\tfunc _Cfunc_sin(_Ctype_double) _Ctype_double\n-\n-\t// compiled by 6c\n+\t//go:cgo_ldflag \"-lm\"\n \n-\t#pragma cgo_import_dynamic sin sin#GLIBC_2.2.5 \"libm.so.6\"\n-\n-\t#pragma cgo_import_static _cgo_gcc_Cfunc_sin\n-\t#pragma cgo_ldflag \"-lm\"\n+\ttype _Ctype_double float64\n \n-\tvoid _cgo_gcc_Cfunc_sin(void*);\n+\t//go:cgo_import_static _cgo_gcc_Cfunc_sin\n+\t//go:linkname __cgo_gcc_Cfunc_sin _cgo_gcc_Cfunc_sin\n+\tvar __cgo_gcc_Cfunc_sin byte\n+\tvar _cgo_gcc_Cfunc_sin = unsafe.Pointer(&__cgo_gcc_Cfunc_sin)\n \n-\tvoid\n-\t\u00b7_Cfunc_sin(struct{uint8 x[16];}p)\n-\t{\n-\t\truntime\u00b7cgocall(_cgo_gcc_Cfunc_sin, &p);\n+\tfunc _Cfunc_sin(p0 _Ctype_double) (r1 _Ctype_double) {\n+\t\t_cgo_runtime_cgocall(_cgo_gcc_Cfunc_sin, uintptr(unsafe.Pointer(&p0)))\n+\t\treturn\n \t}\n \n \t// compiled by gcc, into foo.cgo2.o\n@@ -682,8 +705,8 @@ using the internal or external mode. If other packages are compiled in\n \"external only\" mode, then the final link will be an external one.\n Otherwise the link will be an internal one.\n \n-The directives in the 6c-compiled file are used according to the kind\n-of final link used.\n+The linking directives are used according to the kind of final link\n+used.\n \n In internal mode, 6l itself processes all the host object files, in\n particular foo.cgo2.o. To do so, it uses the cgo_import_dynamic and\n@@ -694,10 +717,10 @@ symbol sin with version GLIBC_2.2.5 from the dynamic library\n runtime dynamic linker.\n \n In external mode, 6l does not process any host object files, in\n-particular foo.cgo2.o. It links together the 6g- and 6c-generated\n-object files, along with any other Go code, into a go.o file. While\n-doing that, 6l will discover that there is no definition for\n-_cgo_gcc_Cfunc_sin, referred to by the 6c-compiled source file. This\n+particular foo.cgo2.o. It links together the 6g-generated object\n+files, along with any other Go code, into a go.o file. While doing\n+that, 6l will discover that there is no definition for\n+_cgo_gcc_Cfunc_sin, referred to by the 6g-compiled source file. This\n is okay, because 6l also processes the cgo_import_static directive and\n knows that _cgo_gcc_Cfunc_sin is expected to be supplied by a host\n object file, so 6l does not treat the missing symbol as an error when"}, {"sha": "b64849a8d16f37f577cad456b40b8822f4371b6c", "filename": "libgo/go/cmd/cgo/gcc.go", "status": "modified", "additions": 54, "deletions": 42, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -154,20 +154,6 @@ func splitQuoted(s string) (r []string, err error) {\n \treturn args, err\n }\n \n-var safeBytes = []byte(`+-.,/0123456789:=ABCDEFGHIJKLMNOPQRSTUVWXYZ\\_abcdefghijklmnopqrstuvwxyz`)\n-\n-func safeName(s string) bool {\n-\tif s == \"\" {\n-\t\treturn false\n-\t}\n-\tfor i := 0; i < len(s); i++ {\n-\t\tif c := s[i]; c < 0x80 && bytes.IndexByte(safeBytes, c) < 0 {\n-\t\t\treturn false\n-\t\t}\n-\t}\n-\treturn true\n-}\n-\n // Translate rewrites f.AST, the original Go input, to remove\n // references to the imported package C, replacing them with\n // references to the equivalent Go types, functions, and variables.\n@@ -213,6 +199,10 @@ func (p *Package) loadDefines(f *File) {\n \t\t\tval = strings.TrimSpace(line[tabIndex:])\n \t\t}\n \n+\t\tif key == \"__clang__\" {\n+\t\t\tp.GccIsClang = true\n+\t\t}\n+\n \t\tif n := f.Name[key]; n != nil {\n \t\t\tif *debugDefine {\n \t\t\t\tfmt.Fprintf(os.Stderr, \"#define %s %s\\n\", key, val)\n@@ -582,7 +572,7 @@ func (p *Package) mangleName(n *Name) {\n \n // rewriteRef rewrites all the C.xxx references in f.AST to refer to the\n // Go equivalents, now that we have figured out the meaning of all\n-// the xxx.  In *godefs or *cdefs mode, rewriteRef replaces the names\n+// the xxx.  In *godefs mode, rewriteRef replaces the names\n // with full definitions instead of mangled names.\n func (p *Package) rewriteRef(f *File) {\n \t// Keep a list of all the functions, to remove the ones\n@@ -673,6 +663,13 @@ func (p *Package) rewriteRef(f *File) {\n \t\t\t\texpr = &ast.StarExpr{Star: (*r.Expr).Pos(), X: expr}\n \t\t\t}\n \n+\t\tcase \"selector\":\n+\t\t\tif r.Name.Kind == \"var\" {\n+\t\t\t\texpr = &ast.StarExpr{Star: (*r.Expr).Pos(), X: expr}\n+\t\t\t} else {\n+\t\t\t\terror_(r.Pos(), \"only C variables allowed in selector expression\", fixGo(r.Name.Go))\n+\t\t\t}\n+\n \t\tcase \"type\":\n \t\t\tif r.Name.Kind != \"type\" {\n \t\t\t\terror_(r.Pos(), \"expression C.%s used as type\", fixGo(r.Name.Go))\n@@ -688,7 +685,7 @@ func (p *Package) rewriteRef(f *File) {\n \t\t\t\terror_(r.Pos(), \"must call C.%s\", fixGo(r.Name.Go))\n \t\t\t}\n \t\t}\n-\t\tif *godefs || *cdefs {\n+\t\tif *godefs {\n \t\t\t// Substitute definition for mangled type name.\n \t\t\tif id, ok := expr.(*ast.Ident); ok {\n \t\t\t\tif t := typedef[id.Name]; t != nil {\n@@ -746,6 +743,10 @@ func (p *Package) gccMachine() []string {\n \t\treturn []string{\"-m32\"}\n \tcase \"arm\":\n \t\treturn []string{\"-marm\"} // not thumb\n+\tcase \"s390\":\n+\t\treturn []string{\"-m31\"}\n+\tcase \"s390x\":\n+\t\treturn []string{\"-m64\"}\n \t}\n \treturn nil\n }\n@@ -765,7 +766,7 @@ func (p *Package) gccCmd() []string {\n \t\t\"-c\",          // do not link\n \t\t\"-xc\",         // input language is C\n \t)\n-\tif strings.Contains(c[0], \"clang\") {\n+\tif p.GccIsClang {\n \t\tc = append(c,\n \t\t\t\"-ferror-limit=0\",\n \t\t\t// Apple clang version 1.7 (tags/Apple/clang-77) (based on LLVM 2.9svn)\n@@ -780,7 +781,7 @@ func (p *Package) gccCmd() []string {\n \t\t\t// incorrectly typed unsigned long. We work around that\n \t\t\t// by disabling the builtin functions (this is safe as\n \t\t\t// it won't affect the actual compilation of the C code).\n-\t\t\t// See: http://golang.org/issue/6506.\n+\t\t\t// See: https://golang.org/issue/6506.\n \t\t\t\"-fno-builtin\",\n \t\t)\n \t}\n@@ -992,8 +993,8 @@ func (c *typeConv) Init(ptrSize, intSize int64) {\n \tc.goVoid = c.Ident(\"_Ctype_void\")\n \n \t// Normally cgo translates void* to unsafe.Pointer,\n-\t// but for historical reasons -cdefs and -godefs use *byte instead.\n-\tif *cdefs || *godefs {\n+\t// but for historical reasons -godefs uses *byte instead.\n+\tif *godefs {\n \t\tc.goVoidPtr = &ast.StarExpr{X: c.byte}\n \t} else {\n \t\tc.goVoidPtr = c.Ident(\"unsafe.Pointer\")\n@@ -1045,7 +1046,7 @@ func (tr *TypeRepr) String() string {\n \treturn fmt.Sprintf(tr.Repr, tr.FormatArgs...)\n }\n \n-// Empty returns true if the result of String would be \"\".\n+// Empty reports whether the result of String would be \"\".\n func (tr *TypeRepr) Empty() bool {\n \treturn len(tr.Repr) == 0\n }\n@@ -1334,8 +1335,8 @@ func (c *typeConv) Type(dtype dwarf.Type, pos token.Pos) *Type {\n \t\t// If sub.Go.Name is \"_Ctype_struct_foo\" or \"_Ctype_union_foo\" or \"_Ctype_class_foo\",\n \t\t// use that as the Go form for this typedef too, so that the typedef will be interchangeable\n \t\t// with the base type.\n-\t\t// In -godefs and -cdefs mode, do this for all typedefs.\n-\t\tif isStructUnionClass(sub.Go) || *godefs || *cdefs {\n+\t\t// In -godefs mode, do this for all typedefs.\n+\t\tif isStructUnionClass(sub.Go) || *godefs {\n \t\t\tt.Go = sub.Go\n \n \t\t\tif isStructUnionClass(sub.Go) {\n@@ -1397,7 +1398,7 @@ func (c *typeConv) Type(dtype dwarf.Type, pos token.Pos) *Type {\n \t\t\tname := c.Ident(\"_Ctype_\" + s)\n \t\t\ttt := *t\n \t\t\ttypedef[name.Name] = &tt\n-\t\t\tif !*godefs && !*cdefs {\n+\t\t\tif !*godefs {\n \t\t\t\tt.Go = name\n \t\t\t}\n \t\t}\n@@ -1543,21 +1544,24 @@ func (c *typeConv) intExpr(n int64) ast.Expr {\n }\n \n // Add padding of given size to fld.\n-func (c *typeConv) pad(fld []*ast.Field, size int64) []*ast.Field {\n+func (c *typeConv) pad(fld []*ast.Field, sizes []int64, size int64) ([]*ast.Field, []int64) {\n \tn := len(fld)\n \tfld = fld[0 : n+1]\n \tfld[n] = &ast.Field{Names: []*ast.Ident{c.Ident(\"_\")}, Type: c.Opaque(size)}\n-\treturn fld\n+\tsizes = sizes[0 : n+1]\n+\tsizes[n] = size\n+\treturn fld, sizes\n }\n \n-// Struct conversion: return Go and (6g) C syntax for type.\n+// Struct conversion: return Go and (gc) C syntax for type.\n func (c *typeConv) Struct(dt *dwarf.StructType, pos token.Pos) (expr *ast.StructType, csyntax string, align int64) {\n \t// Minimum alignment for a struct is 1 byte.\n \talign = 1\n \n \tvar buf bytes.Buffer\n \tbuf.WriteString(\"struct {\")\n \tfld := make([]*ast.Field, 0, 2*len(dt.Field)+1) // enough for padding around every field\n+\tsizes := make([]int64, 0, 2*len(dt.Field)+1)\n \toff := int64(0)\n \n \t// Rename struct fields that happen to be named Go keywords into\n@@ -1573,7 +1577,7 @@ func (c *typeConv) Struct(dt *dwarf.StructType, pos token.Pos) (expr *ast.Struct\n \t\tused[f.Name] = true\n \t}\n \n-\tif !*godefs && !*cdefs {\n+\tif !*godefs {\n \t\tfor cid, goid := range ident {\n \t\t\tif token.Lookup(goid).IsKeyword() {\n \t\t\t\t// Avoid keyword\n@@ -1593,19 +1597,19 @@ func (c *typeConv) Struct(dt *dwarf.StructType, pos token.Pos) (expr *ast.Struct\n \tanon := 0\n \tfor _, f := range dt.Field {\n \t\tif f.ByteOffset > off {\n-\t\t\tfld = c.pad(fld, f.ByteOffset-off)\n+\t\t\tfld, sizes = c.pad(fld, sizes, f.ByteOffset-off)\n \t\t\toff = f.ByteOffset\n \t\t}\n \n \t\tname := f.Name\n \t\tft := f.Type\n \n-\t\t// In godefs or cdefs mode, if this field is a C11\n+\t\t// In godefs mode, if this field is a C11\n \t\t// anonymous union then treat the first field in the\n \t\t// union as the field in the struct.  This handles\n \t\t// cases like the glibc <sys/resource.h> file; see\n \t\t// issue 6677.\n-\t\tif *godefs || *cdefs {\n+\t\tif *godefs {\n \t\t\tif st, ok := f.Type.(*dwarf.StructType); ok && name == \"\" && st.Kind == \"union\" && len(st.Field) > 0 && !used[st.Field[0].Name] {\n \t\t\t\tname = st.Field[0].Name\n \t\t\t\tident[name] = name\n@@ -1635,14 +1639,12 @@ func (c *typeConv) Struct(dt *dwarf.StructType, pos token.Pos) (expr *ast.Struct\n \t\t\ttalign = size\n \t\t}\n \n-\t\tif talign > 0 && f.ByteOffset%talign != 0 && !*cdefs {\n+\t\tif talign > 0 && f.ByteOffset%talign != 0 {\n \t\t\t// Drop misaligned fields, the same way we drop integer bit fields.\n \t\t\t// The goal is to make available what can be made available.\n \t\t\t// Otherwise one bad and unneeded field in an otherwise okay struct\n \t\t\t// makes the whole program not compile. Much of the time these\n \t\t\t// structs are in system headers that cannot be corrected.\n-\t\t\t// Exception: In -cdefs mode, we use #pragma pack, so misaligned\n-\t\t\t// fields should still work.\n \t\t\tcontinue\n \t\t}\n \t\tn := len(fld)\n@@ -1653,6 +1655,8 @@ func (c *typeConv) Struct(dt *dwarf.StructType, pos token.Pos) (expr *ast.Struct\n \t\t\tident[name] = name\n \t\t}\n \t\tfld[n] = &ast.Field{Names: []*ast.Ident{c.Ident(ident[name])}, Type: tgo}\n+\t\tsizes = sizes[0 : n+1]\n+\t\tsizes[n] = size\n \t\toff += size\n \t\tbuf.WriteString(t.C.String())\n \t\tbuf.WriteString(\" \")\n@@ -1663,16 +1667,29 @@ func (c *typeConv) Struct(dt *dwarf.StructType, pos token.Pos) (expr *ast.Struct\n \t\t}\n \t}\n \tif off < dt.ByteSize {\n-\t\tfld = c.pad(fld, dt.ByteSize-off)\n+\t\tfld, sizes = c.pad(fld, sizes, dt.ByteSize-off)\n \t\toff = dt.ByteSize\n \t}\n+\n+\t// If the last field in a non-zero-sized struct is zero-sized\n+\t// the compiler is going to pad it by one (see issue 9401).\n+\t// We can't permit that, because then the size of the Go\n+\t// struct will not be the same as the size of the C struct.\n+\t// Our only option in such a case is to remove the field,\n+\t// which means that it can not be referenced from Go.\n+\tfor off > 0 && sizes[len(sizes)-1] == 0 {\n+\t\tn := len(sizes)\n+\t\tfld = fld[0 : n-1]\n+\t\tsizes = sizes[0 : n-1]\n+\t}\n+\n \tif off != dt.ByteSize {\n \t\tfatalf(\"%s: struct size calculation error off=%d bytesize=%d\", lineno(pos), off, dt.ByteSize)\n \t}\n \tbuf.WriteString(\"}\")\n \tcsyntax = buf.String()\n \n-\tif *godefs || *cdefs {\n+\tif *godefs {\n \t\tgodefsFields(fld)\n \t}\n \texpr = &ast.StructType{Fields: &ast.FieldList{List: fld}}\n@@ -1707,9 +1724,7 @@ func godefsFields(fld []*ast.Field) {\n \t\t\t\tn.Name = \"Pad_cgo_\" + strconv.Itoa(npad)\n \t\t\t\tnpad++\n \t\t\t}\n-\t\t\tif !*cdefs {\n-\t\t\t\tn.Name = upper(n.Name)\n-\t\t\t}\n+\t\t\tn.Name = upper(n.Name)\n \t\t}\n \t}\n }\n@@ -1721,9 +1736,6 @@ func godefsFields(fld []*ast.Field) {\n // package syscall's data structures, we drop a common prefix\n // (so sec, usec, which will get turned into Sec, Usec for exporting).\n func fieldPrefix(fld []*ast.Field) string {\n-\tif *cdefs {\n-\t\treturn \"\"\n-\t}\n \tprefix := \"\"\n \tfor _, f := range fld {\n \t\tfor _, n := range f.Names {"}, {"sha": "1b0ece29ef4895d03aa3ca7d2eb3550c3e16d694", "filename": "libgo/go/cmd/cgo/godefs.go", "status": "modified", "additions": 0, "deletions": 167, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fcgo%2Fgodefs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fcgo%2Fgodefs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fgodefs.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -114,173 +114,6 @@ func (p *Package) godefs(f *File, srcfile string) string {\n \treturn buf.String()\n }\n \n-// cdefs returns the output for -cdefs mode.\n-// The easiest way to do this is to translate the godefs Go to C.\n-func (p *Package) cdefs(f *File, srcfile string) string {\n-\tgodefsOutput := p.godefs(f, srcfile)\n-\n-\tlines := strings.Split(godefsOutput, \"\\n\")\n-\tlines[0] = \"// Created by cgo -cdefs - DO NOT EDIT\"\n-\n-\tfor i, line := range lines {\n-\t\tlines[i] = strings.TrimSpace(line)\n-\t}\n-\n-\tvar out bytes.Buffer\n-\tprintf := func(format string, args ...interface{}) { fmt.Fprintf(&out, format, args...) }\n-\n-\tdidTypedef := false\n-\tfor i := 0; i < len(lines); i++ {\n-\t\tline := lines[i]\n-\n-\t\t// Delete\n-\t\t//\tpackage x\n-\t\tif strings.HasPrefix(line, \"package \") {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\t// Convert\n-\t\t//\tconst (\n-\t\t//\t\tA = 1\n-\t\t//\t\tB = 2\n-\t\t//\t)\n-\t\t//\n-\t\t// to\n-\t\t//\n-\t\t//\tenum {\n-\t\t//\t\tA = 1,\n-\t\t//\t\tB = 2,\n-\t\t//\t};\n-\t\tif line == \"const (\" {\n-\t\t\tprintf(\"enum {\\n\")\n-\t\t\tfor i++; i < len(lines) && lines[i] != \")\"; i++ {\n-\t\t\t\tline = lines[i]\n-\t\t\t\tif line != \"\" {\n-\t\t\t\t\tprintf(\"\\t%s,\", line)\n-\t\t\t\t}\n-\t\t\t\tprintf(\"\\n\")\n-\t\t\t}\n-\t\t\tprintf(\"};\\n\")\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\t// Convert\n-\t\t//\tconst A = 1\n-\t\t// to\n-\t\t//\tenum { A = 1 };\n-\t\tif strings.HasPrefix(line, \"const \") {\n-\t\t\tprintf(\"enum { %s };\\n\", line[len(\"const \"):])\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\t// On first type definition, typedef all the structs\n-\t\t// in case there are dependencies between them.\n-\t\tif !didTypedef && strings.HasPrefix(line, \"type \") {\n-\t\t\tdidTypedef = true\n-\t\t\tfor _, line := range lines {\n-\t\t\t\tline = strings.TrimSpace(line)\n-\t\t\t\tif strings.HasPrefix(line, \"type \") && strings.HasSuffix(line, \" struct {\") {\n-\t\t\t\t\ts := strings.TrimSuffix(strings.TrimPrefix(line, \"type \"), \" struct {\")\n-\t\t\t\t\tprintf(\"typedef struct %s %s;\\n\", s, s)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tprintf(\"\\n\")\n-\t\t\tprintf(\"#pragma pack on\\n\")\n-\t\t\tprintf(\"\\n\")\n-\t\t}\n-\n-\t\t// Convert\n-\t\t//\ttype T struct {\n-\t\t//\t\tX int64\n-\t\t//\t\tY *int32\n-\t\t//\t\tZ [4]byte\n-\t\t//\t}\n-\t\t//\n-\t\t// to\n-\t\t//\n-\t\t//\tstruct T {\n-\t\t//\t\tint64 X;\n-\t\t//\t\tint32 *Y;\n-\t\t//\t\tbyte Z[4];\n-\t\t//\t}\n-\t\tif strings.HasPrefix(line, \"type \") && strings.HasSuffix(line, \" struct {\") {\n-\t\t\tif len(lines) > i+1 && lines[i+1] == \"}\" {\n-\t\t\t\t// do not output empty struct\n-\t\t\t\ti++\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\ts := line[len(\"type \") : len(line)-len(\" struct {\")]\n-\t\t\tprintf(\"struct %s {\\n\", s)\n-\t\t\tfor i++; i < len(lines) && lines[i] != \"}\"; i++ {\n-\t\t\t\tline := lines[i]\n-\t\t\t\tif line != \"\" {\n-\t\t\t\t\tf := strings.Fields(line)\n-\t\t\t\t\tif len(f) != 2 {\n-\t\t\t\t\t\tfmt.Fprintf(os.Stderr, \"cgo: cannot parse struct field: %s\\n\", line)\n-\t\t\t\t\t\tnerrors++\n-\t\t\t\t\t\tcontinue\n-\t\t\t\t\t}\n-\t\t\t\t\tprintf(\"\\t%s;\", cdecl(f[0], f[1]))\n-\t\t\t\t}\n-\t\t\t\tprintf(\"\\n\")\n-\t\t\t}\n-\t\t\tprintf(\"};\\n\")\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\t// Convert\n-\t\t//\ttype T int\n-\t\t// to\n-\t\t//\ttypedef int T;\n-\t\tif strings.HasPrefix(line, \"type \") {\n-\t\t\tf := strings.Fields(line[len(\"type \"):])\n-\t\t\tif len(f) != 2 {\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"cgo: cannot parse type definition: %s\\n\", line)\n-\t\t\t\tnerrors++\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tprintf(\"typedef\\t%s;\\n\", cdecl(f[0], f[1]))\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tprintf(\"%s\\n\", line)\n-\t}\n-\n-\tif didTypedef {\n-\t\tprintf(\"\\n\")\n-\t\tprintf(\"#pragma pack off\\n\")\n-\t}\n-\n-\treturn out.String()\n-}\n-\n-// cdecl returns the C declaration for the given Go name and type.\n-// It only handles the specific cases necessary for converting godefs output.\n-func cdecl(name, typ string) string {\n-\t// X *[0]byte -> X *void\n-\tif strings.HasPrefix(typ, \"*[0]\") {\n-\t\ttyp = \"*void\"\n-\t}\n-\t// X [4]byte -> X[4] byte\n-\tfor strings.HasPrefix(typ, \"[\") {\n-\t\ti := strings.Index(typ, \"]\") + 1\n-\t\tname = name + typ[:i]\n-\t\ttyp = typ[i:]\n-\t}\n-\t// X *byte -> *X byte\n-\tfor strings.HasPrefix(typ, \"*\") {\n-\t\tname = \"*\" + name\n-\t\ttyp = typ[1:]\n-\t}\n-\t// X T -> T X\n-\t// Handle the special case: 'unsafe.Pointer' is 'void *'\n-\tif typ == \"unsafe.Pointer\" {\n-\t\ttyp = \"void\"\n-\t\tname = \"*\" + name\n-\t}\n-\treturn typ + \"\\t\" + name\n-}\n-\n var gofmtBuf bytes.Buffer\n \n // gofmt returns the gofmt-formatted string for an AST node."}, {"sha": "c8cd1610baf221f3f5d644d4e61f43e99225dce4", "filename": "libgo/go/cmd/cgo/main.go", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -6,7 +6,7 @@\n \n // TODO(rsc):\n //\tEmit correct line number annotations.\n-//\tMake 6g understand the annotations.\n+//\tMake gc understand the annotations.\n \n package main\n \n@@ -33,6 +33,7 @@ type Package struct {\n \tPtrSize     int64\n \tIntSize     int64\n \tGccOptions  []string\n+\tGccIsClang  bool\n \tCgoFlags    map[string][]string // #cgo flags (CFLAGS, LDFLAGS)\n \tWritten     map[string]bool\n \tName        map[string]*Name // accumulated Name from Files\n@@ -87,7 +88,7 @@ type Name struct {\n \tConst    string // constant definition\n }\n \n-// IsVar returns true if Kind is either \"var\" or \"fpvar\"\n+// IsVar reports whether Kind is either \"var\" or \"fpvar\"\n func (n *Name) IsVar() bool {\n \treturn n.Kind == \"var\" || n.Kind == \"fpvar\"\n }\n@@ -98,6 +99,7 @@ func (n *Name) IsVar() bool {\n type ExpFunc struct {\n \tFunc    *ast.FuncDecl\n \tExpName string // name to use from C\n+\tDoc     string\n }\n \n // A TypeRepr contains the string representation of a type.\n@@ -174,15 +176,18 @@ var cPrefix string\n var fset = token.NewFileSet()\n \n var dynobj = flag.String(\"dynimport\", \"\", \"if non-empty, print dynamic import data for that file\")\n-var dynout = flag.String(\"dynout\", \"\", \"write -dynobj output to this file\")\n-var dynlinker = flag.Bool(\"dynlinker\", false, \"record dynamic linker information in dynimport mode\")\n+var dynout = flag.String(\"dynout\", \"\", \"write -dynimport output to this file\")\n+var dynpackage = flag.String(\"dynpackage\", \"main\", \"set Go package for -dynimport output\")\n+var dynlinker = flag.Bool(\"dynlinker\", false, \"record dynamic linker information in -dynimport mode\")\n \n-// These flags are for bootstrapping a new Go implementation,\n-// to generate Go and C headers that match the data layout and\n+// This flag is for bootstrapping a new Go implementation,\n+// to generate Go types that match the data layout and\n // constant values used in the host's C libraries and system calls.\n var godefs = flag.Bool(\"godefs\", false, \"for bootstrap: write Go definitions for C file to standard output\")\n-var cdefs = flag.Bool(\"cdefs\", false, \"for bootstrap: write C definitions for C file to standard output\")\n+\n var objDir = flag.String(\"objdir\", \"\", \"object directory\")\n+var importPath = flag.String(\"importpath\", \"\", \"import path of package being built (for comments in generated files)\")\n+var exportHeader = flag.String(\"exportheader\", \"\", \"where to write export header if any exported functions\")\n \n var gccgo = flag.Bool(\"gccgo\", false, \"generate files for use with gccgo\")\n var gccgoprefix = flag.String(\"gccgoprefix\", \"\", \"-fgo-prefix option used with gccgo\")\n@@ -208,12 +213,7 @@ func main() {\n \t\treturn\n \t}\n \n-\tif *godefs && *cdefs {\n-\t\tfmt.Fprintf(os.Stderr, \"cgo: cannot use -cdefs and -godefs together\\n\")\n-\t\tos.Exit(2)\n-\t}\n-\n-\tif *godefs || *cdefs {\n+\tif *godefs {\n \t\t// Generating definitions pulled from header files,\n \t\t// to be checked into Go repositories.\n \t\t// Line numbers are just noise.\n@@ -305,14 +305,12 @@ func main() {\n \t\tp.Record(f)\n \t\tif *godefs {\n \t\t\tos.Stdout.WriteString(p.godefs(f, input))\n-\t\t} else if *cdefs {\n-\t\t\tos.Stdout.WriteString(p.cdefs(f, input))\n \t\t} else {\n \t\t\tp.writeOutput(f, input)\n \t\t}\n \t}\n \n-\tif !*godefs && !*cdefs {\n+\tif !*godefs {\n \t\tp.writeDefs()\n \t}\n \tif nerrors > 0 {"}, {"sha": "90a744196228e1e93c53e97a01984adb64efde02", "filename": "libgo/go/cmd/cgo/out.go", "status": "modified", "additions": 208, "deletions": 123, "changes": 331, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -13,18 +13,25 @@ import (\n \t\"go/ast\"\n \t\"go/printer\"\n \t\"go/token\"\n+\t\"io\"\n \t\"os\"\n \t\"sort\"\n \t\"strings\"\n )\n \n var conf = printer.Config{Mode: printer.SourcePos, Tabwidth: 8}\n \n-// writeDefs creates output files to be compiled by 6g, 6c, and gcc.\n-// (The comments here say 6g and 6c but the code applies to the 8 and 5 tools too.)\n+// writeDefs creates output files to be compiled by gc and gcc.\n func (p *Package) writeDefs() {\n-\tfgo2 := creat(*objDir + \"_cgo_gotypes.go\")\n-\tfc := creat(*objDir + \"_cgo_defun.c\")\n+\tvar fgo2, fc io.Writer\n+\tf := creat(*objDir + \"_cgo_gotypes.go\")\n+\tdefer f.Close()\n+\tfgo2 = f\n+\tif *gccgo {\n+\t\tf := creat(*objDir + \"_cgo_defun.c\")\n+\t\tdefer f.Close()\n+\t\tfc = f\n+\t}\n \tfm := creat(*objDir + \"_cgo_main.c\")\n \n \tvar gccgoInit bytes.Buffer\n@@ -34,7 +41,7 @@ func (p *Package) writeDefs() {\n \t\tfmt.Fprintf(fflg, \"_CGO_%s=%s\\n\", k, strings.Join(v, \" \"))\n \t\tif k == \"LDFLAGS\" && !*gccgo {\n \t\t\tfor _, arg := range v {\n-\t\t\t\tfmt.Fprintf(fc, \"#pragma cgo_ldflag %q\\n\", arg)\n+\t\t\t\tfmt.Fprintf(fgo2, \"//go:cgo_ldflag %q\\n\", arg)\n \t\t\t}\n \t\t}\n \t}\n@@ -44,14 +51,17 @@ func (p *Package) writeDefs() {\n \tfmt.Fprintf(fm, \"int main() { return 0; }\\n\")\n \tif *importRuntimeCgo {\n \t\tfmt.Fprintf(fm, \"void crosscall2(void(*fn)(void*, int), void *a, int c) { }\\n\")\n+\t\tfmt.Fprintf(fm, \"void _cgo_wait_runtime_init_done() { }\\n\")\n \t\tfmt.Fprintf(fm, \"char* _cgo_topofstack(void) { return (char*)0; }\\n\")\n \t} else {\n \t\t// If we're not importing runtime/cgo, we *are* runtime/cgo,\n-\t\t// which provides crosscall2.  We just need a prototype.\n+\t\t// which provides these functions.  We just need a prototype.\n \t\tfmt.Fprintf(fm, \"void crosscall2(void(*fn)(void*, int), void *a, int c);\\n\")\n+\t\tfmt.Fprintf(fm, \"void _cgo_wait_runtime_init_done();\\n\")\n \t}\n \tfmt.Fprintf(fm, \"void _cgo_allocate(void *a, int c) { }\\n\")\n \tfmt.Fprintf(fm, \"void _cgo_panic(void *a, int c) { }\\n\")\n+\tfmt.Fprintf(fm, \"void _cgo_reginit(void) { }\\n\")\n \n \t// Write second Go output: definitions of _C_xxx.\n \t// In a separate file so that the import of \"unsafe\" does not\n@@ -68,6 +78,13 @@ func (p *Package) writeDefs() {\n \t}\n \tfmt.Fprintf(fgo2, \"func _Cgo_ptr(ptr unsafe.Pointer) unsafe.Pointer { return ptr }\\n\\n\")\n \n+\tif !*gccgo {\n+\t\tfmt.Fprintf(fgo2, \"//go:linkname _Cgo_always_false runtime.cgoAlwaysFalse\\n\")\n+\t\tfmt.Fprintf(fgo2, \"var _Cgo_always_false bool\\n\")\n+\t\tfmt.Fprintf(fgo2, \"//go:linkname _Cgo_use runtime.cgoUse\\n\")\n+\t\tfmt.Fprintf(fgo2, \"func _Cgo_use(interface{})\\n\")\n+\t}\n+\n \ttypedefNames := make([]string, 0, len(typedef))\n \tfor name := range typedef {\n \t\ttypedefNames = append(typedefNames, name)\n@@ -88,7 +105,6 @@ func (p *Package) writeDefs() {\n \tif *gccgo {\n \t\tfmt.Fprint(fc, p.cPrologGccgo())\n \t} else {\n-\t\tfmt.Fprint(fc, cProlog)\n \t\tfmt.Fprint(fgo2, goProlog)\n \t}\n \n@@ -102,44 +118,44 @@ func (p *Package) writeDefs() {\n \t\t}\n \n \t\tif !cVars[n.C] {\n-\t\t\tfmt.Fprintf(fm, \"extern char %s[];\\n\", n.C)\n-\t\t\tfmt.Fprintf(fm, \"void *_cgohack_%s = %s;\\n\\n\", n.C, n.C)\n-\n-\t\t\tif !*gccgo {\n-\t\t\t\tfmt.Fprintf(fc, \"#pragma cgo_import_static %s\\n\", n.C)\n+\t\t\tif *gccgo {\n+\t\t\t\tfmt.Fprintf(fc, \"extern byte *%s;\\n\", n.C)\n+\t\t\t} else {\n+\t\t\t\tfmt.Fprintf(fm, \"extern char %s[];\\n\", n.C)\n+\t\t\t\tfmt.Fprintf(fm, \"void *_cgohack_%s = %s;\\n\\n\", n.C, n.C)\n+\t\t\t\tfmt.Fprintf(fgo2, \"//go:linkname __cgo_%s %s\\n\", n.C, n.C)\n+\t\t\t\tfmt.Fprintf(fgo2, \"//go:cgo_import_static %s\\n\", n.C)\n+\t\t\t\tfmt.Fprintf(fgo2, \"var __cgo_%s byte\\n\", n.C)\n \t\t\t}\n-\n-\t\t\tfmt.Fprintf(fc, \"extern byte *%s;\\n\", n.C)\n-\n \t\t\tcVars[n.C] = true\n \t\t}\n-\t\tvar amp string\n+\n \t\tvar node ast.Node\n \t\tif n.Kind == \"var\" {\n-\t\t\tamp = \"&\"\n \t\t\tnode = &ast.StarExpr{X: n.Type.Go}\n \t\t} else if n.Kind == \"fpvar\" {\n \t\t\tnode = n.Type.Go\n-\t\t\tif *gccgo {\n-\t\t\t\tamp = \"&\"\n-\t\t\t}\n \t\t} else {\n \t\t\tpanic(fmt.Errorf(\"invalid var kind %q\", n.Kind))\n \t\t}\n \t\tif *gccgo {\n \t\t\tfmt.Fprintf(fc, `extern void *%s __asm__(\"%s.%s\");`, n.Mangle, gccgoSymbolPrefix, n.Mangle)\n-\t\t\tfmt.Fprintf(&gccgoInit, \"\\t%s = %s%s;\\n\", n.Mangle, amp, n.C)\n-\t\t} else {\n-\t\t\tfmt.Fprintf(fc, \"#pragma dataflag NOPTR /* C pointer, not heap pointer */ \\n\")\n-\t\t\tfmt.Fprintf(fc, \"void *\u00b7%s = %s%s;\\n\", n.Mangle, amp, n.C)\n+\t\t\tfmt.Fprintf(&gccgoInit, \"\\t%s = &%s;\\n\", n.Mangle, n.C)\n+\t\t\tfmt.Fprintf(fc, \"\\n\")\n \t\t}\n-\t\tfmt.Fprintf(fc, \"\\n\")\n \n \t\tfmt.Fprintf(fgo2, \"var %s \", n.Mangle)\n \t\tconf.Fprint(fgo2, fset, node)\n+\t\tif !*gccgo {\n+\t\t\tfmt.Fprintf(fgo2, \" = (\")\n+\t\t\tconf.Fprint(fgo2, fset, node)\n+\t\t\tfmt.Fprintf(fgo2, \")(unsafe.Pointer(&__cgo_%s))\", n.C)\n+\t\t}\n \t\tfmt.Fprintf(fgo2, \"\\n\")\n \t}\n-\tfmt.Fprintf(fc, \"\\n\")\n+\tif *gccgo {\n+\t\tfmt.Fprintf(fc, \"\\n\")\n+\t}\n \n \tfor _, key := range nameKeys(p.Name) {\n \t\tn := p.Name[key]\n@@ -152,14 +168,37 @@ func (p *Package) writeDefs() {\n \tfor _, key := range nameKeys(p.Name) {\n \t\tn := p.Name[key]\n \t\tif n.FuncType != nil {\n-\t\t\tp.writeDefsFunc(fc, fgo2, n)\n+\t\t\tp.writeDefsFunc(fgo2, n)\n \t\t}\n \t}\n \n+\tfgcc := creat(*objDir + \"_cgo_export.c\")\n+\tfgcch := creat(*objDir + \"_cgo_export.h\")\n \tif *gccgo {\n-\t\tp.writeGccgoExports(fgo2, fc, fm)\n+\t\tp.writeGccgoExports(fgo2, fm, fgcc, fgcch)\n \t} else {\n-\t\tp.writeExports(fgo2, fc, fm)\n+\t\tp.writeExports(fgo2, fm, fgcc, fgcch)\n+\t}\n+\tif err := fgcc.Close(); err != nil {\n+\t\tfatalf(\"%s\", err)\n+\t}\n+\tif err := fgcch.Close(); err != nil {\n+\t\tfatalf(\"%s\", err)\n+\t}\n+\n+\tif *exportHeader != \"\" && len(p.ExpFunc) > 0 {\n+\t\tfexp := creat(*exportHeader)\n+\t\tfgcch, err := os.Open(*objDir + \"_cgo_export.h\")\n+\t\tif err != nil {\n+\t\t\tfatalf(\"%s\", err)\n+\t\t}\n+\t\t_, err = io.Copy(fexp, fgcch)\n+\t\tif err != nil {\n+\t\t\tfatalf(\"%s\", err)\n+\t\t}\n+\t\tif err = fexp.Close(); err != nil {\n+\t\t\tfatalf(\"%s\", err)\n+\t\t}\n \t}\n \n \tinit := gccgoInit.String()\n@@ -169,9 +208,6 @@ func (p *Package) writeDefs() {\n \t\tfmt.Fprint(fc, init)\n \t\tfmt.Fprintln(fc, \"}\")\n \t}\n-\n-\tfgo2.Close()\n-\tfc.Close()\n }\n \n func dynimport(obj string) {\n@@ -184,13 +220,15 @@ func dynimport(obj string) {\n \t\tstdout = f\n \t}\n \n+\tfmt.Fprintf(stdout, \"package %s\\n\", *dynpackage)\n+\n \tif f, err := elf.Open(obj); err == nil {\n \t\tif *dynlinker {\n \t\t\t// Emit the cgo_dynamic_linker line.\n \t\t\tif sec := f.Section(\".interp\"); sec != nil {\n \t\t\t\tif data, err := sec.Data(); err == nil && len(data) > 1 {\n \t\t\t\t\t// skip trailing \\0 in data\n-\t\t\t\t\tfmt.Fprintf(stdout, \"#pragma cgo_dynamic_linker %q\\n\", string(data[:len(data)-1]))\n+\t\t\t\t\tfmt.Fprintf(stdout, \"//go:cgo_dynamic_linker %q\\n\", string(data[:len(data)-1]))\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -203,14 +241,14 @@ func dynimport(obj string) {\n \t\t\tif s.Version != \"\" {\n \t\t\t\ttarg += \"#\" + s.Version\n \t\t\t}\n-\t\t\tfmt.Fprintf(stdout, \"#pragma cgo_import_dynamic %s %s %q\\n\", s.Name, targ, s.Library)\n+\t\t\tfmt.Fprintf(stdout, \"//go:cgo_import_dynamic %s %s %q\\n\", s.Name, targ, s.Library)\n \t\t}\n \t\tlib, err := f.ImportedLibraries()\n \t\tif err != nil {\n \t\t\tfatalf(\"cannot load imported libraries from ELF file %s: %v\", obj, err)\n \t\t}\n \t\tfor _, l := range lib {\n-\t\t\tfmt.Fprintf(stdout, \"#pragma cgo_import_dynamic _ _ %q\\n\", l)\n+\t\t\tfmt.Fprintf(stdout, \"//go:cgo_import_dynamic _ _ %q\\n\", l)\n \t\t}\n \t\treturn\n \t}\n@@ -224,14 +262,14 @@ func dynimport(obj string) {\n \t\t\tif len(s) > 0 && s[0] == '_' {\n \t\t\t\ts = s[1:]\n \t\t\t}\n-\t\t\tfmt.Fprintf(stdout, \"#pragma cgo_import_dynamic %s %s %q\\n\", s, s, \"\")\n+\t\t\tfmt.Fprintf(stdout, \"//go:cgo_import_dynamic %s %s %q\\n\", s, s, \"\")\n \t\t}\n \t\tlib, err := f.ImportedLibraries()\n \t\tif err != nil {\n \t\t\tfatalf(\"cannot load imported libraries from Mach-O file %s: %v\", obj, err)\n \t\t}\n \t\tfor _, l := range lib {\n-\t\t\tfmt.Fprintf(stdout, \"#pragma cgo_import_dynamic _ _ %q\\n\", l)\n+\t\t\tfmt.Fprintf(stdout, \"//go:cgo_import_dynamic _ _ %q\\n\", l)\n \t\t}\n \t\treturn\n \t}\n@@ -244,18 +282,18 @@ func dynimport(obj string) {\n \t\tfor _, s := range sym {\n \t\t\tss := strings.Split(s, \":\")\n \t\t\tname := strings.Split(ss[0], \"@\")[0]\n-\t\t\tfmt.Fprintf(stdout, \"#pragma cgo_import_dynamic %s %s %q\\n\", name, ss[0], strings.ToLower(ss[1]))\n+\t\t\tfmt.Fprintf(stdout, \"//go:cgo_import_dynamic %s %s %q\\n\", name, ss[0], strings.ToLower(ss[1]))\n \t\t}\n \t\treturn\n \t}\n \n \tfatalf(\"cannot parse %s as ELF, Mach-O or PE\", obj)\n }\n \n-// Construct a gcc struct matching the 6c argument frame.\n+// Construct a gcc struct matching the gc argument frame.\n // Assumes that in gcc, char is 1 byte, short 2 bytes, int 4 bytes, long long 8 bytes.\n // These assumptions are checked by the gccProlog.\n-// Also assumes that 6c convention is to word-align the\n+// Also assumes that gc convention is to word-align the\n // input and output parameters.\n func (p *Package) structType(n *Name) (string, int64) {\n \tvar buf bytes.Buffer\n@@ -304,7 +342,7 @@ func (p *Package) structType(n *Name) (string, int64) {\n \treturn buf.String(), off\n }\n \n-func (p *Package) writeDefsFunc(fc, fgo2 *os.File, n *Name) {\n+func (p *Package) writeDefsFunc(fgo2 io.Writer, n *Name) {\n \tname := n.Go\n \tgtype := n.FuncType.Go\n \tvoid := gtype.Results == nil || len(gtype.Results.List) == 0\n@@ -396,11 +434,11 @@ func (p *Package) writeDefsFunc(fc, fgo2 *os.File, n *Name) {\n \t\treturn\n \t}\n \n-\t// C wrapper calls into gcc, passing a pointer to the argument frame.\n-\tfmt.Fprintf(fc, \"#pragma cgo_import_static %s\\n\", cname)\n-\tfmt.Fprintf(fc, \"void %s(void*);\\n\", cname)\n-\tfmt.Fprintf(fc, \"#pragma dataflag NOPTR\\n\")\n-\tfmt.Fprintf(fc, \"void *\u00b7%s = %s;\\n\", cname, cname)\n+\t// Wrapper calls into gcc, passing a pointer to the argument frame.\n+\tfmt.Fprintf(fgo2, \"//go:cgo_import_static %s\\n\", cname)\n+\tfmt.Fprintf(fgo2, \"//go:linkname __cgofn_%s %s\\n\", cname, cname)\n+\tfmt.Fprintf(fgo2, \"var __cgofn_%s byte\\n\", cname)\n+\tfmt.Fprintf(fgo2, \"var %s = unsafe.Pointer(&__cgofn_%s)\\n\", cname, cname)\n \n \tnret := 0\n \tif !void {\n@@ -412,7 +450,6 @@ func (p *Package) writeDefsFunc(fc, fgo2 *os.File, n *Name) {\n \t}\n \n \tfmt.Fprint(fgo2, \"\\n\")\n-\tfmt.Fprintf(fgo2, \"var %s unsafe.Pointer\\n\", cname)\n \tconf.Fprint(fgo2, fset, d)\n \tfmt.Fprint(fgo2, \" {\\n\")\n \n@@ -428,16 +465,20 @@ func (p *Package) writeDefsFunc(fc, fgo2 *os.File, n *Name) {\n \tif n.AddError {\n \t\tprefix = \"errno := \"\n \t}\n-\tfmt.Fprintf(fgo2, \"\\t%s_cgo_runtime_cgocall_errno(%s, %s)\\n\", prefix, cname, arg)\n+\tfmt.Fprintf(fgo2, \"\\t%s_cgo_runtime_cgocall(%s, %s)\\n\", prefix, cname, arg)\n \tif n.AddError {\n \t\tfmt.Fprintf(fgo2, \"\\tif errno != 0 { r2 = syscall.Errno(errno) }\\n\")\n \t}\n+\tfmt.Fprintf(fgo2, \"\\tif _Cgo_always_false {\\n\")\n+\tfor i := range d.Type.Params.List {\n+\t\tfmt.Fprintf(fgo2, \"\\t\\t_Cgo_use(p%d)\\n\", i)\n+\t}\n+\tfmt.Fprintf(fgo2, \"\\t}\\n\")\n \tfmt.Fprintf(fgo2, \"\\treturn\\n\")\n \tfmt.Fprintf(fgo2, \"}\\n\")\n }\n \n-// writeOutput creates stubs for a specific source file to be compiled by 6g\n-// (The comments here say 6g and 6c but the code applies to the 8 and 5 tools too.)\n+// writeOutput creates stubs for a specific source file to be compiled by gc\n func (p *Package) writeOutput(f *File, srcfile string) {\n \tbase := srcfile\n \tif strings.HasSuffix(base, \".go\") {\n@@ -454,7 +495,7 @@ func (p *Package) writeOutput(f *File, srcfile string) {\n \tfmt.Fprintf(fgo1, \"// Created by cgo - DO NOT EDIT\\n\\n\")\n \tconf.Fprint(fgo1, fset, f.AST)\n \n-\t// While we process the vars and funcs, also write 6c and gcc output.\n+\t// While we process the vars and funcs, also write gcc output.\n \t// Gcc output starts with the preamble.\n \tfmt.Fprintf(fgcc, \"%s\\n\", f.Preamble)\n \tfmt.Fprintf(fgcc, \"%s\\n\", gccProlog)\n@@ -516,7 +557,7 @@ func (p *Package) writeOutputFunc(fgcc *os.File, n *Name) {\n \tif n.AddError {\n \t\tfmt.Fprintf(fgcc, \"\\terrno = 0;\\n\")\n \t}\n-\t// We're trying to write a gcc struct that matches 6c/8c/5c's layout.\n+\t// We're trying to write a gcc struct that matches gc's layout.\n \t// Use packed attribute to force no padding in this struct in case\n \t// gcc has different packing requirements.\n \tfmt.Fprintf(fgcc, \"\\t%s %v *a = v;\\n\", ctype, p.packedAttribute())\n@@ -612,37 +653,33 @@ func (p *Package) writeGccgoOutputFunc(fgcc *os.File, n *Name) {\n }\n \n // packedAttribute returns host compiler struct attribute that will be\n-// used to match 6c/8c/5c's struct layout. For example, on 386 Windows,\n-// gcc wants to 8-align int64s, but 8c does not.\n+// used to match gc's struct layout. For example, on 386 Windows,\n+// gcc wants to 8-align int64s, but gc does not.\n // Use __gcc_struct__ to work around http://gcc.gnu.org/PR52991 on x86,\n-// and http://golang.org/issue/5603.\n+// and https://golang.org/issue/5603.\n func (p *Package) packedAttribute() string {\n \ts := \"__attribute__((__packed__\"\n-\tif !strings.Contains(p.gccBaseCmd()[0], \"clang\") && (goarch == \"amd64\" || goarch == \"386\") {\n+\tif !p.GccIsClang && (goarch == \"amd64\" || goarch == \"386\") {\n \t\ts += \", __gcc_struct__\"\n \t}\n \treturn s + \"))\"\n }\n \n // Write out the various stubs we need to support functions exported\n // from Go so that they are callable from C.\n-func (p *Package) writeExports(fgo2, fc, fm *os.File) {\n-\tfgcc := creat(*objDir + \"_cgo_export.c\")\n-\tfgcch := creat(*objDir + \"_cgo_export.h\")\n-\n-\tfmt.Fprintf(fgcch, \"/* Created by cgo - DO NOT EDIT. */\\n\")\n-\tfmt.Fprintf(fgcch, \"%s\\n\", p.Preamble)\n-\tfmt.Fprintf(fgcch, \"%s\\n\", p.gccExportHeaderProlog())\n+func (p *Package) writeExports(fgo2, fm, fgcc, fgcch io.Writer) {\n+\tp.writeExportHeader(fgcch)\n \n \tfmt.Fprintf(fgcc, \"/* Created by cgo - DO NOT EDIT. */\\n\")\n-\tfmt.Fprintf(fgcc, \"#include \\\"_cgo_export.h\\\"\\n\")\n+\tfmt.Fprintf(fgcc, \"#include \\\"_cgo_export.h\\\"\\n\\n\")\n \n-\tfmt.Fprintf(fgcc, \"\\nextern void crosscall2(void (*fn)(void *, int), void *, int);\\n\\n\")\n+\tfmt.Fprintf(fgcc, \"extern void crosscall2(void (*fn)(void *, int), void *, int);\\n\")\n+\tfmt.Fprintf(fgcc, \"extern void _cgo_wait_runtime_init_done();\\n\\n\")\n \n \tfor _, exp := range p.ExpFunc {\n \t\tfn := exp.Func\n \n-\t\t// Construct a gcc struct matching the 6c argument and\n+\t\t// Construct a gcc struct matching the gc argument and\n \t\t// result frame.  The gcc struct will be compiled with\n \t\t// __attribute__((packed)) so all padding must be accounted\n \t\t// for explicitly.\n@@ -728,11 +765,16 @@ func (p *Package) writeExports(fgo2, fc, fm *os.File) {\n \t\t\t\ts += fmt.Sprintf(\"%s p%d\", p.cgoType(atype).C, i)\n \t\t\t})\n \t\ts += \")\"\n+\n+\t\tif len(exp.Doc) > 0 {\n+\t\t\tfmt.Fprintf(fgcch, \"\\n%s\", exp.Doc)\n+\t\t}\n \t\tfmt.Fprintf(fgcch, \"\\nextern %s;\\n\", s)\n \n \t\tfmt.Fprintf(fgcc, \"extern void _cgoexp%s_%s(void *, int);\\n\", cPrefix, exp.ExpName)\n \t\tfmt.Fprintf(fgcc, \"\\n%s\\n\", s)\n \t\tfmt.Fprintf(fgcc, \"{\\n\")\n+\t\tfmt.Fprintf(fgcc, \"\\t_cgo_wait_runtime_init_done();\\n\")\n \t\tfmt.Fprintf(fgcc, \"\\t%s %v a;\\n\", ctype, p.packedAttribute())\n \t\tif gccResult != \"void\" && (len(fntype.Results.List) > 1 || len(fntype.Results.List[0].Names) > 1) {\n \t\t\tfmt.Fprintf(fgcc, \"\\t%s r;\\n\", gccResult)\n@@ -758,20 +800,21 @@ func (p *Package) writeExports(fgo2, fc, fm *os.File) {\n \t\t}\n \t\tfmt.Fprintf(fgcc, \"}\\n\")\n \n-\t\t// Build the wrapper function compiled by 6c/8c\n+\t\t// Build the wrapper function compiled by gc.\n \t\tgoname := exp.Func.Name.Name\n \t\tif fn.Recv != nil {\n \t\t\tgoname = \"_cgoexpwrap\" + cPrefix + \"_\" + fn.Recv.List[0].Names[0].Name + \"_\" + goname\n \t\t}\n-\t\tfmt.Fprintf(fc, \"#pragma cgo_export_dynamic %s\\n\", goname)\n-\t\tfmt.Fprintf(fc, \"extern void \u00b7%s();\\n\\n\", goname)\n-\t\tfmt.Fprintf(fc, \"#pragma cgo_export_static _cgoexp%s_%s\\n\", cPrefix, exp.ExpName)\n-\t\tfmt.Fprintf(fc, \"#pragma textflag 7\\n\") // no split stack, so no use of m or g\n-\t\tfmt.Fprintf(fc, \"void\\n\")\n-\t\tfmt.Fprintf(fc, \"_cgoexp%s_%s(void *a, int32 n)\\n\", cPrefix, exp.ExpName)\n-\t\tfmt.Fprintf(fc, \"{\\n\")\n-\t\tfmt.Fprintf(fc, \"\\truntime\u00b7cgocallback(\u00b7%s, a, n);\\n\", goname)\n-\t\tfmt.Fprintf(fc, \"}\\n\")\n+\t\tfmt.Fprintf(fgo2, \"//go:cgo_export_dynamic %s\\n\", goname)\n+\t\tfmt.Fprintf(fgo2, \"//go:linkname _cgoexp%s_%s _cgoexp%s_%s\\n\", cPrefix, exp.ExpName, cPrefix, exp.ExpName)\n+\t\tfmt.Fprintf(fgo2, \"//go:cgo_export_static _cgoexp%s_%s\\n\", cPrefix, exp.ExpName)\n+\t\tfmt.Fprintf(fgo2, \"//go:nosplit\\n\") // no split stack, so no use of m or g\n+\t\tfmt.Fprintf(fgo2, \"//go:norace\\n\")  // must not have race detector calls inserted\n+\t\tfmt.Fprintf(fgo2, \"func _cgoexp%s_%s(a unsafe.Pointer, n int32) {\", cPrefix, exp.ExpName)\n+\t\tfmt.Fprintf(fgo2, \"\\tfn := %s\\n\", goname)\n+\t\t// The indirect here is converting from a Go function pointer to a C function pointer.\n+\t\tfmt.Fprintf(fgo2, \"\\t_cgo_runtime_cgocallback(**(**unsafe.Pointer)(unsafe.Pointer(&fn)), a, uintptr(n));\\n\")\n+\t\tfmt.Fprintf(fgo2, \"}\\n\")\n \n \t\tfmt.Fprintf(fm, \"int _cgoexp%s_%s;\\n\", cPrefix, exp.ExpName)\n \n@@ -814,23 +857,20 @@ func (p *Package) writeExports(fgo2, fc, fm *os.File) {\n \t\t\tfmt.Fprint(fgo2, \"}\\n\")\n \t\t}\n \t}\n+\n+\tfmt.Fprintf(fgcch, \"%s\", gccExportHeaderEpilog)\n }\n \n // Write out the C header allowing C code to call exported gccgo functions.\n-func (p *Package) writeGccgoExports(fgo2, fc, fm *os.File) {\n-\tfgcc := creat(*objDir + \"_cgo_export.c\")\n-\tfgcch := creat(*objDir + \"_cgo_export.h\")\n-\n+func (p *Package) writeGccgoExports(fgo2, fm, fgcc, fgcch io.Writer) {\n \tgccgoSymbolPrefix := p.gccgoSymbolPrefix()\n \n-\tfmt.Fprintf(fgcch, \"/* Created by cgo - DO NOT EDIT. */\\n\")\n-\tfmt.Fprintf(fgcch, \"%s\\n\", p.Preamble)\n-\tfmt.Fprintf(fgcch, \"%s\\n\", p.gccExportHeaderProlog())\n+\tp.writeExportHeader(fgcch)\n \n \tfmt.Fprintf(fgcc, \"/* Created by cgo - DO NOT EDIT. */\\n\")\n \tfmt.Fprintf(fgcc, \"#include \\\"_cgo_export.h\\\"\\n\")\n \n-\tfmt.Fprintf(fm, \"#include \\\"_cgo_export.h\\\"\\n\")\n+\tfmt.Fprintf(fgcc, \"%s\\n\", gccgoExportFileProlog)\n \n \tfor _, exp := range p.ExpFunc {\n \t\tfn := exp.Func\n@@ -851,6 +891,7 @@ func (p *Package) writeGccgoExports(fgo2, fc, fm *os.File) {\n \t\t\t\t})\n \t\tdefault:\n \t\t\t// Declare a result struct.\n+\t\t\tfmt.Fprintf(fgcch, \"\\n/* Return type for %s */\\n\", exp.ExpName)\n \t\t\tfmt.Fprintf(fgcch, \"struct %s_result {\\n\", exp.ExpName)\n \t\t\tforFieldList(fntype.Results,\n \t\t\t\tfunc(i int, atype ast.Expr) {\n@@ -880,6 +921,10 @@ func (p *Package) writeGccgoExports(fgo2, fc, fm *os.File) {\n \t\tfmt.Fprintf(cdeclBuf, \")\")\n \t\tcParams := cdeclBuf.String()\n \n+\t\tif len(exp.Doc) > 0 {\n+\t\t\tfmt.Fprintf(fgcch, \"\\n%s\", exp.Doc)\n+\t\t}\n+\n \t\t// We need to use a name that will be exported by the\n \t\t// Go code; otherwise gccgo will make it static and we\n \t\t// will not be able to link against it from the C\n@@ -900,6 +945,8 @@ func (p *Package) writeGccgoExports(fgo2, fc, fm *os.File) {\n \n \t\tfmt.Fprint(fgcc, \"\\n\")\n \t\tfmt.Fprintf(fgcc, \"%s %s %s {\\n\", cRet, exp.ExpName, cParams)\n+\t\tfmt.Fprintf(fgcc, \"\\tif(_cgo_wait_runtime_init_done)\\n\")\n+\t\tfmt.Fprintf(fgcc, \"\\t\\t_cgo_wait_runtime_init_done();\\n\")\n \t\tfmt.Fprint(fgcc, \"\\t\")\n \t\tif resultCount > 0 {\n \t\t\tfmt.Fprint(fgcc, \"return \")\n@@ -919,7 +966,8 @@ func (p *Package) writeGccgoExports(fgo2, fc, fm *os.File) {\n \t\tfmt.Fprint(fgcc, \"}\\n\")\n \n \t\t// Dummy declaration for _cgo_main.c\n-\t\tfmt.Fprintf(fm, \"%s %s %s {}\\n\", cRet, goName, cParams)\n+\t\tfmt.Fprintf(fm, `char %s[1] __asm__(\"%s.%s\");`, goName, gccgoSymbolPrefix, goName)\n+\t\tfmt.Fprint(fm, \"\\n\")\n \n \t\t// For gccgo we use a wrapper function in Go, in order\n \t\t// to call CgocallBack and CgocallBackDone.\n@@ -974,6 +1022,24 @@ func (p *Package) writeGccgoExports(fgo2, fc, fm *os.File) {\n \t\tfmt.Fprint(fgo2, \")\\n\")\n \t\tfmt.Fprint(fgo2, \"}\\n\")\n \t}\n+\n+\tfmt.Fprintf(fgcch, \"%s\", gccExportHeaderEpilog)\n+}\n+\n+// writeExportHeader writes out the start of the _cgo_export.h file.\n+func (p *Package) writeExportHeader(fgcch io.Writer) {\n+\tfmt.Fprintf(fgcch, \"/* Created by \\\"go tool cgo\\\" - DO NOT EDIT. */\\n\\n\")\n+\tpkg := *importPath\n+\tif pkg == \"\" {\n+\t\tpkg = p.PackagePath\n+\t}\n+\tfmt.Fprintf(fgcch, \"/* package %s */\\n\\n\", pkg)\n+\n+\tfmt.Fprintf(fgcch, \"/* Start of preamble from import \\\"C\\\" comments.  */\\n\\n\")\n+\tfmt.Fprintf(fgcch, \"%s\\n\", p.Preamble)\n+\tfmt.Fprintf(fgcch, \"\\n/* End of preamble from import \\\"C\\\" comments.  */\\n\\n\")\n+\n+\tfmt.Fprintf(fgcch, \"%s\\n\", p.gccExportHeaderProlog())\n }\n \n // Return the package prefix when using gccgo.\n@@ -1164,60 +1230,39 @@ char *CString(_GoString_);\n void *_CMalloc(size_t);\n `\n \n-const cProlog = `\n-#include \"runtime.h\"\n-#include \"cgocall.h\"\n-#include \"textflag.h\"\n-\n-#pragma dataflag NOPTR\n-static void *cgocall_errno = runtime\u00b7cgocall_errno;\n-#pragma dataflag NOPTR\n-void *\u00b7_cgo_runtime_cgocall_errno = &cgocall_errno;\n-\n-#pragma dataflag NOPTR\n-static void *runtime_gostring = runtime\u00b7gostring;\n-#pragma dataflag NOPTR\n-void *\u00b7_cgo_runtime_gostring = &runtime_gostring;\n-\n-#pragma dataflag NOPTR\n-static void *runtime_gostringn = runtime\u00b7gostringn;\n-#pragma dataflag NOPTR\n-void *\u00b7_cgo_runtime_gostringn = &runtime_gostringn;\n-\n-#pragma dataflag NOPTR\n-static void *runtime_gobytes = runtime\u00b7gobytes;\n-#pragma dataflag NOPTR\n-void *\u00b7_cgo_runtime_gobytes = &runtime_gobytes;\n-\n-#pragma dataflag NOPTR\n-static void *runtime_cmalloc = runtime\u00b7cmalloc;\n-#pragma dataflag NOPTR\n-void *\u00b7_cgo_runtime_cmalloc = &runtime_cmalloc;\n-\n-void \u00b7_Cerrno(void*, int32);\n-`\n-\n const goProlog = `\n-var _cgo_runtime_cgocall_errno func(unsafe.Pointer, uintptr) int32\n-var _cgo_runtime_cmalloc func(uintptr) unsafe.Pointer\n+//go:linkname _cgo_runtime_cgocall runtime.cgocall\n+func _cgo_runtime_cgocall(unsafe.Pointer, uintptr) int32\n+\n+//go:linkname _cgo_runtime_cmalloc runtime.cmalloc\n+func _cgo_runtime_cmalloc(uintptr) unsafe.Pointer\n+\n+//go:linkname _cgo_runtime_cgocallback runtime.cgocallback\n+func _cgo_runtime_cgocallback(unsafe.Pointer, unsafe.Pointer, uintptr)\n `\n \n const goStringDef = `\n-var _cgo_runtime_gostring func(*_Ctype_char) string\n+//go:linkname _cgo_runtime_gostring runtime.gostring\n+func _cgo_runtime_gostring(*_Ctype_char) string\n+\n func _Cfunc_GoString(p *_Ctype_char) string {\n \treturn _cgo_runtime_gostring(p)\n }\n `\n \n const goStringNDef = `\n-var _cgo_runtime_gostringn func(*_Ctype_char, int) string\n+//go:linkname _cgo_runtime_gostringn runtime.gostringn\n+func _cgo_runtime_gostringn(*_Ctype_char, int) string\n+\n func _Cfunc_GoStringN(p *_Ctype_char, l _Ctype_int) string {\n \treturn _cgo_runtime_gostringn(p, int(l))\n }\n `\n \n const goBytesDef = `\n-var _cgo_runtime_gobytes func(unsafe.Pointer, int) []byte\n+//go:linkname _cgo_runtime_gobytes runtime.gobytes\n+func _cgo_runtime_gobytes(unsafe.Pointer, int) []byte\n+\n func _Cfunc_GoBytes(p unsafe.Pointer, l _Ctype_int) []byte {\n \treturn _cgo_runtime_gobytes(p, int(l))\n }\n@@ -1310,6 +1355,11 @@ func (p *Package) gccExportHeaderProlog() string {\n }\n \n const gccExportHeaderProlog = `\n+/* Start of boilerplate cgo prologue.  */\n+\n+#ifndef GO_CGO_PROLOGUE_H\n+#define GO_CGO_PROLOGUE_H\n+\n typedef signed char GoInt8;\n typedef unsigned char GoUint8;\n typedef short GoInt16;\n@@ -1326,9 +1376,44 @@ typedef double GoFloat64;\n typedef __complex float GoComplex64;\n typedef __complex double GoComplex128;\n \n+// static assertion to make sure the file is being used on architecture\n+// at least with matching size of GoInt.\n+typedef char _check_for_GOINTBITS_bit_pointer_matching_GoInt[sizeof(void*)==GOINTBITS/8 ? 1:-1];\n+\n typedef struct { char *p; GoInt n; } GoString;\n typedef void *GoMap;\n typedef void *GoChan;\n typedef struct { void *t; void *v; } GoInterface;\n typedef struct { void *data; GoInt len; GoInt cap; } GoSlice;\n+\n+#endif\n+\n+/* End of boilerplate cgo prologue.  */\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+`\n+\n+// gccExportHeaderEpilog goes at the end of the generated header file.\n+const gccExportHeaderEpilog = `\n+#ifdef __cplusplus\n+}\n+#endif\n+`\n+\n+// gccgoExportFileProlog is written to the _cgo_export.c file when\n+// using gccgo.\n+// We use weak declarations, and test the addresses, so that this code\n+// works with older versions of gccgo.\n+const gccgoExportFileProlog = `\n+extern _Bool runtime_iscgo __attribute__ ((weak));\n+\n+static void GoInit(void) __attribute__ ((constructor));\n+static void GoInit(void) {\n+\tif(&runtime_iscgo)\n+\t\truntime_iscgo = 1;\n+}\n+\n+extern void _cgo_wait_runtime_init_done() __attribute__ ((weak));\n `"}, {"sha": "3adb8e87836c21adc289b70711ebfbb326370b81", "filename": "libgo/go/cmd/cgo/util.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fcgo%2Futil.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fcgo%2Futil.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Futil.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -55,7 +55,7 @@ func error_(pos token.Pos, msg string, args ...interface{}) {\n \tfmt.Fprintf(os.Stderr, \"\\n\")\n }\n \n-// isName returns true if s is a valid C identifier\n+// isName reports whether s is a valid C identifier\n func isName(s string) bool {\n \tfor i, v := range s {\n \t\tif v != '_' && (v < 'A' || v > 'Z') && (v < 'a' || v > 'z') && (v < '0' || v > '9') {"}, {"sha": "6077d93a436f4a440bdb9b955095625900ef90b9", "filename": "libgo/go/cmd/go/alldocs.go", "status": "added", "additions": 1482, "deletions": 0, "changes": 1482, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -0,0 +1,1482 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// DO NOT EDIT THIS FILE. GENERATED BY mkalldocs.sh.\n+// Edit the documentation in other files and rerun mkalldocs.sh to generate this one.\n+\n+/*\n+Go is a tool for managing Go source code.\n+\n+Usage:\n+\n+\tgo command [arguments]\n+\n+The commands are:\n+\n+\tbuild       compile packages and dependencies\n+\tclean       remove object files\n+\tdoc         show documentation for package or symbol\n+\tenv         print Go environment information\n+\tfix         run go tool fix on packages\n+\tfmt         run gofmt on package sources\n+\tgenerate    generate Go files by processing source\n+\tget         download and install packages and dependencies\n+\tinstall     compile and install packages and dependencies\n+\tlist        list packages\n+\trun         compile and run Go program\n+\ttest        test packages\n+\ttool        run specified go tool\n+\tversion     print Go version\n+\tvet         run go tool vet on packages\n+\n+Use \"go help [command]\" for more information about a command.\n+\n+Additional help topics:\n+\n+\tc           calling between Go and C\n+\tbuildmode   description of build modes\n+\tfiletype    file types\n+\tgopath      GOPATH environment variable\n+\tenvironment environment variables\n+\timportpath  import path syntax\n+\tpackages    description of package lists\n+\ttestflag    description of testing flags\n+\ttestfunc    description of testing functions\n+\n+Use \"go help [topic]\" for more information about that topic.\n+\n+\n+Compile packages and dependencies\n+\n+Usage:\n+\n+\tgo build [-o output] [-i] [build flags] [packages]\n+\n+Build compiles the packages named by the import paths,\n+along with their dependencies, but it does not install the results.\n+\n+If the arguments to build are a list of .go files, build treats\n+them as a list of source files specifying a single package.\n+\n+When compiling a single main package, build writes\n+the resulting executable to an output file named after\n+the first source file ('go build ed.go rx.go' writes 'ed' or 'ed.exe')\n+or the source code directory ('go build unix/sam' writes 'sam' or 'sam.exe').\n+The '.exe' suffix is added when writing a Windows executable.\n+\n+When compiling multiple packages or a single non-main package,\n+build compiles the packages but discards the resulting object,\n+serving only as a check that the packages can be built.\n+\n+The -o flag, only allowed when compiling a single package,\n+forces build to write the resulting executable or object\n+to the named output file, instead of the default behavior described\n+in the last two paragraphs.\n+\n+The -i flag installs the packages that are dependencies of the target.\n+\n+The build flags are shared by the build, clean, get, install, list, run,\n+and test commands:\n+\n+\t-a\n+\t\tforce rebuilding of packages that are already up-to-date.\n+\t\tIn Go releases, does not apply to the standard library.\n+\t-n\n+\t\tprint the commands but do not run them.\n+\t-p n\n+\t\tthe number of builds that can be run in parallel.\n+\t\tThe default is the number of CPUs available, except\n+\t\ton darwin/arm which defaults to 1.\n+\t-race\n+\t\tenable data race detection.\n+\t\tSupported only on linux/amd64, freebsd/amd64, darwin/amd64 and windows/amd64.\n+\t-v\n+\t\tprint the names of packages as they are compiled.\n+\t-work\n+\t\tprint the name of the temporary work directory and\n+\t\tdo not delete it when exiting.\n+\t-x\n+\t\tprint the commands.\n+\n+\t-asmflags 'flag list'\n+\t\targuments to pass on each go tool asm invocation.\n+\t-buildmode mode\n+\t\tbuild mode to use. See 'go help buildmode' for more.\n+\t-compiler name\n+\t\tname of compiler to use, as in runtime.Compiler (gccgo or gc).\n+\t-gccgoflags 'arg list'\n+\t\targuments to pass on each gccgo compiler/linker invocation.\n+\t-gcflags 'arg list'\n+\t\targuments to pass on each go tool compile invocation.\n+\t-installsuffix suffix\n+\t\ta suffix to use in the name of the package installation directory,\n+\t\tin order to keep output separate from default builds.\n+\t\tIf using the -race flag, the install suffix is automatically set to race\n+\t\tor, if set explicitly, has _race appended to it.  Using a -buildmode\n+\t\toption that requires non-default compile flags has a similar effect.\n+\t-ldflags 'flag list'\n+\t\targuments to pass on each go tool link invocation.\n+\t-linkshared\n+\t\tlink against shared libraries previously created with\n+\t\t-buildmode=shared\n+\t-pkgdir dir\n+\t\tinstall and load all packages from dir instead of the usual locations.\n+\t\tFor example, when building with a non-standard configuration,\n+\t\tuse -pkgdir to keep generated packages in a separate location.\n+\t-tags 'tag list'\n+\t\ta list of build tags to consider satisfied during the build.\n+\t\tFor more information about build tags, see the description of\n+\t\tbuild constraints in the documentation for the go/build package.\n+\t-toolexec 'cmd args'\n+\t\ta program to use to invoke toolchain programs like vet and asm.\n+\t\tFor example, instead of running asm, the go command will run\n+\t\t'cmd args /path/to/asm <arguments for asm>'.\n+\n+The list flags accept a space-separated list of strings. To embed spaces\n+in an element in the list, surround it with either single or double quotes.\n+\n+For more about specifying packages, see 'go help packages'.\n+For more about where packages and binaries are installed,\n+run 'go help gopath'.\n+For more about calling between Go and C/C++, run 'go help c'.\n+\n+Note: Build adheres to certain conventions such as those described\n+by 'go help gopath'. Not all projects can follow these conventions,\n+however. Installations that have their own conventions or that use\n+a separate software build system may choose to use lower-level\n+invocations such as 'go tool compile' and 'go tool link' to avoid\n+some of the overheads and design decisions of the build tool.\n+\n+See also: go install, go get, go clean.\n+\n+\n+Remove object files\n+\n+Usage:\n+\n+\tgo clean [-i] [-r] [-n] [-x] [build flags] [packages]\n+\n+Clean removes object files from package source directories.\n+The go command builds most objects in a temporary directory,\n+so go clean is mainly concerned with object files left by other\n+tools or by manual invocations of go build.\n+\n+Specifically, clean removes the following files from each of the\n+source directories corresponding to the import paths:\n+\n+\t_obj/            old object directory, left from Makefiles\n+\t_test/           old test directory, left from Makefiles\n+\t_testmain.go     old gotest file, left from Makefiles\n+\ttest.out         old test log, left from Makefiles\n+\tbuild.out        old test log, left from Makefiles\n+\t*.[568ao]        object files, left from Makefiles\n+\n+\tDIR(.exe)        from go build\n+\tDIR.test(.exe)   from go test -c\n+\tMAINFILE(.exe)   from go build MAINFILE.go\n+\t*.so             from SWIG\n+\n+In the list, DIR represents the final path element of the\n+directory, and MAINFILE is the base name of any Go source\n+file in the directory that is not included when building\n+the package.\n+\n+The -i flag causes clean to remove the corresponding installed\n+archive or binary (what 'go install' would create).\n+\n+The -n flag causes clean to print the remove commands it would execute,\n+but not run them.\n+\n+The -r flag causes clean to be applied recursively to all the\n+dependencies of the packages named by the import paths.\n+\n+The -x flag causes clean to print remove commands as it executes them.\n+\n+For more about build flags, see 'go help build'.\n+\n+For more about specifying packages, see 'go help packages'.\n+\n+\n+Show documentation for package or symbol\n+\n+Usage:\n+\n+\tgo doc [-u] [-c] [package|[package.]symbol[.method]]\n+\n+Doc prints the documentation comments associated with the item identified by its\n+arguments (a package, const, func, type, var, or method) followed by a one-line\n+summary of each of the first-level items \"under\" that item (package-level\n+declarations for a package, methods for a type, etc.).\n+\n+Doc accepts zero, one, or two arguments.\n+\n+Given no arguments, that is, when run as\n+\n+\tgo doc\n+\n+it prints the package documentation for the package in the current directory.\n+If the package is a command (package main), the exported symbols of the package\n+are elided from the presentation unless the -cmd flag is provided.\n+\n+When run with one argument, the argument is treated as a Go-syntax-like\n+representation of the item to be documented. What the argument selects depends\n+on what is installed in GOROOT and GOPATH, as well as the form of the argument,\n+which is schematically one of these:\n+\n+\tgo doc <pkg>\n+\tgo doc <sym>[.<method>]\n+\tgo doc [<pkg>].<sym>[.<method>]\n+\n+The first item in this list matched by the argument is the one whose\n+documentation is printed. (See the examples below.) For packages, the order of\n+scanning is determined lexically, but the GOROOT tree is always scanned before\n+GOPATH.\n+\n+If there is no package specified or matched, the package in the current\n+directory is selected, so \"go doc Foo\" shows the documentation for symbol Foo in\n+the current package.\n+\n+The package path must be either a qualified path or a proper suffix of a\n+path. The go tool's usual package mechanism does not apply: package path\n+elements like . and ... are not implemented by go doc.\n+\n+When run with two arguments, the first must be a full package path (not just a\n+suffix), and the second is a symbol or symbol and method; this is similar to the\n+syntax accepted by godoc:\n+\n+\tgo doc <pkg> <sym>[.<method>]\n+\n+In all forms, when matching symbols, lower-case letters in the argument match\n+either case but upper-case letters match exactly. This means that there may be\n+multiple matches of a lower-case argument in a package if different symbols have\n+different cases. If this occurs, documentation for all matches is printed.\n+\n+Examples:\n+\tgo doc\n+\t\tShow documentation for current package.\n+\tgo doc Foo\n+\t\tShow documentation for Foo in the current package.\n+\t\t(Foo starts with a capital letter so it cannot match\n+\t\ta package path.)\n+\tgo doc encoding/json\n+\t\tShow documentation for the encoding/json package.\n+\tgo doc json\n+\t\tShorthand for encoding/json.\n+\tgo doc json.Number (or go doc json.number)\n+\t\tShow documentation and method summary for json.Number.\n+\tgo doc json.Number.Int64 (or go doc json.number.int64)\n+\t\tShow documentation for json.Number's Int64 method.\n+\tgo doc cmd/doc\n+\t\tShow package docs for the doc command.\n+\tgo doc -cmd cmd/doc\n+\t\tShow package docs and exported symbols within the doc command.\n+\tgo doc template.new\n+\t\tShow documentation for html/template's New function.\n+\t\t(html/template is lexically before text/template)\n+\tgo doc text/template.new # One argument\n+\t\tShow documentation for text/template's New function.\n+\tgo doc text/template new # Two arguments\n+\t\tShow documentation for text/template's New function.\n+\n+Flags:\n+\t-c\n+\t\tRespect case when matching symbols.\n+\t-cmd\n+\t\tTreat a command (package main) like a regular package.\n+\t\tOtherwise package main's exported symbols are hidden\n+\t\twhen showing the package's top-level documentation.\n+\t-u\n+\t\tShow documentation for unexported as well as exported\n+\t\tsymbols and methods.\n+\n+\n+Print Go environment information\n+\n+Usage:\n+\n+\tgo env [var ...]\n+\n+Env prints Go environment information.\n+\n+By default env prints information as a shell script\n+(on Windows, a batch file).  If one or more variable\n+names is given as arguments,  env prints the value of\n+each named variable on its own line.\n+\n+\n+Run go tool fix on packages\n+\n+Usage:\n+\n+\tgo fix [packages]\n+\n+Fix runs the Go fix command on the packages named by the import paths.\n+\n+For more about fix, see 'go doc cmd/fix'.\n+For more about specifying packages, see 'go help packages'.\n+\n+To run fix with specific options, run 'go tool fix'.\n+\n+See also: go fmt, go vet.\n+\n+\n+Run gofmt on package sources\n+\n+Usage:\n+\n+\tgo fmt [-n] [-x] [packages]\n+\n+Fmt runs the command 'gofmt -l -w' on the packages named\n+by the import paths.  It prints the names of the files that are modified.\n+\n+For more about gofmt, see 'go doc cmd/gofmt'.\n+For more about specifying packages, see 'go help packages'.\n+\n+The -n flag prints commands that would be executed.\n+The -x flag prints commands as they are executed.\n+\n+To run gofmt with specific options, run gofmt itself.\n+\n+See also: go fix, go vet.\n+\n+\n+Generate Go files by processing source\n+\n+Usage:\n+\n+\tgo generate [-run regexp] [file.go... | packages]\n+\n+Generate runs commands described by directives within existing\n+files. Those commands can run any process but the intent is to\n+create or update Go source files, for instance by running yacc.\n+\n+Go generate is never run automatically by go build, go get, go test,\n+and so on. It must be run explicitly.\n+\n+Go generate scans the file for directives, which are lines of\n+the form,\n+\n+\t//go:generate command argument...\n+\n+(note: no leading spaces and no space in \"//go\") where command\n+is the generator to be run, corresponding to an executable file\n+that can be run locally. It must either be in the shell path\n+(gofmt), a fully qualified path (/usr/you/bin/mytool), or a\n+command alias, described below.\n+\n+Note that go generate does not parse the file, so lines that look\n+like directives in comments or multiline strings will be treated\n+as directives.\n+\n+The arguments to the directive are space-separated tokens or\n+double-quoted strings passed to the generator as individual\n+arguments when it is run.\n+\n+Quoted strings use Go syntax and are evaluated before execution; a\n+quoted string appears as a single argument to the generator.\n+\n+Go generate sets several variables when it runs the generator:\n+\n+\t$GOARCH\n+\t\tThe execution architecture (arm, amd64, etc.)\n+\t$GOOS\n+\t\tThe execution operating system (linux, windows, etc.)\n+\t$GOFILE\n+\t\tThe base name of the file.\n+\t$GOLINE\n+\t\tThe line number of the directive in the source file.\n+\t$GOPACKAGE\n+\t\tThe name of the package of the file containing the directive.\n+\t$DOLLAR\n+\t\tA dollar sign.\n+\n+Other than variable substitution and quoted-string evaluation, no\n+special processing such as \"globbing\" is performed on the command\n+line.\n+\n+As a last step before running the command, any invocations of any\n+environment variables with alphanumeric names, such as $GOFILE or\n+$HOME, are expanded throughout the command line. The syntax for\n+variable expansion is $NAME on all operating systems.  Due to the\n+order of evaluation, variables are expanded even inside quoted\n+strings. If the variable NAME is not set, $NAME expands to the\n+empty string.\n+\n+A directive of the form,\n+\n+\t//go:generate -command xxx args...\n+\n+specifies, for the remainder of this source file only, that the\n+string xxx represents the command identified by the arguments. This\n+can be used to create aliases or to handle multiword generators.\n+For example,\n+\n+\t//go:generate -command yacc go tool yacc\n+\n+specifies that the command \"yacc\" represents the generator\n+\"go tool yacc\".\n+\n+Generate processes packages in the order given on the command line,\n+one at a time. If the command line lists .go files, they are treated\n+as a single package. Within a package, generate processes the\n+source files in a package in file name order, one at a time. Within\n+a source file, generate runs generators in the order they appear\n+in the file, one at a time.\n+\n+If any generator returns an error exit status, \"go generate\" skips\n+all further processing for that package.\n+\n+The generator is run in the package's source directory.\n+\n+Go generate accepts one specific flag:\n+\n+\t-run=\"\"\n+\t\tif non-empty, specifies a regular expression to select\n+\t\tdirectives whose full original source text (excluding\n+\t\tany trailing spaces and final newline) matches the\n+\t\texpression.\n+\n+It also accepts the standard build flags -v, -n, and -x.\n+The -v flag prints the names of packages and files as they are\n+processed.\n+The -n flag prints commands that would be executed.\n+The -x flag prints commands as they are executed.\n+\n+For more about specifying packages, see 'go help packages'.\n+\n+\n+Download and install packages and dependencies\n+\n+Usage:\n+\n+\tgo get [-d] [-f] [-fix] [-insecure] [-t] [-u] [build flags] [packages]\n+\n+Get downloads and installs the packages named by the import paths,\n+along with their dependencies.\n+\n+The -d flag instructs get to stop after downloading the packages; that is,\n+it instructs get not to install the packages.\n+\n+The -f flag, valid only when -u is set, forces get -u not to verify that\n+each package has been checked out from the source control repository\n+implied by its import path. This can be useful if the source is a local fork\n+of the original.\n+\n+The -fix flag instructs get to run the fix tool on the downloaded packages\n+before resolving dependencies or building the code.\n+\n+The -insecure flag permits fetching from repositories and resolving\n+custom domains using insecure schemes such as HTTP. Use with caution.\n+\n+The -t flag instructs get to also download the packages required to build\n+the tests for the specified packages.\n+\n+The -u flag instructs get to use the network to update the named packages\n+and their dependencies.  By default, get uses the network to check out\n+missing packages but does not use it to look for updates to existing packages.\n+\n+Get also accepts build flags to control the installation. See 'go help build'.\n+\n+When checking out or updating a package, get looks for a branch or tag\n+that matches the locally installed version of Go. The most important\n+rule is that if the local installation is running version \"go1\", get\n+searches for a branch or tag named \"go1\". If no such version exists it\n+retrieves the most recent version of the package.\n+\n+If the vendoring experiment is enabled (see 'go help gopath'),\n+then when go get checks out or updates a Git repository,\n+it also updates any git submodules referenced by the repository.\n+\n+For more about specifying packages, see 'go help packages'.\n+\n+For more about how 'go get' finds source code to\n+download, see 'go help importpath'.\n+\n+See also: go build, go install, go clean.\n+\n+\n+Compile and install packages and dependencies\n+\n+Usage:\n+\n+\tgo install [build flags] [packages]\n+\n+Install compiles and installs the packages named by the import paths,\n+along with their dependencies.\n+\n+For more about the build flags, see 'go help build'.\n+For more about specifying packages, see 'go help packages'.\n+\n+See also: go build, go get, go clean.\n+\n+\n+List packages\n+\n+Usage:\n+\n+\tgo list [-e] [-f format] [-json] [build flags] [packages]\n+\n+List lists the packages named by the import paths, one per line.\n+\n+The default output shows the package import path:\n+\n+    bytes\n+    encoding/json\n+    github.com/gorilla/mux\n+    golang.org/x/net/html\n+\n+The -f flag specifies an alternate format for the list, using the\n+syntax of package template.  The default output is equivalent to -f\n+'{{.ImportPath}}'. The struct being passed to the template is:\n+\n+    type Package struct {\n+        Dir           string // directory containing package sources\n+        ImportPath    string // import path of package in dir\n+        ImportComment string // path in import comment on package statement\n+        Name          string // package name\n+        Doc           string // package documentation string\n+        Target        string // install path\n+        Shlib         string // the shared library that contains this package (only set when -linkshared)\n+        Goroot        bool   // is this package in the Go root?\n+        Standard      bool   // is this package part of the standard Go library?\n+        Stale         bool   // would 'go install' do anything for this package?\n+        Root          string // Go root or Go path dir containing this package\n+\n+        // Source files\n+        GoFiles        []string // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)\n+        CgoFiles       []string // .go sources files that import \"C\"\n+        IgnoredGoFiles []string // .go sources ignored due to build constraints\n+        CFiles         []string // .c source files\n+        CXXFiles       []string // .cc, .cxx and .cpp source files\n+        MFiles         []string // .m source files\n+        HFiles         []string // .h, .hh, .hpp and .hxx source files\n+        SFiles         []string // .s source files\n+        SwigFiles      []string // .swig files\n+        SwigCXXFiles   []string // .swigcxx files\n+        SysoFiles      []string // .syso object files to add to archive\n+\n+        // Cgo directives\n+        CgoCFLAGS    []string // cgo: flags for C compiler\n+        CgoCPPFLAGS  []string // cgo: flags for C preprocessor\n+        CgoCXXFLAGS  []string // cgo: flags for C++ compiler\n+        CgoLDFLAGS   []string // cgo: flags for linker\n+        CgoPkgConfig []string // cgo: pkg-config names\n+\n+        // Dependency information\n+        Imports []string // import paths used by this package\n+        Deps    []string // all (recursively) imported dependencies\n+\n+        // Error information\n+        Incomplete bool            // this package or a dependency has an error\n+        Error      *PackageError   // error loading package\n+        DepsErrors []*PackageError // errors loading dependencies\n+\n+        TestGoFiles  []string // _test.go files in package\n+        TestImports  []string // imports from TestGoFiles\n+        XTestGoFiles []string // _test.go files outside package\n+        XTestImports []string // imports from XTestGoFiles\n+    }\n+\n+The template function \"join\" calls strings.Join.\n+\n+The template function \"context\" returns the build context, defined as:\n+\n+\ttype Context struct {\n+\t\tGOARCH        string   // target architecture\n+\t\tGOOS          string   // target operating system\n+\t\tGOROOT        string   // Go root\n+\t\tGOPATH        string   // Go path\n+\t\tCgoEnabled    bool     // whether cgo can be used\n+\t\tUseAllFiles   bool     // use files regardless of +build lines, file names\n+\t\tCompiler      string   // compiler to assume when computing target paths\n+\t\tBuildTags     []string // build constraints to match in +build lines\n+\t\tReleaseTags   []string // releases the current release is compatible with\n+\t\tInstallSuffix string   // suffix to use in the name of the install dir\n+\t}\n+\n+For more information about the meaning of these fields see the documentation\n+for the go/build package's Context type.\n+\n+The -json flag causes the package data to be printed in JSON format\n+instead of using the template format.\n+\n+The -e flag changes the handling of erroneous packages, those that\n+cannot be found or are malformed.  By default, the list command\n+prints an error to standard error for each erroneous package and\n+omits the packages from consideration during the usual printing.\n+With the -e flag, the list command never prints errors to standard\n+error and instead processes the erroneous packages with the usual\n+printing.  Erroneous packages will have a non-empty ImportPath and\n+a non-nil Error field; other information may or may not be missing\n+(zeroed).\n+\n+For more about build flags, see 'go help build'.\n+\n+For more about specifying packages, see 'go help packages'.\n+\n+\n+Compile and run Go program\n+\n+Usage:\n+\n+\tgo run [build flags] [-exec xprog] gofiles... [arguments...]\n+\n+Run compiles and runs the main package comprising the named Go source files.\n+A Go source file is defined to be a file ending in a literal \".go\" suffix.\n+\n+By default, 'go run' runs the compiled binary directly: 'a.out arguments...'.\n+If the -exec flag is given, 'go run' invokes the binary using xprog:\n+\t'xprog a.out arguments...'.\n+If the -exec flag is not given, GOOS or GOARCH is different from the system\n+default, and a program named go_$GOOS_$GOARCH_exec can be found\n+on the current search path, 'go run' invokes the binary using that program,\n+for example 'go_nacl_386_exec a.out arguments...'. This allows execution of\n+cross-compiled programs when a simulator or other execution method is\n+available.\n+\n+For more about build flags, see 'go help build'.\n+\n+See also: go build.\n+\n+\n+Test packages\n+\n+Usage:\n+\n+\tgo test [-c] [-i] [build and test flags] [packages] [flags for test binary]\n+\n+'Go test' automates testing the packages named by the import paths.\n+It prints a summary of the test results in the format:\n+\n+\tok   archive/tar   0.011s\n+\tFAIL archive/zip   0.022s\n+\tok   compress/gzip 0.033s\n+\t...\n+\n+followed by detailed output for each failed package.\n+\n+'Go test' recompiles each package along with any files with names matching\n+the file pattern \"*_test.go\".\n+Files whose names begin with \"_\" (including \"_test.go\") or \".\" are ignored.\n+These additional files can contain test functions, benchmark functions, and\n+example functions.  See 'go help testfunc' for more.\n+Each listed package causes the execution of a separate test binary.\n+\n+Test files that declare a package with the suffix \"_test\" will be compiled as a\n+separate package, and then linked and run with the main test binary.\n+\n+By default, go test needs no arguments.  It compiles and tests the package\n+with source in the current directory, including tests, and runs the tests.\n+\n+The package is built in a temporary directory so it does not interfere with the\n+non-test installation.\n+\n+In addition to the build flags, the flags handled by 'go test' itself are:\n+\n+\t-c\n+\t\tCompile the test binary to pkg.test but do not run it\n+\t\t(where pkg is the last element of the package's import path).\n+\t\tThe file name can be changed with the -o flag.\n+\n+\t-exec xprog\n+\t    Run the test binary using xprog. The behavior is the same as\n+\t    in 'go run'. See 'go help run' for details.\n+\n+\t-i\n+\t    Install packages that are dependencies of the test.\n+\t    Do not run the test.\n+\n+\t-o file\n+\t\tCompile the test binary to the named file.\n+\t\tThe test still runs (unless -c or -i is specified).\n+\n+The test binary also accepts flags that control execution of the test; these\n+flags are also accessible by 'go test'. See 'go help testflag' for details.\n+\n+If the test binary needs any other flags, they should be presented after the\n+package names. The go tool treats as a flag the first argument that begins with\n+a minus sign that it does not recognize itself; that argument and all subsequent\n+arguments are passed as arguments to the test binary.\n+\n+For more about build flags, see 'go help build'.\n+For more about specifying packages, see 'go help packages'.\n+\n+See also: go build, go vet.\n+\n+\n+Run specified go tool\n+\n+Usage:\n+\n+\tgo tool [-n] command [args...]\n+\n+Tool runs the go tool command identified by the arguments.\n+With no arguments it prints the list of known tools.\n+\n+The -n flag causes tool to print the command that would be\n+executed but not execute it.\n+\n+For more about each tool command, see 'go tool command -h'.\n+\n+\n+Print Go version\n+\n+Usage:\n+\n+\tgo version\n+\n+Version prints the Go version, as reported by runtime.Version.\n+\n+\n+Run go tool vet on packages\n+\n+Usage:\n+\n+\tgo vet [-n] [-x] [build flags] [packages]\n+\n+Vet runs the Go vet command on the packages named by the import paths.\n+\n+For more about vet, see 'go doc cmd/vet'.\n+For more about specifying packages, see 'go help packages'.\n+\n+To run the vet tool with specific options, run 'go tool vet'.\n+\n+The -n flag prints commands that would be executed.\n+The -x flag prints commands as they are executed.\n+\n+For more about build flags, see 'go help build'.\n+\n+See also: go fmt, go fix.\n+\n+\n+Calling between Go and C\n+\n+There are two different ways to call between Go and C/C++ code.\n+\n+The first is the cgo tool, which is part of the Go distribution.  For\n+information on how to use it see the cgo documentation (go doc cmd/cgo).\n+\n+The second is the SWIG program, which is a general tool for\n+interfacing between languages.  For information on SWIG see\n+http://swig.org/.  When running go build, any file with a .swig\n+extension will be passed to SWIG.  Any file with a .swigcxx extension\n+will be passed to SWIG with the -c++ option.\n+\n+When either cgo or SWIG is used, go build will pass any .c, .m, .s,\n+or .S files to the C compiler, and any .cc, .cpp, .cxx files to the C++\n+compiler.  The CC or CXX environment variables may be set to determine\n+the C or C++ compiler, respectively, to use.\n+\n+\n+Description of build modes\n+\n+The 'go build' and 'go install' commands take a -buildmode argument which\n+indicates which kind of object file is to be built. Currently supported values\n+are:\n+\n+\t-buildmode=archive\n+\t\tBuild the listed non-main packages into .a files. Packages named\n+\t\tmain are ignored.\n+\n+\t-buildmode=c-archive\n+\t\tBuild the listed main package, plus all packages it imports,\n+\t\tinto a C archive file. The only callable symbols will be those\n+\t\tfunctions exported using a cgo //export comment. Requires\n+\t\texactly one main package to be listed.\n+\n+\t-buildmode=c-shared\n+\t\tBuild the listed main packages, plus all packages that they\n+\t\timport, into C shared libraries. The only callable symbols will\n+\t\tbe those functions exported using a cgo //export comment.\n+\t\tNon-main packages are ignored.\n+\n+\t-buildmode=default\n+\t\tListed main packages are built into executables and listed\n+\t\tnon-main packages are built into .a files (the default\n+\t\tbehavior).\n+\n+\t-buildmode=shared\n+\t\tCombine all the listed non-main packages into a single shared\n+\t\tlibrary that will be used when building with the -linkshared\n+\t\toption. Packages named main are ignored.\n+\n+\t-buildmode=exe\n+\t\tBuild the listed main packages and everything they import into\n+\t\texecutables. Packages not named main are ignored.\n+\n+\n+File types\n+\n+The go command examines the contents of a restricted set of files\n+in each directory. It identifies which files to examine based on\n+the extension of the file name. These extensions are:\n+\n+\t.go\n+\t\tGo source files.\n+\t.c, .h\n+\t\tC source files.\n+\t\tIf the package uses cgo or SWIG, these will be compiled with the\n+\t\tOS-native compiler (typically gcc); otherwise they will\n+\t\ttrigger an error.\n+\t.cc, .cpp, .cxx, .hh, .hpp, .hxx\n+\t\tC++ source files. Only useful with cgo or SWIG, and always\n+\t\tcompiled with the OS-native compiler.\n+\t.m\n+\t\tObjective-C source files. Only useful with cgo, and always\n+\t\tcompiled with the OS-native compiler.\n+\t.s, .S\n+\t\tAssembler source files.\n+\t\tIf the package uses cgo or SWIG, these will be assembled with the\n+\t\tOS-native assembler (typically gcc (sic)); otherwise they\n+\t\twill be assembled with the Go assembler.\n+\t.swig, .swigcxx\n+\t\tSWIG definition files.\n+\t.syso\n+\t\tSystem object files.\n+\n+Files of each of these types except .syso may contain build\n+constraints, but the go command stops scanning for build constraints\n+at the first item in the file that is not a blank line or //-style\n+line comment.\n+\n+\n+GOPATH environment variable\n+\n+The Go path is used to resolve import statements.\n+It is implemented by and documented in the go/build package.\n+\n+The GOPATH environment variable lists places to look for Go code.\n+On Unix, the value is a colon-separated string.\n+On Windows, the value is a semicolon-separated string.\n+On Plan 9, the value is a list.\n+\n+GOPATH must be set to get, build and install packages outside the\n+standard Go tree.\n+\n+Each directory listed in GOPATH must have a prescribed structure:\n+\n+The src directory holds source code.  The path below src\n+determines the import path or executable name.\n+\n+The pkg directory holds installed package objects.\n+As in the Go tree, each target operating system and\n+architecture pair has its own subdirectory of pkg\n+(pkg/GOOS_GOARCH).\n+\n+If DIR is a directory listed in the GOPATH, a package with\n+source in DIR/src/foo/bar can be imported as \"foo/bar\" and\n+has its compiled form installed to \"DIR/pkg/GOOS_GOARCH/foo/bar.a\".\n+\n+The bin directory holds compiled commands.\n+Each command is named for its source directory, but only\n+the final element, not the entire path.  That is, the\n+command with source in DIR/src/foo/quux is installed into\n+DIR/bin/quux, not DIR/bin/foo/quux.  The \"foo/\" prefix is stripped\n+so that you can add DIR/bin to your PATH to get at the\n+installed commands.  If the GOBIN environment variable is\n+set, commands are installed to the directory it names instead\n+of DIR/bin.\n+\n+Here's an example directory layout:\n+\n+    GOPATH=/home/user/gocode\n+\n+    /home/user/gocode/\n+        src/\n+            foo/\n+                bar/               (go code in package bar)\n+                    x.go\n+                quux/              (go code in package main)\n+                    y.go\n+        bin/\n+            quux                   (installed command)\n+        pkg/\n+            linux_amd64/\n+                foo/\n+                    bar.a          (installed package object)\n+\n+Go searches each directory listed in GOPATH to find source code,\n+but new packages are always downloaded into the first directory\n+in the list.\n+\n+See https://golang.org/doc/code.html for an example.\n+\n+Internal Directories\n+\n+Code in or below a directory named \"internal\" is importable only\n+by code in the directory tree rooted at the parent of \"internal\".\n+Here's an extended version of the directory layout above:\n+\n+    /home/user/gocode/\n+        src/\n+            crash/\n+                bang/              (go code in package bang)\n+                    b.go\n+            foo/                   (go code in package foo)\n+                f.go\n+                bar/               (go code in package bar)\n+                    x.go\n+                internal/\n+                    baz/           (go code in package baz)\n+                        z.go\n+                quux/              (go code in package main)\n+                    y.go\n+\n+\n+The code in z.go is imported as \"foo/internal/baz\", but that\n+import statement can only appear in source files in the subtree\n+rooted at foo. The source files foo/f.go, foo/bar/x.go, and\n+foo/quux/y.go can all import \"foo/internal/baz\", but the source file\n+crash/bang/b.go cannot.\n+\n+See https://golang.org/s/go14internal for details.\n+\n+Vendor Directories\n+\n+Go 1.5 includes experimental support for using local copies\n+of external dependencies to satisfy imports of those dependencies,\n+often referred to as vendoring. Setting the environment variable\n+GO15VENDOREXPERIMENT=1 enables that experimental support.\n+\n+When the vendor experiment is enabled,\n+code below a directory named \"vendor\" is importable only\n+by code in the directory tree rooted at the parent of \"vendor\",\n+and only using an import path that omits the prefix up to and\n+including the vendor element.\n+\n+Here's the example from the previous section,\n+but with the \"internal\" directory renamed to \"vendor\"\n+and a new foo/vendor/crash/bang directory added:\n+\n+    /home/user/gocode/\n+        src/\n+            crash/\n+                bang/              (go code in package bang)\n+                    b.go\n+            foo/                   (go code in package foo)\n+                f.go\n+                bar/               (go code in package bar)\n+                    x.go\n+                vendor/\n+                    crash/\n+                        bang/      (go code in package bang)\n+                            b.go\n+                    baz/           (go code in package baz)\n+                        z.go\n+                quux/              (go code in package main)\n+                    y.go\n+\n+The same visibility rules apply as for internal, but the code\n+in z.go is imported as \"baz\", not as \"foo/vendor/baz\".\n+\n+Code in vendor directories deeper in the source tree shadows\n+code in higher directories. Within the subtree rooted at foo, an import\n+of \"crash/bang\" resolves to \"foo/vendor/crash/bang\", not the\n+top-level \"crash/bang\".\n+\n+Code in vendor directories is not subject to import path\n+checking (see 'go help importpath').\n+\n+When the vendor experiment is enabled, 'go get' checks out\n+submodules when checking out or updating a git repository\n+(see 'go help get').\n+\n+The vendoring semantics are an experiment, and they may change\n+in future releases. Once settled, they will be on by default.\n+\n+See https://golang.org/s/go15vendor for details.\n+\n+\n+Environment variables\n+\n+The go command, and the tools it invokes, examine a few different\n+environment variables. For many of these, you can see the default\n+value of on your system by running 'go env NAME', where NAME is the\n+name of the variable.\n+\n+General-purpose environment variables:\n+\n+\tGCCGO\n+\t\tThe gccgo command to run for 'go build -compiler=gccgo'.\n+\tGOARCH\n+\t\tThe architecture, or processor, for which to compile code.\n+\t\tExamples are amd64, 386, arm, ppc64.\n+\tGOBIN\n+\t\tThe directory where 'go install' will install a command.\n+\tGOOS\n+\t\tThe operating system for which to compile code.\n+\t\tExamples are linux, darwin, windows, netbsd.\n+\tGOPATH\n+\t\tSee 'go help gopath'.\n+\tGORACE\n+\t\tOptions for the race detector.\n+\t\tSee https://golang.org/doc/articles/race_detector.html.\n+\tGOROOT\n+\t\tThe root of the go tree.\n+\n+Environment variables for use with cgo:\n+\n+\tCC\n+\t\tThe command to use to compile C code.\n+\tCGO_ENABLED\n+\t\tWhether the cgo command is supported.  Either 0 or 1.\n+\tCGO_CFLAGS\n+\t\tFlags that cgo will pass to the compiler when compiling\n+\t\tC code.\n+\tCGO_CPPFLAGS\n+\t\tFlags that cgo will pass to the compiler when compiling\n+\t\tC or C++ code.\n+\tCGO_CXXFLAGS\n+\t\tFlags that cgo will pass to the compiler when compiling\n+\t\tC++ code.\n+\tCGO_LDFLAGS\n+\t\tFlags that cgo will pass to the compiler when linking.\n+\tCXX\n+\t\tThe command to use to compile C++ code.\n+\n+Architecture-specific environment variables:\n+\n+\tGOARM\n+\t\tFor GOARCH=arm, the ARM architecture for which to compile.\n+\t\tValid values are 5, 6, 7.\n+\tGO386\n+\t\tFor GOARCH=386, the floating point instruction set.\n+\t\tValid values are 387, sse2.\n+\n+Special-purpose environment variables:\n+\n+\tGOROOT_FINAL\n+\t\tThe root of the installed Go tree, when it is\n+\t\tinstalled in a location other than where it is built.\n+\t\tFile names in stack traces are rewritten from GOROOT to\n+\t\tGOROOT_FINAL.\n+\tGO15VENDOREXPERIMENT\n+\t\tSet to 1 to enable the Go 1.5 vendoring experiment.\n+\tGO_EXTLINK_ENABLED\n+\t\tWhether the linker should use external linking mode\n+\t\twhen using -linkmode=auto with code that uses cgo.\n+\t\tSet to 0 to disable external linking mode, 1 to enable it.\n+\n+\n+Import path syntax\n+\n+An import path (see 'go help packages') denotes a package\n+stored in the local file system.  In general, an import path denotes\n+either a standard package (such as \"unicode/utf8\") or a package\n+found in one of the work spaces (see 'go help gopath').\n+\n+Relative import paths\n+\n+An import path beginning with ./ or ../ is called a relative path.\n+The toolchain supports relative import paths as a shortcut in two ways.\n+\n+First, a relative path can be used as a shorthand on the command line.\n+If you are working in the directory containing the code imported as\n+\"unicode\" and want to run the tests for \"unicode/utf8\", you can type\n+\"go test ./utf8\" instead of needing to specify the full path.\n+Similarly, in the reverse situation, \"go test ..\" will test \"unicode\" from\n+the \"unicode/utf8\" directory. Relative patterns are also allowed, like\n+\"go test ./...\" to test all subdirectories. See 'go help packages' for details\n+on the pattern syntax.\n+\n+Second, if you are compiling a Go program not in a work space,\n+you can use a relative path in an import statement in that program\n+to refer to nearby code also not in a work space.\n+This makes it easy to experiment with small multipackage programs\n+outside of the usual work spaces, but such programs cannot be\n+installed with \"go install\" (there is no work space in which to install them),\n+so they are rebuilt from scratch each time they are built.\n+To avoid ambiguity, Go programs cannot use relative import paths\n+within a work space.\n+\n+Remote import paths\n+\n+Certain import paths also\n+describe how to obtain the source code for the package using\n+a revision control system.\n+\n+A few common code hosting sites have special syntax:\n+\n+\tBitbucket (Git, Mercurial)\n+\n+\t\timport \"bitbucket.org/user/project\"\n+\t\timport \"bitbucket.org/user/project/sub/directory\"\n+\n+\tGitHub (Git)\n+\n+\t\timport \"github.com/user/project\"\n+\t\timport \"github.com/user/project/sub/directory\"\n+\n+\tGoogle Code Project Hosting (Git, Mercurial, Subversion)\n+\n+\t\timport \"code.google.com/p/project\"\n+\t\timport \"code.google.com/p/project/sub/directory\"\n+\n+\t\timport \"code.google.com/p/project.subrepository\"\n+\t\timport \"code.google.com/p/project.subrepository/sub/directory\"\n+\n+\tLaunchpad (Bazaar)\n+\n+\t\timport \"launchpad.net/project\"\n+\t\timport \"launchpad.net/project/series\"\n+\t\timport \"launchpad.net/project/series/sub/directory\"\n+\n+\t\timport \"launchpad.net/~user/project/branch\"\n+\t\timport \"launchpad.net/~user/project/branch/sub/directory\"\n+\n+\tIBM DevOps Services (Git)\n+\n+\t\timport \"hub.jazz.net/git/user/project\"\n+\t\timport \"hub.jazz.net/git/user/project/sub/directory\"\n+\n+For code hosted on other servers, import paths may either be qualified\n+with the version control type, or the go tool can dynamically fetch\n+the import path over https/http and discover where the code resides\n+from a <meta> tag in the HTML.\n+\n+To declare the code location, an import path of the form\n+\n+\trepository.vcs/path\n+\n+specifies the given repository, with or without the .vcs suffix,\n+using the named version control system, and then the path inside\n+that repository.  The supported version control systems are:\n+\n+\tBazaar      .bzr\n+\tGit         .git\n+\tMercurial   .hg\n+\tSubversion  .svn\n+\n+For example,\n+\n+\timport \"example.org/user/foo.hg\"\n+\n+denotes the root directory of the Mercurial repository at\n+example.org/user/foo or foo.hg, and\n+\n+\timport \"example.org/repo.git/foo/bar\"\n+\n+denotes the foo/bar directory of the Git repository at\n+example.org/repo or repo.git.\n+\n+When a version control system supports multiple protocols,\n+each is tried in turn when downloading.  For example, a Git\n+download tries https://, then git+ssh://.\n+\n+If the import path is not a known code hosting site and also lacks a\n+version control qualifier, the go tool attempts to fetch the import\n+over https/http and looks for a <meta> tag in the document's HTML\n+<head>.\n+\n+The meta tag has the form:\n+\n+\t<meta name=\"go-import\" content=\"import-prefix vcs repo-root\">\n+\n+The import-prefix is the import path corresponding to the repository\n+root. It must be a prefix or an exact match of the package being\n+fetched with \"go get\". If it's not an exact match, another http\n+request is made at the prefix to verify the <meta> tags match.\n+\n+The meta tag should appear as early in the file as possible.\n+In particular, it should appear before any raw JavaScript or CSS,\n+to avoid confusing the go command's restricted parser.\n+\n+The vcs is one of \"git\", \"hg\", \"svn\", etc,\n+\n+The repo-root is the root of the version control system\n+containing a scheme and not containing a .vcs qualifier.\n+\n+For example,\n+\n+\timport \"example.org/pkg/foo\"\n+\n+will result in the following requests:\n+\n+\thttps://example.org/pkg/foo?go-get=1 (preferred)\n+\thttp://example.org/pkg/foo?go-get=1  (fallback, only with -insecure)\n+\n+If that page contains the meta tag\n+\n+\t<meta name=\"go-import\" content=\"example.org git https://code.org/r/p/exproj\">\n+\n+the go tool will verify that https://example.org/?go-get=1 contains the\n+same meta tag and then git clone https://code.org/r/p/exproj into\n+GOPATH/src/example.org.\n+\n+New downloaded packages are written to the first directory\n+listed in the GOPATH environment variable (see 'go help gopath').\n+\n+The go command attempts to download the version of the\n+package appropriate for the Go release being used.\n+Run 'go help get' for more.\n+\n+Import path checking\n+\n+When the custom import path feature described above redirects to a\n+known code hosting site, each of the resulting packages has two possible\n+import paths, using the custom domain or the known hosting site.\n+\n+A package statement is said to have an \"import comment\" if it is immediately\n+followed (before the next newline) by a comment of one of these two forms:\n+\n+\tpackage math // import \"path\"\n+\tpackage math /* import \"path\" * /\n+\n+The go command will refuse to install a package with an import comment\n+unless it is being referred to by that import path. In this way, import comments\n+let package authors make sure the custom import path is used and not a\n+direct path to the underlying code hosting site.\n+\n+If the vendoring experiment is enabled (see 'go help gopath'),\n+then import path checking is disabled for code found within vendor trees.\n+This makes it possible to copy code into alternate locations in vendor trees\n+without needing to update import comments.\n+\n+See https://golang.org/s/go14customimport for details.\n+\n+\n+Description of package lists\n+\n+Many commands apply to a set of packages:\n+\n+\tgo action [packages]\n+\n+Usually, [packages] is a list of import paths.\n+\n+An import path that is a rooted path or that begins with\n+a . or .. element is interpreted as a file system path and\n+denotes the package in that directory.\n+\n+Otherwise, the import path P denotes the package found in\n+the directory DIR/src/P for some DIR listed in the GOPATH\n+environment variable (see 'go help gopath').\n+\n+If no import paths are given, the action applies to the\n+package in the current directory.\n+\n+There are four reserved names for paths that should not be used\n+for packages to be built with the go tool:\n+\n+- \"main\" denotes the top-level package in a stand-alone executable.\n+\n+- \"all\" expands to all package directories found in all the GOPATH\n+trees. For example, 'go list all' lists all the packages on the local\n+system.\n+\n+- \"std\" is like all but expands to just the packages in the standard\n+Go library.\n+\n+- \"cmd\" expands to the Go repository's commands and their\n+internal libraries.\n+\n+An import path is a pattern if it includes one or more \"...\" wildcards,\n+each of which can match any string, including the empty string and\n+strings containing slashes.  Such a pattern expands to all package\n+directories found in the GOPATH trees with names matching the\n+patterns.  As a special case, x/... matches x as well as x's subdirectories.\n+For example, net/... expands to net and packages in its subdirectories.\n+\n+An import path can also name a package to be downloaded from\n+a remote repository.  Run 'go help importpath' for details.\n+\n+Every package in a program must have a unique import path.\n+By convention, this is arranged by starting each path with a\n+unique prefix that belongs to you.  For example, paths used\n+internally at Google all begin with 'google', and paths\n+denoting remote repositories begin with the path to the code,\n+such as 'github.com/user/repo'.\n+\n+As a special case, if the package list is a list of .go files from a\n+single directory, the command is applied to a single synthesized\n+package made up of exactly those files, ignoring any build constraints\n+in those files and ignoring any other files in the directory.\n+\n+Directory and file names that begin with \".\" or \"_\" are ignored\n+by the go tool, as are directories named \"testdata\".\n+\n+\n+Description of testing flags\n+\n+The 'go test' command takes both flags that apply to 'go test' itself\n+and flags that apply to the resulting test binary.\n+\n+Several of the flags control profiling and write an execution profile\n+suitable for \"go tool pprof\"; run \"go tool pprof -h\" for more\n+information.  The --alloc_space, --alloc_objects, and --show_bytes\n+options of pprof control how the information is presented.\n+\n+The following flags are recognized by the 'go test' command and\n+control the execution of any test:\n+\n+\t-bench regexp\n+\t    Run benchmarks matching the regular expression.\n+\t    By default, no benchmarks run. To run all benchmarks,\n+\t    use '-bench .' or '-bench=.'.\n+\n+\t-benchmem\n+\t    Print memory allocation statistics for benchmarks.\n+\n+\t-benchtime t\n+\t    Run enough iterations of each benchmark to take t, specified\n+\t    as a time.Duration (for example, -benchtime 1h30s).\n+\t    The default is 1 second (1s).\n+\n+\t-blockprofile block.out\n+\t    Write a goroutine blocking profile to the specified file\n+\t    when all tests are complete.\n+\t    Writes test binary as -c would.\n+\n+\t-blockprofilerate n\n+\t    Control the detail provided in goroutine blocking profiles by\n+\t    calling runtime.SetBlockProfileRate with n.\n+\t    See 'go doc runtime.SetBlockProfileRate'.\n+\t    The profiler aims to sample, on average, one blocking event every\n+\t    n nanoseconds the program spends blocked.  By default,\n+\t    if -test.blockprofile is set without this flag, all blocking events\n+\t    are recorded, equivalent to -test.blockprofilerate=1.\n+\n+\t-count n\n+\t    Run each test and benchmark n times (default 1).\n+\t    If -cpu is set, run n times for each GOMAXPROCS value.\n+\t    Examples are always run once.\n+\n+\t-cover\n+\t    Enable coverage analysis.\n+\n+\t-covermode set,count,atomic\n+\t    Set the mode for coverage analysis for the package[s]\n+\t    being tested. The default is \"set\" unless -race is enabled,\n+\t    in which case it is \"atomic\".\n+\t    The values:\n+\t\tset: bool: does this statement run?\n+\t\tcount: int: how many times does this statement run?\n+\t\tatomic: int: count, but correct in multithreaded tests;\n+\t\t\tsignificantly more expensive.\n+\t    Sets -cover.\n+\n+\t-coverpkg pkg1,pkg2,pkg3\n+\t    Apply coverage analysis in each test to the given list of packages.\n+\t    The default is for each test to analyze only the package being tested.\n+\t    Packages are specified as import paths.\n+\t    Sets -cover.\n+\n+\t-coverprofile cover.out\n+\t    Write a coverage profile to the file after all tests have passed.\n+\t    Sets -cover.\n+\n+\t-cpu 1,2,4\n+\t    Specify a list of GOMAXPROCS values for which the tests or\n+\t    benchmarks should be executed.  The default is the current value\n+\t    of GOMAXPROCS.\n+\n+\t-cpuprofile cpu.out\n+\t    Write a CPU profile to the specified file before exiting.\n+\t    Writes test binary as -c would.\n+\n+\t-memprofile mem.out\n+\t    Write a memory profile to the file after all tests have passed.\n+\t    Writes test binary as -c would.\n+\n+\t-memprofilerate n\n+\t    Enable more precise (and expensive) memory profiles by setting\n+\t    runtime.MemProfileRate.  See 'go doc runtime.MemProfileRate'.\n+\t    To profile all memory allocations, use -test.memprofilerate=1\n+\t    and pass --alloc_space flag to the pprof tool.\n+\n+\t-outputdir directory\n+\t    Place output files from profiling in the specified directory,\n+\t    by default the directory in which \"go test\" is running.\n+\n+\t-parallel n\n+\t    Allow parallel execution of test functions that call t.Parallel.\n+\t    The value of this flag is the maximum number of tests to run\n+\t    simultaneously; by default, it is set to the value of GOMAXPROCS.\n+\n+\t-run regexp\n+\t    Run only those tests and examples matching the regular\n+\t    expression.\n+\n+\t-short\n+\t    Tell long-running tests to shorten their run time.\n+\t    It is off by default but set during all.bash so that installing\n+\t    the Go tree can run a sanity check but not spend time running\n+\t    exhaustive tests.\n+\n+\t-timeout t\n+\t    If a test runs longer than t, panic.\n+\t    The default is 10 minutes (10m).\n+\n+\t-trace trace.out\n+\t    Write an execution trace to the specified file before exiting.\n+\t    Writes test binary as -c would.\n+\n+\t-v\n+\t    Verbose output: log all tests as they are run. Also print all\n+\t    text from Log and Logf calls even if the test succeeds.\n+\n+The test binary, called pkg.test where pkg is the name of the\n+directory containing the package sources, can be invoked directly\n+after building it with 'go test -c'. When invoking the test binary\n+directly, each of the standard flag names must be prefixed with 'test.',\n+as in -test.run=TestMyFunc or -test.v.\n+\n+When running 'go test', flags not listed above are passed through\n+unaltered. For instance, the command\n+\n+\tgo test -x -v -cpuprofile=prof.out -dir=testdata -update\n+\n+will compile the test binary and then run it as\n+\n+\tpkg.test -test.v -test.cpuprofile=prof.out -dir=testdata -update\n+\n+The test flags that generate profiles (other than for coverage) also\n+leave the test binary in pkg.test for use when analyzing the profiles.\n+\n+Flags not recognized by 'go test' must be placed after any specified packages.\n+\n+\n+Description of testing functions\n+\n+The 'go test' command expects to find test, benchmark, and example functions\n+in the \"*_test.go\" files corresponding to the package under test.\n+\n+A test function is one named TestXXX (where XXX is any alphanumeric string\n+not starting with a lower case letter) and should have the signature,\n+\n+\tfunc TestXXX(t *testing.T) { ... }\n+\n+A benchmark function is one named BenchmarkXXX and should have the signature,\n+\n+\tfunc BenchmarkXXX(b *testing.B) { ... }\n+\n+An example function is similar to a test function but, instead of using\n+*testing.T to report success or failure, prints output to os.Stdout.\n+That output is compared against the function's \"Output:\" comment, which\n+must be the last comment in the function body (see example below). An\n+example with no such comment, or with no text after \"Output:\" is compiled\n+but not executed.\n+\n+Godoc displays the body of ExampleXXX to demonstrate the use\n+of the function, constant, or variable XXX.  An example of a method M with\n+receiver type T or *T is named ExampleT_M.  There may be multiple examples\n+for a given function, constant, or variable, distinguished by a trailing _xxx,\n+where xxx is a suffix not beginning with an upper case letter.\n+\n+Here is an example of an example:\n+\n+\tfunc ExamplePrintln() {\n+\t\tPrintln(\"The output of\\nthis example.\")\n+\t\t// Output: The output of\n+\t\t// this example.\n+\t}\n+\n+The entire test file is presented as the example when it contains a single\n+example function, at least one other function, type, variable, or constant\n+declaration, and no test or benchmark functions.\n+\n+See the documentation of the testing package for more information.\n+\n+\n+*/\n+package main"}, {"sha": "1686df77afd863914fcfc04d8ceab716db357276", "filename": "libgo/go/cmd/go/bootstrap.go", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Fbootstrap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Fbootstrap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fbootstrap.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -17,11 +17,19 @@ import (\n \n var errHTTP = errors.New(\"no http in bootstrap go command\")\n \n+type httpError struct {\n+\tstatusCode int\n+}\n+\n+func (e *httpError) Error() string {\n+\tpanic(\"unreachable\")\n+}\n+\n func httpGET(url string) ([]byte, error) {\n \treturn nil, errHTTP\n }\n \n-func httpsOrHTTP(importPath string) (string, io.ReadCloser, error) {\n+func httpsOrHTTP(importPath string, security securityMode) (string, io.ReadCloser, error) {\n \treturn \"\", nil, errHTTP\n }\n "}, {"sha": "56b15ad90d31b40a5a1e82fc451f5474a957ed9c", "filename": "libgo/go/cmd/go/build.go", "status": "modified", "additions": 1054, "deletions": 366, "changes": 1420, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fbuild.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -8,6 +8,7 @@ import (\n \t\"bufio\"\n \t\"bytes\"\n \t\"container/heap\"\n+\t\"debug/elf\"\n \t\"errors\"\n \t\"flag\"\n \t\"fmt\"\n@@ -34,21 +35,23 @@ var cmdBuild = &Command{\n Build compiles the packages named by the import paths,\n along with their dependencies, but it does not install the results.\n \n-If the arguments are a list of .go files, build treats them as a list\n-of source files specifying a single package.\n+If the arguments to build are a list of .go files, build treats\n+them as a list of source files specifying a single package.\n \n-When the command line specifies a single main package,\n-build writes the resulting executable to output.\n-Otherwise build compiles the packages but discards the results,\n+When compiling a single main package, build writes\n+the resulting executable to an output file named after\n+the first source file ('go build ed.go rx.go' writes 'ed' or 'ed.exe')\n+or the source code directory ('go build unix/sam' writes 'sam' or 'sam.exe').\n+The '.exe' suffix is added when writing a Windows executable.\n+\n+When compiling multiple packages or a single non-main package,\n+build compiles the packages but discards the resulting object,\n serving only as a check that the packages can be built.\n \n-The -o flag specifies the output file name. If not specified, the\n-output file name depends on the arguments and derives from the name\n-of the package, such as p.a for package p, unless p is 'main'. If\n-the package is main and file names are provided, the file name\n-derives from the first file name mentioned, such as f1 for 'go build\n-f1.go f2.go'; with no files provided ('go build'), the output file\n-name is the base name of the containing directory.\n+The -o flag, only allowed when compiling a single package,\n+forces build to write the resulting executable or object\n+to the named output file, instead of the default behavior described\n+in the last two paragraphs.\n \n The -i flag installs the packages that are dependencies of the target.\n \n@@ -62,7 +65,8 @@ and test commands:\n \t\tprint the commands but do not run them.\n \t-p n\n \t\tthe number of builds that can be run in parallel.\n-\t\tThe default is the number of CPUs available.\n+\t\tThe default is the number of CPUs available, except\n+\t\ton darwin/arm which defaults to 1.\n \t-race\n \t\tenable data race detection.\n \t\tSupported only on linux/amd64, freebsd/amd64, darwin/amd64 and windows/amd64.\n@@ -74,33 +78,54 @@ and test commands:\n \t-x\n \t\tprint the commands.\n \n-\t-ccflags 'arg list'\n-\t\targuments to pass on each 5c, 6c, or 8c compiler invocation.\n+\t-asmflags 'flag list'\n+\t\targuments to pass on each go tool asm invocation.\n+\t-buildmode mode\n+\t\tbuild mode to use. See 'go help buildmode' for more.\n \t-compiler name\n \t\tname of compiler to use, as in runtime.Compiler (gccgo or gc).\n \t-gccgoflags 'arg list'\n \t\targuments to pass on each gccgo compiler/linker invocation.\n \t-gcflags 'arg list'\n-\t\targuments to pass on each 5g, 6g, or 8g compiler invocation.\n+\t\targuments to pass on each go tool compile invocation.\n \t-installsuffix suffix\n \t\ta suffix to use in the name of the package installation directory,\n \t\tin order to keep output separate from default builds.\n \t\tIf using the -race flag, the install suffix is automatically set to race\n-\t\tor, if set explicitly, has _race appended to it.\n+\t\tor, if set explicitly, has _race appended to it.  Using a -buildmode\n+\t\toption that requires non-default compile flags has a similar effect.\n \t-ldflags 'flag list'\n-\t\targuments to pass on each 5l, 6l, or 8l linker invocation.\n+\t\targuments to pass on each go tool link invocation.\n+\t-linkshared\n+\t\tlink against shared libraries previously created with\n+\t\t-buildmode=shared\n+\t-pkgdir dir\n+\t\tinstall and load all packages from dir instead of the usual locations.\n+\t\tFor example, when building with a non-standard configuration,\n+\t\tuse -pkgdir to keep generated packages in a separate location.\n \t-tags 'tag list'\n \t\ta list of build tags to consider satisfied during the build.\n \t\tFor more information about build tags, see the description of\n \t\tbuild constraints in the documentation for the go/build package.\n+\t-toolexec 'cmd args'\n+\t\ta program to use to invoke toolchain programs like vet and asm.\n+\t\tFor example, instead of running asm, the go command will run\n+\t\t'cmd args /path/to/asm <arguments for asm>'.\n \n The list flags accept a space-separated list of strings. To embed spaces\n in an element in the list, surround it with either single or double quotes.\n \n For more about specifying packages, see 'go help packages'.\n For more about where packages and binaries are installed,\n-run 'go help gopath'.  For more about calling between Go and C/C++,\n-run 'go help c'.\n+run 'go help gopath'.\n+For more about calling between Go and C/C++, run 'go help c'.\n+\n+Note: Build adheres to certain conventions such as those described\n+by 'go help gopath'. Not all projects can follow these conventions,\n+however. Installations that have their own conventions or that use\n+a separate software build system may choose to use lower-level\n+invocations such as 'go tool compile' and 'go tool link' to avoid\n+some of the overheads and design decisions of the build tool.\n \n See also: go install, go get, go clean.\n \t`,\n@@ -115,6 +140,17 @@ func init() {\n \n \taddBuildFlags(cmdBuild)\n \taddBuildFlags(cmdInstall)\n+\n+\tif buildContext.GOOS == \"darwin\" {\n+\t\tswitch buildContext.GOARCH {\n+\t\tcase \"arm\", \"arm64\":\n+\t\t\t// darwin/arm cannot run multiple tests simultaneously.\n+\t\t\t// Parallelism is limited in go_darwin_arm_exec, but\n+\t\t\t// also needs to be limited here so go test std does not\n+\t\t\t// timeout tests that waiting to run.\n+\t\t\tbuildP = 1\n+\t\t}\n+\t}\n }\n \n // Flags set by multiple commands.\n@@ -126,16 +162,21 @@ var buildX bool               // -x flag\n var buildI bool               // -i flag\n var buildO = cmdBuild.Flag.String(\"o\", \"\", \"output file\")\n var buildWork bool           // -work flag\n+var buildAsmflags []string   // -asmflags flag\n var buildGcflags []string    // -gcflags flag\n-var buildCcflags []string    // -ccflags flag\n var buildLdflags []string    // -ldflags flag\n var buildGccgoflags []string // -gccgoflags flag\n var buildRace bool           // -race flag\n+var buildToolExec []string   // -toolexec flag\n+var buildBuildmode string    // -buildmode flag\n+var buildLinkshared bool     // -linkshared flag\n+var buildPkgdir string       // -pkgdir flag\n \n // Require the source for go std packages\n var reqStdPkgSrc bool\n var buildContext = build.Default\n var buildToolchain toolchain = noToolchain{}\n+var ldBuildmode string\n \n // buildCompiler implements flag.Var.\n // It implements Set by updating both\n@@ -171,21 +212,25 @@ func init() {\n // addBuildFlags adds the flags common to the build, clean, get,\n // install, list, run, and test commands.\n func addBuildFlags(cmd *Command) {\n-\t// NOTE: If you add flags here, also add them to testflag.go.\n \tcmd.Flag.BoolVar(&buildA, \"a\", false, \"\")\n \tcmd.Flag.BoolVar(&buildN, \"n\", false, \"\")\n \tcmd.Flag.IntVar(&buildP, \"p\", buildP, \"\")\n-\tcmd.Flag.StringVar(&buildContext.InstallSuffix, \"installsuffix\", \"\", \"\")\n \tcmd.Flag.BoolVar(&buildV, \"v\", false, \"\")\n \tcmd.Flag.BoolVar(&buildX, \"x\", false, \"\")\n-\tcmd.Flag.BoolVar(&buildWork, \"work\", false, \"\")\n+\n+\tcmd.Flag.Var((*stringsFlag)(&buildAsmflags), \"asmflags\", \"\")\n+\tcmd.Flag.Var(buildCompiler{}, \"compiler\", \"\")\n+\tcmd.Flag.StringVar(&buildBuildmode, \"buildmode\", \"default\", \"\")\n \tcmd.Flag.Var((*stringsFlag)(&buildGcflags), \"gcflags\", \"\")\n-\tcmd.Flag.Var((*stringsFlag)(&buildCcflags), \"ccflags\", \"\")\n-\tcmd.Flag.Var((*stringsFlag)(&buildLdflags), \"ldflags\", \"\")\n \tcmd.Flag.Var((*stringsFlag)(&buildGccgoflags), \"gccgoflags\", \"\")\n-\tcmd.Flag.Var((*stringsFlag)(&buildContext.BuildTags), \"tags\", \"\")\n-\tcmd.Flag.Var(buildCompiler{}, \"compiler\", \"\")\n+\tcmd.Flag.StringVar(&buildContext.InstallSuffix, \"installsuffix\", \"\", \"\")\n+\tcmd.Flag.Var((*stringsFlag)(&buildLdflags), \"ldflags\", \"\")\n+\tcmd.Flag.BoolVar(&buildLinkshared, \"linkshared\", false, \"\")\n+\tcmd.Flag.StringVar(&buildPkgdir, \"pkgdir\", \"\", \"\")\n \tcmd.Flag.BoolVar(&buildRace, \"race\", false, \"\")\n+\tcmd.Flag.Var((*stringsFlag)(&buildContext.BuildTags), \"tags\", \"\")\n+\tcmd.Flag.Var((*stringsFlag)(&buildToolExec), \"toolexec\", \"\")\n+\tcmd.Flag.BoolVar(&buildWork, \"work\", false, \"\")\n \tswitch build.Default.Compiler {\n \tcase \"gc\":\n \t\treqStdPkgSrc = true\n@@ -266,8 +311,113 @@ func (v *stringsFlag) String() string {\n \treturn \"<stringsFlag>\"\n }\n \n+func pkgsMain(pkgs []*Package) (res []*Package) {\n+\tfor _, p := range pkgs {\n+\t\tif p.Name == \"main\" {\n+\t\t\tres = append(res, p)\n+\t\t}\n+\t}\n+\treturn res\n+}\n+\n+func pkgsNotMain(pkgs []*Package) (res []*Package) {\n+\tfor _, p := range pkgs {\n+\t\tif p.Name != \"main\" {\n+\t\t\tres = append(res, p)\n+\t\t}\n+\t}\n+\treturn res\n+}\n+\n+var pkgsFilter = func(pkgs []*Package) []*Package { return pkgs }\n+\n+func buildModeInit() {\n+\t_, gccgo := buildToolchain.(gccgoToolchain)\n+\tvar codegenArg string\n+\tplatform := goos + \"/\" + goarch\n+\tswitch buildBuildmode {\n+\tcase \"archive\":\n+\t\tpkgsFilter = pkgsNotMain\n+\tcase \"c-archive\":\n+\t\tpkgsFilter = func(p []*Package) []*Package {\n+\t\t\tif len(p) != 1 || p[0].Name != \"main\" {\n+\t\t\t\tfatalf(\"-buildmode=c-archive requires exactly one main package\")\n+\t\t\t}\n+\t\t\treturn p\n+\t\t}\n+\t\texeSuffix = \".a\"\n+\t\tldBuildmode = \"c-archive\"\n+\tcase \"c-shared\":\n+\t\tpkgsFilter = pkgsMain\n+\t\tif gccgo {\n+\t\t\tcodegenArg = \"-fPIC\"\n+\t\t} else {\n+\t\t\tswitch platform {\n+\t\t\tcase \"linux/amd64\":\n+\t\t\t\tcodegenArg = \"-shared\"\n+\t\t\tcase \"linux/arm\":\n+\t\t\t\tbuildAsmflags = append(buildAsmflags, \"-shared\")\n+\t\t\tcase \"darwin/amd64\":\n+\t\t\tcase \"android/arm\":\n+\t\t\tdefault:\n+\t\t\t\tfatalf(\"-buildmode=c-shared not supported on %s\\n\", platform)\n+\t\t\t}\n+\t\t}\n+\t\tldBuildmode = \"c-shared\"\n+\tcase \"default\":\n+\t\tldBuildmode = \"exe\"\n+\tcase \"exe\":\n+\t\tpkgsFilter = pkgsMain\n+\t\tldBuildmode = \"exe\"\n+\tcase \"shared\":\n+\t\tpkgsFilter = pkgsNotMain\n+\t\tif gccgo {\n+\t\t\tcodegenArg = \"-fPIC\"\n+\t\t} else {\n+\t\t\tswitch platform {\n+\t\t\tcase \"linux/amd64\":\n+\t\t\tdefault:\n+\t\t\t\tfatalf(\"-buildmode=shared not supported on %s\\n\", platform)\n+\t\t\t}\n+\t\t\tcodegenArg = \"-dynlink\"\n+\t\t}\n+\t\tif *buildO != \"\" {\n+\t\t\tfatalf(\"-buildmode=shared and -o not supported together\")\n+\t\t}\n+\t\tldBuildmode = \"shared\"\n+\tdefault:\n+\t\tfatalf(\"buildmode=%s not supported\", buildBuildmode)\n+\t}\n+\tif buildLinkshared {\n+\t\tif gccgo {\n+\t\t\tcodegenArg = \"-fPIC\"\n+\t\t} else {\n+\t\t\tif platform != \"linux/amd64\" {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"go %s: -linkshared is only supported on linux/amd64\\n\", flag.Args()[0])\n+\t\t\t\tos.Exit(2)\n+\t\t\t}\n+\t\t\tcodegenArg = \"-dynlink\"\n+\t\t\t// TODO(mwhudson): remove -w when that gets fixed in linker.\n+\t\t\tbuildLdflags = append(buildLdflags, \"-linkshared\", \"-w\")\n+\t\t}\n+\t}\n+\tif codegenArg != \"\" {\n+\t\tif gccgo {\n+\t\t\tbuildGccgoflags = append(buildGccgoflags, codegenArg)\n+\t\t} else {\n+\t\t\tbuildAsmflags = append(buildAsmflags, codegenArg)\n+\t\t\tbuildGcflags = append(buildGcflags, codegenArg)\n+\t\t}\n+\t\tif buildContext.InstallSuffix != \"\" {\n+\t\t\tbuildContext.InstallSuffix += \"_\"\n+\t\t}\n+\t\tbuildContext.InstallSuffix += codegenArg[1:]\n+\t}\n+}\n+\n func runBuild(cmd *Command, args []string) {\n \traceInit()\n+\tbuildModeInit()\n \tvar b builder\n \tb.init()\n \n@@ -305,16 +455,21 @@ func runBuild(cmd *Command, args []string) {\n \t\t\tfatalf(\"no packages to build\")\n \t\t}\n \t\tp := pkgs[0]\n-\t\tp.target = \"\" // must build - not up to date\n+\t\tp.target = *buildO\n+\t\tp.Stale = true // must build - not up to date\n \t\ta := b.action(modeInstall, depMode, p)\n-\t\ta.target = *buildO\n \t\tb.do(a)\n \t\treturn\n \t}\n \n-\ta := &action{}\n-\tfor _, p := range packages(args) {\n-\t\ta.deps = append(a.deps, b.action(modeBuild, depMode, p))\n+\tvar a *action\n+\tif buildBuildmode == \"shared\" {\n+\t\ta = b.libaction(libname(args), pkgsFilter(packages(args)), modeBuild, depMode)\n+\t} else {\n+\t\ta = &action{}\n+\t\tfor _, p := range pkgsFilter(packages(args)) {\n+\t\t\ta.deps = append(a.deps, b.action(modeBuild, depMode, p))\n+\t\t}\n \t}\n \tb.do(a)\n }\n@@ -333,37 +488,116 @@ See also: go build, go get, go clean.\n \t`,\n }\n \n+// libname returns the filename to use for the shared library when using\n+// -buildmode=shared.  The rules we use are:\n+//  1) Drop any trailing \"/...\"s if present\n+//  2) Change / to -\n+//  3) Join arguments with ,\n+// So std -> libstd.so\n+//    a b/... -> liba,b.so\n+//    gopkg.in/tomb.v2 -> libgopkg.in-tomb.v2.so\n+func libname(args []string) string {\n+\tvar libname string\n+\tfor _, arg := range args {\n+\t\targ = strings.TrimSuffix(arg, \"/...\")\n+\t\targ = strings.Replace(arg, \"/\", \"-\", -1)\n+\t\tif libname == \"\" {\n+\t\t\tlibname = arg\n+\t\t} else {\n+\t\t\tlibname += \",\" + arg\n+\t\t}\n+\t}\n+\t// TODO(mwhudson): Needs to change for platforms that use different naming\n+\t// conventions...\n+\treturn \"lib\" + libname + \".so\"\n+}\n+\n func runInstall(cmd *Command, args []string) {\n \traceInit()\n-\tpkgs := packagesForBuild(args)\n+\tbuildModeInit()\n+\tpkgs := pkgsFilter(packagesForBuild(args))\n \n \tfor _, p := range pkgs {\n \t\tif p.Target == \"\" && (!p.Standard || p.ImportPath != \"unsafe\") {\n-\t\t\tif p.cmdline {\n+\t\t\tswitch {\n+\t\t\tcase p.gobinSubdir:\n+\t\t\t\terrorf(\"go install: cannot install cross-compiled binaries when GOBIN is set\")\n+\t\t\tcase p.cmdline:\n \t\t\t\terrorf(\"go install: no install location for .go files listed on command line (GOBIN not set)\")\n-\t\t\t} else if p.ConflictDir != \"\" {\n+\t\t\tcase p.ConflictDir != \"\":\n \t\t\t\terrorf(\"go install: no install location for %s: hidden by %s\", p.Dir, p.ConflictDir)\n-\t\t\t} else {\n-\t\t\t\terrorf(\"go install: no install location for directory %s outside GOPATH\", p.Dir)\n+\t\t\tdefault:\n+\t\t\t\terrorf(\"go install: no install location for directory %s outside GOPATH\\n\"+\n+\t\t\t\t\t\"\\tFor more details see: go help gopath\", p.Dir)\n \t\t\t}\n \t\t}\n \t}\n \texitIfErrors()\n \n \tvar b builder\n \tb.init()\n-\ta := &action{}\n-\tfor _, p := range pkgs {\n-\t\ta.deps = append(a.deps, b.action(modeInstall, modeInstall, p))\n+\tvar a *action\n+\tif buildBuildmode == \"shared\" {\n+\t\ta = b.libaction(libname(args), pkgs, modeInstall, modeInstall)\n+\t} else {\n+\t\ta = &action{}\n+\t\tvar tools []*action\n+\t\tfor _, p := range pkgs {\n+\t\t\t// If p is a tool, delay the installation until the end of the build.\n+\t\t\t// This avoids installing assemblers/compilers that are being executed\n+\t\t\t// by other steps in the build.\n+\t\t\t// cmd/cgo is handled specially in b.action, so that we can\n+\t\t\t// both build and use it in the same 'go install'.\n+\t\t\taction := b.action(modeInstall, modeInstall, p)\n+\t\t\tif goTools[p.ImportPath] == toTool && p.ImportPath != \"cmd/cgo\" {\n+\t\t\t\ta.deps = append(a.deps, action.deps...)\n+\t\t\t\taction.deps = append(action.deps, a)\n+\t\t\t\ttools = append(tools, action)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\ta.deps = append(a.deps, action)\n+\t\t}\n+\t\tif len(tools) > 0 {\n+\t\t\ta = &action{\n+\t\t\t\tdeps: tools,\n+\t\t\t}\n+\t\t}\n \t}\n \tb.do(a)\n+\texitIfErrors()\n+\n+\t// Success. If this command is 'go install' with no arguments\n+\t// and the current directory (the implicit argument) is a command,\n+\t// remove any leftover command binary from a previous 'go build'.\n+\t// The binary is installed; it's not needed here anymore.\n+\t// And worse it might be a stale copy, which you don't want to find\n+\t// instead of the installed one if $PATH contains dot.\n+\t// One way to view this behavior is that it is as if 'go install' first\n+\t// runs 'go build' and the moves the generated file to the install dir.\n+\t// See issue 9645.\n+\tif len(args) == 0 && len(pkgs) == 1 && pkgs[0].Name == \"main\" {\n+\t\t// Compute file 'go build' would have created.\n+\t\t// If it exists and is an executable file, remove it.\n+\t\t_, targ := filepath.Split(pkgs[0].ImportPath)\n+\t\ttarg += exeSuffix\n+\t\tif filepath.Join(pkgs[0].Dir, targ) != pkgs[0].Target { // maybe $GOBIN is the current directory\n+\t\t\tfi, err := os.Stat(targ)\n+\t\t\tif err == nil {\n+\t\t\t\tm := fi.Mode()\n+\t\t\t\tif m.IsRegular() {\n+\t\t\t\t\tif m&0111 != 0 || goos == \"windows\" { // windows never sets executable bit\n+\t\t\t\t\t\tos.Remove(targ)\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n }\n \n // Global build parameters (used during package load)\n var (\n \tgoarch    string\n \tgoos      string\n-\tarchChar  string\n \texeSuffix string\n )\n \n@@ -373,16 +607,6 @@ func init() {\n \tif goos == \"windows\" {\n \t\texeSuffix = \".exe\"\n \t}\n-\tvar err error\n-\tarchChar, err = build.ArchChar(goarch)\n-\tif err != nil {\n-\t\tif _, isgc := buildToolchain.(gcToolchain); isgc {\n-\t\t\tfatalf(\"%s\", err)\n-\t\t}\n-\t\t// archChar is only required for gcToolchain, if we're using\n-\t\t// another toolchain leave it blank.\n-\t\tarchChar = \"\"\n-\t}\n }\n \n // A builder holds global state about a build.\n@@ -429,8 +653,9 @@ type action struct {\n \n // cacheKey is the key for the action cache.\n type cacheKey struct {\n-\tmode buildMode\n-\tp    *Package\n+\tmode  buildMode\n+\tp     *Package\n+\tshlib string\n }\n \n // buildMode specifies the build mode:\n@@ -505,6 +730,9 @@ func goFilesPackage(gofiles []string) *Package {\n \t\t\tfatalf(\"%s is a directory, should be a Go file\", file)\n \t\t}\n \t\tdir1, _ := filepath.Split(file)\n+\t\tif dir1 == \"\" {\n+\t\t\tdir1 = \"./\"\n+\t\t}\n \t\tif dir == \"\" {\n \t\t\tdir = dir1\n \t\t} else if dir != dir1 {\n@@ -541,55 +769,113 @@ func goFilesPackage(gofiles []string) *Package {\n \t\tif gobin != \"\" {\n \t\t\tpkg.target = filepath.Join(gobin, exe)\n \t\t}\n-\t} else {\n-\t\tif *buildO == \"\" {\n-\t\t\t*buildO = pkg.Name + \".a\"\n-\t\t}\n \t}\n+\n \tpkg.Target = pkg.target\n \tpkg.Stale = true\n \n \tcomputeStale(pkg)\n \treturn pkg\n }\n \n+// readpkglist returns the list of packages that were built into the shared library\n+// at shlibpath. For the native toolchain this list is stored, newline separated, in\n+// an ELF note with name \"Go\\x00\\x00\" and type 1. For GCCGO it is extracted from the\n+// .go_export section.\n+func readpkglist(shlibpath string) (pkgs []*Package) {\n+\tvar stk importStack\n+\tif _, gccgo := buildToolchain.(gccgoToolchain); gccgo {\n+\t\tf, _ := elf.Open(shlibpath)\n+\t\tsect := f.Section(\".go_export\")\n+\t\tdata, _ := sect.Data()\n+\t\tscanner := bufio.NewScanner(bytes.NewBuffer(data))\n+\t\tfor scanner.Scan() {\n+\t\t\tt := scanner.Text()\n+\t\t\tif strings.HasPrefix(t, \"pkgpath \") {\n+\t\t\t\tt = strings.TrimPrefix(t, \"pkgpath \")\n+\t\t\t\tt = strings.TrimSuffix(t, \";\")\n+\t\t\t\tpkgs = append(pkgs, loadPackage(t, &stk))\n+\t\t\t}\n+\t\t}\n+\t} else {\n+\t\tpkglistbytes, err := readELFNote(shlibpath, \"Go\\x00\\x00\", 1)\n+\t\tif err != nil {\n+\t\t\tfatalf(\"readELFNote failed: %v\", err)\n+\t\t}\n+\t\tscanner := bufio.NewScanner(bytes.NewBuffer(pkglistbytes))\n+\t\tfor scanner.Scan() {\n+\t\t\tt := scanner.Text()\n+\t\t\tpkgs = append(pkgs, loadPackage(t, &stk))\n+\t\t}\n+\t}\n+\treturn\n+}\n+\n // action returns the action for applying the given operation (mode) to the package.\n // depMode is the action to use when building dependencies.\n+// action never looks for p in a shared library.\n func (b *builder) action(mode buildMode, depMode buildMode, p *Package) *action {\n-\tkey := cacheKey{mode, p}\n+\treturn b.action1(mode, depMode, p, false)\n+}\n+\n+// action1 returns the action for applying the given operation (mode) to the package.\n+// depMode is the action to use when building dependencies.\n+// action1 will look for p in a shared library if lookshared is true.\n+func (b *builder) action1(mode buildMode, depMode buildMode, p *Package, lookshared bool) *action {\n+\tshlib := \"\"\n+\tif lookshared {\n+\t\tshlib = p.Shlib\n+\t}\n+\tkey := cacheKey{mode, p, shlib}\n+\n \ta := b.actionCache[key]\n \tif a != nil {\n \t\treturn a\n \t}\n+\tif shlib != \"\" {\n+\t\tkey2 := cacheKey{modeInstall, nil, shlib}\n+\t\ta = b.actionCache[key2]\n+\t\tif a != nil {\n+\t\t\tb.actionCache[key] = a\n+\t\t\treturn a\n+\t\t}\n+\t\tpkgs := readpkglist(shlib)\n+\t\ta = b.libaction(filepath.Base(shlib), pkgs, modeInstall, depMode)\n+\t\tb.actionCache[key2] = a\n+\t\tb.actionCache[key] = a\n+\t\treturn a\n+\t}\n \n \ta = &action{p: p, pkgdir: p.build.PkgRoot}\n \tif p.pkgdir != \"\" { // overrides p.t\n \t\ta.pkgdir = p.pkgdir\n \t}\n-\n \tb.actionCache[key] = a\n \n \tfor _, p1 := range p.imports {\n-\t\ta.deps = append(a.deps, b.action(depMode, depMode, p1))\n+\t\tls := buildLinkshared\n+\t\t// If p1 is part of the same shared library as p, we need the action\n+\t\t// that builds p here, not the shared libary or we get action loops.\n+\t\tif p1.Shlib == p.Shlib {\n+\t\t\tls = false\n+\t\t}\n+\t\ta.deps = append(a.deps, b.action1(depMode, depMode, p1, ls))\n \t}\n \n \t// If we are not doing a cross-build, then record the binary we'll\n \t// generate for cgo as a dependency of the build of any package\n \t// using cgo, to make sure we do not overwrite the binary while\n \t// a package is using it.  If this is a cross-build, then the cgo we\n \t// are writing is not the cgo we need to use.\n-\n-\tif goos == runtime.GOOS && goarch == runtime.GOARCH && !buildRace {\n-\t\tif reqStdPkgSrc {\n-\t\t\tif len(p.CgoFiles) > 0 || p.Standard && p.ImportPath == \"runtime/cgo\" {\n-\t\t\t\tvar stk importStack\n-\t\t\t\tp1 := loadPackage(\"cmd/cgo\", &stk)\n-\t\t\t\tif p1.Error != nil {\n-\t\t\t\t\tfatalf(\"load cmd/cgo: %v\", p1.Error)\n-\t\t\t\t}\n-\t\t\t\ta.cgo = b.action(depMode, depMode, p1)\n-\t\t\t\ta.deps = append(a.deps, a.cgo)\n+\tif goos == runtime.GOOS && goarch == runtime.GOARCH && !buildRace && reqStdPkgSrc {\n+\t\tif (len(p.CgoFiles) > 0 || p.Standard && p.ImportPath == \"runtime/cgo\") && !buildLinkshared && buildBuildmode != \"shared\" {\n+\t\t\tvar stk importStack\n+\t\t\tp1 := loadPackage(\"cmd/cgo\", &stk)\n+\t\t\tif p1.Error != nil {\n+\t\t\t\tfatalf(\"load cmd/cgo: %v\", p1.Error)\n \t\t\t}\n+\t\t\ta.cgo = b.action(depMode, depMode, p1)\n+\t\t\ta.deps = append(a.deps, a.cgo)\n \t\t}\n \t}\n \n@@ -629,8 +915,22 @@ func (b *builder) action(mode buildMode, depMode buildMode, p *Package) *action\n \tswitch mode {\n \tcase modeInstall:\n \t\ta.f = (*builder).install\n-\t\ta.deps = []*action{b.action(modeBuild, depMode, p)}\n+\t\ta.deps = []*action{b.action1(modeBuild, depMode, p, lookshared)}\n \t\ta.target = a.p.target\n+\n+\t\t// Install header for cgo in c-archive and c-shared modes.\n+\t\tif p.usesCgo() && (buildBuildmode == \"c-archive\" || buildBuildmode == \"c-shared\") {\n+\t\t\tah := &action{\n+\t\t\t\tp:      a.p,\n+\t\t\t\tdeps:   []*action{a.deps[0]},\n+\t\t\t\tf:      (*builder).installHeader,\n+\t\t\t\tpkgdir: a.pkgdir,\n+\t\t\t\tobjdir: a.objdir,\n+\t\t\t\ttarget: a.target[:len(a.target)-len(filepath.Ext(a.target))] + \".h\",\n+\t\t\t}\n+\t\t\ta.deps = append(a.deps, ah)\n+\t\t}\n+\n \tcase modeBuild:\n \t\ta.f = (*builder).build\n \t\ta.target = a.objpkg\n@@ -645,6 +945,13 @@ func (b *builder) action(mode buildMode, depMode buildMode, p *Package) *action\n \t\t\tname := \"a.out\"\n \t\t\tif p.exeName != \"\" {\n \t\t\t\tname = p.exeName\n+\t\t\t} else if goos == \"darwin\" && buildBuildmode == \"c-shared\" && p.target != \"\" {\n+\t\t\t\t// On OS X, the linker output name gets recorded in the\n+\t\t\t\t// shared library's LC_ID_DYLIB load command.\n+\t\t\t\t// The code invoking the linker knows to pass only the final\n+\t\t\t\t// path element. Arrange that the path element matches what\n+\t\t\t\t// we'll install it as; otherwise the library is only loadable as \"a.out\".\n+\t\t\t\t_, name = filepath.Split(p.target)\n \t\t\t}\n \t\t\ta.target = a.objdir + filepath.Join(\"exe\", name) + exeSuffix\n \t\t}\n@@ -653,6 +960,100 @@ func (b *builder) action(mode buildMode, depMode buildMode, p *Package) *action\n \treturn a\n }\n \n+func (b *builder) libaction(libname string, pkgs []*Package, mode, depMode buildMode) *action {\n+\ta := &action{}\n+\tif mode == modeBuild {\n+\t\ta.f = (*builder).linkShared\n+\t\ta.target = filepath.Join(b.work, libname)\n+\t\tfor _, p := range pkgs {\n+\t\t\tif p.target == \"\" {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\ta.deps = append(a.deps, b.action(depMode, depMode, p))\n+\t\t}\n+\t} else if mode == modeInstall {\n+\t\t// Currently build mode shared forces external linking mode, and\n+\t\t// external linking mode forces an import of runtime/cgo. So if it\n+\t\t// was not passed on the command line and it is not present in\n+\t\t// another shared library, add it here.\n+\t\tseencgo := false\n+\t\t_, gccgo := buildToolchain.(gccgoToolchain)\n+\t\tif !gccgo {\n+\t\t\tfor _, p := range pkgs {\n+\t\t\t\tseencgo = seencgo || (p.Standard && p.ImportPath == \"runtime/cgo\")\n+\t\t\t}\n+\t\t\tif !seencgo {\n+\t\t\t\tvar stk importStack\n+\t\t\t\tp := loadPackage(\"runtime/cgo\", &stk)\n+\t\t\t\tif p.Error != nil {\n+\t\t\t\t\tfatalf(\"load runtime/cgo: %v\", p.Error)\n+\t\t\t\t}\n+\t\t\t\tcomputeStale(p)\n+\t\t\t\t// If runtime/cgo is in another shared library, then that's\n+\t\t\t\t// also the shared library that contains runtime, so\n+\t\t\t\t// something will depend on it and so runtime/cgo's staleness\n+\t\t\t\t// will be checked when processing that library.\n+\t\t\t\tif p.Shlib == \"\" || p.Shlib == libname {\n+\t\t\t\t\tpkgs = append([]*Package{}, pkgs...)\n+\t\t\t\t\tpkgs = append(pkgs, p)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Figure out where the library will go.\n+\t\tvar libdir string\n+\t\tfor _, p := range pkgs {\n+\t\t\tplibdir := p.build.PkgTargetRoot\n+\t\t\tif gccgo {\n+\t\t\t\tplibdir = filepath.Join(plibdir, \"shlibs\")\n+\t\t\t}\n+\t\t\tif libdir == \"\" {\n+\t\t\t\tlibdir = plibdir\n+\t\t\t} else if libdir != plibdir {\n+\t\t\t\tfatalf(\"multiple roots %s & %s\", libdir, plibdir)\n+\t\t\t}\n+\t\t}\n+\t\ta.target = filepath.Join(libdir, libname)\n+\n+\t\t// Now we can check whether we need to rebuild it.\n+\t\tstale := false\n+\t\tvar built time.Time\n+\t\tif fi, err := os.Stat(a.target); err == nil {\n+\t\t\tbuilt = fi.ModTime()\n+\t\t}\n+\t\tfor _, p := range pkgs {\n+\t\t\tif p.target == \"\" {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tstale = stale || p.Stale\n+\t\t\tlstat, err := os.Stat(p.target)\n+\t\t\tif err != nil || lstat.ModTime().After(built) {\n+\t\t\t\tstale = true\n+\t\t\t}\n+\t\t\ta.deps = append(a.deps, b.action(depMode, depMode, p))\n+\t\t}\n+\n+\t\tif stale {\n+\t\t\ta.f = (*builder).install\n+\t\t\tbuildAction := b.libaction(libname, pkgs, modeBuild, depMode)\n+\t\t\ta.deps = []*action{buildAction}\n+\t\t\tfor _, p := range pkgs {\n+\t\t\t\tif p.target == \"\" {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tshlibnameaction := &action{}\n+\t\t\t\tshlibnameaction.f = (*builder).installShlibname\n+\t\t\t\tshlibnameaction.target = p.target[:len(p.target)-2] + \".shlibname\"\n+\t\t\t\ta.deps = append(a.deps, shlibnameaction)\n+\t\t\t\tshlibnameaction.deps = append(shlibnameaction.deps, buildAction)\n+\t\t\t}\n+\t\t}\n+\t} else {\n+\t\tfatalf(\"unregonized mode %v\", mode)\n+\t}\n+\treturn a\n+}\n+\n // actionList returns the list of actions in the dag rooted at root\n // as visited in a depth-first post-order traversal.\n func actionList(root *action) []*action {\n@@ -673,6 +1074,31 @@ func actionList(root *action) []*action {\n \treturn all\n }\n \n+// allArchiveActions returns a list of the archive dependencies of root.\n+// This is needed because if package p depends on package q that is in libr.so, the\n+// action graph looks like p->libr.so->q and so just scanning through p's\n+// dependencies does not find the import dir for q.\n+func allArchiveActions(root *action) []*action {\n+\tseen := map[*action]bool{}\n+\tr := []*action{}\n+\tvar walk func(*action)\n+\twalk = func(a *action) {\n+\t\tif seen[a] {\n+\t\t\treturn\n+\t\t}\n+\t\tseen[a] = true\n+\t\tif strings.HasSuffix(a.target, \".so\") || a == root {\n+\t\t\tfor _, a1 := range a.deps {\n+\t\t\t\twalk(a1)\n+\t\t\t}\n+\t\t} else if strings.HasSuffix(a.target, \".a\") {\n+\t\t\tr = append(r, a)\n+\t\t}\n+\t}\n+\twalk(root)\n+\treturn r\n+}\n+\n // do runs the action graph rooted at root.\n func (b *builder) do(root *action) {\n \t// Build list of all actions, assigning depth-first post-order priority.\n@@ -793,9 +1219,7 @@ func hasString(strings []string, s string) bool {\n func (b *builder) build(a *action) (err error) {\n \t// Return an error if the package has CXX files but it's not using\n \t// cgo nor SWIG, since the CXX files can only be processed by cgo\n-\t// and SWIG (it's possible to have packages with C files without\n-\t// using cgo, they will get compiled with the plan9 C compiler and\n-\t// linked with the rest of the package).\n+\t// and SWIG.\n \tif len(a.p.CXXFiles) > 0 && !a.p.usesCgo() && !a.p.usesSwig() {\n \t\treturn fmt.Errorf(\"can't build package %s because it contains C++ files (%s) but it's not using cgo nor SWIG\",\n \t\t\ta.p.ImportPath, strings.Join(a.p.CXXFiles, \",\"))\n@@ -824,7 +1248,8 @@ func (b *builder) build(a *action) (err error) {\n \t}\n \n \tif a.p.Standard && a.p.ImportPath == \"runtime\" && buildContext.Compiler == \"gc\" &&\n-\t\t!hasString(a.p.HFiles, \"zasm_\"+buildContext.GOOS+\"_\"+buildContext.GOARCH+\".h\") {\n+\t\t(!hasString(a.p.GoFiles, \"zgoos_\"+buildContext.GOOS+\".go\") ||\n+\t\t\t!hasString(a.p.GoFiles, \"zgoarch_\"+buildContext.GOARCH+\".go\")) {\n \t\treturn fmt.Errorf(\"%s/%s must be bootstrapped using make%v\", buildContext.GOOS, buildContext.GOARCH, defaultSuffix())\n \t}\n \n@@ -842,19 +1267,35 @@ func (b *builder) build(a *action) (err error) {\n \t\t}\n \t}\n \n-\tvar gofiles, cfiles, sfiles, objects, cgoObjects, pcCFLAGS, pcLDFLAGS []string\n+\tvar gofiles, cgofiles, cfiles, sfiles, cxxfiles, objects, cgoObjects, pcCFLAGS, pcLDFLAGS []string\n \n \tgofiles = append(gofiles, a.p.GoFiles...)\n+\tcgofiles = append(cgofiles, a.p.CgoFiles...)\n \tcfiles = append(cfiles, a.p.CFiles...)\n \tsfiles = append(sfiles, a.p.SFiles...)\n+\tcxxfiles = append(cxxfiles, a.p.CXXFiles...)\n \n \tif a.p.usesCgo() || a.p.usesSwig() {\n \t\tif pcCFLAGS, pcLDFLAGS, err = b.getPkgConfigFlags(a.p); err != nil {\n \t\t\treturn\n \t\t}\n \t}\n+\n+\t// Run SWIG on each .swig and .swigcxx file.\n+\t// Each run will generate two files, a .go file and a .c or .cxx file.\n+\t// The .go file will use import \"C\" and is to be processed by cgo.\n+\tif a.p.usesSwig() {\n+\t\toutGo, outC, outCXX, err := b.swig(a.p, obj, pcCFLAGS)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tcgofiles = append(cgofiles, outGo...)\n+\t\tcfiles = append(cfiles, outC...)\n+\t\tcxxfiles = append(cxxfiles, outCXX...)\n+\t}\n+\n \t// Run cgo.\n-\tif a.p.usesCgo() {\n+\tif a.p.usesCgo() || a.p.usesSwig() {\n \t\t// In a package using cgo, cgo compiles the C, C++ and assembly files with gcc.\n \t\t// There is one exception: runtime/cgo's job is to bridge the\n \t\t// cgo and non-cgo worlds, so it necessarily has files in both.\n@@ -883,31 +1324,7 @@ func (b *builder) build(a *action) (err error) {\n \t\tif a.cgo != nil && a.cgo.target != \"\" {\n \t\t\tcgoExe = a.cgo.target\n \t\t}\n-\t\toutGo, outObj, err := b.cgo(a.p, cgoExe, obj, pcCFLAGS, pcLDFLAGS, gccfiles, a.p.CXXFiles, a.p.MFiles)\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\tcgoObjects = append(cgoObjects, outObj...)\n-\t\tgofiles = append(gofiles, outGo...)\n-\t}\n-\n-\t// Run SWIG.\n-\tif a.p.usesSwig() {\n-\t\t// In a package using SWIG, any .c or .s files are\n-\t\t// compiled with gcc.\n-\t\tgccfiles := append(cfiles, sfiles...)\n-\t\tcxxfiles, mfiles := a.p.CXXFiles, a.p.MFiles\n-\t\tcfiles = nil\n-\t\tsfiles = nil\n-\n-\t\t// Don't build c/c++ files twice if cgo is enabled (mainly for pkg-config).\n-\t\tif a.p.usesCgo() {\n-\t\t\tcxxfiles = nil\n-\t\t\tgccfiles = nil\n-\t\t\tmfiles = nil\n-\t\t}\n-\n-\t\toutGo, outObj, err := b.swig(a.p, obj, pcCFLAGS, gccfiles, cxxfiles, mfiles)\n+\t\toutGo, outObj, err := b.cgo(a.p, cgoExe, obj, pcCFLAGS, pcLDFLAGS, cgofiles, gccfiles, cxxfiles, a.p.MFiles)\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n@@ -949,10 +1366,10 @@ func (b *builder) build(a *action) (err error) {\n \t}\n \n \t// Prepare Go import path list.\n-\tinc := b.includeArgs(\"-I\", a.deps)\n+\tinc := b.includeArgs(\"-I\", allArchiveActions(a))\n \n \t// Compile Go.\n-\tofile, out, err := buildToolchain.gc(b, a.p, a.objpkg, obj, inc, gofiles)\n+\tofile, out, err := buildToolchain.gc(b, a.p, a.objpkg, obj, len(sfiles) > 0, inc, gofiles)\n \tif len(out) > 0 {\n \t\tb.showOutput(a.p.Dir, a.p.ImportPath, b.processOutput(out))\n \t\tif err != nil {\n@@ -977,29 +1394,24 @@ func (b *builder) build(a *action) (err error) {\n \t\tswitch {\n \t\tcase strings.HasSuffix(name, _goos_goarch):\n \t\t\ttarg := file[:len(name)-len(_goos_goarch)] + \"_GOOS_GOARCH.\" + ext\n-\t\t\tif err := b.copyFile(a, obj+targ, filepath.Join(a.p.Dir, file), 0644); err != nil {\n+\t\t\tif err := b.copyFile(a, obj+targ, filepath.Join(a.p.Dir, file), 0644, true); err != nil {\n \t\t\t\treturn err\n \t\t\t}\n \t\tcase strings.HasSuffix(name, _goarch):\n \t\t\ttarg := file[:len(name)-len(_goarch)] + \"_GOARCH.\" + ext\n-\t\t\tif err := b.copyFile(a, obj+targ, filepath.Join(a.p.Dir, file), 0644); err != nil {\n+\t\t\tif err := b.copyFile(a, obj+targ, filepath.Join(a.p.Dir, file), 0644, true); err != nil {\n \t\t\t\treturn err\n \t\t\t}\n \t\tcase strings.HasSuffix(name, _goos):\n \t\t\ttarg := file[:len(name)-len(_goos)] + \"_GOOS.\" + ext\n-\t\t\tif err := b.copyFile(a, obj+targ, filepath.Join(a.p.Dir, file), 0644); err != nil {\n+\t\t\tif err := b.copyFile(a, obj+targ, filepath.Join(a.p.Dir, file), 0644, true); err != nil {\n \t\t\t\treturn err\n \t\t\t}\n \t\t}\n \t}\n \n-\tobjExt := archChar\n-\tif _, ok := buildToolchain.(gccgoToolchain); ok {\n-\t\tobjExt = \"o\"\n-\t}\n-\n \tfor _, file := range cfiles {\n-\t\tout := file[:len(file)-len(\".c\")] + \".\" + objExt\n+\t\tout := file[:len(file)-len(\".c\")] + \".o\"\n \t\tif err := buildToolchain.cc(b, a.p, obj, obj+out, file); err != nil {\n \t\t\treturn err\n \t\t}\n@@ -1008,7 +1420,7 @@ func (b *builder) build(a *action) (err error) {\n \n \t// Assemble .s files.\n \tfor _, file := range sfiles {\n-\t\tout := file[:len(file)-len(\".s\")] + \".\" + objExt\n+\t\tout := file[:len(file)-len(\".s\")] + \".o\"\n \t\tif err := buildToolchain.asm(b, a.p, obj, obj+out, file); err != nil {\n \t\t\treturn err\n \t\t}\n@@ -1018,7 +1430,7 @@ func (b *builder) build(a *action) (err error) {\n \t// NOTE(rsc): On Windows, it is critically important that the\n \t// gcc-compiled objects (cgoObjects) be listed after the ordinary\n \t// objects in the archive.  I do not know why this is.\n-\t// http://golang.org/issue/2601\n+\t// https://golang.org/issue/2601\n \tobjects = append(objects, cgoObjects...)\n \n \t// Add system object files.\n@@ -1043,7 +1455,7 @@ func (b *builder) build(a *action) (err error) {\n \t\t// linker needs the whole dependency tree.\n \t\tall := actionList(a)\n \t\tall = all[:len(all)-1] // drop a\n-\t\tif err := buildToolchain.ld(b, a.p, a.target, all, a.objpkg, objects); err != nil {\n+\t\tif err := buildToolchain.ld(b, a, a.target, all, a.objpkg, objects); err != nil {\n \t\t\treturn err\n \t\t}\n \t}\n@@ -1079,6 +1491,24 @@ func (b *builder) getPkgConfigFlags(p *Package) (cflags, ldflags []string, err e\n \treturn\n }\n \n+func (b *builder) installShlibname(a *action) error {\n+\ta1 := a.deps[0]\n+\terr := ioutil.WriteFile(a.target, []byte(filepath.Base(a1.target)+\"\\n\"), 0644)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif buildX {\n+\t\tb.showcmd(\"\", \"echo '%s' > %s # internal\", filepath.Base(a1.target), a.target)\n+\t}\n+\treturn nil\n+}\n+\n+func (b *builder) linkShared(a *action) (err error) {\n+\tallactions := actionList(a)\n+\tallactions = allactions[:len(allactions)-1]\n+\treturn buildToolchain.ldShared(b, a.deps, a.target, allactions)\n+}\n+\n // install is the action for installing a single package or executable.\n func (b *builder) install(a *action) (err error) {\n \tdefer func() {\n@@ -1089,7 +1519,11 @@ func (b *builder) install(a *action) (err error) {\n \ta1 := a.deps[0]\n \tperm := os.FileMode(0644)\n \tif a1.link {\n-\t\tperm = 0755\n+\t\tswitch buildBuildmode {\n+\t\tcase \"c-archive\", \"c-shared\":\n+\t\tdefault:\n+\t\t\tperm = 0755\n+\t\t}\n \t}\n \n \t// make target directory\n@@ -1109,7 +1543,7 @@ func (b *builder) install(a *action) (err error) {\n \t\tdefer os.Remove(a1.target)\n \t}\n \n-\treturn b.moveOrCopyFile(a, a.target, a1.target, perm)\n+\treturn b.moveOrCopyFile(a, a.target, a1.target, perm, false)\n }\n \n // includeArgs returns the -I or -L directory list for access\n@@ -1126,6 +1560,9 @@ func (b *builder) includeArgs(flag string, all []*action) []string {\n \t// This is the $WORK/my/package/_test directory for the\n \t// package being built, so there are few of these.\n \tfor _, a1 := range all {\n+\t\tif a1.p == nil {\n+\t\t\tcontinue\n+\t\t}\n \t\tif dir := a1.pkgdir; dir != a1.p.build.PkgRoot && !incMap[dir] {\n \t\t\tincMap[dir] = true\n \t\t\tinc = append(inc, flag, dir)\n@@ -1138,25 +1575,20 @@ func (b *builder) includeArgs(flag string, all []*action) []string {\n \n \t// Finally, look in the installed package directories for each action.\n \tfor _, a1 := range all {\n+\t\tif a1.p == nil {\n+\t\t\tcontinue\n+\t\t}\n \t\tif dir := a1.pkgdir; dir == a1.p.build.PkgRoot && !incMap[dir] {\n \t\t\tincMap[dir] = true\n-\t\t\tif _, ok := buildToolchain.(gccgoToolchain); ok {\n-\t\t\t\tdir = filepath.Join(dir, \"gccgo_\"+goos+\"_\"+goarch)\n-\t\t\t} else {\n-\t\t\t\tdir = filepath.Join(dir, goos+\"_\"+goarch)\n-\t\t\t\tif buildContext.InstallSuffix != \"\" {\n-\t\t\t\t\tdir += \"_\" + buildContext.InstallSuffix\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tinc = append(inc, flag, dir)\n+\t\t\tinc = append(inc, flag, a1.p.build.PkgTargetRoot)\n \t\t}\n \t}\n \n \treturn inc\n }\n \n // moveOrCopyFile is like 'mv src dst' or 'cp src dst'.\n-func (b *builder) moveOrCopyFile(a *action, dst, src string, perm os.FileMode) error {\n+func (b *builder) moveOrCopyFile(a *action, dst, src string, perm os.FileMode, force bool) error {\n \tif buildN {\n \t\tb.showcmd(\"\", \"mv %s %s\", src, dst)\n \t\treturn nil\n@@ -1173,11 +1605,11 @@ func (b *builder) moveOrCopyFile(a *action, dst, src string, perm os.FileMode) e\n \t\t}\n \t}\n \n-\treturn b.copyFile(a, dst, src, perm)\n+\treturn b.copyFile(a, dst, src, perm, force)\n }\n \n // copyFile is like 'cp src dst'.\n-func (b *builder) copyFile(a *action, dst, src string, perm os.FileMode) error {\n+func (b *builder) copyFile(a *action, dst, src string, perm os.FileMode, force bool) error {\n \tif buildN || buildX {\n \t\tb.showcmd(\"\", \"cp %s %s\", src, dst)\n \t\tif buildN {\n@@ -1198,7 +1630,7 @@ func (b *builder) copyFile(a *action, dst, src string, perm os.FileMode) error {\n \t\tif fi.IsDir() {\n \t\t\treturn fmt.Errorf(\"build output %q already exists and is a directory\", dst)\n \t\t}\n-\t\tif !isObject(dst) {\n+\t\tif !force && !isObject(dst) {\n \t\t\treturn fmt.Errorf(\"build output %q already exists and is not an object file\", dst)\n \t\t}\n \t}\n@@ -1235,10 +1667,30 @@ func (b *builder) copyFile(a *action, dst, src string, perm os.FileMode) error {\n \treturn nil\n }\n \n+// Install the cgo export header file, if there is one.\n+func (b *builder) installHeader(a *action) error {\n+\tsrc := a.objdir + \"_cgo_install.h\"\n+\tif _, err := os.Stat(src); os.IsNotExist(err) {\n+\t\t// If the file does not exist, there are no exported\n+\t\t// functions, and we do not install anything.\n+\t\treturn nil\n+\t}\n+\n+\tdir, _ := filepath.Split(a.target)\n+\tif dir != \"\" {\n+\t\tif err := b.mkdir(dir); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\treturn b.moveOrCopyFile(a, a.target, src, 0644, true)\n+}\n+\n // cover runs, in effect,\n //\tgo tool cover -mode=b.coverMode -var=\"varName\" -o dst.go src.go\n func (b *builder) cover(a *action, dst, src string, perm os.FileMode, varName string) error {\n \treturn b.run(a.objdir, \"cover \"+a.p.ImportPath, nil,\n+\t\tbuildToolExec,\n \t\ttool(\"cover\"),\n \t\t\"-mode\", a.p.coverMode,\n \t\t\"-var\", varName,\n@@ -1247,15 +1699,15 @@ func (b *builder) cover(a *action, dst, src string, perm os.FileMode, varName st\n }\n \n var objectMagic = [][]byte{\n-\t{'!', '<', 'a', 'r', 'c', 'h', '>', '\\n'},        // Package archive\n-\t{'\\x7F', 'E', 'L', 'F'},                          // ELF\n-\t{0xFE, 0xED, 0xFA, 0xCE},                         // Mach-O big-endian 32-bit\n-\t{0xFE, 0xED, 0xFA, 0xCF},                         // Mach-O big-endian 64-bit\n-\t{0xCE, 0xFA, 0xED, 0xFE},                         // Mach-O little-endian 32-bit\n-\t{0xCF, 0xFA, 0xED, 0xFE},                         // Mach-O little-endian 64-bit\n-\t{0x4d, 0x5a, 0x90, 0x00, 0x03, 0x00, 0x04, 0x00}, // PE (Windows) as generated by 6l/8l\n-\t{0x00, 0x00, 0x01, 0xEB},                         // Plan 9 i386\n-\t{0x00, 0x00, 0x8a, 0x97},                         // Plan 9 amd64\n+\t{'!', '<', 'a', 'r', 'c', 'h', '>', '\\n'}, // Package archive\n+\t{'\\x7F', 'E', 'L', 'F'},                   // ELF\n+\t{0xFE, 0xED, 0xFA, 0xCE},                  // Mach-O big-endian 32-bit\n+\t{0xFE, 0xED, 0xFA, 0xCF},                  // Mach-O big-endian 64-bit\n+\t{0xCE, 0xFA, 0xED, 0xFE},                  // Mach-O little-endian 32-bit\n+\t{0xCF, 0xFA, 0xED, 0xFE},                  // Mach-O little-endian 64-bit\n+\t{0x4d, 0x5a, 0x90, 0x00, 0x03, 0x00},      // PE (Windows) as generated by 6l/8l and gcc\n+\t{0x00, 0x00, 0x01, 0xEB},                  // Plan 9 i386\n+\t{0x00, 0x00, 0x8a, 0x97},                  // Plan 9 amd64\n }\n \n func isObject(s string) bool {\n@@ -1436,7 +1888,7 @@ func (b *builder) runOut(dir string, desc string, env []string, cmdargs ...inter\n \t\tcmd.Stdout = &buf\n \t\tcmd.Stderr = &buf\n \t\tcmd.Dir = dir\n-\t\tcmd.Env = mergeEnvLists(env, envForDir(cmd.Dir))\n+\t\tcmd.Env = mergeEnvLists(env, envForDir(cmd.Dir, os.Environ()))\n \t\terr := cmd.Run()\n \n \t\t// cmd.Run will fail on Unix if some other process has the binary\n@@ -1478,7 +1930,7 @@ func (b *builder) runOut(dir string, desc string, env []string, cmdargs ...inter\n \t\t// Sleeping when we observe the race seems to be the most reliable\n \t\t// option we have.\n \t\t//\n-\t\t// http://golang.org/issue/3001\n+\t\t// https://golang.org/issue/3001\n \t\t//\n \t\tif err != nil && nbusy < 3 && strings.Contains(err.Error(), \"text file busy\") {\n \t\t\ttime.Sleep(100 * time.Millisecond << uint(nbusy))\n@@ -1561,7 +2013,7 @@ type toolchain interface {\n \t// gc runs the compiler in a specific directory on a set of files\n \t// and returns the name of the generated output file.\n \t// The compiler runs in the directory dir.\n-\tgc(b *builder, p *Package, archive, obj string, importArgs []string, gofiles []string) (ofile string, out []byte, err error)\n+\tgc(b *builder, p *Package, archive, obj string, asmhdr bool, importArgs []string, gofiles []string) (ofile string, out []byte, err error)\n \t// cc runs the toolchain's C compiler in a directory on a C file\n \t// to produce an output file.\n \tcc(b *builder, p *Package, objdir, ofile, cfile string) error\n@@ -1574,8 +2026,10 @@ type toolchain interface {\n \t// an archive from a set of object files.\n \t// typically it is run in the object directory.\n \tpack(b *builder, p *Package, objDir, afile string, ofiles []string) error\n-\t// ld runs the linker to create a package starting at mainpkg.\n-\tld(b *builder, p *Package, out string, allactions []*action, mainpkg string, ofiles []string) error\n+\t// ld runs the linker to create an executable starting at mainpkg.\n+\tld(b *builder, root *action, out string, allactions []*action, mainpkg string, ofiles []string) error\n+\t// ldShared runs the linker to create a shared library containing the pkgs built by toplevelactions\n+\tldShared(b *builder, toplevelactions []*action, out string, allactions []*action) error\n \n \tcompiler() string\n \tlinker() string\n@@ -1598,7 +2052,7 @@ func (noToolchain) linker() string {\n \treturn \"\"\n }\n \n-func (noToolchain) gc(b *builder, p *Package, archive, obj string, importArgs []string, gofiles []string) (ofile string, out []byte, err error) {\n+func (noToolchain) gc(b *builder, p *Package, archive, obj string, asmhdr bool, importArgs []string, gofiles []string) (ofile string, out []byte, err error) {\n \treturn \"\", nil, noCompiler()\n }\n \n@@ -1615,7 +2069,11 @@ func (noToolchain) pack(b *builder, p *Package, objDir, afile string, ofiles []s\n \treturn noCompiler()\n }\n \n-func (noToolchain) ld(b *builder, p *Package, out string, allactions []*action, mainpkg string, ofiles []string) error {\n+func (noToolchain) ld(b *builder, root *action, out string, allactions []*action, mainpkg string, ofiles []string) error {\n+\treturn noCompiler()\n+}\n+\n+func (noToolchain) ldShared(b *builder, toplevelactions []*action, out string, allactions []*action) error {\n \treturn noCompiler()\n }\n \n@@ -1627,24 +2085,27 @@ func (noToolchain) cc(b *builder, p *Package, objdir, ofile, cfile string) error\n type gcToolchain struct{}\n \n func (gcToolchain) compiler() string {\n-\treturn tool(archChar + \"g\")\n+\treturn tool(\"compile\")\n }\n \n func (gcToolchain) linker() string {\n-\treturn tool(archChar + \"l\")\n+\treturn tool(\"link\")\n }\n \n-func (gcToolchain) gc(b *builder, p *Package, archive, obj string, importArgs []string, gofiles []string) (ofile string, output []byte, err error) {\n+func (gcToolchain) gc(b *builder, p *Package, archive, obj string, asmhdr bool, importArgs []string, gofiles []string) (ofile string, output []byte, err error) {\n \tif archive != \"\" {\n \t\tofile = archive\n \t} else {\n-\t\tout := \"_go_.\" + archChar\n+\t\tout := \"_go_.o\"\n \t\tofile = obj + out\n \t}\n \n \tgcargs := []string{\"-p\", p.ImportPath}\n+\tif p.Name == \"main\" {\n+\t\tgcargs[1] = \"main\"\n+\t}\n \tif p.Standard && p.ImportPath == \"runtime\" {\n-\t\t// runtime compiles with a special 6g flag to emit\n+\t\t// runtime compiles with a special gc flag to emit\n \t\t// additional reflect type data.\n \t\tgcargs = append(gcargs, \"-+\")\n \t}\n@@ -1666,24 +2127,76 @@ func (gcToolchain) gc(b *builder, p *Package, archive, obj string, importArgs []\n \tif buildContext.InstallSuffix != \"\" {\n \t\tgcargs = append(gcargs, \"-installsuffix\", buildContext.InstallSuffix)\n \t}\n+\tif p.buildID != \"\" {\n+\t\tgcargs = append(gcargs, \"-buildid\", p.buildID)\n+\t}\n+\n+\tfor _, path := range p.Imports {\n+\t\tif i := strings.LastIndex(path, \"/vendor/\"); i >= 0 {\n+\t\t\tgcargs = append(gcargs, \"-importmap\", path[i+len(\"/vendor/\"):]+\"=\"+path)\n+\t\t} else if strings.HasPrefix(path, \"vendor/\") {\n+\t\t\tgcargs = append(gcargs, \"-importmap\", path[len(\"vendor/\"):]+\"=\"+path)\n+\t\t}\n+\t}\n+\n+\tfor _, path := range p.Imports {\n+\t\tif i := strings.LastIndex(path, \"/vendor/\"); i >= 0 {\n+\t\t\tgcargs = append(gcargs, \"-importmap\", path[i+len(\"/vendor/\"):]+\"=\"+path)\n+\t\t} else if strings.HasPrefix(path, \"vendor/\") {\n+\t\t\tgcargs = append(gcargs, \"-importmap\", path[len(\"vendor/\"):]+\"=\"+path)\n+\t\t}\n+\t}\n \n-\targs := stringList(tool(archChar+\"g\"), \"-o\", ofile, \"-trimpath\", b.work, buildGcflags, gcargs, \"-D\", p.localPrefix, importArgs)\n+\targs := []interface{}{buildToolExec, tool(\"compile\"), \"-o\", ofile, \"-trimpath\", b.work, buildGcflags, gcargs, \"-D\", p.localPrefix, importArgs}\n \tif ofile == archive {\n \t\targs = append(args, \"-pack\")\n \t}\n+\tif asmhdr {\n+\t\targs = append(args, \"-asmhdr\", obj+\"go_asm.h\")\n+\t}\n \tfor _, f := range gofiles {\n \t\targs = append(args, mkAbs(p.Dir, f))\n \t}\n \n-\toutput, err = b.runOut(p.Dir, p.ImportPath, nil, args)\n+\toutput, err = b.runOut(p.Dir, p.ImportPath, nil, args...)\n \treturn ofile, output, err\n }\n \n func (gcToolchain) asm(b *builder, p *Package, obj, ofile, sfile string) error {\n \t// Add -I pkg/GOOS_GOARCH so #include \"textflag.h\" works in .s files.\n-\tinc := filepath.Join(goroot, \"pkg\", fmt.Sprintf(\"%s_%s\", goos, goarch))\n+\tinc := filepath.Join(goroot, \"pkg\", \"include\")\n \tsfile = mkAbs(p.Dir, sfile)\n-\treturn b.run(p.Dir, p.ImportPath, nil, tool(archChar+\"a\"), \"-trimpath\", b.work, \"-I\", obj, \"-I\", inc, \"-o\", ofile, \"-D\", \"GOOS_\"+goos, \"-D\", \"GOARCH_\"+goarch, sfile)\n+\targs := []interface{}{buildToolExec, tool(\"asm\"), \"-o\", ofile, \"-trimpath\", b.work, \"-I\", obj, \"-I\", inc, \"-D\", \"GOOS_\" + goos, \"-D\", \"GOARCH_\" + goarch, buildAsmflags, sfile}\n+\tif err := b.run(p.Dir, p.ImportPath, nil, args...); err != nil {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+// toolVerify checks that the command line args writes the same output file\n+// if run using newTool instead.\n+// Unused now but kept around for future use.\n+func toolVerify(b *builder, p *Package, newTool string, ofile string, args []interface{}) error {\n+\tnewArgs := make([]interface{}, len(args))\n+\tcopy(newArgs, args)\n+\tnewArgs[1] = tool(newTool)\n+\tnewArgs[3] = ofile + \".new\" // x.6 becomes x.6.new\n+\tif err := b.run(p.Dir, p.ImportPath, nil, newArgs...); err != nil {\n+\t\treturn err\n+\t}\n+\tdata1, err := ioutil.ReadFile(ofile)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tdata2, err := ioutil.ReadFile(ofile + \".new\")\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif !bytes.Equal(data1, data2) {\n+\t\treturn fmt.Errorf(\"%s and %s produced different output files:\\n%s\\n%s\", filepath.Base(args[1].(string)), newTool, strings.Join(stringList(args...), \" \"), strings.Join(stringList(newArgs...), \" \"))\n+\t}\n+\tos.Remove(ofile + \".new\")\n+\treturn nil\n }\n \n func (gcToolchain) pkgpath(basedir string, p *Package) string {\n@@ -1722,7 +2235,7 @@ func (gcToolchain) pack(b *builder, p *Package, objDir, afile string, ofiles []s\n \n \t// Need actual pack.\n \tcmdline[0] = tool(\"pack\")\n-\treturn b.run(p.Dir, p.ImportPath, nil, cmdline)\n+\treturn b.run(p.Dir, p.ImportPath, nil, buildToolExec, cmdline)\n }\n \n func packInternal(b *builder, afile string, ofiles []string) error {\n@@ -1775,78 +2288,117 @@ func packInternal(b *builder, afile string, ofiles []string) error {\n \treturn dst.Close()\n }\n \n-func (gcToolchain) ld(b *builder, p *Package, out string, allactions []*action, mainpkg string, ofiles []string) error {\n+// setextld sets the appropriate linker flags for the specified compiler.\n+func setextld(ldflags []string, compiler []string) []string {\n+\tfor _, f := range ldflags {\n+\t\tif f == \"-extld\" || strings.HasPrefix(f, \"-extld=\") {\n+\t\t\t// don't override -extld if supplied\n+\t\t\treturn ldflags\n+\t\t}\n+\t}\n+\tldflags = append(ldflags, \"-extld=\"+compiler[0])\n+\tif len(compiler) > 1 {\n+\t\textldflags := false\n+\t\tadd := strings.Join(compiler[1:], \" \")\n+\t\tfor i, f := range ldflags {\n+\t\t\tif f == \"-extldflags\" && i+1 < len(ldflags) {\n+\t\t\t\tldflags[i+1] = add + \" \" + ldflags[i+1]\n+\t\t\t\textldflags = true\n+\t\t\t\tbreak\n+\t\t\t} else if strings.HasPrefix(f, \"-extldflags=\") {\n+\t\t\t\tldflags[i] = \"-extldflags=\" + add + \" \" + ldflags[i][len(\"-extldflags=\"):]\n+\t\t\t\textldflags = true\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t\tif !extldflags {\n+\t\t\tldflags = append(ldflags, \"-extldflags=\"+add)\n+\t\t}\n+\t}\n+\treturn ldflags\n+}\n+\n+func (gcToolchain) ld(b *builder, root *action, out string, allactions []*action, mainpkg string, ofiles []string) error {\n \timportArgs := b.includeArgs(\"-L\", allactions)\n-\tcxx := len(p.CXXFiles) > 0\n+\tcxx := len(root.p.CXXFiles) > 0 || len(root.p.SwigCXXFiles) > 0\n \tfor _, a := range allactions {\n-\t\tif a.p != nil && len(a.p.CXXFiles) > 0 {\n+\t\tif a.p != nil && (len(a.p.CXXFiles) > 0 || len(a.p.SwigCXXFiles) > 0) {\n \t\t\tcxx = true\n \t\t}\n \t}\n-\tldflags := buildLdflags\n-\t// Limit slice capacity so that concurrent appends do not race on the shared array.\n-\tldflags = ldflags[:len(ldflags):len(ldflags)]\n+\tvar ldflags []string\n \tif buildContext.InstallSuffix != \"\" {\n \t\tldflags = append(ldflags, \"-installsuffix\", buildContext.InstallSuffix)\n \t}\n-\tif p.omitDWARF {\n+\tif root.p.omitDWARF {\n \t\tldflags = append(ldflags, \"-w\")\n \t}\n \n \t// If the user has not specified the -extld option, then specify the\n \t// appropriate linker. In case of C++ code, use the compiler named\n \t// by the CXX environment variable or defaultCXX if CXX is not set.\n \t// Else, use the CC environment variable and defaultCC as fallback.\n-\textld := false\n-\tfor _, f := range ldflags {\n-\t\tif f == \"-extld\" || strings.HasPrefix(f, \"-extld=\") {\n-\t\t\textld = true\n-\t\t\tbreak\n+\tvar compiler []string\n+\tif cxx {\n+\t\tcompiler = envList(\"CXX\", defaultCXX)\n+\t} else {\n+\t\tcompiler = envList(\"CC\", defaultCC)\n+\t}\n+\tldflags = setextld(ldflags, compiler)\n+\tldflags = append(ldflags, \"-buildmode=\"+ldBuildmode)\n+\tif root.p.buildID != \"\" {\n+\t\tldflags = append(ldflags, \"-buildid=\"+root.p.buildID)\n+\t}\n+\tldflags = append(ldflags, buildLdflags...)\n+\n+\t// On OS X when using external linking to build a shared library,\n+\t// the argument passed here to -o ends up recorded in the final\n+\t// shared library in the LC_ID_DYLIB load command.\n+\t// To avoid putting the temporary output directory name there\n+\t// (and making the resulting shared library useless),\n+\t// run the link in the output directory so that -o can name\n+\t// just the final path element.\n+\tdir := \".\"\n+\tif goos == \"darwin\" && buildBuildmode == \"c-shared\" {\n+\t\tdir, out = filepath.Split(out)\n+\t}\n+\n+\treturn b.run(dir, root.p.ImportPath, nil, buildToolExec, tool(\"link\"), \"-o\", out, importArgs, ldflags, mainpkg)\n+}\n+\n+func (gcToolchain) ldShared(b *builder, toplevelactions []*action, out string, allactions []*action) error {\n+\timportArgs := b.includeArgs(\"-L\", allactions)\n+\tldflags := []string{\"-installsuffix\", buildContext.InstallSuffix}\n+\tldflags = append(ldflags, \"-buildmode=shared\")\n+\tldflags = append(ldflags, buildLdflags...)\n+\tcxx := false\n+\tfor _, a := range allactions {\n+\t\tif a.p != nil && (len(a.p.CXXFiles) > 0 || len(a.p.SwigCXXFiles) > 0) {\n+\t\t\tcxx = true\n \t\t}\n \t}\n-\tif !extld {\n-\t\tvar compiler []string\n-\t\tif cxx {\n-\t\t\tcompiler = envList(\"CXX\", defaultCXX)\n-\t\t} else {\n-\t\t\tcompiler = envList(\"CC\", defaultCC)\n-\t\t}\n-\t\tldflags = append(ldflags, \"-extld=\"+compiler[0])\n-\t\tif len(compiler) > 1 {\n-\t\t\textldflags := false\n-\t\t\tadd := strings.Join(compiler[1:], \" \")\n-\t\t\tfor i, f := range ldflags {\n-\t\t\t\tif f == \"-extldflags\" && i+1 < len(ldflags) {\n-\t\t\t\t\tldflags[i+1] = add + \" \" + ldflags[i+1]\n-\t\t\t\t\textldflags = true\n-\t\t\t\t\tbreak\n-\t\t\t\t} else if strings.HasPrefix(f, \"-extldflags=\") {\n-\t\t\t\t\tldflags[i] = \"-extldflags=\" + add + \" \" + ldflags[i][len(\"-extldflags=\"):]\n-\t\t\t\t\textldflags = true\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif !extldflags {\n-\t\t\t\tldflags = append(ldflags, \"-extldflags=\"+add)\n-\t\t\t}\n+\t// If the user has not specified the -extld option, then specify the\n+\t// appropriate linker. In case of C++ code, use the compiler named\n+\t// by the CXX environment variable or defaultCXX if CXX is not set.\n+\t// Else, use the CC environment variable and defaultCC as fallback.\n+\tvar compiler []string\n+\tif cxx {\n+\t\tcompiler = envList(\"CXX\", defaultCXX)\n+\t} else {\n+\t\tcompiler = envList(\"CC\", defaultCC)\n+\t}\n+\tldflags = setextld(ldflags, compiler)\n+\tfor _, d := range toplevelactions {\n+\t\tif !strings.HasSuffix(d.target, \".a\") { // omit unsafe etc and actions for other shared libraries\n+\t\t\tcontinue\n \t\t}\n+\t\tldflags = append(ldflags, d.p.ImportPath+\"=\"+d.target)\n \t}\n-\treturn b.run(\".\", p.ImportPath, nil, tool(archChar+\"l\"), \"-o\", out, importArgs, ldflags, mainpkg)\n+\treturn b.run(\".\", out, nil, buildToolExec, tool(\"link\"), \"-o\", out, importArgs, ldflags)\n }\n \n func (gcToolchain) cc(b *builder, p *Package, objdir, ofile, cfile string) error {\n-\tinc := filepath.Join(goroot, \"pkg\", fmt.Sprintf(\"%s_%s\", goos, goarch))\n-\tcfile = mkAbs(p.Dir, cfile)\n-\twarn := []string{\"-w\"}\n-\tif p.usesSwig() {\n-\t\t// When using SWIG, this compiler is only used to\n-\t\t// compile the C files generated by SWIG.\n-\t\t// We don't want warnings.\n-\t\t// See issue 9065 for details.\n-\t\twarn = nil\n-\t}\n-\targs := stringList(tool(archChar+\"c\"), \"-F\", \"-V\", warn, \"-trimpath\", b.work, \"-I\", objdir, \"-I\", inc, \"-o\", ofile, buildCcflags, \"-D\", \"GOOS_\"+goos, \"-D\", \"GOARCH_\"+goarch, cfile)\n-\treturn b.run(p.Dir, p.ImportPath, nil, args)\n+\treturn fmt.Errorf(\"%s: C source files not supported without cgo\", mkAbs(p.Dir, cfile))\n }\n \n // The Gccgo toolchain.\n@@ -1870,7 +2422,7 @@ func (gccgoToolchain) linker() string {\n \treturn gccgoBin\n }\n \n-func (tools gccgoToolchain) gc(b *builder, p *Package, archive, obj string, importArgs []string, gofiles []string) (ofile string, output []byte, err error) {\n+func (tools gccgoToolchain) gc(b *builder, p *Package, archive, obj string, asmhdr bool, importArgs []string, gofiles []string) (ofile string, output []byte, err error) {\n \tout := \"_go_.o\"\n \tofile = obj + out\n \tgcargs := []string{\"-g\"}\n@@ -1896,8 +2448,8 @@ func (tools gccgoToolchain) asm(b *builder, p *Package, obj, ofile, sfile string\n \tif pkgpath := gccgoCleanPkgpath(p); pkgpath != \"\" {\n \t\tdefs = append(defs, `-D`, `GOPKGPATH=\"`+pkgpath+`\"`)\n \t}\n+\tdefs = tools.maybePIC(defs)\n \tdefs = append(defs, b.gccArchArgs()...)\n-\n \treturn b.run(p.Dir, p.ImportPath, nil, tools.compiler(), \"-c\", \"-I\", obj, \"-o\", ofile, defs, sfile)\n }\n \n@@ -1916,30 +2468,46 @@ func (gccgoToolchain) pack(b *builder, p *Package, objDir, afile string, ofiles\n \treturn b.run(p.Dir, p.ImportPath, nil, \"ar\", \"cru\", mkAbs(objDir, afile), absOfiles)\n }\n \n-func (tools gccgoToolchain) ld(b *builder, p *Package, out string, allactions []*action, mainpkg string, ofiles []string) error {\n+func (tools gccgoToolchain) ld(b *builder, root *action, out string, allactions []*action, mainpkg string, ofiles []string) error {\n \t// gccgo needs explicit linking with all package dependencies,\n \t// and all LDFLAGS from cgo dependencies.\n \tapackagesSeen := make(map[*Package]bool)\n \tafiles := []string{}\n+\tshlibs := []string{}\n \txfiles := []string{}\n \tldflags := b.gccArchArgs()\n \tcgoldflags := []string{}\n \tusesCgo := false\n-\tcxx := len(p.CXXFiles) > 0\n-\tobjc := len(p.MFiles) > 0\n-\n-\t// Prefer the output of an install action to the output of a build action,\n-\t// because the install action will delete the output of the build action.\n-\t// Iterate over the list backward (reverse dependency order) so that we\n-\t// always see the install before the build.\n-\tfor i := len(allactions) - 1; i >= 0; i-- {\n-\t\ta := allactions[i]\n-\t\tif !a.p.Standard {\n-\t\t\tif a.p != nil && !apackagesSeen[a.p] {\n+\tcxx := len(root.p.CXXFiles) > 0 || len(root.p.SwigCXXFiles) > 0\n+\tobjc := len(root.p.MFiles) > 0\n+\n+\tactionsSeen := make(map[*action]bool)\n+\t// Make a pre-order depth-first traversal of the action graph, taking note of\n+\t// whether a shared library action has been seen on the way to an action (the\n+\t// construction of the graph means that if any path to a node passes through\n+\t// a shared library action, they all do).\n+\tvar walk func(a *action, seenShlib bool)\n+\twalk = func(a *action, seenShlib bool) {\n+\t\tif actionsSeen[a] {\n+\t\t\treturn\n+\t\t}\n+\t\tactionsSeen[a] = true\n+\t\tif a.p != nil && !seenShlib {\n+\t\t\tif a.p.Standard {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\t// We record the target of the first time we see a .a file\n+\t\t\t// for a package to make sure that we prefer the 'install'\n+\t\t\t// rather than the 'build' location (which may not exist any\n+\t\t\t// more). We still need to traverse the dependencies of the\n+\t\t\t// build action though so saying\n+\t\t\t// if apackagesSeen[a.p] { return }\n+\t\t\t// doesn't work.\n+\t\t\tif !apackagesSeen[a.p] {\n \t\t\t\tapackagesSeen[a.p] = true\n \t\t\t\tif a.p.fake && a.p.external {\n \t\t\t\t\t// external _tests, if present must come before\n-\t\t\t\t\t// internal _tests. Store these on a seperate list\n+\t\t\t\t\t// internal _tests. Store these on a separate list\n \t\t\t\t\t// and place them at the head after this loop.\n \t\t\t\t\txfiles = append(xfiles, a.target)\n \t\t\t\t} else if a.p.fake {\n@@ -1950,54 +2518,182 @@ func (tools gccgoToolchain) ld(b *builder, p *Package, out string, allactions []\n \t\t\t\t}\n \t\t\t}\n \t\t}\n+\t\tif strings.HasSuffix(a.target, \".so\") {\n+\t\t\tshlibs = append(shlibs, a.target)\n+\t\t\tseenShlib = true\n+\t\t}\n+\t\tfor _, a1 := range a.deps {\n+\t\t\twalk(a1, seenShlib)\n+\t\t}\n+\t}\n+\tfor _, a1 := range root.deps {\n+\t\twalk(a1, false)\n \t}\n \tafiles = append(xfiles, afiles...)\n \n \tfor _, a := range allactions {\n-\t\tif a.p != nil {\n+\t\t// Gather CgoLDFLAGS, but not from standard packages.\n+\t\t// The go tool can dig up runtime/cgo from GOROOT and\n+\t\t// think that it should use its CgoLDFLAGS, but gccgo\n+\t\t// doesn't use runtime/cgo.\n+\t\tif a.p == nil {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif !a.p.Standard {\n \t\t\tcgoldflags = append(cgoldflags, a.p.CgoLDFLAGS...)\n-\t\t\tif len(a.p.CgoFiles) > 0 {\n-\t\t\t\tusesCgo = true\n-\t\t\t}\n-\t\t\tif a.p.usesSwig() {\n-\t\t\t\tusesCgo = true\n-\t\t\t}\n-\t\t\tif len(a.p.CXXFiles) > 0 {\n-\t\t\t\tcxx = true\n-\t\t\t}\n-\t\t\tif len(a.p.MFiles) > 0 {\n-\t\t\t\tobjc = true\n-\t\t\t}\n+\t\t}\n+\t\tif len(a.p.CgoFiles) > 0 {\n+\t\t\tusesCgo = true\n+\t\t}\n+\t\tif a.p.usesSwig() {\n+\t\t\tusesCgo = true\n+\t\t}\n+\t\tif len(a.p.CXXFiles) > 0 || len(a.p.SwigCXXFiles) > 0 {\n+\t\t\tcxx = true\n+\t\t}\n+\t\tif len(a.p.MFiles) > 0 {\n+\t\t\tobjc = true\n \t\t}\n \t}\n+\n+\tswitch ldBuildmode {\n+\tcase \"c-archive\", \"c-shared\":\n+\t\tldflags = append(ldflags, \"-Wl,--whole-archive\")\n+\t}\n+\n \tldflags = append(ldflags, afiles...)\n+\n+\tswitch ldBuildmode {\n+\tcase \"c-archive\", \"c-shared\":\n+\t\tldflags = append(ldflags, \"-Wl,--no-whole-archive\")\n+\t}\n+\n \tldflags = append(ldflags, cgoldflags...)\n \tldflags = append(ldflags, envList(\"CGO_LDFLAGS\", \"\")...)\n-\tldflags = append(ldflags, p.CgoLDFLAGS...)\n-\tif usesCgo && goos == \"linux\" {\n-\t\tldflags = append(ldflags, \"-Wl,-E\")\n+\tldflags = append(ldflags, root.p.CgoLDFLAGS...)\n+\n+\tldflags = stringList(\"-Wl,-(\", ldflags, \"-Wl,-)\")\n+\n+\tfor _, shlib := range shlibs {\n+\t\tldflags = append(\n+\t\t\tldflags,\n+\t\t\t\"-L\"+filepath.Dir(shlib),\n+\t\t\t\"-Wl,-rpath=\"+filepath.Dir(shlib),\n+\t\t\t\"-l\"+strings.TrimSuffix(\n+\t\t\t\tstrings.TrimPrefix(filepath.Base(shlib), \"lib\"),\n+\t\t\t\t\".so\"))\n \t}\n-\tif cxx {\n-\t\tldflags = append(ldflags, \"-lstdc++\")\n+\n+\tvar realOut string\n+\tswitch ldBuildmode {\n+\tcase \"exe\":\n+\t\tif usesCgo && goos == \"linux\" {\n+\t\t\tldflags = append(ldflags, \"-Wl,-E\")\n+\t\t}\n+\n+\tcase \"c-archive\":\n+\t\t// Link the Go files into a single .o, and also link\n+\t\t// in -lgolibbegin.\n+\t\t//\n+\t\t// We need to use --whole-archive with -lgolibbegin\n+\t\t// because it doesn't define any symbols that will\n+\t\t// cause the contents to be pulled in; it's just\n+\t\t// initialization code.\n+\t\t//\n+\t\t// The user remains responsible for linking against\n+\t\t// -lgo -lpthread -lm in the final link.  We can't use\n+\t\t// -r to pick them up because we can't combine\n+\t\t// split-stack and non-split-stack code in a single -r\n+\t\t// link, and libgo picks up non-split-stack code from\n+\t\t// libffi.\n+\t\tldflags = append(ldflags, \"-Wl,-r\", \"-nostdlib\", \"-Wl,--whole-archive\", \"-lgolibbegin\", \"-Wl,--no-whole-archive\")\n+\n+\t\t// We are creating an object file, so we don't want a build ID.\n+\t\tldflags = b.disableBuildID(ldflags)\n+\n+\t\trealOut = out\n+\t\tout = out + \".o\"\n+\n+\tcase \"c-shared\":\n+\t\tldflags = append(ldflags, \"-shared\", \"-nostdlib\", \"-Wl,--whole-archive\", \"-lgolibbegin\", \"-Wl,--no-whole-archive\", \"-lgo\", \"-lgcc_s\", \"-lgcc\")\n+\n+\tdefault:\n+\t\tfatalf(\"-buildmode=%s not supported for gccgo\", ldBuildmode)\n+\t}\n+\n+\tswitch ldBuildmode {\n+\tcase \"exe\", \"c-shared\":\n+\t\tif cxx {\n+\t\t\tldflags = append(ldflags, \"-lstdc++\")\n+\t\t}\n+\t\tif objc {\n+\t\t\tldflags = append(ldflags, \"-lobjc\")\n+\t\t}\n \t}\n-\tif objc {\n-\t\tldflags = append(ldflags, \"-lobjc\")\n+\n+\tif err := b.run(\".\", root.p.ImportPath, nil, tools.linker(), \"-o\", out, ofiles, ldflags, buildGccgoflags); err != nil {\n+\t\treturn err\n+\t}\n+\n+\tswitch ldBuildmode {\n+\tcase \"c-archive\":\n+\t\tif err := b.run(\".\", root.p.ImportPath, nil, \"ar\", \"rc\", realOut, out); err != nil {\n+\t\t\treturn err\n+\t\t}\n \t}\n-\treturn b.run(\".\", p.ImportPath, nil, tools.linker(), \"-o\", out, ofiles, \"-Wl,-(\", ldflags, \"-Wl,-)\", buildGccgoflags)\n+\treturn nil\n }\n \n-func (gccgoToolchain) cc(b *builder, p *Package, objdir, ofile, cfile string) error {\n-\tinc := filepath.Join(goroot, \"pkg\", fmt.Sprintf(\"%s_%s\", goos, goarch))\n+func (tools gccgoToolchain) ldShared(b *builder, toplevelactions []*action, out string, allactions []*action) error {\n+\targs := []string{\"-o\", out, \"-shared\", \"-nostdlib\", \"-zdefs\", \"-Wl,--whole-archive\"}\n+\tfor _, a := range toplevelactions {\n+\t\targs = append(args, a.target)\n+\t}\n+\targs = append(args, \"-Wl,--no-whole-archive\", \"-shared\", \"-nostdlib\", \"-lgo\", \"-lgcc_s\", \"-lgcc\", \"-lc\")\n+\tshlibs := []string{}\n+\tfor _, a := range allactions {\n+\t\tif strings.HasSuffix(a.target, \".so\") {\n+\t\t\tshlibs = append(shlibs, a.target)\n+\t\t}\n+\t}\n+\tfor _, shlib := range shlibs {\n+\t\targs = append(\n+\t\t\targs,\n+\t\t\t\"-L\"+filepath.Dir(shlib),\n+\t\t\t\"-Wl,-rpath=\"+filepath.Dir(shlib),\n+\t\t\t\"-l\"+strings.TrimSuffix(\n+\t\t\t\tstrings.TrimPrefix(filepath.Base(shlib), \"lib\"),\n+\t\t\t\t\".so\"))\n+\t}\n+\treturn b.run(\".\", out, nil, tools.linker(), args, buildGccgoflags)\n+}\n+\n+func (tools gccgoToolchain) cc(b *builder, p *Package, objdir, ofile, cfile string) error {\n+\tinc := filepath.Join(goroot, \"pkg\", \"include\")\n \tcfile = mkAbs(p.Dir, cfile)\n \tdefs := []string{\"-D\", \"GOOS_\" + goos, \"-D\", \"GOARCH_\" + goarch}\n \tdefs = append(defs, b.gccArchArgs()...)\n \tif pkgpath := gccgoCleanPkgpath(p); pkgpath != \"\" {\n \t\tdefs = append(defs, `-D`, `GOPKGPATH=\"`+pkgpath+`\"`)\n \t}\n+\tswitch goarch {\n+\tcase \"386\", \"amd64\":\n+\t\tdefs = append(defs, \"-fsplit-stack\")\n+\t}\n+\tdefs = tools.maybePIC(defs)\n \treturn b.run(p.Dir, p.ImportPath, nil, envList(\"CC\", defaultCC), \"-Wall\", \"-g\",\n \t\t\"-I\", objdir, \"-I\", inc, \"-o\", ofile, defs, \"-c\", cfile)\n }\n \n+// maybePIC adds -fPIC to the list of arguments if needed.\n+func (tools gccgoToolchain) maybePIC(args []string) []string {\n+\tswitch buildBuildmode {\n+\tcase \"c-shared\", \"shared\":\n+\t\targs = append(args, \"-fPIC\")\n+\t}\n+\treturn args\n+}\n+\n func gccgoPkgpath(p *Package) string {\n \tif p.build.IsCommand() && !p.forceLibrary {\n \t\treturn \"\"\n@@ -2073,7 +2769,7 @@ func (b *builder) ccompile(p *Package, out string, flags []string, file string,\n // gccld runs the gcc linker to create an executable from a set of object files.\n func (b *builder) gccld(p *Package, out string, flags []string, obj []string) error {\n \tvar cmd []string\n-\tif len(p.CXXFiles) > 0 {\n+\tif len(p.CXXFiles) > 0 || len(p.SwigCXXFiles) > 0 {\n \t\tcmd = b.gxxCmd(p.Dir)\n \t} else {\n \t\tcmd = b.gccCmd(p.Dir)\n@@ -2132,7 +2828,7 @@ func (b *builder) ccompilerCmd(envvar, defcmd, objdir string) []string {\n \n \t// On OS X, some of the compilers behave as if -fno-common\n \t// is always set, and the Mach-O linker in 6l/8l assumes this.\n-\t// See http://golang.org/issue/3253.\n+\t// See https://golang.org/issue/3253.\n \tif goos == \"darwin\" {\n \t\ta = append(a, \"-fno-common\")\n \t}\n@@ -2142,12 +2838,12 @@ func (b *builder) ccompilerCmd(envvar, defcmd, objdir string) []string {\n \n // gccArchArgs returns arguments to pass to gcc based on the architecture.\n func (b *builder) gccArchArgs() []string {\n-\tswitch archChar {\n-\tcase \"8\":\n+\tswitch goarch {\n+\tcase \"386\":\n \t\treturn []string{\"-m32\"}\n-\tcase \"6\":\n+\tcase \"amd64\", \"amd64p32\":\n \t\treturn []string{\"-m64\"}\n-\tcase \"5\":\n+\tcase \"arm\":\n \t\treturn []string{\"-marm\"} // not thumb\n \t}\n \treturn nil\n@@ -2185,7 +2881,7 @@ var (\n \tcgoLibGccFileOnce sync.Once\n )\n \n-func (b *builder) cgo(p *Package, cgoExe, obj string, pcCFLAGS, pcLDFLAGS, gccfiles, gxxfiles, mfiles []string) (outGo, outObj []string, err error) {\n+func (b *builder) cgo(p *Package, cgoExe, obj string, pcCFLAGS, pcLDFLAGS, cgofiles, gccfiles, gxxfiles, mfiles []string) (outGo, outObj []string, err error) {\n \tcgoCPPFLAGS, cgoCFLAGS, cgoCXXFLAGS, cgoLDFLAGS := b.cflags(p, true)\n \t_, cgoexeCFLAGS, _, _ := b.cflags(p, false)\n \tcgoCPPFLAGS = append(cgoCPPFLAGS, pcCFLAGS...)\n@@ -2202,7 +2898,7 @@ func (b *builder) cgo(p *Package, cgoExe, obj string, pcCFLAGS, pcLDFLAGS, gccfi\n \t// TODO: CGOPKGPATH, CGO_FLAGS?\n \tgofiles := []string{obj + \"_cgo_gotypes.go\"}\n \tcfiles := []string{\"_cgo_main.c\", \"_cgo_export.c\"}\n-\tfor _, fn := range p.CgoFiles {\n+\tfor _, fn := range cgofiles {\n \t\tf := cgoRe.ReplaceAllString(fn[:len(fn)-2], \"_\")\n \t\tgofiles = append(gofiles, obj+f+\"cgo1.go\")\n \t\tcfiles = append(cfiles, f+\"cgo2.c\")\n@@ -2212,8 +2908,6 @@ func (b *builder) cgo(p *Package, cgoExe, obj string, pcCFLAGS, pcLDFLAGS, gccfi\n \tcgoflags := []string{}\n \t// TODO: make cgo not depend on $GOARCH?\n \n-\tobjExt := archChar\n-\n \tif p.Standard && p.ImportPath == \"runtime/cgo\" {\n \t\tcgoflags = append(cgoflags, \"-import_runtime_cgo=false\")\n \t}\n@@ -2232,23 +2926,38 @@ func (b *builder) cgo(p *Package, cgoExe, obj string, pcCFLAGS, pcLDFLAGS, gccfi\n \t}\n \n \tif _, ok := buildToolchain.(gccgoToolchain); ok {\n+\t\tswitch goarch {\n+\t\tcase \"386\", \"amd64\":\n+\t\t\tcgoCFLAGS = append(cgoCFLAGS, \"-fsplit-stack\")\n+\t\t}\n \t\tcgoflags = append(cgoflags, \"-gccgo\")\n \t\tif pkgpath := gccgoPkgpath(p); pkgpath != \"\" {\n \t\t\tcgoflags = append(cgoflags, \"-gccgopkgpath=\"+pkgpath)\n \t\t}\n-\t\tobjExt = \"o\"\n \t}\n-\tif err := b.run(p.Dir, p.ImportPath, cgoenv, cgoExe, \"-objdir\", obj, cgoflags, \"--\", cgoCPPFLAGS, cgoexeCFLAGS, p.CgoFiles); err != nil {\n+\n+\tswitch buildBuildmode {\n+\tcase \"c-archive\", \"c-shared\":\n+\t\t// Tell cgo that if there are any exported functions\n+\t\t// it should generate a header file that C code can\n+\t\t// #include.\n+\t\tcgoflags = append(cgoflags, \"-exportheader=\"+obj+\"_cgo_install.h\")\n+\t}\n+\n+\tif err := b.run(p.Dir, p.ImportPath, cgoenv, buildToolExec, cgoExe, \"-objdir\", obj, \"-importpath\", p.ImportPath, cgoflags, \"--\", cgoCPPFLAGS, cgoexeCFLAGS, cgofiles); err != nil {\n \t\treturn nil, nil, err\n \t}\n \toutGo = append(outGo, gofiles...)\n \n \t// cc _cgo_defun.c\n-\tdefunObj := obj + \"_cgo_defun.\" + objExt\n-\tif err := buildToolchain.cc(b, p, obj, defunObj, defunC); err != nil {\n-\t\treturn nil, nil, err\n+\t_, gccgo := buildToolchain.(gccgoToolchain)\n+\tif gccgo {\n+\t\tdefunObj := obj + \"_cgo_defun.o\"\n+\t\tif err := buildToolchain.cc(b, p, obj, defunObj, defunC); err != nil {\n+\t\t\treturn nil, nil, err\n+\t\t}\n+\t\toutObj = append(outObj, defunObj)\n \t}\n-\toutObj = append(outObj, defunObj)\n \n \t// gcc\n \tvar linkobj []string\n@@ -2362,20 +3071,15 @@ func (b *builder) cgo(p *Package, cgoExe, obj string, pcCFLAGS, pcLDFLAGS, gccfi\n \t}\n \n \t// cgo -dynimport\n-\timportC := obj + \"_cgo_import.c\"\n+\timportGo := obj + \"_cgo_import.go\"\n \tcgoflags = []string{}\n \tif p.Standard && p.ImportPath == \"runtime/cgo\" {\n \t\tcgoflags = append(cgoflags, \"-dynlinker\") // record path to dynamic linker\n \t}\n-\tif err := b.run(p.Dir, p.ImportPath, nil, cgoExe, \"-objdir\", obj, \"-dynimport\", dynobj, \"-dynout\", importC, cgoflags); err != nil {\n-\t\treturn nil, nil, err\n-\t}\n-\n-\t// cc _cgo_import.ARCH\n-\timportObj := obj + \"_cgo_import.\" + objExt\n-\tif err := buildToolchain.cc(b, p, obj, importObj, importC); err != nil {\n+\tif err := b.run(p.Dir, p.ImportPath, nil, buildToolExec, cgoExe, \"-objdir\", obj, \"-dynpackage\", p.Name, \"-dynimport\", dynobj, \"-dynout\", importGo, cgoflags); err != nil {\n \t\treturn nil, nil, err\n \t}\n+\toutGo = append(outGo, importGo)\n \n \tofile := obj + \"_all.o\"\n \tvar gccObjs, nonGccObjs []string\n@@ -2388,106 +3092,59 @@ func (b *builder) cgo(p *Package, cgoExe, obj string, pcCFLAGS, pcLDFLAGS, gccfi\n \t}\n \tldflags := stringList(bareLDFLAGS, \"-Wl,-r\", \"-nostdlib\", staticLibs)\n \n-\t// Some systems, such as Ubuntu, always add --build-id to\n-\t// every link, but we don't want a build ID since we are\n-\t// producing an object file.  On some of those system a plain\n-\t// -r (not -Wl,-r) will turn off --build-id, but clang 3.0\n-\t// doesn't support a plain -r.  I don't know how to turn off\n-\t// --build-id when using clang other than passing a trailing\n-\t// --build-id=none.  So that is what we do, but only on\n-\t// systems likely to support it, which is to say, systems that\n-\t// normally use gold or the GNU linker.\n-\tswitch goos {\n-\tcase \"android\", \"dragonfly\", \"linux\", \"netbsd\":\n-\t\tldflags = append(ldflags, \"-Wl,--build-id=none\")\n-\t}\n+\t// We are creating an object file, so we don't want a build ID.\n+\tldflags = b.disableBuildID(ldflags)\n \n \tif err := b.gccld(p, ofile, ldflags, gccObjs); err != nil {\n \t\treturn nil, nil, err\n \t}\n \n \t// NOTE(rsc): The importObj is a 5c/6c/8c object and on Windows\n \t// must be processed before the gcc-generated objects.\n-\t// Put it first.  http://golang.org/issue/2601\n-\toutObj = stringList(importObj, nonGccObjs, ofile)\n+\t// Put it first.  https://golang.org/issue/2601\n+\toutObj = stringList(nonGccObjs, ofile)\n \n \treturn outGo, outObj, nil\n }\n \n // Run SWIG on all SWIG input files.\n // TODO: Don't build a shared library, once SWIG emits the necessary\n // pragmas for external linking.\n-func (b *builder) swig(p *Package, obj string, pcCFLAGS, gccfiles, gxxfiles, mfiles []string) (outGo, outObj []string, err error) {\n-\tcgoCPPFLAGS, cgoCFLAGS, cgoCXXFLAGS, _ := b.cflags(p, true)\n-\tcflags := stringList(cgoCPPFLAGS, cgoCFLAGS)\n-\tcxxflags := stringList(cgoCPPFLAGS, cgoCXXFLAGS)\n-\n-\tfor _, file := range gccfiles {\n-\t\tofile := obj + cgoRe.ReplaceAllString(file[:len(file)-1], \"_\") + \"o\"\n-\t\tif err := b.gcc(p, ofile, cflags, file); err != nil {\n-\t\t\treturn nil, nil, err\n-\t\t}\n-\t\toutObj = append(outObj, ofile)\n-\t}\n-\n-\tfor _, file := range gxxfiles {\n-\t\t// Append .o to the file, just in case the pkg has file.c and file.cpp\n-\t\tofile := obj + cgoRe.ReplaceAllString(file, \"_\") + \".o\"\n-\t\tif err := b.gxx(p, ofile, cxxflags, file); err != nil {\n-\t\t\treturn nil, nil, err\n-\t\t}\n-\t\toutObj = append(outObj, ofile)\n-\t}\n-\n-\tfor _, file := range mfiles {\n-\t\t// Append .o to the file, just in case the pkg has file.c and file.cpp\n-\t\tofile := obj + cgoRe.ReplaceAllString(file, \"_\") + \".o\"\n-\t\tif err := b.gcc(p, ofile, cflags, file); err != nil {\n-\t\t\treturn nil, nil, err\n-\t\t}\n-\t\toutObj = append(outObj, ofile)\n-\t}\n-\n+func (b *builder) swig(p *Package, obj string, pcCFLAGS []string) (outGo, outC, outCXX []string, err error) {\n \tif err := b.swigVersionCheck(); err != nil {\n-\t\treturn nil, nil, err\n+\t\treturn nil, nil, nil, err\n \t}\n \n \tintgosize, err := b.swigIntSize(obj)\n \tif err != nil {\n-\t\treturn nil, nil, err\n+\t\treturn nil, nil, nil, err\n \t}\n \n \tfor _, f := range p.SwigFiles {\n-\t\tgoFile, objFile, gccObjFile, err := b.swigOne(p, f, obj, pcCFLAGS, false, intgosize)\n+\t\tgoFile, cFile, err := b.swigOne(p, f, obj, pcCFLAGS, false, intgosize)\n \t\tif err != nil {\n-\t\t\treturn nil, nil, err\n+\t\t\treturn nil, nil, nil, err\n \t\t}\n \t\tif goFile != \"\" {\n \t\t\toutGo = append(outGo, goFile)\n \t\t}\n-\t\tif objFile != \"\" {\n-\t\t\toutObj = append(outObj, objFile)\n-\t\t}\n-\t\tif gccObjFile != \"\" {\n-\t\t\toutObj = append(outObj, gccObjFile)\n+\t\tif cFile != \"\" {\n+\t\t\toutC = append(outC, cFile)\n \t\t}\n \t}\n \tfor _, f := range p.SwigCXXFiles {\n-\t\tgoFile, objFile, gccObjFile, err := b.swigOne(p, f, obj, pcCFLAGS, true, intgosize)\n+\t\tgoFile, cxxFile, err := b.swigOne(p, f, obj, pcCFLAGS, true, intgosize)\n \t\tif err != nil {\n-\t\t\treturn nil, nil, err\n+\t\t\treturn nil, nil, nil, err\n \t\t}\n \t\tif goFile != \"\" {\n \t\t\toutGo = append(outGo, goFile)\n \t\t}\n-\t\tif objFile != \"\" {\n-\t\t\toutObj = append(outObj, objFile)\n-\t\t}\n-\t\tif gccObjFile != \"\" {\n-\t\t\toutObj = append(outObj, gccObjFile)\n+\t\tif cxxFile != \"\" {\n+\t\t\toutCXX = append(outCXX, cxxFile)\n \t\t}\n \t}\n-\treturn outGo, outObj, nil\n+\treturn outGo, outC, outCXX, nil\n }\n \n // Make sure SWIG is new enough.\n@@ -2501,20 +3158,51 @@ func (b *builder) swigDoVersionCheck() error {\n \tif err != nil {\n \t\treturn err\n \t}\n-\tre := regexp.MustCompile(`[vV]ersion +([\\d])`)\n+\tre := regexp.MustCompile(`[vV]ersion +([\\d]+)([.][\\d]+)?([.][\\d]+)?`)\n \tmatches := re.FindSubmatch(out)\n \tif matches == nil {\n \t\t// Can't find version number; hope for the best.\n \t\treturn nil\n \t}\n+\n \tmajor, err := strconv.Atoi(string(matches[1]))\n \tif err != nil {\n \t\t// Can't find version number; hope for the best.\n \t\treturn nil\n \t}\n+\tconst errmsg = \"must have SWIG version >= 3.0.6\"\n \tif major < 3 {\n-\t\treturn errors.New(\"must have SWIG version >= 3.0\")\n+\t\treturn errors.New(errmsg)\n+\t}\n+\tif major > 3 {\n+\t\t// 4.0 or later\n+\t\treturn nil\n+\t}\n+\n+\t// We have SWIG version 3.x.\n+\tif len(matches[2]) > 0 {\n+\t\tminor, err := strconv.Atoi(string(matches[2][1:]))\n+\t\tif err != nil {\n+\t\t\treturn nil\n+\t\t}\n+\t\tif minor > 0 {\n+\t\t\t// 3.1 or later\n+\t\t\treturn nil\n+\t\t}\n \t}\n+\n+\t// We have SWIG version 3.0.x.\n+\tif len(matches[3]) > 0 {\n+\t\tpatch, err := strconv.Atoi(string(matches[3][1:]))\n+\t\tif err != nil {\n+\t\t\treturn nil\n+\t\t}\n+\t\tif patch < 6 {\n+\t\t\t// Before 3.0.6.\n+\t\t\treturn errors.New(errmsg)\n+\t\t}\n+\t}\n+\n \treturn nil\n }\n \n@@ -2545,14 +3233,14 @@ func (b *builder) swigIntSize(obj string) (intsize string, err error) {\n \n \tp := goFilesPackage(srcs)\n \n-\tif _, _, e := buildToolchain.gc(b, p, \"\", obj, nil, srcs); e != nil {\n+\tif _, _, e := buildToolchain.gc(b, p, \"\", obj, false, nil, srcs); e != nil {\n \t\treturn \"32\", nil\n \t}\n \treturn \"64\", nil\n }\n \n // Run SWIG on one SWIG input file.\n-func (b *builder) swigOne(p *Package, file, obj string, pcCFLAGS []string, cxx bool, intgosize string) (outGo, outObj, objGccObj string, err error) {\n+func (b *builder) swigOne(p *Package, file, obj string, pcCFLAGS []string, cxx bool, intgosize string) (outGo, outC string, err error) {\n \tcgoCPPFLAGS, cgoCFLAGS, cgoCXXFLAGS, _ := b.cflags(p, true)\n \tvar cflags []string\n \tif cxx {\n@@ -2567,7 +3255,6 @@ func (b *builder) swigOne(p *Package, file, obj string, pcCFLAGS []string, cxx b\n \t}\n \tbase := file[:len(file)-n]\n \tgoFile := base + \".go\"\n-\tcBase := base + \"_gc.\"\n \tgccBase := base + \"_wrap.\"\n \tgccExt := \"c\"\n \tif cxx {\n@@ -2579,6 +3266,7 @@ func (b *builder) swigOne(p *Package, file, obj string, pcCFLAGS []string, cxx b\n \t// swig\n \targs := []string{\n \t\t\"-go\",\n+\t\t\"-cgo\",\n \t\t\"-intgosize\", intgosize,\n \t\t\"-module\", base,\n \t\t\"-o\", obj + gccBase + gccExt,\n@@ -2601,39 +3289,40 @@ func (b *builder) swigOne(p *Package, file, obj string, pcCFLAGS []string, cxx b\n \t\targs = append(args, \"-c++\")\n \t}\n \n-\tif out, err := b.runOut(p.Dir, p.ImportPath, nil, \"swig\", args, file); err != nil {\n+\tout, err := b.runOut(p.Dir, p.ImportPath, nil, \"swig\", args, file)\n+\tif err != nil {\n \t\tif len(out) > 0 {\n-\t\t\tif bytes.Contains(out, []byte(\"Unrecognized option -intgosize\")) {\n-\t\t\t\treturn \"\", \"\", \"\", errors.New(\"must have SWIG version >= 3.0\")\n+\t\t\tif bytes.Contains(out, []byte(\"-intgosize\")) || bytes.Contains(out, []byte(\"-cgo\")) {\n+\t\t\t\treturn \"\", \"\", errors.New(\"must have SWIG version >= 3.0.6\")\n \t\t\t}\n-\t\t\tb.showOutput(p.Dir, p.ImportPath, b.processOutput(out))\n-\t\t\treturn \"\", \"\", \"\", errPrintedOutput\n+\t\t\tb.showOutput(p.Dir, p.ImportPath, b.processOutput(out)) // swig error\n+\t\t\treturn \"\", \"\", errPrintedOutput\n \t\t}\n-\t\treturn \"\", \"\", \"\", err\n+\t\treturn \"\", \"\", err\n \t}\n-\n-\tvar cObj string\n-\tif !gccgo {\n-\t\t// cc\n-\t\tcObj = obj + cBase + archChar\n-\t\tif err := buildToolchain.cc(b, p, obj, cObj, obj+cBase+\"c\"); err != nil {\n-\t\t\treturn \"\", \"\", \"\", err\n-\t\t}\n+\tif len(out) > 0 {\n+\t\tb.showOutput(p.Dir, p.ImportPath, b.processOutput(out)) // swig warning\n \t}\n \n-\t// gcc\n-\tgccObj := obj + gccBase + \"o\"\n-\tif !cxx {\n-\t\tif err := b.gcc(p, gccObj, cflags, obj+gccBase+gccExt); err != nil {\n-\t\t\treturn \"\", \"\", \"\", err\n-\t\t}\n-\t} else {\n-\t\tif err := b.gxx(p, gccObj, cflags, obj+gccBase+gccExt); err != nil {\n-\t\t\treturn \"\", \"\", \"\", err\n-\t\t}\n-\t}\n+\treturn obj + goFile, obj + gccBase + gccExt, nil\n+}\n \n-\treturn obj + goFile, cObj, gccObj, nil\n+// disableBuildID adjusts a linker command line to avoid creating a\n+// build ID when creating an object file rather than an executable or\n+// shared library.  Some systems, such as Ubuntu, always add\n+// --build-id to every link, but we don't want a build ID when we are\n+// producing an object file.  On some of those system a plain -r (not\n+// -Wl,-r) will turn off --build-id, but clang 3.0 doesn't support a\n+// plain -r.  I don't know how to turn off --build-id when using clang\n+// other than passing a trailing --build-id=none.  So that is what we\n+// do, but only on systems likely to support it, which is to say,\n+// systems that normally use gold or the GNU linker.\n+func (b *builder) disableBuildID(ldflags []string) []string {\n+\tswitch goos {\n+\tcase \"android\", \"dragonfly\", \"linux\", \"netbsd\":\n+\t\tldflags = append(ldflags, \"-Wl,--build-id=none\")\n+\t}\n+\treturn ldflags\n }\n \n // An actionQueue is a priority queue of actions.\n@@ -2669,7 +3358,6 @@ func raceInit() {\n \t}\n \tbuildGcflags = append(buildGcflags, \"-race\")\n \tbuildLdflags = append(buildLdflags, \"-race\")\n-\tbuildCcflags = append(buildCcflags, \"-D\", \"RACE\")\n \tif buildContext.InstallSuffix != \"\" {\n \t\tbuildContext.InstallSuffix += \"_\"\n \t}"}, {"sha": "4a07dfe11f4e76a76a3aa6feceaa55c964ccf367", "filename": "libgo/go/cmd/go/doc.go", "status": "modified", "additions": 98, "deletions": 1126, "changes": 1224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fdoc.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -1,1131 +1,103 @@\n-// Copyright 2011 The Go Authors.  All rights reserved.\n+// Copyright 2015 The Go Authors.  All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// DO NOT EDIT THIS FILE. GENERATED BY mkdoc.sh.\n-// Edit the documentation in other files and rerun mkdoc.sh to generate this one.\n-\n-/*\n-Go is a tool for managing Go source code.\n-\n-Usage:\n-\n-\tgo command [arguments]\n-\n-The commands are:\n-\n-    build       compile packages and dependencies\n-    clean       remove object files\n-    env         print Go environment information\n-    fix         run go tool fix on packages\n-    fmt         run gofmt on package sources\n-    generate    generate Go files by processing source\n-    get         download and install packages and dependencies\n-    install     compile and install packages and dependencies\n-    list        list packages\n-    run         compile and run Go program\n-    test        test packages\n-    tool        run specified go tool\n-    version     print Go version\n-    vet         run go tool vet on packages\n-\n-Use \"go help [command]\" for more information about a command.\n-\n-Additional help topics:\n-\n-    c           calling between Go and C\n-    filetype    file types\n-    gopath      GOPATH environment variable\n-    importpath  import path syntax\n-    packages    description of package lists\n-    testflag    description of testing flags\n-    testfunc    description of testing functions\n-\n-Use \"go help [topic]\" for more information about that topic.\n-\n-\n-Compile packages and dependencies\n-\n-Usage:\n-\n-\tgo build [-o output] [-i] [build flags] [packages]\n-\n-Build compiles the packages named by the import paths,\n-along with their dependencies, but it does not install the results.\n-\n-If the arguments are a list of .go files, build treats them as a list\n-of source files specifying a single package.\n-\n-When the command line specifies a single main package,\n-build writes the resulting executable to output.\n-Otherwise build compiles the packages but discards the results,\n-serving only as a check that the packages can be built.\n-\n-The -o flag specifies the output file name. If not specified, the\n-output file name depends on the arguments and derives from the name\n-of the package, such as p.a for package p, unless p is 'main'. If\n-the package is main and file names are provided, the file name\n-derives from the first file name mentioned, such as f1 for 'go build\n-f1.go f2.go'; with no files provided ('go build'), the output file\n-name is the base name of the containing directory.\n-\n-The -i flag installs the packages that are dependencies of the target.\n-\n-The build flags are shared by the build, clean, get, install, list, run,\n-and test commands:\n-\n-\t-a\n-\t\tforce rebuilding of packages that are already up-to-date.\n-\t\tIn Go releases, does not apply to the standard library.\n-\t-n\n-\t\tprint the commands but do not run them.\n-\t-p n\n-\t\tthe number of builds that can be run in parallel.\n-\t\tThe default is the number of CPUs available.\n-\t-race\n-\t\tenable data race detection.\n-\t\tSupported only on linux/amd64, freebsd/amd64, darwin/amd64 and windows/amd64.\n-\t-v\n-\t\tprint the names of packages as they are compiled.\n-\t-work\n-\t\tprint the name of the temporary work directory and\n-\t\tdo not delete it when exiting.\n-\t-x\n-\t\tprint the commands.\n-\n-\t-ccflags 'arg list'\n-\t\targuments to pass on each 5c, 6c, or 8c compiler invocation.\n-\t-compiler name\n-\t\tname of compiler to use, as in runtime.Compiler (gccgo or gc).\n-\t-gccgoflags 'arg list'\n-\t\targuments to pass on each gccgo compiler/linker invocation.\n-\t-gcflags 'arg list'\n-\t\targuments to pass on each 5g, 6g, or 8g compiler invocation.\n-\t-installsuffix suffix\n-\t\ta suffix to use in the name of the package installation directory,\n-\t\tin order to keep output separate from default builds.\n-\t\tIf using the -race flag, the install suffix is automatically set to race\n-\t\tor, if set explicitly, has _race appended to it.\n-\t-ldflags 'flag list'\n-\t\targuments to pass on each 5l, 6l, or 8l linker invocation.\n-\t-tags 'tag list'\n-\t\ta list of build tags to consider satisfied during the build.\n-\t\tFor more information about build tags, see the description of\n-\t\tbuild constraints in the documentation for the go/build package.\n-\n-The list flags accept a space-separated list of strings. To embed spaces\n-in an element in the list, surround it with either single or double quotes.\n-\n-For more about specifying packages, see 'go help packages'.\n-For more about where packages and binaries are installed,\n-run 'go help gopath'.  For more about calling between Go and C/C++,\n-run 'go help c'.\n-\n-See also: go install, go get, go clean.\n-\n-\n-Remove object files\n-\n-Usage:\n-\n-\tgo clean [-i] [-r] [-n] [-x] [build flags] [packages]\n-\n-Clean removes object files from package source directories.\n-The go command builds most objects in a temporary directory,\n-so go clean is mainly concerned with object files left by other\n-tools or by manual invocations of go build.\n-\n-Specifically, clean removes the following files from each of the\n-source directories corresponding to the import paths:\n-\n-\t_obj/            old object directory, left from Makefiles\n-\t_test/           old test directory, left from Makefiles\n-\t_testmain.go     old gotest file, left from Makefiles\n-\ttest.out         old test log, left from Makefiles\n-\tbuild.out        old test log, left from Makefiles\n-\t*.[568ao]        object files, left from Makefiles\n-\n-\tDIR(.exe)        from go build\n-\tDIR.test(.exe)   from go test -c\n-\tMAINFILE(.exe)   from go build MAINFILE.go\n-\t*.so             from SWIG\n-\n-In the list, DIR represents the final path element of the\n-directory, and MAINFILE is the base name of any Go source\n-file in the directory that is not included when building\n-the package.\n-\n-The -i flag causes clean to remove the corresponding installed\n-archive or binary (what 'go install' would create).\n-\n-The -n flag causes clean to print the remove commands it would execute,\n-but not run them.\n-\n-The -r flag causes clean to be applied recursively to all the\n-dependencies of the packages named by the import paths.\n-\n-The -x flag causes clean to print remove commands as it executes them.\n-\n-For more about build flags, see 'go help build'.\n-\n-For more about specifying packages, see 'go help packages'.\n-\n-\n-Print Go environment information\n-\n-Usage:\n-\n-\tgo env [var ...]\n-\n-Env prints Go environment information.\n-\n-By default env prints information as a shell script\n-(on Windows, a batch file).  If one or more variable\n-names is given as arguments,  env prints the value of\n-each named variable on its own line.\n-\n-\n-Run go tool fix on packages\n-\n-Usage:\n-\n-\tgo fix [packages]\n-\n-Fix runs the Go fix command on the packages named by the import paths.\n-\n-For more about fix, see 'godoc fix'.\n-For more about specifying packages, see 'go help packages'.\n-\n-To run fix with specific options, run 'go tool fix'.\n-\n-See also: go fmt, go vet.\n-\n-\n-Run gofmt on package sources\n-\n-Usage:\n-\n-\tgo fmt [-n] [-x] [packages]\n-\n-Fmt runs the command 'gofmt -l -w' on the packages named\n-by the import paths.  It prints the names of the files that are modified.\n-\n-For more about gofmt, see 'godoc gofmt'.\n-For more about specifying packages, see 'go help packages'.\n-\n-The -n flag prints commands that would be executed.\n-The -x flag prints commands as they are executed.\n-\n-To run gofmt with specific options, run gofmt itself.\n-\n-See also: go fix, go vet.\n-\n-\n-Generate Go files by processing source\n-\n-Usage:\n-\n-\tgo generate [-run regexp] [file.go... | packages]\n-\n-Generate runs commands described by directives within existing\n-files. Those commands can run any process but the intent is to\n-create or update Go source files, for instance by running yacc.\n-\n-Go generate is never run automatically by go build, go get, go test,\n-and so on. It must be run explicitly.\n-\n-Go generate scans the file for directives, which are lines of\n-the form,\n-\n-\t//go:generate command argument...\n-\n-(note: no leading spaces and no space in \"//go\") where command\n-is the generator to be run, corresponding to an executable file\n-that can be run locally. It must either be in the shell path\n-(gofmt), a fully qualified path (/usr/you/bin/mytool), or a\n-command alias, described below.\n-\n-Note that go generate does not parse the file, so lines that look\n-like directives in comments or multiline strings will be treated\n-as directives.\n-\n-The arguments to the directive are space-separated tokens or\n-double-quoted strings passed to the generator as individual\n-arguments when it is run.\n-\n-Quoted strings use Go syntax and are evaluated before execution; a\n-quoted string appears as a single argument to the generator.\n-\n-Go generate sets several variables when it runs the generator:\n-\n-\t$GOARCH\n-\t\tThe execution architecture (arm, amd64, etc.)\n-\t$GOOS\n-\t\tThe execution operating system (linux, windows, etc.)\n-\t$GOFILE\n-\t\tThe base name of the file.\n-\t$GOPACKAGE\n-\t\tThe name of the package of the file containing the directive.\n-\n-Other than variable substitution and quoted-string evaluation, no\n-special processing such as \"globbing\" is performed on the command\n-line.\n-\n-As a last step before running the command, any invocations of any\n-environment variables with alphanumeric names, such as $GOFILE or\n-$HOME, are expanded throughout the command line. The syntax for\n-variable expansion is $NAME on all operating systems.  Due to the\n-order of evaluation, variables are expanded even inside quoted\n-strings. If the variable NAME is not set, $NAME expands to the\n-empty string.\n-\n-A directive of the form,\n-\n-\t//go:generate -command xxx args...\n-\n-specifies, for the remainder of this source file only, that the\n-string xxx represents the command identified by the arguments. This\n-can be used to create aliases or to handle multiword generators.\n-For example,\n-\n-\t//go:generate -command yacc go tool yacc\n-\n-specifies that the command \"yacc\" represents the generator\n-\"go tool yacc\".\n-\n-Generate processes packages in the order given on the command line,\n-one at a time. If the command line lists .go files, they are treated\n-as a single package. Within a package, generate processes the\n-source files in a package in file name order, one at a time. Within\n-a source file, generate runs generators in the order they appear\n-in the file, one at a time.\n-\n-If any generator returns an error exit status, \"go generate\" skips\n-all further processing for that package.\n-\n-The generator is run in the package's source directory.\n-\n-Go generate accepts one specific flag:\n-\n-\t-run=\"\"\n-\t\tTODO: This flag is unimplemented.\n-\t\tif non-empty, specifies a regular expression to\n-\t\tselect directives whose command matches the expression.\n-\n-It also accepts the standard build flags -v, -n, and -x.\n-The -v flag prints the names of packages and files as they are\n-processed.\n-The -n flag prints commands that would be executed.\n-The -x flag prints commands as they are executed.\n-\n-For more about specifying packages, see 'go help packages'.\n-\n-\n-Download and install packages and dependencies\n-\n-Usage:\n-\n-\tgo get [-d] [-f] [-fix] [-t] [-u] [build flags] [packages]\n-\n-Get downloads and installs the packages named by the import paths,\n-along with their dependencies.\n-\n-The -d flag instructs get to stop after downloading the packages; that is,\n-it instructs get not to install the packages.\n-\n-The -f flag, valid only when -u is set, forces get -u not to verify that\n-each package has been checked out from the source control repository\n-implied by its import path. This can be useful if the source is a local fork\n-of the original.\n-\n-The -fix flag instructs get to run the fix tool on the downloaded packages\n-before resolving dependencies or building the code.\n-\n-The -t flag instructs get to also download the packages required to build\n-the tests for the specified packages.\n-\n-The -u flag instructs get to use the network to update the named packages\n-and their dependencies.  By default, get uses the network to check out\n-missing packages but does not use it to look for updates to existing packages.\n-\n-Get also accepts build flags to control the installation. See 'go help build'.\n-\n-When checking out or updating a package, get looks for a branch or tag\n-that matches the locally installed version of Go. The most important\n-rule is that if the local installation is running version \"go1\", get\n-searches for a branch or tag named \"go1\". If no such version exists it\n-retrieves the most recent version of the package.\n-\n-For more about specifying packages, see 'go help packages'.\n-\n-For more about how 'go get' finds source code to\n-download, see 'go help importpath'.\n-\n-See also: go build, go install, go clean.\n-\n-\n-Compile and install packages and dependencies\n-\n-Usage:\n-\n-\tgo install [build flags] [packages]\n-\n-Install compiles and installs the packages named by the import paths,\n-along with their dependencies.\n-\n-For more about the build flags, see 'go help build'.\n-For more about specifying packages, see 'go help packages'.\n-\n-See also: go build, go get, go clean.\n-\n-\n-List packages\n-\n-Usage:\n-\n-\tgo list [-e] [-f format] [-json] [build flags] [packages]\n-\n-List lists the packages named by the import paths, one per line.\n-\n-The default output shows the package import path:\n-\n-    code.google.com/p/google-api-go-client/books/v1\n-    code.google.com/p/goauth2/oauth\n-    code.google.com/p/sqlite\n-\n-The -f flag specifies an alternate format for the list, using the\n-syntax of package template.  The default output is equivalent to -f\n-'{{.ImportPath}}'. The struct being passed to the template is:\n-\n-    type Package struct {\n-        Dir           string // directory containing package sources\n-        ImportPath    string // import path of package in dir\n-        ImportComment string // path in import comment on package statement\n-        Name          string // package name\n-        Doc           string // package documentation string\n-        Target        string // install path\n-        Goroot        bool   // is this package in the Go root?\n-        Standard      bool   // is this package part of the standard Go library?\n-        Stale         bool   // would 'go install' do anything for this package?\n-        Root          string // Go root or Go path dir containing this package\n-\n-        // Source files\n-        GoFiles        []string // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)\n-        CgoFiles       []string // .go sources files that import \"C\"\n-        IgnoredGoFiles []string // .go sources ignored due to build constraints\n-        CFiles         []string // .c source files\n-        CXXFiles       []string // .cc, .cxx and .cpp source files\n-        MFiles         []string // .m source files\n-        HFiles         []string // .h, .hh, .hpp and .hxx source files\n-        SFiles         []string // .s source files\n-        SwigFiles      []string // .swig files\n-        SwigCXXFiles   []string // .swigcxx files\n-        SysoFiles      []string // .syso object files to add to archive\n-\n-        // Cgo directives\n-        CgoCFLAGS    []string // cgo: flags for C compiler\n-        CgoCPPFLAGS  []string // cgo: flags for C preprocessor\n-        CgoCXXFLAGS  []string // cgo: flags for C++ compiler\n-        CgoLDFLAGS   []string // cgo: flags for linker\n-        CgoPkgConfig []string // cgo: pkg-config names\n-\n-        // Dependency information\n-        Imports []string // import paths used by this package\n-        Deps    []string // all (recursively) imported dependencies\n-\n-        // Error information\n-        Incomplete bool            // this package or a dependency has an error\n-        Error      *PackageError   // error loading package\n-        DepsErrors []*PackageError // errors loading dependencies\n-\n-        TestGoFiles  []string // _test.go files in package\n-        TestImports  []string // imports from TestGoFiles\n-        XTestGoFiles []string // _test.go files outside package\n-        XTestImports []string // imports from XTestGoFiles\n-    }\n-\n-The template function \"join\" calls strings.Join.\n-\n-The template function \"context\" returns the build context, defined as:\n-\n-\ttype Context struct {\n-\t\tGOARCH        string   // target architecture\n-\t\tGOOS          string   // target operating system\n-\t\tGOROOT        string   // Go root\n-\t\tGOPATH        string   // Go path\n-\t\tCgoEnabled    bool     // whether cgo can be used\n-\t\tUseAllFiles   bool     // use files regardless of +build lines, file names\n-\t\tCompiler      string   // compiler to assume when computing target paths\n-\t\tBuildTags     []string // build constraints to match in +build lines\n-\t\tReleaseTags   []string // releases the current release is compatible with\n-\t\tInstallSuffix string   // suffix to use in the name of the install dir\n-\t}\n-\n-For more information about the meaning of these fields see the documentation\n-for the go/build package's Context type.\n-\n-The -json flag causes the package data to be printed in JSON format\n-instead of using the template format.\n-\n-The -e flag changes the handling of erroneous packages, those that\n-cannot be found or are malformed.  By default, the list command\n-prints an error to standard error for each erroneous package and\n-omits the packages from consideration during the usual printing.\n-With the -e flag, the list command never prints errors to standard\n-error and instead processes the erroneous packages with the usual\n-printing.  Erroneous packages will have a non-empty ImportPath and\n-a non-nil Error field; other information may or may not be missing\n-(zeroed).\n-\n-For more about build flags, see 'go help build'.\n-\n-For more about specifying packages, see 'go help packages'.\n-\n-\n-Compile and run Go program\n-\n-Usage:\n-\n-\tgo run [build flags] [-exec xprog] gofiles... [arguments...]\n-\n-Run compiles and runs the main package comprising the named Go source files.\n-A Go source file is defined to be a file ending in a literal \".go\" suffix.\n-\n-By default, 'go run' runs the compiled binary directly: 'a.out arguments...'.\n-If the -exec flag is given, 'go run' invokes the binary using xprog: 'xprog a.out arguments...'.\n-If the -exec flag is not given, GOOS or GOARCH is different from the system\n-default, and a program named go_$GOOS_$GOARCH_exec can be found\n-on the current search path, 'go run' invokes the binary using that program,\n-for example 'go_nacl_386_exec a.out arguments...'. This allows execution of\n-cross-compiled programs when a simulator or other execution method is\n-available.\n-\n-For more about build flags, see 'go help build'.\n-\n-See also: go build.\n-\n-\n-Test packages\n-\n-Usage:\n-\n-\tgo test [-c] [-i] [build and test flags] [packages] [flags for test binary]\n-\n-'Go test' automates testing the packages named by the import paths.\n-It prints a summary of the test results in the format:\n-\n-\tok   archive/tar   0.011s\n-\tFAIL archive/zip   0.022s\n-\tok   compress/gzip 0.033s\n-\t...\n-\n-followed by detailed output for each failed package.\n-\n-'Go test' recompiles each package along with any files with names matching\n-the file pattern \"*_test.go\".\n-Files whose names begin with \"_\" (including \"_test.go\") or \".\" are ignored.\n-These additional files can contain test functions, benchmark functions, and\n-example functions.  See 'go help testfunc' for more.\n-Each listed package causes the execution of a separate test binary.\n-\n-Test files that declare a package with the suffix \"_test\" will be compiled as a\n-separate package, and then linked and run with the main test binary.\n-\n-By default, go test needs no arguments.  It compiles and tests the package\n-with source in the current directory, including tests, and runs the tests.\n-\n-The package is built in a temporary directory so it does not interfere with the\n-non-test installation.\n-\n-In addition to the build flags, the flags handled by 'go test' itself are:\n+package main\n \n+var cmdDoc = &Command{\n+\tRun:         runDoc,\n+\tUsageLine:   \"doc [-u] [-c] [package|[package.]symbol[.method]]\",\n+\tCustomFlags: true,\n+\tShort:       \"show documentation for package or symbol\",\n+\tLong: `\n+Doc prints the documentation comments associated with the item identified by its\n+arguments (a package, const, func, type, var, or method) followed by a one-line\n+summary of each of the first-level items \"under\" that item (package-level\n+declarations for a package, methods for a type, etc.).\n+\n+Doc accepts zero, one, or two arguments.\n+\n+Given no arguments, that is, when run as\n+\n+\tgo doc\n+\n+it prints the package documentation for the package in the current directory.\n+If the package is a command (package main), the exported symbols of the package\n+are elided from the presentation unless the -cmd flag is provided.\n+\n+When run with one argument, the argument is treated as a Go-syntax-like\n+representation of the item to be documented. What the argument selects depends\n+on what is installed in GOROOT and GOPATH, as well as the form of the argument,\n+which is schematically one of these:\n+\n+\tgo doc <pkg>\n+\tgo doc <sym>[.<method>]\n+\tgo doc [<pkg>].<sym>[.<method>]\n+\n+The first item in this list matched by the argument is the one whose\n+documentation is printed. (See the examples below.) For packages, the order of\n+scanning is determined lexically, but the GOROOT tree is always scanned before\n+GOPATH.\n+\n+If there is no package specified or matched, the package in the current\n+directory is selected, so \"go doc Foo\" shows the documentation for symbol Foo in\n+the current package.\n+\n+The package path must be either a qualified path or a proper suffix of a\n+path. The go tool's usual package mechanism does not apply: package path\n+elements like . and ... are not implemented by go doc.\n+\n+When run with two arguments, the first must be a full package path (not just a\n+suffix), and the second is a symbol or symbol and method; this is similar to the\n+syntax accepted by godoc:\n+\n+\tgo doc <pkg> <sym>[.<method>]\n+\n+In all forms, when matching symbols, lower-case letters in the argument match\n+either case but upper-case letters match exactly. This means that there may be\n+multiple matches of a lower-case argument in a package if different symbols have\n+different cases. If this occurs, documentation for all matches is printed.\n+\n+Examples:\n+\tgo doc\n+\t\tShow documentation for current package.\n+\tgo doc Foo\n+\t\tShow documentation for Foo in the current package.\n+\t\t(Foo starts with a capital letter so it cannot match\n+\t\ta package path.)\n+\tgo doc encoding/json\n+\t\tShow documentation for the encoding/json package.\n+\tgo doc json\n+\t\tShorthand for encoding/json.\n+\tgo doc json.Number (or go doc json.number)\n+\t\tShow documentation and method summary for json.Number.\n+\tgo doc json.Number.Int64 (or go doc json.number.int64)\n+\t\tShow documentation for json.Number's Int64 method.\n+\tgo doc cmd/doc\n+\t\tShow package docs for the doc command.\n+\tgo doc -cmd cmd/doc\n+\t\tShow package docs and exported symbols within the doc command.\n+\tgo doc template.new\n+\t\tShow documentation for html/template's New function.\n+\t\t(html/template is lexically before text/template)\n+\tgo doc text/template.new # One argument\n+\t\tShow documentation for text/template's New function.\n+\tgo doc text/template new # Two arguments\n+\t\tShow documentation for text/template's New function.\n+\n+Flags:\n \t-c\n-\t\tCompile the test binary to pkg.test but do not run it\n-\t\t(where pkg is the last element of the package's import path).\n-\t\tThe file name can be changed with the -o flag.\n-\n-\t-exec xprog\n-\t    Run the test binary using xprog. The behavior is the same as\n-\t    in 'go run'. See 'go help run' for details.\n-\n-\t-i\n-\t    Install packages that are dependencies of the test.\n-\t    Do not run the test.\n-\n-\t-o file\n-\t\tCompile the test binary to the named file.\n-\t\tThe test still runs (unless -c or -i is specified).\n-\n-\n-The test binary also accepts flags that control execution of the test; these\n-flags are also accessible by 'go test'.  See 'go help testflag' for details.\n-\n-If the test binary needs any other flags, they should be presented after the\n-package names. The go tool treats as a flag the first argument that begins with\n-a minus sign that it does not recognize itself; that argument and all subsequent\n-arguments are passed as arguments to the test binary.\n-\n-For more about build flags, see 'go help build'.\n-For more about specifying packages, see 'go help packages'.\n-\n-See also: go build, go vet.\n-\n-\n-Run specified go tool\n-\n-Usage:\n-\n-\tgo tool [-n] command [args...]\n-\n-Tool runs the go tool command identified by the arguments.\n-With no arguments it prints the list of known tools.\n-\n-The -n flag causes tool to print the command that would be\n-executed but not execute it.\n-\n-For more about each tool command, see 'go tool command -h'.\n-\n-\n-Print Go version\n-\n-Usage:\n-\n-\tgo version\n-\n-Version prints the Go version, as reported by runtime.Version.\n-\n-\n-Run go tool vet on packages\n-\n-Usage:\n-\n-\tgo vet [-n] [-x] [packages]\n-\n-Vet runs the Go vet command on the packages named by the import paths.\n-\n-For more about vet, see 'godoc golang.org/x/tools/cmd/vet'.\n-For more about specifying packages, see 'go help packages'.\n-\n-To run the vet tool with specific options, run 'go tool vet'.\n-\n-The -n flag prints commands that would be executed.\n-The -x flag prints commands as they are executed.\n-\n-See also: go fmt, go fix.\n-\n-\n-Calling between Go and C\n-\n-There are two different ways to call between Go and C/C++ code.\n-\n-The first is the cgo tool, which is part of the Go distribution.  For\n-information on how to use it see the cgo documentation (godoc cmd/cgo).\n-\n-The second is the SWIG program, which is a general tool for\n-interfacing between languages.  For information on SWIG see\n-http://swig.org/.  When running go build, any file with a .swig\n-extension will be passed to SWIG.  Any file with a .swigcxx extension\n-will be passed to SWIG with the -c++ option.\n-\n-When either cgo or SWIG is used, go build will pass any .c, .m, .s,\n-or .S files to the C compiler, and any .cc, .cpp, .cxx files to the C++\n-compiler.  The CC or CXX environment variables may be set to determine\n-the C or C++ compiler, respectively, to use.\n-\n-\n-File types\n-\n-The go command examines the contents of a restricted set of files\n-in each directory. It identifies which files to examine based on\n-the extension of the file name. These extensions are:\n-\n-\t.go\n-\t\tGo source files.\n-\t.c, .h\n-\t\tC source files.\n-\t\tIf the package uses cgo, these will be compiled with the\n-\t\tOS-native compiler (typically gcc); otherwise they will be\n-\t\tcompiled with the Go-specific support compiler,\n-\t\t5c, 6c, or 8c, etc. as appropriate.\n-\t.cc, .cpp, .cxx, .hh, .hpp, .hxx\n-\t\tC++ source files. Only useful with cgo or SWIG, and always\n-\t\tcompiled with the OS-native compiler.\n-\t.m\n-\t\tObjective-C source files. Only useful with cgo, and always\n-\t\tcompiled with the OS-native compiler.\n-\t.s, .S\n-\t\tAssembler source files.\n-\t\tIf the package uses cgo, these will be assembled with the\n-\t\tOS-native assembler (typically gcc (sic)); otherwise they\n-\t\twill be assembled with the Go-specific support assembler,\n-\t\t5a, 6a, or 8a, etc., as appropriate.\n-\t.swig, .swigcxx\n-\t\tSWIG definition files.\n-\t.syso\n-\t\tSystem object files.\n-\n-Files of each of these types except .syso may contain build\n-constraints, but the go command stops scanning for build constraints\n-at the first item in the file that is not a blank line or //-style\n-line comment.\n-\n-\n-GOPATH environment variable\n-\n-The Go path is used to resolve import statements.\n-It is implemented by and documented in the go/build package.\n-\n-The GOPATH environment variable lists places to look for Go code.\n-On Unix, the value is a colon-separated string.\n-On Windows, the value is a semicolon-separated string.\n-On Plan 9, the value is a list.\n-\n-GOPATH must be set to get, build and install packages outside the\n-standard Go tree.\n-\n-Each directory listed in GOPATH must have a prescribed structure:\n-\n-The src/ directory holds source code.  The path below 'src'\n-determines the import path or executable name.\n-\n-The pkg/ directory holds installed package objects.\n-As in the Go tree, each target operating system and\n-architecture pair has its own subdirectory of pkg\n-(pkg/GOOS_GOARCH).\n-\n-If DIR is a directory listed in the GOPATH, a package with\n-source in DIR/src/foo/bar can be imported as \"foo/bar\" and\n-has its compiled form installed to \"DIR/pkg/GOOS_GOARCH/foo/bar.a\".\n-\n-The bin/ directory holds compiled commands.\n-Each command is named for its source directory, but only\n-the final element, not the entire path.  That is, the\n-command with source in DIR/src/foo/quux is installed into\n-DIR/bin/quux, not DIR/bin/foo/quux.  The foo/ is stripped\n-so that you can add DIR/bin to your PATH to get at the\n-installed commands.  If the GOBIN environment variable is\n-set, commands are installed to the directory it names instead\n-of DIR/bin.\n-\n-Here's an example directory layout:\n-\n-    GOPATH=/home/user/gocode\n-\n-    /home/user/gocode/\n-        src/\n-            foo/\n-                bar/               (go code in package bar)\n-                    x.go\n-                quux/              (go code in package main)\n-                    y.go\n-        bin/\n-            quux                   (installed command)\n-        pkg/\n-            linux_amd64/\n-                foo/\n-                    bar.a          (installed package object)\n-\n-Go searches each directory listed in GOPATH to find source code,\n-but new packages are always downloaded into the first directory\n-in the list.\n-\n-\n-Import path syntax\n-\n-An import path (see 'go help packages') denotes a package\n-stored in the local file system.  In general, an import path denotes\n-either a standard package (such as \"unicode/utf8\") or a package\n-found in one of the work spaces (see 'go help gopath').\n-\n-Relative import paths\n-\n-An import path beginning with ./ or ../ is called a relative path.\n-The toolchain supports relative import paths as a shortcut in two ways.\n-\n-First, a relative path can be used as a shorthand on the command line.\n-If you are working in the directory containing the code imported as\n-\"unicode\" and want to run the tests for \"unicode/utf8\", you can type\n-\"go test ./utf8\" instead of needing to specify the full path.\n-Similarly, in the reverse situation, \"go test ..\" will test \"unicode\" from\n-the \"unicode/utf8\" directory. Relative patterns are also allowed, like\n-\"go test ./...\" to test all subdirectories. See 'go help packages' for details\n-on the pattern syntax.\n-\n-Second, if you are compiling a Go program not in a work space,\n-you can use a relative path in an import statement in that program\n-to refer to nearby code also not in a work space.\n-This makes it easy to experiment with small multipackage programs\n-outside of the usual work spaces, but such programs cannot be\n-installed with \"go install\" (there is no work space in which to install them),\n-so they are rebuilt from scratch each time they are built.\n-To avoid ambiguity, Go programs cannot use relative import paths\n-within a work space.\n-\n-Remote import paths\n-\n-Certain import paths also\n-describe how to obtain the source code for the package using\n-a revision control system.\n-\n-A few common code hosting sites have special syntax:\n-\n-\tBitbucket (Git, Mercurial)\n-\n-\t\timport \"bitbucket.org/user/project\"\n-\t\timport \"bitbucket.org/user/project/sub/directory\"\n-\n-\tGitHub (Git)\n-\n-\t\timport \"github.com/user/project\"\n-\t\timport \"github.com/user/project/sub/directory\"\n-\n-\tGoogle Code Project Hosting (Git, Mercurial, Subversion)\n-\n-\t\timport \"code.google.com/p/project\"\n-\t\timport \"code.google.com/p/project/sub/directory\"\n-\n-\t\timport \"code.google.com/p/project.subrepository\"\n-\t\timport \"code.google.com/p/project.subrepository/sub/directory\"\n-\n-\tLaunchpad (Bazaar)\n-\n-\t\timport \"launchpad.net/project\"\n-\t\timport \"launchpad.net/project/series\"\n-\t\timport \"launchpad.net/project/series/sub/directory\"\n-\n-\t\timport \"launchpad.net/~user/project/branch\"\n-\t\timport \"launchpad.net/~user/project/branch/sub/directory\"\n-\n-\tIBM DevOps Services (Git)\n-\n-\t\timport \"hub.jazz.net/git/user/project\"\n-\t\timport \"hub.jazz.net/git/user/project/sub/directory\"\n-\n-For code hosted on other servers, import paths may either be qualified\n-with the version control type, or the go tool can dynamically fetch\n-the import path over https/http and discover where the code resides\n-from a <meta> tag in the HTML.\n-\n-To declare the code location, an import path of the form\n-\n-\trepository.vcs/path\n-\n-specifies the given repository, with or without the .vcs suffix,\n-using the named version control system, and then the path inside\n-that repository.  The supported version control systems are:\n-\n-\tBazaar      .bzr\n-\tGit         .git\n-\tMercurial   .hg\n-\tSubversion  .svn\n-\n-For example,\n-\n-\timport \"example.org/user/foo.hg\"\n-\n-denotes the root directory of the Mercurial repository at\n-example.org/user/foo or foo.hg, and\n-\n-\timport \"example.org/repo.git/foo/bar\"\n-\n-denotes the foo/bar directory of the Git repository at\n-example.org/repo or repo.git.\n-\n-When a version control system supports multiple protocols,\n-each is tried in turn when downloading.  For example, a Git\n-download tries git://, then https://, then http://.\n-\n-If the import path is not a known code hosting site and also lacks a\n-version control qualifier, the go tool attempts to fetch the import\n-over https/http and looks for a <meta> tag in the document's HTML\n-<head>.\n-\n-The meta tag has the form:\n-\n-\t<meta name=\"go-import\" content=\"import-prefix vcs repo-root\">\n-\n-The import-prefix is the import path corresponding to the repository\n-root. It must be a prefix or an exact match of the package being\n-fetched with \"go get\". If it's not an exact match, another http\n-request is made at the prefix to verify the <meta> tags match.\n-\n-The vcs is one of \"git\", \"hg\", \"svn\", etc,\n-\n-The repo-root is the root of the version control system\n-containing a scheme and not containing a .vcs qualifier.\n-\n-For example,\n-\n-\timport \"example.org/pkg/foo\"\n-\n-will result in the following request(s):\n-\n-\thttps://example.org/pkg/foo?go-get=1 (preferred)\n-\thttp://example.org/pkg/foo?go-get=1  (fallback)\n-\n-If that page contains the meta tag\n-\n-\t<meta name=\"go-import\" content=\"example.org git https://code.org/r/p/exproj\">\n-\n-the go tool will verify that https://example.org/?go-get=1 contains the\n-same meta tag and then git clone https://code.org/r/p/exproj into\n-GOPATH/src/example.org.\n-\n-New downloaded packages are written to the first directory\n-listed in the GOPATH environment variable (see 'go help gopath').\n-\n-The go command attempts to download the version of the\n-package appropriate for the Go release being used.\n-Run 'go help get' for more.\n-\n-Import path checking\n-\n-When the custom import path feature described above redirects to a\n-known code hosting site, each of the resulting packages has two possible\n-import paths, using the custom domain or the known hosting site.\n-\n-A package statement is said to have an \"import comment\" if it is immediately\n-followed (before the next newline) by a comment of one of these two forms:\n-\n-\tpackage math // import \"path\"\n-\tpackage math /* import \"path\" * /\n-\n-The go command will refuse to install a package with an import comment\n-unless it is being referred to by that import path. In this way, import comments\n-let package authors make sure the custom import path is used and not a\n-direct path to the underlying code hosting site.\n-\n-See https://golang.org/s/go14customimport for details.\n-\n-\n-Description of package lists\n-\n-Many commands apply to a set of packages:\n-\n-\tgo action [packages]\n-\n-Usually, [packages] is a list of import paths.\n-\n-An import path that is a rooted path or that begins with\n-a . or .. element is interpreted as a file system path and\n-denotes the package in that directory.\n-\n-Otherwise, the import path P denotes the package found in\n-the directory DIR/src/P for some DIR listed in the GOPATH\n-environment variable (see 'go help gopath').\n-\n-If no import paths are given, the action applies to the\n-package in the current directory.\n-\n-There are three reserved names for paths that should not be used\n-for packages to be built with the go tool:\n-\n-- \"main\" denotes the top-level package in a stand-alone executable.\n-\n-- \"all\" expands to all package directories found in all the GOPATH\n-trees. For example, 'go list all' lists all the packages on the local\n-system.\n-\n-- \"std\" is like all but expands to just the packages in the standard\n-Go library.\n-\n-An import path is a pattern if it includes one or more \"...\" wildcards,\n-each of which can match any string, including the empty string and\n-strings containing slashes.  Such a pattern expands to all package\n-directories found in the GOPATH trees with names matching the\n-patterns.  As a special case, x/... matches x as well as x's subdirectories.\n-For example, net/... expands to net and packages in its subdirectories.\n-\n-An import path can also name a package to be downloaded from\n-a remote repository.  Run 'go help importpath' for details.\n-\n-Every package in a program must have a unique import path.\n-By convention, this is arranged by starting each path with a\n-unique prefix that belongs to you.  For example, paths used\n-internally at Google all begin with 'google', and paths\n-denoting remote repositories begin with the path to the code,\n-such as 'code.google.com/p/project'.\n-\n-As a special case, if the package list is a list of .go files from a\n-single directory, the command is applied to a single synthesized\n-package made up of exactly those files, ignoring any build constraints\n-in those files and ignoring any other files in the directory.\n-\n-Directory and file names that begin with \".\" or \"_\" are ignored\n-by the go tool, as are directories named \"testdata\".\n-\n-\n-Description of testing flags\n-\n-The 'go test' command takes both flags that apply to 'go test' itself\n-and flags that apply to the resulting test binary.\n-\n-Several of the flags control profiling and write an execution profile\n-suitable for \"go tool pprof\"; run \"go tool pprof help\" for more\n-information.  The --alloc_space, --alloc_objects, and --show_bytes\n-options of pprof control how the information is presented.\n-\n-The following flags are recognized by the 'go test' command and\n-control the execution of any test:\n-\n-\t-bench regexp\n-\t    Run benchmarks matching the regular expression.\n-\t    By default, no benchmarks run. To run all benchmarks,\n-\t    use '-bench .' or '-bench=.'.\n-\n-\t-benchmem\n-\t    Print memory allocation statistics for benchmarks.\n-\n-\t-benchtime t\n-\t    Run enough iterations of each benchmark to take t, specified\n-\t    as a time.Duration (for example, -benchtime 1h30s).\n-\t    The default is 1 second (1s).\n-\n-\t-blockprofile block.out\n-\t    Write a goroutine blocking profile to the specified file\n-\t    when all tests are complete.\n-\t    Writes test binary as -c would.\n-\n-\t-blockprofilerate n\n-\t    Control the detail provided in goroutine blocking profiles by\n-\t    calling runtime.SetBlockProfileRate with n.\n-\t    See 'godoc runtime SetBlockProfileRate'.\n-\t    The profiler aims to sample, on average, one blocking event every\n-\t    n nanoseconds the program spends blocked.  By default,\n-\t    if -test.blockprofile is set without this flag, all blocking events\n-\t    are recorded, equivalent to -test.blockprofilerate=1.\n-\n-\t-cover\n-\t    Enable coverage analysis.\n-\n-\t-covermode set,count,atomic\n-\t    Set the mode for coverage analysis for the package[s]\n-\t    being tested. The default is \"set\" unless -race is enabled,\n-\t    in which case it is \"atomic\".\n-\t    The values:\n-\t\tset: bool: does this statement run?\n-\t\tcount: int: how many times does this statement run?\n-\t\tatomic: int: count, but correct in multithreaded tests;\n-\t\t\tsignificantly more expensive.\n-\t    Sets -cover.\n-\n-\t-coverpkg pkg1,pkg2,pkg3\n-\t    Apply coverage analysis in each test to the given list of packages.\n-\t    The default is for each test to analyze only the package being tested.\n-\t    Packages are specified as import paths.\n-\t    Sets -cover.\n-\n-\t-coverprofile cover.out\n-\t    Write a coverage profile to the file after all tests have passed.\n-\t    Sets -cover.\n-\n-\t-cpu 1,2,4\n-\t    Specify a list of GOMAXPROCS values for which the tests or\n-\t    benchmarks should be executed.  The default is the current value\n-\t    of GOMAXPROCS.\n-\n-\t-cpuprofile cpu.out\n-\t    Write a CPU profile to the specified file before exiting.\n-\t    Writes test binary as -c would.\n-\n-\t-memprofile mem.out\n-\t    Write a memory profile to the file after all tests have passed.\n-\t    Writes test binary as -c would.\n-\n-\t-memprofilerate n\n-\t    Enable more precise (and expensive) memory profiles by setting\n-\t    runtime.MemProfileRate.  See 'godoc runtime MemProfileRate'.\n-\t    To profile all memory allocations, use -test.memprofilerate=1\n-\t    and pass --alloc_space flag to the pprof tool.\n-\n-\t-outputdir directory\n-\t    Place output files from profiling in the specified directory,\n-\t    by default the directory in which \"go test\" is running.\n-\n-\t-parallel n\n-\t    Allow parallel execution of test functions that call t.Parallel.\n-\t    The value of this flag is the maximum number of tests to run\n-\t    simultaneously; by default, it is set to the value of GOMAXPROCS.\n-\n-\t-run regexp\n-\t    Run only those tests and examples matching the regular\n-\t    expression.\n-\n-\t-short\n-\t    Tell long-running tests to shorten their run time.\n-\t    It is off by default but set during all.bash so that installing\n-\t    the Go tree can run a sanity check but not spend time running\n-\t    exhaustive tests.\n-\n-\t-timeout t\n-\t    If a test runs longer than t, panic.\n-\n-\t-v\n-\t    Verbose output: log all tests as they are run. Also print all\n-\t    text from Log and Logf calls even if the test succeeds.\n-\n-The test binary, called pkg.test where pkg is the name of the\n-directory containing the package sources, can be invoked directly\n-after building it with 'go test -c'. When invoking the test binary\n-directly, each of the standard flag names must be prefixed with 'test.',\n-as in -test.run=TestMyFunc or -test.v.\n-\n-When running 'go test', flags not listed above are passed through\n-unaltered. For instance, the command\n-\n-\tgo test -x -v -cpuprofile=prof.out -dir=testdata -update\n-\n-will compile the test binary and then run it as\n-\n-\tpkg.test -test.v -test.cpuprofile=prof.out -dir=testdata -update\n-\n-The test flags that generate profiles (other than for coverage) also\n-leave the test binary in pkg.test for use when analyzing the profiles.\n-\n-Flags not recognized by 'go test' must be placed after any specified packages.\n-\n-\n-Description of testing functions\n-\n-The 'go test' command expects to find test, benchmark, and example functions\n-in the \"*_test.go\" files corresponding to the package under test.\n-\n-A test function is one named TestXXX (where XXX is any alphanumeric string\n-not starting with a lower case letter) and should have the signature,\n-\n-\tfunc TestXXX(t *testing.T) { ... }\n-\n-A benchmark function is one named BenchmarkXXX and should have the signature,\n-\n-\tfunc BenchmarkXXX(b *testing.B) { ... }\n-\n-An example function is similar to a test function but, instead of using\n-*testing.T to report success or failure, prints output to os.Stdout.\n-That output is compared against the function's \"Output:\" comment, which\n-must be the last comment in the function body (see example below). An\n-example with no such comment, or with no text after \"Output:\" is compiled\n-but not executed.\n-\n-Godoc displays the body of ExampleXXX to demonstrate the use\n-of the function, constant, or variable XXX.  An example of a method M with\n-receiver type T or *T is named ExampleT_M.  There may be multiple examples\n-for a given function, constant, or variable, distinguished by a trailing _xxx,\n-where xxx is a suffix not beginning with an upper case letter.\n-\n-Here is an example of an example:\n-\n-\tfunc ExamplePrintln() {\n-\t\tPrintln(\"The output of\\nthis example.\")\n-\t\t// Output: The output of\n-\t\t// this example.\n-\t}\n-\n-The entire test file is presented as the example when it contains a single\n-example function, at least one other function, type, variable, or constant\n-declaration, and no test or benchmark functions.\n-\n-See the documentation of the testing package for more information.\n-\n-\n-*/\n-package main\n+\t\tRespect case when matching symbols.\n+\t-cmd\n+\t\tTreat a command (package main) like a regular package.\n+\t\tOtherwise package main's exported symbols are hidden\n+\t\twhen showing the package's top-level documentation.\n+\t-u\n+\t\tShow documentation for unexported as well as exported\n+\t\tsymbols and methods.\n+`,\n+}\n+\n+func runDoc(cmd *Command, args []string) {\n+\trun(buildToolExec, tool(\"doc\"), args)\n+}"}, {"sha": "600accac03f2767bf086d45b8a94ec5313d8d123", "filename": "libgo/go/cmd/go/env.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Fenv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Fenv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fenv.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -36,7 +36,6 @@ func mkEnv() []envVar {\n \tenv := []envVar{\n \t\t{\"GOARCH\", goarch},\n \t\t{\"GOBIN\", gobin},\n-\t\t{\"GOCHAR\", archChar},\n \t\t{\"GOEXE\", exeSuffix},\n \t\t{\"GOHOSTARCH\", runtime.GOARCH},\n \t\t{\"GOHOSTOS\", runtime.GOOS},\n@@ -45,6 +44,7 @@ func mkEnv() []envVar {\n \t\t{\"GORACE\", os.Getenv(\"GORACE\")},\n \t\t{\"GOROOT\", goroot},\n \t\t{\"GOTOOLDIR\", toolDir},\n+\t\t{\"GO15VENDOREXPERIMENT\", os.Getenv(\"GO15VENDOREXPERIMENT\")},\n \n \t\t// disable escape codes in clang errors\n \t\t{\"TERM\", \"dumb\"},"}, {"sha": "94fd22e3c2150ec64d4840d15a262e025968a463", "filename": "libgo/go/cmd/go/fix.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ffix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ffix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ffix.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -11,7 +11,7 @@ var cmdFix = &Command{\n \tLong: `\n Fix runs the Go fix command on the packages named by the import paths.\n \n-For more about fix, see 'godoc fix'.\n+For more about fix, see 'go doc cmd/fix'.\n For more about specifying packages, see 'go help packages'.\n \n To run fix with specific options, run 'go tool fix'.\n@@ -25,6 +25,6 @@ func runFix(cmd *Command, args []string) {\n \t\t// Use pkg.gofiles instead of pkg.Dir so that\n \t\t// the command only applies to this package,\n \t\t// not to packages in subdirectories.\n-\t\trun(stringList(tool(\"fix\"), relPaths(pkg.allgofiles)))\n+\t\trun(stringList(buildToolExec, tool(\"fix\"), relPaths(pkg.allgofiles)))\n \t}\n }"}, {"sha": "57c02ad26477f483c4fe3422809076a7a32070d4", "filename": "libgo/go/cmd/go/fmt.go", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ffmt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ffmt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ffmt.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -4,6 +4,11 @@\n \n package main\n \n+import (\n+\t\"os\"\n+\t\"path/filepath\"\n+)\n+\n func init() {\n \taddBuildFlagsNX(cmdFmt)\n }\n@@ -16,7 +21,7 @@ var cmdFmt = &Command{\n Fmt runs the command 'gofmt -l -w' on the packages named\n by the import paths.  It prints the names of the files that are modified.\n \n-For more about gofmt, see 'godoc gofmt'.\n+For more about gofmt, see 'go doc cmd/gofmt'.\n For more about specifying packages, see 'go help packages'.\n \n The -n flag prints commands that would be executed.\n@@ -29,10 +34,31 @@ See also: go fix, go vet.\n }\n \n func runFmt(cmd *Command, args []string) {\n+\tgofmt := gofmtPath()\n \tfor _, pkg := range packages(args) {\n \t\t// Use pkg.gofiles instead of pkg.Dir so that\n \t\t// the command only applies to this package,\n \t\t// not to packages in subdirectories.\n-\t\trun(stringList(\"gofmt\", \"-l\", \"-w\", relPaths(pkg.allgofiles)))\n+\t\trun(stringList(gofmt, \"-l\", \"-w\", relPaths(pkg.allgofiles)))\n \t}\n }\n+\n+func gofmtPath() string {\n+\tgofmt := \"gofmt\"\n+\tif toolIsWindows {\n+\t\tgofmt += toolWindowsExtension\n+\t}\n+\n+\tgofmtPath := filepath.Join(gobin, gofmt)\n+\tif _, err := os.Stat(gofmtPath); err == nil {\n+\t\treturn gofmtPath\n+\t}\n+\n+\tgofmtPath = filepath.Join(goroot, \"bin\", gofmt)\n+\tif _, err := os.Stat(gofmtPath); err == nil {\n+\t\treturn gofmtPath\n+\t}\n+\n+\t// fallback to looking for gofmt in $PATH\n+\treturn \"gofmt\"\n+}"}, {"sha": "efdc229b2281a2e0463e12d4308c85299ed56c74", "filename": "libgo/go/cmd/go/generate.go", "status": "modified", "additions": 46, "deletions": 39, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Fgenerate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Fgenerate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgenerate.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -13,11 +13,11 @@ import (\n \t\"os\"\n \t\"os/exec\"\n \t\"path/filepath\"\n+\t\"regexp\"\n \t\"runtime\"\n \t\"strconv\"\n \t\"strings\"\n \t\"unicode\"\n-\t\"unicode/utf8\"\n )\n \n var cmdGenerate = &Command{\n@@ -62,8 +62,12 @@ Go generate sets several variables when it runs the generator:\n \t\tThe execution operating system (linux, windows, etc.)\n \t$GOFILE\n \t\tThe base name of the file.\n+\t$GOLINE\n+\t\tThe line number of the directive in the source file.\n \t$GOPACKAGE\n \t\tThe name of the package of the file containing the directive.\n+\t$DOLLAR\n+\t\tA dollar sign.\n \n Other than variable substitution and quoted-string evaluation, no\n special processing such as \"globbing\" is performed on the command\n@@ -106,9 +110,10 @@ The generator is run in the package's source directory.\n Go generate accepts one specific flag:\n \n \t-run=\"\"\n-\t\tTODO: This flag is unimplemented.\n-\t\tif non-empty, specifies a regular expression to\n-\t\tselect directives whose command matches the expression.\n+\t\tif non-empty, specifies a regular expression to select\n+\t\tdirectives whose full original source text (excluding\n+\t\tany trailing spaces and final newline) matches the\n+\t\texpression.\n \n It also accepts the standard build flags -v, -n, and -x.\n The -v flag prints the names of packages and files as they are\n@@ -120,14 +125,24 @@ For more about specifying packages, see 'go help packages'.\n \t`,\n }\n \n-var generateRunFlag string // generate -run flag\n+var (\n+\tgenerateRunFlag string         // generate -run flag\n+\tgenerateRunRE   *regexp.Regexp // compiled expression for -run\n+)\n \n func init() {\n \taddBuildFlags(cmdGenerate)\n \tcmdGenerate.Flag.StringVar(&generateRunFlag, \"run\", \"\", \"\")\n }\n \n func runGenerate(cmd *Command, args []string) {\n+\tif generateRunFlag != \"\" {\n+\t\tvar err error\n+\t\tgenerateRunRE, err = regexp.Compile(generateRunFlag)\n+\t\tif err != nil {\n+\t\t\tlog.Fatalf(\"generate: %s\", err)\n+\t\t}\n+\t}\n \t// Even if the arguments are .go files, this loop suffices.\n \tfor _, pkg := range packages(args) {\n \t\tfor _, file := range pkg.gofiles {\n@@ -163,7 +178,7 @@ type Generator struct {\n \tfile     string // base name of file.\n \tpkg      string\n \tcommands map[string][]string\n-\tlineNum  int\n+\tlineNum  int // current line number.\n }\n \n // run runs the generators in the current file.\n@@ -221,6 +236,11 @@ func (g *Generator) run() (ok bool) {\n \t\tif !isGoGenerate(buf) {\n \t\t\tcontinue\n \t\t}\n+\t\tif generateRunFlag != \"\" {\n+\t\t\tif !generateRunRE.Match(bytes.TrimSpace(buf)) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t}\n \n \t\twords := g.split(string(buf))\n \t\tif len(words) == 0 {\n@@ -306,7 +326,7 @@ Words:\n \t}\n \t// Substitute environment variables.\n \tfor i, word := range words {\n-\t\twords[i] = g.expandEnv(word)\n+\t\twords[i] = os.Expand(word, g.expandVar)\n \t}\n \treturn words\n }\n@@ -322,38 +342,25 @@ func (g *Generator) errorf(format string, args ...interface{}) {\n \tpanic(stop)\n }\n \n-// expandEnv expands any $XXX invocations in word.\n-func (g *Generator) expandEnv(word string) string {\n-\tif !strings.ContainsRune(word, '$') {\n-\t\treturn word\n-\t}\n-\tvar buf bytes.Buffer\n-\tvar w int\n-\tvar r rune\n-\tfor i := 0; i < len(word); i += w {\n-\t\tr, w = utf8.DecodeRuneInString(word[i:])\n-\t\tif r != '$' {\n-\t\t\tbuf.WriteRune(r)\n-\t\t\tcontinue\n-\t\t}\n-\t\tw += g.identLength(word[i+w:])\n-\t\tenvVar := word[i+1 : i+w]\n-\t\tvar sub string\n-\t\tswitch envVar {\n-\t\tcase \"GOARCH\":\n-\t\t\tsub = runtime.GOARCH\n-\t\tcase \"GOOS\":\n-\t\t\tsub = runtime.GOOS\n-\t\tcase \"GOFILE\":\n-\t\t\tsub = g.file\n-\t\tcase \"GOPACKAGE\":\n-\t\t\tsub = g.pkg\n-\t\tdefault:\n-\t\t\tsub = os.Getenv(envVar)\n-\t\t}\n-\t\tbuf.WriteString(sub)\n+// expandVar expands the $XXX invocation in word. It is called\n+// by os.Expand.\n+func (g *Generator) expandVar(word string) string {\n+\tswitch word {\n+\tcase \"GOARCH\":\n+\t\treturn buildContext.GOARCH\n+\tcase \"GOOS\":\n+\t\treturn buildContext.GOOS\n+\tcase \"GOFILE\":\n+\t\treturn g.file\n+\tcase \"GOLINE\":\n+\t\treturn fmt.Sprint(g.lineNum)\n+\tcase \"GOPACKAGE\":\n+\t\treturn g.pkg\n+\tcase \"DOLLAR\":\n+\t\treturn \"$\"\n+\tdefault:\n+\t\treturn os.Getenv(word)\n \t}\n-\treturn buf.String()\n }\n \n // identLength returns the length of the identifier beginning the string.\n@@ -395,7 +402,7 @@ func (g *Generator) exec(words []string) {\n \t\t\"GOFILE=\" + g.file,\n \t\t\"GOPACKAGE=\" + g.pkg,\n \t}\n-\tcmd.Env = mergeEnvLists(env, os.Environ())\n+\tcmd.Env = mergeEnvLists(env, origEnv)\n \terr := cmd.Run()\n \tif err != nil {\n \t\tg.errorf(\"running %q: %s\", words[0], err)"}, {"sha": "169d71ca812b7515e12a3c5909f21dce38b9cf02", "filename": "libgo/go/cmd/go/generate_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Fgenerate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Fgenerate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgenerate_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -26,6 +26,7 @@ var splitTests = []splitTest{\n \t{\"$GOPACKAGE\", []string{\"sys\"}},\n \t{\"a $XXNOTDEFINEDXX b\", []string{\"a\", \"\", \"b\"}},\n \t{\"/$XXNOTDEFINED/\", []string{\"//\"}},\n+\t{\"/$DOLLAR/\", []string{\"/$/\"}},\n \t{\"yacc -o $GOARCH/yacc_$GOFILE\", []string{\"go\", \"tool\", \"yacc\", \"-o\", runtime.GOARCH + \"/yacc_proc.go\"}},\n }\n "}, {"sha": "e95201a69307b040de55a24082c37701c20b6a40", "filename": "libgo/go/cmd/go/get.go", "status": "modified", "additions": 96, "deletions": 21, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Fget.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Fget.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fget.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -16,7 +16,7 @@ import (\n )\n \n var cmdGet = &Command{\n-\tUsageLine: \"get [-d] [-f] [-fix] [-t] [-u] [build flags] [packages]\",\n+\tUsageLine: \"get [-d] [-f] [-fix] [-insecure] [-t] [-u] [build flags] [packages]\",\n \tShort:     \"download and install packages and dependencies\",\n \tLong: `\n Get downloads and installs the packages named by the import paths,\n@@ -33,6 +33,9 @@ of the original.\n The -fix flag instructs get to run the fix tool on the downloaded packages\n before resolving dependencies or building the code.\n \n+The -insecure flag permits fetching from repositories and resolving\n+custom domains using insecure schemes such as HTTP. Use with caution.\n+\n The -t flag instructs get to also download the packages required to build\n the tests for the specified packages.\n \n@@ -48,6 +51,10 @@ rule is that if the local installation is running version \"go1\", get\n searches for a branch or tag named \"go1\". If no such version exists it\n retrieves the most recent version of the package.\n \n+If the vendoring experiment is enabled (see 'go help gopath'),\n+then when go get checks out or updates a Git repository,\n+it also updates any git submodules referenced by the repository.\n+\n For more about specifying packages, see 'go help packages'.\n \n For more about how 'go get' finds source code to\n@@ -62,6 +69,7 @@ var getF = cmdGet.Flag.Bool(\"f\", false, \"\")\n var getT = cmdGet.Flag.Bool(\"t\", false, \"\")\n var getU = cmdGet.Flag.Bool(\"u\", false, \"\")\n var getFix = cmdGet.Flag.Bool(\"fix\", false, \"\")\n+var getInsecure = cmdGet.Flag.Bool(\"insecure\", false, \"\")\n \n func init() {\n \taddBuildFlags(cmdGet)\n@@ -73,10 +81,20 @@ func runGet(cmd *Command, args []string) {\n \t\tfatalf(\"go get: cannot use -f flag without -u\")\n \t}\n \n+\t// Disable any prompting for passwords by Git.\n+\t// Only has an effect for 2.3.0 or later, but avoiding\n+\t// the prompt in earlier versions is just too hard.\n+\t// See golang.org/issue/9341.\n+\tos.Setenv(\"GIT_TERMINAL_PROMPT\", \"0\")\n+\n \t// Phase 1.  Download/update.\n \tvar stk importStack\n+\tmode := 0\n+\tif *getT {\n+\t\tmode |= getTestDeps\n+\t}\n \tfor _, arg := range downloadPaths(args) {\n-\t\tdownload(arg, &stk, *getT)\n+\t\tdownload(arg, nil, &stk, mode)\n \t}\n \texitIfErrors()\n \n@@ -92,12 +110,13 @@ func runGet(cmd *Command, args []string) {\n \t}\n \n \targs = importPaths(args)\n+\tpackagesForBuild(args)\n \n \t// Phase 3.  Install.\n \tif *getD {\n \t\t// Download only.\n \t\t// Check delayed until now so that importPaths\n-\t\t// has a chance to print errors.\n+\t\t// and packagesForBuild have a chance to print errors.\n \t\treturn\n \t}\n \n@@ -148,13 +167,30 @@ var downloadRootCache = map[string]bool{}\n \n // download runs the download half of the get command\n // for the package named by the argument.\n-func download(arg string, stk *importStack, getTestDeps bool) {\n-\tp := loadPackage(arg, stk)\n+func download(arg string, parent *Package, stk *importStack, mode int) {\n+\tload := func(path string, mode int) *Package {\n+\t\tif parent == nil {\n+\t\t\treturn loadPackage(path, stk)\n+\t\t}\n+\t\treturn loadImport(path, parent.Dir, parent, stk, nil, mode)\n+\t}\n+\n+\tp := load(arg, mode)\n \tif p.Error != nil && p.Error.hard {\n \t\terrorf(\"%s\", p.Error)\n \t\treturn\n \t}\n \n+\t// loadPackage inferred the canonical ImportPath from arg.\n+\t// Use that in the following to prevent hysteresis effects\n+\t// in e.g. downloadCache and packageCache.\n+\t// This allows invocations such as:\n+\t//   mkdir -p $GOPATH/src/github.com/user\n+\t//   cd $GOPATH/src/github.com/user\n+\t//   go get ./foo\n+\t// see: golang.org/issue/9767\n+\targ = p.ImportPath\n+\n \t// There's nothing to do if this is a package in the standard library.\n \tif p.Standard {\n \t\treturn\n@@ -163,7 +199,7 @@ func download(arg string, stk *importStack, getTestDeps bool) {\n \t// Only process each package once.\n \t// (Unless we're fetching test dependencies for this package,\n \t// in which case we want to process it again.)\n-\tif downloadCache[arg] && !getTestDeps {\n+\tif downloadCache[arg] && mode&getTestDeps == 0 {\n \t\treturn\n \t}\n \tdownloadCache[arg] = true\n@@ -175,14 +211,25 @@ func download(arg string, stk *importStack, getTestDeps bool) {\n \t// Download if the package is missing, or update if we're using -u.\n \tif p.Dir == \"\" || *getU {\n \t\t// The actual download.\n-\t\tstk.push(p.ImportPath)\n+\t\tstk.push(arg)\n \t\terr := downloadPackage(p)\n \t\tif err != nil {\n \t\t\terrorf(\"%s\", &PackageError{ImportStack: stk.copy(), Err: err.Error()})\n \t\t\tstk.pop()\n \t\t\treturn\n \t\t}\n \n+\t\t// Warn that code.google.com is shutting down.  We\n+\t\t// issue the warning here because this is where we\n+\t\t// have the import stack.\n+\t\tif strings.HasPrefix(p.ImportPath, \"code.google.com\") {\n+\t\t\tfmt.Fprintf(os.Stderr, \"warning: code.google.com is shutting down; import path %v will stop working\\n\", p.ImportPath)\n+\t\t\tif len(*stk) > 1 {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"warning: package %v\\n\", strings.Join(*stk, \"\\n\\timports \"))\n+\t\t\t}\n+\t\t}\n+\t\tstk.pop()\n+\n \t\targs := []string{arg}\n \t\t// If the argument has a wildcard in it, re-evaluate the wildcard.\n \t\t// We delay this until after reloadPackage so that the old entry\n@@ -208,9 +255,10 @@ func download(arg string, stk *importStack, getTestDeps bool) {\n \n \t\tpkgs = pkgs[:0]\n \t\tfor _, arg := range args {\n-\t\t\tstk.push(arg)\n-\t\t\tp := loadPackage(arg, stk)\n-\t\t\tstk.pop()\n+\t\t\t// Note: load calls loadPackage or loadImport,\n+\t\t\t// which push arg onto stk already.\n+\t\t\t// Do not push here too, or else stk will say arg imports arg.\n+\t\t\tp := load(arg, mode)\n \t\t\tif p.Error != nil {\n \t\t\t\terrorf(\"%s\", p.Error)\n \t\t\t\tcontinue\n@@ -223,7 +271,7 @@ func download(arg string, stk *importStack, getTestDeps bool) {\n \t// due to wildcard expansion.\n \tfor _, p := range pkgs {\n \t\tif *getFix {\n-\t\t\trun(stringList(tool(\"fix\"), relPaths(p.allgofiles)))\n+\t\t\trun(buildToolExec, stringList(tool(\"fix\"), relPaths(p.allgofiles)))\n \n \t\t\t// The imports might have changed, so reload again.\n \t\t\tp = reloadPackage(arg, stk)\n@@ -240,18 +288,31 @@ func download(arg string, stk *importStack, getTestDeps bool) {\n \t\t}\n \n \t\t// Process dependencies, now that we know what they are.\n-\t\tfor _, dep := range p.deps {\n+\t\tfor _, path := range p.Imports {\n+\t\t\tif path == \"C\" {\n+\t\t\t\tcontinue\n+\t\t\t}\n \t\t\t// Don't get test dependencies recursively.\n-\t\t\tdownload(dep.ImportPath, stk, false)\n+\t\t\t// Imports is already vendor-expanded.\n+\t\t\tdownload(path, p, stk, 0)\n \t\t}\n-\t\tif getTestDeps {\n+\t\tif mode&getTestDeps != 0 {\n \t\t\t// Process test dependencies when -t is specified.\n \t\t\t// (Don't get test dependencies for test dependencies.)\n+\t\t\t// We pass useVendor here because p.load does not\n+\t\t\t// vendor-expand TestImports and XTestImports.\n+\t\t\t// The call to loadImport inside download needs to do that.\n \t\t\tfor _, path := range p.TestImports {\n-\t\t\t\tdownload(path, stk, false)\n+\t\t\t\tif path == \"C\" {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tdownload(path, p, stk, useVendor)\n \t\t\t}\n \t\t\tfor _, path := range p.XTestImports {\n-\t\t\t\tdownload(path, stk, false)\n+\t\t\t\tif path == \"C\" {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tdownload(path, p, stk, useVendor)\n \t\t\t}\n \t\t}\n \n@@ -269,6 +330,12 @@ func downloadPackage(p *Package) error {\n \t\trepo, rootPath string\n \t\terr            error\n \t)\n+\n+\tsecurity := secure\n+\tif *getInsecure {\n+\t\tsecurity = insecure\n+\t}\n+\n \tif p.build.SrcRoot != \"\" {\n \t\t// Directory exists.  Look for checkout along path to src.\n \t\tvcs, rootPath, err = vcsForDir(p)\n@@ -278,18 +345,23 @@ func downloadPackage(p *Package) error {\n \t\trepo = \"<local>\" // should be unused; make distinctive\n \n \t\t// Double-check where it came from.\n-\t\tif *getU && vcs.remoteRepo != nil && !*getF {\n+\t\tif *getU && vcs.remoteRepo != nil {\n \t\t\tdir := filepath.Join(p.build.SrcRoot, rootPath)\n-\t\t\tif remote, err := vcs.remoteRepo(vcs, dir); err == nil {\n-\t\t\t\tif rr, err := repoRootForImportPath(p.ImportPath); err == nil {\n+\t\t\tremote, err := vcs.remoteRepo(vcs, dir)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\trepo = remote\n+\t\t\tif !*getF {\n+\t\t\t\tif rr, err := repoRootForImportPath(p.ImportPath, security); err == nil {\n \t\t\t\t\trepo := rr.repo\n \t\t\t\t\tif rr.vcs.resolveRepo != nil {\n \t\t\t\t\t\tresolved, err := rr.vcs.resolveRepo(rr.vcs, dir, repo)\n \t\t\t\t\t\tif err == nil {\n \t\t\t\t\t\t\trepo = resolved\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n-\t\t\t\t\tif remote != repo {\n+\t\t\t\t\tif remote != repo && p.ImportComment != \"\" {\n \t\t\t\t\t\treturn fmt.Errorf(\"%s is a custom import path for %s, but %s is checked out from %s\", rr.root, repo, dir, remote)\n \t\t\t\t\t}\n \t\t\t\t}\n@@ -298,12 +370,15 @@ func downloadPackage(p *Package) error {\n \t} else {\n \t\t// Analyze the import path to determine the version control system,\n \t\t// repository, and the import path for the root of the repository.\n-\t\trr, err := repoRootForImportPath(p.ImportPath)\n+\t\trr, err := repoRootForImportPath(p.ImportPath, security)\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n \t\tvcs, repo, rootPath = rr.vcs, rr.repo, rr.root\n \t}\n+\tif !vcs.isSecure(repo) && !*getInsecure {\n+\t\treturn fmt.Errorf(\"cannot download, %v uses insecure protocol\", repo)\n+\t}\n \n \tif p.build.SrcRoot == \"\" {\n \t\t// Package not found.  Put in first directory of $GOPATH."}, {"sha": "77b2628982bb81675d07d2705017aa1dd7c1efe4", "filename": "libgo/go/cmd/go/go_test.go", "status": "added", "additions": 2389, "deletions": 0, "changes": 2389, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -0,0 +1,2389 @@\n+// Copyright 2015 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main_test\n+\n+import (\n+\t\"bytes\"\n+\t\"flag\"\n+\t\"fmt\"\n+\t\"go/build\"\n+\t\"go/format\"\n+\t\"internal/testenv\"\n+\t\"io\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"path/filepath\"\n+\t\"regexp\"\n+\t\"runtime\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"testing\"\n+\t\"time\"\n+)\n+\n+var (\n+\tcanRun  = true  // whether we can run go or ./testgo\n+\tcanRace = false // whether we can run the race detector\n+\tcanCgo  = false // whether we can use cgo\n+\n+\texeSuffix string // \".exe\" on Windows\n+\n+\tbuilder             = testenv.Builder()\n+\tskipExternalBuilder = false // skip external tests on this builder\n+)\n+\n+func init() {\n+\tswitch runtime.GOOS {\n+\tcase \"android\", \"nacl\":\n+\t\tcanRun = false\n+\tcase \"darwin\":\n+\t\tswitch runtime.GOARCH {\n+\t\tcase \"arm\", \"arm64\":\n+\t\t\tcanRun = false\n+\t\t}\n+\t}\n+\n+\tif strings.HasPrefix(builder+\"-\", \"freebsd-arm-\") {\n+\t\tskipExternalBuilder = true\n+\t\tcanRun = false\n+\t}\n+\n+\tswitch runtime.GOOS {\n+\tcase \"windows\":\n+\t\texeSuffix = \".exe\"\n+\t}\n+}\n+\n+// The TestMain function creates a go command for testing purposes and\n+// deletes it after the tests have been run.\n+func TestMain(m *testing.M) {\n+\tflag.Parse()\n+\n+\tif canRun {\n+\t\tout, err := exec.Command(\"go\", \"build\", \"-tags\", \"testgo\", \"-o\", \"testgo\"+exeSuffix).CombinedOutput()\n+\t\tif err != nil {\n+\t\t\tfmt.Fprintf(os.Stderr, \"building testgo failed: %v\\n%s\", err, out)\n+\t\t\tos.Exit(2)\n+\t\t}\n+\n+\t\tif out, err := exec.Command(\"./testgo\"+exeSuffix, \"env\", \"CGO_ENABLED\").Output(); err != nil {\n+\t\t\tfmt.Fprintf(os.Stderr, \"running testgo failed: %v\\n\", err)\n+\t\t\tcanRun = false\n+\t\t} else {\n+\t\t\tcanCgo, err = strconv.ParseBool(strings.TrimSpace(string(out)))\n+\t\t\tif err != nil {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"can't parse go env CGO_ENABLED output: %v\\n\", strings.TrimSpace(string(out)))\n+\t\t\t}\n+\t\t}\n+\n+\t\tswitch runtime.GOOS {\n+\t\tcase \"linux\", \"darwin\", \"freebsd\", \"windows\":\n+\t\t\tcanRace = canCgo && runtime.GOARCH == \"amd64\"\n+\t\t}\n+\n+\t\tmeasureTick(\"./testgo\" + exeSuffix)\n+\t}\n+\n+\t// Don't let these environment variables confuse the test.\n+\tos.Unsetenv(\"GOBIN\")\n+\tos.Unsetenv(\"GOPATH\")\n+\n+\tr := m.Run()\n+\n+\tif canRun {\n+\t\tos.Remove(\"testgo\" + exeSuffix)\n+\t}\n+\n+\tos.Exit(r)\n+}\n+\n+// The length of an mtime tick on this system.  This is an estimate of\n+// how long we need to sleep to ensure that the mtime of two files is\n+// different.\n+var mtimeTick time.Duration\n+\n+// measureTick sets mtimeTick by looking at the rounding of the mtime\n+// of a file.\n+func measureTick(path string) {\n+\tst, err := os.Stat(path)\n+\tif err != nil {\n+\t\t// Default to one second, the most conservative value.\n+\t\tmtimeTick = time.Second\n+\t\treturn\n+\t}\n+\tmtime := st.ModTime()\n+\tt := time.Microsecond\n+\tfor mtime.Round(t).Equal(mtime) && t < time.Second {\n+\t\tt *= 10\n+\t}\n+\tmtimeTick = t\n+}\n+\n+// Manage a single run of the testgo binary.\n+type testgoData struct {\n+\tt              *testing.T\n+\ttemps          []string\n+\twd             string\n+\tenv            []string\n+\ttempdir        string\n+\tran            bool\n+\tinParallel     bool\n+\tstdout, stderr bytes.Buffer\n+}\n+\n+// testgo sets up for a test that runs testgo.\n+func testgo(t *testing.T) *testgoData {\n+\ttestenv.MustHaveGoBuild(t)\n+\n+\tif skipExternalBuilder {\n+\t\tt.Skip(\"skipping external tests on %s builder\", builder)\n+\t}\n+\n+\treturn &testgoData{t: t}\n+}\n+\n+// must gives a fatal error if err is not nil.\n+func (tg *testgoData) must(err error) {\n+\tif err != nil {\n+\t\ttg.t.Fatal(err)\n+\t}\n+}\n+\n+// check gives a test non-fatal error if err is not nil.\n+func (tg *testgoData) check(err error) {\n+\tif err != nil {\n+\t\ttg.t.Error(err)\n+\t}\n+}\n+\n+// parallel runs the test in parallel by calling t.Parallel.\n+func (tg *testgoData) parallel() {\n+\tif tg.ran {\n+\t\ttg.t.Fatal(\"internal testsuite error: call to parallel after run\")\n+\t}\n+\tif tg.wd != \"\" {\n+\t\ttg.t.Fatal(\"internal testsuite error: call to parallel after cd\")\n+\t}\n+\tfor _, e := range tg.env {\n+\t\tif strings.HasPrefix(e, \"GOROOT=\") || strings.HasPrefix(e, \"GOPATH=\") || strings.HasPrefix(e, \"GOBIN=\") {\n+\t\t\tval := e[strings.Index(e, \"=\")+1:]\n+\t\t\tif strings.HasPrefix(val, \"testdata\") || strings.HasPrefix(val, \"./testdata\") {\n+\t\t\t\ttg.t.Fatalf(\"internal testsuite error: call to parallel with testdata in environment (%s)\", e)\n+\t\t\t}\n+\t\t}\n+\t}\n+\ttg.inParallel = true\n+\ttg.t.Parallel()\n+}\n+\n+// pwd returns the current directory.\n+func (tg *testgoData) pwd() string {\n+\twd, err := os.Getwd()\n+\tif err != nil {\n+\t\ttg.t.Fatalf(\"could not get working directory: %v\", err)\n+\t}\n+\treturn wd\n+}\n+\n+// cd changes the current directory to the named directory.  Note that\n+// using this means that the test must not be run in parallel with any\n+// other tests.\n+func (tg *testgoData) cd(dir string) {\n+\tif tg.inParallel {\n+\t\ttg.t.Fatal(\"internal testsuite error: changing directory when running in parallel\")\n+\t}\n+\tif tg.wd == \"\" {\n+\t\ttg.wd = tg.pwd()\n+\t}\n+\tabs, err := filepath.Abs(dir)\n+\ttg.must(os.Chdir(dir))\n+\tif err == nil {\n+\t\ttg.setenv(\"PWD\", abs)\n+\t}\n+}\n+\n+// sleep sleeps for one tick, where a tick is a conservative estimate\n+// of how long it takes for a file modification to get a different\n+// mtime.\n+func (tg *testgoData) sleep() {\n+\ttime.Sleep(mtimeTick)\n+}\n+\n+// setenv sets an environment variable to use when running the test go\n+// command.\n+func (tg *testgoData) setenv(name, val string) {\n+\tif tg.inParallel && (name == \"GOROOT\" || name == \"GOPATH\" || name == \"GOBIN\") && (strings.HasPrefix(val, \"testdata\") || strings.HasPrefix(val, \"./testdata\")) {\n+\t\ttg.t.Fatalf(\"internal testsuite error: call to setenv with testdata (%s=%s) after parallel\", name, val)\n+\t}\n+\ttg.unsetenv(name)\n+\ttg.env = append(tg.env, name+\"=\"+val)\n+}\n+\n+// unsetenv removes an environment variable.\n+func (tg *testgoData) unsetenv(name string) {\n+\tif tg.env == nil {\n+\t\ttg.env = append([]string(nil), os.Environ()...)\n+\t}\n+\tfor i, v := range tg.env {\n+\t\tif strings.HasPrefix(v, name+\"=\") {\n+\t\t\ttg.env = append(tg.env[:i], tg.env[i+1:]...)\n+\t\t\tbreak\n+\t\t}\n+\t}\n+}\n+\n+// doRun runs the test go command, recording stdout and stderr and\n+// returning exit status.\n+func (tg *testgoData) doRun(args []string) error {\n+\tif !canRun {\n+\t\tpanic(\"testgoData.doRun called but canRun false\")\n+\t}\n+\tif tg.inParallel {\n+\t\tfor _, arg := range args {\n+\t\t\tif strings.HasPrefix(arg, \"testdata\") || strings.HasPrefix(arg, \"./testdata\") {\n+\t\t\t\ttg.t.Fatal(\"internal testsuite error: parallel run using testdata\")\n+\t\t\t}\n+\t\t}\n+\t}\n+\ttg.t.Logf(\"running testgo %v\", args)\n+\tvar prog string\n+\tif tg.wd == \"\" {\n+\t\tprog = \"./testgo\" + exeSuffix\n+\t} else {\n+\t\tprog = filepath.Join(tg.wd, \"testgo\"+exeSuffix)\n+\t}\n+\tcmd := exec.Command(prog, args...)\n+\ttg.stdout.Reset()\n+\ttg.stderr.Reset()\n+\tcmd.Stdout = &tg.stdout\n+\tcmd.Stderr = &tg.stderr\n+\tcmd.Env = tg.env\n+\tstatus := cmd.Run()\n+\tif tg.stdout.Len() > 0 {\n+\t\ttg.t.Log(\"standard output:\")\n+\t\ttg.t.Log(tg.stdout.String())\n+\t}\n+\tif tg.stderr.Len() > 0 {\n+\t\ttg.t.Log(\"standard error:\")\n+\t\ttg.t.Log(tg.stderr.String())\n+\t}\n+\ttg.ran = true\n+\treturn status\n+}\n+\n+// run runs the test go command, and expects it to succeed.\n+func (tg *testgoData) run(args ...string) {\n+\tif status := tg.doRun(args); status != nil {\n+\t\ttg.t.Logf(\"go %v failed unexpectedly: %v\", args, status)\n+\t\ttg.t.FailNow()\n+\t}\n+}\n+\n+// runFail runs the test go command, and expects it to fail.\n+func (tg *testgoData) runFail(args ...string) {\n+\tif status := tg.doRun(args); status == nil {\n+\t\ttg.t.Fatal(\"testgo succeeded unexpectedly\")\n+\t} else {\n+\t\ttg.t.Log(\"testgo failed as expected:\", status)\n+\t}\n+}\n+\n+// runGit runs a git command, and expects it to succeed.\n+func (tg *testgoData) runGit(dir string, args ...string) {\n+\tcmd := exec.Command(\"git\", args...)\n+\ttg.stdout.Reset()\n+\ttg.stderr.Reset()\n+\tcmd.Stdout = &tg.stdout\n+\tcmd.Stderr = &tg.stderr\n+\tcmd.Dir = dir\n+\tcmd.Env = tg.env\n+\tstatus := cmd.Run()\n+\tif tg.stdout.Len() > 0 {\n+\t\ttg.t.Log(\"git standard output:\")\n+\t\ttg.t.Log(tg.stdout.String())\n+\t}\n+\tif tg.stderr.Len() > 0 {\n+\t\ttg.t.Log(\"git standard error:\")\n+\t\ttg.t.Log(tg.stderr.String())\n+\t}\n+\tif status != nil {\n+\t\ttg.t.Logf(\"git %v failed unexpectedly: %v\", args, status)\n+\t\ttg.t.FailNow()\n+\t}\n+}\n+\n+// getStdout returns standard output of the testgo run as a string.\n+func (tg *testgoData) getStdout() string {\n+\tif !tg.ran {\n+\t\ttg.t.Fatal(\"internal testsuite error: stdout called before run\")\n+\t}\n+\treturn tg.stdout.String()\n+}\n+\n+// getStderr returns standard error of the testgo run as a string.\n+func (tg *testgoData) getStderr() string {\n+\tif !tg.ran {\n+\t\ttg.t.Fatal(\"internal testsuite error: stdout called before run\")\n+\t}\n+\treturn tg.stderr.String()\n+}\n+\n+// doGrepMatch looks for a regular expression in a buffer, and returns\n+// whether it is found.  The regular expression is matched against\n+// each line separately, as with the grep command.\n+func (tg *testgoData) doGrepMatch(match string, b *bytes.Buffer) bool {\n+\tif !tg.ran {\n+\t\ttg.t.Fatal(\"internal testsuite error: grep called before run\")\n+\t}\n+\tre := regexp.MustCompile(match)\n+\tfor _, ln := range bytes.Split(b.Bytes(), []byte{'\\n'}) {\n+\t\tif re.Match(ln) {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+// doGrep looks for a regular expression in a buffer and fails if it\n+// is not found.  The name argument is the name of the output we are\n+// searching, \"output\" or \"error\".  The msg argument is logged on\n+// failure.\n+func (tg *testgoData) doGrep(match string, b *bytes.Buffer, name, msg string) {\n+\tif !tg.doGrepMatch(match, b) {\n+\t\ttg.t.Log(msg)\n+\t\ttg.t.Logf(\"pattern %v not found in standard %s\", match, name)\n+\t\ttg.t.FailNow()\n+\t}\n+}\n+\n+// grepStdout looks for a regular expression in the test run's\n+// standard output and fails, logging msg, if it is not found.\n+func (tg *testgoData) grepStdout(match, msg string) {\n+\ttg.doGrep(match, &tg.stdout, \"output\", msg)\n+}\n+\n+// grepStderr looks for a regular expression in the test run's\n+// standard error and fails, logging msg, if it is not found.\n+func (tg *testgoData) grepStderr(match, msg string) {\n+\ttg.doGrep(match, &tg.stderr, \"error\", msg)\n+}\n+\n+// grepBoth looks for a regular expression in the test run's standard\n+// output or stand error and fails, logging msg, if it is not found.\n+func (tg *testgoData) grepBoth(match, msg string) {\n+\tif !tg.doGrepMatch(match, &tg.stdout) && !tg.doGrepMatch(match, &tg.stderr) {\n+\t\ttg.t.Log(msg)\n+\t\ttg.t.Logf(\"pattern %v not found in standard output or standard error\", match)\n+\t\ttg.t.FailNow()\n+\t}\n+}\n+\n+// doGrepNot looks for a regular expression in a buffer and fails if\n+// it is found.  The name and msg arguments are as for doGrep.\n+func (tg *testgoData) doGrepNot(match string, b *bytes.Buffer, name, msg string) {\n+\tif tg.doGrepMatch(match, b) {\n+\t\ttg.t.Log(msg)\n+\t\ttg.t.Logf(\"pattern %v found unexpectedly in standard %s\", match, name)\n+\t\ttg.t.FailNow()\n+\t}\n+}\n+\n+// grepStdoutNot looks for a regular expression in the test run's\n+// standard output and fails, logging msg, if it is found.\n+func (tg *testgoData) grepStdoutNot(match, msg string) {\n+\ttg.doGrepNot(match, &tg.stdout, \"output\", msg)\n+}\n+\n+// grepStderrNot looks for a regular expression in the test run's\n+// standard error and fails, logging msg, if it is found.\n+func (tg *testgoData) grepStderrNot(match, msg string) {\n+\ttg.doGrepNot(match, &tg.stderr, \"error\", msg)\n+}\n+\n+// grepBothNot looks for a regular expression in the test run's\n+// standard output or stand error and fails, logging msg, if it is\n+// found.\n+func (tg *testgoData) grepBothNot(match, msg string) {\n+\tif tg.doGrepMatch(match, &tg.stdout) || tg.doGrepMatch(match, &tg.stderr) {\n+\t\ttg.t.Log(msg)\n+\t\ttg.t.Fatalf(\"pattern %v found unexpectedly in standard output or standard error\", match)\n+\t}\n+}\n+\n+// doGrepCount counts the number of times a regexp is seen in a buffer.\n+func (tg *testgoData) doGrepCount(match string, b *bytes.Buffer) int {\n+\tif !tg.ran {\n+\t\ttg.t.Fatal(\"internal testsuite error: doGrepCount called before run\")\n+\t}\n+\tre := regexp.MustCompile(match)\n+\tc := 0\n+\tfor _, ln := range bytes.Split(b.Bytes(), []byte{'\\n'}) {\n+\t\tif re.Match(ln) {\n+\t\t\tc++\n+\t\t}\n+\t}\n+\treturn c\n+}\n+\n+// grepCountStdout returns the number of times a regexp is seen in\n+// standard output.\n+func (tg *testgoData) grepCountStdout(match string) int {\n+\treturn tg.doGrepCount(match, &tg.stdout)\n+}\n+\n+// grepCountStderr returns the number of times a regexp is seen in\n+// standard error.\n+func (tg *testgoData) grepCountStderr(match string) int {\n+\treturn tg.doGrepCount(match, &tg.stderr)\n+}\n+\n+// grepCountBoth returns the number of times a regexp is seen in both\n+// standard output and standard error.\n+func (tg *testgoData) grepCountBoth(match string) int {\n+\treturn tg.doGrepCount(match, &tg.stdout) + tg.doGrepCount(match, &tg.stderr)\n+}\n+\n+// creatingTemp records that the test plans to create a temporary file\n+// or directory.  If the file or directory exists already, it will be\n+// removed.  When the test completes, the file or directory will be\n+// removed if it exists.\n+func (tg *testgoData) creatingTemp(path string) {\n+\tif filepath.IsAbs(path) && !strings.HasPrefix(path, tg.tempdir) {\n+\t\ttg.t.Fatal(\"internal testsuite error: creatingTemp(%q) with absolute path not in temporary directory\", path)\n+\t}\n+\t// If we have changed the working directory, make sure we have\n+\t// an absolute path, because we are going to change directory\n+\t// back before we remove the temporary.\n+\tif tg.wd != \"\" && !filepath.IsAbs(path) {\n+\t\tpath = filepath.Join(tg.pwd(), path)\n+\t}\n+\ttg.must(os.RemoveAll(path))\n+\ttg.temps = append(tg.temps, path)\n+}\n+\n+// makeTempdir makes a temporary directory for a run of testgo.  If\n+// the temporary directory was already created, this does nothing.\n+func (tg *testgoData) makeTempdir() {\n+\tif tg.tempdir == \"\" {\n+\t\tvar err error\n+\t\ttg.tempdir, err = ioutil.TempDir(\"\", \"gotest\")\n+\t\ttg.must(err)\n+\t}\n+}\n+\n+// tempFile adds a temporary file for a run of testgo.\n+func (tg *testgoData) tempFile(path, contents string) {\n+\ttg.makeTempdir()\n+\ttg.must(os.MkdirAll(filepath.Join(tg.tempdir, filepath.Dir(path)), 0755))\n+\tbytes := []byte(contents)\n+\tif strings.HasSuffix(path, \".go\") {\n+\t\tformatted, err := format.Source(bytes)\n+\t\tif err == nil {\n+\t\t\tbytes = formatted\n+\t\t}\n+\t}\n+\ttg.must(ioutil.WriteFile(filepath.Join(tg.tempdir, path), bytes, 0644))\n+}\n+\n+// tempDir adds a temporary directory for a run of testgo.\n+func (tg *testgoData) tempDir(path string) {\n+\ttg.makeTempdir()\n+\tif err := os.MkdirAll(filepath.Join(tg.tempdir, path), 0755); err != nil && !os.IsExist(err) {\n+\t\ttg.t.Fatal(err)\n+\t}\n+}\n+\n+// path returns the absolute pathname to file with the temporary\n+// directory.\n+func (tg *testgoData) path(name string) string {\n+\tif tg.tempdir == \"\" {\n+\t\ttg.t.Fatalf(\"internal testsuite error: path(%q) with no tempdir\", name)\n+\t}\n+\tif name == \".\" {\n+\t\treturn tg.tempdir\n+\t}\n+\treturn filepath.Join(tg.tempdir, name)\n+}\n+\n+// mustNotExist fails if path exists.\n+func (tg *testgoData) mustNotExist(path string) {\n+\tif _, err := os.Stat(path); err == nil || !os.IsNotExist(err) {\n+\t\ttg.t.Fatalf(\"%s exists but should not (%v)\", path, err)\n+\t}\n+}\n+\n+// wantExecutable fails with msg if path is not executable.\n+func (tg *testgoData) wantExecutable(path, msg string) {\n+\tif st, err := os.Stat(path); err != nil {\n+\t\tif !os.IsNotExist(err) {\n+\t\t\ttg.t.Log(err)\n+\t\t}\n+\t\ttg.t.Fatal(msg)\n+\t} else {\n+\t\tif runtime.GOOS != \"windows\" && st.Mode()&0111 == 0 {\n+\t\t\ttg.t.Fatalf(\"binary %s exists but is not executable\", path)\n+\t\t}\n+\t}\n+}\n+\n+// wantArchive fails if path is not an archive.\n+func (tg *testgoData) wantArchive(path string) {\n+\tf, err := os.Open(path)\n+\tif err != nil {\n+\t\ttg.t.Fatal(err)\n+\t}\n+\tbuf := make([]byte, 100)\n+\tio.ReadFull(f, buf)\n+\tf.Close()\n+\tif !bytes.HasPrefix(buf, []byte(\"!<arch>\\n\")) {\n+\t\ttg.t.Fatalf(\"file %s exists but is not an archive\", path)\n+\t}\n+}\n+\n+// isStale returns whether pkg is stale.\n+func (tg *testgoData) isStale(pkg string) bool {\n+\ttg.run(\"list\", \"-f\", \"{{.Stale}}\", pkg)\n+\tswitch v := strings.TrimSpace(tg.getStdout()); v {\n+\tcase \"true\":\n+\t\treturn true\n+\tcase \"false\":\n+\t\treturn false\n+\tdefault:\n+\t\ttg.t.Fatalf(\"unexpected output checking staleness of package %v: %v\", pkg, v)\n+\t\tpanic(\"unreachable\")\n+\t}\n+}\n+\n+// wantStale fails with msg if pkg is not stale.\n+func (tg *testgoData) wantStale(pkg, msg string) {\n+\tif !tg.isStale(pkg) {\n+\t\ttg.t.Fatal(msg)\n+\t}\n+}\n+\n+// wantNotStale fails with msg if pkg is stale.\n+func (tg *testgoData) wantNotStale(pkg, msg string) {\n+\tif tg.isStale(pkg) {\n+\t\ttg.t.Fatal(msg)\n+\t}\n+}\n+\n+// cleanup cleans up a test that runs testgo.\n+func (tg *testgoData) cleanup() {\n+\tif tg.wd != \"\" {\n+\t\tif err := os.Chdir(tg.wd); err != nil {\n+\t\t\t// We are unlikely to be able to continue.\n+\t\t\tfmt.Fprintln(os.Stderr, \"could not restore working directory, crashing:\", err)\n+\t\t\tos.Exit(2)\n+\t\t}\n+\t}\n+\tfor _, path := range tg.temps {\n+\t\ttg.check(os.RemoveAll(path))\n+\t}\n+\tif tg.tempdir != \"\" {\n+\t\ttg.check(os.RemoveAll(tg.tempdir))\n+\t}\n+}\n+\n+// resetReadOnlyFlagAll resets windows read-only flag\n+// set on path and any children it contains.\n+// The flag is set by git and has to be removed.\n+// os.Remove refuses to remove files with read-only flag set.\n+func (tg *testgoData) resetReadOnlyFlagAll(path string) {\n+\tfi, err := os.Stat(path)\n+\tif err != nil {\n+\t\ttg.t.Fatalf(\"resetReadOnlyFlagAll(%q) failed: %v\", path, err)\n+\t}\n+\tif !fi.IsDir() {\n+\t\terr := os.Chmod(path, 0666)\n+\t\tif err != nil {\n+\t\t\ttg.t.Fatalf(\"resetReadOnlyFlagAll(%q) failed: %v\", path, err)\n+\t\t}\n+\t}\n+\tfd, err := os.Open(path)\n+\tif err != nil {\n+\t\ttg.t.Fatalf(\"resetReadOnlyFlagAll(%q) failed: %v\", path, err)\n+\t}\n+\tdefer fd.Close()\n+\tnames, _ := fd.Readdirnames(-1)\n+\tfor _, name := range names {\n+\t\ttg.resetReadOnlyFlagAll(path + string(filepath.Separator) + name)\n+\t}\n+}\n+\n+// failSSH puts an ssh executable in the PATH that always fails.\n+// This is to stub out uses of ssh by go get.\n+func (tg *testgoData) failSSH() {\n+\twd, err := os.Getwd()\n+\tif err != nil {\n+\t\ttg.t.Fatal(err)\n+\t}\n+\tfail := filepath.Join(wd, \"testdata/failssh\")\n+\ttg.setenv(\"PATH\", fmt.Sprintf(\"%v%c%v\", fail, filepath.ListSeparator, os.Getenv(\"PATH\")))\n+}\n+\n+func TestFileLineInErrorMessages(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.tempFile(\"err.go\", `package main; import \"bar\"`)\n+\tpath := tg.path(\"err.go\")\n+\ttg.runFail(\"run\", path)\n+\tshortPath := path\n+\tif rel, err := filepath.Rel(tg.pwd(), path); err == nil && len(rel) < len(path) {\n+\t\tshortPath = rel\n+\t}\n+\ttg.grepStderr(\"^\"+regexp.QuoteMeta(shortPath)+\":\", \"missing file:line in error message\")\n+}\n+\n+func TestProgramNameInCrashMessages(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.tempFile(\"triv.go\", `package main; func main() {}`)\n+\ttg.runFail(\"build\", \"-ldflags\", \"-crash_for_testing\", tg.path(\"triv.go\"))\n+\ttg.grepStderr(`[/\\\\]tool[/\\\\].*[/\\\\]link`, \"missing linker name in error message\")\n+}\n+\n+func TestBrokenTestsWithoutTestFunctionsAllFail(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.runFail(\"test\", \"./testdata/src/badtest/...\")\n+\ttg.grepBothNot(\"^ok\", \"test passed unexpectedly\")\n+\ttg.grepBoth(\"FAIL.*badtest/badexec\", \"test did not run everything\")\n+\ttg.grepBoth(\"FAIL.*badtest/badsyntax\", \"test did not run everything\")\n+\ttg.grepBoth(\"FAIL.*badtest/badvar\", \"test did not run everything\")\n+}\n+\n+func TestGoBuildDashAInDevBranch(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"don't rebuild the standard library in short mode\")\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.run(\"install\", \"math\") // should be up to date already but just in case\n+\ttg.setenv(\"TESTGO_IS_GO_RELEASE\", \"0\")\n+\ttg.run(\"build\", \"-v\", \"-a\", \"math\")\n+\ttg.grepStderr(\"runtime\", \"testgo build -a math in dev branch DID NOT build runtime, but should have\")\n+}\n+\n+func TestGoBuilDashAInReleaseBranch(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"don't rebuild the standard library in short mode\")\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.run(\"install\", \"math\") // should be up to date already but just in case\n+\ttg.setenv(\"TESTGO_IS_GO_RELEASE\", \"1\")\n+\ttg.run(\"build\", \"-v\", \"-a\", \"math\")\n+\ttg.grepStderr(\"runtime\", \"testgo build -a math in dev branch did not build runtime, but should have\")\n+}\n+\n+func TestGoInstallCleansUpAfterGoBuild(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.tempFile(\"src/mycmd/main.go\", `package main; func main(){}`)\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.cd(tg.path(\"src/mycmd\"))\n+\n+\tdoesNotExist := func(file, msg string) {\n+\t\tif _, err := os.Stat(file); err == nil {\n+\t\t\tt.Fatal(msg)\n+\t\t} else if !os.IsNotExist(err) {\n+\t\t\tt.Fatal(msg, \"error:\", err)\n+\t\t}\n+\t}\n+\n+\ttg.run(\"build\")\n+\ttg.wantExecutable(\"mycmd\"+exeSuffix, \"testgo build did not write command binary\")\n+\ttg.run(\"install\")\n+\tdoesNotExist(\"mycmd\"+exeSuffix, \"testgo install did not remove command binary\")\n+\ttg.run(\"build\")\n+\ttg.wantExecutable(\"mycmd\"+exeSuffix, \"testgo build did not write command binary (second time)\")\n+\t// Running install with arguments does not remove the target,\n+\t// even in the same directory.\n+\ttg.run(\"install\", \"mycmd\")\n+\ttg.wantExecutable(\"mycmd\"+exeSuffix, \"testgo install mycmd removed command binary when run in mycmd\")\n+\ttg.run(\"build\")\n+\ttg.wantExecutable(\"mycmd\"+exeSuffix, \"testgo build did not write command binary (third time)\")\n+\t// And especially not outside the directory.\n+\ttg.cd(tg.path(\".\"))\n+\tif data, err := ioutil.ReadFile(\"src/mycmd/mycmd\" + exeSuffix); err != nil {\n+\t\tt.Fatal(\"could not read file:\", err)\n+\t} else {\n+\t\tif err := ioutil.WriteFile(\"mycmd\"+exeSuffix, data, 0555); err != nil {\n+\t\t\tt.Fatal(\"could not write file:\", err)\n+\t\t}\n+\t}\n+\ttg.run(\"install\", \"mycmd\")\n+\ttg.wantExecutable(\"src/mycmd/mycmd\"+exeSuffix, \"testgo install mycmd removed command binary from its source dir when run outside mycmd\")\n+\ttg.wantExecutable(\"mycmd\"+exeSuffix, \"testgo install mycmd removed command binary from current dir when run outside mycmd\")\n+}\n+\n+func TestGoInstallRebuildsStalePackagesInOtherGOPATH(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.tempFile(\"d1/src/p1/p1.go\", `package p1\n+\t\timport \"p2\"\n+\t\tfunc F() { p2.F() }`)\n+\ttg.tempFile(\"d2/src/p2/p2.go\", `package p2\n+\t\tfunc F() {}`)\n+\tsep := string(filepath.ListSeparator)\n+\ttg.setenv(\"GOPATH\", tg.path(\"d1\")+sep+tg.path(\"d2\"))\n+\ttg.run(\"install\", \"p1\")\n+\ttg.wantNotStale(\"p1\", \"./testgo list mypkg claims p1 is stale, incorrectly\")\n+\ttg.wantNotStale(\"p2\", \"./testgo list mypkg claims p2 is stale, incorrectly\")\n+\ttg.sleep()\n+\tif f, err := os.OpenFile(tg.path(\"d2/src/p2/p2.go\"), os.O_WRONLY|os.O_APPEND, 0); err != nil {\n+\t\tt.Fatal(err)\n+\t} else if _, err = f.WriteString(`func G() {}`); err != nil {\n+\t\tt.Fatal(err)\n+\t} else {\n+\t\ttg.must(f.Close())\n+\t}\n+\ttg.wantStale(\"p2\", \"./testgo list mypkg claims p2 is NOT stale, incorrectly\")\n+\ttg.wantStale(\"p1\", \"./testgo list mypkg claims p1 is NOT stale, incorrectly\")\n+\n+\ttg.run(\"install\", \"p1\")\n+\ttg.wantNotStale(\"p2\", \"./testgo list mypkg claims p2 is stale after reinstall, incorrectly\")\n+\ttg.wantNotStale(\"p1\", \"./testgo list mypkg claims p1 is stale after reinstall, incorrectly\")\n+}\n+\n+func TestGoInstallDetectsRemovedFiles(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.tempFile(\"src/mypkg/x.go\", `package mypkg`)\n+\ttg.tempFile(\"src/mypkg/y.go\", `package mypkg`)\n+\ttg.tempFile(\"src/mypkg/z.go\", `// +build missingtag\n+\n+\t\tpackage mypkg`)\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.run(\"install\", \"mypkg\")\n+\ttg.wantNotStale(\"mypkg\", \"./testgo list mypkg claims mypkg is stale, incorrectly\")\n+\t// z.go was not part of the build; removing it is okay.\n+\ttg.must(os.Remove(tg.path(\"src/mypkg/z.go\")))\n+\ttg.wantNotStale(\"mypkg\", \"./testgo list mypkg claims mypkg is stale after removing z.go; should not be stale\")\n+\t// y.go was part of the package; removing it should be detected.\n+\ttg.must(os.Remove(tg.path(\"src/mypkg/y.go\")))\n+\ttg.wantStale(\"mypkg\", \"./testgo list mypkg claims mypkg is NOT stale after removing y.go; should be stale\")\n+}\n+\n+func TestGoInstallErrorOnCrossCompileToBin(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"don't install into GOROOT in short mode\")\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.tempFile(\"src/mycmd/x.go\", `package main\n+\t\tfunc main() {}`)\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.cd(tg.path(\"src/mycmd\"))\n+\n+\ttg.run(\"build\", \"mycmd\")\n+\n+\tgoarch := \"386\"\n+\tif runtime.GOARCH == \"386\" {\n+\t\tgoarch = \"amd64\"\n+\t}\n+\ttg.setenv(\"GOOS\", \"linux\")\n+\ttg.setenv(\"GOARCH\", goarch)\n+\ttg.run(\"install\", \"mycmd\")\n+\ttg.setenv(\"GOBIN\", tg.path(\".\"))\n+\ttg.runFail(\"install\", \"mycmd\")\n+\ttg.run(\"install\", \"cmd/pack\")\n+}\n+\n+func TestGoInstallDetectsRemovedFilesInPackageMain(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.tempFile(\"src/mycmd/x.go\", `package main\n+\t\tfunc main() {}`)\n+\ttg.tempFile(\"src/mycmd/y.go\", `package main`)\n+\ttg.tempFile(\"src/mycmd/z.go\", `// +build missingtag\n+\n+\t\tpackage main`)\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.run(\"install\", \"mycmd\")\n+\ttg.wantNotStale(\"mycmd\", \"./testgo list mypkg claims mycmd is stale, incorrectly\")\n+\t// z.go was not part of the build; removing it is okay.\n+\ttg.must(os.Remove(tg.path(\"src/mycmd/z.go\")))\n+\ttg.wantNotStale(\"mycmd\", \"./testgo list mycmd claims mycmd is stale after removing z.go; should not be stale\")\n+\t// y.go was part of the package; removing it should be detected.\n+\ttg.must(os.Remove(tg.path(\"src/mycmd/y.go\")))\n+\ttg.wantStale(\"mycmd\", \"./testgo list mycmd claims mycmd is NOT stale after removing y.go; should be stale\")\n+}\n+\n+func testLocalRun(tg *testgoData, exepath, local, match string) {\n+\tout, err := exec.Command(exepath).Output()\n+\tif err != nil {\n+\t\ttg.t.Fatalf(\"error running %v: %v\", exepath, err)\n+\t}\n+\tif !regexp.MustCompile(match).Match(out) {\n+\t\ttg.t.Log(string(out))\n+\t\ttg.t.Errorf(\"testdata/%s/easy.go did not generate expected output\", local)\n+\t}\n+}\n+\n+func testLocalEasy(tg *testgoData, local string) {\n+\texepath := \"./easy\" + exeSuffix\n+\ttg.creatingTemp(exepath)\n+\ttg.run(\"build\", \"-o\", exepath, filepath.Join(\"testdata\", local, \"easy.go\"))\n+\ttestLocalRun(tg, exepath, local, `(?m)^easysub\\.Hello`)\n+}\n+\n+func testLocalEasySub(tg *testgoData, local string) {\n+\texepath := \"./easysub\" + exeSuffix\n+\ttg.creatingTemp(exepath)\n+\ttg.run(\"build\", \"-o\", exepath, filepath.Join(\"testdata\", local, \"easysub\", \"main.go\"))\n+\ttestLocalRun(tg, exepath, local, `(?m)^easysub\\.Hello`)\n+}\n+\n+func testLocalHard(tg *testgoData, local string) {\n+\texepath := \"./hard\" + exeSuffix\n+\ttg.creatingTemp(exepath)\n+\ttg.run(\"build\", \"-o\", exepath, filepath.Join(\"testdata\", local, \"hard.go\"))\n+\ttestLocalRun(tg, exepath, local, `(?m)^sub\\.Hello`)\n+}\n+\n+func testLocalInstall(tg *testgoData, local string) {\n+\ttg.runFail(\"install\", filepath.Join(\"testdata\", local, \"easy.go\"))\n+}\n+\n+func TestLocalImportsEasy(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttestLocalEasy(tg, \"local\")\n+}\n+\n+func TestLocalImportsEasySub(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttestLocalEasySub(tg, \"local\")\n+}\n+\n+func TestLocalImportsHard(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttestLocalHard(tg, \"local\")\n+}\n+\n+func TestLocalImportsGoInstallShouldFail(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttestLocalInstall(tg, \"local\")\n+}\n+\n+const badDirName = `#$%:, &()*;<=>?\\^{}`\n+\n+func copyBad(tg *testgoData) {\n+\tif runtime.GOOS == \"windows\" {\n+\t\ttg.t.Skipf(\"skipping test because %q is an invalid directory name\", badDirName)\n+\t}\n+\n+\ttg.must(filepath.Walk(\"testdata/local\",\n+\t\tfunc(path string, info os.FileInfo, err error) error {\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tif info.IsDir() {\n+\t\t\t\treturn nil\n+\t\t\t}\n+\t\t\tvar data []byte\n+\t\t\tdata, err = ioutil.ReadFile(path)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tnewpath := strings.Replace(path, \"local\", badDirName, 1)\n+\t\t\ttg.tempFile(newpath, string(data))\n+\t\t\treturn nil\n+\t\t}))\n+\ttg.cd(tg.path(\".\"))\n+}\n+\n+func TestBadImportsEasy(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\tcopyBad(tg)\n+\ttestLocalEasy(tg, badDirName)\n+}\n+\n+func TestBadImportsEasySub(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\tcopyBad(tg)\n+\ttestLocalEasySub(tg, badDirName)\n+}\n+\n+func TestBadImportsHard(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\tcopyBad(tg)\n+\ttestLocalHard(tg, badDirName)\n+}\n+\n+func TestBadImportsGoInstallShouldFail(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\tcopyBad(tg)\n+\ttestLocalInstall(tg, badDirName)\n+}\n+\n+func TestInternalPackagesInGOROOTAreRespected(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.runFail(\"build\", \"-v\", \"./testdata/testinternal\")\n+\ttg.grepBoth(\"use of internal package not allowed\", \"wrong error message for testdata/testinternal\")\n+}\n+\n+func TestInternalPackagesOutsideGOROOTAreRespected(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.runFail(\"build\", \"-v\", \"./testdata/testinternal2\")\n+\ttg.grepBoth(\"use of internal package not allowed\", \"wrote error message for testdata/testinternal2\")\n+}\n+\n+func testMove(t *testing.T, vcs, url, base, config string) {\n+\ttestenv.MustHaveExternalNetwork(t)\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.tempDir(\"src\")\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.run(\"get\", \"-d\", url)\n+\ttg.run(\"get\", \"-d\", \"-u\", url)\n+\tswitch vcs {\n+\tcase \"svn\":\n+\t\t// SVN doesn't believe in text files so we can't just edit the config.\n+\t\t// Check out a different repo into the wrong place.\n+\t\ttg.must(os.RemoveAll(tg.path(\"src/code.google.com/p/rsc-svn\")))\n+\t\ttg.run(\"get\", \"-d\", \"-u\", \"code.google.com/p/rsc-svn2/trunk\")\n+\t\ttg.must(os.Rename(tg.path(\"src/code.google.com/p/rsc-svn2\"), tg.path(\"src/code.google.com/p/rsc-svn\")))\n+\tdefault:\n+\t\tpath := tg.path(filepath.Join(\"src\", config))\n+\t\tdata, err := ioutil.ReadFile(path)\n+\t\ttg.must(err)\n+\t\tdata = bytes.Replace(data, []byte(base), []byte(base+\"XXX\"), -1)\n+\t\ttg.must(ioutil.WriteFile(path, data, 0644))\n+\t}\n+\tif vcs == \"git\" {\n+\t\t// git will ask for a username and password when we\n+\t\t// run go get -d -f -u.  An empty username and\n+\t\t// password will work.  Prevent asking by setting\n+\t\t// GIT_ASKPASS.\n+\t\ttg.creatingTemp(\"sink\" + exeSuffix)\n+\t\ttg.tempFile(\"src/sink/sink.go\", `package main; func main() {}`)\n+\t\ttg.run(\"build\", \"-o\", \"sink\"+exeSuffix, \"sink\")\n+\t\ttg.setenv(\"GIT_ASKPASS\", filepath.Join(tg.pwd(), \"sink\"+exeSuffix))\n+\t}\n+\ttg.runFail(\"get\", \"-d\", \"-u\", url)\n+\ttg.grepStderr(\"is a custom import path for\", \"go get -d -u \"+url+\" failed for wrong reason\")\n+\ttg.runFail(\"get\", \"-d\", \"-f\", \"-u\", url)\n+\ttg.grepStderr(\"validating server certificate|not found\", \"go get -d -f -u \"+url+\" failed for wrong reason\")\n+}\n+\n+func TestInternalPackageErrorsAreHandled(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.run(\"list\", \"./testdata/testinternal3\")\n+}\n+\n+func TestInternalCache(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata/testinternal4\"))\n+\ttg.runFail(\"build\", \"p\")\n+\ttg.grepStderr(\"internal\", \"did not fail to build p\")\n+}\n+\n+func TestMoveGit(t *testing.T) {\n+\ttestMove(t, \"git\", \"rsc.io/pdf\", \"pdf\", \"rsc.io/pdf/.git/config\")\n+}\n+\n+// TODO(rsc): Set up a test case on bitbucket for hg.\n+// func TestMoveHG(t *testing.T) {\n+// \ttestMove(t, \"hg\", \"rsc.io/x86/x86asm\", \"x86\", \"rsc.io/x86/.hg/hgrc\")\n+// }\n+\n+// TODO(rsc): Set up a test case on SourceForge (?) for svn.\n+// func testMoveSVN(t *testing.T) {\n+//\ttestMove(t, \"svn\", \"code.google.com/p/rsc-svn/trunk\", \"-\", \"-\")\n+// }\n+\n+func TestImportCommandMatch(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata/importcom\"))\n+\ttg.run(\"build\", \"./testdata/importcom/works.go\")\n+}\n+\n+func TestImportCommentMismatch(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata/importcom\"))\n+\ttg.runFail(\"build\", \"./testdata/importcom/wrongplace.go\")\n+\ttg.grepStderr(`wrongplace expects import \"my/x\"`, \"go build did not mention incorrect import\")\n+}\n+\n+func TestImportCommentSyntaxError(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata/importcom\"))\n+\ttg.runFail(\"build\", \"./testdata/importcom/bad.go\")\n+\ttg.grepStderr(\"cannot parse import comment\", \"go build did not mention syntax error\")\n+}\n+\n+func TestImportCommentConflict(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata/importcom\"))\n+\ttg.runFail(\"build\", \"./testdata/importcom/conflict.go\")\n+\ttg.grepStderr(\"found import comments\", \"go build did not mention comment conflict\")\n+}\n+\n+// cmd/go: custom import path checking should not apply to github.com/xxx/yyy.\n+func TestIssue10952(t *testing.T) {\n+\ttestenv.MustHaveExternalNetwork(t)\n+\n+\tif _, err := exec.LookPath(\"git\"); err != nil {\n+\t\tt.Skip(\"skipping because git binary not found\")\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.tempDir(\"src\")\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\tconst importPath = \"github.com/zombiezen/go-get-issue-10952\"\n+\ttg.run(\"get\", \"-d\", \"-u\", importPath)\n+\trepoDir := tg.path(\"src/\" + importPath)\n+\tdefer tg.resetReadOnlyFlagAll(repoDir)\n+\ttg.runGit(repoDir, \"remote\", \"set-url\", \"origin\", \"https://\"+importPath+\".git\")\n+\ttg.run(\"get\", \"-d\", \"-u\", importPath)\n+}\n+\n+func TestDisallowedCSourceFiles(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.runFail(\"build\", \"badc\")\n+\ttg.grepStderr(\"C source files not allowed\", \"go test did not say C source files not allowed\")\n+}\n+\n+func TestErrorMessageForSyntaxErrorInTestGoFileSaysFAIL(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.runFail(\"test\", \"syntaxerror\")\n+\ttg.grepStderr(\"FAIL\", \"go test did not say FAIL\")\n+}\n+\n+func TestWildcardsDoNotLookInUselessDirectories(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.runFail(\"list\", \"...\")\n+\ttg.grepBoth(\"badpkg\", \"go list ... failure does not mention badpkg\")\n+\ttg.run(\"list\", \"m...\")\n+}\n+\n+func TestRelativeImportsGoTest(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.run(\"test\", \"./testdata/testimport\")\n+}\n+\n+func TestRelativeImportsGoTestDashI(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.run(\"test\", \"-i\", \"./testdata/testimport\")\n+}\n+\n+func TestRelativeImportsInCommandLinePackage(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\tfiles, err := filepath.Glob(\"./testdata/testimport/*.go\")\n+\ttg.must(err)\n+\ttg.run(append([]string{\"test\"}, files...)...)\n+}\n+\n+func TestVersionControlErrorMessageIncludesCorrectDirectory(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata/shadow/root1\"))\n+\ttg.runFail(\"get\", \"-u\", \"foo\")\n+\n+\t// TODO(iant): We should not have to use strconv.Quote here.\n+\t// The code in vcs.go should be changed so that it is not required.\n+\tquoted := strconv.Quote(filepath.Join(\"testdata\", \"shadow\", \"root1\", \"src\", \"foo\"))\n+\tquoted = quoted[1 : len(quoted)-1]\n+\n+\ttg.grepStderr(regexp.QuoteMeta(quoted), \"go get -u error does not mention shadow/root1/src/foo\")\n+}\n+\n+func TestInstallFailsWithNoBuildableFiles(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.setenv(\"CGO_ENABLED\", \"0\")\n+\ttg.runFail(\"install\", \"cgotest\")\n+\ttg.grepStderr(\"no buildable Go source files\", \"go install cgotest did not report 'no buildable Go Source files'\")\n+}\n+\n+// Test that without $GOBIN set, binaries get installed\n+// into the GOPATH bin directory.\n+func TestInstallIntoGOPATH(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.creatingTemp(\"testdata/bin/go-cmd-test\" + exeSuffix)\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.run(\"install\", \"go-cmd-test\")\n+\ttg.wantExecutable(\"testdata/bin/go-cmd-test\"+exeSuffix, \"go install go-cmd-test did not write to testdata/bin/go-cmd-test\")\n+}\n+\n+func TestPackageMainTestImportsArchiveNotBinary(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\tgobin := filepath.Join(tg.pwd(), \"testdata\", \"bin\")\n+\ttg.creatingTemp(gobin)\n+\ttg.setenv(\"GOBIN\", gobin)\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.must(os.Chtimes(\"./testdata/src/main_test/m.go\", time.Now(), time.Now()))\n+\ttg.sleep()\n+\ttg.run(\"test\", \"main_test\")\n+\ttg.run(\"install\", \"main_test\")\n+\ttg.wantNotStale(\"main_test\", \"after go install, main listed as stale\")\n+\ttg.run(\"test\", \"main_test\")\n+}\n+\n+// With $GOBIN set, binaries get installed to $GOBIN.\n+func TestInstallIntoGOBIN(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\tgobin := filepath.Join(tg.pwd(), \"testdata\", \"bin1\")\n+\ttg.creatingTemp(gobin)\n+\ttg.setenv(\"GOBIN\", gobin)\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.run(\"install\", \"go-cmd-test\")\n+\ttg.wantExecutable(\"testdata/bin1/go-cmd-test\"+exeSuffix, \"go install go-cmd-test did not write to testdata/bin1/go-cmd-test\")\n+}\n+\n+// Issue 11065\n+func TestInstallToCurrentDirectoryCreatesExecutable(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\tpkg := filepath.Join(tg.pwd(), \"testdata\", \"src\", \"go-cmd-test\")\n+\ttg.creatingTemp(filepath.Join(pkg, \"go-cmd-test\"+exeSuffix))\n+\ttg.setenv(\"GOBIN\", pkg)\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.cd(pkg)\n+\ttg.run(\"install\")\n+\ttg.wantExecutable(\"go-cmd-test\"+exeSuffix, \"go install did not write to current directory\")\n+}\n+\n+// Without $GOBIN set, installing a program outside $GOPATH should fail\n+// (there is nowhere to install it).\n+func TestInstallWithoutDestinationFails(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.runFail(\"install\", \"testdata/src/go-cmd-test/helloworld.go\")\n+\ttg.grepStderr(\"no install location for .go files listed on command line\", \"wrong error\")\n+}\n+\n+// With $GOBIN set, should install there.\n+func TestInstallToGOBINCommandLinePackage(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\tgobin := filepath.Join(tg.pwd(), \"testdata\", \"bin1\")\n+\ttg.creatingTemp(gobin)\n+\ttg.setenv(\"GOBIN\", gobin)\n+\ttg.run(\"install\", \"testdata/src/go-cmd-test/helloworld.go\")\n+\ttg.wantExecutable(\"testdata/bin1/helloworld\"+exeSuffix, \"go install testdata/src/go-cmd-test/helloworld.go did not write testdata/bin1/helloworld\")\n+}\n+\n+func TestGodocInstalls(t *testing.T) {\n+\ttestenv.MustHaveExternalNetwork(t)\n+\n+\t// godoc installs into GOBIN\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.tempDir(\"gobin\")\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.setenv(\"GOBIN\", tg.path(\"gobin\"))\n+\ttg.run(\"get\", \"golang.org/x/tools/cmd/godoc\")\n+\ttg.wantExecutable(tg.path(\"gobin/godoc\"), \"did not install godoc to $GOBIN\")\n+\ttg.unsetenv(\"GOBIN\")\n+\n+\t// godoc installs into GOROOT\n+\tgoroot := runtime.GOROOT()\n+\ttg.setenv(\"GOROOT\", goroot)\n+\ttg.check(os.RemoveAll(filepath.Join(goroot, \"bin\", \"godoc\")))\n+\ttg.run(\"install\", \"golang.org/x/tools/cmd/godoc\")\n+\ttg.wantExecutable(filepath.Join(goroot, \"bin\", \"godoc\"), \"did not install godoc to $GOROOT/bin\")\n+}\n+\n+func TestGoGetNonPkg(t *testing.T) {\n+\ttestenv.MustHaveExternalNetwork(t)\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.tempDir(\"gobin\")\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.setenv(\"GOBIN\", tg.path(\"gobin\"))\n+\ttg.runFail(\"get\", \"-d\", \"golang.org/x/tools\")\n+\ttg.grepStderr(\"golang.org/x/tools: no buildable Go source files\", \"missing error\")\n+\ttg.runFail(\"get\", \"-d\", \"-u\", \"golang.org/x/tools\")\n+\ttg.grepStderr(\"golang.org/x/tools: no buildable Go source files\", \"missing error\")\n+\ttg.runFail(\"get\", \"-d\", \"golang.org/x/tools\")\n+\ttg.grepStderr(\"golang.org/x/tools: no buildable Go source files\", \"missing error\")\n+}\n+\n+func TestInstalls(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"don't install into GOROOT in short mode\")\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.tempDir(\"gobin\")\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\tgoroot := runtime.GOROOT()\n+\ttg.setenv(\"GOROOT\", goroot)\n+\n+\t// cmd/fix installs into tool\n+\ttg.run(\"env\", \"GOOS\")\n+\tgoos := strings.TrimSpace(tg.getStdout())\n+\ttg.setenv(\"GOOS\", goos)\n+\ttg.run(\"env\", \"GOARCH\")\n+\tgoarch := strings.TrimSpace(tg.getStdout())\n+\ttg.setenv(\"GOARCH\", goarch)\n+\tfixbin := filepath.Join(goroot, \"pkg\", \"tool\", goos+\"_\"+goarch, \"fix\") + exeSuffix\n+\ttg.must(os.RemoveAll(fixbin))\n+\ttg.run(\"install\", \"cmd/fix\")\n+\ttg.wantExecutable(fixbin, \"did not install cmd/fix to $GOROOT/pkg/tool\")\n+\ttg.must(os.Remove(fixbin))\n+\ttg.setenv(\"GOBIN\", tg.path(\"gobin\"))\n+\ttg.run(\"install\", \"cmd/fix\")\n+\ttg.wantExecutable(fixbin, \"did not install cmd/fix to $GOROOT/pkg/tool with $GOBIN set\")\n+\ttg.unsetenv(\"GOBIN\")\n+\n+\t// gopath program installs into GOBIN\n+\ttg.tempFile(\"src/progname/p.go\", `package main; func main() {}`)\n+\ttg.setenv(\"GOBIN\", tg.path(\"gobin\"))\n+\ttg.run(\"install\", \"progname\")\n+\ttg.unsetenv(\"GOBIN\")\n+\ttg.wantExecutable(tg.path(\"gobin/progname\")+exeSuffix, \"did not install progname to $GOBIN/progname\")\n+\n+\t// gopath program installs into GOPATH/bin\n+\ttg.run(\"install\", \"progname\")\n+\ttg.wantExecutable(tg.path(\"bin/progname\")+exeSuffix, \"did not install progname to $GOPATH/bin/progname\")\n+}\n+\n+func TestRejectRelativeDotPathInGOPATHCommandLinePackage(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.setenv(\"GOPATH\", \".\")\n+\ttg.runFail(\"build\", \"testdata/src/go-cmd-test/helloworld.go\")\n+\ttg.grepStderr(\"GOPATH entry is relative\", \"expected an error message rejecting relative GOPATH entries\")\n+}\n+\n+func TestRejectRelativePathsInGOPATH(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\tsep := string(filepath.ListSeparator)\n+\ttg.setenv(\"GOPATH\", sep+filepath.Join(tg.pwd(), \"testdata\")+sep+\".\")\n+\ttg.runFail(\"build\", \"go-cmd-test\")\n+\ttg.grepStderr(\"GOPATH entry is relative\", \"expected an error message rejecting relative GOPATH entries\")\n+}\n+\n+func TestRejectRelativePathsInGOPATHCommandLinePackage(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.setenv(\"GOPATH\", \"testdata\")\n+\ttg.runFail(\"build\", \"testdata/src/go-cmd-test/helloworld.go\")\n+\ttg.grepStderr(\"GOPATH entry is relative\", \"expected an error message rejecting relative GOPATH entries\")\n+}\n+\n+// Issue 4104.\n+func TestGoTestWithPackageListedMultipleTimes(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.run(\"test\", \"errors\", \"errors\", \"errors\", \"errors\", \"errors\")\n+\tif strings.Index(strings.TrimSpace(tg.getStdout()), \"\\n\") != -1 {\n+\t\tt.Error(\"go test errors errors errors errors errors tested the same package multiple times\")\n+\t}\n+}\n+\n+func TestGoListHasAConsistentOrder(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.run(\"list\", \"std\")\n+\tfirst := tg.getStdout()\n+\ttg.run(\"list\", \"std\")\n+\tif first != tg.getStdout() {\n+\t\tt.Error(\"go list std ordering is inconsistent\")\n+\t}\n+}\n+\n+func TestGoListStdDoesNotIncludeCommands(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.run(\"list\", \"std\")\n+\ttg.grepStdoutNot(\"cmd/\", \"go list std shows commands\")\n+}\n+\n+func TestGoListCmdOnlyShowsCommands(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.run(\"list\", \"cmd\")\n+\tout := strings.TrimSpace(tg.getStdout())\n+\tfor _, line := range strings.Split(out, \"\\n\") {\n+\t\tif strings.Index(line, \"cmd/\") == -1 {\n+\t\t\tt.Error(\"go list cmd shows non-commands\")\n+\t\t\tbreak\n+\t\t}\n+\t}\n+}\n+\n+// Issue 4096. Validate the output of unsuccessful go install foo/quxx.\n+func TestUnsuccessfulGoInstallShouldMentionMissingPackage(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.runFail(\"install\", \"foo/quxx\")\n+\tif tg.grepCountBoth(`cannot find package \"foo/quxx\" in any of`) != 1 {\n+\t\tt.Error(`go install foo/quxx expected error: .*cannot find package \"foo/quxx\" in any of`)\n+\t}\n+}\n+\n+func TestGOROOTSearchFailureReporting(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.runFail(\"install\", \"foo/quxx\")\n+\tif tg.grepCountBoth(regexp.QuoteMeta(filepath.Join(\"foo\", \"quxx\"))+` \\(from \\$GOROOT\\)$`) != 1 {\n+\t\tt.Error(`go install foo/quxx expected error: .*foo/quxx (from $GOROOT)`)\n+\t}\n+}\n+\n+func TestMultipleGOPATHEntriesReportedSeparately(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\tsep := string(filepath.ListSeparator)\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\", \"a\")+sep+filepath.Join(tg.pwd(), \"testdata\", \"b\"))\n+\ttg.runFail(\"install\", \"foo/quxx\")\n+\tif tg.grepCountBoth(`testdata[/\\\\].[/\\\\]src[/\\\\]foo[/\\\\]quxx`) != 2 {\n+\t\tt.Error(`go install foo/quxx expected error: .*testdata/a/src/foo/quxx (from $GOPATH)\\n.*testdata/b/src/foo/quxx`)\n+\t}\n+}\n+\n+// Test (from $GOPATH) annotation is reported for the first GOPATH entry,\n+func TestMentionGOPATHInFirstGOPATHEntry(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\tsep := string(filepath.ListSeparator)\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\", \"a\")+sep+filepath.Join(tg.pwd(), \"testdata\", \"b\"))\n+\ttg.runFail(\"install\", \"foo/quxx\")\n+\tif tg.grepCountBoth(regexp.QuoteMeta(filepath.Join(\"testdata\", \"a\", \"src\", \"foo\", \"quxx\"))+` \\(from \\$GOPATH\\)$`) != 1 {\n+\t\tt.Error(`go install foo/quxx expected error: .*testdata/a/src/foo/quxx (from $GOPATH)`)\n+\t}\n+}\n+\n+// but not on the second.\n+func TestMentionGOPATHNotOnSecondEntry(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\tsep := string(filepath.ListSeparator)\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\", \"a\")+sep+filepath.Join(tg.pwd(), \"testdata\", \"b\"))\n+\ttg.runFail(\"install\", \"foo/quxx\")\n+\tif tg.grepCountBoth(regexp.QuoteMeta(filepath.Join(\"testdata\", \"b\", \"src\", \"foo\", \"quxx\"))+`$`) != 1 {\n+\t\tt.Error(`go install foo/quxx expected error: .*testdata/b/src/foo/quxx`)\n+\t}\n+}\n+\n+// Test missing GOPATH is reported.\n+func TestMissingGOPATHIsReported(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.setenv(\"GOPATH\", \"\")\n+\ttg.runFail(\"install\", \"foo/quxx\")\n+\tif tg.grepCountBoth(`\\(\\$GOPATH not set\\)$`) != 1 {\n+\t\tt.Error(`go install foo/quxx expected error: ($GOPATH not set)`)\n+\t}\n+}\n+\n+// Issue 4186.  go get cannot be used to download packages to $GOROOT.\n+// Test that without GOPATH set, go get should fail.\n+func TestWithoutGOPATHGoGetFails(t *testing.T) {\n+\ttestenv.MustHaveExternalNetwork(t)\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.tempDir(\"src\")\n+\ttg.setenv(\"GOPATH\", \"\")\n+\ttg.setenv(\"GOROOT\", tg.path(\".\"))\n+\ttg.runFail(\"get\", \"-d\", \"golang.org/x/codereview/cmd/hgpatch\")\n+}\n+\n+// Test that with GOPATH=$GOROOT, go get should fail.\n+func TestWithGOPATHEqualsGOROOTGoGetFails(t *testing.T) {\n+\ttestenv.MustHaveExternalNetwork(t)\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.tempDir(\"src\")\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.setenv(\"GOROOT\", tg.path(\".\"))\n+\ttg.runFail(\"get\", \"-d\", \"golang.org/x/codereview/cmd/hgpatch\")\n+}\n+\n+func TestLdflagsArgumentsWithSpacesIssue3941(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.tempFile(\"main.go\", `package main\n+\t\tvar extern string\n+\t\tfunc main() {\n+\t\t\tprintln(extern)\n+\t\t}`)\n+\ttg.run(\"run\", \"-ldflags\", `-X main.extern \"hello world\"`, tg.path(\"main.go\"))\n+\ttg.grepStderr(\"^hello world\", `ldflags -X main.extern 'hello world' failed`)\n+}\n+\n+func TestGoTestCpuprofileLeavesBinaryBehind(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.makeTempdir()\n+\ttg.cd(tg.path(\".\"))\n+\ttg.run(\"test\", \"-cpuprofile\", \"errors.prof\", \"errors\")\n+\ttg.wantExecutable(\"errors.test\"+exeSuffix, \"go test -cpuprofile did not create errors.test\")\n+}\n+\n+func TestGoTestCpuprofileDashOControlsBinaryLocation(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.makeTempdir()\n+\ttg.cd(tg.path(\".\"))\n+\ttg.run(\"test\", \"-cpuprofile\", \"errors.prof\", \"-o\", \"myerrors.test\"+exeSuffix, \"errors\")\n+\ttg.wantExecutable(\"myerrors.test\"+exeSuffix, \"go test -cpuprofile -o myerrors.test did not create myerrors.test\")\n+}\n+\n+func TestGoTestDashCDashOControlsBinaryLocation(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.makeTempdir()\n+\ttg.run(\"test\", \"-c\", \"-o\", tg.path(\"myerrors.test\"+exeSuffix), \"errors\")\n+\ttg.wantExecutable(tg.path(\"myerrors.test\"+exeSuffix), \"go test -c -o myerrors.test did not create myerrors.test\")\n+}\n+\n+func TestGoTestDashOWritesBinary(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.makeTempdir()\n+\ttg.run(\"test\", \"-o\", tg.path(\"myerrors.test\"+exeSuffix), \"errors\")\n+\ttg.wantExecutable(tg.path(\"myerrors.test\"+exeSuffix), \"go test -o myerrors.test did not create myerrors.test\")\n+}\n+\n+// Issue 4568.\n+func TestSymlinksDoNotConfuseGoList(t *testing.T) {\n+\tswitch runtime.GOOS {\n+\tcase \"plan9\", \"windows\":\n+\t\tt.Skipf(\"skipping symlink test on %s\", runtime.GOOS)\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.tempDir(\"src\")\n+\ttg.must(os.Symlink(tg.path(\".\"), tg.path(\"src/dir1\")))\n+\ttg.tempFile(\"src/dir1/p.go\", \"package p\")\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.cd(tg.path(\"src\"))\n+\ttg.run(\"list\", \"-f\", \"{{.Root}}\", \"dir1\")\n+\tif strings.TrimSpace(tg.getStdout()) != tg.path(\".\") {\n+\t\tt.Error(\"confused by symlinks\")\n+\t}\n+}\n+\n+// Issue 4515.\n+func TestInstallWithTags(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.tempDir(\"bin\")\n+\ttg.tempFile(\"src/example/a/main.go\", `package main\n+\t\tfunc main() {}`)\n+\ttg.tempFile(\"src/example/b/main.go\", `// +build mytag\n+\n+\t\tpackage main\n+\t\tfunc main() {}`)\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.run(\"install\", \"-tags\", \"mytag\", \"example/a\", \"example/b\")\n+\ttg.wantExecutable(tg.path(\"bin/a\"+exeSuffix), \"go install example/a example/b did not install binaries\")\n+\ttg.wantExecutable(tg.path(\"bin/b\"+exeSuffix), \"go install example/a example/b did not install binaries\")\n+\ttg.must(os.Remove(tg.path(\"bin/a\" + exeSuffix)))\n+\ttg.must(os.Remove(tg.path(\"bin/b\" + exeSuffix)))\n+\ttg.run(\"install\", \"-tags\", \"mytag\", \"example/...\")\n+\ttg.wantExecutable(tg.path(\"bin/a\"+exeSuffix), \"go install example/... did not install binaries\")\n+\ttg.wantExecutable(tg.path(\"bin/b\"+exeSuffix), \"go install example/... did not install binaries\")\n+\ttg.run(\"list\", \"-tags\", \"mytag\", \"example/b...\")\n+\tif strings.TrimSpace(tg.getStdout()) != \"example/b\" {\n+\t\tt.Error(\"go list example/b did not find example/b\")\n+\t}\n+}\n+\n+// Issue 4773\n+func TestCaseCollisions(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.tempDir(\"src/example/a/pkg\")\n+\ttg.tempDir(\"src/example/a/Pkg\")\n+\ttg.tempDir(\"src/example/b\")\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.tempFile(\"src/example/a/a.go\", `package p\n+\t\timport (\n+\t\t\t_ \"example/a/pkg\"\n+\t\t\t_ \"example/a/Pkg\"\n+\t\t)`)\n+\ttg.tempFile(\"src/example/a/pkg/pkg.go\", `package pkg`)\n+\ttg.tempFile(\"src/example/a/Pkg/pkg.go\", `package pkg`)\n+\ttg.runFail(\"list\", \"example/a\")\n+\ttg.grepStderr(\"case-insensitive import collision\", \"go list example/a did not report import collision\")\n+\ttg.tempFile(\"src/example/b/file.go\", `package b`)\n+\ttg.tempFile(\"src/example/b/FILE.go\", `package b`)\n+\tf, err := os.Open(tg.path(\"src/example/b\"))\n+\ttg.must(err)\n+\tnames, err := f.Readdirnames(0)\n+\ttg.must(err)\n+\ttg.check(f.Close())\n+\targs := []string{\"list\"}\n+\tif len(names) == 2 {\n+\t\t// case-sensitive file system, let directory read find both files\n+\t\targs = append(args, \"example/b\")\n+\t} else {\n+\t\t// case-insensitive file system, list files explicitly on command line\n+\t\targs = append(args, tg.path(\"src/example/b/file.go\"), tg.path(\"src/example/b/FILE.go\"))\n+\t}\n+\ttg.runFail(args...)\n+\ttg.grepStderr(\"case-insensitive file name collision\", \"go list example/b did not report file name collision\")\n+}\n+\n+// Issue 8181.\n+func TestGoGetDashTIssue8181(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"skipping test that uses network in short mode\")\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.run(\"get\", \"-v\", \"-t\", \"github.com/rsc/go-get-issue-8181/a\", \"github.com/rsc/go-get-issue-8181/b\")\n+\ttg.run(\"list\", \"...\")\n+\ttg.grepStdout(\"x/build/cmd/cl\", \"missing expected x/build/cmd/cl\")\n+}\n+\n+func TestIssue11307(t *testing.T) {\n+\t// go get -u was not working except in checkout directory\n+\tif testing.Short() {\n+\t\tt.Skip(\"skipping test that uses network in short mode\")\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.run(\"get\", \"github.com/rsc/go-get-issue-11307\")\n+\ttg.run(\"get\", \"-u\", \"github.com/rsc/go-get-issue-11307\") // was failing\n+}\n+\n+func TestShadowingLogic(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\tpwd := tg.pwd()\n+\tsep := string(filepath.ListSeparator)\n+\ttg.setenv(\"GOPATH\", filepath.Join(pwd, \"testdata\", \"shadow\", \"root1\")+sep+filepath.Join(pwd, \"testdata\", \"shadow\", \"root2\"))\n+\n+\t// The math in root1 is not \"math\" because the standard math is.\n+\ttg.run(\"list\", \"-f\", \"({{.ImportPath}}) ({{.ConflictDir}})\", \"./testdata/shadow/root1/src/math\")\n+\tpwdForwardSlash := strings.Replace(pwd, string(os.PathSeparator), \"/\", -1)\n+\tif !strings.HasPrefix(pwdForwardSlash, \"/\") {\n+\t\tpwdForwardSlash = \"/\" + pwdForwardSlash\n+\t}\n+\t// The output will have makeImportValid applies, but we only\n+\t// bother to deal with characters we might reasonably see.\n+\tpwdForwardSlash = strings.Replace(pwdForwardSlash, \":\", \"_\", -1)\n+\twant := \"(_\" + pwdForwardSlash + \"/testdata/shadow/root1/src/math) (\" + filepath.Join(runtime.GOROOT(), \"src\", \"math\") + \")\"\n+\tif strings.TrimSpace(tg.getStdout()) != want {\n+\t\tt.Error(\"shadowed math is not shadowed; looking for\", want)\n+\t}\n+\n+\t// The foo in root1 is \"foo\".\n+\ttg.run(\"list\", \"-f\", \"({{.ImportPath}}) ({{.ConflictDir}})\", \"./testdata/shadow/root1/src/foo\")\n+\tif strings.TrimSpace(tg.getStdout()) != \"(foo) ()\" {\n+\t\tt.Error(\"unshadowed foo is shadowed\")\n+\t}\n+\n+\t// The foo in root2 is not \"foo\" because the foo in root1 got there first.\n+\ttg.run(\"list\", \"-f\", \"({{.ImportPath}}) ({{.ConflictDir}})\", \"./testdata/shadow/root2/src/foo\")\n+\twant = \"(_\" + pwdForwardSlash + \"/testdata/shadow/root2/src/foo) (\" + filepath.Join(pwd, \"testdata\", \"shadow\", \"root1\", \"src\", \"foo\") + \")\"\n+\tif strings.TrimSpace(tg.getStdout()) != want {\n+\t\tt.Error(\"shadowed foo is not shadowed; looking for\", want)\n+\t}\n+\n+\t// The error for go install should mention the conflicting directory.\n+\ttg.runFail(\"install\", \"./testdata/shadow/root2/src/foo\")\n+\twant = \"go install: no install location for \" + filepath.Join(pwd, \"testdata\", \"shadow\", \"root2\", \"src\", \"foo\") + \": hidden by \" + filepath.Join(pwd, \"testdata\", \"shadow\", \"root1\", \"src\", \"foo\")\n+\tif strings.TrimSpace(tg.getStderr()) != want {\n+\t\tt.Error(\"wrong shadowed install error; looking for\", want)\n+\t}\n+}\n+\n+// Only succeeds if source order is preserved.\n+func TestSourceFileNameOrderPreserved(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.run(\"test\", \"testdata/example1_test.go\", \"testdata/example2_test.go\")\n+}\n+\n+// Check that coverage analysis works at all.\n+// Don't worry about the exact numbers but require not 0.0%.\n+func checkCoverage(tg *testgoData, data string) {\n+\tif regexp.MustCompile(`[^0-9]0\\.0%`).MatchString(data) {\n+\t\ttg.t.Error(\"some coverage results are 0.0%\")\n+\t}\n+\ttg.t.Log(data)\n+}\n+\n+func TestCoverageRuns(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"don't build libraries for coverage in short mode\")\n+\t}\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.run(\"test\", \"-short\", \"-coverpkg=strings\", \"strings\", \"regexp\")\n+\tdata := tg.getStdout() + tg.getStderr()\n+\ttg.run(\"test\", \"-short\", \"-cover\", \"strings\", \"math\", \"regexp\")\n+\tdata += tg.getStdout() + tg.getStderr()\n+\tcheckCoverage(tg, data)\n+}\n+\n+// Check that coverage analysis uses set mode.\n+func TestCoverageUsesSetMode(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"don't build libraries for coverage in short mode\")\n+\t}\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.creatingTemp(\"testdata/cover.out\")\n+\ttg.run(\"test\", \"-short\", \"-cover\", \"encoding/binary\", \"-coverprofile=testdata/cover.out\")\n+\tdata := tg.getStdout() + tg.getStderr()\n+\tif out, err := ioutil.ReadFile(\"testdata/cover.out\"); err != nil {\n+\t\tt.Error(err)\n+\t} else {\n+\t\tif !bytes.Contains(out, []byte(\"mode: set\")) {\n+\t\t\tt.Error(\"missing mode: set\")\n+\t\t}\n+\t}\n+\tcheckCoverage(tg, data)\n+}\n+\n+func TestCoverageUsesAtomicModeForRace(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"don't build libraries for coverage in short mode\")\n+\t}\n+\tif !canRace {\n+\t\tt.Skip(\"skipping because race detector not supported\")\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.creatingTemp(\"testdata/cover.out\")\n+\ttg.run(\"test\", \"-short\", \"-race\", \"-cover\", \"encoding/binary\", \"-coverprofile=testdata/cover.out\")\n+\tdata := tg.getStdout() + tg.getStderr()\n+\tif out, err := ioutil.ReadFile(\"testdata/cover.out\"); err != nil {\n+\t\tt.Error(err)\n+\t} else {\n+\t\tif !bytes.Contains(out, []byte(\"mode: atomic\")) {\n+\t\t\tt.Error(\"missing mode: atomic\")\n+\t\t}\n+\t}\n+\tcheckCoverage(tg, data)\n+}\n+\n+func TestCoverageUsesActualSettingToOverrideEvenForRace(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"don't build libraries for coverage in short mode\")\n+\t}\n+\tif !canRace {\n+\t\tt.Skip(\"skipping because race detector not supported\")\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.creatingTemp(\"testdata/cover.out\")\n+\ttg.run(\"test\", \"-short\", \"-race\", \"-cover\", \"encoding/binary\", \"-covermode=count\", \"-coverprofile=testdata/cover.out\")\n+\tdata := tg.getStdout() + tg.getStderr()\n+\tif out, err := ioutil.ReadFile(\"testdata/cover.out\"); err != nil {\n+\t\tt.Error(err)\n+\t} else {\n+\t\tif !bytes.Contains(out, []byte(\"mode: count\")) {\n+\t\t\tt.Error(\"missing mode: count\")\n+\t\t}\n+\t}\n+\tcheckCoverage(tg, data)\n+}\n+\n+func TestCoverageWithCgo(t *testing.T) {\n+\tif !canCgo {\n+\t\tt.Skip(\"skipping because cgo not enabled\")\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.run(\"test\", \"-short\", \"-cover\", \"./testdata/cgocover\")\n+\tdata := tg.getStdout() + tg.getStderr()\n+\tcheckCoverage(tg, data)\n+}\n+\n+func TestCgoDependsOnSyscall(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"skipping test that removes $GOROOT/pkg/*_race in short mode\")\n+\t}\n+\tif !canCgo {\n+\t\tt.Skip(\"skipping because cgo not enabled\")\n+\t}\n+\tif !canRace {\n+\t\tt.Skip(\"skipping because race detector not supported\")\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\tfiles, err := filepath.Glob(filepath.Join(runtime.GOROOT(), \"pkg\", \"*_race\"))\n+\ttg.must(err)\n+\tfor _, file := range files {\n+\t\ttg.check(os.RemoveAll(file))\n+\t}\n+\ttg.tempFile(\"src/foo/foo.go\", `\n+\t\tpackage foo\n+\t\t//#include <stdio.h>\n+\t\timport \"C\"`)\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.run(\"build\", \"-race\", \"foo\")\n+}\n+\n+func TestCgoShowsFullPathNames(t *testing.T) {\n+\tif !canCgo {\n+\t\tt.Skip(\"skipping because cgo not enabled\")\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.tempFile(\"src/x/y/dirname/foo.go\", `\n+\t\tpackage foo\n+\t\timport \"C\"\n+\t\tfunc f() {`)\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.runFail(\"build\", \"x/y/dirname\")\n+\ttg.grepBoth(\"x/y/dirname\", \"error did not use full path\")\n+}\n+\n+func TestCgoHandlesWlORIGIN(t *testing.T) {\n+\tif !canCgo {\n+\t\tt.Skip(\"skipping because cgo not enabled\")\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.tempFile(\"src/origin/origin.go\", `package origin\n+\t\t// #cgo !darwin LDFLAGS: -Wl,-rpath -Wl,$ORIGIN\n+\t\t// void f(void) {}\n+\t\timport \"C\"\n+\t\tfunc f() { C.f() }`)\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.run(\"build\", \"origin\")\n+}\n+\n+// \"go test -c -test.bench=XXX errors\" should not hang\n+func TestIssue6480(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.makeTempdir()\n+\ttg.cd(tg.path(\".\"))\n+\ttg.run(\"test\", \"-c\", \"-test.bench=XXX\", \"errors\")\n+}\n+\n+// cmd/cgo: undefined reference when linking a C-library using gccgo\n+func TestIssue7573(t *testing.T) {\n+\tif _, err := exec.LookPath(\"gccgo\"); err != nil {\n+\t\tt.Skip(\"skipping because no gccgo compiler found\")\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.tempFile(\"src/cgoref/cgoref.go\", `\n+package main\n+// #cgo LDFLAGS: -L alibpath -lalib\n+// void f(void) {}\n+import \"C\"\n+\n+func main() { C.f() }`)\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.run(\"build\", \"-n\", \"-compiler\", \"gccgo\", \"cgoref\")\n+\ttg.grepStderr(`gccgo.*\\-L alibpath \\-lalib`, `no Go-inline \"#cgo LDFLAGS:\" (\"-L alibpath -lalib\") passed to gccgo linking stage`)\n+}\n+\n+func TestListTemplateCanUseContextFunction(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.run(\"list\", \"-f\", \"GOARCH: {{context.GOARCH}}\")\n+}\n+\n+// cmd/go: \"go test\" should fail if package does not build\n+func TestIssue7108(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.runFail(\"test\", \"notest\")\n+}\n+\n+// cmd/go: go test -a foo does not rebuild regexp.\n+func TestIssue6844(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"don't rebuild the standard libary in short mode\")\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.creatingTemp(\"deps.test\" + exeSuffix)\n+\ttg.run(\"test\", \"-x\", \"-a\", \"-c\", \"testdata/dep_test.go\")\n+\ttg.grepStderr(\"regexp\", \"go test -x -a -c testdata/dep-test.go did not rebuild regexp\")\n+}\n+\n+func TestBuildDashIInstallsDependencies(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.tempFile(\"src/x/y/foo/foo.go\", `package foo\n+\t\tfunc F() {}`)\n+\ttg.tempFile(\"src/x/y/bar/bar.go\", `package bar\n+\t\timport \"x/y/foo\"\n+\t\tfunc F() { foo.F() }`)\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\n+\tcheckbar := func(desc string) {\n+\t\ttg.sleep()\n+\t\ttg.must(os.Chtimes(tg.path(\"src/x/y/foo/foo.go\"), time.Now(), time.Now()))\n+\t\ttg.sleep()\n+\t\ttg.run(\"build\", \"-v\", \"-i\", \"x/y/bar\")\n+\t\ttg.grepBoth(\"x/y/foo\", \"first build -i \"+desc+\" did not build x/y/foo\")\n+\t\ttg.run(\"build\", \"-v\", \"-i\", \"x/y/bar\")\n+\t\ttg.grepBothNot(\"x/y/foo\", \"second build -i \"+desc+\" built x/y/foo\")\n+\t}\n+\tcheckbar(\"pkg\")\n+\ttg.creatingTemp(\"bar\" + exeSuffix)\n+\ttg.tempFile(\"src/x/y/bar/bar.go\", `package main\n+\t\timport \"x/y/foo\"\n+\t\tfunc main() { foo.F() }`)\n+\tcheckbar(\"cmd\")\n+}\n+\n+func TestGoBuildInTestOnlyDirectoryFailsWithAGoodError(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.runFail(\"build\", \"./testdata/testonly\")\n+\ttg.grepStderr(\"no buildable Go\", \"go build ./testdata/testonly produced unexpected error\")\n+}\n+\n+func TestGoTestDetectsTestOnlyImportCycles(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.runFail(\"test\", \"-c\", \"testcycle/p3\")\n+\ttg.grepStderr(\"import cycle not allowed in test\", \"go test testcycle/p3 produced unexpected error\")\n+\n+\ttg.runFail(\"test\", \"-c\", \"testcycle/q1\")\n+\ttg.grepStderr(\"import cycle not allowed in test\", \"go test testcycle/q1 produced unexpected error\")\n+}\n+\n+func TestGoTestFooTestWorks(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.run(\"test\", \"testdata/standalone_test.go\")\n+}\n+\n+func TestGoTestXtestonlyWorks(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.run(\"clean\", \"-i\", \"xtestonly\")\n+\ttg.run(\"test\", \"xtestonly\")\n+}\n+\n+func TestGoTestBuildsAnXtestContainingOnlyNonRunnableExamples(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.run(\"test\", \"-v\", \"./testdata/norunexample\")\n+\ttg.grepStdout(\"File with non-runnable example was built.\", \"file with non-runnable example was not built\")\n+}\n+\n+func TestGoGenerateHandlesSimpleCommand(t *testing.T) {\n+\tif runtime.GOOS == \"windows\" {\n+\t\tt.Skip(\"skipping because windows has no echo command\")\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.run(\"generate\", \"./testdata/generate/test1.go\")\n+\ttg.grepStdout(\"Success\", \"go generate ./testdata/generate/test1.go generated wrong output\")\n+}\n+\n+func TestGoGenerateHandlesCommandAlias(t *testing.T) {\n+\tif runtime.GOOS == \"windows\" {\n+\t\tt.Skip(\"skipping because windows has no echo command\")\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.run(\"generate\", \"./testdata/generate/test2.go\")\n+\ttg.grepStdout(\"Now is the time for all good men\", \"go generate ./testdata/generate/test2.go generated wrong output\")\n+}\n+\n+func TestGoGenerateVariableSubstitution(t *testing.T) {\n+\tif runtime.GOOS == \"windows\" {\n+\t\tt.Skip(\"skipping because windows has no echo command\")\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.run(\"generate\", \"./testdata/generate/test3.go\")\n+\ttg.grepStdout(runtime.GOARCH+\" test3.go:7 pabc xyzp/test3.go/123\", \"go generate ./testdata/generate/test3.go generated wrong output\")\n+}\n+\n+func TestGoGenerateRunFlag(t *testing.T) {\n+\tif runtime.GOOS == \"windows\" {\n+\t\tt.Skip(\"skipping because windows has no echo command\")\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.run(\"generate\", \"-run\", \"y.s\", \"./testdata/generate/test4.go\")\n+\ttg.grepStdout(\"yes\", \"go generate -run yes ./testdata/generate/test4.go did not select yes\")\n+\ttg.grepStdoutNot(\"no\", \"go generate -run yes ./testdata/generate/test4.go selected no\")\n+}\n+\n+func TestGoGetCustomDomainWildcard(t *testing.T) {\n+\ttestenv.MustHaveExternalNetwork(t)\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.run(\"get\", \"-u\", \"rsc.io/pdf/...\")\n+\ttg.wantExecutable(tg.path(\"bin/pdfpasswd\"+exeSuffix), \"did not build rsc/io/pdf/pdfpasswd\")\n+}\n+\n+func TestGoGetInternalWildcard(t *testing.T) {\n+\ttestenv.MustHaveExternalNetwork(t)\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\t// used to fail with errors about internal packages\n+\ttg.run(\"get\", \"github.com/rsc/go-get-issue-11960/...\")\n+}\n+\n+func TestGoVetWithExternalTests(t *testing.T) {\n+\ttestenv.MustHaveExternalNetwork(t)\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.run(\"get\", \"golang.org/x/tools/cmd/vet\")\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.runFail(\"vet\", \"vetpkg\")\n+\ttg.grepBoth(\"missing argument for Printf\", \"go vet vetpkg did not find missing argument for Printf\")\n+}\n+\n+func TestGoVetWithTags(t *testing.T) {\n+\ttestenv.MustHaveExternalNetwork(t)\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.run(\"get\", \"golang.org/x/tools/cmd/vet\")\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.runFail(\"vet\", \"-tags\", \"tagtest\", \"vetpkg\")\n+\ttg.grepBoth(`c\\.go.*wrong number of args for format`, \"go get vetpkg did not run scan tagged file\")\n+}\n+\n+// Issue 9767.\n+func TestGoGetRscIoToolstash(t *testing.T) {\n+\ttestenv.MustHaveExternalNetwork(t)\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.tempDir(\"src/rsc.io\")\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.cd(tg.path(\"src/rsc.io\"))\n+\ttg.run(\"get\", \"./toolstash\")\n+}\n+\n+// Test that you can not import a main package.\n+func TestIssue4210(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.tempFile(\"src/x/main.go\", `package main\n+\t\tvar X int\n+\t\tfunc main() {}`)\n+\ttg.tempFile(\"src/y/main.go\", `package main\n+\t\timport \"fmt\"\n+\t\timport xmain \"x\"\n+\t\tfunc main() {\n+\t\t\tfmt.Println(xmain.X)\n+\t\t}`)\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.runFail(\"build\", \"y\")\n+\ttg.grepBoth(\"is a program\", `did not find expected error message (\"is a program\")`)\n+}\n+\n+func TestGoGetInsecure(t *testing.T) {\n+\ttestenv.MustHaveExternalNetwork(t)\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.failSSH()\n+\n+\tconst repo = \"wh3rd.net/git.git\"\n+\n+\t// Try go get -d of HTTP-only repo (should fail).\n+\ttg.runFail(\"get\", \"-d\", repo)\n+\n+\t// Try again with -insecure (should succeed).\n+\ttg.run(\"get\", \"-d\", \"-insecure\", repo)\n+\n+\t// Try updating without -insecure (should fail).\n+\ttg.runFail(\"get\", \"-d\", \"-u\", \"-f\", repo)\n+}\n+\n+func TestGoGetUpdateInsecure(t *testing.T) {\n+\ttestenv.MustHaveExternalNetwork(t)\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\n+\tconst repo = \"github.com/golang/example\"\n+\n+\t// Clone the repo via HTTP manually.\n+\tcmd := exec.Command(\"git\", \"clone\", \"-q\", \"http://\"+repo, tg.path(\"src/\"+repo))\n+\tif out, err := cmd.CombinedOutput(); err != nil {\n+\t\tt.Fatalf(\"cloning %v repo: %v\\n%s\", repo, err, out)\n+\t}\n+\n+\t// Update without -insecure should fail.\n+\t// Update with -insecure should succeed.\n+\t// We need -f to ignore import comments.\n+\tconst pkg = repo + \"/hello\"\n+\ttg.runFail(\"get\", \"-d\", \"-u\", \"-f\", pkg)\n+\ttg.run(\"get\", \"-d\", \"-u\", \"-f\", \"-insecure\", pkg)\n+}\n+\n+func TestGoGetInsecureCustomDomain(t *testing.T) {\n+\ttestenv.MustHaveExternalNetwork(t)\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\n+\tconst repo = \"wh3rd.net/repo\"\n+\ttg.runFail(\"get\", \"-d\", repo)\n+\ttg.run(\"get\", \"-d\", \"-insecure\", repo)\n+}\n+\n+func TestIssue10193(t *testing.T) {\n+\ttestenv.MustHaveExternalNetwork(t)\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.tempDir(\"src\")\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.runFail(\"get\", \"code.google.com/p/rsc/pdf\")\n+\ttg.grepStderr(\"is shutting down\", \"missed warning about code.google.com\")\n+}\n+\n+func TestGoRunDirs(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.cd(\"testdata/rundir\")\n+\ttg.runFail(\"run\", \"x.go\", \"sub/sub.go\")\n+\ttg.grepStderr(\"named files must all be in one directory; have ./ and sub/\", \"wrong output\")\n+\ttg.runFail(\"run\", \"sub/sub.go\", \"x.go\")\n+\ttg.grepStderr(\"named files must all be in one directory; have sub/ and ./\", \"wrong output\")\n+}\n+\n+func TestGoInstallPkgdir(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.makeTempdir()\n+\tpkg := tg.path(\".\")\n+\ttg.run(\"install\", \"-pkgdir\", pkg, \"errors\")\n+\t_, err := os.Stat(filepath.Join(pkg, \"errors.a\"))\n+\ttg.must(err)\n+\t_, err = os.Stat(filepath.Join(pkg, \"runtime.a\"))\n+\ttg.must(err)\n+}\n+\n+func TestGoTestRaceInstallCgo(t *testing.T) {\n+\tswitch sys := runtime.GOOS + \"/\" + runtime.GOARCH; sys {\n+\tcase \"darwin/amd64\", \"freebsd/amd64\", \"linux/amd64\", \"windows/amd64\":\n+\t\t// ok\n+\tdefault:\n+\t\tt.Skip(\"no race detector on %s\", sys)\n+\t}\n+\n+\tif !build.Default.CgoEnabled {\n+\t\tt.Skip(\"no race detector without cgo\")\n+\t}\n+\n+\t// golang.org/issue/10500.\n+\t// This used to install a race-enabled cgo.\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.run(\"tool\", \"-n\", \"cgo\")\n+\tcgo := strings.TrimSpace(tg.stdout.String())\n+\told, err := os.Stat(cgo)\n+\ttg.must(err)\n+\ttg.run(\"test\", \"-race\", \"-i\", \"runtime/race\")\n+\tnew, err := os.Stat(cgo)\n+\ttg.must(err)\n+\tif new.ModTime() != old.ModTime() {\n+\t\tt.Fatalf(\"go test -i runtime/race reinstalled cmd/cgo\")\n+\t}\n+}\n+\n+func TestGoTestImportErrorStack(t *testing.T) {\n+\tconst out = `package testdep/p1 (test)\n+\timports testdep/p2\n+\timports testdep/p3: no buildable Go source files`\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.runFail(\"test\", \"testdep/p1\")\n+\tif !strings.Contains(tg.stderr.String(), out) {\n+\t\tt.Fatal(\"did not give full import stack:\\n\\n%s\", tg.stderr.String())\n+\t}\n+}\n+\n+func TestGoGetUpdate(t *testing.T) {\n+\t// golang.org/issue/9224.\n+\t// The recursive updating was trying to walk to\n+\t// former dependencies, not current ones.\n+\n+\ttestenv.MustHaveExternalNetwork(t)\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\n+\trewind := func() {\n+\t\ttg.run(\"get\", \"github.com/rsc/go-get-issue-9224-cmd\")\n+\t\tcmd := exec.Command(\"git\", \"reset\", \"--hard\", \"HEAD~\")\n+\t\tcmd.Dir = tg.path(\"src/github.com/rsc/go-get-issue-9224-lib\")\n+\t\tout, err := cmd.CombinedOutput()\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"git: %v\\n%s\", err, out)\n+\t\t}\n+\t}\n+\n+\trewind()\n+\ttg.run(\"get\", \"-u\", \"github.com/rsc/go-get-issue-9224-cmd\")\n+\n+\t// Again with -d -u.\n+\trewind()\n+\ttg.run(\"get\", \"-d\", \"-u\", \"github.com/rsc/go-get-issue-9224-cmd\")\n+}\n+\n+func TestGoGetDomainRoot(t *testing.T) {\n+\t// golang.org/issue/9357.\n+\t// go get foo.io (not foo.io/subdir) was not working consistently.\n+\n+\ttestenv.MustHaveExternalNetwork(t)\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\n+\t// go-get-issue-9357.appspot.com is running\n+\t// the code at github.com/rsc/go-get-issue-9357,\n+\t// a trivial Go on App Engine app that serves a\n+\t// <meta> tag for the domain root.\n+\ttg.run(\"get\", \"-d\", \"go-get-issue-9357.appspot.com\")\n+\ttg.run(\"get\", \"go-get-issue-9357.appspot.com\")\n+\ttg.run(\"get\", \"-u\", \"go-get-issue-9357.appspot.com\")\n+\n+\ttg.must(os.RemoveAll(tg.path(\"src/go-get-issue-9357.appspot.com\")))\n+\ttg.run(\"get\", \"go-get-issue-9357.appspot.com\")\n+\n+\ttg.must(os.RemoveAll(tg.path(\"src/go-get-issue-9357.appspot.com\")))\n+\ttg.run(\"get\", \"-u\", \"go-get-issue-9357.appspot.com\")\n+}\n+\n+func TestGoInstallShadowedGOPATH(t *testing.T) {\n+\t// golang.org/issue/3652.\n+\t// go get foo.io (not foo.io/subdir) was not working consistently.\n+\n+\ttestenv.MustHaveExternalNetwork(t)\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOPATH\", tg.path(\"gopath1\")+string(filepath.ListSeparator)+tg.path(\"gopath2\"))\n+\n+\ttg.tempDir(\"gopath1/src/test\")\n+\ttg.tempDir(\"gopath2/src/test\")\n+\ttg.tempFile(\"gopath2/src/test/main.go\", \"package main\\nfunc main(){}\\n\")\n+\n+\ttg.cd(tg.path(\"gopath2/src/test\"))\n+\ttg.runFail(\"install\")\n+\ttg.grepStderr(\"no install location for.*gopath2.src.test: hidden by .*gopath1.src.test\", \"missing error\")\n+}\n+\n+func TestIssue11709(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.tempFile(\"run.go\", `\n+\t\tpackage main\n+\t\timport \"os\"\n+\t\tfunc main() {\n+\t\t\tif os.Getenv(\"TERM\") != \"\" {\n+\t\t\t\tos.Exit(1)\n+\t\t\t}\n+\t\t}`)\n+\ttg.unsetenv(\"TERM\")\n+\ttg.run(\"run\", tg.path(\"run.go\"))\n+}\n+\n+func TestIssue12096(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.tempFile(\"test_test.go\", `\n+\t\tpackage main\n+\t\timport (\"os\"; \"testing\")\n+\t\tfunc TestEnv(t *testing.T) {\n+\t\t\tif os.Getenv(\"TERM\") != \"\" {\n+\t\t\t\tt.Fatal(\"TERM is set\")\n+\t\t\t}\n+\t\t}`)\n+\ttg.unsetenv(\"TERM\")\n+\ttg.run(\"test\", tg.path(\"test_test.go\"))\n+}\n+\n+func TestGoBuildOutput(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\n+\ttg.makeTempdir()\n+\ttg.cd(tg.path(\".\"))\n+\n+\tnonExeSuffix := \".exe\"\n+\tif exeSuffix == \".exe\" {\n+\t\tnonExeSuffix = \"\"\n+\t}\n+\n+\ttg.tempFile(\"x.go\", \"package main\\nfunc main(){}\\n\")\n+\ttg.run(\"build\", \"x.go\")\n+\ttg.wantExecutable(\"x\"+exeSuffix, \"go build x.go did not write x\"+exeSuffix)\n+\ttg.must(os.Remove(tg.path(\"x\" + exeSuffix)))\n+\ttg.mustNotExist(\"x\" + nonExeSuffix)\n+\n+\ttg.run(\"build\", \"-o\", \"myprog\", \"x.go\")\n+\ttg.mustNotExist(\"x\")\n+\ttg.mustNotExist(\"x.exe\")\n+\ttg.wantExecutable(\"myprog\", \"go build -o myprog x.go did not write myprog\")\n+\ttg.mustNotExist(\"myprog.exe\")\n+\n+\ttg.tempFile(\"p.go\", \"package p\\n\")\n+\ttg.run(\"build\", \"p.go\")\n+\ttg.mustNotExist(\"p\")\n+\ttg.mustNotExist(\"p.a\")\n+\ttg.mustNotExist(\"p.o\")\n+\ttg.mustNotExist(\"p.exe\")\n+\n+\ttg.run(\"build\", \"-o\", \"p.a\", \"p.go\")\n+\ttg.wantArchive(\"p.a\")\n+\n+\ttg.run(\"build\", \"cmd/gofmt\")\n+\ttg.wantExecutable(\"gofmt\"+exeSuffix, \"go build cmd/gofmt did not write gofmt\"+exeSuffix)\n+\ttg.must(os.Remove(tg.path(\"gofmt\" + exeSuffix)))\n+\ttg.mustNotExist(\"gofmt\" + nonExeSuffix)\n+\n+\ttg.run(\"build\", \"-o\", \"mygofmt\", \"cmd/gofmt\")\n+\ttg.wantExecutable(\"mygofmt\", \"go build -o mygofmt cmd/gofmt did not write mygofmt\")\n+\ttg.mustNotExist(\"mygofmt.exe\")\n+\ttg.mustNotExist(\"gofmt\")\n+\ttg.mustNotExist(\"gofmt.exe\")\n+\n+\ttg.run(\"build\", \"sync/atomic\")\n+\ttg.mustNotExist(\"atomic\")\n+\ttg.mustNotExist(\"atomic.exe\")\n+\n+\ttg.run(\"build\", \"-o\", \"myatomic.a\", \"sync/atomic\")\n+\ttg.wantArchive(\"myatomic.a\")\n+\ttg.mustNotExist(\"atomic\")\n+\ttg.mustNotExist(\"atomic.a\")\n+\ttg.mustNotExist(\"atomic.exe\")\n+\n+\ttg.runFail(\"build\", \"-o\", \"whatever\", \"cmd/gofmt\", \"sync/atomic\")\n+\ttg.grepStderr(\"multiple packages\", \"did not reject -o with multiple packages\")\n+}\n+\n+func TestGoBuildARM(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"skipping cross-compile in short mode\")\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\n+\ttg.makeTempdir()\n+\ttg.cd(tg.path(\".\"))\n+\n+\ttg.setenv(\"GOARCH\", \"arm\")\n+\ttg.setenv(\"GOOS\", \"linux\")\n+\ttg.setenv(\"GOARM\", \"5\")\n+\ttg.tempFile(\"hello.go\", `package main\n+\t\tfunc main() {}`)\n+\ttg.run(\"build\", \"hello.go\")\n+\ttg.grepStderrNot(\"unable to find math.a\", \"did not build math.a correctly\")\n+}"}, {"sha": "5dff2670f1b990471dee5a4338fee5e3ee9ab6a8", "filename": "libgo/go/cmd/go/help.go", "status": "modified", "additions": 229, "deletions": 17, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Fhelp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Fhelp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fhelp.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -11,7 +11,7 @@ var helpC = &Command{\n There are two different ways to call between Go and C/C++ code.\n \n The first is the cgo tool, which is part of the Go distribution.  For\n-information on how to use it see the cgo documentation (godoc cmd/cgo).\n+information on how to use it see the cgo documentation (go doc cmd/cgo).\n \n The second is the SWIG program, which is a general tool for\n interfacing between languages.  For information on SWIG see\n@@ -47,7 +47,7 @@ environment variable (see 'go help gopath').\n If no import paths are given, the action applies to the\n package in the current directory.\n \n-There are three reserved names for paths that should not be used\n+There are four reserved names for paths that should not be used\n for packages to be built with the go tool:\n \n - \"main\" denotes the top-level package in a stand-alone executable.\n@@ -59,6 +59,9 @@ system.\n - \"std\" is like all but expands to just the packages in the standard\n Go library.\n \n+- \"cmd\" expands to the Go repository's commands and their\n+internal libraries.\n+\n An import path is a pattern if it includes one or more \"...\" wildcards,\n each of which can match any string, including the empty string and\n strings containing slashes.  Such a pattern expands to all package\n@@ -74,7 +77,7 @@ By convention, this is arranged by starting each path with a\n unique prefix that belongs to you.  For example, paths used\n internally at Google all begin with 'google', and paths\n denoting remote repositories begin with the path to the code,\n-such as 'code.google.com/p/project'.\n+such as 'github.com/user/repo'.\n \n As a special case, if the package list is a list of .go files from a\n single directory, the command is applied to a single synthesized\n@@ -192,7 +195,7 @@ example.org/repo or repo.git.\n \n When a version control system supports multiple protocols,\n each is tried in turn when downloading.  For example, a Git\n-download tries git://, then https://, then http://.\n+download tries https://, then git+ssh://.\n \n If the import path is not a known code hosting site and also lacks a\n version control qualifier, the go tool attempts to fetch the import\n@@ -208,6 +211,10 @@ root. It must be a prefix or an exact match of the package being\n fetched with \"go get\". If it's not an exact match, another http\n request is made at the prefix to verify the <meta> tags match.\n \n+The meta tag should appear as early in the file as possible.\n+In particular, it should appear before any raw JavaScript or CSS,\n+to avoid confusing the go command's restricted parser.\n+\n The vcs is one of \"git\", \"hg\", \"svn\", etc,\n \n The repo-root is the root of the version control system\n@@ -217,10 +224,10 @@ For example,\n \n \timport \"example.org/pkg/foo\"\n \n-will result in the following request(s):\n+will result in the following requests:\n \n \thttps://example.org/pkg/foo?go-get=1 (preferred)\n-\thttp://example.org/pkg/foo?go-get=1  (fallback)\n+\thttp://example.org/pkg/foo?go-get=1  (fallback, only with -insecure)\n \n If that page contains the meta tag\n \n@@ -254,6 +261,11 @@ unless it is being referred to by that import path. In this way, import comments\n let package authors make sure the custom import path is used and not a\n direct path to the underlying code hosting site.\n \n+If the vendoring experiment is enabled (see 'go help gopath'),\n+then import path checking is disabled for code found within vendor trees.\n+This makes it possible to copy code into alternate locations in vendor trees\n+without needing to update import comments.\n+\n See https://golang.org/s/go14customimport for details.\n \t`,\n }\n@@ -275,10 +287,10 @@ standard Go tree.\n \n Each directory listed in GOPATH must have a prescribed structure:\n \n-The src/ directory holds source code.  The path below 'src'\n+The src directory holds source code.  The path below src\n determines the import path or executable name.\n \n-The pkg/ directory holds installed package objects.\n+The pkg directory holds installed package objects.\n As in the Go tree, each target operating system and\n architecture pair has its own subdirectory of pkg\n (pkg/GOOS_GOARCH).\n@@ -287,11 +299,11 @@ If DIR is a directory listed in the GOPATH, a package with\n source in DIR/src/foo/bar can be imported as \"foo/bar\" and\n has its compiled form installed to \"DIR/pkg/GOOS_GOARCH/foo/bar.a\".\n \n-The bin/ directory holds compiled commands.\n+The bin directory holds compiled commands.\n Each command is named for its source directory, but only\n the final element, not the entire path.  That is, the\n command with source in DIR/src/foo/quux is installed into\n-DIR/bin/quux, not DIR/bin/foo/quux.  The foo/ is stripped\n+DIR/bin/quux, not DIR/bin/foo/quux.  The \"foo/\" prefix is stripped\n so that you can add DIR/bin to your PATH to get at the\n installed commands.  If the GOBIN environment variable is\n set, commands are installed to the directory it names instead\n@@ -318,6 +330,168 @@ Here's an example directory layout:\n Go searches each directory listed in GOPATH to find source code,\n but new packages are always downloaded into the first directory\n in the list.\n+\n+See https://golang.org/doc/code.html for an example.\n+\n+Internal Directories\n+\n+Code in or below a directory named \"internal\" is importable only\n+by code in the directory tree rooted at the parent of \"internal\".\n+Here's an extended version of the directory layout above:\n+\n+    /home/user/gocode/\n+        src/\n+            crash/\n+                bang/              (go code in package bang)\n+                    b.go\n+            foo/                   (go code in package foo)\n+                f.go\n+                bar/               (go code in package bar)\n+                    x.go\n+                internal/\n+                    baz/           (go code in package baz)\n+                        z.go\n+                quux/              (go code in package main)\n+                    y.go\n+\n+\n+The code in z.go is imported as \"foo/internal/baz\", but that\n+import statement can only appear in source files in the subtree\n+rooted at foo. The source files foo/f.go, foo/bar/x.go, and\n+foo/quux/y.go can all import \"foo/internal/baz\", but the source file\n+crash/bang/b.go cannot.\n+\n+See https://golang.org/s/go14internal for details.\n+\n+Vendor Directories\n+\n+Go 1.5 includes experimental support for using local copies\n+of external dependencies to satisfy imports of those dependencies,\n+often referred to as vendoring. Setting the environment variable\n+GO15VENDOREXPERIMENT=1 enables that experimental support.\n+\n+When the vendor experiment is enabled,\n+code below a directory named \"vendor\" is importable only\n+by code in the directory tree rooted at the parent of \"vendor\",\n+and only using an import path that omits the prefix up to and\n+including the vendor element.\n+\n+Here's the example from the previous section,\n+but with the \"internal\" directory renamed to \"vendor\"\n+and a new foo/vendor/crash/bang directory added:\n+\n+    /home/user/gocode/\n+        src/\n+            crash/\n+                bang/              (go code in package bang)\n+                    b.go\n+            foo/                   (go code in package foo)\n+                f.go\n+                bar/               (go code in package bar)\n+                    x.go\n+                vendor/\n+                    crash/\n+                        bang/      (go code in package bang)\n+                            b.go\n+                    baz/           (go code in package baz)\n+                        z.go\n+                quux/              (go code in package main)\n+                    y.go\n+\n+The same visibility rules apply as for internal, but the code\n+in z.go is imported as \"baz\", not as \"foo/vendor/baz\".\n+\n+Code in vendor directories deeper in the source tree shadows\n+code in higher directories. Within the subtree rooted at foo, an import\n+of \"crash/bang\" resolves to \"foo/vendor/crash/bang\", not the\n+top-level \"crash/bang\".\n+\n+Code in vendor directories is not subject to import path\n+checking (see 'go help importpath').\n+\n+When the vendor experiment is enabled, 'go get' checks out\n+submodules when checking out or updating a git repository\n+(see 'go help get').\n+\n+The vendoring semantics are an experiment, and they may change\n+in future releases. Once settled, they will be on by default.\n+\n+See https://golang.org/s/go15vendor for details.\n+\t`,\n+}\n+\n+var helpEnvironment = &Command{\n+\tUsageLine: \"environment\",\n+\tShort:     \"environment variables\",\n+\tLong: `\n+\n+The go command, and the tools it invokes, examine a few different\n+environment variables. For many of these, you can see the default\n+value of on your system by running 'go env NAME', where NAME is the\n+name of the variable.\n+\n+General-purpose environment variables:\n+\n+\tGCCGO\n+\t\tThe gccgo command to run for 'go build -compiler=gccgo'.\n+\tGOARCH\n+\t\tThe architecture, or processor, for which to compile code.\n+\t\tExamples are amd64, 386, arm, ppc64.\n+\tGOBIN\n+\t\tThe directory where 'go install' will install a command.\n+\tGOOS\n+\t\tThe operating system for which to compile code.\n+\t\tExamples are linux, darwin, windows, netbsd.\n+\tGOPATH\n+\t\tSee 'go help gopath'.\n+\tGORACE\n+\t\tOptions for the race detector.\n+\t\tSee https://golang.org/doc/articles/race_detector.html.\n+\tGOROOT\n+\t\tThe root of the go tree.\n+\n+Environment variables for use with cgo:\n+\n+\tCC\n+\t\tThe command to use to compile C code.\n+\tCGO_ENABLED\n+\t\tWhether the cgo command is supported.  Either 0 or 1.\n+\tCGO_CFLAGS\n+\t\tFlags that cgo will pass to the compiler when compiling\n+\t\tC code.\n+\tCGO_CPPFLAGS\n+\t\tFlags that cgo will pass to the compiler when compiling\n+\t\tC or C++ code.\n+\tCGO_CXXFLAGS\n+\t\tFlags that cgo will pass to the compiler when compiling\n+\t\tC++ code.\n+\tCGO_LDFLAGS\n+\t\tFlags that cgo will pass to the compiler when linking.\n+\tCXX\n+\t\tThe command to use to compile C++ code.\n+\n+Architecture-specific environment variables:\n+\n+\tGOARM\n+\t\tFor GOARCH=arm, the ARM architecture for which to compile.\n+\t\tValid values are 5, 6, 7.\n+\tGO386\n+\t\tFor GOARCH=386, the floating point instruction set.\n+\t\tValid values are 387, sse2.\n+\n+Special-purpose environment variables:\n+\n+\tGOROOT_FINAL\n+\t\tThe root of the installed Go tree, when it is\n+\t\tinstalled in a location other than where it is built.\n+\t\tFile names in stack traces are rewritten from GOROOT to\n+\t\tGOROOT_FINAL.\n+\tGO15VENDOREXPERIMENT\n+\t\tSet to 1 to enable the Go 1.5 vendoring experiment.\n+\tGO_EXTLINK_ENABLED\n+\t\tWhether the linker should use external linking mode\n+\t\twhen using -linkmode=auto with code that uses cgo.\n+\t\tSet to 0 to disable external linking mode, 1 to enable it.\n \t`,\n }\n \n@@ -333,10 +507,9 @@ the extension of the file name. These extensions are:\n \t\tGo source files.\n \t.c, .h\n \t\tC source files.\n-\t\tIf the package uses cgo, these will be compiled with the\n-\t\tOS-native compiler (typically gcc); otherwise they will be\n-\t\tcompiled with the Go-specific support compiler,\n-\t\t5c, 6c, or 8c, etc. as appropriate.\n+\t\tIf the package uses cgo or SWIG, these will be compiled with the\n+\t\tOS-native compiler (typically gcc); otherwise they will\n+\t\ttrigger an error.\n \t.cc, .cpp, .cxx, .hh, .hpp, .hxx\n \t\tC++ source files. Only useful with cgo or SWIG, and always\n \t\tcompiled with the OS-native compiler.\n@@ -345,10 +518,9 @@ the extension of the file name. These extensions are:\n \t\tcompiled with the OS-native compiler.\n \t.s, .S\n \t\tAssembler source files.\n-\t\tIf the package uses cgo, these will be assembled with the\n+\t\tIf the package uses cgo or SWIG, these will be assembled with the\n \t\tOS-native assembler (typically gcc (sic)); otherwise they\n-\t\twill be assembled with the Go-specific support assembler,\n-\t\t5a, 6a, or 8a, etc., as appropriate.\n+\t\twill be assembled with the Go assembler.\n \t.swig, .swigcxx\n \t\tSWIG definition files.\n \t.syso\n@@ -360,3 +532,43 @@ at the first item in the file that is not a blank line or //-style\n line comment.\n \t`,\n }\n+\n+var helpBuildmode = &Command{\n+\tUsageLine: \"buildmode\",\n+\tShort:     \"description of build modes\",\n+\tLong: `\n+The 'go build' and 'go install' commands take a -buildmode argument which\n+indicates which kind of object file is to be built. Currently supported values\n+are:\n+\n+\t-buildmode=archive\n+\t\tBuild the listed non-main packages into .a files. Packages named\n+\t\tmain are ignored.\n+\n+\t-buildmode=c-archive\n+\t\tBuild the listed main package, plus all packages it imports,\n+\t\tinto a C archive file. The only callable symbols will be those\n+\t\tfunctions exported using a cgo //export comment. Requires\n+\t\texactly one main package to be listed.\n+\n+\t-buildmode=c-shared\n+\t\tBuild the listed main packages, plus all packages that they\n+\t\timport, into C shared libraries. The only callable symbols will\n+\t\tbe those functions exported using a cgo //export comment.\n+\t\tNon-main packages are ignored.\n+\n+\t-buildmode=default\n+\t\tListed main packages are built into executables and listed\n+\t\tnon-main packages are built into .a files (the default\n+\t\tbehavior).\n+\n+\t-buildmode=shared\n+\t\tCombine all the listed non-main packages into a single shared\n+\t\tlibrary that will be used when building with the -linkshared\n+\t\toption. Packages named main are ignored.\n+\n+\t-buildmode=exe\n+\t\tBuild the listed main packages and everything they import into\n+\t\texecutables. Packages not named main are ignored.\n+`,\n+}"}, {"sha": "7979c41b11bae8a59a68eb23d1f184009fd0aa4f", "filename": "libgo/go/cmd/go/http.go", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Fhttp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Fhttp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fhttp.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -18,11 +18,25 @@ import (\n \t\"log\"\n \t\"net/http\"\n \t\"net/url\"\n+\t\"time\"\n )\n \n // httpClient is the default HTTP client, but a variable so it can be\n // changed by tests, without modifying http.DefaultClient.\n var httpClient = http.DefaultClient\n+var impatientHTTPClient = &http.Client{\n+\tTimeout: time.Duration(5 * time.Second),\n+}\n+\n+type httpError struct {\n+\tstatus     string\n+\tstatusCode int\n+\turl        string\n+}\n+\n+func (e *httpError) Error() string {\n+\treturn fmt.Sprintf(\"%s: %s\", e.url, e.status)\n+}\n \n // httpGET returns the data from an HTTP GET request for the given URL.\n func httpGET(url string) ([]byte, error) {\n@@ -32,7 +46,9 @@ func httpGET(url string) ([]byte, error) {\n \t}\n \tdefer resp.Body.Close()\n \tif resp.StatusCode != 200 {\n-\t\treturn nil, fmt.Errorf(\"%s: %s\", url, resp.Status)\n+\t\terr := &httpError{status: resp.Status, statusCode: resp.StatusCode, url: url}\n+\n+\t\treturn nil, err\n \t}\n \tb, err := ioutil.ReadAll(resp.Body)\n \tif err != nil {\n@@ -43,7 +59,7 @@ func httpGET(url string) ([]byte, error) {\n \n // httpsOrHTTP returns the body of either the importPath's\n // https resource or, if unavailable, the http resource.\n-func httpsOrHTTP(importPath string) (urlStr string, body io.ReadCloser, err error) {\n+func httpsOrHTTP(importPath string, security securityMode) (urlStr string, body io.ReadCloser, err error) {\n \tfetch := func(scheme string) (urlStr string, res *http.Response, err error) {\n \t\tu, err := url.Parse(scheme + \"://\" + importPath)\n \t\tif err != nil {\n@@ -54,7 +70,11 @@ func httpsOrHTTP(importPath string) (urlStr string, body io.ReadCloser, err erro\n \t\tif buildV {\n \t\t\tlog.Printf(\"Fetching %s\", urlStr)\n \t\t}\n-\t\tres, err = httpClient.Get(urlStr)\n+\t\tif security == insecure && scheme == \"https\" { // fail earlier\n+\t\t\tres, err = impatientHTTPClient.Get(urlStr)\n+\t\t} else {\n+\t\t\tres, err = httpClient.Get(urlStr)\n+\t\t}\n \t\treturn\n \t}\n \tcloseBody := func(res *http.Response) {\n@@ -72,7 +92,9 @@ func httpsOrHTTP(importPath string) (urlStr string, body io.ReadCloser, err erro\n \t\t\t}\n \t\t}\n \t\tcloseBody(res)\n-\t\turlStr, res, err = fetch(\"http\")\n+\t\tif security == insecure {\n+\t\t\turlStr, res, err = fetch(\"http\")\n+\t\t}\n \t}\n \tif err != nil {\n \t\tcloseBody(res)"}, {"sha": "35c7cc4f2a73a8168570695625c88f6a2b56700e", "filename": "libgo/go/cmd/go/list.go", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Flist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Flist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Flist.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -21,9 +21,10 @@ List lists the packages named by the import paths, one per line.\n \n The default output shows the package import path:\n \n-    code.google.com/p/google-api-go-client/books/v1\n-    code.google.com/p/goauth2/oauth\n-    code.google.com/p/sqlite\n+    bytes\n+    encoding/json\n+    github.com/gorilla/mux\n+    golang.org/x/net/html\n \n The -f flag specifies an alternate format for the list, using the\n syntax of package template.  The default output is equivalent to -f\n@@ -36,6 +37,7 @@ syntax of package template.  The default output is equivalent to -f\n         Name          string // package name\n         Doc           string // package documentation string\n         Target        string // install path\n+        Shlib         string // the shared library that contains this package (only set when -linkshared)\n         Goroot        bool   // is this package in the Go root?\n         Standard      bool   // is this package part of the standard Go library?\n         Stale         bool   // would 'go install' do anything for this package?\n@@ -126,6 +128,7 @@ var listJson = cmdList.Flag.Bool(\"json\", false, \"\")\n var nl = []byte{'\\n'}\n \n func runList(cmd *Command, args []string) {\n+\tbuildModeInit()\n \tout := newTrackingWriter(os.Stdout)\n \tdefer out.w.Flush()\n \n@@ -173,6 +176,10 @@ func runList(cmd *Command, args []string) {\n \t}\n \n \tfor _, pkg := range load(args) {\n+\t\t// Show vendor-expanded paths in listing\n+\t\tpkg.TestImports = pkg.vendored(pkg.TestImports)\n+\t\tpkg.XTestImports = pkg.vendored(pkg.XTestImports)\n+\n \t\tdo(pkg)\n \t}\n }"}, {"sha": "8ebde8925990dc5a4ad1f19a7da298d20302fd8b", "filename": "libgo/go/cmd/go/main.go", "status": "modified", "additions": 93, "deletions": 55, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -5,6 +5,7 @@\n package main\n \n import (\n+\t\"bufio\"\n \t\"bytes\"\n \t\"flag\"\n \t\"fmt\"\n@@ -76,6 +77,7 @@ func (c *Command) Runnable() bool {\n var commands = []*Command{\n \tcmdBuild,\n \tcmdClean,\n+\tcmdDoc,\n \tcmdEnv,\n \tcmdFix,\n \tcmdFmt,\n@@ -90,8 +92,10 @@ var commands = []*Command{\n \tcmdVet,\n \n \thelpC,\n+\thelpBuildmode,\n \thelpFileType,\n \thelpGopath,\n+\thelpEnvironment,\n \thelpImportPath,\n \thelpPackages,\n \thelpTestflag,\n@@ -109,6 +113,8 @@ func setExitStatus(n int) {\n \texitMu.Unlock()\n }\n \n+var origEnv []string\n+\n func main() {\n \t_ = go11tag\n \tflag.Usage = usage\n@@ -139,7 +145,7 @@ func main() {\n \t\t\t\tfmt.Fprintf(os.Stderr, \"go: GOPATH entry cannot start with shell metacharacter '~': %q\\n\", p)\n \t\t\t\tos.Exit(2)\n \t\t\t}\n-\t\t\tif build.IsLocalImport(p) {\n+\t\t\tif !filepath.IsAbs(p) {\n \t\t\t\tfmt.Fprintf(os.Stderr, \"go: GOPATH entry is relative; must be absolute path: %q.\\nRun 'go help gopath' for usage.\\n\", p)\n \t\t\t\tos.Exit(2)\n \t\t\t}\n@@ -151,8 +157,20 @@ func main() {\n \t\tos.Exit(2)\n \t}\n \n+\t// Set environment (GOOS, GOARCH, etc) explicitly.\n+\t// In theory all the commands we invoke should have\n+\t// the same default computation of these as we do,\n+\t// but in practice there might be skew\n+\t// This makes sure we all agree.\n+\torigEnv = os.Environ()\n+\tfor _, env := range mkEnv() {\n+\t\tif os.Getenv(env.name) != env.value {\n+\t\t\tos.Setenv(env.name, env.value)\n+\t\t}\n+\t}\n+\n \tfor _, cmd := range commands {\n-\t\tif cmd.Name() == args[0] && cmd.Run != nil {\n+\t\tif cmd.Name() == args[0] && cmd.Runnable() {\n \t\t\tcmd.Flag.Usage = func() { cmd.Usage() }\n \t\t\tif cmd.CustomFlags {\n \t\t\t\targs = args[1:]\n@@ -179,13 +197,13 @@ Usage:\n \n The commands are:\n {{range .}}{{if .Runnable}}\n-    {{.Name | printf \"%-11s\"}} {{.Short}}{{end}}{{end}}\n+\t{{.Name | printf \"%-11s\"}} {{.Short}}{{end}}{{end}}\n \n Use \"go help [command]\" for more information about a command.\n \n Additional help topics:\n {{range .}}{{if not .Runnable}}\n-    {{.Name | printf \"%-11s\"}} {{.Short}}{{end}}{{end}}\n+\t{{.Name | printf \"%-11s\"}} {{.Short}}{{end}}{{end}}\n \n Use \"go help [topic]\" for more information about that topic.\n \n@@ -200,8 +218,8 @@ var documentationTemplate = `// Copyright 2011 The Go Authors.  All rights reser\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// DO NOT EDIT THIS FILE. GENERATED BY mkdoc.sh.\n-// Edit the documentation in other files and rerun mkdoc.sh to generate this one.\n+// DO NOT EDIT THIS FILE. GENERATED BY mkalldocs.sh.\n+// Edit the documentation in other files and rerun mkalldocs.sh to generate this one.\n \n /*\n {{range .}}{{if .Short}}{{.Short | capitalize}}\n@@ -217,12 +235,35 @@ var documentationTemplate = `// Copyright 2011 The Go Authors.  All rights reser\n package main\n `\n \n+// An errWriter wraps a writer, recording whether a write error occurred.\n+type errWriter struct {\n+\tw   io.Writer\n+\terr error\n+}\n+\n+func (w *errWriter) Write(b []byte) (int, error) {\n+\tn, err := w.w.Write(b)\n+\tif err != nil {\n+\t\tw.err = err\n+\t}\n+\treturn n, err\n+}\n+\n // tmpl executes the given template text on data, writing the result to w.\n func tmpl(w io.Writer, text string, data interface{}) {\n \tt := template.New(\"top\")\n \tt.Funcs(template.FuncMap{\"trim\": strings.TrimSpace, \"capitalize\": capitalize})\n \ttemplate.Must(t.Parse(text))\n-\tif err := t.Execute(w, data); err != nil {\n+\tew := &errWriter{w: w}\n+\terr := t.Execute(ew, data)\n+\tif ew.err != nil {\n+\t\t// I/O error writing. Ignore write on closed pipe.\n+\t\tif strings.Contains(ew.err.Error(), \"pipe\") {\n+\t\t\tos.Exit(1)\n+\t\t}\n+\t\tfatalf(\"writing output: %v\", ew.err)\n+\t}\n+\tif err != nil {\n \t\tpanic(err)\n \t}\n }\n@@ -236,13 +277,17 @@ func capitalize(s string) string {\n }\n \n func printUsage(w io.Writer) {\n-\ttmpl(w, usageTemplate, commands)\n+\tbw := bufio.NewWriter(w)\n+\ttmpl(bw, usageTemplate, commands)\n+\tbw.Flush()\n }\n \n func usage() {\n \t// special case \"go test -h\"\n \tif len(os.Args) > 1 && os.Args[1] == \"test\" {\n-\t\thelp([]string{\"testflag\"})\n+\t\tos.Stdout.WriteString(testUsage + \"\\n\\n\" +\n+\t\t\tstrings.TrimSpace(testFlag1) + \"\\n\\n\" +\n+\t\t\tstrings.TrimSpace(testFlag2) + \"\\n\")\n \t\tos.Exit(2)\n \t}\n \tprintUsage(os.Stderr)\n@@ -308,7 +353,7 @@ func importPathsNoDotExpansion(args []string) []string {\n \t\t} else {\n \t\t\ta = path.Clean(a)\n \t\t}\n-\t\tif a == \"all\" || a == \"std\" {\n+\t\tif a == \"all\" || a == \"std\" || a == \"cmd\" {\n \t\t\tout = append(out, allPackages(a)...)\n \t\t\tcontinue\n \t\t}\n@@ -401,11 +446,10 @@ func runOut(dir string, cmdargs ...interface{}) []byte {\n // The environment is the current process's environment\n // but with an updated $PWD, so that an os.Getwd in the\n // child will be faster.\n-func envForDir(dir string) []string {\n-\tenv := os.Environ()\n+func envForDir(dir string, base []string) []string {\n \t// Internally we only use rooted paths, so dir is rooted.\n \t// Even if dir is not rooted, no harm done.\n-\treturn mergeEnvLists([]string{\"PWD=\" + dir}, env)\n+\treturn mergeEnvLists([]string{\"PWD=\" + dir}, base)\n }\n \n // mergeEnvLists merges the two environment lists such that\n@@ -458,6 +502,28 @@ func hasPathPrefix(s, prefix string) bool {\n \t}\n }\n \n+// hasFilePathPrefix reports whether the filesystem path s begins with the\n+// elements in prefix.\n+func hasFilePathPrefix(s, prefix string) bool {\n+\tsv := strings.ToUpper(filepath.VolumeName(s))\n+\tpv := strings.ToUpper(filepath.VolumeName(prefix))\n+\ts = s[len(sv):]\n+\tprefix = prefix[len(pv):]\n+\tswitch {\n+\tdefault:\n+\t\treturn false\n+\tcase sv != pv:\n+\t\treturn false\n+\tcase len(s) == len(prefix):\n+\t\treturn s == prefix\n+\tcase len(s) > len(prefix):\n+\t\tif prefix != \"\" && prefix[len(prefix)-1] == filepath.Separator {\n+\t\t\treturn strings.HasPrefix(s, prefix)\n+\t\t}\n+\t\treturn s[len(prefix)] == filepath.Separator && s[:len(prefix)] == prefix\n+\t}\n+}\n+\n // treeCanMatchPattern(pattern)(name) reports whether\n // name or children of name can possibly match pattern.\n // Pattern is the same limited glob accepted by matchPattern.\n@@ -475,8 +541,8 @@ func treeCanMatchPattern(pattern string) func(name string) bool {\n \n // allPackages returns all the packages that can be found\n // under the $GOPATH directories and $GOROOT matching pattern.\n-// The pattern is either \"all\" (all packages), \"std\" (standard packages)\n-// or a path including \"...\".\n+// The pattern is either \"all\" (all packages), \"std\" (standard packages),\n+// \"cmd\" (standard commands), or a path including \"...\".\n func allPackages(pattern string) []string {\n \tpkgs := matchPackages(pattern)\n \tif len(pkgs) == 0 {\n@@ -488,7 +554,7 @@ func allPackages(pattern string) []string {\n func matchPackages(pattern string) []string {\n \tmatch := func(string) bool { return true }\n \ttreeCanMatch := func(string) bool { return true }\n-\tif pattern != \"all\" && pattern != \"std\" {\n+\tif pattern != \"all\" && pattern != \"std\" && pattern != \"cmd\" {\n \t\tmatch = matchPattern(pattern)\n \t\ttreeCanMatch = treeCanMatchPattern(pattern)\n \t}\n@@ -501,47 +567,16 @@ func matchPackages(pattern string) []string {\n \t}\n \tvar pkgs []string\n \n-\t// Commands\n-\tcmd := filepath.Join(goroot, \"src/cmd\") + string(filepath.Separator)\n-\tfilepath.Walk(cmd, func(path string, fi os.FileInfo, err error) error {\n-\t\tif err != nil || !fi.IsDir() || path == cmd {\n-\t\t\treturn nil\n-\t\t}\n-\t\tname := path[len(cmd):]\n-\t\tif !treeCanMatch(name) {\n-\t\t\treturn filepath.SkipDir\n-\t\t}\n-\t\t// Commands are all in cmd/, not in subdirectories.\n-\t\tif strings.Contains(name, string(filepath.Separator)) {\n-\t\t\treturn filepath.SkipDir\n-\t\t}\n-\n-\t\t// We use, e.g., cmd/gofmt as the pseudo import path for gofmt.\n-\t\tname = \"cmd/\" + name\n-\t\tif have[name] {\n-\t\t\treturn nil\n-\t\t}\n-\t\thave[name] = true\n-\t\tif !match(name) {\n-\t\t\treturn nil\n-\t\t}\n-\t\t_, err = buildContext.ImportDir(path, 0)\n-\t\tif err != nil {\n-\t\t\tif _, noGo := err.(*build.NoGoError); !noGo {\n-\t\t\t\tlog.Print(err)\n-\t\t\t}\n-\t\t\treturn nil\n-\t\t}\n-\t\tpkgs = append(pkgs, name)\n-\t\treturn nil\n-\t})\n-\n \tfor _, src := range buildContext.SrcDirs() {\n-\t\tif pattern == \"std\" && src != gorootSrc {\n+\t\tif (pattern == \"std\" || pattern == \"cmd\") && src != gorootSrc {\n \t\t\tcontinue\n \t\t}\n \t\tsrc = filepath.Clean(src) + string(filepath.Separator)\n-\t\tfilepath.Walk(src, func(path string, fi os.FileInfo, err error) error {\n+\t\troot := src\n+\t\tif pattern == \"cmd\" {\n+\t\t\troot += \"cmd\" + string(filepath.Separator)\n+\t\t}\n+\t\tfilepath.Walk(root, func(path string, fi os.FileInfo, err error) error {\n \t\t\tif err != nil || !fi.IsDir() || path == src {\n \t\t\t\treturn nil\n \t\t\t}\n@@ -553,7 +588,10 @@ func matchPackages(pattern string) []string {\n \t\t\t}\n \n \t\t\tname := filepath.ToSlash(path[len(src):])\n-\t\t\tif pattern == \"std\" && strings.Contains(name, \".\") {\n+\t\t\tif pattern == \"std\" && (strings.Contains(name, \".\") || name == \"cmd\") {\n+\t\t\t\t// The name \"std\" is only the standard library.\n+\t\t\t\t// If the name has a dot, assume it's a domain name for go get,\n+\t\t\t\t// and if the name is cmd, it's the root of the command tree.\n \t\t\t\treturn filepath.SkipDir\n \t\t\t}\n \t\t\tif !treeCanMatch(name) {\n@@ -659,7 +697,7 @@ func stringList(args ...interface{}) []string {\n \t\tcase string:\n \t\t\tx = append(x, arg)\n \t\tdefault:\n-\t\t\tpanic(\"stringList: invalid argument\")\n+\t\t\tpanic(\"stringList: invalid argument of type \" + fmt.Sprintf(\"%T\", arg))\n \t\t}\n \t}\n \treturn x"}, {"sha": "97e18651e4acca486f3ab3383ab07b1ad872c433", "filename": "libgo/go/cmd/go/note.go", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Fnote.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Fnote.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fnote.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -0,0 +1,116 @@\n+// Copyright 2015 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"bytes\"\n+\t\"debug/elf\"\n+\t\"encoding/binary\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+)\n+\n+func readAligned4(r io.Reader, sz int32) ([]byte, error) {\n+\tfull := (sz + 3) &^ 3\n+\tdata := make([]byte, full)\n+\t_, err := io.ReadFull(r, data)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdata = data[:sz]\n+\treturn data, nil\n+}\n+\n+func readELFNote(filename, name string, typ int32) ([]byte, error) {\n+\tf, err := elf.Open(filename)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tfor _, sect := range f.Sections {\n+\t\tif sect.Type != elf.SHT_NOTE {\n+\t\t\tcontinue\n+\t\t}\n+\t\tr := sect.Open()\n+\t\tfor {\n+\t\t\tvar namesize, descsize, noteType int32\n+\t\t\terr = binary.Read(r, f.ByteOrder, &namesize)\n+\t\t\tif err != nil {\n+\t\t\t\tif err == io.EOF {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\treturn nil, fmt.Errorf(\"read namesize failed: %v\", err)\n+\t\t\t}\n+\t\t\terr = binary.Read(r, f.ByteOrder, &descsize)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, fmt.Errorf(\"read descsize failed: %v\", err)\n+\t\t\t}\n+\t\t\terr = binary.Read(r, f.ByteOrder, &noteType)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, fmt.Errorf(\"read type failed: %v\", err)\n+\t\t\t}\n+\t\t\tnoteName, err := readAligned4(r, namesize)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, fmt.Errorf(\"read name failed: %v\", err)\n+\t\t\t}\n+\t\t\tdesc, err := readAligned4(r, descsize)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, fmt.Errorf(\"read desc failed: %v\", err)\n+\t\t\t}\n+\t\t\tif name == string(noteName) && typ == noteType {\n+\t\t\t\treturn desc, nil\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn nil, nil\n+}\n+\n+var elfGoNote = []byte(\"Go\\x00\\x00\")\n+\n+// readELFGoBuildID the Go build ID string from an ELF binary.\n+// The Go build ID is stored in a note described by an ELF PT_NOTE prog header.\n+// The caller has already opened filename, to get f, and read the first 4 kB out, in data.\n+func readELFGoBuildID(filename string, f *os.File, data []byte) (buildid string, err error) {\n+\t// Assume the note content is in the first 4 kB, already read.\n+\t// Rewrite the ELF header to set shnum to 0, so that we can pass\n+\t// the data to elf.NewFile and it will decode the Prog list but not\n+\t// try to read the section headers and the string table from disk.\n+\t// That's a waste of I/O when all we care about is the Prog list\n+\t// and the one ELF note.\n+\tswitch elf.Class(data[elf.EI_CLASS]) {\n+\tcase elf.ELFCLASS32:\n+\t\tdata[48] = 0\n+\t\tdata[49] = 0\n+\tcase elf.ELFCLASS64:\n+\t\tdata[60] = 0\n+\t\tdata[61] = 0\n+\t}\n+\n+\tconst elfGoBuildIDTag = 4\n+\n+\tef, err := elf.NewFile(bytes.NewReader(data))\n+\tif err != nil {\n+\t\treturn \"\", &os.PathError{Path: filename, Op: \"parse\", Err: err}\n+\t}\n+\tfor _, p := range ef.Progs {\n+\t\tif p.Type != elf.PT_NOTE || p.Off >= uint64(len(data)) || p.Off+p.Filesz >= uint64(len(data)) || p.Filesz < 16 {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tnote := data[p.Off : p.Off+p.Filesz]\n+\t\tnameSize := ef.ByteOrder.Uint32(note)\n+\t\tvalSize := ef.ByteOrder.Uint32(note[4:])\n+\t\ttag := ef.ByteOrder.Uint32(note[8:])\n+\t\tname := note[12:16]\n+\t\tif nameSize != 4 || 16+valSize > uint32(len(note)) || tag != elfGoBuildIDTag || !bytes.Equal(name, elfGoNote) {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\treturn string(note[16 : 16+valSize]), nil\n+\t}\n+\n+\t// No note. Treat as successful but build ID empty.\n+\treturn \"\", nil\n+}"}, {"sha": "3d644518c6897de348b57f8928f1b2e06b139769", "filename": "libgo/go/cmd/go/note_test.go", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Fnote_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Fnote_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fnote_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2015 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main_test\n+\n+import (\n+\tmain \"cmd/go\"\n+\t\"runtime\"\n+\t\"testing\"\n+)\n+\n+func TestNoteReading(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.tempFile(\"hello.go\", `package main; func main() { print(\"hello, world\\n\") }`)\n+\tconst buildID = \"TestNoteReading-Build-ID\"\n+\ttg.run(\"build\", \"-ldflags\", \"-buildid=\"+buildID, \"-o\", tg.path(\"hello.exe\"), tg.path(\"hello.go\"))\n+\tid, err := main.ReadBuildIDFromBinary(tg.path(\"hello.exe\"))\n+\tif err != nil {\n+\t\tt.Fatalf(\"reading build ID from hello binary: %v\", err)\n+\t}\n+\tif id != buildID {\n+\t\tt.Fatalf(\"buildID in hello binary = %q, want %q\", id, buildID)\n+\t}\n+\n+\tif runtime.GOOS == \"linux\" && runtime.GOARCH == \"ppc64le\" {\n+\t\tt.Skipf(\"skipping - golang.org/issue/11184\")\n+\t}\n+\n+\tswitch runtime.GOOS {\n+\tcase \"plan9\":\n+\t\t// no external linking\n+\t\tt.Logf(\"no external linking - skipping linkmode=external test\")\n+\n+\tcase \"solaris\":\n+\t\tt.Logf(\"skipping - golang.org/issue/12178\")\n+\n+\tdefault:\n+\t\ttg.run(\"build\", \"-ldflags\", \"-buildid=\"+buildID+\" -linkmode=external\", \"-o\", tg.path(\"hello.exe\"), tg.path(\"hello.go\"))\n+\t\tid, err := main.ReadBuildIDFromBinary(tg.path(\"hello.exe\"))\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"reading build ID from hello binary (linkmode=external): %v\", err)\n+\t\t}\n+\t\tif id != buildID {\n+\t\t\tt.Fatalf(\"buildID in hello binary = %q, want %q (linkmode=external)\", id, buildID)\n+\t\t}\n+\t}\n+}"}, {"sha": "1af59b3760a9bb2c312ba99d6d136b9a3ea2e631", "filename": "libgo/go/cmd/go/pkg.go", "status": "modified", "additions": 942, "deletions": 55, "changes": 997, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Fpkg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Fpkg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fpkg.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -6,18 +6,21 @@ package main\n \n import (\n \t\"bytes\"\n+\t\"crypto/sha1\"\n \t\"errors\"\n \t\"fmt\"\n \t\"go/build\"\n \t\"go/scanner\"\n \t\"go/token\"\n+\t\"io\"\n+\t\"io/ioutil\"\n \t\"os\"\n \tpathpkg \"path\"\n \t\"path/filepath\"\n \t\"runtime\"\n \t\"sort\"\n+\t\"strconv\"\n \t\"strings\"\n-\t\"time\"\n \t\"unicode\"\n )\n \n@@ -32,6 +35,7 @@ type Package struct {\n \tName          string `json:\",omitempty\"` // package name\n \tDoc           string `json:\",omitempty\"` // package documentation string\n \tTarget        string `json:\",omitempty\"` // install path\n+\tShlib         string `json:\",omitempty\"` // the shared library that contains this package (only set when -linkshared)\n \tGoroot        bool   `json:\",omitempty\"` // is this package found in the Go root?\n \tStandard      bool   `json:\",omitempty\"` // is this package part of the standard Go library?\n \tStale         bool   `json:\",omitempty\"` // would 'go install' do anything for this package?\n@@ -93,6 +97,35 @@ type Package struct {\n \tcoverMode    string               // preprocess Go source files with the coverage tool in this mode\n \tcoverVars    map[string]*CoverVar // variables created by coverage analysis\n \tomitDWARF    bool                 // tell linker not to write DWARF information\n+\tbuildID      string               // expected build ID for generated package\n+\tgobinSubdir  bool                 // install target would be subdir of GOBIN\n+}\n+\n+// vendored returns the vendor-resolved version of imports,\n+// which should be p.TestImports or p.XTestImports, NOT p.Imports.\n+// The imports in p.TestImports and p.XTestImports are not recursively\n+// loaded during the initial load of p, so they list the imports found in\n+// the source file, but most processing should be over the vendor-resolved\n+// import paths. We do this resolution lazily both to avoid file system work\n+// and because the eventual real load of the test imports (during 'go test')\n+// can produce better error messages if it starts with the original paths.\n+// The initial load of p loads all the non-test imports and rewrites\n+// the vendored paths, so nothing should ever call p.vendored(p.Imports).\n+func (p *Package) vendored(imports []string) []string {\n+\tif len(imports) > 0 && len(p.Imports) > 0 && &imports[0] == &p.Imports[0] {\n+\t\tpanic(\"internal error: p.vendored(p.Imports) called\")\n+\t}\n+\tseen := make(map[string]bool)\n+\tvar all []string\n+\tfor _, path := range imports {\n+\t\tpath, _ = vendoredImportPath(p, path)\n+\t\tif !seen[path] {\n+\t\t\tseen[path] = true\n+\t\t\tall = append(all, path)\n+\t\t}\n+\t}\n+\tsort.Strings(all)\n+\treturn all\n }\n \n // CoverVar holds the name of the generated coverage variables targeting the named file.\n@@ -104,6 +137,13 @@ type CoverVar struct {\n func (p *Package) copyBuild(pp *build.Package) {\n \tp.build = pp\n \n+\tif pp.PkgTargetRoot != \"\" && buildPkgdir != \"\" {\n+\t\told := pp.PkgTargetRoot\n+\t\tpp.PkgRoot = buildPkgdir\n+\t\tpp.PkgTargetRoot = buildPkgdir\n+\t\tpp.PkgObj = filepath.Join(buildPkgdir, strings.TrimPrefix(pp.PkgObj, old))\n+\t}\n+\n \tp.Dir = pp.Dir\n \tp.ImportPath = pp.ImportPath\n \tp.ImportComment = pp.ImportComment\n@@ -181,7 +221,7 @@ func (s *importStack) copy() []string {\n \treturn append([]string{}, *s...)\n }\n \n-// shorterThan returns true if sp is shorter than t.\n+// shorterThan reports whether sp is shorter than t.\n // We use this to record the shortest import sequence\n // that leads to a particular package.\n func (sp *importStack) shorterThan(t []string) bool {\n@@ -214,6 +254,12 @@ func reloadPackage(arg string, stk *importStack) *Package {\n \treturn loadPackage(arg, stk)\n }\n \n+// The Go 1.5 vendoring experiment is enabled by setting GO15VENDOREXPERIMENT=1.\n+// The variable is obnoxiously long so that years from now when people find it in\n+// their profiles and wonder what it does, there is some chance that a web search\n+// might answer the question.\n+var go15VendorExperiment = os.Getenv(\"GO15VENDOREXPERIMENT\") == \"1\"\n+\n // dirToImportPath returns the pseudo-import path we use for a package\n // outside the Go path.  It begins with _/ and then contains the full path\n // to the directory.  If the package lives in c:\\home\\gopher\\my\\pkg then\n@@ -234,27 +280,57 @@ func makeImportValid(r rune) rune {\n \treturn r\n }\n \n+// Mode flags for loadImport and download (in get.go).\n+const (\n+\t// useVendor means that loadImport should do vendor expansion\n+\t// (provided the vendoring experiment is enabled).\n+\t// That is, useVendor means that the import path came from\n+\t// a source file and has not been vendor-expanded yet.\n+\t// Every import path should be loaded initially with useVendor,\n+\t// and then the expanded version (with the /vendor/ in it) gets\n+\t// recorded as the canonical import path. At that point, future loads\n+\t// of that package must not pass useVendor, because\n+\t// disallowVendor will reject direct use of paths containing /vendor/.\n+\tuseVendor = 1 << iota\n+\n+\t// getTestDeps is for download (part of \"go get\") and indicates\n+\t// that test dependencies should be fetched too.\n+\tgetTestDeps\n+)\n+\n // loadImport scans the directory named by path, which must be an import path,\n // but possibly a local import path (an absolute file system path or one beginning\n // with ./ or ../).  A local relative path is interpreted relative to srcDir.\n // It returns a *Package describing the package found in that directory.\n-func loadImport(path string, srcDir string, stk *importStack, importPos []token.Position) *Package {\n+func loadImport(path, srcDir string, parent *Package, stk *importStack, importPos []token.Position, mode int) *Package {\n \tstk.push(path)\n \tdefer stk.pop()\n \n \t// Determine canonical identifier for this package.\n \t// For a local import the identifier is the pseudo-import path\n \t// we create from the full directory to the package.\n \t// Otherwise it is the usual import path.\n+\t// For vendored imports, it is the expanded form.\n \timportPath := path\n+\torigPath := path\n \tisLocal := build.IsLocalImport(path)\n+\tvar vendorSearch []string\n \tif isLocal {\n \t\timportPath = dirToImportPath(filepath.Join(srcDir, path))\n+\t} else if mode&useVendor != 0 {\n+\t\tpath, vendorSearch = vendoredImportPath(parent, path)\n+\t\timportPath = path\n \t}\n+\n \tif p := packageCache[importPath]; p != nil {\n \t\tif perr := disallowInternal(srcDir, p, stk); perr != p {\n \t\t\treturn perr\n \t\t}\n+\t\tif mode&useVendor != 0 {\n+\t\t\tif perr := disallowVendor(srcDir, origPath, p, stk); perr != p {\n+\t\t\t\treturn perr\n+\t\t\t}\n+\t\t}\n \t\treturn reusePackage(p, stk)\n \t}\n \n@@ -270,11 +346,33 @@ func loadImport(path string, srcDir string, stk *importStack, importPos []token.\n \t// TODO: After Go 1, decide when to pass build.AllowBinary here.\n \t// See issue 3268 for mistakes to avoid.\n \tbp, err := buildContext.Import(path, srcDir, build.ImportComment)\n+\n+\t// If we got an error from go/build about package not found,\n+\t// it contains the directories from $GOROOT and $GOPATH that\n+\t// were searched. Add to that message the vendor directories\n+\t// that were searched.\n+\tif err != nil && len(vendorSearch) > 0 {\n+\t\t// NOTE(rsc): The direct text manipulation here is fairly awful,\n+\t\t// but it avoids defining new go/build API (an exported error type)\n+\t\t// late in the Go 1.5 release cycle. If this turns out to be a more general\n+\t\t// problem we could define a real error type when the decision can be\n+\t\t// considered more carefully.\n+\t\ttext := err.Error()\n+\t\tif strings.Contains(text, \"cannot find package \\\"\") && strings.Contains(text, \"\\\" in any of:\\n\\t\") {\n+\t\t\told := strings.SplitAfter(text, \"\\n\")\n+\t\t\tlines := []string{old[0]}\n+\t\t\tfor _, dir := range vendorSearch {\n+\t\t\t\tlines = append(lines, \"\\t\"+dir+\" (vendor tree)\\n\")\n+\t\t\t}\n+\t\t\tlines = append(lines, old[1:]...)\n+\t\t\terr = errors.New(strings.Join(lines, \"\"))\n+\t\t}\n+\t}\n \tbp.ImportPath = importPath\n \tif gobin != \"\" {\n \t\tbp.BinDir = gobin\n \t}\n-\tif err == nil && !isLocal && bp.ImportComment != \"\" && bp.ImportComment != path {\n+\tif err == nil && !isLocal && bp.ImportComment != \"\" && bp.ImportComment != path && (!go15VendorExperiment || !strings.Contains(path, \"/vendor/\")) {\n \t\terr = fmt.Errorf(\"code in directory %s expects import %q\", bp.Dir, bp.ImportComment)\n \t}\n \tp.load(stk, bp, err)\n@@ -287,10 +385,83 @@ func loadImport(path string, srcDir string, stk *importStack, importPos []token.\n \tif perr := disallowInternal(srcDir, p, stk); perr != p {\n \t\treturn perr\n \t}\n+\tif mode&useVendor != 0 {\n+\t\tif perr := disallowVendor(srcDir, origPath, p, stk); perr != p {\n+\t\t\treturn perr\n+\t\t}\n+\t}\n \n \treturn p\n }\n \n+var isDirCache = map[string]bool{}\n+\n+func isDir(path string) bool {\n+\tresult, ok := isDirCache[path]\n+\tif ok {\n+\t\treturn result\n+\t}\n+\n+\tfi, err := os.Stat(path)\n+\tresult = err == nil && fi.IsDir()\n+\tisDirCache[path] = result\n+\treturn result\n+}\n+\n+// vendoredImportPath returns the expansion of path when it appears in parent.\n+// If parent is x/y/z, then path might expand to x/y/z/vendor/path, x/y/vendor/path,\n+// x/vendor/path, vendor/path, or else stay x/y/z if none of those exist.\n+// vendoredImportPath returns the expanded path or, if no expansion is found, the original.\n+// If no expansion is found, vendoredImportPath also returns a list of vendor directories\n+// it searched along the way, to help prepare a useful error message should path turn\n+// out not to exist.\n+func vendoredImportPath(parent *Package, path string) (found string, searched []string) {\n+\tif parent == nil || parent.Root == \"\" || !go15VendorExperiment {\n+\t\treturn path, nil\n+\t}\n+\tdir := filepath.Clean(parent.Dir)\n+\troot := filepath.Join(parent.Root, \"src\")\n+\tif !hasFilePathPrefix(dir, root) || len(dir) <= len(root) || dir[len(root)] != filepath.Separator {\n+\t\tfatalf(\"invalid vendoredImportPath: dir=%q root=%q separator=%q\", dir, root, string(filepath.Separator))\n+\t}\n+\tvpath := \"vendor/\" + path\n+\tfor i := len(dir); i >= len(root); i-- {\n+\t\tif i < len(dir) && dir[i] != filepath.Separator {\n+\t\t\tcontinue\n+\t\t}\n+\t\t// Note: checking for the vendor directory before checking\n+\t\t// for the vendor/path directory helps us hit the\n+\t\t// isDir cache more often. It also helps us prepare a more useful\n+\t\t// list of places we looked, to report when an import is not found.\n+\t\tif !isDir(filepath.Join(dir[:i], \"vendor\")) {\n+\t\t\tcontinue\n+\t\t}\n+\t\ttarg := filepath.Join(dir[:i], vpath)\n+\t\tif isDir(targ) {\n+\t\t\t// We started with parent's dir c:\\gopath\\src\\foo\\bar\\baz\\quux\\xyzzy.\n+\t\t\t// We know the import path for parent's dir.\n+\t\t\t// We chopped off some number of path elements and\n+\t\t\t// added vendor\\path to produce c:\\gopath\\src\\foo\\bar\\baz\\vendor\\path.\n+\t\t\t// Now we want to know the import path for that directory.\n+\t\t\t// Construct it by chopping the same number of path elements\n+\t\t\t// (actually the same number of bytes) from parent's import path\n+\t\t\t// and then append /vendor/path.\n+\t\t\tchopped := len(dir) - i\n+\t\t\tif chopped == len(parent.ImportPath)+1 {\n+\t\t\t\t// We walked up from c:\\gopath\\src\\foo\\bar\n+\t\t\t\t// and found c:\\gopath\\src\\vendor\\path.\n+\t\t\t\t// We chopped \\foo\\bar (length 8) but the import path is \"foo/bar\" (length 7).\n+\t\t\t\t// Use \"vendor/path\" without any prefix.\n+\t\t\t\treturn vpath, nil\n+\t\t\t}\n+\t\t\treturn parent.ImportPath[:len(parent.ImportPath)-chopped] + \"/\" + vpath, nil\n+\t\t}\n+\t\t// Note the existence of a vendor directory in case path is not found anywhere.\n+\t\tsearched = append(searched, targ)\n+\t}\n+\treturn path, searched\n+}\n+\n // reusePackage reuses package p to satisfy the import at the top\n // of the import stack stk.  If this use causes an import loop,\n // reusePackage updates p's error information to record the loop.\n@@ -324,11 +495,9 @@ func disallowInternal(srcDir string, p *Package, stk *importStack) *Package {\n \t// An import of a path containing the element \u201cinternal\u201d\n \t// is disallowed if the importing code is outside the tree\n \t// rooted at the parent of the \u201cinternal\u201d directory.\n-\t//\n-\t// ... For Go 1.4, we will implement the rule first for $GOROOT, but not $GOPATH.\n \n-\t// Only applies to $GOROOT.\n-\tif !p.Standard {\n+\t// There was an error loading the package; stop here.\n+\tif p.Error != nil {\n \t\treturn p\n \t}\n \n@@ -385,6 +554,105 @@ func findInternal(path string) (index int, ok bool) {\n \treturn 0, false\n }\n \n+// disallowVendor checks that srcDir is allowed to import p as path.\n+// If the import is allowed, disallowVendor returns the original package p.\n+// If not, it returns a new package containing just an appropriate error.\n+func disallowVendor(srcDir, path string, p *Package, stk *importStack) *Package {\n+\tif !go15VendorExperiment {\n+\t\treturn p\n+\t}\n+\n+\t// The stack includes p.ImportPath.\n+\t// If that's the only thing on the stack, we started\n+\t// with a name given on the command line, not an\n+\t// import. Anything listed on the command line is fine.\n+\tif len(*stk) == 1 {\n+\t\treturn p\n+\t}\n+\n+\tif perr := disallowVendorVisibility(srcDir, p, stk); perr != p {\n+\t\treturn perr\n+\t}\n+\n+\t// Paths like x/vendor/y must be imported as y, never as x/vendor/y.\n+\tif i, ok := findVendor(path); ok {\n+\t\tperr := *p\n+\t\tperr.Error = &PackageError{\n+\t\t\tImportStack: stk.copy(),\n+\t\t\tErr:         \"must be imported as \" + path[i+len(\"vendor/\"):],\n+\t\t}\n+\t\tperr.Incomplete = true\n+\t\treturn &perr\n+\t}\n+\n+\treturn p\n+}\n+\n+// disallowVendorVisibility checks that srcDir is allowed to import p.\n+// The rules are the same as for /internal/ except that a path ending in /vendor\n+// is not subject to the rules, only subdirectories of vendor.\n+// This allows people to have packages and commands named vendor,\n+// for maximal compatibility with existing source trees.\n+func disallowVendorVisibility(srcDir string, p *Package, stk *importStack) *Package {\n+\t// The stack includes p.ImportPath.\n+\t// If that's the only thing on the stack, we started\n+\t// with a name given on the command line, not an\n+\t// import. Anything listed on the command line is fine.\n+\tif len(*stk) == 1 {\n+\t\treturn p\n+\t}\n+\n+\t// Check for \"vendor\" element.\n+\ti, ok := findVendor(p.ImportPath)\n+\tif !ok {\n+\t\treturn p\n+\t}\n+\n+\t// Vendor is present.\n+\t// Map import path back to directory corresponding to parent of vendor.\n+\tif i > 0 {\n+\t\ti-- // rewind over slash in \".../vendor\"\n+\t}\n+\ttruncateTo := i + len(p.Dir) - len(p.ImportPath)\n+\tif truncateTo < 0 || len(p.Dir) < truncateTo {\n+\t\treturn p\n+\t}\n+\tparent := p.Dir[:truncateTo]\n+\tif hasPathPrefix(filepath.ToSlash(srcDir), filepath.ToSlash(parent)) {\n+\t\treturn p\n+\t}\n+\n+\t// Vendor is present, and srcDir is outside parent's tree. Not allowed.\n+\tperr := *p\n+\tperr.Error = &PackageError{\n+\t\tImportStack: stk.copy(),\n+\t\tErr:         \"use of vendored package not allowed\",\n+\t}\n+\tperr.Incomplete = true\n+\treturn &perr\n+}\n+\n+// findVendor looks for the last non-terminating \"vendor\" path element in the given import path.\n+// If there isn't one, findVendor returns ok=false.\n+// Otherwise, findInternal returns ok=true and the index of the \"vendor\".\n+//\n+// Note that terminating \"vendor\" elements don't count: \"x/vendor\" is its own package,\n+// not the vendored copy of an import \"\" (the empty import path).\n+// This will allow people to have packages or commands named vendor.\n+// This may help reduce breakage, or it may just be confusing. We'll see.\n+func findVendor(path string) (index int, ok bool) {\n+\t// Two cases, depending on internal at start of string or not.\n+\t// The order matters: we must return the index of the final element,\n+\t// because the final one is where the effective import path starts.\n+\tswitch {\n+\tcase strings.Contains(path, \"/vendor/\"):\n+\t\treturn strings.LastIndex(path, \"/vendor/\") + 1, true\n+\tcase strings.HasPrefix(path, \"vendor/\"):\n+\t\treturn 0, true\n+\t}\n+\treturn 0, false\n+}\n+\n type targetDir int\n \n const (\n@@ -398,17 +666,23 @@ const (\n var goTools = map[string]targetDir{\n \t\"cmd/addr2line\":                        toTool,\n \t\"cmd/api\":                              toTool,\n+\t\"cmd/asm\":                              toTool,\n+\t\"cmd/compile\":                          toTool,\n \t\"cmd/cgo\":                              toTool,\n+\t\"cmd/cover\":                            toTool,\n+\t\"cmd/dist\":                             toTool,\n+\t\"cmd/doc\":                              toTool,\n \t\"cmd/fix\":                              toTool,\n \t\"cmd/link\":                             toTool,\n+\t\"cmd/newlink\":                          toTool,\n \t\"cmd/nm\":                               toTool,\n \t\"cmd/objdump\":                          toTool,\n \t\"cmd/pack\":                             toTool,\n \t\"cmd/pprof\":                            toTool,\n+\t\"cmd/trace\":                            toTool,\n+\t\"cmd/vet\":                              toTool,\n \t\"cmd/yacc\":                             toTool,\n-\t\"golang.org/x/tools/cmd/cover\":         toTool,\n \t\"golang.org/x/tools/cmd/godoc\":         toBin,\n-\t\"golang.org/x/tools/cmd/vet\":           toTool,\n \t\"code.google.com/p/go.tools/cmd/cover\": stalePath,\n \t\"code.google.com/p/go.tools/cmd/godoc\": stalePath,\n \t\"code.google.com/p/go.tools/cmd/vet\":   stalePath,\n@@ -471,7 +745,15 @@ func (p *Package) load(stk *importStack, bp *build.Package, err error) *Package\n \t\treturn p\n \t}\n \n-\tif p.Name == \"main\" {\n+\tuseBindir := p.Name == \"main\"\n+\tif !p.Standard {\n+\t\tswitch buildBuildmode {\n+\t\tcase \"c-archive\", \"c-shared\":\n+\t\t\tuseBindir = false\n+\t\t}\n+\t}\n+\n+\tif useBindir {\n \t\t// Report an error when the old code.google.com/p/go.tools paths are used.\n \t\tif goTools[p.ImportPath] == stalePath {\n \t\t\tnewPath := strings.Replace(p.ImportPath, \"code.google.com/p/go.\", \"golang.org/x/\", 1)\n@@ -493,6 +775,11 @@ func (p *Package) load(stk *importStack, bp *build.Package, err error) *Package\n \t\t} else if p.build.BinDir != \"\" {\n \t\t\t// Install to GOBIN or bin of GOPATH entry.\n \t\t\tp.target = filepath.Join(p.build.BinDir, elem)\n+\t\t\tif !p.Goroot && strings.Contains(elem, \"/\") && gobin != \"\" {\n+\t\t\t\t// Do not create $GOBIN/goos_goarch/elem.\n+\t\t\t\tp.target = \"\"\n+\t\t\t\tp.gobinSubdir = true\n+\t\t\t}\n \t\t}\n \t\tif goTools[p.ImportPath] == toTool {\n \t\t\t// This is for 'go tool'.\n@@ -508,6 +795,21 @@ func (p *Package) load(stk *importStack, bp *build.Package, err error) *Package\n \t\tp.target = \"\"\n \t} else {\n \t\tp.target = p.build.PkgObj\n+\t\tif buildLinkshared {\n+\t\t\tshlibnamefile := p.target[:len(p.target)-2] + \".shlibname\"\n+\t\t\tshlib, err := ioutil.ReadFile(shlibnamefile)\n+\t\t\tif err == nil {\n+\t\t\t\tlibname := strings.TrimSpace(string(shlib))\n+\t\t\t\tif buildContext.Compiler == \"gccgo\" {\n+\t\t\t\t\tp.Shlib = filepath.Join(p.build.PkgTargetRoot, \"shlibs\", libname)\n+\t\t\t\t} else {\n+\t\t\t\t\tp.Shlib = filepath.Join(p.build.PkgTargetRoot, libname)\n+\n+\t\t\t\t}\n+\t\t\t} else if !os.IsNotExist(err) {\n+\t\t\t\tfatalf(\"unexpected error reading %s: %v\", shlibnamefile, err)\n+\t\t\t}\n+\t\t}\n \t}\n \n \timportPaths := p.Imports\n@@ -521,6 +823,14 @@ func (p *Package) load(stk *importStack, bp *build.Package, err error) *Package\n \tif len(p.CgoFiles) > 0 && (!p.Standard || !cgoSyscallExclude[p.ImportPath]) {\n \t\timportPaths = append(importPaths, \"syscall\")\n \t}\n+\n+\t// Currently build mode c-shared, or -linkshared, forces\n+\t// external linking mode, and external linking mode forces an\n+\t// import of runtime/cgo.\n+\tif p.Name == \"main\" && !p.Goroot && (buildBuildmode == \"c-shared\" || buildLinkshared) {\n+\t\timportPaths = append(importPaths, \"runtime/cgo\")\n+\t}\n+\n \t// Everything depends on runtime, except runtime and unsafe.\n \tif !p.Standard || (p.ImportPath != \"runtime\" && p.ImportPath != \"unsafe\") {\n \t\timportPaths = append(importPaths, \"runtime\")\n@@ -529,6 +839,10 @@ func (p *Package) load(stk *importStack, bp *build.Package, err error) *Package\n \t\tif buildRace && (!p.Standard || !raceExclude[p.ImportPath]) {\n \t\t\timportPaths = append(importPaths, \"runtime/race\")\n \t\t}\n+\t\t// On ARM with GOARM=5, everything depends on math for the link.\n+\t\tif p.Name == \"main\" && goarch == \"arm\" {\n+\t\t\timportPaths = append(importPaths, \"math\")\n+\t\t}\n \t}\n \n \t// Build list of full paths to all Go files in the package,\n@@ -586,10 +900,20 @@ func (p *Package) load(stk *importStack, bp *build.Package, err error) *Package\n \t\tif path == \"C\" {\n \t\t\tcontinue\n \t\t}\n-\t\tp1 := loadImport(path, p.Dir, stk, p.build.ImportPos[path])\n+\t\tp1 := loadImport(path, p.Dir, p, stk, p.build.ImportPos[path], useVendor)\n \t\tif !reqStdPkgSrc && p1.Standard {\n \t\t\tcontinue\n \t\t}\n+\t\tif p1.Name == \"main\" {\n+\t\t\tp.Error = &PackageError{\n+\t\t\t\tImportStack: stk.copy(),\n+\t\t\t\tErr:         fmt.Sprintf(\"import %q is a program, not an importable package\", path),\n+\t\t\t}\n+\t\t\tpos := p.build.ImportPos[path]\n+\t\t\tif len(pos) > 0 {\n+\t\t\t\tp.Error.Pos = pos[0].String()\n+\t\t\t}\n+\t\t}\n \t\tif p1.local {\n \t\t\tif !p.local && p.Error == nil {\n \t\t\t\tp.Error = &PackageError{\n@@ -601,13 +925,21 @@ func (p *Package) load(stk *importStack, bp *build.Package, err error) *Package\n \t\t\t\t\tp.Error.Pos = pos[0].String()\n \t\t\t\t}\n \t\t\t}\n-\t\t\tpath = p1.ImportPath\n-\t\t\timportPaths[i] = path\n+\t\t}\n+\t\tpath = p1.ImportPath\n+\t\timportPaths[i] = path\n+\t\tif i < len(p.Imports) {\n+\t\t\tp.Imports[i] = path\n \t\t}\n \t\tdeps[path] = p1\n \t\timports = append(imports, p1)\n \t\tfor _, dep := range p1.deps {\n-\t\t\tdeps[dep.ImportPath] = dep\n+\t\t\t// The same import path could produce an error or not,\n+\t\t\t// depending on what tries to import it.\n+\t\t\t// Prefer to record entries with errors, so we can report them.\n+\t\t\tif deps[dep.ImportPath] == nil || dep.Error != nil {\n+\t\t\t\tdeps[dep.ImportPath] = dep\n+\t\t\t}\n \t\t}\n \t\tif p1.Incomplete {\n \t\t\tp.Incomplete = true\n@@ -637,12 +969,11 @@ func (p *Package) load(stk *importStack, bp *build.Package, err error) *Package\n \t}\n \tp.Target = p.target\n \n-\t// Check for C code compiled with Plan 9 C compiler.\n-\t// No longer allowed except in runtime and runtime/cgo, for now.\n-\tif len(p.CFiles) > 0 && !p.usesCgo() && (!p.Standard || p.ImportPath != \"runtime\") {\n+\t// The gc toolchain only permits C source files with cgo.\n+\tif len(p.CFiles) > 0 && !p.usesCgo() && !p.usesSwig() && buildContext.Compiler == \"gc\" {\n \t\tp.Error = &PackageError{\n \t\t\tImportStack: stk.copy(),\n-\t\t\tErr:         fmt.Sprintf(\"C source files not allowed when not using cgo: %s\", strings.Join(p.CFiles, \" \")),\n+\t\t\tErr:         fmt.Sprintf(\"C source files not allowed when not using cgo or SWIG: %s\", strings.Join(p.CFiles, \" \")),\n \t\t}\n \t\treturn p\n \t}\n@@ -660,6 +991,7 @@ func (p *Package) load(stk *importStack, bp *build.Package, err error) *Package\n \t\t}\n \t}\n \n+\tcomputeBuildID(p)\n \treturn p\n }\n \n@@ -698,13 +1030,8 @@ func packageList(roots []*Package) []*Package {\n // computeStale computes the Stale flag in the package dag that starts\n // at the named pkgs (command-line arguments).\n func computeStale(pkgs ...*Package) {\n-\ttopRoot := map[string]bool{}\n-\tfor _, p := range pkgs {\n-\t\ttopRoot[p.Root] = true\n-\t}\n-\n \tfor _, p := range packageList(pkgs) {\n-\t\tp.Stale = isStale(p, topRoot)\n+\t\tp.Stale = isStale(p)\n \t}\n }\n \n@@ -714,8 +1041,269 @@ func computeStale(pkgs ...*Package) {\n // inspecting the version.\n var isGoRelease = strings.HasPrefix(runtime.Version(), \"go1\")\n \n+// isStale and computeBuildID\n+//\n+// Theory of Operation\n+//\n+// There is an installed copy of the package (or binary).\n+// Can we reuse the installed copy, or do we need to build a new one?\n+//\n+// We can use the installed copy if it matches what we'd get\n+// by building a new one. The hard part is predicting that without\n+// actually running a build.\n+//\n+// To start, we must know the set of inputs to the build process that can\n+// affect the generated output. At a minimum, that includes the source\n+// files for the package and also any compiled packages imported by those\n+// source files. The *Package has these, and we use them. One might also\n+// argue for including in the input set: the build tags, whether the race\n+// detector is in use, the target operating system and architecture, the\n+// compiler and linker binaries being used, the additional flags being\n+// passed to those, the cgo binary being used, the additional flags cgo\n+// passes to the host C compiler, the host C compiler being used, the set\n+// of host C include files and installed C libraries, and so on.\n+// We include some but not all of this information.\n+//\n+// Once we have decided on a set of inputs, we must next decide how to\n+// tell whether the content of that set has changed since the last build\n+// of p. If there have been no changes, then we assume a new build would\n+// produce the same result and reuse the installed package or binary.\n+// But if there have been changes, then we assume a new build might not\n+// produce the same result, so we rebuild.\n+//\n+// There are two common ways to decide whether the content of the set has\n+// changed: modification times and content hashes. We use a mixture of both.\n+//\n+// The use of modification times (mtimes) was pioneered by make:\n+// assuming that a file's mtime is an accurate record of when that file was last written,\n+// and assuming that the modification time of an installed package or\n+// binary is the time that it was built, if the mtimes of the inputs\n+// predate the mtime of the installed object, then the build of that\n+// object saw those versions of the files, and therefore a rebuild using\n+// those same versions would produce the same object. In contrast, if any\n+// mtime of an input is newer than the mtime of the installed object, a\n+// change has occurred since the build, and the build should be redone.\n+//\n+// Modification times are attractive because the logic is easy to\n+// understand and the file system maintains the mtimes automatically\n+// (less work for us). Unfortunately, there are a variety of ways in\n+// which the mtime approach fails to detect a change and reuses a stale\n+// object file incorrectly. (Making the opposite mistake, rebuilding\n+// unnecessarily, is only a performance problem and not a correctness\n+// problem, so we ignore that one.)\n+//\n+// As a warmup, one problem is that to be perfectly precise, we need to\n+// compare the input mtimes against the time at the beginning of the\n+// build, but the object file time is the time at the end of the build.\n+// If an input file changes after being read but before the object is\n+// written, the next build will see an object newer than the input and\n+// will incorrectly decide that the object is up to date. We make no\n+// attempt to detect or solve this problem.\n+//\n+// Another problem is that due to file system imprecision, an input and\n+// output that are actually ordered in time have the same mtime.\n+// This typically happens on file systems with 1-second (or, worse,\n+// 2-second) mtime granularity and with automated scripts that write an\n+// input and then immediately run a build, or vice versa. If an input and\n+// an output have the same mtime, the conservative behavior is to treat\n+// the output as out-of-date and rebuild. This can cause one or more\n+// spurious rebuilds, but only for 1 second, until the object finally has\n+// an mtime later than the input.\n+//\n+// Another problem is that binary distributions often set the mtime on\n+// all files to the same time. If the distribution includes both inputs\n+// and cached build outputs, the conservative solution to the previous\n+// problem will cause unnecessary rebuilds. Worse, in such a binary\n+// distribution, those rebuilds might not even have permission to update\n+// the cached build output. To avoid these write errors, if an input and\n+// output have the same mtime, we assume the output is up-to-date.\n+// This is the opposite of what the previous problem would have us do,\n+// but binary distributions are more common than instances of the\n+// previous problem.\n+//\n+// A variant of the last problem is that some binary distributions do not\n+// set the mtime on all files to the same time. Instead they let the file\n+// system record mtimes as the distribution is unpacked. If the outputs\n+// are unpacked before the inputs, they'll be older and a build will try\n+// to rebuild them. That rebuild might hit the same write errors as in\n+// the last scenario. We don't make any attempt to solve this, and we\n+// haven't had many reports of it. Perhaps the only time this happens is\n+// when people manually unpack the distribution, and most of the time\n+// that's done as the same user who will be using it, so an initial\n+// rebuild on first use succeeds quietly.\n+//\n+// More generally, people and programs change mtimes on files. The last\n+// few problems were specific examples of this, but it's a general problem.\n+// For example, instead of a binary distribution, copying a home\n+// directory from one directory or machine to another might copy files\n+// but not preserve mtimes. If the inputs are new than the outputs on the\n+// first machine but copied first, they end up older than the outputs on\n+// the second machine.\n+//\n+// Because many other build systems have the same sensitivity to mtimes,\n+// most programs manipulating source code take pains not to break the\n+// mtime assumptions. For example, Git does not set the mtime of files\n+// during a checkout operation, even when checking out an old version of\n+// the code. This decision was made specifically to work well with\n+// mtime-based build systems.\n+//\n+// The killer problem, though, for mtime-based build systems is that the\n+// build only has access to the mtimes of the inputs that still exist.\n+// If it is possible to remove an input without changing any other inputs,\n+// a later build will think the object is up-to-date when it is not.\n+// This happens for Go because a package is made up of all source\n+// files in a directory. If a source file is removed, there is no newer\n+// mtime available recording that fact. The mtime on the directory could\n+// be used, but it also changes when unrelated files are added to or\n+// removed from the directory, so including the directory mtime would\n+// cause unnecessary rebuilds, possibly many. It would also exacerbate\n+// the problems mentioned earlier, since even programs that are careful\n+// to maintain mtimes on files rarely maintain mtimes on directories.\n+//\n+// A variant of the last problem is when the inputs change for other\n+// reasons. For example, Go 1.4 and Go 1.5 both install $GOPATH/src/mypkg\n+// into the same target, $GOPATH/pkg/$GOOS_$GOARCH/mypkg.a.\n+// If Go 1.4 has built mypkg into mypkg.a, a build using Go 1.5 must\n+// rebuild mypkg.a, but from mtimes alone mypkg.a looks up-to-date.\n+// If Go 1.5 has just been installed, perhaps the compiler will have a\n+// newer mtime; since the compiler is considered an input, that would\n+// trigger a rebuild. But only once, and only the last Go 1.4 build of\n+// mypkg.a happened before Go 1.5 was installed. If a user has the two\n+// versions installed in different locations and flips back and forth,\n+// mtimes alone cannot tell what to do. Changing the toolchain is\n+// changing the set of inputs, without affecting any mtimes.\n+//\n+// To detect the set of inputs changing, we turn away from mtimes and to\n+// an explicit data comparison. Specifically, we build a list of the\n+// inputs to the build, compute its SHA1 hash, and record that as the\n+// ``build ID'' in the generated object. At the next build, we can\n+// recompute the buid ID and compare it to the one in the generated\n+// object. If they differ, the list of inputs has changed, so the object\n+// is out of date and must be rebuilt.\n+//\n+// Because this build ID is computed before the build begins, the\n+// comparison does not have the race that mtime comparison does.\n+//\n+// Making the build sensitive to changes in other state is\n+// straightforward: include the state in the build ID hash, and if it\n+// changes, so does the build ID, triggering a rebuild.\n+//\n+// To detect changes in toolchain, we include the toolchain version in\n+// the build ID hash for package runtime, and then we include the build\n+// IDs of all imported packages in the build ID for p.\n+//\n+// It is natural to think about including build tags in the build ID, but\n+// the naive approach of just dumping the tags into the hash would cause\n+// spurious rebuilds. For example, 'go install' and 'go install -tags neverusedtag'\n+// produce the same binaries (assuming neverusedtag is never used).\n+// A more precise approach would be to include only tags that have an\n+// effect on the build. But the effect of a tag on the build is to\n+// include or exclude a file from the compilation, and that file list is\n+// already in the build ID hash. So the build ID is already tag-sensitive\n+// in a perfectly precise way. So we do NOT explicitly add build tags to\n+// the build ID hash.\n+//\n+// We do not include as part of the build ID the operating system,\n+// architecture, or whether the race detector is enabled, even though all\n+// three have an effect on the output, because that information is used\n+// to decide the install location. Binaries for linux and binaries for\n+// darwin are written to different directory trees; including that\n+// information in the build ID is unnecessary (although it would be\n+// harmless).\n+//\n+// TODO(rsc): Investigate the cost of putting source file content into\n+// the build ID hash as a replacement for the use of mtimes. Using the\n+// file content would avoid all the mtime problems, but it does require\n+// reading all the source files, something we avoid today (we read the\n+// beginning to find the build tags and the imports, but we stop as soon\n+// as we see the import block is over). If the package is stale, the compiler\n+// is going to read the files anyway. But if the package is up-to-date, the\n+// read is overhead.\n+//\n+// TODO(rsc): Investigate the complexity of making the build more\n+// precise about when individual results are needed. To be fully precise,\n+// there are two results of a compilation: the entire .a file used by the link\n+// and the subpiece used by later compilations (__.PKGDEF only).\n+// If a rebuild is needed but produces the previous __.PKGDEF, then\n+// no more recompilation due to the rebuilt package is needed, only\n+// relinking. To date, there is nothing in the Go command to express this.\n+//\n+// Special Cases\n+//\n+// When the go command makes the wrong build decision and does not\n+// rebuild something it should, users fall back to adding the -a flag.\n+// Any common use of the -a flag should be considered prima facie evidence\n+// that isStale is returning an incorrect false result in some important case.\n+// Bugs reported in the behavior of -a itself should prompt the question\n+// ``Why is -a being used at all? What bug does that indicate?''\n+//\n+// There is a long history of changes to isStale to try to make -a into a\n+// suitable workaround for bugs in the mtime-based decisions.\n+// It is worth recording that history to inform (and, as much as possible, deter) future changes.\n+//\n+// (1) Before the build IDs were introduced, building with alternate tags\n+// would happily reuse installed objects built without those tags.\n+// For example, \"go build -tags netgo myprog.go\" would use the installed\n+// copy of package net, even if that copy had been built without netgo.\n+// (The netgo tag controls whether package net uses cgo or pure Go for\n+// functionality such as name resolution.)\n+// Using the installed non-netgo package defeats the purpose.\n+//\n+// Users worked around this with \"go build -tags netgo -a myprog.go\".\n+//\n+// Build IDs have made that workaround unnecessary:\n+// \"go build -tags netgo myprog.go\"\n+// cannot use a non-netgo copy of package net.\n+//\n+// (2) Before the build IDs were introduced, building with different toolchains,\n+// especially changing between toolchains, tried to reuse objects stored in\n+// $GOPATH/pkg, resulting in link-time errors about object file mismatches.\n+//\n+// Users worked around this with \"go install -a ./...\".\n+//\n+// Build IDs have made that workaround unnecessary:\n+// \"go install ./...\" will rebuild any objects it finds that were built against\n+// a different toolchain.\n+//\n+// (3) The common use of \"go install -a ./...\" led to reports of problems\n+// when the -a forced the rebuild of the standard library, which for some\n+// users was not writable. Because we didn't understand that the real\n+// problem was the bug -a was working around, we changed -a not to\n+// apply to the standard library.\n+//\n+// (4) The common use of \"go build -tags netgo -a myprog.go\" broke\n+// when we changed -a not to apply to the standard library, because\n+// if go build doesn't rebuild package net, it uses the non-netgo version.\n+//\n+// Users worked around this with \"go build -tags netgo -installsuffix barf myprog.go\".\n+// The -installsuffix here is making the go command look for packages\n+// in pkg/$GOOS_$GOARCH_barf instead of pkg/$GOOS_$GOARCH.\n+// Since the former presumably doesn't exist, go build decides to rebuild\n+// everything, including the standard library. Since go build doesn't\n+// install anything it builds, nothing is ever written to pkg/$GOOS_$GOARCH_barf,\n+// so repeated invocations continue to work.\n+//\n+// If the use of -a wasn't a red flag, the use of -installsuffix to point to\n+// a non-existent directory in a command that installs nothing should\n+// have been.\n+//\n+// (5) Now that (1) and (2) no longer need -a, we have removed the kludge\n+// introduced in (3): once again, -a means ``rebuild everything,'' not\n+// ``rebuild everything except the standard library.'' Only Go 1.4 had\n+// the restricted meaning.\n+//\n+// In addition to these cases trying to trigger rebuilds, there are\n+// special cases trying NOT to trigger rebuilds. The main one is that for\n+// a variety of reasons (see above), the install process for a Go release\n+// cannot be relied upon to set the mtimes such that the go command will\n+// think the standard library is up to date. So the mtime evidence is\n+// ignored for the standard library if we find ourselves in a release\n+// version of Go. Build ID-based staleness checks still apply to the\n+// standard library, even in release versions. This makes\n+// 'go build -tags netgo' work, among other things.\n+\n // isStale reports whether package p needs to be rebuilt.\n-func isStale(p *Package, topRoot map[string]bool) bool {\n+func isStale(p *Package) bool {\n \tif p.Standard && (p.ImportPath == \"unsafe\" || buildContext.Compiler == \"gccgo\") {\n \t\t// fake, builtin package\n \t\treturn false\n@@ -734,36 +1322,76 @@ func isStale(p *Package, topRoot map[string]bool) bool {\n \t\treturn false\n \t}\n \n-\t// If we are running a release copy of Go, do not rebuild the standard packages.\n-\t// They may not be writable anyway, but they are certainly not changing.\n-\t// This makes 'go build -a' skip the standard packages when using an official release.\n-\t// See issue 4106 and issue 8290.\n-\tpkgBuildA := buildA\n-\tif p.Standard && isGoRelease {\n-\t\tpkgBuildA = false\n+\t// If the -a flag is given, rebuild everything.\n+\tif buildA {\n+\t\treturn true\n \t}\n \n-\tif pkgBuildA || p.target == \"\" || p.Stale {\n+\t// If there's no install target or it's already marked stale, we have to rebuild.\n+\tif p.target == \"\" || p.Stale {\n \t\treturn true\n \t}\n \n \t// Package is stale if completely unbuilt.\n-\tvar built time.Time\n-\tif fi, err := os.Stat(p.target); err == nil {\n-\t\tbuilt = fi.ModTime()\n+\tfi, err := os.Stat(p.target)\n+\tif err != nil {\n+\t\treturn true\n \t}\n-\tif built.IsZero() {\n+\n+\t// Package is stale if the expected build ID differs from the\n+\t// recorded build ID. This catches changes like a source file\n+\t// being removed from a package directory. See issue 3895.\n+\t// It also catches changes in build tags that affect the set of\n+\t// files being compiled. See issue 9369.\n+\t// It also catches changes in toolchain, like when flipping between\n+\t// two versions of Go compiling a single GOPATH.\n+\t// See issue 8290 and issue 10702.\n+\ttargetBuildID, err := readBuildID(p)\n+\tif err == nil && targetBuildID != p.buildID {\n \t\treturn true\n \t}\n \n+\t// Package is stale if a dependency is.\n+\tfor _, p1 := range p.deps {\n+\t\tif p1.Stale {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\n+\t// The checks above are content-based staleness.\n+\t// We assume they are always accurate.\n+\t//\n+\t// The checks below are mtime-based staleness.\n+\t// We hope they are accurate, but we know that they fail in the case of\n+\t// prebuilt Go installations that don't preserve the build mtimes\n+\t// (for example, if the pkg/ mtimes are before the src/ mtimes).\n+\t// See the large comment above isStale for details.\n+\n+\t// If we are running a release copy of Go and didn't find a content-based\n+\t// reason to rebuild the standard packages, do not rebuild them.\n+\t// They may not be writable anyway, but they are certainly not changing.\n+\t// This makes 'go build' skip the standard packages when\n+\t// using an official release, even when the mtimes have been changed.\n+\t// See issue 3036, issue 3149, issue 4106, issue 8290.\n+\t// (If a change to a release tree must be made by hand, the way to force the\n+\t// install is to run make.bash, which will remove the old package archives\n+\t// before rebuilding.)\n+\tif p.Standard && isGoRelease {\n+\t\treturn false\n+\t}\n+\n+\t// Time-based staleness.\n+\n+\tbuilt := fi.ModTime()\n+\n \tolderThan := func(file string) bool {\n \t\tfi, err := os.Stat(file)\n \t\treturn err != nil || fi.ModTime().After(built)\n \t}\n \n \t// Package is stale if a dependency is, or if a dependency is newer.\n \tfor _, p1 := range p.deps {\n-\t\tif p1.Stale || p1.target != \"\" && olderThan(p1.target) {\n+\t\tif p1.target != \"\" && olderThan(p1.target) {\n \t\t\treturn true\n \t\t}\n \t}\n@@ -775,8 +1403,12 @@ func isStale(p *Package, topRoot map[string]bool) bool {\n \t// back-dated, as some binary distributions may do, but it does handle\n \t// a very common case.\n \t// See issue 3036.\n-\t// Assume code in $GOROOT is up to date, since it may not be writeable.\n-\t// See issue 4106.\n+\t// Exclude $GOROOT, under the assumption that people working on\n+\t// the compiler may want to control when everything gets rebuilt,\n+\t// and people updating the Go repository will run make.bash or all.bash\n+\t// and get a full rebuild anyway.\n+\t// Excluding $GOROOT used to also fix issue 4106, but that's now\n+\t// taken care of above (at least when the installed Go is a released version).\n \tif p.Root != goroot {\n \t\tif olderThan(buildToolchain.compiler()) {\n \t\t\treturn true\n@@ -786,19 +1418,43 @@ func isStale(p *Package, topRoot map[string]bool) bool {\n \t\t}\n \t}\n \n-\t// Have installed copy, probably built using current compilers,\n-\t// and built after its imported packages.  The only reason now\n-\t// that we'd have to rebuild it is if the sources were newer than\n-\t// the package.   If a package p is not in the same tree as any\n-\t// package named on the command-line, assume it is up-to-date\n-\t// no matter what the modification times on the source files indicate.\n-\t// This avoids rebuilding $GOROOT packages when people are\n-\t// working outside the Go root, and it effectively makes each tree\n-\t// listed in $GOPATH a separate compilation world.\n-\t// See issue 3149.\n-\tif p.Root != \"\" && !topRoot[p.Root] {\n-\t\treturn false\n-\t}\n+\t// Note: Until Go 1.5, we had an additional shortcut here.\n+\t// We built a list of the workspace roots ($GOROOT, each $GOPATH)\n+\t// containing targets directly named on the command line,\n+\t// and if p were not in any of those, it would be treated as up-to-date\n+\t// as long as it is built. The goal was to avoid rebuilding a system-installed\n+\t// $GOROOT, unless something from $GOROOT were explicitly named\n+\t// on the command line (like go install math).\n+\t// That's now handled by the isGoRelease clause above.\n+\t// The other effect of the shortcut was to isolate different entries in\n+\t// $GOPATH from each other. This had the unfortunate effect that\n+\t// if you had (say), GOPATH listing two entries, one for commands\n+\t// and one for libraries, and you did a 'git pull' in the library one\n+\t// and then tried 'go install commands/...', it would build the new libraries\n+\t// during the first build (because they wouldn't have been installed at all)\n+\t// but then subsequent builds would not rebuild the libraries, even if the\n+\t// mtimes indicate they are stale, because the different GOPATH entries\n+\t// were treated differently. This behavior was confusing when using\n+\t// non-trivial GOPATHs, which were particularly common with some\n+\t// code management conventions, like the original godep.\n+\t// Since the $GOROOT case (the original motivation) is handled separately,\n+\t// we no longer put a barrier between the different $GOPATH entries.\n+\t//\n+\t// One implication of this is that if there is a system directory for\n+\t// non-standard Go packages that is included in $GOPATH, the mtimes\n+\t// on those compiled packages must be no earlier than the mtimes\n+\t// on the source files. Since most distributions use the same mtime\n+\t// for all files in a tree, they will be unaffected. People using plain\n+\t// tar x to extract system-installed packages will need to adjust mtimes,\n+\t// but it's better to force them to get the mtimes right than to ignore\n+\t// the mtimes and thereby do the wrong thing in common use cases.\n+\t//\n+\t// So there is no GOPATH vs GOPATH shortcut here anymore.\n+\t//\n+\t// If something needs to come back here, we could try writing a dummy\n+\t// file with a random name to the $GOPATH/pkg directory (and removing it)\n+\t// to test for write access, and then skip GOPATH roots we don't have write\n+\t// access to. But hopefully we can just use the mtimes always.\n \n \tsrcs := stringList(p.GoFiles, p.CFiles, p.CXXFiles, p.MFiles, p.HFiles, p.SFiles, p.CgoFiles, p.SysoFiles, p.SwigFiles, p.SwigCXXFiles)\n \tfor _, src := range srcs {\n@@ -810,6 +1466,53 @@ func isStale(p *Package, topRoot map[string]bool) bool {\n \treturn false\n }\n \n+// computeBuildID computes the build ID for p, leaving it in p.buildID.\n+// Build ID is a hash of the information we want to detect changes in.\n+// See the long comment in isStale for details.\n+func computeBuildID(p *Package) {\n+\th := sha1.New()\n+\n+\t// Include the list of files compiled as part of the package.\n+\t// This lets us detect removed files. See issue 3895.\n+\tinputFiles := stringList(\n+\t\tp.GoFiles,\n+\t\tp.CgoFiles,\n+\t\tp.CFiles,\n+\t\tp.CXXFiles,\n+\t\tp.MFiles,\n+\t\tp.HFiles,\n+\t\tp.SFiles,\n+\t\tp.SysoFiles,\n+\t\tp.SwigFiles,\n+\t\tp.SwigCXXFiles,\n+\t)\n+\tfor _, file := range inputFiles {\n+\t\tfmt.Fprintf(h, \"file %s\\n\", file)\n+\t}\n+\n+\t// Include the content of runtime/zversion.go in the hash\n+\t// for package runtime. This will give package runtime a\n+\t// different build ID in each Go release.\n+\tif p.Standard && p.ImportPath == \"runtime\" {\n+\t\tdata, _ := ioutil.ReadFile(filepath.Join(p.Dir, \"zversion.go\"))\n+\t\tfmt.Fprintf(h, \"zversion %q\\n\", string(data))\n+\t}\n+\n+\t// Include the build IDs of any dependencies in the hash.\n+\t// This, combined with the runtime/zversion content,\n+\t// will cause packages to have different build IDs when\n+\t// compiled with different Go releases.\n+\t// This helps the go command know to recompile when\n+\t// people use the same GOPATH but switch between\n+\t// different Go releases. See issue 10702.\n+\t// This is also a better fix for issue 8290.\n+\tfor _, p1 := range p.deps {\n+\t\tfmt.Fprintf(h, \"dep %s %s\\n\", p1.ImportPath, p1.buildID)\n+\t}\n+\n+\tp.buildID = fmt.Sprintf(\"%x\", h.Sum(nil))\n+}\n+\n var cwd, _ = os.Getwd()\n \n var cmdCache = map[string]*Package{}\n@@ -872,7 +1575,7 @@ func loadPackage(arg string, stk *importStack) *Package {\n \t\t}\n \t}\n \n-\treturn loadImport(arg, cwd, stk, nil)\n+\treturn loadImport(arg, cwd, nil, stk, nil, 0)\n }\n \n // packages returns the packages named by the\n@@ -942,6 +1645,23 @@ func packagesForBuild(args []string) []*Package {\n \t\t}\n \t}\n \texitIfErrors()\n+\n+\t// Check for duplicate loads of the same package.\n+\t// That should be impossible, but if it does happen then\n+\t// we end up trying to build the same package twice,\n+\t// usually in parallel overwriting the same files,\n+\t// which doesn't work very well.\n+\tseen := map[string]bool{}\n+\treported := map[string]bool{}\n+\tfor _, pkg := range packageList(pkgs) {\n+\t\tif seen[pkg.ImportPath] && !reported[pkg.ImportPath] {\n+\t\t\treported[pkg.ImportPath] = true\n+\t\t\terrorf(\"internal error: duplicate loads of %s\", pkg.ImportPath)\n+\t\t}\n+\t\tseen[pkg.ImportPath] = true\n+\t}\n+\texitIfErrors()\n+\n \treturn pkgs\n }\n \n@@ -967,3 +1687,170 @@ func hasSubdir(root, dir string) (rel string, ok bool) {\n \t}\n \treturn filepath.ToSlash(dir[len(root):]), true\n }\n+\n+var (\n+\terrBuildIDToolchain = fmt.Errorf(\"build ID only supported in gc toolchain\")\n+\terrBuildIDMalformed = fmt.Errorf(\"malformed object file\")\n+\terrBuildIDUnknown   = fmt.Errorf(\"lost build ID\")\n+)\n+\n+var (\n+\tbangArch = []byte(\"!<arch>\")\n+\tpkgdef   = []byte(\"__.PKGDEF\")\n+\tgoobject = []byte(\"go object \")\n+\tbuildid  = []byte(\"build id \")\n+)\n+\n+// readBuildID reads the build ID from an archive or binary.\n+// It only supports the gc toolchain.\n+// Other toolchain maintainers should adjust this function.\n+func readBuildID(p *Package) (id string, err error) {\n+\tif buildToolchain != (gcToolchain{}) {\n+\t\treturn \"\", errBuildIDToolchain\n+\t}\n+\n+\t// For commands, read build ID directly from binary.\n+\tif p.Name == \"main\" {\n+\t\treturn ReadBuildIDFromBinary(p.Target)\n+\t}\n+\n+\t// Otherwise, we expect to have an archive (.a) file,\n+\t// and we can read the build ID from the Go export data.\n+\tif !strings.HasSuffix(p.Target, \".a\") {\n+\t\treturn \"\", &os.PathError{Op: \"parse\", Path: p.Target, Err: errBuildIDUnknown}\n+\t}\n+\n+\t// Read just enough of the target to fetch the build ID.\n+\t// The archive is expected to look like:\n+\t//\n+\t//\t!<arch>\n+\t//\t__.PKGDEF       0           0     0     644     7955      `\n+\t//\tgo object darwin amd64 devel X:none\n+\t//\tbuild id \"b41e5c45250e25c9fd5e9f9a1de7857ea0d41224\"\n+\t//\n+\t// The variable-sized strings are GOOS, GOARCH, and the experiment list (X:none).\n+\t// Reading the first 1024 bytes should be plenty.\n+\tf, err := os.Open(p.Target)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tdata := make([]byte, 1024)\n+\tn, err := io.ReadFull(f, data)\n+\tf.Close()\n+\n+\tif err != nil && n == 0 {\n+\t\treturn \"\", err\n+\t}\n+\n+\tbad := func() (string, error) {\n+\t\treturn \"\", &os.PathError{Op: \"parse\", Path: p.Target, Err: errBuildIDMalformed}\n+\t}\n+\n+\t// Archive header.\n+\tfor i := 0; ; i++ { // returns during i==3\n+\t\tj := bytes.IndexByte(data, '\\n')\n+\t\tif j < 0 {\n+\t\t\treturn bad()\n+\t\t}\n+\t\tline := data[:j]\n+\t\tdata = data[j+1:]\n+\t\tswitch i {\n+\t\tcase 0:\n+\t\t\tif !bytes.Equal(line, bangArch) {\n+\t\t\t\treturn bad()\n+\t\t\t}\n+\t\tcase 1:\n+\t\t\tif !bytes.HasPrefix(line, pkgdef) {\n+\t\t\t\treturn bad()\n+\t\t\t}\n+\t\tcase 2:\n+\t\t\tif !bytes.HasPrefix(line, goobject) {\n+\t\t\t\treturn bad()\n+\t\t\t}\n+\t\tcase 3:\n+\t\t\tif !bytes.HasPrefix(line, buildid) {\n+\t\t\t\t// Found the object header, just doesn't have a build id line.\n+\t\t\t\t// Treat as successful, with empty build id.\n+\t\t\t\treturn \"\", nil\n+\t\t\t}\n+\t\t\tid, err := strconv.Unquote(string(line[len(buildid):]))\n+\t\t\tif err != nil {\n+\t\t\t\treturn bad()\n+\t\t\t}\n+\t\t\treturn id, nil\n+\t\t}\n+\t}\n+}\n+\n+var (\n+\tgoBuildPrefix = []byte(\"\\xff Go build ID: \\\"\")\n+\tgoBuildEnd    = []byte(\"\\\"\\n \\xff\")\n+\n+\telfPrefix = []byte(\"\\x7fELF\")\n+)\n+\n+// ReadBuildIDFromBinary reads the build ID from a binary.\n+//\n+// ELF binaries store the build ID in a proper PT_NOTE section.\n+//\n+// Other binary formats are not so flexible. For those, the linker\n+// stores the build ID as non-instruction bytes at the very beginning\n+// of the text segment, which should appear near the beginning\n+// of the file. This is clumsy but fairly portable. Custom locations\n+// can be added for other binary types as needed, like we did for ELF.\n+func ReadBuildIDFromBinary(filename string) (id string, err error) {\n+\tif filename == \"\" {\n+\t\treturn \"\", &os.PathError{Op: \"parse\", Path: filename, Err: errBuildIDUnknown}\n+\t}\n+\n+\t// Read the first 16 kB of the binary file.\n+\t// That should be enough to find the build ID.\n+\t// In ELF files, the build ID is in the leading headers,\n+\t// which are typically less than 4 kB, not to mention 16 kB.\n+\t// On other systems, we're trying to read enough that\n+\t// we get the beginning of the text segment in the read.\n+\t// The offset where the text segment begins in a hello\n+\t// world compiled for each different object format today:\n+\t//\n+\t//\tPlan 9: 0x20\n+\t//\tWindows: 0x600\n+\t//\tMach-O: 0x2000\n+\t//\n+\tf, err := os.Open(filename)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tdefer f.Close()\n+\n+\tdata := make([]byte, 16*1024)\n+\t_, err = io.ReadFull(f, data)\n+\tif err == io.ErrUnexpectedEOF {\n+\t\terr = nil\n+\t}\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\n+\tif bytes.HasPrefix(data, elfPrefix) {\n+\t\treturn readELFGoBuildID(filename, f, data)\n+\t}\n+\n+\ti := bytes.Index(data, goBuildPrefix)\n+\tif i < 0 {\n+\t\t// Missing. Treat as successful but build ID empty.\n+\t\treturn \"\", nil\n+\t}\n+\n+\tj := bytes.Index(data[i+len(goBuildPrefix):], goBuildEnd)\n+\tif j < 0 {\n+\t\treturn \"\", &os.PathError{Op: \"parse\", Path: filename, Err: errBuildIDMalformed}\n+\t}\n+\n+\tquoted := data[i+len(goBuildPrefix)-1 : i+len(goBuildPrefix)+j+1]\n+\tid, err = strconv.Unquote(string(quoted))\n+\tif err != nil {\n+\t\treturn \"\", &os.PathError{Op: \"parse\", Path: filename, Err: errBuildIDMalformed}\n+\t}\n+\n+\treturn id, nil\n+}"}, {"sha": "f6da373e2522d4b491a58af224859e8d862f39d9", "filename": "libgo/go/cmd/go/run.go", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Frun.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Frun.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Frun.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -37,7 +37,8 @@ Run compiles and runs the main package comprising the named Go source files.\n A Go source file is defined to be a file ending in a literal \".go\" suffix.\n \n By default, 'go run' runs the compiled binary directly: 'a.out arguments...'.\n-If the -exec flag is given, 'go run' invokes the binary using xprog: 'xprog a.out arguments...'.\n+If the -exec flag is given, 'go run' invokes the binary using xprog:\n+\t'xprog a.out arguments...'.\n If the -exec flag is not given, GOOS or GOARCH is different from the system\n default, and a program named go_$GOOS_$GOARCH_exec can be found\n on the current search path, 'go run' invokes the binary using that program,\n@@ -64,6 +65,7 @@ func printStderr(args ...interface{}) (int, error) {\n \n func runRun(cmd *Command, args []string) {\n \traceInit()\n+\tbuildModeInit()\n \tvar b builder\n \tb.init()\n \tb.print = printStderr\n@@ -136,6 +138,7 @@ func runStdin(cmdline []string) {\n \tcmd.Stdin = os.Stdin\n \tcmd.Stdout = os.Stdout\n \tcmd.Stderr = os.Stderr\n+\tcmd.Env = origEnv\n \tstartSigHandlers()\n \tif err := cmd.Run(); err != nil {\n \t\terrorf(\"%v\", err)"}, {"sha": "aadfdf67cceed41f22d9d9cae659ea56d326c534", "filename": "libgo/go/cmd/go/test.go", "status": "modified", "additions": 86, "deletions": 39, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftest.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -33,9 +33,11 @@ func init() {\n \tcmdTest.Run = runTest\n }\n \n+const testUsage = \"test [-c] [-i] [build and test flags] [packages] [flags for test binary]\"\n+\n var cmdTest = &Command{\n \tCustomFlags: true,\n-\tUsageLine:   \"test [-c] [-i] [build and test flags] [packages] [flags for test binary]\",\n+\tUsageLine:   testUsage,\n \tShort:       \"test packages\",\n \tLong: `\n 'Go test' automates testing the packages named by the import paths.\n@@ -64,6 +66,21 @@ with source in the current directory, including tests, and runs the tests.\n The package is built in a temporary directory so it does not interfere with the\n non-test installation.\n \n+` + strings.TrimSpace(testFlag1) + ` See 'go help testflag' for details.\n+\n+If the test binary needs any other flags, they should be presented after the\n+package names. The go tool treats as a flag the first argument that begins with\n+a minus sign that it does not recognize itself; that argument and all subsequent\n+arguments are passed as arguments to the test binary.\n+\n+For more about build flags, see 'go help build'.\n+For more about specifying packages, see 'go help packages'.\n+\n+See also: go build, go vet.\n+`,\n+}\n+\n+const testFlag1 = `\n In addition to the build flags, the flags handled by 'go test' itself are:\n \n \t-c\n@@ -83,21 +100,9 @@ In addition to the build flags, the flags handled by 'go test' itself are:\n \t\tCompile the test binary to the named file.\n \t\tThe test still runs (unless -c or -i is specified).\n \n-\n The test binary also accepts flags that control execution of the test; these\n-flags are also accessible by 'go test'.  See 'go help testflag' for details.\n-\n-If the test binary needs any other flags, they should be presented after the\n-package names. The go tool treats as a flag the first argument that begins with\n-a minus sign that it does not recognize itself; that argument and all subsequent\n-arguments are passed as arguments to the test binary.\n-\n-For more about build flags, see 'go help build'.\n-For more about specifying packages, see 'go help packages'.\n-\n-See also: go build, go vet.\n-`,\n-}\n+flags are also accessible by 'go test'.\n+`\n \n var helpTestflag = &Command{\n \tUsageLine: \"testflag\",\n@@ -107,13 +112,18 @@ The 'go test' command takes both flags that apply to 'go test' itself\n and flags that apply to the resulting test binary.\n \n Several of the flags control profiling and write an execution profile\n-suitable for \"go tool pprof\"; run \"go tool pprof help\" for more\n+suitable for \"go tool pprof\"; run \"go tool pprof -h\" for more\n information.  The --alloc_space, --alloc_objects, and --show_bytes\n options of pprof control how the information is presented.\n \n The following flags are recognized by the 'go test' command and\n control the execution of any test:\n \n+\t` + strings.TrimSpace(testFlag2) + `\n+`,\n+}\n+\n+const testFlag2 = `\n \t-bench regexp\n \t    Run benchmarks matching the regular expression.\n \t    By default, no benchmarks run. To run all benchmarks,\n@@ -135,12 +145,17 @@ control the execution of any test:\n \t-blockprofilerate n\n \t    Control the detail provided in goroutine blocking profiles by\n \t    calling runtime.SetBlockProfileRate with n.\n-\t    See 'godoc runtime SetBlockProfileRate'.\n+\t    See 'go doc runtime.SetBlockProfileRate'.\n \t    The profiler aims to sample, on average, one blocking event every\n \t    n nanoseconds the program spends blocked.  By default,\n \t    if -test.blockprofile is set without this flag, all blocking events\n \t    are recorded, equivalent to -test.blockprofilerate=1.\n \n+\t-count n\n+\t    Run each test and benchmark n times (default 1).\n+\t    If -cpu is set, run n times for each GOMAXPROCS value.\n+\t    Examples are always run once.\n+\n \t-cover\n \t    Enable coverage analysis.\n \n@@ -180,7 +195,7 @@ control the execution of any test:\n \n \t-memprofilerate n\n \t    Enable more precise (and expensive) memory profiles by setting\n-\t    runtime.MemProfileRate.  See 'godoc runtime MemProfileRate'.\n+\t    runtime.MemProfileRate.  See 'go doc runtime.MemProfileRate'.\n \t    To profile all memory allocations, use -test.memprofilerate=1\n \t    and pass --alloc_space flag to the pprof tool.\n \n@@ -205,6 +220,11 @@ control the execution of any test:\n \n \t-timeout t\n \t    If a test runs longer than t, panic.\n+\t    The default is 10 minutes (10m).\n+\n+\t-trace trace.out\n+\t    Write an execution trace to the specified file before exiting.\n+\t    Writes test binary as -c would.\n \n \t-v\n \t    Verbose output: log all tests as they are run. Also print all\n@@ -229,8 +249,7 @@ The test flags that generate profiles (other than for coverage) also\n leave the test binary in pkg.test for use when analyzing the profiles.\n \n Flags not recognized by 'go test' must be placed after any specified packages.\n-`,\n-}\n+`\n \n var helpTestfunc = &Command{\n \tUsageLine: \"testfunc\",\n@@ -310,6 +329,7 @@ func runTest(cmd *Command, args []string) {\n \tfindExecCmd() // initialize cached result\n \n \traceInit()\n+\tbuildModeInit()\n \tpkgs := packagesForBuild(pkgArgs)\n \tif len(pkgs) == 0 {\n \t\tfatalf(\"no packages to test\")\n@@ -342,11 +362,11 @@ func runTest(cmd *Command, args []string) {\n \t// been given on the command line (implicit current directory)\n \t// or when benchmarking.\n \t// Also stream if we're showing output anyway with a\n-\t// single package under test.  In that case, streaming the\n-\t// output produces the same result as not streaming,\n-\t// just more immediately.\n+\t// single package under test or if parallelism is set to 1.\n+\t// In these cases, streaming the output produces the same result\n+\t// as not streaming, just more immediately.\n \ttestStreamOutput = len(pkgArgs) == 0 || testBench ||\n-\t\t(len(pkgs) <= 1 && testShowPass)\n+\t\t(testShowPass && (len(pkgs) == 1 || buildP == 1))\n \n \tvar b builder\n \tb.init()\n@@ -364,10 +384,10 @@ func runTest(cmd *Command, args []string) {\n \t\t\tfor _, path := range p.Imports {\n \t\t\t\tdeps[path] = true\n \t\t\t}\n-\t\t\tfor _, path := range p.TestImports {\n+\t\t\tfor _, path := range p.vendored(p.TestImports) {\n \t\t\t\tdeps[path] = true\n \t\t\t}\n-\t\t\tfor _, path := range p.XTestImports {\n+\t\t\tfor _, path := range p.vendored(p.XTestImports) {\n \t\t\t\tdeps[path] = true\n \t\t\t}\n \t\t}\n@@ -376,7 +396,7 @@ func runTest(cmd *Command, args []string) {\n \t\tif deps[\"C\"] {\n \t\t\tdelete(deps, \"C\")\n \t\t\tdeps[\"runtime/cgo\"] = true\n-\t\t\tif buildContext.GOOS == runtime.GOOS && buildContext.GOARCH == runtime.GOARCH {\n+\t\t\tif goos == runtime.GOOS && goarch == runtime.GOARCH && !buildRace {\n \t\t\t\tdeps[\"cmd/cgo\"] = true\n \t\t\t}\n \t\t}\n@@ -428,6 +448,10 @@ func runTest(cmd *Command, args []string) {\n \n \t\t// Mark all the coverage packages for rebuilding with coverage.\n \t\tfor _, p := range testCoverPkgs {\n+\t\t\t// There is nothing to cover in package unsafe; it comes from the compiler.\n+\t\t\tif p.ImportPath == \"unsafe\" {\n+\t\t\t\tcontinue\n+\t\t\t}\n \t\t\tp.Stale = true // rebuild\n \t\t\tp.fake = true  // do not warn about rebuild\n \t\t\tp.coverMode = testCoverMode\n@@ -562,15 +586,20 @@ func (b *builder) test(p *Package) (buildAction, runAction, printAction *action,\n \tvar imports, ximports []*Package\n \tvar stk importStack\n \tstk.push(p.ImportPath + \" (test)\")\n-\tfor _, path := range p.TestImports {\n-\t\tp1 := loadImport(path, p.Dir, &stk, p.build.TestImportPos[path])\n+\tfor i, path := range p.TestImports {\n+\t\tp1 := loadImport(path, p.Dir, p, &stk, p.build.TestImportPos[path], useVendor)\n \t\tif !reqStdPkgSrc && p1.Standard {\n \t\t\tcontinue\n \t\t}\n \t\tif p1.Error != nil {\n \t\t\treturn nil, nil, nil, p1.Error\n \t\t}\n-\t\tif contains(p1.Deps, p.ImportPath) {\n+\t\tif len(p1.DepsErrors) > 0 {\n+\t\t\terr := p1.DepsErrors[0]\n+\t\t\terr.Pos = \"\" // show full import stack\n+\t\t\treturn nil, nil, nil, err\n+\t\t}\n+\t\tif contains(p1.Deps, p.ImportPath) || p1.ImportPath == p.ImportPath {\n \t\t\t// Same error that loadPackage returns (via reusePackage) in pkg.go.\n \t\t\t// Can't change that code, because that code is only for loading the\n \t\t\t// non-test copy of a package.\n@@ -581,24 +610,31 @@ func (b *builder) test(p *Package) (buildAction, runAction, printAction *action,\n \t\t\t}\n \t\t\treturn nil, nil, nil, err\n \t\t}\n+\t\tp.TestImports[i] = p1.ImportPath\n \t\timports = append(imports, p1)\n \t}\n \tstk.pop()\n \tstk.push(p.ImportPath + \"_test\")\n \tpxtestNeedsPtest := false\n-\tfor _, path := range p.XTestImports {\n-\t\tif path == p.ImportPath {\n-\t\t\tpxtestNeedsPtest = true\n-\t\t\tcontinue\n-\t\t}\n-\t\tp1 := loadImport(path, p.Dir, &stk, p.build.XTestImportPos[path])\n+\tfor i, path := range p.XTestImports {\n+\t\tp1 := loadImport(path, p.Dir, p, &stk, p.build.XTestImportPos[path], useVendor)\n \t\tif !reqStdPkgSrc && p1.Standard {\n \t\t\tcontinue\n \t\t}\n \t\tif p1.Error != nil {\n \t\t\treturn nil, nil, nil, p1.Error\n \t\t}\n-\t\tximports = append(ximports, p1)\n+\t\tif len(p1.DepsErrors) > 0 {\n+\t\t\terr := p1.DepsErrors[0]\n+\t\t\terr.Pos = \"\" // show full import stack\n+\t\t\treturn nil, nil, nil, err\n+\t\t}\n+\t\tif p1.ImportPath == p.ImportPath {\n+\t\t\tpxtestNeedsPtest = true\n+\t\t} else {\n+\t\t\tximports = append(ximports, p1)\n+\t\t}\n+\t\tp.XTestImports[i] = p1.ImportPath\n \t}\n \tstk.pop()\n \n@@ -723,7 +759,7 @@ func (b *builder) test(p *Package) (buildAction, runAction, printAction *action,\n \t\tif dep == ptest.ImportPath {\n \t\t\tpmain.imports = append(pmain.imports, ptest)\n \t\t} else {\n-\t\t\tp1 := loadImport(dep, \"\", &stk, nil)\n+\t\t\tp1 := loadImport(dep, \"\", nil, &stk, nil, 0)\n \t\t\tif !reqStdPkgSrc && p1.Standard {\n \t\t\t\tcontinue\n \t\t\t}\n@@ -781,6 +817,12 @@ func (b *builder) test(p *Package) (buildAction, runAction, printAction *action,\n \t\trecompileForTest(pmain, p, ptest, testDir)\n \t}\n \n+\tif buildContext.GOOS == \"darwin\" {\n+\t\tif buildContext.GOARCH == \"arm\" || buildContext.GOARCH == \"arm64\" {\n+\t\t\tt.NeedCgo = true\n+\t\t}\n+\t}\n+\n \tfor _, cp := range pmain.imports {\n \t\tif len(cp.coverVars) > 0 {\n \t\t\tt.Cover = append(t.Cover, coverInfo{cp, cp.coverVars})\n@@ -997,7 +1039,7 @@ func (b *builder) runTest(a *action) error {\n \n \tcmd := exec.Command(args[0], args[1:]...)\n \tcmd.Dir = a.p.Dir\n-\tcmd.Env = envForDir(cmd.Dir)\n+\tcmd.Env = envForDir(cmd.Dir, origEnv)\n \tvar buf bytes.Buffer\n \tif testStreamOutput {\n \t\tcmd.Stdout = os.Stdout\n@@ -1216,6 +1258,7 @@ type testFuncs struct {\n \tNeedTest    bool\n \tImportXtest bool\n \tNeedXtest   bool\n+\tNeedCgo     bool\n \tCover       []coverInfo\n }\n \n@@ -1319,6 +1362,10 @@ import (\n {{range $i, $p := .Cover}}\n \t_cover{{$i}} {{$p.Package.ImportPath | printf \"%q\"}}\n {{end}}\n+\n+{{if .NeedCgo}}\n+\t_ \"runtime/cgo\"\n+{{end}}\n )\n \n var tests = []testing.InternalTest{"}, {"sha": "3d6a8a5c7420fe33031ced2907aa1f89eed3a15c", "filename": "libgo/go/cmd/go/testdata/generate/test3.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fgenerate%2Ftest3.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fgenerate%2Ftest3.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fgenerate%2Ftest3.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -4,6 +4,6 @@\n \n // Test go generate variable substitution.\n \n-//go:generate echo $GOARCH $GOFILE $GOPACKAGE xyz$GOPACKAGE/$GOFILE/123\n+//go:generate echo $GOARCH $GOFILE:$GOLINE ${GOPACKAGE}abc xyz$GOPACKAGE/$GOFILE/123\n \n package p"}, {"sha": "a7631c4a45652c6dbdb050911a3bccdd463d7314", "filename": "libgo/go/cmd/go/testdata/generate/test4.go", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fgenerate%2Ftest4.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fgenerate%2Ftest4.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fgenerate%2Ftest4.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -0,0 +1,10 @@\n+// Copyright 2015 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Test -run flag\n+\n+//go:generate echo oh yes my man\n+//go:generate echo no, no, a thousand times no\n+\n+package p"}, {"sha": "06ab7d0f9a35a7d1070711496d6ca1cb892a258f", "filename": "libgo/go/cmd/go/testdata/rundir/sub/sub.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Frundir%2Fsub%2Fsub.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Frundir%2Fsub%2Fsub.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Frundir%2Fsub%2Fsub.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -0,0 +1 @@\n+package main"}, {"sha": "06ab7d0f9a35a7d1070711496d6ca1cb892a258f", "filename": "libgo/go/cmd/go/testdata/rundir/x.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Frundir%2Fx.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Frundir%2Fx.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Frundir%2Fx.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -0,0 +1 @@\n+package main"}, {"sha": "7a471f0cc05a38b6c173ada43a7a68e82968456d", "filename": "libgo/go/cmd/go/testdata/src/testcycle/q1/q1.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fq1%2Fq1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fq1%2Fq1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fq1%2Fq1.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -0,0 +1 @@\n+package q1"}, {"sha": "ca81bd2bf80b18f01b6a8248a7999fe3d7d20b00", "filename": "libgo/go/cmd/go/testdata/src/testcycle/q1/q1_test.go", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fq1%2Fq1_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fq1%2Fq1_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fq1%2Fq1_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -0,0 +1,6 @@\n+package q1\n+\n+import \"testing\"\n+import _ \"testcycle/q1\"\n+\n+func Test(t *testing.T) {}"}, {"sha": "a457035a4300f39249b3b263624b537909bd2951", "filename": "libgo/go/cmd/go/testdata/src/testdep/p1/p1.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestdep%2Fp1%2Fp1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestdep%2Fp1%2Fp1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestdep%2Fp1%2Fp1.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -0,0 +1 @@\n+package p1"}, {"sha": "8be75334425d606a4070f7e7be41ee83f8d760cb", "filename": "libgo/go/cmd/go/testdata/src/testdep/p1/p1_test.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestdep%2Fp1%2Fp1_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestdep%2Fp1%2Fp1_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestdep%2Fp1%2Fp1_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -0,0 +1,3 @@\n+package p1\n+\n+import _ \"testdep/p2\""}, {"sha": "15ba2eacea5c6e4a26884238c7f98f0149132f71", "filename": "libgo/go/cmd/go/testdata/src/testdep/p2/p2.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestdep%2Fp2%2Fp2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestdep%2Fp2%2Fp2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestdep%2Fp2%2Fp2.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -0,0 +1,3 @@\n+package p2\n+\n+import _ \"testdep/p3\""}, {"sha": "0219e7fae507e173b49c71e668b8fd2811715178", "filename": "libgo/go/cmd/go/testdata/src/testdep/p3/p3.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestdep%2Fp3%2Fp3.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestdep%2Fp3%2Fp3.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestdep%2Fp3%2Fp3.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -0,0 +1,3 @@\n+// +build ignore\n+\n+package ignored"}, {"sha": "57cc595220c50d5941a245734f0a2ed8a6592192", "filename": "libgo/go/cmd/go/testdata/src/vend/bad.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fbad.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fbad.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fbad.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -0,0 +1,3 @@\n+package vend\n+\n+import _ \"r\""}, {"sha": "952ada3108d34828f0ae101e11e93ef69260d587", "filename": "libgo/go/cmd/go/testdata/src/vend/good.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fgood.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fgood.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fgood.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -0,0 +1,3 @@\n+package vend\n+\n+import _ \"p\""}, {"sha": "41dc03e0ce497d99597d06ddd15ff6f55635b874", "filename": "libgo/go/cmd/go/testdata/src/vend/hello/hello.go", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fhello%2Fhello.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fhello%2Fhello.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fhello%2Fhello.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -0,0 +1,10 @@\n+package main\n+\n+import (\n+\t\"fmt\"\n+\t\"strings\" // really ../vendor/strings\n+)\n+\n+func main() {\n+\tfmt.Printf(\"%s\\n\", strings.Msg)\n+}"}, {"sha": "5e72ada9387a7a79d903d8557b214c0899c432d5", "filename": "libgo/go/cmd/go/testdata/src/vend/hello/hello_test.go", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fhello%2Fhello_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fhello%2Fhello_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fhello%2Fhello_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -0,0 +1,12 @@\n+package main\n+\n+import (\n+\t\"strings\" // really ../vendor/strings\n+\t\"testing\"\n+)\n+\n+func TestMsgInternal(t *testing.T) {\n+\tif strings.Msg != \"hello, world\" {\n+\t\tt.Fatal(\"unexpected msg: %v\", strings.Msg)\n+\t}\n+}"}, {"sha": "96e6049dad0ae1642f9fbdcb3a91917675ecd52d", "filename": "libgo/go/cmd/go/testdata/src/vend/hello/hellox_test.go", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fhello%2Fhellox_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fhello%2Fhellox_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fhello%2Fhellox_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -0,0 +1,12 @@\n+package main_test\n+\n+import (\n+\t\"strings\" // really ../vendor/strings\n+\t\"testing\"\n+)\n+\n+func TestMsgExternal(t *testing.T) {\n+\tif strings.Msg != \"hello, world\" {\n+\t\tt.Fatal(\"unexpected msg: %v\", strings.Msg)\n+\t}\n+}"}, {"sha": "d0ddaacfea5df6464c0f185d477c9ded6ee09150", "filename": "libgo/go/cmd/go/testdata/src/vend/subdir/bad.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fsubdir%2Fbad.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fsubdir%2Fbad.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fsubdir%2Fbad.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -0,0 +1,3 @@\n+package subdir\n+\n+import _ \"r\""}, {"sha": "edd04543a2bad09f53b1f4fd50a2502f80d16e3b", "filename": "libgo/go/cmd/go/testdata/src/vend/subdir/good.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fsubdir%2Fgood.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fsubdir%2Fgood.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fsubdir%2Fgood.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -0,0 +1,3 @@\n+package subdir\n+\n+import _ \"p\""}, {"sha": "c89cd18d0fe7d777c6008d0d9133c5bb808be6fc", "filename": "libgo/go/cmd/go/testdata/src/vend/vendor/p/p.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fvendor%2Fp%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fvendor%2Fp%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fvendor%2Fp%2Fp.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -0,0 +1 @@\n+package p"}, {"sha": "946e6d99109580d53b402a34fd8b55226b9e564d", "filename": "libgo/go/cmd/go/testdata/src/vend/vendor/q/q.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fvendor%2Fq%2Fq.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fvendor%2Fq%2Fq.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fvendor%2Fq%2Fq.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -0,0 +1 @@\n+package q"}, {"sha": "438126ba2be59819a8e2710480eccd897f9cdf9b", "filename": "libgo/go/cmd/go/testdata/src/vend/vendor/strings/msg.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fvendor%2Fstrings%2Fmsg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fvendor%2Fstrings%2Fmsg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fvendor%2Fstrings%2Fmsg.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -0,0 +1,3 @@\n+package strings\n+\n+var Msg = \"hello, world\""}, {"sha": "e250d5bb31b563a4fdbb958fb034d7fa388fe38a", "filename": "libgo/go/cmd/go/testdata/src/vend/x/invalid/invalid.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fx%2Finvalid%2Finvalid.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fx%2Finvalid%2Finvalid.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fx%2Finvalid%2Finvalid.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -0,0 +1,3 @@\n+package invalid\n+\n+import \"vend/x/invalid/vendor/foo\""}, {"sha": "c89cd18d0fe7d777c6008d0d9133c5bb808be6fc", "filename": "libgo/go/cmd/go/testdata/src/vend/x/vendor/p/p.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fx%2Fvendor%2Fp%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fx%2Fvendor%2Fp%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fx%2Fvendor%2Fp%2Fp.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -0,0 +1 @@\n+package p"}, {"sha": "e12e12c2f4c9c738561a10ce54e8afcaa17fb9ef", "filename": "libgo/go/cmd/go/testdata/src/vend/x/vendor/p/p/p.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fx%2Fvendor%2Fp%2Fp%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fx%2Fvendor%2Fp%2Fp%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fx%2Fvendor%2Fp%2Fp%2Fp.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -0,0 +1,3 @@\n+package p\n+\n+import _ \"notfound\""}, {"sha": "838c177a570f958653822675e6dc4079e5c472af", "filename": "libgo/go/cmd/go/testdata/src/vend/x/vendor/r/r.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fx%2Fvendor%2Fr%2Fr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fx%2Fvendor%2Fr%2Fr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fx%2Fvendor%2Fr%2Fr.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -0,0 +1 @@\n+package r"}, {"sha": "ae526ebdda252e8fb618fb5b6f90e5ab6902a432", "filename": "libgo/go/cmd/go/testdata/src/vend/x/x.go", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fx%2Fx.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fx%2Fx.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvend%2Fx%2Fx.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -0,0 +1,5 @@\n+package x\n+\n+import _ \"p\"\n+import _ \"q\"\n+import _ \"r\""}, {"sha": "ef5648f0590c42e9b6d7a3ee4049fca0feb3ae00", "filename": "libgo/go/cmd/go/testdata/src/vetpkg/c.go", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetpkg%2Fc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetpkg%2Fc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetpkg%2Fc.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -0,0 +1,9 @@\n+// +build tagtest\n+\n+package p\n+\n+import \"fmt\"\n+\n+func g() {\n+\tfmt.Printf(\"%d\", 3, 4)\n+}"}, {"sha": "8576a4b4d76d6220a56482e722a58712fb50ae14", "filename": "libgo/go/cmd/go/testdata/testinternal3/t.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal3%2Ft.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal3%2Ft.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal3%2Ft.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -0,0 +1,3 @@\n+package t\n+\n+import _ \"internal/does-not-exist\""}, {"sha": "6bdee27be2f9577b633f5c889bd0ed60050aa366", "filename": "libgo/go/cmd/go/testdata/testinternal4/src/p/p.go", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal4%2Fsrc%2Fp%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal4%2Fsrc%2Fp%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal4%2Fsrc%2Fp%2Fp.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -0,0 +1,6 @@\n+package p\n+\n+import (\n+\t_ \"q/internal/x\"\n+\t_ \"q/j\"\n+)"}, {"sha": "823aafd0712b6c533df84b17d9b7ac6ae43e66fa", "filename": "libgo/go/cmd/go/testdata/testinternal4/src/q/internal/x/x.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal4%2Fsrc%2Fq%2Finternal%2Fx%2Fx.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal4%2Fsrc%2Fq%2Finternal%2Fx%2Fx.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal4%2Fsrc%2Fq%2Finternal%2Fx%2Fx.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -0,0 +1 @@\n+package x"}, {"sha": "9f07543894098fa018424fb6fc0eff05b4682466", "filename": "libgo/go/cmd/go/testdata/testinternal4/src/q/j/j.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal4%2Fsrc%2Fq%2Fj%2Fj.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal4%2Fsrc%2Fq%2Fj%2Fj.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal4%2Fsrc%2Fq%2Fj%2Fj.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -0,0 +1,3 @@\n+package j\n+\n+import _ \"q/internal/x\""}, {"sha": "e740715186ebf6695594700c00042ee8fc8fb468", "filename": "libgo/go/cmd/go/testdata/testvendor/src/p/p.go", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestvendor%2Fsrc%2Fp%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestvendor%2Fsrc%2Fp%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestvendor%2Fsrc%2Fp%2Fp.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -0,0 +1,6 @@\n+package p\n+\n+import (\n+\t_ \"q/y\"\n+\t_ \"q/z\"\n+)"}, {"sha": "823aafd0712b6c533df84b17d9b7ac6ae43e66fa", "filename": "libgo/go/cmd/go/testdata/testvendor/src/q/vendor/x/x.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestvendor%2Fsrc%2Fq%2Fvendor%2Fx%2Fx.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestvendor%2Fsrc%2Fq%2Fvendor%2Fx%2Fx.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestvendor%2Fsrc%2Fq%2Fvendor%2Fx%2Fx.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -0,0 +1 @@\n+package x"}, {"sha": "4f842237675a424ea2e20029ec4fd4c5cbfd0d1e", "filename": "libgo/go/cmd/go/testdata/testvendor/src/q/y/y.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestvendor%2Fsrc%2Fq%2Fy%2Fy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestvendor%2Fsrc%2Fq%2Fy%2Fy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestvendor%2Fsrc%2Fq%2Fy%2Fy.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -0,0 +1,3 @@\n+package y\n+\n+import _ \"x\""}, {"sha": "a8d4924936a7a5d7e4bc88b8ab9e5a9d20c26627", "filename": "libgo/go/cmd/go/testdata/testvendor/src/q/z/z.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestvendor%2Fsrc%2Fq%2Fz%2Fz.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestvendor%2Fsrc%2Fq%2Fz%2Fz.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestvendor%2Fsrc%2Fq%2Fz%2Fz.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -0,0 +1,3 @@\n+package z\n+\n+import _ \"q/vendor/x\""}, {"sha": "220b2b2a0712eabd10461cb354842501785282d6", "filename": "libgo/go/cmd/go/testdata/testvendor2/src/p/p.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestvendor2%2Fsrc%2Fp%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestvendor2%2Fsrc%2Fp%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestvendor2%2Fsrc%2Fp%2Fp.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -0,0 +1,3 @@\n+package p\n+\n+import \"x\""}, {"sha": "823aafd0712b6c533df84b17d9b7ac6ae43e66fa", "filename": "libgo/go/cmd/go/testdata/testvendor2/vendor/x/x.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestvendor2%2Fvendor%2Fx%2Fx.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestvendor2%2Fvendor%2Fx%2Fx.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestvendor2%2Fvendor%2Fx%2Fx.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -0,0 +1 @@\n+package x"}, {"sha": "1f3e3d316af5a8794e8746e6617d9a943a5fc3a3", "filename": "libgo/go/cmd/go/testflag.go", "status": "modified", "additions": 81, "deletions": 119, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftestflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestflag.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -5,6 +5,7 @@\n package main\n \n import (\n+\t\"flag\"\n \t\"fmt\"\n \t\"os\"\n \t\"strconv\"\n@@ -16,46 +17,11 @@ import (\n // our command line are for us, and some are for 6.out, and\n // some are for both.\n \n-var usageMessage = `Usage of go test:\n-  -c=false: compile but do not run the test binary\n-  -file=file_test.go: specify file to use for tests;\n-      use multiple times for multiple files\n-  -p=n: build and test up to n packages in parallel\n-  -x=false: print command lines as they are executed\n-\n-  // These flags can be passed with or without a \"test.\" prefix: -v or -test.v.\n-  -bench=\"\": passes -test.bench to test\n-  -benchmem=false: print memory allocation statistics for benchmarks\n-  -benchtime=1s: passes -test.benchtime to test\n-  -cover=false: enable coverage analysis\n-  -covermode=\"set\": specifies mode for coverage analysis\n-  -coverpkg=\"\": comma-separated list of packages for coverage analysis\n-  -coverprofile=\"\": passes -test.coverprofile to test if -cover\n-  -cpu=\"\": passes -test.cpu to test\n-  -cpuprofile=\"\": passes -test.cpuprofile to test\n-  -memprofile=\"\": passes -test.memprofile to test\n-  -memprofilerate=0: passes -test.memprofilerate to test\n-  -blockprofile=\"\": pases -test.blockprofile to test\n-  -blockprofilerate=0: passes -test.blockprofilerate to test\n-  -outputdir=$PWD: passes -test.outputdir to test\n-  -parallel=0: passes -test.parallel to test\n-  -run=\"\": passes -test.run to test\n-  -short=false: passes -test.short to test\n-  -timeout=0: passes -test.timeout to test\n-  -v=false: passes -test.v to test\n-`\n-\n-// usage prints a usage message and exits.\n-func testUsage() {\n-\tfmt.Fprint(os.Stderr, usageMessage)\n-\tsetExitStatus(2)\n-\texit()\n-}\n-\n // testFlagSpec defines a flag we know about.\n type testFlagSpec struct {\n \tname       string\n \tboolVar    *bool\n+\tflagValue  flag.Value\n \tpassToTest bool // pass to Test\n \tmultiOK    bool // OK to have multiple instances\n \tpresent    bool // flag has been seen\n@@ -65,32 +31,18 @@ type testFlagSpec struct {\n var testFlagDefn = []*testFlagSpec{\n \t// local.\n \t{name: \"c\", boolVar: &testC},\n+\t{name: \"i\", boolVar: &buildI},\n+\t{name: \"o\"},\n \t{name: \"cover\", boolVar: &testCover},\n+\t{name: \"covermode\"},\n \t{name: \"coverpkg\"},\n-\t{name: \"o\"},\n-\n-\t// build flags.\n-\t{name: \"a\", boolVar: &buildA},\n-\t{name: \"n\", boolVar: &buildN},\n-\t{name: \"p\"},\n-\t{name: \"x\", boolVar: &buildX},\n-\t{name: \"i\", boolVar: &buildI},\n-\t{name: \"work\", boolVar: &buildWork},\n-\t{name: \"ccflags\"},\n-\t{name: \"gcflags\"},\n \t{name: \"exec\"},\n-\t{name: \"ldflags\"},\n-\t{name: \"gccgoflags\"},\n-\t{name: \"tags\"},\n-\t{name: \"compiler\"},\n-\t{name: \"race\", boolVar: &buildRace},\n-\t{name: \"installsuffix\"},\n \n \t// passed to 6.out, adding a \"test.\" prefix to the name if necessary: -v becomes -test.v.\n \t{name: \"bench\", passToTest: true},\n \t{name: \"benchmem\", boolVar: new(bool), passToTest: true},\n \t{name: \"benchtime\", passToTest: true},\n-\t{name: \"covermode\"},\n+\t{name: \"count\", passToTest: true},\n \t{name: \"coverprofile\", passToTest: true},\n \t{name: \"cpu\", passToTest: true},\n \t{name: \"cpuprofile\", passToTest: true},\n@@ -103,9 +55,26 @@ var testFlagDefn = []*testFlagSpec{\n \t{name: \"run\", passToTest: true},\n \t{name: \"short\", boolVar: new(bool), passToTest: true},\n \t{name: \"timeout\", passToTest: true},\n+\t{name: \"trace\", passToTest: true},\n \t{name: \"v\", boolVar: &testV, passToTest: true},\n }\n \n+// add build flags to testFlagDefn\n+func init() {\n+\tvar cmd Command\n+\taddBuildFlags(&cmd)\n+\tcmd.Flag.VisitAll(func(f *flag.Flag) {\n+\t\tif f.Name == \"v\" {\n+\t\t\t// test overrides the build -v flag\n+\t\t\treturn\n+\t\t}\n+\t\ttestFlagDefn = append(testFlagDefn, &testFlagSpec{\n+\t\t\tname:      f.Name,\n+\t\t\tflagValue: f.Value,\n+\t\t})\n+\t})\n+}\n+\n // testFlags processes the command line, grabbing -x and -c, rewriting known flags\n // to have \"test\" before them, and reading the command line for the 6.out.\n // Unfortunately for us, we need to do our own flag processing because go test\n@@ -148,73 +117,55 @@ func testFlags(args []string) (packageNames, passToTest []string) {\n \t\t\tpassToTest = append(passToTest, args[i])\n \t\t\tcontinue\n \t\t}\n-\t\tvar err error\n-\t\tswitch f.name {\n-\t\t// bool flags.\n-\t\tcase \"a\", \"c\", \"i\", \"n\", \"x\", \"v\", \"race\", \"cover\", \"work\":\n-\t\t\tsetBoolFlag(f.boolVar, value)\n-\t\tcase \"o\":\n-\t\t\ttestO = value\n-\t\t\ttestNeedBinary = true\n-\t\tcase \"p\":\n-\t\t\tsetIntFlag(&buildP, value)\n-\t\tcase \"exec\":\n-\t\t\texecCmd, err = splitQuotedFields(value)\n-\t\t\tif err != nil {\n+\t\tif f.flagValue != nil {\n+\t\t\tif err := f.flagValue.Set(value); err != nil {\n \t\t\t\tfatalf(\"invalid flag argument for -%s: %v\", f.name, err)\n \t\t\t}\n-\t\tcase \"ccflags\":\n-\t\t\tbuildCcflags, err = splitQuotedFields(value)\n-\t\t\tif err != nil {\n-\t\t\t\tfatalf(\"invalid flag argument for -%s: %v\", f.name, err)\n-\t\t\t}\n-\t\tcase \"gcflags\":\n-\t\t\tbuildGcflags, err = splitQuotedFields(value)\n-\t\t\tif err != nil {\n-\t\t\t\tfatalf(\"invalid flag argument for -%s: %v\", f.name, err)\n-\t\t\t}\n-\t\tcase \"ldflags\":\n-\t\t\tbuildLdflags, err = splitQuotedFields(value)\n-\t\t\tif err != nil {\n-\t\t\t\tfatalf(\"invalid flag argument for -%s: %v\", f.name, err)\n-\t\t\t}\n-\t\tcase \"gccgoflags\":\n-\t\t\tbuildGccgoflags, err = splitQuotedFields(value)\n-\t\t\tif err != nil {\n-\t\t\t\tfatalf(\"invalid flag argument for -%s: %v\", f.name, err)\n-\t\t\t}\n-\t\tcase \"tags\":\n-\t\t\tbuildContext.BuildTags = strings.Fields(value)\n-\t\tcase \"compiler\":\n-\t\t\tbuildCompiler{}.Set(value)\n-\t\tcase \"bench\":\n-\t\t\t// record that we saw the flag; don't care about the value\n-\t\t\ttestBench = true\n-\t\tcase \"timeout\":\n-\t\t\ttestTimeout = value\n-\t\tcase \"blockprofile\", \"cpuprofile\", \"memprofile\":\n-\t\t\ttestProfile = true\n-\t\t\ttestNeedBinary = true\n-\t\tcase \"coverpkg\":\n-\t\t\ttestCover = true\n-\t\t\tif value == \"\" {\n-\t\t\t\ttestCoverPaths = nil\n-\t\t\t} else {\n-\t\t\t\ttestCoverPaths = strings.Split(value, \",\")\n-\t\t\t}\n-\t\tcase \"coverprofile\":\n-\t\t\ttestCover = true\n-\t\t\ttestProfile = true\n-\t\tcase \"covermode\":\n-\t\t\tswitch value {\n-\t\t\tcase \"set\", \"count\", \"atomic\":\n-\t\t\t\ttestCoverMode = value\n-\t\t\tdefault:\n-\t\t\t\tfatalf(\"invalid flag argument for -cover: %q\", value)\n+\t\t} else {\n+\t\t\t// Test-only flags.\n+\t\t\t// Arguably should be handled by f.flagValue, but aren't.\n+\t\t\tvar err error\n+\t\t\tswitch f.name {\n+\t\t\t// bool flags.\n+\t\t\tcase \"c\", \"i\", \"v\", \"cover\":\n+\t\t\t\tsetBoolFlag(f.boolVar, value)\n+\t\t\tcase \"o\":\n+\t\t\t\ttestO = value\n+\t\t\t\ttestNeedBinary = true\n+\t\t\tcase \"exec\":\n+\t\t\t\texecCmd, err = splitQuotedFields(value)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tfatalf(\"invalid flag argument for -%s: %v\", f.name, err)\n+\t\t\t\t}\n+\t\t\tcase \"bench\":\n+\t\t\t\t// record that we saw the flag; don't care about the value\n+\t\t\t\ttestBench = true\n+\t\t\tcase \"timeout\":\n+\t\t\t\ttestTimeout = value\n+\t\t\tcase \"blockprofile\", \"cpuprofile\", \"memprofile\", \"trace\":\n+\t\t\t\ttestProfile = true\n+\t\t\t\ttestNeedBinary = true\n+\t\t\tcase \"coverpkg\":\n+\t\t\t\ttestCover = true\n+\t\t\t\tif value == \"\" {\n+\t\t\t\t\ttestCoverPaths = nil\n+\t\t\t\t} else {\n+\t\t\t\t\ttestCoverPaths = strings.Split(value, \",\")\n+\t\t\t\t}\n+\t\t\tcase \"coverprofile\":\n+\t\t\t\ttestCover = true\n+\t\t\t\ttestProfile = true\n+\t\t\tcase \"covermode\":\n+\t\t\t\tswitch value {\n+\t\t\t\tcase \"set\", \"count\", \"atomic\":\n+\t\t\t\t\ttestCoverMode = value\n+\t\t\t\tdefault:\n+\t\t\t\t\tfatalf(\"invalid flag argument for -covermode: %q\", value)\n+\t\t\t\t}\n+\t\t\t\ttestCover = true\n+\t\t\tcase \"outputdir\":\n+\t\t\t\toutputDir = value\n \t\t\t}\n-\t\t\ttestCover = true\n-\t\tcase \"outputdir\":\n-\t\t\toutputDir = value\n \t\t}\n \t\tif extraWord {\n \t\t\ti++\n@@ -267,7 +218,7 @@ func testFlag(args []string, i int) (f *testFlagSpec, value string, extra bool)\n \tfor _, f = range testFlagDefn {\n \t\tif name == f.name {\n \t\t\t// Booleans are special because they have modes -x, -x=true, -x=false.\n-\t\t\tif f.boolVar != nil {\n+\t\t\tif f.boolVar != nil || isBoolFlag(f.flagValue) {\n \t\t\t\tif equals < 0 { // otherwise, it's been set and will be verified in setBoolFlag\n \t\t\t\t\tvalue = \"true\"\n \t\t\t\t} else {\n@@ -294,6 +245,17 @@ func testFlag(args []string, i int) (f *testFlagSpec, value string, extra bool)\n \treturn\n }\n \n+// isBoolFlag reports whether v is a bool flag.\n+func isBoolFlag(v flag.Value) bool {\n+\tvv, ok := v.(interface {\n+\t\tIsBoolFlag() bool\n+\t})\n+\tif ok {\n+\t\treturn vv.IsBoolFlag()\n+\t}\n+\treturn false\n+}\n+\n // setBoolFlag sets the addressed boolean to the value.\n func setBoolFlag(flag *bool, value string) {\n \tx, err := strconv.ParseBool(value)"}, {"sha": "937ca1f306cf025eb5124c6cfc86950d8c132e83", "filename": "libgo/go/cmd/go/tool.go", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftool.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Ftool.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftool.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -50,6 +50,9 @@ func tool(toolName string) string {\n \tif toolIsWindows {\n \t\ttoolPath += toolWindowsExtension\n \t}\n+\tif len(buildToolExec) > 0 {\n+\t\treturn toolPath\n+\t}\n \t// Give a nice message if there is no tool with that name.\n \tif _, err := os.Stat(toolPath); err != nil {\n \t\tif isInGoToolsRepo(toolName) {\n@@ -64,10 +67,6 @@ func tool(toolName string) string {\n }\n \n func isInGoToolsRepo(toolName string) bool {\n-\tswitch toolName {\n-\tcase \"cover\", \"vet\":\n-\t\treturn true\n-\t}\n \treturn false\n }\n \n@@ -92,7 +91,11 @@ func runTool(cmd *Command, args []string) {\n \t\treturn\n \t}\n \tif toolN {\n-\t\tfmt.Printf(\"%s %s\\n\", toolPath, strings.Join(args[1:], \" \"))\n+\t\tcmd := toolPath\n+\t\tif len(args) > 1 {\n+\t\t\tcmd += \" \" + strings.Join(args[1:], \" \")\n+\t\t}\n+\t\tfmt.Printf(\"%s\\n\", cmd)\n \t\treturn\n \t}\n \ttoolCmd := &exec.Cmd{\n@@ -101,6 +104,8 @@ func runTool(cmd *Command, args []string) {\n \t\tStdin:  os.Stdin,\n \t\tStdout: os.Stdout,\n \t\tStderr: os.Stderr,\n+\t\t// Set $GOROOT, mainly for go tool dist.\n+\t\tEnv: mergeEnvLists([]string{\"GOROOT=\" + goroot}, os.Environ()),\n \t}\n \terr := toolCmd.Run()\n \tif err != nil {"}, {"sha": "28a7540dfe43c0b14f929e94051a74eb6b1ae399", "filename": "libgo/go/cmd/go/vcs.go", "status": "modified", "additions": 280, "deletions": 98, "changes": 378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Fvcs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Fvcs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fvcs.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -9,12 +9,15 @@ import (\n \t\"encoding/json\"\n \t\"errors\"\n \t\"fmt\"\n+\t\"internal/singleflight\"\n \t\"log\"\n+\t\"net/url\"\n \t\"os\"\n \t\"os/exec\"\n \t\"path/filepath\"\n \t\"regexp\"\n \t\"strings\"\n+\t\"sync\"\n )\n \n // A vcsCmd describes how to use a version control system\n@@ -23,13 +26,13 @@ type vcsCmd struct {\n \tname string\n \tcmd  string // name of binary to invoke command\n \n-\tcreateCmd   string // command to download a fresh copy of a repository\n-\tdownloadCmd string // command to download updates into an existing repository\n+\tcreateCmd   []string // commands to download a fresh copy of a repository\n+\tdownloadCmd []string // commands to download updates into an existing repository\n \n \ttagCmd         []tagCmd // commands to list tags\n \ttagLookupCmd   []tagCmd // commands to lookup tags before running tagSyncCmd\n-\ttagSyncCmd     string   // command to sync to specific tag\n-\ttagSyncDefault string   // command to sync to default tag\n+\ttagSyncCmd     []string // commands to sync to specific tag\n+\ttagSyncDefault []string // commands to sync to default tag\n \n \tscheme  []string\n \tpingCmd string\n@@ -38,6 +41,23 @@ type vcsCmd struct {\n \tresolveRepo func(v *vcsCmd, rootDir, remoteRepo string) (realRepo string, err error)\n }\n \n+var isSecureScheme = map[string]bool{\n+\t\"https\":   true,\n+\t\"git+ssh\": true,\n+\t\"bzr+ssh\": true,\n+\t\"svn+ssh\": true,\n+\t\"ssh\":     true,\n+}\n+\n+func (v *vcsCmd) isSecure(repo string) bool {\n+\tu, err := url.Parse(repo)\n+\tif err != nil {\n+\t\t// If repo is not a URL, it's not secure.\n+\t\treturn false\n+\t}\n+\treturn isSecureScheme[u.Scheme]\n+}\n+\n // A tagCmd describes a command to list available tags\n // that can be passed to tagSyncCmd.\n type tagCmd struct {\n@@ -69,8 +89,8 @@ var vcsHg = &vcsCmd{\n \tname: \"Mercurial\",\n \tcmd:  \"hg\",\n \n-\tcreateCmd:   \"clone -U {repo} {dir}\",\n-\tdownloadCmd: \"pull\",\n+\tcreateCmd:   []string{\"clone -U {repo} {dir}\"},\n+\tdownloadCmd: []string{\"pull\"},\n \n \t// We allow both tag and branch names as 'tags'\n \t// for selecting a version.  This lets people have\n@@ -81,8 +101,8 @@ var vcsHg = &vcsCmd{\n \t\t{\"tags\", `^(\\S+)`},\n \t\t{\"branches\", `^(\\S+)`},\n \t},\n-\ttagSyncCmd:     \"update -r {tag}\",\n-\ttagSyncDefault: \"update default\",\n+\ttagSyncCmd:     []string{\"update -r {tag}\"},\n+\ttagSyncDefault: []string{\"update default\"},\n \n \tscheme:     []string{\"https\", \"http\", \"ssh\"},\n \tpingCmd:    \"identify {scheme}://{repo}\",\n@@ -102,8 +122,8 @@ var vcsGit = &vcsCmd{\n \tname: \"Git\",\n \tcmd:  \"git\",\n \n-\tcreateCmd:   \"clone {repo} {dir}\",\n-\tdownloadCmd: \"pull --ff-only\",\n+\tcreateCmd:   []string{\"clone {repo} {dir}\", \"--git-dir={dir}/.git submodule update --init --recursive\"},\n+\tdownloadCmd: []string{\"pull --ff-only\", \"submodule update --init --recursive\"},\n \n \ttagCmd: []tagCmd{\n \t\t// tags/xxx matches a git tag named xxx\n@@ -113,57 +133,80 @@ var vcsGit = &vcsCmd{\n \ttagLookupCmd: []tagCmd{\n \t\t{\"show-ref tags/{tag} origin/{tag}\", `((?:tags|origin)/\\S+)$`},\n \t},\n-\ttagSyncCmd:     \"checkout {tag}\",\n-\ttagSyncDefault: \"checkout master\",\n-\n-\tscheme:     []string{\"git\", \"https\", \"http\", \"git+ssh\"},\n+\ttagSyncCmd: []string{\"checkout {tag}\", \"submodule update --init --recursive\"},\n+\t// both createCmd and downloadCmd update the working dir.\n+\t// No need to do more here. We used to 'checkout master'\n+\t// but that doesn't work if the default branch is not named master.\n+\t// See golang.org/issue/9032.\n+\ttagSyncDefault: []string{\"checkout master\", \"submodule update --init --recursive\"},\n+\n+\tscheme:     []string{\"git\", \"https\", \"http\", \"git+ssh\", \"ssh\"},\n \tpingCmd:    \"ls-remote {scheme}://{repo}\",\n \tremoteRepo: gitRemoteRepo,\n }\n \n+// scpSyntaxRe matches the SCP-like addresses used by Git to access\n+// repositories by SSH.\n+var scpSyntaxRe = regexp.MustCompile(`^([a-zA-Z0-9_]+)@([a-zA-Z0-9._-]+):(.*)$`)\n+\n func gitRemoteRepo(vcsGit *vcsCmd, rootDir string) (remoteRepo string, err error) {\n-\toutb, err := vcsGit.runOutput(rootDir, \"remote -v\")\n+\tcmd := \"config remote.origin.url\"\n+\terrParse := errors.New(\"unable to parse output of git \" + cmd)\n+\terrRemoteOriginNotFound := errors.New(\"remote origin not found\")\n+\toutb, err := vcsGit.run1(rootDir, cmd, nil, false)\n \tif err != nil {\n+\t\t// if it doesn't output any message, it means the config argument is correct,\n+\t\t// but the config value itself doesn't exist\n+\t\tif outb != nil && len(outb) == 0 {\n+\t\t\treturn \"\", errRemoteOriginNotFound\n+\t\t}\n \t\treturn \"\", err\n \t}\n-\tout := string(outb)\n-\n-\t// Expect:\n-\t// origin\thttps://github.com/rsc/pdf (fetch)\n-\t// origin\thttps://github.com/rsc/pdf (push)\n-\t// use first line only.\n-\n-\tif !strings.HasPrefix(out, \"origin\\t\") {\n-\t\treturn \"\", fmt.Errorf(\"unable to parse output of git remote -v\")\n-\t}\n-\tout = strings.TrimPrefix(out, \"origin\\t\")\n-\ti := strings.Index(out, \"\\n\")\n-\tif i < 0 {\n-\t\treturn \"\", fmt.Errorf(\"unable to parse output of git remote -v\")\n+\tout := strings.TrimSpace(string(outb))\n+\n+\tvar repoURL *url.URL\n+\tif m := scpSyntaxRe.FindStringSubmatch(out); m != nil {\n+\t\t// Match SCP-like syntax and convert it to a URL.\n+\t\t// Eg, \"git@github.com:user/repo\" becomes\n+\t\t// \"ssh://git@github.com/user/repo\".\n+\t\trepoURL = &url.URL{\n+\t\t\tScheme:  \"ssh\",\n+\t\t\tUser:    url.User(m[1]),\n+\t\t\tHost:    m[2],\n+\t\t\tRawPath: m[3],\n+\t\t}\n+\t} else {\n+\t\trepoURL, err = url.Parse(out)\n+\t\tif err != nil {\n+\t\t\treturn \"\", err\n+\t\t}\n \t}\n-\tout = out[:i]\n-\ti = strings.LastIndex(out, \" \")\n-\tif i < 0 {\n-\t\treturn \"\", fmt.Errorf(\"unable to parse output of git remote -v\")\n+\n+\t// Iterate over insecure schemes too, because this function simply\n+\t// reports the state of the repo. If we can't see insecure schemes then\n+\t// we can't report the actual repo URL.\n+\tfor _, s := range vcsGit.scheme {\n+\t\tif repoURL.Scheme == s {\n+\t\t\treturn repoURL.String(), nil\n+\t\t}\n \t}\n-\tout = out[:i]\n-\treturn strings.TrimSpace(string(out)), nil\n+\treturn \"\", errParse\n }\n \n // vcsBzr describes how to use Bazaar.\n var vcsBzr = &vcsCmd{\n \tname: \"Bazaar\",\n \tcmd:  \"bzr\",\n \n-\tcreateCmd: \"branch {repo} {dir}\",\n+\tcreateCmd: []string{\"branch {repo} {dir}\"},\n \n \t// Without --overwrite bzr will not pull tags that changed.\n \t// Replace by --overwrite-tags after http://pad.lv/681792 goes in.\n-\tdownloadCmd: \"pull --overwrite\",\n+\tdownloadCmd: []string{\"pull --overwrite\"},\n \n \ttagCmd:         []tagCmd{{\"tags\", `^(\\S+)`}},\n-\ttagSyncCmd:     \"update -r {tag}\",\n-\ttagSyncDefault: \"update -r revno:-1\",\n+\ttagSyncCmd:     []string{\"update -r {tag}\"},\n+\ttagSyncDefault: []string{\"update -r revno:-1\"},\n \n \tscheme:      []string{\"https\", \"http\", \"bzr\", \"bzr+ssh\"},\n \tpingCmd:     \"info {scheme}://{repo}\",\n@@ -217,8 +260,8 @@ var vcsSvn = &vcsCmd{\n \tname: \"Subversion\",\n \tcmd:  \"svn\",\n \n-\tcreateCmd:   \"checkout {repo} {dir}\",\n-\tdownloadCmd: \"update\",\n+\tcreateCmd:   []string{\"checkout {repo} {dir}\"},\n+\tdownloadCmd: []string{\"update\"},\n \n \t// There is no tag command in subversion.\n \t// The branch information is all in the path names.\n@@ -294,14 +337,14 @@ func (v *vcsCmd) run1(dir string, cmdline string, keyval []string, verbose bool)\n \t_, err := exec.LookPath(v.cmd)\n \tif err != nil {\n \t\tfmt.Fprintf(os.Stderr,\n-\t\t\t\"go: missing %s command. See http://golang.org/s/gogetcmd\\n\",\n+\t\t\t\"go: missing %s command. See https://golang.org/s/gogetcmd\\n\",\n \t\t\tv.name)\n \t\treturn nil, err\n \t}\n \n \tcmd := exec.Command(v.cmd, args...)\n \tcmd.Dir = dir\n-\tcmd.Env = envForDir(cmd.Dir)\n+\tcmd.Env = envForDir(cmd.Dir, os.Environ())\n \tif buildX {\n \t\tfmt.Printf(\"cd %s\\n\", dir)\n \t\tfmt.Printf(\"%s %s\\n\", v.cmd, strings.Join(args, \" \"))\n@@ -316,7 +359,7 @@ func (v *vcsCmd) run1(dir string, cmdline string, keyval []string, verbose bool)\n \t\t\tfmt.Fprintf(os.Stderr, \"# cd %s; %s %s\\n\", dir, v.cmd, strings.Join(args, \" \"))\n \t\t\tos.Stderr.Write(out)\n \t\t}\n-\t\treturn nil, err\n+\t\treturn out, err\n \t}\n \treturn out, nil\n }\n@@ -329,15 +372,31 @@ func (v *vcsCmd) ping(scheme, repo string) error {\n // create creates a new copy of repo in dir.\n // The parent of dir must exist; dir must not.\n func (v *vcsCmd) create(dir, repo string) error {\n-\treturn v.run(\".\", v.createCmd, \"dir\", dir, \"repo\", repo)\n+\tfor _, cmd := range v.createCmd {\n+\t\tif !go15VendorExperiment && strings.Contains(cmd, \"submodule\") {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif err := v.run(\".\", cmd, \"dir\", dir, \"repo\", repo); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n }\n \n // download downloads any new changes for the repo in dir.\n func (v *vcsCmd) download(dir string) error {\n \tif err := v.fixDetachedHead(dir); err != nil {\n \t\treturn err\n \t}\n-\treturn v.run(dir, v.downloadCmd)\n+\tfor _, cmd := range v.downloadCmd {\n+\t\tif !go15VendorExperiment && strings.Contains(cmd, \"submodule\") {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif err := v.run(dir, cmd); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n }\n \n // fixDetachedHead switches a Git repository in dir from a detached head to the master branch.\n@@ -383,7 +442,7 @@ func (v *vcsCmd) tags(dir string) ([]string, error) {\n // tagSync syncs the repo in dir to the named tag,\n // which either is a tag returned by tags or is v.tagDefault.\n func (v *vcsCmd) tagSync(dir, tag string) error {\n-\tif v.tagSyncCmd == \"\" {\n+\tif v.tagSyncCmd == nil {\n \t\treturn nil\n \t}\n \tif tag != \"\" {\n@@ -400,10 +459,28 @@ func (v *vcsCmd) tagSync(dir, tag string) error {\n \t\t\t}\n \t\t}\n \t}\n-\tif tag == \"\" && v.tagSyncDefault != \"\" {\n-\t\treturn v.run(dir, v.tagSyncDefault)\n+\n+\tif tag == \"\" && v.tagSyncDefault != nil {\n+\t\tfor _, cmd := range v.tagSyncDefault {\n+\t\t\tif !go15VendorExperiment && strings.Contains(cmd, \"submodule\") {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif err := v.run(dir, cmd); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t}\n+\t\treturn nil\n+\t}\n+\n+\tfor _, cmd := range v.tagSyncCmd {\n+\t\tif !go15VendorExperiment && strings.Contains(cmd, \"submodule\") {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif err := v.run(dir, cmd, \"tag\", tag); err != nil {\n+\t\t\treturn err\n+\t\t}\n \t}\n-\treturn v.run(dir, v.tagSyncCmd, \"tag\", tag)\n+\treturn nil\n }\n \n // A vcsPath describes how to convert an import path into a\n@@ -467,10 +544,20 @@ type repoRoot struct {\n \n var httpPrefixRE = regexp.MustCompile(`^https?:`)\n \n+// securityMode specifies whether a function should make network\n+// calls using insecure transports (eg, plain text HTTP).\n+// The zero value is \"secure\".\n+type securityMode int\n+\n+const (\n+\tsecure securityMode = iota\n+\tinsecure\n+)\n+\n // repoRootForImportPath analyzes importPath to determine the\n // version control system, and code repository to use.\n-func repoRootForImportPath(importPath string) (*repoRoot, error) {\n-\trr, err := repoRootForImportPathStatic(importPath, \"\")\n+func repoRootForImportPath(importPath string, security securityMode) (*repoRoot, error) {\n+\trr, err := repoRootFromVCSPaths(importPath, \"\", security, vcsPaths)\n \tif err == errUnknownSite {\n \t\t// If there are wildcards, look up the thing before the wildcard,\n \t\t// hoping it applies to the wildcarded parts too.\n@@ -479,7 +566,7 @@ func repoRootForImportPath(importPath string) (*repoRoot, error) {\n \t\tif i := strings.Index(lookup, \"/.../\"); i >= 0 {\n \t\t\tlookup = lookup[:i]\n \t\t}\n-\t\trr, err = repoRootForImportDynamic(lookup)\n+\t\trr, err = repoRootForImportDynamic(lookup, security)\n \n \t\t// repoRootForImportDynamic returns error detail\n \t\t// that is irrelevant if the user didn't intend to use a\n@@ -492,6 +579,13 @@ func repoRootForImportPath(importPath string) (*repoRoot, error) {\n \t\t\terr = fmt.Errorf(\"unrecognized import path %q\", importPath)\n \t\t}\n \t}\n+\tif err != nil {\n+\t\trr1, err1 := repoRootFromVCSPaths(importPath, \"\", security, vcsPathsAfterDynamic)\n+\t\tif err1 == nil {\n+\t\t\trr = rr1\n+\t\t\terr = nil\n+\t\t}\n+\t}\n \n \tif err == nil && strings.Contains(importPath, \"...\") && strings.Contains(rr.root, \"...\") {\n \t\t// Do not allow wildcards in the repo root.\n@@ -503,13 +597,10 @@ func repoRootForImportPath(importPath string) (*repoRoot, error) {\n \n var errUnknownSite = errors.New(\"dynamic lookup required to find mapping\")\n \n-// repoRootForImportPathStatic attempts to map importPath to a\n-// repoRoot using the commonly-used VCS hosting sites in vcsPaths\n-// (github.com/user/dir), or from a fully-qualified importPath already\n-// containing its VCS type (foo.com/repo.git/dir)\n-//\n+// repoRootFromVCSPaths attempts to map importPath to a repoRoot\n+// using the mappings defined in vcsPaths.\n // If scheme is non-empty, that scheme is forced.\n-func repoRootForImportPathStatic(importPath, scheme string) (*repoRoot, error) {\n+func repoRootFromVCSPaths(importPath, scheme string, security securityMode, vcsPaths []*vcsPath) (*repoRoot, error) {\n \t// A common error is to use https://packagepath because that's what\n \t// hg and git require. Diagnose this helpfully.\n \tif loc := httpPrefixRE.FindStringIndex(importPath); loc != nil {\n@@ -559,6 +650,9 @@ func repoRootForImportPathStatic(importPath, scheme string) (*repoRoot, error) {\n \t\t\t\tmatch[\"repo\"] = scheme + \"://\" + match[\"repo\"]\n \t\t\t} else {\n \t\t\t\tfor _, scheme := range vcs.scheme {\n+\t\t\t\t\tif security == secure && !isSecureScheme[scheme] {\n+\t\t\t\t\t\tcontinue\n+\t\t\t\t\t}\n \t\t\t\t\tif vcs.ping(scheme, match[\"repo\"]) == nil {\n \t\t\t\t\t\tmatch[\"repo\"] = scheme + \"://\" + match[\"repo\"]\n \t\t\t\t\t\tbreak\n@@ -579,77 +673,129 @@ func repoRootForImportPathStatic(importPath, scheme string) (*repoRoot, error) {\n // repoRootForImportDynamic finds a *repoRoot for a custom domain that's not\n // statically known by repoRootForImportPathStatic.\n //\n-// This handles \"vanity import paths\" like \"name.tld/pkg/foo\".\n-func repoRootForImportDynamic(importPath string) (*repoRoot, error) {\n+// This handles custom import paths like \"name.tld/pkg/foo\" or just \"name.tld\".\n+func repoRootForImportDynamic(importPath string, security securityMode) (*repoRoot, error) {\n \tslash := strings.Index(importPath, \"/\")\n \tif slash < 0 {\n-\t\treturn nil, errors.New(\"import path does not contain a slash\")\n+\t\tslash = len(importPath)\n \t}\n \thost := importPath[:slash]\n \tif !strings.Contains(host, \".\") {\n \t\treturn nil, errors.New(\"import path does not begin with hostname\")\n \t}\n-\turlStr, body, err := httpsOrHTTP(importPath)\n+\turlStr, body, err := httpsOrHTTP(importPath, security)\n \tif err != nil {\n-\t\treturn nil, fmt.Errorf(\"http/https fetch: %v\", err)\n+\t\tmsg := \"https fetch: %v\"\n+\t\tif security == insecure {\n+\t\t\tmsg = \"http/\" + msg\n+\t\t}\n+\t\treturn nil, fmt.Errorf(msg, err)\n \t}\n \tdefer body.Close()\n \timports, err := parseMetaGoImports(body)\n \tif err != nil {\n \t\treturn nil, fmt.Errorf(\"parsing %s: %v\", importPath, err)\n \t}\n-\tmetaImport, err := matchGoImport(imports, importPath)\n+\t// Find the matched meta import.\n+\tmmi, err := matchGoImport(imports, importPath)\n \tif err != nil {\n \t\tif err != errNoMatch {\n \t\t\treturn nil, fmt.Errorf(\"parse %s: %v\", urlStr, err)\n \t\t}\n \t\treturn nil, fmt.Errorf(\"parse %s: no go-import meta tags\", urlStr)\n \t}\n \tif buildV {\n-\t\tlog.Printf(\"get %q: found meta tag %#v at %s\", importPath, metaImport, urlStr)\n+\t\tlog.Printf(\"get %q: found meta tag %#v at %s\", importPath, mmi, urlStr)\n \t}\n \t// If the import was \"uni.edu/bob/project\", which said the\n \t// prefix was \"uni.edu\" and the RepoRoot was \"evilroot.com\",\n \t// make sure we don't trust Bob and check out evilroot.com to\n \t// \"uni.edu\" yet (possibly overwriting/preempting another\n \t// non-evil student).  Instead, first verify the root and see\n \t// if it matches Bob's claim.\n-\tif metaImport.Prefix != importPath {\n+\tif mmi.Prefix != importPath {\n \t\tif buildV {\n \t\t\tlog.Printf(\"get %q: verifying non-authoritative meta tag\", importPath)\n \t\t}\n \t\turlStr0 := urlStr\n-\t\turlStr, body, err = httpsOrHTTP(metaImport.Prefix)\n+\t\tvar imports []metaImport\n+\t\turlStr, imports, err = metaImportsForPrefix(mmi.Prefix, security)\n \t\tif err != nil {\n-\t\t\treturn nil, fmt.Errorf(\"fetch %s: %v\", urlStr, err)\n-\t\t}\n-\t\timports, err := parseMetaGoImports(body)\n-\t\tif err != nil {\n-\t\t\treturn nil, fmt.Errorf(\"parsing %s: %v\", importPath, err)\n-\t\t}\n-\t\tif len(imports) == 0 {\n-\t\t\treturn nil, fmt.Errorf(\"fetch %s: no go-import meta tag\", urlStr)\n+\t\t\treturn nil, err\n \t\t}\n \t\tmetaImport2, err := matchGoImport(imports, importPath)\n-\t\tif err != nil || metaImport != metaImport2 {\n-\t\t\treturn nil, fmt.Errorf(\"%s and %s disagree about go-import for %s\", urlStr0, urlStr, metaImport.Prefix)\n+\t\tif err != nil || mmi != metaImport2 {\n+\t\t\treturn nil, fmt.Errorf(\"%s and %s disagree about go-import for %s\", urlStr0, urlStr, mmi.Prefix)\n \t\t}\n \t}\n \n-\tif !strings.Contains(metaImport.RepoRoot, \"://\") {\n-\t\treturn nil, fmt.Errorf(\"%s: invalid repo root %q; no scheme\", urlStr, metaImport.RepoRoot)\n+\tif !strings.Contains(mmi.RepoRoot, \"://\") {\n+\t\treturn nil, fmt.Errorf(\"%s: invalid repo root %q; no scheme\", urlStr, mmi.RepoRoot)\n \t}\n \trr := &repoRoot{\n-\t\tvcs:  vcsByCmd(metaImport.VCS),\n-\t\trepo: metaImport.RepoRoot,\n-\t\troot: metaImport.Prefix,\n+\t\tvcs:  vcsByCmd(mmi.VCS),\n+\t\trepo: mmi.RepoRoot,\n+\t\troot: mmi.Prefix,\n \t}\n \tif rr.vcs == nil {\n-\t\treturn nil, fmt.Errorf(\"%s: unknown vcs %q\", urlStr, metaImport.VCS)\n+\t\treturn nil, fmt.Errorf(\"%s: unknown vcs %q\", urlStr, mmi.VCS)\n \t}\n \treturn rr, nil\n }\n \n+var fetchGroup singleflight.Group\n+var (\n+\tfetchCacheMu sync.Mutex\n+\tfetchCache   = map[string]fetchResult{} // key is metaImportsForPrefix's importPrefix\n+)\n+\n+// metaImportsForPrefix takes a package's root import path as declared in a <meta> tag\n+// and returns its HTML discovery URL and the parsed metaImport lines\n+// found on the page.\n+//\n+// The importPath is of the form \"golang.org/x/tools\".\n+// It is an error if no imports are found.\n+// urlStr will still be valid if err != nil.\n+// The returned urlStr will be of the form \"https://golang.org/x/tools?go-get=1\"\n+func metaImportsForPrefix(importPrefix string, security securityMode) (urlStr string, imports []metaImport, err error) {\n+\tsetCache := func(res fetchResult) (fetchResult, error) {\n+\t\tfetchCacheMu.Lock()\n+\t\tdefer fetchCacheMu.Unlock()\n+\t\tfetchCache[importPrefix] = res\n+\t\treturn res, nil\n+\t}\n+\n+\tresi, _, _ := fetchGroup.Do(importPrefix, func() (resi interface{}, err error) {\n+\t\tfetchCacheMu.Lock()\n+\t\tif res, ok := fetchCache[importPrefix]; ok {\n+\t\t\tfetchCacheMu.Unlock()\n+\t\t\treturn res, nil\n+\t\t}\n+\t\tfetchCacheMu.Unlock()\n+\n+\t\turlStr, body, err := httpsOrHTTP(importPrefix, security)\n+\t\tif err != nil {\n+\t\t\treturn setCache(fetchResult{urlStr: urlStr, err: fmt.Errorf(\"fetch %s: %v\", urlStr, err)})\n+\t\t}\n+\t\timports, err := parseMetaGoImports(body)\n+\t\tif err != nil {\n+\t\t\treturn setCache(fetchResult{urlStr: urlStr, err: fmt.Errorf(\"parsing %s: %v\", urlStr, err)})\n+\t\t}\n+\t\tif len(imports) == 0 {\n+\t\t\terr = fmt.Errorf(\"fetch %s: no go-import meta tag\", urlStr)\n+\t\t}\n+\t\treturn setCache(fetchResult{urlStr: urlStr, imports: imports, err: err})\n+\t})\n+\tres := resi.(fetchResult)\n+\treturn res.urlStr, res.imports, res.err\n+}\n+\n+type fetchResult struct {\n+\turlStr  string // e.g. \"https://foo.com/x/bar?go-get=1\"\n+\timports []metaImport\n+\terr     error\n+}\n+\n // metaImport represents the parsed <meta name=\"go-import\"\n // content=\"prefix vcs reporoot\" /> tags from HTML files.\n type metaImport struct {\n@@ -689,7 +835,10 @@ func expand(match map[string]string, s string) string {\n \treturn s\n }\n \n-// vcsPaths lists the known vcs paths.\n+// vcsPaths defines the meaning of import paths referring to\n+// commonly-used VCS hosting sites (github.com/user/dir)\n+// and import paths referring to a fully-qualified importPath\n+// containing a VCS type (foo.com/repo.git/dir)\n var vcsPaths = []*vcsPath{\n \t// Google Code - new syntax\n \t{\n@@ -722,15 +871,6 @@ var vcsPaths = []*vcsPath{\n \t\tcheck:  bitbucketVCS,\n \t},\n \n-\t// Launchpad\n-\t{\n-\t\tprefix: \"launchpad.net/\",\n-\t\tre:     `^(?P<root>launchpad\\.net/((?P<project>[A-Za-z0-9_.\\-]+)(?P<series>/[A-Za-z0-9_.\\-]+)?|~[A-Za-z0-9_.\\-]+/(\\+junk|[A-Za-z0-9_.\\-]+)/[A-Za-z0-9_.\\-]+))(/[A-Za-z0-9_.\\-]+)*$`,\n-\t\tvcs:    \"bzr\",\n-\t\trepo:   \"https://{root}\",\n-\t\tcheck:  launchpadVCS,\n-\t},\n-\n \t// IBM DevOps Services (JazzHub)\n \t{\n \t\tprefix: \"hub.jazz.net/git\",\n@@ -740,20 +880,47 @@ var vcsPaths = []*vcsPath{\n \t\tcheck:  noVCSSuffix,\n \t},\n \n+\t// Git at Apache\n+\t{\n+\t\tprefix: \"git.apache.org\",\n+\t\tre:     `^(?P<root>git.apache.org/[a-z0-9_.\\-]+\\.git)(/[A-Za-z0-9_.\\-]+)*$`,\n+\t\tvcs:    \"git\",\n+\t\trepo:   \"https://{root}\",\n+\t},\n+\n \t// General syntax for any server.\n+\t// Must be last.\n \t{\n \t\tre:   `^(?P<root>(?P<repo>([a-z0-9.\\-]+\\.)+[a-z0-9.\\-]+(:[0-9]+)?/[A-Za-z0-9_.\\-/]*?)\\.(?P<vcs>bzr|git|hg|svn))(/[A-Za-z0-9_.\\-]+)*$`,\n \t\tping: true,\n \t},\n }\n \n+// vcsPathsAfterDynamic gives additional vcsPaths entries\n+// to try after the dynamic HTML check.\n+// This gives those sites a chance to introduce <meta> tags\n+// as part of a graceful transition away from the hard-coded logic.\n+var vcsPathsAfterDynamic = []*vcsPath{\n+\t// Launchpad. See golang.org/issue/11436.\n+\t{\n+\t\tprefix: \"launchpad.net/\",\n+\t\tre:     `^(?P<root>launchpad\\.net/((?P<project>[A-Za-z0-9_.\\-]+)(?P<series>/[A-Za-z0-9_.\\-]+)?|~[A-Za-z0-9_.\\-]+/(\\+junk|[A-Za-z0-9_.\\-]+)/[A-Za-z0-9_.\\-]+))(/[A-Za-z0-9_.\\-]+)*$`,\n+\t\tvcs:    \"bzr\",\n+\t\trepo:   \"https://{root}\",\n+\t\tcheck:  launchpadVCS,\n+\t},\n+}\n+\n func init() {\n \t// fill in cached regexps.\n \t// Doing this eagerly discovers invalid regexp syntax\n \t// without having to run a command that needs that regexp.\n \tfor _, srv := range vcsPaths {\n \t\tsrv.regexp = regexp.MustCompile(srv.re)\n \t}\n+\tfor _, srv := range vcsPathsAfterDynamic {\n+\t\tsrv.regexp = regexp.MustCompile(srv.re)\n+\t}\n }\n \n // noVCSSuffix checks that the repository name does not\n@@ -821,10 +988,25 @@ func bitbucketVCS(match map[string]string) error {\n \turl := expand(match, \"https://api.bitbucket.org/1.0/repositories/{bitname}\")\n \tdata, err := httpGET(url)\n \tif err != nil {\n-\t\treturn err\n-\t}\n-\tif err := json.Unmarshal(data, &resp); err != nil {\n-\t\treturn fmt.Errorf(\"decoding %s: %v\", url, err)\n+\t\tif httpErr, ok := err.(*httpError); ok && httpErr.statusCode == 403 {\n+\t\t\t// this may be a private repository. If so, attempt to determine which\n+\t\t\t// VCS it uses. See issue 5375.\n+\t\t\troot := match[\"root\"]\n+\t\t\tfor _, vcs := range []string{\"git\", \"hg\"} {\n+\t\t\t\tif vcsByCmd(vcs).ping(\"https\", root) == nil {\n+\t\t\t\t\tresp.SCM = vcs\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tif resp.SCM == \"\" {\n+\t\t\treturn err\n+\t\t}\n+\t} else {\n+\t\tif err := json.Unmarshal(data, &resp); err != nil {\n+\t\t\treturn fmt.Errorf(\"decoding %s: %v\", url, err)\n+\t\t}\n \t}\n \n \tif vcsByCmd(resp.SCM) != nil {"}, {"sha": "f5d5e4f4f0b521a5ccbe99b5039a0ee95965fd7b", "filename": "libgo/go/cmd/go/vcs_test.go", "status": "modified", "additions": 60, "deletions": 9, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Fvcs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Fvcs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fvcs_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -5,20 +5,15 @@\n package main\n \n import (\n-\t\"runtime\"\n+\t\"internal/testenv\"\n \t\"testing\"\n )\n \n // Test that RepoRootForImportPath creates the correct RepoRoot for a given importPath.\n // TODO(cmang): Add tests for SVN and BZR.\n func TestRepoRootForImportPath(t *testing.T) {\n-\tif testing.Short() {\n-\t\tt.Skip(\"skipping test to avoid external network\")\n-\t}\n-\tswitch runtime.GOOS {\n-\tcase \"nacl\", \"android\":\n-\t\tt.Skipf(\"no networking available on %s\", runtime.GOOS)\n-\t}\n+\ttestenv.MustHaveExternalNetwork(t)\n+\n \ttests := []struct {\n \t\tpath string\n \t\twant *repoRoot\n@@ -101,10 +96,34 @@ func TestRepoRootForImportPath(t *testing.T) {\n \t\t\t\"hub.jazz.net/git/USER/pkgname\",\n \t\t\tnil,\n \t\t},\n+\t\t// Spaces are not valid in package name\n+\t\t{\n+\t\t\t\"git.apache.org/package name/path/to/lib\",\n+\t\t\tnil,\n+\t\t},\n+\t\t// Should have \".git\" suffix\n+\t\t{\n+\t\t\t\"git.apache.org/package-name/path/to/lib\",\n+\t\t\tnil,\n+\t\t},\n+\t\t{\n+\t\t\t\"git.apache.org/package-name.git\",\n+\t\t\t&repoRoot{\n+\t\t\t\tvcs:  vcsGit,\n+\t\t\t\trepo: \"https://git.apache.org/package-name.git\",\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t\"git.apache.org/package-name_2.x.git/path/to/lib\",\n+\t\t\t&repoRoot{\n+\t\t\t\tvcs:  vcsGit,\n+\t\t\t\trepo: \"https://git.apache.org/package-name_2.x.git\",\n+\t\t\t},\n+\t\t},\n \t}\n \n \tfor _, test := range tests {\n-\t\tgot, err := repoRootForImportPath(test.path)\n+\t\tgot, err := repoRootForImportPath(test.path, secure)\n \t\twant := test.want\n \n \t\tif want == nil {\n@@ -122,3 +141,35 @@ func TestRepoRootForImportPath(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestIsSecure(t *testing.T) {\n+\ttests := []struct {\n+\t\tvcs    *vcsCmd\n+\t\turl    string\n+\t\tsecure bool\n+\t}{\n+\t\t{vcsGit, \"http://example.com/foo.git\", false},\n+\t\t{vcsGit, \"https://example.com/foo.git\", true},\n+\t\t{vcsBzr, \"http://example.com/foo.bzr\", false},\n+\t\t{vcsBzr, \"https://example.com/foo.bzr\", true},\n+\t\t{vcsSvn, \"http://example.com/svn\", false},\n+\t\t{vcsSvn, \"https://example.com/svn\", true},\n+\t\t{vcsHg, \"http://example.com/foo.hg\", false},\n+\t\t{vcsHg, \"https://example.com/foo.hg\", true},\n+\t\t{vcsGit, \"ssh://user@example.com/foo.git\", true},\n+\t\t{vcsGit, \"user@server:path/to/repo.git\", false},\n+\t\t{vcsGit, \"user@server:\", false},\n+\t\t{vcsGit, \"server:repo.git\", false},\n+\t\t{vcsGit, \"server:path/to/repo.git\", false},\n+\t\t{vcsGit, \"example.com:path/to/repo.git\", false},\n+\t\t{vcsGit, \"path/that/contains/a:colon/repo.git\", false},\n+\t\t{vcsHg, \"ssh://user@example.com/path/to/repo.hg\", true},\n+\t}\n+\n+\tfor _, test := range tests {\n+\t\tsecure := test.vcs.isSecure(test.url)\n+\t\tif secure != test.secure {\n+\t\t\tt.Errorf(\"%s isSecure(%q) = %t; want %t\", test.vcs, test.url, secure, test.secure)\n+\t\t}\n+\t}\n+}"}, {"sha": "1e8cf9c8d26d7531fbc5520f5819362c5b21e2a3", "filename": "libgo/go/cmd/go/vendor_test.go", "status": "added", "additions": 258, "deletions": 0, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Fvendor_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Fvendor_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fvendor_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -0,0 +1,258 @@\n+// Copyright 2015 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Tests for vendoring semantics.\n+\n+package main_test\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"internal/testenv\"\n+\t\"path/filepath\"\n+\t\"regexp\"\n+\t\"strings\"\n+\t\"testing\"\n+)\n+\n+func TestVendorImports(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.setenv(\"GO15VENDOREXPERIMENT\", \"1\")\n+\ttg.run(\"list\", \"-f\", \"{{.ImportPath}} {{.Imports}}\", \"vend/...\")\n+\twant := `\n+\t\tvend [vend/vendor/p r]\n+\t\tvend/hello [fmt vend/vendor/strings]\n+\t\tvend/subdir [vend/vendor/p r]\n+\t\tvend/vendor/p []\n+\t\tvend/vendor/q []\n+\t\tvend/vendor/strings []\n+\t\tvend/x [vend/x/vendor/p vend/vendor/q vend/x/vendor/r]\n+\t\tvend/x/invalid [vend/x/invalid/vendor/foo]\n+\t\tvend/x/vendor/p []\n+\t\tvend/x/vendor/p/p [notfound]\n+\t\tvend/x/vendor/r []\n+\t`\n+\twant = strings.Replace(want+\"\\t\", \"\\n\\t\\t\", \"\\n\", -1)\n+\twant = strings.TrimPrefix(want, \"\\n\")\n+\n+\thave := tg.stdout.String()\n+\n+\tif have != want {\n+\t\tt.Errorf(\"incorrect go list output:\\n%s\", diffSortedOutputs(have, want))\n+\t}\n+}\n+\n+func TestVendorRun(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.setenv(\"GO15VENDOREXPERIMENT\", \"1\")\n+\ttg.cd(filepath.Join(tg.pwd(), \"testdata/src/vend/hello\"))\n+\ttg.run(\"run\", \"hello.go\")\n+\ttg.grepStdout(\"hello, world\", \"missing hello world output\")\n+}\n+\n+func TestVendorGOPATH(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\tchangeVolume := func(s string, f func(s string) string) string {\n+\t\tvol := filepath.VolumeName(s)\n+\t\treturn f(vol) + s[len(vol):]\n+\t}\n+\tgopath := changeVolume(filepath.Join(tg.pwd(), \"testdata\"), strings.ToLower)\n+\ttg.setenv(\"GOPATH\", gopath)\n+\ttg.setenv(\"GO15VENDOREXPERIMENT\", \"1\")\n+\tcd := changeVolume(filepath.Join(tg.pwd(), \"testdata/src/vend/hello\"), strings.ToUpper)\n+\ttg.cd(cd)\n+\ttg.run(\"run\", \"hello.go\")\n+\ttg.grepStdout(\"hello, world\", \"missing hello world output\")\n+}\n+\n+func TestVendorTest(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.setenv(\"GO15VENDOREXPERIMENT\", \"1\")\n+\ttg.cd(filepath.Join(tg.pwd(), \"testdata/src/vend/hello\"))\n+\ttg.run(\"test\", \"-v\")\n+\ttg.grepStdout(\"TestMsgInternal\", \"missing use in internal test\")\n+\ttg.grepStdout(\"TestMsgExternal\", \"missing use in external test\")\n+}\n+\n+func TestVendorInvalid(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.setenv(\"GO15VENDOREXPERIMENT\", \"1\")\n+\n+\ttg.runFail(\"build\", \"vend/x/invalid\")\n+\ttg.grepStderr(\"must be imported as foo\", \"missing vendor import error\")\n+}\n+\n+func TestVendorImportError(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.setenv(\"GO15VENDOREXPERIMENT\", \"1\")\n+\n+\ttg.runFail(\"build\", \"vend/x/vendor/p/p\")\n+\n+\tre := regexp.MustCompile(`cannot find package \"notfound\" in any of:\n+\t.*[\\\\/]testdata[\\\\/]src[\\\\/]vend[\\\\/]x[\\\\/]vendor[\\\\/]notfound \\(vendor tree\\)\n+\t.*[\\\\/]testdata[\\\\/]src[\\\\/]vend[\\\\/]vendor[\\\\/]notfound \\(vendor tree\\)\n+\t.*[\\\\/]src[\\\\/]notfound \\(from \\$GOROOT\\)\n+\t.*[\\\\/]testdata[\\\\/]src[\\\\/]notfound \\(from \\$GOPATH\\)`)\n+\n+\tif !re.MatchString(tg.stderr.String()) {\n+\t\tt.Errorf(\"did not find expected search list in error text\")\n+\t}\n+}\n+\n+// diffSortedOutput prepares a diff of the already sorted outputs haveText and wantText.\n+// The diff shows common lines prefixed by a tab, lines present only in haveText\n+// prefixed by \"unexpected: \", and lines present only in wantText prefixed by \"missing: \".\n+func diffSortedOutputs(haveText, wantText string) string {\n+\tvar diff bytes.Buffer\n+\thave := splitLines(haveText)\n+\twant := splitLines(wantText)\n+\tfor len(have) > 0 || len(want) > 0 {\n+\t\tif len(want) == 0 || len(have) > 0 && have[0] < want[0] {\n+\t\t\tfmt.Fprintf(&diff, \"unexpected: %s\\n\", have[0])\n+\t\t\thave = have[1:]\n+\t\t\tcontinue\n+\t\t}\n+\t\tif len(have) == 0 || len(want) > 0 && want[0] < have[0] {\n+\t\t\tfmt.Fprintf(&diff, \"missing: %s\\n\", want[0])\n+\t\t\twant = want[1:]\n+\t\t\tcontinue\n+\t\t}\n+\t\tfmt.Fprintf(&diff, \"\\t%s\\n\", want[0])\n+\t\twant = want[1:]\n+\t\thave = have[1:]\n+\t}\n+\treturn diff.String()\n+}\n+\n+func splitLines(s string) []string {\n+\tx := strings.Split(s, \"\\n\")\n+\tif x[len(x)-1] == \"\" {\n+\t\tx = x[:len(x)-1]\n+\t}\n+\treturn x\n+}\n+\n+func TestVendorGet(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.tempFile(\"src/v/m.go\", `\n+\t\tpackage main\n+\t\timport (\"fmt\"; \"vendor.org/p\")\n+\t\tfunc main() {\n+\t\t\tfmt.Println(p.C)\n+\t\t}`)\n+\ttg.tempFile(\"src/v/m_test.go\", `\n+\t\tpackage main\n+\t\timport (\"fmt\"; \"testing\"; \"vendor.org/p\")\n+\t\tfunc TestNothing(t *testing.T) {\n+\t\t\tfmt.Println(p.C)\n+\t\t}`)\n+\ttg.tempFile(\"src/v/vendor/vendor.org/p/p.go\", `\n+\t\tpackage p\n+\t\tconst C = 1`)\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.setenv(\"GO15VENDOREXPERIMENT\", \"1\")\n+\ttg.cd(tg.path(\"src/v\"))\n+\ttg.run(\"run\", \"m.go\")\n+\ttg.run(\"test\")\n+\ttg.run(\"list\", \"-f\", \"{{.Imports}}\")\n+\ttg.grepStdout(\"v/vendor/vendor.org/p\", \"import not in vendor directory\")\n+\ttg.run(\"list\", \"-f\", \"{{.TestImports}}\")\n+\ttg.grepStdout(\"v/vendor/vendor.org/p\", \"test import not in vendor directory\")\n+\ttg.run(\"get\")\n+\ttg.run(\"get\", \"-t\")\n+}\n+\n+func TestVendorGetUpdate(t *testing.T) {\n+\ttestenv.MustHaveExternalNetwork(t)\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.setenv(\"GO15VENDOREXPERIMENT\", \"1\")\n+\ttg.run(\"get\", \"github.com/rsc/go-get-issue-11864\")\n+\ttg.run(\"get\", \"-u\", \"github.com/rsc/go-get-issue-11864\")\n+}\n+\n+func TestVendorCache(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata/testvendor\"))\n+\ttg.setenv(\"GO15VENDOREXPERIMENT\", \"1\")\n+\ttg.runFail(\"build\", \"p\")\n+\ttg.grepStderr(\"must be imported as x\", \"did not fail to build p\")\n+}\n+\n+func TestVendorTest2(t *testing.T) {\n+\ttestenv.MustHaveExternalNetwork(t)\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.setenv(\"GO15VENDOREXPERIMENT\", \"1\")\n+\ttg.run(\"get\", \"github.com/rsc/go-get-issue-11864\")\n+\n+\t// build -i should work\n+\ttg.run(\"build\", \"-i\", \"github.com/rsc/go-get-issue-11864\")\n+\ttg.run(\"build\", \"-i\", \"github.com/rsc/go-get-issue-11864/t\")\n+\n+\t// test -i should work like build -i (golang.org/issue/11988)\n+\ttg.run(\"test\", \"-i\", \"github.com/rsc/go-get-issue-11864\")\n+\ttg.run(\"test\", \"-i\", \"github.com/rsc/go-get-issue-11864/t\")\n+\n+\t// test should work too\n+\ttg.run(\"test\", \"github.com/rsc/go-get-issue-11864\")\n+\ttg.run(\"test\", \"github.com/rsc/go-get-issue-11864/t\")\n+\n+\t// external tests should observe internal test exports (golang.org/issue/11977)\n+\ttg.run(\"test\", \"github.com/rsc/go-get-issue-11864/vendor/vendor.org/tx2\")\n+}\n+\n+func TestVendorList(t *testing.T) {\n+\ttestenv.MustHaveExternalNetwork(t)\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.setenv(\"GO15VENDOREXPERIMENT\", \"1\")\n+\ttg.run(\"get\", \"github.com/rsc/go-get-issue-11864\")\n+\n+\ttg.run(\"list\", \"-f\", `{{join .TestImports \"\\n\"}}`, \"github.com/rsc/go-get-issue-11864/t\")\n+\ttg.grepStdout(\"go-get-issue-11864/vendor/vendor.org/p\", \"did not find vendor-expanded p\")\n+\n+\ttg.run(\"list\", \"-f\", `{{join .XTestImports \"\\n\"}}`, \"github.com/rsc/go-get-issue-11864/tx\")\n+\ttg.grepStdout(\"go-get-issue-11864/vendor/vendor.org/p\", \"did not find vendor-expanded p\")\n+\n+\ttg.run(\"list\", \"-f\", `{{join .XTestImports \"\\n\"}}`, \"github.com/rsc/go-get-issue-11864/vendor/vendor.org/tx2\")\n+\ttg.grepStdout(\"go-get-issue-11864/vendor/vendor.org/tx2\", \"did not find vendor-expanded tx2\")\n+\n+\ttg.run(\"list\", \"-f\", `{{join .XTestImports \"\\n\"}}`, \"github.com/rsc/go-get-issue-11864/vendor/vendor.org/tx3\")\n+\ttg.grepStdout(\"go-get-issue-11864/vendor/vendor.org/tx3\", \"did not find vendor-expanded tx3\")\n+}\n+\n+func TestVendor12156(t *testing.T) {\n+\t// Former index out of range panic.\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata/testvendor2\"))\n+\ttg.setenv(\"GO15VENDOREXPERIMENT\", \"1\")\n+\ttg.cd(filepath.Join(tg.pwd(), \"testdata/testvendor2/src/p\"))\n+\ttg.runFail(\"build\", \"p.go\")\n+\ttg.grepStderrNot(\"panic\", \"panicked\")\n+\ttg.grepStderr(`cannot find package \"x\"`, \"wrong error\")\n+}"}, {"sha": "81b978e8dab2b5213cbe64d79c89bd9f0cccea69", "filename": "libgo/go/cmd/go/vet.go", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Fvet.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgo%2Fvet.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fvet.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -7,24 +7,26 @@ package main\n import \"path/filepath\"\n \n func init() {\n-\taddBuildFlagsNX(cmdVet)\n+\taddBuildFlags(cmdVet)\n }\n \n var cmdVet = &Command{\n \tRun:       runVet,\n-\tUsageLine: \"vet [-n] [-x] [packages]\",\n+\tUsageLine: \"vet [-n] [-x] [build flags] [packages]\",\n \tShort:     \"run go tool vet on packages\",\n \tLong: `\n Vet runs the Go vet command on the packages named by the import paths.\n \n-For more about vet, see 'godoc golang.org/x/tools/cmd/vet'.\n+For more about vet, see 'go doc cmd/vet'.\n For more about specifying packages, see 'go help packages'.\n \n To run the vet tool with specific options, run 'go tool vet'.\n \n The -n flag prints commands that would be executed.\n The -x flag prints commands as they are executed.\n \n+For more about build flags, see 'go help build'.\n+\n See also: go fmt, go fix.\n \t`,\n }\n@@ -46,5 +48,5 @@ func runVetFiles(p *Package, files []string) {\n \tfor i := range files {\n \t\tfiles[i] = filepath.Join(p.Dir, files[i])\n \t}\n-\trun(tool(\"vet\"), relPaths(files))\n+\trun(buildToolExec, tool(\"vet\"), relPaths(files))\n }"}, {"sha": "9d0cd328623cb406c470f10fdea230d5a6fa08f2", "filename": "libgo/go/cmd/gofmt/doc.go", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgofmt%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgofmt%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Fdoc.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -87,6 +87,13 @@ When invoked with -s gofmt will make the following source transformations where\n \t\tfor x, _ = range v {...}\n \twill be simplified to:\n \t\tfor x = range v {...}\n+\n+\tA range of the form:\n+\t\tfor _ = range v {...}\n+\twill be simplified to:\n+\t\tfor range v {...}\n+\n+This may result in changes that are incompatible with earlier versions of Go.\n */\n package main\n "}, {"sha": "b2805ac05fbcc936c92ccd74d4c79781090bb2b5", "filename": "libgo/go/cmd/gofmt/gofmt.go", "status": "modified", "additions": 3, "deletions": 153, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -13,6 +13,7 @@ import (\n \t\"go/printer\"\n \t\"go/scanner\"\n \t\"go/token\"\n+\t\"internal/format\"\n \t\"io\"\n \t\"io/ioutil\"\n \t\"os\"\n@@ -87,7 +88,7 @@ func processFile(filename string, in io.Reader, out io.Writer, stdin bool) error\n \t\treturn err\n \t}\n \n-\tfile, sourceAdj, indentAdj, err := parse(fileSet, filename, src, stdin)\n+\tfile, sourceAdj, indentAdj, err := format.Parse(fileSet, filename, src, stdin)\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -106,7 +107,7 @@ func processFile(filename string, in io.Reader, out io.Writer, stdin bool) error\n \t\tsimplify(file)\n \t}\n \n-\tres, err := format(fileSet, file, sourceAdj, indentAdj, src, printer.Config{Mode: printerMode, Tabwidth: tabWidth})\n+\tres, err := format.Format(fileSet, file, sourceAdj, indentAdj, src, printer.Config{Mode: printerMode, Tabwidth: tabWidth})\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -234,154 +235,3 @@ func diff(b1, b2 []byte) (data []byte, err error) {\n \treturn\n \n }\n-\n-// ----------------------------------------------------------------------------\n-// Support functions\n-//\n-// The functions parse, format, and isSpace below are identical to the\n-// respective functions in src/go/format/format.go - keep them in sync!\n-//\n-// TODO(gri) Factor out this functionality, eventually.\n-\n-// parse parses src, which was read from the named file,\n-// as a Go source file, declaration, or statement list.\n-func parse(fset *token.FileSet, filename string, src []byte, fragmentOk bool) (\n-\tfile *ast.File,\n-\tsourceAdj func(src []byte, indent int) []byte,\n-\tindentAdj int,\n-\terr error,\n-) {\n-\t// Try as whole source file.\n-\tfile, err = parser.ParseFile(fset, filename, src, parserMode)\n-\t// If there's no error, return.  If the error is that the source file didn't begin with a\n-\t// package line and source fragments are ok, fall through to\n-\t// try as a source fragment.  Stop and return on any other error.\n-\tif err == nil || !fragmentOk || !strings.Contains(err.Error(), \"expected 'package'\") {\n-\t\treturn\n-\t}\n-\n-\t// If this is a declaration list, make it a source file\n-\t// by inserting a package clause.\n-\t// Insert using a ;, not a newline, so that the line numbers\n-\t// in psrc match the ones in src.\n-\tpsrc := append([]byte(\"package p;\"), src...)\n-\tfile, err = parser.ParseFile(fset, filename, psrc, parserMode)\n-\tif err == nil {\n-\t\tsourceAdj = func(src []byte, indent int) []byte {\n-\t\t\t// Remove the package clause.\n-\t\t\t// Gofmt has turned the ; into a \\n.\n-\t\t\tsrc = src[indent+len(\"package p\\n\"):]\n-\t\t\treturn bytes.TrimSpace(src)\n-\t\t}\n-\t\treturn\n-\t}\n-\t// If the error is that the source file didn't begin with a\n-\t// declaration, fall through to try as a statement list.\n-\t// Stop and return on any other error.\n-\tif !strings.Contains(err.Error(), \"expected declaration\") {\n-\t\treturn\n-\t}\n-\n-\t// If this is a statement list, make it a source file\n-\t// by inserting a package clause and turning the list\n-\t// into a function body.  This handles expressions too.\n-\t// Insert using a ;, not a newline, so that the line numbers\n-\t// in fsrc match the ones in src.\n-\tfsrc := append(append([]byte(\"package p; func _() {\"), src...), '\\n', '}')\n-\tfile, err = parser.ParseFile(fset, filename, fsrc, parserMode)\n-\tif err == nil {\n-\t\tsourceAdj = func(src []byte, indent int) []byte {\n-\t\t\t// Cap adjusted indent to zero.\n-\t\t\tif indent < 0 {\n-\t\t\t\tindent = 0\n-\t\t\t}\n-\t\t\t// Remove the wrapping.\n-\t\t\t// Gofmt has turned the ; into a \\n\\n.\n-\t\t\t// There will be two non-blank lines with indent, hence 2*indent.\n-\t\t\tsrc = src[2*indent+len(\"package p\\n\\nfunc _() {\"):]\n-\t\t\tsrc = src[:len(src)-(indent+len(\"\\n}\\n\"))]\n-\t\t\treturn bytes.TrimSpace(src)\n-\t\t}\n-\t\t// Gofmt has also indented the function body one level.\n-\t\t// Adjust that with indentAdj.\n-\t\tindentAdj = -1\n-\t}\n-\n-\t// Succeeded, or out of options.\n-\treturn\n-}\n-\n-// format formats the given package file originally obtained from src\n-// and adjusts the result based on the original source via sourceAdj\n-// and indentAdj.\n-func format(\n-\tfset *token.FileSet,\n-\tfile *ast.File,\n-\tsourceAdj func(src []byte, indent int) []byte,\n-\tindentAdj int,\n-\tsrc []byte,\n-\tcfg printer.Config,\n-) ([]byte, error) {\n-\tif sourceAdj == nil {\n-\t\t// Complete source file.\n-\t\tvar buf bytes.Buffer\n-\t\terr := cfg.Fprint(&buf, fset, file)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\treturn buf.Bytes(), nil\n-\t}\n-\n-\t// Partial source file.\n-\t// Determine and prepend leading space.\n-\ti, j := 0, 0\n-\tfor j < len(src) && isSpace(src[j]) {\n-\t\tif src[j] == '\\n' {\n-\t\t\ti = j + 1 // byte offset of last line in leading space\n-\t\t}\n-\t\tj++\n-\t}\n-\tvar res []byte\n-\tres = append(res, src[:i]...)\n-\n-\t// Determine and prepend indentation of first code line.\n-\t// Spaces are ignored unless there are no tabs,\n-\t// in which case spaces count as one tab.\n-\tindent := 0\n-\thasSpace := false\n-\tfor _, b := range src[i:j] {\n-\t\tswitch b {\n-\t\tcase ' ':\n-\t\t\thasSpace = true\n-\t\tcase '\\t':\n-\t\t\tindent++\n-\t\t}\n-\t}\n-\tif indent == 0 && hasSpace {\n-\t\tindent = 1\n-\t}\n-\tfor i := 0; i < indent; i++ {\n-\t\tres = append(res, '\\t')\n-\t}\n-\n-\t// Format the source.\n-\t// Write it without any leading and trailing space.\n-\tcfg.Indent = indent + indentAdj\n-\tvar buf bytes.Buffer\n-\terr := cfg.Fprint(&buf, fset, file)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tres = append(res, sourceAdj(buf.Bytes(), cfg.Indent)...)\n-\n-\t// Determine and append trailing space.\n-\ti = len(src)\n-\tfor i > 0 && isSpace(src[i-1]) {\n-\t\ti--\n-\t}\n-\treturn append(res, src[i:]...), nil\n-}\n-\n-func isSpace(b byte) bool {\n-\treturn b == ' ' || b == '\\t' || b == '\\n' || b == '\\r'\n-}"}, {"sha": "df9a878df44db12eb844b82451f3afc5dbcd9174", "filename": "libgo/go/cmd/gofmt/long_test.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgofmt%2Flong_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgofmt%2Flong_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Flong_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -15,6 +15,7 @@ import (\n \t\"go/ast\"\n \t\"go/printer\"\n \t\"go/token\"\n+\t\"internal/format\"\n \t\"io\"\n \t\"os\"\n \t\"path/filepath\"\n@@ -32,7 +33,7 @@ var (\n )\n \n func gofmt(fset *token.FileSet, filename string, src *bytes.Buffer) error {\n-\tf, _, _, err := parse(fset, filename, src.Bytes(), false)\n+\tf, _, _, err := format.Parse(fset, filename, src.Bytes(), false)\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -60,7 +61,7 @@ func testFile(t *testing.T, b1, b2 *bytes.Buffer, filename string) {\n \n \t// exclude files w/ syntax errors (typically test cases)\n \tfset := token.NewFileSet()\n-\tif _, _, _, err = parse(fset, filename, b1.Bytes(), false); err != nil {\n+\tif _, _, _, err = format.Parse(fset, filename, b1.Bytes(), false); err != nil {\n \t\tif *verbose {\n \t\t\tfmt.Fprintf(os.Stderr, \"ignoring %s\\n\", err)\n \t\t}"}, {"sha": "069f96622caf712a58f9dd7f08d1b3c6e4c0e281", "filename": "libgo/go/cmd/gofmt/rewrite.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgofmt%2Frewrite.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcmd%2Fgofmt%2Frewrite.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Frewrite.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -154,7 +154,7 @@ func isWildcard(s string) bool {\n \treturn size == len(s) && unicode.IsLower(rune)\n }\n \n-// match returns true if pattern matches val,\n+// match reports whether pattern matches val,\n // recording wildcard submatches in m.\n // If m == nil, match checks whether pattern == val.\n func match(m map[string]reflect.Value, pattern, val reflect.Value) bool {"}, {"sha": "689795727089d9b16b1e740f9ef1b390a11cd1ac", "filename": "libgo/go/compress/bzip2/bzip2.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -353,7 +353,7 @@ func (bz2 *reader) readBlock() (err error) {\n \t// variables accumulate the repeat count. See the Wikipedia page for\n \t// details.\n \trepeat := 0\n-\trepeat_power := 0\n+\trepeatPower := 0\n \n \t// The `C' array (used by the inverse BWT) needs to be zero initialized.\n \tfor i := range bz2.c {\n@@ -380,10 +380,10 @@ func (bz2 *reader) readBlock() (err error) {\n \t\tif v < 2 {\n \t\t\t// This is either the RUNA or RUNB symbol.\n \t\t\tif repeat == 0 {\n-\t\t\t\trepeat_power = 1\n+\t\t\t\trepeatPower = 1\n \t\t\t}\n-\t\t\trepeat += repeat_power << v\n-\t\t\trepeat_power <<= 1\n+\t\t\trepeat += repeatPower << v\n+\t\t\trepeatPower <<= 1\n \n \t\t\t// This limit of 2 million comes from the bzip2 source\n \t\t\t// code. It prevents repeat from overflowing."}, {"sha": "77c50dfe948b6dc9c52b0a693ba50228431bf2d2", "filename": "libgo/go/compress/bzip2/bzip2_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -200,7 +200,7 @@ func BenchmarkDecodeDigits(b *testing.B) { benchmarkDecode(b, digits) }\n func BenchmarkDecodeTwain(b *testing.B)  { benchmarkDecode(b, twain) }\n \n func TestBufferOverrun(t *testing.T) {\n-\t// Tests https://code.google.com/p/go/issues/detail?id=5747.\n+\t// Tests https://golang.org/issue/5747.\n \tbuffer := bytes.NewReader([]byte(bufferOverrunBase64))\n \tdecoder := base64.NewDecoder(base64.StdEncoding, buffer)\n \tdecompressor := NewReader(decoder)\n@@ -209,7 +209,7 @@ func TestBufferOverrun(t *testing.T) {\n }\n \n func TestOutOfRangeSelector(t *testing.T) {\n-\t// Tests https://code.google.com/p/go/issues/detail?id=8363.\n+\t// Tests https://golang.org/issue/8363.\n \tbuffer := bytes.NewReader(outOfRangeSelector)\n \tdecompressor := NewReader(buffer)\n \t// This shouldn't panic."}, {"sha": "169a0c7b2ebe4b169212e73ddc7a6539ee8f7ac6", "filename": "libgo/go/compress/flate/deflate.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -24,7 +24,7 @@ const (\n \tmaxMatchLength     = 258 // The longest match for the compressor\n \tminOffsetSize      = 1   // The shortest offset that makes any sense\n \n-\t// The maximum number of tokens we put into a single flat block, just too\n+\t// The maximum number of tokens we put into a single flat block, just to\n \t// stop things from getting too large.\n \tmaxFlateBlockTokens = 1 << 14\n \tmaxStoreBlockSize   = 65535"}, {"sha": "d5d6e732cf1192305a874a79e45f0ee35eb7a3d8", "filename": "libgo/go/compress/flate/deflate_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -407,7 +407,7 @@ func TestWriterDict(t *testing.T) {\n \t}\n }\n \n-// See http://code.google.com/p/go/issues/detail?id=2508\n+// See https://golang.org/issue/2508\n func TestRegression2508(t *testing.T) {\n \tif testing.Short() {\n \t\tt.Logf(\"test disabled with -short\")"}, {"sha": "3f67025cd76b5f98ba26bc615dd87a80d28bd583", "filename": "libgo/go/compress/flate/flate_test.go", "status": "modified", "additions": 217, "deletions": 19, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcompress%2Fflate%2Fflate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcompress%2Fflate%2Fflate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fflate_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -10,29 +10,18 @@ package flate\n \n import (\n \t\"bytes\"\n+\t\"encoding/hex\"\n+\t\"io/ioutil\"\n \t\"testing\"\n )\n \n-func TestUncompressedSource(t *testing.T) {\n-\tdecoder := NewReader(bytes.NewReader([]byte{0x01, 0x01, 0x00, 0xfe, 0xff, 0x11}))\n-\toutput := make([]byte, 1)\n-\tn, error := decoder.Read(output)\n-\tif n != 1 || error != nil {\n-\t\tt.Fatalf(\"decoder.Read() = %d, %v, want 1, nil\", n, error)\n-\t}\n-\tif output[0] != 0x11 {\n-\t\tt.Errorf(\"output[0] = %x, want 0x11\", output[0])\n-\t}\n-}\n-\n // The following test should not panic.\n func TestIssue5915(t *testing.T) {\n \tbits := []int{4, 0, 0, 6, 4, 3, 2, 3, 3, 4, 4, 5, 0, 0, 0, 0, 5, 5, 6,\n \t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n \t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 8, 6, 0, 11, 0, 8, 0, 6, 6, 10, 8}\n-\th := new(huffmanDecoder)\n-\tok := h.init(bits)\n-\tif ok == true {\n+\tvar h huffmanDecoder\n+\tif h.init(bits) {\n \t\tt.Fatalf(\"Given sequence of bits is bad, and should not succeed.\")\n \t}\n }\n@@ -41,9 +30,8 @@ func TestIssue5915(t *testing.T) {\n func TestIssue5962(t *testing.T) {\n \tbits := []int{4, 0, 0, 6, 4, 3, 2, 3, 3, 4, 4, 5, 0, 0, 0, 0,\n \t\t5, 5, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11}\n-\th := new(huffmanDecoder)\n-\tok := h.init(bits)\n-\tif ok == true {\n+\tvar h huffmanDecoder\n+\tif h.init(bits) {\n \t\tt.Fatalf(\"Given sequence of bits is bad, and should not succeed.\")\n \t}\n }\n@@ -52,11 +40,221 @@ func TestIssue5962(t *testing.T) {\n func TestIssue6255(t *testing.T) {\n \tbits1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 11}\n \tbits2 := []int{11, 13}\n-\th := new(huffmanDecoder)\n+\tvar h huffmanDecoder\n \tif !h.init(bits1) {\n \t\tt.Fatalf(\"Given sequence of bits is good and should succeed.\")\n \t}\n \tif h.init(bits2) {\n \t\tt.Fatalf(\"Given sequence of bits is bad and should not succeed.\")\n \t}\n }\n+\n+func TestInvalidEncoding(t *testing.T) {\n+\t// Initialize Huffman decoder to recognize \"0\".\n+\tvar h huffmanDecoder\n+\tif !h.init([]int{1}) {\n+\t\tt.Fatal(\"Failed to initialize Huffman decoder\")\n+\t}\n+\n+\t// Initialize decompressor with invalid Huffman coding.\n+\tvar f decompressor\n+\tf.r = bytes.NewReader([]byte{0xff})\n+\n+\t_, err := f.huffSym(&h)\n+\tif err == nil {\n+\t\tt.Fatal(\"Should have rejected invalid bit sequence\")\n+\t}\n+}\n+\n+func TestInvalidBits(t *testing.T) {\n+\toversubscribed := []int{1, 2, 3, 4, 4, 5}\n+\tincomplete := []int{1, 2, 4, 4}\n+\tvar h huffmanDecoder\n+\tif h.init(oversubscribed) {\n+\t\tt.Fatal(\"Should reject oversubscribed bit-length set\")\n+\t}\n+\tif h.init(incomplete) {\n+\t\tt.Fatal(\"Should reject incomplete bit-length set\")\n+\t}\n+}\n+\n+func TestStreams(t *testing.T) {\n+\t// To verify any of these hexstrings as valid or invalid flate streams\n+\t// according to the C zlib library, you can use the Python wrapper library:\n+\t// >>> hex_string = \"010100feff11\"\n+\t// >>> import zlib\n+\t// >>> zlib.decompress(hex_string.decode(\"hex\"), -15) # Negative means raw DEFLATE\n+\t// '\\x11'\n+\n+\ttestCases := []struct {\n+\t\tdesc   string // Description of the stream\n+\t\tstream string // Hexstring of the input DEFLATE stream\n+\t\twant   string // Expected result. Use \"fail\" to expect failure\n+\t}{{\n+\t\t\"degenerate HCLenTree\",\n+\t\t\"05e0010000000000100000000000000000000000000000000000000000000000\" +\n+\t\t\t\"00000000000000000004\",\n+\t\t\"fail\",\n+\t}, {\n+\t\t\"complete HCLenTree, empty HLitTree, empty HDistTree\",\n+\t\t\"05e0010400000000000000000000000000000000000000000000000000000000\" +\n+\t\t\t\"00000000000000000010\",\n+\t\t\"fail\",\n+\t}, {\n+\t\t\"empty HCLenTree\",\n+\t\t\"05e0010000000000000000000000000000000000000000000000000000000000\" +\n+\t\t\t\"00000000000000000010\",\n+\t\t\"fail\",\n+\t}, {\n+\t\t\"complete HCLenTree, complete HLitTree, empty HDistTree, use missing HDist symbol\",\n+\t\t\"000100feff000de0010400000000100000000000000000000000000000000000\" +\n+\t\t\t\"0000000000000000000000000000002c\",\n+\t\t\"fail\",\n+\t}, {\n+\t\t\"complete HCLenTree, complete HLitTree, degenerate HDistTree, use missing HDist symbol\",\n+\t\t\"000100feff000de0010000000000000000000000000000000000000000000000\" +\n+\t\t\t\"00000000000000000610000000004070\",\n+\t\t\"fail\",\n+\t}, {\n+\t\t\"complete HCLenTree, empty HLitTree, empty HDistTree\",\n+\t\t\"05e0010400000000100400000000000000000000000000000000000000000000\" +\n+\t\t\t\"0000000000000000000000000008\",\n+\t\t\"fail\",\n+\t}, {\n+\t\t\"complete HCLenTree, empty HLitTree, degenerate HDistTree\",\n+\t\t\"05e0010400000000100400000000000000000000000000000000000000000000\" +\n+\t\t\t\"0000000000000000000800000008\",\n+\t\t\"fail\",\n+\t}, {\n+\t\t\"complete HCLenTree, degenerate HLitTree, degenerate HDistTree, use missing HLit symbol\",\n+\t\t\"05e0010400000000100000000000000000000000000000000000000000000000\" +\n+\t\t\t\"0000000000000000001c\",\n+\t\t\"fail\",\n+\t}, {\n+\t\t\"complete HCLenTree, complete HLitTree, too large HDistTree\",\n+\t\t\"edff870500000000200400000000000000000000000000000000000000000000\" +\n+\t\t\t\"000000000000000000080000000000000004\",\n+\t\t\"fail\",\n+\t}, {\n+\t\t\"complete HCLenTree, complete HLitTree, empty HDistTree, excessive repeater code\",\n+\t\t\"edfd870500000000200400000000000000000000000000000000000000000000\" +\n+\t\t\t\"000000000000000000e8b100\",\n+\t\t\"fail\",\n+\t}, {\n+\t\t\"complete HCLenTree, complete HLitTree, empty HDistTree of normal length 30\",\n+\t\t\"05fd01240000000000f8ffffffffffffffffffffffffffffffffffffffffffff\" +\n+\t\t\t\"ffffffffffffffffff07000000fe01\",\n+\t\t\"\",\n+\t}, {\n+\t\t\"complete HCLenTree, complete HLitTree, empty HDistTree of excessive length 31\",\n+\t\t\"05fe01240000000000f8ffffffffffffffffffffffffffffffffffffffffffff\" +\n+\t\t\t\"ffffffffffffffffff07000000fc03\",\n+\t\t\"fail\",\n+\t}, {\n+\t\t\"complete HCLenTree, over-subscribed HLitTree, empty HDistTree\",\n+\t\t\"05e001240000000000fcffffffffffffffffffffffffffffffffffffffffffff\" +\n+\t\t\t\"ffffffffffffffffff07f00f\",\n+\t\t\"fail\",\n+\t}, {\n+\t\t\"complete HCLenTree, under-subscribed HLitTree, empty HDistTree\",\n+\t\t\"05e001240000000000fcffffffffffffffffffffffffffffffffffffffffffff\" +\n+\t\t\t\"fffffffffcffffffff07f00f\",\n+\t\t\"fail\",\n+\t}, {\n+\t\t\"complete HCLenTree, complete HLitTree with single code, empty HDistTree\",\n+\t\t\"05e001240000000000f8ffffffffffffffffffffffffffffffffffffffffffff\" +\n+\t\t\t\"ffffffffffffffffff07f00f\",\n+\t\t\"01\",\n+\t}, {\n+\t\t\"complete HCLenTree, complete HLitTree with multiple codes, empty HDistTree\",\n+\t\t\"05e301240000000000f8ffffffffffffffffffffffffffffffffffffffffffff\" +\n+\t\t\t\"ffffffffffffffffff07807f\",\n+\t\t\"01\",\n+\t}, {\n+\t\t\"complete HCLenTree, complete HLitTree, degenerate HDistTree, use valid HDist symbol\",\n+\t\t\"000100feff000de0010400000000100000000000000000000000000000000000\" +\n+\t\t\t\"0000000000000000000000000000003c\",\n+\t\t\"00000000\",\n+\t}, {\n+\t\t\"complete HCLenTree, degenerate HLitTree, degenerate HDistTree\",\n+\t\t\"05e0010400000000100000000000000000000000000000000000000000000000\" +\n+\t\t\t\"0000000000000000000c\",\n+\t\t\"\",\n+\t}, {\n+\t\t\"complete HCLenTree, degenerate HLitTree, empty HDistTree\",\n+\t\t\"05e0010400000000100000000000000000000000000000000000000000000000\" +\n+\t\t\t\"00000000000000000004\",\n+\t\t\"\",\n+\t}, {\n+\t\t\"complete HCLenTree, complete HLitTree, empty HDistTree, spanning repeater code\",\n+\t\t\"edfd870500000000200400000000000000000000000000000000000000000000\" +\n+\t\t\t\"000000000000000000e8b000\",\n+\t\t\"\",\n+\t}, {\n+\t\t\"complete HCLenTree with length codes, complete HLitTree, empty HDistTree\",\n+\t\t\"ede0010400000000100000000000000000000000000000000000000000000000\" +\n+\t\t\t\"0000000000000000000400004000\",\n+\t\t\"\",\n+\t}, {\n+\t\t\"complete HCLenTree, complete HLitTree, degenerate HDistTree, use valid HLit symbol 284 with count 31\",\n+\t\t\"000100feff00ede0010400000000100000000000000000000000000000000000\" +\n+\t\t\t\"000000000000000000000000000000040000407f00\",\n+\t\t\"0000000000000000000000000000000000000000000000000000000000000000\" +\n+\t\t\t\"0000000000000000000000000000000000000000000000000000000000000000\" +\n+\t\t\t\"0000000000000000000000000000000000000000000000000000000000000000\" +\n+\t\t\t\"0000000000000000000000000000000000000000000000000000000000000000\" +\n+\t\t\t\"0000000000000000000000000000000000000000000000000000000000000000\" +\n+\t\t\t\"0000000000000000000000000000000000000000000000000000000000000000\" +\n+\t\t\t\"0000000000000000000000000000000000000000000000000000000000000000\" +\n+\t\t\t\"0000000000000000000000000000000000000000000000000000000000000000\" +\n+\t\t\t\"000000\",\n+\t}, {\n+\t\t\"complete HCLenTree, complete HLitTree, degenerate HDistTree, use valid HLit and HDist symbols\",\n+\t\t\"0cc2010d00000082b0ac4aff0eb07d27060000ffff\",\n+\t\t\"616263616263\",\n+\t}, {\n+\t\t\"fixed block, use reserved symbol 287\",\n+\t\t\"33180700\",\n+\t\t\"fail\",\n+\t}, {\n+\t\t\"raw block\",\n+\t\t\"010100feff11\",\n+\t\t\"11\",\n+\t}, {\n+\t\t\"issue 10426 - over-subscribed HCLenTree causes a hang\",\n+\t\t\"344c4a4e494d4b070000ff2e2eff2e2e2e2e2eff\",\n+\t\t\"fail\",\n+\t}, {\n+\t\t\"issue 11030 - empty HDistTree unexpectedly leads to error\",\n+\t\t\"05c0070600000080400fff37a0ca\",\n+\t\t\"\",\n+\t}, {\n+\t\t\"issue 11033 - empty HDistTree unexpectedly leads to error\",\n+\t\t\"050fb109c020cca5d017dcbca044881ee1034ec149c8980bbc413c2ab35be9dc\" +\n+\t\t\t\"b1473449922449922411202306ee97b0383a521b4ffdcf3217f9f7d3adb701\",\n+\t\t\"3130303634342068652e706870005d05355f7ed957ff084a90925d19e3ebc6d0\" +\n+\t\t\t\"c6d7\",\n+\t}}\n+\n+\tfor i, tc := range testCases {\n+\t\tdata, err := hex.DecodeString(tc.stream)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tdata, err = ioutil.ReadAll(NewReader(bytes.NewReader(data)))\n+\t\tif tc.want == \"fail\" {\n+\t\t\tif err == nil {\n+\t\t\t\tt.Errorf(\"#%d (%s): got nil error, want non-nil\", i, tc.desc)\n+\t\t\t}\n+\t\t} else {\n+\t\t\tif err != nil {\n+\t\t\t\tt.Errorf(\"#%d (%s): %v\", i, tc.desc, err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif got := hex.EncodeToString(data); got != tc.want {\n+\t\t\t\tt.Errorf(\"#%d (%s):\\ngot  %q\\nwant %q\", i, tc.desc, got, tc.want)\n+\t\t\t}\n+\n+\t\t}\n+\t}\n+}"}, {"sha": "154c89a488e08c2ed8d321e6034d88124a7e0b8e", "filename": "libgo/go/compress/flate/gen.go", "status": "modified", "additions": 100, "deletions": 25, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcompress%2Fflate%2Fgen.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcompress%2Fflate%2Fgen.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fgen.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -45,7 +45,20 @@ type huffmanDecoder struct {\n }\n \n // Initialize Huffman decoding tables from array of code lengths.\n+// Following this function, h is guaranteed to be initialized into a complete\n+// tree (i.e., neither over-subscribed nor under-subscribed). The exception is a\n+// degenerate case where the tree has only a single symbol with length 1. Empty\n+// trees are permitted.\n func (h *huffmanDecoder) init(bits []int) bool {\n+\t// Sanity enables additional runtime tests during Huffman\n+\t// table construction.  It's intended to be used during\n+\t// development to supplement the currently ad-hoc unit tests.\n+\tconst sanity = false\n+\n+\tif h.min != 0 {\n+\t\t*h = huffmanDecoder{}\n+\t}\n+\n \t// Count number of codes of each length,\n \t// compute min and max length.\n \tvar count [maxCodeLen]int\n@@ -62,37 +75,53 @@ func (h *huffmanDecoder) init(bits []int) bool {\n \t\t}\n \t\tcount[n]++\n \t}\n+\n+\t// Empty tree. The decompressor.huffSym function will fail later if the tree\n+\t// is used. Technically, an empty tree is only valid for the HDIST tree and\n+\t// not the HCLEN and HLIT tree. However, a stream with an empty HCLEN tree\n+\t// is guaranteed to fail since it will attempt to use the tree to decode the\n+\t// codes for the HLIT and HDIST trees. Similarly, an empty HLIT tree is\n+\t// guaranteed to fail later since the compressed data section must be\n+\t// composed of at least one symbol (the end-of-block marker).\n \tif max == 0 {\n+\t\treturn true\n+\t}\n+\n+\tcode := 0\n+\tvar nextcode [maxCodeLen]int\n+\tfor i := min; i <= max; i++ {\n+\t\tcode <<= 1\n+\t\tnextcode[i] = code\n+\t\tcode += count[i]\n+\t}\n+\n+\t// Check that the coding is complete (i.e., that we've\n+\t// assigned all 2-to-the-max possible bit sequences).\n+\t// Exception: To be compatible with zlib, we also need to\n+\t// accept degenerate single-code codings.  See also\n+\t// TestDegenerateHuffmanCoding.\n+\tif code != 1<<uint(max) && !(code == 1 && max == 1) {\n \t\treturn false\n \t}\n \n \th.min = min\n-\tvar linkBits uint\n-\tvar numLinks int\n \tif max > huffmanChunkBits {\n-\t\tlinkBits = uint(max) - huffmanChunkBits\n-\t\tnumLinks = 1 << linkBits\n+\t\tnumLinks := 1 << (uint(max) - huffmanChunkBits)\n \t\th.linkMask = uint32(numLinks - 1)\n-\t}\n-\tcode := 0\n-\tvar nextcode [maxCodeLen]int\n-\tfor i := min; i <= max; i++ {\n-\t\tif i == huffmanChunkBits+1 {\n-\t\t\t// create link tables\n-\t\t\tlink := code >> 1\n-\t\t\th.links = make([][]uint32, huffmanNumChunks-link)\n-\t\t\tfor j := uint(link); j < huffmanNumChunks; j++ {\n-\t\t\t\treverse := int(reverseByte[j>>8]) | int(reverseByte[j&0xff])<<8\n-\t\t\t\treverse >>= uint(16 - huffmanChunkBits)\n-\t\t\t\toff := j - uint(link)\n-\t\t\t\th.chunks[reverse] = uint32(off<<huffmanValueShift + uint(i))\n-\t\t\t\th.links[off] = make([]uint32, 1<<linkBits)\n+\n+\t\t// create link tables\n+\t\tlink := nextcode[huffmanChunkBits+1] >> 1\n+\t\th.links = make([][]uint32, huffmanNumChunks-link)\n+\t\tfor j := uint(link); j < huffmanNumChunks; j++ {\n+\t\t\treverse := int(reverseByte[j>>8]) | int(reverseByte[j&0xff])<<8\n+\t\t\treverse >>= uint(16 - huffmanChunkBits)\n+\t\t\toff := j - uint(link)\n+\t\t\tif sanity && h.chunks[reverse] != 0 {\n+\t\t\t\tpanic(\"impossible: overwriting existing chunk\")\n \t\t\t}\n+\t\t\th.chunks[reverse] = uint32(off<<huffmanValueShift | (huffmanChunkBits + 1))\n+\t\t\th.links[off] = make([]uint32, numLinks)\n \t\t}\n-\t\tn := count[i]\n-\t\tnextcode[i] = code\n-\t\tcode += n\n-\t\tcode <<= 1\n \t}\n \n \tfor i, n := range bits {\n@@ -105,17 +134,60 @@ func (h *huffmanDecoder) init(bits []int) bool {\n \t\treverse := int(reverseByte[code>>8]) | int(reverseByte[code&0xff])<<8\n \t\treverse >>= uint(16 - n)\n \t\tif n <= huffmanChunkBits {\n-\t\t\tfor off := reverse; off < huffmanNumChunks; off += 1 << uint(n) {\n+\t\t\tfor off := reverse; off < len(h.chunks); off += 1 << uint(n) {\n+\t\t\t\t// We should never need to overwrite\n+\t\t\t\t// an existing chunk.  Also, 0 is\n+\t\t\t\t// never a valid chunk, because the\n+\t\t\t\t// lower 4 \"count\" bits should be\n+\t\t\t\t// between 1 and 15.\n+\t\t\t\tif sanity && h.chunks[off] != 0 {\n+\t\t\t\t\tpanic(\"impossible: overwriting existing chunk\")\n+\t\t\t\t}\n \t\t\t\th.chunks[off] = chunk\n \t\t\t}\n \t\t} else {\n-\t\t\tlinktab := h.links[h.chunks[reverse&(huffmanNumChunks-1)]>>huffmanValueShift]\n+\t\t\tj := reverse & (huffmanNumChunks - 1)\n+\t\t\tif sanity && h.chunks[j]&huffmanCountMask != huffmanChunkBits+1 {\n+\t\t\t\t// Longer codes should have been\n+\t\t\t\t// associated with a link table above.\n+\t\t\t\tpanic(\"impossible: not an indirect chunk\")\n+\t\t\t}\n+\t\t\tvalue := h.chunks[j] >> huffmanValueShift\n+\t\t\tlinktab := h.links[value]\n \t\t\treverse >>= huffmanChunkBits\n-\t\t\tfor off := reverse; off < numLinks; off += 1 << uint(n-huffmanChunkBits) {\n+\t\t\tfor off := reverse; off < len(linktab); off += 1 << uint(n-huffmanChunkBits) {\n+\t\t\t\tif sanity && linktab[off] != 0 {\n+\t\t\t\t\tpanic(\"impossible: overwriting existing chunk\")\n+\t\t\t\t}\n \t\t\t\tlinktab[off] = chunk\n \t\t\t}\n \t\t}\n \t}\n+\n+\tif sanity {\n+\t\t// Above we've sanity checked that we never overwrote\n+\t\t// an existing entry.  Here we additionally check that\n+\t\t// we filled the tables completely.\n+\t\tfor i, chunk := range h.chunks {\n+\t\t\tif chunk == 0 {\n+\t\t\t\t// As an exception, in the degenerate\n+\t\t\t\t// single-code case, we allow odd\n+\t\t\t\t// chunks to be missing.\n+\t\t\t\tif code == 1 && i%2 == 1 {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tpanic(\"impossible: missing chunk\")\n+\t\t\t}\n+\t\t}\n+\t\tfor _, linktab := range h.links {\n+\t\t\tfor _, chunk := range linktab {\n+\t\t\t\tif chunk == 0 {\n+\t\t\t\t\tpanic(\"impossible: missing chunk\")\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \treturn true\n }\n \n@@ -138,6 +210,9 @@ func main() {\n \t\tbits[i] = 8\n \t}\n \th.init(bits[:])\n+\tif h.links != nil {\n+\t\tlog.Fatal(\"Unexpected links table in fixed Huffman decoder\")\n+\t}\n \n \tvar buf bytes.Buffer\n "}, {"sha": "616440412e4b2b869d22859bd873ea43a8145286", "filename": "libgo/go/compress/flate/huffman_bit_writer.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_bit_writer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_bit_writer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_bit_writer.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -87,11 +87,11 @@ type huffmanBitWriter struct {\n func newHuffmanBitWriter(w io.Writer) *huffmanBitWriter {\n \treturn &huffmanBitWriter{\n \t\tw:               w,\n-\t\tliteralFreq:     make([]int32, maxLit),\n+\t\tliteralFreq:     make([]int32, maxNumLit),\n \t\toffsetFreq:      make([]int32, offsetCodeCount),\n-\t\tcodegen:         make([]uint8, maxLit+offsetCodeCount+1),\n+\t\tcodegen:         make([]uint8, maxNumLit+offsetCodeCount+1),\n \t\tcodegenFreq:     make([]int32, codegenCodeCount),\n-\t\tliteralEncoding: newHuffmanEncoder(maxLit),\n+\t\tliteralEncoding: newHuffmanEncoder(maxNumLit),\n \t\toffsetEncoding:  newHuffmanEncoder(offsetCodeCount),\n \t\tcodegenEncoding: newHuffmanEncoder(codegenCodeCount),\n \t}"}, {"sha": "50ec79c94051e1ba610e5926c77633514ffb83ab", "filename": "libgo/go/compress/flate/huffman_code.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_code.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_code.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_code.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -47,11 +47,11 @@ func newHuffmanEncoder(size int) *huffmanEncoder {\n \n // Generates a HuffmanCode corresponding to the fixed literal table\n func generateFixedLiteralEncoding() *huffmanEncoder {\n-\th := newHuffmanEncoder(maxLit)\n+\th := newHuffmanEncoder(maxNumLit)\n \tcodeBits := h.codeBits\n \tcode := h.code\n \tvar ch uint16\n-\tfor ch = 0; ch < maxLit; ch++ {\n+\tfor ch = 0; ch < maxNumLit; ch++ {\n \t\tvar bits uint16\n \t\tvar size uint8\n \t\tswitch {"}, {"sha": "04372dec2419c86a7f66b9965cfc0d16fffdaa38", "filename": "libgo/go/compress/flate/inflate.go", "status": "modified", "additions": 118, "deletions": 46, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -18,10 +18,12 @@ import (\n const (\n \tmaxCodeLen = 16    // max length of Huffman code\n \tmaxHist    = 32768 // max history required\n-\t// The next three numbers come from the RFC, section 3.2.7.\n-\tmaxLit   = 286\n-\tmaxDist  = 32\n-\tnumCodes = 19 // number of codes in Huffman meta-code\n+\t// The next three numbers come from the RFC section 3.2.7, with the\n+\t// additional proviso in section 3.2.5 which implies that distance codes\n+\t// 30 and 31 should never occur in compressed data.\n+\tmaxNumLit  = 286\n+\tmaxNumDist = 30\n+\tnumCodes   = 19 // number of codes in Huffman meta-code\n )\n \n // A CorruptInputError reports the presence of corrupt input at a given offset.\n@@ -101,7 +103,16 @@ type huffmanDecoder struct {\n }\n \n // Initialize Huffman decoding tables from array of code lengths.\n+// Following this function, h is guaranteed to be initialized into a complete\n+// tree (i.e., neither over-subscribed nor under-subscribed). The exception is a\n+// degenerate case where the tree has only a single symbol with length 1. Empty\n+// trees are permitted.\n func (h *huffmanDecoder) init(bits []int) bool {\n+\t// Sanity enables additional runtime tests during Huffman\n+\t// table construction.  It's intended to be used during\n+\t// development to supplement the currently ad-hoc unit tests.\n+\tconst sanity = false\n+\n \tif h.min != 0 {\n \t\t*h = huffmanDecoder{}\n \t}\n@@ -122,40 +133,53 @@ func (h *huffmanDecoder) init(bits []int) bool {\n \t\t}\n \t\tcount[n]++\n \t}\n+\n+\t// Empty tree. The decompressor.huffSym function will fail later if the tree\n+\t// is used. Technically, an empty tree is only valid for the HDIST tree and\n+\t// not the HCLEN and HLIT tree. However, a stream with an empty HCLEN tree\n+\t// is guaranteed to fail since it will attempt to use the tree to decode the\n+\t// codes for the HLIT and HDIST trees. Similarly, an empty HLIT tree is\n+\t// guaranteed to fail later since the compressed data section must be\n+\t// composed of at least one symbol (the end-of-block marker).\n \tif max == 0 {\n+\t\treturn true\n+\t}\n+\n+\tcode := 0\n+\tvar nextcode [maxCodeLen]int\n+\tfor i := min; i <= max; i++ {\n+\t\tcode <<= 1\n+\t\tnextcode[i] = code\n+\t\tcode += count[i]\n+\t}\n+\n+\t// Check that the coding is complete (i.e., that we've\n+\t// assigned all 2-to-the-max possible bit sequences).\n+\t// Exception: To be compatible with zlib, we also need to\n+\t// accept degenerate single-code codings.  See also\n+\t// TestDegenerateHuffmanCoding.\n+\tif code != 1<<uint(max) && !(code == 1 && max == 1) {\n \t\treturn false\n \t}\n \n \th.min = min\n-\tvar linkBits uint\n-\tvar numLinks int\n \tif max > huffmanChunkBits {\n-\t\tlinkBits = uint(max) - huffmanChunkBits\n-\t\tnumLinks = 1 << linkBits\n+\t\tnumLinks := 1 << (uint(max) - huffmanChunkBits)\n \t\th.linkMask = uint32(numLinks - 1)\n-\t}\n-\tcode := 0\n-\tvar nextcode [maxCodeLen]int\n-\tfor i := min; i <= max; i++ {\n-\t\tif i == huffmanChunkBits+1 {\n-\t\t\t// create link tables\n-\t\t\tlink := code >> 1\n-\t\t\tif huffmanNumChunks < link {\n-\t\t\t\treturn false\n-\t\t\t}\n-\t\t\th.links = make([][]uint32, huffmanNumChunks-link)\n-\t\t\tfor j := uint(link); j < huffmanNumChunks; j++ {\n-\t\t\t\treverse := int(reverseByte[j>>8]) | int(reverseByte[j&0xff])<<8\n-\t\t\t\treverse >>= uint(16 - huffmanChunkBits)\n-\t\t\t\toff := j - uint(link)\n-\t\t\t\th.chunks[reverse] = uint32(off<<huffmanValueShift + uint(i))\n-\t\t\t\th.links[off] = make([]uint32, 1<<linkBits)\n+\n+\t\t// create link tables\n+\t\tlink := nextcode[huffmanChunkBits+1] >> 1\n+\t\th.links = make([][]uint32, huffmanNumChunks-link)\n+\t\tfor j := uint(link); j < huffmanNumChunks; j++ {\n+\t\t\treverse := int(reverseByte[j>>8]) | int(reverseByte[j&0xff])<<8\n+\t\t\treverse >>= uint(16 - huffmanChunkBits)\n+\t\t\toff := j - uint(link)\n+\t\t\tif sanity && h.chunks[reverse] != 0 {\n+\t\t\t\tpanic(\"impossible: overwriting existing chunk\")\n \t\t\t}\n+\t\t\th.chunks[reverse] = uint32(off<<huffmanValueShift | (huffmanChunkBits + 1))\n+\t\t\th.links[off] = make([]uint32, numLinks)\n \t\t}\n-\t\tn := count[i]\n-\t\tnextcode[i] = code\n-\t\tcode += n\n-\t\tcode <<= 1\n \t}\n \n \tfor i, n := range bits {\n@@ -168,21 +192,60 @@ func (h *huffmanDecoder) init(bits []int) bool {\n \t\treverse := int(reverseByte[code>>8]) | int(reverseByte[code&0xff])<<8\n \t\treverse >>= uint(16 - n)\n \t\tif n <= huffmanChunkBits {\n-\t\t\tfor off := reverse; off < huffmanNumChunks; off += 1 << uint(n) {\n+\t\t\tfor off := reverse; off < len(h.chunks); off += 1 << uint(n) {\n+\t\t\t\t// We should never need to overwrite\n+\t\t\t\t// an existing chunk.  Also, 0 is\n+\t\t\t\t// never a valid chunk, because the\n+\t\t\t\t// lower 4 \"count\" bits should be\n+\t\t\t\t// between 1 and 15.\n+\t\t\t\tif sanity && h.chunks[off] != 0 {\n+\t\t\t\t\tpanic(\"impossible: overwriting existing chunk\")\n+\t\t\t\t}\n \t\t\t\th.chunks[off] = chunk\n \t\t\t}\n \t\t} else {\n-\t\t\tvalue := h.chunks[reverse&(huffmanNumChunks-1)] >> huffmanValueShift\n-\t\t\tif value >= uint32(len(h.links)) {\n-\t\t\t\treturn false\n+\t\t\tj := reverse & (huffmanNumChunks - 1)\n+\t\t\tif sanity && h.chunks[j]&huffmanCountMask != huffmanChunkBits+1 {\n+\t\t\t\t// Longer codes should have been\n+\t\t\t\t// associated with a link table above.\n+\t\t\t\tpanic(\"impossible: not an indirect chunk\")\n \t\t\t}\n+\t\t\tvalue := h.chunks[j] >> huffmanValueShift\n \t\t\tlinktab := h.links[value]\n \t\t\treverse >>= huffmanChunkBits\n-\t\t\tfor off := reverse; off < numLinks; off += 1 << uint(n-huffmanChunkBits) {\n+\t\t\tfor off := reverse; off < len(linktab); off += 1 << uint(n-huffmanChunkBits) {\n+\t\t\t\tif sanity && linktab[off] != 0 {\n+\t\t\t\t\tpanic(\"impossible: overwriting existing chunk\")\n+\t\t\t\t}\n \t\t\t\tlinktab[off] = chunk\n \t\t\t}\n \t\t}\n \t}\n+\n+\tif sanity {\n+\t\t// Above we've sanity checked that we never overwrote\n+\t\t// an existing entry.  Here we additionally check that\n+\t\t// we filled the tables completely.\n+\t\tfor i, chunk := range h.chunks {\n+\t\t\tif chunk == 0 {\n+\t\t\t\t// As an exception, in the degenerate\n+\t\t\t\t// single-code case, we allow odd\n+\t\t\t\t// chunks to be missing.\n+\t\t\t\tif code == 1 && i%2 == 1 {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tpanic(\"impossible: missing chunk\")\n+\t\t\t}\n+\t\t}\n+\t\tfor _, linktab := range h.links {\n+\t\t\tfor _, chunk := range linktab {\n+\t\t\t\tif chunk == 0 {\n+\t\t\t\t\tpanic(\"impossible: missing chunk\")\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \treturn true\n }\n \n@@ -209,7 +272,7 @@ type decompressor struct {\n \th1, h2 huffmanDecoder\n \n \t// Length arrays used to define Huffman codes.\n-\tbits     *[maxLit + maxDist]int\n+\tbits     *[maxNumLit + maxNumDist]int\n \tcodebits *[numCodes]int\n \n \t// Output history, buffer.\n@@ -307,12 +370,14 @@ func (f *decompressor) readHuffman() error {\n \t\t}\n \t}\n \tnlit := int(f.b&0x1F) + 257\n-\tif nlit > maxLit {\n+\tif nlit > maxNumLit {\n \t\treturn CorruptInputError(f.roffset)\n \t}\n \tf.b >>= 5\n \tndist := int(f.b&0x1F) + 1\n-\t// maxDist is 32, so ndist is always valid.\n+\tif ndist > maxNumDist {\n+\t\treturn CorruptInputError(f.roffset)\n+\t}\n \tf.b >>= 5\n \tnclen := int(f.b&0xF) + 4\n \t// numCodes is 19, so nclen is always valid.\n@@ -443,9 +508,12 @@ func (f *decompressor) huffmanBlock() {\n \t\tcase v < 285:\n \t\t\tlength = v*32 - (281*32 - 131)\n \t\t\tn = 5\n-\t\tdefault:\n+\t\tcase v < maxNumLit:\n \t\t\tlength = 258\n \t\t\tn = 0\n+\t\tdefault:\n+\t\t\tf.err = CorruptInputError(f.roffset)\n+\t\t\treturn\n \t\t}\n \t\tif n > 0 {\n \t\t\tfor f.nb < n {\n@@ -480,10 +548,7 @@ func (f *decompressor) huffmanBlock() {\n \t\tswitch {\n \t\tcase dist < 4:\n \t\t\tdist++\n-\t\tcase dist >= 30:\n-\t\t\tf.err = CorruptInputError(f.roffset)\n-\t\t\treturn\n-\t\tdefault:\n+\t\tcase dist < maxNumDist:\n \t\t\tnb := uint(dist-2) >> 1\n \t\t\t// have 1 bit in bottom of dist, need nb more.\n \t\t\textra := (dist & 1) << nb\n@@ -497,6 +562,9 @@ func (f *decompressor) huffmanBlock() {\n \t\t\tf.b >>= nb\n \t\t\tf.nb -= nb\n \t\t\tdist = 1<<(nb+1) + 1 + extra\n+\t\tdefault:\n+\t\t\tf.err = CorruptInputError(f.roffset)\n+\t\t\treturn\n \t\t}\n \n \t\t// Copy history[-dist:-dist+length] into output.\n@@ -643,6 +711,10 @@ func (f *decompressor) moreBits() error {\n \n // Read the next Huffman-encoded symbol from f according to h.\n func (f *decompressor) huffSym(h *huffmanDecoder) (int, error) {\n+\t// Since a huffmanDecoder can be empty or be composed of a degenerate tree\n+\t// with single element, huffSym must error on these two edge cases. In both\n+\t// cases, the chunks slice will be 0 for the invalid sequence, leading it\n+\t// satisfy the n == 0 check below.\n \tn := uint(h.min)\n \tfor {\n \t\tfor f.nb < n {\n@@ -655,12 +727,12 @@ func (f *decompressor) huffSym(h *huffmanDecoder) (int, error) {\n \t\tif n > huffmanChunkBits {\n \t\t\tchunk = h.links[chunk>>huffmanValueShift][(f.b>>huffmanChunkBits)&h.linkMask]\n \t\t\tn = uint(chunk & huffmanCountMask)\n+\t\t}\n+\t\tif n <= f.nb {\n \t\t\tif n == 0 {\n \t\t\t\tf.err = CorruptInputError(f.roffset)\n \t\t\t\treturn 0, f.err\n \t\t\t}\n-\t\t}\n-\t\tif n <= f.nb {\n \t\t\tf.b >>= n\n \t\t\tf.nb -= n\n \t\t\treturn int(chunk >> huffmanValueShift), nil\n@@ -712,7 +784,7 @@ func (f *decompressor) Reset(r io.Reader, dict []byte) error {\n // The ReadCloser returned by NewReader also implements Resetter.\n func NewReader(r io.Reader) io.ReadCloser {\n \tvar f decompressor\n-\tf.bits = new([maxLit + maxDist]int)\n+\tf.bits = new([maxNumLit + maxNumDist]int)\n \tf.codebits = new([numCodes]int)\n \tf.r = makeReader(r)\n \tf.hist = new([maxHist]byte)\n@@ -731,7 +803,7 @@ func NewReaderDict(r io.Reader, dict []byte) io.ReadCloser {\n \tvar f decompressor\n \tf.r = makeReader(r)\n \tf.hist = new([maxHist]byte)\n-\tf.bits = new([maxLit + maxDist]int)\n+\tf.bits = new([maxNumLit + maxNumDist]int)\n \tf.codebits = new([numCodes]int)\n \tf.step = (*decompressor).nextBlock\n \tf.setDict(dict)"}, {"sha": "1353831eca9d8ad4d9a243da5f8cfc6cef1ae31c", "filename": "libgo/go/compress/lzw/reader.go", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcompress%2Flzw%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcompress%2Flzw%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Flzw%2Freader.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -139,6 +139,7 @@ func (d *decoder) decode() {\n \t\t\t\terr = io.ErrUnexpectedEOF\n \t\t\t}\n \t\t\td.err = err\n+\t\t\td.flush()\n \t\t\treturn\n \t\t}\n \t\tswitch {\n@@ -190,6 +191,7 @@ func (d *decoder) decode() {\n \t\t\t}\n \t\tdefault:\n \t\t\td.err = errors.New(\"lzw: invalid code\")\n+\t\t\td.flush()\n \t\t\treturn\n \t\t}\n \t\td.last, d.hi = code, d.hi+1\n@@ -213,7 +215,7 @@ func (d *decoder) flush() {\n \td.o = 0\n }\n \n-var errClosed = errors.New(\"compress/lzw: reader/writer is closed\")\n+var errClosed = errors.New(\"lzw: reader/writer is closed\")\n \n func (d *decoder) Close() error {\n \td.err = errClosed // in case any Reads come along\n@@ -227,7 +229,8 @@ func (d *decoder) Close() error {\n // It is the caller's responsibility to call Close on the ReadCloser when\n // finished reading.\n // The number of bits to use for literal codes, litWidth, must be in the\n-// range [2,8] and is typically 8.\n+// range [2,8] and is typically 8. It must equal the litWidth\n+// used during compression.\n func NewReader(r io.Reader, order Order, litWidth int) io.ReadCloser {\n \td := new(decoder)\n \tswitch order {"}, {"sha": "c3a5c3a0aaacdf3bfce7fbbf111786cb9310e98a", "filename": "libgo/go/compress/lzw/reader_test.go", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcompress%2Flzw%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcompress%2Flzw%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Flzw%2Freader_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -98,13 +98,20 @@ func TestReader(t *testing.T) {\n \t\tdefer rc.Close()\n \t\tb.Reset()\n \t\tn, err := io.Copy(&b, rc)\n+\t\ts := b.String()\n \t\tif err != nil {\n \t\t\tif err != tt.err {\n \t\t\t\tt.Errorf(\"%s: io.Copy: %v want %v\", tt.desc, err, tt.err)\n \t\t\t}\n+\t\t\tif err == io.ErrUnexpectedEOF {\n+\t\t\t\t// Even if the input is truncated, we should still return the\n+\t\t\t\t// partial decoded result.\n+\t\t\t\tif n == 0 || !strings.HasPrefix(tt.raw, s) {\n+\t\t\t\t\tt.Errorf(\"got %d bytes (%q), want a non-empty prefix of %q\", n, s, tt.raw)\n+\t\t\t\t}\n+\t\t\t}\n \t\t\tcontinue\n \t\t}\n-\t\ts := b.String()\n \t\tif s != tt.raw {\n \t\t\tt.Errorf(\"%s: got %d-byte %q want %d-byte %q\", tt.desc, n, s, len(tt.raw), tt.raw)\n \t\t}"}, {"sha": "7367c29651d772b6a6f5eeba0ba0af5ac1959d57", "filename": "libgo/go/compress/lzw/writer.go", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -138,16 +138,23 @@ func (e *encoder) Write(p []byte) (n int, err error) {\n \tif len(p) == 0 {\n \t\treturn 0, nil\n \t}\n+\tif maxLit := uint8(1<<e.litWidth - 1); maxLit != 0xff {\n+\t\tfor _, x := range p {\n+\t\t\tif x > maxLit {\n+\t\t\t\te.err = errors.New(\"lzw: input byte too large for the litWidth\")\n+\t\t\t\treturn 0, e.err\n+\t\t\t}\n+\t\t}\n+\t}\n \tn = len(p)\n-\tlitMask := uint32(1<<e.litWidth - 1)\n \tcode := e.savedCode\n \tif code == invalidCode {\n \t\t// The first code sent is always a literal code.\n-\t\tcode, p = uint32(p[0])&litMask, p[1:]\n+\t\tcode, p = uint32(p[0]), p[1:]\n \t}\n loop:\n \tfor _, x := range p {\n-\t\tliteral := uint32(x) & litMask\n+\t\tliteral := uint32(x)\n \t\tkey := code<<8 | literal\n \t\t// If there is a hash table hit for this key then we continue the loop\n \t\t// and do not emit a code yet.\n@@ -230,7 +237,7 @@ func (e *encoder) Close() error {\n // It is the caller's responsibility to call Close on the WriteCloser when\n // finished writing.\n // The number of bits to use for literal codes, litWidth, must be in the\n-// range [2,8] and is typically 8.\n+// range [2,8] and is typically 8. Input bytes must be less than 1<<litWidth.\n func NewWriter(w io.Writer, order Order, litWidth int) io.WriteCloser {\n \tvar write func(*encoder, uint32) error\n \tswitch order {"}, {"sha": "c20d058f8d3df34d2f9abfb839643831539447b6", "filename": "libgo/go/compress/lzw/writer_test.go", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -104,6 +104,16 @@ func TestWriterReturnValues(t *testing.T) {\n \t}\n }\n \n+func TestSmallLitWidth(t *testing.T) {\n+\tw := NewWriter(ioutil.Discard, LSB, 2)\n+\tif _, err := w.Write([]byte{0x03}); err != nil {\n+\t\tt.Fatalf(\"write a byte < 1<<2: %v\", err)\n+\t}\n+\tif _, err := w.Write([]byte{0x04}); err == nil {\n+\t\tt.Fatal(\"write a byte >= 1<<2: got nil error, want non-nil\")\n+\t}\n+}\n+\n func benchmarkEncoder(b *testing.B, n int) {\n \tb.StopTimer()\n \tb.SetBytes(int64(n))"}, {"sha": "7d27fde61d8fac2a0fd63548d35d0b8bf02a7493", "filename": "libgo/go/crypto/cipher/cipher.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcipher.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcipher.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcipher.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -29,6 +29,9 @@ type Block interface {\n type Stream interface {\n \t// XORKeyStream XORs each byte in the given slice with a byte from the\n \t// cipher's key stream. Dst and src may point to the same memory.\n+\t// If len(dst) < len(src), XORKeyStream should panic. It is acceptable\n+\t// to pass a dst bigger than src, and in that case, XORKeyStream will\n+\t// only update dst[:len(src)] and will not touch the rest of dst.\n \tXORKeyStream(dst, src []byte)\n }\n "}, {"sha": "bbdf9f5d3df7eb9da5a97c0330f55b2486de8c1e", "filename": "libgo/go/crypto/cipher/gcm.go", "status": "modified", "additions": 50, "deletions": 20, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fcipher%2Fgcm.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fcipher%2Fgcm.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fgcm.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -52,22 +52,34 @@ type gcmFieldElement struct {\n // gcm represents a Galois Counter Mode with a specific key. See\n // http://csrc.nist.gov/groups/ST/toolkit/BCM/documents/proposedmodes/gcm/gcm-revised-spec.pdf\n type gcm struct {\n-\tcipher Block\n+\tcipher    Block\n+\tnonceSize int\n \t// productTable contains the first sixteen powers of the key, H.\n-\t// However, they are in bit reversed order. See NewGCM.\n+\t// However, they are in bit reversed order. See NewGCMWithNonceSize.\n \tproductTable [16]gcmFieldElement\n }\n \n-// NewGCM returns the given 128-bit, block cipher wrapped in Galois Counter Mode.\n+// NewGCM returns the given 128-bit, block cipher wrapped in Galois Counter Mode\n+// with the standard nonce length.\n func NewGCM(cipher Block) (AEAD, error) {\n+\treturn NewGCMWithNonceSize(cipher, gcmStandardNonceSize)\n+}\n+\n+// NewGCMWithNonceSize returns the given 128-bit, block cipher wrapped in Galois\n+// Counter Mode, which accepts nonces of the given length.\n+//\n+// Only use this function if you require compatibility with an existing\n+// cryptosystem that uses non-standard nonce lengths. All other users should use\n+// NewGCM, which is faster and more resistant to misuse.\n+func NewGCMWithNonceSize(cipher Block, size int) (AEAD, error) {\n \tif cipher.BlockSize() != gcmBlockSize {\n \t\treturn nil, errors.New(\"cipher: NewGCM requires 128-bit block cipher\")\n \t}\n \n \tvar key [gcmBlockSize]byte\n \tcipher.Encrypt(key[:], key[:])\n \n-\tg := &gcm{cipher: cipher}\n+\tg := &gcm{cipher: cipher, nonceSize: size}\n \n \t// We precompute 16 multiples of |key|. However, when we do lookups\n \t// into this table we'll be using bits from a field element and\n@@ -89,30 +101,27 @@ func NewGCM(cipher Block) (AEAD, error) {\n }\n \n const (\n-\tgcmBlockSize = 16\n-\tgcmTagSize   = 16\n-\tgcmNonceSize = 12\n+\tgcmBlockSize         = 16\n+\tgcmTagSize           = 16\n+\tgcmStandardNonceSize = 12\n )\n \n-func (*gcm) NonceSize() int {\n-\treturn gcmNonceSize\n+func (g *gcm) NonceSize() int {\n+\treturn g.nonceSize\n }\n \n func (*gcm) Overhead() int {\n \treturn gcmTagSize\n }\n \n func (g *gcm) Seal(dst, nonce, plaintext, data []byte) []byte {\n-\tif len(nonce) != gcmNonceSize {\n+\tif len(nonce) != g.nonceSize {\n \t\tpanic(\"cipher: incorrect nonce length given to GCM\")\n \t}\n-\n \tret, out := sliceForAppend(dst, len(plaintext)+gcmTagSize)\n \n-\t// See GCM spec, section 7.1.\n \tvar counter, tagMask [gcmBlockSize]byte\n-\tcopy(counter[:], nonce)\n-\tcounter[gcmBlockSize-1] = 1\n+\tg.deriveCounter(&counter, nonce)\n \n \tg.cipher.Encrypt(tagMask[:], counter[:])\n \tgcmInc32(&counter)\n@@ -126,7 +135,7 @@ func (g *gcm) Seal(dst, nonce, plaintext, data []byte) []byte {\n var errOpen = errors.New(\"cipher: message authentication failed\")\n \n func (g *gcm) Open(dst, nonce, ciphertext, data []byte) ([]byte, error) {\n-\tif len(nonce) != gcmNonceSize {\n+\tif len(nonce) != g.nonceSize {\n \t\tpanic(\"cipher: incorrect nonce length given to GCM\")\n \t}\n \n@@ -136,10 +145,8 @@ func (g *gcm) Open(dst, nonce, ciphertext, data []byte) ([]byte, error) {\n \ttag := ciphertext[len(ciphertext)-gcmTagSize:]\n \tciphertext = ciphertext[:len(ciphertext)-gcmTagSize]\n \n-\t// See GCM spec, section 7.1.\n \tvar counter, tagMask [gcmBlockSize]byte\n-\tcopy(counter[:], nonce)\n-\tcounter[gcmBlockSize-1] = 1\n+\tg.deriveCounter(&counter, nonce)\n \n \tg.cipher.Encrypt(tagMask[:], counter[:])\n \tgcmInc32(&counter)\n@@ -198,7 +205,7 @@ var gcmReductionTable = []uint16{\n \t0xe100, 0xfd20, 0xd940, 0xc560, 0x9180, 0x8da0, 0xa9c0, 0xb5e0,\n }\n \n-// mul sets y to y*H, where H is the GCM key, fixed during NewGCM.\n+// mul sets y to y*H, where H is the GCM key, fixed during NewGCMWithNonceSize.\n func (g *gcm) mul(y *gcmFieldElement) {\n \tvar z gcmFieldElement\n \n@@ -219,7 +226,7 @@ func (g *gcm) mul(y *gcmFieldElement) {\n \n \t\t\t// the values in |table| are ordered for\n \t\t\t// little-endian bit positions. See the comment\n-\t\t\t// in NewGCM.\n+\t\t\t// in NewGCMWithNonceSize.\n \t\t\tt := &g.productTable[word&0xf]\n \n \t\t\tz.low ^= t.low\n@@ -301,6 +308,29 @@ func (g *gcm) counterCrypt(out, in []byte, counter *[gcmBlockSize]byte) {\n \t}\n }\n \n+// deriveCounter computes the initial GCM counter state from the given nonce.\n+// See NIST SP 800-38D, section 7.1. This assumes that counter is filled with\n+// zeros on entry.\n+func (g *gcm) deriveCounter(counter *[gcmBlockSize]byte, nonce []byte) {\n+\t// GCM has two modes of operation with respect to the initial counter\n+\t// state: a \"fast path\" for 96-bit (12-byte) nonces, and a \"slow path\"\n+\t// for nonces of other lengths. For a 96-bit nonce, the nonce, along\n+\t// with a four-byte big-endian counter starting at one, is used\n+\t// directly as the starting counter. For other nonce sizes, the counter\n+\t// is computed by passing it through the GHASH function.\n+\tif len(nonce) == gcmStandardNonceSize {\n+\t\tcopy(counter[:], nonce)\n+\t\tcounter[gcmBlockSize-1] = 1\n+\t} else {\n+\t\tvar y gcmFieldElement\n+\t\tg.update(&y, nonce)\n+\t\ty.high ^= uint64(len(nonce)) * 8\n+\t\tg.mul(&y)\n+\t\tputUint64(counter[:8], y.low)\n+\t\tputUint64(counter[8:], y.high)\n+\t}\n+}\n+\n // auth calculates GHASH(ciphertext, additionalData), masks the result with\n // tagMask and writes the result to out.\n func (g *gcm) auth(out, ciphertext, additionalData []byte, tagMask *[gcmTagSize]byte) {"}, {"sha": "81b9aa241912f76fc93d7d9194f5466c4acadfb2", "filename": "libgo/go/crypto/cipher/gcm_test.go", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fcipher%2Fgcm_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fcipher%2Fgcm_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fgcm_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -101,6 +101,35 @@ var aesGCMTests = []struct {\n \t\t\"\",\n \t\t\"b2051c80014f42f08735a7b0cd38e6bcd29962e5f2c13626b85a877101\",\n \t},\n+\t// These cases test non-standard nonce sizes.\n+\t{\n+\t\t\"1672c3537afa82004c6b8a46f6f0d026\",\n+\t\t\"05\",\n+\t\t\"\",\n+\t\t\"\",\n+\t\t\"8e2ad721f9455f74d8b53d3141f27e8e\",\n+\t},\n+\t{\n+\t\t\"9a4fea86a621a91ab371e492457796c0\",\n+\t\t\"75\",\n+\t\t\"ca6131faf0ff210e4e693d6c31c109fc5b6f54224eb120f37de31dc59ec669b6\",\n+\t\t\"4f6e2585c161f05a9ae1f2f894e9f0ab52b45d0f\",\n+\t\t\"5698c0a384241d30004290aac56bb3ece6fe8eacc5c4be98954deb9c3ff6aebf5d50e1af100509e1fba2a5e8a0af9670\",\n+\t},\n+\t{\n+\t\t\"d0f1f4defa1e8c08b4b26d576392027c\",\n+\t\t\"42b4f01eb9f5a1ea5b1eb73b0fb0baed54f387ecaa0393c7d7dffc6af50146ecc021abf7eb9038d4303d91f8d741a11743166c0860208bcc02c6258fd9511a2fa626f96d60b72fcff773af4e88e7a923506e4916ecbd814651e9f445adef4ad6a6b6c7290cc13b956130eef5b837c939fcac0cbbcc9656cd75b13823ee5acdac\",\n+\t\t\"\",\n+\t\t\"\",\n+\t\t\"7ab49b57ddf5f62c427950111c5c4f0d\",\n+\t},\n+\t{\n+\t\t\"4a0c00a3d284dea9d4bf8b8dde86685e\",\n+\t\t\"f8cbe82588e784bcacbe092cd9089b51e01527297f635bf294b3aa787d91057ef23869789698ac960707857f163ecb242135a228ad93964f5dc4a4d7f88fd7b3b07dd0a5b37f9768fb05a523639f108c34c661498a56879e501a2321c8a4a94d7e1b89db255ac1f685e185263368e99735ebe62a7f2931b47282be8eb165e4d7\",\n+\t\t\"6d4bf87640a6a48a50d28797b7\",\n+\t\t\"8d8c7ffc55086d539b5a8f0d1232654c\",\n+\t\t\"0d803ec309482f35b8e6226f2b56303239298e06b281c2d51aaba3c125\",\n+\t},\n }\n \n func TestAESGCM(t *testing.T) {\n@@ -114,7 +143,7 @@ func TestAESGCM(t *testing.T) {\n \t\tnonce, _ := hex.DecodeString(test.nonce)\n \t\tplaintext, _ := hex.DecodeString(test.plaintext)\n \t\tad, _ := hex.DecodeString(test.ad)\n-\t\taesgcm, err := cipher.NewGCM(aes)\n+\t\taesgcm, err := cipher.NewGCMWithNonceSize(aes, len(nonce))\n \t\tif err != nil {\n \t\t\tt.Fatal(err)\n \t\t}"}, {"sha": "184ea9d4d62c74ae04419ca5cf8edb1f7f883d17", "filename": "libgo/go/crypto/crypto.go", "status": "modified", "additions": 46, "deletions": 26, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fcrypto.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fcrypto.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcrypto.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -21,36 +21,40 @@ func (h Hash) HashFunc() Hash {\n }\n \n const (\n-\tMD4       Hash = 1 + iota // import golang.org/x/crypto/md4\n-\tMD5                       // import crypto/md5\n-\tSHA1                      // import crypto/sha1\n-\tSHA224                    // import crypto/sha256\n-\tSHA256                    // import crypto/sha256\n-\tSHA384                    // import crypto/sha512\n-\tSHA512                    // import crypto/sha512\n-\tMD5SHA1                   // no implementation; MD5+SHA1 used for TLS RSA\n-\tRIPEMD160                 // import golang.org/x/crypto/ripemd160\n-\tSHA3_224                  // import golang.org/x/crypto/sha3\n-\tSHA3_256                  // import golang.org/x/crypto/sha3\n-\tSHA3_384                  // import golang.org/x/crypto/sha3\n-\tSHA3_512                  // import golang.org/x/crypto/sha3\n+\tMD4        Hash = 1 + iota // import golang.org/x/crypto/md4\n+\tMD5                        // import crypto/md5\n+\tSHA1                       // import crypto/sha1\n+\tSHA224                     // import crypto/sha256\n+\tSHA256                     // import crypto/sha256\n+\tSHA384                     // import crypto/sha512\n+\tSHA512                     // import crypto/sha512\n+\tMD5SHA1                    // no implementation; MD5+SHA1 used for TLS RSA\n+\tRIPEMD160                  // import golang.org/x/crypto/ripemd160\n+\tSHA3_224                   // import golang.org/x/crypto/sha3\n+\tSHA3_256                   // import golang.org/x/crypto/sha3\n+\tSHA3_384                   // import golang.org/x/crypto/sha3\n+\tSHA3_512                   // import golang.org/x/crypto/sha3\n+\tSHA512_224                 // import crypto/sha512\n+\tSHA512_256                 // import crypto/sha512\n \tmaxHash\n )\n \n var digestSizes = []uint8{\n-\tMD4:       16,\n-\tMD5:       16,\n-\tSHA1:      20,\n-\tSHA224:    28,\n-\tSHA256:    32,\n-\tSHA384:    48,\n-\tSHA512:    64,\n-\tSHA3_224:  28,\n-\tSHA3_256:  32,\n-\tSHA3_384:  48,\n-\tSHA3_512:  64,\n-\tMD5SHA1:   36,\n-\tRIPEMD160: 20,\n+\tMD4:        16,\n+\tMD5:        16,\n+\tSHA1:       20,\n+\tSHA224:     28,\n+\tSHA256:     32,\n+\tSHA384:     48,\n+\tSHA512:     64,\n+\tSHA512_224: 28,\n+\tSHA512_256: 32,\n+\tSHA3_224:   28,\n+\tSHA3_256:   32,\n+\tSHA3_384:   48,\n+\tSHA3_512:   64,\n+\tMD5SHA1:    36,\n+\tRIPEMD160:  20,\n }\n \n // Size returns the length, in bytes, of a digest resulting from the given hash\n@@ -124,3 +128,19 @@ type SignerOpts interface {\n \t// hashing was done.\n \tHashFunc() Hash\n }\n+\n+// Decrypter is an interface for an opaque private key that can be used for\n+// asymmetric decryption operations. An example would be an RSA key\n+// kept in a hardware module.\n+type Decrypter interface {\n+\t// Public returns the public key corresponding to the opaque,\n+\t// private key.\n+\tPublic() PublicKey\n+\n+\t// Decrypt decrypts msg. The opts argument should be appropriate for\n+\t// the primitive used. See the documentation in each implementation for\n+\t// details.\n+\tDecrypt(rand io.Reader, msg []byte, opts DecrypterOpts) (plaintext []byte, err error)\n+}\n+\n+type DecrypterOpts interface{}"}, {"sha": "8d66477fd10d2871e0b4bc571383a683058db4fe", "filename": "libgo/go/crypto/ecdsa/ecdsa.go", "status": "modified", "additions": 59, "deletions": 2, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -4,22 +4,33 @@\n \n // Package ecdsa implements the Elliptic Curve Digital Signature Algorithm, as\n // defined in FIPS 186-3.\n+//\n+// This implementation  derives the nonce from an AES-CTR CSPRNG keyed by\n+// ChopMD(256, SHA2-512(priv.D || entropy || hash)). The CSPRNG key is IRO by\n+// a result of Coron; the AES-CTR stream is IRO under standard assumptions.\n package ecdsa\n \n // References:\n //   [NSA]: Suite B implementer's guide to FIPS 186-3,\n //     http://www.nsa.gov/ia/_files/ecdsa.pdf\n //   [SECG]: SECG, SEC1\n-//     http://www.secg.org/download/aid-780/sec1-v2.pdf\n+//     http://www.secg.org/sec1-v2.pdf\n \n import (\n \t\"crypto\"\n+\t\"crypto/aes\"\n+\t\"crypto/cipher\"\n \t\"crypto/elliptic\"\n+\t\"crypto/sha512\"\n \t\"encoding/asn1\"\n \t\"io\"\n \t\"math/big\"\n )\n \n+const (\n+\taesIV = \"IV for ECDSA CTR\"\n+)\n+\n // PublicKey represents an ECDSA public key.\n type PublicKey struct {\n \telliptic.Curve\n@@ -123,14 +134,46 @@ func fermatInverse(k, N *big.Int) *big.Int {\n // pair of integers. The security of the private key depends on the entropy of\n // rand.\n func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err error) {\n+\t// Get max(log2(q) / 2, 256) bits of entropy from rand.\n+\tentropylen := (priv.Curve.Params().BitSize + 7) / 16\n+\tif entropylen > 32 {\n+\t\tentropylen = 32\n+\t}\n+\tentropy := make([]byte, entropylen)\n+\t_, err = io.ReadFull(rand, entropy)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\t// Initialize an SHA-512 hash context; digest ...\n+\tmd := sha512.New()\n+\tmd.Write(priv.D.Bytes()) // the private key,\n+\tmd.Write(entropy)        // the entropy,\n+\tmd.Write(hash)           // and the input hash;\n+\tkey := md.Sum(nil)[:32]  // and compute ChopMD-256(SHA-512),\n+\t// which is an indifferentiable MAC.\n+\n+\t// Create an AES-CTR instance to use as a CSPRNG.\n+\tblock, err := aes.NewCipher(key)\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\t// Create a CSPRNG that xors a stream of zeros with\n+\t// the output of the AES-CTR instance.\n+\tcsprng := cipher.StreamReader{\n+\t\tR: zeroReader,\n+\t\tS: cipher.NewCTR(block, []byte(aesIV)),\n+\t}\n+\n \t// See [NSA] 3.4.1\n \tc := priv.PublicKey.Curve\n \tN := c.Params().N\n \n \tvar k, kInv *big.Int\n \tfor {\n \t\tfor {\n-\t\t\tk, err = randFieldElement(c, rand)\n+\t\t\tk, err = randFieldElement(c, csprng)\n \t\t\tif err != nil {\n \t\t\t\tr = nil\n \t\t\t\treturn\n@@ -187,3 +230,17 @@ func Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool {\n \tx.Mod(x, N)\n \treturn x.Cmp(r) == 0\n }\n+\n+type zr struct {\n+\tio.Reader\n+}\n+\n+// Read replaces the contents of dst with zeros.\n+func (z *zr) Read(dst []byte) (n int, err error) {\n+\tfor i := range dst {\n+\t\tdst[i] = 0\n+\t}\n+\treturn len(dst), nil\n+}\n+\n+var zeroReader = &zr{}"}, {"sha": "169944dfb27b2207cd1076aed95dc2a037a21328", "filename": "libgo/go/crypto/ecdsa/ecdsa_test.go", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -72,6 +72,78 @@ func TestSignAndVerify(t *testing.T) {\n \ttestSignAndVerify(t, elliptic.P521(), \"p521\")\n }\n \n+func testNonceSafety(t *testing.T, c elliptic.Curve, tag string) {\n+\tpriv, _ := GenerateKey(c, rand.Reader)\n+\n+\thashed := []byte(\"testing\")\n+\tr0, s0, err := Sign(zeroReader, priv, hashed)\n+\tif err != nil {\n+\t\tt.Errorf(\"%s: error signing: %s\", tag, err)\n+\t\treturn\n+\t}\n+\n+\thashed = []byte(\"testing...\")\n+\tr1, s1, err := Sign(zeroReader, priv, hashed)\n+\tif err != nil {\n+\t\tt.Errorf(\"%s: error signing: %s\", tag, err)\n+\t\treturn\n+\t}\n+\n+\tif s0.Cmp(s1) == 0 {\n+\t\t// This should never happen.\n+\t\tt.Errorf(\"%s: the signatures on two different messages were the same\")\n+\t}\n+\n+\tif r0.Cmp(r1) == 0 {\n+\t\tt.Errorf(\"%s: the nonce used for two diferent messages was the same\")\n+\t}\n+}\n+\n+func TestNonceSafety(t *testing.T) {\n+\ttestNonceSafety(t, elliptic.P224(), \"p224\")\n+\tif testing.Short() {\n+\t\treturn\n+\t}\n+\ttestNonceSafety(t, elliptic.P256(), \"p256\")\n+\ttestNonceSafety(t, elliptic.P384(), \"p384\")\n+\ttestNonceSafety(t, elliptic.P521(), \"p521\")\n+}\n+\n+func testINDCCA(t *testing.T, c elliptic.Curve, tag string) {\n+\tpriv, _ := GenerateKey(c, rand.Reader)\n+\n+\thashed := []byte(\"testing\")\n+\tr0, s0, err := Sign(rand.Reader, priv, hashed)\n+\tif err != nil {\n+\t\tt.Errorf(\"%s: error signing: %s\", tag, err)\n+\t\treturn\n+\t}\n+\n+\tr1, s1, err := Sign(rand.Reader, priv, hashed)\n+\tif err != nil {\n+\t\tt.Errorf(\"%s: error signing: %s\", tag, err)\n+\t\treturn\n+\t}\n+\n+\tif s0.Cmp(s1) == 0 {\n+\t\tt.Errorf(\"%s: two signatures of the same message produced the same result\")\n+\t}\n+\n+\tif r0.Cmp(r1) == 0 {\n+\t\tt.Errorf(\"%s: two signatures of the same message produced the same nonce\")\n+\t}\n+}\n+\n+func TestINDCCA(t *testing.T) {\n+\ttestINDCCA(t, elliptic.P224(), \"p224\")\n+\tif testing.Short() {\n+\t\treturn\n+\t}\n+\ttestINDCCA(t, elliptic.P256(), \"p256\")\n+\ttestINDCCA(t, elliptic.P384(), \"p384\")\n+\ttestINDCCA(t, elliptic.P521(), \"p521\")\n+}\n+\n func fromHex(s string) *big.Int {\n \tr, ok := new(big.Int).SetString(s, 16)\n \tif !ok {"}, {"sha": "e6b59c5f436b9d24a8a61e093bd2adcc079e72ba", "filename": "libgo/go/crypto/elliptic/elliptic.go", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -24,7 +24,7 @@ import (\n type Curve interface {\n \t// Params returns the parameters for the curve.\n \tParams() *CurveParams\n-\t// IsOnCurve returns true if the given (x,y) lies on the curve.\n+\t// IsOnCurve reports whether the given (x,y) lies on the curve.\n \tIsOnCurve(x, y *big.Int) bool\n \t// Add returns the sum of (x1,y1) and (x2,y2)\n \tAdd(x1, y1, x2, y2 *big.Int) (x, y *big.Int)\n@@ -45,6 +45,7 @@ type CurveParams struct {\n \tB       *big.Int // the constant of the curve equation\n \tGx, Gy  *big.Int // (x,y) of the base point\n \tBitSize int      // the size of the underlying field\n+\tName    string   // the canonical name of the curve\n }\n \n func (curve *CurveParams) Params() *CurveParams {\n@@ -307,7 +308,8 @@ func Marshal(curve Curve, x, y *big.Int) []byte {\n \treturn ret\n }\n \n-// Unmarshal converts a point, serialized by Marshal, into an x, y pair. On error, x = nil.\n+// Unmarshal converts a point, serialized by Marshal, into an x, y pair.\n+// It is an error if the point is not on the curve. On error, x = nil.\n func Unmarshal(curve Curve, data []byte) (x, y *big.Int) {\n \tbyteLen := (curve.Params().BitSize + 7) >> 3\n \tif len(data) != 1+2*byteLen {\n@@ -318,6 +320,9 @@ func Unmarshal(curve Curve, data []byte) (x, y *big.Int) {\n \t}\n \tx = new(big.Int).SetBytes(data[1 : 1+byteLen])\n \ty = new(big.Int).SetBytes(data[1+byteLen:])\n+\tif !curve.IsOnCurve(x, y) {\n+\t\tx, y = nil, nil\n+\t}\n \treturn\n }\n \n@@ -334,7 +339,7 @@ func initAll() {\n \n func initP384() {\n \t// See FIPS 186-3, section D.2.4\n-\tp384 = new(CurveParams)\n+\tp384 = &CurveParams{Name: \"P-384\"}\n \tp384.P, _ = new(big.Int).SetString(\"39402006196394479212279040100143613805079739270465446667948293404245721771496870329047266088258938001861606973112319\", 10)\n \tp384.N, _ = new(big.Int).SetString(\"39402006196394479212279040100143613805079739270465446667946905279627659399113263569398956308152294913554433653942643\", 10)\n \tp384.B, _ = new(big.Int).SetString(\"b3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef\", 16)\n@@ -345,7 +350,7 @@ func initP384() {\n \n func initP521() {\n \t// See FIPS 186-3, section D.2.5\n-\tp521 = new(CurveParams)\n+\tp521 = &CurveParams{Name: \"P-521\"}\n \tp521.P, _ = new(big.Int).SetString(\"6864797660130609714981900799081393217269435300143305409394463459185543183397656052122559640661454554977296311391480858037121987999716643812574028291115057151\", 10)\n \tp521.N, _ = new(big.Int).SetString(\"6864797660130609714981900799081393217269435300143305409394463459185543183397655394245057746333217197532963996371363321113864768612440380340372808892707005449\", 10)\n \tp521.B, _ = new(big.Int).SetString(\"051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00\", 16)"}, {"sha": "7e27913dcd0505001411377f2f4fab3ebfb21d65", "filename": "libgo/go/crypto/elliptic/elliptic_test.go", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -19,6 +19,19 @@ func TestOnCurve(t *testing.T) {\n \t}\n }\n \n+func TestOffCurve(t *testing.T) {\n+\tp224 := P224()\n+\tx, y := new(big.Int).SetInt64(1), new(big.Int).SetInt64(1)\n+\tif p224.IsOnCurve(x, y) {\n+\t\tt.Errorf(\"FAIL: point off curve is claimed to be on the curve\")\n+\t}\n+\tb := Marshal(p224, x, y)\n+\tx1, y1 := Unmarshal(p224, b)\n+\tif x1 != nil || y1 != nil {\n+\t\tt.Errorf(\"FAIL: unmarshalling a point not on the curve succeeded\")\n+\t}\n+}\n+\n type baseMultTest struct {\n \tk    string\n \tx, y string"}, {"sha": "2d3fac74fbfa4bd019ae6a0997ad79354037aa17", "filename": "libgo/go/crypto/elliptic/p224.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp224.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp224.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp224.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -22,7 +22,7 @@ type p224Curve struct {\n \n func initP224() {\n \t// See FIPS 186-3, section D.2.2\n-\tp224.CurveParams = new(CurveParams)\n+\tp224.CurveParams = &CurveParams{Name: \"P-224\"}\n \tp224.P, _ = new(big.Int).SetString(\"26959946667150639794667015087019630673557916260026308143510066298881\", 10)\n \tp224.N, _ = new(big.Int).SetString(\"26959946667150639794667015087019625940457807714424391721682722368061\", 10)\n \tp224.B, _ = new(big.Int).SetString(\"b4050a850c04b3abf54132565044b0b7d7bfd8ba270b39432355ffb4\", 16)"}, {"sha": "82bc7b3019e62c6d7fd468bb2b59b88c43c3201e", "filename": "libgo/go/crypto/elliptic/p256.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp256.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp256.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp256.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -23,7 +23,7 @@ var (\n \n func initP256() {\n \t// See FIPS 186-3, section D.2.3\n-\tp256.CurveParams = new(CurveParams)\n+\tp256.CurveParams = &CurveParams{Name: \"P-256\"}\n \tp256.P, _ = new(big.Int).SetString(\"115792089210356248762697446949407573530086143415290314195533631308867097853951\", 10)\n \tp256.N, _ = new(big.Int).SetString(\"115792089210356248762697446949407573529996955224135760342422259061068512044369\", 10)\n \tp256.B, _ = new(big.Int).SetString(\"5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b\", 16)"}, {"sha": "e0cc1d6d2241331c02f2fd489e4c5efff5fb2c52", "filename": "libgo/go/crypto/hmac/hmac.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fhmac%2Fhmac.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -11,7 +11,7 @@ The receiver verifies the hash by recomputing it using the same key.\n Receivers should be careful to use Equal to compare MACs in order to avoid\n timing side-channels:\n \n-\t// CheckMAC returns true if messageMAC is a valid HMAC tag for message.\n+\t// CheckMAC reports whether messageMAC is a valid HMAC tag for message.\n \tfunc CheckMAC(message, messageMAC, key []byte) bool {\n \t\tmac := hmac.New(sha256.New, key)\n \t\tmac.Write(message)"}, {"sha": "2c853d0a13455ed70e497f92a2de09a7e45b3d14", "filename": "libgo/go/crypto/rand/eagain.go", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Frand%2Feagain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Frand%2Feagain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Feagain.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build darwin dragonfly freebsd linux nacl netbsd openbsd solaris\n+\n+package rand\n+\n+import (\n+\t\"os\"\n+\t\"syscall\"\n+)\n+\n+func init() {\n+\tisEAGAIN = unixIsEAGAIN\n+}\n+\n+// unixIsEAGAIN reports whether err is a syscall.EAGAIN wrapped in a PathError.\n+// See golang.org/issue/9205\n+func unixIsEAGAIN(err error) bool {\n+\tif pe, ok := err.(*os.PathError); ok {\n+\t\tif errno, ok := pe.Err.(syscall.Errno); ok && errno == syscall.EAGAIN {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}"}, {"sha": "ee32fa0bd67e52cffea909e36d7ba0eeeb1d2056", "filename": "libgo/go/crypto/rand/rand.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Frand%2Frand.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Frand%2Frand.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Frand.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -10,7 +10,9 @@ import \"io\"\n \n // Reader is a global, shared instance of a cryptographically\n // strong pseudo-random generator.\n+//\n // On Unix-like systems, Reader reads from /dev/urandom.\n+// On Linux, Reader uses getrandom(2) if available, /dev/urandom otherwise.\n // On Windows systems, Reader uses the CryptGenRandom API.\n var Reader io.Reader\n "}, {"sha": "7d6d9e8a09405860f33bc9d3d207b6489252d238", "filename": "libgo/go/crypto/rand/rand_linux.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Frand%2Frand_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Frand%2Frand_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Frand_linux.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -5,7 +5,7 @@\n package rand\n \n import (\n-\t\"internal/syscall\"\n+\t\"internal/syscall/unix\"\n \t\"sync\"\n )\n \n@@ -25,7 +25,7 @@ func pickStrategy() {\n \t// - the machine has no entropy available (early boot + no hardware\n \t//   entropy source?) and we want to avoid blocking later.\n \tvar buf [1]byte\n-\tn, err := syscall.GetRandom(buf[:], syscall.GRND_NONBLOCK)\n+\tn, err := unix.GetRandom(buf[:], unix.GRND_NONBLOCK)\n \tuseSyscall = n == 1 && err == nil\n }\n \n@@ -34,6 +34,6 @@ func getRandomLinux(p []byte) (ok bool) {\n \tif !useSyscall {\n \t\treturn false\n \t}\n-\tn, err := syscall.GetRandom(p, 0)\n+\tn, err := unix.GetRandom(p, 0)\n \treturn n == len(p) && err == nil\n }"}, {"sha": "75c36e05b34020f92e057fd2966f073cf0e40c74", "filename": "libgo/go/crypto/rand/rand_unix.go", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Frand%2Frand_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Frand%2Frand_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Frand_unix.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -58,12 +58,28 @@ func (r *devReader) Read(b []byte) (n int, err error) {\n \t\tif runtime.GOOS == \"plan9\" {\n \t\t\tr.f = f\n \t\t} else {\n-\t\t\tr.f = bufio.NewReader(f)\n+\t\t\tr.f = bufio.NewReader(hideAgainReader{f})\n \t\t}\n \t}\n \treturn r.f.Read(b)\n }\n \n+var isEAGAIN func(error) bool // set by eagain.go on unix systems\n+\n+// hideAgainReader masks EAGAIN reads from /dev/urandom.\n+// See golang.org/issue/9205\n+type hideAgainReader struct {\n+\tr io.Reader\n+}\n+\n+func (hr hideAgainReader) Read(p []byte) (n int, err error) {\n+\tn, err = hr.r.Read(p)\n+\tif err != nil && isEAGAIN != nil && isEAGAIN(err) {\n+\t\terr = nil\n+\t}\n+\treturn\n+}\n+\n // Alternate pseudo-random implementation for use on\n // systems without a reliable /dev/urandom.\n "}, {"sha": "2f7cba8364a3e30f7cfbdf369971cd164005efa2", "filename": "libgo/go/crypto/rand/util_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Frand%2Futil_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Frand%2Futil_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Futil_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -10,7 +10,7 @@ import (\n \t\"testing\"\n )\n \n-// http://golang.org/issue/6849.\n+// https://golang.org/issue/6849.\n func TestPrimeSmall(t *testing.T) {\n \tfor n := 2; n < 10; n++ {\n \t\tp, err := rand.Prime(rand.Reader, n)"}, {"sha": "34037b0d674f72a8d3ec89bba1aa1a3d6c2594e7", "filename": "libgo/go/crypto/rsa/pkcs1v15.go", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -14,6 +14,16 @@ import (\n \n // This file implements encryption and decryption using PKCS#1 v1.5 padding.\n \n+// PKCS1v15DecrypterOpts is for passing options to PKCS#1 v1.5 decryption using\n+// the crypto.Decrypter interface.\n+type PKCS1v15DecryptOptions struct {\n+\t// SessionKeyLen is the length of the session key that is being\n+\t// decrypted. If not zero, then a padding error during decryption will\n+\t// cause a random plaintext of this length to be returned rather than\n+\t// an error. These alternatives happen in constant time.\n+\tSessionKeyLen int\n+}\n+\n // EncryptPKCS1v15 encrypts the given message with RSA and the padding scheme from PKCS#1 v1.5.\n // The message must be no longer than the length of the public modulus minus 11 bytes.\n // WARNING: use of this function to encrypt plaintexts other than session keys"}, {"sha": "89253751ec2696784ed4bf42d654a090a05d360f", "filename": "libgo/go/crypto/rsa/pkcs1v15_test.go", "status": "modified", "additions": 35, "deletions": 8, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -51,14 +51,25 @@ var decryptPKCS1v15Tests = []DecryptPKCS1v15Test{\n }\n \n func TestDecryptPKCS1v15(t *testing.T) {\n-\tfor i, test := range decryptPKCS1v15Tests {\n-\t\tout, err := DecryptPKCS1v15(nil, rsaPrivateKey, decodeBase64(test.in))\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"#%d error decrypting\", i)\n-\t\t}\n-\t\twant := []byte(test.out)\n-\t\tif !bytes.Equal(out, want) {\n-\t\t\tt.Errorf(\"#%d got:%#v want:%#v\", i, out, want)\n+\tdecryptionFuncs := []func([]byte) ([]byte, error){\n+\t\tfunc(ciphertext []byte) (plaintext []byte, err error) {\n+\t\t\treturn DecryptPKCS1v15(nil, rsaPrivateKey, ciphertext)\n+\t\t},\n+\t\tfunc(ciphertext []byte) (plaintext []byte, err error) {\n+\t\t\treturn rsaPrivateKey.Decrypt(nil, ciphertext, nil)\n+\t\t},\n+\t}\n+\n+\tfor _, decryptFunc := range decryptionFuncs {\n+\t\tfor i, test := range decryptPKCS1v15Tests {\n+\t\t\tout, err := decryptFunc(decodeBase64(test.in))\n+\t\t\tif err != nil {\n+\t\t\t\tt.Errorf(\"#%d error decrypting\", i)\n+\t\t\t}\n+\t\t\twant := []byte(test.out)\n+\t\t\tif !bytes.Equal(out, want) {\n+\t\t\t\tt.Errorf(\"#%d got:%#v want:%#v\", i, out, want)\n+\t\t\t}\n \t\t}\n \t}\n }\n@@ -138,6 +149,22 @@ func TestEncryptPKCS1v15SessionKey(t *testing.T) {\n \t}\n }\n \n+func TestEncryptPKCS1v15DecrypterSessionKey(t *testing.T) {\n+\tfor i, test := range decryptPKCS1v15SessionKeyTests {\n+\t\tplaintext, err := rsaPrivateKey.Decrypt(rand.Reader, decodeBase64(test.in), &PKCS1v15DecryptOptions{SessionKeyLen: 4})\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"#%d: error decrypting: %s\", i, err)\n+\t\t}\n+\t\tif len(plaintext) != 4 {\n+\t\t\tt.Fatalf(\"#%d: incorrect length plaintext: got %d, want 4\", i, len(plaintext))\n+\t\t}\n+\n+\t\tif test.out != \"FAIL\" && !bytes.Equal(plaintext, []byte(test.out)) {\n+\t\t\tt.Errorf(\"#%d: incorrect plaintext: got %x, want %x\", plaintext, test.out)\n+\t\t}\n+\t}\n+}\n+\n func TestNonZeroRandomBytes(t *testing.T) {\n \trandom := rand.Reader\n "}, {"sha": "0a41814a4b1e7c7a772f5ba3850068cefe88fbe9", "filename": "libgo/go/crypto/rsa/pss.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Frsa%2Fpss.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Frsa%2Fpss.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Fpss.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -255,7 +255,7 @@ func SignPSS(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []byte,\n \t\tsaltLength = hash.Size()\n \t}\n \n-\tif opts.Hash != 0 {\n+\tif opts != nil && opts.Hash != 0 {\n \t\thash = opts.Hash\n \t}\n "}, {"sha": "cae24e58c6794ce5db502932f6504934bf4115cc", "filename": "libgo/go/crypto/rsa/pss_test.go", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Frsa%2Fpss_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Frsa%2Fpss_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Fpss_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -189,6 +189,15 @@ func TestPSSOpenSSL(t *testing.T) {\n \t}\n }\n \n+func TestPSSNilOpts(t *testing.T) {\n+\thash := crypto.SHA256\n+\th := hash.New()\n+\th.Write([]byte(\"testing\"))\n+\thashed := h.Sum(nil)\n+\n+\tSignPSS(rand.Reader, rsaPrivateKey, hash, hashed, nil)\n+}\n+\n func TestPSSSigning(t *testing.T) {\n \tvar saltLengthCombinations = []struct {\n \t\tsignSaltLength, verifySaltLength int"}, {"sha": "1293b783679b143440aabb2d5a9e04a391273f46", "filename": "libgo/go/crypto/rsa/rsa.go", "status": "modified", "additions": 46, "deletions": 11, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -24,6 +24,16 @@ type PublicKey struct {\n \tE int      // public exponent\n }\n \n+// OAEPOptions is an interface for passing options to OAEP decryption using the\n+// crypto.Decrypter interface.\n+type OAEPOptions struct {\n+\t// Hash is the hash function that will be used when generating the mask.\n+\tHash crypto.Hash\n+\t// Label is an arbitrary byte string that must be equal to the value\n+\t// used when encrypting.\n+\tLabel []byte\n+}\n+\n var (\n \terrPublicModulus       = errors.New(\"crypto/rsa: missing public modulus\")\n \terrPublicExponentSmall = errors.New(\"crypto/rsa: public exponent too small\")\n@@ -77,6 +87,37 @@ func (priv *PrivateKey) Sign(rand io.Reader, msg []byte, opts crypto.SignerOpts)\n \treturn SignPKCS1v15(rand, priv, opts.HashFunc(), msg)\n }\n \n+// Decrypt decrypts ciphertext with priv. If opts is nil or of type\n+// *PKCS1v15DecryptOptions then PKCS#1 v1.5 decryption is performed. Otherwise\n+// opts must have type *OAEPOptions and OAEP decryption is done.\n+func (priv *PrivateKey) Decrypt(rand io.Reader, ciphertext []byte, opts crypto.DecrypterOpts) (plaintext []byte, err error) {\n+\tif opts == nil {\n+\t\treturn DecryptPKCS1v15(rand, priv, ciphertext)\n+\t}\n+\n+\tswitch opts := opts.(type) {\n+\tcase *OAEPOptions:\n+\t\treturn DecryptOAEP(opts.Hash.New(), rand, priv, ciphertext, opts.Label)\n+\n+\tcase *PKCS1v15DecryptOptions:\n+\t\tif l := opts.SessionKeyLen; l > 0 {\n+\t\t\tplaintext = make([]byte, l)\n+\t\t\tif _, err := io.ReadFull(rand, plaintext); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tif err := DecryptPKCS1v15SessionKey(rand, priv, ciphertext, plaintext); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\treturn plaintext, nil\n+\t\t} else {\n+\t\t\treturn DecryptPKCS1v15(rand, priv, ciphertext)\n+\t\t}\n+\n+\tdefault:\n+\t\treturn nil, errors.New(\"crypto/rsa: invalid options for Decrypt\")\n+\t}\n+}\n+\n type PrecomputedValues struct {\n \tDp, Dq *big.Int // D mod (P-1) (or mod Q-1)\n \tQinv   *big.Int // Q^-1 mod P\n@@ -88,7 +129,7 @@ type PrecomputedValues struct {\n \tCRTValues []CRTValue\n }\n \n-// CRTValue contains the precomputed chinese remainder theorem values.\n+// CRTValue contains the precomputed Chinese remainder theorem values.\n type CRTValue struct {\n \tExp   *big.Int // D mod (prime-1).\n \tCoeff *big.Int // R\u00b7Coeff \u2261 1 mod Prime.\n@@ -102,19 +143,13 @@ func (priv *PrivateKey) Validate() error {\n \t\treturn err\n \t}\n \n-\t// Check that the prime factors are actually prime. Note that this is\n-\t// just a sanity check. Since the random witnesses chosen by\n-\t// ProbablyPrime are deterministic, given the candidate number, it's\n-\t// easy for an attack to generate composites that pass this test.\n-\tfor _, prime := range priv.Primes {\n-\t\tif !prime.ProbablyPrime(20) {\n-\t\t\treturn errors.New(\"crypto/rsa: prime factor is composite\")\n-\t\t}\n-\t}\n-\n \t// Check that \u03a0primes == n.\n \tmodulus := new(big.Int).Set(bigOne)\n \tfor _, prime := range priv.Primes {\n+\t\t// Any primes \u2264 1 will cause divide-by-zero panics later.\n+\t\tif prime.Cmp(bigOne) <= 0 {\n+\t\t\treturn errors.New(\"crypto/rsa: invalid prime value\")\n+\t\t}\n \t\tmodulus.Mul(modulus, prime)\n \t}\n \tif modulus.Cmp(priv.N) != 0 {"}, {"sha": "e7781fd2f41159ba8d03f770a6fe78653acf2cd0", "filename": "libgo/go/crypto/sha512/sha512.go", "status": "modified", "additions": 126, "deletions": 36, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -2,8 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// Package sha512 implements the SHA384 and SHA512 hash algorithms as defined\n-// in FIPS 180-2.\n+// Package sha512 implements the SHA-384, SHA-512, SHA-512/224, and SHA-512/256\n+// hash algorithms as defined in FIPS 180-4.\n package sha512\n \n import (\n@@ -14,16 +14,27 @@ import (\n func init() {\n \tcrypto.RegisterHash(crypto.SHA384, New384)\n \tcrypto.RegisterHash(crypto.SHA512, New)\n+\tcrypto.RegisterHash(crypto.SHA512_224, New512_224)\n+\tcrypto.RegisterHash(crypto.SHA512_256, New512_256)\n }\n \n-// The size of a SHA512 checksum in bytes.\n-const Size = 64\n+const (\n+\t// Size is the size, in bytes, of a SHA-512 checksum.\n+\tSize = 64\n+\n+\t// Size224 is the size, in bytes, of a SHA-512/224 checksum.\n+\tSize224 = 28\n+\n+\t// Size256 is the size, in bytes, of a SHA-512/256 checksum.\n+\tSize256 = 32\n \n-// The size of a SHA384 checksum in bytes.\n-const Size384 = 48\n+\t// Size384 is the size, in bytes, of a SHA-384 checksum.\n+\tSize384 = 48\n \n-// The blocksize of SHA512 and SHA384 in bytes.\n-const BlockSize = 128\n+\t// BlockSize is the block size, in bytes, of the SHA-512/224,\n+\t// SHA-512/256, SHA-384 and SHA-512 hash functions.\n+\tBlockSize = 128\n+)\n \n const (\n \tchunk     = 128\n@@ -35,6 +46,22 @@ const (\n \tinit5     = 0x9b05688c2b3e6c1f\n \tinit6     = 0x1f83d9abfb41bd6b\n \tinit7     = 0x5be0cd19137e2179\n+\tinit0_224 = 0x8c3d37c819544da2\n+\tinit1_224 = 0x73e1996689dcd4d6\n+\tinit2_224 = 0x1dfab7ae32ff9c82\n+\tinit3_224 = 0x679dd514582f9fcf\n+\tinit4_224 = 0x0f6d2b697bd44da8\n+\tinit5_224 = 0x77e36f7304c48942\n+\tinit6_224 = 0x3f9d85a86a1d36c8\n+\tinit7_224 = 0x1112e6ad91d692a1\n+\tinit0_256 = 0x22312194fc2bf72c\n+\tinit1_256 = 0x9f555fa3c84c64c2\n+\tinit2_256 = 0x2393b86b6f53b151\n+\tinit3_256 = 0x963877195940eabd\n+\tinit4_256 = 0x96283ee2a88effe3\n+\tinit5_256 = 0xbe5e1e2553863992\n+\tinit6_256 = 0x2b0199fc2c85b8aa\n+\tinit7_256 = 0x0eb72ddc81c52ca2\n \tinit0_384 = 0xcbbb9d5dc1059ed8\n \tinit1_384 = 0x629a292a367cd507\n \tinit2_384 = 0x9159015a3070dd17\n@@ -47,24 +74,16 @@ const (\n \n // digest represents the partial evaluation of a checksum.\n type digest struct {\n-\th     [8]uint64\n-\tx     [chunk]byte\n-\tnx    int\n-\tlen   uint64\n-\tis384 bool // mark if this digest is SHA-384\n+\th        [8]uint64\n+\tx        [chunk]byte\n+\tnx       int\n+\tlen      uint64\n+\tfunction crypto.Hash\n }\n \n func (d *digest) Reset() {\n-\tif !d.is384 {\n-\t\td.h[0] = init0\n-\t\td.h[1] = init1\n-\t\td.h[2] = init2\n-\t\td.h[3] = init3\n-\t\td.h[4] = init4\n-\t\td.h[5] = init5\n-\t\td.h[6] = init6\n-\t\td.h[7] = init7\n-\t} else {\n+\tswitch d.function {\n+\tcase crypto.SHA384:\n \t\td.h[0] = init0_384\n \t\td.h[1] = init1_384\n \t\td.h[2] = init2_384\n@@ -73,31 +92,77 @@ func (d *digest) Reset() {\n \t\td.h[5] = init5_384\n \t\td.h[6] = init6_384\n \t\td.h[7] = init7_384\n+\tcase crypto.SHA512_224:\n+\t\td.h[0] = init0_224\n+\t\td.h[1] = init1_224\n+\t\td.h[2] = init2_224\n+\t\td.h[3] = init3_224\n+\t\td.h[4] = init4_224\n+\t\td.h[5] = init5_224\n+\t\td.h[6] = init6_224\n+\t\td.h[7] = init7_224\n+\tcase crypto.SHA512_256:\n+\t\td.h[0] = init0_256\n+\t\td.h[1] = init1_256\n+\t\td.h[2] = init2_256\n+\t\td.h[3] = init3_256\n+\t\td.h[4] = init4_256\n+\t\td.h[5] = init5_256\n+\t\td.h[6] = init6_256\n+\t\td.h[7] = init7_256\n+\tdefault:\n+\t\td.h[0] = init0\n+\t\td.h[1] = init1\n+\t\td.h[2] = init2\n+\t\td.h[3] = init3\n+\t\td.h[4] = init4\n+\t\td.h[5] = init5\n+\t\td.h[6] = init6\n+\t\td.h[7] = init7\n \t}\n \td.nx = 0\n \td.len = 0\n }\n \n-// New returns a new hash.Hash computing the SHA512 checksum.\n+// New returns a new hash.Hash computing the SHA-512 checksum.\n func New() hash.Hash {\n-\td := new(digest)\n+\td := &digest{function: crypto.SHA512}\n \td.Reset()\n \treturn d\n }\n \n-// New384 returns a new hash.Hash computing the SHA384 checksum.\n+// New512_224 returns a new hash.Hash computing the SHA-512/224 checksum.\n+func New512_224() hash.Hash {\n+\td := &digest{function: crypto.SHA512_224}\n+\td.Reset()\n+\treturn d\n+}\n+\n+// New512_256 returns a new hash.Hash computing the SHA-512/256 checksum.\n+func New512_256() hash.Hash {\n+\td := &digest{function: crypto.SHA512_256}\n+\td.Reset()\n+\treturn d\n+}\n+\n+// New384 returns a new hash.Hash computing the SHA-384 checksum.\n func New384() hash.Hash {\n-\td := new(digest)\n-\td.is384 = true\n+\td := &digest{function: crypto.SHA384}\n \td.Reset()\n \treturn d\n }\n \n func (d *digest) Size() int {\n-\tif !d.is384 {\n+\tswitch d.function {\n+\tcase crypto.SHA512_224:\n+\t\treturn Size224\n+\tcase crypto.SHA512_256:\n+\t\treturn Size256\n+\tcase crypto.SHA384:\n+\t\treturn Size384\n+\tdefault:\n \t\treturn Size\n \t}\n-\treturn Size384\n }\n \n func (d *digest) BlockSize() int { return BlockSize }\n@@ -130,10 +195,16 @@ func (d0 *digest) Sum(in []byte) []byte {\n \td := new(digest)\n \t*d = *d0\n \thash := d.checkSum()\n-\tif d.is384 {\n+\tswitch d.function {\n+\tcase crypto.SHA384:\n \t\treturn append(in, hash[:Size384]...)\n+\tcase crypto.SHA512_224:\n+\t\treturn append(in, hash[:Size224]...)\n+\tcase crypto.SHA512_256:\n+\t\treturn append(in, hash[:Size256]...)\n+\tdefault:\n+\t\treturn append(in, hash[:]...)\n \t}\n-\treturn append(in, hash[:]...)\n }\n \n func (d *digest) checkSum() [Size]byte {\n@@ -159,7 +230,7 @@ func (d *digest) checkSum() [Size]byte {\n \t}\n \n \th := d.h[:]\n-\tif d.is384 {\n+\tif d.function == crypto.SHA384 {\n \t\th = d.h[:6]\n \t}\n \n@@ -180,19 +251,38 @@ func (d *digest) checkSum() [Size]byte {\n \n // Sum512 returns the SHA512 checksum of the data.\n func Sum512(data []byte) [Size]byte {\n-\tvar d digest\n+\td := digest{function: crypto.SHA512}\n \td.Reset()\n \td.Write(data)\n \treturn d.checkSum()\n }\n \n // Sum384 returns the SHA384 checksum of the data.\n func Sum384(data []byte) (sum384 [Size384]byte) {\n-\tvar d digest\n-\td.is384 = true\n+\td := digest{function: crypto.SHA384}\n \td.Reset()\n \td.Write(data)\n \tsum := d.checkSum()\n \tcopy(sum384[:], sum[:Size384])\n \treturn\n }\n+\n+// Sum512_224 returns the Sum512/224 checksum of the data.\n+func Sum512_224(data []byte) (sum224 [Size224]byte) {\n+\td := digest{function: crypto.SHA512_224}\n+\td.Reset()\n+\td.Write(data)\n+\tsum := d.checkSum()\n+\tcopy(sum224[:], sum[:Size224])\n+\treturn\n+}\n+\n+// Sum512_256 returns the Sum512/256 checksum of the data.\n+func Sum512_256(data []byte) (sum256 [Size256]byte) {\n+\td := digest{function: crypto.SHA512_256}\n+\td.Reset()\n+\td.Write(data)\n+\tsum := d.checkSum()\n+\tcopy(sum256[:], sum[:Size256])\n+\treturn\n+}"}, {"sha": "04b3d4a3cc0ab12c0ac85a1a5ecdb05addbbb534", "filename": "libgo/go/crypto/sha512/sha512_test.go", "status": "modified", "additions": 263, "deletions": 109, "changes": 372, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -2,133 +2,279 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// SHA512 hash algorithm.  See FIPS 180-2.\n+// SHA512 hash algorithm.  See FIPS 180-4.\n \n package sha512\n \n import (\n-\t\"fmt\"\n+\t\"encoding/hex\"\n+\t\"hash\"\n \t\"io\"\n \t\"testing\"\n )\n \n type sha512Test struct {\n-\tout string\n-\tin  string\n+\tin     string\n+\tout224 string\n+\tout256 string\n+\tout384 string\n+\tout512 string\n }\n \n var golden = []sha512Test{\n-\t{\"cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e\", \"\"},\n-\t{\"1f40fc92da241694750979ee6cf582f2d5d7d28e18335de05abc54d0560e0f5302860c652bf08d560252aa5e74210546f369fbbbce8c12cfc7957b2652fe9a75\", \"a\"},\n-\t{\"2d408a0717ec188158278a796c689044361dc6fdde28d6f04973b80896e1823975cdbf12eb63f9e0591328ee235d80e9b5bf1aa6a44f4617ff3caf6400eb172d\", \"ab\"},\n-\t{\"ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f\", \"abc\"},\n-\t{\"d8022f2060ad6efd297ab73dcc5355c9b214054b0d1776a136a669d26a7d3b14f73aa0d0ebff19ee333368f0164b6419a96da49e3e481753e7e96b716bdccb6f\", \"abcd\"},\n-\t{\"878ae65a92e86cac011a570d4c30a7eaec442b85ce8eca0c2952b5e3cc0628c2e79d889ad4d5c7c626986d452dd86374b6ffaa7cd8b67665bef2289a5c70b0a1\", \"abcde\"},\n-\t{\"e32ef19623e8ed9d267f657a81944b3d07adbb768518068e88435745564e8d4150a0a703be2a7d88b61e3d390c2bb97e2d4c311fdc69d6b1267f05f59aa920e7\", \"abcdef\"},\n-\t{\"d716a4188569b68ab1b6dfac178e570114cdf0ea3a1cc0e31486c3e41241bc6a76424e8c37ab26f096fc85ef9886c8cb634187f4fddff645fb099f1ff54c6b8c\", \"abcdefg\"},\n-\t{\"a3a8c81bc97c2560010d7389bc88aac974a104e0e2381220c6e084c4dccd1d2d17d4f86db31c2a851dc80e6681d74733c55dcd03dd96f6062cdda12a291ae6ce\", \"abcdefgh\"},\n-\t{\"f22d51d25292ca1d0f68f69aedc7897019308cc9db46efb75a03dd494fc7f126c010e8ade6a00a0c1a5f1b75d81e0ed5a93ce98dc9b833db7839247b1d9c24fe\", \"abcdefghi\"},\n-\t{\"ef6b97321f34b1fea2169a7db9e1960b471aa13302a988087357c520be957ca119c3ba68e6b4982c019ec89de3865ccf6a3cda1fe11e59f98d99f1502c8b9745\", \"abcdefghij\"},\n-\t{\"2210d99af9c8bdecda1b4beff822136753d8342505ddce37f1314e2cdbb488c6016bdaa9bd2ffa513dd5de2e4b50f031393d8ab61f773b0e0130d7381e0f8a1d\", \"Discard medicine more than two years old.\"},\n-\t{\"a687a8985b4d8d0a24f115fe272255c6afaf3909225838546159c1ed685c211a203796ae8ecc4c81a5b6315919b3a64f10713da07e341fcdbb08541bf03066ce\", \"He who has a shady past knows that nice guys finish last.\"},\n-\t{\"8ddb0392e818b7d585ab22769a50df660d9f6d559cca3afc5691b8ca91b8451374e42bcdabd64589ed7c91d85f626596228a5c8572677eb98bc6b624befb7af8\", \"I wouldn't marry him with a ten foot pole.\"},\n-\t{\"26ed8f6ca7f8d44b6a8a54ae39640fa8ad5c673f70ee9ce074ba4ef0d483eea00bab2f61d8695d6b34df9c6c48ae36246362200ed820448bdc03a720366a87c6\", \"Free! Free!/A trip/to Mars/for 900/empty jars/Burma Shave\"},\n-\t{\"e5a14bf044be69615aade89afcf1ab0389d5fc302a884d403579d1386a2400c089b0dbb387ed0f463f9ee342f8244d5a38cfbc0e819da9529fbff78368c9a982\", \"The days of the digital watch are numbered.  -Tom Stoppard\"},\n-\t{\"420a1faa48919e14651bed45725abe0f7a58e0f099424c4e5a49194946e38b46c1f8034b18ef169b2e31050d1648e0b982386595f7df47da4b6fd18e55333015\", \"Nepal premier won't resign.\"},\n-\t{\"d926a863beadb20134db07683535c72007b0e695045876254f341ddcccde132a908c5af57baa6a6a9c63e6649bba0c213dc05fadcf9abccea09f23dcfb637fbe\", \"For every action there is an equal and opposite government program.\"},\n-\t{\"9a98dd9bb67d0da7bf83da5313dff4fd60a4bac0094f1b05633690ffa7f6d61de9a1d4f8617937d560833a9aaa9ccafe3fd24db418d0e728833545cadd3ad92d\", \"His money is twice tainted: 'taint yours and 'taint mine.\"},\n-\t{\"d7fde2d2351efade52f4211d3746a0780a26eec3df9b2ed575368a8a1c09ec452402293a8ea4eceb5a4f60064ea29b13cdd86918cd7a4faf366160b009804107\", \"There is no reason for any individual to have a computer in their home. -Ken Olsen, 1977\"},\n-\t{\"b0f35ffa2697359c33a56f5c0cf715c7aeed96da9905ca2698acadb08fbc9e669bf566b6bd5d61a3e86dc22999bcc9f2224e33d1d4f32a228cf9d0349e2db518\", \"It's a tiny change to the code and not completely disgusting. - Bob Manchek\"},\n-\t{\"3d2e5f91778c9e66f7e061293aaa8a8fc742dd3b2e4f483772464b1144189b49273e610e5cccd7a81a19ca1fa70f16b10f1a100a4d8c1372336be8484c64b311\", \"size:  a.out:  bad magic\"},\n-\t{\"b2f68ff58ac015efb1c94c908b0d8c2bf06f491e4de8e6302c49016f7f8a33eac3e959856c7fddbc464de618701338a4b46f76dbfaf9a1e5262b5f40639771c7\", \"The major problem is with sendmail.  -Mark Horton\"},\n-\t{\"d8c92db5fdf52cf8215e4df3b4909d29203ff4d00e9ad0b64a6a4e04dec5e74f62e7c35c7fb881bd5de95442123df8f57a489b0ae616bd326f84d10021121c57\", \"Give me a rock, paper and scissors and I will move the world.  CCFestoon\"},\n-\t{\"19a9f8dc0a233e464e8566ad3ca9b91e459a7b8c4780985b015776e1bf239a19bc233d0556343e2b0a9bc220900b4ebf4f8bdf89ff8efeaf79602d6849e6f72e\", \"If the enemy is within range, then so are you.\"},\n-\t{\"00b4c41f307bde87301cdc5b5ab1ae9a592e8ecbb2021dd7bc4b34e2ace60741cc362560bec566ba35178595a91932b8d5357e2c9cec92d393b0fa7831852476\", \"It's well we cannot hear the screams/That we create in others' dreams.\"},\n-\t{\"91eccc3d5375fd026e4d6787874b1dce201cecd8a27dbded5065728cb2d09c58a3d467bb1faf353bf7ba567e005245d5321b55bc344f7c07b91cb6f26c959be7\", \"You remind me of a TV show, but that's all right: I watch it anyway.\"},\n-\t{\"fabbbe22180f1f137cfdc9556d2570e775d1ae02a597ded43a72a40f9b485d500043b7be128fb9fcd982b83159a0d99aa855a9e7cc4240c00dc01a9bdf8218d7\", \"C is as portable as Stonehedge!!\"},\n-\t{\"2ecdec235c1fa4fc2a154d8fba1dddb8a72a1ad73838b51d792331d143f8b96a9f6fcb0f34d7caa351fe6d88771c4f105040e0392f06e0621689d33b2f3ba92e\", \"Even if I could be Shakespeare, I think I should still choose to be Faraday. - A. Huxley\"},\n-\t{\"7ad681f6f96f82f7abfa7ecc0334e8fa16d3dc1cdc45b60b7af43fe4075d2357c0c1d60e98350f1afb1f2fe7a4d7cd2ad55b88e458e06b73c40b437331f5dab4\", \"The fugacity of a constituent in a mixture of gases at a given temperature is proportional to its mole fraction.  Lewis-Randall Rule\"},\n-\t{\"833f9248ab4a3b9e5131f745fda1ffd2dd435b30e965957e78291c7ab73605fd1912b0794e5c233ab0a12d205a39778d19b83515d6a47003f19cdee51d98c7e0\", \"How can you write a big system without C++?  -Paul Glick\"},\n+\t{\n+\t\t\"\",\n+\t\t\"6ed0dd02806fa89e25de060c19d3ac86cabb87d6a0ddd05c333b84f4\",\n+\t\t\"c672b8d1ef56ed28ab87c3622c5114069bdd3ad7b8f9737498d0c01ecef0967a\",\n+\t\t\"38b060a751ac96384cd9327eb1b1e36a21fdb71114be07434c0cc7bf63f6e1da274edebfe76f65fbd51ad2f14898b95b\",\n+\t\t\"cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e\",\n+\t},\n+\t{\n+\t\t\"a\",\n+\t\t\"d5cdb9ccc769a5121d4175f2bfdd13d6310e0d3d361ea75d82108327\",\n+\t\t\"455e518824bc0601f9fb858ff5c37d417d67c2f8e0df2babe4808858aea830f8\",\n+\t\t\"54a59b9f22b0b80880d8427e548b7c23abd873486e1f035dce9cd697e85175033caa88e6d57bc35efae0b5afd3145f31\",\n+\t\t\"1f40fc92da241694750979ee6cf582f2d5d7d28e18335de05abc54d0560e0f5302860c652bf08d560252aa5e74210546f369fbbbce8c12cfc7957b2652fe9a75\",\n+\t},\n+\t{\n+\t\t\"ab\",\n+\t\t\"b35878d07bfedf39fc638af08547eb5d1072d8546319f247b442fbf5\",\n+\t\t\"22d4d37ec6370571af7109fb12eae79673d5f7c83e6e677083faa3cfac3b2c14\",\n+\t\t\"c7be03ba5bcaa384727076db0018e99248e1a6e8bd1b9ef58a9ec9dd4eeebb3f48b836201221175befa74ddc3d35afdd\",\n+\t\t\"2d408a0717ec188158278a796c689044361dc6fdde28d6f04973b80896e1823975cdbf12eb63f9e0591328ee235d80e9b5bf1aa6a44f4617ff3caf6400eb172d\",\n+\t},\n+\t{\n+\t\t\"abc\",\n+\t\t\"4634270f707b6a54daae7530460842e20e37ed265ceee9a43e8924aa\",\n+\t\t\"53048e2681941ef99b2e29b76b4c7dabe4c2d0c634fc6d46e0e2f13107e7af23\",\n+\t\t\"cb00753f45a35e8bb5a03d699ac65007272c32ab0eded1631a8b605a43ff5bed8086072ba1e7cc2358baeca134c825a7\",\n+\t\t\"ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f\",\n+\t},\n+\t{\n+\t\t\"abcd\",\n+\t\t\"0c9f157ab030fb06e957c14e3938dc5908962e5dd7b66f04a36fc534\",\n+\t\t\"d2891c7978be0e24948f37caa415b87cb5cbe2b26b7bad9dc6391b8a6f6ddcc9\",\n+\t\t\"1165b3406ff0b52a3d24721f785462ca2276c9f454a116c2b2ba20171a7905ea5a026682eb659c4d5f115c363aa3c79b\",\n+\t\t\"d8022f2060ad6efd297ab73dcc5355c9b214054b0d1776a136a669d26a7d3b14f73aa0d0ebff19ee333368f0164b6419a96da49e3e481753e7e96b716bdccb6f\",\n+\t},\n+\t{\n+\t\t\"abcde\",\n+\t\t\"880e79bb0a1d2c9b7528d851edb6b8342c58c831de98123b432a4515\",\n+\t\t\"de8322b46e78b67d4431997070703e9764e03a1237b896fd8b379ed4576e8363\",\n+\t\t\"4c525cbeac729eaf4b4665815bc5db0c84fe6300068a727cf74e2813521565abc0ec57a37ee4d8be89d097c0d2ad52f0\",\n+\t\t\"878ae65a92e86cac011a570d4c30a7eaec442b85ce8eca0c2952b5e3cc0628c2e79d889ad4d5c7c626986d452dd86374b6ffaa7cd8b67665bef2289a5c70b0a1\",\n+\t},\n+\t{\n+\t\t\"abcdef\",\n+\t\t\"236c829cfea4fd6d4de61ad15fcf34dca62342adaf9f2001c16f29b8\",\n+\t\t\"e4fdcb11d1ac14e698743acd8805174cea5ddc0d312e3e47f6372032571bad84\",\n+\t\t\"c6a4c65b227e7387b9c3e839d44869c4cfca3ef583dea64117859b808c1e3d8ae689e1e314eeef52a6ffe22681aa11f5\",\n+\t\t\"e32ef19623e8ed9d267f657a81944b3d07adbb768518068e88435745564e8d4150a0a703be2a7d88b61e3d390c2bb97e2d4c311fdc69d6b1267f05f59aa920e7\",\n+\t},\n+\t{\n+\t\t\"abcdefg\",\n+\t\t\"4767af672b3ed107f25018dc22d6fa4b07d156e13b720971e2c4f6bf\",\n+\t\t\"a8117f680bdceb5d1443617cbdae9255f6900075422326a972fdd2f65ba9bee3\",\n+\t\t\"9f11fc131123f844c1226f429b6a0a6af0525d9f40f056c7fc16cdf1b06bda08e302554417a59fa7dcf6247421959d22\",\n+\t\t\"d716a4188569b68ab1b6dfac178e570114cdf0ea3a1cc0e31486c3e41241bc6a76424e8c37ab26f096fc85ef9886c8cb634187f4fddff645fb099f1ff54c6b8c\",\n+\t},\n+\t{\n+\t\t\"abcdefgh\",\n+\t\t\"792e25e0ae286d123a38950007e037d3122e76c4ee201668c385edab\",\n+\t\t\"a29b9645d2a02a8b582888d044199787220e316bf2e89d1422d3df26bf545bbe\",\n+\t\t\"9000cd7cada59d1d2eb82912f7f24e5e69cc5517f68283b005fa27c285b61e05edf1ad1a8a9bded6fd29eb87d75ad806\",\n+\t\t\"a3a8c81bc97c2560010d7389bc88aac974a104e0e2381220c6e084c4dccd1d2d17d4f86db31c2a851dc80e6681d74733c55dcd03dd96f6062cdda12a291ae6ce\",\n+\t},\n+\t{\n+\t\t\"abcdefghi\",\n+\t\t\"56b275d36127dc070cda4019baf2ce2579a25d8c67fa2bc9be61b539\",\n+\t\t\"b955095330f9c8188d11884ec1679dc44c9c5b25ff9bda700416df9cdd39188f\",\n+\t\t\"ef54915b60cf062b8dd0c29ae3cad69abe6310de63ac081f46ef019c5c90897caefd79b796cfa81139788a260ded52df\",\n+\t\t\"f22d51d25292ca1d0f68f69aedc7897019308cc9db46efb75a03dd494fc7f126c010e8ade6a00a0c1a5f1b75d81e0ed5a93ce98dc9b833db7839247b1d9c24fe\",\n+\t},\n+\t{\n+\t\t\"abcdefghij\",\n+\t\t\"f809423cbb25e81a2a64aecee2cd5fdc7d91d5db583901fbf1db3116\",\n+\t\t\"550762913d51eefbcd1a55068fcfc9b154fd11c1078b996df0d926ea59d2a68d\",\n+\t\t\"a12070030a02d86b0ddacd0d3a5b598344513d0a051e7355053e556a0055489c1555399b03342845c4adde2dc44ff66c\",\n+\t\t\"ef6b97321f34b1fea2169a7db9e1960b471aa13302a988087357c520be957ca119c3ba68e6b4982c019ec89de3865ccf6a3cda1fe11e59f98d99f1502c8b9745\",\n+\t},\n+\t{\n+\t\t\"Discard medicine more than two years old.\",\n+\t\t\"4c46e10b5b72204e509c3c06072cea970bc020cd45a61a0acdfa97ac\",\n+\t\t\"690c8ad3916cefd3ad29226d9875965e3ee9ec0d4482eacc248f2ff4aa0d8e5b\",\n+\t\t\"86f58ec2d74d1b7f8eb0c2ff0967316699639e8d4eb129de54bdf34c96cdbabe200d052149f2dd787f43571ba74670d4\",\n+\t\t\"2210d99af9c8bdecda1b4beff822136753d8342505ddce37f1314e2cdbb488c6016bdaa9bd2ffa513dd5de2e4b50f031393d8ab61f773b0e0130d7381e0f8a1d\",\n+\t},\n+\t{\n+\t\t\"He who has a shady past knows that nice guys finish last.\",\n+\t\t\"cb0cef13c1848d91a6d02637c7c520de1914ad4a7aea824671cc328e\",\n+\t\t\"25938ca49f7ef1178ce81620842b65e576245fcaed86026a36b516b80bb86b3b\",\n+\t\t\"ae4a2b639ca9bfa04b1855d5a05fe7f230994f790891c6979103e2605f660c4c1262a48142dcbeb57a1914ba5f7c3fa7\",\n+\t\t\"a687a8985b4d8d0a24f115fe272255c6afaf3909225838546159c1ed685c211a203796ae8ecc4c81a5b6315919b3a64f10713da07e341fcdbb08541bf03066ce\",\n+\t},\n+\t{\n+\t\t\"I wouldn't marry him with a ten foot pole.\",\n+\t\t\"6c7bd0f3a6544ea698006c2ea583a85f80ea2913590a186db8bb2f1b\",\n+\t\t\"698e420c3a7038e53d8e73f4be2b02e03b93464ac1a61ebe69f557079921ef65\",\n+\t\t\"40ae213df6436eca952aa6841886fcdb82908ef1576a99c8f49bb9dd5023169f7c53035abdda0b54c302f4974e2105e7\",\n+\t\t\"8ddb0392e818b7d585ab22769a50df660d9f6d559cca3afc5691b8ca91b8451374e42bcdabd64589ed7c91d85f626596228a5c8572677eb98bc6b624befb7af8\",\n+\t},\n+\t{\n+\t\t\"Free! Free!/A trip/to Mars/for 900/empty jars/Burma Shave\",\n+\t\t\"981323be3eca6ccfa598e58dd74ed8cb05d5f7f6653b7604b684f904\",\n+\t\t\"839b414d7e3900ee243aa3d1f9b6955720e64041f5ab9bedd3eb0a08da5a2ca8\",\n+\t\t\"e7cf8b873c9bc950f06259aa54309f349cefa72c00d597aebf903e6519a50011dfe355afff064a10701c705693848df9\",\n+\t\t\"26ed8f6ca7f8d44b6a8a54ae39640fa8ad5c673f70ee9ce074ba4ef0d483eea00bab2f61d8695d6b34df9c6c48ae36246362200ed820448bdc03a720366a87c6\",\n+\t},\n+\t{\n+\t\t\"The days of the digital watch are numbered.  -Tom Stoppard\",\n+\t\t\"e6fbf82df5138bf361e826903cadf0612cb2986649ba47a57e1bca99\",\n+\t\t\"5625ecb9d284e54c00b257b67a8cacb25a78db2845c60ef2d29e43c84f236e8e\",\n+\t\t\"c3d4f0f4047181c7d39d34703365f7bf70207183caf2c2f6145f04da895ef69124d9cdeb635da636c3a474e61024e29b\",\n+\t\t\"e5a14bf044be69615aade89afcf1ab0389d5fc302a884d403579d1386a2400c089b0dbb387ed0f463f9ee342f8244d5a38cfbc0e819da9529fbff78368c9a982\",\n+\t},\n+\t{\n+\t\t\"Nepal premier won't resign.\",\n+\t\t\"6ec2cb2ecafc1a9bddaf4caf57344d853e6ded398927d5694fd7714f\",\n+\t\t\"9b81d06bca2f985e6ad3249096ff3c0f2a9ec5bb16ef530d738d19d81e7806f2\",\n+\t\t\"a097aab567e167d5cf93676ed73252a69f9687cb3179bb2d27c9878119e94bf7b7c4b58dc90582edfaf66e11388ed714\",\n+\t\t\"420a1faa48919e14651bed45725abe0f7a58e0f099424c4e5a49194946e38b46c1f8034b18ef169b2e31050d1648e0b982386595f7df47da4b6fd18e55333015\",\n+\t},\n+\t{\n+\t\t\"For every action there is an equal and opposite government program.\",\n+\t\t\"7f62f36e716e0badaf4a4658da9d09bea26357a1bc6aeb8cf7c3ae35\",\n+\t\t\"08241df8d91edfcd68bb1a1dada6e0ae1475a5c6e7b8f12d8e24ca43a38240a9\",\n+\t\t\"5026ca45c41fc64712eb65065da92f6467541c78f8966d3fe2c8e3fb769a3ec14215f819654b47bd64f7f0eac17184f3\",\n+\t\t\"d926a863beadb20134db07683535c72007b0e695045876254f341ddcccde132a908c5af57baa6a6a9c63e6649bba0c213dc05fadcf9abccea09f23dcfb637fbe\",\n+\t},\n+\t{\n+\t\t\"His money is twice tainted: 'taint yours and 'taint mine.\",\n+\t\t\"45adffcb86a05ee4d91263a6115dda011b805d442c60836963cb8378\",\n+\t\t\"4ff74d9213a8117745f5d37b5353a774ec81c5dfe65c4c8986a56fc01f2c551e\",\n+\t\t\"ac1cc0f5ac8d5f5514a7b738ac322b7fb52a161b449c3672e9b6a6ad1a5e4b26b001cf3bad24c56598676ca17d4b445a\",\n+\t\t\"9a98dd9bb67d0da7bf83da5313dff4fd60a4bac0094f1b05633690ffa7f6d61de9a1d4f8617937d560833a9aaa9ccafe3fd24db418d0e728833545cadd3ad92d\",\n+\t},\n+\t{\n+\t\t\"There is no reason for any individual to have a computer in their home. -Ken Olsen, 1977\",\n+\t\t\"51cb518f1f68daa901a3075a0a5e1acc755b4e5c82cb47687537f880\",\n+\t\t\"b5baf747c307f98849ec881cf0d48605ae4edd386372aea9b26e71db517e650b\",\n+\t\t\"722d10c5de371ec0c8c4b5247ac8a5f1d240d68c73f8da13d8b25f0166d6f309bf9561979a111a0049405771d201941a\",\n+\t\t\"d7fde2d2351efade52f4211d3746a0780a26eec3df9b2ed575368a8a1c09ec452402293a8ea4eceb5a4f60064ea29b13cdd86918cd7a4faf366160b009804107\",\n+\t},\n+\t{\n+\t\t\"It's a tiny change to the code and not completely disgusting. - Bob Manchek\",\n+\t\t\"3b59c5e64b0da7bfc18d7017bf458d90f2c83601ff1afc6263ac0993\",\n+\t\t\"7eef0538ebd7ecf18611d23b0e1cd26a74d65b929a2e374197dc66e755ca4944\",\n+\t\t\"dc2d3ea18bfa10549c63bf2b75b39b5167a80c12aff0e05443168ea87ff149fb0eda5e0bd234eb5d48c7d02ffc5807f1\",\n+\t\t\"b0f35ffa2697359c33a56f5c0cf715c7aeed96da9905ca2698acadb08fbc9e669bf566b6bd5d61a3e86dc22999bcc9f2224e33d1d4f32a228cf9d0349e2db518\",\n+\t},\n+\t{\n+\t\t\"size:  a.out:  bad magic\",\n+\t\t\"6a9525c0fac0f91b489bc4f0f539b9ec4a156a4e98bc15b655c2c881\",\n+\t\t\"d05600964f83f55323104aadab434f32391c029718a7690d08ddb2d7e8708443\",\n+\t\t\"1d67c969e2a945ae5346d2139760261504d4ba164c522443afe19ef3e29b152a4c52445489cfc9d7215e5a450e8e1e4e\",\n+\t\t\"3d2e5f91778c9e66f7e061293aaa8a8fc742dd3b2e4f483772464b1144189b49273e610e5cccd7a81a19ca1fa70f16b10f1a100a4d8c1372336be8484c64b311\",\n+\t},\n+\t{\n+\t\t\"The major problem is with sendmail.  -Mark Horton\",\n+\t\t\"a1b2b2905b1527d682049c6a76e35c7d8c72551abfe7833ac1be595f\",\n+\t\t\"53ed5f9b5c0b674ac0f3425d9f9a5d462655b07cc90f5d0f692eec093884a607\",\n+\t\t\"5ff8e075e465646e7b73ef36d812c6e9f7d60fa6ea0e533e5569b4f73cde53cdd2cc787f33540af57cca3fe467d32fe0\",\n+\t\t\"b2f68ff58ac015efb1c94c908b0d8c2bf06f491e4de8e6302c49016f7f8a33eac3e959856c7fddbc464de618701338a4b46f76dbfaf9a1e5262b5f40639771c7\",\n+\t},\n+\t{\n+\t\t\"Give me a rock, paper and scissors and I will move the world.  CCFestoon\",\n+\t\t\"76cf045c76a5f2e3d64d56c3cdba6a25479334611bc375460526f8c1\",\n+\t\t\"5a0147685a44eea2435dbd582724efca7637acd9c428e5e1a05115bc3bc2a0e0\",\n+\t\t\"5bd0a997a67c9ae1979a894eb0cde403dde003c9b6f2c03cf21925c42ff4e1176e6df1ca005381612ef18457b9b7ec3b\",\n+\t\t\"d8c92db5fdf52cf8215e4df3b4909d29203ff4d00e9ad0b64a6a4e04dec5e74f62e7c35c7fb881bd5de95442123df8f57a489b0ae616bd326f84d10021121c57\",\n+\t},\n+\t{\n+\t\t\"If the enemy is within range, then so are you.\",\n+\t\t\"4473671daeecfdb6f6c5bc06b26374aa5e497cc37119fe14144c430c\",\n+\t\t\"1152c9b27a99dbf4057d21438f4e63dd0cd0977d5ff12317c64d3b97fcac875a\",\n+\t\t\"1eee6da33e7e54fc5be52ae23b94b16ba4d2a947ae4505c6a3edfc7401151ea5205ac01b669b56f27d8ef7f175ed7762\",\n+\t\t\"19a9f8dc0a233e464e8566ad3ca9b91e459a7b8c4780985b015776e1bf239a19bc233d0556343e2b0a9bc220900b4ebf4f8bdf89ff8efeaf79602d6849e6f72e\",\n+\t},\n+\t{\n+\t\t\"It's well we cannot hear the screams/That we create in others' dreams.\",\n+\t\t\"6accb6394758523fcd453d47d37ebd10868957a0a9e81c796736abf8\",\n+\t\t\"105e890f5d5cf1748d9a7b4cdaf58b69855779deebc2097747c2210a17b2cb51\",\n+\t\t\"76b06e9dea66bfbb1a96029426dc0dfd7830bd297eb447ff5358d94a87cd00c88b59df2493fef56ecbb5231073892ea9\",\n+\t\t\"00b4c41f307bde87301cdc5b5ab1ae9a592e8ecbb2021dd7bc4b34e2ace60741cc362560bec566ba35178595a91932b8d5357e2c9cec92d393b0fa7831852476\",\n+\t},\n+\t{\n+\t\t\"You remind me of a TV show, but that's all right: I watch it anyway.\",\n+\t\t\"6f173f4b6eac7f2a73eaa0833c4563752df2c869dc00b7d30219e12e\",\n+\t\t\"74644ead770da1434365cd912656fe1aca2056d3039d39f10eb1151bddb32cf3\",\n+\t\t\"12acaf21452cff586143e3f5db0bfdf7802c057e1adf2a619031c4e1b0ccc4208cf6cef8fe722bbaa2fb46a30d9135d8\",\n+\t\t\"91eccc3d5375fd026e4d6787874b1dce201cecd8a27dbded5065728cb2d09c58a3d467bb1faf353bf7ba567e005245d5321b55bc344f7c07b91cb6f26c959be7\",\n+\t},\n+\t{\n+\t\t\"C is as portable as Stonehedge!!\",\n+\t\t\"db05bf4d0f73325208755f4af96cfac6cb3db5dbfc323d675d68f938\",\n+\t\t\"50a234625de5587581883dad9ef399460928032a5ea6bd005d7dc7b68d8cc3d6\",\n+\t\t\"0fc23d7f4183efd186f0bc4fc5db867e026e2146b06cb3d52f4bdbd57d1740122caa853b41868b197b2ac759db39df88\",\n+\t\t\"fabbbe22180f1f137cfdc9556d2570e775d1ae02a597ded43a72a40f9b485d500043b7be128fb9fcd982b83159a0d99aa855a9e7cc4240c00dc01a9bdf8218d7\",\n+\t},\n+\t{\n+\t\t\"Even if I could be Shakespeare, I think I should still choose to be Faraday. - A. Huxley\",\n+\t\t\"05ffa71bb02e855de1aaee1777b3bdbaf7507646f19c4c6aa29933d0\",\n+\t\t\"a7a3846005f8a9935a0a2d43e7fd56d95132a9a3609bf3296ef80b8218acffa0\",\n+\t\t\"bc805578a7f85d34a86a32976e1c34fe65cf815186fbef76f46ef99cda10723f971f3f1464d488243f5e29db7488598d\",\n+\t\t\"2ecdec235c1fa4fc2a154d8fba1dddb8a72a1ad73838b51d792331d143f8b96a9f6fcb0f34d7caa351fe6d88771c4f105040e0392f06e0621689d33b2f3ba92e\",\n+\t},\n+\t{\n+\t\t\"The fugacity of a constituent in a mixture of gases at a given temperature is proportional to its mole fraction.  Lewis-Randall Rule\",\n+\t\t\"3ad3c89e15b91e6273534c5d18adadbb528e7b840b288f64e81b8c6d\",\n+\t\t\"688ff03e367680757aa9906cb1e2ad218c51f4526dc0426ea229a5ba9d002c69\",\n+\t\t\"b23918399a12ebf4431559eec3813eaf7412e875fd7464f16d581e473330842d2e96c6be49a7ce3f9bb0b8bc0fcbe0fe\",\n+\t\t\"7ad681f6f96f82f7abfa7ecc0334e8fa16d3dc1cdc45b60b7af43fe4075d2357c0c1d60e98350f1afb1f2fe7a4d7cd2ad55b88e458e06b73c40b437331f5dab4\",\n+\t},\n+\t{\n+\t\t\"How can you write a big system without C++?  -Paul Glick\",\n+\t\t\"e3763669d1b760c1be7bfcb6625f92300a8430419d1dbad57ec9f53c\",\n+\t\t\"3fa46d52094b01021cff5af9a438982b887a5793f624c0a6644149b6b7c3f485\",\n+\t\t\"1764b700eb1ead52a2fc33cc28975c2180f1b8faa5038d94cffa8d78154aab16e91dd787e7b0303948ebed62561542c8\",\n+\t\t\"833f9248ab4a3b9e5131f745fda1ffd2dd435b30e965957e78291c7ab73605fd1912b0794e5c233ab0a12d205a39778d19b83515d6a47003f19cdee51d98c7e0\",\n+\t},\n }\n \n-var golden384 = []sha512Test{\n-\t{\"38b060a751ac96384cd9327eb1b1e36a21fdb71114be07434c0cc7bf63f6e1da274edebfe76f65fbd51ad2f14898b95b\", \"\"},\n-\t{\"54a59b9f22b0b80880d8427e548b7c23abd873486e1f035dce9cd697e85175033caa88e6d57bc35efae0b5afd3145f31\", \"a\"},\n-\t{\"c7be03ba5bcaa384727076db0018e99248e1a6e8bd1b9ef58a9ec9dd4eeebb3f48b836201221175befa74ddc3d35afdd\", \"ab\"},\n-\t{\"cb00753f45a35e8bb5a03d699ac65007272c32ab0eded1631a8b605a43ff5bed8086072ba1e7cc2358baeca134c825a7\", \"abc\"},\n-\t{\"1165b3406ff0b52a3d24721f785462ca2276c9f454a116c2b2ba20171a7905ea5a026682eb659c4d5f115c363aa3c79b\", \"abcd\"},\n-\t{\"4c525cbeac729eaf4b4665815bc5db0c84fe6300068a727cf74e2813521565abc0ec57a37ee4d8be89d097c0d2ad52f0\", \"abcde\"},\n-\t{\"c6a4c65b227e7387b9c3e839d44869c4cfca3ef583dea64117859b808c1e3d8ae689e1e314eeef52a6ffe22681aa11f5\", \"abcdef\"},\n-\t{\"9f11fc131123f844c1226f429b6a0a6af0525d9f40f056c7fc16cdf1b06bda08e302554417a59fa7dcf6247421959d22\", \"abcdefg\"},\n-\t{\"9000cd7cada59d1d2eb82912f7f24e5e69cc5517f68283b005fa27c285b61e05edf1ad1a8a9bded6fd29eb87d75ad806\", \"abcdefgh\"},\n-\t{\"ef54915b60cf062b8dd0c29ae3cad69abe6310de63ac081f46ef019c5c90897caefd79b796cfa81139788a260ded52df\", \"abcdefghi\"},\n-\t{\"a12070030a02d86b0ddacd0d3a5b598344513d0a051e7355053e556a0055489c1555399b03342845c4adde2dc44ff66c\", \"abcdefghij\"},\n-\t{\"86f58ec2d74d1b7f8eb0c2ff0967316699639e8d4eb129de54bdf34c96cdbabe200d052149f2dd787f43571ba74670d4\", \"Discard medicine more than two years old.\"},\n-\t{\"ae4a2b639ca9bfa04b1855d5a05fe7f230994f790891c6979103e2605f660c4c1262a48142dcbeb57a1914ba5f7c3fa7\", \"He who has a shady past knows that nice guys finish last.\"},\n-\t{\"40ae213df6436eca952aa6841886fcdb82908ef1576a99c8f49bb9dd5023169f7c53035abdda0b54c302f4974e2105e7\", \"I wouldn't marry him with a ten foot pole.\"},\n-\t{\"e7cf8b873c9bc950f06259aa54309f349cefa72c00d597aebf903e6519a50011dfe355afff064a10701c705693848df9\", \"Free! Free!/A trip/to Mars/for 900/empty jars/Burma Shave\"},\n-\t{\"c3d4f0f4047181c7d39d34703365f7bf70207183caf2c2f6145f04da895ef69124d9cdeb635da636c3a474e61024e29b\", \"The days of the digital watch are numbered.  -Tom Stoppard\"},\n-\t{\"a097aab567e167d5cf93676ed73252a69f9687cb3179bb2d27c9878119e94bf7b7c4b58dc90582edfaf66e11388ed714\", \"Nepal premier won't resign.\"},\n-\t{\"5026ca45c41fc64712eb65065da92f6467541c78f8966d3fe2c8e3fb769a3ec14215f819654b47bd64f7f0eac17184f3\", \"For every action there is an equal and opposite government program.\"},\n-\t{\"ac1cc0f5ac8d5f5514a7b738ac322b7fb52a161b449c3672e9b6a6ad1a5e4b26b001cf3bad24c56598676ca17d4b445a\", \"His money is twice tainted: 'taint yours and 'taint mine.\"},\n-\t{\"722d10c5de371ec0c8c4b5247ac8a5f1d240d68c73f8da13d8b25f0166d6f309bf9561979a111a0049405771d201941a\", \"There is no reason for any individual to have a computer in their home. -Ken Olsen, 1977\"},\n-\t{\"dc2d3ea18bfa10549c63bf2b75b39b5167a80c12aff0e05443168ea87ff149fb0eda5e0bd234eb5d48c7d02ffc5807f1\", \"It's a tiny change to the code and not completely disgusting. - Bob Manchek\"},\n-\t{\"1d67c969e2a945ae5346d2139760261504d4ba164c522443afe19ef3e29b152a4c52445489cfc9d7215e5a450e8e1e4e\", \"size:  a.out:  bad magic\"},\n-\t{\"5ff8e075e465646e7b73ef36d812c6e9f7d60fa6ea0e533e5569b4f73cde53cdd2cc787f33540af57cca3fe467d32fe0\", \"The major problem is with sendmail.  -Mark Horton\"},\n-\t{\"5bd0a997a67c9ae1979a894eb0cde403dde003c9b6f2c03cf21925c42ff4e1176e6df1ca005381612ef18457b9b7ec3b\", \"Give me a rock, paper and scissors and I will move the world.  CCFestoon\"},\n-\t{\"1eee6da33e7e54fc5be52ae23b94b16ba4d2a947ae4505c6a3edfc7401151ea5205ac01b669b56f27d8ef7f175ed7762\", \"If the enemy is within range, then so are you.\"},\n-\t{\"76b06e9dea66bfbb1a96029426dc0dfd7830bd297eb447ff5358d94a87cd00c88b59df2493fef56ecbb5231073892ea9\", \"It's well we cannot hear the screams/That we create in others' dreams.\"},\n-\t{\"12acaf21452cff586143e3f5db0bfdf7802c057e1adf2a619031c4e1b0ccc4208cf6cef8fe722bbaa2fb46a30d9135d8\", \"You remind me of a TV show, but that's all right: I watch it anyway.\"},\n-\t{\"0fc23d7f4183efd186f0bc4fc5db867e026e2146b06cb3d52f4bdbd57d1740122caa853b41868b197b2ac759db39df88\", \"C is as portable as Stonehedge!!\"},\n-\t{\"bc805578a7f85d34a86a32976e1c34fe65cf815186fbef76f46ef99cda10723f971f3f1464d488243f5e29db7488598d\", \"Even if I could be Shakespeare, I think I should still choose to be Faraday. - A. Huxley\"},\n-\t{\"b23918399a12ebf4431559eec3813eaf7412e875fd7464f16d581e473330842d2e96c6be49a7ce3f9bb0b8bc0fcbe0fe\", \"The fugacity of a constituent in a mixture of gases at a given temperature is proportional to its mole fraction.  Lewis-Randall Rule\"},\n-\t{\"1764b700eb1ead52a2fc33cc28975c2180f1b8faa5038d94cffa8d78154aab16e91dd787e7b0303948ebed62561542c8\", \"How can you write a big system without C++?  -Paul Glick\"},\n-}\n+func testHash(t *testing.T, name, in, outHex string, oneShotResult []byte, digestFunc hash.Hash) {\n+\tif calculated := hex.EncodeToString(oneShotResult); calculated != outHex {\n+\t\tt.Errorf(\"one-shot result for %s(%q) = %q, but expected %q\", name, in, calculated, outHex)\n+\t\treturn\n+\t}\n \n-func TestGolden(t *testing.T) {\n-\tfor i := 0; i < len(golden); i++ {\n-\t\tg := golden[i]\n-\t\ts := fmt.Sprintf(\"%x\", Sum512([]byte(g.in)))\n-\t\tif s != g.out {\n-\t\t\tt.Fatalf(\"Sum512 function: sha512(%s) = %s want %s\", g.in, s, g.out)\n+\tfor pass := 0; pass < 3; pass++ {\n+\t\tif pass < 2 {\n+\t\t\tio.WriteString(digestFunc, in)\n+\t\t} else {\n+\t\t\tio.WriteString(digestFunc, in[:len(in)/2])\n+\t\t\tdigestFunc.Sum(nil)\n+\t\t\tio.WriteString(digestFunc, in[len(in)/2:])\n \t\t}\n-\t\tc := New()\n-\t\tfor j := 0; j < 3; j++ {\n-\t\t\tif j < 2 {\n-\t\t\t\tio.WriteString(c, g.in)\n-\t\t\t} else {\n-\t\t\t\tio.WriteString(c, g.in[0:len(g.in)/2])\n-\t\t\t\tc.Sum(nil)\n-\t\t\t\tio.WriteString(c, g.in[len(g.in)/2:])\n-\t\t\t}\n-\t\t\ts := fmt.Sprintf(\"%x\", c.Sum(nil))\n-\t\t\tif s != g.out {\n-\t\t\t\tt.Fatalf(\"sha512[%d](%s) = %s want %s\", j, g.in, s, g.out)\n-\t\t\t}\n-\t\t\tc.Reset()\n+\n+\t\tif calculated := hex.EncodeToString(digestFunc.Sum(nil)); calculated != outHex {\n+\t\t\tt.Errorf(\"%s(%q) = %q (in pass #%d), but expected %q\", name, in, calculated, pass, outHex)\n \t\t}\n+\t\tdigestFunc.Reset()\n \t}\n-\tfor i := 0; i < len(golden384); i++ {\n-\t\tg := golden384[i]\n-\t\ts := fmt.Sprintf(\"%x\", Sum384([]byte(g.in)))\n-\t\tif s != g.out {\n-\t\t\tt.Fatalf(\"Sum384 function: sha384(%s) = %s want %s\", g.in, s, g.out)\n-\t\t}\n-\t\tc := New384()\n-\t\tfor j := 0; j < 3; j++ {\n-\t\t\tif j < 2 {\n-\t\t\t\tio.WriteString(c, g.in)\n-\t\t\t} else {\n-\t\t\t\tio.WriteString(c, g.in[0:len(g.in)/2])\n-\t\t\t\tc.Sum(nil)\n-\t\t\t\tio.WriteString(c, g.in[len(g.in)/2:])\n-\t\t\t}\n-\t\t\ts := fmt.Sprintf(\"%x\", c.Sum(nil))\n-\t\t\tif s != g.out {\n-\t\t\t\tt.Fatalf(\"sha384[%d](%s) = %s want %s\", j, g.in, s, g.out)\n-\t\t\t}\n-\t\t\tc.Reset()\n-\t\t}\n+}\n+\n+func TestGolden(t *testing.T) {\n+\tfor _, test := range golden {\n+\t\tin := []byte(test.in)\n+\n+\t\tsum224 := Sum512_224(in)\n+\t\tsum256 := Sum512_256(in)\n+\t\tsum384 := Sum384(in)\n+\t\tsum512 := Sum512(in)\n+\t\ttestHash(t, \"SHA512/224\", test.in, test.out224, sum224[:], New512_224())\n+\t\ttestHash(t, \"SHA512/256\", test.in, test.out256, sum256[:], New512_256())\n+\t\ttestHash(t, \"SHA384\", test.in, test.out384, sum384[:], New384())\n+\t\ttestHash(t, \"SHA512\", test.in, test.out512, sum512[:], New())\n \t}\n }\n \n@@ -141,6 +287,14 @@ func TestSize(t *testing.T) {\n \tif got := c.Size(); got != Size384 {\n \t\tt.Errorf(\"New384.Size = %d; want %d\", got, Size384)\n \t}\n+\tc = New512_224()\n+\tif got := c.Size(); got != Size224 {\n+\t\tt.Errorf(\"New512224.Size = %d; want %d\", got, Size224)\n+\t}\n+\tc = New512_256()\n+\tif got := c.Size(); got != Size256 {\n+\t\tt.Errorf(\"New512256.Size = %d; want %d\", got, Size256)\n+\t}\n }\n \n func TestBlockSize(t *testing.T) {"}, {"sha": "a5fed29375243eda07383e11dbb503328faf0bc5", "filename": "libgo/go/crypto/tls/cipher_suites.go", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Fcipher_suites.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Fcipher_suites.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fcipher_suites.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -48,6 +48,12 @@ const (\n \t// suiteTLS12 indicates that the cipher suite should only be advertised\n \t// and accepted when using TLS 1.2.\n \tsuiteTLS12\n+\t// suiteSHA384 indicates that the cipher suite uses SHA384 as the\n+\t// handshake hash.\n+\tsuiteSHA384\n+\t// suiteDefaultOff indicates that this cipher suite is not included by\n+\t// default.\n+\tsuiteDefaultOff\n )\n \n // A cipherSuite is a specific combination of key agreement, cipher and MAC\n@@ -71,13 +77,15 @@ var cipherSuites = []*cipherSuite{\n \t// and RC4 comes before AES (because of the Lucky13 attack).\n \t{TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, 16, 0, 4, ecdheRSAKA, suiteECDHE | suiteTLS12, nil, nil, aeadAESGCM},\n \t{TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, 16, 0, 4, ecdheECDSAKA, suiteECDHE | suiteECDSA | suiteTLS12, nil, nil, aeadAESGCM},\n-\t{TLS_ECDHE_RSA_WITH_RC4_128_SHA, 16, 20, 0, ecdheRSAKA, suiteECDHE, cipherRC4, macSHA1, nil},\n-\t{TLS_ECDHE_ECDSA_WITH_RC4_128_SHA, 16, 20, 0, ecdheECDSAKA, suiteECDHE | suiteECDSA, cipherRC4, macSHA1, nil},\n+\t{TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384, 32, 0, 4, ecdheRSAKA, suiteECDHE | suiteTLS12 | suiteSHA384, nil, nil, aeadAESGCM},\n+\t{TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384, 32, 0, 4, ecdheECDSAKA, suiteECDHE | suiteECDSA | suiteTLS12 | suiteSHA384, nil, nil, aeadAESGCM},\n+\t{TLS_ECDHE_RSA_WITH_RC4_128_SHA, 16, 20, 0, ecdheRSAKA, suiteECDHE | suiteDefaultOff, cipherRC4, macSHA1, nil},\n+\t{TLS_ECDHE_ECDSA_WITH_RC4_128_SHA, 16, 20, 0, ecdheECDSAKA, suiteECDHE | suiteECDSA | suiteDefaultOff, cipherRC4, macSHA1, nil},\n \t{TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA, 16, 20, 16, ecdheRSAKA, suiteECDHE, cipherAES, macSHA1, nil},\n \t{TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA, 16, 20, 16, ecdheECDSAKA, suiteECDHE | suiteECDSA, cipherAES, macSHA1, nil},\n \t{TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA, 32, 20, 16, ecdheRSAKA, suiteECDHE, cipherAES, macSHA1, nil},\n \t{TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA, 32, 20, 16, ecdheECDSAKA, suiteECDHE | suiteECDSA, cipherAES, macSHA1, nil},\n-\t{TLS_RSA_WITH_RC4_128_SHA, 16, 20, 0, rsaKA, 0, cipherRC4, macSHA1, nil},\n+\t{TLS_RSA_WITH_RC4_128_SHA, 16, 20, 0, rsaKA, suiteDefaultOff, cipherRC4, macSHA1, nil},\n \t{TLS_RSA_WITH_AES_128_CBC_SHA, 16, 20, 16, rsaKA, 0, cipherAES, macSHA1, nil},\n \t{TLS_RSA_WITH_AES_256_CBC_SHA, 32, 20, 16, rsaKA, 0, cipherAES, macSHA1, nil},\n \t{TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA, 24, 20, 8, ecdheRSAKA, suiteECDHE, cipher3DES, macSHA1, nil},\n@@ -267,6 +275,8 @@ const (\n \tTLS_ECDHE_RSA_WITH_AES_256_CBC_SHA      uint16 = 0xc014\n \tTLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256   uint16 = 0xc02f\n \tTLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 uint16 = 0xc02b\n+\tTLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384   uint16 = 0xc030\n+\tTLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 uint16 = 0xc02c\n \n \t// TLS_FALLBACK_SCSV isn't a standard cipher suite but an indicator\n \t// that the client is doing version fallback. See"}, {"sha": "a3d75d69cbfadf33acc4a6726cd0f340c799f32f", "filename": "libgo/go/crypto/tls/common.go", "status": "modified", "additions": 133, "deletions": 42, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -8,7 +8,9 @@ import (\n \t\"container/list\"\n \t\"crypto\"\n \t\"crypto/rand\"\n+\t\"crypto/sha512\"\n \t\"crypto/x509\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"io\"\n \t\"math/big\"\n@@ -30,7 +32,7 @@ const (\n \trecordHeaderLen = 5            // record header length\n \tmaxHandshake    = 65536        // maximum handshake we support (protocol max is 16 MB)\n \n-\tminVersion = VersionSSL30\n+\tminVersion = VersionTLS10\n \tmaxVersion = VersionTLS12\n )\n \n@@ -73,6 +75,7 @@ const (\n \textensionSupportedPoints     uint16 = 11\n \textensionSignatureAlgorithms uint16 = 13\n \textensionALPN                uint16 = 16\n+\textensionSCT                 uint16 = 18 // https://tools.ietf.org/html/rfc6962#section-6\n \textensionSessionTicket       uint16 = 35\n \textensionNextProtoNeg        uint16 = 13172 // not IANA assigned\n \textensionRenegotiationInfo   uint16 = 0xff01\n@@ -123,6 +126,7 @@ const (\n const (\n \thashSHA1   uint8 = 2\n \thashSHA256 uint8 = 4\n+\thashSHA384 uint8 = 5\n )\n \n // Signature algorithms for TLS 1.2 (See RFC 5246, section A.4.1)\n@@ -137,34 +141,31 @@ type signatureAndHash struct {\n \thash, signature uint8\n }\n \n-// supportedSKXSignatureAlgorithms contains the signature and hash algorithms\n-// that the code advertises as supported in a TLS 1.2 ClientHello.\n-var supportedSKXSignatureAlgorithms = []signatureAndHash{\n+// supportedSignatureAlgorithms contains the signature and hash algorithms that\n+// the code advertises as supported in a TLS 1.2 ClientHello and in a TLS 1.2\n+// CertificateRequest.\n+var supportedSignatureAlgorithms = []signatureAndHash{\n \t{hashSHA256, signatureRSA},\n \t{hashSHA256, signatureECDSA},\n+\t{hashSHA384, signatureRSA},\n+\t{hashSHA384, signatureECDSA},\n \t{hashSHA1, signatureRSA},\n \t{hashSHA1, signatureECDSA},\n }\n \n-// supportedClientCertSignatureAlgorithms contains the signature and hash\n-// algorithms that the code advertises as supported in a TLS 1.2\n-// CertificateRequest.\n-var supportedClientCertSignatureAlgorithms = []signatureAndHash{\n-\t{hashSHA256, signatureRSA},\n-\t{hashSHA256, signatureECDSA},\n-}\n-\n // ConnectionState records basic TLS details about the connection.\n type ConnectionState struct {\n-\tVersion                    uint16                // TLS version used by the connection (e.g. VersionTLS12)\n-\tHandshakeComplete          bool                  // TLS handshake is complete\n-\tDidResume                  bool                  // connection resumes a previous TLS connection\n-\tCipherSuite                uint16                // cipher suite in use (TLS_RSA_WITH_RC4_128_SHA, ...)\n-\tNegotiatedProtocol         string                // negotiated next protocol (from Config.NextProtos)\n-\tNegotiatedProtocolIsMutual bool                  // negotiated protocol was advertised by server\n-\tServerName                 string                // server name requested by client, if any (server side only)\n-\tPeerCertificates           []*x509.Certificate   // certificate chain presented by remote peer\n-\tVerifiedChains             [][]*x509.Certificate // verified chains built from PeerCertificates\n+\tVersion                     uint16                // TLS version used by the connection (e.g. VersionTLS12)\n+\tHandshakeComplete           bool                  // TLS handshake is complete\n+\tDidResume                   bool                  // connection resumes a previous TLS connection\n+\tCipherSuite                 uint16                // cipher suite in use (TLS_RSA_WITH_RC4_128_SHA, ...)\n+\tNegotiatedProtocol          string                // negotiated next protocol (from Config.NextProtos)\n+\tNegotiatedProtocolIsMutual  bool                  // negotiated protocol was advertised by server\n+\tServerName                  string                // server name requested by client, if any (server side only)\n+\tPeerCertificates            []*x509.Certificate   // certificate chain presented by remote peer\n+\tVerifiedChains              [][]*x509.Certificate // verified chains built from PeerCertificates\n+\tSignedCertificateTimestamps [][]byte              // SCTs from the server, if any\n+\tOCSPResponse                []byte                // stapled OCSP response from server, if any\n \n \t// TLSUnique contains the \"tls-unique\" channel binding value (see RFC\n \t// 5929, section 3). For resumed sessions this value will be nil\n@@ -190,11 +191,12 @@ const (\n // ClientSessionState contains the state needed by clients to resume TLS\n // sessions.\n type ClientSessionState struct {\n-\tsessionTicket      []uint8             // Encrypted ticket used for session resumption with server\n-\tvers               uint16              // SSL/TLS version negotiated for the session\n-\tcipherSuite        uint16              // Ciphersuite negotiated for the session\n-\tmasterSecret       []byte              // MasterSecret generated by client on a full handshake\n-\tserverCertificates []*x509.Certificate // Certificate chain presented by the server\n+\tsessionTicket      []uint8               // Encrypted ticket used for session resumption with server\n+\tvers               uint16                // SSL/TLS version negotiated for the session\n+\tcipherSuite        uint16                // Ciphersuite negotiated for the session\n+\tmasterSecret       []byte                // MasterSecret generated by client on a full handshake\n+\tserverCertificates []*x509.Certificate   // Certificate chain presented by the server\n+\tverifiedChains     [][]*x509.Certificate // Certificate chains we built for verification\n }\n \n // ClientSessionCache is a cache of ClientSessionState objects that can be used\n@@ -265,10 +267,12 @@ type Config struct {\n \tNameToCertificate map[string]*Certificate\n \n \t// GetCertificate returns a Certificate based on the given\n-\t// ClientHelloInfo. If GetCertificate is nil or returns nil, then the\n-\t// certificate is retrieved from NameToCertificate. If\n-\t// NameToCertificate is nil, the first element of Certificates will be\n-\t// used.\n+\t// ClientHelloInfo. It will only be called if the client supplies SNI\n+\t// information or if Certificates is empty.\n+\t//\n+\t// If GetCertificate is nil or returns nil, then the certificate is\n+\t// retrieved from NameToCertificate. If NameToCertificate is nil, the\n+\t// first element of Certificates will be used.\n \tGetCertificate func(clientHello *ClientHelloInfo) (*Certificate, error)\n \n \t// RootCAs defines the set of root certificate authorities\n@@ -330,7 +334,7 @@ type Config struct {\n \tClientSessionCache ClientSessionCache\n \n \t// MinVersion contains the minimum SSL/TLS version that is acceptable.\n-\t// If zero, then SSLv3 is taken as the minimum.\n+\t// If zero, then TLS 1.0 is taken as the minimum.\n \tMinVersion uint16\n \n \t// MaxVersion contains the maximum SSL/TLS version that is acceptable.\n@@ -344,23 +348,90 @@ type Config struct {\n \tCurvePreferences []CurveID\n \n \tserverInitOnce sync.Once // guards calling (*Config).serverInit\n+\n+\t// mutex protects sessionTicketKeys\n+\tmutex sync.RWMutex\n+\t// sessionTicketKeys contains zero or more ticket keys. If the length\n+\t// is zero, SessionTicketsDisabled must be true. The first key is used\n+\t// for new tickets and any subsequent keys can be used to decrypt old\n+\t// tickets.\n+\tsessionTicketKeys []ticketKey\n+}\n+\n+// ticketKeyNameLen is the number of bytes of identifier that is prepended to\n+// an encrypted session ticket in order to identify the key used to encrypt it.\n+const ticketKeyNameLen = 16\n+\n+// ticketKey is the internal representation of a session ticket key.\n+type ticketKey struct {\n+\t// keyName is an opaque byte string that serves to identify the session\n+\t// ticket key. It's exposed as plaintext in every session ticket.\n+\tkeyName [ticketKeyNameLen]byte\n+\taesKey  [16]byte\n+\thmacKey [16]byte\n+}\n+\n+// ticketKeyFromBytes converts from the external representation of a session\n+// ticket key to a ticketKey. Externally, session ticket keys are 32 random\n+// bytes and this function expands that into sufficient name and key material.\n+func ticketKeyFromBytes(b [32]byte) (key ticketKey) {\n+\thashed := sha512.Sum512(b[:])\n+\tcopy(key.keyName[:], hashed[:ticketKeyNameLen])\n+\tcopy(key.aesKey[:], hashed[ticketKeyNameLen:ticketKeyNameLen+16])\n+\tcopy(key.hmacKey[:], hashed[ticketKeyNameLen+16:ticketKeyNameLen+32])\n+\treturn key\n }\n \n func (c *Config) serverInit() {\n \tif c.SessionTicketsDisabled {\n \t\treturn\n \t}\n \n-\t// If the key has already been set then we have nothing to do.\n+\talreadySet := false\n \tfor _, b := range c.SessionTicketKey {\n \t\tif b != 0 {\n+\t\t\talreadySet = true\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\tif !alreadySet {\n+\t\tif _, err := io.ReadFull(c.rand(), c.SessionTicketKey[:]); err != nil {\n+\t\t\tc.SessionTicketsDisabled = true\n \t\t\treturn\n \t\t}\n \t}\n \n-\tif _, err := io.ReadFull(c.rand(), c.SessionTicketKey[:]); err != nil {\n-\t\tc.SessionTicketsDisabled = true\n+\tc.sessionTicketKeys = []ticketKey{ticketKeyFromBytes(c.SessionTicketKey)}\n+}\n+\n+func (c *Config) ticketKeys() []ticketKey {\n+\tc.mutex.RLock()\n+\t// c.sessionTicketKeys is constant once created. SetSessionTicketKeys\n+\t// will only update it by replacing it with a new value.\n+\tret := c.sessionTicketKeys\n+\tc.mutex.RUnlock()\n+\treturn ret\n+}\n+\n+// SetSessionTicketKeys updates the session ticket keys for a server. The first\n+// key will be used when creating new tickets, while all keys can be used for\n+// decrypting tickets. It is safe to call this function while the server is\n+// running in order to rotate the session ticket keys. The function will panic\n+// if keys is empty.\n+func (c *Config) SetSessionTicketKeys(keys [][32]byte) {\n+\tif len(keys) == 0 {\n+\t\tpanic(\"tls: keys must have at least one key\")\n \t}\n+\n+\tnewKeys := make([]ticketKey, len(keys))\n+\tfor i, bytes := range keys {\n+\t\tnewKeys[i] = ticketKeyFromBytes(bytes)\n+\t}\n+\n+\tc.mutex.Lock()\n+\tc.sessionTicketKeys = newKeys\n+\tc.mutex.Unlock()\n }\n \n func (c *Config) rand() io.Reader {\n@@ -428,13 +499,18 @@ func (c *Config) mutualVersion(vers uint16) (uint16, bool) {\n // getCertificate returns the best certificate for the given ClientHelloInfo,\n // defaulting to the first element of c.Certificates.\n func (c *Config) getCertificate(clientHello *ClientHelloInfo) (*Certificate, error) {\n-\tif c.GetCertificate != nil {\n+\tif c.GetCertificate != nil &&\n+\t\t(len(c.Certificates) == 0 || len(clientHello.ServerName) > 0) {\n \t\tcert, err := c.GetCertificate(clientHello)\n \t\tif cert != nil || err != nil {\n \t\t\treturn cert, err\n \t\t}\n \t}\n \n+\tif len(c.Certificates) == 0 {\n+\t\treturn nil, errors.New(\"crypto/tls: no certificates configured\")\n+\t}\n+\n \tif len(c.Certificates) == 1 || c.NameToCertificate == nil {\n \t\t// There's only one choice, so no point doing any work.\n \t\treturn &c.Certificates[0], nil\n@@ -488,14 +564,17 @@ func (c *Config) BuildNameToCertificate() {\n type Certificate struct {\n \tCertificate [][]byte\n \t// PrivateKey contains the private key corresponding to the public key\n-\t// in Leaf. For a server, this must be a *rsa.PrivateKey or\n-\t// *ecdsa.PrivateKey. For a client doing client authentication, this\n-\t// can be any type that implements crypto.Signer (which includes RSA\n-\t// and ECDSA private keys).\n+\t// in Leaf. For a server, this must implement crypto.Signer and/or\n+\t// crypto.Decrypter, with an RSA or ECDSA PublicKey. For a client\n+\t// (performing client authentication), this must be a crypto.Signer\n+\t// with an RSA or ECDSA PublicKey.\n \tPrivateKey crypto.PrivateKey\n \t// OCSPStaple contains an optional OCSP response which will be served\n \t// to clients that request it.\n \tOCSPStaple []byte\n+\t// SignedCertificateTimestamps contains an optional list of Signed\n+\t// Certificate Timestamps which will be served to clients that request it.\n+\tSignedCertificateTimestamps [][]byte\n \t// Leaf is the parsed form of the leaf certificate, which may be\n \t// initialized using x509.ParseCertificate to reduce per-handshake\n \t// processing for TLS clients doing client authentication. If nil, the\n@@ -610,12 +689,24 @@ func defaultCipherSuites() []uint16 {\n }\n \n func initDefaultCipherSuites() {\n-\tvarDefaultCipherSuites = make([]uint16, len(cipherSuites))\n-\tfor i, suite := range cipherSuites {\n-\t\tvarDefaultCipherSuites[i] = suite.id\n+\tvarDefaultCipherSuites = make([]uint16, 0, len(cipherSuites))\n+\tfor _, suite := range cipherSuites {\n+\t\tif suite.flags&suiteDefaultOff != 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tvarDefaultCipherSuites = append(varDefaultCipherSuites, suite.id)\n \t}\n }\n \n func unexpectedMessageError(wanted, got interface{}) error {\n \treturn fmt.Errorf(\"tls: received unexpected handshake message of type %T when waiting for %T\", got, wanted)\n }\n+\n+func isSupportedSignatureAndHash(sigHash signatureAndHash, sigHashes []signatureAndHash) bool {\n+\tfor _, s := range sigHashes {\n+\t\tif s == sigHash {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}"}, {"sha": "e3dcf15400ce18a6c3985ba02239fb013910e78e", "filename": "libgo/go/crypto/tls/conn.go", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -35,7 +35,8 @@ type Conn struct {\n \thandshakeComplete bool\n \tdidResume         bool // whether this connection was a session resumption\n \tcipherSuite       uint16\n-\tocspResponse      []byte // stapled OCSP response\n+\tocspResponse      []byte   // stapled OCSP response\n+\tscts              [][]byte // signed certificate timestamps from server\n \tpeerCertificates  []*x509.Certificate\n \t// verifiedChains contains the certificate chains that we built, as\n \t// opposed to the ones presented by the server.\n@@ -570,15 +571,11 @@ Again:\n \t\treturn c.in.setErrorLocked(fmt.Errorf(\"tls: oversized record received with length %d\", n))\n \t}\n \tif !c.haveVers {\n-\t\t// First message, be extra suspicious:\n-\t\t// this might not be a TLS client.\n-\t\t// Bail out before reading a full 'body', if possible.\n-\t\t// The current max version is 3.1.\n-\t\t// If the version is >= 16.0, it's probably not real.\n-\t\t// Similarly, a clientHello message encodes in\n-\t\t// well under a kilobyte.  If the length is >= 12 kB,\n+\t\t// First message, be extra suspicious: this might not be a TLS\n+\t\t// client. Bail out before reading a full 'body', if possible.\n+\t\t// The current max version is 3.3 so if the version is >= 16.0,\n \t\t// it's probably not real.\n-\t\tif (typ != recordTypeAlert && typ != want) || vers >= 0x1000 || n >= 0x3000 {\n+\t\tif (typ != recordTypeAlert && typ != want) || vers >= 0x1000 {\n \t\t\tc.sendAlert(alertUnexpectedMessage)\n \t\t\treturn c.in.setErrorLocked(fmt.Errorf(\"tls: first record does not look like a TLS handshake\"))\n \t\t}\n@@ -926,7 +923,7 @@ func (c *Conn) Read(b []byte) (n int, err error) {\n \t\t// tried to reuse the HTTP connection for a new\n \t\t// request.\n \t\t// See https://codereview.appspot.com/76400046\n-\t\t// and http://golang.org/issue/3514\n+\t\t// and https://golang.org/issue/3514\n \t\tif ri := c.rawInput; ri != nil &&\n \t\t\tn != 0 && err == nil &&\n \t\t\tc.input == nil && len(ri.data) > 0 && recordType(ri.data[0]) == recordTypeAlert {\n@@ -997,6 +994,8 @@ func (c *Conn) ConnectionState() ConnectionState {\n \t\tstate.PeerCertificates = c.peerCertificates\n \t\tstate.VerifiedChains = c.verifiedChains\n \t\tstate.ServerName = c.serverName\n+\t\tstate.SignedCertificateTimestamps = c.scts\n+\t\tstate.OCSPResponse = c.ocspResponse\n \t\tif !c.didResume {\n \t\t\tstate.TLSUnique = c.firstFinished[:]\n \t\t}\n@@ -1026,5 +1025,8 @@ func (c *Conn) VerifyHostname(host string) error {\n \tif !c.handshakeComplete {\n \t\treturn errors.New(\"tls: handshake has not yet been performed\")\n \t}\n+\tif len(c.verifiedChains) == 0 {\n+\t\treturn errors.New(\"tls: handshake did not verify certificate chain\")\n+\t}\n \treturn c.peerCertificates[0].VerifyHostname(host)\n }"}, {"sha": "0b591d7309c2592b9067b8ba796519806260e1fd", "filename": "libgo/go/crypto/tls/handshake_client.go", "status": "modified", "additions": 41, "deletions": 19, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -54,6 +54,7 @@ func (c *Conn) clientHandshake() error {\n \t\tcompressionMethods:  []uint8{compressionNone},\n \t\trandom:              make([]byte, 32),\n \t\tocspStapling:        true,\n+\t\tscts:                true,\n \t\tserverName:          c.config.ServerName,\n \t\tsupportedCurves:     c.config.curvePreferences(),\n \t\tsupportedPoints:     []uint8{pointFormatUncompressed},\n@@ -88,7 +89,7 @@ NextCipherSuite:\n \t}\n \n \tif hello.vers >= VersionTLS12 {\n-\t\thello.signatureAndHashes = supportedSKXSignatureAlgorithms\n+\t\thello.signatureAndHashes = supportedSignatureAlgorithms\n \t}\n \n \tvar session *ClientSessionState\n@@ -168,18 +169,26 @@ NextCipherSuite:\n \t\tserverHello:  serverHello,\n \t\thello:        hello,\n \t\tsuite:        suite,\n-\t\tfinishedHash: newFinishedHash(c.vers),\n+\t\tfinishedHash: newFinishedHash(c.vers, suite),\n \t\tsession:      session,\n \t}\n \n-\ths.finishedHash.Write(hs.hello.marshal())\n-\ths.finishedHash.Write(hs.serverHello.marshal())\n-\n \tisResume, err := hs.processServerHello()\n \tif err != nil {\n \t\treturn err\n \t}\n \n+\t// No signatures of the handshake are needed in a resumption.\n+\t// Otherwise, in a full handshake, if we don't have any certificates\n+\t// configured then we will never send a CertificateVerify message and\n+\t// thus no signatures are needed in that case either.\n+\tif isResume || len(c.config.Certificates) == 0 {\n+\t\ths.finishedHash.discardHandshakeBuffer()\n+\t}\n+\n+\ths.finishedHash.Write(hs.hello.marshal())\n+\ths.finishedHash.Write(hs.serverHello.marshal())\n+\n \tif isResume {\n \t\tif err := hs.establishKeys(); err != nil {\n \t\t\treturn err\n@@ -423,7 +432,6 @@ func (hs *clientHandshakeState) doFullHandshake() error {\n \t}\n \n \tif chainToSend != nil {\n-\t\tvar signed []byte\n \t\tcertVerify := &certificateVerifyMsg{\n \t\t\thasSignatureAndHash: c.vers >= VersionTLS12,\n \t\t}\n@@ -433,39 +441,50 @@ func (hs *clientHandshakeState) doFullHandshake() error {\n \t\t\tc.sendAlert(alertInternalError)\n \t\t\treturn fmt.Errorf(\"tls: client certificate private key of type %T does not implement crypto.Signer\", chainToSend.PrivateKey)\n \t\t}\n+\n+\t\tvar signatureType uint8\n \t\tswitch key.Public().(type) {\n \t\tcase *ecdsa.PublicKey:\n-\t\t\tdigest, hashFunc, hashId := hs.finishedHash.hashForClientCertificate(signatureECDSA)\n-\t\t\tsigned, err = key.Sign(c.config.rand(), digest, hashFunc)\n-\t\t\tcertVerify.signatureAndHash.signature = signatureECDSA\n-\t\t\tcertVerify.signatureAndHash.hash = hashId\n+\t\t\tsignatureType = signatureECDSA\n \t\tcase *rsa.PublicKey:\n-\t\t\tdigest, hashFunc, hashId := hs.finishedHash.hashForClientCertificate(signatureRSA)\n-\t\t\tsigned, err = key.Sign(c.config.rand(), digest, hashFunc)\n-\t\t\tcertVerify.signatureAndHash.signature = signatureRSA\n-\t\t\tcertVerify.signatureAndHash.hash = hashId\n+\t\t\tsignatureType = signatureRSA\n \t\tdefault:\n-\t\t\terr = fmt.Errorf(\"tls: unknown client certificate key type: %T\", key)\n+\t\t\tc.sendAlert(alertInternalError)\n+\t\t\treturn fmt.Errorf(\"tls: failed to sign handshake with client certificate: unknown client certificate key type: %T\", key)\n+\t\t}\n+\n+\t\tcertVerify.signatureAndHash, err = hs.finishedHash.selectClientCertSignatureAlgorithm(certReq.signatureAndHashes, signatureType)\n+\t\tif err != nil {\n+\t\t\tc.sendAlert(alertInternalError)\n+\t\t\treturn err\n \t\t}\n+\t\tdigest, hashFunc, err := hs.finishedHash.hashForClientCertificate(certVerify.signatureAndHash, hs.masterSecret)\n \t\tif err != nil {\n \t\t\tc.sendAlert(alertInternalError)\n-\t\t\treturn errors.New(\"tls: failed to sign handshake with client certificate: \" + err.Error())\n+\t\t\treturn err\n+\t\t}\n+\t\tcertVerify.signature, err = key.Sign(c.config.rand(), digest, hashFunc)\n+\t\tif err != nil {\n+\t\t\tc.sendAlert(alertInternalError)\n+\t\t\treturn err\n \t\t}\n-\t\tcertVerify.signature = signed\n \n \t\ths.finishedHash.Write(certVerify.marshal())\n \t\tc.writeRecord(recordTypeHandshake, certVerify.marshal())\n \t}\n \n-\ths.masterSecret = masterFromPreMasterSecret(c.vers, preMasterSecret, hs.hello.random, hs.serverHello.random)\n+\ths.masterSecret = masterFromPreMasterSecret(c.vers, hs.suite, preMasterSecret, hs.hello.random, hs.serverHello.random)\n+\n+\ths.finishedHash.discardHandshakeBuffer()\n+\n \treturn nil\n }\n \n func (hs *clientHandshakeState) establishKeys() error {\n \tc := hs.c\n \n \tclientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV :=\n-\t\tkeysFromMasterSecret(c.vers, hs.masterSecret, hs.hello.random, hs.serverHello.random, hs.suite.macLen, hs.suite.keyLen, hs.suite.ivLen)\n+\t\tkeysFromMasterSecret(c.vers, hs.suite, hs.masterSecret, hs.hello.random, hs.serverHello.random, hs.suite.macLen, hs.suite.keyLen, hs.suite.ivLen)\n \tvar clientCipher, serverCipher interface{}\n \tvar clientHash, serverHash macFunction\n \tif hs.suite.cipher != nil {\n@@ -522,11 +541,13 @@ func (hs *clientHandshakeState) processServerHello() (bool, error) {\n \t\tc.clientProtocol = hs.serverHello.alpnProtocol\n \t\tc.clientProtocolFallback = false\n \t}\n+\tc.scts = hs.serverHello.scts\n \n \tif hs.serverResumedSession() {\n \t\t// Restore masterSecret and peerCerts from previous state\n \t\ths.masterSecret = hs.session.masterSecret\n \t\tc.peerCertificates = hs.session.serverCertificates\n+\t\tc.verifiedChains = hs.session.verifiedChains\n \t\treturn true, nil\n \t}\n \treturn false, nil\n@@ -584,6 +605,7 @@ func (hs *clientHandshakeState) readSessionTicket() error {\n \t\tcipherSuite:        hs.suite.id,\n \t\tmasterSecret:       hs.masterSecret,\n \t\tserverCertificates: c.peerCertificates,\n+\t\tverifiedChains:     c.verifiedChains,\n \t}\n \n \treturn nil"}, {"sha": "664fe8de6a0c73b0439cffcc5621955f49c955fd", "filename": "libgo/go/crypto/tls/handshake_client_test.go", "status": "modified", "additions": 121, "deletions": 9, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc", "patch": "@@ -9,6 +9,8 @@ import (\n \t\"crypto/ecdsa\"\n \t\"crypto/rsa\"\n \t\"crypto/x509\"\n+\t\"encoding/base64\"\n+\t\"encoding/binary\"\n \t\"encoding/pem\"\n \t\"fmt\"\n \t\"io\"\n@@ -49,6 +51,10 @@ type clientTest struct {\n \t// key, if not nil, contains either a *rsa.PrivateKey or\n \t// *ecdsa.PrivateKey which is the private key for the reference server.\n \tkey interface{}\n+\t// extensions, if not nil, contains a list of extension data to be returned\n+\t// from the ServerHello. The data should be in standard TLS format with\n+\t// a 2-byte uint16 type, 2-byte data length, followed by the extension data.\n+\textensions [][]byte\n \t// validate, if not nil, is a function that will be called with the\n \t// ConnectionState of the resulting connection. It returns a non-nil\n \t// error if the ConnectionState is unacceptable.\n@@ -111,6 +117,19 @@ func (test *clientTest) connFromCommand() (conn *recordingConn, child *exec.Cmd,\n \tconst serverPort = 24323\n \tcommand = append(command, \"-accept\", strconv.Itoa(serverPort))\n \n+\tif len(test.extensions) > 0 {\n+\t\tvar serverInfo bytes.Buffer\n+\t\tfor _, ext := range test.extensions {\n+\t\t\tpem.Encode(&serverInfo, &pem.Block{\n+\t\t\t\tType:  fmt.Sprintf(\"SERVERINFO FOR EXTENSION %d\", binary.BigEndian.Uint16(ext)),\n+\t\t\t\tBytes: ext,\n+\t\t\t})\n+\t\t}\n+\t\tserverInfoPath := tempFile(serverInfo.String())\n+\t\tdefer os.Remove(serverInfoPath)\n+\t\tcommand = append(command, \"-serverinfo\", serverInfoPath)\n+\t}\n+\n \tcmd := exec.Command(command[0], command[1:]...)\n \tstdin = blockingSource(make(chan bool))\n \tcmd.Stdin = stdin\n@@ -127,7 +146,6 @@ func (test *clientTest) connFromCommand() (conn *recordingConn, child *exec.Cmd,\n \t// connection.\n \tvar tcpConn net.Conn\n \tfor i := uint(0); i < 5; i++ {\n-\t\tvar err error\n \t\ttcpConn, err = net.DialTCP(\"tcp\", nil, &net.TCPAddr{\n \t\t\tIP:   net.IPv4(127, 0, 0, 1),\n \t\t\tPort: serverPort,\n@@ -137,7 +155,7 @@ func (test *clientTest) connFromCommand() (conn *recordingConn, child *exec.Cmd,\n \t\t}\n \t\ttime.Sleep((1 << i) * 5 * time.Millisecond)\n \t}\n-\tif tcpConn == nil {\n+\tif err != nil {\n \t\tclose(stdin)\n \t\tout.WriteTo(os.Stdout)\n \t\tcmd.Process.Kill()\n@@ -190,11 +208,11 @@ func (test *clientTest) run(t *testing.T, write bool) {\n \tdoneChan := make(chan bool)\n \tgo func() {\n \t\tif _, err := client.Write([]byte(\"hello\\n\")); err != nil {\n-\t\t\tt.Logf(\"Client.Write failed: %s\", err)\n+\t\t\tt.Errorf(\"Client.Write failed: %s\", err)\n \t\t}\n \t\tif test.validate != nil {\n \t\t\tif err := test.validate(client.ConnectionState()); err != nil {\n-\t\t\t\tt.Logf(\"validate callback returned error: %s\", err)\n+\t\t\t\tt.Errorf(\"validate callback returned error: %s\", err)\n \t\t\t}\n \t\t}\n \t\tclient.Close()\n@@ -311,6 +329,16 @@ func TestHandshakeClientECDHEECDSAAESGCM(t *testing.T) {\n \trunClientTestTLS12(t, test)\n }\n \n+func TestHandshakeClientAES256GCMSHA384(t *testing.T) {\n+\ttest := &clientTest{\n+\t\tname:    \"ECDHE-ECDSA-AES256-GCM-SHA384\",\n+\t\tcommand: []string{\"openssl\", \"s_server\", \"-cipher\", \"ECDHE-ECDSA-AES256-GCM-SHA384\"},\n+\t\tcert:    testECDSACertificate,\n+\t\tkey:     testECDSAPrivateKey,\n+\t}\n+\trunClientTestTLS12(t, test)\n+}\n+\n func TestHandshakeClientCertRSA(t *testing.T) {\n \tconfig := *testConfig\n \tcert, _ := X509KeyPair([]byte(clientCertificatePEM), []byte(clientKeyPEM))\n@@ -335,6 +363,16 @@ func TestHandshakeClientCertRSA(t *testing.T) {\n \n \trunClientTestTLS10(t, test)\n \trunClientTestTLS12(t, test)\n+\n+\ttest = &clientTest{\n+\t\tname:    \"ClientCert-RSA-AES256-GCM-SHA384\",\n+\t\tcommand: []string{\"openssl\", \"s_server\", \"-cipher\", \"ECDHE-RSA-AES256-GCM-SHA384\", \"-verify\", \"1\"},\n+\t\tconfig:  &config,\n+\t\tcert:    testRSACertificate,\n+\t\tkey:     testRSAPrivateKey,\n+\t}\n+\n+\trunClientTestTLS12(t, test)\n }\n \n func TestHandshakeClientCertECDSA(t *testing.T) {\n@@ -368,31 +406,67 @@ func TestClientResumption(t *testing.T) {\n \t\tCipherSuites: []uint16{TLS_RSA_WITH_RC4_128_SHA, TLS_ECDHE_RSA_WITH_RC4_128_SHA},\n \t\tCertificates: testConfig.Certificates,\n \t}\n+\n+\tissuer, err := x509.ParseCertificate(testRSACertificateIssuer)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\n+\trootCAs := x509.NewCertPool()\n+\trootCAs.AddCert(issuer)\n+\n \tclientConfig := &Config{\n \t\tCipherSuites:       []uint16{TLS_RSA_WITH_RC4_128_SHA},\n-\t\tInsecureSkipVerify: true,\n \t\tClientSessionCache: NewLRUClientSessionCache(32),\n+\t\tRootCAs:            rootCAs,\n+\t\tServerName:         \"example.golang\",\n \t}\n \n \ttestResumeState := func(test string, didResume bool) {\n-\t\ths, err := testHandshake(clientConfig, serverConfig)\n+\t\t_, hs, err := testHandshake(clientConfig, serverConfig)\n \t\tif err != nil {\n \t\t\tt.Fatalf(\"%s: handshake failed: %s\", test, err)\n \t\t}\n \t\tif hs.DidResume != didResume {\n \t\t\tt.Fatalf(\"%s resumed: %v, expected: %v\", test, hs.DidResume, didResume)\n \t\t}\n+\t\tif didResume && (hs.PeerCertificates == nil || hs.VerifiedChains == nil) {\n+\t\t\tt.Fatalf(\"expected non-nil certificates after resumption. Got peerCertificates: %#v, verifedCertificates: %#v\", hs.PeerCertificates, hs.VerifiedChains)\n+\t\t}\n+\t}\n+\n+\tgetTicket := func() []byte {\n+\t\treturn clientConfig.ClientSessionCache.(*lruSessionCache).q.Front().Value.(*lruSessionCacheEntry).state.sessionTicket\n+\t}\n+\trandomKey := func() [32]byte {\n+\t\tvar k [32]byte\n+\t\tif _, err := io.ReadFull(serverConfig.rand(), k[:]); err != nil {\n+\t\t\tt.Fatalf(\"Failed to read new SessionTicketKey: %s\", err)\n+\t\t}\n+\t\treturn k\n \t}\n \n \ttestResumeState(\"Handshake\", false)\n+\tticket := getTicket()\n \ttestResumeState(\"Resume\", true)\n-\n-\tif _, err := io.ReadFull(serverConfig.rand(), serverConfig.SessionTicketKey[:]); err != nil {\n-\t\tt.Fatalf(\"Failed to invalidate SessionTicketKey\")\n+\tif !bytes.Equal(ticket, getTicket()) {\n+\t\tt.Fatal(\"first ticket doesn't match ticket after resumption\")\n \t}\n+\n+\tkey2 := randomKey()\n+\tserverConfig.SetSessionTicketKeys([][32]byte{key2})\n+\n \ttestResumeState(\"InvalidSessionTicketKey\", false)\n \ttestResumeState(\"ResumeAfterInvalidSessionTicketKey\", true)\n \n+\tserverConfig.SetSessionTicketKeys([][32]byte{randomKey(), key2})\n+\tticket = getTicket()\n+\ttestResumeState(\"KeyChange\", true)\n+\tif bytes.Equal(ticket, getTicket()) {\n+\t\tt.Fatal(\"new ticket wasn't included while resuming\")\n+\t}\n+\ttestResumeState(\"KeyChangeFinish\", true)\n+\n \tclientConfig.CipherSuites = []uint16{TLS_ECDHE_RSA_WITH_RC4_128_SHA}\n \ttestResumeState(\"DifferentCipherSuite\", false)\n \ttestResumeState(\"DifferentCipherSuiteRecovers\", true)\n@@ -488,3 +562,41 @@ func TestHandshakeClientALPNNoMatch(t *testing.T) {\n \t}\n \trunClientTestTLS12(t, test)\n }\n+\n+// sctsBase64 contains data from `openssl s_client -serverinfo 18 -connect ritter.vg:443`\n+const sctsBase64 = \"ABIBaQFnAHUApLkJkLQYWBSHuxOizGdwCjw1mAT5G9+443fNDsgN3BAAAAFHl5nuFgAABAMARjBEAiAcS4JdlW5nW9sElUv2zvQyPoZ6ejKrGGB03gjaBZFMLwIgc1Qbbn+hsH0RvObzhS+XZhr3iuQQJY8S9G85D9KeGPAAdgBo9pj4H2SCvjqM7rkoHUz8cVFdZ5PURNEKZ6y7T0/7xAAAAUeX4bVwAAAEAwBHMEUCIDIhFDgG2HIuADBkGuLobU5a4dlCHoJLliWJ1SYT05z6AiEAjxIoZFFPRNWMGGIjskOTMwXzQ1Wh2e7NxXE1kd1J0QsAdgDuS723dc5guuFCaR+r4Z5mow9+X7By2IMAxHuJeqj9ywAAAUhcZIqHAAAEAwBHMEUCICmJ1rBT09LpkbzxtUC+Hi7nXLR0J+2PmwLp+sJMuqK+AiEAr0NkUnEVKVhAkccIFpYDqHOlZaBsuEhWWrYpg2RtKp0=\"\n+\n+func TestHandshakClientSCTs(t *testing.T) {\n+\tconfig := *testConfig\n+\n+\tscts, err := base64.StdEncoding.DecodeString(sctsBase64)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\ttest := &clientTest{\n+\t\tname: \"SCT\",\n+\t\t// Note that this needs OpenSSL 1.0.2 because that is the first\n+\t\t// version that supports the -serverinfo flag.\n+\t\tcommand:    []string{\"openssl\", \"s_server\"},\n+\t\tconfig:     &config,\n+\t\textensions: [][]byte{scts},\n+\t\tvalidate: func(state ConnectionState) error {\n+\t\t\texpectedSCTs := [][]byte{\n+\t\t\t\tscts[8:125],\n+\t\t\t\tscts[127:245],\n+\t\t\t\tscts[247:],\n+\t\t\t}\n+\t\t\tif n := len(state.SignedCertificateTimestamps); n != len(expectedSCTs) {\n+\t\t\t\treturn fmt.Errorf(\"Got %d scts, wanted %d\", n, len(expectedSCTs))\n+\t\t\t}\n+\t\t\tfor i, expected := range expectedSCTs {\n+\t\t\t\tif sct := state.SignedCertificateTimestamps[i]; !bytes.Equal(sct, expected) {\n+\t\t\t\t\treturn fmt.Errorf(\"SCT #%d contained %x, expected %x\", i, sct, expected)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn nil\n+\t\t},\n+\t}\n+\trunClientTestTLS12(t, test)\n+}"}, {"sha": "799a776799aa1c158562f7e68a5712d0d68a6641", "filename": "libgo/go/crypto/tls/handshake_messages.go", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "95d825bd17522a427ca8c1e16933828d8ca45526", "filename": "libgo/go/crypto/tls/handshake_messages_test.go", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "e16cddcbd81db53051c63f155e0a2a3efef7d8af", "filename": "libgo/go/crypto/tls/handshake_server.go", "status": "modified", "additions": 123, "deletions": 58, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "20c2bd6d4d4fbbc9ae1f6bb27b28299805072821", "filename": "libgo/go/crypto/tls/handshake_server_test.go", "status": "modified", "additions": 238, "deletions": 47, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "0e6a7c2262404ae6bf499a914855b48bda897535", "filename": "libgo/go/crypto/tls/key_agreement.go", "status": "modified", "additions": 50, "deletions": 58, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "6127c1ccfe79facc2484f70977d926377bff993c", "filename": "libgo/go/crypto/tls/prf.go", "status": "modified", "additions": 127, "deletions": 51, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "0a1b1bcbd1b90c77bc2979dd371a187f2b950087", "filename": "libgo/go/crypto/tls/prf_test.go", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "4bad7865df3f7bc411a17a54c9c02452e814c9ef", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv10-ClientCert-ECDSA-ECDSA", "status": "modified", "additions": 53, "deletions": 52, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-ClientCert-ECDSA-ECDSA", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-ClientCert-ECDSA-ECDSA", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-ClientCert-ECDSA-ECDSA?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "0e420a64804d14bf9c24683919ae981eeb4b1eb2", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv10-ClientCert-ECDSA-RSA", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-ClientCert-ECDSA-RSA", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-ClientCert-ECDSA-RSA", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-ClientCert-ECDSA-RSA?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "7e33edc18975e95cc699dc6d98156181d6c255a4", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv10-ClientCert-RSA-ECDSA", "status": "modified", "additions": 52, "deletions": 51, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-ClientCert-RSA-ECDSA", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-ClientCert-RSA-ECDSA", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-ClientCert-RSA-ECDSA?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "9b1a5533acf093c6147fb7ff08a8432e62d3e5a0", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv10-ClientCert-RSA-RSA", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-ClientCert-RSA-RSA", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-ClientCert-RSA-RSA", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-ClientCert-RSA-RSA?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "937c2909f904ab50f75b26fd24ec37905db769fe", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv10-ECDHE-ECDSA-AES", "status": "modified", "additions": 42, "deletions": 41, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-ECDHE-ECDSA-AES", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-ECDHE-ECDSA-AES", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-ECDHE-ECDSA-AES?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "f8183f103539129755173db2aaa0eb1e4869bb62", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv10-ECDHE-RSA-AES", "status": "modified", "additions": 42, "deletions": 41, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-ECDHE-RSA-AES", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-ECDHE-RSA-AES", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-ECDHE-RSA-AES?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "b5deaeb011a460f331fbfbb18430174577977a24", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv10-RSA-RC4", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-RSA-RC4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-RSA-RC4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv10-RSA-RC4?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "a4a29306cb7ccd3281f87b758ccbf1829fb2a5c1", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv11-ECDHE-ECDSA-AES", "status": "modified", "additions": 43, "deletions": 42, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv11-ECDHE-ECDSA-AES", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv11-ECDHE-ECDSA-AES", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv11-ECDHE-ECDSA-AES?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "103f1d8a11d1d3a3d8c42b3630d8caf3563e3ccf", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv11-ECDHE-RSA-AES", "status": "modified", "additions": 42, "deletions": 41, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv11-ECDHE-RSA-AES", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv11-ECDHE-RSA-AES", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv11-ECDHE-RSA-AES?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "729391f68ca4945720fa9e49d84b6ff4972ec85a", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv11-RSA-RC4", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv11-RSA-RC4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv11-RSA-RC4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv11-RSA-RC4?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "9ecb065f09218b7d53f832181b4a78954712e016", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-ALPN", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ALPN", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ALPN", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ALPN?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "a22ffaeb499ab6c9d2774ac19420947c35f1d851", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-ALPN-NoMatch", "status": "modified", "additions": 40, "deletions": 39, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ALPN-NoMatch", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ALPN-NoMatch", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ALPN-NoMatch?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "1470ba7a2500e189c64522c4a244b8ec96663434", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-ClientCert-ECDSA-ECDSA", "status": "modified", "additions": 54, "deletions": 54, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ClientCert-ECDSA-ECDSA", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ClientCert-ECDSA-ECDSA", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ClientCert-ECDSA-ECDSA?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "95c5782ab0d88deda7c7bd5380c5665d021e75d3", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-ClientCert-ECDSA-RSA", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ClientCert-ECDSA-RSA", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ClientCert-ECDSA-RSA", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ClientCert-ECDSA-RSA?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "52e3befe615cd2c972848b84276ace73c97b5514", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-ClientCert-RSA-AES256-GCM-SHA384", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ClientCert-RSA-AES256-GCM-SHA384", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ClientCert-RSA-AES256-GCM-SHA384", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ClientCert-RSA-AES256-GCM-SHA384?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "23bf29d776e1b441673c6e30c982dc627b94d4e3", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-ClientCert-RSA-ECDSA", "status": "modified", "additions": 54, "deletions": 54, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ClientCert-RSA-ECDSA", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ClientCert-RSA-ECDSA", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ClientCert-RSA-ECDSA?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "ff79aa236c569cce02ef8a9fe8489f310211b449", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-ClientCert-RSA-RSA", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ClientCert-RSA-RSA", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ClientCert-RSA-RSA", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ClientCert-RSA-RSA?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "e700e16352a692cca48ce48dc141b5d317fecde7", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-ECDHE-ECDSA-AES", "status": "modified", "additions": 43, "deletions": 42, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ECDHE-ECDSA-AES", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ECDHE-ECDSA-AES", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ECDHE-ECDSA-AES?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "607ecdcb2407fac950a092a79597d79e9769445e", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-ECDHE-ECDSA-AES-GCM", "status": "modified", "additions": 40, "deletions": 39, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ECDHE-ECDSA-AES-GCM", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ECDHE-ECDSA-AES-GCM", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ECDHE-ECDSA-AES-GCM?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "df2f7376de8b8cdb6f9983367971960f041fe10a", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-ECDHE-ECDSA-AES256-GCM-SHA384", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ECDHE-ECDSA-AES256-GCM-SHA384", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ECDHE-ECDSA-AES256-GCM-SHA384", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ECDHE-ECDSA-AES256-GCM-SHA384?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "994ebb1e37f94b4eb4b5c06f77dedfbf1cf823a6", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-ECDHE-RSA-AES", "status": "modified", "additions": 42, "deletions": 41, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ECDHE-RSA-AES", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ECDHE-RSA-AES", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ECDHE-RSA-AES?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "73e34c0ce354b4006b36c3251adbfa07a688694d", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-RSA-RC4", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-RSA-RC4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-RSA-RC4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-RSA-RC4?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "826c9f0a579cdacfc83b3923bba61b4fb658dd02", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-SCT", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-SCT", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-SCT", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-SCT?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "20520f542d4923ecafe64f137fc53def751dbea0", "filename": "libgo/go/crypto/tls/testdata/Server-SSLv3-RSA-3DES", "status": "modified", "additions": 70, "deletions": 75, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-SSLv3-RSA-3DES", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-SSLv3-RSA-3DES", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-SSLv3-RSA-3DES?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "e0fe95658dac3653b0a02707289e1b05436cb507", "filename": "libgo/go/crypto/tls/testdata/Server-SSLv3-RSA-AES", "status": "modified", "additions": 71, "deletions": 76, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-SSLv3-RSA-AES", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-SSLv3-RSA-AES", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-SSLv3-RSA-AES?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "39124c67ef17599532481192643d242c9fd89a5e", "filename": "libgo/go/crypto/tls/testdata/Server-SSLv3-RSA-RC4", "status": "modified", "additions": 66, "deletions": 71, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-SSLv3-RSA-RC4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-SSLv3-RSA-RC4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-SSLv3-RSA-RC4?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "f81ffc28c0e585f3c3e4882139ac4f2c079ee4ce", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv10-ECDHE-ECDSA-AES", "status": "modified", "additions": 40, "deletions": 39, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv10-ECDHE-ECDSA-AES", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv10-ECDHE-ECDSA-AES", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv10-ECDHE-ECDSA-AES?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "55cb487d12a9835b91c8b76eb9d05d2118b36847", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv10-RSA-3DES", "status": "modified", "additions": 66, "deletions": 71, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv10-RSA-3DES", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv10-RSA-3DES", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv10-RSA-3DES?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "46713022890f527cb1031bddcc51d97376a6d7c4", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv10-RSA-AES", "status": "modified", "additions": 69, "deletions": 74, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv10-RSA-AES", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv10-RSA-AES", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv10-RSA-AES?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "b5cb479c283eda63b40908fdf900990452c9fd71", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv10-RSA-RC4", "status": "modified", "additions": 63, "deletions": 68, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv10-RSA-RC4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv10-RSA-RC4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv10-RSA-RC4?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "dc5e765e5438ae0f1823d8098811be05f93c9eaa", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv11-RSA-RC4", "status": "modified", "additions": 63, "deletions": 68, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv11-RSA-RC4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv11-RSA-RC4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv11-RSA-RC4?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "cbfeb42eb06deaf96867e6c378fa4be379e267f8", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-ALPN", "status": "modified", "additions": 102, "deletions": 115, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ALPN", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ALPN", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ALPN?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "af75445dc5559e9d32b5dc74acb9b5c2583a55be", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-ALPN-NoMatch", "status": "modified", "additions": 102, "deletions": 115, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ALPN-NoMatch", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ALPN-NoMatch", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ALPN-NoMatch?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "344d9737b253cc83cbc7800b76799f843f9f26f6", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-CipherSuiteCertPreferenceECDSA", "status": "modified", "additions": 90, "deletions": 83, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-CipherSuiteCertPreferenceECDSA", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-CipherSuiteCertPreferenceECDSA", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-CipherSuiteCertPreferenceECDSA?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "10624c02591a528cb9b81757a098ad1b9c0bc6bf", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-CipherSuiteCertPreferenceRSA", "status": "modified", "additions": 96, "deletions": 93, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-CipherSuiteCertPreferenceRSA", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-CipherSuiteCertPreferenceRSA", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-CipherSuiteCertPreferenceRSA?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "56c3c822e352124fafd8a0f47e53f75d6e01ab3d", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-ClientAuthRequestedAndECDSAGiven", "status": "modified", "additions": 76, "deletions": 81, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ClientAuthRequestedAndECDSAGiven", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ClientAuthRequestedAndECDSAGiven", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ClientAuthRequestedAndECDSAGiven?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "862e0be09eef947abc0d13095bd128d71bce7a30", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-ClientAuthRequestedAndGiven", "status": "modified", "additions": 76, "deletions": 81, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ClientAuthRequestedAndGiven", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ClientAuthRequestedAndGiven", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ClientAuthRequestedAndGiven?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "5de6dd82ec0b27325f879dfcb8c0e4b34056e765", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-ClientAuthRequestedNotGiven", "status": "modified", "additions": 67, "deletions": 72, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ClientAuthRequestedNotGiven", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ClientAuthRequestedNotGiven", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ClientAuthRequestedNotGiven?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "3b7238ad29970af507f86fe6c2b0d0ce0c63f5bb", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-ECDHE-ECDSA-AES", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ECDHE-ECDSA-AES", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ECDHE-ECDSA-AES", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ECDHE-ECDSA-AES?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "20a0731091a6b0b679cacf92de0602b5f92917c9", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-IssueTicket", "status": "modified", "additions": 75, "deletions": 79, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-IssueTicket", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-IssueTicket", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-IssueTicket?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "a8f7edfa2c011a6cafc4aa631128980832118014", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-IssueTicketPreDisable", "status": "modified", "additions": 75, "deletions": 79, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-IssueTicketPreDisable", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-IssueTicketPreDisable", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-IssueTicketPreDisable?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "74576264d856b786f17f7ff09a0d86cec6365197", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-RSA-3DES", "status": "modified", "additions": 68, "deletions": 74, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-RSA-3DES", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-RSA-3DES", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-RSA-3DES?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "4ca860d2c262724979c330d23f05088258611fa2", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-RSA-AES", "status": "modified", "additions": 70, "deletions": 76, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-RSA-AES", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-RSA-AES", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-RSA-AES?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "7a26ebd82a76a932e791f5080e03528826d5595e", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-RSA-AES-GCM", "status": "modified", "additions": 75, "deletions": 81, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-RSA-AES-GCM", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-RSA-AES-GCM", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-RSA-AES-GCM?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "d59645c52dbab83daf276ca6a8937e3d725bb814", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-RSA-AES256-GCM-SHA384", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-RSA-AES256-GCM-SHA384", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-RSA-AES256-GCM-SHA384", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-RSA-AES256-GCM-SHA384?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "13163d68f6876ec0e7d6a36c53b684c58c192094", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-RSA-RC4", "status": "modified", "additions": 65, "deletions": 71, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-RSA-RC4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-RSA-RC4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-RSA-RC4?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "8cacd2184087fed16428c58035e8fc5cf1f0d871", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-Resume", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-Resume", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-Resume", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-Resume?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "912c1787a1e1c96cb8e898ef6a928501f378645a", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-ResumeDisabled", "status": "modified", "additions": 76, "deletions": 80, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ResumeDisabled", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ResumeDisabled", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ResumeDisabled?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "aee57421a23447cf85db50dfd831001e06028f68", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-SNI", "status": "modified", "additions": 22, "deletions": 34, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-SNI", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-SNI", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-SNI?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "40d3714a86db625f08b51f63c4f9116674f67c7e", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-SNI-GetCertificate", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-SNI-GetCertificate", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-SNI-GetCertificate", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-SNI-GetCertificate?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "904f69ecacb5f43ce5c61e29a26b8c5a161c64e4", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-SNI-GetCertificateNotFound", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-SNI-GetCertificateNotFound", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-SNI-GetCertificateNotFound", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-SNI-GetCertificateNotFound?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "7be50ce68c959f07554e10eb6b92cb7b1b530aac", "filename": "libgo/go/crypto/tls/ticket.go", "status": "modified", "additions": 32, "deletions": 11, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Fticket.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Fticket.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fticket.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "0b1c3778ad41ec4950b708f6005cfd6dd568b9c5", "filename": "libgo/go/crypto/tls/tls.go", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "c45c10378d76344ed34e1795fbec10391a628ebe", "filename": "libgo/go/crypto/tls/tls_test.go", "status": "modified", "additions": 53, "deletions": 1, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "2362e84688d140179f5e77a0ef111056a13dc328", "filename": "libgo/go/crypto/x509/cert_pool.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fx509%2Fcert_pool.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fx509%2Fcert_pool.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fcert_pool.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "49ceadb4366fc6666b406d8bbd64deb7ccfce4e5", "filename": "libgo/go/crypto/x509/pem_decrypt.go", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fx509%2Fpem_decrypt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fx509%2Fpem_decrypt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fpem_decrypt.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "685d5ee15697cb00d4efdb7b60a2d39cdda754a2", "filename": "libgo/go/crypto/x509/pem_decrypt_test.go", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fx509%2Fpem_decrypt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fx509%2Fpem_decrypt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fpem_decrypt_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "5add4e5d3e0d0d5aab1a6be905fd2f6a68383bf6", "filename": "libgo/go/crypto/x509/pkix/pkix.go", "status": "modified", "additions": 31, "deletions": 14, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkix%2Fpkix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkix%2Fpkix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkix%2Fpkix.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "93172837368935ef444f7e9765e3ded5abaebe69", "filename": "libgo/go/crypto/x509/root_bsd.go", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_bsd.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "bf4a5cdfeeef2fcf15475e300fa332c74ba9bb8c", "filename": "libgo/go/crypto/x509/root_cgo_darwin.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_cgo_darwin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_cgo_darwin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_cgo_darwin.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "78de56c221531491f117f034757809df70af23b5", "filename": "libgo/go/crypto/x509/root_darwin.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_darwin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_darwin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_darwin.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "5817158c33b6e90b9c040cddb6d4542d7f76ccb4", "filename": "libgo/go/crypto/x509/root_darwin_arm_gen.go", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_darwin_arm_gen.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_darwin_arm_gen.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_darwin_arm_gen.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "37675b48a39035ac2e2036a2fe4f9d7b9171bb53", "filename": "libgo/go/crypto/x509/root_darwin_armx.go", "status": "added", "additions": 4907, "deletions": 0, "changes": 4907, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_darwin_armx.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_darwin_armx.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_darwin_armx.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "cfeca6958ca0c31865b70c36f6ee93f6d3898271", "filename": "libgo/go/crypto/x509/root_linux.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_linux.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "4413f64738a7f6f6add0ff2888d710e74365a4f9", "filename": "libgo/go/crypto/x509/root_nacl.go", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_nacl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_nacl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_nacl.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "e6d4e613994754d2e7e303dcd09c22fde836f255", "filename": "libgo/go/crypto/x509/root_solaris.go", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_solaris.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_solaris.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_solaris.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "8d3b2fbb23395dc7bbd455fa457a419f27aa830c", "filename": "libgo/go/crypto/x509/root_unix.go", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_unix.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "c4d7ab68f7dbbb9d7cb8d8f5217f74c3e34caf83", "filename": "libgo/go/crypto/x509/sec1.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fx509%2Fsec1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fx509%2Fsec1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fsec1.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "79dc685c5b55bec4404b303dc7c6b40c2f4975b3", "filename": "libgo/go/crypto/x509/sha2_windows_test.go", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fx509%2Fsha2_windows_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fx509%2Fsha2_windows_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fsha2_windows_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "21b870c1712cc712ed3c2dc89baa37af9ccce1c8", "filename": "libgo/go/crypto/x509/verify.go", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "694c14023b8ab12f9685134ce11e576cb6e6b86d", "filename": "libgo/go/crypto/x509/verify_test.go", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "be6c013464b40eae1a8e881b4aa51ccf7d71dd41", "filename": "libgo/go/crypto/x509/x509.go", "status": "modified", "additions": 254, "deletions": 142, "changes": 396, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "f4f9fa2f7f9e39e322281679a2687181d7459927", "filename": "libgo/go/crypto/x509/x509_test.go", "status": "modified", "additions": 185, "deletions": 35, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "8cbbb29a7c24e025019ec7e055f4ada0b0d12ac9", "filename": "libgo/go/database/sql/fakedb_test.go", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "aaa4ea28be4527d956e58c08a9d103c2ac7ac42a", "filename": "libgo/go/database/sql/sql.go", "status": "modified", "additions": 144, "deletions": 97, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "432a641b85549632dba855b4500a7bf32a209ae4", "filename": "libgo/go/database/sql/sql_test.go", "status": "modified", "additions": 174, "deletions": 52, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "2ade0bd76ad6eabef752953016a6445205e3762a", "filename": "libgo/go/debug/dwarf/buf.go", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Fdwarf%2Fbuf.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Fdwarf%2Fbuf.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Fbuf.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "0b1206b9f3daf08388f77fbd433d08a07b3e5a6c", "filename": "libgo/go/debug/dwarf/class_string.go", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Fdwarf%2Fclass_string.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Fdwarf%2Fclass_string.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Fclass_string.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "2170db1e32dc7a53cfb7972a3bac10c5f77d7400", "filename": "libgo/go/debug/dwarf/const.go", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Fdwarf%2Fconst.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Fdwarf%2Fconst.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Fconst.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "d607e5b4a38e498d04cb1d1208ee4a04d74baffd", "filename": "libgo/go/debug/dwarf/entry.go", "status": "modified", "additions": 249, "deletions": 26, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Fdwarf%2Fentry.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Fdwarf%2Fentry.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Fentry.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "ca64bbd7f3b310778058a3a404d699f5a84e0907", "filename": "libgo/go/debug/dwarf/line.go", "status": "modified", "additions": 522, "deletions": 413, "changes": 935, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Fdwarf%2Fline.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Fdwarf%2Fline.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Fline.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "4104b5d49b80b7399f9fe6f211cab40e79ee6107", "filename": "libgo/go/debug/dwarf/line_test.go", "status": "modified", "additions": 204, "deletions": 28, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Fdwarf%2Fline_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Fdwarf%2Fline_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Fline_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "b63cc781c410a53840c001af944e6292935ce3ff", "filename": "libgo/go/debug/dwarf/testdata/line-clang.elf", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftestdata%2Fline-clang.elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftestdata%2Fline-clang.elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftestdata%2Fline-clang.elf?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "50500a8eecd95ee18ac78e130e12eef10c4aaf55", "filename": "libgo/go/debug/dwarf/testdata/line-gcc.elf", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftestdata%2Fline-gcc.elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftestdata%2Fline-gcc.elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftestdata%2Fline-gcc.elf?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "f35864776caf0bbf7b971b69f72cfef08dba91ee", "filename": "libgo/go/debug/dwarf/testdata/line1.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftestdata%2Fline1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftestdata%2Fline1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftestdata%2Fline1.c?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "974d4c881778482a760d68b2f197c7a91b565126", "filename": "libgo/go/debug/dwarf/testdata/line1.h", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftestdata%2Fline1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftestdata%2Fline1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftestdata%2Fline1.h?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "38d89983cbb2433f398e26b09aae09b24961988b", "filename": "libgo/go/debug/dwarf/testdata/line2.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftestdata%2Fline2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftestdata%2Fline2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftestdata%2Fline2.c?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "a5daa1d0bb18e6e48b640ef5c4e87568a5f1709c", "filename": "libgo/go/debug/dwarf/type.go", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftype.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "9cfb4a8b256d312da316f6132d4684d3ca849e35", "filename": "libgo/go/debug/dwarf/typeunit.go", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftypeunit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftypeunit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftypeunit.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "ceb6cdbff321933cd10f06c5c174070fc7344fd3", "filename": "libgo/go/debug/dwarf/unit.go", "status": "modified", "additions": 35, "deletions": 32, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Fdwarf%2Funit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Fdwarf%2Funit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Funit.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "c97ccaa4c1c3cd67401ad65237cfb5e7964566cb", "filename": "libgo/go/debug/elf/elf.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Felf%2Felf.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Felf%2Felf.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Felf.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "370c5e6437c94e5aaa34421a6d3fe41d708dbe95", "filename": "libgo/go/debug/elf/file.go", "status": "modified", "additions": 84, "deletions": 65, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "1ad43146ac8b31858504d0c10e83d6d545b2437d", "filename": "libgo/go/debug/elf/file_test.go", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Felf%2Ffile_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Felf%2Ffile_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Ffile_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "1cc7e4b11143698a3abc3f72b88411e41f3d4989", "filename": "libgo/go/debug/elf/testdata/go-relocation-test-clang-arm.obj", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Felf%2Ftestdata%2Fgo-relocation-test-clang-arm.obj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Felf%2Ftestdata%2Fgo-relocation-test-clang-arm.obj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Ftestdata%2Fgo-relocation-test-clang-arm.obj?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "ed45be2c55fda61466e4860e42fab07cc9228978", "filename": "libgo/go/debug/elf/testdata/go-relocation-test-gcc492-arm.obj", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Felf%2Ftestdata%2Fgo-relocation-test-gcc492-arm.obj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Felf%2Ftestdata%2Fgo-relocation-test-gcc492-arm.obj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Ftestdata%2Fgo-relocation-test-gcc492-arm.obj?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "53f3e952d62bdbf7f2d12c535aa701ecedc45da5", "filename": "libgo/go/debug/gosym/pclntab_test.go", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Fgosym%2Fpclntab_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Fgosym%2Fpclntab_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fgosym%2Fpclntab_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "46f07833442b28c7e111ee3caa96b7f6e6654780", "filename": "libgo/go/debug/gosym/symtab.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Fgosym%2Fsymtab.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Fgosym%2Fsymtab.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fgosym%2Fsymtab.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "a7599aa5b2b13922956259a62ecaab5e28207387", "filename": "libgo/go/debug/macho/file.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Fmacho%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Fmacho%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fmacho%2Ffile.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "3df4ae73681e0f56fce796b4fb27640576b8b00e", "filename": "libgo/go/debug/pe/file.go", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Fpe%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Fpe%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fpe%2Ffile.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "316a569ede97dd5e2a84235f5fcb886453413c17", "filename": "libgo/go/debug/pe/file_test.go", "status": "modified", "additions": 91, "deletions": 25, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Fpe%2Ffile_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fdebug%2Fpe%2Ffile_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fpe%2Ffile_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "2ac411af8820b7c2c8f22f5f442307a3810ec27d", "filename": "libgo/go/encoding/asn1/asn1.go", "status": "modified", "additions": 45, "deletions": 5, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "893d0801b00308ffd935d6d26426631fe3e9efc6", "filename": "libgo/go/encoding/asn1/asn1_test.go", "status": "modified", "additions": 77, "deletions": 2, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "ab85e0496ff85171ee05f531eb4559c3694be7c7", "filename": "libgo/go/encoding/asn1/common.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fasn1%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fasn1%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fcommon.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "67a019db2d40677d68517e2d44330419f12e743b", "filename": "libgo/go/encoding/asn1/marshal.go", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "cdca8aa33638d8eba823a0a730ced38a239c85f3", "filename": "libgo/go/encoding/asn1/marshal_test.go", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "3302fb4a7426924d2f9b6f529184193f5bb19df9", "filename": "libgo/go/encoding/base64/base64.go", "status": "modified", "additions": 141, "deletions": 84, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "d144b96821f9bf614e5f1e3ec2a9a0ddc9d144be", "filename": "libgo/go/encoding/base64/base64_test.go", "status": "modified", "additions": 61, "deletions": 13, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "2bbe07c02ff3153886c76f8756ca9c83a3bfbfe0", "filename": "libgo/go/encoding/binary/binary.go", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "e3c3bd51228633888a7844e83a9a047e2717812a", "filename": "libgo/go/encoding/csv/example_test.go", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fcsv%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fcsv%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fcsv%2Fexample_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "37bf80ceaedd9b8e7e69fe5a3d852a5d5b6dd787", "filename": "libgo/go/encoding/csv/reader.go", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fcsv%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fcsv%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fcsv%2Freader.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "be1002d034a1768c8b5e47ee225e01f0222f3142", "filename": "libgo/go/encoding/csv/reader_test.go", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fcsv%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fcsv%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fcsv%2Freader_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "353d91f238f80fa49dbb3fbebe37b28633f35fc0", "filename": "libgo/go/encoding/csv/writer.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fcsv%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fcsv%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fcsv%2Fwriter.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "c2583bfee337d18fbe4971dbbff005419805b5c8", "filename": "libgo/go/encoding/gob/codec_test.go", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fgob%2Fcodec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fgob%2Fcodec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fcodec_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "e913f15c545a240cc0760cd681fcc10af9664653", "filename": "libgo/go/encoding/gob/decode.go", "status": "modified", "additions": 69, "deletions": 38, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "4d3d0076fbc570a32ef7cdb83ae7d12b15a3bc5f", "filename": "libgo/go/encoding/gob/doc.go", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fgob%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fgob%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fdoc.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "62d0f42e81ae3fc8f7bbdd692bfc31427803a68d", "filename": "libgo/go/encoding/gob/encoder.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "dc657348223ce005dc3055ea9d68da918a3697fc", "filename": "libgo/go/encoding/gob/encoder_test.go", "status": "modified", "additions": 84, "deletions": 20, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "ed89d1156eda8ef31a9ce243974acf1e987e1159", "filename": "libgo/go/encoding/json/bench_test.go", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fjson%2Fbench_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fjson%2Fbench_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fbench_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "530e8521dc5e6eccecfd0cde8926edada7d793fe", "filename": "libgo/go/encoding/json/decode.go", "status": "modified", "additions": 30, "deletions": 21, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "8aa158f08cdade6f9fe7f2d3caa91382bb646a1a", "filename": "libgo/go/encoding/json/decode_test.go", "status": "modified", "additions": 83, "deletions": 3, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "90782deb70be7aedbcc837d5427a201bb7ff35da", "filename": "libgo/go/encoding/json/encode.go", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "9e170127dbac439b7ccbd87537167a78379db84a", "filename": "libgo/go/encoding/json/fold.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fjson%2Ffold.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fjson%2Ffold.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Ffold.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "38d0b0802b356b09c2b0ecfe782d592afd3be960", "filename": "libgo/go/encoding/json/scanner.go", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fjson%2Fscanner.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fjson%2Fscanner.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fscanner.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "66383ef0ef7565833e79736a493ec1eddc473eab", "filename": "libgo/go/encoding/json/scanner_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fjson%2Fscanner_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fjson%2Fscanner_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fscanner_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "dc53bceff85ebe6e6a4fe73f799db1cf2978a4fc", "filename": "libgo/go/encoding/json/stream.go", "status": "modified", "additions": 303, "deletions": 23, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fjson%2Fstream.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fjson%2Fstream.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fstream.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "c2e30408cd81c2de7384f93dd41bc63e8b4477d4", "filename": "libgo/go/encoding/json/stream_test.go", "status": "modified", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fjson%2Fstream_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fjson%2Fstream_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fstream_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "85bb4ba83777a9e244af2366d5d1fb6b83ff75ea", "filename": "libgo/go/encoding/json/tagkey_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fjson%2Ftagkey_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fjson%2Ftagkey_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Ftagkey_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "506196b1db9bd412c050b9da4516d172a1f1801e", "filename": "libgo/go/encoding/pem/pem.go", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fpem%2Fpem.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fpem%2Fpem.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fpem%2Fpem.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "ab656c6261c4012a112b7a9e426d5e6589c41ae4", "filename": "libgo/go/encoding/pem/pem_test.go", "status": "modified", "additions": 111, "deletions": 1, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fpem%2Fpem_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fpem%2Fpem_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fpem%2Fpem_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "86d1422a5bd53fbc458c358079e5e0940b9161c5", "filename": "libgo/go/encoding/xml/marshal.go", "status": "modified", "additions": 55, "deletions": 4, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "66675d7abc409e8f39f4ffa523e098589cb6e1a3", "filename": "libgo/go/encoding/xml/marshal_test.go", "status": "modified", "additions": 526, "deletions": 26, "changes": 552, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "7d004dc488cdfe7a6bd9bb29e0278acae9b4b514", "filename": "libgo/go/encoding/xml/read_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fxml%2Fread_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fxml%2Fread_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fread_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "0a21c9305310341812f95d48bdd55fdc4f117fdd", "filename": "libgo/go/encoding/xml/xml.go", "status": "modified", "additions": 32, "deletions": 12, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fxml%2Fxml.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fxml%2Fxml.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fxml.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "312a7c98a5c50488fda5a98bed217598b6300eb0", "filename": "libgo/go/encoding/xml/xml_test.go", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fxml%2Fxml_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fencoding%2Fxml%2Fxml_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fxml_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "24c2d6b29ab4221928104eb052ff693bb223f733", "filename": "libgo/go/expvar/expvar.go", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fexpvar%2Fexpvar.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fexpvar%2Fexpvar.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexpvar%2Fexpvar.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "8bc633e4a9767acd61bd28e6cd6578b3046eca70", "filename": "libgo/go/expvar/expvar_test.go", "status": "modified", "additions": 229, "deletions": 6, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fexpvar%2Fexpvar_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fexpvar%2Fexpvar_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexpvar%2Fexpvar_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "3abc80e9c676ca9334a50fd69db1b9084c7158a7", "filename": "libgo/go/flag/flag.go", "status": "modified", "additions": 125, "deletions": 26, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fflag%2Fflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fflag%2Fflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fflag%2Fflag.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "e2319ec94c8691f83c30b0c9e9fdeb73903d2e13", "filename": "libgo/go/flag/flag_test.go", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fflag%2Fflag_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Fflag%2Fflag_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fflag%2Fflag_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "ef91368ef0849dcc20f03f58cfa0ab7dfc605ec5", "filename": "libgo/go/fmt/doc.go", "status": "modified", "additions": 48, "deletions": 29, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Ffmt%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Ffmt%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fdoc.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "8f3587b55054fce319875056b003c205b9ee6a60", "filename": "libgo/go/fmt/fmt_test.go", "status": "modified", "additions": 99, "deletions": 17, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Ffmt_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "517b18f7d4378e3c60bc3f9c123d10273d42a2ac", "filename": "libgo/go/fmt/format.go", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Ffmt%2Fformat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Ffmt%2Fformat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fformat.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "1267cc34ee332a87114b1d6213b0afab7de5436b", "filename": "libgo/go/fmt/norace_test.go", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Ffmt%2Fnorace_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Ffmt%2Fnorace_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fnorace_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "8d3e97c3ab1b7da8959a71218302a73ceef89f57", "filename": "libgo/go/fmt/print.go", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Ffmt%2Fprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Ffmt%2Fprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fprint.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "ae3147a5b000c9118782accd86d12140ffbf5bdb", "filename": "libgo/go/fmt/race_test.go", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Ffmt%2Frace_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Ffmt%2Frace_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Frace_test.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}, {"sha": "5b9b516353b94c18ff3bf7538f61aac7b7acf897", "filename": "libgo/go/fmt/scan.go", "status": "modified", "additions": 62, "deletions": 41, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Ffmt%2Fscan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af146490bb04205107cb23e301ec7a8ff927b5fc/libgo%2Fgo%2Ffmt%2Fscan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fscan.go?ref=af146490bb04205107cb23e301ec7a8ff927b5fc"}]}