{"sha": "f60d648137b2d2cda1c598996b9598d559715117", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjYwZDY0ODEzN2IyZDJjZGExYzU5ODk5NmI5NTk4ZDU1OTcxNTExNw==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@verizon.net", "date": "2005-07-02T03:17:55Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2005-07-02T03:17:55Z"}, "message": "intrinsic.texi: Add documentaion for eoshift, epsilon, etime, and exit.\n\n2005-07-01  Jerry DeLisle  <jvdelisle@verizon.net>\n\n    * intrinsic.texi: Add documentaion for eoshift, epsilon, etime, and exit.\n    Fixed alignment of text for dtime syntax. Fixed a few line lengths.\n\nFrom-SVN: r101530", "tree": {"sha": "c23c8126478d5c63f2fd2aa41550c076e7741143", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c23c8126478d5c63f2fd2aa41550c076e7741143"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f60d648137b2d2cda1c598996b9598d559715117", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f60d648137b2d2cda1c598996b9598d559715117", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f60d648137b2d2cda1c598996b9598d559715117", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f60d648137b2d2cda1c598996b9598d559715117/comments", "author": null, "committer": null, "parents": [{"sha": "606c33f195f98232adedfef307b07cdadea2bfd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/606c33f195f98232adedfef307b07cdadea2bfd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/606c33f195f98232adedfef307b07cdadea2bfd8"}], "stats": {"total": 258, "additions": 242, "deletions": 16}, "files": [{"sha": "2e9053edfc3efe7af7fc9e28769ea23b271db9c0", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f60d648137b2d2cda1c598996b9598d559715117/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f60d648137b2d2cda1c598996b9598d559715117/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=f60d648137b2d2cda1c598996b9598d559715117", "patch": "@@ -1,3 +1,10 @@\n+2005-07-01  Jerry DeLisle  <jvdelisle@verizon.net>\n+\n+    * gfortran.texi: Fix typos and grammar.\n+    * invoke.texi: Fix typos and grammar.\n+    * intrinsic.texi: Add documentaion for eoshift, epsilon, etime, and exit.\n+    Fixed alignment of text for dtime syntax. Fixed a few line lengths.\n+\n 2005-06-25  Jakub Jelinek  <jakub@redhat.com>\n \n \t* trans-stmt.c (gfc_trans_forall_1): Prefer to use smaller logical"}, {"sha": "72fb77beb7a88af8adad9d37d9aaeec79d4d35d6", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 235, "deletions": 16, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f60d648137b2d2cda1c598996b9598d559715117/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f60d648137b2d2cda1c598996b9598d559715117/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=f60d648137b2d2cda1c598996b9598d559715117", "patch": "@@ -77,8 +77,12 @@ and editing.  All contributions and corrections are strongly encouraged.\n * @code{DPROD}:         DPROD,     Double product function\n * @code{DREAL}:         DREAL,     Double real part function\n * @code{DTIME}:         DTIME,     Execution time subroutine (or function)\n+* @code{EOSHIFT}:       EOSHIFT,   End-off shift function\n+* @code{EPSILON}:       EPSILON,   Epsilon function\n * @code{ERF}:           ERF,       Error function\n * @code{ERFC}:          ERFC,      Complementary error function\n+* @code{ETIME}:         ETIME,     Execution time subroutine (or function)\n+* @code{EXIT}:          EXIT,      Exit the program with status.\n * @code{EXP}:           EXP,       Cosine function\n * @code{LOG}:           LOG,       Logarithm function\n * @code{LOG10}:         LOG10,     Base 10 logarithm function \n@@ -665,8 +669,8 @@ end program test_anint\n \n @table @asis\n @item @emph{Description}:\n-@code{ANY(MASK [, DIM])} determines if any of the values in the logical array @var{MASK}\n-along dimension @var{DIM} are @code{.TRUE.}.\n+@code{ANY(MASK [, DIM])} determines if any of the values in the logical array\n+@var{MASK} along dimension @var{DIM} are @code{.TRUE.}.\n \n @item @emph{Option}:\n f95, gnu\n@@ -1225,7 +1229,8 @@ end program test_besyn\n \n @table @asis\n @item @emph{Description}:\n-@code{BIT_SIZE(I)} returns the number of bits (integer precision plus sign bit) represented by the type of @var{I}.\n+@code{BIT_SIZE(I)} returns the number of bits (integer precision plus sign bit)\n+represented by the type of @var{I}.\n \n @item @emph{Option}:\n f95, gnu\n@@ -1264,7 +1269,8 @@ end program test_bit_size\n \n @table @asis\n @item @emph{Description}:\n-@code{BTEST(I,POS)} returns logical .TRUE. if the bit at @var{POS} in @var{I} is set.\n+@code{BTEST(I,POS)} returns logical @code{.TRUE.} if the bit at @var{POS}\n+in @var{I} is set.\n \n @item @emph{Option}:\n f95, gnu\n@@ -1964,7 +1970,6 @@ program test_digits\n     integer :: i = 12345\n     real :: x = 3.143\n     real(8) :: y = 2.33\n-    complex :: z = (23.0,45.6)\n     print *, digits(i)\n     print *, digits(x)\n     print *, digits(y)\n@@ -2166,9 +2171,11 @@ end program test_dreal\n @code{DTIME(TARRAY, RESULT)} initially returns the number of seconds of runtime\n since the start of the process's execution in @var{RESULT}.  @var{TARRAY}\n returns the user and system components of this time in @code{TARRAY(1)} and\n-@code{TARRAY(2)} respectively. @var{RESULT} is equal to @code{TARRAY(1) + TARRAY(2)}.\n+@code{TARRAY(2)} respectively. @var{RESULT} is equal to @code{TARRAY(1) +\n+TARRAY(2)}.\n \n-Subsequent invocations of @code{DTIME} return values accumulated since the previous invocation.\n+Subsequent invocations of @code{DTIME} return values accumulated since the\n+previous invocation.\n \n On some systems, the underlying timings are represented using types with\n sufficiently small limits that overflows (wraparounds) are possible, such as\n@@ -2194,8 +2201,10 @@ gnu\n subroutine\n \n @item @emph{Syntax}:\n-@code{CALL DTIME(TARRAY, RESULT)}\n-@code{RESULT = DTIME(TARRAY)}, (not recommended)\n+@multitable @columnfractions .80\n+@item @code{CALL DTIME(TARRAY, RESULT)}.\n+@item @code{RESULT = DTIME(TARRAY)}, (not recommended).\n+@end multitable\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .80\n@@ -2229,6 +2238,110 @@ end program test_dtime\n \n \n \n+@node EOSHIFT\n+@section @code{EOSHIFT} --- End-off shift function\n+@findex @code{EOSHIFT} intrinsic\n+@cindex eoshift intrinsic\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{EOSHIFT(ARRAY, SHIFT[,BOUNDARY, DIM])} performs an end-off shift on\n+elements of @var{ARRAY} along the dimension of @var{DIM}.  If @var{DIM} is\n+omitted it is taken to be @code{1}.  @var{DIM} is a scaler of type\n+@code{INTEGER} in the range of @math{1 /leq DIM /leq n)} where @math{n} is the\n+rank of @var{ARRAY}.  If the rank of @var{ARRAY} is one, then all elements of\n+@var{ARRAY} are shifted by @var{SHIFT} places.  If rank is greater than one,\n+then all complete rank one sections of @var{ARRAY} along the given dimension are\n+shifted.  Elements shifted out one end of each rank one section are dropped.  If\n+@var{BOUNDARY} is present then the cooresponding value of from @var{BOUNDARY}\n+is copied back in the other end.  If @var{BOUNDARY} is not present then the\n+following are copied in depending on the type of @var{ARRAY}.\n+\n+@multitable @columnfractions .15 .80\n+@item @emph{Array Type} @tab @emph{Boundary Value}\n+@item Numeric  @tab 0 of the type and kind of @var{ARRAY}.\n+@item Logical  @tab @code{.FALSE.}.\n+@item Character(@var{len}) @tab @var{len} blanks.\n+@end multitable\n+\n+@item @emph{Option}:\n+f95, gnu\n+\n+@item @emph{Class}:\n+transformational function\n+\n+@item @emph{Syntax}:\n+@code{A = EOSHIFT(A, SHIFT[,BOUNDARY, DIM])}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{ARRAY}  @tab May be any type, not scaler.\n+@item @var{SHIFT}  @tab The type shall be @code{INTEGER}.\n+@item @var{BOUNDARY} @tab Same type as @var{ARRAY}. \n+@item @var{DIM}    @tab The type shall be @code{INTEGER}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+Returns an array of same type and rank as the @var{ARRAY} argument.\n+\n+@item @emph{Example}:\n+@smallexample\n+program test_eoshift\n+    integer, dimension(3,3) :: a\n+    a = reshape( (/ 1, 2, 3, 4, 5, 6, 7, 8, 9 /), (/ 3, 3 /))\n+    print '(3i3)', a(1,:)\n+    print '(3i3)', a(2,:)\n+    print '(3i3)', a(3,:)    \n+    a = EOSHIFT(a, SHIFT=(/1, 2, 1/), BOUNDARY=-5, DIM=2)\n+    print *\n+    print '(3i3)', a(1,:)\n+    print '(3i3)', a(2,:)\n+    print '(3i3)', a(3,:)\n+end program test_eoshift\n+@end smallexample\n+@end table\n+\n+\n+\n+@node EPSILON\n+@section @code{EPSILON} --- Epsilon function\n+@findex @code{EPSILON} intrinsic\n+@cindex epsilon, significant\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{EPSILON(X)} returns a nearly negligible number relative to @code{1}.\n+\n+@item @emph{Option}:\n+f95, gnu\n+\n+@item @emph{Class}:\n+inquiry function\n+\n+@item @emph{Syntax}:\n+@code{C = EPSILON(X)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{X} @tab The type shall be @code{REAL(*)}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value is of same type as the argument.\n+\n+@item @emph{Example}:\n+@smallexample\n+program test_epsilon\n+    real :: x = 3.143\n+    real(8) :: y = 2.33\n+    print *, EPSILON(x)\n+    print *, EPSILON(y)\n+end program test_epsilon\n+@end smallexample\n+@end table\n+\n+\n+\n @node ERF\n @section @code{ERF} --- Error function \n @findex @code{ERF} intrinsic\n@@ -2317,6 +2430,119 @@ end program test_erfc\n \n \n \n+@node ETIME\n+@section @code{ETIME} --- Execution time subroutine (or function)\n+@findex @code{ETIME} intrinsic\n+@cindex ETIME subroutine \n+\n+@table @asis\n+@item @emph{Description}:\n+@code{ETIME(TARRAY, RESULT)} returns the number of seconds of runtime\n+since the start of the process's execution in @var{RESULT}.  @var{TARRAY}\n+returns the user and system components of this time in @code{TARRAY(1)} and\n+@code{TARRAY(2)} respectively. @var{RESULT} is equal to @code{TARRAY(1) + TARRAY(2)}.\n+\n+On some systems, the underlying timings are represented using types with\n+sufficiently small limits that overflows (wraparounds) are possible, such as\n+32-bit types. Therefore, the values returned by this intrinsic might be, or\n+become, negative, or numerically less than previous values, during a single\n+run of the compiled program.\n+\n+If @code{ETIME} is invoked as a function, it can not be invoked as a\n+subroutine, and vice versa.\n+\n+@var{TARRAY} and @var{RESULT} are @code{INTENT(OUT)} and provide the following:\n+\n+@multitable @columnfractions .15 .30 .60\n+@item @tab @code{TARRAY(1)}: @tab User time in seconds.\n+@item @tab @code{TARRAY(2)}: @tab System time in seconds.\n+@item @tab @code{RESULT}: @tab Run time since start in seconds.\n+@end multitable\n+\n+@item @emph{Option}:\n+gnu\n+\n+@item @emph{Class}:\n+subroutine\n+\n+@item @emph{Syntax}:\n+@multitable @columnfractions .8\n+@item @code{CALL ETIME(TARRAY, RESULT)}.\n+@item @code{RESULT = ETIME(TARRAY)}, (not recommended).\n+@end multitable\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{TARRAY}@tab The type shall be @code{REAL, DIMENSION(2)}.\n+@item @var{RESULT}@tab The type shall be @code{REAL}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+Elapsed time in seconds since the start of program execution.\n+\n+@item @emph{Example}:\n+@smallexample\n+program test_etime\n+    integer(8) :: i, j\n+    real, dimension(2) :: tarray\n+    real :: result\n+    call ETIME(tarray, result)\n+    print *, result\n+    print *, tarray(1)\n+    print *, tarray(2)   \n+    do i=1,100000000    ! Just a delay\n+        j = i * i - i\n+    end do\n+    call ETIME(tarray, result)\n+    print *, result\n+    print *, tarray(1)\n+    print *, tarray(2)\n+end program test_etime\n+@end smallexample\n+@end table\n+\n+\n+\n+@node EXIT\n+@section @code{EXIT} --- Exit the program with status. \n+@findex @code{EXIT}\n+@cindex exit\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{EXIT} causes immediate termination of the program with status.  If status\n+is omitted it returns the connonical @emph{success} for the system.  All Fortran\n+I/O units are closed. \n+\n+@item @emph{Option}:\n+gnu\n+\n+@item @emph{Class}:\n+non-elemental subroutine\n+\n+@item @emph{Syntax}:\n+@code{CALL EXIT([STATUS])}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{STATUS} @tab The type of the argument shall be @code{INTEGER(*)}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+@code{STATUS} is passed to the parent process on exit.\n+\n+@item @emph{Example}:\n+@smallexample\n+program test_exit\n+  integer :: STATUS = 0\n+  print *, 'This program is going to exit.'\n+  call EXIT(STATUS)\n+end program test_exit\n+@end smallexample\n+@end table\n+\n+\n+\n @node EXP\n @section @code{EXP} --- Exponential function \n @findex @code{EXP} intrinsic\n@@ -2709,13 +2935,6 @@ end program test_tanh\n \n \n \n-@comment gen   eoshift\n-@comment \n-@comment gen   epsilon\n-@comment \n-@comment gen   etime\n-@comment sub   etime\n-@comment \n @comment sub   exit\n @comment \n @comment gen   exponent"}]}