{"sha": "1d15f620aa4e68f6298491d52ca8cc8d496457a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQxNWY2MjBhYTRlNjhmNjI5ODQ5MWQ1MmNhOGNjOGQ0OTY0NTdhNg==", "commit": {"author": {"name": "Kai Tietz", "email": "ktietz@redhat.com", "date": "2011-05-12T18:19:07Z"}, "committer": {"name": "Kai Tietz", "email": "ktietz@gcc.gnu.org", "date": "2011-05-12T18:19:07Z"}, "message": "gimplify.c (gimple_boolify): Re-boolify expression arguments even if expression type is of kind BOOLEAN_TYPE.\n\n2011-05-12  Kai Tietz  <ktietz@redhat.com>\n\n\t* gimplify.c (gimple_boolify): Re-boolify expression\n\targuments even if expression type is of kind BOOLEAN_TYPE.\n\t(gimplify_boolean_expr): Removed.\n\t(gimplify_expr): Boolify truth opcodes AND, ANDIF, OR, ORIF,\n\tand XOR. Additional take care that we keep expression's type.\n\t* tree-cfg.c (verify_gimple_assign_binary): Adjust check for type\n\tof TRUTH_AND|OR|XOR_EXPR.\n\nFrom-SVN: r173711", "tree": {"sha": "adcc70e35c9e266924a73609b2a5e907b5c51dd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/adcc70e35c9e266924a73609b2a5e907b5c51dd0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d15f620aa4e68f6298491d52ca8cc8d496457a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d15f620aa4e68f6298491d52ca8cc8d496457a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d15f620aa4e68f6298491d52ca8cc8d496457a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d15f620aa4e68f6298491d52ca8cc8d496457a6/comments", "author": null, "committer": null, "parents": [{"sha": "c2b5fc8de6a06b34a60f90bb37c46e27dc67d347", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2b5fc8de6a06b34a60f90bb37c46e27dc67d347", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2b5fc8de6a06b34a60f90bb37c46e27dc67d347"}], "stats": {"total": 84, "additions": 49, "deletions": 35}, "files": [{"sha": "4245ccc42639e9ed54fbbe599d5ee37524d456d3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d15f620aa4e68f6298491d52ca8cc8d496457a6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d15f620aa4e68f6298491d52ca8cc8d496457a6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1d15f620aa4e68f6298491d52ca8cc8d496457a6", "patch": "@@ -1,3 +1,13 @@\n+2011-05-12  Kai Tietz  <ktietz@redhat.com>\n+\n+\t* gimplify.c (gimple_boolify): Re-boolify expression\n+\targuments even if expression type is of kind BOOLEAN_TYPE.\n+\t(gimplify_boolean_expr): Removed.\n+\t(gimplify_expr): Boolify truth opcodes AND, ANDIF, OR, ORIF,\n+\tand XOR. Additional take care that we keep expression's type.\n+\t* tree-cfg.c (verify_gimple_assign_binary): Adjust check for type\n+\tof TRUTH_AND|OR|XOR_EXPR.\n+\n 2011-05-12  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/48975"}, {"sha": "c54d3b5dcfcff5868cf5c5af5f35bf1270a57865", "filename": "gcc/gimplify.c", "status": "modified", "additions": 35, "deletions": 31, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d15f620aa4e68f6298491d52ca8cc8d496457a6/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d15f620aa4e68f6298491d52ca8cc8d496457a6/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=1d15f620aa4e68f6298491d52ca8cc8d496457a6", "patch": "@@ -2824,9 +2824,6 @@ gimple_boolify (tree expr)\n \t}\n     }\n \n-  if (TREE_CODE (type) == BOOLEAN_TYPE)\n-    return expr;\n-\n   switch (TREE_CODE (expr))\n     {\n     case TRUTH_AND_EXPR:\n@@ -2851,6 +2848,8 @@ gimple_boolify (tree expr)\n     default:\n       /* Other expressions that get here must have boolean values, but\n \t might need to be converted to the appropriate mode.  */\n+      if (TREE_CODE (type) == BOOLEAN_TYPE)\n+\treturn expr;\n       return fold_convert_loc (loc, boolean_type_node, expr);\n     }\n }\n@@ -4695,31 +4694,6 @@ gimplify_scalar_mode_aggregate_compare (tree *expr_p)\n   return GS_OK;\n }\n \n-/* Gimplify TRUTH_ANDIF_EXPR and TRUTH_ORIF_EXPR expressions.  EXPR_P\n-   points to the expression to gimplify.\n-\n-   Expressions of the form 'a && b' are gimplified to:\n-\n-\ta && b ? true : false\n-\n-   LOCUS is the source location to be put on the generated COND_EXPR.\n-   gimplify_cond_expr will do the rest.  */\n-\n-static enum gimplify_status\n-gimplify_boolean_expr (tree *expr_p, location_t locus)\n-{\n-  /* Preserve the original type of the expression.  */\n-  tree type = TREE_TYPE (*expr_p);\n-\n-  *expr_p = build3 (COND_EXPR, type, *expr_p,\n-\t\t    fold_convert_loc (locus, type, boolean_true_node),\n-\t\t    fold_convert_loc (locus, type, boolean_false_node));\n-\n-  SET_EXPR_LOCATION (*expr_p, locus);\n-\n-  return GS_OK;\n-}\n-\n /* Gimplify an expression sequence.  This function gimplifies each\n    expression and rewrites the original expression with the last\n    expression of the sequence in GIMPLE form.\n@@ -6762,9 +6736,22 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \n \tcase TRUTH_ANDIF_EXPR:\n \tcase TRUTH_ORIF_EXPR:\n-\t  /* Pass the source location of the outer expression.  */\n-\t  ret = gimplify_boolean_expr (expr_p, saved_location);\n-\t  break;\n+\t  {\n+\t    /* Preserve the original type of the expression and the\n+\t       source location of the outer expression.  */\n+\t    tree org_type = TREE_TYPE (*expr_p);\n+\t    *expr_p = gimple_boolify (*expr_p);\n+\t    *expr_p = build3_loc (saved_location, COND_EXPR,\n+\t\t\t\t  org_type, *expr_p,\n+\t\t\t\t  fold_convert_loc\n+\t\t\t\t    (saved_location,\n+\t\t\t\t     org_type, boolean_true_node),\n+\t\t\t\t  fold_convert_loc\n+\t\t\t\t    (saved_location,\n+\t\t\t\t     org_type, boolean_false_node));\n+\t    ret = GS_OK;\n+\t    break;\n+\t  }\n \n \tcase TRUTH_NOT_EXPR:\n \t  if (TREE_CODE (TREE_TYPE (*expr_p)) != BOOLEAN_TYPE)\n@@ -7203,6 +7190,23 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \tcase TRUTH_AND_EXPR:\n \tcase TRUTH_OR_EXPR:\n \tcase TRUTH_XOR_EXPR:\n+\t  {\n+\t    tree org_type = TREE_TYPE (*expr_p);\n+\t    \n+\t    *expr_p = gimple_boolify (*expr_p);\n+\n+\t    /* This shouldn't happen, but due fold-const (and here especially\n+\t       fold_truth_not_expr) happily uses operand type and doesn't\n+\t       automatically uses boolean_type as result, we need to keep\n+\t       orignal type.  */\n+\t    if (TREE_CODE (org_type) != BOOLEAN_TYPE)\n+\t      {\n+\t\t*expr_p = fold_convert (org_type, *expr_p);\n+\t\tret = GS_OK;\n+\t\tbreak;\n+\t      }\n+\t  }\n+\t  \n \t  /* Classified as tcc_expression.  */\n \t  goto expr_2;\n "}, {"sha": "aa73f5ea3a5c9c681b4d44c1191776d18534eb09", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d15f620aa4e68f6298491d52ca8cc8d496457a6/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d15f620aa4e68f6298491d52ca8cc8d496457a6/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=1d15f620aa4e68f6298491d52ca8cc8d496457a6", "patch": "@@ -3541,10 +3541,10 @@ verify_gimple_assign_binary (gimple stmt)\n     case TRUTH_OR_EXPR:\n     case TRUTH_XOR_EXPR:\n       {\n-\t/* We allow any kind of integral typed argument and result.  */\n-\tif (!INTEGRAL_TYPE_P (rhs1_type)\n-\t    || !INTEGRAL_TYPE_P (rhs2_type)\n-\t    || !INTEGRAL_TYPE_P (lhs_type))\n+\t/* We allow only boolean typed or compatible argument and result.  */\n+\tif (!useless_type_conversion_p (boolean_type_node,  rhs1_type)\n+\t    || !useless_type_conversion_p (boolean_type_node,  rhs2_type)\n+\t    || !useless_type_conversion_p (boolean_type_node,  lhs_type))\n \t  {\n \t    error (\"type mismatch in binary truth expression\");\n \t    debug_generic_expr (lhs_type);"}]}