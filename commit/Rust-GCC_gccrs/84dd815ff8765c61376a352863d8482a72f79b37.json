{"sha": "84dd815ff8765c61376a352863d8482a72f79b37", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODRkZDgxNWZmODc2NWM2MTM3NmEzNTI4NjNkODQ4MmE3MmY3OWIzNw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2017-10-10T18:04:02Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2017-10-10T18:04:02Z"}, "message": "More delayed lambda capture fixes.\n\n\t* call.c (add_function_candidate): Use build_address.\n\t(build_op_call_1): Call mark_lvalue_use early.\n\t(build_over_call): Handle error from build_this.\n\t* constexpr.c (cxx_bind_parameters_in_call): Use build_address.\n\t(cxx_eval_increment_expression): Don't use rvalue().\n\t* cvt.c (convert_to_void): Use mark_discarded_use.\n\t* expr.c (mark_use): Handle PARM_DECL, NON_DEPENDENT_EXPR.  Fix\n\treference handling.  Don't copy the expression.\n\t(mark_discarded_use): New.\n\t* lambda.c (insert_capture_proxy): Add some sanity checking.\n\t(maybe_add_lambda_conv_op): Set cp_unevaluated_operand.\n\t* pt.c (register_local_specialization): Add sanity check.\n\t* semantics.c (process_outer_var_ref): Fix check for existing proxy.\n\t* typeck.c (cp_build_addr_expr_1): Handle error from\n\tmark_lvalue_use.\n\t(cp_build_modify_expr): Call mark_lvalue_use_nonread, handle error\n\tfrom rvalue.\n\n\tHandle generic lambda capture in dependent expressions.\n\t* lambda.c (need_generic_capture, dependent_capture_r)\n\t(do_dependent_capture): New.\n\t* pt.c (processing_nonlambda_template): Use need_generic_capture.\n\t* semantics.c (maybe_cleanup_point_expr)\n\t(maybe_cleanup_point_expr_void, finish_goto_stmt)\n\t(maybe_convert_cond): Call do_dependent_capture.\n\t* typeck.c (build_static_cast): Remove dependent capture handling.\n\nFrom-SVN: r253601", "tree": {"sha": "a1d29341c64d9d46baace208102db49665b10367", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a1d29341c64d9d46baace208102db49665b10367"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84dd815ff8765c61376a352863d8482a72f79b37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84dd815ff8765c61376a352863d8482a72f79b37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84dd815ff8765c61376a352863d8482a72f79b37", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84dd815ff8765c61376a352863d8482a72f79b37/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e1bea3412a75a300c3866dcf9559c2b796f5b430", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1bea3412a75a300c3866dcf9559c2b796f5b430", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1bea3412a75a300c3866dcf9559c2b796f5b430"}], "stats": {"total": 374, "additions": 300, "deletions": 74}, "files": [{"sha": "0baf3c73356eb30a7975df15ddb887725de053ed", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84dd815ff8765c61376a352863d8482a72f79b37/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84dd815ff8765c61376a352863d8482a72f79b37/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=84dd815ff8765c61376a352863d8482a72f79b37", "patch": "@@ -1,5 +1,33 @@\n 2017-10-10  Jason Merrill  <jason@redhat.com>\n \n+\tMore delayed lambda capture fixes.\n+\t* call.c (add_function_candidate): Use build_address.\n+\t(build_op_call_1): Call mark_lvalue_use early.\n+\t(build_over_call): Handle error from build_this.\n+\t* constexpr.c (cxx_bind_parameters_in_call): Use build_address.\n+\t(cxx_eval_increment_expression): Don't use rvalue().\n+\t* cvt.c (convert_to_void): Use mark_discarded_use.\n+\t* expr.c (mark_use): Handle PARM_DECL, NON_DEPENDENT_EXPR.  Fix\n+\treference handling.  Don't copy the expression.\n+\t(mark_discarded_use): New.\n+\t* lambda.c (insert_capture_proxy): Add some sanity checking.\n+\t(maybe_add_lambda_conv_op): Set cp_unevaluated_operand.\n+\t* pt.c (register_local_specialization): Add sanity check.\n+\t* semantics.c (process_outer_var_ref): Fix check for existing proxy.\n+\t* typeck.c (cp_build_addr_expr_1): Handle error from\n+\tmark_lvalue_use.\n+\t(cp_build_modify_expr): Call mark_lvalue_use_nonread, handle error\n+\tfrom rvalue.\n+\n+\tHandle generic lambda capture in dependent expressions.\n+\t* lambda.c (need_generic_capture, dependent_capture_r)\n+\t(do_dependent_capture): New.\n+\t* pt.c (processing_nonlambda_template): Use need_generic_capture.\n+\t* semantics.c (maybe_cleanup_point_expr)\n+\t(maybe_cleanup_point_expr_void, finish_goto_stmt)\n+\t(maybe_convert_cond): Call do_dependent_capture.\n+\t* typeck.c (build_static_cast): Remove dependent capture handling.\n+\n \t* typeck.c (condition_conversion): Assert !processing_template_decl.\n \t* semantics.c (finish_omp_clauses): Don't\n \tfold_build_cleanup_point_expr if processing_template_decl."}, {"sha": "13269024547b04040a4f004f8f05f696fe10752d", "filename": "gcc/cp/call.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84dd815ff8765c61376a352863d8482a72f79b37/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84dd815ff8765c61376a352863d8482a72f79b37/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=84dd815ff8765c61376a352863d8482a72f79b37", "patch": "@@ -2160,7 +2160,10 @@ add_function_candidate (struct z_candidate **candidates,\n \t      else\n \t\t{\n \t\t  parmtype = build_pointer_type (parmtype);\n-\t\t  arg = build_this (arg);\n+\t\t  /* We don't use build_this here because we don't want to\n+\t\t     capture the object argument until we've chosen a\n+\t\t     non-static member function.  */\n+\t\t  arg = build_address (arg);\n \t\t  argtype = lvalue_type (arg);\n \t\t}\n \t    }\n@@ -4446,14 +4449,17 @@ build_op_call_1 (tree obj, vec<tree, va_gc> **args, tsubst_flags_t complain)\n {\n   struct z_candidate *candidates = 0, *cand;\n   tree fns, convs, first_mem_arg = NULL_TREE;\n-  tree type = TREE_TYPE (obj);\n   bool any_viable_p;\n   tree result = NULL_TREE;\n   void *p;\n \n+  obj = mark_lvalue_use (obj);\n+\n   if (error_operand_p (obj))\n     return error_mark_node;\n \n+  tree type = TREE_TYPE (obj);\n+\n   obj = prep_operand (obj);\n \n   if (TYPE_PTRMEMFUNC_P (type))\n@@ -7772,6 +7778,9 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n       tree converted_arg;\n       tree base_binfo;\n \n+      if (arg == error_mark_node)\n+\treturn error_mark_node;\n+\n       if (convs[i]->bad_p)\n \t{\n \t  if (complain & tf_error)"}, {"sha": "59192829d7125641643408ffe3dc4c2fbf407fba", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84dd815ff8765c61376a352863d8482a72f79b37/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84dd815ff8765c61376a352863d8482a72f79b37/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=84dd815ff8765c61376a352863d8482a72f79b37", "patch": "@@ -1268,7 +1268,10 @@ cxx_bind_parameters_in_call (const constexpr_ctx *ctx, tree t,\n \t  && is_dummy_object (x))\n \t{\n \t  x = ctx->object;\n-\t  x = cp_build_addr_expr (x, tf_warning_or_error);\n+\t  /* We don't use cp_build_addr_expr here because we don't want to\n+\t     capture the object argument until we've chosen a non-static member\n+\t     function.  */\n+\t  x = build_address (x);\n \t}\n       bool lval = false;\n       arg = cxx_eval_constant_expression (ctx, x, lval,\n@@ -3642,9 +3645,9 @@ cxx_eval_increment_expression (const constexpr_ctx *ctx, tree t,\n \t\t\t\t     non_constant_p, overflow_p);\n \n   /* The operand as an rvalue.  */\n-  tree val = rvalue (op);\n-  val = cxx_eval_constant_expression (ctx, val, false,\n-\t\t\t\t      non_constant_p, overflow_p);\n+  tree val\n+    = cxx_eval_constant_expression (ctx, op, false,\n+\t\t\t\t    non_constant_p, overflow_p);\n   /* Don't VERIFY_CONSTANT if this might be dealing with a pointer to\n      a local array in a constexpr function.  */\n   bool ptr = POINTER_TYPE_P (TREE_TYPE (val));"}, {"sha": "1c008dbb3b35a531c084c5ea865a96d15a5e4cea", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84dd815ff8765c61376a352863d8482a72f79b37/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84dd815ff8765c61376a352863d8482a72f79b37/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=84dd815ff8765c61376a352863d8482a72f79b37", "patch": "@@ -6270,6 +6270,7 @@ extern tree mark_rvalue_use\t\t\t(tree,\n extern tree mark_lvalue_use\t\t\t(tree);\n extern tree mark_lvalue_use_nonread\t\t(tree);\n extern tree mark_type_use\t\t\t(tree);\n+extern tree mark_discarded_use\t\t\t(tree);\n extern void mark_exp_read\t\t\t(tree);\n \n /* friend.c */\n@@ -6432,6 +6433,7 @@ extern tree lookup_template_variable\t\t(tree, tree);\n extern int uses_template_parms\t\t\t(tree);\n extern bool uses_template_parms_level\t\t(tree, int);\n extern bool in_template_function\t\t(void);\n+extern bool need_generic_capture\t\t(void);\n extern bool processing_nonlambda_template\t(void);\n extern tree instantiate_class_template\t\t(tree);\n extern tree instantiate_template\t\t(tree, tree, tsubst_flags_t);\n@@ -6833,6 +6835,7 @@ extern tree current_nonlambda_function\t\t(void);\n extern tree nonlambda_method_basetype\t\t(void);\n extern tree current_nonlambda_scope\t\t(void);\n extern bool generic_lambda_fn_p\t\t\t(tree);\n+extern tree do_dependent_capture\t\t(tree, bool = false);\n extern bool lambda_fn_in_template_p\t\t(tree);\n extern void maybe_add_lambda_conv_op            (tree);\n extern bool is_lambda_ignored_entity            (tree);"}, {"sha": "c0d0a6005628d96302587c1ff94cd33c23365faf", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84dd815ff8765c61376a352863d8482a72f79b37/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84dd815ff8765c61376a352863d8482a72f79b37/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=84dd815ff8765c61376a352863d8482a72f79b37", "patch": "@@ -1055,24 +1055,10 @@ convert_to_void (tree expr, impl_conv_void implicit, tsubst_flags_t complain)\n       || TREE_TYPE (expr) == error_mark_node)\n     return error_mark_node;\n \n+  expr = mark_discarded_use (expr);\n   if (implicit == ICV_CAST)\n+    /* An explicit cast to void avoids all -Wunused-but-set* warnings.  */\n     mark_exp_read (expr);\n-  else\n-    {\n-      tree exprv = expr;\n-\n-      while (TREE_CODE (exprv) == COMPOUND_EXPR)\n-\texprv = TREE_OPERAND (exprv, 1);\n-      if (DECL_P (exprv)\n-\t  || handled_component_p (exprv)\n-\t  || INDIRECT_REF_P (exprv))\n-\t/* Expr is not being 'used' here, otherwise we whould have\n-\t   called mark_{rl}value_use use here, which would have in turn\n-\t   called mark_exp_read.  Rather, we call mark_exp_read directly\n-\t   to avoid some warnings when\n-\t   -Wunused-but-set-{variable,parameter} is in effect.  */\n-\tmark_exp_read (exprv);\n-    }\n \n   if (!TREE_TYPE (expr))\n     return expr;"}, {"sha": "f251a9043d46ef5cdb99a4650d613f897e608576", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84dd815ff8765c61376a352863d8482a72f79b37/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84dd815ff8765c61376a352863d8482a72f79b37/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=84dd815ff8765c61376a352863d8482a72f79b37", "patch": "@@ -6867,6 +6867,8 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t  DECL_INITIAL (decl) = NULL_TREE;\n \t}\n \n+      init = do_dependent_capture (init);\n+\n       /* Generally, initializers in templates are expanded when the\n \t template is instantiated.  But, if DECL is a variable constant\n \t then it can be used in future constant expressions, so its value"}, {"sha": "23e30cf789c08d00152ae93f2181b45d061af20f", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 60, "deletions": 18, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84dd815ff8765c61376a352863d8482a72f79b37/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84dd815ff8765c61376a352863d8482a72f79b37/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=84dd815ff8765c61376a352863d8482a72f79b37", "patch": "@@ -96,16 +96,21 @@ mark_use (tree expr, bool rvalue_p, bool read_p,\n {\n #define RECUR(t) mark_use ((t), rvalue_p, read_p, loc, reject_builtin)\n \n+  if (expr == NULL_TREE || expr == error_mark_node)\n+    return expr;\n+\n   if (reject_builtin && reject_gcc_builtin (expr, loc))\n     return error_mark_node;\n \n   if (read_p)\n     mark_exp_read (expr);\n \n+  tree oexpr = expr;\n   bool recurse_op[3] = { false, false, false };\n   switch (TREE_CODE (expr))\n     {\n     case VAR_DECL:\n+    case PARM_DECL:\n       if (outer_automatic_var_p (expr)\n \t  && decl_constant_var_p (expr))\n \t{\n@@ -119,10 +124,13 @@ mark_use (tree expr, bool rvalue_p, bool read_p,\n \t\t}\n \t    }\n \t  expr = process_outer_var_ref (expr, tf_warning_or_error, true);\n-\t  expr = convert_from_reference (expr);\n+\t  if (!(TREE_TYPE (oexpr)\n+\t\t&& TREE_CODE (TREE_TYPE (oexpr)) == REFERENCE_TYPE))\n+\t    expr = convert_from_reference (expr);\n \t}\n       break;\n     case COMPONENT_REF:\n+    case NON_DEPENDENT_EXPR:\n       recurse_op[0] = true;\n       break;\n     case COMPOUND_EXPR:\n@@ -140,35 +148,23 @@ mark_use (tree expr, bool rvalue_p, bool read_p,\n \t  tree ref = TREE_OPERAND (expr, 0);\n \t  tree r = mark_rvalue_use (ref, loc, reject_builtin);\n \t  if (r != ref)\n-\t    {\n-\t      expr = copy_node (expr);\n-\t      TREE_OPERAND (expr, 0) = r;\n-\t    }\n+\t    expr = convert_from_reference (r);\n \t}\n       break;\n     default:\n       break;\n     }\n \n-  bool changed = false;\n-  tree ops[3];\n   for (int i = 0; i < 3; ++i)\n     if (recurse_op[i])\n       {\n \ttree op = TREE_OPERAND (expr, i);\n-\tops[i] = RECUR (op);\n-\tif (ops[i] != op)\n-\t  changed = true;\n+\top = RECUR (op);\n+\tif (op == error_mark_node)\n+\t  return error_mark_node;\n+\tTREE_OPERAND (expr, i) = op;\n       }\n \n-  if (changed)\n-    {\n-      expr = copy_node (expr);\n-      for (int i = 0; i < 3; ++i)\n-\tif (recurse_op[i])\n-\t  TREE_OPERAND (expr, i) = ops[i];\n-    }\n-\n   return expr;\n #undef RECUR\n }\n@@ -187,6 +183,52 @@ mark_rvalue_use (tree e,\n   return mark_use (e, true, true, loc, reject_builtin);\n }\n \n+/* Called when expr appears as a discarded-value expression.  */\n+\n+tree\n+mark_discarded_use (tree expr)\n+{\n+  /* The lvalue-to-rvalue conversion (7.1) is applied if and only if the\n+     expression is a glvalue of volatile-qualified type and it is one of the\n+     following:\n+     * ( expression ), where expression is one of these expressions,\n+     * id-expression (8.1.4),\n+     * subscripting (8.2.1),\n+     * class member access (8.2.5),\n+     * indirection (8.3.1),\n+     * pointer-to-member operation (8.5),\n+     * conditional expression (8.16) where both the second and the third\n+       operands are one of these expressions, or\n+     * comma expression (8.19) where the right operand is one of these\n+       expressions.  */\n+  if (expr == NULL_TREE)\n+    return expr;\n+\n+  switch (TREE_CODE (expr))\n+    {\n+    case COND_EXPR:\n+      TREE_OPERAND (expr, 2) = mark_discarded_use (TREE_OPERAND (expr, 2));\n+      gcc_fallthrough ();\n+    case COMPOUND_EXPR:\n+      TREE_OPERAND (expr, 1) = mark_discarded_use (TREE_OPERAND (expr, 1));\n+      return expr;\n+\n+    case COMPONENT_REF:\n+    case ARRAY_REF:\n+    case INDIRECT_REF:\n+    case MEMBER_REF:\n+      break;\n+    default:\n+      if (DECL_P (expr))\n+\tbreak;\n+      else\n+\treturn expr;\n+    }\n+\n+  /* Like mark_rvalue_use, but don't reject built-ins.  */\n+  return mark_use (expr, true, true, input_location, false);\n+}\n+\n /* Called whenever an expression is used in an lvalue context.  */\n \n tree"}, {"sha": "76f2f29578fe14b9ec1e291ead7d0fd80e50b917", "filename": "gcc/cp/lambda.c", "status": "modified", "additions": 129, "deletions": 1, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84dd815ff8765c61376a352863d8482a72f79b37/gcc%2Fcp%2Flambda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84dd815ff8765c61376a352863d8482a72f79b37/gcc%2Fcp%2Flambda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.c?ref=84dd815ff8765c61376a352863d8482a72f79b37", "patch": "@@ -297,7 +297,17 @@ void\n insert_capture_proxy (tree var)\n {\n   if (is_normal_capture_proxy (var))\n-    register_local_specialization (var, DECL_CAPTURED_VARIABLE (var));\n+    {\n+      tree cap = DECL_CAPTURED_VARIABLE (var);\n+      if (CHECKING_P)\n+\t{\n+\t  gcc_assert (!is_normal_capture_proxy (cap));\n+\t  tree old = retrieve_local_specialization (cap);\n+\t  if (old)\n+\t    gcc_assert (DECL_CONTEXT (old) != DECL_CONTEXT (var));\n+\t}\n+      register_local_specialization (var, cap);\n+    }\n \n   /* Put the capture proxy in the extra body block so that it won't clash\n      with a later local variable.  */\n@@ -977,6 +987,121 @@ generic_lambda_fn_p (tree callop)\n \t  && PRIMARY_TEMPLATE_P (DECL_TI_TEMPLATE (callop)));\n }\n \n+/* Returns true iff we need to consider default capture for an enclosing\n+   generic lambda.  */\n+\n+bool\n+need_generic_capture (void)\n+{\n+  if (!processing_template_decl)\n+    return false;\n+\n+  tree outer_closure = NULL_TREE;\n+  for (tree t = current_class_type; t;\n+       t = decl_type_context (TYPE_MAIN_DECL (t)))\n+    {\n+      tree lam = CLASSTYPE_LAMBDA_EXPR (t);\n+      if (!lam || LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lam) == CPLD_NONE)\n+\t/* No default capture.  */\n+\tbreak;\n+      outer_closure = t;\n+    }\n+\n+  if (!outer_closure)\n+    /* No lambda.  */\n+    return false;\n+  else if (dependent_type_p (outer_closure))\n+    /* The enclosing context isn't instantiated.  */\n+    return false;\n+  else\n+    return true;\n+}\n+\n+/* A lambda-expression...is said to implicitly capture the entity...if the\n+   compound-statement...names the entity in a potentially-evaluated\n+   expression where the enclosing full-expression depends on a generic lambda\n+   parameter declared within the reaching scope of the lambda-expression.  */\n+\n+static tree\n+dependent_capture_r (tree *tp, int *walk_subtrees, void *data)\n+{\n+  hash_set<tree> *pset = (hash_set<tree> *)data;\n+\n+  if (TYPE_P (*tp))\n+    *walk_subtrees = 0;\n+\n+  if (outer_automatic_var_p (*tp))\n+    {\n+      tree t = process_outer_var_ref (*tp, tf_warning_or_error, /*force*/true);\n+      if (t != *tp\n+\t  && TREE_CODE (TREE_TYPE (t)) == REFERENCE_TYPE\n+\t  && TREE_CODE (TREE_TYPE (*tp)) != REFERENCE_TYPE)\n+\tt = convert_from_reference (t);\n+      *tp = t;\n+    }\n+\n+  if (pset->add (*tp))\n+    *walk_subtrees = 0;\n+\n+  switch (TREE_CODE (*tp))\n+    {\n+      /* Don't walk into unevaluated context or another lambda.  */\n+    case SIZEOF_EXPR:\n+    case ALIGNOF_EXPR:\n+    case TYPEID_EXPR:\n+    case NOEXCEPT_EXPR:\n+    case LAMBDA_EXPR:\n+      *walk_subtrees = 0;\n+      break;\n+\n+      /* Don't walk into statements whose subexpressions we already\n+\t handled.  */\n+    case TRY_BLOCK:\n+    case EH_SPEC_BLOCK:\n+    case HANDLER:\n+    case IF_STMT:\n+    case FOR_STMT:\n+    case RANGE_FOR_STMT:\n+    case WHILE_STMT:\n+    case DO_STMT:\n+    case SWITCH_STMT:\n+    case STATEMENT_LIST:\n+    case RETURN_EXPR:\n+      *walk_subtrees = 0;\n+      break;\n+\n+    case DECL_EXPR:\n+      {\n+\ttree decl = DECL_EXPR_DECL (*tp);\n+\tif (VAR_P (decl))\n+\t  {\n+\t    /* walk_tree_1 won't step in here.  */\n+\t    cp_walk_tree (&DECL_INITIAL (decl),\n+\t\t\t  dependent_capture_r, &pset, NULL);\n+\t    *walk_subtrees = 0;\n+\t  }\n+      }\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+tree\n+do_dependent_capture (tree expr, bool force)\n+{\n+  if (!need_generic_capture ()\n+      || (!force && !instantiation_dependent_expression_p (expr)))\n+    return expr;\n+\n+  hash_set<tree> pset;\n+  cp_walk_tree (&expr, dependent_capture_r, &pset, NULL);\n+  return expr;\n+}\n+\n /* If the closure TYPE has a static op(), also add a conversion to function\n    pointer.  */\n \n@@ -1073,7 +1198,10 @@ maybe_add_lambda_conv_op (tree type)\n \n \tif (generic_lambda_p)\n \t  {\n+\t    /* Avoid capturing variables in this context.  */\n+\t    ++cp_unevaluated_operand;\n \t    tree a = forward_parm (tgt);\n+\t    --cp_unevaluated_operand;\n \n \t    CALL_EXPR_ARG (call, ix) = a;\n \t    if (decltype_call)"}, {"sha": "142a090cbab55fa4bfc616ee17a39acfe9101bab", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84dd815ff8765c61376a352863d8482a72f79b37/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84dd815ff8765c61376a352863d8482a72f79b37/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=84dd815ff8765c61376a352863d8482a72f79b37", "patch": "@@ -11873,6 +11873,8 @@ cp_convert_range_for (tree statement, tree range_decl, tree range_expr,\n   tree iter_type, begin_expr, end_expr;\n   tree condition, expression;\n \n+  range_expr = mark_lvalue_use (range_expr);\n+\n   if (range_decl == error_mark_node || range_expr == error_mark_node)\n     /* If an error happened previously do nothing or else a lot of\n        unhelpful errors would be issued.  */"}, {"sha": "ba52f3b57a62dc6970f5c732939ca0dbe5dcba3e", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84dd815ff8765c61376a352863d8482a72f79b37/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84dd815ff8765c61376a352863d8482a72f79b37/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=84dd815ff8765c61376a352863d8482a72f79b37", "patch": "@@ -1895,6 +1895,7 @@ reregister_specialization (tree spec, tree tinfo, tree new_spec)\n void\n register_local_specialization (tree spec, tree tmpl)\n {\n+  gcc_assert (tmpl != spec);\n   local_specializations->put (tmpl, spec);\n }\n \n@@ -9494,30 +9495,14 @@ in_template_function (void)\n   return ret;\n }\n \n-/* Returns true iff we are currently within a template other than a generic\n-   lambda.  We test this by finding the outermost closure type and checking\n-   whether it is dependent.  */\n+/* Returns true iff we are currently within a template other than a\n+   default-capturing generic lambda, so we don't need to worry about semantic\n+   processing.  */\n \n bool\n processing_nonlambda_template (void)\n {\n-  if (!processing_template_decl)\n-    return false;\n-\n-  tree outer_closure = NULL_TREE;\n-  for (tree t = current_class_type; t;\n-       t = decl_type_context (TYPE_MAIN_DECL (t)))\n-    {\n-      if (LAMBDA_TYPE_P (t))\n-\touter_closure = t;\n-      else\n-\tbreak;\n-    }\n-\n-  if (outer_closure)\n-    return dependent_type_p (outer_closure);\n-  else\n-    return true;\n+  return processing_template_decl && !need_generic_capture ();\n }\n \n /* Returns true if T depends on any template parameter with level LEVEL.  */"}, {"sha": "a512664e3966fd9186175dc129c3d5dcd3955c82", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84dd815ff8765c61376a352863d8482a72f79b37/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84dd815ff8765c61376a352863d8482a72f79b37/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=84dd815ff8765c61376a352863d8482a72f79b37", "patch": "@@ -410,6 +410,8 @@ maybe_cleanup_point_expr (tree expr)\n {\n   if (!processing_template_decl && stmts_are_full_exprs_p ())\n     expr = fold_build_cleanup_point_expr (TREE_TYPE (expr), expr);\n+  else\n+    expr = do_dependent_capture (expr);\n   return expr;\n }\n \n@@ -423,6 +425,8 @@ maybe_cleanup_point_expr_void (tree expr)\n {\n   if (!processing_template_decl && stmts_are_full_exprs_p ())\n     expr = fold_build_cleanup_point_expr (void_type_node, expr);\n+  else\n+    expr = do_dependent_capture (expr);\n   return expr;\n }\n \n@@ -629,6 +633,8 @@ finish_goto_stmt (tree destination)\n \t    = fold_build_cleanup_point_expr (TREE_TYPE (destination),\n \t\t\t\t\t     destination);\n \t}\n+      else\n+\tdestination = do_dependent_capture (destination);\n     }\n \n   check_goto (destination);\n@@ -650,7 +656,7 @@ maybe_convert_cond (tree cond)\n \n   /* Wait until we instantiate templates before doing conversion.  */\n   if (processing_template_decl)\n-    return cond;\n+    return do_dependent_capture (cond);\n \n   if (warn_sequence_point)\n     verify_sequence_points (cond);\n@@ -3314,8 +3320,12 @@ process_outer_var_ref (tree decl, tsubst_flags_t complain, bool force_use)\n   if (containing_function && LAMBDA_FUNCTION_P (containing_function))\n     {\n       /* Check whether we've already built a proxy.  */\n-      tree d = retrieve_local_specialization (decl);\n-      if (d && is_capture_proxy (d))\n+      tree var = decl;\n+      while (is_normal_capture_proxy (var))\n+\tvar = DECL_CAPTURED_VARIABLE (var);\n+      tree d = retrieve_local_specialization (var);\n+\n+      if (d && d != decl && is_capture_proxy (d))\n \t{\n \t  if (DECL_CONTEXT (d) == containing_function)\n \t    /* We already have an inner proxy.  */"}, {"sha": "08b2ae555e635fce9695076abd9302b7284e683b", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84dd815ff8765c61376a352863d8482a72f79b37/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84dd815ff8765c61376a352863d8482a72f79b37/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=84dd815ff8765c61376a352863d8482a72f79b37", "patch": "@@ -5654,6 +5654,9 @@ cp_build_addr_expr_1 (tree arg, bool strict_lvalue, tsubst_flags_t complain)\n     return error_mark_node;\n \n   arg = mark_lvalue_use (arg);\n+  if (error_operand_p (arg))\n+    return error_mark_node;\n+\n   argtype = lvalue_type (arg);\n \n   gcc_assert (!(identifier_p (arg) && IDENTIFIER_ANY_OP_P (arg)));\n@@ -7059,11 +7062,7 @@ build_static_cast (tree type, tree oexpr, tsubst_flags_t complain)\n   if (dependent)\n     {\n     tmpl:\n-      expr = oexpr;\n-      if (dependent)\n-\t/* Handle generic lambda capture.  */\n-\texpr = mark_lvalue_use (expr);\n-      expr = build_min (STATIC_CAST_EXPR, type, expr);\n+      expr = build_min (STATIC_CAST_EXPR, type, oexpr);\n       /* We don't know if it will or will not have side effects.  */\n       TREE_SIDE_EFFECTS (expr) = 1;\n       return convert_from_reference (expr);\n@@ -7702,6 +7701,8 @@ tree\n cp_build_modify_expr (location_t loc, tree lhs, enum tree_code modifycode,\n \t\t      tree rhs, tsubst_flags_t complain)\n {\n+  lhs = mark_lvalue_use_nonread (lhs);\n+\n   tree result = NULL_TREE;\n   tree newrhs = rhs;\n   tree lhstype = TREE_TYPE (lhs);\n@@ -7924,6 +7925,8 @@ cp_build_modify_expr (location_t loc, tree lhs, enum tree_code modifycode,\n \t     operator. -- end note ]  */\n \t  lhs = cp_stabilize_reference (lhs);\n \t  rhs = rvalue (rhs);\n+\t  if (rhs == error_mark_node)\n+\t    return error_mark_node;\n \t  rhs = stabilize_expr (rhs, &init);\n \t  newrhs = cp_build_binary_op (loc, modifycode, lhs, rhs, complain);\n \t  if (newrhs == error_mark_node)\n@@ -9109,7 +9112,7 @@ check_return_expr (tree retval, bool *no_warning)\n     dependent:\n       /* We should not have changed the return value.  */\n       gcc_assert (retval == saved_retval);\n-      return retval;\n+      return do_dependent_capture (retval, /*force*/true);\n     }\n \n   /* The fabled Named Return Value optimization, as per [class.copy]/15:"}, {"sha": "115d800bb35e41c34e79d749a049df6d6b43e91f", "filename": "gcc/testsuite/g++.dg/cpp0x/error1.C", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84dd815ff8765c61376a352863d8482a72f79b37/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ferror1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84dd815ff8765c61376a352863d8482a72f79b37/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ferror1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ferror1.C?ref=84dd815ff8765c61376a352863d8482a72f79b37", "patch": "@@ -1,10 +1,17 @@\n // PR c++/34395\n // { dg-do compile { target c++11 } }\n \n-template<int... N> void foo (int... x[N])\t// { dg-message \"int \\\\\\[N\\\\\\]\\\\.\\\\.\\\\. x\" }\n+void f(...);\n+template<int... N> void foo (int... x[N])\t// { dg-message \"declared here\" }\n {\n   struct A\n   {\n-    A () { x; }\t\t// { dg-error \"use of parameter from containing function\" }\n+    A () { f(x...); }\t\t// { dg-error \"use of parameter from containing function\" }\n   };\n }\n+\n+int main()\n+{\n+  int ar[4];\n+  foo<4>(ar);\n+}"}, {"sha": "91e3804cb0bf2ffc19d9f959565d8c80c2bfab86", "filename": "gcc/testsuite/g++.dg/cpp1y/lambda-generic-dep2.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84dd815ff8765c61376a352863d8482a72f79b37/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-generic-dep2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84dd815ff8765c61376a352863d8482a72f79b37/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-generic-dep2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-generic-dep2.C?ref=84dd815ff8765c61376a352863d8482a72f79b37", "patch": "@@ -0,0 +1,18 @@\n+// { dg-do compile { target c++14 } }\n+\n+struct A { void operator()(int) const {} };\n+\n+template <class T>\n+void f()\n+{\n+  constexpr A a {};\n+\n+  [=](auto b) {\n+    a(b);\n+  }(42);\n+}\n+\n+int main()\n+{\n+  f<int>();\n+}"}, {"sha": "88b7d1a05a174b5fab2cd4c78960c4241f89372f", "filename": "gcc/testsuite/g++.dg/cpp1y/lambda-generic-ice5.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84dd815ff8765c61376a352863d8482a72f79b37/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-generic-ice5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84dd815ff8765c61376a352863d8482a72f79b37/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-generic-ice5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-generic-ice5.C?ref=84dd815ff8765c61376a352863d8482a72f79b37", "patch": "@@ -12,7 +12,7 @@ using Void = void;\n \n template<typename F,typename A>\n auto\n-bar(F f, A a) -> decltype( ( f(a) , 0 ) ) // { dg-error \"no match\" }\n+bar(F f, A a) -> decltype( ( f(a) , 0 ) ) // { dg-message \"\" }\n { return {}; }\n \n "}, {"sha": "9bcabc6009bb4f4ff489f8f5046f93240564344a", "filename": "gcc/testsuite/g++.dg/template/crash108.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84dd815ff8765c61376a352863d8482a72f79b37/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash108.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84dd815ff8765c61376a352863d8482a72f79b37/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash108.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash108.C?ref=84dd815ff8765c61376a352863d8482a72f79b37", "patch": "@@ -1,5 +1,5 @@\n // PR c++/50861\n \n-template<class T> struct A {A(int b=k(0));}; // { dg-error \"parameter|arguments\" }\n+template<class T> struct A {A(int b=k(0));}; // { dg-error \"parameter|argument\" }\n void f(int k){A<int> a;} // // { dg-message \"declared\" }\n // { dg-message \"note\" \"note\" { target *-*-* } 3 }"}]}