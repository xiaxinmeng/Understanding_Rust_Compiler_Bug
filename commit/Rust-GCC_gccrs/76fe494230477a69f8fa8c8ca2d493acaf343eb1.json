{"sha": "76fe494230477a69f8fa8c8ca2d493acaf343eb1", "node_id": "C_kwDOANBUbNoAKDc2ZmU0OTQyMzA0NzdhNjlmOGZhOGM4Y2EyZDQ5M2FjYWYzNDNlYjE", "commit": {"author": {"name": "Andrew Pinski", "email": "apinski@marvell.com", "date": "2021-11-17T02:45:22Z"}, "committer": {"name": "Andrew Pinski", "email": "apinski@marvell.com", "date": "2022-01-18T10:35:48Z"}, "message": "Fix tree-optimization/101941: IPA splitting out function with error attribute\n\nThe Linux kernel started to fail compile when the jump threader was improved\n(r12-2591-g2e96b5f14e4025691). This failure was due to the IPA splitting code\ndecided now to split off the basic block which contained two functions,\none of those functions included the error attribute on them.  This patch fixes\nthe problem by disallowing basic blocks from being split which contain functions\nthat have either the error or warning attribute on them.\n\nThe two new testcases are to make sure we still split the function for other\nplaces if we reject the one case.\n\nCommitted as approved after Bootstrapped and tested on x86_64-linux-gnu with no regressions.\n\n\tPR tree-optimization/101941\n\ngcc/ChangeLog:\n\n\t* ipa-split.cc (visit_bb): Disallow function calls where\n\tthe function has either error or warning attribute.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.c-torture/compile/pr101941-1.c: New test.\n\t* gcc.dg/tree-ssa/pr101941-1.c: New test.", "tree": {"sha": "9c56a55724928ee67880ac8ea95951af26b21604", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c56a55724928ee67880ac8ea95951af26b21604"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76fe494230477a69f8fa8c8ca2d493acaf343eb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76fe494230477a69f8fa8c8ca2d493acaf343eb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76fe494230477a69f8fa8c8ca2d493acaf343eb1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76fe494230477a69f8fa8c8ca2d493acaf343eb1/comments", "author": {"login": "apinski-cavium", "id": 6335315, "node_id": "MDQ6VXNlcjYzMzUzMTU=", "avatar_url": "https://avatars.githubusercontent.com/u/6335315?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apinski-cavium", "html_url": "https://github.com/apinski-cavium", "followers_url": "https://api.github.com/users/apinski-cavium/followers", "following_url": "https://api.github.com/users/apinski-cavium/following{/other_user}", "gists_url": "https://api.github.com/users/apinski-cavium/gists{/gist_id}", "starred_url": "https://api.github.com/users/apinski-cavium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apinski-cavium/subscriptions", "organizations_url": "https://api.github.com/users/apinski-cavium/orgs", "repos_url": "https://api.github.com/users/apinski-cavium/repos", "events_url": "https://api.github.com/users/apinski-cavium/events{/privacy}", "received_events_url": "https://api.github.com/users/apinski-cavium/received_events", "type": "User", "site_admin": false}, "committer": {"login": "apinski-cavium", "id": 6335315, "node_id": "MDQ6VXNlcjYzMzUzMTU=", "avatar_url": "https://avatars.githubusercontent.com/u/6335315?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apinski-cavium", "html_url": "https://github.com/apinski-cavium", "followers_url": "https://api.github.com/users/apinski-cavium/followers", "following_url": "https://api.github.com/users/apinski-cavium/following{/other_user}", "gists_url": "https://api.github.com/users/apinski-cavium/gists{/gist_id}", "starred_url": "https://api.github.com/users/apinski-cavium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apinski-cavium/subscriptions", "organizations_url": "https://api.github.com/users/apinski-cavium/orgs", "repos_url": "https://api.github.com/users/apinski-cavium/repos", "events_url": "https://api.github.com/users/apinski-cavium/events{/privacy}", "received_events_url": "https://api.github.com/users/apinski-cavium/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f6b62e0f0c99e421d07bf1847259744db22924b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f6b62e0f0c99e421d07bf1847259744db22924b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f6b62e0f0c99e421d07bf1847259744db22924b"}], "stats": {"total": 177, "additions": 149, "deletions": 28}, "files": [{"sha": "6ca45f3b745d42cf300dc1b3e48d98dd0fe56be0", "filename": "gcc/ipa-split.cc", "status": "modified", "additions": 46, "deletions": 28, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76fe494230477a69f8fa8c8ca2d493acaf343eb1/gcc%2Fipa-split.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76fe494230477a69f8fa8c8ca2d493acaf343eb1/gcc%2Fipa-split.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.cc?ref=76fe494230477a69f8fa8c8ca2d493acaf343eb1", "patch": "@@ -873,7 +873,6 @@ visit_bb (basic_block bb, basic_block return_bb,\n       gimple *stmt = gsi_stmt (bsi);\n       tree op;\n       ssa_op_iter iter;\n-      tree decl;\n \n       if (is_gimple_debug (stmt))\n \tcontinue;\n@@ -899,33 +898,52 @@ visit_bb (basic_block bb, basic_block return_bb,\n \t  can_split = false;\n \t}\n \n-      /* Check builtins that prevent splitting.  */\n-      if (gimple_code (stmt) == GIMPLE_CALL\n-\t  && (decl = gimple_call_fndecl (stmt)) != NULL_TREE\n-\t  && fndecl_built_in_p (decl, BUILT_IN_NORMAL))\n-\tswitch (DECL_FUNCTION_CODE (decl))\n-\t  {\n-\t  /* FIXME: once we will allow passing non-parm values to split part,\n-\t     we need to be sure to handle correct builtin_stack_save and\n-\t     builtin_stack_restore.  At the moment we are safe; there is no\n-\t     way to store builtin_stack_save result in non-SSA variable\n-\t     since all calls to those are compiler generated.  */\n-\t  case BUILT_IN_APPLY:\n-\t  case BUILT_IN_APPLY_ARGS:\n-\t  case BUILT_IN_VA_START:\n-\t    if (dump_file && (dump_flags & TDF_DETAILS))\n-\t      fprintf (dump_file,\n-\t\t       \"Cannot split: builtin_apply and va_start.\\n\");\n-\t    can_split = false;\n-\t    break;\n-\t  case BUILT_IN_EH_POINTER:\n-\t    if (dump_file && (dump_flags & TDF_DETAILS))\n-\t      fprintf (dump_file, \"Cannot split: builtin_eh_pointer.\\n\");\n-\t    can_split = false;\n-\t    break;\n-\t  default:\n-\t    break;\n-\t  }\n+      /* Check calls that would prevent splitting.  */\n+      if (gimple_code (stmt) == GIMPLE_CALL)\n+\t{\n+\t  if (tree decl = gimple_call_fndecl (stmt))\n+\t    {\n+\t      /* Check builtins that would prevent splitting.  */\n+\t      if (fndecl_built_in_p (decl, BUILT_IN_NORMAL))\n+\t\tswitch (DECL_FUNCTION_CODE (decl))\n+\t\t  {\n+\t\t  /* FIXME: once we will allow passing non-parm values to\n+\t\t     split part, we need to be sure to handle correct\n+\t\t     builtin_stack_save and builtin_stack_restore.  At the\n+\t\t     moment we are safe; there is no way to store\n+\t\t     builtin_stack_save result in non-SSA variable since all\n+\t\t     calls to those are compiler generated.  */\n+\t\t  case BUILT_IN_APPLY:\n+\t\t  case BUILT_IN_APPLY_ARGS:\n+\t\t  case BUILT_IN_VA_START:\n+\t\t    if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t      fprintf (dump_file,\n+\t\t\t       \"Cannot split: builtin_apply and va_start.\\n\");\n+\t\t    can_split = false;\n+\t\t    break;\n+\t\t  case BUILT_IN_EH_POINTER:\n+\t\t    if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t      fprintf (dump_file,\n+\t\t\t       \"Cannot split: builtin_eh_pointer.\\n\");\n+\t\t    can_split = false;\n+\t\t    break;\n+\t\t  default:\n+\t\t    break;\n+\t\t  }\n+\n+\t      /* Calls that function has either the warning or error\n+\t         attribute on it should not be split off into another\n+\t\t function.  */\n+\t      if (lookup_attribute (\"warning\", DECL_ATTRIBUTES (decl))\n+\t\t   || lookup_attribute (\"error\", DECL_ATTRIBUTES (decl)))\n+\t\t{\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    fprintf (dump_file,\n+\t\t\t     \"Cannot split: warning or error attribute.\\n\");\n+\t\t  can_split = false;\n+\t\t}\n+\t    }\n+\t}\n \n       FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_DEF)\n \tbitmap_set_bit (set_ssa_names, SSA_NAME_VERSION (op));"}, {"sha": "0481a3835a62b8c4f6b88b50d923da052b634287", "filename": "gcc/testsuite/gcc.c-torture/compile/pr101941-1.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76fe494230477a69f8fa8c8ca2d493acaf343eb1/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr101941-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76fe494230477a69f8fa8c8ca2d493acaf343eb1/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr101941-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr101941-1.c?ref=76fe494230477a69f8fa8c8ca2d493acaf343eb1", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-additional-options \"-fconserve-stack\" } */\n+\n+/* Check to make sure that if\n+   rfc4106_set_hash_subkey gets split,\n+   the error function does not gets split away\n+   from the if statement conditionalizing it. */\n+\n+struct crypto_aes_ctx {\n+  char key_dec[128];\n+};\n+\n+int rfc4106_set_hash_subkey_hash_subkey;\n+\n+void __write_overflow(void)__attribute__((__error__(\"\")));\n+void __write_overflow1(void);\n+void aes_encrypt(void*);\n+\n+void fortify_panic(const char*) __attribute__((__noreturn__)) ;\n+\n+char *rfc4106_set_hash_subkey(struct crypto_aes_ctx *ctx) {\n+  void *a = &ctx->key_dec[0];\n+  unsigned p_size =  __builtin_object_size(a, 0);\n+#ifdef __OPTIMIZE__\n+  if (p_size < 16) {\n+    __write_overflow1();\n+    fortify_panic(__func__);\n+  }\n+  if (p_size < 32) {\n+    __write_overflow();\n+    fortify_panic(__func__);\n+  }\n+#endif\n+  aes_encrypt(ctx);\n+  return ctx->key_dec;\n+}\n+\n+char *(*gg)(struct crypto_aes_ctx *) = rfc4106_set_hash_subkey;\n+\n+void a(void)\n+{\n+  struct crypto_aes_ctx ctx;\n+  rfc4106_set_hash_subkey(&ctx);\n+}\n+void b(void)\n+{\n+  struct crypto_aes_ctx ctx;\n+  ctx.key_dec[0] = 0;\n+  rfc4106_set_hash_subkey(&ctx);\n+}\n+"}, {"sha": "a1a342a253afce969b08f6162b72fd264e7eccfe", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr101941-1.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76fe494230477a69f8fa8c8ca2d493acaf343eb1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr101941-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76fe494230477a69f8fa8c8ca2d493acaf343eb1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr101941-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr101941-1.c?ref=76fe494230477a69f8fa8c8ca2d493acaf343eb1", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fconserve-stack -fdump-tree-optimized\" } */\n+/* Check to make sure that if\n+   rfc4106_set_hash_subkey gets split,\n+   the error function does not gets split away\n+   from the if statement conditionalizing it.\n+   Checking this via the scan tree also. */\n+struct crypto_aes_ctx {\n+  char key_dec[128];\n+};\n+\n+int rfc4106_set_hash_subkey_hash_subkey;\n+\n+void __write_overflow(void)__attribute__((__error__(\"\")));\n+void __write_overflow1(void);\n+void aes_encrypt(void*);\n+\n+void fortify_panic(const char*) __attribute__((__noreturn__)) ;\n+\n+char *rfc4106_set_hash_subkey(struct crypto_aes_ctx *ctx) {\n+  void *a = &ctx->key_dec[0];\n+  unsigned p_size =  __builtin_object_size(a, 0);\n+#ifdef __OPTIMIZE__\n+  if (p_size < 16) {\n+    __write_overflow1();\n+    fortify_panic(__func__);\n+  }\n+  if (p_size < 32) {\n+    __write_overflow();\n+    fortify_panic(__func__);\n+  }\n+#endif\n+  aes_encrypt(ctx);\n+  return ctx->key_dec;\n+}\n+\n+char *(*gg)(struct crypto_aes_ctx *) = rfc4106_set_hash_subkey;\n+\n+void a(void)\n+{\n+  struct crypto_aes_ctx ctx;\n+  rfc4106_set_hash_subkey(&ctx);\n+}\n+void b(void)\n+{\n+  struct crypto_aes_ctx ctx;\n+  ctx.key_dec[0] = 0;\n+  rfc4106_set_hash_subkey(&ctx);\n+}\n+\n+/* This testcase should still split out one of the above basic blocks dealing\n+   with __write_overflow. */\n+/* { dg-final { scan-tree-dump-times \"Function rfc4106_set_hash_subkey.part\" 1 \"optimized\" } } */"}]}