{"sha": "bae73ca5222381861a29202c88ce5cfe675b6753", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmFlNzNjYTUyMjIzODE4NjFhMjkyMDJjODhjZTVjZmU2NzViNjc1Mw==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-10-20T16:39:46Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-10-21T07:47:27Z"}, "message": "Move simplify_cond_using_ranges_2 to tree-vrp.c\n\nThis was slated to be moved last year, as its only use is in tree-vrp.c\n\nThere are no functional changes.  It's just a move and a rename.\n\ngcc/ChangeLog:\n\n\t* vr-values.h: Remove simplify_cond_using_ranges_2.\n\t(range_fits_type_p): New.\n\t* vr-values.c (range_fits_type_p): Remove static qualifier.\n\t(vrp_simplify_cond_using_ranges): Move...\n\t* tree-vrp.c (vrp_simplify_cond_using_ranges): ...to here.", "tree": {"sha": "88b106ddf5b7150b6c247bdb4af571ccadc407bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/88b106ddf5b7150b6c247bdb4af571ccadc407bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bae73ca5222381861a29202c88ce5cfe675b6753", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bae73ca5222381861a29202c88ce5cfe675b6753", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bae73ca5222381861a29202c88ce5cfe675b6753", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bae73ca5222381861a29202c88ce5cfe675b6753/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c5b08a2ca935c5db68e79d33e5c5b752252115c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c5b08a2ca935c5db68e79d33e5c5b752252115c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c5b08a2ca935c5db68e79d33e5c5b752252115c"}], "stats": {"total": 133, "additions": 66, "deletions": 67}, "files": [{"sha": "e00c034fee3adc9fdff5e465cad5c91bbca88e7f", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 63, "deletions": 2, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bae73ca5222381861a29202c88ce5cfe675b6753/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bae73ca5222381861a29202c88ce5cfe675b6753/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=bae73ca5222381861a29202c88ce5cfe675b6753", "patch": "@@ -4395,6 +4395,67 @@ vrp_prop::vrp_finalize (vrp_folder *folder, bool warn_array_bounds_p)\n     }\n }\n \n+/* STMT is a conditional at the end of a basic block.\n+\n+   If the conditional is of the form SSA_NAME op constant and the SSA_NAME\n+   was set via a type conversion, try to replace the SSA_NAME with the RHS\n+   of the type conversion.  Doing so makes the conversion dead which helps\n+   subsequent passes.  */\n+\n+static void\n+vrp_simplify_cond_using_ranges (vr_values *query, gcond *stmt)\n+{\n+  tree op0 = gimple_cond_lhs (stmt);\n+  tree op1 = gimple_cond_rhs (stmt);\n+\n+  /* If we have a comparison of an SSA_NAME (OP0) against a constant,\n+     see if OP0 was set by a type conversion where the source of\n+     the conversion is another SSA_NAME with a range that fits\n+     into the range of OP0's type.\n+\n+     If so, the conversion is redundant as the earlier SSA_NAME can be\n+     used for the comparison directly if we just massage the constant in the\n+     comparison.  */\n+  if (TREE_CODE (op0) == SSA_NAME\n+      && TREE_CODE (op1) == INTEGER_CST)\n+    {\n+      gimple *def_stmt = SSA_NAME_DEF_STMT (op0);\n+      tree innerop;\n+\n+      if (!is_gimple_assign (def_stmt)\n+\t  || !CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (def_stmt)))\n+\treturn;\n+\n+      innerop = gimple_assign_rhs1 (def_stmt);\n+\n+      if (TREE_CODE (innerop) == SSA_NAME\n+\t  && !POINTER_TYPE_P (TREE_TYPE (innerop))\n+\t  && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (innerop)\n+\t  && desired_pro_or_demotion_p (TREE_TYPE (innerop), TREE_TYPE (op0)))\n+\t{\n+\t  const value_range *vr = query->get_value_range (innerop);\n+\n+\t  if (range_int_cst_p (vr)\n+\t      && range_fits_type_p (vr,\n+\t\t\t\t    TYPE_PRECISION (TREE_TYPE (op0)),\n+\t\t\t\t    TYPE_SIGN (TREE_TYPE (op0)))\n+\t      && int_fits_type_p (op1, TREE_TYPE (innerop)))\n+\t    {\n+\t      tree newconst = fold_convert (TREE_TYPE (innerop), op1);\n+\t      gimple_cond_set_lhs (stmt, innerop);\n+\t      gimple_cond_set_rhs (stmt, newconst);\n+\t      update_stmt (stmt);\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t{\n+\t\t  fprintf (dump_file, \"Folded into: \");\n+\t\t  print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+\t\t  fprintf (dump_file, \"\\n\");\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\n /* Main entry point to VRP (Value Range Propagation).  This pass is\n    loosely based on J. R. C. Patterson, ``Accurate Static Branch\n    Prediction by Value Range Propagation,'' in SIGPLAN Conference on\n@@ -4482,8 +4543,8 @@ execute_vrp (struct function *fun, bool warn_array_bounds_p)\n     {\n       gimple *last = last_stmt (bb);\n       if (last && gimple_code (last) == GIMPLE_COND)\n-\tsimplify_cond_using_ranges_2 (&vrp_prop.vr_values,\n-\t\t\t\t      as_a <gcond *> (last));\n+\tvrp_simplify_cond_using_ranges (&vrp_prop.vr_values,\n+\t\t\t\t\tas_a <gcond *> (last));\n     }\n \n   free_numbers_of_iterations_estimates (fun);"}, {"sha": "cc0ddca2bd31423c623d6d35434650c574b79ca0", "filename": "gcc/vr-values.c", "status": "modified", "additions": 1, "deletions": 62, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bae73ca5222381861a29202c88ce5cfe675b6753/gcc%2Fvr-values.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bae73ca5222381861a29202c88ce5cfe675b6753/gcc%2Fvr-values.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.c?ref=bae73ca5222381861a29202c88ce5cfe675b6753", "patch": "@@ -3594,7 +3594,7 @@ test_for_singularity (enum tree_code cond_code, tree op0,\n /* Return whether the value range *VR fits in an integer type specified\n    by PRECISION and UNSIGNED_P.  */\n \n-static bool\n+bool\n range_fits_type_p (const value_range *vr,\n \t\t   unsigned dest_precision, signop dest_sgn)\n {\n@@ -3781,67 +3781,6 @@ simplify_using_ranges::simplify_cond_using_ranges_1 (gcond *stmt)\n   return false;\n }\n \n-/* STMT is a conditional at the end of a basic block.\n-\n-   If the conditional is of the form SSA_NAME op constant and the SSA_NAME\n-   was set via a type conversion, try to replace the SSA_NAME with the RHS\n-   of the type conversion.  Doing so makes the conversion dead which helps\n-   subsequent passes.  */\n-\n-void\n-simplify_cond_using_ranges_2 (vr_values *query, gcond *stmt)\n-{\n-  tree op0 = gimple_cond_lhs (stmt);\n-  tree op1 = gimple_cond_rhs (stmt);\n-\n-  /* If we have a comparison of an SSA_NAME (OP0) against a constant,\n-     see if OP0 was set by a type conversion where the source of\n-     the conversion is another SSA_NAME with a range that fits\n-     into the range of OP0's type.\n-\n-     If so, the conversion is redundant as the earlier SSA_NAME can be\n-     used for the comparison directly if we just massage the constant in the\n-     comparison.  */\n-  if (TREE_CODE (op0) == SSA_NAME\n-      && TREE_CODE (op1) == INTEGER_CST)\n-    {\n-      gimple *def_stmt = SSA_NAME_DEF_STMT (op0);\n-      tree innerop;\n-\n-      if (!is_gimple_assign (def_stmt)\n-\t  || !CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (def_stmt)))\n-\treturn;\n-\n-      innerop = gimple_assign_rhs1 (def_stmt);\n-\n-      if (TREE_CODE (innerop) == SSA_NAME\n-\t  && !POINTER_TYPE_P (TREE_TYPE (innerop))\n-\t  && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (innerop)\n-\t  && desired_pro_or_demotion_p (TREE_TYPE (innerop), TREE_TYPE (op0)))\n-\t{\n-\t  const value_range *vr = query->get_value_range (innerop);\n-\n-\t  if (range_int_cst_p (vr)\n-\t      && range_fits_type_p (vr,\n-\t\t\t\t    TYPE_PRECISION (TREE_TYPE (op0)),\n-\t\t\t\t    TYPE_SIGN (TREE_TYPE (op0)))\n-\t      && int_fits_type_p (op1, TREE_TYPE (innerop)))\n-\t    {\n-\t      tree newconst = fold_convert (TREE_TYPE (innerop), op1);\n-\t      gimple_cond_set_lhs (stmt, innerop);\n-\t      gimple_cond_set_rhs (stmt, newconst);\n-\t      update_stmt (stmt);\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t{\n-\t\t  fprintf (dump_file, \"Folded into: \");\n-\t\t  print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n-\t\t  fprintf (dump_file, \"\\n\");\n-\t\t}\n-\t    }\n-\t}\n-    }\n-}\n-\n /* Simplify a switch statement using the value range of the switch\n    argument.  */\n "}, {"sha": "59fac0c4b1e4a36fa39ebf46102aee31a36dfcc6", "filename": "gcc/vr-values.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bae73ca5222381861a29202c88ce5cfe675b6753/gcc%2Fvr-values.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bae73ca5222381861a29202c88ce5cfe675b6753/gcc%2Fvr-values.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.h?ref=bae73ca5222381861a29202c88ce5cfe675b6753", "patch": "@@ -170,9 +170,8 @@ class vr_values : public range_query\n \n extern tree get_output_for_vrp (gimple *);\n \n-// FIXME: Move this to tree-vrp.c.\n-void simplify_cond_using_ranges_2 (class vr_values *, gcond *);\n-\n+extern bool range_fits_type_p (const value_range *vr,\n+\t\t\t       unsigned dest_precision, signop dest_sgn);\n extern bool bounds_of_var_in_loop (tree *min, tree *max, range_query *,\n \t\t\t\t   class loop *loop, gimple *stmt, tree var);\n "}]}