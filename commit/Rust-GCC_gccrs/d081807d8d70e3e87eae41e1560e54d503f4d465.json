{"sha": "d081807d8d70e3e87eae41e1560e54d503f4d465", "node_id": "C_kwDOANBUbNoAKGQwODE4MDdkOGQ3MGUzZTg3ZWFlNDFlMTU2MGU1NGQ1MDNmNGQ0NjU", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-12-06T14:51:51Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-12-08T18:40:21Z"}, "message": "c++: avoid initializer_list<string> [PR105838]\n\nWhen constructing a vector<string> from { \"strings\" }, first is built an\ninitializer_list<string>, which is then copied into the strings in the\nvector.  But this is inefficient: better would be treat the { \"strings\" }\nas a range and construct the strings in the vector directly from the\nstring-literals.  We can do this transformation for standard library\nclasses because we know the design patterns they follow.\n\n\tPR c++/105838\n\ngcc/cp/ChangeLog:\n\n\t* call.cc (list_ctor_element_type): New.\n\t(braced_init_element_type): New.\n\t(has_non_trivial_temporaries): New.\n\t(maybe_init_list_as_array): New.\n\t(maybe_init_list_as_range): New.\n\t(build_user_type_conversion_1): Use maybe_init_list_as_range.\n\t* parser.cc (cp_parser_braced_list): Call\n\trecompute_constructor_flags.\n\t* cp-tree.h (find_temps_r): Declare.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/tree-ssa/initlist-opt1.C: New test.", "tree": {"sha": "185855bcdb475ae4a4034cbb4441d20d661fa927", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/185855bcdb475ae4a4034cbb4441d20d661fa927"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d081807d8d70e3e87eae41e1560e54d503f4d465", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d081807d8d70e3e87eae41e1560e54d503f4d465", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d081807d8d70e3e87eae41e1560e54d503f4d465", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d081807d8d70e3e87eae41e1560e54d503f4d465/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e1847612d7f169f82c985b0b3a5e3301d6fe999", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e1847612d7f169f82c985b0b3a5e3301d6fe999", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e1847612d7f169f82c985b0b3a5e3301d6fe999"}], "stats": {"total": 165, "additions": 165, "deletions": 0}, "files": [{"sha": "33b5e7f87f502289f6bc7a4684c9a5106d55cd9b", "filename": "gcc/cp/call.cc", "status": "modified", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d081807d8d70e3e87eae41e1560e54d503f4d465/gcc%2Fcp%2Fcall.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d081807d8d70e3e87eae41e1560e54d503f4d465/gcc%2Fcp%2Fcall.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.cc?ref=d081807d8d70e3e87eae41e1560e54d503f4d465", "patch": "@@ -4154,6 +4154,134 @@ add_list_candidates (tree fns, tree first_arg,\n \t\t  access_path, flags, candidates, complain);\n }\n \n+/* Given C(std::initializer_list<A>), return A.  */\n+\n+static tree\n+list_ctor_element_type (tree fn)\n+{\n+  gcc_checking_assert (is_list_ctor (fn));\n+\n+  tree parm = FUNCTION_FIRST_USER_PARMTYPE (fn);\n+  parm = non_reference (TREE_VALUE (parm));\n+  return TREE_VEC_ELT (CLASSTYPE_TI_ARGS (parm), 0);\n+}\n+\n+/* If EXPR is a braced-init-list where the elements all decay to the same type,\n+   return that type.  */\n+\n+static tree\n+braced_init_element_type (tree expr)\n+{\n+  if (TREE_CODE (expr) == CONSTRUCTOR\n+      && TREE_CODE (TREE_TYPE (expr)) == ARRAY_TYPE)\n+    return TREE_TYPE (TREE_TYPE (expr));\n+  if (!BRACE_ENCLOSED_INITIALIZER_P (expr))\n+    return NULL_TREE;\n+\n+  tree elttype = NULL_TREE;\n+  for (constructor_elt &e: CONSTRUCTOR_ELTS (expr))\n+    {\n+      tree type = TREE_TYPE (e.value);\n+      type = type_decays_to (type);\n+      if (!elttype)\n+\telttype = type;\n+      else if (!same_type_p (type, elttype))\n+\treturn NULL_TREE;\n+    }\n+  return elttype;\n+}\n+\n+/* True iff EXPR contains any temporaries with non-trivial destruction.\n+\n+   ??? Also ignore classes with non-trivial but no-op destruction other than\n+   std::allocator?  */\n+\n+static bool\n+has_non_trivial_temporaries (tree expr)\n+{\n+  auto_vec<tree*> temps;\n+  cp_walk_tree_without_duplicates (&expr, find_temps_r, &temps);\n+  for (tree *p : temps)\n+    {\n+      tree t = TREE_TYPE (*p);\n+      if (!TYPE_HAS_TRIVIAL_DESTRUCTOR (t)\n+\t  && !is_std_allocator (t))\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+/* We're initializing an array of ELTTYPE from INIT.  If it seems useful,\n+   return INIT as an array (of its own type) so the caller can initialize the\n+   target array in a loop.  */\n+\n+static tree\n+maybe_init_list_as_array (tree elttype, tree init)\n+{\n+  /* Only do this if the array can go in rodata but not once converted.  */\n+  if (!CLASS_TYPE_P (elttype))\n+    return NULL_TREE;\n+  tree init_elttype = braced_init_element_type (init);\n+  if (!init_elttype || !SCALAR_TYPE_P (init_elttype) || !TREE_CONSTANT (init))\n+    return NULL_TREE;\n+\n+  tree first = CONSTRUCTOR_ELT (init, 0)->value;\n+  if (TREE_CODE (init_elttype) == INTEGER_TYPE && null_ptr_cst_p (first))\n+    /* Avoid confusion from treating 0 as a null pointer constant.  */\n+    first = build1 (UNARY_PLUS_EXPR, init_elttype, first);\n+  first = (perform_implicit_conversion_flags\n+\t   (elttype, first, tf_none, LOOKUP_IMPLICIT|LOOKUP_NO_NARROWING));\n+  if (first == error_mark_node)\n+    /* Let the normal code give the error.  */\n+    return NULL_TREE;\n+\n+  /* Don't do this if the conversion would be constant.  */\n+  first = maybe_constant_init (first);\n+  if (TREE_CONSTANT (first))\n+    return NULL_TREE;\n+\n+  /* We can't do this if the conversion creates temporaries that need\n+     to live until the whole array is initialized.  */\n+  if (has_non_trivial_temporaries (first))\n+    return NULL_TREE;\n+\n+  init_elttype = cp_build_qualified_type (init_elttype, TYPE_QUAL_CONST);\n+  tree arr = build_array_of_n_type (init_elttype, CONSTRUCTOR_NELTS (init));\n+  return finish_compound_literal (arr, init, tf_none);\n+}\n+\n+/* If we were going to call e.g. vector(initializer_list<string>) starting\n+   with a list of string-literals (which is inefficient, see PR105838),\n+   instead build an array of const char* and pass it to the range constructor.\n+   But only do this for standard library types, where we can assume the\n+   transformation makes sense.\n+\n+   Really the container classes should have initializer_list<U> constructors to\n+   get the same effect more simply; this is working around that lack.  */\n+\n+static tree\n+maybe_init_list_as_range (tree fn, tree expr)\n+{\n+  if (BRACE_ENCLOSED_INITIALIZER_P (expr)\n+      && is_list_ctor (fn)\n+      && decl_in_std_namespace_p (fn))\n+    {\n+      tree to = list_ctor_element_type (fn);\n+      if (tree init = maybe_init_list_as_array (to, expr))\n+\t{\n+\t  tree begin = decay_conversion (TARGET_EXPR_SLOT (init), tf_none);\n+\t  tree nelts = array_type_nelts_top (TREE_TYPE (init));\n+\t  tree end = cp_build_binary_op (input_location, PLUS_EXPR, begin,\n+\t\t\t\t\t nelts, tf_none);\n+\t  begin = cp_build_compound_expr (init, begin, tf_none);\n+\t  return build_constructor_va (init_list_type_node, 2,\n+\t\t\t\t       NULL_TREE, begin, NULL_TREE, end);\n+\t}\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Returns the best overload candidate to perform the requested\n    conversion.  This function is used for three the overloading situations\n    described in [over.match.copy], [over.match.conv], and [over.match.ref].\n@@ -4425,6 +4553,16 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags,\n       return cand;\n     }\n \n+  /* Maybe pass { } as iterators instead of an initializer_list.  */\n+  if (tree iters = maybe_init_list_as_range (cand->fn, expr))\n+    if (z_candidate *cand2\n+\t= build_user_type_conversion_1 (totype, iters, flags, tf_none))\n+      if (cand2->viable == 1)\n+\t{\n+\t  cand = cand2;\n+\t  expr = iters;\n+\t}\n+\n   tree convtype;\n   if (!DECL_CONSTRUCTOR_P (cand->fn))\n     convtype = non_reference (TREE_TYPE (TREE_TYPE (cand->fn)));"}, {"sha": "0d6c234b3b0792834ace39e34bb2aba8373b61a3", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d081807d8d70e3e87eae41e1560e54d503f4d465/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d081807d8d70e3e87eae41e1560e54d503f4d465/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d081807d8d70e3e87eae41e1560e54d503f4d465", "patch": "@@ -7087,6 +7087,7 @@ extern void set_global_friend\t\t\t(tree);\n extern bool is_global_friend\t\t\t(tree);\n \n /* in init.cc */\n+extern tree find_temps_r\t\t\t(tree *, int *, void *);\n extern tree expand_member_init\t\t\t(tree);\n extern void emit_mem_initializers\t\t(tree);\n extern tree build_aggr_init\t\t\t(tree, tree, int,"}, {"sha": "4798aae1fbb3482200d59800acbcb71f65a8da28", "filename": "gcc/cp/parser.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d081807d8d70e3e87eae41e1560e54d503f4d465/gcc%2Fcp%2Fparser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d081807d8d70e3e87eae41e1560e54d503f4d465/gcc%2Fcp%2Fparser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.cc?ref=d081807d8d70e3e87eae41e1560e54d503f4d465", "patch": "@@ -25445,6 +25445,7 @@ cp_parser_braced_list (cp_parser* parser, bool* non_constant_p)\n   location_t finish_loc = cp_lexer_peek_token (parser->lexer)->location;\n   braces.require_close (parser);\n   TREE_TYPE (initializer) = init_list_type_node;\n+  recompute_constructor_flags (initializer);\n \n   cp_expr result (initializer);\n   /* Build a location of the form:"}, {"sha": "053317b59d8c7b60108b4e6f2716bdaa5a1dbf4c", "filename": "gcc/testsuite/g++.dg/tree-ssa/initlist-opt1.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d081807d8d70e3e87eae41e1560e54d503f4d465/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Finitlist-opt1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d081807d8d70e3e87eae41e1560e54d503f4d465/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Finitlist-opt1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Finitlist-opt1.C?ref=d081807d8d70e3e87eae41e1560e54d503f4d465", "patch": "@@ -0,0 +1,25 @@\n+// PR c++/105838\n+// { dg-additional-options -fdump-tree-gimple }\n+// { dg-do compile { target c++11 } }\n+\n+// Test that we do range-initialization from const char *.\n+// { dg-final { scan-tree-dump {_M_range_initialize<const char\\* const\\*>} \"gimple\" } }\n+\n+#include <string>\n+#include <vector>\n+\n+void g (const void *);\n+\n+void f (const char *p)\n+{\n+  std::vector<std::string> lst = {\n+  \"aahing\", \"aaliis\", \"aarrgh\", \"abacas\", \"abacus\", \"abakas\", \"abamps\", \"abands\", \"abased\", \"abaser\", \"abases\", \"abasia\",\n+  \"abated\", \"abater\", \"abates\", \"abatis\", \"abator\", \"abattu\", \"abayas\", \"abbacy\", \"abbess\", \"abbeys\", \"abbots\", \"abcees\",\n+  \"abdabs\", \"abduce\", \"abduct\", \"abears\", \"abeigh\", \"abeles\", \"abelia\", \"abends\", \"abhors\", \"abided\", \"abider\", \"abides\",\n+  \"abject\", \"abjure\", \"ablate\", \"ablaut\", \"ablaze\", \"ablest\", \"ablets\", \"abling\", \"ablins\", \"abloom\", \"ablush\", \"abmhos\",\n+  \"aboard\", \"aboded\", \"abodes\", \"abohms\", \"abolla\", \"abomas\", \"aboral\", \"abords\", \"aborne\", \"aborts\", \"abound\", \"abouts\",\n+  \"aboves\", \"abrade\", \"abraid\", \"abrash\", \"abrays\", \"abrazo\", \"abrege\", \"abrins\", \"abroad\", \"abrupt\", \"abseil\", \"absent\",\n+  };\n+\n+  g(&lst);\n+}"}]}