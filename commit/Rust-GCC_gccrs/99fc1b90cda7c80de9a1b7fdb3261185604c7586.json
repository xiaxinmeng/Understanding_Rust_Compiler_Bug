{"sha": "99fc1b90cda7c80de9a1b7fdb3261185604c7586", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTlmYzFiOTBjZGE3YzgwZGU5YTFiN2ZkYjMyNjExODU2MDRjNzU4Ng==", "commit": {"author": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2011-08-07T10:12:09Z"}, "committer": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2011-08-07T10:12:09Z"}, "message": "re PR fortran/49638 ([OOP] length parameter is ignored when overriding type bound character functions with constant length.)\n\n2011-08-07  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/49638\n\t* dependency.h (gfc_is_same_range,gfc_are_identical_variables): Remove\n\ttwo prototypes.\n\t* dependency.c (gfc_are_identical_variables,are_identical_variables):\n\tRenamed the former to the latter and made static.\n\t(gfc_dep_compare_expr): Renamed 'gfc_are_identical_variables', handle\n\tcommutativity of multiplication.\n\t(gfc_is_same_range,is_same_range): Renamed the former to the latter,\n\tmade static and removed argument 'def'.\n\t(check_section_vs_section): Renamed 'gfc_is_same_range'.\n\t* gfortran.h (gfc_check_typebound_override): New prototype.\n\t* interface.c (gfc_check_typebound_override): Moved here from ...\n\t* resolve.c (check_typebound_override): ... here (and renamed).\n\t(resolve_typebound_procedure): Renamed 'check_typebound_override'.\n\nFrom-SVN: r177545", "tree": {"sha": "609c767e03ac951170167c3efe780f0cf1058588", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/609c767e03ac951170167c3efe780f0cf1058588"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/99fc1b90cda7c80de9a1b7fdb3261185604c7586", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99fc1b90cda7c80de9a1b7fdb3261185604c7586", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99fc1b90cda7c80de9a1b7fdb3261185604c7586", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99fc1b90cda7c80de9a1b7fdb3261185604c7586/comments", "author": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f446d60e814fdafc3bd7b11b748f2faeb0012a5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f446d60e814fdafc3bd7b11b748f2faeb0012a5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f446d60e814fdafc3bd7b11b748f2faeb0012a5a"}], "stats": {"total": 470, "additions": 241, "deletions": 229}, "files": [{"sha": "0c38317ed5d5de2d03950afb6b49e3ff4ac5c631", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99fc1b90cda7c80de9a1b7fdb3261185604c7586/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99fc1b90cda7c80de9a1b7fdb3261185604c7586/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=99fc1b90cda7c80de9a1b7fdb3261185604c7586", "patch": "@@ -1,3 +1,20 @@\n+2011-08-07  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/49638\n+\t* dependency.h (gfc_is_same_range,gfc_are_identical_variables): Remove\n+\ttwo prototypes.\n+\t* dependency.c (gfc_are_identical_variables,are_identical_variables):\n+\tRenamed the former to the latter and made static.\n+\t(gfc_dep_compare_expr): Renamed 'gfc_are_identical_variables', handle\n+\tcommutativity of multiplication.\n+\t(gfc_is_same_range,is_same_range): Renamed the former to the latter,\n+\tmade static and removed argument 'def'.\n+\t(check_section_vs_section): Renamed 'gfc_is_same_range'.\n+\t* gfortran.h (gfc_check_typebound_override): New prototype.\n+\t* interface.c (gfc_check_typebound_override): Moved here from ...\n+\t* resolve.c (check_typebound_override): ... here (and renamed).\n+\t(resolve_typebound_procedure): Renamed 'check_typebound_override'.\n+\n 2011-08-06  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/50004"}, {"sha": "b49cf5424cad37f8cbe4e5c7d9a16e632f41ce58", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 22, "deletions": 27, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99fc1b90cda7c80de9a1b7fdb3261185604c7586/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99fc1b90cda7c80de9a1b7fdb3261185604c7586/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=99fc1b90cda7c80de9a1b7fdb3261185604c7586", "patch": "@@ -118,8 +118,8 @@ identical_array_ref (gfc_array_ref *a1, gfc_array_ref *a2)\n /* Return true for identical variables, checking for references if\n    necessary.  Calls identical_array_ref for checking array sections.  */\n \n-bool\n-gfc_are_identical_variables (gfc_expr *e1, gfc_expr *e2)\n+static bool\n+are_identical_variables (gfc_expr *e1, gfc_expr *e2)\n {\n   gfc_ref *r1, *r2;\n \n@@ -169,7 +169,7 @@ gfc_are_identical_variables (gfc_expr *e1, gfc_expr *e2)\n \t  break;\n \n \tdefault:\n-\t  gfc_internal_error (\"gfc_are_identical_variables: Bad type\");\n+\t  gfc_internal_error (\"are_identical_variables: Bad type\");\n \t}\n       r1 = r1->next;\n       r2 = r2->next;\n@@ -421,7 +421,7 @@ gfc_dep_compare_expr (gfc_expr *e1, gfc_expr *e2)\n       return 1;\n \n     case EXPR_VARIABLE:\n-      if (gfc_are_identical_variables (e1, e2))\n+      if (are_identical_variables (e1, e2))\n \treturn 0;\n       else\n \treturn -2;\n@@ -438,7 +438,12 @@ gfc_dep_compare_expr (gfc_expr *e1, gfc_expr *e2)\n       if (gfc_dep_compare_expr (e1->value.op.op1, e2->value.op.op1) == 0\n \t  && gfc_dep_compare_expr (e1->value.op.op2, e2->value.op.op2) == 0)\n \treturn 0;\n-      /* TODO Handle commutative binary operators here?  */\n+      else if (e1->value.op.op == INTRINSIC_TIMES\n+\t       && gfc_dep_compare_expr (e1->value.op.op1, e2->value.op.op2) == 0\n+\t       && gfc_dep_compare_expr (e1->value.op.op2, e2->value.op.op1) == 0)\n+\t/* Commutativity of multiplication.  */\n+\treturn 0;\n+\n       return -2;\n \n     case EXPR_FUNCTION:\n@@ -451,11 +456,11 @@ gfc_dep_compare_expr (gfc_expr *e1, gfc_expr *e2)\n }\n \n \n-/* Returns 1 if the two ranges are the same, 0 if they are not, and def\n-   if the results are indeterminate.  N is the dimension to compare.  */\n+/* Returns 1 if the two ranges are the same and 0 if they are not (or if the\n+   results are indeterminate). 'n' is the dimension to compare.  */\n \n-int\n-gfc_is_same_range (gfc_array_ref *ar1, gfc_array_ref *ar2, int n, int def)\n+static int\n+is_same_range (gfc_array_ref *ar1, gfc_array_ref *ar2, int n)\n {\n   gfc_expr *e1;\n   gfc_expr *e2;\n@@ -472,25 +477,19 @@ gfc_is_same_range (gfc_array_ref *ar1, gfc_array_ref *ar2, int n, int def)\n   if (e1 && !e2)\n     {\n       i = gfc_expr_is_one (e1, -1);\n-      if (i == -1)\n-\treturn def;\n-      else if (i == 0)\n+      if (i == -1 || i == 0)\n \treturn 0;\n     }\n   else if (e2 && !e1)\n     {\n       i = gfc_expr_is_one (e2, -1);\n-      if (i == -1)\n-\treturn def;\n-      else if (i == 0)\n+      if (i == -1 || i == 0)\n \treturn 0;\n     }\n   else if (e1 && e2)\n     {\n       i = gfc_dep_compare_expr (e1, e2);\n-      if (i == -2)\n-\treturn def;\n-      else if (i != 0)\n+      if (i != 0)\n \treturn 0;\n     }\n   /* The strides match.  */\n@@ -509,12 +508,10 @@ gfc_is_same_range (gfc_array_ref *ar1, gfc_array_ref *ar2, int n, int def)\n \n       /* Check we have values for both.  */\n       if (!(e1 && e2))\n-\treturn def;\n+\treturn 0;\n \n       i = gfc_dep_compare_expr (e1, e2);\n-      if (i == -2)\n-\treturn def;\n-      else if (i != 0)\n+      if (i != 0)\n \treturn 0;\n     }\n \n@@ -532,12 +529,10 @@ gfc_is_same_range (gfc_array_ref *ar1, gfc_array_ref *ar2, int n, int def)\n \n       /* Check we have values for both.  */\n       if (!(e1 && e2))\n-\treturn def;\n+\treturn 0;\n \n       i = gfc_dep_compare_expr (e1, e2);\n-      if (i == -2)\n-\treturn def;\n-      else if (i != 0)\n+      if (i != 0)\n \treturn 0;\n     }\n \n@@ -1091,7 +1086,7 @@ check_section_vs_section (gfc_array_ref *l_ar, gfc_array_ref *r_ar, int n)\n   int start_comparison;\n \n   /* If they are the same range, return without more ado.  */\n-  if (gfc_is_same_range (l_ar, r_ar, n, 0))\n+  if (is_same_range (l_ar, r_ar, n))\n     return GFC_DEP_EQUAL;\n \n   l_start = l_ar->start[n];"}, {"sha": "d56a7f726d27294ff15cbbdc8b275b87415e603e", "filename": "gcc/fortran/dependency.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99fc1b90cda7c80de9a1b7fdb3261185604c7586/gcc%2Ffortran%2Fdependency.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99fc1b90cda7c80de9a1b7fdb3261185604c7586/gcc%2Ffortran%2Fdependency.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.h?ref=99fc1b90cda7c80de9a1b7fdb3261185604c7586", "patch": "@@ -37,11 +37,7 @@ gfc_expr *gfc_get_noncopying_intrinsic_argument (gfc_expr *);\n int gfc_check_fncall_dependency (gfc_expr *, sym_intent, gfc_symbol *,\n \t\t\t\t gfc_actual_arglist *, gfc_dep_check);\n int gfc_check_dependency (gfc_expr *, gfc_expr *, bool);\n-int gfc_is_same_range (gfc_array_ref *, gfc_array_ref *, int, int);\n int gfc_expr_is_one (gfc_expr *, int);\n \n int gfc_dep_resolver(gfc_ref *, gfc_ref *, gfc_reverse *);\n int gfc_are_equivalenced_arrays (gfc_expr *, gfc_expr *);\n-\n-bool gfc_are_identical_variables (gfc_expr *, gfc_expr *);\n-"}, {"sha": "b4a4f8593ee43e900dbcdbc624e1d7d68a3941fc", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99fc1b90cda7c80de9a1b7fdb3261185604c7586/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99fc1b90cda7c80de9a1b7fdb3261185604c7586/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=99fc1b90cda7c80de9a1b7fdb3261185604c7586", "patch": "@@ -2840,6 +2840,7 @@ bool gfc_arglist_matches_symbol (gfc_actual_arglist**, gfc_symbol*);\n bool gfc_check_operator_interface (gfc_symbol*, gfc_intrinsic_op, locus);\n int gfc_has_vector_subscript (gfc_expr*);\n gfc_intrinsic_op gfc_equivalent_op (gfc_intrinsic_op);\n+gfc_try gfc_check_typebound_override (gfc_symtree*, gfc_symtree*);\n \n /* io.c */\n extern gfc_st_label format_asterisk;"}, {"sha": "899807231a276a29ab43abe35a73a3dea2383de6", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99fc1b90cda7c80de9a1b7fdb3261185604c7586/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99fc1b90cda7c80de9a1b7fdb3261185604c7586/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=99fc1b90cda7c80de9a1b7fdb3261185604c7586", "patch": "@@ -3466,3 +3466,197 @@ gfc_free_formal_arglist (gfc_formal_arglist *p)\n       free (p);\n     }\n }\n+\n+\n+/* Check that it is ok for the typebound procedure proc to override the\n+   procedure old.  */\n+\n+gfc_try\n+gfc_check_typebound_override (gfc_symtree* proc, gfc_symtree* old)\n+{\n+  locus where;\n+  const gfc_symbol* proc_target;\n+  const gfc_symbol* old_target;\n+  unsigned proc_pass_arg, old_pass_arg, argpos;\n+  gfc_formal_arglist* proc_formal;\n+  gfc_formal_arglist* old_formal;\n+\n+  /* This procedure should only be called for non-GENERIC proc.  */\n+  gcc_assert (!proc->n.tb->is_generic);\n+\n+  /* If the overwritten procedure is GENERIC, this is an error.  */\n+  if (old->n.tb->is_generic)\n+    {\n+      gfc_error (\"Can't overwrite GENERIC '%s' at %L\",\n+\t\t old->name, &proc->n.tb->where);\n+      return FAILURE;\n+    }\n+\n+  where = proc->n.tb->where;\n+  proc_target = proc->n.tb->u.specific->n.sym;\n+  old_target = old->n.tb->u.specific->n.sym;\n+\n+  /* Check that overridden binding is not NON_OVERRIDABLE.  */\n+  if (old->n.tb->non_overridable)\n+    {\n+      gfc_error (\"'%s' at %L overrides a procedure binding declared\"\n+\t\t \" NON_OVERRIDABLE\", proc->name, &where);\n+      return FAILURE;\n+    }\n+\n+  /* It's an error to override a non-DEFERRED procedure with a DEFERRED one.  */\n+  if (!old->n.tb->deferred && proc->n.tb->deferred)\n+    {\n+      gfc_error (\"'%s' at %L must not be DEFERRED as it overrides a\"\n+\t\t \" non-DEFERRED binding\", proc->name, &where);\n+      return FAILURE;\n+    }\n+\n+  /* If the overridden binding is PURE, the overriding must be, too.  */\n+  if (old_target->attr.pure && !proc_target->attr.pure)\n+    {\n+      gfc_error (\"'%s' at %L overrides a PURE procedure and must also be PURE\",\n+\t\t proc->name, &where);\n+      return FAILURE;\n+    }\n+\n+  /* If the overridden binding is ELEMENTAL, the overriding must be, too.  If it\n+     is not, the overriding must not be either.  */\n+  if (old_target->attr.elemental && !proc_target->attr.elemental)\n+    {\n+      gfc_error (\"'%s' at %L overrides an ELEMENTAL procedure and must also be\"\n+\t\t \" ELEMENTAL\", proc->name, &where);\n+      return FAILURE;\n+    }\n+  if (!old_target->attr.elemental && proc_target->attr.elemental)\n+    {\n+      gfc_error (\"'%s' at %L overrides a non-ELEMENTAL procedure and must not\"\n+\t\t \" be ELEMENTAL, either\", proc->name, &where);\n+      return FAILURE;\n+    }\n+\n+  /* If the overridden binding is a SUBROUTINE, the overriding must also be a\n+     SUBROUTINE.  */\n+  if (old_target->attr.subroutine && !proc_target->attr.subroutine)\n+    {\n+      gfc_error (\"'%s' at %L overrides a SUBROUTINE and must also be a\"\n+\t\t \" SUBROUTINE\", proc->name, &where);\n+      return FAILURE;\n+    }\n+\n+  /* If the overridden binding is a FUNCTION, the overriding must also be a\n+     FUNCTION and have the same characteristics.  */\n+  if (old_target->attr.function)\n+    {\n+      if (!proc_target->attr.function)\n+\t{\n+\t  gfc_error (\"'%s' at %L overrides a FUNCTION and must also be a\"\n+\t\t     \" FUNCTION\", proc->name, &where);\n+\t  return FAILURE;\n+\t}\n+\n+      /* FIXME:  Do more comprehensive checking (including, for instance, the\n+\t rank and array-shape).  */\n+      gcc_assert (proc_target->result && old_target->result);\n+      if (!gfc_compare_types (&proc_target->result->ts,\n+\t\t\t      &old_target->result->ts))\n+\t{\n+\t  gfc_error (\"'%s' at %L and the overridden FUNCTION should have\"\n+\t\t     \" matching result types\", proc->name, &where);\n+\t  return FAILURE;\n+\t}\n+    }\n+\n+  /* If the overridden binding is PUBLIC, the overriding one must not be\n+     PRIVATE.  */\n+  if (old->n.tb->access == ACCESS_PUBLIC\n+      && proc->n.tb->access == ACCESS_PRIVATE)\n+    {\n+      gfc_error (\"'%s' at %L overrides a PUBLIC procedure and must not be\"\n+\t\t \" PRIVATE\", proc->name, &where);\n+      return FAILURE;\n+    }\n+\n+  /* Compare the formal argument lists of both procedures.  This is also abused\n+     to find the position of the passed-object dummy arguments of both\n+     bindings as at least the overridden one might not yet be resolved and we\n+     need those positions in the check below.  */\n+  proc_pass_arg = old_pass_arg = 0;\n+  if (!proc->n.tb->nopass && !proc->n.tb->pass_arg)\n+    proc_pass_arg = 1;\n+  if (!old->n.tb->nopass && !old->n.tb->pass_arg)\n+    old_pass_arg = 1;\n+  argpos = 1;\n+  for (proc_formal = proc_target->formal, old_formal = old_target->formal;\n+       proc_formal && old_formal;\n+       proc_formal = proc_formal->next, old_formal = old_formal->next)\n+    {\n+      if (proc->n.tb->pass_arg\n+\t  && !strcmp (proc->n.tb->pass_arg, proc_formal->sym->name))\n+\tproc_pass_arg = argpos;\n+      if (old->n.tb->pass_arg\n+\t  && !strcmp (old->n.tb->pass_arg, old_formal->sym->name))\n+\told_pass_arg = argpos;\n+\n+      /* Check that the names correspond.  */\n+      if (strcmp (proc_formal->sym->name, old_formal->sym->name))\n+\t{\n+\t  gfc_error (\"Dummy argument '%s' of '%s' at %L should be named '%s' as\"\n+\t\t     \" to match the corresponding argument of the overridden\"\n+\t\t     \" procedure\", proc_formal->sym->name, proc->name, &where,\n+\t\t     old_formal->sym->name);\n+\t  return FAILURE;\n+\t}\n+\n+      /* Check that the types correspond if neither is the passed-object\n+\t argument.  */\n+      /* FIXME:  Do more comprehensive testing here.  */\n+      if (proc_pass_arg != argpos && old_pass_arg != argpos\n+\t  && !gfc_compare_types (&proc_formal->sym->ts, &old_formal->sym->ts))\n+\t{\n+\t  gfc_error (\"Types mismatch for dummy argument '%s' of '%s' %L \"\n+\t\t     \"in respect to the overridden procedure\",\n+\t\t     proc_formal->sym->name, proc->name, &where);\n+\t  return FAILURE;\n+\t}\n+\n+      ++argpos;\n+    }\n+  if (proc_formal || old_formal)\n+    {\n+      gfc_error (\"'%s' at %L must have the same number of formal arguments as\"\n+\t\t \" the overridden procedure\", proc->name, &where);\n+      return FAILURE;\n+    }\n+\n+  /* If the overridden binding is NOPASS, the overriding one must also be\n+     NOPASS.  */\n+  if (old->n.tb->nopass && !proc->n.tb->nopass)\n+    {\n+      gfc_error (\"'%s' at %L overrides a NOPASS binding and must also be\"\n+\t\t \" NOPASS\", proc->name, &where);\n+      return FAILURE;\n+    }\n+\n+  /* If the overridden binding is PASS(x), the overriding one must also be\n+     PASS and the passed-object dummy arguments must correspond.  */\n+  if (!old->n.tb->nopass)\n+    {\n+      if (proc->n.tb->nopass)\n+\t{\n+\t  gfc_error (\"'%s' at %L overrides a binding with PASS and must also be\"\n+\t\t     \" PASS\", proc->name, &where);\n+\t  return FAILURE;\n+\t}\n+\n+      if (proc_pass_arg != old_pass_arg)\n+\t{\n+\t  gfc_error (\"Passed-object dummy argument of '%s' at %L must be at\"\n+\t\t     \" the same position as the passed-object dummy argument of\"\n+\t\t     \" the overridden procedure\", proc->name, &where);\n+\t  return FAILURE;\n+\t}\n+    }\n+\n+  return SUCCESS;\n+}"}, {"sha": "6245666f620df64e3b999bfa5f295121b0e329a7", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 7, "deletions": 198, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99fc1b90cda7c80de9a1b7fdb3261185604c7586/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99fc1b90cda7c80de9a1b7fdb3261185604c7586/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=99fc1b90cda7c80de9a1b7fdb3261185604c7586", "patch": "@@ -10672,200 +10672,6 @@ gfc_resolve_finalizers (gfc_symbol* derived)\n }\n \n \n-/* Check that it is ok for the typebound procedure proc to override the\n-   procedure old.  */\n-\n-static gfc_try\n-check_typebound_override (gfc_symtree* proc, gfc_symtree* old)\n-{\n-  locus where;\n-  const gfc_symbol* proc_target;\n-  const gfc_symbol* old_target;\n-  unsigned proc_pass_arg, old_pass_arg, argpos;\n-  gfc_formal_arglist* proc_formal;\n-  gfc_formal_arglist* old_formal;\n-\n-  /* This procedure should only be called for non-GENERIC proc.  */\n-  gcc_assert (!proc->n.tb->is_generic);\n-\n-  /* If the overwritten procedure is GENERIC, this is an error.  */\n-  if (old->n.tb->is_generic)\n-    {\n-      gfc_error (\"Can't overwrite GENERIC '%s' at %L\",\n-\t\t old->name, &proc->n.tb->where);\n-      return FAILURE;\n-    }\n-\n-  where = proc->n.tb->where;\n-  proc_target = proc->n.tb->u.specific->n.sym;\n-  old_target = old->n.tb->u.specific->n.sym;\n-\n-  /* Check that overridden binding is not NON_OVERRIDABLE.  */\n-  if (old->n.tb->non_overridable)\n-    {\n-      gfc_error (\"'%s' at %L overrides a procedure binding declared\"\n-\t\t \" NON_OVERRIDABLE\", proc->name, &where);\n-      return FAILURE;\n-    }\n-\n-  /* It's an error to override a non-DEFERRED procedure with a DEFERRED one.  */\n-  if (!old->n.tb->deferred && proc->n.tb->deferred)\n-    {\n-      gfc_error (\"'%s' at %L must not be DEFERRED as it overrides a\"\n-\t\t \" non-DEFERRED binding\", proc->name, &where);\n-      return FAILURE;\n-    }\n-\n-  /* If the overridden binding is PURE, the overriding must be, too.  */\n-  if (old_target->attr.pure && !proc_target->attr.pure)\n-    {\n-      gfc_error (\"'%s' at %L overrides a PURE procedure and must also be PURE\",\n-\t\t proc->name, &where);\n-      return FAILURE;\n-    }\n-\n-  /* If the overridden binding is ELEMENTAL, the overriding must be, too.  If it\n-     is not, the overriding must not be either.  */\n-  if (old_target->attr.elemental && !proc_target->attr.elemental)\n-    {\n-      gfc_error (\"'%s' at %L overrides an ELEMENTAL procedure and must also be\"\n-\t\t \" ELEMENTAL\", proc->name, &where);\n-      return FAILURE;\n-    }\n-  if (!old_target->attr.elemental && proc_target->attr.elemental)\n-    {\n-      gfc_error (\"'%s' at %L overrides a non-ELEMENTAL procedure and must not\"\n-\t\t \" be ELEMENTAL, either\", proc->name, &where);\n-      return FAILURE;\n-    }\n-\n-  /* If the overridden binding is a SUBROUTINE, the overriding must also be a\n-     SUBROUTINE.  */\n-  if (old_target->attr.subroutine && !proc_target->attr.subroutine)\n-    {\n-      gfc_error (\"'%s' at %L overrides a SUBROUTINE and must also be a\"\n-\t\t \" SUBROUTINE\", proc->name, &where);\n-      return FAILURE;\n-    }\n-\n-  /* If the overridden binding is a FUNCTION, the overriding must also be a\n-     FUNCTION and have the same characteristics.  */\n-  if (old_target->attr.function)\n-    {\n-      if (!proc_target->attr.function)\n-\t{\n-\t  gfc_error (\"'%s' at %L overrides a FUNCTION and must also be a\"\n-\t\t     \" FUNCTION\", proc->name, &where);\n-\t  return FAILURE;\n-\t}\n-\n-      /* FIXME:  Do more comprehensive checking (including, for instance, the\n-\t rank and array-shape).  */\n-      gcc_assert (proc_target->result && old_target->result);\n-      if (!gfc_compare_types (&proc_target->result->ts,\n-\t\t\t      &old_target->result->ts))\n-\t{\n-\t  gfc_error (\"'%s' at %L and the overridden FUNCTION should have\"\n-\t\t     \" matching result types\", proc->name, &where);\n-\t  return FAILURE;\n-\t}\n-    }\n-\n-  /* If the overridden binding is PUBLIC, the overriding one must not be\n-     PRIVATE.  */\n-  if (old->n.tb->access == ACCESS_PUBLIC\n-      && proc->n.tb->access == ACCESS_PRIVATE)\n-    {\n-      gfc_error (\"'%s' at %L overrides a PUBLIC procedure and must not be\"\n-\t\t \" PRIVATE\", proc->name, &where);\n-      return FAILURE;\n-    }\n-\n-  /* Compare the formal argument lists of both procedures.  This is also abused\n-     to find the position of the passed-object dummy arguments of both\n-     bindings as at least the overridden one might not yet be resolved and we\n-     need those positions in the check below.  */\n-  proc_pass_arg = old_pass_arg = 0;\n-  if (!proc->n.tb->nopass && !proc->n.tb->pass_arg)\n-    proc_pass_arg = 1;\n-  if (!old->n.tb->nopass && !old->n.tb->pass_arg)\n-    old_pass_arg = 1;\n-  argpos = 1;\n-  for (proc_formal = proc_target->formal, old_formal = old_target->formal;\n-       proc_formal && old_formal;\n-       proc_formal = proc_formal->next, old_formal = old_formal->next)\n-    {\n-      if (proc->n.tb->pass_arg\n-\t  && !strcmp (proc->n.tb->pass_arg, proc_formal->sym->name))\n-\tproc_pass_arg = argpos;\n-      if (old->n.tb->pass_arg\n-\t  && !strcmp (old->n.tb->pass_arg, old_formal->sym->name))\n-\told_pass_arg = argpos;\n-\n-      /* Check that the names correspond.  */\n-      if (strcmp (proc_formal->sym->name, old_formal->sym->name))\n-\t{\n-\t  gfc_error (\"Dummy argument '%s' of '%s' at %L should be named '%s' as\"\n-\t\t     \" to match the corresponding argument of the overridden\"\n-\t\t     \" procedure\", proc_formal->sym->name, proc->name, &where,\n-\t\t     old_formal->sym->name);\n-\t  return FAILURE;\n-\t}\n-\n-      /* Check that the types correspond if neither is the passed-object\n-\t argument.  */\n-      /* FIXME:  Do more comprehensive testing here.  */\n-      if (proc_pass_arg != argpos && old_pass_arg != argpos\n-\t  && !gfc_compare_types (&proc_formal->sym->ts, &old_formal->sym->ts))\n-\t{\n-\t  gfc_error (\"Types mismatch for dummy argument '%s' of '%s' %L \"\n-\t\t     \"in respect to the overridden procedure\",\n-\t\t     proc_formal->sym->name, proc->name, &where);\n-\t  return FAILURE;\n-\t}\n-\n-      ++argpos;\n-    }\n-  if (proc_formal || old_formal)\n-    {\n-      gfc_error (\"'%s' at %L must have the same number of formal arguments as\"\n-\t\t \" the overridden procedure\", proc->name, &where);\n-      return FAILURE;\n-    }\n-\n-  /* If the overridden binding is NOPASS, the overriding one must also be\n-     NOPASS.  */\n-  if (old->n.tb->nopass && !proc->n.tb->nopass)\n-    {\n-      gfc_error (\"'%s' at %L overrides a NOPASS binding and must also be\"\n-\t\t \" NOPASS\", proc->name, &where);\n-      return FAILURE;\n-    }\n-\n-  /* If the overridden binding is PASS(x), the overriding one must also be\n-     PASS and the passed-object dummy arguments must correspond.  */\n-  if (!old->n.tb->nopass)\n-    {\n-      if (proc->n.tb->nopass)\n-\t{\n-\t  gfc_error (\"'%s' at %L overrides a binding with PASS and must also be\"\n-\t\t     \" PASS\", proc->name, &where);\n-\t  return FAILURE;\n-\t}\n-\n-      if (proc_pass_arg != old_pass_arg)\n-\t{\n-\t  gfc_error (\"Passed-object dummy argument of '%s' at %L must be at\"\n-\t\t     \" the same position as the passed-object dummy argument of\"\n-\t\t     \" the overridden procedure\", proc->name, &where);\n-\t  return FAILURE;\n-\t}\n-    }\n-\n-  return SUCCESS;\n-}\n-\n-\n /* Check if two GENERIC targets are ambiguous and emit an error is they are.  */\n \n static gfc_try\n@@ -11327,11 +11133,14 @@ resolve_typebound_procedure (gfc_symtree* stree)\n       overridden = gfc_find_typebound_proc (super_type, NULL,\n \t\t\t\t\t    stree->name, true, NULL);\n \n-      if (overridden && overridden->n.tb)\n-\tstree->n.tb->overridden = overridden->n.tb;\n+      if (overridden)\n+\t{\n+\t  if (overridden->n.tb)\n+\t    stree->n.tb->overridden = overridden->n.tb;\n \n-      if (overridden && check_typebound_override (stree, overridden) == FAILURE)\n-\tgoto error;\n+\t  if (gfc_check_typebound_override (stree, overridden) == FAILURE)\n+\t    goto error;\n+\t}\n     }\n \n   /* See if there's a name collision with a component directly in this type.  */"}]}