{"sha": "68a607d8143693c8f4bc66bef001197ea4ff7c84", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjhhNjA3ZDgxNDM2OTNjOGY0YmM2NmJlZjAwMTE5N2VhNGZmN2M4NA==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2009-04-14T20:18:49Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2009-04-14T20:18:49Z"}, "message": "[multiple changes]\n\n2009-04-14  Diego Novillo  <dnovillo@google.com>\n\t    Le-Chun Wu  <lcwu@google.com>\n\n\t* configure.ac: Add --enable-plugin support.\n\tDefine ENABLE_PLUGIN and PLUGINLIBS when specified.\n\t* Makefile.in (PLUGIN_H): Define.\n\tExport ENABLE_PLUGIN and GMPINC to site.exp.\n\tAdd PLUGINLIBS to link command.\n\tAdd/modify dependencies for plugin.o and files including plugin.h.\n\t(plugin.o): New.\n\t* config.in: Regenerate.\n\t\n\t* opts.c (common_handle_option): Handle OPT_fplugin_ and\n\tOPT_fplugin_arg_.\n\n2009-04-14  Le-Chun Wu  <lcwu@google.com>\n\n\t* tree-pass.h (register_one_dump_file): Add a prototype for\n\tregister_one_dump_file.\n\t* toplev.c (compile_file): Call initialize_plugins.\n\t(do_compile): Call invoke_plugin_callbacks.\n\t(toplev_main): Call invoke_plugin_callbacks.\n\t* common.opt: Add -fplugin= and -fplugin-arg-.\n\t* gcc-plugin.h: New public header file for plugins to include.\n\t* plugin.c: New source file.\n\t* plugin.h: New internal header file.\n\t* passes.c (register_one_dump_file): Make it external.\n\t\n\t* c-parser.c (c_parser_declspecs): Call invoke_plugin_callbacks.\n\n2009-04-14  Diego Novillo  <dnovillo@google.com>\n\n\t* doc/plugins.texi: New.\n\t* doc/gccint.texi: Add reference to Plugins chapter.\n\t* doc/invoke.texi: Document -fplugin and -fplugin-arg\n\t* diagnostic.c (diagnostic_report_diagnostic): Warn about\n\tloaded plugins, if any.\n\t* timevar.def (TV_PLUGIN_INIT): Define.\n\t(TV_PLUGIN_RUN): Define.\n\t* plugin.c: Include timevar.h\n\t(plugins_active_p): New.\n\t(dump_active_plugins): New.\n\t(debug_active_plugins): New.\n\n\ncp/ChangeLog\n\n2009-04-14  Le-Chun Wu  <lcwu@google.com>\n\n\t* Make-lang.in: Modify dependencies of files including plugin.h.\n\t* decl.c (finish_function): Call invoke_plugin_callbacks.\n\t* parser.c (cp_parser_type_specifier): Call invoke_plugin_callbacks.\n\nFrom-SVN: r146059", "tree": {"sha": "a65b40c88b9169d2d76f8139339fd3054612f224", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a65b40c88b9169d2d76f8139339fd3054612f224"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68a607d8143693c8f4bc66bef001197ea4ff7c84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68a607d8143693c8f4bc66bef001197ea4ff7c84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68a607d8143693c8f4bc66bef001197ea4ff7c84", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68a607d8143693c8f4bc66bef001197ea4ff7c84/comments", "author": null, "committer": null, "parents": [{"sha": "50617257085372785e4385d166b2fba4b634ee54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50617257085372785e4385d166b2fba4b634ee54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50617257085372785e4385d166b2fba4b634ee54"}], "stats": {"total": 1417, "additions": 1392, "deletions": 25}, "files": [{"sha": "eae509530ca1f5f4ad17e00d09c74d708ef17c92", "filename": "gcc/ChangeLog", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=68a607d8143693c8f4bc66bef001197ea4ff7c84", "patch": "@@ -1,3 +1,47 @@\n+2009-04-14  Diego Novillo  <dnovillo@google.com>\n+\t    Le-Chun Wu  <lcwu@google.com>\n+\n+\t* configure.ac: Add --enable-plugin support.\n+\tDefine ENABLE_PLUGIN and PLUGINLIBS when specified.\n+\t* Makefile.in (PLUGIN_H): Define.\n+\tExport ENABLE_PLUGIN and GMPINC to site.exp.\n+\tAdd PLUGINLIBS to link command.\n+\tAdd/modify dependencies for plugin.o and files including plugin.h.\n+\t(plugin.o): New.\n+\t* config.in: Regenerate.\n+\t\n+\t* opts.c (common_handle_option): Handle OPT_fplugin_ and\n+\tOPT_fplugin_arg_.\n+\n+2009-04-14  Le-Chun Wu  <lcwu@google.com>\n+\n+\t* tree-pass.h (register_one_dump_file): Add a prototype for\n+\tregister_one_dump_file.\n+\t* toplev.c (compile_file): Call initialize_plugins.\n+\t(do_compile): Call invoke_plugin_callbacks.\n+\t(toplev_main): Call invoke_plugin_callbacks.\n+\t* common.opt: Add -fplugin= and -fplugin-arg-.\n+\t* gcc-plugin.h: New public header file for plugins to include.\n+\t* plugin.c: New source file.\n+\t* plugin.h: New internal header file.\n+\t* passes.c (register_one_dump_file): Make it external.\n+\t\n+\t* c-parser.c (c_parser_declspecs): Call invoke_plugin_callbacks.\n+\n+2009-04-14  Diego Novillo  <dnovillo@google.com>\n+\n+\t* doc/plugins.texi: New.\n+\t* doc/gccint.texi: Add reference to Plugins chapter.\n+\t* doc/invoke.texi: Document -fplugin and -fplugin-arg\n+\t* diagnostic.c (diagnostic_report_diagnostic): Warn about\n+\tloaded plugins, if any.\n+\t* timevar.def (TV_PLUGIN_INIT): Define.\n+\t(TV_PLUGIN_RUN): Define.\n+\t* plugin.c: Include timevar.h\n+\t(plugins_active_p): New.\n+\t(dump_active_plugins): New.\n+\t(debug_active_plugins): New.\n+\n 2009-04-14  Joseph Myers  <joseph@codesourcery.com>\n \n \t* config/sol2.h (LINK_ARCH32_SPEC_BASE): Use %R with absolute\n@@ -21,7 +65,7 @@\n \n \t2008-12-19  Diego Novillo  <dnovillo@google.com>\n \n-        \t* cgraph.c (dump_cgraph_node): Show memory address of NODE.\n+\t       \t* cgraph.c (dump_cgraph_node): Show memory address of NODE.\n \n 2000-04-14  Richard Guenther  <rguenther@suse.de>\n "}, {"sha": "3b748d4fd23d86189b9e9a7045b5a4f1f66d048c", "filename": "gcc/Makefile.in", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=68a607d8143693c8f4bc66bef001197ea4ff7c84", "patch": "@@ -283,6 +283,9 @@ PPLINC = @PPLINC@\n CLOOGLIBS = @CLOOGLIBS@\n CLOOGINC = @CLOOGINC@\n \n+# Libs and linker option needed for plugin support\n+PLUGINLIBS = @pluginlibs@\n+\n CPPLIB = ../libcpp/libcpp.a\n CPPINC = -I$(srcdir)/../libcpp/include\n \n@@ -872,6 +875,7 @@ EBIMAP_H = ebitmap.h sbitmap.h\n IPA_PROP_H = ipa-prop.h $(TREE_H) vec.h $(CGRAPH_H)\n GSTAB_H = gstab.h stab.def\n BITMAP_H = bitmap.h $(HASHTAB_H) statistics.h\n+PLUGIN_H = plugin.h gcc-plugin.h\n \n #\f\n # Now figure out from those variables how to compile and link.\n@@ -906,7 +910,7 @@ BUILD_LIBDEPS= $(BUILD_LIBIBERTY)\n # How to link with both our special library facilities\n # and the system's installed libraries.\n LIBS = @LIBS@ $(CPPLIB) $(LIBINTL) $(LIBICONV) $(LIBIBERTY) $(LIBDECNUMBER)\n-BACKENDLIBS = $(CLOOGLIBS) $(PPLLIBS) $(GMPLIBS)\n+BACKENDLIBS = $(CLOOGLIBS) $(PPLLIBS) $(GMPLIBS) $(PLUGINLIBS)\n # Any system libraries needed just for GNAT.\n SYSLIBS = @GNAT_LIBEXC@\n \n@@ -1148,6 +1152,7 @@ OBJS-common = \\\n \topts.o \\\n \tparams.o \\\n \tpasses.o \\\n+\tplugin.o \\\n \tpointer-set.o \\\n \tpostreload-gcse.o \\\n \tpostreload.o \\\n@@ -1800,7 +1805,7 @@ c-errors.o: c-errors.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n c-parser.o : c-parser.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n     $(GGC_H) $(TIMEVAR_H) $(C_TREE_H) $(INPUT_H) $(FLAGS_H) $(TOPLEV_H) output.h \\\n     $(CPPLIB_H) gt-c-parser.h $(RTL_H) langhooks.h $(C_COMMON_H) $(C_PRAGMA_H) \\\n-    vec.h $(TARGET_H) $(CGRAPH_H)\n+    vec.h $(TARGET_H) $(CGRAPH_H) $(PLUGIN_H)\n \n srcextra: gcc.srcextra lang.srcextra\n \n@@ -2422,11 +2427,12 @@ fold-const.o : fold-const.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(GIMPLE_H)\n diagnostic.o : diagnostic.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) version.h $(TM_P_H) $(FLAGS_H) $(INPUT_H) $(TOPLEV_H) intl.h \\\n-   $(DIAGNOSTIC_H) langhooks.h $(LANGHOOKS_DEF_H) diagnostic.def opts.h\n+   $(DIAGNOSTIC_H) langhooks.h $(LANGHOOKS_DEF_H) diagnostic.def opts.h \\\n+   $(PLUGIN_H)\n opts.o : opts.c opts.h options.h $(TOPLEV_H) $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TREE_H) $(TM_H) langhooks.h $(GGC_H) $(EXPR_H) $(RTL_H) \\\n    output.h $(DIAGNOSTIC_H) $(TM_P_H) $(INSN_ATTR_H) intl.h $(TARGET_H) \\\n-   $(FLAGS_H) $(PARAMS_H) tree-pass.h $(DBGCNT_H) debug.h varray.h\n+   $(FLAGS_H) $(PARAMS_H) tree-pass.h $(DBGCNT_H) debug.h varray.h $(PLUGIN_H)\n opts-common.o : opts-common.c opts.h $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h intl.h\n targhooks.o : targhooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TREE_H) \\\n@@ -2443,7 +2449,7 @@ toplev.o : toplev.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    langhooks.h insn-flags.h $(CFGLAYOUT_H) $(CFGLOOP_H) hosthooks.h \\\n    $(CGRAPH_H) $(COVERAGE_H) alloc-pool.h $(GGC_H) $(INTEGRATE_H) \\\n    opts.h params.def tree-mudflap.h $(REAL_H) tree-pass.h $(GIMPLE_H) \\\n-   tree-ssa-alias.h\n+   tree-ssa-alias.h $(PLUGIN_H)\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) \\\n \t  -DTARGET_NAME=\\\"$(target_noncanonical)\\\" \\\n \t  -c $(srcdir)/toplev.c $(OUTPUT_OPTION)\n@@ -2459,6 +2465,9 @@ passes.o : passes.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(GGC_H) $(INTEGRATE_H) $(CPPLIB_H) opts.h $(TREE_FLOW_H) $(TREE_INLINE_H) \\\n    gt-passes.h $(DF_H) $(PREDICT_H)\n \n+plugin.o : plugin.c $(PLUGIN_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+   errors.h $(TOPLEV_H) $(TREE_H) tree-pass.h intl.h\n+\n main.o : main.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TOPLEV_H)\n \n host-default.o : host-default.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n@@ -4247,6 +4256,10 @@ site.exp: ./config.status Makefile\n \t@echo \"set TEST_GCC_EXEC_PREFIX \\\"$(libdir)/gcc/\\\"\" >> ./tmp0\n \t@echo \"set TESTING_IN_BUILD_TREE 1\" >> ./tmp0\n \t@echo \"set HAVE_LIBSTDCXX_V3 1\" >> ./tmp0\n+\t@if test \"@enable_plugin@\" = \"yes\" ; then \\\n+\t  echo \"set ENABLE_PLUGIN 1\" >> ./tmp0; \\\n+\t  echo \"set GMPINC \\\"$(GMPINC)\\\"\" >> ./tmp0; \\\n+\tfi\n # If newlib has been configured, we need to pass -B to gcc so it can find\n # newlib's crt0.o if it exists.  This will cause a \"path prefix not used\"\n # message if it doesn't, but the testsuite is supposed to ignore the message -"}, {"sha": "c5f573a028b93275a97087bd2d9528ba3ee3a433", "filename": "gcc/c-decl.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=68a607d8143693c8f4bc66bef001197ea4ff7c84", "patch": "@@ -63,6 +63,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"langhooks-def.h\"\n #include \"pointer-set.h\"\n #include \"gimple.h\"\n+#include \"plugin.h\"\n \n /* In grokdeclarator, distinguish syntactic contexts of declarators.  */\n enum decl_context\n@@ -7261,6 +7262,9 @@ struct c_declspecs *\n declspecs_add_type (struct c_declspecs *specs, struct c_typespec spec)\n {\n   tree type = spec.spec;\n+\n+  invoke_plugin_callbacks (PLUGIN_FINISH_TYPE, type);\n+\n   specs->non_sc_seen_p = true;\n   specs->declspecs_seen_p = true;\n   specs->type_seen_p = true;"}, {"sha": "1443bc5b6c4bf091f61b333e035d1f8902d852f5", "filename": "gcc/c-parser.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=68a607d8143693c8f4bc66bef001197ea4ff7c84", "patch": "@@ -57,6 +57,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"vec.h\"\n #include \"target.h\"\n #include \"cgraph.h\"\n+#include \"plugin.h\"\n \n \f\n /* Initialization routine for this file.  */"}, {"sha": "f85b943f7de370a88dc2025b1f26403e38e187d7", "filename": "gcc/common.opt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=68a607d8143693c8f4bc66bef001197ea4ff7c84", "patch": "@@ -854,6 +854,14 @@ fpie\n Common Report Var(flag_pie,1) VarExists\n Generate position-independent code for executables if possible (small mode)\n \n+fplugin=\n+Common Joined RejectNegative\n+Specify a plugin to load\n+\n+fplugin-arg-\n+Common Joined RejectNegative\n+-fplugin-arg-<name>-<key>[=<value>] Specify argument <key>=<value> for plugin <name>\n+\n fpredictive-commoning\n Common Report Var(flag_predictive_commoning) Optimization\n Run predictive commoning optimization."}, {"sha": "f45ea338a4c5272a11b744b4e3cf04e8d719064e", "filename": "gcc/config.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=68a607d8143693c8f4bc66bef001197ea4ff7c84", "patch": "@@ -108,6 +108,12 @@\n #endif\n \n \n+/* Define to enable plugin support. */\n+#ifndef USED_FOR_TARGET\n+#undef ENABLE_PLUGIN\n+#endif\n+\n+\n /* Define if you want all operations on RTL (the basic data structure of the\n    optimizer and back end) to be checked for dynamic type safety at runtime.\n    This is quite expensive. */"}, {"sha": "dbe7426fab1c60872ba17af1515593d0c2f09c81", "filename": "gcc/configure", "status": "modified", "additions": 232, "deletions": 15, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=68a607d8143693c8f4bc66bef001197ea4ff7c84", "patch": "@@ -458,7 +458,7 @@ ac_includes_default=\"\\\n # include <unistd.h>\n #endif\"\n \n-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os target_noncanonical build_libsubdir build_subdir host_subdir target_subdir GENINSRC CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT GNATBIND ac_ct_GNATBIND GNATMAKE ac_ct_GNATMAKE NO_MINUS_C_MINUS_O OUTPUT_OPTION CPP EGREP loose_warn strict_warn warn_cflags nocommon_flag TREEBROWSER valgrind_path valgrind_path_defines valgrind_command coverage_flags enable_multilib enable_decimal_float enable_fixed_point enable_shared TARGET_SYSTEM_ROOT TARGET_SYSTEM_ROOT_DEFINE CROSS_SYSTEM_HEADER_DIR onestep PKGVERSION REPORT_BUGS_TO REPORT_BUGS_TEXI datarootdir docdir htmldir SET_MAKE AWK LN_S LN RANLIB ac_ct_RANLIB ranlib_flags INSTALL INSTALL_PROGRAM INSTALL_DATA make_compare_target have_mktemp_command MAKEINFO BUILD_INFO GENERATED_MANPAGES FLEX BISON NM AR COLLECT2_LIBS GNAT_LIBEXC LDEXP_LIB LIBICONV LTLIBICONV LIBICONV_DEP manext objext gthread_flags extra_modes_file extra_opt_files USE_NLS LIBINTL LIBINTL_DEP INCINTL XGETTEXT GMSGFMT POSUB CATALOGS DATADIRNAME INSTOBJEXT GENCAT CATOBJEXT CROSS ALL SYSTEM_HEADER_DIR inhibit_libc CC_FOR_BUILD BUILD_CFLAGS BUILD_LDFLAGS STMP_FIXINC collect2 LIBTOOL SED FGREP GREP LD DUMPBIN ac_ct_DUMPBIN OBJDUMP ac_ct_OBJDUMP ac_ct_AR STRIP ac_ct_STRIP lt_ECHO DSYMUTIL ac_ct_DSYMUTIL NMEDIT ac_ct_NMEDIT LIPO ac_ct_LIPO OTOOL ac_ct_OTOOL OTOOL64 ac_ct_OTOOL64 objdir enable_fast_install gcc_cv_as ORIGINAL_AS_FOR_TARGET gcc_cv_ld ORIGINAL_LD_FOR_TARGET gcc_cv_nm ORIGINAL_NM_FOR_TARGET gcc_cv_objdump gcc_cv_readelf libgcc_visibility GGC zlibdir zlibinc MAINT gcc_tooldir dollar slibdir subdirs srcdir all_compilers all_gtfiles all_lang_makefrags all_lang_makefiles all_languages all_selected_languages build_exeext build_install_headers_dir build_xm_file_list build_xm_include_list build_xm_defines build_file_translate check_languages cpp_install_dir xmake_file tmake_file extra_gcc_objs extra_headers_list extra_objs extra_parts extra_passes extra_programs float_h_file gcc_config_arguments gcc_gxx_include_dir host_exeext host_xm_file_list host_xm_include_list host_xm_defines out_host_hook_obj install lang_opt_files lang_specs_files lang_tree_files local_prefix md_file objc_boehm_gc out_file out_object_file thread_file tm_file_list tm_include_list tm_defines tm_p_file_list tm_p_include_list xm_file_list xm_include_list xm_defines use_gcc_stdint c_target_objs cxx_target_objs fortran_target_objs target_cpu_default GMPLIBS GMPINC PPLLIBS PPLINC CLOOGLIBS CLOOGINC LIBOBJS LTLIBOBJS'\n+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os target_noncanonical build_libsubdir build_subdir host_subdir target_subdir GENINSRC CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT GNATBIND ac_ct_GNATBIND GNATMAKE ac_ct_GNATMAKE NO_MINUS_C_MINUS_O OUTPUT_OPTION CPP EGREP loose_warn strict_warn warn_cflags nocommon_flag TREEBROWSER valgrind_path valgrind_path_defines valgrind_command coverage_flags enable_multilib enable_decimal_float enable_fixed_point enable_shared TARGET_SYSTEM_ROOT TARGET_SYSTEM_ROOT_DEFINE CROSS_SYSTEM_HEADER_DIR onestep PKGVERSION REPORT_BUGS_TO REPORT_BUGS_TEXI datarootdir docdir htmldir SET_MAKE AWK LN_S LN RANLIB ac_ct_RANLIB ranlib_flags INSTALL INSTALL_PROGRAM INSTALL_DATA make_compare_target have_mktemp_command MAKEINFO BUILD_INFO GENERATED_MANPAGES FLEX BISON NM AR COLLECT2_LIBS GNAT_LIBEXC LDEXP_LIB LIBICONV LTLIBICONV LIBICONV_DEP manext objext gthread_flags extra_modes_file extra_opt_files USE_NLS LIBINTL LIBINTL_DEP INCINTL XGETTEXT GMSGFMT POSUB CATALOGS DATADIRNAME INSTOBJEXT GENCAT CATOBJEXT CROSS ALL SYSTEM_HEADER_DIR inhibit_libc CC_FOR_BUILD BUILD_CFLAGS BUILD_LDFLAGS STMP_FIXINC collect2 LIBTOOL SED FGREP GREP LD DUMPBIN ac_ct_DUMPBIN OBJDUMP ac_ct_OBJDUMP ac_ct_AR STRIP ac_ct_STRIP lt_ECHO DSYMUTIL ac_ct_DSYMUTIL NMEDIT ac_ct_NMEDIT LIPO ac_ct_LIPO OTOOL ac_ct_OTOOL OTOOL64 ac_ct_OTOOL64 objdir enable_fast_install gcc_cv_as ORIGINAL_AS_FOR_TARGET gcc_cv_ld ORIGINAL_LD_FOR_TARGET gcc_cv_nm ORIGINAL_NM_FOR_TARGET gcc_cv_objdump gcc_cv_readelf libgcc_visibility GGC zlibdir zlibinc MAINT gcc_tooldir dollar slibdir subdirs srcdir all_compilers all_gtfiles all_lang_makefrags all_lang_makefiles all_languages all_selected_languages build_exeext build_install_headers_dir build_xm_file_list build_xm_include_list build_xm_defines build_file_translate check_languages cpp_install_dir xmake_file tmake_file extra_gcc_objs extra_headers_list extra_objs extra_parts extra_passes extra_programs float_h_file gcc_config_arguments gcc_gxx_include_dir host_exeext host_xm_file_list host_xm_include_list host_xm_defines out_host_hook_obj install lang_opt_files lang_specs_files lang_tree_files local_prefix md_file objc_boehm_gc out_file out_object_file thread_file tm_file_list tm_include_list tm_defines tm_p_file_list tm_p_include_list xm_file_list xm_include_list xm_defines use_gcc_stdint c_target_objs cxx_target_objs fortran_target_objs target_cpu_default GMPLIBS GMPINC PPLLIBS PPLINC CLOOGLIBS CLOOGINC pluginlibs enable_plugin LIBOBJS LTLIBOBJS'\n ac_subst_files='language_hooks'\n ac_pwd=`pwd`\n \n@@ -1084,6 +1084,7 @@ Optional Features:\n   --enable-version-specific-runtime-libs\n                           specify that runtime libraries should be\n                           installed in a compiler-specific directory\n+  --enable-plugin         enable plugin support\n \n Optional Packages:\n   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]\n@@ -14348,13 +14349,13 @@ if test \"${lt_cv_nm_interface+set}\" = set; then\n else\n   lt_cv_nm_interface=\"BSD nm\"\n   echo \"int some_variable = 0;\" > conftest.$ac_ext\n-  (eval echo \"\\\"\\$as_me:14351: $ac_compile\\\"\" >&5)\n+  (eval echo \"\\\"\\$as_me:14352: $ac_compile\\\"\" >&5)\n   (eval \"$ac_compile\" 2>conftest.err)\n   cat conftest.err >&5\n-  (eval echo \"\\\"\\$as_me:14354: $NM \\\\\\\"conftest.$ac_objext\\\\\\\"\\\"\" >&5)\n+  (eval echo \"\\\"\\$as_me:14355: $NM \\\\\\\"conftest.$ac_objext\\\\\\\"\\\"\" >&5)\n   (eval \"$NM \\\"conftest.$ac_objext\\\"\" 2>conftest.err > conftest.out)\n   cat conftest.err >&5\n-  (eval echo \"\\\"\\$as_me:14357: output\\\"\" >&5)\n+  (eval echo \"\\\"\\$as_me:14358: output\\\"\" >&5)\n   cat conftest.out >&5\n   if $GREP 'External.*some_variable' conftest.out > /dev/null; then\n     lt_cv_nm_interface=\"MS dumpbin\"\n@@ -15511,7 +15512,7 @@ ia64-*-hpux*)\n   ;;\n *-*-irix6*)\n   # Find out which ABI we are using.\n-  echo '#line 15514 \"configure\"' > conftest.$ac_ext\n+  echo '#line 15515 \"configure\"' > conftest.$ac_ext\n   if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   (eval $ac_compile) 2>&5\n   ac_status=$?\n@@ -16810,11 +16811,11 @@ else\n    -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n    -e 's: [^ ]*conftest\\.: $lt_compiler_flag&:; t' \\\n    -e 's:$: $lt_compiler_flag:'`\n-   (eval echo \"\\\"\\$as_me:16813: $lt_compile\\\"\" >&5)\n+   (eval echo \"\\\"\\$as_me:16814: $lt_compile\\\"\" >&5)\n    (eval \"$lt_compile\" 2>conftest.err)\n    ac_status=$?\n    cat conftest.err >&5\n-   echo \"$as_me:16817: \\$? = $ac_status\" >&5\n+   echo \"$as_me:16818: \\$? = $ac_status\" >&5\n    if (exit $ac_status) && test -s \"$ac_outfile\"; then\n      # The compiler can only warn and ignore the option if not recognized\n      # So say no if there are warnings other than the usual output.\n@@ -17149,11 +17150,11 @@ else\n    -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n    -e 's: [^ ]*conftest\\.: $lt_compiler_flag&:; t' \\\n    -e 's:$: $lt_compiler_flag:'`\n-   (eval echo \"\\\"\\$as_me:17152: $lt_compile\\\"\" >&5)\n+   (eval echo \"\\\"\\$as_me:17153: $lt_compile\\\"\" >&5)\n    (eval \"$lt_compile\" 2>conftest.err)\n    ac_status=$?\n    cat conftest.err >&5\n-   echo \"$as_me:17156: \\$? = $ac_status\" >&5\n+   echo \"$as_me:17157: \\$? = $ac_status\" >&5\n    if (exit $ac_status) && test -s \"$ac_outfile\"; then\n      # The compiler can only warn and ignore the option if not recognized\n      # So say no if there are warnings other than the usual output.\n@@ -17254,11 +17255,11 @@ else\n    -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n    -e 's: [^ ]*conftest\\.: $lt_compiler_flag&:; t' \\\n    -e 's:$: $lt_compiler_flag:'`\n-   (eval echo \"\\\"\\$as_me:17257: $lt_compile\\\"\" >&5)\n+   (eval echo \"\\\"\\$as_me:17258: $lt_compile\\\"\" >&5)\n    (eval \"$lt_compile\" 2>out/conftest.err)\n    ac_status=$?\n    cat out/conftest.err >&5\n-   echo \"$as_me:17261: \\$? = $ac_status\" >&5\n+   echo \"$as_me:17262: \\$? = $ac_status\" >&5\n    if (exit $ac_status) && test -s out/conftest2.$ac_objext\n    then\n      # The compiler can only warn and ignore the option if not recognized\n@@ -17309,11 +17310,11 @@ else\n    -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n    -e 's: [^ ]*conftest\\.: $lt_compiler_flag&:; t' \\\n    -e 's:$: $lt_compiler_flag:'`\n-   (eval echo \"\\\"\\$as_me:17312: $lt_compile\\\"\" >&5)\n+   (eval echo \"\\\"\\$as_me:17313: $lt_compile\\\"\" >&5)\n    (eval \"$lt_compile\" 2>out/conftest.err)\n    ac_status=$?\n    cat out/conftest.err >&5\n-   echo \"$as_me:17316: \\$? = $ac_status\" >&5\n+   echo \"$as_me:17317: \\$? = $ac_status\" >&5\n    if (exit $ac_status) && test -s out/conftest2.$ac_objext\n    then\n      # The compiler can only warn and ignore the option if not recognized\n@@ -20121,7 +20122,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 20124 \"configure\"\n+#line 20125 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -20217,7 +20218,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 20220 \"configure\"\n+#line 20221 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -24680,6 +24681,220 @@ _ACEOF\n \n fi\n \n+# Check for plugin support\n+# Check whether --enable-plugin or --disable-plugin was given.\n+if test \"${enable_plugin+set}\" = set; then\n+  enableval=\"$enable_plugin\"\n+  enable_plugin=$enableval\n+else\n+  enable_plugin=yes; default_plugin=yes\n+fi;\n+\n+pluginlibs=\n+if test x\"$enable_plugin\" = x\"yes\"; then\n+  # Check that the host supports -rdynamic and -ldl\n+  have_rdynamic=no\n+  have_dl=no\n+  saved_LDFLAGS=\"$LDFLAGS\"\n+  saved_LIBS=\"$LIBS\"\n+  LIBS=\n+\n+  # Check -rdynamic\n+  LDFLAGS=\"$LDFLAGS -rdynamic\"\n+  echo \"$as_me:$LINENO: checking for -rdynamic\" >&5\n+echo $ECHO_N \"checking for -rdynamic... $ECHO_C\" >&6\n+  cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+int\n+main ()\n+{\n+return 0;\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext conftest$ac_exeext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n+  (eval $ac_link) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest$ac_exeext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  echo \"$as_me:$LINENO: result: yes\" >&5\n+echo \"${ECHO_T}yes\" >&6; have_rdynamic=yes\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+echo \"$as_me:$LINENO: result: no\" >&5\n+echo \"${ECHO_T}no\" >&6\n+fi\n+rm -f conftest.err conftest.$ac_objext \\\n+      conftest$ac_exeext conftest.$ac_ext\n+  if test x\"$have_rdynamic\" = x\"yes\" ; then\n+    pluginlibs=\"-rdynamic\"\n+  fi\n+\n+  # Check -ldl\n+  LDFLAGS=\"$LDFLAGS -ldl\"\n+  echo \"$as_me:$LINENO: checking for -ldl\" >&5\n+echo $ECHO_N \"checking for -ldl... $ECHO_C\" >&6\n+  cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+#include <dlfcn.h>\n+int\n+main ()\n+{\n+volatile int f = 0; if (f) dlopen (\"dummy\", 0);\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext conftest$ac_exeext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n+  (eval $ac_link) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest$ac_exeext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  echo \"$as_me:$LINENO: result: yes\" >&5\n+echo \"${ECHO_T}yes\" >&6; have_dl=yes\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+echo \"$as_me:$LINENO: result: no\" >&5\n+echo \"${ECHO_T}no\" >&6\n+fi\n+rm -f conftest.err conftest.$ac_objext \\\n+      conftest$ac_exeext conftest.$ac_ext\n+  if test x\"$have_dl\" = x\"yes\"; then\n+    pluginlibs=\"$pluginlibs -ldl\"\n+  fi\n+\n+  # Check that we can build shared objects with -fPIC -shared\n+  LDFLAGS=\"$LDFLAGS -fPIC -shared\"\n+  echo \"$as_me:$LINENO: checking for -fPIC -shared\" >&5\n+echo $ECHO_N \"checking for -fPIC -shared... $ECHO_C\" >&6\n+  cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+extern int X;\n+int\n+main ()\n+{\n+return X == 0;\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext conftest$ac_exeext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n+  (eval $ac_link) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest$ac_exeext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  echo \"$as_me:$LINENO: result: yes\" >&5\n+echo \"${ECHO_T}yes\" >&6; have_pic_shared=yes\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+echo \"$as_me:$LINENO: result: no\" >&5\n+echo \"${ECHO_T}no\" >&6; have_pic_shared=no\n+fi\n+rm -f conftest.err conftest.$ac_objext \\\n+      conftest$ac_exeext conftest.$ac_ext\n+  if test x\"$have_pic_shared\" != x\"yes\"; then\n+    pluginlibs=\n+    enable_plugin=no\n+  fi\n+\n+  # If plugin support had been requested but not available, fail.\n+  if test x\"$enable_plugin\" = x\"no\" ; then\n+    if test x\"$default_plugin\" != x\"yes\"; then\n+      { { echo \"$as_me:$LINENO: error:\n+Building GCC with plugin support requires a host that supports\n+-fPIC, -shared, -ldl and -rdynamic.\" >&5\n+echo \"$as_me: error:\n+Building GCC with plugin support requires a host that supports\n+-fPIC, -shared, -ldl and -rdynamic.\" >&2;}\n+   { (exit 1); exit 1; }; }\n+    fi\n+  fi\n+\n+  LDFLAGS=\"$saved_LDFLAGS\"\n+  LIBS=\"$saved_LIBS\"\n+fi\n+\n+\n+\n+if test x\"$enable_plugin\" = x\"yes\"; then\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define ENABLE_PLUGIN 1\n+_ACEOF\n+\n+fi\n+\n # Configure the subdirectories\n # AC_CONFIG_SUBDIRS($subdirs)\n \n@@ -25524,6 +25739,8 @@ s,@PPLLIBS@,$PPLLIBS,;t t\n s,@PPLINC@,$PPLINC,;t t\n s,@CLOOGLIBS@,$CLOOGLIBS,;t t\n s,@CLOOGINC@,$CLOOGINC,;t t\n+s,@pluginlibs@,$pluginlibs,;t t\n+s,@enable_plugin@,$enable_plugin,;t t\n s,@LIBOBJS@,$LIBOBJS,;t t\n s,@LTLIBOBJS@,$LTLIBOBJS,;t t\n /@language_hooks@/r $language_hooks"}, {"sha": "07e4c6d73fb9798cce2f22507d389f963bf1f380", "filename": "gcc/configure.ac", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=68a607d8143693c8f4bc66bef001197ea4ff7c84", "patch": "@@ -3949,6 +3949,74 @@ if test \"x${CLOOGLIBS}\" != \"x\" ; then\n    AC_DEFINE(HAVE_cloog, 1, [Define if cloog is in use.])\n fi\n \n+# Check for plugin support\n+AC_ARG_ENABLE(plugin,\n+[  --enable-plugin         enable plugin support],\n+enable_plugin=$enableval,\n+enable_plugin=yes; default_plugin=yes)\n+\n+pluginlibs=\n+if test x\"$enable_plugin\" = x\"yes\"; then\n+  # Check that the host supports -rdynamic and -ldl\n+  have_rdynamic=no\n+  have_dl=no\n+  saved_LDFLAGS=\"$LDFLAGS\"\n+  saved_LIBS=\"$LIBS\"\n+  LIBS=\n+\n+  # Check -rdynamic\n+  LDFLAGS=\"$LDFLAGS -rdynamic\"\n+  AC_MSG_CHECKING([for -rdynamic])\n+  AC_TRY_LINK([],[return 0;],\n+    [AC_MSG_RESULT([yes]); have_rdynamic=yes],\n+    [AC_MSG_RESULT([no])])\n+  if test x\"$have_rdynamic\" = x\"yes\" ; then\n+    pluginlibs=\"-rdynamic\"\n+  fi\n+\n+  # Check -ldl\n+  LDFLAGS=\"$LDFLAGS -ldl\"\n+  AC_MSG_CHECKING([for -ldl])\n+  AC_TRY_LINK(\n+    [#include <dlfcn.h>],\n+    [volatile int f = 0; if (f) dlopen (\"dummy\", 0);],\n+    [AC_MSG_RESULT([yes]); have_dl=yes],\n+    [AC_MSG_RESULT([no])])\n+  if test x\"$have_dl\" = x\"yes\"; then\n+    pluginlibs=\"$pluginlibs -ldl\"\n+  fi\n+\n+  # Check that we can build shared objects with -fPIC -shared\n+  LDFLAGS=\"$LDFLAGS -fPIC -shared\"\n+  AC_MSG_CHECKING([for -fPIC -shared])\n+  AC_TRY_LINK(\n+    [extern int X;],[return X == 0;],\n+    [AC_MSG_RESULT([yes]); have_pic_shared=yes],\n+    [AC_MSG_RESULT([no]); have_pic_shared=no])\n+  if test x\"$have_pic_shared\" != x\"yes\"; then\n+    pluginlibs=\n+    enable_plugin=no\n+  fi\n+\n+  # If plugin support had been requested but not available, fail.\n+  if test x\"$enable_plugin\" = x\"no\" ; then\n+    if test x\"$default_plugin\" != x\"yes\"; then\n+      AC_MSG_ERROR([\n+Building GCC with plugin support requires a host that supports\n+-fPIC, -shared, -ldl and -rdynamic.])\n+    fi\n+  fi\n+\n+  LDFLAGS=\"$saved_LDFLAGS\"\n+  LIBS=\"$saved_LIBS\"\n+fi\n+\n+AC_SUBST(pluginlibs)\n+AC_SUBST(enable_plugin)\n+if test x\"$enable_plugin\" = x\"yes\"; then\n+  AC_DEFINE(ENABLE_PLUGIN, 1, [Define to enable plugin support.])\n+fi\n+\n # Configure the subdirectories\n # AC_CONFIG_SUBDIRS($subdirs)\n "}, {"sha": "23d135b47496a6e4102d7343006e8cf2bb4ca750", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=68a607d8143693c8f4bc66bef001197ea4ff7c84", "patch": "@@ -1,3 +1,9 @@\n+2009-04-14  Le-Chun Wu  <lcwu@google.com>\n+\n+\t* Make-lang.in: Modify dependencies of files including plugin.h.\n+\t* decl.c (finish_function): Call invoke_plugin_callbacks.\n+\t* parser.c (cp_parser_type_specifier): Call invoke_plugin_callbacks.\n+\n 2009-04-14  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/39763"}, {"sha": "aadaae6e044a86a57d887ed115581b82e3273f87", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=68a607d8143693c8f4bc66bef001197ea4ff7c84", "patch": "@@ -240,7 +240,7 @@ cp/cp-lang.o: cp/cp-lang.c $(CXX_TREE_H) $(TM_H) toplev.h debug.h langhooks.h \\\n cp/decl.o: cp/decl.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) cp/decl.h \\\n   output.h $(EXPR_H) except.h toplev.h $(HASHTAB_H) $(RTL_H) \\\n   cp/operators.def $(TM_P_H) $(TREE_INLINE_H) $(DIAGNOSTIC_H) $(C_PRAGMA_H) \\\n-  debug.h gt-cp-decl.h $(TIMEVAR_H) $(TREE_FLOW_H) $(TARGET_H)\n+  debug.h gt-cp-decl.h $(TIMEVAR_H) $(TREE_FLOW_H) $(TARGET_H) $(PLUGIN_H)\n cp/decl2.o: cp/decl2.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) cp/decl.h $(EXPR_H) \\\n   output.h except.h toplev.h $(RTL_H) $(C_COMMON_H) gt-cp-decl2.h $(CGRAPH_H) \\\n   $(C_PRAGMA_H) $(TREE_DUMP_H) intl.h $(TARGET_H) $(GIMPLE_H)\n@@ -292,7 +292,7 @@ cp/optimize.o: cp/optimize.c $(CXX_TREE_H) $(TM_H) rtl.h $(INTEGRATE_H) \\\n cp/mangle.o: cp/mangle.c $(CXX_TREE_H) $(TM_H) toplev.h $(REAL_H) \\\n   gt-cp-mangle.h $(TARGET_H) $(TM_P_H)\n cp/parser.o: cp/parser.c $(CXX_TREE_H) $(TM_H) $(DIAGNOSTIC_H) gt-cp-parser.h \\\n-  output.h $(TARGET_H)\n+  output.h $(TARGET_H) $(PLUGIN_H)\n cp/cp-gimplify.o: cp/cp-gimplify.c $(CXX_TREE_H) toplev.h $(C_COMMON_H) \\\n \t$(TM_H) coretypes.h pointer-set.h tree-iterator.h\n "}, {"sha": "5ab9392849b7f5cb91e6d796fbb380b2784981dd", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=68a607d8143693c8f4bc66bef001197ea4ff7c84", "patch": "@@ -53,6 +53,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"timevar.h\"\n #include \"tree-flow.h\"\n #include \"pointer-set.h\"\n+#include \"plugin.h\"\n \n static tree grokparms (tree parmlist, tree *);\n static const char *redeclaration_error_message (tree, tree);\n@@ -12354,6 +12355,7 @@ finish_function (int flags)\n   if (!processing_template_decl)\n     {\n       struct language_function *f = DECL_SAVED_FUNCTION_DATA (fndecl);\n+      invoke_plugin_callbacks (PLUGIN_CXX_CP_PRE_GENERICIZE, fndecl);\n       cp_genericize (fndecl);\n       /* Clear out the bits we don't need.  */\n       f->x_current_class_ptr = NULL;"}, {"sha": "8a8ca0654d4021221f1017b016391653b5552e9b", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=68a607d8143693c8f4bc66bef001197ea4ff7c84", "patch": "@@ -37,6 +37,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n #include \"cgraph.h\"\n #include \"c-common.h\"\n+#include \"plugin.h\"\n \n \f\n /* The lexer.  */\n@@ -13890,6 +13891,8 @@ cp_parser_type_specifier_seq (cp_parser* parser,\n \t  break;\n \t}\n \n+      invoke_plugin_callbacks (PLUGIN_FINISH_TYPE, type_specifier);\n+\n       seen_type_specifier = true;\n       /* The standard says that a condition can be:\n "}, {"sha": "c0648cd53b2f9fd0704a7883ca2c88f7359db1b2", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=68a607d8143693c8f4bc66bef001197ea4ff7c84", "patch": "@@ -40,6 +40,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"langhooks.h\"\n #include \"langhooks-def.h\"\n #include \"opts.h\"\n+#include \"plugin.h\"\n \n #define pedantic_warning_kind() (flag_pedantic_errors ? DK_ERROR : DK_WARNING)\n #define permissive_error_kind() (flag_permissive ? DK_WARNING : DK_ERROR)\n@@ -371,6 +372,17 @@ diagnostic_report_diagnostic (diagnostic_context *context,\n \n   context->lock++;\n \n+  if ((diagnostic->kind == DK_ERROR\n+       || diagnostic->kind == DK_WARNING\n+       || diagnostic->kind == DK_ICE)\n+      && plugins_active_p ())\n+    {\n+      fnotice (stderr, \"*** WARNING *** there are active plugins, do not report\"\n+\t       \" this as a bug unless you can reproduce it without enabling\"\n+\t       \" any plugins.\\n\");\n+      dump_active_plugins (stderr);\n+    }\n+\n   if (diagnostic->kind == DK_ICE) \n     {\n #ifndef ENABLE_CHECKING"}, {"sha": "265244b349ef20963ba6dd4057e80b5a57d85742", "filename": "gcc/doc/gccint.texi", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Fdoc%2Fgccint.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Fdoc%2Fgccint.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint.texi?ref=68a607d8143693c8f4bc66bef001197ea4ff7c84", "patch": "@@ -122,6 +122,7 @@ Additional tutorial information is linked to from\n * Collect2::        How @code{collect2} works; how it finds @code{ld}.\n * Header Dirs::     Understanding the standard header file directories.\n * Type Information:: GCC's memory management; generating type information.\n+* Plugins::         Extending the compiler with plugins.\n \n * Funding::         How to help assure funding for free software.\n * GNU Project::     The GNU Project and GNU/Linux.\n@@ -157,6 +158,7 @@ Additional tutorial information is linked to from\n @include collect2.texi\n @include headerdirs.texi\n @include gty.texi\n+@include plugins.texi\n \n @include funding.texi\n @include gnu.texi"}, {"sha": "554b6d93cada7326355311c7a370fe0042f01e6c", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=68a607d8143693c8f4bc66bef001197ea4ff7c84", "patch": "@@ -163,7 +163,7 @@ in the following sections.\n @xref{Overall Options,,Options Controlling the Kind of Output}.\n @gccoptlist{-c  -S  -E  -o @var{file}  -combine  -pipe  -pass-exit-codes  @gol\n -x @var{language}  -v  -###  --help@r{[}=@var{class}@r{[},@dots{}@r{]]}  --target-help  @gol\n---version -wrapper@@@var{file}}\n+--version -wrapper@@@var{file} -fplugin=@var{file} -fplugin-arg-@var{name}=@var{arg}}\n \n @item C Language Options\n @xref{C Dialect Options,,Options Controlling C Dialect}.\n@@ -1298,6 +1298,19 @@ gcc -c t.c -wrapper gdb,--args\n This will invoke all subprograms of gcc under \"gdb --args\",\n thus cc1 invocation will be \"gdb --args cc1 ...\".\n \n+@item -fplugin=@var{name}.so\n+Load the plugin code in file @var{name}.so, assumed to be a\n+shared object to be dlopen'd by the compiler.  The base name of\n+the shared object file is used to identify the plugin for the\n+purposes of argument parsing (See\n+@option{-fplugin-arg-@var{name}-@var{key}=@var{value}} below).\n+Each plugin should define the callback functions specified in the\n+Plugins API.\n+\n+@item -fplugin-arg-@var{name}-@var{key}=@var{value}\n+Define an argument called @var{key} with a value of @var{value}\n+for the plugin called @var{name}.\n+\n @include @value{srcdir}/../libiberty/at-file.texi\n @end table\n "}, {"sha": "7c3fbed354e95d6cccf0e32dd69a4ac7c4675a84", "filename": "gcc/doc/plugins.texi", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Fdoc%2Fplugins.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Fdoc%2Fplugins.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fplugins.texi?ref=68a607d8143693c8f4bc66bef001197ea4ff7c84", "patch": "@@ -0,0 +1,137 @@\n+@c Copyright (c) 2009 Free Software Foundation, Inc.\n+@c Free Software Foundation, Inc.\n+@c This is part of the GCC manual.\n+@c For copying conditions, see the file gcc.texi.\n+\n+@node Plugins\n+@chapter Plugins\n+@cindex Plugins\n+\n+@section Loading Plugins\n+\n+Plugins are supported on platforms that support @option{-ld\n+-rdynamic}.  They are loaded by the compiler using @code{dlopen}\n+and invoked at pre-determined locations in the compilation\n+process.\n+\n+Plugins are loaded with \n+\n+@option{-fplugin=/path/to/NAME.so} @option{-fplugin-arg-NAME-<key1>[=<value1>]}\n+\n+The plugin arguments are parsed by GCC and passed to respective\n+plugins as key-value pairs. Multiple plugins can be invoked by\n+specifying multiple @option{-fplugin} arguments.\n+\n+\n+@section Plugin API\n+\n+Plugins are activated by the compiler at specific events as defined in\n+@file{gcc-plugin.h}.  For each event of interest, the plugin should\n+call @code{register_callback} specifying the name of the event and\n+address of the callback function that will handle that event.\n+\n+@subsection Plugin initialization\n+\n+Every plugin should export a function called @code{plugin_init} that\n+is called right after the plugin is loaded. This function is\n+responsible for registering all the callbacks required by the plugin\n+and do any other required initialization.\n+\n+This function is called from @code{compile_file} right before invoking\n+the parser.  The arguments to @code{plugin_init} are:\n+\n+@itemize @bullet\n+@item @code{plugin_name}: Name of the plugin.\n+@item @code{argc}: Number of arguments specified with @option{-fplugin-arg-...}.\n+@item @code{argv}: Array of @code{argc} key-value pairs.\n+@end itemize\n+\n+If initialization fails, @code{plugin_init} must return a non-zero\n+value.  Otherwise, it should return 0.\n+\n+@subsection Plugin callbacks\n+\n+Callback functions have the following prototype:\n+\n+@smallexample\n+/* The prototype for a plugin callback function.\n+     gcc_data  - event-specific data provided by GCC\n+     user_data - plugin-specific data provided by the plug-in.  */\n+typedef void (*plugin_callback_func)(void *gcc_data, void *user_data);\n+@end smallexample\n+\n+Callbacks can be invoked at the following pre-determined events:\n+\n+\n+@smallexample\n+enum plugin_event\n+@{\n+  PLUGIN_PASS_MANAGER_SETUP,    /* To hook into pass manager.  */\n+  PLUGIN_FINISH_TYPE,           /* After finishing parsing a type.  */\n+  PLUGIN_FINISH_UNIT,           /* Useful for summary processing.  */\n+  PLUGIN_CXX_CP_PRE_GENERICIZE, /* Allows to see low level AST in C++ FE.  */\n+  PLUGIN_FINISH,                /* Called before GCC exits.  */\n+  PLUGIN_EVENT_LAST             /* Dummy event used for indexing callback\n+                                   array.  */\n+@};\n+@end smallexample\n+\n+To register a callback, the plugin calls @code{register_callback} with the arguments:\n+\n+@itemize\n+@item @code{char *name}: Plugin name.\n+@item @code{enum plugin_event event}: The event code.\n+@item @code{plugin_callback_func callback}: The function that handles @code{event}.\n+@item @code{void *user_data}: Pointer to plugin-specific data.\n+@end itemize\n+\n+\n+@section Interacting with the pass manager\n+\n+There needs to be a way to add/reorder/remove passes dynamically. This\n+is useful for both analysis plugins (plugging in after a certain pass\n+such as CFG or an IPA pass) and optimization plugins.\n+\n+Basic support for inserting new passes or replacing existing passes is\n+provided. A plugin registers a new pass with GCC by calling\n+@code{register_callback} with the @code{PLUGIN_PASS_MANAGER_SETUP}\n+event and a pointer to a @code{struct plugin_pass} object defined as follows\n+\n+@smallexample\n+enum pass_positioning_ops\n+@{\n+  PASS_POS_INSERT_AFTER,  // Insert after the reference pass.\n+  PASS_POS_INSERT_BEFORE, // Insert before the reference pass.\n+  PASS_POS_REPLACE        // Replace the reference pass.\n+@};\n+\n+struct plugin_pass\n+@{\n+  struct opt_pass *pass;            /* New pass provided by the plugin.  */\n+  const char *reference_pass_name;  /* Name of the reference pass for hooking\n+                                       up the new pass.  */\n+  int ref_pass_instance_number;     /* Insert the pass at the specified\n+                                       instance number of the reference pass.  */\n+                                    /* Do it for every instance if it is 0.  */\n+  enum pass_positioning_ops pos_op; /* how to insert the new pass.  */\n+@};\n+\n+\n+/* Sample plugin code that registers a new pass.  */\n+int\n+plugin_init (const char *plugin_name, int argc, struct plugin_argument *argv)\n+@{\n+  struct plugin_pass pass_info;\n+\n+  ...\n+\n+  /* Code to fill in the pass_info object with new pass information.  */\n+\n+  ...\n+\n+  /* Register the new pass.  */\n+  register_callback (plugin_name, PLUGIN_PASS_MANAGER_SETUP, NULL, &pass_info);\n+\n+  ...\n+@}\n+@end smallexample"}, {"sha": "4a45c1e2c4819387b112aa0eb55d10a25c4af6b5", "filename": "gcc/gcc-plugin.h", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Fgcc-plugin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Fgcc-plugin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc-plugin.h?ref=68a607d8143693c8f4bc66bef001197ea4ff7c84", "patch": "@@ -0,0 +1,98 @@\n+/* Public header file for plugins to include.\n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_PLUGIN_H\n+#define GCC_PLUGIN_H\n+\n+/* Event names.  Keep in sync with plugin_event_name[].  */\n+enum plugin_event\n+{\n+  PLUGIN_PASS_MANAGER_SETUP,    /* To hook into pass manager.  */\n+  PLUGIN_FINISH_TYPE,           /* After finishing parsing a type.  */\n+  PLUGIN_FINISH_UNIT,           /* Useful for summary processing.  */\n+  PLUGIN_CXX_CP_PRE_GENERICIZE, /* Allows to see low level AST in C++ FE.  */\n+  PLUGIN_FINISH,                /* Called before GCC exits.  */\n+  PLUGIN_EVENT_LAST             /* Dummy event used for indexing callback\n+                                   array.  */\n+};\n+\n+extern const char *plugin_event_name[];\n+\n+struct plugin_argument\n+{\n+  char *key;    /* key of the argument.  */\n+  char *value;  /* value is optional and can be NULL.  */\n+};\n+\n+enum pass_positioning_ops\n+{\n+  PASS_POS_INSERT_AFTER,  /* Insert after the reference pass.  */\n+  PASS_POS_INSERT_BEFORE, /* Insert before the reference pass.  */\n+  PASS_POS_REPLACE        /* Replace the reference pass.  */\n+};\n+\n+struct plugin_pass\n+{\n+  struct opt_pass *pass;            /* New pass provided by the plugin.  */\n+  const char *reference_pass_name;  /* Name of the reference pass for hooking\n+                                       up the new pass.  */\n+  int ref_pass_instance_number;     /* Insert the pass at the specified\n+                                       instance number of the reference pass.\n+                                       Do it for every instance if it is 0.  */\n+  enum pass_positioning_ops pos_op; /* how to insert the new pass.  */\n+};\n+\n+/* Function type for the plugin initialization routine. Each plugin module\n+   should define this as an externally-visible function with name\n+   \"plugin_init.\"\n+\n+   PLUGIN_NAME - name of the plugin (useful for error reporting)\n+   ARGC        - the size of the ARGV array\n+   ARGV        - an array of key-value argument pair\n+\n+   Returns 0 if initialization finishes successfully.  */\n+\n+typedef int (*plugin_init_func) (const char *plugin_name,\n+                                 int argc, struct plugin_argument *argv);\n+\n+/* Declaration for \"plugin_init\" function so that it doesn't need to be\n+   duplicated in every plugin.  */\n+extern int plugin_init (const char *, int, struct plugin_argument *);\n+\n+/* Function type for a plugin callback routine.\n+\n+   GCC_DATA  - event-specific data provided by GCC\n+   USER_DATA - plugin-specific data provided by the plugin  */\n+\n+typedef void (*plugin_callback_func) (void *gcc_data, void *user_data);\n+\n+/* Called from the plugin's initialization code. Register a single callback.\n+   This function can be called multiple times.\n+\n+   PLUGIN_NAME - display name for this plugin\n+   EVENT       - which event the callback is for\n+   CALLBACK    - the callback to be called at the event\n+   USER_DATA   - plugin-provided data   */\n+\n+extern void register_callback (const char *plugin_name,\n+                               enum plugin_event event,\n+                               plugin_callback_func callback,\n+                               void *user_data);\n+\n+#endif /* GCC_PLUGIN_H */"}, {"sha": "5ee16d69a21905e992511d5ddbd770e4a93204fa", "filename": "gcc/opts.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=68a607d8143693c8f4bc66bef001197ea4ff7c84", "patch": "@@ -42,6 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"dbgcnt.h\"\n #include \"debug.h\"\n+#include \"plugin.h\"\n \n /* Value of the -G xx switch, and whether it was passed or not.  */\n unsigned HOST_WIDE_INT g_switch_value;\n@@ -1766,6 +1767,22 @@ common_handle_option (size_t scode, const char *arg, int value,\n       flag_peel_loops_set = true;\n       break;\n \n+    case OPT_fplugin_:\n+#ifdef ENABLE_PLUGIN\n+      add_new_plugin (arg);\n+#else\n+      error (\"Plugin support is disabled.  Configure with --enable-plugin.\");\n+#endif\n+      break;\n+\n+    case OPT_fplugin_arg_:\n+#ifdef ENABLE_PLUGIN\n+      parse_plugin_arg_opt (arg);\n+#else\n+      error (\"Plugin support is disabled.  Configure with --enable-plugin.\");\n+#endif\n+      break;\n+\n     case OPT_fprofile_arcs:\n       profile_arc_flag_set = true;\n       break;"}, {"sha": "2814140ee15dc6b6205a4539f25db2057569d666", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=68a607d8143693c8f4bc66bef001197ea4ff7c84", "patch": "@@ -368,7 +368,7 @@ get_pass_for_id (int id)\n    to do this depth first, and independent of whether the pass is\n    enabled or not.  */\n \n-static void\n+void\n register_one_dump_file (struct opt_pass *pass)\n {\n   char *dot_name, *flag_name, *glob_name;"}, {"sha": "93e158c7867f26495848d8ce8f176474c5ddffd4", "filename": "gcc/plugin.c", "status": "added", "additions": 672, "deletions": 0, "changes": 672, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Fplugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Fplugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fplugin.c?ref=68a607d8143693c8f4bc66bef001197ea4ff7c84", "patch": "@@ -0,0 +1,672 @@\n+/* Support for GCC plugin mechanism.\n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* This file contains the support for GCC plugin mechanism based on the\n+   APIs described in doc/plugin.texi.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+\n+/* If plugin support is not enabled, do not try to execute any code\n+   that may reference libdl.  The generic code is still compiled in to\n+   avoid including to many conditional compilation paths in the rest\n+   of the compiler.  */\n+#ifdef ENABLE_PLUGIN\n+#include <dlfcn.h>\n+#endif\n+\n+#include \"coretypes.h\"\n+#include \"toplev.h\"\n+#include \"tree.h\"\n+#include \"tree-pass.h\"\n+#include \"intl.h\"\n+#include \"plugin.h\"\n+#include \"timevar.h\"\n+\n+/* Event names as strings.  Keep in sync with enum plugin_event.  */\n+const char *plugin_event_name[] =\n+{\n+  \"PLUGIN_PASS_MANAGER_SETUP\",\n+  \"PLUGIN_FINISH_TYPE\",\n+  \"PLUGIN_FINISH_UNIT\",\n+  \"PLUGIN_CXX_CP_PRE_GENERICIZE\",\n+  \"PLUGIN_FINISH\",\n+  \"PLUGIN_EVENT_LAST\"\n+};\n+\n+/* Object that keeps track of the plugin name and its arguments\n+   when parsing the command-line options -fplugin=/path/to/NAME.so and\n+   -fplugin-arg-NAME-<key>[=<value>].  */\n+struct plugin_name_args\n+{\n+  char *base_name;\n+  const char *full_name;\n+  int argc;\n+  struct plugin_argument *argv;\n+};\n+\n+/* Hash table for the plugin_name_args objects created during command-line\n+   parsing.  */\n+static htab_t plugin_name_args_tab = NULL;\n+\n+/* List node for keeping track of plugin-registered callback.  */\n+struct callback_info\n+{\n+  const char *plugin_name;   /* Name of plugin that registers the callback.  */\n+  plugin_callback_func func; /* Callback to be called.  */\n+  void *user_data;           /* plugin-specified data.  */\n+  struct callback_info *next;\n+};\n+\n+/* An array of lists of 'callback_info' objects indexed by the event id.  */\n+static struct callback_info *plugin_callbacks[PLUGIN_EVENT_LAST] = { NULL };\n+\n+/* List node for an inserted pass instance. We need to keep track of all\n+   the newly-added pass instances (with 'added_pass_nodes' defined below)\n+   so that we can register their dump files after pass-positioning is finished.\n+   Registering dumping files needs to be post-processed or the\n+   static_pass_number of the opt_pass object would be modified and mess up\n+   the dump file names of future pass instances to be added.  */\n+struct pass_list_node\n+{\n+  struct opt_pass *pass;\n+  struct pass_list_node *next;\n+};\n+\n+static struct pass_list_node *added_pass_nodes = NULL;\n+static struct pass_list_node *prev_added_pass_node;\n+\n+#ifdef ENABLE_PLUGIN\n+/* Each plugin should define an initialization function with exactly\n+   this name.  */\n+static const char *str_plugin_init_func_name = \"plugin_init\";\n+#endif\n+\n+/* Helper function for the hash table that compares the base_name of the\n+   existing entry (S1) with the given string (S2).  */\n+\n+static int\n+htab_str_eq (const void *s1, const void *s2)\n+{\n+  const struct plugin_name_args *plugin = (const struct plugin_name_args *) s1;\n+  return !strcmp (plugin->base_name, (const char *) s2);\n+}\n+\n+\n+/* Given a plugin's full-path name FULL_NAME, e.g. /pass/to/NAME.so,\n+   return NAME.  */\n+\n+static char *\n+get_plugin_base_name (const char *full_name)\n+{\n+  /* First get the base name part of the full-path name, i.e. NAME.so.  */\n+  char *base_name = xstrdup (lbasename (full_name));\n+\n+  /* Then get rid of '.so' part of the name.  */\n+  strip_off_ending (base_name, strlen (base_name));\n+\n+  return base_name;\n+}\n+\n+\n+/* Create a plugin_name_args object for the give plugin and insert it to\n+   the hash table. This function is called when -fplugin=/path/to/NAME.so\n+   option is processed.  */\n+\n+void\n+add_new_plugin (const char* plugin_name)\n+{\n+  struct plugin_name_args *plugin;\n+  void **slot;\n+  char *base_name = get_plugin_base_name (plugin_name);\n+\n+  /* If this is the first -fplugin= option we encounter, create \n+     'plugin_name_args_tab' hash table.  */\n+  if (!plugin_name_args_tab)\n+    plugin_name_args_tab = htab_create (10, htab_hash_string, htab_str_eq,\n+                                        NULL);\n+\n+  slot = htab_find_slot (plugin_name_args_tab, base_name, INSERT);\n+\n+  /* If the same plugin (name) has been specified earlier, either emit an\n+     error or a warning message depending on if they have identical full\n+     (path) names.  */\n+  if (*slot)\n+    {\n+      plugin = (struct plugin_name_args *) *slot;\n+      if (strcmp (plugin->full_name, plugin_name))\n+        error (\"Plugin %s was specified with different paths:\\n%s\\n%s\",\n+               plugin->base_name, plugin->full_name, plugin_name);\n+      return;\n+    }\n+\n+  plugin = XCNEW (struct plugin_name_args);\n+  plugin->base_name = base_name;\n+  plugin->full_name = plugin_name;\n+\n+  *slot = plugin;\n+}\n+\n+\n+/* Parse the -fplugin-arg-<name>-<key>[=<value>] option and create a\n+   'plugin_argument' object for the parsed key-value pair. ARG is\n+   the <name>-<key>[=<value>] part of the option.  */\n+\n+void\n+parse_plugin_arg_opt (const char *arg)\n+{\n+  size_t len = 0, name_len = 0, key_len = 0, value_len = 0;\n+  const char *ptr, *name_start = arg, *key_start = NULL, *value_start = NULL;\n+  char *name, *key, *value;\n+  void **slot;\n+  bool name_parsed = false, key_parsed = false;\n+\n+  /* Iterate over the ARG string and identify the starting character position\n+     of 'name', 'key', and 'value' and their lengths.  */\n+  for (ptr = arg; *ptr; ++ptr)\n+    {\n+      /* Only the first '-' encountered is considered a separator between\n+         'name' and 'key'. All the subsequent '-'s are considered part of\n+         'key'. For example, given -fplugin-arg-foo-bar-primary-key=value,\n+         the plugin name is 'foo' and the key is 'bar-primary-key'.  */\n+      if (*ptr == '-' && !name_parsed)\n+        {\n+          name_len = len;\n+          len = 0;\n+          key_start = ptr + 1;\n+          name_parsed = true;\n+          continue;\n+        }\n+      else if (*ptr == '=')\n+        {\n+          if (key_parsed)\n+            {\n+              error (\"Malformed option -fplugin-arg-%s (multiple '=' signs)\",\n+\t\t     arg);\n+              return;\n+            }\n+          key_len = len;\n+          len = 0;\n+          value_start = ptr + 1;\n+          key_parsed = true;\n+          continue;\n+        }\n+      else\n+        ++len;\n+    }\n+\n+  if (!key_start)\n+    {\n+      error (\"Malformed option -fplugin-arg-%s (missing -<key>[=<value>])\",\n+             arg);\n+      return;\n+    }\n+\n+  /* If the option doesn't contain the 'value' part, LEN is the KEY_LEN.\n+     Otherwise, it is the VALUE_LEN.  */\n+  if (!value_start)\n+    key_len = len;\n+  else\n+    value_len = len;\n+\n+  name = XNEWVEC (char, name_len + 1);\n+  strncpy (name, name_start, name_len);\n+  name[name_len] = '\\0';\n+\n+  /* Check if the named plugin has already been specified earlier in the\n+     command-line.  */\n+  if (plugin_name_args_tab\n+      && ((slot = htab_find_slot (plugin_name_args_tab, name, NO_INSERT))\n+          != NULL))\n+    {\n+      struct plugin_name_args *plugin = (struct plugin_name_args *) *slot;\n+\n+      key = XNEWVEC (char, key_len + 1);\n+      strncpy (key, key_start, key_len);\n+      key[key_len] = '\\0';\n+      if (value_start)\n+        {\n+          value = XNEWVEC (char, value_len + 1);\n+          strncpy (value, value_start, value_len);\n+          value[value_len] = '\\0';\n+        }\n+      else\n+        value = NULL;\n+\n+      /* Create a plugin_argument object for the parsed key-value pair.\n+         If there are already arguments for this plugin, we will need to\n+         adjust the argument array size by creating a new array and deleting\n+         the old one. If the performance ever becomes an issue, we can\n+         change the code by pre-allocating a larger array first.  */\n+      if (plugin->argc > 0)\n+        {\n+          struct plugin_argument *args = XNEWVEC (struct plugin_argument,\n+                                                  plugin->argc + 1);\n+          memcpy (args, plugin->argv,\n+                  sizeof (struct plugin_argument) * plugin->argc);\n+          XDELETEVEC (plugin->argv);\n+          plugin->argv = args;\n+          ++plugin->argc;\n+        }\n+      else\n+        {\n+          gcc_assert (plugin->argv == NULL);\n+          plugin->argv = XNEWVEC (struct plugin_argument, 1);\n+          plugin->argc = 1;\n+        }\n+\n+      plugin->argv[plugin->argc - 1].key = key;\n+      plugin->argv[plugin->argc - 1].value = value;\n+    }\n+  else\n+    error (\"Plugin %s should be specified before -fplugin-arg-%s \"\n+           \"in the command line\", name, arg);\n+\n+  /* We don't need the plugin's name anymore. Just release it.  */\n+  XDELETEVEC (name);\n+}\n+\n+\n+/* Insert the plugin pass at the proper position. Return true if the pass \n+   is successfully added.\n+\n+   PLUGIN_PASS_INFO - new pass to be inserted\n+   PASS_LIST        - root of the pass list to insert the new pass to  */\n+\n+static bool\n+position_pass (struct plugin_pass *plugin_pass_info,\n+               struct opt_pass **pass_list)\n+{\n+  struct opt_pass *pass = *pass_list, *prev_pass = NULL;\n+  bool success = false;\n+\n+  for ( ; pass; prev_pass = pass, pass = pass->next)\n+    {\n+      /* Check if the current pass is of the same type as the new pass and\n+         matches the name and the instance number of the reference pass.  */\n+      if (pass->type == plugin_pass_info->pass->type\n+          && pass->name\n+          && !strcmp (pass->name, plugin_pass_info->reference_pass_name)\n+          && ((plugin_pass_info->ref_pass_instance_number == 0)\n+              || (plugin_pass_info->ref_pass_instance_number ==\n+                  pass->static_pass_number)\n+              || (plugin_pass_info->ref_pass_instance_number == 1\n+                  && pass->todo_flags_start & TODO_mark_first_instance)))\n+        {\n+          struct opt_pass *new_pass = plugin_pass_info->pass;\n+          struct pass_list_node *new_pass_node;\n+\n+          /* The following code (if-statement) is adopted from next_pass_1.  */\n+          if (new_pass->static_pass_number)\n+            {\n+              new_pass = XNEW (struct opt_pass);\n+              memcpy (new_pass, plugin_pass_info->pass, sizeof (*new_pass));\n+              new_pass->next = NULL;\n+\n+              new_pass->todo_flags_start &= ~TODO_mark_first_instance;\n+\n+              plugin_pass_info->pass->static_pass_number -= 1;\n+              new_pass->static_pass_number =\n+                  -plugin_pass_info->pass->static_pass_number;\n+            }\n+          else\n+            {\n+              new_pass->todo_flags_start |= TODO_mark_first_instance;\n+              new_pass->static_pass_number = -1;\n+            }\n+\n+          /* Insert the new pass instance based on the positioning op.  */\n+          switch (plugin_pass_info->pos_op)\n+            {\n+              case PASS_POS_INSERT_AFTER:\n+                new_pass->next = pass->next;\n+                pass->next = new_pass;\n+                break;\n+              case PASS_POS_INSERT_BEFORE:\n+                new_pass->next = pass;\n+                if (prev_pass)\n+                  prev_pass->next = new_pass;\n+                else\n+                  *pass_list = new_pass;\n+                break;\n+              case PASS_POS_REPLACE:\n+                new_pass->next = pass->next;\n+                if (prev_pass)\n+                  prev_pass->next = new_pass;\n+                else\n+                  *pass_list = new_pass;\n+                new_pass->sub = pass->sub;\n+                new_pass->tv_id = pass->tv_id;\n+                pass = new_pass;\n+                break;\n+              default:\n+                error (\"Invalid pass positioning operation\");\n+                return false;\n+            }\n+\n+          /* Save the newly added pass (instance) in the added_pass_nodes\n+             list so that we can register its dump file later. Note that\n+             we cannot register the dump file now because doing so will modify\n+             the static_pass_number of the opt_pass object and therefore\n+             mess up the dump file name of future instances.  */\n+          new_pass_node = XCNEW (struct pass_list_node);\n+          new_pass_node->pass = new_pass;\n+          if (!added_pass_nodes)\n+            added_pass_nodes = new_pass_node;\n+          else\n+            prev_added_pass_node->next = new_pass_node;\n+          prev_added_pass_node = new_pass_node;\n+\n+          success = true;\n+        }\n+\n+      if (pass->sub && position_pass (plugin_pass_info, &pass->sub))\n+        success = true;\n+    }\n+\n+  return success;\n+}\n+\n+\n+/* Hook into the pass lists (trees) a new pass registered by a plugin.\n+\n+   PLUGIN_NAME - display name for the plugin\n+   PASS_INFO   - plugin pass information that specifies the opt_pass object,\n+                 reference pass, instance number, and how to position\n+                 the pass  */\n+\n+static void\n+register_pass (const char *plugin_name, struct plugin_pass *pass_info)\n+{\n+  if (!pass_info->pass)\n+    {\n+      error (\"No pass specified when registering a new pass in plugin %s\",\n+             plugin_name);\n+      return;\n+    }\n+\n+  if (!pass_info->reference_pass_name)\n+    {\n+      error (\"No reference pass specified for positioning the pass \"\n+             \" from plugin %s\", plugin_name);\n+      return;\n+    }\n+\n+  /* Try to insert the new pass to the pass lists. We need to check all\n+     three lists as the reference pass could be in one (or all) of them.  */\n+  if (!position_pass (pass_info, &all_lowering_passes)\n+      && !position_pass (pass_info, &all_ipa_passes)\n+      && !position_pass (pass_info, &all_passes))\n+    error (\"Failed to position pass %s registered by plugin %s. \"\n+           \"Cannot find the (specified instance of) reference pass %s\",\n+           pass_info->pass->name, plugin_name, pass_info->reference_pass_name);\n+  else\n+    {\n+      /* OK, we have successfully inserted the new pass. We need to register\n+         the dump files for the newly added pass and its duplicates (if any).\n+         Because the registration of plugin passes happens after the\n+         command-line options are parsed, the options that specify single\n+         pass dumping (e.g. -fdump-tree-PASSNAME) cannot be used for new\n+         plugin passes. Therefore we currently can only enable dumping of\n+         new plugin passes when the 'dump-all' flags (e.g. -fdump-tree-all)\n+         are specified. While doing so, we also delete the pass_list_node\n+         objects created during pass positioning.  */\n+      while (added_pass_nodes)\n+        {\n+          struct pass_list_node *next_node = added_pass_nodes->next;\n+          enum tree_dump_index tdi;\n+          register_one_dump_file (added_pass_nodes->pass);\n+          if (added_pass_nodes->pass->type == SIMPLE_IPA_PASS\n+              || added_pass_nodes->pass->type == IPA_PASS)\n+            tdi = TDI_ipa_all;\n+          else if (added_pass_nodes->pass->type == GIMPLE_PASS)\n+            tdi = TDI_tree_all;\n+          else\n+            tdi = TDI_rtl_all;\n+          /* Check if dump-all flag is specified.  */\n+          if (get_dump_file_info (tdi)->state)\n+            get_dump_file_info (added_pass_nodes->pass->static_pass_number)\n+                ->state = get_dump_file_info (tdi)->state;\n+          XDELETE (added_pass_nodes);\n+          added_pass_nodes = next_node;\n+        }\n+    }\n+}\n+\n+\n+/* Called from the plugin's initialization code. Register a single callback.\n+   This function can be called multiple times.\n+\n+   PLUGIN_NAME - display name for this plugin\n+   EVENT       - which event the callback is for\n+   CALLBACK    - the callback to be called at the event\n+   USER_DATA   - plugin-provided data   */\n+\n+void\n+register_callback (const char *plugin_name,\n+                   enum plugin_event event,\n+                   plugin_callback_func callback,\n+                   void *user_data)\n+{\n+  switch (event)\n+    {\n+      case PLUGIN_PASS_MANAGER_SETUP:\n+        register_pass (plugin_name, (struct plugin_pass *) user_data);\n+        break;\n+      case PLUGIN_FINISH_TYPE:\n+      case PLUGIN_FINISH_UNIT:\n+      case PLUGIN_CXX_CP_PRE_GENERICIZE:\n+      case PLUGIN_FINISH:\n+        {\n+          struct callback_info *new_callback;\n+          if (!callback)\n+            {\n+              error (\"Plugin %s registered a null callback function \"\n+\t\t     \"for event %s\", plugin_name, plugin_event_name[event]);\n+              return;\n+            }\n+          new_callback = XNEW (struct callback_info);\n+          new_callback->plugin_name = plugin_name;\n+          new_callback->func = callback;\n+          new_callback->user_data = user_data;\n+          new_callback->next = plugin_callbacks[event];\n+          plugin_callbacks[event] = new_callback;\n+        }\n+        break;\n+      case PLUGIN_EVENT_LAST:\n+      default:\n+        error (\"Unkown callback event registered by plugin %s\",\n+               plugin_name);\n+    }\n+}\n+\n+\n+/* Called from inside GCC.  Invoke all plug-in callbacks registered with\n+   the specified event.\n+\n+   EVENT    - the event identifier\n+   GCC_DATA - event-specific data provided by the compiler  */\n+\n+void\n+invoke_plugin_callbacks (enum plugin_event event, void *gcc_data)\n+{\n+  timevar_push (TV_PLUGIN_RUN);\n+\n+  switch (event)\n+    {\n+      case PLUGIN_FINISH_TYPE:\n+      case PLUGIN_FINISH_UNIT:\n+      case PLUGIN_CXX_CP_PRE_GENERICIZE:\n+      case PLUGIN_FINISH:\n+        {\n+          /* Iterate over every callback registered with this event and\n+             call it.  */\n+          struct callback_info *callback = plugin_callbacks[event];\n+          for ( ; callback; callback = callback->next)\n+            (*callback->func) (gcc_data, callback->user_data);\n+        }\n+        break;\n+\n+      case PLUGIN_PASS_MANAGER_SETUP:\n+      case PLUGIN_EVENT_LAST:\n+      default:\n+        gcc_assert (false);\n+    }\n+\n+  timevar_pop (TV_PLUGIN_RUN);\n+}\n+\n+#ifdef ENABLE_PLUGIN\n+/* We need a union to cast dlsym return value to a function pointer\n+   as ISO C forbids assignment between function pointer and 'void *'.\n+   Use explicit union instead of __extension__(<union_cast>) for\n+   portability.  */\n+#define PTR_UNION_TYPE(TOTYPE) union { void *_q; TOTYPE _nq; }\n+#define PTR_UNION_AS_VOID_PTR(NAME) (NAME._q)\n+#define PTR_UNION_AS_CAST_PTR(NAME) (NAME._nq)\n+\n+/* Routine to dlopen and initialize one plugin. This function is passed to\n+   (and called by) the hash table traverse routine. Return 1 for the\n+   htab_traverse to continue scan, 0 to stop.\n+\n+   SLOT - slot of the hash table element\n+   INFO - auxiliary pointer handed to hash table traverse routine\n+          (unused in this function)  */\n+\n+static int\n+init_one_plugin (void **slot, void * ARG_UNUSED (info))\n+{\n+  struct plugin_name_args *plugin = (struct plugin_name_args *) *slot;\n+  void *dl_handle;\n+  plugin_init_func plugin_init;\n+  char *err;\n+  PTR_UNION_TYPE (plugin_init_func) plugin_init_union;\n+\n+  dl_handle = dlopen (plugin->full_name, RTLD_NOW);\n+  if (!dl_handle)\n+    {\n+      error (\"Cannot load plugin %s\\n%s\", plugin->full_name, dlerror ());\n+      return 1;\n+    }\n+\n+  /* Clear any existing error.  */\n+  dlerror ();\n+\n+  PTR_UNION_AS_VOID_PTR (plugin_init_union) =\n+      dlsym (dl_handle, str_plugin_init_func_name);\n+  plugin_init = PTR_UNION_AS_CAST_PTR (plugin_init_union);\n+\n+  if ((err = dlerror ()) != NULL)\n+    {\n+      error (\"Cannot find %s in plugin %s\\n%s\", str_plugin_init_func_name,\n+             plugin->full_name, err);\n+      return 1;\n+    }\n+\n+  /* Call the plugin-provided initialization routine with the arguments.  */\n+  if ((*plugin_init) (plugin->base_name, plugin->argc, plugin->argv))\n+    {\n+      error (\"Fail to initialize plugin %s\", plugin->full_name);\n+      return 1;\n+    }\n+\n+  /* We can now delete the plugin_name_args object as it will no longer\n+     be used. Note that base_name and argv fields (both of which were also\n+     dynamically allocated) are not freed as they could still be used by\n+     the plugin code.  */\n+  XDELETE (plugin);\n+\n+  return 1;\n+}\n+#endif\t/* ENABLE_PLUGIN  */\n+\n+/* Main plugin initialization function.  Called from compile_file() in\n+   toplev.c.  */\n+\n+void\n+initialize_plugins (void)\n+{\n+  /* If no plugin was specified in the command-line, simply return.  */\n+  if (!plugin_name_args_tab)\n+    return;\n+\n+  timevar_push (TV_PLUGIN_INIT);\n+ \n+#ifdef ENABLE_PLUGIN\n+  /* Traverse and initialize each plugin specified in the command-line.  */\n+  htab_traverse_noresize (plugin_name_args_tab, init_one_plugin, NULL);\n+#endif\n+\n+  /* PLUGIN_NAME_ARGS_TAB is no longer needed, just delete it.  */\n+  htab_delete (plugin_name_args_tab);\n+  plugin_name_args_tab = NULL;\n+\n+  timevar_pop (TV_PLUGIN_INIT);\n+}\n+\n+\n+/* Return true if plugins have been loaded.  */\n+\n+bool\n+plugins_active_p (void)\n+{\n+  enum plugin_event event;\n+\n+  for (event = PLUGIN_PASS_MANAGER_SETUP; event < PLUGIN_EVENT_LAST; event++)\n+    if (plugin_callbacks[event])\n+      return true;\n+\n+  return false;\n+}\n+\n+\n+/* Dump to FILE the names and associated events for all the active\n+   plugins.  */\n+\n+void\n+dump_active_plugins (FILE *file)\n+{\n+  enum plugin_event event;\n+\n+  if (!plugins_active_p ())\n+    return;\n+\n+  fprintf (stderr, \"Event\\t\\tPlugins\\n\");\n+  for (event = PLUGIN_PASS_MANAGER_SETUP; event < PLUGIN_EVENT_LAST; event++)\n+    if (plugin_callbacks[event])\n+      {\n+\tstruct callback_info *ci;\n+\n+\tfprintf (file, \"%s\\t\", plugin_event_name[event]);\n+\n+\tfor (ci = plugin_callbacks[event]; ci; ci = ci->next)\n+\t  fprintf (file, \"%s \", ci->plugin_name);\n+\n+\tfprintf (file, \"\\n\");\n+      }\n+}\n+\n+\n+/* Dump active plugins to stderr.  */\n+\n+void\n+debug_active_plugins (void)\n+{\n+  dump_active_plugins (stderr);\n+}"}, {"sha": "40f864c446b94514befb20af319d612c45acb06f", "filename": "gcc/plugin.h", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Fplugin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Fplugin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fplugin.h?ref=68a607d8143693c8f4bc66bef001197ea4ff7c84", "patch": "@@ -0,0 +1,33 @@\n+/* Header file for internal GCC plugin mechanism.\n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef PLUGIN_H\n+#define PLUGIN_H\n+\n+#include \"gcc-plugin.h\"\n+\n+extern void add_new_plugin (const char *);\n+extern void parse_plugin_arg_opt (const char *);\n+extern void invoke_plugin_callbacks (enum plugin_event, void *);\n+extern void initialize_plugins (void);\n+extern bool plugins_active_p (void);\n+extern void dump_active_plugins (FILE *);\n+extern void debug_active_plugins (void);\n+\n+#endif /* PLUGIN_H */"}, {"sha": "d65c7389a68ffe1278ffa2c9aab53ca6a38d9979", "filename": "gcc/timevar.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=68a607d8143693c8f4bc66bef001197ea4ff7c84", "patch": "@@ -195,6 +195,8 @@ DEFTIMEVAR (TV_FINAL                 , \"final\")\n DEFTIMEVAR (TV_SYMOUT                , \"symout\")\n DEFTIMEVAR (TV_VAR_TRACKING          , \"variable tracking\")\n DEFTIMEVAR (TV_TREE_IFCOMBINE        , \"tree if-combine\")\n+DEFTIMEVAR (TV_PLUGIN_INIT           , \"plugin initialization\")\n+DEFTIMEVAR (TV_PLUGIN_RUN            , \"plugin execution\")\n \n /* Everything else in rest_of_compilation not included above.  */\n DEFTIMEVAR (TV_REST_OF_COMPILATION   , \"rest of compilation\")"}, {"sha": "675cdf249cfb61f19b09492670a572d812e9e5c2", "filename": "gcc/toplev.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=68a607d8143693c8f4bc66bef001197ea4ff7c84", "patch": "@@ -85,6 +85,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"gimple.h\"\n #include \"tree-ssa-alias.h\"\n+#include \"plugin.h\"\n \n #if defined (DWARF2_UNWIND_INFO) || defined (DWARF2_DEBUGGING_INFO)\n #include \"dwarf2out.h\"\n@@ -968,6 +969,7 @@ compile_file (void)\n   init_final (main_input_filename);\n   coverage_init (aux_base_name);\n   statistics_init ();\n+  initialize_plugins ();\n \n   timevar_push (TV_PARSE);\n \n@@ -2241,6 +2243,9 @@ do_compile (void)\n \tcompile_file ();\n \n       finalize ();\n+\n+      /* Invoke registered plugin callbacks.  */\n+      invoke_plugin_callbacks (PLUGIN_FINISH_UNIT, NULL);\n     }\n \n   /* Stop timing and print the times.  */\n@@ -2275,6 +2280,9 @@ toplev_main (unsigned int argc, const char **argv)\n   if (warningcount || errorcount) \n     print_ignored_options ();\n \n+  /* Invoke registered plugin callbacks if any.  */\n+  invoke_plugin_callbacks (PLUGIN_FINISH, NULL);\n+\n   if (errorcount || sorrycount)\n     return (FATAL_EXIT_CODE);\n "}, {"sha": "07e4247ec8e3c88aef9eac514f68f37064de1809", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68a607d8143693c8f4bc66bef001197ea4ff7c84/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=68a607d8143693c8f4bc66bef001197ea4ff7c84", "patch": "@@ -529,6 +529,7 @@ extern void execute_pass_list (struct opt_pass *);\n extern void execute_ipa_pass_list (struct opt_pass *);\n extern void print_current_pass (FILE *);\n extern void debug_pass (void);\n+extern void register_one_dump_file (struct opt_pass *);\n extern bool function_called_by_processed_nodes_p (void);\n \n /* Set to true if the pass is called the first time during compilation of the"}]}