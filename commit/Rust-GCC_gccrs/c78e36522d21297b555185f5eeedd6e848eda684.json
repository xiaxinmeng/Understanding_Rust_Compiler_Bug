{"sha": "c78e36522d21297b555185f5eeedd6e848eda684", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzc4ZTM2NTIyZDIxMjk3YjU1NTE4NWY1ZWVlZGQ2ZTg0OGVkYTY4NA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2017-07-03T07:28:28Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-07-03T07:28:28Z"}, "message": "tree-vect-loop.c (vect_analyze_loop_operations): Also analyze reduction PHIs.\n\n2016-07-03  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-loop.c (vect_analyze_loop_operations): Also analyze\n\treduction PHIs.\n\t(vect_force_simple_reduction): Record reduction def -> phi mapping.\n\t(vectorizable_reduction): Perform reduction PHI creation when\n\tvisiting a reduction PHI and adjust and simplify code generation\n\tphase of the reduction op.  Cache dts, use fold_binary, not fold_build2.\n\t(vect_transform_loop): Visit reduction PHIs.\n\t* tree-vect-slp.c (vect_get_and_check_slp_defs): Record reduction\n\tdefs into the SLP tree.\n\t(vect_build_slp_tree): Reduction defs terminate the recursion.\n\t* tree-vect-stmts.c (vect_get_vec_def_for_operand_1): Allow lookup\n\tof reduction defs.\n\t(vect_get_vec_defs_for_stmt_copy): Export.\n\t(vect_get_vec_defs): Likewise.\n\t* tree-vectorizer.h (struct _stmt_vec_info): Amend reduc_def\n\tpurpose.\n\t(vect_get_vec_defs_for_stmt_copy): Declare.\n\t(vect_get_vec_defs): Likewise.\n\nFrom-SVN: r249897", "tree": {"sha": "7fdd88d9eb9c5f83544cb4ff2ec1df7197ccc648", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7fdd88d9eb9c5f83544cb4ff2ec1df7197ccc648"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c78e36522d21297b555185f5eeedd6e848eda684", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c78e36522d21297b555185f5eeedd6e848eda684", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c78e36522d21297b555185f5eeedd6e848eda684", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c78e36522d21297b555185f5eeedd6e848eda684/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bc9f4235bcac6304141c472c94ecedeb9dbbff56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc9f4235bcac6304141c472c94ecedeb9dbbff56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc9f4235bcac6304141c472c94ecedeb9dbbff56"}], "stats": {"total": 266, "additions": 179, "deletions": 87}, "files": [{"sha": "402f8b74f678153f50ca7daea6379bcc59b77564", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c78e36522d21297b555185f5eeedd6e848eda684/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c78e36522d21297b555185f5eeedd6e848eda684/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c78e36522d21297b555185f5eeedd6e848eda684", "patch": "@@ -1,3 +1,24 @@\n+2016-07-03  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vect-loop.c (vect_analyze_loop_operations): Also analyze\n+\treduction PHIs.\n+\t(vect_force_simple_reduction): Record reduction def -> phi mapping.\n+\t(vectorizable_reduction): Perform reduction PHI creation when\n+\tvisiting a reduction PHI and adjust and simplify code generation\n+\tphase of the reduction op.  Cache dts, use fold_binary, not fold_build2.\n+\t(vect_transform_loop): Visit reduction PHIs.\n+\t* tree-vect-slp.c (vect_get_and_check_slp_defs): Record reduction\n+\tdefs into the SLP tree.\n+\t(vect_build_slp_tree): Reduction defs terminate the recursion.\n+\t* tree-vect-stmts.c (vect_get_vec_def_for_operand_1): Allow lookup\n+\tof reduction defs.\n+\t(vect_get_vec_defs_for_stmt_copy): Export.\n+\t(vect_get_vec_defs): Likewise.\n+\t* tree-vectorizer.h (struct _stmt_vec_info): Amend reduc_def\n+\tpurpose.\n+\t(vect_get_vec_defs_for_stmt_copy): Declare.\n+\t(vect_get_vec_defs): Likewise.\n+\n 2017-07-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* tree-data-ref.c (dr_analyze_innermost): Replace the \"nest\""}, {"sha": "ace3b8c9cc948d072d844536cbd2be6532b42230", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 138, "deletions": 70, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c78e36522d21297b555185f5eeedd6e848eda684/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c78e36522d21297b555185f5eeedd6e848eda684/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=c78e36522d21297b555185f5eeedd6e848eda684", "patch": "@@ -1778,6 +1778,10 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n               if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_induction_def\n \t\t  && ! PURE_SLP_STMT (stmt_info))\n                 ok = vectorizable_induction (phi, NULL, NULL, NULL);\n+\t      else if ((STMT_VINFO_DEF_TYPE (stmt_info) == vect_reduction_def\n+\t\t\t|| STMT_VINFO_DEF_TYPE (stmt_info) == vect_nested_cycle)\n+\t\t       && ! PURE_SLP_STMT (stmt_info))\n+\t\tok = vectorizable_reduction (phi, NULL, NULL, NULL);\n             }\n \n \t  if (ok && STMT_VINFO_LIVE_P (stmt_info))\n@@ -3185,6 +3189,8 @@ vect_force_simple_reduction (loop_vec_info loop_info, gimple *phi,\n       stmt_vec_info reduc_def_info = vinfo_for_stmt (phi);\n       STMT_VINFO_REDUC_TYPE (reduc_def_info) = v_reduc_type;\n       STMT_VINFO_REDUC_DEF (reduc_def_info) = def;\n+      reduc_def_info = vinfo_for_stmt (def);\n+      STMT_VINFO_REDUC_DEF (reduc_def_info) = phi;\n     }\n   return def;\n }\n@@ -5558,7 +5564,6 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n {\n   tree vec_dest;\n   tree scalar_dest;\n-  tree loop_vec_def0 = NULL_TREE, loop_vec_def1 = NULL_TREE;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   tree vectype_out = STMT_VINFO_VECTYPE (stmt_info);\n   tree vectype_in = NULL_TREE;\n@@ -5576,7 +5581,6 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n   bool is_simple_use;\n   gimple *orig_stmt;\n   stmt_vec_info orig_stmt_info;\n-  tree expr = NULL_TREE;\n   int i;\n   int ncopies;\n   int epilog_copies;\n@@ -5586,6 +5590,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n   gimple *new_stmt = NULL;\n   int j;\n   tree ops[3];\n+  enum vect_def_type dts[3];\n   bool nested_cycle = false, found_nested_cycle_def = false;\n   gimple *reduc_def_stmt = NULL;\n   bool double_reduc = false;\n@@ -5598,11 +5603,23 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n   auto_vec<tree> vect_defs;\n   auto_vec<gimple *> phis;\n   int vec_num;\n-  tree def0, def1, tem, op1 = NULL_TREE;\n+  tree def0, tem;\n   bool first_p = true;\n   tree cr_index_scalar_type = NULL_TREE, cr_index_vector_type = NULL_TREE;\n   tree cond_reduc_val = NULL_TREE;\n \n+  /* Make sure it was already recognized as a reduction computation.  */\n+  if (STMT_VINFO_DEF_TYPE (vinfo_for_stmt (stmt)) != vect_reduction_def\n+      && STMT_VINFO_DEF_TYPE (vinfo_for_stmt (stmt)) != vect_nested_cycle)\n+    return false;\n+\n+  if (nested_in_vect_loop_p (loop, stmt))\n+    {\n+      outer_loop = loop;\n+      loop = loop->inner;\n+      nested_cycle = true;\n+    }\n+\n   /* In case of reduction chain we switch to the first stmt in the chain, but\n      we don't update STMT_INFO, since only the last stmt is marked as reduction\n      and has reduction properties.  */\n@@ -5613,11 +5630,82 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n       first_p = false;\n     }\n \n-  if (nested_in_vect_loop_p (loop, stmt))\n+  if (gimple_code (stmt) == GIMPLE_PHI)\n     {\n-      outer_loop = loop;\n-      loop = loop->inner;\n-      nested_cycle = true;\n+      /* Analysis is fully done on the reduction stmt invocation.  */\n+      if (! vec_stmt)\n+\t{\n+\t  STMT_VINFO_TYPE (stmt_info) = reduc_vec_info_type;\n+\t  return true;\n+\t}\n+\n+      gimple *reduc_stmt = STMT_VINFO_REDUC_DEF (stmt_info);\n+      if (STMT_VINFO_IN_PATTERN_P (vinfo_for_stmt (reduc_stmt)))\n+\treduc_stmt = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (reduc_stmt));\n+      if (STMT_VINFO_RELEVANT (vinfo_for_stmt (reduc_stmt)) <= vect_used_only_live)\n+\tsingle_defuse_cycle = true;\n+\n+      gcc_assert (is_gimple_assign (reduc_stmt));\n+      for (unsigned k = 1; k < gimple_num_ops (reduc_stmt); ++k)\n+\t{\n+\t  tree op = gimple_op (reduc_stmt, k);\n+\t  if (op == gimple_phi_result (stmt))\n+\t    continue;\n+\t  if (k == 1\n+\t      && gimple_assign_rhs_code (reduc_stmt) == COND_EXPR)\n+\t    continue;\n+\t  vectype_in = get_vectype_for_scalar_type (TREE_TYPE (op));\n+\t  break;\n+\t}\n+      gcc_assert (vectype_in);\n+\n+      if (slp_node)\n+\tncopies = 1;\n+      else\n+\tncopies = (LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n+\t\t   / TYPE_VECTOR_SUBPARTS (vectype_in));\n+\n+      /* Create the destination vector  */\n+      scalar_dest = gimple_assign_lhs (reduc_stmt);\n+      vec_dest = vect_create_destination_var (scalar_dest, vectype_out);\n+\n+      if (slp_node)\n+\t/* The size vect_schedule_slp_instance computes is off for us.  */\n+\tvec_num = ((LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n+\t\t    * SLP_TREE_SCALAR_STMTS (slp_node).length ())\n+\t\t   / TYPE_VECTOR_SUBPARTS (vectype_in));\n+      else\n+\tvec_num = 1;\n+\n+      /* Generate the reduction PHIs upfront.  */\n+      prev_phi_info = NULL;\n+      for (j = 0; j < ncopies; j++)\n+\t{\n+\t  if (j == 0 || !single_defuse_cycle)\n+\t    {\n+\t      for (i = 0; i < vec_num; i++)\n+\t\t{\n+\t\t  /* Create the reduction-phi that defines the reduction\n+\t\t     operand.  */\n+\t\t  new_phi = create_phi_node (vec_dest, loop->header);\n+\t\t  set_vinfo_for_stmt (new_phi,\n+\t\t\t\t      new_stmt_vec_info (new_phi, loop_vinfo));\n+\n+\t\t  if (slp_node)\n+\t\t    SLP_TREE_VEC_STMTS (slp_node).quick_push (new_phi);\n+\t\t  else\n+\t\t    {\n+\t\t      if (j == 0)\n+\t\t\tSTMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_phi;\n+\t\t      else\n+\t\t\tSTMT_VINFO_RELATED_STMT (prev_phi_info) = new_phi;\n+\t\t      prev_phi_info = vinfo_for_stmt (new_phi);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+\n+      return true;\n     }\n \n   /* 1. Is vectorizable reduction?  */\n@@ -5633,11 +5721,6 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n       && !STMT_VINFO_LIVE_P (stmt_info))\n     return false;\n \n-  /* Make sure it was already recognized as a reduction computation.  */\n-  if (STMT_VINFO_DEF_TYPE (vinfo_for_stmt (stmt)) != vect_reduction_def\n-      && STMT_VINFO_DEF_TYPE (vinfo_for_stmt (stmt)) != vect_nested_cycle)\n-    return false;\n-\n   /* 2. Has this been recognized as a reduction pattern?\n \n      Check if STMT represents a pattern that has been recognized\n@@ -5718,11 +5801,12 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n         continue;\n \n       is_simple_use = vect_is_simple_use (ops[i], loop_vinfo,\n-\t\t\t\t\t  &def_stmt, &dt, &tem);\n+\t\t\t\t\t  &def_stmt, &dts[i], &tem);\n       if (!vectype_in)\n \tvectype_in = tem;\n       gcc_assert (is_simple_use);\n \n+      dt = dts[i];\n       if (dt != vect_internal_def\n \t  && dt != vect_external_def\n \t  && dt != vect_constant_def\n@@ -5752,7 +5836,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n     }\n \n   is_simple_use = vect_is_simple_use (ops[reduc_index], loop_vinfo,\n-\t\t\t\t      &def_stmt, &dt, &tem);\n+\t\t\t\t      &def_stmt, &dts[reduc_index], &tem);\n   if (!vectype_in)\n     vectype_in = tem;\n   gcc_assert (is_simple_use);\n@@ -5762,6 +5846,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (reduc_def_stmt && gimple_code (reduc_def_stmt) != GIMPLE_PHI)\n     return false;\n \n+  dt = dts[reduc_index];\n   if (!(dt == vect_reduction_def\n \t|| dt == vect_nested_cycle\n \t|| ((dt == vect_internal_def || dt == vect_external_def\n@@ -5820,7 +5905,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \t      && types_compatible_p (TREE_TYPE (cond_initial_val),\n \t\t\t\t     TREE_TYPE (cond_reduc_val)))\n \t    {\n-\t      tree e = fold_build2 (LE_EXPR, boolean_type_node,\n+\t      tree e = fold_binary (LE_EXPR, boolean_type_node,\n \t\t\t\t    cond_initial_val, cond_reduc_val);\n \t      if (e && (integer_onep (e) || integer_zerop (e)))\n \t\t{\n@@ -6190,19 +6275,28 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (!slp_node)\n     vect_defs.quick_push (NULL_TREE);\n \n+  auto_vec<tree> vec_oprnds;\n   for (j = 0; j < ncopies; j++)\n     {\n       if (j == 0 || !single_defuse_cycle)\n \t{\n           for (i = 0; i < vec_num; i++)\n             {\n-              /* Create the reduction-phi that defines the reduction\n+\t      /* Get the created reduction-phi that defines the reduction\n                  operand.  */\n-              new_phi = create_phi_node (vec_dest, loop->header);\n-              set_vinfo_for_stmt (new_phi,\n-                                  new_stmt_vec_info (new_phi, loop_vinfo));\n-               if (j == 0 || slp_node)\n-                 phis.quick_push (new_phi);\n+\t      tree reduc_def = gimple_phi_result (reduc_def_stmt);\n+\t      if (j == 0)\n+\t\tvect_get_vec_defs (reduc_def, NULL, stmt, &vec_oprnds, NULL,\n+\t\t\t\t   slp_node);\n+\t      else\n+\t\t{\n+\t\t  dt = vect_reduction_def;\n+\t\t  vect_get_vec_defs_for_stmt_copy (&dt,\n+\t\t\t\t\t\t   &vec_oprnds, NULL);\n+\t\t}\n+\t      new_phi = as_a <gphi *> (SSA_NAME_DEF_STMT (vec_oprnds[i]));\n+\t      if (j == 0 || slp_node)\n+\t\tphis.quick_push (new_phi);\n             }\n         }\n \n@@ -6243,42 +6337,30 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \t    }\n           else\n \t    {\n-              loop_vec_def0 = vect_get_vec_def_for_operand (ops[!reduc_index],\n-                                                            stmt);\n-              vec_oprnds0.quick_push (loop_vec_def0);\n+              vec_oprnds0.quick_push\n+\t\t(vect_get_vec_def_for_operand (ops[!reduc_index], stmt));\n               if (op_type == ternary_op)\n-               {\n-\t\t op1 = reduc_index == 0 ? ops[2] : ops[1];\n-                 loop_vec_def1 = vect_get_vec_def_for_operand (op1, stmt);\n-                 vec_oprnds1.quick_push (loop_vec_def1);\n-               }\n+\t\tvec_oprnds1.quick_push \n+\t\t  (vect_get_vec_def_for_operand (reduc_index == 0\n+\t\t\t\t\t\t ? ops[2] : ops[1], stmt));\n \t    }\n         }\n       else\n         {\n           if (!slp_node)\n             {\n-              enum vect_def_type dt;\n-\t      gimple *dummy_stmt;\n-\n-              vect_is_simple_use (ops[!reduc_index], loop_vinfo,\n-                                  &dummy_stmt, &dt);\n-              loop_vec_def0 = vect_get_vec_def_for_stmt_copy (dt,\n-                                                              loop_vec_def0);\n-              vec_oprnds0[0] = loop_vec_def0;\n+              vec_oprnds0[0]\n+\t\t= vect_get_vec_def_for_stmt_copy (dts[!reduc_index],\n+\t\t\t\t\t\t  vec_oprnds0[0]);\n               if (op_type == ternary_op)\n-                {\n-                  vect_is_simple_use (op1, loop_vinfo, &dummy_stmt, &dt);\n-                  loop_vec_def1 = vect_get_vec_def_for_stmt_copy (dt,\n-                                                                loop_vec_def1);\n-                  vec_oprnds1[0] = loop_vec_def1;\n-                }\n+                vec_oprnds1[0] \n+\t\t  = vect_get_vec_def_for_stmt_copy (dts[reduc_index == 0\n+\t\t\t\t\t\t        ? 2 : 1],\n+\t\t\t\t\t\t    vec_oprnds1[0]);\n             }\n \n           if (single_defuse_cycle)\n             reduc_def = gimple_assign_lhs (new_stmt);\n-\n-          STMT_VINFO_RELATED_STMT (prev_phi_info) = new_phi;\n         }\n \n       FOR_EACH_VEC_ELT (vec_oprnds0, i, def0)\n@@ -6291,31 +6373,16 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n                 reduc_def = PHI_RESULT (new_phi);\n             }\n \n-          def1 = ((op_type == ternary_op)\n-                  ? vec_oprnds1[i] : NULL);\n-          if (op_type == binary_op)\n-            {\n-              if (reduc_index == 0)\n-                expr = build2 (code, vectype_out, reduc_def, def0);\n-              else\n-                expr = build2 (code, vectype_out, def0, reduc_def);\n-            }\n-          else\n-            {\n-              if (reduc_index == 0)\n-                expr = build3 (code, vectype_out, reduc_def, def0, def1);\n-              else\n-                {\n-                  if (reduc_index == 1)\n-                    expr = build3 (code, vectype_out, def0, reduc_def, def1);\n-                  else\n-                    expr = build3 (code, vectype_out, def0, def1, reduc_def);\n-                }\n-            }\n+\t  tree vop[3] = { def0, NULL_TREE, NULL_TREE };\n+\t  if (op_type == ternary_op)\n+\t    vop[1] = vec_oprnds1[i];\n+\t  for (int k = 2; k > reduc_index; --k)\n+\t    vop[k] = vop[k - 1];\n+\t  vop[reduc_index] = reduc_def;\n \n-          new_stmt = gimple_build_assign (vec_dest, expr);\n           new_temp = make_ssa_name (vec_dest, new_stmt);\n-          gimple_assign_set_lhs (new_stmt, new_temp);\n+          new_stmt = gimple_build_assign (new_temp, code,\n+\t\t\t\t\t  vop[0], vop[1], vop[2]);\n           vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \n           if (slp_node)\n@@ -6336,7 +6403,6 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \tSTMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n \n       prev_stmt_info = vinfo_for_stmt (new_stmt);\n-      prev_phi_info = vinfo_for_stmt (new_phi);\n     }\n \n   /* Finalize the reduction-phi (set its arguments) and create the\n@@ -7285,7 +7351,9 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t      && dump_enabled_p ())\n \t    dump_printf_loc (MSG_NOTE, vect_location, \"multiple-types.\\n\");\n \n-\t  if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_induction_def\n+\t  if ((STMT_VINFO_DEF_TYPE (stmt_info) == vect_induction_def\n+\t       || STMT_VINFO_DEF_TYPE (stmt_info) == vect_reduction_def\n+\t       || STMT_VINFO_DEF_TYPE (stmt_info) == vect_nested_cycle)\n \t      && ! PURE_SLP_STMT (stmt_info))\n \t    {\n \t      if (dump_enabled_p ())"}, {"sha": "131f8f3b1a7c32972c7d7ef12f167c59c376d628", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c78e36522d21297b555185f5eeedd6e848eda684/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c78e36522d21297b555185f5eeedd6e848eda684/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=c78e36522d21297b555185f5eeedd6e848eda684", "patch": "@@ -403,9 +403,9 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char *swap,\n \t{\n \tcase vect_constant_def:\n \tcase vect_external_def:\n-\tcase vect_reduction_def:\n \t  break;\n \n+\tcase vect_reduction_def:\n \tcase vect_induction_def:\n \tcase vect_internal_def:\n \t  oprnd_info->def_stmts.quick_push (def_stmt);\n@@ -943,13 +943,15 @@ vect_build_slp_tree (vec_info *vinfo,\n   else\n     return NULL;\n \n-  /* If the SLP node is a PHI (induction), terminate the recursion.  */\n+  /* If the SLP node is a PHI (induction or reduction), terminate\n+     the recursion.  */\n   if (gimple_code (stmt) == GIMPLE_PHI)\n     {\n-      FOR_EACH_VEC_ELT (stmts, i, stmt)\n-\tif (stmt != stmts[0])\n-\t  /* Induction from different IVs is not supported.  */\n-\t  return NULL;\n+      /* Induction from different IVs is not supported.  */\n+      if (STMT_VINFO_DEF_TYPE (vinfo_for_stmt (stmt)) == vect_induction_def)\n+\tFOR_EACH_VEC_ELT (stmts, i, stmt)\n+\t  if (stmt != stmts[0])\n+\t    return NULL;\n       node = vect_create_new_slp_node (stmts);\n       return node;\n     }\n@@ -1005,6 +1007,7 @@ vect_build_slp_tree (vec_info *vinfo,\n       unsigned int j;\n \n       if (oprnd_info->first_dt != vect_internal_def\n+\t  && oprnd_info->first_dt != vect_reduction_def\n \t  && oprnd_info->first_dt != vect_induction_def)\n         continue;\n "}, {"sha": "99c071557d4488c1711c12bcae30c46389e5b5ec", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c78e36522d21297b555185f5eeedd6e848eda684/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c78e36522d21297b555185f5eeedd6e848eda684/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=c78e36522d21297b555185f5eeedd6e848eda684", "patch": "@@ -1367,14 +1367,10 @@ vect_get_vec_def_for_operand_1 (gimple *def_stmt, enum vect_def_type dt)\n         return vec_oprnd;\n       }\n \n-    /* operand is defined by a loop header phi - reduction  */\n+    /* operand is defined by a loop header phi.  */\n     case vect_reduction_def:\n     case vect_double_reduction_def:\n     case vect_nested_cycle:\n-      /* Code should use get_initial_def_for_reduction.  */\n-      gcc_unreachable ();\n-\n-    /* operand is defined by loop-header phi - induction.  */\n     case vect_induction_def:\n       {\n \tgcc_assert (gimple_code (def_stmt) == GIMPLE_PHI);\n@@ -1535,7 +1531,7 @@ vect_get_vec_def_for_stmt_copy (enum vect_def_type dt, tree vec_oprnd)\n /* Get vectorized definitions for the operands to create a copy of an original\n    stmt.  See vect_get_vec_def_for_stmt_copy () for details.  */\n \n-static void\n+void\n vect_get_vec_defs_for_stmt_copy (enum vect_def_type *dt,\n \t\t\t\t vec<tree> *vec_oprnds0,\n \t\t\t\t vec<tree> *vec_oprnds1)\n@@ -1554,11 +1550,9 @@ vect_get_vec_defs_for_stmt_copy (enum vect_def_type *dt,\n }\n \n \n-/* Get vectorized definitions for OP0 and OP1.\n-   REDUC_INDEX is the index of reduction operand in case of reduction,\n-   and -1 otherwise.  */\n+/* Get vectorized definitions for OP0 and OP1.  */\n \n-static void\n+void\n vect_get_vec_defs (tree op0, tree op1, gimple *stmt,\n \t\t   vec<tree> *vec_oprnds0,\n \t\t   vec<tree> *vec_oprnds1,"}, {"sha": "c4a84e8298d3e8447273a0d20b1dc161055d2dcd", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c78e36522d21297b555185f5eeedd6e848eda684/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c78e36522d21297b555185f5eeedd6e848eda684/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=c78e36522d21297b555185f5eeedd6e848eda684", "patch": "@@ -647,7 +647,9 @@ typedef struct _stmt_vec_info {\n      vect_force_simple_reduction.  */\n   enum vect_reduction_type reduc_type;\n \n-  /* On a reduction PHI the def returned by vect_force_simple_reduction.  */\n+  /* On a reduction PHI the def returned by vect_force_simple_reduction.\n+     On the def returned by vect_force_simple_reduction the\n+     corresponding PHI.  */\n   gimple *reduc_def;\n \n   /* The number of scalar stmt references from active SLP instances.  */\n@@ -1078,6 +1080,10 @@ extern void vect_finish_stmt_generation (gimple *, gimple *,\n extern bool vect_mark_stmts_to_be_vectorized (loop_vec_info);\n extern tree vect_get_vec_def_for_operand_1 (gimple *, enum vect_def_type);\n extern tree vect_get_vec_def_for_operand (tree, gimple *, tree = NULL);\n+extern void vect_get_vec_defs (tree, tree, gimple *, vec<tree> *,\n+\t\t\t       vec<tree> *, slp_tree);\n+extern void vect_get_vec_defs_for_stmt_copy (enum vect_def_type *,\n+\t\t\t\t\t     vec<tree> *, vec<tree> *);\n extern tree vect_init_vector (gimple *, tree, tree,\n                               gimple_stmt_iterator *);\n extern tree vect_get_vec_def_for_stmt_copy (enum vect_def_type, tree);"}]}