{"sha": "aa271860870b642b35b39938fdb39ff30af70c43", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWEyNzE4NjA4NzBiNjQyYjM1YjM5OTM4ZmRiMzlmZjMwYWY3MGM0Mw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2013-01-27T07:09:06Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2013-01-27T07:09:06Z"}, "message": "[multiple changes]\n\n2013-01-27 Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/55789\n\tPR fortran/56047\n\t* gfortran.h : Add associate_var to symbol_attr.\n\t* resolve.c (resolve_assoc_var): Set associate_var attribute.\n\tIf the target class_ok is set, set it for the associate\n\tvariable.\n\t* check.c (allocatable_check): Associate variables should not\n\thave the allocatable attribute even if their symbols do.\n\t* class.c (gfc_build_class_symbol): Symbols with associate_var\n\tset will always have a good class container.\n\n2013-01-27  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/55789\n\t* gfortran.dg/associate_14.f90: New test.\n\n\tPR fortran/56047\n\t* gfortran.dg/associate_13.f90: New test.\n\nFrom-SVN: r195492", "tree": {"sha": "fe0ca5f04c7acfc990df2467d358c30147ce59fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe0ca5f04c7acfc990df2467d358c30147ce59fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa271860870b642b35b39938fdb39ff30af70c43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa271860870b642b35b39938fdb39ff30af70c43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa271860870b642b35b39938fdb39ff30af70c43", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa271860870b642b35b39938fdb39ff30af70c43/comments", "author": null, "committer": null, "parents": [{"sha": "170c0f31d1e0080e8dba330d39fb37399df64b76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/170c0f31d1e0080e8dba330d39fb37399df64b76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/170c0f31d1e0080e8dba330d39fb37399df64b76"}], "stats": {"total": 114, "additions": 110, "deletions": 4}, "files": [{"sha": "38ae004913cf5efe0717d160e5274b14bc641536", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa271860870b642b35b39938fdb39ff30af70c43/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa271860870b642b35b39938fdb39ff30af70c43/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=aa271860870b642b35b39938fdb39ff30af70c43", "patch": "@@ -1,3 +1,16 @@\n+2013-01-27 Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/55789\n+\tPR fortran/56047\n+\t* gfortran.h : Add associate_var to symbol_attr.\n+\t* resolve.c (resolve_assoc_var): Set associate_var attribute.\n+\tIf the target class_ok is set, set it for the associate\n+\tvariable.\n+\t* check.c (allocatable_check): Associate variables should not\n+\thave the allocatable attribute even if their symbols do.\n+\t* class.c (gfc_build_class_symbol): Symbols with associate_var\n+\tset will always have a good class container.\n+\n 2013-01-23  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/56081"}, {"sha": "8bd06457ff4878f76ac4df5e57ac9f63c4b3ee9c", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa271860870b642b35b39938fdb39ff30af70c43/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa271860870b642b35b39938fdb39ff30af70c43/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=aa271860870b642b35b39938fdb39ff30af70c43", "patch": "@@ -454,7 +454,7 @@ allocatable_check (gfc_expr *e, int n)\n   symbol_attribute attr;\n \n   attr = gfc_variable_attr (e, NULL);\n-  if (!attr.allocatable)\n+  if (!attr.allocatable || attr.associate_var)\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L must be ALLOCATABLE\",\n \t\t gfc_current_intrinsic_arg[n]->name, gfc_current_intrinsic,"}, {"sha": "d8e7b6ded7a4e4d0e01133613803c473ea4b80e8", "filename": "gcc/fortran/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa271860870b642b35b39938fdb39ff30af70c43/gcc%2Ffortran%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa271860870b642b35b39938fdb39ff30af70c43/gcc%2Ffortran%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fclass.c?ref=aa271860870b642b35b39938fdb39ff30af70c43", "patch": "@@ -568,7 +568,7 @@ gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n     return SUCCESS;\n \n   attr->class_ok = attr->dummy || attr->pointer || attr->allocatable\n-\t\t   || attr->select_type_temporary;\n+\t\t   || attr->select_type_temporary || attr->associate_var;\n \n   if (!attr->class_ok)\n     /* We can not build the class container yet.  */"}, {"sha": "6be507fd676d0eb0c7353cf01e12cf51fcdaba42", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa271860870b642b35b39938fdb39ff30af70c43/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa271860870b642b35b39938fdb39ff30af70c43/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=aa271860870b642b35b39938fdb39ff30af70c43", "patch": "@@ -803,8 +803,9 @@ typedef struct\n \t   private_comp:1, zero_comp:1, coarray_comp:1, lock_comp:1,\n \t   defined_assign_comp:1, unlimited_polymorphic:1;\n \n-  /* This is a temporary selector for SELECT TYPE.  */\n-  unsigned select_type_temporary:1;\n+  /* This is a temporary selector for SELECT TYPE or an associate\n+     variable for SELECT_TYPE or ASSOCIATE.  */\n+  unsigned select_type_temporary:1, associate_var:1;\n \n   /* Attributes set by compiler extensions (!GCC$ ATTRIBUTES).  */\n   unsigned ext_attr:EXT_ATTR_NUM;"}, {"sha": "f2e6b9dd625ca0a4fd8155f4530f1677ba0e4cbb", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa271860870b642b35b39938fdb39ff30af70c43/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa271860870b642b35b39938fdb39ff30af70c43/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=aa271860870b642b35b39938fdb39ff30af70c43", "patch": "@@ -8325,6 +8325,13 @@ resolve_assoc_var (gfc_symbol* sym, bool resolve_target)\n \t has no corank.  */\n       sym->as->corank = 0;\n     }\n+\n+  /* Mark this as an associate variable.  */\n+  sym->attr.associate_var = 1;\n+\n+  /* If the target is a good class object, so is the associate variable.  */\n+  if (sym->ts.type == BT_CLASS && gfc_expr_attr (target).class_ok)\n+    sym->attr.class_ok = 1;\n }\n \n "}, {"sha": "b2fbe881c944537517452777ae098a4c1d4b007e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa271860870b642b35b39938fdb39ff30af70c43/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa271860870b642b35b39938fdb39ff30af70c43/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=aa271860870b642b35b39938fdb39ff30af70c43", "patch": "@@ -1,3 +1,11 @@\n+2013-01-27  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/55789\n+\t* gfortran.dg/associate_14.f90: New test.\n+\n+\tPR fortran/56047\n+\t* gfortran.dg/associate_13.f90: New test.\n+\n 2013-01-25  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/56098"}, {"sha": "7c64d3f0aa73059cd5c181e32b8ce82692ef2ebb", "filename": "gcc/testsuite/gfortran.dg/associate_13.f90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa271860870b642b35b39938fdb39ff30af70c43/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_13.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa271860870b642b35b39938fdb39ff30af70c43/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_13.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_13.f90?ref=aa271860870b642b35b39938fdb39ff30af70c43", "patch": "@@ -0,0 +1,21 @@\n+! { dg-do run }\n+!\n+! Tests the fix for PR56047.  This is actually a development of\n+! the test case of comment #10.\n+!\n+! Reported by Juergen Reuter  <juergen.reuter@desy.de>\n+!\n+  implicit none\n+  type :: process_variant_def_t\n+    integer :: i\n+  end type\n+  type :: process_component_def_t\n+     class(process_variant_def_t), allocatable :: variant_def\n+  end type\n+  type(process_component_def_t), dimension(1:2) :: initial\n+  allocate (initial(1)%variant_def, source = process_variant_def_t (99))\n+  associate (template => initial(1)%variant_def)\n+    template%i = 77\n+  end associate\n+  if (initial(1)%variant_def%i .ne. 77) call abort\n+end"}, {"sha": "765e36520c6d7dda0ef80b6f2bd88ad10ed4d57a", "filename": "gcc/testsuite/gfortran.dg/associate_14.f90", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa271860870b642b35b39938fdb39ff30af70c43/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_14.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa271860870b642b35b39938fdb39ff30af70c43/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_14.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_14.f90?ref=aa271860870b642b35b39938fdb39ff30af70c43", "patch": "@@ -0,0 +1,56 @@\n+! { dg-do compile }\n+! Tests the fix for PR55984.\n+!\n+! Contributed by Sylwester Arabas  <slayoo@staszic.waw.pl>\n+!\n+module bcd_m\n+  type, abstract :: bcd_t\n+    contains\n+    procedure(bcd_fill_halos), deferred :: fill_halos\n+  end type\n+  abstract interface\n+    subroutine bcd_fill_halos(this)\n+      import :: bcd_t\n+      class(bcd_t ) :: this\n+    end subroutine\n+  end interface\n+end module\n+\n+module solver_m\n+  use bcd_m\n+  type, abstract :: solver_t\n+    integer :: n, hlo\n+    class(bcd_t), pointer :: bcx, bcy\n+    contains\n+    procedure(solver_advop), deferred :: advop\n+  end type\n+  abstract interface\n+    subroutine solver_advop(this)\n+      import solver_t\n+      class(solver_t) :: this\n+    end subroutine\n+  end interface\n+  contains\n+end module\n+\n+module solver_mpdata_m\n+  use solver_m\n+  type :: mpdata_t\n+    class(bcd_t), pointer :: bcx, bcy\n+    contains\n+    procedure :: advop => mpdata_advop\n+  end type\n+  contains\n+  subroutine mpdata_advop(this)\n+    class(mpdata_t) :: this\n+    associate ( bcx => this%bcx, bcy => this%bcy )\n+      call bcx%fill_halos()\n+    end associate\n+  end subroutine\n+end module\n+\n+  use solver_mpdata_m\n+  class(mpdata_t), allocatable :: that\n+  call mpdata_advop (that)\n+end\n+"}]}