{"sha": "cd761692cbbaa21d141866df06be53c7af5435b5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Q3NjE2OTJjYmJhYTIxZDE0MTg2NmRmMDZiZTUzYzdhZjU0MzViNQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2017-11-23T20:19:01Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-11-23T20:19:01Z"}, "message": "rs6000.c (rs6000_gimple_fold_builtin): Formatting fixes.\n\n\t* config/rs6000/rs6000.c (rs6000_gimple_fold_builtin): Formatting\n\tfixes.  Declare temp and g variables at the top in order to avoid\n\t{} in most of the cases.\n\nFrom-SVN: r255118", "tree": {"sha": "59e8d93815d0dea18a0b084a7abb4d19c33a1126", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59e8d93815d0dea18a0b084a7abb4d19c33a1126"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd761692cbbaa21d141866df06be53c7af5435b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd761692cbbaa21d141866df06be53c7af5435b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd761692cbbaa21d141866df06be53c7af5435b5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd761692cbbaa21d141866df06be53c7af5435b5/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9c378aa9f4c34dcf06f58b8446858bf0aee7880e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c378aa9f4c34dcf06f58b8446858bf0aee7880e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c378aa9f4c34dcf06f58b8446858bf0aee7880e"}], "stats": {"total": 558, "additions": 261, "deletions": 297}, "files": [{"sha": "52b4f4ddd73a1d0d74e2470f7c4c0e6a7c682e2d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd761692cbbaa21d141866df06be53c7af5435b5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd761692cbbaa21d141866df06be53c7af5435b5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cd761692cbbaa21d141866df06be53c7af5435b5", "patch": "@@ -1,3 +1,9 @@\n+2017-11-23  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_gimple_fold_builtin): Formatting\n+\tfixes.  Declare temp and g variables at the top in order to avoid\n+\t{} in most of the cases.\n+\n 2017-11-23  Marc Glisse  <marc.glisse@inria.fr>\n \n \t* match.pd (ptr-0): New transformation."}, {"sha": "7212cddc9a76e29bd9ca2d52d1b6247d0d97389f", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 255, "deletions": 297, "changes": 552, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd761692cbbaa21d141866df06be53c7af5435b5/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd761692cbbaa21d141866df06be53c7af5435b5/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=cd761692cbbaa21d141866df06be53c7af5435b5", "patch": "@@ -16121,7 +16121,8 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n   gcc_checking_assert (fndecl && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_MD);\n   enum rs6000_builtins fn_code\n     = (enum rs6000_builtins) DECL_FUNCTION_CODE (fndecl);\n-  tree arg0, arg1, lhs;\n+  tree arg0, arg1, lhs, temp;\n+  gimple *g;\n \n   size_t uns_fncode = (size_t) fn_code;\n   enum insn_code icode = rs6000_builtin_info[uns_fncode].icode;\n@@ -16138,7 +16139,7 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n     return false;\n \n   /* Prevent gimple folding for code that does not have a LHS, unless it is\n-   allowed per the rs6000_builtin_valid_without_lhs helper function.  */\n+     allowed per the rs6000_builtin_valid_without_lhs helper function.  */\n   if (!gimple_call_lhs (stmt) && !rs6000_builtin_valid_without_lhs (fn_code))\n     return false;\n \n@@ -16153,15 +16154,13 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n     case P8V_BUILTIN_VADDUDM:\n     case ALTIVEC_BUILTIN_VADDFP:\n     case VSX_BUILTIN_XVADDDP:\n-      {\n-\targ0 = gimple_call_arg (stmt, 0);\n-\targ1 = gimple_call_arg (stmt, 1);\n-\tlhs = gimple_call_lhs (stmt);\n-\tgimple *g = gimple_build_assign (lhs, PLUS_EXPR, arg0, arg1);\n-\tgimple_set_location (g, gimple_location (stmt));\n-\tgsi_replace (gsi, g, true);\n-\treturn true;\n-      }\n+      arg0 = gimple_call_arg (stmt, 0);\n+      arg1 = gimple_call_arg (stmt, 1);\n+      lhs = gimple_call_lhs (stmt);\n+      g = gimple_build_assign (lhs, PLUS_EXPR, arg0, arg1);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_replace (gsi, g, true);\n+      return true;\n     /* Flavors of vec_sub.  We deliberately don't expand\n        P8V_BUILTIN_VSUBUQM. */\n     case ALTIVEC_BUILTIN_VSUBUBM:\n@@ -16170,26 +16169,22 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n     case P8V_BUILTIN_VSUBUDM:\n     case ALTIVEC_BUILTIN_VSUBFP:\n     case VSX_BUILTIN_XVSUBDP:\n-      {\n-\targ0 = gimple_call_arg (stmt, 0);\n-\targ1 = gimple_call_arg (stmt, 1);\n-\tlhs = gimple_call_lhs (stmt);\n-\tgimple *g = gimple_build_assign (lhs, MINUS_EXPR, arg0, arg1);\n-\tgimple_set_location (g, gimple_location (stmt));\n-\tgsi_replace (gsi, g, true);\n-\treturn true;\n-      }\n+      arg0 = gimple_call_arg (stmt, 0);\n+      arg1 = gimple_call_arg (stmt, 1);\n+      lhs = gimple_call_lhs (stmt);\n+      g = gimple_build_assign (lhs, MINUS_EXPR, arg0, arg1);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_replace (gsi, g, true);\n+      return true;\n     case VSX_BUILTIN_XVMULSP:\n     case VSX_BUILTIN_XVMULDP:\n-      {\n-\targ0 = gimple_call_arg (stmt, 0);\n-\targ1 = gimple_call_arg (stmt, 1);\n-\tlhs = gimple_call_lhs (stmt);\n-\tgimple *g = gimple_build_assign (lhs, MULT_EXPR, arg0, arg1);\n-\tgimple_set_location (g, gimple_location (stmt));\n-\tgsi_replace (gsi, g, true);\n-\treturn true;\n-      }\n+      arg0 = gimple_call_arg (stmt, 0);\n+      arg1 = gimple_call_arg (stmt, 1);\n+      lhs = gimple_call_lhs (stmt);\n+      g = gimple_build_assign (lhs, MULT_EXPR, arg0, arg1);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_replace (gsi, g, true);\n+      return true;\n     /* Even element flavors of vec_mul (signed). */\n     case ALTIVEC_BUILTIN_VMULESB:\n     case ALTIVEC_BUILTIN_VMULESH:\n@@ -16198,15 +16193,13 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n     case ALTIVEC_BUILTIN_VMULEUB:\n     case ALTIVEC_BUILTIN_VMULEUH:\n     case ALTIVEC_BUILTIN_VMULEUW:\n-      {\n-\targ0 = gimple_call_arg (stmt, 0);\n-\targ1 = gimple_call_arg (stmt, 1);\n-\tlhs = gimple_call_lhs (stmt);\n-\tgimple *g = gimple_build_assign (lhs, VEC_WIDEN_MULT_EVEN_EXPR, arg0, arg1);\n-\tgimple_set_location (g, gimple_location (stmt));\n-\tgsi_replace (gsi, g, true);\n-\treturn true;\n-      }\n+      arg0 = gimple_call_arg (stmt, 0);\n+      arg1 = gimple_call_arg (stmt, 1);\n+      lhs = gimple_call_lhs (stmt);\n+      g = gimple_build_assign (lhs, VEC_WIDEN_MULT_EVEN_EXPR, arg0, arg1);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_replace (gsi, g, true);\n+      return true;\n     /* Odd element flavors of vec_mul (signed).  */\n     case ALTIVEC_BUILTIN_VMULOSB:\n     case ALTIVEC_BUILTIN_VMULOSH:\n@@ -16215,65 +16208,55 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n     case ALTIVEC_BUILTIN_VMULOUB:\n     case ALTIVEC_BUILTIN_VMULOUH:\n     case ALTIVEC_BUILTIN_VMULOUW:\n-      {\n-\targ0 = gimple_call_arg (stmt, 0);\n-\targ1 = gimple_call_arg (stmt, 1);\n-\tlhs = gimple_call_lhs (stmt);\n-\tgimple *g = gimple_build_assign (lhs, VEC_WIDEN_MULT_ODD_EXPR, arg0, arg1);\n-\tgimple_set_location (g, gimple_location (stmt));\n-\tgsi_replace (gsi, g, true);\n-\treturn true;\n-      }\n+      arg0 = gimple_call_arg (stmt, 0);\n+      arg1 = gimple_call_arg (stmt, 1);\n+      lhs = gimple_call_lhs (stmt);\n+      g = gimple_build_assign (lhs, VEC_WIDEN_MULT_ODD_EXPR, arg0, arg1);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_replace (gsi, g, true);\n+      return true;\n     /* Flavors of vec_div (Integer).  */\n     case VSX_BUILTIN_DIV_V2DI:\n     case VSX_BUILTIN_UDIV_V2DI:\n-      {\n-\targ0 = gimple_call_arg (stmt, 0);\n-\targ1 = gimple_call_arg (stmt, 1);\n-\tlhs = gimple_call_lhs (stmt);\n-\tgimple *g = gimple_build_assign (lhs, TRUNC_DIV_EXPR, arg0, arg1);\n-\tgimple_set_location (g, gimple_location (stmt));\n-\tgsi_replace (gsi, g, true);\n-\treturn true;\n-      }\n+      arg0 = gimple_call_arg (stmt, 0);\n+      arg1 = gimple_call_arg (stmt, 1);\n+      lhs = gimple_call_lhs (stmt);\n+      g = gimple_build_assign (lhs, TRUNC_DIV_EXPR, arg0, arg1);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_replace (gsi, g, true);\n+      return true;\n     /* Flavors of vec_div (Float).  */\n     case VSX_BUILTIN_XVDIVSP:\n     case VSX_BUILTIN_XVDIVDP:\n-      {\n-\targ0 = gimple_call_arg (stmt, 0);\n-\targ1 = gimple_call_arg (stmt, 1);\n-\tlhs = gimple_call_lhs (stmt);\n-\tgimple *g = gimple_build_assign (lhs, RDIV_EXPR, arg0, arg1);\n-\tgimple_set_location (g, gimple_location (stmt));\n-\tgsi_replace (gsi, g, true);\n-\treturn true;\n-      }\n+      arg0 = gimple_call_arg (stmt, 0);\n+      arg1 = gimple_call_arg (stmt, 1);\n+      lhs = gimple_call_lhs (stmt);\n+      g = gimple_build_assign (lhs, RDIV_EXPR, arg0, arg1);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_replace (gsi, g, true);\n+      return true;\n     /* Flavors of vec_and.  */\n     case ALTIVEC_BUILTIN_VAND:\n-      {\n-\targ0 = gimple_call_arg (stmt, 0);\n-\targ1 = gimple_call_arg (stmt, 1);\n-\tlhs = gimple_call_lhs (stmt);\n-\tgimple *g = gimple_build_assign (lhs, BIT_AND_EXPR, arg0, arg1);\n-\tgimple_set_location (g, gimple_location (stmt));\n-\tgsi_replace (gsi, g, true);\n-\treturn true;\n-      }\n+      arg0 = gimple_call_arg (stmt, 0);\n+      arg1 = gimple_call_arg (stmt, 1);\n+      lhs = gimple_call_lhs (stmt);\n+      g = gimple_build_assign (lhs, BIT_AND_EXPR, arg0, arg1);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_replace (gsi, g, true);\n+      return true;\n     /* Flavors of vec_andc.  */\n     case ALTIVEC_BUILTIN_VANDC:\n-      {\n-\targ0 = gimple_call_arg (stmt, 0);\n-\targ1 = gimple_call_arg (stmt, 1);\n-\tlhs = gimple_call_lhs (stmt);\n-\ttree temp = create_tmp_reg_or_ssa_name (TREE_TYPE (arg1));\n-\tgimple *g = gimple_build_assign(temp, BIT_NOT_EXPR, arg1);\n-\tgimple_set_location (g, gimple_location (stmt));\n-\tgsi_insert_before(gsi, g, GSI_SAME_STMT);\n-\tg = gimple_build_assign (lhs, BIT_AND_EXPR, arg0, temp);\n-\tgimple_set_location (g, gimple_location (stmt));\n-\tgsi_replace (gsi, g, true);\n-\treturn true;\n-      }\n+      arg0 = gimple_call_arg (stmt, 0);\n+      arg1 = gimple_call_arg (stmt, 1);\n+      lhs = gimple_call_lhs (stmt);\n+      temp = create_tmp_reg_or_ssa_name (TREE_TYPE (arg1));\n+      g = gimple_build_assign (temp, BIT_NOT_EXPR, arg1);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_insert_before (gsi, g, GSI_SAME_STMT);\n+      g = gimple_build_assign (lhs, BIT_AND_EXPR, arg0, temp);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_replace (gsi, g, true);\n+      return true;\n     /* Flavors of vec_nand.  */\n     case P8V_BUILTIN_VEC_NAND:\n     case P8V_BUILTIN_NAND_V16QI:\n@@ -16282,94 +16265,82 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n     case P8V_BUILTIN_NAND_V4SF:\n     case P8V_BUILTIN_NAND_V2DF:\n     case P8V_BUILTIN_NAND_V2DI:\n-      {\n-\targ0 = gimple_call_arg (stmt, 0);\n-\targ1 = gimple_call_arg (stmt, 1);\n-\tlhs = gimple_call_lhs (stmt);\n-\ttree temp = create_tmp_reg_or_ssa_name (TREE_TYPE (arg1));\n-\tgimple *g = gimple_build_assign(temp, BIT_AND_EXPR, arg0, arg1);\n-\tgimple_set_location (g, gimple_location (stmt));\n-\tgsi_insert_before(gsi, g, GSI_SAME_STMT);\n-\tg = gimple_build_assign (lhs, BIT_NOT_EXPR, temp);\n-\tgimple_set_location (g, gimple_location (stmt));\n-\tgsi_replace (gsi, g, true);\n-\treturn true;\n-      }\n+      arg0 = gimple_call_arg (stmt, 0);\n+      arg1 = gimple_call_arg (stmt, 1);\n+      lhs = gimple_call_lhs (stmt);\n+      temp = create_tmp_reg_or_ssa_name (TREE_TYPE (arg1));\n+      g = gimple_build_assign (temp, BIT_AND_EXPR, arg0, arg1);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_insert_before (gsi, g, GSI_SAME_STMT);\n+      g = gimple_build_assign (lhs, BIT_NOT_EXPR, temp);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_replace (gsi, g, true);\n+      return true;\n     /* Flavors of vec_or.  */\n     case ALTIVEC_BUILTIN_VOR:\n-      {\n-\targ0 = gimple_call_arg (stmt, 0);\n-\targ1 = gimple_call_arg (stmt, 1);\n-\tlhs = gimple_call_lhs (stmt);\n-\tgimple *g = gimple_build_assign (lhs, BIT_IOR_EXPR, arg0, arg1);\n-\tgimple_set_location (g, gimple_location (stmt));\n-\tgsi_replace (gsi, g, true);\n-\treturn true;\n-      }\n+      arg0 = gimple_call_arg (stmt, 0);\n+      arg1 = gimple_call_arg (stmt, 1);\n+      lhs = gimple_call_lhs (stmt);\n+      g = gimple_build_assign (lhs, BIT_IOR_EXPR, arg0, arg1);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_replace (gsi, g, true);\n+      return true;\n     /* flavors of vec_orc.  */\n     case P8V_BUILTIN_ORC_V16QI:\n     case P8V_BUILTIN_ORC_V8HI:\n     case P8V_BUILTIN_ORC_V4SI:\n     case P8V_BUILTIN_ORC_V4SF:\n     case P8V_BUILTIN_ORC_V2DF:\n     case P8V_BUILTIN_ORC_V2DI:\n-      {\n-\targ0 = gimple_call_arg (stmt, 0);\n-\targ1 = gimple_call_arg (stmt, 1);\n-\tlhs = gimple_call_lhs (stmt);\n-\ttree temp = create_tmp_reg_or_ssa_name (TREE_TYPE (arg1));\n-\tgimple *g = gimple_build_assign(temp, BIT_NOT_EXPR, arg1);\n-\tgimple_set_location (g, gimple_location (stmt));\n-\tgsi_insert_before(gsi, g, GSI_SAME_STMT);\n-\tg = gimple_build_assign (lhs, BIT_IOR_EXPR, arg0, temp);\n-\tgimple_set_location (g, gimple_location (stmt));\n-\tgsi_replace (gsi, g, true);\n-\treturn true;\n-      }\n+      arg0 = gimple_call_arg (stmt, 0);\n+      arg1 = gimple_call_arg (stmt, 1);\n+      lhs = gimple_call_lhs (stmt);\n+      temp = create_tmp_reg_or_ssa_name (TREE_TYPE (arg1));\n+      g = gimple_build_assign (temp, BIT_NOT_EXPR, arg1);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_insert_before (gsi, g, GSI_SAME_STMT);\n+      g = gimple_build_assign (lhs, BIT_IOR_EXPR, arg0, temp);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_replace (gsi, g, true);\n+      return true;\n     /* Flavors of vec_xor.  */\n     case ALTIVEC_BUILTIN_VXOR:\n-      {\n-\targ0 = gimple_call_arg (stmt, 0);\n-\targ1 = gimple_call_arg (stmt, 1);\n-\tlhs = gimple_call_lhs (stmt);\n-\tgimple *g = gimple_build_assign (lhs, BIT_XOR_EXPR, arg0, arg1);\n-\tgimple_set_location (g, gimple_location (stmt));\n-\tgsi_replace (gsi, g, true);\n-\treturn true;\n-      }\n+      arg0 = gimple_call_arg (stmt, 0);\n+      arg1 = gimple_call_arg (stmt, 1);\n+      lhs = gimple_call_lhs (stmt);\n+      g = gimple_build_assign (lhs, BIT_XOR_EXPR, arg0, arg1);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_replace (gsi, g, true);\n+      return true;\n     /* Flavors of vec_nor.  */\n     case ALTIVEC_BUILTIN_VNOR:\n-      {\n-\targ0 = gimple_call_arg (stmt, 0);\n-\targ1 = gimple_call_arg (stmt, 1);\n-\tlhs = gimple_call_lhs (stmt);\n-\ttree temp = create_tmp_reg_or_ssa_name (TREE_TYPE (arg1));\n-\tgimple *g = gimple_build_assign (temp, BIT_IOR_EXPR, arg0, arg1);\n-\tgimple_set_location (g, gimple_location (stmt));\n-\tgsi_insert_before(gsi, g, GSI_SAME_STMT);\n-\tg = gimple_build_assign (lhs, BIT_NOT_EXPR, temp);\n-\tgimple_set_location (g, gimple_location (stmt));\n-\tgsi_replace (gsi, g, true);\n-\treturn true;\n-      }\n+      arg0 = gimple_call_arg (stmt, 0);\n+      arg1 = gimple_call_arg (stmt, 1);\n+      lhs = gimple_call_lhs (stmt);\n+      temp = create_tmp_reg_or_ssa_name (TREE_TYPE (arg1));\n+      g = gimple_build_assign (temp, BIT_IOR_EXPR, arg0, arg1);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_insert_before (gsi, g, GSI_SAME_STMT);\n+      g = gimple_build_assign (lhs, BIT_NOT_EXPR, temp);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_replace (gsi, g, true);\n+      return true;\n     /* flavors of vec_abs.  */\n     case ALTIVEC_BUILTIN_ABS_V16QI:\n     case ALTIVEC_BUILTIN_ABS_V8HI:\n     case ALTIVEC_BUILTIN_ABS_V4SI:\n     case ALTIVEC_BUILTIN_ABS_V4SF:\n     case P8V_BUILTIN_ABS_V2DI:\n     case VSX_BUILTIN_XVABSDP:\n-      {\n-\targ0 = gimple_call_arg (stmt, 0);\n-\tif (INTEGRAL_TYPE_P (TREE_TYPE (TREE_TYPE (arg0)))\n-\t    && !TYPE_OVERFLOW_WRAPS (TREE_TYPE (TREE_TYPE (arg0))))\n-\t      return false;\n-\tlhs = gimple_call_lhs (stmt);\n-\tgimple *g = gimple_build_assign (lhs, ABS_EXPR, arg0);\n-\tgimple_set_location (g, gimple_location (stmt));\n-\tgsi_replace (gsi, g, true);\n-\treturn true;\n-      }\n+      arg0 = gimple_call_arg (stmt, 0);\n+      if (INTEGRAL_TYPE_P (TREE_TYPE (TREE_TYPE (arg0)))\n+\t  && !TYPE_OVERFLOW_WRAPS (TREE_TYPE (TREE_TYPE (arg0))))\n+\treturn false;\n+      lhs = gimple_call_lhs (stmt);\n+      g = gimple_build_assign (lhs, ABS_EXPR, arg0);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_replace (gsi, g, true);\n+      return true;\n     /* flavors of vec_min.  */\n     case VSX_BUILTIN_XVMINDP:\n     case P8V_BUILTIN_VMINSD:\n@@ -16381,15 +16352,13 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n     case ALTIVEC_BUILTIN_VMINUH:\n     case ALTIVEC_BUILTIN_VMINUW:\n     case ALTIVEC_BUILTIN_VMINFP:\n-      {\n-\targ0 = gimple_call_arg (stmt, 0);\n-\targ1 = gimple_call_arg (stmt, 1);\n-\tlhs = gimple_call_lhs (stmt);\n-\tgimple *g = gimple_build_assign (lhs, MIN_EXPR, arg0, arg1);\n-\tgimple_set_location (g, gimple_location (stmt));\n-\tgsi_replace (gsi, g, true);\n-\treturn true;\n-      }\n+      arg0 = gimple_call_arg (stmt, 0);\n+      arg1 = gimple_call_arg (stmt, 1);\n+      lhs = gimple_call_lhs (stmt);\n+      g = gimple_build_assign (lhs, MIN_EXPR, arg0, arg1);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_replace (gsi, g, true);\n+      return true;\n     /* flavors of vec_max.  */\n     case VSX_BUILTIN_XVMAXDP:\n     case P8V_BUILTIN_VMAXSD:\n@@ -16401,82 +16370,72 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n     case ALTIVEC_BUILTIN_VMAXUH:\n     case ALTIVEC_BUILTIN_VMAXUW:\n     case ALTIVEC_BUILTIN_VMAXFP:\n-      {\n-\targ0 = gimple_call_arg (stmt, 0);\n-\targ1 = gimple_call_arg (stmt, 1);\n-\tlhs = gimple_call_lhs (stmt);\n-\tgimple *g = gimple_build_assign (lhs, MAX_EXPR, arg0, arg1);\n-\tgimple_set_location (g, gimple_location (stmt));\n-\tgsi_replace (gsi, g, true);\n-\treturn true;\n-      }\n+      arg0 = gimple_call_arg (stmt, 0);\n+      arg1 = gimple_call_arg (stmt, 1);\n+      lhs = gimple_call_lhs (stmt);\n+      g = gimple_build_assign (lhs, MAX_EXPR, arg0, arg1);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_replace (gsi, g, true);\n+      return true;\n     /* Flavors of vec_eqv.  */\n     case P8V_BUILTIN_EQV_V16QI:\n     case P8V_BUILTIN_EQV_V8HI:\n     case P8V_BUILTIN_EQV_V4SI:\n     case P8V_BUILTIN_EQV_V4SF:\n     case P8V_BUILTIN_EQV_V2DF:\n     case P8V_BUILTIN_EQV_V2DI:\n-      {\n-\targ0 = gimple_call_arg (stmt, 0);\n-\targ1 = gimple_call_arg (stmt, 1);\n-\tlhs = gimple_call_lhs (stmt);\n-\ttree temp = create_tmp_reg_or_ssa_name (TREE_TYPE (arg1));\n-\tgimple *g = gimple_build_assign (temp, BIT_XOR_EXPR, arg0, arg1);\n-\tgimple_set_location (g, gimple_location (stmt));\n-\tgsi_insert_before (gsi, g, GSI_SAME_STMT);\n-\tg = gimple_build_assign (lhs, BIT_NOT_EXPR, temp);\n-\tgimple_set_location (g, gimple_location (stmt));\n-\tgsi_replace (gsi, g, true);\n-\treturn true;\n-      }\n+      arg0 = gimple_call_arg (stmt, 0);\n+      arg1 = gimple_call_arg (stmt, 1);\n+      lhs = gimple_call_lhs (stmt);\n+      temp = create_tmp_reg_or_ssa_name (TREE_TYPE (arg1));\n+      g = gimple_build_assign (temp, BIT_XOR_EXPR, arg0, arg1);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_insert_before (gsi, g, GSI_SAME_STMT);\n+      g = gimple_build_assign (lhs, BIT_NOT_EXPR, temp);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_replace (gsi, g, true);\n+      return true;\n     /* Flavors of vec_rotate_left.  */\n     case ALTIVEC_BUILTIN_VRLB:\n     case ALTIVEC_BUILTIN_VRLH:\n     case ALTIVEC_BUILTIN_VRLW:\n     case P8V_BUILTIN_VRLD:\n-      {\n-\targ0 = gimple_call_arg (stmt, 0);\n-\targ1 = gimple_call_arg (stmt, 1);\n-\tlhs = gimple_call_lhs (stmt);\n-\tgimple *g = gimple_build_assign (lhs, LROTATE_EXPR, arg0, arg1);\n-\tgimple_set_location (g, gimple_location (stmt));\n-\tgsi_replace (gsi, g, true);\n-\treturn true;\n-      }\n+      arg0 = gimple_call_arg (stmt, 0);\n+      arg1 = gimple_call_arg (stmt, 1);\n+      lhs = gimple_call_lhs (stmt);\n+      g = gimple_build_assign (lhs, LROTATE_EXPR, arg0, arg1);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_replace (gsi, g, true);\n+      return true;\n   /* Flavors of vector shift right algebraic.\n      vec_sra{b,h,w} -> vsra{b,h,w}.  */\n     case ALTIVEC_BUILTIN_VSRAB:\n     case ALTIVEC_BUILTIN_VSRAH:\n     case ALTIVEC_BUILTIN_VSRAW:\n     case P8V_BUILTIN_VSRAD:\n-      {\n-\targ0 = gimple_call_arg (stmt, 0);\n-\targ1 = gimple_call_arg (stmt, 1);\n-\tlhs = gimple_call_lhs (stmt);\n-\tgimple *g = gimple_build_assign (lhs, RSHIFT_EXPR, arg0, arg1);\n-\tgimple_set_location (g, gimple_location (stmt));\n-\tgsi_replace (gsi, g, true);\n-\treturn true;\n-      }\n+      arg0 = gimple_call_arg (stmt, 0);\n+      arg1 = gimple_call_arg (stmt, 1);\n+      lhs = gimple_call_lhs (stmt);\n+      g = gimple_build_assign (lhs, RSHIFT_EXPR, arg0, arg1);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_replace (gsi, g, true);\n+      return true;\n    /* Flavors of vector shift left.\n       builtin_altivec_vsl{b,h,w} -> vsl{b,h,w}.  */\n     case ALTIVEC_BUILTIN_VSLB:\n     case ALTIVEC_BUILTIN_VSLH:\n     case ALTIVEC_BUILTIN_VSLW:\n     case P8V_BUILTIN_VSLD:\n-      {\n-\targ0 = gimple_call_arg (stmt, 0);\n-\tif (INTEGRAL_TYPE_P (TREE_TYPE (TREE_TYPE (arg0)))\n-\t    && !TYPE_OVERFLOW_WRAPS (TREE_TYPE (TREE_TYPE (arg0))))\n-\t      return false;\n-\targ1 = gimple_call_arg (stmt, 1);\n-\tlhs = gimple_call_lhs (stmt);\n-\tgimple *g = gimple_build_assign (lhs, LSHIFT_EXPR, arg0, arg1);\n-\tgimple_set_location (g, gimple_location (stmt));\n-\tgsi_replace (gsi, g, true);\n-\treturn true;\n-      }\n+      arg0 = gimple_call_arg (stmt, 0);\n+      if (INTEGRAL_TYPE_P (TREE_TYPE (TREE_TYPE (arg0)))\n+\t  && !TYPE_OVERFLOW_WRAPS (TREE_TYPE (TREE_TYPE (arg0))))\n+\treturn false;\n+      arg1 = gimple_call_arg (stmt, 1);\n+      lhs = gimple_call_lhs (stmt);\n+      g = gimple_build_assign (lhs, LSHIFT_EXPR, arg0, arg1);\n+      gimple_set_location (g, gimple_location (stmt));\n+      gsi_replace (gsi, g, true);\n+      return true;\n     /* Flavors of vector shift right.  */\n     case ALTIVEC_BUILTIN_VSRB:\n     case ALTIVEC_BUILTIN_VSRH:\n@@ -16489,11 +16448,11 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n \tgimple_seq stmts = NULL;\n \t/* Convert arg0 to unsigned.  */\n \ttree arg0_unsigned\n-\t   = gimple_build (&stmts, VIEW_CONVERT_EXPR,\n-\t\t\t   unsigned_type_for (TREE_TYPE (arg0)), arg0);\n+\t  = gimple_build (&stmts, VIEW_CONVERT_EXPR,\n+\t\t\t  unsigned_type_for (TREE_TYPE (arg0)), arg0);\n \ttree res\n-\t   = gimple_build (&stmts, RSHIFT_EXPR,\n-\t\t\t   TREE_TYPE (arg0_unsigned), arg0_unsigned, arg1);\n+\t  = gimple_build (&stmts, RSHIFT_EXPR,\n+\t\t\t  TREE_TYPE (arg0_unsigned), arg0_unsigned, arg1);\n \t/* Convert result back to the lhs type.  */\n \tres = gimple_build (&stmts, VIEW_CONVERT_EXPR, TREE_TYPE (lhs), res);\n \tgsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n@@ -16508,38 +16467,38 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n     case ALTIVEC_BUILTIN_LVX_V2DI:\n     case ALTIVEC_BUILTIN_LVX_V2DF:\n       {\n-\t arg0 = gimple_call_arg (stmt, 0);  // offset\n-\t arg1 = gimple_call_arg (stmt, 1);  // address\n-\t /* Do not fold for -maltivec=be on LE targets.  */\n-\t if (VECTOR_ELT_ORDER_BIG && !BYTES_BIG_ENDIAN)\n-\t    return false;\n-\t lhs = gimple_call_lhs (stmt);\n-\t location_t loc = gimple_location (stmt);\n-\t /* Since arg1 may be cast to a different type, just use ptr_type_node\n-\t    here instead of trying to enforce TBAA on pointer types.  */\n-\t tree arg1_type = ptr_type_node;\n-\t tree lhs_type = TREE_TYPE (lhs);\n-\t /* POINTER_PLUS_EXPR wants the offset to be of type 'sizetype'.  Create\n-\t    the tree using the value from arg0.  The resulting type will match\n-\t    the type of arg1.  */\n-\t gimple_seq stmts = NULL;\n-\t tree temp_offset = gimple_convert (&stmts, loc, sizetype, arg0);\n-\t tree temp_addr = gimple_build (&stmts, loc, POINTER_PLUS_EXPR,\n+\targ0 = gimple_call_arg (stmt, 0);  // offset\n+\targ1 = gimple_call_arg (stmt, 1);  // address\n+\t/* Do not fold for -maltivec=be on LE targets.  */\n+\tif (VECTOR_ELT_ORDER_BIG && !BYTES_BIG_ENDIAN)\n+\t  return false;\n+\tlhs = gimple_call_lhs (stmt);\n+\tlocation_t loc = gimple_location (stmt);\n+\t/* Since arg1 may be cast to a different type, just use ptr_type_node\n+\t   here instead of trying to enforce TBAA on pointer types.  */\n+\ttree arg1_type = ptr_type_node;\n+\ttree lhs_type = TREE_TYPE (lhs);\n+\t/* POINTER_PLUS_EXPR wants the offset to be of type 'sizetype'.  Create\n+\t   the tree using the value from arg0.  The resulting type will match\n+\t   the type of arg1.  */\n+\tgimple_seq stmts = NULL;\n+\ttree temp_offset = gimple_convert (&stmts, loc, sizetype, arg0);\n+\ttree temp_addr = gimple_build (&stmts, loc, POINTER_PLUS_EXPR,\n \t\t\t\t       arg1_type, arg1, temp_offset);\n-\t /* Mask off any lower bits from the address.  */\n-\t tree aligned_addr = gimple_build (&stmts, loc, BIT_AND_EXPR,\n+\t/* Mask off any lower bits from the address.  */\n+\ttree aligned_addr = gimple_build (&stmts, loc, BIT_AND_EXPR,\n \t\t\t\t\t  arg1_type, temp_addr,\n \t\t\t\t\t  build_int_cst (arg1_type, -16));\n-\t gsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n-\t /* Use the build2 helper to set up the mem_ref.  The MEM_REF could also\n-\t    take an offset, but since we've already incorporated the offset\n-\t    above, here we just pass in a zero.  */\n-\t gimple *g;\n-\t g = gimple_build_assign (lhs, build2 (MEM_REF, lhs_type, aligned_addr,\n-\t\t\t\t\t\tbuild_int_cst (arg1_type, 0)));\n-\t gimple_set_location (g, loc);\n-\t gsi_replace (gsi, g, true);\n-\t return true;\n+\tgsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n+\t/* Use the build2 helper to set up the mem_ref.  The MEM_REF could also\n+\t   take an offset, but since we've already incorporated the offset\n+\t   above, here we just pass in a zero.  */\n+\tgimple *g\n+\t  = gimple_build_assign (lhs, build2 (MEM_REF, lhs_type, aligned_addr,\n+\t\t\t\t\t      build_int_cst (arg1_type, 0)));\n+\tgimple_set_location (g, loc);\n+\tgsi_replace (gsi, g, true);\n+\treturn true;\n       }\n     /* Vector stores.  */\n     case ALTIVEC_BUILTIN_STVX_V16QI:\n@@ -16549,69 +16508,68 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n     case ALTIVEC_BUILTIN_STVX_V2DI:\n     case ALTIVEC_BUILTIN_STVX_V2DF:\n       {\n-\t /* Do not fold for -maltivec=be on LE targets.  */\n-\t if (VECTOR_ELT_ORDER_BIG && !BYTES_BIG_ENDIAN)\n-\t    return false;\n-\t arg0 = gimple_call_arg (stmt, 0); /* Value to be stored.  */\n-\t arg1 = gimple_call_arg (stmt, 1); /* Offset.  */\n-\t tree arg2 = gimple_call_arg (stmt, 2); /* Store-to address.  */\n-\t location_t loc = gimple_location (stmt);\n-\t tree arg0_type = TREE_TYPE (arg0);\n-\t /* Use ptr_type_node (no TBAA) for the arg2_type.\n-\t  FIXME: (Richard)  \"A proper fix would be to transition this type as\n-\t  seen from the frontend to GIMPLE, for example in a similar way we\n-\t  do for MEM_REFs by piggy-backing that on an extra argument, a\n-\t  constant zero pointer of the alias pointer type to use (which would\n-\t  also serve as a type indicator of the store itself).  I'd use a\n-\t  target specific internal function for this (not sure if we can have\n-\t  those target specific, but I guess if it's folded away then that's\n-\t  fine) and get away with the overload set.\"\n-\t  */\n-\t tree arg2_type = ptr_type_node;\n-\t /* POINTER_PLUS_EXPR wants the offset to be of type 'sizetype'.  Create\n-\t    the tree using the value from arg0.  The resulting type will match\n-\t    the type of arg2.  */\n-\t gimple_seq stmts = NULL;\n-\t tree temp_offset = gimple_convert (&stmts, loc, sizetype, arg1);\n-\t tree temp_addr = gimple_build (&stmts, loc, POINTER_PLUS_EXPR,\n+\t/* Do not fold for -maltivec=be on LE targets.  */\n+\tif (VECTOR_ELT_ORDER_BIG && !BYTES_BIG_ENDIAN)\n+\t  return false;\n+\targ0 = gimple_call_arg (stmt, 0); /* Value to be stored.  */\n+\targ1 = gimple_call_arg (stmt, 1); /* Offset.  */\n+\ttree arg2 = gimple_call_arg (stmt, 2); /* Store-to address.  */\n+\tlocation_t loc = gimple_location (stmt);\n+\ttree arg0_type = TREE_TYPE (arg0);\n+\t/* Use ptr_type_node (no TBAA) for the arg2_type.\n+\t   FIXME: (Richard)  \"A proper fix would be to transition this type as\n+\t   seen from the frontend to GIMPLE, for example in a similar way we\n+\t   do for MEM_REFs by piggy-backing that on an extra argument, a\n+\t   constant zero pointer of the alias pointer type to use (which would\n+\t   also serve as a type indicator of the store itself).  I'd use a\n+\t   target specific internal function for this (not sure if we can have\n+\t   those target specific, but I guess if it's folded away then that's\n+\t   fine) and get away with the overload set.\"  */\n+\ttree arg2_type = ptr_type_node;\n+\t/* POINTER_PLUS_EXPR wants the offset to be of type 'sizetype'.  Create\n+\t   the tree using the value from arg0.  The resulting type will match\n+\t   the type of arg2.  */\n+\tgimple_seq stmts = NULL;\n+\ttree temp_offset = gimple_convert (&stmts, loc, sizetype, arg1);\n+\ttree temp_addr = gimple_build (&stmts, loc, POINTER_PLUS_EXPR,\n \t\t\t\t       arg2_type, arg2, temp_offset);\n-\t /* Mask off any lower bits from the address.  */\n-\t tree aligned_addr = gimple_build (&stmts, loc, BIT_AND_EXPR,\n+\t/* Mask off any lower bits from the address.  */\n+\ttree aligned_addr = gimple_build (&stmts, loc, BIT_AND_EXPR,\n \t\t\t\t\t  arg2_type, temp_addr,\n \t\t\t\t\t  build_int_cst (arg2_type, -16));\n-\t gsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n+\tgsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n \t/* The desired gimple result should be similar to:\n-\t MEM[(__vector floatD.1407 *)_1] = vf1D.2697;  */\n-\t gimple *g;\n-\t g = gimple_build_assign (build2 (MEM_REF, arg0_type, aligned_addr,\n-\t\t\t\t\t   build_int_cst (arg2_type, 0)), arg0);\n-\t gimple_set_location (g, loc);\n-\t gsi_replace (gsi, g, true);\n-\t return true;\n+\t   MEM[(__vector floatD.1407 *)_1] = vf1D.2697;  */\n+\tgimple *g\n+\t  = gimple_build_assign (build2 (MEM_REF, arg0_type, aligned_addr,\n+\t\t\t\t\t build_int_cst (arg2_type, 0)), arg0);\n+\tgimple_set_location (g, loc);\n+\tgsi_replace (gsi, g, true);\n+\treturn true;\n       }\n \n     /* Vector Fused multiply-add (fma).  */\n     case ALTIVEC_BUILTIN_VMADDFP:\n     case VSX_BUILTIN_XVMADDDP:\n     case ALTIVEC_BUILTIN_VMLADDUHM:\n       {\n-       arg0 = gimple_call_arg (stmt, 0);\n-       arg1 = gimple_call_arg (stmt, 1);\n-       tree arg2 = gimple_call_arg (stmt, 2);\n-       lhs = gimple_call_lhs (stmt);\n-       gimple *g = gimple_build_assign (lhs, FMA_EXPR , arg0, arg1, arg2);\n-       gimple_set_location (g, gimple_location (stmt));\n-       gsi_replace (gsi, g, true);\n-       return true;\n+\targ0 = gimple_call_arg (stmt, 0);\n+\targ1 = gimple_call_arg (stmt, 1);\n+\ttree arg2 = gimple_call_arg (stmt, 2);\n+\tlhs = gimple_call_lhs (stmt);\n+\tgimple *g = gimple_build_assign (lhs, FMA_EXPR, arg0, arg1, arg2);\n+\tgimple_set_location (g, gimple_location (stmt));\n+\tgsi_replace (gsi, g, true);\n+\treturn true;\n       }\n \n     /* Vector compares; EQ, NE, GE, GT, LE.  */\n     case ALTIVEC_BUILTIN_VCMPEQUB:\n     case ALTIVEC_BUILTIN_VCMPEQUH:\n     case ALTIVEC_BUILTIN_VCMPEQUW:\n     case P8V_BUILTIN_VCMPEQUD:\n-\tfold_compare_helper (gsi, EQ_EXPR, stmt);\n-\treturn true;\n+      fold_compare_helper (gsi, EQ_EXPR, stmt);\n+      return true;\n \n     case P9V_BUILTIN_CMPNEB:\n     case P9V_BUILTIN_CMPNEH:\n@@ -16653,9 +16611,9 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n       return true;\n \n     default:\n-\tif (TARGET_DEBUG_BUILTIN)\n-\t   fprintf (stderr, \"gimple builtin intrinsic not matched:%d %s %s\\n\",\n-\t\t    fn_code, fn_name1, fn_name2);\n+      if (TARGET_DEBUG_BUILTIN)\n+\tfprintf (stderr, \"gimple builtin intrinsic not matched:%d %s %s\\n\",\n+\t\t fn_code, fn_name1, fn_name2);\n       break;\n     }\n "}]}