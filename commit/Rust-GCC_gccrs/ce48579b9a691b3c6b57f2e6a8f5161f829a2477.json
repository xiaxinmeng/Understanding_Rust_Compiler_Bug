{"sha": "ce48579b9a691b3c6b57f2e6a8f5161f829a2477", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2U0ODU3OWI5YTY5MWIzYzZiNTdmMmU2YThmNTE2MWY4MjlhMjQ3Nw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-04-28T18:25:23Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-04-28T18:25:23Z"}, "message": "calls.c (combine_pending_stack_adjustment_and_call): Return the adjustment; don't do the stack adjust.\n\n        * calls.c (combine_pending_stack_adjustment_and_call): Return the\n        adjustment; don't do the stack adjust.\n        (expand_call): Call compute_argument_block_size right before\n        allocating the block; update comment; don't do alignment sanity\n        checking for sibling call; use args_size instead of\n        unadjusted_args_size before args_size is adjusted.  Use\n        combine_pending_stack_adjustment_and_call to compute stack adjust\n        for must_preallocate case.\n\n        * expr.c (push_block): Remove shadow `temp' in inner scope.\n\nCo-Authored-By: Jan Hubicka <jh@suse.cz>\n\nFrom-SVN: r33516", "tree": {"sha": "e75c3ecd031d33c167b1cec66724b2616b301ce9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e75c3ecd031d33c167b1cec66724b2616b301ce9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce48579b9a691b3c6b57f2e6a8f5161f829a2477", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce48579b9a691b3c6b57f2e6a8f5161f829a2477", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce48579b9a691b3c6b57f2e6a8f5161f829a2477", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce48579b9a691b3c6b57f2e6a8f5161f829a2477/comments", "author": null, "committer": null, "parents": [{"sha": "f1f39752d65187341d19c164ba18f6d8c1ce5a6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1f39752d65187341d19c164ba18f6d8c1ce5a6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1f39752d65187341d19c164ba18f6d8c1ce5a6a"}], "stats": {"total": 146, "additions": 92, "deletions": 54}, "files": [{"sha": "7db2bc046eee32ce71009732b38fe5624f3ebab7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce48579b9a691b3c6b57f2e6a8f5161f829a2477/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce48579b9a691b3c6b57f2e6a8f5161f829a2477/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ce48579b9a691b3c6b57f2e6a8f5161f829a2477", "patch": "@@ -1,3 +1,17 @@\n+2000-04-28  Richard Henderson  <rth@cygnus.com>\n+\t    Jan Hubicka  <jh@suse.cz>\n+\n+\t* calls.c (combine_pending_stack_adjustment_and_call): Return the\n+\tadjustment; don't do the stack adjust.\n+\t(expand_call): Call compute_argument_block_size right before\n+\tallocating the block; update comment; don't do alignment sanity\n+\tchecking for sibling call; use args_size instead of\n+\tunadjusted_args_size before args_size is adjusted.  Use\n+\tcombine_pending_stack_adjustment_and_call to compute stack adjust\n+\tfor must_preallocate case.\n+\n+\t* expr.c (push_block): Remove shadow `temp' in inner scope.\n+\n 2000-04-28  Jason Merrill  <jason@casey.cygnus.com>\n \n \t* toplev.c (rest_of_compilation): Call "}, {"sha": "eff0042422f797f94a8e7be07a300a19bde23d88", "filename": "gcc/calls.c", "status": "modified", "additions": 77, "deletions": 52, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce48579b9a691b3c6b57f2e6a8f5161f829a2477/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce48579b9a691b3c6b57f2e6a8f5161f829a2477/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=ce48579b9a691b3c6b57f2e6a8f5161f829a2477", "patch": "@@ -210,7 +210,7 @@ static int special_function_p\t\t\tPARAMS ((tree, int));\n static int flags_from_decl_or_type \t\tPARAMS ((tree));\n static rtx try_to_integrate\t\t\tPARAMS ((tree, tree, rtx,\n \t\t\t\t\t\t\t int, tree, rtx));\n-static void combine_pending_stack_adjustment_and_call\n+static int combine_pending_stack_adjustment_and_call\n                                                 PARAMS ((int, struct args_size *, int));\n \n #ifdef REG_PARM_STACK_SPACE\n@@ -1860,13 +1860,13 @@ try_to_integrate (fndecl, actparms, target, ignore, type, structure_value_addr)\n /* We need to pop PENDING_STACK_ADJUST bytes.  But, if the arguments\n    wouldn't fill up an even multiple of PREFERRED_UNIT_STACK_BOUNDARY\n    bytes, then we would need to push some additional bytes to pad the\n-   arguments.  So, we adjust the stack pointer by an amount that will\n-   leave the stack under-aligned by UNADJUSTED_ARGS_SIZE bytes.  Then,\n-   when the arguments are pushed the stack will be perfectly aligned.\n-   ARGS_SIZE->CONSTANT is set to the number of bytes that should be\n-   popped after the call.  */\n+   arguments.  So, we compute an adjust to the stack pointer for an\n+   amount that will leave the stack under-aligned by UNADJUSTED_ARGS_SIZE\n+   bytes.  Then, when the arguments are pushed the stack will be perfectly\n+   aligned.  ARGS_SIZE->CONSTANT is set to the number of bytes that should\n+   be popped after the call.  Returns the adjustment.  */\n \n-static void\n+static int\n combine_pending_stack_adjustment_and_call (unadjusted_args_size,\n \t\t\t\t\t   args_size,\n \t\t\t\t\t   preferred_unit_stack_boundary)\n@@ -1910,9 +1910,7 @@ combine_pending_stack_adjustment_and_call (unadjusted_args_size,\n   args_size->constant \n     = pending_stack_adjust - adjustment + unadjusted_args_size;\n \n-  /* Push the right number of bytes.  */\n-  pending_stack_adjust = adjustment;\n-  do_pending_stack_adjust ();\n+  return adjustment;\n }\n \n /* Generate all the code for a function call\n@@ -2504,19 +2502,9 @@ expand_call (exp, target, ignore)\n \t  sibcall_failure = 1;\n \t}\n \n-      /* Compute the actual size of the argument block required.  The variable\n-\t and constant sizes must be combined, the size may have to be rounded,\n-\t and there may be a minimum required size.  When generating a sibcall\n-\t pattern, do not round up, since we'll be re-using whatever space our\n-\t caller provided.  */\n-      unadjusted_args_size\n-\t= compute_argument_block_size (reg_parm_stack_space, &args_size,\n-\t\t\t\t       (pass == 0 ? 0\n-\t\t\t\t\t: preferred_stack_boundary));\n-\n       /* If the callee pops its own arguments, then it must pop exactly\n \t the same number of arguments as the current function.  */\n-      if (RETURN_POPS_ARGS (fndecl, funtype, unadjusted_args_size)\n+      if (RETURN_POPS_ARGS (fndecl, funtype, args_size.constant)\n \t  != RETURN_POPS_ARGS (current_function_decl,\n \t\t\t       TREE_TYPE (current_function_decl),\n \t\t\t       current_function_args_size))\n@@ -2548,14 +2536,25 @@ expand_call (exp, target, ignore)\n       if (flags & (ECF_CONST | ECF_PURE | ECF_MALLOC))\n \tstart_sequence ();\n \n+      /* Compute the actual size of the argument block required.  The variable\n+\t and constant sizes must be combined, the size may have to be rounded,\n+\t and there may be a minimum required size.  When generating a sibcall\n+\t pattern, do not round up, since we'll be re-using whatever space our\n+\t caller provided.  */\n+      unadjusted_args_size\n+\t= compute_argument_block_size (reg_parm_stack_space, &args_size,\n+\t\t\t\t       (pass == 0 ? 0\n+\t\t\t\t\t: preferred_stack_boundary));\n+\n       old_stack_allocated =  stack_pointer_delta - pending_stack_adjust;\n+\n       /* The argument block when performing a sibling call is the\n          incoming argument block.  */\n       if (pass == 0)\n \targblock = virtual_incoming_args_rtx;\n+\n       /* If we have no actual push instructions, or shouldn't use them,\n \t make space for all args right now.  */\n-\n       else if (args_size.var != 0)\n \t{\n \t  if (old_stack_level == 0)\n@@ -2644,20 +2643,36 @@ expand_call (exp, target, ignore)\n \t\t  if (inhibit_defer_pop == 0)\n \t\t    {\n \t\t      /* Try to reuse some or all of the pending_stack_adjust\n-\t\t\t to get this space.  Maybe we can avoid any pushing.  */\n-\t\t      if (needed > pending_stack_adjust)\n-\t\t\t{\n-\t\t\t  needed -= pending_stack_adjust;\n-\t\t\t  pending_stack_adjust = 0;\n-\t\t\t}\n-\t\t      else\n+\t\t\t to get this space.  */\n+\t\t      needed\n+\t\t\t= (combine_pending_stack_adjustment_and_call \n+\t\t\t   (unadjusted_args_size,\n+\t\t\t    &args_size,\n+\t\t\t    preferred_unit_stack_boundary));\n+\n+\t\t      /* combine_pending_stack_adjustment_and_call computes\n+\t\t\t an adjustment before the arguments are allocated.\n+\t\t\t Account for them and see whether or not the stack\n+\t\t\t needs to go up or down.  */\n+\t\t      needed = unadjusted_args_size - needed;\n+\n+\t\t      if (needed < 0)\n \t\t\t{\n-\t\t\t  pending_stack_adjust -= needed;\n+\t\t\t  /* We're releasing stack space.  */\n+\t\t\t  /* ??? We can avoid any adjustment at all if we're\n+\t\t\t     already aligned.  FIXME.  */\n+\t\t\t  pending_stack_adjust = -needed;\n+\t\t\t  do_pending_stack_adjust ();\n \t\t\t  needed = 0;\n \t\t\t}\n+\t\t      else \n+\t\t\t/* We need to allocate space.  We'll do that in\n+\t\t\t   push_block below.  */\n+\t\t\tpending_stack_adjust = 0;\n \t\t    }\n-\t\t  /* Special case this because overhead of `push_block' in this\n-\t\t     case is non-trivial.  */\n+\n+\t\t  /* Special case this because overhead of `push_block' in\n+\t\t     this case is non-trivial.  */\n \t\t  if (needed == 0)\n \t\t    argblock = virtual_outgoing_args_rtx;\n \t\t  else\n@@ -2673,35 +2688,41 @@ expand_call (exp, target, ignore)\n \t\t  argblock = copy_to_reg (argblock);\n \n \t\t  /* The save/restore code in store_one_arg handles all\n-\t\t     cases except one:\n-\t\t     a constructor call (including a C function returning\n-\t\t     a BLKmode struct) to initialize an argument.  */\n+\t\t     cases except one: a constructor call (including a C\n+\t\t     function returning a BLKmode struct) to initialize\n+\t\t     an argument.  */\n \t\t  if (stack_arg_under_construction)\n \t\t    {\n #ifndef OUTGOING_REG_PARM_STACK_SPACE\n-\t\t      rtx push_size = GEN_INT (reg_parm_stack_space + args_size.constant);\n+\t\t      rtx push_size = GEN_INT (reg_parm_stack_space\n+\t\t\t\t\t       + args_size.constant);\n #else\n \t\t      rtx push_size = GEN_INT (args_size.constant);\n #endif\n \t\t      if (old_stack_level == 0)\n \t\t\t{\n-\t\t\t  emit_stack_save (SAVE_BLOCK, &old_stack_level, NULL_RTX);\n+\t\t\t  emit_stack_save (SAVE_BLOCK, &old_stack_level,\n+\t\t\t\t\t   NULL_RTX);\n \t\t\t  old_pending_adj = pending_stack_adjust;\n \t\t\t  pending_stack_adjust = 0;\n-\t\t\t  /* stack_arg_under_construction says whether a stack arg is\n-\t\t\t     being constructed at the old stack level.  Pushing the stack\n-\t\t\t     gets a clean outgoing argument block.  */\n-\t\t\t  old_stack_arg_under_construction = stack_arg_under_construction;\n+\t\t\t  /* stack_arg_under_construction says whether a stack\n+\t\t\t     arg is being constructed at the old stack level.\n+\t\t\t     Pushing the stack gets a clean outgoing argument\n+\t\t\t     block.  */\n+\t\t\t  old_stack_arg_under_construction\n+\t\t\t    = stack_arg_under_construction;\n \t\t\t  stack_arg_under_construction = 0;\n \t\t\t  /* Make a new map for the new argument list.  */\n-\t\t\t  stack_usage_map = (char *)alloca (highest_outgoing_arg_in_use);\n+\t\t\t  stack_usage_map = (char *)\n+\t\t\t    alloca (highest_outgoing_arg_in_use);\n \t\t\t  bzero (stack_usage_map, highest_outgoing_arg_in_use);\n \t\t\t  highest_outgoing_arg_in_use = 0;\n \t\t\t}\n-\t\t      allocate_dynamic_stack_space (push_size, NULL_RTX, BITS_PER_UNIT);\n+\t\t      allocate_dynamic_stack_space (push_size, NULL_RTX,\n+\t\t\t\t\t\t    BITS_PER_UNIT);\n \t\t    }\n-\t\t  /* If argument evaluation might modify the stack pointer, copy the\n-\t\t     address of the argument list to a register.  */\n+\t\t  /* If argument evaluation might modify the stack pointer,\n+\t\t     copy the address of the argument list to a register.  */\n \t\t  for (i = 0; i < num_actuals; i++)\n \t\t    if (args[i].pass_on_stack)\n \t\t      {\n@@ -2725,10 +2746,14 @@ expand_call (exp, target, ignore)\n \t  if (pending_stack_adjust \n \t      && ! (flags & (ECF_CONST | ECF_PURE))\n \t      && ! inhibit_defer_pop)\n-\t    combine_pending_stack_adjustment_and_call \n-\t      (unadjusted_args_size,\n-\t       &args_size,\n-\t       preferred_unit_stack_boundary);\n+\t    {\n+\t      pending_stack_adjust\n+\t\t= (combine_pending_stack_adjustment_and_call \n+\t\t   (unadjusted_args_size,\n+\t\t    &args_size,\n+\t\t    preferred_unit_stack_boundary));\n+\t      do_pending_stack_adjust ();\n+\t    }\n \t  else if (argblock == 0)\n \t    anti_adjust_stack (GEN_INT (args_size.constant\n \t\t\t\t\t- unadjusted_args_size));\n@@ -2862,8 +2887,8 @@ expand_call (exp, target, ignore)\n \t now!  */\n \n #ifdef PREFERRED_STACK_BOUNDARY\n-      /* Stack must to be properly aligned now.  */\n-      if (stack_pointer_delta & (preferred_stack_boundary / BITS_PER_UNIT - 1))\n+      /* Stack must be properly aligned now.  */\n+      if (pass && stack_pointer_delta % preferred_unit_stack_boundary)\n \tabort();\n #endif\n \n@@ -3767,7 +3792,7 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n \t    ? hard_libcall_value (outmode) : NULL_RTX);\n \n #ifdef PREFERRED_STACK_BOUNDARY\n-  /* Stack must to be properly aligned now.  */\n+  /* Stack must be properly aligned now.  */\n   if (stack_pointer_delta & (PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT - 1))\n     abort();\n #endif"}, {"sha": "bc1bbf4bfddd19c2b6d15b6c169ab2b0ad592831", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce48579b9a691b3c6b57f2e6a8f5161f829a2477/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce48579b9a691b3c6b57f2e6a8f5161f829a2477/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=ce48579b9a691b3c6b57f2e6a8f5161f829a2477", "patch": "@@ -2840,7 +2840,7 @@ push_block (size, extra, below)\n     anti_adjust_stack (size);\n   else\n     {\n-      rtx temp = copy_to_mode_reg (Pmode, size);\n+      temp = copy_to_mode_reg (Pmode, size);\n       if (extra != 0)\n \ttemp = expand_binop (Pmode, add_optab, temp, GEN_INT (extra),\n \t\t\t     temp, 0, OPTAB_LIB_WIDEN);\n@@ -2857,7 +2857,6 @@ push_block (size, extra, below)\n   if (1)\n #endif\n     {\n-\n       /* Return the lowest stack address when STACK or ARGS grow downward and\n \t we are not aaccumulating outgoing arguments (the c4x port uses such\n \t conventions).  */"}]}