{"sha": "7ac28727fb6149d6e9301e501a94080cb80be27a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2FjMjg3MjdmYjYxNDlkNmU5MzAxZTUwMWE5NDA4MGNiODBiZTI3YQ==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel1@de.ibm.com", "date": "2008-05-27T11:46:45Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2008-05-27T11:46:45Z"}, "message": "reload.c: (find_reloads): Skip alternatives according to the \"enabled\" attribute.\n\n2008-05-27  Andreas Krebbel  <krebbel1@de.ibm.com>\n\n\t* reload.c: (find_reloads): Skip alternatives according to the\n\t\"enabled\" attribute. Constify the constraint variable.\n\t* recog.c (get_attr_enabled): Add default implementation.\n\t(extract_insn): Set the alternative_enabled_p array\n\tin the recog_data struct.\n\t(preprocess_constraints, constrain_operands): Skip\n\talternatives according to the \"enabled\" attribute\n\t* recog.h (struct recog_data): New field alternative_enabled_p.\n\t(skip_alternative): New inline function.\n\t* regclass.c: (record_operand_costs): Check the \"enabled\"\n\tattribute.\n\t(record_reg_classes): Skip alternative according to the\n\t\"enabled\" attribute.\n\n\t* doc/md.texi: Add documention for the \"enabled\" attribute.\n\nFrom-SVN: r136012", "tree": {"sha": "8b144af648d4119d5962a025331d5ae887135564", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b144af648d4119d5962a025331d5ae887135564"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ac28727fb6149d6e9301e501a94080cb80be27a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ac28727fb6149d6e9301e501a94080cb80be27a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ac28727fb6149d6e9301e501a94080cb80be27a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ac28727fb6149d6e9301e501a94080cb80be27a/comments", "author": null, "committer": null, "parents": [{"sha": "a4edaf835918f2dd4a2c36659b3639438a0d1a38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4edaf835918f2dd4a2c36659b3639438a0d1a38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4edaf835918f2dd4a2c36659b3639438a0d1a38"}], "stats": {"total": 223, "additions": 213, "deletions": 10}, "files": [{"sha": "6fe4bdc684d1be5c37207a8a001e45bbc6417d2b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ac28727fb6149d6e9301e501a94080cb80be27a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ac28727fb6149d6e9301e501a94080cb80be27a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7ac28727fb6149d6e9301e501a94080cb80be27a", "patch": "@@ -1,3 +1,21 @@\n+2008-05-27  Andreas Krebbel  <krebbel1@de.ibm.com>\n+\n+\t* reload.c: (find_reloads): Skip alternatives according to the\n+\t\"enabled\" attribute. Constify the constraint variable.\n+\t* recog.c (get_attr_enabled): Add default implementation.\n+\t(extract_insn): Set the alternative_enabled_p array\n+\tin the recog_data struct.\n+\t(preprocess_constraints, constrain_operands): Skip\n+\talternatives according to the \"enabled\" attribute\n+\t* recog.h (struct recog_data): New field alternative_enabled_p.\n+\t(skip_alternative): New inline function.\n+\t* regclass.c: (record_operand_costs): Check the \"enabled\"\n+\tattribute.\n+\t(record_reg_classes): Skip alternative according to the\n+\t\"enabled\" attribute.\n+\n+\t* doc/md.texi: Add documention for the \"enabled\" attribute.\n+\n 2008-05-27  Andreas Krebbel  <krebbel1@de.ibm.com>\n \n \t* defaults.h (TARGET_MEM_CONSTRAINT): New target macro added."}, {"sha": "05b1754b818b5fa57006f0bb1b49739f71d3e1f7", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ac28727fb6149d6e9301e501a94080cb80be27a/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ac28727fb6149d6e9301e501a94080cb80be27a/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=7ac28727fb6149d6e9301e501a94080cb80be27a", "patch": "@@ -1050,6 +1050,7 @@ have.  Constraints can also require two operands to match.\n * Multi-Alternative::   When an insn has two alternative constraint-patterns.\n * Class Preferences::   Constraints guide which hard register to put things in.\n * Modifiers::           More precise control over effects of constraints.\n+* Disable Insn Alternatives:: Disable insn alternatives using the @code{enabled} attribute.\n * Machine Constraints:: Existing constraints for some particular machines.\n * Define Constraints::  How to define machine-specific constraints.\n * C Constraint Interface:: How to test constraints from C code.\n@@ -3088,6 +3089,99 @@ Unsigned constant valid for BccUI instructions\n \n @end table\n \n+@ifset INTERNALS\n+@node Disable Insn Alternatives\n+@subsection Disable insn alternatives using the @code{enabled} attribute\n+@cindex enabled\n+\n+The @code{enabled} insn attribute may be used to disable certain insn\n+alternatives for machine-specific reasons.  This is useful when adding\n+new instructions to an existing pattern which are only available for\n+certain cpu architecture levels as specified with the @code{-march=}\n+option.\n+\n+If an insn alternative is disabled, then it will never be used.  The\n+compiler treats the constraints for the disabled alternative as\n+unsatisfiable.\n+\n+In order to make use of the @code{enabled} attribute a back end has to add\n+in the machine description files:\n+\n+@enumerate\n+@item\n+A definition of the @code{enabled} insn attribute.  The attribute is\n+defined as usual using the @code{define_attr} command.  This\n+definition should be based on other insn attributes and/or target flags.\n+The @code{enabled} attribute is a numeric attribute and should evaluate to\n+@code{(const_int 1)} for an enabled alternative and to\n+@code{(const_int 0)} otherwise.\n+@item\n+A definition of another insn attribute used to describe for what\n+reason an insn alternative might be available or\n+not.  E.g. @code{cpu_facility} as in the example below.\n+@item\n+An assignement for the second attribute to each insn definition\n+combining instructions which are not all available under the same\n+circumstances.  (Note: It obviously only makes sense for definitions\n+with more than one alternative.  Otherwise the insn pattern should be\n+disabled or enabled using the insn condition.)\n+@end enumerate\n+\n+E.g. the following two patterns could easily be merged using the @code{enabled}\n+attribute:\n+\n+@smallexample\n+\n+(define_insn \"*movdi_old\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+        (match_operand:DI 1 \"register_operand\" \" d\"))]\n+  \"!TARGET_NEW\"\n+  \"lgr %0,%1\")\n+\n+(define_insn \"*movdi_new\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d,f,d\")\n+        (match_operand:DI 1 \"register_operand\" \" d,d,f\"))]\n+  \"TARGET_NEW\"\n+  \"@@\n+   lgr  %0,%1\n+   ldgr %0,%1\n+   lgdr %0,%1\")\n+\n+@end smallexample\n+\n+to:\n+\n+@smallexample\n+\n+(define_insn \"*movdi_combined\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d,f,d\")\n+        (match_operand:DI 1 \"register_operand\" \" d,d,f\"))]\n+  \"\"\n+  \"@@\n+   lgr  %0,%1\n+   ldgr %0,%1\n+   lgdr %0,%1\"\n+  [(set_attr \"cpu_facility\" \"*,new,new\")])\n+\n+@end smallexample\n+\n+with the @code{enabled} attribute defined like this:\n+\n+@smallexample\n+\n+(define_attr \"cpu_facility\" \"standard,new\" (const_string \"standard\"))\n+\n+(define_attr \"enabled\" \"\"\n+  (cond [(eq_attr \"cpu_facility\" \"standard\") (const_int 1)\n+         (and (eq_attr \"cpu_facility\" \"new\")\n+              (ne (symbol_ref \"TARGET_NEW\") (const_int 0)))\n+         (const_int 1)]\n+        (const_int 0)))\n+\n+@end smallexample\n+\n+@end ifset\n+\n @ifset INTERNALS\n @node Define Constraints\n @subsection Defining Machine-Specific Constraints\n@@ -6521,6 +6615,22 @@ If the attribute takes numeric values, no @code{enum} type will be\n defined and the function to obtain the attribute's value will return\n @code{int}.\n \n+There are attributes which are tied to a specific meaning.  These\n+attributes are not free to use for other purposes:\n+\n+@table @code\n+@item length\n+The @code{length} attribute is used to calculate the length of emitted\n+code chunks.  This is especially important when verifying branch\n+distances. @xref{Insn Lengths}.\n+\n+@item enabled\n+The @code{enabled} attribute can be defined to prevent certain\n+alternatives of an insn definition from being used during code\n+generation. @xref{Disable Insn Alternatives}.\n+\n+@end table\n+\n @end ifset\n @ifset INTERNALS\n @node Expressions"}, {"sha": "ee5837dc1ec21634fb97e69cda029ba92153278c", "filename": "gcc/recog.c", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ac28727fb6149d6e9301e501a94080cb80be27a/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ac28727fb6149d6e9301e501a94080cb80be27a/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=7ac28727fb6149d6e9301e501a94080cb80be27a", "patch": "@@ -60,6 +60,14 @@ along with GCC; see the file COPYING3.  If not see\n #endif\n #endif\n \n+#ifndef HAVE_ATTR_enabled\n+static inline bool\n+get_attr_enabled (rtx insn ATTRIBUTE_UNUSED)\n+{\n+  return true;\n+}\n+#endif\n+\n static void validate_replace_rtx_1 (rtx *, rtx, rtx, rtx);\n static void validate_replace_src_1 (rtx *, void *);\n static rtx split_insn (rtx);\n@@ -1920,11 +1928,9 @@ extract_insn (rtx insn)\n   int noperands;\n   rtx body = PATTERN (insn);\n \n-  recog_data.insn = NULL;\n   recog_data.n_operands = 0;\n   recog_data.n_alternatives = 0;\n   recog_data.n_dups = 0;\n-  which_alternative = -1;\n \n   switch (GET_CODE (body))\n     {\n@@ -2004,6 +2010,22 @@ extract_insn (rtx insn)\n \t : OP_IN);\n \n   gcc_assert (recog_data.n_alternatives <= MAX_RECOG_ALTERNATIVES);\n+\n+  if (INSN_CODE (insn) < 0)\n+    for (i = 0; i < recog_data.n_alternatives; i++)\n+      recog_data.alternative_enabled_p[i] = true;\n+  else\n+    {\n+      recog_data.insn = insn;\n+      for (i = 0; i < recog_data.n_alternatives; i++)\n+\t{\n+\t  which_alternative = i;\n+\t  recog_data.alternative_enabled_p[i] = get_attr_enabled (insn);\n+\t}\n+    }\n+\n+  recog_data.insn = NULL;\n+  which_alternative = -1;\n }\n \n /* After calling extract_insn, you can use this function to extract some\n@@ -2033,6 +2055,12 @@ preprocess_constraints (void)\n \t  op_alt[j].matches = -1;\n \t  op_alt[j].matched = -1;\n \n+\t  if (!recog_data.alternative_enabled_p[j])\n+\t    {\n+\t      p = skip_alternative (p);\n+\t      continue;\n+\t    }\n+\n \t  if (*p == '\\0' || *p == ',')\n \t    {\n \t      op_alt[j].anything_ok = 1;\n@@ -2202,6 +2230,17 @@ constrain_operands (int strict)\n       int lose = 0;\n       funny_match_index = 0;\n \n+      if (!recog_data.alternative_enabled_p[which_alternative])\n+\t{\n+\t  int i;\n+\n+\t  for (i = 0; i < recog_data.n_operands; i++)\n+\t    constraints[i] = skip_alternative (constraints[i]);\n+\n+\t  which_alternative++;\n+\t  continue;\n+\t}\n+\n       for (opno = 0; opno < recog_data.n_operands; opno++)\n \t{\n \t  rtx op = recog_data.operand[opno];"}, {"sha": "6a2a2caf1da78c4d5e786878462ca84bb9d3c958", "filename": "gcc/recog.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ac28727fb6149d6e9301e501a94080cb80be27a/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ac28727fb6149d6e9301e501a94080cb80be27a/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=7ac28727fb6149d6e9301e501a94080cb80be27a", "patch": "@@ -143,6 +143,19 @@ recog_memoized (rtx insn)\n }\n #endif\n \n+/* Skip chars until the next ',' or the end of the string.  This is\n+   useful to skip alternatives in a constraint string.  */\n+static inline const char *\n+skip_alternative (const char *p)\n+{\n+  const char *r = p;\n+  while (*r != '\\0' && *r != ',')\n+    r++;\n+  if (*r == ',')\n+    r++;\n+  return r;\n+}\n+\n /* Nonzero means volatile operands are recognized.  */\n extern int volatile_ok;\n \n@@ -202,6 +215,12 @@ struct recog_data\n   /* The number of alternatives in the constraints for the insn.  */\n   char n_alternatives;\n \n+  /* Specifies whether an insn alternative is enabled using the\n+     `enabled' attribute in the insn pattern definition.  For back\n+     ends not using the `enabled' attribute the array fields are\n+     always set to `true' in expand_insn.  */\n+  bool alternative_enabled_p [MAX_RECOG_ALTERNATIVES];\n+\n   /* In case we are caching, hold insn data was generated for.  */\n   rtx insn;\n };"}, {"sha": "8b9e86b1411d5ca39a322fa8cfd84d83a002c5f9", "filename": "gcc/regclass.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ac28727fb6149d6e9301e501a94080cb80be27a/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ac28727fb6149d6e9301e501a94080cb80be27a/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=7ac28727fb6149d6e9301e501a94080cb80be27a", "patch": "@@ -1143,8 +1143,9 @@ record_operand_costs (rtx insn, struct costs *op_costs,\n \trecord_address_regs (GET_MODE (recog_data.operand[i]),\n \t\t\t     XEXP (recog_data.operand[i], 0),\n \t\t\t     0, MEM, SCRATCH, frequency * 2);\n-      else if (constraints[i][0] == 'p'\n-\t       || EXTRA_ADDRESS_CONSTRAINT (constraints[i][0], constraints[i]))\n+      else if (recog_data.alternative_enabled_p[0]\n+\t       && (constraints[i][0] == 'p'\n+\t\t   || EXTRA_ADDRESS_CONSTRAINT (constraints[i][0], constraints[i])))\n \trecord_address_regs (VOIDmode, recog_data.operand[i], 0, ADDRESS,\n \t\t\t     SCRATCH, frequency * 2);\n     }\n@@ -1932,6 +1933,9 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n       if (alt_fail)\n \tcontinue;\n \n+      if (!recog_data.alternative_enabled_p[alt])\n+\tcontinue;\n+\n       /* Finally, update the costs with the information we've calculated\n \t about this alternative.  */\n "}, {"sha": "7472272d9c4a1eca945de06504ab0c2913ceaac8", "filename": "gcc/reload.c", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ac28727fb6149d6e9301e501a94080cb80be27a/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ac28727fb6149d6e9301e501a94080cb80be27a/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=7ac28727fb6149d6e9301e501a94080cb80be27a", "patch": "@@ -2523,7 +2523,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n   int noperands;\n   /* These start out as the constraints for the insn\n      and they are chewed up as we consider alternatives.  */\n-  char *constraints[MAX_RECOG_OPERANDS];\n+  const char *constraints[MAX_RECOG_OPERANDS];\n   /* These are the preferred classes for an operand, or NO_REGS if it isn't\n      a register.  */\n   enum reg_class preferred_class[MAX_RECOG_OPERANDS];\n@@ -2630,7 +2630,8 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \n   memcpy (operand_mode, recog_data.operand_mode,\n \t  noperands * sizeof (enum machine_mode));\n-  memcpy (constraints, recog_data.constraints, noperands * sizeof (char *));\n+  memcpy (constraints, recog_data.constraints,\n+\t  noperands * sizeof (const char *));\n \n   commutative = -1;\n \n@@ -2641,8 +2642,9 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \n   for (i = 0; i < noperands; i++)\n     {\n-      char *p;\n+      const char *p;\n       int c;\n+      char *end;\n \n       substed_operand[i] = recog_data.operand[i];\n       p = constraints[i];\n@@ -2686,7 +2688,8 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t    case '0': case '1': case '2': case '3': case '4':\n \t    case '5': case '6': case '7': case '8': case '9':\n \t      {\n-\t\tc = strtoul (p - 1, &p, 10);\n+\t\tc = strtoul (p - 1, &end, 10);\n+\t\tp = end;\n \n \t\toperands_match[c][i]\n \t\t  = operands_match_p (recog_data.operand[c],\n@@ -2914,11 +2917,21 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t a bad register class to only count 1/3 as much.  */\n       int reject = 0;\n \n+      if (!recog_data.alternative_enabled_p[this_alternative_number])\n+\t{\n+\t  int i;\n+\n+\t  for (i = 0; i < recog_data.n_operands; i++)\n+\t    constraints[i] = skip_alternative (constraints[i]);\n+\n+\t  continue;\n+\t}\n+\n       this_earlyclobber = 0;\n \n       for (i = 0; i < noperands; i++)\n \t{\n-\t  char *p = constraints[i];\n+\t  const char *p = constraints[i];\n \t  char *end;\n \t  int len;\n \t  int win = 0;\n@@ -3717,7 +3730,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t  address_reloaded[commutative + 1] = t;\n \n \t  memcpy (constraints, recog_data.constraints,\n-\t\t  noperands * sizeof (char *));\n+\t\t  noperands * sizeof (const char *));\n \t  goto try_swapped;\n \t}\n       else"}]}