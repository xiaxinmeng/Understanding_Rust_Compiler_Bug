{"sha": "18d13f34175f157bc3152afdf48da798452afc1b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MThkMTNmMzQxNzVmMTU3YmMzMTUyYWZkZjQ4ZGE3OTg0NTJhZmMxYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2003-03-08T13:26:37Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2003-03-08T13:26:37Z"}, "message": "inline-3.c: New test.\n\n\n\t* gcc.dg/inline-3.c: New test.\n\n\t* c-decl.c: (finish_function): Update call of tree_inlinable_function_p.\n\t* cgraph.h: (cgraph_local_info): Add can_inline_once\n\t(cgraph_global_info): Add inline_once.\n\t(cgraph_node): Add previous.\n\t(cgraph_remove_node): New.\n\t* cgraphunit.c (cgraph_mark_functions_to_inline_once): New static\n\tfunction.\n\t(cgraph_optimize): Call it.\n\t(cgraph_finalize_function):  Set inlinable flags.\n\t(cgraph_finalize_compilation_unit):  Actually remove the reclaimed nodes.\n\t(cgraph_mark_functions_to_output):  Use new inlining heuristics flags.\n\t(cgraph_expand_function): Likewise.\n\t* cgraph.c\n\t(cgraph_node): Put nodes into doubly linked chain.\n\t(cgraph_remove_node): New function.\n\t* flags.h (flag_inline_functions_called_once): Declare.\n\t* tree-inline.c: Include cgraph.h\n\t(inlinable_functions_p): Add extra argument to bypass limits.\n\t(expand_call_inline):  Obey cgraph flag.\n\t* tree-inline.h (tree_inlinable_function_p): Update prototype.\n\nFrom-SVN: r63983", "tree": {"sha": "8a4f34953d22192851b98b6fb46d7a44532ecfc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a4f34953d22192851b98b6fb46d7a44532ecfc0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18d13f34175f157bc3152afdf48da798452afc1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18d13f34175f157bc3152afdf48da798452afc1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18d13f34175f157bc3152afdf48da798452afc1b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18d13f34175f157bc3152afdf48da798452afc1b/comments", "author": null, "committer": null, "parents": [{"sha": "4a07c08a47f2a4fbce5634b93834ed824ebafc79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a07c08a47f2a4fbce5634b93834ed824ebafc79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a07c08a47f2a4fbce5634b93834ed824ebafc79"}], "stats": {"total": 268, "additions": 246, "deletions": 22}, "files": [{"sha": "383f9e62bd4ba3625491c0520ca8c4244e361efc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18d13f34175f157bc3152afdf48da798452afc1b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18d13f34175f157bc3152afdf48da798452afc1b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=18d13f34175f157bc3152afdf48da798452afc1b", "patch": "@@ -1,3 +1,26 @@\n+Sat Mar  8 14:13:35 CET 2003  Jan Hubicka  <jh@suse.cz>\n+\n+\t* c-decl.c: (finish_function): Update call of tree_inlinable_function_p.\n+\t* cgraph.h: (cgraph_local_info): Add can_inline_once\n+\t(cgraph_global_info): Add inline_once.\n+\t(cgraph_node): Add previous.\n+\t(cgraph_remove_node): New.\n+\t* cgraphunit.c (cgraph_mark_functions_to_inline_once): New static\n+\tfunction.\n+\t(cgraph_optimize): Call it.\n+\t(cgraph_finalize_function):  Set inlinable flags.\n+\t(cgraph_finalize_compilation_unit):  Actually remove the reclaimed nodes.\n+\t(cgraph_mark_functions_to_output):  Use new inlining heuristics flags.\n+\t(cgraph_expand_function): Likewise.\n+\t* cgraph.c \n+\t(cgraph_node): Put nodes into doubly linked chain.\n+\t(cgraph_remove_node): New function.\n+\t* flags.h (flag_inline_functions_called_once): Declare.\n+\t* tree-inline.c: Include cgraph.h\n+\t(inlinable_functions_p): Add extra argument to bypass limits.\n+\t(expand_call_inline):  Obey cgraph flag.\n+\t* tree-inline.h (tree_inlinable_function_p): Update prototype.\n+\n 2003-03-08  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n \n \t* gcse.c (bypass_block, bypass_conditional_jumps): Do not create"}, {"sha": "f7996f1a8126bff746ba3c16d5a82b2041abbf81", "filename": "gcc/c-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18d13f34175f157bc3152afdf48da798452afc1b/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18d13f34175f157bc3152afdf48da798452afc1b/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=18d13f34175f157bc3152afdf48da798452afc1b", "patch": "@@ -6444,7 +6444,7 @@ finish_function (nested, can_defer_p)\n \t     predicates depend on cfun and current_function_decl to\n \t     function completely.  */\n \t  timevar_push (TV_INTEGRATION);\n-\t  uninlinable = ! tree_inlinable_function_p (fndecl);\n+\t  uninlinable = ! tree_inlinable_function_p (fndecl, 0);\n \t  \n \t  if (! uninlinable && can_defer_p\n \t      /* Save function tree for inlining.  Should return 0 if the"}, {"sha": "bb035b2ea74aeff1d10c29425d2e391625a3ac76", "filename": "gcc/cgraph.c", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18d13f34175f157bc3152afdf48da798452afc1b/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18d13f34175f157bc3152afdf48da798452afc1b/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=18d13f34175f157bc3152afdf48da798452afc1b", "patch": "@@ -48,7 +48,7 @@ bool cgraph_global_info_ready = false;\n \n static struct cgraph_edge *create_edge PARAMS ((struct cgraph_node *,\n \t\t\t\t\t\tstruct cgraph_node *));\n-static void remove_edge PARAMS ((struct cgraph_node *, struct cgraph_node *));\n+static void cgraph_remove_edge PARAMS ((struct cgraph_node *, struct cgraph_node *));\n static hashval_t hash_node PARAMS ((const PTR));\n static int eq_node PARAMS ((const PTR, const PTR));\n \n@@ -95,6 +95,9 @@ cgraph_node (decl)\n   node = xcalloc (sizeof (*node), 1);\n   node->decl = decl;\n   node->next = cgraph_nodes;\n+  if (cgraph_nodes)\n+    cgraph_nodes->previous = node;\n+  node->previous = NULL;\n   cgraph_nodes = node;\n   cgraph_n_nodes++;\n   *slot = node;\n@@ -127,7 +130,7 @@ create_edge (caller, callee)\n /* Remove the edge from CALLER to CALLEE in the cgraph.  */\n \n static void\n-remove_edge (caller, callee)\n+cgraph_remove_edge (caller, callee)\n      struct cgraph_node *caller, *callee;\n {\n   struct cgraph_edge **edge, **edge2;\n@@ -146,6 +149,37 @@ remove_edge (caller, callee)\n   *edge2 = (*edge2)->next_callee;\n }\n \n+/* Remove the node from cgraph.  */\n+\n+void\n+cgraph_remove_node (node)\n+     struct cgraph_node *node;\n+{\n+  while (node->callers)\n+    cgraph_remove_edge (node->callers->caller, node);\n+  while (node->callees)\n+    cgraph_remove_edge (node, node->callees->callee);\n+  while (node->nested)\n+    cgraph_remove_node (node->nested);\n+  if (node->origin)\n+    {\n+      struct cgraph_node **node2 = &node->origin->nested;\n+\n+      while (*node2 != node)\n+\tnode2 = &(*node2)->next_nested;\n+      *node2 = node->next_nested;\n+    }\n+  if (node->previous)\n+    node->previous->next = node->next;\n+  else\n+    cgraph_nodes = node;\n+  if (node->next)\n+    node->next->previous = node->previous;\n+  DECL_SAVED_TREE (node->decl) = NULL;\n+  /* Do not free the structure itself so the walk over chain can continue.  */\n+}\n+\n+\n /* Record call from CALLER to CALLEE  */\n \n struct cgraph_edge *\n@@ -159,7 +193,7 @@ void\n cgraph_remove_call (caller, callee)\n      tree caller, callee;\n {\n-  remove_edge (cgraph_node (caller), cgraph_node (callee));\n+  cgraph_remove_edge (cgraph_node (caller), cgraph_node (callee));\n }\n \n /* Return true when CALLER_DECL calls CALLEE_DECL.  */"}, {"sha": "b785e172665dd2ffbfa44d5375298ddf2c9aebf4", "filename": "gcc/cgraph.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18d13f34175f157bc3152afdf48da798452afc1b/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18d13f34175f157bc3152afdf48da798452afc1b/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=18d13f34175f157bc3152afdf48da798452afc1b", "patch": "@@ -30,16 +30,20 @@ struct cgraph_local_info\n   /* Set when function function is visiable in current compilation unit only\n      and it's address is never taken.  */\n   bool local;\n+  /* Set when function is small enought to be inlinable many times.  */\n   bool inline_many;\n+  /* Set when function can be inlined once (false only for functions calling\n+     alloca, using varargs and so on).  */\n+  bool can_inline_once;\n };\n \n /* Information about the function that needs to be computed globally\n    once compilation is finished.  Available only with -funit-at-time.  */\n \n struct cgraph_global_info\n {\n-  /* Empty for the moment.  */\n-  int dummy;\n+  /* Set when the function will be inlined exactly once.  */\n+  bool inline_once;\n };\n \n /* Information about the function that is propagated by the RTL backend.\n@@ -60,7 +64,7 @@ struct cgraph_node\n   tree decl;\n   struct cgraph_edge *callees;\n   struct cgraph_edge *callers;\n-  struct cgraph_node *next;\n+  struct cgraph_node *next, *previous;\n   /* For nested functions points to function the node is nested in.  */\n   struct cgraph_node *origin;\n   /* Points to first nested function, if any.  */\n@@ -100,6 +104,7 @@ extern bool cgraph_global_info_ready;\n /* In cgraph.c  */\n void dump_cgraph\t\t\tPARAMS ((FILE *));\n void cgraph_remove_call\t\t\tPARAMS ((tree, tree));\n+void cgraph_remove_node\t\t\tPARAMS ((struct cgraph_node *));\n struct cgraph_edge *cgraph_record_call\tPARAMS ((tree, tree));\n struct cgraph_node *cgraph_node\t\tPARAMS ((tree decl));\n bool cgraph_calls_p\t\t\tPARAMS ((tree, tree));"}, {"sha": "c01bba6b815e8d822bd46023f4387d8ba056ebb3", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 71, "deletions": 6, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18d13f34175f157bc3152afdf48da798452afc1b/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18d13f34175f157bc3152afdf48da798452afc1b/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=18d13f34175f157bc3152afdf48da798452afc1b", "patch": "@@ -40,6 +40,8 @@ static void cgraph_mark_functions_to_output PARAMS ((void));\n static void cgraph_expand_function PARAMS ((struct cgraph_node *));\n static tree record_call_1 PARAMS ((tree *, int *, void *));\n static void cgraph_mark_local_functions PARAMS ((void));\n+static void cgraph_mark_functions_to_inline_once PARAMS ((void));\n+static void cgraph_optimize_function PARAMS ((struct cgraph_node *));\n \n /* Analyze function once it is parsed.  Set up the local information\n    available - create cgraph edges for function calles via BODY.  */\n@@ -53,8 +55,9 @@ cgraph_finalize_function (decl, body)\n \n   node->decl = decl;\n \n+  node->local.can_inline_once = tree_inlinable_function_p (decl, 1);\n   if (flag_inline_trees)\n-    node->local.inline_many = tree_inlinable_function_p (decl);\n+    node->local.inline_many = tree_inlinable_function_p (decl, 0);\n   else\n     node->local.inline_many = 0;\n \n@@ -200,7 +203,7 @@ cgraph_finalize_compilation_unit ()\n \n       if (!node->reachable && DECL_SAVED_TREE (decl))\n \t{\n-\t  DECL_SAVED_TREE (decl) = NULL;\n+\t  cgraph_remove_node (node);\n \t  announce_function (decl);\n \t}\n     }\n@@ -221,14 +224,31 @@ cgraph_mark_functions_to_output ()\n \n       if (DECL_SAVED_TREE (decl)\n \t  && (node->needed\n-\t      || (!node->local.inline_many && node->reachable)\n+\t      || (!node->local.inline_many && !node->global.inline_once\n+\t\t  && node->reachable)\n \t      || TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)))\n \t  && !TREE_ASM_WRITTEN (decl) && !node->origin\n \t  && !DECL_EXTERNAL (decl))\n \tnode->output = 1;\n     }\n }\n \n+/* Optimize the function before expansion.  */\n+static void\n+cgraph_optimize_function (node)\n+     struct cgraph_node *node;\n+{\n+  tree decl = node->decl;\n+\n+  if (flag_inline_trees)\n+    optimize_inline_calls (decl);\n+  if (node->nested)\n+    {\n+      for (node = node->nested; node; node = node->next_nested)\n+\tcgraph_optimize_function (node);\n+    }\n+}\n+\n /* Expand function specified by NODE.  */\n static void\n cgraph_expand_function (node)\n@@ -237,12 +257,18 @@ cgraph_expand_function (node)\n   tree decl = node->decl;\n \n   announce_function (decl);\n-  if (flag_inline_trees)\n-    optimize_inline_calls (decl);\n+\n+  cgraph_optimize_function (node);\n \n   /* Avoid RTL inlining from taking place.  */\n   (*lang_hooks.callgraph.expand_function) (decl);\n-  if (DECL_UNINLINABLE (decl))\n+\n+  /* When we decided to inline the function once, we never ever should need to\n+     output it separately.  */\n+  if (node->global.inline_once)\n+    abort ();\n+  if (!node->local.inline_many\n+      || !node->callers)\n     DECL_SAVED_TREE (decl) = NULL;\n   current_function_decl = NULL;\n }\n@@ -354,6 +380,43 @@ cgraph_mark_local_functions ()\n     }\n }\n \n+/*  Decide what function should be inlined because they are invoked once\n+    (so inlining won't result in duplication of the code).  */\n+\n+static void\n+cgraph_mark_functions_to_inline_once ()\n+{\n+  struct cgraph_node *node, *node1;\n+\n+  if (!quiet_flag)\n+    fprintf (stderr, \"\\n\\nMarking functions to inline once:\");\n+\n+  /* Now look for function called only once and mark them to inline.  From this\n+     point number of calls to given function won't grow.  */\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      if (node->callers && !node->callers->next_caller && !node->needed\n+\t  && node->local.can_inline_once)\n+\t{\n+\t  bool ok = true;\n+\n+\t  /* Verify that we won't duplicate the caller.  */\n+\t  for (node1 = node->callers->caller;\n+\t       node1->local.inline_many\n+\t       && node1->callers\n+\t       && ok;\n+\t       node1 = node1->callers->caller)\n+\t    if (node1->callers->next_caller || node1->needed)\n+\t      ok = false;\n+\t  if (ok)\n+\t    {\n+\t      node->global.inline_once = true;\n+\t      announce_function (node->decl);\n+\t    }\n+\t}\n+    }\n+}\n+\n \n /* Perform simple optimizations based on callgraph.  */\n \n@@ -365,6 +428,8 @@ cgraph_optimize ()\n \n   cgraph_mark_local_functions ();\n \n+  cgraph_mark_functions_to_inline_once ();\n+\n   cgraph_global_info_ready = true;\n   if (!quiet_flag)\n     fprintf (stderr, \"\\n\\nAssembling functions:\");"}, {"sha": "3152299f7340dc2c5fc7fe575762c1feacd42568", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18d13f34175f157bc3152afdf48da798452afc1b/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18d13f34175f157bc3152afdf48da798452afc1b/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=18d13f34175f157bc3152afdf48da798452afc1b", "patch": "@@ -4519,6 +4519,16 @@\n   [(set_attr \"type\" \"sseicvt\")\n    (set_attr \"athlon_decode\" \"double,vector\")])\n \n+;; Avoid vector decoded form of the instruction.\n+(define_peephole2\n+  [(match_scratch:SF 2 \"x\")\n+   (set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(fix:DI (match_operand:SF 1 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_K8 && !optimize_size\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (set (match_dup 0) (fix:DI (match_dup 2)))]\n+  \"\")\n+\n (define_insn \"fix_truncdfdi_sse\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n \t(fix:DI (match_operand:DF 1 \"nonimmediate_operand\" \"Y,Ym\")))]\n@@ -4527,6 +4537,16 @@\n   [(set_attr \"type\" \"sseicvt,sseicvt\")\n    (set_attr \"athlon_decode\" \"double,vector\")])\n \n+;; Avoid vector decoded form of the instruction.\n+(define_peephole2\n+  [(match_scratch:DF 2 \"Y\")\n+   (set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(fix:DI (match_operand:DF 1 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_K8 && !optimize_size\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (set (match_dup 0) (fix:DI (match_dup 2)))]\n+  \"\")\n+\n ;; Signed conversion to SImode.\n \n (define_expand \"fix_truncxfsi2\"\n@@ -4630,6 +4650,16 @@\n   [(set_attr \"type\" \"sseicvt\")\n    (set_attr \"athlon_decode\" \"double,vector\")])\n \n+;; Avoid vector decoded form of the instruction.\n+(define_peephole2\n+  [(match_scratch:SF 2 \"x\")\n+   (set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(fix:SI (match_operand:SF 1 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_K8 && !optimize_size\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (set (match_dup 0) (fix:SI (match_dup 2)))]\n+  \"\")\n+\n (define_insn \"fix_truncdfsi_sse\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(fix:SI (match_operand:DF 1 \"nonimmediate_operand\" \"Y,Ym\")))]\n@@ -4638,6 +4668,16 @@\n   [(set_attr \"type\" \"sseicvt\")\n    (set_attr \"athlon_decode\" \"double,vector\")])\n \n+;; Avoid vector decoded form of the instruction.\n+(define_peephole2\n+  [(match_scratch:DF 2 \"Y\")\n+   (set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(fix:SI (match_operand:DF 1 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_K8 && !optimize_size\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (set (match_dup 0) (fix:SI (match_dup 2)))]\n+  \"\")\n+\n (define_split \n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(fix:SI (match_operand 1 \"register_operand\" \"\")))"}, {"sha": "d44271e05024650a7f8bd7e6805090487e42a0ff", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18d13f34175f157bc3152afdf48da798452afc1b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18d13f34175f157bc3152afdf48da798452afc1b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=18d13f34175f157bc3152afdf48da798452afc1b", "patch": "@@ -1,3 +1,7 @@\n+Sat Mar  8 14:18:15 CET 2003  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/inline-3.c: New test.\n+\n 2003-03-08  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/9809\n@@ -22,6 +26,7 @@\n Fri Mar  7 17:41:07 CET 2003  Jan Hubicka  <jh@suse.cz>\n \n \t* gcc.dg/i386-local2.c: Fix problems with certain versions of dejagnu.\n+\t* gcc.dg/inline-3.c:  New test.\n \n 2003-03-06  Mark Mitchell  <mark@codesourcery.com>\n "}, {"sha": "a3de193063d03876c4827477f536dffe304a03b7", "filename": "gcc/testsuite/gcc.dg/inline-3.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18d13f34175f157bc3152afdf48da798452afc1b/gcc%2Ftestsuite%2Fgcc.dg%2Finline-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18d13f34175f157bc3152afdf48da798452afc1b/gcc%2Ftestsuite%2Fgcc.dg%2Finline-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Finline-3.c?ref=18d13f34175f157bc3152afdf48da798452afc1b", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-options \"-O2 -funit-at-a-time\" } */\n+/* { dg-final { scan-assembler-not \"big_function_2\" } } */\n+static void\n+big_function_2(void);\n+void\n+big_function_1()\n+{\n+\twhile (t());\n+\twhile (t());\n+\twhile (t());\n+\twhile (t());\n+\twhile (t());\n+\twhile (t());\n+\twhile (t());\n+\twhile (t());\n+\twhile (t());\n+\twhile (t());\n+\twhile (t());\n+\twhile (t());\n+\twhile (t());\n+\twhile (t());\n+\twhile (t());\n+\twhile (t());\n+\twhile (t());\n+\tbig_function_2();\n+}\n+static void\n+big_function_2()\n+{\n+\twhile (t());\n+\twhile (t());\n+\twhile (t());\n+\twhile (t());\n+\twhile (t());\n+\twhile (t());\n+\twhile (t());\n+\twhile (t());\n+\twhile (t());\n+\twhile (t());\n+\twhile (t());\n+\twhile (t());\n+\twhile (t());\n+\twhile (t());\n+\twhile (t());\n+\twhile (t());\n+\twhile (t());\n+}"}, {"sha": "a49dca92d9019b5611bdf487460ab40b50ec9853", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18d13f34175f157bc3152afdf48da798452afc1b/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18d13f34175f157bc3152afdf48da798452afc1b/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=18d13f34175f157bc3152afdf48da798452afc1b", "patch": "@@ -115,7 +115,7 @@ static tree copy_body_r PARAMS ((tree *, int *, void *));\n static tree copy_body PARAMS ((inline_data *));\n static tree expand_call_inline PARAMS ((tree *, int *, void *));\n static void expand_calls_inline PARAMS ((tree *, inline_data *));\n-static int inlinable_function_p PARAMS ((tree, inline_data *));\n+static int inlinable_function_p PARAMS ((tree, inline_data *, int));\n static tree remap_decl PARAMS ((tree, inline_data *));\n #ifndef INLINER_FOR_JAVA\n static tree initialize_inlined_parameters PARAMS ((inline_data *, tree, tree));\n@@ -872,10 +872,11 @@ declare_return_variable (id, return_slot_addr, var)\n /* Returns nonzero if a function can be inlined as a tree.  */\n \n int\n-tree_inlinable_function_p (fn)\n+tree_inlinable_function_p (fn, nolimit)\n      tree fn;\n+     int nolimit;\n {\n-  return inlinable_function_p (fn, NULL);\n+  return inlinable_function_p (fn, NULL, nolimit);\n }\n \n /* If *TP is possibly call to alloca, return nonzero.  */\n@@ -939,9 +940,10 @@ find_builtin_longjmp_call (exp)\n    can be inlined at all.  */\n \n static int\n-inlinable_function_p (fn, id)\n+inlinable_function_p (fn, id, nolimit)\n      tree fn;\n      inline_data *id;\n+     int nolimit;\n {\n   int inlinable;\n   int currfn_insns;\n@@ -973,12 +975,13 @@ inlinable_function_p (fn, id)\n      front-end that must set DECL_INLINE in this case, because\n      dwarf2out loses if a function is inlined that doesn't have\n      DECL_INLINE set.  */\n-  else if (! DECL_INLINE (fn))\n+  else if (! DECL_INLINE (fn) && !nolimit)\n     ;\n   /* We can't inline functions that are too big.  Only allow a single\n      function to be of MAX_INLINE_INSNS_SINGLE size.  Make special\n      allowance for extern inline functions, though.  */\n-  else if (! (*lang_hooks.tree_inlining.disregard_inline_limits) (fn)\n+  else if (!nolimit\n+\t   && ! (*lang_hooks.tree_inlining.disregard_inline_limits) (fn)\n \t   && currfn_insns > max_inline_insns_single)\n     ;\n   /* We can't inline functions that call __builtin_longjmp at all.\n@@ -1009,7 +1012,7 @@ inlinable_function_p (fn, id)\n   /* In case we don't disregard the inlining limits and we basically\n      can inline this function, investigate further.  */\n   if (! (*lang_hooks.tree_inlining.disregard_inline_limits) (fn)\n-      && inlinable)\n+      && inlinable && !nolimit)\n     {\n       int sum_insns = (id ? id->inlined_stmts : 0) * INSNS_PER_STMT\n \t\t     + currfn_insns;\n@@ -1158,7 +1161,9 @@ expand_call_inline (tp, walk_subtrees, data)\n \n   /* Don't try to inline functions that are not well-suited to\n      inlining.  */\n-  if (!inlinable_function_p (fn, id))\n+  if ((!flag_unit_at_a_time || !DECL_SAVED_TREE (fn)\n+       || !cgraph_global_info (fn)->inline_once)\n+      && !inlinable_function_p (fn, id, 0))\n     return NULL_TREE;\n \n   if (! (*lang_hooks.tree_inlining.start_inlining) (fn))"}, {"sha": "0b9fc891259d616640dea79d92bb7da8134a6ad3", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18d13f34175f157bc3152afdf48da798452afc1b/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18d13f34175f157bc3152afdf48da798452afc1b/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=18d13f34175f157bc3152afdf48da798452afc1b", "patch": "@@ -25,7 +25,7 @@ Boston, MA 02111-1307, USA.  */\n /* Function prototypes.  */\n \n void optimize_inline_calls PARAMS ((tree));\n-int tree_inlinable_function_p PARAMS ((tree));\n+int tree_inlinable_function_p PARAMS ((tree, int));\n tree walk_tree PARAMS ((tree*, walk_tree_fn, void*, void*));\n tree walk_tree_without_duplicates PARAMS ((tree*, walk_tree_fn, void*));\n tree copy_tree_r PARAMS ((tree*, int*, void*));"}]}