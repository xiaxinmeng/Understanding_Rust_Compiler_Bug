{"sha": "14df5747394ff436ba13ebd39c2742c40fc45eb8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTRkZjU3NDczOTRmZjQzNmJhMTNlYmQzOWMyNzQyYzQwZmM0NWViOA==", "commit": {"author": {"name": "Scott Robert Ladd", "email": "srladd@gcc.gnu.org", "date": "2004-10-28T21:43:46Z"}, "committer": {"name": "Scott Robert Ladd", "email": "srladd@gcc.gnu.org", "date": "2004-10-28T21:43:46Z"}, "message": "Added pedantic_min_int to gfc_integer_info Added ARITH_ASYMMETRIC to arith...\n\nAdded pedantic_min_int to gfc_integer_info\nAdded ARITH_ASYMMETRIC to arith\nAdded support for an \"asymmetric integer\" warning when compiling with pedantic\nSet minimum integer values to reflect realities of two's complement signed integers\n\nFrom-SVN: r89785", "tree": {"sha": "03674e8f5f8dfc9bf3b4ffe08883f12acc36f847", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03674e8f5f8dfc9bf3b4ffe08883f12acc36f847"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14df5747394ff436ba13ebd39c2742c40fc45eb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14df5747394ff436ba13ebd39c2742c40fc45eb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14df5747394ff436ba13ebd39c2742c40fc45eb8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14df5747394ff436ba13ebd39c2742c40fc45eb8/comments", "author": null, "committer": null, "parents": [{"sha": "7ec02c04f7b98ebdeec75e8e428e3b0e14fe2e32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ec02c04f7b98ebdeec75e8e428e3b0e14fe2e32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ec02c04f7b98ebdeec75e8e428e3b0e14fe2e32"}], "stats": {"total": 85, "additions": 74, "deletions": 11}, "files": [{"sha": "cc6f3ebd1e12ba190ee025fb6574bcf7cbe3dbe0", "filename": "gcc/fortran/arith.c", "status": "modified", "additions": 72, "deletions": 9, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14df5747394ff436ba13ebd39c2742c40fc45eb8/gcc%2Ffortran%2Farith.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14df5747394ff436ba13ebd39c2742c40fc45eb8/gcc%2Ffortran%2Farith.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.c?ref=14df5747394ff436ba13ebd39c2742c40fc45eb8", "patch": "@@ -27,6 +27,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n #include \"config.h\"\n #include \"system.h\"\n+#include \"flags.h\"\n #include \"gfortran.h\"\n #include \"arith.h\"\n \n@@ -157,6 +158,9 @@ gfc_arith_error (arith code)\n     case ARITH_INCOMMENSURATE:\n       p = \"Array operands are incommensurate\";\n       break;\n+    case ARITH_ASYMMETRIC:\n+      p = \"Integer outside symmetric range implied by Standard Fortran\";\n+      break;\n     default:\n       gfc_internal_error (\"gfc_arith_error(): Bad error code\");\n     }\n@@ -194,11 +198,20 @@ gfc_arith_init_1 (void)\n       /* These are the numbers that are actually representable by the\n          target.  For bases other than two, this needs to be changed.  */\n       if (int_info->radix != 2)\n-\tgfc_internal_error (\"Fix min_int, max_int calculation\");\n+        gfc_internal_error (\"Fix min_int, max_int calculation\");\n+\n+      /* See PRs 13490 and 17912, related to integer ranges.\n+         The pedantic_min_int exists for range checking when a program\n+         is compiled with -pedantic, and reflects the belief that\n+         Standard Fortran requires integers to be symmetrical, i.e.\n+         every negative integer must have a representable positive\n+         absolute value, and vice versa. */\n+         \n+      mpz_init (int_info->pedantic_min_int);\n+      mpz_neg (int_info->pedantic_min_int, int_info->huge);\n \n       mpz_init (int_info->min_int);\n-      mpz_neg (int_info->min_int, int_info->huge);\n-      /* No -1 here, because the representation is symmetric.  */\n+      mpz_sub_ui(int_info->min_int, int_info->pedantic_min_int, 1);\n \n       mpz_init (int_info->max_int);\n       mpz_add (int_info->max_int, int_info->huge, int_info->huge);\n@@ -317,7 +330,8 @@ gfc_arith_done_1 (void)\n \n \n /* Given an integer and a kind, make sure that the integer lies within\n-   the range of the kind.  Returns ARITH_OK or ARITH_OVERFLOW.  */\n+   the range of the kind.  Returns ARITH_OK, ARITH_ASYMMETRIC or \n+   ARITH_OVERFLOW.  */\n \n static arith\n gfc_check_integer_range (mpz_t p, int kind)\n@@ -328,6 +342,12 @@ gfc_check_integer_range (mpz_t p, int kind)\n   i = gfc_validate_kind (BT_INTEGER, kind, false);\n   result = ARITH_OK;\n \n+  if (pedantic)\n+    {\n+      if (mpz_cmp (p, gfc_integer_kinds[i].pedantic_min_int) < 0)\n+        result = ARITH_ASYMMETRIC;\n+    }\n+\n   if (mpz_cmp (p, gfc_integer_kinds[i].min_int) < 0\n       || mpz_cmp (p, gfc_integer_kinds[i].max_int) > 0)\n     result = ARITH_OVERFLOW;\n@@ -529,7 +549,7 @@ gfc_range_check (gfc_expr * e)\n     default:\n       gfc_internal_error (\"gfc_range_check(): Bad type\");\n     }\n-\n+    \n   return rc;\n }\n \n@@ -582,6 +602,12 @@ gfc_arith_uminus (gfc_expr * op1, gfc_expr ** resultp)\n       rc = ARITH_OK;\n       *resultp = result;\n     }\n+  else if (rc == ARITH_ASYMMETRIC)\n+    {\n+      gfc_warning (\"%s at %L\", gfc_arith_error (rc), &op1->where);\n+      rc = ARITH_OK;\n+      *resultp = result;\n+    }\n   else if (rc != ARITH_OK)\n     gfc_free_expr (result);\n   else\n@@ -631,6 +657,12 @@ gfc_arith_plus (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n       rc = ARITH_OK;\n       *resultp = result;\n     }\n+  else if (rc == ARITH_ASYMMETRIC)\n+    {\n+      gfc_warning (\"%s at %L\", gfc_arith_error (rc), &op1->where);\n+      rc = ARITH_OK;\n+      *resultp = result;\n+    }\n   else if (rc != ARITH_OK)\n     gfc_free_expr (result);\n   else\n@@ -680,6 +712,12 @@ gfc_arith_minus (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n       rc = ARITH_OK;\n       *resultp = result;\n     }\n+  else if (rc == ARITH_ASYMMETRIC)\n+    {\n+      gfc_warning (\"%s at %L\", gfc_arith_error (rc), &op1->where);\n+      rc = ARITH_OK;\n+      *resultp = result;\n+    }\n   else if (rc != ARITH_OK)\n     gfc_free_expr (result);\n   else\n@@ -743,6 +781,12 @@ gfc_arith_times (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n       rc = ARITH_OK;\n       *resultp = result;\n     }\n+  else if (rc == ARITH_ASYMMETRIC)\n+    {\n+      gfc_warning (\"%s at %L\", gfc_arith_error (rc), &op1->where);\n+      rc = ARITH_OK;\n+      *resultp = result;\n+    }\n   else if (rc != ARITH_OK)\n     gfc_free_expr (result);\n   else\n@@ -839,6 +883,12 @@ gfc_arith_divide (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n       rc = ARITH_OK;\n       *resultp = result;\n     }\n+  else if (rc == ARITH_ASYMMETRIC)\n+    {\n+      gfc_warning (\"%s at %L\", gfc_arith_error (rc), &op1->where);\n+      rc = ARITH_OK;\n+      *resultp = result;\n+    }\n   else if (rc != ARITH_OK)\n     gfc_free_expr (result);\n   else\n@@ -1029,11 +1079,17 @@ gfc_arith_power (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n       rc = ARITH_OK;\n       *resultp = result;\n     }\n+  else if (rc == ARITH_ASYMMETRIC)\n+    {\n+      gfc_warning (\"%s at %L\", gfc_arith_error (rc), &op1->where);\n+      rc = ARITH_OK;\n+      *resultp = result;\n+    }\n   else if (rc != ARITH_OK)\n     gfc_free_expr (result);\n   else\n     *resultp = result;\n-\n+  \n   return rc;\n }\n \n@@ -1932,9 +1988,16 @@ gfc_int2int (gfc_expr * src, int kind)\n   if ((rc = gfc_check_integer_range (result->value.integer, kind))\n       != ARITH_OK)\n     {\n-      arith_error (rc, &src->ts, &result->ts, &src->where);\n-      gfc_free_expr (result);\n-      return NULL;\n+      if (rc == ARITH_ASYMMETRIC)\n+        {\n+          gfc_warning (\"%s at %L\", gfc_arith_error (rc), &src->where);\n+        }\n+      else\n+        {\n+          arith_error (rc, &src->ts, &result->ts, &src->where);\n+          gfc_free_expr (result);\n+          return NULL;\n+        }\n     }\n \n   return result;"}, {"sha": "85485612d0f9598bde2d0ff07f0bc8ff2f52dc20", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14df5747394ff436ba13ebd39c2742c40fc45eb8/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14df5747394ff436ba13ebd39c2742c40fc45eb8/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=14df5747394ff436ba13ebd39c2742c40fc45eb8", "patch": "@@ -185,7 +185,7 @@ extern mstring intrinsic_operators[];\n /* Arithmetic results.  */\n typedef enum\n { ARITH_OK = 1, ARITH_OVERFLOW, ARITH_UNDERFLOW, ARITH_NAN,\n-  ARITH_DIV0, ARITH_0TO0, ARITH_INCOMMENSURATE\n+  ARITH_DIV0, ARITH_0TO0, ARITH_INCOMMENSURATE, ARITH_ASYMMETRIC\n }\n arith;\n \n@@ -1100,7 +1100,7 @@ gfc_expr;\n typedef struct\n {\n   /* Values really representable by the target.  */\n-  mpz_t huge, min_int, max_int;\n+  mpz_t huge, pedantic_min_int, min_int, max_int;\n \n   int kind, radix, digits, bit_size, range;\n "}]}