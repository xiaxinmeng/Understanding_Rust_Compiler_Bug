{"sha": "03f6d32edb50546f1a123e848ae98a70a747b0c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDNmNmQzMmVkYjUwNTQ2ZjFhMTIzZTg0OGFlOThhNzBhNzQ3YjBjNw==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2018-10-11T19:03:33Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2018-10-11T19:03:33Z"}, "message": "C++: suggestions for misspelled private members (PR c++/84993)\n\nPR c++/84993 identifies a problem with our suggestions for\nmisspelled member names in the C++ FE for the case where the\nmember is private.\n\nFor example, given:\n\nclass foo\n{\npublic:\n  double get_ratio() const { return m_ratio; }\n\nprivate:\n  double m_ratio;\n};\n\nvoid test(foo *ptr)\n{\n  if (ptr->ratio >= 0.5)\n    ;// etc\n}\n\n...we currently emit this suggestion:\n\n<source>: In function 'void test(foo*)':\n<source>:12:12: error: 'class foo' has no member named 'ratio'; did you mean 'm_ratio'?\n   if (ptr->ratio >= 0.5)\n            ^~~~~\n            m_ratio\n\n...but if the user follows this suggestion, they get:\n\n<source>: In function 'void test(foo*)':\n<source>:12:12: error: 'double foo::m_ratio' is private within this context\n   if (ptr->m_ratio >= 0.5)\n            ^~~~~~~\n<source>:7:10: note: declared private here\n   double m_ratio;\n          ^~~~~~~\n<source>:12:12: note: field 'double foo::m_ratio' can be accessed via 'double foo::get_ratio() const'\n   if (ptr->m_ratio >= 0.5)\n            ^~~~~~~\n            get_ratio()\n\nIt feels wrong to be emitting a fix-it hint that doesn't compile, so this\npatch adds the accessor fix-it hint logic to this case, so that we directly\noffer a valid suggestion:\n\n<source>: In function 'void test(foo*)':\n<source>:12:12: error: 'class foo' has no member named 'ratio'; did you mean\n'double foo::m_ratio'? (accessible via 'double foo::get_ratio() const')\n   if (ptr->ratio >= 0.5)\n            ^~~~~\n            get_ratio()\n\ngcc/cp/ChangeLog:\n\tPR c++/84993\n\t* call.c (enforce_access): Move diagnostics to...\n\t(complain_about_access): ...this new function.\n\t* cp-tree.h (class access_failure_info): Rename split out field\n\t\"m_field_decl\" into \"m_decl\" and \"m_diag_decl\".\n\t(access_failure_info::record_access_failure): Add tree param.\n\t(access_failure_info::was_inaccessible_p): New accessor.\n\t(access_failure_info::get_decl): New accessor.\n\t(access_failure_info::get_diag_decl): New accessor.\n\t(access_failure_info::get_any_accessor): New member function.\n\t(access_failure_info::add_fixit_hint): New static member function.\n\t(complain_about_access): New decl.\n\t* typeck.c (access_failure_info::record_access_failure): Update\n\tfor change to fields.\n\t(access_failure_info::maybe_suggest_accessor): Split out into...\n\t(access_failure_info::get_any_accessor): ...this new function...\n\t(access_failure_info::add_fixit_hint): ...and this new function.\n\t(finish_class_member_access_expr): Split out \"has no member named\"\n\terror-handling into...\n\t(complain_about_unrecognized_member): ...this new function, and\n\tcheck that the guessed name is accessible along the access path.\n\tOnly provide a spell-correction fix-it hint if it is; otherwise,\n\tattempt to issue an accessor fix-it hint.\n\ngcc/testsuite/ChangeLog:\n\tPR c++/84993\n\t* g++.dg/torture/accessor-fixits-9.C: New test.\n\nFrom-SVN: r265056", "tree": {"sha": "eebbad5740eb6f7d20c0276e17e09a489b15efde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eebbad5740eb6f7d20c0276e17e09a489b15efde"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03f6d32edb50546f1a123e848ae98a70a747b0c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03f6d32edb50546f1a123e848ae98a70a747b0c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03f6d32edb50546f1a123e848ae98a70a747b0c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03f6d32edb50546f1a123e848ae98a70a747b0c7/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c7f45560c7856139118f71dd31d1bc2f3eb7b98c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7f45560c7856139118f71dd31d1bc2f3eb7b98c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7f45560c7856139118f71dd31d1bc2f3eb7b98c"}], "stats": {"total": 381, "additions": 313, "deletions": 68}, "files": [{"sha": "a3d29d75b36e445d88970e6c7fca80385b6fbd68", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03f6d32edb50546f1a123e848ae98a70a747b0c7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03f6d32edb50546f1a123e848ae98a70a747b0c7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=03f6d32edb50546f1a123e848ae98a70a747b0c7", "patch": "@@ -1,3 +1,29 @@\n+2018-10-11  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c++/84993\n+\t* call.c (enforce_access): Move diagnostics to...\n+\t(complain_about_access): ...this new function.\n+\t* cp-tree.h (class access_failure_info): Rename split out field\n+\t\"m_field_decl\" into \"m_decl\" and \"m_diag_decl\".\n+\t(access_failure_info::record_access_failure): Add tree param.\n+\t(access_failure_info::was_inaccessible_p): New accessor.\n+\t(access_failure_info::get_decl): New accessor.\n+\t(access_failure_info::get_diag_decl): New accessor.\n+\t(access_failure_info::get_any_accessor): New member function.\n+\t(access_failure_info::add_fixit_hint): New static member function.\n+\t(complain_about_access): New decl.\n+\t* typeck.c (access_failure_info::record_access_failure): Update\n+\tfor change to fields.\n+\t(access_failure_info::maybe_suggest_accessor): Split out into...\n+\t(access_failure_info::get_any_accessor): ...this new function...\n+\t(access_failure_info::add_fixit_hint): ...and this new function.\n+\t(finish_class_member_access_expr): Split out \"has no member named\"\n+\terror-handling into...\n+\t(complain_about_unrecognized_member): ...this new function, and\n+\tcheck that the guessed name is accessible along the access path.\n+\tOnly provide a spell-correction fix-it hint if it is; otherwise,\n+\tattempt to issue an accessor fix-it hint.\n+\n 2018-10-11  Nathan Sidwell  <nathan@acm.org>\n \n \t* parser.c (cp_parser_translation_unit): Return void.  Don't fail"}, {"sha": "0baf26e43460e7f061f606e5a6b423c4995333b6", "filename": "gcc/cp/call.c", "status": "modified", "additions": 37, "deletions": 27, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03f6d32edb50546f1a123e848ae98a70a747b0c7/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03f6d32edb50546f1a123e848ae98a70a747b0c7/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=03f6d32edb50546f1a123e848ae98a70a747b0c7", "patch": "@@ -6514,6 +6514,38 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n   return error_mark_node;\n }\n \n+/* Issue diagnostics about a disallowed access of DECL, using DIAG_DECL\n+   in the diagnostics.\n+\n+   If ISSUE_ERROR is true, then issue an error about the\n+   access, followed by a note showing the declaration.\n+   Otherwise, just show the note.  */\n+\n+void\n+complain_about_access (tree decl, tree diag_decl, bool issue_error)\n+{\n+  if (TREE_PRIVATE (decl))\n+    {\n+      if (issue_error)\n+\terror (\"%q#D is private within this context\", diag_decl);\n+      inform (DECL_SOURCE_LOCATION (diag_decl),\n+\t      \"declared private here\");\n+    }\n+  else if (TREE_PROTECTED (decl))\n+    {\n+      if (issue_error)\n+\terror (\"%q#D is protected within this context\", diag_decl);\n+      inform (DECL_SOURCE_LOCATION (diag_decl),\n+\t      \"declared protected here\");\n+    }\n+  else\n+    {\n+      if (issue_error)\n+\terror (\"%q#D is inaccessible within this context\", diag_decl);\n+      inform (DECL_SOURCE_LOCATION (diag_decl), \"declared here\");\n+    }\n+}\n+\n /* If the current scope isn't allowed to access DECL along\n    BASETYPE_PATH, give an error.  The most derived class in\n    BASETYPE_PATH is the one used to qualify DECL. DIAG_DECL is\n@@ -6538,34 +6570,12 @@ enforce_access (tree basetype_path, tree decl, tree diag_decl,\n \n   if (!accessible_p (basetype_path, decl, true))\n     {\n+      if (flag_new_inheriting_ctors)\n+\tdiag_decl = strip_inheriting_ctors (diag_decl);\n       if (complain & tf_error)\n-\t{\n-\t  if (flag_new_inheriting_ctors)\n-\t    diag_decl = strip_inheriting_ctors (diag_decl);\n-\t  if (TREE_PRIVATE (decl))\n-\t    {\n-\t      error (\"%q#D is private within this context\", diag_decl);\n-\t      inform (DECL_SOURCE_LOCATION (diag_decl),\n-\t\t      \"declared private here\");\n-\t      if (afi)\n-\t\tafi->record_access_failure (basetype_path, diag_decl);\n-\t    }\n-\t  else if (TREE_PROTECTED (decl))\n-\t    {\n-\t      error (\"%q#D is protected within this context\", diag_decl);\n-\t      inform (DECL_SOURCE_LOCATION (diag_decl),\n-\t\t      \"declared protected here\");\n-\t      if (afi)\n-\t\tafi->record_access_failure (basetype_path, diag_decl);\n-\t    }\n-\t  else\n-\t    {\n-\t      error (\"%q#D is inaccessible within this context\", diag_decl);\n-\t      inform (DECL_SOURCE_LOCATION (diag_decl), \"declared here\");\n-\t      if (afi)\n-\t\tafi->record_access_failure (basetype_path, diag_decl);\n-\t    }\n-\t}\n+\tcomplain_about_access (decl, diag_decl, true);\n+      if (afi)\n+\tafi->record_access_failure (basetype_path, decl, diag_decl);\n       return false;\n     }\n "}, {"sha": "26ded3a921438d80dcfc15d65a8d03f3502b891e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03f6d32edb50546f1a123e848ae98a70a747b0c7/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03f6d32edb50546f1a123e848ae98a70a747b0c7/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=03f6d32edb50546f1a123e848ae98a70a747b0c7", "patch": "@@ -6103,18 +6103,27 @@ extern void complain_about_bad_argument\t(location_t arg_loc,\n class access_failure_info\n {\n  public:\n-  access_failure_info () : m_was_inaccessible (false), m_basetype_path (NULL_TREE),\n-    m_field_decl (NULL_TREE) {}\n+  access_failure_info () : m_was_inaccessible (false),\n+    m_basetype_path (NULL_TREE),\n+    m_decl (NULL_TREE), m_diag_decl (NULL_TREE) {}\n \n-  void record_access_failure (tree basetype_path, tree field_decl);\n+  void record_access_failure (tree basetype_path, tree decl, tree diag_decl);\n+\n+  bool was_inaccessible_p () const { return m_was_inaccessible; }\n+  tree get_decl () const { return m_decl; }\n+  tree get_diag_decl () const { return m_diag_decl; }\n+  tree get_any_accessor (bool const_p) const;\n   void maybe_suggest_accessor (bool const_p) const;\n+  static void add_fixit_hint (rich_location *richloc, tree accessor);\n \n  private:\n   bool m_was_inaccessible;\n   tree m_basetype_path;\n-  tree m_field_decl;\n+  tree m_decl;\n+  tree m_diag_decl;\n };\n \n+extern void complain_about_access\t\t(tree, tree, bool);\n extern bool enforce_access\t\t\t(tree, tree, tree,\n \t\t\t\t\t\t tsubst_flags_t,\n \t\t\t\t\t\t access_failure_info *afi = NULL);"}, {"sha": "c921096cb31f84d5e5dfef1dd107b931917eecd8", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 113, "deletions": 37, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03f6d32edb50546f1a123e848ae98a70a747b0c7/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03f6d32edb50546f1a123e848ae98a70a747b0c7/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=03f6d32edb50546f1a123e848ae98a70a747b0c7", "patch": "@@ -2708,43 +2708,138 @@ check_template_keyword (tree decl)\n }\n \n /* Record that an access failure occurred on BASETYPE_PATH attempting\n-   to access FIELD_DECL.  */\n+   to access DECL, where DIAG_DECL should be used for diagnostics.  */\n \n void\n access_failure_info::record_access_failure (tree basetype_path,\n-\t\t\t\t\t    tree field_decl)\n+\t\t\t\t\t    tree decl, tree diag_decl)\n {\n   m_was_inaccessible = true;\n   m_basetype_path = basetype_path;\n-  m_field_decl = field_decl;\n+  m_decl = decl;\n+  m_diag_decl = diag_decl;\n }\n \n /* If an access failure was recorded, then attempt to locate an\n-   accessor function for the pertinent field, and if one is\n-   available, add a note and fix-it hint suggesting using it.  */\n+   accessor function for the pertinent field.\n+   Otherwise, return NULL_TREE.  */\n \n-void\n-access_failure_info::maybe_suggest_accessor (bool const_p) const\n+tree\n+access_failure_info::get_any_accessor (bool const_p) const\n {\n-  if (!m_was_inaccessible)\n-    return;\n+  if (!was_inaccessible_p ())\n+    return NULL_TREE;\n \n   tree accessor\n-    = locate_field_accessor (m_basetype_path, m_field_decl, const_p);\n+    = locate_field_accessor (m_basetype_path, m_diag_decl, const_p);\n   if (!accessor)\n-    return;\n+    return NULL_TREE;\n \n   /* The accessor must itself be accessible for it to be a reasonable\n      suggestion.  */\n   if (!accessible_p (m_basetype_path, accessor, true))\n-    return;\n+    return NULL_TREE;\n \n-  rich_location richloc (line_table, input_location);\n+  return accessor;\n+}\n+\n+/* Add a fix-it hint to RICHLOC suggesting the use of ACCESSOR_DECL, by\n+   replacing the primary location in RICHLOC with \"accessor()\".  */\n+\n+void\n+access_failure_info::add_fixit_hint (rich_location *richloc,\n+\t\t\t\t     tree accessor_decl)\n+{\n   pretty_printer pp;\n-  pp_printf (&pp, \"%s()\", IDENTIFIER_POINTER (DECL_NAME (accessor)));\n-  richloc.add_fixit_replace (pp_formatted_text (&pp));\n+  pp_printf (&pp, \"%s()\", IDENTIFIER_POINTER (DECL_NAME (accessor_decl)));\n+  richloc->add_fixit_replace (pp_formatted_text (&pp));\n+}\n+\n+/* If an access failure was recorded, then attempt to locate an\n+   accessor function for the pertinent field, and if one is\n+   available, add a note and fix-it hint suggesting using it.  */\n+\n+void\n+access_failure_info::maybe_suggest_accessor (bool const_p) const\n+{\n+  tree accessor = get_any_accessor (const_p);\n+  if (accessor == NULL_TREE)\n+    return;\n+  rich_location richloc (line_table, input_location);\n+  add_fixit_hint (&richloc, accessor);\n   inform (&richloc, \"field %q#D can be accessed via %q#D\",\n-\t  m_field_decl, accessor);\n+\t  m_diag_decl, accessor);\n+}\n+\n+/* Subroutine of finish_class_member_access_expr.\n+   Issue an error about NAME not being a member of ACCESS_PATH (or\n+   OBJECT_TYPE), potentially providing a fix-it hint for misspelled\n+   names.  */\n+\n+static void\n+complain_about_unrecognized_member (tree access_path, tree name,\n+\t\t\t\t    tree object_type)\n+{\n+  /* Attempt to provide a hint about misspelled names.  */\n+  tree guessed_id = lookup_member_fuzzy (access_path, name,\n+\t\t\t\t\t /*want_type=*/false);\n+  if (guessed_id == NULL_TREE)\n+    {\n+      /* No hint.  */\n+      error (\"%q#T has no member named %qE\",\n+\t     TREE_CODE (access_path) == TREE_BINFO\n+\t     ? TREE_TYPE (access_path) : object_type, name);\n+      return;\n+    }\n+\n+  location_t bogus_component_loc = input_location;\n+  gcc_rich_location rich_loc (bogus_component_loc);\n+\n+  /* Check that the guessed name is accessible along access_path.  */\n+  access_failure_info afi;\n+  lookup_member (access_path, guessed_id, /*protect=*/1,\n+\t\t /*want_type=*/false, /*complain=*/false,\n+\t\t &afi);\n+  if (afi.was_inaccessible_p ())\n+    {\n+      tree accessor = afi.get_any_accessor (TYPE_READONLY (object_type));\n+      if (accessor)\n+\t{\n+\t  /* The guessed name isn't directly accessible, but can be accessed\n+\t     via an accessor member function.  */\n+\t  afi.add_fixit_hint (&rich_loc, accessor);\n+\t  error_at (&rich_loc,\n+\t\t    \"%q#T has no member named %qE;\"\n+\t\t    \" did you mean %q#D? (accessible via %q#D)\",\n+\t\t    TREE_CODE (access_path) == TREE_BINFO\n+\t\t    ? TREE_TYPE (access_path) : object_type,\n+\t\t    name, afi.get_diag_decl (), accessor);\n+\t}\n+      else\n+\t{\n+\t  /* The guessed name isn't directly accessible, and no accessor\n+\t     member function could be found.  */\n+\t  error_at (&rich_loc,\n+\t\t    \"%q#T has no member named %qE;\"\n+\t\t    \" did you mean %q#D? (not accessible from this context)\",\n+\t\t    TREE_CODE (access_path) == TREE_BINFO\n+\t\t    ? TREE_TYPE (access_path) : object_type,\n+\t\t    name, afi.get_diag_decl ());\n+\t  complain_about_access (afi.get_decl (), afi.get_diag_decl (), false);\n+\t}\n+    }\n+  else\n+    {\n+      /* The guessed name is directly accessible; suggest it.  */\n+      rich_loc.add_fixit_misspelled_id (bogus_component_loc,\n+\t\t\t\t\tguessed_id);\n+      error_at (&rich_loc,\n+\t\t\"%q#T has no member named %qE;\"\n+\t\t\" did you mean %qE?\",\n+\t\tTREE_CODE (access_path) == TREE_BINFO\n+\t\t? TREE_TYPE (access_path) : object_type,\n+\t\tname, guessed_id);\n+    }\n }\n \n /* This function is called by the parser to process a class member\n@@ -2940,27 +3035,8 @@ finish_class_member_access_expr (cp_expr object, tree name, bool template_p,\n \t\t/* Try again at instantiation time.  */\n \t\tgoto dependent;\n \t      if (complain & tf_error)\n-\t\t{\n-\t\t  tree guessed_id = lookup_member_fuzzy (access_path, name,\n-\t\t\t\t\t\t\t /*want_type=*/false);\n-\t\t  if (guessed_id)\n-\t\t    {\n-\t\t      location_t bogus_component_loc = input_location;\n-\t\t      gcc_rich_location rich_loc (bogus_component_loc);\n-\t\t      rich_loc.add_fixit_misspelled_id (bogus_component_loc,\n-\t\t\t\t\t\t\tguessed_id);\n-\t\t      error_at (&rich_loc,\n-\t\t\t\t\"%q#T has no member named %qE;\"\n-\t\t\t\t\" did you mean %qE?\",\n-\t\t\t\tTREE_CODE (access_path) == TREE_BINFO\n-\t\t\t\t? TREE_TYPE (access_path) : object_type,\n-\t\t\t\tname, guessed_id);\n-\t\t    }\n-\t\t  else\n-\t\t    error (\"%q#T has no member named %qE\",\n-\t\t\t   TREE_CODE (access_path) == TREE_BINFO\n-\t\t\t   ? TREE_TYPE (access_path) : object_type, name);\n-\t\t}\n+\t\tcomplain_about_unrecognized_member (access_path, name,\n+\t\t\t\t\t\t    object_type);\n \t      return error_mark_node;\n \t    }\n \t  if (member == error_mark_node)"}, {"sha": "a1ba7da09b832142f94da158e3d2bd9dbc0d44eb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03f6d32edb50546f1a123e848ae98a70a747b0c7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03f6d32edb50546f1a123e848ae98a70a747b0c7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=03f6d32edb50546f1a123e848ae98a70a747b0c7", "patch": "@@ -1,3 +1,8 @@\n+2018-10-11  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c++/84993\n+\t* g++.dg/torture/accessor-fixits-9.C: New test.\n+\n 2018-10-11  Nathan Sidwell  <nathan@acm.org>\n \n \t* g++.dg/parse/close-brace.C: New."}, {"sha": "d9e77ba2d3bd83992030271062088ce6bf49f50c", "filename": "gcc/testsuite/g++.dg/torture/accessor-fixits-9.C", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03f6d32edb50546f1a123e848ae98a70a747b0c7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Faccessor-fixits-9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03f6d32edb50546f1a123e848ae98a70a747b0c7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Faccessor-fixits-9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Faccessor-fixits-9.C?ref=03f6d32edb50546f1a123e848ae98a70a747b0c7", "patch": "@@ -0,0 +1,119 @@\n+// PR c++/84993\n+// { dg-options \"-fdiagnostics-show-caret\" }\n+\n+/* Misspelling (by omitting a leading \"m_\") of a private member for which\n+   there's a public accessor.\n+\n+   We expect a fix-it hint suggesting the accessor.  */\n+\n+class t1\n+{\n+public:\n+  int get_ratio () const { return m_ratio; }\n+\n+private:\n+  int m_ratio;\n+};\n+\n+int test (t1 *ptr_1)\n+{\n+  return ptr_1->ratio; // { dg-error \"'class t1' has no member named 'ratio'; did you mean 'int t1::m_ratio'\\\\? \\\\(accessible via 'int t1::get_ratio\\\\(\\\\) const'\\\\)\" }\n+  /* { dg-begin-multiline-output \"\" }\n+   return ptr_1->ratio;\n+                 ^~~~~\n+                 get_ratio()\n+     { dg-end-multiline-output \"\" } */\n+}\n+\n+\n+/* Misspelling of a private member for which there's a public accessor.\n+\n+   We expect a fix-it hint suggesting the accessor.  */\n+\n+class t2\n+{\n+public:\n+  int get_color () const { return m_color; }\n+\n+private:\n+  int m_color;\n+};\n+\n+int test (t2 *ptr_2)\n+{\n+  return ptr_2->m_colour; // { dg-error \"'class t2' has no member named 'm_colour'; did you mean 'int t2::m_color'\\\\? \\\\(accessible via 'int t2::get_color\\\\(\\\\) const'\\\\)\" }\n+  /* { dg-begin-multiline-output \"\" }\n+   return ptr_2->m_colour;\n+                 ^~~~~~~~\n+                 get_color()\n+     { dg-end-multiline-output \"\" } */\n+}\n+\n+\n+/* Misspelling of a private member via a subclass pointer, for which there's\n+   a public accessor in the base class.\n+\n+   We expect a fix-it hint suggesting the accessor.  */\n+\n+class t3 : public t2 {};\n+\n+int test (t3 *ptr_3)\n+{\n+  return ptr_3->m_colour; // { dg-error \"'class t3' has no member named 'm_colour'; did you mean 'int t2::m_color'\\\\? \\\\(accessible via 'int t2::get_color\\\\(\\\\) const'\\\\)\" }\n+  /* { dg-begin-multiline-output \"\" }\n+   return ptr_3->m_colour;\n+                 ^~~~~~~~\n+                 get_color()\n+     { dg-end-multiline-output \"\" } */\n+}\n+\n+\n+/* Misspelling of a protected member, for which there's isn't a public\n+   accessor.\n+\n+   We expect no fix-it hint; instead a message identifying where the\n+   data member was declared.  */\n+\n+class t4\n+{\n+protected:\n+  int m_color; // { dg-message \"declared protected here\" }\n+};\n+\n+int test (t4 *ptr_4)\n+{\n+  return ptr_4->m_colour; // { dg-error \"'class t4' has no member named 'm_colour'; did you mean 'int t4::m_color'\\\\? \\\\(not accessible from this context\\\\)\" }\n+  /* { dg-begin-multiline-output \"\" }\n+   return ptr_4->m_colour;\n+                 ^~~~~~~~\n+     { dg-end-multiline-output \"\" } */\n+  /* { dg-begin-multiline-output \"\" }\n+   int m_color;\n+       ^~~~~~~\n+     { dg-end-multiline-output \"\" } */\n+}\n+\n+\n+/* Misspelling of a private member, for which the accessor is also private.\n+\n+   We expect no fix-it hint; instead a message identifying where the\n+   data member was declared.  */\n+\n+class t5\n+{\n+  int get_color () const { return m_color; }\n+  int m_color; // { dg-message \"declared private here\" }\n+};\n+\n+int test (t5 *ptr_5)\n+{\n+  return ptr_5->m_colour; // { dg-error \"'class t5' has no member named 'm_colour'; did you mean 'int t5::m_color'\\\\? \\\\(not accessible from this context\\\\)\" }\n+  /* { dg-begin-multiline-output \"\" }\n+   return ptr_5->m_colour;\n+                 ^~~~~~~~\n+     { dg-end-multiline-output \"\" } */\n+  /* { dg-begin-multiline-output \"\" }\n+   int m_color;\n+       ^~~~~~~\n+     { dg-end-multiline-output \"\" } */\n+}"}]}