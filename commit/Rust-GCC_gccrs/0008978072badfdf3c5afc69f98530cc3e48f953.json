{"sha": "0008978072badfdf3c5afc69f98530cc3e48f953", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDAwODk3ODA3MmJhZGZkZjNjNWFmYzY5Zjk4NTMwY2MzZTQ4Zjk1Mw==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@klomp.org", "date": "2005-02-12T13:51:11Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2005-02-12T13:51:11Z"}, "message": "Fixes bug libgcj/8170\n\n       Fixes bug libgcj/8170\n       * java/lang/ClassLoader.java (loadClass): Don't rewrap\n       ClassNotFoundException.\n       * gnu/java/lang/MainThread.java (run): Chain NoClassDefFoundError.\n       * gnu/gcj/runtime/NameFinder.java (remove_interpreter): Removed.\n       (remove_internal): New field superceding remove_interpreter.\n       (sanitizeStack): Remove all no-package classes starting with \"_Jv_\".\n       Remove no-class methods starting with \"_Jv_\". And Replace null\n       class or method names with the empty string. Stop at either the\n       MainThread or a real Thread run() method.\n       (newElement): Made static.\n       * java/net/URLClassLoader.java (findClass): Throw\n       ClassNotFoundExceptions including urls, plus parent using toString().\n       (thisString): New field.\n       (toString): New method.\n\nFrom-SVN: r94935", "tree": {"sha": "d1a4c371ccfdcb609926e0a4c67a184227910bb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1a4c371ccfdcb609926e0a4c67a184227910bb5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0008978072badfdf3c5afc69f98530cc3e48f953", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0008978072badfdf3c5afc69f98530cc3e48f953", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0008978072badfdf3c5afc69f98530cc3e48f953", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0008978072badfdf3c5afc69f98530cc3e48f953/comments", "author": null, "committer": null, "parents": [{"sha": "8ad833acc437754377f80eeab747ad2147f0e7a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ad833acc437754377f80eeab747ad2147f0e7a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ad833acc437754377f80eeab747ad2147f0e7a5"}], "stats": {"total": 153, "additions": 110, "deletions": 43}, "files": [{"sha": "579ee7634515e87c923e23d2c6d901d4c9fa63d6", "filename": "libjava/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0008978072badfdf3c5afc69f98530cc3e48f953/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0008978072badfdf3c5afc69f98530cc3e48f953/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=0008978072badfdf3c5afc69f98530cc3e48f953", "patch": "@@ -1,3 +1,21 @@\n+2005-02-12  Mark Wielaard  <mark@klomp.org>\n+\n+\tFixes bug libgcj/8170\n+\t* java/lang/ClassLoader.java (loadClass): Don't rewrap\n+\tClassNotFoundException.\n+\t* gnu/java/lang/MainThread.java (run): Chain NoClassDefFoundError.\n+\t* gnu/gcj/runtime/NameFinder.java (remove_interpreter): Removed.\n+\t(remove_internal): New field superceding remove_interpreter.\n+\t(sanitizeStack): Remove all no-package classes starting with \"_Jv_\".\n+\tRemove no-class methods starting with \"_Jv_\". And Replace null\n+\tclass or method names with the empty string. Stop at either the\n+\tMainThread or a real Thread run() method.\n+\t(newElement): Made static.\n+\t* java/net/URLClassLoader.java (findClass): Throw\n+\tClassNotFoundExceptions including urls, plus parent using toString().\n+\t(thisString): New field.\n+\t(toString): New method.\n+\n 2005-02-10  Tom Tromey  <tromey@redhat.com>\n \n \t* external/sax/Makefile.in: Rebuilt."}, {"sha": "b14bbf933273afd69933903cce57b7accfc7986d", "filename": "libjava/gnu/gcj/runtime/NameFinder.java", "status": "modified", "additions": 50, "deletions": 25, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0008978072badfdf3c5afc69f98530cc3e48f953/libjava%2Fgnu%2Fgcj%2Fruntime%2FNameFinder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0008978072badfdf3c5afc69f98530cc3e48f953/libjava%2Fgnu%2Fgcj%2Fruntime%2FNameFinder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fruntime%2FNameFinder.java?ref=0008978072badfdf3c5afc69f98530cc3e48f953", "patch": "@@ -37,8 +37,8 @@\n  *     Whether calls to unknown functions (class and method names are unknown)\n  *     should be removed from the stack trace. Only done when the stack is\n  *     sanitized.</ul>\n- * <ul><code>gnu.gcj.runtime.NameFinder.remove_interpreter</code>\n- *     Whether runtime interpreter calls (methods in the _Jv_InterpMethod class\n+ * <ul><code>gnu.gcj.runtime.NameFinder.remove_internal</code>\n+ *     Whether runtime internal calls (methods in the internal _Jv_* classes\n  *     and functions starting with 'ffi_') should be removed from the stack\n  *     trace. Only done when the stack is sanitized.</ul>\n  * <ul><code>gnu.gcj.runtime.NameFinder.use_addr2line</code>\n@@ -72,10 +72,18 @@\n \t  = Boolean.valueOf(System.getProperty\n \t\t(\"gnu.gcj.runtime.NameFinder.remove_unknown\", \"true\")\n \t    ).booleanValue();\n-  private static final boolean remove_interpreter\n-\t  = Boolean.valueOf(System.getProperty\n+\n+  // The remove_interpreter name is an old 3.3/3.4 (deprecated) synonym.\n+  private static final boolean remove_internal\n+\t  = (Boolean.valueOf(System.getProperty\n+\t\t(\"gnu.gcj.runtime.NameFinder.remove_internal\", \"true\")\n+\t\t\t     ).booleanValue()\n+\t     ||\n+\t     Boolean.valueOf(System.getProperty\n \t\t(\"gnu.gcj.runtime.NameFinder.remove_interpreter\", \"true\")\n-\t    ).booleanValue();\n+                             ).booleanValue()\n+\t     );\n+\n   private static final boolean use_addr2line\n \t  = Boolean.valueOf(System.getProperty\n \t\t(\"gnu.gcj.runtime.NameFinder.use_addr2line\", \"true\")\n@@ -280,7 +288,7 @@ private static StackTraceElement[] sanitizeStack(StackTraceElement[] elements,\n       consName = className.substring(lastDot + 1) + '(';\n \n     int unknown = 0;\n-    int interpreter = 0;\n+    int internal = 0;\n     int last_throw = -1;\n     int length = elements.length;\n     int end = length-1;\n@@ -300,19 +308,23 @@ private static StackTraceElement[] sanitizeStack(StackTraceElement[] elements,\n \t\t|| MName.startsWith(\"fillInStackTrace(\"))))\n \t  {\n \t    last_throw = i;\n-\t    // Reset counting of unknown and interpreter frames.\n+\t    // Reset counting of unknown and internal frames.\n \t    unknown = 0;\n-\t    interpreter = 0;\n+\t    internal = 0;\n \t  }\n \telse if (remove_unknown && CName == null \n \t\t && (MName == null || MName.startsWith(\"0x\")))\n \t  unknown++;\n-\telse if (remove_interpreter\n+\telse if (remove_internal\n \t\t && ((CName == null\n \t\t      && MName != null && MName.startsWith(\"ffi_\"))\n-\t\t     || (CName != null && CName.equals(\"_Jv_InterpMethod\"))))\n-\t  interpreter++;\n-\telse if (\"main(java.lang.String[])\".equals(MName))\n+\t\t     || (CName != null && CName.startsWith(\"_Jv_\"))\n+\t\t     || (CName == null && MName != null\n+\t\t\t && MName.startsWith(\"_Jv_\"))))\n+\t  internal++;\n+\telse if ((\"java.lang.Thread\".equals(CName)\n+\t\t  || \"gnu.java.lang.MainThread\".equals(CName))\n+\t\t && \"run()\".equals(MName))\n \t  {\n \t    end = i;\n \t    break;\n@@ -321,11 +333,11 @@ else if (\"main(java.lang.String[])\".equals(MName))\n     int begin = last_throw+1;\n \n     // Now filter out everything at the start and the end that is not part\n-    // of the \"normal\" user program including any elements that are interpreter\n+    // of the \"normal\" user program including any elements that are internal\n     // calls or have no usefull information whatsoever.\n     // Unless that means we filter out all info.\n-    int nr_elements = end-begin-unknown-interpreter+1;\n-    if ((begin > 0 || end < length-1 || unknown > 0 || interpreter > 0)\n+    int nr_elements = end - begin - unknown - internal + 1;\n+    if ((begin > 0 || end < length-1 || unknown > 0 || internal > 0)\n \t&& nr_elements > 0)\n       {\n \tstack = new StackTraceElement[nr_elements];\n@@ -337,14 +349,27 @@ else if (\"main(java.lang.String[])\".equals(MName))\n \t    if (remove_unknown && CName == null \n \t\t && (MName == null || MName.startsWith(\"0x\")))\n \t      ; // Skip unknown frame\n-\t    else if (remove_interpreter\n+\t    else if (remove_internal\n \t\t     && ((CName == null\n-\t\t\t && MName != null && MName.startsWith(\"ffi_\"))\n-\t\t\t|| (CName != null && CName.equals(\"_Jv_InterpMethod\"))))\n-\t      ; // Skip interpreter runtime frame\n+\t\t\t  && MName != null && MName.startsWith(\"ffi_\"))\n+\t\t\t || (CName != null && CName.startsWith(\"_Jv_\"))\n+\t\t\t || (CName == null && MName != null\n+\t\t\t     && MName.startsWith(\"_Jv_\"))))\n+\t      ; // Skip internal runtime frame\n \t    else\n \t      {\n-\t\tstack[pos] = elements[i];\n+\t\t// Null Class or Method name in elements are not allowed.\n+\t\tif (MName == null || CName == null)\n+\t\t  {\n+\t\t    MName = MName == null ? \"\" : MName;\n+\t\t    CName = CName == null ? \"\" : CName;\n+\t\t    stack[pos] = newElement(elements[i].getFileName(),\n+\t\t\t\t\t    elements[i].getLineNumber(),\n+\t\t\t\t\t    CName, MName,\n+\t\t\t\t\t    elements[i].isNativeMethod());\n+\t\t  }\n+\t\telse\n+\t\t  stack[pos] = elements[i];\n \t\tpos++;\n \t      }\n \t  }\n@@ -359,11 +384,11 @@ else if (remove_interpreter\n    * Native helper method to create a StackTraceElement. Needed to work\n    * around normal Java access restrictions.\n    */\n-  native private StackTraceElement newElement(String fileName,\n-                                              int lineNumber,\n-                                              String className,\n-                                              String methName,\n-                                              boolean isNative);\n+  native static private StackTraceElement newElement(String fileName,\n+\t\t\t\t\t\t     int lineNumber,\n+\t\t\t\t\t\t     String className,\n+\t\t\t\t\t\t     String methName,\n+\t\t\t\t\t\t     boolean isNative);\n \n   /**\n    * Creates a StackTraceElement given a string and a filename."}, {"sha": "14a00ca8d9b1be8e19d59ff5dfd9883f26c1e785", "filename": "libjava/gnu/java/lang/MainThread.java", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0008978072badfdf3c5afc69f98530cc3e48f953/libjava%2Fgnu%2Fjava%2Flang%2FMainThread.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0008978072badfdf3c5afc69f98530cc3e48f953/libjava%2Fgnu%2Fjava%2Flang%2FMainThread.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Flang%2FMainThread.java?ref=0008978072badfdf3c5afc69f98530cc3e48f953", "patch": "@@ -95,7 +95,9 @@ public void run()\n \t  }\n \tcatch (ClassNotFoundException x)\n \t  {\n-\t    throw new NoClassDefFoundError(klass_name);\n+\t    NoClassDefFoundError ncdfe = new NoClassDefFoundError(klass_name);\n+\t    ncdfe.initCause(x);\n+\t    throw ncdfe;\n \t  }\n       }\n "}, {"sha": "46e523c6834d77a1a03826199b40e5700aead1d4", "filename": "libjava/java/lang/ClassLoader.java", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0008978072badfdf3c5afc69f98530cc3e48f953/libjava%2Fjava%2Flang%2FClassLoader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0008978072badfdf3c5afc69f98530cc3e48f953/libjava%2Fjava%2Flang%2FClassLoader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClassLoader.java?ref=0008978072badfdf3c5afc69f98530cc3e48f953", "patch": "@@ -288,8 +288,6 @@ protected synchronized Class loadClass(String name, boolean resolve)\n     if (c != null)\n       return c;\n \n-    ClassNotFoundException ex = null;\n-\n     // Can the class be loaded by a parent?\n     try\n       {\n@@ -306,20 +304,9 @@ protected synchronized Class loadClass(String name, boolean resolve)\n       }\n     catch (ClassNotFoundException e)\n       {\n-\tex = e;\n       }\n     // Still not found, we have to do it ourself.\n-    try\n-      {\n-\tc = findClass(name);\n-      }\n-    catch (ClassNotFoundException cause)\n-      {\n-\tif (ex != null)\n-\t  throw new ClassNotFoundException(ex.toString(), cause);\n-\telse\n-\t  throw cause;\n-      }\n+    c = findClass(name);\n     if (resolve)\n       resolveClass(c);\n     return c;"}, {"sha": "0da6a0356b2dd2a113759a470dfaf29f38fe0422", "filename": "libjava/java/net/URLClassLoader.java", "status": "modified", "additions": 38, "deletions": 3, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0008978072badfdf3c5afc69f98530cc3e48f953/libjava%2Fjava%2Fnet%2FURLClassLoader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0008978072badfdf3c5afc69f98530cc3e48f953/libjava%2Fjava%2Fnet%2FURLClassLoader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURLClassLoader.java?ref=0008978072badfdf3c5afc69f98530cc3e48f953", "patch": "@@ -1,5 +1,6 @@\n /* URLClassLoader.java --  ClassLoader that loads classes from one or more URLs\n-   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005\n+   Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -958,7 +959,7 @@ protected Class findClass(final String className)\n \tresource = loader.getResource(resourceName);\n       }\n     if (resource == null)\n-      throw new ClassNotFoundException(className + \" not found in \" + urls);\n+      throw new ClassNotFoundException(className + \" not found in \" + this);\n \n     // Try to read the class data, create the CodeSource, Package and\n     // construct the class (and watch out for those nasty IOExceptions)\n@@ -1039,9 +1040,43 @@ public Object run()\n       }\n     catch (IOException ioe)\n       {\n-        throw new ClassNotFoundException(className, ioe);\n+\tClassNotFoundException cnfe;\n+\tcnfe = new ClassNotFoundException(className + \" not found in \" + this);\n+\tcnfe.initCause(ioe);\n+\tthrow cnfe;\n       }\n   }\n+  \n+  // Cached String representation of this URLClassLoader\n+  private String thisString;\n+  \n+  /**\n+   * Returns a String representation of this URLClassLoader giving the\n+   * actual Class name, the URLs that are searched and the parent\n+   * ClassLoader.\n+   */\n+  public String toString()\n+  {\n+    if (thisString == null)\n+      {\n+\tStringBuffer sb = new StringBuffer();\n+\tsb.append(this.getClass().getName());\n+\tsb.append(\"{urls=[\" );\n+\tURL[] thisURLs = getURLs();\n+\tfor (int i = 0; i < thisURLs.length; i++)\n+\t  {\n+\t    sb.append(thisURLs[i]);\n+\t    if (i < thisURLs.length - 1)\n+\t      sb.append(',');\n+\t  }\n+\tsb.append(']');\n+\tsb.append(\", parent=\");\n+\tsb.append(getParent());\n+\tsb.append('}');\n+\tthisString = sb.toString();\n+      }\n+    return thisString;\n+  }\n \n   /**\n    * Finds the first occurrence of a resource that can be found. The locations"}]}