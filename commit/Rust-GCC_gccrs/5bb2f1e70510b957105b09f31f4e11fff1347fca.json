{"sha": "5bb2f1e70510b957105b09f31f4e11fff1347fca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWJiMmYxZTcwNTEwYjk1NzEwNWIwOWYzMWY0ZTExZmZmMTM0N2ZjYQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-07-27T01:35:35Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-07-27T01:35:35Z"}, "message": "tree.c (build_cplus_new): Adjust call to abstract_virtuals_error as per 1999-07-26 change.\n\n\t* tree.c (build_cplus_new): Adjust call to abstract_virtuals_error\n\tas per 1999-07-26 change.\n\n\t* typeck.c (c_sizeof): Don't allow non-static data members.\n\t(expr_sizeof): Likewise.\n\nFrom-SVN: r28280", "tree": {"sha": "044ebeb42e6bab7f392c835986fc537853e56e1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/044ebeb42e6bab7f392c835986fc537853e56e1e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5bb2f1e70510b957105b09f31f4e11fff1347fca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bb2f1e70510b957105b09f31f4e11fff1347fca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bb2f1e70510b957105b09f31f4e11fff1347fca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bb2f1e70510b957105b09f31f4e11fff1347fca/comments", "author": null, "committer": null, "parents": [{"sha": "4c8a3a899417130f47bc1cbc2f3217e85aca070e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c8a3a899417130f47bc1cbc2f3217e85aca070e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c8a3a899417130f47bc1cbc2f3217e85aca070e"}], "stats": {"total": 67, "additions": 55, "deletions": 12}, "files": [{"sha": "b2e6c076b71da93b77eef49df97907ee66fbad8c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bb2f1e70510b957105b09f31f4e11fff1347fca/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bb2f1e70510b957105b09f31f4e11fff1347fca/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5bb2f1e70510b957105b09f31f4e11fff1347fca", "patch": "@@ -1,3 +1,11 @@\n+1999-07-26  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* tree.c (build_cplus_new): Adjust call to abstract_virtuals_error\n+\tas per 1999-07-26 change.\n+\n+\t* typeck.c (c_sizeof): Don't allow non-static data members.\n+\t(expr_sizeof): Likewise.\n+\n 1999-07-26  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* input.c (feed_input): Only touch lineno and input_filename"}, {"sha": "89447970b02fa8314f8cfccb0047d9cf41e88019", "filename": "gcc/cp/NEWS", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bb2f1e70510b957105b09f31f4e11fff1347fca/gcc%2Fcp%2FNEWS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bb2f1e70510b957105b09f31f4e11fff1347fca/gcc%2Fcp%2FNEWS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FNEWS?ref=5bb2f1e70510b957105b09f31f4e11fff1347fca", "patch": "@@ -1,3 +1,20 @@\n+*** Changes in GCC 3.0:\n+\n+* Certain invalid conversions that were previously accepted will now\n+  be rejected.  For example, assigning function pointers of one type\n+  to function pointers of another type now requires a cast, whereas\n+  previously g++ would sometimes accept the code even without the\n+  cast.\n+\n+* G++ previously allowed `sizeof (X::Y)' where Y was a non-static\n+  member of X, even if the `sizeof' expression occurred outside\n+  of a non-static member function of X (or one of its derived classes, \n+  or a member-initializer for X or one of its derived classes.)   This\n+  extension has been removed.\n+\n+* G++ no longer allows you to overload the conditional operator (i.e., \n+  the `?:' operator.)\n+\n *** Changes in GCC 2.95:\n \n * Messages about non-conformant code that we can still handle (\"pedwarns\")"}, {"sha": "a84a9babe5dafafdd6a1ed2ef18cf673e2f78068", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bb2f1e70510b957105b09f31f4e11fff1347fca/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bb2f1e70510b957105b09f31f4e11fff1347fca/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=5bb2f1e70510b957105b09f31f4e11fff1347fca", "patch": "@@ -226,8 +226,7 @@ build_cplus_new (type, init)\n \n   /* Make sure that we're not trying to create an instance of an\n      abstract class.  */\n-  if (CLASSTYPE_ABSTRACT_VIRTUALS (type))\n-    abstract_virtuals_error (NULL_TREE, type);\n+  abstract_virtuals_error (NULL_TREE, type);\n \n   if (TREE_CODE (init) != CALL_EXPR && TREE_CODE (init) != AGGR_INIT_EXPR)\n     return convert (type, init);"}, {"sha": "905b3e3a1b253bb959339f2651e139198f05cac1", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bb2f1e70510b957105b09f31f4e11fff1347fca/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bb2f1e70510b957105b09f31f4e11fff1347fca/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=5bb2f1e70510b957105b09f31f4e11fff1347fca", "patch": "@@ -1603,23 +1603,18 @@ c_sizeof (type)\n   if (code == REFERENCE_TYPE)\n     type = TREE_TYPE (type);\n \n-  /* We couldn't find anything in the ARM or the draft standard that says,\n-     one way or the other, if doing sizeof on something that doesn't have\n-     an object associated with it is correct or incorrect.  For example, if\n-     you declare `struct S { char str[16]; };', and in your program do\n-     a `sizeof (S::str)', should we flag that as an error or should we give\n-     the size of it?  Since it seems like a reasonable thing to do, we'll go\n-     with giving the value.  */\n-  if (code == OFFSET_TYPE)\n-    type = TREE_TYPE (type);\n-\n   /* @@ This also produces an error for a signature ref.\n         In that case we should be able to do better.  */\n   if (IS_SIGNATURE (type))\n     {\n       error (\"`sizeof' applied to a signature type\");\n       return size_int (0);\n     }\n+  else if (code == OFFSET_TYPE)\n+    {\n+      cp_error (\"`sizeof' applied to non-static member\");\n+      return size_int (0);\n+    }\n \n   if (TYPE_SIZE (complete_type (type)) == 0)\n     {\n@@ -1665,6 +1660,15 @@ expr_sizeof (e)\n       incomplete_type_error (e, TREE_TYPE (e));\n       return size_int (1);\n     }\n+  /* It's illegal to say `sizeof (X::i)' for `i' a non-static data\n+     member unless you're in a non-static member of X.  But, we used\n+     to support this usage, so we still permit it unless we're being\n+     pedantic.  */\n+  else if (TREE_CODE (e) == OFFSET_REF)\n+    e = resolve_offset_ref (e);\n+\n+  if (e == error_mark_node)\n+    return e;\n \n   return c_sizeof (TREE_TYPE (e));\n }"}, {"sha": "c597844ae2e5e7e5b18cd8b4cfb8aedd559c4c88", "filename": "gcc/testsuite/g++.old-deja/g++.other/sizeof2.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bb2f1e70510b957105b09f31f4e11fff1347fca/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fsizeof2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bb2f1e70510b957105b09f31f4e11fff1347fca/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fsizeof2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fsizeof2.C?ref=5bb2f1e70510b957105b09f31f4e11fff1347fca", "patch": "@@ -0,0 +1,15 @@\n+// Build don't link:\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+struct S\n+{\n+  int j; // ERROR - member\n+  int i[2]; // ERROR - member\n+};\n+\n+void f ()\n+{\n+  sizeof (S::j); // ERROR - non-static data member\n+  sizeof (S::i[0]); //  ERROR - non-static data member\n+}\n+"}]}