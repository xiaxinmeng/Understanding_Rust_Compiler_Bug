{"sha": "33c94679bde917193e6af8644598cc85b3df1645", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzNjOTQ2NzliZGU5MTcxOTNlNmFmODY0NDU5OGNjODViM2RmMTY0NQ==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@redhat.com", "date": "2004-06-23T20:12:44Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2004-06-23T20:12:44Z"}, "message": "Makefile.in (tree-vn.o): New.\n\n\n\t* Makefile.in (tree-vn.o): New.\n\t(tree-ssa-pre.o): Don't depend on RTL_H.\n\t* tree-dfa.c (find_referenced_vars): Don't call init_tree_ssa.\n\t* tree-flow.h (struct var_ann_d): Remove field expr_set.\n\t(add_to_value, expressions_equal_p, get_value_handle, vn_compute,\n\tvn_lookup_or_add, vn_add, vn_lookup, vn_init, vn_delete): Declare.\n\t* tree-optimize.c (execute_init_datastructures): New local function.\n\t(pass_init_datastructures): New local variable.\n\t(init_tree_optimization_passes): Sequence pass_init_datastructures.\n\t* tree-pretty-print.c (MASK_POINTER): Remove.\n\t(dump_generic_node): Handle VALUE_HANDLE.\n\t* tree-ssa-pre.c: Move all value numbering routines to tree-vn.c.\n\tUpdate callers to use new function names.\n\tUse VALUE_HANDLE_ID and VALUE_HANDLE_EXPR_SET instead of\n\tvariable annotations.\n\t* tree-ssa.c (init_tree_ssa): Call vn_init.\n\t(delete_tree_ssa): Call vn_delete.\n\t* tree-vn.c: New file.\n\t* tree.c (tree_size): Handle VALUE_HANDLE.\n\t(tree_node_structure): Likewise.\n\t(iterative_hash_expr): Likewise.\n\t* tree.def (VALUE_HANDLE): New code.\n\t* tree.h (struct tree_value_handle): New.\n\t(VALUE_HANDLE_ID): Define.\n\t(VALUE_HANDLE_EXPR_SET): Define.\n\t(enum tree_node_structure_enum): Add TS_VALUE_HANDLE.\n\t(union tree_node): Add struct tree_value_handle.\n\nFrom-SVN: r83564", "tree": {"sha": "127e72e0356924b11aaf2aa72a79bae2b3ebc255", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/127e72e0356924b11aaf2aa72a79bae2b3ebc255"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/33c94679bde917193e6af8644598cc85b3df1645", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33c94679bde917193e6af8644598cc85b3df1645", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33c94679bde917193e6af8644598cc85b3df1645", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33c94679bde917193e6af8644598cc85b3df1645/comments", "author": null, "committer": null, "parents": [{"sha": "881f20cbcdaaed818ceb9f8e99226ac8c77743da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/881f20cbcdaaed818ceb9f8e99226ac8c77743da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/881f20cbcdaaed818ceb9f8e99226ac8c77743da"}], "stats": {"total": 714, "additions": 435, "deletions": 279}, "files": [{"sha": "320edb0020e4baf2c12731d4fe005ebb0b9b7086", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c94679bde917193e6af8644598cc85b3df1645/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c94679bde917193e6af8644598cc85b3df1645/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=33c94679bde917193e6af8644598cc85b3df1645", "patch": "@@ -1,3 +1,33 @@\n+2004-06-23  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* Makefile.in (tree-vn.o): New.\n+\t(tree-ssa-pre.o): Don't depend on RTL_H.\n+\t* tree-dfa.c (find_referenced_vars): Don't call init_tree_ssa.\n+\t* tree-flow.h (struct var_ann_d): Remove field expr_set.\n+\t(add_to_value, expressions_equal_p, get_value_handle, vn_compute,\n+\tvn_lookup_or_add, vn_add, vn_lookup, vn_init, vn_delete): Declare.\n+\t* tree-optimize.c (execute_init_datastructures): New local function.\n+\t(pass_init_datastructures): New local variable.\n+\t(init_tree_optimization_passes): Sequence pass_init_datastructures.\n+\t* tree-pretty-print.c (MASK_POINTER): Remove.\n+\t(dump_generic_node): Handle VALUE_HANDLE.\n+\t* tree-ssa-pre.c: Move all value numbering routines to tree-vn.c.\n+\tUpdate callers to use new function names.\n+\tUse VALUE_HANDLE_ID and VALUE_HANDLE_EXPR_SET instead of\n+\tvariable annotations.\n+\t* tree-ssa.c (init_tree_ssa): Call vn_init.\n+\t(delete_tree_ssa): Call vn_delete.\n+\t* tree-vn.c: New file.\n+\t* tree.c (tree_size): Handle VALUE_HANDLE.\n+\t(tree_node_structure): Likewise.\n+\t(iterative_hash_expr): Likewise.\n+\t* tree.def (VALUE_HANDLE): New code.\n+\t* tree.h (struct tree_value_handle): New.\n+\t(VALUE_HANDLE_ID): Define.\n+\t(VALUE_HANDLE_EXPR_SET): Define.\n+\t(enum tree_node_structure_enum): Add TS_VALUE_HANDLE.\n+\t(union tree_node): Add struct tree_value_handle.\n+\n 2004-06-23  Andrew Pinski  <apinski@apple.com>\n \n \t* c-typeck.c (composite_type):"}, {"sha": "81b5b7e51eb53299d4a0c478c2195196c1827a30", "filename": "gcc/Makefile.in", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c94679bde917193e6af8644598cc85b3df1645/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c94679bde917193e6af8644598cc85b3df1645/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=33c94679bde917193e6af8644598cc85b3df1645", "patch": "@@ -887,7 +887,7 @@ C_OBJS = c-parse.o c-lang.o stub-objc.o $(C_AND_OBJC_OBJS)\n OBJS-common = \\\n  tree-cfg.o tree-dfa.o tree-eh.o tree-ssa.o tree-optimize.o tree-gimple.o  \\\n  tree-alias-type.o gimplify.o tree-pretty-print.o tree-into-ssa.o          \\\n- tree-outof-ssa.o tree-alias-common.o tree-ssa-ccp.o\t\t\t   \\\n+ tree-outof-ssa.o tree-alias-common.o tree-ssa-ccp.o tree-vn.o             \\\n  @ANDER@ tree-ssa-dce.o  tree-ssa-copy.o tree-nrv.o tree-ssa-copyrename.o  \\\n  tree-ssa-pre.o tree-ssa-live.o tree-ssa-operands.o tree-ssa-alias.o       \\\n  tree-ssa-phiopt.o tree-ssa-forwprop.o tree-nested.o tree-ssa-dse.o\t   \\\n@@ -1640,9 +1640,12 @@ tree-ssa-copyrename.o : tree-ssa-copyrename.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    diagnostic.h errors.h toplev.h function.h $(TIMEVAR_H) tree-pass.h \\\n    tree-alias-common.h $(TM_H) coretypes.h $(TREE_DUMP_H) $(TREE_SSA_LIVE_H)\n tree-ssa-pre.o : tree-ssa-pre.c $(TREE_FLOW_H) $(CONFIG_H) \\\n-   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) \\\n+   $(SYSTEM_H) $(TREE_H) $(TM_P_H) $(EXPR_H) \\\n    $(GGC_H) output.h diagnostic.h errors.h toplev.h $(TIMEVAR_H) \\\n    $(TM_H) coretypes.h $(TREE_DUMP_H) tree-pass.h $(FLAGS_H)\n+tree-vn.o : tree-vn.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(GGC_H) \\\n+   $(TREE_H) $(TREE_FLOW_H) $(HASHTAB_H) langhooks.h tree-pass.h \\\n+   $(TREE_DUMP_H) diagnostic.h\n tree-cfg.o : tree-cfg.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) $(FLAGS_H) output.h \\\n    diagnostic.h errors.h function.h $(TIMEVAR_H) $(TM_H) coretypes.h \\\n@@ -3068,6 +3071,7 @@ distclean: clean lang.distclean\n \t-rm -f fixinc/Makefile\n # Delete po/*.gmo only if we are not building in the source directory.\n \t-if [ ! -f po/exgettext ]; then rm -f po/*.gmo; fi\n+\t-rmdir ada cp f java objc fixinc intl po testsuite 2>/dev/null\n \n # Get rid of every file that's generated from some other file, except for `configure'.\n # Most of these files ARE PRESENT in the GCC distribution."}, {"sha": "bc1f8f5dd44581daf15cdcedd421fe7c8ff6fd91", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c94679bde917193e6af8644598cc85b3df1645/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c94679bde917193e6af8644598cc85b3df1645/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=33c94679bde917193e6af8644598cc85b3df1645", "patch": "@@ -111,10 +111,6 @@ find_referenced_vars (void)\n   struct walk_state walk_state;\n   tree block;\n \n-  /* This is the very first pass in preparation for building the SSA\n-     form of the function, so initialize internal data structures now.  */\n-  init_tree_ssa ();\n-\n   /* Walk the lexical blocks in the function looking for variables that may\n      have been used to declare VLAs and for nested functions.  Both\n      constructs create hidden uses of variables. "}, {"sha": "e18c1e4c48dd11a943992e9a988c5cfd425b9946", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c94679bde917193e6af8644598cc85b3df1645/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c94679bde917193e6af8644598cc85b3df1645/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=33c94679bde917193e6af8644598cc85b3df1645", "patch": "@@ -167,11 +167,6 @@ struct var_ann_d GTY(())\n      live at the same time and this can happen for each call to the\n      dominator optimizer.  */\n   tree current_def;\n-\n-  /* The set of expressions represented by this variable if it is a\n-     value handle.  This is used by GVN-PRE.  */\n-  PTR GTY ((skip)) expr_set;\n-  \n };\n \n \n@@ -576,12 +571,23 @@ extern bool tree_can_throw_internal (tree);\n extern bool tree_can_throw_external (tree);\n extern void add_stmt_to_eh_region (tree, int);\n \n-/* In tree-ssa-pre.c */\n-tree get_value_handle (tree);\n-void set_value_handle (tree, tree);\n+/* In tree-ssa-pre.c  */\n+void add_to_value (tree, tree);\n void debug_value_expressions (tree);\n void print_value_expressions (FILE *, tree);\n \n+\n+/* In tree-vn.c  */\n+bool expressions_equal_p (tree e1, tree e2);\n+tree get_value_handle (tree);\n+hashval_t vn_compute (tree, hashval_t);\n+tree vn_lookup_or_add (tree);\n+void vn_add (tree, tree);\n+tree vn_lookup (tree);\n+void vn_init (void);\n+void vn_delete (void);\n+\n+\n /* In tree-sra.c  */\n void insert_edge_copies (tree stmt, basic_block bb);\n "}, {"sha": "a9217b187c4201d4016a4906c2620a0782f66658", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c94679bde917193e6af8644598cc85b3df1645/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c94679bde917193e6af8644598cc85b3df1645/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=33c94679bde917193e6af8644598cc85b3df1645", "patch": "@@ -153,6 +153,33 @@ static struct tree_opt_pass pass_free_datastructures =\n   0\t\t\t\t\t/* todo_flags_finish */\n };\n \n+\n+/* Do the actions required to initialize internal data structures used\n+   in tree-ssa optimization passes.  */\n+\n+static void\n+execute_init_datastructures (void)\n+{\n+  /* Allocate hash tables, arrays and other structures.  */\n+  init_tree_ssa ();\n+}\n+\n+static struct tree_opt_pass pass_init_datastructures =\n+{\n+  NULL,\t\t\t\t\t/* name */\n+  NULL,\t\t\t\t\t/* gate */\n+  execute_init_datastructures,\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  0,\t\t\t\t\t/* tv_id */\n+  PROP_cfg,\t\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  0\t\t\t\t\t/* todo_flags_finish */\n+};\n+\n /* Iterate over the pass tree allocating dump file numbers.  We want\n    to do this depth first, and independent of whether the pass is\n    enabled or not.  */\n@@ -253,6 +280,7 @@ init_tree_optimization_passes (void)\n   NEXT_PASS (pass_lower_eh);\n   NEXT_PASS (pass_build_cfg);\n   NEXT_PASS (pass_tree_profile);\n+  NEXT_PASS (pass_init_datastructures);\n   NEXT_PASS (pass_all_optimizations);\n   NEXT_PASS (pass_mudflap_2);\n   NEXT_PASS (pass_free_datastructures);"}, {"sha": "fe115bc3ca8e644680cf2e507118c5d9057ae217", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c94679bde917193e6af8644598cc85b3df1645/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c94679bde917193e6af8644598cc85b3df1645/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=33c94679bde917193e6af8644598cc85b3df1645", "patch": "@@ -55,8 +55,6 @@ static void dump_generic_bb_buff (pretty_printer *, basic_block, int, int);\n    lang_hooks.decl_printable_name (TREE_OPERAND (NODE, 0), 1) : \\\n    lang_hooks.decl_printable_name (NODE, 1))\n \n-#define MASK_POINTER(P)\t((unsigned)((unsigned long)(P) & 0xffff))\n-\n static pretty_printer buffer;\n static int initialized = 0;\n static bool dumping_stmts;\n@@ -1403,6 +1401,10 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       pp_decimal_int (buffer, SSA_NAME_VERSION (node));\n       break;\n \n+    case VALUE_HANDLE:\n+      pp_printf (buffer, \"VH.%d\", VALUE_HANDLE_ID (node));\n+      break;\n+\n     default:\n       NIY;\n     }"}, {"sha": "5c32bc2878775147e98d6a0b5c1ecea52ae91f28", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 60, "deletions": 262, "changes": 322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c94679bde917193e6af8644598cc85b3df1645/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c94679bde917193e6af8644598cc85b3df1645/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=33c94679bde917193e6af8644598cc85b3df1645", "patch": "@@ -19,18 +19,14 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n+\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"errors.h\"\n #include \"ggc.h\"\n #include \"tree.h\"\n-\n-/* These RTL headers are needed for basic-block.h.  */\n-#include \"rtl.h\"\n-#include \"tm_p.h\"\n-#include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n #include \"diagnostic.h\"\n #include \"tree-inline.h\"\n@@ -48,6 +44,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"splay-tree.h\"\n #include \"bitmap.h\"\n #include \"langhooks.h\"\n+\n /* TODO:\n    \n    1. Implement load value numbering.\n@@ -279,10 +276,8 @@ static struct\n static tree find_leader (value_set_t, tree);\n static void value_insert_into_set (value_set_t, tree);\n static void insert_into_set (value_set_t, tree);\n-static void add_to_value (tree, tree);\n static value_set_t set_new  (bool);\n static bool is_undefined_value (tree);\n-static bool expressions_equal_p (tree, tree);\n static tree create_expression_by_pieces (basic_block, tree, tree);\n \n /* We can add and remove elements and entries to and from sets\n@@ -293,117 +288,12 @@ static alloc_pool value_set_node_pool;\n static alloc_pool binary_node_pool;\n static alloc_pool unary_node_pool;\n \n-/* The value table that maps expressions to values.  */\n-\n-static htab_t value_table;\n \n /* The phi_translate_table caches phi translations for a given\n    expression and predecessor.  */\n \n static htab_t phi_translate_table;\n \n-/* Compare two expressions E1 and E2 and return true if they are\n-   equal.  */\n-\n-static bool\n-expressions_equal_p (tree e1, tree e2)\n-{\n-  tree te1, te2;\n-  \n-  if (e1 == e2)\n-    return true;\n-  \n-  te1 = TREE_TYPE (e1);\n-  te2 = TREE_TYPE (e2);\n-\n-  if (TREE_CODE (e1) == TREE_CODE (e2) \n-      && (te1 == te2 || lang_hooks.types_compatible_p (te1, te2))\n-      && operand_equal_p (e1, e2, 0))\n-    return true;\n-  return false;\n-}\n-\n-/* Map expressions to values.  These are simple pairs of expressions\n-   and the values they represent.  To find the value represented by\n-   an expression, we use a hash table where the elements are {e,v}\n-   pairs, and the expression is the key.  */\n-\n-typedef struct val_expr_pair_d\n-{\n-  tree v, e;\n-  hashval_t hashcode;\n-} *val_expr_pair_t;\n-\n-\n-/* Hash a {v,e} pair that is pointed to by P.\n-   The hashcode is cached in the val_expr_pair, so we just return\n-   that.  */\n-\n-static hashval_t\n-val_expr_pair_hash (const void *p)\n-{\n-  const val_expr_pair_t ve = (val_expr_pair_t) p;\n-  return ve->hashcode;\n-}\n-\n-\n-/* Given two val_expr_pair_t's, return true if they represent the same\n-   expression, false otherwise.\n-   P1 and P2 should point to the val_expr_pair_t's to be compared.  */\n-\n-static int\n-val_expr_pair_expr_eq (const void *p1, const void *p2)\n-{\n-  const val_expr_pair_t ve1 = (val_expr_pair_t) p1;\n-  const val_expr_pair_t ve2 = (val_expr_pair_t) p2;\n-\n-  if (expressions_equal_p (ve1->e, ve2->e))\n-    return true;\n-  \n-  return false;\n-}\n-\n-\n-/* Get the value handle of EXPR.  This is the only correct way to get\n-   the value handle for a \"thing\". \n-   Returns NULL if the value handle does not exist.  */\n-\n-tree\n-get_value_handle (tree expr)\n-{\n-  /* We should never see these.  */\n-  if (DECL_P (expr))\n-    abort ();\n-  else if (TREE_CODE (expr) == SSA_NAME)\n-    {\n-      return SSA_NAME_VALUE (expr);\n-    }\n-  else if (TREE_CODE_CLASS (TREE_CODE (expr)) == 'c')\n-    return expr;\n-  else if (EXPR_P (expr))\n-    {\n-      tree_ann_t ann = tree_ann (expr);  \n-      if (ann)\n-\treturn ann->common.value_handle;\n-      return NULL;\n-    }\n-  abort ();\n-}\n-\n-\n-/* Set the value handle for expression E to value V */\n-   \n-void\n-set_value_handle (tree e, tree v)\n-{\n-  if (DECL_P (e))\n-    abort ();\n-  else if (TREE_CODE (e) == SSA_NAME)\n-    SSA_NAME_VALUE (e) = v;\n-  else if (EXPR_P (e))\n-    get_tree_ann (e)->common.value_handle = v;\n-}\n-\n /* A three tuple {e, pred, v} used to cache phi translations in the\n    phi_translate_table.  */\n \n@@ -468,7 +358,7 @@ phi_trans_lookup (tree e, basic_block pred)\n   struct expr_pred_trans_d ept;\n   ept.e = e;\n   ept.pred = pred;\n-  ept.hashcode = iterative_hash_expr (e, (unsigned long) pred);\n+  ept.hashcode = vn_compute (e, (unsigned long) pred);\n   slot = htab_find_slot_with_hash (phi_translate_table, &ept, ept.hashcode,\n \t\t\t\t   NO_INSERT);\n   if (!slot)\n@@ -489,39 +379,19 @@ phi_trans_add (tree e, tree v, basic_block pred)\n   new_pair->e = e;\n   new_pair->pred = pred;\n   new_pair->v = v;\n-  new_pair->hashcode = iterative_hash_expr (e, (unsigned long) pred);\n+  new_pair->hashcode = vn_compute (e, (unsigned long) pred);\n   slot = htab_find_slot_with_hash (phi_translate_table, new_pair,\n \t\t\t\t   new_pair->hashcode, INSERT);\n   if (*slot)\n     free (*slot);\n   *slot = (void *) new_pair;\n }\n \n-/* Search in TABLE for an existing instance of expression E,\n-   and return its value, or NULL if none has been set.  */\n-\n-static inline tree\n-lookup (htab_t table, tree e)\n-{\n-  void **slot;\n-  struct val_expr_pair_d vep = {NULL, NULL, 0};\n-  if (TREE_CODE_CLASS (TREE_CODE (e)) == 'c')\n-    return e;\n-  vep.e = e;\n-  vep.hashcode = iterative_hash_expr (e,0); \n-  slot = htab_find_slot_with_hash (table, &vep, vep.hashcode, NO_INSERT);\n-  if (!slot)\n-    return NULL_TREE;\n-  else\n-    return ((val_expr_pair_t) *slot)->v;\n-}\n-\n /* Add expression E to the expression set of value V.  */\n \n-static inline void\n+void\n add_to_value (tree v, tree e)\n {\n-  var_ann_t va;\n   /* For values representing non-CST nodes, but still function\n      invariant things we mark TREE_CONSTANT as true and set the tree\n      chain to the actual constant.  This is because unlike values\n@@ -536,106 +406,40 @@ add_to_value (tree v, tree e)\n       TREE_CHAIN (v) = e;\n       return;\n     }\n-  va = var_ann (v);\n-  if (va->expr_set == NULL)\n-    va->expr_set = set_new (false);\n-  insert_into_set (va->expr_set, e);\n-}\n-\n-/* Insert E into TABLE with value V, and add expression E to the value\n-   set for value V.  */\n-\n-static inline void\n-add (htab_t table, tree e, tree v)\n-{\n-\n-  void **slot;\n-  val_expr_pair_t new_pair = xmalloc (sizeof (struct val_expr_pair_d));\n-  new_pair->e = e;\n-  new_pair->v = v;\n-  new_pair->hashcode = iterative_hash_expr (e, 0);\n-  slot = htab_find_slot_with_hash (table, new_pair, new_pair->hashcode,\n-\t\t\t\t   INSERT);\n-  if (*slot)\n-    free (*slot);\n-  *slot = (void *) new_pair;\n-  set_value_handle (e, v);\n-\n-  add_to_value (v, e);\n- \n-}\n-\n-/* A unique counter that is incremented every time we create a new\n-   value.  */\n-static int pre_uid;\n \n-/* Create a new value handle for expression EXPR.  */\n-\n-static tree\n-create_new_value (tree expr)\n-{\n-  tree a = create_tmp_var_raw (TREE_TYPE (expr), \"value\");\n-  create_var_ann (a);\n-  var_ann (a)->uid = pre_uid++;\n+  if (VALUE_HANDLE_EXPR_SET (v) == NULL)\n+    VALUE_HANDLE_EXPR_SET (v) = set_new (false);\n \n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {     \n-      fprintf (dump_file, \"Created value \");\n-      print_generic_expr (dump_file, a, dump_flags);\n-      fprintf (dump_file, \" for \");\n-      print_generic_expr (dump_file, expr, dump_flags);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-  return a;\n+  insert_into_set (VALUE_HANDLE_EXPR_SET (v), e);\n }\n \n-/* Like lookup, but creates a new value for expression E if E doesn't\n-   already have a value.\n-   Return the existing/created value for E.  */\n-\n-static inline tree\n-lookup_or_add (htab_t table, tree e)\n-{\n-  tree x = lookup (table, e);\n-  if (x == NULL_TREE)\n-    {\n-      tree v;\n-      v = create_new_value (e);\n-      add (table, e, v);\n-      x = v;\n-    }\n-  set_value_handle (e, x);\n-  return x;\n-}\n \n-  \n /* Return true if value V exists in the bitmap for SET.  */\n \n static inline bool\n value_exists_in_set_bitmap (value_set_t set, tree v)\n {\n-  if (TREE_CODE (v) != VAR_DECL)\n-    abort ();\n-\n   if (!set->values)\n     return false;\n-  return bitmap_bit_p (set->values, get_var_ann (v)->uid);\n+\n+  return bitmap_bit_p (set->values, VALUE_HANDLE_ID (v));\n }\n \n+\n /* Remove value V from the bitmap for SET.  */\n \n static void\n value_remove_from_set_bitmap (value_set_t set, tree v)\n {\n-  if (TREE_CODE (v) != VAR_DECL)\n-    abort ();\n #ifdef ENABLE_CHECKING\n   if (!set->indexed)\n     abort ();\n #endif\n+\n   if (!set->values)\n     return;\n-  bitmap_clear_bit (set->values, get_var_ann (v)->uid);\n+\n+  bitmap_clear_bit (set->values, VALUE_HANDLE_ID (v));\n }\n \n \n@@ -645,20 +449,21 @@ value_remove_from_set_bitmap (value_set_t set, tree v)\n static inline void\n value_insert_into_set_bitmap (value_set_t set, tree v)\n {\n-  if (TREE_CODE (v) != VAR_DECL)\n-    abort ();  \n #ifdef ENABLE_CHECKING\n   if (!set->indexed)\n     abort ();\n #endif\n+\n   if (set->values == NULL)\n     {\n       set->values = BITMAP_GGC_ALLOC ();\n       bitmap_clear (set->values);\n     }\n-  bitmap_set_bit (set->values, get_var_ann (v)->uid);\n+\n+  bitmap_set_bit (set->values, VALUE_HANDLE_ID (v));\n }\n \n+\n /* Create a new set.  */\n \n static value_set_t\n@@ -681,8 +486,6 @@ insert_into_set (value_set_t set, tree expr)\n {\n   value_set_node_t newnode = pool_alloc (value_set_node_pool);\n   tree val = get_value_handle (expr);\n-  if (DECL_P (expr))\n-    abort ();\n   \n   if (val == NULL)\n     abort ();\n@@ -873,7 +676,6 @@ value_insert_into_set (value_set_t set, tree expr)\n {\n   tree val = get_value_handle (expr);\n \n-\n   /* Constant and invariant values exist everywhere, and thus,\n      actually keeping them in the sets is pointless.  */\n   if (TREE_CONSTANT (val))\n@@ -913,13 +715,16 @@ print_value_set (FILE *outfile, value_set_t set,\n }\n \n /* Print out the expressions that have VAL to OUTFILE.  */\n+\n void\n print_value_expressions (FILE *outfile, tree val)\n {\n-  var_ann_t va = var_ann (val);\n-  if (va && va->expr_set)\n-    print_value_set (outfile, va->expr_set, \n-\t\t     IDENTIFIER_POINTER (DECL_NAME (val)), 0);\n+  if (VALUE_HANDLE_EXPR_SET (val))\n+    {\n+      char s[10];\n+      sprintf (s, \"VH.%04d\", VALUE_HANDLE_ID (val));\n+      print_value_set (outfile, VALUE_HANDLE_EXPR_SET (val), s, 0);\n+    }\n }\n \n \n@@ -983,7 +788,7 @@ phi_translate (tree expr, value_set_t set,  basic_block pred,\n \t    create_tree_ann (newexpr);\n \t    TREE_OPERAND (newexpr, 0) = newop1 == oldop1 ? oldop1 : get_value_handle (newop1);\n \t    TREE_OPERAND (newexpr, 1) = newop2 == oldop2 ? oldop2 : get_value_handle (newop2);\n-\t    lookup_or_add (value_table, newexpr);\n+\t    vn_lookup_or_add (newexpr);\n \t    expr = newexpr;\n \t    phi_trans_add (oldexpr, newexpr, pred);\t    \n \t  }\n@@ -1010,7 +815,7 @@ phi_translate (tree expr, value_set_t set,  basic_block pred,\n \t    memcpy (newexpr, expr, tree_size (expr));\n \t    create_tree_ann (newexpr);\t \n \t    TREE_OPERAND (newexpr, 0) = get_value_handle (newop1);\n-\t    lookup_or_add (value_table, newexpr);\n+\t    vn_lookup_or_add (newexpr);\n \t    expr = newexpr;\n \t    phi_trans_add (oldexpr, newexpr, pred);\n \t  }\n@@ -1035,7 +840,7 @@ phi_translate (tree expr, value_set_t set,  basic_block pred,\n \t      tree val;\n \t      if (is_undefined_value (PHI_ARG_DEF (phi, i)))\n \t\treturn NULL;\n-\t      val = lookup_or_add (value_table, PHI_ARG_DEF (phi, i));\n+\t      val = vn_lookup_or_add (PHI_ARG_DEF (phi, i));\n \t      return PHI_ARG_DEF (phi, i);\n \t    }\n       }\n@@ -1328,15 +1133,6 @@ compute_antic (void)\n     fprintf (dump_file, \"compute_antic required %d iterations\\n\", num_iterations);\n }\n \n-/* Get the expressions represented by value VAL.  */\n-\n-static value_set_t\n-get_expr_set (tree val)\n-{\n-  var_ann_t va = var_ann (val);\n-  return va->expr_set;\n-}\n-\n \n /* Find a leader for an expression, or generate one using\n    create_expression_by_pieces if it's ANTIC but\n@@ -1364,7 +1160,7 @@ find_or_generate_expression (basic_block block, tree expr, tree stmts)\n      not really .  */\n   if (genop == NULL)\n     {\n-      genop = get_expr_set (expr)->head->expr;\n+      genop = VALUE_HANDLE_EXPR_SET (expr)->head->expr;\n       if (TREE_CODE_CLASS (TREE_CODE (genop)) != '1'\n \t  && TREE_CODE_CLASS (TREE_CODE (genop)) != '2')\n \tabort ();\n@@ -1445,7 +1241,7 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n       \n     }\n   v = get_value_handle (expr);\n-  add (value_table, name, v);\n+  vn_add (name, v);\n   insert_into_set (NEW_SETS (block), name);\n   value_insert_into_set (AVAIL_OUT (block), name);\n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -1610,7 +1406,7 @@ insert_aux (basic_block block)\n \t\t\t  temp = create_tmp_var (type, \"prephitmp\");\n \t\t\t  add_referenced_tmp_var (temp);\n \t\t\t  temp = create_phi_node (temp, block);\n-\t\t\t  add (value_table, PHI_RESULT (temp), val);\n+\t\t\t  vn_add (PHI_RESULT (temp), val);\n \n #if 0\n \t\t\t  if (!set_contains_value (AVAIL_OUT (block), val))\n@@ -1679,17 +1475,19 @@ insert (void)\n     fprintf (dump_file, \"insert required %d iterations\\n\", num_iterations);\n }\n \n+\n /* Return true if EXPR has no defining statement in this procedure,\n    *AND* isn't a live-on-entry parameter.  */\n+\n static bool\n is_undefined_value (tree expr)\n {  \n-  \n #ifdef ENABLE_CHECKING\n   /* We should never be handed DECL's  */\n   if (DECL_P (expr))\n     abort ();\n #endif\n+\n   if (TREE_CODE (expr) == SSA_NAME)\n     {\n       /* XXX: Is this the correct test?  */\n@@ -1698,6 +1496,7 @@ is_undefined_value (tree expr)\n       if (IS_EMPTY_STMT (SSA_NAME_DEF_STMT (expr)))\n \treturn true;\n     }\n+\n   return false;\n }\n \n@@ -1731,7 +1530,7 @@ compute_avail (basic_block block)\n \t    {\n \t      tree val;\n \t      tree def = default_def (param);\n-\t      val = lookup_or_add (value_table, def);\n+\t      val = vn_lookup_or_add (def);\n \t      insert_into_set (TMP_GEN (block), def);\n \t      value_insert_into_set (AVAIL_OUT (block), def);\n \t    }\n@@ -1746,14 +1545,15 @@ compute_avail (basic_block block)\n       dom = get_immediate_dominator (CDI_DOMINATORS, block);\n       if (dom)\n \tset_copy (AVAIL_OUT (block), AVAIL_OUT (dom));\n+\n       for (phi = phi_nodes (block); phi; phi = PHI_CHAIN (phi))\n \t{\n \t  /* Ignore virtual PHIs until we can do PRE on expressions\n \t     with virtual operands.  */\n \t  if (!is_gimple_reg (SSA_NAME_VAR (PHI_RESULT (phi))))\n \t    continue;\n \n-\t  lookup_or_add (value_table, PHI_RESULT (phi));\n+\t  vn_lookup_or_add (PHI_RESULT (phi));\n \t  value_insert_into_set (AVAIL_OUT (block), PHI_RESULT (phi));\n \t  insert_into_set (PHI_GEN (block), PHI_RESULT (phi));\n \t}\n@@ -1773,7 +1573,7 @@ compute_avail (basic_block block)\n \t      for (j = 0; j < NUM_DEFS (STMT_DEF_OPS (stmt)); j++)\n \t\t{\n \t\t  tree def = DEF_OP (STMT_DEF_OPS (stmt), j);\n-\t\t  lookup_or_add (value_table, def);\n+\t\t  vn_lookup_or_add (def);\n \t\t  insert_into_set (TMP_GEN (block), def);\n \t\t  value_insert_into_set (AVAIL_OUT (block), def);\n \t\t}\n@@ -1782,7 +1582,7 @@ compute_avail (basic_block block)\n \t\t  tree use = USE_OP (STMT_USE_OPS (stmt), j);\n \t\t  if (TREE_CODE (use) == SSA_NAME)\n \t\t    {\n-\t\t      lookup_or_add (value_table, use);\n+\t\t      vn_lookup_or_add (use);\n \t\t      insert_into_set (TMP_GEN (block), use);\n \t\t      value_insert_into_set (AVAIL_OUT (block), use);\n \t\t    }\n@@ -1801,7 +1601,7 @@ compute_avail (basic_block block)\n \t      STRIP_USELESS_TYPE_CONVERSION (op1);\n \t      if (is_gimple_min_invariant (op1))\n \t\t{\n-\t\t  add (value_table, op0, lookup_or_add (value_table, op1));\n+\t\t  vn_add (op0, vn_lookup_or_add (op1));\n \t\t  insert_into_set (TMP_GEN (block), op0);\n \t\t  value_insert_into_set (AVAIL_OUT (block), op0);\n \t\t}\n@@ -1812,15 +1612,15 @@ compute_avail (basic_block block)\n \t\t  tree newt;\n \t\t  bop1 = TREE_OPERAND (op1, 0);\n \t\t  bop2 = TREE_OPERAND (op1, 1);\n-\t\t  val1 = lookup_or_add (value_table, bop1);\n-\t\t  val2 = lookup_or_add (value_table, bop2);\n+\t\t  val1 = vn_lookup_or_add (bop1);\n+\t\t  val2 = vn_lookup_or_add (bop2);\n  \n \t\t  newt = pool_alloc (binary_node_pool);\n \t\t  memcpy (newt, op1, tree_size (op1));\n \t\t  TREE_OPERAND (newt, 0) = val1;\n \t\t  TREE_OPERAND (newt, 1) = val2;\n-\t\t  val = lookup_or_add (value_table, newt);\n-\t\t  add (value_table, op0, val);\n+\t\t  val = vn_lookup_or_add (newt);\n+\t\t  vn_add (op0, val);\n \t\t  if (!is_undefined_value (bop1))\n \t\t    value_insert_into_set (EXP_GEN (block), bop1);\n \t\t  if (!is_undefined_value (bop2))\n@@ -1836,12 +1636,12 @@ compute_avail (basic_block block)\n \t\t  tree val, val1;\n \t\t  tree newt;\n \t\t  uop = TREE_OPERAND (op1, 0);\n-\t\t  val1 = lookup_or_add (value_table, uop);\n+\t\t  val1 = vn_lookup_or_add (uop);\n \t\t  newt = pool_alloc (unary_node_pool);\n \t\t  memcpy (newt, op1, tree_size (op1));\n \t\t  TREE_OPERAND (newt, 0) = val1;\n-\t\t  val = lookup_or_add (value_table, newt);\n-\t\t  add (value_table, op0, val);\n+\t\t  val = vn_lookup_or_add (newt);\n+\t\t  vn_add (op0, val);\n \t\t  if (!is_undefined_value (uop))\n \t\t    value_insert_into_set (EXP_GEN (block), uop);\n \t\t  value_insert_into_set (EXP_GEN (block), newt);\n@@ -1850,8 +1650,8 @@ compute_avail (basic_block block)\n \t\t}\n \t      else if (TREE_CODE (op1) == SSA_NAME)\n \t\t{\n-\t\t  tree val = lookup_or_add (value_table, op1);\n-\t\t  add (value_table, op0, val);\n+\t\t  tree val = vn_lookup_or_add (op1);\n+\t\t  vn_add (op0, val);\n \t\t  if (!is_undefined_value (op1))\n \t\t    value_insert_into_set (EXP_GEN (block), op1);\n \t\t  insert_into_set (TMP_GEN (block), op0);\n@@ -1863,7 +1663,7 @@ compute_avail (basic_block block)\n \t\t  for (j = 0; j < NUM_DEFS (STMT_DEF_OPS (stmt)); j++)\n \t\t    {\n \t\t      tree def = DEF_OP (STMT_DEF_OPS (stmt), j);\n-\t\t      lookup_or_add (value_table, def);\n+\t\t      vn_lookup_or_add (def);\n \t\t      insert_into_set (TMP_GEN (block), def);\n \t\t      value_insert_into_set (AVAIL_OUT (block), def);\n \t\t      if (def != op0)\n@@ -1874,7 +1674,7 @@ compute_avail (basic_block block)\n \t\t      tree use = USE_OP (STMT_USE_OPS (stmt), j);\n \t\t      if (TREE_CODE (use) == SSA_NAME)\n \t\t\t{\n-\t\t\t  lookup_or_add (value_table, use);\n+\t\t\t  vn_lookup_or_add (use);\n \t\t\t  insert_into_set (TMP_GEN (block), use);\n \t\t\t  value_insert_into_set (AVAIL_OUT (block), use);\n \t\t\t}\n@@ -1887,7 +1687,7 @@ compute_avail (basic_block block)\n \t      for (j = 0; j < NUM_DEFS (STMT_DEF_OPS (stmt)); j++)\n \t\t{\n \t\t  tree def = DEF_OP (STMT_DEF_OPS (stmt), j);\n-\t\t  lookup_or_add (value_table, def);\n+\t\t  vn_lookup_or_add (def);\n \t\t  insert_into_set (TMP_GEN (block), def);\n \t\t  value_insert_into_set (AVAIL_OUT (block), def);\n \t\t}\n@@ -1896,21 +1696,22 @@ compute_avail (basic_block block)\n \t\t  tree use = USE_OP (STMT_USE_OPS (stmt), j);\n \t\t  if (TREE_CODE (use) == SSA_NAME)\n \t\t    {\n-\t\t      lookup_or_add (value_table, use);\n+\t\t      vn_lookup_or_add (use);\n \t\t      insert_into_set (TMP_GEN (block), use);\n \t\t      value_insert_into_set (AVAIL_OUT (block), use);\n \t\t    }\n \t\t}\n \t    }\n \t}\n     }\n+\n   for (son = first_dom_son (CDI_DOMINATORS, block);\n        son;\n        son = next_dom_son (CDI_DOMINATORS, son))\n     compute_avail (son);\n-\n }\n \n+\n /* Eliminate fully redundant computations.  */\n \n static void\n@@ -1931,6 +1732,7 @@ eliminate (void)\n \t      || NUM_V_MAY_DEFS (STMT_V_MAY_DEF_OPS (stmt))\n \t      || stmt_ann (stmt)->has_volatile_ops)\n             continue;\n+\n           /* Lookup the RHS of the expression, see if we have an\n \t     available computation for it. If so, replace the RHS with\n \t     the available computation.  */\n@@ -1945,8 +1747,8 @@ eliminate (void)\n \t\t  || (TREE_CODE_CLASS (TREE_CODE (expr)) != '2' \n \t\t   && TREE_CODE_CLASS (TREE_CODE (expr)) != '1'))\n \t\tcontinue;\n-\t      sprime = find_leader (AVAIL_OUT (b),\n-\t\t\t\t    lookup (value_table, t));\n+\n+\t      sprime = find_leader (AVAIL_OUT (b), vn_lookup (t));\n               if (sprime \n \t\t  && sprime != t \n \t\t  && may_propagate_copy (sprime, TREE_OPERAND (stmt, 1)))\n@@ -1965,11 +1767,11 @@ eliminate (void)\n                   modify_stmt (stmt);\n                 }\n             }\n-\n         }\n     }\n }\n \n+\n /* Main entry point to the SSA-PRE pass.\n \n    PHASE indicates which dump file from the DUMP_FILES array to use when\n@@ -1980,7 +1782,6 @@ execute_pre (void)\n {\n   size_t tsize;\n   basic_block bb;\n-  pre_uid = num_referenced_vars;\n   memset (&pre_stats, 0, sizeof (pre_stats));\n   FOR_ALL_BB (bb)\n     {\n@@ -1989,8 +1790,6 @@ execute_pre (void)\n   phi_translate_table = htab_create (511, expr_pred_trans_hash,\n \t\t\t\t     expr_pred_trans_eq,\n \t\t\t\t     free);\n-  value_table = htab_create (511, val_expr_pair_hash,\n-\t\t\t     val_expr_pair_expr_eq, free);\n   value_set_pool = create_alloc_pool (\"Value sets\",\n \t\t\t\t      sizeof (struct value_set), 30);\n   value_set_node_pool = create_alloc_pool (\"Value set nodes\",\n@@ -2048,7 +1847,6 @@ execute_pre (void)\n   free_alloc_pool (value_set_node_pool);\n   free_alloc_pool (binary_node_pool);\n   free_alloc_pool (unary_node_pool);\n-  htab_delete (value_table);\n   htab_delete (phi_translate_table);\n   \n   FOR_ALL_BB (bb)"}, {"sha": "91bfaf54cf8f4c73bb83b52eda0334338447514a", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c94679bde917193e6af8644598cc85b3df1645/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c94679bde917193e6af8644598cc85b3df1645/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=33c94679bde917193e6af8644598cc85b3df1645", "patch": "@@ -497,6 +497,7 @@ init_tree_ssa (void)\n   init_ssa_operands ();\n   init_ssanames ();\n   init_phinodes ();\n+  vn_init ();\n   global_var = NULL_TREE;\n   aliases_computed_p = false;\n }\n@@ -527,6 +528,7 @@ delete_tree_ssa (void)\n   fini_ssanames ();\n   fini_phinodes ();\n   fini_ssa_operands ();\n+  vn_delete ();\n \n   global_var = NULL_TREE;\n   BITMAP_XFREE (call_clobbered_vars);"}, {"sha": "de4c361feb8207393199c6f73ddc6145a41e76aa", "filename": "gcc/tree-vn.c", "status": "added", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c94679bde917193e6af8644598cc85b3df1645/gcc%2Ftree-vn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c94679bde917193e6af8644598cc85b3df1645/gcc%2Ftree-vn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vn.c?ref=33c94679bde917193e6af8644598cc85b3df1645", "patch": "@@ -0,0 +1,257 @@\n+/* Value Numbering routines for tree expressions.\n+   Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n+   Contributed by Daniel Berlin <dan@dberlin.org>, Steven Bosscher\n+   <stevenb@suse.de> and Diego Novillo <dnovillo@redhat.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"ggc.h\"\n+#include \"tree.h\"\n+#include \"tree-flow.h\"\n+#include \"hashtab.h\"\n+#include \"langhooks.h\"\n+#include \"tree-pass.h\"\n+#include \"tree-dump.h\"\n+#include \"diagnostic.h\"\n+\n+/* The value table that maps expressions to values.  */\n+static htab_t value_table;\n+\n+/* Map expressions to values.  These are simple pairs of expressions\n+   and the values they represent.  To find the value represented by\n+   an expression, we use a hash table where the elements are {e,v}\n+   pairs, and the expression is the key.  */\n+typedef struct val_expr_pair_d\n+{\n+  tree v, e;\n+  hashval_t hashcode;\n+} *val_expr_pair_t;\n+\n+static void set_value_handle (tree e, tree v);\n+\n+\n+/* Create and return a new value handle node of type TYPE.  */\n+\n+static tree\n+make_value_handle (tree type)\n+{\n+  static unsigned int id = 0;\n+  tree vh;\n+\n+  vh = build0 (VALUE_HANDLE, type);\n+  VALUE_HANDLE_ID (vh) = id++;\n+  return vh;\n+}\n+\n+\n+/* Given an expression or statement P, compute a hash value number using the\n+   code of the expression and its real operands.  */\n+\n+hashval_t\n+vn_compute (tree expr, hashval_t val)\n+{\n+  val = iterative_hash_expr (expr, val);\n+  return val;\n+}\n+\n+\n+/* Compare two expressions E1 and E2 and return true if they are\n+   equal.  */\n+\n+bool\n+expressions_equal_p (tree e1, tree e2)\n+{\n+  tree te1, te2;\n+  \n+  if (e1 == e2)\n+    return true;\n+\n+  te1 = TREE_TYPE (e1);\n+  te2 = TREE_TYPE (e2);\n+\n+  if (TREE_CODE (e1) == TREE_CODE (e2) \n+      && (te1 == te2 || lang_hooks.types_compatible_p (te1, te2))\n+      && operand_equal_p (e1, e2, 0))\n+    return true;\n+\n+  return false;\n+}\n+\n+\n+/* Hash a {v,e} pair that is pointed to by P.\n+   The hashcode is cached in the val_expr_pair, so we just return\n+   that.  */\n+\n+static hashval_t\n+val_expr_pair_hash (const void *p)\n+{\n+  const val_expr_pair_t ve = (val_expr_pair_t) p;\n+  return ve->hashcode;\n+}\n+\n+\n+/* Given two val_expr_pair_t's, return true if they represent the same\n+   expression, false otherwise.\n+   P1 and P2 should point to the val_expr_pair_t's to be compared.  */\n+\n+static int\n+val_expr_pair_expr_eq (const void *p1, const void *p2)\n+{\n+  const val_expr_pair_t ve1 = (val_expr_pair_t) p1;\n+  const val_expr_pair_t ve2 = (val_expr_pair_t) p2;\n+\n+  if (expressions_equal_p (ve1->e, ve2->e))\n+    return true;\n+  \n+  return false;\n+}\n+\n+\n+/* Set the value handle for expression E to value V */\n+   \n+static void\n+set_value_handle (tree e, tree v)\n+{\n+  if (TREE_CODE (e) == SSA_NAME)\n+    SSA_NAME_VALUE (e) = v;\n+  else if (EXPR_P (e) || DECL_P (e))\n+    get_tree_ann (e)->common.value_handle = v;\n+  else if (TREE_CODE_CLASS (TREE_CODE (e)) == 'c')\n+    /* Do nothing.  Constants are their own value handles.  */\n+    ;\n+  else\n+    abort ();\n+}\n+\n+\n+/* Insert E into VALUE_TABLE with value V, and add expression E to the\n+   value set for value V.  */\n+\n+void\n+vn_add (tree e, tree v)\n+{\n+  void **slot;\n+  val_expr_pair_t new_pair = xmalloc (sizeof (struct val_expr_pair_d));\n+  new_pair->e = e;\n+  new_pair->v = v;\n+  new_pair->hashcode = vn_compute (e, 0);\n+  slot = htab_find_slot_with_hash (value_table, new_pair, new_pair->hashcode,\n+\t\t\t\t   INSERT);\n+  if (*slot)\n+    free (*slot);\n+  *slot = (void *) new_pair;\n+  set_value_handle (e, v);\n+\n+  add_to_value (v, e);\n+}\n+\n+\n+/* Search in VALUE_TABLE for an existing instance of expression E, and\n+   return its value, or NULL if none has been set.  */\n+\n+tree\n+vn_lookup (tree e)\n+{\n+  void **slot;\n+  struct val_expr_pair_d vep = {NULL, NULL, 0};\n+\n+  if (TREE_CODE_CLASS (TREE_CODE (e)) == 'c')\n+    return e;\n+  vep.e = e;\n+  vep.hashcode = vn_compute (e, 0); \n+  slot = htab_find_slot_with_hash (value_table, &vep, vep.hashcode, NO_INSERT);\n+  if (!slot)\n+    return NULL_TREE;\n+  else\n+    return ((val_expr_pair_t) *slot)->v;\n+}\n+\n+\n+/* Like vn_lookup, but creates a new value for expression E if E doesn't\n+   already have a value.  Return the existing/created value for E.  */\n+\n+tree\n+vn_lookup_or_add (tree e)\n+{\n+  tree x = vn_lookup (e);\n+  if (x == NULL_TREE)\n+    {\n+      tree v = make_value_handle (TREE_TYPE (e));\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{     \n+\t  fprintf (dump_file, \"Created value \");\n+\t  print_generic_expr (dump_file, v, dump_flags);\n+\t  fprintf (dump_file, \" for \");\n+\t  print_generic_expr (dump_file, e, dump_flags);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+\n+      vn_add (e, v);\n+      x = v;\n+    }\n+\n+  set_value_handle (e, x);\n+\n+  return x;\n+}\n+\n+\n+/* Get the value handle of EXPR.  This is the only correct way to get\n+   the value handle for a \"thing\".  If EXPR does not have a value\n+   handle associated, it generates and returns a new one.  */\n+\n+tree\n+get_value_handle (tree expr)\n+{\n+  if (TREE_CODE (expr) == SSA_NAME)\n+    return SSA_NAME_VALUE (expr);\n+  else if (TREE_CODE_CLASS (TREE_CODE (expr)) == 'c')\n+    return expr;\n+  else if (EXPR_P (expr) || DECL_P (expr))\n+    {\n+      tree_ann_t ann = tree_ann (expr);\n+      return ((ann) ? ann->common.value_handle : NULL_TREE);\n+    }\n+\n+  abort ();\n+}\n+\n+\n+/* Initialize data structures used in value numbering.  */\n+\n+void\n+vn_init (void)\n+{\n+  value_table = htab_create (511, val_expr_pair_hash,\n+\t\t\t     val_expr_pair_expr_eq, free);\n+}\n+\n+\n+/* Delete data used for value numbering.  */\n+\n+void\n+vn_delete (void)\n+{\n+  htab_delete (value_table);\n+  value_table = NULL;\n+}"}, {"sha": "25431d4495b66a1ef0a4d442d78d0e846839f3d6", "filename": "gcc/tree.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c94679bde917193e6af8644598cc85b3df1645/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c94679bde917193e6af8644598cc85b3df1645/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=33c94679bde917193e6af8644598cc85b3df1645", "patch": "@@ -196,6 +196,7 @@ tree_size (tree node)\n \n \tcase STATEMENT_LIST:\treturn sizeof (struct tree_statement_list);\n \tcase BLOCK:\t\treturn sizeof (struct tree_block);\n+\tcase VALUE_HANDLE:\treturn sizeof (struct tree_value_handle);\n \n \tdefault:\n \t  return lang_hooks.tree_size (code);\n@@ -1497,6 +1498,7 @@ tree_node_structure (tree t)\n     case PLACEHOLDER_EXPR:\treturn TS_COMMON;\n     case STATEMENT_LIST:\treturn TS_STATEMENT_LIST;\n     case BLOCK:\t\t\treturn TS_BLOCK;\n+    case VALUE_HANDLE:\t\treturn TS_VALUE_HANDLE;\n \n     default:\n       abort ();\n@@ -3851,7 +3853,8 @@ iterative_hash_expr (tree t, hashval_t val)\n   code = TREE_CODE (t);\n   class = TREE_CODE_CLASS (code);\n \n-  if (class == 'd')\n+  if (class == 'd'\n+      || TREE_CODE (t) == VALUE_HANDLE)\n     {\n       /* Decls we can just compare by pointer.  */\n       val = iterative_hash_object (t, val);"}, {"sha": "f7dabaf46c8643d21068423bb262b4e435d47d1d", "filename": "gcc/tree.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c94679bde917193e6af8644598cc85b3df1645/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c94679bde917193e6af8644598cc85b3df1645/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=33c94679bde917193e6af8644598cc85b3df1645", "patch": "@@ -899,6 +899,12 @@ DEFTREECODE (EH_FILTER_EXPR, \"eh_filter_expr\", 's', 2)\n    Use the interface in tree-iterator.h to access this node.  */\n DEFTREECODE (STATEMENT_LIST, \"statement_list\", 'x', 0)\n \n+/* Value handles.  Artificial nodes to represent expressions in\n+   partial redundancy elimination (tree-ssa-pre.c).  These nodes are\n+   used for expression canonicalization.  If two expressions compute\n+   the same value, they will be assigned the same value handle.  */\n+DEFTREECODE (VALUE_HANDLE, \"value_handle\", 'x', 0)\n+\n /*\n Local variables:\n mode:c"}, {"sha": "3d3c6f11baa2c8a914024d6f5bde40b9eed3eda9", "filename": "gcc/tree.h", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c94679bde917193e6af8644598cc85b3df1645/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c94679bde917193e6af8644598cc85b3df1645/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=33c94679bde917193e6af8644598cc85b3df1645", "patch": "@@ -2234,6 +2234,28 @@ struct tree_statement_list\n   struct tree_statement_list_node *head;\n   struct tree_statement_list_node *tail;\n };\n+\n+#define VALUE_HANDLE_ID(NODE)\t\t\\\n+  (VALUE_HANDLE_CHECK (NODE)->value_handle.id)\n+\n+#define VALUE_HANDLE_EXPR_SET(NODE)\t\\\n+  (VALUE_HANDLE_CHECK (NODE)->value_handle.expr_set)\n+\n+/* Defined and used in tree-ssa-pre.c.  */\n+struct value_set;\n+\n+struct tree_value_handle GTY(())\n+{\n+  struct tree_common common;\n+\n+  /* The set of expressions represented by this handle.  */\n+  struct value_set * GTY ((skip)) expr_set;\n+\n+  /* Unique ID for this value handle.  IDs are handed out in a\n+     conveniently dense form starting at 0, so that we can make\n+     bitmaps of value handles. */\n+  unsigned int id;\n+};\n \f\n enum tree_node_structure_enum {\n   TS_COMMON,\n@@ -2252,6 +2274,7 @@ enum tree_node_structure_enum {\n   TS_PHI_NODE,\n   TS_BLOCK,\n   TS_STATEMENT_LIST,\n+  TS_VALUE_HANDLE,\n   LAST_TS_ENUM\n };\n \n@@ -2278,6 +2301,7 @@ union tree_node GTY ((ptr_alias (union lang_tree_node),\n   struct tree_phi_node GTY ((tag (\"TS_PHI_NODE\"))) phi;\n   struct tree_block GTY ((tag (\"TS_BLOCK\"))) block;\n   struct tree_statement_list GTY ((tag (\"TS_STATEMENT_LIST\"))) stmt_list;\n+  struct tree_value_handle GTY ((tag (\"TS_VALUE_HANDLE\"))) value_handle;\n };\n \f\n /* Standard named or nameless data types of the C compiler.  */"}]}