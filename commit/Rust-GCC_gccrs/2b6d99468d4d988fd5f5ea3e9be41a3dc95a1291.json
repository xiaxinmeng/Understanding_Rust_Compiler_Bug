{"sha": "2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmI2ZDk5NDY4ZDRkOTg4ZmQ1ZjVlYTNlOWJlNDFhM2RjOTVhMTI5MQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-07-10T17:51:40Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-07-10T18:30:23Z"}, "message": "libgo: update to Go 1.14.4 release\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/241999", "tree": {"sha": "cb989c3bca6130c4649a3cd44041adc4f4b1c2c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb989c3bca6130c4649a3cd44041adc4f4b1c2c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "510125d2272175f47b26227fbe9b8c8c5abfd988", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/510125d2272175f47b26227fbe9b8c8c5abfd988", "html_url": "https://github.com/Rust-GCC/gccrs/commit/510125d2272175f47b26227fbe9b8c8c5abfd988"}], "stats": {"total": 491, "additions": 409, "deletions": 82}, "files": [{"sha": "64b13f410e083bb46dfdd85b48d14d902506cb07", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291", "patch": "@@ -1,4 +1,4 @@\n-30674246ef60ab74566a21f362a7de7a09b99955\n+2ad0970e9da95024110cd3244e9e21313af70a5f\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "07547d064a1c40798fd68d70a2e161d360c346c1", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291", "patch": "@@ -1,4 +1,4 @@\n-96745b980cfde139e8611772e2bc0c59a8e6cdf7\n+83b181c68bf332ac7948f145f33d128377a09c42\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "d8281a2e9968ae9f816d1e099032b14f43ca0736", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291", "patch": "@@ -1 +1 @@\n-go1.14.2\n+go1.14.4"}, {"sha": "e38972913be2df18324e6704b85e0807d3fbb0c1", "filename": "libgo/go/cmd/cgo/gcc.go", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go?ref=2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291", "patch": "@@ -2082,6 +2082,10 @@ var goIdent = make(map[string]*ast.Ident)\n // that may contain a pointer. This is used for cgo pointer checking.\n var unionWithPointer = make(map[ast.Expr]bool)\n \n+// anonymousStructTag provides a consistent tag for an anonymous struct.\n+// The same dwarf.StructType pointer will always get the same tag.\n+var anonymousStructTag = make(map[*dwarf.StructType]string)\n+\n func (c *typeConv) Init(ptrSize, intSize int64) {\n \tc.ptrSize = ptrSize\n \tc.intSize = intSize\n@@ -2430,8 +2434,12 @@ func (c *typeConv) loadType(dtype dwarf.Type, pos token.Pos, parent string) *Typ\n \t\t\tbreak\n \t\t}\n \t\tif tag == \"\" {\n-\t\t\ttag = \"__\" + strconv.Itoa(tagGen)\n-\t\t\ttagGen++\n+\t\t\ttag = anonymousStructTag[dt]\n+\t\t\tif tag == \"\" {\n+\t\t\t\ttag = \"__\" + strconv.Itoa(tagGen)\n+\t\t\t\ttagGen++\n+\t\t\t\tanonymousStructTag[dt] = tag\n+\t\t\t}\n \t\t} else if t.C.Empty() {\n \t\t\tt.C.Set(dt.Kind + \" \" + tag)\n \t\t}"}, {"sha": "b60e2bb0b2c4dbee63f3a4d7e59c7cb03550abe3", "filename": "libgo/go/encoding/json/decode.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go?ref=2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291", "patch": "@@ -1217,6 +1217,11 @@ func (d *decodeState) unquoteBytes(s []byte) (t []byte, ok bool) {\n \tif r == -1 {\n \t\treturn s, true\n \t}\n+\t// Only perform up to one safe unquote for each re-scanned string\n+\t// literal. In some edge cases, the decoder unquotes a literal a second\n+\t// time, even after another literal has been re-scanned. Thus, only the\n+\t// first unquote can safely use safeUnquote.\n+\td.safeUnquote = 0\n \n \tb := make([]byte, len(s)+2*utf8.UTFMax)\n \tw := copy(b, s[0:r])"}, {"sha": "a49181e9823d378e1eac372281722981678e3ad7", "filename": "libgo/go/encoding/json/decode_test.go", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go?ref=2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291", "patch": "@@ -2419,7 +2419,7 @@ func (m *textUnmarshalerString) UnmarshalText(text []byte) error {\n \treturn nil\n }\n \n-// Test unmarshal to a map, with map key is a user defined type.\n+// Test unmarshal to a map, where the map key is a user defined type.\n // See golang.org/issues/34437.\n func TestUnmarshalMapWithTextUnmarshalerStringKey(t *testing.T) {\n \tvar p map[textUnmarshalerString]string\n@@ -2428,6 +2428,35 @@ func TestUnmarshalMapWithTextUnmarshalerStringKey(t *testing.T) {\n \t}\n \n \tif _, ok := p[\"foo\"]; !ok {\n-\t\tt.Errorf(`Key \"foo\" is not existed in map: %v`, p)\n+\t\tt.Errorf(`Key \"foo\" does not exist in map: %v`, p)\n+\t}\n+}\n+\n+func TestUnmarshalRescanLiteralMangledUnquote(t *testing.T) {\n+\t// See golang.org/issues/38105.\n+\tvar p map[textUnmarshalerString]string\n+\tif err := Unmarshal([]byte(`{\"\u5f00\u6e90\":\"12345\u5f00\u6e90\"}`), &p); err != nil {\n+\t\tt.Fatalf(\"Unmarshal unexpected error: %v\", err)\n+\t}\n+\tif _, ok := p[\"\u5f00\u6e90\"]; !ok {\n+\t\tt.Errorf(`Key \"\u5f00\u6e90\" does not exist in map: %v`, p)\n+\t}\n+\n+\t// See golang.org/issues/38126.\n+\ttype T struct {\n+\t\tF1 string `json:\"F1,string\"`\n+\t}\n+\tt1 := T{\"aaa\\tbbb\"}\n+\n+\tb, err := Marshal(t1)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Marshal unexpected error: %v\", err)\n+\t}\n+\tvar t2 T\n+\tif err := Unmarshal(b, &t2); err != nil {\n+\t\tt.Fatalf(\"Unmarshal unexpected error: %v\", err)\n+\t}\n+\tif t1 != t2 {\n+\t\tt.Errorf(\"Marshal and Unmarshal roundtrip mismatch: want %q got %q\", t1, t2)\n \t}\n }"}, {"sha": "b351cf3f4499acc029a824270d096915bda58c1f", "filename": "libgo/go/encoding/json/encode.go", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go?ref=2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291", "patch": "@@ -635,11 +635,12 @@ func stringEncoder(e *encodeState, v reflect.Value, opts encOpts) {\n \t\treturn\n \t}\n \tif opts.quoted {\n-\t\tb := make([]byte, 0, v.Len()+2)\n-\t\tb = append(b, '\"')\n-\t\tb = append(b, []byte(v.String())...)\n-\t\tb = append(b, '\"')\n-\t\te.stringBytes(b, opts.escapeHTML)\n+\t\te2 := newEncodeState()\n+\t\t// Since we encode the string twice, we only need to escape HTML\n+\t\t// the first time.\n+\t\te2.string(v.String(), opts.escapeHTML)\n+\t\te.stringBytes(e2.Bytes(), false)\n+\t\tencodeStatePool.Put(e2)\n \t} else {\n \t\te.string(v.String(), opts.escapeHTML)\n \t}"}, {"sha": "7290eca06f070769bf46225123ebde9c728294d6", "filename": "libgo/go/encoding/json/encode_test.go", "status": "modified", "additions": 58, "deletions": 29, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2Fgo%2Fencoding%2Fjson%2Fencode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2Fgo%2Fencoding%2Fjson%2Fencode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fencode_test.go?ref=2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291", "patch": "@@ -79,37 +79,66 @@ type StringTag struct {\n \tNumberStr  Number  `json:\",string\"`\n }\n \n-var stringTagExpected = `{\n- \"BoolStr\": \"true\",\n- \"IntStr\": \"42\",\n- \"UintptrStr\": \"44\",\n- \"StrStr\": \"\\\"xzbit\\\"\",\n- \"NumberStr\": \"46\"\n-}`\n-\n-func TestStringTag(t *testing.T) {\n-\tvar s StringTag\n-\ts.BoolStr = true\n-\ts.IntStr = 42\n-\ts.UintptrStr = 44\n-\ts.StrStr = \"xzbit\"\n-\ts.NumberStr = \"46\"\n-\tgot, err := MarshalIndent(&s, \"\", \" \")\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tif got := string(got); got != stringTagExpected {\n-\t\tt.Fatalf(\" got: %s\\nwant: %s\\n\", got, stringTagExpected)\n+func TestRoundtripStringTag(t *testing.T) {\n+\ttests := []struct {\n+\t\tname string\n+\t\tin   StringTag\n+\t\twant string // empty to just test that we roundtrip\n+\t}{\n+\t\t{\n+\t\t\tname: \"AllTypes\",\n+\t\t\tin: StringTag{\n+\t\t\t\tBoolStr:    true,\n+\t\t\t\tIntStr:     42,\n+\t\t\t\tUintptrStr: 44,\n+\t\t\t\tStrStr:     \"xzbit\",\n+\t\t\t\tNumberStr:  \"46\",\n+\t\t\t},\n+\t\t\twant: `{\n+\t\t\t\t\"BoolStr\": \"true\",\n+\t\t\t\t\"IntStr\": \"42\",\n+\t\t\t\t\"UintptrStr\": \"44\",\n+\t\t\t\t\"StrStr\": \"\\\"xzbit\\\"\",\n+\t\t\t\t\"NumberStr\": \"46\"\n+\t\t\t}`,\n+\t\t},\n+\t\t{\n+\t\t\t// See golang.org/issues/38173.\n+\t\t\tname: \"StringDoubleEscapes\",\n+\t\t\tin: StringTag{\n+\t\t\t\tStrStr:    \"\\b\\f\\n\\r\\t\\\"\\\\\",\n+\t\t\t\tNumberStr: \"0\", // just to satisfy the roundtrip\n+\t\t\t},\n+\t\t\twant: `{\n+\t\t\t\t\"BoolStr\": \"false\",\n+\t\t\t\t\"IntStr\": \"0\",\n+\t\t\t\t\"UintptrStr\": \"0\",\n+\t\t\t\t\"StrStr\": \"\\\"\\\\u0008\\\\u000c\\\\n\\\\r\\\\t\\\\\\\"\\\\\\\\\\\"\",\n+\t\t\t\t\"NumberStr\": \"0\"\n+\t\t\t}`,\n+\t\t},\n \t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\t// Indent with a tab prefix to make the multi-line string\n+\t\t\t// literals in the table nicer to read.\n+\t\t\tgot, err := MarshalIndent(&test.in, \"\\t\\t\\t\", \"\\t\")\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\tif got := string(got); got != test.want {\n+\t\t\t\tt.Fatalf(\" got: %s\\nwant: %s\\n\", got, test.want)\n+\t\t\t}\n \n-\t// Verify that it round-trips.\n-\tvar s2 StringTag\n-\terr = NewDecoder(bytes.NewReader(got)).Decode(&s2)\n-\tif err != nil {\n-\t\tt.Fatalf(\"Decode: %v\", err)\n-\t}\n-\tif !reflect.DeepEqual(s, s2) {\n-\t\tt.Fatalf(\"decode didn't match.\\nsource: %#v\\nEncoded as:\\n%s\\ndecode: %#v\", s, string(got), s2)\n+\t\t\t// Verify that it round-trips.\n+\t\t\tvar s2 StringTag\n+\t\t\tif err := Unmarshal(got, &s2); err != nil {\n+\t\t\t\tt.Fatalf(\"Decode: %v\", err)\n+\t\t\t}\n+\t\t\tif !reflect.DeepEqual(test.in, s2) {\n+\t\t\t\tt.Fatalf(\"decode didn't match.\\nsource: %#v\\nEncoded as:\\n%s\\ndecode: %#v\", test.in, string(got), s2)\n+\t\t\t}\n+\t\t})\n \t}\n }\n "}, {"sha": "c9e5334337dff035de49c6621a5aa2ad9c6124b2", "filename": "libgo/go/encoding/json/stream_test.go", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2Fgo%2Fencoding%2Fjson%2Fstream_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2Fgo%2Fencoding%2Fjson%2Fstream_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fstream_test.go?ref=2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291", "patch": "@@ -144,22 +144,24 @@ func TestEncoderSetEscapeHTML(t *testing.T) {\n \t\t},\n \t\t{\n \t\t\t\"stringOption\", stringOption,\n-\t\t\t`{\"bar\":\"\\\"\\u003chtml\\u003efoobar\\u003c/html\\u003e\\\"\"}`,\n+\t\t\t`{\"bar\":\"\\\"\\\\u003chtml\\\\u003efoobar\\\\u003c/html\\\\u003e\\\"\"}`,\n \t\t\t`{\"bar\":\"\\\"<html>foobar</html>\\\"\"}`,\n \t\t},\n \t} {\n \t\tvar buf bytes.Buffer\n \t\tenc := NewEncoder(&buf)\n \t\tif err := enc.Encode(tt.v); err != nil {\n-\t\t\tt.Fatalf(\"Encode(%s): %s\", tt.name, err)\n+\t\t\tt.Errorf(\"Encode(%s): %s\", tt.name, err)\n+\t\t\tcontinue\n \t\t}\n \t\tif got := strings.TrimSpace(buf.String()); got != tt.wantEscape {\n \t\t\tt.Errorf(\"Encode(%s) = %#q, want %#q\", tt.name, got, tt.wantEscape)\n \t\t}\n \t\tbuf.Reset()\n \t\tenc.SetEscapeHTML(false)\n \t\tif err := enc.Encode(tt.v); err != nil {\n-\t\t\tt.Fatalf(\"SetEscapeHTML(false) Encode(%s): %s\", tt.name, err)\n+\t\t\tt.Errorf(\"SetEscapeHTML(false) Encode(%s): %s\", tt.name, err)\n+\t\t\tcontinue\n \t\t}\n \t\tif got := strings.TrimSpace(buf.String()); got != tt.want {\n \t\t\tt.Errorf(\"SetEscapeHTML(false) Encode(%s) = %#q, want %#q\","}, {"sha": "ebf81189b5b283732b39cdb8de483416e602312f", "filename": "libgo/go/go/doc/example.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2Fgo%2Fgo%2Fdoc%2Fexample.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2Fgo%2Fgo%2Fdoc%2Fexample.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fexample.go?ref=2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291", "patch": "@@ -62,9 +62,6 @@ func Examples(testFiles ...*ast.File) []*Example {\n \t\t\tif !ok || f.Recv != nil {\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\tif params := f.Type.Params; len(params.List) != 0 {\n-\t\t\t\tcontinue // function has params; not a valid example\n-\t\t\t}\n \t\t\tnumDecl++\n \t\t\tname := f.Name.Name\n \t\t\tif isTest(name, \"Test\") || isTest(name, \"Benchmark\") {\n@@ -74,6 +71,9 @@ func Examples(testFiles ...*ast.File) []*Example {\n \t\t\tif !isTest(name, \"Example\") {\n \t\t\t\tcontinue\n \t\t\t}\n+\t\t\tif params := f.Type.Params; len(params.List) != 0 {\n+\t\t\t\tcontinue // function has params; not a valid example\n+\t\t\t}\n \t\t\tif f.Body == nil { // ast.File.Body nil dereference (see issue 28044)\n \t\t\t\tcontinue\n \t\t\t}"}, {"sha": "32db3cd7da7b6c702d179d3debb32fc0945758e3", "filename": "libgo/go/go/doc/example_test.go", "status": "modified", "additions": 58, "deletions": 18, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2Fgo%2Fgo%2Fdoc%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2Fgo%2Fgo%2Fdoc%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fexample_test.go?ref=2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291", "patch": "@@ -331,25 +331,65 @@ func main() {\n }\n `\n \n+const exampleWholeFileFunction = `package foo_test\n+\n+func Foo(x int) {\n+}\n+\n+func Example() {\n+\tfmt.Println(\"Hello, world!\")\n+\t// Output: Hello, world!\n+}\n+`\n+\n+const exampleWholeFileFunctionOutput = `package main\n+\n+func Foo(x int) {\n+}\n+\n+func main() {\n+\tfmt.Println(\"Hello, world!\")\n+}\n+`\n+\n+var exampleWholeFileTestCases = []struct {\n+\tTitle, Source, Play, Output string\n+}{\n+\t{\n+\t\t\"Methods\",\n+\t\texampleWholeFile,\n+\t\texampleWholeFileOutput,\n+\t\t\"Hello, world!\\n\",\n+\t},\n+\t{\n+\t\t\"Function\",\n+\t\texampleWholeFileFunction,\n+\t\texampleWholeFileFunctionOutput,\n+\t\t\"Hello, world!\\n\",\n+\t},\n+}\n+\n func TestExamplesWholeFile(t *testing.T) {\n-\tfset := token.NewFileSet()\n-\tfile, err := parser.ParseFile(fset, \"test.go\", strings.NewReader(exampleWholeFile), parser.ParseComments)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tes := doc.Examples(file)\n-\tif len(es) != 1 {\n-\t\tt.Fatalf(\"wrong number of examples; got %d want 1\", len(es))\n-\t}\n-\te := es[0]\n-\tif e.Name != \"\" {\n-\t\tt.Errorf(\"got Name == %q, want %q\", e.Name, \"\")\n-\t}\n-\tif g, w := formatFile(t, fset, e.Play), exampleWholeFileOutput; g != w {\n-\t\tt.Errorf(\"got Play == %q, want %q\", g, w)\n-\t}\n-\tif g, w := e.Output, \"Hello, world!\\n\"; g != w {\n-\t\tt.Errorf(\"got Output == %q, want %q\", g, w)\n+\tfor _, c := range exampleWholeFileTestCases {\n+\t\tfset := token.NewFileSet()\n+\t\tfile, err := parser.ParseFile(fset, \"test.go\", strings.NewReader(c.Source), parser.ParseComments)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tes := doc.Examples(file)\n+\t\tif len(es) != 1 {\n+\t\t\tt.Fatalf(\"%s: wrong number of examples; got %d want 1\", c.Title, len(es))\n+\t\t}\n+\t\te := es[0]\n+\t\tif e.Name != \"\" {\n+\t\t\tt.Errorf(\"%s: got Name == %q, want %q\", c.Title, e.Name, \"\")\n+\t\t}\n+\t\tif g, w := formatFile(t, fset, e.Play), c.Play; g != w {\n+\t\t\tt.Errorf(\"%s: got Play == %q, want %q\", c.Title, g, w)\n+\t\t}\n+\t\tif g, w := e.Output, c.Output; g != w {\n+\t\t\tt.Errorf(\"%s: got Output == %q, want %q\", c.Title, g, w)\n+\t\t}\n \t}\n }\n "}, {"sha": "54f9d7b80ac9a6a1c364514c498866694398db0c", "filename": "libgo/go/go/parser/interface.go", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go?ref=2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291", "patch": "@@ -133,13 +133,7 @@ func ParseFile(fset *token.FileSet, filename string, src interface{}, mode Mode)\n // first error encountered are returned.\n //\n func ParseDir(fset *token.FileSet, path string, filter func(os.FileInfo) bool, mode Mode) (pkgs map[string]*ast.Package, first error) {\n-\tfd, err := os.Open(path)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tdefer fd.Close()\n-\n-\tlist, err := fd.Readdir(-1)\n+\tlist, err := ioutil.ReadDir(path)\n \tif err != nil {\n \t\treturn nil, err\n \t}"}, {"sha": "c31ec5156b81d8830b189245be2b399c6f8d6e2b", "filename": "libgo/go/math/big/nat.go", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2Fgo%2Fmath%2Fbig%2Fnat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2Fgo%2Fmath%2Fbig%2Fnat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fnat.go?ref=2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291", "patch": "@@ -740,7 +740,8 @@ func (z nat) divLarge(u, uIn, vIn nat) (q, r nat) {\n // The remainder overwrites input u.\n //\n // Precondition:\n-// - len(q) >= len(u)-len(v)\n+// - q is large enough to hold the quotient u / v\n+//   which has a maximum length of len(u)-len(v)+1.\n func (q nat) divBasic(u, v nat) {\n \tn := len(v)\n \tm := len(u) - n\n@@ -779,6 +780,8 @@ func (q nat) divBasic(u, v nat) {\n \t\t}\n \n \t\t// D4.\n+\t\t// Compute the remainder u - (q\u0302*v) << (_W*j).\n+\t\t// The subtraction may overflow if q\u0302 estimate was off by one.\n \t\tqhatv[n] = mulAddVWW(qhatv[0:n], v, qhat, 0)\n \t\tqhl := len(qhatv)\n \t\tif j+qhl > len(u) && qhatv[n] == 0 {\n@@ -787,7 +790,11 @@ func (q nat) divBasic(u, v nat) {\n \t\tc := subVV(u[j:j+qhl], u[j:], qhatv)\n \t\tif c != 0 {\n \t\t\tc := addVV(u[j:j+n], u[j:], v)\n-\t\t\tu[j+n] += c\n+\t\t\t// If n == qhl, the carry from subVV and the carry from addVV\n+\t\t\t// cancel out and don't affect u[j+n].\n+\t\t\tif n < qhl {\n+\t\t\t\tu[j+n] += c\n+\t\t\t}\n \t\t\tqhat--\n \t\t}\n \n@@ -827,6 +834,10 @@ func (z nat) divRecursive(u, v nat) {\n \tputNat(tmp)\n }\n \n+// divRecursiveStep computes the division of u by v.\n+// - z must be large enough to hold the quotient\n+// - the quotient will overwrite z\n+// - the remainder will overwrite u\n func (z nat) divRecursiveStep(u, v nat, depth int, tmp *nat, temps []*nat) {\n \tu = u.norm()\n \tv = v.norm()"}, {"sha": "89e913fc16ea4954737e316b657aea7a4aa500c1", "filename": "libgo/go/math/big/nat_test.go", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2Fgo%2Fmath%2Fbig%2Fnat_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2Fgo%2Fmath%2Fbig%2Fnat_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fnat_test.go?ref=2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291", "patch": "@@ -786,3 +786,21 @@ func TestNatDiv(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+// TestIssue37499 triggers the edge case of divBasic where\n+// the inaccurate estimate of the first word's quotient\n+// happens at the very beginning of the loop.\n+func TestIssue37499(t *testing.T) {\n+\t// Choose u and v such that v is slightly larger than u >> N.\n+\t// This tricks divBasic into choosing 1 as the first word\n+\t// of the quotient. This works in both 32-bit and 64-bit settings.\n+\tu := natFromString(\"0x2b6c385a05be027f5c22005b63c42a1165b79ff510e1706b39f8489c1d28e57bb5ba4ef9fd9387a3e344402c0a453381\")\n+\tv := natFromString(\"0x2b6c385a05be027f5c22005b63c42a1165b79ff510e1706c\")\n+\n+\tq := nat(nil).make(8)\n+\tq.divBasic(u, v)\n+\tq = q.norm()\n+\tif s := string(q.utoa(16)); s != \"fffffffffffffffffffffffffffffffffffffffffffffffb\" {\n+\t\tt.Fatalf(\"incorrect quotient: %s\", s)\n+\t}\n+}"}, {"sha": "8ec6de7c07834496cc164bbe340d280e17e9f6ee", "filename": "libgo/go/os/os_test.go", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2Fgo%2Fos%2Fos_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2Fgo%2Fos%2Fos_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fos_test.go?ref=2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291", "patch": "@@ -2450,3 +2450,38 @@ func TestDirSeek(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+// Test that opening a file does not change its permissions.  Issue 38225.\n+func TestOpenFileKeepsPermissions(t *testing.T) {\n+\tt.Parallel()\n+\tdir, err := ioutil.TempDir(\"\", \"TestOpenFileKeepsPermissions\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer RemoveAll(dir)\n+\tname := filepath.Join(dir, \"x\")\n+\tf, err := Create(name)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif err := f.Close(); err != nil {\n+\t\tt.Error(err)\n+\t}\n+\tf, err = OpenFile(name, O_WRONLY|O_CREATE|O_TRUNC, 0)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif fi, err := f.Stat(); err != nil {\n+\t\tt.Error(err)\n+\t} else if fi.Mode()&0222 == 0 {\n+\t\tt.Errorf(\"f.Stat.Mode after OpenFile is %v, should be writable\", fi.Mode())\n+\t}\n+\tif err := f.Close(); err != nil {\n+\t\tt.Error(err)\n+\t}\n+\tif fi, err := Stat(name); err != nil {\n+\t\tt.Error(err)\n+\t} else if fi.Mode()&0222 == 0 {\n+\t\tt.Errorf(\"Stat after OpenFile is %v, should be writable\", fi.Mode())\n+\t}\n+}"}, {"sha": "aa97cf7d56822abe92917d63df69ed092d528f91", "filename": "libgo/go/runtime/crash_test.go", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2Fgo%2Fruntime%2Fcrash_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2Fgo%2Fruntime%2Fcrash_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fcrash_test.go?ref=2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291", "patch": "@@ -55,6 +55,16 @@ func runTestProg(t *testing.T, binary, name string, env ...string) string {\n \t\tt.Fatal(err)\n \t}\n \n+\treturn runBuiltTestProg(t, exe, name, env...)\n+}\n+\n+func runBuiltTestProg(t *testing.T, exe, name string, env ...string) string {\n+\tif *flagQuick {\n+\t\tt.Skip(\"-quick\")\n+\t}\n+\n+\ttestenv.MustHaveGoBuild(t)\n+\n \tcmd := testenv.CleanCmdEnv(exec.Command(exe, name))\n \tcmd.Env = append(cmd.Env, env...)\n \tif testing.Short() {\n@@ -64,7 +74,7 @@ func runTestProg(t *testing.T, binary, name string, env ...string) string {\n \tcmd.Stdout = &b\n \tcmd.Stderr = &b\n \tif err := cmd.Start(); err != nil {\n-\t\tt.Fatalf(\"starting %s %s: %v\", binary, name, err)\n+\t\tt.Fatalf(\"starting %s %s: %v\", exe, name, err)\n \t}\n \n \t// If the process doesn't complete within 1 minute,\n@@ -92,7 +102,7 @@ func runTestProg(t *testing.T, binary, name string, env ...string) string {\n \t}()\n \n \tif err := cmd.Wait(); err != nil {\n-\t\tt.Logf(\"%s %s exit status: %v\", binary, name, err)\n+\t\tt.Logf(\"%s %s exit status: %v\", exe, name, err)\n \t}\n \tclose(done)\n "}, {"sha": "d4b527c0713deb43686db8ffb8eded2caaf68186", "filename": "libgo/go/runtime/mgcscavenge.go", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2Fgo%2Fruntime%2Fmgcscavenge.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2Fgo%2Fruntime%2Fmgcscavenge.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmgcscavenge.go?ref=2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291", "patch": "@@ -288,6 +288,28 @@ func bgscavenge(c chan int) {\n \t\t\tcontinue\n \t\t}\n \n+\t\tif released < physPageSize {\n+\t\t\t// If this happens, it means that we may have attempted to release part\n+\t\t\t// of a physical page, but the likely effect of that is that it released\n+\t\t\t// the whole physical page, some of which may have still been in-use.\n+\t\t\t// This could lead to memory corruption. Throw.\n+\t\t\tthrow(\"released less than one physical page of memory\")\n+\t\t}\n+\n+\t\t// On some platforms we may see crit as zero if the time it takes to scavenge\n+\t\t// memory is less than the minimum granularity of its clock (e.g. Windows).\n+\t\t// In this case, just assume scavenging takes 10 \u00b5s per regular physical page\n+\t\t// (determined empirically), and conservatively ignore the impact of huge pages\n+\t\t// on timing.\n+\t\t//\n+\t\t// We shouldn't ever see a crit value less than zero unless there's a bug of\n+\t\t// some kind, either on our side or in the platform we're running on, but be\n+\t\t// defensive in that case as well.\n+\t\tconst approxCritNSPerPhysicalPage = 10e3\n+\t\tif crit <= 0 {\n+\t\t\tcrit = approxCritNSPerPhysicalPage * float64(released/physPageSize)\n+\t\t}\n+\n \t\t// Multiply the critical time by 1 + the ratio of the costs of using\n \t\t// scavenged memory vs. scavenging memory. This forces us to pay down\n \t\t// the cost of reusing this memory eagerly by sleeping for a longer period"}, {"sha": "a074961840582800b89def8eba11c93205959709", "filename": "libgo/go/runtime/mpagecache.go", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2Fgo%2Fruntime%2Fmpagecache.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2Fgo%2Fruntime%2Fmpagecache.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmpagecache.go?ref=2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291", "patch": "@@ -148,9 +148,14 @@ func (s *pageAlloc) allocToCache() pageCache {\n \t// Update as an allocation, but note that it's not contiguous.\n \ts.update(c.base, pageCachePages, false, true)\n \n-\t// We're always searching for the first free page, and we always know the\n-\t// up to pageCache size bits will be allocated, so we can always move the\n-\t// searchAddr past the cache.\n-\ts.searchAddr = c.base + pageSize*pageCachePages\n+\t// Set the search address to the last page represented by the cache.\n+\t// Since all of the pages in this block are going to the cache, and we\n+\t// searched for the first free page, we can confidently start at the\n+\t// next page.\n+\t//\n+\t// However, s.searchAddr is not allowed to point into unmapped heap memory\n+\t// unless it is maxSearchAddr, so make it the last page as opposed to\n+\t// the page after.\n+\ts.searchAddr = c.base + pageSize*(pageCachePages-1)\n \treturn c\n }"}, {"sha": "2ed0c0aa6a0ba82da5c78a1601514120840b5b0b", "filename": "libgo/go/runtime/mpagecache_test.go", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2Fgo%2Fruntime%2Fmpagecache_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2Fgo%2Fruntime%2Fmpagecache_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmpagecache_test.go?ref=2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291", "patch": "@@ -260,12 +260,13 @@ func TestPageAllocAllocToCache(t *testing.T) {\n \tif GOOS == \"openbsd\" && testing.Short() {\n \t\tt.Skip(\"skipping because virtual memory is limited; see #36210\")\n \t}\n-\ttests := map[string]struct {\n+\ttype test struct {\n \t\tbefore map[ChunkIdx][]BitRange\n \t\tscav   map[ChunkIdx][]BitRange\n \t\thits   []PageCache // expected base addresses and patterns\n \t\tafter  map[ChunkIdx][]BitRange\n-\t}{\n+\t}\n+\ttests := map[string]test{\n \t\t\"AllFree\": {\n \t\t\tbefore: map[ChunkIdx][]BitRange{\n \t\t\t\tBaseChunkIdx: {},\n@@ -349,6 +350,34 @@ func TestPageAllocAllocToCache(t *testing.T) {\n \t\t\t},\n \t\t},\n \t}\n+\tif PageAlloc64Bit != 0 {\n+\t\tconst chunkIdxBigJump = 0x100000 // chunk index offset which translates to O(TiB)\n+\n+\t\t// This test is similar to the one with the same name for\n+\t\t// pageAlloc.alloc and serves the same purpose.\n+\t\t// See mpagealloc_test.go for details.\n+\t\tsumsPerPhysPage := ChunkIdx(PhysPageSize / PallocSumBytes)\n+\t\tbaseChunkIdx := BaseChunkIdx &^ (sumsPerPhysPage - 1)\n+\t\ttests[\"DiscontiguousMappedSumBoundary\"] = test{\n+\t\t\tbefore: map[ChunkIdx][]BitRange{\n+\t\t\t\tbaseChunkIdx + sumsPerPhysPage - 1: {{0, PallocChunkPages - 1}},\n+\t\t\t\tbaseChunkIdx + chunkIdxBigJump:     {{1, PallocChunkPages - 1}},\n+\t\t\t},\n+\t\t\tscav: map[ChunkIdx][]BitRange{\n+\t\t\t\tbaseChunkIdx + sumsPerPhysPage - 1: {},\n+\t\t\t\tbaseChunkIdx + chunkIdxBigJump:     {},\n+\t\t\t},\n+\t\t\thits: []PageCache{\n+\t\t\t\tNewPageCache(PageBase(baseChunkIdx+sumsPerPhysPage-1, PallocChunkPages-64), 1<<63, 0),\n+\t\t\t\tNewPageCache(PageBase(baseChunkIdx+chunkIdxBigJump, 0), 1, 0),\n+\t\t\t\tNewPageCache(0, 0, 0),\n+\t\t\t},\n+\t\t\tafter: map[ChunkIdx][]BitRange{\n+\t\t\t\tbaseChunkIdx + sumsPerPhysPage - 1: {{0, PallocChunkPages}},\n+\t\t\t\tbaseChunkIdx + chunkIdxBigJump:     {{0, PallocChunkPages}},\n+\t\t\t},\n+\t\t}\n+\t}\n \tfor name, v := range tests {\n \t\tv := v\n \t\tt.Run(name, func(t *testing.T) {"}, {"sha": "e0981377512f53dc28a72262d0b5800656309658", "filename": "libgo/go/runtime/proc.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2Fgo%2Fruntime%2Fproc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2Fgo%2Fruntime%2Fproc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fproc.go?ref=2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291", "patch": "@@ -1704,10 +1704,16 @@ func startTemplateThread() {\n \tif GOARCH == \"wasm\" { // no threads on wasm yet\n \t\treturn\n \t}\n+\n+\t// Disable preemption to guarantee that the template thread will be\n+\t// created before a park once haveTemplateThread is set.\n+\tmp := acquirem()\n \tif !atomic.Cas(&newmHandoff.haveTemplateThread, 0, 1) {\n+\t\treleasem(mp)\n \t\treturn\n \t}\n \tnewm(templateThread, nil)\n+\treleasem(mp)\n }\n \n // templateThread is a thread in a known-good state that exists solely"}, {"sha": "5f96d648d986b24dea48e20d0f51cb999a1d4336", "filename": "libgo/go/runtime/proc_test.go", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2Fgo%2Fruntime%2Fproc_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2Fgo%2Fruntime%2Fproc_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fproc_test.go?ref=2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291", "patch": "@@ -6,6 +6,7 @@ package runtime_test\n \n import (\n \t\"fmt\"\n+\t\"internal/testenv\"\n \t\"math\"\n \t\"net\"\n \t\"runtime\"\n@@ -930,6 +931,29 @@ func TestLockOSThreadAvoidsStatePropagation(t *testing.T) {\n \t}\n }\n \n+func TestLockOSThreadTemplateThreadRace(t *testing.T) {\n+\ttestenv.MustHaveGoRun(t)\n+\n+\texe, err := buildTestProg(t, \"testprog\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\titerations := 100\n+\tif testing.Short() {\n+\t\t// Reduce run time to ~100ms, with much lower probability of\n+\t\t// catching issues.\n+\t\titerations = 5\n+\t}\n+\tfor i := 0; i < iterations; i++ {\n+\t\twant := \"OK\\n\"\n+\t\toutput := runBuiltTestProg(t, exe, \"LockOSThreadTemplateThreadRace\")\n+\t\tif output != want {\n+\t\t\tt.Fatalf(\"run %d: want %q, got %q\", i, want, output)\n+\t\t}\n+\t}\n+}\n+\n // fakeSyscall emulates a system call.\n //go:nosplit\n func fakeSyscall(duration time.Duration) {"}, {"sha": "098cc4dd722e659d5d97d0ea6a326d2efc893e8d", "filename": "libgo/go/runtime/testdata/testprog/lockosthread.go", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprog%2Flockosthread.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprog%2Flockosthread.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprog%2Flockosthread.go?ref=2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291", "patch": "@@ -7,6 +7,7 @@ package main\n import (\n \t\"os\"\n \t\"runtime\"\n+\t\"sync\"\n \t\"time\"\n )\n \n@@ -30,6 +31,7 @@ func init() {\n \t\truntime.LockOSThread()\n \t})\n \tregister(\"LockOSThreadAvoidsStatePropagation\", LockOSThreadAvoidsStatePropagation)\n+\tregister(\"LockOSThreadTemplateThreadRace\", LockOSThreadTemplateThreadRace)\n }\n \n func LockOSThreadMain() {\n@@ -195,3 +197,50 @@ func LockOSThreadAvoidsStatePropagation() {\n \truntime.UnlockOSThread()\n \tprintln(\"OK\")\n }\n+\n+func LockOSThreadTemplateThreadRace() {\n+\t// This test attempts to reproduce the race described in\n+\t// golang.org/issue/38931. To do so, we must have a stop-the-world\n+\t// (achieved via ReadMemStats) racing with two LockOSThread calls.\n+\t//\n+\t// While this test attempts to line up the timing, it is only expected\n+\t// to fail (and thus hang) around 2% of the time if the race is\n+\t// present.\n+\n+\t// Ensure enough Ps to actually run everything in parallel. Though on\n+\t// <4 core machines, we are still at the whim of the kernel scheduler.\n+\truntime.GOMAXPROCS(4)\n+\n+\tgo func() {\n+\t\t// Stop the world; race with LockOSThread below.\n+\t\tvar m runtime.MemStats\n+\t\tfor {\n+\t\t\truntime.ReadMemStats(&m)\n+\t\t}\n+\t}()\n+\n+\t// Try to synchronize both LockOSThreads.\n+\tstart := time.Now().Add(10*time.Millisecond)\n+\n+\tvar wg sync.WaitGroup\n+\twg.Add(2)\n+\n+\tfor i := 0; i < 2; i++ {\n+\t\tgo func() {\n+\t\t\tfor time.Now().Before(start) {\n+\t\t\t}\n+\n+\t\t\t// Add work to the local runq to trigger early startm\n+\t\t\t// in handoffp.\n+\t\t\tgo func(){}()\n+\n+\t\t\truntime.LockOSThread()\n+\t\t\truntime.Gosched()  // add a preemption point.\n+\t\t\twg.Done()\n+\t\t}()\n+\t}\n+\n+\twg.Wait()\n+\t// If both LockOSThreads completed then we did not hit the race.\n+\tprintln(\"OK\")\n+}"}, {"sha": "eb9d7fa47d3ecdf70613100fd52850be84da168d", "filename": "libgo/misc/cgo/test/testx.go", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2Fmisc%2Fcgo%2Ftest%2Ftestx.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291/libgo%2Fmisc%2Fcgo%2Ftest%2Ftestx.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Ftestx.go?ref=2b6d99468d4d988fd5f5ea3e9be41a3dc95a1291", "patch": "@@ -124,6 +124,11 @@ typedef struct {\n } Issue31891B;\n \n void callIssue31891(void);\n+\n+typedef struct {\n+\tint i;\n+} Issue38408, *PIssue38408;\n+\n */\n import \"C\"\n \n@@ -552,3 +557,8 @@ func useIssue31891B(c *C.Issue31891B) {}\n func test31891(t *testing.T) {\n \tC.callIssue31891()\n }\n+\n+// issue 38408\n+// A typedef pointer can be used as the element type.\n+// No runtime test; just make sure it compiles.\n+var _ C.PIssue38408 = &C.Issue38408{i: 1}"}]}