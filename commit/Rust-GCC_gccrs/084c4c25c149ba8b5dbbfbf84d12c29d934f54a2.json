{"sha": "084c4c25c149ba8b5dbbfbf84d12c29d934f54a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDg0YzRjMjVjMTQ5YmE4YjVkYmJmYmY4NGQxMmMyOWQ5MzRmNTRhMg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-10-09T11:35:27Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-10-09T11:35:27Z"}, "message": "Update number of shift/reduce conflicts.\n\n({typed_declspecs,reserved_declspecs,declmods}_no_prefix_attr): New.\n(current_declspecs): Initialize to NULL_TREE.\n(fndef): Pass current_declspecs, not $1, to start_function.\n(old_style_parm_decls): Renamed from xdecls.\n(datadecl, declmods): Add references to new rules.\n(setspecs): Call split_specs_attrs.\n(absdcl1): Remove case with setattrs.\n\nFrom-SVN: r12924", "tree": {"sha": "15655027f19b24d8a499337f43d0c691f96ef8d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15655027f19b24d8a499337f43d0c691f96ef8d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/084c4c25c149ba8b5dbbfbf84d12c29d934f54a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/084c4c25c149ba8b5dbbfbf84d12c29d934f54a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/084c4c25c149ba8b5dbbfbf84d12c29d934f54a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/084c4c25c149ba8b5dbbfbf84d12c29d934f54a2/comments", "author": null, "committer": null, "parents": [{"sha": "33aeec285da3a98be09d983bfb82ba16799464e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33aeec285da3a98be09d983bfb82ba16799464e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33aeec285da3a98be09d983bfb82ba16799464e6"}], "stats": {"total": 108, "additions": 82, "deletions": 26}, "files": [{"sha": "09f299cd3c5358363bfcbea35177d532bfdf1090", "filename": "gcc/c-parse.in", "status": "modified", "additions": 82, "deletions": 26, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/084c4c25c149ba8b5dbbfbf84d12c29d934f54a2/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/084c4c25c149ba8b5dbbfbf84d12c29d934f54a2/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=084c4c25c149ba8b5dbbfbf84d12c29d934f54a2", "patch": "@@ -28,10 +28,10 @@ Boston, MA 02111-1307, USA.  */\n    written by AT&T, but I have never seen it.  */\n \n ifobjc\n-%expect 52\n+%expect 66\n end ifobjc\n ifc\n-%expect 34\n+%expect 45 \n \n /* These are the 23 conflicts you should get in parse.output;\n    the state numbers may vary if minor changes in the grammar are made.\n@@ -185,6 +185,8 @@ void yyerror ();\n %type <ttype> typed_declspecs reserved_declspecs\n %type <ttype> typed_typespecs reserved_typespecquals\n %type <ttype> declmods typespec typespecqual_reserved\n+%type <ttype> typed_declspecs_no_prefix_attr reserved_declspecs_no_prefix_attr\n+%type <ttype> declmods_no_prefix_attr\n %type <ttype> SCSPEC TYPESPEC TYPE_QUAL nonempty_type_quals maybe_type_qual\n %type <ttype> initdecls notype_initdecls initdcl notype_initdcl\n %type <ttype> init maybeasm\n@@ -239,7 +241,7 @@ static char *if_stmt_file;\n static int if_stmt_line;\n \n /* List of types and structure classes of the current declaration.  */\n-static tree current_declspecs;\n+static tree current_declspecs = NULL_TREE;\n static tree prefix_attributes = NULL_TREE;\n \n /* Stack of saved values of current_declspecs and prefix_attributes.  */\n@@ -343,11 +345,11 @@ datadef:\n \f\n fndef:\n \t  typed_declspecs setspecs declarator\n-\t\t{ if (! start_function ($1, $3, prefix_attributes,\n-\t\t\t\t\tNULL_TREE, 0))\n+\t\t{ if (! start_function (current_declspecs, $3,\n+\t\t\t\t\tprefix_attributes, NULL_TREE, 0))\n \t\t    YYERROR1;\n \t\t  reinit_parse_for_function (); }\n-\t  xdecls\n+\t  old_style_parm_decls\n \t\t{ store_parm_decls (); }\n \t  compstmt_or_error\n \t\t{ finish_function (0); \n@@ -361,11 +363,11 @@ fndef:\n \t\t  declspec_stack = TREE_CHAIN (declspec_stack);\n \t\t  resume_momentary ($2); }\n \t| declmods setspecs notype_declarator\n-\t\t{ if (! start_function ($1, $3, prefix_attributes,\n-\t\t\t\t\tNULL_TREE, 0))\n+\t\t{ if (! start_function (current_declspecs, $3,\n+\t\t\t\t\tprefix_attributes, NULL_TREE, 0))\n \t\t    YYERROR1;\n \t\t  reinit_parse_for_function (); }\n-\t  xdecls\n+\t  old_style_parm_decls\n \t\t{ store_parm_decls (); }\n \t  compstmt_or_error\n \t\t{ finish_function (0); \n@@ -383,7 +385,7 @@ fndef:\n \t\t\t\t\tprefix_attributes, NULL_TREE, 0))\n \t\t    YYERROR1;\n \t\t  reinit_parse_for_function (); }\n-\t  xdecls\n+\t  old_style_parm_decls\n \t\t{ store_parm_decls (); }\n \t  compstmt_or_error\n \t\t{ finish_function (0); \n@@ -862,7 +864,7 @@ objc_string:\n \t;\n end ifobjc\n \n-xdecls:\n+old_style_parm_decls:\n \t/* empty */\n \t| datadecls\n \t| datadecls ELLIPSIS\n@@ -887,21 +889,25 @@ datadecls:\n \t| lineno_datadecl errstmt\n \t;\n \n+/* We don't allow prefix attributes here because they cause reduce/reduce\n+   conflicts: we can't know whether we're parsing a function decl with\n+   attribute suffix, or function defn with attribute prefix on first old\n+   style parm.  */\n datadecl:\n-\ttyped_declspecs setspecs initdecls ';'\n+\ttyped_declspecs_no_prefix_attr setspecs initdecls ';'\n \t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n \t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n \t\t  declspec_stack = TREE_CHAIN (declspec_stack);\n \t\t  resume_momentary ($2); }\n-\t| declmods setspecs notype_initdecls ';'\n+\t| declmods_no_prefix_attr setspecs notype_initdecls ';'\n \t\t{ current_declspecs = TREE_VALUE (declspec_stack);\t\n \t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n \t\t  declspec_stack = TREE_CHAIN (declspec_stack);\n \t\t  resume_momentary ($2); }\n-\t| typed_declspecs ';'\n+\t| typed_declspecs_no_prefix_attr ';'\n \t\t{ shadow_tag_warned ($1, 1);\n \t\t  pedwarn (\"empty declaration\"); }\n-\t| declmods ';'\n+\t| declmods_no_prefix_attr ';'\n \t\t{ pedwarn (\"empty declaration\"); }\n \t;\n \n@@ -931,10 +937,11 @@ setspecs: /* empty */\n \t\t  declspec_stack = tree_cons (prefix_attributes,\n \t\t\t\t\t      current_declspecs,\n \t\t\t\t\t      declspec_stack);\n-\t\t  current_declspecs = $<ttype>0; \n-\t\t  prefix_attributes = NULL_TREE; }\n+\t\t  split_specs_attrs ($<ttype>0,\n+\t\t\t\t     &current_declspecs, &prefix_attributes); }\n \t;\n \n+/* ??? Yuck.  See after_type_declarator.  */\n setattrs: /* empty */\n \t\t{ prefix_attributes = chainon (prefix_attributes, $<ttype>0); }\n \t;\n@@ -968,7 +975,8 @@ decl:\n \n /* Declspecs which contain at least one type specifier or typedef name.\n    (Just `const' or `volatile' is not enough.)\n-   A typedef'd name following these is taken as a name to be declared.  */\n+   A typedef'd name following these is taken as a name to be declared.\n+   Declspecs have a non-NULL TREE_VALUE, attributes do not.  */\n \n typed_declspecs:\n \t  typespec reserved_declspecs\n@@ -986,22 +994,55 @@ reserved_declspecs:  /* empty */\n \t\t    warning (\"`%s' is not at beginning of declaration\",\n \t\t\t     IDENTIFIER_POINTER ($2));\n \t\t  $$ = tree_cons (NULL_TREE, $2, $1); }\n+\t| reserved_declspecs attributes\n+\t\t{ $$ = tree_cons ($2, NULL_TREE, $1); }\n+\t;\n+\n+typed_declspecs_no_prefix_attr:\n+\t  typespec reserved_declspecs_no_prefix_attr\n+\t\t{ $$ = tree_cons (NULL_TREE, $1, $2); }\n+\t| declmods_no_prefix_attr typespec reserved_declspecs_no_prefix_attr\n+\t\t{ $$ = chainon ($3, tree_cons (NULL_TREE, $2, $1)); }\n+\t;\n+\n+reserved_declspecs_no_prefix_attr:\n+\t  /* empty */\n+\t\t{ $$ = NULL_TREE; }\n+\t| reserved_declspecs_no_prefix_attr typespecqual_reserved\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1); }\n+\t| reserved_declspecs_no_prefix_attr SCSPEC\n+\t\t{ if (extra_warnings)\n+\t\t    warning (\"`%s' is not at beginning of declaration\",\n+\t\t\t     IDENTIFIER_POINTER ($2));\n+\t\t  $$ = tree_cons (NULL_TREE, $2, $1); }\n \t;\n \n-/* List of just storage classes and type modifiers.\n+/* List of just storage classes, type modifiers, and prefix attributes.\n    A declaration can start with just this, but then it cannot be used\n-   to redeclare a typedef-name.  */\n+   to redeclare a typedef-name.\n+   Declspecs have a non-NULL TREE_VALUE, attributes do not.  */\n \n declmods:\n+\t  declmods_no_prefix_attr\n+\t\t{ $$ = $1; }\n+\t| attributes\n+\t\t{ $$ = tree_cons ($1, NULL_TREE, NULL_TREE); }\n+\t| declmods declmods_no_prefix_attr\n+\t\t{ $$ = chainon ($2, $1); }\n+\t| declmods attributes\n+\t\t{ $$ = tree_cons ($2, NULL_TREE, $1); }\n+\t;\n+\n+declmods_no_prefix_attr:\n \t  TYPE_QUAL\n \t\t{ $$ = tree_cons (NULL_TREE, $1, NULL_TREE);\n \t\t  TREE_STATIC ($$) = 1; }\n \t| SCSPEC\n \t\t{ $$ = tree_cons (NULL_TREE, $1, NULL_TREE); }\n-\t| declmods TYPE_QUAL\n+\t| declmods_no_prefix_attr TYPE_QUAL\n \t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n \t\t  TREE_STATIC ($$) = 1; }\n-\t| declmods SCSPEC\n+\t| declmods_no_prefix_attr SCSPEC\n \t\t{ if (extra_warnings && TREE_STATIC ($1))\n \t\t    warning (\"`%s' is not at beginning of declaration\",\n \t\t\t     IDENTIFIER_POINTER ($2));\n@@ -1238,7 +1279,7 @@ nested_function:\n \t\t      YYERROR1;\n \t\t    }\n \t\t  reinit_parse_for_function (); }\n-\t   xdecls\n+\t   old_style_parm_decls\n \t\t{ store_parm_decls (); }\n /* This used to use compstmt_or_error.\n    That caused a bug with input `f(g) int g {}',\n@@ -1261,7 +1302,7 @@ notype_nested_function:\n \t\t      YYERROR1;\n \t\t    }\n \t\t  reinit_parse_for_function (); }\n-\t  xdecls\n+\t  old_style_parm_decls\n \t\t{ store_parm_decls (); }\n /* This used to use compstmt_or_error.\n    That caused a bug with input `f(g) int g {}',\n@@ -1298,6 +1339,11 @@ after_type_declarator:\n \t\t{ $$ = build_nt (ARRAY_REF, $1, NULL_TREE); }\n \t| '*' type_quals after_type_declarator  %prec UNARY\n \t\t{ $$ = make_pointer_declarator ($2, $3); }\n+\t/* ??? Yuck.  setattrs is a quick hack.  We can't use\n+\t   prefix_attributes because $1 only applies to this\n+\t   declarator.  We assume setspecs has already been done.\n+\t   setattrs also avoids 5 reduce/reduce conflicts (otherwise multiple\n+\t   attributes could be recognized here or in `attributes').  */\n \t| attributes setattrs after_type_declarator\n \t\t{ $$ = $3; }\n \t| TYPENAME\n@@ -1323,6 +1369,11 @@ parm_declarator:\n \t\t{ $$ = build_nt (ARRAY_REF, $1, NULL_TREE); }\n \t| '*' type_quals parm_declarator  %prec UNARY\n \t\t{ $$ = make_pointer_declarator ($2, $3); }\n+\t/* ??? Yuck.  setattrs is a quick hack.  We can't use\n+\t   prefix_attributes because $1 only applies to this\n+\t   declarator.  We assume setspecs has already been done.\n+\t   setattrs also avoids 5 reduce/reduce conflicts (otherwise multiple\n+\t   attributes could be recognized here or in `attributes').  */\n \t| attributes setattrs parm_declarator\n \t\t{ $$ = $3; }\n \t| TYPENAME\n@@ -1345,6 +1396,11 @@ notype_declarator:\n \t\t{ $$ = build_nt (ARRAY_REF, $1, $3); }\n \t| notype_declarator '[' ']'  %prec '.'\n \t\t{ $$ = build_nt (ARRAY_REF, $1, NULL_TREE); }\n+\t/* ??? Yuck.  setattrs is a quick hack.  We can't use\n+\t   prefix_attributes because $1 only applies to this\n+\t   declarator.  We assume setspecs has already been done.\n+\t   setattrs also avoids 5 reduce/reduce conflicts (otherwise multiple\n+\t   attributes could be recognized here or in `attributes').  */\n \t| attributes setattrs notype_declarator\n \t\t{ $$ = $3; }\n \t| IDENTIFIER\n@@ -1559,8 +1615,8 @@ absdcl1:  /* a nonempty absolute declarator */\n \t\t{ $$ = build_nt (ARRAY_REF, NULL_TREE, $2); }\n \t| '[' ']'  %prec '.'\n \t\t{ $$ = build_nt (ARRAY_REF, NULL_TREE, NULL_TREE); }\n-\t| attributes setattrs absdcl1\n-\t\t{ $$ = $3; }\n+\t/* ??? It appears we have to support attributes here, however\n+\t   using prefix_attributes is wrong.  */\n \t;\n \n /* at least one statement, the first of which parses without error.  */"}]}