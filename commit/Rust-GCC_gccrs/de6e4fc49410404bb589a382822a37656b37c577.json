{"sha": "de6e4fc49410404bb589a382822a37656b37c577", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGU2ZTRmYzQ5NDEwNDA0YmI1ODlhMzgyODIyYTM3NjU2YjM3YzU3Nw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-01-30T10:35:19Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-01-30T10:35:19Z"}, "message": "[multiple changes]\n\n2012-01-30  Pascal Obry  <obry@adacore.com>\n\n\t* prj.ads, prj.adb (For_Each_Source): Add support for skipping\n\tsources coming from an encapsulated library.\n\n2012-01-30  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb (Process-Full_View): fix typo.\n\t* sem_ch13.adb (Aalyze_Aspect_Specifications): if predicates\n\tappear on a private type and the full view is available, ensure\n\texistence of freeze node for full view.\n\t(Build_Predicate_Function): Attach predicate function to both\n\tviews of a private type.\n\n2012-01-30  Vincent Celier  <celier@adacore.com>\n\n\t* prj-nmsc.adb (Check_Interfaces): Compute the Lib_Interface_ALIs\n\tfor the project if either attribute Library_Interface or\n\tInterfaces is declared.\n\t(Check_Stand_Alone_Library): Use Lib_Interface_ALIs computed in\n\tCheck_Interfaces.\n\nFrom-SVN: r183704", "tree": {"sha": "aea86832d6154b5897072ec342e07628034557e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aea86832d6154b5897072ec342e07628034557e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de6e4fc49410404bb589a382822a37656b37c577", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de6e4fc49410404bb589a382822a37656b37c577", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de6e4fc49410404bb589a382822a37656b37c577", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de6e4fc49410404bb589a382822a37656b37c577/comments", "author": null, "committer": null, "parents": [{"sha": "a76b09dce5542b4eacfe5c0ec495cb708feb2a4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a76b09dce5542b4eacfe5c0ec495cb708feb2a4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a76b09dce5542b4eacfe5c0ec495cb708feb2a4c"}], "stats": {"total": 381, "additions": 179, "deletions": 202}, "files": [{"sha": "cfc585f626e7979e4d3644195b696e903b026ced", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6e4fc49410404bb589a382822a37656b37c577/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6e4fc49410404bb589a382822a37656b37c577/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=de6e4fc49410404bb589a382822a37656b37c577", "patch": "@@ -1,3 +1,25 @@\n+2012-01-30  Pascal Obry  <obry@adacore.com>\n+\n+\t* prj.ads, prj.adb (For_Each_Source): Add support for skipping\n+\tsources coming from an encapsulated library.\n+\n+2012-01-30  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb (Process-Full_View): fix typo.\n+\t* sem_ch13.adb (Aalyze_Aspect_Specifications): if predicates\n+\tappear on a private type and the full view is available, ensure\n+\texistence of freeze node for full view.\n+\t(Build_Predicate_Function): Attach predicate function to both\n+\tviews of a private type.\n+\n+2012-01-30  Vincent Celier  <celier@adacore.com>\n+\n+\t* prj-nmsc.adb (Check_Interfaces): Compute the Lib_Interface_ALIs\n+\tfor the project if either attribute Library_Interface or\n+\tInterfaces is declared.\n+\t(Check_Stand_Alone_Library): Use Lib_Interface_ALIs computed in\n+\tCheck_Interfaces.\n+\n 2012-01-30  Pascal Obry  <obry@adacore.com>\n \n \t* prj-proc.adb (Recursive_Process): Set From_Encapsulated_Lib"}, {"sha": "00cc88ad6e4a319b5a38216e248d79f43aa21cc7", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 107, "deletions": 185, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6e4fc49410404bb589a382822a37656b37c577/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6e4fc49410404bb589a382822a37656b37c577/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=de6e4fc49410404bb589a382822a37656b37c577", "patch": "@@ -2554,6 +2554,8 @@ package body Prj.Nmsc is\n       Project_2 : Project_Id;\n       Other     : Source_Id;\n \n+      Interface_ALIs : String_List_Id := Nil_String;\n+\n    begin\n       if not Interfaces.Default then\n \n@@ -2599,6 +2601,31 @@ package body Prj.Nmsc is\n                            Other.Declared_In_Interfaces := True;\n                         end if;\n \n+                        if Source.Language.Config.Kind = Unit_Based then\n+                           if Source.Kind = Spec\n+                             and then Other_Part (Source) /= No_Source\n+                           then\n+                              Source := Other_Part (Source);\n+                           end if;\n+\n+                           String_Element_Table.Increment_Last\n+                             (Shared.String_Elements);\n+\n+                           Shared.String_Elements.Table\n+                             (String_Element_Table.Last\n+                                (Shared.String_Elements)) :=\n+                             (Value         => Name_Id (Source.Dep_Name),\n+                              Index         => 0,\n+                              Display_Value => Name_Id (Source.Dep_Name),\n+                              Location      => No_Location,\n+                              Flag          => False,\n+                              Next          => Interface_ALIs);\n+\n+                           Interface_ALIs :=\n+                             String_Element_Table.Last\n+                               (Shared.String_Elements);\n+                        end if;\n+\n                         Debug_Output\n                           (\"interface: \", Name_Id (Source.Path.Name));\n                      end if;\n@@ -2627,6 +2654,7 @@ package body Prj.Nmsc is\n          end loop;\n \n          Project.Interfaces_Defined := True;\n+         Project.Lib_Interface_ALIs := Interface_ALIs;\n \n       elsif Project.Library and then not Library_Interface.Default then\n \n@@ -2668,6 +2696,7 @@ package body Prj.Nmsc is\n                      if not Source.Locally_Removed then\n                         Source.In_Interfaces := True;\n                         Source.Declared_In_Interfaces := True;\n+                        Project.Interfaces_Defined := True;\n \n                         Other := Other_Part (Source);\n \n@@ -2678,6 +2707,28 @@ package body Prj.Nmsc is\n \n                         Debug_Output\n                           (\"interface: \", Name_Id (Source.Path.Name));\n+\n+                        if Source.Kind = Spec\n+                          and then Other_Part (Source) /= No_Source\n+                        then\n+                           Source := Other_Part (Source);\n+                        end if;\n+\n+                        String_Element_Table.Increment_Last\n+                          (Shared.String_Elements);\n+\n+                        Shared.String_Elements.Table\n+                          (String_Element_Table.Last\n+                             (Shared.String_Elements)) :=\n+                          (Value         => Name_Id (Source.Dep_Name),\n+                           Index         => 0,\n+                           Display_Value => Name_Id (Source.Dep_Name),\n+                           Location      => No_Location,\n+                           Flag          => False,\n+                           Next          => Interface_ALIs);\n+\n+                        Interface_ALIs :=\n+                          String_Element_Table.Last (Shared.String_Elements);\n                      end if;\n \n                      exit Big_Loop_2;\n@@ -2692,7 +2743,7 @@ package body Prj.Nmsc is\n             List := Element.Next;\n          end loop;\n \n-         Project.Interfaces_Defined := True;\n+         Project.Lib_Interface_ALIs := Interface_ALIs;\n \n       elsif Project.Extends /= No_Project\n         and then Project.Extends.Interfaces_Defined\n@@ -2710,6 +2761,8 @@ package body Prj.Nmsc is\n \n             Next (Iter);\n          end loop;\n+\n+         Project.Lib_Interface_ALIs := Project.Extends.Lib_Interface_ALIs;\n       end if;\n    end Check_Interfaces;\n \n@@ -4282,12 +4335,6 @@ package body Prj.Nmsc is\n                                 Project.Decl.Attributes,\n                                 Shared);\n \n-      Lib_Interfaces      : constant Prj.Variable_Value :=\n-                              Prj.Util.Value_Of\n-                                (Snames.Name_Library_Interface,\n-                                 Project.Decl.Attributes,\n-                                 Shared);\n-\n       Lib_Standalone      : constant Prj.Variable_Value :=\n                               Prj.Util.Value_Of\n                                 (Snames.Name_Library_Standalone,\n@@ -4326,19 +4373,14 @@ package body Prj.Nmsc is\n \n       Auto_Init_Supported : Boolean;\n       OK                  : Boolean := True;\n-      Source              : Source_Id;\n-      Next_Proj           : Project_Id;\n-      Iter                : Source_Iterator;\n \n    begin\n       Auto_Init_Supported := Project.Config.Auto_Init_Supported;\n \n-      pragma Assert (Lib_Interfaces.Kind = List);\n-\n-      --  It is a stand-alone library project file if attribute\n-      --  Library_Interface is defined.\n+      --  It is a stand-alone library project file if there is at least one\n+      --  unit in the declared or inherited interface.\n \n-      if Lib_Interfaces.Default then\n+      if Project.Lib_Interface_ALIs = Nil_String then\n          if not Lib_Standalone.Default\n            and then Get_Name_String (Lib_Standalone.Value) /= \"no\"\n          then\n@@ -4349,6 +4391,10 @@ package body Prj.Nmsc is\n          end if;\n \n       else\n+         if Project.Standalone_Library = No then\n+            Project.Standalone_Library := Standard;\n+         end if;\n+\n          --  The name of a stand-alone library needs to have the syntax of an\n          --  Ada identifier.\n \n@@ -4388,198 +4434,74 @@ package body Prj.Nmsc is\n             end if;\n          end;\n \n-         declare\n-            Interfaces     : String_List_Id := Lib_Interfaces.Values;\n-            Interface_ALIs : String_List_Id := Nil_String;\n-            Unit           : Name_Id;\n-\n-         begin\n-            if Lib_Standalone.Default then\n-               Project.Standalone_Library := Standard;\n-\n-            else\n-               Get_Name_String (Lib_Standalone.Value);\n-               To_Lower (Name_Buffer (1 .. Name_Len));\n-\n-               if Name_Buffer (1 .. Name_Len) = \"standard\" then\n-                  Project.Standalone_Library := Standard;\n+         if Lib_Standalone.Default then\n+            Project.Standalone_Library := Standard;\n \n-               elsif Name_Buffer (1 .. Name_Len) = \"encapsulated\" then\n-                  Project.Standalone_Library := Encapsulated;\n+         else\n+            Get_Name_String (Lib_Standalone.Value);\n+            To_Lower (Name_Buffer (1 .. Name_Len));\n \n-               elsif Name_Buffer (1 .. Name_Len) = \"no\" then\n-                  Project.Standalone_Library := No;\n-                  Error_Msg\n-                    (Data.Flags,\n-                     \"wrong value for Library_Standalone \"\n-                     & \"when Library_Interface defined\",\n-                     Lib_Standalone.Location, Project);\n+            if Name_Buffer (1 .. Name_Len) = \"standard\" then\n+               Project.Standalone_Library := Standard;\n \n-               else\n-                  Error_Msg\n-                    (Data.Flags,\n-                     \"invalid value for attribute Library_Standalone\",\n-                     Lib_Standalone.Location, Project);\n-               end if;\n-            end if;\n+            elsif Name_Buffer (1 .. Name_Len) = \"encapsulated\" then\n+               Project.Standalone_Library := Encapsulated;\n \n-            --  Library_Interface cannot be an empty list\n+            elsif Name_Buffer (1 .. Name_Len) = \"no\" then\n+               Project.Standalone_Library := No;\n+               Error_Msg\n+                 (Data.Flags,\n+                  \"wrong value for Library_Standalone \"\n+                  & \"when Library_Interface defined\",\n+                  Lib_Standalone.Location, Project);\n \n-            if Interfaces = Nil_String then\n+            else\n                Error_Msg\n                  (Data.Flags,\n-                  \"Library_Interface cannot be an empty list\",\n-                  Lib_Interfaces.Location, Project);\n+                  \"invalid value for attribute Library_Standalone\",\n+                  Lib_Standalone.Location, Project);\n             end if;\n+         end if;\n \n-            --  Process each unit name specified in the attribute\n-            --  Library_Interface.\n-\n-            while Interfaces /= Nil_String loop\n-               Get_Name_String\n-                 (Shared.String_Elements.Table (Interfaces).Value);\n-               To_Lower (Name_Buffer (1 .. Name_Len));\n-\n-               if Name_Len = 0 then\n-                  Error_Msg\n-                    (Data.Flags,\n-                     \"an interface cannot be an empty string\",\n-                     Shared.String_Elements.Table (Interfaces).Location,\n-                     Project);\n-\n-               else\n-                  Unit := Name_Find;\n-                  Error_Msg_Name_1 := Unit;\n-\n-                  Next_Proj := Project.Extends;\n-\n-                  if Project.Qualifier = Aggregate_Library then\n-\n-                     --  For an aggregate library we want to consider sources\n-                     --  of all aggregated projects.\n-\n-                     Iter := For_Each_Source (Data.Tree);\n-\n-                  else\n-                     Iter := For_Each_Source (Data.Tree, Project);\n-                  end if;\n-\n-                  loop\n-                     while Prj.Element (Iter) /= No_Source\n-                       and then\n-                         (Prj.Element (Iter).Unit = null\n-                           or else Prj.Element (Iter).Unit.Name /= Unit)\n-                     loop\n-                        Next (Iter);\n-                     end loop;\n-\n-                     Source := Prj.Element (Iter);\n-                     exit when Source /= No_Source\n-                       or else Next_Proj = No_Project;\n-\n-                     Iter := For_Each_Source (Data.Tree, Next_Proj);\n-                     Next_Proj := Next_Proj.Extends;\n-                  end loop;\n-\n-                  if Source /= No_Source then\n-                     if Source.Kind = Sep then\n-                        Source := No_Source;\n-\n-                     elsif Source.Kind = Spec\n-                       and then Other_Part (Source) /= No_Source\n-                     then\n-                        Source := Other_Part (Source);\n-                     end if;\n-                  end if;\n-\n-                  if Source /= No_Source then\n-                     if Source.Project /= Project\n-                       and then not Is_Extending (Project, Source.Project)\n-                       and then Project.Qualifier /= Aggregate_Library\n-                     then\n-                        Source := No_Source;\n-                     end if;\n-                  end if;\n-\n-                  if Source = No_Source then\n-                     Error_Msg\n-                       (Data.Flags,\n-                        \"%% is not a unit of this project\",\n-                        Shared.String_Elements.Table (Interfaces).Location,\n-                        Project);\n-\n-                  else\n-                     if Source.Kind = Spec\n-                       and then Other_Part (Source) /= No_Source\n-                     then\n-                        Source := Other_Part (Source);\n-                     end if;\n-\n-                     String_Element_Table.Increment_Last\n-                       (Shared.String_Elements);\n-\n-                     Shared.String_Elements.Table\n-                       (String_Element_Table.Last (Shared.String_Elements)) :=\n-                         (Value         => Name_Id (Source.Dep_Name),\n-                          Index         => 0,\n-                          Display_Value => Name_Id (Source.Dep_Name),\n-                          Location      =>\n-                            Shared.String_Elements.Table (Interfaces).Location,\n-                          Flag          => False,\n-                          Next          => Interface_ALIs);\n-\n-                     Interface_ALIs :=\n-                       String_Element_Table.Last (Shared.String_Elements);\n-                  end if;\n-               end if;\n-\n-               Interfaces := Shared.String_Elements.Table (Interfaces).Next;\n-            end loop;\n-\n-            --  Put the list of Interface ALIs in the project data\n-\n-            Project.Lib_Interface_ALIs := Interface_ALIs;\n-\n-            --  Check value of attribute Library_Auto_Init and set\n-            --  Lib_Auto_Init accordingly.\n-\n-            if Lib_Auto_Init.Default then\n-\n-               --  If no attribute Library_Auto_Init is declared, then set auto\n-               --  init only if it is supported.\n+         --  Check value of attribute Library_Auto_Init and set\n+         --  Lib_Auto_Init accordingly.\n \n-               Project.Lib_Auto_Init := Auto_Init_Supported;\n+         if Lib_Auto_Init.Default then\n \n-            else\n-               Get_Name_String (Lib_Auto_Init.Value);\n-               To_Lower (Name_Buffer (1 .. Name_Len));\n+            --  If no attribute Library_Auto_Init is declared, then set auto\n+            --  init only if it is supported.\n \n-               if Name_Buffer (1 .. Name_Len) = \"false\" then\n-                  Project.Lib_Auto_Init := False;\n+            Project.Lib_Auto_Init := Auto_Init_Supported;\n \n-               elsif Name_Buffer (1 .. Name_Len) = \"true\" then\n-                  if Auto_Init_Supported then\n-                     Project.Lib_Auto_Init := True;\n+         else\n+            Get_Name_String (Lib_Auto_Init.Value);\n+            To_Lower (Name_Buffer (1 .. Name_Len));\n \n-                  else\n-                     --  Library_Auto_Init cannot be \"true\" if auto init is not\n-                     --  supported.\n+            if Name_Buffer (1 .. Name_Len) = \"false\" then\n+               Project.Lib_Auto_Init := False;\n \n-                     Error_Msg\n-                       (Data.Flags,\n-                        \"library auto init not supported \" &\n-                        \"on this platform\",\n-                        Lib_Auto_Init.Location, Project);\n-                  end if;\n+            elsif Name_Buffer (1 .. Name_Len) = \"true\" then\n+               if Auto_Init_Supported then\n+                  Project.Lib_Auto_Init := True;\n \n                else\n+                  --  Library_Auto_Init cannot be \"true\" if auto init is not\n+                  --  supported.\n+\n                   Error_Msg\n                     (Data.Flags,\n-                     \"invalid value for attribute Library_Auto_Init\",\n+                     \"library auto init not supported \" &\n+                     \"on this platform\",\n                      Lib_Auto_Init.Location, Project);\n                end if;\n+\n+            else\n+               Error_Msg\n+                 (Data.Flags,\n+                  \"invalid value for attribute Library_Auto_Init\",\n+                  Lib_Auto_Init.Location, Project);\n             end if;\n-         end;\n+         end if;\n \n          --  If attribute Library_Src_Dir is defined and not the empty string,\n          --  check if the directory exist and is not the object directory or"}, {"sha": "f4226c21c6f27498c1cbf9ba77473390ebabe11f", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6e4fc49410404bb589a382822a37656b37c577/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6e4fc49410404bb589a382822a37656b37c577/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=de6e4fc49410404bb589a382822a37656b37c577", "patch": "@@ -443,7 +443,13 @@ package body Prj is\n \n       if Iter.Language = No_Language_Index then\n          if Iter.All_Projects then\n-            Iter.Project := Iter.Project.Next;\n+            loop\n+               Iter.Project := Iter.Project.Next;\n+               exit when Iter.Project = null\n+                 or else Iter.Encapsulated_Libs\n+                 or else not Iter.Project.From_Encapsulated_Lib;\n+            end loop;\n+\n             Project_Changed (Iter);\n          else\n             Iter.Project := null;\n@@ -464,26 +470,35 @@ package body Prj is\n    ---------------------\n \n    function For_Each_Source\n-     (In_Tree  : Project_Tree_Ref;\n-      Project  : Project_Id := No_Project;\n-      Language : Name_Id := No_Name) return Source_Iterator\n+     (In_Tree           : Project_Tree_Ref;\n+      Project           : Project_Id := No_Project;\n+      Language          : Name_Id := No_Name;\n+      Encapsulated_Libs : Boolean := True) return Source_Iterator\n    is\n       Iter : Source_Iterator;\n    begin\n       Iter := Source_Iterator'\n-        (In_Tree       => In_Tree,\n-         Project       => In_Tree.Projects,\n-         All_Projects  => Project = No_Project,\n-         Language_Name => Language,\n-         Language      => No_Language_Index,\n-         Current       => No_Source);\n+        (In_Tree           => In_Tree,\n+         Project           => In_Tree.Projects,\n+         All_Projects      => Project = No_Project,\n+         Language_Name     => Language,\n+         Language          => No_Language_Index,\n+         Current           => No_Source,\n+         Encapsulated_Libs => Encapsulated_Libs);\n \n       if Project /= null then\n          while Iter.Project /= null\n            and then Iter.Project.Project /= Project\n          loop\n             Iter.Project := Iter.Project.Next;\n          end loop;\n+\n+      else\n+         while not Iter.Encapsulated_Libs\n+           and then Iter.Project.From_Encapsulated_Lib\n+         loop\n+            Iter.Project := Iter.Project.Next;\n+         end loop;\n       end if;\n \n       Project_Changed (Iter);"}, {"sha": "830f51158c52d7c0b49088ec9f0a9f010e4b692f", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6e4fc49410404bb589a382822a37656b37c577/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6e4fc49410404bb589a382822a37656b37c577/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=de6e4fc49410404bb589a382822a37656b37c577", "patch": "@@ -1180,7 +1180,8 @@ package Prj is\n       --  True for virtual extending projects\n \n       Location : Source_Ptr := No_Location;\n-      --  The location in the project file source of the reserved word project\n+      --  The location in the project file source of the project name that\n+      --  immediately follows the reserved word \"project\".\n \n       ---------------\n       -- Languages --\n@@ -1405,11 +1406,13 @@ package Prj is\n    type Source_Iterator is private;\n \n    function For_Each_Source\n-     (In_Tree  : Project_Tree_Ref;\n-      Project  : Project_Id := No_Project;\n-      Language : Name_Id := No_Name) return Source_Iterator;\n+     (In_Tree           : Project_Tree_Ref;\n+      Project           : Project_Id := No_Project;\n+      Language          : Name_Id := No_Name;\n+      Encapsulated_Libs : Boolean := True) return Source_Iterator;\n    --  Returns an iterator for all the sources of a project tree, or a specific\n-   --  project, or a specific language.\n+   --  project, or a specific language. Include sources from aggregated libs if\n+   --  Aggregated_Libs is True.\n \n    function Element (Iter : Source_Iterator) return Source_Id;\n    --  Return the current source (or No_Source if there are no more sources)\n@@ -1847,7 +1850,10 @@ private\n       Language_Name : Name_Id;\n       --  Only sources of this language will be returned (or all if No_Name)\n \n-      Current : Source_Id;\n+      Current      : Source_Id;\n+\n+      Encapsulated_Libs : Boolean;\n+      --  True if we want to include the sources from encapsulated libs\n    end record;\n \n    procedure Add_To_Buffer"}, {"sha": "d3761b386c93cbbc9273b5d3d1397aac594f72f3", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6e4fc49410404bb589a382822a37656b37c577/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6e4fc49410404bb589a382822a37656b37c577/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=de6e4fc49410404bb589a382822a37656b37c577", "patch": "@@ -1423,6 +1423,9 @@ package body Sem_Ch13 is\n                   --  Make sure we have a freeze node (it might otherwise be\n                   --  missing in cases like subtype X is Y, and we would not\n                   --  have a place to build the predicate function).\n+                  --  If the type is private, indicate that its completion\n+                  --  has a freeze node, because that is the one that will be\n+                  --  visible at freeze time.\n \n                   Set_Has_Predicates (E);\n \n@@ -1431,6 +1434,7 @@ package body Sem_Ch13 is\n                   then\n                      Set_Has_Predicates (Full_View (E));\n                      Set_Has_Delayed_Aspects (Full_View (E));\n+                     Ensure_Freeze_Node (Full_View (E));\n                   end if;\n \n                   Ensure_Freeze_Node (E);\n@@ -5056,6 +5060,14 @@ package body Sem_Ch13 is\n          Set_Has_Predicates (SId);\n          Set_Predicate_Function (Typ, SId);\n \n+         --  The predicate function is shared between views of a type.\n+\n+         if Is_Private_Type (Typ)\n+           and then Present (Full_View (Typ))\n+         then\n+            Set_Predicate_Function (Full_View (Typ), SId);\n+         end if;\n+\n          Spec :=\n            Make_Function_Specification (Loc,\n              Defining_Unit_Name       => SId,"}, {"sha": "3afea799d853c78f12b33c05a8c1c9e278c13a83", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6e4fc49410404bb589a382822a37656b37c577/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6e4fc49410404bb589a382822a37656b37c577/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=de6e4fc49410404bb589a382822a37656b37c577", "patch": "@@ -18180,7 +18180,7 @@ package body Sem_Ch3 is\n \n       if Has_Predicates (Priv_T) then\n          Set_Predicate_Function (Priv_T, Predicate_Function (Full_T));\n-         Set_Has_Predicates (Priv_T);\n+         Set_Has_Predicates (Full_T);\n       end if;\n    end Process_Full_View;\n "}]}