{"sha": "a459ee44c0a74b0df0485ed7a56683816c02aae9", "node_id": "C_kwDOANBUbNoAKGE0NTllZTQ0YzBhNzRiMGRmMDQ4NWVkN2E1NjY4MzgxNmMwMmFhZTk", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2021-09-29T10:21:45Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2021-09-29T10:21:45Z"}, "message": "aarch64: Improve size heuristic for cpymem expansion\n\nSimilar to my previous patch for setmem this one does the same for the cpymem expansion.\nWe count the number of ops emitted and compare it against the alternative of just calling\nthe library function when optimising for size.\nFor the code:\nvoid\ncpy_127 (char *out, char *in)\n{\n  __builtin_memcpy (out, in, 127);\n}\n\nvoid\ncpy_128 (char *out, char *in)\n{\n  __builtin_memcpy (out, in, 128);\n}\n\nwe now emit a call to memcpy (with an extra MOV-immediate instruction for the size) instead of:\ncpy_127(char*, char*):\n        ldp     q0, q1, [x1]\n        stp     q0, q1, [x0]\n        ldp     q0, q1, [x1, 32]\n        stp     q0, q1, [x0, 32]\n        ldp     q0, q1, [x1, 64]\n        stp     q0, q1, [x0, 64]\n        ldr     q0, [x1, 96]\n        str     q0, [x0, 96]\n        ldr     q0, [x1, 111]\n        str     q0, [x0, 111]\n        ret\ncpy_128(char*, char*):\n        ldp     q0, q1, [x1]\n        stp     q0, q1, [x0]\n        ldp     q0, q1, [x1, 32]\n        stp     q0, q1, [x0, 32]\n        ldp     q0, q1, [x1, 64]\n        stp     q0, q1, [x0, 64]\n        ldp     q0, q1, [x1, 96]\n        stp     q0, q1, [x0, 96]\n        ret\n\nwhich is a clear code size win. Speed optimisation heuristics remain unchanged.\n\n2021-09-29  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n\n\t* config/aarch64/aarch64.c (aarch64_expand_cpymem): Count number of\n\temitted operations and adjust heuristic for code size.\n\n2021-09-29  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n\n\t* gcc.target/aarch64/cpymem-size.c: New test.", "tree": {"sha": "28120613b6c3f40a1f797cab6d68499117140a49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28120613b6c3f40a1f797cab6d68499117140a49"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a459ee44c0a74b0df0485ed7a56683816c02aae9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a459ee44c0a74b0df0485ed7a56683816c02aae9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a459ee44c0a74b0df0485ed7a56683816c02aae9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a459ee44c0a74b0df0485ed7a56683816c02aae9/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f95e3c04d659d541ca4937b3df2f1175a1c5f05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f95e3c04d659d541ca4937b3df2f1175a1c5f05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f95e3c04d659d541ca4937b3df2f1175a1c5f05"}], "stats": {"total": 65, "additions": 54, "deletions": 11}, "files": [{"sha": "a9a1800af53b18306465e382e9dd149d0e335b09", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a459ee44c0a74b0df0485ed7a56683816c02aae9/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a459ee44c0a74b0df0485ed7a56683816c02aae9/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=a459ee44c0a74b0df0485ed7a56683816c02aae9", "patch": "@@ -23390,7 +23390,8 @@ aarch64_copy_one_block_and_progress_pointers (rtx *src, rtx *dst,\n }\n \n /* Expand cpymem, as if from a __builtin_memcpy.  Return true if\n-   we succeed, otherwise return false.  */\n+   we succeed, otherwise return false, indicating that a libcall to\n+   memcpy should be emitted.  */\n \n bool\n aarch64_expand_cpymem (rtx *operands)\n@@ -23407,11 +23408,13 @@ aarch64_expand_cpymem (rtx *operands)\n \n   unsigned HOST_WIDE_INT size = INTVAL (operands[2]);\n \n-  /* Inline up to 256 bytes when optimizing for speed.  */\n+  /* Try to inline up to 256 bytes.  */\n   unsigned HOST_WIDE_INT max_copy_size = 256;\n \n-  if (optimize_function_for_size_p (cfun))\n-    max_copy_size = 128;\n+  bool size_p = optimize_function_for_size_p (cfun);\n+\n+  if (size > max_copy_size)\n+    return false;\n \n   int copy_bits = 256;\n \n@@ -23421,13 +23424,14 @@ aarch64_expand_cpymem (rtx *operands)\n       || !TARGET_SIMD\n       || (aarch64_tune_params.extra_tuning_flags\n \t  & AARCH64_EXTRA_TUNE_NO_LDP_STP_QREGS))\n-    {\n-      copy_bits = 128;\n-      max_copy_size = max_copy_size / 2;\n-    }\n+    copy_bits = 128;\n \n-  if (size > max_copy_size)\n-    return false;\n+  /* Emit an inline load+store sequence and count the number of operations\n+     involved.  We use a simple count of just the loads and stores emitted\n+     rather than rtx_insn count as all the pointer adjustments and reg copying\n+     in this function will get optimized away later in the pipeline.  */\n+  start_sequence ();\n+  unsigned nops = 0;\n \n   base = copy_to_mode_reg (Pmode, XEXP (dst, 0));\n   dst = adjust_automodify_address (dst, VOIDmode, base, 0);\n@@ -23456,7 +23460,8 @@ aarch64_expand_cpymem (rtx *operands)\n \tcur_mode = V4SImode;\n \n       aarch64_copy_one_block_and_progress_pointers (&src, &dst, cur_mode);\n-\n+      /* A single block copy is 1 load + 1 store.  */\n+      nops += 2;\n       n -= mode_bits;\n \n       /* Emit trailing copies using overlapping unaligned accesses - this is\n@@ -23471,7 +23476,16 @@ aarch64_expand_cpymem (rtx *operands)\n \t  n = n_bits;\n \t}\n     }\n+  rtx_insn *seq = get_insns ();\n+  end_sequence ();\n+\n+  /* A memcpy libcall in the worst case takes 3 instructions to prepare the\n+     arguments + 1 for the call.  */\n+  unsigned libcall_cost = 4;\n+  if (size_p && libcall_cost < nops)\n+    return false;\n \n+  emit_insn (seq);\n   return true;\n }\n "}, {"sha": "4d488b74301dd6bf6321372a0985771b0e4d5c07", "filename": "gcc/testsuite/gcc.target/aarch64/cpymem-size.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a459ee44c0a74b0df0485ed7a56683816c02aae9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fcpymem-size.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a459ee44c0a74b0df0485ed7a56683816c02aae9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fcpymem-size.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fcpymem-size.c?ref=a459ee44c0a74b0df0485ed7a56683816c02aae9", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Os\" } */\n+\n+#include <stdlib.h>\n+\n+/*\n+** cpy_127:\n+**      mov\tx2, 127\n+**      b\tmemcpy\n+*/\n+void\n+cpy_127 (char *out, char *in)\n+{\n+  __builtin_memcpy (out, in, 127);\n+}\n+\n+/*\n+** cpy_128:\n+**      mov\tx2, 128\n+**      b\tmemcpy\n+*/\n+void\n+cpy_128 (char *out, char *in)\n+{\n+  __builtin_memcpy (out, in, 128);\n+}\n+\n+/* { dg-final { check-function-bodies \"**\" \"\" \"\" } } */\n+"}]}